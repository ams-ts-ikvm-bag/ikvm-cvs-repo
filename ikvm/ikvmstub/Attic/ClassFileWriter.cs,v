head	1.11;
access;
symbols
	v7_2_4630_6:1.10
	v7_2_4630_5:1.10
	v7_2_4630_4:1.10
	v7_2_4630_3:1.10
	v7_2_4630_2:1.10
	v0_46_0_4:1.10
	v7_2_4630_1:1.10
	v7_2:1.10.0.10
	v7_1_4532_2:1.10
	v7_1_4532_1:1.10
	v7_1_4532_0:1.10
	v7_1:1.10.0.8
	v7_0_4335_3:1.10
	v7_0_4335_2:1.10
	v7_0_4335_1:1.10
	v0_46_0_2:1.10
	v7_0_4335_0:1.10
	v7_0:1.10.0.6
	v0_46_0_1:1.10
	v0_46_0_0:1.10
	v0_46:1.10.0.4
	v0_44_0_6:1.10
	v0_44_0_5:1.10
	v0_44_0_4:1.10
	v0_44_0_3:1.10
	v0_44_0_2:1.10
	v0_44_0_1:1.10
	v0_44_0_0:1.10
	v0_44:1.10.0.2
	v0_30:1.8.0.2
	v0_28_0_0:1.6
	v0_26_0_1:1.6
	v0_26_0_0:1.6
	v0_24_0_1:1.6
	v0_24_0_0:1.6
	v0_22_0_0:1.6
	v0_20_0_0:1.5
	v0_18_0_0:1.5
	v0_16_0_0:1.5
	v0_14_0_1:1.5
	v0_14_0_0:1.5
	v0_12_0_0:1.5
	v0_10_0_1:1.3
	v0_10_0_0:1.3
	v0_8_0_0:1.1;
locks; strict;
comment	@ * @;


1.11
date	2013.02.21.16.56.08;	author jfrijters;	state dead;
branches;
next	1.10;

1.10
date	2010.01.28.07.29.22;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.04.12.39.33;	author jfrijters;	state dead;
branches;
next	1.8;

1.8
date	2006.06.20.14.31.59;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.15.12.29.12;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.01.11.16.12;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.02.15.25.02;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.02.15.12.03;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.16.11.11.54;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.10;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Removed the old Java stub class generator and replaced it with the ikvmstub core.
@
text
@/*
  Copyright (C) 2002 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.IO;
using System.Collections;
using IKVM.Attributes;

namespace IKVM.StubGen
{
	sealed class BigEndianStream
	{
		private Stream stream;

		public BigEndianStream(Stream stream)
		{
			this.stream = stream;
		}

		public void WriteUInt16(ushort s)
		{
			stream.WriteByte((byte)(s >> 8));
			stream.WriteByte((byte)s);
		}

		public void WriteUInt32(uint u)
		{
			stream.WriteByte((byte)(u >> 24));
			stream.WriteByte((byte)(u >> 16));
			stream.WriteByte((byte)(u >> 8));
			stream.WriteByte((byte)u);
		}

		public void WriteInt64(long l)
		{
			WriteUInt32((uint)(l >> 32));
			WriteUInt32((uint)l);
		}

		public void WriteFloat(float f)
		{
			WriteUInt32(BitConverter.ToUInt32(BitConverter.GetBytes(f), 0));
		}

		public void WriteDouble(double d)
		{
			WriteInt64(BitConverter.ToInt64(BitConverter.GetBytes(d), 0));
		}

		public void WriteByte(byte b)
		{
			stream.WriteByte(b);
		}

		public void WriteUtf8(string str)
		{
			byte[] buf = new byte[str.Length * 3 + 1];
			int j = 0;
			for (int i = 0, e = str.Length; i < e; i++)
			{
				char ch = str[i];
				if ((ch != 0) && (ch <= 0x7f))
				{
					buf[j++] = (byte)ch;
				}
				else if (ch <= 0x7FF)
				{
					/* 11 bits or less. */
					byte high_five = (byte)(ch >> 6);
					byte low_six = (byte)(ch & 0x3F);
					buf[j++] = (byte)(high_five | 0xC0); /* 110xxxxx */
					buf[j++] = (byte)(low_six | 0x80);   /* 10xxxxxx */
				}
				else
				{
					/* possibly full 16 bits. */
					byte high_four = (byte)(ch >> 12);
					byte mid_six = (byte)((ch >> 6) & 0x3F);
					byte low_six = (byte)(ch & 0x3f);
					buf[j++] = (byte)(high_four | 0xE0); /* 1110xxxx */
					buf[j++] = (byte)(mid_six | 0x80);   /* 10xxxxxx */
					buf[j++] = (byte)(low_six | 0x80);   /* 10xxxxxx*/
				}
			}
			WriteUInt16((ushort)j);
			stream.Write(buf, 0, j);
		}
	}

	enum Constant
	{
		Utf8 = 1,
		Integer = 3,
		Float = 4,
		Long = 5,
		Double = 6,
		Class = 7,
		String = 8,
		Fieldref = 9,
		Methodref = 10,
		InterfaceMethodref = 11,
		NameAndType = 12
	}

	abstract class ConstantPoolItem
	{
		public abstract void Write(BigEndianStream bes);
	}

	sealed class ConstantPoolItemClass : ConstantPoolItem
	{
		private ushort name_index;

		public ConstantPoolItemClass(ushort name_index)
		{
			this.name_index = name_index;
		}

		public override int GetHashCode()
		{
			return name_index;
		}

		public override bool Equals(object o)
		{
			if (o != null && o.GetType() == typeof(ConstantPoolItemClass))
			{
				return ((ConstantPoolItemClass)o).name_index == name_index;
			}
			return false;
		}

		public override void Write(BigEndianStream bes)
		{
			bes.WriteByte((byte)Constant.Class);
			bes.WriteUInt16(name_index);
		}
	}

	sealed class ConstantPoolItemMethodref : ConstantPoolItem
	{
		private ushort class_index;
		private ushort name_and_type_index;

		public ConstantPoolItemMethodref(ushort class_index, ushort name_and_type_index)
		{
			this.class_index = class_index;
			this.name_and_type_index = name_and_type_index;
		}

		public override int GetHashCode()
		{
			return class_index | (name_and_type_index << 16);
		}

		public override bool Equals(object o)
		{
			if (o != null && o.GetType() == typeof(ConstantPoolItemMethodref))
			{
				ConstantPoolItemMethodref m = (ConstantPoolItemMethodref)o;
				return m.class_index == class_index && m.name_and_type_index == name_and_type_index;
			}
			return false;
		}

		public override void Write(BigEndianStream bes)
		{
			bes.WriteByte((byte)Constant.Methodref);
			bes.WriteUInt16(class_index);
			bes.WriteUInt16(name_and_type_index);
		}
	}

	sealed class ConstantPoolItemNameAndType : ConstantPoolItem
	{
		private ushort name_index;
		private ushort descriptor_index;

		public ConstantPoolItemNameAndType(ushort name_index, ushort descriptor_index)
		{
			this.name_index = name_index;
			this.descriptor_index = descriptor_index;
		}

		public override int GetHashCode()
		{
			return name_index | (descriptor_index << 16);
		}

		public override bool Equals(object o)
		{
			if (o != null && o.GetType() == typeof(ConstantPoolItemNameAndType))
			{
				ConstantPoolItemNameAndType n = (ConstantPoolItemNameAndType)o;
				return n.name_index == name_index && n.descriptor_index == descriptor_index;
			}
			return false;
		}

		public override void Write(BigEndianStream bes)
		{
			bes.WriteByte((byte)Constant.NameAndType);
			bes.WriteUInt16(name_index);
			bes.WriteUInt16(descriptor_index);
		}
	}

	sealed class ConstantPoolItemUtf8 : ConstantPoolItem
	{
		private string str;

		public ConstantPoolItemUtf8(string str)
		{
			this.str = str;
		}

		public override int GetHashCode()
		{
			return str.GetHashCode();
		}

		public override bool Equals(object o)
		{
			if (o != null && o.GetType() == typeof(ConstantPoolItemUtf8))
			{
				return ((ConstantPoolItemUtf8)o).str == str;
			}
			return false;
		}

		public override void Write(BigEndianStream bes)
		{
			bes.WriteByte((byte)Constant.Utf8);
			bes.WriteUtf8(str);
		}
	}

	sealed class ConstantPoolItemInt : ConstantPoolItem
	{
		private int v;

		public ConstantPoolItemInt(int v)
		{
			this.v = v;
		}

		public override int GetHashCode()
		{
			return v;
		}

		public override bool Equals(object o)
		{
			if (o != null && o.GetType() == typeof(ConstantPoolItemInt))
			{
				return ((ConstantPoolItemInt)o).v == v;
			}
			return false;
		}

		public override void Write(BigEndianStream bes)
		{
			bes.WriteByte((byte)Constant.Integer);
			bes.WriteUInt32((uint)v);
		}
	}

	sealed class ConstantPoolItemLong : ConstantPoolItem
	{
		private long v;

		public ConstantPoolItemLong(long v)
		{
			this.v = v;
		}

		public override int GetHashCode()
		{
			return (int)v;
		}

		public override bool Equals(object o)
		{
			if (o != null && o.GetType() == typeof(ConstantPoolItemLong))
			{
				return ((ConstantPoolItemLong)o).v == v;
			}
			return false;
		}

		public override void Write(BigEndianStream bes)
		{
			bes.WriteByte((byte)Constant.Long);
			bes.WriteInt64(v);
		}
	}

	sealed class ConstantPoolItemFloat : ConstantPoolItem
	{
		private float v;

		public ConstantPoolItemFloat(float v)
		{
			this.v = v;
		}

		public override int GetHashCode()
		{
			return BitConverter.ToInt32(BitConverter.GetBytes(v), 0);
		}

		public override bool Equals(object o)
		{
			if (o != null && o.GetType() == typeof(ConstantPoolItemFloat))
			{
				return ((ConstantPoolItemFloat)o).v == v;
			}
			return false;
		}

		public override void Write(BigEndianStream bes)
		{
			bes.WriteByte((byte)Constant.Float);
			bes.WriteFloat(v);
		}
	}

	sealed class ConstantPoolItemDouble : ConstantPoolItem
	{
		private double v;

		public ConstantPoolItemDouble(double v)
		{
			this.v = v;
		}

		public override int GetHashCode()
		{
			long l = BitConverter.DoubleToInt64Bits(v);
			return ((int)l) ^ ((int)(l >> 32));
		}

		public override bool Equals(object o)
		{
			if (o != null && o.GetType() == typeof(ConstantPoolItemDouble))
			{
				return ((ConstantPoolItemDouble)o).v == v;
			}
			return false;
		}

		public override void Write(BigEndianStream bes)
		{
			bes.WriteByte((byte)Constant.Double);
			bes.WriteDouble(v);
		}
	}

	sealed class ConstantPoolItemString : ConstantPoolItem
	{
		private ushort string_index;

		public ConstantPoolItemString(ushort string_index)
		{
			this.string_index = string_index;
		}

		public override int GetHashCode()
		{
			return string_index;
		}

		public override bool Equals(object o)
		{
			if (o != null && o.GetType() == typeof(ConstantPoolItemString))
			{
				return ((ConstantPoolItemString)o).string_index == string_index;
			}
			return false;
		}

		public override void Write(BigEndianStream bes)
		{
			bes.WriteByte((byte)Constant.String);
			bes.WriteUInt16(string_index);
		}
	}

	abstract class ClassFileAttribute
	{
		private ushort name_index;

		public ClassFileAttribute(ushort name_index)
		{
			this.name_index = name_index;
		}

		public virtual void Write(BigEndianStream bes)
		{
			bes.WriteUInt16(name_index);
		}
	}

	sealed class DeprecatedAttribute : ClassFileAttribute
	{
		internal DeprecatedAttribute(ClassFileWriter classFile)
			: base(classFile.AddUtf8("Deprecated"))
		{
		}

		public override void Write(BigEndianStream bes)
		{
			base.Write(bes);
			bes.WriteUInt32(0);
		}
	}

	sealed class ConstantValueAttribute : ClassFileAttribute
	{
		private ushort constant_index;

		public ConstantValueAttribute(ushort name_index, ushort constant_index)
			: base(name_index)
		{
			this.constant_index = constant_index;
		}

		public override void Write(BigEndianStream bes)
		{
			base.Write(bes);
			bes.WriteUInt32(2);
			bes.WriteUInt16(constant_index);
		}
	}

	sealed class StringAttribute : ClassFileAttribute
	{
		private ushort string_index;

		public StringAttribute(ushort name_index, ushort string_index)
			: base(name_index)
		{
			this.string_index = string_index;
		}

		public override void Write(BigEndianStream bes)
		{
			base.Write(bes);
			bes.WriteUInt32(2);
			bes.WriteUInt16(string_index);
		}
	}

	sealed class InnerClassesAttribute : ClassFileAttribute
	{
		private ClassFileWriter classFile;
		private ArrayList classes = new ArrayList();

		public InnerClassesAttribute(ClassFileWriter classFile)
			: base(classFile.AddUtf8("InnerClasses"))
		{
			this.classFile = classFile;
		}

		public override void Write(BigEndianStream bes)
		{
			base.Write(bes);
			bes.WriteUInt32((uint)(2 + 8 * classes.Count));
			bes.WriteUInt16((ushort)classes.Count);
			foreach (Item i in classes)
			{
				bes.WriteUInt16(i.inner_class_info_index);
				bes.WriteUInt16(i.outer_class_info_index);
				bes.WriteUInt16(i.inner_name_index);
				bes.WriteUInt16(i.inner_class_access_flags);
			}
		}

		private class Item
		{
			internal ushort inner_class_info_index;
			internal ushort outer_class_info_index;
			internal ushort inner_name_index;
			internal ushort inner_class_access_flags;
		}

		public void Add(string inner, string outer, string name, ushort access)
		{
			Item i = new Item();
			i.inner_class_info_index = classFile.AddClass(inner);
			i.outer_class_info_index = classFile.AddClass(outer);
			if (name != null)
			{
				i.inner_name_index = classFile.AddUtf8(name);
			}
			i.inner_class_access_flags = access;
			classes.Add(i);
		}
	}

	sealed class ExceptionsAttribute : ClassFileAttribute
	{
		private ClassFileWriter classFile;
		private ArrayList classes = new ArrayList();

		internal ExceptionsAttribute(ClassFileWriter classFile)
			: base(classFile.AddUtf8("Exceptions"))
		{
			this.classFile = classFile;
		}

		internal void Add(string exceptionClass)
		{
			classes.Add(classFile.AddClass(exceptionClass));
		}

		public override void Write(BigEndianStream bes)
		{
			base.Write(bes);
			bes.WriteUInt32((uint)(2 + 2 * classes.Count));
			bes.WriteUInt16((ushort)classes.Count);
			foreach (ushort idx in classes)
			{
				bes.WriteUInt16(idx);
			}
		}
	}

	sealed class RuntimeVisibleAnnotationsAttribute : ClassFileAttribute
	{
		private ClassFileWriter classFile;
		private MemoryStream mem;
		private BigEndianStream bes;
		private ushort count;

		internal RuntimeVisibleAnnotationsAttribute(ClassFileWriter classFile)
			: base(classFile.AddUtf8("RuntimeVisibleAnnotations"))
		{
			this.classFile = classFile;
			mem = new MemoryStream();
			bes = new BigEndianStream(mem);
		}

		internal void Add(object[] annot)
		{
			count++;
			bes.WriteUInt16(classFile.AddUtf8((string)annot[1]));
			bes.WriteUInt16((ushort)((annot.Length - 2) / 2));
			for (int i = 2; i < annot.Length; i += 2)
			{
				bes.WriteUInt16(classFile.AddUtf8((string)annot[i]));
				WriteElementValue(bes, annot[i + 1]);
			}
		}

		private void WriteElementValue(BigEndianStream bes, object val)
		{
			if (val is object[])
			{
				object[] arr = (object[])val;
				if (AnnotationDefaultAttribute.TAG_ENUM.Equals(arr[0]))
				{
					bes.WriteByte(AnnotationDefaultAttribute.TAG_ENUM);
					bes.WriteUInt16(classFile.AddUtf8((string)arr[1]));
					bes.WriteUInt16(classFile.AddUtf8((string)arr[2]));
					return;
				}
				else if (AnnotationDefaultAttribute.TAG_ARRAY.Equals(arr[0]))
				{
					bes.WriteByte(AnnotationDefaultAttribute.TAG_ARRAY);
					object[] elemarr = (object[])arr[1];
					bes.WriteUInt16((ushort)elemarr.Length);
					foreach (object elem in elemarr)
					{
						WriteElementValue(bes, elem);
					}
					return;
				}
			}
			throw new NotImplementedException(val.GetType().FullName);
		}

		public override void Write(BigEndianStream bes)
		{
			base.Write(bes);
			bes.WriteUInt32((uint)(mem.Length + 2));
			bes.WriteUInt16(count);
			foreach (byte b in mem.ToArray())
			{
				bes.WriteByte(b);
			}
		}
	}

	sealed class AnnotationDefaultClassFileAttribute : ClassFileAttribute
	{
		private ClassFileWriter classFile;
		private byte[] buf;

		internal AnnotationDefaultClassFileAttribute(ClassFileWriter classFile, byte[] buf)
			: base(classFile.AddUtf8("AnnotationDefault"))
		{
			this.classFile = classFile;
			this.buf = buf;
		}

		public override void Write(BigEndianStream bes)
		{
			base.Write(bes);
			bes.WriteUInt32((uint)(buf.Length));
			foreach (byte b in buf)
			{
				bes.WriteByte(b);
			}
		}
	}

	sealed class FieldOrMethod
	{
		private Modifiers access_flags;
		private ushort name_index;
		private ushort descriptor_index;
		private ArrayList attribs = new ArrayList();

		public FieldOrMethod(Modifiers access_flags, ushort name_index, ushort descriptor_index)
		{
			this.access_flags = access_flags;
			this.name_index = name_index;
			this.descriptor_index = descriptor_index;
		}

		public void AddAttribute(ClassFileAttribute attrib)
		{
			attribs.Add(attrib);
		}

		public void Write(BigEndianStream bes)
		{
			bes.WriteUInt16((ushort)access_flags);
			bes.WriteUInt16(name_index);
			bes.WriteUInt16(descriptor_index);
			bes.WriteUInt16((ushort)attribs.Count);
			for (int i = 0; i < attribs.Count; i++)
			{
				((ClassFileAttribute)attribs[i]).Write(bes);
			}
		}
	}

	sealed class CodeAttribute : ClassFileAttribute
	{
		private ClassFileWriter classFile;
		private ushort max_stack;
		private ushort max_locals;
		private byte[] code;

		public CodeAttribute(ClassFileWriter classFile)
			: base(classFile.AddUtf8("Code"))
		{
			this.classFile = classFile;
		}

		public ushort MaxStack
		{
			get { return max_stack; }
			set { max_stack = value; }
		}

		public ushort MaxLocals
		{
			get { return max_locals; }
			set { max_locals = value; }
		}

		public byte[] ByteCode
		{
			get { return code; }
			set { code = value; }
		}

		public override void Write(BigEndianStream bes)
		{
			base.Write(bes);
			bes.WriteUInt32((uint)(2 + 2 + 4 + code.Length + 2 + 2));
			bes.WriteUInt16(max_stack);
			bes.WriteUInt16(max_locals);
			bes.WriteUInt32((uint)code.Length);
			for (int i = 0; i < code.Length; i++)
			{
				bes.WriteByte(code[i]);
			}
			bes.WriteUInt16(0);	// no exceptions
			bes.WriteUInt16(0); // no attributes
		}
	}

	sealed class ClassFileWriter
	{
		private ArrayList cplist = new ArrayList();
		private Hashtable cphashtable = new Hashtable();
		private ArrayList fields = new ArrayList();
		private ArrayList methods = new ArrayList();
		private ArrayList attribs = new ArrayList();
		private ArrayList interfaces = new ArrayList();
		private Modifiers access_flags;
		private ushort this_class;
		private ushort super_class;
		private ushort minorVersion;
		private ushort majorVersion;

		public ClassFileWriter(Modifiers mods, string name, string super, ushort minorVersion, ushort majorVersion)
		{
			cplist.Add(null);
			access_flags = mods;
			this_class = AddClass(name);
			if (super != null)
			{
				super_class = AddClass(super);
			}
			this.minorVersion = minorVersion;
			this.majorVersion = majorVersion;
		}

		private ushort Add(ConstantPoolItem cpi)
		{
			object index = cphashtable[cpi];
			if (index == null)
			{
				index = (ushort)cplist.Add(cpi);
				if (cpi is ConstantPoolItemDouble || cpi is ConstantPoolItemLong)
				{
					cplist.Add(null);
				}
				cphashtable[cpi] = index;
			}
			return (ushort)index;
		}

		public ushort AddUtf8(string str)
		{
			return Add(new ConstantPoolItemUtf8(str));
		}

		public ushort AddClass(string classname)
		{
			return Add(new ConstantPoolItemClass(AddUtf8(classname)));
		}

		public ushort AddMethodRef(string classname, string methodname, string signature)
		{
			return Add(new ConstantPoolItemMethodref(AddClass(classname), AddNameAndType(methodname, signature)));
		}

		public ushort AddNameAndType(string name, string type)
		{
			return Add(new ConstantPoolItemNameAndType(AddUtf8(name), AddUtf8(type)));
		}

		public ushort AddInt(int i)
		{
			return Add(new ConstantPoolItemInt(i));
		}

		public ushort AddLong(long l)
		{
			return Add(new ConstantPoolItemLong(l));
		}

		public ushort AddFloat(float f)
		{
			return Add(new ConstantPoolItemFloat(f));
		}

		public ushort AddDouble(double d)
		{
			return Add(new ConstantPoolItemDouble(d));
		}

		public ushort AddString(string s)
		{
			return Add(new ConstantPoolItemString(AddUtf8(s)));
		}

		public void AddInterface(string name)
		{
			interfaces.Add(AddClass(name));
		}

		public FieldOrMethod AddMethod(Modifiers access, string name, string signature)
		{
			FieldOrMethod method = new FieldOrMethod(access, AddUtf8(name), AddUtf8(signature));
			methods.Add(method);
			return method;
		}

		public FieldOrMethod AddField(Modifiers access, string name, string signature, object constantValue)
		{
			FieldOrMethod field = new FieldOrMethod(access, AddUtf8(name), AddUtf8(signature));
			if (constantValue != null)
			{
				ushort constantValueIndex;
				if (constantValue is byte)
				{
					constantValueIndex = AddInt((sbyte)(byte)constantValue);
				}
				else if (constantValue is bool)
				{
					constantValueIndex = AddInt((bool)constantValue ? 1 : 0);
				}
				else if (constantValue is short)
				{
					constantValueIndex = AddInt((short)constantValue);
				}
				else if (constantValue is char)
				{
					constantValueIndex = AddInt((char)constantValue);
				}
				else if (constantValue is int)
				{
					constantValueIndex = AddInt((int)constantValue);
				}
				else if (constantValue is long)
				{
					constantValueIndex = AddLong((long)constantValue);
				}
				else if (constantValue is float)
				{
					constantValueIndex = AddFloat((float)constantValue);
				}
				else if (constantValue is double)
				{
					constantValueIndex = AddDouble((double)constantValue);
				}
				else if (constantValue is string)
				{
					constantValueIndex = AddString((string)constantValue);
				}
				else
				{
					throw new InvalidOperationException(constantValue.GetType().FullName);
				}
				field.AddAttribute(new ConstantValueAttribute(AddUtf8("ConstantValue"), constantValueIndex));
			}
			fields.Add(field);
			return field;
		}

		public ClassFileAttribute MakeStringAttribute(string name, string value)
		{
			return new StringAttribute(AddUtf8(name), AddUtf8(value));
		}

		public void AddStringAttribute(string name, string value)
		{
			attribs.Add(MakeStringAttribute(name, value));
		}

		public void AddAttribute(ClassFileAttribute attrib)
		{
			attribs.Add(attrib);
		}

		public void Write(Stream stream)
		{
			BigEndianStream bes = new BigEndianStream(stream);
			bes.WriteUInt32(0xCAFEBABE);
			bes.WriteUInt16(minorVersion);
			bes.WriteUInt16(majorVersion);
			bes.WriteUInt16((ushort)cplist.Count);
			for (int i = 1; i < cplist.Count; i++)
			{
				ConstantPoolItem cpi = (ConstantPoolItem)cplist[i];
				if (cpi != null)
				{
					cpi.Write(bes);
				}
			}
			bes.WriteUInt16((ushort)access_flags);
			bes.WriteUInt16(this_class);
			bes.WriteUInt16(super_class);
			// interfaces count
			bes.WriteUInt16((ushort)interfaces.Count);
			for (int i = 0; i < interfaces.Count; i++)
			{
				bes.WriteUInt16((ushort)interfaces[i]);
			}
			// fields count
			bes.WriteUInt16((ushort)fields.Count);
			for (int i = 0; i < fields.Count; i++)
			{
				((FieldOrMethod)fields[i]).Write(bes);
			}
			// methods count
			bes.WriteUInt16((ushort)methods.Count);
			for (int i = 0; i < methods.Count; i++)
			{
				((FieldOrMethod)methods[i]).Write(bes);
			}
			// attributes count
			bes.WriteUInt16((ushort)attribs.Count);
			for (int i = 0; i < attribs.Count; i++)
			{
				((ClassFileAttribute)attribs[i]).Write(bes);
			}
		}
	}
}
@


1.10
log
@New version of ikvmstub that no longer depends on ikvm runtime or Java class library.
@
text
@@


1.9
log
@*** empty log message ***
@
text
@d29 1
a29 1
class BigEndianStream
d31 3
a33 1
	private Stream stream;
d35 4
a38 4
	public BigEndianStream(Stream stream)
	{
		this.stream = stream;
	}
d40 5
a44 5
	public void WriteUInt16(ushort s)
	{
		stream.WriteByte((byte)(s >> 8));
		stream.WriteByte((byte)s);
	}
d46 7
a52 7
	public void WriteUInt32(uint u)
	{
		stream.WriteByte((byte)(u >> 24));
		stream.WriteByte((byte)(u >> 16));
		stream.WriteByte((byte)(u >> 8));
		stream.WriteByte((byte)u);
	}
d54 5
a58 5
	public void WriteInt64(long l)
	{
		WriteUInt32((uint)(l >> 32));
		WriteUInt32((uint)l);
	}
d60 4
a63 4
	public void WriteFloat(float f)
	{
		WriteUInt32(BitConverter.ToUInt32(BitConverter.GetBytes(f), 0));
	}
d65 4
a68 4
	public void WriteDouble(double d)
	{
		WriteInt64(BitConverter.ToInt64(BitConverter.GetBytes(d), 0));
	}
d70 4
a73 4
	public void WriteByte(byte b)
	{
		stream.WriteByte(b);
	}
d75 1
a75 5
	public void WriteUtf8(string str)
	{
		byte[] buf = new byte[str.Length * 3 + 1];
		int j = 0;
		for(int i = 0, e = str.Length; i < e; i++)
d77 3
a79 6
			char ch = str[i];
			if ((ch != 0) && (ch <=0x7f))
			{
				buf[j++] = (byte)ch;
			}
			else if (ch <= 0x7FF)
d81 23
a103 15
				/* 11 bits or less. */
				byte high_five = (byte)(ch >> 6);
				byte low_six = (byte)(ch & 0x3F);
				buf[j++] = (byte)(high_five | 0xC0); /* 110xxxxx */
				buf[j++] = (byte)(low_six | 0x80);   /* 10xxxxxx */
			}
			else
			{
				/* possibly full 16 bits. */
				byte high_four = (byte)(ch >> 12);
				byte mid_six = (byte)((ch >> 6) & 0x3F);
				byte low_six = (byte)(ch & 0x3f);
				buf[j++] = (byte)(high_four | 0xE0); /* 1110xxxx */
				buf[j++] = (byte)(mid_six | 0x80);   /* 10xxxxxx */
				buf[j++] = (byte)(low_six | 0x80);   /* 10xxxxxx*/
d105 2
a107 2
		WriteUInt16((ushort)j);
		stream.Write(buf, 0, j);
a108 16
}

enum Constant
{
	Utf8 = 1,
	Integer = 3,
	Float = 4,
	Long = 5,
	Double = 6,
	Class = 7,
	String = 8,
	Fieldref = 9,
	Methodref = 10,
	InterfaceMethodref = 11,
	NameAndType = 12
}
d110 1
a110 10
abstract class ConstantPoolItem
{
	public abstract void Write(BigEndianStream bes);
}

class ConstantPoolItemClass : ConstantPoolItem
{
	private ushort name_index;

	public ConstantPoolItemClass(ushort name_index)
d112 11
a122 1
		this.name_index = name_index;
d125 1
a125 1
	public override int GetHashCode()
d127 1
a127 1
		return name_index;
d130 1
a130 1
	public override bool Equals(object o)
d132 3
a134 1
		if(o != null && o.GetType() == typeof(ConstantPoolItemClass))
d136 1
a136 1
			return ((ConstantPoolItemClass)o).name_index == name_index;
a137 2
		return false;
	}
d139 4
a142 6
	public override void Write(BigEndianStream bes)
	{
		bes.WriteByte((byte)Constant.Class);
		bes.WriteUInt16(name_index);
	}
}
d144 8
a151 4
class ConstantPoolItemMethodref : ConstantPoolItem
{
	private ushort class_index;
	private ushort name_and_type_index;
d153 5
a157 4
	public ConstantPoolItemMethodref(ushort class_index, ushort name_and_type_index)
	{
		this.class_index = class_index;
		this.name_and_type_index = name_and_type_index;
d160 1
a160 1
	public override int GetHashCode()
d162 2
a163 2
		return class_index | (name_and_type_index << 16);
	}
d165 1
a165 3
	public override bool Equals(object o)
	{
		if(o != null && o.GetType() == typeof(ConstantPoolItemMethodref))
d167 2
a168 2
			ConstantPoolItemMethodref m = (ConstantPoolItemMethodref)o;
			return m.class_index == class_index && m.name_and_type_index == name_and_type_index;
a169 2
		return false;
	}
d171 4
a174 7
	public override void Write(BigEndianStream bes)
	{
		bes.WriteByte((byte)Constant.Methodref);
		bes.WriteUInt16(class_index);
		bes.WriteUInt16(name_and_type_index);
	}
}
d176 9
a184 4
class ConstantPoolItemNameAndType : ConstantPoolItem
{
	private ushort name_index;
	private ushort descriptor_index;
d186 6
a191 4
	public ConstantPoolItemNameAndType(ushort name_index, ushort descriptor_index)
	{
		this.name_index = name_index;
		this.descriptor_index = descriptor_index;
d194 1
a194 1
	public override int GetHashCode()
d196 2
a197 2
		return name_index | (descriptor_index << 16);
	}
d199 1
a199 3
	public override bool Equals(object o)
	{
		if(o != null && o.GetType() == typeof(ConstantPoolItemNameAndType))
d201 2
a202 2
			ConstantPoolItemNameAndType n = (ConstantPoolItemNameAndType)o;
			return n.name_index == name_index && n.descriptor_index == descriptor_index;
a203 2
		return false;
	}
d205 4
a208 7
	public override void Write(BigEndianStream bes)
	{
		bes.WriteByte((byte)Constant.NameAndType);
		bes.WriteUInt16(name_index);
		bes.WriteUInt16(descriptor_index);
	}
}
d210 9
a218 3
class ConstantPoolItemUtf8 : ConstantPoolItem
{
	private string str;
d220 6
a225 3
	public ConstantPoolItemUtf8(string str)
	{
		this.str = str;
d228 1
a228 1
	public override int GetHashCode()
d230 1
a230 2
		return str.GetHashCode();
	}
d232 1
a232 3
	public override bool Equals(object o)
	{
		if(o != null && o.GetType() == typeof(ConstantPoolItemUtf8))
d234 1
a234 1
			return ((ConstantPoolItemUtf8)o).str == str;
a235 2
		return false;
	}
d237 4
a240 6
	public override void Write(BigEndianStream bes)
	{
		bes.WriteByte((byte)Constant.Utf8);
		bes.WriteUtf8(str);
	}
}
d242 8
a249 3
class ConstantPoolItemInt : ConstantPoolItem
{
	private int v;
d251 5
a255 3
	public ConstantPoolItemInt(int v)
	{
		this.v = v;
d258 1
a258 1
	public override int GetHashCode()
d260 1
a260 2
		return v;
	}
d262 1
a262 3
	public override bool Equals(object o)
	{
		if(o != null && o.GetType() == typeof(ConstantPoolItemInt))
d264 1
a264 1
			return ((ConstantPoolItemInt)o).v == v;
a265 2
		return false;
	}
d267 4
a270 6
	public override void Write(BigEndianStream bes)
	{
		bes.WriteByte((byte)Constant.Integer);
		bes.WriteUInt32((uint)v);
	}
}
d272 8
a279 3
class ConstantPoolItemLong : ConstantPoolItem
{
	private long v;
d281 5
a285 3
	public ConstantPoolItemLong(long v)
	{
		this.v = v;
d288 1
a288 1
	public override int GetHashCode()
d290 1
a290 2
		return (int)v;
	}
d292 1
a292 3
	public override bool Equals(object o)
	{
		if(o != null && o.GetType() == typeof(ConstantPoolItemLong))
d294 1
a294 1
			return ((ConstantPoolItemLong)o).v == v;
a295 2
		return false;
	}
d297 4
a300 6
	public override void Write(BigEndianStream bes)
	{
		bes.WriteByte((byte)Constant.Long);
		bes.WriteInt64(v);
	}
}
d302 8
a309 3
class ConstantPoolItemFloat : ConstantPoolItem
{
	private float v;
d311 5
a315 3
	public ConstantPoolItemFloat(float v)
	{
		this.v = v;
d318 1
a318 1
	public override int GetHashCode()
d320 1
a320 2
		return BitConverter.ToInt32(BitConverter.GetBytes(v), 0);
	}
d322 1
a322 3
	public override bool Equals(object o)
	{
		if(o != null && o.GetType() == typeof(ConstantPoolItemFloat))
d324 1
a324 1
			return ((ConstantPoolItemFloat)o).v == v;
a325 2
		return false;
	}
d327 4
a330 6
	public override void Write(BigEndianStream bes)
	{
		bes.WriteByte((byte)Constant.Float);
		bes.WriteFloat(v);
	}
}
d332 8
a339 3
class ConstantPoolItemDouble : ConstantPoolItem
{
	private double v;
d341 5
a345 3
	public ConstantPoolItemDouble(double v)
	{
		this.v = v;
d348 1
a348 1
	public override int GetHashCode()
d350 1
a350 3
		long l = BitConverter.DoubleToInt64Bits(v);
		return ((int)l) ^ ((int)(l >> 32));
	}
d352 1
a352 3
	public override bool Equals(object o)
	{
		if(o != null && o.GetType() == typeof(ConstantPoolItemDouble))
d354 1
a354 1
			return ((ConstantPoolItemDouble)o).v == v;
a355 2
		return false;
	}
d357 5
a361 6
	public override void Write(BigEndianStream bes)
	{
		bes.WriteByte((byte)Constant.Double);
		bes.WriteDouble(v);
	}
}
d363 8
a370 3
class ConstantPoolItemString : ConstantPoolItem
{
	private ushort string_index;
d372 5
a376 3
	public ConstantPoolItemString(ushort string_index)
	{
		this.string_index = string_index;
d379 1
a379 1
	public override int GetHashCode()
d381 1
a381 2
		return string_index;
	}
d383 1
a383 3
	public override bool Equals(object o)
	{
		if(o != null && o.GetType() == typeof(ConstantPoolItemString))
d385 1
a385 1
			return ((ConstantPoolItemString)o).string_index == string_index;
a386 2
		return false;
	}
d388 4
a391 6
	public override void Write(BigEndianStream bes)
	{
		bes.WriteByte((byte)Constant.String);
		bes.WriteUInt16(string_index);
	}
}
d393 8
a400 3
class ClassFileAttribute
{
	private ushort name_index;
d402 5
a406 3
	public ClassFileAttribute(ushort name_index)
	{
		this.name_index = name_index;
d409 1
a409 1
	public virtual void Write(BigEndianStream bes)
d411 6
a416 3
		bes.WriteUInt16(name_index);
	}
}
d418 4
a421 5
class DeprecatedAttribute : ClassFileAttribute
{
	internal DeprecatedAttribute(ClassFileWriter classFile)
		: base(classFile.AddUtf8("Deprecated"))
	{
d424 1
a424 1
	public override void Write(BigEndianStream bes)
d426 4
a429 4
		base.Write(bes);
		bes.WriteUInt32(0);
	}
}
d431 5
a435 8
class ConstantValueAttribute : ClassFileAttribute
{
	private ushort constant_index;

	public ConstantValueAttribute(ushort name_index, ushort constant_index)
		: base(name_index)
	{
		this.constant_index = constant_index;
d438 1
a438 1
	public override void Write(BigEndianStream bes)
d440 1
a440 5
		base.Write(bes);
		bes.WriteUInt32(2);
		bes.WriteUInt16(constant_index);
	}
}
d442 5
a446 3
class StringAttribute : ClassFileAttribute
{
	private ushort string_index;
d448 6
a453 4
	public StringAttribute(ushort name_index, ushort string_index)
		: base(name_index)
	{
		this.string_index = string_index;
d456 1
a456 1
	public override void Write(BigEndianStream bes)
d458 1
a458 5
		base.Write(bes);
		bes.WriteUInt32(2);
		bes.WriteUInt16(string_index);
	}
}
d460 5
a464 4
class InnerClassesAttribute : ClassFileAttribute
{
	private ClassFileWriter classFile;
	private ArrayList classes = new ArrayList();
d466 6
a471 4
	public InnerClassesAttribute(ClassFileWriter classFile)
		: base(classFile.AddUtf8("InnerClasses"))
	{
		this.classFile = classFile;
d474 1
a474 1
	public override void Write(BigEndianStream bes)
d476 5
a480 4
		base.Write(bes);
		bes.WriteUInt32((uint)(2 + 8 * classes.Count));
		bes.WriteUInt16((ushort)classes.Count);
		foreach(Item i in classes)
d482 1
a482 4
			bes.WriteUInt16(i.inner_class_info_index);
			bes.WriteUInt16(i.outer_class_info_index);
			bes.WriteUInt16(i.inner_name_index);
			bes.WriteUInt16(i.inner_class_access_flags);
a483 1
	}
d485 13
a497 7
	private class Item
	{
		internal ushort inner_class_info_index;
		internal ushort outer_class_info_index;
		internal ushort inner_name_index;
		internal ushort inner_class_access_flags;
	}
d499 1
a499 6
	public void Add(string inner, string outer, string name, ushort access)
	{
		Item i = new Item();
		i.inner_class_info_index = classFile.AddClass(inner);
		i.outer_class_info_index = classFile.AddClass(outer);
		if(name != null)
d501 4
a504 1
			i.inner_name_index = classFile.AddUtf8(name);
a505 4
		i.inner_class_access_flags = access;
		classes.Add(i);
	}
}
d507 12
a518 9
class ExceptionsAttribute : ClassFileAttribute
{
	private ClassFileWriter classFile;
	private ArrayList classes = new ArrayList();

	internal ExceptionsAttribute(ClassFileWriter classFile)
		: base(classFile.AddUtf8("Exceptions"))
	{
		this.classFile = classFile;
d521 1
a521 1
	internal void Add(string exceptionClass)
d523 2
a524 2
		classes.Add(classFile.AddClass(exceptionClass));
	}
d526 2
a527 6
	public override void Write(BigEndianStream bes)
	{
		base.Write(bes);
		bes.WriteUInt32((uint)(2 + 2 * classes.Count));
		bes.WriteUInt16((ushort)classes.Count);
		foreach(ushort idx in classes)
d529 1
a529 1
			bes.WriteUInt16(idx);
a530 2
	}
}
d532 1
a532 21
class RuntimeVisibleAnnotationsAttribute : ClassFileAttribute
{
	private ClassFileWriter classFile;
	private MemoryStream mem;
	private BigEndianStream bes;
	private ushort count;

	internal RuntimeVisibleAnnotationsAttribute(ClassFileWriter classFile)
		: base(classFile.AddUtf8("RuntimeVisibleAnnotations"))
	{
		this.classFile = classFile;
		mem = new MemoryStream();
		bes = new BigEndianStream(mem);
	}

	internal void Add(object[] annot)
	{
		count++;
		bes.WriteUInt16(classFile.AddUtf8((string)annot[1]));
		bes.WriteUInt16((ushort)((annot.Length - 2) / 2));
		for(int i = 2; i < annot.Length; i += 2)
d534 1
a534 2
			bes.WriteUInt16(classFile.AddUtf8((string)annot[i]));
			WriteElementValue(bes, annot[i + 1]);
a535 1
	}
d537 1
a537 3
	private void WriteElementValue(BigEndianStream bes, object val)
	{
		if(val is object[])
d539 4
a542 2
			object[] arr = (object[])val;
			if(AnnotationDefaultAttribute.TAG_ENUM.Equals(arr[0]))
d544 1
a544 4
				bes.WriteByte(AnnotationDefaultAttribute.TAG_ENUM);
				bes.WriteUInt16(classFile.AddUtf8((string)arr[1]));
				bes.WriteUInt16(classFile.AddUtf8((string)arr[2]));
				return;
a546 1
		throw new NotImplementedException();
d549 1
a549 1
	public override void Write(BigEndianStream bes)
d551 7
a557 4
		base.Write(bes);
		bes.WriteUInt32((uint)(mem.Length + 2));
		bes.WriteUInt16(count);
		foreach(byte b in mem.ToArray())
d559 3
a561 1
			bes.WriteByte(b);
a562 2
	}
}
d564 11
a574 4
class AnnotationDefaultClassFileAttribute : ClassFileAttribute
{
	private ClassFileWriter classFile;
	private byte[] buf;
d576 1
a576 7
	internal AnnotationDefaultClassFileAttribute(ClassFileWriter classFile, object val)
		: base(classFile.AddUtf8("AnnotationDefault"))
	{
		this.classFile = classFile;
		MemoryStream mem = new MemoryStream();
		BigEndianStream bes  = new BigEndianStream(mem);
		if(val is java.lang.Boolean)
d578 23
a600 2
			bes.WriteByte((byte)'Z');
			bes.WriteUInt16(classFile.AddInt(((java.lang.Boolean)val).booleanValue() ? 1 : 0));
d602 2
a603 1
		else
d605 7
a611 1
			throw new NotImplementedException();
a612 1
		buf = mem.ToArray();
d615 1
a615 1
	public override void Write(BigEndianStream bes)
d617 5
a621 3
		base.Write(bes);
		bes.WriteUInt32((uint)(buf.Length));
		foreach(byte b in buf)
d623 2
a624 1
			bes.WriteByte(b);
a625 2
	}
}
d627 9
a635 12
class FieldOrMethod
{
	private Modifiers access_flags;
	private ushort name_index;
	private ushort descriptor_index;
	private ArrayList attribs = new ArrayList();

	public FieldOrMethod(Modifiers access_flags, ushort name_index, ushort descriptor_index)
	{
		this.access_flags = access_flags;
		this.name_index = name_index;
		this.descriptor_index = descriptor_index;
d638 1
a638 1
	public void AddAttribute(ClassFileAttribute attrib)
d640 4
a643 2
		attribs.Add(attrib);
	}
d645 1
a645 7
	public void Write(BigEndianStream bes)
	{
		bes.WriteUInt16((ushort)access_flags);
		bes.WriteUInt16(name_index);
		bes.WriteUInt16(descriptor_index);
		bes.WriteUInt16((ushort)attribs.Count);
		for(int i = 0; i < attribs.Count; i++)
d647 3
a649 1
			((ClassFileAttribute)attribs[i]).Write(bes);
a650 2
	}
}
d652 4
a655 6
class CodeAttribute : ClassFileAttribute
{
	private ClassFileWriter classFile;
	private ushort max_stack;
	private ushort max_locals;
	private byte[] code;
d657 11
a667 4
	public CodeAttribute(ClassFileWriter classFile)
		: base(classFile.AddUtf8("Code"))
	{
		this.classFile = classFile;
d670 1
a670 1
	public ushort MaxStack
d672 4
a675 3
		get { return max_stack; }
		set { max_stack = value; }
	}
d677 5
a681 5
	public ushort MaxLocals
	{
		get { return max_locals; }
		set { max_locals = value; }
	}
d683 5
a687 5
	public byte[] ByteCode
	{
		get { return code; }
		set { code = value; }
	}
d689 1
a689 8
	public override void Write(BigEndianStream bes)
	{
		base.Write(bes);
		bes.WriteUInt32((uint)(2 + 2 + 4 + code.Length + 2 + 2));
		bes.WriteUInt16(max_stack);
		bes.WriteUInt16(max_locals);
		bes.WriteUInt32((uint)code.Length);
		for(int i = 0; i < code.Length; i++)
d691 2
a692 1
			bes.WriteByte(code[i]);
a693 18
		bes.WriteUInt16(0);	// no exceptions
		bes.WriteUInt16(0); // no attributes
	}
}

class ClassFileWriter
{
	private ArrayList cplist = new ArrayList();
	private Hashtable cphashtable = new Hashtable();
	private ArrayList fields = new ArrayList();
	private ArrayList methods = new ArrayList();
	private ArrayList attribs = new ArrayList();
	private ArrayList interfaces = new ArrayList();
	private Modifiers access_flags;
	private ushort this_class;
	private ushort super_class;
	private ushort minorVersion;
	private ushort majorVersion;
d695 1
a695 6
	public ClassFileWriter(Modifiers mods, string name, string super, ushort minorVersion, ushort majorVersion)
	{
		cplist.Add(null);
		access_flags = mods;
		this_class = AddClass(name);
		if(super != null)
d697 2
a698 1
			super_class = AddClass(super);
a699 3
		this.minorVersion = minorVersion;
		this.majorVersion = majorVersion;
	}
d701 1
a701 4
	private ushort Add(ConstantPoolItem cpi)
	{
		object index = cphashtable[cpi];
		if(index == null)
d703 6
a708 2
			index = (ushort)cplist.Add(cpi);
			if(cpi is ConstantPoolItemDouble || cpi is ConstantPoolItemLong)
d710 1
a710 1
				cplist.Add(null);
d712 2
a713 1
			cphashtable[cpi] = index;
a714 1
		return (ushort)index;
d717 1
a717 1
	public ushort AddUtf8(string str)
d719 11
a729 2
		return Add(new ConstantPoolItemUtf8(str));
	}
d731 12
a742 4
	public ushort AddClass(string classname)
	{
		return Add(new ConstantPoolItemClass(AddUtf8(classname)));
	}
d744 14
a757 4
	public ushort AddMethodRef(string classname, string methodname, string signature)
	{
		return Add(new ConstantPoolItemMethodref(AddClass(classname), AddNameAndType(methodname, signature)));
	}
d759 4
a762 4
	public ushort AddNameAndType(string name, string type)
	{
		return Add(new ConstantPoolItemNameAndType(AddUtf8(name), AddUtf8(type)));
	}
d764 4
a767 4
	public ushort AddInt(int i)
	{
		return Add(new ConstantPoolItemInt(i));
	}
d769 4
a772 4
	private ushort AddLong(long l)
	{
		return Add(new ConstantPoolItemLong(l));
	}
d774 4
a777 4
	private ushort AddFloat(float f)
	{
		return Add(new ConstantPoolItemFloat(f));
	}
d779 4
a782 4
	private ushort AddDouble(double d)
	{
		return Add(new ConstantPoolItemDouble(d));
	}
d784 4
a787 4
	public ushort AddString(string s)
	{
		return Add(new ConstantPoolItemString(AddUtf8(s)));
	}
d789 4
a792 4
	public void AddInterface(string name)
	{
		interfaces.Add(AddClass(name));
	}
d794 4
a797 6
	public FieldOrMethod AddMethod(Modifiers access, string name, string signature)
	{
		FieldOrMethod method = new FieldOrMethod(access, AddUtf8(name), AddUtf8(signature));
		methods.Add(method);
		return method;
	}
d799 1
a799 4
	public FieldOrMethod AddField(Modifiers access, string name, string signature, object constantValue)
	{
		FieldOrMethod field = new FieldOrMethod(access, AddUtf8(name), AddUtf8(signature));
		if(constantValue != null)
d801 1
a801 42
			ushort constantValueIndex;
			if(constantValue is byte)
			{
				constantValueIndex = AddInt((sbyte)(byte)constantValue);
			}
			else if(constantValue is bool)
			{
				constantValueIndex = AddInt((bool)constantValue ? 1 : 0);
			}
			else if(constantValue is short)
			{
				constantValueIndex = AddInt((short)constantValue);
			}
			else if(constantValue is char)
			{
				constantValueIndex = AddInt((char)constantValue);
			}
			else if(constantValue is int)
			{
				constantValueIndex = AddInt((int)constantValue);
			}
			else if(constantValue is long)
			{
				constantValueIndex = AddLong((long)constantValue);
			}
			else if(constantValue is float)
			{
				constantValueIndex = AddFloat((float)constantValue);
			}
			else if(constantValue is double)
			{
				constantValueIndex = AddDouble((double)constantValue);
			}
			else if(constantValue is string)
			{
				constantValueIndex = AddString((string)constantValue);
			}
			else
			{
				throw new InvalidOperationException(constantValue.GetType ().FullName);
			}
			field.AddAttribute(new ConstantValueAttribute(AddUtf8("ConstantValue"), constantValueIndex));
a802 3
		fields.Add(field);
		return field;
	}
d804 4
a807 4
	public ClassFileAttribute MakeStringAttribute(string name, string value)
	{
		return new StringAttribute(AddUtf8(name), AddUtf8(value));
	}
d809 6
a814 4
	public void AddStringAttribute(string name, string value)
	{
		attribs.Add(MakeStringAttribute(name, value));
	}
d816 1
a816 13
	public void AddAttribute(ClassFileAttribute attrib)
	{
		attribs.Add(attrib);
	}

	public void Write(Stream stream)
	{
		BigEndianStream bes = new BigEndianStream(stream);
		bes.WriteUInt32(0xCAFEBABE);
		bes.WriteUInt16(minorVersion);
		bes.WriteUInt16(majorVersion);
		bes.WriteUInt16((ushort)cplist.Count);
		for(int i = 1; i < cplist.Count; i++)
d818 2
a819 2
			ConstantPoolItem cpi = (ConstantPoolItem)cplist[i];
			if(cpi != null)
d821 42
a862 1
				cpi.Write(bes);
d864 2
d867 2
a868 6
		bes.WriteUInt16((ushort)access_flags);
		bes.WriteUInt16(this_class);
		bes.WriteUInt16(super_class);
		// interfaces count
		bes.WriteUInt16((ushort)interfaces.Count);
		for(int i = 0; i < interfaces.Count; i++)
d870 1
a870 1
			bes.WriteUInt16((ushort)interfaces[i]);
d872 2
a873 3
		// fields count
		bes.WriteUInt16((ushort)fields.Count);
		for(int i = 0; i < fields.Count; i++)
d875 1
a875 1
			((FieldOrMethod)fields[i]).Write(bes);
d877 2
a878 3
		// methods count
		bes.WriteUInt16((ushort)methods.Count);
		for(int i = 0; i < methods.Count; i++)
d880 1
a880 1
			((FieldOrMethod)methods[i]).Write(bes);
d882 2
a883 3
		// attributes count
		bes.WriteUInt16((ushort)attribs.Count);
		for(int i = 0; i < attribs.Count; i++)
d885 40
a924 1
			((ClassFileAttribute)attribs[i]).Write(bes);
@


1.8
log
@*** empty log message ***
@
text
@@


1.7
log
@*** empty log message ***
@
text
@d602 34
d777 1
a777 1
	private ushort AddInt(int i)
@


1.6
log
@*** empty log message ***
@
text
@d547 55
@


1.5
log
@*** empty log message ***
@
text
@d637 2
d640 1
a640 1
	public ClassFileWriter(Modifiers mods, string name, string super)
d649 2
d777 5
d784 1
a784 1
		attribs.Add(new StringAttribute(AddUtf8(name), AddUtf8(value)));
d796 2
a797 2
		bes.WriteUInt16((ushort)3);
		bes.WriteUInt16((ushort)45);
@


1.4
log
@*** empty log message ***
@
text
@d729 1
a729 1
				constantValueIndex = AddInt((byte)constantValue);
@


1.3
log
@*** empty log message ***
@
text
@d727 1
a727 1
			if(constantValue is sbyte)
d729 1
a729 1
				constantValueIndex = AddInt((sbyte)constantValue);
a746 4
			else if(constantValue is uint)
			{
				constantValueIndex = AddInt((int)(uint)constantValue);
			}
a750 4
			else if(constantValue is ulong)
			{
				constantValueIndex = AddLong((long)(ulong)constantValue);
			}
@


1.2
log
@*** empty log message ***
@
text
@d422 14
@


1.1
log
@*** empty log message ***
@
text
@d27 1
@

