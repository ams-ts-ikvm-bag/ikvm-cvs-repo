head	1.88;
access;
symbols
	v8_1_5717_0:1.88
	v8_1:1.88.0.2
	v8_0_5449_1:1.86
	v8_0_5449_0:1.86
	v8_0:1.86.0.2
	v7_4_5196_0:1.78
	v7_4:1.78.0.2
	v7_3:1.76.0.2
	v7_2_4630_6:1.71.2.1
	v7_2_4630_5:1.71.2.1
	v7_2_4630_4:1.71.2.1
	v7_2_4630_3:1.71.2.1
	v7_2_4630_2:1.71.2.1
	v0_46_0_4:1.61
	v7_2_4630_1:1.71.2.1
	v7_2:1.71.0.2
	v7_1_4532_2:1.68
	v7_1_4532_1:1.68
	v7_1_4532_0:1.68
	v7_1:1.68.0.2
	v7_0_4335_3:1.64
	v7_0_4335_2:1.64
	v7_0_4335_1:1.64
	v0_46_0_2:1.61
	v7_0_4335_0:1.64
	v7_0:1.64.0.2
	v0_40_0_6:1.38
	v0_40_0_5:1.38
	v0_46_0_1:1.61
	v0_46_0_0:1.61
	v0_46:1.61.0.2
	v0_36_0_14:1.19.2.2
	v0_44_0_6:1.57
	v0_44_0_5:1.57
	v0_44_0_4:1.57
	v0_44_0_3:1.57
	v0_44_0_2:1.57
	v0_42_0_7:1.45.2.3
	v0_44_0_1:1.57
	v0_44_0_0:1.57
	v0_44:1.57.0.2
	v0_42_0_6:1.45.2.3
	v0_42_0_5:1.45.2.3
	v0_42_0_4:1.45.2.2
	v0_42_0_3:1.45.2.1
	v0_42_0_2:1.45.2.1
	v0_42_0_1:1.45
	v0_42_0_0:1.45
	v0_42:1.45.0.2
	v0_40_0_3:1.38
	v0_40_0_2:1.38
	v0_40_0_1:1.38
	v0_40_0_0:1.38
	v0_40:1.38.0.2
	v0_36_0_13:1.19.2.2
	v0_38_0_1:1.35
	v0_38_0_0:1.35
	v0_38:1.35.0.2
	v0_36_0_9:1.19.2.1
	v0_36_0_7:1.19.2.1
	v0_36_0_5:1.19.2.1
	v0_36_0_4:1.19
	v0_36_0_3:1.19
	v0_36_0_2:1.19
	v0_36_0_1:1.19
	v0_36_0_0:1.19
	v0_36:1.19.0.2
	v0_34_0_3:1.14
	v0_34_0_2:1.14
	v0_34_0_1:1.14
	v0_34_0_0:1.14
	v0_34:1.14.0.2
	v0_32:1.12.0.2
	v0_32_0_0:1.12
	v0_30:1.6.0.2
	v0_28_0_0:1.5;
locks; strict;
comment	@ * @;


1.88
date	2015.06.21.06.23.29;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2015.03.24.09.39.10;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2014.06.13.06.54.06;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2014.05.27.09.55.51;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2014.04.30.09.06.41;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2014.04.30.09.04.41;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2014.04.29.13.36.29;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2014.04.28.14.26.37;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2014.04.24.16.06.05;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2014.04.11.13.03.33;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2013.03.29.10.02.30;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2013.03.24.12.40.33;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2013.01.31.09.12.20;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2013.01.30.17.39.46;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2012.12.30.10.58.17;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2012.09.13.13.21.35;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2012.09.11.12.00.46;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2012.08.15.08.45.39;	author jfrijters;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2012.08.06.12.12.03;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2012.07.03.14.45.51;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2012.01.05.09.03.52;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2011.12.12.12.43.22;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2011.12.11.10.43.17;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2011.12.07.11.28.17;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2011.08.08.11.28.05;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2011.05.25.09.22.23;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2011.05.12.10.15.52;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2010.09.30.04.03.32;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2010.09.29.07.21.51;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2010.09.20.15.08.45;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.14.12.29.22;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.20.04.58.12;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.16.06.31.20;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2010.02.19.08.07.37;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.28.09.18.33;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.28.06.37.48;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.25.07.52.43;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2009.12.07.07.12.23;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2009.12.01.07.08.52;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.23.06.29.54;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.23.06.06.48;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.16.07.06.50;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.14.14.58.41;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.31.05.02.34;	author jfrijters;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2009.07.14.09.31.20;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2009.07.14.06.27.41;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2009.05.25.05.10.14;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2009.05.17.05.56.37;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2009.05.12.04.04.52;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.12.04.00.01;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.06.09.47.59;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.14.08.42.07;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.14.07.55.53;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2008.08.15.12.01.11;	author jfrijters;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2008.08.15.06.27.12;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.14.07.52.27;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2008.08.14.07.42.56;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.14.06.51.32;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.14.05.42.43;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.06.05.25.18;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.24.15.01.45;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.24.14.49.12;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.03.12.10.07;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.03.09.17.31;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2008.02.18.07.58.28;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2008.02.09.17.38.41;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.27.11.09.04;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.26.08.38.38;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.06.08.54.52;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.22.04.45.22;	author jfrijters;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2007.06.28.10.32.50;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.10.06.53.50;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.15.08.01.19;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.12.09.27.18;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.15.08.02.51;	author jfrijters;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2007.01.04.07.46.40;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.06.06.53.34;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.02.07.10.53;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.26.04.53.16;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.12.09.57.36;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.29.11.56.09;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.26.14.16.52;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.05.11.21.15;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.20.07.30.59;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.14.14.11.39;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.12.13.01.14;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.10.10.18.49;	author jfrijters;	state Exp;
branches;
next	;

1.14.2.1
date	2007.08.06.08.09.37;	author jfrijters;	state Exp;
branches;
next	;

1.19.2.1
date	2007.12.04.06.04.31;	author jfrijters;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2008.11.05.07.52.01;	author jfrijters;	state Exp;
branches;
next	;

1.35.2.1
date	2009.02.02.05.58.20;	author jfrijters;	state Exp;
branches;
next	;

1.45.2.1
date	2009.10.26.04.51.24;	author jfrijters;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2010.01.12.16.57.12;	author jfrijters;	state Exp;
branches;
next	1.45.2.3;

1.45.2.3
date	2010.02.19.08.14.27;	author jfrijters;	state Exp;
branches;
next	;

1.71.2.1
date	2012.09.17.11.17.30;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.88
log
@Make non-public final methods defined in map.xml that don't override anything automatically non-virtual.
@
text
@/*
  Copyright (C) 2002-2015 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/

using System;
using System.Collections.Generic;
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
using System.Diagnostics;
using System.Security;
using System.Security.Permissions;
using IKVM.Attributes;

namespace IKVM.Internal
{
	sealed class AotTypeWrapper : DynamicTypeWrapper
	{
		private FieldInfo ghostRefField;
		private MethodBuilder ghostIsInstanceMethod;
		private MethodBuilder ghostIsInstanceArrayMethod;
		private MethodBuilder ghostCastMethod;
		private MethodBuilder ghostCastArrayMethod;
		private TypeBuilder typeBuilderGhostInterface;
		private Annotation annotation;
		private Type enumType;
		private MethodWrapper[] replacedMethods;
		private WorkaroundBaseClass workaroundBaseClass;

		internal AotTypeWrapper(ClassFile f, CompilerClassLoader loader)
			: base(null, f, loader, null)
		{
		}

		protected override Type GetBaseTypeForDefineType()
		{
			TypeWrapper baseTypeWrapper = BaseTypeWrapper;
			if (this.IsPublic && this.IsAbstract && baseTypeWrapper.IsPublic && baseTypeWrapper.IsAbstract && classLoader.WorkaroundAbstractMethodWidening)
			{
				// FXBUG
				// if the current class widens access on an abstract base class method,
				// we need to inject an artificial base class to workaround a C# compiler bug
				List<MethodWrapper> methods = null;
				foreach (MethodWrapper mw in GetMethods())
				{
					if (!mw.IsStatic && mw.IsPublic)
					{
						MethodWrapper baseMethod = baseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
						if (baseMethod != null && baseMethod.IsAbstract && baseMethod.IsProtected)
						{
							if (methods == null)
							{
								methods = new List<MethodWrapper>();
							}
							methods.Add(baseMethod);
						}
					}
				}
				if (methods != null)
				{
					string name = "__WorkaroundBaseClass__." + UnicodeUtil.EscapeInvalidSurrogates(Name);
					while (!classLoader.ReserveName(name))
					{
						name = "_" + name;
					}
					TypeWrapperFactory context = classLoader.GetTypeWrapperFactory();
					TypeBuilder typeBuilder = context.ModuleBuilder.DefineType(name, TypeAttributes.Public | TypeAttributes.Abstract, base.GetBaseTypeForDefineType());
					AttributeHelper.HideFromJava(typeBuilder);
					AttributeHelper.SetEditorBrowsableNever(typeBuilder);
					workaroundBaseClass = new WorkaroundBaseClass(this, typeBuilder, methods.ToArray());
					List<MethodWrapper> constructors = new List<MethodWrapper>();
					foreach (MethodWrapper mw in baseTypeWrapper.GetMethods())
					{
						if (ReferenceEquals(mw.Name, StringConstants.INIT) && mw.IsAccessibleFrom(baseTypeWrapper, this, this))
						{
							constructors.Add(new ConstructorForwarder(context, typeBuilder, mw));
						}
					}
					replacedMethods = constructors.ToArray();
					return typeBuilder;
				}
			}
			return base.GetBaseTypeForDefineType();
		}

		internal override void Finish()
		{
			base.Finish();
			if (workaroundBaseClass != null)
			{
				workaroundBaseClass.Finish();
			}
		}

		private sealed class WorkaroundBaseClass
		{
			private readonly AotTypeWrapper wrapper;
			private readonly TypeBuilder typeBuilder;
			private readonly MethodWrapper[] methods;
			private MethodBuilder baseSerializationCtor;

			internal WorkaroundBaseClass(AotTypeWrapper wrapper, TypeBuilder typeBuilder, MethodWrapper[] methods)
			{
				this.wrapper = wrapper;
				this.typeBuilder = typeBuilder;
				this.methods = methods;
			}

			internal MethodBuilder GetSerializationConstructor()
			{
				if (baseSerializationCtor == null)
				{
					baseSerializationCtor = Serialization.AddAutomagicSerializationToWorkaroundBaseClass(typeBuilder, wrapper.BaseTypeWrapper.GetSerializationConstructor());
				}
				return baseSerializationCtor;
			}

			internal void Finish()
			{
				if (!typeBuilder.IsCreated())
				{
					foreach (MethodWrapper mw in methods)
					{
						MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(wrapper, typeBuilder, mw.Name, MethodAttributes.FamORAssem | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.CheckAccessOnOverride);
						AttributeHelper.HideFromJava(mb);
						CodeEmitter ilgen = CodeEmitter.Create(mb);
						ilgen.EmitThrow("java.lang.AbstractMethodError");
						ilgen.DoEmit();
					}
					typeBuilder.CreateType();
				}
			}
		}

		private sealed class ConstructorForwarder : MethodWrapper
		{
			private readonly TypeWrapperFactory context;
			private readonly TypeBuilder typeBuilder;
			private readonly MethodWrapper ctor;
			private MethodBuilder constructorBuilder;

			internal ConstructorForwarder(TypeWrapperFactory context, TypeBuilder typeBuilder, MethodWrapper ctor)
				: base(ctor.DeclaringType, ctor.Name, ctor.Signature, null, null, null, ctor.Modifiers, MemberFlags.None)
			{
				this.context = context;
				this.typeBuilder = typeBuilder;
				this.ctor = ctor;
			}

			protected override void DoLinkMethod()
			{
				ctor.Link();
				DefineMethodHelper dmh = ctor.GetDefineMethodHelper();
				constructorBuilder = dmh.DefineConstructor(context, typeBuilder, MethodAttributes.PrivateScope);
				AttributeHelper.HideFromJava(constructorBuilder);
				CodeEmitter ilgen = CodeEmitter.Create(constructorBuilder);
				ilgen.Emit(OpCodes.Ldarg_0);
				for (int i = 1; i <= dmh.ParameterCount; i++)
				{
					ilgen.EmitLdarg(i);
				}
				ctor.EmitCall(ilgen);
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
			}

			internal override void EmitCall(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Call, constructorBuilder);
			}
		}

		internal override bool IsGhost
		{
			get
			{
				return classLoader.IsGhost(this);
			}
		}

		internal override bool IsMapUnsafeException
		{
			get
			{
				return classLoader.IsMapUnsafeException(this);
			}
		}

		internal override Type TypeAsBaseType
		{
			get
			{
				return typeBuilderGhostInterface != null ? typeBuilderGhostInterface : base.TypeAsBaseType;
			}
		}

		internal void GetParameterNamesFromXml(string methodName, string methodSig, string[] parameterNames)
		{
			IKVM.Internal.MapXml.Param[] parameters = classLoader.GetXmlMapParameters(Name, methodName, methodSig);
			if(parameters != null)
			{
				for(int i = 0; i < parameters.Length; i++)
				{
					if(parameters[i].Name != null)
					{
						parameterNames[i] = parameters[i].Name;
					}
				}
			}
		}

		internal void AddXmlMapParameterAttributes(MethodBuilder method, string className, string methodName, string methodSig, ref ParameterBuilder[] pbs)
		{
			IKVM.Internal.MapXml.Param[] parameters = classLoader.GetXmlMapParameters(className, methodName, methodSig);
			if(parameters != null)
			{
				if(pbs == null)
				{
					// let's hope that the parameters array is the right length
					pbs = GetParameterBuilders(method, parameters.Length, null);
				}
				for(int i = 0; i < pbs.Length; i++)
				{
					if(parameters[i].Attributes != null)
					{
						foreach(IKVM.Internal.MapXml.Attribute attr in parameters[i].Attributes)
						{
							AttributeHelper.SetCustomAttribute(classLoader, pbs[i], attr);
						}
					}
				}
			}
		}

		private void AddParameterMetadata(MethodBuilder method, MethodWrapper mw)
		{
			ParameterBuilder[] pbs;
			if((mw.DeclaringType.IsPublic && (mw.IsPublic || mw.IsProtected)) || classLoader.EmitDebugInfo)
			{
				string[] parameterNames = new string[mw.GetParameters().Length];
				GetParameterNamesFromXml(mw.Name, mw.Signature, parameterNames);
				GetParameterNamesFromSig(mw.Signature, parameterNames);
				pbs = GetParameterBuilders(method, parameterNames.Length, parameterNames);
			}
			else
			{
				pbs = GetParameterBuilders(method, mw.GetParameters().Length, null);
			}
			if((mw.Modifiers & Modifiers.VarArgs) != 0 && pbs.Length > 0)
			{
				AttributeHelper.SetParamArrayAttribute(pbs[pbs.Length - 1]);
			}
			AddXmlMapParameterAttributes(method, Name, mw.Name, mw.Signature, ref pbs);
		}

		protected override void AddMapXmlFields(ref FieldWrapper[] fields)
		{
			Dictionary<string, IKVM.Internal.MapXml.Class> mapxml = classLoader.GetMapXmlClasses();
			if(mapxml != null)
			{
				IKVM.Internal.MapXml.Class clazz;
				if(mapxml.TryGetValue(this.Name, out clazz))
				{
					if(clazz.Fields != null)
					{
						foreach(IKVM.Internal.MapXml.Field field in clazz.Fields)
						{
							// are we adding a new field?
							bool found = false;
							foreach(FieldWrapper fw in fields)
							{
								if(fw.Name == field.Name && fw.Signature == field.Sig)
								{
									found = true;
									break;
								}
							}
							if(!found)
							{
								fields = ArrayUtil.Concat(fields, FieldWrapper.Create(this, null, null, field.Name, field.Sig, new ExModifiers((Modifiers)field.Modifiers, false)));
							}
						}
					}
				}				
			}
		}

		protected override bool EmitMapXmlMethodPrologueAndOrBody(CodeEmitter ilgen, ClassFile f, ClassFile.Method m)
		{
			IKVM.Internal.MapXml.InstructionList prologue = classLoader.GetMethodPrologue(new MethodKey(f.Name, m.Name, m.Signature));
			if(prologue != null)
			{
				prologue.Emit(classLoader, ilgen);
			}
			Dictionary<MethodKey, IKVM.Internal.MapXml.InstructionList> mapxml = classLoader.GetMapXmlMethodBodies();
			if(mapxml != null)
			{
				IKVM.Internal.MapXml.InstructionList opcodes;
				if(mapxml.TryGetValue(new MethodKey(f.Name, m.Name, m.Signature), out opcodes))
				{
					opcodes.Emit(classLoader, ilgen);
					return true;
				}
			}
			return false;
		}

		private void PublishAttributes(TypeBuilder typeBuilder, IKVM.Internal.MapXml.Class clazz)
		{
			foreach(IKVM.Internal.MapXml.Attribute attr in clazz.Attributes)
			{
				AttributeHelper.SetCustomAttribute(classLoader, typeBuilder, attr);
			}
		}

		private static bool CheckPropertyArgs(Type[] args1, Type[] args2)
		{
			if(args1.Length == args2.Length)
			{
				for(int i = 0; i < args1.Length; i++)
				{
					if(args1[i] != args2[i])
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		private static MethodAttributes GetPropertyMethodAttributes(MethodWrapper mw, bool final)
		{
			MethodAttributes attribs = MethodAttributes.HideBySig;
			if(mw.IsStatic)
			{
				attribs |= MethodAttributes.Static;
			}
			else
			{
				// NOTE in order for IntelliSense to consider the property a "real" property,
				// the getter and setter methods need to have substantially the same method attributes,
				// so we may need to look at our peer to determine whether we should be final
				// or not (and vice versa).
				attribs |= MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.CheckAccessOnOverride;
				if(final)
				{
					attribs |= MethodAttributes.Final;
				}
			}
			// TODO what happens if accessibility doesn't match our peer?
			if(mw.IsPublic)
			{
				attribs |= MethodAttributes.Public;
			}
			else if(mw.IsProtected)
			{
				attribs |= MethodAttributes.FamORAssem;
			}
			else if(mw.IsPrivate)
			{
				attribs |= MethodAttributes.Private;
			}
			else
			{
				attribs |= MethodAttributes.Assembly;
			}
			return attribs;
		}

		private void PublishProperties(TypeBuilder typeBuilder, IKVM.Internal.MapXml.Class clazz)
		{
			foreach(IKVM.Internal.MapXml.Property prop in clazz.Properties)
			{
				TypeWrapper typeWrapper = GetClassLoader().RetTypeWrapperFromSig(prop.Sig, LoadMode.Link);
				TypeWrapper[] propargs = GetClassLoader().ArgTypeWrapperListFromSig(prop.Sig, LoadMode.Link);
				Type[] indexer = new Type[propargs.Length];
				for(int i = 0; i < propargs.Length; i++)
				{
					indexer[i] = propargs[i].TypeAsSignatureType;
				}
				PropertyBuilder propbuilder = typeBuilder.DefineProperty(prop.Name, PropertyAttributes.None, typeWrapper.TypeAsSignatureType, indexer);
				AttributeHelper.HideFromJava(propbuilder);
				if(prop.Attributes != null)
				{
					foreach(IKVM.Internal.MapXml.Attribute attr in prop.Attributes)
					{
						AttributeHelper.SetCustomAttribute(classLoader, propbuilder, attr);
					}
				}
				MethodWrapper getter = null;
				MethodWrapper setter = null;
				if(prop.getter != null)
				{
					getter = GetMethodWrapper(prop.getter.Name, prop.getter.Sig, true);
					if(getter == null)
					{
						Console.Error.WriteLine("Warning: getter not found for {0}::{1}", clazz.Name, prop.Name);
					}
				}
				if(prop.setter != null)
				{
					setter = GetMethodWrapper(prop.setter.Name, prop.setter.Sig, true);
					if(setter == null)
					{
						Console.Error.WriteLine("Warning: setter not found for {0}::{1}", clazz.Name, prop.Name);
					}
				}
				bool final = (getter != null && getter.IsFinal) || (setter != null && setter.IsFinal);
				if(getter != null)
				{
					MethodWrapper mw = getter;
					if(!CheckPropertyArgs(mw.GetParametersForDefineMethod(), indexer) || mw.ReturnType != typeWrapper)
					{
						Console.Error.WriteLine("Warning: ignoring invalid property getter for {0}::{1}", clazz.Name, prop.Name);
					}
					else
					{
						MethodBuilder mb = mw.GetMethod() as MethodBuilder;
						if(mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final))
						{
							mb = typeBuilder.DefineMethod("get_" + prop.Name, GetPropertyMethodAttributes(mw, final), typeWrapper.TypeAsSignatureType, indexer);
							AttributeHelper.HideFromJava(mb);
							CodeEmitter ilgen = CodeEmitter.Create(mb);
							if(mw.IsStatic)
							{
								for(int i = 0; i < indexer.Length; i++)
								{
									ilgen.EmitLdarg(i);
								}
								mw.EmitCall(ilgen);
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								for(int i = 0; i < indexer.Length; i++)
								{
									ilgen.EmitLdarg(i + 1);
								}
								mw.EmitCallvirt(ilgen);
							}
							ilgen.Emit(OpCodes.Ret);
							ilgen.DoEmit();
						}
						propbuilder.SetGetMethod(mb);
					}
				}
				if(setter != null)
				{
					MethodWrapper mw = setter;
					Type[] args = ArrayUtil.Concat(indexer, typeWrapper.TypeAsSignatureType);
					if(!CheckPropertyArgs(args, mw.GetParametersForDefineMethod()))
					{
						Console.Error.WriteLine("Warning: ignoring invalid property setter for {0}::{1}", clazz.Name, prop.Name);
					}
					else
					{
						MethodBuilder mb = mw.GetMethod() as MethodBuilder;
						if(mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final))
						{
							mb = typeBuilder.DefineMethod("set_" + prop.Name, GetPropertyMethodAttributes(mw, final), mw.ReturnTypeForDefineMethod, args);
							AttributeHelper.HideFromJava(mb);
							CodeEmitter ilgen = CodeEmitter.Create(mb);
							if(mw.IsStatic)
							{
								for(int i = 0; i <= indexer.Length; i++)
								{
									ilgen.EmitLdarg(i);
								}
								mw.EmitCall(ilgen);
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								for(int i = 0; i <= indexer.Length; i++)
								{
									ilgen.EmitLdarg(i + 1);
								}
								mw.EmitCallvirt(ilgen);
							}
							ilgen.Emit(OpCodes.Ret);
							ilgen.DoEmit();
						}
						propbuilder.SetSetMethod(mb);
					}
				}
			}
		}

		private static void MapModifiers(MapXml.MapModifiers mapmods, bool isConstructor, out bool setmodifiers, ref MethodAttributes attribs, bool isNewSlot)
		{
			setmodifiers = false;
			Modifiers modifiers = (Modifiers)mapmods;
			if((modifiers & Modifiers.Public) != 0)
			{
				attribs |= MethodAttributes.Public;
			}
			else if((modifiers & Modifiers.Protected) != 0)
			{
				attribs |= MethodAttributes.FamORAssem;
			}
			else if((modifiers & Modifiers.Private) != 0)
			{
				attribs |= MethodAttributes.Private;
			}
			else
			{
				attribs |= MethodAttributes.Assembly;
			}
			if((modifiers & Modifiers.Static) != 0)
			{
				attribs |= MethodAttributes.Static;
				if((modifiers & Modifiers.Final) != 0)
				{
					setmodifiers = true;
				}
			}
			else if(!isConstructor)
			{
				// NOTE we're abusing the MethodAttributes.NewSlot and Modifiers.Final combination to mean non-virtual
				if((modifiers & Modifiers.Final) != 0 && (attribs & MethodAttributes.NewSlot) != 0 && (attribs & MethodAttributes.Virtual) == 0)
				{
					// remove NewSlot, because it doesn't make sense on a non-virtual method
					attribs &= ~MethodAttributes.NewSlot;
				}
				else if(((modifiers & (Modifiers.Public | Modifiers.Final)) == Modifiers.Final && isNewSlot && (attribs & MethodAttributes.Virtual) == 0))
				{
					// final method that doesn't need to be virtual
				}
				else
				{
					if((modifiers & Modifiers.Private) == 0)
					{
						attribs |= MethodAttributes.Virtual;
					}
					if((modifiers & Modifiers.Final) != 0)
					{
						attribs |= MethodAttributes.Final;
					}
					else if((modifiers & Modifiers.Abstract) != 0)
					{
						attribs |= MethodAttributes.Abstract;
					}
				}
			}
			if((modifiers & Modifiers.Synchronized) != 0)
			{
				throw new NotImplementedException();
			}
		}

		private void MapSignature(string sig, out Type returnType, out Type[] parameterTypes)
		{
			returnType = GetClassLoader().RetTypeWrapperFromSig(sig, LoadMode.Link).TypeAsSignatureType;
			TypeWrapper[] parameterTypeWrappers = GetClassLoader().ArgTypeWrapperListFromSig(sig, LoadMode.Link);
			parameterTypes = new Type[parameterTypeWrappers.Length];
			for(int i = 0; i < parameterTypeWrappers.Length; i++)
			{
				parameterTypes[i] = parameterTypeWrappers[i].TypeAsSignatureType;
			}
		}

		protected override void EmitMapXmlMetadata(TypeBuilder typeBuilder, ClassFile classFile, FieldWrapper[] fields, MethodWrapper[] methods)
		{
			Dictionary<string, IKVM.Internal.MapXml.Class> mapxml = classLoader.GetMapXmlClasses();
			if(mapxml != null)
			{
				IKVM.Internal.MapXml.Class clazz;
				if(mapxml.TryGetValue(classFile.Name, out clazz))
				{
					if(clazz.Attributes != null)
					{
						PublishAttributes(typeBuilder, clazz);
					}
					if(clazz.Properties != null)
					{
						PublishProperties(typeBuilder, clazz);
					}
					if(clazz.Fields != null)
					{
						foreach(IKVM.Internal.MapXml.Field field in clazz.Fields)
						{
							if(field.Attributes != null)
							{
								foreach(FieldWrapper fw in fields)
								{
									if(fw.Name == field.Name && fw.Signature == field.Sig)
									{
										FieldBuilder fb = fw.GetField() as FieldBuilder;
										if(fb != null)
										{
											foreach(IKVM.Internal.MapXml.Attribute attr in field.Attributes)
											{
												AttributeHelper.SetCustomAttribute(classLoader, fb, attr);
											}
										}
									}
								}
							}
						}
					}
					if(clazz.Constructors != null)
					{
						// HACK this isn't the right place to do this, but for now it suffices
						foreach(IKVM.Internal.MapXml.Constructor constructor in clazz.Constructors)
						{
							// are we adding a new constructor?
							if(GetMethodWrapper(StringConstants.INIT, constructor.Sig, false) == null)
							{
								if(constructor.body == null)
								{
									Console.Error.WriteLine("Error: Constructor {0}.<init>{1} in xml remap file doesn't have a body.", clazz.Name, constructor.Sig);
									continue;
								}
								bool setmodifiers = false;
								MethodAttributes attribs = 0;
								MapModifiers(constructor.Modifiers, true, out setmodifiers, ref attribs, false);
								Type returnType;
								Type[] parameterTypes;
								MapSignature(constructor.Sig, out returnType, out parameterTypes);
								MethodBuilder cb = ReflectUtil.DefineConstructor(typeBuilder, attribs, parameterTypes);
								if(setmodifiers)
								{
									AttributeHelper.SetModifiers(cb, (Modifiers)constructor.Modifiers, false);
								}
								CompilerClassLoader.AddDeclaredExceptions(cb, constructor.throws);
								CodeEmitter ilgen = CodeEmitter.Create(cb);
								constructor.Emit(classLoader, ilgen);
								ilgen.DoEmit();
								if(constructor.Attributes != null)
								{
									foreach(IKVM.Internal.MapXml.Attribute attr in constructor.Attributes)
									{
										AttributeHelper.SetCustomAttribute(classLoader, cb, attr);
									}
								}
							}
						}
						foreach(IKVM.Internal.MapXml.Constructor constructor in clazz.Constructors)
						{
							if(constructor.Attributes != null)
							{
								foreach(MethodWrapper mw in methods)
								{
									if(mw.Name == "<init>" && mw.Signature == constructor.Sig)
									{
										MethodBuilder mb = mw.GetMethod() as MethodBuilder;
										if(mb != null)
										{
											foreach(IKVM.Internal.MapXml.Attribute attr in constructor.Attributes)
											{
												AttributeHelper.SetCustomAttribute(classLoader, mb, attr);
											}
										}
									}
								}
							}
						}
					}
					if(clazz.Methods != null)
					{
						// HACK this isn't the right place to do this, but for now it suffices
						foreach(IKVM.Internal.MapXml.Method method in clazz.Methods)
						{
							// are we adding a new method?
							if(GetMethodWrapper(method.Name, method.Sig, false) == null)
							{
								bool setmodifiers = false;
								MethodAttributes attribs = method.MethodAttributes;
								MapModifiers(method.Modifiers, false, out setmodifiers, ref attribs, BaseTypeWrapper == null || BaseTypeWrapper.GetMethodWrapper(method.Name, method.Sig, true) == null);
								if(method.body == null && (attribs & MethodAttributes.Abstract) == 0)
								{
									Console.Error.WriteLine("Error: Method {0}.{1}{2} in xml remap file doesn't have a body.", clazz.Name, method.Name, method.Sig);
									continue;
								}
								Type returnType;
								Type[] parameterTypes;
								MapSignature(method.Sig, out returnType, out parameterTypes);
								MethodBuilder mb = typeBuilder.DefineMethod(method.Name, attribs, returnType, parameterTypes);
								if(setmodifiers)
								{
									AttributeHelper.SetModifiers(mb, (Modifiers)method.Modifiers, false);
								}
								if(method.@@override != null)
								{
									MethodWrapper mw = GetClassLoader().LoadClassByDottedName(method.@@override.Class).GetMethodWrapper(method.@@override.Name, method.Sig, true);
									mw.Link();
									typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
								}
								CompilerClassLoader.AddDeclaredExceptions(mb, method.throws);
								if(method.body != null)
								{
									CodeEmitter ilgen = CodeEmitter.Create(mb);
									method.Emit(classLoader, ilgen);
									ilgen.DoEmit();
								}
								if(method.Attributes != null)
								{
									foreach(IKVM.Internal.MapXml.Attribute attr in method.Attributes)
									{
										AttributeHelper.SetCustomAttribute(classLoader, mb, attr);
									}
								}
							}
						}
						foreach(IKVM.Internal.MapXml.Method method in clazz.Methods)
						{
							if(method.Attributes != null)
							{
								foreach(MethodWrapper mw in methods)
								{
									if(mw.Name == method.Name && mw.Signature == method.Sig)
									{
										MethodBuilder mb = mw.GetMethod() as MethodBuilder;
										if(mb != null)
										{
											foreach(IKVM.Internal.MapXml.Attribute attr in method.Attributes)
											{
												AttributeHelper.SetCustomAttribute(classLoader, mb, attr);
											}
										}
									}
								}
							}
						}
					}
					if(clazz.Interfaces != null)
					{
						foreach(IKVM.Internal.MapXml.Interface iface in clazz.Interfaces)
						{
							TypeWrapper tw = GetClassLoader().LoadClassByDottedName(iface.Name);
							// NOTE since this interface won't be part of the list in the ImplementAttribute,
							// it won't be visible from Java that the type implements this interface.
							typeBuilder.AddInterfaceImplementation(tw.TypeAsBaseType);
							if(iface.Methods != null)
							{
								foreach(IKVM.Internal.MapXml.Method m in iface.Methods)
								{
									MethodWrapper mw = tw.GetMethodWrapper(m.Name, m.Sig, false);
									if(mw == null)
									{
										throw new InvalidOperationException("Method " + m.Name + m.Sig + " not found in interface " + tw.Name);
									}
									mw.Link();
									MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(this, typeBuilder, tw.Name + "/" + m.Name, MethodAttributes.Private | MethodAttributes.NewSlot | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.CheckAccessOnOverride);
									AttributeHelper.HideFromJava(mb);
									typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
									CodeEmitter ilgen = CodeEmitter.Create(mb);
									m.Emit(classLoader, ilgen);
									ilgen.DoEmit();
								}
							}
						}
					}
				}
			}
		}

		protected override MethodBuilder DefineGhostMethod(TypeBuilder typeBuilder, string name, MethodAttributes attribs, MethodWrapper mw)
		{
			if(typeBuilderGhostInterface != null && mw.IsVirtual)
			{
				DefineMethodHelper helper = mw.GetDefineMethodHelper();
				MethodBuilder stub = helper.DefineMethod(this, typeBuilder, name, MethodAttributes.Public);
				((GhostMethodWrapper)mw).SetGhostMethod(stub);
				return helper.DefineMethod(this, typeBuilderGhostInterface, name, attribs);
			}
			return null;
		}

		protected override void FinishGhost(TypeBuilder typeBuilder, MethodWrapper[] methods)
		{
			if(typeBuilderGhostInterface != null)
			{
				// TODO consider adding methods from base interface and java.lang.Object as well
				for(int i = 0; i < methods.Length; i++)
				{
					// skip <clinit> and non-virtual interface methods introduced in Java 8
					GhostMethodWrapper gmw = methods[i] as GhostMethodWrapper;
					if(gmw != null)
					{
						TypeWrapper[] args = methods[i].GetParameters();
						MethodBuilder stub = gmw.GetGhostMethod();
						AddParameterMetadata(stub, methods[i]);
						AttributeHelper.SetModifiers(stub, methods[i].Modifiers, methods[i].IsInternal);
						CodeEmitter ilgen = CodeEmitter.Create(stub);
						CodeEmitterLabel end = ilgen.DefineLabel();
						TypeWrapper[] implementers = classLoader.GetGhostImplementers(this);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Ldfld, ghostRefField);
						ilgen.Emit(OpCodes.Dup);
						ilgen.Emit(OpCodes.Isinst, typeBuilderGhostInterface);
						CodeEmitterLabel label = ilgen.DefineLabel();
						ilgen.EmitBrfalse(label);
						ilgen.Emit(OpCodes.Castclass, typeBuilderGhostInterface);
						for(int k = 0; k < args.Length; k++)
						{
							ilgen.EmitLdarg(k + 1);
						}
						ilgen.Emit(OpCodes.Callvirt, (MethodInfo)methods[i].GetMethod());
						ilgen.EmitBr(end);
						ilgen.MarkLabel(label);
						for(int j = 0; j < implementers.Length; j++)
						{
							ilgen.Emit(OpCodes.Dup);
							ilgen.Emit(OpCodes.Isinst, implementers[j].TypeAsTBD);
							label = ilgen.DefineLabel();
							ilgen.EmitBrfalse(label);
							MethodWrapper mw = implementers[j].GetMethodWrapper(methods[i].Name, methods[i].Signature, true);
							if(mw == null)
							{
								if(methods[i].IsAbstract)
								{
									// This should only happen for remapped types (defined in map.xml), because normally you'd get a miranda method.
									throw new FatalCompilerErrorException(Message.GhostInterfaceMethodMissing, implementers[j].Name, Name, methods[i].Name, methods[i].Signature);
								}
								// We're inheriting a default method
								ilgen.Emit(OpCodes.Pop);
								ilgen.Emit(OpCodes.Ldarg_0);
								for (int k = 0; k < args.Length; k++)
								{
									ilgen.EmitLdarg(k + 1);
								}
								ilgen.Emit(OpCodes.Call, DefaultInterfaceMethodWrapper.GetImpl(methods[i]));
							}
							else
							{
								ilgen.Emit(OpCodes.Castclass, implementers[j].TypeAsTBD);
								for (int k = 0; k < args.Length; k++)
								{
									ilgen.EmitLdarg(k + 1);
								}
								mw.EmitCallvirt(ilgen);
							}
							ilgen.EmitBr(end);
							ilgen.MarkLabel(label);
						}
						// we need to do a null check (null fails all the isinst checks)
						ilgen.EmitNullCheck();
						ilgen.EmitThrow("java.lang.IncompatibleClassChangeError", Name);
						ilgen.MarkLabel(end);
						ilgen.Emit(OpCodes.Ret);
						ilgen.DoEmit();
					}
				}
				// HACK create a scope to enable reuse of "implementers" name
				if(true)
				{
					MethodBuilder mb;
					CodeEmitter ilgen;
					CodeEmitterLocal local;
					// add implicit conversions for all the ghost implementers
					TypeWrapper[] implementers = classLoader.GetGhostImplementers(this);
					for(int i = 0; i < implementers.Length; i++)
					{
						mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, TypeAsSignatureType, new Type[] { implementers[i].TypeAsSignatureType });
						AttributeHelper.HideFromJava(mb);
						ilgen = CodeEmitter.Create(mb);
						local = ilgen.DeclareLocal(TypeAsSignatureType);
						ilgen.Emit(OpCodes.Ldloca, local);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Stfld, ghostRefField);
						ilgen.Emit(OpCodes.Ldloca, local);
						ilgen.Emit(OpCodes.Ldobj, TypeAsSignatureType);			
						ilgen.Emit(OpCodes.Ret);
						ilgen.DoEmit();
					}
					// Implement the "IsInstance" method
					mb = ghostIsInstanceMethod;
					AttributeHelper.HideFromJava(mb);
					ilgen = CodeEmitter.Create(mb);
					CodeEmitterLabel end = ilgen.DefineLabel();
					for(int i = 0; i < implementers.Length; i++)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
						CodeEmitterLabel label = ilgen.DefineLabel();
						ilgen.EmitBrfalse(label);
						ilgen.Emit(OpCodes.Ldc_I4_1);
						ilgen.EmitBr(end);
						ilgen.MarkLabel(label);
					}
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Isinst, typeBuilderGhostInterface);
					ilgen.Emit(OpCodes.Ldnull);
					ilgen.Emit(OpCodes.Cgt_Un);
					ilgen.MarkLabel(end);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();
					// Implement the "IsInstanceArray" method
					mb = ghostIsInstanceArrayMethod;
					AttributeHelper.HideFromJava(mb);
					ilgen = CodeEmitter.Create(mb);
					CodeEmitterLocal localType = ilgen.DeclareLocal(Types.Type);
					CodeEmitterLocal localRank = ilgen.DeclareLocal(Types.Int32);
					ilgen.Emit(OpCodes.Ldarg_0);
					CodeEmitterLabel skip = ilgen.DefineLabel();
					ilgen.EmitBrtrue(skip);
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ret);
					ilgen.MarkLabel(skip);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Call, Compiler.getTypeMethod);
					ilgen.Emit(OpCodes.Stloc, localType);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Stloc, localRank);
					skip = ilgen.DefineLabel();
					ilgen.EmitBr(skip);
					CodeEmitterLabel iter = ilgen.DefineLabel();
					ilgen.MarkLabel(iter);
					ilgen.Emit(OpCodes.Ldloc, localType);
					ilgen.Emit(OpCodes.Callvirt, Types.Type.GetMethod("GetElementType"));
					ilgen.Emit(OpCodes.Stloc, localType);
					ilgen.Emit(OpCodes.Ldloc, localRank);
					ilgen.Emit(OpCodes.Ldc_I4_1);
					ilgen.Emit(OpCodes.Sub);
					ilgen.Emit(OpCodes.Stloc, localRank);
					ilgen.Emit(OpCodes.Ldloc, localRank);
					CodeEmitterLabel typecheck = ilgen.DefineLabel();
					ilgen.EmitBrfalse(typecheck);
					ilgen.MarkLabel(skip);
					ilgen.Emit(OpCodes.Ldloc, localType);
					ilgen.Emit(OpCodes.Callvirt, Types.Type.GetMethod("get_IsArray"));
					ilgen.EmitBrtrue(iter);
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ret);
					ilgen.MarkLabel(typecheck);
					for(int i = 0; i < implementers.Length; i++)
					{
						ilgen.Emit(OpCodes.Ldtoken, implementers[i].TypeAsTBD);
						ilgen.Emit(OpCodes.Call, Types.Type.GetMethod("GetTypeFromHandle"));
						ilgen.Emit(OpCodes.Ldloc, localType);
						ilgen.Emit(OpCodes.Callvirt, Types.Type.GetMethod("IsAssignableFrom"));
						CodeEmitterLabel label = ilgen.DefineLabel();
						ilgen.EmitBrfalse(label);
						ilgen.Emit(OpCodes.Ldc_I4_1);
						ilgen.Emit(OpCodes.Ret);
						ilgen.MarkLabel(label);
					}
					ilgen.Emit(OpCodes.Ldtoken, typeBuilderGhostInterface);
					ilgen.Emit(OpCodes.Call, Types.Type.GetMethod("GetTypeFromHandle"));
					ilgen.Emit(OpCodes.Ldloc, localType);
					ilgen.Emit(OpCodes.Callvirt, Types.Type.GetMethod("IsAssignableFrom"));
					skip = ilgen.DefineLabel();
					ilgen.EmitBrfalse(skip);
					ilgen.Emit(OpCodes.Ldc_I4_1);
					ilgen.Emit(OpCodes.Ret);
					ilgen.MarkLabel(skip);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldtoken, typeBuilder);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Call, StaticCompiler.GetRuntimeType("IKVM.Runtime.GhostTag").GetMethod("IsGhostArrayInstance", BindingFlags.NonPublic | BindingFlags.Static));
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();
						
					// Implement the "Cast" method
					mb = ghostCastMethod;
					AttributeHelper.HideFromJava(mb);
					ilgen = CodeEmitter.Create(mb);
					end = ilgen.DefineLabel();
					for(int i = 0; i < implementers.Length; i++)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
						ilgen.EmitBrtrue(end);
					}
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Castclass, typeBuilderGhostInterface);
					ilgen.Emit(OpCodes.Pop);
					ilgen.MarkLabel(end);
					local = ilgen.DeclareLocal(TypeAsSignatureType);
					ilgen.Emit(OpCodes.Ldloca, local);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Stfld, ghostRefField);
					ilgen.Emit(OpCodes.Ldloca, local);
					ilgen.Emit(OpCodes.Ldobj, TypeAsSignatureType);	
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();
					// Add "ToObject" methods
					mb = typeBuilder.DefineMethod("ToObject", MethodAttributes.HideBySig | MethodAttributes.Public, Types.Object, Type.EmptyTypes);
					AttributeHelper.HideFromJava(mb);
					ilgen = CodeEmitter.Create(mb);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldfld, ghostRefField);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();

					// Implement the "CastArray" method
					// NOTE unlike "Cast" this doesn't return anything, it just throws a ClassCastException if the
					// cast is unsuccessful. Also, because of the complexity of this test, we call IsInstanceArray
					// instead of reimplementing the check here.
					mb = ghostCastArrayMethod;
					AttributeHelper.HideFromJava(mb);
					ilgen = CodeEmitter.Create(mb);
					end = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.EmitBrfalse(end);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Call, ghostIsInstanceArrayMethod);
					ilgen.EmitBrtrue(end);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldtoken, typeBuilder);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Call, StaticCompiler.GetRuntimeType("IKVM.Runtime.GhostTag").GetMethod("ThrowClassCastException", BindingFlags.NonPublic | BindingFlags.Static));
					ilgen.MarkLabel(end);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();

					// Implement the "Equals" method
					mb = typeBuilder.DefineMethod("Equals", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Virtual, Types.Boolean, new Type[] { Types.Object });
					AttributeHelper.HideFromJava(mb);
					ilgen = CodeEmitter.Create(mb);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldfld, ghostRefField);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Ceq);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();

					// Implement the "GetHashCode" method
					mb = typeBuilder.DefineMethod("GetHashCode", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Virtual, Types.Int32, Type.EmptyTypes);
					AttributeHelper.HideFromJava(mb);
					ilgen = CodeEmitter.Create(mb);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldfld, ghostRefField);
					ilgen.Emit(OpCodes.Callvirt, Types.Object.GetMethod("GetHashCode"));
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();

					// Implement the "op_Equality" method
					mb = typeBuilder.DefineMethod("op_Equality", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, Types.Boolean, new Type[] { typeBuilder, typeBuilder });
					AttributeHelper.HideFromJava(mb);
					ilgen = CodeEmitter.Create(mb);
					ilgen.EmitLdarga(0);
					ilgen.Emit(OpCodes.Ldfld, ghostRefField);
					ilgen.EmitLdarga(1);
					ilgen.Emit(OpCodes.Ldfld, ghostRefField);
					ilgen.Emit(OpCodes.Ceq);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();

					// Implement the "op_Inequality" method
					mb = typeBuilder.DefineMethod("op_Inequality", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, Types.Boolean, new Type[] { typeBuilder, typeBuilder });
					AttributeHelper.HideFromJava(mb);
					ilgen = CodeEmitter.Create(mb);
					ilgen.EmitLdarga(0);
					ilgen.Emit(OpCodes.Ldfld, ghostRefField);
					ilgen.EmitLdarga(1);
					ilgen.Emit(OpCodes.Ldfld, ghostRefField);
					ilgen.Emit(OpCodes.Ceq);
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ceq);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();
				}
			}
		}

		protected override void FinishGhostStep2()
		{
			if(typeBuilderGhostInterface != null)
			{
				typeBuilderGhostInterface.CreateType();
			}
		}

		protected override TypeBuilder DefineGhostType(string mangledTypeName, TypeAttributes typeAttribs)
		{
			typeAttribs &= ~(TypeAttributes.Interface | TypeAttributes.Abstract);
			typeAttribs |= TypeAttributes.Class | TypeAttributes.Sealed;
			TypeBuilder typeBuilder = classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs, Types.ValueType);
			AttributeHelper.SetGhostInterface(typeBuilder);
			AttributeHelper.SetModifiers(typeBuilder, Modifiers, IsInternal);
			ghostRefField = typeBuilder.DefineField("__<ref>", Types.Object, FieldAttributes.Public | FieldAttributes.SpecialName);
			typeBuilderGhostInterface = typeBuilder.DefineNestedType("__Interface", TypeAttributes.Interface | TypeAttributes.Abstract | TypeAttributes.NestedPublic);
			AttributeHelper.HideFromJava(typeBuilderGhostInterface);
			ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, Types.Boolean, new Type[] { Types.Object });
			ghostIsInstanceMethod.DefineParameter(1, ParameterAttributes.None, "obj");
			ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, Types.Boolean, new Type[] { Types.Object, Types.Int32 });
			ghostIsInstanceArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
			ghostIsInstanceArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
			ghostCastMethod = typeBuilder.DefineMethod("Cast", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeBuilder, new Type[] { Types.Object });
			ghostCastMethod.DefineParameter(1, ParameterAttributes.None, "obj");
			ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, Types.Void, new Type[] { Types.Object, Types.Int32 });
			ghostCastArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
			ghostCastArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
			return typeBuilder;
		}

		internal override FieldInfo GhostRefField
		{
			get
			{
				return ghostRefField;
			}
		}

		internal override void EmitCheckcast(CodeEmitter ilgen)
		{
			if(IsGhost)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Call, ghostCastMethod);
				ilgen.Emit(OpCodes.Pop);
			}
			else if(IsGhostArray)
			{
				ilgen.Emit(OpCodes.Dup);
				TypeWrapper tw = this;
				int rank = 0;
				while(tw.IsArray)
				{
					rank++;
					tw = tw.ElementTypeWrapper;
				}
				ilgen.EmitLdc_I4(rank);
				ilgen.Emit(OpCodes.Call, ghostCastArrayMethod);
				ilgen.Emit(OpCodes.Castclass, ArrayTypeWrapper.MakeArrayType(Types.Object, rank));
			}
			else
			{
				base.EmitCheckcast(ilgen);
			}
		}

		internal override void EmitInstanceOf(CodeEmitter ilgen)
		{
			if(IsGhost)
			{
				ilgen.Emit(OpCodes.Call, ghostIsInstanceMethod);
			}
			else if(IsGhostArray)
			{
				ilgen.Emit(OpCodes.Call, ghostIsInstanceArrayMethod);
			}
			else
			{
				base.EmitInstanceOf(ilgen);
			}
		}

		internal void SetAnnotation(Annotation annotation)
		{
			this.annotation = annotation;
		}

		internal override Annotation Annotation
		{
			get
			{
				return annotation;
			}
		}

		internal void SetEnumType(Type enumType)
		{
			this.enumType = enumType;
		}

		internal override Type EnumType
		{
			get
			{
				return enumType;
			}
		}

		private sealed class ReplacedMethodWrapper : MethodWrapper
		{
			private IKVM.Internal.MapXml.InstructionList code;

			internal ReplacedMethodWrapper(TypeWrapper tw, string name, string sig, IKVM.Internal.MapXml.InstructionList code)
				: base(tw, name, sig, null, null, null, Modifiers.Public, MemberFlags.None)
			{
				this.code = code;
			}

			internal ReplacedMethodWrapper(ClassFile.ConstantPoolItemMI cpi, IKVM.Internal.MapXml.InstructionList code)
				: base(cpi.GetClassType(), cpi.Name, cpi.Signature, null, cpi.GetRetType(), cpi.GetArgTypes(), Modifiers.Public, MemberFlags.None)
			{
				this.code = code;
			}

			protected override void DoLinkMethod()
			{
			}

			private void DoEmit(CodeEmitter ilgen)
			{
				IKVM.Internal.MapXml.CodeGenContext context = new IKVM.Internal.MapXml.CodeGenContext(this.DeclaringType.GetClassLoader());
				// we don't want the line numbers from map.xml, so we have our own emit loop
				for (int i = 0; i < code.invoke.Length; i++)
				{
					code.invoke[i].Generate(context, ilgen);
				}
			}

			internal override void EmitCall(CodeEmitter ilgen)
			{
				DoEmit(ilgen);
			}

			internal override void EmitCallvirt(CodeEmitter ilgen)
			{
				DoEmit(ilgen);
			}

			internal override void EmitNewobj(CodeEmitter ilgen)
			{
				DoEmit(ilgen);
			}
		}

		internal override MethodWrapper[] GetReplacedMethodsFor(MethodWrapper mw)
		{
			IKVM.Internal.MapXml.ReplaceMethodCall[] replacedMethods = ((CompilerClassLoader)GetClassLoader()).GetReplacedMethodsFor(mw);
			MethodWrapper[] baseReplacedMethodWrappers = base.GetReplacedMethodsFor(mw);
			if (replacedMethods != null || baseReplacedMethodWrappers != null || this.replacedMethods != null)
			{
				List<MethodWrapper> list = new List<MethodWrapper>();
				if (replacedMethods != null)
				{
					for (int i = 0; i < replacedMethods.Length; i++)
					{
						list.Add(new ReplacedMethodWrapper(GetClassLoader().LoadClassByDottedName(replacedMethods[i].Class), replacedMethods[i].Name, replacedMethods[i].Sig, replacedMethods[i].code));
					}
				}
				if (baseReplacedMethodWrappers != null)
				{
					list.AddRange(baseReplacedMethodWrappers);
				}
				if (this.replacedMethods != null)
				{
					list.AddRange(this.replacedMethods);
				}
				return list.ToArray();
			}
			return null;
		}

		internal override bool IsFastClassLiteralSafe
		{
			get { return true; }
		}

		internal MethodWrapper ReplaceMethodWrapper(MethodWrapper mw)
		{
			if (replacedMethods != null)
			{
				foreach (MethodWrapper r in replacedMethods)
				{
					if (mw.DeclaringType == r.DeclaringType
						&& mw.Name == r.Name
						&& mw.Signature == r.Signature)
					{
						return r;
					}
				}
			}
			return mw;
		}

		internal override MethodBase GetBaseSerializationConstructor()
		{
			if (workaroundBaseClass != null)
			{
				return workaroundBaseClass.GetSerializationConstructor();
			}
			else
			{
				return base.GetBaseSerializationConstructor();
			}
		}
	}
}
@


1.87
log
@Removed sig decoding methods with implicit LoadMode.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2014 Jeroen Frijters
d510 1
a510 1
		private static void MapModifiers(MapXml.MapModifiers mapmods, bool isConstructor, out bool setmodifiers, ref MethodAttributes attribs)
d546 4
d637 1
a637 1
								MapModifiers(constructor.Modifiers, true, out setmodifiers, ref attribs);
d690 1
a690 1
								MapModifiers(method.Modifiers, false, out setmodifiers, ref attribs);
@


1.86
log
@Bug fix. Handle malformed UTF-16 (invalid surrogates) in type/member names and annotations.
@
text
@d395 2
a396 2
				TypeWrapper typeWrapper = GetClassLoader().RetTypeWrapperFromSigNoThrow(prop.Sig);
				TypeWrapper[] propargs = GetClassLoader().ArgTypeWrapperListFromSigNoThrow(prop.Sig);
d570 2
a571 2
			returnType = GetClassLoader().RetTypeWrapperFromSigNoThrow(sig).TypeAsSignatureType;
			TypeWrapper[] parameterTypeWrappers = GetClassLoader().ArgTypeWrapperListFromSigNoThrow(sig);
@


1.85
log
@Added support for defining abstract methods in remap file.
@
text
@d81 1
a81 1
					string name = "__WorkaroundBaseClass__." + Name;
@


1.84
log
@Emit proper error when remapped type doesn't implement interface method.
@
text
@d684 4
a687 1
								if(method.body == null)
a691 3
								bool setmodifiers = false;
								MethodAttributes attribs = method.MethodAttributes;
								MapModifiers(method.Modifiers, false, out setmodifiers, ref attribs);
d707 6
a712 3
								CodeEmitter ilgen = CodeEmitter.Create(mb);
								method.Emit(classLoader, ilgen);
								ilgen.DoEmit();
@


1.83
log
@GhostMethodWrapper can also be a default method.
@
text
@d825 5
@


1.82
log
@Generate both versions of a ghost interface method during method linking.
@
text
@d822 13
a834 2
							ilgen.Emit(OpCodes.Castclass, implementers[j].TypeAsTBD);
							for(int k = 0; k < args.Length; k++)
d836 6
a841 1
								ilgen.EmitLdarg(k + 1);
a842 2
							MethodWrapper mw = implementers[j].GetMethodWrapper(methods[i].Name, methods[i].Signature, true);
							mw.EmitCallvirt(ilgen);
@


1.81
log
@Allow classes defined by Unsafe.defineAnonymousClass() access to private methods of their host class.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
d772 1
a772 1
		protected override MethodBuilder DefineGhostMethod(string name, MethodAttributes attribs, MethodWrapper mw)
d774 1
a774 1
			if(typeBuilderGhostInterface != null)
d776 4
a779 1
				return mw.GetDefineMethodHelper().DefineMethod(this, typeBuilderGhostInterface, name, attribs);
d792 2
a793 1
					if(methods[i].IsVirtual)
d796 1
a796 1
						MethodBuilder stub = methods[i].GetDefineMethodHelper().DefineMethod(this, typeBuilder, methods[i].Name, MethodAttributes.Public);
@


1.80
log
@- Added IsVirtual property to ClassFile.Method and MethodWrapper to make the code a bit easier to read.
- Fixed Java 8 interface method handling for annotations and ghost interfaces.
@
text
@d51 1
a51 1
			: base(f, loader, null)
@


1.79
log
@Centralized switches to control C# interop workarounds.
@
text
@d788 2
a789 2
					// skip <clinit>
					if(!methods[i].IsStatic)
@


1.78
log
@sealed DynamicTypeWrapper in runtime.
@
text
@d58 1
a58 1
			if (this.IsPublic && this.IsAbstract && baseTypeWrapper.IsPublic && baseTypeWrapper.IsAbstract)
@


1.77
log
@Introduced ArrayUtil.Concat() methods.
@
text
@a509 30
		protected override bool IsPInvokeMethod(ClassFile.Method m)
		{
			Dictionary<string, IKVM.Internal.MapXml.Class> mapxml = classLoader.GetMapXmlClasses();
			if(mapxml != null)
			{
				IKVM.Internal.MapXml.Class clazz;
				if(mapxml.TryGetValue(this.Name, out clazz) && clazz.Methods != null)
				{
					foreach(IKVM.Internal.MapXml.Method method in clazz.Methods)
					{
						if(method.Name == m.Name && method.Sig == m.Signature)
						{
							if(method.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute attr in method.Attributes)
								{
									if(StaticCompiler.GetType(classLoader, attr.Type) == JVM.Import(typeof(System.Runtime.InteropServices.DllImportAttribute)))
									{
										return true;
									}
								}
							}
							break;
						}
					}
				}
			}
			return base.IsPInvokeMethod(m);
		}

@


1.76
log
@Removed unused (and bogus) parameter from TypeWrapper.EmitCheckcast() and EmitInstanceOf().
@
text
@d300 1
a300 4
								FieldWrapper[] newFields = new FieldWrapper[fields.Length + 1];
								Array.Copy(fields, newFields, fields.Length);
								fields = newFields;
								fields[fields.Length - 1] = FieldWrapper.Create(this, null, null, field.Name, field.Sig, new ExModifiers((Modifiers)field.Modifiers, false));
d471 1
a471 3
					Type[] args = new Type[indexer.Length + 1];
					indexer.CopyTo(args, 0);
					args[args.Length - 1] = typeWrapper.TypeAsSignatureType;
@


1.75
log
@Implemented package access checks (dynamic mode only).
@
text
@d1124 1
a1124 1
		internal override void EmitCheckcast(TypeWrapper context, CodeEmitter ilgen)
d1148 1
a1148 1
				base.EmitCheckcast(context, ilgen);
d1152 1
a1152 1
		internal override void EmitInstanceOf(TypeWrapper context, CodeEmitter ilgen)
d1164 1
a1164 1
				base.EmitInstanceOf(context, ilgen);
@


1.74
log
@Bug fix. Private methods declared in map.xml should not be made virtual.
@
text
@d51 1
a51 1
			: base(f, loader)
@


1.73
log
@Removed remaining ConstructorBuilder usages.
@
text
@d583 4
a586 1
					attribs |= MethodAttributes.Virtual;
@


1.72
log
@Removed more ConstructorBuilder usage to fix regression (constructor custom attributes specified map.xml were not applied).
@
text
@d120 1
a120 1
			private ConstructorInfo baseSerializationCtor;
d129 1
a129 1
			internal ConstructorInfo GetSerializationConstructor()
d232 1
a232 1
		internal void AddXmlMapParameterAttributes(MethodBase method, string className, string methodName, string methodSig, ref ParameterBuilder[] pbs)
d1286 1
a1286 1
		internal override ConstructorInfo GetBaseSerializationConstructor()
@


1.71
log
@Stop using ConstructorBuilder (always use MethodBuilder).
@
text
@d669 1
a669 1
								ConstructorBuilder cb = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, parameterTypes);
d695 1
a695 1
										ConstructorBuilder mb = mw.GetMethod() as ConstructorBuilder;
@


1.71.2.1
log
@- Fixed build number
- Fixed .NET 4.0 build issues
- Fixed map.xml custom attribute application regression
- Updated HOWTO
@
text
@d669 1
a669 1
								MethodBuilder cb = ReflectUtil.DefineConstructor(typeBuilder, attribs, parameterTypes);
d695 1
a695 1
										MethodBuilder mb = mw.GetMethod() as MethodBuilder;
@


1.70
log
@- Marked MemberWrapper class abstract.
- Marked all classes that don't (and shouldn't) have subclasses sealed.
@
text
@d160 1
a160 1
			private ConstructorBuilder constructorBuilder;
@


1.69
log
@- Made CodeEmitter more "type safe" by adding specific EmitXxx methods instead of following the more general ILGenerator pattern.
- Added some new optimizations to CodeEmitter (disabled unless experimental optimizations are enabled).
- Added some invariant checks to CodeEmitter to help debug optimizations (and document the invariants).
@
text
@d37 1
a37 1
	class AotTypeWrapper : DynamicTypeWrapper
@


1.68
log
@Removed method name mangling and depend on custom modifiers instead.
@
text
@d180 1
a180 1
					ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
d452 1
a452 1
									ilgen.Emit(OpCodes.Ldarg, (short)i);
d461 1
a461 1
									ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
d493 1
a493 1
									ilgen.Emit(OpCodes.Ldarg, (short)i);
d502 1
a502 1
									ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
d835 1
a835 1
						ilgen.Emit(OpCodes.Brfalse_S, label);
d839 1
a839 1
							ilgen.Emit(OpCodes.Ldarg_S, (byte)(k + 1));
d842 1
a842 1
						ilgen.Emit(OpCodes.Br, end);
d849 1
a849 1
							ilgen.Emit(OpCodes.Brfalse_S, label);
d853 1
a853 1
								ilgen.Emit(OpCodes.Ldarg_S, (byte)(k + 1));
d857 1
a857 1
							ilgen.Emit(OpCodes.Br, end);
d900 1
a900 1
						ilgen.Emit(OpCodes.Brfalse_S, label);
d902 1
a902 1
						ilgen.Emit(OpCodes.Br, end);
d920 1
a920 1
					ilgen.Emit(OpCodes.Brtrue_S, skip);
d930 1
a930 1
					ilgen.Emit(OpCodes.Br_S, skip);
d942 1
a942 1
					ilgen.Emit(OpCodes.Brfalse_S, typecheck);
d946 1
a946 1
					ilgen.Emit(OpCodes.Brtrue_S, iter);
d957 1
a957 1
						ilgen.Emit(OpCodes.Brfalse_S, label);
d967 1
a967 1
					ilgen.Emit(OpCodes.Brfalse_S, skip);
d987 1
a987 1
						ilgen.Emit(OpCodes.Brtrue, end);
d1019 1
a1019 1
					ilgen.Emit(OpCodes.Brfalse_S, end);
d1023 1
a1023 1
					ilgen.Emit(OpCodes.Brtrue_S, end);
d1057 1
a1057 1
					ilgen.Emit(OpCodes.Ldarga_S, (byte)0);
d1059 1
a1059 1
					ilgen.Emit(OpCodes.Ldarga_S, (byte)1);
d1069 1
a1069 1
					ilgen.Emit(OpCodes.Ldarga_S, (byte)0);
d1071 1
a1071 1
					ilgen.Emit(OpCodes.Ldarga_S, (byte)1);
d1139 1
a1139 1
				ilgen.Emit(OpCodes.Ldc_I4, rank);
@


1.67
log
@More TypeAsBuiler usage removed.
@
text
@d445 1
a445 1
							mb = typeBuilder.DefineMethod(GenerateUniqueMethodName("get_" + prop.Name, mw), GetPropertyMethodAttributes(mw, final), typeWrapper.TypeAsSignatureType, indexer);
d486 1
a486 1
							mb = typeBuilder.DefineMethod(GenerateUniqueMethodName("set_" + prop.Name, mw), GetPropertyMethodAttributes(mw, final), mw.ReturnTypeForDefineMethod, args);
@


1.66
log
@Removed duplication of keeping track of AnnotationBuilder and moved enum nested type to AotTypeWrapper as well.
@
text
@d144 1
a144 1
						MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(), typeBuilder, mw.Name, MethodAttributes.FamORAssem | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.CheckAccessOnOverride);
d790 1
a790 1
									MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(this, tw.Name + "/" + m.Name, MethodAttributes.Private | MethodAttributes.NewSlot | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.CheckAccessOnOverride);
d808 1
a808 1
				return mw.GetDefineMethodHelper().DefineMethod(GetClassLoader().GetTypeWrapperFactory(), typeBuilderGhostInterface, name, attribs);
d824 1
a824 1
						MethodBuilder stub = methods[i].GetDefineMethodHelper().DefineMethod(this, methods[i].Name, MethodAttributes.Public);
@


1.65
log
@Introduced DefineMethodHelper class as an abstraction over method signatures (the parameter/return types) to make it easier to start using modopt for methods.
@
text
@d46 1
d1178 13
@


1.64
log
@Support remap file <throws /> element for methods and constructors defined in remap file.
@
text
@d85 2
a86 1
					TypeBuilder typeBuilder = classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(name, TypeAttributes.Public | TypeAttributes.Abstract, base.GetBaseTypeForDefineType());
d95 1
a95 1
							constructors.Add(new ConstructorForwarder(typeBuilder, mw));
d143 1
a143 1
						MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, MethodAttributes.FamORAssem | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.CheckAccessOnOverride, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
d156 1
d161 1
a161 1
			internal ConstructorForwarder(TypeBuilder typeBuilder, MethodWrapper ctor)
d164 1
d172 2
a173 2
				Type[] parameters = ctor.GetParametersForDefineMethod();
				constructorBuilder = typeBuilder.DefineConstructor(MethodAttributes.PrivateScope, CallingConventions.Standard, parameters);
d177 1
a177 1
				for (int i = 1; i <= parameters.Length; i++)
d789 1
a789 1
									MethodBuilder mb = typeBuilder.DefineMethod(tw.Name + "/" + m.Name, MethodAttributes.Private | MethodAttributes.NewSlot | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.CheckAccessOnOverride, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
d807 1
a807 1
				return typeBuilderGhostInterface.DefineMethod(name, attribs, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
d823 1
a823 1
						MethodBuilder stub = typeBuilder.DefineMethod(methods[i].Name, MethodAttributes.Public, methods[i].ReturnTypeForDefineMethod, methods[i].GetParametersForDefineMethod());
@


1.63
log
@Call constructor/method.Emit instead of body directly to allow prologue to be inserted.
@
text
@d670 1
d734 1
@


1.62
log
@Added method prologue support to remap file.
@
text
@d671 1
a671 1
								constructor.body.Emit(classLoader, ilgen);
d734 1
a734 1
								method.body.Emit(classLoader, ilgen);
@


1.61
log
@Build intermediate store of MSIL code in CodeEmitter to allow post-processing optimization steps.
@
text
@d307 1
a307 1
		protected override bool EmitMapXmlMethodBody(CodeEmitter ilgen, ClassFile f, ClassFile.Method m)
d309 5
@


1.60
log
@Wrapped LocalBuilder in new CodeEmitterLocal class to allow CodeEmitter to encapsulate the ILGenerator fully.
@
text
@d146 1
d180 1
d457 1
d498 1
d667 1
d730 1
d782 3
a784 1
									m.Emit(classLoader, CodeEmitter.Create(mb));
d854 1
d877 1
d900 1
d965 1
d989 1
d997 1
d1019 1
d1030 1
d1040 1
d1052 1
d1066 1
@


1.59
log
@Renamed StaticCompiler.GetType() that is used exclusively by map.xml processing to make it more obvious and added error message (and abort the compile). The remaining StaticCompiler.GetType() now behaves more like Type.GetType() in that it returns null if the type isn't found.
@
text
@d853 1
a853 1
					LocalBuilder local;
d894 2
a895 2
					LocalBuilder localType = ilgen.DeclareLocal(Types.Type);
					LocalBuilder localRank = ilgen.DeclareLocal(Types.Int32);
@


1.58
log
@Added extra indirection thru MethodWrapper for intrinsic method call emitting to allow .NET delegate constructor optimization to use instrinsic infrastructure instead of requiring EmitNewobj to pass a MethodAnalyzer and opcode index.
@
text
@d518 1
a518 1
									if(StaticCompiler.GetType(classLoader, attr.Type, false) == JVM.Import(typeof(System.Runtime.InteropServices.DllImportAttribute)))
@


1.57
log
@Custom attribute types in map.xml should be resolved via the referenced assemblies, not globally.
@
text
@d1188 1
a1188 1
			internal override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
@


1.56
log
@Changed StaticCompiler.GetType() to be multi-target aware. Instead of looking thru all assemblies currently loaded, only the relevant referenced assemblies are searched.

Note that this is a (minor) breaking change. Types referenced in -remap:map.xml file are now only resolved against directly referenced assemblies.
@
text
@d518 1
a518 1
									if(JVM.GetType(attr.Type, false) == JVM.Import(typeof(System.Runtime.InteropServices.DllImportAttribute)))
@


1.55
log
@Fix for bug #2946842.
@
text
@d952 1
a952 1
					ilgen.Emit(OpCodes.Call, StaticCompiler.GetType("IKVM.Runtime.GhostTag").GetMethod("IsGhostArrayInstance", BindingFlags.NonPublic | BindingFlags.Static));
d1002 1
a1002 1
					ilgen.Emit(OpCodes.Call, StaticCompiler.GetType("IKVM.Runtime.GhostTag").GetMethod("ThrowClassCastException", BindingFlags.NonPublic | BindingFlags.Static));
@


1.54
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@d88 1
a88 1
					workaroundBaseClass = new WorkaroundBaseClass(typeBuilder, methods.ToArray());
a96 1
					Serialization.AddAutomagicSerializationToWorkaroundBaseClass(typeBuilder);
d107 1
a107 1
			lock (this)
d109 1
a109 5
				if (workaroundBaseClass != null)
				{
					workaroundBaseClass.Finish();
					workaroundBaseClass = null;
				}
d115 1
d118 1
d120 1
a120 1
			internal WorkaroundBaseClass(TypeBuilder typeBuilder, MethodWrapper[] methods)
d122 1
d127 9
d138 1
a138 1
				foreach (MethodWrapper mw in methods)
d140 8
a147 4
					MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, MethodAttributes.FamORAssem | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.CheckAccessOnOverride, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
					AttributeHelper.HideFromJava(mb);
					CodeEmitter ilgen = CodeEmitter.Create(mb);
					ilgen.EmitThrow("java.lang.AbstractMethodError");
a148 1
				typeBuilder.CreateType();
d1225 29
@


1.53
log
@Moved non-throwing signature parsing from ClassFile.cs to ClassLoaderWrapper.cs (and merged it with the throwing variant). This avoids new stub generator having to include ClassFile.cs.
@
text
@a26 1
#if IKVM_REF_EMIT
a29 4
#else
using System.Reflection;
using System.Reflection.Emit;
#endif
@


1.52
log
@Integrated new IKVM.Reflection implementation.
@
text
@d382 2
a383 2
				TypeWrapper typeWrapper = ClassFile.RetTypeWrapperFromSig(GetClassLoader(), prop.Sig);
				TypeWrapper[] propargs = ClassFile.ArgTypeWrapperListFromSig(GetClassLoader(), prop.Sig);
d584 2
a585 2
			returnType = ClassFile.RetTypeWrapperFromSig(GetClassLoader(), sig).TypeAsSignatureType;
			TypeWrapper[] parameterTypeWrappers = ClassFile.ArgTypeWrapperListFromSig(GetClassLoader(), sig);
@


1.51
log
@Don't automatically hide "op_Implicit" methods. Instead mark the ones we automatically generate with HideFromJavaAttribute.
@
text
@a26 1
using System.Reflection;
d28 1
d30 1
d32 1
@


1.50
log
@Mangle all artificial type names if they clash with Java type names in the same assembly.
@
text
@d852 1
@


1.49
log
@Fixed automagic serialization interop to work correctly in the face of a __WorkaroundBaseClass__ base type.
@
text
@d84 1
a84 1
					while (!classLoader.GetTypeWrapperFactory().ReserveName(name))
@


1.48
log
@Use cached methods instead of looking them up again.
@
text
@d100 1
@


1.47
log
@More type funneling.
@
text
@d894 1
a894 1
					ilgen.Emit(OpCodes.Call, Types.Object.GetMethod("GetType"));
@


1.46
log
@Replaced most type literals with static field access (in Types class) or warpped JVM.Import() around them.
@
text
@d510 1
a510 1
									if(Type.GetType(attr.Type) == typeof(System.Runtime.InteropServices.DllImportAttribute))
@


1.45
log
@Removed EmitHelper class and moved its methods into CodeEmitter.
@
text
@d885 2
a886 2
					LocalBuilder localType = ilgen.DeclareLocal(typeof(Type));
					LocalBuilder localRank = ilgen.DeclareLocal(typeof(int));
d894 1
a894 1
					ilgen.Emit(OpCodes.Call, typeof(object).GetMethod("GetType"));
d903 1
a903 1
					ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("GetElementType"));
d914 1
a914 1
					ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("get_IsArray"));
d922 1
a922 1
						ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
d924 1
a924 1
						ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("IsAssignableFrom"));
d932 1
a932 1
					ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
d934 1
a934 1
					ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("IsAssignableFrom"));
d969 1
a969 1
					mb = typeBuilder.DefineMethod("ToObject", MethodAttributes.HideBySig | MethodAttributes.Public, typeof(object), Type.EmptyTypes);
d998 1
a998 1
					mb = typeBuilder.DefineMethod("Equals", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Virtual, typeof(bool), new Type[] { typeof(object) });
d1008 1
a1008 1
					mb = typeBuilder.DefineMethod("GetHashCode", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Virtual, typeof(int), Type.EmptyTypes);
d1013 1
a1013 1
					ilgen.Emit(OpCodes.Callvirt, typeof(object).GetMethod("GetHashCode"));
d1017 1
a1017 1
					mb = typeBuilder.DefineMethod("op_Equality", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, typeof(bool), new Type[] { typeBuilder, typeBuilder });
d1028 1
a1028 1
					mb = typeBuilder.DefineMethod("op_Inequality", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, typeof(bool), new Type[] { typeBuilder, typeBuilder });
d1055 1
a1055 1
			TypeBuilder typeBuilder = classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs, typeof(ValueType));
d1058 1
a1058 1
			ghostRefField = typeBuilder.DefineField("__<ref>", typeof(object), FieldAttributes.Public | FieldAttributes.SpecialName);
d1061 1
a1061 1
			ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object) });
d1063 1
a1063 1
			ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object), typeof(int) });
d1066 1
a1066 1
			ghostCastMethod = typeBuilder.DefineMethod("Cast", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeBuilder, new Type[] { typeof(object) });
d1068 1
a1068 1
			ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(object), typeof(int) });
d1102 1
a1102 1
				ilgen.Emit(OpCodes.Castclass, ArrayTypeWrapper.MakeArrayType(typeof(object), rank));
@


1.45.2.1
log
@Fixed automagic serialization interop to work correctly in the face of a __WorkaroundBaseClass__ base type.
@
text
@a99 1
					Serialization.AddAutomagicSerializationToWorkaroundBaseClass(typeBuilder);
@


1.45.2.2
log
@- Update version to 0.42.0.4
Backported:
- Mangle all artificial type names if they clash with Java type names in the same assembly.
- Fix for http://gcc.gnu.org/bugzilla/show_bug.cgi?id=41696
- Fixed exception sorter to be correct when invoked with two references to the same object.
@
text
@d84 1
a84 1
					while (!classLoader.ReserveName(name))
@


1.45.2.3
log
@Back port of fix for #2946842.
@
text
@d91 1
a91 1
					workaroundBaseClass = new WorkaroundBaseClass(this, typeBuilder, methods.ToArray());
d100 1
d111 1
a111 1
			if (workaroundBaseClass != null)
d113 5
a117 1
				workaroundBaseClass.Finish();
a122 1
			private readonly AotTypeWrapper wrapper;
a124 2
			private ConstructorInfo baseSerializationCtor;
			private bool finished;
d126 1
a126 1
			internal WorkaroundBaseClass(AotTypeWrapper wrapper, TypeBuilder typeBuilder, MethodWrapper[] methods)
a127 1
				this.wrapper = wrapper;
a131 9
			internal ConstructorInfo GetSerializationConstructor()
			{
				if (baseSerializationCtor == null)
				{
					baseSerializationCtor = Serialization.AddAutomagicSerializationToWorkaroundBaseClass(typeBuilder, wrapper.BaseTypeWrapper.GetSerializationConstructor());
				}
				return baseSerializationCtor;
			}

d134 1
a134 1
				if (!finished)
d136 4
a139 9
					finished = true;
					foreach (MethodWrapper mw in methods)
					{
						MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, MethodAttributes.FamORAssem | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.CheckAccessOnOverride, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
						AttributeHelper.HideFromJava(mb);
						CodeEmitter ilgen = CodeEmitter.Create(mb);
						ilgen.EmitThrow("java.lang.AbstractMethodError");
					}
					typeBuilder.CreateType();
d141 1
a1216 29

		internal MethodWrapper ReplaceMethodWrapper(MethodWrapper mw)
		{
			if (replacedMethods != null)
			{
				foreach (MethodWrapper r in replacedMethods)
				{
					if (mw.DeclaringType == r.DeclaringType
						&& mw.Name == r.Name
						&& mw.Signature == r.Signature)
					{
						return r;
					}
				}
			}
			return mw;
		}

		internal override ConstructorInfo GetBaseSerializationConstructor()
		{
			if (workaroundBaseClass != null)
			{
				return workaroundBaseClass.GetSerializationConstructor();
			}
			else
			{
				return base.GetBaseSerializationConstructor();
			}
		}
@


1.44
log
@- Turn pops in map.mxl into lazy pop to annihilate constants.
- Fixed "replace-method-call" to not emit line numbers from map.xml (which don't make sense in the context of another method and disrupt the lazy pop optimizations).
@
text
@d138 1
a138 1
					EmitHelper.Throw(ilgen, "java.lang.AbstractMethodError");
d834 2
a835 2
						EmitHelper.NullCheck(ilgen);
						EmitHelper.Throw(ilgen, "java.lang.IncompatibleClassChangeError", Name);
@


1.43
log
@Moved responsibility for creating java.lang.Class instances for "fast literal" enable types into ClassLiteral<T>, this allows class literals to be really cheap, because non of the underlying reflection is needed, the class will cache the Type and lazily resolve it to its TypeWrapper.
@
text
@d1159 10
d1171 1
a1171 1
				code.Emit(DeclaringType.GetClassLoader(), ilgen);
d1176 1
a1176 1
				code.Emit(DeclaringType.GetClassLoader(), ilgen);
d1181 1
a1181 1
				code.Emit(DeclaringType.GetClassLoader(), ilgen);
@


1.42
log
@Introduced virtual methods should have hidebysig and strict flags.
@
text
@d1201 5
@


1.41
log
@- Changed name of workaround base class to make it easier to spot them.
- Added EditorBrowsable(Never) to prevent the workaround base class from showing up in intellisense.
@
text
@d135 1
a135 1
					MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, MethodAttributes.FamORAssem | MethodAttributes.Virtual, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
@


1.40
log
@Added workaround for .NET C# compiler bug that prevents it from subclassing a Java class that implements a protected abstract method using a public method.
@
text
@d83 1
a83 1
					string name = "__" + Name + "__WorkaroundBaseClass";
d86 1
a86 1
						name += "_";
d90 1
@


1.39
log
@Refactored method call replacement to allow it to be used by others than xml mapping stuff.
@
text
@d50 1
d57 121
@


1.38
log
@Include helpful exception message in ClassCastException generated for ghost array casts.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
d49 1
d1015 63
@


1.37
log
@Integrated IKVM.Reflection.Emit in ikvmc.
@
text
@d866 4
a869 1
					EmitHelper.Throw(ilgen, "java.lang.ClassCastException");
@


1.36
log
@Added check for referencing non-existing constructor in map.xml
@
text
@d28 3
d32 1
@


1.35
log
@Generified all collections.
@
text
@d509 5
@


1.35.2.1
log
@Changed version to 0.38.0.3 and backported these fixes:
- Fixed the stack trace when an unwrapped java.lang.Error (or subclass) escapes from a static initializer.
- It turns out that we really should create an MBeanServer in sun.management.ManagementFactory.createPlatformMBeanServer(), even if we don't populate it with anything useful, applications might still want to register their own MBeans. This fix allows Derby 10.4.2.0 to work.
- Added helpful message to ClassCastException generated for ghost array casts.
- Added check for constructor with missing body in map.xml.
- Removed over eager state checking from java.util.zip.Deflater. Fixes Lucene issue.
- Fixed enclosing method discovery to work for ReflectionOnly assemblies. This allows ikvmstub to work with ikvmc generated assemblies.
- Always emit an explicit method override if we've mangled the name/sig, because we can't predict whether it will be needed or not (without keeping track of the mangling in the base classes) and the cost is minimal since this doesn't happen all that often.
- Miranda method should use mangled name (if the name is mangled).
- Fixed pointer detection to work for types with multiple indirection levels.
- If the last call site of a subroutine wasn't reachable, the return switch would fall through potentially causing the code to be unverifiable.
- The check for unloadable types on the stack indexed the stack in the wrong order.
- Fixed exception wrapping for java.security.AccessController.doPrivileged().
- Fixed tracer to only add a trace listener in executables.
@
text
@a508 5
								if(constructor.body == null)
								{
									Console.Error.WriteLine("Error: Constructor {0}.<init>{1} in xml remap file doesn't have a body.", clazz.Name, constructor.Sig);
									continue;
								}
d857 1
a857 4
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldtoken, typeBuilder);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Call, StaticCompiler.GetType("IKVM.Runtime.GhostTag").GetMethod("ThrowClassCastException", BindingFlags.NonPublic | BindingFlags.Static));
@


1.34
log
@Removed unused per-type class caching.
@
text
@a25 1
using System.Collections;
@


1.33
log
@Eleminated some (CompilerClassLoader) downcasts by making the type of the DynamicTypeWrapper.classLoader field depend on whether we're compiling the runtime or ikvmc.
@
text
@a249 1
			Hashtable classCache = new Hashtable();
d252 2
a253 2
				TypeWrapper typeWrapper = ClassFile.RetTypeWrapperFromSig(GetClassLoader(), classCache, prop.Sig);
				TypeWrapper[] propargs = ClassFile.ArgTypeWrapperListFromSig(GetClassLoader(), classCache, prop.Sig);
d454 2
a455 3
			Hashtable classCache = new Hashtable();
			returnType = ClassFile.RetTypeWrapperFromSig(GetClassLoader(), classCache, sig).TypeAsSignatureType;
			TypeWrapper[] parameterTypeWrappers = ClassFile.ArgTypeWrapperListFromSig(GetClassLoader(), classCache, sig);
@


1.32
log
@Replaced mapxml Hashtable with three statically typed Dictionaries.
@
text
@d56 1
a56 1
				return ((CompilerClassLoader)classLoader).IsGhost(this);
d64 1
a64 1
				return ((CompilerClassLoader)classLoader).IsMapUnsafeException(this);
d78 1
a78 1
			IKVM.Internal.MapXml.Param[] parameters = ((CompilerClassLoader)classLoader).GetXmlMapParameters(Name, methodName, methodSig);
d93 1
a93 1
			IKVM.Internal.MapXml.Param[] parameters = ((CompilerClassLoader)classLoader).GetXmlMapParameters(className, methodName, methodSig);
d137 1
a137 1
			Dictionary<string, IKVM.Internal.MapXml.Class> mapxml = ((CompilerClassLoader)classLoader).GetMapXmlClasses();
d172 1
a172 1
			Dictionary<MethodKey, IKVM.Internal.MapXml.InstructionList> mapxml = ((CompilerClassLoader)classLoader).GetMapXmlMethodBodies();
d370 1
a370 1
			Dictionary<string, IKVM.Internal.MapXml.Class> mapxml = ((CompilerClassLoader)classLoader).GetMapXmlClasses();
d467 1
a467 1
			Dictionary<string, IKVM.Internal.MapXml.Class> mapxml = ((CompilerClassLoader)classLoader).GetMapXmlClasses();
d672 1
a672 1
						TypeWrapper[] implementers = ((CompilerClassLoader)classLoader).GetGhostImplementers(this);
d717 1
a717 1
					TypeWrapper[] implementers = ((CompilerClassLoader)classLoader).GetGhostImplementers(this);
@


1.31
log
@Moved generated exception mapping code from ExceptionHelper to Throwable and made it slightly less hacky.
@
text
@d137 1
a137 1
			Hashtable mapxml = ((CompilerClassLoader)classLoader).GetMapXml();
d140 2
a141 2
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[this.Name];
				if(clazz != null)
d172 1
a172 1
			Hashtable mapxml = ((CompilerClassLoader)classLoader).GetMapXml();
d175 2
a176 2
				object obj = mapxml[f.Name + "." + m.Name + m.Signature];
				if(obj != null)
d178 2
a179 6
					IKVM.Internal.MapXml.InstructionList opcodes = obj as IKVM.Internal.MapXml.InstructionList;
					if(opcodes != null)
					{
						opcodes.Emit(classLoader, ilgen);
						return true;
					}
d370 1
a370 1
			Hashtable mapxml = ((CompilerClassLoader)classLoader).GetMapXml();
d373 2
a374 2
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[Name];
				if(clazz != null && clazz.Methods != null)
d467 1
a467 1
			Hashtable mapxml = ((CompilerClassLoader)classLoader).GetMapXml();
d470 2
a471 2
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[classFile.Name];
				if(clazz != null)
@


1.30
log
@Replaced usage of BootstrapClassLoader with actual class loader in static compiler.
@
text
@a183 7
					// HACK if we're compiling the core class library, it can also be the ExceptionMapEmitter
					CompilerClassLoader.ExceptionMapEmitter eme = obj as CompilerClassLoader.ExceptionMapEmitter;
					if(eme != null)
					{
						eme.Emit(classLoader, ilgen);
						return true;
					}
@


1.29
log
@- Added ghost array tagging to be able to report the instantiated class (instead of object[] which is allocated instead).
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
@
text
@d107 1
a107 1
							AttributeHelper.SetCustomAttribute(pbs[i], attr);
d181 1
a181 1
						opcodes.Emit(ilgen);
d188 1
a188 1
						eme.Emit(ilgen);
d200 1
a200 1
				AttributeHelper.SetCustomAttribute(typeBuilder, attr);
d277 1
a277 1
						AttributeHelper.SetCustomAttribute(propbuilder, attr);
d507 1
a507 1
												AttributeHelper.SetCustomAttribute(fb, attr);
d535 1
a535 1
								constructor.body.Emit(ilgen);
d540 1
a540 1
										AttributeHelper.SetCustomAttribute(cb, attr);
d558 1
a558 1
												AttributeHelper.SetCustomAttribute(mb, attr);
d597 1
a597 1
								method.body.Emit(ilgen);
d602 1
a602 1
										AttributeHelper.SetCustomAttribute(mb, attr);
d620 1
a620 1
												AttributeHelper.SetCustomAttribute(mb, attr);
d649 1
a649 1
									m.Emit(CodeEmitter.Create(mb));
@


1.28
log
@Fix for #2001799.
@
text
@d767 1
d777 2
a782 4
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Ldc_I4_1);
					ilgen.Emit(OpCodes.Sub);
					ilgen.Emit(OpCodes.Starg_S, (byte)1);
d786 7
a796 3
					ilgen.Emit(OpCodes.Ldarg_1);
					skip = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, skip);
d799 1
a799 1
					ilgen.MarkLabel(skip);
d821 4
a824 4
					ilgen.Emit(OpCodes.Ldtoken, typeof(object));
					ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
					ilgen.Emit(OpCodes.Ldloc, localType);
					ilgen.Emit(OpCodes.Ceq);
@


1.27
log
@Fix for #2001802 contributed by Andy Malakov.
@
text
@d574 5
@


1.26
log
@- Renamed CountingILGenerator to CodeEmitter.
- Renamed CountingLabel to CodeEmitterLabel.
@
text
@d83 1
a83 1
					if(parameterNames[i] == null)
@


1.25
log
@Removed CodeEmitter abstract base class.
@
text
@a34 3
using ILGenerator = IKVM.Internal.CountingILGenerator;
using Label = IKVM.Internal.CountingLabel;

d170 1
a170 1
		protected override bool EmitMapXmlMethodBody(CountingILGenerator ilgen, ClassFile f, ClassFile.Method m)
d313 1
a313 1
							ILGenerator ilgen = new CountingILGenerator(mb.GetILGenerator());
d353 1
a353 1
							ILGenerator ilgen = new CountingILGenerator(mb.GetILGenerator());
d534 1
a534 1
								ILGenerator ilgen = cb.GetILGenerator();
d591 1
a591 1
								ILGenerator ilgen = mb.GetILGenerator();
d644 1
a644 1
									m.Emit(mb.GetILGenerator());
d676 2
a677 2
						ILGenerator ilgen = stub.GetILGenerator();
						Label end = ilgen.DefineLabel();
d683 1
a683 1
						Label label = ilgen.DefineLabel();
d720 1
a720 1
					ILGenerator ilgen;
d727 1
a727 1
						ilgen = mb.GetILGenerator();
d739 2
a740 2
					ilgen = mb.GetILGenerator();
					Label end = ilgen.DefineLabel();
d745 1
a745 1
						Label label = ilgen.DefineLabel();
d760 1
a760 1
					ilgen = mb.GetILGenerator();
d763 1
a763 1
					Label skip = ilgen.DefineLabel();
d773 1
a773 1
					Label iter = ilgen.DefineLabel();
d798 1
a798 1
						Label label = ilgen.DefineLabel();
d822 1
a822 1
					ilgen = mb.GetILGenerator();
d844 1
a844 1
					ilgen = mb.GetILGenerator();
d855 1
a855 1
					ilgen = mb.GetILGenerator();
d870 1
a870 1
					ilgen = mb.GetILGenerator();
d880 1
a880 1
					ilgen = mb.GetILGenerator();
d889 1
a889 1
					ilgen = mb.GetILGenerator();
d900 1
a900 1
					ilgen = mb.GetILGenerator();
d952 1
a952 1
		internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
d980 1
a980 1
		internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
@


1.24
log
@Added support for explicitly implementing an interface method with the <override /> element.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
a39 5
	public abstract class CodeEmitter
	{
		internal abstract void Emit(CountingILGenerator ilgen);
	}

d178 2
a179 2
				CodeEmitter opcodes = (CodeEmitter)mapxml[f.Name + "." + m.Name + m.Signature];
				if(opcodes != null)
d181 13
a193 2
					opcodes.Emit(ilgen);
					return true;
@


1.23
log
@Added support for defining non-virtual methods in map.xml.
@
text
@d582 6
@


1.22
log
@Added support for adding constructors in map.xml.
@
text
@d436 2
a437 2
				attribs |= MethodAttributes.Virtual;
				if((modifiers & Modifiers.Final) != 0)
d439 2
a440 1
					attribs |= MethodAttributes.Final;
d442 1
a442 1
				else if((modifiers & Modifiers.Abstract) != 0)
d444 9
a452 1
					attribs |= MethodAttributes.Abstract;
@


1.21
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d406 58
d505 28
d564 4
a567 53
								Modifiers modifiers = (Modifiers)method.Modifiers;
								if((modifiers & Modifiers.Public) != 0)
								{
									attribs |= MethodAttributes.Public;
								}
								else if((modifiers & Modifiers.Protected) != 0)
								{
									attribs |= MethodAttributes.FamORAssem;
								}
								else if((modifiers & Modifiers.Private) != 0)
								{
									attribs |= MethodAttributes.Private;
								}
								else
								{
									attribs |= MethodAttributes.Assembly;
								}
								if((modifiers & Modifiers.Static) != 0)
								{
									attribs |= MethodAttributes.Static;
									if((modifiers & Modifiers.Final) != 0)
									{
										setmodifiers = true;
									}
								}
								else if(method.Name != "<init>")
								{
									attribs |= MethodAttributes.Virtual;
									if((modifiers & Modifiers.Final) != 0)
									{
										attribs |= MethodAttributes.Final;
									}
									else if((modifiers & Modifiers.Abstract) != 0)
									{
										attribs |= MethodAttributes.Abstract;
									}
								}
								if((modifiers & Modifiers.Synchronized) != 0)
								{
									throw new NotImplementedException();
								}
								if(method.Name == "<init>")
								{
									throw new NotImplementedException();
								}
								Hashtable classCache = new Hashtable();
								Type returnType = ClassFile.RetTypeWrapperFromSig(GetClassLoader(), classCache, method.Sig).TypeAsSignatureType;
								TypeWrapper[] parameterTypeWrappers = ClassFile.ArgTypeWrapperListFromSig(GetClassLoader(), classCache, method.Sig);
								Type[] parameterTypes = new Type[parameterTypeWrappers.Length];
								for(int i = 0; i < parameterTypeWrappers.Length; i++)
								{
									parameterTypes[i] = parameterTypeWrappers[i].TypeAsSignatureType;
								}
d571 1
a571 1
									AttributeHelper.SetModifiers(mb, modifiers, false);
@


1.20
log
@- Fixed AotTypeWrapper.EmitCheckCast() for ghost arrays (which apparently isn't used in the current core library).
- Fixed TypeWrapper.EmitCheckCast() for ghost arrays to actually cast to an array type.
@
text
@a26 1
#if WHIDBEY
a27 1
#endif
a32 1
using IKVM.Runtime;
@


1.19
log
@Allow Object[] to be cast/assigned to ghost array. Fix for bug 1757889.
@
text
@d911 8
d920 1
@


1.19.2.1
log
@Backported fixes and changed version to 0.36.0.5
@
text
@a910 8
				TypeWrapper tw = this;
				int rank = 0;
				while(tw.IsArray)
				{
					rank++;
					tw = tw.ElementTypeWrapper;
				}
				ilgen.Emit(OpCodes.Ldc_I4, rank);
a911 1
				ilgen.Emit(OpCodes.Castclass, ArrayTypeWrapper.MakeArrayType(typeof(object), rank));
@


1.19.2.2
log
@Back ported various fixes:
- Changed version to 0.36.0.13.
- Fixed ikvmc not to open the key file for write access.
- Added more efficient float/double to/from int/long bits converters.
- Fixed libikvm-native.so build to include reference to gmodule-2.0 library.
- Fixed ikvmc not to open the key file for write access.
- Fixed Graphics2D.rotate() to convert rotation angle from radians (Java) to degrees (.NET).
- Applied awt patch #1979656 by Daniel Wilson.
- Fixed three String bugs found by OpenJDK string tests.
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
- Removed incorrect DataFormatException thrown in java.util.zip.InflaterHuffmanTree.
- Fixed #2001802 contributed by Andy Malakov.
- Fixed #2001799.
- Fixed #2006953.
- Made finalize() and clone() methods in cli.System.Object and cli.System.Exception final.
@
text
@d94 1
a94 1
					if(parameters[i].Name != null)
a478 5
								if(method.body == null)
								{
									Console.Error.WriteLine("Error: Method {0}.{1}{2} in xml remap file doesn't have a body.", clazz.Name, method.Name, method.Sig);
									continue;
								}
a722 3
					ilgen.Emit(OpCodes.Ldloc, localType);
					ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("GetElementType"));
					ilgen.Emit(OpCodes.Stloc, localType);
d727 3
a729 3
					ilgen.Emit(OpCodes.Ldarg_1);
					Label typecheck = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, typecheck);
d734 3
d739 1
a739 1
					ilgen.MarkLabel(typecheck);
@


1.18
log
@Restructured handling of fields defined in map.xml to enable referencing them from map.xml method  bodies.
@
text
@d756 9
@


1.17
log
@Fixed varargs regression introduced by recent ParameterBuilder handling rewrite.
@
text
@d146 35
a570 39
					if(clazz.Fields != null)
					{
						foreach(IKVM.Internal.MapXml.Field field in clazz.Fields)
						{
							// are we adding a new field?
							if(GetFieldWrapper(field.Name, field.Sig) == null)
							{
								FieldAttributes attribs = 0;
								Modifiers modifiers = (Modifiers)field.Modifiers;
								if((modifiers & Modifiers.Public) != 0)
								{
									attribs |= FieldAttributes.Public;
								}
								else if((modifiers & Modifiers.Protected) != 0)
								{
									attribs |= FieldAttributes.FamORAssem;
								}
								else if((modifiers & Modifiers.Private) != 0)
								{
									attribs |= FieldAttributes.Private;
								}
								else
								{
									attribs |= FieldAttributes.Assembly;
								}
								if((modifiers & Modifiers.Static) != 0)
								{
									attribs |= FieldAttributes.Static;
								}
								if((modifiers & Modifiers.Final) != 0)
								{
									attribs |= FieldAttributes.InitOnly;
								}
								Hashtable classCache = new Hashtable();
								Type fieldType = ClassFile.FieldTypeWrapperFromSig(GetClassLoader(), classCache, field.Sig).TypeAsSignatureType;
								typeBuilder.DefineField(field.Name, fieldType, attribs);
							}
						}
					}
@


1.16
log
@- Added support for applying custom attributes to return values.
- Added support for applying AllowMultiple custom attributes multiple times to the same element.
- Restructured ParameterBuilder handling.
@
text
@d102 1
a102 1
		internal void AddParameterAttributes(ClassFile.Method m, MethodBase method, ref ParameterBuilder[] pbs)
d104 1
a104 1
			IKVM.Internal.MapXml.Param[] parameters = ((CompilerClassLoader)classLoader).GetXmlMapParameters(Name, m.Name, m.Signature);
d112 1
a112 1
				if((m.Modifiers & Modifiers.VarArgs) != 0 && pbs.Length > 0)
d114 1
a114 5
					AttributeHelper.SetParamArrayAttribute(pbs[pbs.Length - 1]);
				}
				if(parameters != null)
				{
					for(int i = 0; i < pbs.Length; i++)
d116 1
a116 1
						if(parameters[i].Attributes != null)
d118 1
a118 4
							foreach(IKVM.Internal.MapXml.Attribute attr in parameters[i].Attributes)
							{
								AttributeHelper.SetCustomAttribute(pbs[i], attr);
							}
d143 1
a143 14
			IKVM.Internal.MapXml.Param[] parameters = ((CompilerClassLoader)classLoader).GetXmlMapParameters(Name, mw.Name, mw.Signature);
			if (parameters != null)
			{
				for(int i = 0; i < pbs.Length; i++)
				{
					if(parameters[i].Attributes != null)
					{
						foreach(IKVM.Internal.MapXml.Attribute attr in parameters[i].Attributes)
						{
							AttributeHelper.SetCustomAttribute(pbs[i], attr);
						}
					}
				}
			}
@


1.15
log
@Implement major chunk of custom attribute as annotations support.
@
text
@d87 1
a87 1
		protected override void AddParameterNames(ClassFile classFile, ClassFile.Method m, MethodBase method)
d89 2
a90 5
			IKVM.Internal.MapXml.Param[] parameters = ((CompilerClassLoader)classLoader).GetXmlMapParameters(classFile.Name, m.Name, m.Signature);
			if((classFile.IsPublic && (m.IsPublic || m.IsProtected))
				|| m.ParameterAnnotations != null
				|| parameters != null
				|| classLoader.EmitDebugInfo)
d92 1
a92 2
				string[] parameterNames = null;
				if(parameters != null)
d94 1
a94 2
					parameterNames = new string[parameters.Length];
					for(int i = 0; i < parameters.Length; i++)
d99 13
a111 1
				ParameterBuilder[] pbs = AddParameterNames(method, m, parameterNames);
a115 14
				if(m.ParameterAnnotations != null)
				{
					for(int i = 0; i < m.ParameterAnnotations.Length; i++)
					{
						foreach(object[] def in m.ParameterAnnotations[i])
						{
							Annotation annotation = Annotation.Load(classLoader, def);
							if(annotation != null)
							{
								annotation.Apply(classLoader, pbs[i], def);
							}
						}
					}
				}
d132 1
a132 1
		private void AddParameterNames(MethodBuilder method, MethodWrapper mw)
d134 16
d151 1
a151 1
			if((mw.DeclaringType.IsPublic && (mw.IsPublic || mw.IsProtected)) || parameters != null || classLoader.EmitDebugInfo)
d153 1
a153 2
				string[] parameterNames = null;
				if(parameters != null)
d155 1
a155 2
					parameterNames = new string[parameters.Length];
					for(int i = 0; i < parameters.Length; i++)
d157 1
a157 13
						parameterNames[i] = parameters[i].Name;
					}
				}
				ParameterBuilder[] pbs = AddParameterNames(method, mw.Signature, parameterNames);
				if((mw.Modifiers & Modifiers.VarArgs) != 0 && pbs.Length > 0)
				{
					AttributeHelper.SetParamArrayAttribute(pbs[pbs.Length - 1]);
				}
				if(parameters != null)
				{
					for(int i = 0; i < pbs.Length; i++)
					{
						if(parameters[i].Attributes != null)
d159 1
a159 4
							foreach(IKVM.Internal.MapXml.Attribute attr in parameters[i].Attributes)
							{
								AttributeHelper.SetCustomAttribute(pbs[i], attr);
							}
d646 1
a646 1
						AddParameterNames(stub, methods[i]);
@


1.14
log
@As pointed out by FxCop: Ghost types should have Equals, GetHashCode, == and != methods.
@
text
@d118 1
a118 1
								annotation.Apply(pbs[i], def);
@


1.14.2.1
log
@back ported the follwing fixes and incremented version to 0.34.0.4:
- magic assembly type for assembly attribute annotations (bug #1721688)
- LocalVariableTable robustness fix (bug #1765952)
- public interfaces extending non-public interfaces
- parameter annotations on redirected contructors
- casting ghost interface arrays (bug #1757889)
- JNI NewObject fix
- make sure all implemented interface methods on .NET types are public (so that ikvmstub generates jars that javac is happy with)
@
text
@a787 9
					skip = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, skip);
					ilgen.Emit(OpCodes.Ldc_I4_1);
					ilgen.Emit(OpCodes.Ret);
					ilgen.MarkLabel(skip);
					ilgen.Emit(OpCodes.Ldtoken, typeof(object));
					ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
					ilgen.Emit(OpCodes.Ldloc, localType);
					ilgen.Emit(OpCodes.Ceq);
@


1.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d837 43
@


1.12
log
@*** empty log message ***
@
text
@d564 39
@


1.11
log
@*** empty log message ***
@
text
@d311 1
a311 1
									ilgen.Emit(OpCodes.Ldarg, i);
d320 1
a320 1
									ilgen.Emit(OpCodes.Ldarg, i + 1);
d351 1
a351 1
									ilgen.Emit(OpCodes.Ldarg, i);
d360 1
a360 1
									ilgen.Emit(OpCodes.Ldarg, i + 1);
@


1.10
log
@*** empty log message ***
@
text
@d564 26
@


1.9
log
@*** empty log message ***
@
text
@d265 1
@


1.8
log
@*** empty log message ***
@
text
@d573 1
a573 4
			else
			{
				return base.DefineGhostMethod(name, attribs, mw);
			}
d783 1
a783 1
		protected override TypeBuilder DefineType(string mangledTypeName, TypeAttributes typeAttribs)
d785 19
a803 26
			if(IsGhost)
			{
				typeAttribs &= ~(TypeAttributes.Interface | TypeAttributes.Abstract);
				typeAttribs |= TypeAttributes.Class | TypeAttributes.Sealed;
				TypeBuilder typeBuilder = classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs, typeof(ValueType));
				AttributeHelper.SetGhostInterface(typeBuilder);
				AttributeHelper.SetModifiers(typeBuilder, Modifiers, IsInternal);
				ghostRefField = typeBuilder.DefineField("__<ref>", typeof(object), FieldAttributes.Public | FieldAttributes.SpecialName);
				typeBuilderGhostInterface = typeBuilder.DefineNestedType("__Interface", TypeAttributes.Interface | TypeAttributes.Abstract | TypeAttributes.NestedPublic);
				AttributeHelper.HideFromJava(typeBuilderGhostInterface);
				ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object) });
				ghostIsInstanceMethod.DefineParameter(1, ParameterAttributes.None, "obj");
				ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object), typeof(int) });
				ghostIsInstanceArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
				ghostIsInstanceArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
				ghostCastMethod = typeBuilder.DefineMethod("Cast", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeBuilder, new Type[] { typeof(object) });
				ghostCastMethod.DefineParameter(1, ParameterAttributes.None, "obj");
				ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(object), typeof(int) });
				ghostCastArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
				ghostCastArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
				return typeBuilder;
			}
			else
			{
				return base.DefineType(mangledTypeName, typeAttribs);
			}
@


1.7
log
@*** empty log message ***
@
text
@a56 4
		private static Hashtable ghosts;
		private static TypeWrapper[] mappedExceptions;
		private static bool[] mappedExceptionsAllSubClasses;
		private static Hashtable mapxml;
a62 39
		internal static void SetupGhosts(IKVM.Internal.MapXml.Root map)
		{
			ghosts = new Hashtable();

			// find the ghost interfaces
			foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
			{
				if(c.Shadows != null && c.Interfaces != null)
				{
					// NOTE we don't support interfaces that inherit from other interfaces
					// (actually, if they are explicitly listed it would probably work)
					TypeWrapper typeWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(c.Name);
					foreach(IKVM.Internal.MapXml.Interface iface in c.Interfaces)
					{
						TypeWrapper ifaceWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(iface.Name);
						if(ifaceWrapper == null || !ifaceWrapper.TypeAsTBD.IsAssignableFrom(typeWrapper.TypeAsTBD))
						{
							AddGhost(iface.Name, typeWrapper);
						}
					}
				}
			}
			// we manually add the array ghost interfaces
			TypeWrapper array = ClassLoaderWrapper.GetWrapperFromType(typeof(Array));
			AddGhost("java.io.Serializable", array);
			AddGhost("java.lang.Cloneable", array);
		}

		private static void AddGhost(string interfaceName, TypeWrapper implementer)
		{
			ArrayList list = (ArrayList)ghosts[interfaceName];
			if(list == null)
			{
				list = new ArrayList();
				ghosts[interfaceName] = list;
			}
			list.Add(implementer);
		}

d67 1
a67 79
				return ghosts != null && IsInterface && ghosts.ContainsKey(Name);
			}
		}

		private class ExceptionMapEmitter : CodeEmitter
		{
			private IKVM.Internal.MapXml.ExceptionMapping[] map;

			internal ExceptionMapEmitter(IKVM.Internal.MapXml.ExceptionMapping[] map)
			{
				this.map = map;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				MethodWrapper mwSuppressFillInStackTrace = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("__<suppressFillInStackTrace>", "()V", false);
				mwSuppressFillInStackTrace.Link();
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Callvirt, typeof(Object).GetMethod("GetType"));
				MethodInfo GetTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle");
				for(int i = 0; i < map.Length; i++)
				{
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Ldtoken, Type.GetType(map[i].src));
					ilgen.Emit(OpCodes.Call, GetTypeFromHandle);
					ilgen.Emit(OpCodes.Ceq);
					Label label = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, label);
					ilgen.Emit(OpCodes.Pop);
					if(map[i].code != null)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						// TODO we should manually walk the instruction list and add a suppressFillInStackTrace call
						// before each newobj that instantiates an exception
						map[i].code.Emit(ilgen);
						ilgen.Emit(OpCodes.Ret);
					}
					else
					{
						TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map[i].dst);
						MethodWrapper mw = tw.GetMethodWrapper("<init>", "()V", false);
						mw.Link();
						mwSuppressFillInStackTrace.EmitCall(ilgen);
						mw.EmitNewobj(ilgen);
						ilgen.Emit(OpCodes.Ret);
					}
					ilgen.MarkLabel(label);
				}
				ilgen.Emit(OpCodes.Pop);
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Ret);
			}
		}

		internal static void LoadMapXml(IKVM.Internal.MapXml.Root map)
		{
			mapxml = new Hashtable();
			// HACK we've got a hardcoded location for the exception mapping method that is generated from the xml mapping
			mapxml["java.lang.ExceptionHelper.MapExceptionImpl(Ljava.lang.Throwable;)Ljava.lang.Throwable;"] = new ExceptionMapEmitter(map.exceptionMappings);
			foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
			{
				// HACK if it is not a remapped type, we assume it is a container for native methods
				if(c.Shadows == null)
				{
					string className = c.Name;
					mapxml.Add(className, c);
					if(c.Methods != null)
					{
						foreach(IKVM.Internal.MapXml.Method method in c.Methods)
						{
							if(method.body != null)
							{
								string methodName = method.Name;
								string methodSig = method.Sig;
								mapxml.Add(className + "." + methodName + methodSig, method.body);
							}
						}
					}
				}
d75 1
a75 40
				if(mappedExceptions != null)
				{
					for(int i = 0; i < mappedExceptions.Length; i++)
					{
						if(mappedExceptions[i].IsSubTypeOf(this) ||
							(mappedExceptionsAllSubClasses[i] && this.IsSubTypeOf(mappedExceptions[i])))
						{
							return true;
						}
					}
				}
				return false;
			}
		}

		internal static void LoadMappedExceptions(IKVM.Internal.MapXml.Root map)
		{
			if(map.exceptionMappings != null)
			{
				mappedExceptionsAllSubClasses = new bool[map.exceptionMappings.Length];
				mappedExceptions = new TypeWrapper[map.exceptionMappings.Length];
				for(int i = 0; i < mappedExceptions.Length; i++)
				{
					string dst = map.exceptionMappings[i].dst;
					if(dst[0] == '*')
					{
						mappedExceptionsAllSubClasses[i] = true;
						dst = dst.Substring(1);
					}
					mappedExceptions[i] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dst);
				}
			}
		}

		private static TypeWrapper[] GetGhostImplementers(TypeWrapper wrapper)
		{
			ArrayList list = (ArrayList)ghosts[wrapper.Name];
			if(list == null)
			{
				return TypeWrapper.EmptyArray;
a76 1
			return (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
a86 32
		private static IKVM.Internal.MapXml.Param[] GetXmlMapParameters(string classname, string method, string sig)
		{
			if(mapxml != null)
			{
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[classname];
				if(clazz != null)
				{
					if(method == "<init>" && clazz.Constructors != null)
					{
						for(int i = 0; i < clazz.Constructors.Length; i++)
						{
							if(clazz.Constructors[i].Sig == sig)
							{
								return clazz.Constructors[i].Params;
							}
						}
					}
					else if(clazz.Methods != null)
					{
						for(int i = 0; i < clazz.Methods.Length; i++)
						{
							if(clazz.Methods[i].Name == method && clazz.Methods[i].Sig == sig)
							{
								return clazz.Methods[i].Params;
							}
						}
					}
				}
			}
			return null;
		}

d89 1
a89 1
			IKVM.Internal.MapXml.Param[] parameters = GetXmlMapParameters(classFile.Name, m.Name, m.Signature);
d141 1
a141 1
			IKVM.Internal.MapXml.Param[] parameters = GetXmlMapParameters(Name, mw.Name, mw.Signature);
d176 1
d373 1
d403 1
d595 1
a595 1
						TypeWrapper[] implementers = GetGhostImplementers(this);
d640 1
a640 1
					TypeWrapper[] implementers = GetGhostImplementers(this);
@


1.6
log
@*** empty log message ***
@
text
@d286 1
a286 1
				|| JVM.Debug)
d335 1
a335 1
			if((mw.DeclaringType.IsPublic && (mw.IsPublic || mw.IsProtected)) || parameters != null || JVM.Debug)
@


1.5
log
@*** empty log message ***
@
text
@d982 1
a982 1
				TypeBuilder typeBuilder = classLoader.ModuleBuilder.DefineType(mangledTypeName, typeAttribs, typeof(ValueType));
@


1.4
log
@*** empty log message ***
@
text
@d976 1
a976 1
		protected override TypeBuilder DefineType(TypeAttributes typeAttribs)
d982 1
a982 1
				TypeBuilder typeBuilder = classLoader.ModuleBuilder.DefineType(classLoader.MangleTypeName(Name), typeAttribs, typeof(ValueType));
d1002 1
a1002 1
				return base.DefineType(typeAttribs);
@


1.3
log
@*** empty log message ***
@
text
@d283 4
a286 1
			if((classFile.IsPublic && (m.IsPublic || m.IsProtected)) || parameters != null || JVM.Debug)
d302 14
@


1.2
log
@*** empty log message ***
@
text
@d283 1
a283 1
			if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || parameters != null || JVM.Debug || DynamicClassLoader.IsSaveDebugImage)
d318 1
a318 1
			if((JVM.IsStaticCompiler && mw.DeclaringType.IsPublic && (mw.IsPublic || mw.IsProtected)) || parameters != null || JVM.Debug || DynamicClassLoader.IsSaveDebugImage)
@


1.1
log
@*** empty log message ***
@
text
@d24 1
a30 1
#if !COMPACT_FRAMEWORK
a31 3
using ILGenerator = IKVM.Internal.CountingILGenerator;
using Label = IKVM.Internal.CountingLabel;
#endif
d38 3
@

