head	1.280;
access;
symbols
	v8_1_5717_0:1.278
	v8_1:1.278.0.2
	v8_0_5449_1:1.270
	v8_0_5449_0:1.270
	v8_0:1.270.0.2
	v7_4_5196_0:1.258
	v7_4:1.258.0.2
	v7_3:1.248.0.2
	v7_2_4630_6:1.202.2.1
	v7_2_4630_5:1.202.2.1
	v7_2_4630_4:1.202.2.1
	v7_2_4630_3:1.202.2.1
	v7_2_4630_2:1.202.2.1
	v0_46_0_4:1.165.2.4
	v7_2_4630_1:1.202.2.1
	v7_2:1.202.0.2
	v7_1_4532_2:1.199
	v7_1_4532_1:1.199
	v7_1_4532_0:1.199
	v7_1:1.199.0.2
	v7_0_4335_3:1.176.2.1
	v7_0_4335_2:1.176.2.1
	v7_0_4335_1:1.176.2.1
	v0_46_0_2:1.165.2.3
	v7_0_4335_0:1.176
	v7_0:1.176.0.2
	v0_40_0_6:1.93.2.1
	v0_40_0_5:1.93.2.1
	v0_46_0_1:1.165
	v0_46_0_0:1.165
	v0_46:1.165.0.2
	v0_36_0_14:1.48.2.6
	v0_44_0_6:1.147.2.3
	v0_44_0_5:1.147.2.1
	v0_44_0_4:1.147
	v0_44_0_3:1.147
	v0_44_0_2:1.147
	v0_42_0_7:1.108.2.3
	v0_44_0_1:1.147
	v0_44_0_0:1.147
	v0_44:1.147.0.2
	v0_42_0_6:1.108.2.3
	v0_42_0_5:1.108.2.3
	v0_42_0_4:1.108.2.3
	v0_42_0_3:1.108.2.2
	v0_42_0_2:1.108.2.1
	v0_42_0_1:1.108
	v0_42_0_0:1.108
	v0_42:1.108.0.2
	v0_40_0_3:1.93.2.1
	v0_40_0_2:1.93
	v0_40_0_1:1.93
	v0_40_0_0:1.93
	v0_40:1.93.0.2
	v0_36_0_13:1.48.2.6
	v0_38_0_1:1.71
	v0_38_0_0:1.71
	v0_38:1.71.0.2
	v0_36_0_9:1.48.2.3
	v0_36_0_7:1.48.2.2
	v0_36_0_5:1.48.2.2
	v0_36_0_4:1.48.2.1
	v0_36_0_3:1.48
	v0_36_0_2:1.48
	v0_36_0_1:1.48
	v0_36_0_0:1.48
	v0_36:1.48.0.2
	v0_34_0_3:1.39.2.1
	v0_34_0_2:1.39
	v0_34_0_1:1.39
	v0_34_0_0:1.39
	v0_34:1.39.0.2
	v0_32:1.32.0.2
	v0_32_0_0:1.32
	v0_30:1.9.0.2
	v0_28_0_0:1.5;
locks; strict;
comment	@ * @;


1.280
date	2017.02.21.16.03.24;	author jfrijters;	state Exp;
branches;
next	1.279;

1.279
date	2016.09.07.07.57.52;	author jfrijters;	state Exp;
branches;
next	1.278;

1.278
date	2015.06.26.11.22.19;	author jfrijters;	state Exp;
branches;
next	1.277;

1.277
date	2015.06.22.13.17.58;	author jfrijters;	state Exp;
branches;
next	1.276;

1.276
date	2015.06.22.10.55.23;	author jfrijters;	state Exp;
branches;
next	1.275;

1.275
date	2015.03.24.09.39.11;	author jfrijters;	state Exp;
branches;
next	1.274;

1.274
date	2015.03.24.09.15.03;	author jfrijters;	state Exp;
branches;
next	1.273;

1.273
date	2015.02.19.07.54.53;	author jfrijters;	state Exp;
branches;
next	1.272;

1.272
date	2015.02.18.14.13.10;	author jfrijters;	state Exp;
branches;
next	1.271;

1.271
date	2015.02.18.13.52.46;	author jfrijters;	state Exp;
branches;
next	1.270;

1.270
date	2014.07.01.15.12.34;	author jfrijters;	state Exp;
branches;
next	1.269;

1.269
date	2014.06.24.09.44.37;	author jfrijters;	state Exp;
branches;
next	1.268;

1.268
date	2014.06.13.06.54.06;	author jfrijters;	state Exp;
branches;
next	1.267;

1.267
date	2014.06.03.12.42.19;	author jfrijters;	state Exp;
branches;
next	1.266;

1.266
date	2014.06.02.13.25.40;	author jfrijters;	state Exp;
branches;
next	1.265;

1.265
date	2014.05.13.14.13.14;	author jfrijters;	state Exp;
branches;
next	1.264;

1.264
date	2014.05.01.11.56.28;	author jfrijters;	state Exp;
branches;
next	1.263;

1.263
date	2014.05.01.08.16.27;	author jfrijters;	state Exp;
branches;
next	1.262;

1.262
date	2014.04.30.09.06.41;	author jfrijters;	state Exp;
branches;
next	1.261;

1.261
date	2014.04.29.07.01.35;	author jfrijters;	state Exp;
branches;
next	1.260;

1.260
date	2014.04.28.13.34.03;	author jfrijters;	state Exp;
branches;
next	1.259;

1.259
date	2014.04.11.13.03.34;	author jfrijters;	state Exp;
branches;
next	1.258;

1.258
date	2014.03.05.11.12.47;	author jfrijters;	state Exp;
branches;
next	1.257;

1.257
date	2014.03.04.07.53.35;	author jfrijters;	state Exp;
branches;
next	1.256;

1.256
date	2014.02.20.16.51.24;	author jfrijters;	state Exp;
branches;
next	1.255;

1.255
date	2014.02.20.16.13.28;	author jfrijters;	state Exp;
branches;
next	1.254;

1.254
date	2014.02.06.11.14.27;	author jfrijters;	state Exp;
branches;
next	1.253;

1.253
date	2014.02.06.08.46.11;	author jfrijters;	state Exp;
branches;
next	1.252;

1.252
date	2013.08.12.07.55.55;	author jfrijters;	state Exp;
branches;
next	1.251;

1.251
date	2013.05.01.12.58.26;	author jfrijters;	state Exp;
branches;
next	1.250;

1.250
date	2013.03.30.06.18.15;	author jfrijters;	state Exp;
branches;
next	1.249;

1.249
date	2013.03.24.12.40.33;	author jfrijters;	state Exp;
branches;
next	1.248;

1.248
date	2013.03.11.12.42.57;	author jfrijters;	state Exp;
branches;
next	1.247;

1.247
date	2013.03.05.13.29.09;	author jfrijters;	state Exp;
branches;
next	1.246;

1.246
date	2013.02.19.19.42.32;	author jfrijters;	state Exp;
branches;
next	1.245;

1.245
date	2013.02.19.16.24.09;	author jfrijters;	state Exp;
branches;
next	1.244;

1.244
date	2013.02.19.07.17.50;	author jfrijters;	state Exp;
branches;
next	1.243;

1.243
date	2013.02.18.09.40.41;	author jfrijters;	state Exp;
branches;
next	1.242;

1.242
date	2013.02.18.09.35.57;	author jfrijters;	state Exp;
branches;
next	1.241;

1.241
date	2013.02.18.08.59.00;	author jfrijters;	state Exp;
branches;
next	1.240;

1.240
date	2013.02.18.08.41.22;	author jfrijters;	state Exp;
branches;
next	1.239;

1.239
date	2013.02.18.08.39.37;	author jfrijters;	state Exp;
branches;
next	1.238;

1.238
date	2013.02.18.08.34.31;	author jfrijters;	state Exp;
branches;
next	1.237;

1.237
date	2013.02.17.12.43.42;	author jfrijters;	state Exp;
branches;
next	1.236;

1.236
date	2013.02.17.10.57.35;	author jfrijters;	state Exp;
branches;
next	1.235;

1.235
date	2013.02.17.10.07.54;	author jfrijters;	state Exp;
branches;
next	1.234;

1.234
date	2013.02.17.09.49.23;	author jfrijters;	state Exp;
branches;
next	1.233;

1.233
date	2013.02.17.09.35.26;	author jfrijters;	state Exp;
branches;
next	1.232;

1.232
date	2013.02.17.08.00.24;	author jfrijters;	state Exp;
branches;
next	1.231;

1.231
date	2013.02.17.06.58.37;	author jfrijters;	state Exp;
branches;
next	1.230;

1.230
date	2013.02.17.06.41.28;	author jfrijters;	state Exp;
branches;
next	1.229;

1.229
date	2013.02.16.08.23.07;	author jfrijters;	state Exp;
branches;
next	1.228;

1.228
date	2013.02.12.17.12.01;	author jfrijters;	state Exp;
branches;
next	1.227;

1.227
date	2013.02.12.14.49.46;	author jfrijters;	state Exp;
branches;
next	1.226;

1.226
date	2013.02.12.13.41.44;	author jfrijters;	state Exp;
branches;
next	1.225;

1.225
date	2013.02.12.12.33.07;	author jfrijters;	state Exp;
branches;
next	1.224;

1.224
date	2013.02.12.12.27.07;	author jfrijters;	state Exp;
branches;
next	1.223;

1.223
date	2013.02.12.11.25.21;	author jfrijters;	state Exp;
branches;
next	1.222;

1.222
date	2013.02.12.07.52.08;	author jfrijters;	state Exp;
branches;
next	1.221;

1.221
date	2013.02.06.19.31.10;	author jfrijters;	state Exp;
branches;
next	1.220;

1.220
date	2013.01.31.15.45.23;	author jfrijters;	state Exp;
branches;
next	1.219;

1.219
date	2013.01.24.13.59.10;	author jfrijters;	state Exp;
branches;
next	1.218;

1.218
date	2013.01.24.13.54.19;	author jfrijters;	state Exp;
branches;
next	1.217;

1.217
date	2013.01.16.09.49.01;	author jfrijters;	state Exp;
branches;
next	1.216;

1.216
date	2013.01.15.15.33.50;	author jfrijters;	state Exp;
branches;
next	1.215;

1.215
date	2013.01.15.15.19.52;	author jfrijters;	state Exp;
branches;
next	1.214;

1.214
date	2013.01.15.15.02.37;	author jfrijters;	state Exp;
branches;
next	1.213;

1.213
date	2013.01.15.14.55.50;	author jfrijters;	state Exp;
branches;
next	1.212;

1.212
date	2013.01.15.14.40.03;	author jfrijters;	state Exp;
branches;
next	1.211;

1.211
date	2013.01.08.14.47.50;	author jfrijters;	state Exp;
branches;
next	1.210;

1.210
date	2013.01.08.07.07.07;	author jfrijters;	state Exp;
branches;
next	1.209;

1.209
date	2013.01.07.12.19.56;	author jfrijters;	state Exp;
branches;
next	1.208;

1.208
date	2013.01.07.10.54.55;	author jfrijters;	state Exp;
branches;
next	1.207;

1.207
date	2012.12.30.11.20.15;	author jfrijters;	state Exp;
branches;
next	1.206;

1.206
date	2012.09.13.15.19.35;	author jfrijters;	state Exp;
branches;
next	1.205;

1.205
date	2012.09.13.13.21.35;	author jfrijters;	state Exp;
branches;
next	1.204;

1.204
date	2012.09.13.11.50.15;	author jfrijters;	state Exp;
branches;
next	1.203;

1.203
date	2012.09.11.12.00.46;	author jfrijters;	state Exp;
branches;
next	1.202;

1.202
date	2012.08.15.08.17.51;	author jfrijters;	state Exp;
branches
	1.202.2.1;
next	1.201;

1.201
date	2012.08.06.12.12.03;	author jfrijters;	state Exp;
branches;
next	1.200;

1.200
date	2012.07.03.14.45.51;	author jfrijters;	state Exp;
branches;
next	1.199;

1.199
date	2012.03.25.09.10.29;	author jfrijters;	state Exp;
branches;
next	1.198;

1.198
date	2012.03.24.10.02.59;	author jfrijters;	state Exp;
branches;
next	1.197;

1.197
date	2012.03.24.08.54.12;	author jfrijters;	state Exp;
branches;
next	1.196;

1.196
date	2012.03.23.16.45.41;	author jfrijters;	state Exp;
branches;
next	1.195;

1.195
date	2012.03.21.12.38.22;	author jfrijters;	state Exp;
branches;
next	1.194;

1.194
date	2012.03.21.11.33.10;	author jfrijters;	state Exp;
branches;
next	1.193;

1.193
date	2012.03.19.12.42.05;	author jfrijters;	state Exp;
branches;
next	1.192;

1.192
date	2012.03.19.09.47.52;	author jfrijters;	state Exp;
branches;
next	1.191;

1.191
date	2012.01.26.06.43.40;	author jfrijters;	state Exp;
branches;
next	1.190;

1.190
date	2012.01.20.16.13.07;	author jfrijters;	state Exp;
branches;
next	1.189;

1.189
date	2012.01.03.14.26.36;	author jfrijters;	state Exp;
branches;
next	1.188;

1.188
date	2011.12.14.12.06.52;	author jfrijters;	state Exp;
branches;
next	1.187;

1.187
date	2011.12.14.09.04.57;	author jfrijters;	state Exp;
branches;
next	1.186;

1.186
date	2011.12.14.07.56.53;	author jfrijters;	state Exp;
branches;
next	1.185;

1.185
date	2011.12.13.07.34.50;	author jfrijters;	state Exp;
branches;
next	1.184;

1.184
date	2011.12.12.13.43.11;	author jfrijters;	state Exp;
branches;
next	1.183;

1.183
date	2011.11.28.13.23.02;	author jfrijters;	state Exp;
branches;
next	1.182;

1.182
date	2011.11.27.11.29.56;	author jfrijters;	state Exp;
branches;
next	1.181;

1.181
date	2011.11.24.12.31.38;	author jfrijters;	state Exp;
branches;
next	1.180;

1.180
date	2011.11.15.05.51.38;	author jfrijters;	state Exp;
branches;
next	1.179;

1.179
date	2011.11.15.05.41.19;	author jfrijters;	state Exp;
branches;
next	1.178;

1.178
date	2011.11.14.06.17.13;	author jfrijters;	state Exp;
branches;
next	1.177;

1.177
date	2011.11.11.15.35.13;	author jfrijters;	state Exp;
branches;
next	1.176;

1.176
date	2011.10.18.10.57.18;	author jfrijters;	state Exp;
branches
	1.176.2.1;
next	1.175;

1.175
date	2011.09.29.13.16.51;	author jfrijters;	state Exp;
branches;
next	1.174;

1.174
date	2011.08.08.11.28.05;	author jfrijters;	state Exp;
branches;
next	1.173;

1.173
date	2011.07.12.07.41.24;	author jfrijters;	state Exp;
branches;
next	1.172;

1.172
date	2011.07.11.07.32.40;	author jfrijters;	state Exp;
branches;
next	1.171;

1.171
date	2011.06.28.06.17.40;	author jfrijters;	state Exp;
branches;
next	1.170;

1.170
date	2011.06.28.06.02.11;	author jfrijters;	state Exp;
branches;
next	1.169;

1.169
date	2011.06.27.13.15.17;	author jfrijters;	state Exp;
branches;
next	1.168;

1.168
date	2011.05.25.09.23.36;	author jfrijters;	state Exp;
branches;
next	1.167;

1.167
date	2011.05.12.10.15.52;	author jfrijters;	state Exp;
branches;
next	1.166;

1.166
date	2011.05.12.08.08.08;	author jfrijters;	state Exp;
branches;
next	1.165;

1.165
date	2011.02.17.12.43.18;	author jfrijters;	state Exp;
branches
	1.165.2.1;
next	1.164;

1.164
date	2010.11.29.08.16.54;	author jfrijters;	state Exp;
branches;
next	1.163;

1.163
date	2010.11.29.07.11.46;	author jfrijters;	state Exp;
branches;
next	1.162;

1.162
date	2010.10.21.10.58.57;	author jfrijters;	state Exp;
branches;
next	1.161;

1.161
date	2010.10.14.15.48.11;	author jfrijters;	state Exp;
branches;
next	1.160;

1.160
date	2010.10.11.12.15.28;	author jfrijters;	state Exp;
branches;
next	1.159;

1.159
date	2010.10.06.04.27.38;	author jfrijters;	state Exp;
branches;
next	1.158;

1.158
date	2010.10.05.04.54.09;	author jfrijters;	state Exp;
branches;
next	1.157;

1.157
date	2010.09.30.04.03.33;	author jfrijters;	state Exp;
branches;
next	1.156;

1.156
date	2010.09.29.07.21.51;	author jfrijters;	state Exp;
branches;
next	1.155;

1.155
date	2010.09.20.15.08.46;	author jfrijters;	state Exp;
branches;
next	1.154;

1.154
date	2010.09.14.12.29.22;	author jfrijters;	state Exp;
branches;
next	1.153;

1.153
date	2010.09.10.08.14.42;	author jfrijters;	state Exp;
branches;
next	1.152;

1.152
date	2010.08.18.07.17.30;	author jfrijters;	state Exp;
branches;
next	1.151;

1.151
date	2010.08.05.13.43.01;	author jfrijters;	state Exp;
branches;
next	1.150;

1.150
date	2010.07.28.12.37.25;	author jfrijters;	state Exp;
branches;
next	1.149;

1.149
date	2010.07.16.08.56.13;	author jfrijters;	state Exp;
branches;
next	1.148;

1.148
date	2010.07.16.08.50.40;	author jfrijters;	state Exp;
branches;
next	1.147;

1.147
date	2010.06.10.08.44.40;	author jfrijters;	state Exp;
branches
	1.147.2.1;
next	1.146;

1.146
date	2010.05.27.08.27.37;	author jfrijters;	state Exp;
branches;
next	1.145;

1.145
date	2010.05.21.06.27.22;	author jfrijters;	state Exp;
branches;
next	1.144;

1.144
date	2010.05.20.06.00.48;	author jfrijters;	state Exp;
branches;
next	1.143;

1.143
date	2010.05.20.04.59.13;	author jfrijters;	state Exp;
branches;
next	1.142;

1.142
date	2010.05.20.04.26.35;	author jfrijters;	state Exp;
branches;
next	1.141;

1.141
date	2010.05.18.06.48.40;	author jfrijters;	state Exp;
branches;
next	1.140;

1.140
date	2010.05.16.07.47.08;	author jfrijters;	state Exp;
branches;
next	1.139;

1.139
date	2010.05.16.06.31.20;	author jfrijters;	state Exp;
branches;
next	1.138;

1.138
date	2010.05.12.15.15.25;	author jfrijters;	state Exp;
branches;
next	1.137;

1.137
date	2010.05.11.09.34.58;	author jfrijters;	state Exp;
branches;
next	1.136;

1.136
date	2010.05.11.06.12.12;	author jfrijters;	state Exp;
branches;
next	1.135;

1.135
date	2010.05.07.12.05.52;	author jfrijters;	state Exp;
branches;
next	1.134;

1.134
date	2010.05.07.05.48.22;	author jfrijters;	state Exp;
branches;
next	1.133;

1.133
date	2010.05.06.06.11.56;	author jfrijters;	state Exp;
branches;
next	1.132;

1.132
date	2010.05.06.06.07.13;	author jfrijters;	state Exp;
branches;
next	1.131;

1.131
date	2010.04.14.14.43.21;	author jfrijters;	state Exp;
branches;
next	1.130;

1.130
date	2010.02.03.15.12.58;	author jfrijters;	state Exp;
branches;
next	1.129;

1.129
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches;
next	1.128;

1.128
date	2010.01.25.07.52.43;	author jfrijters;	state Exp;
branches;
next	1.127;

1.127
date	2009.12.11.13.47.10;	author jfrijters;	state Exp;
branches;
next	1.126;

1.126
date	2009.12.11.08.06.10;	author jfrijters;	state Exp;
branches;
next	1.125;

1.125
date	2009.12.10.09.04.52;	author jfrijters;	state Exp;
branches;
next	1.124;

1.124
date	2009.12.01.07.08.52;	author jfrijters;	state Exp;
branches;
next	1.123;

1.123
date	2009.11.30.09.12.36;	author jfrijters;	state Exp;
branches;
next	1.122;

1.122
date	2009.11.13.15.08.20;	author jfrijters;	state Exp;
branches;
next	1.121;

1.121
date	2009.11.09.07.47.22;	author jfrijters;	state Exp;
branches;
next	1.120;

1.120
date	2009.11.09.06.39.17;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2009.11.09.05.31.48;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2009.11.04.05.18.37;	author jfrijters;	state Exp;
branches;
next	1.117;

1.117
date	2009.11.03.07.15.37;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2009.10.28.11.25.20;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2009.10.23.06.25.09;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2009.10.23.06.06.48;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2009.10.21.04.54.39;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2009.10.21.04.43.27;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2009.10.19.05.39.23;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2009.10.16.07.06.50;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2009.10.14.14.58.41;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2009.09.07.04.46.01;	author jfrijters;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2009.08.31.05.02.35;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2009.08.28.06.20.22;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2009.08.06.06.38.42;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2009.08.06.06.21.37;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2009.08.06.06.18.43;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2009.07.27.16.46.15;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2009.07.14.06.27.41;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.22.06.12.47;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2009.06.18.06.14.55;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2009.06.18.06.13.21;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2009.05.26.05.00.38;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2009.05.25.13.42.15;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2009.05.24.06.54.24;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2009.05.17.06.11.58;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.16.05.28.11;	author jfrijters;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2009.03.13.05.05.26;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.13.04.59.21;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.04.05.47.19;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2009.02.22.08.18.37;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2009.02.19.08.12.05;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2009.02.10.07.27.25;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2009.02.10.07.24.30;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2009.02.05.06.59.11;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2009.02.04.07.24.44;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2009.02.04.07.19.06;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2009.02.04.07.10.59;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2008.12.23.07.11.29;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2008.12.23.06.14.42;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2008.12.23.06.12.05;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2008.12.23.06.07.10;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2008.11.19.05.41.13;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2008.11.18.05.32.15;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.18.05.28.15;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2008.11.14.08.42.07;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.14.08.29.19;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.14.08.24.50;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2008.09.21.09.48.57;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2008.08.15.12.01.12;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2008.08.14.07.42.56;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2008.08.14.06.51.32;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2008.08.14.05.42.43;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2008.08.13.13.04.47;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2008.08.08.06.26.37;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.03.12.10.10;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.03.09.17.31;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2008.05.20.07.19.12;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2008.04.21.04.18.32;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2008.03.14.09.13.59;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2008.03.03.07.05.19;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2008.02.10.09.39.21;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2008.02.10.08.59.36;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2008.02.10.08.55.18;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.03.09.39.12;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.17.10.59.02;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.26.16.00.15;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.26.08.38.38;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.25.12.57.40;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.21.07.15.40;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.10.06.54.20;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.25.16.28.20;	author jfrijters;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2007.06.28.10.32.50;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.14.06.36.35;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.12.11.45.23;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.27.08.13.44;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.24.10.03.44;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.23.12.46.29;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.02.06.04.07;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.23.08.20.15;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.29.09.17.20;	author jfrijters;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2007.03.15.08.04.35;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2007.02.16.07.42.33;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2007.02.01.07.13.02;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.31.11.26.41;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.05.21.22.55;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.04.07.46.40;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.05.07.52.27;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.20.09.33.16;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.16.07.32.44;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.27.16.55.07;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.19.06.12.48;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.12.05.59.24;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.10.16.31.34;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2006.10.09.12.32.33;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.09.08.29.42;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.04.13.54.38;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.02.07.10.54;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.29.05.30.58;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.12.09.57.36;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.01.07.53.36;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.31.09.22.10;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.29.11.56.09;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.26.13.00.50;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.23.06.01.45;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.21.05.15.52;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.17.08.14.47;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.15.08.50.43;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.14.07.57.03;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.26.14.16.52;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.10.09.37.07;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.06.13.53.51;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.05.12.53.26;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.15.09.08.01;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.05.11.21.15;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.12.13.01.14;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.11.14.59.44;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.10.09.18.37;	author jfrijters;	state Exp;
branches;
next	;

1.39.2.1
date	2007.05.30.11.58.26;	author jfrijters;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2007.08.06.08.09.37;	author jfrijters;	state Exp;
branches;
next	;

1.48.2.1
date	2007.10.12.16.18.41;	author jfrijters;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2007.12.04.06.04.31;	author jfrijters;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	2008.02.03.07.58.40;	author jfrijters;	state Exp;
branches;
next	1.48.2.4;

1.48.2.4
date	2008.03.14.06.14.31;	author jfrijters;	state Exp;
branches;
next	1.48.2.5;

1.48.2.5
date	2008.05.04.08.29.01;	author jfrijters;	state Exp;
branches;
next	1.48.2.6;

1.48.2.6
date	2008.11.05.07.52.01;	author jfrijters;	state Exp;
branches;
next	;

1.93.2.1
date	2009.07.31.06.34.55;	author jfrijters;	state Exp;
branches;
next	;

1.108.2.1
date	2009.10.26.04.48.29;	author jfrijters;	state Exp;
branches;
next	1.108.2.2;

1.108.2.2
date	2009.11.30.05.48.11;	author jfrijters;	state Exp;
branches;
next	1.108.2.3;

1.108.2.3
date	2010.01.12.16.57.12;	author jfrijters;	state Exp;
branches;
next	;

1.147.2.1
date	2010.08.23.04.36.33;	author jfrijters;	state Exp;
branches;
next	1.147.2.2;

1.147.2.2
date	2010.10.22.07.07.53;	author jfrijters;	state Exp;
branches;
next	1.147.2.3;

1.147.2.3
date	2010.10.22.07.16.48;	author jfrijters;	state Exp;
branches;
next	;

1.165.2.1
date	2011.12.20.11.01.45;	author jfrijters;	state Exp;
branches;
next	1.165.2.2;

1.165.2.2
date	2011.12.20.12.16.40;	author jfrijters;	state Exp;
branches;
next	1.165.2.3;

1.165.2.3
date	2011.12.20.12.30.25;	author jfrijters;	state Exp;
branches;
next	1.165.2.4;

1.165.2.4
date	2012.10.03.06.18.56;	author jfrijters;	state Exp;
branches;
next	;

1.176.2.1
date	2012.01.03.12.16.37;	author jfrijters;	state Exp;
branches;
next	;

1.202.2.1
date	2012.09.17.11.17.31;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.280
log
@Fix for #320.
When -target:module is used, disable deterministic output.
@
text
@/*
  Copyright (C) 2002-2014 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/

using System;
using System.Resources;
using System.IO;
using System.Collections.Generic;
using System.Xml;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Text;
using System.Threading;
using System.Security.Permissions;
using System.Security;
using System.Runtime.CompilerServices;
using ICSharpCode.SharpZipLib.Zip;
using IKVM.Attributes;
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;

namespace IKVM.Internal
{
	sealed class CompilerClassLoader : ClassLoaderWrapper
	{
		private Dictionary<string, Jar.Item> classes;
		private Dictionary<string, RemapperTypeWrapper> remapped = new Dictionary<string, RemapperTypeWrapper>();
		private string assemblyName;
		private string assemblyFile;
		private string assemblyDir;
		private bool targetIsModule;
		private AssemblyBuilder assemblyBuilder;
		private IKVM.Internal.MapXml.Attribute[] assemblyAttributes;
		private CompilerOptions options;
		private AssemblyClassLoader[] referencedAssemblies;
		private Dictionary<string, string> nameMappings = new Dictionary<string, string>();
		private Packages packages;
		private Dictionary<string, List<TypeWrapper>> ghosts;
		private TypeWrapper[] mappedExceptions;
		private bool[] mappedExceptionsAllSubClasses;
		private Dictionary<string, IKVM.Internal.MapXml.Class> mapxml_Classes;
		private Dictionary<MethodKey, IKVM.Internal.MapXml.InstructionList> mapxml_MethodBodies;
		private Dictionary<MethodKey, IKVM.Internal.MapXml.ReplaceMethodCall[]> mapxml_ReplacedMethods;
		private Dictionary<MethodKey, IKVM.Internal.MapXml.InstructionList> mapxml_MethodPrologues;
		private IKVM.Internal.MapXml.Root map;
		private List<string> classesToCompile;
		private List<CompilerClassLoader> peerReferences = new List<CompilerClassLoader>();
		private Dictionary<string, string> peerLoading = new Dictionary<string, string>();
		private List<ClassLoaderWrapper> internalsVisibleTo = new List<ClassLoaderWrapper>();
		private List<TypeWrapper> dynamicallyImportedTypes = new List<TypeWrapper>();
		private List<string> jarList = new List<string>();
		private List<TypeWrapper> allwrappers;
		private bool compilingCoreAssembly;

		internal CompilerClassLoader(AssemblyClassLoader[] referencedAssemblies, CompilerOptions options, FileInfo assemblyPath, bool targetIsModule, string assemblyName, Dictionary<string, Jar.Item> classes, bool compilingCoreAssembly)
			: base(options.codegenoptions, null)
		{
			this.referencedAssemblies = referencedAssemblies;
			this.options = options;
			this.classes = classes;
			this.assemblyName = assemblyName;
			this.assemblyFile = assemblyPath.Name;
			this.assemblyDir = assemblyPath.DirectoryName;
			this.targetIsModule = targetIsModule;
			this.compilingCoreAssembly = compilingCoreAssembly;
			Tracer.Info(Tracer.Compiler, "Instantiate CompilerClassLoader for {0}", assemblyName);
		}

		internal bool ReserveName(string javaName)
		{
			return !classes.ContainsKey(javaName) && GetTypeWrapperFactory().ReserveName(javaName);
		}

		internal void AddNameMapping(string javaName, string typeName)
		{
			nameMappings.Add(javaName, typeName);
		}

		internal void AddReference(AssemblyClassLoader acl)
		{
			referencedAssemblies = ArrayUtil.Concat(referencedAssemblies, acl);
		}

		internal void AddReference(CompilerClassLoader ccl)
		{
			peerReferences.Add(ccl);
		}

		internal AssemblyName GetAssemblyName()
		{
			return assemblyBuilder.GetName();
		}

		private static PermissionSet Combine(PermissionSet p1, PermissionSet p2)
		{
			if (p1 == null)
			{
				return p2;
			}
			if (p2 == null)
			{
				return p1;
			}
			return p1.Union(p2);
		}

		internal ModuleBuilder CreateModuleBuilder()
		{
			AssemblyName name = new AssemblyName();
			name.Name = assemblyName;
			if (options.keyPair != null)
			{
				name.KeyPair = options.keyPair;
			}
			else if (options.publicKey != null)
			{
				name.SetPublicKey(options.publicKey);
			}
			name.Version = options.version;
			assemblyBuilder = 
				StaticCompiler.Universe
					.DefineDynamicAssembly(name, AssemblyBuilderAccess.ReflectionOnly, assemblyDir);
			ModuleBuilder moduleBuilder;
			moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName, assemblyFile, this.EmitDebugInfo);
			if(this.EmitStackTraceInfo)
			{
				AttributeHelper.SetSourceFile(moduleBuilder, null);
			}
			if(this.EmitDebugInfo || this.EmitStackTraceInfo)
			{
				CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(JVM.Import(typeof(DebuggableAttribute)).GetConstructor(new Type[] { Types.Boolean, Types.Boolean }), new object[] { true, this.EmitDebugInfo });
				assemblyBuilder.SetCustomAttribute(debugAttr);
			}
			AttributeHelper.SetRuntimeCompatibilityAttribute(assemblyBuilder);
			if(options.baseAddress != 0)
			{
				moduleBuilder.__ImageBase = options.baseAddress;
			}
			if(options.fileAlignment != 0)
			{
				moduleBuilder.__FileAlignment = options.fileAlignment;
			}
			if(options.highentropyva)
			{
				moduleBuilder.__DllCharacteristics |= DllCharacteristics.HighEntropyVA;
			}
			// allow the runtime to "inject" dynamic classes into the assembly
			string mainAssemblyName = options.sharedclassloader != null && options.sharedclassloader[0] != this
				? options.sharedclassloader[0].assemblyName
				: assemblyName;
			if(!DisableDynamicBinding)
			{
				AttributeHelper.SetInternalsVisibleToAttribute(assemblyBuilder, mainAssemblyName + DynamicClassLoader.DynamicAssemblySuffixAndPublicKey);
			}
			return moduleBuilder;
		}

		public override string ToString()
		{
			return "CompilerClassLoader:" + options.assembly;
		}

		protected override TypeWrapper LoadClassImpl(string name, LoadMode mode)
		{
			foreach(AssemblyClassLoader acl in referencedAssemblies)
			{
				TypeWrapper tw = acl.DoLoad(name);
				if(tw != null)
				{
					return tw;
				}
			}
			if(!peerLoading.ContainsKey(name))
			{
				peerLoading.Add(name, null);
				try
				{
					foreach(CompilerClassLoader ccl in peerReferences)
					{
						TypeWrapper tw = ccl.PeerLoad(name);
						if(tw != null)
						{
							return tw;
						}
					}
					if(options.sharedclassloader != null && options.sharedclassloader[0] != this)
					{
						TypeWrapper tw = options.sharedclassloader[0].PeerLoad(name);
						if(tw != null)
						{
							return tw;
						}
					}
				}
				finally
				{
					peerLoading.Remove(name);
				}
			}
			TypeWrapper tw1 = GetTypeWrapperCompilerHook(name);
			if(tw1 != null)
			{
				return tw1;
			}
			// HACK the peer loading mess above may have indirectly loaded the classes without returning it,
			// so we try once more here
			tw1 = FindLoadedClass(name);
			if(tw1 != null)
			{
				return tw1;
			}
			return FindOrLoadGenericClass(name, mode);
		}

		private TypeWrapper PeerLoad(string name)
		{
			// To keep the performance acceptable in cases where we're compiling many targets, we first check if the load can
			// possibly succeed on this class loader, otherwise we'll end up doing a lot of futile recursive loading attempts.
			if(classes.ContainsKey(name) || remapped.ContainsKey(name) || FindLoadedClass(name) != null)
			{
				TypeWrapper tw = LoadClassByDottedNameFast(name);
				// HACK we don't want to load classes referenced by peers, hence the "== this" check
				if(tw != null && tw.GetClassLoader() == this)
				{
					return tw;
				}
			}
			if(options.sharedclassloader != null && options.sharedclassloader[0] == this)
			{
				foreach(CompilerClassLoader ccl in options.sharedclassloader)
				{
					if(ccl != this)
					{
						TypeWrapper tw = ccl.PeerLoad(name);
						if(tw != null)
						{
							return tw;
						}
					}
				}
			}
			return null;
		}

		private TypeWrapper GetTypeWrapperCompilerHook(string name)
		{
			RemapperTypeWrapper rtw;
			if(remapped.TryGetValue(name, out rtw))
			{
				return rtw;
			}
			else
			{
				Jar.Item itemRef;
				if(classes.TryGetValue(name, out itemRef))
				{
					classes.Remove(name);
					ClassFile f;
					try
					{
						byte[] buf = itemRef.GetData();
						f = new ClassFile(buf, 0, buf.Length, name, ClassFileParseOptions, null);
					}
					catch(ClassFormatError x)
					{
						StaticCompiler.SuppressWarning(options, Message.ClassNotFound, name);
						StaticCompiler.IssueMessage(options, Message.ClassFormatError, name, x.Message);
						return null;
					}
					if(f.Name != name)
					{
						StaticCompiler.SuppressWarning(options, Message.ClassNotFound, name);
						StaticCompiler.IssueMessage(options, Message.WrongClassName, name, f.Name);
						return null;
					}
					if(f.IsPublic && options.privatePackages != null)
					{
						foreach(string p in options.privatePackages)
						{
							if(f.Name.StartsWith(p))
							{
								f.SetInternal();
								break;
							}
						}
					}
					if(f.IsPublic && options.publicPackages != null)
					{
						bool found = false;
						foreach(string package in options.publicPackages)
						{
							if(f.Name.StartsWith(package))
							{
								found = true;
								break;
							}
						}
						if(!found)
						{
							f.SetInternal();
						}
					}
					if(f.SourceFileAttribute != null)
					{
						FileInfo path = itemRef.Path;
						if(path != null)
						{
							string sourceFile = Path.GetFullPath(Path.Combine(path.DirectoryName, f.SourceFileAttribute));
							if(File.Exists(sourceFile))
							{
								f.SourcePath = sourceFile;
							}
						}
						if(f.SourcePath == null)
						{
							if (options.sourcepath != null)
							{
								string package = f.Name;
								int index = package.LastIndexOf('.');
								package = index == -1 ? "" : package.Substring(0, index).Replace('.', '/');
								f.SourcePath = Path.GetFullPath(Path.Combine(options.sourcepath + "/" + package, f.SourceFileAttribute));
							}
							else
							{
								f.SourcePath = f.SourceFileAttribute;
							}
						}
					}
					try
					{
						TypeWrapper tw = DefineClass(f, null);
						// we successfully created the type, so we don't need to include the class as a resource
						if (options.nojarstubs)
						{
							itemRef.Remove();
						}
						else
						{
							itemRef.MarkAsStub();
						}
						int pos = f.Name.LastIndexOf('.');
						if (pos != -1)
						{
							string manifestJar = options.IsClassesJar(itemRef.Jar) ? null : itemRef.Jar.Name;
							packages.DefinePackage(f.Name.Substring(0, pos), manifestJar);
						}
						return tw;
					}
					catch (ClassFormatError x)
					{
						StaticCompiler.IssueMessage(options, Message.ClassFormatError, name, x.Message);
					}
					catch (IllegalAccessError x)
					{
						StaticCompiler.IssueMessage(options, Message.IllegalAccessError, name, x.Message);
					}
					catch (VerifyError x)
					{
						StaticCompiler.IssueMessage(options, Message.VerificationError, name, x.Message);
					}
					catch (NoClassDefFoundError x)
					{
						if ((options.codegenoptions & CodeGenOptions.DisableDynamicBinding) != 0)
						{
							StaticCompiler.IssueMessage(options, Message.NoClassDefFoundError, name, x.Message);
						}
						StaticCompiler.IssueMessage(options, Message.ClassNotFound, x.Message);
					}
					catch (RetargetableJavaException x)
					{
						StaticCompiler.IssueMessage(options, Message.GenericUnableToCompileError, name, x.GetType().Name, x.Message);
					}
					StaticCompiler.SuppressWarning(options, Message.ClassNotFound, name);
					return null;
				}
				else
				{
					return null;
				}
			}
		}

		// HACK when we're compiling multiple targets with -sharedclassloader, each target will have its own CompilerClassLoader,
		// so we need to consider them equivalent (because they represent the same class loader).
		internal bool IsEquivalentTo(ClassLoaderWrapper other)
		{
			if (this == other)
			{
				return true;
			}
			CompilerClassLoader ccl = other as CompilerClassLoader;
			if (ccl != null && options.sharedclassloader != null && options.sharedclassloader.Contains(ccl))
			{
				if (!internalsVisibleTo.Contains(ccl))
				{
					AddInternalsVisibleToAttribute(ccl);
				}
				return true;
			}
			return false;
		}

		internal override bool InternalsVisibleToImpl(TypeWrapper wrapper, TypeWrapper friend)
		{
			Debug.Assert(wrapper.GetClassLoader() == this);
			ClassLoaderWrapper other = friend.GetClassLoader();
			// TODO ideally we should also respect InternalsVisibleToAttribute.Annotation here
			if (this == other || internalsVisibleTo.Contains(other))
			{
				return true;
			}
			CompilerClassLoader ccl = other as CompilerClassLoader;
			if (ccl != null)
			{
				AddInternalsVisibleToAttribute(ccl);
				return true;
			}
			return false;
		}

		private void AddInternalsVisibleToAttribute(CompilerClassLoader ccl)
		{
			internalsVisibleTo.Add(ccl);
			AssemblyBuilder asm = ccl.assemblyBuilder;
			AssemblyName asmName = asm.GetName();
			string name = asmName.Name;
			byte[] pubkey = asmName.GetPublicKey();
			if (pubkey == null && asmName.KeyPair != null)
			{
				pubkey = asmName.KeyPair.PublicKey;
			}
			if (pubkey != null && pubkey.Length != 0)
			{
				StringBuilder sb = new StringBuilder(name);
				sb.Append(", PublicKey=");
				foreach (byte b in pubkey)
				{
					sb.AppendFormat("{0:X2}", b);
				}
				name = sb.ToString();
			}
			AttributeHelper.SetInternalsVisibleToAttribute(this.assemblyBuilder, name);
		}

		internal void SetMain(MethodInfo m, PEFileKinds target, Dictionary<string, string> props, bool noglobbing, Type apartmentAttributeType)
		{
			MethodBuilder mainStub = this.GetTypeWrapperFactory().ModuleBuilder.DefineGlobalMethod("main", MethodAttributes.Public | MethodAttributes.Static, Types.Int32, new Type[] { Types.String.MakeArrayType() });
			if(apartmentAttributeType != null)
			{
				mainStub.SetCustomAttribute(new CustomAttributeBuilder(apartmentAttributeType.GetConstructor(Type.EmptyTypes), new object[0]));
			}
			CodeEmitter ilgen = CodeEmitter.Create(mainStub);
			CodeEmitterLocal rc = ilgen.DeclareLocal(Types.Int32);
			TypeWrapper startupType = LoadClassByDottedName("ikvm.runtime.Startup");
			if(props.Count > 0)
			{
				ilgen.Emit(OpCodes.Newobj, JVM.Import(typeof(System.Collections.Generic.Dictionary<string, string>)).GetConstructor(Type.EmptyTypes));
				foreach(KeyValuePair<string, string> kv in props)
				{
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Ldstr, kv.Key);
					ilgen.Emit(OpCodes.Ldstr, kv.Value);
					if(kv.Value.IndexOf('%') < kv.Value.LastIndexOf('%'))
					{
						ilgen.Emit(OpCodes.Call, JVM.Import(typeof(Environment)).GetMethod("ExpandEnvironmentVariables", new Type[] { Types.String }));
					}
					ilgen.Emit(OpCodes.Callvirt, JVM.Import(typeof(System.Collections.Generic.Dictionary<string, string>)).GetMethod("Add"));
				}
				startupType.GetMethodWrapper("setProperties", "(Lcli.System.Collections.IDictionary;)V", false).EmitCall(ilgen);
			}
			ilgen.BeginExceptionBlock();
			startupType.GetMethodWrapper("enterMainThread", "()V", false).EmitCall(ilgen);
			ilgen.Emit(OpCodes.Ldarg_0);
			if (!noglobbing)
			{
				ilgen.Emit(OpCodes.Ldc_I4_0);
				startupType.GetMethodWrapper("glob", "([Ljava.lang.String;I)[Ljava.lang.String;", false).EmitCall(ilgen);
			}
			ilgen.Emit(OpCodes.Call, m);
			CodeEmitterLabel label = ilgen.DefineLabel();
			ilgen.EmitLeave(label);
			ilgen.BeginCatchBlock(Types.Exception);
			LoadClassByDottedName("ikvm.runtime.Util").GetMethodWrapper("mapException", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false).EmitCall(ilgen);
			CodeEmitterLocal exceptionLocal = ilgen.DeclareLocal(Types.Exception);
			ilgen.Emit(OpCodes.Stloc, exceptionLocal);
			TypeWrapper threadTypeWrapper = ClassLoaderWrapper.LoadClassCritical("java.lang.Thread");
			CodeEmitterLocal threadLocal = ilgen.DeclareLocal(threadTypeWrapper.TypeAsLocalOrStackType);
			threadTypeWrapper.GetMethodWrapper("currentThread", "()Ljava.lang.Thread;", false).EmitCall(ilgen);
			ilgen.Emit(OpCodes.Stloc, threadLocal);
			ilgen.Emit(OpCodes.Ldloc, threadLocal);
			threadTypeWrapper.GetMethodWrapper("getThreadGroup", "()Ljava.lang.ThreadGroup;", false).EmitCallvirt(ilgen);
			ilgen.Emit(OpCodes.Ldloc, threadLocal);
			ilgen.Emit(OpCodes.Ldloc, exceptionLocal);
			ClassLoaderWrapper.LoadClassCritical("java.lang.ThreadGroup").GetMethodWrapper("uncaughtException", "(Ljava.lang.Thread;Ljava.lang.Throwable;)V", false).EmitCallvirt(ilgen);
			ilgen.Emit(OpCodes.Ldc_I4_1);
			ilgen.Emit(OpCodes.Stloc, rc);
			ilgen.EmitLeave(label);
			ilgen.BeginFinallyBlock();
			startupType.GetMethodWrapper("exitMainThread", "()V", false).EmitCall(ilgen);
			ilgen.Emit(OpCodes.Endfinally);
			ilgen.EndExceptionBlock();
			ilgen.MarkLabel(label);
			ilgen.Emit(OpCodes.Ldloc, rc);
			ilgen.Emit(OpCodes.Ret);
			ilgen.DoEmit();
			assemblyBuilder.SetEntryPoint(mainStub, target);
		}

		private void PrepareSave()
		{
			((DynamicClassLoader)this.GetTypeWrapperFactory()).FinishAll();
		}

		private void Save()
		{
			ModuleBuilder mb = GetTypeWrapperFactory().ModuleBuilder;
			if(targetIsModule)
			{
				// HACK force all referenced assemblies to end up as references in the assembly
				// (even if they are otherwise unused), to make sure that the assembly class loader
				// delegates to them at runtime.
				// NOTE now we only do this for modules, when we're an assembly we store the exported
				// assemblies in the ikvm.exports resource.
				for(int i = 0;i < referencedAssemblies.Length; i++)
				{
					Type[] types = referencedAssemblies[i].MainAssembly.GetExportedTypes();
					if(types.Length > 0)
					{
						mb.GetTypeToken(types[0]);
					}
				}
			}
			mb.CreateGlobalFunctions();

			AddJavaModuleAttribute(mb);

			// add a package list and export map
			if(options.sharedclassloader == null || options.sharedclassloader[0] == this)
			{
				ConstructorInfo packageListAttributeCtor = JVM.LoadType(typeof(PackageListAttribute)).GetConstructor(new Type[] { Types.String, Types.String.MakeArrayType() });
				foreach(object[] args in packages.ToArray())
				{
					args[1] = UnicodeUtil.EscapeInvalidSurrogates((string[])args[1]);
					mb.SetCustomAttribute(new CustomAttributeBuilder(packageListAttributeCtor, args));
				}
				// We can't add the resource when we're a module, because a multi-module assembly has a single resource namespace
				// and since you cannot combine -target:module with -sharedclassloader we don't need an export map
				// (the wildcard exports have already been added above, by making sure that we statically reference the assemblies).
				if(!targetIsModule)
				{
					WriteExportMap();
				}
			}

			if(targetIsModule)
			{
				Tracer.Info(Tracer.Compiler, "CompilerClassLoader saving {0} in {1}", assemblyFile, assemblyDir);
				try
				{
					GetTypeWrapperFactory().ModuleBuilder.__Save(options.pekind, options.imageFileMachine);
				}
				catch(IOException x)
				{
					throw new FatalCompilerErrorException(Message.ErrorWritingFile, GetTypeWrapperFactory().ModuleBuilder.FullyQualifiedName, x.Message);
				}
				catch(UnauthorizedAccessException x)
				{
					throw new FatalCompilerErrorException(Message.ErrorWritingFile, GetTypeWrapperFactory().ModuleBuilder.FullyQualifiedName, x.Message);
				}
			}
			else
			{
				Tracer.Info(Tracer.Compiler, "CompilerClassLoader saving {0} in {1}", assemblyFile, assemblyDir);
				try
				{
					assemblyBuilder.Save(assemblyFile, options.pekind, options.imageFileMachine);
				}
				catch(IOException x)
				{
					throw new FatalCompilerErrorException(Message.ErrorWritingFile, Path.Combine(assemblyDir, assemblyFile), x.Message);
				}
				catch(UnauthorizedAccessException x)
				{
					throw new FatalCompilerErrorException(Message.ErrorWritingFile, Path.Combine(assemblyDir, assemblyFile), x.Message);
				}
			}
		}

		private void AddJavaModuleAttribute(ModuleBuilder mb)
		{
			Type typeofJavaModuleAttribute = JVM.LoadType(typeof(JavaModuleAttribute));
			PropertyInfo[] propInfos = new PropertyInfo[] {
				typeofJavaModuleAttribute.GetProperty("Jars")
			};
			object[] propValues = new object[] {
				jarList.ToArray()
			};
			if (nameMappings.Count > 0)
			{
				string[] list = new string[nameMappings.Count * 2];
				int i = 0;
				foreach (KeyValuePair<string, string> kv in nameMappings)
				{
					list[i++] = kv.Key;
					list[i++] = kv.Value;
				}
				list = UnicodeUtil.EscapeInvalidSurrogates(list);
				CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofJavaModuleAttribute.GetConstructor(new Type[] { JVM.Import(typeof(string[])) }), new object[] { list }, propInfos, propValues);
				mb.SetCustomAttribute(cab);
			}
			else
			{
				CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofJavaModuleAttribute.GetConstructor(Type.EmptyTypes), new object[0], propInfos, propValues);
				mb.SetCustomAttribute(cab);
			}
		}

		private static void AddExportMapEntry(Dictionary<string, List<string>> map, CompilerClassLoader ccl, string name)
		{
			string assemblyName = ccl.assemblyBuilder.FullName;
			List<string> list;
			if (!map.TryGetValue(assemblyName, out list))
			{
				list = new List<string>();
				map.Add(assemblyName, list);
			}
			if (list != null) // if list is null, we already have a wildcard export for this assembly
			{
				list.Add(name);
			}
		}

		private void AddWildcardExports(Dictionary<string, List<string>> exportedNamesPerAssembly)
		{
			foreach (AssemblyClassLoader acl in referencedAssemblies)
			{
				exportedNamesPerAssembly[acl.MainAssembly.FullName] = null;
			}
		}

		private void WriteExportMap()
		{
			Dictionary<string, List<string>> exportedNamesPerAssembly = new Dictionary<string, List<string>>();
			AddWildcardExports(exportedNamesPerAssembly);
			foreach (TypeWrapper tw in dynamicallyImportedTypes)
			{
				AddExportMapEntry(exportedNamesPerAssembly, (CompilerClassLoader)tw.GetClassLoader(), tw.Name);
			}
			if (options.sharedclassloader == null)
			{
				foreach (CompilerClassLoader ccl in peerReferences)
				{
					exportedNamesPerAssembly[ccl.assemblyBuilder.FullName] = null;
				}
			}
			else
			{
				foreach (CompilerClassLoader ccl in options.sharedclassloader)
				{
					if (ccl != this)
					{
						ccl.AddWildcardExports(exportedNamesPerAssembly);
						foreach (Jar jar in ccl.options.jars)
						{
							foreach (Jar.Item item in jar)
							{
								if (!item.IsStub)
								{
									AddExportMapEntry(exportedNamesPerAssembly, ccl, item.Name);
								}
							}
						}
						if (ccl.options.externalResources != null)
						{
							foreach (string name in ccl.options.externalResources.Keys)
							{
								AddExportMapEntry(exportedNamesPerAssembly, ccl, name);
							}
						}
					}
				}
			}
			MemoryStream ms = new MemoryStream();
			BinaryWriter bw = new BinaryWriter(ms);
			bw.Write(exportedNamesPerAssembly.Count);
			foreach (KeyValuePair<string, List<string>> kv in exportedNamesPerAssembly)
			{
				bw.Write(kv.Key);
				if (kv.Value == null)
				{
					// wildcard export
					bw.Write(0);
				}
				else
				{
					Debug.Assert(kv.Value.Count != 0);
					bw.Write(kv.Value.Count);
					foreach (string name in kv.Value)
					{
						bw.Write(JVM.PersistableHash(name));
					}
				}
			}
			ms.Position = 0;
			this.GetTypeWrapperFactory().ModuleBuilder.DefineManifestResource("ikvm.exports", ms, ResourceAttributes.Public);
		}

		private void WriteResources()
		{
			Tracer.Info(Tracer.Compiler, "CompilerClassLoader adding resources...");

			// BUG we need to call GetTypeWrapperFactory() to make sure that the assemblyBuilder is created (when building an empty target)
			ModuleBuilder moduleBuilder = this.GetTypeWrapperFactory().ModuleBuilder;

			for (int i = 0; i < options.jars.Count; i++)
			{
				bool hasEntries = false;
				MemoryStream mem = new MemoryStream();
				using (ZipOutputStream zip = new ZipOutputStream(mem))
				{
					if (!string.IsNullOrEmpty(options.jars[i].Comment))
					{
						zip.SetComment(options.jars[i].Comment);
					}
					zip.SetLevel(9);
					List<string> stubs = new List<string>();
					foreach (Jar.Item item in options.jars[i])
					{
						if (item.IsStub)
						{
							// we don't want stub class pseudo resources for classes loaded from the file system
							if (i != options.classesJar)
							{
								stubs.Add(item.Name);
							}
							continue;
						}
						ZipEntry zipEntry = item.ZipEntry;
						if (options.compressedResources || zipEntry.CompressionMethod != CompressionMethod.Stored)
						{
							zipEntry.CompressionMethod = CompressionMethod.Deflated;
						}
						zip.PutNextEntry(zipEntry);
						byte[] data = item.GetData();
						zip.Write(data, 0, data.Length);
						zip.CloseEntry();
						hasEntries = true;
					}
					if (stubs.Count != 0)
					{
						// generate the --ikvm-classes-- file in the jar
						ZipEntry zipEntry = new ZipEntry(JVM.JarClassList);
						zipEntry.CompressionMethod = CompressionMethod.Deflated;
						zip.PutNextEntry(zipEntry);
						BinaryWriter bw = new BinaryWriter(zip);
						bw.Write(stubs.Count);
						foreach (string classFile in stubs)
						{
							bw.Write(classFile);
						}
						bw.Flush();
						zip.CloseEntry();
						hasEntries = true;
					}
				}
				// don't include empty classes.jar
				if (i != options.classesJar || hasEntries)
				{
					mem = new MemoryStream(mem.ToArray());
					string name = options.jars[i].Name;
					if (options.targetIsModule)
					{
						name = Path.GetFileNameWithoutExtension(name) + "-" + moduleBuilder.ModuleVersionId.ToString("N") + Path.GetExtension(name);
					}
					jarList.Add(name);
					moduleBuilder.DefineManifestResource(name, mem, ResourceAttributes.Public);
				}
			}
		}

		private static MethodAttributes MapMethodAccessModifiers(IKVM.Internal.MapXml.MapModifiers mod)
		{
			const IKVM.Internal.MapXml.MapModifiers access = IKVM.Internal.MapXml.MapModifiers.Public | IKVM.Internal.MapXml.MapModifiers.Protected | IKVM.Internal.MapXml.MapModifiers.Private;
			switch(mod & access)
			{
				case IKVM.Internal.MapXml.MapModifiers.Public:
					return MethodAttributes.Public;
				case IKVM.Internal.MapXml.MapModifiers.Protected:
					return MethodAttributes.FamORAssem;
				case IKVM.Internal.MapXml.MapModifiers.Private:
					return MethodAttributes.Private;
				default:
					return MethodAttributes.Assembly;
			}
		}

		private static FieldAttributes MapFieldAccessModifiers(IKVM.Internal.MapXml.MapModifiers mod)
		{
			const IKVM.Internal.MapXml.MapModifiers access = IKVM.Internal.MapXml.MapModifiers.Public | IKVM.Internal.MapXml.MapModifiers.Protected | IKVM.Internal.MapXml.MapModifiers.Private;
			switch(mod & access)
			{
				case IKVM.Internal.MapXml.MapModifiers.Public:
					return FieldAttributes.Public;
				case IKVM.Internal.MapXml.MapModifiers.Protected:
					return FieldAttributes.FamORAssem;
				case IKVM.Internal.MapXml.MapModifiers.Private:
					return FieldAttributes.Private;
				default:
					return FieldAttributes.Assembly;
			}
		}

		private sealed class RemapperTypeWrapper : TypeWrapper
		{
			private CompilerClassLoader classLoader;
			private TypeBuilder typeBuilder;
			private TypeBuilder helperTypeBuilder;
			private Type shadowType;
			private IKVM.Internal.MapXml.Class classDef;
			private TypeWrapper baseTypeWrapper;
			private TypeWrapper[] interfaceWrappers;

			internal override ClassLoaderWrapper GetClassLoader()
			{
				return classLoader;
			}

			internal override bool IsRemapped
			{
				get
				{
					return true;
				}
			}

			private static TypeWrapper GetBaseWrapper(IKVM.Internal.MapXml.Class c)
			{
				if((c.Modifiers & IKVM.Internal.MapXml.MapModifiers.Interface) != 0)
				{
					return null;
				}
				if(c.Name == "java.lang.Object")
				{
					return null;
				}
				return CoreClasses.java.lang.Object.Wrapper;
			}

			internal RemapperTypeWrapper(CompilerClassLoader classLoader, IKVM.Internal.MapXml.Class c, IKVM.Internal.MapXml.Root map)
				: base(TypeFlags.None, (Modifiers)c.Modifiers, c.Name)
			{
				this.classLoader = classLoader;
				this.baseTypeWrapper = GetBaseWrapper(c);
				classDef = c;
				bool baseIsSealed = false;
				shadowType = StaticCompiler.Universe.GetType(c.Shadows, true);
				classLoader.SetRemappedType(shadowType, this);
				Type baseType = shadowType;
				Type baseInterface = null;
				if(baseType.IsInterface)
				{
					baseInterface = baseType;
				}
				TypeAttributes attrs = TypeAttributes.Public;
				if((c.Modifiers & IKVM.Internal.MapXml.MapModifiers.Interface) == 0)
				{
					attrs |= TypeAttributes.Class;
					if(baseType.IsSealed)
					{
						baseIsSealed = true;
						attrs |= TypeAttributes.Abstract | TypeAttributes.Sealed;
					}
				}
				else
				{
					attrs |= TypeAttributes.Interface | TypeAttributes.Abstract;
					baseType = null;
				}
				if((c.Modifiers & IKVM.Internal.MapXml.MapModifiers.Abstract) != 0)
				{
					attrs |= TypeAttributes.Abstract;
				}
				string name = c.Name.Replace('/', '.');
				typeBuilder = classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(name, attrs, baseIsSealed ? Types.Object : baseType);
				if(c.Attributes != null)
				{
					foreach(IKVM.Internal.MapXml.Attribute custattr in c.Attributes)
					{
						AttributeHelper.SetCustomAttribute(classLoader, typeBuilder, custattr);
					}
				}
				if(baseInterface != null)
				{
					typeBuilder.AddInterfaceImplementation(baseInterface);
				}
				if(classLoader.EmitStackTraceInfo)
				{
					AttributeHelper.SetSourceFile(typeBuilder, classLoader.options.remapfile.Name);
				}

				if(baseIsSealed)
				{
					AttributeHelper.SetModifiers(typeBuilder, (Modifiers)c.Modifiers, false);
				}

				if(c.scope == IKVM.Internal.MapXml.Scope.Public)
				{
					// FXBUG we would like to emit an attribute with a Type argument here, but that doesn't work because
					// of a bug in SetCustomAttribute that causes type arguments to be serialized incorrectly (if the type
					// is in the same assembly). Normally we use AttributeHelper.FreezeDry to get around this, but that doesn't
					// work in this case (no attribute is emitted at all). So we work around by emitting a string instead
					AttributeHelper.SetRemappedClass(classLoader.assemblyBuilder, name, shadowType);
						
					AttributeHelper.SetRemappedType(typeBuilder, shadowType);
				}

				List<MethodWrapper> methods = new List<MethodWrapper>();

				if(c.Constructors != null)
				{
					foreach(IKVM.Internal.MapXml.Constructor m in c.Constructors)
					{
						methods.Add(new RemappedConstructorWrapper(this, m));
					}
				}

				if(c.Methods != null)
				{
					foreach(IKVM.Internal.MapXml.Method m in c.Methods)
					{
						methods.Add(new RemappedMethodWrapper(this, m, map, false));
					}
				}
				// add methods from our super classes (e.g. Throwable should have Object's methods)
				if(!this.IsFinal && !this.IsInterface && this.BaseTypeWrapper != null)
				{
					foreach(MethodWrapper mw in BaseTypeWrapper.GetMethods())
					{
						RemappedMethodWrapper rmw = mw as RemappedMethodWrapper;
						if(rmw != null && (rmw.IsPublic || rmw.IsProtected))
						{
							if(!FindMethod(methods, rmw.Name, rmw.Signature))
							{
								methods.Add(new RemappedMethodWrapper(this, rmw.XmlMethod, map, true));
							}
						}
					}
				}

				SetMethods(methods.ToArray());
			}

			internal sealed override TypeWrapper BaseTypeWrapper
			{
				get { return baseTypeWrapper; }
			}

			internal void LoadInterfaces(IKVM.Internal.MapXml.Class c)
			{
				if (c.Interfaces != null)
				{
					interfaceWrappers = new TypeWrapper[c.Interfaces.Length];
					for (int i = 0; i < c.Interfaces.Length; i++)
					{
						TypeWrapper iface = classLoader.LoadClassByDottedName(c.Interfaces[i].Name);
						interfaceWrappers[i] = iface;
						foreach (MethodWrapper mw in iface.GetMethods())
						{
							// make sure default interface methods are implemented (they currently have to be explicitly implemented in map.xml)
							if (mw.IsVirtual && !mw.IsAbstract)
							{
								if (GetMethodWrapper(mw.Name, mw.Signature, true) == null)
								{
									StaticCompiler.IssueMessage(Message.RemappedTypeMissingDefaultInterfaceMethod, Name, iface.Name + "." + mw.Name + mw.Signature);
								}
							}
						}
					}
				}
				else
				{
					interfaceWrappers = TypeWrapper.EmptyArray;
				}
			}

			private static bool FindMethod(List<MethodWrapper> methods, string name, string sig)
			{
				foreach(MethodWrapper mw in methods)
				{
					if(mw.Name == name && mw.Signature == sig)
					{
						return true;
					}
				}
				return false;
			}

			abstract class RemappedMethodBaseWrapper : MethodWrapper
			{
				internal RemappedMethodBaseWrapper(RemapperTypeWrapper typeWrapper, string name, string sig, Modifiers modifiers)
					: base(typeWrapper, name, sig, null, null, null, modifiers, MemberFlags.None)
				{
				}

				internal abstract MethodBase DoLink();

				internal abstract void Finish();
			}

			sealed class RemappedConstructorWrapper : RemappedMethodBaseWrapper
			{
				private IKVM.Internal.MapXml.Constructor m;
				private MethodBuilder mbHelper;

				internal RemappedConstructorWrapper(RemapperTypeWrapper typeWrapper, IKVM.Internal.MapXml.Constructor m)
					: base(typeWrapper, "<init>", m.Sig, (Modifiers)m.Modifiers)
				{
					this.m = m;
				}

				internal override void EmitCall(CodeEmitter ilgen)
				{
					ilgen.Emit(OpCodes.Call, GetMethod());
				}

				internal override void EmitNewobj(CodeEmitter ilgen)
				{
					if(mbHelper != null)
					{
						ilgen.Emit(OpCodes.Call, mbHelper);
					}
					else
					{
						ilgen.Emit(OpCodes.Newobj, GetMethod());
					}
				}

				internal override MethodBase DoLink()
				{
					MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers);
					RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)DeclaringType;
					Type[] paramTypes = typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig);

					MethodBuilder cbCore = null;

					if(typeWrapper.shadowType.IsSealed)
					{
						mbHelper = typeWrapper.typeBuilder.DefineMethod("newhelper", attr | MethodAttributes.Static, CallingConventions.Standard, typeWrapper.shadowType, paramTypes);
						if(m.Attributes != null)
						{
							foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
							{
								AttributeHelper.SetCustomAttribute(DeclaringType.GetClassLoader(), mbHelper, custattr);
							}
						}
						SetParameters(DeclaringType.GetClassLoader(), mbHelper, m.Params);
						AttributeHelper.SetModifiers(mbHelper, (Modifiers)m.Modifiers, false);
						AttributeHelper.SetNameSig(mbHelper, "<init>", m.Sig);
						AddDeclaredExceptions(mbHelper, m.throws);
					}
					else
					{
						cbCore = ReflectUtil.DefineConstructor(typeWrapper.typeBuilder, attr, paramTypes);
						if(m.Attributes != null)
						{
							foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
							{
								AttributeHelper.SetCustomAttribute(DeclaringType.GetClassLoader(), cbCore, custattr);
							}
						}
						SetParameters(DeclaringType.GetClassLoader(), cbCore, m.Params);
						AddDeclaredExceptions(cbCore, m.throws);
					}
					return cbCore;
				}
				
				internal override void Finish()
				{
					// TODO we should insert method tracing (if enabled)

					Type[] paramTypes = this.GetParametersForDefineMethod();

					MethodBuilder cbCore = GetMethod() as MethodBuilder;

					if(cbCore != null)
					{
						CodeEmitter ilgen = CodeEmitter.Create(cbCore);
						// TODO we need to support ghost (and other funky?) parameter types
						if(m.body != null)
						{
							// TODO do we need return type conversion here?
							m.body.Emit(DeclaringType.GetClassLoader(), ilgen);
						}
						else
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							for(int i = 0; i < paramTypes.Length; i++)
							{
								ilgen.EmitLdarg(i + 1);
							}
							if(m.redirect != null)
							{
								throw new NotImplementedException();
							}
							else
							{
								ConstructorInfo baseCon = DeclaringType.TypeAsTBD.GetConstructor(paramTypes);
								if(baseCon == null)
								{
									// TODO better error handling
									throw new InvalidOperationException("base class constructor not found: " + DeclaringType.Name + ".<init>" + m.Sig);
								}
								ilgen.Emit(OpCodes.Call, baseCon);
							}
							ilgen.Emit(OpCodes.Ret);
						}
						ilgen.DoEmit();
						if(this.DeclaringType.GetClassLoader().EmitStackTraceInfo)
						{
							ilgen.EmitLineNumberTable(cbCore);
						}
					}

					if(mbHelper != null)
					{
						CodeEmitter ilgen = CodeEmitter.Create(mbHelper);
						if(m.redirect != null)
						{
							m.redirect.Emit(DeclaringType.GetClassLoader(), ilgen);
						}
						else if(m.alternateBody != null)
						{
							m.alternateBody.Emit(DeclaringType.GetClassLoader(), ilgen);
						}
						else if(m.body != null)
						{
							// <body> doesn't make sense for helper constructors (which are actually factory methods)
							throw new InvalidOperationException();
						}
						else
						{
							ConstructorInfo baseCon = DeclaringType.TypeAsTBD.GetConstructor(paramTypes);
							if(baseCon == null)
							{
								// TODO better error handling
								throw new InvalidOperationException("constructor not found: " + DeclaringType.Name + ".<init>" + m.Sig);
							}
							for(int i = 0; i < paramTypes.Length; i++)
							{
								ilgen.EmitLdarg(i);
							}
							ilgen.Emit(OpCodes.Newobj, baseCon);
							ilgen.Emit(OpCodes.Ret);
						}
						ilgen.DoEmit();
						if(this.DeclaringType.GetClassLoader().EmitStackTraceInfo)
						{
							ilgen.EmitLineNumberTable(mbHelper);
						}
					}
				}
			}

			sealed class RemappedMethodWrapper : RemappedMethodBaseWrapper
			{
				private IKVM.Internal.MapXml.Method m;
				private IKVM.Internal.MapXml.Root map;
				private MethodBuilder mbHelper;
				private List<RemapperTypeWrapper> overriders = new List<RemapperTypeWrapper>();
				private bool inherited;

				internal RemappedMethodWrapper(RemapperTypeWrapper typeWrapper, IKVM.Internal.MapXml.Method m, IKVM.Internal.MapXml.Root map, bool inherited)
					: base(typeWrapper, m.Name, m.Sig, (Modifiers)m.Modifiers)
				{
					this.m = m;
					this.map = map;
					this.inherited = inherited;
				}

				internal IKVM.Internal.MapXml.Method XmlMethod
				{
					get
					{
						return m;
					}
				}

				internal override void EmitCall(CodeEmitter ilgen)
				{
					if(!IsStatic && IsFinal)
					{
						// When calling a final instance method on a remapped type from a class derived from a .NET class (i.e. a cli.System.Object or cli.System.Exception derived base class)
						// then we can't call the java.lang.Object or java.lang.Throwable methods and we have to go through the instancehelper_ method. Note that since the method
						// is final, this won't affect the semantics.
						EmitCallvirt(ilgen);
					}
					else
					{
						ilgen.Emit(OpCodes.Call, (MethodInfo)GetMethod());
					}
				}

				internal override void EmitCallvirt(CodeEmitter ilgen)
				{
					EmitCallvirtImpl(ilgen, this.IsProtected && !mbHelper.IsPublic);
				}

				private void EmitCallvirtImpl(CodeEmitter ilgen, bool cloneOrFinalizeHack)
				{
					if(mbHelper != null && !cloneOrFinalizeHack)
					{
						ilgen.Emit(OpCodes.Call, mbHelper);
					}
					else
					{
						ilgen.Emit(OpCodes.Callvirt, (MethodInfo)GetMethod());
					}
				}

				internal override MethodBase DoLink()
				{
					RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)DeclaringType;

					if(typeWrapper.IsInterface)
					{
						if(m.@@override == null)
						{
							throw new InvalidOperationException(typeWrapper.Name + "." + m.Name + m.Sig);
						}
						MethodInfo interfaceMethod = typeWrapper.shadowType.GetMethod(m.@@override.Name, typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig));
						if(interfaceMethod == null)
						{
							throw new InvalidOperationException(typeWrapper.Name + "." + m.Name + m.Sig);
						}
						// if any of the remapped types has a body for this interface method, we need a helper method
						// to special invocation through this interface for that type
						List<IKVM.Internal.MapXml.Class> specialCases = null;
						foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
						{
							if(c.Methods != null)
							{
								foreach(IKVM.Internal.MapXml.Method mm in c.Methods)
								{
									if(mm.Name == m.Name && mm.Sig == m.Sig && mm.body != null)
									{
										if(specialCases == null)
										{
											specialCases = new List<IKVM.Internal.MapXml.Class>();
										}
										specialCases.Add(c);
										break;
									}
								}
							}
						}
						string[] throws;
						if (m.throws == null)
						{
							throws = new string[0];
						}
						else
						{
							throws = new string[m.throws.Length];
							for (int i = 0; i < throws.Length; i++)
							{
								throws[i] = m.throws[i].Class;
							}
						}
						AttributeHelper.SetRemappedInterfaceMethod(typeWrapper.typeBuilder, m.Name, m.@@override.Name, throws);
						MethodBuilder helper = null;
						if(specialCases != null)
						{
							CodeEmitter ilgen;
							Type[] argTypes = ArrayUtil.Concat(typeWrapper.shadowType, typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig));
							if(typeWrapper.helperTypeBuilder == null)
							{
								typeWrapper.helperTypeBuilder = typeWrapper.typeBuilder.DefineNestedType("__Helper", TypeAttributes.NestedPublic | TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.Abstract);
								AttributeHelper.HideFromJava(typeWrapper.helperTypeBuilder);
							}
							helper = typeWrapper.helperTypeBuilder.DefineMethod(m.Name, MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig, LoadMode.LoadOrThrow).TypeAsSignatureType, argTypes);
							if(m.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
								{
									AttributeHelper.SetCustomAttribute(DeclaringType.GetClassLoader(), helper, custattr);
								}
							}
							SetParameters(DeclaringType.GetClassLoader(), helper, m.Params);
							ilgen = CodeEmitter.Create(helper);
							foreach(IKVM.Internal.MapXml.Class c in specialCases)
							{
								TypeWrapper tw = typeWrapper.GetClassLoader().LoadClassByDottedName(c.Name);
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Isinst, tw.TypeAsTBD);
								ilgen.Emit(OpCodes.Dup);
								CodeEmitterLabel label = ilgen.DefineLabel();
								ilgen.EmitBrfalse(label);
								for(int i = 1; i < argTypes.Length; i++)
								{
									ilgen.EmitLdarg(i);
								}
								MethodWrapper mw = tw.GetMethodWrapper(m.Name, m.Sig, false);
								mw.Link();
								mw.EmitCallvirt(ilgen);
								ilgen.Emit(OpCodes.Ret);
								ilgen.MarkLabel(label);
								ilgen.Emit(OpCodes.Pop);
							}
							for(int i = 0; i < argTypes.Length; i++)
							{
								ilgen.EmitLdarg(i);
							}
							ilgen.Emit(OpCodes.Callvirt, interfaceMethod);
							ilgen.Emit(OpCodes.Ret);
							ilgen.DoEmit();
						}
						mbHelper = helper;
						return interfaceMethod;
					}
					else
					{
						MethodBuilder mbCore = null;
						Type[] paramTypes = typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig);
						Type retType = typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig, LoadMode.LoadOrThrow).TypeAsSignatureType;

						if(typeWrapper.shadowType.IsSealed && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) == 0)
						{
							// skip instance methods in sealed types, but we do need to add them to the overriders
							if(typeWrapper.BaseTypeWrapper != null && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Private) == 0)
							{
								RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(m.Name, m.Sig, true) as RemappedMethodWrapper;
								if(baseMethod != null &&
									!baseMethod.IsFinal &&
									!baseMethod.IsPrivate &&
									(baseMethod.m.@@override != null ||
									baseMethod.m.redirect != null ||
									baseMethod.m.body != null ||
									baseMethod.m.alternateBody != null))
								{
									baseMethod.overriders.Add(typeWrapper);
								}
							}
						}
						else
						{
							MethodInfo overrideMethod = null;
							MethodAttributes attr = m.MethodAttributes | MapMethodAccessModifiers(m.Modifiers) | MethodAttributes.HideBySig;
							if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) != 0)
							{
								attr |= MethodAttributes.Static;
							}
							else if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Private) == 0 && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Final) == 0)
							{
								attr |= MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.CheckAccessOnOverride;
								if(!typeWrapper.shadowType.IsSealed)
								{
									MethodInfo autoOverride = typeWrapper.shadowType.GetMethod(m.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, paramTypes, null);
									if(autoOverride != null && autoOverride.ReturnType == retType && !autoOverride.IsFinal)
									{
										// the method we're processing is overriding a method in its shadowType (which is the actual base type)
										attr &= ~MethodAttributes.NewSlot;
									}
								}
								if(typeWrapper.BaseTypeWrapper != null)
								{
									RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(m.Name, m.Sig, true) as RemappedMethodWrapper;
									if(baseMethod != null)
									{
										baseMethod.overriders.Add(typeWrapper);
										if(baseMethod.m.@@override != null)
										{
											overrideMethod = typeWrapper.BaseTypeWrapper.TypeAsTBD.GetMethod(baseMethod.m.@@override.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, paramTypes, null);
											if(overrideMethod == null)
											{
												throw new InvalidOperationException();
											}
										}
									}
								}
							}
							mbCore = GetDefineMethodHelper().DefineMethod(DeclaringType.GetClassLoader().GetTypeWrapperFactory(), typeWrapper.typeBuilder, m.Name, attr);
							if(m.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
								{
									AttributeHelper.SetCustomAttribute(DeclaringType.GetClassLoader(), mbCore, custattr);
								}
							}
							SetParameters(DeclaringType.GetClassLoader(), mbCore, m.Params);
							if(overrideMethod != null && !inherited)
							{
								typeWrapper.typeBuilder.DefineMethodOverride(mbCore, overrideMethod);
							}
							if(inherited)
							{
								AttributeHelper.HideFromReflection(mbCore);
							}
							AddDeclaredExceptions(mbCore, m.throws);
						}

						if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) == 0 && !IsHideFromJava(m))
						{
							// instance methods must have an instancehelper method
							MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers) | MethodAttributes.HideBySig | MethodAttributes.Static;
							// NOTE instancehelpers for protected methods are made internal
							// and special cased in DotNetTypeWrapper.LazyPublishMembers
							if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Protected) != 0)
							{
								attr &= ~MethodAttributes.MemberAccessMask;
								attr |= MethodAttributes.Assembly;
							}
							mbHelper = typeWrapper.typeBuilder.DefineMethod("instancehelper_" + m.Name, attr, CallingConventions.Standard, retType, ArrayUtil.Concat(typeWrapper.shadowType, paramTypes));
							if(m.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
								{
									AttributeHelper.SetCustomAttribute(DeclaringType.GetClassLoader(), mbHelper, custattr);
								}
							}
							IKVM.Internal.MapXml.Param[] parameters;
							if(m.Params == null)
							{
								parameters = new IKVM.Internal.MapXml.Param[1];
							}
							else
							{
								parameters = new IKVM.Internal.MapXml.Param[m.Params.Length + 1];
								m.Params.CopyTo(parameters, 1);
							}
							parameters[0] = new IKVM.Internal.MapXml.Param();
							parameters[0].Name = "this";
							SetParameters(DeclaringType.GetClassLoader(), mbHelper, parameters);
							if(!typeWrapper.IsFinal)
							{
								AttributeHelper.SetEditorBrowsableNever(mbHelper);
							}
							AttributeHelper.SetModifiers(mbHelper, (Modifiers)m.Modifiers, false);
							AttributeHelper.SetNameSig(mbHelper, m.Name, m.Sig);
							AddDeclaredExceptions(mbHelper, m.throws);
							mbHelper.SetCustomAttribute(new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(new Type[] { Types.String }), new object[] { "This function will be removed from future versions. Please use extension methods from ikvm.extensions namespace instead." }));
						}
						return mbCore;
					}
				}

				private static bool IsHideFromJava(IKVM.Internal.MapXml.Method m)
				{
					if (m.Attributes != null)
					{
						foreach (MapXml.Attribute attr in m.Attributes)
						{
							if (attr.Type == "IKVM.Attributes.HideFromJavaAttribute")
							{
								return true;
							}
						}
					}
					return m.Name.StartsWith("__<", StringComparison.Ordinal);
				}

				internal override void Finish()
				{
					// TODO we should insert method tracing (if enabled)
					Type[] paramTypes = this.GetParametersForDefineMethod();

					MethodBuilder mbCore = GetMethod() as MethodBuilder;

					// NOTE sealed types don't have instance methods (only instancehelpers)
					if(mbCore != null)
					{
						CodeEmitter ilgen = CodeEmitter.Create(mbCore);
						MethodInfo baseMethod = null;
						if(m.@@override != null)
						{
							baseMethod = DeclaringType.TypeAsTBD.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, paramTypes, null);
							if(baseMethod == null)
							{
								throw new InvalidOperationException();
							}
							((TypeBuilder)DeclaringType.TypeAsBaseType).DefineMethodOverride(mbCore, baseMethod);
						}
						// TODO we need to support ghost (and other funky?) parameter types
						if(m.body != null)
						{
							// we manually walk the instruction list, because we need to special case the ret instructions
							IKVM.Internal.MapXml.CodeGenContext context = new IKVM.Internal.MapXml.CodeGenContext(DeclaringType.GetClassLoader());
							foreach(IKVM.Internal.MapXml.Instruction instr in m.body.invoke)
							{
								if(instr is IKVM.Internal.MapXml.Ret)
								{
									this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
								}
								instr.Generate(context, ilgen);
							}
						}
						else
						{
							if(m.redirect != null && m.redirect.LineNumber != -1)
							{
								ilgen.SetLineNumber((ushort)m.redirect.LineNumber);
							}
							int thisOffset = 0;
							if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) == 0)
							{
								thisOffset = 1;
								ilgen.Emit(OpCodes.Ldarg_0);
							}
							for(int i = 0; i < paramTypes.Length; i++)
							{
								ilgen.EmitLdarg(i + thisOffset);
							}
							if(m.redirect != null)
							{
								EmitRedirect(DeclaringType.TypeAsTBD, ilgen);
							}
							else
							{
								if(baseMethod == null)
								{
									throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
								}
								ilgen.Emit(OpCodes.Call, baseMethod);
							}
							this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
							ilgen.Emit(OpCodes.Ret);
						}
						ilgen.DoEmit();
						if(this.DeclaringType.GetClassLoader().EmitStackTraceInfo)
						{
							ilgen.EmitLineNumberTable(mbCore);
						}
					}

					// NOTE static methods don't have helpers
					// NOTE for interface helpers we don't have to do anything,
					// because they've already been generated in DoLink
					// (currently this only applies to Comparable.compareTo).
					if(mbHelper != null && !this.DeclaringType.IsInterface)
					{
						CodeEmitter ilgen = CodeEmitter.Create(mbHelper);
						// check "this" for null
						if(m.@@override != null && m.redirect == null && m.body == null && m.alternateBody == null)
						{
							// we're going to be calling the overridden version, so we don't need the null check
						}
						else if(!m.NoNullCheck)
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.EmitNullCheck();
						}
						if(mbCore != null && 
							(m.@@override == null || m.redirect != null) &&
							(m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Private) == 0 && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Final) == 0)
						{
							// TODO we should have a way to supress this for overridden methods
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Isinst, DeclaringType.TypeAsBaseType);
							ilgen.Emit(OpCodes.Dup);
							CodeEmitterLabel skip = ilgen.DefineLabel();
							ilgen.EmitBrfalse(skip);
							for(int i = 0; i < paramTypes.Length; i++)
							{
								ilgen.EmitLdarg(i + 1);
							}
							ilgen.Emit(OpCodes.Callvirt, mbCore);
							this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
							ilgen.Emit(OpCodes.Ret);
							ilgen.MarkLabel(skip);
							ilgen.Emit(OpCodes.Pop);
						}
						foreach(RemapperTypeWrapper overrider in overriders)
						{
							RemappedMethodWrapper mw = (RemappedMethodWrapper)overrider.GetMethodWrapper(Name, Signature, false);
							if(mw.m.redirect == null && mw.m.body == null && mw.m.alternateBody == null)
							{
								// the overridden method doesn't actually do anything special (that means it will end
								// up calling the .NET method it overrides), so we don't need to special case this
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Isinst, overrider.TypeAsTBD);
								ilgen.Emit(OpCodes.Dup);
								CodeEmitterLabel skip = ilgen.DefineLabel();
								ilgen.EmitBrfalse(skip);
								for(int i = 0; i < paramTypes.Length; i++)
								{
									ilgen.EmitLdarg(i + 1);
								}
								mw.Link();
								mw.EmitCallvirtImpl(ilgen, false);
								this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
								ilgen.Emit(OpCodes.Ret);
								ilgen.MarkLabel(skip);
								ilgen.Emit(OpCodes.Pop);
							}
						}
						if(m.body != null || m.alternateBody != null)
						{
							IKVM.Internal.MapXml.InstructionList body = m.alternateBody == null ? m.body : m.alternateBody;
							// we manually walk the instruction list, because we need to special case the ret instructions
							IKVM.Internal.MapXml.CodeGenContext context = new IKVM.Internal.MapXml.CodeGenContext(DeclaringType.GetClassLoader());
							foreach(IKVM.Internal.MapXml.Instruction instr in body.invoke)
							{
								if(instr is IKVM.Internal.MapXml.Ret)
								{
									this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
								}
								instr.Generate(context, ilgen);
							}
						}
						else
						{
							if(m.redirect != null && m.redirect.LineNumber != -1)
							{
								ilgen.SetLineNumber((ushort)m.redirect.LineNumber);
							}
							Type shadowType = ((RemapperTypeWrapper)DeclaringType).shadowType;
							for(int i = 0; i < paramTypes.Length + 1; i++)
							{
								ilgen.EmitLdarg(i);
							}
							if(m.redirect != null)
							{
								EmitRedirect(shadowType, ilgen);
							}
							else if(m.@@override != null)
							{
								MethodInfo baseMethod = shadowType.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
								if(baseMethod == null)
								{
									throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
								}
								ilgen.Emit(OpCodes.Callvirt, baseMethod);
							}
							else
							{
								RemappedMethodWrapper baseMethod = DeclaringType.BaseTypeWrapper.GetMethodWrapper(Name, Signature, true) as RemappedMethodWrapper;
								if(baseMethod == null || baseMethod.m.@@override == null)
								{
									throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
								}
								MethodInfo overrideMethod = shadowType.GetMethod(baseMethod.m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
								if(overrideMethod == null)
								{
									throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
								}
								ilgen.Emit(OpCodes.Callvirt, overrideMethod);
							}
							this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
							ilgen.Emit(OpCodes.Ret);
						}
						ilgen.DoEmit();
						if(this.DeclaringType.GetClassLoader().EmitStackTraceInfo)
						{
							ilgen.EmitLineNumberTable(mbHelper);
						}
					}

					// do we need a helper for non-virtual reflection invocation?
					if(m.nonvirtualAlternateBody != null || (m.@@override != null && overriders.Count > 0))
					{
						RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)DeclaringType;
						MethodBuilder mb = typeWrapper.typeBuilder.DefineMethod("nonvirtualhelper/" + this.Name, MethodAttributes.Private | MethodAttributes.Static,
							ReturnTypeForDefineMethod, ArrayUtil.Concat(typeWrapper.TypeAsSignatureType, GetParametersForDefineMethod()));
						if(m.Attributes != null)
						{
							foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
							{
								AttributeHelper.SetCustomAttribute(DeclaringType.GetClassLoader(), mb, custattr);
							}
						}
						SetParameters(DeclaringType.GetClassLoader(), mb, m.Params);
						AttributeHelper.HideFromJava(mb);
						CodeEmitter ilgen = CodeEmitter.Create(mb);
						if(m.nonvirtualAlternateBody != null)
						{
							m.nonvirtualAlternateBody.Emit(DeclaringType.GetClassLoader(), ilgen);
						}
						else
						{
							Type shadowType = ((RemapperTypeWrapper)DeclaringType).shadowType;
							MethodInfo baseMethod = shadowType.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
							if(baseMethod == null)
							{
								throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
							}
							ilgen.Emit(OpCodes.Ldarg_0);
							for(int i = 0; i < paramTypes.Length; i++)
							{
								ilgen.EmitLdarg(i + 1);
							}
							ilgen.Emit(OpCodes.Call, baseMethod);
							ilgen.Emit(OpCodes.Ret);
						}
						ilgen.DoEmit();
					}
				}

				private void EmitRedirect(Type baseType, CodeEmitter ilgen)
				{
					string redirName = m.redirect.Name;
					string redirSig = m.redirect.Sig;
					if(redirName == null)
					{
						redirName = m.Name;
					}
					if(redirSig == null)
					{
						redirSig = m.Sig;
					}
					ClassLoaderWrapper classLoader = DeclaringType.GetClassLoader();
					// HACK if the class name contains a comma, we assume it is a .NET type
					if(m.redirect.Class == null || m.redirect.Class.IndexOf(',') >= 0)
					{
						// TODO better error handling
						Type type = m.redirect.Class == null ? baseType : StaticCompiler.Universe.GetType(m.redirect.Class, true);
						Type[] redirParamTypes = classLoader.ArgTypeListFromSig(redirSig);
						MethodInfo mi = type.GetMethod(m.redirect.Name, redirParamTypes);
						if(mi == null)
						{
							throw new InvalidOperationException();
						}
						ilgen.Emit(OpCodes.Call, mi);
					}
					else
					{
						TypeWrapper tw = classLoader.LoadClassByDottedName(m.redirect.Class);
						MethodWrapper mw = tw.GetMethodWrapper(redirName, redirSig, false);
						if(mw == null)
						{
							throw new InvalidOperationException("Missing redirect method: " + tw.Name + "." + redirName + redirSig);
						}
						mw.Link();
						mw.EmitCall(ilgen);
					}
				}
			}

			private static void SetParameters(ClassLoaderWrapper loader, MethodBuilder mb, IKVM.Internal.MapXml.Param[] parameters)
			{
				if(parameters != null)
				{
					for(int i = 0; i < parameters.Length; i++)
					{
						ParameterBuilder pb = mb.DefineParameter(i + 1, ParameterAttributes.None, parameters[i].Name);
						if(parameters[i].Attributes != null)
						{
							for(int j = 0; j < parameters[i].Attributes.Length; j++)
							{
								AttributeHelper.SetCustomAttribute(loader, pb, parameters[i].Attributes[j]);
							}
						}
					}
				}
			}

			internal void Process2ndPassStep1()
			{
				if (!shadowType.IsSealed)
				{
					foreach (TypeWrapper ifaceTypeWrapper in interfaceWrappers)
					{
						typeBuilder.AddInterfaceImplementation(ifaceTypeWrapper.TypeAsBaseType);
					}
				}
				AttributeHelper.SetImplementsAttribute(typeBuilder, interfaceWrappers);
			}

			internal void Process2ndPassStep2(IKVM.Internal.MapXml.Root map)
			{
				IKVM.Internal.MapXml.Class c = classDef;
				TypeBuilder tb = typeBuilder;

				List<FieldWrapper> fields = new List<FieldWrapper>();

				// TODO fields should be moved to the RemapperTypeWrapper constructor as well
				if(c.Fields != null)
				{
					foreach(IKVM.Internal.MapXml.Field f in c.Fields)
					{
						{
							FieldAttributes attr = MapFieldAccessModifiers(f.Modifiers);
							if(f.Constant != null)
							{
								attr |= FieldAttributes.Literal;
							}
							else if((f.Modifiers & IKVM.Internal.MapXml.MapModifiers.Final) != 0)
							{
								attr |= FieldAttributes.InitOnly;
							}
							if((f.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) != 0)
							{
								attr |= FieldAttributes.Static;
							}
							FieldBuilder fb = tb.DefineField(f.Name, GetClassLoader().FieldTypeWrapperFromSig(f.Sig, LoadMode.LoadOrThrow).TypeAsSignatureType, attr);
							if(f.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute custattr in f.Attributes)
								{
									AttributeHelper.SetCustomAttribute(classLoader, fb, custattr);
								}
							}
							object constant;
							if(f.Constant != null)
							{
								switch(f.Sig[0])
								{
									case 'J':
										constant = long.Parse(f.Constant);
										break;
									default:
										// TODO support other types
										throw new NotImplementedException("remapped constant field of type: " + f.Sig);
								}
								fb.SetConstant(constant);
								fields.Add(new ConstantFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig, LoadMode.LoadOrThrow), f.Name, f.Sig, (Modifiers)f.Modifiers, fb, constant, MemberFlags.None));
							}
							else
							{
								fields.Add(FieldWrapper.Create(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig, LoadMode.LoadOrThrow), fb, f.Name, f.Sig, new ExModifiers((Modifiers)f.Modifiers, false)));
							}
						}
					}
				}
				SetFields(fields.ToArray());
			}

			internal void Process3rdPass()
			{
				foreach(RemappedMethodBaseWrapper m in GetMethods())
				{
					m.Link();
				}
			}

			internal void Process4thPass(ICollection<RemapperTypeWrapper> remappedTypes)
			{
				foreach(RemappedMethodBaseWrapper m in GetMethods())
				{
					m.Finish();
				}

				if(classDef.Clinit != null)
				{
					MethodBuilder cb = ReflectUtil.DefineTypeInitializer(typeBuilder, classLoader);
					CodeEmitter ilgen = CodeEmitter.Create(cb);
					// TODO emit code to make sure super class is initialized
					classDef.Clinit.body.Emit(classLoader, ilgen);
					ilgen.DoEmit();
				}

				// FXBUG because the AppDomain.TypeResolve event doesn't work correctly for inner classes,
				// we need to explicitly finish the interface we implement (if they are ghosts, we need the nested __Interface type)
				if(classDef.Interfaces != null)
				{
					foreach(IKVM.Internal.MapXml.Interface iface in classDef.Interfaces)
					{
						GetClassLoader().LoadClassByDottedName(iface.Name).Finish();
					}
				}

				CreateShadowInstanceOf(remappedTypes);
				CreateShadowCheckCast(remappedTypes);

				if(!shadowType.IsInterface)
				{
					// For all inherited methods, we emit a method that hides the inherited method and
					// annotate it with EditorBrowsableAttribute(EditorBrowsableState.Never) to make
					// sure the inherited methods don't show up in Intellisense.
					Dictionary<string, MethodBuilder> methods = new Dictionary<string, MethodBuilder>();
					foreach(MethodWrapper mw in GetMethods())
					{
						MethodBuilder mb = mw.GetMethod() as MethodBuilder;
						if(mb != null)
						{
							methods.Add(MakeMethodKey(mb), mb);
						}
					}
					foreach(MethodInfo mi in typeBuilder.BaseType.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.FlattenHierarchy))
					{
						string key = MakeMethodKey(mi);
						if(!methods.ContainsKey(key))
						{
							ParameterInfo[] paramInfo = mi.GetParameters();
							Type[] paramTypes = new Type[paramInfo.Length];
							for(int i = 0; i < paramInfo.Length; i++)
							{
								paramTypes[i] = paramInfo[i].ParameterType;
							}
							MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & (MethodAttributes.MemberAccessMask | MethodAttributes.SpecialName | MethodAttributes.Static), mi.ReturnType, paramTypes);
							AttributeHelper.HideFromJava(mb);
							AttributeHelper.SetEditorBrowsableNever(mb);
							CopyLinkDemands(mb, mi);
							CodeEmitter ilgen = CodeEmitter.Create(mb);
							for(int i = 0; i < paramTypes.Length; i++)
							{
								ilgen.EmitLdarg(i);
							}
							if(!mi.IsStatic)
							{
								ilgen.EmitLdarg(paramTypes.Length);
								ilgen.Emit(OpCodes.Callvirt, mi);
							}
							else
							{
								ilgen.Emit(OpCodes.Call, mi);
							}
							ilgen.Emit(OpCodes.Ret);
							ilgen.DoEmit();
							methods[key] = mb;
						}
					}
					foreach(PropertyInfo pi in typeBuilder.BaseType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static))
					{
						ParameterInfo[] paramInfo = pi.GetIndexParameters();
						Type[] paramTypes = new Type[paramInfo.Length];
						for(int i = 0; i < paramInfo.Length; i++)
						{
							paramTypes[i] = paramInfo[i].ParameterType;
						}
						PropertyBuilder pb = typeBuilder.DefineProperty(pi.Name, PropertyAttributes.None, pi.PropertyType, paramTypes);
						if(pi.GetGetMethod() != null)
						{
							pb.SetGetMethod(methods[MakeMethodKey(pi.GetGetMethod())]);
						}
						if(pi.GetSetMethod() != null)
						{
							pb.SetSetMethod(methods[MakeMethodKey(pi.GetSetMethod())]);
						}
						AttributeHelper.SetEditorBrowsableNever(pb);
					}
				}

				typeBuilder.CreateType();
				if(helperTypeBuilder != null)
				{
					helperTypeBuilder.CreateType();
				}
			}

			private static void CopyLinkDemands(MethodBuilder mb, MethodInfo mi)
			{
				foreach (CustomAttributeData cad in CustomAttributeData.__GetDeclarativeSecurity(mi))
				{
					if (cad.ConstructorArguments.Count == 0 || (int)cad.ConstructorArguments[0].Value == (int)SecurityAction.LinkDemand)
					{
						mb.__AddDeclarativeSecurity(cad.__ToBuilder());
					}
				}
			}

			private static string MakeMethodKey(MethodInfo method)
			{
				StringBuilder sb = new StringBuilder();
				sb.Append(method.ReturnType.AssemblyQualifiedName).Append(":").Append(method.Name);
				ParameterInfo[] paramInfo = method.GetParameters();
				Type[] paramTypes = new Type[paramInfo.Length];
				for(int i = 0; i < paramInfo.Length; i++)
				{
					paramTypes[i] = paramInfo[i].ParameterType;
					sb.Append(":").Append(paramInfo[i].ParameterType.AssemblyQualifiedName);
				}
				return sb.ToString();
			}

			private void CreateShadowInstanceOf(ICollection<RemapperTypeWrapper> remappedTypes)
			{
				// FXBUG .NET 1.1 doesn't allow static methods on interfaces
				if(typeBuilder.IsInterface)
				{
					return;
				}
				MethodAttributes attr = MethodAttributes.SpecialName | MethodAttributes.Public | MethodAttributes.Static;
				MethodBuilder mb = typeBuilder.DefineMethod("__<instanceof>", attr, Types.Boolean, new Type[] { Types.Object });
				AttributeHelper.HideFromJava(mb);
				AttributeHelper.SetEditorBrowsableNever(mb);
				CodeEmitter ilgen = CodeEmitter.Create(mb);

				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Isinst, shadowType);
				CodeEmitterLabel retFalse = ilgen.DefineLabel();
				ilgen.EmitBrfalse(retFalse);

				if(!shadowType.IsSealed)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Isinst, typeBuilder);
					ilgen.EmitBrtrue(retFalse);
				}

				if(shadowType == Types.Object)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Isinst, Types.Array);
					ilgen.EmitBrtrue(retFalse);
				}

				foreach(RemapperTypeWrapper r in remappedTypes)
				{
					if(!r.shadowType.IsInterface && r.shadowType.IsSubclassOf(shadowType))
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, r.shadowType);
						ilgen.EmitBrtrue(retFalse);
					}
				}
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Ret);

				ilgen.MarkLabel(retFalse);
				ilgen.Emit(OpCodes.Ldc_I4_0);
				ilgen.Emit(OpCodes.Ret);

				ilgen.DoEmit();
			}

			private void CreateShadowCheckCast(ICollection<RemapperTypeWrapper> remappedTypes)
			{
				// FXBUG .NET 1.1 doesn't allow static methods on interfaces
				if(typeBuilder.IsInterface)
				{
					return;
				}
				MethodAttributes attr = MethodAttributes.SpecialName | MethodAttributes.Public | MethodAttributes.Static;
				MethodBuilder mb = typeBuilder.DefineMethod("__<checkcast>", attr, shadowType, new Type[] { Types.Object });
				AttributeHelper.HideFromJava(mb);
				AttributeHelper.SetEditorBrowsableNever(mb);
				CodeEmitter ilgen = CodeEmitter.Create(mb);

				CodeEmitterLabel fail = ilgen.DefineLabel();
				bool hasfail = false;

				if(!shadowType.IsSealed)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Isinst, typeBuilder);
					ilgen.EmitBrtrue(fail);
					hasfail = true;
				}

				if(shadowType == Types.Object)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Isinst, Types.Array);
					ilgen.EmitBrtrue(fail);
					hasfail = true;
				}

				foreach(RemapperTypeWrapper r in remappedTypes)
				{
					if(!r.shadowType.IsInterface && r.shadowType.IsSubclassOf(shadowType))
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, r.shadowType);
						ilgen.EmitBrtrue(fail);
						hasfail = true;
					}
				}
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.EmitCastclass(shadowType);
				ilgen.Emit(OpCodes.Ret);

				if(hasfail)
				{
					ilgen.MarkLabel(fail);
					ilgen.ThrowException(JVM.Import(typeof(InvalidCastException)));
				}

				ilgen.DoEmit();
			}

			internal override MethodBase LinkMethod(MethodWrapper mw)
			{
				return ((RemappedMethodBaseWrapper)mw).DoLink();
			}

			internal override TypeWrapper[] Interfaces
			{
				get
				{
					return interfaceWrappers;
				}
			}

			internal override Type TypeAsTBD
			{
				get
				{
					return shadowType;
				}
			}

			internal override Type TypeAsBaseType
			{
				get
				{
					return typeBuilder;
				}
			}

			internal override bool IsMapUnsafeException
			{
				get
				{
					// any remapped exceptions are automatically unsafe
					return shadowType == Types.Exception || shadowType.IsSubclassOf(Types.Exception);
				}
			}

			internal override bool IsFastClassLiteralSafe
			{
				get { return true; }
			}
		}

		internal static void AddDeclaredExceptions(MethodBuilder mb, IKVM.Internal.MapXml.Throws[] throws)
		{
			if (throws != null)
			{
				string[] exceptions = new string[throws.Length];
				for (int i = 0; i < exceptions.Length; i++)
				{
					exceptions[i] = throws[i].Class;
				}
				AttributeHelper.SetThrowsAttribute(mb, exceptions);
			}
		}

		internal void EmitRemappedTypes()
		{
			Tracer.Info(Tracer.Compiler, "Emit remapped types");

			assemblyAttributes = map.assembly.Attributes;

			if(map.assembly.Classes != null)
			{
				// 1st pass, put all types in remapped to make them loadable
				bool hasRemappedTypes = false;
				foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
				{
					if(c.Shadows != null)
					{
						if(classes.ContainsKey(c.Name))
						{
							StaticCompiler.IssueMessage(Message.DuplicateClassName, c.Name);
						}
						remapped.Add(c.Name, new RemapperTypeWrapper(this, c, map));
						hasRemappedTypes = true;
					}
				}

				if(hasRemappedTypes)
				{
					SetupGhosts(map);
					foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
					{
						if(c.Shadows != null)
						{
							remapped[c.Name].LoadInterfaces(c);
						}
					}
				}
			}
		}

		internal void EmitRemappedTypes2ndPass()
		{
			if (map != null && map.assembly != null && map.assembly.Classes != null)
			{
				// 2nd pass, resolve interfaces, publish methods/fields
				foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
				{
					if(c.Shadows != null)
					{
						RemapperTypeWrapper typeWrapper = remapped[c.Name];
						typeWrapper.Process2ndPassStep1();
					}
				}
				foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
				{
					if(c.Shadows != null)
					{
						RemapperTypeWrapper typeWrapper = remapped[c.Name];
						typeWrapper.Process2ndPassStep2(map);
					}
				}
			}
		}

		internal bool IsMapUnsafeException(TypeWrapper tw)
		{
			if(mappedExceptions != null)
			{
				for(int i = 0; i < mappedExceptions.Length; i++)
				{
					if(mappedExceptions[i].IsSubTypeOf(tw) ||
						(mappedExceptionsAllSubClasses[i] && tw.IsSubTypeOf(mappedExceptions[i])))
					{
						return true;
					}
				}
			}
			return false;
		}

		internal void LoadMappedExceptions(IKVM.Internal.MapXml.Root map)
		{
			if(map.exceptionMappings != null)
			{
				mappedExceptionsAllSubClasses = new bool[map.exceptionMappings.Length];
				mappedExceptions = new TypeWrapper[map.exceptionMappings.Length];
				for(int i = 0; i < mappedExceptions.Length; i++)
				{
					string dst = map.exceptionMappings[i].dst;
					if(dst[0] == '*')
					{
						mappedExceptionsAllSubClasses[i] = true;
						dst = dst.Substring(1);
					}
					mappedExceptions[i] = LoadClassByDottedName(dst);
				}
				// HACK we need to find the <exceptionMapping /> element and bind it
				foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
				{
					if(c.Methods != null)
					{
						foreach(IKVM.Internal.MapXml.Method m in c.Methods)
						{
							if(m.body != null && m.body.invoke != null)
							{
								foreach(IKVM.Internal.MapXml.Instruction instr in m.body.invoke)
								{
									IKVM.Internal.MapXml.EmitExceptionMapping eem = instr as IKVM.Internal.MapXml.EmitExceptionMapping;
									if(eem != null)
									{
										eem.mapping = map.exceptionMappings;
									}
								}
							}
						}
					}
				}
			}
		}

		internal sealed class ExceptionMapEmitter
		{
			private IKVM.Internal.MapXml.ExceptionMapping[] map;

			internal ExceptionMapEmitter(IKVM.Internal.MapXml.ExceptionMapping[] map)
			{
				this.map = map;
			}

			internal void Emit(IKVM.Internal.MapXml.CodeGenContext context, CodeEmitter ilgen)
			{
				MethodWrapper mwSuppressFillInStackTrace = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("__<suppressFillInStackTrace>", "()V", false);
				mwSuppressFillInStackTrace.Link();
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Callvirt, Compiler.getTypeMethod);
				for(int i = 0; i < map.Length; i++)
				{
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Ldtoken, StaticCompiler.Universe.GetType(map[i].src, true));
					ilgen.Emit(OpCodes.Call, Compiler.getTypeFromHandleMethod);
					ilgen.Emit(OpCodes.Ceq);
					CodeEmitterLabel label = ilgen.DefineLabel();
					ilgen.EmitBrfalse(label);
					ilgen.Emit(OpCodes.Pop);
					if(map[i].code != null)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						if(map[i].code.invoke != null)
						{
							foreach(MapXml.Instruction instr in map[i].code.invoke)
							{
								MapXml.NewObj newobj = instr as MapXml.NewObj;
								if(newobj != null
									&& newobj.Class != null
									&& context.ClassLoader.LoadClassByDottedName(newobj.Class).IsSubTypeOf(CoreClasses.java.lang.Throwable.Wrapper))
								{
									mwSuppressFillInStackTrace.EmitCall(ilgen);
								}
								instr.Generate(context, ilgen);
							}
						}
						ilgen.Emit(OpCodes.Ret);
					}
					else
					{
						TypeWrapper tw = context.ClassLoader.LoadClassByDottedName(map[i].dst);
						MethodWrapper mw = tw.GetMethodWrapper("<init>", "()V", false);
						mw.Link();
						mwSuppressFillInStackTrace.EmitCall(ilgen);
						mw.EmitNewobj(ilgen);
						ilgen.Emit(OpCodes.Ret);
					}
					ilgen.MarkLabel(label);
				}
				ilgen.Emit(OpCodes.Pop);
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Ret);
			}
		}

		internal void LoadMapXml()
		{
			if(map.assembly.Classes != null)
			{
				mapxml_Classes = new Dictionary<string, IKVM.Internal.MapXml.Class>();
				mapxml_MethodBodies = new Dictionary<MethodKey, IKVM.Internal.MapXml.InstructionList>();
				mapxml_ReplacedMethods = new Dictionary<MethodKey, IKVM.Internal.MapXml.ReplaceMethodCall[]>();
				mapxml_MethodPrologues = new Dictionary<MethodKey, IKVM.Internal.MapXml.InstructionList>();
				foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
				{
					// if it is not a remapped type, it must be a container for native, patched or augmented methods
					if(c.Shadows == null)
					{
						string className = c.Name;
						mapxml_Classes.Add(className, c);
						AddMapXmlMethods(className, c.Constructors);
						AddMapXmlMethods(className, c.Methods);
						if (c.Clinit != null)
						{
							AddMapXmlMethod(className, c.Clinit);
						}
					}
				}
			}
		}

		private void AddMapXmlMethods(string className, IKVM.Internal.MapXml.MethodBase[] methods)
		{
			if(methods != null)
			{
				foreach(IKVM.Internal.MapXml.MethodBase method in methods)
				{
					AddMapXmlMethod(className, method);
				}
			}
		}

		private void AddMapXmlMethod(string className, IKVM.Internal.MapXml.MethodBase method)
		{
			if(method.body != null)
			{
				mapxml_MethodBodies.Add(method.ToMethodKey(className), method.body);
			}
			if(method.ReplaceMethodCalls != null)
			{
				mapxml_ReplacedMethods.Add(method.ToMethodKey(className), method.ReplaceMethodCalls);
			}
			if (method.prologue != null)
			{
				mapxml_MethodPrologues.Add(method.ToMethodKey(className), method.prologue);
			}
		}

		internal IKVM.Internal.MapXml.InstructionList GetMethodPrologue(MethodKey method)
		{
			if(mapxml_MethodPrologues == null)
			{
				return null;
			}
			IKVM.Internal.MapXml.InstructionList prologue;
			mapxml_MethodPrologues.TryGetValue(method, out prologue);
			return prologue;
		}

		internal IKVM.Internal.MapXml.ReplaceMethodCall[] GetReplacedMethodsFor(MethodWrapper mw)
		{
			if(mapxml_ReplacedMethods == null)
			{
				return null;
			}
			IKVM.Internal.MapXml.ReplaceMethodCall[] rmc;
			mapxml_ReplacedMethods.TryGetValue(new MethodKey(mw.DeclaringType.Name, mw.Name, mw.Signature), out rmc);
			return rmc;
		}

		internal Dictionary<string, IKVM.Internal.MapXml.Class> GetMapXmlClasses()
		{
			return mapxml_Classes;
		}

		internal Dictionary<MethodKey, IKVM.Internal.MapXml.InstructionList> GetMapXmlMethodBodies()
		{
			return mapxml_MethodBodies;
		}

		internal IKVM.Internal.MapXml.Param[] GetXmlMapParameters(string classname, string method, string sig)
		{
			if(mapxml_Classes != null)
			{
				IKVM.Internal.MapXml.Class clazz;
				if(mapxml_Classes.TryGetValue(classname, out clazz))
				{
					if(method == "<init>" && clazz.Constructors != null)
					{
						for(int i = 0; i < clazz.Constructors.Length; i++)
						{
							if(clazz.Constructors[i].Sig == sig)
							{
								return clazz.Constructors[i].Params;
							}
						}
					}
					else if(clazz.Methods != null)
					{
						for(int i = 0; i < clazz.Methods.Length; i++)
						{
							if(clazz.Methods[i].Name == method && clazz.Methods[i].Sig == sig)
							{
								return clazz.Methods[i].Params;
							}
						}
					}
				}
			}
			return null;
		}

		internal bool IsGhost(TypeWrapper tw)
		{
			return ghosts != null && tw.IsInterface && ghosts.ContainsKey(tw.Name);
		}

		private void SetupGhosts(IKVM.Internal.MapXml.Root map)
		{
			ghosts = new Dictionary<string, List<TypeWrapper>>();

			// find the ghost interfaces
			foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
			{
				if(c.Shadows != null && c.Interfaces != null)
				{
					// NOTE we don't support interfaces that inherit from other interfaces
					// (actually, if they are explicitly listed it would probably work)
					TypeWrapper typeWrapper = FindLoadedClass(c.Name);
					foreach(IKVM.Internal.MapXml.Interface iface in c.Interfaces)
					{
						TypeWrapper ifaceWrapper = FindLoadedClass(iface.Name);
						if(ifaceWrapper == null || !ifaceWrapper.TypeAsTBD.IsAssignableFrom(typeWrapper.TypeAsTBD))
						{
							AddGhost(iface.Name, typeWrapper);
						}
					}
				}
			}
			// we manually add the array ghost interfaces
			TypeWrapper array = ClassLoaderWrapper.GetWrapperFromType(Types.Array);
			AddGhost("java.io.Serializable", array);
			AddGhost("java.lang.Cloneable", array);
		}

		private void AddGhost(string interfaceName, TypeWrapper implementer)
		{
			List<TypeWrapper> list;
			if(!ghosts.TryGetValue(interfaceName, out list))
			{
				list = new List<TypeWrapper>();
				ghosts[interfaceName] = list;
			}
			list.Add(implementer);
		}

		internal TypeWrapper[] GetGhostImplementers(TypeWrapper wrapper)
		{
			List<TypeWrapper> list;
			if (!ghosts.TryGetValue(wrapper.Name, out list))
			{
				return TypeWrapper.EmptyArray;
			}
			return list.ToArray();
		}

		internal void FinishRemappedTypes()
		{
			// 3rd pass, link the methods. Note that a side effect of the linking is the
			// twiddling with the overriders array in the base methods, so we need to do this
			// as a separate pass before we compile the methods
			foreach(RemapperTypeWrapper typeWrapper in remapped.Values)
			{
				typeWrapper.Process3rdPass();
			}
			// 4th pass, implement methods/fields and bake the type
			foreach(RemapperTypeWrapper typeWrapper in remapped.Values)
			{
				typeWrapper.Process4thPass(remapped.Values);
			}

			if(assemblyAttributes != null)
			{
				foreach(IKVM.Internal.MapXml.Attribute attr in assemblyAttributes)
				{
					AttributeHelper.SetCustomAttribute(this, assemblyBuilder, attr);
				}
			}
		}

		private static bool IsSigned(Assembly asm)
		{
			byte[] key = asm.GetName().GetPublicKey();
			return key != null && key.Length != 0;
		}

		internal static bool IsCoreAssembly(Assembly asm)
		{
			return asm.IsDefined(StaticCompiler.GetRuntimeType("IKVM.Attributes.RemappedClassAttribute"), false);
		}

		private bool CheckCompilingCoreAssembly()
		{
			if (map != null && map.assembly != null && map.assembly.Classes != null)
			{
				foreach (IKVM.Internal.MapXml.Class c in map.assembly.Classes)
				{
					if (c.Shadows != null && c.Name == "java.lang.Object")
					{
						return compilingCoreAssembly = true;
					}
				}
			}
			return false;
		}

		internal static int Compile(string runtimeAssembly, List<CompilerOptions> optionsList)
		{
			try
			{
				if(runtimeAssembly == null)
				{
					// we assume that the runtime is in the same directory as the compiler
					runtimeAssembly = Path.Combine(typeof(CompilerClassLoader).Assembly.Location, ".." + Path.DirectorySeparatorChar + "IKVM.Runtime.dll");
				}
				StaticCompiler.runtimeAssembly = StaticCompiler.LoadFile(runtimeAssembly);
				StaticCompiler.runtimeJniAssembly = StaticCompiler.LoadFile(Path.Combine(StaticCompiler.runtimeAssembly.Location, ".." + Path.DirectorySeparatorChar + "IKVM.Runtime.JNI.dll"));
			}
			catch(FileNotFoundException)
			{
				if(StaticCompiler.runtimeAssembly == null)
				{
					throw new FatalCompilerErrorException(Message.RuntimeNotFound);
				}
				StaticCompiler.IssueMessage(Message.NoJniRuntime);
			}
			Tracer.Info(Tracer.Compiler, "Loaded runtime assembly: {0}", StaticCompiler.runtimeAssembly.FullName);
			bool compilingCoreAssembly = false;
			List<CompilerClassLoader> compilers = new List<CompilerClassLoader>();
			foreach (CompilerOptions options in optionsList)
			{
				CompilerClassLoader compiler = null;
				int rc = CreateCompiler(options, ref compiler, ref compilingCoreAssembly);
				if(rc != 0)
				{
					return rc;
				}
				compilers.Add(compiler);
				if(options.sharedclassloader != null)
				{
					options.sharedclassloader.Add(compiler);
				}
			}
			foreach (CompilerClassLoader compiler1 in compilers)
			{
				foreach (CompilerClassLoader compiler2 in compilers)
				{
					if (compiler1 != compiler2
						&& (compiler1.options.crossReferenceAllPeers || (compiler1.options.peerReferences != null && Array.IndexOf(compiler1.options.peerReferences, compiler2.options.assembly) != -1)))
					{
						compiler1.AddReference(compiler2);
					}
				}
			}
			foreach (CompilerClassLoader compiler in compilers)
			{
				compiler.CompilePass0();
			}
			Dictionary<CompilerClassLoader, Type> mainAssemblyTypes = new Dictionary<CompilerClassLoader, Type>();
			foreach (CompilerClassLoader compiler in compilers)
			{
				if (compiler.options.sharedclassloader != null)
				{
					Type mainAssemblyType;
					if (!mainAssemblyTypes.TryGetValue(compiler.options.sharedclassloader[0], out mainAssemblyType))
					{
						TypeBuilder tb = compiler.options.sharedclassloader[0].GetTypeWrapperFactory().ModuleBuilder.DefineType("__<MainAssembly>", TypeAttributes.NotPublic | TypeAttributes.Abstract | TypeAttributes.SpecialName);
						AttributeHelper.HideFromJava(tb);
						mainAssemblyType = tb.CreateType();
						mainAssemblyTypes.Add(compiler.options.sharedclassloader[0], mainAssemblyType);
					}
					if (compiler.options.sharedclassloader[0] != compiler)
					{
						((AssemblyBuilder)compiler.GetTypeWrapperFactory().ModuleBuilder.Assembly).__AddTypeForwarder(mainAssemblyType);
					}
				}
				compiler.CompilePass1();
			}
			foreach (CompilerClassLoader compiler in compilers)
			{
				compiler.CompilePass2();
			}
			if (compilingCoreAssembly)
			{
				RuntimeHelperTypes.Create(compilers[0]);
				foreach (CompilerClassLoader compiler in compilers)
				{
					compiler.EmitRemappedTypes2ndPass();
				}
			}
			foreach (CompilerClassLoader compiler in compilers)
			{
				int rc = compiler.CompilePass3();
				if (rc != 0)
				{
					return rc;
				}
			}
			Tracer.Info(Tracer.Compiler, "CompilerClassLoader.Save...");
			foreach (CompilerClassLoader compiler in compilers)
			{
				compiler.PrepareSave();
			}
			if (StaticCompiler.errorCount > 0)
			{
				return 1;
			}
			foreach (CompilerClassLoader compiler in compilers)
			{
				compiler.Save();
			}
			return StaticCompiler.errorCount == 0 ? 0 : 1;
		}

		private static int CreateCompiler(CompilerOptions options, ref CompilerClassLoader loader, ref bool compilingCoreAssembly)
		{
			Tracer.Info(Tracer.Compiler, "JVM.Compile path: {0}, assembly: {1}", options.path, options.assembly);
			AssemblyName runtimeAssemblyName = StaticCompiler.runtimeAssembly.GetName();
			bool allReferencesAreStrongNamed = IsSigned(StaticCompiler.runtimeAssembly);
			List<Assembly> references = new List<Assembly>();
			foreach(Assembly reference in options.references ?? new Assembly[0])
			{
				references.Add(reference);
				allReferencesAreStrongNamed &= IsSigned(reference);
				Tracer.Info(Tracer.Compiler, "Loaded reference assembly: {0}", reference.FullName);
				// if it's an IKVM compiled assembly, make sure that it was compiled
				// against same version of the runtime
				foreach(AssemblyName asmref in reference.GetReferencedAssemblies())
				{
					if(asmref.Name == runtimeAssemblyName.Name)
					{
						if(IsSigned(StaticCompiler.runtimeAssembly))
						{
							// TODO we really should support binding redirects here to allow different revisions to be mixed
							if(asmref.FullName != runtimeAssemblyName.FullName)
							{
								throw new FatalCompilerErrorException(Message.RuntimeMismatch, reference.Location, runtimeAssemblyName.FullName, asmref.FullName);
							}
						}
						else
						{
							if(asmref.GetPublicKeyToken() != null && asmref.GetPublicKeyToken().Length != 0)
							{
								throw new FatalCompilerErrorException(Message.RuntimeMismatch, reference.Location, runtimeAssemblyName.FullName, asmref.FullName);
							}
						}
					}
				}
			}
			Tracer.Info(Tracer.Compiler, "Parsing class files");
			// map the class names to jar entries
			Dictionary<string, Jar.Item> h = new Dictionary<string, Jar.Item>();
			List<string> classNames = new List<string>();
			foreach (Jar jar in options.jars)
			{
				if (options.IsResourcesJar(jar))
				{
					continue;
				}
				foreach (Jar.Item item in jar)
				{
					string name = item.Name;
					if (name.EndsWith(".class", StringComparison.Ordinal)
						&& name.Length > 6
						&& name.IndexOf('.') == name.Length - 6)
					{
						string className = name.Substring(0, name.Length - 6).Replace('/', '.');
						if (h.ContainsKey(className))
						{
							StaticCompiler.IssueMessage(Message.DuplicateClassName, className);
							Jar.Item itemRef = h[className];
							if ((options.classesJar != -1 && itemRef.Jar == options.jars[options.classesJar]) || jar != itemRef.Jar)
							{
								// the previous class stays, because it was either in an earlier jar or we're processing the classes.jar
								// which contains the classes loaded from the file system (where the first encountered class wins)
								continue;
							}
							else
							{
								// we have a jar that contains multiple entries with the same name, the last one wins
								h.Remove(className);
								classNames.Remove(className);
							}
						}
						h.Add(className, item);
						classNames.Add(className);
					}
				}
			}

			if (options.assemblyAttributeAnnotations == null)
			{
				// look for "assembly" type that acts as a placeholder for assembly attributes
				Jar.Item assemblyType;
				if (h.TryGetValue("assembly", out assemblyType))
				{
					try
					{
						byte[] buf = assemblyType.GetData();
						ClassFile f = new ClassFile(buf, 0, buf.Length, null, ClassFileParseOptions.None, null);
						// NOTE the "assembly" type in the unnamed package is a magic type
						// that acts as the placeholder for assembly attributes
						if (f.Name == "assembly" && f.Annotations != null)
						{
							options.assemblyAttributeAnnotations = f.Annotations;
							// HACK remove "assembly" type that exists only as a placeholder for assembly attributes
							h.Remove(f.Name);
							assemblyType.Remove();
							StaticCompiler.IssueMessage(Message.LegacyAssemblyAttributesFound);
						}
					}
					catch (ClassFormatError) { }
				}
			}

			// now look for a main method
			if (options.mainClass == null && (options.guessFileKind || options.target != PEFileKinds.Dll))
			{
				foreach (string className in classNames)
				{
					try
					{
						byte[] buf = h[className].GetData();
						ClassFile f = new ClassFile(buf, 0, buf.Length, null, ClassFileParseOptions.None, null);
						if (f.Name == className)
						{
							foreach (ClassFile.Method m in f.Methods)
							{
								if (m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V")
								{
									StaticCompiler.IssueMessage(Message.MainMethodFound, f.Name);
									options.mainClass = f.Name;
									goto break_outer;
								}
							}
						}
					}
					catch (ClassFormatError) { }
				}
			break_outer: ;
			}

			if(options.guessFileKind && options.mainClass == null)
			{
				options.target = PEFileKinds.Dll;
			}

			if(options.target == PEFileKinds.Dll && options.mainClass != null)
			{
				throw new FatalCompilerErrorException(Message.MainClassRequiresExe);
			}

			if(options.target != PEFileKinds.Dll && options.mainClass == null)
			{
				throw new FatalCompilerErrorException(Message.ExeRequiresMainClass);
			}

			if(options.target == PEFileKinds.Dll && options.props.Count != 0)
			{
				throw new FatalCompilerErrorException(Message.PropertiesRequireExe);
			}

			if(options.path == null)
			{
				if(options.target == PEFileKinds.Dll)
				{
					if(options.targetIsModule)
					{
						options.path = IkvmcCompiler.GetFileInfo(options.assembly + ".netmodule");
					}
					else
					{
						options.path = IkvmcCompiler.GetFileInfo(options.assembly + ".dll");
					}
				}
				else
				{
					options.path = IkvmcCompiler.GetFileInfo(options.assembly + ".exe");
				}
				StaticCompiler.IssueMessage(Message.OutputFileIs, options.path.ToString());
			}

			if(options.targetIsModule)
			{
				if(options.classLoader != null)
				{
					throw new FatalCompilerErrorException(Message.ModuleCannotHaveClassLoader);
				}
				// TODO if we're overwriting a user specified assembly name, we need to emit a warning
				options.assembly = options.path.Name;
			}

			Tracer.Info(Tracer.Compiler, "Constructing compiler");
			AssemblyClassLoader[] referencedAssemblies = new AssemblyClassLoader[references.Count];
			for(int i = 0; i < references.Count; i++)
			{
				AssemblyClassLoader acl = AssemblyClassLoader.FromAssembly(references[i]);
				if (Array.IndexOf(referencedAssemblies, acl) != -1)
				{
					StaticCompiler.IssueMessage(options, Message.DuplicateAssemblyReference, acl.MainAssembly.FullName);
				}
				referencedAssemblies[i] = acl;
			}
			loader = new CompilerClassLoader(referencedAssemblies, options, options.path, options.targetIsModule, options.assembly, h, compilingCoreAssembly);
			loader.classesToCompile = new List<string>(h.Keys);
			if(options.remapfile != null)
			{
				Tracer.Info(Tracer.Compiler, "Loading remapped types (1) from {0}", options.remapfile);
				System.Xml.Serialization.XmlSerializer ser = new System.Xml.Serialization.XmlSerializer(typeof(IKVM.Internal.MapXml.Root));
				ser.UnknownElement += new System.Xml.Serialization.XmlElementEventHandler(ser_UnknownElement);
				ser.UnknownAttribute += new System.Xml.Serialization.XmlAttributeEventHandler(ser_UnknownAttribute);
				FileStream fs;
				try
				{
					fs = options.remapfile.OpenRead();
				}
				catch(Exception x)
				{
					throw new FatalCompilerErrorException(Message.ErrorReadingFile, options.remapfile, x.Message);
				}
				try
				{
					XmlTextReader rdr = new XmlTextReader(fs);
					IKVM.Internal.MapXml.Root.xmlReader = rdr;
					IKVM.Internal.MapXml.Root map;
					try
					{
						map = (IKVM.Internal.MapXml.Root)ser.Deserialize(rdr);
					}
					catch(InvalidOperationException x)
					{
						throw new FatalCompilerErrorException(Message.ErrorParsingMapFile, options.remapfile, x.Message);
					}
					if(!loader.ValidateAndSetMap(map))
					{
						return 1;
					}
				}
				finally
				{
					fs.Close();
				}
				if(loader.CheckCompilingCoreAssembly())
				{
					compilingCoreAssembly = true;
					ClassLoaderWrapper.SetBootstrapClassLoader(loader);
				}
			}
			// If we do not yet have a reference to the core assembly and we are not compiling the core assembly,
			// try to find the core assembly by looking at the assemblies that the runtime references
			if(JVM.CoreAssembly == null && !compilingCoreAssembly)
			{
				foreach(AssemblyName name in StaticCompiler.runtimeAssembly.GetReferencedAssemblies())
				{
					Assembly asm = null;
					try
					{
						asm = LoadReferencedAssembly(StaticCompiler.runtimeAssembly.Location + "/../" + name.Name + ".dll");
					}
					catch(FileNotFoundException)
					{
					}
					if(asm != null && IsCoreAssembly(asm))
					{
						AssemblyClassLoader.PreloadExportedAssemblies(asm);
						JVM.CoreAssembly = asm;
						break;
					}
				}
				if(JVM.CoreAssembly == null)
				{
					throw new FatalCompilerErrorException(Message.BootstrapClassesMissing);
				}
				// we need to scan again for remapped types, now that we've loaded the core library
				ClassLoaderWrapper.LoadRemappedTypes();
			}

			if(!compilingCoreAssembly)
			{
				allReferencesAreStrongNamed &= IsSigned(JVM.CoreAssembly);
				loader.AddReference(AssemblyClassLoader.FromAssembly(JVM.CoreAssembly));
			}

			if((options.keyPair != null || options.publicKey != null) && !allReferencesAreStrongNamed)
			{
				throw new FatalCompilerErrorException(Message.StrongNameRequiresStrongNamedRefs);
			}

			if(loader.map != null)
			{
				loader.LoadMapXml();
			}

			if(!compilingCoreAssembly)
			{
				FakeTypes.Load(JVM.CoreAssembly);
			}
			return 0;
		}

		private static Assembly LoadReferencedAssembly(string r)
		{
			Assembly asm = StaticCompiler.LoadFile(r);
			return asm;
		}

		private void CompilePass0()
		{
			if(options.sharedclassloader != null && options.sharedclassloader[0] != this)
			{
				packages = options.sharedclassloader[0].packages;
			}
			else
			{
				packages = new Packages();
			}
		}

		private void CompilePass1()
		{
			Tracer.Info(Tracer.Compiler, "Compiling class files (1)");
			if(CheckCompilingCoreAssembly())
			{
				EmitRemappedTypes();
			}
			// if we're compiling the core class library, generate the "fake" generic types
			// that represent the not-really existing types (i.e. the Java enums that represent .NET enums,
			// the Method interface for delegates and the Annotation annotation for custom attributes)
			if(map != null && CheckCompilingCoreAssembly())
			{
				FakeTypes.Create(GetTypeWrapperFactory().ModuleBuilder, this);
			}
			allwrappers = new List<TypeWrapper>();
			foreach(string s in classesToCompile)
			{
				TypeWrapper wrapper = LoadClassByDottedNameFast(s);
				if(wrapper != null)
				{
					ClassLoaderWrapper loader = wrapper.GetClassLoader();
					if(loader != this)
					{
						if(loader is AssemblyClassLoader)
						{
							StaticCompiler.IssueMessage(options, Message.SkippingReferencedClass, s, ((AssemblyClassLoader)loader).GetAssembly(wrapper).FullName);
						}
						continue;
					}
					if(options.sharedclassloader != null && options.sharedclassloader[0] != this)
					{
						options.sharedclassloader[0].dynamicallyImportedTypes.Add(wrapper);
					}
					allwrappers.Add(wrapper);
				}
			}
		}

		private void CompilePass2()
		{
			Tracer.Info(Tracer.Compiler, "Compiling class files (2)");
			foreach(TypeWrapper tw in allwrappers)
			{
				DynamicTypeWrapper dtw = tw as DynamicTypeWrapper;
				if(dtw != null)
				{
					dtw.CreateStep2();
				}
			}
		}

		private int CompilePass3()
		{
			Tracer.Info(Tracer.Compiler, "Compiling class files (3)");
			if(map != null && CheckCompilingCoreAssembly())
			{
				FakeTypes.Finish(this);
			}
			foreach(string proxy in options.proxies)
			{
				ProxyGenerator.Create(this, proxy);
			}
			if(options.mainClass != null)
			{
				TypeWrapper wrapper = null;
				try
				{
					wrapper = LoadClassByDottedNameFast(options.mainClass);
				}
				catch(RetargetableJavaException)
				{
				}
				if(wrapper == null)
				{
					throw new FatalCompilerErrorException(Message.MainClassNotFound);
				}
				MethodWrapper mw = wrapper.GetMethodWrapper("main", "([Ljava.lang.String;)V", false);
				if(mw == null || !mw.IsStatic)
				{
					throw new FatalCompilerErrorException(Message.MainMethodNotFound);
				}
				mw.Link();
				MethodInfo method = mw.GetMethod() as MethodInfo;
				if(method == null)
				{
					throw new FatalCompilerErrorException(Message.UnsupportedMainMethod);
				}
				if(!ReflectUtil.IsFromAssembly(method.DeclaringType, assemblyBuilder)
					&& (!method.IsPublic || !method.DeclaringType.IsPublic))
				{
					throw new FatalCompilerErrorException(Message.ExternalMainNotAccessible);
				}
				Type apartmentAttributeType = null;
				if(options.apartment == ApartmentState.STA)
				{
					apartmentAttributeType = JVM.Import(typeof(STAThreadAttribute));
				}
				else if(options.apartment == ApartmentState.MTA)
				{
					apartmentAttributeType = JVM.Import(typeof(MTAThreadAttribute));
				}
				SetMain(method, options.target, options.props, options.noglobbing, apartmentAttributeType);
			}
			if(map != null)
			{
				LoadMappedExceptions(map);
				Tracer.Info(Tracer.Compiler, "Loading remapped types (2)");
				try
				{
					FinishRemappedTypes();
				}
				catch (IKVM.Reflection.MissingMemberException x)
				{
					StaticCompiler.IssueMissingTypeMessage((Type)x.MemberInfo);
					return 1;
				}
			}
			Tracer.Info(Tracer.Compiler, "Compiling class files (2)");
			WriteResources();
			if(options.externalResources != null)
			{
				foreach(KeyValuePair<string, string> kv in options.externalResources)
				{
					assemblyBuilder.AddResourceFile(JVM.MangleResourceName(kv.Key), kv.Value);
				}
			}
			if(options.fileversion != null)
			{
				CustomAttributeBuilder filever = new CustomAttributeBuilder(JVM.Import(typeof(System.Reflection.AssemblyFileVersionAttribute)).GetConstructor(new Type[] { Types.String }), new object[] { options.fileversion });
				assemblyBuilder.SetCustomAttribute(filever);
			}
			if(options.assemblyAttributeAnnotations != null)
			{
				foreach(object[] def in options.assemblyAttributeAnnotations)
				{
					Annotation annotation = Annotation.LoadAssemblyCustomAttribute(this, def);
					if(annotation != null)
					{
						annotation.Apply(this, assemblyBuilder, def);
					}
				}
			}
			if(options.classLoader != null)
			{
				TypeWrapper wrapper = null;
				try
				{
					wrapper = LoadClassByDottedNameFast(options.classLoader);
				}
				catch(RetargetableJavaException)
				{
				}
				if(wrapper == null)
				{
					throw new FatalCompilerErrorException(Message.ClassLoaderNotFound);
				}
				if(!wrapper.IsPublic && !ReflectUtil.IsFromAssembly(wrapper.TypeAsBaseType, assemblyBuilder))
				{
					throw new FatalCompilerErrorException(Message.ClassLoaderNotAccessible);
				}
				if(wrapper.IsAbstract)
				{
					throw new FatalCompilerErrorException(Message.ClassLoaderIsAbstract);
				}
				if(!wrapper.IsAssignableTo(ClassLoaderWrapper.LoadClassCritical("java.lang.ClassLoader")))
				{
					throw new FatalCompilerErrorException(Message.ClassLoaderNotClassLoader);
				}
				MethodWrapper mw = wrapper.GetMethodWrapper("<init>", "(Lcli.System.Reflection.Assembly;)V", false);
				if(mw == null)
				{
					throw new FatalCompilerErrorException(Message.ClassLoaderConstructorMissing);
				}
				ConstructorInfo ci = JVM.LoadType(typeof(CustomAssemblyClassLoaderAttribute)).GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { Types.Type }, null);
				assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(ci, new object[] { wrapper.TypeAsTBD }));
				// TODO it would be better to do this for all assemblies in a shared class loader group (because options.classloader is relevant only for the main assembly),
				// but since it is probably common to specify the custom assembly class loader at the group level, it hopefully won't make much difference in practice.
				MethodWrapper mwModuleInit = wrapper.GetMethodWrapper("InitializeModule", "(Lcli.System.Reflection.Module;)V", false);
				if(mwModuleInit != null && !mwModuleInit.IsStatic)
				{
					MethodBuilder moduleInitializer = GetTypeWrapperFactory().ModuleBuilder.DefineGlobalMethod(".cctor", MethodAttributes.Private | MethodAttributes.Static | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName, null, Type.EmptyTypes);
					ILGenerator ilgen = moduleInitializer.GetILGenerator();
					ilgen.Emit(OpCodes.Ldtoken, moduleInitializer);
					ilgen.Emit(OpCodes.Call, JVM.Import(typeof(System.Reflection.MethodBase)).GetMethod("GetMethodFromHandle", new Type[] { JVM.Import(typeof(RuntimeMethodHandle)) }));
					ilgen.Emit(OpCodes.Callvirt, JVM.Import(typeof(System.Reflection.MemberInfo)).GetMethod("get_Module"));
					ilgen.Emit(OpCodes.Call, StaticCompiler.GetRuntimeType("IKVM.Runtime.ByteCodeHelper").GetMethod("InitializeModule"));
					ilgen.Emit(OpCodes.Ret);
				}
			}
			if (options.iconfile != null)
			{
				assemblyBuilder.__DefineIconResource(IkvmcCompiler.ReadAllBytes(options.iconfile));
			}
			if (options.manifestFile != null)
			{
				assemblyBuilder.__DefineManifestResource(IkvmcCompiler.ReadAllBytes(options.manifestFile));
			}
			assemblyBuilder.DefineVersionInfoResource();
			return 0;
		}

		private static void ser_UnknownElement(object sender, System.Xml.Serialization.XmlElementEventArgs e)
		{
			StaticCompiler.IssueMessage(Message.UnknownElementInMapFile, e.Element.Name, e.LineNumber.ToString(), e.LinePosition.ToString());
		}

		private static void ser_UnknownAttribute(object sender, System.Xml.Serialization.XmlAttributeEventArgs e)
		{
			StaticCompiler.IssueMessage(Message.UnknownAttributeInMapFile, e.Attr.Name, e.LineNumber.ToString(), e.LinePosition.ToString());
		}

		private bool ValidateAndSetMap(IKVM.Internal.MapXml.Root map)
		{
			bool valid = true;
			if (map.assembly != null)
			{
				if (map.assembly.Classes != null)
				{
					foreach (IKVM.Internal.MapXml.Class c in map.assembly.Classes)
					{
						if (c.Fields != null)
						{
							foreach (IKVM.Internal.MapXml.Field f in c.Fields)
							{
								ValidateNameSig("field", c.Name, f.Name, f.Sig, ref valid, true);
							}
						}
						if (c.Methods != null)
						{
							foreach (IKVM.Internal.MapXml.Method m in c.Methods)
							{
								ValidateNameSig("method", c.Name, m.Name, m.Sig, ref valid, false);
							}
						}
						if (c.Constructors != null)
						{
							foreach (IKVM.Internal.MapXml.Constructor ctor in c.Constructors)
							{
								ValidateNameSig("constructor", c.Name, "<init>", ctor.Sig, ref valid, false);
							}
						}
						if (c.Properties != null)
						{
							foreach (IKVM.Internal.MapXml.Property prop in c.Properties)
							{
								ValidateNameSig("property", c.Name, prop.Name, prop.Sig, ref valid, false);
								ValidatePropertyGetterSetter("getter", c.Name, prop.Name, prop.getter, ref valid);
								ValidatePropertyGetterSetter("setter", c.Name, prop.Name, prop.setter, ref valid);
							}
						}
					}
				}
			}
			this.map = map;
			return valid;
		}

		private static void ValidateNameSig(string member, string clazz, string name, string sig, ref bool valid, bool field)
		{
			if (!IsValidName(name))
			{
				valid = false;
				StaticCompiler.IssueMessage(Message.InvalidMemberNameInMapFile, member, name, clazz);
			}
			if (!IsValidSig(sig, field))
			{
				valid = false;
				StaticCompiler.IssueMessage(Message.InvalidMemberSignatureInMapFile, member, clazz, name, sig);
			}
		}

		private static void ValidatePropertyGetterSetter(string getterOrSetter, string clazz, string property, IKVM.Internal.MapXml.Method method, ref bool valid)
		{
			if (method != null)
			{
				if (!IsValidName(method.Name))
				{
					valid = false;
					StaticCompiler.IssueMessage(Message.InvalidPropertyNameInMapFile, getterOrSetter, clazz, property, method.Name);
				}
				if (!ClassFile.IsValidMethodSig(method.Sig))
				{
					valid = false;
					StaticCompiler.IssueMessage(Message.InvalidPropertySignatureInMapFile, getterOrSetter, clazz, property, method.Sig);
				}
			}
		}

		private static bool IsValidName(string name)
		{
			return name != null && name.Length != 0;
		}

		private static bool IsValidSig(string sig, bool field)
		{
			return sig != null && (field ? ClassFile.IsValidFieldSig(sig) : ClassFile.IsValidMethodSig(sig));
		}

		internal Type GetTypeFromReferencedAssembly(string name)
		{
			foreach (AssemblyClassLoader acl in referencedAssemblies)
			{
				Type type = acl.MainAssembly.GetType(name, false);
				if (type != null)
				{
					return type;
				}
			}
			return null;
		}

		internal override void IssueMessage(Message msgId, params string[] values)
		{
			StaticCompiler.IssueMessage(options, msgId, values);
		}

		internal bool TryEnableUnmanagedExports()
		{
			// we only support -platform:x86 and -platform:x64
			// (currently IKVM.Reflection doesn't support unmanaged exports for ARM)
			if ((options.imageFileMachine == ImageFileMachine.I386 && (options.pekind & PortableExecutableKinds.Required32Bit) != 0)
				|| options.imageFileMachine == ImageFileMachine.AMD64)
			{
				// when you add unmanaged exports, the ILOnly flag MUST NOT be set or the DLL will fail to load
				options.pekind &= ~PortableExecutableKinds.ILOnly;
				return true;
			}
			else
			{
				StaticCompiler.IssueMessage(options, Message.DllExportRequiresSupportedPlatform);
				return false;
			}
		}

		internal override bool WarningLevelHigh
		{
			get { return options.warningLevelHigh; }
		}

		internal override bool NoParameterReflection
		{
			get { return options.noParameterReflection; }
		}

		protected override void CheckProhibitedPackage(string className)
		{
			if (!compilingCoreAssembly)
			{
				base.CheckProhibitedPackage(className);
			}
		}
	}

	sealed class Jar
	{
		internal readonly string Name;
		internal readonly string Comment;
		private readonly List<JarItem> Items = new List<JarItem>();

		internal Jar(string name, string comment)
		{
			this.Name = name;
			this.Comment = comment;
		}

		internal Jar Copy()
		{
			Jar newJar = new Jar(Name, Comment);
			newJar.Items.AddRange(Items);
			return newJar;
		}

		internal void Add(ZipEntry ze, byte[] data)
		{
			Items.Add(new JarItem(ze, data, null));
		}

		internal void Add(string name, byte[] data, FileInfo fileInfo)
		{
			ZipEntry zipEntry = new ZipEntry(name);
			zipEntry.DateTime = fileInfo.LastWriteTimeUtc;
			zipEntry.CompressionMethod = CompressionMethod.Stored;
			Items.Add(new JarItem(zipEntry, data, fileInfo));
		}

		private struct JarItem
		{
			internal readonly ZipEntry zipEntry;
			internal readonly byte[] data;
			internal readonly FileInfo path;			// path of the original file, if it was individual file (used to construct source file path)

			internal JarItem(ZipEntry zipEntry, byte[] data, FileInfo path)
			{
				this.zipEntry = zipEntry;
				this.data = data;
				this.path = path;
			}
		}

		public struct Item
		{
			internal readonly Jar Jar;
			private readonly int Index;

			internal Item(Jar jar, int index)
			{
				this.Jar = jar;
				this.Index = index;
			}

			internal string Name
			{
				get { return Jar.Items[Index].zipEntry.Name; }
			}

			internal byte[] GetData()
			{
				return Jar.Items[Index].data;
			}

			internal FileInfo Path
			{
				get { return Jar.Items[Index].path; }
			}

			internal ZipEntry ZipEntry
			{
				get
				{
					ZipEntry org = Jar.Items[Index].zipEntry;
					ZipEntry zipEntry = new ZipEntry(org.Name);
					zipEntry.Comment = org.Comment;
					zipEntry.CompressionMethod = org.CompressionMethod;
					zipEntry.DosTime = org.DosTime;
					zipEntry.ExternalFileAttributes = org.ExternalFileAttributes;
					zipEntry.ExtraData = org.ExtraData;
					zipEntry.Flags = org.Flags;
					return zipEntry;
				}
			}

			internal void Remove()
			{
				Jar.Items[Index] = new JarItem();
			}

			internal void MarkAsStub()
			{
				Jar.Items[Index] = new JarItem(Jar.Items[Index].zipEntry, null, null);
			}

			internal bool IsStub
			{
				get { return Jar.Items[Index].data == null; }
			}
		}

		internal struct JarEnumerator
		{
			private readonly Jar jar;
			private int index;

			internal JarEnumerator(Jar jar)
			{
				this.jar = jar;
				this.index = -1;
			}

			public Item Current
			{
				get { return new Item(jar, index); }
			}

			public bool MoveNext()
			{
				while (index + 1 < jar.Items.Count)
				{
					if (jar.Items[++index].zipEntry != null)
					{
						return true;
					}
				}
				return false;
			}
		}

		public JarEnumerator GetEnumerator()
		{
			return new JarEnumerator(this);
		}
	}

	sealed class CompilerOptions
	{
		internal List<Jar> jars = new List<Jar>();
		private Dictionary<string, int> jarMap = new Dictionary<string, int>();
		internal int classesJar = -1;
		internal int resourcesJar = -1;
		internal bool nojarstubs;
		internal FileInfo path;
		internal FileInfo keyfile;
		internal string keycontainer;
		internal bool delaysign;
		internal byte[] publicKey;
		internal StrongNameKeyPair keyPair;
		internal Version version;
		internal string fileversion;
		internal FileInfo iconfile;
		internal FileInfo manifestFile;
		internal bool targetIsModule;
		internal string assembly;
		internal string mainClass;
		internal ApartmentState apartment;
		internal PEFileKinds target;
		internal bool guessFileKind;
		internal string[] unresolvedReferences;	// only used during command line parsing
		internal Dictionary<string, string> legacyStubReferences = new Dictionary<string,string>();	// only used during command line parsing
		internal Assembly[] references;
		internal string[] peerReferences;
		internal bool crossReferenceAllPeers = true;
		internal string[] classesToExclude;		// only used during command line parsing
		internal FileInfo remapfile;
		internal Dictionary<string, string> props;
		internal bool noglobbing;
		internal CodeGenOptions codegenoptions;
		internal bool compressedResources;
		internal string[] privatePackages;
		internal string[] publicPackages;
		internal string sourcepath;
		internal Dictionary<string, string> externalResources;
		internal string classLoader;
		internal PortableExecutableKinds pekind = PortableExecutableKinds.ILOnly;
		internal ImageFileMachine imageFileMachine = ImageFileMachine.I386;
		internal long baseAddress;
		internal int fileAlignment;
		internal bool highentropyva;
		internal List<CompilerClassLoader> sharedclassloader; // should *not* be deep copied in Copy(), because we want the list of all compilers that share a class loader
		internal Dictionary<string, string> suppressWarnings = new Dictionary<string, string>();
		internal Dictionary<string, string> errorWarnings = new Dictionary<string, string>();	// treat specific warnings as errors
		internal bool warnaserror; // treat all warnings as errors
		internal FileInfo writeSuppressWarningsFile;
		internal List<string> proxies = new List<string>();
		internal object[] assemblyAttributeAnnotations;
		internal bool warningLevelHigh;
		internal bool noParameterReflection;

		internal CompilerOptions Copy()
		{
			CompilerOptions copy = (CompilerOptions)MemberwiseClone();
			copy.jars = Copy(jars);
			copy.jarMap = new Dictionary<string, int>(jarMap);
			if (props != null)
			{
				copy.props = new Dictionary<string, string>(props);
			}
			if (externalResources != null)
			{
				copy.externalResources = new Dictionary<string, string>(externalResources);
			}
			copy.suppressWarnings = new Dictionary<string, string>(suppressWarnings);
			copy.errorWarnings = new Dictionary<string, string>(errorWarnings);
			return copy;
		}

		private static List<Jar> Copy(List<Jar> jars)
		{
			List<Jar> newJars = new List<Jar>();
			foreach (Jar jar in jars)
			{
				newJars.Add(jar.Copy());
			}
			return newJars;
		}

		internal Jar GetJar(ZipFile zf)
		{
			int existingJar;
			if (jarMap.TryGetValue(zf.Name, out existingJar))
			{
				return jars[existingJar];
			}
			jarMap.Add(zf.Name, jars.Count);
			return CreateJar(Path.GetFileName(zf.Name), zf.ZipFileComment);
		}

		private Jar CreateJar(string jarName, string comment)
		{
			int count = 0;
			string name = jarName;
		retry:
			foreach (Jar jar in jars)
			{
				if (jar.Name == name)
				{
					name = Path.GetFileNameWithoutExtension(jarName) + "-" + (++count) + Path.GetExtension(jarName);
					goto retry;
				}
			}
			Jar newJar = new Jar(name, comment);
			jars.Add(newJar);
			return newJar;
		}

		internal Jar GetClassesJar()
		{
			if (classesJar == -1)
			{
				classesJar = jars.Count;
				CreateJar("classes.jar", null);
			}
			return jars[classesJar];
		}

		internal bool IsClassesJar(Jar jar)
		{
			return classesJar != -1 && jars[classesJar] == jar;
		}

		internal Jar GetResourcesJar()
		{
			if (resourcesJar == -1)
			{
				resourcesJar = jars.Count;
				CreateJar("resources.jar", null);
			}
			return jars[resourcesJar];
		}

		internal bool IsResourcesJar(Jar jar)
		{
			return resourcesJar != -1 && jars[resourcesJar] == jar;
		}

		internal bool IsExcludedClass(string className)
		{
			if (classesToExclude != null)
			{
				for (int i = 0; i < classesToExclude.Length; i++)
				{
					if (Regex.IsMatch(className, classesToExclude[i]))
					{
						return true;
					}
				}
			}
			return false;
		}
	}

	enum Message
	{
		// These are the informational messages
		MainMethodFound = 1,
		OutputFileIs = 2,
		AutoAddRef = 3,
		MainMethodFromManifest = 4,
		// This is were the warnings start
		StartWarnings = 100,
		ClassNotFound = 100,
		ClassFormatError = 101,
		DuplicateClassName = 102,
		IllegalAccessError = 103,
		VerificationError = 104,
		NoClassDefFoundError = 105,
		GenericUnableToCompileError = 106,
		DuplicateResourceName = 107,
		SkippingReferencedClass = 109,
		NoJniRuntime= 110,
		EmittedNoClassDefFoundError = 111,
		EmittedIllegalAccessError = 112,
		EmittedInstantiationError = 113,
		EmittedIncompatibleClassChangeError = 114,
		EmittedNoSuchFieldError = 115,
		EmittedAbstractMethodError = 116,
		EmittedNoSuchMethodError = 117,
		EmittedLinkageError = 118,
		EmittedVerificationError = 119,
		EmittedClassFormatError = 120,
		InvalidCustomAttribute = 121,
		IgnoredCustomAttribute = 122,
		AssumeAssemblyVersionMatch = 123,
		InvalidDirectoryInLibOptionPath = 124,
		InvalidDirectoryInLibEnvironmentPath = 125,
		LegacySearchRule = 126,
		AssemblyLocationIgnored = 127,
		InterfaceMethodCantBeInternal = 128,
		DllExportMustBeStaticMethod = 129,
		DllExportRequiresSupportedPlatform = 130,
		DuplicateAssemblyReference = 132,
		UnableToResolveType = 133,
		StubsAreDeprecated = 134,
		WrongClassName = 135,
		ReflectionCallerClassRequiresCallerID = 136,
		LegacyAssemblyAttributesFound = 137,
		UnableToCreateLambdaFactory = 138,
		UnknownWarning = 999,
		// This is where the errors start
		StartErrors = 4000,
		UnableToCreateProxy = 4001,
		DuplicateProxy = 4002,
		MapXmlUnableToResolveOpCode = 4003,
		MapXmlError = 4004,
		InputFileNotFound = 4005,
		UnknownFileType = 4006,
		UnknownElementInMapFile = 4007,
		UnknownAttributeInMapFile = 4008,
		InvalidMemberNameInMapFile = 4009,
		InvalidMemberSignatureInMapFile = 4010,
		InvalidPropertyNameInMapFile = 4011,
		InvalidPropertySignatureInMapFile = 4012,
		NonPrimaryAssemblyReference = 4013,
		MissingType = 4014,
		MissingReference = 4015,
		CallerSensitiveOnUnsupportedMethod = 4016,
		RemappedTypeMissingDefaultInterfaceMethod = 4017,
		// Fatal errors
		ResponseFileDepthExceeded = 5000,
		ErrorReadingFile = 5001,
		NoTargetsFound = 5002,
		FileFormatLimitationExceeded = 5003,
		CannotSpecifyBothKeyFileAndContainer = 5004,
		DelaySignRequiresKey = 5005,
		InvalidStrongNameKeyPair = 5006,
		ReferenceNotFound = 5007,
		OptionsMustPreceedChildLevels = 5008,
		UnrecognizedTargetType = 5009,
		UnrecognizedPlatform = 5010,
		UnrecognizedApartment = 5011,
		MissingFileSpecification = 5012,
		PathTooLong = 5013,
		PathNotFound = 5014,
		InvalidPath = 5015,
		InvalidOptionSyntax = 5016,
		ExternalResourceNotFound = 5017,
		ExternalResourceNameInvalid = 5018,
		InvalidVersionFormat = 5019,
		InvalidFileAlignment = 5020,
		ErrorWritingFile = 5021,
		UnrecognizedOption = 5022,
		NoOutputFileSpecified = 5023,
		SharedClassLoaderCannotBeUsedOnModuleTarget = 5024,
		RuntimeNotFound = 5025,
		MainClassRequiresExe = 5026,
		ExeRequiresMainClass = 5027,
		PropertiesRequireExe = 5028,
		ModuleCannotHaveClassLoader = 5029,
		ErrorParsingMapFile = 5030,
		BootstrapClassesMissing = 5031,
		StrongNameRequiresStrongNamedRefs = 5032,
		MainClassNotFound = 5033,
		MainMethodNotFound = 5034,
		UnsupportedMainMethod = 5035,
		ExternalMainNotAccessible = 5036,
		ClassLoaderNotFound = 5037,
		ClassLoaderNotAccessible = 5038,
		ClassLoaderIsAbstract = 5039,
		ClassLoaderNotClassLoader = 5040,
		ClassLoaderConstructorMissing = 5041,
		MapFileTypeNotFound = 5042,
		MapFileClassNotFound = 5043,
		MaximumErrorCountReached = 5044,
		LinkageError = 5045,
		RuntimeMismatch = 5046,
		RuntimeMismatchStrongName = 5047,
		CoreClassesMissing = 5048,
		CriticalClassNotFound = 5049,
		AssemblyContainsDuplicateClassNames = 5050,
		CallerIDRequiresHasCallerIDAnnotation = 5051,
		UnableToResolveInterface = 5052,
		MissingBaseType = 5053,
		MissingBaseTypeReference = 5054,
		FileNotFound = 5055,
		RuntimeMethodMissing = 5056,
		MapFileFieldNotFound = 5057,
		GhostInterfaceMethodMissing = 5058,
	}

	static class StaticCompiler
	{
		private static Universe universe;
		internal static Assembly runtimeAssembly;
		internal static Assembly runtimeJniAssembly;
		internal static CompilerOptions toplevel;
		internal static int errorCount;

		internal static Universe Universe
		{
			get
			{
				Debug.Assert(universe != null);
				return universe;
			}
		}

		internal static void Init(bool nonDeterministicOutput)
		{
			UniverseOptions options = UniverseOptions.ResolveMissingMembers | UniverseOptions.EnableFunctionPointers;
			if (!nonDeterministicOutput)
			{
				options |= UniverseOptions.DeterministicOutput;
			}
			universe = new Universe(options);
			universe.ResolvedMissingMember += ResolvedMissingMember;
		}

		private static void ResolvedMissingMember(Module requestingModule, MemberInfo member)
		{
			if (requestingModule != null && member is Type)
			{
				IssueMessage(Message.UnableToResolveType, requestingModule.Name, ((Type)member).FullName, member.Module.FullyQualifiedName);
			}
		}

		internal static Assembly Load(string assemblyString)
		{
			Assembly asm = Universe.Load(assemblyString);
			if (asm.__IsMissing)
			{
				throw new FileNotFoundException(assemblyString);
			}
			return asm;
		}

		internal static Assembly LoadFile(string path)
		{
			return Universe.LoadFile(path);
		}

		internal static Type GetRuntimeType(string name)
		{
			Type type = runtimeAssembly.GetType(name);
			if (type != null)
			{
				return type;
			}
			if (runtimeJniAssembly != null)
			{
				return runtimeJniAssembly.GetType(name, true);
			}
			else
			{
				throw new TypeLoadException(name);
			}
		}

		internal static Type GetTypeForMapXml(ClassLoaderWrapper loader, string name)
		{
			Type type = GetType(loader, name);
			if (type == null)
			{
				throw new FatalCompilerErrorException(Message.MapFileTypeNotFound, name);
			}
			return type;
		}

		internal static TypeWrapper GetClassForMapXml(ClassLoaderWrapper loader, string name)
		{
			TypeWrapper tw = loader.LoadClassByDottedNameFast(name);
			if (tw == null)
			{
				throw new FatalCompilerErrorException(Message.MapFileClassNotFound, name);
			}
			return tw;
		}

		internal static FieldWrapper GetFieldForMapXml(ClassLoaderWrapper loader, string clazz, string name, string sig)
		{
			FieldWrapper fw = GetClassForMapXml(loader, clazz).GetFieldWrapper(name, sig);
			if (fw == null)
			{
				throw new FatalCompilerErrorException(Message.MapFileFieldNotFound, name, clazz);
			}
			fw.Link();
			return fw;
		}

		internal static Type GetType(ClassLoaderWrapper loader, string name)
		{
			CompilerClassLoader ccl = (CompilerClassLoader)loader;
			return ccl.GetTypeFromReferencedAssembly(name);
		}

		internal static void IssueMessage(Message msgId, params string[] values)
		{
			IssueMessage(toplevel, msgId, values);
		}

		internal static void IssueMessage(CompilerOptions options, Message msgId, params string[] values)
		{
			if (errorCount != 0 && msgId < Message.StartErrors && !options.warnaserror)
			{
				// don't display any warnings after we've emitted an error message
				return;
			}
			string key = ((int)msgId).ToString();
			for (int i = 0; ; i++)
			{
				if (options.suppressWarnings.ContainsKey(key))
				{
					return;
				}
				if (i == values.Length)
				{
					break;
				}
				key += ":" + values[i];
			}
			options.suppressWarnings.Add(key, key);
			if(options.writeSuppressWarningsFile != null)
			{
				File.AppendAllText(options.writeSuppressWarningsFile.FullName, "-nowarn:" + key + Environment.NewLine);
			}
			string msg;
			switch(msgId)
			{
				case Message.MainMethodFound:
					msg = "Found main method in class \"{0}\"";
					break;
				case Message.OutputFileIs:
					msg = "Output file is \"{0}\"";
					break;
				case Message.AutoAddRef:
					msg = "Automatically adding reference to \"{0}\"";
					break;
				case Message.MainMethodFromManifest:
					msg = "Using main class \"{0}\" based on jar manifest";
					break;
				case Message.ClassNotFound:
					msg = "Class \"{0}\" not found";
					break;
				case Message.ClassFormatError:
					msg = "Unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (class format error \"{1}\")";
					break;
				case Message.DuplicateClassName:
					msg = "Duplicate class name: \"{0}\"";
					break;
				case Message.IllegalAccessError:
					msg = "Unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (illegal access error \"{1}\")";
					break;
				case Message.VerificationError:
					msg = "Unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (verification error \"{1}\")";
					break;
				case Message.NoClassDefFoundError:
					msg = "Unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (missing class \"{1}\")";
					break;
				case Message.GenericUnableToCompileError:
					msg = "Unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (\"{1}\": \"{2}\")";
					break;
				case Message.DuplicateResourceName:
					msg = "Skipping resource (name clash): \"{0}\"";
					break;
				case Message.SkippingReferencedClass:
					msg = "Skipping class: \"{0}\"" + Environment.NewLine +
						"    (class is already available in referenced assembly \"{1}\")";
					break;
				case Message.NoJniRuntime:
					msg = "Unable to load runtime JNI assembly";
					break;
				case Message.EmittedNoClassDefFoundError:
					msg = "Emitted java.lang.NoClassDefFoundError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.EmittedIllegalAccessError:
					msg = "Emitted java.lang.IllegalAccessError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.EmittedInstantiationError:
					msg = "Emitted java.lang.InstantiationError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.EmittedIncompatibleClassChangeError:
					msg = "Emitted java.lang.IncompatibleClassChangeError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.EmittedNoSuchFieldError:
					msg = "Emitted java.lang.NoSuchFieldError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.EmittedAbstractMethodError:
					msg = "Emitted java.lang.AbstractMethodError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.EmittedNoSuchMethodError:
					msg = "Emitted java.lang.NoSuchMethodError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.EmittedLinkageError:
					msg = "Emitted java.lang.LinkageError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.EmittedVerificationError:
					msg = "Emitted java.lang.VerificationError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.EmittedClassFormatError:
					msg = "Emitted java.lang.ClassFormatError in \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.InvalidCustomAttribute:
					msg = "Error emitting \"{0}\" custom attribute" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.IgnoredCustomAttribute:
					msg = "Custom attribute \"{0}\" was ignored" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.AssumeAssemblyVersionMatch:
					msg = "Assuming assembly reference \"{0}\" matches \"{1}\", you may need to supply runtime policy";
					break;
				case Message.InvalidDirectoryInLibOptionPath:
					msg = "Directory \"{0}\" specified in -lib option is not valid";
					break;
				case Message.InvalidDirectoryInLibEnvironmentPath:
					msg = "Directory \"{0}\" specified in LIB environment is not valid";
					break;
				case Message.LegacySearchRule:
					msg = "Found assembly \"{0}\" using legacy search rule, please append '.dll' to the reference";
					break;
				case Message.AssemblyLocationIgnored:
					msg = "Assembly \"{0}\" is ignored as previously loaded assembly \"{1}\" has the same identity \"{2}\"";
					break;
				case Message.InterfaceMethodCantBeInternal:
					msg = "Ignoring @@ikvm.lang.Internal annotation on interface method" + Environment.NewLine +
						"    (\"{0}.{1}{2}\")";
					break;
				case Message.DllExportMustBeStaticMethod:
					msg = "Ignoring @@ikvm.lang.DllExport annotation on non-static method" + Environment.NewLine +
						"    (\"{0}.{1}{2}\")";
					break;
				case Message.DllExportRequiresSupportedPlatform:
					msg = "Ignoring @@ikvm.lang.DllExport annotation due to unsupported target platform";
					break;
				case Message.NonPrimaryAssemblyReference:
					msg = "Referenced assembly \"{0}\" is not the primary assembly of a shared class loader group, please reference primary assembly \"{1}\" instead";
					break;
				case Message.MissingType:
					msg = "Reference to type \"{0}\" claims it is defined in \"{1}\", but it could not be found";
					break;
				case Message.MissingReference:
					msg = "The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'";
					break;
				case Message.DuplicateAssemblyReference:
					msg = "Duplicate assembly reference \"{0}\"";
					break;
				case Message.UnableToResolveType:
					msg = "Reference in \"{0}\" to type \"{1}\" claims it is defined in \"{2}\", but it could not be found";
					break;
				case Message.StubsAreDeprecated:
					msg = "Compiling stubs is deprecated. Please add a reference to assembly \"{0}\" instead.";
					break;
				case Message.WrongClassName:
					msg = "Unable to compile \"{0}\" (wrong name: \"{1}\")";
					break;
				case Message.ReflectionCallerClassRequiresCallerID:
					msg = "Reflection.getCallerClass() called from non-CallerID method" + Environment.NewLine +
						"    (\"{0}.{1}{2}\")";
					break;
				case Message.LegacyAssemblyAttributesFound:
					msg = "Legacy assembly attributes container found. Please use the -assemblyattributes:<file> option.";
					break;
				case Message.UnableToCreateLambdaFactory:
					msg = "Unable to create static lambda factory.";
					break;
				case Message.UnableToCreateProxy:
					msg = "Unable to create proxy \"{0}\"" + Environment.NewLine +
						"    (\"{1}\")";
					break;
				case Message.DuplicateProxy:
					msg = "Duplicate proxy \"{0}\"";
					break;
				case Message.MapXmlUnableToResolveOpCode:
					msg = "Unable to resolve opcode in remap file: {0}";
					break;
				case Message.MapXmlError:
					msg = "Error in remap file: {0}";
					break;
				case Message.InputFileNotFound:
					msg = "Source file '{0}' not found";
					break;
				case Message.UnknownFileType:
					msg = "Unknown file type: {0}";
					break;
				case Message.UnknownElementInMapFile:
					msg = "Unknown element {0} in remap file, line {1}, column {2}";
					break;
				case Message.UnknownAttributeInMapFile:
					msg = "Unknown attribute {0} in remap file, line {1}, column {2}";
					break;
				case Message.InvalidMemberNameInMapFile:
					msg = "Invalid {0} name '{1}' in remap file in class {2}";
					break;
				case Message.InvalidMemberSignatureInMapFile:
					msg = "Invalid {0} signature '{3}' in remap file for {0} {1}.{2}";
					break;
				case Message.InvalidPropertyNameInMapFile:
					msg = "Invalid property {0} name '{3}' in remap file for property {1}.{2}";
					break;
				case Message.InvalidPropertySignatureInMapFile:
					msg = "Invalid property {0} signature '{3}' in remap file for property {1}.{2}";
					break;
				case Message.UnknownWarning:
					msg = "{0}";
					break;
				case Message.CallerSensitiveOnUnsupportedMethod:
					msg = "CallerSensitive annotation on unsupported method" + Environment.NewLine +
						"    (\"{0}.{1}{2}\")";
					break;
				case Message.RemappedTypeMissingDefaultInterfaceMethod:
					msg = "{0} does not implement default interface method {1}";
					break;
				default:
					throw new InvalidProgramException();
			}
			bool error = msgId >= Message.StartErrors
				|| (options.warnaserror && msgId >= Message.StartWarnings)
				|| options.errorWarnings.ContainsKey(key)
				|| options.errorWarnings.ContainsKey(((int)msgId).ToString());
			Console.Error.Write("{0} IKVMC{1:D4}: ", error ? "error" : msgId < Message.StartWarnings ? "note" : "warning", (int)msgId);
			if (error && Message.StartWarnings <= msgId && msgId < Message.StartErrors)
			{
				Console.Error.Write("Warning as Error: ");
			}
			Console.Error.WriteLine(msg, values);
			if(options != toplevel && options.path != null)
			{
				Console.Error.WriteLine("    (in {0})", options.path);
			}
			if(error)
			{
				if (++errorCount == 100)
				{
					throw new FatalCompilerErrorException(Message.MaximumErrorCountReached);
				}
			}
		}

		internal static void LinkageError(string msg, TypeWrapper actualType, TypeWrapper expectedType, params object[] values)
		{
			object[] args = new object[values.Length + 2];
			values.CopyTo(args, 2);
			args[0] = AssemblyQualifiedName(actualType);
			args[1] = AssemblyQualifiedName(expectedType);
			string str = string.Format(msg, args);
			if (actualType is UnloadableTypeWrapper && (expectedType is CompiledTypeWrapper || expectedType is DotNetTypeWrapper))
			{
				str += string.Format("\n\t(Please add a reference to {0})", expectedType.TypeAsBaseType.Assembly.Location);
			}
			throw new FatalCompilerErrorException(Message.LinkageError, str);
		}

		private static string AssemblyQualifiedName(TypeWrapper tw)
		{
			ClassLoaderWrapper loader = tw.GetClassLoader();
			AssemblyClassLoader acl = loader as AssemblyClassLoader;
			if(acl != null)
			{
				return tw.Name + ", " + acl.GetAssembly(tw).FullName;
			}
			CompilerClassLoader ccl = loader as CompilerClassLoader;
			if(ccl != null)
			{
				return tw.Name + ", " + ccl.GetTypeWrapperFactory().ModuleBuilder.Assembly.FullName;
			}
			return tw.Name + " (unknown assembly)";
		}

		internal static void IssueMissingTypeMessage(Type type)
		{
			type = ReflectUtil.GetMissingType(type);
			StaticCompiler.IssueMessage(type.Assembly.__IsMissing ? Message.MissingReference : Message.MissingType, type.FullName, type.Assembly.FullName);
		}

		internal static void SuppressWarning(CompilerOptions options, Message message, string name)
		{
			options.suppressWarnings[(int)message + ":" + name] = null;
		}
	}

	sealed class Packages
	{
		private readonly List<string> packages = new List<string>();
		private readonly Dictionary<string, string> packagesSet = new Dictionary<string, string>();

		internal void DefinePackage(string packageName, string jar)
		{
			if (!packagesSet.ContainsKey(packageName))
			{
				packages.Add(packageName);
				packagesSet.Add(packageName, jar);
			}
		}

		// returns an array of PackageListAttribute constructor argument arrays
		internal object[][] ToArray()
		{
			List<object[]> list = new List<object[]>();
			// we use an empty string to indicate we don't yet have a jar,
			// because null is used for packages that were defined from
			// the file system (i.e. don't have a jar to load a manifest from)
			string currentJar = "";
			List<string> currentList = new List<string>();
			foreach (string package in packages)
			{
				string jar = packagesSet[package];
				if (jar != currentJar)
				{
					if (currentList.Count != 0)
					{
						list.Add(new object[] { currentJar, currentList.ToArray() });
						currentList.Clear();
					}
					currentJar = jar;
				}
				currentList.Add(package);
			}
			if (currentList.Count != 0)
			{
				list.Add(new object[] { currentJar, currentList.ToArray() });
			}
			return list.ToArray();
		}
	}
}
@


1.279
log
@Bug fix. Added missing methods to String (chars() and codePoints()).
@
text
@d3755 1
a3755 1
		internal static void Init(bool emitSymbols)
d3758 1
a3758 1
			if (!emitSymbols)
@


1.278
log
@Moved unused field removal optimization to a later stage in the compilation. Also made the check more strict to only remove final fields and not remove fields that have annotations.
@
text
@d986 13
a998 1
						interfaceWrappers[i] = classLoader.LoadClassByDottedName(c.Interfaces[i].Name);
d3675 1
d4073 3
@


1.277
log
@Made TypeWrapper.[Interfaces|InnerClasses|DeclaringTypeWrapper|Finish] non-abstract to implement common behavior.
@
text
@a296 4
					if(options.removeUnusedFields)
					{
						f.RemoveUnusedFields();
					}
a3473 1
		internal bool removeUnusedFields;
@


1.276
log
@Fixed regression introduced in previous change. Untangled TypeWrapper finishing from linking.
@
text
@a2090 21
			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
				{
					// at the moment we don't support nested remapped types
					return null;
				}
			}

			internal override void Finish()
			{
			}

			internal override TypeWrapper[] InnerClasses
			{
				get
				{
					return TypeWrapper.EmptyArray;
				}
			}

@


1.275
log
@Removed sig decoding methods with implicit LoadMode.
@
text
@a2101 16
				if(BaseTypeWrapper != null)
				{
					BaseTypeWrapper.Finish();
				}
				foreach(TypeWrapper iface in Interfaces)
				{
					iface.Finish();
				}
				foreach(MethodWrapper m in GetMethods())
				{
					m.Link();
				}
				foreach(FieldWrapper f in GetFields())
				{
					f.Link();
				}
@


1.274
log
@Minor class loading refactoring.
@
text
@d1293 1
a1293 1
							helper = typeWrapper.helperTypeBuilder.DefineMethod(m.Name, MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsSignatureType, argTypes);
d1337 1
a1337 1
						Type retType = typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsSignatureType;
d1809 1
a1809 1
							FieldBuilder fb = tb.DefineField(f.Name, GetClassLoader().FieldTypeWrapperFromSig(f.Sig).TypeAsSignatureType, attr);
d1830 1
a1830 1
								fields.Add(new ConstantFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, fb, constant, MemberFlags.None));
d1834 1
a1834 1
								fields.Add(FieldWrapper.Create(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), fb, f.Name, f.Sig, new ExModifiers((Modifiers)f.Modifiers, false)));
@


1.273
log
@The zip file timestamp is in local time, but for deterministic builds we don't want to depend on system timezone, so we have to store the UTC time.
@
text
@d184 1
a184 1
		protected override TypeWrapper LoadClassImpl(string name, bool throwClassNotFoundException)
d233 1
a233 1
			return FindOrLoadGenericClass(name, false);
@


1.272
log
@Enable UniverseOptions.DeterministicOutput for ikvmc (unless -debug option is used).
@
text
@d3370 1
a3370 1
			zipEntry.DateTime = fileInfo.LastWriteTime;
@


1.271
log
@Use the last write time of the input file for resources read from the file system.
@
text
@d3769 1
a3769 1
		internal static readonly Universe Universe = new Universe(UniverseOptions.ResolveMissingMembers | UniverseOptions.EnableFunctionPointers);
d3775 1
a3775 1
		static StaticCompiler()
d3777 16
a3792 1
			Universe.ResolvedMissingMember += ResolvedMissingMember;
@


1.270
log
@Added intrinsic for LambdaMetafactory.metafactory().
@
text
@d3370 1
@


1.269
log
@Bug fix. Only the bootstrap class loader is allowed to define classes in the java package.
@
text
@d3684 1
d4039 3
@


1.268
log
@Bug fix. Handle malformed UTF-16 (invalid surrogates) in type/member names and annotations.
@
text
@d74 1
d76 1
a76 1
		internal CompilerClassLoader(AssemblyClassLoader[] referencedAssemblies, CompilerOptions options, FileInfo assemblyPath, bool targetIsModule, string assemblyName, Dictionary<string, Jar.Item> classes)
d86 1
d2571 1
a2571 1
						return true;
d2875 1
a2875 1
			loader = new CompilerClassLoader(referencedAssemblies, options, options.path, options.targetIsModule, options.assembly, h);
d3333 8
@


1.267
log
@Added (undocumented) -noparameterreflection option ikvmc to disable emitting method parameter reflection metadata, because we want to javac compile core class library with the -parameters option (to get the parameter names of native and abstract methods), but we don't want the reflection info (because the JDK doesn't include it either).
@
text
@d566 1
d630 1
@


1.266
log
@Fixed PackageListAttribute to be ECMA compliant.
@
text
@d3324 5
d3522 1
@


1.265
log
@Fixed handling of ghost array types in remapped type methods.
@
text
@d563 5
a567 2
				string[][] list = packages.ToArray();
				mb.SetCustomAttribute(new CustomAttributeBuilder(JVM.LoadType(typeof(PackageListAttribute)).GetConstructor(new Type[] { JVM.Import(typeof(string[][])) }), new object[] { list }));
d4146 2
a4147 2
		// see PackageListAttribute for the structure of this array
		internal string[][] ToArray()
d4149 1
a4149 1
			List<string[]> list = new List<string[]>();
d4162 1
a4162 1
						list.Add(currentList.ToArray());
a4164 1
					currentList.Add(jar);
d4171 1
a4171 1
				list.Add(currentList.ToArray());
@


1.264
log
@Added (undocumented) -w4 option to ikvmc to always warn about missing classes.
@
text
@d1387 1
a1387 1
							mbCore = typeWrapper.typeBuilder.DefineMethod(m.Name, attr, CallingConventions.Standard, retType, paramTypes);
@


1.263
log
@Bug fix. If ikvmc -warnaserror is used, "warnings" should not be suppressed after an error was emitted.
@
text
@d3316 5
d3513 1
@


1.262
log
@Emit proper error when remapped type doesn't implement interface method.
@
text
@d3835 1
a3835 1
			if (errorCount != 0 && msgId < Message.StartErrors)
@


1.261
log
@Added ikvmc option -assemblyattributes:<file> to explicitly specify the assembly attribute container class and deprecated the previous behavior.
@
text
@d3735 1
@


1.260
log
@Fixed ikvmc to emit fatal error instead of crashing when a field referenced in remap file isn't found.
@
text
@a66 1
		private List<object> assemblyAnnotations;
a2713 1
			List<object> assemblyAnnotations = new List<object>();
d2755 1
a2755 3
			// look for "assembly" type that acts as a placeholder for assembly attributes
			Jar.Item assemblyType;
			if (h.TryGetValue("assembly", out assemblyType))
d2757 3
a2759 1
				try
d2761 14
a2774 10
					byte[] buf = assemblyType.GetData();
					ClassFile f = new ClassFile(buf, 0, buf.Length, null, ClassFileParseOptions.None, null);
					// NOTE the "assembly" type in the unnamed package is a magic type
					// that acts as the placeholder for assembly attributes
					if (f.Name == "assembly" && f.Annotations != null)
					{
						assemblyAnnotations.AddRange(f.Annotations);
						// HACK remove "assembly" type that exists only as a placeholder for assembly attributes
						h.Remove(f.Name);
						assemblyType.Remove();
d2776 1
a2777 1
				catch (ClassFormatError) { }
a2868 1
			loader.assemblyAnnotations = assemblyAnnotations;
d3114 1
a3114 1
			foreach(object[] def in assemblyAnnotations)
d3116 1
a3116 2
				Annotation annotation = Annotation.LoadAssemblyCustomAttribute(this, def);
				if(annotation != null)
d3118 5
a3122 1
					annotation.Apply(this, assemblyBuilder, def);
d3507 1
d3656 1
d4007 3
@


1.259
log
@Centralized switches to control C# interop workarounds.
@
text
@d3728 1
d3804 11
@


1.258
log
@Bug fix. Non-public annotations can be used used in code that doesn't have access to them. Implemented that by switching to DynamicAnnotationAttribute when the annotation isn't accessible.
@
text
@d1853 1
a1853 1
					MethodBuilder cb = ReflectUtil.DefineTypeInitializer(typeBuilder);
@


1.257
log
@Added support for getting package information from the right jar manifest for ikvmc compiled jars.
@
text
@d3115 1
a3115 1
				Annotation annotation = Annotation.Load(this, def);
@


1.256
log
@Added Unsafe.defineAnonymousClass().
@
text
@d58 1
a58 1
		private Dictionary<string, string> packages;
d365 6
d564 2
a565 3
				string[] list = new string[packages.Count];
				packages.Keys.CopyTo(list, 0);
				mb.SetCustomAttribute(new CustomAttributeBuilder(JVM.LoadType(typeof(PackageListAttribute)).GetConstructor(new Type[] { JVM.Import(typeof(string[])) }), new object[] { list }));
d2620 4
d2970 12
a2995 8
			if(options.sharedclassloader != null && options.sharedclassloader[0] != this)
			{
				packages = options.sharedclassloader[0].packages;
			}
			else
			{
				packages = new Dictionary<string, string>();
			}
a3010 5
					int pos = wrapper.Name.LastIndexOf('.');
					if(pos != -1)
					{
						packages[wrapper.Name.Substring(0, pos)] = "";
					}
d3571 5
d4100 46
@


1.255
log
@Moved ClassFileParseOptions into ClassLoaderWrapper.
@
text
@d282 1
a282 1
						f = new ClassFile(buf, 0, buf.Length, name, ClassFileParseOptions);
d2755 1
a2755 1
					ClassFile f = new ClassFile(buf, 0, buf.Length, null, ClassFileParseOptions.None);
d2777 1
a2777 1
						ClassFile f = new ClassFile(buf, 0, buf.Length, null, ClassFileParseOptions.None);
@


1.254
log
@Refactored ikvmc -exclude: handling to allow -resource: to add .class files as resources.
@
text
@a280 5
						ClassFileParseOptions cfp = ClassFileParseOptions.LocalVariableTable;
						if(this.EmitStackTraceInfo)
						{
							cfp |= ClassFileParseOptions.LineNumberTable;
						}
d282 1
a282 1
						f = new ClassFile(buf, 0, buf.Length, name, cfp);
@


1.253
log
@Make all byte code helper methods available during in first-pass version of IKVM.Runtime.dll and changed compiler to check that all methods are available.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
d2718 4
d2730 1
a2730 1
						if (options.IsExcludedClass(className))
d2732 9
a2740 6
							// we don't compile the class and we also don't include it as a resource
							item.Remove();
						}
						else
						{
							if (h.ContainsKey(className))
d2742 3
a2744 14
								StaticCompiler.IssueMessage(Message.DuplicateClassName, className);
								Jar.Item itemRef = h[className];
								if ((options.classesJar != -1 && itemRef.Jar == options.jars[options.classesJar]) || jar != itemRef.Jar)
								{
									// the previous class stays, because it was either in an earlier jar or we're processing the classes.jar
									// which contains the classes loaded from the file system (where the first encountered class wins)
									continue;
								}
								else
								{
									// we have a jar that contains multiple entries with the same name, the last one wins
									h.Remove(className);
									classNames.Remove(className);
								}
a2745 2
							h.Add(className, item);
							classNames.Add(className);
d2747 2
d3477 1
a3477 1
		internal string[] classesToExclude;
d3578 5
d3585 1
a3585 1
			for (int i = 0; i < classesToExclude.Length; i++)
d3587 1
a3587 1
				if (Regex.IsMatch(className, classesToExclude[i]))
d3589 4
a3592 1
					return true;
@


1.252
log
@Switched from @@HasCallerID to @@CallerSensitive and merged CallerSenstive related 7u40 changes.
@
text
@d3715 1
@


1.251
log
@Handle signatures with function pointer types in ikvmc and ikvmstub.
@
text
@d3638 1
d3657 1
d3972 4
d4016 4
@


1.250
log
@If ikvmc -static option is used, don't add the InternalsVisibleTo("...-ikvm-runtime-injected") attribute.
@
text
@d3717 1
a3717 1
		internal static readonly Universe Universe = new Universe(UniverseOptions.ResolveMissingMembers);
@


1.249
log
@Introduced ArrayUtil.Concat() methods.
@
text
@d171 4
a174 1
			AttributeHelper.SetInternalsVisibleToAttribute(assemblyBuilder, mainAssemblyName + DynamicClassLoader.DynamicAssemblySuffixAndPublicKey);
@


1.248
log
@Encapsulated the "jar" handling better.
@
text
@d101 1
a101 4
			AssemblyClassLoader[] temp = new AssemblyClassLoader[referencedAssemblies.Length + 1];
			Array.Copy(referencedAssemblies, 0, temp, 0, referencedAssemblies.Length);
			temp[temp.Length - 1] = acl;
			referencedAssemblies = temp;
d1278 1
a1278 4
							Type[] temp = typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig);
							Type[] argTypes = new Type[temp.Length + 1];
							temp.CopyTo(argTypes, 1);
							argTypes[0] = typeWrapper.shadowType;
d1416 1
a1416 4
							Type[] exParamTypes = new Type[paramTypes.Length + 1];
							Array.Copy(paramTypes, 0, exParamTypes, 1, paramTypes.Length);
							exParamTypes[0] = typeWrapper.shadowType;
							mbHelper = typeWrapper.typeBuilder.DefineMethod("instancehelper_" + m.Name, attr, CallingConventions.Standard, retType, exParamTypes);
d1668 2
a1669 4
						Type[] argTypes = new Type[paramTypes.Length + 1];
						argTypes[0] = typeWrapper.TypeAsSignatureType;
						this.GetParametersForDefineMethod().CopyTo(argTypes, 1);
						MethodBuilder mb = typeWrapper.typeBuilder.DefineMethod("nonvirtualhelper/" + this.Name, MethodAttributes.Private | MethodAttributes.Static, this.ReturnTypeForDefineMethod, argTypes);
@


1.247
log
@Removed "effectively final" optimization because it breaks the ability to dynamically load subclasses.
@
text
@d47 1
a47 1
		private Dictionary<string, JarItemReference> classes;
d76 1
a76 1
		internal CompilerClassLoader(AssemblyClassLoader[] referencedAssemblies, CompilerOptions options, FileInfo assemblyPath, bool targetIsModule, string assemblyName, Dictionary<string, JarItemReference> classes)
d274 1
a274 1
				JarItemReference itemRef;
a277 1
					JarItem classdef = itemRef.Jar.Items[itemRef.Index];
d286 2
a287 1
						f = new ClassFile(classdef.data, 0, classdef.data.Length, name, cfp);
d334 2
a335 1
						if(classdef.path != null)
d337 1
a337 1
							string sourceFile = Path.GetFullPath(Path.Combine(classdef.path.DirectoryName, f.SourceFileAttribute));
d362 8
a369 3
						itemRef.Jar.Items[itemRef.Index] = options.nojarstubs
							? new JarItem()	// null entry
							: new JarItem(itemRef.Jar.Items[itemRef.Index].zipEntry, null, null); // create a stub class pseudo resource
d684 1
a684 1
							foreach (JarItem item in jar.Items)
d686 1
a686 1
								if (item.zipEntry != null && item.data != null)
d688 1
a688 1
									AddExportMapEntry(exportedNamesPerAssembly, ccl, item.zipEntry.Name);
d746 1
a746 1
					foreach (JarItem item in options.jars[i].Items)
d748 1
a748 5
						if (item.zipEntry == null)
						{
							continue;
						}
						if (item.data == null)
d753 1
a753 1
								stubs.Add(item.zipEntry.Name);
d757 1
a757 7
						ZipEntry zipEntry = new ZipEntry(item.zipEntry.Name);
						zipEntry.Comment = item.zipEntry.Comment;
						zipEntry.CompressionMethod = item.zipEntry.CompressionMethod;
						zipEntry.DosTime = item.zipEntry.DosTime;
						zipEntry.ExternalFileAttributes = item.zipEntry.ExternalFileAttributes;
						zipEntry.ExtraData = item.zipEntry.ExtraData;
						zipEntry.Flags = item.zipEntry.Flags;
d763 2
a764 1
						zip.Write(item.data, 0, item.data.Length);
d2722 1
a2722 1
			Dictionary<string, JarItemReference> h = new Dictionary<string, JarItemReference>();
d2726 1
a2726 1
				for (int i = 0; i < jar.Items.Count; i++)
d2728 1
a2728 1
					string name = jar.Items[i].zipEntry.Name;
d2737 1
a2737 1
							jar.Items[i] = new JarItem();
d2744 1
a2744 1
								JarItemReference itemRef = h[className];
d2758 1
a2758 1
							h.Add(className, new JarItemReference(jar, i));
d2766 1
a2766 1
			JarItemReference assemblyType;
d2771 1
a2771 1
					byte[] buf = assemblyType.Jar.Items[assemblyType.Index].data;
d2780 1
a2780 1
						assemblyType.Jar.Items[assemblyType.Index] = new JarItem();
d2793 1
a2793 2
						JarItemReference itemRef = h[className];
						byte[] buf = itemRef.Jar.Items[itemRef.Index].data;
d3327 1
a3327 1
		internal readonly List<JarItem> Items = new List<JarItem>();
a3352 1
	}
d3354 70
a3423 11
	struct JarItem
	{
		internal readonly ZipEntry zipEntry;
		internal readonly byte[] data;
		internal readonly FileInfo path;			// path of the original file, if it was individual file (used to construct source file path)

		internal JarItem(ZipEntry zipEntry, byte[] data, FileInfo path)
		{
			this.zipEntry = zipEntry;
			this.data = data;
			this.path = path;
a3424 1
	}
d3426 28
a3453 4
	struct JarItemReference
	{
		internal readonly Jar Jar;
		internal readonly int Index;
d3455 1
a3455 1
		internal JarItemReference(Jar jar, int index)
d3457 1
a3457 2
			this.Jar = jar;
			this.Index = index;
@


1.246
log
@Changed AssemblyClassLoader.FindLoadedClassImpl() to return generic types.
@
text
@a65 1
		private Dictionary<string, string> baseClasses;
a331 11
					if(!f.IsInterface
						&& !f.IsAbstract
						&& !f.IsPublic
						&& !f.IsInternal
						&& !f.IsFinal
						&& !baseClasses.ContainsKey(f.Name)
						&& !options.targetIsModule
						&& options.sharedclassloader == null)
					{
						f.SetEffectivelyFinal();
					}
d2767 4
a2770 4
			// now process all the classes to record the classes that are used as base classes and
			// to look for assembly attribute annotations and the main method
			Dictionary<string, string> baseClasses = new Dictionary<string, string>();
			foreach (string className in classNames)
d2774 1
a2774 2
					JarItemReference itemRef = h[className];
					byte[] buf = itemRef.Jar.Items[itemRef.Index].data;
a2775 4
					if (!f.IsInterface && f.SuperClass != null)
					{
						baseClasses[f.SuperClass] = f.SuperClass;
					}
d2778 1
a2778 1
					if (className == f.Name && f.Name == "assembly" && f.Annotations != null)
d2783 1
a2783 2
						itemRef.Jar.Items[itemRef.Index] = new JarItem();
						continue;
d2785 10
a2794 1
					if (options.mainClass == null && (options.guessFileKind || options.target != PEFileKinds.Dll))
d2796 4
a2799 1
						foreach (ClassFile.Method m in f.Methods)
d2801 1
a2801 1
							if (m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V")
d2803 6
a2808 3
								StaticCompiler.IssueMessage(Message.MainMethodFound, f.Name);
								options.mainClass = f.Name;
								break;
d2812 1
d2814 1
a2814 3
				catch (ClassFormatError)
				{
				}
a2878 1
			loader.baseClasses = baseClasses;
@


1.245
log
@Removed the special casing of generic type definition loading as we've since exposed the generic type definitions to Java.
@
text
@d233 1
a233 1
			return LoadGenericClass(name);
@


1.244
log
@Renamed ClassLoaderWrapper.GetLoadedClass() to FindLoadedClass().
@
text
@a411 13
		internal override Type GetGenericTypeDefinition(string name)
		{
			foreach(AssemblyClassLoader loader in referencedAssemblies)
			{
				Type type = loader.GetGenericTypeDefinition(name);
				if(type != null)
				{
					return type;
				}
			}
			return null;
		}

@


1.243
log
@Emit a warning if a remapped type duplicates a loaded class.
@
text
@d228 1
a228 1
			tw1 = GetLoadedClass(name);
d240 1
a240 1
			if(classes.ContainsKey(name) || remapped.ContainsKey(name) || GetLoadedClass(name) != null)
d2520 1
a2520 1
					TypeWrapper typeWrapper = GetLoadedClass(c.Name);
d2523 1
a2523 1
						TypeWrapper ifaceWrapper = GetLoadedClass(iface.Name);
@


1.242
log
@- Don't call EmitRemappedTypes2ndPass() unless we're compiling the core assemblies.
- Removed redundant casts.
@
text
@d2224 4
@


1.241
log
@Copy zip file comment.
@
text
@d2252 1
a2252 1
						RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)remapped[c.Name];
d2260 1
a2260 1
						RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)remapped[c.Name];
d2679 4
a2682 4
			}
			foreach (CompilerClassLoader compiler in compilers)
			{
				compiler.EmitRemappedTypes2ndPass();
@


1.240
log
@Corrected indentation.
@
text
@d759 4
d3344 1
d3347 1
a3347 1
		internal Jar(string name)
d3350 1
d3355 1
a3355 1
			Jar newJar = new Jar(Name);
d3479 1
a3479 1
		internal Jar GetJar(string path)
d3482 1
a3482 1
			if (jarMap.TryGetValue(path, out existingJar))
d3486 2
a3487 2
			jarMap.Add(path, jars.Count);
			return CreateJar(Path.GetFileName(path));
d3490 1
a3490 1
		private Jar CreateJar(string jarName)
d3503 1
a3503 1
			Jar newJar = new Jar(name);
d3513 1
a3513 1
				CreateJar("classes.jar");
d3523 1
a3523 1
				CreateJar("resources.jar");
@


1.239
log
@Don't include empty classes.jar.
@
text
@d755 3
d759 3
a761 3
					bool hasEntries = false;
					MemoryStream mem = new MemoryStream();
					using (ZipOutputStream zip = new ZipOutputStream(mem))
d763 1
a763 3
						zip.SetLevel(9);
						List<string> stubs = new List<string>();
						foreach (JarItem item in options.jars[i].Items)
d765 6
a770 21
							if (item.zipEntry == null)
							{
								continue;
							}
							if (item.data == null)
							{
								// we don't want stub class pseudo resources for classes loaded from the file system
								if (i != options.classesJar)
								{
									stubs.Add(item.zipEntry.Name);
								}
								continue;
							}
							ZipEntry zipEntry = new ZipEntry(item.zipEntry.Name);
							zipEntry.Comment = item.zipEntry.Comment;
							zipEntry.CompressionMethod = item.zipEntry.CompressionMethod;
							zipEntry.DosTime = item.zipEntry.DosTime;
							zipEntry.ExternalFileAttributes = item.zipEntry.ExternalFileAttributes;
							zipEntry.ExtraData = item.zipEntry.ExtraData;
							zipEntry.Flags = item.zipEntry.Flags;
							if (options.compressedResources || zipEntry.CompressionMethod != CompressionMethod.Stored)
d772 1
a772 1
								zipEntry.CompressionMethod = CompressionMethod.Deflated;
d774 1
a774 4
							zip.PutNextEntry(zipEntry);
							zip.Write(item.data, 0, item.data.Length);
							zip.CloseEntry();
							hasEntries = true;
d776 8
a783 1
						if (stubs.Count != 0)
a784 2
							// generate the --ikvm-classes-- file in the jar
							ZipEntry zipEntry = new ZipEntry(JVM.JarClassList);
a785 10
							zip.PutNextEntry(zipEntry);
							BinaryWriter bw = new BinaryWriter(zip);
							bw.Write(stubs.Count);
							foreach (string classFile in stubs)
							{
								bw.Write(classFile);
							}
							bw.Flush();
							zip.CloseEntry();
							hasEntries = true;
d787 4
d792 1
a792 2
					// don't include empty classes.jar
					if (i != options.classesJar || hasEntries)
d794 7
a800 3
						mem = new MemoryStream(mem.ToArray());
						string name = options.jars[i].Name;
						if (options.targetIsModule)
d802 1
a802 1
							name = Path.GetFileNameWithoutExtension(name) + "-" + moduleBuilder.ModuleVersionId.ToString("N") + Path.GetExtension(name);
d804 13
a816 2
						jarList.Add(name);
						moduleBuilder.DefineManifestResource(name, mem, ResourceAttributes.Public);
d818 2
@


1.238
log
@Add uncompilable classes loaded from the file system to classes.jar.
@
text
@d756 1
d791 1
d807 1
d810 2
a811 3
					mem = new MemoryStream(mem.ToArray());
					string name = options.jars[i].Name;
					if (options.targetIsModule)
d813 8
a820 1
						name = Path.GetFileNameWithoutExtension(name) + "-" + moduleBuilder.ModuleVersionId.ToString("N") + Path.GetExtension(name);
a821 2
					jarList.Add(name);
					moduleBuilder.DefineManifestResource(name, mem, ResourceAttributes.Public);
@


1.237
log
@Changed ikvmc -recurse: option to give a fatal error if it matches no files.
@
text
@a754 3
				// the classes jar (that contains classes loaded directly from the file system,
				// does not contain any resources and we don't want stub class pseudo resources
				if (i != options.classesJar)
d769 5
a773 1
								stubs.Add(item.zipEntry.Name);
@


1.236
log
@- Split class name mapping and class parsing into separate loops to simplify dealing with duplicates.
- Made class name mapping compatible with runtime behavior.
- Give a warning if a class filename doesn't match the class name.
@
text
@d3646 1
@


1.235
log
@Turns out we need to match the .class extension case senstive.
@
text
@d296 6
a2733 1
			Dictionary<string, string> baseClasses = new Dictionary<string, string>();
d2735 1
a2735 1
			bool hasSpecifiedMainClass = options.mainClass != null;
d2737 1
d2743 3
a2745 1
					if (name.EndsWith(".class", StringComparison.Ordinal))
d2747 2
a2748 2
						ClassFile f;
						try
d2750 2
a2751 14
							byte[] buf = jar.Items[i].data;
							f = new ClassFile(buf, 0, buf.Length, null, ClassFileParseOptions.None);
							if (!f.IsInterface && f.SuperClass != null)
							{
								baseClasses[f.SuperClass] = f.SuperClass;
							}
							// NOTE the "assembly" type in the unnamed package is a magic type
							// that acts as the placeholder for assembly attributes
							if (f.Name == "assembly" && f.Annotations != null)
							{
								assemblyAnnotations.AddRange(f.Annotations);
								// HACK skip "assembly" type that exists only as a placeholder for assembly attributes
								continue;
							}
d2753 1
a2753 1
						catch (ClassFormatError)
d2755 1
a2755 7
							continue;
						}
						if (h.ContainsKey(f.Name))
						{
							StaticCompiler.IssueMessage(Message.DuplicateClassName, f.Name);
							JarItemReference itemRef = h[f.Name];
							if ((options.classesJar != -1 && itemRef.Jar == options.jars[options.classesJar]) || jar != itemRef.Jar)
d2757 9
a2765 9
								// the previous class stays, because it was either in an earlier jar or we're processing the classes.jar
								// which contains the classes loaded from the file system
								continue;
							}
							else
							{
								// we have a jar that contains multiple entries with the same name, the last one wins
								h.Remove(f.Name);
								if (!hasSpecifiedMainClass && options.mainClass == f.Name)
d2767 3
a2769 1
									options.mainClass = null;
d2772 2
d2775 30
a2804 1
						if (options.IsExcludedClass(f.Name))
d2806 1
a2806 7
							// we don't compile the class and we also don't include it as a resource
							jar.Items[i] = new JarItem();
						}
						else
						{
							h.Add(f.Name, new JarItemReference(jar, i));
							if (options.mainClass == null && (options.guessFileKind || options.target != PEFileKinds.Dll))
d2808 3
a2810 9
								foreach (ClassFile.Method m in f.Methods)
								{
									if (m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V")
									{
										StaticCompiler.IssueMessage(Message.MainMethodFound, f.Name);
										options.mainClass = f.Name;
										break;
									}
								}
d2815 3
d3571 1
d3900 3
@


1.234
log
@If a jar has multiple class entries with the same name, the last one wins. This mirrors the behavior of Java and dynamic mode.
@
text
@d2737 1
a2737 1
					if (name.EndsWith(".class", StringComparison.OrdinalIgnoreCase))
@


1.233
log
@Project stub classes into the jar the classes originated from.
@
text
@d2730 1
d2764 16
d2781 1
a2781 1
						else if (options.IsExcludedClass(f.Name))
@


1.232
log
@- Unified the handling of resources and classes in ikvmc.
- Include all uncompilable .class files (from jars) into the resource jars.
@
text
@d366 4
a369 2
						// we successfully create the type, so we don't need to include the class as a resource
						itemRef.Jar.Items[itemRef.Index] = new JarItem();
d699 1
a699 1
								if (item.zipEntry != null)
d757 1
d764 5
d781 12
a792 1
							if (item.data != null)
d794 1
a794 1
								zip.Write(item.data, 0, item.data.Length);
d796 1
d3362 1
@


1.231
log
@- Merged two passes through the options.classes dictionary.
- Only skip "assembly" type if it contains annotations.
- Bug fix. Don't look for main method in excluded classes.
@
text
@d47 1
a47 1
		private Dictionary<string, ClassItem> classes;
d77 1
a77 1
		internal CompilerClassLoader(AssemblyClassLoader[] referencedAssemblies, CompilerOptions options, FileInfo assemblyPath, bool targetIsModule, string assemblyName, Dictionary<string, ClassItem> classes)
d275 2
a276 2
				ClassItem classdef;
				if(classes.TryGetValue(name, out classdef))
d279 1
d342 1
a342 1
							string sourceFile = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(classdef.path), f.SourceFileAttribute));
d365 4
a368 1
						return DefineClass(f, null);
d384 1
a384 9
						if ((options.codegenoptions & CodeGenOptions.DisableDynamicBinding) == 0)
						{
							// add the class file as a resource
							options.AddResource(null, f.Name.Replace('.', '/') + ".class", classdef.data, "classes.jar");

							// give a warning about the missing base class/interface
							StaticCompiler.IssueMessage(options, Message.ClassNotFound, x.Message);
						}
						else
d388 1
d693 1
a693 1
						foreach (string name in ccl.options.resources.Keys)
d695 7
a701 1
							AddExportMapEntry(exportedNamesPerAssembly, ccl, name);
d738 1
a738 1
		internal void AddResources(Dictionary<string, List<ResourceItem>> resources, bool compressedResources)
a743 1
			Dictionary<string, Dictionary<string, ResourceItem>> jars = new Dictionary<string, Dictionary<string, ResourceItem>>();
d745 1
a745 1
			foreach (KeyValuePair<string, List<ResourceItem>> kv in resources)
d747 3
a749 1
				foreach (ResourceItem item in kv.Value)
d751 2
a752 5
					int count = 0;
					string jarName = item.jar;
				retry:
					Dictionary<string, ResourceItem> jar;
					if (!jars.TryGetValue(jarName, out jar))
d754 25
a778 2
						jar = new Dictionary<string, ResourceItem>();
						jars.Add(jarName, jar);
d780 3
a782 1
					if (jar.ContainsKey(kv.Key))
d784 1
a784 39
						jarName = Path.GetFileNameWithoutExtension(item.jar) + "-" + (count++) + Path.GetExtension(item.jar);
						goto retry;
					}
					jar.Add(kv.Key, item);
				}
			}

			foreach (KeyValuePair<string, Dictionary<string, ResourceItem>> jar in jars)
			{
				MemoryStream mem = new MemoryStream();
				using (ZipOutputStream zip = new ZipOutputStream(mem))
				{
					foreach (KeyValuePair<string, ResourceItem> kv in jar.Value)
					{
						ZipEntry zipEntry = new ZipEntry(kv.Key);
						if (kv.Value.zipEntry == null)
						{
							zipEntry.CompressionMethod = CompressionMethod.Stored;
						}
						else
						{
							zipEntry.Comment = kv.Value.zipEntry.Comment;
							zipEntry.CompressionMethod = kv.Value.zipEntry.CompressionMethod;
							zipEntry.DosTime = kv.Value.zipEntry.DosTime;
							zipEntry.ExternalFileAttributes = kv.Value.zipEntry.ExternalFileAttributes;
							zipEntry.ExtraData = kv.Value.zipEntry.ExtraData;
							zipEntry.Flags = kv.Value.zipEntry.Flags;
						}
						if (compressedResources || zipEntry.CompressionMethod != CompressionMethod.Stored)
						{
							zip.SetLevel(9);
							zipEntry.CompressionMethod = CompressionMethod.Deflated;
						}
						zip.PutNextEntry(zipEntry);
						if (kv.Value.data != null)
						{
							zip.Write(kv.Value.data, 0, kv.Value.data.Length);
						}
						zip.CloseEntry();
d786 2
a788 8
				mem = new MemoryStream(mem.ToArray());
				string name = jar.Key;
				if (options.targetIsModule)
				{
					name = Path.GetFileNameWithoutExtension(name) + "-" + moduleBuilder.ModuleVersionId.ToString("N") + Path.GetExtension(name);
				}
				jarList.Add(name);
				moduleBuilder.DefineManifestResource(name, mem, ResourceAttributes.Public);
d2710 2
a2711 2
			Dictionary<string, ClassItem> h = new Dictionary<string, ClassItem>();
			foreach(KeyValuePair<string, ClassItem> kv in options.classes)
d2713 1
a2713 2
				ClassFile f;
				try
d2715 2
a2716 9
					byte[] buf = kv.Value.data;
					f = new ClassFile(buf, 0, buf.Length, null, ClassFileParseOptions.None);
					if(!f.IsInterface && f.SuperClass != null)
					{
						baseClasses[f.SuperClass] = f.SuperClass;
					}
					// NOTE the "assembly" type in the unnamed package is a magic type
					// that acts as the placeholder for assembly attributes
					if(f.Name == "assembly" && f.Annotations != null)
d2718 32
a2749 23
						assemblyAnnotations.AddRange(f.Annotations);
						// HACK skip "assembly" type that exists only as a placeholder for assembly attributes
						continue;
					}
				}
				catch(ClassFormatError)
				{
					continue;
				}
				if(h.ContainsKey(f.Name))
				{
					StaticCompiler.IssueMessage(Message.DuplicateClassName, f.Name);
				}
				else if(options.IsExcludedClass(f.Name))
				{
					// skip excluded class
				}
				else
				{
					h.Add(f.Name, kv.Value);
					if (options.mainClass == null && (options.guessFileKind || options.target != PEFileKinds.Dll))
					{
						foreach(ClassFile.Method m in f.Methods)
d2751 2
a2752 1
							if(m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V")
d2754 9
a2762 3
								StaticCompiler.IssueMessage(Message.MainMethodFound, f.Name);
								options.mainClass = f.Name;
								break;
a2767 1
			options.classes = null;
d3066 1
a3066 1
			AddResources(options.resources, options.compressedResources);
d3280 1
a3280 1
	struct ClassItem
d3282 26
a3307 2
		internal byte[] data;
		internal string path;
d3310 1
a3310 1
	struct ResourceItem
d3312 22
a3333 3
		internal ZipEntry zipEntry;
		internal byte[] data;
		internal string jar;
d3338 4
a3357 1
		internal Dictionary<string, ClassItem> classes;
a3362 1
		internal Dictionary<string, List<ResourceItem>> resources = new Dictionary<string, List<ResourceItem>>();
d3390 2
a3391 5
			if (classes != null)
			{
				copy.classes = new Dictionary<string, ClassItem>(classes);
			}
			copy.resources = Copy(resources);
d3405 22
a3426 1
		internal static Dictionary<string, List<ResourceItem>> Copy(Dictionary<string, List<ResourceItem>> resources)
d3428 4
a3431 2
			Dictionary<string, List<ResourceItem>> copy = new Dictionary<string, List<ResourceItem>>();
			foreach (KeyValuePair<string, List<ResourceItem>> kv in resources)
d3433 5
a3437 1
				copy.Add(kv.Key, new List<ResourceItem>(kv.Value));
d3439 13
a3451 1
			return copy;
d3454 1
a3454 1
		internal void AddResource(ZipEntry zipEntry, string name, byte[] buf, string jar)
d3456 1
a3456 2
			List<ResourceItem> list;
			if (!resources.TryGetValue(name, out list))
d3458 2
a3459 2
				list = new List<ResourceItem>();
				resources.Add(name, list);
d3461 1
a3461 5
			ResourceItem item = new ResourceItem();
			item.zipEntry = zipEntry;
			item.data = buf;
			item.jar = jar ?? "resources.jar";
			list.Add(item);
a3493 1
		NotAClassFile = 108,
a3747 4
				case Message.NotAClassFile:
					msg = "Not a class file \"{0}\", including it as resource" + Environment.NewLine +
						"    (class format error \"{1}\")";
					break;
@


1.230
log
@Suppress "class not found" warning for a classes that fails to compile for any reason (because we already give a warning about the primary cause).
@
text
@d2728 1
d2745 2
d2753 5
a2757 1
				if(options.mainClass == null && (options.guessFileKind || options.target != PEFileKinds.Dll))
d2759 6
a2764 1
					foreach(ClassFile.Method m in f.Methods)
d2766 1
a2766 1
						if(m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V")
d2768 6
a2773 3
							StaticCompiler.IssueMessage(Message.MainMethodFound, f.Name);
							options.mainClass = f.Name;
							break;
a2777 25
			Dictionary<string, ClassItem> h = new Dictionary<string, ClassItem>();
			// HACK remove "assembly" type that exists only as a placeholder for assembly attributes
			options.classes.Remove("assembly");
			foreach(KeyValuePair<string, ClassItem> kv in options.classes)
			{
				string name = kv.Key;
				bool excluded = false;
				for(int j = 0; j < options.classesToExclude.Length; j++)
				{
					if(Regex.IsMatch(name, options.classesToExclude[j]))
					{
						excluded = true;
						break;
					}
				}
				if(h.ContainsKey(name))
				{
					StaticCompiler.IssueMessage(Message.DuplicateClassName, name);
					excluded = true;
				}
				if(!excluded)
				{
					h[name] = kv.Value;
				}
			}
d3398 12
@


1.229
log
@Reordered using declarations and add using for sharpziplib.
@
text
@d291 1
a368 1
						return null;
a372 1
						return null;
a376 1
						return null;
a384 3
							// suppress class not found warning for the current class
							options.suppressWarnings[(int)Message.ClassNotFound + ":" + f.Name] = null;

a391 1
						return null;
a395 1
						return null;
d397 2
d3886 5
@


1.228
log
@Unified all ikvmc filename validation.
@
text
@a25 3
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
a33 2
using IKVM.Attributes;

d37 5
d773 1
a773 1
				using (ICSharpCode.SharpZipLib.Zip.ZipOutputStream zip = new ICSharpCode.SharpZipLib.Zip.ZipOutputStream(mem))
d777 1
a777 1
						ICSharpCode.SharpZipLib.Zip.ZipEntry zipEntry = new ICSharpCode.SharpZipLib.Zip.ZipEntry(kv.Key);
d780 1
a780 1
							zipEntry.CompressionMethod = ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored;
d791 1
a791 1
						if (compressedResources || zipEntry.CompressionMethod != ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored)
d794 1
a794 1
							zipEntry.CompressionMethod = ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflated;
d3314 1
a3314 1
		internal ICSharpCode.SharpZipLib.Zip.ZipEntry zipEntry;
d3399 1
a3399 1
		internal void AddResource(ICSharpCode.SharpZipLib.Zip.ZipEntry zipEntry, string name, byte[] buf, string jar)
@


1.227
log
@- Made dynamic binding to unloadable types the default (for ikvmc).
- Added -static option to ikvmc to disable dynamic binding.
@
text
@d77 1
a77 1
		internal CompilerClassLoader(AssemblyClassLoader[] referencedAssemblies, CompilerOptions options, string path, bool targetIsModule, string assemblyName, Dictionary<string, ClassItem> classes)
a83 1
			FileInfo assemblyPath = new FileInfo(path);
d932 1
a932 1
					AttributeHelper.SetSourceFile(typeBuilder, Path.GetFileName(classLoader.options.remapfile));
d2821 1
a2821 1
						options.path = options.assembly + ".netmodule";
d2825 1
a2825 1
						options.path = options.assembly + ".dll";
d2830 1
a2830 1
					options.path = options.assembly + ".exe";
d2832 1
a2832 1
				StaticCompiler.IssueMessage(Message.OutputFileIs, options.path);
d2842 1
a2842 1
				options.assembly = new FileInfo(options.path).Name;
d2869 1
a2869 1
					fs = File.OpenRead(options.remapfile);
d3321 2
a3322 2
		internal string path;
		internal string keyfile;
d3329 2
a3330 2
		internal string iconfile;
		internal string manifestFile;
d3345 1
a3345 1
		internal string remapfile;
d3365 1
a3365 1
		internal string writeSuppressWarningsFile;
d3641 1
a3641 1
				File.AppendAllText(options.writeSuppressWarningsFile, "-nowarn:" + key + Environment.NewLine);
@


1.226
log
@Fixed previous commit. We can't add the suppress warning key if it already exists.
@
text
@d3349 1
a3349 1
		internal CodeGenOptions codegenoptions = CodeGenOptions.DisableDynamicBinding;
@


1.225
log
@- If a class can't be statically compiled due to a missing base class/interface, include it as a resource.
- Modified the assembly class loader to try to load classes from resources.
@
text
@d389 1
a389 1
							options.suppressWarnings.Add((int)Message.ClassNotFound + ":" + f.Name, null);
@


1.224
log
@Simplified resource option handling.
@
text
@d383 15
a397 1
						StaticCompiler.IssueMessage(options, Message.NoClassDefFoundError, name, x.Message);
@


1.223
log
@Fix for bug #3604215.
@
text
@d688 1
a688 1
						if (ccl.options.resources != null)
d690 1
a690 4
							foreach (string name in ccl.options.resources.Keys)
							{
								AddExportMapEntry(exportedNamesPerAssembly, ccl, name);
							}
d3330 1
a3330 1
		internal Dictionary<string, List<ResourceItem>> resources;
d3362 1
a3362 4
			if (resources != null)
			{
				copy.resources = Copy(resources);
			}
d3385 15
@


1.222
log
@Removed obsolete stub class handling.
@
text
@d592 4
d608 4
@


1.221
log
@Made TypeWrapper.IsInternal a readonly property.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2012 Jeroen Frijters
a71 1
		private Dictionary<string, TypeWrapper> importedStubTypes = new Dictionary<string, TypeWrapper>();
d364 1
a364 6
						TypeWrapper type = DefineClass(f, null);
						if(f.IKVMAssemblyAttribute != null)
						{
							importedStubTypes.Add(f.Name, type);
						}
						return type;
a2942 18
		private bool IsStub(string className)
		{
			// this function is needed because when using generics a type may be loaded before the stub is seen
			// and without this check that would cause a spurious IKVMC0109 warning
			ClassItem classdef;
			if (classes.TryGetValue(className, out classdef))
			{
				try
				{
					return new ClassFile(classdef.data, 0, classdef.data.Length, className, ClassFileParseOptions.RelaxedClassNameValidation).IKVMAssemblyAttribute != null;
				}
				catch (ClassFormatError)
				{
				}
			}
			return false;
		}

d2974 1
a2974 1
						if(!(loader is GenericClassLoader || loader is CompilerClassLoader || (importedStubTypes.ContainsKey(s) && importedStubTypes[s] == wrapper) || IsStub(s)))
@


1.220
log
@Added CodeGenOptions.DisableDynamicBinding to disable dynamic binding, instead of conditional compilation.
@
text
@d872 1
a872 1
				: base((Modifiers)c.Modifiers, c.Name)
@


1.219
log
@(Ab)use InternalsVisibleToAttribute to allow the runtime to dynamically inject classes into statically compiled assemblies.
@
text
@d3354 1
a3354 1
		internal CodeGenOptions codegenoptions;
@


1.218
log
@Added AttributeHelper.SetInternalsVisibleToAttribute().
@
text
@d173 5
@


1.217
log
@Suppress warnings after an error has occurred (to avoid obscuring the fact that compilation failed).
@
text
@d472 1
a472 2
			CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.Import(typeof(InternalsVisibleToAttribute)).GetConstructor(new Type[] { Types.String }), new object[] { name });
			this.assemblyBuilder.SetCustomAttribute(cab);
@


1.216
log
@Disabled automatic assembly loading for ikvmc. All dependencies must now be explicitly referenced (except for the stub jar loophole and secondary assemblies in a shared class loader group).
@
text
@d3610 5
@


1.215
log
@Corrected previous commit.
@
text
@d3089 1
a3089 1
					StaticCompiler.IssueMessage(Message.MissingType, ((Type)x.MemberInfo).FullName, x.MemberInfo.Module.Assembly.FullName);
d3465 1
d3521 1
d3547 6
a3552 1
			return Universe.Load(assemblyString);
d3763 3
d3870 6
@


1.214
log
@Handle MissingMemberException during FinishRemappedTypes.
@
text
@d3089 1
a3089 1
					StaticCompiler.IssueMessage(Message.MissingReference, ((Type)x.MemberInfo).FullName, x.MemberInfo.Module.Assembly.FullName);
d3464 1
d3753 3
@


1.213
log
@Moved secondary assembly loading (from a shared class loader group) to an explicit step early in the compilation process. Referencing a secondary assembly is now an error, instead of a warning.
@
text
@d3083 9
a3091 1
				FinishRemappedTypes();
@


1.212
log
@Moved (legacy) stub class parsing from the guts of the class loader to an explicit upfront step.
@
text
@a2833 4
				if (acl.MainAssembly != references[i])
				{
					StaticCompiler.IssueMessage(options, Message.NonPrimaryAssemblyReference, references[i].GetName().Name, acl.MainAssembly.GetName().Name);
				}
d2903 1
a3436 1
		NonPrimaryAssemblyReference = 131,
d3455 1
d3742 1
a3742 1
					msg = "Referenced assembly \"{0}\" is not the primary assembly of a shared class loader group, referencing primary assembly \"{1}\" instead";
@


1.211
log
@Officially deprecated compiling with stubs.
@
text
@d3336 1
@


1.210
log
@Give the appropriate error messages if trying to extend or implement a missing type.
@
text
@d3442 1
d3752 3
@


1.209
log
@Enabled resolving missing members and added a warning for missing types.
@
text
@d3511 1
@


1.208
log
@- Bug fix. Deduplicate messages based on all parameter values, not just the first one.
- Allow messages to be suppressed based on any number of parameter values.
- Write fully specific -nowarn options to suppress file.
@
text
@d3441 1
d3515 1
a3515 1
		internal static readonly Universe Universe = new Universe();
d3521 13
d3747 3
@


1.207
log
@- Support "attributes" attribute on method tag in map.xml for methods declared in remapped types.
- Recognize methods in remapped types with the "__<" name prefix as HideFromJava.
@
text
@d3580 2
a3581 3
			StringBuilder sb = new StringBuilder();
			sb.Append((int)msgId);
			if(values.Length > 0)
d3583 9
a3591 7
				sb.Append(':').Append(values[0]);
			}
			string key = sb.ToString();
			if(options.suppressWarnings.ContainsKey(key)
				|| options.suppressWarnings.ContainsKey(((int)msgId).ToString()))
			{
				return;
@


1.206
log
@Removed unnecessary MethodBuilder casts.
@
text
@d1356 1
a1356 1
							MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers) | MethodAttributes.HideBySig;
d1470 1
a1470 1
					return false;
@


1.205
log
@Removed remaining ConstructorBuilder usages.
@
text
@d1939 1
a1939 1
							pb.SetGetMethod((MethodBuilder)methods[MakeMethodKey(pi.GetGetMethod())]);
d1943 1
a1943 1
							pb.SetSetMethod((MethodBuilder)methods[MakeMethodKey(pi.GetSetMethod())]);
@


1.204
log
@Removed dummy constructor from __Helper class.
@
text
@d2168 1
a2168 1
		internal static void AddDeclaredExceptions(MethodBase mb, IKVM.Internal.MapXml.Throws[] throws)
@


1.203
log
@Removed more ConstructorBuilder usage to fix regression (constructor custom attributes specified map.xml were not applied).
@
text
@d1286 1
a1286 7
								// FXBUG we use a nested helper class, because Reflection.Emit won't allow us to add a static method to the interface
								// TODO now that we're on Whidbey we can remove this workaround
								typeWrapper.helperTypeBuilder = typeWrapper.typeBuilder.DefineNestedType("__Helper", TypeAttributes.NestedPublic | TypeAttributes.Class | TypeAttributes.Sealed);
								ilgen = CodeEmitter.Create(typeWrapper.helperTypeBuilder.DefineConstructor(MethodAttributes.Private, CallingConventions.Standard, Type.EmptyTypes));
								ilgen.Emit(OpCodes.Ldnull);
								ilgen.Emit(OpCodes.Throw);
								ilgen.DoEmit();
@


1.202
log
@Removed unnecessary casting (now that we have a CodeEmitter.Emit() overload that takes a MethodBase).
@
text
@d1050 1
a1050 1
					ConstructorBuilder cbCore = null;
d1069 1
a1069 1
						cbCore = typeWrapper.typeBuilder.DefineConstructor(attr, CallingConventions.Standard, paramTypes);
d1089 1
a1089 1
					ConstructorBuilder cbCore = GetMethod() as ConstructorBuilder;
a1777 18
			private static void SetParameters(ClassLoaderWrapper loader, ConstructorBuilder cb, IKVM.Internal.MapXml.Param[] parameters)
			{
				if(parameters != null)
				{
					for(int i = 0; i < parameters.Length; i++)
					{
						ParameterBuilder pb = cb.DefineParameter(i + 1, ParameterAttributes.None, parameters[i].Name);
						if(parameters[i].Attributes != null)
						{
							for(int j = 0; j < parameters[i].Attributes.Length; j++)
							{
								AttributeHelper.SetCustomAttribute(loader, pb, parameters[i].Attributes[j]);
							}
						}
					}
				}
			}

d1866 1
a1866 1
					ConstructorBuilder cb = typeBuilder.DefineTypeInitializer();
@


1.202.2.1
log
@- Fixed build number
- Fixed .NET 4.0 build issues
- Fixed map.xml custom attribute application regression
- Updated HOWTO
@
text
@d1050 1
a1050 1
					MethodBuilder cbCore = null;
d1069 1
a1069 1
						cbCore = ReflectUtil.DefineConstructor(typeWrapper.typeBuilder, attr, paramTypes);
d1089 1
a1089 1
					MethodBuilder cbCore = GetMethod() as MethodBuilder;
d1778 18
d1884 1
a1884 1
					MethodBuilder cb = ReflectUtil.DefineTypeInitializer(typeBuilder);
@


1.201
log
@- Marked MemberWrapper class abstract.
- Marked all classes that don't (and shouldn't) have subclasses sealed.
@
text
@d1029 1
a1029 1
					ilgen.Emit(OpCodes.Call, (ConstructorInfo)GetMethod());
d1040 1
a1040 1
						ilgen.Emit(OpCodes.Newobj, (ConstructorInfo)GetMethod());
@


1.200
log
@- Made CodeEmitter more "type safe" by adding specific EmitXxx methods instead of following the more general ILGenerator pattern.
- Added some new optimizations to CodeEmitter (disabled unless experimental optimizations are enabled).
- Added some invariant checks to CodeEmitter to help debug optimizations (and document the invariants).
@
text
@d45 1
a45 1
	class CompilerClassLoader : ClassLoaderWrapper
d831 1
a831 1
		private class RemapperTypeWrapper : TypeWrapper
d3340 1
a3340 1
	class CompilerOptions
@


1.199
log
@More ikvmc error handling clean up.
@
text
@d512 1
a512 1
			ilgen.Emit(OpCodes.Leave, label);
d528 1
a528 1
			ilgen.Emit(OpCodes.Leave, label);
d1105 1
a1105 1
								ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
d1156 1
a1156 1
								ilgen.Emit(OpCodes.Ldarg, (short)i);
d1312 1
a1312 1
								ilgen.Emit(OpCodes.Brfalse_S, label);
d1315 1
a1315 1
									ilgen.Emit(OpCodes.Ldarg, (short)i);
d1326 1
a1326 1
								ilgen.Emit(OpCodes.Ldarg, (short)i);
d1528 1
a1528 1
								ilgen.Emit(OpCodes.Ldarg, (short)(i + thisOffset));
d1578 1
a1578 1
							ilgen.Emit(OpCodes.Brfalse_S, skip);
d1581 1
a1581 1
								ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
d1603 1
a1603 1
								ilgen.Emit(OpCodes.Brfalse_S, skip);
d1606 1
a1606 1
									ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
d1639 1
a1639 1
								ilgen.Emit(OpCodes.Ldarg, (short)i);
d1711 1
a1711 1
								ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
d1936 1
a1936 1
								ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
d1940 1
a1940 1
								ilgen.Emit(OpCodes.Ldarg_S, (byte)paramTypes.Length);
d2021 1
a2021 1
				ilgen.Emit(OpCodes.Brfalse_S, retFalse);
d2027 1
a2027 1
					ilgen.Emit(OpCodes.Brtrue_S, retFalse);
d2034 1
a2034 1
					ilgen.Emit(OpCodes.Brtrue_S, retFalse);
d2043 1
a2043 1
						ilgen.Emit(OpCodes.Brtrue_S, retFalse);
d2076 1
a2076 1
					ilgen.Emit(OpCodes.Brtrue_S, fail);
d2084 1
a2084 1
					ilgen.Emit(OpCodes.Brtrue_S, fail);
d2094 1
a2094 1
						ilgen.Emit(OpCodes.Brtrue_S, fail);
d2340 1
a2340 1
					ilgen.Emit(OpCodes.Brfalse_S, label);
@


1.198
log
@Fix regression caused by previous commit. If we can't find the source and no -srcpath: option is specified, the debugging source path should be set to the source file attribute as-is.
@
text
@d586 8
a593 1
				GetTypeWrapperFactory().ModuleBuilder.__Save(options.pekind, options.imageFileMachine);
d598 8
a605 1
				assemblyBuilder.Save(assemblyFile, options.pekind, options.imageFileMachine);
d2615 1
a2615 2
					Console.Error.WriteLine("Error: unable to load runtime assembly");
					return 1;
d2687 2
a2688 1
			try
d2690 1
a2690 13
				Tracer.Info(Tracer.Compiler, "CompilerClassLoader.Save...");
				foreach (CompilerClassLoader compiler in compilers)
				{
					compiler.PrepareSave();
				}
				if (StaticCompiler.errorCount > 0)
				{
					return 1;
				}
				foreach (CompilerClassLoader compiler in compilers)
				{
					compiler.Save();
				}
d2692 1
a2692 1
			catch (IOException x)
a2693 1
				Console.Error.WriteLine("Error: {0}", x.Message);
d2696 4
d2711 6
a2716 1
				try
d2718 1
a2718 6
					references.Add(reference);
					allReferencesAreStrongNamed &= IsSigned(reference);
					Tracer.Info(Tracer.Compiler, "Loaded reference assembly: {0}", reference.FullName);
					// if it's an IKVM compiled assembly, make sure that it was compiled
					// against same version of the runtime
					foreach(AssemblyName asmref in reference.GetReferencedAssemblies())
d2720 1
a2720 1
						if(asmref.Name == runtimeAssemblyName.Name)
d2722 2
a2723 1
							if(IsSigned(StaticCompiler.runtimeAssembly))
d2725 1
a2725 7
								if(asmref.FullName != runtimeAssemblyName.FullName)
								{
									Console.Error.WriteLine("Error: referenced assembly {0} was compiled with an incompatible IKVM.Runtime version ({1})", reference.Location, asmref.Version);
									Console.Error.WriteLine("   Current runtime: {0}", runtimeAssemblyName.FullName);
									Console.Error.WriteLine("   Referenced assembly runtime: {0}", asmref.FullName);
									return 1;
								}
d2727 4
a2730 1
							else
d2732 1
a2732 7
								if(asmref.GetPublicKeyToken() != null && asmref.GetPublicKeyToken().Length != 0)
								{
									Console.Error.WriteLine("Error: referenced assembly {0} was compiled with an incompatible (signed) IKVM.Runtime version", reference.Location);
									Console.Error.WriteLine("   Current runtime: {0}", runtimeAssemblyName.FullName);
									Console.Error.WriteLine("   Referenced assembly runtime: {0}", asmref.FullName);
									return 1;
								}
a2736 5
				catch(Exception x)
				{
					Console.Error.WriteLine("Error: invalid reference: {0} ({1})", reference.Location, x.Message);
					return 1;
				}
d2810 1
a2810 2
				Console.Error.WriteLine("Error: main class cannot be specified for library or module");
				return 1;
d2815 1
a2815 2
				Console.Error.WriteLine("Error: no main method found");
				return 1;
d2820 1
a2820 2
				Console.Error.WriteLine("Error: properties cannot be specified for library or module");
				return 1;
d2847 1
a2847 2
					Console.Error.WriteLine("Error: cannot specify assembly class loader for modules");
					return 1;
a2852 12
			if(options.target == PEFileKinds.Dll && !options.path.ToLower().EndsWith(".dll") && !options.targetIsModule)
			{
				Console.Error.WriteLine("Error: library output file must end with .dll");
				return 1;
			}

			if(options.target != PEFileKinds.Dll && !options.path.ToLower().EndsWith(".exe"))
			{
				Console.Error.WriteLine("Error: executable output file must end with .exe");
				return 1;
			}

d2885 1
a2885 2
					Console.Error.WriteLine("Error opening remap file \"{0}\": {1}", options.remapfile, x.Message);
					return 1;
d2898 1
a2898 2
						Console.Error.WriteLine("Error parsing remap file \"{0}\": {1}", options.remapfile, x.Message);
						return 1;
d2937 1
a2937 2
					Console.Error.WriteLine("Error: bootstrap classes missing and core assembly not found");
					return 1;
d2951 1
a2951 2
				Console.Error.WriteLine("Error: all referenced assemblies must be strong named, to be able to sign the output assembly");
				return 1;
d3077 1
a3077 2
					Console.Error.WriteLine("Error: main class not found");
					return 1;
d3080 1
a3080 1
				if(mw == null)
d3082 1
a3082 2
					Console.Error.WriteLine("Error: main method not found");
					return 1;
d3088 1
a3088 2
					Console.Error.WriteLine("Error: redirected main method not supported");
					return 1;
d3093 1
a3093 2
					Console.Error.WriteLine("Error: external main method must be public and in a public class");
					return 1;
d3146 1
a3146 2
					Console.Error.WriteLine("Error: custom assembly class loader class not found");
					return 1;
d3150 1
a3150 2
					Console.Error.WriteLine("Error: custom assembly class loader class is not accessible");
					return 1;
d3154 1
a3154 2
					Console.Error.WriteLine("Error: custom assembly class loader class is abstract");
					return 1;
d3158 1
a3158 2
					Console.Error.WriteLine("Error: custom assembly class loader class does not extend java.lang.ClassLoader");
					return 1;
d3163 1
a3163 2
					Console.Error.WriteLine("Error: custom assembly class loader constructor is missing");
					return 1;
d3183 1
a3183 8
				try
				{
					assemblyBuilder.__DefineIconResource(File.ReadAllBytes(options.iconfile));
				}
				catch (Exception x)
				{
					Console.Error.WriteLine("Error: unable to read icon file.\r\n\t'{0}' -- {1}", options.iconfile, x.Message);
				}
d3187 1
a3187 8
				try
				{
					assemblyBuilder.__DefineManifestResource(File.ReadAllBytes(options.manifestFile));
				}
				catch (Exception x)
				{
					Console.Error.WriteLine("Error: unable to read manifest file.\r\n\t'{0}' -- {1}", options.manifestFile, x.Message);
				}
d3195 1
a3195 2
			Console.Error.WriteLine("Unknown element {0} in XML mapping file, line {1}, column {2}", e.Element.Name, e.LineNumber, e.LinePosition);
			Environment.Exit(1);
d3200 1
a3200 2
			Console.Error.WriteLine("Unknown attribute {0} in XML mapping file, line {1}, column {2}", e.Attr.Name, e.LineNumber, e.LinePosition);
			Environment.Exit(1);
d3254 1
a3254 1
				Console.Error.WriteLine("Error: Invalid {0} name '{2}' in remap file in class {1}", member, clazz, name, sig);
d3259 1
a3259 1
				Console.Error.WriteLine("Error: Invalid {0} signature '{3}' in remap file for {0} {1}.{2}", member, clazz, name, sig);
d3270 1
a3270 1
					Console.Error.WriteLine("Error: Invalid property {0} name '{3}' in remap file for property {1}.{2}", getterOrSetter, clazz, property, method.Name, method.Sig);
d3275 1
a3275 1
					Console.Error.WriteLine("Error: Invalid property {0} signature '{4}' in remap file for property {1}.{2}", getterOrSetter, clazz, property, method.Name, method.Sig);
d3474 6
d3506 28
d3576 1
a3576 2
				Console.Error.WriteLine("Error: type '{0}' referenced in xml remap file was not found", name);
				Environment.Exit(1);
d3586 1
a3586 2
				Console.Error.WriteLine("Error: class '{0}' referenced in xml remap file was not found", name);
				Environment.Exit(1);
d3775 18
d3817 1
a3817 2
					Console.Error.WriteLine("Maximum error count reached, exiting.");
					Environment.Exit(1);
d3828 1
a3828 1
			Console.Error.WriteLine("Link Error: " + msg, args);
d3831 1
a3831 1
				Console.Error.WriteLine("Please add a reference to {0}", expectedType.TypeAsBaseType.Assembly.Location);
d3833 1
a3833 1
			Environment.Exit(1);
@


1.197
log
@Added support to ikvmc to automatically set the full source path in the debugging info if the source file lives next to the .class file.
@
text
@d343 1
a343 1
						if(f.SourcePath == null && options.sourcepath != null)
d345 11
a355 4
							string package = f.Name;
							int index = package.LastIndexOf('.');
							package = index == -1 ? "" : package.Substring(0, index).Replace('.', '/');
							f.SourcePath = Path.GetFullPath(Path.Combine(options.sourcepath + "/" + package, f.SourceFileAttribute));
@


1.196
log
@Lots of ikvmc error handling clean up.
@
text
@d47 1
a47 1
		private Dictionary<string, byte[]> classes;
d78 1
a78 1
		internal CompilerClassLoader(AssemblyClassLoader[] referencedAssemblies, CompilerOptions options, string path, bool targetIsModule, string assemblyName, Dictionary<string, byte[]> classes)
a114 8
		internal override string SourcePath
		{
			get
			{
				return options.sourcepath;
			}
		}

d272 1
a272 1
				byte[] classdef;
d284 1
a284 1
						f = new ClassFile(classdef, 0, classdef.Length, name, cfp);
d333 18
d2742 1
a2742 1
			foreach(KeyValuePair<string, byte[]> kv in options.classes)
d2747 1
a2747 1
					byte[] buf = kv.Value;
d2777 1
a2777 1
			Dictionary<string, byte[]> h = new Dictionary<string, byte[]>();
d2780 1
a2780 1
			foreach(KeyValuePair<string, byte[]> kv in options.classes)
d2997 1
a2997 1
			byte[] classdef;
d3002 1
a3002 1
					return new ClassFile(classdef, 0, classdef.Length, className, ClassFileParseOptions.RelaxedClassNameValidation).IKVMAssemblyAttribute != null;
d3373 6
d3404 1
a3404 1
		internal Dictionary<string, byte[]> classes;
d3439 1
a3439 1
				copy.classes = new Dictionary<string, byte[]>(classes);
@


1.195
log
@Added ikvmc -highentropyva option (to enable high entropy ASLR in 64 bit processes on Windows 8).
@
text
@d3502 28
d3623 1
a3623 1
					msg = "found main method in class \"{0}\"";
d3626 1
a3626 1
					msg = "output file is \"{0}\"";
d3629 1
a3629 1
					msg = "automatically adding reference to \"{0}\"";
d3632 1
a3632 1
					msg = "using main class \"{0}\" based on jar manifest";
d3635 1
a3635 1
					msg = "class \"{0}\" not found";
d3638 1
a3638 1
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
d3642 1
a3642 1
					msg = "duplicate class name: \"{0}\"";
d3645 1
a3645 1
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
d3649 1
a3649 1
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
d3653 1
a3653 1
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
d3657 1
a3657 1
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
d3661 1
a3661 1
					msg = "skipping resource (name clash): \"{0}\"";
d3664 1
a3664 1
					msg = "not a class file \"{0}\", including it as resource" + Environment.NewLine +
d3668 1
a3668 1
					msg = "skipping class: \"{0}\"" + Environment.NewLine +
d3672 1
a3672 1
					msg = "unable to load runtime JNI assembly";
d3675 1
a3675 1
					msg = "emitted java.lang.NoClassDefFoundError in \"{0}\"" + Environment.NewLine +
d3679 1
a3679 1
					msg = "emitted java.lang.IllegalAccessError in \"{0}\"" + Environment.NewLine +
d3683 1
a3683 1
					msg = "emitted java.lang.InstantiationError in \"{0}\"" + Environment.NewLine +
d3687 1
a3687 1
					msg = "emitted java.lang.IncompatibleClassChangeError in \"{0}\"" + Environment.NewLine +
d3691 1
a3691 1
					msg = "emitted java.lang.NoSuchFieldError in \"{0}\"" + Environment.NewLine +
d3695 1
a3695 1
					msg = "emitted java.lang.AbstractMethodError in \"{0}\"" + Environment.NewLine +
d3699 1
a3699 1
					msg = "emitted java.lang.NoSuchMethodError in \"{0}\"" + Environment.NewLine +
d3703 1
a3703 1
					msg = "emitted java.lang.LinkageError in \"{0}\"" + Environment.NewLine +
d3707 1
a3707 1
					msg = "emitted java.lang.VerificationError in \"{0}\"" + Environment.NewLine +
d3711 1
a3711 1
					msg = "emitted java.lang.ClassFormatError in \"{0}\"" + Environment.NewLine +
d3715 1
a3715 1
					msg = "error emitting \"{0}\" custom attribute" + Environment.NewLine +
d3719 1
a3719 1
					msg = "custom attribute \"{0}\" was ignored" + Environment.NewLine +
d3723 1
a3723 1
					msg = "assuming assembly reference \"{0}\" matches \"{1}\", you may need to supply runtime policy";
d3726 1
a3726 1
					msg = "directory \"{0}\" specified in -lib option is not valid";
d3729 1
a3729 1
					msg = "directory \"{0}\" specified in LIB environment is not valid";
d3732 1
a3732 1
					msg = "found assembly \"{0}\" using legacy search rule, please append '.dll' to the reference";
d3735 1
a3735 1
					msg = "assembly \"{0}\" is ignored as previously loaded assembly \"{1}\" has the same identity \"{2}\"";
d3738 1
a3738 1
					msg = "ignoring @@ikvm.lang.Internal annotation on interface method" + Environment.NewLine +
d3742 1
a3742 1
					msg = "ignoring @@ikvm.lang.DllExport annotation on non-static method" + Environment.NewLine +
d3746 1
a3746 1
					msg = "ignoring @@ikvm.lang.DllExport annotation due to unsupported target platform";
d3749 1
a3749 1
					msg = "referenced assembly \"{0}\" is not the primary assembly of a shared class loader group, referencing primary assembly \"{1}\" instead";
d3752 1
a3752 1
					msg = "duplicate assembly reference \"{0}\"";
d3755 1
a3755 1
					msg = "unable to create proxy \"{0}\"" + Environment.NewLine +
d3759 1
a3759 1
					msg = "duplicate proxy \"{0}\"";
d3762 1
a3762 1
					msg = "unable to resolve opcode in remap file: {0}";
d3765 7
a3771 1
					msg = "error in remap file: {0}";
d3783 1
a3783 1
			Console.Error.Write("{0} IKVMC{1:D4}: ", error ? "Error" : msgId < Message.StartWarnings ? "Note" : "Warning", (int)msgId);
@


1.194
log
@Added ikvmc -filealign:<n> option.
@
text
@d177 4
d3410 1
@


1.193
log
@Added ikvmc -win32manifest:<file> option.
@
text
@d173 4
d3405 1
@


1.192
log
@Bug fix. Non-public property getter/setter methods should be ignored when we create properties to hide properties inherited from shadow types. This fixes a build break with .NET 4.5 beta which introduces a protected setter for Exception.HResult.
@
text
@d3204 11
d3373 1
@


1.191
log
@Prevent IKVMC0109 warning when a stub is encountered after the corresponding type has already been loaded.
@
text
@d1922 1
a1922 1
						if(pi.CanRead)
d1926 1
a1926 1
						if(pi.CanWrite)
@


1.190
log
@Bug fix. The right remap filename should be put in the SourceFileAttribute, instead of the last one.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d2975 18
d3024 1
a3024 1
						if(!(loader is GenericClassLoader || loader is CompilerClassLoader || (importedStubTypes.ContainsKey(s) && importedStubTypes[s] == wrapper)))
@


1.189
log
@Made base TypeWrapper resolution lazy for compiled and .NET TypeWrappers. This is not just a perf improvement, but also avoid infinite recursion for generic type instantiations that use sub types as type parameters.
@
text
@d877 1
a877 1
					AttributeHelper.SetSourceFile(typeBuilder, IKVM.Internal.MapXml.Root.filename);
a2890 1
					IKVM.Internal.MapXml.Root.filename = new FileInfo(fs.Name).Name;
@


1.188
log
@Introduced an intermediate compilation pass for CreateStep2 to enable a class to extend a class nested inside itself.
@
text
@d799 1
d829 1
a829 1
				: base((Modifiers)c.Modifiers, c.Name, GetBaseWrapper(c))
d832 1
d932 5
@


1.187
log
@Split compilation into two passes.
@
text
@d2622 4
d2636 1
a2636 1
				int rc = compiler.CompilePass2();
d3020 14
a3033 1
		private int CompilePass2()
@


1.186
log
@Use RemapperTypeWrapper instead of TypeWrapper where appropriate.
@
text
@d76 1
d930 16
d1750 1
a1750 1
			internal void Process2ndPassStep1(IKVM.Internal.MapXml.Root map)
d1752 1
a1752 5
				IKVM.Internal.MapXml.Class c = classDef;
				TypeBuilder tb = typeBuilder;
				bool baseIsSealed = shadowType.IsSealed;

				if(c.Interfaces != null)
d1754 1
a1754 2
					interfaceWrappers = new TypeWrapper[c.Interfaces.Length];
					for(int i = 0; i < c.Interfaces.Length; i++)
d1756 1
a1756 6
						TypeWrapper ifaceTypeWrapper = classLoader.LoadClassByDottedName(c.Interfaces[i].Name);
						interfaceWrappers[i] = ifaceTypeWrapper;
						if(!baseIsSealed)
						{
							tb.AddInterfaceImplementation(ifaceTypeWrapper.TypeAsBaseType);
						}
a1757 5
					AttributeHelper.SetImplementsAttribute(tb, interfaceWrappers);
				}
				else
				{
					interfaceWrappers = TypeWrapper.EmptyArray;
d1759 1
d2181 7
d2202 1
a2202 1
						typeWrapper.Process2ndPassStep1(map);
d2540 1
a2540 1
			if (map.assembly.Classes != null)
a2601 8
			if (compilingCoreAssembly)
			{
				RuntimeHelperTypes.Create(compilers[0]);
			}
			foreach (CompilerClassLoader compiler in compilers)
			{
				compiler.EmitRemappedTypes2ndPass();
			}
d2620 13
a2632 1
				int rc = compiler.Compile();
a2903 1
					loader.EmitRemappedTypes();
d2965 1
a2965 1
		private int Compile()
d2968 4
d2987 1
a2987 1
			List<TypeWrapper> allwrappers = new List<TypeWrapper>();
a3001 4
					if(map == null)
					{
						wrapper.Finish();
					}
d3014 9
@


1.185
log
@Removed last remaining TypeAsBuilder usage.
@
text
@d48 1
a48 1
		private Dictionary<string, TypeWrapper> remapped = new Dictionary<string, TypeWrapper>();
d264 6
a269 2
			TypeWrapper type = null;
			if(type == null)
a270 4
				if(remapped.TryGetValue(name, out type))
				{
					return type;
				}
d334 1
a334 1
						type = DefineClass(f, null);
d339 1
d367 4
a371 1
			return type;
d1826 1
a1826 1
			internal void Process4thPass(ICollection<TypeWrapper> remappedTypes)
d1956 1
a1956 1
			private void CreateShadowInstanceOf(ICollection<TypeWrapper> remappedTypes)
d2007 1
a2007 1
			private void CreateShadowCheckCast(ICollection<TypeWrapper> remappedTypes)
@


1.184
log
@Removed another TypeAsBuilder usage.
@
text
@a2123 8
			internal override TypeBuilder TypeAsBuilder
			{
				get
				{
					return typeBuilder;
				}
			}

@


1.183
log
@- Added extension methods for (almost) all instance methods in Object, String and Throwable.
- Added ObsoleteAttribute to instancehelper_ methods in remapped types (with a message saying that the extension methods should be used).
@
text
@a3056 10
				// mark all exceptions that are unsafe for mapping with a custom attribute,
				// so that at runtime we can quickly assertain if an exception type can be
				// caught without filtering
				foreach(TypeWrapper tw in allwrappers)
				{
					if(!tw.IsInterface && tw.IsMapUnsafeException)
					{
						AttributeHelper.SetExceptionIsUnsafeForMapping(tw.TypeAsBuilder);
					}
				}
@


1.182
log
@Informational messages should not be treated as error when -warnaserror is specified. Fix for #3443377.
@
text
@d1391 1
@


1.181
log
@Removed legacy remap feature that allowed final fields as properties to be defined (long time ago this was used for the System.in/out/err fields).
@
text
@d3674 1
a3674 1
				|| options.warnaserror
d3678 1
a3678 1
			if (error && msgId < Message.StartErrors)
@


1.180
log
@Added ikvmc warnings for:
- referencing non-primary assembly in shared class loader group
- duplicate references
@
text
@a1765 14
						if(f.redirect != null)
						{
							TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(f.redirect.Class);
							MethodWrapper method = tw.GetMethodWrapper(f.redirect.Name, f.redirect.Sig, false);
							if(method == null || !method.IsStatic)
							{
								// TODO better error handling
								throw new InvalidOperationException("remapping field: " + f.Name + f.Sig + " not found");
							}
							// TODO emit an static helper method that enables access to the field at runtime
							method.Link();
							fields.Add(new GetterFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), null, f.Name, f.Sig, new ExModifiers((Modifiers)f.Modifiers, false), (MethodInfo)method.GetMethod(), null));
						}
						else
@


1.179
log
@Use the existing "infrastructure" to add the assembly name to the warning, when necessary.
@
text
@d2848 10
a2857 1
				referencedAssemblies[i] = AssemblyClassLoader.FromAssembly(references[i]);
d3435 2
d3662 6
@


1.178
log
@Only support ikvm.lang.DllExport when -platform:x86 or -platform:x64 is explicitly specified.
@
text
@d3293 1
a3293 1
				StaticCompiler.IssueMessage(Message.DllExportRequiresSupportedPlatform, options.assembly);
d3649 1
a3649 2
					msg = "ignoring @@ikvm.lang.DllExport annotation due to unsupported target platform" + Environment.NewLine +
						"	(\"{0}\")";
@


1.177
log
@Added ikvm.lang.DllExport annotation to export static methods as unmanaged exports.
@
text
@d3280 1
a3280 1
		internal void ClearILOnlyFlag()
d3282 14
a3295 1
			options.pekind &= ~PortableExecutableKinds.ILOnly;
d3425 1
d3648 4
@


1.176
log
@Bug fix. When calling a final method on a remapped type we can't call the instance method in the remapped type, but we have to call the instancehelper instead.
@
text
@d3279 5
d3411 1
d3630 4
@


1.176.2.1
log
@Backported fixes:
- FileStore for non-accessible drive should throw exception when trying to create the FileStore, not when accessing the name() or type() properties.
- Graphics2D.clip(null) should only throw NPE for a Component graphics.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Handle Main-Class manifest value that spans multiple lines. Fix for bug #3461012.
- Informational messages should not be treated as error when -warnaserror is specified. Fix for #3443377.
- Don't enforce pre-1.5 class name rules in ikvmc (since HotSpot doesn't enforce any naming rules for classes loaded by the system (and boot) class loader, by default). Fix for #3443373.
- Fix for #3441959.
- Throwable.addSuppressed() didn't have a proper parameter name.
- mark getSpace0 with SecuritySafeCritical to avoid getting an exception with .NET 4
- Bug fix. Removed incorrect check for uninitialized objects on backward branch.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Added AssemblyInformationalVersionAttribute to OpenJDK assemblies (to set the "Product Version"). Part of patch #3458997.
- Include copyright and metadata in IKVM.OpenJDK.Tools.dll. Part of patch #3458997.
- Bug fix. Don't call Finish on unloadable TypeWrapper.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
- Suppress annotation custom attributes when enumerating inner classes.
- IKVM.Reflection: Bug fix. Fixed copy/paste error. FieldInfo.IsAssembly should test for FieldAttributes.Assembly access, not FieldAttributes.Family.
@
text
@d3644 1
a3644 1
				|| (options.warnaserror && msgId >= Message.StartWarnings)
d3648 1
a3648 1
			if (error && Message.StartWarnings <= msgId && msgId < Message.StartErrors)
@


1.175
log
@Don't open the remap file in read/write mode.
@
text
@d1129 11
a1139 1
					ilgen.Emit(OpCodes.Call, (MethodInfo)GetMethod());
@


1.174
log
@Support remap file <throws /> element for methods and constructors defined in remap file.
@
text
@d2853 1
a2853 1
					fs = File.Open(options.remapfile, FileMode.Open);
@


1.173
log
@Updated Windows globbing to be compatible with Java 7.
@
text
@a946 13

				internal static void AddDeclaredExceptions(MethodBase mb, IKVM.Internal.MapXml.Throws[] throws)
				{
					if(throws != null)
					{
						string[] exceptions = new string[throws.Length];
						for(int i = 0; i < exceptions.Length; i++)
						{
							exceptions[i] = throws[i].Class;
						}
						AttributeHelper.SetThrowsAttribute(mb, exceptions);
					}
				}
d2150 13
@


1.172
log
@Extended map file support for ldtoken opcode to support loading method and field tokens.
@
text
@d448 1
a448 6
			Type[] args = Type.EmptyTypes;
			if(noglobbing)
			{
				args = new Type[] { JVM.Import(typeof(string[])) };
			}
			MethodBuilder mainStub = this.GetTypeWrapperFactory().ModuleBuilder.DefineGlobalMethod("main", MethodAttributes.Public | MethodAttributes.Static, Types.Int32, args);
d474 2
a475 1
			if(noglobbing)
d477 2
a478 5
				ilgen.Emit(OpCodes.Ldarg_0);
			}
			else
			{
				startupType.GetMethodWrapper("glob", "()[Ljava.lang.String;", false).EmitCall(ilgen);
@


1.171
log
@Don't stop on the first error encountered. Keep going until 100 errors. Note that there still are a bunch of immediately fatal errors.
@
text
@d3408 2
d3628 6
@


1.170
log
@Added ikvmc -warnaserror option (which turns all warnings into errors, as opposed to the already existing option -warnaserror: to turn specific warnings into errors).
@
text
@d2645 4
d2659 1
a2659 1
			return 0;
d3416 1
d3648 5
a3652 1
				Environment.Exit(1);
@


1.169
log
@Added support for declaring exceptions on shadow interface methods.
@
text
@d3321 2
a3322 1
		internal Dictionary<string, string> errorWarnings = new Dictionary<string, string>();
d3628 1
d3632 4
@


1.168
log
@Unified Method/Constructor/Clinit remapper types to allow method patching to work more consistently.
@
text
@a1183 5
						if(m.throws != null)
						{
							// TODO we need a place to stick the declared exceptions
							throw new NotImplementedException();
						}
d1205 14
a1218 1
						AttributeHelper.SetRemappedInterfaceMethod(typeWrapper.typeBuilder, m.Name, m.@@override.Name);
@


1.167
log
@Added method prologue support to remap file.
@
text
@d2338 1
a2338 1
					// HACK if it is not a remapped type, we assume it is a container for native methods
d2343 3
a2345 1
						if(c.Methods != null)
d2347 1
a2347 17
							foreach(IKVM.Internal.MapXml.Method method in c.Methods)
							{
								if(method.body != null)
								{
									string methodName = method.Name;
									string methodSig = method.Sig;
									mapxml_MethodBodies.Add(new MethodKey(className, methodName, methodSig), method.body);
								}
								if(method.ReplaceMethodCalls != null)
								{
									mapxml_ReplacedMethods.Add(new MethodKey(className, method.Name, method.Sig), method.ReplaceMethodCalls);
								}
								if (method.prologue != null)
								{
									mapxml_MethodPrologues.Add(new MethodKey(className, method.Name, method.Sig), method.prologue);
								}
							}
d2354 27
@


1.166
log
@Added experimental (and for the time being undocumented) support for having ikvmc pre-generate proxy classes.
@
text
@d65 1
d2335 1
d2357 4
d2368 11
@


1.165
log
@Interface methods must be public, so we ignore the @@ikvm.lang.Internal annotation and emit a warning.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2010 Jeroen Frijters
d2964 4
d3285 1
d3361 4
d3575 7
d3588 4
a3591 8
			if(options.errorWarnings.ContainsKey(key)
				|| options.errorWarnings.ContainsKey(((int)msgId).ToString()))
			{
				Console.Error.Write("{0} IKVMC{1:D4}: ", "Error", (int)msgId);
				Console.Error.WriteLine(msg, values);
				Environment.Exit(1);
			}
			Console.Error.Write("{0} IKVMC{1:D4}: ", msgId < Message.StartWarnings ? "Note" : "Warning", (int)msgId);
d3597 4
@


1.165.2.1
log
@Backport: Add support for overriding constructor body in map.xml.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d2336 1
a2336 1
					// if it is not a remapped type, it must be a container for native, patched or augmented methods
d2341 1
a2341 3
						AddMapXmlMethods(className, c.Constructors);
						AddMapXmlMethods(className, c.Methods);
						if (c.Clinit != null)
d2343 13
a2355 1
							AddMapXmlMethod(className, c.Clinit);
a2361 23
		private void AddMapXmlMethods(string className, IKVM.Internal.MapXml.MethodBase[] methods)
		{
			if(methods != null)
			{
				foreach(IKVM.Internal.MapXml.MethodBase method in methods)
				{
					AddMapXmlMethod(className, method);
				}
			}
		}

		private void AddMapXmlMethod(string className, IKVM.Internal.MapXml.MethodBase method)
		{
			if(method.body != null)
			{
				mapxml_MethodBodies.Add(method.ToMethodKey(className), method.body);
			}
			if(method.ReplaceMethodCalls != null)
			{
				mapxml_ReplacedMethods.Add(method.ToMethodKey(className), method.ReplaceMethodCalls);
			}
		}

@


1.165.2.2
log
@Backport: Don't open the remap file in read/write mode.
@
text
@d2831 1
a2831 1
					fs = File.OpenRead(options.remapfile);
@


1.165.2.3
log
@Backport: Bug fix. When calling a final method on a remapped type we can't call the instance method in the remapped type, but we have to call the instancehelper instead.
@
text
@d1148 1
a1148 11
					if(!IsStatic && IsFinal)
					{
						// When calling a final instance method on a remapped type from a class derived from a .NET class (i.e. a cli.System.Object or cli.System.Exception derived base class)
						// then we can't call the java.lang.Object or java.lang.Throwable methods and we have to go through the instancehelper_ method. Note that since the method
						// is final, this won't affect the semantics.
						EmitCallvirt(ilgen);
					}
					else
					{
						ilgen.Emit(OpCodes.Call, (MethodInfo)GetMethod());
					}
@


1.165.2.4
log
@Backported fixes for 0.46.0.3:
- Bug fix. java.lang.Package was not populated from manifest for ikvmc compiled assemblies.
- Bug fix. When writing a direct ByteBuffer to a non-blocking socket and the write fails because there is no kernel buffer available, we should not advance the ByteBuffer position.
- Bug fix. When adding certificates to virtual cacerts file make sure that the aliases are unique.
- Bug fix. If a finally/fault handler contains reachable code before the handler's start index, the handler should branch to the handler start index.
- Bug fix. After emitting a finally/fault handler block, we should emit the block leave stubs (even though you can't leave the block, they also emit the backward branch stubs).
- Bug fix. If a Java class extends a remapped .NET type (cli.System.Object or cli.System.Exception), we should correctly report the base class.
- Bug fix. If we encounter a jsr or ret instruction, we should throw a VerifyError (instead of NotImplementedException).
- Bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
- Disable AppDomain.ProcessExit hook to run shutdown hooks when running on Mono to workaround https://bugzilla.xamarin.com/show_bug.cgi?id=5650
- Bug fix. Custom attribute properties that don't have a public getter and setter should not be exposed as annotation properties.
- Bug fix. Non-public property getter/setter methods should be ignored when we create properties to hide properties inherited from shadow types. This fixes a build break with .NET 4.5 beta which introduces a protected setter for Exception.HResult.
- Bug fix. The $Method inner class for delegates should also be loadable for generic delegates. Thanks to Michael Bayne for reporting this.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Replaced non-ascii character (micro) with ascii 'u' in Win32PrintService.java.
- IKVM.Reflection: Bug fix. Resource Directory Entries must be sorted and names are case-insensitive

Backported for 0.46.0.4:
- Fixed ikvmc to retain transient modifier on constant static final fields.
- Fixed Field.getModifiers() to only return the relevant modifiers.
- Fixed IKVM.Reflection to set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@d1932 1
a1932 1
						if(pi.GetGetMethod() != null)
d1936 1
a1936 1
						if(pi.GetSetMethod() != null)
@


1.164
log
@- Added ModuleBuilder.__Save() to support -target:module option better.
- Changed ikvmc to use new ModuleBuilder.__Save() instead of workaround of deleting the manifest module after saving the assembly.
@
text
@d3354 1
d3562 4
@


1.163
log
@Added -win32icon:<file> option to ikvmc.
@
text
@d561 2
a562 4
				Tracer.Info(Tracer.Compiler, "CompilerClassLoader saving temp.$$$ in {0}", assemblyDir);
				string manifestAssembly = "temp.$$$";
				assemblyBuilder.Save(manifestAssembly, options.pekind, options.imageFileMachine);
				File.Delete(assemblyDir + manifestAssembly);
@


1.162
log
@Fixed class name resolution for xml remapping instructions.
@
text
@d3101 11
d3251 1
@


1.161
log
@Added error handling for -remap file errors.
@
text
@d3392 11
@


1.160
log
@Bug fix. Before saving any of the output assemblies, we should first finish all of them (because InternalsVisibleToAttributes may be added as a side effect of compiling code in another assembly).
@
text
@d2817 11
a2827 1
				using(FileStream fs = File.Open(options.remapfile, FileMode.Open))
d2832 2
a2833 1
					if (!loader.ValidateAndSetMap((IKVM.Internal.MapXml.Root)ser.Deserialize(rdr)))
d2835 5
d2842 8
@


1.159
log
@Moved core assembly detection to the right place, to avoid problems when a non-main assembly of the core assembly set is explicitly referenced.
@
text
@d516 1
a516 1
		internal void Save()
a517 1
			Tracer.Info(Tracer.Compiler, "CompilerClassLoader.Save...");
d519 1
d521 2
d2604 5
@


1.158
log
@Don't depend on leave/endfinally instructions being inserted automatically by ILGenerator.
@
text
@d2499 1
a2499 1
		private static bool IsCoreAssembly(Assembly asm)
a2624 4
					if(IsCoreAssembly(reference))
					{
						JVM.CoreAssembly = reference;
					}
@


1.157
log
@Build intermediate store of MSIL code in CodeEmitter to allow post-processing optimization steps.
@
text
@d487 2
d504 1
d507 1
d509 1
@


1.156
log
@Wrapped LocalBuilder in new CodeEmitterLocal class to allow CodeEmitter to encapsulate the ILGenerator fully.
@
text
@d507 1
d1070 1
d1108 1
d1221 1
d1259 1
d1473 1
d1599 1
d1644 1
d1844 1
d1904 1
d2008 2
d2063 2
@


1.155
log
@Renamed StaticCompiler.GetType() that is used exclusively by map.xml processing to make it more obvious and added error message (and abort the compile). The remaining StaticCompiler.GetType() now behaves more like Type.GetType() in that it returns null if the type isn't found.
@
text
@d458 1
a458 1
			LocalBuilder rc = ilgen.DeclareLocal(Types.Int32);
d489 1
a489 1
			LocalBuilder exceptionLocal = ilgen.DeclareLocal(Types.Exception);
d492 1
a492 1
			LocalBuilder threadLocal = ilgen.DeclareLocal(threadTypeWrapper.TypeAsLocalOrStackType);
@


1.154
log
@Added extra indirection thru MethodWrapper for intrinsic method call emitting to allow .NET delegate constructor optimization to use instrinsic infrastructure instead of requiring EmitNewobj to pass a MethodAnalyzer and opcode index.
@
text
@d3335 1
a3335 1
		internal static Type GetType(ClassLoaderWrapper loader, string name)
d3337 7
a3343 1
			return GetType(loader, name, true);
d3346 1
a3346 1
		internal static Type GetType(ClassLoaderWrapper loader, string name, bool throwOnError)
d3349 1
a3349 6
			Type type = ccl.GetTypeFromReferencedAssembly(name);
			if (type == null && throwOnError)
			{
				throw new TypeLoadException(name);
			}
			return type;
@


1.153
log
@Added explanatory message to Link Error is it is caused by a missing reference.
@
text
@d978 1
a978 1
				internal override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
@


1.152
log
@Don't seal @@Internal classes.
@
text
@d3521 4
@


1.151
log
@Massive change to change resource handling. Java resources are now stored in jars that are stored as managed .NET resources. The jars are projected into VFS and the assembly class loaders know how to load resources from these jars.
@
text
@d323 1
@


1.150
log
@Forgot to commit this change when the changes for the target specific warning handling went in.
@
text
@d74 1
d533 1
a533 18
			// add a class.map resource, if needed.
			if(nameMappings.Count > 0)
			{
				string[] list = new string[nameMappings.Count * 2];
				int i = 0;
				foreach(KeyValuePair<string, string> kv in nameMappings)
				{
					list[i++] = kv.Key;
					list[i++] = kv.Value;
				}
				CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(JavaModuleAttribute)).GetConstructor(new Type[] { JVM.Import(typeof(string[])) }), new object[] { list });
				mb.SetCustomAttribute(cab);
			}
			else
			{
				CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(JavaModuleAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
				mb.SetCustomAttribute(cab);
			}
d564 28
d679 1
a679 1
		internal void AddResources(Dictionary<string, byte[]> resources, bool compressedResources)
d682 2
d685 25
a709 1
			foreach(KeyValuePair<string, byte[]> kv in resources)
a710 2
				byte[] buf = kv.Value;
				string name = JVM.MangleResourceName(kv.Key);
d712 1
a712 1
				if(compressedResources)
d714 1
a714 2
					mem.WriteByte(1);
					using(System.IO.Compression.DeflateStream def = new System.IO.Compression.DeflateStream(mem, System.IO.Compression.CompressionMode.Compress, true))
d716 25
a740 1
						def.Write(buf, 0, buf.Length);
d743 3
a745 1
				else
d747 1
a747 2
					mem.WriteByte(0);
					mem.Write(buf, 0, buf.Length);
d749 1
a749 1
				mem.Position = 0;
d3176 7
d3204 1
a3204 1
		internal Dictionary<string, byte[]> resources;
d3234 1
a3234 1
				copy.resources = new Dictionary<string, byte[]>(resources);
d3248 10
@


1.149
log
@Added -writeSuppressWarningsFile:<file> ikvmc option.
@
text
@d3109 5
@


1.148
log
@Made most static compiler warnings local to the target that is being compiled (in multi target mode), to allow warnings to be suppressed (or turned into an error) for a specific target.
@
text
@d3151 1
d3288 4
@


1.147
log
@Add feature to expand environment variables in system properties specified with -D ikvmc option.
@
text
@d285 1
a285 1
						StaticCompiler.IssueMessage(Message.ClassFormatError, name, x.Message);
d339 1
a339 1
						StaticCompiler.IssueMessage(Message.ClassFormatError, name, x.Message);
d344 1
a344 1
						StaticCompiler.IssueMessage(Message.IllegalAccessError, name, x.Message);
d349 1
a349 1
						StaticCompiler.IssueMessage(Message.VerificationError, name, x.Message);
d354 1
a354 1
						StaticCompiler.IssueMessage(Message.NoClassDefFoundError, name, x.Message);
d359 1
a359 1
						StaticCompiler.IssueMessage(Message.GenericUnableToCompileError, name, x.GetType().Name, x.Message);
d2839 1
a2839 1
							StaticCompiler.IssueMessage(Message.SkippingReferencedClass, s, ((AssemblyClassLoader)loader).GetAssembly(wrapper).FullName);
d3149 2
d3171 2
d3222 1
d3267 1
a3267 9
		private static Dictionary<string, string> suppressWarnings = new Dictionary<string, string>();
		private static Dictionary<string, string> errorWarnings = new Dictionary<string, string>();

		internal static void SuppressWarning(string key)
		{
			suppressWarnings[key] = key;
		}

		internal static void WarnAsError(string key)
d3269 1
a3269 1
			errorWarnings[key] = key;
d3272 1
a3272 1
		internal static void IssueMessage(Message msgId, params string[] values)
d3281 2
a3282 2
			if(suppressWarnings.ContainsKey(key)
				|| suppressWarnings.ContainsKey(((int)msgId).ToString()))
d3286 1
a3286 1
			suppressWarnings.Add(key, key);
d3411 2
a3412 2
			if(errorWarnings.ContainsKey(key)
				|| errorWarnings.ContainsKey(((int)msgId).ToString()))
d3420 4
@


1.147.2.1
log
@Don't seal @@Internal classes.
@
text
@a321 1
						&& !f.IsInternal
@


1.147.2.2
log
@Backport: Moved core assembly detection to the right place, to avoid problems when a non-main assembly of the core assembly set is explicitly referenced.
@
text
@d2420 1
a2420 1
		internal static bool IsCoreAssembly(Assembly asm)
d2546 4
@


1.147.2.3
log
@Backport: Bug fix. Before saving any of the output assemblies, we should first finish all of them (because InternalsVisibleToAttributes may be added as a side effect of compiling code in another assembly).
@
text
@d509 1
a509 1
		private void PrepareSave()
d511 1
a512 1
		}
a513 2
		private void Save()
		{
a2522 5
				Tracer.Info(Tracer.Compiler, "CompilerClassLoader.Save...");
				foreach (CompilerClassLoader compiler in compilers)
				{
					compiler.PrepareSave();
				}
@


1.146
log
@Set type name as exception message.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
d466 4
@


1.145
log
@When we're compiling with the -sharedclassloader option we can't do the "effectively final" optimization, because classes in another assembly can be part of the same package (and hence extend the packge private class).
@
text
@d3238 1
a3238 1
				throw new TypeLoadException();
@


1.144
log
@We don't need to use our own version of IsDefined to test for custom attributes, because there is no confusion about what runtime types to use anymore.
@
text
@d324 2
a325 1
						&& !options.targetIsModule)
@


1.143
log
@Removed JVM.GetType().
@
text
@d2416 1
a2416 1
			return AttributeHelper.IsDefined(asm, StaticCompiler.GetRuntimeType("IKVM.Attributes.RemappedClassAttribute"));
@


1.142
log
@Fixed regression introduced when ikvm.runtime.Startup.setProperties() signature was changed. It should also be changed here. Also changed to using Dictionary<string, string> instead of Hashtable.
@
text
@d762 1
a762 1
				shadowType = JVM.GetType(c.Shadows, true);
d1591 1
a1591 1
						Type type = m.redirect.Class == null ? baseType : JVM.GetType(m.redirect.Class, true);
d2200 1
a2200 1
					ilgen.Emit(OpCodes.Ldtoken, JVM.GetType(map[i].src, true));
@


1.141
log
@Made all AssemblyResolver warnings into formal ikvmc warnings.
@
text
@d459 1
a459 1
				ilgen.Emit(OpCodes.Newobj, JVM.Import(typeof(System.Collections.Hashtable)).GetConstructor(Type.EmptyTypes));
d465 1
a465 1
					ilgen.Emit(OpCodes.Callvirt, JVM.Import(typeof(System.Collections.Hashtable)).GetMethod("Add"));
d467 1
a467 1
				startupType.GetMethodWrapper("setProperties", "(Lcli.System.Collections.Hashtable;)V", false).EmitCall(ilgen);
@


1.140
log
@Fix. Imported the wrong types.
@
text
@d3201 5
d3391 15
@


1.139
log
@Changed StaticCompiler.GetType() to be multi-target aware. Instead of looking thru all assemblies currently loaded, only the relevant referenced assemblies are searched.

Note that this is a (minor) breaking change. Types referenced in -remap:map.xml file are now only resolved against directly referenced assemblies.
@
text
@d2983 2
a2984 2
					ilgen.Emit(OpCodes.Call, JVM.Import(typeof(MethodBase)).GetMethod("GetMethodFromHandle", new Type[] { JVM.Import(typeof(RuntimeMethodHandle)) }));
					ilgen.Emit(OpCodes.Callvirt, JVM.Import(typeof(MemberInfo)).GetMethod("get_Module"));
@


1.138
log
@Moved resolver back to compiler from StaticCompiler, because messing with StaticCompiler.LoadFile isn't a good idea.
@
text
@d3091 13
d3236 1
a3236 3
		// TODO this method should be removed, because it is not multi target aware (it looks inside all loaded ReflectionOnly assemblies,
		// instead of just the ones that are supposed to be visible to a particular target)
		internal static Type GetType(string name)
d3238 1
a3238 1
			return GetType(name, true);
d3241 1
a3241 3
		// TODO this method should be removed, because it is not multi target aware (it looks inside all loaded ReflectionOnly assemblies,
		// instead of just the ones that are supposed to be visible to a particular target)
		internal static Type GetType(string name, bool throwOnError)
d3243 3
a3245 1
			if(runtimeAssembly.GetType(name) != null)
d3247 1
a3247 13
				return runtimeAssembly.GetType(name);
			}
			if(runtimeJniAssembly != null && runtimeJniAssembly.GetType(name) != null)
			{
				return runtimeJniAssembly.GetType(name);
			}
			foreach(Assembly asm in Universe.GetAssemblies())
			{
				Type t = asm.GetType(name, false);
				if(t != null)
				{
					return t;
				}
d3249 1
a3249 2
			// try mscorlib as well
			return Types.Object.Assembly.GetType(name, throwOnError);
@


1.137
log
@Added check to avoid loading assemblies that require a newer version of mscorlib than the one were using (to avoid weird exceptions and potential other problems).
@
text
@a3192 1
		internal static readonly AssemblyResolver Resolver = new AssemblyResolver();
d3203 1
a3203 1
			return Resolver.LoadFile(path);
@


1.136
log
@Hookup AssemblyResolver's assembly version warning in ikvmc.
@
text
@d3193 1
d3204 1
a3204 1
			return Universe.LoadFile(path);
@


1.135
log
@Added ikvmc -delaysign option.
@
text
@d3187 1
d3385 3
@


1.134
log
@Added support for AssemblyVersionAttribute and AssemblyCultureAttribute to ikvmc.
Added warnings for AssemblyDelaySignAttribute, AssemblyKeyFileAttribute and AssemblyKeyNameAttribute.
Throw NotImplementedException for AssemblyAlgorithmIdAttribute and AssemblyFlagsAttribute (that exception isn't reachable because these two attributes are not exposed as annotations.)
@
text
@d142 8
a149 1
			name.KeyPair = options.key;
d2781 1
a2781 1
			if(options.key != null && !allReferencesAreStrongNamed)
d3096 5
a3100 1
		internal StrongNameKeyPair key;
@


1.133
log
@Avoid depending on IKVM.Reflection specific pseudo custom attribute support that will be removed in the future (TypeForwardedToAttribute and DefaultParameterValueAttribute).
@
text
@d3174 2
d3365 8
@


1.132
log
@Give a propery error message instead of dying with an exception if output file can't be created/overwritten.
@
text
@d2484 1
a2484 1
			Dictionary<CompilerClassLoader, CustomAttributeBuilder> mainAssemblyCabs = new Dictionary<CompilerClassLoader, CustomAttributeBuilder>();
d2489 2
a2490 2
					CustomAttributeBuilder mainAssembly;
					if (!mainAssemblyCabs.TryGetValue(compiler.options.sharedclassloader[0], out mainAssembly))
d2494 2
a2495 2
						mainAssembly = new CustomAttributeBuilder(JVM.Import(typeof(TypeForwardedToAttribute)).GetConstructor(new Type[] { Types.Type }), new object[] { tb.CreateType() });
						mainAssemblyCabs.Add(compiler.options.sharedclassloader[0], mainAssembly);
d2499 1
a2499 1
						((AssemblyBuilder)compiler.GetTypeWrapperFactory().ModuleBuilder.Assembly).SetCustomAttribute(mainAssembly);
a2926 1
					// TODO we should support pseudo custom attributes that Ref.Emit doesn't support (e.g. AssemblyVersionAttribute)
@


1.131
log
@Added parameter validation to ikvmc's -version option (fix bug #2987144 ).
@
text
@d2508 1
a2508 1
			foreach (CompilerClassLoader compiler in compilers)
d2510 9
a2518 1
				compiler.Save();
@


1.130
log
@Simplified StrongNameKey handling and added command line argument validation to ikvmc -key: and -keyfile: options.
@
text
@a51 1
		private string version;
d75 1
a75 1
		internal CompilerClassLoader(AssemblyClassLoader[] referencedAssemblies, CompilerOptions options, string path, string version, bool targetIsModule, string assemblyName, Dictionary<string, byte[]> classes)
a85 1
			this.version = version;
d143 1
a143 1
			name.Version = new Version(version);
d2704 1
a2704 1
			loader = new CompilerClassLoader(referencedAssemblies, options, options.path, options.version, options.targetIsModule, options.assembly, h);
d3083 1
a3083 1
		internal string version;
@


1.129
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@a51 2
		private string keyfilename;
		private string keycontainer;
d76 1
a76 1
		internal CompilerClassLoader(AssemblyClassLoader[] referencedAssemblies, CompilerOptions options, string path, string keyfilename, string keycontainer, string version, bool targetIsModule, string assemblyName, Dictionary<string, byte[]> classes)
a87 2
			this.keyfilename = keyfilename;
			this.keycontainer = keycontainer;
d144 1
a144 8
			if(keyfilename != null) 
			{
				name.KeyPair = new StrongNameKeyPair(File.ReadAllBytes(keyfilename));
			}
			if(keycontainer != null)
			{
				name.KeyPair = new StrongNameKeyPair(keycontainer);
			}
d2706 1
a2706 1
			loader = new CompilerClassLoader(referencedAssemblies, options, options.path, options.keyfilename, options.keycontainer, options.version, options.targetIsModule, options.assembly, h);
d2768 1
a2768 1
			if((options.keycontainer != null || options.keyfilename != null) && !allReferencesAreStrongNamed)
d3084 1
a3084 2
		internal string keyfilename;
		internal string keycontainer;
@


1.128
log
@Integrated new IKVM.Reflection implementation.
@
text
@a25 1
#if IKVM_REF_EMIT
a28 4
#else
using System.Reflection;
using System.Reflection.Emit;
#endif
a143 38
#if !NET_4_0 && !IKVM_REF_EMIT
		private void GetAssemblyPermissions(out PermissionSet requiredPermissions, out PermissionSet optionalPermissions, out PermissionSet refusedPermissions)
		{
			requiredPermissions = null;
			optionalPermissions = null;
			refusedPermissions = null;
			foreach (object[] def in assemblyAnnotations)
			{
				string annotationClass = (string)def[1];
				annotationClass = annotationClass.Replace('/', '.').Substring(1, annotationClass.Length - 2);
				if (annotationClass.EndsWith(DotNetTypeWrapper.AttributeAnnotationSuffix))
				{
					Type annot = JVM.GetType(DotNetTypeWrapper.DemangleTypeName(annotationClass.Substring(0, annotationClass.Length - DotNetTypeWrapper.AttributeAnnotationSuffix.Length)), false);
					if (annot != null && annot.IsSubclassOf(JVM.Import(typeof(SecurityAttribute))))
					{
						SecurityAction action;
						PermissionSet permSet;
						if (Annotation.MakeDeclSecurity(annot, def, out action, out permSet))
						{
							switch (action)
							{
								case SecurityAction.RequestMinimum:
									requiredPermissions = Combine(requiredPermissions, permSet);
									break;
								case SecurityAction.RequestOptional:
									optionalPermissions = Combine(optionalPermissions, permSet);
									break;
								case SecurityAction.RequestRefuse:
									refusedPermissions = Combine(refusedPermissions, permSet);
									break;
							}
						}
					}
				}
			}
		}
#endif

a156 1
#if NET_4_0 || IKVM_REF_EMIT
a157 1
#if IKVM_REF_EMIT
a158 3
#else
				AppDomain.CurrentDomain
#endif
a159 9
#else
			PermissionSet requiredPermissions;
			PermissionSet optionalPermissions;
			PermissionSet refusedPermissions;
			GetAssemblyPermissions(out requiredPermissions, out optionalPermissions, out refusedPermissions);
			assemblyBuilder = 
				AppDomain.CurrentDomain
					.DefineDynamicAssembly(name, AssemblyBuilderAccess.ReflectionOnly, assemblyDir, requiredPermissions, optionalPermissions, refusedPermissions);
#endif
a1867 1
#if IKVM_REF_EMIT
a1874 15
#else
				foreach (object attr in mi.GetCustomAttributes(false))
				{
					CodeAccessSecurityAttribute cas = attr as CodeAccessSecurityAttribute;
					if (cas != null)
					{
						if (cas.Action == SecurityAction.LinkDemand)
						{
							PermissionSet pset = new PermissionSet(PermissionState.None);
							pset.AddPermission(cas.CreatePermission());
							mb.AddDeclarativeSecurity(SecurityAction.LinkDemand, pset);
						}
					}
				}
#endif
a2579 33
#if !IKVM_REF_EMIT
			bool err = false;
			foreach(Assembly reference in references)
			{
				try
				{
					reference.GetTypes();
				}
				catch(ReflectionTypeLoadException x)
				{
					err = true;
					foreach(Exception n in x.LoaderExceptions)
					{
						FileNotFoundException f = n as FileNotFoundException;
						if(f != null)
						{
							Console.Error.WriteLine("Error: referenced assembly {0} has a missing dependency: {1}", reference.GetName().Name, f.FileName);
							goto next;
						}
					}
					Console.Error.WriteLine("Error: referenced assembly produced the following loader exceptions:");
					foreach(Exception n in x.LoaderExceptions)
					{
						Console.WriteLine(n.Message);
					}
				}
			next:;
			}
			if(err)
			{
				return 1;
			}
#endif
a2799 31
#if !IKVM_REF_EMIT
			if (asm.GetManifestResourceInfo("ikvm.exports") != null)
			{
				// If this is the main assembly in a multi assembly group, try to pre-load all the assemblies.
				// (This is required to make Assembly.ReflectionOnlyLoad() work later on (because it doesn't fire the ReflectionOnlyAssemblyResolve event).)
				using (Stream stream = asm.GetManifestResourceStream("ikvm.exports"))
				{
					BinaryReader rdr = new BinaryReader(stream);
					int assemblyCount = rdr.ReadInt32();
					for (int i = 0; i < assemblyCount; i++)
					{
						AssemblyName name = new AssemblyName(rdr.ReadString());
						int typeCount = rdr.ReadInt32();
						if (typeCount > 0)
						{
							for (int j = 0; j < typeCount; j++)
							{
								rdr.ReadInt32();
							}
							try
							{
								Assembly.ReflectionOnlyLoadFrom(asm.CodeBase + "/../" + name.Name + ".dll");
							}
							catch
							{
							}
						}
					}
				}
			}
#endif
@


1.127
log
@Handle missing sig attribute.
@
text
@a25 1
using System.Reflection;
d27 1
d29 1
d31 1
d203 1
a203 1
				AssemblyBuilder
d1925 9
d1947 1
d2519 2
a2520 9
					// HACK based on our assembly name we create the default runtime assembly name
					AssemblyName compilerAssembly = typeof(CompilerClassLoader).Assembly.GetName();
					StaticCompiler.runtimeAssembly = StaticCompiler.Load(compilerAssembly.FullName.Replace(compilerAssembly.Name, "IKVM.Runtime"));
					StaticCompiler.runtimeJniAssembly = StaticCompiler.Load(compilerAssembly.FullName.Replace(compilerAssembly.Name, "IKVM.Runtime.JNI"));
				}
				else
				{
					StaticCompiler.runtimeAssembly = StaticCompiler.LoadFile(runtimeAssembly);
					StaticCompiler.runtimeJniAssembly = StaticCompiler.LoadFile(Path.Combine(StaticCompiler.runtimeAssembly.CodeBase, ".." + Path.DirectorySeparatorChar + "IKVM.Runtime.JNI.dll"));
d2522 2
d2653 1
d2685 1
a2685 14
			// If the "System" assembly wasn't explicitly referenced, load it automatically
			bool systemIsLoaded = false;
			foreach(Assembly asm in AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies())
			{
				if(asm.GetType("System.ComponentModel.EditorBrowsableAttribute") != null)
				{
					systemIsLoaded = true;
					break;
				}
			}
			if(!systemIsLoaded)
			{
				Assembly.ReflectionOnlyLoadFrom(JVM.Import(typeof(System.ComponentModel.EditorBrowsableAttribute)).Assembly.Location);
			}
d2859 1
a2859 1
						asm = StaticCompiler.Load(name.FullName);
a2862 7
						try
						{
							asm = LoadReferencedAssembly(StaticCompiler.runtimeAssembly.CodeBase + "/../" + name.Name + ".dll");
						}
						catch(FileNotFoundException)
						{
						}
d2906 1
d2936 1
d3322 1
d3328 1
a3328 1
			return Assembly.ReflectionOnlyLoad(assemblyString);
d3333 1
a3333 1
			return Assembly.ReflectionOnlyLoadFrom(path);
d3372 1
a3372 1
			foreach(Assembly asm in AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies())
@


1.126
log
@Added basic signature validation for remap file (map.xml). Fixes bug 2908683.
@
text
@d3235 1
a3235 1
			return field ? ClassFile.IsValidFieldSig(sig) : ClassFile.IsValidMethodSig(sig);
@


1.125
log
@Load the runtime only once, instead of for each target.
@
text
@d2843 4
a2846 1
					loader.map = (IKVM.Internal.MapXml.Root)ser.Deserialize(rdr);
d3150 87
@


1.124
log
@Mangle all artificial type names if they clash with Java type names in the same assembly.
@
text
@d2501 1
a2501 1
		internal static int Compile(List<CompilerOptions> optionsList)
d2503 25
a2596 25
			try
			{
				if(options.runtimeAssembly == null)
				{
					// HACK based on our assembly name we create the default runtime assembly name
					AssemblyName compilerAssembly = typeof(CompilerClassLoader).Assembly.GetName();
					StaticCompiler.runtimeAssembly = StaticCompiler.Load(compilerAssembly.FullName.Replace(compilerAssembly.Name, "IKVM.Runtime"));
					StaticCompiler.runtimeJniAssembly = StaticCompiler.Load(compilerAssembly.FullName.Replace(compilerAssembly.Name, "IKVM.Runtime.JNI"));
				}
				else
				{
					StaticCompiler.runtimeAssembly = StaticCompiler.LoadFile(options.runtimeAssembly);
					StaticCompiler.runtimeJniAssembly = StaticCompiler.LoadFile(Path.Combine(StaticCompiler.runtimeAssembly.CodeBase, ".." + Path.DirectorySeparatorChar + "IKVM.Runtime.JNI.dll"));
				}
			}
			catch(FileNotFoundException)
			{
				if(StaticCompiler.runtimeAssembly == null)
				{
					Console.Error.WriteLine("Error: unable to load runtime assembly");
					return 1;
				}
				StaticCompiler.IssueMessage(Message.NoJniRuntime);
			}
			Tracer.Info(Tracer.Compiler, "Loaded runtime assembly: {0}", StaticCompiler.runtimeAssembly.FullName);
a3174 1
		internal string runtimeAssembly;
@


1.123
log
@Type export map performance bug fix by Eyal Alaluf. AssemblyName doesn't implement Equals/GetHashCode and this caused the map to contain an assembly entry for every type.
@
text
@d98 5
@


1.122
log
@- Fixed IsPackageAccessibleFrom to consider class loaders, instead of InternalsVisibleToAttribute
- Added automatic access to internal accessibility members across assemblies in multi target compilation (previously this was only done for -sharedclassloader scenarios)
- Cleaned up existing field access stubs (now known as "type 1") and added type 2 access stubs to make public fields that have a non-public field type accessible.
@
text
@d631 1
a631 1
		private static void AddExportMapEntry(Dictionary<AssemblyName, List<string>> map, CompilerClassLoader ccl, string name)
d633 1
a633 1
			AssemblyName asm = ccl.assemblyBuilder.GetName();
d635 1
a635 1
			if (!map.TryGetValue(asm, out list))
d638 1
a638 1
				map.Add(asm, list);
d646 1
a646 1
		private void AddWildcardExports(Dictionary<AssemblyName, List<string>> exportedNamesPerAssembly)
d650 1
a650 1
				exportedNamesPerAssembly[acl.MainAssembly.GetName()] = null;
d656 1
a656 1
			Dictionary<AssemblyName, List<string>> exportedNamesPerAssembly = new Dictionary<AssemblyName, List<string>>();
d666 1
a666 1
					exportedNamesPerAssembly[ccl.assemblyBuilder.GetName()] = null;
d696 1
a696 1
			foreach (KeyValuePair<AssemblyName, List<string>> kv in exportedNamesPerAssembly)
d698 1
a698 1
				bw.Write(kv.Key.FullName);
@


1.121
log
@Import types.
@
text
@d435 20
d465 1
a465 3
			if (ccl != null
				&& options.sharedclassloader != null
				&& options.sharedclassloader.Contains(ccl))
d467 1
a467 2
				AddInternalsVisibleToAttribute(ccl.assemblyBuilder);
				internalsVisibleTo.Add(other);
d473 1
a473 1
		private void AddInternalsVisibleToAttribute(AssemblyBuilder asm)
d475 2
@


1.120
log
@Use IKVM.Reflection.Emit's new-style declarative security APIs.
@
text
@d3102 2
a3103 2
					ilgen.Emit(OpCodes.Call, typeof(MethodBase).GetMethod("GetMethodFromHandle", new Type[] { typeof(RuntimeMethodHandle) }));
					ilgen.Emit(OpCodes.Callvirt, typeof(MemberInfo).GetMethod("get_Module"));
@


1.119
log
@Added comment to remind that some pseudo custom assembly attributes aren't supported.
@
text
@d142 1
a142 1
#if !NET_4_0
d193 1
a193 1
#if NET_4_0
a206 3
#if IKVM_REF_EMIT
				AssemblyBuilder
#else
a207 1
#endif
@


1.118
log
@Added ikvmc option -nopeercrossreference and the ability to use -r with peer assemblies.
@
text
@d3056 1
@


1.117
log
@Added (optional) per-module initialization to custom assembly class loaders.
@
text
@d255 12
a266 10
						// To keep the performance acceptable in cases where we're compiling many targets, we first check if the load can
						// possibly succeed on this class loader, otherwise we'll end up doing a lot of futile recursive loading attempts.
						if (ccl.classes.ContainsKey(name) || ccl.remapped.ContainsKey(name) || ccl.GetLoadedClass(name) != null)
						{
							TypeWrapper tw = ccl.LoadClassByDottedNameFast(name);
							// HACK we don't want to load classes referenced by peers, hence the "is CompilerClassLoader" check
							if (tw != null && tw.GetClassLoader() is CompilerClassLoader)
							{
								return tw;
							}
d280 7
d290 30
d2503 2
a2504 1
					if (compiler1 != compiler2)
d2580 1
a2580 1
			foreach(Assembly reference in options.references)
d3142 1
d3144 2
@


1.116
log
@Add -publicpackage:<pkg> option to ikvmc.
@
text
@d3057 13
@


1.115
log
@In a non-sharedclassloader multi target scenario, peer assemblies should automatically reference eachother.
Fix for bug #2883889.
@
text
@d324 16
d3100 1
@


1.114
log
@Use cached methods instead of looking them up again.
@
text
@d592 8
a599 1
			if (options.sharedclassloader != null)
@


1.113
log
@More ikvmc assembly/type refactoring.
@
text
@d2181 1
a2181 2
				ilgen.Emit(OpCodes.Callvirt, Types.Object.GetMethod("GetType"));
				MethodInfo GetTypeFromHandle = Types.Type.GetMethod("GetTypeFromHandle");
d2186 1
a2186 1
					ilgen.Emit(OpCodes.Call, GetTypeFromHandle);
@


1.112
log
@Removed .NET 4.0 beta 1 workarounds and did some minor updates for .NET 4.0 beta 2.
@
text
@d2402 1
a2402 1
			return AttributeHelper.IsDefined(asm, StaticCompiler.GetType("IKVM.Attributes.RemappedClassAttribute"));
d2495 3
a2497 3
					Assembly compilerAssembly = typeof(CompilerClassLoader).Assembly;
					StaticCompiler.runtimeAssembly = Assembly.ReflectionOnlyLoad(compilerAssembly.FullName.Replace(compilerAssembly.GetName().Name, "IKVM.Runtime"));
					StaticCompiler.runtimeJniAssembly = Assembly.ReflectionOnlyLoad(compilerAssembly.FullName.Replace(compilerAssembly.GetName().Name, "IKVM.Runtime.JNI"));
d2501 2
a2502 2
					StaticCompiler.runtimeAssembly = Assembly.ReflectionOnlyLoadFrom(options.runtimeAssembly);
					StaticCompiler.runtimeJniAssembly = Assembly.ReflectionOnlyLoadFrom(Path.Combine(StaticCompiler.runtimeAssembly.CodeBase, ".." + Path.DirectorySeparatorChar + "IKVM.Runtime.JNI.dll"));
d2599 1
a2599 1
				if(asm.GetType("System.ComponentModel.EditorBrowsableAttribute", false, false) != null)
d2779 1
a2779 1
						asm = Assembly.ReflectionOnlyLoad(name.FullName);
d2832 1
a2832 1
			Assembly asm = Assembly.ReflectionOnlyLoadFrom(r);
d3141 1
a3141 1
	class StaticCompiler
d3146 29
d3180 2
@


1.111
log
@Resolve reference assemblies early on, to avoid having to do it multiple times in a multi target scenario.
@
text
@a225 8
			if(Environment.Version.Major == 4 && Environment.Version.Minor == 0 && Environment.Version.Build == 20506)
			{
				// FXBUG workaround for MethodImpl bug in .NET 4.0 beta 1
				assemblyBuilder.SetCustomAttribute(
					new CustomAttributeBuilder(
						Type.GetType("System.Security.SecurityRulesAttribute").GetConstructor(new Type[] { Type.GetType("System.Security.SecurityRuleSet") }),
						new object[] { Type.GetType("System.Security.SecurityRuleSet").GetField("Level1").GetValue(null) }));
			}
@


1.110
log
@More type funneling.
@
text
@d749 1
a749 1
				shadowType = Type.GetType(c.Shadows, true);
d2526 1
a2526 1
			foreach(string r in options.references)
a2529 1
					Assembly reference = LoadReferencedAssembly(r);
a2533 5
					if(reference == null)
					{
						Console.Error.WriteLine("Error: reference not found: {0}", r);
						return 1;
					}
d2547 1
a2547 1
									Console.Error.WriteLine("Error: referenced assembly {0} was compiled with an incompatible IKVM.Runtime version ({1})", r, asmref.Version);
d2557 1
a2557 1
									Console.Error.WriteLine("Error: referenced assembly {0} was compiled with an incompatible (signed) IKVM.Runtime version", r);
d2568 1
a2568 1
					Console.Error.WriteLine("Error: invalid reference: {0} ({1})", r, x.Message);
d3075 1
a3075 1
		internal string[] references;
@


1.109
log
@Replaced most type literals with static field access (in Types class) or warpped JVM.Import() around them.
@
text
@d154 1
a154 1
					Type annot = Type.GetType(DotNetTypeWrapper.DemangleTypeName(annotationClass.Substring(0, annotationClass.Length - DotNetTypeWrapper.AttributeAnnotationSuffix.Length)));
d1578 1
a1578 1
						Type type = m.redirect.Class == null ? baseType : Type.GetType(m.redirect.Class, true);
d2194 1
a2194 1
					ilgen.Emit(OpCodes.Ldtoken, Type.GetType(map[i].src));
@


1.108
log
@Moved GetAssemblyClassLoader() (and related stuff) from ClassLoaderWrapper to AssemblyClassLoader and renamed it to FromAssembly().
@
text
@d155 1
a155 1
					if (annot != null && annot.IsSubclassOf(typeof(SecurityAttribute)))
d222 1
a222 1
				CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, this.EmitDebugInfo });
d432 1
a432 1
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(InternalsVisibleToAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { name });
d441 1
a441 1
				args = new Type[] { typeof(string[]) };
d443 1
a443 1
			MethodBuilder mainStub = this.GetTypeWrapperFactory().ModuleBuilder.DefineGlobalMethod("main", MethodAttributes.Public | MethodAttributes.Static, typeof(int), args);
d449 1
a449 1
			LocalBuilder rc = ilgen.DeclareLocal(typeof(int));
d453 1
a453 1
				ilgen.Emit(OpCodes.Newobj, typeof(System.Collections.Hashtable).GetConstructor(Type.EmptyTypes));
d459 1
a459 1
					ilgen.Emit(OpCodes.Callvirt, typeof(System.Collections.Hashtable).GetMethod("Add"));
d474 1
a474 1
			ilgen.BeginCatchBlock(typeof(Exception));
d476 1
a476 1
			LocalBuilder exceptionLocal = ilgen.DeclareLocal(typeof(Exception));
d531 1
a531 1
				CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(JavaModuleAttribute)).GetConstructor(new Type[] { typeof(string[]) }), new object[] { list });
d545 1
a545 1
				mb.SetCustomAttribute(new CustomAttributeBuilder(JVM.LoadType(typeof(PackageListAttribute)).GetConstructor(new Type[] { typeof(string[]) }), new object[] { list }));
d777 1
a777 1
				typeBuilder = classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(name, attrs, baseIsSealed ? typeof(object) : baseType);
d1886 1
a1886 1
				MethodBuilder mb = typeBuilder.DefineMethod("__<instanceof>", attr, typeof(bool), new Type[] { typeof(object) });
d1903 1
a1903 1
				if(shadowType == typeof(object))
d1906 1
a1906 1
					ilgen.Emit(OpCodes.Isinst, typeof(Array));
d1935 1
a1935 1
				MethodBuilder mb = typeBuilder.DefineMethod("__<checkcast>", attr, shadowType, new Type[] { typeof(object) });
d1951 1
a1951 1
				if(shadowType == typeof(object))
d1954 1
a1954 1
					ilgen.Emit(OpCodes.Isinst, typeof(Array));
d1976 1
a1976 1
					ilgen.ThrowException(typeof(InvalidCastException));
d2059 1
a2059 1
					return shadowType == typeof(Exception) || shadowType.IsSubclassOf(typeof(Exception));
d2189 2
a2190 2
				ilgen.Emit(OpCodes.Callvirt, typeof(Object).GetMethod("GetType"));
				MethodInfo GetTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle");
d2352 1
a2352 1
			TypeWrapper array = ClassLoaderWrapper.GetWrapperFromType(typeof(Array));
d2474 1
a2474 1
						mainAssembly = new CustomAttributeBuilder(typeof(TypeForwardedToAttribute).GetConstructor(new Type[] { typeof(Type) }), new object[] { tb.CreateType() });
d2621 1
a2621 1
				Assembly.ReflectionOnlyLoadFrom(typeof(System.ComponentModel.EditorBrowsableAttribute).Assembly.Location);
d2965 1
a2965 1
					apartmentAttributeType = typeof(STAThreadAttribute);
d2969 1
a2969 1
					apartmentAttributeType = typeof(MTAThreadAttribute);
d3000 1
a3000 1
				CustomAttributeBuilder filever = new CustomAttributeBuilder(typeof(AssemblyFileVersionAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { options.fileversion });
d3047 1
a3047 1
				ConstructorInfo ci = JVM.LoadType(typeof(CustomAssemblyClassLoaderAttribute)).GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { typeof(Type) }, null);
d3184 1
a3184 1
			return typeof(object).Assembly.GetType(name, throwOnError);
@


1.108.2.1
log
@In a non-sharedclassloader multi target scenario, peer assemblies should automatically reference eachother.
Fix for bug #2883889.
@
text
@d600 1
a600 8
			if (options.sharedclassloader == null)
			{
				foreach (CompilerClassLoader ccl in peerReferences)
				{
					exportedNamesPerAssembly[ccl.assemblyBuilder.GetName()] = null;
				}
			}
			else
@


1.108.2.2
log
@Type export map performance bug fix by Eyal Alaluf. AssemblyName doesn't implement Equals/GetHashCode and this caused the map to contain an assembly entry for every type.
@
text
@d569 1
a569 1
		private static void AddExportMapEntry(Dictionary<string, List<string>> map, CompilerClassLoader ccl, string name)
d571 1
a571 1
			string assemblyName = ccl.assemblyBuilder.FullName;
d573 1
a573 1
			if (!map.TryGetValue(assemblyName, out list))
d576 1
a576 1
				map.Add(assemblyName, list);
d584 1
a584 1
		private void AddWildcardExports(Dictionary<string, List<string>> exportedNamesPerAssembly)
d588 1
a588 1
				exportedNamesPerAssembly[acl.MainAssembly.FullName] = null;
d594 1
a594 1
			Dictionary<string, List<string>> exportedNamesPerAssembly = new Dictionary<string, List<string>>();
d604 1
a604 1
					exportedNamesPerAssembly[ccl.assemblyBuilder.FullName] = null;
d634 1
a634 1
			foreach (KeyValuePair<string, List<string>> kv in exportedNamesPerAssembly)
d636 1
a636 1
				bw.Write(kv.Key);
@


1.108.2.3
log
@- Update version to 0.42.0.4
Backported:
- Mangle all artificial type names if they clash with Java type names in the same assembly.
- Fix for http://gcc.gnu.org/bugzilla/show_bug.cgi?id=41696
- Fixed exception sorter to be correct when invoked with two references to the same object.
@
text
@a97 5
		internal bool ReserveName(string javaName)
		{
			return !classes.ContainsKey(javaName) && GetTypeWrapperFactory().ReserveName(javaName);
		}

@


1.107
log
@Removed EmitHelper class and moved its methods into CodeEmitter.
@
text
@d2758 1
a2758 1
				referencedAssemblies[i] = ClassLoaderWrapper.GetAssemblyClassLoader(references[i]);
d2823 1
a2823 1
				loader.AddReference(ClassLoaderWrapper.GetAssemblyClassLoader(JVM.CoreAssembly));
@


1.106
log
@Small code cleanup. Changed a couple of abstract methods in TypeWrapper to virtual and provided a default implementation and removed the implementation from a number of subclasses.
@
text
@d1410 1
a1410 1
							EmitHelper.NullCheck(ilgen);
d1970 1
a1970 1
				EmitHelper.Castclass(ilgen, shadowType);
@


1.105
log
@Added support for overriding methods in shadow type.
@
text
@a2062 20
			internal override string GetGenericSignature()
			{
				return null;
			}

			internal override string GetGenericMethodSignature(MethodWrapper mw)
			{
				return null;
			}

			internal override string GetGenericFieldSignature(FieldWrapper fw)
			{
				return null;
			}

			internal override string[] GetEnclosingMethod()
			{
				return null;
			}

@


1.104
log
@Added methods defined in map.xml to methods dictionary, before adding the inherited methods that we want to hide, to avoid adding a method that we already explicitly defined (e.g. to override) in map.xml.
@
text
@d1215 9
@


1.103
log
@We shouldn't generate an instancehelper_ method for map.xml methods that have the HideFromJavaAttribute.
@
text
@d1769 8
@


1.102
log
@Fixed regression introduced with the switch to IKVM.Reflection.Emit. We cannot use the Type.Assembly property for TypeBuilders.
@
text
@d1252 1
a1252 1
						if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) == 0)
d1299 15
@


1.101
log
@Moved responsibility for creating java.lang.Class instances for "fast literal" enable types into ClassLiteral<T>, this allows class literals to be really cheap, because non of the underlying reflection is needed, the class will cache the Type and lazily resolve it to its TypeWrapper.
@
text
@d3014 1
a3014 1
				if(!wrapper.IsPublic && !wrapper.TypeAsBaseType.Assembly.Equals(assemblyBuilder))
@


1.100
log
@Added -baseaddress:<address> option to ikvmc.
@
text
@d2050 5
@


1.99
log
@Added "RuntimeCompatibilityAttribute(WrapNonExceptionThrows = true)" to generated assemblies.
@
text
@d234 4
d3080 1
@


1.98
log
@Added ikvmc warnings for VerificationError and ClassFormatError.
@
text
@d225 1
@


1.97
log
@- When building for .NET 4.0, don't use DefineDynamicAssembly() overload that takes assembly permission sets, because .NET 4.0 ignores them anyway.
- Fixed BakedTypeCleanupHack to work for .NET 2.0 SP2.
- Changes to remove warnings when building on .NET 4.0
@
text
@d3128 2
d3279 8
@


1.96
log
@When building for .NET 4.0 we can derived ModuleBuilder from Module and AssemblyBuilder from Assembly.
@
text
@d142 1
d178 1
d193 9
d213 1
@


1.95
log
@Preparing for .NET 4.0:
- Added SecurityRules(Level1) attribute to IKVM.Runtime.dll to (temporarily) opt out of new .NET 4.0 security model.
- Changed compiler/runtime to automatically add SecurityRules(Level1) attribute when running on .NET 4.0 beta 1 to work around bug in the handling of MethodImpls in beta 1.
@
text
@d2445 1
a2445 1
						compiler.GetTypeWrapperFactory().ModuleBuilder.Assembly.SetCustomAttribute(mainAssembly);
@


1.94
log
@Added support for assembly declarative security pseudo custom attribute annotations.
@
text
@d213 8
@


1.93
log
@Added (limited) support for defining instance fields on remapped types. The fields will only be available on the actual implementation types, not the types they shadow (accessing the field on a shadow instance is undefined, but for reflection we'll at least guarantee that an exception is thrown (current java.lang.IllegalArgumentException)).
@
text
@d129 49
d191 4
d201 1
a201 1
				.DefineDynamicAssembly(name, AssemblyBuilderAccess.ReflectionOnly, assemblyDir);
@


1.93.2.1
log
@Fixed regression introduced in 0.40 that caused ikvmc -classloader:<class> option to fail if <class> wasn't public.
@
text
@d2931 1
a2931 1
				if(!wrapper.IsPublic && !ReflectUtil.IsFromAssembly(wrapper.TypeAsBaseType, assemblyBuilder))
@


1.92
log
@Roll back previous accidental commit.
@
text
@d1586 1
a1586 1
						else if((f.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) != 0)
d1588 1
a1588 1
							FieldAttributes attr = MapFieldAccessModifiers(f.Modifiers) | FieldAttributes.Static;
d1597 4
a1628 6
						else
						{
							// TODO we should support adding arbitrary instance fields (the runtime will have to use
							// a weak identity hashtable to store the extra information for subclasses that don't extend our stub)
							throw new NotImplementedException(this.Name + "." + f.Name + f.Sig);
						}
@


1.91
log
@Added newarr opcode.
@
text
@d1586 1
a1586 1
						else if(true || (f.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) != 0)
d1588 1
a1588 1
							FieldAttributes attr = MapFieldAccessModifiers(f.Modifiers);// | FieldAttributes.Static;
a1596 4
							if((f.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) != 0)
							{
								attr |= FieldAttributes.Static;
							}
@


1.90
log
@Implemented ikvm.internal.ClassLiteral<T> to allow for more efficient class literals.
@
text
@d1586 1
a1586 1
						else if((f.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) != 0)
d1588 1
a1588 1
							FieldAttributes attr = MapFieldAccessModifiers(f.Modifiers) | FieldAttributes.Static;
d1597 4
@


1.89
log
@Add wildcard exports for assemblies referenced by non-main assembly in shared class loader group.
@
text
@d2363 4
@


1.88
log
@Use "ikvm.exports" map for "wildcard exports" (i.e. assemblies that are referenced and whose types are available thru the assembly class loader).
@
text
@d506 1
a506 1
		private void WriteExportMap()
a507 1
			Dictionary<AssemblyName, List<string>> exportedNamesPerAssembly = new Dictionary<AssemblyName, List<string>>();
d510 1
a510 1
				exportedNamesPerAssembly.Add(acl.MainAssembly.GetName(), null);
d512 6
d528 1
@


1.87
log
@Renamed AssemblyClassLoader.Assembly to MainAssembly.
@
text
@d425 1
a425 4
			// HACK force all referenced assemblies to end up as references in the assembly
			// (even if they are otherwise unused), to make sure that the assembly class loader
			// delegates to them at runtime.
			for(int i = 0;i < referencedAssemblies.Length; i++)
d427 6
a432 2
				Type[] types = referencedAssemblies[i].MainAssembly.GetExportedTypes();
				if(types.Length > 0)
d434 5
a438 1
					mb.GetTypeToken(types[0]);
d462 1
a462 1
			// add a package list
d468 7
a474 6
			}

			// if we're the main assembly in a shared class loader group, add a resource that lists all the types available in the other assemblies
			if(options.sharedclassloader != null && options.sharedclassloader.Count > 1 && options.sharedclassloader[0] == this)
			{
				WriteExportMap();
d491 1
a491 1
		private static void AddExportMapEntry(Dictionary<CompilerClassLoader, List<string>> map, CompilerClassLoader ccl, string name)
d493 1
d495 1
a495 1
			if (!map.TryGetValue(ccl, out list))
d498 5
a502 1
				map.Add(ccl, list);
a503 1
			list.Add(name);
d508 5
a512 1
			Dictionary<CompilerClassLoader, List<string>> exportedNamesPerAssembly = new Dictionary<CompilerClassLoader, List<string>>();
d517 1
a517 1
			foreach (CompilerClassLoader ccl in options.sharedclassloader)
d519 1
a519 1
				if (ccl != this)
d521 1
a521 1
					if (ccl.options.resources != null)
d523 1
a523 1
						foreach (string name in ccl.options.resources.Keys)
d525 4
a528 1
							AddExportMapEntry(exportedNamesPerAssembly, ccl, name);
d530 1
a530 4
					}
					if (ccl.options.externalResources != null)
					{
						foreach (string name in ccl.options.externalResources.Keys)
d532 4
a535 1
							AddExportMapEntry(exportedNamesPerAssembly, ccl, name);
d543 1
a543 1
			foreach (KeyValuePair<CompilerClassLoader, List<string>> kv in exportedNamesPerAssembly)
d545 7
a551 3
				bw.Write(kv.Key.assemblyBuilder.GetName().FullName);
				bw.Write(kv.Value.Count);
				foreach (string name in kv.Value)
d553 6
a558 1
					bw.Write(JVM.PersistableHash(name));
a2360 4
			if (!compilingCoreAssembly)
			{
				ClassLoaderWrapper.SetBootstrapClassLoader(ClassLoaderWrapper.GetAssemblyClassLoader(JVM.CoreAssembly));
			}
@


1.86
log
@Changed "InternalsVisibleTo" handling to be based on Assembly instead of class loader.
@
text
@d430 1
a430 1
				Type[] types = referencedAssemblies[i].Assembly.GetExportedTypes();
@


1.85
log
@Use AssemblyClassLoader.GetAssembly() to get the actual assembly the type lives in, instead of the main assembly of the group.
@
text
@d314 1
a314 1
		internal override bool InternalsVisibleTo(ClassLoaderWrapper other)
d316 2
@


1.84
log
@Added AssemblyClassLoader.GetAssembly(TypeWrapper) and changed most code that assumed that an AssemblyClassLoader represented a single assembly to use it.
@
text
@d3202 1
a3202 1
				return tw.Name + ", " + acl.Assembly.FullName;
@


1.83
log
@When loading a referenced assembly that is the main assemblye of a sharedclassloader group, also pre-load the other assemblies in the group.
@
text
@d2781 1
a2781 1
							StaticCompiler.IssueMessage(Message.SkippingReferencedClass, s, ((AssemblyClassLoader)loader).Assembly.FullName);
@


1.82
log
@Renamed ClassLoadWrapper.GetType(string) to GetGenericTypeDefinition() to make clear what it is used for.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
d2403 1
a2403 1
					Assembly reference = Assembly.ReflectionOnlyLoadFrom(r);
d2672 1
a2672 1
							asm = Assembly.ReflectionOnlyLoadFrom(StaticCompiler.runtimeAssembly.CodeBase + "\\..\\" + name.Name + ".dll");
d2717 35
@


1.81
log
@Implemented shared class loader support.
@
text
@d301 1
a301 1
		internal override Type GetType(string name)
d305 1
a305 1
				Type type = loader.GetType(name);
@


1.80
log
@Split EmitRemappedTypes into two passes, to allow map.xml to refer to types in other assemblies currently being compiled.
@
text
@d44 1
d64 1
a64 1
		private Dictionary<string, string> packages = new Dictionary<string, string>();
d78 2
d314 42
d456 1
a456 1
			if(true)
d463 6
d483 54
d2314 4
d2337 1
d2340 15
d2361 4
d2727 8
d2759 4
a2888 1
			Save();
d2935 1
@


1.79
log
@Added workaround for protected methods in remapped types (i.e. Object.close() and Object.finalize()) that will be necessary when splitting the class library into multiple assemblies.
@
text
@d1860 2
d1863 4
d2220 4
@


1.78
log
@Make ikvmc emit a warning whenever it emits code that throws a hard error.
@
text
@d849 6
a854 1
					if(mbHelper != null)
d1211 1
a1211 1
								mw.EmitCallvirt(ilgen);
@


1.77
log
@Multi target performance fix.
@
text
@d2824 8
d2949 32
@


1.76
log
@Simplified creation of "fake" types.
@
text
@d182 10
a191 5
						TypeWrapper tw = ccl.LoadClassByDottedNameFast(name);
						// HACK we don't want to load classes referenced by peers, hence the "is CompilerClassLoader" check
						if(tw != null && tw.GetClassLoader() is CompilerClassLoader)
						{
							return tw;
@


1.75
log
@Don't generate warnings for  ikvmstub generated classes that are loaded.
@
text
@a2564 4
			else if(loader.map != null && loader.CheckCompilingCoreAssembly())
			{
				FakeTypes.CreatePre(loader.GetTypeWrapperFactory().ModuleBuilder);
			}
d2571 7
a2664 7
				// if we're compiling the core class library, generate the "fake" generic types
				// that represent the not-really existing types (i.e. the Java enums that represent .NET enums,
				// the Method interface for delegates and the Annotation annotation for custom attributes)
				if(CheckCompilingCoreAssembly())
				{
					FakeTypes.Create(GetTypeWrapperFactory().ModuleBuilder, this);
				}
@


1.74
log
@Integrated IKVM.Reflection.Emit in ikvmc.
@
text
@d76 1
d258 4
d2584 1
a2584 1
						if(!(loader is GenericClassLoader || loader is CompilerClassLoader))
@


1.73
log
@Improved core assembly compilation detection to work in multi target scenarios.
@
text
@d27 3
d31 1
d138 7
a144 1
			assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.ReflectionOnly, assemblyDir);
d2625 1
a2625 1
				if(!method.DeclaringType.Assembly.Equals(assemblyBuilder)
@


1.72
log
@Fixed peer class loading hack.
@
text
@a67 1
		private bool compilingCoreAssembly;
d149 5
d2167 1
d2172 1
a2172 1
				int rc = CreateCompiler(options, ref compiler);
a2178 1
			bool compilingCoreAssembly = false;
a2180 4
				if (compiler1.compilingCoreAssembly)
				{
					compilingCoreAssembly = true;
				}
d2204 1
a2204 1
		private static int CreateCompiler(CompilerOptions options, ref CompilerClassLoader loader)
d2488 1
a2488 1
					loader.compilingCoreAssembly = true;
d2495 1
a2495 1
			if(JVM.CoreAssembly == null && !loader.compilingCoreAssembly)
d2529 1
a2529 1
			if(!loader.compilingCoreAssembly)
d2546 1
a2546 1
			if(!loader.compilingCoreAssembly)
d2550 1
a2550 1
			else
d2650 1
a2650 1
				if(compilingCoreAssembly)
@


1.71
log
@Fixed .NET generic support regression introduced when ikvmc moved to not using the CompilerClassLoader as the system class loader.
@
text
@d72 1
a72 2
		[ThreadStatic]
		private bool peerHack;
d160 1
a160 1
			if(!peerHack)
d162 1
a162 1
				peerHack = true;
d168 2
a169 1
						if(tw != null && tw.GetClassLoader() == ccl)
d177 1
a177 1
					peerHack = false;
@


1.70
log
@Generified all collections.
@
text
@d180 6
a185 1
			return GetTypeWrapperCompilerHook(name);
@


1.69
log
@Replaced mapxml Hashtable with three statically typed Dictionaries.
@
text
@a42 24
	struct MethodKey : IEquatable<MethodKey>
	{
		private readonly string className;
		private readonly string methodName;
		private readonly string methodSig;

		internal MethodKey(string className, string methodName, string methodSig)
		{
			this.className = className;
			this.methodName = methodName;
			this.methodSig = methodSig;
		}

		public bool Equals(MethodKey other)
		{
			return className == other.className && methodName == other.methodName && methodSig == other.methodSig;
		}

		public override int GetHashCode()
		{
			return className.GetHashCode() ^ methodName.GetHashCode() ^ methodSig.GetHashCode();
		}
	}

@


1.68
log
@Moved generated exception mapping code from ExceptionHelper to Throwable and made it slightly less hacky.
@
text
@d43 24
d87 3
a89 1
		private System.Collections.Hashtable mapxml;
a1989 1
			mapxml = new System.Collections.Hashtable();
d1992 3
d2001 1
a2001 1
						mapxml.Add(className, c);
d2010 1
a2010 1
									mapxml.Add(className + "." + methodName + methodSig, method.body);
d2014 1
a2014 1
									mapxml.Add("replaced:" + className + "." + method.Name + method.Sig, method.ReplaceMethodCalls);
d2025 1
a2025 1
			if(mapxml == null)
d2029 8
a2036 1
			return (IKVM.Internal.MapXml.ReplaceMethodCall[])mapxml["replaced:" + mw.DeclaringType.Name + "." + mw.Name + mw.Signature];
d2039 1
a2039 1
		internal System.Collections.Hashtable GetMapXml()
d2041 1
a2041 1
			return mapxml;
d2046 1
a2046 1
			if(mapxml != null)
d2048 2
a2049 2
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[classname];
				if(clazz != null)
@


1.67
log
@Replaced usage of BootstrapClassLoader with actual class loader in static compiler.
@
text
@d1877 21
d1910 1
a1910 1
			internal void Emit(ClassLoaderWrapper loader, CodeEmitter ilgen)
a1930 1
							IKVM.Internal.MapXml.CodeGenContext context = new IKVM.Internal.MapXml.CodeGenContext(loader);
d1936 1
a1936 1
									&& loader.LoadClassByDottedName(newobj.Class).IsSubTypeOf(CoreClasses.java.lang.Throwable.Wrapper))
d1947 1
a1947 1
						TypeWrapper tw = loader.LoadClassByDottedName(map[i].dst);
a1964 2
			// HACK we've got a hardcoded location for the exception mapping method that is generated from the xml mapping
			mapxml["java.lang.ExceptionHelper.MapExceptionImpl(Ljava.lang.Throwable;)Ljava.lang.Throwable;"] = new ExceptionMapEmitter(map.exceptionMappings);
@


1.66
log
@Added multi target support to ikvmc (although it is currently disabled, because of a showstopper .NET Ref.Emit bug).
@
text
@d534 1
a534 1
						AttributeHelper.SetCustomAttribute(typeBuilder, custattr);
d678 1
a678 1
								AttributeHelper.SetCustomAttribute(mbHelper, custattr);
d681 1
a681 1
						SetParameters(mbHelper, m.Params);
d693 1
a693 1
								AttributeHelper.SetCustomAttribute(cbCore, custattr);
d696 1
a696 1
						SetParameters(cbCore, m.Params);
d717 1
a717 1
							m.body.Emit(ilgen);
d753 1
a753 1
							m.redirect.Emit(ilgen);
d757 1
a757 1
							m.alternateBody.Emit(ilgen);
d893 1
a893 1
									AttributeHelper.SetCustomAttribute(helper, custattr);
d896 1
a896 1
							SetParameters(helper, m.Params);
d984 1
a984 1
									AttributeHelper.SetCustomAttribute(mbCore, custattr);
d987 1
a987 1
							SetParameters(mbCore, m.Params);
d1018 1
a1018 1
									AttributeHelper.SetCustomAttribute(mbHelper, custattr);
d1033 1
a1033 1
							SetParameters(mbHelper, parameters);
d1071 1
a1071 1
							System.Collections.Hashtable context = new System.Collections.Hashtable();
d1186 1
a1186 1
							System.Collections.Hashtable context = new System.Collections.Hashtable();
d1255 1
a1255 1
								AttributeHelper.SetCustomAttribute(mb, custattr);
d1258 1
a1258 1
						SetParameters(mb, m.Params);
d1263 1
a1263 1
							m.nonvirtualAlternateBody.Emit(ilgen);
d1296 1
a1296 1
					ClassLoaderWrapper classLoader = ClassLoaderWrapper.GetBootstrapClassLoader();
d1312 1
a1312 1
						TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(m.redirect.Class);
d1324 1
a1324 1
			private static void SetParameters(MethodBuilder mb, IKVM.Internal.MapXml.Param[] parameters)
d1335 1
a1335 1
								AttributeHelper.SetCustomAttribute(pb, parameters[i].Attributes[j]);
d1342 1
a1342 1
			private static void SetParameters(ConstructorBuilder cb, IKVM.Internal.MapXml.Param[] parameters)
d1353 1
a1353 1
								AttributeHelper.SetCustomAttribute(pb, parameters[i].Attributes[j]);
d1371 1
a1371 1
						TypeWrapper ifaceTypeWrapper = ClassLoaderWrapper.LoadClassCritical(c.Interfaces[i].Name);
d1427 1
a1427 1
									AttributeHelper.SetCustomAttribute(fb, custattr);
d1481 1
a1481 1
					classDef.Clinit.body.Emit(ilgen);
d1875 1
a1875 1
					mappedExceptions[i] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dst);
d1889 1
a1889 1
			internal void Emit(CodeEmitter ilgen)
d1910 1
a1910 1
							System.Collections.Hashtable context = new System.Collections.Hashtable();
d1916 1
a1916 1
									&& ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(newobj.Class).IsSubTypeOf(CoreClasses.java.lang.Throwable.Wrapper))
d1927 1
a1927 1
						TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map[i].dst);
d2039 1
a2039 1
					TypeWrapper typeWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(c.Name);
d2042 1
a2042 1
						TypeWrapper ifaceWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(iface.Name);
d2096 1
a2096 1
					AttributeHelper.SetCustomAttribute(assemblyBuilder, attr);
@


1.65
log
@Switched to using generic collections.
@
text
@d65 7
d103 5
d159 19
d1801 1
a1801 1
		internal void EmitRemappedTypes(IKVM.Internal.MapXml.Root map)
d1942 1
a1942 1
		internal void LoadMapXml(IKVM.Internal.MapXml.Root map)
d2112 59
a2170 1
		internal static int Compile(CompilerOptions options)
a2299 1
			Dictionary<string, byte[]> h = new Dictionary<string, byte[]>();
d2336 1
d2433 1
a2433 1
				referencedAssemblies[i] = ClassLoaderWrapper.GetAssemblyClassLoader((Assembly)references[i]);
d2435 1
a2435 1
			CompilerClassLoader loader = new CompilerClassLoader(referencedAssemblies, options, options.path, options.keyfilename, options.keycontainer, options.version, options.targetIsModule, options.assembly, h);
d2437 2
a2438 2
			ClassLoaderWrapper.SetBootstrapClassLoader(loader);
			IKVM.Internal.MapXml.Root map = null;
d2450 7
a2456 1
					map = (IKVM.Internal.MapXml.Root)ser.Deserialize(rdr);
a2457 1
				loader.EmitRemappedTypes(map);
d2461 1
a2461 1
			if(JVM.CoreAssembly == null && !loader.remapped.ContainsKey("java.lang.Object"))
a2490 2
				loader.AddReference(ClassLoaderWrapper.GetAssemblyClassLoader(JVM.CoreAssembly));
				allReferencesAreStrongNamed &= IsSigned(JVM.CoreAssembly);
d2495 6
d2507 1
a2507 1
			if(map != null)
d2509 1
a2509 1
				loader.LoadMapXml(map);
d2512 1
a2512 1
			if(!loader.remapped.ContainsKey("java.lang.Object"))
d2520 2
d2523 2
d2527 1
a2527 1
			foreach(string s in new List<string>(h.Keys))
d2529 1
a2529 1
				TypeWrapper wrapper = loader.LoadClassByDottedNameFast(s);
d2532 2
a2533 1
					if(wrapper.GetClassLoader() != loader)
d2535 1
a2535 1
						if(!(wrapper.GetClassLoader() is GenericClassLoader))
d2537 1
a2537 1
							StaticCompiler.IssueMessage(Message.SkippingReferencedClass, s, ((AssemblyClassLoader)wrapper.GetClassLoader()).Assembly.FullName);
d2548 1
a2548 1
						loader.packages[wrapper.Name.Substring(0, pos)] = "";
d2558 1
a2558 1
					wrapper = loader.LoadClassByDottedNameFast(options.mainClass);
d2581 1
a2581 1
				if(!method.DeclaringType.Assembly.Equals(loader.assemblyBuilder)
d2596 1
a2596 1
				loader.SetMain(method, options.target, options.props, options.noglobbing, apartmentAttributeType);
d2600 1
a2600 1
				loader.LoadMappedExceptions(map);
d2612 1
a2612 1
				loader.FinishRemappedTypes();
d2616 1
a2616 1
				if(loader.remapped.ContainsKey("java.lang.Object"))
d2618 1
a2618 1
					FakeTypes.Create(loader.GetTypeWrapperFactory().ModuleBuilder, loader);
d2622 1
a2622 1
			loader.AddResources(options.resources, options.compressedResources);
d2627 1
a2627 1
					loader.assemblyBuilder.AddResourceFile(JVM.MangleResourceName(kv.Key), kv.Value);
d2633 1
a2633 1
				loader.assemblyBuilder.SetCustomAttribute(filever);
d2637 1
a2637 1
				Annotation annotation = Annotation.Load(loader, def);
d2640 1
a2640 1
					annotation.Apply(loader, loader.assemblyBuilder, def);
d2648 1
a2648 1
					wrapper = loader.LoadClassByDottedNameFast(options.classLoader);
d2658 1
a2658 1
				if(!wrapper.IsPublic && !wrapper.TypeAsBaseType.Assembly.Equals(loader.assemblyBuilder))
d2680 1
a2680 1
				loader.assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(ci, new object[] { wrapper.TypeAsTBD }));
d2682 2
a2683 2
			loader.assemblyBuilder.DefineVersionInfoResource();
			loader.Save();
d2730 22
@


1.64
log
@- Renamed CountingILGenerator to CodeEmitter.
- Renamed CountingLabel to CodeEmitterLabel.
@
text
@d30 1
a30 1
using System.Collections;
d45 2
a46 2
		private Hashtable classes;
		private Hashtable remapped = new Hashtable();
d58 3
a60 3
		private Hashtable nameMappings = new Hashtable();
		private Hashtable packages = new Hashtable();
		private Hashtable ghosts;
d63 2
a64 2
		private Hashtable mapxml;
		private Hashtable baseClasses;
d66 1
a66 1
		internal CompilerClassLoader(AssemblyClassLoader[] referencedAssemblies, CompilerOptions options, string path, string keyfilename, string keycontainer, string version, bool targetIsModule, string assemblyName, Hashtable classes)
d155 1
a155 2
				type = (TypeWrapper)remapped[name];
				if(type != null)
d159 2
a160 2
				byte[] classdef = (byte[])classes[name];
				if(classdef != null)
d249 1
a249 1
		internal void SetMain(MethodInfo m, PEFileKinds target, Hashtable props, bool noglobbing, Type apartmentAttributeType)
d266 2
a267 2
				ilgen.Emit(OpCodes.Newobj, typeof(Hashtable).GetConstructor(Type.EmptyTypes));
				foreach(DictionaryEntry de in props)
d270 3
a272 3
					ilgen.Emit(OpCodes.Ldstr, (string)de.Key);
					ilgen.Emit(OpCodes.Ldstr, (string)de.Value);
					ilgen.Emit(OpCodes.Callvirt, typeof(Hashtable).GetMethod("Add"));
d334 1
a334 1
				foreach(DictionaryEntry de in nameMappings)
d336 2
a337 2
					list[i++] = (string)de.Key;
					list[i++] = (string)de.Value;
d370 1
a370 1
		internal void AddResources(Hashtable resources, bool compressedResources)
d374 1
a374 1
			foreach(DictionaryEntry d in resources)
d376 2
a377 2
				byte[] buf = (byte[])d.Value;
				string name = JVM.MangleResourceName((string)d.Key);
d531 1
a531 1
				ArrayList methods = new ArrayList();
d564 1
a564 1
				SetMethods((MethodWrapper[])methods.ToArray(typeof(MethodWrapper)));
d567 1
a567 1
			private static bool FindMethod(ArrayList methods, string name, string sig)
d761 1
a761 1
				private ArrayList overriders = new ArrayList();
d819 1
a819 1
						ArrayList specialCases = null;
d830 1
a830 1
											specialCases = new ArrayList();
d1040 1
a1040 1
							Hashtable context = new Hashtable();
d1155 1
a1155 1
							Hashtable context = new Hashtable();
d1360 1
a1360 1
				ArrayList fields = new ArrayList();
d1427 1
a1427 1
				SetFields((FieldWrapper[])fields.ToArray(typeof(FieldWrapper)));
d1438 1
a1438 1
			internal void Process4thPass(ICollection remappedTypes)
d1471 1
a1471 1
					Hashtable methods = new Hashtable();
d1564 1
a1564 1
			private void CreateShadowInstanceOf(ICollection remappedTypes)
d1613 1
a1613 1
			private void CreateShadowCheckCast(ICollection remappedTypes)
d1879 1
a1879 1
							Hashtable context = new Hashtable();
d1913 1
a1913 1
			mapxml = new Hashtable();
d1955 1
a1955 1
		internal Hashtable GetMapXml()
d1999 1
a1999 1
			ghosts = new Hashtable();
d2027 2
a2028 2
			ArrayList list = (ArrayList)ghosts[interfaceName];
			if(list == null)
d2030 1
a2030 1
				list = new ArrayList();
d2038 2
a2039 2
			ArrayList list = (ArrayList)ghosts[wrapper.Name];
			if(list == null)
d2043 1
a2043 1
			return (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
d2111 1
a2111 1
			ArrayList references = new ArrayList();
d2209 3
a2211 3
			ArrayList assemblyAnnotations = new ArrayList();
			Hashtable baseClasses = new Hashtable();
			Hashtable h = new Hashtable();
d2213 1
a2213 1
			foreach(DictionaryEntry de in options.classes)
d2218 1
a2218 1
					byte[] buf = (byte[])de.Value;
d2250 1
a2250 1
			foreach(DictionaryEntry de in options.classes)
d2252 1
a2252 1
				string name = (string)de.Key;
d2269 1
a2269 1
					h[name] = de.Value;
d2424 2
a2425 2
			ArrayList allwrappers = new ArrayList();
			foreach(string s in new ArrayList(h.Keys))
d2522 1
a2522 1
				foreach(DictionaryEntry de in options.externalResources)
d2524 1
a2524 1
					loader.assemblyBuilder.AddResourceFile(JVM.MangleResourceName((string)de.Key), (string)de.Value);
d2610 1
a2610 1
		internal Hashtable classes;
d2612 1
a2612 1
		internal Hashtable resources;
d2615 1
a2615 1
		internal Hashtable props;
d2623 1
a2623 1
		internal Hashtable externalResources;
d2683 2
a2684 2
		private static Hashtable suppressWarnings = new Hashtable();
		private static Hashtable errorWarnings = new Hashtable();
@


1.63
log
@Removed CodeEmitter abstract base class.
@
text
@a37 2
using ILGenerator = IKVM.Internal.CountingILGenerator;
using Label = IKVM.Internal.CountingLabel;
d262 1
a262 1
			ILGenerator ilgen = mainStub.GetILGenerator();
d616 1
a616 1
				internal override void EmitCall(ILGenerator ilgen)
d621 1
a621 1
				internal override void EmitNewobj(ILGenerator ilgen, MethodAnalyzer ma, int opcodeIndex)
d682 1
a682 1
						ILGenerator ilgen = cbCore.GetILGenerator();
d720 1
a720 1
						ILGenerator ilgen = mbHelper.GetILGenerator();
d781 1
a781 1
				internal override void EmitCall(ILGenerator ilgen)
d786 1
a786 1
				internal override void EmitCallvirt(ILGenerator ilgen)
d843 1
a843 1
							ILGenerator ilgen;
d853 1
a853 1
								ilgen = typeWrapper.helperTypeBuilder.DefineConstructor(MethodAttributes.Private, CallingConventions.Standard, Type.EmptyTypes).GetILGenerator();
d867 1
a867 1
							ilgen = helper.GetILGenerator();
d874 1
a874 1
								Label label = ilgen.DefineLabel();
d1026 1
a1026 1
						ILGenerator ilgen = mbCore.GetILGenerator();
d1094 1
a1094 1
						ILGenerator ilgen = mbHelper.GetILGenerator();
d1113 1
a1113 1
							Label skip = ilgen.DefineLabel();
d1138 1
a1138 1
								Label skip = ilgen.DefineLabel();
d1230 1
a1230 1
						ILGenerator ilgen = mb.GetILGenerator();
d1254 1
a1254 1
				private void EmitRedirect(Type baseType, ILGenerator ilgen)
d1449 1
a1449 1
					ILGenerator ilgen = cb.GetILGenerator();
d1488 1
a1488 1
							ILGenerator ilgen = mb.GetILGenerator();
d1576 1
a1576 1
				ILGenerator ilgen = mb.GetILGenerator();
d1580 1
a1580 1
				Label retFalse = ilgen.DefineLabel();
d1625 1
a1625 1
				ILGenerator ilgen = mb.GetILGenerator();
d1627 1
a1627 1
				Label fail = ilgen.DefineLabel();
d1859 1
a1859 1
			internal void Emit(ILGenerator ilgen)
d1872 1
a1872 1
					Label label = ilgen.DefineLabel();
@


1.62
log
@Bug fix: the key file should not be opened for read/write access.
@
text
@d1852 1
a1852 1
		private class ExceptionMapEmitter : CodeEmitter
d1861 1
a1861 1
			internal override void Emit(ILGenerator ilgen)
@


1.61
log
@Call suppressFillInStackTrace before instantiating a remapped exception in the remap implementation method.
@
text
@d117 1
a117 4
				using(FileStream stream = File.Open(keyfilename, FileMode.Open))
				{
					name.KeyPair = new StrongNameKeyPair(stream);
				}
@


1.60
log
@Don't skip zero length resource files.
@
text
@d1883 15
a1897 3
						// TODO we should manually walk the instruction list and add a suppressFillInStackTrace call
						// before each newobj that instantiates an exception
						map[i].code.Emit(ilgen);
d2424 4
@


1.59
log
@Replaced notion of DynamicOnly types with Fake types. Fake types are implemented as generic type instances and can have DynamicOnly methods.
@
text
@d383 3
a385 1
				if(buf.Length > 0)
d387 2
a388 3
					string name = JVM.MangleResourceName((string)d.Key);
					MemoryStream mem = new MemoryStream();
					if(compressedResources)
a389 2
						mem.WriteByte(1);
						System.IO.Compression.DeflateStream def = new System.IO.Compression.DeflateStream(mem, System.IO.Compression.CompressionMode.Compress, true);
a390 1
						def.Close();
a391 7
					else
					{
						mem.WriteByte(0);
						mem.Write(buf, 0, buf.Length);
					}
					mem.Position = 0;
					moduleBuilder.DefineManifestResource(name, mem, ResourceAttributes.Public);
d393 7
@


1.58
log
@Removed workaround that is no longer needed.
@
text
@d2410 5
d2502 7
@


1.57
log
@Made core assembly compilation detection more robust.
@
text
@a538 12
				// HACK because of the above FXBUG that prevents us from making the type both abstract and sealed,
				// we need to emit a private constructor (otherwise reflection will automatically generate a public
				// default constructor, another lame feature)
				if(baseIsSealed)
				{
					ConstructorBuilder cb = typeBuilder.DefineConstructor(MethodAttributes.Private, CallingConventions.Standard, Type.EmptyTypes);
					ILGenerator ilgen = cb.GetILGenerator();
					// lazyman's way to create a type-safe bogus constructor
					ilgen.Emit(OpCodes.Ldnull);
					ilgen.Emit(OpCodes.Throw);
				}

@


1.56
log
@Made core assembly detection more robust.
@
text
@d2373 3
a2375 3
			// Do a sanity check to make sure some of the bootstrap classes are available
			bool hasBootClasses;
			try
a2376 9
				hasBootClasses = loader.LoadClassByDottedNameFast("java.lang.Object") != null;
			}
			catch(ClassFormatError)
			{
				hasBootClasses = false;
			}
			if(!hasBootClasses)
			{
				// try to find the core assembly looking at the assemblies that the runtime references
@


1.55
log
@- Added ikvmc -platform option.
- Fixed ikvmc JNI handling regression (introduced when IKVM.Runtime.JNI was split off).
@
text
@d2084 5
d2125 1
a2125 1
					if(AttributeHelper.IsDefined(reference, StaticCompiler.GetType("IKVM.Attributes.RemappedClassAttribute")))
d2385 2
a2386 2
				AssemblyName coreAssemblyName = null;
				foreach(AssemblyName asm in StaticCompiler.runtimeAssembly.GetReferencedAssemblies())
d2388 2
a2389 2
					// HACK we assume that IKVM.Runtime.dll only references the core library and that the name starts with "IKVM."
					if(asm.Name.StartsWith("IKVM."))
d2391 1
a2391 2
						coreAssemblyName = asm;
						break;
d2393 1
a2393 13
				}
				if(coreAssemblyName == null)
				{
					Console.Error.WriteLine("Error: runtime assembly doesn't reference core assembly");
					return 1;
				}
				try
				{
					JVM.CoreAssembly = Assembly.ReflectionOnlyLoad(coreAssemblyName.FullName);
				}
				catch(FileNotFoundException)
				{
					try
d2395 7
a2401 1
						JVM.CoreAssembly = Assembly.ReflectionOnlyLoadFrom(StaticCompiler.runtimeAssembly.CodeBase + "\\..\\" + coreAssemblyName.Name + ".dll");
d2403 1
a2403 1
					catch(FileNotFoundException)
d2405 2
@


1.54
log
@Implemented support for InternalsVisibleToAttribute.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d366 1
a366 1
				assemblyBuilder.Save(manifestAssembly);
d372 1
a372 1
				assemblyBuilder.Save(assemblyFile);
d2094 1
d2099 1
d2104 6
a2109 2
				Console.Error.WriteLine("Error: unable to load runtime assembly");
				return 1;
d2251 2
d2626 2
d2649 1
d2655 1
d2668 4
d2764 3
@


1.53
log
@Removed more .NET 1.1 workarounds.
@
text
@d106 5
@


1.52
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d488 1
a488 6
						// FXBUG .NET framework bug
						// ideally we would make the type sealed and abstract,
						// but Reflection.Emit incorrectly prohibits that
						// (the ECMA spec explicitly mentions this is valid)
						// attrs |= TypeAttributes.Abstract | TypeAttributes.Sealed;
						attrs |= TypeAttributes.Abstract;
d865 1
@


1.51
log
@Allow non-public custom assembly class loaders.
@
text
@a36 1
using IKVM.Runtime;
a121 1
#if WHIDBEY
a122 3
#else
			assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Save, assemblyDir);
#endif
d381 1
a381 17
#if WHIDBEY
						MemoryStream mem = new MemoryStream();
						if(compressedResources)
						{
							mem.WriteByte(1);
							System.IO.Compression.DeflateStream def = new System.IO.Compression.DeflateStream(mem, System.IO.Compression.CompressionMode.Compress, true);
							def.Write(buf, 0, buf.Length);
							def.Close();
						}
						else
						{
							mem.WriteByte(0);
							mem.Write(buf, 0, buf.Length);
						}
						mem.Position = 0;
						moduleBuilder.DefineManifestResource(name, mem, ResourceAttributes.Public);
#else
d384 12
a395 9
						MemoryStream mem = new MemoryStream();
						LZOutputStream lz = new LZOutputStream(mem);
						lz.Write(buf, 0, buf.Length);
						lz.Flush();
						buf = mem.ToArray();
					}
					IResourceWriter writer = moduleBuilder.DefineResource(name, "");
					writer.AddResource(compressedResources ? "lz" : "ikvm", buf);
#endif
d2086 1
a2086 2
#if WHIDBEY
			if(options.runtimeAssembly == null)
d2088 10
a2097 1
				StaticCompiler.runtimeAssembly = Assembly.ReflectionOnlyLoadFrom(typeof(ByteCodeHelper).Assembly.Location);
d2099 1
a2099 1
			else
d2101 2
a2102 1
				StaticCompiler.runtimeAssembly = Assembly.ReflectionOnlyLoadFrom(options.runtimeAssembly);
a2103 10
#else
			if(options.runtimeAssembly == null)
			{
				StaticCompiler.runtimeAssembly = typeof(ByteCodeHelper).Assembly;
			}
			else
			{
				StaticCompiler.runtimeAssembly = Assembly.LoadFrom(options.runtimeAssembly);
			}
#endif
a2111 1
#if WHIDBEY
a2116 14
#else
					AssemblyName name = AssemblyName.GetAssemblyName(r);
					Assembly reference;
					try
					{
						reference = Assembly.Load(name);
					}
					catch(FileNotFoundException)
					{
						// MONOBUG mono fails to use the codebase inside the AssemblyName,
						// so now we try again explicitly loading from the codebase
						reference = Assembly.LoadFrom(name.CodeBase);
					}
#endif
a2122 5
					// HACK if we explictly referenced the core assembly, make sure we register it as such
					if(reference.GetType("java.lang.Object") != null)
					{
						JVM.CoreAssembly = reference;
					}
a2190 1
#if WHIDBEY
a2204 1
#endif
d2386 14
a2399 5
#if WHIDBEY
				JVM.CoreAssembly = Assembly.ReflectionOnlyLoadFrom(StaticCompiler.runtimeAssembly.CodeBase + "\\..\\" + coreAssemblyName.Name + ".dll");
#else
				JVM.CoreAssembly = Assembly.Load(coreAssemblyName);
#endif
a2406 1
				StaticCompiler.IssueMessage(Message.AutoAddRef, JVM.CoreAssembly.Location);
a2654 1
#if WHIDBEY
a2664 15
#else
			foreach(Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
			{
				Type t = asm.GetType(name, false);
				if(t != null)
				{
					return t;
				}
			}
			if(throwOnError)
			{
				throw new TypeLoadException(name);
			}
			return null;
#endif
@


1.50
log
@Added ikvmc option to specify custom assembly class loader.
@
text
@d2580 1
a2580 1
				if(!wrapper.IsPublic)
d2582 1
a2582 1
					Console.Error.WriteLine("Error: custom assembly class loader class is not public");
d2596 1
a2596 1
				if(mw == null || !mw.IsPublic)
d2598 1
a2598 1
					Console.Error.WriteLine("Error: custom assembly class loader constructor is missing or not public");
d2601 1
a2601 1
				ConstructorInfo ci = JVM.LoadType(typeof(CustomAssemblyClassLoaderAttribute)).GetConstructor(new Type[] { typeof(Type) });
@


1.49
log
@Fix for bug #1802125.
@
text
@d2354 5
d2565 39
d2649 1
@


1.48
log
@- Fixed assembly annotation support (annotations are now applied, even though "assembly" type already exists in core library).
- Added ikvmc warning when annotation type isn't found.
@
text
@d2505 1
a2505 1
				if(method.DeclaringType.Assembly != loader.assemblyBuilder
@


1.48.2.1
log
@Backported fixes. Changed version to 0.36.0.4.
@
text
@d2505 1
a2505 1
				if(!method.DeclaringType.Assembly.Equals(loader.assemblyBuilder)
@


1.48.2.2
log
@Backported fixes and changed version to 0.36.0.5
@
text
@a2353 5
				if(options.classLoader != null)
				{
					Console.Error.WriteLine("Error: cannot specify assembly class loader for modules");
					return 1;
				}
a2559 39
			if(options.classLoader != null)
			{
				TypeWrapper wrapper = null;
				try
				{
					wrapper = loader.LoadClassByDottedNameFast(options.classLoader);
				}
				catch(RetargetableJavaException)
				{
				}
				if(wrapper == null)
				{
					Console.Error.WriteLine("Error: custom assembly class loader class not found");
					return 1;
				}
				if(!wrapper.IsPublic && !wrapper.TypeAsBaseType.Assembly.Equals(loader.assemblyBuilder))
				{
					Console.Error.WriteLine("Error: custom assembly class loader class is not accessible");
					return 1;
				}
				if(wrapper.IsAbstract)
				{
					Console.Error.WriteLine("Error: custom assembly class loader class is abstract");
					return 1;
				}
				if(!wrapper.IsAssignableTo(ClassLoaderWrapper.LoadClassCritical("java.lang.ClassLoader")))
				{
					Console.Error.WriteLine("Error: custom assembly class loader class does not extend java.lang.ClassLoader");
					return 1;
				}
				MethodWrapper mw = wrapper.GetMethodWrapper("<init>", "(Lcli.System.Reflection.Assembly;)V", false);
				if(mw == null)
				{
					Console.Error.WriteLine("Error: custom assembly class loader constructor is missing");
					return 1;
				}
				ConstructorInfo ci = JVM.LoadType(typeof(CustomAssemblyClassLoaderAttribute)).GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { typeof(Type) }, null);
				loader.assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(ci, new object[] { wrapper.TypeAsTBD }));
			}
a2604 1
		internal string classLoader;
@


1.48.2.3
log
@- Changed the detection of referenced core assembly to be more robust.
- Changed the detection of the fact that we're compiling the core assembly to be more robust.
@
text
@d2133 4
d2150 1
d2156 3
a2158 3
#endif
					// if we explictly referenced the core assembly, make sure we register it as such
					if(AttributeHelper.IsDefined(reference, StaticCompiler.GetType("IKVM.Attributes.RemappedClassAttribute")))
a2161 1
					references.Add(reference);
d2401 9
a2409 1
			bool hasBootClasses = JVM.CoreAssembly != null || loader.remapped.ContainsKey("java.lang.Object");
@


1.48.2.4
log
@Include zero length resource files.
@
text
@d383 1
a383 1
				if(true)
@


1.48.2.5
log
@Back ported the following fixes:
- Remapped exceptions with explicit remapping code now call suppressFullInStackTrace (to make sure the proper stack trace is captured).
- Fixed memory mapped file bug (mapping at a non-zero offset would fail).
- Fixed .NET type name mangling for nested types that contain a dot in their name (which the C# 3.0 compiler generates for some helper types).
- Fixed bug in deserialization of double arrays.
- Fixed path canonicalization to swallow NotSupportedException (thrown when the path contains a colon, other than the one following the drive letter).
@
text
@d1914 3
a1916 15
						if(map[i].code.invoke != null)
						{
							Hashtable context = new Hashtable();
							foreach(MapXml.Instruction instr in map[i].code.invoke)
							{
								MapXml.NewObj newobj = instr as MapXml.NewObj;
								if(newobj != null
									&& newobj.Class != null
									&& ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(newobj.Class).IsSubTypeOf(CoreClasses.java.lang.Throwable.Wrapper))
								{
									mwSuppressFillInStackTrace.EmitCall(ilgen);
								}
								instr.Generate(context, ilgen);
							}
						}
@


1.48.2.6
log
@Back ported various fixes:
- Changed version to 0.36.0.13.
- Fixed ikvmc not to open the key file for write access.
- Added more efficient float/double to/from int/long bits converters.
- Fixed libikvm-native.so build to include reference to gmodule-2.0 library.
- Fixed ikvmc not to open the key file for write access.
- Fixed Graphics2D.rotate() to convert rotation angle from radians (Java) to degrees (.NET).
- Applied awt patch #1979656 by Daniel Wilson.
- Fixed three String bugs found by OpenJDK string tests.
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
- Removed incorrect DataFormatException thrown in java.util.zip.InflaterHuffmanTree.
- Fixed #2001802 contributed by Andy Malakov.
- Fixed #2001799.
- Fixed #2006953.
- Made finalize() and clone() methods in cli.System.Object and cli.System.Exception final.
@
text
@d113 1
a113 1
				using(FileStream stream = File.OpenRead(keyfilename))
@


1.47
log
@Restructured handling of fields defined in map.xml to enable referencing them from map.xml method  bodies.
@
text
@d2246 1
d2261 6
d2552 8
@


1.46
log
@Fixed GetReplacedMethodsFor() to not throw a NullReferenceException if no map file is specified.
@
text
@d2438 5
a2527 1
				loader.LoadMapXml(map);
@


1.45
log
@Added support for locally (i.e. per method) replacing method calls with a custom CIL sequence.
@
text
@d1973 4
@


1.44
log
@- Don't crash if remap file contains no class entries.
- Fixed previous change to auto-load the right core class library assembly.
@
text
@d1960 4
d1971 5
@


1.43
log
@Removed core assembly name dependency.
@
text
@d1813 1
a1813 3
			// 1st pass, put all types in remapped to make them loadable
			bool hasRemappedTypes = false;
			foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
d1815 3
a1817 1
				if(c.Shadows != null)
d1819 5
a1823 2
					remapped.Add(c.Name, new RemapperTypeWrapper(this, c, map));
					hasRemappedTypes = true;
a1824 1
			}
d1826 4
a1829 4
			if(hasRemappedTypes)
			{
				SetupGhosts(map);
			}
d1831 2
a1832 4
			// 2nd pass, resolve interfaces, publish methods/fields
			foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
			{
				if(c.Shadows != null)
d1834 5
a1838 2
					RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)remapped[c.Name];
					typeWrapper.Process2ndPassStep1(map);
d1840 1
a1840 4
			}
			foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
			{
				if(c.Shadows != null)
d1842 5
a1846 2
					RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)remapped[c.Name];
					typeWrapper.Process2ndPassStep2(map);
d1941 1
a1941 1
			foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
d1943 1
a1943 2
				// HACK if it is not a remapped type, we assume it is a container for native methods
				if(c.Shadows == null)
d1945 2
a1946 3
					string className = c.Name;
					mapxml.Add(className, c);
					if(c.Methods != null)
d1948 3
a1950 1
						foreach(IKVM.Internal.MapXml.Method method in c.Methods)
d1952 1
a1952 1
							if(method.body != null)
d1954 6
a1959 3
								string methodName = method.Name;
								string methodSig = method.Sig;
								mapxml.Add(className + "." + methodName + methodSig, method.body);
d2403 1
a2403 1
				JVM.CoreAssembly = Assembly.ReflectionOnlyLoadFrom(coreAssemblyName.CodeBase);
@


1.42
log
@Implemented type loading from referenced assemblies (to support loading generic .NET type instances).
@
text
@d2381 15
d2397 1
a2397 1
				JVM.CoreAssembly = Assembly.ReflectionOnlyLoadFrom(Assembly.GetExecutingAssembly().Location + "\\..\\IKVM.GNU.Classpath.dll");
d2399 1
a2399 1
				JVM.CoreAssembly = Assembly.LoadWithPartialName("IKVM.GNU.Classpath");
d2403 1
a2403 1
					Console.Error.WriteLine("Error: bootstrap classes missing and IKVM.GNU.Classpath.dll not found");
@


1.41
log
@Moved compiler warning handling to fix missing warnings bug (previously depending on compilation order, some warnings might not be shown).
@
text
@d242 13
@


1.40
log
@Added support for supressing the automatic null this check.
@
text
@d208 29
a236 1
					type = DefineClass(f, null);
d2395 2
a2396 1
				try
d2398 1
a2398 2
					TypeWrapper wrapper = loader.LoadClassByDottedNameFast(s);
					if(wrapper != null)
d2400 1
a2400 1
						if(wrapper.GetClassLoader() != loader)
d2402 1
a2402 5
							if(!(wrapper.GetClassLoader() is GenericClassLoader))
							{
								StaticCompiler.IssueMessage(Message.SkippingReferencedClass, s, ((AssemblyClassLoader)wrapper.GetClassLoader()).Assembly.FullName);
							}
							continue;
d2404 10
a2413 10
						if(map == null)
						{
							wrapper.Finish();
						}
						int pos = wrapper.Name.LastIndexOf('.');
						if(pos != -1)
						{
							loader.packages[wrapper.Name.Substring(0, pos)] = "";
						}
						allwrappers.Add(wrapper);
d2415 1
a2415 20
				}
				catch(ClassFormatError x)
				{
					StaticCompiler.IssueMessage(Message.ClassFormatError, s, x.Message);
				}
				catch(IllegalAccessError x)
				{
					StaticCompiler.IssueMessage(Message.IllegalAccessError, s, x.Message);
				}
				catch(VerifyError x)
				{
					StaticCompiler.IssueMessage(Message.VerificationError, s, x.Message);
				}
				catch(NoClassDefFoundError x)
				{
					StaticCompiler.IssueMessage(Message.NoClassDefFoundError, s, x.Message);
				}
				catch(RetargetableJavaException x)
				{
					StaticCompiler.IssueMessage(Message.GenericUnableToCompileError, s, x.GetType().Name, x.Message);
@


1.39
log
@- .NET "generic class loaders" now return something sensible when toString() is called on them.
- Ikvmc no longer warns about generic stubs.
- Ikvmstub now has WHIDBEY conditional code to properly determine if a class is a generic type instance (instead of the name based hack).
- Fixed .NET generic type name mangling bug (nested generic types were double encoded).
- Added support for loading .NET generic type stubs.
- Fixed several .NET generic type loading bugs.
- Fixed ikvm.runtime.Util.getInstanceTypeFromClass() to return null instead of throw an exception when it is called on a "dynamic only" class.
@
text
@d1095 1
a1095 1
						else
@


1.39.2.1
log
@Fixed ikvmc generic .NET type loading bug.
@
text
@a213 13
		internal override Type GetType(string name)
		{
			foreach(AssemblyClassLoader loader in referencedAssemblies)
			{
				Type type = loader.GetType(name);
				if(type != null)
				{
					return type;
				}
			}
			return null;
		}

@


1.39.2.2
log
@back ported the follwing fixes and incremented version to 0.34.0.4:
- magic assembly type for assembly attribute annotations (bug #1721688)
- LocalVariableTable robustness fix (bug #1765952)
- public interfaces extending non-public interfaces
- parameter annotations on redirected contructors
- casting ghost interface arrays (bug #1757889)
- JNI NewObject fix
- make sure all implemented interface methods on .NET types are public (so that ikvmstub generates jars that javac is happy with)
@
text
@a2198 1
			ArrayList assemblyAnnotations = new ArrayList();
a2212 6
					// NOTE the "assembly" type in the unnamed package is a magic type
					// that acts as the placeholder for assembly attributes
					if(f.Name == "assembly" && f.Annotations != null)
					{
						assemblyAnnotations.AddRange(f.Annotations);
					}
a2501 8
			foreach(object[] def in assemblyAnnotations)
			{
				Annotation annotation = Annotation.Load(loader, def);
				if(annotation != null)
				{
					annotation.Apply(loader.assemblyBuilder, def);
				}
			}
@


1.38
log
@As pointed out by FxCop:
- Comparable.__Helper should not have a public constructor and should be sealed.
- Shadow methods in remapped types (that exist to hide the Java methods from Intellisense) should copy LinkDemands from the methods that they hide.
@
text
@d2374 4
a2377 1
							StaticCompiler.IssueMessage(Message.SkippingReferencedClass, s, ((AssemblyClassLoader)wrapper.GetClassLoader()).Assembly.FullName);
@


1.37
log
@Restructured mutual dependency of IKVM.Runtime and IKVM.GNU.Classpath to work around Mono C# compiler limitation.
@
text
@d41 2
d839 1
d847 4
a850 1
								typeWrapper.helperTypeBuilder = typeWrapper.typeBuilder.DefineNestedType("__Helper", TypeAttributes.NestedPublic | TypeAttributes.Class);
d862 1
a862 1
							ILGenerator ilgen = helper.GetILGenerator();
a1466 1
					// TODO if the original method has a LinkDemand, we should copy that
d1482 1
d1529 17
@


1.36
log
@- Changed ikvmc to fail with a Link Error when it detects a loader constraints violation (instead of emitting code that throws a LinkageError at runtime).
@
text
@a2339 8
			// NOTE types from IKVM.Runtime that are "published" should also be added to
			// the white list in DotNetTypeWrapper.IsAllowedOutside()
			Type libvminterface = StaticCompiler.runtimeAssembly.GetType("ikvm.internal.LibraryVMInterface");
			if(libvminterface != null)
			{
				ClassLoaderWrapper.PublishLibraryImplementationHelperType(libvminterface);
			}

@


1.35
log
@- Added warning to ikvmc when skipping a class that is already in a referenced assembly.
- Changed ikvmc -nowarn to use only the first variable string in a warning as the key.
@
text
@d2675 26
@


1.34
log
@*** empty log message ***
@
text
@d2357 5
d2536 1
d2599 1
a2599 1
			foreach(string s in values)
d2601 1
a2601 1
				sb.Append(':').Append(s);
d2658 4
@


1.33
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d2577 1
d2584 5
d2655 7
@


1.32
log
@*** empty log message ***
@
text
@d1078 4
a1081 1
					if(mbHelper != null)
@


1.31
log
@*** empty log message ***
@
text
@d2451 7
d2507 1
@


1.30
log
@*** empty log message ***
@
text
@d962 2
a963 2
							// NOTE instancehelpers for protected methods are made public,
							// because cli.System.Object derived types can call protected methods
d967 1
a967 3
								attr |= MethodAttributes.Public;
								// mark with specialname, so that tools (hopefully) won't show them
								attr |= MethodAttributes.SpecialName;
@


1.29
log
@*** empty log message ***
@
text
@d1484 5
a1489 1
							ilgen.Emit(OpCodes.Call, mi);
@


1.28
log
@*** empty log message ***
@
text
@d2111 31
@


1.27
log
@*** empty log message ***
@
text
@a2305 5
			Type pointer = StaticCompiler.runtimeAssembly.GetType("gnu.classpath.Pointer");
			if(pointer != null)
			{
				ClassLoaderWrapper.PublishLibraryImplementationHelperType(pointer);
			}
@


1.26
log
@*** empty log message ***
@
text
@a185 9
					if(!f.IsInterface
						&& !f.IsAbstract
						&& !f.IsPublic
						&& !f.IsFinal
						&& !baseClasses.ContainsKey(f.Name)
						&& !options.targetIsModule)
					{
						f.SetEffectivelyFinal();
					}
d197 9
@


1.25
log
@*** empty log message ***
@
text
@d1401 1
a1401 1
								fields.Add(new ConstantFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, fb, constant, MemberFlags.LiteralField));
@


1.24
log
@*** empty log message ***
@
text
@d65 1
d186 9
d2127 1
d2130 1
a2130 1
			if(options.mainClass == null && (options.guessFileKind || options.target != PEFileKinds.Dll))
d2132 2
a2133 1
				foreach(DictionaryEntry de in options.classes)
d2135 3
a2137 2
					ClassFile f;
					try
d2139 1
a2139 6
						byte[] buf = (byte[])de.Value;
						f = new ClassFile(buf, 0, buf.Length, null, ClassFileParseOptions.None);
					}
					catch(ClassFormatError)
					{
						continue;
d2141 7
d2251 1
@


1.23
log
@*** empty log message ***
@
text
@a130 1
			AttributeHelper.SetJavaModule(moduleBuilder);
d285 2
a286 4
				IResourceWriter writer = mb.DefineResource("class.map", "", ResourceAttributes.Public);
				MemoryStream ms = new MemoryStream();
				BinaryWriter bw = new BinaryWriter(ms, System.Text.Encoding.UTF8);
				bw.Write(nameMappings.Count);
d289 2
a290 2
					bw.Write((string)de.Key);
					bw.Write((string)de.Value);
d292 7
a298 1
				writer.AddResource("m", ms.ToArray());
d304 3
a306 9
				IResourceWriter writer = mb.DefineResource("pkg.lst", "", ResourceAttributes.Public);
				MemoryStream ms = new MemoryStream();
				BinaryWriter bw = new BinaryWriter(ms, System.Text.Encoding.UTF8);
				bw.Write(packages.Count);
				foreach(string pkg in packages.Keys)
				{
					bw.Write(pkg);
				}
				writer.AddResource("m", ms.ToArray());
@


1.22
log
@*** empty log message ***
@
text
@d2080 2
a2081 1
									Console.Error.WriteLine("   (current runtime is {0})", runtimeAssemblyName.FullName);
d2087 1
a2087 1
								if(asmref.GetPublicKey() != null && asmref.GetPublicKey().Length != 0)
d2090 2
a2091 1
									Console.Error.WriteLine("   (current runtime is {0})", runtimeAssemblyName.FullName);
@


1.21
log
@*** empty log message ***
@
text
@d710 1
a710 33
							if(m.redirect.Type != "static" || m.redirect.Class == null || m.redirect.Name == null || m.redirect.Sig == null)
							{
								throw new NotImplementedException();
							}
							Type[] redirParamTypes = ClassLoaderWrapper.GetBootstrapClassLoader().ArgTypeListFromSig(m.redirect.Sig);
							for(int i = 0; i < redirParamTypes.Length; i++)
							{
								ilgen.Emit(OpCodes.Ldarg, (short)i);
							}
							// HACK if the class name contains a comma, we assume it is a .NET type
							if(m.redirect.Class.IndexOf(',') >= 0)
							{
								Type type = Type.GetType(m.redirect.Class, true);
								MethodInfo mi = type.GetMethod(m.redirect.Name, redirParamTypes);
								if(mi == null)
								{
									throw new InvalidOperationException();
								}
								ilgen.Emit(OpCodes.Call, mi);
							}
							else
							{
								TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(m.redirect.Class);
								MethodWrapper mw = tw.GetMethodWrapper(m.redirect.Name, m.redirect.Sig, false);
								if(mw == null)
								{
									throw new InvalidOperationException();
								}
								mw.Link();
								mw.EmitCall(ilgen);
							}
							// TODO we may need a cast here (or a stack to return type conversion)
							ilgen.Emit(OpCodes.Ret);
@


1.20
log
@*** empty log message ***
@
text
@d2075 12
a2086 1
					Assembly reference = Assembly.Load(AssemblyName.GetAssemblyName(r));
@


1.19
log
@*** empty log message ***
@
text
@a95 19
		class CompilerTypeWrapperFactory : DynamicClassLoader
		{
			internal CompilerTypeWrapperFactory(ModuleBuilder moduleBuilder)
				: base(moduleBuilder)
			{
			}

			protected override DynamicTypeWrapper CreateDynamicTypeWrapper(ClassFile f, ClassLoaderWrapper loader)
			{
				CompilerClassLoader classLoader = (CompilerClassLoader)loader;
				int pos = f.Name.LastIndexOf('.');
				if(pos != -1)
				{
					classLoader.packages[f.Name.Substring(0, pos)] = "";
				}
				return new AotTypeWrapper(f, classLoader);
			}
		}

d104 1
a104 6
		protected override TypeWrapperFactory CreateTypeWrapperFactory()
		{
			return new CompilerTypeWrapperFactory(CreateModuleBuilder());
		}

		private ModuleBuilder CreateModuleBuilder()
d2336 5
@


1.18
log
@*** empty log message ***
@
text
@d67 1
a67 1
			: base(null)
d98 2
a99 4
			private CompilerClassLoader classLoader;

			internal CompilerTypeWrapperFactory(CompilerClassLoader classLoader)
				: base(classLoader, classLoader.options.codegenoptions)
a100 1
				this.classLoader = classLoader;
d103 1
a103 1
			protected override DynamicTypeWrapper CreateDynamicTypeWrapper(ClassFile f)
d105 1
a112 5

			protected override ModuleBuilder CreateModuleBuilder()
			{
				return classLoader.CreateModuleBuilder();
			}
d125 1
a125 1
			return new CompilerTypeWrapperFactory(this);
d291 1
a291 1
			DynamicClassLoader.FinishAll(false);
@


1.17
log
@*** empty log message ***
@
text
@a439 8
			internal override Assembly Assembly
			{
				get
				{
					return typeBuilder.Assembly;
				}
			}

d2058 1
a2058 1
					AttributeHelper.SetCustomAttribute(this.GetTypeWrapperFactory().AssemblyBuilder, attr);
a2061 170
	}

	class CompilerOptions
	{
		internal string path;
		internal string keyfilename;
		internal string keycontainer;
		internal string version;
		internal string fileversion;
		internal bool targetIsModule;
		internal string assembly;
		internal string mainClass;
		internal ApartmentState apartment;
		internal PEFileKinds target;
		internal bool guessFileKind;
		internal Hashtable classes;
		internal string[] references;
		internal Hashtable resources;
		internal string[] classesToExclude;
		internal string remapfile;
		internal Hashtable props;
		internal bool noglobbing;
		internal CodeGenOptions codegenoptions;
		internal bool removeUnusedFields;
		internal bool compressedResources;
		internal string runtimeAssembly;
		internal string[] privatePackages;
		internal string sourcepath;
	}

	enum Message
	{
		// These are the informational messages
		MainMethodFound = 1,
		OutputFileIs = 2,
		AutoAddRef = 3,
		MainMethodFromManifest = 4,
		// This is were the warnings start
		StartWarnings = 100,
		ClassNotFound = 100,
		ClassFormatError = 101,
		DuplicateClassName = 102,
		IllegalAccessError = 103,
		VerificationError = 104,
		NoClassDefFoundError = 105,
		GenericUnableToCompileError = 106,
		DuplicateResourceName = 107,
		NotAClassFile = 108,
	}

	class StaticCompiler
	{
		internal static Assembly runtimeAssembly;

		internal static Type GetType(string name)
		{
			return GetType(name, true);
		}

		internal static Type GetType(string name, bool throwOnError)
		{
			if(runtimeAssembly.GetType(name) != null)
			{
				return runtimeAssembly.GetType(name);
			}
#if WHIDBEY
			foreach(Assembly asm in AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies())
			{
				Type t = asm.GetType(name, false);
				if(t != null)
				{
					return t;
				}
			}
			// try mscorlib as well
			return typeof(object).Assembly.GetType(name, throwOnError);
#else
			foreach(Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
			{
				Type t = asm.GetType(name, false);
				if(t != null)
				{
					return t;
				}
			}
			if(throwOnError)
			{
				throw new TypeLoadException(name);
			}
			return null;
#endif
		}

		private static Hashtable suppressWarnings = new Hashtable();

		internal static void SuppressWarning(string key)
		{
			suppressWarnings[key] = key;
		}

		internal static void IssueMessage(Message msgId, params string[] values)
		{
			StringBuilder sb = new StringBuilder();
			sb.Append((int)msgId);
			foreach(string s in values)
			{
				sb.Append(':').Append(s);
			}
			string key = sb.ToString();
			if(suppressWarnings.ContainsKey(key)
				|| suppressWarnings.ContainsKey(((int)msgId).ToString()))
			{
				return;
			}
			suppressWarnings.Add(key, key);
			string msg;
			switch(msgId)
			{
				case Message.MainMethodFound:
					msg = "found main method in class \"{0}\"";
					break;
				case Message.OutputFileIs:
					msg = "output file is \"{0}\"";
					break;
				case Message.AutoAddRef:
					msg = "automatically adding reference to \"{0}\"";
					break;
				case Message.MainMethodFromManifest:
					msg = "using main class \"{0}\" based on jar manifest";
					break;
				case Message.ClassNotFound:
					msg = "class \"{0}\" not found";
					break;
				case Message.ClassFormatError:
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (class format error \"{1}\")";
					break;
				case Message.DuplicateClassName:
					msg = "duplicate class name: \"{0}\"";
					break;
				case Message.IllegalAccessError:
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (illegal access error \"{1}\")";
					break;
				case Message.VerificationError:
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (verification error \"{1}\")";
					break;
				case Message.NoClassDefFoundError:
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (missing class \"{1}\")";
					break;
				case Message.GenericUnableToCompileError:
					msg = "unable to compile class \"{0}\"" + Environment.NewLine + 
						"    (\"{1}\": \"{2}\")";
					break;
				case Message.DuplicateResourceName:
					msg = "skipping resource (name clash): \"{0}\"";
					break;
				case Message.NotAClassFile:
					msg = "not a class file \"{0}\", including it as resource" + Environment.NewLine +
						"    (class format error \"{1}\")";
					break;
				default:
					throw new InvalidProgramException();
			}
			Console.Error.Write("{0} IKVMC{1:D4}: ", msgId < Message.StartWarnings ? "Note" : "Warning", (int)msgId);
			Console.Error.WriteLine(msg, values);
		}
	}
a2062 2
	class AotCompiler
	{
d2419 1
a2419 1
				if(method.DeclaringType.Assembly != loader.GetTypeWrapperFactory().AssemblyBuilder
d2458 1
a2458 1
				loader.GetTypeWrapperFactory().AssemblyBuilder.SetCustomAttribute(filever);
d2460 1
a2460 1
			loader.GetTypeWrapperFactory().AssemblyBuilder.DefineVersionInfoResource();
d2477 169
@


1.16
log
@*** empty log message ***
@
text
@d61 4
d1821 1
a1821 1
				AotTypeWrapper.SetupGhosts(map);
d1843 204
d2618 1
a2618 1
				AotTypeWrapper.LoadMappedExceptions(map);
d2629 1
a2629 1
				AotTypeWrapper.LoadMapXml(map);
@


1.15
log
@*** empty log message ***
@
text
@d97 1
a97 1
				: base(classLoader)
d118 8
d153 2
a154 2
			moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName, assemblyFile, JVM.Debug);
			if(!JVM.NoStackTraceInfo)
d159 1
a159 1
			if(JVM.Debug || !JVM.NoStackTraceInfo)
d161 1
a161 1
				CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, JVM.Debug });
d197 6
a202 1
						f = new ClassFile(classdef, 0, classdef.Length, name);
d380 8
d521 1
a521 1
				if(!JVM.NoStackTraceInfo)
d734 4
a737 1
						ilgen.EmitLineNumberTable(cbCore);
d803 4
a806 1
						ilgen.EmitLineNumberTable(mbHelper);
d1133 4
a1136 1
						ilgen.EmitLineNumberTable(mbCore);
d1255 4
a1258 1
						ilgen.EmitLineNumberTable(mbHelper);
d1877 1
a1877 2
		internal byte[][] classes;
		internal string[] classNames;	// for diagnostics only (these are the file names, not the actual class names)
a1878 1
		internal bool nojni;
d1884 1
a1884 1
		internal bool nostacktraceinfo;
a1886 1
		internal bool strictFinalFieldSemantics;
d1889 1
a1898 1
		NotAClassFile = 5,
d1909 1
a1991 3
				case Message.NotAClassFile:
					msg = "\"{0}\" is not a class file, including it as resource";
					break;
d2021 4
a2043 3
			JVM.NoJniStubs = options.nojni;
			JVM.NoStackTraceInfo = options.nostacktraceinfo;
			JVM.StrictFinalFieldSemantics = options.strictFinalFieldSemantics;
d2144 1
a2144 1
			for(int i = 0; i < options.classes.Length; i++)
d2146 1
a2146 2
				string name;
				try
d2148 2
a2149 1
					if(options.mainClass == null && (options.guessFileKind || options.target != PEFileKinds.Dll))
d2151 10
a2160 3
						ClassFile f = new ClassFile(options.classes[i], 0, options.classes[i].Length, null);
						name = f.Name;
						foreach(ClassFile.Method m in f.Methods)
d2162 3
a2164 6
							if(m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V")
							{
								StaticCompiler.IssueMessage(Message.MainMethodFound, f.Name);
								options.mainClass = f.Name;
								break;
							}
a2166 9
					else
					{
						name = ClassFile.GetClassName(options.classes[i], 0, options.classes[i].Length);
					}
				}
				catch(ClassFormatError x)
				{
					StaticCompiler.IssueMessage(Message.ClassFormatError, options.classNames[i], x.Message);
					continue;
d2168 4
d2188 1
a2188 1
					h[name] = options.classes[i];
d2279 10
a2288 1
			if(loader.LoadClassByDottedNameFast("java.lang.Object") == null)
a2331 17
					// HACK skip synthetic delegate inner classes
					// (we don't want to generate the unused interfaces)
					if(s.EndsWith(DotNetTypeWrapper.DelegateInterfaceSuffix))
					{
						byte[] buf = (byte[])h[s];
						try
						{
							ClassFile c = new ClassFile(buf, 0, buf.Length, s);
							if(c.IKVMAssemblyAttribute != null)
							{
								continue;
							}
						}
						catch
						{
						}
					}
@


1.14
log
@*** empty log message ***
@
text
@d622 1
a622 1
				internal override void EmitNewobj(ILGenerator ilgen)
@


1.13
log
@*** empty log message ***
@
text
@a2233 1
			JVM.IsStaticCompilerPhase1 = true;
a2387 1
			JVM.IsStaticCompilerPhase1 = false;
@


1.12
log
@*** empty log message ***
@
text
@d193 1
a193 1
						StaticCompiler.IssueMessage(Message.ClassFormatError, x.Message);
d1845 1
d1868 1
d1961 3
d1968 2
a1969 1
					msg = "class format error: \"{0}\"";
a2138 5
				catch(UnsupportedClassVersionError x)
				{
					Console.Error.WriteLine("Error: unsupported class file version: {0}", x.Message);
					return 1;
				}
d2141 2
a2142 2
					Console.Error.WriteLine("Error: invalid class file: {0}", x.Message);
					return 1;
d2323 4
@


1.11
log
@*** empty log message ***
@
text
@d231 1
a231 1
			Type startupType = StaticCompiler.GetType("IKVM.Runtime.Startup");
d242 1
a242 1
				ilgen.Emit(OpCodes.Call, startupType.GetMethod("SetProperties"));
d245 1
a245 1
			ilgen.Emit(OpCodes.Call, startupType.GetMethod("EnterMainThread"));
d252 1
a252 1
				ilgen.Emit(OpCodes.Call, startupType.GetMethod("Glob", Type.EmptyTypes));
d256 1
a256 1
			ilgen.Emit(OpCodes.Call, StaticCompiler.GetType("IKVM.Runtime.Util").GetMethod("MapException", new Type[] { typeof(Exception) }));
d271 1
a271 1
			ilgen.Emit(OpCodes.Call, startupType.GetMethod("ExitMainThread", Type.EmptyTypes));
@


1.10
log
@*** empty log message ***
@
text
@d1394 1
a1394 1
							fields.Add(new GetterFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), null, f.Name, f.Sig, new ExModifiers((Modifiers)f.Modifiers, false), (MethodInfo)method.GetMethod()));
@


1.9
log
@*** empty log message ***
@
text
@d44 1
a44 1
	class CompilerClassLoader : BootstrapClassLoader
d58 3
d62 2
a63 2
		internal CompilerClassLoader(CompilerOptions options, string path, string keyfilename, string keycontainer, string version, bool targetIsModule, string assemblyName, Hashtable classes)
			: base()
d65 1
d79 13
d104 5
d161 1
a161 2
			TypeWrapper tw = base.LoadClassImpl(name, throwClassNotFoundException);
			if(tw == null)
d163 5
a167 1
				tw = GetTypeWrapperCompilerHook(name);
d169 1
a169 1
			return tw;
d283 42
a324 1
			GetTypeWrapperFactory().ModuleBuilder.CreateGlobalFunctions();
d2031 1
d2043 1
a2043 1
					Assembly reference = Assembly.LoadFrom(r);
d2050 1
d2226 6
a2231 1
			CompilerClassLoader loader = new CompilerClassLoader(options, options.path, options.keyfilename, options.keycontainer, options.version, options.targetIsModule, options.assembly, h);
d2263 1
@


1.8
log
@*** empty log message ***
@
text
@d168 1
a168 1
						Console.Error.WriteLine("Warning: class format error: {0}", x.Message);
d199 1
a199 1
			MethodBuilder mainStub = this.ModuleBuilder.DefineGlobalMethod("main", MethodAttributes.Public | MethodAttributes.Static, typeof(int), args);
d258 1
a258 1
			ModuleBuilder.CreateGlobalFunctions();
d277 1
a277 1
			ModuleBuilder moduleBuilder = this.ModuleBuilder;
d422 1
a422 1
				typeBuilder = classLoader.ModuleBuilder.DefineType(name, attrs, baseIsSealed ? typeof(object) : baseType);
d1759 1
a1759 1
					AttributeHelper.SetCustomAttribute(((AssemblyBuilder)this.ModuleBuilder.Assembly), attr);
d1794 19
d1855 72
d2054 1
a2054 1
								Console.Error.WriteLine("Note: found main method in class \"{0}\"", f.Name);
d2086 1
a2086 1
					Console.Error.WriteLine("Warning: duplicate class name: {0}", name);
d2136 1
a2136 1
				Console.Error.WriteLine("Note: output file is \"{0}\"", options.path);
d2191 1
a2191 1
				Console.Error.WriteLine("Note: automatically adding reference to \"{0}\"", JVM.CoreAssembly.Location);
d2250 1
a2250 2
					Console.Error.WriteLine("Warning: unable to compile class \"{0}\"", s);
					Console.Error.WriteLine("    (illegal access error \"{0}\")", x.Message);
d2254 1
a2254 2
					Console.Error.WriteLine("Warning: unable to compile class \"{0}\"", s);
					Console.Error.WriteLine("    (verification error \"{0}\")", x.Message);
d2258 1
a2258 2
					Console.Error.WriteLine("Warning: unable to compile class \"{0}\"", s);
					Console.Error.WriteLine("    (missing class \"{0}\")", x.Message);
d2262 1
a2262 2
					Console.Error.WriteLine("Warning: unable to compile class \"{0}\"", s);
					Console.Error.WriteLine("    ({0}: \"{1}\")", x.GetType().Name, x.Message);
d2293 1
a2293 1
				if(method.DeclaringType.Assembly != loader.ModuleBuilder.Assembly
d2333 1
a2333 1
				((AssemblyBuilder)loader.ModuleBuilder.Assembly).SetCustomAttribute(filever);
d2335 1
a2335 1
			((AssemblyBuilder)loader.ModuleBuilder.Assembly).DefineVersionInfoResource();
@


1.7
log
@*** empty log message ***
@
text
@d44 1
a44 1
	class CompilerClassLoader : ClassLoaderWrapper
d60 1
a60 1
			: base(null)
d137 1
a137 1
		internal override TypeWrapper GetTypeWrapperCompilerHook(string name)
d139 11
a149 1
			TypeWrapper type = base.GetTypeWrapperCompilerHook(name);
@


1.6
log
@*** empty log message ***
@
text
@d44 1
a44 1
	class CompilerClassLoader : DynamicClassLoader
d75 1
a75 1
		protected override DynamicTypeWrapper CreateDynamicTypeWrapper(ClassFile f)
d77 22
a98 1
			return new AotTypeWrapper(f, this);
d101 1
a101 1
		protected override ModuleBuilder CreateModuleBuilder()
d118 1
a118 1
				assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.ReflectionOnly, assemblyDir);
d246 1
a246 1
			FinishAll(false);
@


1.5
log
@*** empty log message ***
@
text
@a139 25
					// to enhance error reporting we special case loading of netexp
					// classes, to handle the case where the ikvmstub type doesn't exist
					// (this happens when the .NET mscorlib.jar is used on Mono, for example)
					string netexp = f.IKVMAssemblyAttribute;
					if(netexp != null)
					{
						try
						{
#if WHIDBEY
								Assembly.ReflectionOnlyLoad(netexp);
#else
							Assembly.Load(netexp);
#endif
						}
						catch(Exception)
						{
							Console.Error.WriteLine("ikvmstub assembly not found: {0}", netexp);
						}
						// HACK create a new wrapper to see if the type is visible now
						if(DotNetTypeWrapper.CreateDotNetTypeWrapper(name) == null)
						{
							Console.Error.WriteLine("Warning: ikvmstub class \"{0}\" refers to non-existing type", name);
							return null;
						}
					}
@


1.4
log
@*** empty log message ***
@
text
@d1849 1
a1849 1
				Assembly.ReflectionOnlyLoadFrom(typeof(ByteCodeHelper).Assembly.Location);
d1853 1
a1853 1
				runtimeAssembly = Assembly.ReflectionOnlyLoadFrom(options.runtimeAssembly);
d2105 2
@


1.3
log
@*** empty log message ***
@
text
@d75 1
a75 1
		protected override TypeWrapper CreateDynamicTypeWrapper(ClassFile f)
@


1.2
log
@*** empty log message ***
@
text
@d24 1
a24 1
#if STATIC_COMPILER && !COMPACT_FRAMEWORK
a2257 1
#endif // STATIC_COMPILER && !COMPACT_FRAMEWORK
@


1.1
log
@moved CompilerClassLoader.cs and remapper.cs from runtime to ikvmc
@
text
@d1874 1
a1874 1
					if(AttributeHelper.IsDefined(reference, JVM.LoadType(typeof(RemappedClassAttribute))))
d2105 2
a2106 1
			if(StaticCompiler.runtimeAssembly.GetType("gnu.classpath.Pointer") != null)
d2108 1
a2108 1
				ClassLoaderWrapper.PublishLibraryImplementationHelperType(JVM.LoadType(typeof(gnu.classpath.Pointer)));
d2110 2
a2111 1
			if(StaticCompiler.runtimeAssembly.GetType("ikvm.internal.LibraryVMInterface") != null)
d2113 1
a2113 1
				ClassLoaderWrapper.PublishLibraryImplementationHelperType(JVM.LoadType(typeof(ikvm.@@internal.LibraryVMInterface)));
@

