head	1.21;
access;
symbols;
locks; strict;
comment	@ * @;


1.21
date	2004.05.27.07.12.13;	author jfrijters;	state dead;
branches;
next	1.20;

1.20
date	2004.05.14.09.31.54;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.20.13.25.08;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.16.17.10.10;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.08.15.18.47;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.28.11.28.16;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.11.13.14.42;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.24.11.51.41;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.19.22.19.18;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.17.12.01.51;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.17.08.08.31;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.10.14.58.19;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.04.09.51.15;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.26.11.24.17;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.21.10.06.35;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.12.13.09.31;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.07.14.55.43;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.31.12.49.29;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.07.14.18.27;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.10.13.28.48;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.30.12.09.01;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.21
log
@*** empty log message ***
@
text
@/*
  Copyright (C) 2002 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Diagnostics;
using OpenSystem.Java;

class MemberWrapper
{
	private System.Runtime.InteropServices.GCHandle handle;
	private TypeWrapper declaringType;
	private Modifiers modifiers;
	private bool hideFromReflection;

	protected MemberWrapper(TypeWrapper declaringType, Modifiers modifiers, bool hideFromReflection)
	{
		Debug.Assert(declaringType != null);
		this.declaringType = declaringType;
		this.modifiers = modifiers;
		this.hideFromReflection = hideFromReflection;
	}

	~MemberWrapper()
	{
		if(handle.IsAllocated)
		{
			handle.Free();
		}
	}

	internal IntPtr Cookie
	{
		get
		{
			lock(this)
			{
				if(!handle.IsAllocated)
				{
					handle = System.Runtime.InteropServices.GCHandle.Alloc(this, System.Runtime.InteropServices.GCHandleType.Weak);
				}
			}
			return (IntPtr)handle;
		}
	}

	internal static MemberWrapper FromCookieImpl(IntPtr cookie)
	{
		return (MemberWrapper)((System.Runtime.InteropServices.GCHandle)cookie).Target;
	}

	internal TypeWrapper DeclaringType
	{
		get
		{
			return declaringType;
		}
	}

	internal bool IsHideFromReflection
	{
		get
		{
			return hideFromReflection;
		}
	}

	internal Modifiers Modifiers
	{
		get
		{
			return modifiers;
		}
	}

	internal bool IsStatic
	{
		get
		{
			return (modifiers & Modifiers.Static) != 0;
		}
	}

	internal bool IsPublic
	{
		get
		{
			return (modifiers & Modifiers.Public) != 0;
		}
	}

	internal bool IsPrivate
	{
		get
		{
			return (modifiers & Modifiers.Private) != 0;
		}
	}

	internal bool IsProtected
	{
		get
		{
			return (modifiers & Modifiers.Protected) != 0;
		}
	}

	internal bool IsFinal
	{
		get
		{
			return (modifiers & Modifiers.Final) != 0;
		}
	}
}

class MethodWrapper : MemberWrapper
{
	private MethodDescriptor md;
	private MethodBase originalMethod;
	private MethodBase redirMethod;
	private string[] declaredExceptions;
	internal CodeEmitter EmitCall;
	internal CodeEmitter EmitCallvirt;
	internal CodeEmitter EmitNewobj;

	private class GhostUnwrapper : CodeEmitter
	{
		private TypeWrapper type;

		internal GhostUnwrapper(TypeWrapper type)
		{
			this.type = type;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			LocalBuilder local = ilgen.DeclareLocal(type.TypeAsParameterType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(OpCodes.Ldloca, local);
			ilgen.Emit(OpCodes.Ldfld, type.GhostRefField);
		}
	}

	// TODO creation of MethodWrappers should be cleaned up (and every instance should support Invoke())
	internal static MethodWrapper Create(TypeWrapper declaringType, MethodDescriptor md, MethodBase originalMethod, MethodBase method, Modifiers modifiers, bool hideFromReflection)
	{
		Debug.Assert(method != null);

		MethodWrapper wrapper = new MethodWrapper(declaringType, md, originalMethod, method, modifiers, hideFromReflection);
		if(declaringType.IsGhost)
		{
			wrapper.EmitCallvirt = new GhostCallEmitter(declaringType, md, originalMethod);
		}
		else
		{
			CreateEmitters(originalMethod, method, ref wrapper.EmitCall, ref wrapper.EmitCallvirt, ref wrapper.EmitNewobj);
		}
		TypeWrapper retType = md.RetTypeWrapper;
		if(!retType.IsUnloadable)
		{
			if(retType.IsNonPrimitiveValueType)
			{
				wrapper.EmitCall += CodeEmitter.CreateEmitBoxCall(retType);
				wrapper.EmitCallvirt += CodeEmitter.CreateEmitBoxCall(retType);
			}
			else if(retType.IsGhost)
			{
				wrapper.EmitCall += new GhostUnwrapper(retType);
				wrapper.EmitCallvirt += new GhostUnwrapper(retType);
			}
		}
		if(declaringType.IsNonPrimitiveValueType)
		{
			if(method is ConstructorInfo)
			{
				// HACK after constructing a new object, we don't want the custom boxing rule to run
				// (because that would turn "new IntPtr" into a null reference)
				wrapper.EmitNewobj += CodeEmitter.Create(OpCodes.Box, declaringType.TypeAsTBD);
			}
			else
			{
				// callvirt isn't allowed on a value type
				wrapper.EmitCallvirt = wrapper.EmitCall;
			}
		}
		return wrapper;
	}

	internal class GhostCallEmitter : CodeEmitter
	{
		private MethodDescriptor md;
		private TypeWrapper type;
		private MethodInfo method;

		internal GhostCallEmitter(TypeWrapper type, MethodDescriptor md, MethodBase __method)
		{
			this.type = type;
			this.md = md;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			if(method == null)
			{
				method = type.TypeAsParameterType.GetMethod(md.Name, md.ArgTypesForDefineMethod);
			}
			ilgen.Emit(OpCodes.Call, method);
		}
	}

	internal static void CreateEmitters(MethodBase originalMethod, MethodBase method, ref CodeEmitter call, ref CodeEmitter callvirt, ref CodeEmitter newobj)
	{
		if(method is ConstructorInfo)
		{
			call = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)method);
			callvirt = null;
			newobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)method);
		}
		else
		{
			call = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
			if(originalMethod != null && originalMethod != method)
			{
				// if we're calling a virtual method that is redirected, that overrides an already
				// existing method, we have to call it virtually, instead of redirecting
				callvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)originalMethod);
			}
			else if(method.IsStatic)
			{
				// because of redirection, it can be legal to call a static method with invokevirtual
				callvirt = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
			}
			else
			{
				callvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)method);
			}
			newobj = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
		}
	}

	internal MethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase originalMethod, MethodBase method, Modifiers modifiers, bool hideFromReflection)
		: base(declaringType, modifiers, hideFromReflection)
	{
		Profiler.Count("MethodWrapper");
		if(method != originalMethod)
		{
			redirMethod = method;
			Debug.Assert(!(method is MethodBuilder));
		}
		this.md = md;
		// NOTE originalMethod may be null
		this.originalMethod = originalMethod;
	}

	internal void SetDeclaredExceptions(string[] exceptions)
	{
		if(exceptions == null)
		{
			exceptions = new string[0];
		}
		this.declaredExceptions = (string[])exceptions.Clone();
	}

	internal void SetDeclaredExceptions(MapXml.Throws[] throws)
	{
		if(throws != null)
		{
			declaredExceptions = new string[throws.Length];
			for(int i = 0; i < throws.Length; i++)
			{
				declaredExceptions[i] = throws[i].Class;
			}
		}
	}

	internal static MethodWrapper FromCookie(IntPtr cookie)
	{
		return (MethodWrapper)FromCookieImpl(cookie);
	}

	internal MethodDescriptor Descriptor
	{
		get
		{
			return md;
		}
	}

	internal string Name
	{
		get
		{
			return md.Name;
		}
	}

	internal bool HasUnloadableArgsOrRet
	{
		get
		{
			if(ReturnType.IsUnloadable)
			{
				return true;
			}
			foreach(TypeWrapper tw in GetParameters())
			{
				if(tw.IsUnloadable)
				{
					return true;
				}
			}
			return false;
		}
	}

	internal TypeWrapper ReturnType
	{
		get
		{
			return md.RetTypeWrapper;
		}
	}

	internal TypeWrapper[] GetParameters()
	{
		return md.ArgTypeWrappers;
	}

	internal string[] GetExceptions()
	{
		// remapped types and dynamically compiled types have declaredExceptions set
		if(declaredExceptions != null)
		{
			return (string[])declaredExceptions.Clone();
		}
		// NOTE if originalMethod is a MethodBuilder, GetCustomAttributes doesn't work
		if(originalMethod != null && !(originalMethod is MethodBuilder))
		{
			object[] attributes = originalMethod.GetCustomAttributes(typeof(ThrowsAttribute), false);
			if(attributes.Length == 1)
			{
				return ((ThrowsAttribute)attributes[0]).Classes;
			}
		}
		return new string[0];
	}

	// we expose the underlying MethodBase object,
	// for Java types, this is the method that contains the compiled Java bytecode
	// for remapped types, this is the method that underlies the remapped method
	internal MethodBase GetMethod()
	{
		return originalMethod;
	}

	internal string RealName
	{
		get
		{
			return originalMethod.Name;
		}
	}

	// this returns the Java method's attributes in .NET terms (e.g. used to create stubs for this method)
	internal MethodAttributes GetMethodAttributes()
	{
		MethodAttributes attribs = 0;
		if(IsStatic)
		{
			attribs |= MethodAttributes.Static;
		}
		if(IsPublic)
		{
			attribs |= MethodAttributes.Public;
		}
		else if(IsPrivate)
		{
			attribs |= MethodAttributes.Private;
		}
		else if(IsProtected)
		{
			attribs |= MethodAttributes.FamORAssem;
		}
		else
		{
			attribs |= MethodAttributes.Family;
		}
		// constructors aren't virtual
		if(!IsStatic && !IsPrivate && md.Name != "<init>")
		{
			attribs |= MethodAttributes.Virtual;
		}
		if(IsFinal)
		{
			attribs |= MethodAttributes.Final;
		}
		if(IsAbstract)
		{
			attribs |= MethodAttributes.Abstract;
		}
		return attribs;
	}

	internal bool IsAbstract
	{
		get
		{
			return (Modifiers & Modifiers.Abstract) != 0;
		}
	}

	internal virtual object Invoke(object obj, object[] args, bool nonVirtual)
	{
		// TODO if any of the parameters is a ghost, convert the passed in reference to a ghost value type
		// TODO instead of looking up the method using reflection, we should use the method object passed into the
		// constructor
		if(IsStatic)
		{
			MethodInfo method = this.originalMethod != null && !(this.originalMethod is MethodBuilder) ? (MethodInfo)this.originalMethod : DeclaringType.TypeAsTBD.GetMethod(md.Name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypesDontUse, null);
			try
			{
				return method.Invoke(null, args);
			}
			catch(ArgumentException x1)
			{
				throw JavaException.IllegalArgumentException(x1.Message);
			}
			catch(TargetInvocationException x)
			{
				throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
			}
		}
		else
		{
			// calling <init> without an instance means that we're constructing a new instance
			// NOTE this means that we cannot detect a NullPointerException when calling <init>
			if(md.Name == "<init>")
			{
				ConstructorInfo constructor = this.originalMethod != null && !(this.originalMethod is ConstructorBuilder) ? (ConstructorInfo)this.originalMethod : DeclaringType.TypeAsTBD.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, CallingConventions.Standard, md.ArgTypesDontUse, null);
				try
				{
					if(obj != null)
					{
						return constructor.Invoke(obj, args);
					}
					else
					{
						return constructor.Invoke(args);
					}
				}
				catch(ArgumentException x1)
				{
					throw JavaException.IllegalArgumentException(x1.Message);
				}
				catch(TargetInvocationException x)
				{
					throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
				}
			}
			if(nonVirtual)
			{
				throw new NotImplementedException("non-virtual reflective method invocation not implemented");
			}
			MethodInfo method = (MethodInfo)this.originalMethod;
			if(redirMethod != null)
			{
				method = (MethodInfo)redirMethod;
				if(method.IsStatic)
				{
					// we've been redirected to a static method, so we have to copy the this into the args
					object[] oldargs = args;
					args = new object[args.Length + 1];
					args[0] = obj;
					oldargs.CopyTo(args, 1);
					obj = null;
				}
			}
			else
			{
				if(method is MethodBuilder || method == null)
				{
					method = DeclaringType.TypeAsTBD.GetMethod(md.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypesDontUse, null);
				}
				if(method == null)
				{
					throw new NotImplementedException("method not found: " + this.DeclaringType.Name + "." + md.Name + md.Signature);
				}
			}
			try
			{
				return method.Invoke(obj, args);
			}
			catch(ArgumentException x1)
			{
				throw JavaException.IllegalArgumentException(x1.Message);
			}
			catch(TargetInvocationException x)
			{
				throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
			}
		}
	}
}

// This class tests if reflection on a constant field triggers the class constructor to run
// (it shouldn't run, but on .NET 1.0 & 1.1 it does)
class ReflectionOnConstant
{
	private static bool isBroken;
	private static System.Collections.Hashtable warnOnce;

	static ReflectionOnConstant()
	{
		typeof(Helper).GetField("foo", BindingFlags.NonPublic | BindingFlags.Static).GetValue(null);
	}

	internal static bool IsBroken
	{
		get
		{
			return isBroken;
		}
	}

	internal static void IssueWarning(FieldInfo field)
	{
		// FXBUG .NET (1.0 & 1.1)
		// FieldInfo.GetValue() on a literal causes the type initializer to run and
		// we don't want that.
		// TODO may need to find a workaround, for now we just spit out a warning
		if(ReflectionOnConstant.IsBroken && field.DeclaringType.TypeInitializer != null)
		{
			if(Tracer.FxBug.TraceWarning)
			{
				if(warnOnce == null)
				{
					warnOnce = new System.Collections.Hashtable();
				}
				if(!warnOnce.ContainsKey(field.DeclaringType.FullName))
				{
					warnOnce.Add(field.DeclaringType.FullName, null);
					Tracer.Warning(Tracer.FxBug, "Running type initializer for {0} due to CLR bug", field.DeclaringType.FullName);
				}
			}
		}
	}

	private class Helper
	{
		internal const int foo = 1;

		static Helper()
		{
			isBroken = true;
		}
	}
}

class FieldWrapper : MemberWrapper
{
	private string name;
	private string sig;
	internal readonly CodeEmitter EmitGet;
	internal readonly CodeEmitter EmitSet;
	private FieldInfo field;
	private TypeWrapper fieldType;

	private FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, CodeEmitter emitGet, CodeEmitter emitSet)
		: base(declaringType, modifiers, false)
	{
		Debug.Assert(fieldType != null);
		Debug.Assert(name != null);
		Debug.Assert(sig != null);
		Debug.Assert(emitGet != null);
		Debug.Assert(emitSet != null);
		this.name = name;
		this.sig = sig;
		this.fieldType = fieldType;
		this.field = field;
		this.EmitGet = emitGet;
		this.EmitSet = emitSet;
	}

	// HACK used (indirectly thru NativeCode.java.lang.Field.getConstant) by netexp to find out if the
	// field is a constant (and if it is, to get its value)
	internal object GetConstant()
	{
		// NOTE only pritimives and string can be literals in Java (because the other "primitives" (like uint),
		// are treated as NonPrimitiveValueTypes)
		if(field != null && (fieldType.IsPrimitive || fieldType == CoreClasses.java.lang.String.Wrapper) && field.IsLiteral)
		{
			ReflectionOnConstant.IssueWarning(field);
			object val = field.GetValue(null);
			if(val != null && !(val is string))
			{
				return NativeCode.java.lang.reflect.JavaWrapper.Box(val);
			}
			return val;
		}
		return null;
	}

	internal static FieldWrapper FromCookie(IntPtr cookie)
	{
		return (FieldWrapper)FromCookieImpl(cookie);
	}

	internal string Name
	{
		get
		{
			return name;
		}
	}

	internal TypeWrapper FieldTypeWrapper
	{
		get
		{
			return fieldType;
		}
	}

	internal bool IsVolatile
	{
		get
		{
			return (Modifiers & Modifiers.Volatile) != 0;
		}
	}

	private class VolatileLongDoubleGetter : CodeEmitter
	{
		private static MethodInfo volatileReadDouble = typeof(System.Threading.Thread).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Double&") });
		private static MethodInfo volatileReadLong = typeof(System.Threading.Thread).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Int64&") });
		private FieldInfo fi;

		internal VolatileLongDoubleGetter(FieldInfo fi)
		{
			this.fi = fi;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(fi.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldflda, fi);
			if(fi.FieldType == typeof(double))
			{
				ilgen.Emit(OpCodes.Call, volatileReadDouble);
			}
			else
			{
				Debug.Assert(fi.FieldType == typeof(long));
				ilgen.Emit(OpCodes.Call, volatileReadLong);
			}
		}
	}

	private class VolatileLongDoubleSetter : CodeEmitter
	{
		private static MethodInfo volatileWriteDouble = typeof(System.Threading.Thread).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Double&"), typeof(double) });
		private static MethodInfo volatileWriteLong = typeof(System.Threading.Thread).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Int64&"), typeof(long) });
		private FieldInfo fi;

		internal VolatileLongDoubleSetter(FieldInfo fi)
		{
			this.fi = fi;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			LocalBuilder temp = ilgen.DeclareLocal(fi.FieldType);
			ilgen.Emit(OpCodes.Stloc, temp);
			ilgen.Emit(fi.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldflda, fi);
			ilgen.Emit(OpCodes.Ldloc, temp);
			if(fi.FieldType == typeof(double))
			{
				ilgen.Emit(OpCodes.Call, volatileWriteDouble);
			}
			else
			{
				Debug.Assert(fi.FieldType == typeof(long));
				ilgen.Emit(OpCodes.Call, volatileWriteLong);
			}
		}
	}

	private class ValueTypeFieldSetter : CodeEmitter
	{
		private Type declaringType;
		private Type fieldType;

		internal ValueTypeFieldSetter(Type declaringType, Type fieldType)
		{
			this.declaringType = declaringType;
			this.fieldType = fieldType;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			LocalBuilder local = ilgen.DeclareLocal(fieldType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(OpCodes.Unbox, declaringType);
			ilgen.Emit(OpCodes.Ldloc, local);
		}
	}

	private class GhostFieldSetter : CodeEmitter
	{
		private OpCode ldflda;
		private FieldInfo field;
		private TypeWrapper type;

		internal GhostFieldSetter(FieldInfo field, TypeWrapper type, OpCode ldflda)
		{
			this.field = field;
			this.type = type;
			this.ldflda = ldflda;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			LocalBuilder local = ilgen.DeclareLocal(type.TypeAsLocalOrStackType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(ldflda, field);
			ilgen.Emit(OpCodes.Ldloc, local);
			ilgen.Emit(OpCodes.Stfld, type.GhostRefField);
		}
	}

	internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo fi, CodeEmitter getter, CodeEmitter setter)
	{
		return new FieldWrapper(declaringType, fieldType, name, sig, modifiers, fi, getter, setter);
	}

	internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo fi, CodeEmitter getter, CodeEmitter setter, object constant)
	{
		if(constant != null)
		{
			return new ConstantFieldWrapper(declaringType, fieldType, name, sig, modifiers, fi, getter, setter, constant);
		}
		else
		{
			return new FieldWrapper(declaringType, fieldType, name, sig, modifiers, fi, getter, setter);
		}
	}

	internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string sig, Modifiers modifiers)
	{
		CodeEmitter emitGet = null;
		CodeEmitter emitSet = null;
		if(declaringType.IsNonPrimitiveValueType)
		{
			// NOTE all that ValueTypeFieldSetter does, is unbox the boxed value type that contains the field that we are setting
			emitSet = new ValueTypeFieldSetter(declaringType.TypeAsTBD, fieldType.TypeAsTBD);
			emitGet = CodeEmitter.Create(OpCodes.Unbox, declaringType.TypeAsTBD);
		}
		if(fieldType.IsUnloadable)
		{
			// TODO we might need to emit code to check the type dynamically
			// TODO the fact that the type is unloadable now, doesn't mean it will be unloadable when a method
			// that accesses this field is compiled, that means that that method (may) need to emit a cast
			if((modifiers & Modifiers.Static) != 0)
			{
				emitGet += CodeEmitter.Create(OpCodes.Ldsfld, fi);
				emitSet += CodeEmitter.Create(OpCodes.Stsfld, fi);
			}
			else
			{
				emitGet += CodeEmitter.Create(OpCodes.Ldfld, fi);
				emitSet += CodeEmitter.Create(OpCodes.Stfld, fi);
			}
			return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, fi, emitGet, emitSet);
		}
		if(fieldType.IsGhost)
		{
			if((modifiers & Modifiers.Static) != 0)
			{
				emitGet += CodeEmitter.Create(OpCodes.Ldsflda, fi) + CodeEmitter.Create(OpCodes.Ldfld, fieldType.GhostRefField);
				emitSet += new GhostFieldSetter(fi, fieldType, OpCodes.Ldsflda);
			}
			else
			{
				emitGet += CodeEmitter.Create(OpCodes.Ldflda, fi) + CodeEmitter.Create(OpCodes.Ldfld, fieldType.GhostRefField);
				emitSet += new GhostFieldSetter(fi, fieldType, OpCodes.Ldflda);
			}
			return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, fi, emitGet, emitSet);
		}
		if(fieldType.IsNonPrimitiveValueType)
		{
			emitSet += CodeEmitter.CreateEmitUnboxCall(fieldType);
		}
		if((modifiers & Modifiers.Volatile) != 0)
		{
			// long & double field accesses must be made atomic
			if(fi.FieldType == typeof(long) || fi.FieldType == typeof(double))
			{
				// TODO shouldn't we use += here (for volatile fields inside of value types)?
				emitGet = new VolatileLongDoubleGetter(fi);
				emitSet = new VolatileLongDoubleSetter(fi);
				return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, fi, emitGet, emitSet);
			}
			emitGet += CodeEmitter.Volatile;
			emitSet += CodeEmitter.Volatile;
		}
		if((modifiers & Modifiers.Static) != 0)
		{
			emitGet += CodeEmitter.Create(OpCodes.Ldsfld, fi);
			emitSet += CodeEmitter.Create(OpCodes.Stsfld, fi);
		}
		else
		{
			emitGet += CodeEmitter.Create(OpCodes.Ldfld, fi);
			emitSet += CodeEmitter.Create(OpCodes.Stfld, fi);
		}
		if(fieldType.IsNonPrimitiveValueType)
		{
			emitGet += CodeEmitter.CreateEmitBoxCall(fieldType);
		}
		return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, fi, emitGet, emitSet);
	}

	private void LookupField()
	{
		BindingFlags bindings = BindingFlags.Public | BindingFlags.NonPublic;
		if(IsStatic)
		{
			bindings |= BindingFlags.Static;
		}
		else
		{
			bindings |= BindingFlags.Instance;
		}
		field = DeclaringType.TypeAsTBD.GetField(name, bindings);
		Debug.Assert(field != null);
	}

	internal void SetValue(object obj, object val)
	{
		// TODO this is a broken implementation (for one thing, it needs to support redirection)
		if(field == null || field is FieldBuilder)
		{
			LookupField();
		}
		if(fieldType.IsGhost)
		{
			object temp = field.GetValue(obj);
			fieldType.GhostRefField.SetValue(temp, val);
			val = temp;
		}
		try
		{
			field.SetValue(obj, val);
		}
		catch(FieldAccessException x)
		{
			throw JavaException.IllegalAccessException(x.Message);
		}
	}

	internal virtual object GetValue(object obj)
	{
		// TODO this is a broken implementation (for one thing, it needs to support redirection)
		if(field == null || field is FieldBuilder)
		{
			LookupField();
		}
		if(field.IsLiteral)
		{
			// on a non-broken CLR GetValue on a literal will not trigger type initialization, but on Java it should
			System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(field.DeclaringType.TypeHandle);
		}
		object val = field.GetValue(obj);
		if(fieldType.IsGhost)
		{
			val = fieldType.GhostRefField.GetValue(val);
		}
		return val;
	}

	// NOTE this type is only used for remapped fields, dynamically compiled classes are always finished before we
	// allow reflection (so we can look at the underlying field in that case)
	private class ConstantFieldWrapper : FieldWrapper
	{
		private object constant;

		internal ConstantFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, CodeEmitter emitGet, CodeEmitter emitSet, object constant)
			: base(declaringType, fieldType, name, sig, modifiers, field, emitGet, emitSet)
		{
			this.constant = constant;
		}

		internal override object GetValue(object obj)
		{
			return constant;
		}
	}
}
@


1.20
log
@*** empty log message ***
@
text
@@


1.19
log
@*** empty log message ***
@
text
@d362 1
a362 2
			string[] exceptions = new string[attributes.Length];
			for(int i = 0; i < exceptions.Length; i++)
d364 1
a364 1
				exceptions[i] = ((ThrowsAttribute)attributes[i]).ClassName;
a365 1
			return exceptions;
@


1.18
log
@*** empty log message ***
@
text
@d614 1
a614 1
		if(field != null && (fieldType.IsPrimitive || fieldType == CoreClasses.java_lang_String) && field.IsLiteral)
@


1.17
log
@*** empty log message ***
@
text
@d443 1
a443 1
			MethodInfo method = this.originalMethod != null && !(this.originalMethod is MethodBuilder) ? (MethodInfo)this.originalMethod : DeclaringType.TypeAsTBD.GetMethod(md.Name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypes, null);
d463 1
a463 1
				ConstructorInfo constructor = this.originalMethod != null && !(this.originalMethod is ConstructorBuilder) ? (ConstructorInfo)this.originalMethod : DeclaringType.TypeAsTBD.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, CallingConventions.Standard, md.ArgTypes, null);
d506 1
a506 1
					method = DeclaringType.TypeAsTBD.GetMethod(md.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypes, null);
d609 1
a609 1
	// field is a constant (and if it is its value)
d614 1
a614 2
		TypeWrapper java_lang_String = ClassLoaderWrapper.LoadClassCritical("java.lang.String");
		if(field != null && (fieldType.IsPrimitive || fieldType == java_lang_String) && field.IsLiteral)
d658 2
a659 3
		private static MethodInfo getFieldFromHandle = typeof(FieldInfo).GetMethod("GetFieldFromHandle");
		private static MethodInfo monitorEnter = typeof(System.Threading.Monitor).GetMethod("Enter");
		private static MethodInfo monitorExit = typeof(System.Threading.Monitor).GetMethod("Exit");
d669 2
a670 1
			if(!fi.IsStatic)
d672 1
a672 13
				ilgen.Emit(OpCodes.Dup);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brtrue, label);
				ilgen.ThrowException(typeof(NullReferenceException));
				ilgen.MarkLabel(label);
			}
			// HACK we lock on the FieldInfo object
			ilgen.Emit(OpCodes.Ldtoken, fi);
			ilgen.Emit(OpCodes.Call, getFieldFromHandle);
			ilgen.Emit(OpCodes.Call, monitorEnter);
			if(fi.IsStatic)
			{
				ilgen.Emit(OpCodes.Ldsfld, fi);
d676 2
a677 1
				ilgen.Emit(OpCodes.Ldfld, fi);
a678 3
			ilgen.Emit(OpCodes.Ldtoken, fi);
			ilgen.Emit(OpCodes.Call, getFieldFromHandle);
			ilgen.Emit(OpCodes.Call, monitorExit);
d684 2
a685 3
		private static MethodInfo getFieldFromHandle = typeof(FieldInfo).GetMethod("GetFieldFromHandle");
		private static MethodInfo monitorEnter = typeof(System.Threading.Monitor).GetMethod("Enter");
		private static MethodInfo monitorExit = typeof(System.Threading.Monitor).GetMethod("Exit");
d695 5
a699 16
			if(!fi.IsStatic)
			{
				LocalBuilder local = ilgen.DeclareLocal(fi.FieldType);
				ilgen.Emit(OpCodes.Stloc, local);
				ilgen.Emit(OpCodes.Dup);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brtrue, label);
				ilgen.ThrowException(typeof(NullReferenceException));
				ilgen.MarkLabel(label);
				ilgen.Emit(OpCodes.Ldloc, local);
			}
			// HACK we lock on the FieldInfo object
			ilgen.Emit(OpCodes.Ldtoken, fi);
			ilgen.Emit(OpCodes.Call, getFieldFromHandle);
			ilgen.Emit(OpCodes.Call, monitorEnter);
			if(fi.IsStatic)
d701 1
a701 1
				ilgen.Emit(OpCodes.Stsfld, fi);
d705 2
a706 1
				ilgen.Emit(OpCodes.Stfld, fi);
a707 3
			ilgen.Emit(OpCodes.Ldtoken, fi);
			ilgen.Emit(OpCodes.Call, getFieldFromHandle);
			ilgen.Emit(OpCodes.Call, monitorExit);
@


1.16
log
@*** empty log message ***
@
text
@a142 2
	private bool isRemappedVirtual;
	private bool isRemappedOverride;
a371 31
	// IsRemappedOverride (only possible for remapped types) indicates whether the method in the
	// remapped type overrides (i.e. replaces) the method from the underlying type
	// Example: System.Object.ToString() is overriden by java.lang.Object.toString(),
	//          because java.lang.Object's toString() does something different from
	//          System.Object's ToString().
	internal bool IsRemappedOverride
	{
		get
		{
			return isRemappedOverride;
		}
		set
		{
			isRemappedOverride = value;
		}
	}

	// IsRemappedVirtual (only possible for remapped types) indicates that the method is virtual,
	// but doesn't really exist in the underlying type (there is no vtable slot to reuse)
	internal bool IsRemappedVirtual
	{
		get
		{
			return isRemappedVirtual;
		}
		set
		{
			isRemappedVirtual = value;
		}
	}

a499 12
					// if we calling a remapped virtual method, we need to locate the proper helper method
					if(IsRemappedVirtual)
					{
						Type[] argTypes = new Type[md.ArgTypes.Length + 1];
						argTypes[0] = this.DeclaringType.TypeAsTBD;
						md.ArgTypes.CopyTo(argTypes, 1);
						method = ((RemappedTypeWrapper)this.DeclaringType).VirtualsHelperHack.GetMethod(md.Name, BindingFlags.Static | BindingFlags.Public, null, argTypes, null);
					}
				}
				else if(IsRemappedVirtual)
				{
					throw new NotImplementedException("non-static remapped virtual invocation not implement");
d551 2
a552 1
		// NOTE .NET (1.0 & 1.1) BUG FieldInfo.GetValue() on a literal causes the type initializer to run and
d557 1
a557 2
			// HACK lame way to support a command line switch to suppress this warning
			if(Environment.CommandLine.IndexOf("-noTypeInitWarning") == -1)
d566 1
a566 1
					Console.Error.WriteLine("Warning: Running type initializer for {0} due to CLR bug", field.DeclaringType.FullName);
@


1.15
log
@*** empty log message ***
@
text
@a941 6
		if(field.IsLiteral)
		{
			// NOTE this is illegal, but it will still run type initialization
			// on a non-broken CLR GetValue on a literal will not trigger type initialization, but on Java it should
			System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(field.DeclaringType.TypeHandle);
		}
d954 1
a954 1
			throw JavaException.IllegalAccessError(x.Message);
@


1.14
log
@*** empty log message ***
@
text
@d171 2
a172 4
		if(method == null)
		{
			throw new InvalidOperationException();
		}
d202 1
a202 1
				wrapper.EmitNewobj += CodeEmitter.Create(OpCodes.Box, declaringType.Type);
d476 1
a476 1
			MethodInfo method = this.originalMethod != null && !(this.originalMethod is MethodBuilder) ? (MethodInfo)this.originalMethod : DeclaringType.Type.GetMethod(md.Name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypes, null);
d496 2
a497 1
				if(obj == null)
d499 1
a499 2
					ConstructorInfo constructor = this.originalMethod != null && !(this.originalMethod is ConstructorBuilder) ? (ConstructorInfo)this.originalMethod : DeclaringType.Type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, CallingConventions.Standard, md.ArgTypes, null);
					try
d501 1
a501 1
						return constructor.Invoke(args);
d503 1
a503 1
					catch(ArgumentException x1)
d505 1
a505 5
						throw JavaException.IllegalArgumentException(x1.Message);
					}
					catch(TargetInvocationException x)
					{
						throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
d508 5
a512 1
				else
d514 1
a514 1
					throw new NotImplementedException("invoking constructor on existing instance");
d537 1
a537 1
						argTypes[0] = this.DeclaringType.Type;
d551 1
a551 1
					method = DeclaringType.Type.GetMethod(md.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypes, null);
d852 2
a853 2
			emitSet = new ValueTypeFieldSetter(declaringType.Type, fieldType.Type);
			emitGet = CodeEmitter.Create(OpCodes.Unbox, declaringType.Type);
d931 1
a931 1
		field = DeclaringType.Type.GetField(name, bindings);
@


1.13
log
@*** empty log message ***
@
text
@d355 1
a355 1
	internal TypeWrapper[] GetExceptions()
d360 1
a360 7
			TypeWrapper[] wrappers = new TypeWrapper[declaredExceptions.Length];
			for(int i = 0; i < declaredExceptions.Length; i++)
			{
				// TODO if the type isn't found, put in an unloadable
				wrappers[i] = DeclaringType.GetClassLoader().LoadClassByDottedName(declaredExceptions[i]);
			}
			return wrappers;
d365 2
a366 2
			object[] exceptions = originalMethod.GetCustomAttributes(typeof(ThrowsAttribute), false);
			TypeWrapper[] wrappers = new TypeWrapper[exceptions.Length];
d369 1
a369 2
				// TODO if the type isn't found, put in an unloadable
				wrappers[i] = DeclaringType.GetClassLoader().LoadClassByDottedName(((ThrowsAttribute)exceptions[i]).ClassName);
d371 1
a371 1
			return wrappers;
d373 1
a373 1
		return TypeWrapper.EmptyArray;
d581 1
d596 23
a637 1
	private static System.Collections.Hashtable warnOnce;
d661 1
a661 1
		TypeWrapper java_lang_String = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.String");
d664 1
a664 18
			// NOTE .NET (1.0 & 1.1) BUG this causes the type initializer to run and we don't want that.
			// TODO may need to find a workaround, for now we just spit out a warning (only shows up during netexp)
			if(field.DeclaringType.TypeInitializer != null && ReflectionOnConstant.IsBroken)
			{
				// HACK lame way to support a command line switch to suppress this warning
				if(Environment.CommandLine.IndexOf("-noTypeInitWarning") == -1)
				{
					if(warnOnce == null)
					{
						warnOnce = new System.Collections.Hashtable();
					}
					if(!warnOnce.ContainsKey(field.DeclaringType.FullName))
					{
						warnOnce.Add(field.DeclaringType.FullName, null);
						Console.WriteLine("Warning: Running type initializer for {0} due to .NET bug", field.DeclaringType.FullName);
					}
				}
			}
d859 13
a871 3
			// TODO emit code to dynamically get/set the field
			emitGet += CodeEmitter.NoClassDefFoundError(fieldType.Name);
			emitSet += CodeEmitter.NoClassDefFoundError(fieldType.Name);
d944 6
d956 8
a963 1
		field.SetValue(obj, val);
d972 5
@


1.12
log
@*** empty log message ***
@
text
@d150 18
d185 1
a185 1
		if(!retType.IsUnloadable && retType.IsNonPrimitiveValueType)
d187 10
a196 2
			wrapper.EmitCall += CodeEmitter.CreateEmitBoxCall(retType);
			wrapper.EmitCallvirt += CodeEmitter.CreateEmitBoxCall(retType);
d583 30
d648 1
a648 1
			// NOTE .NET BUG this causes the type initializer to run and we don't want that.
d650 1
a650 1
			if(field.DeclaringType.TypeInitializer != null)
@


1.11
log
@*** empty log message ***
@
text
@d145 1
d169 2
a170 2
			wrapper.EmitCall += CodeEmitter.Create(OpCodes.Box, retType.Type);
			wrapper.EmitCallvirt += CodeEmitter.Create(OpCodes.Box, retType.Type);
d176 2
d255 21
d329 28
d396 8
d557 1
a557 1
sealed class FieldWrapper : MemberWrapper
d780 12
d798 1
d825 1
a825 2
			emitSet += CodeEmitter.Create(OpCodes.Unbox, fieldType.Type);
			emitSet += CodeEmitter.Create(OpCodes.Ldobj, fieldType.Type);
d852 1
a852 1
			emitGet += CodeEmitter.Create(OpCodes.Box, fieldType.Type);
d869 1
d888 1
a888 1
	internal object GetValue(object obj)
d901 18
@


1.10
log
@*** empty log message ***
@
text
@d189 2
a190 2
		private TypeWrapper[] implementers;
		private CodeEmitter[] methods;
d192 1
a192 1
		internal GhostCallEmitter(TypeWrapper type, MethodDescriptor md, MethodBase method)
d194 1
a195 6
			TypeWrapper[] imps = ClassLoaderWrapper.GetGhostImplementers(type);
			implementers = new TypeWrapper[imps.Length + 1];
			imps.CopyTo(implementers, 1);
			methods = new CodeEmitter[implementers.Length + 1];
			implementers[0] = type;
			methods[0] = CodeEmitter.Create(OpCodes.Callvirt, method);
d200 1
a200 3
			TypeWrapper[] args = md.ArgTypeWrappers;
			LocalBuilder[] argLocals = new LocalBuilder[args.Length];
			for(int i = args.Length - 1; i >= 0; i--)
d202 1
a202 2
				argLocals[i] = ilgen.DeclareLocal(args[i].TypeAsLocalOrStackType);
				ilgen.Emit(OpCodes.Stloc, argLocals[i]);
d204 1
a204 25
			Label end = ilgen.DefineLabel();
			for(int i = 0; i < implementers.Length; i++)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Isinst, implementers[i].Type);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brfalse_S, label);
				ilgen.Emit(OpCodes.Castclass, implementers[i].Type);
				for(int j = 0; j < argLocals.Length; j++)
				{
					ilgen.Emit(OpCodes.Ldloc, argLocals[j]);
				}
				if(methods[i] == null)
				{
					// NOTE this needs to be done lazily, because otherwise any the first implementer
					// of a ghost interface will trigger GetMethodWrapper calls to itself, before it is
					// constructed.
					methods[i] = implementers[i].GetMethodWrapper(md, true).EmitCallvirt;
				}
				methods[i].Emit(ilgen);
				ilgen.Emit(OpCodes.Br, end);
				ilgen.MarkLabel(label);
			}
			EmitHelper.Throw(ilgen, "java.lang.IncompatibleClassChangeError", "ghost interface not implemented");
			ilgen.MarkLabel(end);
d394 1
d692 23
d731 1
d736 14
d806 6
d822 6
a827 1
		return field.GetValue(obj);
@


1.9
log
@*** empty log message ***
@
text
@d209 1
a209 1
				argLocals[i] = ilgen.DeclareLocal(args[i].TypeOrUnloadableAsObject);
@


1.8
log
@*** empty log message ***
@
text
@d195 3
a197 1
			implementers = ClassLoaderWrapper.GetGhostImplementers(type);
@


1.7
log
@*** empty log message ***
@
text
@d138 1
a138 1
sealed class MethodWrapper : MemberWrapper
d422 1
a422 1
	internal object Invoke(object obj, object[] args, bool nonVirtual)
@


1.6
log
@*** empty log message ***
@
text
@d534 1
d536 1
a536 1
	private FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, CodeEmitter emitGet, CodeEmitter emitSet)
d547 1
d552 37
d721 1
a721 1
	internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, CodeEmitter getter, CodeEmitter setter)
d723 1
a723 1
		return new FieldWrapper(declaringType, fieldType, name, sig, modifiers, getter, setter);
d739 1
a739 1
			return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, emitGet, emitSet);
d754 1
a754 1
				return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, emitGet, emitSet);
d773 1
a773 1
		return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, emitGet, emitSet);
d793 1
a793 1
		if(field == null)
d803 1
a803 1
		if(field == null)
@


1.5
log
@*** empty log message ***
@
text
@d203 1
a203 1
			Type[] args = md.ArgTypes;
d207 1
a207 1
				argLocals[i] = ilgen.DeclareLocal(args[i]);
d218 1
a218 1
				for(int j = 0; j < args.Length; j++)
a559 8
		}
	}

	internal Type FieldType
	{
		get
		{
			return FieldTypeWrapper.Type;
@


1.4
log
@*** empty log message ***
@
text
@d188 2
a189 2
		private Type[] args;
		private Type[] implementerTypes;
d194 2
a195 3
			args = md.ArgTypes;
			TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(type);
			implementerTypes = new Type[implementers.Length + 1];
d197 1
a197 1
			implementerTypes[0] = type.Type;
a198 5
			for(int i = 0; i < implementers.Length; i++)
			{
				implementerTypes[i + 1] = implementers[i].Type;
				methods[i + 1] = implementers[i].GetMethodWrapper(md, true).EmitCallvirt;
			}
d203 1
d211 1
a211 1
			for(int i = 0; i < implementerTypes.Length; i++)
d214 1
a214 1
				ilgen.Emit(OpCodes.Isinst, implementerTypes[i]);
d217 1
a217 1
				ilgen.Emit(OpCodes.Castclass, implementerTypes[i]);
d221 7
@


1.3
log
@*** empty log message ***
@
text
@d157 8
a164 1
		CreateEmitters(originalMethod, method, ref wrapper.EmitCall, ref wrapper.EmitCallvirt, ref wrapper.EmitNewobj);
d184 50
@


1.2
log
@*** empty log message ***
@
text
@d39 1
d471 2
a472 2
	internal CodeEmitter EmitGet;
	internal CodeEmitter EmitSet;
d476 1
a476 1
	internal FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers)
d479 5
a485 4
		if(fieldType == null)
		{
			fieldType = DeclaringType.GetClassLoader().RetTypeWrapperFromSig("()" + sig);
		}
d487 2
d631 1
a631 6
	internal static FieldWrapper Create(TypeWrapper declaringType, FieldInfo fi, ClassFile.Field fld)
	{
		return Create(declaringType, fld.GetFieldType(declaringType.GetClassLoader()), fi, fld.Signature, fld.Modifiers);
	}

	internal static FieldWrapper Create(TypeWrapper declaringType, FieldInfo fi, string sig, Modifiers modifiers)
d633 1
a633 1
		return Create(declaringType, null, fi, sig, modifiers);
d638 2
a639 1
		FieldWrapper field = new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers);
d642 2
a643 2
			field.EmitSet = new ValueTypeFieldSetter(declaringType.Type, field.FieldType);
			field.EmitGet = CodeEmitter.Create(OpCodes.Unbox, declaringType.Type);
d645 1
a645 1
		if(field.FieldTypeWrapper.IsUnloadable)
d647 3
a649 3
			field.EmitGet += CodeEmitter.NoClassDefFoundError(field.FieldTypeWrapper.Name);
			field.EmitSet += CodeEmitter.NoClassDefFoundError(field.FieldTypeWrapper.Name);
			return field;
d651 1
a651 1
		if(field.FieldTypeWrapper.IsNonPrimitiveValueType)
d653 2
a654 2
			field.EmitSet += CodeEmitter.Create(OpCodes.Unbox, field.FieldTypeWrapper.Type);
			field.EmitSet += CodeEmitter.Create(OpCodes.Ldobj, field.FieldTypeWrapper.Type);
d656 1
a656 1
		if(field.IsVolatile)
d661 4
a664 3
				field.EmitGet = new VolatileLongDoubleGetter(fi);
				field.EmitSet = new VolatileLongDoubleSetter(fi);
				return field;
d666 2
a667 2
			field.EmitGet += CodeEmitter.Volatile;
			field.EmitSet += CodeEmitter.Volatile;
d669 1
a669 1
		if(field.IsStatic)
d671 2
a672 2
			field.EmitGet += CodeEmitter.Create(OpCodes.Ldsfld, fi);
			field.EmitSet += CodeEmitter.Create(OpCodes.Stsfld, fi);
d676 2
a677 2
			field.EmitGet += CodeEmitter.Create(OpCodes.Ldfld, fi);
			field.EmitSet += CodeEmitter.Create(OpCodes.Stfld, fi);
d679 1
a679 1
		if(field.FieldTypeWrapper.IsNonPrimitiveValueType)
d681 1
a681 1
			field.EmitGet += CodeEmitter.Create(OpCodes.Box, field.FieldTypeWrapper.Type);
d683 1
a683 1
		return field;
@


1.1
log
@*** empty log message ***
@
text
@d158 1
a158 1
		if(retType.IsNonPrimitiveValueType)
d243 19
d473 1
d475 1
a475 1
	internal FieldWrapper(TypeWrapper declaringType, string name, string sig, Modifiers modifiers)
d480 5
d512 1
a512 2
			// HACK
			return DeclaringType.GetClassLoader().RetTypeWrapperFromSig("()" + sig);
d627 5
d634 6
a639 1
		FieldWrapper field = new FieldWrapper(declaringType, fi.Name, sig, modifiers);
d644 6
@

