head	1.26;
access;
symbols
	initial:1.1.1.1 ikvm:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2004.05.27.07.12.16;	author jfrijters;	state dead;
branches;
next	1.25;

1.25
date	2004.05.14.09.31.56;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.26.10.19.22;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.20.13.25.08;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.16.17.10.10;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.08.15.18.47;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.30.15.27.53;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.11.13.14.43;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.24.11.51.41;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.19.22.19.18;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.17.12.01.52;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.29.10.14.08;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.12.13.09.31;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.20.13.47.13;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.30.12.09.00;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.18.10.27.33;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.14.09.41.58;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.22.15.17.07;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.21.13.41.43;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.18.09.31.20;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.17.14.36.07;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.06.14.01.54;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.31.12.23.10;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.28.11.10.34;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.27.09.09.02;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.18.16.01.23;	author jfrijters;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.12.18.16.01.23;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.26
log
@*** empty log message ***
@
text
@/*
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.IO;
using System.Collections;
using System.Diagnostics;

class VerifyError : ApplicationException
{
	internal int ByteCodeOffset;
	internal string Class;
	internal string Method;
	internal string Signature;
	internal string Instruction;

	internal VerifyError()
	{
	}

	internal VerifyError(string msg) : base(msg)
	{
	}
}

class Subroutine
{
	private int subroutineIndex;
	private bool[] localsModified;

	private Subroutine(int subroutineIndex, bool[] localsModified)
	{
		this.subroutineIndex = subroutineIndex;
		this.localsModified = localsModified;
	}

	internal Subroutine(int subroutineIndex, int maxLocals)
	{
		this.subroutineIndex = subroutineIndex;
		localsModified = new bool[maxLocals];
	}

	internal int SubroutineIndex
	{
		get
		{
			return subroutineIndex;
		}
	}

	internal bool[] LocalsModified
	{
		get
		{
			return localsModified;
		}
	}

	internal void SetLocalModified(int local)
	{
		localsModified[local] = true;
	}

	internal Subroutine Copy()
	{
		return new Subroutine(subroutineIndex, (bool[])localsModified.Clone());
	}
}

class InstructionState
{
	private TypeWrapper[] stack;
	private int stackSize;
	private TypeWrapper[] locals;
	private Hashtable[] localStoreSites;
	private ArrayList subroutines;
	private int callsites;
	internal bool changed = true;

	private InstructionState(TypeWrapper[] stack, int stackSize, TypeWrapper[] locals, Hashtable[] localStoreSites, ArrayList subroutines, int callsites)
	{
		this.stack = stack;
		this.stackSize = stackSize;
		this.locals = locals;
		this.localStoreSites = localStoreSites;
		this.subroutines = subroutines;
		this.callsites = callsites;
	}

	internal InstructionState(int maxLocals, int maxStack)
	{
		this.stack = new TypeWrapper[maxStack];
		this.locals = new TypeWrapper[maxLocals];
		this.localStoreSites = new Hashtable[maxLocals];
	}

	internal InstructionState Copy()
	{
		return new InstructionState((TypeWrapper[])stack.Clone(), stackSize, (TypeWrapper[])locals.Clone(), (Hashtable[])localStoreSites.Clone(), CopySubroutines(subroutines), callsites);
	}

	internal void CopyTo(InstructionState target)
	{
		stack.CopyTo(target.stack, 0);
		target.stackSize = stackSize;
		locals.CopyTo(target.locals, 0);
		localStoreSites.CopyTo(target.localStoreSites, 0);
		target.subroutines = CopySubroutines(subroutines);
		target.callsites = callsites;
		target.changed = true;
	}

	internal InstructionState CopyLocalsAndSubroutines()
	{
		return new InstructionState(new TypeWrapper[stack.Length], 0, (TypeWrapper[])locals.Clone(), (Hashtable[])localStoreSites.Clone(), CopySubroutines(subroutines), callsites);
	}

	private ArrayList CopySubroutines(ArrayList l)
	{
		if(l == null)
		{
			return null;
		}
		ArrayList n = new ArrayList(l.Count);
		foreach(Subroutine s in l)
		{
			n.Add(s.Copy());
		}
		return n;
	}

	public static InstructionState operator+(InstructionState s1, InstructionState s2)
	{
		return Merge(s1, s2, null, null);
	}

	private void MergeSubroutineHelper(InstructionState s2)
	{
		if(subroutines == null || s2.subroutines == null)
		{
			if(subroutines != null)
			{
				subroutines = null;
				changed = true;
			}
		}
		else
		{
			ArrayList ss1 = subroutines;
			subroutines = new ArrayList();
			foreach(Subroutine ss2 in s2.subroutines)
			{
				foreach(Subroutine ss in ss1)
				{
					if(ss.SubroutineIndex == ss2.SubroutineIndex)
					{
						subroutines.Add(ss);
						for(int i = 0; i < ss.LocalsModified.Length; i++)
						{
							if(ss2.LocalsModified[i] && !ss.LocalsModified[i])
							{
								ss.LocalsModified[i] = true;
								changed = true;
							}
						}
					}
				}
			}
			if(ss1.Count != subroutines.Count)
			{
				changed = true;
			}
		}

		if(s2.callsites > callsites)
		{
			//Console.WriteLine("s2.callsites = {0}, callsites = {1}", s2.callsites, callsites);
			callsites = s2.callsites;
			changed = true;
		}
	}

	internal static InstructionState Merge(InstructionState s1, InstructionState s2, bool[] locals_modified, InstructionState s3)
	{
		if(s1 == null)
		{
			s2 = s2.Copy();
			if(locals_modified != null)
			{
				for(int i = 0; i < s2.locals.Length; i++)
				{
					if(!locals_modified[i])
					{
						s2.locals[i] = s3.locals[i];
						s2.localStoreSites[i] = s3.localStoreSites[i] != null ? (Hashtable)s3.localStoreSites[i].Clone() : null;
					}
				}
			}
			if(s3 != null)
			{
				s2.MergeSubroutineHelper(s3);
			}
			return s2;
		}
		if(s1.stackSize != s2.stackSize)
		{
			throw new VerifyError(string.Format("Inconsistent stack height: {0} != {1}", s1.stackSize, s2.stackSize));
		}
		InstructionState s = s1.Copy();
		s.changed = s1.changed;
		for(int i = 0; i < s.stackSize; i++)
		{
			TypeWrapper type = s.stack[i];
			if(type == s2.stack[i])
			{
				// perfect match, nothing to do
			}
			else if(!type.IsPrimitive)
			{
				TypeWrapper baseType = InstructionState.FindCommonBaseType(type, s2.stack[i]);
				if(baseType == VerifierTypeWrapper.Invalid)
				{
					// if we never return from a subroutine, it is legal to merge to subroutine flows
					// (this is from the Mauve test subr.pass.mergeok)
					if(VerifierTypeWrapper.IsRet(type) && VerifierTypeWrapper.IsRet(s2.stack[i]))
					{
						baseType = VerifierTypeWrapper.Invalid;
					}
					else
					{
						System.Diagnostics.Debug.Fail("invalid merge");
					}
				}
				if(type != baseType)
				{
					s.stack[i] = baseType;
					s.changed = true;
				}
			}
			else
			{
				throw new VerifyError(string.Format("cannot merge {0} and {1}", type.Name, s2.stack[i].Name));
			}
		}
		for(int i = 0; i < s.locals.Length; i++)
		{
			TypeWrapper type = s.locals[i];
			TypeWrapper type2;
			Hashtable storeSites = s.localStoreSites[i];
			Hashtable storeSites2;
			if(locals_modified == null || locals_modified[i])
			{
				type2 = s2.locals[i];
				storeSites2 = s2.localStoreSites[i];
			}
			else
			{
				type2 = s3.locals[i];
				storeSites2 = s3.localStoreSites[i];
			}
			TypeWrapper baseType = InstructionState.FindCommonBaseType(type, type2);
			if(type != baseType)
			{
				s.locals[i] = baseType;
				s.changed = true;
			}
			storeSites = MergeStoreSites(storeSites, storeSites2);
			if(storeSites != null && (s.localStoreSites[i] == null || storeSites.Count != s.localStoreSites[i].Count))
			{
				s.localStoreSites[i] = storeSites;
				s.changed = true;
			}
		}
		s.MergeSubroutineHelper(s2);
		if(s3 != null)
		{
			s.MergeSubroutineHelper(s3);
		}
		return s;
	}

	private static Hashtable MergeStoreSites(Hashtable h1, Hashtable h2)
	{
		if(h1 == null && h2 == null)
		{
			return null;
		}
		if(h1 == null)
		{
			return (Hashtable)h2.Clone();
		}
		if(h2 == null)
		{
			return (Hashtable)h1.Clone();
		}
		Hashtable h = new Hashtable();
		foreach(DictionaryEntry de in h1)
		{
			h.Add(de.Key, de.Value);
		}
		foreach(DictionaryEntry de in h2)
		{
			h[de.Key] = de.Value;
		}
		return h;
	}

	internal void AddCallSite()
	{
		callsites++;
		changed = true;
	}

	internal void SetSubroutineId(int subroutineIndex)
	{
		if(subroutines == null)
		{
			subroutines = new ArrayList();
		}
		else
		{
			foreach(Subroutine s in subroutines)
			{
				if(s.SubroutineIndex == subroutineIndex)
				{
					// subroutines cannot recursivly call themselves
					throw new VerifyError("subroutines cannot recurse");
				}
			}
		}
		subroutines.Add(new Subroutine(subroutineIndex, locals.Length));
	}

	internal bool[] ClearSubroutineId(int subroutineIndex)
	{
		if(subroutines != null)
		{
			foreach(Subroutine s in subroutines)
			{
				if(s.SubroutineIndex == subroutineIndex)
				{
					// TODO i'm not 100% sure about this, but I think we need to clear
					// the subroutines here (because when you return you can never "become" inside a subroutine)
					// UPDATE the above is incorrect, we only need to remove the subroutine we're actually
					// returning from
					subroutines.Remove(s);
					return s.LocalsModified;
				}
			}
		}
		throw new VerifyError("return from wrong subroutine");
	}

	internal void CheckSubroutineActive(int subroutineIndex)
	{
		if(subroutines != null)
		{
			foreach(Subroutine s in subroutines)
			{
				if(s.SubroutineIndex == subroutineIndex)
				{
					return;
				}
			}
		}
		throw new VerifyError("inactive subroutine");
	}

	internal static TypeWrapper FindCommonBaseType(TypeWrapper type1, TypeWrapper type2)
	{
		if(type1 == type2)
		{
			return type1;
		}
		if(type1 == VerifierTypeWrapper.Null)
		{
			return type2;
		}
		if(type2 == VerifierTypeWrapper.Null)
		{
			return type1;
		}
		if(type1 == VerifierTypeWrapper.Invalid || type2 == VerifierTypeWrapper.Invalid)
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(type1.IsPrimitive || type2.IsPrimitive)
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(type1 == VerifierTypeWrapper.UninitializedThis || type2 == VerifierTypeWrapper.UninitializedThis)
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(VerifierTypeWrapper.IsNew(type1) || VerifierTypeWrapper.IsNew(type2))
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(VerifierTypeWrapper.IsRet(type1) || VerifierTypeWrapper.IsRet(type2))
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(type1.IsUnloadable || type2.IsUnloadable)
		{
			return VerifierTypeWrapper.Unloadable;
		}
		if(type1.ArrayRank > 0 && type2.ArrayRank > 0)
		{
			int rank = 1;
			int rank1 = type1.ArrayRank - 1;
			int rank2 = type2.ArrayRank - 1;
			TypeWrapper elem1 = type1.ElementTypeWrapper;
			TypeWrapper elem2 = type2.ElementTypeWrapper;
			while(rank1 != 0 && rank2 != 0)
			{
				elem1 = elem1.ElementTypeWrapper;
				elem2 = elem2.ElementTypeWrapper;
				rank++;
				rank1--;
				rank2--;
			}
			TypeWrapper baseType = FindCommonBaseTypeHelper(elem1, elem2);
			if(baseType == VerifierTypeWrapper.Invalid)
			{
				baseType = CoreClasses.java.lang.Object.Wrapper;
				rank--;
				if(rank == 0)
				{
					return baseType;
				}
			}
			return baseType.MakeArrayType(rank);
		}
		return FindCommonBaseTypeHelper(type1, type2);
	}

	private static TypeWrapper FindCommonBaseTypeHelper(TypeWrapper t1, TypeWrapper t2)
	{
		if(t1 == t2)
		{
			return t1;
		}
		if(t1.IsNonPrimitiveValueType || t2.IsNonPrimitiveValueType)
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(t1.IsInterface || t2.IsInterface)
		{
			// TODO I don't know how finding the common base for interfaces is defined, but
			// for now I'm just doing the naive thing
			// UPDATE according to a paper by Alessandro Coglio & Allen Goldberg titled
			// "Type Safety in the JVM: Some Problems in Java 2 SDK 1.2 and Proposed Solutions"
			// the common base of two interfaces is java.lang.Object, and there is special
			// treatment for java.lang.Object types that allow it to be assigned to any interface
			// type, the JVM's typesafety then depends on the invokeinterface instruction to make
			// sure that the reference actually implements the interface.
			// So strictly speaking, the code below isn't correct, but it works and it produces
			// more efficient code, so for now it stays in.
			if(t1.ImplementsInterface(t2))
			{
				return t2;
			}
			if(t2.ImplementsInterface(t1))
			{
				return t1;
			}
			foreach (TypeWrapper baseInterface in t1.Interfaces)
			{
				TypeWrapper commonBase = FindCommonBaseTypeHelper(baseInterface, t2);
				if (commonBase != CoreClasses.java.lang.Object.Wrapper)
				{
					return commonBase;
				}
			}
			return CoreClasses.java.lang.Object.Wrapper;
		}
		Stack st1 = new Stack();
		Stack st2 = new Stack();
		while(t1 != null)
		{
			st1.Push(t1);
			t1 = t1.BaseTypeWrapper;
		}
		while(t2 != null)
		{
			st2.Push(t2);
			t2 = t2.BaseTypeWrapper;
		}
		TypeWrapper type = null;
		for(;;)
		{
			t1 = st1.Count > 0 ? (TypeWrapper)st1.Pop() : null;
			t2 = st2.Count > 0 ? (TypeWrapper)st2.Pop() : null;
			if(t1 != t2)
			{
				return type;
			}
			type = t1;
		}
	}

	private void SetLocal1(int index, TypeWrapper type)
	{
		try
		{
			if(index > 0 && locals[index - 1] != VerifierTypeWrapper.Invalid && locals[index - 1].IsWidePrimitive)
			{
				locals[index - 1] = VerifierTypeWrapper.Invalid;
				if(subroutines != null)
				{
					foreach(Subroutine s in subroutines)
					{
						s.SetLocalModified(index - 1);
					}
				}
			}
			locals[index] = type;
			if(subroutines != null)
			{
				foreach(Subroutine s in subroutines)
				{
					s.SetLocalModified(index);
				}
			}
		}
		catch(IndexOutOfRangeException)
		{
			throw new VerifyError("Illegal local variable number");
		}
	}

	private void SetLocal2(int index, TypeWrapper type)
	{
		try
		{
			if(index > 0 && locals[index - 1] != VerifierTypeWrapper.Invalid && locals[index - 1].IsWidePrimitive)
			{
				locals[index - 1] = VerifierTypeWrapper.Invalid;
				if(subroutines != null)
				{
					foreach(Subroutine s in subroutines)
					{
						s.SetLocalModified(index - 1);
					}
				}
			}
			locals[index] = type;
			locals[index + 1] = VerifierTypeWrapper.Invalid;
			if(subroutines != null)
			{
				foreach(Subroutine s in subroutines)
				{
					s.SetLocalModified(index);
					s.SetLocalModified(index + 1);
				}
			}
		}
		catch(IndexOutOfRangeException)
		{
			throw new VerifyError("Illegal local variable number");
		}
	}

	private void SetLocalStoreSite(int localIndex, int instructionIndex)
	{
		localStoreSites[localIndex] = new Hashtable();
		localStoreSites[localIndex].Add(instructionIndex, "");
	}

	internal void GetLocalInt(int index, ref Hashtable readers)
	{
		if(GetLocalType(index, ref readers) != PrimitiveTypeWrapper.INT)
		{
			throw new VerifyError("Invalid local type");
		}
	}

	internal void SetLocalInt(int index, int instructionIndex)
	{
		SetLocalStoreSite(index, instructionIndex);
		SetLocal1(index, PrimitiveTypeWrapper.INT);
	}

	internal void GetLocalLong(int index, ref Hashtable readers)
	{
		if(GetLocalType(index, ref readers) != PrimitiveTypeWrapper.LONG)
		{
			throw new VerifyError("incorrect local type, not long");
		}
	}

	internal void SetLocalLong(int index, int instructionIndex)
	{
		SetLocalStoreSite(index, instructionIndex);
		SetLocal2(index, PrimitiveTypeWrapper.LONG);
	}

	internal void GetLocalFloat(int index, ref Hashtable readers)
	{
		if(GetLocalType(index, ref readers) != PrimitiveTypeWrapper.FLOAT)
		{
			throw new VerifyError("incorrect local type, not float");
		}
	}

	internal void SetLocalFloat(int index, int instructionIndex)
	{
		SetLocalStoreSite(index, instructionIndex);
		SetLocal1(index, PrimitiveTypeWrapper.FLOAT);
	}

	internal void GetLocalDouble(int index, ref Hashtable readers)
	{
		if(GetLocalType(index, ref readers) != PrimitiveTypeWrapper.DOUBLE)
		{
			throw new VerifyError("incorrect local type, not double");
		}
	}

	internal void SetLocalDouble(int index, int instructionIndex)
	{
		SetLocalStoreSite(index, instructionIndex);
		SetLocal2(index, PrimitiveTypeWrapper.DOUBLE);
	}

	internal TypeWrapper GetLocalType(int index, ref Hashtable readers)
	{
		try
		{
			if(readers == null)
			{
				readers = new Hashtable();
			}
			foreach(int store in localStoreSites[index].Keys)
			{
				readers[store] = "";
			}
			return locals[index];
		}
		catch(IndexOutOfRangeException)
		{
			throw new VerifyError("Illegal local variable number");
		}
	}

	// this is used by the compiler (indirectly, through MethodAnalyzer.GetLocalTypeWrapper),
	// we've already verified the code so we know we won't run outside the array boundary,
	// and we don't need to record the fact that we're reading the local.
	internal TypeWrapper GetLocalTypeEx(int index)
	{
		return locals[index];
	}

	internal int GetLocalRet(int index, ref Hashtable readers)
	{
		TypeWrapper type = GetLocalType(index, ref readers);
		if(VerifierTypeWrapper.IsRet(type))
		{
			return ((VerifierTypeWrapper)type).Index;
		}
		throw new VerifyError("incorrect local type, not ret");
	}

	internal void SetLocalType(int index, TypeWrapper type, int instructionIndex)
	{
		SetLocalStoreSite(index, instructionIndex);
		if(type.IsWidePrimitive)
		{
			SetLocal2(index, type);
		}
		else
		{
			SetLocal1(index, type);
		}
	}

	internal void PushType(TypeWrapper type)
	{
		if(type.IsIntOnStackPrimitive)
		{
			type = PrimitiveTypeWrapper.INT;
		}
		PushHelper(type);
	}

	internal void PushInt()
	{
		PushHelper(PrimitiveTypeWrapper.INT);
	}

	internal void PushLong()
	{
		PushHelper(PrimitiveTypeWrapper.LONG);
	}

	internal void PushFloat()
	{
		PushHelper(PrimitiveTypeWrapper.FLOAT);
	}

	internal void PushDouble()
	{
		PushHelper(PrimitiveTypeWrapper.DOUBLE);
	}

	internal void PopInt()
	{
		if(PopAnyType() != PrimitiveTypeWrapper.INT)
		{
			throw new VerifyError("Int expected on stack");
		}
	}

	internal void PopFloat()
	{
		if(PopAnyType() != PrimitiveTypeWrapper.FLOAT)
		{
			throw new VerifyError("Float expected on stack");
		}
	}

	internal void PopDouble()
	{
		if(PopAnyType() != PrimitiveTypeWrapper.DOUBLE)
		{
			throw new VerifyError("Double expected on stack");
		}
	}

	internal void PopLong()
	{
		if(PopAnyType() != PrimitiveTypeWrapper.LONG)
		{
			throw new VerifyError("Long expected on stack");
		}
	}

	internal TypeWrapper PopArrayType()
	{
		TypeWrapper type = PopAnyType();
		if(!VerifierTypeWrapper.IsNullOrUnloadable(type) && type.ArrayRank == 0)
		{
			throw new VerifyError("Array reference expected on stack");
		}
		return type;
	}

	// null or an initialized object reference (or a subroutine return address)
	internal TypeWrapper PopObjectType()
	{
		TypeWrapper type = PopType();
		if(type.IsPrimitive || VerifierTypeWrapper.IsNew(type) || type == VerifierTypeWrapper.UninitializedThis)
		{
			throw new VerifyError("Expected object reference on stack");
		}
		return type;
	}

	// null or an initialized object reference derived from baseType (or baseType)
	internal TypeWrapper PopObjectType(TypeWrapper baseType)
	{
		TypeWrapper type = PopObjectType();
		// HACK because of the way interfaces references works, if baseType
		// is an interface or array of interfaces, any reference will be accepted
		if(!baseType.IsUnloadable && !baseType.IsInterfaceOrInterfaceArray && !(type.IsUnloadable || type.IsAssignableTo(baseType)))
		{
			throw new VerifyError("Unexpected type " + type + " where " + baseType + " was expected");
		}
		return type;
	}

	internal TypeWrapper PeekType()
	{
		if(stackSize == 0)
		{
			throw new VerifyError("Unable to pop operand off an empty stack");
		}
		return stack[stackSize - 1];
	}

	internal TypeWrapper PopAnyType()
	{
		if(stackSize == 0)
		{
			throw new VerifyError("Unable to pop operand off an empty stack");
		}
		return stack[--stackSize];
	}

	// NOTE this can *not* be used to pop double or long
	internal TypeWrapper PopType()
	{
		TypeWrapper type = PopAnyType();
		if(type.IsWidePrimitive)
		{
			throw new VerifyError("Attempt to split long or double on the stack");
		}
		return type;
	}

	// this will accept null, a primitive type of the specified type or an initialized reference of the
	// specified type or derived from it
	// NOTE this can also be used to pop double or long
	internal TypeWrapper PopType(TypeWrapper baseType)
	{
		if(baseType.IsIntOnStackPrimitive)
		{
			baseType = PrimitiveTypeWrapper.INT;
		}
		TypeWrapper type = PopAnyType();
		if(VerifierTypeWrapper.IsNew(type) || type == VerifierTypeWrapper.UninitializedThis)
		{
			throw new VerifyError("Expecting to find object/array on stack");
		}
		if(type != baseType &&
			!((type.IsUnloadable && !baseType.IsPrimitive) || (baseType.IsUnloadable && !type.IsPrimitive) ||
				type.IsAssignableTo(baseType)))
		{
			// HACK because of the way interfaces references works, if baseType
			// is an interface or array of interfaces, any reference will be accepted
			if(baseType.IsInterfaceOrInterfaceArray && !type.IsPrimitive)
			{
				return type;
			}
			throw new VerifyError("Unexpected type " + type.Name + " where " + baseType.Name + " was expected");
		}
		return type;
	}

	internal int GetStackHeight()
	{
		return stackSize;
	}

	internal TypeWrapper GetStackSlot(int pos)
	{
		return stack[stackSize - 1 - pos];
	}

	private void PushHelper(TypeWrapper type)
	{
		if(stackSize == stack.Length)
		{
			throw new VerifyError("Stack overflow");
		}
		stack[stackSize++] = type;
	}

	internal void MarkInitialized(TypeWrapper type, TypeWrapper initType, int instructionIndex)
	{
		System.Diagnostics.Debug.Assert(type != null && initType != null);

		for(int i = 0; i < locals.Length; i++)
		{
			if(locals[i] == type)
			{
				SetLocalStoreSite(i, instructionIndex);
				locals[i] = initType;
			}
		}
		for(int i = 0; i < stackSize; i++)
		{
			if(stack[i] == type)
			{
				stack[i] = initType;
			}
		}
	}

	internal void DumpLocals()
	{
		Console.Write("// ");
		string sep = "";
		for(int i = 0; i < locals.Length; i++)
		{
			Console.Write(sep);
			Console.Write(locals[i]);
			sep = ", ";
		}
		Console.WriteLine();
	}

	internal void DumpStack()
	{
		Console.Write("// ");
		string sep = "";
		for(int i = 0; i < stackSize; i++)
		{
			Console.Write(sep);
			Console.Write(stack[i]);
			sep = ", ";
		}
		Console.WriteLine();
	}

	internal void DumpSubroutines()
	{
		Console.Write("// subs: ");
		string sep = "";
		if(subroutines != null)
		{
			for(int i = 0; i < subroutines.Count; i++)
			{
				Console.Write(sep);
				Console.Write(((Subroutine)subroutines[i]).SubroutineIndex);
				sep = ", ";
			}
		}
		Console.WriteLine();
	}

	// this method ensures that no uninitialized object are in the current state
	internal void CheckUninitializedObjRefs()
	{
		for(int i = 0; i < locals.Length; i++)
		{
			TypeWrapper type = locals[i];
			if(type == VerifierTypeWrapper.UninitializedThis || VerifierTypeWrapper.IsNew(type))
			{
				throw new VerifyError("uninitialized object ref in local (2)");
			}
		}
		for(int i = 0; i < stackSize; i++)
		{
			TypeWrapper type = stack[i];
			if(type == VerifierTypeWrapper.UninitializedThis || VerifierTypeWrapper.IsNew(type))
			{
				throw new VerifyError("uninitialized object ref on stack");
			}
		}
	}
}

// this is a container for the special verifier TypeWrappers
class VerifierTypeWrapper : TypeWrapper
{
	internal static readonly TypeWrapper Invalid = null;
	internal static readonly TypeWrapper Null = new VerifierTypeWrapper("null", 0, null);
	internal static readonly TypeWrapper UninitializedThis = new VerifierTypeWrapper("this", 0, null);
	internal static readonly TypeWrapper Unloadable = new UnloadableTypeWrapper("verifier");

	private int index;
	private TypeWrapper underlyingType;

	public override string ToString()
	{
		return GetType().Name + "[" + Name + "," + index + "," + underlyingType + "]";
	}

	internal static TypeWrapper MakeNew(TypeWrapper type, int bytecodeIndex)
	{
		return new VerifierTypeWrapper("new", bytecodeIndex, type);
	}

	internal static TypeWrapper MakeRet(int bytecodeIndex)
	{
		return new VerifierTypeWrapper("ret", bytecodeIndex, null);
	}

	internal static bool IsNew(TypeWrapper w)
	{
		return w != null && w.IsVerifierType && w.Name == "new";
	}

	internal static bool IsRet(TypeWrapper w)
	{
		return w != null && w.IsVerifierType && w.Name == "ret";
	}

	internal static bool IsNullOrUnloadable(TypeWrapper w)
	{
		return w == Null || w.IsUnloadable;
	}

	internal int Index
	{
		get
		{
			return index;
		}
	}

	internal TypeWrapper UnderlyingType
	{
		get
		{
			return underlyingType;
		}
	}

	private VerifierTypeWrapper(string name, int index, TypeWrapper underlyingType)
		: base(TypeWrapper.VerifierTypeModifiersHack, name, null, null)
	{
		this.index = index;
		this.underlyingType = underlyingType;
	}

	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
	{
		throw new InvalidOperationException("GetFieldImpl called on " + this);
	}

	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		throw new InvalidOperationException("GetMethodImpl called on " + this);
	}

	internal override Type TypeAsTBD
	{
		get
		{
			throw new InvalidOperationException("get_Type called on " + this);
		}
	}

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			throw new InvalidOperationException("get_Interfaces called on " + this);
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			throw new InvalidOperationException("get_InnerClasses called on " + this);
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			throw new InvalidOperationException("get_DeclaringTypeWrapper called on " + this);
		}
	}

	internal override void Finish()
	{
		throw new InvalidOperationException("Finish called on " + this);
	}
}

class LocalVar
{
	internal bool isArg;
	internal int local;
	internal TypeWrapper type;
	internal System.Reflection.Emit.LocalBuilder builder;
	// used to emit debugging info, only available if JVM.Debug is true
	internal string name;
	internal int start_pc;
	internal int end_pc;

	internal void FindLvtEntry(ClassFile.Method.Code method, int instructionIndex)
	{
		ClassFile.Method.LocalVariableTableEntry[] lvt = method.LocalVariableTableAttribute;
		if(lvt != null)
		{
			int pc = method.Instructions[instructionIndex].PC;
			int nextPC = method.Instructions[instructionIndex + 1].PC;
			bool isStore = MethodAnalyzer.IsStoreLocal(method.Instructions[instructionIndex].NormalizedOpCode);
			foreach(ClassFile.Method.LocalVariableTableEntry e in lvt)
			{
				// TODO validate the contents of the LVT entry
				if(e.index == local &&
					(e.start_pc <= pc || (e.start_pc == nextPC && isStore)) && 
					e.start_pc + e.length > pc)
				{
					name = e.name;
					start_pc = e.start_pc;
					end_pc = e.start_pc + e.length;
					break;
				}
			}
		}
	}
}

class MethodAnalyzer
{
	private static TypeWrapper ByteArrayType;
	private static TypeWrapper BooleanArrayType;
	private static TypeWrapper ShortArrayType;
	private static TypeWrapper CharArrayType;
	private static TypeWrapper IntArrayType;
	private static TypeWrapper FloatArrayType;
	private static TypeWrapper DoubleArrayType;
	private static TypeWrapper LongArrayType;
	private ClassLoaderWrapper classLoader;
	private ClassFile.Method.Code method;
	private InstructionState[] state;
	private ArrayList[] callsites;
	private LocalVar[/*instructionIndex*/] localVars;
	private LocalVar[/*instructionIndex*/][/*localIndex*/] invokespecialLocalVars;
	private LocalVar[/*index*/] allLocalVars;

	static MethodAnalyzer()
	{
		ByteArrayType = PrimitiveTypeWrapper.BYTE.MakeArrayType(1);
		BooleanArrayType = PrimitiveTypeWrapper.BOOLEAN.MakeArrayType(1);
		ShortArrayType = PrimitiveTypeWrapper.SHORT.MakeArrayType(1);
		CharArrayType = PrimitiveTypeWrapper.CHAR.MakeArrayType(1);
		IntArrayType = PrimitiveTypeWrapper.INT.MakeArrayType(1);
		FloatArrayType = PrimitiveTypeWrapper.FLOAT.MakeArrayType(1);
		DoubleArrayType = PrimitiveTypeWrapper.DOUBLE.MakeArrayType(1);
		LongArrayType = PrimitiveTypeWrapper.LONG.MakeArrayType(1);
	}

	internal MethodAnalyzer(TypeWrapper wrapper, ClassFile.Method.Code method, ClassLoaderWrapper classLoader)
	{
		this.classLoader = classLoader;
		this.method = method;
		state = new InstructionState[method.Instructions.Length];
		callsites = new ArrayList[method.Instructions.Length];

		Hashtable/*<int,ignored>*/[] localStoreReaders = new Hashtable[method.Instructions.Length];

		// HACK because types have to have identity, the subroutine return address and new types are cached here
		Hashtable returnAddressTypes = new Hashtable();
		Hashtable newTypes = new Hashtable();

		// TODO we should ensure that exception blocks and handlers start and end at instruction boundaries (note: wide prefix)

		// start by computing the initial state, the stack is empty and the locals contain the arguments
		state[0] = new InstructionState(method.MaxLocals, method.MaxStack);
		int firstNonArgLocalIndex = 0;
		if(!method.Method.IsStatic)
		{
			// this reference. If we're a constructor, the this reference is uninitialized.
			if(method.Method.Name == "<init>")
			{
				state[0].SetLocalType(firstNonArgLocalIndex++, VerifierTypeWrapper.UninitializedThis, -1);
			}
			else
			{
				state[0].SetLocalType(firstNonArgLocalIndex++, wrapper, -1);
			}
		}
		TypeWrapper[] argTypeWrappers = method.Method.GetArgTypes(classLoader);
		for(int i = 0; i < argTypeWrappers.Length; i++)
		{
			TypeWrapper type = argTypeWrappers[i];
			if(type.IsIntOnStackPrimitive)
			{
				type = PrimitiveTypeWrapper.INT;
			}
			state[0].SetLocalType(firstNonArgLocalIndex++, type, -1);
			if(type.IsWidePrimitive)
			{
				firstNonArgLocalIndex++;
			}
		}
		TypeWrapper[] argumentsByLocalIndex = new TypeWrapper[firstNonArgLocalIndex];
		for(int i = 0; i < argumentsByLocalIndex.Length; i++)
		{
			argumentsByLocalIndex[i] = state[0].GetLocalTypeEx(i);
		}
		InstructionState s = state[0].Copy();
		bool done = false;
		while(!done)
		{
			done = true;
			for(int i = 0; i < method.Instructions.Length; i++)
			{
				if(state[i] != null && state[i].changed)
				{
					try
					{
						//Console.WriteLine(method.Instructions[i].PC + ": " + method.Instructions[i].OpCode.ToString());
						done = false;
						state[i].changed = false;
						// mark the exception handlers reachable from this instruction
						for(int j = 0; j < method.ExceptionTable.Length; j++)
						{
							if(method.ExceptionTable[j].start_pc <= method.Instructions[i].PC && method.ExceptionTable[j].end_pc > method.Instructions[i].PC)
							{
								// NOTE this used to be CopyLocalsAndSubroutines, but it doesn't (always) make
								// sense to copy the subroutine state
								// TODO figure out if there are circumstances under which it does make sense
								// to copy the active subroutine state
								// UPDATE subroutines must be copied as well, but I think I now have a better
								// understanding of subroutine merges, so the problems that triggered the previous
								// change here hopefully won't arise anymore
								InstructionState ex = state[i].CopyLocalsAndSubroutines();
								int catch_type = method.ExceptionTable[j].catch_type;
								if(catch_type == 0)
								{
									ex.PushType(CoreClasses.java.lang.Throwable.Wrapper);
								}
								else
								{
									// TODO if the exception type is unloadable we should consider pushing
									// Throwable as the type and recording a loader constraint
									ex.PushType(GetConstantPoolClassType(catch_type));
								}
								int idx = method.PcIndexMap[method.ExceptionTable[j].handler_pc];
								state[idx] += ex;
							}
						}
						state[i].CopyTo(s);
						ClassFile.Method.Instruction instr = method.Instructions[i];
						switch(instr.NormalizedOpCode)
						{
							case NormalizedByteCode.__aload:
							{
								TypeWrapper type = s.GetLocalType(instr.NormalizedArg1, ref localStoreReaders[i]);
								if(type == VerifierTypeWrapper.Invalid || type.IsPrimitive)
								{
									throw new VerifyError("Object reference expected");
								}
								s.PushType(type);
								break;
							}
							case NormalizedByteCode.__astore:
							{
								// NOTE since the reference can be uninitialized, we cannot use PopObjectType
								TypeWrapper type = s.PopType();
								if(type.IsPrimitive)
								{
									throw new VerifyError("Object reference expected");
								}
								s.SetLocalType(instr.NormalizedArg1, type, i);
								break;
							}
							case NormalizedByteCode.__aconst_null:
								s.PushType(VerifierTypeWrapper.Null);
								break;
							case NormalizedByteCode.__aaload:
							{
								s.PopInt();
								TypeWrapper type = s.PopArrayType();
								if(type == VerifierTypeWrapper.Null)
								{
									// if the array is null, we have use null as the element type, because
									// otherwise the rest of the code will not verify correctly
									s.PushType(VerifierTypeWrapper.Null);
								}
								else if(type.IsUnloadable)
								{
									s.PushType(VerifierTypeWrapper.Unloadable);
								}
								else
								{
									type = type.ElementTypeWrapper;
									if(type.IsPrimitive)
									{
										throw new VerifyError("Object array expected");
									}
									s.PushType(type);
								}
								break;
							}
							case NormalizedByteCode.__aastore:
								s.PopObjectType();
								s.PopInt();
								s.PopArrayType();
								// TODO check that elem is assignable to the array
								break;
							case NormalizedByteCode.__baload:
							{
								s.PopInt();
								TypeWrapper type = s.PopArrayType();
								if(!VerifierTypeWrapper.IsNullOrUnloadable(type) &&
									type != ByteArrayType &&
									type != BooleanArrayType)
								{
									throw new VerifyError();
								}
								s.PushInt();
								break;
							}
							case NormalizedByteCode.__bastore:
							{
								s.PopInt();
								s.PopInt();
								TypeWrapper type = s.PopArrayType();
								if(!VerifierTypeWrapper.IsNullOrUnloadable(type) &&
									type != ByteArrayType &&
									type != BooleanArrayType)
								{
									throw new VerifyError();
								}
								break;
							}
							case NormalizedByteCode.__caload:
								s.PopInt();
								s.PopObjectType(CharArrayType);
								s.PushInt();
								break;
							case NormalizedByteCode.__castore:
								s.PopInt();
								s.PopInt();
								s.PopObjectType(CharArrayType);
								break;
							case NormalizedByteCode.__saload:
								s.PopInt();
								s.PopObjectType(ShortArrayType);
								s.PushInt();
								break;
							case NormalizedByteCode.__sastore:
								s.PopInt();
								s.PopInt();
								s.PopObjectType(ShortArrayType);
								break;
							case NormalizedByteCode.__iaload:
								s.PopInt();
								s.PopObjectType(IntArrayType);
								s.PushInt();
								break;
							case NormalizedByteCode.__iastore:
								s.PopInt();
								s.PopInt();
								s.PopObjectType(IntArrayType);
								break;
							case NormalizedByteCode.__laload:
								s.PopInt();
								s.PopObjectType(LongArrayType);
								s.PushLong();
								break;
							case NormalizedByteCode.__lastore:
								s.PopLong();
								s.PopInt();
								s.PopObjectType(LongArrayType);
								break;
							case NormalizedByteCode.__daload:
								s.PopInt();
								s.PopObjectType(DoubleArrayType);
								s.PushDouble();
								break;
							case NormalizedByteCode.__dastore:
								s.PopDouble();
								s.PopInt();
								s.PopObjectType(DoubleArrayType);
								break;
							case NormalizedByteCode.__faload:
								s.PopInt();
								s.PopObjectType(FloatArrayType);
								s.PushFloat();
								break;
							case NormalizedByteCode.__fastore:
								s.PopFloat();
								s.PopInt();
								s.PopObjectType(FloatArrayType);
								break;
							case NormalizedByteCode.__arraylength:
								s.PopArrayType();
								s.PushInt();
								break;
							case NormalizedByteCode.__iconst:
								s.PushInt();
								break;
							case NormalizedByteCode.__if_icmpeq:
							case NormalizedByteCode.__if_icmpne:
							case NormalizedByteCode.__if_icmplt:
							case NormalizedByteCode.__if_icmpge:
							case NormalizedByteCode.__if_icmpgt:
							case NormalizedByteCode.__if_icmple:
								s.PopInt();
								s.PopInt();
								break;
							case NormalizedByteCode.__ifeq:
							case NormalizedByteCode.__ifge:
							case NormalizedByteCode.__ifgt:
							case NormalizedByteCode.__ifle:
							case NormalizedByteCode.__iflt:
							case NormalizedByteCode.__ifne:
								s.PopInt();
								break;
							case NormalizedByteCode.__ifnonnull:
							case NormalizedByteCode.__ifnull:
								// TODO it might be legal to use an unitialized ref here
								s.PopObjectType();
								break;
							case NormalizedByteCode.__if_acmpeq:
							case NormalizedByteCode.__if_acmpne:
								// TODO it might be legal to use an unitialized ref here
								s.PopObjectType();
								s.PopObjectType();
								break;
							case NormalizedByteCode.__getstatic:
								s.PushType((GetFieldref(instr.Arg1)).GetFieldType(classLoader));
								break;
							case NormalizedByteCode.__putstatic:
								s.PopType(GetFieldref(instr.Arg1).GetFieldType(classLoader));
								break;
							case NormalizedByteCode.__getfield:
								s.PopObjectType(GetFieldref(instr.Arg1).GetClassType(classLoader));
								s.PushType(GetFieldref(instr.Arg1).GetFieldType(classLoader));
								break;
							case NormalizedByteCode.__putfield:
								s.PopType(GetFieldref(instr.Arg1).GetFieldType(classLoader));
								// putfield is allowed to access the unintialized this
								if(s.PeekType() == VerifierTypeWrapper.UninitializedThis)
								{
									s.PopType();
								}
								else
								{
									s.PopObjectType(GetFieldref(instr.Arg1).GetClassType(classLoader));
								}
								break;
							case NormalizedByteCode.__ldc:
							{
								switch(GetConstantPoolConstantType(instr.Arg1))
								{
									case ClassFile.ConstantType.Double:
										s.PushDouble();
										break;
									case ClassFile.ConstantType.Float:
										s.PushFloat();
										break;
									case ClassFile.ConstantType.Integer:
										s.PushInt();
										break;
									case ClassFile.ConstantType.Long:
										s.PushLong();
										break;
									case ClassFile.ConstantType.String:
										s.PushType(CoreClasses.java.lang.String.Wrapper);
										break;
									case ClassFile.ConstantType.Class:
										if(method.Method.ClassFile.MajorVersion < 49)
										{
											throw new VerifyError("Illegal type in constant pool");
										}
										s.PushType(CoreClasses.java.lang.Class.Wrapper);
										break;
									default:
										// NOTE this is not a VerifyError, because it cannot happen (unless we have
										// a bug in ClassFile.GetConstantPoolConstantType)
										throw new InvalidOperationException();
								}
								break;
							}
							case NormalizedByteCode.__invokevirtual:
							case NormalizedByteCode.__invokespecial:
							case NormalizedByteCode.__invokeinterface:
							case NormalizedByteCode.__invokestatic:
							{
								ClassFile.ConstantPoolItemFMI cpi = GetMethodref(instr.Arg1);
								if((cpi is ClassFile.ConstantPoolItemInterfaceMethodref) != (instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface))
								{
									throw new VerifyError("Illegal constant pool index");
								}
								if(instr.NormalizedOpCode != NormalizedByteCode.__invokespecial && cpi.Name == "<init>")
								{
									throw new VerifyError("Must call initializers using invokespecial");
								}
								if(cpi.Name == "<clinit>")
								{
									throw new VerifyError("Illegal call to internal method");
								}
								TypeWrapper[] args = cpi.GetArgTypes(classLoader);
								for(int j = args.Length - 1; j >= 0; j--)
								{
									s.PopType(args[j]);
								}
								if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface)
								{
									// TODO check arg (should match signature)
									// error: "Inconsistent args size"
								}
								if(instr.NormalizedOpCode != NormalizedByteCode.__invokestatic)
								{
									// TODO we should verify that in a constructor, the base class constructor is actually called
									if(cpi.Name == "<init>")
									{
										TypeWrapper type = s.PopType();
										if((VerifierTypeWrapper.IsNew(type) && ((VerifierTypeWrapper)type).UnderlyingType != cpi.GetClassType(classLoader)) ||
											(type == VerifierTypeWrapper.UninitializedThis && cpi.GetClassType(classLoader) != method.Method.ClassFile.GetSuperTypeWrapper(classLoader) && cpi.GetClassType(classLoader) != wrapper) ||
											(!VerifierTypeWrapper.IsNew(type) && type != VerifierTypeWrapper.UninitializedThis))
										{
											// TODO oddly enough, Java fails verification for the class without
											// even running the constructor, so maybe constructors are always
											// verified...
											// NOTE when a constructor isn't verifiable, the static initializer
											// doesn't run either (or so I believe)
											throw new VerifyError("Call to wrong initialization method");
										}
										// after the constructor invocation, the uninitialized reference, is now
										// suddenly initialized
										if(type == VerifierTypeWrapper.UninitializedThis)
										{
											s.MarkInitialized(type, wrapper, i);
										}
										else
										{
											s.MarkInitialized(type, ((VerifierTypeWrapper)type).UnderlyingType, i);
										}
									}
									else
									{
										if(instr.NormalizedOpCode != NormalizedByteCode.__invokeinterface)
										{
											TypeWrapper refType = s.PopObjectType();
											if(!VerifierTypeWrapper.IsNullOrUnloadable(refType) && !refType.IsAssignableTo(cpi.GetClassType(classLoader)))
											{
												throw new VerifyError("Incompatible object argument for function call");
											}
											// for invokespecial we also need to make sure we're calling ourself or a base class
											if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
											{
												if(!VerifierTypeWrapper.IsNullOrUnloadable(refType) && !wrapper.IsAssignableTo(refType))
												{
													throw new VerifyError("Incompatible object argument for invokespecial");
												}
											}
										}
										else /* __invokeinterface */
										{
											// NOTE previously we checked the type here, but it turns out that
											// the JVM throws an IncompatibleClassChangeError at runtime instead
											// of a VerifyError if this doesn't match
											s.PopObjectType();
										}
									}
								}
								TypeWrapper retType = cpi.GetRetType(classLoader);
								if(retType != PrimitiveTypeWrapper.VOID)
								{
									s.PushType(retType);
								}
								break;
							}
							case NormalizedByteCode.__goto:
								break;
							case NormalizedByteCode.__istore:
								s.PopInt();
								s.SetLocalInt(instr.NormalizedArg1, i);
								break;
							case NormalizedByteCode.__iload:
								s.GetLocalInt(instr.NormalizedArg1, ref localStoreReaders[i]);
								s.PushInt();
								break;
							case NormalizedByteCode.__ineg:
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__iadd:
							case NormalizedByteCode.__isub:
							case NormalizedByteCode.__imul:
							case NormalizedByteCode.__idiv:
							case NormalizedByteCode.__irem:
							case NormalizedByteCode.__iand:
							case NormalizedByteCode.__ior:
							case NormalizedByteCode.__ixor:
							case NormalizedByteCode.__ishl:
							case NormalizedByteCode.__ishr:
							case NormalizedByteCode.__iushr:
								s.PopInt();
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__lneg:
								s.PopLong();
								s.PushLong();
								break;
							case NormalizedByteCode.__ladd:
							case NormalizedByteCode.__lsub:
							case NormalizedByteCode.__lmul:
							case NormalizedByteCode.__ldiv:
							case NormalizedByteCode.__lrem:
							case NormalizedByteCode.__land:
							case NormalizedByteCode.__lor:
							case NormalizedByteCode.__lxor:
								s.PopLong();
								s.PopLong();
								s.PushLong();
								break;
							case NormalizedByteCode.__lshl:
							case NormalizedByteCode.__lshr:
							case NormalizedByteCode.__lushr:
								s.PopInt();
								s.PopLong();
								s.PushLong();
								break;
							case NormalizedByteCode.__fneg:
								s.PopFloat();
								s.PushFloat();
								break;
							case NormalizedByteCode.__fadd:
							case NormalizedByteCode.__fsub:
							case NormalizedByteCode.__fmul:
							case NormalizedByteCode.__fdiv:
							case NormalizedByteCode.__frem:
								s.PopFloat();
								s.PopFloat();
								s.PushFloat();
								break;
							case NormalizedByteCode.__dneg:
								s.PopDouble();
								s.PushDouble();
								break;
							case NormalizedByteCode.__dadd:
							case NormalizedByteCode.__dsub:
							case NormalizedByteCode.__dmul:
							case NormalizedByteCode.__ddiv:
							case NormalizedByteCode.__drem:
								s.PopDouble();
								s.PopDouble();
								s.PushDouble();
								break;
							case NormalizedByteCode.__new:
							{
								// mark the type, so that we can ascertain that it is a "new object"
								TypeWrapper type = (TypeWrapper)newTypes[instr.PC];
								if(type == null)
								{
									type = VerifierTypeWrapper.MakeNew(GetConstantPoolClassType(instr.Arg1), instr.PC);
									newTypes[instr.PC] = type;
								}
								s.PushType(type);
								break;
							}
							case NormalizedByteCode.__multianewarray:
							{
								if(instr.Arg2 < 1)
								{
									throw new VerifyError("Illegal dimension argument");
								}
								for(int j = 0; j < instr.Arg2; j++)
								{
									s.PopInt();
								}
								TypeWrapper type = GetConstantPoolClassType(instr.Arg1);
								if(type.ArrayRank < instr.Arg2)
								{
									throw new VerifyError("Illegal dimension argument");
								}
								s.PushType(type);
								break;
							}
							case NormalizedByteCode.__anewarray:
							{
								s.PopInt();
								TypeWrapper type = GetConstantPoolClassType(instr.Arg1);
								if(type.IsUnloadable)
								{
									string name = type.Name;
									if(name[0] != '[')
									{
										name = "L" + name + ";";
									}
									s.PushType(new UnloadableTypeWrapper(name));
								}
								else
								{
									s.PushType(type.MakeArrayType(1));
								}
								break;
							}
							case NormalizedByteCode.__newarray:
								s.PopInt();
							switch(instr.Arg1)
							{
								case 4:
									s.PushType(BooleanArrayType);
									break;
								case 5:
									s.PushType(CharArrayType);
									break;
								case 6:
									s.PushType(FloatArrayType);
									break;
								case 7:
									s.PushType(DoubleArrayType);
									break;
								case 8:
									s.PushType(ByteArrayType);
									break;
								case 9:
									s.PushType(ShortArrayType);
									break;
								case 10:
									s.PushType(IntArrayType);
									break;
								case 11:
									s.PushType(LongArrayType);
									break;
								default:
									throw new VerifyError("Bad type");
							}
								break;
							case NormalizedByteCode.__swap:
							{
								TypeWrapper t1 = s.PopType();
								TypeWrapper t2 = s.PopType();
								s.PushType(t1);
								s.PushType(t2);
								break;
							}
							case NormalizedByteCode.__dup:
							{
								TypeWrapper t = s.PopType();
								s.PushType(t);
								s.PushType(t);
								break;
							}
							case NormalizedByteCode.__dup2:
							{
								TypeWrapper t = s.PopAnyType();
								if(t.IsWidePrimitive)
								{
									s.PushType(t);
									s.PushType(t);
								}
								else
								{
									TypeWrapper t2 = s.PopType();
									s.PushType(t2);
									s.PushType(t);
									s.PushType(t2);
									s.PushType(t);
								}
								break;
							}
							case NormalizedByteCode.__dup_x1:
							{
								TypeWrapper value1 = s.PopType();
								TypeWrapper value2 = s.PopType();
								s.PushType(value1);
								s.PushType(value2);
								s.PushType(value1);
								break;
							}
							case NormalizedByteCode.__dup2_x1:
							{
								TypeWrapper value1 = s.PopAnyType();
								if(value1.IsWidePrimitive)
								{
									TypeWrapper value2 = s.PopType();
									s.PushType(value1);
									s.PushType(value2);
									s.PushType(value1);
								}
								else
								{
									TypeWrapper value2 = s.PopType();
									TypeWrapper value3 = s.PopType();
									s.PushType(value2);
									s.PushType(value1);
									s.PushType(value3);
									s.PushType(value2);
									s.PushType(value1);
								}
								break;
							}
							case NormalizedByteCode.__dup_x2:
							{
								TypeWrapper value1 = s.PopType();
								TypeWrapper value2 = s.PopType();
								TypeWrapper value3 = s.PopType();
								s.PushType(value1);
								s.PushType(value3);
								s.PushType(value2);
								s.PushType(value1);
								break;
							}
							case NormalizedByteCode.__dup2_x2:
							{
								TypeWrapper value1 = s.PopAnyType();
								if(value1.IsWidePrimitive)
								{
									TypeWrapper value2 = s.PopAnyType();
									if(value2.IsWidePrimitive)
									{
										// Form 4
										s.PushType(value1);
										s.PushType(value2);
										s.PushType(value1);
									}
									else
									{
										// Form 2
										TypeWrapper value3 = s.PopType();
										s.PushType(value1);
										s.PushType(value3);
										s.PushType(value2);
										s.PushType(value1);
									}
								}
								else
								{
									TypeWrapper value2 = s.PopType();
									TypeWrapper value3 = s.PopAnyType();
									if(value3.IsWidePrimitive)
									{
										// Form 3
										s.PushType(value2);
										s.PushType(value1);
										s.PushType(value3);
										s.PushType(value2);
										s.PushType(value1);
									}
									else
									{
										// Form 4
										TypeWrapper value4 = s.PopType();
										s.PushType(value2);
										s.PushType(value1);
										s.PushType(value4);
										s.PushType(value3);
										s.PushType(value2);
										s.PushType(value1);
									}
								}
								break;
							}
							case NormalizedByteCode.__pop:
								s.PopType();
								break;
							case NormalizedByteCode.__pop2:
							{
								TypeWrapper type = s.PopAnyType();
								if(!type.IsWidePrimitive)
								{
									s.PopType();
								}
								break;
							}
							case NormalizedByteCode.__monitorenter:
							case NormalizedByteCode.__monitorexit:
								// TODO these bytecodes are allowed on an uninitialized object, but
								// we don't support that at the moment...
								s.PopObjectType();
								break;
							case NormalizedByteCode.__return:
								if(method.Method.GetRetType(classLoader) != PrimitiveTypeWrapper.VOID)
								{
									throw new VerifyError("Wrong return type in function");
								}
								break;
							case NormalizedByteCode.__areturn:
								s.PopObjectType(method.Method.GetRetType(classLoader));
								break;
							case NormalizedByteCode.__ireturn:
							{
								s.PopInt();
								TypeWrapper retType = method.Method.GetRetType(classLoader);
								if(!retType.IsIntOnStackPrimitive)
								{
									throw new VerifyError("Wrong return type in function");
								}
								break;
							}
							case NormalizedByteCode.__lreturn:
								s.PopLong();
								if(method.Method.GetRetType(classLoader) != PrimitiveTypeWrapper.LONG)
								{
									throw new VerifyError("Wrong return type in function");
								}
								break;
							case NormalizedByteCode.__freturn:
								s.PopFloat();
								if(method.Method.GetRetType(classLoader) != PrimitiveTypeWrapper.FLOAT)
								{
									throw new VerifyError("Wrong return type in function");
								}
								break;
							case NormalizedByteCode.__dreturn:
								s.PopDouble();
								if(method.Method.GetRetType(classLoader) != PrimitiveTypeWrapper.DOUBLE)
								{
									throw new VerifyError("Wrong return type in function");
								}
								break;
							case NormalizedByteCode.__fload:
								s.GetLocalFloat(instr.NormalizedArg1, ref localStoreReaders[i]);
								s.PushFloat();
								break;
							case NormalizedByteCode.__fstore:
								s.PopFloat();
								s.SetLocalFloat(instr.NormalizedArg1, i);
								break;
							case NormalizedByteCode.__dload:
								s.GetLocalDouble(instr.NormalizedArg1, ref localStoreReaders[i]);
								s.PushDouble();
								break;
							case NormalizedByteCode.__dstore:
								s.PopDouble();
								s.SetLocalDouble(instr.NormalizedArg1, i);
								break;
							case NormalizedByteCode.__lload:
								s.GetLocalLong(instr.NormalizedArg1, ref localStoreReaders[i]);
								s.PushLong();
								break;
							case NormalizedByteCode.__lstore:
								s.PopLong();
								s.SetLocalLong(instr.NormalizedArg1, i);
								break;
							case NormalizedByteCode.__lconst_0:
							case NormalizedByteCode.__lconst_1:
								s.PushLong();
								break;
							case NormalizedByteCode.__fconst_0:
							case NormalizedByteCode.__fconst_1:
							case NormalizedByteCode.__fconst_2:
								s.PushFloat();
								break;
							case NormalizedByteCode.__dconst_0:
							case NormalizedByteCode.__dconst_1:
								s.PushDouble();
								break;
							case NormalizedByteCode.__lcmp:
								s.PopLong();
								s.PopLong();
								s.PushInt();
								break;
							case NormalizedByteCode.__fcmpl:
							case NormalizedByteCode.__fcmpg:
								s.PopFloat();
								s.PopFloat();
								s.PushInt();
								break;
							case NormalizedByteCode.__dcmpl:
							case NormalizedByteCode.__dcmpg:
								s.PopDouble();
								s.PopDouble();
								s.PushInt();
								break;
							case NormalizedByteCode.__checkcast:
								s.PopObjectType();
								s.PushType(GetConstantPoolClassType(instr.Arg1));
								break;
							case NormalizedByteCode.__instanceof:
								s.PopObjectType();
								s.PushInt();
								break;
							case NormalizedByteCode.__iinc:
								s.GetLocalInt(instr.Arg1, ref localStoreReaders[i]);
								break;
							case NormalizedByteCode.__athrow:
								s.PopObjectType(CoreClasses.java.lang.Throwable.Wrapper);
								break;
							case NormalizedByteCode.__lookupswitch:
								s.PopInt();
								break;
							case NormalizedByteCode.__i2b:
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__i2c:
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__i2s:
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__i2l:
								s.PopInt();
								s.PushLong();
								break;
							case NormalizedByteCode.__i2f:
								s.PopInt();
								s.PushFloat();
								break;
							case NormalizedByteCode.__i2d:
								s.PopInt();
								s.PushDouble();
								break;
							case NormalizedByteCode.__l2i:
								s.PopLong();
								s.PushInt();
								break;
							case NormalizedByteCode.__l2f:
								s.PopLong();
								s.PushFloat();
								break;
							case NormalizedByteCode.__l2d:
								s.PopLong();
								s.PushDouble();
								break;
							case NormalizedByteCode.__f2i:
								s.PopFloat();
								s.PushInt();
								break;
							case NormalizedByteCode.__f2l:
								s.PopFloat();
								s.PushLong();
								break;
							case NormalizedByteCode.__f2d:
								s.PopFloat();
								s.PushDouble();
								break;
							case NormalizedByteCode.__d2i:
								s.PopDouble();
								s.PushInt();
								break;
							case NormalizedByteCode.__d2f:
								s.PopDouble();
								s.PushFloat();
								break;
							case NormalizedByteCode.__d2l:
								s.PopDouble();
								s.PushLong();
								break;
							case NormalizedByteCode.__jsr:
								// TODO make sure we're not calling a subroutine we're already in
								break;
							case NormalizedByteCode.__ret:
							{
								// TODO if we're returning from a higher level subroutine, invalidate
								// all the intermediate return addresses
								int subroutineIndex = s.GetLocalRet(instr.Arg1, ref localStoreReaders[i]);
								s.CheckSubroutineActive(subroutineIndex);
								break;
							}
							case NormalizedByteCode.__nop:
								if(i + 1 == method.Method.CodeAttribute.Instructions.Length)
								{
									throw new VerifyError("Falling off the end of the code");
								}
								break;
							default:
								throw new NotImplementedException(instr.NormalizedOpCode.ToString());
						}
						if(s.GetStackHeight() > method.MaxStack)
						{
							throw new VerifyError("Stack size too large");
						}
						try
						{
							// another big switch to handle the opcode targets
							switch(instr.NormalizedOpCode)
							{
								case NormalizedByteCode.__lookupswitch:
									for(int j = 0; j < instr.Values.Length; j++)
									{
										state[method.PcIndexMap[instr.PC + instr.TargetOffsets[j]]] += s;
									}
									state[method.PcIndexMap[instr.PC + instr.DefaultOffset]] += s;
									break;
								case NormalizedByteCode.__ifeq:
								case NormalizedByteCode.__ifne:
								case NormalizedByteCode.__iflt:
								case NormalizedByteCode.__ifge:
								case NormalizedByteCode.__ifgt:
								case NormalizedByteCode.__ifle:
								case NormalizedByteCode.__if_icmpeq:
								case NormalizedByteCode.__if_icmpne:
								case NormalizedByteCode.__if_icmplt:
								case NormalizedByteCode.__if_icmpge:
								case NormalizedByteCode.__if_icmpgt:
								case NormalizedByteCode.__if_icmple:
								case NormalizedByteCode.__if_acmpeq:
								case NormalizedByteCode.__if_acmpne:
								case NormalizedByteCode.__ifnull:
								case NormalizedByteCode.__ifnonnull:
									if(instr.Arg1 < 0)
									{
										// backward branches cannot have uninitialized objects on
										// the stack or in local variables
										s.CheckUninitializedObjRefs();
									}
									state[i + 1] += s;
									state[method.PcIndexMap[instr.PC + instr.Arg1]] += s;
									break;
								case NormalizedByteCode.__goto:
									if(instr.Arg1 < 0)
									{
										// backward branches cannot have uninitialized objects on
										// the stack or in local variables
										s.CheckUninitializedObjRefs();
									}
									state[method.PcIndexMap[instr.PC + instr.Arg1]] += s;
									break;
								case NormalizedByteCode.__jsr:
								{
									int index = method.PcIndexMap[instr.PC + instr.Arg1];
									s.SetSubroutineId(index);
									TypeWrapper retAddressType = (TypeWrapper)returnAddressTypes[index];
									if(retAddressType == null)
									{
										retAddressType = VerifierTypeWrapper.MakeRet(index);
										returnAddressTypes[index] = retAddressType;
									}
									s.PushType(retAddressType);
									state[index] += s;
									AddCallSite(index, i);
									break;
								}
								case NormalizedByteCode.__ret:
								{
									// HACK if the ret is processed before all of the jsr instructions to this subroutine
									// we wouldn't be able to properly merge, so that is why we track the number of callsites
									// for each subroutine instruction (see Instruction.AddCallSite())
									int subroutineIndex = s.GetLocalRet(instr.Arg1, ref localStoreReaders[i]);
									int[] cs = GetCallSites(subroutineIndex);
									bool[] locals_modified = s.ClearSubroutineId(subroutineIndex);
									for(int j = 0; j < cs.Length; j++)
									{
										state[cs[j] + 1] = InstructionState.Merge(state[cs[j] + 1], s, locals_modified, state[cs[j]]);
									}
									break;
								}
								case NormalizedByteCode.__ireturn:
								case NormalizedByteCode.__lreturn:
								case NormalizedByteCode.__freturn:
								case NormalizedByteCode.__dreturn:
								case NormalizedByteCode.__areturn:
								case NormalizedByteCode.__return:
								case NormalizedByteCode.__athrow:
									break;
								default:
									state[i + 1] += s;
									break;
							}
						}
						catch(IndexOutOfRangeException)
						{
							// we're going to assume that this always means that we have an invalid branch target
							// NOTE because PcIndexMap returns -1 for illegal PCs (in the middle of an instruction) and
							// we always use that value as an index into the state array, any invalid PC will result
							// in an IndexOutOfRangeException
							throw new VerifyError("Illegal target of jump or branch");
						}
					}
					catch(VerifyError x)
					{
						x.Class = method.Method.ClassFile.Name;
						x.Method = method.Method.Name;
						x.Signature = method.Method.Signature;
						x.ByteCodeOffset = method.Instructions[i].PC;
						string opcode = method.Instructions[i].OpCode.ToString();
						if(opcode.StartsWith("__"))
						{
							opcode = opcode.Substring(2);
						}
						x.Instruction = opcode;
						Tracer.Info(Tracer.Verifier, x.ToString());
						/*
						for(int j = 0; j < method.Instructions.Length; j++)
						{
							//state[j].DumpLocals();
							//state[j].DumpStack();
							if(state[j] != null)
							{
								state[j].DumpSubroutines();
								Console.WriteLine("{0}: {1}", method.Instructions[j].PC, method.Instructions[j].OpCode.ToString());
							}
						}
						*/
						throw;
					}
				}
			}
		}
		
		// now that we've done the code flow analysis, we can do a liveness analysis on the local variables
		Hashtable/*<string,LocalVar>*/ localByStoreSite = new Hashtable();
		ArrayList/*<LocalVar>*/ locals = new ArrayList();
		for(int i = 0; i < localStoreReaders.Length; i++)
		{
			if(localStoreReaders[i] != null)
			{
				VisitLocalLoads(locals, localByStoreSite, localStoreReaders[i], i);
			}
		}
		Hashtable forwarders = new Hashtable();
		if(JVM.Debug)
		{
			// if we're emitting debug info, we need to keep dead stores as well...
			for(int i = 0; i < method.Instructions.Length; i++)
			{
				if(IsStoreLocal(method.Instructions[i].NormalizedOpCode))
				{
					if(!localByStoreSite.ContainsKey(i + ":" + method.Instructions[i].NormalizedArg1))
					{
						LocalVar v = new LocalVar();
						v.local = method.Instructions[i].NormalizedArg1;
						v.type = GetRawStackTypeWrapper(i, 0);
						v.FindLvtEntry(method, i);
						locals.Add(v);
						localByStoreSite.Add(i + ":" + v.local, v);
					}
				}
			}
			// to make the debugging experience better, we have to trust the
			// LocalVariableTable (unless it's clearly bogus) and merge locals
			// together that are the same according to the LVT
			for(int i = 0; i < locals.Count - 1; i++)
			{
				for(int j = i + 1; j < locals.Count; j++)
				{
					LocalVar v1 = (LocalVar)locals[i];
					LocalVar v2 = (LocalVar)locals[j];
					if(v1.name != null && v1.name == v2.name && v1.start_pc == v2.start_pc && v1.end_pc == v2.end_pc)
					{
						// we can only merge if the resulting type is valid (this protects against incorrect
						// LVT data, but is also needed for constructors, where the uninitialized this is a different
						// type from the initialized this)
						TypeWrapper tw = InstructionState.FindCommonBaseType(v1.type, v2.type);
						if(tw != VerifierTypeWrapper.Invalid)
						{
							v1.isArg |= v2.isArg;
							v1.type = tw;
							forwarders.Add(v2, v1);
							locals.RemoveAt(j);
							j--;
						}
					}
				}
			}
		}
		else
		{
			for(int i = 0; i < locals.Count - 1; i++)
			{
				for(int j = i + 1; j < locals.Count; j++)
				{
					LocalVar v1 = (LocalVar)locals[i];
					LocalVar v2 = (LocalVar)locals[j];
					// if the two locals are the same, we merge them, this is a small
					// optimization, it should *not* be required for correctness.
					if(v1.local == v2.local && v1.type == v2.type)
					{
						v1.isArg |= v2.isArg;
						forwarders.Add(v2, v1);
						locals.RemoveAt(j);
						j--;
					}
				}
			}
		}
		invokespecialLocalVars = new LocalVar[method.Instructions.Length][];
		localVars = new LocalVar[method.Instructions.Length];
		for(int i = 0; i < localVars.Length; i++)
		{
			LocalVar v = null;
			if(localStoreReaders[i] != null)
			{
				Debug.Assert(IsLoadLocal(method.Instructions[i].NormalizedOpCode));
				// lame way to look up the local variable for a load
				// (by indirecting through a corresponding store)
				foreach(int store in localStoreReaders[i].Keys)
				{
					v = (LocalVar)localByStoreSite[store + ":" + method.Instructions[i].NormalizedArg1];
					break;
				}
			}
			else
			{
				if(method.Instructions[i].NormalizedOpCode == NormalizedByteCode.__invokespecial)
				{
					invokespecialLocalVars[i] = new LocalVar[method.MaxLocals];
					for(int j = 0; j < invokespecialLocalVars[i].Length; j++)
					{
						invokespecialLocalVars[i][j] = (LocalVar)localByStoreSite[i + ":" + j];
					}
				}
				else
				{
					v = (LocalVar)localByStoreSite[i + ":" + method.Instructions[i].NormalizedArg1];
				}
			}
			if(v != null)
			{
				LocalVar fwd = (LocalVar)forwarders[v];
				if(fwd != null)
				{
					v = fwd;
				}
				localVars[i] = v;
			}
		}
		this.allLocalVars = (LocalVar[])locals.ToArray(typeof(LocalVar));
	}

	private static bool IsLoadLocal(NormalizedByteCode bc)
	{
		return bc == NormalizedByteCode.__aload ||
			bc == NormalizedByteCode.__iload ||
			bc == NormalizedByteCode.__lload ||
			bc == NormalizedByteCode.__fload ||
			bc == NormalizedByteCode.__dload ||
			bc == NormalizedByteCode.__iinc ||
			bc == NormalizedByteCode.__ret;
	}

	internal static bool IsStoreLocal(NormalizedByteCode bc)
	{
		return bc == NormalizedByteCode.__astore ||
			bc == NormalizedByteCode.__istore ||
			bc == NormalizedByteCode.__lstore ||
			bc == NormalizedByteCode.__fstore ||
			bc == NormalizedByteCode.__dstore;
	}

	private void VisitLocalLoads(ArrayList locals, Hashtable localByStoreSite, Hashtable storeSites, int instructionIndex)
	{
		Debug.Assert(IsLoadLocal(method.Instructions[instructionIndex].NormalizedOpCode));
		LocalVar local = null;
		TypeWrapper type = VerifierTypeWrapper.Null;
		int localIndex = method.Instructions[instructionIndex].NormalizedArg1;
		bool isArg = false;
		foreach(int store in storeSites.Keys)
		{
			if(store == -1)
			{
				// it's a method argument, it has no initial store, but the type is simply the parameter type
				type = InstructionState.FindCommonBaseType(type, state[0].GetLocalTypeEx(localIndex));
				isArg = true;
			}
			else
			{
				if(method.Instructions[store].NormalizedOpCode == NormalizedByteCode.__invokespecial)
				{
					type = InstructionState.FindCommonBaseType(type, GetLocalTypeWrapper(store + 1, localIndex));
				}
				else
				{
					Debug.Assert(IsStoreLocal(method.Instructions[store].NormalizedOpCode));
					type = InstructionState.FindCommonBaseType(type, GetRawStackTypeWrapper(store, 0));
				}
			}
			// we can't have an invalid type, because that would have failed verification earlier
			Debug.Assert(type != VerifierTypeWrapper.Invalid);

			LocalVar l = (LocalVar)localByStoreSite[store + ":" + localIndex];
			if(l != null)
			{
				if(local == null)
				{
					local = l;
				}
				else
				{
					// If we've already defined a LocalVar and we find another one, then we merge them
					// together.
					// This happens for the following code fragment:
					//
					// int i = -1;
					// try { i = 0; for(; ; ) System.out.println(i); } catch(Exception x) {}
					// try { i = 0; for(; ; ) System.out.println(i); } catch(Exception x) {}
					// System.out.println(i);
					//
					local = MergeLocals(locals, localByStoreSite, local, l);
				}
			}
		}
		if(local == null)
		{
			local = new LocalVar();
			local.local = localIndex;
			local.type = type;
			local.isArg = isArg;
			if(JVM.Debug)
			{
				local.FindLvtEntry(method, instructionIndex);
			}
			locals.Add(local);
		}
		else
		{
			local.isArg |= isArg;
			local.type = InstructionState.FindCommonBaseType(local.type, type);
			Debug.Assert(local.type != VerifierTypeWrapper.Invalid);
		}
		foreach(int store in storeSites.Keys)
		{
			LocalVar v = (LocalVar)localByStoreSite[store + ":" + localIndex];
			if(v == null)
			{
				// TODO does this ever happen?
				localByStoreSite[store + ":" + localIndex] = local;
			}
			else if(v != local)
			{
				// TODO does this ever happen?
				Console.WriteLine("merging...");
				local = MergeLocals(locals, localByStoreSite, local, v);
			}
		}
	}

	private static LocalVar MergeLocals(ArrayList locals, Hashtable localByStoreSite, LocalVar l1, LocalVar l2)
	{
		Debug.Assert(l1.local == l2.local);
		for(int i = 0; i < locals.Count; i++)
		{
			if(locals[i] == l2)
			{
				locals.RemoveAt(i);
				i--;
			}
		}
		Hashtable temp = (Hashtable)localByStoreSite.Clone();
		localByStoreSite.Clear();
		foreach(DictionaryEntry de in temp)
		{
			localByStoreSite[de.Key] = de.Value == l2 ? l1 : de.Value;
		}
		l1.isArg |= l2.isArg;
		l1.type = InstructionState.FindCommonBaseType(l1.type, l2.type);
		Debug.Assert(l1.type != VerifierTypeWrapper.Invalid);
		return l1;
	}

	private ClassFile.ConstantPoolItemFMI GetMethodref(int index)
	{
		try
		{
			ClassFile.ConstantPoolItemFMI item = method.Method.ClassFile.GetMethodref(index);
			if(item != null && !(item is ClassFile.ConstantPoolItemFieldref))
			{
				return item;
			}
		}
		catch(InvalidCastException)
		{
		}
		catch(IndexOutOfRangeException)
		{
		}
		throw new VerifyError("Illegal constant pool index");
	}

	private ClassFile.ConstantPoolItemFieldref GetFieldref(int index)
	{
		try
		{
			ClassFile.ConstantPoolItemFieldref item = method.Method.ClassFile.GetFieldref(index);
			if(item != null)
			{
				return item;
			}
		}
		catch(InvalidCastException)
		{
		}
		catch(IndexOutOfRangeException)
		{
		}
		throw new VerifyError("Illegal constant pool index");
	}

	private ClassFile.ConstantType GetConstantPoolConstantType(int index)
	{
		try
		{
			return method.Method.ClassFile.GetConstantPoolConstantType(index);
		}
		catch(IndexOutOfRangeException)
		{
			// constant pool index out of range
		}
		catch(InvalidOperationException)
		{
			// specified constant pool entry doesn't contain a constant
		}
		catch(NullReferenceException)
		{
			// specified constant pool entry is empty (entry 0 or the filler following a wide entry)
		}
		throw new VerifyError("Illegal constant pool index");
	}

	private string GetConstantPoolClass(int index)
	{
		try
		{
			return method.Method.ClassFile.GetConstantPoolClass(index);
		}
		catch(InvalidCastException)
		{
		}
		catch(IndexOutOfRangeException)
		{
		}
		throw new VerifyError("Illegal constant pool index");
	}

	private TypeWrapper GetConstantPoolClassType(int index)
	{
		try
		{
			return method.Method.ClassFile.GetConstantPoolClassType(index, classLoader);
		}
		catch(InvalidCastException)
		{
		}
		catch(IndexOutOfRangeException)
		{
		}
		throw new VerifyError("Illegal constant pool index");
	}

	private void AddCallSite(int subroutineIndex, int callSiteIndex)
	{
		if(callsites[subroutineIndex] == null)
		{
			callsites[subroutineIndex] = new ArrayList();
		}
		ArrayList l = (ArrayList)callsites[subroutineIndex];
		if(l.IndexOf(callSiteIndex) == -1)
		{
			l.Add(callSiteIndex);
			state[subroutineIndex].AddCallSite();
		}
	}

	internal int[] GetCallSites(int subroutineIndex)
	{
		return (int[])((ArrayList)callsites[subroutineIndex]).ToArray(typeof(int));
	}

	internal int GetStackHeight(int index)
	{
		return state[index].GetStackHeight();
	}

	internal TypeWrapper GetRawStackTypeWrapper(int index, int pos)
	{
		return state[index].GetStackSlot(pos);
	}

	internal TypeWrapper GetLocalTypeWrapper(int index, int local)
	{
		return state[index].GetLocalTypeEx(local);
	}

	// NOTE for dead stores, this returns null
	internal LocalVar GetLocalVar(int instructionIndex)
	{
		return localVars[instructionIndex];
	}

	internal LocalVar[] GetLocalVarsForInvokeSpecial(int instructionIndex)
	{
		Debug.Assert(method.Instructions[instructionIndex].NormalizedOpCode == NormalizedByteCode.__invokespecial);
		return invokespecialLocalVars[instructionIndex];
	}

	internal LocalVar[] GetAllLocalVars()
	{
		return allLocalVars;
	}

	internal bool IsReachable(int instructionIndex)
	{
		return state[instructionIndex] != null;
	}
}
@


1.25
log
@*** empty log message ***
@
text
@@


1.24
log
@*** empty log message ***
@
text
@d1145 2
@


1.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002 Jeroen Frijters
d251 1
a251 1
						System.Diagnostics.Debug.Assert(false);
d1066 1
a1066 1
class LocalVar : IComparable
d1068 1
a1075 2
	// we have a linked list of LocalVars that are really the same
	private LocalVar next;
d1077 1
a1077 1
	internal void Link(LocalVar v)
d1079 2
a1080 9
		Debug.Assert(v != this);
		v = v.Tail();
		v.next = this;
		next = null;
	}

	internal LocalVar Tail()
	{
		if(next == null)
d1082 16
a1097 1
			return this;
a1098 15
		return next.Tail();
	}

	int IComparable.CompareTo(object obj)
	{
		LocalVar other = (LocalVar)obj;
		if(local > other.local)
		{
			return 1;
		}
		else if(local < other.local)
		{
			return -1;
		}
		return type.SigName.CompareTo(other.type.SigName);
d1116 3
a1118 2
	private LocalVar[] localVars;
	private LocalVar[][] invokespecialLocalVars;
d1139 1
a1139 1
		Hashtable[] localStoreReaders = new Hashtable[method.Instructions.Length];
d1147 1
a1147 1
		int arg = 0;
d1153 1
a1153 1
				state[0].SetLocalType(arg++, VerifierTypeWrapper.UninitializedThis, -1);
d1157 1
a1157 1
				state[0].SetLocalType(arg++, wrapper, -1);
d1160 2
a1161 2
		// HACK articial scope to make "args" name reusable
		if(true)
d1163 7
a1169 2
			TypeWrapper[] args = method.Method.GetArgTypes(classLoader);
			for(int i = 0; i < args.Length; i++)
d1171 1
a1171 10
				TypeWrapper type = args[i];
				if(type.IsIntOnStackPrimitive)
				{
					type = PrimitiveTypeWrapper.INT;
				}
				state[0].SetLocalType(arg++, type, -1);
				if(type.IsWidePrimitive)
				{
					arg++;
				}
d1174 5
d2172 2
a2173 2
		Hashtable localByStoreSite = new Hashtable();
		ArrayList locals = new ArrayList();
d2181 2
a2182 2
		Hashtable unique = new Hashtable();
		for(int i = 0; i < locals.Count; i++)
d2184 42
a2225 1
			unique[((LocalVar)locals[i]).Tail()] = "";
d2227 1
a2227 4
		locals = new ArrayList(unique.Keys);
		locals.Sort();
		Hashtable forwarders = new Hashtable();
		for(int i = 0; i < locals.Count - 1; i++)
d2229 1
a2229 8
			LocalVar v1 = (LocalVar)locals[i];
			LocalVar v2 = (LocalVar)locals[i + 1];
			// if the two locals are the same, we merge them (note that the debugging stuff
			// will always match if debugging is disabled)
			// NOTE this is a small optimization (and to improve the debugging experience)
			// it should *not* be required for correctness.
			if(v1.local == v2.local && v1.type == v2.type &&
				v1.name == v2.name && v1.start_pc == v2.start_pc && v1.end_pc == v2.end_pc)
d2231 14
a2244 3
				forwarders.Add(v2, v1);
				locals.RemoveAt(i + 1);
				i--;
d2288 1
d2302 1
a2302 1
	private static bool IsStoreLocal(NormalizedByteCode bc)
d2317 1
d2324 1
a2341 17

			// If we've already defined a LocalVar and we find another one, then we join them
			// together.
			// This happens for the following code fragment:
			//
			// int i = -1;
			// try { i = 0; for(; ; ) System.out.println(i); } catch(Exception x) {}
			// try { i = 0; for(; ; ) System.out.println(i); } catch(Exception x) {}
			// System.out.println(i);
			//
			if(l != null && local != null && l != local)
			{
				Debug.Assert(l.local == local.local);
				local.Link(l);
				l = null;
			}
			Debug.Assert(local == null || l == null || local == l);
d2344 17
a2360 2
				Debug.Assert(l.local == localIndex);
				local = l;
d2368 1
d2371 1
a2371 15
				ClassFile.Method.LocalVariableTableEntry[] lvt = method.LocalVariableTableAttribute;
				if(lvt != null)
				{
					int pc = method.Instructions[instructionIndex].PC;
					foreach(ClassFile.Method.LocalVariableTableEntry e in lvt)
					{
						if(e.index == localIndex && e.start_pc <= pc && e.start_pc + e.length >= pc)
						{
							local.name = e.name;
							local.start_pc = e.start_pc;
							local.end_pc = e.start_pc + e.length;
							break;
						}
					}
				}
d2377 1
d2383 25
a2407 1
			localByStoreSite[store + ":" + localIndex] = local;
d2409 10
d2555 10
@


1.22
log
@*** empty log message ***
@
text
@d27 1
d95 1
d100 1
a100 1
	private InstructionState(TypeWrapper[] stack, int stackSize, TypeWrapper[] locals, ArrayList subroutines, int callsites)
d105 1
d114 1
d119 1
a119 1
		return new InstructionState((TypeWrapper[])stack.Clone(), stackSize, (TypeWrapper[])locals.Clone(), CopySubroutines(subroutines), callsites);
d127 1
d135 1
a135 1
		return new InstructionState(new TypeWrapper[stack.Length], 0, (TypeWrapper[])locals.Clone(), CopySubroutines(subroutines), callsites);
d215 1
d240 1
a240 1
				TypeWrapper baseType = s.FindCommonBaseType(type, s2.stack[i]);
d269 2
d274 1
d279 1
d281 1
a281 1
			TypeWrapper baseType = s2.FindCommonBaseType(type, type2);
d287 6
d302 26
d389 1
a389 1
	internal TypeWrapper FindCommonBaseType(TypeWrapper type1, TypeWrapper type2)
d445 1
a445 1
				baseType = CoreClasses.java_lang_Object;
d457 1
a457 1
	private TypeWrapper FindCommonBaseTypeHelper(TypeWrapper t1, TypeWrapper t2)
d490 1
a490 1
				if (commonBase != CoreClasses.java_lang_Object)
d495 1
a495 1
			return CoreClasses.java_lang_Object;
d584 7
a590 1
	internal void GetLocalInt(int index)
d592 1
a592 1
		if(GetLocalType(index) != PrimitiveTypeWrapper.INT)
d598 1
a598 1
	internal void SetLocalInt(int index)
d600 1
d604 1
a604 1
	internal void GetLocalLong(int index)
d606 1
a606 1
		if(GetLocalType(index) != PrimitiveTypeWrapper.LONG)
d612 1
a612 1
	internal void SetLocalLong(int index)
d614 1
d618 1
a618 1
	internal void GetLocalFloat(int index)
d620 1
a620 1
		if(GetLocalType(index) != PrimitiveTypeWrapper.FLOAT)
d626 1
a626 1
	internal void SetLocalFloat(int index)
d628 1
d632 1
a632 1
	internal void GetLocalDouble(int index)
d634 1
a634 1
		if(GetLocalType(index) != PrimitiveTypeWrapper.DOUBLE)
d640 1
a640 1
	internal void SetLocalDouble(int index)
d642 1
d646 1
a646 1
	internal TypeWrapper GetLocalType(int index)
d650 8
d666 4
a669 1
	internal int GetLocalRet(int index)
d671 6
a676 1
		TypeWrapper type = GetLocalType(index);
d684 1
a684 1
	internal void SetLocalType(int index, TypeWrapper type)
d686 1
d869 1
a869 1
	internal void MarkInitialized(TypeWrapper type, TypeWrapper initType)
d877 1
d1066 44
d1124 2
a1125 2
	private TypeWrapper[] localTypes;
	private bool[] aload_used;
d1145 2
a1146 5
		localTypes = new TypeWrapper[method.MaxLocals];
		// HACK aload_used is used to track whether aload is ever used on a particular local (a very lame way of
		// trying to determine if a local that contains an exception, is ever used)
		// TODO we really need real liveness analyses for the locals
		aload_used = new Boolean[method.MaxLocals];
d1160 1
a1160 1
				state[0].SetLocalType(arg++, VerifierTypeWrapper.UninitializedThis);
d1164 1
a1164 1
				state[0].SetLocalType(arg++, wrapper);
d1178 1
a1178 1
				state[0].SetLocalType(arg++, type);
d1215 1
a1215 1
									ex.PushType(CoreClasses.java_lang_Throwable);
d1233 1
a1233 2
								aload_used[instr.NormalizedArg1] = true;
								TypeWrapper type = s.GetLocalType(instr.NormalizedArg1);
d1249 1
a1249 1
								s.SetLocalType(instr.NormalizedArg1, type);
d1446 1
a1446 1
										s.PushType(CoreClasses.java_lang_String);
d1453 1
a1453 1
										s.PushType(CoreClasses.java_lang_Class);
d1511 1
a1511 1
											s.MarkInitialized(type, wrapper);
d1515 1
a1515 1
											s.MarkInitialized(type, ((VerifierTypeWrapper)type).UnderlyingType);
d1556 1
a1556 1
								s.SetLocalInt(instr.NormalizedArg1);
d1559 1
a1559 1
								s.GetLocalInt(instr.NormalizedArg1);
d1895 1
a1895 1
								s.GetLocalFloat(instr.NormalizedArg1);
d1900 1
a1900 1
								s.SetLocalFloat(instr.NormalizedArg1);
d1903 1
a1903 1
								s.GetLocalDouble(instr.NormalizedArg1);
d1908 1
a1908 1
								s.SetLocalDouble(instr.NormalizedArg1);
d1911 1
a1911 1
								s.GetLocalLong(instr.NormalizedArg1);
d1916 1
a1916 1
								s.SetLocalLong(instr.NormalizedArg1);
d1957 1
a1957 1
								s.GetLocalInt(instr.Arg1);
d1960 1
a1960 1
								s.PopObjectType(CoreClasses.java_lang_Throwable);
d2032 1
a2032 1
								int subroutineIndex = s.GetLocalRet(instr.Arg1);
d2115 1
a2115 1
									int subroutineIndex = s.GetLocalRet(instr.Arg1);
a2144 31
						// HACK track the local types (but only for object references)
						for(int j = 0; j < localTypes.Length ; j++)
						{
							TypeWrapper l = s.GetLocalType(j);
							if(l != VerifierTypeWrapper.Invalid)
							{
								if(l == VerifierTypeWrapper.UninitializedThis)
								{
									localTypes[j] = wrapper;
								}
								else if(VerifierTypeWrapper.IsNew(l))
								{
									localTypes[j] = ((VerifierTypeWrapper)l).UnderlyingType;
								}
								else if(!VerifierTypeWrapper.IsRet(l) && !l.IsPrimitive)
								{
									if(!VerifierTypeWrapper.IsNullOrUnloadable(l) && l.IsNonPrimitiveValueType)
									{
										l = CoreClasses.java_lang_Object;
									}
									if(localTypes[j] == VerifierTypeWrapper.Invalid)
									{
										localTypes[j] = l;
									}
									else
									{
										localTypes[j] = s.FindCommonBaseType(localTypes[j], l);
									}
								}
							}
						}
d2175 185
a2359 1
		}		
d2482 1
a2482 1
		return state[index].GetLocalType(local);
d2485 2
a2486 1
	internal TypeWrapper GetDeclaredLocalTypeWrapper(int local)
d2488 1
a2488 1
		return localTypes[local];
d2491 1
a2491 1
	internal bool IsAloadUsed(int local)
d2493 2
a2494 1
		return aload_used[local];
@


1.21
log
@*** empty log message ***
@
text
@d403 1
a403 1
				baseType = MethodAnalyzer.java_lang_Object;
d448 1
a448 1
				if (commonBase != MethodAnalyzer.java_lang_Object)
d453 1
a453 1
			return MethodAnalyzer.java_lang_Object;
a997 3
	internal static TypeWrapper java_lang_Object;
	private static TypeWrapper java_lang_Throwable;
	private static TypeWrapper java_lang_String;
d1013 12
a1028 17
		lock(GetType())
		{
			if(java_lang_Throwable == null)
			{
				java_lang_Object = ClassLoaderWrapper.LoadClassCritical("java.lang.Object");
				java_lang_Throwable = ClassLoaderWrapper.LoadClassCritical("java.lang.Throwable");
				java_lang_String = ClassLoaderWrapper.LoadClassCritical("java.lang.String");
				ByteArrayType = PrimitiveTypeWrapper.BYTE.MakeArrayType(1);
				BooleanArrayType = PrimitiveTypeWrapper.BOOLEAN.MakeArrayType(1);
				ShortArrayType = PrimitiveTypeWrapper.SHORT.MakeArrayType(1);
				CharArrayType = PrimitiveTypeWrapper.CHAR.MakeArrayType(1);
				IntArrayType = PrimitiveTypeWrapper.INT.MakeArrayType(1);
				FloatArrayType = PrimitiveTypeWrapper.FLOAT.MakeArrayType(1);
				DoubleArrayType = PrimitiveTypeWrapper.DOUBLE.MakeArrayType(1);
				LongArrayType = PrimitiveTypeWrapper.LONG.MakeArrayType(1);
			}
		}
d1104 1
a1104 1
									ex.PushType(java_lang_Throwable);
d1336 8
a1343 1
										s.PushType(java_lang_String);
d1850 1
a1850 1
								s.PopObjectType(java_lang_Throwable);
d2053 1
a2053 1
										l = java_lang_Object;
@


1.20
log
@*** empty log message ***
@
text
@d958 1
a958 1
	public override Type TypeAsTBD
d966 1
a966 1
	public override TypeWrapper[] Interfaces
d974 1
a974 1
	public override TypeWrapper[] InnerClasses
d982 1
a982 1
	public override TypeWrapper DeclaringTypeWrapper
d990 1
a990 1
	public override void Finish()
d2080 1
a2080 4
						if(JVM.LogVerifyErrors)
						{
							Console.Error.WriteLine(x);
						}
@


1.19
log
@*** empty log message ***
@
text
@d948 1
a948 1
	protected override FieldWrapper GetFieldImpl(string fieldName)
@


1.18
log
@*** empty log message ***
@
text
@d245 1
a245 3
						Console.WriteLine("type = " + type);
						Console.WriteLine("s2.stack[i] = " + s2.stack[i]);
						throw new InvalidOperationException();
d802 2
a803 4
		if(type == null || initType == null)
		{
			throw new InvalidOperationException();
		}
d958 1
a958 1
	public override Type Type
@


1.17
log
@*** empty log message ***
@
text
@d412 1
a412 2
			// HACK load the array type
			return baseType.GetClassLoader().LoadClassByDottedName(new String('[', rank) + "L" + baseType.Name + ";");
d1028 11
a1038 11
				java_lang_Object = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Object");
				java_lang_Throwable = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Throwable");
				java_lang_String = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.String");
				ByteArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("[B");
				BooleanArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("[Z");
				ShortArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("[S");
				CharArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("[C");
				IntArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("[I");
				FloatArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("[F");
				DoubleArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("[D");
				LongArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("[J");
a1558 5
								string name = type.Name;
								if(name[0] != '[')
								{
									name = "L" + name + ";";
								}
d1561 5
d1570 1
a1570 1
									s.PushType(type.GetClassLoader().LoadClassByDottedName("[" + name));
@


1.16
log
@*** empty log message ***
@
text
@d1334 1
a1334 2
								object o = GetConstantPoolConstant(instr.Arg1);
								if(o is int)
d1336 19
a1354 21
									s.PushInt();
								}
								else if(o is string)
								{
									s.PushType(java_lang_String);
								}
								else if(o is long)
								{
									s.PushLong();
								}
								else if(o is float)
								{
									s.PushFloat();
								}
								else if(o is double)
								{
									s.PushDouble();
								}
								else
								{
									throw new InvalidOperationException(o.GetType().FullName);
d2146 1
a2146 1
	private object GetConstantPoolConstant(int index)
d2150 1
a2150 1
			return method.Method.ClassFile.GetConstantPoolConstant(index);
d2154 9
@


1.15
log
@*** empty log message ***
@
text
@d487 1
a487 1
			if(index > 0 && (locals[index - 1] == PrimitiveTypeWrapper.DOUBLE || locals[index - 1] == PrimitiveTypeWrapper.LONG))
d517 1
a517 1
			if(index > 0 && (locals[index - 1] == PrimitiveTypeWrapper.DOUBLE || locals[index - 1] == PrimitiveTypeWrapper.LONG))
d621 1
a621 1
		if(type == PrimitiveTypeWrapper.DOUBLE || type == PrimitiveTypeWrapper.LONG)
d633 1
a633 1
		if(type.IsPrimitive)
d635 1
a635 7
			if(type == PrimitiveTypeWrapper.BOOLEAN ||
				type == PrimitiveTypeWrapper.BYTE ||
				type == PrimitiveTypeWrapper.CHAR ||
				type == PrimitiveTypeWrapper.SHORT)
			{
				type = PrimitiveTypeWrapper.INT;
			}
d748 1
a748 1
		if(type == PrimitiveTypeWrapper.DOUBLE || type == PrimitiveTypeWrapper.LONG)
d760 1
a760 1
		if(baseType.IsPrimitive)
d762 1
a762 7
			if(baseType == PrimitiveTypeWrapper.BOOLEAN ||
				baseType == PrimitiveTypeWrapper.BYTE ||
				baseType == PrimitiveTypeWrapper.CHAR ||
				baseType == PrimitiveTypeWrapper.SHORT)
			{
				baseType = PrimitiveTypeWrapper.INT;
			}
d1076 1
a1076 5
				if(type.IsPrimitive &&
					(type == PrimitiveTypeWrapper.BOOLEAN ||
					type == PrimitiveTypeWrapper.BYTE ||
					type == PrimitiveTypeWrapper.CHAR ||
					type == PrimitiveTypeWrapper.SHORT))
d1081 1
a1081 1
				if(type == PrimitiveTypeWrapper.DOUBLE || type == PrimitiveTypeWrapper.LONG)
d1628 1
a1628 1
								if(t == PrimitiveTypeWrapper.DOUBLE || t == PrimitiveTypeWrapper.LONG)
d1655 1
a1655 1
								if(value1 == PrimitiveTypeWrapper.DOUBLE || value1 == PrimitiveTypeWrapper.LONG)
d1688 1
a1688 1
								if(value1 == PrimitiveTypeWrapper.DOUBLE || value1 == PrimitiveTypeWrapper.LONG)
d1691 1
a1691 1
									if(value2 == PrimitiveTypeWrapper.DOUBLE || value2 == PrimitiveTypeWrapper.LONG)
d1712 1
a1712 1
									if(value3 == PrimitiveTypeWrapper.DOUBLE || value3 == PrimitiveTypeWrapper.LONG)
d1741 1
a1741 1
								if(type != PrimitiveTypeWrapper.DOUBLE && type != PrimitiveTypeWrapper.LONG)
d1766 1
a1766 5
								if(retType != PrimitiveTypeWrapper.BOOLEAN &&
									retType != PrimitiveTypeWrapper.BYTE &&
									retType != PrimitiveTypeWrapper.CHAR &&
									retType != PrimitiveTypeWrapper.SHORT &&
									retType != PrimitiveTypeWrapper.INT)
@


1.14
log
@*** empty log message ***
@
text
@d438 2
a439 1
			// So strictly speaking, the code below isn't correct, but it works, so for now it stays in.
d448 8
d724 2
a725 2
		// is an interface, any reference will be accepted
		if(!baseType.IsUnloadable && !baseType.IsInterface && !(type.IsUnloadable || type.IsAssignableTo(baseType)))
d732 9
d777 4
d786 2
a787 2
			// is an interface, any reference will be accepted
			if(baseType.IsInterface && !type.IsPrimitive)
d1338 9
a1346 1
								s.PopObjectType(GetFieldref(instr.Arg1).GetClassType(classLoader));
@


1.13
log
@*** empty log message ***
@
text
@d383 4
d692 1
a692 1
		if(type != VerifierTypeWrapper.Null && type.ArrayRank == 0)
d716 1
a716 1
		if(!baseType.IsInterface && !type.IsAssignableTo(baseType))
d759 3
a761 1
		if(type != baseType && !type.IsAssignableTo(baseType))
d885 1
d915 5
d1162 4
d1187 1
a1187 1
								if(type != VerifierTypeWrapper.Null &&
d1201 1
a1201 1
								if(type != VerifierTypeWrapper.Null &&
d1405 1
a1405 2
										// for invokespecial we need to make sure we're calling ourself or a base class
										if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
d1408 1
a1408 1
											if(refType != VerifierTypeWrapper.Null && !wrapper.IsAssignableTo(refType))
d1410 9
a1418 1
												throw new VerifyError("Incompatible object argument for invokespecial");
d1421 1
a1421 1
										else
d2050 1
a2050 1
									if(l != VerifierTypeWrapper.Null && l.IsNonPrimitiveValueType)
@


1.12
log
@*** empty log message ***
@
text
@d780 4
@


1.11
log
@*** empty log message ***
@
text
@d409 1
a409 1
			return baseType.GetClassLoader().LoadClassBySlashedName(new String('[', rank) + "L" + baseType.Name + ";");
d430 2
a431 2
			// the common base of two interfaces is java/lang/Object, and there is special
			// treatment for java/lang/Object types that allow it to be assigned to any interface
d921 1
a921 1
		: base(Modifiers.Final | Modifiers.Interface, name, null, null)
a944 8
	public override bool IsInterface
	{
		get
		{
			throw new InvalidOperationException("get_IsInterface called on " + this);
		}
	}

d1003 11
a1013 11
				java_lang_Object = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/Object");
				java_lang_Throwable = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/Throwable");
				java_lang_String = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/String");
				ByteArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("[B");
				BooleanArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("[Z");
				ShortArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("[S");
				CharArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("[C");
				IntArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("[I");
				FloatArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("[F");
				DoubleArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("[D");
				LongArrayType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("[J");
d1533 1
a1533 1
									s.PushType(type.GetClassLoader().LoadClassBySlashedName("[" + name));
@


1.10
log
@*** empty log message ***
@
text
@d1393 16
a1408 4
										// NOTE previously we checked the type here, but it turns out that
										// the JVM throws an IncompatibleClassChangeError at runtime instead
										// of a VerifyError if this doesn't match
										s.PopObjectType();
@


1.9
log
@a few optimizations and a little clean up
@
text
@d401 1
a401 2
				// TODO cache java.lang.Object type somewhere
				baseType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/Object");
d420 4
d443 1
a443 2
			// TODO cache java.lang.Object type somewhere
			return ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/Object");
d985 1
d1011 1
d2019 4
@


1.8
log
@*** empty log message ***
@
text
@d91 3
a93 4
	private static ArrayList empty = new ArrayList();
	private MethodAnalyzer ma;
	private ArrayList stack;			// each entry contains a TypeWrapper object
	private TypeWrapper[] locals;		// each entry contains a TypeWrapper object
d98 1
a98 1
	private InstructionState(MethodAnalyzer ma, ArrayList stack, TypeWrapper[] locals, ArrayList subroutines, int callsites)
a99 1
		this.ma = ma;
d101 1
d107 1
a107 1
	internal InstructionState(MethodAnalyzer ma, int maxLocals)
d109 1
a109 2
		this.ma = ma;
		this.stack = new ArrayList();
a110 1
		this.subroutines = new ArrayList();
d115 11
a125 1
		return new InstructionState(ma, (ArrayList)stack.Clone(), (TypeWrapper[])locals.Clone(), CopySubroutines(subroutines), callsites);
d130 1
a130 1
		return new InstructionState(ma, new ArrayList(), (TypeWrapper[])locals.Clone(), CopySubroutines(subroutines), callsites);
d135 4
d154 1
a154 3
		ArrayList ss1 = subroutines;
		subroutines = new ArrayList();
		foreach(Subroutine ss2 in s2.subroutines)
d156 1
a156 1
			foreach(Subroutine ss in ss1)
d158 2
a159 12
				if(ss.SubroutineIndex == ss2.SubroutineIndex)
				{
					subroutines.Add(ss);
					for(int i = 0; i < ss.LocalsModified.Length; i++)
					{
						if(ss2.LocalsModified[i] && !ss.LocalsModified[i])
						{
							ss.LocalsModified[i] = true;
							changed = true;
						}
					}
				}
d162 1
a162 1
		if(ss1.Count != subroutines.Count)
d164 3
a166 8
			changed = true;
		}

		/*
		foreach(Subroutine ss2 in s2.subroutines)
		{
			bool found = false;
			foreach(Subroutine ss in subroutines)
d168 1
a168 1
				if(ss.SubroutineIndex == ss2.SubroutineIndex)
d170 1
a170 1
					for(int i = 0; i < ss.LocalsModified.Length; i++)
d172 2
a173 1
						if(ss2.LocalsModified[i] && !ss.LocalsModified[i])
d175 5
a179 2
							ss.LocalsModified[i] = true;
							changed = true;
a181 1
					found = true;
d184 1
a184 1
			if(!found)
a185 1
				subroutines.Add(ss2.Copy());
d189 1
a189 1
		*/
d219 1
a219 1
		if(s1.stack.Count != s2.stack.Count)
d221 1
a221 1
			throw new VerifyError(string.Format("Inconsistent stack height: {0} != {1}", s1.stack.Count, s2.stack.Count));
d225 1
a225 1
		for(int i = 0; i < s.stack.Count; i++)
d227 1
a227 1
			TypeWrapper type = (TypeWrapper)s.stack[i];
d234 1
a234 1
				TypeWrapper baseType = s.FindCommonBaseType(type, (TypeWrapper)s2.stack[i]);
d239 1
a239 1
					if(VerifierTypeWrapper.IsRet(type) && VerifierTypeWrapper.IsRet((TypeWrapper)s2.stack[i]))
d258 1
a258 1
				throw new VerifyError(string.Format("cannot merge {0} and {1}", type.Name, ((TypeWrapper)s2.stack[i]).Name));
d296 5
a300 1
		foreach(Subroutine s in subroutines)
d302 1
a302 1
			if(s.SubroutineIndex == subroutineIndex)
d304 5
a308 2
				// subroutines cannot recursivly call themselves
				throw new VerifyError("subroutines cannot recurse");
d316 1
a316 1
		foreach(Subroutine s in subroutines)
d318 1
a318 1
			if(s.SubroutineIndex == subroutineIndex)
d320 9
a328 6
				// TODO i'm not 100% sure about this, but I think we need to clear
				// the subroutines here (because when you return you can never "become" inside a subroutine)
				// UPDATE the above is incorrect, we only need to remove the subroutine we're actually
				// returning from
				subroutines.Remove(s);
				return s.LocalsModified;
d336 1
a336 1
		foreach(Subroutine s in subroutines)
d338 1
a338 1
			if(s.SubroutineIndex == subroutineIndex)
d340 4
a343 1
				return;
d475 1
a475 1
				foreach(Subroutine s in subroutines)
d477 4
a480 1
					s.SetLocalModified(index - 1);
d484 1
a484 1
			foreach(Subroutine s in subroutines)
d486 4
a489 1
				s.SetLocalModified(index);
d505 1
a505 1
				foreach(Subroutine s in subroutines)
d507 4
a510 1
					s.SetLocalModified(index - 1);
d515 1
a515 1
			foreach(Subroutine s in subroutines)
d517 5
a521 2
				s.SetLocalModified(index);
				s.SetLocalModified(index + 1);
d719 1
a719 1
		if(stack.Count == 0)
d723 1
a723 3
		TypeWrapper s = (TypeWrapper)stack[stack.Count - 1];
		stack.RemoveAt(stack.Count - 1);
		return s;
d768 1
a768 1
		return stack.Count;
d773 1
a773 1
		return (TypeWrapper)stack[stack.Count - 1 - pos];
d778 1
a778 1
		stack.Add(type);
d794 1
a794 1
		for(int i = 0; i < stack.Count; i++)
d820 1
a820 1
		for(int i = 0; i < stack.Count; i++)
d856 1
a856 1
		for(int i = 0; i < stack.Count; i++)
d858 1
a858 1
			TypeWrapper type = (TypeWrapper)stack[i];
d993 1
a993 1
	internal readonly ClassLoaderWrapper classLoader;
d1033 1
a1033 1
		state[0] = new InstructionState(this, method.MaxLocals);
d1069 1
d1111 1
a1111 1
						InstructionState s = state[i].Copy();
@


1.7
log
@*** empty log message ***
@
text
@d121 1
a121 1
	internal InstructionState CopyLocals()
d123 1
a123 1
		return new InstructionState(ma, new ArrayList(), (TypeWrapper[])locals.Clone(), new ArrayList(), callsites);
d143 26
d193 1
d241 12
a252 3
					Console.WriteLine("type = " + type);
					Console.WriteLine("s2.stack[i] = " + s2.stack[i]);
					throw new InvalidOperationException();
d319 3
a321 1
				subroutines.Clear();
d461 1
a461 1
		if(index > 0 && (locals[index - 1] == PrimitiveTypeWrapper.DOUBLE || locals[index - 1] == PrimitiveTypeWrapper.LONG))
d463 9
a471 1
			locals[index - 1] = VerifierTypeWrapper.Invalid;
d474 1
a474 1
				s.SetLocalModified(index - 1);
d477 1
a477 2
		locals[index] = type;
		foreach(Subroutine s in subroutines)
d479 1
a479 1
			s.SetLocalModified(index);
d485 1
a485 1
		if(index > 0 && (locals[index - 1] == PrimitiveTypeWrapper.DOUBLE || locals[index - 1] == PrimitiveTypeWrapper.LONG))
d487 10
a496 1
			locals[index - 1] = VerifierTypeWrapper.Invalid;
d499 2
a500 1
				s.SetLocalModified(index - 1);
d503 1
a503 3
		locals[index] = type;
		locals[index + 1] = VerifierTypeWrapper.Invalid;
		foreach(Subroutine s in subroutines)
d505 1
a505 2
			s.SetLocalModified(index);
			s.SetLocalModified(index + 1);
d563 8
a570 1
		return locals[index];
d1072 4
a1075 1
								InstructionState ex = state[i].CopyLocals();
d1099 1
a1099 1
								if(type.IsPrimitive || type == VerifierTypeWrapper.Invalid)
d2019 4
a2022 1
						Console.WriteLine(x);
@


1.6
log
@no message
@
text
@d881 16
@


1.5
log
@no message
@
text
@d1602 2
a1603 1
								// TODO is this allowed to be an uninitialized object?
@


1.4
log
@no message
@
text
@d93 2
a94 2
	private ArrayList stack;			// each entry contains a string with a Java signature of the type
	private string[] locals;			// each entry contains a string with a Java signature of the type
d99 1
a99 1
	private InstructionState(MethodAnalyzer ma, ArrayList stack, string[] locals, ArrayList subroutines, int callsites)
d112 1
a112 1
		this.locals = new string[maxLocals];
d118 1
a118 1
		return new InstructionState(ma, (ArrayList)stack.Clone(), (string[])locals.Clone(), CopySubroutines(subroutines), callsites);
d123 1
a123 1
		return new InstructionState(ma, new ArrayList(), (string[])locals.Clone(), new ArrayList(), callsites);
d204 2
a205 2
			string type = (string)s.stack[i];
			if(type == (string)s2.stack[i])
d209 1
a209 1
			else if(type[0] == 'L' || type[0] == '[' || type[0] == 'U' || type[0] == 'N')
d211 7
a217 1
				string baseType = s.FindCommonBaseType(type, (string)s2.stack[i]);
d226 1
a226 1
				throw new VerifyError(string.Format("cannot merge {0} and {1}", type, s2.stack[i]));
d231 2
a232 2
			string type = s.locals[i];
			string type2;
d241 2
a242 5
			if(type == type2)
			{
				// perfect match, nothing to do
			}
			else if(type != null)
d244 2
a245 15
				if(type[0] == 'L' || type[0] == '[')
				{
					string baseType = s2.FindCommonBaseType(type, type2);
					if(type != baseType)
					{
						s.locals[i] = baseType;
						s.changed = true;
					}
				}
				else
				{
					// mark the slot as invalid
					s.locals[i] = null;
					s.changed = true;
				}
d302 1
a302 1
	private bool IsSubType(string subType, string baseType)
d304 5
a308 1
		if(subType == baseType)
d310 5
a314 1
			return true;
d316 1
a316 1
		if(subType.Length == 1 || baseType.Length == 1)
d318 1
a318 2
			// primitives can never be subtypes of another type
			return false;
d320 1
a320 1
		if(baseType == "Ljava/lang/Object;")
d322 1
a322 1
			return true;
d324 1
a324 1
		if(baseType[0] == '[')
d326 18
a343 11
			if(subType[0] != '[')
			{
				return false;
			}
			int subDepth = 0;
			while(subType[subDepth] == '[')
			{
				subDepth++;
			}
			int baseDepth = 0;
			while(baseType[baseDepth] == '[')
d345 5
a349 1
				baseDepth++;
d351 2
a352 1
			if(baseDepth > subDepth)
d354 4
a357 9
				return false;
			}
			if(baseDepth < subDepth)
			{
				return baseType.EndsWith("[Ljava/lang/Object;");
			}
			if(subType[subDepth] == baseType[baseDepth])
			{
				if(subType[subDepth] != 'L')
d359 1
a359 11
					return baseDepth == subDepth;
				}
				string baseElemType = baseType.Substring(baseDepth + 1, baseType.Length - baseDepth - 2);
				if(baseElemType == "java/lang/Object")
				{
					return true;
				}
				if(baseDepth == subDepth)
				{
					string subElemType = subType.Substring(subDepth + 1, subType.Length - subDepth - 2);
					return ma.classLoader.IsSubType(subElemType, baseElemType);
d362 2
a363 5
			return false;
		}
		else if(subType[0] == '[')
		{
			return false;
d365 1
a365 1
		return ma.classLoader.IsSubType(subType.Substring(1, subType.Length - 2), baseType.Substring(1, baseType.Length - 2));
d368 1
a368 1
	internal string FindCommonBaseType(string type1, string type2)
d370 1
a370 2
//		Console.WriteLine("FindCommonBaseType: {0} v {1}", type1, type2);
		if(type1 == "Lnull")
d372 1
a372 1
			return type2;
d374 1
a374 1
		if(type2 == "Lnull")
d376 19
a394 5
			return type1;
		}
		if(type1 == type2)
		{
			return type1;
d396 3
a398 1
		if(type1 == null || type2 == null)
d400 2
a401 1
			return null;
d403 1
a403 1
		if(type1.Length == 1 || type2.Length == 1)
d405 2
a406 1
			return null;
d408 2
a409 1
		if(type1[0] == '[' || type2[0] == '[')
d411 3
a413 11
			int rank1 = 0;
			while(type1[rank1] == '[')
			{
				rank1++;
			}
			int rank2 = 0;
			while(type2[rank2] == '[')
			{
				rank2++;
			}
			if(rank1 == 0 || rank2 == 0)
d415 1
a415 1
				return "Ljava/lang/Object;";
d417 1
a417 30
			if(rank1 != rank2)
			{
				if(rank1 > rank2)
				{
					int temp = rank1;
					rank1 = rank2;
					rank2 = temp;
					string temps = type1;
					type1 = type2;
					type2 = temps;
				}
				if(type1.EndsWith("Ljava/lang/Object;"))
				{
					return type1;
				}
				return "Ljava/lang/Object;";
			}
			else
			{
				if(type1[rank1] != type2[rank1])
				{
					// two different primitive arrays, or a primitive and a reference array
					return "Ljava/lang/Object;";
				}
				return new String('[', rank1) + "L" + ma.classLoader.FindCommonBaseType(type1.Substring(1 + rank1, type1.Length - (2 + rank1)), type2.Substring(1 + rank2, type2.Length - (2 + rank2))) + ";";
			}
		}
		if(type1.StartsWith("Lret;") || type2.StartsWith("Lret;"))
		{
			return null;
a418 1
		return "L" + ma.classLoader.FindCommonBaseType(type1.Substring(1, type1.Length - 2), type2.Substring(1, type2.Length - 2)) + ";";
d421 1
a421 1
	private void SetLocal1(int index, string type)
d423 1
a423 1
		if(index > 0 && (locals[index] == "D2" || locals[index] == "J2"))
d425 5
a429 1
			locals[index - 1] = null;
d438 1
a438 1
	private void SetLocal2(int index, string type)
d440 1
a440 1
		if(index > 0 && (locals[index] == "D2" || locals[index] == "J2"))
d442 5
a446 1
			locals[index - 1] = null;
d449 1
a449 1
		locals[index + 1] = type[0] == 'D' ? "D2" : "J2";
d459 1
a459 1
		if(locals[index] != "I")
d467 1
a467 6
		SetLocal1(index, "I");
	}

	internal void SetLocalLong(int index)
	{
		SetLocal2(index, "J");
d472 1
a472 1
		if(locals[index] != "J" || locals[index + 1] != "J2")
d478 5
d485 1
a485 1
		if(locals[index] != "F")
d493 1
a493 6
		SetLocal1(index, "F");
	}

	internal void SetLocalDouble(int index)
	{
		SetLocal2(index, "D");
d498 1
a498 1
		if(locals[index] != "D" || locals[index + 1] != "D2")
d504 6
a509 1
	internal string GetLocalType(int index)
d516 2
a517 2
		string type = locals[index];
		if(!type.StartsWith("Lret;"))
d519 1
a519 1
			throw new VerifyError("incorrect local type, not ret");
d521 1
a521 1
		return int.Parse(type.Substring(5));
d524 1
a524 1
	internal string GetLocalObject(int index)
d526 1
a526 2
		string s = locals[index];
		if(s == null || (s[0] != 'L' && s[0] != '[' && s[0] != 'U' && s[0] != 'N') || s.StartsWith("Lret;"))
d528 1
a528 1
			throw new VerifyError("incorrect local type, not object");
d530 1
a530 6
		return s;
	}

	internal void SetLocalObject(int index, string type)
	{
		if(type[0] != 'L' && type[0] != '[' && type[0] != 'U' && type[0] != 'N')
d532 1
a532 1
			throw new VerifyError("SetLocalObject");
a533 1
		SetLocal1(index, type);
d536 1
a536 1
	internal void Push(string type)
d538 1
a538 1
		if(type.Length == 1)
d540 4
a543 1
			switch(type[0])
d545 1
a545 6
				case 'Z':
				case 'B':
				case 'C':
				case 'S':
					type = "I";
					break;
a550 14
	internal void PushObject(string type)
	{
		if(type == null)
		{
			throw new VerifyError("PushObject null");
		}
		if(type[0] == 'L' || type[0] == '[' || type[0] == 'U' || type[0] == 'N')
		{
			PushHelper(type);
			return;
		}
		throw new VerifyError("PushObject not object");
	}

d553 1
a553 1
		PushHelper("I");
d558 1
a558 1
		PushHelper("J");
d563 1
a563 1
		PushHelper("F");
d568 1
a568 1
		PushHelper("D");
d573 4
a576 1
		Pop('I');
d581 4
a584 1
		Pop('F');
d589 4
a592 1
		Pop('D');
d597 4
a600 1
		Pop('J');
d603 1
a603 1
	internal string PopArray()
d605 2
a606 2
		string s = PopHelper();
		if(s[0] == '[' || s == "Lnull")
d608 1
a608 1
			return s;
d610 1
a610 1
		throw new VerifyError("Array type expected");
d613 2
a614 1
	internal string PopUninitializedObject(string type)
d616 2
a617 3
		string s = PopHelper();
		string u = s;
		if(s[0] != 'U' && s[0] != 'N')
d619 1
a619 1
			throw new VerifyError("Expecting to find unitialized object on stack");
d621 1
a621 13
		s = s.Substring(s.IndexOf(';') + 1);
		if(s != type)
		{
			if(IsSubType(s, type))
			{
				// OK
			}
			else
			{
				throw new VerifyError(string.Format("popped {0} and expected {1}", s, type));
			}
		}
		return u;
d624 2
a625 1
	internal void Pop(string type)
d627 4
a630 14
		if(type.Length == 1)
		{
			switch(type[0])
			{
				case 'Z':
				case 'B':
				case 'C':
				case 'S':
					Pop('I');
					return;
			}
		}
		string s = PopHelper();
		if(s != type)
d632 1
a632 10
			if((type[0] == 'L' || type[0] == '[') && s == "Lnull")
			{
			}
			else if(IsSubType(s, type))
			{
			}
			else
			{
				throw new VerifyError(string.Format("popped {0} and expected {1}", s, type));
			}
d634 1
d637 1
a637 1
	internal string PopObject(string type)
d639 1
a639 2
		string s = PopHelper();
		if(s != type)
d641 1
a641 16
			if(s == "Lnull")
			{
				// null can be used as any type
			}
			else if(s[0] == 'N' || s[0] == 'U')
			{
				throw new VerifyError("Unexpected unitialized objref " + s);
			}
			else if(IsSubType(s, type))
			{
				// OK
			}
			else
			{
				throw new VerifyError(string.Format("popped {0} and expected {1}", s, type));
			}
d643 2
d648 2
a649 6
	internal string PopAny()
	{
		return PopHelper();
	}

	internal string Pop()
d651 2
a652 2
		string type = PopHelper();
		if(type == "D" || type == "J")
d659 4
a662 1
	internal string Pop2()
d664 1
a664 2
		string type = PopHelper();
		if(type == "D" || type == "J")
d666 7
a672 1
			return type;
d674 2
a675 2
		type = PopHelper();
		if(type == "D" || type == "J")
d677 7
a683 1
			throw new VerifyError("Attempt to split long or double on the stack");
d693 1
a693 16
	internal string GetStackSlot(int pos)
	{
		return (string)stack[stack.Count - 1 - pos];
	}

	internal string Peek()
	{
		if(stack.Count == 0)
		{
			// return null, if the stack is empty
			return null;
		}
		return (string)stack[stack.Count - 1];
	}

	private string PopHelper()
d695 1
a695 7
		if(stack.Count == 0)
		{
			throw new VerifyError("Unable to pop operand off an empty stack");
		}
		string s = (string)stack[stack.Count - 1];
		stack.RemoveAt(stack.Count - 1);
		return s;
d698 1
a698 1
	private void PushHelper(string s)
d700 1
a700 5
		if(s.IndexOf("L[") >= 0)
		{
			throw new VerifyError("Internal error: L[ type found");
		}
		stack.Add(s);
d703 1
a703 1
	private string Pop(char type)
d705 1
a705 2
		string s = PopHelper();
		if(s[0] != type)
d707 1
a707 17
			switch(type)
			{
				case 'I':
					throw new VerifyError("Expecting to find int on stack");
				case '[':
					throw new VerifyError("Expecting to find array on stack");
				case 'L':
					throw new VerifyError("Expecting to find object on stack");
				case 'F':
					throw new VerifyError("Expecting to find float on stack");
				case 'D':
					throw new VerifyError("Expecting to find double on stack");
				case 'J':
					throw new VerifyError("Expecting to find long on stack");
				default:
					throw new VerifyError("Expecting to find " + type + " on stack");
			}
a708 6
		return s;
	}

	internal void MarkInitialized(string type)
	{
		string initType = type.Substring(type.IndexOf(';') + 1);
d718 1
a718 1
			if((string)stack[i] == type)
d772 2
a773 1
			if(locals[i] != null && (((locals[i])[0] == 'U') || ((locals[i])[0] == 'N')))
d780 2
a781 1
			if((((string)stack[i])[0] == 'U') || (((string)stack[i])[0] == 'N'))
d787 1
d789 11
a799 2
	// this method ensures that no uninitialized objects, of the specified type are in the current state
	internal void CheckUninitializedObjRefs(string type)
d801 11
a811 14
		for(int i = 0; i < locals.Length; i++)
		{
			if(locals[i] == type)
			{
				throw new VerifyError("unininitialized " + type + " in locals");
			}
		}
		for(int i = 0; i < stack.Count; i++)
		{
			if((string)stack[i] == type)
			{
				throw new VerifyError("uninitialized " + type + " on stack");
			}
		}
a812 1
}
d814 4
a817 5
class SigEnumerator
{
	private string sig;
	private int pos;
	private int length;
d819 1
a819 1
	internal SigEnumerator(string sig)
d821 1
a821 3
		this.sig = sig;
		pos = 1;
		length = 0;
d824 1
a824 1
	internal bool MoveNext()
d826 1
a826 2
		pos += length;
		switch(sig[pos])
d828 1
a828 22
			case 'L':
			{
				length = sig.IndexOf(';', pos) - pos + 1;
				break;
			}
			case '[':
			{
				length = 0;
				while(sig[pos + length] == '[') length++;
				if(sig[pos + length] == 'L')
				{
					length = sig.IndexOf(';', pos) - pos;
				}
				length++;
				break;
			}
			case ')':
				length = 0;
				return false;
			default:
				length = 1;
				break;
a829 1
		return true;
d832 1
a832 1
	internal string Current
d836 1
a836 1
			return sig.Substring(pos, length);
a838 1
}
d840 16
a855 4
class ReverseSigEnumerator
{
	private string[] items;
	private int pos;
d857 1
a857 1
	internal ReverseSigEnumerator(string sig)
d859 1
a859 3
		ArrayList ar = new ArrayList();
		SigEnumerator se = new SigEnumerator(sig);
		while(se.MoveNext())
d861 1
a861 1
			ar.Add(se.Current);
a862 3
		items = new String[ar.Count];
		ar.CopyTo(items);
		pos = items.Length;
d865 1
a865 1
	internal bool MoveNext()
d867 4
a870 2
		pos--;
		return pos >= 0;
d873 1
a873 1
	internal string Current
d877 1
a877 1
			return items[pos];
d880 5
d889 10
d903 1
a903 1
	private string[] localTypes;
d906 1
a906 1
	internal MethodAnalyzer(ClassFile.Method.Code method, ClassLoaderWrapper classLoader)
d910 16
d928 1
a928 1
		localTypes = new String[method.MaxLocals];
d934 4
d946 1
a946 1
				state[0].SetLocalObject(arg++, "U0;L" + method.Method.ClassFile.Name + ";");
d950 1
a950 1
				state[0].SetLocalObject(arg++, "L" + method.Method.ClassFile.Name + ";");
d953 2
a954 2
		string sig = method.Method.Signature;
		for(int i = 1; sig[i] != ')'; i++)
d956 2
a957 1
			switch(sig[i])
d959 6
a964 9
				case 'D':
					state[0].SetLocalDouble(arg);
					arg += 2;
					break;
				case 'J':
					state[0].SetLocalLong(arg);
					arg += 2;
					break;
				case 'L':
d966 1
a966 4
					int pos = sig.IndexOf(';', i);
					state[0].SetLocalObject(arg++, sig.Substring(i, pos - i + 1));
					i = pos;
					break;
d968 2
a969 1
				case '[':
d971 1
a971 8
					int start = i;
					while(sig[i] == '[') i++;
					if(sig[i] == 'L')
					{
						i = sig.IndexOf(';', i);
					}
					state[0].SetLocalObject(arg++, sig.Substring(start, i - start + 1));
					break;
a972 12
				case 'F':
					state[0].SetLocalFloat(arg++);
					break;
				case 'Z':
				case 'B':
				case 'S':
				case 'C':
				case 'I':
					state[0].SetLocalInt(arg++);
					break;
				default:
					throw new NotImplementedException();
d1001 1
a1001 1
									ex.PushObject("Ljava/lang/Throwable;");
d1005 3
a1007 1
									ex.PushObject("L" + GetConstantPoolClass(catch_type) + ";");
d1018 1
d1020 6
a1025 1
								s.PushObject(s.GetLocalObject(instr.NormalizedArg1));
d1027 1
d1030 3
a1032 2
								string type = s.Pop();
								switch(type[0])
d1034 1
a1034 8
									case 'L':
									case '[':
									case 'N':
									case 'U':
										s.SetLocalObject(instr.NormalizedArg1, type);
										break;
									default:
										throw new VerifyError("Object reference expected");
d1036 1
d1040 1
a1040 1
								s.PushObject("Lnull");
d1045 2
a1046 2
								string type = s.PopArray();
								if(type == "Lnull")
d1050 1
a1050 1
									s.PushObject(type);
d1054 6
a1059 1
									s.PushObject(type.Substring(1));
d1064 1
a1064 2
							{
								string elem = s.PopObject("Ljava/lang/Object;");
d1066 1
a1066 1
								string type = s.PopArray();
a1068 1
							}
d1072 4
a1075 2
								string type = s.PopArray();
								if(type[1] != 'B' && type[1] != 'Z' && type != "Lnull")
d1086 4
a1089 2
								string type = s.PopArray();
								if(type[1] != 'B' && type[1] != 'Z' && type != "Lnull")
d1097 1
a1097 1
								s.PopObject("[C");
d1103 1
a1103 1
								s.PopObject("[C");
d1107 1
a1107 1
								s.PopObject("[S");
d1113 1
a1113 1
								s.PopObject("[S");
d1117 1
a1117 1
								s.PopObject("[I");
d1123 1
a1123 1
								s.PopObject("[I");
d1127 1
a1127 1
								s.PopObject("[J");
d1133 1
a1133 1
								s.PopObject("[J");
d1137 1
a1137 1
								s.PopObject("[D");
d1143 1
a1143 1
								s.PopObject("[D");
d1147 1
a1147 1
								s.PopObject("[F");
d1153 1
a1153 1
								s.PopObject("[F");
d1156 1
a1156 1
								s.PopArray();
d1182 1
a1182 1
								s.PopObject("Ljava/lang/Object;");
d1187 2
a1188 2
								s.PopObject("Ljava/lang/Object;");
								s.PopObject("Ljava/lang/Object;");
d1191 1
a1191 1
								s.Push((GetFieldref(instr.Arg1)).Signature);
d1194 1
a1194 13
							{
								// HACK because of the way interface merging works, if the
								// type on the stack is Object, it can be assigned to anything
								// (the compiler will emit a cast)
								string type = (GetFieldref(instr.Arg1)).Signature;
								if(type[0] == 'L' && s.Peek() == "Ljava/lang/Object;")
								{
									s.Pop();
								}
								else
								{
									s.Pop(type);
								}
a1195 1
							}
d1197 2
a1198 2
								s.PopObject("L" + (GetFieldref(instr.Arg1)).Class + ";");
								s.Push((GetFieldref(instr.Arg1)).Signature);
d1201 2
a1202 14
							{
								// HACK because of the way interface merging works, if the
								// type on the stack is Object, it can be assigned to anything
								// (the compiler will emit a cast)
								string type = (GetFieldref(instr.Arg1)).Signature;
								if(type[0] == 'L' && s.Peek() == "Ljava/lang/Object;")
								{
									s.Pop();
								}
								else
								{
									s.Pop(type);
								}
								s.PopObject("L" + (GetFieldref(instr.Arg1)).Class + ";");
a1203 1
							}
d1213 1
a1213 1
									s.PushObject("Ljava/lang/String;");
d1251 2
a1252 2
								ReverseSigEnumerator rse = new ReverseSigEnumerator(cpi.Signature);
								while(rse.MoveNext())
d1254 1
a1254 39
									switch(rse.Current[0])
									{
										case 'Z':
										case 'B':
										case 'S':
										case 'C':
										case 'I':
											s.PopInt();
											break;
										case 'J':
											s.PopLong();
											break;
										case 'D':
											s.PopDouble();
											break;
										case 'F':
											s.PopFloat();
											break;
										case 'L':
										{
											// HACK if the return type is an interface, any object is legal
											if(classLoader.RetTypeFromSig("()" + rse.Current).IsInterface)
											{
												// TODO implement support in the compiler for this condition (the code that
												// is currently generated works, but isn't verifiable)
												s.PopObject("Ljava/lang/Object;");
											}
											else
											{
												s.PopObject(rse.Current);
											}
											break;
										}
										case '[':
											s.PopObject(rse.Current);
											break;
										default:
											throw new NotImplementedException(rse.Current);
									}
d1263 1
d1266 4
a1269 3
										string type = s.PopUninitializedObject("L" + cpi.Class + ";");
										if((type[0] == 'N' && !type.EndsWith("L" + cpi.Class + ";")) ||
											(type[0] == 'U' && cpi.Class != method.Method.ClassFile.SuperClass && cpi.Class != method.Method.ClassFile.Name))
d1280 8
a1287 1
										s.MarkInitialized(type);
d1294 1
a1294 21
										s.PopObject("Ljava/lang/Object;");
										/*
										string type = cpi.Class;
										if(type[0] != '[')
										{
											type = "L" + type + ";";
										}
										// invokeinterface is allowed on java/lang/Object (because merging interfaces is
										// complicated), this will generate a runtime cast in the compiler
										if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface &&
											s.Peek() == "Ljava/lang/Object;")
										{
											s.PopAny();
										}
										else
										{
											// TODO if this fails it shouldn't generate a VerifyError, but instead
											// an IncompatibleClassChangeError (at run time)
											s.PopObject(type);
										}
										*/
d1297 2
a1298 2
								string ret = cpi.Signature.Substring(cpi.Signature.IndexOf(')') + 1);
								switch(ret[0])
d1300 1
a1300 24
									case 'Z':
									case 'B':
									case 'S':
									case 'C':
									case 'I':
										s.PushInt();
										break;
									case 'J':
										s.PushLong();
										break;
									case 'D':
										s.PushDouble();
										break;
									case 'F':
										s.PushFloat();
										break;
									case 'L':
									case '[':
										s.PushObject(ret);
										break;
									case 'V':
										break;
									default:
										throw new NotImplementedException(ret);
d1383 1
d1385 7
a1391 1
								s.PushObject(string.Format("N{0};L{1};", instr.PC, GetConstantPoolClass(instr.Arg1)));
d1393 1
d1404 2
a1405 2
								string type = GetConstantPoolClass(instr.Arg1);
								if(!type.StartsWith(new String('[', instr.Arg2)))
d1409 1
a1409 1
								s.PushObject(type);
d1415 11
a1425 2
								string type = GetConstantPoolClass(instr.Arg1);
								if(type[0] != '[')
d1427 1
a1427 1
									type = "L" + type + ";";
a1428 1
								s.PushObject("[" + type);
d1436 1
a1436 1
									s.PushObject("[Z");
d1439 1
a1439 1
									s.PushObject("[C");
d1442 1
a1442 1
									s.PushObject("[F");
d1445 1
a1445 1
									s.PushObject("[D");
d1448 1
a1448 1
									s.PushObject("[B");
d1451 1
a1451 1
									s.PushObject("[S");
d1454 1
a1454 1
									s.PushObject("[I");
d1457 1
a1457 1
									s.PushObject("[J");
d1465 4
a1468 4
								string t1 = s.Pop();
								string t2 = s.Pop();
								s.Push(t1);
								s.Push(t2);
d1473 3
a1475 3
								string t = s.Pop();
								s.Push(t);
								s.Push(t);
d1480 2
a1481 2
								string t = s.PopAny();
								if(t == "D" || t == "J")
d1483 2
a1484 2
									s.Push(t);
									s.Push(t);
d1488 5
a1492 5
									string t2 = s.Pop();
									s.Push(t2);
									s.Push(t);
									s.Push(t2);
									s.Push(t);
d1498 5
a1502 5
								string value1 = s.Pop();
								string value2 = s.Pop();
								s.Push(value1);
								s.Push(value2);
								s.Push(value1);
d1507 2
a1508 2
								string value1 = s.PopAny();
								if(value1 == "D" || value1 == "J")
d1510 4
a1513 4
									string value2 = s.Pop();
									s.Push(value1);
									s.Push(value2);
									s.Push(value1);
d1517 7
a1523 7
									string value2 = s.Pop();
									string value3 = s.Pop();
									s.Push(value2);
									s.Push(value1);
									s.Push(value3);
									s.Push(value2);
									s.Push(value1);
d1529 7
a1535 7
								string value1 = s.Pop();
								string value2 = s.Pop();
								string value3 = s.Pop();
								s.Push(value1);
								s.Push(value3);
								s.Push(value2);
								s.Push(value1);
d1540 2
a1541 2
								string value1 = s.PopAny();
								if(value1 == "D" || value1 == "J")
d1543 2
a1544 2
									string value2 = s.PopAny();
									if(value2 == "D" || value2 == "J")
d1547 3
a1549 3
										s.Push(value1);
										s.Push(value2);
										s.Push(value1);
d1554 5
a1558 5
										string value3 = s.Pop();
										s.Push(value1);
										s.Push(value3);
										s.Push(value2);
										s.Push(value1);
d1563 3
a1565 3
									string value2 = s.Pop();
									string value3 = s.PopAny();
									if(value3 == "D" || value3 == "J")
d1568 5
a1572 5
										s.Push(value2);
										s.Push(value1);
										s.Push(value3);
										s.Push(value2);
										s.Push(value1);
d1577 7
a1583 7
										string value4 = s.Pop();
										s.Push(value2);
										s.Push(value1);
										s.Push(value4);
										s.Push(value3);
										s.Push(value2);
										s.Push(value1);
d1589 1
a1589 1
								s.Pop();
d1592 6
a1597 1
								s.Pop2();
d1599 1
d1603 1
a1603 1
								s.PopObject("Ljava/lang/Object;");
d1606 1
a1606 1
								if(method.Method.Signature.Substring(method.Method.Signature.IndexOf(')') + 1) != "V")
d1612 1
a1612 10
							{
								// HACK if the return type is an interface, any object is legal
								if(classLoader.RetTypeFromSig(method.Method.Signature).IsInterface)
								{
									s.PopObject("Ljava/lang/Object;");
								}
								else
								{
									s.PopObject(method.Method.Signature.Substring(method.Method.Signature.IndexOf(')') + 1));
								}
a1613 1
							}
d1615 1
d1617 6
a1622 1
								switch(method.Method.Signature.Substring(method.Method.Signature.IndexOf(')') + 1))
d1624 1
a1624 8
									case "Z":
									case "B":
									case "S":
									case "C":
									case "I":
										break;
									default:
										throw new VerifyError("Wrong return type in function");
d1627 1
d1630 1
a1630 1
								if(method.Method.Signature.Substring(method.Method.Signature.IndexOf(')') + 1) != "J")
d1637 1
a1637 1
								if(method.Method.Signature.Substring(method.Method.Signature.IndexOf(')') + 1) != "F")
d1644 1
a1644 1
								if(method.Method.Signature.Substring(method.Method.Signature.IndexOf(')') + 1) != "D")
d1704 2
a1705 8
							{
								s.PopObject("Ljava/lang/Object;");
								string type = GetConstantPoolClass(instr.Arg1);
								if(type[0] != '[')
								{
									type = "L" + type + ";";
								}
								s.PushObject(type);
a1706 1
							}
d1708 1
a1708 1
								s.PopObject("Ljava/lang/Object;");
d1715 1
a1715 1
								s.PopObject("Ljava/lang/Throwable;");
a1852 1
									s.Push("Lret;" + index);
d1854 7
d1903 2
a1904 2
							string l = s.GetLocalType(j);
							if(l != null && (l[0] == 'U' || l[0] == 'N' || l[0] == 'L' || l[0] == '[') && !l.StartsWith("Lret;"))
d1906 1
a1906 1
								if(l[0] == 'U' || l[0] == 'N')
d1908 1
a1908 1
									l = l.Substring(l.IndexOf(';') + 1);
d1910 1
a1910 1
								if(localTypes[j] == null)
d1912 1
a1912 1
									localTypes[j] = l;
d1914 1
a1914 1
								else
d1916 8
a1923 1
									localTypes[j] = s.FindCommonBaseType(localTypes[j], l);
d1940 1
d2025 15
d2064 1
a2064 1
	internal string GetRawStackType(int index, int pos)
d2069 1
a2069 1
	internal string GetLocalType(int index, int local)
d2074 1
a2074 1
	internal string GetDeclaredLocalType(int local)
@


1.3
log
@no message
@
text
@d1012 1
d1021 4
d1127 1
d2241 5
@


1.2
log
@no message
@
text
@d241 1
a241 1
				if(type[0] == 'L' || type[0] == '[' || type[0] == 'U' || type[0] == 'N')
a879 12
	// this method ensures that no uninitialized object are in the locals for the current state
	internal void CheckLocalsForUninitializedObjRefs()
	{
		for(int i = 0; i < locals.Length; i++)
		{
			if(locals[i] != null && (((locals[i])[0] == 'U') || ((locals[i])[0] == 'N')))
			{
				throw new VerifyError("uninitialized object ref in local (1)");
			}
		}
	}

a1098 1
								state[i].CheckLocalsForUninitializedObjRefs();
@


1.1
log
@Initial revision
@
text
@d121 1
a121 1
	internal InstructionState CopyLocalsAndSubroutines()
d123 1
a123 1
		return new InstructionState(ma, new ArrayList(), (string[])locals.Clone(), CopySubroutines(subroutines), callsites);
d141 34
d190 4
d258 2
a259 1
		foreach(Subroutine ss2 in s2.subroutines)
d261 1
a261 27
			bool found = false;
			foreach(Subroutine ss in s.subroutines)
			{
				if(ss.SubroutineIndex == ss2.SubroutineIndex)
				{
					for(int i = 0; i < ss.LocalsModified.Length; i++)
					{
						if(ss2.LocalsModified[i] && !ss.LocalsModified[i])
						{
							ss.LocalsModified[i] = true;
							s.changed = true;
						}
					}
					found = true;
				}
			}
			if(!found)
			{
				s.subroutines.Add(ss2.Copy());
				s.changed = true;
			}
		}
		if(s2.callsites > s.callsites)
		{
			//Console.WriteLine("s2.callsites = {0}, s.callsites = {1}", s2.callsites, s.callsites);
			s.callsites = s2.callsites;
			s.changed = true;
d291 3
a293 1
				subroutines.Remove(s);
d297 1
a297 1
		throw new VerifyError();
d309 1
a309 1
		throw new VerifyError();
d347 4
d500 1
a500 1
			throw new VerifyError();
d508 1
a508 1
			throw new VerifyError();
d526 1
a526 1
			throw new VerifyError();
d540 1
a540 1
			throw new VerifyError();
d550 1
a550 1
			throw new VerifyError();
d559 1
a559 1
			throw new VerifyError();
d585 1
a585 1
			throw new VerifyError();
d592 1
a592 1
		throw new VerifyError();
d864 16
d887 1
a887 1
				throw new VerifyError();
d899 1
a899 1
				throw new VerifyError();
d906 1
a906 1
				throw new VerifyError();
d918 1
a918 1
				throw new VerifyError();
d925 1
a925 1
				throw new VerifyError();
d1112 5
a1116 1
								InstructionState ex = state[i].CopyLocalsAndSubroutines();
d1288 1
d1293 1
d1406 14
d1785 1
d1796 2
a1797 2
								// HACK we always allow object, because if the return type is an interface, this is legal
								if(s.Peek() == "Ljava/lang/Object;")
d1799 1
a1799 1
									s.Pop();
d1992 4
d2092 1
a2092 1
							throw new VerifyError("Invalid branch target");
d2127 12
d2143 1
a2143 9
		}
/*
		for(int i = 0; i < method.Instructions.Length; i++)
		{
			state[i].DumpLocals();
			state[i].DumpStack();
			Console.WriteLine("{0}: {1}", method.Instructions[i].PC, method.Instructions[i].OpCode.ToString());
		}
*/		
@


1.1.1.1
log
@no message
@
text
@@
