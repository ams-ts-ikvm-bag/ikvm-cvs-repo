head	1.74;
access;
symbols
	initial:1.1.1.1 ikvm:1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2004.05.27.07.12.14;	author jfrijters;	state dead;
branches;
next	1.73;

1.73
date	2004.05.14.09.31.55;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2004.04.23.14.21.43;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.02.08.13.13;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2004.03.29.10.11.33;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.26.10.19.21;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.20.13.25.08;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.16.17.10.10;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2004.03.08.15.18.47;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2004.03.04.13.07.38;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.04.12.50.39;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2004.02.10.17.16.35;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2004.02.10.09.53.56;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2004.02.02.09.46.13;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.30.15.27.53;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.28.11.28.16;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.17.22.46.43;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.11.13.14.42;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.24.11.51.41;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2003.12.19.22.19.18;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2003.11.17.12.01.51;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2003.10.22.16.34.22;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2003.10.17.08.08.31;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.10.14.58.19;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.04.09.51.16;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.29.10.14.08;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.26.11.24.17;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2003.08.21.10.06.35;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2003.08.13.15.00.42;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2003.08.12.13.09.31;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.08.12.37.14;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.05.14.07.22;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2003.08.01.12.12.08;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.31.12.49.29;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2003.07.24.07.29.51;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.21.12.13.13;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.07.14.18.27;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.02.14.50.35;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.20.13.47.13;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.18.08.48.00;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.13.15.13.20;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.10.13.28.48;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.03.08.40.08;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.30.12.09.00;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.12.20.00.15;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.12.16.49.57;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.12.15.20.42;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.12.15.04.21;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.10.15.34.49;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.10.11.43.12;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.26.12.13.02;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.14.09.41.58;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.28.14.33.47;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.21.13.41.43;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.17.14.04.27;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.03.10.58.24;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.27.16.41.50;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.22.12.28.12;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.20.14.18.39;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.18.09.31.19;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.15.16.19.44;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.15.11.18.53;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.15.09.29.00;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.12.12.28.04;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.17.14.36.09;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.07.14.53.17;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.06.14.01.57;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.02.15.44.17;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.02.13.47.58;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.29.16.28.16;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.27.09.09.02;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.19.11.07.03;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.18.16.57.09;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.18.16.01.22;	author jfrijters;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.12.18.16.01.22;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.74
log
@*** empty log message ***
@
text
@/*
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections;
using System.Reflection;
using System.Reflection.Emit;
using System.Diagnostics;
using OpenSystem.Java;

sealed class MethodDescriptor
{
	private ClassLoaderWrapper classLoader;
	private string name;
	private string sig;
	private Type[] args;
	private TypeWrapper[] argTypeWrappers;
	private TypeWrapper retTypeWrapper;

	internal MethodDescriptor(ClassLoaderWrapper classLoader, ClassFile.ConstantPoolItemFMI cpi)
		: this(classLoader, cpi.Name, cpi.Signature, cpi.GetArgTypes(classLoader), cpi.GetRetType(classLoader))
	{
	}

	internal MethodDescriptor(ClassLoaderWrapper classLoader, ClassFile.Method method)
		: this(classLoader, method.Name, method.Signature, method.GetArgTypes(classLoader), method.GetRetType(classLoader))
	{
	}

	internal MethodDescriptor(ClassLoaderWrapper classLoader, string name, string sig, TypeWrapper[] args, TypeWrapper ret)
	{
		Debug.Assert(classLoader != null);
		// class name in the sig should be dotted
		Debug.Assert(sig.IndexOf('/') < 0);

		if(name == null || sig == null)
		{
			throw new ArgumentNullException();
		}

		this.classLoader = classLoader;
		this.name = name;
		this.sig = sig;
		this.argTypeWrappers = args;
		this.retTypeWrapper = ret;
	}

	internal string Name
	{
		get
		{
			return name;
		}
	}

	internal string Signature
	{
		get
		{
			return sig;
		}
	}

	internal int ArgCount
	{
		get
		{
			return ArgTypeWrappers.Length;
		}
	}

	// NOTE this exposes potentially unfinished types!
	internal Type[] ArgTypesForDefineMethod
	{
		get
		{
			if(args == null)
			{
				TypeWrapper[] wrappers = ArgTypeWrappers;
				Type[] temp = new Type[wrappers.Length];
				for(int i = 0; i < wrappers.Length; i++)
				{
					temp[i] = wrappers[i].TypeAsParameterType;
				}
				args = temp;
			}
			return args;
		}
	}

	// NOTE this exposes potentially unfinished types!
	// HACK this should not be used and all existing uses should be reworked
	internal Type[] ArgTypesDontUse
	{
		get
		{
			return ArgTypesForDefineMethod;
		}
	}

	internal TypeWrapper[] ArgTypeWrappers
	{
		get
		{
			if(argTypeWrappers == null)
			{
				argTypeWrappers = classLoader.ArgTypeWrapperListFromSig(sig);
			}
			return argTypeWrappers;
		}
	}

	// NOTE this exposes a potentially unfinished type!
	internal Type RetTypeForDefineMethod
	{
		get
		{
			return RetTypeWrapper.TypeAsParameterType;
		}
	}

	internal TypeWrapper RetTypeWrapper
	{
		get
		{
			if(retTypeWrapper == null)
			{
				retTypeWrapper = classLoader.RetTypeWrapperFromSig(sig);
			}
			return retTypeWrapper;
		}
	}

	public override bool Equals(object o)
	{
		// TODO instead of comparing the signature strings, we should compare the actual types
		// (because, in the face of multiple class loaders, there can be multiple classes with the same name)
		MethodDescriptor md = o as MethodDescriptor;
		return md != null && md.name == name && md.sig == sig;
	}

	public override int GetHashCode()
	{
		return name.GetHashCode() ^ sig.GetHashCode();
	}

	private static void CrackSig(ParameterInfo param, out string name, out TypeWrapper typeWrapper)
	{
		Type type = param.ParameterType;
		if(type == typeof(object))
		{
			CrackSigFromCustomAttribute(param, out name, out typeWrapper);
		}
		else
		{
			if(type.IsByRef)
			{
				type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
				// TODO test type for unsupported types
			}
			name = TypeWrapper.GetSigNameFromType(type);
			typeWrapper = ClassLoaderWrapper.GetWrapperFromType(type);
		}
	}

	private static void CrackSig(MethodInfo method, out string name, out TypeWrapper typeWrapper)
	{
		Type type = method.ReturnType;
		if(type == typeof(object))
		{
			CrackSigFromCustomAttribute(method, out name, out typeWrapper);
		}
		else
		{
			name = TypeWrapper.GetSigNameFromType(type);
			typeWrapper = ClassLoaderWrapper.GetWrapperFromType(type);
		}
	}

	internal static string GetFieldSigName(FieldInfo field)
	{
		Type type = field.FieldType;
		if(type == typeof(object))
		{
			return GetSigNameFromCustomAttribute(field);
		}
		return TypeWrapper.GetSigNameFromType(type);
	}

	private static void CrackSigFromCustomAttribute(ICustomAttributeProvider provider, out string name, out TypeWrapper typeWrapper)
	{
		object[] attribs = provider.GetCustomAttributes(typeof(UnloadableTypeAttribute), false);
		if(attribs.Length == 1)
		{
			string s = ((UnloadableTypeAttribute)attribs[0]).Name;
			if(s.StartsWith("["))
			{
				name = s;
			}
			else
			{
				name = "L" + s + ";";
			}
			// TODO it might be loadable now, what do we do? I don't think we can try to load the type here,
			// because that will cause Java code to run and that isn't allowed while we're finishing (which we
			// might be doing when we get here).
			typeWrapper = new UnloadableTypeWrapper(s);
		}
		else
		{
			name = "Ljava.lang.Object;";
			typeWrapper = CoreClasses.java.lang.Object.Wrapper;
		}
	}

	private static string GetSigNameFromCustomAttribute(ICustomAttributeProvider provider)
	{
		object[] attribs = provider.GetCustomAttributes(typeof(UnloadableTypeAttribute), false);
		if(attribs.Length == 1)
		{
			string name = ((UnloadableTypeAttribute)attribs[0]).Name;
			if(name.StartsWith("["))
			{
				return name;
			}
			else
			{
				return "L" + name + ";";
			}
		}
		return "Ljava.lang.Object;";
	}

	// TODO ensure that FromMethodBase is only used on statically compiled Java types, and
	// remove support for ByRef
	internal static MethodDescriptor FromMethodBase(MethodBase mb)
	{
		System.Text.StringBuilder sb = new System.Text.StringBuilder();
		sb.Append('(');
		ParameterInfo[] parameters = mb.GetParameters();
		TypeWrapper[] args = new TypeWrapper[parameters.Length];
		for(int i = 0; i < parameters.Length; i++)
		{
			string name;
			CrackSig(parameters[i], out name, out args[i]);
			sb.Append(name);
		}
		sb.Append(')');
		if(mb is ConstructorInfo)
		{
			sb.Append('V');
			return new MethodDescriptor(ClassLoaderWrapper.GetClassLoader(mb.DeclaringType), mb.IsStatic ? "<clinit>" : "<init>", sb.ToString(), args, PrimitiveTypeWrapper.VOID);
		}
		else
		{
			string name;
			TypeWrapper ret;
			CrackSig((MethodInfo)mb, out name, out ret);
			sb.Append(name);
			return new MethodDescriptor(ClassLoaderWrapper.GetClassLoader(mb.DeclaringType), mb.Name, sb.ToString(), args, ret);
		}
	}

	internal static MethodDescriptor FromNameSig(ClassLoaderWrapper classLoader, string name, string sig)
	{
		// TODO why are we not resolving the signature here?
		return new MethodDescriptor(classLoader, name, sig, null, null);
	}
}

class EmitHelper
{
	private static MethodInfo objectToString = typeof(object).GetMethod("ToString");

	internal static void Throw(ILGenerator ilgen, string dottedClassName)
	{
		TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dottedClassName);
		MethodDescriptor md = MethodDescriptor.FromNameSig(exception.GetClassLoader(), "<init>", "()V");
		exception.GetMethodWrapper(md, false).EmitNewobj.Emit(ilgen);
		ilgen.Emit(OpCodes.Throw);
	}

	internal static void Throw(ILGenerator ilgen, string dottedClassName, string message)
	{
		TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dottedClassName);
		ilgen.Emit(OpCodes.Ldstr, message);
		MethodDescriptor md = MethodDescriptor.FromNameSig(exception.GetClassLoader(), "<init>", "(Ljava.lang.String;)V");
		exception.GetMethodWrapper(md, false).EmitNewobj.Emit(ilgen);
		ilgen.Emit(OpCodes.Throw);
	}

	internal static void RunClassConstructor(ILGenerator ilgen, Type type)
	{
		// NOTE we're *not* running the .cctor is the class is not a Java class
		// NOTE this is a potential versioning problem, if the base class lives in another assembly and doesn't
		// have a <clinit> now, a newer version that does have a <clinit> will not have it's <clinit> called by us.
		// A possible solution would be to use RuntimeHelpers.RunClassConstructor when "type" is a Java type and
		// lives in another assembly as the caller (which we don't know at the moment).
		FieldInfo field = type.GetField("__<clinit>");
		if(field != null)
		{
			ilgen.Emit(OpCodes.Ldsfld, field);
			ilgen.Emit(OpCodes.Pop);
		}
	}

	internal static void NullCheck(ILGenerator ilgen)
	{
		// I think this is the most efficient way to generate a NullReferenceException if the
		// reference is null
		ilgen.Emit(OpCodes.Ldvirtftn, objectToString);
		ilgen.Emit(OpCodes.Pop);
	}
}

class AttributeHelper
{
	private static CustomAttributeBuilder ghostInterfaceAttribute;
	private static CustomAttributeBuilder hideFromReflectionAttribute;
	private static CustomAttributeBuilder deprecatedAttribute;
	private static ConstructorInfo implementsAttribute;
	private static ConstructorInfo throwsAttribute;

	internal static void SetDeprecatedAttribute(MethodBase mb)
	{
		if(deprecatedAttribute == null)
		{
			deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
		}
		MethodBuilder method = mb as MethodBuilder;
		if(method != null)
		{
			method.SetCustomAttribute(deprecatedAttribute);
		}
		else
		{
			((ConstructorBuilder)mb).SetCustomAttribute(deprecatedAttribute);
		}
	}

	internal static void SetDeprecatedAttribute(TypeBuilder tb)
	{
		if(deprecatedAttribute == null)
		{
			deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
		}
		tb.SetCustomAttribute(deprecatedAttribute);
	}

	internal static void SetDeprecatedAttribute(FieldBuilder fb)
	{
		if(deprecatedAttribute == null)
		{
			deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
		}
		fb.SetCustomAttribute(deprecatedAttribute);
	}

	internal static void SetThrowsAttribute(MethodBase mb, string[] exceptions)
	{
		if(exceptions != null && exceptions.Length != 0)
		{
			if(throwsAttribute == null)
			{
				throwsAttribute = typeof(ThrowsAttribute).GetConstructor(new Type[] { typeof(string[]) });
			}
			if(mb is MethodBuilder)
			{
				MethodBuilder method = (MethodBuilder)mb;
				method.SetCustomAttribute(new CustomAttributeBuilder(throwsAttribute, new object[] { exceptions }));
			}
			else
			{
				ConstructorBuilder constructor = (ConstructorBuilder)mb;
				constructor.SetCustomAttribute(new CustomAttributeBuilder(throwsAttribute, new object[] { exceptions }));
			}
		}
	}

	internal static void SetGhostInterface(TypeBuilder typeBuilder)
	{
		if(ghostInterfaceAttribute == null)
		{
			ghostInterfaceAttribute = new CustomAttributeBuilder(typeof(GhostInterfaceAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
		}
		typeBuilder.SetCustomAttribute(ghostInterfaceAttribute);
	}

	internal static void HideFromReflection(TypeBuilder typeBuilder)
	{
		if(hideFromReflectionAttribute == null)
		{
			hideFromReflectionAttribute = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
		}
		typeBuilder.SetCustomAttribute(hideFromReflectionAttribute);
	}

	internal static void HideFromReflection(ConstructorBuilder cb)
	{
		if(hideFromReflectionAttribute == null)
		{
			hideFromReflectionAttribute = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
		}
		cb.SetCustomAttribute(hideFromReflectionAttribute);
	}

	internal static void HideFromReflection(MethodBuilder mb)
	{
		if(hideFromReflectionAttribute == null)
		{
			hideFromReflectionAttribute = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
		}
		mb.SetCustomAttribute(hideFromReflectionAttribute);
	}

	internal static void HideFromReflection(FieldBuilder fb)
	{
		if(hideFromReflectionAttribute == null)
		{
			hideFromReflectionAttribute = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
		}
		fb.SetCustomAttribute(hideFromReflectionAttribute);
	}

	internal static bool IsHideFromReflection(MemberInfo mi)
	{
		// NOTE all privatescope fields and methods are "hideFromReflection"
		// because Java cannot deal with the potential name clashes
		FieldInfo fi = mi as FieldInfo;
		if(fi != null && (fi.Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.PrivateScope)
		{
			return true;
		}
		MethodBase mb = mi as MethodBase;
		if(mb != null && (mb.Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.PrivateScope)
		{
			return true;
		}
		return mi.IsDefined(typeof(HideFromReflectionAttribute), false);
	}

	internal static void SetImplementsAttribute(TypeBuilder typeBuilder, TypeWrapper[] ifaceWrappers)
	{
		if(ifaceWrappers != null && ifaceWrappers.Length != 0)
		{
			string[] interfaces = new string[ifaceWrappers.Length];
			for(int i = 0; i < interfaces.Length; i++)
			{
				interfaces[i] = ifaceWrappers[i].Name;
			}
			if(implementsAttribute == null)
			{
				implementsAttribute = typeof(ImplementsAttribute).GetConstructor(new Type[] { typeof(string[]) });
			}
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(implementsAttribute, new object[] { interfaces }));
		}
	}

	internal static Modifiers GetModifiers(MethodBase mb, bool assemblyIsPrivate)
	{
		object[] customAttribute = mb.GetCustomAttributes(typeof(ModifiersAttribute), false);
		if(customAttribute.Length == 1)
		{
			return ((ModifiersAttribute)customAttribute[0]).Modifiers;
		}
		Modifiers modifiers = 0;
		if(mb.IsPublic)
		{
			modifiers |= Modifiers.Public;
		}
		else if(mb.IsPrivate)
		{
			modifiers |= Modifiers.Private;
		}
		else if(mb.IsFamily || mb.IsFamilyOrAssembly)
		{
			modifiers |= Modifiers.Protected;
		}
		else if(assemblyIsPrivate)
		{
			modifiers |= Modifiers.Private;
		}
		// NOTE Java doesn't support non-virtual methods, but we set the Final modifier for
		// non-virtual methods to approximate the semantics
		if((mb.IsFinal || !mb.IsVirtual) && !mb.IsStatic && !mb.IsConstructor)
		{
			modifiers |= Modifiers.Final;
		}
		if(mb.IsAbstract)
		{
			modifiers |= Modifiers.Abstract;
		}
		else
		{
			// Some .NET interfaces (like System._AppDomain) have synchronized methods,
			// Java doesn't allow synchronized on an abstract methods, so we ignore it for
			// abstract methods.
			if((mb.GetMethodImplementationFlags() & MethodImplAttributes.Synchronized) != 0)
			{
				modifiers |= Modifiers.Synchronized;
			}
		}
		if(mb.IsStatic)
		{
			modifiers |= Modifiers.Static;
		}
		if((mb.Attributes & MethodAttributes.PinvokeImpl) != 0)
		{
			modifiers |= Modifiers.Native;
		}
		return modifiers;
	}

	internal static Modifiers GetModifiers(FieldInfo fi, bool assemblyIsPrivate)
	{
		object[] customAttribute = fi.GetCustomAttributes(typeof(ModifiersAttribute), false);
		if(customAttribute.Length == 1)
		{
			return ((ModifiersAttribute)customAttribute[0]).Modifiers;
		}
		Modifiers modifiers = 0;
		if(fi.IsPublic)
		{
			modifiers |= Modifiers.Public;
		}
		else if(fi.IsPrivate)
		{
			modifiers |= Modifiers.Private;
		}
		else if(fi.IsFamily || fi.IsFamilyOrAssembly)
		{
			modifiers |= Modifiers.Protected;
		}
		else if(assemblyIsPrivate)
		{
			modifiers |= Modifiers.Private;
		}
		if(fi.IsInitOnly || fi.IsLiteral)
		{
			modifiers |= Modifiers.Final;
		}
		if(fi.IsNotSerialized)
		{
			modifiers |= Modifiers.Transient;
		}
		if(fi.IsStatic)
		{
			modifiers |= Modifiers.Static;
		}
		// TODO reflection doesn't support volatile
		return modifiers;
	}

	internal static void SetModifiers(MethodBuilder mb, Modifiers modifiers)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
		mb.SetCustomAttribute(customAttributeBuilder);
	}

	internal static void SetModifiers(ConstructorBuilder cb, Modifiers modifiers)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
		cb.SetCustomAttribute(customAttributeBuilder);
	}

	internal static void SetModifiers(FieldBuilder fb, Modifiers modifiers)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
		fb.SetCustomAttribute(customAttributeBuilder);
	}

	internal static void SetModifiers(TypeBuilder tb, Modifiers modifiers)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
		tb.SetCustomAttribute(customAttributeBuilder);
	}

	internal static byte[] FreezeDryType(Type type)
	{
		System.IO.MemoryStream mem = new System.IO.MemoryStream();
		System.IO.BinaryWriter bw = new System.IO.BinaryWriter(mem, System.Text.UTF8Encoding.UTF8);
		bw.Write((short)1);
		bw.Write(type.FullName);
		bw.Write((short)0);
		return mem.ToArray();
	}

	internal static void SetUnloadableType(FieldBuilder field, string name)
	{
		CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { name });
		field.SetCustomAttribute(attrib);
	}

	internal static void SetInnerClass(TypeBuilder typeBuilder, string innerClass, string outerClass, string name, Modifiers modifiers)
	{
		Type[] argTypes = new Type[] { typeof(string), typeof(string), typeof(string), typeof(Modifiers) };
		object[] args = new object[] { innerClass, outerClass, name, modifiers };
		ConstructorInfo ci = typeof(InnerClassAttribute).GetConstructor(argTypes);
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ci, args);
		typeBuilder.SetCustomAttribute(customAttributeBuilder);
	}
}

abstract class TypeWrapper
{
	private readonly ClassLoaderWrapper classLoader;
	private readonly string name;		// java name (e.g. java.lang.Object)
	private readonly Modifiers modifiers;
	private readonly Hashtable methods = new Hashtable();
	private readonly Hashtable fields = new Hashtable();
	private readonly TypeWrapper baseWrapper;
	private bool hasIncompleteInterfaceImplementation;
	internal static readonly TypeWrapper[] EmptyArray = new TypeWrapper[0];
	internal const Modifiers UnloadableModifiersHack = Modifiers.Final | Modifiers.Interface | Modifiers.Private;
	internal const Modifiers VerifierTypeModifiersHack = Modifiers.Final | Modifiers.Interface;

	internal TypeWrapper(Modifiers modifiers, string name, TypeWrapper baseWrapper, ClassLoaderWrapper classLoader)
	{
		Profiler.Count("TypeWrapper");
		// class name should be dotted or null for primitives
		Debug.Assert(name == null || name.IndexOf('/') < 0);

		this.modifiers = modifiers;
		this.name = name;
		this.baseWrapper = baseWrapper;
		this.classLoader = classLoader;
	}

	public override string ToString()
	{
		return GetType().Name + "[" + name + "]";
	}

	internal bool HasIncompleteInterfaceImplementation
	{
		get
		{
			return hasIncompleteInterfaceImplementation || (baseWrapper != null && baseWrapper.HasIncompleteInterfaceImplementation);
		}
		set
		{
			hasIncompleteInterfaceImplementation = value;
		}
	}

	// a ghost is an interface that appears to be implemented by a .NET type
	// (e.g. System.String (aka java.lang.String) appears to implement java.lang.CharSequence,
	// so java.lang.CharSequence is a ghost)
	internal virtual bool IsGhost
	{
		get
		{
			return false;
		}
	}

	// is this an array type of which the ultimate element type is a ghost?
	internal bool IsGhostArray
	{
		get
		{
			return IsArray && (ElementTypeWrapper.IsGhost || ElementTypeWrapper.IsGhostArray);
		}
	}

	internal virtual FieldInfo GhostRefField
	{
		get
		{
			throw new InvalidOperationException();
		}
	}

	internal virtual bool IsRemapped
	{
		get
		{
			return false;
		}
	}

	internal bool IsArray
	{
		get
		{
			return name != null && name[0] == '[';
		}
	}

	// NOTE for non-array types this returns 0
	internal int ArrayRank
	{
		get
		{
			int i = 0;
			if(name != null)
			{
				while(name[i] == '[')
				{
					i++;
				}
			}
			return i;
		}
	}

	internal bool IsNonPrimitiveValueType
	{
		get
		{
			return this != VerifierTypeWrapper.Null && !IsPrimitive && !IsGhost && TypeAsTBD.IsValueType;
		}
	}

	internal bool IsPrimitive
	{
		get
		{
			return name == null;
		}
	}

	internal bool IsWidePrimitive
	{
		get
		{
			return this == PrimitiveTypeWrapper.LONG || this == PrimitiveTypeWrapper.DOUBLE;
		}
	}

	internal bool IsIntOnStackPrimitive
	{
		get
		{
			return name == null &&
				(this == PrimitiveTypeWrapper.BOOLEAN ||
				this == PrimitiveTypeWrapper.BYTE ||
				this == PrimitiveTypeWrapper.CHAR ||
				this == PrimitiveTypeWrapper.SHORT ||
				this == PrimitiveTypeWrapper.INT);
		}
	}

	internal bool IsUnloadable
	{
		get
		{
			// NOTE we abuse modifiers to note unloadable classes
			return modifiers == UnloadableModifiersHack;
		}
	}

	internal bool IsVerifierType
	{
		get
		{
			// NOTE we abuse modifiers to note verifier types
			return modifiers == VerifierTypeModifiersHack;
		}
	}

	internal virtual bool IsMapUnsafeException
	{
		get
		{
			return false;
		}
	}

	// TODO since for inner classes, the modifiers returned by Class.getModifiers are different from the actual
	// modifiers (as used by the VM access control mechanism), we need an additional property (e.g. InnerClassModifiers)
	internal Modifiers Modifiers
	{
		get
		{
			return modifiers;
		}
	}

	// since for inner classes, the modifiers returned by Class.getModifiers are different from the actual
	// modifiers (as used by the VM access control mechanism), we have this additional property
	// NOTE this property can only be called for finished types!
	internal virtual Modifiers ReflectiveModifiers
	{
		get
		{
			return modifiers;
		}
	}

	internal bool IsPublic
	{
		get
		{
			return (modifiers & Modifiers.Public) != 0;
		}
	}

	internal bool IsAbstract
	{
		get
		{
			return (modifiers & Modifiers.Abstract) != 0;
		}
	}

	internal bool IsFinal
	{
		get
		{
			return (modifiers & Modifiers.Final) != 0;
		}
	}

	internal bool IsInterface
	{
		get
		{
			Debug.Assert(!IsUnloadable && !IsVerifierType);
			return (modifiers & Modifiers.Interface) != 0;
		}
	}

	// this exists because interfaces and arrays of interfaces are treated specially
	// by the verifier, interfaces don't have a common base (other than java.lang.Object)
	// so any object reference or object array reference can be used where an interface
	// or interface array reference is expected (the compiler will insert the required casts).
	internal bool IsInterfaceOrInterfaceArray
	{
		get
		{
			TypeWrapper tw = this;
			while(tw.IsArray)
			{
				tw = tw.ElementTypeWrapper;
			}
			return tw.IsInterface;
		}
	}

	internal virtual ClassLoaderWrapper GetClassLoader()
	{
		return classLoader;
	}

	protected abstract FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType);

	internal FieldWrapper GetFieldWrapper(string fieldName, TypeWrapper fieldType)
	{
		string key = fieldName + fieldType.SigName;
		FieldWrapper fae = (FieldWrapper)fields[key];
		if(fae == null)
		{
			fae = GetFieldImpl(fieldName, fieldType);
			if(fae == null)
			{
				foreach(TypeWrapper iface in this.Interfaces)
				{
					fae = iface.GetFieldWrapper(fieldName, fieldType);
					if(fae != null)
					{
						return fae;
					}
				}
				if(baseWrapper != null)
				{
					return baseWrapper.GetFieldWrapper(fieldName, fieldType);
				}
				return null;
			}
			fields[key] = fae;
		}
		return fae;
	}

	// TODO figure out when it is safe to call this
	// HACK for now we assume that the method hashtable has always been filled when this method is called (by java.lang.Class)
	internal virtual MethodWrapper[] GetMethods()
	{
		MethodWrapper[] wrappers = new MethodWrapper[methods.Count];
		methods.Values.CopyTo(wrappers, 0);
		return wrappers;
	}

	// TODO figure out when it is safe to call this
	// HACK for now we assume that the fields hashtable has always been filled when this method is called (by java.lang.Class)
	internal virtual FieldWrapper[] GetFields()
	{
		FieldWrapper[] wrappers = new FieldWrapper[fields.Count];
		fields.Values.CopyTo(wrappers, 0);
		return wrappers;
	}

	protected abstract MethodWrapper GetMethodImpl(MethodDescriptor md);

	internal MethodWrapper GetMethodWrapper(MethodDescriptor md, bool inherit)
	{
		MethodWrapper mce = (MethodWrapper)methods[md];
		if(mce == null)
		{
			mce = GetMethodImpl(md);
			if(mce == null)
			{
				if(inherit && baseWrapper != null)
				{
					return baseWrapper.GetMethodWrapper(md, inherit);
				}
				return null;
			}
			methods[md] = mce;
		}
		return mce;
	}

	internal void AddMethod(MethodWrapper method)
	{
		Debug.Assert(method != null);
		methods[method.Descriptor] = method;
	}

	internal void AddField(FieldWrapper field)
	{
		Debug.Assert(field != null);
		fields[field.Name + field.FieldTypeWrapper.SigName] = field;
	}

	internal string Name
	{
		get
		{
			return name;
		}
	}

	// the name of the type as it appears in a Java signature string (e.g. "Ljava.lang.Object;" or "I")
	internal virtual string SigName
	{
		get
		{
			return "L" + this.Name + ";";
		}
	}

	internal string PackageName
	{
		get
		{
			int index = name.LastIndexOf('.');
			if(index == -1)
			{
				return "";
			}
			return name.Substring(0, index);
		}
	}

	// returns true iff wrapper is allowed to access us
	internal bool IsAccessibleFrom(TypeWrapper wrapper)
	{
		return IsPublic || IsInSamePackageAs(wrapper);
	}

	internal bool IsInSamePackageAs(TypeWrapper wrapper)
	{
		if(GetClassLoader() == wrapper.GetClassLoader())
		{
			int index1 = name.LastIndexOf('.');
			int index2 = wrapper.name.LastIndexOf('.');
			if(index1 == -1 && index2 == -1)
			{
				return true;
			}
			// for array types we need to skip the brackets
			int skip1 = 0;
			int skip2 = 0;
			while(name[skip1] == '[')
			{
				skip1++;
			}
			while(wrapper.name[skip2] == '[')
			{
				skip2++;
			}
			if(skip1 > 0)
			{
				// skip over the L that follows the brackets
				skip1++;
			}
			if(skip2 > 0)
			{
				// skip over the L that follows the brackets
				skip2++;
			}
			if((index1 - skip1) != (index2 - skip2))
			{
				return false;
			}
			return String.CompareOrdinal(name, skip1, wrapper.name, skip2, index1 - skip1) == 0;
		}
		return false;
	}

	internal abstract Type TypeAsTBD
	{
		get;
	}

	internal virtual TypeBuilder TypeAsBuilder
	{
		get
		{
			TypeBuilder typeBuilder = TypeAsTBD as TypeBuilder;
			Debug.Assert(typeBuilder != null);
			return typeBuilder;
		}
	}

	internal Type TypeAsFieldType
	{
		get
		{
			return TypeAsParameterType;
		}
	}

	internal Type TypeAsParameterType
	{
		get
		{
			if(IsUnloadable)
			{
				return typeof(object);
			}
			if(IsGhostArray)
			{
				int rank = ArrayRank;
				string type = "System.Object";
				for(int i = 0; i < rank; i++)
				{
					type += "[]";
				}
				return Type.GetType(type, true);
			}
			return TypeAsTBD;
		}
	}

	internal virtual Type TypeAsBaseType
	{
		get
		{
			return TypeAsTBD;
		}
	}

	internal Type TypeAsLocalOrStackType
	{
		get
		{
			// HACK as a convenience to the compiler, we replace return address types with typeof(int)
			if(VerifierTypeWrapper.IsRet(this))
			{
				return typeof(int);
			}
			if(IsUnloadable || IsGhost || IsNonPrimitiveValueType)
			{
				return typeof(object);
			}
			if(IsGhostArray)
			{
				int rank = ArrayRank;
				string type = "System.Object";
				for(int i = 0; i < rank; i++)
				{
					type += "[]";
				}
				return Type.GetType(type, true);
			}
			return TypeAsTBD;
		}
	}

	/** <summary>Use this if the type is used as an array or array element</summary> */
	internal Type TypeAsArrayType
	{
		get
		{
			if(IsUnloadable || IsGhost)
			{
				return typeof(object);
			}
			if(IsGhostArray)
			{
				int rank = ArrayRank;
				string type = "System.Object";
				for(int i = 0; i < rank; i++)
				{
					type += "[]";
				}
				return Type.GetType(type, true);
			}
			return TypeAsTBD;
		}
	}

	internal Type TypeAsExceptionType
	{
		get
		{
			if(IsUnloadable)
			{
				return typeof(Exception);
			}
			return TypeAsTBD;
		}
	}

	internal TypeWrapper BaseTypeWrapper
	{
		get
		{
			return baseWrapper;
		}
	}

	internal TypeWrapper ElementTypeWrapper
	{
		get
		{
			Debug.Assert(!this.IsUnloadable);
			Debug.Assert(this == VerifierTypeWrapper.Null || this.IsArray);

			if(this == VerifierTypeWrapper.Null)
			{
				return VerifierTypeWrapper.Null;
			}

			// TODO consider caching the element type
			switch(name[1])
			{
				case '[':
					// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
					// (because the ultimate element type was already loaded when this type was created)
					return classLoader.LoadClassByDottedNameFast(name.Substring(1));
				case 'L':
					// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
					// (because the ultimate element type was already loaded when this type was created)
					return classLoader.LoadClassByDottedNameFast(name.Substring(2, name.Length - 3));
				case 'Z':
					return PrimitiveTypeWrapper.BOOLEAN;
				case 'B':
					return PrimitiveTypeWrapper.BYTE;
				case 'S':
					return PrimitiveTypeWrapper.SHORT;
				case 'C':
					return PrimitiveTypeWrapper.CHAR;
				case 'I':
					return PrimitiveTypeWrapper.INT;
				case 'J':
					return PrimitiveTypeWrapper.LONG;
				case 'F':
					return PrimitiveTypeWrapper.FLOAT;
				case 'D':
					return PrimitiveTypeWrapper.DOUBLE;
				default:
					throw new InvalidOperationException(name);
			}
		}
	}

	internal TypeWrapper MakeArrayType(int rank)
	{
		// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
		return GetClassLoader().LoadClassByDottedNameFast(new String('[', rank) + this.SigName);
	}

	internal bool ImplementsInterface(TypeWrapper interfaceWrapper)
	{
		TypeWrapper typeWrapper = this;
		while(typeWrapper != null)
		{
			TypeWrapper[] interfaces = typeWrapper.Interfaces;
			for(int i = 0; i < interfaces.Length; i++)
			{
				if(interfaces[i] == interfaceWrapper)
				{
					return true;
				}
				if(interfaces[i].ImplementsInterface(interfaceWrapper))
				{
					return true;
				}
			}
			typeWrapper = typeWrapper.BaseTypeWrapper;
		}
		return false;
	}

	internal bool IsSubTypeOf(TypeWrapper baseType)
	{
		// make sure IsSubTypeOf isn't used on primitives
		Debug.Assert(!this.IsPrimitive);
		Debug.Assert(!baseType.IsPrimitive);
		// can't be used on Unloadable
		Debug.Assert(!this.IsUnloadable);
		Debug.Assert(!baseType.IsUnloadable);

		if(baseType.IsInterface)
		{
			if(baseType == this)
			{
				return true;
			}
			return ImplementsInterface(baseType);
		}
		// NOTE this isn't just an optimization, it is also required when this is an interface
		if(baseType == CoreClasses.java.lang.Object.Wrapper)
		{
			return true;
		}
		TypeWrapper subType = this;
		while(subType != baseType)
		{
			subType = subType.BaseTypeWrapper;
			if(subType == null)
			{
				return false;
			}
		}
		return true;
	}

	internal bool IsAssignableTo(TypeWrapper wrapper)
	{
		if(this == wrapper)
		{
			return true;
		}
		if(this.IsPrimitive || wrapper.IsPrimitive)
		{
			return false;
		}
		if(this == VerifierTypeWrapper.Null)
		{
			return true;
		}
		if(wrapper.IsInterface)
		{
			return ImplementsInterface(wrapper);
		}
		int rank1 = this.ArrayRank;
		int rank2 = wrapper.ArrayRank;
		if(rank1 > 0 && rank2 > 0)
		{
			rank1--;
			rank2--;
			TypeWrapper elem1 = this.ElementTypeWrapper;
			TypeWrapper elem2 = wrapper.ElementTypeWrapper;
			while(rank1 != 0 && rank2 != 0)
			{
				elem1 = elem1.ElementTypeWrapper;
				elem2 = elem2.ElementTypeWrapper;
				rank1--;
				rank2--;
			}
			return !elem1.IsNonPrimitiveValueType && elem1.IsSubTypeOf(elem2);
		}
		return this.IsSubTypeOf(wrapper);
	}

	internal abstract TypeWrapper[] Interfaces
	{
		get;
	}

	// NOTE this property can only be called for finished types!
	internal abstract TypeWrapper[] InnerClasses
	{
		get;
	}

	// NOTE this property can only be called for finished types!
	internal abstract TypeWrapper DeclaringTypeWrapper
	{
		get;
	}

	internal abstract void Finish();

	private void ImplementInterfaceMethodStubImpl(MethodDescriptor md, MethodBase ifmethod, TypeBuilder typeBuilder, DynamicTypeWrapper wrapper)
	{
		// we're mangling the name to prevent subclasses from accidentally overriding this method
		string mangledName = this.Name + "/" + ifmethod.Name;
		MethodWrapper mce = wrapper.GetMethodWrapper(md, true);
		if(mce != null && mce.HasUnloadableArgsOrRet)
		{
			// TODO for now we make it seem as if the method isn't there, we should be emitting
			// a stub that throws a NoClassDefFoundError
			// NOTE AFAICT this can only happen when code explicitly messes around with the custom class loaders
			// that violate the class loader rules.
			mce = null;
		}
		if(mce != null)
		{
			if(!mce.IsPublic)
			{
				// NOTE according to the ECMA spec it isn't legal for a privatescope method to be virtual, but this works and
				// it makes sense, so I hope the spec is wrong
				// UPDATE unfortunately, according to Serge Lidin the spec is correct, and it is not allowed to have virtual privatescope
				// methods. Sigh! So I have to use private methods and mangle the name
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				AttributeHelper.HideFromReflection(mb);
				EmitHelper.Throw(mb.GetILGenerator(), "java.lang.IllegalAccessError", wrapper.Name + "." + md.Name + md.Signature);
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
				wrapper.HasIncompleteInterfaceImplementation = true;
			}
			else if(mce.GetMethod() == null || mce.RealName != ifmethod.Name)
			{
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				AttributeHelper.HideFromReflection(mb);
				ILGenerator ilGenerator = mb.GetILGenerator();
				ilGenerator.Emit(OpCodes.Ldarg_0);
				int argc = md.ArgCount;
				for(int n = 0; n < argc; n++)
				{
					ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
				}
				mce.EmitCallvirt.Emit(ilGenerator);
				ilGenerator.Emit(OpCodes.Ret);
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
			}
			else if(mce.DeclaringType.TypeAsTBD.Assembly != typeBuilder.Assembly)
			{
				// NOTE methods inherited from base classes in a different assembly do *not* automatically implement
				// interface methods, so we have to generate a stub here that doesn't do anything but call the base
				// implementation
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
				AttributeHelper.HideFromReflection(mb);
				ILGenerator ilGenerator = mb.GetILGenerator();
				ilGenerator.Emit(OpCodes.Ldarg_0);
				int argc = md.ArgCount;
				for(int n = 0; n < argc; n++)
				{
					ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
				}
				mce.EmitCallvirt.Emit(ilGenerator);
				ilGenerator.Emit(OpCodes.Ret);
			}
		}
		else
		{
			if(!wrapper.IsAbstract)
			{
				// the type doesn't implement the interface method and isn't abstract either. The JVM allows this, but the CLR doesn't,
				// so we have to create a stub method that throws an AbstractMethodError
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				AttributeHelper.HideFromReflection(mb);
				EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + md.Name + md.Signature);
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
				wrapper.HasIncompleteInterfaceImplementation = true;
			}
			else
			{
				// because of a bug in the .NET 1.0 CLR, we have emit an abstract Miranda method, otherwise
				// the class will not be loadable under some circumstances
				// Example (compile with Jikes 1.18):
				//interface __Shape
				//{
				//    public abstract __Rectangle getBounds();
				//    public abstract __Rectangle2D getBounds2D();
				//}
				//
				//abstract class __RectangularShape implements __Shape
				//{
				//    public __Rectangle getBounds()
				//    {
				//	     return null;
				//    }
				//}
				//
				//abstract class __Rectangle2D extends __RectangularShape
				//{
				//    public __Rectangle2D getBounds2D()
				//    {
				//        return null;
				//    }
				//}
				//
				//class __Rectangle extends __Rectangle2D implements __Shape
				//{
				//    public __Rectangle getBounds()
				//    {
				//        return null;
				//    }
				//
				//    public __Rectangle2D getBounds2D()
				//    {
				//        return null;
				//    }
				//}
				MethodBuilder mb = typeBuilder.DefineMethod(md.Name, MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				AttributeHelper.HideFromReflection(mb);
				// NOTE because we are introducing a Miranda method, we must also update the corresponding wrapper.
				// If we don't do this, subclasses might think they are introducing a new method, instead of overriding
				// this one.
				wrapper.AddMethod(MethodWrapper.Create(wrapper, md, mb, mb, Modifiers.Public | Modifiers.Abstract, true));
				// NOTE if the interface method name is remapped, we need to add an explicit methodoverride. Note that when this
				// is required we always need to emit this stub, even if the above mentioned bug is fixed in the CLR
				if(md.Name != ifmethod.Name)
				{
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
				}
			}
		}
	}

	internal void ImplementInterfaceMethodStubs(TypeBuilder typeBuilder, DynamicTypeWrapper wrapper, Hashtable doneSet)
	{
		Debug.Assert(this.IsInterface);

		// TODO interfaces that implement other interfaces need to be handled as well...

		// make sure we don't do the same method twice
		if(doneSet.ContainsKey(this))
		{
			return;
		}
		doneSet.Add(this, this);
		Finish();
		// NOTE for dynamic types it isn't legal to call Type.GetMethods() (because
		// that might trigger finishing of types that are already in the process of
		// being finished) and for RemappedTypeWrappers it makes no sense, so both
		// of these (ab)use the methods hashtable to obtain a list of methods
		// NOTE since the types have been finished, we know for sure that all methods
		// are in fact in the methods cache
		if(TypeAsTBD.Assembly is AssemblyBuilder || this.IsRemapped)
		{
			foreach(MethodWrapper method in methods.Values)
			{
				MethodBase ifmethod = method.GetMethod();
				if(!ifmethod.IsStatic)
				{
					ImplementInterfaceMethodStubImpl(method.Descriptor, ifmethod, typeBuilder, wrapper);
				}
			}
		}
		else
		{
			MethodInfo[] methods = TypeAsBaseType.GetMethods();
			for(int i = 0; i < methods.Length; i++)
			{
				MethodInfo ifmethod = methods[i];
				if(!ifmethod.IsStatic)
				{
					ImplementInterfaceMethodStubImpl(MethodDescriptor.FromMethodBase(ifmethod), ifmethod, typeBuilder, wrapper);
				}
			}
		}
		TypeWrapper[] interfaces = Interfaces;
		for(int i = 0; i < interfaces.Length; i++)
		{
			interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
		}
	}

	[Conditional("DEBUG")]
	internal static void AssertFinished(Type type)
	{
		if(type != null)
		{
			while(type.IsArray)
			{
				type = type.GetElementType();
			}
			Debug.Assert(!(type is TypeBuilder));
		}
	}

	internal void RunClassInit()
	{
		System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(TypeAsTBD.TypeHandle);
	}

	internal void EmitUnbox(ILGenerator ilgen)
	{
		Debug.Assert(this.IsNonPrimitiveValueType);

		Type type = this.TypeAsTBD;
		// NOTE if the reference is null, we treat it as a default instance of the value type.
		ilgen.Emit(OpCodes.Dup);
		Label label1 = ilgen.DefineLabel();
		ilgen.Emit(OpCodes.Brtrue_S, label1);
		ilgen.Emit(OpCodes.Pop);
		ilgen.Emit(OpCodes.Ldloc, ilgen.DeclareLocal(type));
		Label label2 = ilgen.DefineLabel();
		ilgen.Emit(OpCodes.Br_S, label2);
		ilgen.MarkLabel(label1);
		ilgen.Emit(OpCodes.Unbox, type);
		ilgen.Emit(OpCodes.Ldobj, type);
		ilgen.MarkLabel(label2);
	}

	internal virtual void EmitBox(ILGenerator ilgen)
	{
		Debug.Assert(this.IsNonPrimitiveValueType);

		ilgen.Emit(OpCodes.Box, this.TypeAsTBD);
	}

	// NOTE sourceType is optional and only used for special types (e.g. interfaces),
	// it is *not* used to automatically downcast
	internal void EmitConvStackToParameterType(ILGenerator ilgen, TypeWrapper sourceType)
	{
		if(!IsUnloadable)
		{
			if(IsGhost)
			{
				LocalBuilder local1 = ilgen.DeclareLocal(TypeAsLocalOrStackType);
				ilgen.Emit(OpCodes.Stloc, local1);
				LocalBuilder local2 = ilgen.DeclareLocal(TypeAsParameterType);
				ilgen.Emit(OpCodes.Ldloca, local2);
				ilgen.Emit(OpCodes.Ldloc, local1);
				ilgen.Emit(OpCodes.Stfld, GhostRefField);
				ilgen.Emit(OpCodes.Ldloca, local2);
				ilgen.Emit(OpCodes.Ldobj, TypeAsParameterType);
			}
			// because of the way interface merging works, any reference is valid
			// for any interface reference
			else if(IsInterfaceOrInterfaceArray && (sourceType == null || sourceType.IsUnloadable || !sourceType.IsAssignableTo(this)))
			{
				ilgen.Emit(OpCodes.Castclass, TypeAsTBD);
			}
			else if(IsNonPrimitiveValueType)
			{
				EmitUnbox(ilgen);
			}
		}
	}

	internal void EmitConvParameterToStackType(ILGenerator ilgen)
	{
		if(IsUnloadable)
		{
			// nothing to do
		}
		else if(IsNonPrimitiveValueType)
		{
			EmitBox(ilgen);
		}
		else if(IsGhost)
		{
			LocalBuilder local = ilgen.DeclareLocal(TypeAsParameterType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(OpCodes.Ldloca, local);
			ilgen.Emit(OpCodes.Ldfld, GhostRefField);
		}
	}

	internal virtual void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
	{
		if(IsGhost)
		{
			ilgen.Emit(OpCodes.Dup);
			// TODO make sure we get the right "Cast" method and cache it
			// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
			// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
			ilgen.Emit(OpCodes.Call, TypeAsTBD.GetMethod("Cast"));
			ilgen.Emit(OpCodes.Pop);
		}
		else if(IsGhostArray)
		{
			ilgen.Emit(OpCodes.Dup);
			// TODO make sure we get the right "CastArray" method and cache it
			// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
			// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
			TypeWrapper tw = this;
			int rank = 0;
			while(tw.IsArray)
			{
				rank++;
				tw = tw.ElementTypeWrapper;
			}
			ilgen.Emit(OpCodes.Ldc_I4, rank);
			ilgen.Emit(OpCodes.Call, tw.TypeAsTBD.GetMethod("CastArray"));
		}
		else
		{
			ilgen.Emit(OpCodes.Castclass, TypeAsTBD);
		}
	}

	internal virtual void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
	{
		if(IsGhost)
		{
			// TODO make sure we get the right "IsInstance" method and cache it
			// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
			// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
			ilgen.Emit(OpCodes.Call, TypeAsTBD.GetMethod("IsInstance"));
		}
		else if(IsGhostArray)
		{
			// TODO make sure we get the right "IsInstanceArray" method and cache it
			// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
			// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
			ilgen.Emit(OpCodes.Call, TypeAsTBD.GetMethod("IsInstanceArray"));
		}
		else
		{
			ilgen.Emit(OpCodes.Isinst, TypeAsTBD);
			ilgen.Emit(OpCodes.Ldnull);
			ilgen.Emit(OpCodes.Ceq);
			ilgen.Emit(OpCodes.Ldc_I4_0);
			ilgen.Emit(OpCodes.Ceq);
		}
	}

	internal static string GetSigNameFromType(Type type)
	{
		TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromTypeFast(type);

		if(wrapper != null)
		{
			return wrapper.SigName;
		}

		if(type.IsArray)
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			while(type.IsArray)
			{
				sb.Append('[');
				type = type.GetElementType();
			}
			return sb.Append(GetSigNameFromType(type)).ToString();
		}

		string s = TypeWrapper.GetNameFromType(type);
		if(s[0] != '[')
		{
			s = "L" + s + ";";
		}
		return s;
	}

	// NOTE returns null for primitive types
	internal static string GetNameFromType(Type type)
	{
		TypeWrapper.AssertFinished(type);

		if(type.IsArray)
		{
			return GetSigNameFromType(type);
		}

		// first we check if a wrapper exists, because if it does we must use the name from the wrapper to
		// make sure that remapped types return the proper name
		TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromTypeFast(type);
		if(wrapper != null)
		{
			return wrapper.Name;
		}

		if(type.Module.IsDefined(typeof(JavaModuleAttribute), false))
		{
			return CompiledTypeWrapper.GetName(type);
		}
		else
		{
			return DotNetTypeWrapper.GetName(type);
		}
	}
}

class UnloadableTypeWrapper : TypeWrapper
{
	internal UnloadableTypeWrapper(string name)
		: base(TypeWrapper.UnloadableModifiersHack, name, null, null)
	{
	}

	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
	{
		throw new InvalidOperationException("GetFieldImpl called on UnloadableTypeWrapper: " + Name);
	}

	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		throw new InvalidOperationException("GetMethodImpl called on UnloadableTypeWrapper: " + Name);
	}

	internal override Type TypeAsTBD
	{
		get
		{
			throw new InvalidOperationException("get_Type called on UnloadableTypeWrapper: " + Name);
		} 
	} 

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			throw new InvalidOperationException("get_Interfaces called on UnloadableTypeWrapper: " + Name);
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			throw new InvalidOperationException("get_InnerClasses called on UnloadableTypeWrapper: " + Name);
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			throw new InvalidOperationException("get_DeclaringTypeWrapper called on UnloadableTypeWrapper: " + Name);
		}
	}

	internal override void Finish()
	{
		throw new InvalidOperationException("Finish called on UnloadableTypeWrapper: " + Name);
	}

	internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
	{
		ilgen.Emit(OpCodes.Ldtoken, context.TypeAsTBD);
		ilgen.Emit(OpCodes.Ldstr, Name);
		ilgen.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicCast"));
	}

	internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
	{
		ilgen.Emit(OpCodes.Ldtoken, context.TypeAsTBD);
		ilgen.Emit(OpCodes.Ldstr, Name);
		ilgen.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicInstanceOf"));
	}
}

class PrimitiveTypeWrapper : TypeWrapper
{
	internal static readonly PrimitiveTypeWrapper BYTE = new PrimitiveTypeWrapper(typeof(sbyte), "B");
	internal static readonly PrimitiveTypeWrapper CHAR = new PrimitiveTypeWrapper(typeof(char), "C");
	internal static readonly PrimitiveTypeWrapper DOUBLE = new PrimitiveTypeWrapper(typeof(double), "D");
	internal static readonly PrimitiveTypeWrapper FLOAT = new PrimitiveTypeWrapper(typeof(float), "F");
	internal static readonly PrimitiveTypeWrapper INT = new PrimitiveTypeWrapper(typeof(int), "I");
	internal static readonly PrimitiveTypeWrapper LONG = new PrimitiveTypeWrapper(typeof(long), "J");
	internal static readonly PrimitiveTypeWrapper SHORT = new PrimitiveTypeWrapper(typeof(short), "S");
	internal static readonly PrimitiveTypeWrapper BOOLEAN = new PrimitiveTypeWrapper(typeof(bool), "Z");
	internal static readonly PrimitiveTypeWrapper VOID = new PrimitiveTypeWrapper(typeof(void), "V");

	private readonly Type type;
	private readonly string sigName;

	private PrimitiveTypeWrapper(Type type, string sigName)
		: base(Modifiers.Public | Modifiers.Abstract | Modifiers.Final, null, null, null)
	{
		this.type = type;
		this.sigName = sigName;
	}

	internal override string SigName
	{
		get
		{
			return sigName;
		}
	}

	internal override ClassLoaderWrapper GetClassLoader()
	{
		return ClassLoaderWrapper.GetBootstrapClassLoader();
	}

	internal override Type TypeAsTBD
	{
		get
		{
			return type;
		}
	}

	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
	{
		return null;
	}

	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		return null;
	}

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			// TODO does a primitive implement any interfaces?
			return TypeWrapper.EmptyArray;
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			return TypeWrapper.EmptyArray;
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			return null;
		}
	}

	internal override void Finish()
	{
	}
}

class DynamicTypeWrapper : TypeWrapper
{
	private DynamicImpl impl;
	private TypeWrapper[] interfaces;
	private FieldInfo ghostRefField;
	private MethodBuilder ghostIsInstanceMethod;
	private MethodBuilder ghostIsInstanceArrayMethod;
	private MethodBuilder ghostCastMethod;
	private MethodBuilder ghostCastArrayMethod;
	private static TypeWrapper[] mappedExceptions;
	private static Hashtable ghosts;
	private static Hashtable nativeMethods;

	internal DynamicTypeWrapper(ClassFile f, ClassLoaderWrapper classLoader)
		: base(f.Modifiers, f.Name, f.IsInterface ? null : f.GetSuperTypeWrapper(classLoader), classLoader)
	{
		Profiler.Count("DynamicTypeWrapper");
		if(BaseTypeWrapper != null)
		{
			if(BaseTypeWrapper.IsUnloadable)
			{
				throw JavaException.NoClassDefFoundError(BaseTypeWrapper.Name);
			}
			if(!BaseTypeWrapper.IsAccessibleFrom(this))
			{
				throw JavaException.IllegalAccessError("Class {0} cannot access its superclass {1}", f.Name, BaseTypeWrapper.Name);
			}
			if(BaseTypeWrapper.IsFinal)
			{
				throw JavaException.VerifyError("Cannot inherit from final class");
			}
			if(BaseTypeWrapper.IsInterface)
			{
				throw JavaException.IncompatibleClassChangeError("Class {0} has interface {1} as superclass", f.Name, BaseTypeWrapper.Name);
			}
		}
		interfaces = f.GetInterfaceTypeWrappers(classLoader);
		for(int i = 0; i < interfaces.Length; i++)
		{
			if(interfaces[i].IsUnloadable)
			{
				throw JavaException.NoClassDefFoundError(interfaces[i].Name);
			}
			if(!interfaces[i].IsInterface)
			{
				throw JavaException.IncompatibleClassChangeError("Implementing class");
			}
			if(!interfaces[i].IsAccessibleFrom(this))
			{
				throw JavaException.IllegalAccessError("Class {0} cannot access its superinterface {1}", f.Name, interfaces[i].Name);
			}
		}

		impl = new JavaTypeImpl(f, this);
	}

	internal override FieldInfo GhostRefField
	{
		get
		{
			return ghostRefField;
		}
	}

	internal override Modifiers ReflectiveModifiers
	{
		get
		{
			return impl.ReflectiveModifiers;
		}
	}

	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
	{
		return impl.GetFieldImpl(fieldName, fieldType);
	}

	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		return impl.GetMethodImpl(md);
	}

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			return interfaces;
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			return impl.InnerClasses;
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			return impl.DeclaringTypeWrapper;
		}
	}

	internal override Type TypeAsTBD
	{
		get
		{
			return impl.Type;
		}
	}

	internal override Type TypeAsBaseType
	{
		get
		{
			return impl.TypeAsBaseType;
		}
	}

	internal override void Finish()
	{
		lock(GetType())
		{
			Profiler.Enter("DynamicTypeWrapper.Finish");
			try
			{
				impl = impl.Finish();
			}
			finally
			{
				Profiler.Leave("DynamicTypeWrapper.Finish");
			}
		}
	}

	internal static void SetupGhosts(MapXml.Root map)
	{
		ghosts = new Hashtable();

		// find the ghost interfaces
		foreach(MapXml.Class c in map.assembly)
		{
			if(c.Shadows != null && c.Interfaces != null)
			{
				// NOTE we don't support interfaces that inherit from other interfaces
				// (actually, if they are explicitly listed it would probably work)
				TypeWrapper typeWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(c.Name);
				foreach(MapXml.Interface iface in c.Interfaces)
				{
					TypeWrapper ifaceWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(iface.Name);
					if(ifaceWrapper == null || !ifaceWrapper.TypeAsTBD.IsAssignableFrom(typeWrapper.TypeAsTBD))
					{
						AddGhost(iface.Name, typeWrapper);
					}
				}
			}
		}
		// we manually add the array ghost interfaces
		TypeWrapper array = ClassLoaderWrapper.GetWrapperFromType(typeof(Array));
		AddGhost("java.io.Serializable", array);
		AddGhost("java.lang.Cloneable", array);
	}

	private static void AddGhost(string interfaceName, TypeWrapper implementer)
	{
		ArrayList list = (ArrayList)ghosts[interfaceName];
		if(list == null)
		{
			list = new ArrayList();
			ghosts[interfaceName] = list;
		}
		list.Add(implementer);
	}

	internal override bool IsGhost
	{
		get
		{
			return ghosts != null && IsInterface && ghosts.ContainsKey(Name);
		}
	}

	private static TypeWrapper[] GetGhostImplementers(TypeWrapper wrapper)
	{
		ArrayList list = (ArrayList)ghosts[wrapper.Name];
		if(list == null)
		{
			return TypeWrapper.EmptyArray;
		}
		return (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
	}

	private class ExceptionMapEmitter : CodeEmitter
	{
		private MapXml.ExceptionMapping[] map;

		internal ExceptionMapEmitter(MapXml.ExceptionMapping[] map)
		{
			this.map = map;
		}

		// this method doesn't work on Mono yet, so we use a Type based approach instead
#if USE_TYPEHANDLE_EXCEPTION_MAPPING
		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeHandle"));
			LocalBuilder typehandle = ilgen.DeclareLocal(typeof(RuntimeTypeHandle));
			ilgen.Emit(OpCodes.Stloc, typehandle);
			ilgen.Emit(OpCodes.Ldloca, typehandle);
			MethodInfo get_Value = typeof(RuntimeTypeHandle).GetMethod("get_Value");
			ilgen.Emit(OpCodes.Call, get_Value);
			for(int i = 0; i < map.Length; i++)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Ldtoken, Type.GetType(map[i].src));
				ilgen.Emit(OpCodes.Stloc, typehandle);
				ilgen.Emit(OpCodes.Ldloca, typehandle);
				ilgen.Emit(OpCodes.Call, get_Value);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Bne_Un_S, label);
				ilgen.Emit(OpCodes.Pop);
				if(map[i].code != null)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					map[i].code.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
				else
				{
					TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map[i].dst);
					tw.GetMethodWrapper(MethodDescriptor.FromNameSig(tw.GetClassLoader(), "<init>", "()V"), false).EmitNewobj.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
				ilgen.MarkLabel(label);
			}
			ilgen.Emit(OpCodes.Pop);
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Ret);
		}
#else // USE_TYPEHANDLE_EXCEPTION_MAPPING
		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Callvirt, typeof(Object).GetMethod("GetType"));
			MethodInfo GetTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle");
			for(int i = 0; i < map.Length; i++)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Ldtoken, Type.GetType(map[i].src));
				ilgen.Emit(OpCodes.Call, GetTypeFromHandle);
				ilgen.Emit(OpCodes.Ceq);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brfalse_S, label);
				ilgen.Emit(OpCodes.Pop);
				if(map[i].code != null)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					map[i].code.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
				else
				{
					TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map[i].dst);
					tw.GetMethodWrapper(MethodDescriptor.FromNameSig(tw.GetClassLoader(), "<init>", "()V"), false).EmitNewobj.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
				ilgen.MarkLabel(label);
			}
			ilgen.Emit(OpCodes.Pop);
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Ret);
		}
#endif // USE_TYPEHANDLE_EXCEPTION_MAPPING
	}

	internal static void LoadNativeMethods(MapXml.Root map)
	{
		nativeMethods = new Hashtable();
		// HACK we've got a hardcoded location for the exception mapping method that is generated from the xml mapping
		nativeMethods["java.lang.ExceptionHelper.MapExceptionImpl(Ljava.lang.Throwable;)Ljava.lang.Throwable;"] = new ExceptionMapEmitter(map.exceptionMappings);
		foreach(MapXml.Class c in map.assembly)
		{
			// HACK if it is not a remapped type, we assume it is a container for native methods
			if(c.Shadows == null)
			{
				string className = c.Name;
				foreach(MapXml.Method method in c.Methods)
				{
					if(method.body != null)
					{
						string methodName = method.Name;
						string methodSig = method.Sig;
						nativeMethods[className + "." + methodName + methodSig] = method.body;
					}
				}
			}
		}
	}

	internal override bool IsMapUnsafeException
	{
		get
		{
			if(mappedExceptions != null)
			{
				for(int i = 0; i < mappedExceptions.Length; i++)
				{
					if(mappedExceptions[i].IsSubTypeOf(this))
					{
						return true;
					}
				}
			}
			return false;
		}
	}

	internal static void LoadMappedExceptions(MapXml.Root map)
	{
		mappedExceptions = new TypeWrapper[map.exceptionMappings.Length];
		for(int i = 0; i < mappedExceptions.Length; i++)
		{
			mappedExceptions[i] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map.exceptionMappings[i].dst);
		}
	}

	private abstract class DynamicImpl
	{
		public abstract FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType);
		public abstract MethodWrapper GetMethodImpl(MethodDescriptor md);
		public abstract Type Type { get; }
		internal abstract Type TypeAsBaseType { get; }
		public abstract TypeWrapper[] InnerClasses { get; }
		public abstract TypeWrapper DeclaringTypeWrapper { get; }
		public abstract Modifiers ReflectiveModifiers { get; }
		public abstract DynamicImpl Finish();
	}

	private class JavaTypeImpl : DynamicImpl
	{
		private readonly ClassFile classFile;
		private readonly DynamicTypeWrapper wrapper;
		private readonly TypeBuilder typeBuilder;
		private MethodWrapper[] methods;
		private FieldWrapper[] fields;
		private Hashtable methodLookup;
		private Hashtable fieldLookup;
		private bool finishing;
		private FinishedTypeImpl finishedType;
		private readonly TypeWrapper outerClassWrapper;
		private readonly TypeBuilder typeBuilderGhostInterface;

		internal JavaTypeImpl(ClassFile f, DynamicTypeWrapper wrapper)
		{
			Tracer.Info(Tracer.Compiler, "constructing JavaTypeImpl for " + f.Name);
			this.classFile = f;
			this.wrapper = wrapper;

			TypeAttributes typeAttribs = 0;
			if(f.IsAbstract)
			{
				typeAttribs |= TypeAttributes.Abstract;
			}
			if(f.IsFinal)
			{
				typeAttribs |= TypeAttributes.Sealed;
			}
			TypeBuilder outer = null;
			// only if requested, we compile inner classes as nested types, because it has a higher cost
			// and doesn't buy us anything, unless we're compiling a library that could be used from C# (e.g.)
			if(JVM.CompileInnerClassesAsNestedTypes)
			{
				if(f.OuterClass != null)
				{
					if(!CheckInnerOuterNames(f.Name, f.OuterClass.Name))
					{
						Tracer.Warning(Tracer.Compiler, "Incorrect InnerClasses attribute on {0}", f.Name);
					}
					else
					{
						outerClassWrapper = wrapper.GetClassLoader().LoadClassByDottedName(f.OuterClass.Name);
						if(outerClassWrapper is DynamicTypeWrapper)
						{
							outer = outerClassWrapper.TypeAsBuilder;
						}
					}
				}
			}
			if(f.IsPublic)
			{
				if(outer != null)
				{
					typeAttribs |= TypeAttributes.NestedPublic;
				}
				else
				{
					typeAttribs |= TypeAttributes.Public;
				}
			}
			else if(outer != null)
			{
				typeAttribs |= TypeAttributes.NestedAssembly;
			}
			if(f.IsInterface)
			{
				typeAttribs |= TypeAttributes.Interface | TypeAttributes.Abstract;
				if(outer != null)
				{
					if(wrapper.IsGhost)
					{
						throw new NotImplementedException();
					}
					// LAMESPEC the CLI spec says interfaces cannot contain nested types (Part.II, 9.6), but that rule isn't enforced
					// (and broken by J# as well), so we'll just ignore it too.
					typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs);
				}
				else
				{
					if(wrapper.IsGhost)
					{
						typeAttribs &= ~(TypeAttributes.Interface | TypeAttributes.Abstract);
						typeAttribs |= TypeAttributes.Class | TypeAttributes.Sealed;
						typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs, typeof(ValueType));
						AttributeHelper.SetGhostInterface(typeBuilder);
						AttributeHelper.SetModifiers(typeBuilder, wrapper.Modifiers);
						wrapper.ghostRefField = typeBuilder.DefineField("__ref", typeof(object), FieldAttributes.Public | FieldAttributes.SpecialName);
						AttributeHelper.HideFromReflection((FieldBuilder)wrapper.ghostRefField);
						typeBuilderGhostInterface = typeBuilder.DefineNestedType("__Interface", TypeAttributes.Interface | TypeAttributes.Abstract | TypeAttributes.NestedPublic);
						AttributeHelper.HideFromReflection(typeBuilderGhostInterface);
						wrapper.ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object) });
						wrapper.ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object), typeof(int) });
						wrapper.ghostCastMethod = typeBuilder.DefineMethod("Cast", MethodAttributes.Public | MethodAttributes.Static, typeBuilder, new Type[] { typeof(object) });
						wrapper.ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray", MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(object), typeof(int) });
					}
					else
					{
						typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs);
					}
				}
			}
			else
			{
				typeAttribs |= TypeAttributes.Class;
				if(outer != null)
				{
					// TODO in the CLR interfaces cannot contain nested types! (well, it works fine, but the spec says it isn't allowed)
					typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
				}
				else
				{
					typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
				}
			}
			TypeWrapper[] interfaces = wrapper.Interfaces;
			for(int i = 0; i < interfaces.Length; i++)
			{
				// NOTE we're using TypeAsBaseType for the interfaces!
				typeBuilder.AddInterfaceImplementation(interfaces[i].TypeAsBaseType);
			}
			AttributeHelper.SetImplementsAttribute(typeBuilder, interfaces);
			if(JVM.IsStaticCompiler && classFile.DeprecatedAttribute)
			{
				AttributeHelper.SetDeprecatedAttribute(typeBuilder);
			}
		}

		private static bool CheckInnerOuterNames(string inner, string outer)
		{
			// do some sanity checks on the inner/outer class names
			return inner.Length > outer.Length + 1 && inner[outer.Length] == '$' && inner.IndexOf('$', outer.Length + 1) == -1;
		}

		private static string GetInnerClassName(string outer, string inner)
		{
			Debug.Assert(CheckInnerOuterNames(inner, outer));
			return inner.Substring(outer.Length + 1);
		}

		private static bool IsCompatibleArgList(TypeWrapper[] caller, TypeWrapper[] callee)
		{
			if(caller.Length == callee.Length)
			{
				for(int i = 0; i < caller.Length; i++)
				{
					if(caller[i].TypeAsParameterType == typeof(sbyte[]) && callee[i].TypeAsParameterType == typeof(byte[]))
					{
						// special case for byte array cheating...
					}
					else if(!caller[i].IsAssignableTo(callee[i]))
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		private void EmitConstantValueInitialization(ILGenerator ilGenerator)
		{
			ClassFile.Field[] fields = classFile.Fields;
			for(int i = 0; i < fields.Length; i++)
			{
				ClassFile.Field f = fields[i];
				if(f.IsStatic && !f.IsFinal)
				{
					object constant = f.ConstantValue;
					if(constant != null)
					{
						if(constant is int)
						{
							ilGenerator.Emit(OpCodes.Ldc_I4, (int)constant);
						}
						else if(constant is long)
						{
							ilGenerator.Emit(OpCodes.Ldc_I8, (long)constant);
						}
						else if(constant is double)
						{
							ilGenerator.Emit(OpCodes.Ldc_R8, (double)constant);
						}
						else if(constant is float)
						{
							ilGenerator.Emit(OpCodes.Ldc_R4, (float)constant);
						}
						else if(constant is string)
						{
							ilGenerator.Emit(OpCodes.Ldstr, (string)constant);
						}
						else
						{
							throw new InvalidOperationException();
						}
						this.fields[i].EmitSet.Emit(ilGenerator);
					}
				}
			}
		}

		public override DynamicImpl Finish()
		{
			// NOTE if a finish is triggered during static compilation phase 1, it cannot be handled properly,
			// so we bail out.
			// (this should only happen during compilation of classpath.dll and is most likely caused by a bug somewhere)
			if(JVM.IsStaticCompilerPhase1)
			{
				JVM.CriticalFailure("Finish triggered during phase 1 of compilation.", null);
				return null;
			}
			if(wrapper.BaseTypeWrapper != null)
			{
				// make sure that the base type is already finished (because we need any Miranda methods it
				// might introduce to be visible)
				wrapper.BaseTypeWrapper.Finish();
			}
			if(outerClassWrapper != null)
			{
				outerClassWrapper.Finish();
			}
			// NOTE there is a bug in the CLR (.NET 1.0 & 1.1 [1.2 is not yet available]) that
			// causes the AppDomain.TypeResolve event to receive the incorrect type name for nested types.
			// The Name in the ResolveEventArgs contains only the nested type name, not the full type name,
			// for example, if the type being resolved is "MyOuterType+MyInnerType", then the event only
			// receives "MyInnerType" as the name. Since we only compile inner classes as nested types
			// when we're statically compiling, we can only run into this bug when we're statically compiling.
			// NOTE To work around this bug, we have to make sure that all types that are going to be
			// required in finished form, are finished explicitly here. It isn't clear what other types are
			// required to be finished. I instrumented a static compilation of classpath.dll and this
			// turned up no other cases of the TypeResolve event firing.
			for(int i = 0; i < wrapper.Interfaces.Length; i++)
			{
				wrapper.Interfaces[i].Finish();
			}
			// make sure all classes are loaded, before we start finishing the type. During finishing, we
			// may not run any Java code, because that might result in a request to finish the type that we
			// are in the process of finishing, and this would be a problem.
			classFile.LoadAllReferencedTypes(wrapper.GetClassLoader());
			// it is possible that the loading of the referenced classes triggered a finish of us,
			// if that happens, we just return
			if(finishedType != null)
			{
				return finishedType;
			}
			Profiler.Enter("JavaTypeImpl.Finish.Core");
			try
			{
				Debug.Assert(!finishing);
				finishing = true;
				Modifiers reflectiveModifiers = wrapper.Modifiers;
				TypeWrapper declaringTypeWrapper = null;
				TypeWrapper[] innerClassesTypeWrappers = TypeWrapper.EmptyArray;
				// if we're an inner class, we need to attach an InnerClass attribute
				ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
				if(innerclasses != null)
				{
					// TODO consider not pre-computing innerClassesTypeWrappers and declaringTypeWrapper here
					ArrayList wrappers = new ArrayList();
					for(int i = 0; i < innerclasses.Length; i++)
					{
						if(innerclasses[i].innerClass != 0 && innerclasses[i].outerClass != 0)
						{
							if(classFile.GetConstantPoolClassType(innerclasses[i].outerClass, wrapper.GetClassLoader()) == wrapper)
							{
								wrappers.Add(classFile.GetConstantPoolClassType(innerclasses[i].innerClass, wrapper.GetClassLoader()));
							}
							if(classFile.GetConstantPoolClassType(innerclasses[i].innerClass, wrapper.GetClassLoader()) == wrapper)
							{
								declaringTypeWrapper = classFile.GetConstantPoolClassType(innerclasses[i].outerClass, wrapper.GetClassLoader());
								reflectiveModifiers = innerclasses[i].accessFlags;
								AttributeHelper.SetInnerClass(typeBuilder,
									classFile.GetConstantPoolClass(innerclasses[i].innerClass),
									classFile.GetConstantPoolClass(innerclasses[i].outerClass),
									innerclasses[i].name == 0 ? null : classFile.GetConstantPoolUtf8String(innerclasses[i].name),
									reflectiveModifiers);
							}
						}
					}
					innerClassesTypeWrappers = (TypeWrapper[])wrappers.ToArray(typeof(TypeWrapper));
				}
				//Console.WriteLine("finishing TypeFactory for " + classFile.Name);
				if(fieldLookup == null)
				{
					fields = new FieldWrapper[classFile.Fields.Length];
					fieldLookup = new Hashtable();
					for(int i = 0; i < classFile.Fields.Length; i++)
					{
						fieldLookup[classFile.Fields[i].Name + classFile.Fields[i].Signature] = i;
					}
				}
				for(int i = 0; i < fields.Length; i++)
				{
					if(fields[i] == null)
					{
						GenerateField(i);
						wrapper.AddField(fields[i]);
					}
				}
				MethodDescriptor[] methodDescriptors = new MethodDescriptor[classFile.Methods.Length];
				for(int i = 0; i < classFile.Methods.Length; i++)
				{
					methodDescriptors[i] = new MethodDescriptor(wrapper.GetClassLoader(), classFile.Methods[i]);
				}
				if(methodLookup == null)
				{
					methods = new MethodWrapper[classFile.Methods.Length];
					methodLookup = new Hashtable();
					for(int i = 0; i < classFile.Methods.Length; i++)
					{
						methodLookup[methodDescriptors[i]] = i;
					}
				}
				for(int i = 0; i < methods.Length; i++)
				{
					if(methods[i] == null)
					{
						GenerateMethod(i);
						wrapper.AddMethod(methods[i]);
					}
				}
				if(typeBuilderGhostInterface != null)
				{
					// TODO consider adding methods from base interface and java.lang.Object as well
					for(int i = 0; i < methods.Length; i++)
					{
						// skip <clinit>
						if(!methods[i].IsStatic)
						{
							TypeWrapper[] args = methods[i].Descriptor.ArgTypeWrappers;
							MethodBuilder stub = typeBuilder.DefineMethod(methods[i].Name, MethodAttributes.Public, methods[i].Descriptor.RetTypeForDefineMethod, methods[i].Descriptor.ArgTypesForDefineMethod);
							AttributeHelper.SetModifiers(stub, methods[i].Modifiers);
							ILGenerator ilgen = stub.GetILGenerator();
							Label end = ilgen.DefineLabel();
							TypeWrapper[] implementers = GetGhostImplementers(wrapper);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldfld, wrapper.GhostRefField);
							ilgen.Emit(OpCodes.Dup);
							ilgen.Emit(OpCodes.Isinst, wrapper.TypeAsBaseType);
							Label label = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brfalse_S, label);
							ilgen.Emit(OpCodes.Castclass, wrapper.TypeAsBaseType);
							for(int k = 0; k < args.Length; k++)
							{
								ilgen.Emit(OpCodes.Ldarg_S, (byte)(k + 1));
							}
							ilgen.Emit(OpCodes.Callvirt, (MethodInfo)methods[i].GetMethod());
							ilgen.Emit(OpCodes.Br, end);
							ilgen.MarkLabel(label);
							for(int j = 0; j < implementers.Length; j++)
							{
								ilgen.Emit(OpCodes.Dup);
								ilgen.Emit(OpCodes.Isinst, implementers[j].TypeAsTBD);
								label = ilgen.DefineLabel();
								ilgen.Emit(OpCodes.Brfalse_S, label);
								ilgen.Emit(OpCodes.Castclass, implementers[j].TypeAsTBD);
								for(int k = 0; k < args.Length; k++)
								{
									ilgen.Emit(OpCodes.Ldarg_S, (byte)(k + 1));
								}
								MethodWrapper mw = implementers[j].GetMethodWrapper(methods[i].Descriptor, true);
								mw.EmitCallvirt.Emit(ilgen);
								ilgen.Emit(OpCodes.Br, end);
								ilgen.MarkLabel(label);
							}
							// we need to do a null check (null fails all the isinst checks)
							EmitHelper.NullCheck(ilgen);
							EmitHelper.Throw(ilgen, "java.lang.IncompatibleClassChangeError", wrapper.Name);
							ilgen.MarkLabel(end);
							ilgen.Emit(OpCodes.Ret);
						}
					}
					// HACK create a scope to enable reuse of "implementers" name
					if(true)
					{
						MethodBuilder mb;
						ILGenerator ilgen;
						LocalBuilder local;
						// add implicit conversions for all the ghost implementers
						TypeWrapper[] implementers = GetGhostImplementers(wrapper);
						for(int i = 0; i < implementers.Length; i++)
						{
							mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, wrapper.TypeAsParameterType, new Type[] { implementers[i].TypeAsParameterType });
							AttributeHelper.HideFromReflection(mb);
							ilgen = mb.GetILGenerator();
							local = ilgen.DeclareLocal(wrapper.TypeAsParameterType);
							ilgen.Emit(OpCodes.Ldloca, local);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Stfld, wrapper.GhostRefField);
							ilgen.Emit(OpCodes.Ldloca, local);
							ilgen.Emit(OpCodes.Ldobj, wrapper.TypeAsParameterType);			
							ilgen.Emit(OpCodes.Ret);
						}
						// Implement the "IsInstance" method
						mb = wrapper.ghostIsInstanceMethod;
						AttributeHelper.HideFromReflection(mb);
						ilgen = mb.GetILGenerator();
						Label end = ilgen.DefineLabel();
						for(int i = 0; i < implementers.Length; i++)
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
							Label label = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brfalse_S, label);
							ilgen.Emit(OpCodes.Ldc_I4_1);
							ilgen.Emit(OpCodes.Br, end);
							ilgen.MarkLabel(label);
						}
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, wrapper.TypeAsBaseType);
						ilgen.Emit(OpCodes.Ldnull);
						ilgen.Emit(OpCodes.Ceq);
						ilgen.Emit(OpCodes.Ldc_I4_0);
						ilgen.Emit(OpCodes.Ceq);
						ilgen.MarkLabel(end);
						ilgen.Emit(OpCodes.Ret);
						// Implement the "IsInstanceArray" method
						mb = wrapper.ghostIsInstanceArrayMethod;
						AttributeHelper.HideFromReflection(mb);
						ilgen = mb.GetILGenerator();
						LocalBuilder localType = ilgen.DeclareLocal(typeof(Type));
						ilgen.Emit(OpCodes.Ldarg_0);
						Label skip = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brtrue_S, skip);
						ilgen.Emit(OpCodes.Ldc_I4_0);
						ilgen.Emit(OpCodes.Ret);
						ilgen.MarkLabel(skip);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Call, typeof(object).GetMethod("GetType"));
						ilgen.Emit(OpCodes.Stloc, localType);
						skip = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Br_S, skip);
						Label iter = ilgen.DefineLabel();
						ilgen.MarkLabel(iter);
						ilgen.Emit(OpCodes.Ldarg_1);
						ilgen.Emit(OpCodes.Ldc_I4_1);
						ilgen.Emit(OpCodes.Sub);
						ilgen.Emit(OpCodes.Starg_S, (byte)1);
						ilgen.Emit(OpCodes.Ldloc, localType);
						ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("GetElementType"));
						ilgen.Emit(OpCodes.Stloc, localType);
						ilgen.MarkLabel(skip);
						ilgen.Emit(OpCodes.Ldloc, localType);
						ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("get_IsArray"));
						ilgen.Emit(OpCodes.Brtrue_S, iter);
						ilgen.Emit(OpCodes.Ldarg_1);
						skip = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brfalse_S, skip);
						ilgen.Emit(OpCodes.Ldc_I4_0);
						ilgen.Emit(OpCodes.Ret);
						ilgen.MarkLabel(skip);
						for(int i = 0; i < implementers.Length; i++)
						{
							ilgen.Emit(OpCodes.Ldtoken, implementers[i].TypeAsTBD);
							ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
							ilgen.Emit(OpCodes.Ldloc, localType);
							ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("IsAssignableFrom"));
							Label label = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brfalse_S, label);
							ilgen.Emit(OpCodes.Ldc_I4_1);
							ilgen.Emit(OpCodes.Ret);
							ilgen.MarkLabel(label);
						}
						ilgen.Emit(OpCodes.Ldtoken, wrapper.TypeAsBaseType);
						ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
						ilgen.Emit(OpCodes.Ldloc, localType);
						ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("IsAssignableFrom"));
						ilgen.Emit(OpCodes.Ret);
						
						// Implement the "Cast" method
						mb = wrapper.ghostCastMethod;
						AttributeHelper.HideFromReflection(mb);
						ilgen = mb.GetILGenerator();
						end = ilgen.DefineLabel();
						for(int i = 0; i < implementers.Length; i++)
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
							ilgen.Emit(OpCodes.Brtrue, end);
						}
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Castclass, wrapper.TypeAsBaseType);
						ilgen.Emit(OpCodes.Pop);
						ilgen.MarkLabel(end);
						local = ilgen.DeclareLocal(wrapper.TypeAsParameterType);
						ilgen.Emit(OpCodes.Ldloca, local);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Stfld, wrapper.ghostRefField);
						ilgen.Emit(OpCodes.Ldloca, local);
						ilgen.Emit(OpCodes.Ldobj, wrapper.TypeAsParameterType);	
						ilgen.Emit(OpCodes.Ret);
						// Add "ToObject" methods
						mb = typeBuilder.DefineMethod("ToObject", MethodAttributes.Public, typeof(object), Type.EmptyTypes);
						AttributeHelper.HideFromReflection(mb);
						ilgen = mb.GetILGenerator();
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Ldfld, wrapper.GhostRefField);
						ilgen.Emit(OpCodes.Ret);

						// Implement the "CastArray" method
						// NOTE unlike "Cast" this doesn't return anything, it just throws a ClassCastException if the
						// cast is unsuccessful. Also, because of the complexity of this test, we call IsInstanceArray
						// instead of reimplementing the check here.
						mb = wrapper.ghostCastArrayMethod;
						AttributeHelper.HideFromReflection(mb);
						ilgen = mb.GetILGenerator();
						end = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Brfalse_S, end);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Ldarg_1);
						ilgen.Emit(OpCodes.Call, wrapper.ghostIsInstanceArrayMethod);
						ilgen.Emit(OpCodes.Brtrue_S, end);
						EmitHelper.Throw(ilgen, "java.lang.ClassCastException");
						ilgen.MarkLabel(end);
						ilgen.Emit(OpCodes.Ret);
					}
				}
				// if we're not abstract make sure we don't inherit any abstract methods
				if(!wrapper.IsAbstract)
				{
					TypeWrapper parent = wrapper.BaseTypeWrapper;
					// if parent is not abstract, the .NET implementation will never have abstract methods (only
					// stubs that throw AbstractMethodError)
					// NOTE interfaces are supposed to be abstract, but the VM doesn't enforce this, so
					// we have to check for a null parent (interfaces have no parent).
					while(parent != null && parent.IsAbstract)
					{
						MethodWrapper[] methods = parent.GetMethods();
						for(int i = 0; i < methods.Length; i++)
						{
							MethodInfo mi = methods[i].GetMethod() as MethodInfo;
							MethodDescriptor md = methods[i].Descriptor;
							if(mi != null && mi.IsAbstract && wrapper.GetMethodWrapper(md, true).IsAbstract)
							{
								// NOTE in Sun's JRE 1.4.1 this method cannot be overridden by subclasses,
								// but I think this is a bug, so we'll support it anyway.
								MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & ~(MethodAttributes.Abstract|MethodAttributes.NewSlot), CallingConventions.Standard, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
								AttributeHelper.SetModifiers(mb, methods[i].Modifiers);
								EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + md.Name + md.Signature);
							}
						}
						parent = parent.BaseTypeWrapper;
					}
				}
				bool basehasclinit = (wrapper.BaseTypeWrapper == null) ? false : wrapper.BaseTypeWrapper.TypeAsTBD.TypeInitializer != null;
				bool hasclinit = false;
				for(int i = 0; i < methods.Length; i++)
				{
					ILGenerator ilGenerator;
					MethodBase mb = methods[i].GetMethod();
					if(mb is ConstructorBuilder)
					{
						ilGenerator = ((ConstructorBuilder)mb).GetILGenerator();
						if(basehasclinit && classFile.Methods[i].IsClassInitializer && !classFile.IsInterface)
						{
							hasclinit = true;
							// before we call the base class initializer, we need to set the non-final static ConstantValue fields
							EmitConstantValueInitialization(ilGenerator);
							EmitHelper.RunClassConstructor(ilGenerator, Type.BaseType);
						}
					}
					else if(mb != null)
					{
						ilGenerator = ((MethodBuilder)mb).GetILGenerator();
					}
					else
					{
						// HACK methods that have unloadable types in the signature do not have an underlying method, so we end
						// up here
						// TODO I don't think the above is true anymore, this needs to be tested...
						continue;
					}
					ClassFile.Method m = classFile.Methods[i];
					Tracer.EmitMethodTrace(ilGenerator, m.ClassFile.Name + "." + m.Name + m.Signature);
					if(m.IsAbstract)
					{
						// NOTE in the JVM it is apparently legal for a non-abstract class to have abstract methods, but
						// the CLR doens't allow this, so we have to emit a method that throws an AbstractMethodError
						if(!m.ClassFile.IsAbstract && !m.ClassFile.IsInterface)
						{
							EmitHelper.Throw(ilGenerator, "java.lang.AbstractMethodError", m.ClassFile.Name + "." + m.Name + m.Signature);
						}
					}
					else if(m.IsNative)
					{
						Profiler.Enter("JavaTypeImpl.Finish.Native");
						try
						{
							// do we have a native implementation in map.xml?
							if(nativeMethods != null)
							{
								CodeEmitter opcodes = (CodeEmitter)nativeMethods[classFile.Name + "." + m.Name + m.Signature];
								if(opcodes != null)
								{
									opcodes.Emit(ilGenerator);
									continue;
								}
							}
							// see if there exists a NativeCode class for this type
							Type nativeCodeType = Type.GetType("NativeCode." + classFile.Name.Replace('$', '+'));
							MethodInfo nativeMethod = null;
							TypeWrapper[] args = m.GetArgTypes(wrapper.GetClassLoader());
							if(nativeCodeType != null)
							{
								TypeWrapper[] nargs = args;
								if(!m.IsStatic)
								{
									nargs = new TypeWrapper[args.Length + 1];
									args.CopyTo(nargs, 1);
									nargs[0] = this.wrapper;
								}
								MethodInfo[] nativeCodeTypeMethods = nativeCodeType.GetMethods(BindingFlags.Static | BindingFlags.Public);
								foreach(MethodInfo method in nativeCodeTypeMethods)
								{
									ParameterInfo[] param = method.GetParameters();
									TypeWrapper[] match = new TypeWrapper[param.Length];
									for(int j = 0; j < param.Length; j++)
									{
										match[j] = ClassLoaderWrapper.GetWrapperFromType(param[j].ParameterType);
									}
									if(m.Name == method.Name && IsCompatibleArgList(nargs, match))
									{
										// TODO instead of taking the first matching method, we should find the best one
										nativeMethod = method;
										break;
									}
								}
							}
							if(nativeMethod != null)
							{
								int add = 0;
								if(!m.IsStatic)
								{
									ilGenerator.Emit(OpCodes.Ldarg_0);
									add = 1;
								}
								for(int j = 0; j < args.Length; j++)
								{
									ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
								}
								ilGenerator.Emit(OpCodes.Call, nativeMethod);
								TypeWrapper retTypeWrapper = m.GetRetType(wrapper.GetClassLoader());
								if(!retTypeWrapper.TypeAsTBD.Equals(nativeMethod.ReturnType) && !retTypeWrapper.IsGhost)
								{
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
								}
								ilGenerator.Emit(OpCodes.Ret);
							}
							else
							{
								if(JVM.NoJniStubs)
								{
									// since NoJniStubs can only be set when we're statically compiling, it is safe to use the "compiler" trace switch
									Tracer.Warning(Tracer.Compiler, "Native method not implemented: {0}.{1}.{2}", classFile.Name, m.Name, m.Signature);
									EmitHelper.Throw(ilGenerator, "java.lang.UnsatisfiedLinkError", "Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
								}
								else
								{
									JniBuilder.Generate(ilGenerator, wrapper, typeBuilder, m, args);
									//JniProxyBuilder.Generate(ilGenerator, wrapper, typeBuilder, m, args);
								}
							}
						}
						finally
						{
							Profiler.Leave("JavaTypeImpl.Finish.Native");
						}
					}
					else
					{
						Compiler.Compile(wrapper, m, ilGenerator);
					}
				}
				if(!classFile.IsInterface)
				{
					// if we don't have a <clinit> we may need to inject one
					if(!hasclinit)
					{
						bool hasconstantfields = false;
						if(!basehasclinit)
						{
							foreach(ClassFile.Field f in classFile.Fields)
							{
								if(f.IsStatic && !f.IsFinal && f.ConstantValue != null)
								{
									hasconstantfields = true;
									break;
								}
							}
						}
						if(basehasclinit || hasconstantfields)
						{
							ConstructorBuilder cb = DefineClassInitializer();
							AttributeHelper.HideFromReflection(cb);
							ILGenerator ilGenerator = cb.GetILGenerator();
							EmitConstantValueInitialization(ilGenerator);
							if(basehasclinit)
							{
								EmitHelper.RunClassConstructor(ilGenerator, Type.BaseType);
							}
							ilGenerator.Emit(OpCodes.Ret);
						}
					}

					// here we loop thru all the interfaces to explicitly implement any methods that we inherit from
					// base types that may have a different name from the name in the interface
					// (e.g. interface that has an equals() method that should override System.Object.Equals())
					// also deals with interface methods that aren't implemented (generate a stub that throws AbstractMethodError)
					// and with methods that aren't public (generate a stub that throws IllegalAccessError)
					Hashtable doneSet = new Hashtable();
					TypeWrapper[] interfaces = wrapper.Interfaces;
					for(int i = 0; i < interfaces.Length; i++)
					{
						// if we implement a ghost interface, add an implicit conversion to the ghost reference value type
						if(interfaces[i].IsGhost)
						{
							MethodBuilder mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, interfaces[i].TypeAsParameterType, new Type[] { wrapper.TypeAsParameterType });
							AttributeHelper.HideFromReflection(mb);
							ILGenerator ilgen = mb.GetILGenerator();
							LocalBuilder local = ilgen.DeclareLocal(interfaces[i].TypeAsParameterType);
							ilgen.Emit(OpCodes.Ldloca, local);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Stfld, interfaces[i].GhostRefField);
							ilgen.Emit(OpCodes.Ldloca, local);
							ilgen.Emit(OpCodes.Ldobj, interfaces[i].TypeAsParameterType);			
							ilgen.Emit(OpCodes.Ret);
						}
						interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
					}
					// if any of our base classes has an incomplete interface implementation we need to look through all
					// the base class interfaces to see if we've got an implementation now
					TypeWrapper baseTypeWrapper = wrapper.BaseTypeWrapper;
					while(baseTypeWrapper.HasIncompleteInterfaceImplementation)
					{
						for(int i = 0; i < baseTypeWrapper.Interfaces.Length; i++)
						{
							baseTypeWrapper.Interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
						}
						baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
					}
				}

				Type type;
				Profiler.Enter("TypeBuilder.CreateType");
				try
				{
					type = typeBuilder.CreateType();
				}
				finally
				{
					Profiler.Leave("TypeBuilder.CreateType");
				}
				ClassLoaderWrapper.SetWrapperForType(type, wrapper);
				finishedType = new FinishedTypeImpl(type, typeBuilderGhostInterface != null ? typeBuilderGhostInterface.CreateType() : null, innerClassesTypeWrappers, declaringTypeWrapper, reflectiveModifiers);
				return finishedType;
			}
			catch(Exception x)
			{
				JVM.CriticalFailure("Exception during finishing of: " + wrapper.Name, x);
				return null;
			}
			finally
			{
				Profiler.Leave("JavaTypeImpl.Finish.Core");
			}
		}

		internal class JniProxyBuilder
		{
			private static ModuleBuilder mod;
			private static int count;

			private static string Cleanup(string n)
			{
				n = n.Replace('\\', '_');
				n = n.Replace('[', '_');
				n = n.Replace(']', '_');
				n = n.Replace('+', '_');
				n = n.Replace(',', '_');
				return n;
			}

			internal static void Generate(ILGenerator ilGenerator, TypeWrapper wrapper, TypeBuilder typeBuilder, ClassFile.Method m, TypeWrapper[] args)
			{
				if(mod == null)
				{
					mod = ((AssemblyBuilder)ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder.Assembly).DefineDynamicModule("jniproxy", "jniproxy.dll");
				}
				TypeBuilder tb = mod.DefineType("class" + (count++), TypeAttributes.Public | TypeAttributes.Class);
				int instance = m.IsStatic ? 0 : 1;
				Type[] argTypes = new Type[args.Length + instance];
				if(instance != 0)
				{
					argTypes[0] = wrapper.TypeAsParameterType;
				}
				for(int i = instance; i < argTypes.Length + instance; i++)
				{
					argTypes[i] = args[i].TypeAsParameterType;
				}
				MethodBuilder mb = tb.DefineMethod("method", MethodAttributes.Public | MethodAttributes.Static, m.GetRetType(wrapper.GetClassLoader()).TypeAsParameterType, argTypes);
				JniBuilder.Generate(mb.GetILGenerator(), wrapper, tb, m, args);
				for(int i = 0; i < argTypes.Length; i++)
				{
					ilGenerator.Emit(OpCodes.Ldarg, (ushort)i);
				}
				ilGenerator.Emit(OpCodes.Call, mb);
				ilGenerator.Emit(OpCodes.Ret);
				tb.CreateType();
			}
		}

		private class JniBuilder
		{
			private static readonly Type localRefStructType = JVM.JniProvider.GetLocalRefStructType();
			private static readonly MethodInfo jniFuncPtrMethod = JVM.JniProvider.GetJniFuncPtrMethod();
			private static readonly MethodInfo enterLocalRefStruct = localRefStructType.GetMethod("Enter");
			private static readonly MethodInfo leaveLocalRefStruct = localRefStructType.GetMethod("Leave");
			private static readonly MethodInfo makeLocalRef = localRefStructType.GetMethod("MakeLocalRef");
			private static readonly MethodInfo unwrapLocalRef = localRefStructType.GetMethod("UnwrapLocalRef");
			private static readonly MethodInfo getTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle");
			private static readonly MethodInfo getClassFromType = typeof(NativeCode.java.lang.VMClass).GetMethod("getClassFromType");
			private static readonly MethodInfo writeLine = typeof(Console).GetMethod("WriteLine", new Type[] { typeof(object) }, null);

			internal static void Generate(ILGenerator ilGenerator, TypeWrapper wrapper, TypeBuilder typeBuilder, ClassFile.Method m, TypeWrapper[] args)
			{
				FieldBuilder methodPtr = typeBuilder.DefineField(m.Name + "$Ptr", typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
				LocalBuilder localRefStruct = ilGenerator.DeclareLocal(localRefStructType);
				ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
				ilGenerator.Emit(OpCodes.Initobj, localRefStructType);
				ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
				Label oklabel = ilGenerator.DefineLabel();
				ilGenerator.Emit(OpCodes.Brtrue, oklabel);
				ilGenerator.Emit(OpCodes.Ldstr, m.Name);
				ilGenerator.Emit(OpCodes.Ldstr, m.Signature.Replace('.', '/'));
				ilGenerator.Emit(OpCodes.Ldstr, m.ClassFile.Name.Replace('.', '/'));
				ilGenerator.Emit(OpCodes.Call, jniFuncPtrMethod);
				ilGenerator.Emit(OpCodes.Stsfld, methodPtr);
				ilGenerator.MarkLabel(oklabel);
				ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
				ilGenerator.Emit(OpCodes.Call, enterLocalRefStruct);
				LocalBuilder jnienv = ilGenerator.DeclareLocal(typeof(IntPtr));
				ilGenerator.Emit(OpCodes.Stloc, jnienv);
				Label tryBlock = ilGenerator.BeginExceptionBlock();
				TypeWrapper retTypeWrapper = m.GetRetType(wrapper.GetClassLoader());
				if(!retTypeWrapper.IsPrimitive)
				{
					// this one is for use after we return from "calli"
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
				}
				ilGenerator.Emit(OpCodes.Ldloc, jnienv);
				Type[] modargs = new Type[args.Length + 2];
				modargs[0] = typeof(IntPtr);
				modargs[1] = typeof(IntPtr);
				for(int i = 0; i < args.Length; i++)
				{
					modargs[i + 2] = args[i].TypeAsParameterType;
				}
				int add = 0;
				if(!m.IsStatic)
				{
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					ilGenerator.Emit(OpCodes.Ldarg_0);
					ilGenerator.Emit(OpCodes.Call, makeLocalRef);
					add = 1;
				}
				else
				{
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
					ilGenerator.Emit(OpCodes.Call, getTypeFromHandle);
					ilGenerator.Emit(OpCodes.Call, getClassFromType);
					ilGenerator.Emit(OpCodes.Call, makeLocalRef);
				}
				for(int j = 0; j < args.Length; j++)
				{
					if(!args[j].IsPrimitive)
					{
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
						if(args[j].IsNonPrimitiveValueType)
						{
							args[j].EmitBox(ilGenerator);
						}
						ilGenerator.Emit(OpCodes.Call, makeLocalRef);
						modargs[j + 2] = typeof(IntPtr);
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
					}
				}
				ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
				ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, (retTypeWrapper.IsPrimitive) ? retTypeWrapper.TypeAsParameterType : typeof(IntPtr), modargs);
				LocalBuilder retValue = null;
				if(retTypeWrapper != PrimitiveTypeWrapper.VOID)
				{
					if(!retTypeWrapper.IsUnloadable && !retTypeWrapper.IsPrimitive)
					{
						ilGenerator.Emit(OpCodes.Call, unwrapLocalRef);
						if(retTypeWrapper.IsNonPrimitiveValueType)
						{
							retTypeWrapper.EmitUnbox(ilGenerator);
						}
						else if(!retTypeWrapper.IsGhost)
						{
							ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
						}
					}
					retValue = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
					ilGenerator.Emit(OpCodes.Stloc, retValue);
				}
				ilGenerator.BeginCatchBlock(typeof(object));
				ilGenerator.EmitWriteLine("*** exception in native code ***");
				ilGenerator.Emit(OpCodes.Call, writeLine);
				ilGenerator.Emit(OpCodes.Rethrow);
				ilGenerator.BeginFinallyBlock();
				ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
				ilGenerator.Emit(OpCodes.Call, leaveLocalRefStruct);
				ilGenerator.EndExceptionBlock();
				if(retTypeWrapper != PrimitiveTypeWrapper.VOID)
				{
					ilGenerator.Emit(OpCodes.Ldloc, retValue);
				}
				ilGenerator.Emit(OpCodes.Ret);
			}
		}

		public override TypeWrapper[] InnerClasses
		{
			get
			{
				throw new InvalidOperationException("InnerClasses is only available for finished types");
			}
		}

		public override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				throw new InvalidOperationException("DeclaringTypeWrapper is only available for finished types");
			}
		}

		public override Modifiers ReflectiveModifiers
		{
			get
			{
				throw new InvalidOperationException("ReflectiveModifiers is only available for finished types");
			}
		}

		public override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
		{
			if(fieldLookup == null)
			{
				fields = new FieldWrapper[classFile.Fields.Length];
				fieldLookup = new Hashtable();
				for(int i = 0; i < classFile.Fields.Length; i++)
				{
					fieldLookup[classFile.Fields[i].Name + classFile.Fields[i].Signature] = i;
				}
			}
			object index = fieldLookup[fieldName + fieldType.SigName];
			if(index != null)
			{
				int i = (int)index;
				if(fields[i] == null)
				{
					GenerateField(i);
				}
				return fields[i];
			}
			return null;
		}

		private void GenerateField(int i)
		{
			Profiler.Enter("JavaTypeImpl.GenerateField");
			try
			{
				FieldBuilder field;
				ClassFile.Field fld = classFile.Fields[i];
				string fieldName = fld.Name;
				TypeWrapper typeWrapper = fld.GetFieldType(wrapper.GetClassLoader());
				Type type = typeWrapper.TypeAsFieldType;
				if(typeWrapper.IsUnloadable)
				{
					// the field name is mangled here, because otherwise it can (theoretically)
					// conflict with another unloadable or object field
					// (fields can be overloaded on type)
					fieldName += "/" + typeWrapper.Name;
				}
				FieldAttributes attribs = 0;
				MethodAttributes methodAttribs = 0;
				bool setModifiers = false;
				if(fld.IsPrivate)
				{
					attribs |= FieldAttributes.Private;
				}
				else if(fld.IsProtected)
				{
					attribs |= FieldAttributes.FamORAssem;
					methodAttribs |= MethodAttributes.FamORAssem;
				}
				else if(fld.IsPublic)
				{
					attribs |= FieldAttributes.Public;
					methodAttribs |= MethodAttributes.Public;
				}
				else
				{
					attribs |= FieldAttributes.Assembly;
					methodAttribs |= MethodAttributes.Assembly;
				}
				if(fld.IsStatic)
				{
					attribs |= FieldAttributes.Static;
					methodAttribs |= MethodAttributes.Static;
				}
				// NOTE "constant" static finals are converted into literals
				// TODO it would be possible for Java code to change the value of a non-blank static final, but I don't
				// know if we want to support this (since the Java JITs don't really support it either)
				object constantValue = fld.ConstantValue;
				if(fld.IsStatic && fld.IsFinal && constantValue != null)
				{
					Profiler.Count("Static Final Constant");
					attribs |= FieldAttributes.Literal;
					field = typeBuilder.DefineField(fieldName, type, attribs);
					field.SetConstant(constantValue);
					// NOTE even though you're not supposed to access a constant static final (the compiler is supposed
					// to inline them), we have to support it (because it does happen, e.g. if the field becomes final
					// after the referencing class was compiled)
					CodeEmitter emitGet = CodeEmitter.CreateLoadConstant(constantValue);
					// when non-blank final fields are updated, the JIT normally doesn't see that (because the
					// constant value is inlined), so we emulate that behavior by emitting a Pop
					CodeEmitter emitSet = CodeEmitter.Pop;
					fields[i] = FieldWrapper.Create(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), fld.Name, fld.Signature, fld.Modifiers, field, emitGet, emitSet);
				}
				else
				{
					bool isWrappedFinal = fld.IsFinal && (fld.IsPublic || fld.IsProtected) && !wrapper.IsInterface;
					if(isWrappedFinal)
					{
						// NOTE public/protected blank final fields get converted into a read-only property with a private field
						// backing store we used to make the field privatescope, but that really serves no purpose (and it hinders
						// serialization, which uses .NET reflection to get at the field)
						attribs &= ~FieldAttributes.FieldAccessMask;
						attribs |= FieldAttributes.Private;
						setModifiers = true;
					}
					else if(fld.IsFinal)
					{
						setModifiers = true;
					}
					field = typeBuilder.DefineField(fieldName, type, attribs);
					if(fld.IsTransient)
					{
						CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(typeof(NonSerializedAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
						field.SetCustomAttribute(transientAttrib);
					}
					if(fld.IsVolatile)
					{
						// TODO the field should be marked as modreq(IsVolatile), but Reflection.Emit doesn't have a way of doing this
						setModifiers = true;
					}
					if(isWrappedFinal)
					{
						methodAttribs |= MethodAttributes.SpecialName;
						// TODO we should ensure that the getter method name doesn't clash with an existing method
						MethodBuilder getter = typeBuilder.DefineMethod("get_" + fld.Name, methodAttribs, CallingConventions.Standard, type, Type.EmptyTypes);
						AttributeHelper.HideFromReflection(getter);
						ILGenerator ilgen = getter.GetILGenerator();
						if(fld.IsVolatile)
						{
							ilgen.Emit(OpCodes.Volatile);
						}
						if(fld.IsStatic)
						{
							ilgen.Emit(OpCodes.Ldsfld, field);
						}
						else
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldfld, field);
						}
						ilgen.Emit(OpCodes.Ret);
						PropertyBuilder pb = typeBuilder.DefineProperty(fld.Name, PropertyAttributes.None, type, Type.EmptyTypes);
						pb.SetGetMethod(getter);
						CodeEmitter emitGet = CodeEmitter.Create(OpCodes.Call, getter);
						CodeEmitter emitSet = null;
						if(fld.IsVolatile)
						{
							emitSet += CodeEmitter.Volatile;
						}
						if(fld.IsStatic)
						{
							emitSet += CodeEmitter.Create(OpCodes.Stsfld, field);
						}
						else
						{
							emitSet += CodeEmitter.Create(OpCodes.Stfld, field);
						}
						fields[i] = FieldWrapper.Create(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), fld.Name, fld.Signature, fld.Modifiers, field, emitGet, emitSet);
					}
					else
					{
						fields[i] = FieldWrapper.Create(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), field, fld.Signature, fld.Modifiers);
					}
				}
				if(typeWrapper.IsUnloadable)
				{
					AttributeHelper.SetUnloadableType(field, typeWrapper.Name);
				}
				else if(typeWrapper.IsGhostArray)
				{
					// TODO we need to annotate the field so that we know the real type of the field (for reflection)
				}
				// if the Java modifiers cannot be expressed in .NET, we emit the Modifiers attribute to store
				// the Java modifiers
				if(setModifiers)
				{
					AttributeHelper.SetModifiers(field, fld.Modifiers);
				}
				if(JVM.IsStaticCompiler && fld.DeprecatedAttribute)
				{
					AttributeHelper.SetDeprecatedAttribute(field);
				}
			}
			finally
			{
				Profiler.Leave("JavaTypeImpl.GenerateField");
			}
		}

		public override MethodWrapper GetMethodImpl(MethodDescriptor md)
		{
			if(methodLookup == null)
			{
				methods = new MethodWrapper[classFile.Methods.Length];
				methodLookup = new Hashtable();
				for(int i = 0; i < classFile.Methods.Length; i++)
				{
					Profiler.Count("DynamicMethod");
					methodLookup[new MethodDescriptor(wrapper.GetClassLoader(), classFile.Methods[i])] = i;
				}
			}
			object index = methodLookup[md];
			if(index != null)
			{
				int i = (int)index;
				if(methods[i] == null)
				{
					GenerateMethod(i);
				}
				return methods[i];
			}
			return null;
		}

		private ConstructorBuilder DefineClassInitializer()
		{
			// NOTE we don't need to record the modifiers here, because they aren't visible from Java reflection
			// (well they might be visible from JNI reflection, but that isn't important enough to justify the custom attribute)
			if(!classFile.IsFinal && !classFile.IsInterface)
			{
				// We create a field that the derived classes can access in their .cctor to trigger our .cctor
				// (previously we used RuntimeHelpers.RunClassConstructor, but that is slow and requires additional privileges)
				FieldBuilder field = typeBuilder.DefineField("__<clinit>", typeof(int), FieldAttributes.SpecialName | FieldAttributes.Public | FieldAttributes.Static);
				AttributeHelper.HideFromReflection(field);
			}
			if(typeBuilder.IsInterface)
			{
				// LAMESPEC the ECMA spec says (part. I, sect. 8.5.3.2) that all interface members must be public, so we make
				// the class constructor public
				return typeBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
			}
			return typeBuilder.DefineTypeInitializer();
		}

		private void GenerateMethod(int index)
		{
			Profiler.Enter("JavaTypeImpl.GenerateMethod");
			try
			{
				Debug.Assert(methods[index] == null);
				// TODO things to consider when we support unloadable types on the argument list on return type:
				// - later on, the method can be overriden by a class that does have access to the type, so
				//   this should be detected and an appropriate override stub should be generated
				// - overloading might conflict with the generalised argument list (unloadable types appear
				//   as System.Object). The nicest way to solve this would be to emit a modreq attribute on the parameter,
				//   but Reflection.Emit doesn't support this, so we'll probably have to use a name mangling scheme
				MethodBase method;
				ClassFile.Method m = classFile.Methods[index];
				TypeWrapper[] argTypeWrappers = m.GetArgTypes(wrapper.GetClassLoader());
				TypeWrapper retTypeWrapper = m.GetRetType(wrapper.GetClassLoader());
				Type[] args = new Type[argTypeWrappers.Length];
				Type retType = retTypeWrapper.TypeAsParameterType;
				for(int i = 0; i < args.Length; i++)
				{
					args[i] = argTypeWrappers[i].TypeAsParameterType;
				}
				bool setModifiers = m.IsNative;
				MethodAttributes attribs = 0;
				if(m.IsAbstract)
				{
					// only if the classfile is abstract, we make the CLR method abstract, otherwise,
					// we have to generate a method that throws an AbstractMethodError (because the JVM
					// allows abstract methods in non-abstract classes)
					if(m.ClassFile.IsAbstract || m.ClassFile.IsInterface)
					{
						attribs |= MethodAttributes.Abstract;
					}
					else
					{
						setModifiers = true;
					}
				}
				if(m.IsFinal)
				{
					if(!m.IsStatic && !m.IsPrivate)
					{
						attribs |= MethodAttributes.Final;
					}
					else
					{
						setModifiers = true;
					}
				}
				if(m.IsPrivate)
				{
					attribs |= MethodAttributes.Private;
				}
				else if(m.IsProtected)
				{
					attribs |= MethodAttributes.FamORAssem;
				}
				else if(m.IsPublic)
				{
					attribs |= MethodAttributes.Public;
				}
				else
				{
					attribs |= MethodAttributes.Assembly;
				}
				if(m.IsStatic)
				{
					attribs |= MethodAttributes.Static;
				}
				if(m.Name == "<init>")
				{
					// NOTE we don't need to record the modifiers here, because only access modifiers are valid for
					// constructors and we have a well defined (reversible) mapping from them
					method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, args);
					ParameterBuilder[] parameterBuilders = null;
					if(JVM.IsStaticCompiler)
					{
						parameterBuilders = AddParameterNames(method, m);
					}
				}
				else if(m.IsClassInitializer)
				{
					method = DefineClassInitializer();
				}
				else
				{
					if(!m.IsPrivate && !m.IsStatic)
					{
						attribs |= MethodAttributes.Virtual | MethodAttributes.CheckAccessOnOverride;
					}
					string name = m.Name;
					MethodDescriptor md = new MethodDescriptor(wrapper.GetClassLoader(), m);
					// if a method is virtual, we need to find the method it overrides (if any), for several reasons:
					// - if we're overriding a method that has a different name (e.g. some of the virtual methods
					//   in System.Object [Equals <-> equals]) we need to add an explicit MethodOverride
					// - if one of the base classes has a similar method that is private (or package) that we aren't
					//   overriding, we need to specify an explicit MethodOverride
					MethodBase baseMethod = null;
					MethodWrapper baseMce = null;
					bool explicitOverride = false;
					if((attribs & MethodAttributes.Virtual) != 0 && !classFile.IsInterface)
					{
						TypeWrapper tw = wrapper.BaseTypeWrapper;
						while(tw != null)
						{
							baseMce = tw.GetMethodWrapper(md, true);
							if(baseMce == null)
							{
								break;
							}
							// here are the complex rules for determining whether this method overrides the method we found
							// RULE 1: final methods may not be overridden
							if(baseMce.IsFinal)
							{
								// NOTE we don't need to test for our method being private, because if it is
								// we'll never get here (because private methods aren't virtual)
								// TODO make sure the VerifyError is translated into a java.lang.VerifyError
								throw new VerifyError("final method " + baseMce.Name + baseMce.Descriptor.Signature + " in " + tw.Name + " is overriden in " + wrapper.Name);
							}
							// RULE 2: public & protected methods can be overridden (package methods are handled by RULE 4)
							// (by public, protected & *package* methods [even if they are in a different package])
							if(baseMce.IsPublic || baseMce.IsProtected)
							{
								// if we already encountered a package method, we cannot override the base method of
								// that package method
								if(explicitOverride)
								{
									explicitOverride = false;
									break;
								}
								baseMethod = baseMce.GetMethod();
								break;
							}
							// RULE 3: private methods are ignored
							if(!baseMce.IsPrivate)
							{
								// RULE 4: package methods can only be overridden in the same package
								if(baseMce.DeclaringType.IsInSamePackageAs(wrapper))
								{
									baseMethod = baseMce.GetMethod();
									break;
								}
								// since we encountered a method with the same name/signature that we aren't overriding,
								// we need to specify an explicit override
								// NOTE we only do this if baseMce isn't private, because if it is, Reflection.Emit
								// will complain about the explicit MethodOverride (possibly a bug)
								explicitOverride = true;
							}
							tw = baseMce.DeclaringType.BaseTypeWrapper;
						}
						if(baseMethod == null)
						{
							// we need set NewSlot here, to prevent accidentally overriding methods
							// (for example, if a Java class has a method "boolean Equals(object)", we don't want that method
							// to override System.Object.Equals)
							// Unless, of course, we're implementing an inherited interface method (the miranda method might not
							// have been created at this point, because that happens during the finishing of our base class)
							// TODO a better way to fix this would be to move Miranda method creation from Finish to GetMethodImpl
							if(wrapper.BaseTypeWrapper == null || !IsInterfaceMethod(wrapper.BaseTypeWrapper, md))
							{
								attribs |= MethodAttributes.NewSlot;
							}
						}
						else
						{
							// if we have a method overriding a more accessible method (yes, this does work), we need to make the
							// method more accessible, because otherwise the CLR will complain that we're reducing access)
							if((baseMethod.IsPublic && !m.IsPublic) ||
								(baseMethod.IsFamily && !m.IsPublic && !m.IsProtected) ||
								(!m.IsPublic && !m.IsProtected && !baseMce.DeclaringType.IsInSamePackageAs(wrapper)))
							{
								attribs &= ~MethodAttributes.MemberAccessMask;
								attribs |= baseMethod.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
								setModifiers = true;
							}
						}
					}
					MethodBuilder mb;
					if(typeBuilderGhostInterface != null)
					{
						mb = typeBuilderGhostInterface.DefineMethod(name, attribs, retType, args);
					}
					else
					{
						bool needFinalize = false;
						bool needDispatch = false;
						if(baseMethod != null && md.Name == "finalize" && md.Signature == "()V")
						{
							if(baseMethod.Name == "Finalize")
							{
								baseMethod = null;
								attribs |= MethodAttributes.NewSlot;
								needFinalize = true;
								needDispatch = true;
							}
							else if(baseMethod.DeclaringType == CoreClasses.java.lang.Object.Wrapper.TypeAsBaseType)
							{
								needFinalize = true;
								needDispatch = true;
							}
							else if(m.IsFinal)
							{
								needFinalize = true;
								needDispatch = false;
							}
						}
						mb = typeBuilder.DefineMethod(name, attribs, retType, args);
						// if we're overriding java.lang.Object.finalize we need to emit a stub to override System.Object.Finalize,
						// or if we're subclassing a non-Java class that has a Finalize method, we need a new Finalize override
						if(needFinalize)
						{
							MethodInfo baseFinalize = typeBuilder.BaseType.GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
							MethodAttributes attr = MethodAttributes.Virtual;
							// make sure we don't reduce accessibility
							attr |= baseFinalize.IsPublic ? MethodAttributes.Public : MethodAttributes.Family;
							if(m.IsFinal)
							{
								attr |= MethodAttributes.Final;
							}
							MethodBuilder finalize = typeBuilder.DefineMethod("Finalize", attr, CallingConventions.Standard, typeof(void), Type.EmptyTypes);
							AttributeHelper.HideFromReflection(finalize);
							ILGenerator ilgen = finalize.GetILGenerator();
							if(needDispatch)
							{
								ilgen.BeginExceptionBlock();
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Callvirt, mb);
								ilgen.BeginCatchBlock(typeof(object));
								ilgen.EndExceptionBlock();
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Call, baseFinalize);
							}
							ilgen.Emit(OpCodes.Ret);
						}
					}
					ParameterBuilder[] parameterBuilders = null;
					if(JVM.IsStaticCompiler)
					{
						parameterBuilders = AddParameterNames(mb, m);
					}
					if(setModifiers)
					{
						AttributeHelper.SetModifiers(mb, m.Modifiers);
					}
					// if we're public and we're overriding a method that is not public, then we might be also
					// be implementing an interface method that has an IllegalAccessError stub
					// Example:
					//   class Base {
					//     protected void Foo() {}
					//   }
					//   interface IFoo {
					//     public void Foo();
					//   }
					//   class Derived extends Base implements IFoo {
					//   }
					//   class MostDerived extends Derived {
					//     public void Foo() {} 
					//   }
					// TODO this implementation isn't correct. I need to find out what happens for the following:
					//   class Base {
					//     public void Foo() {}
					//   }
					//   interface IFoo {
					//     public void Foo() {}
					//   }
					//   class Derived extends Base implements IFoo {
					//   }
					//   class MostDerived extends Derived {
					//     protected void Foo() {}
					//   }
					if(wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasIncompleteInterfaceImplementation)
					{
						Hashtable hashtable = null;
						TypeWrapper tw = wrapper.BaseTypeWrapper;
						while(tw.HasIncompleteInterfaceImplementation)
						{
							foreach(TypeWrapper iface in tw.Interfaces)
							{
								AddMethodOverride(typeBuilder, mb, iface, md, ref hashtable);
							}
							tw = tw.BaseTypeWrapper;
						}
					}
					method = mb;
					// since Java constructors aren't allowed to be synchronized, we only check this here
					if(m.IsSynchronized && !m.IsStatic)
					{
						// NOTE for static methods we cannot get by with setting the MethodImplAttributes.Synchronized flag,
						// we actually need to emit code to lock the Class object!
						mb.SetImplementationFlags(method.GetMethodImplementationFlags() | MethodImplAttributes.Synchronized);
					}
					if(baseMethod != null && (explicitOverride || baseMethod.Name != name))
					{
						// assert that the method we're overriding is in fact virtual and not final!
						Debug.Assert(baseMethod.IsVirtual && !baseMethod.IsFinal);
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethod);
					}
				}
				if(retTypeWrapper.IsUnloadable)
				{
					CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { retTypeWrapper.Name });
					// NOTE since DefineParameter(0, ...) throws an exception (bug in .NET, I believe),
					// we attach the attribute to the method instead of the return value
					((MethodBuilder)method).SetCustomAttribute(attrib);
				}
				for(int i = 0; i < argTypeWrappers.Length; i++)
				{
					if(argTypeWrappers[i].IsUnloadable)
					{
						CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { argTypeWrappers[i].Name });
						if(method is MethodBuilder)
						{
							((MethodBuilder)method).DefineParameter(i + 1, ParameterAttributes.None, null).SetCustomAttribute(attrib);
						}
						else
						{
							((ConstructorBuilder)method).DefineParameter(i + 1, ParameterAttributes.None, null).SetCustomAttribute(attrib);
						}
					}
				}
				string[] exceptions = m.ExceptionsAttribute;
				AttributeHelper.SetThrowsAttribute(method, exceptions);
				methods[index] = MethodWrapper.Create(wrapper, new MethodDescriptor(wrapper.GetClassLoader(), m), method, method, m.Modifiers, false);
				methods[index].SetDeclaredExceptions(exceptions);
				if(JVM.IsStaticCompiler && m.DeprecatedAttribute)
				{
					AttributeHelper.SetDeprecatedAttribute(method);
				}
			}
			finally
			{
				Profiler.Leave("JavaTypeImpl.GenerateMethod");
			}
		}

		private static ParameterBuilder[] AddParameterNames(MethodBase mb, ClassFile.Method m)
		{
			if(m.CodeAttribute != null)
			{
				ClassFile.Method.LocalVariableTableEntry[] localVars = m.CodeAttribute.LocalVariableTableAttribute;
				if(localVars != null)
				{
					int bias = 1;
					if(m.IsStatic)
					{
						bias = 0;
					}
					ParameterBuilder[] parameterBuilders = new ParameterBuilder[m.CodeAttribute.ArgMap.Length - bias];
					for(int i = bias; i < m.CodeAttribute.ArgMap.Length; i++)
					{
						if(m.CodeAttribute.ArgMap[i] != -1)
						{
							for(int j = 0; j < localVars.Length; j++)
							{
								if(localVars[j].index == i && parameterBuilders[i - bias] == null)
								{
									if(mb is MethodBuilder)
									{
										parameterBuilders[i - bias] = ((MethodBuilder)mb).DefineParameter(m.CodeAttribute.ArgMap[i] + 1 - bias, ParameterAttributes.None, localVars[j].name);
									}
									else if(mb is ConstructorBuilder)
									{
										parameterBuilders[i - bias] = ((ConstructorBuilder)mb).DefineParameter(m.CodeAttribute.ArgMap[i], ParameterAttributes.None, localVars[j].name);
									}
									break;
								}
							}
						}
					}
					return parameterBuilders;
				}
			}
			return null;
		}

		private static bool IsInterfaceMethod(TypeWrapper wrapper, MethodDescriptor md)
		{
			foreach(TypeWrapper iface in wrapper.Interfaces)
			{
				if(iface.GetMethodWrapper(md, false) != null || IsInterfaceMethod(iface, md))
				{
					return true;
				}
			}
			return false;
		}

		private static void AddMethodOverride(TypeBuilder typeBuilder, MethodBuilder mb, TypeWrapper iface, MethodDescriptor md, ref Hashtable hashtable)
		{
			if(hashtable != null && hashtable.ContainsKey(iface))
			{
				return;
			}
			MethodWrapper mw = iface.GetMethodWrapper(md, false);
			if(mw != null)
			{
				if(hashtable == null)
				{
					hashtable = new Hashtable();
				}
				hashtable.Add(iface, iface);
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
			}
			foreach(TypeWrapper iface2 in iface.Interfaces)
			{
				AddMethodOverride(typeBuilder, mb, iface2, md, ref hashtable);
			}
		}

		public override Type Type
		{
			get
			{
				return typeBuilder;
			}
		}

		internal override Type TypeAsBaseType
		{
			get
			{
				return typeBuilderGhostInterface != null ? typeBuilderGhostInterface : typeBuilder;
			}
		}
	}

	private class FinishedTypeImpl : DynamicImpl
	{
		private Type type;
		private Type typeGhostInterface;
		private TypeWrapper[] innerclasses;
		private TypeWrapper declaringTypeWrapper;
		private Modifiers reflectiveModifiers;

		public FinishedTypeImpl(Type type, Type typeGhostInterface, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers)
		{
			this.type = type;
			this.typeGhostInterface = typeGhostInterface;
			this.innerclasses = innerclasses;
			this.declaringTypeWrapper = declaringTypeWrapper;
			this.reflectiveModifiers = reflectiveModifiers;
		}

		public override TypeWrapper[] InnerClasses
		{
			get
			{
				// TODO compute the innerclasses lazily (and fix JavaTypeImpl to not always compute them)
				return innerclasses;
			}
		}

		public override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				// TODO compute lazily (and fix JavaTypeImpl to not always compute it)
				return declaringTypeWrapper;
			}
		}

		public override Modifiers ReflectiveModifiers
		{
			get
			{
				return reflectiveModifiers;
			}
		}

		public override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
		{
			return null;
		}
	
		public override MethodWrapper GetMethodImpl(MethodDescriptor md)
		{
			return null;
		}

		public override Type Type
		{
			get
			{
				return type;
			}
		}

		internal override Type TypeAsBaseType
		{
			get
			{
				return typeGhostInterface != null ? typeGhostInterface : type;
			}
		}

		public override DynamicImpl Finish()
		{
			return this;
		}
	}

	internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
	{
		if(IsGhost)
		{
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Call, ghostCastMethod);
			ilgen.Emit(OpCodes.Pop);
		}
		else if(IsGhostArray)
		{
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Call, ghostCastArrayMethod);
		}
		else
		{
			base.EmitCheckcast(context, ilgen);
		}
	}

	internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
	{
		if(IsGhost)
		{
			ilgen.Emit(OpCodes.Call, ghostIsInstanceMethod);
		}
		else if(IsGhostArray)
		{
			ilgen.Emit(OpCodes.Call, ghostIsInstanceArrayMethod);
		}
		else
		{
			base.EmitInstanceOf(context, ilgen);
		}
	}
}

// TODO this is the base class of CompiledTypeWrapper (ikmvc compiled Java types)
// and DotNetTypeWrapper (.NET types), it should have a better name.
abstract class LazyTypeWrapper : TypeWrapper
{
	private bool membersPublished;

	protected LazyTypeWrapper(Modifiers modifiers, string name, TypeWrapper baseTypeWrapper, ClassLoaderWrapper classLoader)
		: base(modifiers, name, baseTypeWrapper, classLoader)
	{
	}

	protected abstract void LazyPublishMembers();

	protected sealed override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				LazyPublishMembers();
				return GetFieldWrapper(fieldName, fieldType);
			}
		}
		return null;
	}

	protected sealed override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				LazyPublishMembers();
				return GetMethodWrapper(md, false);
			}
		}
		return null;
	}

	internal sealed override void Finish()
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				LazyPublishMembers();
			}
		}
	}
}

class CompiledTypeWrapper : LazyTypeWrapper
{
	private readonly Type type;
	private TypeWrapper[] interfaces;
	private TypeWrapper[] innerclasses;
	private FieldInfo ghostRefField;
	private Type typeAsBaseType;
	private Type remappedType;

	internal static string GetName(Type type)
	{
		Debug.Assert(type.Module.IsDefined(typeof(JavaModuleAttribute), false));

		// look for our custom attribute, that contains the real name of the type (for inner classes)
		Object[] attribs = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
		if(attribs.Length == 1)
		{
			return ((InnerClassAttribute)attribs[0]).InnerClassName;
		}
		return type.FullName;
	}

	// TODO consider resolving the baseType lazily
	private static TypeWrapper GetBaseTypeWrapper(Type type)
	{
		if(type.IsInterface || type.IsDefined(typeof(GhostInterfaceAttribute), false))
		{
			return null;
		}
		else if(type.BaseType == null)
		{
			// System.Object must appear to be derived from java.lang.Object
			return CoreClasses.java.lang.Object.Wrapper;
		}
		else
		{
			object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
			if(attribs.Length == 1)
			{
				if(((RemappedTypeAttribute)attribs[0]).Type == typeof(object))
				{
					return null;
				}
				else
				{
					return CoreClasses.java.lang.Object.Wrapper;
				}
			}
			return ClassLoaderWrapper.GetWrapperFromType(type.BaseType);
		}
	}

	internal CompiledTypeWrapper(string name, Type type)
		: base(GetModifiers(type), name, GetBaseTypeWrapper(type), ClassLoaderWrapper.GetBootstrapClassLoader())
	{
		Debug.Assert(!(type is TypeBuilder));
		Debug.Assert(!type.IsArray);

		object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
		if(attribs.Length == 1)
		{
			this.typeAsBaseType = type;
			this.remappedType = ((RemappedTypeAttribute)attribs[0]).Type;
		}

		this.type = type;
	}

	private static Modifiers GetModifiers(Type type)
	{
		object[] customAttribute = type.GetCustomAttributes(typeof(ModifiersAttribute), false);
		if(customAttribute.Length == 1)
		{
			return ((ModifiersAttribute)customAttribute[0]).Modifiers;
		}
		// only returns public, protected, private, final, static, abstract and interface (as per
		// the documentation of Class.getModifiers())
		Modifiers modifiers = 0;
		if(type.IsPublic)
		{
			modifiers |= Modifiers.Public;
		}
		// TODO do we really need to look for nested attributes? I think all inner classes will have the ModifiersAttribute.
		else if(type.IsNestedPublic)
		{
			modifiers |= Modifiers.Public | Modifiers.Static;
		}
		else if(type.IsNestedPrivate)
		{
			modifiers |= Modifiers.Private | Modifiers.Static;
		}
		else if(type.IsNestedFamily || type.IsNestedFamORAssem)
		{
			modifiers |= Modifiers.Protected | Modifiers.Static;
		}
		else if(type.IsNestedAssembly || type.IsNestedFamANDAssem)
		{
			modifiers |= Modifiers.Static;
		}

		if(type.IsSealed)
		{
			modifiers |= Modifiers.Final;
		}
		if(type.IsAbstract)
		{
			modifiers |= Modifiers.Abstract;
		}
		if(type.IsInterface)
		{
			modifiers |= Modifiers.Interface;
		}
		return modifiers;
	}

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			if(interfaces == null)
			{
				// NOTE instead of getting the interfaces list from Type, we use a custom
				// attribute to list the implemented interfaces, because Java reflection only
				// reports the interfaces *directly* implemented by the type, not the inherited
				// interfaces. This is significant for serialVersionUID calculation (for example).
				object[] attribs = type.GetCustomAttributes(typeof(ImplementsAttribute), false);
				if(attribs.Length == 1)
				{
					string[] interfaceNames = ((ImplementsAttribute)attribs[0]).Interfaces;
					TypeWrapper[] interfaceWrappers = new TypeWrapper[interfaceNames.Length];
					for(int i = 0; i < interfaceWrappers.Length; i++)
					{
						interfaceWrappers[i] = GetClassLoader().LoadClassByDottedName(interfaceNames[i]);
					}
					this.interfaces = interfaceWrappers;
				}
				else
				{
					interfaces = TypeWrapper.EmptyArray;
				}
			}
			return interfaces;
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			if(innerclasses == null)
			{
				Type[] nestedTypes = type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly);
				ArrayList wrappers = new ArrayList();
				for(int i = 0; i < nestedTypes.Length; i++)
				{
					if(!nestedTypes[i].IsDefined(typeof(HideFromReflectionAttribute), false))
					{
						wrappers.Add(ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]));
					}
				}
				innerclasses = (TypeWrapper[])wrappers.ToArray(typeof(TypeWrapper));
			}
			return innerclasses;
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			Type declaringType = type.DeclaringType;
			if(declaringType != null)
			{
				return ClassLoaderWrapper.GetWrapperFromType(declaringType);
			}
			return null;
		}
	}

	internal override Modifiers ReflectiveModifiers
	{
		get
		{
			object[] customAttribute = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
			if(customAttribute.Length == 1)
			{
				return ((InnerClassAttribute)customAttribute[0]).Modifiers;
			}
			return Modifiers;
		}
	}

	internal override Type TypeAsBaseType
	{
		get
		{
			if(typeAsBaseType == null)
			{
				if(IsGhost)
				{
					typeAsBaseType = type.GetNestedType("__Interface");
				}
				else
				{
					typeAsBaseType = type;
				}
			}
			return typeAsBaseType;
		}
	}

	internal override FieldInfo GhostRefField
	{
		get
		{
			if(ghostRefField == null)
			{
				ghostRefField = type.GetField("__ref");
			}
			return ghostRefField;
		}
	}

	protected override void LazyPublishMembers()
	{
		MemberInfo[] members = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
		if(remappedType == null)
		{
			foreach(MemberInfo m in members)
			{
				if(!m.IsDefined(typeof(HideFromReflectionAttribute), false))
				{
					MethodBase method = m as MethodBase;
					if(method != null)
					{
						AddMethod(CreateMethodWrapper(method));
					}
					else
					{
						FieldInfo field = m as FieldInfo;
						if(field != null)
						{
							AddField(CreateFieldWrapper(field));
						}
					}
				}
			}
		}
		else
		{
			foreach(MemberInfo m in members)
			{
				if(!m.IsDefined(typeof(HideFromReflectionAttribute), false))
				{
					MethodBase method = m as MethodBase;
					if(method != null &&
						(remappedType.IsSealed || !m.Name.StartsWith("instancehelper_")) &&
						(!remappedType.IsSealed || method.IsStatic))
					{
						AddMethod(CreateRemappedMethodWrapper(method));
					}
					else
					{
						FieldInfo field = m as FieldInfo;
						if(field != null)
						{
							AddField(CreateFieldWrapper(field));
						}
					}
				}
			}
			// if we're a remapped interface, we need to get the methods from the real interface
			if(remappedType.IsInterface)
			{
				foreach(RemappedInterfaceMethodAttribute m in type.GetCustomAttributes(typeof(RemappedInterfaceMethodAttribute), false))
				{
					MethodInfo method = remappedType.GetMethod(m.MappedTo);
					Modifiers modifiers = AttributeHelper.GetModifiers(method, false);
					MethodDescriptor md = MethodDescriptor.FromMethodBase(method);
					md = MethodDescriptor.FromNameSig(GetClassLoader(), m.Name, md.Signature);
					MethodWrapper mw = new MethodWrapper(this, md, method, null, modifiers, false);
					mw.EmitCall = CodeEmitter.InternalError;
					mw.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, method);
					mw.EmitNewobj = CodeEmitter.InternalError;
					AddMethod(mw);
				}
			}
		}
	}

	private MethodWrapper CreateRemappedMethodWrapper(MethodBase mb)
	{
		bool instancehelper = false;
		Modifiers modifiers = AttributeHelper.GetModifiers(mb, false);
		MethodDescriptor md = MethodDescriptor.FromMethodBase(mb);
		if(md.Name.StartsWith("instancehelper_"))
		{
			instancehelper = true;
			string sig = md.Signature;
			md = MethodDescriptor.FromNameSig(GetClassLoader(), md.Name.Substring(15), "(" + sig.Substring(sig.IndexOf(';') + 1));
			modifiers &= ~Modifiers.Static;
		}
		else if(md.Name == "newhelper")
		{
			string sig = md.Signature;
			md = MethodDescriptor.FromNameSig(GetClassLoader(), "<init>", sig.Substring(0, sig.LastIndexOf(')')) + ")V");
			modifiers &= ~Modifiers.Static;
		}
		MethodWrapper method = new MethodWrapper(this, md, mb, null, modifiers, false);
		if(mb is ConstructorInfo)
		{
			method.EmitCallvirt = CodeEmitter.InternalError;
			method.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)mb);
			method.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)mb);
		}
		else
		{
			if(mb.IsStatic)
			{
				if(mb.Name == "newhelper")
				{
					method.EmitCall = CodeEmitter.InternalError;
					method.EmitCallvirt = CodeEmitter.InternalError;
					method.EmitNewobj = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
				}
				else
				{
					if(instancehelper)
					{
						method.EmitCall = CodeEmitter.InternalError;
						method.EmitCallvirt = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
						method.EmitNewobj = CodeEmitter.InternalError;
					}
					else
					{
						method.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
						method.EmitCallvirt = CodeEmitter.InternalError;
						method.EmitNewobj = CodeEmitter.InternalError;
					}
				}
			}
			else
			{
				method.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
				ParameterInfo[] parameters = mb.GetParameters();
				Type[] argTypes = new Type[parameters.Length + 1];
				argTypes[0] = remappedType;
				for(int i = 0; i < parameters.Length; i++)
				{
					argTypes[i + 1] = parameters[i].ParameterType;
				}
				MethodInfo helper = type.GetMethod("instancehelper_" + mb.Name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static, null, argTypes, null);
				if(helper != null)
				{
					method.EmitCallvirt = CodeEmitter.Create(OpCodes.Call, helper);
				}
				else
				{
					method.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)mb);
				}
				method.EmitNewobj = CodeEmitter.InternalError;
			}
		}
		return method;
	}

	private MethodWrapper CreateMethodWrapper(MethodBase mb)
	{
		MethodDescriptor md = MethodDescriptor.FromMethodBase(mb);
		MethodWrapper method = new MethodWrapper(this, md, mb, null, AttributeHelper.GetModifiers(mb, false), false);
		if(IsGhost)
		{
			method.EmitCall = CodeEmitter.InternalError;
			method.EmitCallvirt = new MethodWrapper.GhostCallEmitter(this, md, mb);
			method.EmitNewobj = CodeEmitter.InternalError;
		}
		else
		{
			if(mb is ConstructorInfo)
			{
				method.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)mb);
				method.EmitCallvirt = CodeEmitter.InternalError;
				method.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)mb);
			}
			else
			{
				method.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
				if(!mb.IsStatic)
				{
					method.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)mb);
				}
				else
				{
					method.EmitCallvirt = CodeEmitter.InternalError;
				}
				method.EmitNewobj = CodeEmitter.InternalError;
			}
		}
		return method;
	}

	private FieldWrapper CreateFieldWrapper(FieldInfo field)
	{
		MethodInfo getter = null;
		Modifiers modifiers = AttributeHelper.GetModifiers(field, false);

		// If the backing field is private, but the modifiers aren't, we've got a static final that
		// has a property accessor method.
		if(field.IsPrivate && ((modifiers & Modifiers.Private) == 0))
		{
			BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public;
			bindingFlags |= field.IsStatic ? BindingFlags.Static : BindingFlags.Instance;
			PropertyInfo prop = field.DeclaringType.GetProperty(field.Name, bindingFlags, null, field.FieldType, Type.EmptyTypes, null);
			Debug.Assert(prop != null);
			if(prop != null)
			{
				getter = prop.GetGetMethod(true);
			}
		}

		CodeEmitter emitGet;
		CodeEmitter emitSet;
		if((modifiers & Modifiers.Private) != 0)
		{
			// there is no way to emit code to access a private member, so we don't need to generate these
			emitGet = CodeEmitter.InternalError;
			emitSet = CodeEmitter.InternalError;
		}
		else if(field.IsLiteral)
		{
			if((modifiers & Modifiers.Static) == 0)
			{
				throw new InvalidOperationException("Invalid assembly, a non-static literal field was encountered.");
			}
			// if field is a literal, we must emit an ldc instead of a ldsfld
			emitGet = CodeEmitter.CreateLoadConstantField(field);
			// it is never legal to emit code to set a final field (from outside the class)
			emitSet = CodeEmitter.InternalError;
		}
		else if((modifiers & Modifiers.Static) != 0)
		{
			if(getter != null)
			{
				emitGet = CodeEmitter.Create(OpCodes.Call, getter);
			}
			else
			{
				emitGet = CodeEmitter.Create(OpCodes.Ldsfld, field);
			}
			emitSet = CodeEmitter.Create(OpCodes.Stsfld, field);
		}
		else
		{
			if(getter != null)
			{
				emitGet = CodeEmitter.Create(OpCodes.Callvirt, getter);
			}
			else
			{
				emitGet = CodeEmitter.Create(OpCodes.Ldfld, field);
			}
			emitSet = CodeEmitter.Create(OpCodes.Stfld, field);
		}
		// if the field name is mangled (because its type is unloadable), chop off the mangled bit
		string fieldName = field.Name;
		int idx = fieldName.IndexOf('/');
		if(idx >= 0)
		{
			fieldName = fieldName.Substring(0, idx);
		}
		return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(field.FieldType), fieldName, MethodDescriptor.GetFieldSigName(field), modifiers, field, emitGet, emitSet);
	}

	internal override bool IsGhost
	{
		get
		{
			return type.IsDefined(typeof(GhostInterfaceAttribute), false);
		}
	}

	internal override bool IsRemapped
	{
		get
		{
			return remappedType != null;
		}
	}

	internal override Type TypeAsTBD
	{
		get
		{
			return remappedType != null ? remappedType : type;
		}
	}

	internal override bool IsMapUnsafeException
	{
		get
		{
			return type.IsDefined(typeof(ExceptionIsUnsafeForMappingAttribute), false);
		}
	}
}

class DotNetTypeWrapper : LazyTypeWrapper
{
	private const string NamePrefix = "cli.";
	private const string DelegateInterfaceSuffix = "$Method";
	private readonly Type type;
	private TypeWrapper[] innerClasses;
	private TypeWrapper outerClass;

	private static Modifiers GetModifiers(Type type)
	{
		Modifiers modifiers = 0;
		if(type.IsPublic)
		{
			modifiers |= Modifiers.Public;
		}
		else if(type.IsNestedPublic)
		{
			modifiers |= Modifiers.Public | Modifiers.Static;
		}
		else if(type.IsNestedPrivate)
		{
			modifiers |= Modifiers.Private | Modifiers.Static;
		}
		else if(type.IsNestedFamily || type.IsNestedFamORAssem)
		{
			modifiers |= Modifiers.Protected | Modifiers.Static;
		}
		else if(type.IsNestedAssembly || type.IsNestedFamANDAssem)
		{
			modifiers |= Modifiers.Static;
		}

		if(type.IsSealed)
		{
			modifiers |= Modifiers.Final;
		}
		if(type.IsAbstract)
		{
			modifiers |= Modifiers.Abstract;
		}
		if(type.IsInterface)
		{
			modifiers |= Modifiers.Interface;
		}
		return modifiers;
	}

	// NOTE when this is called on a remapped type, the "warped" underlying type name is returned.
	// E.g. GetName(typeof(object)) returns "cli.System.Object".
	internal static string GetName(Type type)
	{
		Debug.Assert(!type.IsArray && !type.Module.IsDefined(typeof(JavaModuleAttribute), false));

		if(type.IsDefined(typeof(NoPackagePrefixAttribute), false) || type.Assembly.IsDefined(typeof(NoPackagePrefixAttribute), false))
		{
			// TODO figure out if this is even required
			return type.FullName.Replace('+', '$');
		}

		return MangleTypeName(type.FullName);
	}

	private static string MangleTypeName(string name)
	{
		// TODO a fully reversible name mangling should be used (all characters not supported by Java should be escaped)
		return NamePrefix + name.Replace('+', '$');
	}

	private static string DemangleTypeName(string name)
	{
		Debug.Assert(name.StartsWith(NamePrefix));
		// TODO a fully reversible name mangling should be used (all characters not supported by Java should be escaped)
		name = name.Substring(NamePrefix.Length);
		if(name.EndsWith(DelegateInterfaceSuffix))
		{
			// HACK if we're a delegate nested type, don't replace the $ sign
			return name;
		}
		return name.Replace('$', '+');
	}

	// this method should only be called once for each name, it doesn't do any caching or duplicate prevention
	internal static TypeWrapper LoadDotNetTypeWrapper(string name)
	{
		bool prefixed = name.StartsWith(NamePrefix);
		if(prefixed)
		{
			name = DemangleTypeName(name);
		}
		Type type = LoadTypeFromLoadedAssemblies(name);
		if(type != null)
		{
			if(prefixed || type.IsDefined(typeof(NoPackagePrefixAttribute), false) || type.Assembly.IsDefined(typeof(NoPackagePrefixAttribute), false))
			{
				return new DotNetTypeWrapper(type);
			}
		}
		if(name.EndsWith(DelegateInterfaceSuffix))
		{
			Type delegateType = LoadTypeFromLoadedAssemblies(name.Substring(0, name.Length - DelegateInterfaceSuffix.Length));
			if(delegateType != null && delegateType.IsSubclassOf(typeof(Delegate)))
			{
				ModuleBuilder moduleBuilder = ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder;
				TypeBuilder typeBuilder = moduleBuilder.DefineType(NamePrefix + name, TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract);
				AttributeHelper.SetInnerClass(typeBuilder, NamePrefix + name, NamePrefix + delegateType.FullName, "Method", Modifiers.Public | Modifiers.Interface | Modifiers.Static | Modifiers.Abstract);
				MethodInfo invoke = delegateType.GetMethod("Invoke");
				if(invoke != null)
				{
					ParameterInfo[] parameters = invoke.GetParameters();
					Type[] args = new Type[parameters.Length];
					for(int i = 0; i < args.Length; i++)
					{
						// HACK if the delegate has pointer args, we cannot handle them, but it is already
						// too late to refuse to load the class, so we replace pointers with IntPtr.
						// This is not a solution, because if the delegate would be instantiated the generated
						// code would be invalid.
						if(parameters[i].ParameterType.IsPointer)
						{
							args[i] = typeof(IntPtr);
						}
						else
						{
							args[i] = parameters[i].ParameterType;
						}
					}
					typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Abstract | MethodAttributes.Virtual, CallingConventions.Standard, invoke.ReturnType, args);
					return new CompiledTypeWrapper(NamePrefix + name, typeBuilder.CreateType());
				}
			}
		}
		return null;
	}

	private static Type LoadTypeFromLoadedAssemblies(string name)
	{
		foreach(Assembly a in AppDomain.CurrentDomain.GetAssemblies())
		{
			// HACK we also look inside Java assemblies, because precompiled delegate interfaces might have ended up there
			if(!(a is AssemblyBuilder))
			{
				Type t = a.GetType(name);
				if(t != null)
				{
					return t;
				}
				// HACK we might be looking for an inner classes
				// (if we remove the mangling of NoPackagePrefix types from GetName, we don't need this anymore)
				t = a.GetType(name.Replace('$', '+'));
				if(t != null)
				{
					return t;
				}
			}
		}
		return null;
	}

	private static TypeWrapper GetBaseTypeWrapper(Type type)
	{
		if(type.IsInterface)
		{
			return null;
		}
		else if(ClassLoaderWrapper.IsRemappedType(type))
		{
			// Remapped types extend their alter ego
			// (e.g. cli.System.Object must appear to be derived from java.lang.Object)
			// except when they're sealed, of course.
			if(type.IsSealed)
			{
				return CoreClasses.java.lang.Object.Wrapper;
			}
			return ClassLoaderWrapper.GetWrapperFromType(type);
		}
		else
		{
			return ClassLoaderWrapper.GetWrapperFromType(type.BaseType);
		}
	}

	internal DotNetTypeWrapper(Type type)
		: base(GetModifiers(type), GetName(type), GetBaseTypeWrapper(type), ClassLoaderWrapper.GetBootstrapClassLoader())
	{
		Debug.Assert(!(type.IsByRef), type.FullName);
		Debug.Assert(!(type.IsPointer), type.FullName);
		Debug.Assert(!(type.IsArray), type.FullName);
		Debug.Assert(!(type is TypeBuilder), type.FullName);
		Debug.Assert(!(type.Module.IsDefined(typeof(JavaModuleAttribute), false)));

		this.type = type;
	}

	private class DelegateMethodWrapper : MethodWrapper
	{
		internal DelegateMethodWrapper(TypeWrapper declaringType, MethodDescriptor md)
			: base(declaringType, md, null, null, Modifiers.Public, false)
		{
		}

		internal override object Invoke(object obj, object[] args, bool nonVirtual)
		{
			// TODO map exceptions
			return Delegate.CreateDelegate(DeclaringType.TypeAsTBD, args[0], "Invoke");
		}
	}

	private class ByRefMethodWrapper : MethodWrapper
	{
		private bool[] byrefs;

		internal ByRefMethodWrapper(bool[] byrefs, TypeWrapper declaringType, MethodDescriptor md, MethodBase originalMethod, MethodBase method, Modifiers modifiers, bool hideFromReflection)
			: base(declaringType, md, originalMethod, method, modifiers, hideFromReflection)
		{
			this.byrefs = byrefs;
		}

		internal override object Invoke(object obj, object[] args, bool nonVirtual)
		{
			object[] newargs = (object[])args.Clone();
			for(int i = 0; i < newargs.Length; i++)
			{
				if(byrefs[i])
				{
					newargs[i] = ((Array)args[i]).GetValue(0);
				}
			}
			try
			{
				return base.Invoke(obj, newargs, nonVirtual);
			}
			finally
			{
				for(int i = 0; i < newargs.Length; i++)
				{
					if(byrefs[i])
					{
						((Array)args[i]).SetValue(newargs[i], 0);
					}
				}
			}
		}
	}

	private static bool IsVisible(Type type)
	{
		return type.IsPublic || (type.IsNestedPublic && IsVisible(type.DeclaringType));
	}

	protected override void LazyPublishMembers()
	{
		// special support for enums
		if(type.IsEnum)
		{
			// TODO handle unsigned underlying type
			TypeWrapper fieldType = ClassLoaderWrapper.GetWrapperFromType(Enum.GetUnderlyingType(type));
			FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Static);
			for(int i = 0; i < fields.Length; i++)
			{
				if(fields[i].FieldType == type)
				{
					// TODO handle name/signature clash
					AddField(FieldWrapper.Create(this, fieldType, fields[i].Name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], CodeEmitter.CreateLoadConstantField(fields[i]), CodeEmitter.Pop));
				}
			}
			// NOTE if the reference on the stack is null, we *want* the NullReferenceException, so we don't use TypeWrapper.EmitUnbox
			CodeEmitter getter = CodeEmitter.Create(OpCodes.Unbox, type) + CodeEmitter.Create(OpCodes.Ldobj, type);
			CodeEmitter setter = CodeEmitter.Pop + CodeEmitter.Pop;
			FieldWrapper fw = FieldWrapper.Create(this, fieldType, "Value", fieldType.SigName, Modifiers.Public | Modifiers.Final, null, getter, setter);
			AddField(fw);
			MethodWrapper mw = new MethodWrapper(this, MethodDescriptor.FromNameSig(GetClassLoader(), "wrap", "(" + fieldType.SigName + ")" + this.SigName), null, null, Modifiers.Static | Modifiers.Public, false);
			// NOTE we don't support custom boxing rules for enums
			mw.EmitCall = CodeEmitter.Create(OpCodes.Box, type);
			AddMethod(mw);
		}
		else
		{
			FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			for(int i = 0; i < fields.Length; i++)
			{
				// TODO for remapped types, instance fields need to be converted to static getter/setter methods
				if(fields[i].FieldType.IsPointer)
				{
					// skip, pointer fields are not supported
				}
				else
				{
					// TODO handle name/signature clash
					AddField(CreateFieldWrapper(AttributeHelper.GetModifiers(fields[i], true), fields[i].Name, fields[i].FieldType, fields[i], null));
				}
			}

			// special case for delegate constructors!
			if(!type.IsAbstract && type.IsSubclassOf(typeof(Delegate)))
			{
				// HACK non-public delegates do not get the special treatment (because they are likely to refer to
				// non-public types in the arg list and they're not really useful anyway)
				// NOTE we don't have to check in what assembly the type lives, because this is a DotNetTypeWrapper,
				// we know that it is a different assembly.
				if(IsVisible(type))
				{
					TypeWrapper iface = GetClassLoader().LoadClassByDottedName(this.Name + DelegateInterfaceSuffix);
					Debug.Assert(iface is CompiledTypeWrapper);
					iface.Finish();
					MethodDescriptor md = MethodDescriptor.FromNameSig(GetClassLoader(), "<init>", "(" + iface.SigName + ")V");
					MethodWrapper method = new DelegateMethodWrapper(this, md);
					method.EmitNewobj = new DelegateConstructorEmitter(type.GetConstructor(new Type[] { typeof(object), typeof(IntPtr) }), iface.TypeAsTBD.GetMethod("Invoke"));
					AddMethod(method);
					innerClasses = new TypeWrapper[] { iface };
				}
			}

			ConstructorInfo[] constructors = type.GetConstructors(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			for(int i = 0; i < constructors.Length; i++)
			{
				MethodDescriptor md = MakeMethodDescriptor(constructors[i]);
				if(md != null)
				{
					// TODO handle name/signature clash
					AddMethod(CreateMethodWrapper(md, constructors[i], false));
				}
			}

			MethodInfo[] methods = type.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			for(int i = 0; i < methods.Length; i++)
			{
				if(methods[i].IsStatic && type.IsInterface)
				{
					// skip, Java cannot deal with static methods on interfaces
				}
				else
				{
					MethodDescriptor md = MakeMethodDescriptor(methods[i]);
					if(md != null)
					{
						// TODO handle name/signature clash
						AddMethod(CreateMethodWrapper(md, methods[i], false));
					}
				}
			}

			// HACK private interface implementations need to be published as well
			// (otherwise the type appears abstract while it isn't)
			if(!type.IsInterface)
			{
				Type[] interfaces = type.GetInterfaces();
				for(int i = 0; i < interfaces.Length; i++)
				{
					if(interfaces[i].IsPublic)
					{
						InterfaceMapping map = type.GetInterfaceMap(interfaces[i]);
						for(int j = 0; j < map.InterfaceMethods.Length; j++)
						{
							if(!map.TargetMethods[j].IsPublic && map.TargetMethods[j].DeclaringType == type)
							{
								MethodDescriptor md = MakeMethodDescriptor(map.InterfaceMethods[j]);
								if(md != null)
								{
									// TODO handle name/signature clash
									AddMethod(CreateMethodWrapper(md, map.InterfaceMethods[j], true));
								}
							}
						}
					}
				}
			}

			// for non-final remapped types, we need to add all the virtual methods in our alter ego (which
			// appears as our base class) and make them final (to prevent Java code from overriding these
			// methods, which don't really exist).
			if(ClassLoaderWrapper.IsRemappedType(type) && !type.IsSealed && !type.IsInterface)
			{
				// Finish the type, to make sure the methods are populated
				this.BaseTypeWrapper.Finish();
				Hashtable h = new Hashtable();
				TypeWrapper baseTypeWrapper = this.BaseTypeWrapper;
				while(baseTypeWrapper != null)
				{
					foreach(MethodWrapper m in baseTypeWrapper.GetMethods())
					{
						if(!m.IsStatic && !m.IsFinal && (m.IsPublic || m.IsProtected) && m.Name != "<init>")
						{
							if(!h.ContainsKey(m.Descriptor.Name + m.Descriptor.Signature))
							{
								h.Add(m.Descriptor.Name + m.Descriptor.Signature, "");
								MethodWrapper newmw = new MethodWrapper(this, m.Descriptor, m.GetMethod(), m.GetMethod(), m.Modifiers | Modifiers.Final, false);
								newmw.EmitNewobj = CodeEmitter.InternalError;
								// we bind EmitCall to EmitCallvirt, because we always want to end up at the instancehelper method
								// (EmitCall would go to our alter ego .NET type and that wouldn't be legal)
								newmw.EmitCall = m.EmitCallvirt;
								newmw.EmitCallvirt = m.EmitCallvirt;
								// TODO handle name/sig clash (what should we do?)
								AddMethod(newmw);
							}
						}
					}
					baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
				}
			}
		}
	}

	private MethodDescriptor MakeMethodDescriptor(MethodBase mb)
	{
		System.Text.StringBuilder sb = new System.Text.StringBuilder();
		sb.Append('(');
		ParameterInfo[] parameters = mb.GetParameters();
		TypeWrapper[] args = new TypeWrapper[parameters.Length];
		for(int i = 0; i < parameters.Length; i++)
		{
			Type type = parameters[i].ParameterType;
			if(type.IsPointer)
			{
				return null;
			}
			if(type.IsByRef)
			{
				type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
				if(mb.IsAbstract)
				{
					// Since we cannot override methods with byref arguments, we don't report abstract
					// methods with byref args.
					return null;
				}
			}
			TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(type);
			args[i] = tw;
			sb.Append(tw.SigName);
		}
		sb.Append(')');
		if(mb is ConstructorInfo)
		{
			TypeWrapper ret = PrimitiveTypeWrapper.VOID;
			string name;
			if(mb.IsStatic)
			{
				name = "<clinit>";
			}
			else
			{
				name = "<init>";
			}
			sb.Append(ret.SigName);
			return new MethodDescriptor(GetClassLoader(), name, sb.ToString(), args, ret);
		}
		else
		{
			Type type = ((MethodInfo)mb).ReturnType;
			if(type.IsPointer || type.IsByRef)
			{
				return null;
			}
			TypeWrapper ret = ClassLoaderWrapper.GetWrapperFromType(type);
			sb.Append(ret.SigName);
			return new MethodDescriptor(GetClassLoader(), mb.Name, sb.ToString(), args, ret);
		}
	}

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			// remapped type cannot be instantiated, so it wouldn't make sense to implement
			// interfaces
			if(ClassLoaderWrapper.IsRemappedType(type) && !IsInterface)
			{
				return TypeWrapper.EmptyArray;
			}
			Type[] interfaces = type.GetInterfaces();
			TypeWrapper[] interfaceWrappers = new TypeWrapper[interfaces.Length];
			for(int i = 0; i < interfaces.Length; i++)
			{
				interfaceWrappers[i] = ClassLoaderWrapper.GetWrapperFromType(interfaces[i]);
			}
			return interfaceWrappers;
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			lock(this)
			{
				if(innerClasses == null)
				{
					Type[] nestedTypes = type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic);
					innerClasses = new TypeWrapper[nestedTypes.Length];
					for(int i = 0; i < nestedTypes.Length; i++)
					{
						innerClasses[i] = ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]);
					}
				}
			}
			return innerClasses;
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			if(outerClass == null)
			{
				Type outer = type.DeclaringType;
				if(outer != null)
				{
					outerClass = ClassLoaderWrapper.GetWrapperFromType(outer);
				}
			}
			return outerClass;
		}
	}

	internal override Modifiers ReflectiveModifiers
	{
		get
		{
			if(DeclaringTypeWrapper != null)
			{
				return Modifiers | Modifiers.Static;
			}
			return Modifiers;
		}
	}

	// TODO support NonPrimitiveValueTypes
	// TODO why doesn't this use the standard FieldWrapper.Create?
	private FieldWrapper CreateFieldWrapper(Modifiers modifiers, string name, Type fieldType, FieldInfo field, MethodInfo getter)
	{
		CodeEmitter emitGet;
		CodeEmitter emitSet;
		if((modifiers & Modifiers.Private) != 0)
		{
			// there is no way to emit code to access a private member, so we don't need to generate these
			emitGet = CodeEmitter.InternalError;
			emitSet = CodeEmitter.InternalError;
		}
		else if((modifiers & Modifiers.Static) != 0)
		{
			if(getter != null)
			{
				emitGet = CodeEmitter.Create(OpCodes.Call, getter);
			}
			else
			{
				// if field is a literal, we must emit an ldc instead of a ldsfld
				if(field.IsLiteral)
				{
					emitGet = CodeEmitter.CreateLoadConstantField(field);
				}
				else
				{
					emitGet = CodeEmitter.Create(OpCodes.Ldsfld, field);
				}
			}
			if(field != null && !field.IsLiteral)
			{
				emitSet = CodeEmitter.Create(OpCodes.Stsfld, field);
			}
			else
			{
				// TODO what happens when you try to set a final field?
				// through reflection: java.lang.IllegalAccessException: Field is final
				// through code: java.lang.IllegalAccessError: Field <class>.<field> is final
				emitSet = CodeEmitter.Nop;
			}
		}
		else
		{
			if(getter != null)
			{
				emitGet = CodeEmitter.Create(OpCodes.Callvirt, getter);
			}
			else
			{
				// TODO is it possible to have literal instance fields?
				emitGet = CodeEmitter.Create(OpCodes.Ldfld, field);
			}
			if(field != null)
			{
				emitSet = CodeEmitter.Create(OpCodes.Stfld, field);
			}
			else
			{
				// TODO what happens when you try to set a final field through reflection?
				// see above
				emitSet = CodeEmitter.Nop;
			}
		}
		return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(fieldType), name, MethodDescriptor.GetFieldSigName(field), modifiers, field, emitGet, emitSet);
	}

	// TODO why doesn't this use the standard MethodWrapper.Create?
	private MethodWrapper CreateMethodWrapper(MethodDescriptor md, MethodBase mb, bool privateInterfaceImplHack)
	{
		Modifiers mods = AttributeHelper.GetModifiers(mb, true);
		if(md.Name == "Finalize" && md.Signature == "()V" && !mb.IsStatic &&
			TypeAsBaseType.IsSubclassOf(CoreClasses.java.lang.Object.Wrapper.TypeAsBaseType))
		{
			// TODO if the .NET also has a "finalize" method, we need to hide that one (or rename it, or whatever)
			MethodWrapper mw = new MethodWrapper(this, MethodDescriptor.FromNameSig(GetClassLoader(), "finalize", "()V"), mb, null, mods, false);
			mw.SetDeclaredExceptions(new string[] { "java.lang.Throwable" });
			mw.EmitCall = CodeEmitter.Create(OpCodes.Call, mb);
			mw.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, mb);
			mw.EmitNewobj = CodeEmitter.InternalError;
			return mw;
		}
		ParameterInfo[] parameters = mb.GetParameters();
		Type[] args = new Type[parameters.Length];
		bool hasByRefArgs = false;
		bool[] byrefs = null;
		for(int i = 0; i < parameters.Length; i++)
		{
			args[i] = parameters[i].ParameterType;
			if(parameters[i].ParameterType.IsByRef)
			{
				if(byrefs == null)
				{
					byrefs = new bool[args.Length];
				}
				byrefs[i] = true;
				hasByRefArgs = true;
			}
		}
		if(privateInterfaceImplHack)
		{
			mods &= ~Modifiers.Abstract;
			mods |= Modifiers.Final;
		}
		if(hasByRefArgs && !(mb is ConstructorInfo) && !mb.IsStatic)
		{
			mods |= Modifiers.Final;
		}
		MethodWrapper method = hasByRefArgs ?
			new ByRefMethodWrapper(byrefs, this, md, mb, null, mods, false) : new MethodWrapper(this, md, mb, null, mods, false);
		if(mb is ConstructorInfo)
		{
			method.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)mb);
			method.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)mb);
			if(this.IsNonPrimitiveValueType)
			{
				// HACK after constructing a new object, we don't want the custom boxing rule to run
				// (because that would turn "new IntPtr" into a null reference)
				method.EmitNewobj += CodeEmitter.Create(OpCodes.Box, this.TypeAsTBD);
			}
		}
		else
		{
			bool nonPrimitiveValueType = md.RetTypeWrapper.IsNonPrimitiveValueType;
			method.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
			if(nonPrimitiveValueType)
			{
				method.EmitCall += CodeEmitter.CreateEmitBoxCall(md.RetTypeWrapper);
			}
			if(!mb.IsStatic)
			{
				method.EmitCallvirt = CodeEmitter.Create(this.IsNonPrimitiveValueType ? OpCodes.Call : OpCodes.Callvirt, (MethodInfo)mb);
				if(nonPrimitiveValueType)
				{
					method.EmitCallvirt += CodeEmitter.CreateEmitBoxCall(md.RetTypeWrapper);
				}
			}
		}
		if(hasByRefArgs)
		{
			method.EmitCall = new RefArgConverter(args) + method.EmitCall;
			method.EmitCallvirt = new RefArgConverter(args) + method.EmitCallvirt;
			method.EmitNewobj = new RefArgConverter(args) + method.EmitNewobj;
		}
		return method;
	}

	private class DelegateConstructorEmitter : CodeEmitter
	{
		private ConstructorInfo delegateConstructor;
		private MethodInfo method;

		internal DelegateConstructorEmitter(ConstructorInfo delegateConstructor, MethodInfo method)
		{
			this.delegateConstructor = delegateConstructor;
			this.method = method;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Ldvirtftn, method);
			ilgen.Emit(OpCodes.Newobj, delegateConstructor);
		}
	}

	private class RefArgConverter : CodeEmitter
	{
		private Type[] args;

		internal RefArgConverter(Type[] args)
		{
			this.args = args;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			LocalBuilder[] locals = new LocalBuilder[args.Length];
			for(int i = args.Length - 1; i >= 0; i--)
			{
				Type type = args[i];
				if(type.IsByRef)
				{
					type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
				}
				locals[i] = ilgen.DeclareLocal(type);
				ilgen.Emit(OpCodes.Stloc, locals[i]);
			}
			for(int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldloc, locals[i]);
				if(args[i].IsByRef)
				{
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ldelema, args[i].GetElementType());
				}
			}
		}
	}

	internal override Type TypeAsTBD
	{
		get
		{
			return type;
		}
	}

	internal override bool IsRemapped
	{
		get
		{
			return ClassLoaderWrapper.IsRemappedType(type);
		}
	}
}

class ArrayTypeWrapper : TypeWrapper
{
	private static TypeWrapper[] interfaces;
	private static MethodDescriptor mdClone;
	private static MethodInfo clone;
	private static CodeEmitter callclone;
	private Type type;

	internal ArrayTypeWrapper(Type type, Modifiers modifiers, string name, ClassLoaderWrapper classLoader)
		: base(modifiers, name, CoreClasses.java.lang.Object.Wrapper, classLoader)
	{
		this.type = type;
		if(mdClone == null)
		{
			mdClone = MethodDescriptor.FromNameSig(ClassLoaderWrapper.GetBootstrapClassLoader(), "clone", "()Ljava.lang.Object;");
		}
		if(clone == null)
		{
			clone = typeof(Array).GetMethod("Clone");
		}
		MethodWrapper mw = new MethodWrapper(this, mdClone, clone, null, Modifiers.Public, true);
		if(callclone == null)
		{
			callclone = CodeEmitter.Create(OpCodes.Callvirt, clone);
		}
		mw.EmitCall = callclone;
		mw.EmitCallvirt = callclone;
		AddMethod(mw);
	}

	internal override string SigName
	{
		get
		{
			// for arrays the signature name is the same as the normal name
			return Name;
		}
	}

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			if(interfaces == null)
			{
				TypeWrapper[] tw = new TypeWrapper[2];
				tw[0] = ClassLoaderWrapper.LoadClassCritical("java.lang.Cloneable");
				tw[1] = ClassLoaderWrapper.LoadClassCritical("java.io.Serializable");
				interfaces = tw;
			}
			return interfaces;
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			return TypeWrapper.EmptyArray;
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			return null;
		}
	}

	internal override Type TypeAsTBD
	{
		get
		{
			return type;
		}
	}

	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
	{
		return null;
	}

	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		return null;
	}

	private bool IsFinished
	{
		get
		{
			Type elem = type.GetElementType();
			while(elem.IsArray)
			{
				elem = elem.GetElementType();
			}
			return !(elem is TypeBuilder);
		}
	}

	internal override void Finish()
	{
		lock(this)
		{
			if(!IsFinished)
			{
				TypeWrapper elementTypeWrapper = ElementTypeWrapper;
				Type elementType = elementTypeWrapper.TypeAsArrayType;
				elementTypeWrapper.Finish();
				type = elementType.Assembly.GetType(elementType.FullName + "[]", true);
				ClassLoaderWrapper.SetWrapperForType(type, this);
			}
		}
	}
}
@


1.73
log
@*** empty log message ***
@
text
@@


1.72
log
@*** empty log message ***
@
text
@d381 1
a381 1
		if(exceptions != null)
d385 1
a385 1
				throwsAttribute = typeof(ThrowsAttribute).GetConstructor(new Type[] { typeof(string) });
d390 1
a390 4
				for(int i = 0; i < exceptions.Length; i++)
				{
					method.SetCustomAttribute(new CustomAttributeBuilder(throwsAttribute, new object[] { exceptions[i] }));
				}
d395 1
a395 4
				for(int i = 0; i < exceptions.Length; i++)
				{
					constructor.SetCustomAttribute(new CustomAttributeBuilder(throwsAttribute, new object[] { exceptions[i] }));
				}
d462 1
a462 1
	internal static void ImplementsAttribute(TypeBuilder typeBuilder, TypeWrapper ifaceWrapper)
d464 1
a464 4
		// we always want the "clean" type in the attribute, so for ghosts we use the wrapping value type instead
		// of the nested interface
		Type iface = ifaceWrapper.IsGhost ? ifaceWrapper.TypeAsTBD : ifaceWrapper.TypeAsBaseType;
		if(implementsAttribute == null)
d466 10
a475 12
			implementsAttribute = typeof(ImplementsAttribute).GetConstructor(new Type[] { typeof(Type) });
		}
		// FXBUG because SetCustomAttribute(CustomAttributeBuilder) incorrectly always stores the assembly qualified name
		// we have our own version for when the type lives in the same assembly as the attribute. If we don't do this
		// the .NET runtime will have problems resolving this type when the assembly is loaded in the LoadFrom context.
		if(typeBuilder.Assembly.Equals(iface.Assembly))
		{
			typeBuilder.SetCustomAttribute(implementsAttribute, FreezeDryType(iface));
		}
		else
		{
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(implementsAttribute, new object[] { iface }));
d2226 5
a2230 2
					outerClassWrapper = wrapper.GetClassLoader().LoadClassByDottedName(f.OuterClass.Name);
					if(outerClassWrapper is DynamicTypeWrapper)
d2232 5
a2236 1
						outer = outerClassWrapper.TypeAsBuilder;
a2309 1
				AttributeHelper.ImplementsAttribute(typeBuilder, interfaces[i]);
d2311 1
d2318 6
d2326 1
a2326 4
			Debug.Assert(inner.Length > outer.Length + 1);
			Debug.Assert(inner[outer.Length] == '$');
			Debug.Assert(inner.IndexOf('$', outer.Length + 1) == -1);

d2908 1
d3458 1
a3458 1
						attribs |= MethodAttributes.Virtual;
d4090 11
a4100 2
				ArrayList wrappers = new ArrayList();
				for(int i = 0; i < attribs.Length; i++)
d4102 1
a4102 2
					ImplementsAttribute impl = (ImplementsAttribute)attribs[i];
					wrappers.Add(ClassLoaderWrapper.GetWrapperFromType(impl.Type));
a4103 1
				interfaces = (TypeWrapper[])wrappers.ToArray(typeof(TypeWrapper));
d4812 1
a4812 1
			if(!type.IsSealed && !type.IsInterface)
@


1.71
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002 Jeroen Frijters
d2002 1
a2002 1
		foreach(MapXml.Class c in map.remappings)
d2004 1
a2004 1
			if(c.Interfaces != null)
d2143 1
a2143 1
		foreach(MapXml.Class c in map.nativeMethods)
d2145 2
a2146 2
			string className = c.Name;
			foreach(MapXml.Method method in c.Methods)
d2148 10
a2157 3
				string methodName = method.Name;
				string methodSig = method.Sig;
				nativeMethods[className + "." + methodName + methodSig] = method.body;
d3234 3
a3236 3
						// NOTE blank final fields get converted into a read-only property with a private field backing store
						// we used to make the field privatescope, but that really serves no purpose (and it hinders serialization,
						// which uses .NET reflection to get at the field)
d3241 4
d3987 1
a3987 1
	internal static TypeWrapper GetBaseTypeWrapper(Type type)
d4495 1
a4495 1
		if(type.IsSealed || (ClassLoaderWrapper.IsRemappedType(type) && !type.IsInterface))
d4518 1
d4522 12
d4535 7
a4541 1
		return NamePrefix + type.FullName.Replace('+', '$');
d4550 1
a4550 1
			name = name.Substring(NamePrefix.Length);
d4563 1
a4563 1
			if(delegateType.IsSubclassOf(typeof(Delegate)))
d4609 1
d4620 23
d4644 1
a4644 1
		: base(GetModifiers(type), GetName(type), CompiledTypeWrapper.GetBaseTypeWrapper(type), ClassLoaderWrapper.GetBootstrapClassLoader())
a4738 2
			bool isRemapped = ClassLoaderWrapper.IsRemappedType(type) && !type.IsInterface;

d4777 1
a4777 1
				MethodDescriptor md = MakeMethodDescriptor(constructors[i], isRemapped);
d4781 1
a4781 1
					AddMethod(CreateMethodWrapper(md, constructors[i], isRemapped, false));
d4794 1
a4794 1
					MethodDescriptor md = MakeMethodDescriptor(methods[i], isRemapped);
d4798 1
a4798 1
						AddMethod(CreateMethodWrapper(md, methods[i], isRemapped, false));
d4805 1
a4805 1
			if(!isRemapped && !type.IsInterface)
d4817 1
a4817 1
								MethodDescriptor md = MakeMethodDescriptor(map.InterfaceMethods[j], false);
d4821 1
a4821 1
									AddMethod(CreateMethodWrapper(md, map.InterfaceMethods[j], false, true));
d4828 33
d4864 1
a4864 1
	private MethodDescriptor MakeMethodDescriptor(MethodBase mb, bool isRemapped)
d4869 1
a4869 7
		int bias = (isRemapped && !mb.IsStatic && !mb.IsConstructor) ? 1 : 0;
		TypeWrapper[] args = new TypeWrapper[parameters.Length + bias];
		if(bias == 1)
		{
			args[0] = ClassLoaderWrapper.GetWrapperFromType(mb.DeclaringType);
			sb.Append(args[0].SigName);
		}
d4888 1
a4888 1
			args[i + bias] = tw;
a4899 5
			else if(isRemapped)
			{
				name = "__new";
				ret = ClassLoaderWrapper.GetWrapperFromType(mb.DeclaringType);
			}
d4926 1
a4926 1
			if(IsRemapped && !IsInterface)
d5056 1
a5056 1
	private MethodWrapper CreateMethodWrapper(MethodDescriptor md, MethodBase mb, bool isRemapped, bool privateInterfaceImplHack)
a5086 6
		if(isRemapped)
		{
			// all methods are static and final doesn't make sense
			mods |= Modifiers.Static;
			mods &= ~Modifiers.Final;
		}
d5100 3
a5102 1
			if(isRemapped)
d5104 3
a5106 12
				method.EmitCall = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)mb);
			}
			else
			{
				method.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)mb);
				method.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)mb);
				if(this.IsNonPrimitiveValueType)
				{
					// HACK after constructing a new object, we don't want the custom boxing rule to run
					// (because that would turn "new IntPtr" into a null reference)
					method.EmitNewobj += CodeEmitter.Create(OpCodes.Box, this.TypeAsTBD);
				}
d5195 8
@


1.70
log
@*** empty log message ***
@
text
@d1029 1
a1029 1
			return String.CompareOrdinal(name, skip1, wrapper.name, skip2, index1) == 0;
@


1.69
log
@*** empty log message ***
@
text
@d2063 2
d2102 34
@


1.68
log
@*** empty log message ***
@
text
@d2819 1
a2819 1
						Compiler.Compile(wrapper, m, ilGenerator, wrapper.GetClassLoader());
@


1.67
log
@*** empty log message ***
@
text
@d232 1
a232 1
			typeWrapper = CoreClasses.java_lang_Object;
d1248 1
a1248 1
		if(baseType == CoreClasses.java_lang_Object)
d3188 2
a3189 1
					if(fld.IsFinal)
d3191 6
a3196 10
						// final doesn't make sense for private fields, so if the field is private we ignore final
						if(!fld.IsPrivate && !wrapper.IsInterface)
						{
							// NOTE blank final fields get converted into a read-only property with a private field backing store
							// we used to make the field privatescope, but that really serves no purpose (and it hinders serialization,
							// which uses .NET reflection to get at the field)
							attribs &= ~FieldAttributes.FieldAccessMask;
							attribs |= FieldAttributes.Private;
							setModifiers = true;
						}
d3209 1
a3209 1
					if(fld.IsFinal && !fld.IsPrivate && !wrapper.IsInterface)
d3518 1
a3518 1
							else if(baseMethod.DeclaringType == CoreClasses.java_lang_Object.TypeAsBaseType)
d3949 1
a3949 1
			return CoreClasses.java_lang_Object;
d3962 1
a3962 1
					return CoreClasses.java_lang_Object;
d4950 1
a4950 1
			TypeAsBaseType.IsSubclassOf(CoreClasses.java_lang_Object.TypeAsBaseType))
d5109 1
a5109 1
		: base(modifiers, name, CoreClasses.java_lang_Object, classLoader)
@


1.66
log
@*** empty log message ***
@
text
@d113 1
a113 1
	internal Type[] ArgTypes
a141 10
	// NOTE this exposes potentially unfinished types!
	// HACK this should not be used and all existing uses should be reworked
	internal Type RetType
	{
		get
		{
			return RetTypeForDefineMethod;
		}
	}

d232 1
a232 1
			typeWrapper = ClassLoaderWrapper.LoadClassCritical("java.lang.Object");
d470 3
a472 1
		Type iface = ifaceWrapper.TypeAsTBD;
d479 1
a479 1
		// ikvmc will have problems accessing this attribute when it uses Assembly.LoadFrom to load an assembly.
a636 1
	private static TypeWrapper java_lang_Object;
a1246 5
		if(java_lang_Object == null)
		{
			// TODO cache java.lang.Object somewhere else
			java_lang_Object = ClassLoaderWrapper.LoadClassCritical("java.lang.Object");
		}
d1248 1
a1248 1
		if(baseType == java_lang_Object)
d1323 2
a1324 2
		// HACK we're mangling the name to prevent subclasses from overriding this method
		string mangledName = this.Name + "$" + ifmethod.Name + "$" + wrapper.Name;
d1328 1
a1328 1
			// HACK for now we make it seem as if the method isn't there, we should be emitting
d1368 1
a1368 1
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.Private | MethodAttributes.NewSlot | MethodAttributes.Virtual | MethodAttributes.Final, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
d2718 1
d3437 1
a3437 1
							// RULE 1: final methods may not be overriden
d3510 22
d3533 14
a3546 7
						// if we're overriding java.lang.Object.finalize we need to emit a stub to override System.Object.Finalize
						if(baseMethod != null &&
							baseMethod.Name == "finalize" &&
							baseMethod.DeclaringType.FullName == "java.lang.Object" && 
							md.Signature == "()V")
						{
							MethodBuilder finalize = typeBuilder.DefineMethod("Finalize", MethodAttributes.Family | MethodAttributes.Virtual, CallingConventions.Standard, typeof(void), Type.EmptyTypes);
d3548 13
a3560 3
							// NOTE we're not calling the base class Finalize (that would be Object.Finalize, which doesn't do anything)
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Callvirt, mb);
d3613 2
a3614 2
					// since Java constructors (and static intializers) aren't allowed to be synchronized, we only check this here
					if(m.IsSynchronized)
d3616 2
d3952 1
a3952 1
			return ClassLoaderWrapper.LoadClassCritical("java.lang.Object");
d3965 1
a3965 1
					return ClassLoaderWrapper.LoadClassCritical("java.lang.Object");
d4513 1
a4513 1
						// to late to refuse to load the class, so we replace pointers with IntPtr.
d4951 12
a4979 1
		Modifiers mods = AttributeHelper.GetModifiers(mb, true);
d5025 1
a5025 1
				method.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)mb);
d5112 1
a5112 1
		: base(modifiers, name, ClassLoaderWrapper.LoadClassCritical("java.lang.Object"), classLoader)
@


1.65
log
@*** empty log message ***
@
text
@d303 10
d336 8
d485 1
a485 1
		// HACK because SetCustomAttribute(CustomAttributeBuilder) incorrectly always stores the assembly qualified name
d617 1
a617 1
	private static byte[] FreezeDryType(Type type)
d653 3
a655 3
	public static readonly TypeWrapper[] EmptyArray = new TypeWrapper[0];
	public const Modifiers UnloadableModifiersHack = Modifiers.Final | Modifiers.Interface | Modifiers.Private;
	public const Modifiers VerifierTypeModifiersHack = Modifiers.Final | Modifiers.Interface;
d657 1
a657 1
	public TypeWrapper(Modifiers modifiers, string name, TypeWrapper baseWrapper, ClassLoaderWrapper classLoader)
d689 1
a689 1
	internal bool IsGhost
d693 1
a693 1
			return ClassLoaderWrapper.IsGhost(this);
d714 8
d802 8
d888 1
a888 1
	public FieldWrapper GetFieldWrapper(string fieldName, TypeWrapper fieldType)
d936 1
a936 1
	public MethodWrapper GetMethodWrapper(MethodDescriptor md, bool inherit)
d955 1
a955 1
	public void AddMethod(MethodWrapper method)
d961 1
a961 1
	public void AddField(FieldWrapper field)
d967 1
a967 1
	public string Name
d1043 1
a1043 1
	public abstract Type TypeAsTBD
d1048 1
a1048 1
	public TypeBuilder TypeAsBuilder
d1158 1
a1158 1
	public TypeWrapper BaseTypeWrapper
d1217 1
a1217 1
	public bool ImplementsInterface(TypeWrapper interfaceWrapper)
d1239 1
a1239 1
	public bool IsSubTypeOf(TypeWrapper baseType)
d1316 1
a1316 1
	public abstract TypeWrapper[] Interfaces
d1322 1
a1322 1
	public abstract TypeWrapper[] InnerClasses
d1328 1
a1328 1
	public abstract TypeWrapper DeclaringTypeWrapper
d1333 1
a1333 1
	public abstract void Finish();
d1482 1
a1482 1
		if(TypeAsTBD.Assembly is AssemblyBuilder || this is RemappedTypeWrapper)
a1511 4
	internal virtual void ImplementOverrideStubsAndVirtuals(TypeBuilder typeBuilder, DynamicTypeWrapper wrapper, Hashtable methodLookup)
	{
	}

d1556 2
a1557 2
	// NOTE sourceType is only used for special types (e.g. interfaces), it is *not* used to automatically
	// downcast
d1562 1
a1562 11
			// because of the way interface merging works, any reference is valid
			// for any interface reference
			if(IsInterfaceOrInterfaceArray && (sourceType.IsUnloadable || !sourceType.IsAssignableTo(this)))
			{
				ilgen.Emit(OpCodes.Castclass, TypeAsTBD);
			}
			else if(IsNonPrimitiveValueType)
			{
				EmitUnbox(ilgen);
			}
			else if(IsGhost)
d1573 10
d1618 7
a1624 3
			string brackets = "[]";
			TypeWrapper element = ElementTypeWrapper;
			while(element.IsArray)
d1626 2
a1627 15
				brackets += "[]";
				element = element.ElementTypeWrapper;
			}
			TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(element);
			Type[] implementerTypes = new Type[implementers.Length];
			for(int j = 0; j < implementers.Length; j++)
			{
				implementerTypes[j] = implementers[j].TypeAsTBD.Module.GetType(implementers[j].TypeAsTBD.FullName + brackets);
			}
			Label end = ilgen.DefineLabel();
			for(int j = 0; j < implementerTypes.Length; j++)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Isinst, implementerTypes[j]);
				ilgen.Emit(OpCodes.Brtrue, end);
d1629 2
a1630 3
			// TODO once we "fix" array instantiation this should ever occur
			ilgen.Emit(OpCodes.Castclass, TypeAsTBD);
			ilgen.MarkLabel(end);
d1649 4
a1652 32
			string brackets = "[]";
			TypeWrapper element = ElementTypeWrapper;
			while(element.IsArray)
			{
				brackets += "[]";
				element = element.ElementTypeWrapper;
			}
			TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(element);
			Type[] implementerTypes = new Type[implementers.Length];
			for(int j = 0; j < implementers.Length; j++)
			{
				implementerTypes[j] = implementers[j].TypeAsTBD.Module.GetType(implementers[j].TypeAsTBD.FullName + brackets);
			}
			Label end = ilgen.DefineLabel();
			for(int j = 0; j < implementerTypes.Length; j++)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Isinst, implementerTypes[j]);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brfalse_S, label);
				ilgen.Emit(OpCodes.Pop);
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Br, end);
				ilgen.MarkLabel(label);
			}
			// TODO once we "fix" array instantiation this should ever occur
			ilgen.Emit(OpCodes.Isinst, TypeAsTBD);
			ilgen.Emit(OpCodes.Ldnull);
			ilgen.Emit(OpCodes.Ceq);
			ilgen.Emit(OpCodes.Ldc_I4_0);
			ilgen.Emit(OpCodes.Ceq);
			ilgen.MarkLabel(end);
d1738 1
a1738 1
	public override Type TypeAsTBD
d1746 1
a1746 1
	public override TypeWrapper[] Interfaces
d1754 1
a1754 1
	public override TypeWrapper[] InnerClasses
d1762 1
a1762 1
	public override TypeWrapper DeclaringTypeWrapper
d1770 1
a1770 1
	public override void Finish()
d1825 1
a1825 1
	public override Type TypeAsTBD
d1843 1
a1843 1
	public override TypeWrapper[] Interfaces
d1852 1
a1852 1
	public override TypeWrapper[] InnerClasses
d1860 1
a1860 1
	public override TypeWrapper DeclaringTypeWrapper
d1868 1
a1868 1
	public override void Finish()
d1879 1
d1881 4
d1886 1
a1886 1
	internal DynamicTypeWrapper(ClassFile f, ClassLoaderWrapper classLoader, Hashtable nativeMethods)
d1926 1
a1926 1
		impl = new JavaTypeImpl(f, this, nativeMethods);
d1955 1
a1955 1
	public override TypeWrapper[] Interfaces
d1963 1
a1963 1
	public override TypeWrapper[] InnerClasses
d1971 1
a1971 1
	public override TypeWrapper DeclaringTypeWrapper
d1979 1
a1979 1
	public override Type TypeAsTBD
d1995 1
a1995 1
	public override void Finish()
d2011 149
a2182 1
		private readonly Hashtable nativeMethods;
d2186 1
a2186 1
		internal JavaTypeImpl(ClassFile f, DynamicTypeWrapper wrapper, Hashtable nativeMethods)
d2188 1
a2188 1
			//Console.WriteLine("constructing JavaTypeImpl for " + f.Name);
a2190 1
			this.nativeMethods = nativeMethods;
d2239 2
a2240 1
					// TODO in the CLR interfaces cannot contain nested types!
d2253 1
d2257 1
d2259 1
d2496 1
a2496 1
							TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(wrapper);
d2514 1
a2514 1
								ilgen.Emit(OpCodes.Isinst, implementers[j].TypeAsBaseType);
d2517 1
a2517 1
								ilgen.Emit(OpCodes.Castclass, implementers[j].TypeAsBaseType);
d2528 1
a2528 1
							ilgen.Emit(OpCodes.Ldvirtftn, typeof(object).GetMethod("ToString"));
d2541 1
a2541 1
						TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(wrapper);
d2563 1
a2563 1
							ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsBaseType);
d2578 53
d2639 1
a2639 1
							ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsBaseType);
d2649 1
a2649 1
						ilgen.Emit(OpCodes.Stfld, wrapper.GhostRefField);
d2660 18
d2735 1
d2753 1
a2753 2
								string key = classFile.Name + "." + m.Name + m.Signature;
								CodeEmitter opcodes = (CodeEmitter)nativeMethods[key];
d2814 2
a2815 1
									Console.Error.WriteLine("Warning: Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
a2900 1
					wrapper.BaseTypeWrapper.ImplementOverrideStubsAndVirtuals(typeBuilder, wrapper, methodLookup);
d3321 3
a3323 1
			if(!classFile.IsFinal)
d3330 7
a3336 5
			// NOTE we don't need to record the modifiers here, because they aren't visible from Java reflection
			// (well they might be visible from JNI reflection, but that isn't important enough to justify the custom attribute)
			// HACK because Peverify is complaining about private methods in interfaces, I'm making them public for the time being
			return typeBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
			//return typeBuilder.DefineTypeInitializer();
d3524 13
d3810 5
d3827 4
d3838 3
a3840 1
class RemappedTypeWrapper : TypeWrapper
d3842 22
a3863 6
	private readonly Type type;
	private TypeWrapper[] interfaces;
	private bool virtualsInterfaceBuilt;
	private Type virtualsInterface;
	private Type virtualsHelperHack;
	private CodeEmitter box;
d3865 1
a3865 2
	public RemappedTypeWrapper(ClassLoaderWrapper classLoader, Modifiers modifiers, string name, Type type, TypeWrapper[] interfaces, TypeWrapper baseType)
		: base(modifiers, name, baseType, classLoader)
d3867 10
a3876 2
		this.type = type;
		this.interfaces = interfaces;
d3879 1
a3879 1
	public void LoadRemappings(MapXml.Class classMap)
d3881 1
a3881 3
		bool hasOverrides = false;
		ArrayList methods = new ArrayList();
		if(classMap.Methods != null)
d3883 1
a3883 1
			foreach(MapXml.Method method in classMap.Methods)
d3885 20
a3904 813
				string name = method.Name;
				string sig = method.Sig;
				Modifiers modifiers = (Modifiers)method.Modifiers;
				bool isStatic = (modifiers & Modifiers.Static) != 0;
				MethodDescriptor md = MethodDescriptor.FromNameSig(GetClassLoader(), name, sig);
				if(method.invokevirtual == null &&
					method.invokespecial == null &&
					method.invokestatic == null &&
					method.redirect == null &&
					method.@@override == null)
				{
					// TODO use a better way to get the method
					BindingFlags binding = BindingFlags.Public | BindingFlags.NonPublic;
					if(isStatic)
					{
						binding |= BindingFlags.Static;
					}
					else
					{
						binding |= BindingFlags.Instance;
					}
					MethodBase mb = type.GetMethod(name, binding, null, CallingConventions.Standard, md.ArgTypes, null);
					if(mb == null)
					{
						// TODO better error handling
						throw new InvalidOperationException("declared method: " + Name + "." + name + sig + " not found");
					}
					MethodWrapper mw = MethodWrapper.Create(this, md, mb, mb, modifiers, false);
					mw.SetDeclaredExceptions(method.throws);
					AddMethod(mw);
					methods.Add(mw);
				}
				else
				{
					CodeEmitter newopc = null;
					CodeEmitter invokespecial = null;
					CodeEmitter invokevirtual = null;
					CodeEmitter retcast = null;
					MethodBase redirect = null;
					MethodBase overrideMethod = null;
					if(method.redirect != null)
					{
						if(method.invokevirtual != null ||
							method.invokespecial != null ||
							method.invokestatic != null ||
							method.@@override != null)
						{
							// TODO better error handling
							throw new InvalidOperationException();
						}
						if(method.redirect.Name != null)
						{
							name = method.redirect.Name;
						}
						if(method.redirect.Sig != null)
						{
							sig = method.redirect.Sig;
						}
						string stype = isStatic ? "static" : "instance";
						if(method.redirect.Type != null)
						{
							stype = method.redirect.Type;
						}
						MethodDescriptor redir = MethodDescriptor.FromNameSig(GetClassLoader(), name, sig);
						BindingFlags binding = BindingFlags.Public | BindingFlags.NonPublic;
						if(stype == "static")
						{
							binding |= BindingFlags.Static;
						}
						else
						{
							binding |= BindingFlags.Instance;
						}
						if(method.redirect.Class != null)
						{
							TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(method.redirect.Class);
							if(tw is DynamicTypeWrapper)
							{
								MethodWrapper mw1 = tw.GetMethodWrapper(redir, false);
								if(mw1 == null)
								{
									Console.WriteLine("method not found: " + tw.Name + "." + redir.Name + redir.Signature);
								}
								redirect = mw1.GetMethod();
							}
							else
							{
								redirect = tw.TypeAsTBD.GetMethod(name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
							}
						}
						else
						{
							redirect = this.type.GetMethod(name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
						}
						if(redirect == null)
						{
							// TODO better error handling
							throw new InvalidOperationException("remapping method: " + name + sig + " not found");
						}
						string ret = md.Signature.Substring(md.Signature.IndexOf(')') + 1);
						// when constructors are remapped, we have to assume that the type is correct because the original
						// return type (of the constructor) is void.
						if(ret[0] != 'V' && ret != redir.Signature.Substring(redir.Signature.IndexOf(')') + 1))
						{
							if(ret[0] == 'L')
							{
								ret = ret.Substring(1, ret.Length - 2);
							}
							retcast = new ReturnCastEmitter(ClassLoaderWrapper.LoadClassCritical(ret));
						}
						if(BaseTypeWrapper != null && !TypeAsBaseType.IsSealed)
						{
							MethodWrapper mce1 = BaseTypeWrapper.GetMethodWrapper(md, true);
							if(mce1 != null)
							{
								MethodBase org = mce1.GetMethod();
								if(org != null)
								{
									ParameterInfo[] paramInfo = org.GetParameters();
									Type[] argTypes = new Type[paramInfo.Length];
									for(int i = 0; i < argTypes.Length; i++)
									{
										argTypes[i] = paramInfo[i].ParameterType;
									}
									BindingFlags binding1 = BindingFlags.Public | BindingFlags.NonPublic;
									if(isStatic)
									{
										// TODO this looks like total nonsense, a static method cannot override a method,
										// so we shouldn't ever get here
										binding1 |= BindingFlags.Static;
									}
									else
									{
										binding1 |= BindingFlags.Instance;
									}
									overrideMethod = type.GetMethod(org.Name, binding1, null, CallingConventions.Standard, argTypes, null);
								}
							}
						}
						MethodWrapper.CreateEmitters(overrideMethod, redirect, ref invokespecial, ref invokevirtual, ref newopc);
					}
					else
					{
						if(method.@@override != null)
						{
							BindingFlags binding = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
							overrideMethod = type.GetMethod(method.@@override.Name, binding, null, CallingConventions.Standard, GetClassLoader().ArgTypeListFromSig(sig), null);
							if(overrideMethod == null)
							{
								// TODO better error handling
								throw new InvalidOperationException("Override method not found: " + Name + "." + name + sig);
							}
						}
						invokespecial = method.invokespecial;
						invokevirtual = method.invokevirtual;
						if(method.invokestatic != null)
						{
							invokespecial = method.invokestatic;
						}
					}
					// if invokespecial isn't redefined, it means that the base class' implementation is correct,
					// so we don't need to generate an override stub for this method
					bool trivialOverride = (invokespecial == null);
					if(overrideMethod != null)
					{
						if(invokespecial == null)
						{
							invokespecial = CodeEmitter.Create(OpCodes.Call, (MethodInfo)overrideMethod);
						}
						if(invokevirtual == null)
						{
							invokevirtual = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)overrideMethod);
						}
					}
					// HACK MethodWrapper doesn't accept a MethodBuilder, so we have to blank it out, note
					// that this means that reflection won't work on this method, so we have to add support
					// for that
					// TODO support reflection
					if(redirect is MethodBuilder)
					{
						redirect = null;
					}
					MethodWrapper mw = new MethodWrapper(this, md, overrideMethod, redirect, modifiers, false);
					mw.EmitNewobj = newopc;
					mw.EmitCall = invokespecial;
					mw.EmitCallvirt = invokevirtual;
					if(retcast != null)
					{
						mw.EmitNewobj += retcast;
						mw.EmitCall += retcast;
						mw.EmitCallvirt += retcast;
					}
					// don't generate override stubs for trivial methods (i.e. methods that are only renamed)
					if(overrideMethod != null && !trivialOverride)
					{
						hasOverrides = true;
						mw.IsRemappedOverride = true;
					}
					if(method.Type == "virtual")
					{
						// TODO we're overwriting the retcast (if there is any). We shouldn't do this.
						mw.EmitCallvirt = new VirtualEmitter(md, this);
						mw.IsRemappedVirtual = true;
					}
					mw.SetDeclaredExceptions(method.throws);
					AddMethod(mw);
					methods.Add(mw);
				}
			}
		}
		if(classMap.Constructors != null)
		{
			foreach(MapXml.Constructor constructor in classMap.Constructors)
			{
				Modifiers modifiers = (Modifiers)constructor.Modifiers;
				MethodDescriptor md = MethodDescriptor.FromNameSig(GetClassLoader(), "<init>", constructor.Sig);
				if(constructor.invokespecial == null && constructor.newobj == null && constructor.redirect == null)
				{
					// TODO use a better way to get the method
					BindingFlags binding = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
					MethodBase method = type.GetConstructor(binding, null, CallingConventions.Standard, md.ArgTypes, null);
					if(method == null)
					{
						// TODO better error handling
						throw new InvalidOperationException("declared constructor: " + classMap.Name + constructor.Sig + " not found");
					}
					MethodWrapper mw = MethodWrapper.Create(this, md, method, method, modifiers, false);
					mw.SetDeclaredExceptions(constructor.throws);
					AddMethod(mw);
					methods.Add(mw);
				}
				else
				{
					CodeEmitter newopc = null;
					CodeEmitter invokespecial = null;
					CodeEmitter retcast = null;
					if(constructor.redirect != null)
					{
						if(constructor.invokespecial != null || constructor.newobj != null)
						{
							// TODO better error handling
							throw new InvalidOperationException();
						}
						string sig = constructor.Sig;
						if(constructor.redirect.Sig != null)
						{
							sig = constructor.redirect.Sig;
						}
						MethodDescriptor redir = MethodDescriptor.FromNameSig(GetClassLoader(), "<init>", sig);
						BindingFlags binding = BindingFlags.Public | BindingFlags.NonPublic;
						if(constructor.redirect.Type == "static")
						{
							binding |= BindingFlags.Static;
							if((classMap.Modifiers & MapXml.MapModifiers.Final) == 0)
							{
								// NOTE only final classes can have constructors redirected to static methods,
								// because we don't have support for making the distinction between new and invokespecial
								// TODO better error handling
								throw new InvalidOperationException();
							}
						}
						else
						{
							binding |= BindingFlags.Instance;
						}
						MethodBase redirect = null;
						if(constructor.redirect.Class != null)
						{
							TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(constructor.redirect.Class);
							if(tw is DynamicTypeWrapper)
							{
								MethodDescriptor md1 = MethodDescriptor.FromNameSig(GetClassLoader(), constructor.redirect.Name != null ? constructor.redirect.Name : "<init>", sig);
								MethodWrapper mw1 = tw.GetMethodWrapper(md1, false);
								if(mw1 == null)
								{
									Console.WriteLine("constructor not found: " + tw.Name + "." + redir.Name + redir.Signature);
								}
								redirect = mw1.GetMethod();
							}
							else
							{
								if(constructor.redirect.Name != null)
								{
									redirect = tw.TypeAsTBD.GetMethod(constructor.redirect.Name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
								}
								else
								{
									redirect = tw.TypeAsTBD.GetConstructor(binding, null, CallingConventions.Standard, redir.ArgTypes, null);
								}
							}
						}
						else
						{
							if(constructor.redirect.Name != null)
							{
								redirect = this.type.GetMethod(constructor.redirect.Name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
							}
							else
							{
								redirect = this.type.GetConstructor(binding, null, CallingConventions.Standard, redir.ArgTypes, null);
							}
						}
						if(redirect == null)
						{
							// TODO better error handling
							throw new InvalidOperationException("remapping constructor: " + classMap.Name + constructor.Sig + " not found");
						}
						string ret = md.Signature.Substring(md.Signature.IndexOf(')') + 1);
						// when constructors are remapped, we have to assume that the type is correct because the original
						// return type (of the constructor) is void.
						// TODO we could look at return type of the redirected method and see if that matches the type of the
						// object we're supposed to be constructing
						if(ret[0] != 'V' && ret != redir.Signature.Substring(redir.Signature.IndexOf(')') + 1))
						{
							if(ret[0] == 'L')
							{
								ret = ret.Substring(1, ret.Length - 2);
							}
							retcast = new ReturnCastEmitter(ClassLoaderWrapper.LoadClassCritical(ret));
						}
						CodeEmitter ignore = null;
						MethodWrapper.CreateEmitters(null, redirect, ref ignore, ref ignore, ref newopc);
					}
					else
					{
						newopc = constructor.newobj;
						invokespecial = constructor.invokespecial;
					}
					MethodWrapper mw = new MethodWrapper(this, md, null, null, modifiers, false);
					mw.EmitNewobj = newopc;
					mw.EmitCall = invokespecial;
					if(retcast != null)
					{
						mw.EmitNewobj += retcast;
						mw.EmitCall += retcast;
					}
					mw.SetDeclaredExceptions(constructor.throws);
					AddMethod(mw);
					methods.Add(mw);
				}
			}
		}
		if(classMap.Fields != null)
		{
			foreach(MapXml.Field field in classMap.Fields)
			{
				string name = field.Name;
				string sig = field.Sig;
				string fieldName = name;
				string fieldSig = sig;
				Modifiers modifiers = (Modifiers)field.Modifiers;
				bool isStatic = (modifiers & Modifiers.Static) != 0;
				CodeEmitter getter = null;
				object constant = null;
				if(field.redirect == null)
				{
					if(field.Constant == null || (modifiers & (Modifiers.Static | Modifiers.Final)) != (Modifiers.Static | Modifiers.Final))
					{
						// TODO better error handling
						throw new InvalidOperationException();
					}
					// we got a constant (literal) field
					switch(fieldSig)
					{
						case "J":
							constant = long.Parse(field.Constant);
							break;
						default:
							throw new NotImplementedException("constant field of type: " + fieldSig);
					}
					getter = CodeEmitter.CreateLoadConstant(constant);
				}
				else
				{
					// NOTE when fields are redirected it's always to a method!
					// NOTE only reading a field can be redirected!
					if(field.redirect.Name != null)
					{
						name = field.redirect.Name;
					}
					if(field.redirect.Sig != null)
					{
						sig = field.redirect.Sig;
					}
					string stype = isStatic ? "static" : "instance";
					if(field.redirect.Type != null)
					{
						stype = field.redirect.Type;
					}
					MethodDescriptor redir = MethodDescriptor.FromNameSig(GetClassLoader(), name, sig);
					BindingFlags binding = BindingFlags.Public | BindingFlags.NonPublic;
					if(stype == "static")
					{
						binding |= BindingFlags.Static;
					}
					else
					{
						binding |= BindingFlags.Instance;
					}
					if(field.redirect.Class != null)
					{
						TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(field.redirect.Class);
						MethodWrapper method = tw.GetMethodWrapper(redir, false);
						if(method == null)
						{
							// TODO better error handling
							throw new InvalidOperationException("remapping method: " + name + sig + " not found");
						}
						getter = method.EmitCall;
					}
					else
					{
						MethodInfo method = type.GetMethod(name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
						if(method == null)
						{
							// TODO better error handling
							throw new InvalidOperationException("remapping method: " + name + sig + " not found");
						}
						getter = CodeEmitter.Create(OpCodes.Call, method);
					}
					// ensure that return type for redirected method matches with field type, or emit a castclass
					if(!field.redirect.Sig.EndsWith(fieldSig))
					{
						if(fieldSig[0] == 'L')
						{
							getter += new ReturnCastEmitter(ClassLoaderWrapper.LoadClassCritical(fieldSig.Substring(1, fieldSig.Length - 2)));
						}
						else if(fieldSig[0] == '[')
						{
							getter += new ReturnCastEmitter(ClassLoaderWrapper.LoadClassCritical(fieldSig));
						}
						else
						{
							// TODO better error handling
							throw new InvalidOperationException("invalid field sig: " + fieldSig);
						}
					}
				}
				CodeEmitter setter = CodeEmitter.InternalError;
				// HACK we abuse RetTypeWrapperFromSig
				FieldWrapper fw = FieldWrapper.Create(this, GetClassLoader().RetTypeWrapperFromSig("()" + fieldSig), fieldName, fieldSig, modifiers, null, getter, setter, constant);
				AddField(fw);
			}
		}
		if(classMap.Interfaces != null)
		{
			ArrayList ar = new ArrayList();
			if(interfaces != null)
			{
				for(int i = 0; i < interfaces.Length; i++)
				{
					ar.Add(interfaces[i]);
				}
			}
			foreach(MapXml.Interface iface in classMap.Interfaces)
			{
				ar.Add(GetClassLoader().LoadClassByDottedName(iface.Name));
			}
			interfaces = (TypeWrapper[])ar.ToArray(typeof(TypeWrapper));
		}
		// if the type has "overrides" we need to construct a stub class that actually overrides the methods
		// (for when the type itself is instantiated, instead of a subtype [e.g. java.lang.Throwable])
		if(hasOverrides)
		{
			//Console.WriteLine("constructing override stub for " + Name);
			// HACK because we don't want to end up with System.Exception (which is the type that corresponds to the
			// TypeWrapper that corresponds to the type of Throwable$OverrideStub) we have to use GetBootstrapTypeRaw,
			// which was introduced specifically to deal with this problem
			Type stubType = ClassLoaderWrapper.GetBootstrapClassLoader().GetBootstrapTypeRaw(Name + "$OverrideStub");
			if(stubType != null)
			{
				foreach(MethodWrapper mw in methods)
				{
					MethodDescriptor md = mw.Descriptor;
					if(md.Name == "<init>")
					{
						//Console.WriteLine("replacing newobj " + stubType.FullName + " to " + stubType.GetConstructor(md.ArgTypes));
						// NOTE we only support public constructors here, as that correct?
						mw.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, stubType.GetConstructor(md.ArgTypes));
					}
				}
			}
			else
			{
				// TODO we can ignore the normal ClassNotFoundException, what should we do with other exceptions?
				TypeBuilder stub = GetClassLoader().ModuleBuilder.DefineType(Name + "$OverrideStub", type.Attributes, type);
				CustomAttributeBuilder hideFromReflectionAttrib = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
				stub.SetCustomAttribute(hideFromReflectionAttrib);
				foreach(MethodWrapper mw in methods)
				{
					MethodDescriptor md = mw.Descriptor;
					if(mw.IsRemappedOverride)
					{
						MethodBuilder mb = stub.DefineMethod(md.Name, mw.GetMethodAttributes(), CallingConventions.Standard, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
						ILGenerator ilgen = mb.GetILGenerator();
						ilgen.Emit(OpCodes.Ldarg_0);
						int argc = md.ArgCount;
						for(int n = 0; n < argc; n++)
						{
							ilgen.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
						}
						mw.EmitCall.Emit(ilgen);
						ilgen.Emit(OpCodes.Ret);
						// TODO only explicitly override if it is needed
						stub.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
					}
					else if(md.Name == "<init>")
					{
						ConstructorBuilder cb = stub.DefineConstructor(mw.GetMethodAttributes(), CallingConventions.Standard, md.ArgTypes);
						ILGenerator ilgen = cb.GetILGenerator();
						ilgen.Emit(OpCodes.Ldarg_0);
						int argc = md.ArgCount;
						for(int n = 0; n < argc; n++)
						{
							ilgen.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
						}
						mw.EmitCall.Emit(ilgen);
						ilgen.Emit(OpCodes.Ret);
						mw.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, cb);
					}
				}
				// TODO consider post-poning this until the type is really needed
				stub.CreateType();
			}
		}
		box = classMap.Box;
	}

	public override TypeWrapper[] Interfaces
	{
		get
		{
			return interfaces;
		}
	}

	public override TypeWrapper[] InnerClasses
	{
		get
		{
			// remapped types do not support inner classes at the moment
			return TypeWrapper.EmptyArray;
		}
	}

	public override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			// remapped types cannot be inside inner classes at the moment
			return null;
		}
	}

	public override Type TypeAsTBD
	{
		get
		{
			return type;
		}
	}

	public override void Finish()
	{
	}

	internal override void ImplementOverrideStubsAndVirtuals(TypeBuilder typeBuilder, DynamicTypeWrapper wrapper, Hashtable methodLookup)
	{
		MethodWrapper[] methods = GetMethods();
		Type virtualsInterface = VirtualsInterface;
		if(virtualsInterface != null)
		{
			typeBuilder.AddInterfaceImplementation(virtualsInterface);
		}
		for(int i = 0; i < methods.Length; i++)
		{
			MethodWrapper mce = methods[i];
			if(mce.IsRemappedOverride)
			{
				MethodDescriptor md = mce.Descriptor;
				if(!methodLookup.ContainsKey(md))
				{
					MethodBuilder mb = typeBuilder.DefineMethod(md.Name, mce.GetMethodAttributes(), CallingConventions.Standard, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
					ILGenerator ilgen = mb.GetILGenerator();
					ilgen.Emit(OpCodes.Ldarg_0);
					int argc = md.ArgCount;
					for(int n = 0; n < argc; n++)
					{
						ilgen.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
					}
					mce.EmitCall.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
					// TODO only explicitly override if it is needed
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)mce.GetMethod());
					// now add the method to methodLookup, to prevent the virtuals loop below from adding it again
					methodLookup[md] = md;
				}
			}
			if(mce.IsRemappedVirtual)
			{
				MethodDescriptor md = mce.Descriptor;
				if(!methodLookup.ContainsKey(md))
				{
					// TODO the attributes aren't correct, but we cannot make the method non-public, because
					// that would violate the interface contract. In other words, we need to find a different
					// mechanism for implementing non-public virtuals.
					MethodBuilder mb = typeBuilder.DefineMethod(md.Name, MethodAttributes.Virtual | MethodAttributes.Public, CallingConventions.Standard, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
					ILGenerator ilgen = mb.GetILGenerator();
					ilgen.Emit(OpCodes.Ldarg_0);
					int argc = md.ArgCount;
					for(int n = 0; n < argc; n++)
					{
						ilgen.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
					}
					mce.EmitCall.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
			}
		}
	}

	private MethodWrapper[] GetVirtuals()
	{
		ArrayList array = new ArrayList();
		foreach(MethodWrapper mw in GetMethods())
		{
			if(mw.IsRemappedVirtual)
			{
				array.Add(mw);
			}
		}
		return (MethodWrapper[])array.ToArray(typeof(MethodWrapper));
	}

	private Type VirtualsInterface
	{
		get
		{
			if(!virtualsInterfaceBuilt)
			{
				virtualsInterfaceBuilt = true;
				MethodWrapper[] virtuals = GetVirtuals();
				if(virtuals.Length > 0)
				{
					// if the virtualsinterface already exists in one of the bootstrap DLLs, we need to reference that one
					// instead of creating another one, because creating a new type breaks compatibility with pre-compiled code
					try
					{
						TypeWrapper twInterface = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast(Name + "$VirtualMethods");
						TypeWrapper twHelper = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast(Name + "$VirtualMethodsHelper");
						if(twInterface != null && twHelper != null)
						{
							twInterface.Finish();
							twHelper.Finish();
							virtualsInterface = twInterface.TypeAsTBD;
							virtualsHelperHack = twHelper.TypeAsTBD;
						}
					}
					catch(Exception)
					{
					}
					if(virtualsInterface != null && virtualsHelperHack != null)
					{
						return virtualsInterface;
					}
					// TODO since this construct makes all virtual methods public, we need to find another way of doing this,
					// or split the methods in two interfaces, one public and one friendly (but how about protected?).
					TypeBuilder typeBuilder = GetClassLoader().ModuleBuilder.DefineType(Name + "$VirtualMethods", TypeAttributes.Abstract | TypeAttributes.Interface | TypeAttributes.Public);
					TypeBuilder tbStaticHack = GetClassLoader().ModuleBuilder.DefineType(Name + "$VirtualMethodsHelper", TypeAttributes.Class | TypeAttributes.Public);
					foreach(MethodWrapper mw in virtuals)
					{
						MethodDescriptor md = mw.Descriptor;
						MethodBuilder ifmethod = typeBuilder.DefineMethod(md.Name, MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
						Type[] args = new Type[md.ArgTypesForDefineMethod.Length + 1];
						md.ArgTypesForDefineMethod.CopyTo(args, 1);
						args[0] = this.TypeAsTBD;
						MethodBuilder mb = tbStaticHack.DefineMethod(md.Name, MethodAttributes.Public | MethodAttributes.Static, md.RetTypeForDefineMethod, args);
						ILGenerator ilgen = mb.GetILGenerator();
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, typeBuilder);
						ilgen.Emit(OpCodes.Dup);
						Label label1 = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brtrue_S, label1);
						ilgen.Emit(OpCodes.Pop);
						for(int i = 0; i < args.Length; i++)
						{
							ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
						}
						GetMethodWrapper(md, true).EmitCall.Emit(ilgen);
						Label label2 = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Br_S, label2);
						ilgen.MarkLabel(label1);
						for(int i = 1; i < args.Length; i++)
						{
							ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
						}
						ilgen.Emit(OpCodes.Callvirt, ifmethod);
						ilgen.MarkLabel(label2);
						ilgen.Emit(OpCodes.Ret);
					}
					virtualsInterface = typeBuilder.CreateType();
					virtualsHelperHack = tbStaticHack.CreateType();
				}
			}
			return virtualsInterface;
		}
	}

	// HACK since Reflection.Emit won't allow static methods on an interface (which is a bug), we create
	// a separate type to contain the static helper methods
	public Type VirtualsHelperHack
	{
		get
		{
			// make sure that the type has been created
			object o = this.VirtualsInterface;
			return virtualsHelperHack;
		}
	}

	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
	{
		return null;
	}

	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		return null;
	}

	internal override void EmitBox(ILGenerator ilgen)
	{
		if(box != null)
		{
			box.Emit(ilgen);
		}
		else
		{
			base.EmitBox(ilgen);
		}
	}
}

// TODO this is the base class of CompiledTypeWrapper (ikmvc compiled Java types)
// and DotNetTypeWrapper (.NET types), it should have a better name.
abstract class LazyTypeWrapper : TypeWrapper
{
	private bool membersPublished;

	protected LazyTypeWrapper(Modifiers modifiers, string name, TypeWrapper baseTypeWrapper, ClassLoaderWrapper classLoader)
		: base(modifiers, name, baseTypeWrapper, classLoader)
	{
	}

	protected abstract void LazyPublishMembers();

	protected sealed override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				LazyPublishMembers();
				return GetFieldWrapper(fieldName, fieldType);
			}
		}
		return null;
	}

	protected sealed override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				LazyPublishMembers();
				return GetMethodWrapper(md, false);
			}
		}
		return null;
	}

	public sealed override void Finish()
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				LazyPublishMembers();
			}
		}
	}
}

class CompiledTypeWrapper : LazyTypeWrapper
{
	private readonly Type type;
	private TypeWrapper[] interfaces;
	private TypeWrapper[] innerclasses;
	private FieldInfo ghostRefField;
	private Type typeAsBaseType;

	internal static string GetName(Type type)
	{
		Debug.Assert(type.Module.IsDefined(typeof(JavaModuleAttribute), false));

		if(type.IsDefined(typeof(HideFromReflectionAttribute), false))
		{
			return ClassLoaderWrapper.GetWrapperFromType(type.BaseType).Name;
		}
d3928 12
a3946 1
		Debug.Assert(!type.IsDefined(typeof(HideFromReflectionAttribute), false));
d3949 7
a3955 1
		Debug.Assert(!ClassLoaderWrapper.IsRemappedType(type));
d4007 1
a4007 1
	public override TypeWrapper[] Interfaces
d4030 1
a4030 1
	public override TypeWrapper[] InnerClasses
d4051 1
a4051 1
	public override TypeWrapper DeclaringTypeWrapper
d4111 1
a4111 1
		foreach(MemberInfo m in members)
d4113 1
a4113 1
			if(!m.IsDefined(typeof(HideFromReflectionAttribute), false))
d4115 1
a4115 2
				MethodBase method = m as MethodBase;
				if(method != null)
d4117 92
a4208 1
					AddMethod(CreateMethodWrapper(method));
d4212 1
a4212 2
					FieldInfo field = m as FieldInfo;
					if(field != null)
d4214 9
a4222 1
						AddField(CreateFieldWrapper(field));
d4226 21
d4248 1
d4257 1
d4259 1
d4266 1
d4276 5
d4358 17
a4374 1
	public override Type TypeAsTBD
d4378 9
a4386 1
			return type;
d4785 1
a4785 1
	public override TypeWrapper[] Interfaces
d4791 1
a4791 1
			if(ClassLoaderWrapper.IsRemappedType(TypeAsTBD) && !TypeAsTBD.IsInterface)
d4805 1
a4805 1
	public override TypeWrapper[] InnerClasses
d4825 1
a4825 1
	public override TypeWrapper DeclaringTypeWrapper
d5055 1
a5055 1
	public override Type TypeAsTBD
d5103 1
a5103 1
	public override TypeWrapper[] Interfaces
d5118 1
a5118 1
	public override TypeWrapper[] InnerClasses
d5126 1
a5126 1
	public override TypeWrapper DeclaringTypeWrapper
d5134 1
a5134 1
	public override Type TypeAsTBD
d5165 1
a5165 1
	public override void Finish()
@


1.64
log
@*** empty log message ***
@
text
@d1328 1
a1328 1
			else if(mce.RealName != ifmethod.Name)
@


1.63
log
@*** empty log message ***
@
text
@d1348 2
a1349 6
				if(mce.IsAbstract)
				{
					// TODO figure out what to do here
					throw new NotImplementedException();
				}
				MethodBuilder mb = typeBuilder.DefineMethod(md.Name, MethodAttributes.Public | MethodAttributes.Virtual, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
d1358 1
a1358 1
				mce.EmitCall.Emit(ilGenerator);
@


1.62
log
@*** empty log message ***
@
text
@d1137 1
a1137 1
			Debug.Assert(this.IsArray);
@


1.61
log
@*** empty log message ***
@
text
@d863 8
@


1.60
log
@*** empty log message ***
@
text
@d1180 2
a1181 1
			for(int i = 0; i < typeWrapper.Interfaces.Length; i++)
d1183 1
a1183 1
				if(typeWrapper.Interfaces[i] == interfaceWrapper)
d1187 1
a1187 1
				if(typeWrapper.Interfaces[i].ImplementsInterface(interfaceWrapper))
d1250 4
@


1.59
log
@*** empty log message ***
@
text
@d852 1
a852 1
	protected abstract FieldWrapper GetFieldImpl(string fieldName);
d854 1
a854 2
	// TODO this shouldn't just be based on the name, fields can be overloaded on type
	public FieldWrapper GetFieldWrapper(string fieldName)
d856 2
a857 1
		FieldWrapper fae = (FieldWrapper)fields[fieldName];
d860 1
a860 1
			fae = GetFieldImpl(fieldName);
d865 1
a865 1
					return baseWrapper.GetFieldWrapper(fieldName);
d869 1
a869 1
			fields[fieldName] = fae;
d922 1
a922 1
		fields[field.Name] = field;
d1727 1
a1727 1
	protected override FieldWrapper GetFieldImpl(string fieldName)
d1832 1
a1832 1
	protected override FieldWrapper GetFieldImpl(string fieldName)
d1939 1
a1939 1
	protected override FieldWrapper GetFieldImpl(string fieldName)
d1941 1
a1941 1
		return impl.GetFieldImpl(fieldName);
d2007 1
a2007 1
		public abstract FieldWrapper GetFieldImpl(string fieldName);
d2293 1
a2293 1
						fieldLookup[classFile.Fields[i].Name] = i;
d2884 1
a2884 1
		public override FieldWrapper GetFieldImpl(string fieldName)
d2892 1
a2892 1
					fieldLookup[classFile.Fields[i].Name] = i;
d2895 1
a2895 1
			object index = fieldLookup[fieldName];
d3525 1
a3525 1
		public override FieldWrapper GetFieldImpl(string fieldName)
d4328 1
a4328 1
	protected override FieldWrapper GetFieldImpl(string fieldName)
d4364 1
a4364 1
	protected sealed override FieldWrapper GetFieldImpl(string fieldName)
d4372 1
a4372 1
				return GetFieldWrapper(fieldName);
d5490 1
a5490 1
	protected override FieldWrapper GetFieldImpl(string fieldName)
@


1.58
log
@*** empty log message ***
@
text
@d4351 55
a4405 2
// TODO CompiledTypeWrapper & DotNetTypeWrapper should have a common base class
class CompiledTypeWrapper : TypeWrapper
d4607 1
a4607 27
	// TODO there is an inconsistency here, this method returns regular FieldWrappers for final fields, while
	// GetFieldImpl returns a FieldWrapper that is aware of the getter method. Currently this isn't a problem,
	// because this method is used for reflection (which doesn't care about accessibility) and GetFieldImpl is used for
	// compiled code (which does care about accessibility).
	internal override FieldWrapper[] GetFields()
	{
		ArrayList list = new ArrayList();
		FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
		for(int i = 0; i < fields.Length; i++)
		{
			if(!AttributeHelper.IsHideFromReflection(fields[i]) && !fields[i].IsSpecialName)
			{
				// if the field name is mangled (because its type is unloadable),
				// chop off the mangled bit
				string fieldName = fields[i].Name;
				int idx = fieldName.IndexOf('/');
				if(idx >= 0)
				{
					fieldName = fieldName.Substring(0, idx);
				}
				list.Add(CreateFieldWrapper(AttributeHelper.GetModifiers(fields[i], false), fieldName, fields[i].FieldType, fields[i], null));
			}
		}
		return (FieldWrapper[])list.ToArray(typeof(FieldWrapper));
	}

	private FieldWrapper CreateFieldWrapper(Modifiers modifiers, string name, Type fieldType, FieldInfo field, MethodInfo getter)
d4609 2
a4610 9
		CodeEmitter emitGet;
		CodeEmitter emitSet;
		if((modifiers & Modifiers.Private) != 0)
		{
			// there is no way to emit code to access a private member, so we don't need to generate these
			emitGet = CodeEmitter.InternalError;
			emitSet = CodeEmitter.InternalError;
		}
		else if((modifiers & Modifiers.Static) != 0)
d4612 1
a4612 1
			if(getter != null)
d4614 2
a4615 6
				emitGet = CodeEmitter.Create(OpCodes.Call, getter);
			}
			else
			{
				// if field is a literal, we emit an ldc instead of a ldsfld
				if(field.IsLiteral)
d4617 1
a4617 1
					emitGet = CodeEmitter.CreateLoadConstantField(field);
d4621 5
a4625 1
					emitGet = CodeEmitter.Create(OpCodes.Ldsfld, field);
a4627 33
			if(field != null && !field.IsLiteral)
			{
				emitSet = CodeEmitter.Create(OpCodes.Stsfld, field);
			}
			else
			{
				// TODO what happens when you try to set a final field?
				// through reflection: java.lang.IllegalAccessException: Field is final
				// through code: java.lang.IllegalAccessError: Field <class>.<field> is final
				emitSet = CodeEmitter.Nop;
			}
		}
		else
		{
			if(getter != null)
			{
				emitGet = CodeEmitter.Create(OpCodes.Callvirt, getter);
			}
			else
			{
				// TODO is it possible to have literal instance fields?
				emitGet = CodeEmitter.Create(OpCodes.Ldfld, field);
			}
			if(field != null)
			{
				emitSet = CodeEmitter.Create(OpCodes.Stfld, field);
			}
			else
			{
				// TODO what happens when you try to set a final field through reflection?
				// see above
				emitSet = CodeEmitter.Nop;
			}
a4628 1
		return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(fieldType), name, MethodDescriptor.GetFieldSigName(field), modifiers, field, emitGet, emitSet);
d4631 1
a4631 1
	protected override FieldWrapper GetFieldImpl(string fieldName)
d4633 1
a4633 77
		// TODO this is a crappy implementation, just to get going, but it needs to be revisited
		MemberInfo[] members = type.GetMember(fieldName, MemberTypes.Field | MemberTypes.Property, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
		if(members.Length > 2)
		{
			throw new NotImplementedException();
		}
		if(members.Length == 0)
		{
			return null;
		}
		if(members.Length == 2)
		{
			PropertyInfo prop;
			FieldInfo field;
			if(members[0] is PropertyInfo && !(members[1] is PropertyInfo))
			{
				prop = (PropertyInfo)members[0];
				field = (FieldInfo)members[1];
			}
			else if(members[1] is PropertyInfo && !(members[0] is PropertyInfo))
			{
				prop = (PropertyInfo)members[1];
				field = (FieldInfo)members[0];
			}
			else
			{
				// TODO what does this mean?
				throw new InvalidOperationException();
			}
			Modifiers modifiers = AttributeHelper.GetModifiers(field, false);
			MethodInfo getter = prop.GetGetMethod(true);
			MethodInfo setter = prop.GetSetMethod(true);
			if(getter == null || setter != null)
			{
				// TODO what does this mean?
				throw new InvalidOperationException();
			}
			return CreateFieldWrapper(modifiers, field.Name, field.FieldType, field, getter);
		}
		else
		{
			FieldInfo fi = (FieldInfo)members[0];
			return CreateFieldWrapper(AttributeHelper.GetModifiers(fi, false), fi.Name, fi.FieldType, fi, null);
		}
	}
	
	// TODO this is broken
	internal override MethodWrapper[] GetMethods()
	{
		ArrayList list = new ArrayList();
		MethodInfo[] methods = type.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
		for(int i = 0; i < methods.Length; i++)
		{
			MethodWrapper mw = CreateMethodWrapper(MethodDescriptor.FromMethodBase(methods[i]), methods[i]);
			if(mw != null)
			{
				list.Add(mw);
			}
		}
		ConstructorInfo[] constructors = type.GetConstructors(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
		for(int i = 0; i < constructors.Length; i++)
		{
			MethodWrapper mw = CreateMethodWrapper(MethodDescriptor.FromMethodBase(constructors[i]), constructors[i]);
			if(mw != null)
			{
				list.Add(mw);
			}
		}
		return (MethodWrapper[])list.ToArray(typeof(MethodWrapper));
	}

	private MethodWrapper CreateMethodWrapper(MethodDescriptor md, MethodBase mb)
	{
		if(AttributeHelper.IsHideFromReflection(mb))
		{
			return null;
		}
d4658 1
a4658 1
	private static bool IsBuilderType(Type type)
d4660 20
a4679 1
		while(type.IsArray)
d4681 3
a4683 1
			type = type.GetElementType();
d4685 1
a4685 9
		return type is TypeBuilder;
	}

	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		// If the MethodDescriptor contains types that aren't compiled types, we can never have that method
		// This check is important because Type.GetMethod throws an ArgumentException if one of the argument types
		// is a TypeBuilder
		for(int i = 0; i < md.ArgCount; i++)
d4687 1
a4687 1
			if(md.ArgTypeWrappers[i].IsUnloadable || IsBuilderType(md.ArgTypeWrappers[i].TypeAsTBD))
d4689 1
a4689 1
				return null;
d4691 4
d4696 1
a4696 1
		try
d4698 1
a4698 2
			// TODO this is a crappy implementation, just to get going, but it needs to be revisited
			if(md.Name == "<init>")
d4700 1
a4700 5
				ConstructorInfo ci = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, md.ArgTypes, null);
				if(ci != null)
				{
					return CreateMethodWrapper(md, ci);
				}
d4704 1
a4704 5
				MethodInfo mi = type.GetMethod(md.Name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, CallingConventions.Standard, md.ArgTypes, null);
				if(mi != null)
				{
					return CreateMethodWrapper(md, mi);
				}
d4706 1
d4708 1
a4708 1
		catch
d4710 1
a4710 2
			// HACK this is for debugging only (if the above check fails to detect funky types in the argument array)
			foreach(TypeWrapper tw in md.ArgTypeWrappers)
d4712 5
a4716 1
				Console.WriteLine(tw.Name);
d4718 1
a4718 1
			throw;
d4720 8
a4727 1
		return null;
a4736 4

	public override void Finish()
	{
	}
d4739 1
a4739 1
class DotNetTypeWrapper : TypeWrapper
a4743 1
	private bool membersPublished;
d4944 1
a4944 1
	private void LazyPublishMembers()
a5402 28
	protected override FieldWrapper GetFieldImpl(string fieldName)
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				LazyPublishMembers();
				return GetFieldWrapper(fieldName);
			}
		}
		return null;
	}

	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				LazyPublishMembers();
				return GetMethodWrapper(md, false);
			}
		}
		return null;
	}

a5409 12

	public override void Finish()
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				LazyPublishMembers();
			}
		}
	}
@


1.57
log
@*** empty log message ***
@
text
@d1572 2
d1614 2
d1877 2
d2101 2
d2398 2
a2399 2
						// Add "IsInstance" method
						mb = typeBuilder.DefineMethod("IsInstance", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object) });
d2421 2
a2422 2
						// Add "Cast" method
						mb = typeBuilder.DefineMethod("Cast", MethodAttributes.Public | MethodAttributes.Static, wrapper.TypeAsParameterType, new Type[] { typeof(object) });
d3556 26
@


1.56
log
@*** empty log message ***
@
text
@d191 1
a191 1
			name = GetSigNameFromType(type);
d205 1
a205 1
			name = GetSigNameFromType(type);
d217 1
a217 1
		return GetSigNameFromType(type);
a263 56
	private static string GetSigNameFromType(Type type)
	{
		if(type.IsValueType)
		{
			if(type == typeof(void))
			{
				return "V";
			}
			else if(type == typeof(bool))
			{
				return "Z";
			}
			else if(type == typeof(sbyte))
			{
				return "B";
			}
			else if(type == typeof(char))
			{
				return "C";
			}
			else if(type == typeof(short))
			{
				return "S";
			}
			else if(type == typeof(int))
			{
				return "I";
			}
			else if(type == typeof(long))
			{
				return "J";
			}
			else if(type == typeof(float))
			{
				return "F";
			}
			else if(type == typeof(double))
			{
				return "D";
			}
			else
			{
				return "L" + type.FullName + ";";
			}
		}
		else
		{
			string s = NativeCode.java.lang.VMClass.getName(type);
			if(s[0] != '[')
			{
				s = "L" + s + ";";
			}
			return s;
		}
	}

d462 1
a462 1
		Type iface = ifaceWrapper.Type;
d725 1
a725 1
			return this != VerifierTypeWrapper.Null && !IsPrimitive && !IsGhost && Type.IsValueType;
d1001 1
a1001 1
	public abstract Type Type
d1010 1
a1010 1
			TypeBuilder typeBuilder = Type as TypeBuilder;
d1042 1
a1042 1
			return Type;
d1050 1
a1050 1
			return Type;
d1077 1
a1077 1
			return Type;
d1081 1
d1100 1
a1100 1
			return Type;
d1112 1
a1112 1
			return Type;
d1129 1
d1135 1
a1135 4
			if(name[0] != '[')
			{
				throw new InvalidOperationException(name);
			}
d1140 3
a1142 2
					// TODO are we allowed to trigger class loading here?
					return classLoader.LoadClassByDottedName(name.Substring(1));
d1144 3
a1146 1
					return classLoader.LoadClassByDottedName(name.Substring(2, name.Length - 3));
d1171 2
a1172 1
		return GetClassLoader().LoadClassByDottedName(new String('[', rank) + this.SigName);
d1330 1
a1330 1
			else if(mce.DeclaringType.Type.Assembly != typeBuilder.Assembly)
d1422 2
d1425 1
a1425 4
		if(!IsInterface)
		{
			throw new InvalidOperationException();
		}
d1439 1
a1439 1
		if(Type.Assembly is AssemblyBuilder || this is RemappedTypeWrapper)
d1486 5
d1495 1
a1495 1
		Type type = this.Type;
d1514 1
a1514 1
		ilgen.Emit(OpCodes.Box, this.Type);
d1527 1
a1527 1
				ilgen.Emit(OpCodes.Castclass, Type);
d1565 149
d1733 1
a1733 1
	public override Type Type
d1769 14
d1820 1
a1820 1
	public override Type Type
d1967 1
a1967 1
	public override Type Type
d2130 4
a2133 4
			if(inner.Length <= (outer.Length + 1) || inner[outer.Length] != '$' || inner.IndexOf('$', outer.Length + 1) >= 0)
			{
				throw new InvalidOperationException(string.Format("Inner class name {0} is not well formed wrt outer class {1}", inner, outer));
			}
d2143 1
a2143 1
					if(caller[i].Type == typeof(sbyte[]) && callee[i].Type == typeof(byte[]))
d2471 1
a2471 1
				bool basehasclinit = (wrapper.BaseTypeWrapper == null) ? false : wrapper.BaseTypeWrapper.Type.TypeInitializer != null;
d2525 1
a2525 1
							Type nativeCodeType = Type.GetType("NativeCode." + classFile.Name);
d2568 1
a2568 1
								if(!retTypeWrapper.Type.Equals(nativeMethod.ReturnType) && !retTypeWrapper.IsGhost)
d2570 1
a2570 1
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.Type);
d2793 1
a2793 1
					ilGenerator.Emit(OpCodes.Ldtoken, wrapper.Type);
d2817 1
a2817 1
				ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, (retTypeWrapper.IsPrimitive) ? retTypeWrapper.Type : typeof(IntPtr), modargs);
d2830 1
a2830 1
							ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.Type);
a3228 14
								// if our method's accessibility is less than the method it overrides, we
								// need to make our method more accessible, because the CLR doesn't allow reducing access
								if((attribs & MethodAttributes.Public) == 0)
								{
									attribs &= ~MethodAttributes.MemberAccessMask;
									if(baseMce.IsPublic)
									{
										attribs |= MethodAttributes.Public;
									}
									else
									{
										attribs |= MethodAttributes.FamORAssem;
									}
								}
d3598 1
d3621 1
d3661 1
a3661 1
								redirect = tw.Type.GetMethod(name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
d3670 1
d3684 1
a3684 1
						if(BaseTypeWrapper != null && !Type.IsSealed)
d3723 1
d3797 1
d3814 1
d3831 1
d3857 1
a3857 1
									redirect = tw.Type.GetMethod(constructor.redirect.Name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
d3861 1
a3861 1
									redirect = tw.Type.GetConstructor(binding, null, CallingConventions.Standard, redir.ArgTypes, null);
d3878 1
d3932 1
d3979 1
d3989 1
d4007 1
d4128 1
a4128 1
	public override Type Type
d4228 2
a4229 2
							virtualsInterface = twInterface.Type;
							virtualsHelperHack = twHelper.Type;
d4249 1
a4249 1
						args[0] = this.Type;
d4328 2
a4329 1
		Debug.Assert(type.Assembly.IsDefined(typeof(JavaAssemblyAttribute), false));
d4639 1
d4647 1
d4730 1
a4730 1
			if(md.ArgTypeWrappers[i].IsUnloadable || IsBuilderType(md.ArgTypeWrappers[i].Type))
d4767 1
a4767 1
	public override Type Type
d4832 1
a4832 1
		Debug.Assert(!type.Assembly.IsDefined(typeof(JavaAssemblyAttribute), false), type.FullName);
d4925 1
a4925 1
		Debug.Assert(!(type.Assembly.IsDefined(typeof(JavaAssemblyAttribute), false)));
d4940 1
a4940 1
			return Delegate.CreateDelegate(DeclaringType.Type, args[0], "Invoke");
d5045 1
a5045 1
					method.EmitNewobj = new DelegateConstructorEmitter(type.GetConstructor(new Type[] { typeof(object), typeof(IntPtr) }), iface.Type.GetMethod("Invoke"));
d5181 1
a5181 1
			if(ClassLoaderWrapper.IsRemappedType(Type) && !Type.IsInterface)
d5362 1
a5362 1
					method.EmitNewobj += CodeEmitter.Create(OpCodes.Box, this.Type);
d5473 1
a5473 1
	public override Type Type
d5564 1
a5564 1
	public override Type Type
a5596 2
		// TODO once we have upward notification (when element TypeWrappers have a reference to their containing arrays)
		// we can optimize this
d5602 1
a5602 1
				Type elementType = elementTypeWrapper.Type;
@


1.55
log
@*** empty log message ***
@
text
@d103 1
a103 1
					temp[i] = wrappers[i].Type;
d138 1
a138 1
			return RetTypeWrapper.Type;
d242 1
a242 1
			typeWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Object");
d536 1
a536 1
	internal static Modifiers GetModifiers(MethodBase mb)
d548 1
a548 1
		if(mb.IsPrivate)
d552 1
a552 1
		if(mb.IsFamily || mb.IsFamilyOrAssembly)
d556 4
d591 1
a591 1
	internal static Modifiers GetModifiers(FieldInfo fi)
d603 1
a603 1
		if(fi.IsPrivate)
d607 1
a607 1
		if(fi.IsFamily || fi.IsFamilyOrAssembly)
d611 4
d1017 1
a1017 1
	public bool IsInSamePackageAs(TypeWrapper wrapper)
d1027 22
a1048 1
			if(index1 != index2)
d1052 1
a1052 1
			return String.CompareOrdinal(name, 0, wrapper.name, 0, index1) == 0;
d1183 2
d1223 5
d1269 1
a1269 1
			java_lang_Object = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Object");
d2091 2
a2092 2
				Console.Error.WriteLine("Internal Error: Finish triggered during phase 1 of compilation.");
				Environment.Exit(1);
d2470 1
d2569 27
a2595 1
				if(JVM.IsStaticCompiler)
d2597 1
a2597 1
					throw new InvalidOperationException("Internal error during finishing of " + wrapper.Name, x);
d2599 4
a2602 4
				// NOTE we use reflection to invoke MessageBox.Show, to make sure we run on Mono as well
				Assembly winForms = Assembly.LoadWithPartialName("System.Windows.Forms");
				Type messageBox = null;
				if(winForms != null)
d2604 1
a2604 1
					messageBox = winForms.GetType("System.Windows.Forms.MessageBox");
d2606 1
a2606 1
				if(messageBox != null)
d2608 1
a2608 6
					string message = String.Format("****** Exception during finishing of {0} ******", wrapper.Name);
					message += "\r\n" + x;
					message += "\r\n" + new StackTrace(x);
					message += "\r\n" + new StackTrace(true);
					messageBox.InvokeMember("Show", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.Public, null, null, new object[] { message, "IKVM.NET Internal Error" });
					//System.Windows.Forms.MessageBox.Show(message, "IKVM.NET Internal Error");
d2610 3
a2612 1
				else
d2614 1
a2614 4
					Console.WriteLine("****** Exception during finishing of {0} ******", wrapper.Name);
					Console.WriteLine(x);
					Console.WriteLine(new StackTrace(x));
					Console.WriteLine(new StackTrace(true));
d2616 3
a2618 7
				// we bail out, because there is not much chance that we can continue to run after this
				Environment.Exit(1);
				return null;
			}
			finally
			{
				Profiler.Leave("JavaTypeImpl.Finish.Core");
d2923 1
a2923 1
				if(typeWrapper.IsGhostArray)
d3579 1
a3579 1
							retcast = new ReturnCastEmitter(ret);
d3784 1
a3784 1
							retcast = new ReturnCastEmitter(ret);
a3863 1
					Type t = this.type;
d3866 7
a3872 1
						t = ClassLoaderWrapper.GetType(field.redirect.Class);
d3874 1
a3874 2
					MethodInfo method = t.GetMethod(name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
					if(method == null)
d3876 6
a3881 1
						throw new InvalidOperationException("remapping method: " + name + sig + " not found");
a3882 1
					getter = CodeEmitter.Create(OpCodes.Call, method);
d3888 1
a3888 1
							getter += new ReturnCastEmitter(fieldSig.Substring(1, fieldSig.Length - 2));
d3892 1
a3892 1
							getter += new ReturnCastEmitter(fieldSig);
d3900 1
a3900 1
				CodeEmitter setter = CodeEmitter.Throw("java.lang.IllegalAccessError", "Redirected field " + this.Name + "." + fieldName + " is read-only");
d4240 1
a4240 1
			return ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Object");
d4427 1
a4427 1
				list.Add(CreateFieldWrapper(AttributeHelper.GetModifiers(fields[i]), fieldName, fields[i].FieldType, fields[i], null));
d4437 7
a4443 1
		if((modifiers & Modifiers.Static) != 0)
d4454 1
a4454 1
					emitGet = CodeEmitter.CreateLoadConstant(field.GetValue(null));
d4528 1
a4528 1
			Modifiers modifiers = AttributeHelper.GetModifiers(field);
d4540 1
a4540 1
			return CreateFieldWrapper(AttributeHelper.GetModifiers(fi), fi.Name, fi.FieldType, fi, null);
d4575 1
a4575 1
		MethodWrapper method = new MethodWrapper(this, md, mb, null, AttributeHelper.GetModifiers(mb), false);
d4884 1
a4884 1
					AddField(FieldWrapper.Create(this, fieldType, fields[i].Name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], CodeEmitter.CreateLoadConstant(fields[i].GetValue(null)), CodeEmitter.Pop));
d4912 1
a4912 1
					AddField(CreateFieldWrapper(AttributeHelper.GetModifiers(fields[i]), fields[i].Name, fields[i].FieldType, fields[i], null));
d5134 7
a5140 1
		if((modifiers & Modifiers.Static) != 0)
d5151 1
a5151 1
					emitGet = CodeEmitter.CreateLoadConstant(field.GetValue(null));
d5215 1
a5215 1
		Modifiers mods = AttributeHelper.GetModifiers(mb);
d5388 1
a5388 1
		: base(modifiers, name, ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Object"), classLoader)
d5425 2
a5426 2
				tw[0] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Cloneable");
				tw[1] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.io.Serializable");
@


1.54
log
@*** empty log message ***
@
text
@d56 5
d1529 49
d2007 41
d2050 8
d2333 2
d2449 2
a2450 2
					// if we don't have a <clinit> we need to inject one, to call the base class <clinit>
					if(basehasclinit && !hasclinit)
d2452 24
a2475 5
						ConstructorBuilder cb = DefineClassInitializer();
						AttributeHelper.HideFromReflection(cb);
						ILGenerator ilGenerator = cb.GetILGenerator();
						EmitHelper.RunClassConstructor(ilGenerator, Type.BaseType);
						ilGenerator.Emit(OpCodes.Ret);
d4049 9
a4057 2
						virtualsInterface = ClassLoaderWrapper.GetType(Name + "$VirtualMethods");
						virtualsHelperHack = ClassLoaderWrapper.GetType(Name + "$VirtualMethodsHelper");
d4876 1
a4876 1
					AddMethod(CreateMethodWrapper(md, constructors[i], isRemapped));
d4893 27
a4919 1
						AddMethod(CreateMethodWrapper(md, methods[i], isRemapped));
d5123 1
a5123 1
	private MethodWrapper CreateMethodWrapper(MethodDescriptor md, MethodBase mb, bool isRemapped)
d5148 5
@


1.53
log
@*** empty log message ***
@
text
@d365 11
a375 3
		// TODO RunClassConstructor requires full trust, so we need to use a different mechanism...
		ilgen.Emit(OpCodes.Ldtoken, type);
		ilgen.Emit(OpCodes.Call, typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("RunClassConstructor"));
d383 1
d385 63
d780 21
d1327 1
a1327 1
			else if(mce.GetMethod().Name != ifmethod.Name)
d1342 1
a1342 1
			else if(mce.GetMethod().DeclaringType.Assembly != typeBuilder.Assembly)
d1498 26
d1918 4
d1933 20
d2127 1
d2139 1
d2162 1
d2184 1
d2272 1
d2275 23
a2297 2
								// TODO use better resolution
								nativeMethod = nativeCodeType.GetMethod(m.Name);
a2298 1
							TypeWrapper[] args = m.GetArgTypes(wrapper.GetClassLoader());
d2323 1
a2323 1
									//Console.WriteLine("Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
d2347 1
a2347 1
						ConstructorBuilder cb = typeBuilder.DefineTypeInitializer();
d2515 1
a2515 1
							ilGenerator.Emit(OpCodes.Box, args[j].Type);
d2535 1
a2535 2
							ilGenerator.Emit(OpCodes.Unbox, retTypeWrapper.Type);
							ilGenerator.Emit(OpCodes.Ldobj, retTypeWrapper.Type);
d2756 4
d2792 16
d2890 1
a2890 5
					// NOTE we don't need to record the modifiers here, because they aren't visible from Java reflection
					// (well they might be visible from JNI reflection, but that isn't important enough to justify the custom attribute)
					// HACK because Peverify is complaining about private methods in interfaces, I'm making them public for the time being
					method = typeBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
					//method = typeBuilder.DefineTypeInitializer();
d3091 2
d3094 5
d3280 1
d3324 1
d3497 1
d3519 1
d3625 1
d3641 2
d3645 14
a3658 22
					throw new InvalidOperationException();
				}
				// NOTE when fields are redirected it's always to a method!
				// NOTE only reading a field can be redirected!
				if(field.redirect.Name != null)
				{
					name = field.redirect.Name;
				}
				if(field.redirect.Sig != null)
				{
					sig = field.redirect.Sig;
				}
				string stype = isStatic ? "static" : "instance";
				if(field.redirect.Type != null)
				{
					stype = field.redirect.Type;
				}
				MethodDescriptor redir = MethodDescriptor.FromNameSig(GetClassLoader(), name, sig);
				BindingFlags binding = BindingFlags.Public | BindingFlags.NonPublic;
				if(stype == "static")
				{
					binding |= BindingFlags.Static;
d3662 12
a3673 17
					binding |= BindingFlags.Instance;
				}
				Type t = this.type;
				if(field.redirect.Class != null)
				{
					t = ClassLoaderWrapper.GetType(field.redirect.Class);
				}
				MethodInfo method = t.GetMethod(name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
				if(method == null)
				{
					throw new InvalidOperationException("remapping method: " + name + sig + " not found");
				}
				CodeEmitter getter = CodeEmitter.Create(OpCodes.Call, method);
				// ensure that return type for redirected method matches with field type, or emit a castclass
				if(!field.redirect.Sig.EndsWith(fieldSig))
				{
					if(fieldSig[0] == 'L')
d3675 1
a3675 1
						getter += new ReturnCastEmitter(fieldSig.Substring(1, fieldSig.Length - 2));
d3677 3
a3679 1
					else if(fieldSig[0] == '[')
d3681 1
a3681 1
						getter += new ReturnCastEmitter(fieldSig);
d3685 28
a3712 1
						throw new InvalidOperationException("invalid field sig: " + fieldSig);
d3717 1
a3717 1
				FieldWrapper fw = FieldWrapper.Create(this, GetClassLoader().RetTypeWrapperFromSig("()" + fieldSig), fieldName, fieldSig, modifiers, null, getter, setter);
d3802 1
d3999 12
d4401 9
d4417 1
a4417 1
			if(md.ArgTypeWrappers[i].IsUnloadable || md.ArgTypeWrappers[i].Type is TypeBuilder)
d4422 1
a4422 2
		// TODO this is a crappy implementation, just to get going, but it needs to be revisited
		if(md.Name == "<init>")
d4424 10
a4433 2
			ConstructorInfo ci = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, md.ArgTypes, null);
			if(ci != null)
d4435 5
a4439 1
				return CreateMethodWrapper(md, ci);
d4442 1
a4442 1
		else
d4444 2
a4445 2
			MethodInfo mi = type.GetMethod(md.Name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, CallingConventions.Standard, md.ArgTypes, null);
			if(mi != null)
d4447 1
a4447 1
				return CreateMethodWrapper(md, mi);
d4449 1
d4689 1
d4695 1
d4752 5
a4756 2
				MethodDescriptor md = MakeMethodDescriptor(methods[i], isRemapped);
				if(md != null)
d4758 6
a4763 2
					// TODO handle name/signature clash
					AddMethod(CreateMethodWrapper(md, methods[i], isRemapped));
d5010 2
d5022 1
a5022 1
				method.EmitCall += CodeEmitter.Create(OpCodes.Box, md.RetTypeWrapper.Type);
d5029 1
a5029 1
					method.EmitCallvirt += CodeEmitter.Create(OpCodes.Box, md.RetTypeWrapper.Type);
@


1.52
log
@*** empty log message ***
@
text
@d1068 1
d3841 1
a3841 1
	internal static Modifiers GetModifiers(Type type)
d3843 2
a3844 9
		try
		{
			object[] customAttribute = type.GetCustomAttributes(typeof(ModifiersAttribute), false);
			if(customAttribute.Length == 1)
			{
				return ((ModifiersAttribute)customAttribute[0]).Modifiers;
			}
		}
		catch(Exception x)
d3846 1
a3846 2
			// HACK this is just to find other types that don't support GetCustomAttributes
			Console.WriteLine(x);
d3851 1
a3851 1
		if(type.IsPublic || type.IsNestedPublic)
d3855 2
a3856 1
		if(type.IsNestedPrivate)
d3858 1
a3858 1
			modifiers |= Modifiers.Private;
d3860 1
a3860 1
		if(type.IsNestedFamily || type.IsNestedFamORAssem)
d3862 1
a3862 1
			modifiers |= Modifiers.Protected;
d3864 1
a3864 1
		if(type.IsSealed)
d3866 1
a3866 1
			modifiers |= Modifiers.Final;
d3868 1
a3868 1
		if(type.DeclaringType != null)
d3872 5
d4231 10
a4240 2
		Modifiers mods = CompiledTypeWrapper.GetModifiers(type);
		if(ClassLoaderWrapper.IsRemappedType(type) && !type.IsInterface)
d4242 1
a4242 1
			mods |= Modifiers.Final;
d4244 22
a4265 1
		return mods;
@


1.51
log
@*** empty log message ***
@
text
@d217 1
a217 1
		object[] attribs = provider.GetCustomAttributes(typeof(GhostTypeAttribute), false);
d220 2
a221 7
			name = GetSigNameFromType(((GhostTypeAttribute)attribs[0]).Type);
			typeWrapper = ClassLoaderWrapper.GetWrapperFromType(((GhostTypeAttribute)attribs[0]).Type);
		}
		else
		{
			attribs = provider.GetCustomAttributes(typeof(UnloadableTypeAttribute), false);
			if(attribs.Length == 1)
d223 1
a223 3
				name = "L" + ((UnloadableTypeAttribute)attribs[0]).Name + ";";
				// TODO it might be loadable now, what do we do?
				typeWrapper = new UnloadableTypeWrapper(((UnloadableTypeAttribute)attribs[0]).Name);
d227 1
a227 2
				name = "Ljava.lang.Object;";
				typeWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Object");
d229 9
d243 1
a243 1
		object[] attribs = provider.GetCustomAttributes(typeof(GhostTypeAttribute), false);
d246 9
a254 6
			return GetSigNameFromType(((GhostTypeAttribute)attribs[0]).Type);
		}
		attribs = provider.GetCustomAttributes(typeof(UnloadableTypeAttribute), false);
		if(attribs.Length == 1)
		{
			return "L" + ((UnloadableTypeAttribute)attribs[0]).Name + ";";
d373 1
d376 18
a393 1
	private static ConstructorInfo ghostTypeAttribute;
d413 9
a579 63
	internal static void SetGhostType(TypeBuilder ownerType, ParameterBuilder pb, TypeWrapper typeWrapper)
	{
		Type type = typeWrapper.Type;
		if(ghostTypeAttribute == null)
		{
			ghostTypeAttribute = typeof(GhostTypeAttribute).GetConstructor(new Type[] { typeof(Type) });
		}
		// HACK because SetCustomAttribute(CustomAttributeBuilder) incorrectly always stores the assembly qualified name
		// we have our own version for when the type lives in the same assembly as the attribute. If we don't do this
		// ikvmc will have problems accessing this attribute when it uses Assembly.LoadFrom to load an assembly.
		if(ownerType.Assembly.Equals(type.Assembly))
		{
			pb.SetCustomAttribute(ghostTypeAttribute, FreezeDryType(type));
		}
		else
		{
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ghostTypeAttribute, new object[] { type });
			pb.SetCustomAttribute(customAttributeBuilder);
		}
	}

	internal static void SetGhostType(MethodBuilder mb, TypeWrapper typeWrapper)
	{
		Type type = typeWrapper.Type;
		if(ghostTypeAttribute == null)
		{
			ghostTypeAttribute = typeof(GhostTypeAttribute).GetConstructor(new Type[] { typeof(Type) });
		}
		// HACK because SetCustomAttribute(CustomAttributeBuilder) incorrectly always stores the assembly qualified name
		// we have our own version for when the type lives in the same assembly as the attribute. If we don't do this
		// ikvmc will have problems accessing this attribute when it uses Assembly.LoadFrom to load an assembly.
		if(mb.DeclaringType.Assembly.Equals(type.Assembly))
		{
			mb.SetCustomAttribute(ghostTypeAttribute, FreezeDryType(type));
		}
		else
		{
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ghostTypeAttribute, new object[] { type });
			mb.SetCustomAttribute(customAttributeBuilder);
		}
	}

	internal static void SetGhostType(FieldBuilder fb, TypeWrapper typeWrapper)
	{
		Type type = typeWrapper.Type;
		if(ghostTypeAttribute == null)
		{
			ghostTypeAttribute = typeof(GhostTypeAttribute).GetConstructor(new Type[] { typeof(Type) });
		}
		// HACK because SetCustomAttribute(CustomAttributeBuilder) incorrectly always stores the assembly qualified name
		// we have our own version for when the type lives in the same assembly as the attribute. If we don't do this
		// ikvmc will have problems accessing this attribute when it uses Assembly.LoadFrom to load an assembly.
		if(fb.DeclaringType.Assembly.Equals(type.Assembly))
		{
			fb.SetCustomAttribute(ghostTypeAttribute, FreezeDryType(type));
		}
		else
		{
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ghostTypeAttribute, new object[] { type });
			fb.SetCustomAttribute(customAttributeBuilder);
		}
	}

d659 8
d696 1
a696 1
			return this != VerifierTypeWrapper.Null && !IsPrimitive && Type.IsValueType;
d949 9
a957 1
			if(IsUnloadable || IsGhost)
d975 1
a975 9
	internal Type TypeAsParameterType
	{
		get
		{
			return TypeAsFieldType;
		}
	}

	internal Type TypeAsBaseType
d1014 15
a1028 3
			// TODO if ghosts are ever compiled as value types (for fields), we need special treatment here,
			// otherwise array covariance breaks down
			return TypeAsFieldType;
d1371 1
a1371 1
			MethodInfo[] methods = Type.GetMethods();
d1548 1
d1593 8
d1651 8
d1680 1
d1700 1
d1752 4
d1761 15
a1775 1
					typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs);
d1794 2
a1795 1
				typeBuilder.AddInterfaceImplementation(interfaces[i].Type);
d1921 122
a2109 8
							if(mb is ConstructorBuilder)
							{
								AttributeHelper.SetModifiers((ConstructorBuilder)mb, m.Modifiers);
							}
							else
							{
								AttributeHelper.SetModifiers((MethodBuilder)mb, m.Modifiers);
							}
d2140 1
a2140 1
									ilGenerator.Emit(OpCodes.Ldarg, j + add);
d2194 13
d2234 1
a2234 1
				finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, reflectiveModifiers);
d2343 1
a2343 1
						ilGenerator.Emit(OpCodes.Ldarg, j + add);
d2353 1
a2353 1
						ilGenerator.Emit(OpCodes.Ldarg, j + add);
d2578 1
a2578 1
				if(typeWrapper.IsGhost)
d2580 1
a2580 1
					AttributeHelper.SetGhostType(field, typeWrapper);
d2642 1
a2642 1
				bool setModifiers = false;
a2698 12
					for(int i = 0; i < argTypeWrappers.Length; i++)
					{
						if(argTypeWrappers[i].IsGhost)
						{
							ParameterBuilder pb = (parameterBuilders != null) ? parameterBuilders[i] : null;
							if(pb == null)
							{
								pb = ((ConstructorBuilder)method).DefineParameter(i + 1, ParameterAttributes.None, null);
							}
							AttributeHelper.SetGhostType(typeBuilder, pb, argTypeWrappers[i]);
						}
					}
d2815 2
a2816 3
					MethodBuilder mb = typeBuilder.DefineMethod(name, attribs, retType, args);
					ParameterBuilder[] parameterBuilders = null;
					if(JVM.IsStaticCompiler)
d2818 1
a2818 1
						parameterBuilders = AddParameterNames(mb, m);
d2820 1
a2820 1
					for(int i = 0; i < argTypeWrappers.Length; i++)
d2822 1
a2822 9
						if(argTypeWrappers[i].IsGhost)
						{
							ParameterBuilder pb = (parameterBuilders != null) ? parameterBuilders[i] : null;
							if(pb == null)
							{
								pb = mb.DefineParameter(i + 1, ParameterAttributes.None, null);
							}
							AttributeHelper.SetGhostType(typeBuilder, pb, argTypeWrappers[i]);
						}
d2824 2
a2825 1
					if(retTypeWrapper.IsGhost)
d2827 1
a2827 3
						// HACK we're attaching the return type attribute to the method, because
						// of the DefineParameter(0, ...) .NET bug
						AttributeHelper.SetGhostType(mb, retTypeWrapper);
d2996 8
d3009 1
d3014 1
a3014 1
		public FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers)
d3017 1
d3067 8
d3562 1
a3562 1
							ilgen.Emit(OpCodes.Ldarg, n + 1);
d3577 1
a3577 1
							ilgen.Emit(OpCodes.Ldarg, n + 1);
d3650 1
a3650 1
						ilgen.Emit(OpCodes.Ldarg, n + 1);
d3674 1
a3674 1
						ilgen.Emit(OpCodes.Ldarg, n + 1);
d3741 1
a3741 1
							ilgen.Emit(OpCodes.Ldarg, i);
d3749 1
a3749 1
							ilgen.Emit(OpCodes.Ldarg, i);
d3792 2
d3814 1
a3814 1
		if(type.IsInterface)
d3919 1
a3919 1
				TypeWrapper[] wrappers = new TypeWrapper[nestedTypes.Length];
d3922 4
a3925 1
					wrappers[i] = ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]);
d3927 1
a3927 1
				innerclasses = wrappers;
d3959 31
d4000 1
a4000 1
			if(!AttributeHelper.IsHideFromReflection(fields[i]))
d4246 5
d4258 2
a4259 1
		if(name.StartsWith(NamePrefix))
d4262 5
a4266 2
			Type type = LoadTypeFromLoadedAssemblies(name);
			if(type != null)
d4270 5
a4274 1
			if(name.EndsWith(DelegateInterfaceSuffix))
d4276 19
a4294 12
				Type delegateType = LoadTypeFromLoadedAssemblies(name.Substring(0, name.Length - DelegateInterfaceSuffix.Length));
				if(delegateType.IsSubclassOf(typeof(Delegate)))
				{
					ModuleBuilder moduleBuilder = ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder;
					TypeBuilder typeBuilder = moduleBuilder.DefineType(NamePrefix + name, TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract);
					AttributeHelper.SetInnerClass(typeBuilder, NamePrefix + name, NamePrefix + delegateType.FullName, "Method", Modifiers.Public | Modifiers.Interface | Modifiers.Static | Modifiers.Abstract);
					MethodInfo invoke = delegateType.GetMethod("Invoke");
					if(invoke != null)
					{
						ParameterInfo[] parameters = invoke.GetParameters();
						Type[] args = new Type[parameters.Length];
						for(int i = 0; i < args.Length; i++)
d4296 1
a4296 12
							// HACK if the delegate has pointer args, we cannot handle them, but it is already
							// to late to refuse to load the class, so we replace pointers with IntPtr.
							// This is not a solution, because if the delegate would be instantiated the generated
							// code would be invalid.
							if(parameters[i].ParameterType.IsPointer)
							{
								args[i] = typeof(IntPtr);
							}
							else
							{
								args[i] = parameters[i].ParameterType;
							}
a4297 2
						typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Abstract | MethodAttributes.Virtual, CallingConventions.Standard, invoke.ReturnType, args);
						return new CompiledTypeWrapper(NamePrefix + name, typeBuilder.CreateType());
d4299 2
d4393 5
d4444 15
a4458 8
				TypeWrapper iface = GetClassLoader().LoadClassByDottedName(this.Name + DelegateInterfaceSuffix);
				Debug.Assert(iface is CompiledTypeWrapper);
				iface.Finish();
				MethodDescriptor md = MethodDescriptor.FromNameSig(GetClassLoader(), "<init>", "(" + iface.SigName + ")V");
				MethodWrapper method = new DelegateMethodWrapper(this, md);
				method.EmitNewobj = new DelegateConstructorEmitter(type.GetConstructor(new Type[] { typeof(object), typeof(IntPtr) }), iface.Type.GetMethod("Invoke"));
				AddMethod(method);
				innerClasses = new TypeWrapper[] { iface };
@


1.50
log
@*** empty log message ***
@
text
@d969 1
a969 2
	// TODO this should really be named TypeAsLocalArgOrStackType (or something like that)
	internal Type TypeOrUnloadableAsObject
d987 24
d1016 36
d1758 2
a1759 2
					// TODO in the CLR interfaces cannot contain nested types!
					typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs, wrapper.BaseTypeWrapper.Type);
d1763 1
a1763 1
					typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs, wrapper.BaseTypeWrapper.Type);
d2167 1
a2167 1
					modargs[i + 2] = args[i].TypeOrUnloadableAsObject;
d2221 1
a2221 1
					retValue = ilGenerator.DeclareLocal(retTypeWrapper.TypeOrUnloadableAsObject);
d2295 1
d2297 1
a2297 1
				Type type = typeWrapper.TypeOrUnloadableAsObject;
d2300 4
a2303 2
					// TODO the field name should be mangled here, because otherwise it might conflict with another field
					// with the same name and a different unloadable type (or java.lang.Object as its type)
d2340 1
a2340 1
					field = typeBuilder.DefineField(fld.Name, type, attribs);
d2366 1
a2366 1
					field = typeBuilder.DefineField(fld.Name, type, attribs);
d2484 1
a2484 1
				Type retType = retTypeWrapper.TypeOrUnloadableAsObject;
d2487 1
a2487 1
					args[i] = argTypeWrappers[i].TypeOrUnloadableAsObject;
d3060 1
a3060 1
							retcast = new CastEmitter(ret);
d3263 1
a3263 1
							retcast = new CastEmitter(ret);
d3341 1
a3341 1
						getter += new CastEmitter(fieldSig.Substring(1, fieldSig.Length - 2));
d3345 1
a3345 1
						getter += new CastEmitter(fieldSig);
d3817 9
a3825 1
				list.Add(CreateFieldWrapper(AttributeHelper.GetModifiers(fields[i]), fields[i].Name, fields[i].FieldType, fields[i], null));
@


1.49
log
@*** empty log message ***
@
text
@a222 7
		attribs = provider.GetCustomAttributes(typeof(UnloadableTypeAttribute), false);
		if(attribs.Length == 1)
		{
			name = "L" + ((UnloadableTypeAttribute)attribs[0]).Name + ";";
			// TODO it might be loadable now, what do we do?
			typeWrapper = new UnloadableTypeWrapper(((UnloadableTypeAttribute)attribs[0]).Name);
		}
d225 12
a236 2
			name = "Ljava.lang.Object;";
			typeWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Object");
@


1.48
log
@*** empty log message ***
@
text
@d801 17
@


1.47
log
@*** empty log message ***
@
text
@d4058 51
d4159 1
a4159 2
				// TODO set method flags
				MethodWrapper method = new MethodWrapper(this, md, null, null, Modifiers.Public, false);
d4211 6
d4246 1
a4246 1
			if(type.IsPointer)
d4391 1
d4397 5
d4412 6
a4417 1
		MethodWrapper method = new MethodWrapper(this, md, mb, null, mods, false);
@


1.46
log
@*** empty log message ***
@
text
@d50 1
a50 1
	private MethodDescriptor(ClassLoaderWrapper classLoader, string name, string sig, TypeWrapper[] args, TypeWrapper ret)
d181 5
d308 2
d358 1
d447 1
a447 1
		if(mb.IsFinal || (!mb.IsStatic && !mb.IsVirtual && !mb.IsConstructor))
d455 10
a468 4
		if((mb.GetMethodImplementationFlags() & MethodImplAttributes.Synchronized) != 0)
		{
			modifiers |= Modifiers.Synchronized;
		}
d614 9
d887 9
d1396 9
a1404 9
	internal static readonly PrimitiveTypeWrapper BYTE = new PrimitiveTypeWrapper(typeof(sbyte));
	internal static readonly PrimitiveTypeWrapper CHAR = new PrimitiveTypeWrapper(typeof(char));
	internal static readonly PrimitiveTypeWrapper DOUBLE = new PrimitiveTypeWrapper(typeof(double));
	internal static readonly PrimitiveTypeWrapper FLOAT = new PrimitiveTypeWrapper(typeof(float));
	internal static readonly PrimitiveTypeWrapper INT = new PrimitiveTypeWrapper(typeof(int));
	internal static readonly PrimitiveTypeWrapper LONG = new PrimitiveTypeWrapper(typeof(long));
	internal static readonly PrimitiveTypeWrapper SHORT = new PrimitiveTypeWrapper(typeof(short));
	internal static readonly PrimitiveTypeWrapper BOOLEAN = new PrimitiveTypeWrapper(typeof(bool));
	internal static readonly PrimitiveTypeWrapper VOID = new PrimitiveTypeWrapper(typeof(void));
d1407 1
d1409 1
a1409 1
	private PrimitiveTypeWrapper(Type type)
d1413 9
d1766 1
a1766 2
								Type[] argTypes = new Type[] { typeof(string), typeof(string), typeof(string), typeof(Modifiers) };
								object[] args = new object[] {
d1770 1
a1770 5
									reflectiveModifiers
								};
								ConstructorInfo ci = typeof(InnerClassAttribute).GetConstructor(argTypes);
								CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ci, args);
								typeBuilder.SetCustomAttribute(customAttributeBuilder);
d2267 1
a2267 1
					fields[i] = FieldWrapper.Create(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), fld.Name, fld.Signature, fld.Modifiers, emitGet, emitSet);
d2332 1
a2332 1
						fields[i] = FieldWrapper.Create(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), fld.Name, fld.Signature, fld.Modifiers, emitGet, emitSet);
d3272 1
a3272 1
				FieldWrapper fw = FieldWrapper.Create(this, GetClassLoader().RetTypeWrapperFromSig("()" + fieldSig), fieldName, fieldSig, modifiers, getter, setter);
d3555 2
a3556 1
class NetExpTypeWrapper : TypeWrapper
a3557 1
	private readonly ClassFile classFile;
d3559 2
d3562 1
a3562 19
	// TODO consider constructing modifiers from .NET type instead of the netexp class
	public NetExpTypeWrapper(ClassFile f, string dotnetType, TypeWrapper baseType)
		: base(f.Modifiers, f.Name, baseType, ClassLoaderWrapper.GetBootstrapClassLoader())
	{
		this.classFile = f;
		// TODO if the type isn't found, it should be handled differently
		type = Type.GetType(dotnetType, true);
	}

	public override TypeWrapper[] Interfaces
	{
		get
		{
			// TODO resolve the interfaces!
			return TypeWrapper.EmptyArray;
		}
	}

	public override TypeWrapper[] InnerClasses
d3564 2
a3565 1
		get
d3567 1
a3567 2
			// TODO resolve the inner classes!
			return TypeWrapper.EmptyArray;
d3569 3
a3571 145
	}

	public override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			// TODO resolve the outer class!
			return null;
		}
	}

	protected override FieldWrapper GetFieldImpl(string fieldName)
	{
		// HACK this is a totally broken quick & dirty implementation
		// TODO clean this up, add error checking and whatnot
		FieldInfo field = type.GetField(fieldName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
		if(!AttributeHelper.IsHideFromReflection(field))
		{
			return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(field.FieldType), field, MethodDescriptor.GetFieldSigName(field), AttributeHelper.GetModifiers(field));
		}
		return null;
	}

	private class DelegateConstructorEmitter : CodeEmitter
	{
		private ConstructorInfo delegateConstructor;
		private MethodInfo method;

		internal DelegateConstructorEmitter(ConstructorInfo delegateConstructor, MethodInfo method)
		{
			this.delegateConstructor = delegateConstructor;
			this.method = method;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Ldvirtftn, method);
			ilgen.Emit(OpCodes.Newobj, delegateConstructor);
		}
	}

	private class RefArgConverter : CodeEmitter
	{
		private Type[] args;

		internal RefArgConverter(Type[] args)
		{
			this.args = args;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			LocalBuilder[] locals = new LocalBuilder[args.Length];
			for(int i = args.Length - 1; i >= 0; i--)
			{
				Type type = args[i];
				if(type.IsByRef)
				{
					type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
				}
				locals[i] = ilgen.DeclareLocal(type);
				ilgen.Emit(OpCodes.Stloc, locals[i]);
			}
			for(int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldloc, locals[i]);
				if(args[i].IsByRef)
				{
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ldelema, args[i].GetElementType());
				}
			}
		}
	}

	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		// special case for delegate constructors!
		if(md.Name == "<init>" && type.IsSubclassOf(typeof(MulticastDelegate)))
		{
			// TODO set method flags
			MethodWrapper method = new MethodWrapper(this, md, null, null, Modifiers.Public, false);
			// TODO what class loader should we use?
			TypeWrapper iface = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(classFile.Name + "$Method");
			iface.Finish();
			method.EmitNewobj = new DelegateConstructorEmitter(type.GetConstructor(new Type[] { typeof(object), typeof(IntPtr) }), iface.Type.GetMethod("Invoke"));
			return method;
		}
		// HACK this is a totally broken quick & dirty implementation
		// TODO clean this up, add error checking and whatnot
		ClassFile.Method[] methods = classFile.Methods;
		for(int i = 0; i < methods.Length; i++)
		{
			if(methods[i].Name == md.Name && methods[i].Signature == md.Signature)
			{
				bool hasByRefArgs = false;
				Type[] args;
				string[] sig = methods[i].NetExpSigAttribute;
				if(sig == null)
				{
					args = md.ArgTypes;
				}
				else
				{
					args = new Type[sig.Length];
					for(int j = 0; j < sig.Length; j++)
					{
						args[j] = Type.GetType(sig[j], true);
						if(args[j].IsByRef)
						{
							hasByRefArgs = true;
						}
					}
				}
				MethodBase method;
				if(md.Name == "<init>")
				{
					method = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, CallingConventions.Standard, args, null);
				}
				else
				{
					method = type.GetMethod(md.Name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance, null, CallingConventions.Standard, args, null);
				}
				if(method != null)
				{
					// TODO we can decode the actual method attributes, or we can use them from the NetExp class, what is
					// preferred?
					MethodWrapper mw = MethodWrapper.Create(this, md, method, method, AttributeHelper.GetModifiers(method), AttributeHelper.IsHideFromReflection(method));
					if(hasByRefArgs)
					{
						mw.EmitCall = new RefArgConverter(args) + mw.EmitCall;
						mw.EmitCallvirt = new RefArgConverter(args) + mw.EmitCallvirt;
						mw.EmitNewobj = new RefArgConverter(args) + mw.EmitNewobj;
					}
					return mw;
				}
			}
		}
		return null;
	}

	public override Type Type
	{
		get
d3573 1
a3573 1
			return type;
d3575 1
a3577 11
	public override void Finish()
	{
	}
}

class CompiledTypeWrapper : TypeWrapper
{
	private readonly Type type;
	private TypeWrapper[] interfaces;
	private TypeWrapper[] innerclasses;

d3579 1
a3579 1
	private static TypeWrapper GetBaseTypeWrapper(Type type)
d3599 1
d3602 2
d3607 1
a3607 1
	private static Modifiers GetModifiers(Type type)
d3797 1
a3797 1
		return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(fieldType), name, MethodDescriptor.GetFieldSigName(field), modifiers, emitGet, emitSet);
d3946 549
d4523 9
@


1.45
log
@*** empty log message ***
@
text
@d41 1
a41 1
		: this(classLoader, cpi.Name, cpi.Signature)
a42 2
		argTypeWrappers = cpi.GetArgTypes(classLoader);
		retTypeWrapper = cpi.GetRetType(classLoader);
d46 1
a46 1
		: this(classLoader, method.Name, method.Signature)
a47 2
		argTypeWrappers = method.GetArgTypes(classLoader);
		retTypeWrapper = method.GetRetType(classLoader);
d50 1
a50 1
	internal MethodDescriptor(ClassLoaderWrapper classLoader, string name, string sig)
d59 2
d172 1
a172 1
	internal static string GetSigName(ParameterInfo param)
d177 20
a196 1
			return GetSigNameFromCustomAttribute(param);
a197 1
		return GetSigNameFromType(type);
d200 1
a200 1
	internal static string GetSigName(FieldInfo field)
d210 1
a210 1
	internal static string GetSigName(MethodInfo method)
d212 14
a225 2
		Type type = method.ReturnType;
		if(type == typeof(object))
d227 2
a228 1
			return GetSigNameFromCustomAttribute(method);
a229 1
		return GetSigNameFromType(type);
d307 7
a313 3
		foreach(ParameterInfo param in mb.GetParameters())
		{
			sb.Append(GetSigName(param));
d319 1
a319 1
			return new MethodDescriptor(ClassLoaderWrapper.GetClassLoader(mb.DeclaringType), mb.IsStatic ? "<clinit>" : "<init>", sb.ToString());
d323 5
a327 2
			sb.Append(GetSigName((MethodInfo)mb));
			return new MethodDescriptor(ClassLoaderWrapper.GetClassLoader(mb.DeclaringType), mb.Name, sb.ToString());
d330 6
d344 1
a344 1
		MethodDescriptor md = new MethodDescriptor(exception.GetClassLoader(), "<init>", "(Ljava.lang.String;)V");
d1815 1
a1815 1
						if(basehasclinit && classFile.Methods[i].Name == "<clinit>" && classFile.Methods[i].Signature == "()V" && !classFile.IsInterface)
d1974 23
a1996 9
				string message = String.Format("****** Exception during finishing of {0} ******", wrapper.Name);
				message += "\r\n" + x;
				message += "\r\n" + new StackTrace(x);
				message += "\r\n" + new StackTrace(true);
				System.Windows.Forms.MessageBox.Show(message, "IKVM.NET Internal Error");
//				Console.WriteLine("****** Exception during finishing of {0} ******", wrapper.Name);
//				Console.WriteLine(x);
//				Console.WriteLine(new StackTrace(x));
//				Console.WriteLine(new StackTrace(true));
d2440 1
a2440 1
				else if(m.Name == "<clinit>" && m.Signature == "()V")
d2841 1
a2841 1
				MethodDescriptor md = new MethodDescriptor(GetClassLoader(), name, sig);
d2897 1
a2897 1
						MethodDescriptor redir = new MethodDescriptor(GetClassLoader(), name, sig);
d3046 1
a3046 1
				MethodDescriptor md = new MethodDescriptor(GetClassLoader(), "<init>", constructor.Sig);
d3076 1
a3076 1
						MethodDescriptor redir = new MethodDescriptor(GetClassLoader(), "<init>", sig);
d3098 1
a3098 1
								MethodDescriptor md1 = new MethodDescriptor(GetClassLoader(), constructor.redirect.Name != null ? constructor.redirect.Name : "<init>", sig);
d3196 1
a3196 1
				MethodDescriptor redir = new MethodDescriptor(GetClassLoader(), name, sig);
d3566 1
a3566 1
			return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(field.FieldType), field, MethodDescriptor.GetSigName(field), AttributeHelper.GetModifiers(field));
d3710 19
a3728 2
	internal CompiledTypeWrapper(string name, Type type, TypeWrapper baseType)
		: base(GetModifiers(type), name, baseType, ClassLoaderWrapper.GetBootstrapClassLoader())
d3925 1
a3925 1
		return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(fieldType), name, MethodDescriptor.GetSigName(field), modifiers, emitGet, emitSet);
d4088 1
a4088 1
			mdClone = new MethodDescriptor(ClassLoaderWrapper.GetBootstrapClassLoader(), "clone", "()Ljava.lang.Object;");
@


1.44
log
@*** empty log message ***
@
text
@d81 8
d90 1
a90 1
	internal Type[] ArgTypes
d108 10
d131 10
d145 1
a145 1
			return RetTypeWrapper.Type;
d356 1
a356 1
	internal static void ImplementsAttribute(TypeBuilder typeBuilder, Type iface)
d358 1
d491 1
a491 1
	internal static void SetGhostType(TypeBuilder ownerType, ParameterBuilder pb, Type type)
d493 1
d512 1
a512 1
	internal static void SetGhostType(MethodBuilder mb, Type type)
d514 1
d533 1
a533 1
	internal static void SetGhostType(FieldBuilder fb, Type type)
d535 1
d615 9
d866 10
d885 10
d979 3
d1087 1
a1087 1
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetType, md.ArgTypes);
d1095 1
a1095 1
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetType, md.ArgTypes);
d1099 1
a1099 1
				int argc = md.ArgTypes.Length;
d1118 1
a1118 1
				MethodBuilder mb = typeBuilder.DefineMethod(md.Name, MethodAttributes.Public | MethodAttributes.Virtual, md.RetType, md.ArgTypes);
d1122 1
a1122 1
				int argc = md.ArgTypes.Length;
d1137 1
a1137 1
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetType, md.ArgTypes);
d1182 1
a1182 1
				MethodBuilder mb = typeBuilder.DefineMethod(md.Name, MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract, md.RetType, md.ArgTypes);
d1559 1
a1559 1
						outer = (TypeBuilder)outerClassWrapper.Type;
d1608 1
a1608 1
				AttributeHelper.ImplementsAttribute(typeBuilder, interfaces[i].Type);
d1757 1
a1757 1
								MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & ~(MethodAttributes.Abstract|MethodAttributes.NewSlot), CallingConventions.Standard, md.RetType, md.ArgTypes);
d1929 13
a1941 4
				Console.WriteLine("****** Exception during finishing of {0} ******", wrapper.Name);
				Console.WriteLine(x);
				Console.WriteLine(new StackTrace(x));
				Console.WriteLine(new StackTrace(true));
d1985 1
a1985 2
				Type retType = retTypeWrapper.Type;
				if(!retType.IsValueType && retType != typeof(void))
d1996 1
a1996 1
					modargs[i + 2] = args[i].Type;
d2033 1
a2033 1
				ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, (retTypeWrapper.IsPrimitive) ? retType : typeof(IntPtr), modargs);
d2035 1
a2035 1
				if(retType != typeof(void))
d2037 1
a2037 1
					if(!retTypeWrapper.IsPrimitive)
d2042 2
a2043 2
							ilGenerator.Emit(OpCodes.Unbox, retType);
							ilGenerator.Emit(OpCodes.Ldobj, retType);
d2047 1
a2047 1
							ilGenerator.Emit(OpCodes.Castclass, retType);
d2050 1
a2050 1
					retValue = ilGenerator.DeclareLocal(retType);
d2061 1
a2061 1
				if(retType != typeof(void))
d2253 1
a2253 1
					AttributeHelper.SetGhostType(field, typeWrapper.Type);
d2381 1
a2381 1
							AttributeHelper.SetGhostType(typeBuilder, pb, argTypeWrappers[i].Type);
d2515 1
a2515 1
							AttributeHelper.SetGhostType(typeBuilder, pb, argTypeWrappers[i].Type);
d2520 3
a2522 1
						AttributeHelper.SetGhostType(mb, retTypeWrapper.Type);
d3233 1
a3233 1
						MethodBuilder mb = stub.DefineMethod(md.Name, mw.GetMethodAttributes(), CallingConventions.Standard, md.RetType, md.ArgTypes);
d3236 1
a3236 1
						int argc = md.ArgTypes.Length;
d3251 1
a3251 1
						int argc = md.ArgTypes.Length;
d3321 1
a3321 1
					MethodBuilder mb = typeBuilder.DefineMethod(md.Name, mce.GetMethodAttributes(), CallingConventions.Standard, md.RetType, md.ArgTypes);
d3324 1
a3324 1
					int argc = md.ArgTypes.Length;
d3345 1
a3345 1
					MethodBuilder mb = typeBuilder.DefineMethod(md.Name, MethodAttributes.Virtual | MethodAttributes.Public, CallingConventions.Standard, md.RetType, md.ArgTypes);
d3348 1
a3348 1
					int argc = md.ArgTypes.Length;
d3404 3
a3406 3
						MethodBuilder ifmethod = typeBuilder.DefineMethod(md.Name, MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract, md.RetType, md.ArgTypes);
						Type[] args = new Type[md.ArgTypes.Length + 1];
						md.ArgTypes.CopyTo(args, 1);
d3408 1
a3408 1
						MethodBuilder mb = tbStaticHack.DefineMethod(md.Name, MethodAttributes.Public | MethodAttributes.Static, md.RetType, args);
d3962 1
a3962 1
		for(int i = 0; i < md.ArgTypeWrappers.Length; i++)
@


1.43
log
@*** empty log message ***
@
text
@a2294 4
					if(JVM.IsStaticCompiler)
					{
						AddParameterNames(method, m);
					}
d2555 1
a2555 1
								if(localVars[j].index == i)
@


1.42
log
@*** empty log message ***
@
text
@d334 11
a344 1
		typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(implementsAttribute, new object[] { iface }));
@


1.41
log
@*** empty log message ***
@
text
@d442 11
a452 1
	internal static void SetGhostType(ParameterBuilder pb, Type type)
d458 12
a469 2
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ghostTypeAttribute, new object[] { type });
		pb.SetCustomAttribute(customAttributeBuilder);
d478 12
a489 2
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ghostTypeAttribute, new object[] { type });
		mb.SetCustomAttribute(customAttributeBuilder);
d498 12
a509 2
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ghostTypeAttribute, new object[] { type });
		fb.SetCustomAttribute(customAttributeBuilder);
d1901 2
a1902 1
				Type retType = m.GetRetType(wrapper.GetClassLoader()).Type;
d1934 1
a1934 1
					if(!args[j].Type.IsValueType)
d1938 4
d1951 1
a1951 2
				Type returnType =(retType.IsValueType || retType == typeof(void)) ? retType : typeof(IntPtr);
				ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, returnType, modargs);
d1955 1
a1955 1
					if(!retType.IsValueType)
d1958 9
a1966 1
						ilGenerator.Emit(OpCodes.Castclass, retType);
d2303 1
a2303 1
							AttributeHelper.SetGhostType(pb, argTypeWrappers[i].Type);
d2437 1
a2437 1
							AttributeHelper.SetGhostType(pb, argTypeWrappers[i].Type);
@


1.40
log
@*** empty log message ***
@
text
@d146 46
a191 1
	internal static string GetSigName(Type type)
d253 1
a253 1
			sb.Append(GetSigName(param.ParameterType));
d263 1
a263 1
			sb.Append(GetSigName(((MethodInfo)mb).ReturnType));
d291 1
d441 36
d522 11
d775 1
d780 1
a780 1
			if(IsUnloadable)
d1733 1
a1733 1
								if(!retTypeWrapper.Type.Equals(nativeMethod.ReturnType))
d1991 1
a1991 1
				Type type;
a1995 5
					type = typeof(object);
				}
				else
				{
					type = typeWrapper.Type;
d2115 5
a2119 2
					CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { typeWrapper.Name });
					field.SetCustomAttribute(attrib);
d2237 17
d2259 1
a2259 1
					// HACK because Peverify (in Whidbey) is complaining about private methods in interfaces, I'm making them public for the time being
d2371 1
d2374 17
a2390 1
						AddParameterNames(mb, m);
d2478 1
a2478 1
		private static void AddParameterNames(MethodBase mb, ClassFile.Method m)
d2490 1
d2501 1
a2501 1
										((MethodBuilder)mb).DefineParameter(m.CodeAttribute.ArgMap[i] + 1 - bias, ParameterAttributes.None, localVars[j].name);
d2505 1
a2505 1
										((ConstructorBuilder)mb).DefineParameter(m.CodeAttribute.ArgMap[i], ParameterAttributes.None, localVars[j].name);
d2512 1
d2515 1
d3379 1
a3379 1
			return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(field.FieldType), field, MethodDescriptor.GetSigName(field.FieldType), AttributeHelper.GetModifiers(field));
d3721 1
a3721 1
		return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(fieldType), name, MethodDescriptor.GetSigName(fieldType), modifiers, emitGet, emitSet);
d3802 1
a3802 1
		if(mb is ConstructorInfo)
d3804 1
a3804 2
			method.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)mb);
			method.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)mb);
d3808 1
a3808 2
			method.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
			if(!mb.IsStatic)
d3810 10
a3819 1
				method.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)mb);
@


1.39
log
@*** empty log message ***
@
text
@d245 1
d282 9
d313 1
a313 1
		if(mb.IsFinal || (!mb.IsStatic && !mb.IsVirtual))
d1400 1
d3457 5
a3461 6
				// TODO instead of getting the interfaces list from Type, we should use a custom
				// attribute to list the implemented interfaces (alternatively, we could check the assembly
				// of each interface to make sure it is from an IKVM compiled assembly, but even if the
				// interfaces doesn't come from an IKVM assembly we still must call GetWrapperFromTypeFast
				// to handle remapped interfaces.
				Type[] ifaces = type.GetInterfaces();
d3463 1
a3463 1
				for(int i = 0; i < ifaces.Length; i++)
d3465 2
a3466 10
					// HACK if the interface wrapper isn't found, we'll just ignore it (this happens for
					// example for Throwable derived classes, which seem to implement ISerializable [because System.Exception does],
					// but we cannot find a wrapper for this type)
					try
					{
						wrappers.Add(ClassLoaderWrapper.GetWrapperFromType(ifaces[i]));
					}
					catch(Exception)
					{
					}
@


1.38
log
@*** empty log message ***
@
text
@d2130 4
d2251 4
d2338 37
@


1.37
log
@*** empty log message ***
@
text
@a1933 1
					fields[i] = FieldWrapper.Create(wrapper, field, fld);
d1937 1
a1937 1
					fields[i].EmitGet = CodeEmitter.CreateLoadConstant(constantValue);
d1940 2
a1941 1
					fields[i].EmitSet = CodeEmitter.Pop;
d1992 15
a2006 2
						fields[i] = FieldWrapper.Create(wrapper, field, fld);
						fields[i].EmitGet = CodeEmitter.Create(OpCodes.Call, getter);
d2010 1
a2010 1
						fields[i] = FieldWrapper.Create(wrapper, field, fld);
d2844 1
a2844 3
				FieldWrapper fw = new FieldWrapper(this, null, fieldName, fieldSig, modifiers);
				fw.EmitGet = CodeEmitter.Create(OpCodes.Call, method);
				fw.EmitSet = null;
d2850 9
a2858 1
						fieldSig = fieldSig.Substring(1, fieldSig.Length - 2);
a2859 1
					fw.EmitGet += new CastEmitter(fieldSig);
d2861 3
d3194 1
a3194 1
			return FieldWrapper.Create(this, field, MethodDescriptor.GetSigName(field.FieldType), AttributeHelper.GetModifiers(field));
d3491 2
a3492 1
		FieldWrapper fieldWrapper = new FieldWrapper(this, ClassLoaderWrapper.GetWrapperFromType(fieldType), name, MethodDescriptor.GetSigName(fieldType), modifiers);
d3497 1
a3497 1
				fieldWrapper.EmitGet = CodeEmitter.Create(OpCodes.Call, getter);
d3504 1
a3504 1
					fieldWrapper.EmitGet = CodeEmitter.CreateLoadConstant(field.GetValue(null));
d3508 1
a3508 1
					fieldWrapper.EmitGet = CodeEmitter.Create(OpCodes.Ldsfld, field);
d3513 1
a3513 1
				fieldWrapper.EmitSet = CodeEmitter.Create(OpCodes.Stsfld, field);
d3520 1
a3520 1
				fieldWrapper.EmitSet = CodeEmitter.Nop;
d3527 1
a3527 1
				fieldWrapper.EmitGet = CodeEmitter.Create(OpCodes.Callvirt, getter);
d3532 1
a3532 1
				fieldWrapper.EmitGet = CodeEmitter.Create(OpCodes.Ldfld, field);
d3536 1
a3536 1
				fieldWrapper.EmitSet = CodeEmitter.Create(OpCodes.Stfld, field);
d3542 1
a3542 1
				fieldWrapper.EmitSet = CodeEmitter.Nop;
d3545 1
a3545 1
		return fieldWrapper;
@


1.36
log
@*** empty log message ***
@
text
@d1938 1
a1938 24
					if(constantValue is int || constantValue is short || constantValue is sbyte || constantValue is char || constantValue is bool)
					{
						fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldc_I4, ((IConvertible)constantValue).ToInt32(null));
					}
					else if(constantValue is string)
					{
						fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldstr, (string)constantValue);
					}
					else if(constantValue is float)
					{
						fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldc_R4, (float)constantValue);
					}
					else if(constantValue is double)
					{
						fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldc_R8, (double)constantValue);
					}
					else if(constantValue is long)
					{
						fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldc_I8, (long)constantValue);
					}
					else
					{
						throw new NotImplementedException(constantValue.GetType().FullName);
					}
d2122 3
a2124 1
					method = typeBuilder.DefineTypeInitializer();
d3479 9
a3487 2
				// TODO if field is a literal, we should emit an ldc instead of a ldsfld
				fieldWrapper.EmitGet = CodeEmitter.Create(OpCodes.Ldsfld, field);
d3489 1
a3489 1
			if(field != null)
@


1.35
log
@*** empty log message ***
@
text
@d56 4
a59 4
		if(classLoader == null)
		{
			throw new ArgumentNullException();
		}
a62 2
		// class name in the sig should be dotted
		Debug.Assert(sig.IndexOf('/') < 0);
d146 1
a146 1
	internal static string getSigName(Type type)
d208 1
a208 1
			sb.Append(getSigName(param.ParameterType));
d218 1
a218 1
			sb.Append(getSigName(((MethodInfo)mb).ReturnType));
d434 1
a434 1
			return name[0] == '[';
d444 1
a444 1
			while(name[i] == '[')
d446 4
a449 1
				i++;
d658 1
a658 1
			if(index1 == -1 || index2 == -1)
d662 1
a662 3
			string package1 = name.Substring(0, index1);
			string package2 = wrapper.name.Substring(0, index2);
			return package1 == package2;
d2083 1
a2083 9
				Type retType;
				if(retTypeWrapper.IsUnloadable)
				{
					retType = typeof(object);
				}
				else
				{
					retType = retTypeWrapper.Type;
				}
d2086 1
a2086 8
					if(argTypeWrappers[i].IsUnloadable)
					{
						args[i] = typeof(object);
					}
					else
					{
						args[i] = argTypeWrappers[i].Type;
					}
a2142 7
					// I think this is a CLR bug, the verifier requires static inititializes of interfaces to be public
					// TODO report this bug
					if(classFile.IsInterface)
					{
						attribs &= ~MethodAttributes.MemberAccessMask;
						attribs |= MethodAttributes.Public;
					}
d2145 1
a2145 1
					method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, args);
d2173 1
a2173 1
							// here are the complex rules for determining wether this method overrides the method we found
d3194 1
a3194 1
			return FieldWrapper.Create(this, field, MethodDescriptor.getSigName(field.FieldType), AttributeHelper.GetModifiers(field));
d3491 1
a3491 1
		FieldWrapper fieldWrapper = new FieldWrapper(this, ClassLoaderWrapper.GetWrapperFromType(fieldType), name, MethodDescriptor.getSigName(fieldType), modifiers);
@


1.34
log
@*** empty log message ***
@
text
@d2255 7
a2261 1
							attribs |= MethodAttributes.NewSlot;
d2362 12
@


1.33
log
@*** empty log message ***
@
text
@d458 1
a458 1
			return !IsPrimitive && Type.IsValueType;
d702 4
d708 1
a708 1
				throw new InvalidOperationException();
@


1.32
log
@*** empty log message ***
@
text
@a36 1
	private Type ret;
d83 1
d90 7
a96 1
				args = classLoader.ArgTypeListFromSig(sig);
d114 1
d119 1
a119 5
			if(ret == null)
			{
				ret = classLoader.RetTypeFromSig(sig);
			}
			return ret;
d850 8
d967 6
d1179 1
a1179 1
		: base(f.Modifiers, f.Name, f.GetSuperTypeWrapper(classLoader), classLoader)
d1182 1
a1182 1
		if(BaseTypeWrapper.IsUnloadable)
d1184 16
a1199 13
			throw JavaException.NoClassDefFoundError(BaseTypeWrapper.Name);
		}
		if(!BaseTypeWrapper.IsAccessibleFrom(this))
		{
			throw JavaException.IllegalAccessError("Class {0} cannot access its superclass {1}", f.Name, BaseTypeWrapper.Name);
		}
		if(BaseTypeWrapper.IsFinal)
		{
			throw JavaException.VerifyError("Cannot inherit from final class");
		}
		if(BaseTypeWrapper.IsInterface)
		{
			throw JavaException.IncompatibleClassChangeError("Class {0} has interface {1} as superclass", f.Name, BaseTypeWrapper.Name);
d1367 1
a1367 1
					typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(f.Name, typeAttribs);
d1380 1
a1380 1
					typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(f.Name, typeAttribs, wrapper.BaseTypeWrapper.Type);
d1522 3
a1524 1
					while(parent.IsAbstract)
d1543 1
a1543 1
				bool basehasclinit = wrapper.BaseTypeWrapper.Type.TypeInitializer != null;
d1610 1
a1610 1
							Type[] args = wrapper.GetClassLoader().ArgTypeListFromSig(m.Signature);
d1624 2
a1625 2
								Type retType = wrapper.GetClassLoader().RetTypeFromSig(m.Signature);
								if(!retType.Equals(nativeMethod.ReturnType))
d1627 1
a1627 1
									ilGenerator.Emit(OpCodes.Castclass, retType);
d1709 2
d1733 1
a1733 1
			internal static void Generate(ILGenerator ilGenerator, TypeWrapper wrapper, TypeBuilder typeBuilder, ClassFile.Method m, Type[] args)
d1753 1
a1753 1
				Type retType = wrapper.GetClassLoader().RetTypeFromSig(m.Signature);
d1763 4
a1766 1
				args.CopyTo(modargs, 2);
d1785 1
a1785 1
					if(!args[j].IsValueType)
d1931 1
a1931 1
					fields[i] = FieldWrapper.Create(wrapper, field, fld.Signature, fld.Modifiers);
d2012 1
a2012 1
						fields[i] = FieldWrapper.Create(wrapper, field, fld.Signature, fld.Modifiers);
d2017 1
a2017 1
						fields[i] = FieldWrapper.Create(wrapper, field, fld.Signature, fld.Modifiers);
d2574 5
a2578 1
							retcast = new CastEmitter(md.Signature);
d2777 5
a2781 1
							retcast = new CastEmitter(md.Signature);
d2853 1
a2853 1
				FieldWrapper fw = new FieldWrapper(this, fieldName, fieldSig, modifiers);
d2859 5
a2863 1
					fw.EmitGet += new CastEmitter("()" + fieldSig);
d3492 1
a3492 1
		FieldWrapper fieldWrapper = new FieldWrapper(this, name, MethodDescriptor.getSigName(fieldType), modifiers);
d3640 1
a3640 1
		for(int i = 0; i < md.ArgTypes.Length; i++)
d3642 1
a3642 1
			if(md.ArgTypes[i] is TypeBuilder)
d3783 1
a3783 1
				type = elementType.Assembly.GetType(elementType.FullName + "[]");
@


1.31
log
@*** empty log message ***
@
text
@d1309 3
a1311 2
			// only if we're statically compiling, we compile inner classes as nested types
			if(JVM.IsStaticCompiler)
d1391 14
d1685 1
a1685 1
				Console.WriteLine("****** Exception during finishing ******");
@


1.30
log
@*** empty log message ***
@
text
@d29 1
d64 2
a65 2
		// class name in the sig should be slashed instead of dotted
		Debug.Assert(sig.IndexOf('.') < 0);
d187 1
a187 1
				return "L" + type.FullName.Replace('.', '/') + ";";
d192 1
a192 1
			string s = NativeCode.java.lang.VMClass.getName(type).Replace('.', '/');
d229 1
a229 1
		MethodDescriptor md = new MethodDescriptor(exception.GetClassLoader(), "<init>", "(Ljava/lang/String;)V");
d233 151
d389 6
a394 6
	private ClassLoaderWrapper classLoader;
	private string name;		// java name (e.g. java/lang/Object)
	private Modifiers modifiers;
	protected Hashtable methods = new Hashtable();
	private Hashtable fields = new Hashtable();
	private TypeWrapper baseWrapper;
d396 3
d402 4
d459 1
a459 1
	internal virtual bool IsPrimitive
d463 1
a463 1
			return false;
d472 1
a472 1
			return modifiers == Modifiers.Synthetic;
d481 1
a481 1
			return modifiers == (Modifiers.Final | Modifiers.Interface);
d485 2
d495 11
d530 9
d607 1
a607 4
		if(method == null)
		{
			throw new ArgumentNullException();
		}
d613 1
a613 4
		if(field == null)
		{
			throw new ArgumentNullException();
		}
d629 1
a629 1
			int index = name.LastIndexOf('/');
d648 2
a649 2
			int index1 = name.LastIndexOf('/');
			int index2 = wrapper.name.LastIndexOf('/');
d707 1
a707 1
					return classLoader.LoadClassBySlashedName(name.Substring(1));
d709 1
a709 1
					return classLoader.LoadClassBySlashedName(name.Substring(2, name.Length - 3));
d770 1
a770 1
			java_lang_Object = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/Object");
a822 5
	public abstract bool IsInterface
	{
		get;
	}

d828 1
d834 1
d842 1
a842 1
	private void ImplementInterfaceMethodStubImpl(MethodDescriptor md, MethodBase ifmethod, TypeBuilder typeBuilder, TypeWrapper wrapper)
a845 1
		CustomAttributeBuilder methodFlags = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { Modifiers.Synthetic });
d856 1
a856 1
				mb.SetCustomAttribute(methodFlags);
d864 1
a864 1
				mb.SetCustomAttribute(methodFlags);
d887 1
a887 1
				mb.SetCustomAttribute(methodFlags);
d906 1
a906 1
				mb.SetCustomAttribute(methodFlags);
d951 1
a951 1
				mb.SetCustomAttribute(methodFlags);
d955 1
a955 1
				wrapper.AddMethod(MethodWrapper.Create(wrapper, md, mb, mb, Modifiers.Synthetic | Modifiers.Public | Modifiers.Abstract));
d960 1
a960 1
	internal void ImplementInterfaceMethodStubs(TypeBuilder typeBuilder, TypeWrapper wrapper, Hashtable doneSet)
d1010 1
a1010 1
	internal virtual void ImplementOverrideStubsAndVirtuals(TypeBuilder typeBuilder, TypeWrapper wrapper, Hashtable methodLookup)
d1031 1
a1031 1
		: base(Modifiers.Synthetic, name, null, null)
a1052 8
	public override bool IsInterface
	{
		get
		{
			throw new InvalidOperationException("get_IsInterface called on UnloadableTypeWrapper: " + Name);
		}
	}

d1095 1
a1095 1
	private Type type;
a1107 8
	internal override bool IsPrimitive
	{
		get
		{
			return true;
		}
	}

a1125 8
	public override bool IsInterface
	{
		get
		{
			return false;
		}
	}

d1131 1
a1131 1
			return new TypeWrapper[0];
d1139 1
a1139 1
			return new TypeWrapper[0];
d1164 1
d1169 1
a1169 2
		// if the base type isn't public, it must be in the same package
		if(!BaseTypeWrapper.IsPublic)
d1171 1
a1171 4
			if(BaseTypeWrapper.GetClassLoader() != classLoader || f.PackageName != BaseTypeWrapper.PackageName)
			{
				throw JavaException.IllegalAccessError("Class {0} cannot access its superclass {1}", f.Name, BaseTypeWrapper.Name);
			}
d1198 9
a1206 1
		impl = new JavaTypeImpl(f, this, BaseTypeWrapper, interfaces, nativeMethods);
a1218 8
	public override bool IsInterface
	{
		get
		{
			return impl.IsInterface;
		}
	}

d1255 9
a1263 1
			impl = impl.Finish();
a1271 1
		public abstract bool IsInterface { get; }
d1274 1
d1280 3
a1282 5
		private ClassFile classFile;
		private DynamicTypeWrapper wrapper;
		private TypeWrapper baseWrapper;
		private TypeBuilder typeBuilder;
		private TypeWrapper[] interfaces;
d1289 2
a1290 2
		private Hashtable nativeMethods;
		private TypeWrapper outerClassWrapper;
d1292 1
a1292 1
		internal JavaTypeImpl(ClassFile f, DynamicTypeWrapper wrapper, TypeWrapper baseWrapper, TypeWrapper[] interfaces, Hashtable nativeMethods)
a1296 2
			this.baseWrapper = baseWrapper;
			this.interfaces = interfaces;
d1309 1
a1309 1
			// if we're statically compiling, we compiler inner classes as nested types
d1314 1
a1314 1
					outerClassWrapper = wrapper.GetClassLoader().LoadClassBySlashedName(f.OuterClass.Name);
d1342 1
a1342 1
					typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name).Replace('/', '.'), typeAttribs);
d1346 1
a1346 1
					typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(f.Name.Replace('/', '.'), typeAttribs);
d1355 1
a1355 1
					typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name).Replace('/', '.'), typeAttribs, baseWrapper.Type);
d1359 1
a1359 1
					typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(f.Name.Replace('/', '.'), typeAttribs, baseWrapper.Type);
d1362 1
a1366 4
			if(outer != null)
			{
				typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(typeof(ClassNameAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { f.Name }));
			}
d1380 1
a1380 1
			if(baseWrapper != null)
d1384 1
a1384 1
				baseWrapper.Finish();
d1400 1
d1403 1
a1403 4
				if(finishing)
				{
					throw new InvalidOperationException("Finishing already in progress, for type " + classFile.Name);
				}
d1405 4
a1408 1
				// if we're an inner class, we need to attach a ModifiersAttribute to the type, with the reflected modifiers
d1410 1
a1410 1
				for(int i = 0; i < innerclasses.Length; i++)
d1412 3
a1414 1
					if(innerclasses[i].innerClass != 0)
d1416 1
a1416 1
						if(classFile.GetConstantPoolClassType(innerclasses[i].innerClass, wrapper.GetClassLoader()) == wrapper)
d1418 19
a1436 2
							ModifiersAttribute.SetModifiers(typeBuilder, innerclasses[i].accessFlags);
							break;
d1439 1
a1480 1
				wrapper.BaseTypeWrapper.Finish();
d1499 1
a1499 1
								ModifiersAttribute.SetModifiers(mb, methods[i].Modifiers);
d1506 1
a1506 1
				bool basehasclinit = wrapper.BaseTypeWrapper.Type.GetConstructor(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public, null, CallingConventions.Any, Type.EmptyTypes, null) != null;
d1518 1
a1518 2
							ilGenerator.Emit(OpCodes.Ldtoken, Type.BaseType);
							ilGenerator.Emit(OpCodes.Call, typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("RunClassConstructor"));
d1543 2
a1544 11
						CustomAttributeBuilder methodFlags = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { m.Modifiers });
						if(mb is ConstructorBuilder)
						{
							((ConstructorBuilder)mb).SetCustomAttribute(methodFlags);
						}
						else
						{
							((MethodBuilder)mb).SetCustomAttribute(methodFlags);
						}
						// do we have a native implementation in map.xml?
						if(nativeMethods != null)
d1546 1
a1546 3
							string key = classFile.Name.Replace('/', '.') + "." + m.Name + m.Signature;
							CodeEmitter opcodes = (CodeEmitter)nativeMethods[key];
							if(opcodes != null)
d1548 1
a1548 2
								opcodes.Emit(ilGenerator);
								continue;
d1550 1
a1550 14
						}
						// see if there exists a NativeCode class for this type
						Type nativeCodeType = Type.GetType("NativeCode." + classFile.Name.Replace('/', '.'));
						MethodInfo nativeMethod = null;
						if(nativeCodeType != null)
						{
							// TODO use better resolution
							nativeMethod = nativeCodeType.GetMethod(m.Name);
						}
						Type[] args = wrapper.GetClassLoader().ArgTypeListFromSig(m.Signature);
						if(nativeMethod != null)
						{
							int add = 0;
							if(!m.IsStatic)
d1552 1
a1552 2
								ilGenerator.Emit(OpCodes.Ldarg_0);
								add = 1;
d1554 2
a1555 1
							for(int j = 0; j < args.Length; j++)
d1557 7
a1563 42
								ilGenerator.Emit(OpCodes.Ldarg, j + add);
							}
							ilGenerator.Emit(OpCodes.Call, nativeMethod);
							Type retType = wrapper.GetClassLoader().RetTypeFromSig(m.Signature);
							if(!retType.Equals(nativeMethod.ReturnType))
							{
								ilGenerator.Emit(OpCodes.Castclass, retType);
							}
							ilGenerator.Emit(OpCodes.Ret);
						}
						else
						{
							if(JVM.NoJniStubs)
							{
								//Console.WriteLine("Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
								EmitHelper.Throw(ilGenerator, "java.lang.UnsatisfiedLinkError", "Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
								continue;
							}
							FieldBuilder methodPtr = typeBuilder.DefineField(m.Name + "$Ptr", typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
							Type localRefStructType = JVM.JniProvider.GetLocalRefStructType();
							LocalBuilder localRefStruct = ilGenerator.DeclareLocal(localRefStructType);
							ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
							ilGenerator.Emit(OpCodes.Initobj, localRefStructType);
							ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
							Label oklabel = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Brtrue, oklabel);
							ilGenerator.Emit(OpCodes.Ldstr, m.Name);
							ilGenerator.Emit(OpCodes.Ldstr, m.Signature);
							ilGenerator.Emit(OpCodes.Ldstr, classFile.Name);
							ilGenerator.Emit(OpCodes.Call, JVM.JniProvider.GetJniFuncPtrMethod());
							ilGenerator.Emit(OpCodes.Stsfld, methodPtr);
							ilGenerator.MarkLabel(oklabel);
							ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
							ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("Enter"));
							LocalBuilder jnienv = ilGenerator.DeclareLocal(typeof(IntPtr));
							ilGenerator.Emit(OpCodes.Stloc, jnienv);
							Label tryBlock = ilGenerator.BeginExceptionBlock();
							Type retType = wrapper.GetClassLoader().RetTypeFromSig(m.Signature);
							if(!retType.IsValueType && retType != typeof(void))
							{
								// this one is for use after we return from "calli"
								ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
d1565 4
a1568 7
							ilGenerator.Emit(OpCodes.Ldloc, jnienv);
							Type[] modargs = new Type[args.Length + 2];
							modargs[0] = typeof(IntPtr);
							modargs[1] = typeof(IntPtr);
							args.CopyTo(modargs, 2);
							int add = 0;
							if(!m.IsStatic)
d1570 2
a1571 4
								ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
								ilGenerator.Emit(OpCodes.Ldarg_0);
								ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("MakeLocalRef"));
								add = 1;
d1573 2
a1574 9
							else
							{
								ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
								ilGenerator.Emit(OpCodes.Ldtoken, this.Type);
								ilGenerator.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
								ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMClass).GetMethod("getClassFromType"));
								ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("MakeLocalRef"));
							}
							for(int j = 0; j < args.Length; j++)
d1576 2
a1577 1
								if(!args[j].IsValueType)
d1579 2
a1580 4
									ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
									ilGenerator.Emit(OpCodes.Ldarg, j + add);
									ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("MakeLocalRef"));
									modargs[j + 2] = typeof(IntPtr);
d1582 1
a1582 1
								else
d1586 3
a1588 8
							}
							ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
							Type returnType =(retType.IsValueType || retType == typeof(void)) ? retType : typeof(IntPtr);
							ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, returnType, modargs);
							LocalBuilder retValue = null;
							if(retType != typeof(void))
							{
								if(!retType.IsValueType)
a1589 1
									ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("UnwrapLocalRef"));
d1592 1
a1592 2
								retValue = ilGenerator.DeclareLocal(retType);
								ilGenerator.Emit(OpCodes.Stloc, retValue);
d1594 1
a1594 9
							ilGenerator.BeginCatchBlock(typeof(object));
							ilGenerator.EmitWriteLine("*** exception in native code ***");
							ilGenerator.Emit(OpCodes.Call, typeof(Console).GetMethod("WriteLine", new Type[] { typeof(object) }, null));
							ilGenerator.Emit(OpCodes.Rethrow);
							ilGenerator.BeginFinallyBlock();
							ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
							ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("Leave"));
							ilGenerator.EndExceptionBlock();
							if(retType != typeof(void))
d1596 9
a1604 1
								ilGenerator.Emit(OpCodes.Ldloc, retValue);
d1606 4
a1609 1
							ilGenerator.Emit(OpCodes.Ret);
d1617 1
a1617 2
				// if we don't have a <clinit> we need to inject one to call the base class <clinit>
				if(basehasclinit && !hasclinit && !classFile.IsInterface)
d1619 9
a1627 7
					ConstructorBuilder cb = typeBuilder.DefineConstructor(MethodAttributes.Private | MethodAttributes.Static, CallingConventions.Standard, Type.EmptyTypes);
					ModifiersAttribute.SetModifiers(cb, Modifiers.Synthetic);
					ILGenerator ilGenerator = cb.GetILGenerator();
					ilGenerator.Emit(OpCodes.Ldtoken, Type.BaseType);
					ilGenerator.Emit(OpCodes.Call, typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("RunClassConstructor"));
					ilGenerator.Emit(OpCodes.Ret);
				}
a1628 2
				if(!classFile.IsInterface)
				{
d1635 1
d1665 1
a1665 2
				// TODO don't pre-compute InnerClasses and DeclaringTypeWrapper here
				finishedType = new FinishedTypeImpl(type, InnerClasses, DeclaringTypeWrapper);
d1676 107
d1785 1
a1785 1
		public override bool IsInterface
d1789 1
a1789 1
				return typeBuilder.IsInterface;
d1793 1
a1793 1
		public override TypeWrapper[] InnerClasses
d1797 1
a1797 13
				ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
				ArrayList wrappers = new ArrayList();
				for(int i = 0; i < innerclasses.Length; i++)
				{
					if(innerclasses[i].outerClass != 0 && innerclasses[i].innerClass != 0)
					{
						if(classFile.GetConstantPoolClassType(innerclasses[i].outerClass, wrapper.GetClassLoader()) == wrapper)
						{
							wrappers.Add(classFile.GetConstantPoolClassType(innerclasses[i].innerClass, wrapper.GetClassLoader()));
						}
					}
				}
				return (TypeWrapper[])wrappers.ToArray(typeof(TypeWrapper));
d1801 1
a1801 1
		public override TypeWrapper DeclaringTypeWrapper
d1805 1
a1805 13
				ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
				ArrayList wrappers = new ArrayList();
				for(int i = 0; i < innerclasses.Length; i++)
				{
					if(innerclasses[i].outerClass != 0 && innerclasses[i].innerClass != 0)
					{
						if(classFile.GetConstantPoolClassType(innerclasses[i].innerClass, wrapper.GetClassLoader()) == wrapper)
						{
							return classFile.GetConstantPoolClassType(innerclasses[i].outerClass, wrapper.GetClassLoader());
						}
					}
				}
				return null;
d1835 2
a1836 11
			FieldBuilder field;
			ClassFile.Field fld = classFile.Fields[i];
			TypeWrapper typeWrapper = fld.GetFieldType(wrapper.GetClassLoader());
			Type type;
			if(typeWrapper.IsUnloadable)
			{
				// TODO the field name should be mangled here, because otherwise it might conflict with another field
				// with the same name and a different unloadable type (or java.lang.Object as its type)
				type = typeof(object);
			}
			else
d1838 5
a1842 43
				type = typeWrapper.Type;
			}
			FieldAttributes attribs = 0;
			MethodAttributes methodAttribs = 0;
			bool setModifiers = false;
			if(fld.IsPrivate)
			{
				attribs |= FieldAttributes.Private;
			}
			else if(fld.IsProtected)
			{
				attribs |= FieldAttributes.FamORAssem;
				methodAttribs |= MethodAttributes.FamORAssem;
			}
			else if(fld.IsPublic)
			{
				attribs |= FieldAttributes.Public;
				methodAttribs |= MethodAttributes.Public;
			}
			else
			{
				attribs |= FieldAttributes.Assembly;
				methodAttribs |= MethodAttributes.Assembly;
			}
			if(fld.IsStatic)
			{
				attribs |= FieldAttributes.Static;
				methodAttribs |= MethodAttributes.Static;
			}
			// NOTE "constant" static finals are converted into literals
			// TODO it would be possible for Java code to change the value of a non-blank static final, but I don't
			// know if we want to support this (since the Java JITs don't really support it either)
			object constantValue = fld.ConstantValue;
			if(fld.IsStatic && fld.IsFinal && constantValue != null)
			{
				attribs |= FieldAttributes.Literal;
				field = typeBuilder.DefineField(fld.Name, type, attribs);
				field.SetConstant(constantValue);
				fields[i] = FieldWrapper.Create(wrapper, field, fld.Signature, fld.Modifiers);
				// NOTE even though you're not supposed to access a constant static final (the compiler is supposed
				// to inline them), we have to support it (because it does happen, e.g. if the field becomes final
				// after the referencing class was compiled)
				if(constantValue is int || constantValue is short || constantValue is sbyte || constantValue is char || constantValue is bool)
d1844 3
a1846 1
					fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldc_I4, ((IConvertible)constantValue).ToInt32(null));
d1848 1
a1848 1
				else if(constantValue is string)
d1850 1
a1850 1
					fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldstr, (string)constantValue);
d1852 4
a1855 1
				else if(constantValue is float)
d1857 1
a1857 1
					fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldc_R4, (float)constantValue);
d1859 1
a1859 1
				else if(constantValue is double)
d1861 2
a1862 1
					fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldc_R8, (double)constantValue);
d1864 1
a1864 1
				else if(constantValue is long)
d1866 2
a1867 1
					fields[i].EmitGet = CodeEmitter.Create(OpCodes.Ldc_I8, (long)constantValue);
d1871 2
a1872 1
					throw new NotImplementedException(constantValue.GetType().FullName);
d1874 1
a1874 7
				// when non-blank final fields are updated, the JIT normally doesn't see that (because the
				// constant value is inlined), so we emulate that behavior by emitting a Pop
				fields[i].EmitSet = CodeEmitter.Create(OpCodes.Pop);
			}
			else
			{
				if(fld.IsFinal)
d1876 18
a1893 2
					// final doesn't make sense for private fields, so if the field is private we ignore final
					if(!fld.IsPrivate && !wrapper.IsInterface)
d1895 1
a1895 6
						// NOTE blank final fields get converted into a read-only property with a private field backing store
						// we used to make the field privatescope, but that really serves no purpose (and it hinders serialization,
						// which uses .NET reflection to get at the field)
						attribs &= ~FieldAttributes.FieldAccessMask;
						attribs |= FieldAttributes.Private;
						setModifiers = true;
d1897 23
d1921 1
a1921 2
				field = typeBuilder.DefineField(fld.Name, type, attribs);
				if(fld.IsTransient)
d1923 19
a1941 15
					CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(typeof(NonSerializedAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
					field.SetCustomAttribute(transientAttrib);
				}
				if(fld.IsVolatile)
				{
					// TODO the field should be marked as modreq(IsVolatile), but Reflection.Emit doesn't have a way of doing this
					setModifiers = true;
				}
				if(fld.IsFinal && !fld.IsPrivate && !wrapper.IsInterface)
				{
					methodAttribs |= MethodAttributes.SpecialName;
					// TODO we should ensure that the getter method name doesn't clash with an existing method
					MethodBuilder getter = typeBuilder.DefineMethod("get_" + fld.Name, methodAttribs, CallingConventions.Standard, type, Type.EmptyTypes);
					ModifiersAttribute.SetModifiers(getter, Modifiers.Synthetic);
					ILGenerator ilgen = getter.GetILGenerator();
d1944 2
a1945 1
						ilgen.Emit(OpCodes.Volatile);
d1947 1
a1947 1
					if(fld.IsStatic)
d1949 23
a1971 1
						ilgen.Emit(OpCodes.Ldsfld, field);
d1975 1
a1975 2
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Ldfld, field);
a1976 5
					ilgen.Emit(OpCodes.Ret);
					PropertyBuilder pb = typeBuilder.DefineProperty(fld.Name, PropertyAttributes.None, type, Type.EmptyTypes);
					pb.SetGetMethod(getter);
					fields[i] = FieldWrapper.Create(wrapper, field, fld.Signature, fld.Modifiers);
					fields[i].EmitGet = CodeEmitter.Create(OpCodes.Call, getter);
d1978 8
a1985 1
				else
d1987 1
a1987 1
					fields[i] = FieldWrapper.Create(wrapper, field, fld.Signature, fld.Modifiers);
d1990 1
a1990 8
			if(typeWrapper.IsUnloadable)
			{
				CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { typeWrapper.Name });
				field.SetCustomAttribute(attrib);
			}
			// if the Java modifiers cannot be expressed in .NET, we emit the Modifiers attribute to store
			// the Java modifiers
			if(setModifiers)
d1992 1
a1992 1
				ModifiersAttribute.SetModifiers(field, fld.Modifiers);
d2004 1
d2023 2
a2024 1
			if(methods[index] != null)
d2026 14
a2039 25
				throw new InvalidOperationException();
			}
			// TODO things to consider when we support unloadable types on the argument list on return type:
			// - later on, the method can be overriden by a class that does have access to the type, so
			//   this should be detected and an appropriate override stub should be generated
			// - overloading might conflict with the generalised argument list (unloadable types appear
			//   as System.Object). The nicest way to solve this would be to emit a modreq attribute on the parameter,
			//   but Reflection.Emit doesn't support this, so we'll probably have to use a name mangling scheme
			MethodBase method;
			ClassFile.Method m = classFile.Methods[index];
			TypeWrapper[] argTypeWrappers = m.GetArgTypes(wrapper.GetClassLoader());
			TypeWrapper retTypeWrapper = m.GetRetType(wrapper.GetClassLoader());
			Type[] args = new Type[argTypeWrappers.Length];
			Type retType;
			if(retTypeWrapper.IsUnloadable)
			{
				retType = typeof(object);
			}
			else
			{
				retType = retTypeWrapper.Type;
			}
			for(int i = 0; i < args.Length; i++)
			{
				if(argTypeWrappers[i].IsUnloadable)
d2041 1
a2041 1
					args[i] = typeof(object);
d2045 39
a2083 1
					args[i] = argTypeWrappers[i].Type;
d2085 1
a2085 9
			}
			bool setModifiers = false;
			MethodAttributes attribs = 0;
			if(m.IsAbstract)
			{
				// only if the classfile is abstract, we make the CLR method abstract, otherwise,
				// we have to generate a method that throws an AbstractMethodError (because the JVM
				// allows abstract methods in non-abstract classes)
				if(m.ClassFile.IsAbstract || m.ClassFile.IsInterface)
d2087 1
a2087 1
					attribs |= MethodAttributes.Abstract;
d2089 1
a2089 1
				else
d2091 1
a2091 1
					setModifiers = true;
d2093 1
a2093 4
			}
			if(m.IsFinal)
			{
				if(!m.IsStatic && !m.IsPrivate)
d2095 1
a2095 1
					attribs |= MethodAttributes.Final;
d2099 5
a2103 1
					setModifiers = true;
d2105 1
a2105 32
			}
			if(m.IsPrivate)
			{
				attribs |= MethodAttributes.Private;
			}
			else if(m.IsProtected)
			{
				attribs |= MethodAttributes.FamORAssem;
			}
			else if(m.IsPublic)
			{
				attribs |= MethodAttributes.Public;
			}
			else
			{
				attribs |= MethodAttributes.Assembly;
			}
			if(m.IsStatic)
			{
				attribs |= MethodAttributes.Static;
			}
			if(m.Name == "<init>")
			{
				// NOTE we don't need to record the modifiers here, because only access modifiers are valid for
				// constructors and we have a well defined (reversible) mapping from them
				method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, args);
			}
			else if(m.Name == "<clinit>" && m.Signature == "()V")
			{
				// I think this is a CLR bug, the verifier requires static inititializes of interfaces to be public
				// TODO report this bug
				if(classFile.IsInterface)
d2107 3
a2109 2
					attribs &= ~MethodAttributes.MemberAccessMask;
					attribs |= MethodAttributes.Public;
d2111 1
a2111 7
				// NOTE we don't need to record the modifiers here, because they aren't visible from Java reflection
				// (well they might be visible from JNI reflection, but that isn't important enough to justify the custom attribute)
				method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, args);
			}
			else
			{
				if(!m.IsPrivate && !m.IsStatic)
d2113 10
a2122 1
					attribs |= MethodAttributes.Virtual;
d2124 23
a2146 36
				string name = m.Name;
				MethodDescriptor md = new MethodDescriptor(wrapper.GetClassLoader(), m);
				// if a method is virtual, we need to find the method it overrides (if any), for several reasons:
				// - if we're overriding a method that has a different name (e.g. some of the virtual methods
				//   in System.Object [Equals <-> equals]) we need to add an explicit MethodOverride
				// - if one of the base classes has a similar method that is private (or package) that we aren't
				//   overriding, we need to specify an explicit MethodOverride
				MethodBase baseMethod = null;
				MethodWrapper baseMce = null;
				bool explicitOverride = false;
				if((attribs & MethodAttributes.Virtual) != 0 && !classFile.IsInterface)
				{
					TypeWrapper tw = baseWrapper;
					while(tw != null)
					{
						baseMce = tw.GetMethodWrapper(md, true);
						if(baseMce == null)
						{
							break;
						}
						// here are the complex rules for determining wether this method overrides the method we found
						// RULE 1: final methods may not be overriden
						if(baseMce.IsFinal)
						{
							// NOTE we don't need to test for our method being private, because if it is
							// we'll never get here (because private methods aren't virtual)
							// TODO make sure the VerifyError is translated into a java.lang.VerifyError
							throw new VerifyError("final method " + baseMce.Name + baseMce.Descriptor.Signature + " in " + tw.Name + " is overriden in " + wrapper.Name);
						}
						// RULE 2: public & protected methods can be overridden (package methods are handled by RULE 4)
						// (by public, protected & *package* methods [even if they are in a different package])
						if(baseMce.IsPublic || baseMce.IsProtected)
						{
							// if we already encountered a package method, we cannot override the base method of
							// that package method
							if(explicitOverride)
a2147 1
								explicitOverride = false;
d2150 16
a2165 6
							// if our method's accessibility is less than the method it overrides, we
							// need to make our method more accessible, because the CLR doesn't allow reducing access
							if((attribs & MethodAttributes.Public) == 0)
							{
								attribs &= ~MethodAttributes.MemberAccessMask;
								if(baseMce.IsPublic)
d2167 2
a2168 1
									attribs |= MethodAttributes.Public;
d2170 3
a2172 1
								else
d2174 9
a2182 1
									attribs |= MethodAttributes.FamORAssem;
d2184 2
d2187 23
a2209 2
							baseMethod = baseMce.GetMethod();
							break;
d2211 1
a2211 2
						// RULE 3: private methods are ignored
						if(!baseMce.IsPrivate)
d2213 5
a2217 2
							// RULE 4: package methods can only be overridden in the same package
							if(baseMce.DeclaringType.IsInSamePackageAs(wrapper))
d2219 3
a2221 2
								baseMethod = baseMce.GetMethod();
								break;
d2223 1
a2223 14
							// since we encountered a method with the same name/signature that we aren't overriding,
							// we need to specify an explicit override
							// NOTE we only do this if baseMce isn't private, because if it is, Reflection.Emit
							// will complain about the explicit MethodOverride (possibly a bug)
							explicitOverride = true;
						}
						tw = baseMce.DeclaringType.BaseTypeWrapper;
					}
					if(baseMethod == null)
					{
						// we need set NewSlot here, to prevent accidentally overriding methods
						// (for example, if a Java class has a method "boolean Equals(object)", we don't want that method
						// to override System.Object.Equals)
						attribs |= MethodAttributes.NewSlot;
d2225 32
a2256 1
					else
d2258 3
a2260 5
						// if we have a method overriding a more accessible method (yes, this does work), we need to make the
						// method more accessible, because otherwise the CLR will complain that we're reducing access)
						if((baseMethod.IsPublic && !m.IsPublic) ||
							(baseMethod.IsFamily && !m.IsPublic && !m.IsProtected) ||
							(!m.IsPublic && !m.IsProtected && !baseMce.DeclaringType.IsInSamePackageAs(wrapper)))
d2262 5
a2266 3
							attribs &= ~MethodAttributes.MemberAccessMask;
							attribs |= baseMethod.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
							setModifiers = true;
d2269 12
d2282 1
a2282 2
				MethodBuilder mb = typeBuilder.DefineMethod(name, attribs, retType, args);
				if(setModifiers)
d2284 4
a2287 1
					ModifiersAttribute.SetModifiers(mb, m.Modifiers);
d2289 1
a2289 15
				// if we're public and we're overriding a method that is not public, then we might be also
				// be implementing an interface method that has an IllegalAccessError stub
				// Example:
				//   class Base {
				//     protected void Foo() {}
				//   }
				//   interface IFoo {
				//     public void Foo();
				//   }
				//   class Derived extends Base implements IFoo {
				//   }
				//   class MostDerived extends Derived {
				//     public void Foo() {} 
				//   }
				if(m.IsPublic && baseWrapper != null && baseWrapper.HasIncompleteInterfaceImplementation)
d2291 1
a2291 3
					Hashtable hashtable = null;
					TypeWrapper tw = baseWrapper;
					while(tw.HasIncompleteInterfaceImplementation)
d2293 6
a2298 1
						foreach(TypeWrapper iface in tw.Interfaces)
d2300 1
a2300 1
							AddMethodOverride(typeBuilder, mb, iface, md, ref hashtable);
a2301 1
						tw = tw.BaseTypeWrapper;
d2304 1
a2304 19
				method = mb;
				// since Java constructors (and static intializers) aren't allowed to be synchronized, we only check this here
				if(m.IsSynchronized)
				{
					mb.SetImplementationFlags(method.GetMethodImplementationFlags() | MethodImplAttributes.Synchronized);
				}
				if(baseMethod != null && (explicitOverride || baseMethod.Name != name))
				{
					// assert that the method we're overriding is in fact virtual and not final!
					Debug.Assert(baseMethod.IsVirtual && !baseMethod.IsFinal);
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethod);
				}
			}
			if(retTypeWrapper.IsUnloadable)
			{
				CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { retTypeWrapper.Name });
				// NOTE since DefineParameter(0, ...) throws an exception (bug in .NET, I believe),
				// we attach the attribute to the method instead of the return value
				((MethodBuilder)method).SetCustomAttribute(attrib);
d2306 1
a2306 1
			for(int i = 0; i < argTypeWrappers.Length; i++)
d2308 1
a2308 12
				if(argTypeWrappers[i].IsUnloadable)
				{
					CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { argTypeWrappers[i].Name });
					if(method is MethodBuilder)
					{
						((MethodBuilder)method).DefineParameter(i + 1, ParameterAttributes.None, null).SetCustomAttribute(attrib);
					}
					else
					{
						((ConstructorBuilder)method).DefineParameter(i + 1, ParameterAttributes.None, null).SetCustomAttribute(attrib);
					}
				}
a2309 1
			methods[index] = MethodWrapper.Create(wrapper, new MethodDescriptor(wrapper.GetClassLoader(), m), method, method, m.Modifiers);
d2348 1
d2350 1
a2350 1
		public FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper)
d2355 1
d2376 1
a2376 1
		public override bool IsInterface
d2380 1
a2380 1
				return type.IsInterface;
d2411 1
a2411 1
	private Type type;
d2458 1
a2458 1
					MethodWrapper mw = MethodWrapper.Create(this, md, mb, mb, modifiers);
d2605 1
a2605 1
					MethodWrapper mw = new MethodWrapper(this, md, overrideMethod, redirect, modifiers);
d2647 1
a2647 1
					MethodWrapper mw = MethodWrapper.Create(this, md, method, method, modifiers);
d2741 1
a2741 1
					MethodWrapper mw = new MethodWrapper(this, md, null, null, modifiers);
d2838 1
a2838 1
			Type stubType = ClassLoaderWrapper.GetBootstrapClassLoader().GetBootstrapTypeRaw(Name.Replace('/', '.') + "$OverrideStub");
d2855 3
a2857 3
				TypeBuilder stub = GetClassLoader().ModuleBuilder.DefineType(Name.Replace('/', '.') + "$OverrideStub", type.Attributes, type);
				CustomAttributeBuilder overrideStubAttrib = new CustomAttributeBuilder(typeof(OverrideStubTypeAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
				stub.SetCustomAttribute(overrideStubAttrib);
a2896 8
	public override bool IsInterface
	{
		get
		{
			return type.IsInterface;
		}
	}

d2910 1
a2910 1
			return new TypeWrapper[0];
d2935 1
a2935 1
	internal override void ImplementOverrideStubsAndVirtuals(TypeBuilder typeBuilder, TypeWrapper wrapper, Hashtable methodLookup)
d2937 1
a2937 2
		MethodWrapper[] methods = new MethodWrapper[this.methods.Count];
		this.methods.Values.CopyTo(methods, 0);
d2993 1
a2993 1
		foreach(MethodWrapper mw in methods.Values)
d3017 2
a3018 2
						virtualsInterface = ClassLoaderWrapper.GetType(Name.Replace('/', '.') + "$VirtualMethods");
						virtualsHelperHack = ClassLoaderWrapper.GetType(Name.Replace('/', '.') + "$VirtualMethodsHelper");
d3029 2
a3030 2
					TypeBuilder typeBuilder = GetClassLoader().ModuleBuilder.DefineType(Name.Replace('/', '.') + "$VirtualMethods", TypeAttributes.Abstract | TypeAttributes.Interface | TypeAttributes.Public);
					TypeBuilder tbStaticHack = GetClassLoader().ModuleBuilder.DefineType(Name.Replace('/', '.') + "$VirtualMethodsHelper", TypeAttributes.Class | TypeAttributes.Public);
d3095 2
a3096 2
	private ClassFile classFile;
	private Type type;
a3106 8
	public override bool IsInterface
	{
		get
		{
			return type.IsInterface;
		}
	}

d3112 1
a3112 1
			return new TypeWrapper[0];
d3121 1
a3121 1
			return new TypeWrapper[0];
d3139 1
a3139 1
		if(!ModifiersAttribute.IsSynthetic(field))
d3141 1
a3141 1
			return FieldWrapper.Create(this, field, MethodDescriptor.getSigName(field.FieldType), ModifiersAttribute.GetModifiers(field));
d3205 1
a3205 1
			MethodWrapper method = new MethodWrapper(this, md, null, null, Modifiers.Public);
d3207 1
a3207 1
			TypeWrapper iface = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName(classFile.Name + "$Method");
d3251 1
a3251 1
					MethodWrapper mw = MethodWrapper.Create(this, md, method, method, ModifiersAttribute.GetModifiers(method));
d3280 1
a3280 1
	private Type type;
d3286 1
a3286 1
		: base(ModifiersAttribute.GetModifiers(type), name, baseType, ClassLoaderWrapper.GetBootstrapClassLoader())
d3288 1
d3293 1
a3293 1
	public override bool IsInterface
d3295 41
a3335 1
		get
d3337 1
a3337 1
			return type.IsInterface;
d3339 1
d3405 13
d3428 1
a3428 1
			if(!ModifiersAttribute.IsSynthetic(fields[i]))
d3430 1
a3430 1
				list.Add(CreateFieldWrapper(ModifiersAttribute.GetModifiers(fields[i]), fields[i].Name, fields[i].FieldType, fields[i], null));
d3459 1
a3459 1
				fieldWrapper.EmitSet = CodeEmitter.Create(OpCodes.Nop);
d3481 1
a3481 1
				fieldWrapper.EmitSet = CodeEmitter.Create(OpCodes.Nop);
d3517 1
a3517 1
			Modifiers modifiers = ModifiersAttribute.GetModifiers(field);
d3529 1
a3529 1
			return CreateFieldWrapper(ModifiersAttribute.GetModifiers(fi), fi.Name, fi.FieldType, fi, null);
d3560 1
a3560 1
		if(ModifiersAttribute.IsSynthetic(mb))
d3564 1
a3564 1
		MethodWrapper method = new MethodWrapper(this, md, mb, null, ModifiersAttribute.GetModifiers(mb));
d3640 1
a3640 1
			mdClone = new MethodDescriptor(ClassLoaderWrapper.GetBootstrapClassLoader(), "clone", "()Ljava/lang/Object;");
d3646 1
a3646 1
		MethodWrapper mw = new MethodWrapper(this, mdClone, clone, null, Modifiers.Public | Modifiers.Synthetic);
a3655 8
	public override bool IsInterface
	{
		get
		{
			return false;
		}
	}

d3675 1
a3675 1
			return new TypeWrapper[0];
a3732 1001
	}
}

public abstract class CodeEmitter
{
	internal abstract void Emit(ILGenerator ilgen);

	private class ChainCodeEmitter : CodeEmitter
	{
		private CodeEmitter left;
		private CodeEmitter right;

		internal ChainCodeEmitter(CodeEmitter left, CodeEmitter right)
		{
			this.left = left;
			this.right = right;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			left.Emit(ilgen);
			right.Emit(ilgen);
		}
	}

	public static CodeEmitter operator+(CodeEmitter left, CodeEmitter right)
	{
		if(left == null)
		{
			return right;
		}
		return new ChainCodeEmitter(left, right);
	}

	private class MethodInfoCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private MethodInfo mi;

		internal MethodInfoCodeEmitter(OpCode opcode, MethodInfo mi)
		{
			this.opcode = opcode;
			this.mi = mi;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode, mi);
		}
	}

	internal static CodeEmitter Create(OpCode opcode, MethodInfo mi)
	{
		Debug.Assert(mi != null);
		return new MethodInfoCodeEmitter(opcode, mi);
	}

	internal static CodeEmitter Create(OpCode opcode, MethodBase mb)
	{
		Debug.Assert(mb != null);
		if(mb is MethodInfo)
		{
			return new MethodInfoCodeEmitter(opcode, (MethodInfo)mb);
		}
		else
		{
			return new ConstructorInfoCodeEmitter(opcode, (ConstructorInfo)mb);
		}
	}

	private class ConstructorInfoCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private ConstructorInfo ci;

		internal ConstructorInfoCodeEmitter(OpCode opcode, ConstructorInfo ci)
		{
			this.opcode = opcode;
			this.ci = ci;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode, ci);
		}
	}

	internal static CodeEmitter Create(OpCode opcode, ConstructorInfo ci)
	{
		Debug.Assert(ci != null);
		return new ConstructorInfoCodeEmitter(opcode, ci);
	}

	private class FieldInfoCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private FieldInfo fi;

		internal FieldInfoCodeEmitter(OpCode opcode, FieldInfo fi)
		{
			this.opcode = opcode;
			this.fi = fi;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode, fi);
		}
	}

	internal static CodeEmitter Create(OpCode opcode, FieldInfo fi)
	{
		Debug.Assert(fi != null);
		return new FieldInfoCodeEmitter(opcode, fi);
	}

	private class OpCodeEmitter : CodeEmitter
	{
		private OpCode opcode;

		internal OpCodeEmitter(OpCode opcode)
		{
			this.opcode = opcode;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode);
		}
	}

	internal static CodeEmitter Create(OpCode opcode)
	{
		return new OpCodeEmitter(opcode);
	}

	private class TypeCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private Type type;

		internal TypeCodeEmitter(OpCode opcode, Type type)
		{
			this.opcode = opcode;
			this.type = type;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode, type);
		}
	}

	internal static CodeEmitter Create(OpCode opcode, Type type)
	{
		return new TypeCodeEmitter(opcode, type);
	}

	private class IntCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private int i;

		internal IntCodeEmitter(OpCode opcode, int i)
		{
			this.opcode = opcode;
			this.i = i;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode, i);
		}
	}

	internal static CodeEmitter Create(OpCode opcode, int i)
	{
		return new IntCodeEmitter(opcode, i);
	}

	private class FloatCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private float f;

		internal FloatCodeEmitter(OpCode opcode, float f)
		{
			this.opcode = opcode;
			this.f = f;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode, f);
		}
	}

	internal static CodeEmitter Create(OpCode opcode, float f)
	{
		return new FloatCodeEmitter(opcode, f);
	}

	private class DoubleCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private double d;

		internal DoubleCodeEmitter(OpCode opcode, double d)
		{
			this.opcode = opcode;
			this.d = d;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode, d);
		}
	}

	internal static CodeEmitter Create(OpCode opcode, double d)
	{
		return new DoubleCodeEmitter(opcode, d);
	}

	private class StringCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private string s;

		internal StringCodeEmitter(OpCode opcode, string s)
		{
			this.opcode = opcode;
			this.s = s;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode, s);
		}
	}

	internal static CodeEmitter Create(OpCode opcode, string s)
	{
		return new StringCodeEmitter(opcode, s);
	}

	private class LongCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private long l;

		internal LongCodeEmitter(OpCode opcode, long l)
		{
			this.opcode = opcode;
			this.l = l;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(opcode, l);
		}
	}

	internal static CodeEmitter Create(OpCode opcode, long l)
	{
		return new LongCodeEmitter(opcode, l);
	}
}

sealed class MethodWrapper
{
	private IntPtr cookie;
	private TypeWrapper declaringType;
	private MethodDescriptor md;
	private MethodBase originalMethod;
	private MethodBase redirMethod;
	private Modifiers modifiers;
	private bool isRemappedVirtual;
	private bool isRemappedOverride;
	internal CodeEmitter EmitCall;
	internal CodeEmitter EmitCallvirt;
	internal CodeEmitter EmitNewobj;

	// TODO creation of MethodWrappers should be cleaned up (and every instance should support Invoke())
	internal static MethodWrapper Create(TypeWrapper declaringType, MethodDescriptor md, MethodBase originalMethod, MethodBase method, Modifiers modifiers)
	{
		if(method == null)
		{
			throw new InvalidOperationException();
		}
		MethodWrapper wrapper = new MethodWrapper(declaringType, md, originalMethod, method, modifiers);
		CreateEmitters(originalMethod, method, ref wrapper.EmitCall, ref wrapper.EmitCallvirt, ref wrapper.EmitNewobj);
		TypeWrapper retType = md.RetTypeWrapper;
		if(retType.IsNonPrimitiveValueType)
		{
			wrapper.EmitCall += CodeEmitter.Create(OpCodes.Box, retType.Type);
			wrapper.EmitCallvirt += CodeEmitter.Create(OpCodes.Box, retType.Type);
		}
		if(declaringType.IsNonPrimitiveValueType)
		{
			if(method is ConstructorInfo)
			{
				wrapper.EmitNewobj += CodeEmitter.Create(OpCodes.Box, declaringType.Type);
			}
			else
			{
				// callvirt isn't allowed on a value type
				wrapper.EmitCallvirt = wrapper.EmitCall;
			}
		}
		return wrapper;
	}

	internal static void CreateEmitters(MethodBase originalMethod, MethodBase method, ref CodeEmitter call, ref CodeEmitter callvirt, ref CodeEmitter newobj)
	{
		if(method is ConstructorInfo)
		{
			call = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)method);
			callvirt = null;
			newobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)method);
		}
		else
		{
			call = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
			if(originalMethod != null && originalMethod != method)
			{
				// if we're calling a virtual method that is redirected, that overrides an already
				// existing method, we have to call it virtually, instead of redirecting
				callvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)originalMethod);
			}
			else if(method.IsStatic)
			{
				// because of redirection, it can be legal to call a static method with invokevirtual
				callvirt = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
			}
			else
			{
				callvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)method);
			}
			newobj = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
		}
	}

	internal MethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase originalMethod, MethodBase method, Modifiers modifiers)
	{
		if(method != originalMethod)
		{
			redirMethod = method;
			Debug.Assert(!(method is MethodBuilder));
		}
		this.declaringType = declaringType;
		this.md = md;
		// NOTE originalMethod may be null
		this.originalMethod = originalMethod;
		this.modifiers = modifiers;
	}

	internal IntPtr Cookie
	{
		get
		{
			if(cookie == (IntPtr)0)
			{
				cookie = (IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(this);
			}
			return cookie;
		}
	}

	internal static MethodWrapper FromCookie(IntPtr cookie)
	{
		return (MethodWrapper)((System.Runtime.InteropServices.GCHandle)cookie).Target;
	}

	internal TypeWrapper DeclaringType
	{
		get
		{
			return declaringType;
		}
	}

	internal MethodDescriptor Descriptor
	{
		get
		{
			return md;
		}
	}

	internal string Name
	{
		get
		{
			return md.Name;
		}
	}

	internal TypeWrapper ReturnType
	{
		get
		{
			return md.RetTypeWrapper;
		}
	}

	internal TypeWrapper[] GetParameters()
	{
		return md.ArgTypeWrappers;
	}

	internal Modifiers Modifiers
	{
		get
		{
			return modifiers;
		}
	}

	// IsRemappedOverride (only possible for remapped types) indicates whether the method in the
	// remapped type overrides (i.e. replaces) the method from the underlying type
	// Example: System.Object.ToString() is overriden by java.lang.Object.toString(),
	//          because java.lang.Object's toString() does something different from
	//          System.Object's ToString().
	internal bool IsRemappedOverride
	{
		get
		{
			return isRemappedOverride;
		}
		set
		{
			isRemappedOverride = value;
		}
	}

	// IsRemappedVirtual (only possible for remapped types) indicates that the method is virtual,
	// but doesn't really exist in the underlying type (there is no vtable slot to reuse)
	internal bool IsRemappedVirtual
	{
		get
		{
			return isRemappedVirtual;
		}
		set
		{
			isRemappedVirtual = value;
		}
	}

	// we expose the underlying MethodBase object,
	// for Java types, this is the method that contains the compiled Java bytecode
	// for remapped types, this is the method that underlies the remapped method
	internal MethodBase GetMethod()
	{
		return originalMethod;
	}

	// this returns the Java method's attributes in .NET terms (e.g. used to create stubs for this method)
	internal MethodAttributes GetMethodAttributes()
	{
		MethodAttributes attribs = 0;
		if(IsStatic)
		{
			attribs |= MethodAttributes.Static;
		}
		if(IsPublic)
		{
			attribs |= MethodAttributes.Public;
		}
		else if(IsPrivate)
		{
			attribs |= MethodAttributes.Private;
		}
		else if(IsProtected)
		{
			attribs |= MethodAttributes.FamORAssem;
		}
		else
		{
			attribs |= MethodAttributes.Family;
		}
		// constructors aren't virtual
		if(!IsStatic && !IsPrivate && md.Name != "<init>")
		{
			attribs |= MethodAttributes.Virtual;
		}
		if(IsFinal)
		{
			attribs |= MethodAttributes.Final;
		}
		if(IsAbstract)
		{
			attribs |= MethodAttributes.Abstract;
		}
		return attribs;
	}

	internal bool IsStatic
	{
		get
		{
			return (modifiers & Modifiers.Static) != 0;
		}
	}

	internal bool IsPublic
	{
		get
		{
			return (modifiers & Modifiers.Public) != 0;
		}
	}

	internal bool IsPrivate
	{
		get
		{
			return (modifiers & Modifiers.Private) != 0;
		}
	}

	internal bool IsProtected
	{
		get
		{
			return (modifiers & Modifiers.Protected) != 0;
		}
	}

	internal bool IsFinal
	{
		get
		{
			return (modifiers & Modifiers.Final) != 0;
		}
	}

	internal bool IsAbstract
	{
		get
		{
			return (modifiers & Modifiers.Abstract) != 0;
		}
	}

	internal object Invoke(object obj, object[] args, bool nonVirtual)
	{
		// TODO instead of looking up the method using reflection, we should use the method object passed into the
		// constructor
		if(IsStatic)
		{
			MethodInfo method = this.originalMethod != null && !(this.originalMethod is MethodBuilder) ? (MethodInfo)this.originalMethod : declaringType.Type.GetMethod(md.Name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypes, null);
			try
			{
				return method.Invoke(null, args);
			}
			catch(ArgumentException x1)
			{
				throw JavaException.IllegalArgumentException(x1.Message);
			}
			catch(TargetInvocationException x)
			{
				throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
			}
		}
		else
		{
			// calling <init> without an instance means that we're constructing a new instance
			// NOTE this means that we cannot detect a NullPointerException when calling <init>
			if(md.Name == "<init>")
			{
				if(obj == null)
				{
					ConstructorInfo constructor = this.originalMethod != null && !(this.originalMethod is ConstructorBuilder) ? (ConstructorInfo)this.originalMethod : declaringType.Type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, CallingConventions.Standard, md.ArgTypes, null);
					try
					{
						return constructor.Invoke(args);
					}
					catch(ArgumentException x1)
					{
						throw JavaException.IllegalArgumentException(x1.Message);
					}
					catch(TargetInvocationException x)
					{
						throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
					}
				}
				else
				{
					throw new NotImplementedException("invoking constructor on existing instance");
				}
			}
			if(nonVirtual)
			{
				throw new NotImplementedException("non-virtual reflective method invocation not implemented");
			}
			MethodInfo method = (MethodInfo)this.originalMethod;
			if(redirMethod != null)
			{
				method = (MethodInfo)redirMethod;
				if(method.IsStatic)
				{
					// we've been redirected to a static method, so we have to copy the this into the args
					object[] oldargs = args;
					args = new object[args.Length + 1];
					args[0] = obj;
					oldargs.CopyTo(args, 1);
					obj = null;
					// if we calling a remapped virtual method, we need to locate the proper helper method
					if(IsRemappedVirtual)
					{
						Type[] argTypes = new Type[md.ArgTypes.Length + 1];
						argTypes[0] = this.declaringType.Type;
						md.ArgTypes.CopyTo(argTypes, 1);
						method = ((RemappedTypeWrapper)this.DeclaringType).VirtualsHelperHack.GetMethod(md.Name, BindingFlags.Static | BindingFlags.Public, null, argTypes, null);
					}
				}
				else if(IsRemappedVirtual)
				{
					throw new NotImplementedException("non-static remapped virtual invocation not implement");
				}
			}
			else
			{
				if(method is MethodBuilder || method == null)
				{
					method = declaringType.Type.GetMethod(md.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypes, null);
				}
				if(method == null)
				{
					throw new NotImplementedException("method not found: " + this.declaringType.Name + "." + md.Name + md.Signature);
				}
			}
			try
			{
				return method.Invoke(obj, args);
			}
			catch(ArgumentException x1)
			{
				throw JavaException.IllegalArgumentException(x1.Message);
			}
			catch(TargetInvocationException x)
			{
				throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
			}
		}
	}
}

class CastEmitter : CodeEmitter
{
	private Type retType;
	private string sig;

	internal CastEmitter(string sig)
	{
		this.sig = sig;
	}

	internal override void Emit(ILGenerator ilgen)
	{
		if(retType == null)
		{
			retType = ClassLoaderWrapper.GetBootstrapClassLoader().RetTypeFromSig(sig);
		}
		ilgen.Emit(OpCodes.Castclass, retType);
	}
}

class VirtualEmitter : CodeEmitter
{
	private MethodDescriptor md;
	private RemappedTypeWrapper wrapper;
	private MethodInfo method;

	internal VirtualEmitter(MethodDescriptor md, RemappedTypeWrapper wrapper)
	{
		this.md = md;
		this.wrapper = wrapper;
	}

	internal override void Emit(ILGenerator ilgen)
	{
		if(method == null)
		{
			Type[] args = new Type[md.ArgTypes.Length + 1];
			md.ArgTypes.CopyTo(args, 1);
			args[0] = wrapper.Type;
			method = wrapper.VirtualsHelperHack.GetMethod(md.Name, BindingFlags.Public | BindingFlags.Static, null, CallingConventions.Standard, args, null);
		}
		ilgen.Emit(OpCodes.Call, method);
	}
}

sealed class FieldWrapper
{
	private TypeWrapper declaringType;
	private string name;
	private string sig;
	private Modifiers modifiers;
	private IntPtr cookie;
	internal CodeEmitter EmitGet;
	internal CodeEmitter EmitSet;
	private FieldInfo field;

	internal FieldWrapper(TypeWrapper declaringType, string name, string sig, Modifiers modifiers)
	{
		if((modifiers & Modifiers.Synthetic) != 0)
		{
			throw new InvalidOperationException();
		}
		this.declaringType = declaringType;
		this.name = name;
		this.sig = sig;
		this.modifiers = modifiers;
	}

	internal IntPtr Cookie
	{
		get
		{
			if(cookie == (IntPtr)0)
			{
				cookie = (IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(this);
			}
			return cookie;
		}
	}

	internal static FieldWrapper FromCookie(IntPtr cookie)
	{
		return (FieldWrapper)((System.Runtime.InteropServices.GCHandle)cookie).Target;
	}

	internal TypeWrapper DeclaringType
	{
		get
		{
			return declaringType;
		}
	}

	internal string Name
	{
		get
		{
			return name;
		}
	}

	internal Type FieldType
	{
		get
		{
			return FieldTypeWrapper.Type;
		}
	}

	internal TypeWrapper FieldTypeWrapper
	{
		get
		{
			// HACK
			return declaringType.GetClassLoader().RetTypeWrapperFromSig("()" + sig);
		}
	}

	internal Modifiers Modifiers
	{
		get
		{
			return modifiers;
		}
	}

	internal bool IsStatic
	{
		get
		{
			return (modifiers & Modifiers.Static) != 0;
		}
	}

	internal bool IsPublic
	{
		get
		{
			return (modifiers & Modifiers.Public) != 0;
		}
	}

	internal bool IsPrivate
	{
		get
		{
			return (modifiers & Modifiers.Private) != 0;
		}
	}

	internal bool IsProtected
	{
		get
		{
			return (modifiers & Modifiers.Protected) != 0;
		}
	}

	internal bool IsFinal
	{
		get
		{
			return (modifiers & Modifiers.Final) != 0;
		}
	}

	internal bool IsVolatile
	{
		get
		{
			return (modifiers & Modifiers.Volatile) != 0;
		}
	}

	private class VolatileLongDoubleGetter : CodeEmitter
	{
		private static MethodInfo getFieldFromHandle = typeof(FieldInfo).GetMethod("GetFieldFromHandle");
		private static MethodInfo monitorEnter = typeof(System.Threading.Monitor).GetMethod("Enter");
		private static MethodInfo monitorExit = typeof(System.Threading.Monitor).GetMethod("Exit");
		private FieldInfo fi;

		internal VolatileLongDoubleGetter(FieldInfo fi)
		{
			this.fi = fi;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			if(!fi.IsStatic)
			{
				ilgen.Emit(OpCodes.Dup);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brtrue, label);
				ilgen.ThrowException(typeof(NullReferenceException));
				ilgen.MarkLabel(label);
			}
			// HACK we lock on the FieldInfo object
			ilgen.Emit(OpCodes.Ldtoken, fi);
			ilgen.Emit(OpCodes.Call, getFieldFromHandle);
			ilgen.Emit(OpCodes.Call, monitorEnter);
			if(fi.IsStatic)
			{
				ilgen.Emit(OpCodes.Ldsfld, fi);
			}
			else
			{
				ilgen.Emit(OpCodes.Ldfld, fi);
			}
			ilgen.Emit(OpCodes.Ldtoken, fi);
			ilgen.Emit(OpCodes.Call, getFieldFromHandle);
			ilgen.Emit(OpCodes.Call, monitorExit);
		}
	}

	private class VolatileLongDoubleSetter : CodeEmitter
	{
		private static MethodInfo getFieldFromHandle = typeof(FieldInfo).GetMethod("GetFieldFromHandle");
		private static MethodInfo monitorEnter = typeof(System.Threading.Monitor).GetMethod("Enter");
		private static MethodInfo monitorExit = typeof(System.Threading.Monitor).GetMethod("Exit");
		private FieldInfo fi;

		internal VolatileLongDoubleSetter(FieldInfo fi)
		{
			this.fi = fi;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			if(!fi.IsStatic)
			{
				LocalBuilder local = ilgen.DeclareLocal(fi.FieldType);
				ilgen.Emit(OpCodes.Stloc, local);
				ilgen.Emit(OpCodes.Dup);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brtrue, label);
				ilgen.ThrowException(typeof(NullReferenceException));
				ilgen.MarkLabel(label);
				ilgen.Emit(OpCodes.Ldloc, local);
			}
			// HACK we lock on the FieldInfo object
			ilgen.Emit(OpCodes.Ldtoken, fi);
			ilgen.Emit(OpCodes.Call, getFieldFromHandle);
			ilgen.Emit(OpCodes.Call, monitorEnter);
			if(fi.IsStatic)
			{
				ilgen.Emit(OpCodes.Stsfld, fi);
			}
			else
			{
				ilgen.Emit(OpCodes.Stfld, fi);
			}
			ilgen.Emit(OpCodes.Ldtoken, fi);
			ilgen.Emit(OpCodes.Call, getFieldFromHandle);
			ilgen.Emit(OpCodes.Call, monitorExit);
		}
	}

	private class ValueTypeFieldSetter : CodeEmitter
	{
		private Type declaringType;
		private Type fieldType;

		internal ValueTypeFieldSetter(Type declaringType, Type fieldType)
		{
			this.declaringType = declaringType;
			this.fieldType = fieldType;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			LocalBuilder local = ilgen.DeclareLocal(fieldType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(OpCodes.Unbox, declaringType);
			ilgen.Emit(OpCodes.Ldloc, local);
		}
	}

	internal static FieldWrapper Create(TypeWrapper declaringType, FieldInfo fi, string sig, Modifiers modifiers)
	{
		FieldWrapper field = new FieldWrapper(declaringType, fi.Name, sig, modifiers);
		if(declaringType.IsNonPrimitiveValueType)
		{
			field.EmitSet = new ValueTypeFieldSetter(declaringType.Type, field.FieldType);
			field.EmitGet = CodeEmitter.Create(OpCodes.Unbox, declaringType.Type);
		}
		if(field.FieldTypeWrapper.IsNonPrimitiveValueType)
		{
			field.EmitSet += CodeEmitter.Create(OpCodes.Unbox, field.FieldTypeWrapper.Type);
			field.EmitSet += CodeEmitter.Create(OpCodes.Ldobj, field.FieldTypeWrapper.Type);
		}
		if(field.IsVolatile)
		{
			// long & double field accesses must be made atomic
			if(fi.FieldType == typeof(long) || fi.FieldType == typeof(double))
			{
				field.EmitGet = new VolatileLongDoubleGetter(fi);
				field.EmitSet = new VolatileLongDoubleSetter(fi);
				return field;
			}
			field.EmitGet += CodeEmitter.Create(OpCodes.Volatile);
			field.EmitSet += CodeEmitter.Create(OpCodes.Volatile);
		}
		if(field.IsStatic)
		{
			field.EmitGet += CodeEmitter.Create(OpCodes.Ldsfld, fi);
			field.EmitSet += CodeEmitter.Create(OpCodes.Stsfld, fi);
		}
		else
		{
			field.EmitGet += CodeEmitter.Create(OpCodes.Ldfld, fi);
			field.EmitSet += CodeEmitter.Create(OpCodes.Stfld, fi);
		}
		if(field.FieldTypeWrapper.IsNonPrimitiveValueType)
		{
			field.EmitGet += CodeEmitter.Create(OpCodes.Box, field.FieldTypeWrapper.Type);
		}
		return field;
	}

	private void LookupField()
	{
		BindingFlags bindings = BindingFlags.Public | BindingFlags.NonPublic;
		if(IsStatic)
		{
			bindings |= BindingFlags.Static;
		}
		else
		{
			bindings |= BindingFlags.Instance;
		}
		field = DeclaringType.Type.GetField(name, bindings);
	}

	internal void SetValue(object obj, object val)
	{
		// TODO this is a broken implementation (for one thing, it needs to support redirection)
		if(field == null)
		{
			LookupField();
		}
		field.SetValue(obj, val);
	}

	internal object GetValue(object obj)
	{
		// TODO this is a broken implementation (for one thing, it needs to support redirection)
		if(field == null)
		{
			LookupField();
		}
		return field.GetValue(obj);
@


1.29
log
@*** empty log message ***
@
text
@d222 12
d243 1
d258 12
d672 2
a677 2
			// HACK we're mangling the name to prevent subclasses from overriding this method
			string mangledName = this.Name + "$" + ifmethod.Name + "$" + wrapper.Name;
d686 1
a686 5
				ILGenerator ilGenerator = mb.GetILGenerator();
				TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/IllegalAccessError");
				ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name + "." + md.Name + md.Signature);
				exception.GetMethodWrapper(new MethodDescriptor(ClassLoaderWrapper.GetBootstrapClassLoader(), "<init>", "(Ljava/lang/String;)V"), false).EmitNewobj.Emit(ilGenerator);
				ilGenerator.Emit(OpCodes.Throw);
d688 1
a726 6
			else if((mce.Modifiers & Modifiers.Synthetic) != 0)
			{
				// NOTE we already generated a stub for this method (probably in the case right below here), so
				// we need to add an additional MethodImpl to this stub, to implement this interface as well
				typeBuilder.DefineMethodOverride((MethodInfo)mce.GetMethod(), (MethodInfo)ifmethod);
			}
d734 1
a734 1
				MethodBuilder mb = typeBuilder.DefineMethod(md.Name, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual, md.RetType, md.ArgTypes);
d736 1
a736 5
				ILGenerator ilGenerator = mb.GetILGenerator();
				TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/AbstractMethodError");
				ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name + "." + md.Name + md.Signature);
				exception.GetMethodWrapper(new MethodDescriptor(ClassLoaderWrapper.GetBootstrapClassLoader(), "<init>", "(Ljava/lang/String;)V"), false).EmitNewobj.Emit(ilGenerator);
				ilGenerator.Emit(OpCodes.Throw);
d738 1
a738 4
				// NOTE because we are introducing a Miranda method, we must also update the corresponding wrapper.
				// If we don't do this, subclasses might think they are introducing a new method, instead of overriding
				// this one.
				wrapper.AddMethod(MethodWrapper.Create(wrapper, md, mb, mb, Modifiers.Synthetic | Modifiers.Public | Modifiers.Abstract));
d779 1
a779 1
				MethodBuilder mb = typeBuilder.DefineMethod(md.Name, MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract, md.RetType, md.ArgTypes);
d1335 1
a1335 6
								ILGenerator ilGenerator = mb.GetILGenerator();
								TypeWrapper exceptionType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/AbstractMethodError");
								MethodWrapper method = exceptionType.GetMethodWrapper(new MethodDescriptor(ClassLoaderWrapper.GetBootstrapClassLoader(), "<init>", "(Ljava/lang/String;)V"), false);
								ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name + "." + md.Name + md.Signature);
								method.EmitNewobj.Emit(ilGenerator);
								ilGenerator.Emit(OpCodes.Throw);
d1374 1
a1374 5
							TypeWrapper exceptionType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/AbstractMethodError");
							MethodWrapper method = exceptionType.GetMethodWrapper(new MethodDescriptor(ClassLoaderWrapper.GetBootstrapClassLoader(), "<init>", "(Ljava/lang/String;)V"), false);
							ilGenerator.Emit(OpCodes.Ldstr, m.ClassFile.Name + "." + m.Name + m.Signature);
							method.EmitNewobj.Emit(ilGenerator);
							ilGenerator.Emit(OpCodes.Throw);
a1431 1
								// TODO consider throwing a java.lang.UnsatisfiedLinkError here
d1433 1
a1433 3
								ilGenerator.Emit(OpCodes.Ldstr, "Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
								ilGenerator.Emit(OpCodes.Newobj, typeof(NotImplementedException).GetConstructor(new Type[] { typeof(string) }));
								ilGenerator.Emit(OpCodes.Throw);
d1553 11
d2065 1
a2065 1
				if(baseMethod != null && !baseMethod.IsPublic && m.IsPublic)
d2069 1
a2069 1
					while(tw != baseMce.DeclaringType)
@


1.28
log
@*** empty log message ***
@
text
@d705 6
d725 1
a725 4
				// HACK we don't emit a MethodImpl, because interface methods can be implemented by private methods in the CLR,
				// but this is not legal according to the ECMA specification (Partition II, section 11.2). Note that doing
				// the right thing is more complicated, because we might need multiple MethodImpls for this one stub (if the class
				// implements multiple interfaces with this method).
@


1.27
log
@*** empty log message ***
@
text
@d719 4
a722 1
				// NOTE we don't need a MethodImpl, because interface methods can be implemented by private methods, just fine
@


1.26
log
@*** empty log message ***
@
text
@a647 3
		// HACK we're mangling the name to prevent subclasses from overriding this method (I think it is a bug
		// the CLR that it tries to override privatescope methods, by name)
		string mangledName = ifmethod.Name + "$" + wrapper.Name;
d651 2
d719 1
a719 1
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
d1178 1
d1191 1
@


1.25
log
@*** empty log message ***
@
text
@d713 1
a713 1
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetType, md.ArgTypes);
d721 4
d770 1
a770 1
				wrapper.AddMethod(MethodWrapper.Create(wrapper, md, mb, mb, Modifiers.Public | Modifiers.Abstract));
d1315 2
d1318 1
d1864 1
d1875 4
d1886 4
d1913 2
d1926 2
a1935 1
				bool setModifiers = false;
d1944 1
a1947 1
					MethodWrapper baseMce = null;
d2017 1
a2017 6
					// if we have a method overriding a more accessible method (yes, this does work), we need to make the
					// method more accessible, because otherwise the CLR will complain that we're reducing access)
					if(baseMethod != null && 
						((baseMethod.IsPublic && !m.IsPublic) ||
						(baseMethod.IsFamily && !m.IsPublic && !m.IsProtected) ||
						(!m.IsPublic && !m.IsProtected && !baseMce.DeclaringType.IsInSamePackageAs(wrapper))))
d2019 10
a2028 3
						attribs &= ~MethodAttributes.MemberAccessMask;
						attribs |= baseMethod.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
						setModifiers = true;
d2036 27
d2099 22
@


1.24
log
@*** empty log message ***
@
text
@d4124 1
d4389 1
a4389 1
	internal void SetValue(object obj, object val)
a4390 1
		// TODO this is a broken implementation (for one thing, it needs to support redirection)
d4400 1
a4400 1
		DeclaringType.Type.GetField(name, bindings).SetValue(obj, val);
d4403 1
a4403 1
	internal object GetValue(object obj)
d4406 1
a4406 2
		BindingFlags bindings = BindingFlags.Public | BindingFlags.NonPublic;
		if(IsStatic)
d4408 1
a4408 1
			bindings |= BindingFlags.Static;
d4410 7
a4416 1
		else
d4418 1
a4418 1
			bindings |= BindingFlags.Instance;
d4420 1
a4420 1
		return DeclaringType.Type.GetField(name, bindings).GetValue(obj);
@


1.23
log
@*** empty log message ***
@
text
@d1916 1
d1928 1
d1932 1
a1932 1
						MethodWrapper baseMce = tw.GetMethodWrapper(md, true);
d1998 11
d2011 4
@


1.22
log
@*** empty log message ***
@
text
@d191 1
a191 1
			string s = NativeCode.java.lang.Class.getName(type).Replace('.', '/');
d267 8
d333 1
a333 1
	internal ClassLoaderWrapper GetClassLoader()
d618 1
a618 1
			return elem1.IsSubTypeOf(elem2);
d917 1
a917 1
		: base(Modifiers.Public | Modifiers.Abstract | Modifiers.Final, null, null, ClassLoaderWrapper.GetBootstrapClassLoader())
d922 5
d1468 1
a1468 1
								ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.Class).GetMethod("getClassFromType"));
d2433 2
a2434 3
						// NOTE we abuse MethodWrapper.Create here to construct the emitters for us
						MethodWrapper temp = MethodWrapper.Create(this, md, null, redirect, modifiers);
						newopc = temp.EmitNewobj;
d2496 1
a2496 1
					t = Type.GetType(field.redirect.Class, true);
d2882 34
d2936 1
d2949 4
d2968 8
a2975 1
					return MethodWrapper.Create(this, md, method, method, ModifiersAttribute.GetModifiers(method));
d3456 1
d3460 13
d3492 1
d3515 1
d3695 18
d4309 20
d4332 10
d4363 4
@


1.21
log
@*** empty log message ***
@
text
@d1283 27
d3187 10
@


1.20
log
@*** empty log message ***
@
text
@d245 8
@


1.19
log
@*** empty log message ***
@
text
@d832 1
a832 1
		throw new InvalidOperationException("GetFieldImpl called on UnloadableTypeWrapper");
d837 1
a837 1
		throw new InvalidOperationException("GetMethodImpl called on UnloadableTypeWrapper");
d844 3
a846 3
			throw new InvalidOperationException("get_Type called on UnloadableTypeWrapper");
		}
	}
d852 1
a852 1
			throw new InvalidOperationException("get_IsInterface called on UnloadableTypeWrapper");
d860 1
a860 1
			throw new InvalidOperationException("get_Interfaces called on UnloadableTypeWrapper");
d868 1
a868 1
			throw new InvalidOperationException("get_InnerClasses called on UnloadableTypeWrapper");
d876 1
a876 1
			throw new InvalidOperationException("get_DeclaringTypeWrapper called on UnloadableTypeWrapper");
d882 1
a882 1
		throw new InvalidOperationException("Finish called on UnloadableTypeWrapper");
d1951 1
a1951 1
				// since Java constructors (and static intializers?) aren't allowed to be synchronized, we only check this here
d1966 3
a1968 2
				// TODO DefineParameter(0, ...) throws an exception, even though this looks like the way to do it...
				((MethodBuilder)method).DefineParameter(0, ParameterAttributes.None, null).SetCustomAttribute(attrib);
a2153 1
						Type t = this.type;
d2156 18
a2173 1
							t = Type.GetType(method.redirect.Class, true);
a2174 1
						redirect = t.GetMethod(name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
d2215 1
a2215 5
						// NOTE we abuse MethodWrapper.Create here to construct the emitters for us
						MethodWrapper temp = MethodWrapper.Create(this, md, overrideMethod, redirect, modifiers);
						newopc = temp.EmitNewobj;
						invokespecial = temp.EmitCall;
						invokevirtual = temp.EmitCallvirt;
d2249 8
d2335 1
a2335 1
						Type t = this.type;
d2338 22
a2359 6
							t = Type.GetType(constructor.redirect.Class, true);
						}
						MethodBase redirect = null;
						if(constructor.redirect.Name != null)
						{
							redirect = t.GetMethod(constructor.redirect.Name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
d2363 8
a2370 1
							redirect = t.GetConstructor(binding, null, CallingConventions.Standard, redir.ArgTypes, null);
a2455 1
				// TODO ensure that return type for redirected method matches with field type, or emit a castclass
d2459 5
d3575 6
d3583 3
a3585 3
			wrapper.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)method);
			wrapper.EmitCallvirt = null;
			wrapper.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)method);
d3589 1
a3589 1
			wrapper.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
d3594 1
a3594 1
				wrapper.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)originalMethod);
d3599 1
a3599 1
				wrapper.EmitCallvirt = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
d3603 1
a3603 1
				wrapper.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)method);
d3605 1
a3605 1
			wrapper.EmitNewobj = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
a3606 1
		return wrapper;
@


1.18
log
@*** empty log message ***
@
text
@d1438 2
a1439 1
							ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, (retType.IsValueType || retType == typeof(void)) ? retType : typeof(IntPtr), modargs);
@


1.17
log
@*** empty log message ***
@
text
@d3770 4
d3776 1
a3776 1
				throw ExceptionHelper.MapExceptionFast(x.InnerException);
d3792 4
d3798 1
a3798 1
						throw ExceptionHelper.MapExceptionFast(x.InnerException);
d3851 4
d3857 1
a3857 1
				throw ExceptionHelper.MapExceptionFast(x.InnerException);
@


1.16
log
@*** empty log message ***
@
text
@d808 13
d2864 1
d3134 118
@


1.15
log
@*** empty log message ***
@
text
@d1088 1
d1108 13
d1123 12
a1134 1
				typeAttribs |= TypeAttributes.Public;
d1139 8
a1146 1
				typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(f.Name.Replace('/', '.'), typeAttribs);
d1151 8
a1158 1
				typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(f.Name.Replace('/', '.'), typeAttribs, baseWrapper.Type);
d1164 13
d1187 4
d2900 7
a2906 2
				// TODO
				throw new NotImplementedException();
d2916 6
a2921 2
			// TODO
			throw new NotImplementedException();
@


1.14
log
@no message
@
text
@d617 10
d851 16
d936 16
d1031 16
d1069 2
d1152 13
d1438 2
a1439 1
				finishedType = new FinishedTypeImpl(type);
d1460 40
d1929 2
d1932 1
a1932 1
		public FinishedTypeImpl(Type type)
d1935 20
d2449 18
d2669 18
d2789 1
d2835 22
@


1.13
log
@no message
@
text
@d1710 1
a1710 1
							throw new VerifyError();
d2520 1
a2520 2
		Modifiers modifiers = ModifiersAttribute.GetModifiers(field);
		if(modifiers != Modifiers.Synthetic)
d2522 1
a2522 1
			return FieldWrapper.Create(this, field, MethodDescriptor.getSigName(field.FieldType), modifiers);
d2675 1
a2675 2
			Modifiers modifiers = ModifiersAttribute.GetModifiers(fields[i]);
			if(modifiers != Modifiers.Synthetic)
d2677 1
a2677 1
				list.Add(CreateFieldWrapper(modifiers, fields[i].Name, fields[i].FieldType, fields[i], null));
d2807 1
a2807 2
		Modifiers modifiers = ModifiersAttribute.GetModifiers(mb);
		if(modifiers == Modifiers.Synthetic)
d3516 1
a3516 1
		if(modifiers == Modifiers.Synthetic)
@


1.12
log
@no message
@
text
@d3411 1
a3411 1
				throw new NotImplementedException("non-virtual reflective method invocation non implemented");
d3425 12
@


1.11
log
@no message
@
text
@d1331 3
a1333 1
					ILGenerator ilGenerator = typeBuilder.DefineConstructor(MethodAttributes.Private | MethodAttributes.Static, CallingConventions.Standard, Type.EmptyTypes).GetILGenerator();
@


1.10
log
@no message
@
text
@d1488 3
a1490 7
				// TODO this should probably emit a IllegalAccessError (or whatever)
				// TODO also check other field[x].EmitSet's for final fields
				// UPDATE for other final fields this shouldn't happend, because the compiler will check access before
				// calling EmitSet
				// UPDATE when non-blank final fields are updated, the JIT normally doesn't see that (because the
				// constant value is inlined), so we emulate that behavior by emitting a Nop
				fields[i].EmitSet = CodeEmitter.Create(OpCodes.Nop);
@


1.9
log
@no message
@
text
@d1784 1
d2033 1
a2033 1
					MethodWrapper mw = new MethodWrapper(this, md, overrideMethod, modifiers);
d2147 1
a2147 1
					MethodWrapper mw = new MethodWrapper(this, md, null, modifiers);
d2555 1
a2555 1
			MethodWrapper method = new MethodWrapper(this, md, null, Modifiers.Public);
d2816 1
a2816 1
		MethodWrapper method = new MethodWrapper(this, md, mb, ModifiersAttribute.GetModifiers(mb));
d3120 1
d3124 1
d3132 1
d3139 1
a3139 1
		MethodWrapper wrapper = new MethodWrapper(declaringType, md, originalMethod, modifiers);
d3169 1
a3169 1
	internal MethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase originalMethod, Modifiers modifiers)
d3171 5
d3183 17
d3371 79
d3503 1
d3519 17
d3734 30
@


1.8
log
@no message
@
text
@d224 1
d539 4
d551 10
d579 1
a579 1
		if(wrapper.IsPrimitive)
@


1.7
log
@no message
@
text
@d37 16
d95 12
d119 12
d239 45
d323 1
d453 17
d478 37
d558 34
d785 47
d852 8
d905 2
a906 2
	internal DynamicTypeWrapper(string name, ClassFile f, TypeWrapper baseType, ClassLoaderWrapper classLoader, Hashtable nativeMethods)
		: base(f.Modifiers, name, baseType, classLoader)
d908 38
a945 3
		JavaTypeImpl impl = new JavaTypeImpl(f, this, baseType, nativeMethods);
		this.impl = impl;
		interfaces = impl.GetInterfaces();
d1014 1
a1014 1
		internal JavaTypeImpl(ClassFile f, DynamicTypeWrapper wrapper, TypeWrapper baseWrapper, Hashtable nativeMethods)
d1016 1
a1016 1
			//		Console.WriteLine("constructing JavaTypeImpl for " + f.Name);
d1020 1
a1035 15
			interfaces = new TypeWrapper[f.Interfaces.Length];
			for(int i = 0; i < f.Interfaces.Length; i++)
			{
				interfaces[i] = wrapper.GetClassLoader().LoadClassBySlashedName(f.Interfaces[i]);
				if(!interfaces[i].IsInterface)
				{
					throw JavaException.IncompatibleClassChangeError("Implementing class");
				}
				if(!interfaces[i].IsAccessibleFrom(wrapper))
				{
					throw JavaException.IllegalAccessError("Class {0} cannot access its superinterface {1}", wrapper.Name, interfaces[i].Name);
				}
			}
			// NOTE we call DefineType after all the interfaces have been resolved, because otherwise
			// we end up with a .NET type that cannot be completed
a1051 5
		internal TypeWrapper[] GetInterfaces()
		{
			return interfaces;
		}

d1098 1
a1098 1
					methodDescriptors[i] = new MethodDescriptor(wrapper.GetClassLoader(), classFile.Methods[i].Name, classFile.Methods[i].Signature);
d1397 7
a1403 4
			Type type = null;
			try
			{
				type = wrapper.GetClassLoader().ExpressionType(fld.Signature);
d1405 1
a1405 1
			catch(Exception x)
d1407 1
a1407 8
				if(x.GetType().FullName == "java.lang.ClassNotFoundException")
				{
					// TODO set fields[i] to a special FieldWrapper that does the appropriate thing (whatever that may be)
					fields[i] = new FieldWrapper(this.wrapper, fld.Name, fld.Signature, fld.Modifiers);
					Console.Error.WriteLine("Type " + fld.Signature + " of field " + fld.Name + " in class " + classFile.Name + " is unloadable");
					return;
				}
				throw;
d1538 5
d1559 1
a1559 1
					methodLookup[new MethodDescriptor(wrapper.GetClassLoader(), classFile.Methods[i].Name, classFile.Methods[i].Signature)] = i;
d1581 6
d1589 9
a1597 3
			Type[] args = null;
			Type retType = null;
			try
d1599 1
a1599 2
				args = wrapper.GetClassLoader().ArgTypeListFromSig(m.Signature);
				retType = wrapper.GetClassLoader().RetTypeFromSig(m.Signature);
d1601 1
a1601 1
			catch(Exception x)
d1603 5
a1607 1
				if(x.GetType().FullName == "java.lang.ClassNotFoundException")
d1609 1
a1609 4
					// TODO set methods[i] to a special MethodWrapper that does the appropriate thing (whatever that may be)
					methods[index] = new MethodWrapper(this.wrapper, new MethodDescriptor(wrapper.GetClassLoader(), m.Name, m.Signature), null, m.Modifiers);
					Console.Error.WriteLine("Type " + x.Message + " of method " + m.Name + m.Signature + " in class " + classFile.Name + " is unloadable");
					return;
a1610 1
				throw;
d1672 1
a1672 1
				MethodDescriptor md = new MethodDescriptor(wrapper.GetClassLoader(), name, m.Signature);
d1766 21
a1786 1
			methods[index] = MethodWrapper.Create(wrapper, new MethodDescriptor(wrapper.GetClassLoader(), m.Name, m.Signature), method, method, m.Modifiers);
d1848 2
a1849 2
	public RemappedTypeWrapper(Modifiers modifiers, string name, Type type, TypeWrapper[] interfaces, TypeWrapper baseType)
		: base(modifiers, name, baseType, ClassLoaderWrapper.GetBootstrapClassLoader())
a1988 1
							MethodDescriptor redir = new MethodDescriptor(GetClassLoader(), method.@@override.Name, sig);
d1990 1
a1990 1
							overrideMethod = type.GetMethod(redir.Name, binding, null, CallingConventions.Standard, redir.ArgTypes, null);
d3187 1
a3187 1
			return declaringType.GetClassLoader().RetTypeWrapperFromSig(md.Signature);
d3193 1
a3193 1
		return declaringType.GetClassLoader().ArgTypeWrapperListFromSig(md.Signature);
d3418 10
a3427 1
			return declaringType.GetClassLoader().ExpressionType(sig);
@


1.6
log
@no message
@
text
@d747 1
d815 7
a821 1
			if(finishing)
d823 1
a823 1
				throw new InvalidOperationException("Finishing already in progress, for type " + classFile.Name);
d825 1
a825 12
			finishing = true;
			//		Console.WriteLine("finishing TypeFactory for " + classFile.Name);
			if(fieldLookup == null)
			{
				fields = new FieldWrapper[classFile.Fields.Length];
				fieldLookup = new Hashtable();
				for(int i = 0; i < classFile.Fields.Length; i++)
				{
					fieldLookup[classFile.Fields[i].Name] = i;
				}
			}
			for(int i = 0; i < fields.Length; i++)
d827 1
a827 1
				if(fields[i] == null)
d829 1
a829 2
					GenerateField(i);
					wrapper.AddField(fields[i]);
d831 3
a833 11
			}
			MethodDescriptor[] methodDescriptors = new MethodDescriptor[classFile.Methods.Length];
			for(int i = 0; i < classFile.Methods.Length; i++)
			{
				methodDescriptors[i] = new MethodDescriptor(wrapper.GetClassLoader(), classFile.Methods[i].Name, classFile.Methods[i].Signature);
			}
			if(methodLookup == null)
			{
				methods = new MethodWrapper[classFile.Methods.Length];
				methodLookup = new Hashtable();
				for(int i = 0; i < classFile.Methods.Length; i++)
d835 6
a840 1
					methodLookup[methodDescriptors[i]] = i;
d842 1
a842 17
			}
			for(int i = 0; i < methods.Length; i++)
			{
				if(methods[i] == null)
				{
					GenerateMethod(i);
					wrapper.AddMethod(methods[i]);
				}
			}
			wrapper.BaseTypeWrapper.Finish();
			bool basehasclinit = wrapper.BaseTypeWrapper.Type.GetConstructor(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public, null, CallingConventions.Any, Type.EmptyTypes, null) != null;
			bool hasclinit = false;
			for(int i = 0; i < methods.Length; i++)
			{
				ILGenerator ilGenerator;
				MethodBase mb = methods[i].GetMethod();
				if(mb is ConstructorBuilder)
d844 1
a844 2
					ilGenerator = ((ConstructorBuilder)mb).GetILGenerator();
					if(basehasclinit && classFile.Methods[i].Name == "<clinit>" && classFile.Methods[i].Signature == "()V" && !classFile.IsInterface)
d846 2
a847 3
						hasclinit = true;
						ilGenerator.Emit(OpCodes.Ldtoken, Type.BaseType);
						ilGenerator.Emit(OpCodes.Call, typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("RunClassConstructor"));
d850 2
a851 1
				else if(mb != null)
d853 1
a853 1
					ilGenerator = ((MethodBuilder)mb).GetILGenerator();
d855 1
a855 1
				else
d857 6
a862 3
					// HACK methods that have unloadable types in the signature do not have an underlying method, so we end
					// up here
					continue;
d864 1
a864 2
				ClassFile.Method m = classFile.Methods[i];
				if(m.IsAbstract)
d866 1
a866 3
					// NOTE in the JVM it is apparently legal for a non-abstract class to have abstract methods, but
					// the CLR doens't allow this, so we have to emit a method that throws an AbstractMethodError
					if(!m.ClassFile.IsAbstract && !m.ClassFile.IsInterface)
d868 2
a869 5
						TypeWrapper exceptionType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/AbstractMethodError");
						MethodWrapper method = exceptionType.GetMethodWrapper(new MethodDescriptor(ClassLoaderWrapper.GetBootstrapClassLoader(), "<init>", "(Ljava/lang/String;)V"), false);
						ilGenerator.Emit(OpCodes.Ldstr, m.ClassFile.Name + "." + m.Name + m.Signature);
						method.EmitNewobj.Emit(ilGenerator);
						ilGenerator.Emit(OpCodes.Throw);
d872 4
a875 1
				else if(m.IsNative)
d877 2
a878 1
					CustomAttributeBuilder methodFlags = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { m.Modifiers });
d881 11
a891 1
						((ConstructorBuilder)mb).SetCustomAttribute(methodFlags);
d895 3
a897 1
						((MethodBuilder)mb).SetCustomAttribute(methodFlags);
d899 2
a900 2
					// do we have a native implementation in map.xml?
					if(nativeMethods != null)
d902 9
a910 6
						string key = classFile.Name.Replace('/', '.') + "." + m.Name + m.Signature;
						CodeEmitter opcodes = (CodeEmitter)nativeMethods[key];
						if(opcodes != null)
						{
							opcodes.Emit(ilGenerator);
							continue;
d913 1
a913 4
					// see if there exists a NativeCode class for this type
					Type nativeCodeType = Type.GetType("NativeCode." + classFile.Name.Replace('/', '.'));
					MethodInfo nativeMethod = null;
					if(nativeCodeType != null)
d915 2
a916 8
						// TODO use better resolution
						nativeMethod = nativeCodeType.GetMethod(m.Name);
					}
					Type[] args = wrapper.GetClassLoader().ArgTypeListFromSig(m.Signature);
					if(nativeMethod != null)
					{
						int add = 0;
						if(!m.IsStatic)
d918 1
a918 2
							ilGenerator.Emit(OpCodes.Ldarg_0);
							add = 1;
d920 1
a920 1
						for(int j = 0; j < args.Length; j++)
d922 1
a922 1
							ilGenerator.Emit(OpCodes.Ldarg, j + add);
d924 2
a925 3
						ilGenerator.Emit(OpCodes.Call, nativeMethod);
						Type retType = wrapper.GetClassLoader().RetTypeFromSig(m.Signature);
						if(!retType.Equals(nativeMethod.ReturnType))
d927 7
a933 1
							ilGenerator.Emit(OpCodes.Castclass, retType);
d935 4
a938 5
						ilGenerator.Emit(OpCodes.Ret);
					}
					else
					{
						if(JVM.NoJniStubs)
d940 2
a941 6
							// TODO consider throwing a java.lang.UnsatisfiedLinkError here
							//Console.WriteLine("Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
							ilGenerator.Emit(OpCodes.Ldstr, "Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
							ilGenerator.Emit(OpCodes.Newobj, typeof(NotImplementedException).GetConstructor(new Type[] { typeof(string) }));
							ilGenerator.Emit(OpCodes.Throw);
							continue;
d943 2
a944 21
						FieldBuilder methodPtr = typeBuilder.DefineField(m.Name + "$Ptr", typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
						Type localRefStructType = JVM.JniProvider.GetLocalRefStructType();
						LocalBuilder localRefStruct = ilGenerator.DeclareLocal(localRefStructType);
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						ilGenerator.Emit(OpCodes.Initobj, localRefStructType);
						ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
						Label oklabel = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Brtrue, oklabel);
						ilGenerator.Emit(OpCodes.Ldstr, m.Name);
						ilGenerator.Emit(OpCodes.Ldstr, m.Signature);
						ilGenerator.Emit(OpCodes.Ldstr, classFile.Name);
						ilGenerator.Emit(OpCodes.Call, JVM.JniProvider.GetJniFuncPtrMethod());
						ilGenerator.Emit(OpCodes.Stsfld, methodPtr);
						ilGenerator.MarkLabel(oklabel);
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("Enter"));
						LocalBuilder jnienv = ilGenerator.DeclareLocal(typeof(IntPtr));
						ilGenerator.Emit(OpCodes.Stloc, jnienv);
						Label tryBlock = ilGenerator.BeginExceptionBlock();
						Type retType = wrapper.GetClassLoader().RetTypeFromSig(m.Signature);
						if(!retType.IsValueType && retType != typeof(void))
d946 17
a962 2
							// this one is for use after we return from "calli"
							ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
d964 1
a964 7
						ilGenerator.Emit(OpCodes.Ldloc, jnienv);
						Type[] modargs = new Type[args.Length + 2];
						modargs[0] = typeof(IntPtr);
						modargs[1] = typeof(IntPtr);
						args.CopyTo(modargs, 2);
						int add = 0;
						if(!m.IsStatic)
d966 12
d979 10
a988 6
							ilGenerator.Emit(OpCodes.Ldarg_0);
							ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("MakeLocalRef"));
							add = 1;
						}
						else
						{
d990 17
a1006 8
							ilGenerator.Emit(OpCodes.Ldtoken, this.Type);
							ilGenerator.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
							ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.Class).GetMethod("getClassFromType"));
							ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("MakeLocalRef"));
						}
						for(int j = 0; j < args.Length; j++)
						{
							if(!args[j].IsValueType)
d1009 1
a1009 1
								ilGenerator.Emit(OpCodes.Ldarg, j + add);
d1011 1
a1011 1
								modargs[j + 2] = typeof(IntPtr);
d1015 32
a1046 1
								ilGenerator.Emit(OpCodes.Ldarg, j + add);
d1048 9
a1056 7
						}
						ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
						ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, (retType.IsValueType || retType == typeof(void)) ? retType : typeof(IntPtr), modargs);
						LocalBuilder retValue = null;
						if(retType != typeof(void))
						{
							if(!retType.IsValueType)
d1058 1
a1058 2
								ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("UnwrapLocalRef"));
								ilGenerator.Emit(OpCodes.Castclass, retType);
d1060 1
a1060 2
							retValue = ilGenerator.DeclareLocal(retType);
							ilGenerator.Emit(OpCodes.Stloc, retValue);
d1062 4
a1065 13
						ilGenerator.BeginCatchBlock(typeof(object));
						ilGenerator.EmitWriteLine("*** exception in native code ***");
						ilGenerator.Emit(OpCodes.Call, typeof(Console).GetMethod("WriteLine", new Type[] { typeof(object) }, null));
						ilGenerator.Emit(OpCodes.Rethrow);
						ilGenerator.BeginFinallyBlock();
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						ilGenerator.Emit(OpCodes.Call, localRefStructType.GetMethod("Leave"));
						ilGenerator.EndExceptionBlock();
						if(retType != typeof(void))
						{
							ilGenerator.Emit(OpCodes.Ldloc, retValue);
						}
						ilGenerator.Emit(OpCodes.Ret);
d1068 2
a1069 1
				else
d1071 4
a1074 1
					Compiler.Compile(wrapper, m, ilGenerator, wrapper.GetClassLoader());
a1075 9
			}
			// if we don't have a <clinit> we need to inject one to call the base class <clinit>
			if(basehasclinit && !hasclinit && !classFile.IsInterface)
			{
				ILGenerator ilGenerator = typeBuilder.DefineConstructor(MethodAttributes.Private | MethodAttributes.Static, CallingConventions.Standard, Type.EmptyTypes).GetILGenerator();
				ilGenerator.Emit(OpCodes.Ldtoken, Type.BaseType);
				ilGenerator.Emit(OpCodes.Call, typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("RunClassConstructor"));
				ilGenerator.Emit(OpCodes.Ret);
			}
d1077 1
a1077 9
			if(!classFile.IsInterface)
			{
				// here we loop thru all the interfaces to explicitly implement any methods that we inherit from
				// base types that may have a different name from the name in the interface
				// (e.g. interface that has an equals() method that should override System.Object.Equals())
				// also deals with interface methods that aren't implemented (generate a stub that throws AbstractMethodError)
				// and with methods that aren't public (generate a stub that throws IllegalAccessError)
				Hashtable doneSet = new Hashtable();
				for(int i = 0; i < interfaces.Length; i++)
d1079 11
a1089 1
					interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
a1090 2
				wrapper.BaseTypeWrapper.ImplementOverrideStubsAndVirtuals(typeBuilder, wrapper, methodLookup);
			}
a1091 2
			try
			{
d1103 2
a1104 1
				return new FinishedTypeImpl(type);
d1106 1
a1106 1
			catch
d1108 5
a1112 2
				Console.WriteLine("Exception caused by : " + wrapper.Name);
				throw;
@


1.5
log
@no message
@
text
@d720 4
a723 1
		impl = impl.Finish();
@


1.4
log
@no message
@
text
@d469 22
a766 10
			if(f.IsInterface)
			{
				typeAttribs |= TypeAttributes.Interface | TypeAttributes.Abstract;
				typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(f.Name.Replace('/', '.'), typeAttribs);
			}
			else
			{
				typeAttribs |= TypeAttributes.Class;
				typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(f.Name.Replace('/', '.'), typeAttribs, baseWrapper.Type);
			}
d779 15
d873 4
d879 3
a881 1
					ilGenerator = ((MethodBuilder)mb).GetILGenerator();
d1078 10
a1087 1
				Type type = typeBuilder.CreateType();
d1134 16
a1149 1
			Type type = wrapper.GetClassLoader().ExpressionType(fld.Signature);
d1319 18
a1336 1
			Type[] args = wrapper.GetClassLoader().ArgTypeListFromSig(m.Signature);
d1477 1
a1477 1
				MethodBuilder mb = typeBuilder.DefineMethod(name, attribs, wrapper.GetClassLoader().RetTypeFromSig(m.Signature), args);
@


1.3
log
@I think I finally got the handling of Miranda methods right now.
@
text
@d913 1
a925 1
						//ilGenerator.EmitWriteLine(m.Name);
d927 4
a930 1
						LocalBuilder localsref = ilGenerator.DeclareLocal(typeof(LocalRefStruct));
d937 1
a937 1
						ilGenerator.Emit(OpCodes.Call, typeof(JNI).GetMethod("GetJniFuncPtr"));
d940 5
d946 1
a946 1
						if(!retType.IsValueType)
d949 1
a949 1
							ilGenerator.Emit(OpCodes.Ldloca, localsref);
d951 1
a951 2
						ilGenerator.Emit(OpCodes.Ldloca, localsref);
						ilGenerator.Emit(OpCodes.Call, typeof(LocalRefStruct).GetMethod("Enter"));
d959 1
a959 1
							ilGenerator.Emit(OpCodes.Ldloca, localsref);
d961 1
a961 1
							ilGenerator.Emit(OpCodes.Call, typeof(LocalRefStruct).GetMethod("MakeLocalRef"));
d966 1
a966 1
							ilGenerator.Emit(OpCodes.Ldloca, localsref);
d970 1
a970 1
							ilGenerator.Emit(OpCodes.Call, typeof(LocalRefStruct).GetMethod("MakeLocalRef"));
d976 1
a976 1
								ilGenerator.Emit(OpCodes.Ldloca, localsref);
d978 1
a978 1
								ilGenerator.Emit(OpCodes.Call, typeof(LocalRefStruct).GetMethod("MakeLocalRef"));
d987 3
a989 5
						ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, retType.IsValueType ? retType : typeof(IntPtr), modargs);
						ilGenerator.Emit(OpCodes.Ldloca, localsref);
						// TODO we should use a try {} finally {} to make sure Leave is called, even if the native code throws an exception
						ilGenerator.Emit(OpCodes.Call, typeof(LocalRefStruct).GetMethod("Leave"));
						if(!retType.IsValueType)
d991 19
a1009 2
							ilGenerator.Emit(OpCodes.Call, typeof(LocalRefStruct).GetMethod("UnwrapLocalRef"));
							ilGenerator.Emit(OpCodes.Castclass, retType);
d1011 1
a1012 1
					ilGenerator.Emit(OpCodes.Ret);
d1832 16
a2480 70
	}
}

public sealed class JniHack : IJniHack
{
	public override System.Reflection.MethodBase GetMethod(object clazz, string name, string sig, bool isStatic)
	{
		// TODO this is totally broken, because JNI needs to support redirection
		TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromType(NativeCode.java.lang.Class.getType(clazz));
		wrapper.Finish();
		MethodDescriptor md = new MethodDescriptor(wrapper.GetClassLoader(), name, sig);
		BindingFlags bindings = BindingFlags.Public | BindingFlags.NonPublic;
		if(isStatic)
		{
			bindings |= BindingFlags.Static;
		}
		else
		{
			bindings |= BindingFlags.Instance;
		}
		if(name == "<init>")
		{
			return wrapper.Type.GetConstructor(bindings, null, md.ArgTypes, null);
		}
		Type type = wrapper.Type;
		while(type != null)
		{
			MethodInfo m = type.GetMethod(name, bindings, null, CallingConventions.Standard, md.ArgTypes, null);
			if(m != null)
			{
				return m;
			}
			type = type.BaseType;
		}
		return null;
	}

	public override System.Reflection.FieldInfo GetField(object clazz, string name, string sig, bool isStatic)
	{
		// TODO this is totally broken, because JNI needs to support redirection
		TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromType(NativeCode.java.lang.Class.getType(clazz));
		wrapper.Finish();
		MethodDescriptor md = new MethodDescriptor(wrapper.GetClassLoader(), name, sig);
		BindingFlags bindings = BindingFlags.Public | BindingFlags.NonPublic;
		if(isStatic)
		{
			bindings |= BindingFlags.Static;
		}
		else
		{
			bindings |= BindingFlags.Instance;
		}
		return wrapper.Type.GetField(name, bindings);
	}

	public override object FindClass(string javaName)
	{
		TypeWrapper wrapper = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName(javaName);
		wrapper.Finish();
		return NativeCode.java.lang.Class.getClassFromWrapper(wrapper);
	}

	public override Exception UnsatisfiedLinkError(string msg)
	{
		return JavaException.UnsatisfiedLinkError(msg);
	}

	public override object GetClassFromType(Type type)
	{
		return NativeCode.java.lang.Class.getClassFromType(type);
@


1.2
log
@no message
@
text
@d472 1
a472 1
			if(!wrapper.IsAbstract || true)
d526 4
d778 6
d1375 3
a1392 14
				}
				if(!wrapper.IsAbstract && m.IsPublic && !m.IsStatic)
				{
					// TODO this must be sped up...
					// TODO process interfaces implemented by base classes (and interfaces implemented by interfaces)
					foreach(TypeWrapper ifw in wrapper.BaseTypeWrapper.Interfaces)
					{
						MethodWrapper mw = ifw.GetMethodWrapper(md, false);
						if(mw != null)
						{
							// TODO don't add explicit method override, unless it is required
							typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
						}
					}
@


1.1
log
@Initial revision
@
text
@d472 1
a472 1
			if(!wrapper.IsAbstract)
@


1.1.1.1
log
@no message
@
text
@@
