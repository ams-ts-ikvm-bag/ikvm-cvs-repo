head	1.45;
access;
symbols
	initial:1.1.1.1 ikvm:1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2004.05.27.07.12.15;	author jfrijters;	state dead;
branches;
next	1.44;

1.44
date	2004.05.14.09.31.55;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.02.08.13.13;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.29.10.11.33;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.26.10.19.22;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.20.13.25.08;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.16.17.10.10;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.08.15.18.47;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.02.09.46.26;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.30.15.27.53;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.11.13.14.43;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.24.11.51.41;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.22.17.06.25;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.22.16.45.43;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.19.22.19.18;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.17.12.01.52;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.17.08.08.31;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.10.14.58.19;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.10.12.21.41;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.04.09.51.16;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.29.10.14.08;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.28.09.55.04;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.21.10.06.35;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.13.15.00.42;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.12.13.09.31;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.07.08.58.08;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.05.14.07.23;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.31.12.49.29;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.10.13.28.48;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.30.12.09.00;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.24.08.23.25;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.23.07.30.21;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.18.10.27.33;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.14.09.41.58;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.21.13.41.43;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.27.16.41.51;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.12.12.38.48;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.17.14.36.13;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.06.16.30.09;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.06.14.02.00;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.31.12.23.10;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.29.16.30.50;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.28.11.10.16;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.27.09.09.02;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.18.16.01.16;	author jfrijters;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.12.18.16.01.16;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.45
log
@*** empty log message ***
@
text
@/*
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections;
using System.Reflection;
using System.Reflection.Emit;
using System.Diagnostics;
using System.Diagnostics.SymbolStore;
using ExceptionTableEntry = ClassFile.Method.ExceptionTableEntry;
using LocalVariableTableEntry = ClassFile.Method.LocalVariableTableEntry;
using Instruction = ClassFile.Method.Instruction;

class Compiler
{
	private static CodeEmitter mapExceptionMethod;
	private static CodeEmitter mapExceptionFastMethod;
	private static CodeEmitter fillInStackTraceMethod;
	private static MethodInfo getTypeFromHandleMethod;
	private static MethodInfo getClassFromTypeMethod;
	private static MethodInfo multiANewArrayMethod;
	private static MethodInfo monitorEnterMethod;
	private static MethodInfo monitorExitMethod;
	private static MethodInfo objectToStringMethod;
	private static MethodInfo f2iMethod;
	private static MethodInfo d2iMethod;
	private static MethodInfo f2lMethod;
	private static MethodInfo d2lMethod;
	private static MethodInfo arraycopy_primitive_8Method;
	private static MethodInfo arraycopy_primitive_4Method;
	private static MethodInfo arraycopy_primitive_2Method;
	private static MethodInfo arraycopy_primitive_1Method;
	private static MethodInfo arraycopyMethod;
	private static TypeWrapper java_lang_Object;
	private static TypeWrapper java_lang_Class;
	private static TypeWrapper java_lang_Throwable;
	private static TypeWrapper java_lang_ThreadDeath;
	private TypeWrapper clazz;
	private ClassFile.Method.Code m;
	private ILGenerator ilGenerator;
	private ClassLoaderWrapper classLoader;
	private MethodAnalyzer ma;
	private ExceptionTableEntry[] exceptions;
	private ISymbolDocumentWriter symboldocument;

	static Compiler()
	{
		getTypeFromHandleMethod = typeof(Type).GetMethod("GetTypeFromHandle");
		getClassFromTypeMethod = typeof(NativeCode.java.lang.VMClass).GetMethod("getClassFromType");
		multiANewArrayMethod = typeof(ByteCodeHelper).GetMethod("multianewarray");
		monitorEnterMethod = typeof(System.Threading.Monitor).GetMethod("Enter");
		monitorExitMethod = typeof(System.Threading.Monitor).GetMethod("Exit");
		objectToStringMethod = typeof(object).GetMethod("ToString");
		f2iMethod = typeof(ByteCodeHelper).GetMethod("f2i");
		d2iMethod = typeof(ByteCodeHelper).GetMethod("d2i");
		f2lMethod = typeof(ByteCodeHelper).GetMethod("f2l");
		d2lMethod = typeof(ByteCodeHelper).GetMethod("d2l");
		arraycopy_primitive_8Method = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_8");
		arraycopy_primitive_4Method = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_4");
		arraycopy_primitive_2Method = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_2");
		arraycopy_primitive_1Method = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_1");
		arraycopyMethod = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy");
		TypeWrapper exceptionHelper = ClassLoaderWrapper.LoadClassCritical("java.lang.ExceptionHelper");
		mapExceptionMethod = exceptionHelper.GetMethodWrapper(MethodDescriptor.FromNameSig(exceptionHelper.GetClassLoader(), "MapException", "(Ljava.lang.Throwable;Lcli.System.Type;)Ljava.lang.Throwable;"), false).EmitCall;
		mapExceptionFastMethod = exceptionHelper.GetMethodWrapper(MethodDescriptor.FromNameSig(exceptionHelper.GetClassLoader(), "MapExceptionFast", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"), false).EmitCall;
		fillInStackTraceMethod = exceptionHelper.GetMethodWrapper(MethodDescriptor.FromNameSig(exceptionHelper.GetClassLoader(), "fillInStackTrace", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"), false).EmitCall;
		java_lang_Throwable = CoreClasses.java.lang.Throwable.Wrapper;
		java_lang_Object = CoreClasses.java.lang.Object.Wrapper;
		java_lang_Class = CoreClasses.java.lang.Class.Wrapper;
		java_lang_ThreadDeath = ClassLoaderWrapper.LoadClassCritical("java.lang.ThreadDeath");
	}

	private class ExceptionSorter : IComparer
	{
		public int Compare(object x, object y)
		{
			ExceptionTableEntry e1 = (ExceptionTableEntry)x;
			ExceptionTableEntry e2 = (ExceptionTableEntry)y;
			if(e1.start_pc < e2.start_pc)
			{
				return -1;
			}
			if(e1.start_pc == e2.start_pc)
			{
				if(e1.end_pc == e2.end_pc)
				{
					if(e1.ordinal > e2.ordinal)
					{
						return -1;
					}
					return 1;
				}
				if(e1.end_pc > e2.end_pc)
				{
					return -1;
				}
			}
			return 1;
		}
	}

	private Compiler(TypeWrapper clazz, ClassFile.Method.Code m, ILGenerator ilGenerator, ClassLoaderWrapper classLoader, ISymbolDocumentWriter symboldocument)
	{
		this.clazz = clazz;
		this.m = m;
		this.ilGenerator = ilGenerator;
		this.classLoader = classLoader;
		this.symboldocument = symboldocument;

		Profiler.Enter("MethodAnalyzer");
		ma = new MethodAnalyzer(clazz, m, classLoader);
		Profiler.Leave("MethodAnalyzer");

		TypeWrapper[] args = m.Method.GetArgTypes(classLoader);
		LocalVar[] locals = ma.GetAllLocalVars();
		foreach(LocalVar v in locals)
		{
			if(v.isArg)
			{
				int arg = m.ArgMap[v.local];
				TypeWrapper tw;
				if(m.Method.IsStatic)
				{
					tw = args[arg];
				}
				else if(arg == 0)
				{
					tw = clazz;
				}
				else
				{
					tw = args[arg - 1];
				}
				if(v.type != VerifierTypeWrapper.UninitializedThis &&
					(v.type != tw || tw.TypeAsLocalOrStackType != tw.TypeAsParameterType))
				{
					v.builder = ilGenerator.DeclareLocal(v.type.TypeAsLocalOrStackType);
					if(JVM.Debug && v.name != null)
					{
						v.builder.SetLocalSymInfo(v.name);
					}
					v.isArg = false;
					ilGenerator.Emit(OpCodes.Ldarg_S, (byte)arg);
					v.type.EmitConvParameterToStackType(ilGenerator);
					ilGenerator.Emit(OpCodes.Stloc, v.builder);
				}
			}
		}

		// NOTE we're going to be messing with ExceptionTableEntrys that are owned by the Method, this is very bad practice,
		// this code should probably be changed to use our own ETE class (which should also contain the ordinal, instead
		// of the one in ClassFile.cs)

		ArrayList ar = new ArrayList(m.ExceptionTable);
		restart:
			for(int i = 0; i < ar.Count; i++)
			{
				ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
				for(int j = 0; j < ar.Count; j++)
				{
					ExceptionTableEntry ej = (ExceptionTableEntry)ar[j];
					if(ei.start_pc <= ej.start_pc && ej.start_pc < ei.end_pc)
					{
						// 0006/test.j
						if(ej.end_pc > ei.end_pc)
						{
							ExceptionTableEntry emi = new ExceptionTableEntry();
							emi.start_pc = ej.start_pc;
							emi.end_pc = ei.end_pc;
							emi.catch_type = ei.catch_type;
							emi.handler_pc = ei.handler_pc;
							ExceptionTableEntry emj = new ExceptionTableEntry();
							emj.start_pc = ej.start_pc;
							emj.end_pc = ei.end_pc;
							emj.catch_type = ej.catch_type;
							emj.handler_pc = ej.handler_pc;
							ei.end_pc = emi.start_pc;
							ej.start_pc = emj.end_pc;
							ar.Insert(j, emj);
							ar.Insert(i + 1, emi);
							goto restart;
						}
						// 0007/test.j
						else if(j > i && ej.end_pc < ei.end_pc)
						{
							ExceptionTableEntry emi = new ExceptionTableEntry();
							emi.start_pc = ej.start_pc;
							emi.end_pc = ej.end_pc;
							emi.catch_type = ei.catch_type;
							emi.handler_pc = ei.handler_pc;
							ExceptionTableEntry eei = new ExceptionTableEntry();
							eei.start_pc = ej.end_pc;
							eei.end_pc = ei.end_pc;
							eei.catch_type = ei.catch_type;
							eei.handler_pc = ei.handler_pc;
							ei.end_pc = emi.start_pc;
							ar.Insert(i + 1, eei);
							ar.Insert(i + 1, emi);
							goto restart;
						}
					}
				}
			}
		// __jsr inside a try block (to a PC outside the try block) causes the try
		// block to be broken into two blocks surrounding the __jsr
		// This is actually pretty common. Take, for example, the following code:
		//	class hello
		//	{
		//		public static void main(String[] args)
		//		{
		//			try
		//			{
		//				for(;;)
		//				{
		//					if(args.length == 0) return;
		//				}
		//			}
		//			finally
		//			{
		//				System.out.println("Hello, world!");
		//			}
		//		}
		//	}
		restart_jsr:
			for(int i = 0; i < ar.Count; i++)
			{
				ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
				for(int j = FindPcIndex(ei.start_pc), e = FindPcIndex(ei.end_pc); j < e; j++)
				{
					if(m.Instructions[j].NormalizedOpCode == NormalizedByteCode.__jsr)
					{
						int targetPC = m.Instructions[j].NormalizedArg1 + m.Instructions[j].PC;
						if(targetPC < ei.start_pc || targetPC >= ei.end_pc)
						{
							ExceptionTableEntry en = new ExceptionTableEntry();
							en.catch_type = ei.catch_type;
							en.handler_pc = ei.handler_pc;
							en.start_pc = (ushort)m.Instructions[j + 1].PC;
							en.end_pc = ei.end_pc;
							ei.end_pc = (ushort)m.Instructions[j].PC;
							ar.Insert(i + 1, en);
							goto restart_jsr;
						}
					}
				}
			}
		// Split try blocks at branch targets (branches from outside the try block)
		for(int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
			int start = FindPcIndex(ei.start_pc);
			int end = FindPcIndex(ei.end_pc);
			for(int j = 0; j < m.Instructions.Length; j++)
			{
				if(j < start || j >= end)
				{
					switch(m.Instructions[j].NormalizedOpCode)
					{
						case NormalizedByteCode.__lookupswitch:
							// start at -1 to have an opportunity to handle the default offset
							for(int k = -1; k < m.Instructions[j].Values.Length; k++)
							{
								int targetPC = m.Instructions[j].PC + (k == -1 ? m.Instructions[j].DefaultOffset : m.Instructions[j].TargetOffsets[k]);
								if(ei.start_pc < targetPC && targetPC < ei.end_pc)
								{
									ExceptionTableEntry en = new ExceptionTableEntry();
									en.catch_type = ei.catch_type;
									en.handler_pc = ei.handler_pc;
									en.start_pc = (ushort)targetPC;
									en.end_pc = ei.end_pc;
									ei.end_pc = (ushort)targetPC;
									ar.Insert(i + 1, en);
									goto restart_jsr;
								}
							}
							break;
						case NormalizedByteCode.__ifeq:
						case NormalizedByteCode.__ifne:
						case NormalizedByteCode.__iflt:
						case NormalizedByteCode.__ifge:
						case NormalizedByteCode.__ifgt:
						case NormalizedByteCode.__ifle:
						case NormalizedByteCode.__if_icmpeq:
						case NormalizedByteCode.__if_icmpne:
						case NormalizedByteCode.__if_icmplt:
						case NormalizedByteCode.__if_icmpge:
						case NormalizedByteCode.__if_icmpgt:
						case NormalizedByteCode.__if_icmple:
						case NormalizedByteCode.__if_acmpeq:
						case NormalizedByteCode.__if_acmpne:
						case NormalizedByteCode.__ifnull:
						case NormalizedByteCode.__ifnonnull:
						case NormalizedByteCode.__goto:
						case NormalizedByteCode.__jsr:
						{
							int targetPC = m.Instructions[j].PC + m.Instructions[j].Arg1;
							if(ei.start_pc < targetPC && targetPC < ei.end_pc)
							{
								ExceptionTableEntry en = new ExceptionTableEntry();
								en.catch_type = ei.catch_type;
								en.handler_pc = ei.handler_pc;
								en.start_pc = (ushort)targetPC;
								en.end_pc = ei.end_pc;
								ei.end_pc = (ushort)targetPC;
								ar.Insert(i + 1, en);
								goto restart_jsr;
							}
							break;
						}
					}
				}
			}
		}
		// exception handlers are also a kind of jump, so we need to split try blocks around handlers as well
		for(int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
			for(int j = 0; j < ar.Count; j++)
			{
				ExceptionTableEntry ej = (ExceptionTableEntry)ar[j];
				if(ei.start_pc < ej.handler_pc && ej.handler_pc < ei.end_pc)
				{
					ExceptionTableEntry en = new ExceptionTableEntry();
					en.catch_type = ei.catch_type;
					en.handler_pc = ei.handler_pc;
					en.start_pc = ej.handler_pc;
					en.end_pc = ei.end_pc;
					ei.end_pc = ej.handler_pc;
					ar.Insert(i + 1, en);
					goto restart_jsr;
				}
			}
		}
		// filter out zero length try blocks
		for(int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
			if(ei.start_pc == ei.end_pc)
			{
				ar.RemoveAt(i);
				i--;
			}
			else
			{
				// exception blocks that only contain harmless instructions (i.e. instructions that will *never* throw an exception)
				// are also filtered out (to improve the quality of the generated code)
				// NOTE we don't remove exception handlers that could catch ThreadDeath, because that can be thrown
				// asynchronously (and thus appear on any instruction). This is particularly important to ensure that
				// we run finally blocks when a thread is killed.
				if(ei.catch_type != 0)
				{
					TypeWrapper exceptionType = m.Method.ClassFile.GetConstantPoolClassType(ei.catch_type, classLoader);
					if(!exceptionType.IsUnloadable && !java_lang_ThreadDeath.IsAssignableTo(exceptionType))
					{
						int start = FindPcIndex(ei.start_pc);
						int end = FindPcIndex(ei.end_pc);
						for(int j = start; j < end; j++)
						{
							if(ByteCodeMetaData.CanThrowException(m.Instructions[j].OpCode))
							{
								goto next;
							}
						}
						ar.RemoveAt(i);
						i--;
					}
				}
			}
		next:;
		}
		//		Console.WriteLine("after processing:");
		//		foreach(ExceptionTableEntry e in ar)
		//		{
		//			Console.WriteLine("{0} to {1} handler {2}", e.start_pc, e.end_pc, e.handler_pc);
		//		}

		exceptions = new ExceptionTableEntry[ar.Count];
		ar.CopyTo(exceptions, 0);
		for(int i = 0; i < exceptions.Length; i++)
		{
			exceptions[i].ordinal = i;
		}
		Array.Sort(exceptions, new ExceptionSorter());

		// TODO remove these checks, if the above exception untangling is correct, this shouldn't ever
		// be triggered
		for(int i = 0; i < exceptions.Length; i++)
		{
			for(int j = i + 1; j < exceptions.Length; j++)
			{
				// check for partially overlapping try blocks (which is legal for the JVM, but not the CLR)
				if(exceptions[i].start_pc < exceptions[j].start_pc && 
					exceptions[j].start_pc < exceptions[i].end_pc &&
					exceptions[i].end_pc < exceptions[j].end_pc)
				{
					throw new InvalidOperationException("Partially overlapping try blocks is broken");
				}
				// check that we didn't destroy the ordering, when sorting
				if(exceptions[i].start_pc <= exceptions[j].start_pc &&
					exceptions[i].end_pc >= exceptions[j].end_pc &&
					exceptions[i].ordinal < exceptions[j].ordinal)
				{
					throw new InvalidOperationException("Non recursive try blocks is broken");
				}
			}
			// make sure __jsr doesn't jump out of try block
			for(int j = FindPcIndex(exceptions[i].start_pc), e = FindPcIndex(exceptions[i].end_pc); j < e; j++)
			{
				if(m.Instructions[j].NormalizedOpCode == NormalizedByteCode.__jsr)
				{
					int targetPC = m.Instructions[j].NormalizedArg1 + m.Instructions[j].PC;
					if(targetPC < exceptions[i].start_pc || targetPC >= exceptions[i].end_pc)
					{
						throw new InvalidOperationException("Try block splitting around __jsr is broken");
					}
				}
			}
		}
	}

	private class EmitException : ApplicationException
	{
		private TypeWrapper type;

		internal EmitException(string message, TypeWrapper type)
			: base(message)
		{
			this.type = type;
		}

		internal void Emit(ILGenerator ilgen, ClassFile.Method m)
		{
			Tracer.Warning(Tracer.Compiler, "{0}: {1}\n\tat {2}.{3}{4}", type.Name, Message, m.ClassFile.Name, m.Name, m.Signature);
			ilgen.Emit(OpCodes.Ldstr, Message);
			MethodWrapper method = type.GetMethodWrapper(MethodDescriptor.FromNameSig(type.GetClassLoader(), "<init>", "(Ljava.lang.String;)V"), false);
			method.EmitNewobj.Emit(ilgen);
			ilgen.Emit(OpCodes.Throw);
		}
	}

	private sealed class IllegalAccessError : EmitException
	{
		internal IllegalAccessError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.IllegalAccessError"))
		{
		}
	}

	private sealed class InstantiationError : EmitException
	{
		internal InstantiationError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.InstantiationError"))
		{
		}
	}

	private sealed class IncompatibleClassChangeError : EmitException
	{
		internal IncompatibleClassChangeError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.IncompatibleClassChangeError"))
		{
		}
	}

	private sealed class NoSuchFieldError : EmitException
	{
		internal NoSuchFieldError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchFieldError"))
		{
		}
	}

	private sealed class AbstractMethodError : EmitException
	{
		internal AbstractMethodError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.AbstractMethodError"))
		{
		}
	}
	
	private sealed class NoSuchMethodError : EmitException
	{
		internal NoSuchMethodError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchMethodError"))
		{
		}
	}

	private sealed class ReturnCookie
	{
		private Label stub;
		private LocalBuilder local;

		internal ReturnCookie(Label stub, LocalBuilder local)
		{
			this.stub = stub;
			this.local = local;
		}

		internal void EmitRet(ILGenerator ilgen)
		{
			ilgen.MarkLabel(stub);
			if(local != null)
			{
				ilgen.Emit(OpCodes.Ldloc, local);
			}
			ilgen.Emit(OpCodes.Ret);
		}
	}

	private sealed class BranchCookie
	{
		// NOTE Stub gets used for both the push stub (inside the exception block) as well as the pop stub (outside the block)
		internal Label Stub;
		internal Label TargetLabel;
		internal bool ContentOnStack;
		internal readonly int TargetPC;
		internal DupHelper dh;

		internal BranchCookie(ILGenerator ilgen, int stackHeight, int targetPC)
		{
			this.Stub = ilgen.DefineLabel();
			this.TargetPC = targetPC;
			this.dh = new DupHelper(ilgen, stackHeight);
		}

		internal BranchCookie(Label label, int targetPC)
		{
			this.Stub = label;
			this.TargetPC = targetPC;
		}
	}

	private struct DupHelper
	{
		private enum StackType : byte
		{
			Null,
			New,
			UnitializedThis,
			Other
		}
		private ILGenerator ilgen;
		private StackType[] types;
		private LocalBuilder[] locals;

		internal DupHelper(ILGenerator ilgen, int count)
		{
			this.ilgen = ilgen;
			types = new StackType[count];
			locals = new LocalBuilder[count];
		}

		internal int Count
		{
			get
			{
				return types.Length;
			}
		}

		internal void SetType(int i, TypeWrapper type)
		{
			if(type == VerifierTypeWrapper.Null)
			{
				types[i] = StackType.Null;
			}
			else if(VerifierTypeWrapper.IsNew(type))
			{
				// new objects aren't really there on the stack
				types[i] = StackType.New;
			}
			else if(type == VerifierTypeWrapper.UninitializedThis)
			{
				// uninitialized references cannot be stored in a local, but we can reload them
				types[i] = StackType.UnitializedThis;
			}
			else
			{
				types[i] = StackType.Other;
				locals[i] = ilgen.DeclareLocal(type.TypeAsLocalOrStackType);
			}
		}

		internal void Load(int i)
		{
			switch(types[i])
			{
				case StackType.Null:
					ilgen.Emit(OpCodes.Ldnull);
					break;
				case StackType.New:
					// new objects aren't really there on the stack
					break;
				case StackType.UnitializedThis:
					ilgen.Emit(OpCodes.Ldarg_0);
					break;
				case StackType.Other:
					ilgen.Emit(OpCodes.Ldloc, locals[i]);
					break;
				default:
					throw new InvalidOperationException();
			}
		}

		internal void Store(int i)
		{
			switch(types[i])
			{
				case StackType.Null:
				case StackType.UnitializedThis:
					ilgen.Emit(OpCodes.Pop);
					break;
				case StackType.New:
					// new objects aren't really there on the stack
					break;
				case StackType.Other:
					ilgen.Emit(OpCodes.Stloc, locals[i]);
					break;
				default:
					throw new InvalidOperationException();
			}
		}
	}

	internal static void Compile(TypeWrapper clazz, ClassFile.Method m, ILGenerator ilGenerator)
	{
		ClassLoaderWrapper classLoader = clazz.GetClassLoader();
		ISymbolDocumentWriter symboldocument = null;
		if(JVM.Debug)
		{
			string sourcefile = m.ClassFile.SourceFileAttribute;
			if(sourcefile != null)
			{
				if(JVM.SourcePath != null)
				{
					sourcefile = new System.IO.FileInfo(JVM.SourcePath + "/" + clazz.PackageName.Replace('.', '/') + "/" + sourcefile).FullName;
				}
				symboldocument = classLoader.ModuleBuilder.DefineDocument(sourcefile, SymLanguageType.Java, Guid.Empty, SymDocumentType.Text);
				// the very first instruction in the method must have an associated line number, to be able
				// to step into the method in Visual Studio .NET
				ClassFile.Method.LineNumberTableEntry[] table = m.CodeAttribute.LineNumberTableAttribute;
				if(table != null)
				{
					int firstPC = int.MaxValue;
					int firstLine = -1;
					for(int i = 0; i < table.Length; i++)
					{
						if(table[i].start_pc < firstPC && table[i].line_number != 0)
						{
							firstLine = table[i].line_number;
							firstPC = table[i].start_pc;
						}
					}
					if(firstLine > 0)
					{
						ilGenerator.MarkSequencePoint(symboldocument, firstLine, 0, firstLine + 1, 0);
					}
				}
			}
		}
		TypeWrapper[] args= m.GetArgTypes(classLoader);
		for(int i = 0; i < args.Length; i++)
		{
			if(args[i].IsUnloadable)
			{
				Profiler.Count("EmitDynamicCast");
				ilGenerator.Emit(OpCodes.Ldarg, (ushort)(i + (m.IsStatic ? 0 : 1)));
				ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
				ilGenerator.Emit(OpCodes.Ldstr, args[i].Name);
				ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicCast"));
				ilGenerator.Emit(OpCodes.Pop);
			}
		}
		Compiler c;
		try
		{
			Profiler.Enter("new Compiler");
			c = new Compiler(clazz, m.CodeAttribute, ilGenerator, classLoader, symboldocument);
			Profiler.Leave("new Compiler");
		}
		catch(VerifyError x)
		{
			// because in Java the method is only verified if it is actually called,
			// we generate code here to throw the VerificationError
			string msg = string.Format("(class: {0}, method: {1}, signature: {2}, offset: {3}, instruction: {4}) {5}", x.Class, x.Method, x.Signature, x.ByteCodeOffset, x.Instruction, x.Message);
			EmitHelper.Throw(ilGenerator, "java.lang.VerifyError", msg);
			return;
		}
		Profiler.Enter("Compile");
		if(m.IsStatic && m.IsSynchronized)
		{
			ArrayList exits = new ArrayList();
			// TODO consider caching the Class object in a static field
			ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
			ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
			ilGenerator.Emit(OpCodes.Call, getClassFromTypeMethod);
			ilGenerator.Emit(OpCodes.Dup);
			LocalBuilder monitor = ilGenerator.DeclareLocal(typeof(object));
			ilGenerator.Emit(OpCodes.Stloc, monitor);
			ilGenerator.Emit(OpCodes.Call, monitorEnterMethod);
			ilGenerator.BeginExceptionBlock();
			Block b = new Block(c, 0, int.MaxValue, -1, exits, true);
			c.Compile(b);
			b.Leave();
			ilGenerator.BeginFinallyBlock();
			ilGenerator.Emit(OpCodes.Ldloc, monitor);
			ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
			ilGenerator.EndExceptionBlock();
			b.LeaveStubs(new Block(c, 0, int.MaxValue, -1, null, false));
		}
		else
		{
			Block b = new Block(c, 0, int.MaxValue, -1, null, false);
			c.Compile(b);
			b.Leave();
		}
		// HACK because of the bogus Leave instruction that Reflection.Emit generates, this location
		// sometimes appears reachable (it isn't), so we emit a bogus branch to keep the verifier happy.
		ilGenerator.Emit(OpCodes.Br_S, (sbyte)-2);
		Profiler.Leave("Compile");
	}

	private class Block
	{
		private Compiler compiler;
		private ILGenerator ilgen;
		private int begin;
		private int end;
		private int exceptionIndex;
		private ArrayList exits;
		private bool nested;
		private object[] labels;

		internal Block(Compiler compiler, int begin, int end, int exceptionIndex, ArrayList exits, bool nested)
		{
			this.compiler = compiler;
			this.ilgen = compiler.ilGenerator;
			this.begin = begin;
			this.end = end;
			this.exceptionIndex = exceptionIndex;
			this.exits = exits;
			this.nested = nested;
			labels = new object[compiler.m.Instructions.Length];
		}

		internal int End
		{
			get
			{
				return end;
			}
		}

		internal int ExceptionIndex
		{
			get
			{
				return exceptionIndex;
			}
		}

		internal void SetBackwardBranchLabel(int instructionIndex, BranchCookie bc)
		{
			// NOTE we're overwriting the label that is already there
			labels[instructionIndex] = bc.Stub;
			if(exits == null)
			{
				exits = new ArrayList();
			}
			exits.Add(bc);
		}

		internal Label GetLabel(int targetPC)
		{
			int targetIndex = compiler.FindPcIndex(targetPC);
			if(IsInRange(targetPC))
			{
				object l = labels[targetIndex];
				if(l == null)
				{
					l = ilgen.DefineLabel();
					labels[targetIndex] = l;
				}
				return (Label)l;
			}
			else
			{
				object l = labels[targetIndex];
				if(l == null)
				{
					// if we're branching out of the current exception block, we need to indirect this thru a stub
					// that saves the stack and uses leave to leave the exception block (to another stub that recovers
					// the stack)
					int stackHeight = compiler.ma.GetStackHeight(targetIndex);
					BranchCookie bc = new BranchCookie(ilgen, stackHeight, targetPC);
					bc.ContentOnStack = true;
					for(int i = 0; i < stackHeight; i++)
					{
						bc.dh.SetType(i, compiler.ma.GetRawStackTypeWrapper(targetIndex, i));
					}
					exits.Add(bc);
					l = bc;
					labels[targetIndex] = l;
				}
				return ((BranchCookie)l).Stub;
			}
		}

		internal bool HasLabel(int instructionIndex)
		{
			return labels[instructionIndex] != null;
		}

		internal void MarkLabel(int instructionIndex)
		{
			object label = labels[instructionIndex];
			if(label == null)
			{
				Label l = ilgen.DefineLabel();
				ilgen.MarkLabel(l);
				labels[instructionIndex] = l;
			}
			else
			{
				ilgen.MarkLabel((Label)label);
			}
		}

		internal bool IsInRange(int pc)
		{
			return begin <= pc && pc < end;
		}

		internal void Leave()
		{
			if(exits != null)
			{
				for(int i = 0; i < exits.Count; i++)
				{
					object exit = exits[i];
					BranchCookie bc = exit as BranchCookie;
					if(bc != null && bc.ContentOnStack)
					{
						bc.ContentOnStack = false;
						ilgen.MarkLabel(bc.Stub);
						int stack = bc.dh.Count;
						for(int n = 0; n < stack; n++)
						{
							bc.dh.Store(n);
						}
						if(bc.TargetPC == -1)
						{
							ilgen.Emit(OpCodes.Br, bc.TargetLabel);
						}
						else
						{
							bc.Stub = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Leave, bc.Stub);
						}
					}
				}
			}
		}

		internal void LeaveStubs(Block newBlock)
		{
			if(exits != null)
			{
				for(int i = 0; i < exits.Count; i++)
				{
					object exit = exits[i];
					ReturnCookie rc = exit as ReturnCookie;
					if(rc != null)
					{
						if(newBlock.exits == null)
						{
							rc.EmitRet(ilgen);
						}
						else
						{
							newBlock.exits.Add(rc);
						}
					}
					else
					{
						BranchCookie bc = exit as BranchCookie;
						if(bc != null && bc.TargetPC != -1)
						{
							Debug.Assert(!bc.ContentOnStack);
							// if the target is within the new block, we handle it, otherwise we
							// defer the cookie to our caller
							if(newBlock.IsInRange(bc.TargetPC))
							{
								bc.ContentOnStack = true;
								ilgen.MarkLabel(bc.Stub);
								int stack = bc.dh.Count;
								for(int n = stack - 1; n >= 0; n--)
								{
									bc.dh.Load(n);
								}
								ilgen.Emit(OpCodes.Br, newBlock.GetLabel(bc.TargetPC));
							}
							else
							{
								newBlock.exits.Add(bc);
							}
						}
					}
				}
			}
		}

		internal void AddExitHack(object bc)
		{
			exits.Add(bc);
		}

		internal bool IsNested
		{
			get
			{
				return nested;
			}
		}
	}

	private void Compile(Block block)
	{
		int[] scope = null;
		// if we're emitting debugging information, we need to use scopes for local variables
		if(JVM.Debug)
		{
			scope = new int[m.Instructions.Length];
			LocalVariableTableEntry[] lvt = m.LocalVariableTableAttribute;
			if(lvt != null)
			{
				for(int i = 0; i < lvt.Length; i++)
				{
					// TODO validate the contents of the LVT entry
					int index = FindPcIndex(lvt[i].start_pc);
					if(index > 0)
					{
						// NOTE javac (correctly) sets start_pc of the LVT entry to the instruction
						// following the store that first initializes the local, so we have to
						// detect that case and adjust our local scope (because we'll be creating
						// the local when we encounter the first store).
						LocalVar v = ma.GetLocalVar(index - 1);
						if(v != null && v.local == lvt[i].index)
						{
							index--;
						}
					}
					scope[index]++;
					int end = lvt[i].start_pc + lvt[i].length;
					if(end == m.Instructions[m.Instructions.Length - 1].PC)
					{
						scope[m.Instructions.Length - 1]--;
					}
					else
					{
						scope[FindPcIndex(end)]--;
					}
				}
			}
		}
		int exceptionIndex = 0;
		Instruction[] code = m.Instructions;
		Stack blockStack = new Stack();
		bool instructionIsForwardReachable = true;
		for(int i = 0; i < code.Length; i++)
		{
			Instruction instr = code[i];

			if(scope != null)
			{
				for(int j = scope[i]; j < 0; j++)
				{
					ilGenerator.EndScope();
				}
				for(int j = scope[i]; j > 0; j--)
				{
					ilGenerator.BeginScope();
				}
			}

			// if we've left the current exception block, do the exit processing
			while(block.End == instr.PC)
			{
				block.Leave();

				ExceptionTableEntry exc = exceptions[block.ExceptionIndex];

				Block prevBlock = block;
				block = (Block)blockStack.Pop();

				exceptionIndex = block.ExceptionIndex + 1;
				// skip over exception handlers that are no longer relevant
				for(; exceptionIndex < exceptions.Length && exceptions[exceptionIndex].end_pc <= instr.PC; exceptionIndex++)
				{
				}

				TypeWrapper exceptionTypeWrapper;
				if(exc.catch_type == 0)
				{
					exceptionTypeWrapper = java_lang_Throwable;
				}
				else
				{
					exceptionTypeWrapper = m.Method.ClassFile.GetConstantPoolClassType(exc.catch_type, classLoader);
				}
				Type excType = exceptionTypeWrapper.TypeAsExceptionType;
				bool mapSafe = !exceptionTypeWrapper.IsUnloadable && !exceptionTypeWrapper.IsMapUnsafeException;
				if(true)
				{
					if(mapSafe)
					{
						ilGenerator.BeginCatchBlock(excType);
					}
					else
					{
						ilGenerator.BeginCatchBlock(typeof(Exception));
					}
					BranchCookie bc = new BranchCookie(ilGenerator, 1, exc.handler_pc);
					prevBlock.AddExitHack(bc);
					int handlerIndex = FindPcIndex(exc.handler_pc);
					Instruction handlerInstr = code[handlerIndex];
					bool unusedException = handlerInstr.NormalizedOpCode == NormalizedByteCode.__pop ||
						(handlerInstr.NormalizedOpCode == NormalizedByteCode.__astore &&
						ma.GetLocalVar(handlerIndex) == null);
					// special case for catch(Throwable) (and finally), that produces less code and
					// should be faster
					if(mapSafe || excType == typeof(Exception))
					{
						if(unusedException)
						{
							// we must still have an item on the stack, even though it isn't used!
							bc.dh.SetType(0, VerifierTypeWrapper.Null);
						}
						else
						{
							if(mapSafe)
							{
								ilGenerator.Emit(OpCodes.Dup);
							}
							mapExceptionFastMethod.Emit(ilGenerator);
							if(mapSafe)
							{
								ilGenerator.Emit(OpCodes.Pop);
							}
							bc.dh.SetType(0, exceptionTypeWrapper);
							bc.dh.Store(0);
						}
						ilGenerator.Emit(OpCodes.Leave, bc.Stub);
					}
					else
					{
						if(exceptionTypeWrapper.IsUnloadable)
						{
							Profiler.Count("EmitDynamicGetTypeAsExceptionType");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, exceptionTypeWrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetTypeAsExceptionType"));
							mapExceptionMethod.Emit(ilGenerator);
						}
						else
						{
							ilGenerator.Emit(OpCodes.Ldtoken, excType);
							ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
							mapExceptionMethod.Emit(ilGenerator);
							ilGenerator.Emit(OpCodes.Castclass, excType);
						}
						if(unusedException)
						{
							// we must still have an item on the stack, even though it isn't used!
							bc.dh.SetType(0, VerifierTypeWrapper.Null);
						}
						else
						{
							bc.dh.SetType(0, exceptionTypeWrapper);
							ilGenerator.Emit(OpCodes.Dup);
							bc.dh.Store(0);
						}
						Label rethrow = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Brfalse, rethrow);
						ilGenerator.Emit(OpCodes.Leave, bc.Stub);
						ilGenerator.MarkLabel(rethrow);
						ilGenerator.Emit(OpCodes.Rethrow);
					}
					ilGenerator.EndExceptionBlock();
				}
				prevBlock.LeaveStubs(block);
			}

			if(!ma.IsReachable(i))
			{
				// skip any unreachable instructions
				continue;
			}

			// if there was a forward branch to this instruction, it is forward reachable
			instructionIsForwardReachable |= block.HasLabel(i);

			// TODO for now, every instruction has an associated label, I'm not sure it's worthwhile,
			// but it could be optimized
			block.MarkLabel(i);

			// if the instruction is only backward reachable, ECMA says it must have an empty stack,
			// so we move the stack to locals
			if(!instructionIsForwardReachable)
			{
				int stackHeight = ma.GetStackHeight(i);
				if(stackHeight != 0)
				{
					BranchCookie bc = new BranchCookie(ilGenerator, stackHeight, -1);
					bc.ContentOnStack = true;
					bc.TargetLabel = ilGenerator.DefineLabel();
					ilGenerator.MarkLabel(bc.TargetLabel);
					for(int j = 0; j < stackHeight; j++)
					{
						bc.dh.SetType(j, ma.GetRawStackTypeWrapper(i, j));
					}
					for(int j = stackHeight - 1; j >= 0; j--)
					{
						bc.dh.Load(j);
					}
					block.SetBackwardBranchLabel(i, bc);
				}
			}

			// if we're entering an exception block, we need to setup the exception block and
			// transfer the stack into it
			// Note that an exception block that *starts* at an unreachable instruction,
			// is completely unreachable, because it is impossible to branch into an exception block.
			for(; exceptionIndex < exceptions.Length && exceptions[exceptionIndex].start_pc == instr.PC; exceptionIndex++)
			{
				int stackHeight = ma.GetStackHeight(i);
				if(stackHeight != 0)
				{
					DupHelper dh = new DupHelper(ilGenerator, stackHeight);
					for(int k = 0; k < stackHeight; k++)
					{
						dh.SetType(k, ma.GetRawStackTypeWrapper(i, k));
						dh.Store(k);
					}
					ilGenerator.BeginExceptionBlock();
					for(int k = stackHeight - 1; k >= 0; k--)
					{
						dh.Load(k);
					}
				}
				else
				{
					ilGenerator.BeginExceptionBlock();
				}
				blockStack.Push(block);
				block = new Block(this, exceptions[exceptionIndex].start_pc, exceptions[exceptionIndex].end_pc, exceptionIndex, new ArrayList(), true);
				block.MarkLabel(i);
			}

			if(symboldocument != null)
			{
				ClassFile.Method.LineNumberTableEntry[] table = m.LineNumberTableAttribute;
				if(table != null)
				{
					for(int j = 0; j < table.Length; j++)
					{
						if(table[j].start_pc == instr.PC && table[j].line_number != 0)
						{
							ilGenerator.MarkSequencePoint(symboldocument, table[j].line_number, 0, table[j].line_number + 1, 0);
							// we emit a nop to make sure we always have an instruction associated with the sequence point
							ilGenerator.Emit(OpCodes.Nop);
							break;
						}
					}
				}
			}

			try
			{
				switch(instr.NormalizedOpCode)
				{
					case NormalizedByteCode.__getstatic:
					case NormalizedByteCode.__putstatic:
					case NormalizedByteCode.__getfield:
					case NormalizedByteCode.__putfield:
						GetPutField(instr, i);
						break;
					case NormalizedByteCode.__aconst_null:
						ilGenerator.Emit(OpCodes.Ldnull);
						break;
					case NormalizedByteCode.__iconst:
						EmitLdc_I4(instr.NormalizedArg1);
						break;
					case NormalizedByteCode.__lconst_0:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Conv_I8);
						break;
					case NormalizedByteCode.__lconst_1:
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Conv_I8);
						break;
					case NormalizedByteCode.__fconst_0:
					case NormalizedByteCode.__dconst_0:
						// floats are stored as native size on the stack, so both R4 and R8 are the same
						ilGenerator.Emit(OpCodes.Ldc_R4, 0.0f);
						break;
					case NormalizedByteCode.__fconst_1:
					case NormalizedByteCode.__dconst_1:
						// floats are stored as native size on the stack, so both R4 and R8 are the same
						ilGenerator.Emit(OpCodes.Ldc_R4, 1.0f);
						break;
					case NormalizedByteCode.__fconst_2:
						ilGenerator.Emit(OpCodes.Ldc_R4, 2.0f);
						break;
					case NormalizedByteCode.__ldc:
					{
						ClassFile cf = instr.MethodCode.Method.ClassFile;
						int constant = instr.Arg1;
						switch(cf.GetConstantPoolConstantType(constant))
						{
							case ClassFile.ConstantType.Double:
								ilGenerator.Emit(OpCodes.Ldc_R8, cf.GetConstantPoolConstantDouble(constant));
								break;
							case ClassFile.ConstantType.Float:
								ilGenerator.Emit(OpCodes.Ldc_R4, cf.GetConstantPoolConstantFloat(constant));
								break;
							case ClassFile.ConstantType.Integer:
								EmitLdc_I4(cf.GetConstantPoolConstantInteger(constant));
								break;
							case ClassFile.ConstantType.Long:
								ilGenerator.Emit(OpCodes.Ldc_I8, cf.GetConstantPoolConstantLong(constant));
								break;
							case ClassFile.ConstantType.String:
								ilGenerator.Emit(OpCodes.Ldstr, cf.GetConstantPoolConstantString(constant));
								break;
							case ClassFile.ConstantType.Class:
							{
								TypeWrapper tw = cf.GetConstantPoolClassType(constant, classLoader);
								if(tw.IsUnloadable)
								{
									Profiler.Count("EmitDynamicClassLiteral");
									ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
									ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
									ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicClassLiteral"));
								}
								else
								{
									ilGenerator.Emit(OpCodes.Ldtoken, tw.IsRemapped ? tw.TypeAsBaseType : tw.TypeAsTBD);
									ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
									ilGenerator.Emit(OpCodes.Call, getClassFromTypeMethod);
								}
								java_lang_Class.EmitCheckcast(clazz, ilGenerator);
								break;
							}
							default:
								throw new InvalidOperationException();
						}
						break;
					}
					case NormalizedByteCode.__invokestatic:
					{
						ClassFile.ConstantPoolItemFMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
						// HACK special case for calls to System.arraycopy, if the array arguments on the stack
						// are of a known array type, we can redirect to an optimized version of arraycopy.
						if(cpi.Class == "java.lang.System" &&
							cpi.Name == "arraycopy" &&
							cpi.Signature == "(Ljava.lang.Object;ILjava.lang.Object;II)V" &&
							cpi.GetClassType(classLoader).GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader())
						{
							TypeWrapper t1 = ma.GetRawStackTypeWrapper(i, 2);
							TypeWrapper t2 = ma.GetRawStackTypeWrapper(i, 4);
							if(t1.IsArray && t1 == t2)
							{
								switch(t1.Name[1])
								{
									case 'J':
									case 'D':
										ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_8Method);
										break;
									case 'I':
									case 'F':
										ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_4Method);
										break;
									case 'S':
									case 'C':
										ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_2Method);
										break;
									case 'B':
									case 'Z':
										ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_1Method);
										break;
									default:
										ilGenerator.Emit(OpCodes.Call, arraycopyMethod);
										break;
								}
								break;
							}
						}
						CodeEmitter emitNewobj;
						CodeEmitter emitCall;
						CodeEmitter emitCallvirt;
						GetMethodCallEmitter(cpi, null, NormalizedByteCode.__invokestatic, out emitNewobj, out emitCall, out emitCallvirt);
						// if the stack values don't match the argument types (for interface argument types)
						// we must emit code to cast the stack value to the interface type
						CastInterfaceArgs(cpi.GetArgTypes(classLoader), i, false, false);
						emitCall.Emit(ilGenerator);
						break;
					}
					case NormalizedByteCode.__invokevirtual:
					case NormalizedByteCode.__invokeinterface:
					case NormalizedByteCode.__invokespecial:
					{
						ClassFile.ConstantPoolItemFMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
						int argcount = cpi.GetArgTypes(classLoader).Length;
						TypeWrapper type = ma.GetRawStackTypeWrapper(i, argcount);
						TypeWrapper thisType = SigTypeToClassName(type, cpi.GetClassType(classLoader));

						// if the stack values don't match the argument types (for interface argument types)
						// we must emit code to cast the stack value to the interface type
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>" && VerifierTypeWrapper.IsNew(type))
						{
							TypeWrapper[] args = cpi.GetArgTypes(classLoader);
							CastInterfaceArgs(args, i, false, false);
						}
						else
						{
							// the this reference is included in the argument list because it may also need to be cast
							TypeWrapper[] methodArgs = cpi.GetArgTypes(classLoader);
							TypeWrapper[] args = new TypeWrapper[methodArgs.Length + 1];
							methodArgs.CopyTo(args, 1);
							if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface)
							{
								args[0] = cpi.GetClassType(classLoader);
							}
							else
							{
								args[0] = thisType;
							}
							CastInterfaceArgs(args, i, true, instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && type != VerifierTypeWrapper.UninitializedThis);
						}

						CodeEmitter emitNewobj = null;
						CodeEmitter emitCall = null;
						CodeEmitter emitCallvirt = null;
						CodeEmitter emit = null;
						GetMethodCallEmitter(cpi, thisType, instr.NormalizedOpCode, out emitNewobj, out emitCall, out emitCallvirt);
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
						{
							emit = emitCall;
						}
						else
						{
							emit = emitCallvirt;
						}
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>")
						{
							if(VerifierTypeWrapper.IsNew(type))
							{
								// we have to construct a list of all the unitialized references to the object
								// we're about to create on the stack, so that we can reconstruct the stack after
								// the "newobj" instruction
								int trivcount = 0;
								bool nontrivial = false;
								bool[] stackfix = new bool[ma.GetStackHeight(i) - (argcount + 1)];
								for(int j = 0; j < stackfix.Length; j++)
								{
									if(ma.GetRawStackTypeWrapper(i, argcount + 1 + j) == type)
									{
										stackfix[j] = true;
										if(trivcount == j)
										{
											trivcount++;
										}
										else
										{
											// if there is other stuff on the stack between the new object
											// references, we need to do more work to construct the proper stack
											// layout after the newobj instruction
											nontrivial = true;
										}
									}
								}
								for(int j = 0; !nontrivial && j < m.MaxLocals; j++)
								{
									if(ma.GetLocalTypeWrapper(i, j) == type)
									{
										nontrivial = true;
									}
								}
								emitNewobj.Emit(ilGenerator);
								if(!thisType.IsUnloadable && thisType.IsSubTypeOf(java_lang_Throwable))
								{
									// HACK if the next instruction isn't an athrow, we need to
									// call fillInStackTrace, because the object might be used
									// to print out a stack trace without ever being thrown
									if(code[i + 1].NormalizedOpCode != NormalizedByteCode.__athrow)
									{
										ilGenerator.Emit(OpCodes.Dup);
										fillInStackTraceMethod.Emit(ilGenerator);
										ilGenerator.Emit(OpCodes.Pop);
									}
								}
								if(nontrivial)
								{
									// this could be done a little more efficiently, but since in practice this
									// code never runs (for code compiled from Java source) it doesn't
									// really matter
									LocalBuilder newobj = ilGenerator.DeclareLocal(thisType.TypeAsLocalOrStackType);
									ilGenerator.Emit(OpCodes.Stloc, newobj);
									LocalBuilder[] tempstack = new LocalBuilder[stackfix.Length];
									for(int j = 0; j < stackfix.Length; j++)
									{
										if(!stackfix[j])
										{
											TypeWrapper stacktype = ma.GetRawStackTypeWrapper(i, argcount + 1 + j);
											// it could be another new object reference (not from current invokespecial <init>
											// instruction)
											if(stacktype == VerifierTypeWrapper.Null)
											{
												// TODO handle null stack entries
												throw new NotImplementedException();
											}
											else if(!VerifierTypeWrapper.IsNew(stacktype))
											{
												LocalBuilder lb = ilGenerator.DeclareLocal(stacktype.TypeAsLocalOrStackType);
												ilGenerator.Emit(OpCodes.Stloc, lb);
												tempstack[j] = lb;
											}
										}
									}
									for(int j = stackfix.Length - 1; j >= 0; j--)
									{
										if(stackfix[j])
										{
											ilGenerator.Emit(OpCodes.Ldloc, newobj);
										}
										else if(tempstack[j] != null)
										{
											ilGenerator.Emit(OpCodes.Ldloc, tempstack[j]);
										}
									}
									LocalVar[] locals = ma.GetLocalVarsForInvokeSpecial(i);
									for(int j = 0; j < locals.Length; j++)
									{
										if(locals[j] != null)
										{
											if(locals[j].builder == null)
											{
												// for invokespecial the resulting type can never be null
												locals[j].builder = ilGenerator.DeclareLocal(locals[j].type.TypeAsLocalOrStackType);
											}
											ilGenerator.Emit(OpCodes.Ldloc, newobj);
											ilGenerator.Emit(OpCodes.Stloc, locals[j].builder);
										}
									}
								}
								else
								{
									if(trivcount == 0)
									{
										ilGenerator.Emit(OpCodes.Pop);
									}
									else
									{
										for(int j = 1; j < trivcount; j++)
										{
											ilGenerator.Emit(OpCodes.Dup);
										}
									}
								}
							}
							else
							{
								Debug.Assert(type == VerifierTypeWrapper.UninitializedThis);
								emitCall.Emit(ilGenerator);
								LocalVar[] locals = ma.GetLocalVarsForInvokeSpecial(i);
								for(int j = 0; j < locals.Length; j++)
								{
									if(locals[j] != null)
									{
										if(locals[j].builder == null)
										{
											// for invokespecial the resulting type can never be null
											locals[j].builder = ilGenerator.DeclareLocal(locals[j].type.TypeAsLocalOrStackType);
										}
										ilGenerator.Emit(OpCodes.Ldarg_0);
										ilGenerator.Emit(OpCodes.Stloc, locals[j].builder);
									}
								}
							}
						}
						else
						{
							emit.Emit(ilGenerator);
						}
						break;
					}
					case NormalizedByteCode.__return:
					case NormalizedByteCode.__areturn:
					case NormalizedByteCode.__ireturn:
					case NormalizedByteCode.__lreturn:
					case NormalizedByteCode.__freturn:
					case NormalizedByteCode.__dreturn:
					{
						if(block.IsNested)
						{
							// if we're inside an exception block, copy TOS to local, emit "leave" and push item onto our "todo" list
							LocalBuilder local = null;
							if(instr.NormalizedOpCode != NormalizedByteCode.__return)
							{
								TypeWrapper retTypeWrapper = m.Method.GetRetType(classLoader);
								retTypeWrapper.EmitConvStackToParameterType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
								if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
								{
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsParameterType);
								}
								local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
								ilGenerator.Emit(OpCodes.Stloc, local);
							}
							Label label = ilGenerator.DefineLabel();
							// NOTE leave automatically discards any junk that may be on the stack
							ilGenerator.Emit(OpCodes.Leave, label);
							block.AddExitHack(new ReturnCookie(label, local));
						}
						else
						{
							// if there is junk on the stack (other than the return value), we must pop it off
							// because in .NET this is invalid (unlike in Java)
							int stackHeight = ma.GetStackHeight(i);
							if(instr.NormalizedOpCode == NormalizedByteCode.__return)
							{
								if(stackHeight != 0)
								{
									ilGenerator.Emit(OpCodes.Leave_S, (byte)0);
								}
								ilGenerator.Emit(OpCodes.Ret);
							}
							else
							{
								TypeWrapper retTypeWrapper = m.Method.GetRetType(classLoader);
								retTypeWrapper.EmitConvStackToParameterType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
								if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
								{
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsParameterType);
								}
								if(stackHeight != 1)
								{
									LocalBuilder local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
									ilGenerator.Emit(OpCodes.Stloc, local);
									ilGenerator.Emit(OpCodes.Leave_S, (byte)0);
									ilGenerator.Emit(OpCodes.Ldloc, local);
								}
								ilGenerator.Emit(OpCodes.Ret);
							}
						}
						break;
					}
					case NormalizedByteCode.__aload:
					{
						TypeWrapper type = ma.GetLocalTypeWrapper(i, instr.NormalizedArg1);
						if(type == VerifierTypeWrapper.Null)
						{
							// if the local is known to be null, we just emit a null
							ilGenerator.Emit(OpCodes.Ldnull);
						}
						else if(VerifierTypeWrapper.IsNew(type))
						{
							// since new objects aren't represented on the stack, we don't need to do anything here
						}
						else if(type == VerifierTypeWrapper.UninitializedThis)
						{
							// any unitialized this reference has to be loaded from arg 0
							// NOTE if the method overwrites the this references, it will always end up in
							// a different local (due to the way the local variable liveness analysis works),
							// so we don't have to worry about that.
							ilGenerator.Emit(OpCodes.Ldarg_0);
						}
						else
						{
							LocalVar v = LoadLocal(instr);
							if(!type.IsUnloadable && !v.type.IsUnloadable && !v.type.IsAssignableTo(type))
							{
								type.EmitCheckcast(type, ilGenerator);
							}
						}
						break;
					}
					case NormalizedByteCode.__astore:
					{
						TypeWrapper type = ma.GetRawStackTypeWrapper(i, 0);
						// HACK we use "int" to track the return address of a jsr
						if(VerifierTypeWrapper.IsRet(type))
						{
							StoreLocal(instr);
						}
						else if(VerifierTypeWrapper.IsNew(type))
						{
							// NOTE new objects aren't really on the stack, so we can't copy them into the local.
							// We do store a null in the local, to prevent it from retaining an unintentional reference
							// to whatever object reference happens to be there
							ilGenerator.Emit(OpCodes.Ldnull);
							StoreLocal(instr);
						}
						else if(type == VerifierTypeWrapper.UninitializedThis)
						{
							// any unitialized reference is always the this reference, we don't store anything
							// here (because CLR won't allow unitialized references in locals) and then when
							// the unitialized ref is loaded we redirect to the this reference
							ilGenerator.Emit(OpCodes.Pop);
						}
						else
						{
							StoreLocal(instr);
						}
						break;
					}
					case NormalizedByteCode.__iload:
					case NormalizedByteCode.__lload:
					case NormalizedByteCode.__fload:
					case NormalizedByteCode.__dload:
						LoadLocal(instr);
						break;
					case NormalizedByteCode.__istore:
					case NormalizedByteCode.__lstore:
					case NormalizedByteCode.__fstore:
					case NormalizedByteCode.__dstore:
						StoreLocal(instr);
						break;
					case NormalizedByteCode.__new:
					{
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(wrapper.IsUnloadable)
						{
							Profiler.Count("EmitDynamicNewCheckOnly");
							// this is here to make sure we throw the exception in the right location (before
							// evaluating the constructor arguments)
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicNewCheckOnly"));
						}
						else if(!wrapper.IsAccessibleFrom(clazz))
						{
							throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
						}
						else if(wrapper.IsAbstract || wrapper.IsInterface)
						{
							throw new InstantiationError(wrapper.Name);
						}
						// we don't do anything here, the call to <init> will be converted into a newobj instruction
						break;
					}
					case NormalizedByteCode.__multianewarray:
					{
						LocalBuilder localArray = ilGenerator.DeclareLocal(typeof(int[]));
						LocalBuilder localInt = ilGenerator.DeclareLocal(typeof(int));
						EmitLdc_I4(instr.Arg2);
						ilGenerator.Emit(OpCodes.Newarr, typeof(int));
						ilGenerator.Emit(OpCodes.Stloc, localArray);
						for(int j = 1; j <= instr.Arg2; j++)
						{
							ilGenerator.Emit(OpCodes.Stloc, localInt);
							ilGenerator.Emit(OpCodes.Ldloc, localArray);
							EmitLdc_I4(instr.Arg2 - j);
							ilGenerator.Emit(OpCodes.Ldloc, localInt);
							ilGenerator.Emit(OpCodes.Stelem_I4);
						}
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(wrapper.IsUnloadable)
						{
							Profiler.Count("EmitDynamicMultianewarray");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Ldloc, localArray);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicMultianewarray"));
						}
						else
						{
							if(!wrapper.IsAccessibleFrom(clazz))
							{
								throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
							}
							Type type = wrapper.TypeAsArrayType;
							ilGenerator.Emit(OpCodes.Ldtoken, type);
							ilGenerator.Emit(OpCodes.Ldloc, localArray);
							ilGenerator.Emit(OpCodes.Call, multiANewArrayMethod);
							ilGenerator.Emit(OpCodes.Castclass, type);
						}
						break;
					}
					case NormalizedByteCode.__anewarray:
					{
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(wrapper.IsUnloadable)
						{
							Profiler.Count("EmitDynamicNewarray");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicNewarray"));
						}
						else
						{
							if(!wrapper.IsAccessibleFrom(clazz))
							{
								throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
							}
							// NOTE for ghost types we create object arrays to make sure that Ghost implementers can be
							// stored in ghost arrays, but this has the unintended consequence that ghost arrays can
							// contain *any* reference type (because they are compiled as Object arrays). We could
							// modify aastore to emit code to check for this, but this would have an huge performance
							// cost for all object arrays.
							// Oddly, while the JVM accepts any reference for any other interface typed references, in the
							// case of aastore it does check that the object actually implements the interface. This
							// is unfortunate, but I think we can live with this minor incompatibility.
							// Note that this does not break type safety, because when the incorrect object is eventually
							// used as the ghost interface type it will generate a ClassCastException.
							ilGenerator.Emit(OpCodes.Newarr, wrapper.TypeAsArrayType);
						}
						break;
					}
					case NormalizedByteCode.__newarray:
					switch(instr.Arg1)
					{
						case 4:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.BOOLEAN.TypeAsArrayType);
							break;
						case 5:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.CHAR.TypeAsArrayType);
							break;
						case 6:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.FLOAT.TypeAsArrayType);
							break;
						case 7:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.DOUBLE.TypeAsArrayType);
							break;
						case 8:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.BYTE.TypeAsArrayType);
							break;
						case 9:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.SHORT.TypeAsArrayType);
							break;
						case 10:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.INT.TypeAsArrayType);
							break;
						case 11:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.LONG.TypeAsArrayType);
							break;
						default:
							// this can't happen, the verifier would have caught it
							throw new InvalidOperationException();
					}
						break;
					case NormalizedByteCode.__checkcast:
					{
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(!wrapper.IsUnloadable && !wrapper.IsAccessibleFrom(clazz))
						{
							throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
						}
						wrapper.EmitCheckcast(clazz, ilGenerator);
						break;
					}
					case NormalizedByteCode.__instanceof:
					{
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(!wrapper.IsUnloadable && !wrapper.IsAccessibleFrom(clazz))
						{
							throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
						}
						wrapper.EmitInstanceOf(clazz, ilGenerator);
						break;
					}
					case NormalizedByteCode.__aaload:
					{
						TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 1);
						if(tw.IsUnloadable)
						{
							Profiler.Count("EmitDynamicAaload");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAaload"));
						}
						else
						{
							TypeWrapper elem = tw.ElementTypeWrapper;
							if(elem.IsNonPrimitiveValueType)
							{
								Type t = elem.TypeAsTBD;
								ilGenerator.Emit(OpCodes.Ldelema, t);
								ilGenerator.Emit(OpCodes.Ldobj, t);
								elem.EmitBox(ilGenerator);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Ldelem_Ref);
							}
						}
						break;
					}
					case NormalizedByteCode.__baload:
						// NOTE both the JVM and the CLR use signed bytes for boolean arrays (how convenient!)
						ilGenerator.Emit(OpCodes.Ldelem_I1);
						break;
					case NormalizedByteCode.__bastore:
						ilGenerator.Emit(OpCodes.Stelem_I1);
						break;
					case NormalizedByteCode.__caload:
						ilGenerator.Emit(OpCodes.Ldelem_U2);
						break;
					case NormalizedByteCode.__castore:
						ilGenerator.Emit(OpCodes.Stelem_I2);
						break;
					case NormalizedByteCode.__saload:
						ilGenerator.Emit(OpCodes.Ldelem_I2);
						break;
					case NormalizedByteCode.__sastore:
						ilGenerator.Emit(OpCodes.Stelem_I2);
						break;
					case NormalizedByteCode.__iaload:
						ilGenerator.Emit(OpCodes.Ldelem_I4);
						break;
					case NormalizedByteCode.__iastore:
						ilGenerator.Emit(OpCodes.Stelem_I4);
						break;
					case NormalizedByteCode.__laload:
						ilGenerator.Emit(OpCodes.Ldelem_I8);
						break;
					case NormalizedByteCode.__lastore:
						ilGenerator.Emit(OpCodes.Stelem_I8);
						break;
					case NormalizedByteCode.__faload:
						ilGenerator.Emit(OpCodes.Ldelem_R4);
						break;
					case NormalizedByteCode.__fastore:
						ilGenerator.Emit(OpCodes.Stelem_R4);
						break;
					case NormalizedByteCode.__daload:
						ilGenerator.Emit(OpCodes.Ldelem_R8);
						break;
					case NormalizedByteCode.__dastore:
						ilGenerator.Emit(OpCodes.Stelem_R8);
						break;
					case NormalizedByteCode.__aastore:
					{
						TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 2);
						if(tw.IsUnloadable)
						{
							Profiler.Count("EmitDynamicAastore");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAastore"));
						}
						else
						{
							TypeWrapper elem = tw.ElementTypeWrapper;
							if(elem.IsNonPrimitiveValueType)
							{
								Type t = elem.TypeAsTBD;
								LocalBuilder local = ilGenerator.DeclareLocal(typeof(object));
								ilGenerator.Emit(OpCodes.Stloc, local);
								ilGenerator.Emit(OpCodes.Ldelema, t);
								ilGenerator.Emit(OpCodes.Ldloc, local);
								elem.EmitUnbox(ilGenerator);
								ilGenerator.Emit(OpCodes.Stobj, t);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Stelem_Ref);
							}
						}
						break;
					}
					case NormalizedByteCode.__arraylength:
						if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
						{
							ilGenerator.Emit(OpCodes.Castclass, typeof(Array));
							ilGenerator.Emit(OpCodes.Callvirt, typeof(Array).GetMethod("get_Length"));
						}
						else
						{
							ilGenerator.Emit(OpCodes.Ldlen);
						}
						break;
					case NormalizedByteCode.__lcmp:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(long));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(long));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bgt_S, res1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res1);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__fcmpl:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(float));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(float));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bgt_S, res1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res1);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__fcmpg:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(float));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(float));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label resm1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Blt_S, resm1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(resm1);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__dcmpl:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(double));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(double));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bgt_S, res1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res1);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__dcmpg:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(double));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(double));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label resm1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Blt, resm1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br, end);
						ilGenerator.MarkLabel(resm1);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						ilGenerator.Emit(OpCodes.Br, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__if_icmpeq:
						ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmpne:
						ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmple:
						ilGenerator.Emit(OpCodes.Ble, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmplt:
						ilGenerator.Emit(OpCodes.Blt, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmpge:
						ilGenerator.Emit(OpCodes.Bge, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmpgt:
						ilGenerator.Emit(OpCodes.Bgt, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifle:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Ble, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__iflt:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Blt, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifge:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Bge, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifgt:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Bgt, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifne:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifeq:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifnonnull:
						ilGenerator.Emit(OpCodes.Brtrue, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifnull:
						ilGenerator.Emit(OpCodes.Brfalse, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_acmpeq:
						ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_acmpne:
						ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__goto:
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ineg:
					case NormalizedByteCode.__lneg:
					case NormalizedByteCode.__fneg:
					case NormalizedByteCode.__dneg:
						ilGenerator.Emit(OpCodes.Neg);
						break;
					case NormalizedByteCode.__iadd:
					case NormalizedByteCode.__ladd:
					case NormalizedByteCode.__fadd:
					case NormalizedByteCode.__dadd:
						ilGenerator.Emit(OpCodes.Add);
						break;
					case NormalizedByteCode.__isub:
					case NormalizedByteCode.__lsub:
					case NormalizedByteCode.__fsub:
					case NormalizedByteCode.__dsub:
						ilGenerator.Emit(OpCodes.Sub);
						break;
					case NormalizedByteCode.__ixor:
					case NormalizedByteCode.__lxor:
						ilGenerator.Emit(OpCodes.Xor);
						break;
					case NormalizedByteCode.__ior:
					case NormalizedByteCode.__lor:
						ilGenerator.Emit(OpCodes.Or);
						break;
					case NormalizedByteCode.__iand:
					case NormalizedByteCode.__land:
						ilGenerator.Emit(OpCodes.And);
						break;
					case NormalizedByteCode.__imul:
					case NormalizedByteCode.__lmul:
					case NormalizedByteCode.__fmul:
					case NormalizedByteCode.__dmul:
						ilGenerator.Emit(OpCodes.Mul);
						break;
					case NormalizedByteCode.__idiv:
					case NormalizedByteCode.__ldiv:
					{
						// we need to special case dividing by -1, because the CLR div instruction
						// throws an OverflowException when dividing Int32.MinValue by -1, and
						// Java just silently overflows
						ilGenerator.Emit(OpCodes.Dup);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						if(instr.NormalizedOpCode == NormalizedByteCode.__ldiv)
						{
							ilGenerator.Emit(OpCodes.Conv_I8);
						}
						Label label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bne_Un_S, label);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Neg);
						Label label2 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, label2);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Div);
						ilGenerator.MarkLabel(label2);
						break;
					}
					case NormalizedByteCode.__fdiv:
					case NormalizedByteCode.__ddiv:
						ilGenerator.Emit(OpCodes.Div);
						break;
					case NormalizedByteCode.__irem:
					case NormalizedByteCode.__lrem:
					{
						// we need to special case taking the remainder of dividing by -1,
						// because the CLR rem instruction throws an OverflowException when
						// taking the remainder of dividing Int32.MinValue by -1, and
						// Java just silently overflows
						ilGenerator.Emit(OpCodes.Dup);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
						{
							ilGenerator.Emit(OpCodes.Conv_I8);
						}
						Label label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bne_Un_S, label);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
						{
							ilGenerator.Emit(OpCodes.Conv_I8);
						}
						Label label2 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, label2);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Rem);
						ilGenerator.MarkLabel(label2);
						break;
					}
					case NormalizedByteCode.__frem:
					case NormalizedByteCode.__drem:
						ilGenerator.Emit(OpCodes.Rem);
						break;
					case NormalizedByteCode.__ishl:
						EmitLdc_I4(31);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shl);
						break;
					case NormalizedByteCode.__lshl:
						EmitLdc_I4(63);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shl);
						break;
					case NormalizedByteCode.__iushr:
						EmitLdc_I4(31);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shr_Un);
						break;
					case NormalizedByteCode.__lushr:
						EmitLdc_I4(63);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shr_Un);
						break;
					case NormalizedByteCode.__ishr:
						EmitLdc_I4(31);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shr);
						break;
					case NormalizedByteCode.__lshr:
						EmitLdc_I4(63);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shr);
						break;
					case NormalizedByteCode.__swap:
					{
						DupHelper dh = new DupHelper(ilGenerator, 2);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.Store(0);
						dh.Store(1);
						dh.Load(0);
						dh.Load(1);
						break;
					}
					case NormalizedByteCode.__dup:
						// if the TOS contains a "new" object, it isn't really there, so we don't dup it
						if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
						{
							ilGenerator.Emit(OpCodes.Dup);
						}
						break;
					case NormalizedByteCode.__dup2:
					{
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						if(type1.IsWidePrimitive)
						{
							ilGenerator.Emit(OpCodes.Dup);
						}
						else
						{
							DupHelper dh = new DupHelper(ilGenerator, 2);
							dh.SetType(0, type1);
							dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
							dh.Store(0);
							dh.Store(1);
							dh.Load(1);
							dh.Load(0);
							dh.Load(1);
							dh.Load(0);
						}
						break;
					}
					case NormalizedByteCode.__dup_x1:
					{
						DupHelper dh = new DupHelper(ilGenerator, 2);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.Store(0);
						dh.Store(1);
						dh.Load(0);
						dh.Load(1);
						dh.Load(0);
						break;
					}
					case NormalizedByteCode.__dup2_x1:
					{
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						if(type1.IsWidePrimitive)
						{
							DupHelper dh = new DupHelper(ilGenerator, 2);
							dh.SetType(0, type1);
							dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
							dh.Store(0);
							dh.Store(1);
							dh.Load(0);
							dh.Load(1);
							dh.Load(0);
						}
						else
						{
							DupHelper dh = new DupHelper(ilGenerator, 3);
							dh.SetType(0, type1);
							dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
							dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
							dh.Store(0);
							dh.Store(1);
							dh.Store(2);
							dh.Load(1);
							dh.Load(0);
							dh.Load(2);
							dh.Load(1);
							dh.Load(0);
						}
						break;
					}
					case NormalizedByteCode.__dup2_x2:
					{
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						TypeWrapper type2 = ma.GetRawStackTypeWrapper(i, 1);
						if(type1.IsWidePrimitive)
						{
							if(type2.IsWidePrimitive)
							{
								// Form 4
								DupHelper dh = new DupHelper(ilGenerator, 2);
								dh.SetType(0, type1);
								dh.SetType(1, type2);
								dh.Store(0);
								dh.Store(1);
								dh.Load(0);
								dh.Load(1);
								dh.Load(0);
							}
							else
							{
								// Form 2
								DupHelper dh = new DupHelper(ilGenerator, 3);
								dh.SetType(0, type1);
								dh.SetType(1, type2);
								dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
								dh.Store(0);
								dh.Store(1);
								dh.Store(2);
								dh.Load(0);
								dh.Load(2);
								dh.Load(1);
								dh.Load(0);
							}
						}
						else
						{
							TypeWrapper type3 = ma.GetRawStackTypeWrapper(i, 2);
							if(type3.IsWidePrimitive)
							{
								// Form 3
								DupHelper dh = new DupHelper(ilGenerator, 3);
								dh.SetType(0, type1);
								dh.SetType(1, type2);
								dh.SetType(2, type3);
								dh.Store(0);
								dh.Store(1);
								dh.Store(2);
								dh.Load(1);
								dh.Load(0);
								dh.Load(2);
								dh.Load(1);
								dh.Load(0);
							}
							else
							{
								// Form 1
								DupHelper dh = new DupHelper(ilGenerator, 4);
								dh.SetType(0, type1);
								dh.SetType(1, type2);
								dh.SetType(2, type3);
								dh.SetType(3, ma.GetRawStackTypeWrapper(i, 3));
								dh.Store(0);
								dh.Store(1);
								dh.Store(2);
								dh.Store(3);
								dh.Load(1);
								dh.Load(0);
								dh.Load(3);
								dh.Load(2);
								dh.Load(1);
								dh.Load(0);
							}
						}
						break;
					}
					case NormalizedByteCode.__dup_x2:
					{
						DupHelper dh = new DupHelper(ilGenerator, 3);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
						dh.Store(0);
						dh.Store(1);
						dh.Store(2);
						dh.Load(0);
						dh.Load(2);
						dh.Load(1);
						dh.Load(0);
						break;
					}
					case NormalizedByteCode.__pop2:
					{
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						if(type1.IsWidePrimitive)
						{
							ilGenerator.Emit(OpCodes.Pop);
						}
						else
						{
							if(!VerifierTypeWrapper.IsNew(type1))
							{
								ilGenerator.Emit(OpCodes.Pop);
							}
							if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 1)))
							{
								ilGenerator.Emit(OpCodes.Pop);
							}
						}
						break;
					}
					case NormalizedByteCode.__pop:
						// if the TOS is a new object, it isn't really there, so we don't need to pop it
						if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
						{
							ilGenerator.Emit(OpCodes.Pop);
						}
						break;
					case NormalizedByteCode.__monitorenter:
						ilGenerator.Emit(OpCodes.Call, monitorEnterMethod);
						break;
					case NormalizedByteCode.__monitorexit:
						ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
						break;
					case NormalizedByteCode.__athrow:
						ilGenerator.Emit(OpCodes.Throw);
						break;
					case NormalizedByteCode.__lookupswitch:
						// TODO use OpCodes.Switch
						for(int j = 0; j < instr.Values.Length; j++)
						{
							ilGenerator.Emit(OpCodes.Dup);
							EmitLdc_I4(instr.Values[j]);
							Label label = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Bne_Un_S, label);
							ilGenerator.Emit(OpCodes.Pop);
							ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.TargetOffsets[j]));
							ilGenerator.MarkLabel(label);
						}
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.DefaultOffset));
						break;
					case NormalizedByteCode.__iinc:
						LoadLocal(instr);
						EmitLdc_I4(instr.Arg2);
						ilGenerator.Emit(OpCodes.Add);
						StoreLocal(instr);
						break;
					case NormalizedByteCode.__i2b:
						ilGenerator.Emit(OpCodes.Conv_I1);
						break;
					case NormalizedByteCode.__i2c:
						ilGenerator.Emit(OpCodes.Conv_U2);
						break;
					case NormalizedByteCode.__i2s:
						ilGenerator.Emit(OpCodes.Conv_I2);
						break;
					case NormalizedByteCode.__l2i:
						ilGenerator.Emit(OpCodes.Conv_I4);
						break;
					case NormalizedByteCode.__f2i:
						ilGenerator.Emit(OpCodes.Call, f2iMethod);
						break;
					case NormalizedByteCode.__d2i:
						ilGenerator.Emit(OpCodes.Call, d2iMethod);
						break;
					case NormalizedByteCode.__f2l:
						ilGenerator.Emit(OpCodes.Call, f2lMethod);
						break;
					case NormalizedByteCode.__d2l:
						ilGenerator.Emit(OpCodes.Call, d2lMethod);
						break;
					case NormalizedByteCode.__i2l:
						ilGenerator.Emit(OpCodes.Conv_I8);
						break;
					case NormalizedByteCode.__i2f:
					case NormalizedByteCode.__l2f:
					case NormalizedByteCode.__d2f:
						ilGenerator.Emit(OpCodes.Conv_R4);
						break;
					case NormalizedByteCode.__i2d:
					case NormalizedByteCode.__l2d:
					case NormalizedByteCode.__f2d:
						ilGenerator.Emit(OpCodes.Conv_R8);
						break;
					case NormalizedByteCode.__jsr:
					{
						int index = FindPcIndex(instr.PC + instr.Arg1);
						int[] callsites = ma.GetCallSites(index);
						for(int j = 0; j < callsites.Length; j++)
						{
							if(callsites[j] == i)
							{
								EmitLdc_I4(j);
								break;
							}
						}
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.Arg1));
						break;
					}
					case NormalizedByteCode.__ret:
					{
						// NOTE using a OpCodes.Switch here is not efficient, because 99 out of a 100 cases
						// there are either one or two call sites.
						int subid = ((VerifierTypeWrapper)ma.GetLocalTypeWrapper(i, instr.Arg1)).Index;
						int[] callsites = ma.GetCallSites(subid);
						for(int j = 0; j < callsites.Length - 1; j++)
						{
							LoadLocal(instr);
							EmitLdc_I4(j);
							ilGenerator.Emit(OpCodes.Beq, block.GetLabel(m.Instructions[callsites[j] + 1].PC));
						}
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(m.Instructions[callsites[callsites.Length - 1] + 1].PC));
						break;
					}
					case NormalizedByteCode.__nop:
						ilGenerator.Emit(OpCodes.Nop);
						break;
					default:
						throw new NotImplementedException(instr.NormalizedOpCode.ToString());
				}
				// mark next instruction as inuse
				switch(instr.NormalizedOpCode)
				{
					case NormalizedByteCode.__lookupswitch:
					case NormalizedByteCode.__goto:
					case NormalizedByteCode.__jsr:
					case NormalizedByteCode.__ret:
					case NormalizedByteCode.__ireturn:
					case NormalizedByteCode.__lreturn:
					case NormalizedByteCode.__freturn:
					case NormalizedByteCode.__dreturn:
					case NormalizedByteCode.__areturn:
					case NormalizedByteCode.__return:
					case NormalizedByteCode.__athrow:
						instructionIsForwardReachable = false;
						break;
					default:
						instructionIsForwardReachable = true;
						Debug.Assert(ma.IsReachable(i + 1));
						// don't fall through end of try block
						if(m.Instructions[i + 1].PC == block.End)
						{
							// TODO instead of emitting a branch to the leave stub, it would be more efficient to put the leave stub here
							ilGenerator.Emit(OpCodes.Br, block.GetLabel(m.Instructions[i + 1].PC));
						}
						break;
				}
			}
			catch(EmitException x)
			{
				x.Emit(ilGenerator, m.Method);
			}
		}
	}

	private void EmitLdc_I4(int v)
	{
		switch(v)
		{
			case -1:
				ilGenerator.Emit(OpCodes.Ldc_I4_M1);
				break;
			case 0:
				ilGenerator.Emit(OpCodes.Ldc_I4_0);
				break;
			case 1:
				ilGenerator.Emit(OpCodes.Ldc_I4_1);
				break;
			case 2:
				ilGenerator.Emit(OpCodes.Ldc_I4_2);
				break;
			case 3:
				ilGenerator.Emit(OpCodes.Ldc_I4_3);
				break;
			case 4:
				ilGenerator.Emit(OpCodes.Ldc_I4_4);
				break;
			case 5:
				ilGenerator.Emit(OpCodes.Ldc_I4_5);
				break;
			case 6:
				ilGenerator.Emit(OpCodes.Ldc_I4_6);
				break;
			case 7:
				ilGenerator.Emit(OpCodes.Ldc_I4_7);
				break;
			case 8:
				ilGenerator.Emit(OpCodes.Ldc_I4_8);
				break;
			default:
				if(v >= -128 && v <= 127)
				{
					ilGenerator.Emit(OpCodes.Ldc_I4_S, (sbyte)v);
				}
				else
				{
					ilGenerator.Emit(OpCodes.Ldc_I4, v);
				}
				break;
		}
	}

	// NOTE despite its name this also handles value type args
	private void CastInterfaceArgs(TypeWrapper[] args, int instructionIndex, bool instanceMethod, bool checkThisForNull)
	{
		bool needsCast = checkThisForNull;

		if(!needsCast)
		{
			for(int i = 0; i < args.Length; i++)
			{
				if(args[i].IsUnloadable)
				{
					// nothing to do, callee will (eventually) do the cast
				}
				else if(args[i].IsGhost)
				{
					needsCast = true;
					break;
				}
				else if(args[i].IsInterfaceOrInterfaceArray)
				{
					TypeWrapper tw = ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i);
					if(!tw.IsUnloadable && !tw.IsAssignableTo(args[i]))
					{
						needsCast = true;
						break;
					}
				}
				else if(args[i].IsNonPrimitiveValueType)
				{
					needsCast = true;
					break;
				}
				// if the stack contains an unloadable, we might need to cast it
				// (e.g. if the argument type is a base class that is loadable)
				if(ma.GetRawStackTypeWrapper(instructionIndex, i).IsUnloadable)
				{
					needsCast = true;
					break;
				}
			}
		}

		if(needsCast)
		{
			// OPTIMIZE if the first n arguments don't need a cast, they can be left on the stack
			DupHelper dh = new DupHelper(ilGenerator, args.Length);
			for(int i = 0; i < args.Length; i++)
			{
				TypeWrapper tw = ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i);
				if(tw != VerifierTypeWrapper.UninitializedThis)
				{
					tw = args[i];
				}
				dh.SetType(i, tw);
			}
			for(int i = args.Length - 1; i >= 0; i--)
			{
				if(!args[i].IsUnloadable)
				{
					TypeWrapper tw = ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i);
					if(tw.IsUnloadable || (args[i].IsInterfaceOrInterfaceArray && !tw.IsAssignableTo(args[i])))
					{
						// TODO ideally, instead of an InvalidCastException, the castclass should throw a IncompatibleClassChangeError
						ilGenerator.Emit(OpCodes.Castclass, args[i].TypeAsTBD);
					}
				}
				dh.Store(i);
			}
			if(checkThisForNull)
			{
				dh.Load(0);
				EmitHelper.NullCheck(ilGenerator);
			}
			for(int i = 0; i < args.Length; i++)
			{
				if(!args[i].IsUnloadable && args[i].IsGhost)
				{
					LocalBuilder local = ilGenerator.DeclareLocal(args[i].TypeAsParameterType);
					ilGenerator.Emit(OpCodes.Ldloca, local);
					dh.Load(i);
					ilGenerator.Emit(OpCodes.Stfld, args[i].GhostRefField);
					ilGenerator.Emit(OpCodes.Ldloca, local);
					// NOTE when the this argument is a value type, we need the address on the stack instead of the value
					if(i != 0 || !instanceMethod)
					{
						ilGenerator.Emit(OpCodes.Ldobj, args[i].TypeAsParameterType);
					}
				}
				else
				{
					dh.Load(i);
					if(!args[i].IsUnloadable)
					{
						if(args[i].IsNonPrimitiveValueType)
						{
							if(i != 0 || !instanceMethod)
							{
								args[i].EmitUnbox(ilGenerator);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Unbox, args[i].TypeAsTBD);
							}
						}
						else if(ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i).IsUnloadable)
						{
							ilGenerator.Emit(OpCodes.Castclass, args[i].TypeAsParameterType);
						}
					}
				}
			}
		}
	}

	private void GetPutField(Instruction instr, int i)
	{
		NormalizedByteCode bytecode = instr.NormalizedOpCode;
		ClassFile.ConstantPoolItemFieldref cpi = m.Method.ClassFile.GetFieldref(instr.Arg1);
		bool write = (bytecode == NormalizedByteCode.__putfield || bytecode == NormalizedByteCode.__putstatic);
		TypeWrapper wrapper = cpi.GetClassType(classLoader);
		if(wrapper.IsUnloadable)
		{
			TypeWrapper fieldTypeWrapper = cpi.GetFieldType(classLoader);
			if(write && !fieldTypeWrapper.IsUnloadable && fieldTypeWrapper.IsPrimitive)
			{
				ilGenerator.Emit(OpCodes.Box, fieldTypeWrapper.TypeAsTBD);
			}
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Name);
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Signature);
			ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
			ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
			switch(bytecode)
			{
				case NormalizedByteCode.__getfield:
					Profiler.Count("EmitDynamicGetfield");
					ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetfield"));
					EmitReturnTypeConversion(ilGenerator, fieldTypeWrapper);
					break;
				case NormalizedByteCode.__putfield:
					Profiler.Count("EmitDynamicPutfield");
					ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicPutfield"));
					break;
				case NormalizedByteCode.__getstatic:
					Profiler.Count("EmitDynamicGetstatic");
					ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetstatic"));
					EmitReturnTypeConversion(ilGenerator, fieldTypeWrapper);
					break;
				case NormalizedByteCode.__putstatic:
					Profiler.Count("EmitDynamicPutstatic");
					ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicPutstatic"));
					break;
			}
			return;
		}
		else
		{
			if(!wrapper.IsAccessibleFrom(clazz))
			{
				throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
			}
			TypeWrapper thisType = null;
			if(bytecode == NormalizedByteCode.__getfield)
			{
				thisType = SigTypeToClassName(ma.GetRawStackTypeWrapper(i, 0), cpi.GetClassType(classLoader));
			}
			else if(bytecode == NormalizedByteCode.__putfield)
			{
				thisType = SigTypeToClassName(ma.GetRawStackTypeWrapper(i, 1), cpi.GetClassType(classLoader));
			}
			bool isStatic = (bytecode == NormalizedByteCode.__putstatic || bytecode == NormalizedByteCode.__getstatic);
			FieldWrapper field = wrapper.GetFieldWrapper(cpi.Name, cpi.GetFieldType(classLoader));
			if(field != null)
			{
				if(field.IsStatic == isStatic)
				{
					// NOTE this access check is duplicated in ByteCodeHelper.GetFieldWrapper
					if(field.IsPublic ||
						(field.IsProtected && (isStatic ? clazz.IsSubTypeOf(field.DeclaringType) : thisType.IsSubTypeOf(clazz))) ||
						(field.IsPrivate && clazz == field.DeclaringType) ||
						(!(field.IsPublic || field.IsPrivate) && clazz.IsInSamePackageAs(field.DeclaringType)))
					{
						// are we trying to mutate a final field? (they are read-only from outside of the defining class)
						if(write && field.IsFinal && (isStatic ? clazz != wrapper : clazz != thisType))
						{
							throw new IllegalAccessError("Field " + field.DeclaringType.Name + "." + field.Name + " is final");
						}
						else
						{
							if(!write)
							{
								field.EmitGet.Emit(ilGenerator);
								return;
							}
							else
							{
								TypeWrapper tw = field.FieldTypeWrapper;
								TypeWrapper val = ma.GetRawStackTypeWrapper(i, 0);
								if(!tw.IsUnloadable && (val.IsUnloadable || (tw.IsInterfaceOrInterfaceArray && !tw.IsGhost && !val.IsAssignableTo(tw))))
								{
									ilGenerator.Emit(OpCodes.Castclass, tw.TypeAsTBD);
								}
								field.EmitSet.Emit(ilGenerator);
								return;
							}
						}
					}
					else
					{
						throw new IllegalAccessError("Try to access field " + field.DeclaringType.Name + "." + field.Name + " from class " + clazz.Name);
					}
				}
				else
				{
					throw new IncompatibleClassChangeError("Static field access to non-static field (or v.v.)");
				}
			}
			else
			{
				throw new NoSuchFieldError(cpi.Class + "." + cpi.Name);
			}
		}
	}

	private static MethodWrapper GetInterfaceMethod(TypeWrapper wrapper, MethodDescriptor md)
	{
		MethodWrapper method = wrapper.GetMethodWrapper(md, false);
		if(method != null)
		{
			return method;
		}
		TypeWrapper[] interfaces = wrapper.Interfaces;
		for(int i = 0; i < interfaces.Length; i++)
		{
			method = GetInterfaceMethod(interfaces[i], md);
			if(method != null)
			{
				return method;
			}
		}
		return null;
	}

	private class DynamicInvokeEmitter : CodeEmitter
	{
		private ClassLoaderWrapper classLoader;
		private TypeWrapper wrapper;
		private ClassFile.ConstantPoolItemFMI cpi;
		private MethodInfo helperMethod;
		private TypeWrapper retTypeWrapper;

		internal DynamicInvokeEmitter(ClassLoaderWrapper classLoader, TypeWrapper wrapper, ClassFile.ConstantPoolItemFMI cpi, TypeWrapper retTypeWrapper, MethodInfo helperMethod)
		{
			this.classLoader = classLoader;
			this.wrapper = wrapper;
			this.cpi = cpi;
			this.retTypeWrapper = retTypeWrapper;
			this.helperMethod = helperMethod;
		}

		internal override void Emit(ILGenerator ilGenerator)
		{
			Profiler.Count("EmitDynamicInvokeEmitter");
			TypeWrapper[] args = cpi.GetArgTypes(classLoader);
			LocalBuilder argarray = ilGenerator.DeclareLocal(typeof(object[]));
				LocalBuilder val = ilGenerator.DeclareLocal(typeof(object));
			ilGenerator.Emit(OpCodes.Ldc_I4, args.Length);
			ilGenerator.Emit(OpCodes.Newarr, typeof(object));
			ilGenerator.Emit(OpCodes.Stloc, argarray);
			for(int i = args.Length - 1; i >= 0; i--)
			{
				if(args[i].IsPrimitive)
				{
					ilGenerator.Emit(OpCodes.Box, args[i].TypeAsTBD);
				}
				ilGenerator.Emit(OpCodes.Stloc, val);
				ilGenerator.Emit(OpCodes.Ldloc, argarray);
				ilGenerator.Emit(OpCodes.Ldc_I4, i);
				ilGenerator.Emit(OpCodes.Ldloc, val);
				ilGenerator.Emit(OpCodes.Stelem_Ref);
			}
			ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Class);
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Name);
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Signature);
			ilGenerator.Emit(OpCodes.Ldloc, argarray);
			ilGenerator.Emit(OpCodes.Call, helperMethod);
			EmitReturnTypeConversion(ilGenerator, retTypeWrapper);
		}
	}

	private static void EmitReturnTypeConversion(ILGenerator ilgen, TypeWrapper typeWrapper)
	{
		if(typeWrapper.IsUnloadable)
		{
			// nothing to do for unloadables
		}
		else if(typeWrapper == PrimitiveTypeWrapper.VOID)
		{
			ilgen.Emit(OpCodes.Pop);
		}
		else if(typeWrapper.IsPrimitive)
		{
			// NOTE we don't need to use TypeWrapper.EmitUnbox, because the return value cannot be null
			ilgen.Emit(OpCodes.Unbox, typeWrapper.TypeAsTBD);
			ilgen.Emit(OpCodes.Ldobj, typeWrapper.TypeAsTBD);
		}
		else
		{
			ilgen.Emit(OpCodes.Castclass, typeWrapper.TypeAsTBD);
		}
	}

	private void GetMethodCallEmitter(ClassFile.ConstantPoolItemFMI cpi, TypeWrapper thisType, NormalizedByteCode invoke, out CodeEmitter emitNewobj, out CodeEmitter emitCall, out CodeEmitter emitCallvirt)
	{
		TypeWrapper wrapper = cpi.GetClassType(classLoader);
		if(wrapper.IsUnloadable || (thisType != null && thisType.IsUnloadable))
		{
			emitNewobj = new DynamicInvokeEmitter(classLoader, clazz, cpi, cpi.GetClassType(classLoader), typeof(ByteCodeHelper).GetMethod("DynamicInvokeSpecialNew"));
			if(invoke == NormalizedByteCode.__invokestatic)
			{
				emitCall = new DynamicInvokeEmitter(classLoader, clazz, cpi, cpi.GetRetType(classLoader), typeof(ByteCodeHelper).GetMethod("DynamicInvokestatic"));
			}
			else
			{
				// NOTE this shouldn't happen, because invokespecial is only used to call
				// methods in this class or its base classes and those are obviously always loadable.
				emitCall = CodeEmitter.InternalError;
			}
			emitCallvirt = new DynamicInvokeEmitter(classLoader, clazz, cpi, cpi.GetRetType(classLoader), typeof(ByteCodeHelper).GetMethod("DynamicInvokevirtual"));
			return;
		}
		else
		{
			if(!wrapper.IsAccessibleFrom(clazz))
			{
				throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
			}
			else if(wrapper.IsInterface != (invoke == NormalizedByteCode.__invokeinterface))
			{
				throw new IncompatibleClassChangeError("invokeinterface on non-interface");
			}
			else
			{
				if(invoke == NormalizedByteCode.__invokespecial && m.Method.ClassFile.IsSuper && thisType != wrapper && thisType.IsSubTypeOf(wrapper))
				{
					wrapper = thisType.BaseTypeWrapper;
				}
				MethodDescriptor md = new MethodDescriptor(classLoader, cpi);
				MethodWrapper method = null;
				if(invoke == NormalizedByteCode.__invokeinterface)
				{
					method = GetInterfaceMethod(wrapper, md);
					// NOTE vmspec 5.4.3.4 clearly states that an interfacemethod may also refer to a method in Object
					if(method == null)
					{
						method = java_lang_Object.GetMethodWrapper(md, false);
					}
				}
				else
				{
					method = wrapper.GetMethodWrapper(md, md.Name != "<init>");
					// if the method is not found, we might have to simulate a Miranda method
					if(method == null && invoke == NormalizedByteCode.__invokevirtual)
					{
						method = GetInterfaceMethod(wrapper, md);
					}
				}
				if(method != null)
				{
					if(method.IsStatic == (invoke == NormalizedByteCode.__invokestatic))
					{
						if(method.IsAbstract && invoke == NormalizedByteCode.__invokespecial)
						{
							throw new AbstractMethodError(cpi.Class + "." + cpi.Name + cpi.Signature);
						}
						else if(method.IsPublic ||
							(method.IsProtected && (method.IsStatic ? clazz.IsSubTypeOf(method.DeclaringType) : thisType.IsSubTypeOf(clazz))) ||
							(method.IsPrivate && clazz == method.DeclaringType) ||
							(!(method.IsPublic || method.IsPrivate) && clazz.IsInSamePackageAs(method.DeclaringType)))
						{
							emitNewobj = method.EmitNewobj;
							emitCall = method.EmitCall;
							emitCallvirt = method.EmitCallvirt;
							return;
						}
						else
						{
							// HACK special case for incorrect invocation of Object.clone(), because this could mean
							// we're calling clone() on an array
							// (bug in javac, see http://developer.java.sun.com/developer/bugParade/bugs/4329886.html)
							if(wrapper == java_lang_Object && thisType.IsArray && cpi.Name == "clone")
							{
								method = thisType.GetMethodWrapper(new MethodDescriptor(classLoader, cpi), false);
								if(method != null && method.IsPublic)
								{
									emitNewobj = method.EmitNewobj;
									emitCall = method.EmitCall;
									emitCallvirt = method.EmitCallvirt;
									return;
								}
							}
							throw new IllegalAccessError("Try to access method " + method.DeclaringType.Name + "." + cpi.Name + cpi.Signature + " from class " + clazz.Name);
						}
					}
					else
					{
						throw new IncompatibleClassChangeError("static call to non-static method (or v.v.)");
					}
				}
				else
				{
					throw new NoSuchMethodError(cpi.Class + "." + cpi.Name + cpi.Signature);
				}
			}
		}
	}

	// TODO this method should have a better name
	private TypeWrapper SigTypeToClassName(TypeWrapper type, TypeWrapper nullType)
	{
		if(type == VerifierTypeWrapper.UninitializedThis)
		{
			return clazz;
		}
		else if(VerifierTypeWrapper.IsNew(type))
		{
			return ((VerifierTypeWrapper)type).UnderlyingType;
		}
		else if(type == VerifierTypeWrapper.Null)
		{
			return nullType;
		}
		else
		{
			return type;
		}
	}

	private int FindPcIndex(int target)
	{
		return m.PcIndexMap[target];
	}

	private LocalVar LoadLocal(ClassFile.Method.Instruction instr)
	{
		LocalVar v = ma.GetLocalVar(FindPcIndex(instr.PC));
		if(v.isArg)
		{
			int i = m.ArgMap[instr.NormalizedArg1];
			switch(i)
			{
				case 0:
					ilGenerator.Emit(OpCodes.Ldarg_0);
					break;
				case 1:
					ilGenerator.Emit(OpCodes.Ldarg_1);
					break;
				case 2:
					ilGenerator.Emit(OpCodes.Ldarg_2);
					break;
				case 3:
					ilGenerator.Emit(OpCodes.Ldarg_3);
					break;
				default:
					if(i < 256)
					{
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)i);
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldarg, (ushort)i);
					}
					break;
			}
		}
		else if(v.type == VerifierTypeWrapper.Null)
		{
			ilGenerator.Emit(OpCodes.Ldnull);
		}
		else
		{
			if(v.builder == null)
			{
				v.builder = ilGenerator.DeclareLocal(v.type.TypeAsLocalOrStackType);
				if(JVM.Debug && v.name != null)
				{
					v.builder.SetLocalSymInfo(v.name);
				}
			}
			ilGenerator.Emit(OpCodes.Ldloc, v.builder);
		}
		return v;
	}

	private void StoreLocal(ClassFile.Method.Instruction instr)
	{
		LocalVar v = ma.GetLocalVar(FindPcIndex(instr.PC));
		if(v == null)
		{
			// dead store
			ilGenerator.Emit(OpCodes.Pop);
		}
		else if(v.isArg)
		{
			int i = m.ArgMap[instr.NormalizedArg1];
			if(i < 256)
			{
				ilGenerator.Emit(OpCodes.Starg_S, (byte)i);
			}
			else
			{
				ilGenerator.Emit(OpCodes.Starg, (ushort)i);
			}
		}
		else if(v.type == VerifierTypeWrapper.Null)
		{
			ilGenerator.Emit(OpCodes.Pop);
		}
		else
		{
			if(v.builder == null)
			{
				v.builder = ilGenerator.DeclareLocal(v.type.TypeAsLocalOrStackType);
				if(JVM.Debug && v.name != null)
				{
					v.builder.SetLocalSymInfo(v.name);
				}
			}
			ilGenerator.Emit(OpCodes.Stloc, v.builder);
		}
	}

	private bool IsUnloadable(ClassFile.ConstantPoolItemFMI cpi)
	{
		if(cpi.GetClassType(classLoader).IsUnloadable || cpi.GetRetType(classLoader).IsUnloadable)
		{
			return true;
		}
		TypeWrapper[] args = cpi.GetArgTypes(classLoader);
		for(int i = 0; i < args.Length; i++)
		{
			if(args[i].IsUnloadable)
			{
				return true;
			}
		}
		return false;
	}
}
@


1.44
log
@*** empty log message ***
@
text
@@


1.43
log
@*** empty log message ***
@
text
@d170 4
a174 11
		//		Console.WriteLine(m.Method.ClassFile.Name + "." + m.Method.Name + m.Method.Signature);
		//		Console.WriteLine("before processing:");
		//		foreach(ExceptionTableEntry e in ar)
		//		{
		//			Console.WriteLine("{0} to {1} handler {2}", e.start_pc, e.end_pc, e.handler_pc);
		//		}
		// TODO it's very bad practice to mess with ExceptionTableEntrys that are owned by the Method, yet we
		// do that here, should be changed to use our own ETE class (which should also contain the ordinal, instead
		// of the one in ClassFile.cs)
		// OPTIMIZE there must be a more efficient algorithm to do this...
		// TODO we should ensure that exception blocks and handlers start and end at instruction boundaries (note: wide prefix)
d179 1
a179 1
				for(int j = i + 1; j < ar.Count; j++)
d182 1
a182 1
					if(ei.start_pc <= ej.start_pc && ei.end_pc > ej.start_pc)
d184 1
a184 1
						// try1.j
d203 2
a204 1
						else if(ej.end_pc < ei.end_pc)	// try2.j
d284 1
a284 1
								if(targetPC > ei.start_pc && targetPC < ei.end_pc)
d317 1
a317 1
							if(targetPC > ei.start_pc && targetPC < ei.end_pc)
d341 1
a341 1
				if(ej.handler_pc > ei.start_pc && ej.handler_pc < ei.end_pc)
d346 1
a346 1
					en.start_pc = (ushort)ej.handler_pc;
d348 1
a348 1
					ei.end_pc = (ushort)ej.handler_pc;
@


1.42
log
@*** empty log message ***
@
text
@d1121 6
d1136 1
a1136 1
			if(!instructionIsForwardReachable && ma.IsReachable(i))
d1159 2
a1204 6
			if(!ma.IsReachable(i))
			{
				// skip any unreachable instructions
				continue;
			}

@


1.41
log
@*** empty log message ***
@
text
@d541 1
d693 1
d729 3
a731 1
			c.Compile(new Block(c, 0, int.MaxValue, -1, exits));
d736 1
a736 4
			foreach(ReturnCookie rc in exits)
			{
				rc.EmitRet(ilGenerator);
			}
d740 7
a746 2
			c.Compile(new Block(c, 0, int.MaxValue, -1, null));
		}
d756 1
d758 1
a758 1
		private int exceptionIndex;
d761 1
a761 1
		internal Block(Compiler compiler, int begin, int end, int exceptionIndex, ArrayList exits)
d769 1
d789 11
d836 5
d863 1
a863 1
			for(int i = 0; i < exits.Count; i++)
d865 1
a865 3
				object exit = exits[i];
				BranchCookie bc = exit as BranchCookie;
				if(bc != null && bc.ContentOnStack)
d867 3
a869 4
					bc.ContentOnStack = false;
					ilgen.MarkLabel(bc.Stub);
					int stack = bc.dh.Count;
					for(int n = 0; n < stack; n++)
d871 16
a886 1
						bc.dh.Store(n);
a887 2
					bc.Stub = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Leave, bc.Stub);
d894 1
a894 1
			for(int i = 0; i < exits.Count; i++)
d896 1
a896 3
				object exit = exits[i];
				ReturnCookie rc = exit as ReturnCookie;
				if(rc != null)
d898 3
a900 1
					if(newBlock.exits == null)
d902 8
a909 1
						rc.EmitRet(ilgen);
d913 2
a914 12
						newBlock.exits.Add(rc);
					}
				}
				else
				{
					BranchCookie bc = exit as BranchCookie;
					if(bc != null)
					{
						Debug.Assert(!bc.ContentOnStack);
						// if the target is within the new block, we handle it, otherwise we
						// defer the cookie to our caller
						if(newBlock.IsInRange(bc.TargetPC))
d916 15
a930 4
							bc.ContentOnStack = true;
							ilgen.MarkLabel(bc.Stub);
							int stack = bc.dh.Count;
							for(int n = stack - 1; n >= 0; n--)
d932 1
a932 1
								bc.dh.Load(n);
a933 5
							ilgen.Emit(OpCodes.Br, newBlock.GetLabel(bc.TargetPC));
						}
						else
						{
							newBlock.exits.Add(bc);
d949 1
a949 1
				return exits != null;
d996 1
d1086 1
d1121 3
d1128 23
d1175 1
a1175 1
				block = new Block(this, exceptions[exceptionIndex].start_pc, exceptions[exceptionIndex].end_pc, exceptionIndex, new ArrayList());
d1266 1
d1659 1
d1695 1
d1720 1
d1802 1
d1872 1
d2532 1
d2535 1
d2734 1
d2739 1
d2743 1
d2748 1
d2861 1
@


1.40
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002 Jeroen Frijters
d28 1
d31 1
a33 29
class ExceptionSorter : IComparer
{
	public int Compare(object x, object y)
	{
		ExceptionTableEntry e1 = (ExceptionTableEntry)x;
		ExceptionTableEntry e2 = (ExceptionTableEntry)y;
		if(e1.start_pc < e2.start_pc)
		{
			return -1;
		}
		if(e1.start_pc == e2.start_pc)
		{
			if(e1.end_pc == e2.end_pc)
			{
				if(e1.ordinal > e2.ordinal)
				{
					return -1;
				}
				return 1;
			}
			if(e1.end_pc > e2.end_pc)
			{
				return -1;
			}
		}
		return 1;
	}
}

d39 15
a53 6
	private static MethodInfo getTypeFromHandleMethod = typeof(Type).GetMethod("GetTypeFromHandle");
	private static MethodInfo getClassFromTypeMethod = typeof(NativeCode.java.lang.VMClass).GetMethod("getClassFromType");
	private static MethodInfo multiANewArrayMethod = typeof(ByteCodeHelper).GetMethod("multianewarray");
	private static MethodInfo monitorEnterMethod = typeof(System.Threading.Monitor).GetMethod("Enter");
	private static MethodInfo monitorExitMethod = typeof(System.Threading.Monitor).GetMethod("Exit");
	private static MethodInfo objectToStringMethod = typeof(object).GetMethod("ToString");
d63 1
a63 1
	private ClassFile.Method.ExceptionTableEntry[] exceptions;
d68 15
d93 30
a122 1
	private Compiler(TypeWrapper clazz, ClassFile.Method.Code m, ILGenerator ilGenerator, ClassLoaderWrapper classLoader)
d128 9
a136 1
		if(JVM.Debug)
d138 1
a138 2
			string sourcefile = m.Method.ClassFile.SourceFileAttribute;
			if(sourcefile != null)
d140 27
a166 1
				this.symboldocument = classLoader.ModuleBuilder.DefineDocument(sourcefile, SymLanguageType.Java, Guid.Empty, SymDocumentType.Text);
d169 1
a169 3
		Profiler.Enter("MethodAnalyzer");
		ma = new MethodAnalyzer(clazz, m, classLoader);
		Profiler.Leave("MethodAnalyzer");
d286 16
a301 6
							// TODO if the switch branches out of the try block, that should be handled too
							//							for(int j = 0; j < instr.Values.Length; j++)
							//							{
							//								state[FindPcIndex(instr.PC + instr.TargetOffsets[j])] += s;
							//							}
							//							state[FindPcIndex(instr.PC + instr.DefaultOffset)] += s;
d651 1
a651 1
	internal static void Compile(TypeWrapper clazz, ClassFile.Method m, ILGenerator ilGenerator, ClassLoaderWrapper classLoader)
d653 34
d703 1
a703 1
			c = new Compiler(clazz, m.CodeAttribute, ilGenerator, classLoader);
d727 1
a727 1
			c.Compile(0, 0, exits);
d739 1
a739 1
			c.Compile(0, 0, null);
d744 1
a744 1
	private void Compile(int initialInstructionIndex, int exceptionIndex, ArrayList exits)
d746 84
a829 8
		int rangeBegin;
		int rangeEnd;		// NOTE points past the last instruction in the range
		if(exceptionIndex == 0)
		{
			rangeBegin = 0;
			// because the last instruction in the code array is always the additional __nop, put there
			// by our classfile reader, this works
			rangeEnd = m.Instructions[m.Instructions.Length - 1].PC;
d831 2
a832 1
		else
d834 1
a834 2
			rangeBegin = exceptions[exceptionIndex - 1].start_pc;
			rangeEnd = exceptions[exceptionIndex - 1].end_pc;
d836 2
a837 9
		object[] labels = new object[m.Instructions.Length];
		// used to track instructions that are 'live'
		bool[] inuse = new bool[m.Instructions.Length];
		// used to track instructions that have been compiled
		bool[] done = new bool[m.Instructions.Length];
		bool quit = false;
		inuse[initialInstructionIndex] = true;
		Instruction[] code = m.Instructions;
		while(!quit)
d839 1
a839 2
			quit = true;
			for(int i = 0; i < code.Length; i++)
d841 3
a843 2
			restart:
				if(!inuse[i] || done[i])
d845 9
a853 1
					continue;
d855 2
a856 3
				quit = false;
				done[i] = true;
				Instruction instr = code[i];
d858 18
a875 1
				if(symboldocument != null)
d877 2
a878 3
					// TODO this needs to be done better
					ClassFile.Method.LineNumberTableEntry[] table = m.LineNumberTableAttribute;
					if(table != null)
d880 9
a888 3
						for(int j = 0; j < table.Length; j++)
						{
							if(table[j].start_pc == instr.PC && table[j].line_number != 0)
d890 1
a890 11
								// HACK this nop is a workaround for a bizarre bug in System.Diagnostics.StackTrace
								// that causes it to report the incorrect line number sometimes...
								// BUT, make sure we don't put a nop at the start of the method, because if there
								// is no line number information on the first instruction, VS.NET refuses to step into
								// the method.
								if(instr.PC > 0)
								{
									ilGenerator.Emit(OpCodes.Nop);
								}
								ilGenerator.MarkSequencePoint(symboldocument, table[j].line_number, 0, table[j].line_number + 1, 0);
								break;
d892 5
d900 28
a927 1
				if(true)
d929 21
a949 6
					// TODO for now, every instruction has an associated label, optimize this
					// NOTE labels are local to the current block, this is needed because the same JVM instruction
					// can actually be compiled into several CLR instruction (in the case of exception block boundaries,
					// each boundary has its own stack hoisting code).
					object label = labels[i];
					if(label == null)
d951 1
a951 2
						label = ilGenerator.DefineLabel();
						labels[i] = label;
d953 36
a988 1
					ilGenerator.MarkLabel((Label)label);
d991 12
a1002 2
				// handle the try block here
				for(int j = exceptionIndex; j < exceptions.Length; j++)
d1004 5
a1008 1
					if(exceptions[j].start_pc == instr.PC)
d1010 19
a1028 2
						int stackHeight = ma.GetStackHeight(i);
						if(stackHeight != 0)
d1030 1
a1030 3
							// TODO instead of creating new locals for each block, we should reuse them
							DupHelper dh = new DupHelper(ilGenerator, stackHeight);
							for(int k = 0; k < stackHeight; k++)
d1032 1
a1032 2
								dh.SetType(k, ma.GetRawStackTypeWrapper(i, k));
								dh.Store(k);
d1034 2
a1035 2
							ilGenerator.BeginExceptionBlock();
							for(int k = stackHeight - 1; k >= 0; k--)
d1037 1
a1037 1
								dh.Load(k);
d1039 13
d1055 4
a1058 1
							ilGenerator.BeginExceptionBlock();
d1060 1
a1060 3
						ArrayList newExits = new ArrayList();
						Compile(i, j + 1, newExits);
						for(int k = 0; k < newExits.Count; k++)
d1062 2
a1063 17
							object exit = newExits[k];
							BranchCookie bc = exit as BranchCookie;
							if(bc != null)
							{
								if(bc.ContentOnStack)
								{
									bc.ContentOnStack = false;
									ilGenerator.MarkLabel(bc.Stub);
									int stack = bc.dh.Count;
									for(int n = 0; n < stack; n++)
									{
										bc.dh.Store(n);
									}
									bc.Stub = ilGenerator.DefineLabel();
									ilGenerator.Emit(OpCodes.Leave, bc.Stub);
								}
							}
d1065 1
a1065 2
						TypeWrapper exceptionTypeWrapper;
						if(exceptions[j].catch_type == 0)
d1067 3
a1069 1
							exceptionTypeWrapper = java_lang_Throwable;
d1071 51
a1121 1
						else
d1123 4
a1126 1
							exceptionTypeWrapper = m.Method.ClassFile.GetConstantPoolClassType(exceptions[j].catch_type, classLoader);
d1128 52
a1179 3
						Type excType = exceptionTypeWrapper.TypeAsExceptionType;
						bool mapSafe = !exceptionTypeWrapper.IsUnloadable && !exceptionTypeWrapper.IsMapUnsafeException;
						if(true)
d1181 16
a1196 5
							if(mapSafe)
							{
								ilGenerator.BeginCatchBlock(excType);
							}
							else
d1198 2
a1199 37
								ilGenerator.BeginCatchBlock(typeof(Exception));
							}
							BranchCookie bc = new BranchCookie(ilGenerator, 1, exceptions[j].handler_pc);
							newExits.Add(bc);
							int handlerIndex = FindPcIndex(exceptions[j].handler_pc);
							Instruction handlerInstr = code[handlerIndex];
							bool unusedException = handlerInstr.NormalizedOpCode == NormalizedByteCode.__pop ||
									(handlerInstr.NormalizedOpCode == NormalizedByteCode.__astore &&
									ma.GetLocalVar(handlerIndex) == null);
							// special case for catch(Throwable) (and finally), that produces less code and
							// should be faster
							if(mapSafe || excType == typeof(Exception))
							{
								if(unusedException)
								{
									// we must still have an item on the stack, even though it isn't used!
									bc.dh.SetType(0, VerifierTypeWrapper.Null);
								}
								else
								{
									if(mapSafe)
									{
										ilGenerator.Emit(OpCodes.Dup);
									}
									mapExceptionFastMethod.Emit(ilGenerator);
									if(mapSafe)
									{
										ilGenerator.Emit(OpCodes.Pop);
									}
									bc.dh.SetType(0, exceptionTypeWrapper);
									bc.dh.Store(0);
								}
								ilGenerator.Emit(OpCodes.Leave, bc.Stub);
							}
							else
							{
								if(exceptionTypeWrapper.IsUnloadable)
d1202 2
a1203 3
									ilGenerator.Emit(OpCodes.Ldstr, exceptionTypeWrapper.Name);
									ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetTypeAsExceptionType"));
									mapExceptionMethod.Emit(ilGenerator);
d1207 1
a1207 1
									ilGenerator.Emit(OpCodes.Ldtoken, excType);
d1209 1
a1209 2
									mapExceptionMethod.Emit(ilGenerator);
									ilGenerator.Emit(OpCodes.Castclass, excType);
d1211 43
a1253 4
								if(unusedException)
								{
									// we must still have an item on the stack, even though it isn't used!
									bc.dh.SetType(0, VerifierTypeWrapper.Null);
d1255 1
a1255 11
								else
								{
									bc.dh.SetType(0, exceptionTypeWrapper);
									ilGenerator.Emit(OpCodes.Dup);
									bc.dh.Store(0);
								}
								Label rethrow = ilGenerator.DefineLabel();
								ilGenerator.Emit(OpCodes.Brfalse, rethrow);
								ilGenerator.Emit(OpCodes.Leave, bc.Stub);
								ilGenerator.MarkLabel(rethrow);
								ilGenerator.Emit(OpCodes.Rethrow);
a1256 1
							ilGenerator.EndExceptionBlock();
d1258 27
a1284 1
						for(int k = 0; k < newExits.Count; k++)
d1286 5
a1290 3
							object exit = newExits[k];
							ReturnCookie rc = exit as ReturnCookie;
							if(rc != null)
d1292 1
a1292 8
								if(exits == null)
								{
									rc.EmitRet(ilGenerator);
								}
								else
								{
									exits.Add(rc);
								}
d1296 1
a1296 22
								BranchCookie bc = exit as BranchCookie;
								if(bc != null)
								{
									System.Diagnostics.Debug.Assert(!bc.ContentOnStack);
									// if the target is within the current range, we handle it, otherwise we
									// defer the cookie to our caller
									if(rangeBegin <= bc.TargetPC && bc.TargetPC < rangeEnd)
									{
										bc.ContentOnStack = true;
										ilGenerator.MarkLabel(bc.Stub);
										int stack = bc.dh.Count;
										for(int n = stack - 1; n >= 0; n--)
										{
											bc.dh.Load(n);
										}
										ilGenerator.Emit(OpCodes.Br, GetLabel(labels, bc.TargetPC, inuse, rangeBegin, rangeEnd, exits));
									}
									else
									{
										exits.Add(bc);
									}
								}
d1298 1
a1299 3
						goto restart;
					}
				}
d1301 10
a1310 15
				try
				{
					switch(instr.NormalizedOpCode)
					{
						case NormalizedByteCode.__getstatic:
						case NormalizedByteCode.__putstatic:
						case NormalizedByteCode.__getfield:
						case NormalizedByteCode.__putfield:
							GetPutField(instr, i);
							break;
						case NormalizedByteCode.__aconst_null:
							ilGenerator.Emit(OpCodes.Ldnull);
							break;
						case NormalizedByteCode.__iconst:
						switch(instr.NormalizedArg1)
d1312 1
a1312 40
							case -1:
								ilGenerator.Emit(OpCodes.Ldc_I4_M1);
								break;
							case 0:
								ilGenerator.Emit(OpCodes.Ldc_I4_0);
								break;
							case 1:
								ilGenerator.Emit(OpCodes.Ldc_I4_1);
								break;
							case 2:
								ilGenerator.Emit(OpCodes.Ldc_I4_2);
								break;
							case 3:
								ilGenerator.Emit(OpCodes.Ldc_I4_3);
								break;
							case 4:
								ilGenerator.Emit(OpCodes.Ldc_I4_4);
								break;
							case 5:
								ilGenerator.Emit(OpCodes.Ldc_I4_5);
								break;
							case 6:
								ilGenerator.Emit(OpCodes.Ldc_I4_6);
								break;
							case 7:
								ilGenerator.Emit(OpCodes.Ldc_I4_7);
								break;
							case 8:
								ilGenerator.Emit(OpCodes.Ldc_I4_8);
								break;
							default:
								if(instr.NormalizedArg1 >= -128 && instr.NormalizedArg1 <= 127)
								{
									ilGenerator.Emit(OpCodes.Ldc_I4_S, (sbyte)instr.NormalizedArg1);
								}
								else
								{
									ilGenerator.Emit(OpCodes.Ldc_I4, instr.NormalizedArg1);
								}
								break;
d1314 1
a1314 23
							break;
						case NormalizedByteCode.__lconst_0:
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Conv_I8);
							break;
						case NormalizedByteCode.__lconst_1:
							ilGenerator.Emit(OpCodes.Ldc_I4_1);
							ilGenerator.Emit(OpCodes.Conv_I8);
							break;
						case NormalizedByteCode.__fconst_0:
						case NormalizedByteCode.__dconst_0:
							// floats are stored as native size on the stack, so both R4 and R8 are the same
							ilGenerator.Emit(OpCodes.Ldc_R4, 0.0f);
							break;
						case NormalizedByteCode.__fconst_1:
						case NormalizedByteCode.__dconst_1:
							// floats are stored as native size on the stack, so both R4 and R8 are the same
							ilGenerator.Emit(OpCodes.Ldc_R4, 1.0f);
							break;
						case NormalizedByteCode.__fconst_2:
							ilGenerator.Emit(OpCodes.Ldc_R4, 2.0f);
							break;
						case NormalizedByteCode.__ldc:
d1316 9
a1324 20
							ClassFile cf = instr.MethodCode.Method.ClassFile;
							int constant = instr.Arg1;
							switch(cf.GetConstantPoolConstantType(constant))
							{
								case ClassFile.ConstantType.Double:
									ilGenerator.Emit(OpCodes.Ldc_R8, cf.GetConstantPoolConstantDouble(constant));
									break;
								case ClassFile.ConstantType.Float:
									ilGenerator.Emit(OpCodes.Ldc_R4, cf.GetConstantPoolConstantFloat(constant));
									break;
								case ClassFile.ConstantType.Integer:
									ilGenerator.Emit(OpCodes.Ldc_I4, cf.GetConstantPoolConstantInteger(constant));
									break;
								case ClassFile.ConstantType.Long:
									ilGenerator.Emit(OpCodes.Ldc_I8, cf.GetConstantPoolConstantLong(constant));
									break;
								case ClassFile.ConstantType.String:
									ilGenerator.Emit(OpCodes.Ldstr, cf.GetConstantPoolConstantString(constant));
									break;
								case ClassFile.ConstantType.Class:
d1326 1
a1326 2
									TypeWrapper tw = cf.GetConstantPoolClassType(constant, classLoader);
									if(tw.IsUnloadable)
d1328 12
a1339 3
										ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
										ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
										ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicClassLiteral"));
d1341 4
a1344 1
									else
d1346 1
a1346 3
										ilGenerator.Emit(OpCodes.Ldtoken, tw.IsRemapped ? tw.TypeAsBaseType : tw.TypeAsTBD);
										ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
										ilGenerator.Emit(OpCodes.Call, getClassFromTypeMethod);
a1347 2
									java_lang_Class.EmitCheckcast(clazz, ilGenerator);
									break;
d1349 2
a1350 18
								default:
									throw new InvalidOperationException();
							}
							break;
						}
						case NormalizedByteCode.__invokestatic:
						{
							ClassFile.ConstantPoolItemFMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
							// HACK special case for calls to System.arraycopy, if the array arguments on the stack
							// are of a known array type, we can redirect to an optimized version of arraycopy.
							// TODO make sure that the java.lang.System we're referring to is in the bootstrap class loader
							if(cpi.Class == "java.lang.System" &&
								cpi.Name == "arraycopy" &&
								cpi.Signature == "(Ljava.lang.Object;ILjava.lang.Object;II)V")
							{
								TypeWrapper t1 = ma.GetRawStackTypeWrapper(i, 2);
								TypeWrapper t2 = ma.GetRawStackTypeWrapper(i, 4);
								if(t1.IsArray && t1 == t2)
d1352 4
a1355 1
									switch(t1.Name[1])
d1357 3
a1359 19
										case 'J':
										case 'D':
											ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_8"));
											break;
										case 'I':
										case 'F':
											ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_4"));
											break;
										case 'S':
										case 'C':
											ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_2"));
											break;
										case 'B':
										case 'Z':
											ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_1"));
											break;
										default:
											ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy"));
											break;
a1360 38
									break;
								}
							}
							CodeEmitter emitNewobj;
							CodeEmitter emitCall;
							CodeEmitter emitCallvirt;
							GetMethodCallEmitter(cpi, null, NormalizedByteCode.__invokestatic, out emitNewobj, out emitCall, out emitCallvirt);
							// if the stack values don't match the argument types (for interface argument types)
							// we must emit code to cast the stack value to the interface type
							CastInterfaceArgs(cpi.GetArgTypes(classLoader), i, false, false);
							emitCall.Emit(ilGenerator);
							break;
						}
						case NormalizedByteCode.__invokevirtual:
						case NormalizedByteCode.__invokeinterface:
						case NormalizedByteCode.__invokespecial:
						{
							ClassFile.ConstantPoolItemFMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
							int argcount = cpi.GetArgTypes(classLoader).Length;
							TypeWrapper type = ma.GetRawStackTypeWrapper(i, argcount);
							TypeWrapper thisType = SigTypeToClassName(type, cpi.GetClassType(classLoader));

							// if the stack values don't match the argument types (for interface argument types)
							// we must emit code to cast the stack value to the interface type
							if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>" && VerifierTypeWrapper.IsNew(type))
							{
								TypeWrapper[] args = cpi.GetArgTypes(classLoader);
								CastInterfaceArgs(args, i, false, false);
							}
							else
							{
								// the this reference is included in the argument list because it may also need to be cast
								TypeWrapper[] methodArgs = cpi.GetArgTypes(classLoader);
								TypeWrapper[] args = new TypeWrapper[methodArgs.Length + 1];
								methodArgs.CopyTo(args, 1);
								if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface)
								{
									args[0] = cpi.GetClassType(classLoader);
d1362 1
a1362 23
								else
								{
									args[0] = thisType;
								}
								CastInterfaceArgs(args, i, true, instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && type != VerifierTypeWrapper.UninitializedThis);
							}

							CodeEmitter emitNewobj = null;
							CodeEmitter emitCall = null;
							CodeEmitter emitCallvirt = null;
							CodeEmitter emit = null;
							GetMethodCallEmitter(cpi, thisType, instr.NormalizedOpCode, out emitNewobj, out emitCall, out emitCallvirt);
							if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
							{
								emit = emitCall;
							}
							else
							{
								emit = emitCallvirt;
							}
							if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>")
							{
								if(VerifierTypeWrapper.IsNew(type))
d1364 6
a1369 6
									// we have to construct a list of all the unitialized references to the object
									// we're about to create on the stack, so that we can reconstruct the stack after
									// the "newobj" instruction
									int trivcount = 0;
									bool nontrivial = false;
									bool[] stackfix = new bool[ma.GetStackHeight(i) - (argcount + 1)];
d1372 1
a1372 1
										if(ma.GetRawStackTypeWrapper(i, argcount + 1 + j) == type)
d1374 4
a1377 2
											stackfix[j] = true;
											if(trivcount == j)
d1379 2
a1380 1
												trivcount++;
d1382 1
a1382 1
											else
d1384 3
a1386 4
												// if there is other stuff on the stack between the new object
												// references, we need to do more work to construct the proper stack
												// layout after the newobj instruction
												nontrivial = true;
d1390 1
a1390 1
									for(int j = 0; !nontrivial && j < m.MaxLocals; j++)
d1392 1
a1392 1
										if(ma.GetLocalTypeWrapper(i, j) == type)
d1394 1
a1394 1
											nontrivial = true;
d1396 1
a1396 8
									}
									emitNewobj.Emit(ilGenerator);
									if(!thisType.IsUnloadable && thisType.IsSubTypeOf(java_lang_Throwable))
									{
										// HACK if the next instruction isn't an athrow, we need to
										// call fillInStackTrace, because the object might be used
										// to print out a stack trace without ever being thrown
										if(code[i + 1].NormalizedOpCode != NormalizedByteCode.__athrow)
d1398 1
a1398 3
											ilGenerator.Emit(OpCodes.Dup);
											fillInStackTraceMethod.Emit(ilGenerator);
											ilGenerator.Emit(OpCodes.Pop);
d1401 2
a1402 1
									if(nontrivial)
d1404 1
a1404 7
										// this could be done a little more efficiently, but since in practice this
										// code never runs (for code compiled from Java source) it doesn't
										// really matter
										LocalBuilder newobj = ilGenerator.DeclareLocal(thisType.TypeAsLocalOrStackType);
										ilGenerator.Emit(OpCodes.Stloc, newobj);
										LocalBuilder[] tempstack = new LocalBuilder[stackfix.Length];
										for(int j = 0; j < stackfix.Length; j++)
d1406 1
a1406 1
											if(!stackfix[j])
d1408 2
a1409 39
												TypeWrapper stacktype = ma.GetRawStackTypeWrapper(i, argcount + 1 + j);
												// it could be another new object reference (not from current invokespecial <init>
												// instruction)
												if(stacktype == VerifierTypeWrapper.Null)
												{
													// TODO handle null stack entries
													throw new NotImplementedException();
												}
												else if(!VerifierTypeWrapper.IsNew(stacktype))
												{
													LocalBuilder lb = ilGenerator.DeclareLocal(stacktype.TypeAsLocalOrStackType);
													ilGenerator.Emit(OpCodes.Stloc, lb);
													tempstack[j] = lb;
												}
											}
										}
										for(int j = stackfix.Length - 1; j >= 0; j--)
										{
											if(stackfix[j])
											{
												ilGenerator.Emit(OpCodes.Ldloc, newobj);
											}
											else if(tempstack[j] != null)
											{
												ilGenerator.Emit(OpCodes.Ldloc, tempstack[j]);
											}
										}
										LocalVar[] locals = ma.GetLocalVarsForInvokeSpecial(i);
										for(int j = 0; j < locals.Length; j++)
										{
											if(locals[j] != null)
											{
												if(locals[j].builder == null)
												{
													// for invokespecial the resulting type can never be null
													locals[j].builder = ilGenerator.DeclareLocal(locals[j].type.TypeAsLocalOrStackType);
												}
												ilGenerator.Emit(OpCodes.Ldloc, newobj);
												ilGenerator.Emit(OpCodes.Stloc, locals[j].builder);
d1411 2
d1414 7
d1424 1
a1424 1
										if(trivcount == 0)
d1426 1
a1426 8
											ilGenerator.Emit(OpCodes.Pop);
										}
										else
										{
											for(int j = 1; j < trivcount; j++)
											{
												ilGenerator.Emit(OpCodes.Dup);
											}
a1429 4
								else
								{
									emitCall.Emit(ilGenerator);
								}
d1433 4
a1436 16
								emit.Emit(ilGenerator);
							}
							break;
						}
						case NormalizedByteCode.__return:
						case NormalizedByteCode.__areturn:
						case NormalizedByteCode.__ireturn:
						case NormalizedByteCode.__lreturn:
						case NormalizedByteCode.__freturn:
						case NormalizedByteCode.__dreturn:
						{
							if(exits != null)
							{
								// if we're inside an exception block, copy TOS to local, emit "leave" and push item onto our "todo" list
								LocalBuilder local = null;
								if(instr.NormalizedOpCode != NormalizedByteCode.__return)
d1438 1
a1438 3
									TypeWrapper retTypeWrapper = m.Method.GetRetType(classLoader);
									retTypeWrapper.EmitConvStackToParameterType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
									if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
d1440 7
a1446 1
										ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsParameterType);
a1447 2
									local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
									ilGenerator.Emit(OpCodes.Stloc, local);
a1448 4
								Label label = ilGenerator.DefineLabel();
								// NOTE leave automatically discards any junk that may be on the stack
								ilGenerator.Emit(OpCodes.Leave, label);
								exits.Add(new ReturnCookie(label, local));
d1450 23
a1472 6
							else
							{
								// if there is junk on the stack (other than the return value), we must pop it off
								// because in .NET this is invalid (unlike in Java)
								int stackHeight = ma.GetStackHeight(i);
								if(instr.NormalizedOpCode == NormalizedByteCode.__return)
d1474 1
a1474 22
									if(stackHeight != 0)
									{
										ilGenerator.Emit(OpCodes.Leave_S, (byte)0);
									}
									ilGenerator.Emit(OpCodes.Ret);
								}
								else
								{
									TypeWrapper retTypeWrapper = m.Method.GetRetType(classLoader);
									retTypeWrapper.EmitConvStackToParameterType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
									if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
									{
										ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsParameterType);
									}
									if(stackHeight != 1)
									{
										LocalBuilder local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
										ilGenerator.Emit(OpCodes.Stloc, local);
										ilGenerator.Emit(OpCodes.Leave_S, (byte)0);
										ilGenerator.Emit(OpCodes.Ldloc, local);
									}
									ilGenerator.Emit(OpCodes.Ret);
d1476 2
d1479 4
a1482 1
							break;
d1484 1
a1484 1
						case NormalizedByteCode.__aload:
d1486 4
a1489 2
							TypeWrapper type = ma.GetLocalTypeWrapper(i, instr.NormalizedArg1);
							if(type == VerifierTypeWrapper.Null)
d1491 5
a1495 13
								// if the local is known to be null, we just emit a null
								ilGenerator.Emit(OpCodes.Ldnull);
							}
							else if(VerifierTypeWrapper.IsNew(type))
							{
								// since new objects aren't represented on the stack, we don't need to do anything here
							}
							else if(type == VerifierTypeWrapper.UninitializedThis)
							{
								// any unitialized reference has to be the this reference
								// TODO when we get support for overwriting the this reference, this code
								// needs to be aware of that (or, this overwriting should be handled specially for <init>)
								ilGenerator.Emit(OpCodes.Ldarg_0);
d1499 3
a1501 2
								LoadLocal(instr);
								if(instr.NormalizedArg1 < m.ArgMap.Length)
d1503 1
a1503 4
									// HACK we're boxing the arguments when they are loaded, this is inconsistent
									// with the way locals are treated, so we probably should only box the arguments
									// once (on method entry)
									type.EmitConvParameterToStackType(ilGenerator);
d1505 8
a1513 1
							break;
d1515 23
a1537 1
						case NormalizedByteCode.__astore:
d1539 2
a1540 3
							TypeWrapper type = ma.GetRawStackTypeWrapper(i, 0);
							// HACK we use "int" to track the return address of a jsr
							if(VerifierTypeWrapper.IsRet(type))
d1542 1
a1542 1
								StoreLocal(instr);
a1543 42
							else if(VerifierTypeWrapper.IsNew(type))
							{
								// NOTE new objects aren't really on the stack, so we can't copy them into the local.
								// We do store a null in the local, to prevent it from retaining an unintentional reference
								// to whatever object reference happens to be there
								ilGenerator.Emit(OpCodes.Ldnull);
								StoreLocal(instr);
							}
							else if(type == VerifierTypeWrapper.UninitializedThis)
							{
								// any unitialized reference is always the this reference, we don't store anything
								// here (because CLR won't allow unitialized references in locals) and then when
								// the unitialized ref is loaded we redirect to the this reference
								ilGenerator.Emit(OpCodes.Pop);
							}
							else
							{
								if(instr.NormalizedArg1 < m.ArgMap.Length)
								{
									if(type != VerifierTypeWrapper.Null)
									{
										type.EmitConvStackToParameterType(ilGenerator, type);
									}
									if(type.IsUnloadable)
									{
										TypeWrapper[] args = m.Method.GetArgTypes(classLoader);
										int arg = m.ArgMap[instr.NormalizedArg1];
										if(!m.Method.IsStatic)
										{
											arg--;
										}
										if(arg == -1)
										{
											// TODO once we have this aliasing this should work
											throw new NotImplementedException("overwriting this with unloadable");
										}
										ilGenerator.Emit(OpCodes.Castclass, args[arg].TypeAsParameterType);
									}
								}
								StoreLocal(instr);
							}
							break;
d1545 8
a1552 4
						case NormalizedByteCode.__iload:
							LoadLocal(instr);
							break;
						case NormalizedByteCode.__istore:
d1554 7
a1560 5
							break;
						case NormalizedByteCode.__lload:
							LoadLocal(instr);
							break;
						case NormalizedByteCode.__lstore:
d1562 10
a1571 5
							break;
						case NormalizedByteCode.__fload:
							LoadLocal(instr);
							break;
						case NormalizedByteCode.__fstore:
d1573 19
a1591 8
							break;
						case NormalizedByteCode.__dload:
							LoadLocal(instr);
							break;
						case NormalizedByteCode.__dstore:
							StoreLocal(instr);
							break;
						case NormalizedByteCode.__new:
d1593 5
a1597 19
							TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
							if(wrapper.IsUnloadable)
							{
								// this is here to make sure we throw the exception in the right location (before
								// evaluating the constructor arguments)
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
								ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
								ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicNewCheckOnly"));
							}
							else if(!wrapper.IsAccessibleFrom(clazz))
							{
								throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
							}
							else if(wrapper.IsAbstract || wrapper.IsInterface)
							{
								throw new InstantiationError(wrapper.Name);
							}
							// we don't do anything here, the call to <init> will be converted into a newobj instruction
							break;
d1599 1
a1599 1
						case NormalizedByteCode.__multianewarray:
d1601 1
a1601 34
							LocalBuilder localArray = ilGenerator.DeclareLocal(typeof(int[]));
							LocalBuilder localInt = ilGenerator.DeclareLocal(typeof(int));
							ilGenerator.Emit(OpCodes.Ldc_I4, instr.Arg2);
							ilGenerator.Emit(OpCodes.Newarr, typeof(int));
							ilGenerator.Emit(OpCodes.Stloc, localArray);
							for(int j = 1; j <= instr.Arg2; j++)
							{
								ilGenerator.Emit(OpCodes.Stloc, localInt);
								ilGenerator.Emit(OpCodes.Ldloc, localArray);
								ilGenerator.Emit(OpCodes.Ldc_I4, instr.Arg2 - j);
								ilGenerator.Emit(OpCodes.Ldloc, localInt);
								ilGenerator.Emit(OpCodes.Stelem_I4);
							}
							TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
							if(wrapper.IsUnloadable)
							{
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
								ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
								ilGenerator.Emit(OpCodes.Ldloc, localArray);
								ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicMultianewarray"));
							}
							else
							{
								if(!wrapper.IsAccessibleFrom(clazz))
								{
									throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
								}
								Type type = wrapper.TypeAsArrayType;
								ilGenerator.Emit(OpCodes.Ldtoken, type);
								ilGenerator.Emit(OpCodes.Ldloc, localArray);
								ilGenerator.Emit(OpCodes.Call, multiANewArrayMethod);
								ilGenerator.Emit(OpCodes.Castclass, type);
							}
							break;
d1603 1
a1603 1
						case NormalizedByteCode.__anewarray:
d1605 19
a1623 26
							TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
							if(wrapper.IsUnloadable)
							{
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
								ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
								ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicNewarray"));
							}
							else
							{
								if(!wrapper.IsAccessibleFrom(clazz))
								{
									throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
								}
								// NOTE for ghost types we create object arrays to make sure that Ghost implementers can be
								// stored in ghost arrays, but this has the unintended consequence that ghost arrays can
								// contain *any* reference type (because they are compiled as Object arrays). We could
								// modify aastore to emit code to check for this, but this would have an huge performance
								// cost for all object arrays.
								// Oddly, while the JVM accepts any reference for any other interface typed references, in the
								// case of aastore it does check that the object actually implements the interface. This
								// is unfortunate, but I think we can live with this minor incompatibility.
								// NOTE that this does not break type safety, because when the incorrect object is eventually
								// used as the ghost interface type it will generate a ClassCastException.
								ilGenerator.Emit(OpCodes.Newarr, wrapper.TypeAsArrayType);
							}
							break;
d1625 2
a1626 2
						case NormalizedByteCode.__newarray:
						switch(instr.Arg1)
d1628 4
a1631 27
							case 4:
								ilGenerator.Emit(OpCodes.Newarr, typeof(bool));
								break;
							case 5:
								ilGenerator.Emit(OpCodes.Newarr, typeof(char));
								break;
							case 6:
								ilGenerator.Emit(OpCodes.Newarr, typeof(float));
								break;
							case 7:
								ilGenerator.Emit(OpCodes.Newarr, typeof(double));
								break;
							case 8:
								ilGenerator.Emit(OpCodes.Newarr, typeof(sbyte));
								break;
							case 9:
								ilGenerator.Emit(OpCodes.Newarr, typeof(short));
								break;
							case 10:
								ilGenerator.Emit(OpCodes.Newarr, typeof(int));
								break;
							case 11:
								ilGenerator.Emit(OpCodes.Newarr, typeof(long));
								break;
							default:
								// this can't happen, the verifier would have caught it
								throw new InvalidOperationException();
d1633 1
a1633 2
							break;
						case NormalizedByteCode.__checkcast:
d1635 1
a1635 2
							TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
							if(!wrapper.IsUnloadable && !wrapper.IsAccessibleFrom(clazz))
d1639 5
a1643 2
							wrapper.EmitCheckcast(clazz, ilGenerator);
							break;
d1645 6
a1650 1
						case NormalizedByteCode.__instanceof:
d1652 3
a1654 7
							TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
							if(!wrapper.IsUnloadable && !wrapper.IsAccessibleFrom(clazz))
							{
								throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
							}
							wrapper.EmitInstanceOf(clazz, ilGenerator);
							break;
d1656 1
a1656 1
						case NormalizedByteCode.__aaload:
d1658 1
a1658 2
							TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 1);
							if(tw.IsUnloadable)
d1660 1
a1660 3
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
								ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
								ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAaload"));
d1662 11
a1672 16
							else
							{
								TypeWrapper elem = tw.ElementTypeWrapper;
								if(elem.IsNonPrimitiveValueType)
								{
									Type t = elem.TypeAsTBD;
									ilGenerator.Emit(OpCodes.Ldelema, t);
									ilGenerator.Emit(OpCodes.Ldobj, t);
									elem.EmitBox(ilGenerator);
								}
								else
								{
									ilGenerator.Emit(OpCodes.Ldelem_Ref);
								}
							}
							break;
d1674 7
a1680 3
						case NormalizedByteCode.__baload:
							// NOTE both the JVM and the CLR use signed bytes for boolean arrays (how convenient!)
							ilGenerator.Emit(OpCodes.Ldelem_I1);
d1682 2
a1683 2
						case NormalizedByteCode.__bastore:
							ilGenerator.Emit(OpCodes.Stelem_I1);
d1685 2
a1686 2
						case NormalizedByteCode.__caload:
							ilGenerator.Emit(OpCodes.Ldelem_U2);
d1688 2
a1689 2
						case NormalizedByteCode.__castore:
							ilGenerator.Emit(OpCodes.Stelem_I2);
d1691 2
a1692 2
						case NormalizedByteCode.__saload:
							ilGenerator.Emit(OpCodes.Ldelem_I2);
d1694 2
a1695 2
						case NormalizedByteCode.__sastore:
							ilGenerator.Emit(OpCodes.Stelem_I2);
d1697 2
a1698 2
						case NormalizedByteCode.__iaload:
							ilGenerator.Emit(OpCodes.Ldelem_I4);
d1700 2
a1701 2
						case NormalizedByteCode.__iastore:
							ilGenerator.Emit(OpCodes.Stelem_I4);
d1703 35
a1737 19
						case NormalizedByteCode.__laload:
							ilGenerator.Emit(OpCodes.Ldelem_I8);
							break;
						case NormalizedByteCode.__lastore:
							ilGenerator.Emit(OpCodes.Stelem_I8);
							break;
						case NormalizedByteCode.__faload:
							ilGenerator.Emit(OpCodes.Ldelem_R4);
							break;
						case NormalizedByteCode.__fastore:
							ilGenerator.Emit(OpCodes.Stelem_R4);
							break;
						case NormalizedByteCode.__daload:
							ilGenerator.Emit(OpCodes.Ldelem_R8);
							break;
						case NormalizedByteCode.__dastore:
							ilGenerator.Emit(OpCodes.Stelem_R8);
							break;
						case NormalizedByteCode.__aastore:
d1739 2
a1740 2
							TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 2);
							if(tw.IsUnloadable)
d1742 4
a1745 3
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
								ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
								ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAastore"));
d1749 1
a1749 15
								TypeWrapper elem = tw.ElementTypeWrapper;
								if(elem.IsNonPrimitiveValueType)
								{
									Type t = elem.TypeAsTBD;
									LocalBuilder local = ilGenerator.DeclareLocal(typeof(object));
									ilGenerator.Emit(OpCodes.Stloc, local);
									ilGenerator.Emit(OpCodes.Ldelema, t);
									ilGenerator.Emit(OpCodes.Ldloc, local);
									elem.EmitUnbox(ilGenerator);
									ilGenerator.Emit(OpCodes.Stobj, t);
								}
								else
								{
									ilGenerator.Emit(OpCodes.Stelem_Ref);
								}
a1750 1
							break;
d1752 58
a1809 2
						case NormalizedByteCode.__arraylength:
							if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
d1811 7
a1817 2
								ilGenerator.Emit(OpCodes.Castclass, typeof(Array));
								ilGenerator.Emit(OpCodes.Callvirt, typeof(Array).GetMethod("get_Length"));
d1821 1
a1821 1
								ilGenerator.Emit(OpCodes.Ldlen);
d1823 5
a1827 2
							break;
						case NormalizedByteCode.__lcmp:
d1829 2
a1830 22
							LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(long));
							LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(long));
							ilGenerator.Emit(OpCodes.Stloc, value2);
							ilGenerator.Emit(OpCodes.Stloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label res1 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Bgt_S, res1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label res0 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Beq_S, res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_M1);
							Label end = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Br_S, end);
							ilGenerator.MarkLabel(res1);
							ilGenerator.Emit(OpCodes.Ldc_I4_1);
							ilGenerator.Emit(OpCodes.Br_S, end);
							ilGenerator.MarkLabel(res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.MarkLabel(end);
							break;
d1832 1
a1832 1
						case NormalizedByteCode.__fcmpl:
d1834 1
a1834 22
							LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(float));
							LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(float));
							ilGenerator.Emit(OpCodes.Stloc, value2);
							ilGenerator.Emit(OpCodes.Stloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label res1 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Bgt_S, res1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label res0 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Beq_S, res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_M1);
							Label end = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Br_S, end);
							ilGenerator.MarkLabel(res1);
							ilGenerator.Emit(OpCodes.Ldc_I4_1);
							ilGenerator.Emit(OpCodes.Br_S, end);
							ilGenerator.MarkLabel(res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.MarkLabel(end);
							break;
d1836 228
a2063 1
						case NormalizedByteCode.__fcmpg:
d2065 1
a2065 22
							LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(float));
							LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(float));
							ilGenerator.Emit(OpCodes.Stloc, value2);
							ilGenerator.Emit(OpCodes.Stloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label resm1 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Blt_S, resm1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label res0 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Beq_S, res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_1);
							Label end = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Br_S, end);
							ilGenerator.MarkLabel(resm1);
							ilGenerator.Emit(OpCodes.Ldc_I4_M1);
							ilGenerator.Emit(OpCodes.Br_S, end);
							ilGenerator.MarkLabel(res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.MarkLabel(end);
							break;
d2067 25
a2091 1
						case NormalizedByteCode.__dcmpl:
d2093 1
a2093 22
							LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(double));
							LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(double));
							ilGenerator.Emit(OpCodes.Stloc, value2);
							ilGenerator.Emit(OpCodes.Stloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label res1 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Bgt_S, res1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label res0 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Beq_S, res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_M1);
							Label end = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Br_S, end);
							ilGenerator.MarkLabel(res1);
							ilGenerator.Emit(OpCodes.Ldc_I4_1);
							ilGenerator.Emit(OpCodes.Br_S, end);
							ilGenerator.MarkLabel(res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.MarkLabel(end);
							break;
d2095 6
a2100 1
						case NormalizedByteCode.__dcmpg:
d2102 1
a2102 22
							LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(double));
							LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(double));
							ilGenerator.Emit(OpCodes.Stloc, value2);
							ilGenerator.Emit(OpCodes.Stloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label resm1 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Blt, resm1);
							ilGenerator.Emit(OpCodes.Ldloc, value1);
							ilGenerator.Emit(OpCodes.Ldloc, value2);
							Label res0 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Beq, res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_1);
							Label end = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Br, end);
							ilGenerator.MarkLabel(resm1);
							ilGenerator.Emit(OpCodes.Ldc_I4, -1);
							ilGenerator.Emit(OpCodes.Br, end);
							ilGenerator.MarkLabel(res0);
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.MarkLabel(end);
							break;
d2104 55
a2158 95
						case NormalizedByteCode.__if_icmpeq:
							ilGenerator.Emit(OpCodes.Beq, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__if_icmpne:
							ilGenerator.Emit(OpCodes.Bne_Un, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__if_icmple:
							ilGenerator.Emit(OpCodes.Ble, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__if_icmplt:
							ilGenerator.Emit(OpCodes.Blt, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__if_icmpge:
							ilGenerator.Emit(OpCodes.Bge, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__if_icmpgt:
							ilGenerator.Emit(OpCodes.Bgt, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__ifle:
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Ble, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__iflt:
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Blt, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__ifge:
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Bge, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__ifgt:
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Bgt, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__ifne:
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Bne_Un, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__ifeq:
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Beq, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__ifnonnull:
							ilGenerator.Emit(OpCodes.Brtrue, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__ifnull:
							ilGenerator.Emit(OpCodes.Brfalse, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__if_acmpeq:
							ilGenerator.Emit(OpCodes.Beq, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__if_acmpne:
							ilGenerator.Emit(OpCodes.Bne_Un, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__goto:
							ilGenerator.Emit(OpCodes.Br, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__ineg:
						case NormalizedByteCode.__lneg:
						case NormalizedByteCode.__fneg:
						case NormalizedByteCode.__dneg:
							ilGenerator.Emit(OpCodes.Neg);
							break;
						case NormalizedByteCode.__iadd:
						case NormalizedByteCode.__ladd:
						case NormalizedByteCode.__fadd:
						case NormalizedByteCode.__dadd:
							ilGenerator.Emit(OpCodes.Add);
							break;
						case NormalizedByteCode.__isub:
						case NormalizedByteCode.__lsub:
						case NormalizedByteCode.__fsub:
						case NormalizedByteCode.__dsub:
							ilGenerator.Emit(OpCodes.Sub);
							break;
						case NormalizedByteCode.__ixor:
						case NormalizedByteCode.__lxor:
							ilGenerator.Emit(OpCodes.Xor);
							break;
						case NormalizedByteCode.__ior:
						case NormalizedByteCode.__lor:
							ilGenerator.Emit(OpCodes.Or);
							break;
						case NormalizedByteCode.__iand:
						case NormalizedByteCode.__land:
							ilGenerator.Emit(OpCodes.And);
							break;
						case NormalizedByteCode.__imul:
						case NormalizedByteCode.__lmul:
						case NormalizedByteCode.__fmul:
						case NormalizedByteCode.__dmul:
							ilGenerator.Emit(OpCodes.Mul);
							break;
						case NormalizedByteCode.__idiv:
						case NormalizedByteCode.__ldiv:
a2159 3
							// we need to special case dividing by -1, because the CLR div instruction
							// throws an OverflowException when dividing Int32.MinValue by -1, and
							// Java just silently overflows
a2160 15
							ilGenerator.Emit(OpCodes.Ldc_I4_M1);
							if(instr.NormalizedOpCode == NormalizedByteCode.__ldiv)
							{
								ilGenerator.Emit(OpCodes.Conv_I8);
							}
							Label label = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Bne_Un_S, label);
							ilGenerator.Emit(OpCodes.Pop);
							ilGenerator.Emit(OpCodes.Neg);
							Label label2 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Br_S, label2);
							ilGenerator.MarkLabel(label);
							ilGenerator.Emit(OpCodes.Div);
							ilGenerator.MarkLabel(label2);
							break;
d2162 5
a2166 6
						case NormalizedByteCode.__fdiv:
						case NormalizedByteCode.__ddiv:
							ilGenerator.Emit(OpCodes.Div);
							break;
						case NormalizedByteCode.__irem:
						case NormalizedByteCode.__lrem:
a2167 4
							// we need to special case taking the remainder of dividing by -1,
							// because the CLR rem instruction throws an OverflowException when
							// taking the remainder of dividing Int32.MinValue by -1, and
							// Java just silently overflows
a2168 20
							ilGenerator.Emit(OpCodes.Ldc_I4_M1);
							if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
							{
								ilGenerator.Emit(OpCodes.Conv_I8);
							}
							Label label = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Bne_Un_S, label);
							ilGenerator.Emit(OpCodes.Pop);
							ilGenerator.Emit(OpCodes.Pop);
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
							{
								ilGenerator.Emit(OpCodes.Conv_I8);
							}
							Label label2 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Br_S, label2);
							ilGenerator.MarkLabel(label);
							ilGenerator.Emit(OpCodes.Rem);
							ilGenerator.MarkLabel(label2);
							break;
d2170 1
a2170 35
						case NormalizedByteCode.__frem:
						case NormalizedByteCode.__drem:
							ilGenerator.Emit(OpCodes.Rem);
							break;
						case NormalizedByteCode.__ishl:
							ilGenerator.Emit(OpCodes.Ldc_I4, 31);
							ilGenerator.Emit(OpCodes.And);
							ilGenerator.Emit(OpCodes.Shl);
							break;
						case NormalizedByteCode.__lshl:
							ilGenerator.Emit(OpCodes.Ldc_I4, 63);
							ilGenerator.Emit(OpCodes.And);
							ilGenerator.Emit(OpCodes.Shl);
							break;
						case NormalizedByteCode.__iushr:
							ilGenerator.Emit(OpCodes.Ldc_I4, 31);
							ilGenerator.Emit(OpCodes.And);
							ilGenerator.Emit(OpCodes.Shr_Un);
							break;
						case NormalizedByteCode.__lushr:
							ilGenerator.Emit(OpCodes.Ldc_I4, 63);
							ilGenerator.Emit(OpCodes.And);
							ilGenerator.Emit(OpCodes.Shr_Un);
							break;
						case NormalizedByteCode.__ishr:
							ilGenerator.Emit(OpCodes.Ldc_I4, 31);
							ilGenerator.Emit(OpCodes.And);
							ilGenerator.Emit(OpCodes.Shr);
							break;
						case NormalizedByteCode.__lshr:
							ilGenerator.Emit(OpCodes.Ldc_I4, 63);
							ilGenerator.Emit(OpCodes.And);
							ilGenerator.Emit(OpCodes.Shr);
							break;
						case NormalizedByteCode.__swap:
d2173 1
a2173 1
							dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
d2177 1
d2180 1
a2180 1
							break;
d2182 18
a2199 8
						case NormalizedByteCode.__dup:
							// if the TOS contains a "new" object, it isn't really there, so we don't dup it
							if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
							{
								ilGenerator.Emit(OpCodes.Dup);
							}
							break;
						case NormalizedByteCode.__dup2:
d2201 8
a2208 18
							TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
							if(type1.IsWidePrimitive)
							{
								ilGenerator.Emit(OpCodes.Dup);
							}
							else
							{
								DupHelper dh = new DupHelper(ilGenerator, 2);
								dh.SetType(0, type1);
								dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
								dh.Store(0);
								dh.Store(1);
								dh.Load(1);
								dh.Load(0);
								dh.Load(1);
								dh.Load(0);
							}
							break;
d2210 1
a2210 1
						case NormalizedByteCode.__dup_x1:
d2212 2
a2213 2
							DupHelper dh = new DupHelper(ilGenerator, 2);
							dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
d2215 1
d2218 2
d2221 1
a2223 1
							break;
d2225 7
a2231 1
						case NormalizedByteCode.__dup2_x1:
d2233 1
a2233 2
							TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
							if(type1.IsWidePrimitive)
d2235 1
d2238 1
a2238 1
								dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
d2247 1
d2250 1
a2250 1
								dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
a2254 1
								dh.Load(1);
a2259 1
							break;
d2261 1
a2261 1
						case NormalizedByteCode.__dup2_x2:
d2263 2
a2264 3
							TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
							TypeWrapper type2 = ma.GetRawStackTypeWrapper(i, 1);
							if(type1.IsWidePrimitive)
d2266 13
a2278 27
								if(type2.IsWidePrimitive)
								{
									// Form 4
									DupHelper dh = new DupHelper(ilGenerator, 2);
									dh.SetType(0, type1);
									dh.SetType(1, type2);
									dh.Store(0);
									dh.Store(1);
									dh.Load(0);
									dh.Load(1);
									dh.Load(0);
								}
								else
								{
									// Form 2
									DupHelper dh = new DupHelper(ilGenerator, 3);
									dh.SetType(0, type1);
									dh.SetType(1, type2);
									dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
									dh.Store(0);
									dh.Store(1);
									dh.Store(2);
									dh.Load(0);
									dh.Load(2);
									dh.Load(1);
									dh.Load(0);
								}
d2282 16
a2297 36
								TypeWrapper type3 = ma.GetRawStackTypeWrapper(i, 2);
								if(type3.IsWidePrimitive)
								{
									// Form 3
									DupHelper dh = new DupHelper(ilGenerator, 3);
									dh.SetType(0, type1);
									dh.SetType(1, type2);
									dh.SetType(2, type3);
									dh.Store(0);
									dh.Store(1);
									dh.Store(2);
									dh.Load(1);
									dh.Load(0);
									dh.Load(2);
									dh.Load(1);
									dh.Load(0);
								}
								else
								{
									// Form 1
									DupHelper dh = new DupHelper(ilGenerator, 4);
									dh.SetType(0, type1);
									dh.SetType(1, type2);
									dh.SetType(2, type3);
									dh.SetType(3, ma.GetRawStackTypeWrapper(i, 3));
									dh.Store(0);
									dh.Store(1);
									dh.Store(2);
									dh.Store(3);
									dh.Load(1);
									dh.Load(0);
									dh.Load(3);
									dh.Load(2);
									dh.Load(1);
									dh.Load(0);
								}
a2298 1
							break;
d2300 21
a2320 1
						case NormalizedByteCode.__dup_x2:
d2322 1
a2322 12
							DupHelper dh = new DupHelper(ilGenerator, 3);
							dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
							dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
							dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
							dh.Store(0);
							dh.Store(1);
							dh.Store(2);
							dh.Load(0);
							dh.Load(2);
							dh.Load(1);
							dh.Load(0);
							break;
d2324 1
a2324 1
						case NormalizedByteCode.__pop2:
d2326 1
a2326 2
							TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
							if(type1.IsWidePrimitive)
d2330 1
a2330 16
							else
							{
								if(!VerifierTypeWrapper.IsNew(type1))
								{
									ilGenerator.Emit(OpCodes.Pop);
								}
								if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 1)))
								{
									ilGenerator.Emit(OpCodes.Pop);
								}
							}
							break;
						}
						case NormalizedByteCode.__pop:
							// if the TOS is a new object, it isn't really there, so we don't need to pop it
							if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
d2334 7
a2340 22
							break;
						case NormalizedByteCode.__monitorenter:
							ilGenerator.Emit(OpCodes.Call, monitorEnterMethod);
							break;
						case NormalizedByteCode.__monitorexit:
							ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
							break;
						case NormalizedByteCode.__athrow:
							ilGenerator.Emit(OpCodes.Throw);
							break;
						case NormalizedByteCode.__lookupswitch:
							// TODO use OpCodes.Switch
							for(int j = 0; j < instr.Values.Length; j++)
							{
								ilGenerator.Emit(OpCodes.Dup);
								ilGenerator.Emit(OpCodes.Ldc_I4, instr.Values[j]);
								Label label = ilGenerator.DefineLabel();
								ilGenerator.Emit(OpCodes.Bne_Un, label);
								ilGenerator.Emit(OpCodes.Pop);
								ilGenerator.Emit(OpCodes.Br, GetLabel(labels, instr.PC + instr.TargetOffsets[j], inuse, rangeBegin, rangeEnd, exits));
								ilGenerator.MarkLabel(label);
							}
d2342 14
a2355 46
							ilGenerator.Emit(OpCodes.Br, GetLabel(labels, instr.PC + instr.DefaultOffset, inuse, rangeBegin, rangeEnd, exits));
							break;
						case NormalizedByteCode.__iinc:
							LoadLocal(instr);
							ilGenerator.Emit(OpCodes.Ldc_I4, instr.Arg2);
							ilGenerator.Emit(OpCodes.Add);
							StoreLocal(instr);
							break;
						case NormalizedByteCode.__i2b:
							ilGenerator.Emit(OpCodes.Conv_I1);
							break;
						case NormalizedByteCode.__i2c:
							ilGenerator.Emit(OpCodes.Conv_U2);
							break;
						case NormalizedByteCode.__i2s:
							ilGenerator.Emit(OpCodes.Conv_I2);
							break;
						case NormalizedByteCode.__l2i:
							ilGenerator.Emit(OpCodes.Conv_I4);
							break;
						case NormalizedByteCode.__f2i:
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("f2i"));
							break;
						case NormalizedByteCode.__d2i:
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("d2i"));
							break;
						case NormalizedByteCode.__f2l:
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("f2l"));
							break;
						case NormalizedByteCode.__d2l:
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("d2l"));
							break;
						case NormalizedByteCode.__i2l:
							ilGenerator.Emit(OpCodes.Conv_I8);
							break;
						case NormalizedByteCode.__i2f:
						case NormalizedByteCode.__l2f:
						case NormalizedByteCode.__d2f:
							ilGenerator.Emit(OpCodes.Conv_R4);
							break;
						case NormalizedByteCode.__i2d:
						case NormalizedByteCode.__l2d:
						case NormalizedByteCode.__f2d:
							ilGenerator.Emit(OpCodes.Conv_R8);
							break;
						case NormalizedByteCode.__jsr:
d2357 7
a2363 12
							int index = FindPcIndex(instr.PC + instr.Arg1);
							int[] callsites = ma.GetCallSites(index);
							for(int j = 0; j < callsites.Length; j++)
							{
								if(callsites[j] == i)
								{
									ilGenerator.Emit(OpCodes.Ldc_I4, j);
									break;
								}
							}
							ilGenerator.Emit(OpCodes.Br, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
							break;
d2365 51
a2415 1
						case NormalizedByteCode.__ret:
d2417 4
a2420 9
							// NOTE using a OpCodes.Switch here is not efficient, because 99 out of a 100 cases
							// there are either one or two call sites.
							int subid = ((VerifierTypeWrapper)ma.GetLocalTypeWrapper(i, instr.Arg1)).Index;
							int[] callsites = ma.GetCallSites(subid);
							for(int j = 0; j < callsites.Length - 1; j++)
							{
								LoadLocal(instr);
								ilGenerator.Emit(OpCodes.Ldc_I4, j);
								ilGenerator.Emit(OpCodes.Beq, GetLabel(labels, m.Instructions[callsites[j] + 1].PC, inuse, rangeBegin, rangeEnd, exits));
a2421 2
							ilGenerator.Emit(OpCodes.Br, GetLabel(labels, m.Instructions[callsites[callsites.Length - 1] + 1].PC, inuse, rangeBegin, rangeEnd, exits));
							break;
d2423 2
a2424 5
						case NormalizedByteCode.__nop:
							ilGenerator.Emit(OpCodes.Nop);
							break;
						default:
							throw new NotImplementedException(instr.NormalizedOpCode.ToString());
d2426 1
a2426 2
					// mark next instruction as inuse
					switch(instr.NormalizedOpCode)
d2428 12
a2439 30
						case NormalizedByteCode.__lookupswitch:
						case NormalizedByteCode.__goto:
						case NormalizedByteCode.__jsr:
						case NormalizedByteCode.__ret:
						case NormalizedByteCode.__ireturn:
						case NormalizedByteCode.__lreturn:
						case NormalizedByteCode.__freturn:
						case NormalizedByteCode.__dreturn:
						case NormalizedByteCode.__areturn:
						case NormalizedByteCode.__return:
						case NormalizedByteCode.__athrow:
							break;
						default:
							// don't fall through end of try block
							if(m.Instructions[i + 1].PC == rangeEnd)
							{
								// TODO instead of emitting a branch to the leave stub, it would be more efficient to put the leave stub here
								ilGenerator.Emit(OpCodes.Br, GetLabel(labels, m.Instructions[i + 1].PC, inuse, rangeBegin, rangeEnd, exits));
							}
							else
							{
								inuse[i + 1] = true;
								if(done[i + 1])
								{
									// since we've already processed the code that is supposed to come next, we have
									// to emit a branch to it
									ilGenerator.Emit(OpCodes.Br, GetLabel(labels, m.Instructions[i + 1].PC, inuse, rangeBegin, rangeEnd, exits));
								}
							}
							break;
d2441 5
d2447 2
a2448 1
				catch(EmitException x)
d2450 21
a2470 1
					x.Emit(ilGenerator, m.Method);
d2473 51
d2965 1
a2965 1
	private void LoadLocal(ClassFile.Method.Instruction instr)
d2967 2
a2968 6
		// TODO this check will become more complex, once we support changing the type of an argument 'local'
		if(instr.NormalizedArg1 >= m.ArgMap.Length)
		{
			ilGenerator.Emit(OpCodes.Ldloc, GetLocal(FindPcIndex(instr.PC)));
		}
		else
d2997 17
d3018 2
a3019 2
		// TODO this check will become more complex, once we support changing the type of an argument 'local'
		if(instr.NormalizedArg1 >= m.ArgMap.Length)
d3021 2
a3022 10
			LocalBuilder local = GetLocal(FindPcIndex(instr.PC));
			if(local == null)
			{
				// dead store
				ilGenerator.Emit(OpCodes.Pop);
			}
			else
			{
				ilGenerator.Emit(OpCodes.Stloc, local);
			}
d3024 1
a3024 1
		else
d3036 1
a3036 24
	}

	private LocalBuilder GetLocal(int instructionIndex)
	{
		LocalVar v = ma.GetLocalVar(instructionIndex);
		if(v == null)
		{
			return null;
		}
		if(v.builder == null && v.type != VerifierTypeWrapper.Null)
		{
			v.builder = ilGenerator.DeclareLocal(v.type.TypeAsLocalOrStackType);
			if(JVM.Debug && v.name != null)
			{
				v.builder.SetLocalSymInfo(v.name);
			}
		}
		return v.builder;
	}

	private Label GetLabel(object[] labels, int targetPC, bool[] inuse, int rangeBegin, int rangeEnd, ArrayList exits)
	{
		int targetIndex = FindPcIndex(targetPC);
		if(rangeBegin <= targetPC && targetPC < rangeEnd)
d3038 1
a3038 8
			inuse[targetIndex] = true;
			object l = labels[targetIndex];
			if(l == null)
			{
				l = ilGenerator.DefineLabel();
				labels[targetIndex] = l;
			}
			return (Label)l;
d3042 1
a3042 2
			object l = labels[targetIndex];
			if(l == null)
d3044 5
a3048 13
				// if we're branching out of the current exception block, we need to indirect this thru a stub
				// that saves the stack and uses leave to leave the exception block (to another stub that recovers
				// the stack)
				int stackHeight = ma.GetStackHeight(targetIndex);
				BranchCookie bc = new BranchCookie(ilGenerator, stackHeight, targetPC);
				bc.ContentOnStack = true;
				for(int i = 0; i < stackHeight; i++)
				{
					bc.dh.SetType(i, ma.GetRawStackTypeWrapper(targetIndex, i));
				}
				exits.Add(bc);
				l = bc;
				labels[targetIndex] = l;
d3050 1
a3050 1
			return ((BranchCookie)l).Stub;
@


1.39
log
@*** empty log message ***
@
text
@a80 1
	private Hashtable locals = new Hashtable();
d90 3
a92 3
		java_lang_Throwable = CoreClasses.java_lang_Throwable;
		java_lang_Object = CoreClasses.java_lang_Object;
		java_lang_Class = CoreClasses.java_lang_Class;
d107 1
a107 1
				this.symboldocument = classLoader.ModuleBuilder.DefineDocument(sourcefile, Guid.Empty, Guid.Empty, Guid.Empty);
d693 7
a699 1
								ilGenerator.Emit(OpCodes.Nop);
d791 2
a792 1
							Instruction handlerInstr = code[FindPcIndex(exceptions[j].handler_pc)];
d795 1
a795 1
									!ma.IsAloadUsed(handlerInstr.NormalizedArg1));
a1128 1
									bool[] localsfix = new bool[m.MaxLocals];
d1147 1
a1147 1
									for(int j = 0; j < localsfix.Length; j++)
a1150 1
											localsfix[j] = true;
d1172 1
a1172 1
										LocalBuilder newobj = ilGenerator.DeclareLocal(thisType.TypeAsTBD);
d1206 2
a1207 1
										for(int j = 0; j < localsfix.Length; j++)
d1209 1
a1209 1
											if(localsfix[j])
d1211 5
d1217 1
a1217 1
												ilGenerator.Emit(OpCodes.Stloc, GetLocal(typeof(object), j));
d1281 4
a1284 1
									ilGenerator.Emit(OpCodes.Leave_S, (byte)0);
d1328 2
a1329 11
								Load(instr, typeof(object));
								if(instr.NormalizedArg1 >= m.ArgMap.Length)
								{
									// HACK since, for now, all locals are of type object, we've got to cast them to the proper type
									// UPDATE the above is no longer true, we now have at least some idea of the type of the local
									if(type != ma.GetDeclaredLocalTypeWrapper(instr.NormalizedArg1) && !type.IsUnloadable && !type.IsGhost && !type.IsNonPrimitiveValueType)
									{
										ilGenerator.Emit(OpCodes.Castclass, type.TypeAsTBD);
									}
								}
								else
d1345 1
a1345 1
								Store(instr, typeof(int));
d1353 1
a1353 1
								Store(instr, typeof(object));
d1386 1
a1386 1
								Store(instr, typeof(object));
d1391 1
a1391 1
							Load(instr, typeof(int));
d1394 1
a1394 1
							Store(instr, typeof(int));
d1397 1
a1397 1
							Load(instr, typeof(long));
d1400 1
a1400 1
							Store(instr, typeof(long));
d1403 1
a1403 1
							Load(instr, typeof(float));
d1406 1
a1406 1
							Store(instr, typeof(float));
d1409 1
a1409 1
							Load(instr, typeof(double));
d1412 1
a1412 1
							Store(instr, typeof(double));
d2195 1
a2195 1
							Load(instr, typeof(int));
d2198 1
a2198 1
							Store(instr, typeof(int));
d2260 1
a2260 1
								Load(instr, typeof(int));
d2754 1
a2754 1
	private void Load(ClassFile.Method.Instruction instr, Type type)
d2759 1
a2759 2
			// OPTIMIZE use short form when possible
			ilGenerator.Emit(OpCodes.Ldloc, GetLocal(type, instr.NormalizedArg1));
d2792 1
a2792 1
	private void Store(ClassFile.Method.Instruction instr, Type type)
d2797 10
a2806 1
			ilGenerator.Emit(OpCodes.Stloc, GetLocal(type, instr.NormalizedArg1));
d2822 1
a2822 1
	private LocalBuilder GetLocal(Type type, int index)
d2824 2
a2825 6
		string name;
		if(type.IsValueType)
		{
			name = type.Name + index;
		}
		else
d2827 1
a2827 6
			name = "Obj" + index;
			TypeWrapper t = ma.GetDeclaredLocalTypeWrapper(index);
			if(t != VerifierTypeWrapper.Null)
			{
				type = t.TypeAsLocalOrStackType;
			}
d2829 1
a2829 2
		LocalBuilder lb = (LocalBuilder)locals[name];
		if(lb == null)
d2831 2
a2832 5
			lb = ilGenerator.DeclareLocal(type);
			locals[name] = lb;
			// the local variable table is disabled, because we need to have
			// better support for overloaded indexes to make this usefull
			if(JVM.Debug && false)
d2834 1
a2834 13
				// TODO this should be done better
				ClassFile.Method.LocalVariableTableEntry[] table = m.LocalVariableTableAttribute;
				if(table != null)
				{
					for(int i = 0; i < table.Length; i++)
					{
						if(table[i].index == index)
						{
							lb.SetLocalSymInfo(table[i].name);
							break;
						}
					}
				}
d2837 1
a2837 1
		return lb;
@


1.38
log
@*** empty log message ***
@
text
@d67 1
d73 1
d91 3
a93 2
		java_lang_Throwable = ClassLoaderWrapper.LoadClassCritical("java.lang.Throwable");
		java_lang_Object = ClassLoaderWrapper.LoadClassCritical("java.lang.Object");
d451 18
a468 2
		internal Label Stub;
		internal LocalBuilder Local;
d615 26
a640 1
		c.Compile(0, 0, null);
d856 1
a856 1
								if(exceptionIndex == 0)
d858 1
a858 6
									ilGenerator.MarkLabel(rc.Stub);
									if(rc.Local != null)
									{
										ilGenerator.Emit(OpCodes.Ldloc, rc.Local);
									}
									ilGenerator.Emit(OpCodes.Ret);
d995 18
d1244 1
a1244 1
							if(exceptionIndex != 0)
d1247 1
a1247 1
								ReturnCookie rc = new ReturnCookie();
a1250 1
									rc.Local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
d1256 2
a1257 1
									ilGenerator.Emit(OpCodes.Stloc, rc.Local);
d1259 1
a1259 1
								rc.Stub = ilGenerator.DefineLabel();
d1261 2
a1262 2
								ilGenerator.Emit(OpCodes.Leave, rc.Stub);
								exits.Add(rc);
d1271 1
a1271 4
									for(int j = 0; j < stackHeight; j++)
									{
										ilGenerator.Emit(OpCodes.Pop);
									}
d1286 1
a1286 4
										for(int j = 1; j < stackHeight; j++)
										{
											ilGenerator.Emit(OpCodes.Pop);
										}
d2662 1
a2662 1
						method = ClassLoaderWrapper.LoadClassCritical("java.lang.Object").GetMethodWrapper(md, false);
@


1.37
log
@*** empty log message ***
@
text
@d390 1
a390 5
			if(JVM.IsStaticCompiler)
			{
				Console.Error.WriteLine(type.Name + ": " + Message);
				Console.Error.WriteLine("\tat " + m.ClassFile.Name + "." + m.Name + m.Signature);
			}
a592 4
			if(JVM.IsStaticCompiler)
			{
				Console.Error.WriteLine("Warning: VerifyError: " + msg);
			}
d729 1
a729 1
						bool mapSafe = !exceptionTypeWrapper.IsUnloadable && ClassLoaderWrapper.IsMapSafeException(exceptionTypeWrapper);
d2332 1
a2332 4
				// I think this is the most efficient way to generate a NullReferenceException if the
				// reference is null
				ilGenerator.Emit(OpCodes.Ldvirtftn, objectToStringMethod);
				ilGenerator.Emit(OpCodes.Pop);
@


1.36
log
@*** empty log message ***
@
text
@d1895 4
d1900 2
d1905 4
d1910 2
d1915 4
d1920 2
@


1.35
log
@*** empty log message ***
@
text
@d2420 1
a2420 1
			FieldWrapper field = wrapper.GetFieldWrapper(cpi.Name);
@


1.34
log
@*** empty log message ***
@
text
@d578 1
a578 1
				ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
d783 1
a783 1
									ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
d1119 1
a1119 1
										LocalBuilder newobj = ilGenerator.DeclareLocal(thisType.Type);
d1279 1
a1279 1
										ilGenerator.Emit(OpCodes.Castclass, type.Type);
d1374 1
a1374 1
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
d1376 1
a1376 1
								ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicLoadClass"));
d1407 1
a1407 1
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
d1431 1
a1431 1
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
d1490 1
a1490 1
							if(wrapper.IsUnloadable)
d1492 1
a1492 47
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
								ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
								ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicCast"));
							}
							else
							{
								if(!wrapper.IsAccessibleFrom(clazz))
								{
									throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
								}
								if(wrapper.IsGhost)
								{
									ilGenerator.Emit(OpCodes.Dup);
									// TODO make sure we get the right "Cast" method and cache it
									ilGenerator.Emit(OpCodes.Call, wrapper.Type.GetMethod("Cast"));
									ilGenerator.Emit(OpCodes.Pop);
								}
								else if(wrapper.IsGhostArray)
								{
									string brackets = "[]";
									TypeWrapper element = wrapper.ElementTypeWrapper;
									while(element.IsArray)
									{
										brackets += "[]";
										element = wrapper.ElementTypeWrapper;
									}
									TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(element);
									Type[] implementerTypes = new Type[implementers.Length];
									for(int j = 0; j < implementers.Length; j++)
									{
										implementerTypes[j] = implementers[j].Type.Module.GetType(implementers[j].Type.FullName + brackets);
									}
									Label end = ilGenerator.DefineLabel();
									for(int j = 0; j < implementerTypes.Length; j++)
									{
										ilGenerator.Emit(OpCodes.Dup);
										ilGenerator.Emit(OpCodes.Isinst, implementerTypes[j]);
										ilGenerator.Emit(OpCodes.Brtrue, end);
									}
									// TODO once we "fix" array instantiation this should ever occur
									ilGenerator.Emit(OpCodes.Castclass, wrapper.Type);
									ilGenerator.MarkLabel(end);
								}
								else
								{
									ilGenerator.Emit(OpCodes.Castclass, wrapper.Type);
								}
d1494 1
d1500 1
a1500 1
							if(wrapper.IsUnloadable)
d1502 1
a1502 58
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
								ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
								ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicInstanceOf"));
							}
							else
							{
								if(!wrapper.IsAccessibleFrom(clazz))
								{
									throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
								}
								if(wrapper.IsGhost)
								{
									// TODO make sure we get the right "IsInstance" method and cache it
									ilGenerator.Emit(OpCodes.Call, wrapper.Type.GetMethod("IsInstance"));
								}
								else if(wrapper.IsGhostArray)
								{
									string brackets = "[]";
									TypeWrapper element = wrapper.ElementTypeWrapper;
									while(element.IsArray)
									{
										brackets += "[]";
										element = wrapper.ElementTypeWrapper;
									}
									TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(element);
									Type[] implementerTypes = new Type[implementers.Length];
									for(int j = 0; j < implementers.Length; j++)
									{
										implementerTypes[j] = implementers[j].Type.Module.GetType(implementers[j].Type.FullName + brackets);
									}
									Label end = ilGenerator.DefineLabel();
									for(int j = 0; j < implementerTypes.Length; j++)
									{
										ilGenerator.Emit(OpCodes.Dup);
										ilGenerator.Emit(OpCodes.Isinst, implementerTypes[j]);
										Label label = ilGenerator.DefineLabel();
										ilGenerator.Emit(OpCodes.Brfalse_S, label);
										ilGenerator.Emit(OpCodes.Pop);
										ilGenerator.Emit(OpCodes.Ldc_I4_1);
										ilGenerator.Emit(OpCodes.Br, end);
										ilGenerator.MarkLabel(label);
									}
									// TODO once we "fix" array instantiation this should ever occur
									ilGenerator.Emit(OpCodes.Isinst, wrapper.Type);
									ilGenerator.Emit(OpCodes.Ldnull);
									ilGenerator.Emit(OpCodes.Ceq);
									ilGenerator.Emit(OpCodes.Ldc_I4_0);
									ilGenerator.Emit(OpCodes.Ceq);
									ilGenerator.MarkLabel(end);
								}
								else
								{
									ilGenerator.Emit(OpCodes.Isinst, wrapper.Type);
									ilGenerator.Emit(OpCodes.Ldnull);
									ilGenerator.Emit(OpCodes.Ceq);
									ilGenerator.Emit(OpCodes.Ldc_I4_0);
									ilGenerator.Emit(OpCodes.Ceq);
								}
d1504 1
d1512 1
a1512 1
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
d1521 1
a1521 1
									Type t = elem.Type;
d1581 1
a1581 1
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
d1590 1
a1590 1
									Type t = elem.Type;
d2314 1
a2314 1
						ilGenerator.Emit(OpCodes.Castclass, args[i].Type);
d2355 1
a2355 1
								ilGenerator.Emit(OpCodes.Unbox, args[i].Type);
d2379 1
a2379 1
				ilGenerator.Emit(OpCodes.Box, fieldTypeWrapper.Type);
d2383 1
a2383 1
			ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
d2449 1
a2449 1
									ilGenerator.Emit(OpCodes.Castclass, tw.Type);
d2521 1
a2521 1
					ilGenerator.Emit(OpCodes.Box, args[i].Type);
d2529 1
a2529 1
			ilGenerator.Emit(OpCodes.Ldtoken, wrapper.Type);
d2552 2
a2553 2
			ilgen.Emit(OpCodes.Unbox, typeWrapper.Type);
			ilgen.Emit(OpCodes.Ldobj, typeWrapper.Type);
d2557 1
a2557 1
			ilgen.Emit(OpCodes.Castclass, typeWrapper.Type);
@


1.33
log
@*** empty log message ***
@
text
@a69 1
	private static MethodInfo throwHack = typeof(ExceptionHelper).GetMethod("ThrowHack");
d85 7
a91 8
		ClassLoaderWrapper loader = ClassLoaderWrapper.GetBootstrapClassLoader();
		TypeWrapper exceptionHelper = loader.LoadClassByDottedName("java.lang.ExceptionHelper");
		mapExceptionMethod = exceptionHelper.GetMethodWrapper(MethodDescriptor.FromNameSig(loader, "MapException", "(Ljava.lang.Throwable;Lcli.System.Type;)Ljava.lang.Throwable;"), false).EmitCall;
		mapExceptionFastMethod = exceptionHelper.GetMethodWrapper(MethodDescriptor.FromNameSig(loader, "MapExceptionFast", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"), false).EmitCall;
		fillInStackTraceMethod = exceptionHelper.GetMethodWrapper(MethodDescriptor.FromNameSig(loader, "fillInStackTrace", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"), false).EmitCall;
		java_lang_Throwable = loader.LoadClassByDottedName("java.lang.Throwable");
		java_lang_Object = loader.LoadClassByDottedName("java.lang.Object");
		java_lang_ThreadDeath = loader.LoadClassByDottedName("java.lang.ThreadDeath");
d378 73
a450 1
	private class ReturnCookie
d456 1
a456 1
	private class BranchCookie
d864 1
a864 1
				switch(instr.NormalizedOpCode)
d866 1
a866 11
					case NormalizedByteCode.__getstatic:
					case NormalizedByteCode.__putstatic:
					case NormalizedByteCode.__getfield:
					case NormalizedByteCode.__putfield:
						GetPutField(instr, i);
						break;
					case NormalizedByteCode.__aconst_null:
						ilGenerator.Emit(OpCodes.Ldnull);
						break;
					case NormalizedByteCode.__iconst:
					switch(instr.NormalizedArg1)
d868 5
a872 2
						case -1:
							ilGenerator.Emit(OpCodes.Ldc_I4_M1);
d874 2
a875 26
						case 0:
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							break;
						case 1:
							ilGenerator.Emit(OpCodes.Ldc_I4_1);
							break;
						case 2:
							ilGenerator.Emit(OpCodes.Ldc_I4_2);
							break;
						case 3:
							ilGenerator.Emit(OpCodes.Ldc_I4_3);
							break;
						case 4:
							ilGenerator.Emit(OpCodes.Ldc_I4_4);
							break;
						case 5:
							ilGenerator.Emit(OpCodes.Ldc_I4_5);
							break;
						case 6:
							ilGenerator.Emit(OpCodes.Ldc_I4_6);
							break;
						case 7:
							ilGenerator.Emit(OpCodes.Ldc_I4_7);
							break;
						case 8:
							ilGenerator.Emit(OpCodes.Ldc_I4_8);
d877 2
a878 38
						default:
							if(instr.NormalizedArg1 >= -128 && instr.NormalizedArg1 <= 127)
							{
								ilGenerator.Emit(OpCodes.Ldc_I4_S, (sbyte)instr.NormalizedArg1);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Ldc_I4, instr.NormalizedArg1);
							}
							break;
					}
						break;
					case NormalizedByteCode.__lconst_0:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Conv_I8);
						break;
					case NormalizedByteCode.__lconst_1:
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Conv_I8);
						break;
					case NormalizedByteCode.__fconst_0:
					case NormalizedByteCode.__dconst_0:
						// floats are stored as native size on the stack, so both R4 and R8 are the same
						ilGenerator.Emit(OpCodes.Ldc_R4, 0.0f);
						break;
					case NormalizedByteCode.__fconst_1:
					case NormalizedByteCode.__dconst_1:
						// floats are stored as native size on the stack, so both R4 and R8 are the same
						ilGenerator.Emit(OpCodes.Ldc_R4, 1.0f);
						break;
					case NormalizedByteCode.__fconst_2:
						ilGenerator.Emit(OpCodes.Ldc_R4, 2.0f);
						break;
					case NormalizedByteCode.__ldc:
					{
						ClassFile cf = instr.MethodCode.Method.ClassFile;
						int constant = instr.Arg1;
						switch(cf.GetConstantPoolConstantType(constant))
d880 5
a884 2
							case ClassFile.ConstantType.Double:
								ilGenerator.Emit(OpCodes.Ldc_R8, cf.GetConstantPoolConstantDouble(constant));
d886 11
a896 2
							case ClassFile.ConstantType.Float:
								ilGenerator.Emit(OpCodes.Ldc_R4, cf.GetConstantPoolConstantFloat(constant));
d898 2
a899 2
							case ClassFile.ConstantType.Integer:
								ilGenerator.Emit(OpCodes.Ldc_I4, cf.GetConstantPoolConstantInteger(constant));
d901 2
a902 2
							case ClassFile.ConstantType.Long:
								ilGenerator.Emit(OpCodes.Ldc_I8, cf.GetConstantPoolConstantLong(constant));
d904 5
a908 2
							case ClassFile.ConstantType.String:
								ilGenerator.Emit(OpCodes.Ldstr, cf.GetConstantPoolConstantString(constant));
d911 7
a917 39
								throw new InvalidOperationException();
						}
						break;
					}
					case NormalizedByteCode.__invokestatic:
					{
						ClassFile.ConstantPoolItemFMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
						// HACK special case for calls to System.arraycopy, if the array arguments on the stack
						// are of a known array type, we can redirect to an optimized version of arraycopy.
						// TODO make sure that the java.lang.System we're referring to is in the bootstrap class loader
						if(cpi.Class == "java.lang.System" &&
							cpi.Name == "arraycopy" &&
							cpi.Signature == "(Ljava.lang.Object;ILjava.lang.Object;II)V")
						{
							TypeWrapper t1 = ma.GetRawStackTypeWrapper(i, 2);
							TypeWrapper t2 = ma.GetRawStackTypeWrapper(i, 4);
							if(t1.IsArray && t1 == t2)
							{
								switch(t1.Name[1])
								{
									case 'J':
									case 'D':
										ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_8"));
										break;
									case 'I':
									case 'F':
										ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_4"));
										break;
									case 'S':
									case 'C':
										ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_2"));
										break;
									case 'B':
									case 'Z':
										ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_1"));
										break;
									default:
										ilGenerator.Emit(OpCodes.Call, typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy"));
										break;
d920 46
d967 1
d969 43
a1011 5
						CodeEmitter emitNewobj;
						CodeEmitter emitCall;
						CodeEmitter emitCallvirt;
						if(GetMethodCallEmitter(cpi, null, NormalizedByteCode.__invokestatic, out emitNewobj, out emitCall, out emitCallvirt))
						{
d1016 1
d1018 3
a1020 1
						else
d1022 1
d1024 6
a1029 31
							for(int j = 0; j < argcount; j++)
							{
								ilGenerator.Emit(OpCodes.Pop);
							}
							EmitPlaceholder(cpi.GetRetType(classLoader));
						}
						break;
					}
					case NormalizedByteCode.__invokevirtual:
					case NormalizedByteCode.__invokeinterface:
					case NormalizedByteCode.__invokespecial:
					{
						ClassFile.ConstantPoolItemFMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
						int argcount = cpi.GetArgTypes(classLoader).Length;
						TypeWrapper type = ma.GetRawStackTypeWrapper(i, argcount);
						TypeWrapper thisType = SigTypeToClassName(type, cpi.GetClassType(classLoader));

						// if the stack values don't match the argument types (for interface argument types)
						// we must emit code to cast the stack value to the interface type
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>" && VerifierTypeWrapper.IsNew(type))
						{
							TypeWrapper[] args = cpi.GetArgTypes(classLoader);
							CastInterfaceArgs(args, i, false, false);
						}
						else
						{
							// the this reference is included in the argument list because it may also need to be cast
							TypeWrapper[] methodArgs = cpi.GetArgTypes(classLoader);
							TypeWrapper[] args = new TypeWrapper[methodArgs.Length + 1];
							methodArgs.CopyTo(args, 1);
							if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface)
d1031 2
a1032 1
								args[0] = cpi.GetClassType(classLoader);
d1036 13
a1048 1
								args[0] = thisType;
a1049 2
							CastInterfaceArgs(args, i, true, instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && type != VerifierTypeWrapper.UninitializedThis);
						}
d1051 5
a1055 6
						CodeEmitter emitNewobj = null;
						CodeEmitter emitCall = null;
						CodeEmitter emitCallvirt = null;
						CodeEmitter emit = null;
						if(thisType != null && GetMethodCallEmitter(cpi, thisType, instr.NormalizedOpCode, out emitNewobj, out emitCall, out emitCallvirt))
						{
d1064 1
a1064 4
						}
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>")
						{
							if(VerifierTypeWrapper.IsNew(type))
d1066 1
a1066 1
								if(!thisType.IsUnloadable && (thisType.IsAbstract || thisType.IsInterface))
d1068 8
a1075 15
									// the CLR gets confused when we do a newobj on an abstract class,
									// so we set the emitter to null, to basically just comment out the constructor
									// call (the InstantiationError was already emitted at the "new" bytecode)
									emitNewobj = null;
								}
								// we have to construct a list of all the unitialized references to the object
								// we're about to create on the stack, so that we can reconstruct the stack after
								// the "newobj" instruction
								int trivcount = 0;
								bool nontrivial = false;
								bool[] stackfix = new bool[ma.GetStackHeight(i) - (argcount + 1)];
								bool[] localsfix = new bool[m.MaxLocals];
								for(int j = 0; j < stackfix.Length; j++)
								{
									if(ma.GetRawStackTypeWrapper(i, argcount + 1 + j) == type)
d1077 1
a1077 2
										stackfix[j] = true;
										if(trivcount == j)
d1079 12
a1090 1
											trivcount++;
d1092 4
a1095 1
										else
d1097 1
a1097 3
											// if there is other stuff on the stack between the new object
											// references, we need to do more work to construct the proper stack
											// layout after the newobj instruction
a1100 11
								}
								for(int j = 0; j < localsfix.Length; j++)
								{
									if(ma.GetLocalTypeWrapper(i, j) == type)
									{
										localsfix[j] = true;
										nontrivial = true;
									}
								}
								if(emitNewobj != null)
								{
d1102 1
a1102 4
								}
								else
								{
									for(int j = 0; j < argcount; j++)
d1104 9
a1112 1
										ilGenerator.Emit(OpCodes.Pop);
d1114 1
a1114 8
									ilGenerator.Emit(OpCodes.Ldnull);
								}
								if(!thisType.IsUnloadable && thisType.IsSubTypeOf(java_lang_Throwable))
								{
									// HACK if the next instruction isn't an athrow, we need to
									// call fillInStackTrace, because the object might be used
									// to print out a stack trace without ever being thrown
									if(code[i + 1].NormalizedOpCode != NormalizedByteCode.__athrow)
d1116 27
a1142 16
										ilGenerator.Emit(OpCodes.Dup);
										fillInStackTraceMethod.Emit(ilGenerator);
										ilGenerator.Emit(OpCodes.Pop);
									}
								}
								if(nontrivial)
								{
									// this could be done a little more efficiently, but since in practice this
									// code never runs (for code compiled from Java source) it doesn't
									// really matter
									LocalBuilder newobj = ilGenerator.DeclareLocal(thisType.Type);
									ilGenerator.Emit(OpCodes.Stloc, newobj);
									LocalBuilder[] tempstack = new LocalBuilder[stackfix.Length];
									for(int j = 0; j < stackfix.Length; j++)
									{
										if(!stackfix[j])
d1144 5
a1148 4
											TypeWrapper stacktype = ma.GetRawStackTypeWrapper(i, argcount + 1 + j);
											// it could be another new object reference (not from current invokespecial <init>
											// instruction)
											if(stacktype == VerifierTypeWrapper.Null)
d1150 1
a1150 2
												// TODO handle null stack entries
												throw new NotImplementedException();
d1152 4
a1155 1
											else if(!VerifierTypeWrapper.IsNew(stacktype))
d1157 2
a1158 3
												LocalBuilder lb = ilGenerator.DeclareLocal(stacktype.TypeAsLocalOrStackType);
												ilGenerator.Emit(OpCodes.Stloc, lb);
												tempstack[j] = lb;
d1162 1
a1162 1
									for(int j = stackfix.Length - 1; j >= 0; j--)
d1164 1
a1164 1
										if(stackfix[j])
d1166 1
a1166 1
											ilGenerator.Emit(OpCodes.Ldloc, newobj);
d1168 1
a1168 1
										else if(tempstack[j] != null)
d1170 4
a1173 1
											ilGenerator.Emit(OpCodes.Ldloc, tempstack[j]);
d1176 47
a1222 1
									for(int j = 0; j < localsfix.Length; j++)
d1224 1
a1224 5
										if(localsfix[j])
										{
											ilGenerator.Emit(OpCodes.Ldloc, newobj);
											ilGenerator.Emit(OpCodes.Stloc, GetLocal(typeof(object), j));
										}
d1226 1
d1230 3
a1232 1
									if(trivcount == 0)
d1234 1
a1234 1
										ilGenerator.Emit(OpCodes.Pop);
d1236 1
a1236 1
									else
d1238 3
a1240 1
										for(int j = 1; j < trivcount; j++)
d1242 1
a1242 1
											ilGenerator.Emit(OpCodes.Dup);
d1244 1
d1246 1
d1249 21
d1272 2
a1273 1
								if(emitCall != null)
d1275 6
a1280 1
									emitCall.Emit(ilGenerator);
d1284 4
a1287 15
									// if we're a constructor and the call to the base class constructor
									// wasn't accessible, we need make sure that there is no code path that
									// returns from the constructor, otherwise the method will be not verifiable
									// TODO this isn't anywhere near a proper solution, but for the time being it works
									// some things to consider:
									// - only pull this full when calls to the base class constructor fail
									// - when control flow is complex, this trivial solution will not work
									ilGenerator.Emit(OpCodes.Ldnull);
									ilGenerator.Emit(OpCodes.Throw);
									return;
									//										for(int j = 0; j < argcount + 1; j++)
									//										{
									//											ilGenerator.Emit(OpCodes.Pop);
									//										}
									//										EmitPlaceholder(cpi.Signature.Substring(cpi.Signature.LastIndexOf(')') + 1));
d1290 1
d1292 1
a1292 1
						else
d1294 15
a1308 1
							if(emit != null)
d1310 4
a1313 1
								emit.Emit(ilGenerator);
d1317 1
a1317 1
								for(int j = 0; j < argcount + 1; j++)
d1319 19
a1337 1
									ilGenerator.Emit(OpCodes.Pop);
d1339 1
a1339 1
								EmitPlaceholder(cpi.GetRetType(classLoader));
d1341 1
d1343 25
a1367 10
						break;
					}
					case NormalizedByteCode.__return:
					case NormalizedByteCode.__areturn:
					case NormalizedByteCode.__ireturn:
					case NormalizedByteCode.__lreturn:
					case NormalizedByteCode.__freturn:
					case NormalizedByteCode.__dreturn:
					{
						if(exceptionIndex != 0)
d1369 19
a1387 13
							// if we're inside an exception block, copy TOS to local, emit "leave" and push item onto our "todo" list
							ReturnCookie rc = new ReturnCookie();
							if(instr.NormalizedOpCode != NormalizedByteCode.__return)
							{
								TypeWrapper retTypeWrapper = m.Method.GetRetType(classLoader);
								rc.Local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
								retTypeWrapper.EmitConvStackToParameterType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
								ilGenerator.Emit(OpCodes.Stloc, rc.Local);
							}
							rc.Stub = ilGenerator.DefineLabel();
							// NOTE leave automatically discards any junk that may be on the stack
							ilGenerator.Emit(OpCodes.Leave, rc.Stub);
							exits.Add(rc);
d1389 1
a1389 1
						else
d1391 6
a1396 4
							// if there is junk on the stack (other than the return value), we must pop it off
							// because in .NET this is invalid (unlike in Java)
							int stackHeight = ma.GetStackHeight(i);
							if(instr.NormalizedOpCode == NormalizedByteCode.__return)
d1398 13
a1410 5
								for(int j = 0; j < stackHeight; j++)
								{
									ilGenerator.Emit(OpCodes.Pop);
								}
								ilGenerator.Emit(OpCodes.Ret);
d1414 1
a1414 3
								TypeWrapper retTypeWrapper = m.Method.GetRetType(classLoader);
								retTypeWrapper.EmitConvStackToParameterType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
								if(stackHeight != 1)
d1416 1
a1416 7
									LocalBuilder local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
									ilGenerator.Emit(OpCodes.Stloc, local);
									for(int j = 1; j < stackHeight; j++)
									{
										ilGenerator.Emit(OpCodes.Pop);
									}
									ilGenerator.Emit(OpCodes.Ldloc, local);
d1418 5
a1422 1
								ilGenerator.Emit(OpCodes.Ret);
d1424 1
d1426 1
a1426 6
						break;
					}
					case NormalizedByteCode.__aload:
					{
						TypeWrapper type = ma.GetLocalTypeWrapper(i, instr.NormalizedArg1);
						if(type == VerifierTypeWrapper.Null)
d1428 26
a1453 2
							// if the local is known to be null, we just emit a null
							ilGenerator.Emit(OpCodes.Ldnull);
d1455 2
a1456 1
						else if(VerifierTypeWrapper.IsNew(type))
d1458 27
a1484 1
							// since new objects aren't represented on the stack, we don't need to do anything here
d1486 2
a1487 1
						else if(type == VerifierTypeWrapper.UninitializedThis)
d1489 52
a1540 4
							// any unitialized reference has to be the this reference
							// TODO when we get support for overwriting the this reference, this code
							// needs to be aware of that (or, this overwriting should be handled specially for <init>)
							ilGenerator.Emit(OpCodes.Ldarg_0);
d1542 1
a1542 1
						else
d1544 2
a1545 2
							Load(instr, typeof(object));
							if(instr.NormalizedArg1 >= m.ArgMap.Length)
d1547 3
a1549 6
								// HACK since, for now, all locals are of type object, we've got to cast them to the proper type
								// UPDATE the above is no longer true, we now have at least some idea of the type of the local
								if(type != ma.GetDeclaredLocalTypeWrapper(instr.NormalizedArg1) && !type.IsUnloadable && !type.IsGhost && !type.IsNonPrimitiveValueType)
								{
									ilGenerator.Emit(OpCodes.Castclass, type.Type);
								}
d1553 52
a1604 4
								// HACK we're boxing the arguments when they are loaded, this is inconsistent
								// with the way locals are treated, so we probably should only box the arguments
								// once (on method entry)
								type.EmitConvParameterToStackType(ilGenerator);
d1606 1
d1608 1
a1608 7
						break;
					}
					case NormalizedByteCode.__astore:
					{
						TypeWrapper type = ma.GetRawStackTypeWrapper(i, 0);
						// HACK we use "int" to track the return address of a jsr
						if(VerifierTypeWrapper.IsRet(type))
d1610 8
a1617 20
							Store(instr, typeof(int));
						}
						else if(VerifierTypeWrapper.IsNew(type))
						{
							// NOTE new objects aren't really on the stack, so we can't copy them into the local.
							// We do store a null in the local, to prevent it from retaining an unintentional reference
							// to whatever object reference happens to be there
							ilGenerator.Emit(OpCodes.Ldnull);
							Store(instr, typeof(object));
						}
						else if(type == VerifierTypeWrapper.UninitializedThis)
						{
							// any unitialized reference is always the this reference, we don't store anything
							// here (because CLR won't allow unitialized references in locals) and then when
							// the unitialized ref is loaded we redirect to the this reference
							ilGenerator.Emit(OpCodes.Pop);
						}
						else
						{
							if(instr.NormalizedArg1 < m.ArgMap.Length)
d1619 9
a1627 1
								if(type != VerifierTypeWrapper.Null)
d1629 1
a1629 1
									type.EmitConvStackToParameterType(ilGenerator, type);
d1632 1
a1632 1
							Store(instr, typeof(object));
d1634 23
a1656 57
						break;
					}
					case NormalizedByteCode.__iload:
						Load(instr, typeof(int));
						break;
					case NormalizedByteCode.__istore:
						Store(instr, typeof(int));
						break;
					case NormalizedByteCode.__lload:
						Load(instr, typeof(long));
						break;
					case NormalizedByteCode.__lstore:
						Store(instr, typeof(long));
						break;
					case NormalizedByteCode.__fload:
						Load(instr, typeof(float));
						break;
					case NormalizedByteCode.__fstore:
						Store(instr, typeof(float));
						break;
					case NormalizedByteCode.__dload:
						Load(instr, typeof(double));
						break;
					case NormalizedByteCode.__dstore:
						Store(instr, typeof(double));
						break;
					case NormalizedByteCode.__new:
					{
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(wrapper.IsUnloadable)
						{
							// this is here to make sure we throw the exception in the right location (before
							// evaluating the constructor arguments)
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicLoadClass"));
						}
						else if(wrapper.IsAbstract || wrapper.IsInterface)
						{
							EmitError("java.lang.InstantiationError", wrapper.Name);
						}
						// we don't do anything here, the call to <init> will be converted into a newobj instruction
						break;
					}
					case NormalizedByteCode.__multianewarray:
					{
						LocalBuilder localArray = ilGenerator.DeclareLocal(typeof(int[]));
						LocalBuilder localInt = ilGenerator.DeclareLocal(typeof(int));
						ilGenerator.Emit(OpCodes.Ldc_I4, instr.Arg2);
						ilGenerator.Emit(OpCodes.Newarr, typeof(int));
						ilGenerator.Emit(OpCodes.Stloc, localArray);
						for(int j = 1; j <= instr.Arg2; j++)
						{
							ilGenerator.Emit(OpCodes.Stloc, localInt);
							ilGenerator.Emit(OpCodes.Ldloc, localArray);
							ilGenerator.Emit(OpCodes.Ldc_I4, instr.Arg2 - j);
							ilGenerator.Emit(OpCodes.Ldloc, localInt);
a1657 49
						}
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(wrapper.IsUnloadable)
						{
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Ldloc, localArray);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicMultianewarray"));
						}
						else
						{
							Type type = wrapper.TypeAsArrayType;
							ilGenerator.Emit(OpCodes.Ldtoken, type);
							ilGenerator.Emit(OpCodes.Ldloc, localArray);
							ilGenerator.Emit(OpCodes.Call, multiANewArrayMethod);
							ilGenerator.Emit(OpCodes.Castclass, type);
						}
						break;
					}
					case NormalizedByteCode.__anewarray:
					{
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(wrapper.IsUnloadable)
						{
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicNewarray"));
						}
						else
						{
							// NOTE for ghost types we create object arrays to make sure that Ghost implementers can be
							// stored in ghost arrays, but this has the unintended consequence that ghost arrays can
							// contain *any* reference type (because they are compiled as Object arrays). We could
							// modify aastore to emit code to check for this, but this would have an huge performance
							// cost for all object arrays.
							// Oddly, while the JVM accepts any reference for any other interface typed references, in the
							// case of aastore it does check that the object actually implements the interface. This
							// is unfortunate, but I think we can live with this minor incompatibility.
							// NOTE that this does not break type safety, because when the incorrect object is eventually
							// used as the ghost interface type it will generate a ClassCastException.
							ilGenerator.Emit(OpCodes.Newarr, wrapper.TypeAsArrayType);
						}
						break;
					}
					case NormalizedByteCode.__newarray:
					switch(instr.Arg1)
					{
						case 4:
							ilGenerator.Emit(OpCodes.Newarr, typeof(bool));
d1659 2
a1660 2
						case 5:
							ilGenerator.Emit(OpCodes.Newarr, typeof(char));
d1662 2
a1663 2
						case 6:
							ilGenerator.Emit(OpCodes.Newarr, typeof(float));
d1665 2
a1666 2
						case 7:
							ilGenerator.Emit(OpCodes.Newarr, typeof(double));
d1668 2
a1669 2
						case 8:
							ilGenerator.Emit(OpCodes.Newarr, typeof(sbyte));
d1671 2
a1672 2
						case 9:
							ilGenerator.Emit(OpCodes.Newarr, typeof(short));
d1674 2
a1675 2
						case 10:
							ilGenerator.Emit(OpCodes.Newarr, typeof(int));
d1677 27
a1703 2
						case 11:
							ilGenerator.Emit(OpCodes.Newarr, typeof(long));
a1704 13
						default:
							// this can't happen, the verifier would have caught it
							throw new InvalidOperationException();
					}
						break;
					case NormalizedByteCode.__checkcast:
					{
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(wrapper.IsUnloadable)
						{
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicCast"));
d1706 2
a1707 12
						else if(wrapper.IsGhost)
						{
							ilGenerator.Emit(OpCodes.Dup);
							// TODO make sure we get the right "Cast" method and cache it
							ilGenerator.Emit(OpCodes.Call, wrapper.Type.GetMethod("Cast"));
							ilGenerator.Emit(OpCodes.Pop);
						}
						else if(wrapper.IsGhostArray)
						{
							string brackets = "[]";
							TypeWrapper element = wrapper.ElementTypeWrapper;
							while(element.IsArray)
d1709 2
a1710 2
								brackets += "[]";
								element = wrapper.ElementTypeWrapper;
d1712 1
a1712 3
							TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(element);
							Type[] implementerTypes = new Type[implementers.Length];
							for(int j = 0; j < implementers.Length; j++)
d1714 1
a1714 1
								implementerTypes[j] = implementers[j].Type.Module.GetType(implementers[j].Type.FullName + brackets);
d1716 16
d1733 6
a1738 8
							for(int j = 0; j < implementerTypes.Length; j++)
							{
								ilGenerator.Emit(OpCodes.Dup);
								ilGenerator.Emit(OpCodes.Isinst, implementerTypes[j]);
								ilGenerator.Emit(OpCodes.Brtrue, end);
							}
							// TODO once we "fix" array instantiation this should ever occur
							ilGenerator.Emit(OpCodes.Castclass, wrapper.Type);
d1740 1
d1742 1
a1742 1
						else
d1744 22
a1765 1
							ilGenerator.Emit(OpCodes.Castclass, wrapper.Type);
d1767 1
a1767 6
						break;
					}
					case NormalizedByteCode.__instanceof:
					{
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
						if(wrapper.IsUnloadable)
d1769 22
a1790 3
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicInstanceOf"));
d1792 1
a1792 1
						else if(wrapper.IsGhost)
d1794 22
a1815 2
							// TODO make sure we get the right "IsInstance" method and cache it
							ilGenerator.Emit(OpCodes.Call, wrapper.Type.GetMethod("IsInstance"));
d1817 1
a1817 1
						else if(wrapper.IsGhostArray)
d1819 13
a1831 13
							string brackets = "[]";
							TypeWrapper element = wrapper.ElementTypeWrapper;
							while(element.IsArray)
							{
								brackets += "[]";
								element = wrapper.ElementTypeWrapper;
							}
							TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(element);
							Type[] implementerTypes = new Type[implementers.Length];
							for(int j = 0; j < implementers.Length; j++)
							{
								implementerTypes[j] = implementers[j].Type.Module.GetType(implementers[j].Type.FullName + brackets);
							}
d1833 5
a1837 15
							for(int j = 0; j < implementerTypes.Length; j++)
							{
								ilGenerator.Emit(OpCodes.Dup);
								ilGenerator.Emit(OpCodes.Isinst, implementerTypes[j]);
								Label label = ilGenerator.DefineLabel();
								ilGenerator.Emit(OpCodes.Brfalse_S, label);
								ilGenerator.Emit(OpCodes.Pop);
								ilGenerator.Emit(OpCodes.Ldc_I4_1);
								ilGenerator.Emit(OpCodes.Br, end);
								ilGenerator.MarkLabel(label);
							}
							// TODO once we "fix" array instantiation this should ever occur
							ilGenerator.Emit(OpCodes.Isinst, wrapper.Type);
							ilGenerator.Emit(OpCodes.Ldnull);
							ilGenerator.Emit(OpCodes.Ceq);
a1838 1
							ilGenerator.Emit(OpCodes.Ceq);
d1840 1
d1842 39
a1880 5
						else
						{
							ilGenerator.Emit(OpCodes.Isinst, wrapper.Type);
							ilGenerator.Emit(OpCodes.Ldnull);
							ilGenerator.Emit(OpCodes.Ceq);
d1882 62
a1943 17
							ilGenerator.Emit(OpCodes.Ceq);
						}
						break;
					}
					case NormalizedByteCode.__aaload:
					{
						TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 1);
						if(tw.IsUnloadable)
						{
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
							ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAaload"));
						}
						else
						{
							TypeWrapper elem = tw.ElementTypeWrapper;
							if(elem.IsNonPrimitiveValueType)
d1945 1
a1945 8
								Type t = elem.Type;
								ilGenerator.Emit(OpCodes.Ldelema, t);
								ilGenerator.Emit(OpCodes.Ldobj, t);
								elem.EmitBox(ilGenerator);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Ldelem_Ref);
d1947 10
d1958 6
a1963 49
						break;
					}
					case NormalizedByteCode.__baload:
						// NOTE both the JVM and the CLR use signed bytes for boolean arrays (how convenient!)
						ilGenerator.Emit(OpCodes.Ldelem_I1);
						break;
					case NormalizedByteCode.__bastore:
						ilGenerator.Emit(OpCodes.Stelem_I1);
						break;
					case NormalizedByteCode.__caload:
						ilGenerator.Emit(OpCodes.Ldelem_U2);
						break;
					case NormalizedByteCode.__castore:
						ilGenerator.Emit(OpCodes.Stelem_I2);
						break;
					case NormalizedByteCode.__saload:
						ilGenerator.Emit(OpCodes.Ldelem_I2);
						break;
					case NormalizedByteCode.__sastore:
						ilGenerator.Emit(OpCodes.Stelem_I2);
						break;
					case NormalizedByteCode.__iaload:
						ilGenerator.Emit(OpCodes.Ldelem_I4);
						break;
					case NormalizedByteCode.__iastore:
						ilGenerator.Emit(OpCodes.Stelem_I4);
						break;
					case NormalizedByteCode.__laload:
						ilGenerator.Emit(OpCodes.Ldelem_I8);
						break;
					case NormalizedByteCode.__lastore:
						ilGenerator.Emit(OpCodes.Stelem_I8);
						break;
					case NormalizedByteCode.__faload:
						ilGenerator.Emit(OpCodes.Ldelem_R4);
						break;
					case NormalizedByteCode.__fastore:
						ilGenerator.Emit(OpCodes.Stelem_R4);
						break;
					case NormalizedByteCode.__daload:
						ilGenerator.Emit(OpCodes.Ldelem_R8);
						break;
					case NormalizedByteCode.__dastore:
						ilGenerator.Emit(OpCodes.Stelem_R8);
						break;
					case NormalizedByteCode.__aastore:
					{
						TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 2);
						if(tw.IsUnloadable)
d1965 7
a1971 8
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.Type);
							ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAastore"));
						}
						else
						{
							TypeWrapper elem = tw.ElementTypeWrapper;
							if(elem.IsNonPrimitiveValueType)
d1973 1
a1973 7
								Type t = elem.Type;
								LocalBuilder local = ilGenerator.DeclareLocal(typeof(object));
								ilGenerator.Emit(OpCodes.Stloc, local);
								ilGenerator.Emit(OpCodes.Ldelema, t);
								ilGenerator.Emit(OpCodes.Ldloc, local);
								elem.EmitUnbox(ilGenerator);
								ilGenerator.Emit(OpCodes.Stobj, t);
d1975 6
a1980 1
							else
d1982 1
a1982 1
								ilGenerator.Emit(OpCodes.Stelem_Ref);
d1984 6
d1991 17
a2007 321
						break;
					}
					case NormalizedByteCode.__arraylength:
						ilGenerator.Emit(OpCodes.Ldlen);
						break;
					case NormalizedByteCode.__lcmp:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(long));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(long));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bgt_S, res1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res1);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__fcmpl:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(float));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(float));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bgt_S, res1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res1);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__fcmpg:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(float));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(float));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label resm1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Blt_S, resm1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(resm1);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__dcmpl:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(double));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(double));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bgt_S, res1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res1);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__dcmpg:
					{
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(double));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(double));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label resm1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Blt, resm1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br, end);
						ilGenerator.MarkLabel(resm1);
						ilGenerator.Emit(OpCodes.Ldc_I4, -1);
						ilGenerator.Emit(OpCodes.Br, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						break;
					}
					case NormalizedByteCode.__if_icmpeq:
						ilGenerator.Emit(OpCodes.Beq, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__if_icmpne:
						ilGenerator.Emit(OpCodes.Bne_Un, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__if_icmple:
						ilGenerator.Emit(OpCodes.Ble, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__if_icmplt:
						ilGenerator.Emit(OpCodes.Blt, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__if_icmpge:
						ilGenerator.Emit(OpCodes.Bge, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__if_icmpgt:
						ilGenerator.Emit(OpCodes.Bgt, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__ifle:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Ble, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__iflt:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Blt, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__ifge:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Bge, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__ifgt:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Bgt, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__ifne:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Bne_Un, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__ifeq:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Beq, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__ifnonnull:
						ilGenerator.Emit(OpCodes.Brtrue, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__ifnull:
						ilGenerator.Emit(OpCodes.Brfalse, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__if_acmpeq:
						ilGenerator.Emit(OpCodes.Beq, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__if_acmpne:
						ilGenerator.Emit(OpCodes.Bne_Un, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__goto:
						ilGenerator.Emit(OpCodes.Br, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__ineg:
					case NormalizedByteCode.__lneg:
					case NormalizedByteCode.__fneg:
					case NormalizedByteCode.__dneg:
						ilGenerator.Emit(OpCodes.Neg);
						break;
					case NormalizedByteCode.__iadd:
					case NormalizedByteCode.__ladd:
					case NormalizedByteCode.__fadd:
					case NormalizedByteCode.__dadd:
						ilGenerator.Emit(OpCodes.Add);
						break;
					case NormalizedByteCode.__isub:
					case NormalizedByteCode.__lsub:
					case NormalizedByteCode.__fsub:
					case NormalizedByteCode.__dsub:
						ilGenerator.Emit(OpCodes.Sub);
						break;
					case NormalizedByteCode.__ixor:
					case NormalizedByteCode.__lxor:
						ilGenerator.Emit(OpCodes.Xor);
						break;
					case NormalizedByteCode.__ior:
					case NormalizedByteCode.__lor:
						ilGenerator.Emit(OpCodes.Or);
						break;
					case NormalizedByteCode.__iand:
					case NormalizedByteCode.__land:
						ilGenerator.Emit(OpCodes.And);
						break;
					case NormalizedByteCode.__imul:
					case NormalizedByteCode.__lmul:
					case NormalizedByteCode.__fmul:
					case NormalizedByteCode.__dmul:
						ilGenerator.Emit(OpCodes.Mul);
						break;
					case NormalizedByteCode.__idiv:
					case NormalizedByteCode.__ldiv:
					{
						// we need to special case dividing by -1, because the CLR div instruction
						// throws an OverflowException when dividing Int32.MinValue by -1, and
						// Java just silently overflows
						ilGenerator.Emit(OpCodes.Dup);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						if(instr.NormalizedOpCode == NormalizedByteCode.__ldiv)
						{
							ilGenerator.Emit(OpCodes.Conv_I8);
						}
						Label label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bne_Un_S, label);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Neg);
						Label label2 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, label2);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Div);
						ilGenerator.MarkLabel(label2);
						break;
					}
					case NormalizedByteCode.__fdiv:
					case NormalizedByteCode.__ddiv:
						ilGenerator.Emit(OpCodes.Div);
						break;
					case NormalizedByteCode.__irem:
					case NormalizedByteCode.__lrem:
					{
						// we need to special case taking the remainder of dividing by -1,
						// because the CLR rem instruction throws an OverflowException when
						// taking the remainder of dividing Int32.MinValue by -1, and
						// Java just silently overflows
						ilGenerator.Emit(OpCodes.Dup);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
						{
							ilGenerator.Emit(OpCodes.Conv_I8);
						}
						Label label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bne_Un_S, label);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
						{
							ilGenerator.Emit(OpCodes.Conv_I8);
						}
						Label label2 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, label2);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Rem);
						ilGenerator.MarkLabel(label2);
						break;
					}
					case NormalizedByteCode.__frem:
					case NormalizedByteCode.__drem:
						ilGenerator.Emit(OpCodes.Rem);
						break;
					case NormalizedByteCode.__ishl:
					case NormalizedByteCode.__lshl:
						ilGenerator.Emit(OpCodes.Shl);
						break;
					case NormalizedByteCode.__iushr:
					case NormalizedByteCode.__lushr:
						ilGenerator.Emit(OpCodes.Shr_Un);
						break;
					case NormalizedByteCode.__ishr:
					case NormalizedByteCode.__lshr:
						ilGenerator.Emit(OpCodes.Shr);
						break;
					case NormalizedByteCode.__swap:
					{
						DupHelper dh = new DupHelper(ilGenerator, 2);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.Store(0);
						dh.Store(1);
						dh.Load(0);
						dh.Load(1);
						break;
					}
					case NormalizedByteCode.__dup:
						// if the TOS contains a "new" object, it isn't really there, so we don't dup it
						if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
						{
							ilGenerator.Emit(OpCodes.Dup);
						}
						break;
					case NormalizedByteCode.__dup2:
					{
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						if(type1.IsWidePrimitive)
						{
							ilGenerator.Emit(OpCodes.Dup);
						}
						else
d2010 1
a2010 41
							dh.SetType(0, type1);
							dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
							dh.Store(0);
							dh.Store(1);
							dh.Load(1);
							dh.Load(0);
							dh.Load(1);
							dh.Load(0);
						}
						break;
					}
					case NormalizedByteCode.__dup_x1:
					{
						DupHelper dh = new DupHelper(ilGenerator, 2);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.Store(0);
						dh.Store(1);
						dh.Load(0);
						dh.Load(1);
						dh.Load(0);
						break;
					}
					case NormalizedByteCode.__dup2_x1:
					{
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						if(type1.IsWidePrimitive)
						{
							DupHelper dh = new DupHelper(ilGenerator, 2);
							dh.SetType(0, type1);
							dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
							dh.Store(0);
							dh.Store(1);
							dh.Load(0);
							dh.Load(1);
							dh.Load(0);
						}
						else
						{
							DupHelper dh = new DupHelper(ilGenerator, 3);
							dh.SetType(0, type1);
a2011 1
							dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
a2013 2
							dh.Store(2);
							dh.Load(1);
a2014 1
							dh.Load(2);
d2016 1
a2016 1
							dh.Load(0);
d2018 8
a2025 7
						break;
					}
					case NormalizedByteCode.__dup2_x2:
					{
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						TypeWrapper type2 = ma.GetRawStackTypeWrapper(i, 1);
						if(type1.IsWidePrimitive)
d2027 2
a2028 1
							if(type2.IsWidePrimitive)
d2030 1
a2030 9
								// Form 4
								DupHelper dh = new DupHelper(ilGenerator, 2);
								dh.SetType(0, type1);
								dh.SetType(1, type2);
								dh.Store(0);
								dh.Store(1);
								dh.Load(0);
								dh.Load(1);
								dh.Load(0);
d2034 1
a2034 2
								// Form 2
								DupHelper dh = new DupHelper(ilGenerator, 3);
d2036 1
a2036 2
								dh.SetType(1, type2);
								dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
d2039 1
a2039 1
								dh.Store(2);
a2040 1
								dh.Load(2);
d2044 13
d2058 1
a2058 1
						else
d2060 2
a2061 2
							TypeWrapper type3 = ma.GetRawStackTypeWrapper(i, 2);
							if(type3.IsWidePrimitive)
d2063 1
a2063 2
								// Form 3
								DupHelper dh = new DupHelper(ilGenerator, 3);
d2065 1
a2065 2
								dh.SetType(1, type2);
								dh.SetType(2, type3);
a2067 2
								dh.Store(2);
								dh.Load(1);
a2068 1
								dh.Load(2);
d2074 1
a2074 2
								// Form 1
								DupHelper dh = new DupHelper(ilGenerator, 4);
d2076 2
a2077 3
								dh.SetType(1, type2);
								dh.SetType(2, type3);
								dh.SetType(3, ma.GetRawStackTypeWrapper(i, 3));
a2080 1
								dh.Store(3);
a2082 1
								dh.Load(3);
d2087 76
d2164 1
a2164 21
						break;
					}
					case NormalizedByteCode.__dup_x2:
					{
						DupHelper dh = new DupHelper(ilGenerator, 3);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
						dh.Store(0);
						dh.Store(1);
						dh.Store(2);
						dh.Load(0);
						dh.Load(2);
						dh.Load(1);
						dh.Load(0);
						break;
					}
					case NormalizedByteCode.__pop2:
					{
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						if(type1.IsWidePrimitive)
d2166 12
a2177 1
							ilGenerator.Emit(OpCodes.Pop);
d2179 1
a2179 1
						else
d2181 21
a2201 1
							if(!VerifierTypeWrapper.IsNew(type1))
d2205 13
a2217 1
							if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 1)))
d2219 4
d2224 2
a2226 7
						}
						break;
					}
					case NormalizedByteCode.__pop:
						// if the TOS is a new object, it isn't really there, so we don't need to pop it
						if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
						{
d2228 46
a2273 14
						}
						break;
					case NormalizedByteCode.__monitorenter:
						ilGenerator.Emit(OpCodes.Call, monitorEnterMethod);
						break;
					case NormalizedByteCode.__monitorexit:
						ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
						break;
					case NormalizedByteCode.__athrow:
						ilGenerator.Emit(OpCodes.Throw);
						break;
					case NormalizedByteCode.__lookupswitch:
						// TODO use OpCodes.Switch
						for(int j = 0; j < instr.Values.Length; j++)
d2275 12
a2286 7
							ilGenerator.Emit(OpCodes.Dup);
							ilGenerator.Emit(OpCodes.Ldc_I4, instr.Values[j]);
							Label label = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Bne_Un, label);
							ilGenerator.Emit(OpCodes.Pop);
							ilGenerator.Emit(OpCodes.Br, GetLabel(labels, instr.PC + instr.TargetOffsets[j], inuse, rangeBegin, rangeEnd, exits));
							ilGenerator.MarkLabel(label);
d2288 1
a2288 51
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Br, GetLabel(labels, instr.PC + instr.DefaultOffset, inuse, rangeBegin, rangeEnd, exits));
						break;
					case NormalizedByteCode.__iinc:
						Load(instr, typeof(int));
						ilGenerator.Emit(OpCodes.Ldc_I4, instr.Arg2);
						ilGenerator.Emit(OpCodes.Add);
						Store(instr, typeof(int));
						break;
					case NormalizedByteCode.__i2b:
						ilGenerator.Emit(OpCodes.Conv_I1);
						break;
					case NormalizedByteCode.__i2c:
						ilGenerator.Emit(OpCodes.Conv_U2);
						break;
					case NormalizedByteCode.__i2s:
						ilGenerator.Emit(OpCodes.Conv_I2);
						break;
					case NormalizedByteCode.__l2i:
						ilGenerator.Emit(OpCodes.Conv_I4);
						break;
					case NormalizedByteCode.__f2i:
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("f2i"));
						break;
					case NormalizedByteCode.__d2i:
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("d2i"));
						break;
					case NormalizedByteCode.__f2l:
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("f2l"));
						break;
					case NormalizedByteCode.__d2l:
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("d2l"));
						break;
					case NormalizedByteCode.__i2l:
						ilGenerator.Emit(OpCodes.Conv_I8);
						break;
					case NormalizedByteCode.__i2f:
					case NormalizedByteCode.__l2f:
					case NormalizedByteCode.__d2f:
						ilGenerator.Emit(OpCodes.Conv_R4);
						break;
					case NormalizedByteCode.__i2d:
					case NormalizedByteCode.__l2d:
					case NormalizedByteCode.__f2d:
						ilGenerator.Emit(OpCodes.Conv_R8);
						break;
					case NormalizedByteCode.__jsr:
					{
						int index = FindPcIndex(instr.PC + instr.Arg1);
						int[] callsites = ma.GetCallSites(index);
						for(int j = 0; j < callsites.Length; j++)
d2290 5
a2294 1
							if(callsites[j] == i)
d2296 1
d2298 1
a2298 1
								break;
d2300 2
d2303 5
a2307 2
						ilGenerator.Emit(OpCodes.Br, GetLabel(labels, instr.PC + instr.Arg1, inuse, rangeBegin, rangeEnd, exits));
						break;
d2309 2
a2310 1
					case NormalizedByteCode.__ret:
d2312 30
a2341 12
						// NOTE using a OpCodes.Switch here is not efficient, because 99 out of a 100 cases
						// there are either one or two call sites.
						int subid = ((VerifierTypeWrapper)ma.GetLocalTypeWrapper(i, instr.Arg1)).Index;
						int[] callsites = ma.GetCallSites(subid);
						for(int j = 0; j < callsites.Length - 1; j++)
						{
							Load(instr, typeof(int));
							ilGenerator.Emit(OpCodes.Ldc_I4, j);
							ilGenerator.Emit(OpCodes.Beq, GetLabel(labels, m.Instructions[callsites[j] + 1].PC, inuse, rangeBegin, rangeEnd, exits));
						}
						ilGenerator.Emit(OpCodes.Br, GetLabel(labels, m.Instructions[callsites[callsites.Length - 1] + 1].PC, inuse, rangeBegin, rangeEnd, exits));
						break;
a2342 5
					case NormalizedByteCode.__nop:
						ilGenerator.Emit(OpCodes.Nop);
						break;
					default:
						throw new NotImplementedException(instr.NormalizedOpCode.ToString());
d2344 1
a2344 2
				// mark next instruction as inuse
				switch(instr.NormalizedOpCode)
d2346 1
a2346 30
					case NormalizedByteCode.__lookupswitch:
					case NormalizedByteCode.__goto:
					case NormalizedByteCode.__jsr:
					case NormalizedByteCode.__ret:
					case NormalizedByteCode.__ireturn:
					case NormalizedByteCode.__lreturn:
					case NormalizedByteCode.__freturn:
					case NormalizedByteCode.__dreturn:
					case NormalizedByteCode.__areturn:
					case NormalizedByteCode.__return:
					case NormalizedByteCode.__athrow:
						break;
					default:
						// don't fall through end of try block
						if(m.Instructions[i + 1].PC == rangeEnd)
						{
							// TODO instead of emitting a branch to the leave stub, it would be more efficient to put the leave stub here
							ilGenerator.Emit(OpCodes.Br, GetLabel(labels, m.Instructions[i + 1].PC, inuse, rangeBegin, rangeEnd, exits));
						}
						else
						{
							inuse[i + 1] = true;
							if(done[i + 1])
							{
								// since we've already processed the code that is supposed to come next, we have
								// to emit a branch to it
								ilGenerator.Emit(OpCodes.Br, GetLabel(labels, m.Instructions[i + 1].PC, inuse, rangeBegin, rangeEnd, exits));
							}
						}
						break;
d2384 7
d2400 6
a2405 1
				dh.SetType(i, ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i));
a2406 1
			// TODO instead of an InvalidCastException, the castclass should throw a IncompatibleClassChangeError
d2409 1
a2409 1
				if(!args[i].IsUnloadable && args[i].IsInterfaceOrInterfaceArray)
d2412 1
a2412 1
					if(!tw.IsUnloadable && !tw.IsAssignableTo(args[i]))
d2414 1
d2446 1
a2446 1
					if(!args[i].IsUnloadable && args[i].IsNonPrimitiveValueType)
d2448 1
a2448 1
						if(i != 0 || !instanceMethod)
d2450 8
a2457 1
							args[i].EmitUnbox(ilGenerator);
d2459 1
a2459 1
						else
d2461 1
a2461 1
							ilGenerator.Emit(OpCodes.Unbox, args[i].Type);
d2507 4
d2535 1
a2535 1
							EmitError("java.lang.IllegalAccessError", "Field " + field.DeclaringType.Name + "." + field.Name + " is final");
d2547 2
a2548 9
								int stackpos = (bytecode == NormalizedByteCode.__putstatic) ? 0 : 1;
								TypeWrapper obj = ma.GetRawStackTypeWrapper(i, stackpos);
								// NOTE since we support putfield on an unitialized this, we need to substitute
								// that, if we encounter it.
								if(obj == VerifierTypeWrapper.UninitializedThis)
								{
									obj = this.clazz;
								}
								if(!tw.IsUnloadable && tw.IsInterfaceOrInterfaceArray && !tw.IsGhost && !obj.IsAssignableTo(tw))
d2559 1
a2559 1
						EmitError("java.lang.IllegalAccessError", "Try to access field " + field.DeclaringType.Name + "." + field.Name + " from class " + clazz.Name);
d2564 1
a2564 1
					EmitError("java.lang.IncompatibleClassChangeError", null);
d2569 1
a2569 1
				EmitError("java.lang.NoSuchFieldError", cpi.Class + "." + cpi.Name);
a2571 17
		switch(bytecode)
		{
			case NormalizedByteCode.__getfield:
				ilGenerator.Emit(OpCodes.Pop);
				EmitPlaceholder(cpi.GetFieldType(classLoader));
				break;
			case NormalizedByteCode.__putfield:
				ilGenerator.Emit(OpCodes.Pop);
				ilGenerator.Emit(OpCodes.Pop);
				break;;
			case NormalizedByteCode.__getstatic:
				EmitPlaceholder(cpi.GetFieldType(classLoader));
				break;
			case NormalizedByteCode.__putstatic:
				ilGenerator.Emit(OpCodes.Pop);
				break;;
		}
d2662 1
a2662 1
	private bool GetMethodCallEmitter(ClassFile.ConstantPoolItemFMI cpi, TypeWrapper thisType, NormalizedByteCode invoke, out CodeEmitter emitNewobj, out CodeEmitter emitCall, out CodeEmitter emitCallvirt)
a2663 2
		// TODO when there is an error resolving a call to the super class constructor (in the constructor of this type),
		// we cannot use EmitError, because that will yield an invalid constructor (that doesn't call the superclass constructor)
d2665 1
a2665 1
		if(wrapper.IsUnloadable)
d2674 1
a2674 1
				// NOTE I don't think we need this one to be dynamic, because it is only used to call
d2676 1
a2676 1
				emitCall = CodeEmitter.NoClassDefFoundError(cpi.Class);
d2679 1
a2679 1
			return true;
d2683 1
a2683 1
			if(wrapper.IsInterface != (invoke == NormalizedByteCode.__invokeinterface))
d2685 5
a2689 1
				EmitError("java.lang.IncompatibleClassChangeError", null);
d2705 1
a2705 1
						method = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Object").GetMethodWrapper(md, false);
d2723 1
a2723 1
							EmitError("java.lang.AbstractMethodError", cpi.Class + "." + cpi.Name + cpi.Signature);
d2733 1
a2733 1
							return true;
d2748 1
a2748 1
									return true;
d2751 1
a2751 1
							EmitError("java.lang.IllegalAccessError", "Try to access method " + method.DeclaringType.Name + "." + cpi.Name + cpi.Signature + " from class " + clazz.Name);
d2756 1
a2756 1
						EmitError("java.lang.IncompatibleClassChangeError", null);
d2761 1
a2761 1
					EmitError("java.lang.NoSuchMethodError", cpi.Class + "." + cpi.Name + cpi.Signature);
a2764 57
		emitNewobj = null;
		emitCall = null;
		emitCallvirt = null;
		return false;
	}

	private void EmitError(string errorType, string message)
	{
		if(message != null)
		{
			if(JVM.IsStaticCompiler)
			{
				Console.Error.WriteLine(errorType + ": " + message);
				Console.Error.WriteLine("\tat " + m.Method.ClassFile.Name + "." + m.Method.Name + m.Method.Signature);
			}
			ilGenerator.Emit(OpCodes.Ldstr, message);
			TypeWrapper type = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(errorType);
			MethodWrapper method = type.GetMethodWrapper(MethodDescriptor.FromNameSig(type.GetClassLoader(), "<init>", "(Ljava.lang.String;)V"), false);
			method.EmitNewobj.Emit(ilGenerator);
		}
		else
		{
			if(JVM.IsStaticCompiler)
			{
				Console.Error.WriteLine(errorType);
				Console.Error.WriteLine("\tat " + m.Method.ClassFile.Name + "." + m.Method.Name + m.Method.Signature);
			}
			TypeWrapper type = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(errorType);
			MethodWrapper method = type.GetMethodWrapper(MethodDescriptor.FromNameSig(type.GetClassLoader(), "<init>", "()V"), false);
			method.EmitNewobj.Emit(ilGenerator);
		}
		// we emit a call to ThrowHack instead of a throw instruction, because otherwise the verifier will know
		// that execution won't continue at the next instruction, and the emitted code won't be verifiable
		ilGenerator.Emit(OpCodes.Call, throwHack);
	}

	// TODO since I no longer use LoadClass, I need to go back to each instruction and add a check to make sure
	// the class is accessible from this class
	private TypeWrapper unused__LoadClass(string classname)
	{
		try
		{
			TypeWrapper type = classLoader.LoadClassByDottedName(classname);
			if(!type.IsPublic && !clazz.IsInSamePackageAs(type))
			{
				// TODO all classnames in error messages should be dotted instead of slashed
				EmitError("java.lang.IllegalAccessError", "Try to access class " + classname + " from class " + clazz.Name);
				return null;
			}
			return type;
		}
		catch(Exception)
		{
			// TODO we should freeze the exception here, instead of always throwing a NoClassDefFoundError
			EmitError("java.lang.NoClassDefFoundError", classname);
			return null;
		}
a2784 29
		}
	}

	private void EmitPlaceholder(TypeWrapper type)
	{
		if(type.IsIntOnStackPrimitive)
		{
			ilGenerator.Emit(OpCodes.Ldc_I4_0);
		}
		else if(type == PrimitiveTypeWrapper.LONG)
		{
			ilGenerator.Emit(OpCodes.Ldc_I4_0);
			ilGenerator.Emit(OpCodes.Conv_I8);
		}
		else if(type == PrimitiveTypeWrapper.FLOAT)
		{
			ilGenerator.Emit(OpCodes.Ldc_R4, 0.0f);
		}
		else if(type == PrimitiveTypeWrapper.DOUBLE)
		{
			// NOTE since floating point numbers are stored as native size float on the stack, we can use Ldc_R4 here
			ilGenerator.Emit(OpCodes.Ldc_R4, 0.0f);
		}
		else if(type == PrimitiveTypeWrapper.VOID)
		{
		}
		else
		{
			ilGenerator.Emit(OpCodes.Ldnull);
@


1.32
log
@*** empty log message ***
@
text
@d309 1
a309 2
				if(ei.catch_type != 0 &&
					!java_lang_ThreadDeath.IsAssignableTo(m.Method.ClassFile.GetConstantPoolClassType(ei.catch_type, classLoader)))
d311 2
a312 3
					int start = FindPcIndex(ei.start_pc);
					int end = FindPcIndex(ei.end_pc);
					for(int j = start; j < end; j++)
d314 3
a316 1
						if(ByteCodeMetaData.CanThrowException(m.Instructions[j].OpCode))
d318 4
a321 1
							goto next;
d323 2
a325 2
					ar.RemoveAt(i);
					i--;
@


1.31
log
@*** empty log message ***
@
text
@d774 1
a774 1
										for(int n = 0; n < stack; n++)
@


1.30
log
@*** empty log message ***
@
text
@a31 13
class ReturnCookie
{
	public Label Stub;
	public LocalBuilder Local;
}

class BranchCookie
{
	public Label Stub;
	public int TargetIndex;
	public Stack Stack = new Stack();
}

d63 3
a65 3
	private static MethodInfo mapExceptionMethod = typeof(ExceptionHelper).GetMethod("MapException");
	private static MethodInfo mapExceptionFastMethod = typeof(ExceptionHelper).GetMethod("MapExceptionFast");
	private static MethodInfo fillInStackTraceMethod = typeof(ExceptionHelper).GetMethod("fillInStackTrace");
d74 1
d84 12
d124 1
d302 24
d352 1
a352 1
					throw new Exception("Partially overlapping try blocks is broken");
d359 1
a359 1
					throw new Exception("Non recursive try blocks is broken");
d370 1
a370 4
						Console.WriteLine("i = " + i);
						Console.WriteLine("j = " + j);
						Console.WriteLine("targetPC = " + targetPC);
						throw new Exception("Try block splitting around __jsr is broken");
d377 28
d425 9
a433 1
		internal DupHelper SetType(int i, TypeWrapper type)
a453 1
			return this;
d456 1
a456 1
		internal DupHelper Load(int i)
a474 1
			return this;
d477 1
a477 1
		internal DupHelper Store(int i)
a493 1
			return this;
d524 1
a524 2
			// TODO
			if(true || JVM.IsStaticCompiler)
d551 1
a551 1
		object[] labels = new object[m.Instructions[m.Instructions.Length - 1].PC];
d573 1
a573 6
				// make sure we didn't branch into a try block
				// NOTE this check is not strict enough
				// UPDATE since we're now splitting try blocks around branch targets, this shouldn't be possible anymore
				if(exceptionIndex < exceptions.Length &&
					instr.PC > exceptions[exceptionIndex].start_pc &&
					instr.PC < exceptions[exceptionIndex].end_pc)
d575 16
a590 1
					throw new NotImplementedException("branch into try block not implemented: " + clazz.Name + "." + m.Method.Name + m.Method.Signature + " (index = " + exceptionIndex + ", pc = " + instr.PC + ")");
a591 2

				// TODO for now, every instruction has an associated label, optimize this
d594 5
a598 1
					object label = labels[instr.PC];
d602 1
a602 1
						labels[instr.PC] = label;
a604 16
					if(symboldocument != null)
					{
						// TODO this needs to be done better
						ClassFile.Method.LineNumberTableEntry[] table = m.LineNumberTableAttribute;
						if(table != null)
						{
							for(int j = 0; j < table.Length; j++)
							{
								if(table[j].start_pc == instr.PC && table[j].line_number != 0)
								{
									ilGenerator.MarkSequencePoint(symboldocument, table[j].line_number, 0, table[j].line_number + 1, 0);
									break;
								}
							}
						}
					}
d612 2
a613 1
						if(ma.GetStackHeight(i) != 0)
d615 3
a617 3
							Stack stack = new Stack();
							int stackHeight = ma.GetStackHeight(i);
							for(int n = 0; n < stackHeight; n++)
d619 2
a620 21
								TypeWrapper t = ma.GetRawStackTypeWrapper(i, n);
								if(VerifierTypeWrapper.IsNew(t))
								{
									// unitialized references (new objects) aren't really there
								}
								else if(t == VerifierTypeWrapper.UninitializedThis)
								{
									// we're inside a constructor and the uninitialized this is passed into an exception block!
									ilGenerator.Emit(OpCodes.Pop);
									stack.Push("this");
								}
								else if(t == VerifierTypeWrapper.Null)
								{
									stack.Push(null);
								}
								else
								{
									LocalBuilder local = ilGenerator.DeclareLocal(t.TypeAsLocalOrStackType);
									stack.Push(local);
									ilGenerator.Emit(OpCodes.Stloc, local);
								}
d623 1
a623 1
							while(stack.Count != 0)
d625 1
a625 13
								object o = stack.Pop();
								if(o == null)
								{
									ilGenerator.Emit(OpCodes.Ldnull);
								}
								else if(o is string)	// HACK we use a string to signal "this"
								{
									ilGenerator.Emit(OpCodes.Ldarg_0);
								}
								else
								{
									ilGenerator.Emit(OpCodes.Ldloc, (LocalBuilder)o);
								}
d640 1
a640 3
								ilGenerator.MarkLabel(bc.Stub);
								int stack = ma.GetStackHeight(bc.TargetIndex);
								for(int n = 0; n < stack; n++)
d642 4
a645 2
									TypeWrapper t = ma.GetRawStackTypeWrapper(bc.TargetIndex, n);
									if(VerifierTypeWrapper.IsNew(t))
d647 1
a647 25
										// unitialized references aren't really there, but at the push site we
										// need to know that we have to skip this slot, so we push a null as well,
										// and then at the push site we'll look at the stack type to figure out
										// if it is a real null or an unitialized references
										bc.Stack.Push(null);
									}
									else if(t == VerifierTypeWrapper.UninitializedThis)
									{
										// we're inside a constructor and the uninitialized this is passed into an exception block!
										ilGenerator.Emit(OpCodes.Ldarg_0);
										// unitialized references aren't really there, but at the push site we
										// need to know that we have to skip this slot, so we push a null as well,
										// and then at the push site we'll look at the stack type to figure out
										// if it is a real null or an unitialized references
										bc.Stack.Push(null);
									}
									else if(t == VerifierTypeWrapper.Null)
									{
										bc.Stack.Push(null);
									}
									else
									{
										LocalBuilder local = ilGenerator.DeclareLocal(t.TypeAsLocalOrStackType);
										bc.Stack.Push(local);
										ilGenerator.Emit(OpCodes.Stloc, local);
d649 2
a651 2
								bc.Stub = ilGenerator.DefineLabel();
								ilGenerator.Emit(OpCodes.Leave, bc.Stub);
d654 1
a654 2
						TypeWrapper exceptionTypeWrapper = null;
						Type excType;
d657 1
a657 1
							excType = typeof(Exception);
d661 1
a661 6
							TypeWrapper tw = m.Method.ClassFile.GetConstantPoolClassType(exceptions[j].catch_type, classLoader);
							if(tw.IsUnloadable)
							{
								exceptionTypeWrapper = tw;
							}
							excType = tw.TypeAsExceptionType;
d663 2
a666 1
							bool mapSafe = IsMapSafeException(excType);
d675 6
a680 2
							Label label = ilGenerator.DefineLabel();
							LocalBuilder local = ilGenerator.DeclareLocal(excType);
d685 1
a685 4
								Instruction handlerInstr = code[FindPcIndex(exceptions[j].handler_pc)];
								if(handlerInstr.NormalizedOpCode == NormalizedByteCode.__pop ||
									(handlerInstr.NormalizedOpCode == NormalizedByteCode.__astore &&
									!ma.IsAloadUsed(handlerInstr.NormalizedArg1)))
d687 2
a688 3
									// if the exception isn't used then we don't need to do any mapping!
									ilGenerator.Emit(OpCodes.Stloc, local);
									ilGenerator.Emit(OpCodes.Leave, label);
d696 1
a696 1
									ilGenerator.Emit(OpCodes.Call, mapExceptionFastMethod);
d701 2
a702 2
									ilGenerator.Emit(OpCodes.Stloc, local);
									ilGenerator.Emit(OpCodes.Leave, label);
d704 1
d708 1
a708 1
								if(exceptionTypeWrapper != null)
d713 1
a713 1
									ilGenerator.Emit(OpCodes.Call, mapExceptionMethod);
d719 1
a719 1
									ilGenerator.Emit(OpCodes.Call, mapExceptionMethod);
d722 11
a732 2
								ilGenerator.Emit(OpCodes.Stloc, local);
								ilGenerator.Emit(OpCodes.Ldloc, local);
d735 1
a735 1
								ilGenerator.Emit(OpCodes.Leave, label);
a739 3
							ilGenerator.MarkLabel(label);
							ilGenerator.Emit(OpCodes.Ldloc, local);
							ilGenerator.Emit(OpCodes.Br, GetLabel(labels, exceptions[j].handler_pc, inuse, rangeBegin, rangeEnd, exits));
d758 1
a758 6
									ReturnCookie rc1 = new ReturnCookie();
									rc1.Local = rc.Local;
									rc1.Stub = ilGenerator.DefineLabel();
									ilGenerator.MarkLabel(rc.Stub);
									ilGenerator.Emit(OpCodes.Leave, rc1.Stub);
									exits.Add(rc1);
d766 9
a774 6
									ilGenerator.MarkLabel(bc.Stub);
									int stack = ma.GetStackHeight(bc.TargetIndex);
									for(int n = 0; n < stack; n++)
									{
										LocalBuilder local = (LocalBuilder)bc.Stack.Pop();
										if(local == null)
d776 1
a776 19
											TypeWrapper t = ma.GetRawStackTypeWrapper(bc.TargetIndex, (stack - 1) - n);
											if(t == VerifierTypeWrapper.Null)
											{
												ilGenerator.Emit(OpCodes.Ldnull);
											}
											else if(t == VerifierTypeWrapper.UninitializedThis)
											{
												// we're inside a constructor and the uninitialized this is passed into an exception block!
												ilGenerator.Emit(OpCodes.Ldarg_0);
											}
											else
											{
												// if the type is not Lnull, it means it was an unitialized object reference,
												// which don't really exist on our stack
											}
										}
										else
										{
											ilGenerator.Emit(OpCodes.Ldloc, local);
d778 5
a783 1
									ilGenerator.Emit(OpCodes.Br, GetLabel(labels, code[bc.TargetIndex].PC, inuse, rangeBegin, rangeEnd, exits));
d870 3
a872 2
						object o = instr.MethodCode.Method.ClassFile.GetConstantPoolConstant(instr.Arg1);
						if(o is string)
d874 17
a890 21
							ilGenerator.Emit(OpCodes.Ldstr, (string)o);
						}
						else if(o is float)
						{
							ilGenerator.Emit(OpCodes.Ldc_R4, (float)o);
						}
						else if(o is double)
						{
							ilGenerator.Emit(OpCodes.Ldc_R8, (double)o);
						}
						else if(o is int)
						{
							ilGenerator.Emit(OpCodes.Ldc_I4, (int)o);
						}
						else if(o is long)
						{
							ilGenerator.Emit(OpCodes.Ldc_I8, (long)o);
						}
						else
						{
							throw new NotImplementedException(o.GetType().Name);
a1057 4
								if(java_lang_Throwable == null)
								{
									java_lang_Throwable = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Throwable");
								}
d1066 1
a1066 1
										ilGenerator.Emit(OpCodes.Call, fillInStackTraceMethod);
d1190 2
a1191 14
								rc.Local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsLocalOrStackType);
								if(!retTypeWrapper.IsUnloadable)
								{
									// because of the way interface merging works, any reference is valid
									// for any interface reference
									if(retTypeWrapper.IsInterfaceOrInterfaceArray && !ma.GetRawStackTypeWrapper(i, 0).IsAssignableTo(retTypeWrapper))
									{
										ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.Type);
									}
									if(retTypeWrapper.IsNonPrimitiveValueType)
									{
										retTypeWrapper.EmitUnbox(ilGenerator);
									}
								}
d1215 1
a1215 17
								if(!retTypeWrapper.IsUnloadable)
								{
									TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 0);
									if(!tw.IsUnloadable)
									{
										// because of the way interface merging works, any reference is valid
										// for any interface reference
										if(retTypeWrapper.IsInterfaceOrInterfaceArray && !tw.IsAssignableTo(retTypeWrapper))
										{
											ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.Type);
										}
										if(retTypeWrapper.IsNonPrimitiveValueType)
										{
											retTypeWrapper.EmitUnbox(ilGenerator);
										}
									}
								}
d1218 1
a1218 1
									LocalBuilder local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsLocalOrStackType);
a1225 11
								if(!retTypeWrapper.IsUnloadable && retTypeWrapper.IsGhost)
								{
									LocalBuilder local1 = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsLocalOrStackType);
									ilGenerator.Emit(OpCodes.Stloc, local1);
									LocalBuilder local2 = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
									ilGenerator.Emit(OpCodes.Ldloca, local2);
									ilGenerator.Emit(OpCodes.Ldloc, local1);
									ilGenerator.Emit(OpCodes.Stfld, retTypeWrapper.GhostRefField);
									ilGenerator.Emit(OpCodes.Ldloca, local2);
									ilGenerator.Emit(OpCodes.Ldobj, retTypeWrapper.TypeAsParameterType);
								}
d1264 4
a1267 19
								if(type.IsUnloadable)
								{
									// nothing to do
								}
								else if(type.IsNonPrimitiveValueType)
								{
									// HACK we're boxing the arguments when they are loaded, this is inconsistent
									// with the way locals are treated, so we probably should only box the arguments
									// once (on method entry)
									type.EmitBox(ilGenerator);
								}
								else if(type.IsGhost)
								{
									// HACK instead creating an extra local, we should just take the address of the original argument
									LocalBuilder local = ilGenerator.DeclareLocal(type.TypeAsParameterType);
									ilGenerator.Emit(OpCodes.Stloc, local);
									ilGenerator.Emit(OpCodes.Ldloca, local);
									ilGenerator.Emit(OpCodes.Ldfld, type.GhostRefField);
								}
d1290 2
a1291 2
							// any unitialized reference, is always the this reference, we don't store anything
							// here (because CLR wont allow unitialized references in locals) and then when
d1299 1
a1299 2
								if(!type.IsUnloadable && type != VerifierTypeWrapper.Null &&
									(type.IsNonPrimitiveValueType || type.IsGhost))
d1301 1
a1301 2
									// TODO we must support IsNonPrimitiveValueType and IsGhost types here (for 
									throw new NotImplementedException();
d1939 8
a1946 7
						new DupHelper(ilGenerator, 2)
							.SetType(0, ma.GetRawStackTypeWrapper(i, 0))
							.SetType(1, ma.GetRawStackTypeWrapper(i, 1))
							.Store(0)
							.Store(1)
							.Load(0)
							.Load(1);
d1948 1
d1965 9
a1973 9
							new DupHelper(ilGenerator, 2)
								.SetType(0, type1)
								.SetType(1, ma.GetRawStackTypeWrapper(i, 1))
								.Store(0)
								.Store(1)
								.Load(1)
								.Load(0)
								.Load(1)
								.Load(0);
d1978 9
a1986 8
						new DupHelper(ilGenerator, 2)
							.SetType(0, ma.GetRawStackTypeWrapper(i, 0))
							.SetType(1, ma.GetRawStackTypeWrapper(i, 1))
							.Store(0)
							.Store(1)
							.Load(0)
							.Load(1)
							.Load(0);
d1988 1
d1994 8
a2001 8
							new DupHelper(ilGenerator, 2)
								.SetType(0, type1)
								.SetType(1, ma.GetRawStackTypeWrapper(i, 1))
								.Store(0)
								.Store(1)
								.Load(0)
								.Load(1)
								.Load(0);
d2005 12
a2016 12
							new DupHelper(ilGenerator, 3)
								.SetType(0, type1)
								.SetType(1, ma.GetRawStackTypeWrapper(i, 1))
								.SetType(2, ma.GetRawStackTypeWrapper(i, 2))
								.Store(0)
								.Store(1)
								.Store(2)
								.Load(1)
								.Load(0)
								.Load(2)
								.Load(1)
								.Load(0);
d2029 8
a2036 8
								new DupHelper(ilGenerator, 2)
									.SetType(0, type1)
									.SetType(1, type2)
									.Store(0)
									.Store(1)
									.Load(0)
									.Load(1)
									.Load(0);
d2041 11
a2051 11
								new DupHelper(ilGenerator, 3)
									.SetType(0, type1)
									.SetType(1, type2)
									.SetType(2, ma.GetRawStackTypeWrapper(i, 2))
									.Store(0)
									.Store(1)
									.Store(2)
									.Load(0)
									.Load(2)
									.Load(1)
									.Load(0);
d2060 12
a2071 12
								new DupHelper(ilGenerator, 3)
									.SetType(0, type1)
									.SetType(1, type2)
									.SetType(2, type3)
									.Store(0)
									.Store(1)
									.Store(2)
									.Load(1)
									.Load(0)
									.Load(2)
									.Load(1)
									.Load(0);
d2076 15
a2090 15
								new DupHelper(ilGenerator, 4)
									.SetType(0, type1)
									.SetType(1, type2)
									.SetType(2, type3)
									.SetType(3, ma.GetRawStackTypeWrapper(i, 3))
									.Store(0)
									.Store(1)
									.Store(2)
									.Store(3)
									.Load(1)
									.Load(0)
									.Load(3)
									.Load(2)
									.Load(1)
									.Load(0);
d2096 12
a2107 11
						new DupHelper(ilGenerator, 3)
							.SetType(0, ma.GetRawStackTypeWrapper(i, 0))
							.SetType(1, ma.GetRawStackTypeWrapper(i, 1))
							.SetType(2, ma.GetRawStackTypeWrapper(i, 2))
							.Store(0)
							.Store(1)
							.Store(2)
							.Load(0)
							.Load(2)
							.Load(1)
							.Load(0);
d2109 1
d2259 1
a2661 4
							if(java_lang_Object == null)
							{
								java_lang_Object = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.Object");
							}
d2909 1
d2912 2
a2913 2
			inuse[FindPcIndex(targetPC)] = true;
			object l = labels[targetPC];
d2917 1
a2917 1
				labels[targetPC] = l;
d2923 18
a2940 5
			BranchCookie bc = new BranchCookie();
			bc.TargetIndex = FindPcIndex(targetPC);
			bc.Stub = ilGenerator.DefineLabel();
			exits.Add(bc);
			return bc.Stub;
a2941 7
	}

	private bool IsMapSafeException(Type excType)
	{
		// HACK instead of the name, we should compare with a cache ref of the type (but beware of the
		// fact that the Type identity changes when a TypeBuilder turns into a RuntimeType)
		return excType.FullName == "java.lang.ClassNotFoundException";
@


1.29
log
@*** empty log message ***
@
text
@d357 7
d365 1
a365 1
		private bool[] isnull;
d371 1
a371 1
			isnull = new bool[count];
d379 1
a379 1
				isnull[i] = true;
d384 6
d393 1
d401 1
a401 1
			if(isnull[i])
d403 14
a416 5
				ilgen.Emit(OpCodes.Ldnull);
			}
			else if(locals[i] != null)
			{
				ilgen.Emit(OpCodes.Ldloc, locals[i]);
d423 1
a423 1
			if(isnull[i])
d425 12
a436 5
				ilgen.Emit(OpCodes.Pop);
			}
			else if(locals[i] != null)
			{
				ilgen.Emit(OpCodes.Stloc, locals[i]);
d720 1
a720 1
									ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetType"));
d866 2
a867 1
						ilGenerator.Emit(OpCodes.Ldc_I8, 0L);
d870 2
a871 1
						ilGenerator.Emit(OpCodes.Ldc_I8, 1L);
d874 2
d879 2
a885 6
					case NormalizedByteCode.__dconst_0:
						ilGenerator.Emit(OpCodes.Ldc_R8, 0.0d);
						break;
					case NormalizedByteCode.__dconst_1:
						ilGenerator.Emit(OpCodes.Ldc_R8, 1.0d);
						break;
d1226 1
a1226 2
										ilGenerator.Emit(OpCodes.Unbox, retTypeWrapper.Type);
										ilGenerator.Emit(OpCodes.Ldobj, retTypeWrapper.Type);
d1265 1
a1265 2
											ilGenerator.Emit(OpCodes.Unbox, retTypeWrapper.Type);
											ilGenerator.Emit(OpCodes.Ldobj, retTypeWrapper.Type);
d1279 1
a1279 1
								if(retTypeWrapper.IsGhost)
d1337 1
a1337 1
									ilGenerator.Emit(OpCodes.Box, type.Type);
a1636 7
						else if(tw.ElementTypeWrapper.IsNonPrimitiveValueType)
						{
							Type t = tw.ElementTypeWrapper.Type;
							ilGenerator.Emit(OpCodes.Ldelema, t);
							ilGenerator.Emit(OpCodes.Ldobj, t);
							ilGenerator.Emit(OpCodes.Box, t);
						}
d1639 12
a1650 1
							ilGenerator.Emit(OpCodes.Ldelem_Ref);
a1705 11
						else if(tw.ElementTypeWrapper.IsNonPrimitiveValueType)
						{
							Type t = tw.ElementTypeWrapper.Type;
							LocalBuilder local = ilGenerator.DeclareLocal(typeof(object));
							ilGenerator.Emit(OpCodes.Stloc, local);
							ilGenerator.Emit(OpCodes.Ldelema, t);
							ilGenerator.Emit(OpCodes.Ldloc, local);
							ilGenerator.Emit(OpCodes.Unbox, t);
							ilGenerator.Emit(OpCodes.Ldobj, t);
							ilGenerator.Emit(OpCodes.Stobj, t);
						}
d1708 15
a1722 1
							ilGenerator.Emit(OpCodes.Stelem_Ref);
d2029 1
a2029 1
						// if the TOS contains a "new" object, it isn't really there, so we wont dup it either
d2038 1
a2038 1
						if(type1 == PrimitiveTypeWrapper.DOUBLE || type1 == PrimitiveTypeWrapper.LONG)
d2069 1
a2069 1
						if(type1 == PrimitiveTypeWrapper.DOUBLE || type1 == PrimitiveTypeWrapper.LONG)
d2101 1
a2101 1
						if(type1 == PrimitiveTypeWrapper.DOUBLE || type1 == PrimitiveTypeWrapper.LONG)
d2103 1
a2103 1
							if(type2 == PrimitiveTypeWrapper.DOUBLE || type2 == PrimitiveTypeWrapper.LONG)
d2134 1
a2134 1
							if(type3 == PrimitiveTypeWrapper.DOUBLE || type3 == PrimitiveTypeWrapper.LONG)
d2188 1
a2188 1
						if(type1 == PrimitiveTypeWrapper.DOUBLE || type1 == PrimitiveTypeWrapper.LONG)
d2393 1
a2393 1
				dh.SetType(i, args[i]);
a2435 1
						ilGenerator.Emit(OpCodes.Unbox, args[i].Type);
d2438 5
a2442 1
							ilGenerator.Emit(OpCodes.Ldobj, args[i].Type);
d2653 1
d2850 1
a2850 5
		if(type == PrimitiveTypeWrapper.BOOLEAN ||
			type == PrimitiveTypeWrapper.BYTE ||
			type == PrimitiveTypeWrapper.SHORT ||
			type == PrimitiveTypeWrapper.CHAR ||
			type == PrimitiveTypeWrapper.INT)
d2856 2
a2857 1
			ilGenerator.Emit(OpCodes.Ldc_I8, 0L);
d2865 1
@


1.28
log
@*** empty log message ***
@
text
@d963 1
a963 2
							// for invokeinterface, the this reference is included in the argument list
							// because it may also need to be cast
d967 8
a974 1
							args[0] = thisType;
d1225 2
a1226 3
									// because of the way interface merging works, any reference is valid
									// for any interface reference
									if(retTypeWrapper.IsInterfaceOrInterfaceArray && !ma.GetRawStackTypeWrapper(i, 0).IsAssignableTo(retTypeWrapper))
d1228 11
a1238 6
										ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.Type);
									}
									if(retTypeWrapper.IsNonPrimitiveValueType)
									{
										ilGenerator.Emit(OpCodes.Unbox, retTypeWrapper.Type);
										ilGenerator.Emit(OpCodes.Ldobj, retTypeWrapper.Type);
d1251 11
d1298 1
a1298 1
							else if(!type.IsUnloadable && type.IsNonPrimitiveValueType)
d1300 19
a1318 4
								// HACK we're boxing the arguments when they are loaded, this is inconsistent
								// with the way locals are treated, so we probably should only box the arguments
								// once (on method entry)
								ilGenerator.Emit(OpCodes.Box, type.Type);
d1348 9
d1504 4
a1507 15
							TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(wrapper);
							Type[] implementerTypes = new Type[implementers.Length];
							for(int j = 0; j < implementers.Length; j++)
							{
								implementerTypes[j] = implementers[j].Type;
							}
							Label end = ilGenerator.DefineLabel();
							for(int j = 0; j < implementerTypes.Length; j++)
							{
								ilGenerator.Emit(OpCodes.Dup);
								ilGenerator.Emit(OpCodes.Isinst, implementerTypes[j]);
								ilGenerator.Emit(OpCodes.Brtrue, end);
							}
							ilGenerator.Emit(OpCodes.Castclass, wrapper.Type);
							ilGenerator.MarkLabel(end);
d1552 2
a1553 24
							TypeWrapper[] implementers = ClassLoaderWrapper.GetGhostImplementers(wrapper);
							Type[] implementerTypes = new Type[implementers.Length];
							for(int j = 0; j < implementers.Length; j++)
							{
								implementerTypes[j] = implementers[j].Type;
							}
							Label end = ilGenerator.DefineLabel();
							for(int j = 0; j < implementerTypes.Length; j++)
							{
								ilGenerator.Emit(OpCodes.Dup);
								ilGenerator.Emit(OpCodes.Isinst, implementerTypes[j]);
								Label label = ilGenerator.DefineLabel();
								ilGenerator.Emit(OpCodes.Brfalse_S, label);
								ilGenerator.Emit(OpCodes.Pop);
								ilGenerator.Emit(OpCodes.Ldc_I4_1);
								ilGenerator.Emit(OpCodes.Br, end);
								ilGenerator.MarkLabel(label);
							}
							ilGenerator.Emit(OpCodes.Isinst, wrapper.Type);
							ilGenerator.Emit(OpCodes.Ldnull);
							ilGenerator.Emit(OpCodes.Ceq);
							ilGenerator.Emit(OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Ceq);
							ilGenerator.MarkLabel(end);
d2330 5
d2383 1
a2383 2
				dh.Load(i);
				if(!args[i].IsUnloadable && args[i].IsNonPrimitiveValueType)
d2385 6
a2390 1
					ilGenerator.Emit(OpCodes.Unbox, args[i].Type);
d2393 13
a2405 1
						ilGenerator.Emit(OpCodes.Ldobj, args[i].Type);
@


1.27
log
@*** empty log message ***
@
text
@a377 4
			else if(!type.IsUnloadable && type.IsNonPrimitiveValueType)
			{
				locals[i] = ilgen.DeclareLocal(typeof(object));
			}
d380 1
a380 1
				locals[i] = ilgen.DeclareLocal(type.TypeOrUnloadableAsObject);
d555 1
a555 1
									LocalBuilder local = ilGenerator.DeclareLocal(t.TypeOrUnloadableAsObject);
d619 1
a619 1
										LocalBuilder local = ilGenerator.DeclareLocal(t.TypeOrUnloadableAsObject);
d641 1
a641 1
							excType = tw.TypeOrUnloadableAsObject;
d1081 1
a1081 1
												LocalBuilder lb = ilGenerator.DeclareLocal(stacktype.TypeOrUnloadableAsObject);
d1179 1
a1179 1
								rc.Local = ilGenerator.DeclareLocal(retTypeWrapper.TypeOrUnloadableAsObject);
d1233 1
a1233 1
									LocalBuilder local = ilGenerator.DeclareLocal(retTypeWrapper.TypeOrUnloadableAsObject);
d1383 1
a1383 1
							Type type = wrapper.TypeOrUnloadableAsObject;
d1402 1
a1402 1
							// HACK we use TypeOrUnloadableAsObject here, to make sure that Ghost implementers can be
d1412 1
a1412 1
							ilGenerator.Emit(OpCodes.Newarr, wrapper.TypeOrUnloadableAsObject);
d2885 1
a2885 1
				type = t.TypeOrUnloadableAsObject;
@


1.26
log
@*** empty log message ***
@
text
@d1479 26
d1540 35
@


1.25
log
@*** empty log message ***
@
text
@d2397 8
a2404 1
								if(!tw.IsUnloadable && tw.IsInterfaceOrInterfaceArray && !tw.IsGhost && !ma.GetRawStackTypeWrapper(i, stackpos).IsAssignableTo(tw))
@


1.24
log
@*** empty log message ***
@
text
@d1188 1
a1188 1
									if(retTypeWrapper.IsInterface && !ma.GetRawStackTypeWrapper(i, 0).IsAssignableTo(retTypeWrapper))
d1225 1
a1225 1
									if(retTypeWrapper.IsInterface && !ma.GetRawStackTypeWrapper(i, 0).IsAssignableTo(retTypeWrapper))
d2261 1
a2261 1
				else if(args[i].IsInterface)
d2289 1
a2289 3
				if(!args[i].IsUnloadable && 
					args[i].IsInterface &&
					!ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i).IsAssignableTo(args[i]))
d2291 5
a2295 1
					ilGenerator.Emit(OpCodes.Castclass, args[i].Type);
d2397 1
a2397 1
								if(!tw.IsUnloadable && tw.IsInterface && !tw.IsGhost && !ma.GetRawStackTypeWrapper(i, stackpos).IsAssignableTo(tw))
@


1.23
log
@*** empty log message ***
@
text
@d2263 2
a2264 1
					if(!ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i).IsAssignableTo(args[i]))
@


1.22
log
@*** empty log message ***
@
text
@d963 1
a963 1
							CastInterfaceArgs(args, i, true, false);
@


1.21
log
@*** empty log message ***
@
text
@d2646 1
a2646 1
			MethodWrapper method = type.GetMethodWrapper(new MethodDescriptor(type.GetClassLoader(), "<init>", "(Ljava.lang.String;)V"), false);
d2657 1
a2657 1
			MethodWrapper method = type.GetMethodWrapper(new MethodDescriptor(type.GetClassLoader(), "<init>", "()V"), false);
@


1.20
log
@*** empty log message ***
@
text
@d85 1
d418 2
a419 3
		string unloadableName = m.GetRetType(classLoader).Name;
		bool unloadable = m.GetRetType(classLoader).IsUnloadable;
		foreach(TypeWrapper tw in m.GetArgTypes(classLoader))
d421 1
a421 1
			if(tw.IsUnloadable)
d423 5
a427 2
				unloadable = true;
				unloadableName = tw.Name;
a429 5
		if(unloadable)
		{
			EmitHelper.Throw(ilGenerator, "java.lang.NoClassDefFoundError", unloadableName);
			return;
		}
a440 1
			Type verifyError = ClassLoaderWrapper.GetType("java.lang.VerifyError");
d442 1
a442 3
			ilGenerator.Emit(OpCodes.Ldstr, msg);
			ilGenerator.Emit(OpCodes.Newobj, verifyError.GetConstructor(new Type[] { typeof(string) }));
			ilGenerator.Emit(OpCodes.Throw);
d446 1
a446 1
				Console.WriteLine("java.lang.VerifyError: " + msg);
d632 1
d640 6
a645 2
							// TODO handle class not found
							excType = classLoader.LoadClassByDottedName(m.Method.ClassFile.GetConstantPoolClass(exceptions[j].catch_type)).Type;
d690 14
a703 4
								ilGenerator.Emit(OpCodes.Ldtoken, excType);
								ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
								ilGenerator.Emit(OpCodes.Call, mapExceptionMethod);
								ilGenerator.Emit(OpCodes.Castclass, excType);
a785 13
					{
						ClassFile.ConstantPoolItemFieldref cpi = m.Method.ClassFile.GetFieldref(instr.Arg1);
						FieldWrapper field = GetField(cpi, true, null, false);
						if(field != null)
						{
							field.EmitGet.Emit(ilGenerator);
						}
						else
						{
							EmitPlaceholder(cpi.GetFieldType(classLoader));
						}
						break;
					}
a786 19
					{
						ClassFile.ConstantPoolItemFieldref cpi = m.Method.ClassFile.GetFieldref(instr.Arg1);
						FieldWrapper field = GetField(cpi, true, null, true);
						if(field != null)
						{
							// because of the way interface merging works, any reference is valid
							// for any interface reference
							if(field.FieldTypeWrapper.IsInterface && !ma.GetRawStackTypeWrapper(i, 0).IsAssignableTo(field.FieldTypeWrapper))
							{
								ilGenerator.Emit(OpCodes.Castclass, field.FieldType);
							}
							field.EmitSet.Emit(ilGenerator);
						}
						else
						{
							ilGenerator.Emit(OpCodes.Pop);
						}
						break;
					}
a787 16
					{
						ClassFile.ConstantPoolItemFieldref cpi = m.Method.ClassFile.GetFieldref(instr.Arg1);
						TypeWrapper thisType = SigTypeToClassName(ma.GetRawStackTypeWrapper(i, 0), cpi.GetClassType(classLoader));
						if(!thisType.IsUnloadable)
						{
							FieldWrapper field = GetField(cpi, false, thisType, false);
							if(field != null)
							{
								field.EmitGet.Emit(ilGenerator);
								break;
							}
						}
						ilGenerator.Emit(OpCodes.Pop);
						EmitPlaceholder(cpi.GetFieldType(classLoader));
						break;
					}
d789 1
a789 20
					{
						ClassFile.ConstantPoolItemFieldref cpi = m.Method.ClassFile.GetFieldref(instr.Arg1);
						TypeWrapper thisType = SigTypeToClassName(ma.GetRawStackTypeWrapper(i, 1), cpi.GetClassType(classLoader));
						if(!thisType.IsUnloadable)
						{
							FieldWrapper field = GetField(cpi, false, thisType, true);
							if(field != null)
							{
								// because of the way interface merging works, any reference is valid
								// for any interface reference
								if(field.FieldTypeWrapper.IsInterface && !ma.GetRawStackTypeWrapper(i, 0).IsAssignableTo(field.FieldTypeWrapper))
								{
									ilGenerator.Emit(OpCodes.Castclass, field.FieldType);
								}
								field.EmitSet.Emit(ilGenerator);
								break;
							}
						}
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Pop);
a790 1
					}
d1051 1
a1051 1
								if(thisType.IsSubTypeOf(java_lang_Throwable))
d1184 1
a1184 3
								// because of the way interface merging works, any reference is valid
								// for any interface reference
								if(retTypeWrapper.IsInterface && !ma.GetRawStackTypeWrapper(i, 0).IsAssignableTo(retTypeWrapper))
d1186 11
a1196 6
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.Type);
								}
								if(retTypeWrapper.IsNonPrimitiveValueType)
								{
									ilGenerator.Emit(OpCodes.Unbox, retTypeWrapper.Type);
									ilGenerator.Emit(OpCodes.Ldobj, retTypeWrapper.Type);
d1221 1
a1221 3
								// because of the way interface merging works, any reference is valid
								// for any interface reference
								if(retTypeWrapper.IsInterface && !ma.GetRawStackTypeWrapper(i, 0).IsAssignableTo(retTypeWrapper))
d1223 11
a1233 6
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.Type);
								}
								if(retTypeWrapper.IsNonPrimitiveValueType)
								{
									ilGenerator.Emit(OpCodes.Unbox, retTypeWrapper.Type);
									ilGenerator.Emit(OpCodes.Ldobj, retTypeWrapper.Type);
d1281 1
a1281 1
							else if(type.IsNonPrimitiveValueType)
d1347 9
a1355 1
						if(!wrapper.IsUnloadable && (wrapper.IsAbstract || wrapper.IsInterface))
d1364 13
d1380 4
a1383 2
							// TODO
							throw new NotImplementedException();
d1387 1
a1387 14
							LocalBuilder localArray = ilGenerator.DeclareLocal(typeof(int[]));
								LocalBuilder localInt = ilGenerator.DeclareLocal(typeof(int));
							ilGenerator.Emit(OpCodes.Ldc_I4, instr.Arg2);
							ilGenerator.Emit(OpCodes.Newarr, typeof(int));
							ilGenerator.Emit(OpCodes.Stloc, localArray);
							for(int j = 1; j <= instr.Arg2; j++)
							{
								ilGenerator.Emit(OpCodes.Stloc, localInt);
								ilGenerator.Emit(OpCodes.Ldloc, localArray);
								ilGenerator.Emit(OpCodes.Ldc_I4, instr.Arg2 - j);
								ilGenerator.Emit(OpCodes.Ldloc, localInt);
								ilGenerator.Emit(OpCodes.Stelem_I4);
							}
							Type type = wrapper.Type;
d1400 3
a1402 2
							// TODO
							throw new NotImplementedException();
d1406 11
a1416 1
							ilGenerator.Emit(OpCodes.Newarr, wrapper.Type);
d1448 1
d1457 3
a1459 2
							// TODO
							throw new NotImplementedException();
d1490 3
a1492 2
							// TODO
							throw new NotImplementedException();
d1532 9
a1540 1
						if(ma.GetRawStackTypeWrapper(i, 1).ElementTypeWrapper.IsNonPrimitiveValueType)
d1542 1
a1542 1
							Type t = ma.GetRawStackTypeWrapper(i, 1).ElementTypeWrapper.Type;
d1552 1
d1597 9
a1605 1
						if(ma.GetRawStackTypeWrapper(i, 2).ElementTypeWrapper.IsNonPrimitiveValueType)
d1607 1
a1607 1
							Type t = ma.GetRawStackTypeWrapper(i, 2).ElementTypeWrapper.Type;
d1621 1
d2319 1
a2319 1
	private FieldWrapper GetField(ClassFile.ConstantPoolItemFieldref cpi, bool isStatic, TypeWrapper thisType, bool write)
d2321 3
d2327 27
a2353 3
			// TODO instead of this NoClassDefFoundError, we should return a dynamic FieldWrapper that
			// dynamically tries to get/set the field
			EmitError("java.lang.NoClassDefFoundError", wrapper.Name);
d2357 10
d2372 1
d2374 2
a2375 2
						(field.IsProtected && (isStatic ? clazz.IsSubTypeOf(field.DeclaringType) : clazz.IsSubTypeOf(thisType))) ||
						(field.IsPrivate && clazz == wrapper) ||
d2378 1
a2378 1
						// are we trying to mutate a final field (they are read-only from outside of the defining class)
d2381 1
a2381 1
							EmitError("java.lang.IllegalAccessError", "Field " + cpi.Class + "." + cpi.Name + " is final");
d2385 16
a2400 1
							return field;
d2405 1
a2405 1
						EmitError("java.lang.IllegalAccessError", "Try to access field " + cpi.Class + "." + cpi.Name + " from class " + clazz.Name);
d2418 17
a2434 1
		return null;
d2456 1
a2456 1
	private class DynamicNewEmitter : CodeEmitter
d2461 2
d2464 1
a2464 1
		internal DynamicNewEmitter(ClassLoaderWrapper classLoader, TypeWrapper wrapper, ClassFile.ConstantPoolItemFMI cpi)
d2469 2
d2498 23
a2520 5
			ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicInvokeSpecialNew"));
			if(!cpi.GetClassType(classLoader).IsUnloadable)
			{
				ilGenerator.Emit(OpCodes.Castclass, cpi.GetClassType(classLoader).Type);
			}
d2528 2
a2529 1
		if(IsUnloadable(cpi))
d2531 12
a2542 3
			emitNewobj = new DynamicNewEmitter(classLoader, clazz, cpi);
			emitCall = CodeEmitter.NoClassDefFoundError(cpi.Signature);
			emitCallvirt = CodeEmitter.NoClassDefFoundError(cpi.Signature);
a2546 1
			TypeWrapper wrapper = cpi.GetClassType(classLoader);
d2586 1
a2586 1
							(method.IsProtected && (method.IsStatic ? clazz.IsSubTypeOf(method.DeclaringType) : clazz.IsSubTypeOf(thisType))) ||
d2597 4
d2604 1
a2604 1
							if(!method.IsStatic && cpi.Name == "clone" && wrapper.Type == typeof(object) && thisType.Type.IsArray)
@


1.19
log
@*** empty log message ***
@
text
@d377 1
a377 1
			else if(type.IsNonPrimitiveValueType)
d952 1
d986 4
a989 2
						MethodWrapper method = GetMethod(cpi, null, NormalizedByteCode.__invokestatic);
						if(method != null)
d994 1
a994 1
							method.EmitCall.Emit(ilGenerator);
d1034 3
a1036 1
						MethodWrapper method = (thisType != null) ? GetMethod(cpi, thisType, instr.NormalizedOpCode) : null;
d1038 1
a1038 1
						if(method != null)
d1042 1
a1042 1
								emit = method.EmitCall;
d1046 1
a1046 1
								emit = method.EmitCallvirt;
d1056 1
a1056 1
									// so we set method to null, to basically just comment out the constructor
d1058 1
a1058 1
									method = null;
d1093 1
a1093 1
								if(method != null)
d1095 1
a1095 1
									method.EmitNewobj.Emit(ilGenerator);
d1186 1
a1186 1
								if(method != null)
d1188 1
a1188 1
									method.EmitCall.Emit(ilGenerator);
a2260 1
		// TODO handle unloadable types
d2267 5
a2271 1
				if(args[i].IsInterface)
d2279 1
a2279 1
				if(args[i].IsNonPrimitiveValueType)
d2298 3
a2300 1
				if(args[i].IsInterface && !ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i).IsAssignableTo(args[i]))
d2317 1
a2317 1
				if(args[i].IsNonPrimitiveValueType)
d2443 1
a2443 1
	private MethodWrapper GetMethod(ClassFile.ConstantPoolItemFMI cpi, TypeWrapper thisType, NormalizedByteCode invoke)
d2449 4
a2452 11
			MethodWrapper dummy = new MethodWrapper(null, null, null, null, 0, true);
			if(invoke == NormalizedByteCode.__invokespecial)
			{
				dummy.EmitNewobj = new DynamicNewEmitter(classLoader, clazz, cpi);
			}
			else
			{
				dummy.EmitCall = CodeEmitter.NoClassDefFoundError(cpi.Signature);
				dummy.EmitCallvirt = CodeEmitter.NoClassDefFoundError(cpi.Signature);
			}
			return dummy;
d2500 4
a2503 1
							return method;
d2515 4
a2518 1
									return method;
d2535 4
a2538 1
		return null;
@


1.18
log
@*** empty log message ***
@
text
@d1496 3
a1498 6
								if(implementerTypes[j] != wrapper.Type)
								{
									ilGenerator.Emit(OpCodes.Dup);
									ilGenerator.Emit(OpCodes.Isinst, implementerTypes[j]);
									ilGenerator.Emit(OpCodes.Brtrue, end);
								}
d1537 3
a1539 1
							ilGenerator.Emit(OpCodes.Pop);
d1541 1
@


1.17
log
@*** empty log message ***
@
text
@d1323 1
a1323 1
								if(type != ma.GetDeclaredLocalTypeWrapper(instr.NormalizedArg1) && !type.IsUnloadable && !type.IsNonPrimitiveValueType)
d1485 21
d1520 24
d2710 1
a2710 1
			if(!t.IsUnloadable && t != VerifierTypeWrapper.Null)
d2712 1
a2712 1
				type = t.Type;
@


1.16
log
@*** empty log message ***
@
text
@d417 15
d2401 2
a2402 1
				throw new NotImplementedException();
@


1.15
log
@*** empty log message ***
@
text
@d113 1
d630 1
a630 1
							excType = classLoader.LoadClassBySlashedName(m.Method.ClassFile.GetConstantPoolClass(exceptions[j].catch_type)).Type;
d937 1
a937 1
						if(cpi.Class == "java/lang/System" &&
d939 1
a939 1
							cpi.Signature == "(Ljava/lang/Object;ILjava/lang/Object;II)V")
d1087 1
a1087 1
									java_lang_Throwable = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/Throwable");
d2379 1
a2379 1
			MethodWrapper dummy = new MethodWrapper(null, null, null, null, Modifiers.Synthetic);
d2411 1
a2411 1
						method = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/Object").GetMethodWrapper(md, false);
d2479 1
a2479 1
			MethodWrapper method = type.GetMethodWrapper(new MethodDescriptor(type.GetClassLoader(), "<init>", "(Ljava/lang/String;)V"), false);
d2504 1
a2504 1
			TypeWrapper type = classLoader.LoadClassBySlashedName(classname);
@


1.14
log
@*** empty log message ***
@
text
@d196 1
a196 3
					// TODO we probably should handle other branches here as well...
					if(m.Instructions[j].NormalizedOpCode == NormalizedByteCode.__jsr
						|| m.Instructions[j].NormalizedOpCode == NormalizedByteCode.__goto)
d274 1
a274 2
			// TODO verify that we don't need to start at j = 0
			for(int j = i; j < ar.Count; j++)
@


1.13
log
@*** empty log message ***
@
text
@d196 3
a198 1
					if(m.Instructions[j].NormalizedOpCode == NormalizedByteCode.__jsr)
@


1.12
log
@*** empty log message ***
@
text
@d84 1
d975 1
a975 1
							CastInterfaceArgs(cpi.GetArgTypes(classLoader), i, false);
a999 1
						TypeWrapper[] args;
d1002 2
a1003 1
							args = cpi.GetArgTypes(classLoader);
a1005 1
//						if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface)
d1010 1
a1010 1
							args = new TypeWrapper[methodArgs.Length + 1];
d1013 1
a1014 11
//						else
//						{
//							args = cpi.GetArgTypes(classLoader);
//
//							if(!thisType.IsUnloadable && !thisType.IsSubTypeOf(cpi.GetClassType(classLoader)))
//							{
//								EmitError("java.lang.IncompatibleClassChangeError", null);
//								thisType = null;
//							}
//						}
						CastInterfaceArgs(args, i, true);
d2194 1
a2194 1
	private void CastInterfaceArgs(TypeWrapper[] args, int instructionIndex, bool instanceMethod)
d2197 1
a2197 1
		bool needsCast = false;
d2199 1
a2199 1
		for(int i = 0; i < args.Length; i++)
d2201 1
a2201 1
			if(args[i].IsInterface)
d2203 9
a2211 1
				if(!ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i).IsAssignableTo(args[i]))
a2216 5
			if(args[i].IsNonPrimitiveValueType)
			{
				needsCast = true;
				break;
			}
d2235 8
@


1.11
log
@*** empty log message ***
@
text
@d372 9
a380 1
			else if(!VerifierTypeWrapper.IsNew(type))
d974 1
a974 1
							CastInterfaceArgs(cpi.GetArgTypes(classLoader), i);
d1000 6
a1005 1
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface)
d1014 11
a1024 11
						else
						{
							args = cpi.GetArgTypes(classLoader);

							if(!thisType.IsUnloadable && !thisType.IsSubTypeOf(cpi.GetClassType(classLoader)))
							{
								EmitError("java.lang.IncompatibleClassChangeError", null);
								thisType = null;
							}
						}
						CastInterfaceArgs(args, i);
d1238 5
d1272 5
d1318 1
a1318 1
								if(type != ma.GetDeclaredLocalTypeWrapper(instr.NormalizedArg1) && !type.IsUnloadable)
d1323 7
d1505 11
a1515 1
						ilGenerator.Emit(OpCodes.Ldelem_Ref);
d1561 15
a1575 1
						ilGenerator.Emit(OpCodes.Stelem_Ref);
d2203 2
a2204 1
	private void CastInterfaceArgs(TypeWrapper[] args, int instructionIndex)
d2219 5
d2246 8
@


1.10
log
@*** empty log message ***
@
text
@d926 35
@


1.9
log
@no message
@
text
@d81 2
a82 2
	private static MethodInfo monitorEnterMethod = typeof(ByteCodeHelper).GetMethod("monitorenter");
	private static MethodInfo monitorExitMethod = typeof(ByteCodeHelper).GetMethod("monitorexit");
d2014 2
d2017 2
d2020 1
a2020 1
						ilGenerator.Emit(OpCodes.Conv_I4);
a2021 1
					case NormalizedByteCode.__i2l:
d2023 2
d2026 3
@


1.8
log
@no message
@
text
@d929 1
a929 1
							// TODO if the stack values don't match the argument types (for interface argument types)
d931 1
a948 4
						// TODO if the stack values don't match the argument types (for interface argument types)
						// we must emit code to cast the stack value to the interface type

						// TODO invokespecial should check for null "this" reference
d953 5
a957 4
						// invokeinterface needs to have special support for downcasting to the interface (because
						// the verifier may not be able to merge two interfaces, but the resulting code would still be valid)
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface &&
							thisType == ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/Object"))
d959 12
a970 3
							thisType = cpi.GetClassType(classLoader);
							DupHelper dup = new DupHelper(ilGenerator, argcount);
							for(int k = 0; k < argcount; k++)
d972 2
a973 1
								dup.SetType(k, ma.GetRawStackTypeWrapper(i, k));
d975 8
a982 1
							for(int k = 0; k < argcount; k++)
d984 1
a984 1
								dup.Store(k);
d986 1
a986 13
							// TODO this IncompatibleClassChangeError check should also be applied
							// for other locations where we can "consume" an object reference in the
							// place of an interface reference (putstatic / putfield / arguments for invoke*).
							// TODO it turns out that when an interface ref is expected, *any* type will be accepted!
							ilGenerator.Emit(OpCodes.Dup);
							Label label = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Brfalse_S, label);
							ilGenerator.Emit(OpCodes.Isinst, thisType.Type);
							ilGenerator.Emit(OpCodes.Dup);
							ilGenerator.Emit(OpCodes.Brtrue_S, label);
							EmitError("java.lang.IncompatibleClassChangeError", null);
							ilGenerator.MarkLabel(label);
							for(int k = argcount - 1; k >= 0; k--)
d988 1
a988 1
								dup.Load(k);
a990 15
						else if(!thisType.IsUnloadable && !thisType.IsSubTypeOf(cpi.GetClassType(classLoader)))
						{
							EmitError("java.lang.IncompatibleClassChangeError", null);
							thisType = null;
						}
						MethodWrapper method = (thisType != null) ? GetMethod(cpi, thisType, instr.NormalizedOpCode) : null;
						CodeEmitter emit = null;
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
						{
							emit = method.EmitCall;
						}
						else
						{
							emit = method.EmitCallvirt;
						}
d2102 41
@


1.7
log
@no message
@
text
@d484 1
a484 1
				// every instruction has an associated label, for now
d994 1
d997 9
a1005 1
							if(cpi.Name == "<init>")
d1007 1
a1007 1
								if(VerifierTypeWrapper.IsNew(type))
d1009 15
a1023 15
									if(!thisType.IsUnloadable && (thisType.IsAbstract || thisType.IsInterface))
									{
										// the CLR gets confused when we do a newobj on an abstract class,
										// so we set method to null, to basically just comment out the constructor
										// call (the InstantiationError was already emitted at the "new" bytecode)
										method = null;
									}
									// we have to construct a list of all the unitialized references to the object
									// we're about to create on the stack, so that we can reconstruct the stack after
									// the "newobj" instruction
									int trivcount = 0;
									bool nontrivial = false;
									bool[] stackfix = new bool[ma.GetStackHeight(i) - (argcount + 1)];
									bool[] localsfix = new bool[m.MaxLocals];
									for(int j = 0; j < stackfix.Length; j++)
d1025 2
a1026 1
										if(ma.GetRawStackTypeWrapper(i, argcount + 1 + j) == type)
d1028 1
a1028 12
											stackfix[j] = true;
											if(trivcount == j)
											{
												trivcount++;
											}
											else
											{
												// if there is other stuff on the stack between the new object
												// references, we need to do more work to construct the proper stack
												// layout after the newobj instruction
												nontrivial = true;
											}
d1030 1
a1030 4
									}
									for(int j = 0; j < localsfix.Length; j++)
									{
										if(ma.GetLocalTypeWrapper(i, j) == type)
d1032 3
a1034 1
											localsfix[j] = true;
d1038 4
a1041 1
									if(method != null)
d1043 2
a1044 1
										method.EmitNewobj.Emit(ilGenerator);
d1046 8
a1053 1
									else
d1055 1
a1055 5
										for(int j = 0; j < argcount; j++)
										{
											ilGenerator.Emit(OpCodes.Pop);
										}
										ilGenerator.Emit(OpCodes.Ldnull);
d1057 12
a1068 1
									if(java_lang_Throwable == null)
d1070 3
a1072 1
										java_lang_Throwable = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassBySlashedName("java/lang/Throwable");
d1074 10
a1083 1
									if(thisType.IsSubTypeOf(java_lang_Throwable))
d1085 1
a1085 4
										// HACK if the next instruction isn't an athrow, we need to
										// call fillInStackTrace, because the object might be used
										// to print out a stack trace without ever being thrown
										if(code[i + 1].NormalizedOpCode != NormalizedByteCode.__athrow)
d1087 14
a1100 3
											ilGenerator.Emit(OpCodes.Dup);
											ilGenerator.Emit(OpCodes.Call, fillInStackTraceMethod);
											ilGenerator.Emit(OpCodes.Pop);
d1103 1
a1103 1
									if(nontrivial)
d1105 1
a1105 7
										// this could be done a little more efficiently, but since in practice this
										// code never runs (for code compiled from Java source) it doesn't
										// really matter
										LocalBuilder newobj = ilGenerator.DeclareLocal(thisType.Type);
										ilGenerator.Emit(OpCodes.Stloc, newobj);
										LocalBuilder[] tempstack = new LocalBuilder[stackfix.Length];
										for(int j = 0; j < stackfix.Length; j++)
d1107 1
a1107 17
											if(!stackfix[j])
											{
												TypeWrapper stacktype = ma.GetRawStackTypeWrapper(i, argcount + 1 + j);
												// it could be another new object reference (not from current invokespecial <init>
												// instruction)
												if(stacktype == VerifierTypeWrapper.Null)
												{
													// TODO handle null stack entries
													throw new NotImplementedException();
												}
												else if(!VerifierTypeWrapper.IsNew(stacktype))
												{
													LocalBuilder lb = ilGenerator.DeclareLocal(stacktype.TypeOrUnloadableAsObject);
													ilGenerator.Emit(OpCodes.Stloc, lb);
													tempstack[j] = lb;
												}
											}
d1109 1
a1109 1
										for(int j = stackfix.Length - 1; j >= 0; j--)
d1111 1
a1111 16
											if(stackfix[j])
											{
												ilGenerator.Emit(OpCodes.Ldloc, newobj);
											}
											else if(tempstack[j] != null)
											{
												ilGenerator.Emit(OpCodes.Ldloc, tempstack[j]);
											}
										}
										for(int j = 0; j < localsfix.Length; j++)
										{
											if(localsfix[j])
											{
												ilGenerator.Emit(OpCodes.Ldloc, newobj);
												ilGenerator.Emit(OpCodes.Stloc, GetLocal(typeof(object), j));
											}
d1114 1
a1114 1
									else
d1116 1
a1116 1
										if(trivcount == 0)
d1118 2
a1119 8
											ilGenerator.Emit(OpCodes.Pop);
										}
										else
										{
											for(int j = 1; j < trivcount; j++)
											{
												ilGenerator.Emit(OpCodes.Dup);
											}
d1125 1
a1125 1
									if(method != null)
d1127 1
a1127 1
										method.EmitCall.Emit(ilGenerator);
d1131 4
a1134 15
										// if we're a constructor and the call to the base class constructor
										// wasn't accessible, we need make sure that there is no code path that
										// returns from the constructor, otherwise the method will be not verifiable
										// TODO this isn't anywhere near a proper solution, but for the time being it works
										// some things to consider:
										// - only pull this full when calls to the base class constructor fail
										// - when control flow is complex, this trivial solution will not work
										ilGenerator.Emit(OpCodes.Ldnull);
										ilGenerator.Emit(OpCodes.Throw);
										return;
										//										for(int j = 0; j < argcount + 1; j++)
										//										{
										//											ilGenerator.Emit(OpCodes.Pop);
										//										}
										//										EmitPlaceholder(cpi.Signature.Substring(cpi.Signature.LastIndexOf(')') + 1));
d1146 15
a1160 5
									for(int j = 0; j < argcount + 1; j++)
									{
										ilGenerator.Emit(OpCodes.Pop);
									}
									EmitPlaceholder(cpi.GetRetType(classLoader));
d1166 1
a1166 1
							if(method != null)
d1168 1
a1168 1
								method.EmitCallvirt.Emit(ilGenerator);
d2238 1
a2238 1
			MethodWrapper dummy = new MethodWrapper(null, null, null, Modifiers.Synthetic);
@


1.6
log
@no message
@
text
@d112 5
a116 5
//		Console.WriteLine("before processing:");
//		foreach(ExceptionTableEntry e in ar)
//		{
//			Console.WriteLine("{0} to {1} handler {2}", e.start_pc, e.end_pc, e.handler_pc);
//		}
d121 2
a122 5
	restart:
		for(int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
			for(int j = i + 1; j < ar.Count; j++)
d124 2
a125 2
				ExceptionTableEntry ej = (ExceptionTableEntry)ar[j];
				if(ei.start_pc <= ej.start_pc && ei.end_pc > ej.start_pc)
d127 2
a128 2
					// try1.j
					if(ej.end_pc > ei.end_pc)
d130 36
a165 32
						ExceptionTableEntry emi = new ExceptionTableEntry();
						emi.start_pc = ej.start_pc;
						emi.end_pc = ei.end_pc;
						emi.catch_type = ei.catch_type;
						emi.handler_pc = ei.handler_pc;
						ExceptionTableEntry emj = new ExceptionTableEntry();
						emj.start_pc = ej.start_pc;
						emj.end_pc = ei.end_pc;
						emj.catch_type = ej.catch_type;
						emj.handler_pc = ej.handler_pc;
						ei.end_pc = emi.start_pc;
						ej.start_pc = emj.end_pc;
						ar.Insert(j, emj);
						ar.Insert(i + 1, emi);
						goto restart;
					}
					else if(ej.end_pc < ei.end_pc)	// try2.j
					{
						ExceptionTableEntry emi = new ExceptionTableEntry();
						emi.start_pc = ej.start_pc;
						emi.end_pc = ej.end_pc;
						emi.catch_type = ei.catch_type;
						emi.handler_pc = ei.handler_pc;
						ExceptionTableEntry eei = new ExceptionTableEntry();
						eei.start_pc = ej.end_pc;
						eei.end_pc = ei.end_pc;
						eei.catch_type = ei.catch_type;
						eei.handler_pc = ei.handler_pc;
						ei.end_pc = emi.start_pc;
						ar.Insert(i + 1, eei);
						ar.Insert(i + 1, emi);
						goto restart;
a168 1
		}
d189 2
a190 5
	restart_jsr:
		for(int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
			for(int j = FindPcIndex(ei.start_pc), e = FindPcIndex(ei.end_pc); j < e; j++)
d192 2
a193 1
				if(m.Instructions[j].NormalizedOpCode == NormalizedByteCode.__jsr)
d195 1
a195 2
					int targetPC = m.Instructions[j].NormalizedArg1 + m.Instructions[j].PC;
					if(targetPC < ei.start_pc || targetPC >= ei.end_pc)
d197 12
a208 8
						ExceptionTableEntry en = new ExceptionTableEntry();
						en.catch_type = ei.catch_type;
						en.handler_pc = ei.handler_pc;
						en.start_pc = (ushort)m.Instructions[j + 1].PC;
						en.end_pc = ei.end_pc;
						ei.end_pc = (ushort)m.Instructions[j].PC;
						ar.Insert(i + 1, en);
						goto restart_jsr;
a211 1
		}
d226 5
a230 5
//							for(int j = 0; j < instr.Values.Length; j++)
//							{
//								state[FindPcIndex(instr.PC + instr.TargetOffsets[j])] += s;
//							}
//							state[FindPcIndex(instr.PC + instr.DefaultOffset)] += s;
d300 5
a304 5
//		Console.WriteLine("after processing:");
//		foreach(ExceptionTableEntry e in ar)
//		{
//			Console.WriteLine("{0} to {1} handler {2}", e.start_pc, e.end_pc, e.handler_pc);
//		}
d829 43
a871 43
						switch(instr.NormalizedArg1)
						{
							case -1:
								ilGenerator.Emit(OpCodes.Ldc_I4_M1);
								break;
							case 0:
								ilGenerator.Emit(OpCodes.Ldc_I4_0);
								break;
							case 1:
								ilGenerator.Emit(OpCodes.Ldc_I4_1);
								break;
							case 2:
								ilGenerator.Emit(OpCodes.Ldc_I4_2);
								break;
							case 3:
								ilGenerator.Emit(OpCodes.Ldc_I4_3);
								break;
							case 4:
								ilGenerator.Emit(OpCodes.Ldc_I4_4);
								break;
							case 5:
								ilGenerator.Emit(OpCodes.Ldc_I4_5);
								break;
							case 6:
								ilGenerator.Emit(OpCodes.Ldc_I4_6);
								break;
							case 7:
								ilGenerator.Emit(OpCodes.Ldc_I4_7);
								break;
							case 8:
								ilGenerator.Emit(OpCodes.Ldc_I4_8);
								break;
							default:
								if(instr.NormalizedArg1 >= -128 && instr.NormalizedArg1 <= 127)
								{
									ilGenerator.Emit(OpCodes.Ldc_I4_S, (sbyte)instr.NormalizedArg1);
								}
								else
								{
									ilGenerator.Emit(OpCodes.Ldc_I4, instr.NormalizedArg1);
								}
								break;
						}
d988 1
a988 1
						else if(thisType != null && !thisType.IsSubTypeOf(cpi.GetClassType(classLoader)))
d1000 1
a1000 1
									if(thisType != null && (thisType.IsAbstract || thisType.IsInterface))
d1004 1
a1004 1
										// call (the InstantionError was already emitted at the "new" bytecode)
d1149 5
a1153 5
//										for(int j = 0; j < argcount + 1; j++)
//										{
//											ilGenerator.Emit(OpCodes.Pop);
//										}
//										EmitPlaceholder(cpi.Signature.Substring(cpi.Signature.LastIndexOf(')') + 1));
d1363 1
a1363 1
							LocalBuilder localInt = ilGenerator.DeclareLocal(typeof(int));
d2195 46
d2245 1
a2245 2
		TypeWrapper wrapper = cpi.GetClassType(classLoader);
		if(wrapper.IsUnloadable)
d2247 10
a2256 3
			// TODO instead of this NoClassDefFoundError, we should return a dynamic MethodWrapper that
			// dynamically calls the method
			EmitError("java.lang.NoClassDefFoundError", wrapper.Name);
d2260 1
d2577 17
@


1.5
log
@no message
@
text
@d84 1
d109 1
a109 1
		ma = new MethodAnalyzer(m, classLoader);
a110 9
		// HACK force types of locals to be loaded, so we don't run into a problem later (GetLocal cannot handle an unloadable type)
		for(int i = 0; i < m.MaxLocals; i++)
		{
			string t = ma.GetDeclaredLocalType(i);
			if(t != null && t != "Lnull")
			{
				classLoader.ExpressionType(t);
			}
		}
a354 1
		private ClassLoaderWrapper classLoader;
d359 1
a359 1
		internal DupHelper(ClassLoaderWrapper classLoader, ILGenerator ilgen, int count)
a360 1
			this.classLoader = classLoader;
d366 1
a366 1
		internal DupHelper SetType(int i, string type)
d368 1
a368 1
			if(type == "Lnull")
d372 1
a372 1
			else if(type[0] != 'N')
d374 1
a374 2
				// TODO handle class not found
				locals[i] = ilgen.DeclareLocal(classLoader.ExpressionType(type));
a430 15
		catch(Exception x1)
		{
			// HACK because the verifier currently cannot deal with unloadable classes, we have
			// to work around it by just generating code to throw a verify error
			if(x1.GetType().FullName == "java.lang.ClassNotFoundException")
			{
				Type verifyError = ClassLoaderWrapper.GetType("java.lang.VerifyError");
				string msg = string.Format("{0}.{1}{2} cannot be verified due to unloadable class {3}", clazz.Name, m.Name, m.Signature, x1.Message);
				ilGenerator.Emit(OpCodes.Ldstr, msg);
				ilGenerator.Emit(OpCodes.Newobj, verifyError.GetConstructor(new Type[] { typeof(string) }));
				ilGenerator.Emit(OpCodes.Throw);
				return;
			}
			throw;
		}
d523 2
a524 3
								// TODO handle class not found
								string t = ma.GetRawStackType(i, n);
								if(t.Length > 1 && (t[0] == 'N' || t[0] == 'U'))
d526 7
a532 10
									if(t[0] == 'U')
									{
										// we're inside a constructor and the uninitialized this is passed into an exception block!
										ilGenerator.Emit(OpCodes.Pop);
										stack.Push("this");
									}
									else
									{
										// unitialized references (new objects) aren't really there
									}
d534 1
a534 1
								else if(t == "Lnull")
d540 1
a540 1
									LocalBuilder local = ilGenerator.DeclareLocal(classLoader.ExpressionType(t));
d579 2
a580 3
									// TODO handle class not found
									string t = ma.GetRawStackType(bc.TargetIndex, n);
									if((t.Length > 1 && (t[0] == 'N' || t[0] == 'U')) || t == "Lnull")
a581 5
										if(t[0] == 'U')
										{
											// we're inside a constructor and the uninitialized this is passed into an exception block!
											ilGenerator.Emit(OpCodes.Ldarg_0);
										}
d588 14
d604 1
a604 1
										LocalBuilder local = ilGenerator.DeclareLocal(classLoader.ExpressionType(t));
d720 2
a721 2
											string t = ma.GetRawStackType(bc.TargetIndex, (stack - 1) - n);
											if(t == "Lnull")
d725 1
a725 1
											else if(t[0] == 'U')
d761 1
a761 1
							EmitPlaceholder(cpi.Signature);
d771 1
a771 1
							// because of the way interface merging works, an object reference is valid
d773 1
a773 1
							if(field.FieldType != typeof(object) && ma.GetRawStackType(i, 0) == "Ljava/lang/Object;")
d788 2
a789 2
						TypeWrapper thisType = LoadClass(SigTypeToClassName(ma.GetRawStackType(i, 0), cpi.Class));
						if(thisType != null)
d799 1
a799 1
						EmitPlaceholder(cpi.Signature);
d805 2
a806 2
						TypeWrapper thisType = LoadClass(SigTypeToClassName(ma.GetRawStackType(i, 1), cpi.Class));
						if(thisType != null)
d811 1
a811 1
								// because of the way interface merging works, an object reference is valid
d813 1
a813 1
								if(field.FieldType != typeof(object) && ma.GetRawStackType(i, 0) == "Ljava/lang/Object;")
d935 2
a936 2
							SigEnumerator sig = new SigEnumerator(cpi.Signature);
							while(sig.MoveNext())
d940 1
a940 1
							EmitPlaceholder(cpi.Signature.Substring(cpi.Signature.LastIndexOf(')') + 1));
d953 3
a955 8
						SigEnumerator sig = new SigEnumerator(cpi.Signature);
						int argcount = 0;
						while(sig.MoveNext())
						{
							argcount++;
						}
						string type = ma.GetRawStackType(i, argcount);
						TypeWrapper thisType = LoadClass(SigTypeToClassName(type, cpi.Class));
d961 23
a983 2
							thisType = LoadClass(cpi.Class);
							if(thisType != null)
d985 1
a985 25
								DupHelper dup = new DupHelper(classLoader, ilGenerator, argcount);
								for(int k = 0; k < argcount; k++)
								{
									dup.SetType(k, ma.GetRawStackType(i, k));
								}
								for(int k = 0; k < argcount; k++)
								{
									dup.Store(k);
								}
								// TODO this IncompatibleClassChangeError check should also be applied
								// for other locations where we can "consume" an object reference in the
								// place of an interface reference (putstatic / putfield / arguments for invoke*).
								// TODO it turns out that when an interface ref is expected, *any* type will be accepted!
								ilGenerator.Emit(OpCodes.Dup);
								Label label = ilGenerator.DefineLabel();
								ilGenerator.Emit(OpCodes.Brfalse_S, label);
								ilGenerator.Emit(OpCodes.Isinst, thisType.Type);
								ilGenerator.Emit(OpCodes.Dup);
								ilGenerator.Emit(OpCodes.Brtrue_S, label);
								EmitError("java.lang.IncompatibleClassChangeError", null);
								ilGenerator.MarkLabel(label);
								for(int k = argcount - 1; k >= 0; k--)
								{
									dup.Load(k);
								}
d988 1
a988 1
						else if(thisType != null && !thisType.IsSubTypeOf(LoadClass(cpi.Class)))
d998 1
a998 1
								if(type[0] == 'N')
d1016 1
a1016 1
										if(ma.GetRawStackType(i, argcount + 1 + j) == type)
d1034 1
a1034 1
										if(ma.GetLocalType(i, j) == type)
d1052 3
a1054 11
									// TODO it is probably a better idea to do this in the constructor for each class
									// derived from java.lang.Throwable, but if we do move this to the constructor, we
									// should still call it here for non-Java exceptions (that aren't derived from Throwable)
									Type t = ExpressionType(type.Substring(type.IndexOf(';') + 1));
									if(t == null)
									{
										// If the type couldn't be loaded, we continue we object to make sure
										// the code remains verifiable (the ExpressionType call above already generated
										// code to throw an exception, but the remaing code still needs to be verifiable,
										// even though it is unreachable).
										t = typeof(object);
d1056 1
a1056 1
									if(typeof(Exception).IsAssignableFrom(t))
d1073 1
a1073 1
										LocalBuilder newobj = ilGenerator.DeclareLocal(t);
d1080 1
a1080 1
												string stacktype = ma.GetRawStackType(i, argcount + 1 + j);
d1083 1
a1083 1
												if(stacktype[0] != 'N')
d1085 6
a1090 3
													// TODO handle Lnull stack entries
													// TODO handle class not found
													LocalBuilder lb = ilGenerator.DeclareLocal(classLoader.ExpressionType(stacktype));
d1169 1
a1169 1
									EmitPlaceholder(cpi.Signature.Substring(cpi.Signature.LastIndexOf(')') + 1));
d1185 1
a1185 1
								EmitPlaceholder(cpi.Signature.Substring(cpi.Signature.LastIndexOf(')') + 1));
d1203 3
a1205 4
								// TODO handle class not found
								Type retType = classLoader.RetTypeFromSig(m.Method.Signature);
								rc.Local = ilGenerator.DeclareLocal(retType);
								// because of the way interface merging works, an object reference is valid
d1207 1
a1207 1
								if(retType.IsInterface && m.Method.Signature.Substring(m.Method.Signature.LastIndexOf(')') + 1) != ma.GetRawStackType(i, 0))
d1209 1
a1209 1
									ilGenerator.Emit(OpCodes.Castclass, retType);
d1233 2
a1234 3
								// TODO handle class not found
								Type retType = classLoader.RetTypeFromSig(m.Method.Signature);
								// because of the way interface merging works, an object reference is valid
d1236 1
a1236 1
								if(retType.IsInterface && m.Method.Signature.Substring(m.Method.Signature.LastIndexOf(')') + 1) != ma.GetRawStackType(i, 0))
d1238 1
a1238 1
									ilGenerator.Emit(OpCodes.Castclass, retType);
d1242 1
a1242 1
									LocalBuilder local = ilGenerator.DeclareLocal(retType);
d1257 2
a1258 2
						string type = ma.GetLocalType(i, instr.NormalizedArg1);
						if(type == "Lnull")
d1263 1
a1263 1
						else if(type[0] == 'N')
d1267 1
a1267 1
						else if(type[0] == 'U')
d1281 1
a1281 1
								if(type != ma.GetDeclaredLocalType(instr.NormalizedArg1))
d1283 1
a1283 2
									// TODO handle class not found
									ilGenerator.Emit(OpCodes.Castclass, classLoader.ExpressionType(ma.GetLocalType(i, instr.NormalizedArg1)));
d1291 1
a1291 1
						string type = ma.GetRawStackType(i, 0);
d1293 1
a1293 1
						if(type.StartsWith("Lret;"))
d1297 1
a1297 1
						else if(type[0] == 'N')
d1305 1
a1305 1
						else if(type[0] == 'U')
d1344 2
a1345 2
						TypeWrapper wrapper = LoadClass(instr.MethodCode.Method.ClassFile.GetConstantPoolClass(instr.Arg1));
						if(wrapper != null && (wrapper.IsAbstract || wrapper.IsInterface))
d1354 7
a1360 2
						TypeWrapper wrapper = LoadClass(instr.MethodCode.Method.ClassFile.GetConstantPoolClass(instr.Arg1));
						if(wrapper != null)
d1385 7
a1391 2
						TypeWrapper wrapper = LoadClass(instr.MethodCode.Method.ClassFile.GetConstantPoolClass(instr.Arg1));
						if(wrapper != null)
d1430 7
a1436 2
						TypeWrapper wrapper = LoadClass(instr.MethodCode.Method.ClassFile.GetConstantPoolClass(instr.Arg1));
						if(wrapper != null)
d1444 7
a1450 2
						TypeWrapper wrapper = LoadClass(instr.MethodCode.Method.ClassFile.GetConstantPoolClass(instr.Arg1));
						if(wrapper != null)
d1803 3
a1805 3
						new DupHelper(classLoader, ilGenerator, 2)
							.SetType(0, ma.GetRawStackType(i, 0))
							.SetType(1, ma.GetRawStackType(i, 1))
d1813 1
a1813 1
						if(ma.GetRawStackType(i, 0)[0] != 'N')
d1820 2
a1821 2
						string type1 = ma.GetRawStackType(i, 0);
						if(type1 == "D" || type1 == "J")
d1827 1
a1827 1
							new DupHelper(classLoader, ilGenerator, 2)
d1829 1
a1829 1
								.SetType(1, ma.GetRawStackType(i, 1))
d1840 3
a1842 3
						new DupHelper(classLoader, ilGenerator, 2)
							.SetType(0, ma.GetRawStackType(i, 0))
							.SetType(1, ma.GetRawStackType(i, 1))
d1851 2
a1852 2
						string type1 = ma.GetRawStackType(i, 0);
						if(type1 == "D" || type1 == "J")
d1854 1
a1854 1
							new DupHelper(classLoader, ilGenerator, 2)
d1856 1
a1856 1
								.SetType(1, ma.GetRawStackType(i, 1))
d1865 1
a1865 1
							new DupHelper(classLoader, ilGenerator, 3)
d1867 2
a1868 2
								.SetType(1, ma.GetRawStackType(i, 1))
								.SetType(2, ma.GetRawStackType(i, 2))
d1882 3
a1884 3
						string type1 = ma.GetRawStackType(i, 0);
						string type2 = ma.GetRawStackType(i, 1);
						if(type1 == "D" || type1 == "J")
d1886 1
a1886 1
							if(type2 == "D" || type2 == "J")
d1889 1
a1889 1
								new DupHelper(classLoader, ilGenerator, 2)
d1901 1
a1901 1
								new DupHelper(classLoader, ilGenerator, 3)
d1904 1
a1904 1
									.SetType(2, ma.GetRawStackType(i, 2))
d1916 2
a1917 2
							string type3 = ma.GetRawStackType(i, 2);
							if(type3 == "D" || type3 == "J")
d1920 1
a1920 1
								new DupHelper(classLoader, ilGenerator, 3)
d1936 1
a1936 1
								new DupHelper(classLoader, ilGenerator, 4)
d1940 1
a1940 1
									.SetType(3, ma.GetRawStackType(i, 3))
d1956 4
a1959 4
						new DupHelper(classLoader, ilGenerator, 3)
							.SetType(0, ma.GetRawStackType(i, 0))
							.SetType(1, ma.GetRawStackType(i, 1))
							.SetType(2, ma.GetRawStackType(i, 2))
d1970 2
a1971 2
						string type1 = ma.GetRawStackType(i, 0);
						if(type1 == "D" || type1 == "J")
d1977 1
a1977 1
							if(type1[0] != 'N')
d1981 1
a1981 1
							if(ma.GetRawStackType(i, 1)[0] != 'N')
d1990 1
a1990 1
						if(ma.GetRawStackType(i, 0)[0] != 'N')
d2073 2
a2074 2
						string subid = ma.GetLocalType(i, instr.Arg1);
						int[] callsites = ma.GetCallSites(int.Parse(subid.Substring("Lret;".Length)));
d2129 8
a2136 2
		TypeWrapper wrapper = LoadClass(cpi.Class);
		if(wrapper != null)
d2155 1
a2155 9
							// HACK for the time being we handle fields of an unloadable type here
							if(field.EmitGet == null && field.EmitSet == null)
							{
								EmitError("java.lang.NoClassDefFoundError", "Field " + cpi.Class + "." + cpi.Name + " is is of the unloadable type " + cpi.Signature);
							}
							else
							{
								return field;
							}
d2199 8
a2206 2
		TypeWrapper wrapper = LoadClass(cpi.Class);
		if(wrapper != null)
d2218 1
a2218 1
				MethodDescriptor md = new MethodDescriptor(classLoader, cpi.Name, cpi.Signature);
d2251 1
a2251 9
							// HACK for the time being we handle methods with an unloadable type in the sig here
							if(method.EmitCall == null && method.EmitCallvirt == null && method.EmitNewobj == null)
							{
								EmitError("java.lang.NoClassDefFoundError", "Method " + cpi.Class + "." + cpi.Name + cpi.Signature + " has an unloadable type in its signature");
							}
							else
							{
								return method;
							}
d2260 1
a2260 1
								method = thisType.GetMethodWrapper(new MethodDescriptor(classLoader, cpi.Name, cpi.Signature), false);
d2293 2
a2294 2
			TypeWrapper type = classLoader.LoadClassByDottedName(errorType);
			MethodWrapper method = type.GetMethodWrapper(new MethodDescriptor(classLoader, "<init>", "(Ljava/lang/String;)V"), false);
d2304 2
a2305 2
			TypeWrapper type = classLoader.LoadClassByDottedName(errorType);
			MethodWrapper method = type.GetMethodWrapper(new MethodDescriptor(classLoader, "<init>", "()V"), false);
d2313 3
a2315 1
	private TypeWrapper LoadClass(string classname)
d2336 2
a2337 1
	private Type ExpressionType(string type)
d2339 9
a2347 1
		try
d2349 1
a2349 1
			return classLoader.ExpressionType(type);
d2351 1
a2351 1
		catch(Exception)
d2353 1
a2353 3
			// TODO we should freeze the exception here, instead of always throwing a NoClassDefFoundError
			EmitError("java.lang.NoClassDefFoundError", type);
			return null;
d2357 1
a2357 1
	private static string SigTypeToClassName(string type, string nullType)
d2359 21
a2379 1
		switch(type[0])
a2380 19
			case 'N':
			case 'U':
			{
				string chop = type.Substring(type.IndexOf(';') + 2);
				return chop.Substring(0, chop.Length - 1);
			}
			case 'L':
				if(type == "Lnull")
				{
					return nullType;
				}
				else
				{
					return type.Substring(1, type.Length - 2);
				}
			case '[':
				return type;
			default:
				throw new InvalidOperationException();
d2382 1
a2382 5
	}

	private void EmitPlaceholder(string sig)
	{
		switch(sig[0])
d2384 1
a2384 24
			case 'L':
			case '[':
				ilGenerator.Emit(OpCodes.Ldnull);
				break;
			case 'Z':
			case 'B':
			case 'S':
			case 'C':
			case 'I':
				ilGenerator.Emit(OpCodes.Ldc_I4_0);
				break;
			case 'J':
				ilGenerator.Emit(OpCodes.Ldc_I8, 0L);
				break;
			case 'F':
				ilGenerator.Emit(OpCodes.Ldc_R4, 0.0f);
				break;
			case 'D':
				ilGenerator.Emit(OpCodes.Ldc_R8, 0.0);
				break;
			case 'V':
				break;
			default:
				throw new InvalidOperationException();
d2463 2
a2464 2
			string t = ma.GetDeclaredLocalType(index);
			if(t != null && t != "Lnull")
d2466 1
a2466 2
				// TODO handle class not found
				type = classLoader.ExpressionType(t);
@


1.4
log
@no message
@
text
@d647 9
a655 1
							ilGenerator.BeginCatchBlock(typeof(Exception));
d660 1
a660 1
							if(excType == typeof(Exception))
d662 23
a684 3
								ilGenerator.Emit(OpCodes.Call, mapExceptionFastMethod);
								ilGenerator.Emit(OpCodes.Stloc, local);
								ilGenerator.Emit(OpCodes.Leave, label);
d1096 9
a1104 3
										ilGenerator.Emit(OpCodes.Dup);
										ilGenerator.Emit(OpCodes.Call, fillInStackTraceMethod);
										ilGenerator.Emit(OpCodes.Pop);
d2557 7
@


1.3
log
@no message
@
text
@d110 9
d435 2
a436 2
			// TODO uncomment next line
			//if(JVM.IsStaticCompiler)
d442 15
d2133 9
a2141 1
							return field;
d2231 9
a2239 1
							return method;
@


1.2
log
@no message
@
text
@d527 1
a527 1
								if(t.Length > 1 && t[0] == 'N')
d529 10
a538 2
									// unitialized references aren't really there
									continue;
d540 1
a540 1
								if(t == "Lnull")
d554 2
a555 2
								LocalBuilder local = (LocalBuilder)stack.Pop();
								if(local == null)
d559 4
d565 1
a565 1
									ilGenerator.Emit(OpCodes.Ldloc, local);
d587 1
a587 1
									if((t.Length > 1 && t[0] == 'N') || t == "Lnull")
d589 5
d597 1
a597 1
										// if it is a real null or an uniti
d690 2
a691 1
											if(ma.GetRawStackType(bc.TargetIndex, (stack - 1) - n) == "Lnull")
d694 5
@


1.1
log
@Initial revision
@
text
@d422 2
a423 1
			ilGenerator.Emit(OpCodes.Ldstr, string.Format("(class: {0}, method: {1}, signature: {2}, offset: {3}, instruction: {4}) {5}", x.Class, x.Method, x.Signature, x.ByteCodeOffset, x.Instruction, x.Message));
d426 5
d876 2
d895 3
d1162 1
a1162 1
								if(retType != typeof(object) && ma.GetRawStackType(i, 0) == "Ljava/lang/Object;")
d1192 1
a1192 1
								if(retType != typeof(object) && ma.GetRawStackType(i, 0) == "Ljava/lang/Object;")
@


1.1.1.1
log
@no message
@
text
@@
