head	1.19;
access;
symbols
	v8_1_5717_0:1.19
	v8_1:1.19.0.2
	v8_0_5449_1:1.18
	v8_0_5449_0:1.18
	v8_0:1.18.0.2
	v7_4_5196_0:1.16
	v7_4:1.16.0.4
	v7_3:1.16.0.2
	v7_2_4630_6:1.15
	v7_2_4630_5:1.15
	v7_2_4630_4:1.15
	v7_2_4630_3:1.15
	v7_2_4630_2:1.15
	v0_46_0_4:1.14
	v7_2_4630_1:1.15
	v7_2:1.15.0.2
	v7_1_4532_2:1.14
	v7_1_4532_1:1.14
	v7_1_4532_0:1.14
	v7_1:1.14.0.8
	v7_0_4335_3:1.14
	v7_0_4335_2:1.14
	v7_0_4335_1:1.14
	v0_46_0_2:1.14
	v7_0_4335_0:1.14
	v7_0:1.14.0.6
	v0_40_0_6:1.13
	v0_40_0_5:1.13
	v0_46_0_1:1.14
	v0_46_0_0:1.14
	v0_46:1.14.0.4
	v0_36_0_14:1.12
	v0_44_0_6:1.14
	v0_44_0_5:1.14
	v0_44_0_4:1.14
	v0_44_0_3:1.14
	v0_44_0_2:1.14
	v0_42_0_7:1.13
	v0_44_0_1:1.14
	v0_44_0_0:1.14
	v0_44:1.14.0.2
	v0_42_0_6:1.13
	v0_42_0_5:1.13
	v0_42_0_4:1.13
	v0_42_0_3:1.13
	v0_42_0_2:1.13
	v0_42_0_1:1.13
	v0_42_0_0:1.13
	v0_42:1.13.0.6
	v0_40_0_3:1.13
	v0_40_0_2:1.13
	v0_40_0_1:1.13
	v0_40_0_0:1.13
	v0_40:1.13.0.4
	v0_36_0_13:1.12
	v0_38_0_1:1.13
	v0_38_0_0:1.13
	v0_38:1.13.0.2
	v0_36_0_9:1.12
	v0_36_0_7:1.12
	v0_36_0_5:1.12
	v0_36_0_4:1.12
	v0_36_0_3:1.12
	v0_36_0_2:1.12
	v0_36_0_1:1.12
	v0_36_0_0:1.12
	v0_36:1.12.0.2
	v0_34_0_3:1.11
	v0_34_0_2:1.11
	v0_34_0_1:1.11
	v0_34_0_0:1.11
	v0_34:1.11.0.6
	v0_32:1.11.0.4
	v0_32_0_0:1.11
	v0_30:1.11.0.2
	v0_28_0_0:1.11
	v0_26_0_1:1.10
	v0_26_0_0:1.10
	v0_24_0_1:1.10
	v0_24_0_0:1.10
	v0_22_0_0:1.10
	v0_20_0_0:1.10
	v0_18_0_0:1.9
	v0_16_0_0:1.9
	v0_14_0_1:1.9
	v0_14_0_0:1.9
	v0_12_0_0:1.9
	v0_10_0_1:1.7
	v0_10_0_0:1.7
	v0_8_0_0:1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.03.05.12.43.14;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2014.06.24.10.32.16;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2014.06.24.09.44.37;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2013.02.23.12.41.02;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2012.08.06.12.12.03;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.28.07.14.37;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.23.08.24.33;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.24.11.35.00;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.23.13.06.44;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.18.11.50.38;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.12.14.36.25;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.29.09.48.05;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.30.15.56.24;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.19
log
@The message of a VM generated java.lang.NoClassDefFoundError exception should be the class name, not the message of the underlying exception.
@
text
@/*
  Copyright (C) 2002-2014 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Reflection;
using IKVM.Internal;

abstract class RetargetableJavaException : ApplicationException
{
	internal RetargetableJavaException(string msg) : base(msg)
	{
	}

	internal RetargetableJavaException(string msg, Exception x) : base(msg, x)
	{
	}

	internal static string Format(string s, object[] args)
	{
		if (args == null || args.Length == 0)
		{
			return s;
		}
		return String.Format(s, args);
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal abstract Exception ToJava();
#elif FIRST_PASS
	internal virtual Exception ToJava()
	{
		return null;
	}
#endif
}

// NOTE this is not a Java exception, but instead it wraps a Java exception that
// was thrown by a class loader. It is used so ClassFile.LoadClassHelper() can catch
// Java exceptions and turn them into UnloadableTypeWrappers without inadvertantly
// hiding exceptions caused by coding errors in the IKVM code.
sealed class ClassLoadingException : RetargetableJavaException
{
	internal ClassLoadingException(Exception x, string className)
		: base(className, x)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		if (!(InnerException is java.lang.Error) && !(InnerException is java.lang.RuntimeException))
		{
			return new java.lang.NoClassDefFoundError(Message.Replace('.', '/')).initCause(InnerException);
		}
		return InnerException;
	}
#endif
}

class LinkageError : RetargetableJavaException
{
	internal LinkageError(string msg) : base(msg)
	{
	}

	internal LinkageError(string msg, Exception x) : base(msg, x)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.LinkageError(Message);
	}
#endif
}

sealed class VerifyError : LinkageError
{
	internal VerifyError() : base("")
	{
	}

	internal VerifyError(string msg) : base(msg)
	{
	}

	internal VerifyError(string msg, Exception x) : base(msg, x)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.VerifyError(Message);
	}
#endif
}

sealed class ClassNotFoundException : RetargetableJavaException
{
	internal ClassNotFoundException(string name) : base(name)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.NoClassDefFoundError(Message);
	}
#endif
}

sealed class ClassCircularityError : LinkageError
{
	internal ClassCircularityError(string msg) : base(msg)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.ClassCircularityError(Message);
	}
#endif
}

sealed class NoClassDefFoundError : LinkageError
{
	internal NoClassDefFoundError(string msg) : base(msg)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.NoClassDefFoundError(Message);
	}
#endif
}

class IncompatibleClassChangeError : LinkageError
{
	internal IncompatibleClassChangeError(string msg) : base(msg)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.IncompatibleClassChangeError(Message);
	}
#endif
}

sealed class IllegalAccessError : IncompatibleClassChangeError
{
	internal IllegalAccessError(string msg) : base(msg)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.IllegalAccessError(Message);
	}
#endif
}

class ClassFormatError : LinkageError
{
	internal ClassFormatError(string msg, params object[] p)
		: base(Format(msg, p))
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.ClassFormatError(Message);
	}
#endif
}

sealed class UnsupportedClassVersionError : ClassFormatError
{
	internal UnsupportedClassVersionError(string msg)
		: base(msg)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.UnsupportedClassVersionError(Message);
	}
#endif
}

sealed class JavaSecurityException : RetargetableJavaException
{
	internal JavaSecurityException(string msg)
		: base(msg)
	{
	}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
	internal override Exception ToJava()
	{
		return new java.lang.SecurityException(Message);
	}
#endif
}
@


1.18
log
@Fixed regression introduced by previous commit. We should not introduce SecurityException, because it conflicts with System.Security.SecurityException.
@
text
@d63 2
a64 2
	internal ClassLoadingException(Exception x)
		: base(x.Message, x)
d73 1
a73 1
			return new java.lang.NoClassDefFoundError(InnerException.Message).initCause(InnerException);
@


1.17
log
@Bug fix. Only the bootstrap class loader is allowed to define classes in the java package.
@
text
@d220 1
a220 1
sealed class SecurityException : RetargetableJavaException
d222 1
a222 1
	internal SecurityException(string msg)
@


1.16
log
@Simplified class loading exception handling.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d219 15
@


1.15
log
@- Marked MemberWrapper class abstract.
- Marked all classes that don't (and shouldn't) have subclasses sealed.
@
text
@d68 1
a68 1
#if !STATIC_COMPILER && !STUB_GENERATOR
d71 4
d129 1
a129 1
		return new java.lang.ClassNotFoundException(Message);
@


1.14
log
@Last set of changes preparing for new stub generator. A massive amount of conditional compilation changes, to skip irrelevant code when building ikvmstub.
@
text
@d61 1
a61 1
class ClassLoadingException : RetargetableJavaException
d94 1
a94 1
class VerifyError : LinkageError
d116 1
a116 1
class ClassNotFoundException : RetargetableJavaException
d130 1
a130 1
class ClassCircularityError : LinkageError
d144 1
a144 1
class NoClassDefFoundError : LinkageError
d172 1
a172 1
class IllegalAccessError : IncompatibleClassChangeError
d201 1
a201 1
class UnsupportedClassVersionError : ClassFormatError
@


1.13
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d47 1
a47 1
#if !STATIC_COMPILER && !FIRST_PASS
d68 1
a68 1
#if !STATIC_COMPILER
d86 1
a86 1
#if !STATIC_COMPILER && !FIRST_PASS
d108 1
a108 1
#if !STATIC_COMPILER && !FIRST_PASS
d122 1
a122 1
#if !STATIC_COMPILER && !FIRST_PASS
d136 1
a136 1
#if !STATIC_COMPILER && !FIRST_PASS
d150 1
a150 1
#if !STATIC_COMPILER && !FIRST_PASS
d164 1
a164 1
#if !STATIC_COMPILER && !FIRST_PASS
d178 1
a178 1
#if !STATIC_COMPILER && !FIRST_PASS
d193 1
a193 1
#if !STATIC_COMPILER && !FIRST_PASS
d208 1
a208 1
#if !STATIC_COMPILER && !FIRST_PASS
@


1.12
log
@Simplified VM -> Class Library interface by taking advantage of the fact that IKVM.Runtime.dll is now compiled in two passes with the second pass linking against the class library.
@
text
@a25 1
using IKVM.Runtime;
@


1.11
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d39 10
a48 1
#if !STATIC_COMPILER
d50 5
d87 1
a87 1
#if !STATIC_COMPILER
d90 1
a90 1
		return JVM.Library.newLinkageError(Message);
d109 1
a109 1
#if !STATIC_COMPILER
d112 1
a112 1
		return JVM.Library.newVerifyError(Message);
d123 1
a123 1
#if !STATIC_COMPILER
d126 1
a126 1
		return JVM.Library.newClassNotFoundException(Message);
d137 1
a137 1
#if !STATIC_COMPILER
d140 1
a140 1
		return JVM.Library.newClassCircularityError(Message);
d151 1
a151 1
#if !STATIC_COMPILER
d154 1
a154 1
		return JVM.Library.newNoClassDefFoundError(Message);
d165 1
a165 1
#if !STATIC_COMPILER
d168 1
a168 1
		return JVM.Library.newIncompatibleClassChangeError(Message);
d179 1
a179 1
#if !STATIC_COMPILER
d182 1
a182 1
		return JVM.Library.newIllegalAccessError(Message);
d187 1
a187 1
internal class ClassFormatError : LinkageError
d190 1
a190 1
		: base(JavaException.Format(msg, p))
d194 1
a194 1
#if !STATIC_COMPILER
d197 1
a197 1
		return JVM.Library.newClassFormatError(Message);
d202 1
a202 1
internal class UnsupportedClassVersionError : ClassFormatError
d209 1
a209 1
#if !STATIC_COMPILER
d212 1
a212 1
		return JVM.Library.newUnsupportedClassVersionError(Message);
a215 128

sealed class JavaException
{
	private JavaException() {}

	internal static string Format(string s, object[] args)
	{
		if(args == null || args.Length == 0)
		{
			return s;
		}
		return String.Format(s, args);
	}

#if !STATIC_COMPILER
	internal static Exception IllegalAccessError(string s, params object[] args)
	{
		return JVM.Library.newIllegalAccessError(Format(s, args));
	}

	internal static Exception IllegalAccessException(string s, params object[] args)
	{
		return JVM.Library.newIllegalAccessException(Format(s, args));
	}

	internal static Exception IncompatibleClassChangeError(string s, params object[] args)
	{
		return JVM.Library.newIncompatibleClassChangeError(Format(s, args));
	}

	internal static Exception NoClassDefFoundError(string s, params object[] args)
	{
		return JVM.Library.newNoClassDefFoundError(Format(s, args));
	}

	internal static Exception UnsatisfiedLinkError(string s, params object[] args)
	{
		s = Format(s, args);
		Tracer.Error(Tracer.Jni, "UnsatisfiedLinkError: {0}", s);
		return JVM.Library.newUnsatisfiedLinkError(s);
	}

	internal static Exception IllegalArgumentException(string s, params object[] args)
	{
		return JVM.Library.newIllegalArgumentException(Format(s, args));
	}

	internal static Exception NegativeArraySizeException()
	{
		return JVM.Library.newNegativeArraySizeException();
	}

	internal static Exception ArrayStoreException()
	{
		return JVM.Library.newArrayStoreException();
	}

	internal static Exception IndexOutOfBoundsException(string s)
	{
		return JVM.Library.newIndexOutOfBoundsException(s);
	}

	internal static Exception StringIndexOutOfBoundsException()
	{
		return JVM.Library.newStringIndexOutOfBoundsException();
	}

	internal static Exception InvocationTargetException(Exception x)
	{
		return JVM.Library.newInvocationTargetException(x);
	}

	internal static Exception UnknownHostException(string s, params object[] args)
	{
		return JVM.Library.newUnknownHostException(Format(s, args));
	}

	internal static Exception ArrayIndexOutOfBoundsException()
	{
		return JVM.Library.newArrayIndexOutOfBoundsException();
	}

	internal static Exception NumberFormatException(string s, params object[] args)
	{
		return JVM.Library.newNumberFormatException(Format(s, args));
	}

	internal static Exception NullPointerException()
	{
		return JVM.Library.newNullPointerException();
	}

	internal static Exception ClassCastException(string s, params object[] args)
	{
		return JVM.Library.newClassCastException(Format(s, args));
	}

	internal static Exception NoSuchFieldError(string s, params object[] args)
	{
		return JVM.Library.newNoSuchFieldError(Format(s, args));
	}

	internal static Exception NoSuchMethodError(string s, params object[] args)
	{
		return JVM.Library.newNoSuchMethodError(Format(s, args));
	}

	internal static Exception InstantiationError(string s, params object[] args)
	{
		return JVM.Library.newInstantiationError(Format(s, args));
	}

	internal static Exception InstantiationException(string s, params object[] args)
	{
		return JVM.Library.newInstantiationException(Format(s, args));
	}

	internal static Exception InterruptedException()
	{
		return JVM.Library.newInterruptedException();
	}

	internal static Exception IllegalMonitorStateException()
	{
		return JVM.Library.newIllegalMonitorStateException();
	}
#endif // !STATIC_COMPILER
}
@


1.10
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d39 1
d41 1
d55 1
d60 1
d73 1
d78 1
d95 1
d100 1
d109 1
d114 1
d123 1
d128 1
d137 1
d142 1
d151 1
d156 1
d165 1
d170 1
d180 1
d185 1
d195 1
d200 1
d216 1
d328 1
@


1.9
log
@*** empty log message ***
@
text
@d42 17
@


1.8
log
@*** empty log message ***
@
text
@d199 3
a201 1
		return JVM.Library.newUnsatisfiedLinkError(Format(s, args));
@


1.7
log
@*** empty log message ***
@
text
@d141 1
a141 1
		: base(string.Format(msg, p))
d168 9
d179 1
a179 1
		return JVM.Library.newIllegalAccessError(string.Format(s, args));
d184 1
a184 1
		return JVM.Library.newIllegalAccessException(string.Format(s, args));
d189 1
a189 1
		return JVM.Library.newIncompatibleClassChangeError(string.Format(s, args));
d194 1
a194 1
		return JVM.Library.newNoClassDefFoundError(string.Format(s, args));
d199 1
a199 1
		return JVM.Library.newUnsatisfiedLinkError(string.Format(s, args));
d204 1
a204 1
		return JVM.Library.newIllegalArgumentException(string.Format(s, args));
d234 1
a234 1
		return JVM.Library.newUnknownHostException(string.Format(s, args));
d244 1
a244 1
		return JVM.Library.newNumberFormatException(string.Format(s, args));
d254 1
a254 1
		return JVM.Library.newClassCastException(string.Format(s, args));
d259 1
a259 1
		return JVM.Library.newNoSuchFieldError(string.Format(s, args));
d264 1
a264 1
		return JVM.Library.newNoSuchMethodError(string.Format(s, args));
d269 1
a269 1
		return JVM.Library.newInstantiationError(string.Format(s, args));
d274 1
a274 1
		return JVM.Library.newInstantiationException(string.Format(s, args));
@


1.6
log
@*** empty log message ***
@
text
@d35 4
d48 4
a59 6
	private int byteCodeOffset;
	private string clazz;
	private string method;
	private string signature;
	private string instruction;

d68 1
a68 1
	internal void SetInfo(int byteCodeOffset, string clazz, string method, string signature, string instruction)
a69 20
		this.byteCodeOffset = byteCodeOffset;
		this.clazz = clazz;
		this.method = method;
		this.signature = signature;
		this.instruction = instruction;
	}

	public override string Message
	{
		get
		{
			if(clazz != null)
			{
				return string.Format("(class: {0}, method: {1}, signature: {2}, offset: {3}, instruction: {4}) {5}", clazz, method, signature, byteCodeOffset, instruction, base.Message);
			}
			else
			{
				return base.Message;
			}
		}
@


1.5
log
@*** empty log message ***
@
text
@a34 8
	protected static Type Load(string clazz)
	{
		Tracer.Info(Tracer.Runtime, "Loading exception class: {0}", clazz);
		TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(clazz);
		tw.Finish();
		return tw.TypeAsTBD;
	}

d46 1
a46 1
		return (Exception)Activator.CreateInstance(Load("java.lang.LinkageError"), new object[] { Message });
d92 1
a92 1
		return (Exception)Activator.CreateInstance(Load("java.lang.VerifyError"), new object[] { Message });
d104 1
a104 1
		return (Exception)Activator.CreateInstance(Load("java.lang.ClassNotFoundException"), new object[] { Message });
d116 1
a116 1
		return (Exception)Activator.CreateInstance(Load("java.lang.ClassCircularityError"), new object[] { Message });
d128 1
a128 1
		return (Exception)Activator.CreateInstance(Load("java.lang.NoClassDefFoundError"), new object[] { Message });
d140 1
a140 1
		return (Exception)Activator.CreateInstance(Load("java.lang.IncompatibleClassChangeError"), new object[] { Message });
d152 1
a152 1
		return (Exception)Activator.CreateInstance(Load("java.lang.IllegalAccessError"), new object[] { Message });
d165 1
a165 1
		return (Exception)Activator.CreateInstance(Load("java.lang.ClassFormatError"), new object[] { Message });
d178 1
a178 1
		return (Exception)Activator.CreateInstance(Load("java.lang.UnsupportedClassVersionError"), new object[] { Message });
a185 8
	private static Type Load(string clazz)
	{
		Tracer.Info(Tracer.Runtime, "Loading exception class: {0}", clazz);
		TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(clazz);
		tw.Finish();
		return tw.TypeAsTBD;
	}

d188 1
a188 1
		return (Exception)Activator.CreateInstance(Load("java.lang.IllegalAccessError"), new object[] { String.Format(s, args) });
d193 1
a193 1
		return (Exception)Activator.CreateInstance(Load("java.lang.IllegalAccessException"), new object[] { String.Format(s, args) });
d198 1
a198 1
		return (Exception)Activator.CreateInstance(Load("java.lang.IncompatibleClassChangeError"), new object[] { String.Format(s, args) });
d203 1
a203 1
		return (Exception)Activator.CreateInstance(Load("java.lang.NoClassDefFoundError"), new object[] { String.Format(s, args) });
d208 1
a208 1
		return (Exception)Activator.CreateInstance(Load("java.lang.UnsatisfiedLinkError"), new object[] { String.Format(s, args) });
d213 1
a213 1
		return (Exception)Activator.CreateInstance(Load("java.lang.IllegalArgumentException"), new object[] { String.Format(s, args) });
d218 1
a218 1
		return (Exception)Activator.CreateInstance(Load("java.lang.NegativeArraySizeException"));
d223 1
a223 1
		return (Exception)Activator.CreateInstance(Load("java.lang.ArrayStoreException"));
d228 1
a228 1
		return (Exception)Activator.CreateInstance(Load("java.lang.IndexOutOfBoundsException"), new object[] { s });
d233 1
a233 1
		return (Exception)Activator.CreateInstance(Load("java.lang.StringIndexOutOfBoundsException"));
d238 1
a238 1
		return (Exception)Activator.CreateInstance(Load("java.lang.reflect.InvocationTargetException"), new object[] { x });
d243 1
a243 1
		return (Exception)Activator.CreateInstance(Load("java.net.UnknownHostException"), new object[] { String.Format(s, args) });
d248 1
a248 1
		return (Exception)Activator.CreateInstance(Load("java.lang.ArrayIndexOutOfBoundsException"));
d253 1
a253 1
		return (Exception)Activator.CreateInstance(Load("java.lang.NumberFormatException"), new object[] { String.Format(s, args) });
d258 1
a258 3
		// if we ever stop remapping exceptions generated in non-Java code, this needs to use
		// reflection to get a real java.lang.NullPointerException
		return new NullReferenceException();
d263 1
a263 1
		return (Exception)Activator.CreateInstance(Load("java.lang.ClassCastException"), new object[] { String.Format(s, args) });
d268 1
a268 1
		return (Exception)Activator.CreateInstance(Load("java.lang.NoSuchFieldError"), new object[] { String.Format(s, args) });
d273 1
a273 1
		return (Exception)Activator.CreateInstance(Load("java.lang.NoSuchMethodError"), new object[] { String.Format(s, args) });
d278 1
a278 1
		return (Exception)Activator.CreateInstance(Load("java.lang.InstantiationError"), new object[] { String.Format(s, args) });
d283 1
a283 1
		return (Exception)Activator.CreateInstance(Load("java.lang.InstantiationException"), new object[] { String.Format(s, args) });
d288 1
a288 1
		return (Exception)Activator.CreateInstance(Load("java.lang.InterruptedException"));
d293 1
a293 1
		return (Exception)Activator.CreateInstance(Load("java.lang.IllegalMonitorStateException"));
@


1.4
log
@*** empty log message ***
@
text
@a226 5
	internal static Exception IllegalStateException(string s, params object[] args)
	{
		return (Exception)Activator.CreateInstance(Load("java.lang.IllegalStateException"), new object[] { String.Format(s, args) });
	}

d247 1
a247 1
	internal static Exception StringIndexOutOfBoundsException(string s)
d249 1
a249 1
		return (Exception)Activator.CreateInstance(Load("java.lang.StringIndexOutOfBoundsException"), new object[] { s });
a256 5
	internal static Exception IOException(string s, params object[] args)
	{
		return (Exception)Activator.CreateInstance(Load("java.io.IOException"), new object[] { String.Format(s, args) });
	}

@


1.3
log
@*** empty log message ***
@
text
@d26 2
d242 1
a242 1
	internal static Exception ArrayStoreException(string s)
d244 1
a244 1
		return (Exception)Activator.CreateInstance(Load("java.lang.ArrayStoreException"), new object[] { s });
d309 5
@


1.2
log
@*** empty log message ***
@
text
@d306 10
@


1.1
log
@*** empty log message ***
@
text
@d27 1
a27 1
sealed class JavaException
d29 3
a31 1
	private JavaException() {}
d33 1
a33 1
	private static Type Load(string clazz)
d41 88
a128 1
	internal static Exception ClassFormatError(string s, params object[] args)
a129 1
		return (Exception)Activator.CreateInstance(Load("java.lang.ClassFormatError"), new object[] { String.Format(s, args) });
d132 1
a132 1
	internal static Exception UnsupportedClassVersionError(string s, params object[] args)
d134 64
a197 1
		return (Exception)Activator.CreateInstance(Load("java.lang.UnsupportedClassVersionError"), new object[] { String.Format(s, args) });
a209 5
	internal static Exception VerifyError(string s, params object[] args)
	{
		return (Exception)Activator.CreateInstance(Load("java.lang.VerifyError"), new object[] { String.Format(s, args) });
	}

a214 9
	internal static Exception ClassNotFoundException(string s, params object[] args)
	{
		if(JVM.IsStaticCompilerPhase1)
		{
			Tracer.Warning(Tracer.Compiler, "ClassNotFoundException: {0}", s);
		}
		return (Exception)Activator.CreateInstance(Load("java.lang.ClassNotFoundException"), new object[] { String.Format(s, args) });
	}

a216 4
		if(JVM.IsStaticCompilerPhase1)
		{
			Tracer.Warning(Tracer.Compiler, "NoClassDefFoundError: {0}", s);
		}
a279 15
	internal static Exception CloneNotSupportedException()
	{
		return (Exception)Activator.CreateInstance(Load("java.lang.CloneNotSupportedException"));
	}

	internal static Exception LinkageError(string s, params object[] args)
	{
		return (Exception)Activator.CreateInstance(Load("java.lang.LinkageError"), new object[] { String.Format(s, args) });
	}

	internal static Exception ClassCircularityError(string s, params object[] args)
	{
		return (Exception)Activator.CreateInstance(Load("java.lang.ClassCircularityError"), new object[] { String.Format(s, args) });
	}

d282 1
a282 1
		// TODO if we ever stop remapping exceptions generated in non-Java code, this needs to use
d297 5
@

