head	1.120;
access;
symbols
	v8_1_5717_0:1.120
	v8_1:1.120.0.2
	v8_0_5449_1:1.119
	v8_0_5449_0:1.119
	v8_0:1.119.0.2
	v7_4_5196_0:1.118
	v7_4:1.118.0.2
	v7_3:1.116.0.2
	v7_2_4630_6:1.110
	v7_2_4630_5:1.110
	v7_2_4630_4:1.110
	v7_2_4630_3:1.110
	v7_2_4630_2:1.110
	v0_46_0_4:1.108
	v7_2_4630_1:1.110
	v7_2:1.110.0.4
	v7_1_4532_2:1.110
	v7_1_4532_1:1.110
	v7_1_4532_0:1.110
	v7_1:1.110.0.2
	v7_0_4335_3:1.108
	v7_0_4335_2:1.108
	v7_0_4335_1:1.108
	v0_46_0_2:1.108
	v7_0_4335_0:1.108
	v7_0:1.108.0.6
	v0_40_0_6:1.95
	v0_40_0_5:1.95
	v0_46_0_1:1.108
	v0_46_0_0:1.108
	v0_46:1.108.0.4
	v0_36_0_14:1.86
	v0_44_0_6:1.108
	v0_44_0_5:1.108
	v0_44_0_4:1.108
	v0_44_0_3:1.108
	v0_44_0_2:1.108
	v0_42_0_7:1.99
	v0_44_0_1:1.108
	v0_44_0_0:1.108
	v0_44:1.108.0.2
	v0_42_0_6:1.99
	v0_42_0_5:1.99
	v0_42_0_4:1.99
	v0_42_0_3:1.99
	v0_42_0_2:1.99
	v0_42_0_1:1.99
	v0_42_0_0:1.99
	v0_42:1.99.0.2
	v0_40_0_3:1.95
	v0_40_0_2:1.95
	v0_40_0_1:1.95
	v0_40_0_0:1.95
	v0_40:1.95.0.2
	v0_36_0_13:1.86
	v0_38_0_1:1.94
	v0_38_0_0:1.94
	v0_38:1.94.0.2
	v0_36_0_9:1.86
	v0_36_0_7:1.86
	v0_36_0_5:1.86
	v0_36_0_4:1.86
	v0_36_0_3:1.86
	v0_36_0_2:1.86
	v0_36_0_1:1.86
	v0_36_0_0:1.86
	v0_36:1.86.0.2
	v0_34_0_3:1.85
	v0_34_0_2:1.85
	v0_34_0_1:1.85
	v0_34_0_0:1.85
	v0_34:1.85.0.2
	v0_32:1.83.0.2
	v0_32_0_0:1.83
	v0_30:1.77.0.2
	v0_28_0_0:1.73
	v0_26_0_1:1.69
	v0_26_0_0:1.69
	v0_24_0_1:1.65
	v0_24_0_0:1.64
	v0_22_0_0:1.59
	v0_20_0_0:1.57
	v0_18_0_0:1.48
	v0_16_0_0:1.46
	v0_14_0_1:1.38
	v0_14_0_0:1.38
	v0_12_0_0:1.35
	v0_10_0_1:1.31
	v0_10_0_0:1.31
	v0_8_0_0:1.6;
locks; strict;
comment	@ * @;


1.120
date	2015.03.24.09.37.25;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2014.04.14.09.05.36;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2013.09.02.12.53.04;	author jfrijters;	state Exp;
branches;
next	1.117;

1.117
date	2013.05.03.10.30.08;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2013.02.18.17.25.59;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2013.02.17.09.35.26;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2013.02.12.11.09.16;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2013.02.07.19.34.06;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2013.02.07.09.10.52;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2013.01.30.16.25.23;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2012.03.25.09.10.29;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2011.11.29.07.03.22;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2010.05.20.04.59.13;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2010.01.29.07.09.12;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2010.01.28.07.14.37;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2010.01.25.07.53.31;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2010.01.06.14.28.38;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2009.11.25.10.18.35;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2009.10.16.07.06.52;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2009.10.14.14.58.41;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2009.07.27.08.06.41;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2009.06.02.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2009.05.26.10.17.57;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2008.12.23.07.11.29;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2008.08.21.06.40.24;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2008.08.21.06.05.25;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2008.08.15.12.01.23;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2008.08.06.12.22.13;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.03.07.13.52;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2008.05.31.10.08.10;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2007.12.19.11.28.12;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2007.06.27.06.13.40;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2007.02.15.09.09.45;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2007.01.16.12.12.08;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2006.09.14.12.55.25;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2006.09.01.07.53.36;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2006.08.23.06.01.45;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2006.08.17.07.33.40;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2006.08.04.13.13.23;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2006.07.26.07.57.19;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2006.07.06.13.53.53;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2006.07.05.12.53.26;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2006.06.28.08.07.29;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.15.09.08.01;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.05.08.19.01;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.27.14.00.04;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2006.02.23.13.20.52;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2006.02.22.14.44.07;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2006.02.10.13.29.19;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2006.01.31.10.13.32;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2006.01.23.10.18.44;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2005.12.29.15.48.33;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2005.12.29.09.57.41;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2005.12.19.15.12.50;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2005.12.12.08.51.36;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.21.20.42.50;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.01.11.16.12;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2005.09.01.07.34.53;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2005.08.25.09.36.36;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2005.08.25.07.46.57;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.19.09.08.43;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.14.15.49.50;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2005.08.05.08.40.55;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2005.08.03.14.10.01;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.03.12.59.18;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.29.12.46.51;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.07.13.10.12;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.07.11.24.10;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.19.11.51.02;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2005.06.16.07.38.08;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2005.06.01.09.49.31;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.31.09.47.14;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.30.15.30.13;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.26.08.05.48;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.24.11.54.20;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.23.08.24.09;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.27.06.10.26;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.15.07.54.32;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.07.11.09.03;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.23.13.02.24;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.16.11.20.47;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.11.14.47.05;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2005.02.02.15.12.20;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.07.11.13.12;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.07.09.34.20;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2005.01.06.09.36.49;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.05.12.32.00;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.21.14.59.46;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.21.10.26.55;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.08.11.07.21;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.07.09.53.43;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.29.09.48.06;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.23.17.46.43;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.16.11.11.54;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.08.10.31.46;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.08.10.01.47;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.04.12.50.34;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.19.13.43.57;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.04.19.30.55;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.27.10.17.35;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.15.13.35.58;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.05.09.37.59;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.30.15.56.25;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.10.07.19.57;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.28.09.46.33;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.14.10.36.39;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.07.08.28.57;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.28.14.35.34;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.27.09.32.35;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.120
log
@Added environment switch IKVM_DISABLE_EAGER_CLASS_LOADING to enable testing late binding.
@
text
@/*
  Copyright (C) 2002-2013 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Threading;
#if STATIC_COMPILER || STUB_GENERATOR
using IKVM.Reflection;
using Type = IKVM.Reflection.Type;
#else
using System.Reflection;
#endif
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Security;
using System.Security.Permissions;
using IKVM.Internal;

#if !STATIC_COMPILER && !STUB_GENERATOR
namespace IKVM.Internal
{
	public static class Starter
	{
		public static void PrepareForSaveDebugImage()
		{
			JVM.IsSaveDebugImage  = true;
		}
	
		public static void SaveDebugImage()
		{
			DynamicClassLoader.SaveDebugImages();
		}

		public static bool ClassUnloading
		{
#if CLASSGC
			get { return JVM.classUnloading; }
			set { JVM.classUnloading = value; }
#else
			get { return false; }
			set { }
#endif
		}

		public static bool RelaxedVerification
		{
			get { return JVM.relaxedVerification; }
			set { JVM.relaxedVerification = value; }
		}

		public static bool AllowNonVirtualCalls
		{
			get { return JVM.AllowNonVirtualCalls; }
			set { JVM.AllowNonVirtualCalls = value; }
		}
	}
}
#endif // !STATIC_COMPILER && !STUB_GENERATOR

namespace IKVM.Internal
{
	static class JVM
	{
		internal const string JarClassList = "--ikvm-classes--/";
#if STATIC_COMPILER
		internal const bool FinishingForDebugSave = false;
		internal const bool IsSaveDebugImage = false;
#elif !STUB_GENERATOR
		private static bool finishingForDebugSave;
		private static int emitSymbols;
		internal static bool IsSaveDebugImage;
#if CLASSGC
		internal static bool classUnloading = true;
#endif
#endif // STATIC_COMPILER
		private static Assembly coreAssembly;
#if !STUB_GENERATOR
		internal static bool relaxedVerification = true;
		internal static bool AllowNonVirtualCalls;
		internal static readonly bool DisableEagerClassLoading = SafeGetEnvironmentVariable("IKVM_DISABLE_EAGER_CLASS_LOADING") != null;
#endif

#if !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
		static JVM()
		{
			if (SafeGetEnvironmentVariable("IKVM_SAVE_DYNAMIC_ASSEMBLIES") != null)
			{
				IsSaveDebugImage = true;
				java.lang.Runtime.getRuntime().addShutdownHook(new java.lang.Thread(ikvm.runtime.Delegates.toRunnable(DynamicClassLoader.SaveDebugImages)));
			}
		}
#endif

		internal static Version SafeGetAssemblyVersion(System.Reflection.Assembly asm)
		{
			// Assembly.GetName().Version requires FileIOPermission,
			// so we parse the FullName manually :-(
			string name = asm.FullName;
			int start = name.IndexOf(", Version=");
			if(start >= 0)
			{
				start += 10;
				int end = name.IndexOf(',', start);
				if(end >= 0)
				{
					return new Version(name.Substring(start, end - start));
				}
			}
			return new Version();
		}

		internal static string SafeGetEnvironmentVariable(string name)
		{
			try
			{
				return Environment.GetEnvironmentVariable(name);
			}
			catch(SecurityException)
			{
				return null;
			}
		}

		internal static Assembly CoreAssembly
		{
			get
			{
#if !STATIC_COMPILER && !STUB_GENERATOR
				if(coreAssembly == null)
				{
#if FIRST_PASS
					throw new InvalidOperationException("This version of IKVM.Runtime.dll was compiled with FIRST_PASS defined.");
#else
					coreAssembly = typeof(java.lang.Object).Assembly;
#endif
				}
#endif // !STATIC_COMPILER
				return coreAssembly;
			}
			set
			{
				coreAssembly = value;
			}
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal static bool FinishingForDebugSave
		{
			get
			{
				return finishingForDebugSave;
			}
			set
			{
				finishingForDebugSave = value;
			}
		}

		internal static bool EmitSymbols
		{
			get
			{
				if (emitSymbols == 0)
				{
					int state;
					string debug = System.Configuration.ConfigurationManager.AppSettings["ikvm-emit-symbols"];
					if (debug == null)
					{
						state = Debugger.IsAttached ? 1 : 2;
					}
					else
					{
						state = debug.Equals("True", StringComparison.OrdinalIgnoreCase) ? 1 : 2;
					}
					// make sure we only set the value once, because it isn't allowed to changed as that could cause
					// the compiler to try emitting symbols into a ModuleBuilder that doesn't accept them (and would
					// throw an InvalidOperationException)
					Interlocked.CompareExchange(ref emitSymbols, state, 0);
				}
				return emitSymbols == 1;
			}
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR

		internal static bool IsUnix
		{
			get
			{
				return Environment.OSVersion.Platform == PlatformID.Unix;
			}
		}
	
		internal static string MangleResourceName(string name)
		{
			// FXBUG there really shouldn't be any need to mangle the resource names,
			// but in order for ILDASM/ILASM round tripping to work reliably, we have
			// to make sure that we don't produce resource names that'll cause ILDASM
			// to generate invalid filenames.
			StringBuilder sb = new StringBuilder("ikvm__", name.Length + 6);
			foreach(char c in name)
			{
				if("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-+.()$#@@~=&{}[]0123456789`".IndexOf(c) != -1)
				{
					sb.Append(c);
				}
				else if(c == '/')
				{
					sb.Append('!');
				}
				else
				{
					sb.Append('%');
					sb.Append(string.Format("{0:X4}", (int)c));
				}
			}
			return sb.ToString();
		}

		// based on Bret Mulvey's C# port of Jenkins32
		// note that this algorithm cannot be changed, because we persist these hashcodes in the metadata of shared class loader assemblies
		internal static int PersistableHash(string str)
		{
			uint key = 1;
			foreach (char c in str)
			{
				key += c;
				key += (key << 12);
				key ^= (key >> 22);
				key += (key << 4);
				key ^= (key >> 9);
				key += (key << 10);
				key ^= (key >> 2);
				key += (key << 7);
				key ^= (key >> 12);
			}
			return (int)key;
		}

#if !STATIC_COMPILER
		internal static void CriticalFailure(string message, Exception x)
		{
			try
			{
				Tracer.Error(Tracer.Runtime, "CRITICAL FAILURE: {0}", message);
				System.Type messageBox = null;
#if !STUB_GENERATOR
				// NOTE we use reflection to invoke MessageBox.Show, to make sure we run in environments where WinForms isn't available
				Assembly winForms = IsUnix ? null : Assembly.Load("System.Windows.Forms, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
				if(winForms != null)
				{
					messageBox = winForms.GetType("System.Windows.Forms.MessageBox");
				}
#endif
				message = String.Format("****** Critical Failure: {1} ******{0}{0}" +
					"PLEASE FILE A BUG REPORT FOR IKVM.NET WHEN YOU SEE THIS MESSAGE{0}{0}" +
					(messageBox != null ? "(on Windows you can use Ctrl+C to copy the contents of this message to the clipboard){0}{0}" : "") +
					"{2}{0}" +
					"{3}{0}" +
					"{4} {5}-bit{0}{0}" +
					"{6}{0}" + 
					"{7}{0}" +
					"{8}",
					Environment.NewLine,
					message,
					System.Reflection.Assembly.GetExecutingAssembly().FullName,
					System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory(),
					Environment.Version,
					IntPtr.Size * 8,
					x,
					x != null ? new StackTrace(x, true).ToString() : "",
					new StackTrace(true));
				if(messageBox != null)
				{
					try
					{
						Version ver = SafeGetAssemblyVersion(typeof(JVM).Assembly);
						messageBox.InvokeMember("Show", System.Reflection.BindingFlags.InvokeMethod | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public, null, null, new object[] { message, "IKVM.NET " + ver + " Critical Failure" });
					}
					catch
					{
						Console.Error.WriteLine(message);
					}
				}
				else
				{
					Console.Error.WriteLine(message);
				}
			}
			catch(Exception ex)
			{
				Console.Error.WriteLine(ex);
			}
			finally
			{
				Environment.Exit(666);
			}
		}
#endif // !STATIC_COMPILER

#if STATIC_COMPILER || STUB_GENERATOR
		internal static Type LoadType(System.Type type)
		{
			return StaticCompiler.GetRuntimeType(type.FullName);
		}
#endif

		// this method resolves types in IKVM.Runtime.dll
		// (the version of IKVM.Runtime.dll that we're running
		// with can be different from the one we're compiling against.)
		internal static Type LoadType(Type type)
		{
#if STATIC_COMPILER || STUB_GENERATOR
			return StaticCompiler.GetRuntimeType(type.FullName);
#else
			return type;
#endif
		}

		internal static object Box(object val)
		{
#if STATIC_COMPILER || FIRST_PASS || STUB_GENERATOR
			return null;
#else
			if(val is byte)
			{
				return java.lang.Byte.valueOf((byte)val);
			}
			else if(val is bool)
			{
				return java.lang.Boolean.valueOf((bool)val);
			}
			else if(val is short)
			{
				return java.lang.Short.valueOf((short)val);
			}
			else if(val is char)
			{
				return java.lang.Character.valueOf((char)val);
			}
			else if(val is int)
			{
				return java.lang.Integer.valueOf((int)val);
			}
			else if(val is float)
			{
				return java.lang.Float.valueOf((float)val);
			}
			else if(val is long)
			{
				return java.lang.Long.valueOf((long)val);
			}
			else if(val is double)
			{
				return java.lang.Double.valueOf((double)val);
			}
			else
			{
				throw new java.lang.IllegalArgumentException();
			}
#endif
		}

		internal static object Unbox(object val)
		{
#if STATIC_COMPILER || FIRST_PASS || STUB_GENERATOR
			return null;
#else
			java.lang.Byte b = val as java.lang.Byte;
			if(b != null)
			{
				return b.byteValue();
			}
			java.lang.Boolean b1 = val as java.lang.Boolean;
			if(b1 != null)
			{
				return b1.booleanValue();
			}
			java.lang.Short s = val as java.lang.Short;
			if(s != null)
			{
				return s.shortValue();
			}
			java.lang.Character c = val as java.lang.Character;
			if(c != null)
			{
				return c.charValue();
			}
			java.lang.Integer i = val as java.lang.Integer;
			if(i != null)
			{
				return i.intValue();
			}
			java.lang.Float f = val as java.lang.Float;
			if(f != null)
			{
				return f.floatValue();
			}
			java.lang.Long l = val as java.lang.Long;
			if(l != null)
			{
				return l.longValue();
			}
			java.lang.Double d = val as java.lang.Double;
			if(d != null)
			{
				return d.doubleValue();
			}
			else
			{
				throw new java.lang.IllegalArgumentException();
			}
#endif
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal static object NewAnnotation(java.lang.ClassLoader classLoader, object definition)
		{
#if !FIRST_PASS
			java.lang.annotation.Annotation ann = null;
			try
			{
				ann = (java.lang.annotation.Annotation)ikvm.@@internal.AnnotationAttributeBase.newAnnotation(classLoader, definition);
			}
			catch (java.lang.TypeNotPresentException) { }
			if (ann != null && sun.reflect.annotation.AnnotationType.getInstance(ann.annotationType()).retention() == java.lang.annotation.RetentionPolicy.RUNTIME)
			{
				return ann;
			}
#endif
			return null;
		}
#endif

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal static object NewAnnotationElementValue(java.lang.ClassLoader classLoader, java.lang.Class expectedClass, object definition)
		{
#if FIRST_PASS
			return null;
#else
			try
			{
				return ikvm.@@internal.AnnotationAttributeBase.decodeElementValue(definition, expectedClass, classLoader);
			}
			catch(java.lang.IllegalAccessException)
			{
				// TODO this shouldn't be here
				return null;
			}
#endif
		}
#endif

#if !STATIC_COMPILER && !STUB_GENERATOR
		// helper for JNI (which doesn't have access to core library internals)
		internal static object NewDirectByteBuffer(long address, int capacity)
		{
#if FIRST_PASS
			return null;
#else
			return java.nio.DirectByteBuffer.__new(address, capacity);
#endif
		}
#endif

		internal static Type Import(System.Type type)
		{
#if STATIC_COMPILER || STUB_GENERATOR
			return StaticCompiler.Universe.Import(type);
#else
			return type;
#endif
		}
	}

	static class Experimental
	{
		internal static readonly bool JDK_9 = JVM.SafeGetEnvironmentVariable("IKVM_EXPERIMENTAL_JDK_9") != null;
	}
}
@


1.119
log
@Start of Java 8 support.
@
text
@d100 1
@


1.118
log
@Bug fixes.
- If an annotation's type does not exist, the annotation should be ignored instead of throwing an exception.
- If an annotation is (no longer) RetentionPolicy.RUNTIME it should not be returned.
@
text
@d496 1
a496 1
		internal static readonly bool JDK_8 = JVM.SafeGetEnvironmentVariable("IKVM_EXPERIMENTAL_JDK_8") != null;
@


1.117
log
@Add @@Repeatable annotation to custom attribute annotations that AllowMultiple (when IKVM_EXPERIMENTAL_JDK_8 is defined).
@
text
@d437 12
a448 1
#if FIRST_PASS
a449 3
#else
			return ikvm.@@internal.AnnotationAttributeBase.newAnnotation(classLoader, definition);
#endif
@


1.116
log
@Added version info to runtime critical failure.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d485 5
@


1.115
log
@Project stub classes into the jar the classes originated from.
@
text
@d276 1
a276 1
					"{2}{0}" + 
d278 4
a281 1
					"{4}",
d284 4
@


1.114
log
@Added more Class and ClassLoader types in signatures.
@
text
@d84 1
@


1.113
log
@Stop considering ACC_SUPER when linking invokespecial (unless compatibility switch is set). This change matches the security change in Java 7u13.
@
text
@d427 1
a427 1
		internal static object NewAnnotation(object classLoader, object definition)
d432 1
a432 1
			return ikvm.@@internal.AnnotationAttributeBase.newAnnotation((java.lang.ClassLoader)classLoader, definition);
d438 1
a438 1
		internal static object NewAnnotationElementValue(object classLoader, object expectedClass, object definition)
d445 1
a445 1
				return ikvm.@@internal.AnnotationAttributeBase.decodeElementValue(definition, (java.lang.Class)expectedClass, (java.lang.ClassLoader)classLoader);
@


1.112
log
@Allow dynamic assembly debug dump to be enabled by setting IKVM_SAVE_DYNAMIC_ASSEMBLIES environment variable.
@
text
@d70 6
d96 1
d98 2
@


1.111
log
@Use sun.launcher.LauncherHelper to make the launcher more consistent with Java.
@
text
@d92 11
@


1.110
log
@More ikvmc error handling clean up.
@
text
@a53 16
#if !FIRST_PASS
		public static java.lang.reflect.Method FindMainMethod(java.lang.Class clazz)
		{
			// This method exists because we don't use Class.getDeclaredMethods(),
			// since that could cause us to run into NoClassDefFoundError if any of the
			// method signatures references a missing class.
			TypeWrapper tw = TypeWrapper.FromClass(clazz);
			MethodWrapper mw = tw.GetMethodWrapper("main", "([Ljava.lang.String;)V", true);
			if (mw != null && mw.IsStatic)
			{
				return (java.lang.reflect.Method)mw.ToMethodOrConstructor(true);
			}
			return null;
		}
#endif

@


1.109
log
@Added -Xverify option to ikvm.exe.
@
text
@d253 1
d260 1
a260 1
#if !STATIC_COMPILER && !STUB_GENERATOR
d305 1
@


1.108
log
@Removed JVM.GetType().
@
text
@d80 6
d106 1
@


1.107
log
@Removed unused field.
@
text
@a462 9

		internal static Type GetType(string typeName, bool throwOnError)
		{
#if STATIC_COMPILER || STUB_GENERATOR
			return StaticCompiler.Universe.GetType(typeName, throwOnError);
#else
			return Type.GetType(typeName, throwOnError);
#endif
		}
@


1.106
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@a88 1
		internal const bool IsStaticCompiler = true;
a91 1
		internal const bool IsStaticCompiler = false;
@


1.105
log
@Last set of changes preparing for new stub generator. A massive amount of conditional compilation changes, to skip irrelevant code when building ikvmstub.
@
text
@d26 1
a26 1
#if IKVM_REF_EMIT
d300 1
a300 1
#if IKVM_REF_EMIT
@


1.104
log
@Integrated new IKVM.Reflection implementation.
@
text
@d39 1
a39 1
#if !STATIC_COMPILER
d82 1
a82 1
#endif // !STATIC_COMPILER
d92 1
a92 1
#else
d137 1
a137 1
#if !STATIC_COMPILER
d155 1
a155 1
#if !STATIC_COMPILER
d192 1
a192 1
#endif // !STATIC_COMPILER
d254 1
a254 1
#if !STATIC_COMPILER
d312 1
a312 1
#if STATIC_COMPILER
d321 1
a321 1
#if STATIC_COMPILER || FIRST_PASS
d365 1
a365 1
#if STATIC_COMPILER || FIRST_PASS
d415 1
a415 1
#if !STATIC_COMPILER
d426 1
a426 1
#if !STATIC_COMPILER
d445 1
a445 1
#if !STATIC_COMPILER
d459 1
a459 1
#if STATIC_COMPILER
d468 1
a468 1
#if STATIC_COMPILER
@


1.103
log
@Changed JNI to use standard caller ID mechanism.
@
text
@d26 4
d31 1
d103 1
a103 1
		internal static Version SafeGetAssemblyVersion(Assembly asm)
d253 1
a253 1
				Type messageBox = null;
d278 1
a278 1
						messageBox.InvokeMember("Show", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.Public, null, null, new object[] { message, "IKVM.NET " + ver + " Critical Failure" });
d300 7
d313 1
a313 1
			return StaticCompiler.GetType(type.FullName);
d459 3
d463 1
d468 3
d472 1
@


1.102
log
@Moved FindMainMethod into runtime, to avoid the need for hacks (to avoid NoClassDefFoundErrors).
@
text
@a432 13

#if !STATIC_COMPILER
		// helper for JNI (which doesn't have access to core library internals)
		internal static object CreateCallerID(RuntimeMethodHandle method)
		{
#if FIRST_PASS
			return null;
#else
			return ikvm.@@internal.CallerID.create(MethodBase.GetMethodFromHandle(method));
#endif
		}
#endif

@


1.101
log
@More type funneling.
@
text
@d49 2
a50 1
		public static bool EnableReflectionOnMethodsWithUnloadableTypeParameters
d52 6
a57 1
			get
d59 1
a59 5
				return JVM.EnableReflectionOnMethodsWithUnloadableTypeParameters;
			}
			set
			{
				JVM.EnableReflectionOnMethodsWithUnloadableTypeParameters = value;
d61 1
d63 1
a88 1
		private static bool enableReflectionOnMethodsWithUnloadableTypeParameters;
a150 12
		public static bool EnableReflectionOnMethodsWithUnloadableTypeParameters
		{
			get
			{
				return enableReflectionOnMethodsWithUnloadableTypeParameters;
			}
			set
			{
				enableReflectionOnMethodsWithUnloadableTypeParameters = value;
			}
		}

@


1.100
log
@Replaced most type literals with static field access (in Types class) or warpped JVM.Import() around them.
@
text
@d471 5
@


1.99
log
@Removed vestigial compact framework support.
@
text
@d466 5
@


1.98
log
@Added App.config setting (ikvm-emit-symbols) to force emitting debug symbols on or off.
@
text
@d34 1
a34 1
#if !STATIC_COMPILER && !COMPACT_FRAMEWORK
d73 1
a73 1
#endif // !STATIC_COMPILER && !COMPACT_FRAMEWORK
@


1.97
log
@Implemented class gc (available only when compiling on .NET 4.0).
@
text
@d87 1
d171 25
@


1.96
log
@Changed DynamicClassLoader API to make it easier to move from global AssemblyBuilder to per ClassLoader.
@
text
@d60 11
d88 3
@


1.95
log
@Implemented shared class loader support.
@
text
@d46 1
a46 1
			DynamicClassLoader.Instance.SaveDebugImage();
@


1.94
log
@Changed JNI reflection to be based on Java reflection (where possible).
@
text
@d192 20
@


1.93
log
@Added helper methods to no longer require reflection to instantiate DirectByteBuffer from JNI.
@
text
@d382 13
@


1.92
log
@Generified all collections.
@
text
@d381 12
@


1.91
log
@Removed support for building with GNU Classpath class library.
@
text
@a27 1
using System.Collections;
a352 10
		internal static void SetProperties(Hashtable props)
		{
#if FIRST_PASS
#else
			gnu.classpath.VMSystemProperties.props = props;
#endif
		}
#endif

#if !STATIC_COMPILER
@


1.90
log
@Marked all static classes as static.
@
text
@a76 3
#if !FIRST_PASS && !OPENJDK
		private static ikvm.@@internal.LibraryVMInterface lib;
#endif
a133 18
#if !OPENJDK
		internal static ikvm.@@internal.LibraryVMInterface Library
		{
			get
			{
#if FIRST_PASS
				throw new InvalidOperationException("This version of IKVM.Runtime.dll was compiled with FIRST_PASS defined.");
#else
				if(lib == null)
				{
					lib = ikvm.@@internal.Library.getImpl();
				}
				return lib;
#endif
			}
		}
#endif

d357 1
a357 1
#elif OPENJDK
a358 2
#else
			JVM.Library.setProperties(props);
d368 1
a368 1
#elif OPENJDK
a369 2
#else
			return JVM.Library.newAnnotation(classLoader, definition);
d379 1
a379 1
#elif OPENJDK
a388 2
#else
			return JVM.Library.newAnnotationElementValue(classLoader, expectedClass, definition);
@


1.89
log
@Removed asserts that no longer work since we're now security transparent.
@
text
@d38 1
a38 1
	public sealed class Starter
a39 2
		private Starter() {}

d67 1
a67 1
	class JVM
@


1.88
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@a229 1
				new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
a240 1
				CodeAccessPermission.RevertAssert();
@


1.87
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d79 1
a79 1
#if !FIRST_PASS
d126 1
a126 1
					coreAssembly = typeof(ikvm.@@internal.Library).Assembly;
d139 1
d155 1
d281 142
@


1.86
log
@Made the IsUnix test more efficient.
@
text
@a32 1
using IKVM.Attributes;
a183 1
#if WHIDBEY
a184 4
#else
				PlatformID pid = Environment.OSVersion.Platform;
				return pid != PlatformID.Win32NT && pid != PlatformID.Win32S && pid != PlatformID.Win32Windows && pid != PlatformID.WinCE;
#endif
d228 1
a228 5
				new ReflectionPermission(ReflectionPermissionFlag.MemberAccess
#if !WHIDBEY
					| ReflectionPermissionFlag.TypeInformation
#endif
				).Assert();
d273 1
a273 1
#if WHIDBEY && STATIC_COMPILER
@


1.85
log
@Changed the build process to build IKVM.Runtime in two passes to enable it to reference IKVM.GNU.Classpath (which also references IKVM.Runtime). This removes the need to do reflection to find the loaded IKVM.GNU.Classpath from IKVM.Runtime and completes the ability to run different versions of IKVM side-by-side in the same AppDomain. This should also fix bug 1659196.
@
text
@d185 6
a190 1
				return Environment.OSVersion.ToString().IndexOf("Unix") >= 0;
@


1.84
log
@- Changed JVM.CriticalFailure to write text to console when in static compiler.
- Added text to JVM.CriticalFailure message box to explain about Ctrl+C for copying the text.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d80 1
d82 1
d84 1
a84 1
#endif
a116 44
#if COMPACT_FRAMEWORK
		internal static ikvm.@@internal.LibraryVMInterface Library
		{
			get
			{
				return ikvm.@@internal.Library.getImpl();
			}
		}

		internal static Assembly CoreAssembly
		{
			get
			{
				return Library.GetType().Assembly;
			}
		}
#else

		private static Assembly[] UnsafeGetAssemblies()
		{
			new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
#if WHIDBEY && STATIC_COMPILER
			return AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies();
#else
			return AppDomain.CurrentDomain.GetAssemblies();
#endif
		}

		private static Type UnsafeGetType(Assembly asm, string name)
		{
			new ReflectionPermission(ReflectionPermissionFlag.MemberAccess
#if !WHIDBEY
				| ReflectionPermissionFlag.TypeInformation
#endif
			).Assert();
			return asm.GetType(name);
		}

		private static object UnsafeCreateInstance(Type type)
		{
			new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
			return Activator.CreateInstance(type, true);
		}

d124 5
a128 5
					object lib = Library;
					if(lib != null)
					{
						coreAssembly = lib.GetType().Assembly;
					}
d130 1
a130 1
#endif
d144 3
d149 1
a149 19
					foreach(Assembly asm in UnsafeGetAssemblies())
					{
						Type type = UnsafeGetType(asm, "java.lang.LibraryVMInterfaceImpl");
						if(type != null)
						{
							lib = UnsafeCreateInstance(type) as ikvm.@@internal.LibraryVMInterface;
							if(lib == null)
							{
								// If the "as" fails, this is most likely due to an IKVM.GNU.Classpath.dll version
								// that was linked against an incompatible version of IKVM.Runtime.dll.
								JVM.CriticalFailure("Incompatible core library version", null);
							}
							break;
						}
					}
					if(lib == null)
					{
						JVM.CriticalFailure("Unable to find java.lang.LibraryVMInterfaceImpl", null);
					}
d152 1
a154 2
#endif // STATIC_COMPILER
#endif // COMPACT_FRAMEWORK
a155 1
#if !STATIC_COMPILER
d280 2
a282 1
			return type;
@


1.83
log
@*** empty log message ***
@
text
@d279 2
a282 1
				Type messageBox = null;
d287 1
d295 1
@


1.82
log
@*** empty log message ***
@
text
@d48 1
a48 1
		public static void SaveDebugImage(object mainClass)
d50 1
a50 1
			DynamicClassLoader.Instance.SaveDebugImage(mainClass);
@


1.81
log
@*** empty log message ***
@
text
@d45 1
a45 1
			DynamicClassLoader.PrepareForSaveDebugImage();
d50 1
a50 1
			DynamicClassLoader.SaveDebugImage(mainClass);
d75 1
d81 1
@


1.80
log
@*** empty log message ***
@
text
@d74 1
a76 6
#endif

		private static bool debug = System.Diagnostics.Debugger.IsAttached;
		private static bool noJniStubs;
		private static bool noStackTraceInfo;
		private static string sourcePath;
d78 1
a78 1
#if !STATIC_COMPILER
a80 2
		private static bool strictFinalFieldSemantics;
		private static bool finishingForDebugSave;
d134 4
a137 5
#if WHIDBEY
			if(JVM.IsStaticCompiler)
			{
				return AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies();
			}
a138 1
			return AppDomain.CurrentDomain.GetAssemblies();
d212 1
a212 60
		internal static bool StrictFinalFieldSemantics
		{
			get
			{
				return strictFinalFieldSemantics;
			}
			set
			{
				strictFinalFieldSemantics = value;
			}
		}

		public static bool Debug
		{
			get
			{
				return debug;
			}
			set
			{
				debug = value;
			}
		}

		public static string SourcePath
		{
			get
			{
				return sourcePath;
			}
			set
			{
				sourcePath = value;
			}
		}

		internal static bool NoJniStubs
		{
			get
			{
				return noJniStubs;
			}
			set
			{
				noJniStubs = value;
			}
		}

		internal static bool NoStackTraceInfo
		{
			get
			{
				return noStackTraceInfo;
			}
			set
			{
				noStackTraceInfo = value;
			}
		}

d236 1
@


1.79
log
@*** empty log message ***
@
text
@a80 1
		private static bool compilationPhase1;
a292 12
		internal static bool IsStaticCompilerPhase1
		{
			get
			{
				return compilationPhase1;
			}
			set
			{
				compilationPhase1 = value;
			}
		}

d356 2
a357 1
				message = String.Format("****** Critical Failure: {1} ******{0}" +
@


1.78
log
@*** empty log message ***
@
text
@a67 240
namespace IKVM.Runtime
{
#if !STATIC_COMPILER
	public sealed class Startup
	{
		private Startup()
		{
		}

		private static string[] Glob(string arg)
		{
			try
			{
				string dir = Path.GetDirectoryName(arg);
				if(dir == "")
				{
					dir = null;
				}
				ArrayList list = new ArrayList();
				foreach(FileSystemInfo fsi in new DirectoryInfo(dir == null ? Environment.CurrentDirectory : dir).GetFileSystemInfos(Path.GetFileName(arg)))
				{
					list.Add(dir != null ? Path.Combine(dir, fsi.Name) : fsi.Name);
				}
				if(list.Count == 0)
				{
					return new string[] { arg };
				}
				return (string[])list.ToArray(typeof(string));
			}
			catch
			{
				return new string[] { arg };
			}
		}

		public static string[] Glob()
		{
			return Glob(1);
		}

		public static string[] Glob(int skip)
		{
			if(IKVM.Internal.JVM.IsUnix)
			{
				string[] args = Environment.GetCommandLineArgs();
				string[] vmargs = new string[args.Length - skip];
				Array.Copy(args, skip, vmargs, 0, args.Length - skip);
				return vmargs;
			}
			else
			{
				ArrayList list = new ArrayList();
				string cmdline = Environment.CommandLine;
				StringBuilder sb = new StringBuilder();
				for(int i = 0; i < cmdline.Length;)
				{
					bool quoted = cmdline[i] == '"';
				cont_arg:
					while(i < cmdline.Length && cmdline[i] != ' ' && cmdline[i] != '"')
					{
						sb.Append(cmdline[i++]);
					}
					if(i < cmdline.Length && cmdline[i] == '"')
					{
						if(quoted && i > 1 && cmdline[i - 1] == '"')
						{
							sb.Append('"');
						}
						i++;
						while(i < cmdline.Length && cmdline[i] != '"')
						{
							sb.Append(cmdline[i++]);
						}
						if(i < cmdline.Length && cmdline[i] == '"')
						{
							i++;
						}
						if(i < cmdline.Length && cmdline[i] != ' ')
						{
							goto cont_arg;
						}
					}
					while(i < cmdline.Length && cmdline[i] == ' ')
					{
						i++;
					}
					if(skip > 0)
					{
						skip--;
					}
					else
					{
						if(quoted)
						{
							list.Add(sb.ToString());
						}
						else
						{
							list.AddRange(Glob(sb.ToString()));
						}
					}
					sb.Length = 0;
				}
				return (string[])list.ToArray(typeof(string));
			}
		}

		public static void SetProperties(System.Collections.Hashtable props)
		{
			IKVM.Internal.JVM.Library.setProperties(props);
		}

		public static void EnterMainThread()
		{
			if(Thread.CurrentThread.Name == null)
			{
				try
				{
					Thread.CurrentThread.Name = "main";
				}
				catch(InvalidOperationException)
				{
				}
			}
		}

		public static void ExitMainThread()
		{
			// FXBUG when the main thread ends, it doesn't actually die, it stays around to manage the lifetime
			// of the CLR, but in doing so it also keeps alive the thread local storage for this thread and we
			// use the TLS as a hack to track when the thread dies (if the object stored in the TLS is finalized,
			// we know the thread is dead). So to make that work for the main thread, we use jniDetach which
			// explicitly cleans up our thread.
			IKVM.Internal.JVM.Library.jniDetach();
		}

		public static string GetVersionAndCopyrightInfo()
		{
			Assembly asm = Assembly.GetEntryAssembly();
			object[] desc = asm.GetCustomAttributes(typeof(AssemblyTitleAttribute), false);
			if (desc.Length == 1)
			{
				object[] copyright = asm.GetCustomAttributes(typeof(AssemblyCopyrightAttribute), false);
				if (copyright.Length == 1)
				{
					return string.Format("{0} version {1}{2}{3}{2}http://www.ikvm.net/",
						((AssemblyTitleAttribute)desc[0]).Title,
						asm.GetName().Version,
						Environment.NewLine,
						((AssemblyCopyrightAttribute)copyright[0]).Copyright);
				}
			}
			return "";
		}
	}

	public sealed class Util
	{
		private Util()
		{
		}

		public static object GetClassFromObject(object o)
		{
			return GetTypeWrapperFromObject(o).ClassObject;
		}

		internal static TypeWrapper GetTypeWrapperFromObject(object o)
		{
			Type t = o.GetType();
			if(t.IsPrimitive || (ClassLoaderWrapper.IsRemappedType(t) && !t.IsSealed))
			{
				return DotNetTypeWrapper.GetWrapperFromDotNetType(t);
			}
			return ClassLoaderWrapper.GetWrapperFromType(t);
		}

		public static object GetClassFromTypeHandle(RuntimeTypeHandle handle)
		{
			Type t = Type.GetTypeFromHandle(handle);
			if(t.IsPrimitive || ClassLoaderWrapper.IsRemappedType(t) || t == typeof(void))
			{
				return DotNetTypeWrapper.GetWrapperFromDotNetType(t).ClassObject;
			}
			if(Whidbey.ContainsGenericParameters(t))
			{
				return null;
			}
			TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(t);
			if(tw != null)
			{
				return tw.ClassObject;
			}
			return null;
		}

		public static object GetFriendlyClassFromType(Type type)
		{
			if(Whidbey.ContainsGenericParameters(type))
			{
				return null;
			}
			int rank = 0;
			while(type.IsArray)
			{
				type = type.GetElementType();
				rank++;
			}
			if(type.DeclaringType != null
				&& type.DeclaringType.IsDefined(typeof(GhostInterfaceAttribute), false))
			{
				type = type.DeclaringType;
			}
			TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromType(type);
			if(rank > 0)
			{
				wrapper = wrapper.MakeArrayType(rank);
			}
			return wrapper.ClassObject;
		}

		public static Type GetInstanceTypeFromClass(object classObject)
		{
			TypeWrapper wrapper = (TypeWrapper)JVM.Library.getWrapperFromClass(classObject);
			if(wrapper.IsRemapped && wrapper.IsFinal)
			{
				return wrapper.TypeAsTBD;
			}
			return wrapper.TypeAsBaseType;
		}

		[HideFromJava]
		public static Exception MapException(Exception x)
		{
			return IKVM.Internal.JVM.Library.mapException(x);
		}
	}
#endif
}

@


1.77
log
@*** empty log message ***
@
text
@a298 70
		private static FieldWrapper GetFieldWrapperFromField(object field)
		{
			if(field == null)
			{
				throw new ArgumentNullException("field");
			}
			if(field.GetType().FullName != "java.lang.reflect.Field")
			{
				throw new ArgumentException("field");
			}
			return (FieldWrapper)IKVM.Internal.JVM.Library.getWrapperFromField(field);
		}

		public static object GetFieldConstantValue(object field)
		{
			return GetFieldWrapperFromField(field).GetConstant();
		}

		public static bool IsFieldDeprecated(object field)
		{
			FieldInfo fi = GetFieldWrapperFromField(field).GetField();
			return fi != null && AttributeHelper.IsDefined(fi, typeof(ObsoleteAttribute));
		}

		public static bool IsMethodDeprecated(object method)
		{
			if(method == null)
			{
				throw new ArgumentNullException("method");
			}
			if(method.GetType().FullName != "java.lang.reflect.Method")
			{
				throw new ArgumentException("method");
			}
			MethodWrapper mw = (MethodWrapper)IKVM.Internal.JVM.Library.getWrapperFromMethodOrConstructor(method);
			MethodBase mb = mw.GetMethod();
			return mb != null && AttributeHelper.IsDefined(mb, typeof(ObsoleteAttribute));
		}

		public static bool IsConstructorDeprecated(object constructor)
		{
			if(constructor == null)
			{
				throw new ArgumentNullException("constructor");
			}
			if(constructor.GetType().FullName != "java.lang.reflect.Constructor")
			{
				throw new ArgumentException("constructor");
			}
			MethodWrapper mw = (MethodWrapper)IKVM.Internal.JVM.Library.getWrapperFromMethodOrConstructor(constructor);
			MethodBase mb = mw.GetMethod();
			return mb != null && AttributeHelper.IsDefined(mb, typeof(ObsoleteAttribute));
		}

		public static bool IsClassDeprecated(object clazz)
		{
			if(clazz == null)
			{
				throw new ArgumentNullException("clazz");
			}
			if(clazz.GetType().FullName != "java.lang.Class")
			{
				throw new ArgumentException("clazz");
			}
			TypeWrapper wrapper = TypeWrapper.FromClass(clazz);
			// HACK we need to check TypeAsTBD for null, because ReflectionOnly
			// generated delegate inner interfaces don't really exist
			return wrapper.TypeAsTBD != null && AttributeHelper.IsDefined(wrapper.TypeAsTBD, typeof(ObsoleteAttribute));
		}

@


1.76
log
@*** empty log message ***
@
text
@a389 1
		private static bool isIkvmStub;
a531 6
		public static void SetIkvmStubMode()
		{
			// HACK
			isIkvmStub = true;
		}

a603 8
		internal static bool IsIkvmStub
		{
			get
			{
				return isIkvmStub;
			}
		}

@


1.75
log
@*** empty log message ***
@
text
@d36 1
a36 1
#if !STATIC_COMPILER
d66 1
a66 1
#endif // !STATIC_COMPILER
@


1.74
log
@*** empty log message ***
@
text
@d248 1
a248 1
			if(t.IsPrimitive || ClassLoaderWrapper.IsRemappedType(t))
@


1.73
log
@*** empty log message ***
@
text
@a52 5
		public static void SetBootstrapClassLoader(object classLoader)
		{
			ClassLoaderWrapper.GetBootstrapClassLoader().SetJavaClassLoader(classLoader);
		}

@


1.72
log
@*** empty log message ***
@
text
@d261 6
a266 1
			return ClassLoaderWrapper.GetWrapperFromType(t).ClassObject;
d369 3
a371 1
			return AttributeHelper.IsDefined(wrapper.TypeAsTBD, typeof(ObsoleteAttribute));
a647 12
		internal static bool CompileInnerClassesAsNestedTypes
		{
			get
			{
				// NOTE at the moment, we always do this when compiling statically
				// note that it makes no sense to turn this on when we're dynamically
				// running Java code, it only makes sense to turn it off when statically
				// compiling code that is never used as a library.
				return IsStaticCompiler;
			}
		}

d736 3
d741 2
a742 5
#if WHIDBEY && !COMPACT_FRAMEWORK
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
			{
				return StaticCompiler.GetType(type.FullName);
			}
@


1.71
log
@*** empty log message ***
@
text
@d36 37
d75 1
d373 1
d378 1
a378 1
	public class JVM
d380 6
a387 1
		private static bool isStaticCompiler;
d393 1
d395 1
d480 1
d489 1
d498 1
a502 6
#if WHIDBEY
				if(JVM.IsStaticCompiler)
				{
					return null;
				}
#endif
d520 1
a520 1
					if(lib == null && !IsStaticCompiler)
d528 2
a529 1
#endif
a608 8
		internal static bool DisableDynamicBinding
		{
			get
			{
				return isStaticCompiler;
			}
		}

a616 12
		internal static bool IsStaticCompiler
		{
			get
			{
				return isStaticCompiler;
			}
			set
			{
				isStaticCompiler = value;
			}
		}

a686 17
#if !COMPACT_FRAMEWORK
		public static void PrepareForSaveDebugImage()
		{
			DynamicClassLoader.PrepareForSaveDebugImage();
		}
	
		public static void SaveDebugImage(object mainClass)
		{
			DynamicClassLoader.SaveDebugImage(mainClass);
		}
#endif

		public static void SetBootstrapClassLoader(object classLoader)
		{
			ClassLoaderWrapper.GetBootstrapClassLoader().SetJavaClassLoader(classLoader);
		}

@


1.70
log
@*** empty log message ***
@
text
@d199 5
d207 1
a207 1
				return DotNetTypeWrapper.GetWrapperFromDotNetType(t).ClassObject;
d209 1
a209 1
			return ClassLoaderWrapper.GetWrapperFromType(t).ClassObject;
@


1.69
log
@*** empty log message ***
@
text
@d320 1
a320 1
			TypeWrapper wrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(clazz);
@


1.68
log
@*** empty log message ***
@
text
@a25 6
using System.Resources;
#if !COMPACT_FRAMEWORK
using System.Reflection.Emit;
using ILGenerator = IKVM.Internal.CountingILGenerator;
using Label = IKVM.Internal.CountingLabel;
#endif
a28 1
using System.Xml;
a29 1
using System.Text.RegularExpressions;
a33 1
using IKVM.Runtime;
d439 4
d482 7
a488 1
		public static bool StrictFinalFieldSemantics
d494 4
d530 4
d542 4
d582 4
d594 4
d657 8
a664 2
#if !NO_STATIC_COMPILER && !COMPACT_FRAMEWORK
		private class CompilerClassLoader : DynamicClassLoader
d666 2
a667 54
			private Hashtable classes;
			private Hashtable remapped = new Hashtable();
			private string assemblyName;
			private string assemblyFile;
			private string assemblyDir;
			private string keyfilename;
			private string keycontainer;
			private string version;
			private bool targetIsModule;
			private AssemblyBuilder assemblyBuilder;
			private IKVM.Internal.MapXml.Attribute[] assemblyAttributes;
			private CompilerOptions options;

			internal CompilerClassLoader(CompilerOptions options, string path, string keyfilename, string keycontainer, string version, bool targetIsModule, string assemblyName, Hashtable classes)
				: base(null)
			{
				this.options = options;
				this.classes = classes;
				this.assemblyName = assemblyName;
				FileInfo assemblyPath = new FileInfo(path);
				this.assemblyFile = assemblyPath.Name;
				this.assemblyDir = assemblyPath.DirectoryName;
				this.targetIsModule = targetIsModule;
				this.version = version;
				this.keyfilename = keyfilename;
				this.keycontainer = keycontainer;
				Tracer.Info(Tracer.Compiler, "Instantiate CompilerClassLoader for {0}", assemblyName);
			}

			protected override TypeWrapper CreateDynamicTypeWrapper(ClassFile f, ClassLoaderWrapper loader, object protectionDomain)
			{
				return new AotTypeWrapper(f, loader);
			}

			protected override ModuleBuilder CreateModuleBuilder()
			{
				AssemblyName name = new AssemblyName();
				name.Name = assemblyName;
				if(keyfilename != null) 
				{
					using(FileStream stream = File.Open(keyfilename, FileMode.Open))
					{
						name.KeyPair = new StrongNameKeyPair(stream);
					}
				}
				if(keycontainer != null)
				{
					name.KeyPair = new StrongNameKeyPair(keycontainer);
				}
				name.Version = new Version(version);
#if WHIDBEY
				assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.ReflectionOnly, assemblyDir);
#else
				assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Save, assemblyDir);
a668 14
				ModuleBuilder moduleBuilder;
				moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName, assemblyFile, JVM.Debug);
				if(!JVM.NoStackTraceInfo)
				{
					AttributeHelper.SetSourceFile(moduleBuilder, null);
				}
				AttributeHelper.SetJavaModule(moduleBuilder);
				if(JVM.Debug || !JVM.NoStackTraceInfo)
				{
					CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, JVM.Debug });
					assemblyBuilder.SetCustomAttribute(debugAttr);
				}
				return moduleBuilder;
			}
d670 4
a673 58
			internal override TypeWrapper GetTypeWrapperCompilerHook(string name)
			{
				TypeWrapper type = base.GetTypeWrapperCompilerHook(name);
				if(type == null)
				{
					type = (TypeWrapper)remapped[name];
					if(type != null)
					{
						return type;
					}
					byte[] classdef = (byte[])classes[name];
					if(classdef != null)
					{
						classes.Remove(name);
						ClassFile f;
						try
						{
							f = new ClassFile(classdef, 0, classdef.Length, name);
						}
						catch(ClassFormatError x)
						{
							Console.Error.WriteLine("Warning: class format error: {0}", x.Message);
							return null;
						}
						// to enhance error reporting we special case loading of netexp
						// classes, to handle the case where the ikvmstub type doesn't exist
						// (this happens when the .NET mscorlib.jar is used on Mono, for example)
						string netexp = f.IKVMAssemblyAttribute;
						if(netexp != null)
						{
							try
							{
#if WHIDBEY
								Assembly.ReflectionOnlyLoad(netexp);
#else
								Assembly.Load(netexp);
#endif
							}
							catch(Exception)
							{
								Console.Error.WriteLine("ikvmstub assembly not found: {0}", netexp);
							}
							// HACK create a new wrapper to see if the type is visible now
							if(DotNetTypeWrapper.CreateDotNetTypeWrapper(name) == null)
							{
								Console.Error.WriteLine("Warning: ikvmstub class \"{0}\" refers to non-existing type", name);
								return null;
							}
						}
						if(options.removeUnusedFields)
						{
							f.RemoveUnusedFields();
						}
						type = DefineClass(f, null);
					}
				}
				return type;
			}
d675 3
a677 1
			internal void SetMain(MethodInfo m, PEFileKinds target, Hashtable props, bool noglobbing, Type apartmentAttributeType)
d679 5
a683 2
				Type[] args = Type.EmptyTypes;
				if(noglobbing)
d685 1
a685 1
					args = new Type[] { typeof(string[]) };
d687 16
a702 2
				MethodBuilder mainStub = this.ModuleBuilder.DefineGlobalMethod("main", MethodAttributes.Public | MethodAttributes.Static, typeof(int), args);
				if(apartmentAttributeType != null)
d704 6
a709 9
					mainStub.SetCustomAttribute(new CustomAttributeBuilder(apartmentAttributeType.GetConstructor(Type.EmptyTypes), new object[0]));
				}
				ILGenerator ilgen = mainStub.GetILGenerator();
				LocalBuilder rc = ilgen.DeclareLocal(typeof(int));
				Type startupType = StaticCompiler.GetType("IKVM.Runtime.Startup");
				if(props.Count > 0)
				{
					ilgen.Emit(OpCodes.Newobj, typeof(Hashtable).GetConstructor(Type.EmptyTypes));
					foreach(DictionaryEntry de in props)
d711 1
a711 4
						ilgen.Emit(OpCodes.Dup);
						ilgen.Emit(OpCodes.Ldstr, (string)de.Key);
						ilgen.Emit(OpCodes.Ldstr, (string)de.Value);
						ilgen.Emit(OpCodes.Callvirt, typeof(Hashtable).GetMethod("Add"));
a712 7
					ilgen.Emit(OpCodes.Call, startupType.GetMethod("SetProperties"));
				}
				ilgen.BeginExceptionBlock();
				ilgen.Emit(OpCodes.Call, startupType.GetMethod("EnterMainThread"));
				if(noglobbing)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
d716 1
a716 1
					ilgen.Emit(OpCodes.Call, startupType.GetMethod("Glob", Type.EmptyTypes));
a717 22
				ilgen.Emit(OpCodes.Call, m);
				ilgen.BeginCatchBlock(typeof(Exception));
				ilgen.Emit(OpCodes.Call, StaticCompiler.GetType("IKVM.Runtime.Util").GetMethod("MapException", new Type[] { typeof(Exception) }));
				LocalBuilder exceptionLocal = ilgen.DeclareLocal(typeof(Exception));
				ilgen.Emit(OpCodes.Stloc, exceptionLocal);
				TypeWrapper threadTypeWrapper = ClassLoaderWrapper.LoadClassCritical("java.lang.Thread");
				LocalBuilder threadLocal = ilgen.DeclareLocal(threadTypeWrapper.TypeAsLocalOrStackType);
				threadTypeWrapper.GetMethodWrapper("currentThread", "()Ljava.lang.Thread;", false).EmitCall(ilgen);
				ilgen.Emit(OpCodes.Stloc, threadLocal);
				ilgen.Emit(OpCodes.Ldloc, threadLocal);
				threadTypeWrapper.GetMethodWrapper("getThreadGroup", "()Ljava.lang.ThreadGroup;", false).EmitCallvirt(ilgen);
				ilgen.Emit(OpCodes.Ldloc, threadLocal);
				ilgen.Emit(OpCodes.Ldloc, exceptionLocal);
				ClassLoaderWrapper.LoadClassCritical("java.lang.ThreadGroup").GetMethodWrapper("uncaughtException", "(Ljava.lang.Thread;Ljava.lang.Throwable;)V", false).EmitCallvirt(ilgen);
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Stloc, rc);
				ilgen.BeginFinallyBlock();
				ilgen.Emit(OpCodes.Call, startupType.GetMethod("ExitMainThread", Type.EmptyTypes));
				ilgen.EndExceptionBlock();
				ilgen.Emit(OpCodes.Ldloc, rc);
				ilgen.Emit(OpCodes.Ret);
				assemblyBuilder.SetEntryPoint(mainStub, target);
d719 1
a719 2

			internal void Save()
d721 1
a721 17
				Tracer.Info(Tracer.Compiler, "CompilerClassLoader.Save...");
				FinishAll();

				ModuleBuilder.CreateGlobalFunctions();

				if(targetIsModule)
				{
					Tracer.Info(Tracer.Compiler, "CompilerClassLoader saving temp.$$$ in {0}", assemblyDir);
					string manifestAssembly = "temp.$$$";
					assemblyBuilder.Save(manifestAssembly);
					File.Delete(assemblyDir + manifestAssembly);
				}
				else
				{
					Tracer.Info(Tracer.Compiler, "CompilerClassLoader saving {0} in {1}", assemblyFile, assemblyDir);
					assemblyBuilder.Save(assemblyFile);
				}
d723 1
a723 2

			internal void AddResources(Hashtable resources, bool compressedResources)
d725 1
a725 62
				Tracer.Info(Tracer.Compiler, "CompilerClassLoader adding resources...");
				ModuleBuilder moduleBuilder = this.ModuleBuilder;
				foreach(DictionaryEntry d in resources)
				{
					byte[] buf = (byte[])d.Value;
					if(buf.Length > 0)
					{
						string name = JVM.MangleResourceName((string)d.Key);
#if WHIDBEY
						MemoryStream mem = new MemoryStream();
						if(compressedResources)
						{
							mem.WriteByte(1);
							System.IO.Compression.DeflateStream def = new System.IO.Compression.DeflateStream(mem, System.IO.Compression.CompressionMode.Compress, true);
							def.Write(buf, 0, buf.Length);
							def.Close();
						}
						else
						{
							mem.WriteByte(0);
							mem.Write(buf, 0, buf.Length);
						}
						mem.Position = 0;
						moduleBuilder.DefineManifestResource(name, mem, ResourceAttributes.Public);
#else
						IResourceWriter writer = moduleBuilder.DefineResource(name, "");
						writer.AddResource(compressedResources ? "lz" : "ikvm", buf);
#endif
					}
				}
			}

			private static MethodAttributes MapMethodAccessModifiers(IKVM.Internal.MapXml.MapModifiers mod)
			{
				const IKVM.Internal.MapXml.MapModifiers access = IKVM.Internal.MapXml.MapModifiers.Public | IKVM.Internal.MapXml.MapModifiers.Protected | IKVM.Internal.MapXml.MapModifiers.Private;
				switch(mod & access)
				{
					case IKVM.Internal.MapXml.MapModifiers.Public:
						return MethodAttributes.Public;
					case IKVM.Internal.MapXml.MapModifiers.Protected:
						return MethodAttributes.FamORAssem;
					case IKVM.Internal.MapXml.MapModifiers.Private:
						return MethodAttributes.Private;
					default:
						return MethodAttributes.Assembly;
				}
			}

			private static FieldAttributes MapFieldAccessModifiers(IKVM.Internal.MapXml.MapModifiers mod)
			{
				const IKVM.Internal.MapXml.MapModifiers access = IKVM.Internal.MapXml.MapModifiers.Public | IKVM.Internal.MapXml.MapModifiers.Protected | IKVM.Internal.MapXml.MapModifiers.Private;
				switch(mod & access)
				{
					case IKVM.Internal.MapXml.MapModifiers.Public:
						return FieldAttributes.Public;
					case IKVM.Internal.MapXml.MapModifiers.Protected:
						return FieldAttributes.FamORAssem;
					case IKVM.Internal.MapXml.MapModifiers.Private:
						return FieldAttributes.Private;
					default:
						return FieldAttributes.Assembly;
				}
a726 1895

			private class RemapperTypeWrapper : TypeWrapper
			{
				private TypeBuilder typeBuilder;
				private TypeBuilder helperTypeBuilder;
				private Type shadowType;
				private IKVM.Internal.MapXml.Class classDef;
				private TypeWrapper[] interfaceWrappers;

				internal override Assembly Assembly
				{
					get
					{
						return typeBuilder.Assembly;
					}
				}

				internal override bool IsRemapped
				{
					get
					{
						return true;
					}
				}

				private static TypeWrapper GetBaseWrapper(IKVM.Internal.MapXml.Class c)
				{
					if((c.Modifiers & IKVM.Internal.MapXml.MapModifiers.Interface) != 0)
					{
						return null;
					}
					if(c.Name == "java.lang.Object")
					{
						return null;
					}
					return CoreClasses.java.lang.Object.Wrapper;
				}

				internal RemapperTypeWrapper(CompilerClassLoader classLoader, IKVM.Internal.MapXml.Class c, IKVM.Internal.MapXml.Root map)
					: base((Modifiers)c.Modifiers, c.Name, GetBaseWrapper(c), classLoader, null)
				{
					classDef = c;
					bool baseIsSealed = false;
					shadowType = Type.GetType(c.Shadows, true);
					classLoader.SetRemappedType(shadowType, this);
					Type baseType = shadowType;
					Type baseInterface = null;
					if(baseType.IsInterface)
					{
						baseInterface = baseType;
					}
					TypeAttributes attrs = TypeAttributes.Public;
					if((c.Modifiers & IKVM.Internal.MapXml.MapModifiers.Interface) == 0)
					{
						attrs |= TypeAttributes.Class;
						if(baseType.IsSealed)
						{
							baseIsSealed = true;
							// FXBUG .NET framework bug
							// ideally we would make the type sealed and abstract,
							// but Reflection.Emit incorrectly prohibits that
							// (the ECMA spec explicitly mentions this is valid)
							// attrs |= TypeAttributes.Abstract | TypeAttributes.Sealed;
							attrs |= TypeAttributes.Abstract;
						}
					}
					else
					{
						attrs |= TypeAttributes.Interface | TypeAttributes.Abstract;
						baseType = null;
					}
					if((c.Modifiers & IKVM.Internal.MapXml.MapModifiers.Abstract) != 0)
					{
						attrs |= TypeAttributes.Abstract;
					}
					string name = c.Name.Replace('/', '.');
					typeBuilder = classLoader.ModuleBuilder.DefineType(name, attrs, baseIsSealed ? typeof(object) : baseType);
					if(c.Attributes != null)
					{
						foreach(IKVM.Internal.MapXml.Attribute custattr in c.Attributes)
						{
							AttributeHelper.SetCustomAttribute(typeBuilder, custattr);
						}
					}
					if(baseInterface != null)
					{
						typeBuilder.AddInterfaceImplementation(baseInterface);
					}
					if(!JVM.NoStackTraceInfo)
					{
						AttributeHelper.SetSourceFile(typeBuilder, IKVM.Internal.MapXml.Root.filename);
					}

					if(baseIsSealed)
					{
						AttributeHelper.SetModifiers(typeBuilder, (Modifiers)c.Modifiers);
					}

					if(c.scope == IKVM.Internal.MapXml.Scope.Public)
					{
						// FXBUG we would like to emit an attribute with a Type argument here, but that doesn't work because
						// of a bug in SetCustomAttribute that causes type arguments to be serialized incorrectly (if the type
						// is in the same assembly). Normally we use AttributeHelper.FreezeDry to get around this, but that doesn't
						// work in this case (no attribute is emitted at all). So we work around by emitting a string instead
						AttributeHelper.SetRemappedClass(classLoader.assemblyBuilder, name, shadowType);
						
						AttributeHelper.SetRemappedType(typeBuilder, shadowType);
					}

					// HACK because of the above FXBUG that prevents us from making the type both abstract and sealed,
					// we need to emit a private constructor (otherwise reflection will automatically generate a public
					// default constructor, another lame feature)
					if(baseIsSealed)
					{
						ConstructorBuilder cb = typeBuilder.DefineConstructor(MethodAttributes.Private, CallingConventions.Standard, Type.EmptyTypes);
						ILGenerator ilgen = cb.GetILGenerator();
						// lazyman's way to create a type-safe bogus constructor
						ilgen.Emit(OpCodes.Ldnull);
						ilgen.Emit(OpCodes.Throw);
					}

					ArrayList methods = new ArrayList();

					if(c.Constructors != null)
					{
						foreach(IKVM.Internal.MapXml.Constructor m in c.Constructors)
						{
							methods.Add(new RemappedConstructorWrapper(this, m));
						}
					}

					if(c.Methods != null)
					{
						// TODO we should also add methods from our super classes (e.g. Throwable should have Object's methods)
						foreach(IKVM.Internal.MapXml.Method m in c.Methods)
						{
							methods.Add(new RemappedMethodWrapper(this, m, map));
						}
					}

					SetMethods((MethodWrapper[])methods.ToArray(typeof(MethodWrapper)));
				}

				abstract class RemappedMethodBaseWrapper : MethodWrapper
				{
					internal RemappedMethodBaseWrapper(RemapperTypeWrapper typeWrapper, string name, string sig, Modifiers modifiers)
						: base(typeWrapper, name, sig, null, null, null, modifiers, MemberFlags.None)
					{
					}

					internal abstract MethodBase DoLink();

					internal abstract void Finish();

					internal static void AddDeclaredExceptions(MethodBase mb, IKVM.Internal.MapXml.Throws[] throws)
					{
						if(throws != null)
						{
							string[] exceptions = new string[throws.Length];
							for(int i = 0; i < exceptions.Length; i++)
							{
								exceptions[i] = throws[i].Class;
							}
							AttributeHelper.SetThrowsAttribute(mb, exceptions);
						}
					}
				}

				sealed class RemappedConstructorWrapper : RemappedMethodBaseWrapper
				{
					private IKVM.Internal.MapXml.Constructor m;
					private MethodBuilder mbHelper;

					internal RemappedConstructorWrapper(RemapperTypeWrapper typeWrapper, IKVM.Internal.MapXml.Constructor m)
						: base(typeWrapper, "<init>", m.Sig, (Modifiers)m.Modifiers)
					{
						this.m = m;
					}

					internal override void EmitCall(ILGenerator ilgen)
					{
						ilgen.Emit(OpCodes.Call, (ConstructorInfo)GetMethod());
					}

					internal override void EmitNewobj(ILGenerator ilgen)
					{
						if(mbHelper != null)
						{
							ilgen.Emit(OpCodes.Call, mbHelper);
						}
						else
						{
							ilgen.Emit(OpCodes.Newobj, (ConstructorInfo)GetMethod());
						}
					}

					internal override MethodBase DoLink()
					{
						MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers);
						RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)DeclaringType;
						Type[] paramTypes = typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig);

						ConstructorBuilder cbCore = null;

						if(typeWrapper.shadowType.IsSealed)
						{
							mbHelper = typeWrapper.typeBuilder.DefineMethod("newhelper", attr | MethodAttributes.Static, CallingConventions.Standard, typeWrapper.shadowType, paramTypes);
							if(m.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
								{
									AttributeHelper.SetCustomAttribute(mbHelper, custattr);
								}
							}
							SetParameters(mbHelper, m.Params);
							AttributeHelper.SetModifiers(mbHelper, (Modifiers)m.Modifiers);
							AttributeHelper.SetNameSig(mbHelper, "<init>", m.Sig);
							AddDeclaredExceptions(mbHelper, m.throws);
						}
						else
						{
							cbCore = typeWrapper.typeBuilder.DefineConstructor(attr, CallingConventions.Standard, paramTypes);
							if(m.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
								{
									AttributeHelper.SetCustomAttribute(cbCore, custattr);
								}
							}
							SetParameters(cbCore, m.Params);
							AddDeclaredExceptions(cbCore, m.throws);
						}
						return cbCore;
					}
				
					internal override void Finish()
					{
						// TODO we should insert method tracing (if enabled)

						Type[] paramTypes = this.GetParametersForDefineMethod();

						ConstructorBuilder cbCore = GetMethod() as ConstructorBuilder;

						if(cbCore != null)
						{
							ILGenerator ilgen = cbCore.GetILGenerator();
							// TODO we need to support ghost (and other funky?) parameter types
							if(m.body != null)
							{
								// TODO do we need return type conversion here?
								m.body.Emit(ilgen);
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								for(int i = 0; i < paramTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
								}
								if(m.redirect != null)
								{
									throw new NotImplementedException();
								}
								else
								{
									ConstructorInfo baseCon = DeclaringType.TypeAsTBD.GetConstructor(paramTypes);
									if(baseCon == null)
									{
										// TODO better error handling
										throw new InvalidOperationException("base class constructor not found: " + DeclaringType.Name + ".<init>" + m.Sig);
									}
									ilgen.Emit(OpCodes.Call, baseCon);
								}
								ilgen.Emit(OpCodes.Ret);
							}
							ilgen.EmitLineNumberTable(cbCore);
						}

						if(mbHelper != null)
						{
							ILGenerator ilgen = mbHelper.GetILGenerator();
							if(m.redirect != null)
							{
								if(m.redirect.Type != "static" || m.redirect.Class == null || m.redirect.Name == null || m.redirect.Sig == null)
								{
									throw new NotImplementedException();
								}
								Type[] redirParamTypes = ClassLoaderWrapper.GetBootstrapClassLoader().ArgTypeListFromSig(m.redirect.Sig);
								for(int i = 0; i < redirParamTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)i);
								}
								// HACK if the class name contains a comma, we assume it is a .NET type
								if(m.redirect.Class.IndexOf(',') >= 0)
								{
									Type type = Type.GetType(m.redirect.Class, true);
									MethodInfo mi = type.GetMethod(m.redirect.Name, redirParamTypes);
									if(mi == null)
									{
										throw new InvalidOperationException();
									}
									ilgen.Emit(OpCodes.Call, mi);
								}
								else
								{
									TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(m.redirect.Class);
									MethodWrapper mw = tw.GetMethodWrapper(m.redirect.Name, m.redirect.Sig, false);
									if(mw == null)
									{
										throw new InvalidOperationException();
									}
									mw.Link();
									mw.EmitCall(ilgen);
								}
								// TODO we may need a cast here (or a stack to return type conversion)
								ilgen.Emit(OpCodes.Ret);
							}
							else if(m.alternateBody != null)
							{
								m.alternateBody.Emit(ilgen);
							}
							else if(m.body != null)
							{
								// <body> doesn't make sense for helper constructors (which are actually factory methods)
								throw new InvalidOperationException();
							}
							else
							{
								ConstructorInfo baseCon = DeclaringType.TypeAsTBD.GetConstructor(paramTypes);
								if(baseCon == null)
								{
									// TODO better error handling
									throw new InvalidOperationException("constructor not found: " + DeclaringType.Name + ".<init>" + m.Sig);
								}
								for(int i = 0; i < paramTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)i);
								}
								ilgen.Emit(OpCodes.Newobj, baseCon);
								ilgen.Emit(OpCodes.Ret);
							}
							ilgen.EmitLineNumberTable(mbHelper);
						}
					}
				}

				sealed class RemappedMethodWrapper : RemappedMethodBaseWrapper
				{
					private IKVM.Internal.MapXml.Method m;
					private IKVM.Internal.MapXml.Root map;
					private MethodBuilder mbHelper;
					private ArrayList overriders = new ArrayList();

					internal RemappedMethodWrapper(RemapperTypeWrapper typeWrapper, IKVM.Internal.MapXml.Method m, IKVM.Internal.MapXml.Root map)
						: base(typeWrapper, m.Name, m.Sig, (Modifiers)m.Modifiers)
					{
						this.m = m;
						this.map = map;
					}

					internal override void EmitCall(ILGenerator ilgen)
					{
						ilgen.Emit(OpCodes.Call, (MethodInfo)GetMethod());
					}

					internal override void EmitCallvirt(ILGenerator ilgen)
					{
						if(mbHelper != null)
						{
							ilgen.Emit(OpCodes.Call, mbHelper);
						}
						else
						{
							ilgen.Emit(OpCodes.Callvirt, (MethodInfo)GetMethod());
						}
					}

					internal override MethodBase DoLink()
					{
						RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)DeclaringType;

						if(typeWrapper.IsInterface)
						{
							if(m.@@override == null)
							{
								throw new InvalidOperationException(typeWrapper.Name + "." + m.Name + m.Sig);
							}
							MethodInfo interfaceMethod = typeWrapper.shadowType.GetMethod(m.@@override.Name, typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig));
							if(interfaceMethod == null)
							{
								throw new InvalidOperationException(typeWrapper.Name + "." + m.Name + m.Sig);
							}
							if(m.throws != null)
							{
								// TODO we need a place to stick the declared exceptions
								throw new NotImplementedException();
							}
							// if any of the remapped types has a body for this interface method, we need a helper method
							// to special invocation through this interface for that type
							ArrayList specialCases = null;
							foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
							{
								if(c.Methods != null)
								{
									foreach(IKVM.Internal.MapXml.Method mm in c.Methods)
									{
										if(mm.Name == m.Name && mm.Sig == m.Sig && mm.body != null)
										{
											if(specialCases == null)
											{
												specialCases = new ArrayList();
											}
											specialCases.Add(c);
											break;
										}
									}
								}
							}
							AttributeHelper.SetRemappedInterfaceMethod(typeWrapper.typeBuilder, m.Name, m.@@override.Name);
							MethodBuilder helper = null;
							if(specialCases != null)
							{
								Type[] temp = typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig);
								Type[] argTypes = new Type[temp.Length + 1];
								temp.CopyTo(argTypes, 1);
								argTypes[0] = typeWrapper.shadowType;
								if(typeWrapper.helperTypeBuilder == null)
								{
									// FXBUG we use a nested helper class, because Reflection.Emit won't allow us to add a static method to the interface
									typeWrapper.helperTypeBuilder = typeWrapper.typeBuilder.DefineNestedType("__Helper", TypeAttributes.NestedPublic | TypeAttributes.Class);
									AttributeHelper.HideFromJava(typeWrapper.helperTypeBuilder);
								}
								helper = typeWrapper.helperTypeBuilder.DefineMethod(m.Name, MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsSignatureType, argTypes);
								if(m.Attributes != null)
								{
									foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
									{
										AttributeHelper.SetCustomAttribute(helper, custattr);
									}
								}
								SetParameters(helper, m.Params);
								ILGenerator ilgen = helper.GetILGenerator();
								foreach(IKVM.Internal.MapXml.Class c in specialCases)
								{
									TypeWrapper tw = typeWrapper.GetClassLoader().LoadClassByDottedName(c.Name);
									ilgen.Emit(OpCodes.Ldarg_0);
									ilgen.Emit(OpCodes.Isinst, tw.TypeAsTBD);
									ilgen.Emit(OpCodes.Dup);
									Label label = ilgen.DefineLabel();
									ilgen.Emit(OpCodes.Brfalse_S, label);
									for(int i = 1; i < argTypes.Length; i++)
									{
										ilgen.Emit(OpCodes.Ldarg, (short)i);
									}
									MethodWrapper mw = tw.GetMethodWrapper(m.Name, m.Sig, false);
									mw.Link();
									mw.EmitCallvirt(ilgen);
									ilgen.Emit(OpCodes.Ret);
									ilgen.MarkLabel(label);
									ilgen.Emit(OpCodes.Pop);
								}
								for(int i = 0; i < argTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)i);
								}
								ilgen.Emit(OpCodes.Callvirt, interfaceMethod);
								ilgen.Emit(OpCodes.Ret);
							}
							mbHelper = helper;
							return interfaceMethod;
						}
						else
						{
							MethodBuilder mbCore = null;
							Type[] paramTypes = typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig);
							Type retType = typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsSignatureType;

							if(typeWrapper.shadowType.IsSealed && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) == 0)
							{
								// skip instance methods in sealed types, but we do need to add them to the overriders
								if(typeWrapper.BaseTypeWrapper != null && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Private) == 0)
								{
									RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(m.Name, m.Sig, true) as RemappedMethodWrapper;
									if(baseMethod != null &&
										!baseMethod.IsFinal &&
										!baseMethod.IsPrivate &&
										(baseMethod.m.@@override != null ||
										baseMethod.m.redirect != null ||
										baseMethod.m.body != null ||
										baseMethod.m.alternateBody != null))
									{
										baseMethod.overriders.Add(typeWrapper);
									}
								}
							}
							else
							{
								MethodInfo overrideMethod = null;
								MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers) | MethodAttributes.HideBySig;
								if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) != 0)
								{
									attr |= MethodAttributes.Static;
								}
								else if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Private) == 0 && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Final) == 0)
								{
									attr |= MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.CheckAccessOnOverride;
									if(typeWrapper.BaseTypeWrapper != null)
									{
										RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(m.Name, m.Sig, true) as RemappedMethodWrapper;
										if(baseMethod != null)
										{
											baseMethod.overriders.Add(typeWrapper);
											if(baseMethod.m.@@override != null)
											{
												overrideMethod = typeWrapper.BaseTypeWrapper.TypeAsTBD.GetMethod(baseMethod.m.@@override.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, paramTypes, null);
												if(overrideMethod == null)
												{
													throw new InvalidOperationException();
												}
											}
										}
									}
								}
								mbCore = typeWrapper.typeBuilder.DefineMethod(m.Name, attr, CallingConventions.Standard, retType, paramTypes);
								if(m.Attributes != null)
								{
									foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
									{
										AttributeHelper.SetCustomAttribute(mbCore, custattr);
									}
								}
								SetParameters(mbCore, m.Params);
								if(overrideMethod != null)
								{
									typeWrapper.typeBuilder.DefineMethodOverride(mbCore, overrideMethod);
								}
								AddDeclaredExceptions(mbCore, m.throws);
							}

							if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) == 0)
							{
								// instance methods must have an instancehelper method
								MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers) | MethodAttributes.HideBySig | MethodAttributes.Static;
								// NOTE instancehelpers for protected methods are made public,
								// because cli.System.Object derived types can call protected methods
								if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Protected) != 0)
								{
									attr &= ~MethodAttributes.MemberAccessMask;
									attr |= MethodAttributes.Public;
									// mark with specialname, so that tools (hopefully) won't show them
									attr |= MethodAttributes.SpecialName;
								}
								Type[] exParamTypes = new Type[paramTypes.Length + 1];
								Array.Copy(paramTypes, 0, exParamTypes, 1, paramTypes.Length);
								exParamTypes[0] = typeWrapper.shadowType;
								mbHelper = typeWrapper.typeBuilder.DefineMethod("instancehelper_" + m.Name, attr, CallingConventions.Standard, retType, exParamTypes);
								if(m.Attributes != null)
								{
									foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
									{
										AttributeHelper.SetCustomAttribute(mbHelper, custattr);
									}
								}
								IKVM.Internal.MapXml.Param[] parameters;
								if(m.Params == null)
								{
									parameters = new IKVM.Internal.MapXml.Param[1];
								}
								else
								{
									parameters = new IKVM.Internal.MapXml.Param[m.Params.Length + 1];
									m.Params.CopyTo(parameters, 1);
								}
								parameters[0] = new IKVM.Internal.MapXml.Param();
								parameters[0].Name = "this";
								SetParameters(mbHelper, parameters);
								if(!typeWrapper.IsFinal)
								{
									AttributeHelper.SetEditorBrowsableNever(mbHelper);
								}
								AttributeHelper.SetModifiers(mbHelper, (Modifiers)m.Modifiers);
								AttributeHelper.SetNameSig(mbHelper, m.Name, m.Sig);
								AddDeclaredExceptions(mbHelper, m.throws);
							}
							return mbCore;
						}
					}

					internal override void Finish()
					{
						// TODO we should insert method tracing (if enabled)
						Type[] paramTypes = this.GetParametersForDefineMethod();

						MethodBuilder mbCore = GetMethod() as MethodBuilder;

						// NOTE sealed types don't have instance methods (only instancehelpers)
						if(mbCore != null)
						{
							ILGenerator ilgen = mbCore.GetILGenerator();
							MethodInfo baseMethod = null;
							if(m.@@override != null)
							{
								baseMethod = DeclaringType.TypeAsTBD.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, paramTypes, null);
								if(baseMethod == null)
								{
									throw new InvalidOperationException();
								}
								((TypeBuilder)DeclaringType.TypeAsBaseType).DefineMethodOverride(mbCore, baseMethod);
							}
							// TODO we need to support ghost (and other funky?) parameter types
							if(m.body != null)
							{
								// we manually walk the instruction list, because we need to special case the ret instructions
								Hashtable context = new Hashtable();
								foreach(IKVM.Internal.MapXml.Instruction instr in m.body.invoke)
								{
									if(instr is IKVM.Internal.MapXml.Ret)
									{
										this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
									}
									instr.Generate(context, ilgen);
								}
							}
							else
							{
								if(m.redirect != null && m.redirect.LineNumber != -1)
								{
									ilgen.SetLineNumber((ushort)m.redirect.LineNumber);
								}
								int thisOffset = 0;
								if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) == 0)
								{
									thisOffset = 1;
									ilgen.Emit(OpCodes.Ldarg_0);
								}
								for(int i = 0; i < paramTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)(i + thisOffset));
								}
								if(m.redirect != null)
								{
									EmitRedirect(DeclaringType.TypeAsTBD, ilgen);
								}
								else
								{
									if(baseMethod == null)
									{
										throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
									}
									ilgen.Emit(OpCodes.Call, baseMethod);
								}
								this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
								ilgen.Emit(OpCodes.Ret);
							}
							ilgen.EmitLineNumberTable(mbCore);
						}

						// NOTE static methods don't have helpers
						if(mbHelper != null)
						{
							ILGenerator ilgen = mbHelper.GetILGenerator();
							// check "this" for null
							if(m.@@override != null && m.redirect == null && m.body == null && m.alternateBody == null)
							{
								// we're going to be calling the overridden version, so we don't need the null check
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								EmitHelper.NullCheck(ilgen);
							}
							if(mbCore != null && 
								(m.@@override == null || m.redirect != null) &&
								(m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Private) == 0 && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Final) == 0)
							{
								// TODO we should have a way to supress this for overridden methods
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Isinst, DeclaringType.TypeAsBaseType);
								ilgen.Emit(OpCodes.Dup);
								Label skip = ilgen.DefineLabel();
								ilgen.Emit(OpCodes.Brfalse_S, skip);
								for(int i = 0; i < paramTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
								}
								ilgen.Emit(OpCodes.Callvirt, mbCore);
								this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
								ilgen.Emit(OpCodes.Ret);
								ilgen.MarkLabel(skip);
								ilgen.Emit(OpCodes.Pop);
							}
							foreach(RemapperTypeWrapper overrider in overriders)
							{
								RemappedMethodWrapper mw = (RemappedMethodWrapper)overrider.GetMethodWrapper(Name, Signature, false);
								if(mw.m.redirect == null && mw.m.body == null && mw.m.alternateBody == null)
								{
									// the overridden method doesn't actually do anything special (that means it will end
									// up calling the .NET method it overrides), so we don't need to special case this
								}
								else
								{
									ilgen.Emit(OpCodes.Ldarg_0);
									ilgen.Emit(OpCodes.Isinst, overrider.TypeAsTBD);
									ilgen.Emit(OpCodes.Dup);
									Label skip = ilgen.DefineLabel();
									ilgen.Emit(OpCodes.Brfalse_S, skip);
									for(int i = 0; i < paramTypes.Length; i++)
									{
										ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
									}
									mw.Link();
									mw.EmitCallvirt(ilgen);
									this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
									ilgen.Emit(OpCodes.Ret);
									ilgen.MarkLabel(skip);
									ilgen.Emit(OpCodes.Pop);
								}
							}
							if(m.body != null || m.alternateBody != null)
							{
								IKVM.Internal.MapXml.InstructionList body = m.alternateBody == null ? m.body : m.alternateBody;
								// we manually walk the instruction list, because we need to special case the ret instructions
								Hashtable context = new Hashtable();
								foreach(IKVM.Internal.MapXml.Instruction instr in body.invoke)
								{
									if(instr is IKVM.Internal.MapXml.Ret)
									{
										this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
									}
									instr.Generate(context, ilgen);
								}
							}
							else
							{
								if(m.redirect != null && m.redirect.LineNumber != -1)
								{
									ilgen.SetLineNumber((ushort)m.redirect.LineNumber);
								}
								Type shadowType = ((RemapperTypeWrapper)DeclaringType).shadowType;
								for(int i = 0; i < paramTypes.Length + 1; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)i);
								}
								if(m.redirect != null)
								{
									EmitRedirect(shadowType, ilgen);
								}
								else if(m.@@override != null)
								{
									MethodInfo baseMethod = shadowType.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
									if(baseMethod == null)
									{
										throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
									}
									ilgen.Emit(OpCodes.Callvirt, baseMethod);
								}
								else
								{
									RemappedMethodWrapper baseMethod = DeclaringType.BaseTypeWrapper.GetMethodWrapper(Name, Signature, true) as RemappedMethodWrapper;
									if(baseMethod == null || baseMethod.m.@@override == null)
									{
										throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
									}
									MethodInfo overrideMethod = shadowType.GetMethod(baseMethod.m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
									if(overrideMethod == null)
									{
										throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
									}
									ilgen.Emit(OpCodes.Callvirt, overrideMethod);
								}
								this.ReturnType.EmitConvStackTypeToSignatureType(ilgen, null);
								ilgen.Emit(OpCodes.Ret);
							}
							ilgen.EmitLineNumberTable(mbHelper);
						}

						// do we need a helper for non-virtual reflection invocation?
						if(m.nonvirtualAlternateBody != null || (m.@@override != null && overriders.Count > 0))
						{
							RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)DeclaringType;
							Type[] argTypes = new Type[paramTypes.Length + 1];
							argTypes[0] = typeWrapper.TypeAsSignatureType;
							this.GetParametersForDefineMethod().CopyTo(argTypes, 1);
							MethodBuilder mb = typeWrapper.typeBuilder.DefineMethod("nonvirtualhelper/" + this.Name, MethodAttributes.Private | MethodAttributes.Static, this.ReturnTypeForDefineMethod, argTypes);
							if(m.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute custattr in m.Attributes)
								{
									AttributeHelper.SetCustomAttribute(mb, custattr);
								}
							}
							SetParameters(mb, m.Params);
							AttributeHelper.HideFromJava(mb);
							ILGenerator ilgen = mb.GetILGenerator();
							if(m.nonvirtualAlternateBody != null)
							{
								m.nonvirtualAlternateBody.Emit(ilgen);
							}
							else
							{
								Type shadowType = ((RemapperTypeWrapper)DeclaringType).shadowType;
								MethodInfo baseMethod = shadowType.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
								if(baseMethod == null)
								{
									throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
								}
								ilgen.Emit(OpCodes.Ldarg_0);
								for(int i = 0; i < paramTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
								}
								ilgen.Emit(OpCodes.Call, baseMethod);
								ilgen.Emit(OpCodes.Ret);
							}
						}
					}

					private void EmitRedirect(Type baseType, ILGenerator ilgen)
					{
						string redirName = m.redirect.Name;
						string redirSig = m.redirect.Sig;
						if(redirName == null)
						{
							redirName = m.Name;
						}
						if(redirSig == null)
						{
							redirSig = m.Sig;
						}
						ClassLoaderWrapper classLoader = ClassLoaderWrapper.GetBootstrapClassLoader();
						// HACK if the class name contains a comma, we assume it is a .NET type
						if(m.redirect.Class == null || m.redirect.Class.IndexOf(',') >= 0)
						{
							// TODO better error handling
							Type type = m.redirect.Class == null ? baseType : Type.GetType(m.redirect.Class, true);
							Type[] redirParamTypes = classLoader.ArgTypeListFromSig(redirSig);
							MethodInfo mi = type.GetMethod(m.redirect.Name, redirParamTypes);
							if(mi == null)
							{
								throw new InvalidOperationException();
							}
							ilgen.Emit(OpCodes.Call, mi);
						}
						else
						{
							TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(m.redirect.Class);
							MethodWrapper mw = tw.GetMethodWrapper(redirName, redirSig, false);
							if(mw == null)
							{
								throw new InvalidOperationException("Missing redirect method: " + tw.Name + "." + redirName + redirSig);
							}
							mw.Link();
							mw.EmitCall(ilgen);
						}
					}
				}

				private static void SetParameters(MethodBuilder mb, IKVM.Internal.MapXml.Param[] parameters)
				{
					if(parameters != null)
					{
						for(int i = 0; i < parameters.Length; i++)
						{
							ParameterBuilder pb = mb.DefineParameter(i + 1, ParameterAttributes.None, parameters[i].Name);
							if(parameters[i].Attributes != null)
							{
								for(int j = 0; j < parameters[i].Attributes.Length; j++)
								{
									AttributeHelper.SetCustomAttribute(pb, parameters[i].Attributes[j]);
								}
							}
						}
					}
				}

				private static void SetParameters(ConstructorBuilder cb, IKVM.Internal.MapXml.Param[] parameters)
				{
					if(parameters != null)
					{
						for(int i = 0; i < parameters.Length; i++)
						{
							ParameterBuilder pb = cb.DefineParameter(i + 1, ParameterAttributes.None, parameters[i].Name);
							if(parameters[i].Attributes != null)
							{
								for(int j = 0; j < parameters[i].Attributes.Length; j++)
								{
									AttributeHelper.SetCustomAttribute(pb, parameters[i].Attributes[j]);
								}
							}
						}
					}
				}

				internal void Process2ndPassStep1(IKVM.Internal.MapXml.Root map)
				{
					IKVM.Internal.MapXml.Class c = classDef;
					TypeBuilder tb = typeBuilder;
					bool baseIsSealed = shadowType.IsSealed;

					if(c.Interfaces != null)
					{
						interfaceWrappers = new TypeWrapper[c.Interfaces.Length];
						for(int i = 0; i < c.Interfaces.Length; i++)
						{
							TypeWrapper ifaceTypeWrapper = ClassLoaderWrapper.LoadClassCritical(c.Interfaces[i].Name);
							interfaceWrappers[i] = ifaceTypeWrapper;
							if(!baseIsSealed)
							{
								tb.AddInterfaceImplementation(ifaceTypeWrapper.TypeAsBaseType);
							}
						}
						AttributeHelper.SetImplementsAttribute(tb, interfaceWrappers);
					}
					else
					{
						interfaceWrappers = TypeWrapper.EmptyArray;
					}
				}

				internal void Process2ndPassStep2(IKVM.Internal.MapXml.Root map)
				{
					IKVM.Internal.MapXml.Class c = classDef;
					TypeBuilder tb = typeBuilder;
					bool baseIsSealed = shadowType.IsSealed;

					ArrayList fields = new ArrayList();

					// TODO fields should be moved to the RemapperTypeWrapper constructor as well
					if(c.Fields != null)
					{
						foreach(IKVM.Internal.MapXml.Field f in c.Fields)
						{
							if(f.redirect != null)
							{
								TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(f.redirect.Class);
								MethodWrapper method = tw.GetMethodWrapper(f.redirect.Name, f.redirect.Sig, false);
								if(method == null || !method.IsStatic)
								{
									// TODO better error handling
									throw new InvalidOperationException("remapping field: " + f.Name + f.Sig + " not found");
								}
								// TODO emit an static helper method that enables access to the field at runtime
								method.Link();
								fields.Add(new GetterFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), null, f.Name, f.Sig, (Modifiers)f.Modifiers, (MethodInfo)method.GetMethod()));
							}
							else if((f.Modifiers & IKVM.Internal.MapXml.MapModifiers.Static) != 0)
							{
								FieldAttributes attr = MapFieldAccessModifiers(f.Modifiers) | FieldAttributes.Static;
								if(f.Constant != null)
								{
									attr |= FieldAttributes.Literal;
								}
								else if((f.Modifiers & IKVM.Internal.MapXml.MapModifiers.Final) != 0)
								{
									attr |= FieldAttributes.InitOnly;
								}
								FieldBuilder fb = tb.DefineField(f.Name, GetClassLoader().FieldTypeWrapperFromSig(f.Sig).TypeAsSignatureType, attr);
								if(f.Attributes != null)
								{
									foreach(IKVM.Internal.MapXml.Attribute custattr in f.Attributes)
									{
										AttributeHelper.SetCustomAttribute(fb, custattr);
									}
								}
								object constant;
								if(f.Constant != null)
								{
									switch(f.Sig[0])
									{
										case 'J':
											constant = long.Parse(f.Constant);
											break;
										default:
											// TODO support other types
											throw new NotImplementedException("remapped constant field of type: " + f.Sig);
									}
									fb.SetConstant(constant);
									fields.Add(new ConstantFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, fb, constant, MemberFlags.LiteralField));
								}
								else
								{
									fields.Add(FieldWrapper.Create(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), fb, f.Name, f.Sig, (Modifiers)f.Modifiers));
								}
							}
							else
							{
								// TODO we should support adding arbitrary instance fields (the runtime will have to use
								// a weak identity hashtable to store the extra information for subclasses that don't extend our stub)
								throw new NotImplementedException(this.Name + "." + f.Name + f.Sig);
							}
						}
					}
					SetFields((FieldWrapper[])fields.ToArray(typeof(FieldWrapper)));
				}

				internal void Process3rdPass()
				{
					foreach(RemappedMethodBaseWrapper m in GetMethods())
					{
						m.Link();
					}
				}

				internal void Process4thPass(ICollection remappedTypes)
				{
					foreach(RemappedMethodBaseWrapper m in GetMethods())
					{
						m.Finish();
					}

					if(classDef.Clinit != null)
					{
						ConstructorBuilder cb = typeBuilder.DefineTypeInitializer();
						ILGenerator ilgen = cb.GetILGenerator();
						// TODO emit code to make sure super class is initialized
						classDef.Clinit.body.Emit(ilgen);
					}

					// FXBUG because the AppDomain.TypeResolve event doesn't work correctly for inner classes,
					// we need to explicitly finish the interface we implement (if they are ghosts, we need the nested __Interface type)
					if(classDef.Interfaces != null)
					{
						foreach(IKVM.Internal.MapXml.Interface iface in classDef.Interfaces)
						{
							GetClassLoader().LoadClassByDottedName(iface.Name).Finish();
						}
					}

					CreateShadowInstanceOf(remappedTypes);
					CreateShadowCheckCast(remappedTypes);

					if(!shadowType.IsInterface)
					{
						// For all inherited methods, we emit a method that hides the inherited method and
						// annotate it with EditorBrowsableAttribute(EditorBrowsableState.Never) to make
						// sure the inherited methods don't show up in Intellisense.
						// TODO if the original method has a LinkDemand, we should copy that
						Hashtable methods = new Hashtable();
						foreach(MethodInfo mi in typeBuilder.BaseType.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.FlattenHierarchy))
						{
							string key = MakeMethodKey(mi);
							if(!methods.ContainsKey(key))
							{
								ParameterInfo[] paramInfo = mi.GetParameters();
								Type[] paramTypes = new Type[paramInfo.Length];
								for(int i = 0; i < paramInfo.Length; i++)
								{
									paramTypes[i] = paramInfo[i].ParameterType;
								}
								MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & (MethodAttributes.MemberAccessMask | MethodAttributes.SpecialName | MethodAttributes.Static), mi.ReturnType, paramTypes);
								AttributeHelper.HideFromJava(mb);
								AttributeHelper.SetEditorBrowsableNever(mb);
								ILGenerator ilgen = mb.GetILGenerator();
								for(int i = 0; i < paramTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
								}
								if(!mi.IsStatic)
								{
									ilgen.Emit(OpCodes.Ldarg_S, (byte)paramTypes.Length);
								}
								ilgen.Emit(OpCodes.Call, mi);
								ilgen.Emit(OpCodes.Ret);
								methods[key] = mb;
							}
						}
						foreach(PropertyInfo pi in typeBuilder.BaseType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static))
						{
							ParameterInfo[] paramInfo = pi.GetIndexParameters();
							Type[] paramTypes = new Type[paramInfo.Length];
							for(int i = 0; i < paramInfo.Length; i++)
							{
								paramTypes[i] = paramInfo[i].ParameterType;
							}
							PropertyBuilder pb = typeBuilder.DefineProperty(pi.Name, PropertyAttributes.None, pi.PropertyType, paramTypes);
							if(pi.CanRead)
							{
								pb.SetGetMethod((MethodBuilder)methods[MakeMethodKey(pi.GetGetMethod())]);
							}
							if(pi.CanWrite)
							{
								pb.SetSetMethod((MethodBuilder)methods[MakeMethodKey(pi.GetSetMethod())]);
							}
							AttributeHelper.SetEditorBrowsableNever(pb);
						}
					}

					typeBuilder.CreateType();
					if(helperTypeBuilder != null)
					{
						helperTypeBuilder.CreateType();
					}
				}

				private static string MakeMethodKey(MethodInfo method)
				{
					StringBuilder sb = new StringBuilder();
					sb.Append(method.ReturnType.AssemblyQualifiedName).Append(":").Append(method.Name);
					ParameterInfo[] paramInfo = method.GetParameters();
					Type[] paramTypes = new Type[paramInfo.Length];
					for(int i = 0; i < paramInfo.Length; i++)
					{
						paramTypes[i] = paramInfo[i].ParameterType;
						sb.Append(":").Append(paramInfo[i].ParameterType.AssemblyQualifiedName);
					}
					return sb.ToString();
				}

				private void CreateShadowInstanceOf(ICollection remappedTypes)
				{
					// FXBUG .NET 1.1 doesn't allow static methods on interfaces
					if(typeBuilder.IsInterface)
					{
						return;
					}
					MethodAttributes attr = MethodAttributes.SpecialName | MethodAttributes.Public | MethodAttributes.Static;
					MethodBuilder mb = typeBuilder.DefineMethod("__<instanceof>", attr, typeof(bool), new Type[] { typeof(object) });
					AttributeHelper.HideFromJava(mb);
					AttributeHelper.SetEditorBrowsableNever(mb);
					ILGenerator ilgen = mb.GetILGenerator();

					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Isinst, shadowType);
					Label retFalse = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, retFalse);

					if(!shadowType.IsSealed)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, typeBuilder);
						ilgen.Emit(OpCodes.Brtrue_S, retFalse);
					}

					if(shadowType == typeof(object))
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, typeof(Array));
						ilgen.Emit(OpCodes.Brtrue_S, retFalse);
					}

					foreach(RemapperTypeWrapper r in remappedTypes)
					{
						if(!r.shadowType.IsInterface && r.shadowType.IsSubclassOf(shadowType))
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Isinst, r.shadowType);
							ilgen.Emit(OpCodes.Brtrue_S, retFalse);
						}
					}
					ilgen.Emit(OpCodes.Ldc_I4_1);
					ilgen.Emit(OpCodes.Ret);

					ilgen.MarkLabel(retFalse);
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ret);
				}

				private void CreateShadowCheckCast(ICollection remappedTypes)
				{
					// FXBUG .NET 1.1 doesn't allow static methods on interfaces
					if(typeBuilder.IsInterface)
					{
						return;
					}
					MethodAttributes attr = MethodAttributes.SpecialName | MethodAttributes.Public | MethodAttributes.Static;
					MethodBuilder mb = typeBuilder.DefineMethod("__<checkcast>", attr, shadowType, new Type[] { typeof(object) });
					AttributeHelper.HideFromJava(mb);
					AttributeHelper.SetEditorBrowsableNever(mb);
					ILGenerator ilgen = mb.GetILGenerator();

					Label fail = ilgen.DefineLabel();
					bool hasfail = false;

					if(!shadowType.IsSealed)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, typeBuilder);
						ilgen.Emit(OpCodes.Brtrue_S, fail);
						hasfail = true;
					}

					if(shadowType == typeof(object))
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, typeof(Array));
						ilgen.Emit(OpCodes.Brtrue_S, fail);
						hasfail = true;
					}

					foreach(RemapperTypeWrapper r in remappedTypes)
					{
						if(!r.shadowType.IsInterface && r.shadowType.IsSubclassOf(shadowType))
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Isinst, r.shadowType);
							ilgen.Emit(OpCodes.Brtrue_S, fail);
							hasfail = true;
						}
					}
					ilgen.Emit(OpCodes.Ldarg_0);
					EmitHelper.Castclass(ilgen, shadowType);
					ilgen.Emit(OpCodes.Ret);

					if(hasfail)
					{
						ilgen.MarkLabel(fail);
						ilgen.ThrowException(typeof(InvalidCastException));
					}
				}

				internal override MethodBase LinkMethod(MethodWrapper mw)
				{
					return ((RemappedMethodBaseWrapper)mw).DoLink();
				}

				internal override TypeWrapper DeclaringTypeWrapper
				{
					get
					{
						// at the moment we don't support nested remapped types
						return null;
					}
				}

				internal override void Finish()
				{
					if(BaseTypeWrapper != null)
					{
						BaseTypeWrapper.Finish();
					}
					foreach(TypeWrapper iface in Interfaces)
					{
						iface.Finish();
					}
					foreach(MethodWrapper m in GetMethods())
					{
						m.Link();
					}
					foreach(FieldWrapper f in GetFields())
					{
						f.Link();
					}
				}

				internal override TypeWrapper[] InnerClasses
				{
					get
					{
						return TypeWrapper.EmptyArray;
					}
				}

				internal override TypeWrapper[] Interfaces
				{
					get
					{
						return interfaceWrappers;
					}
				}

				internal override Type TypeAsTBD
				{
					get
					{
						return shadowType;
					}
				}

				internal override Type TypeAsBaseType
				{
					get
					{
						return typeBuilder;
					}
				}

				internal override TypeBuilder TypeAsBuilder
				{
					get
					{
						return typeBuilder;
					}
				}

				internal override bool IsMapUnsafeException
				{
					get
					{
						// any remapped exceptions are automatically unsafe
						return shadowType == typeof(Exception) || shadowType.IsSubclassOf(typeof(Exception));
					}
				}

				internal override string GetGenericSignature()
				{
					return null;
				}

				internal override string GetGenericMethodSignature(MethodWrapper mw)
				{
					return null;
				}

				internal override string GetGenericFieldSignature(FieldWrapper fw)
				{
					return null;
				}

				internal override string[] GetEnclosingMethod()
				{
					return null;
				}
			}

			internal void EmitRemappedTypes(IKVM.Internal.MapXml.Root map)
			{
				Tracer.Info(Tracer.Compiler, "Emit remapped types");

				assemblyAttributes = map.assembly.Attributes;

				// 1st pass, put all types in remapped to make them loadable
				bool hasRemappedTypes = false;
				foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
				{
					if(c.Shadows != null)
					{
						remapped.Add(c.Name, new RemapperTypeWrapper(this, c, map));
						hasRemappedTypes = true;
					}
				}

				if(hasRemappedTypes)
				{
					AotTypeWrapper.SetupGhosts(map);
				}

				// 2nd pass, resolve interfaces, publish methods/fields
				foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
				{
					if(c.Shadows != null)
					{
						RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)remapped[c.Name];
						typeWrapper.Process2ndPassStep1(map);
					}
				}
				foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
				{
					if(c.Shadows != null)
					{
						RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)remapped[c.Name];
						typeWrapper.Process2ndPassStep2(map);
					}
				}
			}

			internal void FinishRemappedTypes()
			{
				// 3rd pass, link the methods. Note that a side effect of the linking is the
				// twiddling with the overriders array in the base methods, so we need to do this
				// as a separate pass before we compile the methods
				foreach(RemapperTypeWrapper typeWrapper in remapped.Values)
				{
					typeWrapper.Process3rdPass();
				}
				// 4th pass, implement methods/fields and bake the type
				foreach(RemapperTypeWrapper typeWrapper in remapped.Values)
				{
					typeWrapper.Process4thPass(remapped.Values);
				}

				if(assemblyAttributes != null)
				{
					foreach(IKVM.Internal.MapXml.Attribute attr in assemblyAttributes)
					{
						AttributeHelper.SetCustomAttribute(((AssemblyBuilder)this.ModuleBuilder.Assembly), attr);
					}
				}
			}
		}

		public class CompilerOptions
		{
			public string path;
			public string keyfilename;
			public string keycontainer;
			public string version;
			public string fileversion;
			public bool targetIsModule;
			public string assembly;
			public string mainClass;
			public ApartmentState apartment;
			public PEFileKinds target;
			public bool guessFileKind;
			public byte[][] classes;
			public string[] references;
			public bool nojni;
			public Hashtable resources;
			public string[] classesToExclude;
			public string remapfile;
			public Hashtable props;
			public bool noglobbing;
			public bool nostacktraceinfo;
			public bool removeUnusedFields;
			public bool compressedResources;
			public bool strictFinalFieldSemantics;
			public string runtimeAssembly;
		}

		private static bool IsSigned(Assembly asm)
		{
			byte[] key = asm.GetName().GetPublicKey();
			return key != null && key.Length != 0;
		}

		public static void SetIkvmStubMode()
		{
			// HACK
			isIkvmStub = true;
		}

		public static int Compile(CompilerOptions options)
		{
			Tracer.Info(Tracer.Compiler, "JVM.Compile path: {0}, assembly: {1}", options.path, options.assembly);
			isStaticCompiler = true;
			noJniStubs = options.nojni;
			noStackTraceInfo = options.nostacktraceinfo;
			strictFinalFieldSemantics = options.strictFinalFieldSemantics;
			Assembly runtimeAssembly;
#if WHIDBEY
			if(options.runtimeAssembly == null)
			{
				runtimeAssembly = typeof(JVM).Assembly;
				Assembly.ReflectionOnlyLoadFrom(runtimeAssembly.Location);
			}
			else
			{
				runtimeAssembly = Assembly.ReflectionOnlyLoadFrom(options.runtimeAssembly);
			}
#else
			runtimeAssembly = typeof(JVM).Assembly;
#endif
			AssemblyName runtimeAssemblyName = runtimeAssembly.GetName();
			bool allReferencesAreStrongNamed = IsSigned(runtimeAssembly);
			foreach(string r in options.references)
			{
				try
				{
#if WHIDBEY
					Assembly reference = Assembly.ReflectionOnlyLoadFrom(r);
					if(AttributeHelper.IsDefined(reference, JVM.LoadType(typeof(RemappedClassAttribute))))
					{
						coreAssembly = reference;
					}
#else
					Assembly reference = Assembly.LoadFrom(r);
#endif
					if(reference == null)
					{
						Console.Error.WriteLine("Error: reference not found: {0}", r);
						return 1;
					}
					allReferencesAreStrongNamed &= IsSigned(reference);
					Tracer.Info(Tracer.Compiler, "Loaded reference assembly: {0}", reference.FullName);
					// if it's an IKVM compiled assembly, make sure that it was compiled
					// against same version of the runtime
					foreach(AssemblyName asmref in reference.GetReferencedAssemblies())
					{
						if(asmref.Name == runtimeAssemblyName.Name)
						{
							if(IsSigned(runtimeAssembly))
							{
								if(asmref.FullName != runtimeAssemblyName.FullName)
								{
									Console.Error.WriteLine("Error: referenced assembly {0} was compiled with an incompatible IKVM.Runtime version ({1})", r, asmref.Version);
									Console.Error.WriteLine("   (current runtime is {0})", runtimeAssemblyName.FullName);
									return 1;
								}
							}
							else
							{
								if(asmref.GetPublicKey() != null && asmref.GetPublicKey().Length != 0)
								{
									Console.Error.WriteLine("Error: referenced assembly {0} was compiled with an incompatible (signed) IKVM.Runtime version", r);
									Console.Error.WriteLine("   (current runtime is {0})", runtimeAssemblyName.FullName);
									return 1;
								}
							}
						}
					}
				}
				catch(Exception x)
				{
					Console.Error.WriteLine("Error: invalid reference: {0} ({1})", r, x.Message);
					return 1;
				}
			}
#if WHIDBEY
			// If the "System" assembly wasn't explicitly referenced, load it automatically
			bool systemIsLoaded = false;
			foreach(Assembly asm in AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies())
			{
				if(asm.GetType("System.ComponentModel.EditorBrowsableAttribute", false, false) != null)
				{
					systemIsLoaded = true;
					break;
				}
			}
			if(!systemIsLoaded)
			{
				Assembly.ReflectionOnlyLoadFrom(typeof(System.ComponentModel.EditorBrowsableAttribute).Assembly.Location);
			}
#endif
			Hashtable h = new Hashtable();
			Tracer.Info(Tracer.Compiler, "Parsing class files");
			for(int i = 0; i < options.classes.Length; i++)
			{
				string name;
				try
				{
					if(options.mainClass == null && (options.guessFileKind || options.target != PEFileKinds.Dll))
					{
						ClassFile f = new ClassFile(options.classes[i], 0, options.classes[i].Length, null);
						name = f.Name;
						foreach(ClassFile.Method m in f.Methods)
						{
							if(m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V")
							{
								Console.Error.WriteLine("Note: found main method in class \"{0}\"", f.Name);
								options.mainClass = f.Name;
								break;
							}
						}
					}
					else
					{
						name = ClassFile.GetClassName(options.classes[i], 0, options.classes[i].Length);
					}
				}
				catch(UnsupportedClassVersionError x)
				{
					Console.Error.WriteLine("Error: unsupported class file version: {0}", x.Message);
					return 1;
				}
				catch(ClassFormatError x)
				{
					Console.Error.WriteLine("Error: invalid class file: {0}", x.Message);
					return 1;
				}
				bool excluded = false;
				for(int j = 0; j < options.classesToExclude.Length; j++)
				{
					if(Regex.IsMatch(name, options.classesToExclude[j]))
					{
						excluded = true;
						break;
					}
				}
				if(h.ContainsKey(name))
				{
					Console.Error.WriteLine("Warning: duplicate class name: {0}", name);
					excluded = true;
				}
				if(!excluded)
				{
					h[name] = options.classes[i];
				}
			}
			options.classes = null;

			if(options.guessFileKind && options.mainClass == null)
			{
				options.target = PEFileKinds.Dll;
			}

			if(options.target == PEFileKinds.Dll && options.mainClass != null)
			{
				Console.Error.WriteLine("Error: main class cannot be specified for library or module");
				return 1;
			}

			if(options.target != PEFileKinds.Dll && options.mainClass == null)
			{
				Console.Error.WriteLine("Error: no main method found");
				return 1;
			}

			if(options.target == PEFileKinds.Dll && options.props.Count != 0)
			{
				Console.Error.WriteLine("Error: properties cannot be specified for library or module");
				return 1;
			}

			if(options.path == null)
			{
				if(options.target == PEFileKinds.Dll)
				{
					if(options.targetIsModule)
					{
						options.path = options.assembly + ".netmodule";
					}
					else
					{
						options.path = options.assembly + ".dll";
					}
				}
				else
				{
					options.path = options.assembly + ".exe";
				}
				Console.Error.WriteLine("Note: output file is \"{0}\"", options.path);
			}

			if(options.targetIsModule)
			{
				// TODO if we're overwriting a user specified assembly name, we need to emit a warning
				options.assembly = new FileInfo(options.path).Name;
			}

			if(options.target == PEFileKinds.Dll && !options.path.ToLower().EndsWith(".dll") && !options.targetIsModule)
			{
				Console.Error.WriteLine("Error: library output file must end with .dll");
				return 1;
			}

			if(options.target != PEFileKinds.Dll && !options.path.ToLower().EndsWith(".exe"))
			{
				Console.Error.WriteLine("Error: executable output file must end with .exe");
				return 1;
			}

			Tracer.Info(Tracer.Compiler, "Constructing compiler");
			CompilerClassLoader loader = new CompilerClassLoader(options, options.path, options.keyfilename, options.keycontainer, options.version, options.targetIsModule, options.assembly, h);
			ClassLoaderWrapper.SetBootstrapClassLoader(loader);
			compilationPhase1 = true;
			IKVM.Internal.MapXml.Root map = null;
			if(options.remapfile != null)
			{
				Tracer.Info(Tracer.Compiler, "Loading remapped types (1) from {0}", options.remapfile);
				System.Xml.Serialization.XmlSerializer ser = new System.Xml.Serialization.XmlSerializer(typeof(IKVM.Internal.MapXml.Root));
				ser.UnknownElement += new System.Xml.Serialization.XmlElementEventHandler(ser_UnknownElement);
				ser.UnknownAttribute += new System.Xml.Serialization.XmlAttributeEventHandler(ser_UnknownAttribute);
				using(FileStream fs = File.Open(options.remapfile, FileMode.Open))
				{
					XmlTextReader rdr = new XmlTextReader(fs);
					IKVM.Internal.MapXml.Root.xmlReader = rdr;
					IKVM.Internal.MapXml.Root.filename = new FileInfo(fs.Name).Name;
					map = (IKVM.Internal.MapXml.Root)ser.Deserialize(rdr);
				}
				loader.EmitRemappedTypes(map);
			}
			// Do a sanity check to make sure some of the bootstrap classes are available
			if(loader.LoadClassByDottedNameFast("java.lang.Object") == null)
			{
#if WHIDBEY
				coreAssembly = Assembly.ReflectionOnlyLoadFrom(Assembly.GetExecutingAssembly().Location + "\\..\\IKVM.GNU.Classpath.dll");
#else
				coreAssembly = Assembly.LoadWithPartialName("IKVM.GNU.Classpath");
#endif
				if(coreAssembly == null)
				{
					Console.Error.WriteLine("Error: bootstrap classes missing and IKVM.GNU.Classpath.dll not found");
					return 1;
				}
				allReferencesAreStrongNamed &= IsSigned(coreAssembly);
				Console.Error.WriteLine("Note: automatically adding reference to \"{0}\"", coreAssembly.Location);
				// we need to scan again for remapped types, now that we've loaded the core library
				ClassLoaderWrapper.LoadRemappedTypes();
			}

			if((options.keycontainer != null || options.keyfilename != null) && !allReferencesAreStrongNamed)
			{
				Console.Error.WriteLine("Error: all referenced assemblies must be strong named, to be able to sign the output assembly");
				return 1;
			}

			if(runtimeAssembly.GetType("gnu.classpath.Pointer") != null)
			{
				ClassLoaderWrapper.PublishLibraryImplementationHelperType(LoadType(typeof(gnu.classpath.Pointer)));
			}
			if(runtimeAssembly.GetType("ikvm.internal.LibraryVMInterface") != null)
			{
				ClassLoaderWrapper.PublishLibraryImplementationHelperType(LoadType(typeof(ikvm.@@internal.LibraryVMInterface)));
			}

			Tracer.Info(Tracer.Compiler, "Compiling class files (1)");
			ArrayList allwrappers = new ArrayList();
			foreach(string s in new ArrayList(h.Keys))
			{
				try
				{
					// HACK skip synthetic delegate inner classes
					// (we don't want to generate the unused interfaces)
					if(s.EndsWith(DotNetTypeWrapper.DelegateInterfaceSuffix))
					{
						byte[] buf = (byte[])h[s];
						try
						{
							ClassFile c = new ClassFile(buf, 0, buf.Length, s);
							if(c.IKVMAssemblyAttribute != null)
							{
								continue;
							}
						}
						catch
						{
						}
					}
					TypeWrapper wrapper = loader.LoadClassByDottedNameFast(s);
					if(wrapper != null)
					{
						if(map == null)
						{
							wrapper.Finish();
						}
						allwrappers.Add(wrapper);
					}
				}
				catch(IllegalAccessError x)
				{
					Console.Error.WriteLine("Warning: unable to compile class \"{0}\"", s);
					Console.Error.WriteLine("    (illegal access error \"{0}\")", x.Message);
				}
				catch(VerifyError x)
				{
					Console.Error.WriteLine("Warning: unable to compile class \"{0}\"", s);
					Console.Error.WriteLine("    (verification error \"{0}\")", x.Message);
				}
				catch(NoClassDefFoundError x)
				{
					Console.Error.WriteLine("Warning: unable to compile class \"{0}\"", s);
					Console.Error.WriteLine("    (missing class \"{0}\")", x.Message);
				}
				catch(RetargetableJavaException x)
				{
					Console.Error.WriteLine("Warning: unable to compile class \"{0}\"", s);
					Console.Error.WriteLine("    ({0}: \"{1}\")", x.GetType().Name, x.Message);
				}
			}
			if(options.mainClass != null)
			{
				TypeWrapper wrapper = null;
				try
				{
					wrapper = loader.LoadClassByDottedNameFast(options.mainClass);
				}
				catch(RetargetableJavaException)
				{
				}
				if(wrapper == null)
				{
					Console.Error.WriteLine("Error: main class not found");
					return 1;
				}
				MethodWrapper mw = wrapper.GetMethodWrapper("main", "([Ljava.lang.String;)V", false);
				if(mw == null)
				{
					Console.Error.WriteLine("Error: main method not found");
					return 1;
				}
				mw.Link();
				MethodInfo method = mw.GetMethod() as MethodInfo;
				if(method == null)
				{
					Console.Error.WriteLine("Error: redirected main method not supported");
					return 1;
				}
				if(method.DeclaringType.Assembly != loader.ModuleBuilder.Assembly
					&& (!method.IsPublic || !method.DeclaringType.IsPublic))
				{
					Console.Error.WriteLine("Error: external main method must be public and in a public class");
					return 1;
				}
				Type apartmentAttributeType = null;
				if(options.apartment == ApartmentState.STA)
				{
					apartmentAttributeType = typeof(STAThreadAttribute);
				}
				else if(options.apartment == ApartmentState.MTA)
				{
					apartmentAttributeType = typeof(MTAThreadAttribute);
				}
				loader.SetMain(method, options.target, options.props, options.noglobbing, apartmentAttributeType);
			}
			compilationPhase1 = false;
			if(map != null)
			{
				AotTypeWrapper.LoadMappedExceptions(map);
				// mark all exceptions that are unsafe for mapping with a custom attribute,
				// so that at runtime we can quickly assertain if an exception type can be
				// caught without filtering
				foreach(TypeWrapper tw in allwrappers)
				{
					if(!tw.IsInterface && tw.IsMapUnsafeException)
					{
						AttributeHelper.SetExceptionIsUnsafeForMapping(tw.TypeAsBuilder);
					}
				}
				AotTypeWrapper.LoadMapXml(map);
				Tracer.Info(Tracer.Compiler, "Loading remapped types (2)");
				loader.FinishRemappedTypes();
			}
			Tracer.Info(Tracer.Compiler, "Compiling class files (2)");
			loader.AddResources(options.resources, options.compressedResources);
			if(options.fileversion != null)
			{
				CustomAttributeBuilder filever = new CustomAttributeBuilder(typeof(AssemblyFileVersionAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { options.fileversion });
				((AssemblyBuilder)loader.ModuleBuilder.Assembly).SetCustomAttribute(filever);
			}
			((AssemblyBuilder)loader.ModuleBuilder.Assembly).DefineVersionInfoResource();
			loader.Save();
			return 0;
		}
#endif

#if !COMPACT_FRAMEWORK
		public static void PrepareForSaveDebugImage()
		{
			DynamicClassLoader.PrepareForSaveDebugImage();
		}
	
		public static void SaveDebugImage(object mainClass)
		{
			DynamicClassLoader.SaveDebugImage(mainClass);
		}
#endif

		public static void SetBootstrapClassLoader(object classLoader)
		{
			ClassLoaderWrapper.GetBootstrapClassLoader().SetJavaClassLoader(classLoader);
		}

		internal static void CriticalFailure(string message, Exception x)
		{
			try
			{
				Tracer.Error(Tracer.Runtime, "CRITICAL FAILURE: {0}", message);
				// NOTE we use reflection to invoke MessageBox.Show, to make sure we run in environments where WinForms isn't available
				Assembly winForms = IsUnix ? null : Assembly.Load("System.Windows.Forms, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
				Type messageBox = null;
				if(winForms != null)
				{
					messageBox = winForms.GetType("System.Windows.Forms.MessageBox");
				}
				new ReflectionPermission(ReflectionPermissionFlag.MemberAccess
#if !WHIDBEY
					| ReflectionPermissionFlag.TypeInformation
#endif
				).Assert();
				message = String.Format("****** Critical Failure: {1} ******{0}" +
					"{2}{0}" + 
					"{3}{0}" +
					"{4}",
					Environment.NewLine,
					message,
					x,
					x != null ? new StackTrace(x, true).ToString() : "",
					new StackTrace(true));
				CodeAccessPermission.RevertAssert();
				if(messageBox != null)
				{
					try
					{
						Version ver = SafeGetAssemblyVersion(typeof(JVM).Assembly);
						messageBox.InvokeMember("Show", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.Public, null, null, new object[] { message, "IKVM.NET " + ver + " Critical Failure" });
					}
					catch
					{
						Console.Error.WriteLine(message);
					}
				}
				else
				{
					Console.Error.WriteLine(message);
				}
			}
			catch(Exception ex)
			{
				Console.Error.WriteLine(ex);
			}
			finally
			{
				Environment.Exit(666);
			}
		}

		private static void ser_UnknownElement(object sender, System.Xml.Serialization.XmlElementEventArgs e)
		{
			Console.Error.WriteLine("Unknown element {0} in XML mapping file, line {1}, column {2}", e.Element.Name, e.LineNumber, e.LinePosition);
			Environment.Exit(1);
		}

		private static void ser_UnknownAttribute(object sender, System.Xml.Serialization.XmlAttributeEventArgs e)
		{
			Console.Error.WriteLine("Unknown attribute {0} in XML mapping file, line {1}, column {2}", e.Attr.Name, e.LineNumber, e.LinePosition);
			Environment.Exit(1);
@


1.67
log
@*** empty log message ***
@
text
@d637 1
a637 1
		private class CompilerClassLoader : ClassLoaderWrapper
d2732 1
a2732 1
			ClassLoaderWrapper.PrepareForSaveDebugImage();
d2737 1
a2737 1
			ClassLoaderWrapper.SaveDebugImage(mainClass);
@


1.66
log
@*** empty log message ***
@
text
@d850 1
a850 1
			internal void AddResources(Hashtable resources, bool compressedResources, bool manifestResources)
d860 3
a862 1
						if(manifestResources)
d864 4
a867 6
#if WHIDBEY
							// NOTE this is an undocumented option and this resource format is *not* supported by IKVM.GNU.Classpath.dll
							moduleBuilder.DefineManifestResource(name, new MemoryStream(buf), ResourceAttributes.Public);
#else
							throw new InvalidOperationException("DefineManifestResource is only available on .NET 2.0");
#endif
d871 2
a872 2
							IResourceWriter writer = moduleBuilder.DefineResource(name, "");
							writer.AddResource(compressedResources ? "lz" : "ikvm", buf);
d874 6
a2318 1
			public bool manifestResources;
d2717 1
a2717 1
			loader.AddResources(options.resources, options.compressedResources, options.manifestResources);
@


1.65
log
@*** empty log message ***
@
text
@d179 19
@


1.64
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
d204 4
d213 4
@


1.63
log
@*** empty log message ***
@
text
@d30 1
@


1.62
log
@*** empty log message ***
@
text
@d673 5
a677 2
				CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, JVM.Debug });
				assemblyBuilder.SetCustomAttribute(debugAttr);
@


1.61
log
@*** empty log message ***
@
text
@d258 1
a258 1
			return fi != null && fi.IsDefined(typeof(ObsoleteAttribute), false);
d273 1
a273 1
			return mb != null && mb.IsDefined(typeof(ObsoleteAttribute), false);
d288 1
a288 1
			return mb != null && mb.IsDefined(typeof(ObsoleteAttribute), false);
d302 1
a302 1
			return wrapper.TypeAsTBD.IsDefined(typeof(ObsoleteAttribute), false);
d320 1
d527 8
d819 1
a819 1
			internal void AddResources(Hashtable resources, bool compressedResources)
d828 15
a842 2
						IResourceWriter writer = moduleBuilder.DefineResource(JVM.MangleResourceName((string)d.Key), "");
						writer.AddResource(compressedResources ? "lz" : "ikvm", buf);
d2282 1
d2284 1
d2293 6
d2306 1
a2306 1
			Assembly runtimeAssembly = typeof(JVM).Assembly;
d2308 11
a2318 1
			Assembly.ReflectionOnlyLoadFrom(runtimeAssembly.Location);
d2328 1
a2328 2
					Type type = UnsafeGetType(reference, "java.lang.LibraryVMInterfaceImpl");
					if(type != null)
d2554 8
a2561 2
			ClassLoaderWrapper.PublishLibraryImplementationHelperType(LoadType(typeof(gnu.classpath.Pointer)));
			ClassLoaderWrapper.PublishLibraryImplementationHelperType(LoadType(typeof(ikvm.@@internal.LibraryVMInterface)));
d2681 1
a2681 1
			loader.AddResources(options.resources, options.compressedResources);
d2779 1
a2779 1
			if(JVM.IsStaticCompiler)
d2781 1
a2781 1
				return Assembly.ReflectionOnlyLoadFrom(type.Assembly.Location).GetType(type.FullName);
@


1.60
log
@*** empty log message ***
@
text
@d227 10
@


1.59
log
@*** empty log message ***
@
text
@d27 1
d29 2
a43 2
using ILGenerator = IKVM.Internal.CountingILGenerator;

d317 1
d349 18
d370 6
d381 5
a385 1
			new ReflectionPermission(ReflectionPermissionFlag.MemberAccess | ReflectionPermissionFlag.TypeInformation).Assert();
d395 16
d415 6
d446 1
d589 1
a589 1
#if !NO_STATIC_COMPILER
d642 5
a646 1
				assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.RunAndSave, assemblyDir);
d651 1
a651 2
					CustomAttributeBuilder sourceFileAttr = new CustomAttributeBuilder(typeof(SourceFileAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { null });
					moduleBuilder.SetCustomAttribute(sourceFileAttr);
d653 1
a653 2
				CustomAttributeBuilder ikvmModuleAttr = new CustomAttributeBuilder(typeof(JavaModuleAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
				moduleBuilder.SetCustomAttribute(ikvmModuleAttr);
d691 3
d695 1
d732 1
d743 1
a743 1
					ilgen.Emit(OpCodes.Call, typeof(IKVM.Runtime.Startup).GetMethod("SetProperties"));
d746 1
a746 1
				ilgen.Emit(OpCodes.Call, typeof(IKVM.Runtime.Startup).GetMethod("EnterMainThread"));
d753 1
a753 1
					ilgen.Emit(OpCodes.Call, typeof(IKVM.Runtime.Startup).GetMethod("Glob", Type.EmptyTypes));
d757 1
a757 1
				ilgen.Emit(OpCodes.Call, typeof(IKVM.Runtime.Util).GetMethod("MapException", new Type[] { typeof(Exception) }));
d768 1
a768 1
				ClassLoaderWrapper.LoadClassCritical("java.lang.ThreadGroup").GetMethodWrapper("uncaughtException", "(Ljava.lang.Thread;Ljava.lang.Throwable;)V", false).EmitCall(ilgen);
d772 1
a772 1
				ilgen.Emit(OpCodes.Call, typeof(IKVM.Runtime.Startup).GetMethod("ExitMainThread", Type.EmptyTypes));
d950 3
a952 5
						ConstructorInfo remappedClassAttribute = typeof(RemappedClassAttribute).GetConstructor(new Type[] { typeof(string), typeof(Type) });
						classLoader.assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(remappedClassAttribute, new object[] { name, shadowType }));

						ConstructorInfo remappedTypeAttribute = typeof(RemappedTypeAttribute).GetConstructor(new Type[] { typeof(Type) });
						typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(remappedTypeAttribute, new object[] { shadowType }));
d1264 1
a1264 2
							CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(RemappedInterfaceMethodAttribute).GetConstructor(new Type[] { typeof(string), typeof(string) }), new object[] { m.Name, m.@@override.Name } );
							typeWrapper.typeBuilder.SetCustomAttribute(cab);
d2267 3
d2276 8
d2285 1
d2326 16
d2483 6
a2488 2
				Assembly classpath = Assembly.LoadWithPartialName("IKVM.GNU.Classpath");
				if(classpath == null)
d2493 2
a2494 2
				allReferencesAreStrongNamed &= IsSigned(classpath);
				Console.Error.WriteLine("Note: automatically adding reference to \"{0}\"", classpath.Location);
d2505 2
a2506 2
			ClassLoaderWrapper.PublishLibraryImplementationHelperType(typeof(gnu.classpath.Pointer));
			ClassLoaderWrapper.PublishLibraryImplementationHelperType(typeof(ikvm.@@internal.LibraryVMInterface));
d2618 1
a2618 1
						tw.TypeAsBuilder.SetCustomAttribute(typeof(ExceptionIsUnsafeForMappingAttribute).GetConstructor(Type.EmptyTypes), new byte[0]);
d2637 2
d2648 1
d2667 5
a2671 1
				new ReflectionPermission(ReflectionPermissionFlag.MemberAccess | ReflectionPermissionFlag.TypeInformation).Assert();
d2720 11
@


1.58
log
@*** empty log message ***
@
text
@d2015 16
@


1.57
log
@*** empty log message ***
@
text
@d2065 20
@


1.56
log
@*** empty log message ***
@
text
@d1221 1
a1221 1
								helper = typeWrapper.helperTypeBuilder.DefineMethod(m.Name, MethodAttributes.Public | MethodAttributes.Static, typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsSignatureType, argTypes);
d1287 1
a1287 1
								MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers);
d1331 1
a1331 1
								MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers) | MethodAttributes.Static;
@


1.55
log
@*** empty log message ***
@
text
@d2389 17
@


1.54
log
@*** empty log message ***
@
text
@d2414 5
d2427 1
a2427 1
				catch(NoClassDefFoundError)
@


1.53
log
@Fixed bug 1257044.
@
text
@d205 21
@


1.52
log
@*** empty log message ***
@
text
@d1661 1
a1661 1
				internal void Process2ndPass(IKVM.Internal.MapXml.Root map)
d1685 7
d1745 1
a1745 1
									fields.Add(new ConstantFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, fb, constant));
d2000 1
a2000 1
						return null;
d2074 9
a2082 1
						typeWrapper.Process2ndPass(map);
@


1.51
log
@*** empty log message ***
@
text
@d294 1
d458 12
d1985 1
a1985 1
				internal override void Finish(bool forDebugSave)
@


1.50
log
@*** empty log message ***
@
text
@d2331 1
a2331 1
			ClassLoaderWrapper.PublishLibraryImplementationHelperType(typeof(gnu.classpath.RawData));
@


1.49
log
@*** empty log message ***
@
text
@d516 1
d518 1
a518 1
			internal CompilerClassLoader(string path, string keyfilename, string keycontainer, string version, bool targetIsModule, string assemblyName, Hashtable classes)
d521 1
d580 2
a581 2
					ClassFile f = (ClassFile)classes[name];
					if(f != null)
d583 11
d611 1
d615 4
d2176 1
a2176 1
				ClassFile f;
d2179 18
a2196 1
					f = new ClassFile(options.classes[i], 0, options.classes[i].Length, null, true);
a2207 1
				string name = f.Name;
d2224 1
a2224 17
					if(options.removeUnusedFields)
					{
						f.RemoveUnusedFields();
					}
					h[name] = f;
					if(options.mainClass == null && (options.guessFileKind || options.target != PEFileKinds.Dll))
					{
						foreach(ClassFile.Method m in f.Methods)
						{
							if(m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V")
							{
								Console.Error.WriteLine("Note: found main method in class \"{0}\"", f.Name);
								options.mainClass = f.Name;
								break;
							}
						}
					}
d2227 1
a2289 36
			// make sure all inner classes have a reference to their outer class
			// note that you cannot use the InnerClasses attribute in the inner class for this, because
			// anonymous inner classes do not have a reference to their outer class
			foreach(ClassFile classFile in h.Values)
			{
				// don't handle inner classes for ikvmstub types
				if(classFile.IKVMAssemblyAttribute == null)
				{
					ClassFile.InnerClass[] innerClasses = classFile.InnerClasses;
					if(innerClasses != null)
					{
						for(int j = 0; j < innerClasses.Length; j++)
						{
							if(innerClasses[j].outerClass != 0 && classFile.GetConstantPoolClass(innerClasses[j].outerClass) == classFile.Name)
							{
								string inner = classFile.GetConstantPoolClass(innerClasses[j].innerClass);
								ClassFile innerClass = (ClassFile)h[inner];
								if(innerClass != null)
								{
									if(innerClass.OuterClass != null)
									{
										Console.Error.WriteLine("Error: inner class {0} has multiple outer classes", inner);
										return 1;
									}
									innerClass.OuterClass = classFile;
								}
								else
								{
									Console.Error.WriteLine("Warning: inner class {0} missing", inner);
								}
							}
						}
					}
				}
			}

d2291 1
a2291 1
			CompilerClassLoader loader = new CompilerClassLoader(options.path, options.keyfilename, options.keycontainer, options.version, options.targetIsModule, options.assembly, h);
d2336 1
a2336 1
			foreach(string s in h.Keys)
a2337 1
				TypeWrapper wrapper = null;
d2340 2
a2341 2
					wrapper = loader.LoadClassByDottedNameFast(s);
					if(wrapper == null)
d2343 1
a2343 3
						// this should only happen for netexp types (because the other classes must exist, after all we just parsed them)
						ClassFile c = h[s] as ClassFile;
						if(c == null || c.IKVMAssemblyAttribute == null)
d2345 1
a2345 2
							Console.Error.WriteLine("Error: loading class \"{0}\" failed for unknown reason", s);
							return 1;
a2346 4
						Console.Error.WriteLine("Warning: ikvmstub class \"{0}\" refers to non-existing type", s);
					}
					else
					{
@


1.48
log
@*** empty log message ***
@
text
@d2375 10
@


1.47
log
@*** empty log message ***
@
text
@d293 1
d373 8
d2090 1
d2105 1
@


1.46
log
@*** empty log message ***
@
text
@d547 5
@


1.45
log
@*** empty log message ***
@
text
@d2080 2
a2081 1
			return asm.GetName().GetPublicKey().Length != 0;
@


1.44
log
@*** empty log message ***
@
text
@d2058 1
d2429 6
@


1.43
log
@*** empty log message ***
@
text
@d39 1
d41 1
a41 1
using ILGenerator = CountingILGenerator;
@


1.42
log
@*** empty log message ***
@
text
@d1748 1
a1748 1
						// For all inherited methods, we emit a method that hide the inherited method and
d1764 1
a1764 1
								MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & ~(MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot), mi.ReturnType, paramTypes);
d1789 1
a1789 1
							PropertyBuilder pb = typeBuilder.DefineProperty(pi.Name, pi.Attributes, pi.PropertyType, paramTypes);
@


1.41
log
@*** empty log message ***
@
text
@d492 1
a492 1

d522 5
d2012 1
a2012 1
					DynamicTypeWrapper.SetupGhosts(map);
d2410 1
a2410 1
				DynamicTypeWrapper.LoadMappedExceptions(map);
d2421 1
a2421 1
				DynamicTypeWrapper.LoadMapXml(map);
d2430 1
a2430 1

@


1.40
log
@*** empty log message ***
@
text
@d1580 8
a1587 1
							mb.DefineParameter(i + 1, ParameterAttributes.None, parameters[i].Name);
d1598 8
a1605 1
							cb.DefineParameter(i + 1, ParameterAttributes.None, parameters[i].Name);
@


1.39
log
@*** empty log message ***
@
text
@a806 5
					if(c.Deprecated)
					{
						AttributeHelper.SetDeprecatedAttribute(typeBuilder);
					}

d930 1
a933 4
							if(m.Deprecated)
							{
								AttributeHelper.SetDeprecatedAttribute(mbHelper);
							}
d945 1
a946 4
							if(m.Deprecated)
							{
								AttributeHelper.SetDeprecatedAttribute(cbCore);
							}
d1157 1
d1248 1
a1253 8
								if(m.Deprecated)
								{
									AttributeHelper.SetDeprecatedAttribute(mbCore);
								}
								if(m.HideFromJava)
								{
									AttributeHelper.HideFromJava(mbCore);
								}
d1280 6
a1285 5
								AttributeHelper.SetEditorBrowsableNever(mbHelper);
								AttributeHelper.SetModifiers(mbHelper, (Modifiers)m.Modifiers);
								AttributeHelper.SetNameSig(mbHelper, m.Name, m.Sig);
								AddDeclaredExceptions(mbHelper, m.throws);
								if(m.Deprecated)
d1287 2
a1288 1
									AttributeHelper.SetDeprecatedAttribute(mbHelper);
d1290 4
a1293 1
								if(m.HideFromJava)
d1295 1
a1295 1
									AttributeHelper.HideFromJava(mbHelper);
d1297 3
d1508 1
d1574 22
a1678 4
								if(f.Deprecated)
								{
									AttributeHelper.SetDeprecatedAttribute(fb);
								}
@


1.38
log
@*** empty log message ***
@
text
@d35 2
d284 1
a284 1
		private static bool debug;
d293 48
d347 1
a347 1
					foreach(Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
d349 1
a349 1
						Type type = asm.GetType("java.lang.LibraryVMInterfaceImpl");
d352 1
a352 1
							lib = Activator.CreateInstance(type, true) as ikvm.@@internal.LibraryVMInterface;
d668 1
a668 1
			internal void AddResources(Hashtable resources)
d678 1
a678 1
						writer.AddResource("ikvm", buf);
d791 7
d928 7
d946 7
d1161 7
d1251 7
d1290 7
d1510 7
d1639 7
d1722 1
d1724 1
a1724 1
						foreach(MethodInfo mi in typeBuilder.BaseType.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static))
d2016 1
a2016 1
						((AssemblyBuilder)this.ModuleBuilder.Assembly).SetCustomAttribute(AttributeHelper.CreateCustomAttribute(attr));
d2044 1
d2058 3
a2060 1
			bool allReferencesAreStrongNamed = IsSigned(typeof(JVM).Assembly);
d2073 26
d2329 2
a2330 1
					Console.Error.WriteLine("Warning: unable to compile class \"{0}\" (missing class \"{1}\")", s, x.Message);
d2397 1
a2397 1
			loader.AddResources(options.resources);
d2422 2
a2423 2
				// NOTE we use reflection to invoke MessageBox.Show, to make sure we run on Mono as well
				Assembly winForms = IsUnix ? null : Assembly.LoadWithPartialName("System.Windows.Forms");
d2429 1
d2439 1
d2444 2
a2445 1
						messageBox.InvokeMember("Show", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.Public, null, null, new object[] { message, "IKVM.NET Critical Failure" });
@


1.37
log
@*** empty log message ***
@
text
@a285 1
		private static bool isTlsEnabled;
a287 1
		private static bool monoBugWorkaround;
a396 12
		internal static bool IsTlsEnabled
		{
			get
			{
				return isTlsEnabled;
			}
			set
			{
				isTlsEnabled = value;
			}
		}

d455 1
d523 1
a523 1
								Console.Error.WriteLine("netexp assembly not found: {0}", netexp);
a596 45
			private void MonoBugWorkaround()
			{
				// Mono 1.0.5 (and earlier) and 1.1.3 (and earlier) have bug in the metadata routines.
				// Zoltan says:
				// The size calculation for the MethodSematics:Association metadata column was wrong,
				// it was based on the size of the Method table, so when the number of methods in the
				// dll exceeded some number, all the tables after the MethodSematics table had the
				// wrong address. This means the only workaround for this bug is to emit
				// like 32768 dummy Events or Properties, or decrease the size of the Method table to
				// below 32768 by dropping some classes.
				// ---
				// We distribute the properties in 128 nested classes, because peverify has some very
				// non-linear algorithms and is extremely slow with 32768 properties in a single class.
				// (it also helps make the overhead a little smaller.)
				bool runningOnMono = Type.GetType("Mono.Runtime") != null;
				TypeBuilder tb = ModuleBuilder.DefineType("MonoBugWorkaround", TypeAttributes.NotPublic);
				TypeBuilder[] nested = new TypeBuilder[128];
				for(int i = 0; i < nested.Length; i++)
				{
					nested[i] = tb.DefineNestedType(i.ToString(), TypeAttributes.NestedPrivate);
					MethodBuilder getter = null;
					for(int j = 0; j < 32768 / nested.Length; j++)
					{
						PropertyBuilder pb = nested[i].DefineProperty(j.ToString(), PropertyAttributes.None, typeof(int), Type.EmptyTypes);
						// MONOBUG sigh, another Mono bug, if the property has no methods, Mono crashes
						if(runningOnMono)
						{
							if(getter == null)
							{
								getter = nested[i].DefineMethod("get", MethodAttributes.Private, typeof(int), Type.EmptyTypes);
								ILGenerator ilgen = getter.GetILGenerator();
								ilgen.Emit(OpCodes.Ldc_I4_0);
								ilgen.Emit(OpCodes.Ret);
							}
							pb.SetGetMethod(getter);
						}
					}
				}
				tb.CreateType();
				for(int i = 0; i < nested.Length; i++)
				{
					nested[i].CreateType();
				}
			}

a601 5
				if(monoBugWorkaround)
				{
					MonoBugWorkaround();
				}

d1056 1
a1056 1
							foreach(IKVM.Internal.MapXml.Class c in map.assembly)
d1861 2
d1865 1
a1865 1
				foreach(IKVM.Internal.MapXml.Class c in map.assembly)
d1880 1
a1880 1
				foreach(IKVM.Internal.MapXml.Class c in map.assembly)
d1904 8
a1936 2
			public bool monoBugWorkaround;
			public bool enableTls;
a1949 2
			monoBugWorkaround = options.monoBugWorkaround;
			isTlsEnabled = options.enableTls;
@


1.36
log
@*** empty log message ***
@
text
@d1925 1
d1931 1
d1935 4
a1938 1
				DynamicTypeWrapper.SetupGhosts(map);
d1994 5
d2007 1
d2018 1
d2209 1
d2215 6
d2312 1
a2312 1
				DynamicTypeWrapper.LoadNativeMethods(map);
@


1.35
log
@*** empty log message ***
@
text
@d304 7
a310 1
							lib = (ikvm.@@internal.LibraryVMInterface)Activator.CreateInstance(type, true);
@


1.34
log
@*** empty log message ***
@
text
@d290 1
d357 20
d1239 4
d1270 4
d2056 1
a2056 1
								Console.Error.WriteLine("Note: found main method in class: {0}", f.Name);
d2105 1
a2105 1
				Console.Error.WriteLine("Note: output file is: {0}", options.path);
d2191 1
a2191 2
				Console.Error.WriteLine("Warning: bootstrap classes are missing, automatically adding reference to {0}", classpath.Location);
				Console.Error.WriteLine("  (to avoid this warning add \"-reference:{0}\" to the command line)", classpath.Location);
d2210 7
a2216 1
						Console.Error.WriteLine("Class not found: {0}", s);
d2223 1
a2223 1
				catch(Exception x)
d2225 1
a2225 2
					Console.Error.WriteLine("Loading class {0} failed due to:", s);
					Console.Error.WriteLine(x);
d2230 8
a2237 1
				TypeWrapper wrapper = loader.LoadClassByDottedNameFast(options.mainClass);
@


1.33
log
@*** empty log message ***
@
text
@d48 1
a48 1
		public static string[] Glob(string arg)
a49 4
			if(IKVM.Internal.JVM.IsUnix)
			{
				return new string[] { arg };
			}
d76 1
a76 8
			if(IKVM.Internal.JVM.IsUnix)
			{
				return Environment.GetCommandLineArgs();
			}
			else
			{
				return Glob(1);
			}
d155 7
a161 1
				Thread.CurrentThread.Name = "main";
d170 3
a172 11
			// we know the thread is dead). So to make that work for the main thread, we explicitly clear the TLS
			// slot that contains our hack object.
			try
			{
				Thread.SetData(Thread.GetNamedDataSlot("ikvm-thread-hack"), null);
			}
			catch(NullReferenceException)
			{
				// MONOBUG Thread.SetData throws a NullReferenceException on Mono
				// if the slot hadn't already been allocated
			}
d286 1
d372 12
d1951 1
d1961 1
@


1.32
log
@*** empty log message ***
@
text
@d1807 1
a1807 1
					ilgen.Emit(OpCodes.Castclass, shadowType);
@


1.31
log
@*** empty log message ***
@
text
@d34 1
d103 1
a103 1
				System.Text.StringBuilder sb = new System.Text.StringBuilder();
d410 1
a410 1
			System.Text.StringBuilder sb = new System.Text.StringBuilder("ikvm__", name.Length + 6);
d1125 1
a1125 1
								helper = typeWrapper.helperTypeBuilder.DefineMethod(m.Name, MethodAttributes.Public | MethodAttributes.Static, typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsParameterType, argTypes);
d1160 1
a1160 1
							Type retType = typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsParameterType;
d1280 1
a1280 1
										this.ReturnType.EmitConvStackToParameterType(ilgen, null);
d1313 1
a1313 1
								this.ReturnType.EmitConvStackToParameterType(ilgen, null);
d1348 1
a1348 1
								this.ReturnType.EmitConvStackToParameterType(ilgen, null);
d1374 1
a1374 1
									this.ReturnType.EmitConvStackToParameterType(ilgen, null);
d1389 1
a1389 1
										this.ReturnType.EmitConvStackToParameterType(ilgen, null);
d1432 1
a1432 1
								this.ReturnType.EmitConvStackToParameterType(ilgen, null);
d1443 1
a1443 1
							argTypes[0] = typeWrapper.TypeAsParameterType;
a1507 7
						if(!classLoader.RetTypeWrapperFromSig(redirSig).IsAssignableTo(this.ReturnType))
						{
							// NOTE we're passing a null context, this is safe because the return type
							// should always be loadable
							System.Diagnostics.Debug.Assert(!this.ReturnType.IsUnloadable);
							this.ReturnType.EmitCheckcast(null, ilgen);
						}
d1567 1
a1567 1
								FieldBuilder fb = tb.DefineField(f.Name, GetClassLoader().FieldTypeWrapperFromSig(f.Sig).TypeAsFieldType, attr);
d1647 2
a1648 3
							ParameterInfo[] paramInfo = mi.GetParameters();
							Type[] paramTypes = new Type[paramInfo.Length];
							for(int i = 0; i < paramInfo.Length; i++)
d1650 21
a1670 1
								paramTypes[i] = paramInfo[i].ParameterType;
a1671 15
							MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & ~(MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot), mi.ReturnType, paramTypes);
							AttributeHelper.HideFromJava(mb);
							AttributeHelper.SetEditorBrowsableNever(mb);
							ILGenerator ilgen = mb.GetILGenerator();
							for(int i = 0; i < paramTypes.Length; i++)
							{
								ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
							}
							if(!mi.IsStatic)
							{
								ilgen.Emit(OpCodes.Ldarg_S, (byte)paramTypes.Length);
							}
							ilgen.Emit(OpCodes.Call, mi);
							ilgen.Emit(OpCodes.Ret);
							methods[mb.Name] = mb;
d1684 1
a1684 1
								pb.SetGetMethod((MethodBuilder)methods[pi.GetGetMethod().Name]);
d1688 1
a1688 1
								pb.SetSetMethod((MethodBuilder)methods[pi.GetSetMethod().Name]);
d1701 14
@


1.30
log
@*** empty log message ***
@
text
@d596 1
d602 1
d605 13
a617 1
						nested[i].DefineProperty(j.ToString(), PropertyAttributes.None, typeof(int), Type.EmptyTypes);
@


1.29
log
@*** empty log message ***
@
text
@d437 1
d442 1
a442 1
			internal CompilerClassLoader(string path, string keyfilename, string version, bool targetIsModule, string assemblyName, Hashtable classes)
d453 1
d468 4
d1906 1
d2106 1
a2106 1
			CompilerClassLoader loader = new CompilerClassLoader(options.path, options.keyfilename, options.version, options.targetIsModule, options.assembly, h);
@


1.28
log
@*** empty log message ***
@
text
@d176 9
a184 1
			Thread.SetData(Thread.GetNamedDataSlot("ikvm-thread-hack"), null);
d300 1
d576 31
d612 5
d1917 1
d1926 1
@


1.27
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d1851 1
a1851 1
		public static int Compile(string path, string keyfilename, string version, bool targetIsModule, string assembly, string mainClass, ApartmentState apartment, PEFileKinds target, bool guessFileKind, byte[][] classes, string[] references, bool nojni, Hashtable resources, string[] classesToExclude, string remapfile, Hashtable props, bool noglobbing, bool nostacktraceinfo)
d1853 24
a1876 1
			Tracer.Info(Tracer.Compiler, "JVM.Compile path: {0}, assembly: {1}", path, assembly);
d1878 3
a1880 3
			noJniStubs = nojni;
			noStackTraceInfo = nostacktraceinfo;
			foreach(string r in references)
d1900 1
a1900 1
			for(int i = 0; i < classes.Length; i++)
d1905 1
a1905 1
					f = new ClassFile(classes[i], 0, classes[i].Length, null, true);
d1919 1
a1919 1
				for(int j = 0; j < classesToExclude.Length; j++)
d1921 1
a1921 1
					if(Regex.IsMatch(name, classesToExclude[j]))
d1934 4
d1939 1
a1939 1
					if(mainClass == null && (guessFileKind || target != PEFileKinds.Dll))
d1946 1
a1946 1
								mainClass = f.Name;
d1954 1
a1954 1
			if(guessFileKind && mainClass == null)
d1956 1
a1956 1
				target = PEFileKinds.Dll;
d1959 1
a1959 1
			if(target == PEFileKinds.Dll && mainClass != null)
d1965 1
a1965 1
			if(target != PEFileKinds.Dll && mainClass == null)
d1971 1
a1971 1
			if(target == PEFileKinds.Dll && props.Count != 0)
d1977 1
a1977 1
			if(path == null)
d1979 1
a1979 1
				if(target == PEFileKinds.Dll)
d1981 1
a1981 1
					if(targetIsModule)
d1983 1
a1983 1
						path = assembly + ".netmodule";
d1987 1
a1987 1
						path = assembly + ".dll";
d1992 1
a1992 1
					path = assembly + ".exe";
d1994 1
a1994 1
				Console.Error.WriteLine("Note: output file is: {0}", path);
d1997 1
a1997 1
			if(targetIsModule)
d2000 1
a2000 1
				assembly = new FileInfo(path).Name;
d2003 1
a2003 1
			if(target == PEFileKinds.Dll && !path.ToLower().EndsWith(".dll") && !targetIsModule)
d2009 1
a2009 1
			if(target != PEFileKinds.Dll && !path.ToLower().EndsWith(".exe"))
d2052 1
a2052 1
			CompilerClassLoader loader = new CompilerClassLoader(path, keyfilename, version, targetIsModule, assembly, h);
d2056 1
a2056 1
			if(remapfile != null)
d2058 1
a2058 1
				Tracer.Info(Tracer.Compiler, "Loading remapped types (1) from {0}", remapfile);
d2062 1
a2062 1
				using(FileStream fs = File.Open(remapfile, FileMode.Open))
d2113 1
a2113 1
			if(mainClass != null)
d2115 1
a2115 1
				TypeWrapper wrapper = loader.LoadClassByDottedNameFast(mainClass);
d2141 1
a2141 1
				if(apartment == ApartmentState.STA)
d2145 1
a2145 1
				else if(apartment == ApartmentState.MTA)
d2149 1
a2149 1
				loader.SetMain(method, target, props, noglobbing, apartmentAttributeType);
d2170 1
a2170 1
			loader.AddResources(resources);
@


1.26
log
@*** empty log message ***
@
text
@d550 1
a550 1
				threadTypeWrapper.GetMethodWrapper(new MethodDescriptor("currentThread", "()Ljava.lang.Thread;"), false).EmitCall(ilgen);
d553 1
a553 1
				threadTypeWrapper.GetMethodWrapper(new MethodDescriptor("getThreadGroup", "()Ljava.lang.ThreadGroup;"), false).EmitCallvirt(ilgen);
d556 1
a556 1
				ClassLoaderWrapper.LoadClassCritical("java.lang.ThreadGroup").GetMethodWrapper(new MethodDescriptor("uncaughtException", "(Ljava.lang.Thread;Ljava.lang.Throwable;)V"), false).EmitCall(ilgen);
d755 2
d761 1
a761 1
							AddMethod(new RemappedConstructorWrapper(this, m));
d770 1
a770 1
							AddMethod(new RemappedMethodWrapper(this, m, map));
d773 2
d779 2
a780 2
					internal RemappedMethodBaseWrapper(RemapperTypeWrapper typeWrapper, MethodDescriptor md, Modifiers modifiers)
						: base(typeWrapper, md, null, null, null, modifiers, MemberFlags.None)
d808 1
a808 1
						: base(typeWrapper, new MethodDescriptor("<init>", m.Sig), (Modifiers)m.Modifiers)
a832 1
						MethodDescriptor md = new MethodDescriptor("<init>", m.Sig);
a912 1
								MethodDescriptor redir = new MethodDescriptor(m.redirect.Name, m.redirect.Sig);
d932 1
a932 1
									MethodWrapper mw = tw.GetMethodWrapper(redir, false);
d980 1
a980 1
						: base(typeWrapper, new MethodDescriptor(m.Name, m.Sig), (Modifiers)m.Modifiers)
a1005 1
						MethodDescriptor md = new MethodDescriptor(m.Name, m.Sig);
d1073 1
a1073 1
									MethodWrapper mw = tw.GetMethodWrapper(md, false);
d1101 1
a1101 1
									RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(md, true) as RemappedMethodWrapper;
d1127 1
a1127 1
										RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(md, true) as RemappedMethodWrapper;
a1186 1
						MethodDescriptor md = this.Descriptor;
d1289 1
a1289 1
								RemappedMethodWrapper mw = (RemappedMethodWrapper)overrider.GetMethodWrapper(md, false);
d1354 1
a1354 1
									RemappedMethodWrapper baseMethod = DeclaringType.BaseTypeWrapper.GetMethodWrapper(md, true) as RemappedMethodWrapper;
a1417 1
						MethodDescriptor redir = new MethodDescriptor(redirName, redirSig);
d1434 1
a1434 1
							MethodWrapper mw = tw.GetMethodWrapper(redir, false);
d1437 1
a1437 1
								throw new InvalidOperationException("Missing redirect method: " + tw.Name + "." + redir.Name + redir.Signature);
d1477 2
d1487 1
a1487 2
								MethodDescriptor redir = new MethodDescriptor(f.redirect.Name, f.redirect.Sig);
								MethodWrapper method = tw.GetMethodWrapper(redir, false);
d1495 1
a1495 1
								AddField(new GetterFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), null, f.Name, f.Sig, (Modifiers)f.Modifiers, (MethodInfo)method.GetMethod()));
d1522 1
a1522 1
									AddField(new ConstantFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, fb, constant));
d1526 1
a1526 1
									AddField(FieldWrapper.Create(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), fb, f.Name, f.Sig, (Modifiers)f.Modifiers));
d1541 1
a1757 6
				protected override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
				{
					// we don't resolve fields lazily
					return null;
				}

d2094 1
a2094 1
				MethodWrapper mw = wrapper.GetMethodWrapper(new MethodDescriptor("main", "([Ljava.lang.String;)V"), false);
@


1.25
log
@*** empty log message ***
@
text
@d191 1
a191 1
				return IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(DotNetTypeWrapper.GetWrapperFromDotNetType(t));
d193 1
a193 1
			return IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(ClassLoaderWrapper.GetWrapperFromType(t));
d201 1
a201 1
				return IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(DotNetTypeWrapper.GetWrapperFromDotNetType(t));
d203 1
a203 1
			return IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(ClassLoaderWrapper.GetWrapperFromType(t));
d300 13
a312 2
					Type type = ClassLoaderWrapper.LoadClassCritical("java.lang.LibraryVMInterfaceImpl").TypeAsTBD;
					lib = (ikvm.@@internal.LibraryVMInterface)Activator.CreateInstance(type, true);
d501 1
a501 1
						type = DefineClass(f);
d673 1
a673 1
					: base((Modifiers)c.Modifiers, c.Name, GetBaseWrapper(c), classLoader)
@


1.24
log
@*** empty log message ***
@
text
@d1845 1
a1845 1
		public static void Compile(string path, string keyfilename, string version, bool targetIsModule, string assembly, string mainClass, ApartmentState apartment, PEFileKinds target, bool guessFileKind, byte[][] classes, string[] references, bool nojni, Hashtable resources, string[] classesToExclude, string remapfile, Hashtable props, bool noglobbing, bool nostacktraceinfo)
d1859 1
a1859 1
						return;
d1866 1
a1866 1
					return;
d1881 1
a1881 1
					return;
d1886 1
a1886 1
					return;
d1929 1
a1929 1
				return;
d1935 1
a1935 1
				return;
d1941 1
a1941 1
				return;
d1973 1
a1973 1
				return;
d1979 1
a1979 1
				return;
d2004 1
a2004 1
										return;
d2045 1
a2045 1
					return;
d2086 1
a2086 1
					return;
d2092 1
a2092 1
					return;
d2099 1
a2099 1
					return;
d2105 1
a2105 1
					return;
d2139 1
@


1.23
log
@*** empty log message ***
@
text
@a2078 27
				if(s == mainClass && wrapper != null)
				{
					MethodWrapper mw = wrapper.GetMethodWrapper(new MethodDescriptor("main", "([Ljava.lang.String;)V"), false);
					if(mw == null)
					{
						Console.Error.WriteLine("Error: main method not found");
						return;
					}
					mw.Link();
					MethodBuilder method = mw.GetMethod() as MethodBuilder;
					if(method == null)
					{
						Console.Error.WriteLine("Error: redirected main method not supported");
						return;
					}
					Type apartmentAttributeType = null;
					if(apartment == ApartmentState.STA)
					{
						apartmentAttributeType = typeof(STAThreadAttribute);
					}
					else if(apartment == ApartmentState.MTA)
					{
						apartmentAttributeType = typeof(MTAThreadAttribute);
					}
					loader.SetMain(method, target, props, noglobbing, apartmentAttributeType);
					mainClass = null;
				}
d2082 35
a2116 2
				Console.Error.WriteLine("Error: main class not found");
				return;
@


1.22
log
@*** empty log message ***
@
text
@d158 1
a158 2
			Type vmruntime = Type.GetType("java.lang.VMRuntime, IKVM.GNU.Classpath");
			vmruntime.GetField("props", BindingFlags.NonPublic | BindingFlags.Static).SetValue(null, props.Clone());
a166 5
			// HACK initialize java.lang.System first
			// (Ideally GNU Classpath wouldn't have circular initialization dependencies, but
			// it's hard to get support for that from the community).
			Type system = Type.GetType("java.lang.System, IKVM.GNU.Classpath");
			System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(system.TypeHandle);
d216 1
a216 2
			// HACK we use reflection to extract the fieldCookie from the java.lang.reflect.Field object
			return (FieldWrapper)field.GetType().GetField("fieldCookie", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(field);
d240 1
a240 2
			// HACK we use reflection to extract the methodCookie from the java.lang.reflect.Method object
			MethodWrapper mw = (MethodWrapper)method.GetType().GetField("methodCookie", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(method);
d255 1
a255 2
			// HACK we use reflection to extract the methodCookie from the java.lang.reflect.Constructor object
			MethodWrapper mw = (MethodWrapper)constructor.GetType().GetField("methodCookie", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(constructor);
@


1.21
log
@*** empty log message ***
@
text
@d282 6
d301 14
d340 1
a340 1
		public static bool NoJniStubs
d348 1
a348 1
		public static bool NoStackTraceInfo
d356 1
a356 1
		public static bool IsStaticCompiler
d364 1
a364 1
		public static bool IsStaticCompilerPhase1
d372 1
a372 1
		public static bool CompileInnerClassesAsNestedTypes
d543 1
a543 1
				ClassLoaderWrapper.LoadClassCritical("java.lang.ExceptionHelper").GetMethodWrapper(new MethodDescriptor("MapExceptionFast", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"), false).EmitCall(ilgen);
d2063 1
@


1.20
log
@*** empty log message ***
@
text
@d647 1
a647 3
					// NOTE we cannot use CoreClasses.java_lang_Object here, because that would trigger a load
					// of java.lang.String and java.lang.Throwable before we've got the remapping set up.
					return ClassLoaderWrapper.LoadClassCritical("java.lang.Object");
@


1.19
log
@*** empty log message ***
@
text
@d1150 1
d1559 51
d1625 1
a1625 1
					MethodBuilder mb = typeBuilder.DefineMethod("shadow/instanceof", attr, typeof(bool), new Type[] { typeof(object) });
d1627 1
d1674 1
a1674 1
					MethodBuilder mb = typeBuilder.DefineMethod("shadow/checkcast", attr, shadowType, new Type[] { typeof(object) });
d1676 1
d2043 3
@


1.18
log
@*** empty log message ***
@
text
@d211 71
d700 5
d821 4
d830 4
d1127 4
d1153 4
d1507 4
@


1.17
log
@*** empty log message ***
@
text
@d168 5
@


1.16
log
@*** empty log message ***
@
text
@d416 1
a416 1
				MethodBuilder mainStub = this.ModuleBuilder.DefineGlobalMethod("main", MethodAttributes.Public | MethodAttributes.Static, typeof(void), args);
d422 1
d459 2
d464 1
@


1.15
log
@*** empty log message ***
@
text
@d192 1
a192 2
				// TODO there should be a better way
				return IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(DotNetTypeWrapper.GetName(t)));
d202 1
a202 2
				// TODO there should be a better way
				return IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(DotNetTypeWrapper.GetName(t)));
a635 1
						AttributeHelper.HideFromJava(typeBuilder);
d943 1
@


1.14
log
@*** empty log message ***
@
text
@a30 1
using System.Collections.Specialized;
d37 2
d41 1
a41 1
	public class Startup
d43 4
d156 1
a156 1
		public static void SetProperties(System.Collections.Specialized.StringDictionary props)
d159 1
a159 6
			System.Collections.Hashtable h = new System.Collections.Hashtable();
			foreach(DictionaryEntry de in props)
			{
				h.Add(de.Key, de.Value);
			}
			vmruntime.GetField("props", BindingFlags.NonPublic | BindingFlags.Static).SetValue(null, h);
d180 29
d215 4
a218 3
		private static bool debug = false;
		private static bool noJniStubs = false;
		private static bool isStaticCompiler = false;
d254 8
d367 2
a368 5
				if(JVM.Debug)
				{
					CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, true });
					assemblyBuilder.SetCustomAttribute(debugAttr);
				}
d411 1
a411 1
			internal void SetMain(MethodInfo m, PEFileKinds target, StringDictionary props, bool noglobbing, Type apartmentAttributeType)
d426 1
a426 1
					ilgen.Emit(OpCodes.Newobj, typeof(StringDictionary).GetConstructor(Type.EmptyTypes));
d432 1
a432 1
						ilgen.Emit(OpCodes.Callvirt, typeof(StringDictionary).GetMethod("Add"));
d617 4
d788 1
d855 1
d1101 4
d1130 1
d1210 4
d1249 1
d1260 1
d1427 1
a1427 1
				internal void Process4thPass()
d1452 3
d1462 100
d1674 1
a1674 1
					typeWrapper.Process4thPass();
d1679 1
a1679 1
		public static void Compile(string path, string keyfilename, string version, bool targetIsModule, string assembly, string mainClass, ApartmentState apartment, PEFileKinds target, bool guessFileKind, byte[][] classes, string[] references, bool nojni, Hashtable resources, string[] classesToExclude, string remapfile, StringDictionary props, bool noglobbing)
d1684 1
d1862 1
d1865 4
a1868 1
					map = (IKVM.Internal.MapXml.Root)ser.Deserialize(fs);
d2032 6
@


1.13
log
@*** empty log message ***
@
text
@d1323 1
a1323 1
								AddField(FieldWrapper.Create1(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, null, CodeEmitter.WrapCall(method), CodeEmitter.InternalError));
d1350 1
a1350 1
									AddField(new FieldWrapper.ConstantFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, fb, constant));
d1354 1
a1354 1
									AddField(FieldWrapper.Create3(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), fb, f.Sig, (Modifiers)f.Modifiers));
d1425 1
a1425 1
				protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
@


1.12
log
@*** empty log message ***
@
text
@d161 18
d378 7
a384 1
				if(noglobbing && props.Count == 0)
d386 7
a392 1
					if(apartmentAttributeType != null)
d394 4
a397 1
						((MethodBuilder)m).SetCustomAttribute(new CustomAttributeBuilder(apartmentAttributeType.GetConstructor(Type.EmptyTypes), new object[0]));
d399 7
a405 1
					assemblyBuilder.SetEntryPoint(m, target);
d409 1
a409 34
					Type[] args = Type.EmptyTypes;
					if(noglobbing)
					{
						args = new Type[] { typeof(string[]) };
					}
					MethodBuilder mainStub = this.ModuleBuilder.DefineGlobalMethod("main", MethodAttributes.Public | MethodAttributes.Static, typeof(void), args);
					if(apartmentAttributeType != null)
					{
						mainStub.SetCustomAttribute(new CustomAttributeBuilder(apartmentAttributeType.GetConstructor(Type.EmptyTypes), new object[0]));
					}
					ILGenerator ilgen = mainStub.GetILGenerator();
					if(props.Count > 0)
					{
						ilgen.Emit(OpCodes.Newobj, typeof(StringDictionary).GetConstructor(Type.EmptyTypes));
						foreach(DictionaryEntry de in props)
						{
							ilgen.Emit(OpCodes.Dup);
							ilgen.Emit(OpCodes.Ldstr, (string)de.Key);
							ilgen.Emit(OpCodes.Ldstr, (string)de.Value);
							ilgen.Emit(OpCodes.Callvirt, typeof(StringDictionary).GetMethod("Add"));
						}
						ilgen.Emit(OpCodes.Call, typeof(IKVM.Runtime.Startup).GetMethod("SetProperties"));
					}
					if(noglobbing)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
					}
					else
					{
						ilgen.Emit(OpCodes.Call, typeof(IKVM.Runtime.Startup).GetMethod("Glob", Type.EmptyTypes));
					}
					ilgen.Emit(OpCodes.Call, m);
					ilgen.Emit(OpCodes.Ret);
					assemblyBuilder.SetEntryPoint(mainStub, target);
d411 19
@


1.11
log
@*** empty log message ***
@
text
@d31 1
d38 126
d358 1
a358 1
			internal void SetMain(MethodInfo m, PEFileKinds target)
d360 45
a404 1
				assemblyBuilder.SetEntryPoint(m, target);
d412 2
d1499 1
a1499 1
		public static void Compile(string path, string keyfilename, string version, bool targetIsModule, string assembly, string mainClass, ApartmentState apartment, PEFileKinds target, bool guessFileKind, byte[][] classes, string[] references, bool nojni, Hashtable resources, string[] classesToExclude, string remapfile)
d1591 6
d1748 1
a1748 5
					if(apartmentAttributeType != null)
					{
						method.SetCustomAttribute(new CustomAttributeBuilder(apartmentAttributeType.GetConstructor(Type.EmptyTypes), new object[0]));
					}
					loader.SetMain(method, target);
@


1.10
log
@*** empty log message ***
@
text
@d34 2
d37 1
a37 1
public class JVM
d39 1
a39 55
	private static bool debug = false;
	private static bool noJniStubs = false;
	private static bool isStaticCompiler = false;
	private static bool compilationPhase1;
	private static string sourcePath;

	public static bool Debug
	{
		get
		{
			return debug;
		}
		set
		{
			debug = value;
		}
	}

	public static string SourcePath
	{
		get
		{
			return sourcePath;
		}
		set
		{
			sourcePath = value;
		}
	}

	public static bool NoJniStubs
	{
		get
		{
			return noJniStubs;
		}
	}

	public static bool IsStaticCompiler
	{
		get
		{
			return isStaticCompiler;
		}
	}

	public static bool IsStaticCompilerPhase1
	{
		get
		{
			return compilationPhase1;
		}
	}

	public static bool CompileInnerClassesAsNestedTypes
d41 5
a45 9
		get
		{
			// NOTE at the moment, we always do this when compiling statically
			// note that it makes no sense to turn this on when we're dynamically
			// running Java code, it only makes sense to turn it off when statically
			// compiling code that is never used as a library.
			return IsStaticCompiler;
		}
	}
d47 1
a47 3
	internal static bool IsUnix
	{
		get
d49 1
a49 18
			return Environment.OSVersion.ToString().IndexOf("Unix") >= 0;
		}
	}
	
	internal static string MangleResourceName(string name)
	{
		// FXBUG there really shouldn't be any need to mangle the resource names,
		// but in order for ILDASM/ILASM round tripping to work reliably, we have
		// to make sure that we don't produce resource names that'll cause ILDASM
		// to generate invalid filenames.
		System.Text.StringBuilder sb = new System.Text.StringBuilder("ikvm__", name.Length + 6);
		foreach(char c in name)
		{
			if("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-+.()$#@@~=&{}[]0123456789`".IndexOf(c) != -1)
			{
				sb.Append(c);
			}
			else if(c == '/')
d51 1
a51 1
				sb.Append('!');
d53 1
a53 1
			else
d55 1
a55 2
				sb.Append('%');
				sb.Append(string.Format("{0:X4}", (int)c));
a57 28
		return sb.ToString();
	}

	private class CompilerClassLoader : ClassLoaderWrapper
	{
		private Hashtable classes;
		private Hashtable remapped = new Hashtable();
		private string assemblyName;
		private string assemblyFile;
		private string assemblyDir;
		private string keyfilename;
		private string version;
		private bool targetIsModule;
		private AssemblyBuilder assemblyBuilder;

		internal CompilerClassLoader(string path, string keyfilename, string version, bool targetIsModule, string assemblyName, Hashtable classes)
			: base(null)
		{
			this.classes = classes;
			this.assemblyName = assemblyName;
			FileInfo assemblyPath = new FileInfo(path);
			this.assemblyFile = assemblyPath.Name;
			this.assemblyDir = assemblyPath.DirectoryName;
			this.targetIsModule = targetIsModule;
			this.version = version;
			this.keyfilename = keyfilename;
			Tracer.Info(Tracer.Compiler, "Instantiate CompilerClassLoader for {0}", assemblyName);
		}
d59 1
a59 1
		protected override ModuleBuilder CreateModuleBuilder()
d61 1
a61 3
			AssemblyName name = new AssemblyName();
			name.Name = assemblyName;
			if(keyfilename != null) 
d63 1
a63 4
				using(FileStream stream = File.Open(keyfilename, FileMode.Open))
				{
					name.KeyPair = new StrongNameKeyPair(stream);
				}
d65 1
a65 7
			name.Version = new Version(version);
			assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.RunAndSave, assemblyDir);
			ModuleBuilder moduleBuilder;
			moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName, assemblyFile, JVM.Debug);
			CustomAttributeBuilder ikvmModuleAttr = new CustomAttributeBuilder(typeof(JavaModuleAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
			moduleBuilder.SetCustomAttribute(ikvmModuleAttr);
			if(JVM.Debug)
d67 1
a67 2
				CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, true });
				assemblyBuilder.SetCustomAttribute(debugAttr);
a68 1
			return moduleBuilder;
d71 1
a71 1
		internal override TypeWrapper GetTypeWrapperCompilerHook(string name)
d73 1
a73 2
			TypeWrapper type = base.GetTypeWrapperCompilerHook(name);
			if(type == null)
d75 1
a75 30
				type = (TypeWrapper)remapped[name];
				if(type != null)
				{
					return type;
				}
				ClassFile f = (ClassFile)classes[name];
				if(f != null)
				{
					// to enhance error reporting we special case loading of netexp
					// classes, to handle the case where the ikvmstub type doesn't exist
					// (this happens when the .NET mscorlib.jar is used on Mono, for example)
					string netexp = f.IKVMAssemblyAttribute;
					if(netexp != null)
					{
						try
						{
							Assembly.Load(netexp);
						}
						catch(Exception)
						{
							Console.Error.WriteLine("netexp assembly not found: {0}", netexp);
						}
						// HACK create a new wrapper to see if the type is visible now
						if(DotNetTypeWrapper.CreateDotNetTypeWrapper(name) == null)
						{
							return null;
						}
					}
					type = DefineClass(f);
				}
a76 1
			return type;
d79 1
a79 1
		internal void SetMain(MethodInfo m, PEFileKinds target)
d81 4
a84 1
			assemblyBuilder.SetEntryPoint(m, target);
d87 1
a87 1
		internal void Save()
d89 1
a89 11
			Tracer.Info(Tracer.Compiler, "CompilerClassLoader.Save...");
			FinishAll();

			if(targetIsModule)
			{
				Tracer.Info(Tracer.Compiler, "CompilerClassLoader saving temp.$$$ in {0}", assemblyDir);
				string manifestAssembly = "temp.$$$";
				assemblyBuilder.Save(manifestAssembly);
				File.Delete(assemblyDir + manifestAssembly);
			}
			else
d91 1
a91 2
				Tracer.Info(Tracer.Compiler, "CompilerClassLoader saving {0} in {1}", assemblyFile, assemblyDir);
				assemblyBuilder.Save(assemblyFile);
d95 1
a95 1
		internal void AddResources(Hashtable resources)
d97 1
a97 3
			Tracer.Info(Tracer.Compiler, "CompilerClassLoader adding resources...");
			ModuleBuilder moduleBuilder = this.ModuleBuilder;
			foreach(DictionaryEntry d in resources)
d99 5
a103 6
				byte[] buf = (byte[])d.Value;
				if(buf.Length > 0)
				{
					IResourceWriter writer = moduleBuilder.DefineResource(JVM.MangleResourceName((string)d.Key), "");
					writer.AddResource("ikvm", buf);
				}
d107 1
a107 1
		private static MethodAttributes MapMethodAccessModifiers(MapXml.MapModifiers mod)
d109 1
a109 2
			const MapXml.MapModifiers access = MapXml.MapModifiers.Public | MapXml.MapModifiers.Protected | MapXml.MapModifiers.Private;
			switch(mod & access)
d111 1
a111 8
				case MapXml.MapModifiers.Public:
					return MethodAttributes.Public;
				case MapXml.MapModifiers.Protected:
					return MethodAttributes.FamORAssem;
				case MapXml.MapModifiers.Private:
					return MethodAttributes.Private;
				default:
					return MethodAttributes.Assembly;
d114 2
a115 2

		private static FieldAttributes MapFieldAccessModifiers(MapXml.MapModifiers mod)
d117 6
a122 2
			const MapXml.MapModifiers access = MapXml.MapModifiers.Public | MapXml.MapModifiers.Protected | MapXml.MapModifiers.Private;
			switch(mod & access)
d124 13
a136 8
				case MapXml.MapModifiers.Public:
					return FieldAttributes.Public;
				case MapXml.MapModifiers.Protected:
					return FieldAttributes.FamORAssem;
				case MapXml.MapModifiers.Private:
					return FieldAttributes.Private;
				default:
					return FieldAttributes.Assembly;
d138 1
d141 1
a141 1
		private class RemapperTypeWrapper : TypeWrapper
d143 23
a165 5
			private TypeBuilder typeBuilder;
			private TypeBuilder helperTypeBuilder;
			private Type shadowType;
			private MapXml.Class classDef;
			private TypeWrapper[] interfaceWrappers;
d167 1
a167 1
			internal override Assembly Assembly
d169 3
a171 1
				get
d173 4
a176 1
					return typeBuilder.Assembly;
d178 12
d192 1
a192 1
			internal override bool IsRemapped
d194 2
a195 1
				get
d197 30
a226 1
					return true;
d228 1
d231 1
a231 1
			private static TypeWrapper GetBaseWrapper(MapXml.Class c)
d233 9
a241 1
				if((c.Modifiers & MapXml.MapModifiers.Interface) != 0)
d243 4
a246 38
					return null;
				}
				if(c.Name == "java.lang.Object")
				{
					return null;
				}
				// NOTE we cannot use CoreClasses.java_lang_Object here, because that would trigger a load
				// of java.lang.String and java.lang.Throwable before we've got the remapping set up.
				return ClassLoaderWrapper.LoadClassCritical("java.lang.Object");
			}

			internal RemapperTypeWrapper(CompilerClassLoader classLoader, MapXml.Class c, MapXml.Root map)
				: base((Modifiers)c.Modifiers, c.Name, GetBaseWrapper(c), classLoader)
			{
				classDef = c;
				bool baseIsSealed = false;
				shadowType = Type.GetType(c.Shadows, true);
				classLoader.SetRemappedType(shadowType, this);
				Type baseType = shadowType;
				Type baseInterface = null;
				if(baseType.IsInterface)
				{
					baseInterface = baseType;
				}
				TypeAttributes attrs = TypeAttributes.Public;
				if((c.Modifiers & MapXml.MapModifiers.Interface) == 0)
				{
					attrs |= TypeAttributes.Class;
					if(baseType.IsSealed)
					{
						baseIsSealed = true;
						// FXBUG .NET framework bug
						// ideally we would make the type sealed and abstract,
						// but Reflection.Emit incorrectly prohibits that
						// (the ECMA spec explicitly mentions this is valid)
						// attrs |= TypeAttributes.Abstract | TypeAttributes.Sealed;
						attrs |= TypeAttributes.Abstract;
					}
d250 2
a251 2
					attrs |= TypeAttributes.Interface | TypeAttributes.Abstract;
					baseType = null;
d253 7
a259 1
				if((c.Modifiers & MapXml.MapModifiers.Abstract) != 0)
d261 6
a266 1
					attrs |= TypeAttributes.Abstract;
d268 6
a273 3
				string name = c.Name.Replace('/', '.');
				typeBuilder = classLoader.ModuleBuilder.DefineType(name, attrs, baseIsSealed ? typeof(object) : baseType);
				if(baseInterface != null)
d275 8
a282 1
					typeBuilder.AddInterfaceImplementation(baseInterface);
d284 1
d286 4
a289 1
				if(baseIsSealed)
d291 8
a298 1
					AttributeHelper.SetModifiers(typeBuilder, (Modifiers)c.Modifiers);
d300 9
d310 1
a310 1
				if(c.scope == MapXml.Scope.Public)
d312 4
a315 10
					// FXBUG we would like to emit an attribute with a Type argument here, but that doesn't work because
					// of a bug in SetCustomAttribute that causes type arguments to be serialized incorrectly (if the type
					// is in the same assembly). Normally we use AttributeHelper.FreezeDry to get around this, but that doesn't
					// work in this case (no attribute is emitted at all). So we work around by emitting a string instead
					ConstructorInfo remappedClassAttribute = typeof(RemappedClassAttribute).GetConstructor(new Type[] { typeof(string), typeof(Type) });
					classLoader.assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(remappedClassAttribute, new object[] { name, shadowType }));

					ConstructorInfo remappedTypeAttribute = typeof(RemappedTypeAttribute).GetConstructor(new Type[] { typeof(Type) });
					typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(remappedTypeAttribute, new object[] { shadowType }));
					AttributeHelper.HideFromJava(typeBuilder);
d318 1
a318 4
				// HACK because of the above FXBUG that prevents us from making the type both abstract and sealed,
				// we need to emit a private constructor (otherwise reflection will automatically generate a public
				// default constructor, another lame feature)
				if(baseIsSealed)
d320 4
a323 5
					ConstructorBuilder cb = typeBuilder.DefineConstructor(MethodAttributes.Private, CallingConventions.Standard, Type.EmptyTypes);
					ILGenerator ilgen = cb.GetILGenerator();
					// lazyman's way to create a type-safe bogus constructor
					ilgen.Emit(OpCodes.Ldnull);
					ilgen.Emit(OpCodes.Throw);
d326 1
a326 1
				if(c.Constructors != null)
d328 1
a328 1
					foreach(MapXml.Constructor m in c.Constructors)
d330 1
a330 1
						AddMethod(new RemappedConstructorWrapper(this, m));
d332 7
d341 2
a342 1
				if(c.Methods != null)
d344 31
a374 2
					// TODO we should also add methods from our super classes (e.g. Throwable should have Object's methods)
					foreach(MapXml.Method m in c.Methods)
d376 12
a387 1
						AddMethod(new RemappedMethodWrapper(this, m, map));
a388 2
				}
			}
d390 8
a397 6
			abstract class RemappedMethodBaseWrapper : MethodWrapper
			{
				internal RemappedMethodBaseWrapper(RemapperTypeWrapper typeWrapper, MethodDescriptor md, Modifiers modifiers)
					: base(typeWrapper, md, null, null, null, modifiers, MemberFlags.None)
				{
				}
d399 4
a402 1
				internal abstract MethodBase DoLink();
d404 11
a414 1
				internal abstract void Finish();
d416 1
a416 3
				internal static void AddDeclaredExceptions(MethodBase mb, MapXml.Throws[] throws)
				{
					if(throws != null)
d418 1
a418 2
						string[] exceptions = new string[throws.Length];
						for(int i = 0; i < exceptions.Length; i++)
d420 1
a420 1
							exceptions[i] = throws[i].Class;
a421 1
						AttributeHelper.SetThrowsAttribute(mb, exceptions);
a422 2
				}
			}
d424 8
a431 14
			sealed class RemappedConstructorWrapper : RemappedMethodBaseWrapper
			{
				private MapXml.Constructor m;
				private MethodBuilder mbHelper;

				internal RemappedConstructorWrapper(RemapperTypeWrapper typeWrapper, MapXml.Constructor m)
					: base(typeWrapper, new MethodDescriptor("<init>", m.Sig), (Modifiers)m.Modifiers)
				{
					this.m = m;
				}

				internal override void EmitCall(ILGenerator ilgen)
				{
					ilgen.Emit(OpCodes.Call, (ConstructorInfo)GetMethod());
d434 1
a434 1
				internal override void EmitNewobj(ILGenerator ilgen)
d436 2
a437 1
					if(mbHelper != null)
a438 1
						ilgen.Emit(OpCodes.Call, mbHelper);
d440 6
a445 1
					else
d447 9
a455 1
						ilgen.Emit(OpCodes.Newobj, (ConstructorInfo)GetMethod());
d459 1
a459 1
				internal override MethodBase DoLink()
d461 2
a462 4
					MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers);
					MethodDescriptor md = new MethodDescriptor("<init>", m.Sig);
					RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)DeclaringType;
					Type[] paramTypes = typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig);
d464 5
a468 1
					ConstructorBuilder cbCore = null;
d470 1
a470 1
					if(typeWrapper.shadowType.IsSealed)
d472 1
a472 4
						mbHelper = typeWrapper.typeBuilder.DefineMethod("newhelper", attr | MethodAttributes.Static, CallingConventions.Standard, typeWrapper.shadowType, paramTypes);
						AttributeHelper.SetModifiers(mbHelper, (Modifiers)m.Modifiers);
						AttributeHelper.SetNameSig(mbHelper, "<init>", m.Sig);
						AddDeclaredExceptions(mbHelper, m.throws);
d474 2
a475 1
					else
d477 8
a484 2
						cbCore = typeWrapper.typeBuilder.DefineConstructor(attr, CallingConventions.Standard, paramTypes);
						AddDeclaredExceptions(cbCore, m.throws);
a485 6
					return cbCore;
				}
				
				internal override void Finish()
				{
					// TODO we should insert method tracing (if enabled)
d487 6
a492 1
					Type[] paramTypes = this.GetParametersForDefineMethod();
d494 1
a494 1
					ConstructorBuilder cbCore = GetMethod() as ConstructorBuilder;
d496 1
a496 5
					if(cbCore != null)
					{
						ILGenerator ilgen = cbCore.GetILGenerator();
						// TODO we need to support ghost (and other funky?) parameter types
						if(m.body != null)
d498 4
a501 2
							// TODO do we need return type conversion here?
							m.body.Emit(ilgen);
d505 19
a523 2
							ilgen.Emit(OpCodes.Ldarg_0);
							for(int i = 0; i < paramTypes.Length; i++)
d525 2
a526 5
								ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
							}
							if(m.redirect != null)
							{
								throw new NotImplementedException();
d530 10
a539 2
								ConstructorInfo baseCon = DeclaringType.TypeAsTBD.GetConstructor(paramTypes);
								if(baseCon == null)
d541 7
a547 2
									// TODO better error handling
									throw new InvalidOperationException("base class constructor not found: " + DeclaringType.Name + ".<init>" + m.Sig);
d549 1
a549 1
								ilgen.Emit(OpCodes.Call, baseCon);
a550 1
							ilgen.Emit(OpCodes.Ret);
a551 1
					}
d553 1
a553 4
					if(mbHelper != null)
					{
						ILGenerator ilgen = mbHelper.GetILGenerator();
						if(m.redirect != null)
d555 2
a556 1
							if(m.redirect.Type != "static" || m.redirect.Class == null || m.redirect.Name == null || m.redirect.Sig == null)
d558 22
a579 14
								throw new NotImplementedException();
							}
							MethodDescriptor redir = new MethodDescriptor(m.redirect.Name, m.redirect.Sig);
							Type[] redirParamTypes = ClassLoaderWrapper.GetBootstrapClassLoader().ArgTypeListFromSig(m.redirect.Sig);
							for(int i = 0; i < redirParamTypes.Length; i++)
							{
								ilgen.Emit(OpCodes.Ldarg, (short)i);
							}
							// HACK if the class name contains a comma, we assume it is a .NET type
							if(m.redirect.Class.IndexOf(',') >= 0)
							{
								Type type = Type.GetType(m.redirect.Class, true);
								MethodInfo mi = type.GetMethod(m.redirect.Name, redirParamTypes);
								if(mi == null)
d581 8
a588 1
									throw new InvalidOperationException();
d590 2
a591 1
								ilgen.Emit(OpCodes.Call, mi);
d593 1
a593 1
							else
d595 1
a595 8
								TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(m.redirect.Class);
								MethodWrapper mw = tw.GetMethodWrapper(redir, false);
								if(mw == null)
								{
									throw new InvalidOperationException();
								}
								mw.Link();
								mw.EmitCall(ilgen);
d597 1
a597 16
							// TODO we may need a cast here (or a stack to return type conversion)
							ilgen.Emit(OpCodes.Ret);
						}
						else if(m.alternateBody != null)
						{
							m.alternateBody.Emit(ilgen);
						}
						else if(m.body != null)
						{
							// <body> doesn't make sense for helper constructors (which are actually factory methods)
							throw new InvalidOperationException();
						}
						else
						{
							ConstructorInfo baseCon = DeclaringType.TypeAsTBD.GetConstructor(paramTypes);
							if(baseCon == null)
d599 2
a600 2
								// TODO better error handling
								throw new InvalidOperationException("constructor not found: " + DeclaringType.Name + ".<init>" + m.Sig);
d602 1
a602 1
							for(int i = 0; i < paramTypes.Length; i++)
d604 12
a615 1
								ilgen.Emit(OpCodes.Ldarg, (short)i);
a616 2
							ilgen.Emit(OpCodes.Newobj, baseCon);
							ilgen.Emit(OpCodes.Ret);
a619 8
			}

			sealed class RemappedMethodWrapper : RemappedMethodBaseWrapper
			{
				private MapXml.Method m;
				private MapXml.Root map;
				private MethodBuilder mbHelper;
				private ArrayList overriders = new ArrayList();
d621 1
a621 2
				internal RemappedMethodWrapper(RemapperTypeWrapper typeWrapper, MapXml.Method m, MapXml.Root map)
					: base(typeWrapper, new MethodDescriptor(m.Name, m.Sig), (Modifiers)m.Modifiers)
d623 4
a626 8
					this.m = m;
					this.map = map;
				}

				internal override void EmitCall(ILGenerator ilgen)
				{
					ilgen.Emit(OpCodes.Call, (MethodInfo)GetMethod());
				}
d628 2
a629 3
				internal override void EmitCallvirt(ILGenerator ilgen)
				{
					if(mbHelper != null)
d631 2
a632 1
						ilgen.Emit(OpCodes.Call, mbHelper);
d634 2
a635 1
					else
d637 1
a637 1
						ilgen.Emit(OpCodes.Callvirt, (MethodInfo)GetMethod());
a638 6
				}

				internal override MethodBase DoLink()
				{
					RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)DeclaringType;
					MethodDescriptor md = new MethodDescriptor(m.Name, m.Sig);
d640 1
a640 1
					if(typeWrapper.IsInterface)
d642 1
a642 1
						if(m.@@override == null)
d644 1
a644 1
							throw new InvalidOperationException(typeWrapper.Name + "." + m.Name + m.Sig);
d646 1
a646 2
						MethodInfo interfaceMethod = typeWrapper.shadowType.GetMethod(m.@@override.Name, typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig));
						if(interfaceMethod == null)
d648 1
a648 1
							throw new InvalidOperationException(typeWrapper.Name + "." + m.Name + m.Sig);
d650 8
a657 1
						if(m.throws != null)
d659 18
a676 9
							// TODO we need a place to stick the declared exceptions
							throw new NotImplementedException();
						}
						// if any of the remapped types has a body for this interface method, we need a helper method
						// to special invocation through this interface for that type
						ArrayList specialCases = null;
						foreach(MapXml.Class c in map.assembly)
						{
							if(c.Methods != null)
d678 1
a678 1
								foreach(MapXml.Method mm in c.Methods)
d680 1
a680 1
									if(mm.Name == m.Name && mm.Sig == m.Sig && mm.body != null)
d682 1
a682 1
										if(specialCases == null)
d684 6
a689 1
											specialCases = new ArrayList();
a690 2
										specialCases.Add(c);
										break;
d694 36
a729 26
						}
						CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(RemappedInterfaceMethodAttribute).GetConstructor(new Type[] { typeof(string), typeof(string) }), new object[] { m.Name, m.@@override.Name } );
						typeWrapper.typeBuilder.SetCustomAttribute(cab);
						MethodBuilder helper = null;
						if(specialCases != null)
						{
							Type[] temp = typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig);
							Type[] argTypes = new Type[temp.Length + 1];
							temp.CopyTo(argTypes, 1);
							argTypes[0] = typeWrapper.shadowType;
							if(typeWrapper.helperTypeBuilder == null)
							{
								// FXBUG we use a nested helper class, because Reflection.Emit won't allow us to add a static method to the interface
								typeWrapper.helperTypeBuilder = typeWrapper.typeBuilder.DefineNestedType("__Helper", TypeAttributes.NestedPublic | TypeAttributes.Class);
							}
							helper = typeWrapper.helperTypeBuilder.DefineMethod(m.Name, MethodAttributes.Public | MethodAttributes.Static, typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsParameterType, argTypes);
							ILGenerator ilgen = helper.GetILGenerator();
							foreach(MapXml.Class c in specialCases)
							{
								TypeWrapper tw = typeWrapper.GetClassLoader().LoadClassByDottedName(c.Name);
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Isinst, tw.TypeAsTBD);
								ilgen.Emit(OpCodes.Dup);
								Label label = ilgen.DefineLabel();
								ilgen.Emit(OpCodes.Brfalse_S, label);
								for(int i = 1; i < argTypes.Length; i++)
d733 1
a733 3
								MethodWrapper mw = tw.GetMethodWrapper(md, false);
								mw.Link();
								mw.EmitCallvirt(ilgen);
a734 6
								ilgen.MarkLabel(label);
								ilgen.Emit(OpCodes.Pop);
							}
							for(int i = 0; i < argTypes.Length; i++)
							{
								ilgen.Emit(OpCodes.Ldarg, (short)i);
d736 2
a737 2
							ilgen.Emit(OpCodes.Callvirt, interfaceMethod);
							ilgen.Emit(OpCodes.Ret);
d739 5
a743 8
						mbHelper = helper;
						return interfaceMethod;
					}
					else
					{
						MethodBuilder mbCore = null;
						Type[] paramTypes = typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig);
						Type retType = typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsParameterType;
d745 1
a745 4
						if(typeWrapper.shadowType.IsSealed && (m.Modifiers & MapXml.MapModifiers.Static) == 0)
						{
							// skip instance methods in sealed types, but we do need to add them to the overriders
							if(typeWrapper.BaseTypeWrapper != null && (m.Modifiers & MapXml.MapModifiers.Private) == 0)
d747 2
a748 8
								RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(md, true) as RemappedMethodWrapper;
								if(baseMethod != null &&
									!baseMethod.IsFinal &&
									!baseMethod.IsPrivate &&
									(baseMethod.m.@@override != null ||
									baseMethod.m.redirect != null ||
									baseMethod.m.body != null ||
									baseMethod.m.alternateBody != null))
d750 11
a760 1
									baseMethod.overriders.Add(typeWrapper);
d763 1
a763 6
						}
						else
						{
							MethodInfo overrideMethod = null;
							MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers);
							if((m.Modifiers & MapXml.MapModifiers.Static) != 0)
d765 7
a771 6
								attr |= MethodAttributes.Static;
							}
							else if((m.Modifiers & MapXml.MapModifiers.Private) == 0 && (m.Modifiers & MapXml.MapModifiers.Final) == 0)
							{
								attr |= MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.CheckAccessOnOverride;
								if(typeWrapper.BaseTypeWrapper != null)
d773 2
a774 2
									RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(md, true) as RemappedMethodWrapper;
									if(baseMethod != null)
d776 2
a777 2
										baseMethod.overriders.Add(typeWrapper);
										if(baseMethod.m.@@override != null)
d779 2
a780 2
											overrideMethod = typeWrapper.BaseTypeWrapper.TypeAsTBD.GetMethod(baseMethod.m.@@override.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, paramTypes, null);
											if(overrideMethod == null)
d782 5
a786 1
												throw new InvalidOperationException();
d791 6
a797 7
							mbCore = typeWrapper.typeBuilder.DefineMethod(m.Name, attr, CallingConventions.Standard, retType, paramTypes);
							if(overrideMethod != null)
							{
								typeWrapper.typeBuilder.DefineMethodOverride(mbCore, overrideMethod);
							}
							AddDeclaredExceptions(mbCore, m.throws);
						}
d799 1
a799 7
						if((m.Modifiers & MapXml.MapModifiers.Static) == 0)
						{
							// instance methods must have an instancehelper method
							MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers) | MethodAttributes.Static;
							// NOTE instancehelpers for protected methods are made public,
							// because cli.System.Object derived types can call protected methods
							if((m.Modifiers & MapXml.MapModifiers.Protected) != 0)
d801 18
a818 4
								attr &= ~MethodAttributes.MemberAccessMask;
								attr |= MethodAttributes.Public;
								// mark with specialname, so that tools (hopefully) won't show them
								attr |= MethodAttributes.SpecialName;
d820 1
a820 7
							Type[] exParamTypes = new Type[paramTypes.Length + 1];
							Array.Copy(paramTypes, 0, exParamTypes, 1, paramTypes.Length);
							exParamTypes[0] = typeWrapper.shadowType;
							mbHelper = typeWrapper.typeBuilder.DefineMethod("instancehelper_" + m.Name, attr, CallingConventions.Standard, retType, exParamTypes);
							AttributeHelper.SetModifiers(mbHelper, (Modifiers)m.Modifiers);
							AttributeHelper.SetNameSig(mbHelper, m.Name, m.Sig);
							AddDeclaredExceptions(mbHelper, m.throws);
a821 1
						return mbCore;
a822 1
				}
d824 5
a828 5
				internal override void Finish()
				{
					// TODO we should insert method tracing (if enabled)
					MethodDescriptor md = this.Descriptor;
					Type[] paramTypes = this.GetParametersForDefineMethod();
d830 1
a830 1
					MethodBuilder mbCore = GetMethod() as MethodBuilder;
d832 2
a833 6
					// NOTE sealed types don't have instance methods (only instancehelpers)
					if(mbCore != null)
					{
						ILGenerator ilgen = mbCore.GetILGenerator();
						MethodInfo baseMethod = null;
						if(m.@@override != null)
d835 3
a837 2
							baseMethod = DeclaringType.TypeAsTBD.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, paramTypes, null);
							if(baseMethod == null)
d839 6
a844 1
								throw new InvalidOperationException();
d846 2
a847 8
							((TypeBuilder)DeclaringType.TypeAsBaseType).DefineMethodOverride(mbCore, baseMethod);
						}
						// TODO we need to support ghost (and other funky?) parameter types
						if(m.body != null)
						{
							// we manually walk the instruction list, because we need to special case the ret instructions
							Hashtable context = new Hashtable();
							foreach(MapXml.Instruction instr in m.body.invoke)
d849 3
a851 1
								if(instr is MapXml.Ret)
d853 5
a857 1
									this.ReturnType.EmitConvStackToParameterType(ilgen, null);
a858 18
								instr.Generate(context, ilgen);
							}
						}
						else
						{
							int thisOffset = 0;
							if((m.Modifiers & MapXml.MapModifiers.Static) == 0)
							{
								thisOffset = 1;
								ilgen.Emit(OpCodes.Ldarg_0);
							}
							for(int i = 0; i < paramTypes.Length; i++)
							{
								ilgen.Emit(OpCodes.Ldarg, (short)(i + thisOffset));
							}
							if(m.redirect != null)
							{
								EmitRedirect(DeclaringType.TypeAsTBD, ilgen);
d862 15
a876 1
								if(baseMethod == null)
d878 5
a882 1
									throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
d884 2
a885 1
								ilgen.Emit(OpCodes.Call, baseMethod);
a886 2
							this.ReturnType.EmitConvStackToParameterType(ilgen, null);
							ilgen.Emit(OpCodes.Ret);
a887 1
					}
d889 2
a890 10
					// NOTE static methods don't have helpers
					if(mbHelper != null)
					{
						ILGenerator ilgen = mbHelper.GetILGenerator();
						// check "this" for null
						if(m.@@override != null && m.redirect == null && m.body == null && m.alternateBody == null)
						{
							// we're going to be calling the overridden version, so we don't need the null check
						}
						else
d892 3
a894 27
							ilgen.Emit(OpCodes.Ldarg_0);
							EmitHelper.NullCheck(ilgen);
						}
						if(mbCore != null && 
							(m.@@override == null || m.redirect != null) &&
							(m.Modifiers & MapXml.MapModifiers.Private) == 0 && (m.Modifiers & MapXml.MapModifiers.Final) == 0)
						{
							// TODO we should have a way to supress this for overridden methods
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Isinst, DeclaringType.TypeAsBaseType);
							ilgen.Emit(OpCodes.Dup);
							Label skip = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brfalse_S, skip);
							for(int i = 0; i < paramTypes.Length; i++)
							{
								ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
							}
							ilgen.Emit(OpCodes.Callvirt, mbCore);
							this.ReturnType.EmitConvStackToParameterType(ilgen, null);
							ilgen.Emit(OpCodes.Ret);
							ilgen.MarkLabel(skip);
							ilgen.Emit(OpCodes.Pop);
						}
						foreach(RemapperTypeWrapper overrider in overriders)
						{
							RemappedMethodWrapper mw = (RemappedMethodWrapper)overrider.GetMethodWrapper(md, false);
							if(mw.m.redirect == null && mw.m.body == null && mw.m.alternateBody == null)
d896 1
a896 2
								// the overridden method doesn't actually do anything special (that means it will end
								// up calling the .NET method it overrides), so we don't need to special case this
d901 9
a909 1
								ilgen.Emit(OpCodes.Isinst, overrider.TypeAsTBD);
d917 1
a917 2
								mw.Link();
								mw.EmitCallvirt(ilgen);
d923 1
a923 7
						}
						if(m.body != null || m.alternateBody != null)
						{
							MapXml.InstructionList body = m.alternateBody == null ? m.body : m.alternateBody;
							// we manually walk the instruction list, because we need to special case the ret instructions
							Hashtable context = new Hashtable();
							foreach(MapXml.Instruction instr in body.invoke)
d925 2
a926 1
								if(instr is MapXml.Ret)
d928 16
d945 3
a948 1
								instr.Generate(context, ilgen);
d950 1
a950 5
						}
						else
						{
							Type shadowType = ((RemapperTypeWrapper)DeclaringType).shadowType;
							for(int i = 0; i < paramTypes.Length + 1; i++)
d952 11
a962 1
								ilgen.Emit(OpCodes.Ldarg, (short)i);
d964 1
a964 1
							if(m.redirect != null)
d966 34
a999 1
								EmitRedirect(shadowType, ilgen);
d1001 12
a1012 1
							else if(m.@@override != null)
d1014 1
a1014 6
								MethodInfo baseMethod = shadowType.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
								if(baseMethod == null)
								{
									throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
								}
								ilgen.Emit(OpCodes.Callvirt, baseMethod);
d1018 3
a1020 2
								RemappedMethodWrapper baseMethod = DeclaringType.BaseTypeWrapper.GetMethodWrapper(md, true) as RemappedMethodWrapper;
								if(baseMethod == null || baseMethod.m.@@override == null)
d1024 2
a1025 2
								MethodInfo overrideMethod = shadowType.GetMethod(baseMethod.m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
								if(overrideMethod == null)
d1027 1
a1027 1
									throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
d1029 2
a1030 1
								ilgen.Emit(OpCodes.Callvirt, overrideMethod);
a1031 2
							this.ReturnType.EmitConvStackToParameterType(ilgen, null);
							ilgen.Emit(OpCodes.Ret);
d1035 1
a1035 2
					// do we need a helper for non-virtual reflection invocation?
					if(m.nonvirtualAlternateBody != null || (m.@@override != null && overriders.Count > 0))
d1037 14
a1050 7
						RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)DeclaringType;
						Type[] argTypes = new Type[paramTypes.Length + 1];
						argTypes[0] = typeWrapper.TypeAsParameterType;
						this.GetParametersForDefineMethod().CopyTo(argTypes, 1);
						MethodBuilder mb = typeWrapper.typeBuilder.DefineMethod("nonvirtualhelper/" + this.Name, MethodAttributes.Private | MethodAttributes.Static, this.ReturnTypeForDefineMethod, argTypes);
						ILGenerator ilgen = mb.GetILGenerator();
						if(m.nonvirtualAlternateBody != null)
d1052 9
a1060 1
							m.nonvirtualAlternateBody.Emit(ilgen);
d1064 3
a1066 3
							Type shadowType = ((RemapperTypeWrapper)DeclaringType).shadowType;
							MethodInfo baseMethod = shadowType.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
							if(baseMethod == null)
d1068 90
a1157 1
								throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
d1159 1
a1159 2
							ilgen.Emit(OpCodes.Ldarg_0);
							for(int i = 0; i < paramTypes.Length; i++)
d1161 3
a1163 1
								ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
a1164 2
							ilgen.Emit(OpCodes.Call, baseMethod);
							ilgen.Emit(OpCodes.Ret);
d1169 1
a1169 1
				private void EmitRedirect(Type baseType, ILGenerator ilgen)
d1171 1
a1171 3
					string redirName = m.redirect.Name;
					string redirSig = m.redirect.Sig;
					if(redirName == null)
d1173 1
a1173 1
						redirName = m.Name;
d1175 5
a1179 1
					if(redirSig == null)
d1181 1
a1181 1
						redirSig = m.Sig;
d1183 2
a1184 4
					ClassLoaderWrapper classLoader = ClassLoaderWrapper.GetBootstrapClassLoader();
					MethodDescriptor redir = new MethodDescriptor(redirName, redirSig);
					// HACK if the class name contains a comma, we assume it is a .NET type
					if(m.redirect.Class == null || m.redirect.Class.IndexOf(',') >= 0)
d1186 4
a1189 9
						// TODO better error handling
						Type type = m.redirect.Class == null ? baseType : Type.GetType(m.redirect.Class, true);
						Type[] redirParamTypes = classLoader.ArgTypeListFromSig(redirSig);
						MethodInfo mi = type.GetMethod(m.redirect.Name, redirParamTypes);
						if(mi == null)
						{
							throw new InvalidOperationException();
						}
						ilgen.Emit(OpCodes.Call, mi);
d1191 4
a1194 1
					else
d1196 1
a1196 3
						TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(m.redirect.Class);
						MethodWrapper mw = tw.GetMethodWrapper(redir, false);
						if(mw == null)
d1198 1
a1198 1
							throw new InvalidOperationException("Missing redirect method: " + tw.Name + "." + redir.Name + redir.Signature);
a1199 2
						mw.Link();
						mw.EmitCall(ilgen);
d1201 3
a1203 1
					if(!classLoader.RetTypeWrapperFromSig(redirSig).IsAssignableTo(this.ReturnType))
d1205 1
a1205 4
						// NOTE we're passing a null context, this is safe because the return type
						// should always be loadable
						System.Diagnostics.Debug.Assert(!this.ReturnType.IsUnloadable);
						this.ReturnType.EmitCheckcast(null, ilgen);
a1207 1
			}
d1209 4
a1212 5
			internal void Process2ndPass(MapXml.Root map)
			{
				MapXml.Class c = classDef;
				TypeBuilder tb = typeBuilder;
				bool baseIsSealed = shadowType.IsSealed;
d1214 1
a1214 1
				if(c.Interfaces != null)
d1216 1
a1216 2
					interfaceWrappers = new TypeWrapper[c.Interfaces.Length];
					for(int i = 0; i < c.Interfaces.Length; i++)
d1218 2
a1219 6
						TypeWrapper ifaceTypeWrapper = ClassLoaderWrapper.LoadClassCritical(c.Interfaces[i].Name);
						interfaceWrappers[i] = ifaceTypeWrapper;
						if(!baseIsSealed)
						{
							tb.AddInterfaceImplementation(ifaceTypeWrapper.TypeAsBaseType);
						}
a1220 1
					AttributeHelper.SetImplementsAttribute(tb, interfaceWrappers);
d1222 6
a1227 1
				else
d1229 2
a1230 1
					interfaceWrappers = TypeWrapper.EmptyArray;
d1233 1
a1233 2
				// TODO fields should be moved to the RemapperTypeWrapper constructor as well
				if(c.Fields != null)
d1235 1
a1235 1
					foreach(MapXml.Field f in c.Fields)
d1237 1
a1237 52
						if(f.redirect != null)
						{
							TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(f.redirect.Class);
							MethodDescriptor redir = new MethodDescriptor(f.redirect.Name, f.redirect.Sig);
							MethodWrapper method = tw.GetMethodWrapper(redir, false);
							if(method == null || !method.IsStatic)
							{
								// TODO better error handling
								throw new InvalidOperationException("remapping field: " + f.Name + f.Sig + " not found");
							}
							// TODO emit an static helper method that enables access to the field at runtime
							method.Link();
							AddField(FieldWrapper.Create1(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, null, CodeEmitter.WrapCall(method), CodeEmitter.InternalError));
						}
						else if((f.Modifiers & MapXml.MapModifiers.Static) != 0)
						{
							FieldAttributes attr = MapFieldAccessModifiers(f.Modifiers) | FieldAttributes.Static;
							if(f.Constant != null)
							{
								attr |= FieldAttributes.Literal;
							}
							else if((f.Modifiers & MapXml.MapModifiers.Final) != 0)
							{
								attr |= FieldAttributes.InitOnly;
							}
							FieldBuilder fb = tb.DefineField(f.Name, GetClassLoader().FieldTypeWrapperFromSig(f.Sig).TypeAsFieldType, attr);
							object constant;
							if(f.Constant != null)
							{
								switch(f.Sig[0])
								{
									case 'J':
										constant = long.Parse(f.Constant);
										break;
									default:
										// TODO support other types
										throw new NotImplementedException("remapped constant field of type: " + f.Sig);
								}
								fb.SetConstant(constant);
								AddField(new FieldWrapper.ConstantFieldWrapper(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, fb, constant));
							}
							else
							{
								AddField(FieldWrapper.Create3(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), fb, f.Sig, (Modifiers)f.Modifiers));
							}
						}
						else
						{
							// TODO we should support adding arbitrary instance fields (the runtime will have to use
							// a weak identity hashtable to store the extra information for subclasses that don't extend our stub)
							throw new NotImplementedException(this.Name + "." + f.Name + f.Sig);
						}
a1239 1
			}
d1241 1
a1241 3
			internal void Process3rdPass()
			{
				foreach(RemappedMethodBaseWrapper m in GetMethods())
d1243 4
a1246 1
					m.Link();
a1247 1
			}
d1249 1
a1249 3
			internal void Process4thPass()
			{
				foreach(RemappedMethodBaseWrapper m in GetMethods())
d1251 4
a1254 1
					m.Finish();
d1257 1
a1257 1
				if(classDef.Clinit != null)
d1259 4
a1262 4
					ConstructorBuilder cb = typeBuilder.DefineTypeInitializer();
					ILGenerator ilgen = cb.GetILGenerator();
					// TODO emit code to make sure super class is initialized
					classDef.Clinit.body.Emit(ilgen);
d1265 1
a1265 3
				// FXBUG because the AppDomain.TypeResolve event doesn't work correctly for inner classes,
				// we need to explicitly finish the interface we implement (if they are ghosts, we need the nested __Interface type)
				if(classDef.Interfaces != null)
d1267 1
a1267 1
					foreach(MapXml.Interface iface in classDef.Interfaces)
d1269 1
a1269 1
						GetClassLoader().LoadClassByDottedName(iface.Name).Finish();
d1273 1
a1273 2
				typeBuilder.CreateType();
				if(helperTypeBuilder != null)
d1275 5
a1279 1
					helperTypeBuilder.CreateType();
d1283 1
a1283 1
			internal override MethodBase LinkMethod(MethodWrapper mw)
d1285 1
a1285 2
				return ((RemappedMethodBaseWrapper)mw).DoLink();
			}
d1287 2
a1288 3
			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
d1290 4
a1293 2
					// at the moment we don't support nested remapped types
					return null;
a1294 1
			}
d1296 1
a1296 9
			internal override void Finish(bool forDebugSave)
			{
			}

			protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
			{
				// we don't resolve fields lazily
				return null;
			}
d1298 2
a1299 3
			internal override TypeWrapper[] InnerClasses
			{
				get
d1301 5
a1305 1
					return null;
d1309 1
a1309 1
			internal override TypeWrapper[] Interfaces
d1311 4
a1314 1
				get
d1316 1
a1316 1
					return interfaceWrappers;
d1318 2
a1319 5
			}

			internal override Type TypeAsTBD
			{
				get
d1321 1
a1321 1
					return shadowType;
d1324 1
d1326 6
a1331 1
			internal override Type TypeAsBaseType
d1333 1
a1333 1
				get
d1335 7
a1341 1
					return typeBuilder;
d1343 1
a1343 5
			}

			internal override TypeBuilder TypeAsBuilder
			{
				get
d1345 2
a1346 1
					return typeBuilder;
d1349 3
a1351 2

			internal override bool IsMapUnsafeException
d1353 2
a1354 1
				get
d1356 1
a1356 2
					// any remapped exceptions are automatically unsafe
					return shadowType == typeof(Exception) || shadowType.IsSubclassOf(typeof(Exception));
d1358 1
a1358 11
			}
		}

		internal void EmitRemappedTypes(MapXml.Root map)
		{
			Tracer.Info(Tracer.Compiler, "Emit remapped types");

			// 1st pass, put all types in remapped to make them loadable
			foreach(MapXml.Class c in map.assembly)
			{
				if(c.Shadows != null)
d1360 2
a1361 1
					remapped.Add(c.Name, new RemapperTypeWrapper(this, c, map));
d1363 1
a1363 8
			}

			DynamicTypeWrapper.SetupGhosts(map);

			// 2nd pass, resolve interfaces, publish methods/fields
			foreach(MapXml.Class c in map.assembly)
			{
				if(c.Shadows != null)
d1365 2
a1366 2
					RemapperTypeWrapper typeWrapper = (RemapperTypeWrapper)remapped[c.Name];
					typeWrapper.Process2ndPass(map);
d1368 3
a1370 31
			}
		}

		internal void FinishRemappedTypes()
		{
			// 3rd pass, link the methods. Note that a side effect of the linking is the
			// twiddling with the overriders array in the base methods, so we need to do this
			// as a separate pass before we compile the methods
			foreach(RemapperTypeWrapper typeWrapper in remapped.Values)
			{
				typeWrapper.Process3rdPass();
			}
			// 4th pass, implement methods/fields and bake the type
			foreach(RemapperTypeWrapper typeWrapper in remapped.Values)
			{
				typeWrapper.Process4thPass();
			}
		}
	}

	public static void Compile(string path, string keyfilename, string version, bool targetIsModule, string assembly, string mainClass, ApartmentState apartment, PEFileKinds target, bool guessFileKind, byte[][] classes, string[] references, bool nojni, Hashtable resources, string[] classesToExclude, string remapfile)
	{
		Tracer.Info(Tracer.Compiler, "JVM.Compile path: {0}, assembly: {1}", path, assembly);
		isStaticCompiler = true;
		noJniStubs = nojni;
		foreach(string r in references)
		{
			try
			{
				Assembly reference = Assembly.LoadFrom(r);
				if(reference == null)
d1372 5
a1376 2
					Console.Error.WriteLine("Error: reference not found: {0}", r);
					return;
d1378 1
a1378 32
				Tracer.Info(Tracer.Compiler, "Loaded reference assembly: {0}", reference.FullName);
			}
			catch(Exception x)
			{
				Console.Error.WriteLine("Error: invalid reference: {0} ({1})", r, x.Message);
				return;
			}
		}
		Hashtable h = new Hashtable();
		Tracer.Info(Tracer.Compiler, "Parsing class files");
		for(int i = 0; i < classes.Length; i++)
		{
			ClassFile f;
			try
			{
				f = new ClassFile(classes[i], 0, classes[i].Length, null, true);
			}
			catch(UnsupportedClassVersionError x)
			{
				Console.Error.WriteLine("Error: unsupported class file version: {0}", x.Message);
				return;
			}
			catch(ClassFormatError x)
			{
				Console.Error.WriteLine("Error: invalid class file: {0}", x.Message);
				return;
			}
			string name = f.Name;
			bool excluded = false;
			for(int j = 0; j < classesToExclude.Length; j++)
			{
				if(Regex.IsMatch(name, classesToExclude[j]))
d1380 1
a1381 1
					break;
d1383 1
a1383 10
			}
			if(h.ContainsKey(name))
			{
				Console.Error.WriteLine("Warning: duplicate class name: {0}", name);
				excluded = true;
			}
			if(!excluded)
			{
				h[name] = f;
				if(mainClass == null && (guessFileKind || target != PEFileKinds.Dll))
d1385 2
a1386 1
					foreach(ClassFile.Method m in f.Methods)
d1388 1
a1388 1
						if(m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V")
d1390 6
a1395 3
							Console.Error.WriteLine("Note: found main method in class: {0}", f.Name);
							mainClass = f.Name;
							break;
a1399 1
		}
d1401 4
a1404 4
		if(guessFileKind && mainClass == null)
		{
			target = PEFileKinds.Dll;
		}
d1406 5
a1410 5
		if(target == PEFileKinds.Dll && mainClass != null)
		{
			Console.Error.WriteLine("Error: main class cannot be specified for library or module");
			return;
		}
d1412 5
a1416 5
		if(target != PEFileKinds.Dll && mainClass == null)
		{
			Console.Error.WriteLine("Error: no main method found");
			return;
		}
d1418 1
a1418 3
		if(path == null)
		{
			if(target == PEFileKinds.Dll)
d1420 1
a1420 1
				if(targetIsModule)
d1422 8
a1429 1
					path = assembly + ".netmodule";
d1433 1
a1433 1
					path = assembly + ".dll";
d1435 1
d1437 2
a1438 1
			else
d1440 2
a1441 1
				path = assembly + ".exe";
a1442 2
			Console.Error.WriteLine("Note: output file is: {0}", path);
		}
d1444 5
a1448 5
		if(targetIsModule)
		{
			// TODO if we're overwriting a user specified assembly name, we need to emit a warning
			assembly = new FileInfo(path).Name;
		}
d1450 5
a1454 11
		if(target == PEFileKinds.Dll && !path.ToLower().EndsWith(".dll") && !targetIsModule)
		{
			Console.Error.WriteLine("Error: library output file must end with .dll");
			return;
		}

		if(target != PEFileKinds.Dll && !path.ToLower().EndsWith(".exe"))
		{
			Console.Error.WriteLine("Error: executable output file must end with .exe");
			return;
		}
d1456 4
a1459 7
		// make sure all inner classes have a reference to their outer class
		// note that you cannot use the InnerClasses attribute in the inner class for this, because
		// anonymous inner classes do not have a reference to their outer class
		foreach(ClassFile classFile in h.Values)
		{
			// don't handle inner classes for ikvmstub types
			if(classFile.IKVMAssemblyAttribute == null)
d1461 2
a1462 2
				ClassFile.InnerClass[] innerClasses = classFile.InnerClasses;
				if(innerClasses != null)
d1464 2
a1465 1
					for(int j = 0; j < innerClasses.Length; j++)
d1467 1
a1467 1
						if(innerClasses[j].outerClass != 0 && classFile.GetConstantPoolClass(innerClasses[j].outerClass) == classFile.Name)
d1469 1
a1469 3
							string inner = classFile.GetConstantPoolClass(innerClasses[j].innerClass);
							ClassFile innerClass = (ClassFile)h[inner];
							if(innerClass != null)
d1471 12
a1482 1
								if(innerClass.OuterClass != null)
d1484 1
a1484 2
									Console.Error.WriteLine("Error: inner class {0} has multiple outer classes", inner);
									return;
a1485 5
								innerClass.OuterClass = classFile;
							}
							else
							{
								Console.Error.WriteLine("Warning: inner class {0} missing", inner);
a1490 1
		}
d1492 6
a1497 36
		Tracer.Info(Tracer.Compiler, "Constructing compiler");
		CompilerClassLoader loader = new CompilerClassLoader(path, keyfilename, version, targetIsModule, assembly, h);
		ClassLoaderWrapper.SetBootstrapClassLoader(loader);
		compilationPhase1 = true;
		MapXml.Root map = null;
		if(remapfile != null)
		{
			Tracer.Info(Tracer.Compiler, "Loading remapped types (1) from {0}", remapfile);
			System.Xml.Serialization.XmlSerializer ser = new System.Xml.Serialization.XmlSerializer(typeof(MapXml.Root));
			ser.UnknownElement += new System.Xml.Serialization.XmlElementEventHandler(ser_UnknownElement);
			using(FileStream fs = File.Open(remapfile, FileMode.Open))
			{
				map = (MapXml.Root)ser.Deserialize(fs);
			}
			loader.EmitRemappedTypes(map);
		}
		// Do a sanity check to make sure some of the bootstrap classes are available
		if(loader.LoadClassByDottedNameFast("java.lang.Object") == null)
		{
			Assembly classpath = Assembly.LoadWithPartialName("IKVM.GNU.Classpath");
			if(classpath == null)
			{
				Console.Error.WriteLine("Error: bootstrap classes missing and IKVM.GNU.Classpath.dll not found");
				return;
			}
			Console.Error.WriteLine("Warning: bootstrap classes are missing, automatically adding reference to {0}", classpath.Location);
			Console.Error.WriteLine("  (to avoid this warning add \"-reference:{0}\" to the command line)", classpath.Location);
			// we need to scan again for remapped types, now that we've loaded the core library
			ClassLoaderWrapper.LoadRemappedTypes();
		}
		Tracer.Info(Tracer.Compiler, "Compiling class files (1)");
		ArrayList allwrappers = new ArrayList();
		foreach(string s in h.Keys)
		{
			TypeWrapper wrapper = null;
			try
d1499 4
a1502 7
				wrapper = loader.LoadClassByDottedNameFast(s);
				if(wrapper == null)
				{
					// this should only happen for netexp types (because the other classes must exist, after all we just parsed them)
					Console.Error.WriteLine("Class not found: {0}", s);
				}
				else
d1504 1
a1504 1
					allwrappers.Add(wrapper);
d1506 1
d1508 2
a1509 1
			catch(Exception x)
d1511 2
a1512 7
				Console.Error.WriteLine("Loading class {0} failed due to:", s);
				Console.Error.WriteLine(x);
			}
			if(s == mainClass && wrapper != null)
			{
				MethodWrapper mw = wrapper.GetMethodWrapper(new MethodDescriptor("main", "([Ljava.lang.String;)V"), false);
				if(mw == null)
d1514 1
a1514 1
					Console.Error.WriteLine("Error: main method not found");
d1517 11
a1527 3
				mw.Link();
				MethodBuilder method = mw.GetMethod() as MethodBuilder;
				if(method == null)
d1529 10
a1538 2
					Console.Error.WriteLine("Error: redirected main method not supported");
					return;
d1540 1
a1540 2
				Type apartmentAttributeType = null;
				if(apartment == ApartmentState.STA)
d1542 2
a1543 1
					apartmentAttributeType = typeof(STAThreadAttribute);
d1545 1
a1545 1
				else if(apartment == ApartmentState.MTA)
d1547 28
a1574 1
					apartmentAttributeType = typeof(MTAThreadAttribute);
d1576 14
a1589 1
				if(apartmentAttributeType != null)
d1591 4
a1594 1
					method.SetCustomAttribute(new CustomAttributeBuilder(apartmentAttributeType.GetConstructor(Type.EmptyTypes), new object[0]));
d1596 3
a1598 2
				loader.SetMain(method, target);
				mainClass = null;
d1600 3
d1604 2
a1605 1
		if(mainClass != null)
d1607 1
a1607 2
			Console.Error.WriteLine("Error: main class not found");
			return;
d1609 2
a1610 2
		compilationPhase1 = false;
		if(map != null)
d1612 1
a1612 14
			DynamicTypeWrapper.LoadMappedExceptions(map);
			// mark all exceptions that are unsafe for mapping with a custom attribute,
			// so that at runtime we can quickly assertain if an exception type can be
			// caught without filtering
			foreach(TypeWrapper tw in allwrappers)
			{
				if(!tw.IsInterface && tw.IsMapUnsafeException)
				{
					tw.TypeAsBuilder.SetCustomAttribute(typeof(ExceptionIsUnsafeForMappingAttribute).GetConstructor(Type.EmptyTypes), new byte[0]);
				}
			}
			DynamicTypeWrapper.LoadNativeMethods(map);
			Tracer.Info(Tracer.Compiler, "Loading remapped types (2)");
			loader.FinishRemappedTypes();
a1613 4
		Tracer.Info(Tracer.Compiler, "Compiling class files (2)");
		loader.AddResources(resources);
		loader.Save();
	}
d1615 4
a1618 14
	public static void PrepareForSaveDebugImage()
	{
		ClassLoaderWrapper.PrepareForSaveDebugImage();
	}
	
	public static void SaveDebugImage(object mainClass)
	{
		ClassLoaderWrapper.SaveDebugImage(mainClass);
	}

	public static void SetBootstrapClassLoader(object classLoader)
	{
		ClassLoaderWrapper.GetBootstrapClassLoader().SetJavaClassLoader(classLoader);
	}
d1620 1
a1620 3
	internal static void CriticalFailure(string message, Exception x)
	{
		try
d1622 1
a1622 18
			Tracer.Error(Tracer.Runtime, "CRITICAL FAILURE: {0}", message);
			// NOTE we use reflection to invoke MessageBox.Show, to make sure we run on Mono as well
			Assembly winForms = IsUnix ? null : Assembly.LoadWithPartialName("System.Windows.Forms");
			Type messageBox = null;
			if(winForms != null)
			{
				messageBox = winForms.GetType("System.Windows.Forms.MessageBox");
			}
			message = String.Format("****** Critical Failure: {1} ******{0}" +
				"{2}{0}" + 
				"{3}{0}" +
				"{4}",
				Environment.NewLine,
				message,
				x,
				x != null ? new StackTrace(x, true).ToString() : "",
				new StackTrace(true));
			if(messageBox != null)
d1624 18
a1641 1
				try
d1643 8
a1650 1
					messageBox.InvokeMember("Show", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.Public, null, null, new object[] { message, "IKVM.NET Critical Failure" });
d1652 1
a1652 1
				catch
d1657 1
a1657 1
			else
d1659 5
a1663 1
				Console.Error.WriteLine(message);
d1666 2
a1667 5
		catch(Exception ex)
		{
			Console.Error.WriteLine(ex);
		}
		finally
d1669 2
a1670 1
			Environment.Exit(666);
a1672 6

	private static void ser_UnknownElement(object sender, System.Xml.Serialization.XmlElementEventArgs e)
	{
		Console.Error.WriteLine("Unknown element {0} in XML mapping file, line {1}, column {2}", e.Element.Name, e.LineNumber, e.LinePosition);
		Environment.Exit(1);
	}
@


1.9
log
@*** empty log message ***
@
text
@d25 1
d110 26
d260 1
a260 1
					IResourceWriter writer = moduleBuilder.DefineResource("ikvm:" + d.Key, "");
d1322 1
a1322 1
	public static void Compile(string path, string keyfilename, string version, bool targetIsModule, string assembly, string mainClass, PEFileKinds target, bool guessFileKind, byte[][] classes, string[] references, bool nojni, Hashtable resources, string[] classesToExclude, string remapfile)
d1550 1
a1550 1
				MethodInfo method = mw.GetMethod() as MethodInfo;
d1556 13
@


1.8
log
@*** empty log message ***
@
text
@a38 1
	private static IJniProvider jniProvider;
a109 32
	public static IJniProvider JniProvider
	{
		get
		{
			if(jniProvider == null)
			{
				Type provider;
				string providerAssembly = Environment.GetEnvironmentVariable("IKVM_JNI_PROVIDER");
				if(providerAssembly != null)
				{
					Tracer.Info(Tracer.Runtime, "Loading environment specified JNI provider: {0}", providerAssembly);
					provider = Assembly.LoadFrom(providerAssembly).GetType("JNI", true);
				}
				else
				{
					if(IsUnix)
					{
						Tracer.Info(Tracer.Runtime, "Loading JNI provider: IKVM.JNI.Mono");
						provider = Assembly.LoadWithPartialName("IKVM.JNI.Mono").GetType("JNI", true);
					}
					else
					{
						Tracer.Info(Tracer.Runtime, "Loading JNI provider: IKVM.JNI.CLR-Win32");
						provider = Assembly.LoadWithPartialName("IKVM.JNI.CLR-Win32").GetType("JNI", true);
					}
				}
				jniProvider = (IJniProvider)Activator.CreateInstance(provider);
			}
			return jniProvider;
		}
	}

d1325 1
a1325 1
				f = new ClassFile(classes[i], 0, classes[i].Length, null);
@


1.7
log
@*** empty log message ***
@
text
@d208 1
a208 1
					// classes, to handle the case where the netexp type doesn't exist
d210 1
a210 1
					string netexp = f.NetExpAssemblyAttribute;
d221 2
a222 1
						if(DotNetTypeWrapper.LoadDotNetTypeWrapper(name) == null)
a303 45
		private static void EmitRedirect(Type baseType, MethodDescriptor md, MapXml.Method m, ILGenerator ilgen)
		{
			string redirName = m.redirect.Name;
			string redirSig = m.redirect.Sig;
			if(redirName == null)
			{
				redirName = m.Name;
			}
			if(redirSig == null)
			{
				redirSig = m.Sig;
			}
			MethodDescriptor redir = MethodDescriptor.FromNameSig(ClassLoaderWrapper.GetBootstrapClassLoader(), redirName, redirSig);
			// HACK if the class name contains a comma, we assume it is a .NET type
			if(m.redirect.Class == null || m.redirect.Class.IndexOf(',') >= 0)
			{
				// TODO better error handling
				Type type = m.redirect.Class == null ? baseType : Type.GetType(m.redirect.Class, true);
				Type[] redirParamTypes = redir.ArgTypesForDefineMethod;
				MethodInfo mi = type.GetMethod(m.redirect.Name, redirParamTypes);
				if(mi == null)
				{
					throw new InvalidOperationException();
				}
				ilgen.Emit(OpCodes.Call, mi);
			}
			else
			{
				TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(m.redirect.Class);
				MethodWrapper mw = tw.GetMethodWrapper(redir, false);
				if(mw == null)
				{
					throw new InvalidOperationException("Missing redirect method: " + tw.Name + "." + redir.Name + redir.Signature);
				}
				mw.EmitCall.Emit(ilgen);
			}
			if(!redir.RetTypeWrapper.IsAssignableTo(md.RetTypeWrapper))
			{
				// NOTE we're passing a null context, this is safe because the return type
				// should always be loadable
				System.Diagnostics.Debug.Assert(!md.RetTypeWrapper.IsUnloadable);
				md.RetTypeWrapper.EmitCheckcast(null, ilgen);
			}
		}

d312 8
d343 1
a343 1
			internal RemapperTypeWrapper(CompilerClassLoader classLoader, MapXml.Class c)
d397 1
a397 1
					// work in this case (to attribute is emitted at all). So we work around by emitting a string instead
d403 1
a403 1
					AttributeHelper.HideFromReflection(typeBuilder);
d417 42
d461 1
a461 1
			class RemappedMethodWrapper : MethodWrapper
d463 1
a463 2
				private MapXml.Method xmlMethod;
				private MethodBuilder mbCore;
a464 5
				private MapXml.Constructor xmlConstructor;
				private ConstructorBuilder cbCore;
				private MethodBuilder cbHelper;
				private MethodInfo interfaceMethod;
				private ArrayList overriders = new ArrayList();
d466 7
a472 2
				private RemappedMethodWrapper(TypeWrapper typeWrapper, MethodDescriptor md, MethodBuilder mbCore, MethodBuilder mbHelper, Modifiers modifiers, MapXml.Method m)
					: base(typeWrapper, md, mbCore, modifiers, false)
d474 2
a475 3
					this.xmlMethod = m;
					this.mbCore = mbCore;
					this.mbHelper = mbHelper;
d477 3
a479 2
					this.EmitNewobj = CodeEmitter.InternalError;
					if(mbCore != null)
d481 1
a481 1
						this.EmitCall = CodeEmitter.Create(OpCodes.Call, mbCore);
d485 1
a485 1
						this.EmitCall = CodeEmitter.InternalError;
d487 12
a498 1
					if(mbHelper != null)
d500 4
a503 1
						this.EmitCallvirt = CodeEmitter.Create(OpCodes.Call, mbHelper);
d507 2
a508 1
						this.EmitCallvirt = CodeEmitter.InternalError;
d510 1
d512 4
d517 3
a519 6
				private RemappedMethodWrapper(RemapperTypeWrapper typeWrapper, MethodDescriptor md, ConstructorBuilder cbCore, MethodBuilder cbHelper, Modifiers modifiers, MapXml.Constructor m)
					: base(typeWrapper, md, cbCore, modifiers, false)
				{
					this.xmlConstructor = m;
					this.cbCore = cbCore;
					this.cbHelper = cbHelper;
d521 1
a521 2
					this.EmitCallvirt = CodeEmitter.InternalError;
					if(typeWrapper.shadowType.IsSealed)
d523 30
a552 2
						this.EmitCall = CodeEmitter.InternalError;
						this.EmitNewobj = CodeEmitter.Create(OpCodes.Call, cbHelper);
d554 2
a555 1
					else
d557 62
a618 2
						this.EmitCall = CodeEmitter.Create(OpCodes.Call, cbCore);
						this.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, cbCore);
d621 8
d630 2
a631 2
				private RemappedMethodWrapper(RemapperTypeWrapper typeWrapper, MethodDescriptor md, MethodInfo interfaceMethod, Modifiers modifiers)
					: base(typeWrapper, md, interfaceMethod, modifiers, false)
d633 2
a634 4
					this.interfaceMethod = interfaceMethod;
					this.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, interfaceMethod);
					this.EmitCall = CodeEmitter.InternalError;
					this.EmitNewobj = CodeEmitter.InternalError;
d637 1
a637 1
				internal static RemappedMethodWrapper Create(RemapperTypeWrapper typeWrapper, MapXml.Constructor m, MapXml.Root map)
d639 2
a640 5
					ConstructorBuilder cbCore = null;
					MethodBuilder cbHelper = null;
					MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers);
					MethodDescriptor md = MethodDescriptor.FromNameSig(typeWrapper.GetClassLoader(), "<init>", m.Sig);
					Type[] paramTypes = md.ArgTypesForDefineMethod;
d642 3
a644 1
					if(typeWrapper.shadowType.IsSealed)
d646 1
a646 2
						cbHelper = typeWrapper.typeBuilder.DefineMethod("newhelper", attr | MethodAttributes.Static, CallingConventions.Standard, typeWrapper.shadowType, paramTypes);
						AddDeclaredExceptions(cbHelper, m.throws);
d650 1
a650 2
						cbCore = typeWrapper.typeBuilder.DefineConstructor(attr, CallingConventions.Standard, paramTypes);
						AddDeclaredExceptions(cbCore, m.throws);
a651 1
					return new RemappedMethodWrapper(typeWrapper, md, cbCore, cbHelper, (Modifiers)m.Modifiers, m);
d654 1
a654 1
				internal static RemappedMethodWrapper Create(RemapperTypeWrapper typeWrapper, MapXml.Method m, MapXml.Root map)
d656 2
a657 1
					MethodDescriptor md = MethodDescriptor.FromNameSig(typeWrapper.GetClassLoader(), m.Name, m.Sig);
d665 1
a665 1
						MethodInfo interfaceMethod = typeWrapper.shadowType.GetMethod(m.@@override.Name, md.ArgTypesForDefineMethod);
d698 1
a698 1
						RemappedMethodWrapper methodWrapper = new RemappedMethodWrapper(typeWrapper, md, interfaceMethod, (Modifiers)m.Modifiers);
d701 1
a701 1
							Type[] temp = md.ArgTypesForDefineMethod;
d710 1
a710 1
							MethodBuilder helper = typeWrapper.helperTypeBuilder.DefineMethod(m.Name, MethodAttributes.Public | MethodAttributes.Static, md.RetTypeForDefineMethod, argTypes);
d724 3
a726 1
								tw.GetMethodWrapper(md, false).EmitCallvirt.Emit(ilgen);
d735 1
a735 1
							methodWrapper.EmitCallvirt.Emit(ilgen);
a736 1
							methodWrapper.EmitCallvirt = CodeEmitter.Create(OpCodes.Call, helper);
d738 2
a739 1
						return methodWrapper;
d741 5
d747 1
a747 9
					MethodBuilder mbCore = null;
					MethodBuilder mbHelper = null;
					Type[] paramTypes = md.ArgTypesForDefineMethod;
					Type retType = md.RetTypeForDefineMethod;

					if(typeWrapper.shadowType.IsSealed && (m.Modifiers & MapXml.MapModifiers.Static) == 0)
					{
						// skip instance methods in sealed types, but we do need to add them to the overriders
						if(typeWrapper.BaseTypeWrapper != null && (m.Modifiers & MapXml.MapModifiers.Private) == 0)
d749 2
a750 8
							RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(md, true) as RemappedMethodWrapper;
							if(baseMethod != null &&
								!baseMethod.IsFinal &&
								!baseMethod.IsPrivate &&
								(baseMethod.xmlMethod.@@override != null ||
								baseMethod.xmlMethod.redirect != null ||
								baseMethod.xmlMethod.body != null ||
								baseMethod.xmlMethod.alternateBody != null))
d752 11
a762 1
								baseMethod.overriders.Add(typeWrapper);
d765 1
a765 6
					}
					else
					{
						MethodInfo overrideMethod = null;
						MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers);
						if((m.Modifiers & MapXml.MapModifiers.Static) != 0)
d767 7
a773 6
							attr |= MethodAttributes.Static;
						}
						else if((m.Modifiers & MapXml.MapModifiers.Private) == 0 && (m.Modifiers & MapXml.MapModifiers.Final) == 0)
						{
							attr |= MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.CheckAccessOnOverride;
							if(typeWrapper.BaseTypeWrapper != null)
d775 2
a776 2
								RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(md, true) as RemappedMethodWrapper;
								if(baseMethod != null)
d778 2
a779 2
									baseMethod.overriders.Add(typeWrapper);
									if(baseMethod.xmlMethod.@@override != null)
d781 2
a782 2
										overrideMethod = typeWrapper.BaseTypeWrapper.TypeAsTBD.GetMethod(baseMethod.xmlMethod.@@override.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, paramTypes, null);
										if(overrideMethod == null)
d784 5
a788 1
											throw new InvalidOperationException();
d793 6
a799 7
						mbCore = typeWrapper.typeBuilder.DefineMethod(m.Name, attr, CallingConventions.Standard, retType, paramTypes);
						if(overrideMethod != null)
						{
							typeWrapper.typeBuilder.DefineMethodOverride(mbCore, overrideMethod);
						}
						AddDeclaredExceptions(mbCore, m.throws);
					}
d801 1
a801 7
					if((m.Modifiers & MapXml.MapModifiers.Static) == 0)
					{
						// instance methods must have an instancehelper method
						MethodAttributes attr = MapMethodAccessModifiers(m.Modifiers) | MethodAttributes.Static;
						// NOTE instancehelpers for protected methods are made public,
						// because cli.System.Object derived types can call protected methods
						if((m.Modifiers & MapXml.MapModifiers.Protected) != 0)
d803 18
a820 23
							attr &= ~MethodAttributes.MemberAccessMask;
							attr |= MethodAttributes.Public;
							// mark with specialname, so that tools (hopefully) won't show them
							attr |= MethodAttributes.SpecialName;
						}
						Type[] exParamTypes = new Type[paramTypes.Length + 1];
						Array.Copy(paramTypes, 0, exParamTypes, 1, paramTypes.Length);
						exParamTypes[0] = typeWrapper.shadowType;
						mbHelper = typeWrapper.typeBuilder.DefineMethod("instancehelper_" + m.Name, attr, CallingConventions.Standard, retType, exParamTypes);
						AddDeclaredExceptions(mbHelper, m.throws);
					}

					return new RemappedMethodWrapper(typeWrapper, md, mbCore, mbHelper, (Modifiers)m.Modifiers, m);
				}

				private static void AddDeclaredExceptions(MethodBase mb, MapXml.Throws[] throws)
				{
					if(throws != null)
					{
						string[] exceptions = new string[throws.Length];
						for(int i = 0; i < exceptions.Length; i++)
						{
							exceptions[i] = throws[i].Class;
d822 1
a822 1
						AttributeHelper.SetThrowsAttribute(mb, exceptions);
d826 1
a826 1
				internal void Finish()
d829 2
a830 3
					if(xmlConstructor != null)
					{
						System.Diagnostics.Debug.Assert(xmlMethod == null);
d832 1
a832 2
						MapXml.Constructor m = xmlConstructor;
						Type[] paramTypes = this.Descriptor.ArgTypesForDefineMethod;
d834 6
a839 1
						if(cbCore != null)
d841 2
a842 3
							ILGenerator ilgen = cbCore.GetILGenerator();
							// TODO we need to support ghost (and other funky?) parameter types
							if(m.body != null)
d844 1
a844 2
								// TODO do we need return type conversion here?
								m.body.Emit(ilgen);
d846 8
a853 1
							else
d855 1
a855 10
								ilgen.Emit(OpCodes.Ldarg_0);
								for(int i = 0; i < paramTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
								}
								if(m.redirect != null)
								{
									throw new NotImplementedException();
								}
								else
d857 1
a857 7
									ConstructorInfo baseCon = DeclaringType.TypeAsTBD.GetConstructor(paramTypes);
									if(baseCon == null)
									{
										// TODO better error handling
										throw new InvalidOperationException("base class constructor not found: " + DeclaringType.Name + ".<init>" + m.Sig);
									}
									ilgen.Emit(OpCodes.Call, baseCon);
d859 1
a859 1
								ilgen.Emit(OpCodes.Ret);
d862 1
a862 2

						if(cbHelper != null)
d864 2
a865 2
							ILGenerator ilgen = cbHelper.GetILGenerator();
							if(m.redirect != null)
d867 2
a868 33
								if(m.redirect.Type != "static" || m.redirect.Class == null || m.redirect.Name == null || m.redirect.Sig == null)
								{
									throw new NotImplementedException();
								}
								MethodDescriptor redir = MethodDescriptor.FromNameSig(ClassLoaderWrapper.GetBootstrapClassLoader(), m.redirect.Name, m.redirect.Sig);
								Type[] redirParamTypes = redir.ArgTypesForDefineMethod;
								for(int i = 0; i < redirParamTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)i);
								}
								// HACK if the class name contains a comma, we assume it is a .NET type
								if(m.redirect.Class.IndexOf(',') >= 0)
								{
									Type type = Type.GetType(m.redirect.Class, true);
									MethodInfo mi = type.GetMethod(m.redirect.Name, redirParamTypes);
									if(mi == null)
									{
										throw new InvalidOperationException();
									}
									ilgen.Emit(OpCodes.Call, mi);
								}
								else
								{
									TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical(m.redirect.Class);
									MethodWrapper mw = tw.GetMethodWrapper(redir, false);
									if(mw == null)
									{
										throw new InvalidOperationException();
									}
									mw.EmitCall.Emit(ilgen);
								}
								// TODO we may need a cast here (or a stack to return type conversion)
								ilgen.Emit(OpCodes.Ret);
d870 1
a870 1
							else if(m.alternateBody != null)
d872 1
a872 1
								m.alternateBody.Emit(ilgen);
d874 1
a874 1
							else if(m.body != null)
d876 1
a876 2
								// <body> doesn't make sense for helper constructors (which are actually factory methods)
								throw new InvalidOperationException();
d880 1
a880 7
								ConstructorInfo baseCon = DeclaringType.TypeAsTBD.GetConstructor(paramTypes);
								if(baseCon == null)
								{
									// TODO better error handling
									throw new InvalidOperationException("constructor not found: " + DeclaringType.Name + ".<init>" + m.Sig);
								}
								for(int i = 0; i < paramTypes.Length; i++)
d882 1
a882 1
									ilgen.Emit(OpCodes.Ldarg, (short)i);
d884 1
a884 2
								ilgen.Emit(OpCodes.Newobj, baseCon);
								ilgen.Emit(OpCodes.Ret);
d886 2
d890 3
a892 1
					else if(xmlMethod != null)
d894 7
a900 6
						MapXml.Method m = xmlMethod;
						MethodDescriptor md = this.Descriptor;
						Type[] paramTypes = md.ArgTypesForDefineMethod;

						// NOTE sealed types don't have instance methods (only instancehelpers)
						if(mbCore != null)
d902 14
a915 3
							ILGenerator ilgen = mbCore.GetILGenerator();
							MethodInfo baseMethod = null;
							if(m.@@override != null)
d917 1
a917 47
								baseMethod = DeclaringType.TypeAsTBD.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, paramTypes, null);
								if(baseMethod == null)
								{
									throw new InvalidOperationException();
								}
								((TypeBuilder)DeclaringType.TypeAsBaseType).DefineMethodOverride(mbCore, baseMethod);
							}
							// TODO we need to support ghost (and other funky?) parameter types
							if(m.body != null)
							{
								// we manually walk the instruction list, because we need to special case the ret instructions
								Hashtable context = new Hashtable();
								foreach(MapXml.Instruction instr in m.body.invoke)
								{
									if(instr is MapXml.Ret)
									{
										md.RetTypeWrapper.EmitConvStackToParameterType(ilgen, null);
									}
									instr.Generate(context, ilgen);
								}
							}
							else
							{
								int thisOffset = 0;
								if((m.Modifiers & MapXml.MapModifiers.Static) == 0)
								{
									thisOffset = 1;
									ilgen.Emit(OpCodes.Ldarg_0);
								}
								for(int i = 0; i < paramTypes.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, (short)(i + thisOffset));
								}
								if(m.redirect != null)
								{
									EmitRedirect(DeclaringType.TypeAsTBD, md, m, ilgen);
								}
								else
								{
									if(baseMethod == null)
									{
										throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
									}
									ilgen.Emit(OpCodes.Call, baseMethod);
								}
								md.RetTypeWrapper.EmitConvStackToParameterType(ilgen, null);
								ilgen.Emit(OpCodes.Ret);
d919 5
d925 1
a925 3

						// NOTE static methods don't have helpers
						if(mbHelper != null)
d927 2
a928 3
							ILGenerator ilgen = mbHelper.GetILGenerator();
							// check "this" for null
							if(m.@@override != null && m.redirect == null && m.body == null && m.alternateBody == null)
d930 2
a931 1
								// we're going to be calling the overridden version, so we don't need the null check
d936 1
a936 9
								EmitHelper.NullCheck(ilgen);
							}
							if(mbCore != null && 
								(m.@@override == null || m.redirect != null) &&
								(m.Modifiers & MapXml.MapModifiers.Private) == 0 && (m.Modifiers & MapXml.MapModifiers.Final) == 0)
							{
								// TODO we should have a way to supress this for overridden methods
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Isinst, DeclaringType.TypeAsBaseType);
d944 3
a946 2
								ilgen.Emit(OpCodes.Callvirt, mbCore);
								md.RetTypeWrapper.EmitConvStackToParameterType(ilgen, null);
d951 7
a957 1
							foreach(RemapperTypeWrapper overrider in overriders)
d959 1
a959 2
								RemappedMethodWrapper mw = (RemappedMethodWrapper)overrider.GetMethodWrapper(md, false);
								if(mw.xmlMethod.redirect == null && mw.xmlMethod.body == null && mw.xmlMethod.alternateBody == null)
d961 1
a961 19
									// the overridden method doesn't actually do anything special (that means it will end
									// up calling the .NET method it overrides), so we don't need to special case this
								}
								else
								{
									ilgen.Emit(OpCodes.Ldarg_0);
									ilgen.Emit(OpCodes.Isinst, overrider.TypeAsTBD);
									ilgen.Emit(OpCodes.Dup);
									Label skip = ilgen.DefineLabel();
									ilgen.Emit(OpCodes.Brfalse_S, skip);
									for(int i = 0; i < paramTypes.Length; i++)
									{
										ilgen.Emit(OpCodes.Ldarg, (short)(i + 1));
									}
									mw.EmitCallvirt.Emit(ilgen);
									md.RetTypeWrapper.EmitConvStackToParameterType(ilgen, null);
									ilgen.Emit(OpCodes.Ret);
									ilgen.MarkLabel(skip);
									ilgen.Emit(OpCodes.Pop);
d963 13
d977 1
a977 1
							if(m.body != null || m.alternateBody != null)
d979 2
a980 4
								MapXml.InstructionList body = m.alternateBody == null ? m.body : m.alternateBody;
								// we manually walk the instruction list, because we need to special case the ret instructions
								Hashtable context = new Hashtable();
								foreach(MapXml.Instruction instr in body.invoke)
d982 1
a982 5
									if(instr is MapXml.Ret)
									{
										md.RetTypeWrapper.EmitConvStackToParameterType(ilgen, null);
									}
									instr.Generate(context, ilgen);
d984 1
d988 2
a989 2
								Type shadowType = ((RemapperTypeWrapper)DeclaringType).shadowType;
								for(int i = 0; i < paramTypes.Length + 1; i++)
d991 1
a991 1
									ilgen.Emit(OpCodes.Ldarg, (short)i);
d993 2
a994 1
								if(m.redirect != null)
d996 1
a996 1
									EmitRedirect(shadowType, md, m, ilgen);
d998 32
a1029 25
								else if(m.@@override != null)
								{
									MethodInfo baseMethod = shadowType.GetMethod(m.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
									if(baseMethod == null)
									{
										throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
									}
									ilgen.Emit(OpCodes.Callvirt, baseMethod);
								}
								else
								{
									RemappedMethodWrapper baseMethod = DeclaringType.BaseTypeWrapper.GetMethodWrapper(md, true) as RemappedMethodWrapper;
									if(baseMethod == null || baseMethod.xmlMethod.@@override == null)
									{
										throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
									}
									MethodInfo overrideMethod = shadowType.GetMethod(baseMethod.xmlMethod.@@override.Name, BindingFlags.Instance | BindingFlags.Public, null, paramTypes, null);
									if(overrideMethod == null)
									{
										throw new InvalidOperationException(DeclaringType.Name + "." + m.Name + m.Sig);
									}
									ilgen.Emit(OpCodes.Callvirt, overrideMethod);
								}
								md.RetTypeWrapper.EmitConvStackToParameterType(ilgen, null);
								ilgen.Emit(OpCodes.Ret);
d1031 2
d1036 47
d1110 1
a1110 17
				if(c.Constructors != null)
				{
					foreach(MapXml.Constructor m in c.Constructors)
					{
						AddMethod(RemappedMethodWrapper.Create(this, m, map));
					}
				}

				if(c.Methods != null)
				{
					// TODO we should also add methods from our super classes (e.g. Throwable should have Object's methods)
					foreach(MapXml.Method m in c.Methods)
					{
						AddMethod(RemappedMethodWrapper.Create(this, m, map));
					}
				}

d1118 1
a1118 1
							MethodDescriptor redir = MethodDescriptor.FromNameSig(GetClassLoader(), f.redirect.Name, f.redirect.Sig);
d1126 2
a1127 1
							AddField(FieldWrapper.Create(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, null, method.EmitCall, CodeEmitter.InternalError));
d1154 1
a1154 2
								CodeEmitter getter = CodeEmitter.CreateLoadConstant(constant);
								AddField(FieldWrapper.Create(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), f.Name, f.Sig, (Modifiers)f.Modifiers, fb, getter, CodeEmitter.InternalError, constant));
d1158 1
a1158 1
								AddField(FieldWrapper.Create(this, GetClassLoader().FieldTypeWrapperFromSig(f.Sig), fb, f.Sig, (Modifiers)f.Modifiers));
d1173 9
a1181 1
				foreach(RemappedMethodWrapper m in GetMethods())
d1211 5
d1225 1
a1225 1
			internal override void Finish()
a1234 6
			protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
			{
				// we don't resolve methods lazily
				return null;
			}

d1294 1
a1294 1
					remapped.Add(c.Name, new RemapperTypeWrapper(this, c));
d1313 3
a1315 1
			// 3rd pass, implement methods/fields and bake the type
d1320 5
d1360 1
a1360 1
			catch(ClassFile.UnsupportedClassVersionError x)
d1365 1
a1365 1
			catch(ClassFile.ClassFormatError x)
d1463 2
a1464 2
			// don't handle inner classes for NetExp types
			if(classFile.NetExpAssemblyAttribute == null)
d1549 1
a1549 1
				MethodWrapper mw = wrapper.GetMethodWrapper(MethodDescriptor.FromNameSig(loader, "main", "([Ljava.lang.String;)V"), false);
d1555 1
d1611 1
a1611 5
		Tracer.Error(Tracer.Runtime, "CRITICAL FAILURE: {0}", message);
		// NOTE we use reflection to invoke MessageBox.Show, to make sure we run on Mono as well
		Assembly winForms = IsUnix ? null : Assembly.LoadWithPartialName("System.Windows.Forms");
		Type messageBox = null;
		if(winForms != null)
d1613 9
a1621 3
			messageBox = winForms.GetType("System.Windows.Forms.MessageBox");
		}
		message = String.Format("****** Critical Failure: {1} ******{0}" +
d1625 22
a1646 6
			Environment.NewLine,
			message,
			x,
			x != null ? new StackTrace(x, true).ToString() : "",
			new StackTrace(true));
		if(messageBox != null)
d1648 1
a1648 1
			messageBox.InvokeMember("Show", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.Public, null, null, new object[] { message, "IKVM.NET Critical Failure" });
d1650 1
a1650 1
		else
d1652 1
a1652 1
			Console.Error.WriteLine(message);
a1653 1
		Environment.Exit(1);
@


1.6
log
@*** empty log message ***
@
text
@d343 1
a343 1
				Debug.CompareTo(!md.RetTypeWrapper.IsUnloadable);
d351 1
d521 1
a521 1
				internal static RemappedMethodWrapper Create(RemapperTypeWrapper typeWrapper, MapXml.Constructor m)
d542 1
a542 1
				internal static RemappedMethodWrapper Create(RemapperTypeWrapper typeWrapper, MapXml.Method m)
d562 21
d585 40
a624 1
						return new RemappedMethodWrapper(typeWrapper, md, interfaceMethod, (Modifiers)m.Modifiers);
d1010 1
a1010 1
			internal void Process2ndPass()
d1039 1
a1039 1
						AddMethod(RemappedMethodWrapper.Create(this, m));
d1048 1
a1048 1
						AddMethod(RemappedMethodWrapper.Create(this, m));
d1138 4
d1240 1
a1240 1
					typeWrapper.Process2ndPass();
@


1.5
log
@*** empty log message ***
@
text
@d129 1
a129 1
						provider = Assembly.Load("IKVM.JNI.Mono").GetType("JNI", true);
d134 1
a134 1
						provider = Assembly.Load("IKVM.JNI.CLR-Win32").GetType("JNI", true);
@


1.4
log
@*** empty log message ***
@
text
@d466 1
a466 1
					: base(typeWrapper, md, /*TODO*/mbCore, mbCore, modifiers, false)
d492 1
a492 1
					: base(typeWrapper, md, /*TODO*/cbCore, cbCore, modifiers, false)
d512 1
a512 1
					: base(typeWrapper, md, interfaceMethod, null, modifiers, false)
d1365 1
d1499 6
@


1.3
log
@*** empty log message ***
@
text
@d184 1
a184 1
			CustomAttributeBuilder ikvmModuleAttr = new CustomAttributeBuilder(typeof(JavaModuleAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { Assembly.GetExecutingAssembly().GetName().Version.ToString() });
@


1.2
log
@*** empty log message ***
@
text
@d1244 2
a1245 2
				Console.Error.WriteLine("Error: duplicate class name: {0}", name);
				return;
@


1.1
log
@*** empty log message ***
@
text
@d128 2
a129 2
						Tracer.Info(Tracer.Runtime, "Loading JNI provider: Mono.IKVM.JNI");
						provider = Assembly.Load("Mono.IKVM.JNI").GetType("JNI", true);
d133 2
a134 2
						Tracer.Info(Tracer.Runtime, "Loading JNI provider: ik.vm.jni");
						provider = Assembly.Load("ik.vm.jni").GetType("JNI", true);
d1374 1
a1374 1
			Assembly classpath = Assembly.LoadWithPartialName("classpath");
d1377 1
a1377 1
				Console.Error.WriteLine("Error: bootstrap classes missing and classpath.dll not found");
@

