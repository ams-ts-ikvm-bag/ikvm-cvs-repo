head	1.489;
access;
symbols
	v8_1_5717_0:1.488.2.1
	v8_1:1.488.0.2
	v8_0_5449_1:1.479
	v8_0_5449_0:1.479
	v8_0:1.479.0.2
	v7_4_5196_0:1.458
	v7_4:1.458.0.2
	v7_3:1.439.0.2
	v7_2_4630_6:1.408.2.2
	v7_2_4630_5:1.408.2.2
	v7_2_4630_4:1.408.2.1
	v7_2_4630_3:1.408.2.1
	v7_2_4630_2:1.408.2.1
	v0_46_0_4:1.373.2.6
	v7_2_4630_1:1.408.2.1
	v7_2:1.408.0.2
	v7_1_4532_2:1.399.2.1
	v7_1_4532_1:1.399.2.1
	v7_1_4532_0:1.399
	v7_1:1.399.0.2
	v7_0_4335_3:1.378.2.1
	v7_0_4335_2:1.378.2.1
	v7_0_4335_1:1.378.2.1
	v0_46_0_2:1.373.2.5
	v7_0_4335_0:1.378
	v7_0:1.378.0.2
	v0_40_0_6:1.283.2.3
	v0_40_0_5:1.283.2.3
	v0_46_0_1:1.373
	v0_46_0_0:1.373
	v0_46:1.373.0.2
	v0_36_0_14:1.187.2.12
	v0_44_0_6:1.363.2.1
	v0_44_0_5:1.363
	v0_44_0_4:1.363
	v0_44_0_3:1.363
	v0_44_0_2:1.363
	v0_42_0_7:1.317.2.1
	v0_44_0_1:1.363
	v0_44_0_0:1.363
	v0_44:1.363.0.2
	v0_42_0_6:1.317.2.1
	v0_42_0_5:1.317.2.1
	v0_42_0_4:1.317
	v0_42_0_3:1.317
	v0_42_0_2:1.317
	v0_42_0_1:1.317
	v0_42_0_0:1.317
	v0_42:1.317.0.2
	v0_40_0_3:1.283.2.3
	v0_40_0_2:1.283.2.2
	v0_40_0_1:1.283.2.2
	v0_40_0_0:1.283
	v0_40:1.283.0.2
	v0_36_0_13:1.187.2.12
	v0_38_0_1:1.258.2.1
	v0_38_0_0:1.258
	v0_38:1.258.0.2
	v0_36_0_9:1.187.2.10
	v0_36_0_7:1.187.2.6
	v0_36_0_5:1.187.2.5
	v0_36_0_4:1.187.2.4
	v0_36_0_3:1.187.2.3
	v0_36_0_2:1.187.2.2
	v0_36_0_1:1.187.2.1
	v0_36_0_0:1.187
	v0_36:1.187.0.2
	v0_34_0_3:1.166.2.2
	v0_34_0_2:1.166
	v0_34_0_1:1.166
	v0_34_0_0:1.166
	v0_34:1.166.0.2
	v0_32:1.148.0.2
	v0_32_0_0:1.148
	v0_30:1.121.0.2
	v0_28_0_0:1.103
	v0_26_0_1:1.80
	v0_26_0_0:1.80
	v0_24_0_1:1.78
	v0_24_0_0:1.77
	v0_22_0_0:1.73
	v0_20_0_0:1.69
	v0_18_0_0:1.54
	v0_16_0_0:1.51
	v0_14_0_1:1.37
	v0_14_0_0:1.37
	v0_12_0_0:1.30
	v0_10_0_1:1.25
	v0_10_0_0:1.25
	v0_8_0_0:1.3;
locks; strict;
comment	@ * @;


1.489
date	2015.08.26.10.08.40;	author jfrijters;	state Exp;
branches;
next	1.488;

1.488
date	2015.06.22.13.17.59;	author jfrijters;	state Exp;
branches
	1.488.2.1;
next	1.487;

1.487
date	2015.06.22.10.55.23;	author jfrijters;	state Exp;
branches;
next	1.486;

1.486
date	2015.06.20.04.58.46;	author jfrijters;	state Exp;
branches;
next	1.485;

1.485
date	2015.06.20.04.54.19;	author jfrijters;	state Exp;
branches;
next	1.484;

1.484
date	2015.03.24.09.39.11;	author jfrijters;	state Exp;
branches;
next	1.483;

1.483
date	2015.03.22.07.48.10;	author jfrijters;	state Exp;
branches;
next	1.482;

1.482
date	2015.03.16.07.03.43;	author jfrijters;	state Exp;
branches;
next	1.481;

1.481
date	2015.03.13.12.54.26;	author jfrijters;	state Exp;
branches;
next	1.480;

1.480
date	2015.03.05.12.14.06;	author jfrijters;	state Exp;
branches;
next	1.479;

1.479
date	2014.07.09.12.52.19;	author jfrijters;	state Exp;
branches;
next	1.478;

1.478
date	2014.07.09.12.25.08;	author jfrijters;	state Exp;
branches;
next	1.477;

1.477
date	2014.07.09.08.45.25;	author jfrijters;	state Exp;
branches;
next	1.476;

1.476
date	2014.07.08.08.23.41;	author jfrijters;	state Exp;
branches;
next	1.475;

1.475
date	2014.07.07.07.40.35;	author jfrijters;	state Exp;
branches;
next	1.474;

1.474
date	2014.07.04.11.06.06;	author jfrijters;	state Exp;
branches;
next	1.473;

1.473
date	2014.07.01.15.12.34;	author jfrijters;	state Exp;
branches;
next	1.472;

1.472
date	2014.06.13.06.54.06;	author jfrijters;	state Exp;
branches;
next	1.471;

1.471
date	2014.06.13.06.48.14;	author jfrijters;	state Exp;
branches;
next	1.470;

1.470
date	2014.06.05.12.38.09;	author jfrijters;	state Exp;
branches;
next	1.469;

1.469
date	2014.06.05.11.08.57;	author jfrijters;	state Exp;
branches;
next	1.468;

1.468
date	2014.06.03.12.04.42;	author jfrijters;	state Exp;
branches;
next	1.467;

1.467
date	2014.06.03.09.13.56;	author jfrijters;	state Exp;
branches;
next	1.466;

1.466
date	2014.06.03.07.15.52;	author jfrijters;	state Exp;
branches;
next	1.465;

1.465
date	2014.05.14.06.02.29;	author jfrijters;	state Exp;
branches;
next	1.464;

1.464
date	2014.04.30.09.04.41;	author jfrijters;	state Exp;
branches;
next	1.463;

1.463
date	2014.04.29.13.20.37;	author jfrijters;	state Exp;
branches;
next	1.462;

1.462
date	2014.04.17.11.31.45;	author jfrijters;	state Exp;
branches;
next	1.461;

1.461
date	2014.04.17.11.29.39;	author jfrijters;	state Exp;
branches;
next	1.460;

1.460
date	2014.04.17.11.02.33;	author jfrijters;	state Exp;
branches;
next	1.459;

1.459
date	2014.04.17.10.18.38;	author jfrijters;	state Exp;
branches;
next	1.458;

1.458
date	2014.03.05.11.12.47;	author jfrijters;	state Exp;
branches;
next	1.457;

1.457
date	2014.02.24.17.05.25;	author jfrijters;	state Exp;
branches;
next	1.456;

1.456
date	2014.02.24.17.00.24;	author jfrijters;	state Exp;
branches;
next	1.455;

1.455
date	2013.10.20.09.31.24;	author jfrijters;	state Exp;
branches;
next	1.454;

1.454
date	2013.10.20.08.52.46;	author jfrijters;	state Exp;
branches;
next	1.453;

1.453
date	2013.08.07.12.15.19;	author jfrijters;	state Exp;
branches;
next	1.452;

1.452
date	2013.08.07.09.26.23;	author jfrijters;	state Exp;
branches;
next	1.451;

1.451
date	2013.08.07.06.46.28;	author jfrijters;	state Exp;
branches;
next	1.450;

1.450
date	2013.08.07.06.24.59;	author jfrijters;	state Exp;
branches;
next	1.449;

1.449
date	2013.08.07.06.16.48;	author jfrijters;	state Exp;
branches;
next	1.448;

1.448
date	2013.08.06.12.11.27;	author jfrijters;	state Exp;
branches;
next	1.447;

1.447
date	2013.03.29.10.50.17;	author jfrijters;	state Exp;
branches;
next	1.446;

1.446
date	2013.03.29.10.37.02;	author jfrijters;	state Exp;
branches;
next	1.445;

1.445
date	2013.03.29.08.28.17;	author jfrijters;	state Exp;
branches;
next	1.444;

1.444
date	2013.03.26.09.52.45;	author jfrijters;	state Exp;
branches;
next	1.443;

1.443
date	2013.03.25.16.37.15;	author jfrijters;	state Exp;
branches;
next	1.442;

1.442
date	2013.03.25.07.34.03;	author jfrijters;	state Exp;
branches;
next	1.441;

1.441
date	2013.03.24.12.40.33;	author jfrijters;	state Exp;
branches;
next	1.440;

1.440
date	2013.03.24.10.05.18;	author jfrijters;	state Exp;
branches;
next	1.439;

1.439
date	2013.03.11.16.58.16;	author jfrijters;	state Exp;
branches;
next	1.438;

1.438
date	2013.03.08.13.21.44;	author jfrijters;	state Exp;
branches;
next	1.437;

1.437
date	2013.03.06.15.26.04;	author jfrijters;	state Exp;
branches;
next	1.436;

1.436
date	2013.03.06.10.11.38;	author jfrijters;	state Exp;
branches;
next	1.435;

1.435
date	2013.03.06.10.09.59;	author jfrijters;	state Exp;
branches;
next	1.434;

1.434
date	2013.02.26.13.27.17;	author jfrijters;	state Exp;
branches;
next	1.433;

1.433
date	2013.02.26.12.00.49;	author jfrijters;	state Exp;
branches;
next	1.432;

1.432
date	2013.02.18.17.15.03;	author jfrijters;	state Exp;
branches;
next	1.431;

1.431
date	2013.02.14.16.09.04;	author jfrijters;	state Exp;
branches;
next	1.430;

1.430
date	2013.02.14.15.51.17;	author jfrijters;	state Exp;
branches;
next	1.429;

1.429
date	2013.02.07.08.45.41;	author jfrijters;	state Exp;
branches;
next	1.428;

1.428
date	2013.02.06.19.54.34;	author jfrijters;	state Exp;
branches;
next	1.427;

1.427
date	2013.02.06.19.31.10;	author jfrijters;	state Exp;
branches;
next	1.426;

1.426
date	2013.02.05.14.54.20;	author jfrijters;	state Exp;
branches;
next	1.425;

1.425
date	2013.01.31.10.55.49;	author jfrijters;	state Exp;
branches;
next	1.424;

1.424
date	2013.01.31.09.12.20;	author jfrijters;	state Exp;
branches;
next	1.423;

1.423
date	2013.01.30.12.20.07;	author jfrijters;	state Exp;
branches;
next	1.422;

1.422
date	2013.01.24.17.48.38;	author jfrijters;	state Exp;
branches;
next	1.421;

1.421
date	2013.01.24.13.54.19;	author jfrijters;	state Exp;
branches;
next	1.420;

1.420
date	2013.01.15.15.33.50;	author jfrijters;	state Exp;
branches;
next	1.419;

1.419
date	2013.01.15.15.31.16;	author jfrijters;	state Exp;
branches;
next	1.418;

1.418
date	2013.01.15.15.29.57;	author jfrijters;	state Exp;
branches;
next	1.417;

1.417
date	2013.01.15.15.20.53;	author jfrijters;	state Exp;
branches;
next	1.416;

1.416
date	2013.01.15.15.07.12;	author jfrijters;	state Exp;
branches;
next	1.415;

1.415
date	2013.01.08.07.58.38;	author jfrijters;	state Exp;
branches;
next	1.414;

1.414
date	2013.01.08.07.07.08;	author jfrijters;	state Exp;
branches;
next	1.413;

1.413
date	2013.01.07.12.21.52;	author jfrijters;	state Exp;
branches;
next	1.412;

1.412
date	2012.11.01.11.23.33;	author jfrijters;	state Exp;
branches;
next	1.411;

1.411
date	2012.09.13.13.21.35;	author jfrijters;	state Exp;
branches;
next	1.410;

1.410
date	2012.09.12.11.40.15;	author jfrijters;	state Exp;
branches;
next	1.409;

1.409
date	2012.09.11.12.00.46;	author jfrijters;	state Exp;
branches;
next	1.408;

1.408
date	2012.08.15.11.52.55;	author jfrijters;	state Exp;
branches
	1.408.2.1;
next	1.407;

1.407
date	2012.08.15.08.45.39;	author jfrijters;	state Exp;
branches;
next	1.406;

1.406
date	2012.08.06.15.40.12;	author jfrijters;	state Exp;
branches;
next	1.405;

1.405
date	2012.08.06.13.01.41;	author jfrijters;	state Exp;
branches;
next	1.404;

1.404
date	2012.08.06.12.12.03;	author jfrijters;	state Exp;
branches;
next	1.403;

1.403
date	2012.07.21.06.35.51;	author jfrijters;	state Exp;
branches;
next	1.402;

1.402
date	2012.07.09.06.07.40;	author jfrijters;	state Exp;
branches;
next	1.401;

1.401
date	2012.07.03.14.45.51;	author jfrijters;	state Exp;
branches;
next	1.400;

1.400
date	2012.06.11.15.41.37;	author jfrijters;	state Exp;
branches;
next	1.399;

1.399
date	2012.04.13.11.47.48;	author jfrijters;	state Exp;
branches
	1.399.2.1;
next	1.398;

1.398
date	2012.04.12.10.09.09;	author jfrijters;	state Exp;
branches;
next	1.397;

1.397
date	2012.03.25.09.10.29;	author jfrijters;	state Exp;
branches;
next	1.396;

1.396
date	2012.01.20.09.01.07;	author jfrijters;	state Exp;
branches;
next	1.395;

1.395
date	2012.01.05.09.03.52;	author jfrijters;	state Exp;
branches;
next	1.394;

1.394
date	2012.01.03.14.26.36;	author jfrijters;	state Exp;
branches;
next	1.393;

1.393
date	2011.12.15.11.54.58;	author jfrijters;	state Exp;
branches;
next	1.392;

1.392
date	2011.12.15.08.56.10;	author jfrijters;	state Exp;
branches;
next	1.391;

1.391
date	2011.12.13.07.34.50;	author jfrijters;	state Exp;
branches;
next	1.390;

1.390
date	2011.11.29.15.08.15;	author jfrijters;	state Exp;
branches;
next	1.389;

1.389
date	2011.11.29.13.00.26;	author jfrijters;	state Exp;
branches;
next	1.388;

1.388
date	2011.11.25.12.47.17;	author jfrijters;	state Exp;
branches;
next	1.387;

1.387
date	2011.11.25.12.03.57;	author jfrijters;	state Exp;
branches;
next	1.386;

1.386
date	2011.11.24.15.14.03;	author jfrijters;	state Exp;
branches;
next	1.385;

1.385
date	2011.11.24.12.31.39;	author jfrijters;	state Exp;
branches;
next	1.384;

1.384
date	2011.11.24.09.08.04;	author jfrijters;	state Exp;
branches;
next	1.383;

1.383
date	2011.11.24.08.35.47;	author jfrijters;	state Exp;
branches;
next	1.382;

1.382
date	2011.11.23.07.09.29;	author jfrijters;	state Exp;
branches;
next	1.381;

1.381
date	2011.11.23.06.20.34;	author jfrijters;	state Exp;
branches;
next	1.380;

1.380
date	2011.11.18.15.22.46;	author jfrijters;	state Exp;
branches;
next	1.379;

1.379
date	2011.11.18.08.33.55;	author jfrijters;	state Exp;
branches;
next	1.378;

1.378
date	2011.10.18.10.57.18;	author jfrijters;	state Exp;
branches
	1.378.2.1;
next	1.377;

1.377
date	2011.08.12.07.51.00;	author jfrijters;	state Exp;
branches;
next	1.376;

1.376
date	2011.06.27.15.13.20;	author jfrijters;	state Exp;
branches;
next	1.375;

1.375
date	2011.06.27.13.15.18;	author jfrijters;	state Exp;
branches;
next	1.374;

1.374
date	2011.05.17.07.46.01;	author jfrijters;	state Exp;
branches;
next	1.373;

1.373
date	2011.01.21.11.06.26;	author jfrijters;	state Exp;
branches
	1.373.2.1;
next	1.372;

1.372
date	2010.10.01.08.11.49;	author jfrijters;	state Exp;
branches;
next	1.371;

1.371
date	2010.09.29.07.21.51;	author jfrijters;	state Exp;
branches;
next	1.370;

1.370
date	2010.09.21.05.45.48;	author jfrijters;	state Exp;
branches;
next	1.369;

1.369
date	2010.09.20.15.08.46;	author jfrijters;	state Exp;
branches;
next	1.368;

1.368
date	2010.09.14.12.29.22;	author jfrijters;	state Exp;
branches;
next	1.367;

1.367
date	2010.09.13.06.16.23;	author jfrijters;	state Exp;
branches;
next	1.366;

1.366
date	2010.09.10.07.59.39;	author jfrijters;	state Exp;
branches;
next	1.365;

1.365
date	2010.07.28.12.33.22;	author jfrijters;	state Exp;
branches;
next	1.364;

1.364
date	2010.07.16.08.50.40;	author jfrijters;	state Exp;
branches;
next	1.363;

1.363
date	2010.06.10.04.38.57;	author jfrijters;	state Exp;
branches
	1.363.2.1;
next	1.362;

1.362
date	2010.06.08.05.25.14;	author jfrijters;	state Exp;
branches;
next	1.361;

1.361
date	2010.06.07.04.21.35;	author jfrijters;	state Exp;
branches;
next	1.360;

1.360
date	2010.05.27.10.54.34;	author jfrijters;	state Exp;
branches;
next	1.359;

1.359
date	2010.05.27.09.25.15;	author jfrijters;	state Exp;
branches;
next	1.358;

1.358
date	2010.05.20.12.37.00;	author jfrijters;	state Exp;
branches;
next	1.357;

1.357
date	2010.05.20.12.16.27;	author jfrijters;	state Exp;
branches;
next	1.356;

1.356
date	2010.05.20.09.43.15;	author jfrijters;	state Exp;
branches;
next	1.355;

1.355
date	2010.05.20.06.00.48;	author jfrijters;	state Exp;
branches;
next	1.354;

1.354
date	2010.05.20.05.39.53;	author jfrijters;	state Exp;
branches;
next	1.353;

1.353
date	2010.05.20.05.34.31;	author jfrijters;	state Exp;
branches;
next	1.352;

1.352
date	2010.05.20.04.59.13;	author jfrijters;	state Exp;
branches;
next	1.351;

1.351
date	2010.05.19.09.11.50;	author jfrijters;	state Exp;
branches;
next	1.350;

1.350
date	2010.05.16.06.31.21;	author jfrijters;	state Exp;
branches;
next	1.349;

1.349
date	2010.05.15.09.28.29;	author jfrijters;	state Exp;
branches;
next	1.348;

1.348
date	2010.05.10.04.46.45;	author jfrijters;	state Exp;
branches;
next	1.347;

1.347
date	2010.02.19.08.07.38;	author jfrijters;	state Exp;
branches;
next	1.346;

1.346
date	2010.02.11.09.59.12;	author jfrijters;	state Exp;
branches;
next	1.345;

1.345
date	2010.02.11.09.54.12;	author jfrijters;	state Exp;
branches;
next	1.344;

1.344
date	2010.01.29.07.08.56;	author jfrijters;	state Exp;
branches;
next	1.343;

1.343
date	2010.01.29.06.58.10;	author jfrijters;	state Exp;
branches;
next	1.342;

1.342
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches;
next	1.341;

1.341
date	2010.01.28.08.44.57;	author jfrijters;	state Exp;
branches;
next	1.340;

1.340
date	2010.01.28.07.14.37;	author jfrijters;	state Exp;
branches;
next	1.339;

1.339
date	2010.01.28.07.10.31;	author jfrijters;	state Exp;
branches;
next	1.338;

1.338
date	2010.01.28.06.37.48;	author jfrijters;	state Exp;
branches;
next	1.337;

1.337
date	2010.01.28.06.24.13;	author jfrijters;	state Exp;
branches;
next	1.336;

1.336
date	2010.01.28.06.09.20;	author jfrijters;	state Exp;
branches;
next	1.335;

1.335
date	2010.01.25.07.53.12;	author jfrijters;	state Exp;
branches;
next	1.334;

1.334
date	2009.12.31.08.20.32;	author jfrijters;	state Exp;
branches;
next	1.333;

1.333
date	2009.12.10.08.43.45;	author jfrijters;	state Exp;
branches;
next	1.332;

1.332
date	2009.12.10.08.27.38;	author jfrijters;	state Exp;
branches;
next	1.331;

1.331
date	2009.12.07.07.12.23;	author jfrijters;	state Exp;
branches;
next	1.330;

1.330
date	2009.12.07.06.59.11;	author jfrijters;	state Exp;
branches;
next	1.329;

1.329
date	2009.12.07.06.39.46;	author jfrijters;	state Exp;
branches;
next	1.328;

1.328
date	2009.12.07.05.54.04;	author jfrijters;	state Exp;
branches;
next	1.327;

1.327
date	2009.12.02.05.48.50;	author jfrijters;	state Exp;
branches;
next	1.326;

1.326
date	2009.11.13.15.08.22;	author jfrijters;	state Exp;
branches;
next	1.325;

1.325
date	2009.11.09.08.52.17;	author jfrijters;	state Exp;
branches;
next	1.324;

1.324
date	2009.11.09.07.49.32;	author jfrijters;	state Exp;
branches;
next	1.323;

1.323
date	2009.11.09.06.39.17;	author jfrijters;	state Exp;
branches;
next	1.322;

1.322
date	2009.11.06.07.46.40;	author jfrijters;	state Exp;
branches;
next	1.321;

1.321
date	2009.11.04.06.06.22;	author jfrijters;	state Exp;
branches;
next	1.320;

1.320
date	2009.10.20.05.17.27;	author jfrijters;	state Exp;
branches;
next	1.319;

1.319
date	2009.10.16.07.06.50;	author jfrijters;	state Exp;
branches;
next	1.318;

1.318
date	2009.10.14.14.58.41;	author jfrijters;	state Exp;
branches;
next	1.317;

1.317
date	2009.09.07.04.46.01;	author jfrijters;	state Exp;
branches
	1.317.2.1;
next	1.316;

1.316
date	2009.08.31.06.16.04;	author jfrijters;	state Exp;
branches;
next	1.315;

1.315
date	2009.08.31.06.05.15;	author jfrijters;	state Exp;
branches;
next	1.314;

1.314
date	2009.08.31.05.49.19;	author jfrijters;	state Exp;
branches;
next	1.313;

1.313
date	2009.08.31.05.46.20;	author jfrijters;	state Exp;
branches;
next	1.312;

1.312
date	2009.08.31.05.10.11;	author jfrijters;	state Exp;
branches;
next	1.311;

1.311
date	2009.08.31.05.02.35;	author jfrijters;	state Exp;
branches;
next	1.310;

1.310
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.309;

1.309
date	2009.08.28.06.20.22;	author jfrijters;	state Exp;
branches;
next	1.308;

1.308
date	2009.08.28.06.06.35;	author jfrijters;	state Exp;
branches;
next	1.307;

1.307
date	2009.08.27.14.40.42;	author jfrijters;	state Exp;
branches;
next	1.306;

1.306
date	2009.07.30.13.14.14;	author jfrijters;	state Exp;
branches;
next	1.305;

1.305
date	2009.07.29.09.36.56;	author jfrijters;	state Exp;
branches;
next	1.304;

1.304
date	2009.07.29.07.06.44;	author jfrijters;	state Exp;
branches;
next	1.303;

1.303
date	2009.07.27.08.04.30;	author jfrijters;	state Exp;
branches;
next	1.302;

1.302
date	2009.07.16.06.29.32;	author jfrijters;	state Exp;
branches;
next	1.301;

1.301
date	2009.07.16.06.26.47;	author jfrijters;	state Exp;
branches;
next	1.300;

1.300
date	2009.07.14.08.25.04;	author jfrijters;	state Exp;
branches;
next	1.299;

1.299
date	2009.07.14.06.27.41;	author jfrijters;	state Exp;
branches;
next	1.298;

1.298
date	2009.07.13.13.34.41;	author jfrijters;	state Exp;
branches;
next	1.297;

1.297
date	2009.07.13.08.34.37;	author jfrijters;	state Exp;
branches;
next	1.296;

1.296
date	2009.07.07.08.02.18;	author jfrijters;	state Exp;
branches;
next	1.295;

1.295
date	2009.07.07.07.44.30;	author jfrijters;	state Exp;
branches;
next	1.294;

1.294
date	2009.06.18.06.14.55;	author jfrijters;	state Exp;
branches;
next	1.293;

1.293
date	2009.06.02.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.292;

1.292
date	2009.05.29.07.47.20;	author jfrijters;	state Exp;
branches;
next	1.291;

1.291
date	2009.05.26.05.00.38;	author jfrijters;	state Exp;
branches;
next	1.290;

1.290
date	2009.05.17.06.05.52;	author jfrijters;	state Exp;
branches;
next	1.289;

1.289
date	2009.05.12.04.03.48;	author jfrijters;	state Exp;
branches;
next	1.288;

1.288
date	2009.05.12.04.00.01;	author jfrijters;	state Exp;
branches;
next	1.287;

1.287
date	2009.04.22.04.34.06;	author jfrijters;	state Exp;
branches;
next	1.286;

1.286
date	2009.04.21.07.26.29;	author jfrijters;	state Exp;
branches;
next	1.285;

1.285
date	2009.04.16.05.44.48;	author jfrijters;	state Exp;
branches;
next	1.284;

1.284
date	2009.04.06.10.10.18;	author jfrijters;	state Exp;
branches;
next	1.283;

1.283
date	2009.03.07.08.33.33;	author jfrijters;	state Exp;
branches
	1.283.2.1;
next	1.282;

1.282
date	2009.03.06.06.43.44;	author jfrijters;	state Exp;
branches;
next	1.281;

1.281
date	2009.03.06.05.33.08;	author jfrijters;	state Exp;
branches;
next	1.280;

1.280
date	2009.03.04.05.47.19;	author jfrijters;	state Exp;
branches;
next	1.279;

1.279
date	2009.03.02.06.30.13;	author jfrijters;	state Exp;
branches;
next	1.278;

1.278
date	2009.02.25.05.00.53;	author jfrijters;	state Exp;
branches;
next	1.277;

1.277
date	2009.02.24.06.11.17;	author jfrijters;	state Exp;
branches;
next	1.276;

1.276
date	2009.02.24.04.42.20;	author jfrijters;	state Exp;
branches;
next	1.275;

1.275
date	2009.02.23.05.17.21;	author jfrijters;	state Exp;
branches;
next	1.274;

1.274
date	2009.02.22.08.19.30;	author jfrijters;	state Exp;
branches;
next	1.273;

1.273
date	2009.02.10.07.24.30;	author jfrijters;	state Exp;
branches;
next	1.272;

1.272
date	2009.02.04.08.10.24;	author jfrijters;	state Exp;
branches;
next	1.271;

1.271
date	2009.02.04.06.51.40;	author jfrijters;	state Exp;
branches;
next	1.270;

1.270
date	2009.01.17.11.05.10;	author jfrijters;	state Exp;
branches;
next	1.269;

1.269
date	2009.01.05.06.29.18;	author jfrijters;	state Exp;
branches;
next	1.268;

1.268
date	2008.12.23.07.12.51;	author jfrijters;	state Exp;
branches;
next	1.267;

1.267
date	2008.12.22.07.54.25;	author jfrijters;	state Exp;
branches;
next	1.266;

1.266
date	2008.12.01.05.26.28;	author jfrijters;	state Exp;
branches;
next	1.265;

1.265
date	2008.12.01.05.23.51;	author jfrijters;	state Exp;
branches;
next	1.264;

1.264
date	2008.12.01.05.21.05;	author jfrijters;	state Exp;
branches;
next	1.263;

1.263
date	2008.11.17.06.15.16;	author jfrijters;	state Exp;
branches;
next	1.262;

1.262
date	2008.11.14.08.42.07;	author jfrijters;	state Exp;
branches;
next	1.261;

1.261
date	2008.11.14.08.37.22;	author jfrijters;	state Exp;
branches;
next	1.260;

1.260
date	2008.11.03.07.02.29;	author jfrijters;	state Exp;
branches;
next	1.259;

1.259
date	2008.11.03.06.48.05;	author jfrijters;	state Exp;
branches;
next	1.258;

1.258
date	2008.09.21.09.50.41;	author jfrijters;	state Exp;
branches
	1.258.2.1;
next	1.257;

1.257
date	2008.08.25.04.16.59;	author jfrijters;	state Exp;
branches;
next	1.256;

1.256
date	2008.08.21.06.53.48;	author jfrijters;	state Exp;
branches;
next	1.255;

1.255
date	2008.08.21.06.40.24;	author jfrijters;	state Exp;
branches;
next	1.254;

1.254
date	2008.08.15.12.01.20;	author jfrijters;	state Exp;
branches;
next	1.253;

1.253
date	2008.08.15.06.27.13;	author jfrijters;	state Exp;
branches;
next	1.252;

1.252
date	2008.08.14.07.52.27;	author jfrijters;	state Exp;
branches;
next	1.251;

1.251
date	2008.08.14.05.42.43;	author jfrijters;	state Exp;
branches;
next	1.250;

1.250
date	2008.08.14.05.40.40;	author jfrijters;	state Exp;
branches;
next	1.249;

1.249
date	2008.08.06.12.22.11;	author jfrijters;	state Exp;
branches;
next	1.248;

1.248
date	2008.08.06.05.48.52;	author jfrijters;	state Exp;
branches;
next	1.247;

1.247
date	2008.08.06.05.25.19;	author jfrijters;	state Exp;
branches;
next	1.246;

1.246
date	2008.07.02.06.22.21;	author jfrijters;	state Exp;
branches;
next	1.245;

1.245
date	2008.06.18.10.23.37;	author jfrijters;	state Exp;
branches;
next	1.244;

1.244
date	2008.06.13.07.52.55;	author jfrijters;	state Exp;
branches;
next	1.243;

1.243
date	2008.06.03.12.10.31;	author jfrijters;	state Exp;
branches;
next	1.242;

1.242
date	2008.06.03.07.13.50;	author jfrijters;	state Exp;
branches;
next	1.241;

1.241
date	2008.06.03.06.52.30;	author jfrijters;	state Exp;
branches;
next	1.240;

1.240
date	2008.06.02.06.20.29;	author jfrijters;	state Exp;
branches;
next	1.239;

1.239
date	2008.06.02.04.04.39;	author jfrijters;	state Exp;
branches;
next	1.238;

1.238
date	2008.05.31.15.20.40;	author jfrijters;	state Exp;
branches;
next	1.237;

1.237
date	2008.05.20.07.43.42;	author jfrijters;	state Exp;
branches;
next	1.236;

1.236
date	2008.05.20.07.36.51;	author jfrijters;	state Exp;
branches;
next	1.235;

1.235
date	2008.05.09.05.58.01;	author jfrijters;	state Exp;
branches;
next	1.234;

1.234
date	2008.04.25.04.45.52;	author jfrijters;	state Exp;
branches;
next	1.233;

1.233
date	2008.04.22.06.50.22;	author jfrijters;	state Exp;
branches;
next	1.232;

1.232
date	2008.04.22.06.48.30;	author jfrijters;	state Exp;
branches;
next	1.231;

1.231
date	2008.04.22.06.24.56;	author jfrijters;	state Exp;
branches;
next	1.230;

1.230
date	2008.04.21.08.19.20;	author jfrijters;	state Exp;
branches;
next	1.229;

1.229
date	2008.04.14.05.13.42;	author jfrijters;	state Exp;
branches;
next	1.228;

1.228
date	2008.04.01.17.39.07;	author jfrijters;	state Exp;
branches;
next	1.227;

1.227
date	2008.04.01.17.36.04;	author jfrijters;	state Exp;
branches;
next	1.226;

1.226
date	2008.03.14.09.12.51;	author jfrijters;	state Exp;
branches;
next	1.225;

1.225
date	2008.03.04.07.28.00;	author jfrijters;	state Exp;
branches;
next	1.224;

1.224
date	2008.03.03.07.05.20;	author jfrijters;	state Exp;
branches;
next	1.223;

1.223
date	2008.02.29.08.01.34;	author jfrijters;	state Exp;
branches;
next	1.222;

1.222
date	2008.02.29.07.08.04;	author jfrijters;	state Exp;
branches;
next	1.221;

1.221
date	2008.02.19.09.44.40;	author jfrijters;	state Exp;
branches;
next	1.220;

1.220
date	2008.02.17.11.33.03;	author jfrijters;	state Exp;
branches;
next	1.219;

1.219
date	2008.02.10.09.05.53;	author jfrijters;	state Exp;
branches;
next	1.218;

1.218
date	2008.02.10.08.45.27;	author jfrijters;	state Exp;
branches;
next	1.217;

1.217
date	2008.02.09.17.37.38;	author jfrijters;	state Exp;
branches;
next	1.216;

1.216
date	2008.01.03.09.42.14;	author jfrijters;	state Exp;
branches;
next	1.215;

1.215
date	2007.12.28.14.36.30;	author jfrijters;	state Exp;
branches;
next	1.214;

1.214
date	2007.12.28.10.22.06;	author jfrijters;	state Exp;
branches;
next	1.213;

1.213
date	2007.12.27.15.41.43;	author jfrijters;	state Exp;
branches;
next	1.212;

1.212
date	2007.12.27.15.08.05;	author jfrijters;	state Exp;
branches;
next	1.211;

1.211
date	2007.12.19.11.28.11;	author jfrijters;	state Exp;
branches;
next	1.210;

1.210
date	2007.12.18.09.56.12;	author jfrijters;	state Exp;
branches;
next	1.209;

1.209
date	2007.12.17.10.59.04;	author jfrijters;	state Exp;
branches;
next	1.208;

1.208
date	2007.12.17.07.43.08;	author jfrijters;	state Exp;
branches;
next	1.207;

1.207
date	2007.12.04.08.10.53;	author jfrijters;	state Exp;
branches;
next	1.206;

1.206
date	2007.11.26.16.00.15;	author jfrijters;	state Exp;
branches;
next	1.205;

1.205
date	2007.11.26.11.01.29;	author jfrijters;	state Exp;
branches;
next	1.204;

1.204
date	2007.11.26.09.01.35;	author jfrijters;	state Exp;
branches;
next	1.203;

1.203
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.202;

1.202
date	2007.11.06.08.54.52;	author jfrijters;	state Exp;
branches;
next	1.201;

1.201
date	2007.10.22.09.25.10;	author jfrijters;	state Exp;
branches;
next	1.200;

1.200
date	2007.10.21.07.14.53;	author jfrijters;	state Exp;
branches;
next	1.199;

1.199
date	2007.10.12.08.52.08;	author jfrijters;	state Exp;
branches;
next	1.198;

1.198
date	2007.10.10.06.54.22;	author jfrijters;	state Exp;
branches;
next	1.197;

1.197
date	2007.10.10.05.31.57;	author jfrijters;	state Exp;
branches;
next	1.196;

1.196
date	2007.09.24.13.06.30;	author jfrijters;	state Exp;
branches;
next	1.195;

1.195
date	2007.09.19.09.38.05;	author jfrijters;	state Exp;
branches;
next	1.194;

1.194
date	2007.09.17.10.15.17;	author jfrijters;	state Exp;
branches;
next	1.193;

1.193
date	2007.09.11.12.12.35;	author jfrijters;	state Exp;
branches;
next	1.192;

1.192
date	2007.09.07.12.37.03;	author jfrijters;	state Exp;
branches;
next	1.191;

1.191
date	2007.09.07.12.34.46;	author jfrijters;	state Exp;
branches;
next	1.190;

1.190
date	2007.09.07.12.32.29;	author jfrijters;	state Exp;
branches;
next	1.189;

1.189
date	2007.09.07.12.29.21;	author jfrijters;	state Exp;
branches;
next	1.188;

1.188
date	2007.09.07.12.26.52;	author jfrijters;	state Exp;
branches;
next	1.187;

1.187
date	2007.08.29.06.23.14;	author jfrijters;	state Exp;
branches
	1.187.2.1;
next	1.186;

1.186
date	2007.08.21.07.22.05;	author jfrijters;	state Exp;
branches;
next	1.185;

1.185
date	2007.08.17.09.11.34;	author jfrijters;	state Exp;
branches;
next	1.184;

1.184
date	2007.08.08.12.50.48;	author jfrijters;	state Exp;
branches;
next	1.183;

1.183
date	2007.08.03.13.14.41;	author jfrijters;	state Exp;
branches;
next	1.182;

1.182
date	2007.07.31.15.27.22;	author jfrijters;	state Exp;
branches;
next	1.181;

1.181
date	2007.07.25.16.28.20;	author jfrijters;	state Exp;
branches;
next	1.180;

1.180
date	2007.07.22.04.45.23;	author jfrijters;	state Exp;
branches;
next	1.179;

1.179
date	2007.07.04.12.19.49;	author jfrijters;	state Exp;
branches;
next	1.178;

1.178
date	2007.06.28.10.32.50;	author jfrijters;	state Exp;
branches;
next	1.177;

1.177
date	2007.06.21.05.02.12;	author jfrijters;	state Exp;
branches;
next	1.176;

1.176
date	2007.06.14.06.41.37;	author jfrijters;	state Exp;
branches;
next	1.175;

1.175
date	2007.06.08.05.00.51;	author jfrijters;	state Exp;
branches;
next	1.174;

1.174
date	2007.05.31.08.20.04;	author jfrijters;	state Exp;
branches;
next	1.173;

1.173
date	2007.05.31.07.12.56;	author jfrijters;	state Exp;
branches;
next	1.172;

1.172
date	2007.05.27.08.16.58;	author jfrijters;	state Exp;
branches;
next	1.171;

1.171
date	2007.05.10.06.53.50;	author jfrijters;	state Exp;
branches;
next	1.170;

1.170
date	2007.05.05.15.40.09;	author jfrijters;	state Exp;
branches;
next	1.169;

1.169
date	2007.04.23.08.24.34;	author jfrijters;	state Exp;
branches;
next	1.168;

1.168
date	2007.04.15.08.01.19;	author jfrijters;	state Exp;
branches;
next	1.167;

1.167
date	2007.04.12.09.27.18;	author jfrijters;	state Exp;
branches;
next	1.166;

1.166
date	2007.04.05.12.50.59;	author jfrijters;	state Exp;
branches
	1.166.2.1;
next	1.165;

1.165
date	2007.03.29.09.17.20;	author jfrijters;	state Exp;
branches;
next	1.164;

1.164
date	2007.03.13.07.44.23;	author jfrijters;	state Exp;
branches;
next	1.163;

1.163
date	2007.03.11.14.14.54;	author jfrijters;	state Exp;
branches;
next	1.162;

1.162
date	2007.03.08.07.42.27;	author jfrijters;	state Exp;
branches;
next	1.161;

1.161
date	2007.03.07.15.41.18;	author jfrijters;	state Exp;
branches;
next	1.160;

1.160
date	2007.03.05.12.37.03;	author jfrijters;	state Exp;
branches;
next	1.159;

1.159
date	2007.02.20.16.11.49;	author jfrijters;	state Exp;
branches;
next	1.158;

1.158
date	2007.02.19.11.31.38;	author jfrijters;	state Exp;
branches;
next	1.157;

1.157
date	2007.02.16.07.42.33;	author jfrijters;	state Exp;
branches;
next	1.156;

1.156
date	2007.02.01.12.41.22;	author jfrijters;	state Exp;
branches;
next	1.155;

1.155
date	2007.02.01.07.13.02;	author jfrijters;	state Exp;
branches;
next	1.154;

1.154
date	2007.01.23.15.45.45;	author jfrijters;	state Exp;
branches;
next	1.153;

1.153
date	2007.01.16.10.14.47;	author jfrijters;	state Exp;
branches;
next	1.152;

1.152
date	2007.01.06.06.53.50;	author jfrijters;	state Exp;
branches;
next	1.151;

1.151
date	2007.01.04.12.54.10;	author jfrijters;	state Exp;
branches;
next	1.150;

1.150
date	2007.01.04.07.46.40;	author jfrijters;	state Exp;
branches;
next	1.149;

1.149
date	2006.12.28.07.46.27;	author jfrijters;	state Exp;
branches;
next	1.148;

1.148
date	2006.12.05.07.52.27;	author jfrijters;	state Exp;
branches;
next	1.147;

1.147
date	2006.11.27.07.39.31;	author jfrijters;	state Exp;
branches;
next	1.146;

1.146
date	2006.11.20.09.33.16;	author jfrijters;	state Exp;
branches;
next	1.145;

1.145
date	2006.11.01.08.55.25;	author jfrijters;	state Exp;
branches;
next	1.144;

1.144
date	2006.10.27.16.55.07;	author jfrijters;	state Exp;
branches;
next	1.143;

1.143
date	2006.10.19.06.12.48;	author jfrijters;	state Exp;
branches;
next	1.142;

1.142
date	2006.10.12.06.44.16;	author jfrijters;	state Exp;
branches;
next	1.141;

1.141
date	2006.10.10.16.31.35;	author jfrijters;	state Exp;
branches;
next	1.140;

1.140
date	2006.10.09.12.47.35;	author jfrijters;	state Exp;
branches;
next	1.139;

1.139
date	2006.10.09.12.32.33;	author jfrijters;	state Exp;
branches;
next	1.138;

1.138
date	2006.10.09.08.29.42;	author jfrijters;	state Exp;
branches;
next	1.137;

1.137
date	2006.10.04.12.51.19;	author jfrijters;	state Exp;
branches;
next	1.136;

1.136
date	2006.10.04.09.03.18;	author jfrijters;	state Exp;
branches;
next	1.135;

1.135
date	2006.10.01.08.09.25;	author jfrijters;	state Exp;
branches;
next	1.134;

1.134
date	2006.09.26.04.53.16;	author jfrijters;	state Exp;
branches;
next	1.133;

1.133
date	2006.09.20.11.29.47;	author jfrijters;	state Exp;
branches;
next	1.132;

1.132
date	2006.09.12.09.57.36;	author jfrijters;	state Exp;
branches;
next	1.131;

1.131
date	2006.09.01.07.53.36;	author jfrijters;	state Exp;
branches;
next	1.130;

1.130
date	2006.08.31.09.22.11;	author jfrijters;	state Exp;
branches;
next	1.129;

1.129
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.128;

1.128
date	2006.08.26.13.00.50;	author jfrijters;	state Exp;
branches;
next	1.127;

1.127
date	2006.08.21.05.15.52;	author jfrijters;	state Exp;
branches;
next	1.126;

1.126
date	2006.08.17.13.18.45;	author jfrijters;	state Exp;
branches;
next	1.125;

1.125
date	2006.08.17.08.35.52;	author jfrijters;	state Exp;
branches;
next	1.124;

1.124
date	2006.08.15.08.50.43;	author jfrijters;	state Exp;
branches;
next	1.123;

1.123
date	2006.08.14.07.57.03;	author jfrijters;	state Exp;
branches;
next	1.122;

1.122
date	2006.08.06.09.27.20;	author jfrijters;	state Exp;
branches;
next	1.121;

1.121
date	2006.07.27.14.44.51;	author jfrijters;	state Exp;
branches
	1.121.2.1;
next	1.120;

1.120
date	2006.07.26.14.16.52;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2006.07.26.10.33.52;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2006.07.26.09.03.44;	author jfrijters;	state Exp;
branches;
next	1.117;

1.117
date	2006.07.26.07.57.18;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2006.07.24.11.47.55;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2006.07.24.08.21.11;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2006.07.21.10.18.15;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2006.07.06.13.53.52;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2006.07.05.12.53.26;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2006.07.05.09.50.27;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2006.07.05.08.46.56;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2006.07.04.10.13.33;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2006.06.22.10.04.08;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2006.06.20.14.31.59;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2006.06.15.12.29.12;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2006.06.08.09.26.39;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2006.05.23.12.49.18;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2006.05.15.09.08.01;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2006.05.06.10.46.52;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.05.11.21.15;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2006.05.05.08.16.18;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2006.05.04.08.09.56;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2006.05.03.08.52.53;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2006.04.28.11.50.38;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2006.04.23.10.46.51;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2006.04.22.10.23.01;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2006.04.21.09.38.07;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2006.04.20.07.30.59;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2006.04.19.15.49.57;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2006.04.14.14.11.39;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2006.04.11.14.59.44;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2006.04.11.12.05.24;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2006.04.10.10.18.49;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2006.04.05.11.04.44;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2006.04.05.08.19.00;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2006.03.27.16.21.32;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2006.03.27.14.00.03;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.27.07.59.35;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2006.03.23.11.57.44;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2006.03.01.12.26.25;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2006.02.22.14.44.07;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2006.01.23.10.18.44;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2005.12.29.15.48.32;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2005.12.20.12.44.29;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2005.12.19.15.12.50;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.01.14.01.43;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2005.10.01.20.22.45;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2005.10.01.11.16.12;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.08.17.44.35;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2005.09.01.07.34.53;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2005.08.25.09.36.36;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2005.08.25.07.46.57;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2005.08.24.08.14.23;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.22.12.50.42;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.19.09.08.43;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2005.08.14.15.49.50;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.08.12.41.46;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2005.08.05.12.18.35;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2005.08.05.08.40.54;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2005.08.03.12.59.17;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.02.08.44.55;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2005.07.27.15.57.56;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.20.10.48.01;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.20.09.42.11;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2005.07.07.14.03.21;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2005.07.07.13.10.10;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.07.11.24.08;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2005.06.28.07.14.01;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2005.06.27.09.07.18;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.22.14.24.17;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2005.06.22.13.02.05;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2005.06.03.06.41.48;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.01.09.49.31;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.31.15.30.38;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.31.09.04.42;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.30.15.30.13;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.27.12.44.06;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.26.08.05.47;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.24.15.18.27;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.24.11.54.20;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.23.08.24.08;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.02.10.03.26;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.01.10.16.16;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.29.12.49.39;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2005.04.27.06.10.25;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.18.08.34.16;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.15.07.54.31;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.23.09.33.42;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.01.08.24.54;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.23.13.05.39;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.16.11.20.47;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.11.14.47.05;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.02.15.12.04;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.05.12.16.36;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.22.08.04.10;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.21.14.59.45;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.21.10.26.54;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.02.08.43.06;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.29.09.48.06;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.23.17.46.41;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.16.11.11.54;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.08.10.01.47;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.04.12.50.33;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.19.13.43.57;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.04.19.30.54;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.27.10.17.35;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.17.14.12.51;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.17.09.32.07;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.15.13.35.58;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.05.09.37.59;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.30.15.56.25;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.10.07.19.57;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.25.09.38.07;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.14.10.36.39;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;

1.121.2.1
date	2006.08.07.20.04.07;	author jfrijters;	state Exp;
branches;
next	;

1.166.2.1
date	2007.05.30.11.47.24;	author jfrijters;	state Exp;
branches;
next	1.166.2.2;

1.166.2.2
date	2007.05.30.11.55.15;	author jfrijters;	state Exp;
branches;
next	1.166.2.3;

1.166.2.3
date	2007.08.06.08.09.37;	author jfrijters;	state Exp;
branches;
next	;

1.187.2.1
date	2007.09.13.07.30.11;	author jfrijters;	state Exp;
branches;
next	1.187.2.2;

1.187.2.2
date	2007.09.20.13.54.23;	author jfrijters;	state Exp;
branches;
next	1.187.2.3;

1.187.2.3
date	2007.10.01.13.02.43;	author jfrijters;	state Exp;
branches;
next	1.187.2.4;

1.187.2.4
date	2007.10.12.16.18.41;	author jfrijters;	state Exp;
branches;
next	1.187.2.5;

1.187.2.5
date	2007.12.04.06.04.33;	author jfrijters;	state Exp;
branches;
next	1.187.2.6;

1.187.2.6
date	2008.01.14.04.58.33;	author jfrijters;	state Exp;
branches;
next	1.187.2.7;

1.187.2.7
date	2008.02.03.07.56.15;	author jfrijters;	state Exp;
branches;
next	1.187.2.8;

1.187.2.8
date	2008.02.26.07.53.37;	author jfrijters;	state Exp;
branches;
next	1.187.2.9;

1.187.2.9
date	2008.02.27.08.09.40;	author jfrijters;	state Exp;
branches;
next	1.187.2.10;

1.187.2.10
date	2008.02.28.06.19.49;	author jfrijters;	state Exp;
branches;
next	1.187.2.11;

1.187.2.11
date	2008.05.04.08.29.04;	author jfrijters;	state Exp;
branches;
next	1.187.2.12;

1.187.2.12
date	2008.11.05.07.52.01;	author jfrijters;	state Exp;
branches;
next	;

1.258.2.1
date	2008.11.04.05.29.20;	author jfrijters;	state Exp;
branches;
next	1.258.2.2;

1.258.2.2
date	2009.02.02.05.58.20;	author jfrijters;	state Exp;
branches;
next	;

1.283.2.1
date	2009.04.21.07.35.47;	author jfrijters;	state Exp;
branches;
next	1.283.2.2;

1.283.2.2
date	2009.04.22.04.50.22;	author jfrijters;	state Exp;
branches;
next	1.283.2.3;

1.283.2.3
date	2009.07.31.06.31.36;	author jfrijters;	state Exp;
branches;
next	;

1.317.2.1
date	2010.02.19.08.14.27;	author jfrijters;	state Exp;
branches;
next	;

1.363.2.1
date	2010.10.22.06.57.08;	author jfrijters;	state Exp;
branches;
next	;

1.373.2.1
date	2011.12.20.08.27.11;	author jfrijters;	state Exp;
branches;
next	1.373.2.2;

1.373.2.2
date	2011.12.20.09.29.27;	author jfrijters;	state Exp;
branches;
next	1.373.2.3;

1.373.2.3
date	2011.12.20.12.30.25;	author jfrijters;	state Exp;
branches;
next	1.373.2.4;

1.373.2.4
date	2011.12.20.13.22.39;	author jfrijters;	state Exp;
branches;
next	1.373.2.5;

1.373.2.5
date	2011.12.20.13.34.45;	author jfrijters;	state Exp;
branches;
next	1.373.2.6;

1.373.2.6
date	2012.10.03.06.18.57;	author jfrijters;	state Exp;
branches;
next	;

1.378.2.1
date	2012.01.03.12.16.37;	author jfrijters;	state Exp;
branches;
next	;

1.399.2.1
date	2012.06.12.10.22.04;	author jfrijters;	state Exp;
branches;
next	;

1.408.2.1
date	2012.09.17.11.17.31;	author jfrijters;	state Exp;
branches;
next	1.408.2.2;

1.408.2.2
date	2012.12.06.08.56.48;	author jfrijters;	state Exp;
branches;
next	;

1.488.2.1
date	2015.08.26.10.21.04;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.489
log
@Fix for #303. Don't crash when trying to get interfaces from type from missing assembly reference.
@
text
@/*
  Copyright (C) 2002-2015 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
#if STATIC_COMPILER || STUB_GENERATOR
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
#else
using System.Reflection;
using System.Reflection.Emit;
#endif
using System.Diagnostics;
using System.Security;
using System.Security.Permissions;
using IKVM.Attributes;

namespace IKVM.Internal
{
	static class StringConstants
	{
		internal static readonly string CLINIT = string.Intern("<clinit>");
		internal static readonly string INIT = string.Intern("<init>");
		internal static readonly string SIG_VOID = string.Intern("()V");
		internal static readonly string FINALIZE = string.Intern("finalize");
		internal static readonly string CLONE = string.Intern("clone");
	}

	struct ExModifiers
	{
		internal readonly Modifiers Modifiers;
		internal readonly bool IsInternal;

		internal ExModifiers(Modifiers modifiers, bool isInternal)
		{
			this.Modifiers = modifiers;
			this.IsInternal = isInternal;
		}
	}

	struct MethodParametersEntry
	{
		internal static readonly MethodParametersEntry[] Malformed = new MethodParametersEntry[0];
		internal string name;
		internal ushort flags;
	}

	static class AttributeHelper
	{
#if STATIC_COMPILER
		private static CustomAttributeBuilder ghostInterfaceAttribute;
		private static CustomAttributeBuilder deprecatedAttribute;
		private static CustomAttributeBuilder editorBrowsableNever;
		private static ConstructorInfo implementsAttribute;
		private static ConstructorInfo throwsAttribute;
		private static ConstructorInfo sourceFileAttribute;
		private static ConstructorInfo lineNumberTableAttribute1;
		private static ConstructorInfo lineNumberTableAttribute2;
		private static ConstructorInfo enclosingMethodAttribute;
		private static ConstructorInfo signatureAttribute;
		private static ConstructorInfo methodParametersAttribute;
		private static ConstructorInfo runtimeVisibleTypeAnnotationsAttribute;
		private static ConstructorInfo constantPoolAttribute;
		private static CustomAttributeBuilder paramArrayAttribute;
		private static ConstructorInfo nonNestedInnerClassAttribute;
		private static ConstructorInfo nonNestedOuterClassAttribute;
		private static readonly Type typeofModifiers = JVM.LoadType(typeof(Modifiers));
		private static readonly Type typeofSourceFileAttribute = JVM.LoadType(typeof(SourceFileAttribute));
		private static readonly Type typeofLineNumberTableAttribute = JVM.LoadType(typeof(LineNumberTableAttribute));
#endif // STATIC_COMPILER
		private static readonly Type typeofRemappedClassAttribute = JVM.LoadType(typeof(RemappedClassAttribute));
		private static readonly Type typeofRemappedTypeAttribute = JVM.LoadType(typeof(RemappedTypeAttribute));
		private static readonly Type typeofModifiersAttribute = JVM.LoadType(typeof(ModifiersAttribute));
		private static readonly Type typeofRemappedInterfaceMethodAttribute = JVM.LoadType(typeof(RemappedInterfaceMethodAttribute));
		private static readonly Type typeofNameSigAttribute = JVM.LoadType(typeof(NameSigAttribute));
		private static readonly Type typeofJavaModuleAttribute = JVM.LoadType(typeof(JavaModuleAttribute));
		private static readonly Type typeofSignatureAttribute = JVM.LoadType(typeof(SignatureAttribute));
		private static readonly Type typeofInnerClassAttribute = JVM.LoadType(typeof(InnerClassAttribute));
		private static readonly Type typeofImplementsAttribute = JVM.LoadType(typeof(ImplementsAttribute));
		private static readonly Type typeofGhostInterfaceAttribute = JVM.LoadType(typeof(GhostInterfaceAttribute));
		private static readonly Type typeofExceptionIsUnsafeForMappingAttribute = JVM.LoadType(typeof(ExceptionIsUnsafeForMappingAttribute));
		private static readonly Type typeofThrowsAttribute = JVM.LoadType(typeof(ThrowsAttribute));
		private static readonly Type typeofHideFromJavaAttribute = JVM.LoadType(typeof(HideFromJavaAttribute));
		private static readonly Type typeofHideFromJavaFlags = JVM.LoadType(typeof(HideFromJavaFlags));
		private static readonly Type typeofNoPackagePrefixAttribute = JVM.LoadType(typeof(NoPackagePrefixAttribute));
		private static readonly Type typeofAnnotationAttributeAttribute = JVM.LoadType(typeof(AnnotationAttributeAttribute));
		private static readonly Type typeofNonNestedInnerClassAttribute = JVM.LoadType(typeof(NonNestedInnerClassAttribute));
		private static readonly Type typeofNonNestedOuterClassAttribute = JVM.LoadType(typeof(NonNestedOuterClassAttribute));
		private static readonly Type typeofEnclosingMethodAttribute = JVM.LoadType(typeof(EnclosingMethodAttribute));
		private static readonly Type typeofMethodParametersAttribute = JVM.LoadType(typeof(MethodParametersAttribute));
		private static readonly Type typeofRuntimeVisibleTypeAnnotationsAttribute = JVM.LoadType(typeof(RuntimeVisibleTypeAnnotationsAttribute));
		private static readonly Type typeofConstantPoolAttribute = JVM.LoadType(typeof(ConstantPoolAttribute));
		private static readonly CustomAttributeBuilder hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
		private static readonly CustomAttributeBuilder hideFromReflection = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(new Type[] { typeofHideFromJavaFlags }), new object[] { HideFromJavaFlags.Reflection | HideFromJavaFlags.StackTrace | HideFromJavaFlags.StackWalk });

		// we don't want beforefieldinit
		static AttributeHelper() { }

#if STATIC_COMPILER
		private static object ParseValue(ClassLoaderWrapper loader, TypeWrapper tw, string val)
		{
			if(tw == CoreClasses.java.lang.String.Wrapper)
			{
				return val;
			}
			else if(tw.IsUnloadable)
			{
				throw new FatalCompilerErrorException(Message.MapFileTypeNotFound, tw.Name);
			}
			else if(tw.TypeAsTBD.IsEnum)
			{
				return EnumHelper.Parse(tw.TypeAsTBD, val);
			}
			else if(tw.TypeAsTBD == Types.Type)
			{
				TypeWrapper valtw = loader.LoadClassByDottedNameFast(val);
				if(valtw != null)
				{
					return valtw.TypeAsBaseType;
				}
				return StaticCompiler.Universe.GetType(val, true);
			}
			else if(tw == PrimitiveTypeWrapper.BOOLEAN)
			{
				return bool.Parse(val);
			}
			else if(tw == PrimitiveTypeWrapper.BYTE)
			{
				return (byte)sbyte.Parse(val);
			}
			else if(tw == PrimitiveTypeWrapper.CHAR)
			{
				return char.Parse(val);
			}
			else if(tw == PrimitiveTypeWrapper.SHORT)
			{
				return short.Parse(val);
			}
			else if(tw == PrimitiveTypeWrapper.INT)
			{
				return int.Parse(val);
			}
			else if(tw == PrimitiveTypeWrapper.FLOAT)
			{
				return float.Parse(val);
			}
			else if(tw == PrimitiveTypeWrapper.LONG)
			{
				return long.Parse(val);
			}
			else if(tw == PrimitiveTypeWrapper.DOUBLE)
			{
				return double.Parse(val);
			}
			else
			{
				throw new NotImplementedException();
			}
		}

		internal static void SetCustomAttribute(ClassLoaderWrapper loader, TypeBuilder tb, IKVM.Internal.MapXml.Attribute attr)
		{
			bool declarativeSecurity;
			CustomAttributeBuilder cab = CreateCustomAttribute(loader, attr, out declarativeSecurity);
			if (declarativeSecurity)
			{
				tb.__AddDeclarativeSecurity(cab);
			}
			else
			{
				tb.SetCustomAttribute(cab);
			}
		}

		internal static void SetCustomAttribute(ClassLoaderWrapper loader, FieldBuilder fb, IKVM.Internal.MapXml.Attribute attr)
		{
			fb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
		}

		internal static void SetCustomAttribute(ClassLoaderWrapper loader, ParameterBuilder pb, IKVM.Internal.MapXml.Attribute attr)
		{
			pb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
		}

		internal static void SetCustomAttribute(ClassLoaderWrapper loader, MethodBuilder mb, IKVM.Internal.MapXml.Attribute attr)
		{
			bool declarativeSecurity;
			CustomAttributeBuilder cab = CreateCustomAttribute(loader, attr, out declarativeSecurity);
			if (declarativeSecurity)
			{
				mb.__AddDeclarativeSecurity(cab);
			}
			else
			{
				mb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
			}
		}

		internal static void SetCustomAttribute(ClassLoaderWrapper loader, PropertyBuilder pb, IKVM.Internal.MapXml.Attribute attr)
		{
			pb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
		}

		internal static void SetCustomAttribute(ClassLoaderWrapper loader, AssemblyBuilder ab, IKVM.Internal.MapXml.Attribute attr)
		{
			ab.SetCustomAttribute(CreateCustomAttribute(loader, attr));
		}

		private static void GetAttributeArgsAndTypes(ClassLoaderWrapper loader, IKVM.Internal.MapXml.Attribute attr, out Type[] argTypes, out object[] args)
		{
			// TODO add error handling
			TypeWrapper[] twargs = loader.ArgTypeWrapperListFromSig(attr.Sig, LoadMode.Link);
			argTypes = new Type[twargs.Length];
			args = new object[argTypes.Length];
			for(int i = 0; i < twargs.Length; i++)
			{
				argTypes[i] = twargs[i].TypeAsSignatureType;
				TypeWrapper tw = twargs[i];
				if(tw == CoreClasses.java.lang.Object.Wrapper)
				{
					tw = loader.FieldTypeWrapperFromSig(attr.Params[i].Sig, LoadMode.Link);
				}
				if(tw.IsArray)
				{
					Array arr = Array.CreateInstance(Type.__GetSystemType(Type.GetTypeCode(tw.ElementTypeWrapper.TypeAsArrayType)), attr.Params[i].Elements.Length);
					for(int j = 0; j < arr.Length; j++)
					{
						arr.SetValue(ParseValue(loader, tw.ElementTypeWrapper, attr.Params[i].Elements[j].Value), j);
					}
					args[i] = arr;
				}
				else
				{
					args[i] = ParseValue(loader, tw, attr.Params[i].Value);
				}
			}
		}

		private static CustomAttributeBuilder CreateCustomAttribute(ClassLoaderWrapper loader, IKVM.Internal.MapXml.Attribute attr)
		{
			bool ignore;
			return CreateCustomAttribute(loader, attr, out ignore);
		}

		private static CustomAttributeBuilder CreateCustomAttribute(ClassLoaderWrapper loader, IKVM.Internal.MapXml.Attribute attr, out bool isDeclarativeSecurity)
		{
			// TODO add error handling
			Type[] argTypes;
			object[] args;
			GetAttributeArgsAndTypes(loader, attr, out argTypes, out args);
			if(attr.Type != null)
			{
				Type t = StaticCompiler.GetTypeForMapXml(loader, attr.Type);
				isDeclarativeSecurity = t.IsSubclassOf(Types.SecurityAttribute);
				ConstructorInfo ci = t.GetConstructor(argTypes);
				if(ci == null)
				{
					throw new InvalidOperationException(string.Format("Constructor missing: {0}::<init>{1}", attr.Type, attr.Sig));
				}
				PropertyInfo[] namedProperties;
				object[] propertyValues;
				if(attr.Properties != null)
				{
					namedProperties = new PropertyInfo[attr.Properties.Length];
					propertyValues = new object[attr.Properties.Length];
					for(int i = 0; i < namedProperties.Length; i++)
					{
						namedProperties[i] = t.GetProperty(attr.Properties[i].Name);
						propertyValues[i] = ParseValue(loader, loader.FieldTypeWrapperFromSig(attr.Properties[i].Sig, LoadMode.Link), attr.Properties[i].Value);
					}
				}
				else
				{
					namedProperties = new PropertyInfo[0];
					propertyValues = new object[0];
				}
				FieldInfo[] namedFields;
				object[] fieldValues;
				if(attr.Fields != null)
				{
					namedFields = new FieldInfo[attr.Fields.Length];
					fieldValues = new object[attr.Fields.Length];
					for(int i = 0; i < namedFields.Length; i++)
					{
						namedFields[i] = t.GetField(attr.Fields[i].Name);
						fieldValues[i] = ParseValue(loader, loader.FieldTypeWrapperFromSig(attr.Fields[i].Sig, LoadMode.Link), attr.Fields[i].Value);
					}
				}
				else
				{
					namedFields = new FieldInfo[0];
					fieldValues = new object[0];
				}
				return new CustomAttributeBuilder(ci, args, namedProperties, propertyValues, namedFields, fieldValues);
			}
			else
			{
				if(attr.Properties != null)
				{
					throw new NotImplementedException("Setting property values on Java attributes is not implemented");
				}
				TypeWrapper t = loader.LoadClassByDottedName(attr.Class);
				isDeclarativeSecurity = t.TypeAsBaseType.IsSubclassOf(Types.SecurityAttribute);
				FieldInfo[] namedFields;
				object[] fieldValues;
				if(attr.Fields != null)
				{
					namedFields = new FieldInfo[attr.Fields.Length];
					fieldValues = new object[attr.Fields.Length];
					for(int i = 0; i < namedFields.Length; i++)
					{
						FieldWrapper fw = t.GetFieldWrapper(attr.Fields[i].Name, attr.Fields[i].Sig);
						fw.Link();
						namedFields[i] = fw.GetField();
						fieldValues[i] = ParseValue(loader, loader.FieldTypeWrapperFromSig(attr.Fields[i].Sig, LoadMode.Link), attr.Fields[i].Value);
					}
				}
				else
				{
					namedFields = new FieldInfo[0];
					fieldValues = new object[0];
				}
				MethodWrapper mw = t.GetMethodWrapper("<init>", attr.Sig, false);
				if (mw == null)
				{
					throw new InvalidOperationException(string.Format("Constructor missing: {0}::<init>{1}", attr.Class, attr.Sig));
				}
				mw.Link();
				ConstructorInfo ci = (mw.GetMethod() as ConstructorInfo) ?? ((MethodInfo)mw.GetMethod()).__AsConstructorInfo();
				return new CustomAttributeBuilder(ci, args, namedFields, fieldValues);
			}
		}

		private static CustomAttributeBuilder GetEditorBrowsableNever()
		{
			if (editorBrowsableNever == null)
			{
				// to avoid having to load (and find) System.dll, we construct a symbolic CustomAttributeBuilder
				AssemblyName name = Types.Object.Assembly.GetName();
				name.Name = "System";
				Universe u = StaticCompiler.Universe;
				Type typeofEditorBrowsableAttribute = u.ResolveType(Types.Object.Assembly, "System.ComponentModel.EditorBrowsableAttribute, " + name.FullName);
				Type typeofEditorBrowsableState = u.ResolveType(Types.Object.Assembly, "System.ComponentModel.EditorBrowsableState, " + name.FullName);
				u.MissingTypeIsValueType += delegate(Type type) { return type == typeofEditorBrowsableState; };
				ConstructorInfo ctor = (ConstructorInfo)typeofEditorBrowsableAttribute.__CreateMissingMethod(ConstructorInfo.ConstructorName,
					CallingConventions.Standard | CallingConventions.HasThis, null, default(CustomModifiers), new Type[] { typeofEditorBrowsableState }, null);
				editorBrowsableNever = CustomAttributeBuilder.__FromBlob(ctor, new byte[] { 01, 00, 01, 00, 00, 00, 00, 00 });
			}
			return editorBrowsableNever;
		}

		internal static void SetEditorBrowsableNever(TypeBuilder tb)
		{
			tb.SetCustomAttribute(GetEditorBrowsableNever());
		}

		internal static void SetEditorBrowsableNever(MethodBuilder mb)
		{
			mb.SetCustomAttribute(GetEditorBrowsableNever());
		}

		internal static void SetEditorBrowsableNever(PropertyBuilder pb)
		{
			pb.SetCustomAttribute(GetEditorBrowsableNever());
		}

		internal static void SetDeprecatedAttribute(MethodBuilder mb)
		{
			if(deprecatedAttribute == null)
			{
				deprecatedAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
			}
			mb.SetCustomAttribute(deprecatedAttribute);
		}

		internal static void SetDeprecatedAttribute(TypeBuilder tb)
		{
			if(deprecatedAttribute == null)
			{
				deprecatedAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
			}
			tb.SetCustomAttribute(deprecatedAttribute);
		}

		internal static void SetDeprecatedAttribute(FieldBuilder fb)
		{
			if(deprecatedAttribute == null)
			{
				deprecatedAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
			}
			fb.SetCustomAttribute(deprecatedAttribute);
		}

		internal static void SetDeprecatedAttribute(PropertyBuilder pb)
		{
			if(deprecatedAttribute == null)
			{
				deprecatedAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
			}
			pb.SetCustomAttribute(deprecatedAttribute);
		}

		internal static void SetThrowsAttribute(MethodBuilder mb, string[] exceptions)
		{
			if(exceptions != null && exceptions.Length != 0)
			{
				if(throwsAttribute == null)
				{
					throwsAttribute = typeofThrowsAttribute.GetConstructor(new Type[] { JVM.Import(typeof(string[])) });
				}
				exceptions = UnicodeUtil.EscapeInvalidSurrogates(exceptions);
				mb.SetCustomAttribute(new CustomAttributeBuilder(throwsAttribute, new object[] { exceptions }));
			}
		}

		internal static void SetGhostInterface(TypeBuilder typeBuilder)
		{
			if(ghostInterfaceAttribute == null)
			{
				ghostInterfaceAttribute = new CustomAttributeBuilder(typeofGhostInterfaceAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			}
			typeBuilder.SetCustomAttribute(ghostInterfaceAttribute);
		}

		internal static void SetNonNestedInnerClass(TypeBuilder typeBuilder, string className)
		{
			if(nonNestedInnerClassAttribute == null)
			{
				nonNestedInnerClassAttribute = typeofNonNestedInnerClassAttribute.GetConstructor(new Type[] { Types.String });
			}
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(nonNestedInnerClassAttribute,
				new object[] { UnicodeUtil.EscapeInvalidSurrogates(className) }));
		}

		internal static void SetNonNestedOuterClass(TypeBuilder typeBuilder, string className)
		{
			if(nonNestedOuterClassAttribute == null)
			{
				nonNestedOuterClassAttribute = typeofNonNestedOuterClassAttribute.GetConstructor(new Type[] { Types.String });
			}
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(nonNestedOuterClassAttribute,
				new object[] { UnicodeUtil.EscapeInvalidSurrogates(className) }));
		}
#endif // STATIC_COMPILER

		internal static void HideFromReflection(MethodBuilder mb)
		{
			mb.SetCustomAttribute(hideFromReflection);
		}

		internal static void HideFromReflection(FieldBuilder fb)
		{
			fb.SetCustomAttribute(hideFromReflection);
		}

		internal static void HideFromReflection(PropertyBuilder pb)
		{
			pb.SetCustomAttribute(hideFromReflection);
		}

		internal static void HideFromJava(TypeBuilder typeBuilder)
		{
			typeBuilder.SetCustomAttribute(hideFromJavaAttribute);
		}

		internal static void HideFromJava(MethodBuilder mb)
		{
			mb.SetCustomAttribute(hideFromJavaAttribute);
		}

		internal static void HideFromJava(MethodBuilder mb, HideFromJavaFlags flags)
		{
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(new Type[] { typeofHideFromJavaFlags }), new object[] { flags });
			mb.SetCustomAttribute(cab);
		}

		internal static void HideFromJava(FieldBuilder fb)
		{
			fb.SetCustomAttribute(hideFromJavaAttribute);
		}

#if STATIC_COMPILER
		internal static void HideFromJava(PropertyBuilder pb)
		{
			pb.SetCustomAttribute(hideFromJavaAttribute);
		}
#endif // STATIC_COMPILER

		internal static bool IsHideFromJava(Type type)
		{
			return type.IsDefined(typeofHideFromJavaAttribute, false)
				|| (type.IsNested && (type.DeclaringType.IsDefined(typeofHideFromJavaAttribute, false) || type.Name.StartsWith("__<", StringComparison.Ordinal)));
		}

		internal static bool IsHideFromJava(MemberInfo mi)
		{
			return (GetHideFromJavaFlags(mi) & HideFromJavaFlags.Code) != 0;
		}

		internal static HideFromJavaFlags GetHideFromJavaFlags(MemberInfo mi)
		{
			// NOTE all privatescope fields and methods are "hideFromJava"
			// because Java cannot deal with the potential name clashes
			FieldInfo fi = mi as FieldInfo;
			if(fi != null && (fi.Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.PrivateScope)
			{
				return HideFromJavaFlags.All;
			}
			MethodBase mb = mi as MethodBase;
			if(mb != null && (mb.Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.PrivateScope)
			{
				return HideFromJavaFlags.All;
			}
			if (mi.Name.StartsWith("__<", StringComparison.Ordinal))
			{
				return HideFromJavaFlags.All;
			}
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = mi.GetCustomAttributes(typeofHideFromJavaAttribute, false);
			if (attr.Length == 1)
			{
				return ((HideFromJavaAttribute)attr[0]).Flags;
			}
#else
			IList<CustomAttributeData> attr = CustomAttributeData.__GetCustomAttributes(mi, typeofHideFromJavaAttribute, false);
			if(attr.Count == 1)
			{
				IList<CustomAttributeTypedArgument> args = attr[0].ConstructorArguments;
				if(args.Count == 1)
				{
					return (HideFromJavaFlags)args[0].Value;
				}
				return HideFromJavaFlags.All;
			}
#endif
			return HideFromJavaFlags.None;
		}

#if STATIC_COMPILER
		internal static void SetImplementsAttribute(TypeBuilder typeBuilder, TypeWrapper[] ifaceWrappers)
		{
			string[] interfaces = new string[ifaceWrappers.Length];
			for(int i = 0; i < interfaces.Length; i++)
			{
				interfaces[i] = UnicodeUtil.EscapeInvalidSurrogates(ifaceWrappers[i].Name);
			}
			if(implementsAttribute == null)
			{
				implementsAttribute = typeofImplementsAttribute.GetConstructor(new Type[] { JVM.Import(typeof(string[])) });
			}
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(implementsAttribute, new object[] { interfaces }));
		}
#endif

		internal static bool IsGhostInterface(Type type)
		{
			return type.IsDefined(typeofGhostInterfaceAttribute, false);
		}

		internal static bool IsRemappedType(Type type)
		{
			return type.IsDefined(typeofRemappedTypeAttribute, false);
		}

		internal static bool IsExceptionIsUnsafeForMapping(Type type)
		{
			return type.IsDefined(typeofExceptionIsUnsafeForMappingAttribute, false);
		}

		internal static ModifiersAttribute GetModifiersAttribute(MemberInfo member)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = member.GetCustomAttributes(typeof(ModifiersAttribute), false);
			return attr.Length == 1 ? (ModifiersAttribute)attr[0] : null;
#else
			IList<CustomAttributeData> attr = CustomAttributeData.__GetCustomAttributes(member, typeofModifiersAttribute, false);
			if(attr.Count == 1)
			{
				IList<CustomAttributeTypedArgument> args = attr[0].ConstructorArguments;
				if(args.Count == 2)
				{
					return new ModifiersAttribute((Modifiers)args[0].Value, (bool)args[1].Value);
				}
				return new ModifiersAttribute((Modifiers)args[0].Value);
			}
			return null;
#endif
		}

		internal static ExModifiers GetModifiers(MethodBase mb, bool assemblyIsPrivate)
		{
			ModifiersAttribute attr = GetModifiersAttribute(mb);
			if(attr != null)
			{
				return new ExModifiers(attr.Modifiers, attr.IsInternal);
			}
			Modifiers modifiers = 0;
			if(mb.IsPublic)
			{
				modifiers |= Modifiers.Public;
			}
			else if(mb.IsPrivate)
			{
				modifiers |= Modifiers.Private;
			}
			else if(mb.IsFamily || mb.IsFamilyOrAssembly)
			{
				modifiers |= Modifiers.Protected;
			}
			else if(assemblyIsPrivate)
			{
				modifiers |= Modifiers.Private;
			}
			// NOTE Java doesn't support non-virtual methods, but we set the Final modifier for
			// non-virtual methods to approximate the semantics
			if((mb.IsFinal || (!mb.IsVirtual && ((modifiers & Modifiers.Private) == 0))) && !mb.IsStatic && !mb.IsConstructor)
			{
				modifiers |= Modifiers.Final;
			}
			if(mb.IsAbstract)
			{
				modifiers |= Modifiers.Abstract;
			}
			else
			{
				// Some .NET interfaces (like System._AppDomain) have synchronized methods,
				// Java doesn't allow synchronized on an abstract methods, so we ignore it for
				// abstract methods.
				if((mb.GetMethodImplementationFlags() & MethodImplAttributes.Synchronized) != 0)
				{
					modifiers |= Modifiers.Synchronized;
				}
			}
			if(mb.IsStatic)
			{
				modifiers |= Modifiers.Static;
			}
			if((mb.Attributes & MethodAttributes.PinvokeImpl) != 0)
			{
				modifiers |= Modifiers.Native;
			}
			ParameterInfo[] parameters = mb.GetParameters();
			if(parameters.Length > 0 && parameters[parameters.Length - 1].IsDefined(JVM.Import(typeof(ParamArrayAttribute)), false))
			{
				modifiers |= Modifiers.VarArgs;
			}
			return new ExModifiers(modifiers, false);
		}

		internal static ExModifiers GetModifiers(FieldInfo fi, bool assemblyIsPrivate)
		{
			ModifiersAttribute attr = GetModifiersAttribute(fi);
			if(attr != null)
			{
				return new ExModifiers(attr.Modifiers, attr.IsInternal);
			}
			Modifiers modifiers = 0;
			if(fi.IsPublic)
			{
				modifiers |= Modifiers.Public;
			}
			else if(fi.IsPrivate)
			{
				modifiers |= Modifiers.Private;
			}
			else if(fi.IsFamily || fi.IsFamilyOrAssembly)
			{
				modifiers |= Modifiers.Protected;
			}
			else if(assemblyIsPrivate)
			{
				modifiers |= Modifiers.Private;
			}
			if(fi.IsInitOnly || fi.IsLiteral)
			{
				modifiers |= Modifiers.Final;
			}
			if(fi.IsNotSerialized)
			{
				modifiers |= Modifiers.Transient;
			}
			if(fi.IsStatic)
			{
				modifiers |= Modifiers.Static;
			}
			if(Array.IndexOf(fi.GetRequiredCustomModifiers(), Types.IsVolatile) != -1)
			{
				modifiers |= Modifiers.Volatile;
			}
			return new ExModifiers(modifiers, false);
		}

#if STATIC_COMPILER
		internal static void SetModifiers(MethodBuilder mb, Modifiers modifiers, bool isInternal)
		{
			CustomAttributeBuilder customAttributeBuilder;
			if (isInternal)
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, Types.Boolean }), new object[] { modifiers, isInternal });
			}
			else
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers }), new object[] { modifiers });
			}
			mb.SetCustomAttribute(customAttributeBuilder);
		}

		internal static void SetModifiers(FieldBuilder fb, Modifiers modifiers, bool isInternal)
		{
			CustomAttributeBuilder customAttributeBuilder;
			if (isInternal)
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, Types.Boolean }), new object[] { modifiers, isInternal });
			}
			else
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers }), new object[] { modifiers });
			}
			fb.SetCustomAttribute(customAttributeBuilder);
		}

		internal static void SetModifiers(PropertyBuilder pb, Modifiers modifiers, bool isInternal)
		{
			CustomAttributeBuilder customAttributeBuilder;
			if (isInternal)
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, Types.Boolean }), new object[] { modifiers, isInternal });
			}
			else
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers }), new object[] { modifiers });
			}
			pb.SetCustomAttribute(customAttributeBuilder);
		}

		internal static void SetModifiers(TypeBuilder tb, Modifiers modifiers, bool isInternal)
		{
			CustomAttributeBuilder customAttributeBuilder;
			if (isInternal)
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, Types.Boolean }), new object[] { modifiers, isInternal });
			}
			else
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers }), new object[] { modifiers });
			}
			tb.SetCustomAttribute(customAttributeBuilder);
		}

		internal static void SetNameSig(MethodBuilder mb, string name, string sig)
		{
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofNameSigAttribute.GetConstructor(new Type[] { Types.String, Types.String }),
				new object[] { UnicodeUtil.EscapeInvalidSurrogates(name), UnicodeUtil.EscapeInvalidSurrogates(sig) });
			mb.SetCustomAttribute(customAttributeBuilder);
		}

		internal static void SetInnerClass(TypeBuilder typeBuilder, string innerClass, Modifiers modifiers)
		{
			Type[] argTypes = new Type[] { Types.String, typeofModifiers };
			object[] args = new object[] { UnicodeUtil.EscapeInvalidSurrogates(innerClass), modifiers };
			ConstructorInfo ci = typeofInnerClassAttribute.GetConstructor(argTypes);
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ci, args);
			typeBuilder.SetCustomAttribute(customAttributeBuilder);
		}

		internal static void SetSourceFile(TypeBuilder typeBuilder, string filename)
		{
			if(sourceFileAttribute == null)
			{
				sourceFileAttribute = typeofSourceFileAttribute.GetConstructor(new Type[] { Types.String });
			}
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(sourceFileAttribute, new object[] { filename }));
		}

		internal static void SetSourceFile(ModuleBuilder moduleBuilder, string filename)
		{
			if(sourceFileAttribute == null)
			{
				sourceFileAttribute = typeofSourceFileAttribute.GetConstructor(new Type[] { Types.String });
			}
			moduleBuilder.SetCustomAttribute(new CustomAttributeBuilder(sourceFileAttribute, new object[] { filename }));
		}

		internal static void SetLineNumberTable(MethodBuilder mb, IKVM.Attributes.LineNumberTableAttribute.LineNumberWriter writer)
		{
			object arg;
			ConstructorInfo con;
			if(writer.Count == 1)
			{
				if(lineNumberTableAttribute2 == null)
				{
					lineNumberTableAttribute2 = typeofLineNumberTableAttribute.GetConstructor(new Type[] { Types.UInt16 });
				}
				con = lineNumberTableAttribute2;
				arg = (ushort)writer.LineNo;
			}
			else
			{
				if(lineNumberTableAttribute1 == null)
				{
					lineNumberTableAttribute1 = typeofLineNumberTableAttribute.GetConstructor(new Type[] { JVM.Import(typeof(byte[])) });
				}
				con = lineNumberTableAttribute1;
				arg = writer.ToArray();
			}
			mb.SetCustomAttribute(new CustomAttributeBuilder(con, new object[] { arg }));
		}

		internal static void SetEnclosingMethodAttribute(TypeBuilder tb, string className, string methodName, string methodSig)
		{
			if(enclosingMethodAttribute == null)
			{
				enclosingMethodAttribute = typeofEnclosingMethodAttribute.GetConstructor(new Type[] { Types.String, Types.String, Types.String });
			}
			tb.SetCustomAttribute(new CustomAttributeBuilder(enclosingMethodAttribute,
				new object[] { UnicodeUtil.EscapeInvalidSurrogates(className), UnicodeUtil.EscapeInvalidSurrogates(methodName), UnicodeUtil.EscapeInvalidSurrogates(methodSig) }));
		}

		internal static void SetSignatureAttribute(TypeBuilder tb, string signature)
		{
			if(signatureAttribute == null)
			{
				signatureAttribute = typeofSignatureAttribute.GetConstructor(new Type[] { Types.String });
			}
			tb.SetCustomAttribute(new CustomAttributeBuilder(signatureAttribute,
				new object[] { UnicodeUtil.EscapeInvalidSurrogates(signature) }));
		}

		internal static void SetSignatureAttribute(FieldBuilder fb, string signature)
		{
			if(signatureAttribute == null)
			{
				signatureAttribute = typeofSignatureAttribute.GetConstructor(new Type[] { Types.String });
			}
			fb.SetCustomAttribute(new CustomAttributeBuilder(signatureAttribute,
				new object[] { UnicodeUtil.EscapeInvalidSurrogates(signature) }));
		}

		internal static void SetSignatureAttribute(MethodBuilder mb, string signature)
		{
			if(signatureAttribute == null)
			{
				signatureAttribute = typeofSignatureAttribute.GetConstructor(new Type[] { Types.String });
			}
			mb.SetCustomAttribute(new CustomAttributeBuilder(signatureAttribute,
				new object[] { UnicodeUtil.EscapeInvalidSurrogates(signature) }));
		}

		internal static void SetMethodParametersAttribute(MethodBuilder mb, Modifiers[] modifiers)
		{
			if(methodParametersAttribute == null)
			{
				methodParametersAttribute = typeofMethodParametersAttribute.GetConstructor(new Type[] { typeofModifiers.MakeArrayType() });
			}
			mb.SetCustomAttribute(new CustomAttributeBuilder(methodParametersAttribute, new object[] { modifiers }));
		}

		internal static void SetRuntimeVisibleTypeAnnotationsAttribute(TypeBuilder tb, byte[] data)
		{
			if(runtimeVisibleTypeAnnotationsAttribute == null)
			{
				runtimeVisibleTypeAnnotationsAttribute = typeofRuntimeVisibleTypeAnnotationsAttribute.GetConstructor(new Type[] { Types.Byte.MakeArrayType() });
			}
			tb.SetCustomAttribute(new CustomAttributeBuilder(runtimeVisibleTypeAnnotationsAttribute, new object[] { data }));
		}

		internal static void SetRuntimeVisibleTypeAnnotationsAttribute(FieldBuilder fb, byte[] data)
		{
			if(runtimeVisibleTypeAnnotationsAttribute == null)
			{
				runtimeVisibleTypeAnnotationsAttribute = typeofRuntimeVisibleTypeAnnotationsAttribute.GetConstructor(new Type[] { Types.Byte.MakeArrayType() });
			}
			fb.SetCustomAttribute(new CustomAttributeBuilder(runtimeVisibleTypeAnnotationsAttribute, new object[] { data }));
		}

		internal static void SetRuntimeVisibleTypeAnnotationsAttribute(MethodBuilder mb, byte[] data)
		{
			if(runtimeVisibleTypeAnnotationsAttribute == null)
			{
				runtimeVisibleTypeAnnotationsAttribute = typeofRuntimeVisibleTypeAnnotationsAttribute.GetConstructor(new Type[] { Types.Byte.MakeArrayType() });
			}
			mb.SetCustomAttribute(new CustomAttributeBuilder(runtimeVisibleTypeAnnotationsAttribute, new object[] { data }));
		}

		internal static void SetConstantPoolAttribute(TypeBuilder tb, object[] constantPool)
		{
			if(constantPoolAttribute == null)
			{
				constantPoolAttribute = typeofConstantPoolAttribute.GetConstructor(new Type[] { Types.Object.MakeArrayType() });
			}
			tb.SetCustomAttribute(new CustomAttributeBuilder(constantPoolAttribute, new object[] { constantPool }));
		}

		internal static void SetParamArrayAttribute(ParameterBuilder pb)
		{
			if(paramArrayAttribute == null)
			{
				paramArrayAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ParamArrayAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
			}
			pb.SetCustomAttribute(paramArrayAttribute);
		}
#endif  // STATIC_COMPILER

		internal static NameSigAttribute GetNameSig(MemberInfo member)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = member.GetCustomAttributes(typeof(NameSigAttribute), false);
			return attr.Length == 1 ? (NameSigAttribute)attr[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(member, typeofNameSigAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new NameSigAttribute((string)args[0].Value, (string)args[1].Value);
			}
			return null;
#endif
		}

		internal static T[] DecodeArray<T>(CustomAttributeTypedArgument arg)
		{
			IList<CustomAttributeTypedArgument> elems = (IList<CustomAttributeTypedArgument>)arg.Value;
			T[] arr = new T[elems.Count];
			for(int i = 0; i < arr.Length; i++)
			{
				arr[i] = (T)elems[i].Value;
			}
			return arr;
		}

		internal static ImplementsAttribute GetImplements(Type type)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = type.GetCustomAttributes(typeof(ImplementsAttribute), false);
			return attribs.Length == 1 ? (ImplementsAttribute)attribs[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type, typeofImplementsAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new ImplementsAttribute(DecodeArray<string>(args[0]));
			}
			return null;
#endif
		}

		internal static ThrowsAttribute GetThrows(MethodBase mb)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = mb.GetCustomAttributes(typeof(ThrowsAttribute), false);
			return attribs.Length == 1 ? (ThrowsAttribute)attribs[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(mb, typeofThrowsAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				if (args[0].ArgumentType == Types.String.MakeArrayType())
				{
					return new ThrowsAttribute(DecodeArray<string>(args[0]));
				}
				else if (args[0].ArgumentType == Types.Type.MakeArrayType())
				{
					return new ThrowsAttribute(DecodeArray<Type>(args[0]));
				}
				else
				{
					return new ThrowsAttribute((Type)args[0].Value);
				}
			}
			return null;
#endif
		}

		internal static string[] GetNonNestedInnerClasses(Type t)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = t.GetCustomAttributes(typeof(NonNestedInnerClassAttribute), false);
			string[] classes = new string[attribs.Length];
			for (int i = 0; i < attribs.Length; i++)
			{
				classes[i] = ((NonNestedInnerClassAttribute)attribs[i]).InnerClassName;
			}
			return classes;
#else
			List<string> list = new List<string>();
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(t, typeofNonNestedInnerClassAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				list.Add(UnicodeUtil.UnescapeInvalidSurrogates((string)args[0].Value));
			}
			return list.ToArray();
#endif
		}

		internal static string GetNonNestedOuterClasses(Type t)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = t.GetCustomAttributes(typeof(NonNestedOuterClassAttribute), false);
			return attribs.Length == 1 ? ((NonNestedOuterClassAttribute)attribs[0]).OuterClassName : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(t, typeofNonNestedOuterClassAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return UnicodeUtil.UnescapeInvalidSurrogates((string)args[0].Value);
			}
			return null;
#endif
		}

		internal static SignatureAttribute GetSignature(MemberInfo member)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = member.GetCustomAttributes(typeof(SignatureAttribute), false);
			return attribs.Length == 1 ? (SignatureAttribute)attribs[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(member, typeofSignatureAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new SignatureAttribute((string)args[0].Value);
			}
			return null;
#endif
		}

		internal static MethodParametersAttribute GetMethodParameters(MethodBase method)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = method.GetCustomAttributes(typeof(MethodParametersAttribute), false);
			return attribs.Length == 1 ? (MethodParametersAttribute)attribs[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(method, typeofMethodParametersAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new MethodParametersAttribute(DecodeArray<Modifiers>(args[0]));
			}
			return null;
#endif
		}

		internal static object[] GetConstantPool(Type type)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = type.GetCustomAttributes(typeof(ConstantPoolAttribute), false);
			return attribs.Length == 1 ? ((ConstantPoolAttribute)attribs[0]).constantPool : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type, typeofConstantPoolAttribute, false))
			{
				return ConstantPoolAttribute.Decompress(DecodeArray<object>(cad.ConstructorArguments[0]));
			}
			return null;
#endif
		}

		internal static byte[] GetRuntimeVisibleTypeAnnotations(MemberInfo member)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = member.GetCustomAttributes(typeof(RuntimeVisibleTypeAnnotationsAttribute), false);
			return attribs.Length == 1 ? ((RuntimeVisibleTypeAnnotationsAttribute)attribs[0]).data : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(member, typeofRuntimeVisibleTypeAnnotationsAttribute, false))
			{
				return DecodeArray<byte>(cad.ConstructorArguments[0]);
			}
			return null;
#endif
		}

		internal static InnerClassAttribute GetInnerClass(Type type)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
			return attribs.Length == 1 ? (InnerClassAttribute)attribs[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type, typeofInnerClassAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new InnerClassAttribute((string)args[0].Value, (Modifiers)args[1].Value);
			}
			return null;
#endif
		}

		internal static RemappedInterfaceMethodAttribute[] GetRemappedInterfaceMethods(Type type)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = type.GetCustomAttributes(typeof(RemappedInterfaceMethodAttribute), false);
			RemappedInterfaceMethodAttribute[] attr1 = new RemappedInterfaceMethodAttribute[attr.Length];
			Array.Copy(attr, attr1, attr.Length);
			return attr1;
#else
			List<RemappedInterfaceMethodAttribute> attrs = new List<RemappedInterfaceMethodAttribute>();
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type, typeofRemappedInterfaceMethodAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				attrs.Add(new RemappedInterfaceMethodAttribute((string)args[0].Value, (string)args[1].Value, DecodeArray<string>(args[2])));
			}
			return attrs.ToArray();
#endif
		}

		internal static RemappedTypeAttribute GetRemappedType(Type type)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
			return attribs.Length == 1 ? (RemappedTypeAttribute)attribs[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type, typeofRemappedTypeAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new RemappedTypeAttribute((Type)args[0].Value);
			}
			return null;
#endif
		}

		internal static RemappedClassAttribute[] GetRemappedClasses(Assembly coreAssembly)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = coreAssembly.GetCustomAttributes(typeof(RemappedClassAttribute), false);
			RemappedClassAttribute[] attr1 = new RemappedClassAttribute[attr.Length];
			Array.Copy(attr, attr1, attr.Length);
			return attr1;
#else
			List<RemappedClassAttribute> attrs = new List<RemappedClassAttribute>();
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(coreAssembly, typeofRemappedClassAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				attrs.Add(new RemappedClassAttribute((string)args[0].Value, (Type)args[1].Value));
			}
			return attrs.ToArray();
#endif
		}

		internal static string GetAnnotationAttributeType(Type type)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = type.GetCustomAttributes(typeof(AnnotationAttributeAttribute), false);
			if(attr.Length == 1)
			{
				return ((AnnotationAttributeAttribute)attr[0]).AttributeType;
			}
			return null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type, typeofAnnotationAttributeAttribute, false))
			{
				return UnicodeUtil.UnescapeInvalidSurrogates((string)cad.ConstructorArguments[0].Value);
			}
			return null;
#endif
		}

		internal static AssemblyName[] GetInternalsVisibleToAttributes(Assembly assembly)
		{
			List<AssemblyName> list = new List<AssemblyName>();
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(assembly))
			{
				if(cad.Constructor.DeclaringType == JVM.Import(typeof(System.Runtime.CompilerServices.InternalsVisibleToAttribute)))
				{
					try
					{
						list.Add(new AssemblyName((string)cad.ConstructorArguments[0].Value));
					}
					catch
					{
						// HACK since there is no list of exception that the AssemblyName constructor can throw, we simply catch all
					}
				}
			}
			return list.ToArray();
		}

		internal static bool IsJavaModule(Module mod)
		{
			return mod.IsDefined(typeofJavaModuleAttribute, false);
		}

		internal static object[] GetJavaModuleAttributes(Module mod)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			return mod.GetCustomAttributes(typeofJavaModuleAttribute, false);
#else
			List<JavaModuleAttribute> attrs = new List<JavaModuleAttribute>();
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(mod, typeofJavaModuleAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				if(args.Count == 0)
				{
					attrs.Add(new JavaModuleAttribute());
				}
				else
				{
					attrs.Add(new JavaModuleAttribute(DecodeArray<string>(args[0])));
				}
			}
			return attrs.ToArray();
#endif
		}

		internal static bool IsNoPackagePrefix(Type type)
		{
			return type.IsDefined(typeofNoPackagePrefixAttribute, false) || type.Assembly.IsDefined(typeofNoPackagePrefixAttribute, false);
		}

		internal static bool HasEnclosingMethodAttribute(Type type)
		{
			return type.IsDefined(typeofEnclosingMethodAttribute, false);
		}

		internal static EnclosingMethodAttribute GetEnclosingMethodAttribute(Type type)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = type.GetCustomAttributes(typeof(EnclosingMethodAttribute), false);
			if (attr.Length == 1)
			{
				return ((EnclosingMethodAttribute)attr[0]).SetClassName(type);
			}
			return null;
#else
			foreach (CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type, typeofEnclosingMethodAttribute, false))
			{
				return new EnclosingMethodAttribute((string)cad.ConstructorArguments[0].Value, (string)cad.ConstructorArguments[1].Value, (string)cad.ConstructorArguments[2].Value).SetClassName(type);
			}
			return null;
#endif
		}

#if STATIC_COMPILER
		internal static void SetRemappedClass(AssemblyBuilder assemblyBuilder, string name, Type shadowType)
		{
			ConstructorInfo remappedClassAttribute = typeofRemappedClassAttribute.GetConstructor(new Type[] { Types.String, Types.Type });
			assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(remappedClassAttribute, new object[] { name, shadowType }));
		}

		internal static void SetRemappedType(TypeBuilder typeBuilder, Type shadowType)
		{
			ConstructorInfo remappedTypeAttribute = typeofRemappedTypeAttribute.GetConstructor(new Type[] { Types.Type });
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(remappedTypeAttribute, new object[] { shadowType }));
		}

		internal static void SetRemappedInterfaceMethod(TypeBuilder typeBuilder, string name, string mappedTo, string[] throws)
		{
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofRemappedInterfaceMethodAttribute.GetConstructor(new Type[] { Types.String, Types.String, Types.String.MakeArrayType() }), new object[] { name, mappedTo, throws });
			typeBuilder.SetCustomAttribute(cab);
		}

		internal static void SetExceptionIsUnsafeForMapping(TypeBuilder typeBuilder)
		{
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofExceptionIsUnsafeForMappingAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			typeBuilder.SetCustomAttribute(cab);
		}
#endif // STATIC_COMPILER

		internal static void SetRuntimeCompatibilityAttribute(AssemblyBuilder assemblyBuilder)
		{
			Type runtimeCompatibilityAttribute = JVM.Import(typeof(System.Runtime.CompilerServices.RuntimeCompatibilityAttribute));
			assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(
				runtimeCompatibilityAttribute.GetConstructor(Type.EmptyTypes), new object[0],
				new PropertyInfo[] { runtimeCompatibilityAttribute.GetProperty("WrapNonExceptionThrows") }, new object[] { true },
				new FieldInfo[0], new object[0]));
		}

		internal static void SetInternalsVisibleToAttribute(AssemblyBuilder assemblyBuilder, string assemblyName)
		{
			Type internalsVisibleToAttribute = JVM.Import(typeof(System.Runtime.CompilerServices.InternalsVisibleToAttribute));
			CustomAttributeBuilder cab = new CustomAttributeBuilder(
				internalsVisibleToAttribute.GetConstructor(new Type[] { Types.String }), new object[] { assemblyName });
			assemblyBuilder.SetCustomAttribute(cab);
		}
	}

	static class EnumHelper
	{
		internal static Type GetUnderlyingType(Type enumType)
		{
#if STATIC_COMPILER || STUB_GENERATOR
			return enumType.GetEnumUnderlyingType();
#else
			return Enum.GetUnderlyingType(enumType);
#endif
		}

#if STATIC_COMPILER
		internal static object Parse(Type type, string value)
		{
			object retval = null;
			foreach (string str in value.Split(','))
			{
				FieldInfo field = type.GetField(str.Trim(), BindingFlags.Public | BindingFlags.Static);
				if (field == null)
				{
					throw new InvalidOperationException("Enum value '" + str + "' not found in " + type.FullName);
				}
				if (retval == null)
				{
					retval = field.GetRawConstantValue();
				}
				else
				{
					retval = OrBoxedIntegrals(retval, field.GetRawConstantValue());
				}
			}
			return retval;
		}
#endif

		// note that we only support the integer types that C# supports
		// (the CLI also supports bool, char, IntPtr & UIntPtr)
		internal static object OrBoxedIntegrals(object v1, object v2)
		{
			Debug.Assert(v1.GetType() == v2.GetType());
			if (v1 is ulong)
			{
				ulong l1 = (ulong)v1;
				ulong l2 = (ulong)v2;
				return l1 | l2;
			}
			else
			{
				long v = ((IConvertible)v1).ToInt64(null) | ((IConvertible)v2).ToInt64(null);
				switch (Type.GetTypeCode(JVM.Import(v1.GetType())))
				{
					case TypeCode.SByte:
						return (sbyte)v;
					case TypeCode.Byte:
						return (byte)v;
					case TypeCode.Int16:
						return (short)v;
					case TypeCode.UInt16:
						return (ushort)v;
					case TypeCode.Int32:
						return (int)v;
					case TypeCode.UInt32:
						return (uint)v;
					case TypeCode.Int64:
						return (long)v;
					default:
						throw new InvalidOperationException();
				}
			}
		}

		// this method can be used to convert an enum value or its underlying value to a Java primitive
		internal static object GetPrimitiveValue(Type underlyingType, object obj)
		{
			// Note that this method doesn't trust that obj is of the correct type,
			// because it turns out there exist assemblies (e.g. gtk-sharp.dll) that
			// have incorrectly typed enum constant values (e.g. int32 instead of uint32).
			long value;
			if (obj is ulong || (obj is Enum && underlyingType == Types.UInt64))
			{
				value = unchecked((long)((IConvertible)obj).ToUInt64(null));
			}
			else
			{
				value = ((IConvertible)obj).ToInt64(null);
			}
			if (underlyingType == Types.SByte || underlyingType == Types.Byte)
			{
				return unchecked((byte)value);
			}
			else if (underlyingType == Types.Int16 || underlyingType == Types.UInt16)
			{
				return unchecked((short)value);
			}
			else if (underlyingType == Types.Int32 || underlyingType == Types.UInt32)
			{
				return unchecked((int)value);
			}
			else if (underlyingType == Types.Int64 || underlyingType == Types.UInt64)
			{
				return value;
			}
			else
			{
				throw new InvalidOperationException();
			}
		}
	}

	static class TypeNameUtil
	{
		// note that MangleNestedTypeName() assumes that there are less than 16 special characters
		private const string specialCharactersString = "\\+,[]*&\u0000";
		internal const string ProxiesContainer = "__<Proxies>";

		internal static string ReplaceIllegalCharacters(string name)
		{
			name = UnicodeUtil.EscapeInvalidSurrogates(name);
			// only the NUL character is illegal in CLR type names, so we replace it with a space
			return name.Replace('\u0000', ' ');
		}

		internal static string Unescape(string name)
		{
			int pos = name.IndexOf('\\');
			if (pos == -1)
			{
				return name;
			}
			System.Text.StringBuilder sb = new System.Text.StringBuilder(name.Length);
			sb.Append(name, 0, pos);
			for (int i = pos; i < name.Length; i++)
			{
				char c = name[i];
				if (c == '\\')
				{
					c = name[++i];
				}
				sb.Append(c);
			}
			return sb.ToString();
		}

		internal static string MangleNestedTypeName(string name)
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			foreach (char c in name)
			{
				int index = specialCharactersString.IndexOf(c);
				if (c == '.')
				{
					sb.Append("_");
				}
				else if (c == '_')
				{
					sb.Append("^-");
				}
				else if (index == -1)
				{
					sb.Append(c);
					if (c == '^')
					{
						sb.Append(c);
					}
				}
				else
				{
					sb.Append('^').AppendFormat("{0:X1}", index);
				}
			}
			return sb.ToString();
		}

		internal static string UnmangleNestedTypeName(string name)
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			for (int i = 0; i < name.Length; i++)
			{
				char c = name[i];
				int index = specialCharactersString.IndexOf(c);
				if (c == '_')
				{
					sb.Append('.');
				}
				else if (c == '^')
				{
					c = name[++i];
					if (c == '-')
					{
						sb.Append('_');
					}
					else if (c == '^')
					{
						sb.Append('^');
					}
					else
					{
						sb.Append(specialCharactersString[c - '0']);
					}
				}
				else
				{
					sb.Append(c);
				}
			}
			return sb.ToString();
		}

		internal static string GetProxyNestedName(TypeWrapper[] interfaces)
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			foreach (TypeWrapper tw in interfaces)
			{
				sb.Append(tw.Name.Length).Append('|').Append(tw.Name);
			}
			return TypeNameUtil.MangleNestedTypeName(sb.ToString());
		}

		internal static string GetProxyName(TypeWrapper[] interfaces)
		{
			return ProxiesContainer + "+" + GetProxyNestedName(interfaces);
		}
	}

	static class ArrayUtil
	{
		internal static T[] Concat<T, X>(X obj, T[] arr)
			where X : T
		{
			T[] narr = new T[arr.Length + 1];
			narr[0] = obj;
			Array.Copy(arr, 0, narr, 1, arr.Length);
			return narr;
		}

		internal static T[] Concat<T, X>(T[] arr, X obj)
			where X : T
		{
			Array.Resize(ref arr, arr.Length + 1);
			arr[arr.Length - 1] = obj;
			return arr;
		}

		internal static T[] DropFirst<T>(T[] arr)
		{
			T[] narr = new T[arr.Length - 1];
			Array.Copy(arr, 1, narr, 0, narr.Length);
			return narr;
		}
	}

	static class UnicodeUtil
	{
		// We use part of the Supplementary Private Use Area-B to encode
		// invalid surrogates. If we encounter either of these two
		// markers, we always encode the surrogate (single or pair)
		private const char HighSurrogatePrefix = '\uDBFF';
		private const char LowSurrogatePrefix = '\uDBFE';

		// Identifiers in ECMA CLI metadata and strings in custom attribute blobs are encoded
		// using UTF-8 and don't allow partial surrogates, so we have to "complete" them to
		// produce valid Unicode and reverse the process when we read back the names.
		internal static string EscapeInvalidSurrogates(string str)
		{
			if (str != null)
			{
				for (int i = 0; i < str.Length; i++)
				{
					char c = str[i];
					if (Char.IsLowSurrogate(c))
					{
						str = str.Substring(0, i) + LowSurrogatePrefix + c + str.Substring(i + 1);
						i++;
					}
					else if (Char.IsHighSurrogate(c))
					{
						i++;
						// always escape the markers
						if (c == HighSurrogatePrefix || c == LowSurrogatePrefix || i == str.Length || !Char.IsLowSurrogate(str[i]))
						{
							str = str.Substring(0, i - 1) + HighSurrogatePrefix + (char)(c + 0x400) + str.Substring(i);
						}
					}
				}
			}
			return str;
		}

		internal static string UnescapeInvalidSurrogates(string str)
		{
			if (str != null)
			{
				for (int i = 0; i < str.Length; i++)
				{
					switch (str[i])
					{
						case HighSurrogatePrefix:
							str = str.Substring(0, i) + (char)(str[i + 1] - 0x400) + str.Substring(i + 2);
							break;
						case LowSurrogatePrefix:
							str = str.Substring(0, i) + str[i + 1] + str.Substring(i + 2);
							break;
					}
				}
			}
			return str;
		}

		internal static string[] EscapeInvalidSurrogates(string[] str)
		{
			if (str != null)
			{
				for (int i = 0; i < str.Length; i++)
				{
					str[i] = EscapeInvalidSurrogates(str[i]);
				}
			}
			return str;
		}

		internal static string[] UnescapeInvalidSurrogates(string[] str)
		{
			if (str != null)
			{
				for (int i = 0; i < str.Length; i++)
				{
					str[i] = UnescapeInvalidSurrogates(str[i]);
				}
			}
			return str;
		}
	}

	abstract class Annotation
	{
#if STATIC_COMPILER
		internal static Annotation LoadAssemblyCustomAttribute(ClassLoaderWrapper loader, object[] def)
		{
			Debug.Assert(def[0].Equals(AnnotationDefaultAttribute.TAG_ANNOTATION));
			string annotationClass = (string)def[1];
			if (ClassFile.IsValidFieldSig(annotationClass))
			{
				try
				{
					return loader.RetTypeWrapperFromSig(annotationClass.Replace('/', '.'), LoadMode.LoadOrThrow).Annotation;
				}
				catch (RetargetableJavaException)
				{
				}
			}
			return null;
		}
#endif

#if !STUB_GENERATOR
		// NOTE this method returns null if the type could not be found
		// or if the type is not a Custom Attribute and we're not in the static compiler
		internal static Annotation Load(TypeWrapper owner, object[] def)
		{
			Debug.Assert(def[0].Equals(AnnotationDefaultAttribute.TAG_ANNOTATION));
			string annotationClass = (string)def[1];
#if !STATIC_COMPILER
			if(!annotationClass.EndsWith("$Annotation;")
				&& !annotationClass.EndsWith("$Annotation$__ReturnValue;")
				&& !annotationClass.EndsWith("$Annotation$__Multiple;"))
			{
				// we don't want to try to load an annotation in dynamic mode,
				// unless it is a .NET custom attribute (which can affect runtime behavior)
				return null;
			}
#endif
			if (ClassFile.IsValidFieldSig(annotationClass))
			{
				TypeWrapper tw = owner.GetClassLoader().RetTypeWrapperFromSig(annotationClass.Replace('/', '.'), LoadMode.Link);
				// Java allows inaccessible annotations to be used, so when the annotation isn't visible
				// we fall back to using the DynamicAnnotationAttribute.
				if (!tw.IsUnloadable && tw.IsAccessibleFrom(owner))
				{
					return tw.Annotation;
				}
			}
			Tracer.Warning(Tracer.Compiler, "Unable to load annotation class {0}", annotationClass);
#if STATIC_COMPILER
			return new CompiledTypeWrapper.CompiledAnnotation(StaticCompiler.GetRuntimeType("IKVM.Attributes.DynamicAnnotationAttribute"));
#else
			return null;
#endif
		}
#endif

		private static object LookupEnumValue(Type enumType, string value)
		{
			FieldInfo field = enumType.GetField(value, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			if(field != null)
			{
				return field.GetRawConstantValue();
			}
			// both __unspecified and missing values end up here
			return EnumHelper.GetPrimitiveValue(EnumHelper.GetUnderlyingType(enumType), 0);
		}

		protected static object ConvertValue(ClassLoaderWrapper loader, Type targetType, object obj)
		{
			if(targetType.IsEnum)
			{
				// TODO check the obj descriptor matches the type we expect
				if(((object[])obj)[0].Equals(AnnotationDefaultAttribute.TAG_ARRAY))
				{
					object[] arr = (object[])obj;
					object value = null;
					for(int i = 1; i < arr.Length; i++)
					{
						// TODO check the obj descriptor matches the type we expect
						string s = ((object[])arr[i])[2].ToString();
						object newval = LookupEnumValue(targetType, s);
						if (value == null)
						{
							value = newval;
						}
						else
						{
							value = EnumHelper.OrBoxedIntegrals(value, newval);
						}
					}
					return value;
				}
				else
				{
					string s = ((object[])obj)[2].ToString();
					if(s == "__unspecified")
					{
						// TODO we should probably return null and handle that
					}
					return LookupEnumValue(targetType, s);
				}
			}
			else if(targetType == Types.Type)
			{
				// TODO check the obj descriptor matches the type we expect
				return loader.FieldTypeWrapperFromSig(((string)((object[])obj)[1]).Replace('/', '.'), LoadMode.LoadOrThrow).TypeAsTBD;
			}
			else if(targetType.IsArray)
			{
				// TODO check the obj descriptor matches the type we expect
				object[] arr = (object[])obj;
				Type elementType = targetType.GetElementType();
				object[] targetArray = new object[arr.Length - 1];
				for(int i = 1; i < arr.Length; i++)
				{
					targetArray[i - 1] = ConvertValue(loader, elementType, arr[i]);
				}
				return targetArray;
			}
			else
			{
				return obj;
			}
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal static bool MakeDeclSecurity(Type type, object annotation, out SecurityAction action, out PermissionSet permSet)
		{
			ConstructorInfo ci = type.GetConstructor(new Type[] { typeof(SecurityAction) });
			if (ci == null)
			{
				// TODO should we support HostProtectionAttribute? (which has a no-arg constructor)
				// TODO issue message?
				action = 0;
				permSet = null;
				return false;
			}
			SecurityAttribute attr = null;
			object[] arr = (object[])annotation;
			for (int i = 2; i < arr.Length; i += 2)
			{
				string name = (string)arr[i];
				if (name == "value")
				{
					attr = (SecurityAttribute)ci.Invoke(new object[] { ConvertValue(null, typeof(SecurityAction), arr[i + 1]) });
				}
			}
			if (attr == null)
			{
				// TODO issue message?
				action = 0;
				permSet = null;
				return false;
			}
			for (int i = 2; i < arr.Length; i += 2)
			{
				string name = (string)arr[i];
				if (name != "value")
				{
					PropertyInfo pi = type.GetProperty(name);
					pi.SetValue(attr, ConvertValue(null, pi.PropertyType, arr[i + 1]), null);
				}
			}
			action = attr.Action;
			permSet = new PermissionSet(PermissionState.None);
			permSet.AddPermission(attr.CreatePermission());
			return true;
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR

		internal static bool HasRetentionPolicyRuntime(object[] annotations)
		{
			if(annotations != null)
			{
				foreach(object[] def in annotations)
				{
					if(def[1].Equals("Ljava/lang/annotation/Retention;"))
					{
						for(int i = 2; i < def.Length; i += 2)
						{
							if(def[i].Equals("value"))
							{
								object[] val = def[i + 1] as object[];
								if(val != null
									&& val.Length == 3
									&& val[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)
									&& val[1].Equals("Ljava/lang/annotation/RetentionPolicy;")
									&& val[2].Equals("RUNTIME"))
								{
									return true;
								}
							}
						}
					}
				}
			}
			return false;
		}

		internal static bool HasObsoleteAttribute(object[] annotations)
		{
			if (annotations != null)
			{
				foreach (object[] def in annotations)
				{
					if (def[1].Equals("Lcli/System/ObsoleteAttribute$Annotation;"))
					{
						return true;
					}
				}
			}
			return false;
		}

		protected static object QualifyClassNames(ClassLoaderWrapper loader, object annotation)
		{
			bool copy = false;
			object[] def = (object[])annotation;
			for(int i = 3; i < def.Length; i += 2)
			{
				object[] val = def[i] as object[];
				if(val != null)
				{
					object[] newval = ValueQualifyClassNames(loader, val);
					if(newval != val)
					{
						if(!copy)
						{
							copy = true;
							object[] newdef = new object[def.Length];
							Array.Copy(def, newdef, def.Length);
							def = newdef;
						}
						def[i] = newval;
					}
				}
			}
			return def;
		}

		private static object[] ValueQualifyClassNames(ClassLoaderWrapper loader, object[] val)
		{
			if(val[0].Equals(AnnotationDefaultAttribute.TAG_ANNOTATION))
			{
				return (object[])QualifyClassNames(loader, val);
			}
			else if(val[0].Equals(AnnotationDefaultAttribute.TAG_CLASS))
			{
				string sig = (string)val[1];
				if(sig.StartsWith("L"))
				{
					TypeWrapper tw = loader.LoadClassByDottedNameFast(sig.Substring(1, sig.Length - 2).Replace('/', '.'));
					if(tw != null)
					{
						return new object[] { AnnotationDefaultAttribute.TAG_CLASS, "L" + tw.TypeAsBaseType.AssemblyQualifiedName.Replace('.', '/') + ";" };
					}
				}
				return val;
			}
			else if(val[0].Equals(AnnotationDefaultAttribute.TAG_ENUM))
			{
				string sig = (string)val[1];
				TypeWrapper tw = loader.LoadClassByDottedNameFast(sig.Substring(1, sig.Length - 2).Replace('/', '.'));
				if(tw != null)
				{
					return new object[] { AnnotationDefaultAttribute.TAG_ENUM, "L" + tw.TypeAsBaseType.AssemblyQualifiedName.Replace('.', '/') + ";", val[2] };
				}
				return val;
			}
			else if(val[0].Equals(AnnotationDefaultAttribute.TAG_ARRAY))
			{
				bool copy = false;
				for(int i = 1; i < val.Length; i++)
				{
					object[] nval = val[i] as object[];
					if(nval != null)
					{
						object newnval = ValueQualifyClassNames(loader, nval);
						if(newnval != nval)
						{
							if(!copy)
							{
								copy = true;
								object[] newval = new object[val.Length];
								Array.Copy(val, newval, val.Length);
								val = newval;
							}
							val[i] = newnval;
						}
					}
				}
				return val;
			}
			else if(val[0].Equals(AnnotationDefaultAttribute.TAG_ERROR))
			{
				return val;
			}
			else
			{
				throw new InvalidOperationException();
			}
		}

		internal abstract void Apply(ClassLoaderWrapper loader, TypeBuilder tb, object annotation);
		internal abstract void Apply(ClassLoaderWrapper loader, MethodBuilder mb, object annotation);
		internal abstract void Apply(ClassLoaderWrapper loader, FieldBuilder fb, object annotation);
		internal abstract void Apply(ClassLoaderWrapper loader, ParameterBuilder pb, object annotation);
		internal abstract void Apply(ClassLoaderWrapper loader, AssemblyBuilder ab, object annotation);
		internal abstract void Apply(ClassLoaderWrapper loader, PropertyBuilder pb, object annotation);

		internal virtual void ApplyReturnValue(ClassLoaderWrapper loader, MethodBuilder mb, ref ParameterBuilder pb, object annotation)
		{
		}

		internal abstract bool IsCustomAttribute { get; }
	}

	[Flags]
	enum TypeFlags : ushort
	{
		None = 0,
		HasIncompleteInterfaceImplementation = 1,
		InternalAccess = 2,
		HasStaticInitializer = 4,
		VerifyError = 8,
		ClassFormatError = 16,
		HasUnsupportedAbstractMethods = 32,
		Anonymous = 64,
		Linked = 128,
	}

	static class NamePrefix
	{
		internal const string Type2AccessStubBackingField = "__<>";
		internal const string AccessStub = "<accessstub>";
		internal const string NonVirtual = "<nonvirtual>";
		internal const string Bridge = "<bridge>";
		internal const string Incomplete = "<incomplete>";
		internal const string DefaultMethod = "<default>";
		internal const string PrivateInterfaceInstanceMethod = "<piim>";
	}

	static class NestedTypeName
	{
		internal const string CallerID = "__<CallerID>";
		internal const string InterfaceHelperMethods = "__<>IHM";
		internal const string PrivateInterfaceMethods = "__<>PIM";

		// interop types (mangled if necessary)
		internal const string Fields = "__Fields";
		internal const string Methods = "__Methods";
		internal const string DefaultMethods = "__DefaultMethods";

		// prefixes
		internal const string ThreadLocal = "__<tls>_";
		internal const string AtomicReferenceFieldUpdater = "__<ARFU>_";
		internal const string IndyCallSite = "__<>IndyCS";
		internal const string MethodHandleConstant = "__<>MHC";
		internal const string MethodTypeConstant = "__<>MTC";
		internal const string IntrinsifiedAnonymousClass = "__<>Anon";
	}

	internal abstract class TypeWrapper
	{
		private static readonly object flagsLock = new object();
		private readonly string name;		// java name (e.g. java.lang.Object)
		private readonly Modifiers modifiers;
		private TypeFlags flags;
		private MethodWrapper[] methods;
		private FieldWrapper[] fields;
#if !STATIC_COMPILER && !STUB_GENERATOR
		private java.lang.Class classObject;
#endif
		internal static readonly TypeWrapper[] EmptyArray = new TypeWrapper[0];
		internal const Modifiers UnloadableModifiersHack = Modifiers.Final | Modifiers.Interface | Modifiers.Private;
		internal const Modifiers VerifierTypeModifiersHack = Modifiers.Final | Modifiers.Interface;

		internal TypeWrapper(TypeFlags flags, Modifiers modifiers, string name)
		{
			Profiler.Count("TypeWrapper");
			// class name should be dotted or null for primitives
			Debug.Assert(name == null || name.IndexOf('/') < 0);

			this.flags = flags;
			this.modifiers = modifiers;
			this.name = name == null ? null : String.Intern(name);
		}

#if EMITTERS
		internal void EmitClassLiteral(CodeEmitter ilgen)
		{
			Debug.Assert(!this.IsPrimitive);

			Type type = GetClassLiteralType();

			// note that this has to be the same check as in LazyInitClass
			if (!this.IsFastClassLiteralSafe || IsForbiddenTypeParameterType(type))
			{
				int rank = 0;
				while (ReflectUtil.IsVector(type))
				{
					rank++;
					type = type.GetElementType();
				}
				if (rank == 0)
				{
					ilgen.Emit(OpCodes.Ldtoken, type);
					Compiler.getClassFromTypeHandle.EmitCall(ilgen);
				}
				else
				{
					ilgen.Emit(OpCodes.Ldtoken, type);
					ilgen.EmitLdc_I4(rank);
					Compiler.getClassFromTypeHandle2.EmitCall(ilgen);
				}
			}
			else
			{
				ilgen.Emit(OpCodes.Ldsfld, RuntimeHelperTypes.GetClassLiteralField(type));
			}
		}
#endif // EMITTERS

		private Type GetClassLiteralType()
		{
			Debug.Assert(!this.IsPrimitive);

			TypeWrapper tw = this;
			if (tw.IsGhostArray)
			{
				int rank = tw.ArrayRank;
				while (tw.IsArray)
				{
					tw = tw.ElementTypeWrapper;
				}
				return ArrayTypeWrapper.MakeArrayType(tw.TypeAsTBD, rank);
			}
			else
			{
				return tw.IsRemapped ? tw.TypeAsBaseType : tw.TypeAsTBD;
			}
		}

		private static bool IsForbiddenTypeParameterType(Type type)
		{
			// these are the types that may not be used as a type argument when instantiating a generic type
			return type == Types.Void
				|| type == JVM.Import(typeof(ArgIterator))
				|| type == JVM.Import(typeof(RuntimeArgumentHandle))
				|| type == JVM.Import(typeof(TypedReference))
				|| type.ContainsGenericParameters
				|| type.IsByRef;
		}

		internal virtual bool IsFastClassLiteralSafe
		{
			get { return false; }
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal void SetClassObject(java.lang.Class classObject)
		{
			this.classObject = classObject;
		}

		internal java.lang.Class ClassObject
		{
			get
			{
				Debug.Assert(!IsUnloadable && !IsVerifierType);
				if (classObject == null)
				{
					LazyInitClass();
				}
				return classObject;
			}
		}

#if !FIRST_PASS
		private java.lang.Class GetPrimitiveClass()
		{
			if (this == PrimitiveTypeWrapper.BYTE)
			{
				return java.lang.Byte.TYPE;
			}
			else if (this == PrimitiveTypeWrapper.CHAR)
			{
				return java.lang.Character.TYPE;
			}
			else if (this == PrimitiveTypeWrapper.DOUBLE)
			{
				return java.lang.Double.TYPE;
			}
			else if (this == PrimitiveTypeWrapper.FLOAT)
			{
				return java.lang.Float.TYPE;
			}
			else if (this == PrimitiveTypeWrapper.INT)
			{
				return java.lang.Integer.TYPE;
			}
			else if (this == PrimitiveTypeWrapper.LONG)
			{
				return java.lang.Long.TYPE;
			}
			else if (this == PrimitiveTypeWrapper.SHORT)
			{
				return java.lang.Short.TYPE;
			}
			else if (this == PrimitiveTypeWrapper.BOOLEAN)
			{
				return java.lang.Boolean.TYPE;
			}
			else if (this == PrimitiveTypeWrapper.VOID)
			{
				return java.lang.Void.TYPE;
			}
			else
			{
				throw new InvalidOperationException();
			}
		}
#endif

		private void LazyInitClass()
		{
			lock (this)
			{
				if (classObject == null)
				{
					// DynamicTypeWrapper should haved already had SetClassObject explicitly
					Debug.Assert(!IsDynamic);
#if !FIRST_PASS
					java.lang.Class clazz;
					// note that this has to be the same check as in EmitClassLiteral
					if (!this.IsFastClassLiteralSafe)
					{
						if (this.IsPrimitive)
						{
							clazz = GetPrimitiveClass();
						}
						else
						{
							clazz = new java.lang.Class(null);
						}
					}
					else
					{
						Type type = GetClassLiteralType();
						if (IsForbiddenTypeParameterType(type))
						{
							clazz = new java.lang.Class(type);
						}
						else
						{
							clazz = (java.lang.Class)typeof(ikvm.@@internal.ClassLiteral<>).MakeGenericType(type).GetField("Value").GetValue(null);
						}
					}
#if __MonoCS__
					SetTypeWrapperHack(clazz, this);
#else
					clazz.typeWrapper = this;
#endif
					// MONOBUG Interlocked.Exchange is broken on Mono, so we use CompareExchange
					System.Threading.Interlocked.CompareExchange(ref classObject, clazz, null);
#endif
				}
			}
		}

#if __MonoCS__
		// MONOBUG this method is to work around an mcs bug
		internal static void SetTypeWrapperHack(object clazz, TypeWrapper type)
		{
#if !FIRST_PASS
			typeof(java.lang.Class).GetField("typeWrapper", BindingFlags.NonPublic | BindingFlags.Instance).SetValue(clazz, type);
#endif
		}
#endif

#if !FIRST_PASS
		private static void ResolvePrimitiveTypeWrapperClasses()
		{
			// note that we're evaluating all ClassObject properties for the side effect
			// (to initialize and associate the ClassObject with the TypeWrapper)
			if (PrimitiveTypeWrapper.BYTE.ClassObject == null
				|| PrimitiveTypeWrapper.CHAR.ClassObject == null
				|| PrimitiveTypeWrapper.DOUBLE.ClassObject == null
				|| PrimitiveTypeWrapper.FLOAT.ClassObject == null
				|| PrimitiveTypeWrapper.INT.ClassObject == null
				|| PrimitiveTypeWrapper.LONG.ClassObject == null
				|| PrimitiveTypeWrapper.SHORT.ClassObject == null
				|| PrimitiveTypeWrapper.BOOLEAN.ClassObject == null
				|| PrimitiveTypeWrapper.VOID.ClassObject == null)
			{
				throw new InvalidOperationException();
			}
		}
#endif

		internal static TypeWrapper FromClass(java.lang.Class clazz)
		{
#if FIRST_PASS
			return null;
#else
			// MONOBUG redundant cast to workaround mcs bug
			TypeWrapper tw = (TypeWrapper)(object)clazz.typeWrapper;
			if(tw == null)
			{
				Type type = clazz.type;
				if (type == null)
				{
					ResolvePrimitiveTypeWrapperClasses();
					return FromClass(clazz);
				}
				if (type == typeof(void) || type.IsPrimitive || ClassLoaderWrapper.IsRemappedType(type))
				{
					tw = DotNetTypeWrapper.GetWrapperFromDotNetType(type);
				}
				else
				{
					tw = ClassLoaderWrapper.GetWrapperFromType(type);
				}
#if __MonoCS__
				SetTypeWrapperHack(clazz, tw);
#else
				clazz.typeWrapper = tw;
#endif
			}
			return tw;
#endif
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR

		public override string ToString()
		{
			return GetType().Name + "[" + name + "]";
		}

		// For UnloadableTypeWrapper it tries to load the type through the specified loader
		// and if that fails it throw a NoClassDefFoundError (not a java.lang.NoClassDefFoundError),
		// for all other types this is a no-op.
		internal virtual TypeWrapper EnsureLoadable(ClassLoaderWrapper loader)
		{
			return this;
		}

		private void SetTypeFlag(TypeFlags flag)
		{
			// we use a global lock object, since the chance of contention is very small
			lock (flagsLock)
			{
				flags |= flag;
			}
		}

		internal bool HasIncompleteInterfaceImplementation
		{
			get
			{
				TypeWrapper baseWrapper = this.BaseTypeWrapper;
				return (flags & TypeFlags.HasIncompleteInterfaceImplementation) != 0 || (baseWrapper != null && baseWrapper.HasIncompleteInterfaceImplementation);
			}
		}

		internal void SetHasIncompleteInterfaceImplementation()
		{
			SetTypeFlag(TypeFlags.HasIncompleteInterfaceImplementation);
		}

		internal bool HasUnsupportedAbstractMethods
		{
			get
			{
				foreach(TypeWrapper iface in this.Interfaces)
				{
					if(iface.HasUnsupportedAbstractMethods)
					{
						return true;
					}
				}
				TypeWrapper baseWrapper = this.BaseTypeWrapper;
				return (flags & TypeFlags.HasUnsupportedAbstractMethods) != 0 || (baseWrapper != null && baseWrapper.HasUnsupportedAbstractMethods);
			}
		}

		internal void SetHasUnsupportedAbstractMethods()
		{
			SetTypeFlag(TypeFlags.HasUnsupportedAbstractMethods);
		}

		internal virtual bool HasStaticInitializer
		{
			get
			{
				return (flags & TypeFlags.HasStaticInitializer) != 0;
			}
		}

		internal void SetHasStaticInitializer()
		{
			SetTypeFlag(TypeFlags.HasStaticInitializer);
		}

		internal bool HasVerifyError
		{
			get
			{
				return (flags & TypeFlags.VerifyError) != 0;
			}
		}

		internal void SetHasVerifyError()
		{
			SetTypeFlag(TypeFlags.VerifyError);
		}

		internal bool HasClassFormatError
		{
			get
			{
				return (flags & TypeFlags.ClassFormatError) != 0;
			}
		}

		internal void SetHasClassFormatError()
		{
			SetTypeFlag(TypeFlags.ClassFormatError);
		}

		internal virtual bool IsFakeTypeContainer
		{
			get
			{
				return false;
			}
		}

		internal virtual bool IsFakeNestedType
		{
			get
			{
				return false;
			}
		}

		// is this an anonymous class (in the sense of Unsafe.defineAnonymousClass(), not the JLS)
		internal bool IsUnsafeAnonymous
		{
			get { return (flags & TypeFlags.Anonymous) != 0; }
		}

		// a ghost is an interface that appears to be implemented by a .NET type
		// (e.g. System.String (aka java.lang.String) appears to implement java.lang.CharSequence,
		// so java.lang.CharSequence is a ghost)
		internal virtual bool IsGhost
		{
			get
			{
				return false;
			}
		}

		// is this an array type of which the ultimate element type is a ghost?
		internal bool IsGhostArray
		{
			get
			{
				return !IsUnloadable && IsArray && (ElementTypeWrapper.IsGhost || ElementTypeWrapper.IsGhostArray);
			}
		}

		internal virtual FieldInfo GhostRefField
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		internal virtual bool IsRemapped
		{
			get
			{
				return false;
			}
		}

		internal bool IsArray
		{
			get
			{
				return name != null && name[0] == '[';
			}
		}

		// NOTE for non-array types this returns 0
		internal int ArrayRank
		{
			get
			{
				int i = 0;
				if(name != null)
				{
					while(name[i] == '[')
					{
						i++;
					}
				}
				return i;
			}
		}

		internal virtual TypeWrapper GetUltimateElementTypeWrapper()
		{
			throw new InvalidOperationException();
		}

		internal bool IsNonPrimitiveValueType
		{
			get
			{
				return this != VerifierTypeWrapper.Null && !IsPrimitive && !IsGhost && TypeAsTBD.IsValueType;
			}
		}

		internal bool IsPrimitive
		{
			get
			{
				return name == null;
			}
		}

		internal bool IsWidePrimitive
		{
			get
			{
				return this == PrimitiveTypeWrapper.LONG || this == PrimitiveTypeWrapper.DOUBLE;
			}
		}

		internal bool IsIntOnStackPrimitive
		{
			get
			{
				return name == null &&
					(this == PrimitiveTypeWrapper.BOOLEAN ||
					this == PrimitiveTypeWrapper.BYTE ||
					this == PrimitiveTypeWrapper.CHAR ||
					this == PrimitiveTypeWrapper.SHORT ||
					this == PrimitiveTypeWrapper.INT);
			}
		}

		private static bool IsJavaPrimitive(Type type)
		{
			return type == PrimitiveTypeWrapper.BOOLEAN.TypeAsTBD
				|| type == PrimitiveTypeWrapper.BYTE.TypeAsTBD
				|| type == PrimitiveTypeWrapper.CHAR.TypeAsTBD
				|| type == PrimitiveTypeWrapper.DOUBLE.TypeAsTBD
				|| type == PrimitiveTypeWrapper.FLOAT.TypeAsTBD
				|| type == PrimitiveTypeWrapper.INT.TypeAsTBD
				|| type == PrimitiveTypeWrapper.LONG.TypeAsTBD
				|| type == PrimitiveTypeWrapper.SHORT.TypeAsTBD
				|| type == PrimitiveTypeWrapper.VOID.TypeAsTBD;
		}

		internal bool IsBoxedPrimitive
		{
			get
			{
				return !IsPrimitive && IsJavaPrimitive(TypeAsSignatureType);
			}
		}

		internal bool IsErasedOrBoxedPrimitiveOrRemapped
		{
			get
			{
				bool erased = IsUnloadable || IsGhostArray;
				return erased || IsBoxedPrimitive || (IsRemapped && this is DotNetTypeWrapper);
			}
		}

		internal bool IsUnloadable
		{
			get
			{
				// NOTE we abuse modifiers to note unloadable classes
				return modifiers == UnloadableModifiersHack;
			}
		}

		internal bool IsVerifierType
		{
			get
			{
				// NOTE we abuse modifiers to note verifier types
				return modifiers == VerifierTypeModifiersHack;
			}
		}

		internal virtual bool IsMapUnsafeException
		{
			get
			{
				return false;
			}
		}

		internal Modifiers Modifiers
		{
			get
			{
				return modifiers;
			}
		}

		// since for inner classes, the modifiers returned by Class.getModifiers are different from the actual
		// modifiers (as used by the VM access control mechanism), we have this additional property
		internal virtual Modifiers ReflectiveModifiers
		{
			get
			{
				return modifiers;
			}
		}

		internal bool IsInternal
		{
			get
			{
				return (flags & TypeFlags.InternalAccess) != 0;
			}
		}

		internal bool IsPublic
		{
			get
			{
				return (modifiers & Modifiers.Public) != 0;
			}
		}

		internal bool IsAbstract
		{
			get
			{
				// interfaces don't need to marked abstract explicitly (and javac 1.1 didn't do it)
				return (modifiers & (Modifiers.Abstract | Modifiers.Interface)) != 0;
			}
		}

		internal bool IsFinal
		{
			get
			{
				return (modifiers & Modifiers.Final) != 0;
			}
		}

		internal bool IsInterface
		{
			get
			{
				Debug.Assert(!IsUnloadable && !IsVerifierType);
				return (modifiers & Modifiers.Interface) != 0;
			}
		}

		// this exists because interfaces and arrays of interfaces are treated specially
		// by the verifier, interfaces don't have a common base (other than java.lang.Object)
		// so any object reference or object array reference can be used where an interface
		// or interface array reference is expected (the compiler will insert the required casts).
		internal bool IsInterfaceOrInterfaceArray
		{
			get
			{
				TypeWrapper tw = this;
				while(tw.IsArray)
				{
					tw = tw.ElementTypeWrapper;
				}
				return tw.IsInterface;
			}
		}

		internal abstract ClassLoaderWrapper GetClassLoader();

		internal FieldWrapper GetFieldWrapper(string fieldName, string fieldSig)
		{
			foreach(FieldWrapper fw in GetFields())
			{
				if(fw.Name == fieldName && fw.Signature == fieldSig)
				{
					return fw;
				}	
			}
			foreach(TypeWrapper iface in this.Interfaces)
			{
				FieldWrapper fw = iface.GetFieldWrapper(fieldName, fieldSig);
				if(fw != null)
				{
					return fw;
				}
			}
			TypeWrapper baseWrapper = this.BaseTypeWrapper;
			if(baseWrapper != null)
			{
				return baseWrapper.GetFieldWrapper(fieldName, fieldSig);
			}
			return null;
		}

		protected virtual void LazyPublishMembers()
		{
			if(methods == null)
			{
				methods = MethodWrapper.EmptyArray;
			}
			if(fields == null)
			{
				fields = FieldWrapper.EmptyArray;
			}
		}

		protected virtual void LazyPublishMethods()
		{
			LazyPublishMembers();
		}

		protected virtual void LazyPublishFields()
		{
			LazyPublishMembers();
		}

		internal MethodWrapper[] GetMethods()
		{
			if(methods == null)
			{
				lock(this)
				{
					if(methods == null)
					{
#if STATIC_COMPILER
						if(IsUnloadable || !CheckMissingBaseTypes(TypeAsBaseType))
						{
							return methods = MethodWrapper.EmptyArray;
						}
#endif
						LazyPublishMethods();
					}
				}
			}
			return methods;
		}

		internal FieldWrapper[] GetFields()
		{
			if(fields == null)
			{
				lock(this)
				{
					if(fields == null)
					{
#if STATIC_COMPILER
						if(IsUnloadable || !CheckMissingBaseTypes(TypeAsBaseType))
						{
							return fields = FieldWrapper.EmptyArray;
						}
#endif
						LazyPublishFields();
					}
				}
			}
			return fields;
		}

#if STATIC_COMPILER
		private static bool CheckMissingBaseTypes(Type type)
		{
			while (type != null)
			{
				if (type.__ContainsMissingType)
				{
					StaticCompiler.IssueMissingTypeMessage(type);
					return false;
				}
				bool ok = true;
				foreach (Type iface in type.__GetDeclaredInterfaces())
				{
					ok &= CheckMissingBaseTypes(iface);
				}
				if (!ok)
				{
					return false;
				}
				type = type.BaseType;
			}
			return true;
		}
#endif

		internal MethodWrapper GetMethodWrapper(string name, string sig, bool inherit)
		{
			// We need to get the methods before calling String.IsInterned, because getting them might cause the strings to be interned
			MethodWrapper[] methods = GetMethods();
			// MemberWrapper interns the name and sig so we can use ref equality
			// profiling has shown this to be more efficient
			string _name = String.IsInterned(name);
			string _sig = String.IsInterned(sig);
			foreach(MethodWrapper mw in methods)
			{
				// NOTE we can use ref equality, because names and signatures are
				// always interned by MemberWrapper
				if(ReferenceEquals(mw.Name, _name) && ReferenceEquals(mw.Signature, _sig))
				{
					return mw;
				}
			}
			TypeWrapper baseWrapper = this.BaseTypeWrapper;
			if(inherit && baseWrapper != null)
			{
				return baseWrapper.GetMethodWrapper(name, sig, inherit);
			}
			return null;
		}

		internal MethodWrapper GetInterfaceMethod(string name, string sig)
		{
			MethodWrapper method = GetMethodWrapper(name, sig, false);
			if (method != null)
			{
				return method;
			}
			TypeWrapper[] interfaces = Interfaces;
			for (int i = 0; i < interfaces.Length; i++)
			{
				method = interfaces[i].GetInterfaceMethod(name, sig);
				if (method != null)
				{
					return method;
				}
			}
			return null;
		}

		internal void SetMethods(MethodWrapper[] methods)
		{
			Debug.Assert(methods != null);
			System.Threading.Thread.MemoryBarrier();
			this.methods = methods;
		}

		internal void SetFields(FieldWrapper[] fields)
		{
			Debug.Assert(fields != null);
			System.Threading.Thread.MemoryBarrier();
			this.fields = fields;
		}

		internal string Name
		{
			get
			{
				return name;
			}
		}

		// the name of the type as it appears in a Java signature string (e.g. "Ljava.lang.Object;" or "I")
		internal virtual string SigName
		{
			get
			{
				return "L" + this.Name + ";";
			}
		}

		// returns true iff wrapper is allowed to access us
		internal bool IsAccessibleFrom(TypeWrapper wrapper)
		{
			return IsPublic
				|| (IsInternal && InternalsVisibleTo(wrapper))
				|| IsPackageAccessibleFrom(wrapper);
		}

		internal bool InternalsVisibleTo(TypeWrapper wrapper)
		{
			return GetClassLoader().InternalsVisibleToImpl(this, wrapper);
		}

		internal virtual bool IsPackageAccessibleFrom(TypeWrapper wrapper)
		{
			if (MatchingPackageNames(name, wrapper.name))
			{
#if STATIC_COMPILER
				CompilerClassLoader ccl = GetClassLoader() as CompilerClassLoader;
				if (ccl != null)
				{
					// this is a hack for multi target -sharedclassloader compilation
					// (during compilation we have multiple CompilerClassLoader instances to represent the single shared runtime class loader)
					return ccl.IsEquivalentTo(wrapper.GetClassLoader());
				}
#endif
				return GetClassLoader() == wrapper.GetClassLoader();
			}
			else
			{
				return false;
			}
		}

		private static bool MatchingPackageNames(string name1, string name2)
		{
			int index1 = name1.LastIndexOf('.');
			int index2 = name2.LastIndexOf('.');
			if (index1 == -1 && index2 == -1)
			{
				return true;
			}
			// for array types we need to skip the brackets
			int skip1 = 0;
			int skip2 = 0;
			while (name1[skip1] == '[')
			{
				skip1++;
			}
			while (name2[skip2] == '[')
			{
				skip2++;
			}
			if (skip1 > 0)
			{
				// skip over the L that follows the brackets
				skip1++;
			}
			if (skip2 > 0)
			{
				// skip over the L that follows the brackets
				skip2++;
			}
			if ((index1 - skip1) != (index2 - skip2))
			{
				return false;
			}
			return String.CompareOrdinal(name1, skip1, name2, skip2, index1 - skip1) == 0;
		}

		internal abstract Type TypeAsTBD
		{
			get;
		}

		internal Type TypeAsSignatureType
		{
			get
			{
				if(IsUnloadable)
				{
					return ((UnloadableTypeWrapper)this).MissingType ?? Types.Object;
				}
				if(IsGhostArray)
				{
					return ArrayTypeWrapper.MakeArrayType(Types.Object, ArrayRank);
				}
				return TypeAsTBD;
			}
		}

		internal Type TypeAsPublicSignatureType
		{
			get
			{
				return (IsPublic ? this : GetPublicBaseTypeWrapper()).TypeAsSignatureType;
			}
		}

		internal virtual Type TypeAsBaseType
		{
			get
			{
				return TypeAsTBD;
			}
		}

		internal Type TypeAsLocalOrStackType
		{
			get
			{
				if(IsUnloadable || IsGhost)
				{
					return Types.Object;
				}
				if(IsNonPrimitiveValueType)
				{
					// return either System.ValueType or System.Enum
					return TypeAsTBD.BaseType;
				}
				if(IsGhostArray)
				{
					return ArrayTypeWrapper.MakeArrayType(Types.Object, ArrayRank);
				}
				return TypeAsTBD;
			}
		}

		/** <summary>Use this if the type is used as an array or array element</summary> */
		internal Type TypeAsArrayType
		{
			get
			{
				if(IsUnloadable || IsGhost)
				{
					return Types.Object;
				}
				if(IsGhostArray)
				{
					return ArrayTypeWrapper.MakeArrayType(Types.Object, ArrayRank);
				}
				return TypeAsTBD;
			}
		}

		internal Type TypeAsExceptionType
		{
			get
			{
				if(IsUnloadable)
				{
					return Types.Exception;
				}
				return TypeAsTBD;
			}
		}

		internal abstract TypeWrapper BaseTypeWrapper
		{
			get;
		}

		internal TypeWrapper ElementTypeWrapper
		{
			get
			{
				Debug.Assert(!this.IsUnloadable);
				Debug.Assert(this == VerifierTypeWrapper.Null || this.IsArray);

				if(this == VerifierTypeWrapper.Null)
				{
					return VerifierTypeWrapper.Null;
				}

				// TODO consider caching the element type
				switch(name[1])
				{
					case '[':
						// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
						// (because the ultimate element type was already loaded when this type was created)
						return GetClassLoader().LoadClassByDottedNameFast(name.Substring(1));
					case 'L':
						// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
						// (because the ultimate element type was already loaded when this type was created)
						return GetClassLoader().LoadClassByDottedNameFast(name.Substring(2, name.Length - 3));
					case 'Z':
						return PrimitiveTypeWrapper.BOOLEAN;
					case 'B':
						return PrimitiveTypeWrapper.BYTE;
					case 'S':
						return PrimitiveTypeWrapper.SHORT;
					case 'C':
						return PrimitiveTypeWrapper.CHAR;
					case 'I':
						return PrimitiveTypeWrapper.INT;
					case 'J':
						return PrimitiveTypeWrapper.LONG;
					case 'F':
						return PrimitiveTypeWrapper.FLOAT;
					case 'D':
						return PrimitiveTypeWrapper.DOUBLE;
					default:
						throw new InvalidOperationException(name);
				}
			}
		}

		internal TypeWrapper MakeArrayType(int rank)
		{
			Debug.Assert(rank != 0);
			// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
			return GetClassLoader().LoadClassByDottedNameFast(new String('[', rank) + this.SigName);
		}

		internal bool ImplementsInterface(TypeWrapper interfaceWrapper)
		{
			TypeWrapper typeWrapper = this;
			while(typeWrapper != null)
			{
				TypeWrapper[] interfaces = typeWrapper.Interfaces;
				for(int i = 0; i < interfaces.Length; i++)
				{
					if(interfaces[i] == interfaceWrapper)
					{
						return true;
					}
					if(interfaces[i].ImplementsInterface(interfaceWrapper))
					{
						return true;
					}
				}
				typeWrapper = typeWrapper.BaseTypeWrapper;
			}
			return false;
		}

		internal bool IsSubTypeOf(TypeWrapper baseType)
		{
			// make sure IsSubTypeOf isn't used on primitives
			Debug.Assert(!this.IsPrimitive);
			Debug.Assert(!baseType.IsPrimitive);
			// can't be used on Unloadable
			Debug.Assert(!this.IsUnloadable);
			Debug.Assert(!baseType.IsUnloadable);

			if(baseType.IsInterface)
			{
				if(baseType == this)
				{
					return true;
				}
				return ImplementsInterface(baseType);
			}
			// NOTE this isn't just an optimization, it is also required when this is an interface
			if(baseType == CoreClasses.java.lang.Object.Wrapper)
			{
				return true;
			}
			TypeWrapper subType = this;
			while(subType != baseType)
			{
				subType = subType.BaseTypeWrapper;
				if(subType == null)
				{
					return false;
				}
			}
			return true;
		}

		internal bool IsAssignableTo(TypeWrapper wrapper)
		{
			if(this == wrapper)
			{
				return true;
			}
			if(this.IsPrimitive || wrapper.IsPrimitive)
			{
				return false;
			}
			if(this == VerifierTypeWrapper.Null)
			{
				return true;
			}
			if(wrapper.IsInterface)
			{
				return ImplementsInterface(wrapper);
			}
			int rank1 = this.ArrayRank;
			int rank2 = wrapper.ArrayRank;
			if(rank1 > 0 && rank2 > 0)
			{
				rank1--;
				rank2--;
				TypeWrapper elem1 = this.ElementTypeWrapper;
				TypeWrapper elem2 = wrapper.ElementTypeWrapper;
				while(rank1 != 0 && rank2 != 0)
				{
					elem1 = elem1.ElementTypeWrapper;
					elem2 = elem2.ElementTypeWrapper;
					rank1--;
					rank2--;
				}
				if(elem1.IsPrimitive || elem2.IsPrimitive)
				{
					return false;
				}
				return (!elem1.IsNonPrimitiveValueType && elem1.IsSubTypeOf(elem2));
			}
			return this.IsSubTypeOf(wrapper);
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal bool IsInstance(object obj)
		{
			if(obj != null)
			{
				TypeWrapper thisWrapper = this;
				TypeWrapper objWrapper = IKVM.NativeCode.ikvm.runtime.Util.GetTypeWrapperFromObject(obj);
				return objWrapper.IsAssignableTo(thisWrapper);
			}
			return false;
		}
#endif

		internal virtual TypeWrapper[] Interfaces
		{
			get { return EmptyArray; }
		}

		// NOTE this property can only be called for finished types!
		internal virtual TypeWrapper[] InnerClasses
		{
			get { return EmptyArray; }
		}

		// NOTE this property can only be called for finished types!
		internal virtual TypeWrapper DeclaringTypeWrapper
		{
			get { return null; }
		}

		internal virtual void Finish()
		{
		}

		internal void LinkAll()
		{
			if ((flags & TypeFlags.Linked) == 0)
			{
				TypeWrapper tw = BaseTypeWrapper;
				if (tw != null)
				{
					tw.LinkAll();
				}
				foreach (TypeWrapper iface in Interfaces)
				{
					iface.LinkAll();
				}
				foreach (MethodWrapper mw in GetMethods())
				{
					mw.Link();
				}
				foreach (FieldWrapper fw in GetFields())
				{
					fw.Link();
				}
				SetTypeFlag(TypeFlags.Linked);
			}
		}

#if !STATIC_COMPILER
		[Conditional("DEBUG")]
		internal static void AssertFinished(Type type)
		{
			if(type != null)
			{
				while(type.HasElementType)
				{
					type = type.GetElementType();
				}
				Debug.Assert(!(type is TypeBuilder));
			}
		}
#endif

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal void RunClassInit()
		{
			Type t = IsRemapped ? TypeAsBaseType : TypeAsTBD;
			if(t != null)
			{
				System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(t.TypeHandle);
			}
		}
#endif

#if EMITTERS
		internal void EmitUnbox(CodeEmitter ilgen)
		{
			Debug.Assert(this.IsNonPrimitiveValueType);

			ilgen.EmitUnboxSpecial(this.TypeAsTBD);
		}

		internal void EmitBox(CodeEmitter ilgen)
		{
			Debug.Assert(this.IsNonPrimitiveValueType);

			ilgen.Emit(OpCodes.Box, this.TypeAsTBD);
		}

		internal void EmitConvSignatureTypeToStackType(CodeEmitter ilgen)
		{
			if(IsUnloadable)
			{
			}
			else if(this == PrimitiveTypeWrapper.BYTE)
			{
				ilgen.Emit(OpCodes.Conv_I1);
			}
			else if(IsNonPrimitiveValueType)
			{
				EmitBox(ilgen);
			}
			else if(IsGhost)
			{
				CodeEmitterLocal local = ilgen.DeclareLocal(TypeAsSignatureType);
				ilgen.Emit(OpCodes.Stloc, local);
				ilgen.Emit(OpCodes.Ldloca, local);
				ilgen.Emit(OpCodes.Ldfld, GhostRefField);
			}
		}

		// NOTE sourceType is optional and only used for interfaces,
		// it is *not* used to automatically downcast
		internal void EmitConvStackTypeToSignatureType(CodeEmitter ilgen, TypeWrapper sourceType)
		{
			if(!IsUnloadable)
			{
				if(IsGhost)
				{
					CodeEmitterLocal local1 = ilgen.DeclareLocal(TypeAsLocalOrStackType);
					ilgen.Emit(OpCodes.Stloc, local1);
					CodeEmitterLocal local2 = ilgen.DeclareLocal(TypeAsSignatureType);
					ilgen.Emit(OpCodes.Ldloca, local2);
					ilgen.Emit(OpCodes.Ldloc, local1);
					ilgen.Emit(OpCodes.Stfld, GhostRefField);
					ilgen.Emit(OpCodes.Ldloca, local2);
					ilgen.Emit(OpCodes.Ldobj, TypeAsSignatureType);
				}
					// because of the way interface merging works, any reference is valid
					// for any interface reference
				else if(IsInterfaceOrInterfaceArray && (sourceType == null || sourceType.IsUnloadable || !sourceType.IsAssignableTo(this)))
				{
					ilgen.EmitAssertType(TypeAsTBD);
					Profiler.Count("InterfaceDownCast");
				}
				else if(IsNonPrimitiveValueType)
				{
					EmitUnbox(ilgen);
				}
				else if(sourceType != null && sourceType.IsUnloadable)
				{
					ilgen.Emit(OpCodes.Castclass, TypeAsSignatureType);
				}
			}
		}

		internal virtual void EmitCheckcast(CodeEmitter ilgen)
		{
			if(IsGhost)
			{
				ilgen.Emit(OpCodes.Dup);
				// TODO make sure we get the right "Cast" method and cache it
				// NOTE for dynamic ghosts we don't end up here because AotTypeWrapper overrides this method,
				// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
				ilgen.Emit(OpCodes.Call, TypeAsTBD.GetMethod("Cast"));
				ilgen.Emit(OpCodes.Pop);
			}
			else if(IsGhostArray)
			{
				ilgen.Emit(OpCodes.Dup);
				// TODO make sure we get the right "CastArray" method and cache it
				// NOTE for dynamic ghosts we don't end up here because AotTypeWrapper overrides this method,
				// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
				TypeWrapper tw = this;
				int rank = 0;
				while(tw.IsArray)
				{
					rank++;
					tw = tw.ElementTypeWrapper;
				}
				ilgen.EmitLdc_I4(rank);
				ilgen.Emit(OpCodes.Call, tw.TypeAsTBD.GetMethod("CastArray"));
				ilgen.Emit(OpCodes.Castclass, ArrayTypeWrapper.MakeArrayType(Types.Object, rank));
			}
			else
			{
				ilgen.EmitCastclass(TypeAsTBD);
			}
		}

		internal virtual void EmitInstanceOf(CodeEmitter ilgen)
		{
			if(IsGhost)
			{
				// TODO make sure we get the right "IsInstance" method and cache it
				// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
				// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
				ilgen.Emit(OpCodes.Call, TypeAsTBD.GetMethod("IsInstance"));
			}
			else if(IsGhostArray)
			{
				// TODO make sure we get the right "IsInstanceArray" method and cache it
				// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
				// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
				TypeWrapper tw = this;
				int rank = 0;
				while(tw.IsArray)
				{
					rank++;
					tw = tw.ElementTypeWrapper;
				}
				ilgen.EmitLdc_I4(rank);
				ilgen.Emit(OpCodes.Call, tw.TypeAsTBD.GetMethod("IsInstanceArray"));
			}
			else
			{
				ilgen.Emit_instanceof(TypeAsTBD);
			}
		}
#endif // EMITTERS

		// NOTE don't call this method, call MethodWrapper.Link instead
		internal virtual MethodBase LinkMethod(MethodWrapper mw)
		{
			return mw.GetMethod();
		}

		// NOTE don't call this method, call FieldWrapper.Link instead
		internal virtual FieldInfo LinkField(FieldWrapper fw)
		{
			return fw.GetField();
		}

#if EMITTERS
		internal virtual void EmitRunClassConstructor(CodeEmitter ilgen)
		{
		}
#endif // EMITTERS

		internal virtual string GetGenericSignature()
		{
			return null;
		}

		internal virtual string GetGenericMethodSignature(MethodWrapper mw)
		{
			return null;
		}

		internal virtual string GetGenericFieldSignature(FieldWrapper fw)
		{
			return null;
		}

		internal virtual MethodParametersEntry[] GetMethodParameters(MethodWrapper mw)
		{
			return null;
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal virtual string[] GetEnclosingMethod()
		{
			return null;
		}

		internal virtual object[] GetDeclaredAnnotations()
		{
			return null;
		}

		internal virtual object[] GetMethodAnnotations(MethodWrapper mw)
		{
			return null;
		}

		internal virtual object[][] GetParameterAnnotations(MethodWrapper mw)
		{
			return null;
		}

		internal virtual object[] GetFieldAnnotations(FieldWrapper fw)
		{
			return null;
		}

		internal virtual string GetSourceFileName()
		{
			return null;
		}

		internal virtual int GetSourceLineNumber(MethodBase mb, int ilOffset)
		{
			return -1;
		}

		internal virtual object GetAnnotationDefault(MethodWrapper mw)
		{
			MethodBase mb = mw.GetMethod();
			if(mb != null)
			{
				object[] attr = mb.GetCustomAttributes(typeof(AnnotationDefaultAttribute), false);
				if(attr.Length == 1)
				{
					return JVM.NewAnnotationElementValue(mw.DeclaringType.GetClassLoader().GetJavaClassLoader(), mw.ReturnType.ClassObject, ((AnnotationDefaultAttribute)attr[0]).Value);
				}
			}
			return null;
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR

		internal virtual Annotation Annotation
		{
			get
			{
				return null;
			}
		}

		internal virtual Type EnumType
		{
			get
			{
				return null;
			}
		}

		private static Type[] GetInterfaces(Type type)
		{
#if STATIC_COMPILER || STUB_GENERATOR
			List<Type> list = new List<Type>();
			for (; type != null && !type.__IsMissing; type = type.BaseType)
			{
				AddInterfaces(list, type);
			}
			return list.ToArray();
#else
			return type.GetInterfaces();
#endif
		}

#if STATIC_COMPILER || STUB_GENERATOR
		private static void AddInterfaces(List<Type> list, Type type)
		{
			foreach (Type iface in type.__GetDeclaredInterfaces())
			{
				if (!list.Contains(iface))
				{
					list.Add(iface);
					if (!iface.__IsMissing)
					{
						AddInterfaces(list, iface);
					}
				}
			}
		}
#endif

		protected static TypeWrapper[] GetImplementedInterfacesAsTypeWrappers(Type type)
		{
			Type[] interfaceTypes = GetInterfaces(type);
			TypeWrapper[] interfaces = new TypeWrapper[interfaceTypes.Length];
			for (int i = 0; i < interfaceTypes.Length; i++)
			{
				Type decl = interfaceTypes[i].DeclaringType;
				if (decl != null && AttributeHelper.IsGhostInterface(decl))
				{
					// we have to return the declaring type for ghost interfaces
					interfaces[i] = ClassLoaderWrapper.GetWrapperFromType(decl);
				}
				else
				{
					interfaces[i] = ClassLoaderWrapper.GetWrapperFromType(interfaceTypes[i]);
				}
			}
			for (int i = 0; i < interfaceTypes.Length; i++)
			{
				if (interfaces[i].IsRemapped)
				{
					// for remapped interfaces, we also return the original interface (Java types will ignore it, if it isn't listed in the ImplementsAttribute)
					TypeWrapper twRemapped = interfaces[i];
					TypeWrapper tw = DotNetTypeWrapper.GetWrapperFromDotNetType(interfaceTypes[i]);
					interfaces[i] = tw;
					if (Array.IndexOf(interfaces, twRemapped) == -1)
					{
						interfaces = ArrayUtil.Concat(interfaces, twRemapped);
					}
				}
			}
			return interfaces;
		}

		internal TypeWrapper GetPublicBaseTypeWrapper()
		{
			Debug.Assert(!this.IsPublic);
			if (this.IsUnloadable || this.IsInterface)
			{
				return CoreClasses.java.lang.Object.Wrapper;
			}
			for (TypeWrapper tw = this; ; tw = tw.BaseTypeWrapper)
			{
				if (tw.IsPublic)
				{
					return tw;
				}
			}
		}

#if !STUB_GENERATOR
		// return the constructor used for automagic .NET serialization
		internal virtual MethodBase GetSerializationConstructor()
		{
			return this.TypeAsBaseType.GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[] {
						JVM.Import(typeof(System.Runtime.Serialization.SerializationInfo)), JVM.Import(typeof(System.Runtime.Serialization.StreamingContext)) }, null);
		}

		internal virtual MethodBase GetBaseSerializationConstructor()
		{
			return BaseTypeWrapper.GetSerializationConstructor();
		}
#endif

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal virtual object GhostWrap(object obj)
		{
			return obj;
		}

		internal virtual object GhostUnwrap(object obj)
		{
			return obj;
		}
#endif

		internal bool IsDynamic
		{
#if STUB_GENERATOR
			get { return false; }
#else
			get { return this is DynamicTypeWrapper; }
#endif
		}

		internal virtual object[] GetConstantPool()
		{
			return null;
		}

		internal virtual byte[] GetRawTypeAnnotations()
		{
			return null;
		}

		internal virtual byte[] GetMethodRawTypeAnnotations(MethodWrapper mw)
		{
			return null;
		}

		internal virtual byte[] GetFieldRawTypeAnnotations(FieldWrapper fw)
		{
			return null;
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal virtual TypeWrapper Host
		{
			get { return null; }
		}
#endif
	}

	sealed class UnloadableTypeWrapper : TypeWrapper
	{
		internal const string ContainerTypeName = "__<Unloadable>";
		private readonly Type missingType;
		private Type customModifier;

		internal UnloadableTypeWrapper(string name)
			: base(TypeFlags.None, TypeWrapper.UnloadableModifiersHack, name)
		{
		}

		internal UnloadableTypeWrapper(Type missingType)
			: this(missingType.FullName)	// TODO demangle and re-mangle appropriately
		{
			this.missingType = missingType;
		}

		internal UnloadableTypeWrapper(string name, Type customModifier)
			: this(name)
		{
			this.customModifier = customModifier;
		}

		internal override TypeWrapper BaseTypeWrapper
		{
			get { return null; }
		}

		internal override ClassLoaderWrapper GetClassLoader()
		{
			return null;
		}

		internal override TypeWrapper EnsureLoadable(ClassLoaderWrapper loader)
		{
			TypeWrapper tw = loader.LoadClassByDottedNameFast(this.Name);
			if(tw == null)
			{
				throw new NoClassDefFoundError(this.Name);
			}
			return tw;
		}

		internal override string SigName
		{
			get
			{
				string name = Name;
				if(name.StartsWith("["))
				{
					return name;
				}
				return "L" + name + ";";
			}
		}

		protected override void LazyPublishMembers()
		{
			throw new InvalidOperationException("LazyPublishMembers called on UnloadableTypeWrapper: " + Name);
		}

		internal override Type TypeAsTBD
		{
			get
			{
				throw new InvalidOperationException("get_Type called on UnloadableTypeWrapper: " + Name);
			}
		}

		internal override TypeWrapper[] Interfaces
		{
			get
			{
#if STATIC_COMPILER
				if (missingType != null)
				{
					StaticCompiler.IssueMissingTypeMessage(missingType);
					return TypeWrapper.EmptyArray;
				}
#endif
				throw new InvalidOperationException("get_Interfaces called on UnloadableTypeWrapper: " + Name);
			}
		}

		internal override TypeWrapper[] InnerClasses
		{
			get
			{
				throw new InvalidOperationException("get_InnerClasses called on UnloadableTypeWrapper: " + Name);
			}
		}

		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				throw new InvalidOperationException("get_DeclaringTypeWrapper called on UnloadableTypeWrapper: " + Name);
			}
		}

		internal override void Finish()
		{
			throw new InvalidOperationException("Finish called on UnloadableTypeWrapper: " + Name);
		}

		internal Type MissingType
		{
			get { return missingType; }
		}

		internal Type CustomModifier
		{
			get { return customModifier; }
		}

		internal void SetCustomModifier(Type type)
		{
			this.customModifier = type;
		}

#if EMITTERS
		internal Type GetCustomModifier(TypeWrapperFactory context)
		{
			// we don't need to lock, because we're only supposed to be called while holding the finish lock
			return customModifier ?? (customModifier = context.DefineUnloadable(this.Name));
		}

		internal override void EmitCheckcast(CodeEmitter ilgen)
		{
			throw new InvalidOperationException("EmitCheckcast called on UnloadableTypeWrapper: " + Name);
		}

		internal override void EmitInstanceOf(CodeEmitter ilgen)
		{
			throw new InvalidOperationException("EmitInstanceOf called on UnloadableTypeWrapper: " + Name);
		}
#endif // EMITTERS
	}

	sealed class PrimitiveTypeWrapper : TypeWrapper
	{
		internal static readonly PrimitiveTypeWrapper BYTE = new PrimitiveTypeWrapper(Types.Byte, "B");
		internal static readonly PrimitiveTypeWrapper CHAR = new PrimitiveTypeWrapper(Types.Char, "C");
		internal static readonly PrimitiveTypeWrapper DOUBLE = new PrimitiveTypeWrapper(Types.Double, "D");
		internal static readonly PrimitiveTypeWrapper FLOAT = new PrimitiveTypeWrapper(Types.Single, "F");
		internal static readonly PrimitiveTypeWrapper INT = new PrimitiveTypeWrapper(Types.Int32, "I");
		internal static readonly PrimitiveTypeWrapper LONG = new PrimitiveTypeWrapper(Types.Int64, "J");
		internal static readonly PrimitiveTypeWrapper SHORT = new PrimitiveTypeWrapper(Types.Int16, "S");
		internal static readonly PrimitiveTypeWrapper BOOLEAN = new PrimitiveTypeWrapper(Types.Boolean, "Z");
		internal static readonly PrimitiveTypeWrapper VOID = new PrimitiveTypeWrapper(Types.Void, "V");

		private readonly Type type;
		private readonly string sigName;

		private PrimitiveTypeWrapper(Type type, string sigName)
			: base(TypeFlags.None, Modifiers.Public | Modifiers.Abstract | Modifiers.Final, null)
		{
			this.type = type;
			this.sigName = sigName;
		}

		internal override TypeWrapper BaseTypeWrapper
		{
			get { return null; }
		}

		internal static bool IsPrimitiveType(Type type)
		{
			return type == BYTE.type
				|| type == CHAR.type
				|| type == DOUBLE.type
				|| type == FLOAT.type
				|| type == INT.type
				|| type == LONG.type
				|| type == SHORT.type
				|| type == BOOLEAN.type
				|| type == VOID.type;
		}

		internal override string SigName
		{
			get
			{
				return sigName;
			}
		}

		internal override ClassLoaderWrapper GetClassLoader()
		{
			return ClassLoaderWrapper.GetBootstrapClassLoader();
		}

		internal override Type TypeAsTBD
		{
			get
			{
				return type;
			}
		}

		public override string ToString()
		{
			return "PrimitiveTypeWrapper[" + sigName + "]";
		}
	}

	class CompiledTypeWrapper : TypeWrapper
	{
		private readonly Type type;
		private TypeWrapper baseTypeWrapper = VerifierTypeWrapper.Null;
		private volatile TypeWrapper[] interfaces;
		private MethodInfo clinitMethod;
		private volatile bool clinitMethodSet;
		private Modifiers reflectiveModifiers;

		internal static CompiledTypeWrapper newInstance(string name, Type type)
		{
			// TODO since ghost and remapped types can only exist in the core library assembly, we probably
			// should be able to remove the Type.IsDefined() tests in most cases
			if(type.IsValueType && AttributeHelper.IsGhostInterface(type))
			{
				return new CompiledGhostTypeWrapper(name, type);
			}
			else if(AttributeHelper.IsRemappedType(type))
			{
				return new CompiledRemappedTypeWrapper(name, type);
			}
			else
			{
				return new CompiledTypeWrapper(name, type);
			}
		}

		private sealed class CompiledRemappedTypeWrapper : CompiledTypeWrapper
		{
			private readonly Type remappedType;

			internal CompiledRemappedTypeWrapper(string name, Type type)
				: base(name, type)
			{
				RemappedTypeAttribute attr = AttributeHelper.GetRemappedType(type);
				if(attr == null)
				{
					throw new InvalidOperationException();
				}
				remappedType = attr.Type;
			}

			internal override Type TypeAsTBD
			{
				get
				{
					return remappedType;
				}
			}

			internal override bool IsRemapped
			{
				get
				{
					return true;
				}
			}

			protected override void LazyPublishMethods()
			{
				List<MethodWrapper> list = new List<MethodWrapper>();
				const BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
				foreach(ConstructorInfo ctor in type.GetConstructors(bindingFlags))
				{
					AddMethod(list, ctor);
				}
				foreach(MethodInfo method in type.GetMethods(bindingFlags))
				{
					AddMethod(list, method);
				}
				// if we're a remapped interface, we need to get the methods from the real interface
				if(remappedType.IsInterface)
				{
					Type nestedHelper = type.GetNestedType("__Helper", BindingFlags.Public | BindingFlags.Static);
					foreach(RemappedInterfaceMethodAttribute m in AttributeHelper.GetRemappedInterfaceMethods(type))
					{
						MethodInfo method = remappedType.GetMethod(m.MappedTo);
						MethodInfo mbHelper = method;
						ExModifiers modifiers = AttributeHelper.GetModifiers(method, false);
						string name;
						string sig;
						TypeWrapper retType;
						TypeWrapper[] paramTypes;
						MemberFlags flags = MemberFlags.None;
						GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes, ref flags);
						if(nestedHelper != null)
						{
							mbHelper = nestedHelper.GetMethod(m.Name);
							if(mbHelper == null)
							{
								mbHelper = method;
							}
						}
						MethodWrapper mw = new CompiledRemappedMethodWrapper(this, m.Name, sig, method, retType, paramTypes, modifiers, false, mbHelper, null);
						mw.SetDeclaredExceptions(m.Throws);
						list.Add(mw);
					}
				}
				SetMethods(list.ToArray());
			}

			private void AddMethod(List<MethodWrapper> list, MethodBase method)
			{
				HideFromJavaFlags flags = AttributeHelper.GetHideFromJavaFlags(method);
				if((flags & HideFromJavaFlags.Code) == 0
					&& (remappedType.IsSealed || !method.Name.StartsWith("instancehelper_"))
					&& (!remappedType.IsSealed || method.IsStatic))
				{
					list.Add(CreateRemappedMethodWrapper(method, flags));
				}
			}

			protected override void LazyPublishFields()
			{
				List<FieldWrapper> list = new List<FieldWrapper>();
				FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
				foreach(FieldInfo field in fields)
				{
					HideFromJavaFlags hideFromJavaFlags = AttributeHelper.GetHideFromJavaFlags(field);
					if((hideFromJavaFlags & HideFromJavaFlags.Code) == 0)
					{
						list.Add(CreateFieldWrapper(field, hideFromJavaFlags));
					}
				}
				SetFields(list.ToArray());
			}

			private MethodWrapper CreateRemappedMethodWrapper(MethodBase mb, HideFromJavaFlags hideFromJavaflags)
			{
				ExModifiers modifiers = AttributeHelper.GetModifiers(mb, false);
				string name;
				string sig;
				TypeWrapper retType;
				TypeWrapper[] paramTypes;
				MemberFlags flags = MemberFlags.None;
				GetNameSigFromMethodBase(mb, out name, out sig, out retType, out paramTypes, ref flags);
				MethodInfo mbHelper = mb as MethodInfo;
				bool hideFromReflection = mbHelper != null && (hideFromJavaflags & HideFromJavaFlags.Reflection) != 0;
				MethodInfo mbNonvirtualHelper = null;
				if(!mb.IsStatic && !mb.IsConstructor)
				{
					ParameterInfo[] parameters = mb.GetParameters();
					Type[] argTypes = new Type[parameters.Length + 1];
					argTypes[0] = remappedType;
					for(int i = 0; i < parameters.Length; i++)
					{
						argTypes[i + 1] = parameters[i].ParameterType;
					}
					MethodInfo helper = type.GetMethod("instancehelper_" + mb.Name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static, null, argTypes, null);
					if(helper != null)
					{
						mbHelper = helper;
					}
					mbNonvirtualHelper = type.GetMethod("nonvirtualhelper/" + mb.Name, BindingFlags.NonPublic | BindingFlags.Static, null, argTypes, null);
				}
				return new CompiledRemappedMethodWrapper(this, name, sig, mb, retType, paramTypes, modifiers, hideFromReflection, mbHelper, mbNonvirtualHelper);
			}
		}

		private sealed class CompiledGhostTypeWrapper : CompiledTypeWrapper
		{
			private volatile FieldInfo ghostRefField;
			private volatile Type typeAsBaseType;

			internal CompiledGhostTypeWrapper(string name, Type type)
				: base(name, type)
			{
			}

			internal override Type TypeAsBaseType
			{
				get
				{
					if(typeAsBaseType == null)
					{
						typeAsBaseType = type.GetNestedType("__Interface");
					}
					return typeAsBaseType;
				}
			}

			internal override FieldInfo GhostRefField
			{
				get
				{
					if(ghostRefField == null)
					{
						ghostRefField = type.GetField("__<ref>");
					}
					return ghostRefField;
				}
			}

			internal override bool IsGhost
			{
				get
				{
					return true;
				}
			}

#if !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
			internal override object GhostWrap(object obj)
			{
				return type.GetMethod("Cast").Invoke(null, new object[] { obj });
			}

			internal override object GhostUnwrap(object obj)
			{
				return type.GetMethod("ToObject").Invoke(obj, new object[0]);
			}
#endif
		}

		internal static string GetName(Type type)
		{
			Debug.Assert(!type.HasElementType);
			Debug.Assert(!type.IsGenericType);
			Debug.Assert(AttributeHelper.IsJavaModule(type.Module));

			// look for our custom attribute, that contains the real name of the type (for inner classes)
			InnerClassAttribute attr = AttributeHelper.GetInnerClass(type);
			if(attr != null)
			{
				string name = attr.InnerClassName;
				if(name != null)
				{
					return name;
				}
			}
			if(type.DeclaringType != null)
			{
				return GetName(type.DeclaringType) + "$" + TypeNameUtil.Unescape(type.Name);
			}
			return TypeNameUtil.Unescape(type.FullName);
		}

		private static TypeWrapper GetBaseTypeWrapper(Type type)
		{
			if(type.IsInterface || AttributeHelper.IsGhostInterface(type))
			{
				return null;
			}
			else if(type.BaseType == null)
			{
				// System.Object must appear to be derived from java.lang.Object
				return CoreClasses.java.lang.Object.Wrapper;
			}
			else
			{
				RemappedTypeAttribute attr = AttributeHelper.GetRemappedType(type);
				if(attr != null)
				{
					if(attr.Type == Types.Object)
					{
						return null;
					}
					else
					{
						return CoreClasses.java.lang.Object.Wrapper;
					}
				}
				else if(ClassLoaderWrapper.IsRemappedType(type.BaseType))
				{
					// if we directly extend System.Object or System.Exception, the base class must be cli.System.Object or cli.System.Exception
					return DotNetTypeWrapper.GetWrapperFromDotNetType(type.BaseType);
				}
				TypeWrapper tw = null;
				while(tw == null)
				{
					type = type.BaseType;
					tw = ClassLoaderWrapper.GetWrapperFromType(type);
				}
				return tw;
			}
		}

		private CompiledTypeWrapper(ExModifiers exmod, string name)
			: base(exmod.IsInternal ? TypeFlags.InternalAccess : TypeFlags.None, exmod.Modifiers, name)
		{
		}

		private CompiledTypeWrapper(string name, Type type)
			: this(GetModifiers(type), name)
		{
			Debug.Assert(!(type is TypeBuilder));
			Debug.Assert(!type.Name.EndsWith("[]"));

			this.type = type;
		}

		internal override TypeWrapper BaseTypeWrapper
		{
			get
			{
				if (baseTypeWrapper != VerifierTypeWrapper.Null)
				{
					return baseTypeWrapper;
				}
				return baseTypeWrapper = GetBaseTypeWrapper(type);
			}
		}

		internal override ClassLoaderWrapper GetClassLoader()
		{
			return AssemblyClassLoader.FromAssembly(type.Assembly);
		}

		private static ExModifiers GetModifiers(Type type)
		{
			ModifiersAttribute attr = AttributeHelper.GetModifiersAttribute(type);
			if(attr != null)
			{
				return new ExModifiers(attr.Modifiers, attr.IsInternal);
			}
			// only returns public, protected, private, final, static, abstract and interface (as per
			// the documentation of Class.getModifiers())
			Modifiers modifiers = 0;
			if(type.IsPublic || type.IsNestedPublic)
			{
				modifiers |= Modifiers.Public;
			}
			if(type.IsSealed)
			{
				modifiers |= Modifiers.Final;
			}
			if(type.IsAbstract)
			{
				modifiers |= Modifiers.Abstract;
			}
			if(type.IsInterface)
			{
				modifiers |= Modifiers.Interface;
			}
			else
			{
				modifiers |= Modifiers.Super;
			}
			return new ExModifiers(modifiers, false);
		}

		internal override bool HasStaticInitializer
		{
			get
			{
				if(!clinitMethodSet)
				{
					try
					{
						clinitMethod = type.GetMethod("__<clinit>", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
					}
#if STATIC_COMPILER
					catch (IKVM.Reflection.MissingMemberException) { }
#endif
					finally { }
					clinitMethodSet = true;
				}
				return clinitMethod != null;
			}
		}

		internal override TypeWrapper[] Interfaces
		{
			get
			{
				if(interfaces == null)
				{
					interfaces = GetInterfaces();
				}
				return interfaces;
			}
		}

		private TypeWrapper[] GetInterfaces()
		{
			// NOTE instead of getting the interfaces list from Type, we use a custom
			// attribute to list the implemented interfaces, because Java reflection only
			// reports the interfaces *directly* implemented by the type, not the inherited
			// interfaces. This is significant for serialVersionUID calculation (for example).
			ImplementsAttribute attr = AttributeHelper.GetImplements(type);
			if (attr == null)
			{
				if (BaseTypeWrapper == CoreClasses.java.lang.Object.Wrapper)
				{
					return GetImplementedInterfacesAsTypeWrappers(type);
				}
				return TypeWrapper.EmptyArray;
			}
			string[] interfaceNames = attr.Interfaces;
			TypeWrapper[] interfaceWrappers = new TypeWrapper[interfaceNames.Length];
			if (this.IsRemapped)
			{
				for (int i = 0; i < interfaceWrappers.Length; i++)
				{
					interfaceWrappers[i] = ClassLoaderWrapper.LoadClassCritical(interfaceNames[i]);
				}
			}
			else
			{
				TypeWrapper[] typeWrappers = GetImplementedInterfacesAsTypeWrappers(type);
				for (int i = 0; i < interfaceWrappers.Length; i++)
				{
					for (int j = 0; j < typeWrappers.Length; j++)
					{
						if (typeWrappers[j].Name == interfaceNames[i])
						{
							interfaceWrappers[i] = typeWrappers[j];
							break;
						}
					}
					if (interfaceWrappers[i] == null)
					{
#if STATIC_COMPILER
						throw new FatalCompilerErrorException(Message.UnableToResolveInterface, interfaceNames[i], this);
#else
						JVM.CriticalFailure("Unable to resolve interface " + interfaceNames[i] + " on type " + this, null);
#endif
					}
				}
			}
			return interfaceWrappers;
		}

		private static bool IsNestedTypeAnonymousOrLocalClass(Type type)
		{
			switch (type.Attributes & (TypeAttributes.SpecialName | TypeAttributes.VisibilityMask))
			{
				case TypeAttributes.SpecialName | TypeAttributes.NestedPublic:
				case TypeAttributes.SpecialName | TypeAttributes.NestedAssembly:
					return AttributeHelper.HasEnclosingMethodAttribute(type);
				default:
					return false;
			}
		}

		private static bool IsAnnotationAttribute(Type type)
		{
			return type.Name.EndsWith("Attribute", StringComparison.Ordinal)
				&& type.IsClass
				&& type.BaseType.FullName == "ikvm.internal.AnnotationAttributeBase";
		}

		internal override TypeWrapper[] InnerClasses
		{
			get
			{
				List<TypeWrapper> wrappers = new List<TypeWrapper>();
				foreach(Type nested in type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly))
				{
					if(IsAnnotationAttribute(nested))
					{
						// HACK it's the custom attribute we generated for a corresponding annotation, so we shouldn't surface it as an inner classes
						// (we can't put a HideFromJavaAttribute on it, because we do want the class to be visible as a $Proxy)
					}
					else if(IsNestedTypeAnonymousOrLocalClass(nested))
					{
						// anonymous and local classes are not reported as inner classes
					}
					else if(AttributeHelper.IsHideFromJava(nested))
					{
						// ignore
					}
					else
					{
						wrappers.Add(ClassLoaderWrapper.GetWrapperFromType(nested));
					}
				}
				foreach(string s in AttributeHelper.GetNonNestedInnerClasses(type))
				{
					wrappers.Add(GetClassLoader().LoadClassByDottedName(s));
				}
				return wrappers.ToArray();
			}
		}

		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				if(IsNestedTypeAnonymousOrLocalClass(type))
				{
					return null;
				}
				Type declaringType = type.DeclaringType;
				if(declaringType != null)
				{
					return ClassLoaderWrapper.GetWrapperFromType(declaringType);
				}
				string decl = AttributeHelper.GetNonNestedOuterClasses(type);
				if(decl != null)
				{
					return GetClassLoader().LoadClassByDottedName(decl);
				}
				return null;
			}
		}

		// returns true iff name is of the form "...$<n>"
		private static bool IsAnonymousClassName(string name)
		{
			int index = name.LastIndexOf('$') + 1;
			if (index > 1 && index < name.Length)
			{
				while (index < name.Length)
				{
					if ("0123456789".IndexOf(name[index++]) == -1)
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		// This method uses some heuristics to predict the reflective modifiers and if the prediction matches
		// we can avoid storing the InnerClassesAttribute to record the modifiers.
		// The heuristics are based on javac from Java 7.
		internal static Modifiers PredictReflectiveModifiers(TypeWrapper tw)
		{
			Modifiers modifiers = Modifiers.Static | (tw.Modifiers & (Modifiers.Public | Modifiers.Abstract | Modifiers.Interface));
			// javac marks anonymous classes as final, but the InnerClasses attribute access_flags does not have the ACC_FINAL flag set
			if (tw.IsFinal && !IsAnonymousClassName(tw.Name))
			{
				modifiers |= Modifiers.Final;
			}
			// javac uses the this$0 field to store the outer instance reference for non-static inner classes
			foreach (FieldWrapper fw in tw.GetFields())
			{
				if (fw.Name == "this$0")
				{
					modifiers &= ~Modifiers.Static;
					break;
				}
			}
			return modifiers;
		}

		internal override Modifiers ReflectiveModifiers
		{
			get
			{
				if (reflectiveModifiers == 0)
				{
					Modifiers mods;
					InnerClassAttribute attr = AttributeHelper.GetInnerClass(type);
					if (attr != null)
					{
						// the mask comes from RECOGNIZED_INNER_CLASS_MODIFIERS in src/hotspot/share/vm/classfile/classFileParser.cpp
						// (minus ACC_SUPER)
						mods = attr.Modifiers & (Modifiers)0x761F;
					}
					else if (type.DeclaringType != null)
					{
						mods = PredictReflectiveModifiers(this);
					}
					else
					{
						// the mask comes from JVM_RECOGNIZED_CLASS_MODIFIERS in src/hotspot/share/vm/prims/jvm.h
						// (minus ACC_SUPER)
						mods = Modifiers & (Modifiers)0x7611;
					}
					if (IsInterface)
					{
						mods |= Modifiers.Abstract;
					}
					reflectiveModifiers = mods;
				}
				return reflectiveModifiers;
			}
		}

		internal override Type TypeAsBaseType
		{
			get
			{
				return type;
			}
		}

		private void SigTypePatchUp(string sigtype, ref TypeWrapper type)
		{
			if(sigtype != type.SigName)
			{
				// if type is an array, we know that it is a ghost array, because arrays of unloadable are compiled
				// as object (not as arrays of object)
				if(type.IsArray)
				{
					type = GetClassLoader().FieldTypeWrapperFromSig(sigtype, LoadMode.LoadOrThrow);
				}
				else if(type.IsPrimitive)
				{
					type = DotNetTypeWrapper.GetWrapperFromDotNetType(type.TypeAsTBD);
					if(sigtype != type.SigName)
					{
						throw new InvalidOperationException();
					}
				}
				else if(type.IsNonPrimitiveValueType)
				{
					// this can't happen and even if it does happen we cannot return
					// UnloadableTypeWrapper because that would result in incorrect code
					// being generated
					throw new InvalidOperationException();
				}
				else
				{
					if(sigtype[0] == 'L')
					{
						sigtype = sigtype.Substring(1, sigtype.Length - 2);
					}
					try
					{
						TypeWrapper tw = GetClassLoader().LoadClassByDottedNameFast(sigtype);
						if(tw != null && tw.IsRemapped)
						{
							type = tw;
							return;
						}
					}
					catch(RetargetableJavaException)
					{
					}
					type = new UnloadableTypeWrapper(sigtype);
				}
			}
		}

		private static void ParseSig(string sig, out string[] sigparam, out string sigret)
		{
			List<string> list = new List<string>();
			int pos = 1;
			for(;;)
			{
				switch(sig[pos])
				{
					case 'L':
					{
						int end = sig.IndexOf(';', pos) + 1;
						list.Add(sig.Substring(pos, end - pos));
						pos = end;
						break;
					}
					case '[':
					{
						int skip = 1;
						while(sig[pos + skip] == '[') skip++;
						if(sig[pos + skip] == 'L')
						{
							int end = sig.IndexOf(';', pos) + 1;
							list.Add(sig.Substring(pos, end - pos));
							pos = end;
						}
						else
						{
							skip++;
							list.Add(sig.Substring(pos, skip));
							pos += skip;
						}
						break;
					}
					case ')':
						sigparam = list.ToArray();
						sigret = sig.Substring(pos + 1);
						return;
					default:
						list.Add(sig.Substring(pos, 1));
						pos++;
						break;
				}
			}
		}

		private static bool IsCallerID(Type type)
		{
#if STUB_GENERATOR
			return type.FullName == "ikvm.internal.CallerID";
#else
			return type == CoreClasses.ikvm.@@internal.CallerID.Wrapper.TypeAsSignatureType;
#endif
		}

		private static bool IsCallerSensitive(MethodBase mb)
		{
#if FIRST_PASS
			return false;
#elif STATIC_COMPILER || STUB_GENERATOR
			foreach (CustomAttributeData cad in mb.GetCustomAttributesData())
			{
				if (cad.AttributeType.FullName == "sun.reflect.CallerSensitiveAttribute")
				{
					return true;
				}
			}
			return false;
#else
			return mb.IsDefined(typeof(sun.reflect.CallerSensitiveAttribute), false);
#endif
		}

		private void GetNameSigFromMethodBase(MethodBase method, out string name, out string sig, out TypeWrapper retType, out TypeWrapper[] paramTypes, ref MemberFlags flags)
		{
			retType = method is ConstructorInfo ? PrimitiveTypeWrapper.VOID : GetParameterTypeWrapper(((MethodInfo)method).ReturnParameter);
			ParameterInfo[] parameters = method.GetParameters();
			int len = parameters.Length;
			if(len > 0
				&& IsCallerID(parameters[len - 1].ParameterType)
				&& GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader()				
				&& IsCallerSensitive(method))
			{
				len--;
				flags |= MemberFlags.CallerID;
			}
			paramTypes = new TypeWrapper[len];
			for(int i = 0; i < len; i++)
			{
				paramTypes[i] = GetParameterTypeWrapper(parameters[i]);
			}
			NameSigAttribute attr = AttributeHelper.GetNameSig(method);
			if(attr != null)
			{
				name = attr.Name;
				sig = attr.Sig;
				string[] sigparams;
				string sigret;
				ParseSig(sig, out sigparams, out sigret);
				// HACK newhelper methods have a return type, but it should be void
				if(name == "<init>")
				{
					retType = PrimitiveTypeWrapper.VOID;
				}
				SigTypePatchUp(sigret, ref retType);
				// if we have a remapped method, the paramTypes array contains an additional entry for "this" so we have
				// to remove that
				if(paramTypes.Length == sigparams.Length + 1)
				{
					paramTypes = ArrayUtil.DropFirst(paramTypes);
				}
				Debug.Assert(sigparams.Length == paramTypes.Length);
				for(int i = 0; i < sigparams.Length; i++)
				{
					SigTypePatchUp(sigparams[i], ref paramTypes[i]);
				}
			}
			else
			{
				if(method is ConstructorInfo)
				{
					name = method.IsStatic ? "<clinit>" : "<init>";
				}
				else
				{
					name = method.Name;
					if(name.StartsWith(NamePrefix.Bridge, StringComparison.Ordinal))
					{
						name = name.Substring(NamePrefix.Bridge.Length);
					}
					if(method.IsSpecialName)
					{
						name = UnicodeUtil.UnescapeInvalidSurrogates(name);
					}
				}
				if(method.IsSpecialName && method.Name.StartsWith(NamePrefix.DefaultMethod, StringComparison.Ordinal))
				{
					paramTypes = ArrayUtil.DropFirst(paramTypes);
				}
				System.Text.StringBuilder sb = new System.Text.StringBuilder("(");
				foreach(TypeWrapper tw in paramTypes)
				{
					sb.Append(tw.SigName);
				}
				sb.Append(")");
				sb.Append(retType.SigName);
				sig = sb.ToString();
			}
		}

		private sealed class DelegateConstructorMethodWrapper : MethodWrapper
		{
			private readonly ConstructorInfo constructor;
			private MethodInfo invoke;

			private DelegateConstructorMethodWrapper(TypeWrapper tw, TypeWrapper iface, ExModifiers mods)
				: base(tw, StringConstants.INIT, "(" + iface.SigName + ")V", null, PrimitiveTypeWrapper.VOID, new TypeWrapper[] { iface }, mods.Modifiers, mods.IsInternal ? MemberFlags.InternalAccess : MemberFlags.None)
			{
			}

			internal DelegateConstructorMethodWrapper(TypeWrapper tw, MethodBase method)
				: this(tw, tw.GetClassLoader().LoadClassByDottedName(tw.Name + DotNetTypeWrapper.DelegateInterfaceSuffix), AttributeHelper.GetModifiers(method, false))
			{
				constructor = (ConstructorInfo)method;
			}

			protected override void DoLinkMethod()
			{
				MethodWrapper mw = GetParameters()[0].GetMethods()[0];
				mw.Link();
				invoke = (MethodInfo)mw.GetMethod();
			}

#if EMITTERS
			internal override void EmitNewobj(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Ldvirtftn, invoke);
				ilgen.Emit(OpCodes.Newobj, constructor);
			}
#endif // EMITTERS
		}

		protected override void LazyPublishMethods()
		{
			bool isDelegate = type.BaseType == Types.MulticastDelegate;
			List<MethodWrapper> methods = new List<MethodWrapper>();
			const BindingFlags flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
			foreach(ConstructorInfo ctor in type.GetConstructors(flags))
			{
				HideFromJavaFlags hideFromJavaFlags = AttributeHelper.GetHideFromJavaFlags(ctor);
				if (isDelegate && !ctor.IsStatic && (hideFromJavaFlags & HideFromJavaFlags.Code) == 0)
				{
					methods.Add(new DelegateConstructorMethodWrapper(this, ctor));
				}
				else
				{
					AddMethodOrConstructor(ctor, hideFromJavaFlags, methods);
				}
			}
			AddMethods(type.GetMethods(flags), methods);
			if (type.IsInterface && (type.IsPublic || type.IsNestedPublic))
			{
				Type privateInterfaceMethods = type.GetNestedType(NestedTypeName.PrivateInterfaceMethods, BindingFlags.NonPublic);
				if (privateInterfaceMethods != null)
				{
					AddMethods(privateInterfaceMethods.GetMethods(flags), methods);
				}
			}
			SetMethods(methods.ToArray());
		}

		private void AddMethods(MethodInfo[] add, List<MethodWrapper> methods)
		{
			foreach (MethodInfo method in add)
			{
				AddMethodOrConstructor(method, AttributeHelper.GetHideFromJavaFlags(method), methods);
			}
		}

		private void AddMethodOrConstructor(MethodBase method, HideFromJavaFlags hideFromJavaFlags, List<MethodWrapper> methods)
		{
			if((hideFromJavaFlags & HideFromJavaFlags.Code) != 0)
			{
				if(method.Name.StartsWith(NamePrefix.Incomplete, StringComparison.Ordinal))
				{
					SetHasIncompleteInterfaceImplementation();
				}
			}
			else
			{
				if(method.IsSpecialName && (method.Name.StartsWith("__<", StringComparison.Ordinal) || method.Name.StartsWith(NamePrefix.DefaultMethod, StringComparison.Ordinal)))
				{
					// skip
				}
				else
				{
					string name;
					string sig;
					TypeWrapper retType;
					TypeWrapper[] paramTypes;
					MethodInfo mi = method as MethodInfo;
					bool hideFromReflection = mi != null && (hideFromJavaFlags & HideFromJavaFlags.Reflection) != 0;
					MemberFlags flags = hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None;
					GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes, ref flags);
					ExModifiers mods = AttributeHelper.GetModifiers(method, false);
					if(mods.IsInternal)
					{
						flags |= MemberFlags.InternalAccess;
					}
					if(hideFromReflection && name.StartsWith(NamePrefix.AccessStub, StringComparison.Ordinal))
					{
						int id = Int32.Parse(name.Substring(NamePrefix.AccessStub.Length, name.IndexOf('|', NamePrefix.AccessStub.Length) - NamePrefix.AccessStub.Length));
						name = name.Substring(name.IndexOf('|', NamePrefix.AccessStub.Length) + 1);
						flags |= MemberFlags.AccessStub;
						MethodInfo nonvirt = type.GetMethod(NamePrefix.NonVirtual + id, BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.Instance);
						methods.Add(new AccessStubMethodWrapper(this, name, sig, mi, mi, nonvirt ?? mi, retType, paramTypes, mods.Modifiers & ~Modifiers.Final, flags));
						return;
					}
					MethodInfo impl;
					MethodWrapper mw;
					if (IsGhost && (mods.Modifiers & (Modifiers.Static | Modifiers.Private)) == 0)
					{
						Type[] types = new Type[paramTypes.Length];
						for (int i = 0; i < types.Length; i++)
						{
							types[i] = paramTypes[i].TypeAsSignatureType;
						}
						MethodInfo ifmethod = TypeAsBaseType.GetMethod(method.Name, types);
						mw = new GhostMethodWrapper(this, name, sig, ifmethod, (MethodInfo)method, retType, paramTypes, mods.Modifiers, flags);
						if (!mw.IsAbstract)
						{
							((GhostMethodWrapper)mw).SetDefaultImpl(TypeAsSignatureType.GetMethod(NamePrefix.DefaultMethod + method.Name, types));
						}
					}
					else if (method.IsSpecialName && method.Name.StartsWith(NamePrefix.PrivateInterfaceInstanceMethod, StringComparison.Ordinal))
					{
						mw = new PrivateInterfaceMethodWrapper(this, name, sig, method, retType, paramTypes, mods.Modifiers, flags);
					}
					else if (IsInterface && method.IsAbstract && (mods.Modifiers & Modifiers.Abstract) == 0 && (impl = GetDefaultInterfaceMethodImpl(mi, sig)) != null)
					{
						mw = new DefaultInterfaceMethodWrapper(this, name, sig, mi, impl, retType, paramTypes, mods.Modifiers, flags);
					}
					else
					{
						mw = new TypicalMethodWrapper(this, name, sig, method, retType, paramTypes, mods.Modifiers, flags);
					}
					if (mw.HasNonPublicTypeInSignature)
					{
						if (mi != null)
						{
							MethodInfo stubVirt;
							MethodInfo stubNonVirt;
							if (GetType2AccessStubs(name, sig, out stubVirt, out stubNonVirt))
							{
								mw = new AccessStubMethodWrapper(this, name, sig, mi, stubVirt, stubNonVirt ?? stubVirt, retType, paramTypes, mw.Modifiers, flags);
							}
						}
						else
						{
							ConstructorInfo stub;
							if (GetType2AccessStub(sig, out stub))
							{
								mw = new AccessStubConstructorMethodWrapper(this, sig, (ConstructorInfo)method, stub, paramTypes, mw.Modifiers, flags);
							}
						}
					}
					methods.Add(mw);
				}
			}
		}

		private MethodInfo GetDefaultInterfaceMethodImpl(MethodInfo method, string expectedSig)
		{
			foreach (MethodInfo candidate in method.DeclaringType.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly))
			{
				if (candidate.IsSpecialName
					&& candidate.Name.StartsWith(NamePrefix.DefaultMethod, StringComparison.Ordinal)
					&& candidate.Name.Length == method.Name.Length + NamePrefix.DefaultMethod.Length
					&& candidate.Name.EndsWith(method.Name, StringComparison.Ordinal))
				{
					string name;
					string sig;
					TypeWrapper retType;
					TypeWrapper[] paramTypes;
					MemberFlags flags = MemberFlags.None;
					GetNameSigFromMethodBase(candidate, out name, out sig, out retType, out paramTypes, ref flags);
					if (sig == expectedSig)
					{
						return candidate;
					}
				}
			}
			return null;
		}

		private bool GetType2AccessStubs(string name, string sig, out MethodInfo stubVirt, out MethodInfo stubNonVirt)
		{
			stubVirt = null;
			stubNonVirt = null;
			const BindingFlags flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
			foreach (MethodInfo method in type.GetMethods(flags))
			{
				if (AttributeHelper.IsHideFromJava(method))
				{
					NameSigAttribute attr = AttributeHelper.GetNameSig(method);
					if (attr != null && attr.Name == name && attr.Sig == sig)
					{
						if (method.Name.StartsWith(NamePrefix.NonVirtual, StringComparison.Ordinal))
						{
							stubNonVirt = method;
						}
						else
						{
							stubVirt = method;
						}
					}
				}
			}
			return stubVirt != null;
		}

		private bool GetType2AccessStub(string sig, out ConstructorInfo stub)
		{
			stub = null;
			const BindingFlags flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
			foreach (ConstructorInfo ctor in type.GetConstructors(flags))
			{
				if (AttributeHelper.IsHideFromJava(ctor))
				{
					NameSigAttribute attr = AttributeHelper.GetNameSig(ctor);
					if (attr != null && attr.Sig == sig)
					{
						stub = ctor;
					}
				}
			}
			return stub != null;
		}

		private static int SortFieldByToken(FieldInfo field1, FieldInfo field2)
		{
			return field1.MetadataToken.CompareTo(field2.MetadataToken);
		}

		protected override void LazyPublishFields()
		{
			List<FieldWrapper> fields = new List<FieldWrapper>();
			const BindingFlags flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
			FieldInfo[] rawfields = type.GetFields(flags);
			Array.Sort(rawfields, SortFieldByToken);
			// FXBUG on .NET 3.5 and Mono Type.GetProperties() will not return "duplicate" properties (i.e. that have the same name and type, but differ in custom modifiers).
			// .NET 4.0 works as expected. We don't have a workaround, because that would require name mangling again and this situation is very unlikely anyway.
			PropertyInfo[] properties = type.GetProperties(flags);
			foreach(FieldInfo field in rawfields)
			{
				HideFromJavaFlags hideFromJavaFlags = AttributeHelper.GetHideFromJavaFlags(field);
				if((hideFromJavaFlags & HideFromJavaFlags.Code) != 0)
				{
					if(field.Name.StartsWith(NamePrefix.Type2AccessStubBackingField, StringComparison.Ordinal))
					{
						TypeWrapper tw = GetFieldTypeWrapper(field);
						string name = field.Name.Substring(NamePrefix.Type2AccessStubBackingField.Length);
						for(int i = 0; i < properties.Length; i++)
						{
							if(properties[i] != null
								&& name == properties[i].Name
								&& MatchTypes(tw, GetPropertyTypeWrapper(properties[i])))
							{
								fields.Add(new CompiledAccessStubFieldWrapper(this, properties[i], field, tw));
								properties[i] = null;
								break;
							}
						}
					}
				}
				else
				{
					if(field.IsSpecialName && field.Name.StartsWith("__<", StringComparison.Ordinal))
					{
						// skip
					}
					else
					{
						fields.Add(CreateFieldWrapper(field, hideFromJavaFlags));
					}
				}
			}
			foreach(PropertyInfo property in properties)
			{
				if(property != null)
				{
					AddPropertyFieldWrapper(fields, property, null);
				}
			}
			SetFields(fields.ToArray());
		}

		private static bool MatchTypes(TypeWrapper tw1, TypeWrapper tw2)
		{
			return tw1 == tw2 || (tw1.IsUnloadable && tw2.IsUnloadable && tw1.Name == tw2.Name);
		}

		private void AddPropertyFieldWrapper(List<FieldWrapper> fields, PropertyInfo property, FieldInfo field)
		{
			// NOTE explictly defined properties (in map.xml) are decorated with HideFromJava,
			// so we don't need to worry about them here
			HideFromJavaFlags hideFromJavaFlags = AttributeHelper.GetHideFromJavaFlags(property);
			if((hideFromJavaFlags & HideFromJavaFlags.Code) == 0)
			{
				// is it a type 1 access stub?
				if((hideFromJavaFlags & HideFromJavaFlags.Reflection) != 0)
				{
					fields.Add(new CompiledAccessStubFieldWrapper(this, property, GetPropertyTypeWrapper(property)));
				}
				else
				{
					// It must be an explicit property
					// (defined in Java source by an @@ikvm.lang.Property annotation)
					ModifiersAttribute mods = AttributeHelper.GetModifiersAttribute(property);
					fields.Add(new CompiledPropertyFieldWrapper(this, property, new ExModifiers(mods.Modifiers, mods.IsInternal)));
				}
			}
		}

		private sealed class CompiledRemappedMethodWrapper : SmartMethodWrapper
		{
			private readonly MethodInfo mbHelper;
#if !STATIC_COMPILER
			private readonly MethodInfo mbNonvirtualHelper;
#endif

			internal CompiledRemappedMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, ExModifiers modifiers, bool hideFromReflection, MethodInfo mbHelper, MethodInfo mbNonvirtualHelper)
				: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers.Modifiers,
						(modifiers.IsInternal ? MemberFlags.InternalAccess : MemberFlags.None) | (hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None))
			{
				this.mbHelper = mbHelper;
#if !STATIC_COMPILER
				this.mbNonvirtualHelper = mbNonvirtualHelper;
#endif
			}

#if EMITTERS
			protected override void CallImpl(CodeEmitter ilgen)
			{
				MethodBase mb = GetMethod();
				MethodInfo mi = mb as MethodInfo;
				if(mi != null)
				{
					if(!IsStatic && IsFinal)
					{
						// When calling a final instance method on a remapped type from a class derived from a .NET class (i.e. a cli.System.Object or cli.System.Exception derived base class)
						// then we can't call the java.lang.Object or java.lang.Throwable methods and we have to go through the instancehelper_ method. Note that since the method
						// is final, this won't affect the semantics.
						CallvirtImpl(ilgen);
					}
					else
					{
						ilgen.Emit(OpCodes.Call, mi);
					}
				}
				else
				{
					ilgen.Emit(OpCodes.Call, mb);
				}
			}

			protected override void CallvirtImpl(CodeEmitter ilgen)
			{
				Debug.Assert(!mbHelper.IsStatic || mbHelper.Name.StartsWith("instancehelper_") || mbHelper.DeclaringType.Name == "__Helper");
				if(mbHelper.IsPublic)
				{
					ilgen.Emit(mbHelper.IsStatic ? OpCodes.Call : OpCodes.Callvirt, mbHelper);
				}
				else
				{
					// HACK the helper is not public, this means that we're dealing with finalize or clone
					ilgen.Emit(OpCodes.Callvirt, GetMethod());
				}
			}

			protected override void NewobjImpl(CodeEmitter ilgen)
			{
				MethodBase mb = GetMethod();
				MethodInfo mi = mb as MethodInfo;
				if(mi != null)
				{
					Debug.Assert(mi.Name == "newhelper");
					ilgen.Emit(OpCodes.Call, mi);
				}
				else
				{
					ilgen.Emit(OpCodes.Newobj, mb);
				}
			}
#endif // EMITTERS

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
			[HideFromJava]
			internal override object Invoke(object obj, object[] args)
			{
				MethodBase mb = mbHelper != null ? mbHelper : GetMethod();
				if (mb.IsStatic && !IsStatic)
				{
					args = ArrayUtil.Concat(obj, args);
					obj = null;
				}
				return InvokeAndUnwrapException(mb, obj, args);
			}

			[HideFromJava]
			internal override object CreateInstance(object[] args)
			{
				MethodBase mb = mbHelper != null ? mbHelper : GetMethod();
				if (mb.IsStatic)
				{
					return InvokeAndUnwrapException(mb, null, args);
				}
				return base.CreateInstance(args);
			}

			[HideFromJava]
			internal override object InvokeNonvirtualRemapped(object obj, object[] args)
			{
				MethodInfo mi = mbNonvirtualHelper;
				if (mi == null)
				{
					mi = mbHelper;
				}
				return mi.Invoke(null, ArrayUtil.Concat(obj, args));
			}
#endif // !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR

#if EMITTERS
			internal override void EmitCallvirtReflect(CodeEmitter ilgen)
			{
				MethodBase mb = mbHelper != null ? mbHelper : GetMethod();
				ilgen.Emit(mb.IsStatic ? OpCodes.Call : OpCodes.Callvirt, mb);
			}
#endif // EMITTERS

			internal string GetGenericSignature()
			{
				SignatureAttribute attr = AttributeHelper.GetSignature(mbHelper != null ? mbHelper : GetMethod());
				if(attr != null)
				{
					return attr.Signature;
				}
				return null;
			}
		}

		private static TypeWrapper TypeWrapperFromModOpt(Type[] modopt)
		{
			int rank = 0;
			TypeWrapper tw = null;
			foreach (Type type in modopt)
			{
				if (type == JVM.LoadType(typeof(IKVM.Attributes.AccessStub)))
				{
					// ignore
				}
				else if (type == Types.Array)
				{
					rank++;
				}
				else if (type == Types.Void || type.IsPrimitive || ClassLoaderWrapper.IsRemappedType(type))
				{
					tw = DotNetTypeWrapper.GetWrapperFromDotNetType(type);
				}
				else if (type.DeclaringType != null && type.DeclaringType.FullName == UnloadableTypeWrapper.ContainerTypeName)
				{
					tw = new UnloadableTypeWrapper(TypeNameUtil.UnmangleNestedTypeName(type.Name), type);
				}
				else
				{
					tw = ClassLoaderWrapper.GetWrapperFromType(type);
				}
			}
			if (rank != 0)
			{
				tw = tw.MakeArrayType(rank);
			}
			return tw;
		}

		private static TypeWrapper GetPropertyTypeWrapper(PropertyInfo property)
		{
			return TypeWrapperFromModOpt(property.GetOptionalCustomModifiers())
				?? ClassLoaderWrapper.GetWrapperFromType(property.PropertyType);
		}

		internal static TypeWrapper GetFieldTypeWrapper(FieldInfo field)
		{
			return TypeWrapperFromModOpt(field.GetOptionalCustomModifiers())
				?? ClassLoaderWrapper.GetWrapperFromType(field.FieldType);
		}

		internal static TypeWrapper GetParameterTypeWrapper(ParameterInfo param)
		{
			TypeWrapper tw = TypeWrapperFromModOpt(param.GetOptionalCustomModifiers());
			if (tw != null)
			{
				return tw;
			}
			Type parameterType = param.ParameterType;
			if (parameterType.IsByRef)
			{
				// we only support ByRef parameters for automatically generated delegate invoke stubs
				parameterType = parameterType.GetElementType().MakeArrayType();
			}
			return ClassLoaderWrapper.GetWrapperFromType(parameterType);
		}

		private FieldWrapper CreateFieldWrapper(FieldInfo field, HideFromJavaFlags hideFromJavaFlags)
		{
			ExModifiers modifiers = AttributeHelper.GetModifiers(field, false);
			TypeWrapper type = GetFieldTypeWrapper(field);
			string name = field.Name;

			if(field.IsSpecialName)
			{
				name = UnicodeUtil.UnescapeInvalidSurrogates(name);
			}

			if(field.IsLiteral)
			{
				MemberFlags flags = MemberFlags.None;
				if((hideFromJavaFlags & HideFromJavaFlags.Reflection) != 0)
				{
					flags |= MemberFlags.HideFromReflection;
				}
				if(modifiers.IsInternal)
				{
					flags |= MemberFlags.InternalAccess;
				}
				return new ConstantFieldWrapper(this, type, name, type.SigName, modifiers.Modifiers, field, null, flags);
			}
			else
			{
				return FieldWrapper.Create(this, type, field, name, type.SigName, modifiers);
			}
		}

		internal override Type TypeAsTBD
		{
			get
			{
				return type;
			}
		}

		internal override bool IsMapUnsafeException
		{
			get
			{
				return AttributeHelper.IsExceptionIsUnsafeForMapping(type);
			}
		}

#if EMITTERS
		internal override void EmitRunClassConstructor(CodeEmitter ilgen)
		{
			if(HasStaticInitializer)
			{
				ilgen.Emit(OpCodes.Call, clinitMethod);
			}
		}
#endif // EMITTERS

		internal override string GetGenericSignature()
		{
			SignatureAttribute attr = AttributeHelper.GetSignature(type);
			if(attr != null)
			{
				return attr.Signature;
			}
			return null;
		}

		internal override string GetGenericMethodSignature(MethodWrapper mw)
		{
			if(mw is CompiledRemappedMethodWrapper)
			{
				return ((CompiledRemappedMethodWrapper)mw).GetGenericSignature();
			}
			MethodBase mb = mw.GetMethod();
			if(mb != null)
			{
				SignatureAttribute attr = AttributeHelper.GetSignature(mb);
				if(attr != null)
				{
					return attr.Signature;
				}
			}
			return null;
		}

		internal override string GetGenericFieldSignature(FieldWrapper fw)
		{
			FieldInfo fi = fw.GetField();
			if(fi != null)
			{
				SignatureAttribute attr = AttributeHelper.GetSignature(fi);
				if(attr != null)
				{
					return attr.Signature;
				}
			}
			return null;
		}

		internal override MethodParametersEntry[] GetMethodParameters(MethodWrapper mw)
		{
			MethodBase mb = mw.GetMethod();
			if (mb == null)
			{
				// delegate constructor
				return null;
			}
			MethodParametersAttribute attr = AttributeHelper.GetMethodParameters(mb);
			if (attr == null)
			{
				return null;
			}
			if (attr.IsMalformed)
			{
				return MethodParametersEntry.Malformed;
			}
			ParameterInfo[] parameters = mb.GetParameters();
			MethodParametersEntry[] mp = new MethodParametersEntry[attr.Modifiers.Length];
			for (int i = 0; i < mp.Length; i++)
			{
				mp[i].name = i < parameters.Length ? parameters[i].Name : null;
				mp[i].flags = (ushort)attr.Modifiers[i];
			}
			return mp;
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal override string[] GetEnclosingMethod()
		{
			EnclosingMethodAttribute enc = AttributeHelper.GetEnclosingMethodAttribute(type);
			if (enc != null)
			{
				return new string[] { enc.ClassName, enc.MethodName, enc.MethodSignature };
			}
			return null;
		}

		internal override object[] GetDeclaredAnnotations()
		{
			return type.GetCustomAttributes(false);
		}

		internal override object[] GetMethodAnnotations(MethodWrapper mw)
		{
			MethodBase mb = mw.GetMethod();
			if(mb == null)
			{
				// delegate constructor
				return null;
			}
			return mb.GetCustomAttributes(false);
		}

		internal override object[][] GetParameterAnnotations(MethodWrapper mw)
		{
			MethodBase mb = mw.GetMethod();
			if(mb == null)
			{
				// delegate constructor
				return null;
			}
			ParameterInfo[] parameters = mb.GetParameters();
			int skip = 0;
			if(mb.IsStatic && !mw.IsStatic && mw.Name != "<init>")
			{
				skip = 1;
			}
			int skipEnd = 0;
			if(mw.HasCallerID)
			{
				skipEnd = 1;
			}
			object[][] attribs = new object[parameters.Length - skip - skipEnd][];
			for(int i = skip; i < parameters.Length - skipEnd; i++)
			{
				attribs[i - skip] = parameters[i].GetCustomAttributes(false);
			}
			return attribs;
		}

		internal override object[] GetFieldAnnotations(FieldWrapper fw)
		{
			FieldInfo field = fw.GetField();
			if(field != null)
			{
				return field.GetCustomAttributes(false);
			}
			CompiledPropertyFieldWrapper prop = fw as CompiledPropertyFieldWrapper;
			if(prop != null)
			{
				return prop.GetProperty().GetCustomAttributes(false);
			}
			return new object[0];
		}
#endif

		internal sealed class CompiledAnnotation : Annotation
		{
			private readonly ConstructorInfo constructor;

			internal CompiledAnnotation(Type type)
			{
				constructor = type.GetConstructor(new Type[] { JVM.Import(typeof(object[])) });
			}

			private CustomAttributeBuilder MakeCustomAttributeBuilder(ClassLoaderWrapper loader, object annotation)
			{
				return new CustomAttributeBuilder(constructor, new object[] { AnnotationDefaultAttribute.Escape(QualifyClassNames(loader, annotation)) });
			}

			internal override void Apply(ClassLoaderWrapper loader, TypeBuilder tb, object annotation)
			{
				tb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
			}

			internal override void Apply(ClassLoaderWrapper loader, MethodBuilder mb, object annotation)
			{
				mb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
			}

			internal override void Apply(ClassLoaderWrapper loader, FieldBuilder fb, object annotation)
			{
				fb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
			}

			internal override void Apply(ClassLoaderWrapper loader, ParameterBuilder pb, object annotation)
			{
				pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
			}

			internal override void Apply(ClassLoaderWrapper loader, AssemblyBuilder ab, object annotation)
			{
				ab.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
			}

			internal override void Apply(ClassLoaderWrapper loader, PropertyBuilder pb, object annotation)
			{
				pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
			}

			internal override bool IsCustomAttribute
			{
				get { return false; }
			}
		}

		internal override Annotation Annotation
		{
			get
			{
				string annotationAttribute = AttributeHelper.GetAnnotationAttributeType(type);
				if(annotationAttribute != null)
				{
					return new CompiledAnnotation(type.Assembly.GetType(annotationAttribute, true));
				}
				return null;
			}
		}

		internal override Type EnumType
		{
			get
			{
				if((this.Modifiers & Modifiers.Enum) != 0)
				{
					return type.GetNestedType("__Enum");
				}
				return null;
			}
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal override string GetSourceFileName()
		{
			object[] attr = type.GetCustomAttributes(typeof(SourceFileAttribute), false);
			if(attr.Length == 1)
			{
				return ((SourceFileAttribute)attr[0]).SourceFile;
			}
			if(DeclaringTypeWrapper != null)
			{
				return DeclaringTypeWrapper.GetSourceFileName();
			}
			if(IsNestedTypeAnonymousOrLocalClass(type))
			{
				return ClassLoaderWrapper.GetWrapperFromType(type.DeclaringType).GetSourceFileName();
			}
			if(type.Module.IsDefined(typeof(SourceFileAttribute), false))
			{
				return type.Name + ".java";
			}
			return null;
		}

		internal override int GetSourceLineNumber(MethodBase mb, int ilOffset)
		{
			object[] attr = mb.GetCustomAttributes(typeof(LineNumberTableAttribute), false);
			if(attr.Length == 1)
			{
				return ((LineNumberTableAttribute)attr[0]).GetLineNumber(ilOffset);
			}
			return -1;
		}
#endif

		internal override bool IsFastClassLiteralSafe
		{
			get { return true; }
		}

		internal override object[] GetConstantPool()
		{
			return AttributeHelper.GetConstantPool(type);
		}

		internal override byte[] GetRawTypeAnnotations()
		{
			return AttributeHelper.GetRuntimeVisibleTypeAnnotations(type);
		}

		internal override byte[] GetMethodRawTypeAnnotations(MethodWrapper mw)
		{
			MethodBase mb = mw.GetMethod();
			return mb == null ? null : AttributeHelper.GetRuntimeVisibleTypeAnnotations(mb);
		}

		internal override byte[] GetFieldRawTypeAnnotations(FieldWrapper fw)
		{
			FieldInfo fi = fw.GetField();
			return fi == null ? null : AttributeHelper.GetRuntimeVisibleTypeAnnotations(fi);
		}
	}

	sealed class ArrayTypeWrapper : TypeWrapper
	{
		private static volatile TypeWrapper[] interfaces;
		private static volatile MethodInfo clone;
		private readonly TypeWrapper ultimateElementTypeWrapper;
		private Type arrayType;
		private bool finished;

		internal ArrayTypeWrapper(TypeWrapper ultimateElementTypeWrapper, string name)
			: base(ultimateElementTypeWrapper.IsInternal ? TypeFlags.InternalAccess : TypeFlags.None,
				Modifiers.Final | Modifiers.Abstract | (ultimateElementTypeWrapper.Modifiers & Modifiers.Public), name)
		{
			Debug.Assert(!ultimateElementTypeWrapper.IsArray);
			this.ultimateElementTypeWrapper = ultimateElementTypeWrapper;
		}

		internal override TypeWrapper BaseTypeWrapper
		{
			get { return CoreClasses.java.lang.Object.Wrapper; }
		}

		internal override ClassLoaderWrapper GetClassLoader()
		{
			return ultimateElementTypeWrapper.GetClassLoader();
		}

		internal static MethodInfo CloneMethod
		{
			get
			{
				if(clone == null)
				{
					clone = Types.Array.GetMethod("Clone", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
				}
				return clone;
			}
		}

		protected override void LazyPublishMembers()
		{
			MethodWrapper mw = new SimpleCallMethodWrapper(this, "clone", "()Ljava.lang.Object;", CloneMethod, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Public, MemberFlags.HideFromReflection, SimpleOpCode.Callvirt, SimpleOpCode.Callvirt);
			mw.Link();
			SetMethods(new MethodWrapper[] { mw });
			SetFields(FieldWrapper.EmptyArray);
		}

		internal override Modifiers ReflectiveModifiers
		{
			get
			{
				return Modifiers.Final | Modifiers.Abstract | (ultimateElementTypeWrapper.ReflectiveModifiers & Modifiers.AccessMask);
			}
		}

		internal override string SigName
		{
			get
			{
				// for arrays the signature name is the same as the normal name
				return Name;
			}
		}

		internal override TypeWrapper[] Interfaces
		{
			get
			{
				if(interfaces == null)
				{
					TypeWrapper[] tw = new TypeWrapper[2];
					tw[0] = CoreClasses.java.lang.Cloneable.Wrapper;
					tw[1] = CoreClasses.java.io.Serializable.Wrapper;
					interfaces = tw;
				}
				return interfaces;
			}
		}

		internal override Type TypeAsTBD
		{
			get
			{
				while (arrayType == null)
				{
					bool prevFinished = finished;
					Type type = MakeArrayType(ultimateElementTypeWrapper.TypeAsArrayType, this.ArrayRank);
					if (prevFinished)
					{
						// We were already finished prior to the call to MakeArrayType, so we can safely
						// set arrayType to the finished type.
						// Note that this takes advantage of the fact that once we've been finished,
						// we can never become unfinished.
						arrayType = type;
					}
					else
					{
						lock (this)
						{
							// To prevent a race with Finish, we can only set arrayType in this case
							// (inside the locked region) if we've not already finished. If we have
							// finished, we need to rerun MakeArrayType on the now finished element type.
							// Note that there is a benign race left, because it is possible that another
							// thread finishes right after we've set arrayType and exited the locked
							// region. This is not problem, because TypeAsTBD is only guaranteed to
							// return a finished type *after* Finish has been called.
							if (!finished)
							{
								arrayType = type;
							}
						}
					}
				}
				return arrayType;
			}
		}

		internal override void Finish()
		{
			if (!finished)
			{
				ultimateElementTypeWrapper.Finish();
				lock (this)
				{
					// Now that we've finished the element type, we must clear arrayType,
					// because it may still refer to a TypeBuilder. Note that we have to
					// do this atomically with setting "finished", to prevent a race
					// with TypeAsTBD.
					finished = true;
					arrayType = null;
				}
			}
		}

		internal override bool IsFastClassLiteralSafe
		{
			// here we have to deal with the somewhat strange fact that in Java you cannot represent primitive type class literals,
			// but you can represent arrays of primitive types as a class literal
			get { return ultimateElementTypeWrapper.IsFastClassLiteralSafe || ultimateElementTypeWrapper.IsPrimitive; }
		}

		internal override TypeWrapper GetUltimateElementTypeWrapper()
		{
			return ultimateElementTypeWrapper;
		}

		internal static Type MakeArrayType(Type type, int dims)
		{
			// NOTE this is not just an optimization, but it is also required to
			// make sure that ReflectionOnly types stay ReflectionOnly types
			// (in particular instantiations of generic types from mscorlib that
			// have ReflectionOnly type parameters).
			for(int i = 0; i < dims; i++)
			{
				type = type.MakeArrayType();
			}
			return type;
		}
	}

	// this is a container for the special verifier TypeWrappers
	sealed class VerifierTypeWrapper : TypeWrapper
	{
		// the TypeWrapper constructor interns the name, so we have to pre-intern here to make sure we have the same string object
		// (if it has only been interned previously)
		private static readonly string This = string.Intern("this");
		private static readonly string New = string.Intern("new");
		private static readonly string Fault = string.Intern("<fault>");
		internal static readonly TypeWrapper Invalid = null;
		internal static readonly TypeWrapper Null = new VerifierTypeWrapper("null", 0, null, null);
		internal static readonly TypeWrapper UninitializedThis = new VerifierTypeWrapper("uninitialized-this", 0, null, null);
		internal static readonly TypeWrapper Unloadable = new UnloadableTypeWrapper("<verifier>");
		internal static readonly TypeWrapper ExtendedFloat = new VerifierTypeWrapper("<extfloat>", 0, null, null);
		internal static readonly TypeWrapper ExtendedDouble = new VerifierTypeWrapper("<extdouble>", 0, null, null);

		private readonly int index;
		private readonly TypeWrapper underlyingType;
		private readonly MethodAnalyzer methodAnalyzer;

#if STUB_GENERATOR
		internal class MethodAnalyzer
		{
			internal void ClearFaultBlockException(int dummy) { }
		}
#endif

		public override string ToString()
		{
			return GetType().Name + "[" + Name + "," + index + "," + underlyingType + "]";
		}

		internal static TypeWrapper MakeNew(TypeWrapper type, int bytecodeIndex)
		{
			return new VerifierTypeWrapper(New, bytecodeIndex, type, null);
		}

		internal static TypeWrapper MakeFaultBlockException(MethodAnalyzer ma, int handlerIndex)
		{
			return new VerifierTypeWrapper(Fault, handlerIndex, null, ma);
		}

		// NOTE the "this" type is special, it can only exist in local[0] and on the stack
		// as soon as the type on the stack is merged or popped it turns into its underlying type.
		// It exists to capture the verification rules for non-virtual base class method invocation in .NET 2.0,
		// which requires that the invocation is done on a "this" reference that was directly loaded onto the
		// stack (using ldarg_0).
		internal static TypeWrapper MakeThis(TypeWrapper type)
		{
			return new VerifierTypeWrapper(This, 0, type, null);
		}

		internal static bool IsNotPresentOnStack(TypeWrapper w)
		{
			return IsNew(w) || IsFaultBlockException(w);
		}

		internal static bool IsNew(TypeWrapper w)
		{
			return w != null && w.IsVerifierType && ReferenceEquals(w.Name, New);
		}

		internal static bool IsFaultBlockException(TypeWrapper w)
		{
			return w != null && w.IsVerifierType && ReferenceEquals(w.Name, Fault);
		}

		internal static bool IsNullOrUnloadable(TypeWrapper w)
		{
			return w == Null || w.IsUnloadable;
		}

		internal static bool IsThis(TypeWrapper w)
		{
			return w != null && w.IsVerifierType && ReferenceEquals(w.Name, This);
		}

		internal static void ClearFaultBlockException(TypeWrapper w)
		{
			VerifierTypeWrapper vtw = (VerifierTypeWrapper)w;
			vtw.methodAnalyzer.ClearFaultBlockException(vtw.Index);
		}

		internal int Index
		{
			get
			{
				return index;
			}
		}

		internal TypeWrapper UnderlyingType
		{
			get
			{
				return underlyingType;
			}
		}

		private VerifierTypeWrapper(string name, int index, TypeWrapper underlyingType, MethodAnalyzer methodAnalyzer)
			: base(TypeFlags.None, TypeWrapper.VerifierTypeModifiersHack, name)
		{
			this.index = index;
			this.underlyingType = underlyingType;
			this.methodAnalyzer = methodAnalyzer;
		}

		internal override TypeWrapper BaseTypeWrapper
		{
			get { return null; }
		}

		internal override ClassLoaderWrapper GetClassLoader()
		{
			return null;
		}

		protected override void LazyPublishMembers()
		{
			throw new InvalidOperationException("LazyPublishMembers called on " + this);
		}

		internal override Type TypeAsTBD
		{
			get
			{
				throw new InvalidOperationException("get_Type called on " + this);
			}
		}

		internal override TypeWrapper[] Interfaces
		{
			get
			{
				throw new InvalidOperationException("get_Interfaces called on " + this);
			}
		}

		internal override TypeWrapper[] InnerClasses
		{
			get
			{
				throw new InvalidOperationException("get_InnerClasses called on " + this);
			}
		}

		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				throw new InvalidOperationException("get_DeclaringTypeWrapper called on " + this);
			}
		}

		internal override void Finish()
		{
			throw new InvalidOperationException("Finish called on " + this);
		}
	}

#if !STATIC_COMPILER && !STUB_GENERATOR
	// this represents an intrinsified anonymous class (currently used only by LambdaMetafactory)
	sealed class AnonymousTypeWrapper : TypeWrapper
	{
		private readonly Type type;

		internal AnonymousTypeWrapper(Type type)
			: base(TypeFlags.Anonymous, Modifiers.Final | Modifiers.Synthetic, GetName(type))
		{
			this.type = type;
		}

		internal static bool IsAnonymous(Type type)
		{
			return type.IsSpecialName
				&& type.Name.StartsWith(NestedTypeName.IntrinsifiedAnonymousClass, StringComparison.Ordinal)
				&& AttributeHelper.IsJavaModule(type.Module);
		}

		private static string GetName(Type type)
		{
			return ClassLoaderWrapper.GetWrapperFromType(type.DeclaringType).Name
				+ type.Name.Replace(NestedTypeName.IntrinsifiedAnonymousClass, "$$Lambda$");
		}

		internal override ClassLoaderWrapper GetClassLoader()
		{
			return ClassLoaderWrapper.GetWrapperFromType(type.DeclaringType).GetClassLoader();
		}

		internal override Type TypeAsTBD
		{
			get { return type; }
		}

		internal override TypeWrapper BaseTypeWrapper
		{
			get { return CoreClasses.java.lang.Object.Wrapper; }
		}

		internal override TypeWrapper[] Interfaces
		{
			get
			{
				TypeWrapper[] interfaces = GetImplementedInterfacesAsTypeWrappers(type);
				if (type.IsSerializable)
				{
					// we have to remove the System.Runtime.Serialization.ISerializable interface
					List<TypeWrapper> list = new List<TypeWrapper>(interfaces);
					list.RemoveAll(Serialization.IsISerializable);
					return list.ToArray();
				}
				return interfaces;
			}
		}

		protected override void LazyPublishMembers()
		{
			List<MethodWrapper> methods = new List<MethodWrapper>();
			foreach (MethodInfo mi in type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly))
			{
				if (mi.IsSpecialName)
				{
					// we use special name to hide default methods
				}
				else if (mi.IsPublic)
				{
					TypeWrapper returnType;
					TypeWrapper[] parameterTypes;
					string signature;
					GetSig(mi, out returnType, out parameterTypes, out signature);
					methods.Add(new TypicalMethodWrapper(this, mi.Name, signature, mi, returnType, parameterTypes, Modifiers.Public, MemberFlags.None));
				}
				else if (mi.Name == "writeReplace")
				{
					methods.Add(new TypicalMethodWrapper(this, "writeReplace", "()Ljava.lang.Object;", mi, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray,
						Modifiers.Private | Modifiers.Final, MemberFlags.None));
				}
			}
			SetMethods(methods.ToArray());
			List<FieldWrapper> fields = new List<FieldWrapper>();
			foreach (FieldInfo fi in type.GetFields(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly))
			{
				TypeWrapper fieldType = CompiledTypeWrapper.GetFieldTypeWrapper(fi);
				fields.Add(new SimpleFieldWrapper(this, fieldType, fi, fi.Name, fieldType.SigName, new ExModifiers(Modifiers.Private | Modifiers.Final, false)));
			}
			SetFields(fields.ToArray());
		}

		private void GetSig(MethodInfo mi, out TypeWrapper returnType, out TypeWrapper[] parameterTypes, out string signature)
		{
			returnType = CompiledTypeWrapper.GetParameterTypeWrapper(mi.ReturnParameter);
			ParameterInfo[] parameters = mi.GetParameters();
			parameterTypes = new TypeWrapper[parameters.Length];
			System.Text.StringBuilder sb = new System.Text.StringBuilder("(");
			for (int i = 0; i < parameters.Length; i++)
			{
				parameterTypes[i] = CompiledTypeWrapper.GetParameterTypeWrapper(parameters[i]);
				sb.Append(parameterTypes[i].SigName);
			}
			sb.Append(')');
			sb.Append(returnType.SigName);
			signature = sb.ToString();
		}
	}
#endif // !STATIC_COMPILER && !STUB_GENERATOR
}
@


1.488
log
@Made TypeWrapper.[Interfaces|InnerClasses|DeclaringTypeWrapper|Finish] non-abstract to implement common behavior.
@
text
@d3658 7
@


1.488.2.1
log
@Ported from main branch:
- Fix for #303. Don't crash when trying to get interfaces from type from missing assembly reference.
- Implemented atomic file move (on Windows).
@
text
@a3657 7
#if STATIC_COMPILER
				if (missingType != null)
				{
					StaticCompiler.IssueMissingTypeMessage(missingType);
					return TypeWrapper.EmptyArray;
				}
#endif
@


1.487
log
@Fixed regression introduced in previous change. Untangled TypeWrapper finishing from linking.
@
text
@d3127 1
a3127 1
		internal abstract TypeWrapper[] Interfaces
d3129 1
a3129 1
			get;
d3133 1
a3133 1
		internal abstract TypeWrapper[] InnerClasses
d3135 1
a3135 1
			get;
d3139 1
a3139 1
		internal abstract TypeWrapper DeclaringTypeWrapper
d3141 1
a3141 1
			get;
d3144 3
a3146 1
		internal abstract void Finish();
a3777 28
		internal override TypeWrapper[] Interfaces
		{
			get
			{
				return TypeWrapper.EmptyArray;
			}
		}

		internal override TypeWrapper[] InnerClasses
		{
			get
			{
				return TypeWrapper.EmptyArray;
			}
		}

		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				return null;
			}
		}

		internal override void Finish()
		{
		}

a5110 4
		internal override void Finish()
		{
		}

a5474 16
		internal override TypeWrapper[] InnerClasses
		{
			get
			{
				return TypeWrapper.EmptyArray;
			}
		}

		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				return null;
			}
		}

a5770 14
		internal override TypeWrapper[] InnerClasses
		{
			get { return TypeWrapper.EmptyArray; }
		}

		internal override TypeWrapper DeclaringTypeWrapper
		{
			get { return null; }
		}

		internal override void Finish()
		{
		}

@


1.486
log
@Removed unnecessary finishing of base TypeWrapper and interfaces from CompiledTypeWrapper and DotNetTypeWrapper.
@
text
@d1951 1
d3146 25
@


1.485
log
@Performance fix. Use a sentinel value instead of null for the unknown baseTypeWrapper state, because null is a valid value.
@
text
@a5112 8
			if(BaseTypeWrapper != null)
			{
				BaseTypeWrapper.Finish();
			}
			foreach(TypeWrapper tw in this.Interfaces)
			{
				tw.Finish();
			}
@


1.484
log
@Removed sig decoding methods with implicit LoadMode.
@
text
@d3787 1
a3787 1
		private TypeWrapper baseTypeWrapper;
d4077 8
a4084 1
			get { return baseTypeWrapper ?? (baseTypeWrapper = GetBaseTypeWrapper(type)); }
@


1.483
log
@Bug fix. Dynamica caller id should return host class for anonymous classes injected into host class.
@
text
@d233 1
a233 1
			TypeWrapper[] twargs = loader.ArgTypeWrapperListFromSigNoThrow(attr.Sig);
d242 1
a242 1
					tw = loader.FieldTypeWrapperFromSigNoThrow(attr.Params[i].Sig);
d290 1
a290 1
						propertyValues[i] = ParseValue(loader, loader.FieldTypeWrapperFromSigNoThrow(attr.Properties[i].Sig), attr.Properties[i].Value);
d307 1
a307 1
						fieldValues[i] = ParseValue(loader, loader.FieldTypeWrapperFromSigNoThrow(attr.Fields[i].Sig), attr.Fields[i].Value);
d336 1
a336 1
						fieldValues[i] = ParseValue(loader, loader.FieldTypeWrapperFromSigNoThrow(attr.Fields[i].Sig), attr.Fields[i].Value);
d1633 1
a1633 1
					return loader.RetTypeWrapperFromSig(annotationClass.Replace('/', '.')).Annotation;
d1662 1
a1662 1
				TypeWrapper tw = owner.GetClassLoader().RetTypeWrapperFromSigNoThrow(annotationClass.Replace('/', '.'));
d1728 1
a1728 1
				return loader.FieldTypeWrapperFromSig(((string)((object[])obj)[1]).Replace('/', '.')).TypeAsTBD;
d4365 1
a4365 1
					type = GetClassLoader().FieldTypeWrapperFromSig(sigtype);
@


1.482
log
@Made the CallerID from signature stripping for CallerSensitive methods more robust.
@
text
@d3548 7
@


1.481
log
@Bug fix. MethodHandle interface method lookup should support methods inherited from base interfaces.
@
text
@d4443 1
a4443 1
		private bool IsCallerID(Type type)
d4448 19
a4466 2
			return type == CoreClasses.ikvm.@@internal.CallerID.Wrapper.TypeAsSignatureType
				&& GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader();
d4477 2
a4478 1
				&& !method.DeclaringType.IsInterface)
@


1.480
log
@Bug fix. Removed legacy (incorrect) array assignability check that compensated for the lack of ghost array typing. This should have been removed when ghost array tagging was introduced.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2014 Jeroen Frijters
d2751 19
@


1.479
log
@Remove AnonymousTypeWrapper from ikvmstub and ikvmc.
@
text
@d3089 1
a3089 1
				return (!elem1.IsNonPrimitiveValueType && elem1.IsSubTypeOf(elem2)) || (rank1 == rank2 && elem2.IsGhost && elem1 == CoreClasses.java.lang.Object.Wrapper);
@


1.478
log
@Added method and field reflection support for lambda classes.
@
text
@d5692 1
d5811 1
@


1.477
log
@Added .NET serialization interop to lambda classes.
@
text
@d4992 1
a4992 1
		private static TypeWrapper GetFieldTypeWrapper(FieldInfo field)
d4998 1
a4998 1
		private static TypeWrapper GetParameterTypeWrapper(ParameterInfo param)
d5763 2
a5764 2
			MethodInfo mi = type.GetMethod("writeReplace", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly, null, Type.EmptyTypes, null);
			if (mi != null)
d5766 17
a5782 3
				SetMethods(new MethodWrapper[] {
					new TypicalMethodWrapper(this, "writeReplace", "()Ljava.lang.Object;", mi, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Private, MemberFlags.None)
				});
d5784 17
a5800 1
			else
d5802 2
a5803 1
				SetMethods(MethodWrapper.EmptyArray);
d5805 3
a5807 1
			SetFields(FieldWrapper.EmptyArray);
@


1.476
log
@Added support for intrinsifying serializable lambdas.
@
text
@d5733 12
a5744 1
			get { return GetImplementedInterfacesAsTypeWrappers(type); }
@


1.475
log
@Simplified the anonymous class name mangling.
@
text
@d5749 16
@


1.474
log
@Include full class name of anonymous classes in stack trace (i.e. including the "/<identityHashCode>" suffix.)
@
text
@d5698 1
a5698 1
			: base(TypeFlags.None, Modifiers.Final | Modifiers.Synthetic, GetName(type))
d5710 1
a5710 1
		internal static string GetName(Type type)
d5713 1
a5713 2
				+ type.Name.Replace(NestedTypeName.IntrinsifiedAnonymousClass, "$$Lambda$")
				+ "/" + (type.GetHashCode() & Int32.MaxValue);
@


1.473
log
@Added intrinsic for LambdaMetafactory.metafactory().
@
text
@d1950 1
d2368 6
@


1.472
log
@Bug fix. Handle malformed UTF-16 (invalid surrogates) in type/member names and annotations.
@
text
@d1980 1
d5684 60
@


1.471
log
@Removed unused method.
@
text
@d432 1
d452 2
a453 1
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(nonNestedInnerClassAttribute, new object[] { className }));
d462 2
a463 1
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(nonNestedOuterClassAttribute, new object[] { className }));
d566 1
a566 1
				interfaces[i] = ifaceWrappers[i].Name;
d773 2
a774 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofNameSigAttribute.GetConstructor(new Type[] { Types.String, Types.String }), new object[] { name, sig });
d781 1
a781 1
			object[] args = new object[] { innerClass, modifiers };
d836 2
a837 1
			tb.SetCustomAttribute(new CustomAttributeBuilder(enclosingMethodAttribute, new object[] { className, methodName, methodSig }));
d846 2
a847 1
			tb.SetCustomAttribute(new CustomAttributeBuilder(signatureAttribute, new object[] { signature }));
d856 2
a857 1
			fb.SetCustomAttribute(new CustomAttributeBuilder(signatureAttribute, new object[] { signature }));
d866 2
a867 1
			mb.SetCustomAttribute(new CustomAttributeBuilder(signatureAttribute, new object[] { signature }));
d1007 1
a1007 1
				list.Add((string)args[0].Value);
d1022 1
a1022 1
				return (string)args[0].Value;
d1066 1
a1066 1
				return DecodeArray<object>(cad.ConstructorArguments[0]);
d1164 1
a1164 1
				return (string)cad.ConstructorArguments[0].Value;
d1406 1
d1540 82
d4482 4
d5010 6
d5028 1
a5028 1
				return new ConstantFieldWrapper(this, type, field.Name, type.SigName, modifiers.Modifiers, field, null, flags);
d5032 1
a5032 1
				return FieldWrapper.Create(this, type, field, field.Name, type.SigName, modifiers);
d5224 1
a5224 1
				return new CustomAttributeBuilder(constructor, new object[] { QualifyClassNames(loader, annotation) });
@


1.470
log
@Implemented type annotation reflection for statically compiled classes.
@
text
@a773 10
		internal static byte[] FreezeDryType(Type type)
		{
			System.IO.MemoryStream mem = new System.IO.MemoryStream();
			System.IO.BinaryWriter bw = new System.IO.BinaryWriter(mem, System.Text.UTF8Encoding.UTF8);
			bw.Write((short)1);
			bw.Write(type.FullName);
			bw.Write((short)0);
			return mem.ToArray();
		}

@


1.469
log
@Implemented type annotation reflection for dynamically loaded classes.
@
text
@d83 2
d112 2
d881 36
d1060 28
d5235 22
@


1.468
log
@- Enabled MethodParameter rendering in runtime stub generator.
- Support round tripping malformed MethodParameter attribute in stub generator.
- Use new general method parameter interface in ikvmstub.
- Added support for method parameter reflection on .NET types.
@
text
@d3352 20
@


1.467
log
@Added support for MethodParameters in statically compiled classes.
@
text
@d62 7
d3165 5
a3190 5
		internal virtual ClassFile.Method.MethodParametersEntry[] GetMethodParameters(MethodWrapper mw)
		{
			return null;
		}

d4937 27
a5017 27
		internal override ClassFile.Method.MethodParametersEntry[] GetMethodParameters(MethodWrapper mw)
		{
			MethodBase mb = mw.GetMethod();
			if(mb == null)
			{
				// delegate constructor
				return null;
			}
			MethodParametersAttribute attr = AttributeHelper.GetMethodParameters(mb);
			if(attr == null)
			{
				return null;
			}
			if(attr.IsMalformed)
			{
				return ClassFile.Method.MethodParametersEntry.Malformed;
			}
			ParameterInfo[] parameters = mb.GetParameters();
			ClassFile.Method.MethodParametersEntry[] mp = new ClassFile.Method.MethodParametersEntry[attr.Modifiers.Length];
			for(int i = 0; i < mp.Length; i++)
			{
				mp[i].name = i < parameters.Length ? parameters[i].Name : null;
				mp[i].flags = (ushort)attr.Modifiers[i];
			}
			return mp;
		}

@


1.466
log
@Implemented method parameter reflection for dynamically loaded classes.
@
text
@d75 1
d102 1
d861 9
d998 15
d4984 27
@


1.465
log
@Load annotation type with RetTypeWrapperFromSigNoThrow to ensure that we emit a class not found warning when warning level high is enabled.
@
text
@d3153 5
@


1.464
log
@GhostMethodWrapper can also be a default method.
@
text
@d1480 4
a1483 11
				try
				{
					TypeWrapper tw = owner.GetClassLoader().RetTypeWrapperFromSig(annotationClass.Replace('/', '.'));
					// Java allows inaccessible annotations to be used, so when the annotation isn't visible
					// we fall back to using the DynamicAnnotationAttribute.
					if (tw.IsAccessibleFrom(owner))
					{
						return tw.Annotation;
					}
				}
				catch (RetargetableJavaException)
d1485 1
@


1.463
log
@Only create GhostMethodWrapper for virtual methods in ghost interfaces.
@
text
@d4417 4
@


1.462
log
@Fixed Java 8 default interface method handling.
@
text
@d4408 1
a4408 1
					if (IsGhost)
@


1.461
log
@Move private interface methods into a nested type when C# compiler workarounds are enabled.
@
text
@d1431 7
d4260 1
a4260 3
					TypeWrapper[] temp = paramTypes;
					paramTypes = new TypeWrapper[sigparams.Length];
					Array.Copy(temp, 1, paramTypes, 0, paramTypes.Length);
d4282 4
d4406 1
d4422 4
d4455 24
@


1.460
log
@Support private instance methods in (Java 8) interfaces.
@
text
@d1784 1
d4338 2
a4339 1
			foreach(MethodInfo method in type.GetMethods(flags))
d4341 5
a4345 2
				HideFromJavaFlags hideFromJavaFlags = AttributeHelper.GetHideFromJavaFlags(method);
				AddMethodOrConstructor(method, hideFromJavaFlags, methods);
d4350 8
@


1.459
log
@Moved nested type names to a central location.
@
text
@d1777 1
d4395 4
@


1.458
log
@Bug fix. Non-public annotations can be used used in code that doesn't have access to them. Implemented that by switching to DynamicAnnotationAttribute when the annotation isn't accessible.
@
text
@d1779 18
@


1.457
log
@Added support for (implementation specific) LambdaForm annotations.
@
text
@d1435 19
d1457 1
a1457 1
		internal static Annotation Load(ClassLoaderWrapper loader, object[] def)
d1475 7
a1481 1
					return loader.RetTypeWrapperFromSig(annotationClass.Replace('/', '.')).Annotation;
@


1.456
log
@- Removed HideFromReflectionAttribute.
- Added flags to HideFromJavaAttribute to support different levels of hiding (including the previous usage of HideFromReflectionAttribute and adding specific ability to hide from security stack walking and from stack traces, for future LamdbaForm support).
@
text
@d476 6
@


1.455
log
@Previous commit broke the build.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
a93 1
		private static readonly Type typeofHideFromReflectionAttribute = JVM.LoadType(typeof(HideFromReflectionAttribute));
d95 1
d102 1
d453 1
a453 8
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofHideFromReflectionAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			mb.SetCustomAttribute(cab);
		}

		internal static void HideFromReflection(MethodBuilder mb, int reason)
		{
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofHideFromReflectionAttribute.GetConstructor(new Type[] { Types.Int32 }), new object[] { reason });
			mb.SetCustomAttribute(cab);
d458 1
a458 2
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofHideFromReflectionAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			fb.SetCustomAttribute(cab);
d463 1
a463 7
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofHideFromReflectionAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			pb.SetCustomAttribute(cab);
		}

		internal static bool IsHideFromReflection(MemberInfo mi)
		{
			return mi.IsDefined(typeofHideFromReflectionAttribute, false);
d496 5
d506 1
a506 1
				return true;
d511 1
a511 1
				return true;
d515 18
a532 1
				return true;
d534 2
a535 1
			return mi.IsDefined(typeofHideFromJavaAttribute, false);
d3594 2
a3595 1
				if(!AttributeHelper.IsHideFromJava(method)
d3599 1
a3599 1
					list.Add(CreateRemappedMethodWrapper(method));
d3609 2
a3610 1
					if(!AttributeHelper.IsHideFromJava(field))
d3612 1
a3612 1
						list.Add(CreateFieldWrapper(field));
d3618 1
a3618 1
			private MethodWrapper CreateRemappedMethodWrapper(MethodBase mb)
d3628 1
a3628 1
				bool hideFromReflection = mbHelper != null && AttributeHelper.IsHideFromReflection(mbHelper);
d4277 2
a4278 1
				if(isDelegate && !ctor.IsStatic && !AttributeHelper.IsHideFromJava(ctor))
d4284 1
a4284 1
					AddMethodOrConstructor(ctor, methods);
d4289 2
a4290 1
				AddMethodOrConstructor(method, methods);
d4295 1
a4295 1
		private void AddMethodOrConstructor(MethodBase method, List<MethodWrapper> methods)
d4297 1
a4297 1
			if(AttributeHelper.IsHideFromJava(method))
d4317 1
a4317 1
					bool hideFromReflection = mi != null ? AttributeHelper.IsHideFromReflection(mi) : false;
d4434 2
a4435 1
				if(AttributeHelper.IsHideFromJava(field))
d4462 1
a4462 1
						fields.Add(CreateFieldWrapper(field));
d4485 2
a4486 1
			if(!AttributeHelper.IsHideFromJava(property))
d4489 1
a4489 1
				if(AttributeHelper.IsHideFromReflection(property))
d4692 1
a4692 1
		private FieldWrapper CreateFieldWrapper(FieldInfo field)
d4700 1
a4700 1
				if(AttributeHelper.IsHideFromReflection(field))
@


1.454
log
@Fixed handling of annotations with invalid type signatures.
@
text
@d1419 1
d1453 1
@


1.453
log
@Added optimization to omit InnerClassesAttribute to record reflective modifiers when we can predict them.
@
text
@d1435 1
a1435 1
			try
d1437 7
a1443 2
				TypeWrapper annot = loader.RetTypeWrapperFromSig(annotationClass.Replace('/', '.'));
				return annot.Annotation;
d1445 1
a1445 3
			catch (RetargetableJavaException)
			{
				Tracer.Warning(Tracer.Compiler, "Unable to load annotation class {0}", annotationClass);
d1447 1
a1447 1
				return new CompiledTypeWrapper.CompiledAnnotation(StaticCompiler.GetRuntimeType("IKVM.Attributes.DynamicAnnotationAttribute"));
d1449 1
a1449 1
				return null;
a1450 1
			}
d1690 4
@


1.452
log
@Added optimization to omit ImplementAttribute in some cases.
@
text
@d3700 4
a3703 4
				if(type.DeclaringType != null)
				{
					return GetName(type.DeclaringType) + "$" + TypeNameUtil.Unescape(type.Name);
				}
d3961 41
d4016 4
@


1.451
log
@Don't store class name in EnclosingMethodAttribute if we can use the DeclaringType.
@
text
@d531 2
a532 1
			if(ifaceWrappers != null && ifaceWrappers.Length != 0)
d534 5
a538 10
				string[] interfaces = new string[ifaceWrappers.Length];
				for(int i = 0; i < interfaces.Length; i++)
				{
					interfaces[i] = ifaceWrappers[i].Name;
				}
				if(implementsAttribute == null)
				{
					implementsAttribute = typeofImplementsAttribute.GetConstructor(new Type[] { JVM.Import(typeof(string[])) });
				}
				typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(implementsAttribute, new object[] { interfaces }));
d540 1
d3846 4
@


1.450
log
@Minor clean up of CompiledTypeWrapper.InnerClasses.
@
text
@d1121 1
a1121 1
				return (EnclosingMethodAttribute)attr[0];
d1127 1
a1127 1
				return new EnclosingMethodAttribute((string)cad.ConstructorArguments[0].Value, (string)cad.ConstructorArguments[1].Value, (string)cad.ConstructorArguments[2].Value);
@


1.449
log
@Compile anonymous and local classes as nested types.
@
text
@d3898 7
a3908 1
				Type[] nestedTypes = type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly);
d3910 1
a3910 1
				for(int i = 0; i < nestedTypes.Length; i++)
d3912 1
a3912 3
					if(nestedTypes[i].Name.EndsWith("Attribute", StringComparison.Ordinal)
						&& nestedTypes[i].IsClass
						&& nestedTypes[i].BaseType.FullName == "ikvm.internal.AnnotationAttributeBase")
a3915 1
						continue;
d3917 9
a3925 1
					if(!IsNestedTypeAnonymousOrLocalClass(nestedTypes[i]) && !AttributeHelper.IsHideFromJava(nestedTypes[i]))
d3927 1
a3927 1
						wrappers.Add(ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]));
@


1.448
log
@Don't add SourceFileAttribute for inner classes if the name matches the outer class.
@
text
@d1110 5
d3886 12
d3914 1
a3914 1
					if(!AttributeHelper.IsHideFromJava(nestedTypes[i]))
d3931 4
d4872 4
@


1.447
log
@Moved pre-compiled proxy type name generation to TypeNameUtil.
@
text
@d4847 4
@


1.446
log
@Introduced TypeWrapper.IsDynamic property.
@
text
@d1285 1
d1378 15
@


1.445
log
@Introduced EMITTERS conditional compilation constant.
@
text
@d1881 1
a1881 1
					Debug.Assert(!(this is DynamicTypeWrapper));
a3195 1
			Debug.Assert(!(this is DynamicTypeWrapper));
d3217 9
@


1.444
log
@Moved JNI invocation of InvokeNonvirtualRemapped into JNI assembly.
@
text
@d1738 1
a1738 1
#if !STUB_GENERATOR
d1771 1
a1771 1
#endif // !STUB_GENERATOR
d2874 1
a2874 1
#if !STUB_GENERATOR
d3009 1
a3009 1
#endif // !STUB_GENERATOR
d3023 1
a3023 1
#if !STUB_GENERATOR
d3027 1
a3027 1
#endif // !STUB_GENERATOR
d3333 1
a3333 1
#if !STUB_GENERATOR
d3349 1
a3349 1
#endif // !STUB_GENERATOR
d4138 1
a4138 1
#if !STUB_GENERATOR
d4145 1
a4145 1
#endif // !STUB_GENERATOR
d4394 1
a4394 1
#if !STUB_GENERATOR
d4447 1
a4447 1
#endif // !STUB_GENERATOR
d4483 1
d4485 1
d4491 1
a4491 1
#endif // !STATIC_COMPILER
d4618 1
a4618 1
#if !STUB_GENERATOR
d4626 1
a4626 1
#endif // !STUB_GENERATOR
@


1.443
log
@Reimplemented JNI non-virtual method invocation based on delegates instead of DynamicMethod.
@
text
@d4474 1
a4474 1
			protected override object InvokeNonvirtualRemapped(object obj, object[] args)
@


1.442
log
@Added NO_REF_EMIT conditional compilation support for reflection.
@
text
@d3207 1
a3207 1
#if !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
@


1.441
log
@Introduced ArrayUtil.Concat() methods.
@
text
@d4451 23
@


1.440
log
@Moved ghost wrapping/unwrapping into TypeWrapper.
@
text
@d1379 20
d3169 1
a3169 2
						Array.Resize(ref interfaces, interfaces.Length + 1);
						interfaces[interfaces.Length - 1] = twRemapped;
a4452 4
				Type[] p1 = GetParametersForDefineMethod();
				Type[] argTypes = new Type[p1.Length + 1];
				p1.CopyTo(argTypes, 1);
				argTypes[0] = this.DeclaringType.TypeAsSignatureType;
d4458 1
a4458 4
				object[] args1 = new object[args.Length + 1];
				args1[0] = obj;
				args.CopyTo(args1, 1);
				return mi.Invoke(null, args1);
@


1.439
log
@Promoted ToPublicSignatureType() method to a TypeWrapper property TypeAsPublicSignatureType.
@
text
@d3187 12
d3626 12
@


1.438
log
@Removed special case for package access check as we now support package access for dynamically injected classes.
@
text
@d2575 8
@


1.437
log
@Implemented Java 8 default interface methods.
@
text
@d2510 1
a2510 9
				if (GetClassLoader() != wrapper.GetClassLoader())
				{
					return false;
				}
#if STATIC_COMPILER || STUB_GENERATOR
				return true;
#else
				return InternalsVisibleTo(wrapper);
#endif
@


1.436
log
@When resolving implemented interfaces we need to handle missing types.
@
text
@d1689 1
d4139 1
a4139 1
				if(method.IsSpecialName && method.Name.StartsWith("__<"))
@


1.435
log
@If GetFieldWrapper() or GetMethodWrapper() is used on a type that has a missing base type, we will end up calling GetFields() or GetMethods() on the base type, so we need to handle that.
@
text
@d3090 31
d3123 1
a3123 1
			Type[] interfaceTypes = type.GetInterfaces();
@


1.434
log
@Minor cleanup.
@
text
@d2369 1
a2369 1
						if(!CheckMissingBaseTypes(TypeAsBaseType))
d2390 1
a2390 1
						if (!CheckMissingBaseTypes(TypeAsBaseType))
@


1.433
log
@Don't add ObsoleteAttribute to deprecated types/members that already have an explicit ObsoleteAttribute annotation.
@
text
@d4649 1
a4649 1
			private readonly Type type;
d4653 1
a4653 1
				this.type = type;
d4656 1
a4656 1
			private CustomAttributeBuilder MakeCustomAttributeBuilder(object annotation)
d4658 1
a4658 1
				return new CustomAttributeBuilder(type.GetConstructor(new Type[] { JVM.Import(typeof(object[])) }), new object[] { annotation });
d4663 1
a4663 2
				annotation = QualifyClassNames(loader, annotation);
				tb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d4668 1
a4668 2
				annotation = QualifyClassNames(loader, annotation);
				mb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d4673 1
a4673 2
				annotation = QualifyClassNames(loader, annotation);
				fb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d4678 1
a4678 2
				annotation = QualifyClassNames(loader, annotation);
				pb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d4683 1
a4683 2
				annotation = QualifyClassNames(loader, annotation);
				ab.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d4688 1
a4688 2
				annotation = QualifyClassNames(loader, annotation);
				pb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
@


1.432
log
@AttributeHelper should have a deterministic class constructor.
@
text
@d1556 15
@


1.431
log
@- Added java.io.Serializable and java.lang.Cloneable to the core classes.
- Replaced LoadClassCritical("ikvm.internal.CallerID") with a core class reference.
@
text
@d103 3
@


1.430
log
@- Marked some fields readonly.
- Memory model fixes.
@
text
@d4812 2
a4813 2
					tw[0] = ClassLoaderWrapper.LoadClassCritical("java.lang.Cloneable");
					tw[1] = ClassLoaderWrapper.LoadClassCritical("java.io.Serializable");
@


1.429
log
@Bug fix. Mark "missing" interface methods so that subclasses (that are compiled separately) know that the base class is incomplete.
@
text
@a63 1
		private static CustomAttributeBuilder hideFromJavaAttribute;
d78 3
a80 3
		private static Type typeofModifiers = JVM.LoadType(typeof(Modifiers));
		private static Type typeofSourceFileAttribute = JVM.LoadType(typeof(SourceFileAttribute));
		private static Type typeofLineNumberTableAttribute = JVM.LoadType(typeof(LineNumberTableAttribute));
d82 20
a101 19
		private static Type typeofRemappedClassAttribute = JVM.LoadType(typeof(RemappedClassAttribute));
		private static Type typeofRemappedTypeAttribute = JVM.LoadType(typeof(RemappedTypeAttribute));
		private static Type typeofModifiersAttribute = JVM.LoadType(typeof(ModifiersAttribute));
		private static Type typeofRemappedInterfaceMethodAttribute = JVM.LoadType(typeof(RemappedInterfaceMethodAttribute));
		private static Type typeofNameSigAttribute = JVM.LoadType(typeof(NameSigAttribute));
		private static Type typeofJavaModuleAttribute = JVM.LoadType(typeof(JavaModuleAttribute));
		private static Type typeofSignatureAttribute = JVM.LoadType(typeof(SignatureAttribute));
		private static Type typeofInnerClassAttribute = JVM.LoadType(typeof(InnerClassAttribute));
		private static Type typeofImplementsAttribute = JVM.LoadType(typeof(ImplementsAttribute));
		private static Type typeofGhostInterfaceAttribute = JVM.LoadType(typeof(GhostInterfaceAttribute));
		private static Type typeofExceptionIsUnsafeForMappingAttribute = JVM.LoadType(typeof(ExceptionIsUnsafeForMappingAttribute));
		private static Type typeofThrowsAttribute = JVM.LoadType(typeof(ThrowsAttribute));
		private static Type typeofHideFromReflectionAttribute = JVM.LoadType(typeof(HideFromReflectionAttribute));
		private static Type typeofHideFromJavaAttribute = JVM.LoadType(typeof(HideFromJavaAttribute));
		private static Type typeofNoPackagePrefixAttribute = JVM.LoadType(typeof(NoPackagePrefixAttribute));
		private static Type typeofAnnotationAttributeAttribute = JVM.LoadType(typeof(AnnotationAttributeAttribute));
		private static Type typeofNonNestedInnerClassAttribute = JVM.LoadType(typeof(NonNestedInnerClassAttribute));
		private static Type typeofNonNestedOuterClassAttribute = JVM.LoadType(typeof(NonNestedOuterClassAttribute));
		private static Type typeofEnclosingMethodAttribute = JVM.LoadType(typeof(EnclosingMethodAttribute));
a477 4
			if(hideFromJavaAttribute == null)
			{
				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			}
a482 4
			if(hideFromJavaAttribute == null)
			{
				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			}
a487 4
			if(hideFromJavaAttribute == null)
			{
				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			}
a493 4
			if(hideFromJavaAttribute == null)
			{
				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			}
d2437 1
d2444 1
d3370 1
a3370 1
		private TypeWrapper[] interfaces;
d3372 1
a3372 1
		private bool clinitMethodSet;
d3525 2
a3526 2
			private FieldInfo ghostRefField;
			private Type typeAsBaseType;
d4286 1
a4286 1
			private MethodInfo mbHelper;
d4288 1
a4288 1
			private MethodInfo mbNonvirtualHelper;
d4631 1
a4631 1
			private Type type;
d4744 2
a4745 2
		private static TypeWrapper[] interfaces;
		private static MethodInfo clone;
d4932 3
a4934 3
		private int index;
		private TypeWrapper underlyingType;
		private MethodAnalyzer methodAnalyzer;
@


1.428
log
@Changed all type flag accessors to readonly and added set methods that can set (but not clear) the flags. Added locking around modifying the flags fields.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2012 Jeroen Frijters
d1686 1
d4094 8
a4101 1
			if(!AttributeHelper.IsHideFromJava(method))
@


1.427
log
@Made TypeWrapper.IsInternal a readonly property.
@
text
@d1690 1
d1973 9
d1989 5
a1993 12
			set
			{
				// TODO do we need locking here?
				if(value)
				{
					flags |= TypeFlags.HasIncompleteInterfaceImplementation;
				}
				else
				{
					flags &= ~TypeFlags.HasIncompleteInterfaceImplementation;
				}
			}
d2010 5
a2014 12
			set
			{
				// TODO do we need locking here?
				if(value)
				{
					flags |= TypeFlags.HasUnsupportedAbstractMethods;
				}
				else
				{
					flags &= ~TypeFlags.HasUnsupportedAbstractMethods;
				}
			}
d2023 5
a2027 12
			set
			{
				// TODO do we need locking here?
				if(value)
				{
					flags |= TypeFlags.HasStaticInitializer;
				}
				else
				{
					flags &= ~TypeFlags.HasStaticInitializer;
				}
			}
d2036 5
a2040 12
			set
			{
				// TODO do we need locking here?
				if(value)
				{
					flags |= TypeFlags.VerifyError;
				}
				else
				{
					flags &= ~TypeFlags.VerifyError;
				}
			}
d2049 5
a2053 12
			set
			{
				// TODO do we need locking here?
				if(value)
				{
					flags |= TypeFlags.ClassFormatError;
				}
				else
				{
					flags &= ~TypeFlags.ClassFormatError;
				}
			}
@


1.426
log
@Added support for "dynamic" (non-loadable type) annotations in statically compiled code.
@
text
@d1671 1
d1702 1
a1702 1
		internal TypeWrapper(Modifiers modifiers, string name)
d1708 1
a2279 12
			set
			{
				// TODO do we need locking here?
				if(value)
				{
					flags |= TypeFlags.InternalAccess;
				}
				else
				{
					flags &= ~TypeFlags.InternalAccess;
				}
			}
d3184 1
a3184 1
			: base(TypeWrapper.UnloadableModifiersHack, name)
d3325 1
a3325 1
			: base(Modifiers.Public | Modifiers.Abstract | Modifiers.Final, null)
d3668 1
a3668 1
			: base(exmod.Modifiers, name)
a3669 1
			this.IsInternal = exmod.IsInternal;
d4782 2
a4783 1
			: base(Modifiers.Final | Modifiers.Abstract | (ultimateElementTypeWrapper.Modifiers & Modifiers.Public), name)
a4786 1
			this.IsInternal = ultimateElementTypeWrapper.IsInternal;
d5047 1
a5047 1
			: base(TypeWrapper.VerifierTypeModifiersHack, name)
@


1.425
log
@Disallow EmitCheckcast() and EmitInstanceOf() on unloadable types.
@
text
@a1414 7
#if STATIC_COMPILER
			catch(ClassNotFoundException x)
			{
				loader.IssueMessage(Message.ClassNotFound, x.Message);
				return null;
			}
#endif
d1418 3
d1422 1
d4671 1
a4671 1
		private sealed class CompiledAnnotation : Annotation
@


1.424
log
@Removed unused (and bogus) parameter from TypeWrapper.EmitCheckcast() and EmitInstanceOf().
@
text
@d3312 1
a3312 3
			ilgen.Emit(OpCodes.Ldstr, Name);
			ilgen.Emit(OpCodes.Ldnull);
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicCast);
d3317 1
a3317 3
			ilgen.Emit(OpCodes.Ldstr, Name);
			ilgen.Emit(OpCodes.Ldnull);
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicInstanceOf);
@


1.423
log
@Changed dynamic bytecode helper methods to be CallerID based instead of trusting the caller to provide the right context type handle. Also, use Java class loader to load classes, instead of directly going to the runtime. Currently this makes no difference, but if we are to allow dynamic code in statically compiled code this is necessary to respect custom assembly class loaders.
@
text
@d2958 1
a2958 1
		internal virtual void EmitCheckcast(TypeWrapper context, CodeEmitter ilgen)
d2992 1
a2992 1
		internal virtual void EmitInstanceOf(TypeWrapper context, CodeEmitter ilgen)
d3310 1
a3310 1
		internal override void EmitCheckcast(TypeWrapper context, CodeEmitter ilgen)
d3317 1
a3317 1
		internal override void EmitInstanceOf(TypeWrapper context, CodeEmitter ilgen)
@


1.422
log
@Updated accessibility checks to handle the fact that we can now inject dynamic classes in all assemblies.
@
text
@a3311 1
			ilgen.Emit(OpCodes.Ldtoken, context.TypeAsTBD);
d3313 1
a3318 1
			ilgen.Emit(OpCodes.Ldtoken, context.TypeAsTBD);
d3320 1
@


1.421
log
@Added AttributeHelper.SetInternalsVisibleToAttribute().
@
text
@d2529 1
a2529 1
		internal bool IsPackageAccessibleFrom(TypeWrapper wrapper)
d2542 9
a2550 1
				return GetClassLoader() == wrapper.GetClassLoader();
@


1.420
log
@Disabled automatic assembly loading for ikvmc. All dependencies must now be explicitly referenced (except for the stub jar loophole and secondary assemblies in a shared class loader group).
@
text
@d1175 8
@


1.419
log
@Made EditorBrowsableAttribute construction fully symbolic, to avoid having to load System.dll.
@
text
@d2436 1
a2436 2
					type = ReflectUtil.GetMissingType(type);
					StaticCompiler.IssueMessage(Message.MissingType, type.FullName, type.Assembly.FullName);
@


1.418
log
@Handle unloadable type in map.xml attribute values.
@
text
@a337 7
		private static Assembly GetSystemAssembly()
		{
			AssemblyName name = Types.Object.Assembly.GetName();
			name.Name = "System";
			return StaticCompiler.Load(name.FullName);
		}

d342 10
a351 2
				Assembly system = GetSystemAssembly();
				editorBrowsableNever = new CustomAttributeBuilder(system.GetType("System.ComponentModel.EditorBrowsableAttribute", true).GetConstructor(new Type[] { system.GetType("System.ComponentModel.EditorBrowsableState", true) }), new object[] { (int)System.ComponentModel.EditorBrowsableState.Never });
@


1.417
log
@Don't try to publish members for types that have a missing base type.
@
text
@d110 4
@


1.416
log
@Ignore MissingMemberException when looking for __<clinit> method.
@
text
@d2390 6
d2411 6
d2424 26
@


1.415
log
@When generating a signature with a missing unloadable type, use the missing type instead of object with a custom modifier.
@
text
@d3690 8
a3697 1
					clinitMethod = type.GetMethod("__<clinit>", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
@


1.414
log
@Give the appropriate error messages if trying to extend or implement a missing type.
@
text
@d2547 1
a2547 1
					return Types.Object;
@


1.413
log
@Made handling of __<Unloadable> type modifiers more explicit to avoid creating an unloadable in the wrong circumstances and to support missing unloadable modifier types.
@
text
@d3135 1
d3143 6
d3230 5
@


1.412
log
@Bug fix. The static compiler cannot use a different way to encode erased array types than the runtime compiler (because otherwise the runtime can't override statically compiled methods).
@
text
@d3134 1
d4383 4
d4389 1
a4389 2
					tw = ClassLoaderWrapper.GetWrapperFromType(type)
						?? new UnloadableTypeWrapper(TypeNameUtil.UnmangleNestedTypeName(type.Name), type);
@


1.411
log
@Removed remaining ConstructorBuilder usages.
@
text
@d4364 1
a4364 1
		private static TypeWrapper TypeWrapperFromModOpt(Type modopt)
d4367 2
a4368 1
			while (ReflectUtil.IsVector(modopt))
d4370 17
a4386 2
				rank++;
				modopt = modopt.GetElementType();
d4390 1
a4390 10
				return TypeWrapperFromModOpt(modopt).MakeArrayType(rank);
			}
			else if (modopt == Types.Void || modopt.IsPrimitive || ClassLoaderWrapper.IsRemappedType(modopt))
			{
				return DotNetTypeWrapper.GetWrapperFromDotNetType(modopt);
			}
			else
			{
				return ClassLoaderWrapper.GetWrapperFromType(modopt)
					?? new UnloadableTypeWrapper(TypeNameUtil.UnmangleNestedTypeName(modopt.Name), modopt);
d4392 1
d4397 2
a4398 4
			Type[] modopt = property.GetOptionalCustomModifiers();
			return modopt.Length == 0
				? ClassLoaderWrapper.GetWrapperFromType(property.PropertyType)
				: TypeWrapperFromModOpt(modopt[0]);
d4403 2
a4404 4
			Type[] modopt = field.GetOptionalCustomModifiers();
			return modopt.Length == 0
				? ClassLoaderWrapper.GetWrapperFromType(field.FieldType)
				: TypeWrapperFromModOpt(modopt[0]);
d4409 2
a4410 3
			// we don't want to rely on the ordering of the custom modifiers,
			// because reflection (currently) reports them in reverse order
			foreach (Type modopt in param.GetOptionalCustomModifiers())
d4412 1
a4412 4
				if (modopt != JVM.LoadType(typeof(IKVM.Attributes.AccessStub)))
				{
					return TypeWrapperFromModOpt(modopt);
				}
@


1.410
log
@Construct the System assembly name from the mscorlib name to support other runtimes.
@
text
@a360 5
		internal static void SetEditorBrowsableNever(ConstructorBuilder cb)
		{
			cb.SetCustomAttribute(GetEditorBrowsableNever());
		}

d366 1
a366 1
		internal static void SetDeprecatedAttribute(MethodBase mb)
d372 1
a372 9
			MethodBuilder method = mb as MethodBuilder;
			if(method != null)
			{
				method.SetCustomAttribute(deprecatedAttribute);
			}
			else
			{
				((ConstructorBuilder)mb).SetCustomAttribute(deprecatedAttribute);
			}
d402 1
a402 1
		internal static void SetThrowsAttribute(MethodBase mb, string[] exceptions)
d410 1
a410 10
				if(mb is MethodBuilder)
				{
					MethodBuilder method = (MethodBuilder)mb;
					method.SetCustomAttribute(new CustomAttributeBuilder(throwsAttribute, new object[] { exceptions }));
				}
				else
				{
					ConstructorBuilder constructor = (ConstructorBuilder)mb;
					constructor.SetCustomAttribute(new CustomAttributeBuilder(throwsAttribute, new object[] { exceptions }));
				}
a479 9
		internal static void HideFromJava(ConstructorBuilder cb)
		{
			if(hideFromJavaAttribute == null)
			{
				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			}
			cb.SetCustomAttribute(hideFromJavaAttribute);
		}

a707 14
		internal static void SetModifiers(ConstructorBuilder cb, Modifiers modifiers, bool isInternal)
		{
			CustomAttributeBuilder customAttributeBuilder;
			if (isInternal)
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, Types.Boolean }), new object[] { modifiers, isInternal });
			}
			else
			{
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers }), new object[] { modifiers });
			}
			cb.SetCustomAttribute(customAttributeBuilder);
		}

d793 1
a793 1
		internal static void SetLineNumberTable(MethodBase mb, IKVM.Attributes.LineNumberTableAttribute.LineNumberWriter writer)
d815 1
a815 8
			if(mb is ConstructorBuilder)
			{
				((ConstructorBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(con, new object[] { arg }));
			}
			else
			{
				((MethodBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(con, new object[] { arg }));
			}
d845 1
a845 1
		internal static void SetSignatureAttribute(MethodBase mb, string signature)
d851 1
a851 8
			if(mb is ConstructorBuilder)
			{
				((ConstructorBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(signatureAttribute, new object[] { signature }));
			}
			else
			{
				((MethodBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(signatureAttribute, new object[] { signature }));
			}
a1645 1
		internal abstract void Apply(ClassLoaderWrapper loader, ConstructorBuilder cb, object annotation);
d3118 1
a3118 1
		internal virtual ConstructorInfo GetSerializationConstructor()
d3125 1
a3125 1
		internal virtual ConstructorInfo GetBaseSerializationConstructor()
a4616 6
			internal override void Apply(ClassLoaderWrapper loader, ConstructorBuilder cb, object annotation)
			{
				annotation = QualifyClassNames(loader, annotation);
				cb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
			}

@


1.409
log
@Removed more ConstructorBuilder usage to fix regression (constructor custom attributes specified map.xml were not applied).
@
text
@d334 7
d345 2
a346 1
				editorBrowsableNever = new CustomAttributeBuilder(JVM.Import(typeof(System.ComponentModel.EditorBrowsableAttribute)).GetConstructor(new Type[] { JVM.Import(typeof(System.ComponentModel.EditorBrowsableState)) }), new object[] { (int)System.ComponentModel.EditorBrowsableState.Never });
@


1.408
log
@Apply custom attribute annotations on annotation types to the corresponding custom attribute that is generated (and allow AttributeUsageAttribute to override the default AttributeUsageAttribute generated from the @@Target annotation).
@
text
@a198 14
		internal static void SetCustomAttribute(ClassLoaderWrapper loader, ConstructorBuilder cb, IKVM.Internal.MapXml.Attribute attr)
		{
			bool declarativeSecurity;
			CustomAttributeBuilder cab = CreateCustomAttribute(loader, attr, out declarativeSecurity);
			if (declarativeSecurity)
			{
				cb.__AddDeclarativeSecurity(cab);
			}
			else
			{
				cb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
			}
		}

@


1.408.2.1
log
@- Fixed build number
- Fixed .NET 4.0 build issues
- Fixed map.xml custom attribute application regression
- Updated HOWTO
@
text
@d199 14
@


1.408.2.2
log
@Backported: Bug fix. The static compiler cannot use a different way to encode erased array types than the runtime compiler (because otherwise the runtime can't override statically compiled methods).
@
text
@d4416 1
a4416 1
		private static TypeWrapper TypeWrapperFromModOpt(Type[] modopt)
d4419 1
a4419 2
			TypeWrapper tw = null;
			foreach (Type type in modopt)
d4421 2
a4422 17
				if (type == JVM.LoadType(typeof(IKVM.Attributes.AccessStub)))
				{
					// ignore
				}
				else if (type == Types.Array)
				{
					rank++;
				}
				else if (type == Types.Void || type.IsPrimitive || ClassLoaderWrapper.IsRemappedType(type))
				{
					tw = DotNetTypeWrapper.GetWrapperFromDotNetType(type);
				}
				else
				{
					tw = ClassLoaderWrapper.GetWrapperFromType(type)
						?? new UnloadableTypeWrapper(TypeNameUtil.UnmangleNestedTypeName(type.Name), type);
				}
d4426 10
a4435 1
				tw = tw.MakeArrayType(rank);
a4436 1
			return tw;
d4441 4
a4444 2
			return TypeWrapperFromModOpt(property.GetOptionalCustomModifiers())
				?? ClassLoaderWrapper.GetWrapperFromType(property.PropertyType);
d4449 4
a4452 2
			return TypeWrapperFromModOpt(field.GetOptionalCustomModifiers())
				?? ClassLoaderWrapper.GetWrapperFromType(field.FieldType);
d4457 3
a4459 2
			TypeWrapper tw = TypeWrapperFromModOpt(param.GetOptionalCustomModifiers());
			if (tw != null)
d4461 4
a4464 1
				return tw;
@


1.407
log
@Stop using ConstructorBuilder (always use MethodBuilder).
@
text
@d1720 2
d4718 5
@


1.406
log
@Moved GhostMethodWrapper out of MethodWrapper and removed MethodWrapper.Create() as it was used in only one place.
@
text
@a317 7
				MethodWrapper mw = t.GetMethodWrapper("<init>", attr.Sig, false);
				mw.Link();
				ConstructorInfo ci = (ConstructorInfo)mw.GetMethod();
				if(ci == null)
				{
					throw new InvalidOperationException(string.Format("Constructor missing: {0}::<init>{1}", attr.Class, attr.Sig));
				}
d337 7
@


1.405
log
@Merged CodeEmitter.Emit(OpCode, MethodInfo) and CodeEmitter.Emit(OpCode, ConstructorInfo) into CodeEmitter.Emit(OpCode, MethodBase) and removed unnecessary downcasting.
@
text
@d4152 15
a4166 1
					MethodWrapper mw = MethodWrapper.Create(this, name, sig, method, retType, paramTypes, mods.Modifiers, flags);
@


1.404
log
@- Marked MemberWrapper class abstract.
- Marked all classes that don't (and shouldn't) have subclasses sealed.
@
text
@d4343 1
a4343 1
					ilgen.Emit(OpCodes.Call, (ConstructorInfo)mb);
d4357 1
a4357 1
					ilgen.Emit(OpCodes.Callvirt, (MethodInfo)GetMethod());
d4372 1
a4372 1
					ilgen.Emit(OpCodes.Newobj, (ConstructorInfo)mb);
d4399 1
a4399 1
				ilgen.Emit(mb.IsStatic ? OpCodes.Call : OpCodes.Callvirt, (MethodInfo)mb);
@


1.403
log
@Bug fix. If a Java class extends a remapped .NET type (cli.System.Object or cli.System.Exception), we should correctly report the base class.
@
text
@d4305 1
a4305 1
		private class CompiledRemappedMethodWrapper : SmartMethodWrapper
d4647 1
a4647 1
		private class CompiledAnnotation : Annotation
@


1.402
log
@Fixed some minor class modifiers issues:
- stub generator now reproduces exact class modifier bits
- unused bits are now properly masked and returned
- non-abstract interfaces now properly return ACC_ABSTRACT
@
text
@d3662 5
@


1.401
log
@- Made CodeEmitter more "type safe" by adding specific EmitXxx methods instead of following the more general ILGenerator pattern.
- Added some new optimizations to CodeEmitter (disabled unless experimental optimizations are enabled).
- Added some invariant checks to CodeEmitter to help debug optimizations (and document the invariants).
@
text
@d3707 1
a3707 1
			if(type.IsPublic)
a3710 18
				// TODO do we really need to look for nested attributes? I think all inner classes will have the ModifiersAttribute.
			else if(type.IsNestedPublic)
			{
				modifiers |= Modifiers.Public | Modifiers.Static;
			}
			else if(type.IsNestedPrivate)
			{
				modifiers |= Modifiers.Private | Modifiers.Static;
			}
			else if(type.IsNestedFamily || type.IsNestedFamORAssem)
			{
				modifiers |= Modifiers.Protected | Modifiers.Static;
			}
			else if(type.IsNestedAssembly || type.IsNestedFamANDAssem)
			{
				modifiers |= Modifiers.Static;
			}

d3723 4
d3854 1
d3858 3
a3860 1
						reflectiveModifiers = attr.Modifiers;
d3864 7
a3870 1
						reflectiveModifiers = Modifiers;
d3872 1
@


1.400
log
@Bug fix. When resolving properties corresponding to fields with type 2 access stubs, unloadable types with the same name should compare as equal.
@
text
@d1789 1
a1789 1
					ilgen.Emit(OpCodes.Ldc_I4, rank);
d2988 1
a2988 1
				ilgen.Emit(OpCodes.Ldc_I4, rank);
d3019 1
a3019 1
				ilgen.Emit(OpCodes.Ldc_I4, rank);
@


1.399
log
@Bug fix. When an unloadable type is used in a method signature that overrides a method (or implements an interface method), the custom modifier must be the same as the base class or an override stub must be generated.
@
text
@d4247 1
a4247 1
								&& tw == GetPropertyTypeWrapper(properties[i]))
d4278 5
@


1.399.2.1
log
@Backported: Bug fix. When resolving properties corresponding to fields with type 2 access stubs, unloadable types with the same name should compare as equal.
@
text
@d4247 1
a4247 1
								&& MatchTypes(tw, GetPropertyTypeWrapper(properties[i])))
a4277 5
		private static bool MatchTypes(TypeWrapper tw1, TypeWrapper tw2)
		{
			return tw1 == tw2 || (tw1.IsUnloadable && tw2.IsUnloadable && tw1.Name == tw2.Name);
		}

@


1.398
log
@Added support for type 2 access stubs for constructors.
@
text
@d3198 2
d3205 6
d3286 10
d3297 6
d4427 1
a4427 1
					?? new UnloadableTypeWrapper(TypeNameUtil.UnmangleNestedTypeName(modopt.Name));
@


1.397
log
@More ikvmc error handling clean up.
@
text
@d4130 1
a4130 3
						MethodInfo stubVirt;
						MethodInfo stubNonVirt;
						if (GetType2AccessStubs(name, sig, out stubVirt, out stubNonVirt))
d4132 14
a4145 1
							mw = new AccessStubMethodWrapper(this, name, sig, mi, stubVirt, stubNonVirt ?? stubVirt, retType, paramTypes, mw.Modifiers, flags);
d4179 18
@


1.396
log
@Add support for delegates with ByRef parameters.
@
text
@d3780 3
d3784 1
@


1.395
log
@Removed method name mangling and depend on custom modifiers instead.
@
text
@d4401 7
a4407 1
			return ClassLoaderWrapper.GetWrapperFromType(param.ParameterType);
@


1.394
log
@Made base TypeWrapper resolution lazy for compiled and .NET TypeWrappers. This is not just a perf improvement, but also avoid infinite recursion for generic type instantiations that use sub types as type parameters.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d4019 4
d4392 10
a4401 4
			Type[] modopt = param.GetOptionalCustomModifiers();
			return modopt.Length == 0
				? ClassLoaderWrapper.GetWrapperFromType(param.ParameterType)
				: TypeWrapperFromModOpt(modopt[0]);
@


1.393
log
@- Fixed regression introduced by earlier change. Type names should be unescaped.
- Suppress annotation custom attributes when enumerating inner classes.
@
text
@a1747 1
		private readonly TypeWrapper baseWrapper;
d1755 1
a1755 1
		internal TypeWrapper(Modifiers modifiers, string name, TypeWrapper baseWrapper)
a1762 1
			this.baseWrapper = baseWrapper;
d2028 1
d2056 1
d2416 1
d2493 1
d2679 1
a2679 1
		internal TypeWrapper BaseTypeWrapper
d2681 1
a2681 4
			get
			{
				return baseWrapper;
			}
d3191 1
a3191 1
			return baseWrapper.GetSerializationConstructor();
d3199 5
a3203 1
			: base(TypeWrapper.UnloadableModifiersHack, name, null)
d3205 1
d3311 1
a3311 1
			: base(Modifiers.Public | Modifiers.Abstract | Modifiers.Final, null, null)
d3317 5
d3393 1
a3612 1
		// TODO consider resolving the baseType lazily
d3648 2
a3649 2
		private CompiledTypeWrapper(ExModifiers exmod, string name, TypeWrapper baseTypeWrapper)
			: base(exmod.Modifiers, name, baseTypeWrapper)
d3655 1
a3655 1
			: this(GetModifiers(type), name, GetBaseTypeWrapper(type))
d3663 5
d4691 1
a4691 1
			: base(Modifiers.Final | Modifiers.Abstract | (ultimateElementTypeWrapper.Modifiers & Modifiers.Public), name, CoreClasses.java.lang.Object.Wrapper)
d4698 5
d4956 1
a4956 1
			: base(TypeWrapper.VerifierTypeModifiersHack, name, null)
d4963 5
@


1.392
log
@Removed class name length limitation.
@
text
@d1357 21
d3597 1
a3597 1
					return GetName(type.DeclaringType) + "$" + type.Name;
d3600 1
a3600 1
			return type.FullName;
d3781 8
@


1.391
log
@Removed last remaining TypeAsBuilder usage.
@
text
@d1349 1
a1349 2
		private static readonly char[] specialCharacters = { '\\', '+', ',', '[', ']', '*', '&', '\u0000' };
		private static readonly string specialCharactersString = new String(specialCharacters);
d1351 1
a1351 1
		internal static string EscapeName(string name)
d1353 2
a1354 26
			// TODO the escaping of special characters is not required on .NET 2.0
			// (but it doesn't really hurt that much either, the only overhead is the
			// extra InnerClassAttribute to record the real name of the class)
			// Note that even though .NET 2.0 automatically escapes the special characters,
			// the name that gets passed in ResolveEventArgs.Name of the TypeResolve event
			// contains the unescaped type name.
			if (name.IndexOfAny(specialCharacters) >= 0)
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder();
				foreach (char c in name)
				{
					if (specialCharactersString.IndexOf(c) >= 0)
					{
						if (c == 0)
						{
							// we can't escape the NUL character, so we replace it with a space.
							sb.Append(' ');
							continue;
						}
						sb.Append('\\');
					}
					sb.Append(c);
				}
				name = sb.ToString();
			}
			return name;
@


1.390
log
@SetNameSig is now only used with MethodBuilder.
@
text
@a2606 10
		internal virtual TypeBuilder TypeAsBuilder
		{
			get
			{
				TypeBuilder typeBuilder = TypeAsTBD as TypeBuilder;
				Debug.Assert(typeBuilder != null);
				return typeBuilder;
			}
		}

@


1.389
log
@- Use custom modifiers (instead of NameSigAttribute) for constructors with mangled types.
- Fixed GetModOpt() to handle ghost arrays.
- Moved namesig handling for methods into GenerateMethod().
@
text
@d801 1
a801 1
		internal static void SetNameSig(MethodBase mb, string name, string sig)
d804 1
a804 9
			MethodBuilder method = mb as MethodBuilder;
			if(method != null)
			{
				method.SetCustomAttribute(customAttributeBuilder);
			}
			else
			{
				((ConstructorBuilder)mb).SetCustomAttribute(customAttributeBuilder);
			}
@


1.388
log
@Don't mangle property accessor method names, but use a custom modifier instead.
@
text
@d3967 1
a3967 1
			retType = method is ConstructorInfo ? PrimitiveTypeWrapper.VOID : ClassLoaderWrapper.GetWrapperFromType(((MethodInfo)method).ReturnType);
d3980 1
a3980 1
				paramTypes[i] = ClassLoaderWrapper.GetWrapperFromType(parameters[i].ParameterType);
d4386 8
@


1.387
log
@Stop mangling property names for access stubs (instead we rely on custom modifiers to make them unique).
@
text
@a814 6
		internal static void SetNameSig(PropertyBuilder pb, string name, string sig)
		{
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofNameSigAttribute.GetConstructor(new Type[] { Types.String, Types.String }), new object[] { name, sig });
			pb.SetCustomAttribute(customAttributeBuilder);
		}

@


1.386
log
@Use modopt to reliably correlate type 2 access stub properties with the underlying field. This fixes a bug where annotations applied to fields with type 2 access stubs would not be visible at runtime (via reflection).
@
text
@d4177 2
d4194 1
a4194 1
								AddPropertyFieldWrapper(fields, properties[i], field);
d4229 2
a4230 4
				// Only AccessStub properties (marked by HideFromReflectionAttribute or NameSigAttribute)
				// are considered here
				FieldWrapper accessStub;
				if(CompiledAccessStubFieldWrapper.TryGet(this, property, field, out accessStub))
d4232 1
a4232 1
					fields.Add(accessStub);
@


1.385
log
@Removed legacy remap feature that allowed final fields as properties to be defined (long time ago this was used for the System.in/out/err fields).
@
text
@d4184 2
a4185 1
						string name = field.Name.Substring(4);
d4188 3
a4190 3
							// note that this "fails" when we have multiple fields with the same name, but the failure mode
							// is simply that the fields won't retain their order (which is allowed by the reflection spec).
							if(properties[i] != null && name == properties[i].Name)
d4192 1
a4192 1
								AddPropertyFieldWrapper(fields, properties[i]);
d4215 1
a4215 1
					AddPropertyFieldWrapper(fields, property);
d4221 1
a4221 1
		private void AddPropertyFieldWrapper(List<FieldWrapper> fields, PropertyInfo property)
d4230 1
a4230 1
				if(CompiledAccessStubFieldWrapper.TryGet(this, property, out accessStub))
d4376 9
a4384 1
		private FieldWrapper CreateFieldWrapper(FieldInfo field)
a4385 1
			ExModifiers modifiers = AttributeHelper.GetModifiers(field, false);
d4387 1
a4387 1
			TypeWrapper type = modopt.Length == 0
d4390 6
@


1.384
log
@Instead of mangling field names and using NameSigAttribute, we now use modopt to modify the signature and record the real type.
@
text
@d4235 1
a4235 1
					// If the property has a ModifiersAttribute, we know that it is an explicit property
d4238 1
a4238 8
					if(mods != null)
					{
						fields.Add(new CompiledPropertyFieldWrapper(this, property, new ExModifiers(mods.Modifiers, mods.IsInternal)));
					}
					else
					{
						fields.Add(CreateFieldWrapper(property));
					}
a4351 17
		private FieldWrapper CreateFieldWrapper(PropertyInfo prop)
		{
			MethodInfo getter = prop.GetGetMethod(true);
			ExModifiers modifiers = AttributeHelper.GetModifiers(getter, false);
			// for static methods AttributeHelper.GetModifiers won't set the Final flag
			modifiers = new ExModifiers(modifiers.Modifiers | Modifiers.Final, modifiers.IsInternal);
			string name = prop.Name;
			TypeWrapper type = ClassLoaderWrapper.GetWrapperFromType(prop.PropertyType);
			NameSigAttribute attr = AttributeHelper.GetNameSig(getter);
			if(attr != null)
			{
				name = attr.Name;
				SigTypePatchUp(attr.Sig, ref type);
			}
			return new GetterFieldWrapper(this, type, null, name, type.SigName, modifiers, getter, prop);
		}

a4478 12
			else
			{
				GetterFieldWrapper getter = fw as GetterFieldWrapper;
				if(getter != null)
				{
					SignatureAttribute attr = AttributeHelper.GetSignature(getter.GetGetter());
					if(attr != null)
					{
						return attr.Signature;
					}
				}
			}
a4542 5
			GetterFieldWrapper getter = fw as GetterFieldWrapper;
			if(getter != null)
			{
				return getter.GetGetter().GetCustomAttributes(false);
			}
@


1.383
log
@Added support for classes that represent arrays of remapped .NET types and .NET primitives.
@
text
@a814 6
		internal static void SetNameSig(FieldBuilder fb, string name, string sig)
		{
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofNameSigAttribute.GetConstructor(new Type[] { Types.String, Types.String }), new object[] { name, sig });
			fb.SetCustomAttribute(customAttributeBuilder);
		}

d1360 102
d2228 5
d4376 23
d4402 4
a4405 8
			string name = field.Name;
			TypeWrapper type = ClassLoaderWrapper.GetWrapperFromType(field.FieldType);
			NameSigAttribute attr = AttributeHelper.GetNameSig(field);
			if(attr != null)
			{
				name = attr.Name;
				SigTypePatchUp(attr.Sig, ref type);
			}
d4418 1
a4418 1
				return new ConstantFieldWrapper(this, type, name, type.SigName, modifiers.Modifiers, field, null, flags);
d4422 1
a4422 1
				return FieldWrapper.Create(this, type, field, name, type.SigName, modifiers);
d4858 5
@


1.382
log
@When generating an access stub for a bridge method, prefix the access stub with <bridge> as well (to avoid confusing any other compilers).
@
text
@d1699 17
a1715 2
				ilgen.Emit(OpCodes.Ldtoken, type);
				Compiler.getClassFromTypeHandle.EmitCall(ilgen);
@


1.381
log
@Implemented type 2 access stubs for methods (not constructors) and rewrote how type 1 access stubs are handled.
@
text
@d1660 1
@


1.380
log
@Fixed several type 1 method access stub issues.
@
text
@a498 31
		internal static bool IsHideFromReflection(MemberInfo mi, out int reason)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = mi.GetCustomAttributes(typeof(HideFromReflectionAttribute), false);
			if (attr.Length == 1)
			{
				reason = ((HideFromReflectionAttribute)attr[0]).Reason;
				return true;
			}
			reason = HideFromReflectionAttribute.Unknown;
			return false;
#else
			IList<CustomAttributeData> attr = CustomAttributeData.__GetCustomAttributes(mi, typeofHideFromReflectionAttribute, false);
			if (attr.Count == 1)
			{
				IList<CustomAttributeTypedArgument> args = attr[0].ConstructorArguments;
				if (args.Count == 1)
				{
					reason = (int)args[0].Value;
				}
				else
				{
					reason = HideFromReflectionAttribute.Unknown;
				}
				return true;
			}
			reason = HideFromReflectionAttribute.Unknown;
			return false;
#endif
		}

d1658 2
a1659 1
		internal const string Type1bNonVirtualAccessStub = "<nonvirtual>";
d3078 1
a3956 1
			List<MethodInfo> type1bAccessStubs = null;
d3966 1
a3966 1
					AddMethodOrConstructor(ctor, methods, ref type1bAccessStubs);
d3971 1
a3971 5
				AddMethodOrConstructor(method, methods, ref type1bAccessStubs);
			}
			if(type1bAccessStubs != null)
			{
				AddType1bAccessStubs(methods, type1bAccessStubs);
d3976 1
a3976 1
		private void AddMethodOrConstructor(MethodBase method, List<MethodWrapper> methods, ref List<MethodInfo> type1bAccessStubs)
d3991 1
a3991 2
					int reason = HideFromReflectionAttribute.Unknown;
					bool hideFromReflection = mi != null ? AttributeHelper.IsHideFromReflection(mi, out reason) : false;
a3992 15
					switch (reason)
					{
						case HideFromReflectionAttribute.Type1aAccessStub:
						case HideFromReflectionAttribute.Type1bAccessStubStatic:
							flags |= MemberFlags.AccessStub;
							break;
						case HideFromReflectionAttribute.Type1bAccessStubVirtual:
						case HideFromReflectionAttribute.Type1bAccessStubNonVirtual:
							if (type1bAccessStubs == null)
							{
								type1bAccessStubs = new List<MethodInfo>();
							}
							type1bAccessStubs.Add(mi);
							return;
					}
d3999 20
a4018 1
					methods.Add(MethodWrapper.Create(this, name, sig, method, retType, paramTypes, mods.Modifiers, flags));
d4023 1
a4023 1
		private void AddType1bAccessStubs(List<MethodWrapper> methods, List<MethodInfo> type1bAccessStubs)
d4025 4
a4028 1
			for (int i = 0; i < type1bAccessStubs.Count; i++)
d4030 1
a4030 1
				if (type1bAccessStubs[i] != null)
d4032 2
a4033 8
					string name1;
					string sig1;
					TypeWrapper retType1;
					TypeWrapper[] paramTypes1;
					MemberFlags flags1 = MemberFlags.HideFromReflection;
					GetNameSigFromMethodBase(type1bAccessStubs[i], out name1, out sig1, out retType1, out paramTypes1, ref flags1);
					MethodInfo found = null;
					for (int j = i + 1; j < type1bAccessStubs.Count; j++)
d4035 1
a4035 1
						if (type1bAccessStubs[j] != null)
d4037 5
a4041 12
							string name2;
							string sig2;
							TypeWrapper retType2;
							TypeWrapper[] paramTypes2;
							MemberFlags flags2 = MemberFlags.HideFromReflection | MemberFlags.AccessStub;
							GetNameSigFromMethodBase(type1bAccessStubs[j], out name2, out sig2, out retType2, out paramTypes2, ref flags2);
							if (name1 == name2 && sig1 == sig2)
							{
								found = type1bAccessStubs[j];
								type1bAccessStubs[j] = null;
								break;
							}
a4043 17
					MethodInfo stubVirtual;
					MethodInfo stubNonVirtual;
					if (found == null)
					{
						stubVirtual = stubNonVirtual = type1bAccessStubs[i];
					}
					else if (found.Name.StartsWith(NamePrefix.Type1bNonVirtualAccessStub, StringComparison.Ordinal))
					{
						stubVirtual = type1bAccessStubs[i];
						stubNonVirtual = found;
					}
					else
					{
						stubVirtual = found;
						stubNonVirtual = type1bAccessStubs[i];
					}
					methods.Add(new AccessStubMethodWrapper(this, name1, sig1, stubVirtual, stubNonVirtual, retType1, paramTypes1, stubVirtual.IsPublic ? Modifiers.Public : Modifiers.Protected, MemberFlags.HideFromReflection | MemberFlags.AccessStub));
d4046 1
@


1.379
log
@Added support for type 1 access stub methods with non-public parameter/return types.
@
text
@d476 6
d499 31
d1689 1
d3883 1
a3883 1
		private bool GetNameSigFromMethodBase(MethodBase method, out string name, out string sig, out TypeWrapper retType, out TypeWrapper[] paramTypes, ref MemberFlags flags)
a3926 1
				return true;
a3945 1
				return false;
d3986 1
d3996 1
a3996 1
					AddMethodOrConstructor(ctor, methods);
d4001 5
a4005 1
				AddMethodOrConstructor(method, methods);
d4010 1
a4010 1
		private void AddMethodOrConstructor(MethodBase method, List<MethodWrapper> methods)
d4025 2
a4026 1
					bool hideFromReflection = mi != null ? AttributeHelper.IsHideFromReflection(mi) : false;
d4028 1
a4028 1
					if (GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes, ref flags) && hideFromReflection && (method.IsPublic || method.IsFamilyOrAssembly))
d4030 7
a4036 3
						foreach (TypeWrapper tw in paramTypes)
						{
							if (!tw.IsPublic)
d4038 1
a4038 2
								flags |= MemberFlags.AccessStub;
								break;
d4040 2
a4041 5
						}
						if (!retType.IsPublic)
						{
							flags |= MemberFlags.AccessStub;
						}
d4043 1
d4054 52
@


1.378
log
@Bug fix. When calling a final method on a remapped type we can't call the instance method in the remapped type, but we have to call the instancehelper instead.
@
text
@d3845 1
a3845 1
		private void GetNameSigFromMethodBase(MethodBase method, out string name, out string sig, out TypeWrapper retType, out TypeWrapper[] paramTypes, ref MemberFlags flags)
d3889 1
d3909 1
d3986 15
a4000 1
					GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes, ref flags);
@


1.378.2.1
log
@Backported fixes:
- FileStore for non-accessible drive should throw exception when trying to create the FileStore, not when accessing the name() or type() properties.
- Graphics2D.clip(null) should only throw NPE for a Component graphics.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Handle Main-Class manifest value that spans multiple lines. Fix for bug #3461012.
- Informational messages should not be treated as error when -warnaserror is specified. Fix for #3443377.
- Don't enforce pre-1.5 class name rules in ikvmc (since HotSpot doesn't enforce any naming rules for classes loaded by the system (and boot) class loader, by default). Fix for #3443373.
- Fix for #3441959.
- Throwable.addSuppressed() didn't have a proper parameter name.
- mark getSpace0 with SecuritySafeCritical to avoid getting an exception with .NET 4
- Bug fix. Removed incorrect check for uninitialized objects on backward branch.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Added AssemblyInformationalVersionAttribute to OpenJDK assemblies (to set the "Product Version"). Part of patch #3458997.
- Include copyright and metadata in IKVM.OpenJDK.Tools.dll. Part of patch #3458997.
- Bug fix. Don't call Finish on unloadable TypeWrapper.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
- Suppress annotation custom attributes when enumerating inner classes.
- IKVM.Reflection: Bug fix. Fixed copy/paste error. FieldInfo.IsAssembly should test for FieldAttributes.Assembly access, not FieldAttributes.Family.
@
text
@a3682 8
					if(nestedTypes[i].Name.EndsWith("Attribute", StringComparison.Ordinal)
						&& nestedTypes[i].IsClass
						&& nestedTypes[i].BaseType.FullName == "ikvm.internal.AnnotationAttributeBase")
					{
						// HACK it's the custom attribute we generated for a corresponding annotation, so we shouldn't surface it as an inner classes
						// (we can't put a HideFromJavaAttribute on it, because we do want the class to be visible as a $Proxy)
						continue;
					}
@


1.377
log
@Bug fix. TypeWrapper.IsAssignableTo() didn't handle arrays with primitive elements properly.
@
text
@d4103 11
a4113 1
					ilgen.Emit(OpCodes.Call, mi);
@


1.376
log
@Fix and enhancement. When a .NET type implements a shadowed interface, we now also publish the original interface (e.g. if the .NET type implements System.IComparable, Java code will now see java.lang.Comparable and System.IComparable). In addition, the new code makes sure that when a .NET type explicitly implements both System.IComparable and java.lang.Comparable that the Java code will not see java.lang.Comparable twice.
@
text
@d2729 4
@


1.375
log
@Added support for declaring exceptions on shadow interface methods.
@
text
@d3046 15
@


1.374
log
@Retain reflection field ordering for ikvmc compiled code (not required by spec, but to improve compatibility with broken code).
@
text
@d1088 1
a1088 1
				attrs.Add(new RemappedInterfaceMethodAttribute((string)args[0].Value, (string)args[1].Value));
d1228 1
a1228 1
		internal static void SetRemappedInterfaceMethod(TypeBuilder typeBuilder, string name, string mappedTo)
d1230 1
a1230 1
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofRemappedInterfaceMethodAttribute.GetConstructor(new Type[] { Types.String, Types.String }), new object[] { name, mappedTo });
d3356 3
a3358 1
						list.Add(new CompiledRemappedMethodWrapper(this, m.Name, sig, method, retType, paramTypes, modifiers, false, mbHelper, null));
@


1.373
log
@Clean up TypeWrapper.IsFakeNestedType and allow it to be called on unfinished TypeWrappers.
@
text
@d1649 5
d3974 5
d3983 4
a3986 1
			foreach(FieldInfo field in type.GetFields(flags))
d3988 19
a4006 1
				if(!AttributeHelper.IsHideFromJava(field))
d4008 1
a4008 1
					if(field.IsSpecialName && field.Name.StartsWith("__<"))
d4018 1
a4018 1
			foreach(PropertyInfo property in type.GetProperties(flags))
d4020 27
a4046 8
				// NOTE explictly defined properties (in map.xml) are decorated with HideFromJava,
				// so we don't need to worry about them here
				if(!AttributeHelper.IsHideFromJava(property))
				{
					// Only AccessStub properties (marked by HideFromReflectionAttribute or NameSigAttribute)
					// are considered here
					FieldWrapper accessStub;
					if(CompiledAccessStubFieldWrapper.TryGet(this, property, out accessStub))
d4048 1
a4048 1
						fields.Add(accessStub);
d4052 1
a4052 11
						// If the property has a ModifiersAttribute, we know that it is an explicit property
						// (defined in Java source by an @@ikvm.lang.Property annotation)
						ModifiersAttribute mods = AttributeHelper.GetModifiersAttribute(property);
						if(mods != null)
						{
							fields.Add(new CompiledPropertyFieldWrapper(this, property, new ExModifiers(mods.Modifiers, mods.IsInternal)));
						}
						else
						{
							fields.Add(CreateFieldWrapper(property));
						}
a4055 1
			SetFields(fields.ToArray());
@


1.373.2.1
log
@Backport: Bug fix. TypeWrapper.IsAssignableTo() didn't handle arrays with primitive elements properly.
@
text
@a2723 4
 				if(elem1.IsPrimitive || elem2.IsPrimitive)
 				{
 					return false;
 				}
@


1.373.2.2
log
@Backport: Fix and enhancement. When a .NET type implements a shadowed interface, we now also publish the original interface (e.g. if the .NET type implements System.IComparable, Java code will now see java.lang.Comparable and System.IComparable). In addition, the new code makes sure that when a .NET type explicitly implements both System.IComparable and java.lang.Comparable that the Java code will not see java.lang.Comparable twice.
@
text
@a3044 15
			for (int i = 0; i < interfaceTypes.Length; i++)
			{
				if (interfaces[i].IsRemapped)
				{
					// for remapped interfaces, we also return the original interface (Java types will ignore it, if it isn't listed in the ImplementsAttribute)
					TypeWrapper twRemapped = interfaces[i];
					TypeWrapper tw = DotNetTypeWrapper.GetWrapperFromDotNetType(interfaceTypes[i]);
					interfaces[i] = tw;
					if (Array.IndexOf(interfaces, twRemapped) == -1)
					{
						Array.Resize(ref interfaces, interfaces.Length + 1);
						interfaces[interfaces.Length - 1] = twRemapped;
					}
				}
			}
@


1.373.2.3
log
@Backport: Bug fix. When calling a final method on a remapped type we can't call the instance method in the remapped type, but we have to call the instancehelper instead.
@
text
@d4062 1
a4062 11
					if(!IsStatic && IsFinal)
					{
						// When calling a final instance method on a remapped type from a class derived from a .NET class (i.e. a cli.System.Object or cli.System.Exception derived base class)
						// then we can't call the java.lang.Object or java.lang.Throwable methods and we have to go through the instancehelper_ method. Note that since the method
						// is final, this won't affect the semantics.
						CallvirtImpl(ilgen);
					}
					else
					{
						ilgen.Emit(OpCodes.Call, mi);
					}
@


1.373.2.4
log
@Backport: Retain reflection field ordering for ikvmc compiled code (not required by spec, but to improve compatibility with broken code).
@
text
@a1648 5
	static class NamePrefix
	{
		internal const string Type2AccessStubBackingField = "__<>";
	}

a3987 5
		private static int SortFieldByToken(FieldInfo field1, FieldInfo field2)
		{
			return field1.MetadataToken.CompareTo(field2.MetadataToken);
		}

d3992 1
a3992 4
			FieldInfo[] rawfields = type.GetFields(flags);
			Array.Sort(rawfields, SortFieldByToken);
			PropertyInfo[] properties = type.GetProperties(flags);
			foreach(FieldInfo field in rawfields)
d3994 1
a3994 19
				if(AttributeHelper.IsHideFromJava(field))
				{
					if(field.Name.StartsWith(NamePrefix.Type2AccessStubBackingField, StringComparison.Ordinal))
					{
						string name = field.Name.Substring(4);
						for(int i = 0; i < properties.Length; i++)
						{
							// note that this "fails" when we have multiple fields with the same name, but the failure mode
							// is simply that the fields won't retain their order (which is allowed by the reflection spec).
							if(properties[i] != null && name == properties[i].Name)
							{
								AddPropertyFieldWrapper(fields, properties[i]);
								properties[i] = null;
								break;
							}
						}
					}
				}
				else
d3996 1
a3996 1
					if(field.IsSpecialName && field.Name.StartsWith("__<", StringComparison.Ordinal))
d4006 1
a4006 1
			foreach(PropertyInfo property in properties)
d4008 8
a4015 27
				if(property != null)
				{
					AddPropertyFieldWrapper(fields, property);
				}
			}
			SetFields(fields.ToArray());
		}

		private void AddPropertyFieldWrapper(List<FieldWrapper> fields, PropertyInfo property)
		{
			// NOTE explictly defined properties (in map.xml) are decorated with HideFromJava,
			// so we don't need to worry about them here
			if(!AttributeHelper.IsHideFromJava(property))
			{
				// Only AccessStub properties (marked by HideFromReflectionAttribute or NameSigAttribute)
				// are considered here
				FieldWrapper accessStub;
				if(CompiledAccessStubFieldWrapper.TryGet(this, property, out accessStub))
				{
					fields.Add(accessStub);
				}
				else
				{
					// If the property has a ModifiersAttribute, we know that it is an explicit property
					// (defined in Java source by an @@ikvm.lang.Property annotation)
					ModifiersAttribute mods = AttributeHelper.GetModifiersAttribute(property);
					if(mods != null)
d4017 1
a4017 1
						fields.Add(new CompiledPropertyFieldWrapper(this, property, new ExModifiers(mods.Modifiers, mods.IsInternal)));
d4021 11
a4031 1
						fields.Add(CreateFieldWrapper(property));
d4035 1
@


1.373.2.5
log
@Fix whitespace.
@
text
@d2729 4
a2732 4
				if(elem1.IsPrimitive || elem2.IsPrimitive)
				{
					return false;
				}
@


1.373.2.6
log
@Backported fixes for 0.46.0.3:
- Bug fix. java.lang.Package was not populated from manifest for ikvmc compiled assemblies.
- Bug fix. When writing a direct ByteBuffer to a non-blocking socket and the write fails because there is no kernel buffer available, we should not advance the ByteBuffer position.
- Bug fix. When adding certificates to virtual cacerts file make sure that the aliases are unique.
- Bug fix. If a finally/fault handler contains reachable code before the handler's start index, the handler should branch to the handler start index.
- Bug fix. After emitting a finally/fault handler block, we should emit the block leave stubs (even though you can't leave the block, they also emit the backward branch stubs).
- Bug fix. If a Java class extends a remapped .NET type (cli.System.Object or cli.System.Exception), we should correctly report the base class.
- Bug fix. If we encounter a jsr or ret instruction, we should throw a VerifyError (instead of NotImplementedException).
- Bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
- Disable AppDomain.ProcessExit hook to run shutdown hooks when running on Mono to workaround https://bugzilla.xamarin.com/show_bug.cgi?id=5650
- Bug fix. Custom attribute properties that don't have a public getter and setter should not be exposed as annotation properties.
- Bug fix. Non-public property getter/setter methods should be ignored when we create properties to hide properties inherited from shadow types. This fixes a build break with .NET 4.5 beta which introduces a protected setter for Exception.HResult.
- Bug fix. The $Method inner class for delegates should also be loadable for generic delegates. Thanks to Michael Bayne for reporting this.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Replaced non-ascii character (micro) with ascii 'u' in Win32PrintService.java.
- IKVM.Reflection: Bug fix. Resource Directory Entries must be sorted and names are case-insensitive

Backported for 0.46.0.4:
- Fixed ikvmc to retain transient modifier on constant static final fields.
- Fixed Field.getModifiers() to only return the relevant modifiers.
- Fixed IKVM.Reflection to set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@a3528 5
 				else if(ClassLoaderWrapper.IsRemappedType(type.BaseType))
 				{
 					// if we directly extend System.Object or System.Exception, the base class must be cli.System.Object or cli.System.Exception
 					return DotNetTypeWrapper.GetWrapperFromDotNetType(type.BaseType);
 				}
@


1.372
log
@- Removed unnecessary methods from CodeEmitter.
- Removed "Lazy" prefixes in CodeEmitter.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2010 Jeroen Frijters
d2034 1
a2034 1
		internal bool IsFakeNestedType
d2038 1
a2038 2
				TypeWrapper outer = this.DeclaringTypeWrapper;
				return outer != null && outer.IsFakeTypeContainer;
@


1.371
log
@Wrapped LocalBuilder in new CodeEmitterLocal class to allow CodeEmitter to encapsulate the ILGenerator fully.
@
text
@d2793 1
a2793 1
			ilgen.LazyEmitUnboxSpecial(this.TypeAsTBD);
d2800 1
a2800 1
			ilgen.LazyEmitBox(this.TypeAsTBD);
d2920 1
a2920 1
				ilgen.LazyEmit_instanceof(TypeAsTBD);
@


1.370
log
@Changed workaround for gmcs inability to properly deal with two-pass compilation of mutually dependant assemblies to use reflection, because the previous workaround now also fails on Mono 2.8.
@
text
@d2818 1
a2818 1
				LocalBuilder local = ilgen.DeclareLocal(TypeAsSignatureType);
d2833 1
a2833 1
					LocalBuilder local1 = ilgen.DeclareLocal(TypeAsLocalOrStackType);
d2835 1
a2835 1
					LocalBuilder local2 = ilgen.DeclareLocal(TypeAsSignatureType);
@


1.369
log
@Renamed StaticCompiler.GetType() that is used exclusively by map.xml processing to make it more obvious and added error message (and abort the compile). The remaining StaticCompiler.GetType() now behaves more like Type.GetType() in that it returns null if the type isn't found.
@
text
@d1831 1
a1831 1
					SetTypeWrapperHack(ref clazz.typeWrapper, this);
d1844 1
a1844 1
		internal static void SetTypeWrapperHack<T>(ref T field, TypeWrapper type)
d1846 3
a1848 1
			field = (T)(object)type;
d1896 1
a1896 1
				SetTypeWrapperHack(ref clazz.typeWrapper, tw);
@


1.368
log
@Added extra indirection thru MethodWrapper for intrinsic method call emitting to allow .NET delegate constructor optimization to use instrinsic infrastructure instead of requiring EmitNewobj to pass a MethodAnalyzer and opcode index.
@
text
@d267 1
a267 1
				Type t = StaticCompiler.GetType(loader, attr.Type);
@


1.367
log
@Added VerifierTypeWrapper.IsNotPresentOnStack() to encapsulate the notion of types that aren't represented on the .NET stack.
Note that while this may look like a bug fix (because we're handling fault block exception types in more places), it isn't. Fault block exceptions can not actually occur on the stack, because the verifier will only allow them in very limited places.
@
text
@d3908 1
a3908 1
			internal override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
@


1.366
log
@Fix for bug #3056721.
@
text
@d4662 5
@


1.365
log
@Types nested in a type that is HideFromJava should also be considered HideFromJava.
@
text
@d560 4
@


1.364
log
@Made most static compiler warnings local to the target that is being compiled (in multi target mode), to allow warnings to be suppressed (or turned into an error) for a specific target.
@
text
@d543 1
a543 1
				|| (type.IsNested && type.Name.StartsWith("__<", StringComparison.Ordinal));
@


1.363
log
@We need to pre-intern the magic strings that VerifierTypeWrapper uses as type names, because TypeWrapper will intern them in its constructor. Thanks to Andrey Malakov for tracking this down.
@
text
@d1382 1
a1382 1
				StaticCompiler.IssueMessage(Message.ClassNotFound, x.Message);
a3074 12
#if STATIC_COMPILER
			if(name != "<verifier>")
			{
				if(name.StartsWith("["))
				{
					int skip = 1;
					while(name[skip++] == '[');
					name = name.Substring(skip, name.Length - skip - 1);
				}
				StaticCompiler.IssueMessage(Message.ClassNotFound, name);
			}
#endif
@


1.363.2.1
log
@Backported Mono 2.8 mcs build workarounds.
@
text
@d1827 1
a1827 1
					SetTypeWrapperHack(clazz, this);
d1840 1
a1840 1
		internal static void SetTypeWrapperHack(object clazz, TypeWrapper type)
d1842 1
a1842 1
			typeof(java.lang.Class).GetField("typeWrapper", BindingFlags.NonPublic | BindingFlags.Instance).SetValue(clazz, type);
d1890 1
a1890 1
				SetTypeWrapperHack(clazz, tw);
@


1.362
log
@Implemented codegen improvement to use CLR fault handlers for Java catch all handlers, whenever possible.
@
text
@d4622 5
d4652 1
a4652 1
			return new VerifierTypeWrapper("new", bytecodeIndex, type, null);
d4657 1
a4657 1
			return new VerifierTypeWrapper("<fault>", handlerIndex, null, ma);
d4667 1
a4667 1
			return new VerifierTypeWrapper("this", 0, type, null);
d4672 1
a4672 1
			return w != null && w.IsVerifierType && ReferenceEquals(w.Name, "new");
d4677 1
a4677 1
			return w != null && w.IsVerifierType && ReferenceEquals(w.Name, "<fault>");
d4687 1
a4687 1
			return w != null && w.IsVerifierType && ReferenceEquals(w.Name, "this");
@


1.361
log
@TypeWrapper.AssertFinished() doesn't make sense for the static compiler anymore.
@
text
@d4623 2
a4624 2
		internal static readonly TypeWrapper Null = new VerifierTypeWrapper("null", 0, null);
		internal static readonly TypeWrapper UninitializedThis = new VerifierTypeWrapper("uninitialized-this", 0, null);
d4626 2
a4627 2
		internal static readonly TypeWrapper ExtendedFloat = new VerifierTypeWrapper("<extfloat>", 0, null);
		internal static readonly TypeWrapper ExtendedDouble = new VerifierTypeWrapper("<extdouble>", 0, null);
d4631 8
d4647 6
a4652 1
			return new VerifierTypeWrapper("new", bytecodeIndex, type);
d4662 1
a4662 1
			return new VerifierTypeWrapper("this", 0, type);
d4670 5
d4685 6
d4707 1
a4707 1
		private VerifierTypeWrapper(string name, int index, TypeWrapper underlyingType)
d4712 1
@


1.360
log
@More object -> java.lang.Class updates.
@
text
@d2756 1
d2769 1
@


1.359
log
@More type safety. TypeWrapper.ClassObject is now typed as java.lang.Class.
@
text
@d1866 1
a1866 1
		internal static TypeWrapper FromClass(object classObject)
a1870 1
			java.lang.Class clazz = (java.lang.Class)classObject;
d1879 1
a1879 1
					return FromClass(classObject);
@


1.358
log
@Made specialized GetModifiers() variant reuse common GetModifiers() method.
@
text
@d1654 1
a1654 1
		private object classObject;
d1728 1
a1728 1
		internal void SetClassObject(object classObject)
d1733 1
a1733 1
		internal object ClassObject
@


1.357
log
@Consolidated a couple of attribute helper overloads by using MemberInfo instead of specific sub types.
@
text
@d603 2
a604 1
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(member, typeofModifiersAttribute, false))
d606 1
a606 1
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
d619 2
a620 3
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] customAttribute = mb.GetCustomAttributes(typeof(ModifiersAttribute), false);
			if(customAttribute.Length == 1)
d622 1
a622 12
				ModifiersAttribute mod = (ModifiersAttribute)customAttribute[0];
				return new ExModifiers(mod.Modifiers, mod.IsInternal);
			}
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(mb, typeofModifiersAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				if(args.Count == 2)
				{
					return new ExModifiers((Modifiers)args[0].Value, (bool)args[1].Value);
				}
				return new ExModifiers((Modifiers)args[0].Value, false);
a623 1
#endif
d679 2
a680 3
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] customAttribute = fi.GetCustomAttributes(typeof(ModifiersAttribute), false);
			if(customAttribute.Length == 1)
d682 1
a682 2
				ModifiersAttribute mod = (ModifiersAttribute)customAttribute[0];
				return new ExModifiers(mod.Modifiers, mod.IsInternal);
a683 11
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(fi, typeofModifiersAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				if(args.Count == 2)
				{
					return new ExModifiers((Modifiers)args[0].Value, (bool)args[1].Value);
				}
				return new ExModifiers((Modifiers)args[0].Value, false);
			}
#endif
@


1.356
log
@Use __GetCustomAttributes() instead of doing our own attribute filtering.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
d488 1
a488 1
		internal static bool IsHideFromReflection(MethodInfo mi)
a492 10
		internal static bool IsHideFromReflection(FieldInfo fi)
		{
			return fi.IsDefined(typeofHideFromReflectionAttribute, false);
		}

		internal static bool IsHideFromReflection(PropertyInfo pi)
		{
			return pi.IsDefined(typeofHideFromReflectionAttribute, false);
		}

d597 1
a597 1
		internal static ModifiersAttribute GetModifiersAttribute(Type type)
d600 1
a600 1
			object[] attr = type.GetCustomAttributes(typeof(ModifiersAttribute), false);
d603 1
a603 20
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type, typeofModifiersAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				if(args.Count == 2)
				{
					return new ModifiersAttribute((Modifiers)args[0].Value, (bool)args[1].Value);
				}
				return new ModifiersAttribute((Modifiers)args[0].Value);
			}
			return null;
#endif
		}

		internal static ModifiersAttribute GetModifiersAttribute(PropertyInfo property)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = property.GetCustomAttributes(typeof(ModifiersAttribute), false);
			return attr.Length == 1 ? (ModifiersAttribute)attr[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(property, typeofModifiersAttribute, false))
d964 1
a964 31
		internal static NameSigAttribute GetNameSig(FieldInfo field)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = field.GetCustomAttributes(typeof(NameSigAttribute), false);
			return attr.Length == 1 ? (NameSigAttribute)attr[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(field, typeofNameSigAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new NameSigAttribute((string)args[0].Value, (string)args[1].Value);
			}
			return null;
#endif
		}

		internal static NameSigAttribute GetNameSig(PropertyInfo property)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attr = property.GetCustomAttributes(typeof(NameSigAttribute), false);
			return attr.Length == 1 ? (NameSigAttribute)attr[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(property, typeofNameSigAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new NameSigAttribute((string)args[0].Value, (string)args[1].Value);
			}
			return null;
#endif
		}

		internal static NameSigAttribute GetNameSig(MethodBase method)
d967 1
a967 1
			object[] attr = method.GetCustomAttributes(typeof(NameSigAttribute), false);
d970 1
a970 1
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(method, typeofNameSigAttribute, false))
d1067 1
a1067 31
		internal static SignatureAttribute GetSignature(MethodBase mb)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = mb.GetCustomAttributes(typeof(SignatureAttribute), false);
			return attribs.Length == 1 ? (SignatureAttribute)attribs[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(mb, typeofSignatureAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new SignatureAttribute((string)args[0].Value);
			}
			return null;
#endif
		}

		internal static SignatureAttribute GetSignature(Type type)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			object[] attribs = type.GetCustomAttributes(typeof(SignatureAttribute), false);
			return attribs.Length == 1 ? (SignatureAttribute)attribs[0] : null;
#else
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type, typeofSignatureAttribute, false))
			{
				IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
				return new SignatureAttribute((string)args[0].Value);
			}
			return null;
#endif
		}

		internal static SignatureAttribute GetSignature(FieldInfo fi)
d1070 1
a1070 1
			object[] attribs = fi.GetCustomAttributes(typeof(SignatureAttribute), false);
d1073 1
a1073 1
			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(fi, typeofSignatureAttribute, false))
@


1.355
log
@We don't need to use our own version of IsDefined to test for custom attributes, because there is no confusion about what runtime types to use anymore.
@
text
@a606 14
		// this method compares t1 and t2 by name
		// if the type name and assembly name (ignoring the version and strong name) match
		// the type are considered the same
		// Note that when we're the stub generator, we don't even care about the assembly names,
		// because in that case we don't want a dependency on the runtime.
		private static bool MatchTypes(Type t1, Type t2)
		{
			return t1.FullName == t2.FullName
#if !STUB_GENERATOR
				&& t1.Assembly.GetName().Name == t2.Assembly.GetName().Name
#endif
				;
		}

d613 1
a613 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d615 2
a616 1
				if(MatchTypes(cad.Constructor.DeclaringType, typeofModifiersAttribute))
d618 1
a618 6
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					if(args.Count == 2)
					{
						return new ModifiersAttribute((Modifiers)args[0].Value, (bool)args[1].Value);
					}
					return new ModifiersAttribute((Modifiers)args[0].Value);
d620 1
d632 1
a632 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(property))
d634 2
a635 1
				if(MatchTypes(cad.Constructor.DeclaringType, typeofModifiersAttribute))
d637 1
a637 6
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					if(args.Count == 2)
					{
						return new ModifiersAttribute((Modifiers)args[0].Value, (bool)args[1].Value);
					}
					return new ModifiersAttribute((Modifiers)args[0].Value);
d639 1
d655 1
a655 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mb))
d657 2
a658 1
				if(MatchTypes(cad.Constructor.DeclaringType, typeofModifiersAttribute))
d660 1
a660 6
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					if(args.Count == 2)
					{
						return new ExModifiers((Modifiers)args[0].Value, (bool)args[1].Value);
					}
					return new ExModifiers((Modifiers)args[0].Value, false);
d662 1
d728 1
a728 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(fi))
d730 2
a731 1
				if(MatchTypes(cad.Constructor.DeclaringType, typeofModifiersAttribute))
d733 1
a733 6
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					if(args.Count == 2)
					{
						return new ExModifiers((Modifiers)args[0].Value, (bool)args[1].Value);
					}
					return new ExModifiers((Modifiers)args[0].Value, false);
d735 1
d999 1
a999 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(field))
d1001 2
a1002 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofNameSigAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return new NameSigAttribute((string)args[0].Value, (string)args[1].Value);
				}
d1014 1
a1014 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(property))
d1016 2
a1017 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofNameSigAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return new NameSigAttribute((string)args[0].Value, (string)args[1].Value);
				}
d1029 1
a1029 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(method))
d1031 2
a1032 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofNameSigAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return new NameSigAttribute((string)args[0].Value, (string)args[1].Value);
				}
d1055 1
a1055 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1057 2
a1058 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofImplementsAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return new ImplementsAttribute(DecodeArray<string>(args[0]));
				}
d1070 1
a1070 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mb))
d1072 10
a1081 1
				if(MatchTypes(cad.Constructor.DeclaringType, typeofThrowsAttribute))
d1083 1
a1083 13
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					if (args[0].ArgumentType == Types.String.MakeArrayType())
					{
						return new ThrowsAttribute(DecodeArray<string>(args[0]));
					}
					else if (args[0].ArgumentType == Types.Type.MakeArrayType())
					{
						return new ThrowsAttribute(DecodeArray<Type>(args[0]));
					}
					else
					{
						return new ThrowsAttribute((Type)args[0].Value);
					}
d1102 1
a1102 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(t))
d1104 2
a1105 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofNonNestedInnerClassAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					list.Add((string)args[0].Value);
				}
d1117 1
a1117 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(t))
d1119 2
a1120 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofNonNestedOuterClassAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return (string)args[0].Value;
				}
d1132 1
a1132 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mb))
d1134 2
a1135 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofSignatureAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return new SignatureAttribute((string)args[0].Value);
				}
d1147 1
a1147 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1149 2
a1150 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofSignatureAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return new SignatureAttribute((string)args[0].Value);
				}
d1162 1
a1162 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(fi))
d1164 2
a1165 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofSignatureAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return new SignatureAttribute((string)args[0].Value);
				}
d1177 1
a1177 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1179 2
a1180 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofInnerClassAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return new InnerClassAttribute((string)args[0].Value, (Modifiers)args[1].Value);
				}
d1195 1
a1195 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1197 2
a1198 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofRemappedInterfaceMethodAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					attrs.Add(new RemappedInterfaceMethodAttribute((string)args[0].Value, (string)args[1].Value));
				}
d1210 1
a1210 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1212 2
a1213 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofRemappedTypeAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					return new RemappedTypeAttribute((Type)args[0].Value);
				}
d1228 1
a1228 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(coreAssembly))
d1230 2
a1231 5
				if(MatchTypes(cad.Constructor.DeclaringType, typeofRemappedClassAttribute))
				{
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					attrs.Add(new RemappedClassAttribute((string)args[0].Value, (Type)args[1].Value));
				}
d1247 1
a1247 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1249 1
a1249 4
				if(MatchTypes(cad.Constructor.DeclaringType, typeofAnnotationAttributeAttribute))
				{
					return (string)cad.ConstructorArguments[0].Value;
				}
d1286 1
a1286 1
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mod))
d1288 6
a1293 1
				if(MatchTypes(cad.Constructor.DeclaringType, typeofJavaModuleAttribute))
d1295 1
a1295 9
					IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
					if(args.Count == 0)
					{
						attrs.Add(new JavaModuleAttribute());
					}
					else
					{
						attrs.Add(new JavaModuleAttribute(DecodeArray<string>(args[0])));
					}
d1317 1
a1317 1
			foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1319 1
a1319 4
				if (MatchTypes(cad.Constructor.DeclaringType, typeofEnclosingMethodAttribute))
				{
					return new EnclosingMethodAttribute((string)cad.ConstructorArguments[0].Value, (string)cad.ConstructorArguments[1].Value, (string)cad.ConstructorArguments[2].Value);
				}
@


1.354
log
@Added Types.SecurityAttribute.
@
text
@d490 1
a490 1
			return IsDefined(mi, typeofHideFromReflectionAttribute);
d495 1
a495 1
			return IsDefined(fi, typeofHideFromReflectionAttribute);
d500 1
a500 1
			return IsDefined(pi, typeofHideFromReflectionAttribute);
d552 1
a552 1
			return IsDefined(type, typeofHideFromJavaAttribute)
d570 1
a570 1
			return IsDefined(mi, typeofHideFromJavaAttribute);
d594 1
a594 1
			return IsDefined(type, typeofGhostInterfaceAttribute);
d599 1
a599 1
			return IsDefined(type, typeofRemappedTypeAttribute);
d604 1
a604 1
			return IsDefined(type, typeofExceptionIsUnsafeForMappingAttribute);
d734 1
a734 1
			if(parameters.Length > 0 && IsDefined(parameters[parameters.Length - 1], JVM.Import(typeof(ParamArrayAttribute))))
a1345 84
		internal static bool IsDefined(Module mod, Type attribute)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			return mod.IsDefined(attribute, false);
#else
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mod))
			{
				// NOTE we don't support subtyping relations!
				if(MatchTypes(cad.Constructor.DeclaringType, attribute))
				{
					return true;
				}
			}
			return false;
#endif
		}

		internal static bool IsDefined(Assembly asm, Type attribute)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			return asm.IsDefined(attribute, false);
#else
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(asm))
			{
				if(MatchTypes(cad.Constructor.DeclaringType, attribute))
				{
					return true;
				}
			}
			return false;
#endif
		}

		internal static bool IsDefined(Type type, Type attribute)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			return type.IsDefined(attribute, false);
#else
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
			{
				// NOTE we don't support subtyping relations!
				if(MatchTypes(cad.Constructor.DeclaringType, attribute))
				{
					return true;
				}
			}
			return false;
#endif
		}

		internal static bool IsDefined(ParameterInfo pi, Type attribute)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			return pi.IsDefined(attribute, false);
#else
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(pi))
			{
				// NOTE we don't support subtyping relations!
				if(MatchTypes(cad.Constructor.DeclaringType, attribute))
				{
					return true;
				}
			}
			return false;
#endif
		}

		internal static bool IsDefined(MemberInfo member, Type attribute)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			return member.IsDefined(attribute, false);
#else
			foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(member))
			{
				// NOTE we don't support subtyping relations!
				if(MatchTypes(cad.Constructor.DeclaringType, attribute))
				{
					return true;
				}
			}
			return false;
#endif
		}

d1348 1
a1348 1
			return IsDefined(mod, typeofJavaModuleAttribute);
d1378 1
a1378 1
			return IsDefined(type, typeofNoPackagePrefixAttribute) || IsDefined(type.Assembly, typeofNoPackagePrefixAttribute);
@


1.353
log
@Fixed ikvmc/ikvmstub regression introduced with the switch to IKVM.Reflection (not IKVM.Reflection.Emit) in volatile field handling acros assemblies.
@
text
@a81 1
		private static Type typeofSecurityAttribute = JVM.Import(typeof(SecurityAttribute));
d268 1
a268 1
				isDeclarativeSecurity = t.IsSubclassOf(typeofSecurityAttribute);
d317 1
a317 1
				isDeclarativeSecurity = t.TypeAsBaseType.IsSubclassOf(typeofSecurityAttribute);
@


1.352
log
@Removed JVM.GetType().
@
text
@d794 1
a794 1
			if(Array.IndexOf(fi.GetRequiredCustomModifiers(), typeof(System.Runtime.CompilerServices.IsVolatile)) != -1)
@


1.351
log
@Added "documentation" assert.
@
text
@d122 1
a122 1
				return JVM.GetType(val, true);
@


1.350
log
@Changed StaticCompiler.GetType() to be multi-target aware. Instead of looking thru all assemblies currently loaded, only the relevant referenced assemblies are searched.

Note that this is a (minor) breaking change. Types referenced in -remap:map.xml file are now only resolved against directly referenced assemblies.
@
text
@d3740 1
@


1.349
log
@We can't rely on System.dll being loaded. EditorBrowsableAttribute needs to be explicitly imported.
@
text
@d268 1
a268 1
				Type t = StaticCompiler.GetType(attr.Type);
@


1.348
log
@Fixed EnumHelper.GetPrimitiveValue() to handle the case where the underlying type of an enum difference from the constants values attached to the fields.
@
text
@d349 1
a349 1
		internal static void SetEditorBrowsableNever(TypeBuilder tb)
d351 1
a351 1
			if(editorBrowsableNever == null)
d353 1
a353 1
				editorBrowsableNever = new CustomAttributeBuilder(StaticCompiler.GetType("System.ComponentModel.EditorBrowsableAttribute").GetConstructor(new Type[] { StaticCompiler.GetType("System.ComponentModel.EditorBrowsableState") }), new object[] { (int)System.ComponentModel.EditorBrowsableState.Never });
d355 6
a360 1
			tb.SetCustomAttribute(editorBrowsableNever);
d365 1
a365 5
			if(editorBrowsableNever == null)
			{
				editorBrowsableNever = new CustomAttributeBuilder(StaticCompiler.GetType("System.ComponentModel.EditorBrowsableAttribute").GetConstructor(new Type[] { StaticCompiler.GetType("System.ComponentModel.EditorBrowsableState") }), new object[] { (int)System.ComponentModel.EditorBrowsableState.Never });
			}
			mb.SetCustomAttribute(editorBrowsableNever);
d370 1
a370 5
			if(editorBrowsableNever == null)
			{
				editorBrowsableNever = new CustomAttributeBuilder(StaticCompiler.GetType("System.ComponentModel.EditorBrowsableAttribute").GetConstructor(new Type[] { StaticCompiler.GetType("System.ComponentModel.EditorBrowsableState") }), new object[] { (int)System.ComponentModel.EditorBrowsableState.Never });
			}
			cb.SetCustomAttribute(editorBrowsableNever);
d375 1
a375 5
			if(editorBrowsableNever == null)
			{
				editorBrowsableNever = new CustomAttributeBuilder(StaticCompiler.GetType("System.ComponentModel.EditorBrowsableAttribute").GetConstructor(new Type[] { StaticCompiler.GetType("System.ComponentModel.EditorBrowsableState") }), new object[] { (int)System.ComponentModel.EditorBrowsableState.Never });
			}
			pb.SetCustomAttribute(editorBrowsableNever);
@


1.347
log
@Fix for bug #2946842.
@
text
@d1604 5
a1608 1
			if (underlyingType == Types.SByte || underlyingType == Types.Byte)
d1610 1
a1610 1
				return unchecked((byte)((IConvertible)obj).ToInt32(null));
d1612 1
a1612 1
			else if (underlyingType == Types.Int16 || underlyingType == Types.UInt16)
d1614 1
a1614 1
				return unchecked((short)((IConvertible)obj).ToInt32(null));
d1616 1
a1616 1
			else if (underlyingType == Types.Int32)
d1618 1
a1618 1
				return ((IConvertible)obj).ToInt32(null);
d1620 1
a1620 1
			else if (underlyingType == Types.UInt32)
d1622 1
a1622 1
				return unchecked((int)((IConvertible)obj).ToUInt32(null));
d1624 1
a1624 1
			else if (underlyingType == Types.Int64)
d1626 1
a1626 1
				return ((IConvertible)obj).ToInt64(null);
d1628 1
a1628 1
			else if (underlyingType == Types.UInt64)
d1630 1
a1630 1
				return unchecked((long)((IConvertible)obj).ToUInt64(null));
@


1.346
log
@Made the IsHideFromJava(Type) test more consistent.
@
text
@d3331 15
@


1.345
log
@It's illegal to call IsInterface on an Unloadable type, so we have to check that first.
@
text
@d560 2
a561 1
			return IsDefined(type, typeofHideFromJavaAttribute);
d3926 1
a3926 1
					if(!AttributeHelper.IsHideFromJava(nestedTypes[i]) && !nestedTypes[i].Name.StartsWith("__<"))
@


1.344
log
@Removed ReflectionOnly support from runtime. Now that ikvmstub no longer requires it, there's no good reason to allow Java code to see ReflectionOnly types.
@
text
@d3318 1
a3318 1
			if (this.IsInterface)
@


1.343
log
@- Moved ClassLoaderWrapper.IsVector() and TypeWrapper.IsReflectionOnly() to ReflectUtil.
- Fixed IsReflectionOnly() to handle more complicated constructed types.
- Optimized IsDynamic() to use a delegate to call get_IsDynamic when running on .NET 4.0
- Optimized IsVector() to use __IsVector when IKVM.Reflection is used.
@
text
@d631 4
a634 7
			if(!type.Assembly.ReflectionOnly)
			{
				object[] attr = type.GetCustomAttributes(typeof(ModifiersAttribute), false);
				return attr.Length == 1 ? (ModifiersAttribute)attr[0] : null;
			}
			else
#endif
d636 1
a636 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d638 2
a639 1
					if(MatchTypes(cad.Constructor.DeclaringType, typeofModifiersAttribute))
d641 1
a641 6
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						if(args.Count == 2)
						{
							return new ModifiersAttribute((Modifiers)args[0].Value, (bool)args[1].Value);
						}
						return new ModifiersAttribute((Modifiers)args[0].Value);
d643 1
a644 1
				return null;
d646 2
d653 4
a656 7
			if (!property.DeclaringType.Assembly.ReflectionOnly)
			{
				object[] attr = property.GetCustomAttributes(typeof(ModifiersAttribute), false);
				return attr.Length == 1 ? (ModifiersAttribute)attr[0] : null;
			}
			else
#endif
d658 1
a658 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(property))
d660 2
a661 1
					if(MatchTypes(cad.Constructor.DeclaringType, typeofModifiersAttribute))
d663 1
a663 6
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						if(args.Count == 2)
						{
							return new ModifiersAttribute((Modifiers)args[0].Value, (bool)args[1].Value);
						}
						return new ModifiersAttribute((Modifiers)args[0].Value);
d665 1
a666 1
				return null;
d668 2
d675 2
a676 1
			if(!mb.DeclaringType.Assembly.ReflectionOnly)
d678 2
a679 6
				object[] customAttribute = mb.GetCustomAttributes(typeof(ModifiersAttribute), false);
				if(customAttribute.Length == 1)
				{
					ModifiersAttribute mod = (ModifiersAttribute)customAttribute[0];
					return new ExModifiers(mod.Modifiers, mod.IsInternal);
				}
d681 2
a682 2
			else
#endif
d684 1
a684 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mb))
d686 2
a687 1
					if(MatchTypes(cad.Constructor.DeclaringType, typeofModifiersAttribute))
d689 1
a689 6
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						if(args.Count == 2)
						{
							return new ExModifiers((Modifiers)args[0].Value, (bool)args[1].Value);
						}
						return new ExModifiers((Modifiers)args[0].Value, false);
d691 1
d694 1
d751 2
a752 1
			if(!fi.DeclaringType.Assembly.ReflectionOnly)
d754 2
a755 6
				object[] customAttribute = fi.GetCustomAttributes(typeof(ModifiersAttribute), false);
				if(customAttribute.Length == 1)
				{
					ModifiersAttribute mod = (ModifiersAttribute)customAttribute[0];
					return new ExModifiers(mod.Modifiers, mod.IsInternal);
				}
d757 2
a758 2
			else
#endif
d760 1
a760 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(fi))
d762 2
a763 1
					if(MatchTypes(cad.Constructor.DeclaringType, typeofModifiersAttribute))
d765 1
a765 6
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						if(args.Count == 2)
						{
							return new ExModifiers((Modifiers)args[0].Value, (bool)args[1].Value);
						}
						return new ExModifiers((Modifiers)args[0].Value, false);
d767 1
d770 1
d1029 4
a1032 7
			if(!field.DeclaringType.Assembly.ReflectionOnly)
			{
				object[] attr = field.GetCustomAttributes(typeof(NameSigAttribute), false);
				return attr.Length == 1 ? (NameSigAttribute)attr[0] : null;
			}
			else
#endif
d1034 1
a1034 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(field))
d1036 2
a1037 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofNameSigAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return new NameSigAttribute((string)args[0].Value, (string)args[1].Value);
					}
a1038 1
				return null;
d1040 2
d1047 4
a1050 1
			if(!property.DeclaringType.Assembly.ReflectionOnly)
d1052 1
a1052 7
				object[] attr = property.GetCustomAttributes(typeof(NameSigAttribute), false);
				return attr.Length == 1 ? (NameSigAttribute)attr[0] : null;
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(property))
d1054 2
a1055 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofNameSigAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return new NameSigAttribute((string)args[0].Value, (string)args[1].Value);
					}
a1056 1
				return null;
d1058 2
d1065 4
a1068 1
			if(!method.DeclaringType.Assembly.ReflectionOnly)
d1070 1
a1070 7
				object[] attr = method.GetCustomAttributes(typeof(NameSigAttribute), false);
				return attr.Length == 1 ? (NameSigAttribute)attr[0] : null;
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(method))
d1072 2
a1073 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofNameSigAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return new NameSigAttribute((string)args[0].Value, (string)args[1].Value);
					}
a1074 1
				return null;
d1076 2
d1094 4
a1097 1
			if(!type.Assembly.ReflectionOnly)
d1099 1
a1099 7
				object[] attribs = type.GetCustomAttributes(typeof(ImplementsAttribute), false);
				return attribs.Length == 1 ? (ImplementsAttribute)attribs[0] : null;
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1101 2
a1102 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofImplementsAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return new ImplementsAttribute(DecodeArray<string>(args[0]));
					}
a1103 1
				return null;
d1105 2
a1108 1
#if !STATIC_COMPILER
d1111 5
a1115 8
#if !STUB_GENERATOR
			if(!mb.DeclaringType.Assembly.ReflectionOnly)
			{
				object[] attribs = mb.GetCustomAttributes(typeof(ThrowsAttribute), false);
				return attribs.Length == 1 ? (ThrowsAttribute)attribs[0] : null;
			}
			else
#endif
d1117 1
a1117 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mb))
d1119 6
a1124 1
					if(MatchTypes(cad.Constructor.DeclaringType, typeofThrowsAttribute))
d1126 5
a1130 13
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						if (args[0].ArgumentType == Types.String.MakeArrayType())
						{
							return new ThrowsAttribute(DecodeArray<string>(args[0]));
						}
						else if (args[0].ArgumentType == Types.Type.MakeArrayType())
						{
							return new ThrowsAttribute(DecodeArray<Type>(args[0]));
						}
						else
						{
							return new ThrowsAttribute((Type)args[0].Value);
						}
a1132 1
				return null;
d1134 2
a1136 1
#endif
d1141 3
a1143 1
			if(!t.Assembly.ReflectionOnly)
d1145 1
a1145 7
				object[] attribs = t.GetCustomAttributes(typeof(NonNestedInnerClassAttribute), false);
				string[] classes = new string[attribs.Length];
				for (int i = 0; i < attribs.Length; i++)
				{
					classes[i] = ((NonNestedInnerClassAttribute)attribs[i]).InnerClassName;
				}
				return classes;
d1147 4
a1150 2
			else
#endif
d1152 1
a1152 2
				List<string> list = new List<string>();
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(t))
d1154 2
a1155 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofNonNestedInnerClassAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						list.Add((string)args[0].Value);
					}
a1156 1
				return list.ToArray();
d1158 2
d1165 4
a1168 1
			if(!t.Assembly.ReflectionOnly)
d1170 1
a1170 7
				object[] attribs = t.GetCustomAttributes(typeof(NonNestedOuterClassAttribute), false);
				return attribs.Length == 1 ? ((NonNestedOuterClassAttribute)attribs[0]).OuterClassName : null;
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(t))
d1172 2
a1173 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofNonNestedOuterClassAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return (string)args[0].Value;
					}
a1174 1
				return null;
d1176 2
d1183 4
a1186 1
			if(!mb.DeclaringType.Assembly.ReflectionOnly)
d1188 1
a1188 7
				object[] attribs = mb.GetCustomAttributes(typeof(SignatureAttribute), false);
				return attribs.Length == 1 ? (SignatureAttribute)attribs[0] : null;
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mb))
d1190 2
a1191 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofSignatureAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return new SignatureAttribute((string)args[0].Value);
					}
a1192 1
				return null;
d1194 2
d1201 4
a1204 1
			if(!type.Assembly.ReflectionOnly)
d1206 1
a1206 7
				object[] attribs = type.GetCustomAttributes(typeof(SignatureAttribute), false);
				return attribs.Length == 1 ? (SignatureAttribute)attribs[0] : null;
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1208 2
a1209 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofSignatureAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return new SignatureAttribute((string)args[0].Value);
					}
a1210 1
				return null;
d1212 2
d1219 4
a1222 7
			if(!fi.DeclaringType.Assembly.ReflectionOnly)
			{
				object[] attribs = fi.GetCustomAttributes(typeof(SignatureAttribute), false);
				return attribs.Length == 1 ? (SignatureAttribute)attribs[0] : null;
			}
			else
#endif
d1224 1
a1224 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(fi))
d1226 2
a1227 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofSignatureAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return new SignatureAttribute((string)args[0].Value);
					}
a1228 1
				return null;
d1230 2
d1237 4
a1240 1
			if(!type.Assembly.ReflectionOnly)
d1242 1
a1242 7
				object[] attribs = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
				return attribs.Length == 1 ? (InnerClassAttribute)attribs[0] : null;
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1244 2
a1245 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofInnerClassAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return new InnerClassAttribute((string)args[0].Value, (Modifiers)args[1].Value);
					}
a1246 1
				return null;
d1248 2
d1255 7
a1261 1
			if(!type.Assembly.ReflectionOnly)
d1263 1
a1263 10
				object[] attr = type.GetCustomAttributes(typeof(RemappedInterfaceMethodAttribute), false);
				RemappedInterfaceMethodAttribute[] attr1 = new RemappedInterfaceMethodAttribute[attr.Length];
				Array.Copy(attr, attr1, attr.Length);
				return attr1;
			}
			else
#endif
			{
				List<RemappedInterfaceMethodAttribute> attrs = new List<RemappedInterfaceMethodAttribute>();
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1265 2
a1266 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofRemappedInterfaceMethodAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						attrs.Add(new RemappedInterfaceMethodAttribute((string)args[0].Value, (string)args[1].Value));
					}
a1267 1
				return attrs.ToArray();
d1269 2
d1276 4
a1279 7
			if(!type.Assembly.ReflectionOnly)
			{
				object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
				return attribs.Length == 1 ? (RemappedTypeAttribute)attribs[0] : null;
			}
			else
#endif
d1281 1
a1281 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1283 2
a1284 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofRemappedTypeAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return new RemappedTypeAttribute((Type)args[0].Value);
					}
a1285 1
				return null;
d1287 2
d1294 7
a1300 1
			if(!coreAssembly.ReflectionOnly)
d1302 1
a1302 10
				object[] attr = coreAssembly.GetCustomAttributes(typeof(RemappedClassAttribute), false);
				RemappedClassAttribute[] attr1 = new RemappedClassAttribute[attr.Length];
				Array.Copy(attr, attr1, attr.Length);
				return attr1;
			}
			else
#endif
			{
				List<RemappedClassAttribute> attrs = new List<RemappedClassAttribute>();
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(coreAssembly))
d1304 2
a1305 5
					if(MatchTypes(cad.Constructor.DeclaringType, typeofRemappedClassAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						attrs.Add(new RemappedClassAttribute((string)args[0].Value, (Type)args[1].Value));
					}
a1306 1
				return attrs.ToArray();
d1308 2
d1315 2
a1316 1
			if(!type.Assembly.ReflectionOnly)
d1318 1
a1318 6
				object[] attr = type.GetCustomAttributes(typeof(AnnotationAttributeAttribute), false);
				if(attr.Length == 1)
				{
					return ((AnnotationAttributeAttribute)attr[0]).AttributeType;
				}
				return null;
d1320 3
a1322 2
			else
#endif
d1324 1
a1324 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1326 1
a1326 4
					if(MatchTypes(cad.Constructor.DeclaringType, typeofAnnotationAttributeAttribute))
					{
						return (string)cad.ConstructorArguments[0].Value;
					}
a1327 1
				return null;
d1329 2
d1356 3
a1358 1
			if(!mod.Assembly.ReflectionOnly)
d1360 2
a1361 6
				return mod.IsDefined(attribute, false);
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mod))
d1363 1
a1363 5
					// NOTE we don't support subtyping relations!
					if(MatchTypes(cad.Constructor.DeclaringType, attribute))
					{
						return true;
					}
a1364 1
				return false;
d1366 2
d1373 3
a1375 1
			if(!asm.ReflectionOnly)
d1377 1
a1377 6
				return asm.IsDefined(attribute, false);
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(asm))
d1379 1
a1379 4
					if(MatchTypes(cad.Constructor.DeclaringType, attribute))
					{
						return true;
					}
a1380 1
				return false;
d1382 2
d1389 3
a1391 1
			if(!type.Assembly.ReflectionOnly)
d1393 2
a1394 6
				return type.IsDefined(attribute, false);
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1396 1
a1396 5
					// NOTE we don't support subtyping relations!
					if(MatchTypes(cad.Constructor.DeclaringType, attribute))
					{
						return true;
					}
a1397 1
				return false;
d1399 2
d1406 3
a1408 1
			if(!pi.Member.DeclaringType.Assembly.ReflectionOnly)
d1410 2
a1411 6
				return pi.IsDefined(attribute, false);
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(pi))
d1413 1
a1413 5
					// NOTE we don't support subtyping relations!
					if(MatchTypes(cad.Constructor.DeclaringType, attribute))
					{
						return true;
					}
a1414 1
				return false;
d1416 2
d1423 3
a1425 6
			if(!member.DeclaringType.Assembly.ReflectionOnly)
			{
				return member.IsDefined(attribute, false);
			}
			else
#endif
d1427 2
a1428 1
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(member))
d1430 1
a1430 5
					// NOTE we don't support subtyping relations!
					if(MatchTypes(cad.Constructor.DeclaringType, attribute))
					{
						return true;
					}
a1431 1
				return false;
d1433 2
d1445 4
a1448 6
			if(!mod.Assembly.ReflectionOnly)
			{
				return mod.GetCustomAttributes(typeofJavaModuleAttribute, false);
			}
			else
#endif
d1450 1
a1450 2
				List<JavaModuleAttribute> attrs = new List<JavaModuleAttribute>();
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(mod))
d1452 2
a1453 1
					if(MatchTypes(cad.Constructor.DeclaringType, typeofJavaModuleAttribute))
d1455 5
a1459 9
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						if(args.Count == 0)
						{
							attrs.Add(new JavaModuleAttribute());
						}
						else
						{
							attrs.Add(new JavaModuleAttribute(DecodeArray<string>(args[0])));
						}
a1461 1
				return attrs.ToArray();
d1463 2
d1474 3
a1476 1
			if (type.Assembly.ReflectionOnly)
d1478 1
a1478 7
				foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
				{
					if (MatchTypes(cad.Constructor.DeclaringType, typeofEnclosingMethodAttribute))
					{
						return new EnclosingMethodAttribute((string)cad.ConstructorArguments[0].Value, (string)cad.ConstructorArguments[1].Value, (string)cad.ConstructorArguments[2].Value);
					}
				}
d1480 3
a1482 1
			else
d1484 1
a1484 3
#if !STATIC_COMPILER && !STUB_GENERATOR
				object[] attr = type.GetCustomAttributes(typeof(EnclosingMethodAttribute), false);
				if (attr.Length == 1)
d1486 1
a1486 1
					return (EnclosingMethodAttribute)attr[0];
a1487 1
#endif
d1490 1
d2095 1
a2095 1
						if (IsForbiddenTypeParameterType(type) || ReflectUtil.IsReflectionOnly(type))
a3269 5
				if(mb.DeclaringType.Assembly.ReflectionOnly)
				{
					// TODO
					return null;
				}
a4538 5
			if(type.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
				return null;
			}
a4549 5
			if(mb.DeclaringType.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
				return null;
			}
a4560 5
			if(mb.DeclaringType.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
				return null;
			}
a4584 5
				if (field.DeclaringType.Assembly.ReflectionOnly)
				{
					// TODO on Whidbey this must be implemented
					return null;
				}
a4589 5
				if (getter.GetGetter().DeclaringType.Assembly.ReflectionOnly)
				{
					// TODO on Whidbey this must be implemented
					return null;
				}
a4594 5
				if (prop.GetProperty().DeclaringType.Assembly.ReflectionOnly)
				{
					// TODO on Whidbey this must be implemented
					return null;
				}
@


1.342
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@a2154 22
		private static bool IsReflectionOnly(Type type)
		{
			Assembly asm = type.Assembly;
			if (asm.ReflectionOnly)
			{
				return true;
			}
			if (!type.IsGenericType || type.IsGenericTypeDefinition)
			{
				return false;
			}
			// we have a generic type instantiation, it might have ReflectionOnly type arguments
			foreach (Type arg in type.GetGenericArguments())
			{
				if (IsReflectionOnly(arg))
				{
					return true;
				}
			}
			return false;
		}

d2226 1
a2226 1
						if (IsForbiddenTypeParameterType(type) || IsReflectionOnly(type))
@


1.341
log
@Removed "constant" instance field support (which was only used by ikvmstub and doesn't make any sense anyway).
@
text
@d26 1
a26 1
#if IKVM_REF_EMIT
a161 47
#if !IKVM_REF_EMIT
		private static void SetPropertiesAndFields(ClassLoaderWrapper loader, Attribute attrib, IKVM.Internal.MapXml.Attribute attr)
		{
			Type t = attrib.GetType();
			if(attr.Properties != null)
			{
				foreach(IKVM.Internal.MapXml.Param prop in attr.Properties)
				{
					PropertyInfo pi = t.GetProperty(prop.Name);
					pi.SetValue(attrib, ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, prop.Sig), prop.Value), null);
				}
			}
			if(attr.Fields != null)
			{
				foreach(IKVM.Internal.MapXml.Param field in attr.Fields)
				{
					FieldInfo fi = t.GetField(field.Name);
					fi.SetValue(attrib, ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, field.Sig), field.Value));
				}
			}
		}

		private static bool IsDeclarativeSecurityAttribute(ClassLoaderWrapper loader, IKVM.Internal.MapXml.Attribute attr, out SecurityAction action, out PermissionSet pset)
		{
			action = SecurityAction.Demand;
			pset = null;
			if(attr.Type != null)
			{
				Type t = StaticCompiler.GetType(attr.Type);
				if(typeofSecurityAttribute.IsAssignableFrom(t))
				{
					Type[] argTypes;
					object[] args;
					GetAttributeArgsAndTypes(loader, attr, out argTypes, out args);
					ConstructorInfo ci = t.GetConstructor(argTypes);
					SecurityAttribute attrib = ci.Invoke(args) as SecurityAttribute;
					SetPropertiesAndFields(loader, attrib, attr);
					action = attrib.Action;
					pset = new PermissionSet(PermissionState.None);
					pset.AddPermission(attrib.CreatePermission());
					return true;
				}
			}
			return false;
		}
#endif

d164 3
a166 4
#if !IKVM_REF_EMIT
			SecurityAction action;
			PermissionSet pset;
			if(IsDeclarativeSecurityAttribute(loader, attr, out action, out pset))
d168 1
a168 1
				tb.AddDeclarativeSecurity(action, pset);
a170 1
#endif
d172 1
a172 14
				bool declarativeSecurity;
				CustomAttributeBuilder cab = CreateCustomAttribute(loader, attr, out declarativeSecurity);
				if (declarativeSecurity)
				{
#if IKVM_REF_EMIT
					tb.__AddDeclarativeSecurity(cab);
#else
					throw new InvalidOperationException();
#endif
				}
				else
				{
					tb.SetCustomAttribute(cab);
				}
d188 3
a190 4
#if !IKVM_REF_EMIT
			SecurityAction action;
			PermissionSet pset;
			if(IsDeclarativeSecurityAttribute(loader, attr, out action, out pset))
d192 1
a192 1
				mb.AddDeclarativeSecurity(action, pset);
a194 1
#endif
d196 1
a196 14
				bool declarativeSecurity;
				CustomAttributeBuilder cab = CreateCustomAttribute(loader, attr, out declarativeSecurity);
				if (declarativeSecurity)
				{
#if IKVM_REF_EMIT
					mb.__AddDeclarativeSecurity(cab);
#else
					throw new InvalidOperationException();
#endif
				}
				else
				{
					mb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
				}
d202 3
a204 4
#if !IKVM_REF_EMIT
			SecurityAction action;
			PermissionSet pset;
			if(IsDeclarativeSecurityAttribute(loader, attr, out action, out pset))
d206 1
a206 1
				cb.AddDeclarativeSecurity(action, pset);
a208 1
#endif
d210 1
a210 14
				bool declarativeSecurity;
				CustomAttributeBuilder cab = CreateCustomAttribute(loader, attr, out declarativeSecurity);
				if (declarativeSecurity)
				{
#if IKVM_REF_EMIT
					cb.__AddDeclarativeSecurity(cab);
#else
					throw new InvalidOperationException();
#endif
				}
				else
				{
					cb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
				}
a347 1
#endif
a348 1
#if STATIC_COMPILER
d1664 1
a1664 1
#if IKVM_REF_EMIT
d1871 1
a1871 1
#if !IKVM_REF_EMIT
d1914 1
a1914 1
#endif
@


1.340
log
@Last set of changes preparing for new stub generator. A massive amount of conditional compilation changes, to skip irrelevant code when building ikvmstub.
@
text
@a98 1
		private static Type typeofConstantValueAttribute = JVM.LoadType(typeof(ConstantValueAttribute));
a721 28
		internal static object GetConstantValue(FieldInfo field)
		{
#if !STATIC_COMPILER && !STUB_GENERATOR
			if(!field.DeclaringType.Assembly.ReflectionOnly)
			{
				// In Java, instance fields can also have a ConstantValue attribute so we emulate that
				// with ConstantValueAttribute (for consumption by ikvmstub only)
				object[] attrib = field.GetCustomAttributes(typeof(ConstantValueAttribute), false);
				if(attrib.Length == 1)
				{
					return ((ConstantValueAttribute)attrib[0]).GetConstantValue();
				}
				return null;
			}
			else
#endif
			{
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(field))
				{
					if(MatchTypes(cad.Constructor.DeclaringType, typeofConstantValueAttribute))
					{
						return cad.ConstructorArguments[0].Value;
					}
				}
				return null;
			}
		}

a1741 23

		internal static void SetConstantValue(FieldBuilder field, object constantValue)
		{
			CustomAttributeBuilder constantValueAttrib;
			try
			{
				constantValueAttrib = new CustomAttributeBuilder(typeofConstantValueAttribute.GetConstructor(new Type[] { JVM.Import(constantValue.GetType()) }), new object[] { constantValue });
			}
			catch (OverflowException)
			{
				// FXBUG for char values > 32K .NET (1.1 and 2.0) throws an exception (because it tries to convert to Int16)
				if (constantValue is char)
				{
					// we use the int constant value instead, the stub generator can handle that
					constantValueAttrib = new CustomAttributeBuilder(typeofConstantValueAttribute.GetConstructor(new Type[] { Types.Int32 }), new object[] { (int)(char)constantValue });
				}
				else
				{
					throw;
				}
			}
			field.SetCustomAttribute(constantValueAttrib);
		}
@


1.339
log
@More preparations for new stub generator.
- When compiling ikvmstub, do type comparisons by name only.
- Replace two cases of typeof() with references to Types fields.
- Added RemappedClassAttribute and RemappedTypeAttribute constructors that explicitly take System.Type (when compiling ikvmstub)
- Avoid unnecessary reference to System.Configuration.dll in tracer.cs (when compiling ikvmstub).
@
text
@d725 1
a725 1
#if !STATIC_COMPILER
d753 1
a753 1
#if !STATIC_COMPILER
d780 1
a780 1
#if !STATIC_COMPILER
d807 1
a807 1
#if !STATIC_COMPILER
d888 1
a888 1
#if !STATIC_COMPILER
d1171 1
a1171 1
#if !STATIC_COMPILER
d1194 1
a1194 1
#if !STATIC_COMPILER
d1217 1
a1217 1
#if !STATIC_COMPILER
d1251 1
a1251 1
#if !STATIC_COMPILER
d1275 1
d1282 1
d1310 1
a1310 1
#if !STATIC_COMPILER
d1339 1
a1339 1
#if !STATIC_COMPILER
d1362 1
a1362 1
#if !STATIC_COMPILER
d1385 1
a1385 1
#if !STATIC_COMPILER
d1408 1
a1408 1
#if !STATIC_COMPILER
d1431 1
a1431 1
#if !STATIC_COMPILER
d1454 1
a1454 1
#if !STATIC_COMPILER
d1480 1
a1480 1
#if !STATIC_COMPILER
d1503 1
a1503 1
#if !STATIC_COMPILER
d1529 1
a1529 1
#if !STATIC_COMPILER
d1575 1
a1575 1
#if !STATIC_COMPILER
d1597 1
a1597 1
#if !STATIC_COMPILER
d1618 1
a1618 1
#if !STATIC_COMPILER
d1640 1
a1640 1
#if !STATIC_COMPILER
d1662 1
a1662 1
#if !STATIC_COMPILER
d1689 1
a1689 1
#if !STATIC_COMPILER
d1736 1
a1736 1
#if !STATIC_COMPILER
d2208 1
a2208 1
#if !STATIC_COMPILER
d2226 1
d2244 1
d2282 1
a2282 1
#if !STATIC_COMPILER
d2476 1
a2476 1
#endif // !STATIC_COMPILER
d3302 1
a3302 1
#if !STATIC_COMPILER
d3347 1
a3347 1
#if !STATIC_COMPILER
d3358 1
d3493 1
d3507 1
d3511 1
d3528 1
a3528 1
#if !STATIC_COMPILER
d3582 1
a3582 1
#endif // !STATIC_COMPILER
d3725 1
d3739 1
d4480 1
d4487 1
d4608 1
d4651 1
d4653 1
a4653 1
#if !STATIC_COMPILER && !FIRST_PASS
d4766 1
d4774 1
d4830 1
a4830 1
#if !STATIC_COMPILER
d5017 1
a5017 1
#if !STATIC_COMPILER
@


1.338
log
@Moved non-throwing signature parsing from ClassFile.cs to ClassLoaderWrapper.cs (and merged it with the throwing variant). This avoids new stub generator having to include ClassFile.cs.
@
text
@d712 2
d717 4
a720 1
				&& t1.Assembly.GetName().Name == t2.Assembly.GetName().Name;
d1287 1
a1287 1
						if (args[0].ArgumentType == typeof(string[]))
d1291 1
a1291 1
						else if (args[0].ArgumentType == typeof(Type[]))
d4371 10
d4387 2
a4388 3
				&& parameters[len - 1].ParameterType == CoreClasses.ikvm.@@internal.CallerID.Wrapper.TypeAsSignatureType
				&& !method.DeclaringType.IsInterface
				&& GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader())
@


1.337
log
@Moved StringConstants from ClassFile.cs to TypeWrapper.cs, to avoid new stub generator (to be checked in later) to have to include ClassFile.cs
@
text
@d320 1
a320 1
			TypeWrapper[] twargs = ClassFile.ArgTypeWrapperListFromSig(loader, attr.Sig);
d329 1
a329 1
					tw = ClassFile.FieldTypeWrapperFromSig(loader, attr.Params[i].Sig);
d377 1
a377 1
						propertyValues[i] = ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, attr.Properties[i].Sig), attr.Properties[i].Value);
d394 1
a394 1
						fieldValues[i] = ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, attr.Fields[i].Sig), attr.Fields[i].Value);
d430 1
a430 1
						fieldValues[i] = ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, attr.Fields[i].Sig), attr.Fields[i].Value);
@


1.336
log
@Moved VerifierTypeWrapper from verifier.cs to TypeWrapper.cs, to avoid new stub generator (to be checked in later) to have to include verifier.cs
(also made VerifierTypeWrapper sealed)
@
text
@d41 9
@


1.335
log
@Integrated new IKVM.Reflection implementation.
@
text
@d5174 119
@


1.334
log
@Use GetConstructors and GetMethods instead of GetMembers (which is needlessly expensive).
@
text
@a25 1
using System.Reflection;
d27 1
d29 1
d31 1
d324 1
a324 1
					Array arr = Array.CreateInstance(tw.ElementTypeWrapper.TypeAsArrayType, attr.Params[i].Elements.Length);
d1794 3
d1798 1
d1940 1
a1940 1
			return Activator.CreateInstance(EnumHelper.GetUnderlyingType(enumType));
@


1.333
log
@More changes to make future merge of IKVM.Reflection easier:
- added #if conditionals to remove runtime only methods from compiler
- added two missing JVM.Import()s.
@
text
@d3861 9
a3869 14
				List<MethodWrapper> methods = new List<MethodWrapper>();
				MemberInfo[] members = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
				foreach(MemberInfo m in members)
				{
					if(!AttributeHelper.IsHideFromJava(m))
					{
						MethodBase method = m as MethodBase;
						if(method != null &&
							(remappedType.IsSealed || !m.Name.StartsWith("instancehelper_")) &&
							(!remappedType.IsSealed || method.IsStatic))
						{
							methods.Add(CreateRemappedMethodWrapper(method));
						}
					}
d3894 1
a3894 1
						methods.Add(new CompiledRemappedMethodWrapper(this, m.Name, sig, method, retType, paramTypes, modifiers, false, mbHelper, null));
d3897 11
a3907 1
				SetMethods(methods.ToArray());
@


1.332
log
@Don't cache inner classes.
@
text
@d1718 1
d1724 1
d1759 1
a1759 1
				constantValueAttrib = new CustomAttributeBuilder(typeofConstantValueAttribute.GetConstructor(new Type[] { constantValue.GetType() }), new object[] { constantValue });
d1833 1
a1833 1
				switch (Type.GetTypeCode(v1.GetType()))
d3323 1
d3332 1
d3500 1
a3535 1
#if !STATIC_COMPILER
d4780 1
d4883 1
d4967 1
d4991 1
@


1.331
log
@Don't automatically hide "op_Implicit" methods. Instead mark the ones we automatically generate with HideFromJavaAttribute.
@
text
@a3801 1
		private TypeWrapper[] innerclasses;
d4186 3
a4188 2
				// TODO why are we caching this?
				if(innerclasses == null)
d4190 1
a4190 3
					Type[] nestedTypes = type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly);
					List<TypeWrapper> wrappers = new List<TypeWrapper>();
					for(int i = 0; i < nestedTypes.Length; i++)
d4192 1
a4192 4
						if(!AttributeHelper.IsHideFromJava(nestedTypes[i]) && !nestedTypes[i].Name.StartsWith("__<"))
						{
							wrappers.Add(ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]));
						}
a4193 5
					foreach(string s in AttributeHelper.GetNonNestedInnerClasses(type))
					{
						wrappers.Add(GetClassLoader().LoadClassByDottedName(s));
					}
					innerclasses = wrappers.ToArray();
d4195 5
a4199 1
				return innerclasses;
@


1.330
log
@Don't use Type.GetMembers(), instead of use GetMethods(), GetConstructor(), GetFields() and GetProperties() explicitly.
@
text
@d4473 1
a4473 2
				if(method.IsSpecialName && 
					(method.Name == "op_Implicit" || method.Name.StartsWith("__<")))
@


1.329
log
@Added LazyPublishMethods and LazyPublishFields to TypeWrapper and implemented the split in CompiledTypeWrapper.
@
text
@d4450 2
a4451 2
			MemberInfo[] members = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			foreach(MemberInfo m in members)
d4453 1
a4453 1
				if(!AttributeHelper.IsHideFromJava(m))
d4455 35
a4489 2
					MethodBase method = m as MethodBase;
					if(method != null)
d4491 1
a4491 26
						if(method.IsSpecialName && 
							(method.Name == "op_Implicit" || method.Name.StartsWith("__<")))
						{
							// skip
						}
						else if(isDelegate && method.IsConstructor && !method.IsStatic)
						{
							methods.Add(new DelegateConstructorMethodWrapper(this, method));
						}
						else
						{
							string name;
							string sig;
							TypeWrapper retType;
							TypeWrapper[] paramTypes;
							MethodInfo mi = method as MethodInfo;
							bool hideFromReflection = mi != null ? AttributeHelper.IsHideFromReflection(mi) : false;
							MemberFlags flags = hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None;
							GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes, ref flags);
							ExModifiers mods = AttributeHelper.GetModifiers(method, false);
							if(mods.IsInternal)
							{
								flags |= MemberFlags.InternalAccess;
							}
							methods.Add(MethodWrapper.Create(this, name, sig, method, retType, paramTypes, mods.Modifiers, flags));
						}
d4493 1
a4495 1
			SetMethods(methods.ToArray());
a4499 1
			bool isDelegate = type.BaseType == Types.MulticastDelegate;
d4501 2
a4502 2
			MemberInfo[] members = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			foreach(MemberInfo m in members)
d4504 1
a4504 1
				if(!AttributeHelper.IsHideFromJava(m))
d4506 5
a4510 2
					FieldInfo field = m as FieldInfo;
					if(field != null)
d4512 23
a4534 1
						if(field.IsSpecialName && field.Name.StartsWith("__<"))
d4536 1
a4536 1
							// skip
d4540 1
a4540 31
							fields.Add(CreateFieldWrapper(field));
						}
					}
					else
					{
						// NOTE explictly defined properties (in map.xml) are decorated with HideFromJava,
						// so we don't need to worry about them here
						PropertyInfo property = m as PropertyInfo;
						if(property != null)
						{
							// Only AccessStub properties (marked by HideFromReflectionAttribute or NameSigAttribute)
							// are considered here
							FieldWrapper accessStub;
							if(CompiledAccessStubFieldWrapper.TryGet(this, property, out accessStub))
							{
								fields.Add(accessStub);
							}
							else
							{
								// If the property has a ModifiersAttribute, we know that it is an explicit property
								// (defined in Java source by an @@ikvm.lang.Property annotation)
								ModifiersAttribute mods = AttributeHelper.GetModifiersAttribute(property);
								if(mods != null)
								{
									fields.Add(new CompiledPropertyFieldWrapper(this, property, new ExModifiers(mods.Modifiers, mods.IsInternal)));
								}
								else
								{
									fields.Add(CreateFieldWrapper(property));
								}
							}
@


1.328
log
@We have room for a free bool, so it makes more sense to only get the __<clinit> method when we really need to (and not trigger a LazyPublishMembers).
@
text
@d2836 1
a2836 8
			lock(this)
			{
				if(fields == null)
				{
					LazyPublishMembers();
				}
			}
			foreach(FieldWrapper fw in fields)
d2870 10
d2882 1
a2882 1
			lock(this)
d2884 1
a2884 1
				if(methods == null)
d2886 4
a2889 1
					LazyPublishMembers();
d2897 1
a2897 1
			lock(this)
d2899 1
a2899 1
				if(fields == null)
d2901 4
a2904 1
					LazyPublishMembers();
d2912 2
a2913 7
			lock(this)
			{
				if(methods == null)
				{
					LazyPublishMembers();
				}
			}
d3856 1
a3856 1
			protected override void LazyPublishMembers()
a3858 1
				List<FieldWrapper> fields = new List<FieldWrapper>();
a3870 8
						else
						{
							FieldInfo field = m as FieldInfo;
							if(field != null)
							{
								fields.Add(CreateFieldWrapper(field));
							}
						}
d3900 14
a3913 1
				SetFields(fields.ToArray());
d4446 1
a4446 1
		protected override void LazyPublishMembers()
a4449 1
			List<FieldWrapper> fields = new List<FieldWrapper>();
d4485 26
d4513 4
a4516 2
						FieldInfo field = m as FieldInfo;
						if(field != null)
d4518 4
a4521 1
							if(field.IsSpecialName && field.Name.StartsWith("__<"))
d4523 1
a4523 1
								// skip
d4527 4
a4530 14
								fields.Add(CreateFieldWrapper(field));
							}
						}
						else
						{
							// NOTE explictly defined properties (in map.xml) are decorated with HideFromJava,
							// so we don't need to worry about them here
							PropertyInfo property = m as PropertyInfo;
							if(property != null)
							{
								// Only AccessStub properties (marked by HideFromReflectionAttribute or NameSigAttribute)
								// are considered here
								FieldWrapper accessStub;
								if(CompiledAccessStubFieldWrapper.TryGet(this, property, out accessStub))
d4532 1
a4532 1
									fields.Add(accessStub);
d4536 1
a4536 11
									// If the property has a ModifiersAttribute, we know that it is an explicit property
									// (defined in Java source by an @@ikvm.lang.Property annotation)
									ModifiersAttribute mods = AttributeHelper.GetModifiersAttribute(property);
									if(mods != null)
									{
										fields.Add(new CompiledPropertyFieldWrapper(this, property, new ExModifiers(mods.Modifiers, mods.IsInternal)));
									}
									else
									{
										fields.Add(CreateFieldWrapper(property));
									}
a4542 1
			SetMethods(methods.ToArray());
@


1.327
log
@Added two constructors to ThowsAttribute that take a Type and a Type[] for greater convenience when applying the attribute to user code and for compatibility with Grasshopper's ThrowsAttribute.
@
text
@d3800 1
d4112 5
a4116 2
				// trigger LazyPublishMembers
				GetMethods();
a4440 1
			clinitMethod = type.GetMethod("__<clinit>", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
d4704 1
a4704 3
			// trigger LazyPublishMembers
			GetMethods();
			if(clinitMethod != null)
@


1.326
log
@- Fixed IsPackageAccessibleFrom to consider class loaders, instead of InternalsVisibleToAttribute
- Added automatic access to internal accessibility members across assemblies in multi target compilation (previously this was only done for -sharedclassloader scenarios)
- Cleaned up existing field access stubs (now known as "type 1") and added type 2 access stubs to make public fields that have a non-public field type accessible.
@
text
@d1256 1
a1258 1
#if !STATIC_COMPILER
a1264 1
#endif
d1271 12
a1282 1
						return new ThrowsAttribute(DecodeArray<string>(args[0]));
d1288 1
@


1.325
log
@- Moved enum helper methods into new EnumHelper class.
- Changed .NET EnumEnum field to call ByteCodeHelper method, instead of emitting code in place.
@
text
@d1025 6
d1176 23
d2963 17
a2979 1
			return MatchingPackageNames(name, wrapper.name) && InternalsVisibleTo(wrapper);
d3572 15
d4485 1
a4485 1
								// Only AccessStub properties (marked by HideFromReflectionAttribute)
d4487 2
a4488 1
								if(AttributeHelper.IsHideFromReflection(property))
d4490 1
a4490 1
									fields.Add(new CompiledAccessStubFieldWrapper(this, property));
@


1.324
log
@Implemented enum parsing.
@
text
@d103 1
a103 1
				return ParseEnumValue(tw.TypeAsTBD, val);
a151 22
		private static object ParseEnumValue(Type type, string val)
		{
			object retval = null;
			foreach (string str in val.Split(','))
			{
				FieldInfo field = type.GetField(str.Trim(), BindingFlags.Public | BindingFlags.Static);
				if (field == null)
				{
					throw new InvalidOperationException("Enum value '" + str + "' not found in " + type.FullName);
				}
				if (retval == null)
				{
					retval = field.GetRawConstantValue();
				}
				else
				{
					retval = Annotation.OrBoxedIntegrals(retval, field.GetRawConstantValue());
				}
			}
			return retval;
		}

d1746 101
d1892 1
a1892 37
			return Activator.CreateInstance(Enum.GetUnderlyingType(enumType));
		}

		// note that we only support the integer types that C# supports
		// (the CLI also supports bool, char, IntPtr & UIntPtr)
		internal static object OrBoxedIntegrals(object v1, object v2)
		{
			Debug.Assert(v1.GetType() == v2.GetType());
			if(v1 is ulong)
			{
				ulong l1 = (ulong)v1;
				ulong l2 = (ulong)v2;
				return l1 | l2;
			}
			else
			{
				long v = ((IConvertible)v1).ToInt64(null) | ((IConvertible)v2).ToInt64(null);
				switch(Type.GetTypeCode(v1.GetType()))
				{
					case TypeCode.SByte:
						return (sbyte)v;
					case TypeCode.Byte:
						return (byte)v;
					case TypeCode.Int16:
						return (short)v;
					case TypeCode.UInt16:
						return (ushort)v;
					case TypeCode.Int32:
						return (int)v;
					case TypeCode.UInt32:
						return (uint)v;
					case TypeCode.Int64:
						return (long)v;
					default:
						throw new InvalidOperationException();
				}
			}
d1915 1
a1915 1
							value = OrBoxedIntegrals(value, newval);
@


1.323
log
@Use IKVM.Reflection.Emit's new-style declarative security APIs.
@
text
@d103 1
a103 11
				if(tw.TypeAsTBD.Assembly.ReflectionOnly)
				{
					// TODO implement full parsing semantics
					FieldInfo field = tw.TypeAsTBD.GetField(val);
					if(field == null)
					{
						throw new NotImplementedException("Parsing enum value: " + val);
					}
					return field.GetRawConstantValue();
				}
				return Enum.Parse(tw.TypeAsTBD, val);
d152 22
d1818 1
a1818 1
		private static object OrBoxedIntegrals(object v1, object v2)
@


1.322
log
@Removed unused methods.
@
text
@d71 1
d162 1
d191 1
a191 1
				if(typeof(SecurityAttribute).IsAssignableFrom(t))
d207 1
d211 1
d219 1
d221 14
a234 1
				tb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
d250 1
d258 1
d260 14
a273 1
				mb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
d279 1
d287 1
d289 14
a302 1
				cb.SetCustomAttribute(CreateCustomAttribute(loader, attr));
d348 6
d361 1
a361 4
				if(typeof(SecurityAttribute).IsAssignableFrom(t))
				{
					throw new NotImplementedException("Declarative SecurityAttribute support not implemented");
				}
d410 1
d1898 1
d1904 1
d1941 1
@


1.321
log
@Changed CompiledTypeWrapper.Interfaces to avoid using the class loader to resolve the interface names. Moved common code to get interface type wrappers into GetImplementedInterfacesAsTypeWrappers() helper method.
@
text
@a181 12
		internal static Attribute InstantiatePseudoCustomAttribute(ClassLoaderWrapper loader, IKVM.Internal.MapXml.Attribute attr)
		{
			Type t = StaticCompiler.GetType(attr.Type);
			Type[] argTypes;
			object[] args;
			GetAttributeArgsAndTypes(loader, attr, out argTypes, out args);
			ConstructorInfo ci = t.GetConstructor(argTypes);
			Attribute attrib = ci.Invoke(args) as Attribute;
			SetPropertiesAndFields(loader, attrib, attr);
			return attrib;
		}

@


1.320
log
@Fixed exception message.
@
text
@d3409 20
d3954 32
a3985 6
					// NOTE instead of getting the interfaces list from Type, we use a custom
					// attribute to list the implemented interfaces, because Java reflection only
					// reports the interfaces *directly* implemented by the type, not the inherited
					// interfaces. This is significant for serialVersionUID calculation (for example).
					ImplementsAttribute attr = AttributeHelper.GetImplements(type);
					if(attr != null)
d3987 1
a3987 3
						string[] interfaceNames = attr.Interfaces;
						TypeWrapper[] interfaceWrappers = new TypeWrapper[interfaceNames.Length];
						for(int i = 0; i < interfaceWrappers.Length; i++)
d3989 2
a3990 1
							interfaceWrappers[i] = GetClassLoader().LoadClassByDottedName(interfaceNames[i]);
a3991 1
						this.interfaces = interfaceWrappers;
d3993 1
a3993 1
					else
d3995 1
a3995 1
						interfaces = TypeWrapper.EmptyArray;
a3997 1
				return interfaces;
d3999 1
@


1.319
log
@More type funneling.
@
text
@d326 1
a326 1
					throw new InvalidOperationException(string.Format("Constructor missing: {0}::<init>{1}", attr.Class, attr.Sig));
@


1.318
log
@Replaced most type literals with static field access (in Types class) or warpped JVM.Import() around them.
@
text
@d121 1
a121 1
				return Type.GetType(val, true);
@


1.317
log
@Moved GetAssemblyClassLoader() (and related stuff) from ClassLoaderWrapper to AssemblyClassLoader and renamed it to FromAssembly().
@
text
@d114 1
a114 1
			else if(tw.TypeAsTBD == typeof(Type))
d443 1
a443 1
				deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d460 1
a460 1
				deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d469 1
a469 1
				deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d478 1
a478 1
				deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d489 1
a489 1
					throwsAttribute = typeofThrowsAttribute.GetConstructor(new Type[] { typeof(string[]) });
d517 1
a517 1
				nonNestedInnerClassAttribute = typeofNonNestedInnerClassAttribute.GetConstructor(new Type[] { typeof(string) });
d526 1
a526 1
				nonNestedOuterClassAttribute = typeofNonNestedOuterClassAttribute.GetConstructor(new Type[] { typeof(string) });
d646 1
a646 1
					implementsAttribute = typeofImplementsAttribute.GetConstructor(new Type[] { typeof(string[]) });
d833 1
a833 1
			if(parameters.Length > 0 && IsDefined(parameters[parameters.Length - 1], typeof(ParamArrayAttribute)))
d910 1
a910 1
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, typeof(bool) }), new object[] { modifiers, isInternal });
d924 1
a924 1
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, typeof(bool) }), new object[] { modifiers, isInternal });
d938 1
a938 1
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, typeof(bool) }), new object[] { modifiers, isInternal });
d952 1
a952 1
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, typeof(bool) }), new object[] { modifiers, isInternal });
d966 1
a966 1
				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers, typeof(bool) }), new object[] { modifiers, isInternal });
d977 1
a977 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofNameSigAttribute.GetConstructor(new Type[] { typeof(string), typeof(string) }), new object[] { name, sig });
d991 1
a991 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofNameSigAttribute.GetConstructor(new Type[] { typeof(string), typeof(string) }), new object[] { name, sig });
d1007 1
a1007 1
			Type[] argTypes = new Type[] { typeof(string), typeofModifiers };
d1018 1
a1018 1
				sourceFileAttribute = typeofSourceFileAttribute.GetConstructor(new Type[] { typeof(string) });
d1027 1
a1027 1
				sourceFileAttribute = typeofSourceFileAttribute.GetConstructor(new Type[] { typeof(string) });
d1040 1
a1040 1
					lineNumberTableAttribute2 = typeofLineNumberTableAttribute.GetConstructor(new Type[] { typeof(ushort) });
d1049 1
a1049 1
					lineNumberTableAttribute1 = typeofLineNumberTableAttribute.GetConstructor(new Type[] { typeof(byte[]) });
d1068 1
a1068 1
				enclosingMethodAttribute = typeofEnclosingMethodAttribute.GetConstructor(new Type[] { typeof(string), typeof(string), typeof(string) });
d1077 1
a1077 1
				signatureAttribute = typeofSignatureAttribute.GetConstructor(new Type[] { typeof(string) });
d1086 1
a1086 1
				signatureAttribute = typeofSignatureAttribute.GetConstructor(new Type[] { typeof(string) });
d1095 1
a1095 1
				signatureAttribute = typeofSignatureAttribute.GetConstructor(new Type[] { typeof(string) });
d1111 1
a1111 1
				paramArrayAttribute = new CustomAttributeBuilder(typeof(ParamArrayAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d1470 1
a1470 1
				if(cad.Constructor.DeclaringType == typeof(System.Runtime.CompilerServices.InternalsVisibleToAttribute))
d1660 1
a1660 1
			ConstructorInfo remappedClassAttribute = typeofRemappedClassAttribute.GetConstructor(new Type[] { typeof(string), typeof(Type) });
d1666 1
a1666 1
			ConstructorInfo remappedTypeAttribute = typeofRemappedTypeAttribute.GetConstructor(new Type[] { typeof(Type) });
d1672 1
a1672 1
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofRemappedInterfaceMethodAttribute.GetConstructor(new Type[] { typeof(string), typeof(string) }), new object[] { name, mappedTo } );
d1695 1
a1695 1
					constantValueAttrib = new CustomAttributeBuilder(typeofConstantValueAttribute.GetConstructor(new Type[] { typeof(int) }), new object[] { (int)(char)constantValue });
d1708 1
a1708 1
			Type runtimeCompatibilityAttribute = typeof(System.Runtime.CompilerServices.RuntimeCompatibilityAttribute);
d1835 1
a1835 1
			else if(targetType == typeof(Type))
d2105 4
a2108 4
			return type == typeof(void)
				|| type == typeof(ArgIterator)
				|| type == typeof(RuntimeArgumentHandle)
				|| type == typeof(TypedReference)
d2896 1
a2896 1
					return typeof(object);
d2900 1
a2900 1
					return ArrayTypeWrapper.MakeArrayType(typeof(object), ArrayRank);
d2920 1
a2920 1
					return typeof(object);
d2929 1
a2929 1
					return ArrayTypeWrapper.MakeArrayType(typeof(object), ArrayRank);
d2942 1
a2942 1
					return typeof(object);
d2946 1
a2946 1
					return ArrayTypeWrapper.MakeArrayType(typeof(object), ArrayRank);
d2958 1
a2958 1
					return typeof(Exception);
d3269 1
a3269 1
				ilgen.Emit(OpCodes.Castclass, ArrayTypeWrapper.MakeArrayType(typeof(object), rank));
d3517 9
a3525 9
		internal static readonly PrimitiveTypeWrapper BYTE = new PrimitiveTypeWrapper(typeof(byte), "B");
		internal static readonly PrimitiveTypeWrapper CHAR = new PrimitiveTypeWrapper(typeof(char), "C");
		internal static readonly PrimitiveTypeWrapper DOUBLE = new PrimitiveTypeWrapper(typeof(double), "D");
		internal static readonly PrimitiveTypeWrapper FLOAT = new PrimitiveTypeWrapper(typeof(float), "F");
		internal static readonly PrimitiveTypeWrapper INT = new PrimitiveTypeWrapper(typeof(int), "I");
		internal static readonly PrimitiveTypeWrapper LONG = new PrimitiveTypeWrapper(typeof(long), "J");
		internal static readonly PrimitiveTypeWrapper SHORT = new PrimitiveTypeWrapper(typeof(short), "S");
		internal static readonly PrimitiveTypeWrapper BOOLEAN = new PrimitiveTypeWrapper(typeof(bool), "Z");
		internal static readonly PrimitiveTypeWrapper VOID = new PrimitiveTypeWrapper(typeof(void), "V");
d3832 1
a3832 1
					if(attr.Type == typeof(object))
d4223 1
a4223 1
			bool isDelegate = type.BaseType == typeof(MulticastDelegate);
d4663 1
a4663 1
				return new CustomAttributeBuilder(type.GetConstructor(new Type[] { typeof(object[]) }), new object[] { annotation });
d4791 1
a4791 1
					clone = typeof(Array).GetMethod("Clone", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
@


1.317.2.1
log
@Back port of fix for #2946842.
@
text
@a3408 13

		// return the constructor used for automagic .NET serialization
		internal virtual ConstructorInfo GetSerializationConstructor()
		{
			Debug.Assert(!(this is DynamicTypeWrapper));
			return this.TypeAsBaseType.GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[] {
						typeof(System.Runtime.Serialization.SerializationInfo), typeof(System.Runtime.Serialization.StreamingContext) }, null);
		}

		internal virtual ConstructorInfo GetBaseSerializationConstructor()
		{
			return baseWrapper.GetSerializationConstructor();
		}
@


1.316
log
@Moved DotNetTypeWrapper class into its own source file.
@
text
@d3868 1
a3868 1
			return ClassLoaderWrapper.GetAssemblyClassLoader(type.Assembly);
@


1.315
log
@Moved BakedTypeCleanupHack to DynamicTypeWrapper.
@
text
@a4763 2553
	sealed class DotNetTypeWrapper : TypeWrapper
	{
		private const string NamePrefix = "cli.";
		internal const string DelegateInterfaceSuffix = "$Method";
		internal const string AttributeAnnotationSuffix = "$Annotation";
		internal const string AttributeAnnotationReturnValueSuffix = "$__ReturnValue";
		internal const string AttributeAnnotationMultipleSuffix = "$__Multiple";
		internal const string EnumEnumSuffix = "$__Enum";
		internal const string GenericEnumEnumTypeName = "ikvm.internal.EnumEnum`1";
		internal const string GenericDelegateInterfaceTypeName = "ikvm.internal.DelegateInterface`1";
		internal const string GenericAttributeAnnotationTypeName = "ikvm.internal.AttributeAnnotation`1";
		internal const string GenericAttributeAnnotationReturnValueTypeName = "ikvm.internal.AttributeAnnotationReturnValue`1";
		internal const string GenericAttributeAnnotationMultipleTypeName = "ikvm.internal.AttributeAnnotationMultiple`1";
		private static readonly Dictionary<Type, TypeWrapper> types = new Dictionary<Type, TypeWrapper>();
		private readonly Type type;
		private TypeWrapper[] innerClasses;
		private TypeWrapper outerClass;
		private TypeWrapper[] interfaces;

		private static Modifiers GetModifiers(Type type)
		{
			Modifiers modifiers = 0;
			if(type.IsPublic)
			{
				modifiers |= Modifiers.Public;
			}
			else if(type.IsNestedPublic)
			{
				modifiers |= Modifiers.Static;
				if(IsVisible(type))
				{
					modifiers |= Modifiers.Public;
				}
			}
			else if(type.IsNestedPrivate)
			{
				modifiers |= Modifiers.Private | Modifiers.Static;
			}
			else if(type.IsNestedFamily || type.IsNestedFamORAssem)
			{
				modifiers |= Modifiers.Protected | Modifiers.Static;
			}
			else if(type.IsNestedAssembly || type.IsNestedFamANDAssem)
			{
				modifiers |= Modifiers.Static;
			}

			if(type.IsSealed)
			{
				modifiers |= Modifiers.Final;
			}
			else if(type.IsAbstract) // we can't be abstract if we're final
			{
				modifiers |= Modifiers.Abstract;
			}
			if(type.IsInterface)
			{
				modifiers |= Modifiers.Interface;
			}
			return modifiers;
		}

		// NOTE when this is called on a remapped type, the "warped" underlying type name is returned.
		// E.g. GetName(typeof(object)) returns "cli.System.Object".
		internal static string GetName(Type type)
		{
			Debug.Assert(!type.Name.EndsWith("[]") && !AttributeHelper.IsJavaModule(type.Module));

			string name = type.FullName;

			if(name == null)
			{
				// generic type parameters don't have a full name
				return null;
			}

			if(type.IsGenericType && !type.ContainsGenericParameters)
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder();
				sb.Append(MangleTypeName(type.GetGenericTypeDefinition().FullName));
				sb.Append("_$$$_");
				string sep = "";
				foreach(Type t1 in type.GetGenericArguments())
				{
					Type t = t1;
					sb.Append(sep);
					// NOTE we can't use ClassLoaderWrapper.GetWrapperFromType() here to get t's name,
					// because we might be resolving a generic type that refers to a type that is in
					// the process of being constructed.
					//
					// For example:
					//   class Base<T> { } 
					//   class Derived : Base<Derived> { }
					//
					while(ClassLoaderWrapper.IsVector(t))
					{
						t = t.GetElementType();
						sb.Append('A');
					}
					if(PrimitiveTypeWrapper.IsPrimitiveType(t))
					{
						sb.Append(ClassLoaderWrapper.GetWrapperFromType(t).SigName);
					}
					else
					{
						string s;
						if(ClassLoaderWrapper.IsRemappedType(t))
						{
							s = ClassLoaderWrapper.GetWrapperFromType(t).Name;
						}
						else if(AttributeHelper.IsJavaModule(t.Module))
						{
							s = CompiledTypeWrapper.GetName(t);
						}
						else
						{
							s = DotNetTypeWrapper.GetName(t);
						}
						// only do the mangling for non-generic types (because we don't want to convert
						// the double underscores in two adjacent _$$$_ or _$$$$_ markers)
						if (s.IndexOf("_$$$_") == -1)
						{
							s = s.Replace("__", "$$005F$$005F");
							s = s.Replace(".", "__");
						}
						sb.Append('L').Append(s);
					}
					sep = "_$$_";
				}
				sb.Append("_$$$$_");
				return sb.ToString();
			}

			if(AttributeHelper.IsNoPackagePrefix(type)
				&& name.IndexOf('$') == -1)
			{
				return name.Replace('+', '$');
			}

			return MangleTypeName(name);
		}

		private static string MangleTypeName(string name)
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder(NamePrefix, NamePrefix.Length + name.Length);
			bool escape = false;
			bool nested = false;
			for(int i = 0; i < name.Length; i++)
			{
				char c = name[i];
				if(c == '+' && !escape && (sb.Length == 0 || sb[sb.Length - 1] != '$'))
				{
					nested = true;
					sb.Append('$');
				}
				else if("_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".IndexOf(c) != -1
					|| (c == '.' && !escape && !nested))
				{
					sb.Append(c);
				}
				else
				{
					sb.Append("$$");
					sb.Append(string.Format("{0:X4}", (int)c));
				}
				if(c == '\\')
				{
					escape = !escape;
				}
				else
				{
					escape = false;
				}
			}
			return sb.ToString();
		}

		// NOTE if the name is not a valid mangled type name, no demangling is done and the
		// original string is returned
		// NOTE we don't enforce canonical form, this is not required, because we cannot
		// guarantee it for unprefixed names anyway, so the caller is responsible for
		// ensuring that the original name was in fact the canonical name.
		internal static string DemangleTypeName(string name)
		{
			if(!name.StartsWith(NamePrefix))
			{
				return name.Replace('$', '+');
			}
			System.Text.StringBuilder sb = new System.Text.StringBuilder(name.Length - NamePrefix.Length);
			for(int i = NamePrefix.Length; i < name.Length; i++)
			{
				char c = name[i];
				if(c == '$')
				{
					if(i + 1 < name.Length && name[i + 1] != '$')
					{
						sb.Append('+');
					}
					else
					{
						i++;
						if(i + 5 > name.Length)
						{
							return name;
						}
						int digit0 = "0123456789ABCDEF".IndexOf(name[++i]);
						int digit1 = "0123456789ABCDEF".IndexOf(name[++i]);
						int digit2 = "0123456789ABCDEF".IndexOf(name[++i]);
						int digit3 = "0123456789ABCDEF".IndexOf(name[++i]);
						if(digit0 == -1 || digit1 == -1 || digit2 == -1 || digit3 == -1)
						{
							return name;
						}
						sb.Append((char)((digit0 << 12) + (digit1 << 8) + (digit2 << 4) + digit3));
					}
				}
				else
				{
					sb.Append(c);
				}
			}
			return sb.ToString();
		}

		// TODO from a perf pov it may be better to allow creation of TypeWrappers,
		// but to simply make sure they don't have ClassObject
		internal static bool IsAllowedOutside(Type type)
		{
			// SECURITY we never expose types from IKVM.Runtime, because doing so would lead to a security hole,
			// since the reflection implementation lives inside this assembly, all internal members would
			// be accessible through Java reflection.
#if !FIRST_PASS && !STATIC_COMPILER
			if(type.Assembly == typeof(DotNetTypeWrapper).Assembly)
			{
				return false;
			}
			if(type.Assembly == IKVM.NativeCode.java.lang.SecurityManager.jniAssembly)
			{
				return false;
			}
#endif
			return true;
		}

		// We allow open generic types to be visible to Java code as very limited classes (or interfaces).
		// They are always package private and have the abstract and final modifiers set, this makes them
		// inaccessible and invalid from a Java point of view. The intent is to avoid any usage of these
		// classes. They exist solely for the purpose of stack walking, because the .NET runtime will report
		// open generic types when walking the stack (as a performance optimization). We cannot (reliably) map
		// these classes to their instantiations, so we report the open generic type class instead.
		// Note also that these classes can only be used as a "handle" to the type, they expose no members,
		// don't implement any interfaces and the base class is always object.
		private sealed class OpenGenericTypeWrapper : TypeWrapper
		{
			private readonly Type type;

			private static Modifiers GetModifiers(Type type)
			{
				Modifiers modifiers = Modifiers.Abstract | Modifiers.Final;
				if (type.IsInterface)
				{
					modifiers |= Modifiers.Interface;
				}
				return modifiers;
			}

			internal OpenGenericTypeWrapper(Type type, string name)
				: base(GetModifiers(type), name, type.IsInterface ? null : CoreClasses.java.lang.Object.Wrapper)
			{
				this.type = type;
			}

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get { return null; }
			}

			internal override TypeWrapper[] InnerClasses
			{
				get { return TypeWrapper.EmptyArray; }
			}

			internal override TypeWrapper[] Interfaces
			{
				get { return TypeWrapper.EmptyArray; }
			}

			internal override Type TypeAsTBD
			{
				get { return type; }
			}

			internal override void Finish()
			{
			}

			internal override ClassLoaderWrapper GetClassLoader()
			{
				return ClassLoaderWrapper.GetAssemblyClassLoader(type.Assembly);
			}

			protected override void LazyPublishMembers()
			{
				SetFields(FieldWrapper.EmptyArray);
				SetMethods(MethodWrapper.EmptyArray);
			}
		}

		private sealed class DelegateInnerClassTypeWrapper : TypeWrapper
		{
			private readonly Type fakeType;

			internal DelegateInnerClassTypeWrapper(string name, Type delegateType, ClassLoaderWrapper classLoader)
				: base(Modifiers.Public | Modifiers.Interface | Modifiers.Abstract, name, null)
			{
#if STATIC_COMPILER
				this.fakeType = FakeTypes.GetDelegateType(delegateType);
#elif !FIRST_PASS
				this.fakeType = typeof(ikvm.@@internal.DelegateInterface<>).MakeGenericType(delegateType);
#endif
				MethodInfo invoke = delegateType.GetMethod("Invoke");
				ParameterInfo[] parameters = invoke.GetParameters();
				TypeWrapper[] argTypeWrappers = new TypeWrapper[parameters.Length];
				System.Text.StringBuilder sb = new System.Text.StringBuilder("(");
				for(int i = 0; i < parameters.Length; i++)
				{
					argTypeWrappers[i] = ClassLoaderWrapper.GetWrapperFromType(parameters[i].ParameterType);
					sb.Append(argTypeWrappers[i].SigName);
				}
				TypeWrapper returnType = ClassLoaderWrapper.GetWrapperFromType(invoke.ReturnType);
				sb.Append(")").Append(returnType.SigName);
				MethodWrapper invokeMethod = new DynamicOnlyMethodWrapper(this, "Invoke", sb.ToString(), returnType, argTypeWrappers);
				SetMethods(new MethodWrapper[] { invokeMethod });
				SetFields(FieldWrapper.EmptyArray);
			}

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
				{
					return ClassLoaderWrapper.GetWrapperFromType(fakeType.GetGenericArguments()[0]);
				}
			}

			internal override void Finish()
			{
			}

			internal override ClassLoaderWrapper GetClassLoader()
			{
				return DeclaringTypeWrapper.GetClassLoader();
			}

			internal override TypeWrapper[] InnerClasses
			{
				get
				{
					return TypeWrapper.EmptyArray;
				}
			}

			internal override TypeWrapper[] Interfaces
			{
				get
				{
					return TypeWrapper.EmptyArray;
				}
			}

			internal override Type TypeAsTBD
			{
				get
				{
					return fakeType;
				}
			}

			internal override bool IsFastClassLiteralSafe
			{
				get { return true; }
			}
		}

		private class DynamicOnlyMethodWrapper : MethodWrapper, ICustomInvoke
		{
			internal DynamicOnlyMethodWrapper(TypeWrapper declaringType, string name, string sig, TypeWrapper returnType, TypeWrapper[] parameterTypes)
				: base(declaringType, name, sig, null, returnType, parameterTypes, Modifiers.Public | Modifiers.Abstract, MemberFlags.None)
			{
			}

			internal override bool IsDynamicOnly
			{
				get
				{
					return true;
				}
			}

#if !STATIC_COMPILER && !FIRST_PASS
			object ICustomInvoke.Invoke(object obj, object[] args, ikvm.@@internal.CallerID callerID)
			{
				// a DynamicOnlyMethodWrapper is an interface method, but now that we've been called on an actual object instance,
				// we can resolve to a real method and call that instead
				TypeWrapper tw = TypeWrapper.FromClass(NativeCode.ikvm.runtime.Util.getClassFromObject(obj));
				MethodWrapper mw = tw.GetMethodWrapper(this.Name, this.Signature, true);
				if(mw == null)
				{
					throw new java.lang.AbstractMethodError(tw.Name + "." + this.Name + this.Signature);
				}
				java.lang.reflect.Method m = (java.lang.reflect.Method)mw.ToMethodOrConstructor(true);
				m.@@override = true;
				return m.invoke(obj, args, callerID);
			}
#endif // !STATIC_COMPILER && !FIRST_PASS
		}

		private sealed class EnumEnumTypeWrapper : TypeWrapper
		{
			private readonly Type fakeType;

			internal EnumEnumTypeWrapper(string name, Type enumType)
				: base(Modifiers.Public | Modifiers.Enum | Modifiers.Final, name, ClassLoaderWrapper.LoadClassCritical("java.lang.Enum"))
			{
#if STATIC_COMPILER
				this.fakeType = FakeTypes.GetEnumType(enumType);
#elif !FIRST_PASS
				if(enumType.Assembly.ReflectionOnly)
				{
					TypeWrapper decl = ClassLoaderWrapper.GetWrapperFromType(enumType);
					TypeWrapperFactory factory = ClassLoaderWrapper.GetBootstrapClassLoader().GetTypeWrapperFactory();
					string basename = "<ReflectionOnlyType>" + enumType.FullName;
					name = basename;
					int index = 0;
					while(!factory.ReserveName(name))
					{
						name = basename + (++index);
					}
					enumType = factory.ModuleBuilder.DefineEnum(name, TypeAttributes.Public, typeof(int)).CreateType();
					ClassLoaderWrapper.GetBootstrapClassLoader().SetWrapperForType(enumType, decl);
				}
				this.fakeType = typeof(ikvm.@@internal.EnumEnum<>).MakeGenericType(enumType);
#endif
			}

			internal object GetUnspecifiedValue()
			{
				return ((EnumFieldWrapper)GetFieldWrapper("__unspecified", this.SigName)).GetValue();
			}

			private class EnumFieldWrapper : FieldWrapper
			{
				private readonly int ordinal;
				private object val;

				internal EnumFieldWrapper(TypeWrapper tw, string name, int ordinal)
					: base(tw, tw, name, tw.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final | Modifiers.Enum, null, MemberFlags.None)
				{
					this.ordinal = ordinal;
				}

				internal object GetValue()
				{
					if(val == null)
					{
						System.Threading.Interlocked.CompareExchange(ref val, Activator.CreateInstance(this.DeclaringType.TypeAsTBD, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, new object[] { this.Name, ordinal }, null), null);
					}
					return val;
				}

				protected override void EmitGetImpl(CodeEmitter ilgen)
				{
					// TODO we should throw a NoSuchFieldError if at runtime we find out that the "field" doesn't exist
					ilgen.LazyEmitLoadClass(this.DeclaringType);
					ilgen.Emit(OpCodes.Ldstr, this.Name);
					this.DeclaringType.BaseTypeWrapper.GetMethodWrapper("valueOf", "(Ljava.lang.Class;Ljava.lang.String;)Ljava.lang.Enum;", false).EmitCall(ilgen);
					ilgen.Emit(OpCodes.Castclass, this.DeclaringType.TypeAsTBD);
				}

				protected override void EmitSetImpl(CodeEmitter ilgen)
				{
				}
			}

			private class EnumValuesMethodWrapper : MethodWrapper, ICustomInvoke
			{
				internal EnumValuesMethodWrapper(TypeWrapper declaringType)
					: base(declaringType, "values", "()[" + declaringType.SigName, null, declaringType.MakeArrayType(1), TypeWrapper.EmptyArray, Modifiers.Public | Modifiers.Static, MemberFlags.None)
				{
				}

				internal override bool IsDynamicOnly
				{
					get
					{
						return true;
					}
				}

#if !STATIC_COMPILER && !FIRST_PASS
				object ICustomInvoke.Invoke(object obj, object[] args, ikvm.@@internal.CallerID callerID)
				{
					FieldWrapper[] values = this.DeclaringType.GetFields();
					object[] array = (object[])Array.CreateInstance(this.DeclaringType.TypeAsArrayType, values.Length);
					for(int i = 0; i < values.Length; i++)
					{
						array[i] = ((EnumFieldWrapper)values[i]).GetValue();
					}
					return array;
				}
#endif // !STATIC_COMPILER && !FIRST_PASS
			}

			private class EnumValueOfMethodWrapper : MethodWrapper, ICustomInvoke
			{
				internal EnumValueOfMethodWrapper(TypeWrapper declaringType)
					: base(declaringType, "valueOf", "(Ljava.lang.String;)" + declaringType.SigName, null, declaringType, new TypeWrapper[] { CoreClasses.java.lang.String.Wrapper }, Modifiers.Public | Modifiers.Static, MemberFlags.None)
				{
				}

				internal override bool IsDynamicOnly
				{
					get
					{
						return true;
					}
				}

#if !STATIC_COMPILER && !FIRST_PASS
				object ICustomInvoke.Invoke(object obj, object[] args, ikvm.@@internal.CallerID callerID)
				{
					FieldWrapper[] values = this.DeclaringType.GetFields();
					for(int i = 0; i < values.Length; i++)
					{
						if(values[i].Name.Equals(args[0]))
						{
							return ((EnumFieldWrapper)values[i]).GetValue();
						}
					}
					throw new java.lang.IllegalArgumentException("" + args[0]);
				}
#endif // !STATIC_COMPILER && !FIRST_PASS
			}

			protected override void LazyPublishMembers()
			{
				List<FieldWrapper> fields = new List<FieldWrapper>();
				int ordinal = 0;
				foreach(FieldInfo field in this.DeclaringTypeWrapper.TypeAsTBD.GetFields(BindingFlags.Static | BindingFlags.Public))
				{
					if(field.IsLiteral)
					{
						fields.Add(new EnumFieldWrapper(this, field.Name, ordinal++));
					}
				}
				// TODO if the enum already has an __unspecified value, rename this one
				fields.Add(new EnumFieldWrapper(this, "__unspecified", ordinal++));
				SetFields(fields.ToArray());
				SetMethods(new MethodWrapper[] { new EnumValuesMethodWrapper(this), new EnumValueOfMethodWrapper(this) });
				base.LazyPublishMembers();
			}

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
				{
					return ClassLoaderWrapper.GetWrapperFromType(fakeType.GetGenericArguments()[0]);
				}
			}

			internal override void Finish()
			{
			}

			internal override ClassLoaderWrapper GetClassLoader()
			{
				return DeclaringTypeWrapper.GetClassLoader();
			}

			internal override TypeWrapper[] InnerClasses
			{
				get
				{
					return TypeWrapper.EmptyArray;
				}
			}

			internal override TypeWrapper[] Interfaces
			{
				get
				{
					return TypeWrapper.EmptyArray;
				}
			}

			internal override Type TypeAsTBD
			{
				get
				{
					return fakeType;
				}
			}

			internal override bool IsFastClassLiteralSafe
			{
				get { return true; }
			}
		}

		private abstract class AttributeAnnotationTypeWrapperBase : TypeWrapper
		{
			internal AttributeAnnotationTypeWrapperBase(string name)
				: base(Modifiers.Public | Modifiers.Interface | Modifiers.Abstract | Modifiers.Annotation, name, null)
			{
			}

			internal sealed override void Finish()
			{
			}

			internal sealed override ClassLoaderWrapper GetClassLoader()
			{
				return DeclaringTypeWrapper.GetClassLoader();
			}

			internal sealed override TypeWrapper[] Interfaces
			{
				get
				{
					return new TypeWrapper[] { ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.annotation.Annotation") };
				}
			}

			internal sealed override bool IsFastClassLiteralSafe
			{
				get { return true; }
			}
		}

		private sealed class AttributeAnnotationTypeWrapper : AttributeAnnotationTypeWrapperBase
		{
			private readonly Type fakeType;
			private readonly Type attributeType;
			private TypeWrapper[] innerClasses;

			internal AttributeAnnotationTypeWrapper(string name, Type attributeType)
				: base(name)
			{
#if STATIC_COMPILER
				this.fakeType = FakeTypes.GetAttributeType(attributeType);
#elif !FIRST_PASS
				this.fakeType = typeof(ikvm.@@internal.AttributeAnnotation<>).MakeGenericType(attributeType);
#endif
				this.attributeType = attributeType;
			}

			private static bool IsSupportedType(Type type)
			{
				// Java annotations only support one-dimensional arrays
				if(type.IsArray)
				{
					type = type.GetElementType();
				}
				return type == typeof(string)
					|| type == typeof(bool)
					|| type == typeof(byte)
					|| type == typeof(char)
					|| type == typeof(short)
					|| type == typeof(int)
					|| type == typeof(float)
					|| type == typeof(long)
					|| type == typeof(double)
					|| type == typeof(Type)
					|| type.IsEnum;
			}

			internal static void GetConstructors(Type type, out ConstructorInfo defCtor, out ConstructorInfo singleOneArgCtor)
			{
				defCtor = null;
				int oneArgCtorCount = 0;
				ConstructorInfo oneArgCtor = null;
				foreach(ConstructorInfo ci in type.GetConstructors(BindingFlags.Public | BindingFlags.Instance))
				{
					ParameterInfo[] args = ci.GetParameters();
					if(args.Length == 0)
					{
						defCtor = ci;
					}
					else if(args.Length == 1)
					{
						// HACK special case for p/invoke StructLayout attribute
						if(type == typeof(System.Runtime.InteropServices.StructLayoutAttribute) && args[0].ParameterType == typeof(short))
						{
							// we skip this constructor, so that the other one will be visible
							continue;
						}
						if(IsSupportedType(args[0].ParameterType))
						{
							oneArgCtor = ci;
							oneArgCtorCount++;
						}
						else
						{
							// set to two to make sure we don't see the oneArgCtor as viable
							oneArgCtorCount = 2;
						}
					}
				}
				singleOneArgCtor = oneArgCtorCount == 1 ? oneArgCtor : null;
			}

			private class AttributeAnnotationMethodWrapper : DynamicOnlyMethodWrapper
			{
				private bool optional;

				internal AttributeAnnotationMethodWrapper(AttributeAnnotationTypeWrapper tw, string name, Type type, bool optional)
					: this(tw, name, MapType(type, false), optional)
				{
				}

				private static TypeWrapper MapType(Type type, bool isArray)
				{
					if(type == typeof(string))
					{
						return CoreClasses.java.lang.String.Wrapper;
					}
					else if(type == typeof(bool))
					{
						return PrimitiveTypeWrapper.BOOLEAN;
					}
					else if(type == typeof(byte))
					{
						return PrimitiveTypeWrapper.BYTE;
					}
					else if(type == typeof(char))
					{
						return PrimitiveTypeWrapper.CHAR;
					}
					else if(type == typeof(short))
					{
						return PrimitiveTypeWrapper.SHORT;
					}
					else if(type == typeof(int))
					{
						return PrimitiveTypeWrapper.INT;
					}
					else if(type == typeof(float))
					{
						return PrimitiveTypeWrapper.FLOAT;
					}
					else if(type == typeof(long))
					{
						return PrimitiveTypeWrapper.LONG;
					}
					else if(type == typeof(double))
					{
						return PrimitiveTypeWrapper.DOUBLE;
					}
					else if(type == typeof(Type))
					{
						return CoreClasses.java.lang.Class.Wrapper;
					}
					else if (type.IsEnum)
					{
						foreach (TypeWrapper tw in ClassLoaderWrapper.GetWrapperFromType(type).InnerClasses)
						{
							if (tw is EnumEnumTypeWrapper)
							{
								if (!isArray && AttributeHelper.IsDefined(type, typeof(FlagsAttribute)))
								{
									return tw.MakeArrayType(1);
								}
								return tw;
							}
						}
						throw new InvalidOperationException();
					}
					else if(!isArray && type.IsArray)
					{
						return MapType(type.GetElementType(), true).MakeArrayType(1);
					}
					else
					{
						throw new NotImplementedException();
					}
				}

				private AttributeAnnotationMethodWrapper(AttributeAnnotationTypeWrapper tw, string name, TypeWrapper returnType, bool optional)
					: base(tw, name, "()" + returnType.SigName, returnType, TypeWrapper.EmptyArray)
				{
					this.optional = optional;
				}

				internal bool IsOptional
				{
					get
					{
						return optional;
					}
				}
			}

			protected override void LazyPublishMembers()
			{
				List<MethodWrapper> methods = new List<MethodWrapper>();
				ConstructorInfo defCtor;
				ConstructorInfo singleOneArgCtor;
				GetConstructors(attributeType, out defCtor, out singleOneArgCtor);
				if(singleOneArgCtor != null)
				{
					methods.Add(new AttributeAnnotationMethodWrapper(this, "value", singleOneArgCtor.GetParameters()[0].ParameterType, defCtor != null));
				}
				foreach(PropertyInfo pi in attributeType.GetProperties(BindingFlags.Instance | BindingFlags.Public))
				{
					if(pi.CanRead && pi.CanWrite && IsSupportedType(pi.PropertyType))
					{
						methods.Add(new AttributeAnnotationMethodWrapper(this, pi.Name, pi.PropertyType, true));
					}
				}
				foreach(FieldInfo fi in attributeType.GetFields(BindingFlags.Public | BindingFlags.Instance))
				{
					// TODO add other field validations to make sure it is appropriate
					if(!fi.IsInitOnly && IsSupportedType(fi.FieldType))
					{
						methods.Add(new AttributeAnnotationMethodWrapper(this, fi.Name, fi.FieldType, true));
					}
				}
				SetMethods(methods.ToArray());
				base.LazyPublishMembers();
			}

#if !STATIC_COMPILER && !FIRST_PASS
			internal override object GetAnnotationDefault(MethodWrapper mw)
			{
				if(((AttributeAnnotationMethodWrapper)mw).IsOptional)
				{
					if (mw.ReturnType == PrimitiveTypeWrapper.BOOLEAN)
					{
						return java.lang.Boolean.FALSE;
					}
					else if(mw.ReturnType == PrimitiveTypeWrapper.BYTE)
					{
						return java.lang.Byte.valueOf((byte)0);
					}
					else if(mw.ReturnType == PrimitiveTypeWrapper.CHAR)
					{
						return java.lang.Character.valueOf((char)0);
					}
					else if(mw.ReturnType == PrimitiveTypeWrapper.SHORT)
					{
						return java.lang.Short.valueOf((short)0);
					}
					else if(mw.ReturnType == PrimitiveTypeWrapper.INT)
					{
						return java.lang.Integer.valueOf(0);
					}
					else if(mw.ReturnType == PrimitiveTypeWrapper.FLOAT)
					{
						return java.lang.Float.valueOf(0F);
					}
					else if(mw.ReturnType == PrimitiveTypeWrapper.LONG)
					{
						return java.lang.Long.valueOf(0L);
					}
					else if(mw.ReturnType == PrimitiveTypeWrapper.DOUBLE)
					{
						return java.lang.Double.valueOf(0D);
					}
					else if(mw.ReturnType == CoreClasses.java.lang.String.Wrapper)
					{
						return "";
					}
					else if(mw.ReturnType == CoreClasses.java.lang.Class.Wrapper)
					{
						return (java.lang.Class)typeof(ikvm.@@internal.__unspecified);
					}
					else if(mw.ReturnType is EnumEnumTypeWrapper)
					{
						EnumEnumTypeWrapper eetw = (EnumEnumTypeWrapper)mw.ReturnType;
						return eetw.GetUnspecifiedValue();
					}
					else if(mw.ReturnType.IsArray)
					{
						return Array.CreateInstance(mw.ReturnType.TypeAsArrayType, 0);
					}
				}
				return null;
			}
#endif // !STATIC_COMPILER && !FIRST_PASS

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
				{
					return ClassLoaderWrapper.GetWrapperFromType(attributeType);
				}
			}

			internal override Type TypeAsTBD
			{
				get
				{
					return fakeType;
				}
			}

			private sealed class ReturnValueAnnotationTypeWrapper : AttributeAnnotationTypeWrapperBase
			{
				private readonly Type fakeType;
				private readonly AttributeAnnotationTypeWrapper declaringType;

				internal ReturnValueAnnotationTypeWrapper(AttributeAnnotationTypeWrapper declaringType)
					: base(declaringType.Name + AttributeAnnotationReturnValueSuffix)
				{
#if STATIC_COMPILER
					this.fakeType = FakeTypes.GetAttributeReturnValueType(declaringType.attributeType);
#elif !FIRST_PASS
					this.fakeType = typeof(ikvm.@@internal.AttributeAnnotationReturnValue<>).MakeGenericType(declaringType.attributeType);
#endif
					this.declaringType = declaringType;
				}

				protected override void LazyPublishMembers()
				{
					TypeWrapper tw = declaringType;
					if(declaringType.GetAttributeUsage().AllowMultiple)
					{
						tw = tw.MakeArrayType(1);
					}
					SetMethods(new MethodWrapper[] { new DynamicOnlyMethodWrapper(this, "value", "()" + tw.SigName, tw, TypeWrapper.EmptyArray) });
					SetFields(FieldWrapper.EmptyArray);
				}

				internal override TypeWrapper DeclaringTypeWrapper
				{
					get
					{
						return declaringType;
					}
				}

				internal override TypeWrapper[] InnerClasses
				{
					get
					{
						return TypeWrapper.EmptyArray;
					}
				}

				internal override Type TypeAsTBD
				{
					get
					{
						return fakeType;
					}
				}

#if !STATIC_COMPILER && !FIRST_PASS
				internal override object[] GetDeclaredAnnotations()
				{
					java.util.HashMap targetMap = new java.util.HashMap();
					targetMap.put("value", new java.lang.annotation.ElementType[] { java.lang.annotation.ElementType.METHOD });
					java.util.HashMap retentionMap = new java.util.HashMap();
					retentionMap.put("value", java.lang.annotation.RetentionPolicy.RUNTIME);
					return new object[] {
						java.lang.reflect.Proxy.newProxyInstance(null, new java.lang.Class[] { typeof(java.lang.annotation.Target) }, new sun.reflect.annotation.AnnotationInvocationHandler(typeof(java.lang.annotation.Target), targetMap)),
						java.lang.reflect.Proxy.newProxyInstance(null, new java.lang.Class[] { typeof(java.lang.annotation.Retention) }, new sun.reflect.annotation.AnnotationInvocationHandler(typeof(java.lang.annotation.Retention), retentionMap))
					};
				}
#endif

				private class ReturnValueAnnotation : Annotation
				{
					private AttributeAnnotationTypeWrapper type;

					internal ReturnValueAnnotation(AttributeAnnotationTypeWrapper type)
					{
						this.type = type;
					}

					internal override void ApplyReturnValue(ClassLoaderWrapper loader, MethodBuilder mb, ref ParameterBuilder pb, object annotation)
					{
						// TODO make sure the descriptor is correct
						Annotation ann = type.Annotation;
						object[] arr = (object[])annotation;
						for(int i = 2; i < arr.Length; i += 2)
						{
							if("value".Equals(arr[i]))
							{
								if(pb == null)
								{
									pb = mb.DefineParameter(0, ParameterAttributes.None, null);
								}
								object[] value = (object[])arr[i + 1];
								if(value[0].Equals(AnnotationDefaultAttribute.TAG_ANNOTATION))
								{
									ann.Apply(loader, pb, value);
								}
								else
								{
									for(int j = 1; j < value.Length; j++)
									{
										ann.Apply(loader, pb, value[j]);
									}
								}
								break;
							}
						}
					}

					internal override void Apply(ClassLoaderWrapper loader, MethodBuilder mb, object annotation)
					{
					}

					internal override void Apply(ClassLoaderWrapper loader, AssemblyBuilder ab, object annotation)
					{
					}

					internal override void Apply(ClassLoaderWrapper loader, ConstructorBuilder cb, object annotation)
					{
					}

					internal override void Apply(ClassLoaderWrapper loader, FieldBuilder fb, object annotation)
					{
					}

					internal override void Apply(ClassLoaderWrapper loader, ParameterBuilder pb, object annotation)
					{
					}

					internal override void Apply(ClassLoaderWrapper loader, TypeBuilder tb, object annotation)
					{
					}

					internal override void Apply(ClassLoaderWrapper loader, PropertyBuilder pb, object annotation)
					{
					}
				}

				internal override Annotation Annotation
				{
					get
					{
						return new ReturnValueAnnotation(declaringType);
					}
				}
			}

			private sealed class MultipleAnnotationTypeWrapper : AttributeAnnotationTypeWrapperBase
			{
				private readonly Type fakeType;
				private readonly AttributeAnnotationTypeWrapper declaringType;

				internal MultipleAnnotationTypeWrapper(AttributeAnnotationTypeWrapper declaringType)
					: base(declaringType.Name + AttributeAnnotationMultipleSuffix)
				{
#if STATIC_COMPILER
					this.fakeType = FakeTypes.GetAttributeMultipleType(declaringType.attributeType);
#elif !FIRST_PASS
					this.fakeType = typeof(ikvm.@@internal.AttributeAnnotationMultiple<>).MakeGenericType(declaringType.attributeType);
#endif
					this.declaringType = declaringType;
				}

				protected override void LazyPublishMembers()
				{
					TypeWrapper tw = declaringType.MakeArrayType(1);
					SetMethods(new MethodWrapper[] { new DynamicOnlyMethodWrapper(this, "value", "()" + tw.SigName, tw, TypeWrapper.EmptyArray) });
					SetFields(FieldWrapper.EmptyArray);
				}

				internal override TypeWrapper DeclaringTypeWrapper
				{
					get
					{
						return declaringType;
					}
				}

				internal override TypeWrapper[] InnerClasses
				{
					get
					{
						return TypeWrapper.EmptyArray;
					}
				}

				internal override Type TypeAsTBD
				{
					get
					{
						return fakeType;
					}
				}

#if !STATIC_COMPILER
				internal override object[] GetDeclaredAnnotations()
				{
					return declaringType.GetDeclaredAnnotations();
				}
#endif

				private class MultipleAnnotation : Annotation
				{
					private AttributeAnnotationTypeWrapper type;

					internal MultipleAnnotation(AttributeAnnotationTypeWrapper type)
					{
						this.type = type;
					}

					private static object[] UnwrapArray(object annotation)
					{
						// TODO make sure the descriptor is correct
						object[] arr = (object[])annotation;
						for (int i = 2; i < arr.Length; i += 2)
						{
							if ("value".Equals(arr[i]))
							{
								object[] value = (object[])arr[i + 1];
								object[] rc = new object[value.Length - 1];
								Array.Copy(value, 1, rc, 0, rc.Length);
								return rc;
							}
						}
						return new object[0];
					}

					internal override void Apply(ClassLoaderWrapper loader, MethodBuilder mb, object annotation)
					{
						Annotation annot = type.Annotation;
						foreach(object ann in UnwrapArray(annotation))
						{
							annot.Apply(loader, mb, ann);
						}
					}

					internal override void Apply(ClassLoaderWrapper loader, AssemblyBuilder ab, object annotation)
					{
						Annotation annot = type.Annotation;
						foreach (object ann in UnwrapArray(annotation))
						{
							annot.Apply(loader, ab, ann);
						}
					}

					internal override void Apply(ClassLoaderWrapper loader, ConstructorBuilder cb, object annotation)
					{
						Annotation annot = type.Annotation;
						foreach (object ann in UnwrapArray(annotation))
						{
							annot.Apply(loader, cb, ann);
						}
					}

					internal override void Apply(ClassLoaderWrapper loader, FieldBuilder fb, object annotation)
					{
						Annotation annot = type.Annotation;
						foreach (object ann in UnwrapArray(annotation))
						{
							annot.Apply(loader, fb, ann);
						}
					}

					internal override void Apply(ClassLoaderWrapper loader, ParameterBuilder pb, object annotation)
					{
						Annotation annot = type.Annotation;
						foreach (object ann in UnwrapArray(annotation))
						{
							annot.Apply(loader, pb, ann);
						}
					}

					internal override void Apply(ClassLoaderWrapper loader, TypeBuilder tb, object annotation)
					{
						Annotation annot = type.Annotation;
						foreach (object ann in UnwrapArray(annotation))
						{
							annot.Apply(loader, tb, ann);
						}
					}

					internal override void Apply(ClassLoaderWrapper loader, PropertyBuilder pb, object annotation)
					{
						Annotation annot = type.Annotation;
						foreach (object ann in UnwrapArray(annotation))
						{
							annot.Apply(loader, pb, ann);
						}
					}
				}

				internal override Annotation Annotation
				{
					get
					{
						return new MultipleAnnotation(declaringType);
					}
				}
			}

			internal override TypeWrapper[] InnerClasses
			{
				get
				{
					lock(this)
					{
						if(innerClasses == null)
						{
							List<TypeWrapper> list = new List<TypeWrapper>();
							AttributeUsageAttribute attr = GetAttributeUsage();
							if((attr.ValidOn & AttributeTargets.ReturnValue) != 0)
							{
								list.Add(GetClassLoader().RegisterInitiatingLoader(new ReturnValueAnnotationTypeWrapper(this)));
							}
							if(attr.AllowMultiple)
							{
								list.Add(GetClassLoader().RegisterInitiatingLoader(new MultipleAnnotationTypeWrapper(this)));
							}
							innerClasses = list.ToArray();
						}
					}
					return innerClasses;
				}
			}

			internal override bool IsFakeTypeContainer
			{
				get
				{
					return true;
				}
			}

			private AttributeUsageAttribute GetAttributeUsage()
			{
				AttributeTargets validOn = AttributeTargets.All;
				bool allowMultiple = false;
				bool inherited = true;
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(attributeType))
				{
					if(cad.Constructor.DeclaringType == typeof(AttributeUsageAttribute))
					{
						if(cad.ConstructorArguments.Count == 1 && cad.ConstructorArguments[0].ArgumentType == typeof(AttributeTargets))
						{
							validOn = (AttributeTargets)cad.ConstructorArguments[0].Value;
						}
						foreach(CustomAttributeNamedArgument cana in cad.NamedArguments)
						{
							if (cana.MemberInfo.Name == "AllowMultiple")
							{
								allowMultiple = (bool)cana.TypedValue.Value;
							}
							else if(cana.MemberInfo.Name == "Inherited")
							{
								inherited = (bool)cana.TypedValue.Value;
							}
						}
					}
				}
				AttributeUsageAttribute attr = new AttributeUsageAttribute(validOn);
				attr.AllowMultiple = allowMultiple;
				attr.Inherited = inherited;
				return attr;
			}

#if !STATIC_COMPILER && !FIRST_PASS
			internal override object[] GetDeclaredAnnotations()
			{
				// note that AttributeUsageAttribute.Inherited does not map to java.lang.annotation.Inherited
				AttributeTargets validOn = GetAttributeUsage().ValidOn;
				List<java.lang.annotation.ElementType> targets = new List<java.lang.annotation.ElementType>();
				if ((validOn & (AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Delegate | AttributeTargets.Assembly)) != 0)
				{
					targets.Add(java.lang.annotation.ElementType.TYPE);
				}
				if ((validOn & AttributeTargets.Constructor) != 0)
				{
					targets.Add(java.lang.annotation.ElementType.CONSTRUCTOR);
				}
				if ((validOn & AttributeTargets.Field) != 0)
				{
					targets.Add(java.lang.annotation.ElementType.FIELD);
				}
				if ((validOn & AttributeTargets.Method) != 0)
				{
					targets.Add(java.lang.annotation.ElementType.METHOD);
				}
				if ((validOn & AttributeTargets.Parameter) != 0)
				{
					targets.Add(java.lang.annotation.ElementType.PARAMETER);
				}
				java.util.HashMap targetMap = new java.util.HashMap();
				targetMap.put("value", targets.ToArray());
				java.util.HashMap retentionMap = new java.util.HashMap();
				retentionMap.put("value", java.lang.annotation.RetentionPolicy.RUNTIME);
				return new object[] {
					java.lang.reflect.Proxy.newProxyInstance(null, new java.lang.Class[] { typeof(java.lang.annotation.Target) }, new sun.reflect.annotation.AnnotationInvocationHandler(typeof(java.lang.annotation.Target), targetMap)),
					java.lang.reflect.Proxy.newProxyInstance(null, new java.lang.Class[] { typeof(java.lang.annotation.Retention) }, new sun.reflect.annotation.AnnotationInvocationHandler(typeof(java.lang.annotation.Retention), retentionMap))
				};
			}
#endif

			private class AttributeAnnotation : Annotation
			{
				private Type type;

				internal AttributeAnnotation(Type type)
				{
					this.type = type;
				}

				private CustomAttributeBuilder MakeCustomAttributeBuilder(ClassLoaderWrapper loader, object annotation)
				{
					object[] arr = (object[])annotation;
					ConstructorInfo defCtor;
					ConstructorInfo singleOneArgCtor;
					object ctorArg = null;
					GetConstructors(type, out defCtor, out singleOneArgCtor);
					List<PropertyInfo> properties = new List<PropertyInfo>();
					List<object> propertyValues = new List<object>();
					List<FieldInfo> fields = new List<FieldInfo>();
					List<object> fieldValues = new List<object>();
					for(int i = 2; i < arr.Length; i += 2)
					{
						string name = (string)arr[i];
						if(name == "value" && singleOneArgCtor != null)
						{
							ctorArg = ConvertValue(loader, singleOneArgCtor.GetParameters()[0].ParameterType, arr[i + 1]);
						}
						else
						{
							PropertyInfo pi = type.GetProperty(name, BindingFlags.Public | BindingFlags.Instance);
							if(pi != null)
							{
								properties.Add(pi);
								propertyValues.Add(ConvertValue(loader, pi.PropertyType, arr[i + 1]));
							}
							else
							{
								FieldInfo fi = type.GetField(name, BindingFlags.Public | BindingFlags.Instance);
								if(fi != null)
								{
									fields.Add(fi);
									fieldValues.Add(ConvertValue(loader, fi.FieldType, arr[i + 1]));
								}
							}
						}
					}
					if(ctorArg == null && defCtor == null)
					{
						// TODO required argument is missing
					}
					return new CustomAttributeBuilder(ctorArg == null ? defCtor : singleOneArgCtor,
						ctorArg == null ? new object[0] : new object[] { ctorArg },
						properties.ToArray(),
						propertyValues.ToArray(),
						fields.ToArray(),
						fieldValues.ToArray());
				}

				internal override void Apply(ClassLoaderWrapper loader, TypeBuilder tb, object annotation)
				{
					if(type == typeof(System.Runtime.InteropServices.StructLayoutAttribute) && tb.BaseType != typeof(object))
					{
						// we have to handle this explicitly, because if we apply an illegal StructLayoutAttribute,
						// TypeBuilder.CreateType() will later on throw an exception.
						Tracer.Error(Tracer.Runtime, "StructLayoutAttribute cannot be applied to {0}, because it does not directly extend cli.System.Object", tb.FullName);
						return;
					}
					if(type.IsSubclassOf(typeof(SecurityAttribute)))
					{
						SecurityAction action;
						PermissionSet permSet;
						if(MakeDeclSecurity(type, annotation, out action, out permSet))
						{
							tb.AddDeclarativeSecurity(action, permSet);
						}
					}
					else
					{
						tb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, ConstructorBuilder cb, object annotation)
				{
					if(type.IsSubclassOf(typeof(SecurityAttribute)))
					{
						SecurityAction action;
						PermissionSet permSet;
						if(MakeDeclSecurity(type, annotation, out action, out permSet))
						{
							cb.AddDeclarativeSecurity(action, permSet);
						}
					}
					else
					{
						cb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, MethodBuilder mb, object annotation)
				{
					if(type.IsSubclassOf(typeof(SecurityAttribute)))
					{
						SecurityAction action;
						PermissionSet permSet;
						if(MakeDeclSecurity(type, annotation, out action, out permSet))
						{
							mb.AddDeclarativeSecurity(action, permSet);
						}
					}
					else
					{
#if CLASSGC
						if(JVM.classUnloading && type == typeof(System.Runtime.InteropServices.DllImportAttribute))
						{
							// TODO PInvoke is not supported in RunAndCollect assemblies,
							// so we ignore the attribute.
							// We could forward the PInvoke to a non RunAndCollect assembly, but for now we don't bother.
							return;
						}
#endif
						mb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, FieldBuilder fb, object annotation)
				{
					if(type.IsSubclassOf(typeof(SecurityAttribute)))
					{
						// you can't add declarative security to a field
					}
					else
					{
						fb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, ParameterBuilder pb, object annotation)
				{
					if(type.IsSubclassOf(typeof(SecurityAttribute)))
					{
						// you can't add declarative security to a parameter
					}
					else
					{
						pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, AssemblyBuilder ab, object annotation)
				{
					if(type.IsSubclassOf(typeof(SecurityAttribute)))
					{
						// you can only add declarative security to an assembly when defining the assembly
					}
					else
					{
						ab.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, PropertyBuilder pb, object annotation)
				{
					if(type.IsSubclassOf(typeof(SecurityAttribute)))
					{
						// you can't add declarative security to a property
					}
					else
					{
						pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
				}
			}

			internal override Annotation Annotation
			{
				get
				{
					return new AttributeAnnotation(attributeType);
				}
			}
		}

		internal static TypeWrapper GetWrapperFromDotNetType(Type type)
		{
			TypeWrapper tw;
			lock (types)
			{
				types.TryGetValue(type, out tw);
			}
			if (tw == null)
			{
				tw = ClassLoaderWrapper.GetAssemblyClassLoader(type.Assembly).GetWrapperFromAssemblyType(type);
				lock (types)
				{
					types[type] = tw;
				}
			}
			return tw;
		}

		private static TypeWrapper GetBaseTypeWrapper(Type type)
		{
			if(type.IsInterface)
			{
				return null;
			}
			else if(ClassLoaderWrapper.IsRemappedType(type))
			{
				// Remapped types extend their alter ego
				// (e.g. cli.System.Object must appear to be derived from java.lang.Object)
				// except when they're sealed, of course.
				if(type.IsSealed)
				{
					return CoreClasses.java.lang.Object.Wrapper;
				}
				return ClassLoaderWrapper.GetWrapperFromType(type);
			}
			else if(ClassLoaderWrapper.IsRemappedType(type.BaseType))
			{
				return GetWrapperFromDotNetType(type.BaseType);
			}
			else
			{
				return ClassLoaderWrapper.GetWrapperFromType(type.BaseType);
			}
		}

		internal static TypeWrapper Create(Type type, string name)
		{
			if (type.ContainsGenericParameters)
			{
				return new OpenGenericTypeWrapper(type, name);
			}
			else
			{
				return new DotNetTypeWrapper(type, name);
			}
		}

		private DotNetTypeWrapper(Type type, string name)
			: base(GetModifiers(type), name, GetBaseTypeWrapper(type))
		{
			Debug.Assert(!(type.IsByRef), type.FullName);
			Debug.Assert(!(type.IsPointer), type.FullName);
			Debug.Assert(!(type.Name.EndsWith("[]")), type.FullName);
			Debug.Assert(!(type is TypeBuilder), type.FullName);
			Debug.Assert(!(AttributeHelper.IsJavaModule(type.Module)));

			this.type = type;
		}

		internal override ClassLoaderWrapper GetClassLoader()
		{
			if(type.IsGenericType)
			{
				return ClassLoaderWrapper.GetGenericClassLoader(this);
			}
			return ClassLoaderWrapper.GetAssemblyClassLoader(type.Assembly);
		}

		private sealed class MulticastDelegateCtorMethodWrapper : MethodWrapper
		{
			internal MulticastDelegateCtorMethodWrapper(TypeWrapper declaringType)
				: base(declaringType, "<init>", "()V", null, PrimitiveTypeWrapper.VOID, TypeWrapper.EmptyArray, Modifiers.Protected, MemberFlags.None)
			{
			}
		}

		private class DelegateMethodWrapper : MethodWrapper
		{
			private ConstructorInfo delegateConstructor;
			private DelegateInnerClassTypeWrapper iface;

			internal DelegateMethodWrapper(TypeWrapper declaringType, DelegateInnerClassTypeWrapper iface)
				: base(declaringType, "<init>", "(" + iface.SigName + ")V", null, PrimitiveTypeWrapper.VOID, new TypeWrapper[] { iface }, Modifiers.Public, MemberFlags.None)
			{
				this.delegateConstructor = declaringType.TypeAsTBD.GetConstructor(new Type[] { typeof(object), typeof(IntPtr) });
				this.iface = iface;
			}

			internal override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
			{
				TypeWrapper targetType = ma == null ? null : ma.GetStackTypeWrapper(opcodeIndex, 0);
				if(targetType == null || targetType.IsInterface)
				{
					MethodInfo createDelegate = typeof(Delegate).GetMethod("CreateDelegate", new Type[] { typeof(Type), typeof(object), typeof(string) });
					LocalBuilder targetObj = ilgen.DeclareLocal(typeof(object));
					ilgen.Emit(OpCodes.Stloc, targetObj);
					ilgen.Emit(OpCodes.Ldtoken, delegateConstructor.DeclaringType);
					ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) }));
					ilgen.Emit(OpCodes.Ldloc, targetObj);
					ilgen.Emit(OpCodes.Ldstr, "Invoke");
					ilgen.Emit(OpCodes.Call, createDelegate);
					ilgen.Emit(OpCodes.Castclass, delegateConstructor.DeclaringType);
				}
				else
				{
					ilgen.Emit(OpCodes.Dup);
					// we know that a DelegateInnerClassTypeWrapper has only one method
					Debug.Assert(iface.GetMethods().Length == 1);
					MethodWrapper mw = targetType.GetMethodWrapper("Invoke", iface.GetMethods()[0].Signature, true);
					// TODO linking here is not safe
					mw.Link();
					ilgen.Emit(OpCodes.Ldvirtftn, (MethodInfo)mw.GetMethod());
					ilgen.Emit(OpCodes.Newobj, delegateConstructor);
				}
			}
		}

		private class ByRefMethodWrapper : SmartMethodWrapper
		{
#if !STATIC_COMPILER
			private bool[] byrefs;
#endif
			private Type[] args;

			internal ByRefMethodWrapper(Type[] args, bool[] byrefs, TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection)
				: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
			{
				this.args = args;
#if !STATIC_COMPILER
				this.byrefs = byrefs;
#endif
			}

			protected override void CallImpl(CodeEmitter ilgen)
			{
				MethodBase mb = GetMethod();
				MethodInfo mi = mb as MethodInfo;
				if(mi != null)
				{
					ilgen.Emit(OpCodes.Call, mi);
				}
				else
				{
					ilgen.Emit(OpCodes.Call, (ConstructorInfo)mb);
				}
			}

			protected override void CallvirtImpl(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Callvirt, (MethodInfo)GetMethod());
			}

			protected override void NewobjImpl(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Newobj, (ConstructorInfo)GetMethod());
			}

			protected override void PreEmit(CodeEmitter ilgen)
			{
				LocalBuilder[] locals = new LocalBuilder[args.Length];
				for(int i = args.Length - 1; i >= 0; i--)
				{
					Type type = args[i];
					if(type.IsByRef)
					{
						type = ArrayTypeWrapper.MakeArrayType(type.GetElementType(), 1);
					}
					locals[i] = ilgen.DeclareLocal(type);
					ilgen.Emit(OpCodes.Stloc, locals[i]);
				}
				for(int i = 0; i < args.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldloc, locals[i]);
					if(args[i].IsByRef)
					{
						ilgen.Emit(OpCodes.Ldc_I4_0);
						ilgen.Emit(OpCodes.Ldelema, args[i].GetElementType());
					}
				}
				base.PreEmit(ilgen);
			}
		}

		internal static bool IsVisible(Type type)
		{
			return type.IsPublic || (type.IsNestedPublic && IsVisible(type.DeclaringType));
		}

		private class EnumWrapMethodWrapper : MethodWrapper
		{
			internal EnumWrapMethodWrapper(DotNetTypeWrapper tw, TypeWrapper fieldType)
				: base(tw, "wrap", "(" + fieldType.SigName + ")" + tw.SigName, null, tw, new TypeWrapper[] { fieldType }, Modifiers.Static | Modifiers.Public, MemberFlags.None)
			{
			}

			internal override void EmitCall(CodeEmitter ilgen)
			{
				// We don't actually need to do anything here!
				// The compiler will insert a boxing operation after calling us and that will
				// result in our argument being boxed (since that's still sitting on the stack).
			}
		}

		internal class EnumValueFieldWrapper : FieldWrapper
		{
			private Type underlyingType;

			internal EnumValueFieldWrapper(DotNetTypeWrapper tw, TypeWrapper fieldType)
				: base(tw, fieldType, "Value", fieldType.SigName, new ExModifiers(Modifiers.Public | Modifiers.Final, false), null)
			{
				underlyingType = Enum.GetUnderlyingType(tw.type);
			}

			protected override void EmitGetImpl(CodeEmitter ilgen)
			{
				// NOTE if the reference on the stack is null, we *want* the NullReferenceException, so we don't use TypeWrapper.EmitUnbox
				ilgen.LazyEmitUnbox(underlyingType);
				ilgen.LazyEmitLdobj(underlyingType);
			}

			protected override void EmitSetImpl(CodeEmitter ilgen)
			{
				// NOTE even though the field is final, JNI reflection can still be used to set its value!
				LocalBuilder temp = ilgen.AllocTempLocal(underlyingType);
				ilgen.Emit(OpCodes.Stloc, temp);
				ilgen.Emit(OpCodes.Unbox, underlyingType);
				ilgen.Emit(OpCodes.Ldloc, temp);
				ilgen.Emit(OpCodes.Stobj, underlyingType);
				ilgen.ReleaseTempLocal(temp);
			}

			// this method takes a boxed Enum and returns its value as a boxed primitive
			// of the subset of Java primitives (i.e. byte, short, int, long)
			internal static object GetEnumPrimitiveValue(object obj)
			{
				return GetEnumPrimitiveValue(Enum.GetUnderlyingType(obj.GetType()), obj);
			}

			// this method can be used to convert an enum value or its underlying value to a Java primitive
			internal static object GetEnumPrimitiveValue(Type underlyingType, object obj)
			{
				if(underlyingType == typeof(sbyte) || underlyingType == typeof(byte))
				{
					return unchecked((byte)((IConvertible)obj).ToInt32(null));
				}
				else if(underlyingType == typeof(short) || underlyingType == typeof(ushort))
				{
					return unchecked((short)((IConvertible)obj).ToInt32(null));
				}
				else if(underlyingType == typeof(int))
				{
					return ((IConvertible)obj).ToInt32(null);
				}
				else if(underlyingType == typeof(uint))
				{
					return unchecked((int)((IConvertible)obj).ToUInt32(null));
				}
				else if(underlyingType == typeof(long))
				{
					return ((IConvertible)obj).ToInt64(null);
				}
				else if(underlyingType == typeof(ulong))
				{
					return unchecked((long)((IConvertible)obj).ToUInt64(null));
				}
				else
				{
					throw new InvalidOperationException();
				}
			}
		}

		private class ValueTypeDefaultCtor : MethodWrapper
		{
			internal ValueTypeDefaultCtor(DotNetTypeWrapper tw)
				: base(tw, "<init>", "()V", null, PrimitiveTypeWrapper.VOID, TypeWrapper.EmptyArray, Modifiers.Public, MemberFlags.None)
			{
			}

			internal override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
			{
				LocalBuilder local = ilgen.DeclareLocal(DeclaringType.TypeAsTBD);
				ilgen.Emit(OpCodes.Ldloc, local);
				ilgen.Emit(OpCodes.Box, DeclaringType.TypeAsTBD);
			}
		}

		private class FinalizeMethodWrapper : MethodWrapper
		{
			internal FinalizeMethodWrapper(DotNetTypeWrapper tw)
				: base(tw, "finalize", "()V", null, PrimitiveTypeWrapper.VOID, TypeWrapper.EmptyArray, Modifiers.Protected | Modifiers.Final, MemberFlags.None)
			{
			}

			internal override void EmitCall(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Pop);
			}

			internal override void EmitCallvirt(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Pop);
			}
		}

		private class CloneMethodWrapper : MethodWrapper
		{
			internal CloneMethodWrapper(DotNetTypeWrapper tw)
				: base(tw, "clone", "()Ljava.lang.Object;", null, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Protected | Modifiers.Final, MemberFlags.None)
			{
			}

			internal override void EmitCall(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Isinst, ClassLoaderWrapper.LoadClassCritical("java.lang.Cloneable").TypeAsBaseType);
				CodeEmitterLabel label1 = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brtrue_S, label1);
				CodeEmitterLabel label2 = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brfalse_S, label2);
				ilgen.EmitThrow("java.lang.CloneNotSupportedException");
				ilgen.MarkLabel(label2);
				ilgen.EmitThrow("java.lang.NullPointerException");
				ilgen.MarkLabel(label1);
				ilgen.Emit(OpCodes.Call, typeof(object).GetMethod("MemberwiseClone", BindingFlags.Instance | BindingFlags.NonPublic, null, Type.EmptyTypes, null));
			}

			internal override void EmitCallvirt(CodeEmitter ilgen)
			{
				EmitCall(ilgen);
			}
		}

		protected override void LazyPublishMembers()
		{
			// special support for enums
			if(type.IsEnum)
			{
				Type underlyingType = Enum.GetUnderlyingType(type);
				Type javaUnderlyingType;
				if(underlyingType == typeof(sbyte))
				{
					javaUnderlyingType = typeof(byte);
				}
				else if(underlyingType == typeof(ushort))
				{
					javaUnderlyingType = typeof(short);
				}
				else if(underlyingType == typeof(uint))
				{
					javaUnderlyingType = typeof(int);
				}
				else if(underlyingType == typeof(ulong))
				{
					javaUnderlyingType = typeof(long);
				}
				else
				{
					javaUnderlyingType = underlyingType;
				}
				TypeWrapper fieldType = ClassLoaderWrapper.GetWrapperFromType(javaUnderlyingType);
				FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Static);
				List<FieldWrapper> fieldsList = new List<FieldWrapper>();
				for(int i = 0; i < fields.Length; i++)
				{
					if(fields[i].FieldType == type)
					{
						string name = fields[i].Name;
						if(name == "Value")
						{
							name = "_Value";
						}
						else if(name.StartsWith("_") && name.EndsWith("Value"))
						{
							name = "_" + name;
						}
						object val = EnumValueFieldWrapper.GetEnumPrimitiveValue(underlyingType, fields[i].GetRawConstantValue());
						fieldsList.Add(new ConstantFieldWrapper(this, fieldType, name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], val, MemberFlags.None));
					}
				}
				fieldsList.Add(new EnumValueFieldWrapper(this, fieldType));
				SetFields(fieldsList.ToArray());
				SetMethods(new MethodWrapper[] { new EnumWrapMethodWrapper(this, fieldType) });
			}
			else
			{
				List<FieldWrapper> fieldsList = new List<FieldWrapper>();
				FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
				for(int i = 0; i < fields.Length; i++)
				{
					// TODO for remapped types, instance fields need to be converted to static getter/setter methods
					if(fields[i].FieldType.IsPointer)
					{
						// skip, pointer fields are not supported
					}
					else
					{
						// TODO handle name/signature clash
						fieldsList.Add(CreateFieldWrapperDotNet(AttributeHelper.GetModifiers(fields[i], true).Modifiers, fields[i].Name, fields[i].FieldType, fields[i]));
					}
				}
				SetFields(fieldsList.ToArray());

				Dictionary<string, MethodWrapper> methodsList = new Dictionary<string, MethodWrapper>();

				// special case for delegate constructors!
				if(IsDelegate(type))
				{
					TypeWrapper iface = InnerClasses[0];
					DelegateMethodWrapper mw = new DelegateMethodWrapper(this, (DelegateInnerClassTypeWrapper)iface);
					methodsList.Add(mw.Name + mw.Signature, mw);
				}

				// add a protected default constructor to MulticastDelegate to make it easier to define a delegate in Java
				if(type == typeof(MulticastDelegate))
				{
					methodsList.Add("<init>()V", new MulticastDelegateCtorMethodWrapper(this));
				}

				ConstructorInfo[] constructors = type.GetConstructors(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
				for(int i = 0; i < constructors.Length; i++)
				{
					string name;
					string sig;
					TypeWrapper[] args;
					TypeWrapper ret;
					if(MakeMethodDescriptor(constructors[i], out name, out sig, out args, out ret))
					{
						MethodWrapper mw = CreateMethodWrapper(name, sig, args, ret, constructors[i], false);
						string key = mw.Name + mw.Signature;
						if(!methodsList.ContainsKey(key))
						{
							methodsList.Add(key, mw);
						}
					}
				}

				if(type.IsValueType && !methodsList.ContainsKey("<init>()V"))
				{
					// Value types have an implicit default ctor
					methodsList.Add("<init>()V", new ValueTypeDefaultCtor(this));
				}

				MethodInfo[] methods = type.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
				for(int i = 0; i < methods.Length; i++)
				{
					if(methods[i].IsStatic && type.IsInterface)
					{
						// skip, Java cannot deal with static methods on interfaces
					}
					else
					{
						string name;
						string sig;
						TypeWrapper[] args;
						TypeWrapper ret;
						if(MakeMethodDescriptor(methods[i], out name, out sig, out args, out ret))
						{
							if(!methods[i].IsStatic && !methods[i].IsPrivate && BaseTypeWrapper != null)
							{
								MethodWrapper baseMethod = BaseTypeWrapper.GetMethodWrapper(name, sig, true);
								if(baseMethod != null && baseMethod.IsFinal && !baseMethod.IsStatic && !baseMethod.IsPrivate)
								{
									continue;
								}
							}
							MethodWrapper mw = CreateMethodWrapper(name, sig, args, ret, methods[i], false);
							string key = mw.Name + mw.Signature;
							MethodWrapper existing;
							methodsList.TryGetValue(key, out existing);
							if(existing == null || existing is ByRefMethodWrapper)
							{
								methodsList[key] = mw;
							}
						}
						else if(methods[i].IsAbstract)
						{
							this.HasUnsupportedAbstractMethods = true;
						}
					}
				}

				// make sure that all the interface methods that we implement are available as public methods,
				// otherwise javac won't like the class.
				if(!type.IsInterface)
				{
					Type[] interfaces = type.GetInterfaces();
					for(int i = 0; i < interfaces.Length; i++)
					{
						// we only handle public (or nested public) types, because we're potentially adding a
						// method that should be callable by anyone through the interface
						if(IsVisible(interfaces[i]))
						{
							InterfaceMapping map = type.GetInterfaceMap(interfaces[i]);
							for(int j = 0; j < map.InterfaceMethods.Length; j++)
							{
								if((!map.TargetMethods[j].IsPublic || map.TargetMethods[j].Name != map.InterfaceMethods[j].Name)
									&& map.TargetMethods[j].DeclaringType == type)
								{
									string name;
									string sig;
									TypeWrapper[] args;
									TypeWrapper ret;
									if(MakeMethodDescriptor(map.InterfaceMethods[j], out name, out sig, out args, out ret))
									{
										string key = name + sig;
										MethodWrapper existing;
										methodsList.TryGetValue(key, out existing);
										if(existing == null && BaseTypeWrapper != null)
										{
											MethodWrapper baseMethod = BaseTypeWrapper.GetMethodWrapper(name, sig, true);
											if(baseMethod != null && !baseMethod.IsStatic && baseMethod.IsPublic)
											{
												continue;
											}
										}
										if(existing == null || existing is ByRefMethodWrapper || existing.IsStatic || !existing.IsPublic)
										{
											// TODO if existing != null, we need to rename the existing method (but this is complicated because
											// it also affects subclasses). This is especially required is the existing method is abstract,
											// because otherwise we won't be able to create any subclasses in Java.
											methodsList[key] = CreateMethodWrapper(name, sig, args, ret, map.InterfaceMethods[j], true);
										}
									}
								}
							}
						}
					}
				}

				// for non-final remapped types, we need to add all the virtual methods in our alter ego (which
				// appears as our base class) and make them final (to prevent Java code from overriding these
				// methods, which don't really exist).
				if(ClassLoaderWrapper.IsRemappedType(type) && !type.IsSealed && !type.IsInterface)
				{
					// Finish the type, to make sure the methods are populated
					this.BaseTypeWrapper.Finish();
					TypeWrapper baseTypeWrapper = this.BaseTypeWrapper;
					while(baseTypeWrapper != null)
					{
						foreach(MethodWrapper m in baseTypeWrapper.GetMethods())
						{
							if(!m.IsStatic && !m.IsFinal && (m.IsPublic || m.IsProtected) && m.Name != "<init>")
							{
								string key = m.Name + m.Signature;
								if(!methodsList.ContainsKey(key))
								{
									if(m.IsProtected)
									{
										if(m.Name == "finalize" && m.Signature == "()V")
										{
											methodsList.Add(key, new FinalizeMethodWrapper(this));
										}
										else if(m.Name == "clone" && m.Signature == "()Ljava.lang.Object;")
										{
											methodsList.Add(key, new CloneMethodWrapper(this));
										}
										else
										{
											// there should be a special MethodWrapper for this method
											throw new InvalidOperationException("Missing protected method support for " + baseTypeWrapper.Name + "::" + m.Name + m.Signature);
										}
									}
									else
									{
										methodsList.Add(key, new BaseFinalMethodWrapper(this, m));
									}
								}
							}
						}
						baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
					}
				}
				MethodWrapper[] methodArray = new MethodWrapper[methodsList.Count];
				methodsList.Values.CopyTo(methodArray, 0);
				SetMethods(methodArray);
			}
		}

		private class BaseFinalMethodWrapper : MethodWrapper
		{
			private MethodWrapper m;

			internal BaseFinalMethodWrapper(DotNetTypeWrapper tw, MethodWrapper m)
				: base(tw, m.Name, m.Signature, m.GetMethod(), m.ReturnType, m.GetParameters(), m.Modifiers | Modifiers.Final, MemberFlags.None)
			{
				this.m = m;
			}

			internal override void EmitCall(CodeEmitter ilgen)
			{
				// we direct EmitCall to EmitCallvirt, because we always want to end up at the instancehelper method
				// (EmitCall would go to our alter ego .NET type and that wouldn't be legal)
				m.EmitCallvirt(ilgen);
			}

			internal override void EmitCallvirt(CodeEmitter ilgen)
			{
				m.EmitCallvirt(ilgen);
			}
		}

		internal static bool IsUnsupportedAbstractMethod(MethodBase mb)
		{
			if(mb.IsAbstract)
			{
				MethodInfo mi = (MethodInfo)mb;
				if(mi.ReturnType.IsByRef || IsPointerType(mi.ReturnType))
				{
					return true;
				}
				foreach(ParameterInfo p in mi.GetParameters())
				{
					if(p.ParameterType.IsByRef || IsPointerType(p.ParameterType))
					{
						return true;
					}
				}
			}
			return false;
		}

		private static bool IsPointerType(Type type)
		{
			while(type.HasElementType)
			{
				if(type.IsPointer)
				{
					return true;
				}
				type = type.GetElementType();
			}
			return false;
		}

		private bool MakeMethodDescriptor(MethodBase mb, out string name, out string sig, out TypeWrapper[] args, out TypeWrapper ret)
		{
			if(mb.IsGenericMethodDefinition)
			{
				name = null;
				sig = null;
				args = null;
				ret = null;
				return false;
			}
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			sb.Append('(');
			ParameterInfo[] parameters = mb.GetParameters();
			args = new TypeWrapper[parameters.Length];
			for(int i = 0; i < parameters.Length; i++)
			{
				Type type = parameters[i].ParameterType;
				if(IsPointerType(type))
				{
					name = null;
					sig = null;
					args = null;
					ret = null;
					return false;
				}
				if(type.IsByRef)
				{
					type = ArrayTypeWrapper.MakeArrayType(type.GetElementType(), 1);
					if(mb.IsAbstract)
					{
						// Since we cannot override methods with byref arguments, we don't report abstract
						// methods with byref args.
						name = null;
						sig = null;
						args = null;
						ret = null;
						return false;
					}
				}
				TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(type);
				args[i] = tw;
				sb.Append(tw.SigName);
			}
			sb.Append(')');
			if(mb is ConstructorInfo)
			{
				ret = PrimitiveTypeWrapper.VOID;
				if(mb.IsStatic)
				{
					name = "<clinit>";
				}
				else
				{
					name = "<init>";
				}
				sb.Append(ret.SigName);
				sig = sb.ToString();
				return true;
			}
			else
			{
				Type type = ((MethodInfo)mb).ReturnType;
				if(IsPointerType(type) || type.IsByRef)
				{
					name = null;
					sig = null;
					ret = null;
					return false;
				}
				ret = ClassLoaderWrapper.GetWrapperFromType(type);
				sb.Append(ret.SigName);
				name = mb.Name;
				sig = sb.ToString();
				return true;
			}
		}

		internal override TypeWrapper[] Interfaces
		{
			get
			{
				lock(this)
				{
					if(interfaces == null)
					{
						Type[] interfaceTypes = type.GetInterfaces();
						interfaces = new TypeWrapper[interfaceTypes.Length];
						for(int i = 0; i < interfaceTypes.Length; i++)
						{
							if(interfaceTypes[i].DeclaringType != null &&
								AttributeHelper.IsHideFromJava(interfaceTypes[i]) &&
								interfaceTypes[i].Name == "__Interface")
							{
								// we have to return the declaring type for ghost interfaces
								interfaces[i] = ClassLoaderWrapper.GetWrapperFromType(interfaceTypes[i].DeclaringType);
							}
							else
							{
								interfaces[i] = ClassLoaderWrapper.GetWrapperFromType(interfaceTypes[i]);
							}
						}
					}
					return interfaces;
				}
			}
		}

		private static bool IsAttribute(Type type)
		{
			if(!type.IsAbstract && type.IsSubclassOf(typeof(Attribute)) && IsVisible(type))
			{
				//
				// Based on the number of constructors and their arguments, we distinguish several types
				// of attributes:
				//                                   | def ctor | single 1-arg ctor
				// -----------------------------------------------------------------
				// complex only (i.e. Annotation{N}) |          |
				// all optional fields/properties    |    X     |
				// required "value"                  |          |   X
				// optional "value"                  |    X     |   X
				// -----------------------------------------------------------------
				// 
				// TODO currently we don't support "complex only" attributes.
				//
				ConstructorInfo defCtor;
				ConstructorInfo singleOneArgCtor;
				AttributeAnnotationTypeWrapper.GetConstructors(type, out defCtor, out singleOneArgCtor);
				return defCtor != null || singleOneArgCtor != null;
			}
			return false;
		}

		private static bool IsDelegate(Type type)
		{
			// HACK non-public delegates do not get the special treatment (because they are likely to refer to
			// non-public types in the arg list and they're not really useful anyway)
			// NOTE we don't have to check in what assembly the type lives, because this is a DotNetTypeWrapper,
			// we know that it is a different assembly.
			if(!type.IsAbstract && type.IsSubclassOf(typeof(MulticastDelegate)) && IsVisible(type))
			{
				MethodInfo invoke = type.GetMethod("Invoke");
				if(invoke != null)
				{
					foreach(ParameterInfo p in invoke.GetParameters())
					{
						// TODO at the moment we don't support delegates with pointer or byref parameters
						if(p.ParameterType.IsPointer || p.ParameterType.IsByRef)
						{
							return false;
						}
					}
					return true;
				}
			}
			return false;
		}

		internal override TypeWrapper[] InnerClasses
		{
			get
			{
				lock(this)
				{
					if(innerClasses == null)
					{
						Type[] nestedTypes = type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic);
						List<TypeWrapper> list = new List<TypeWrapper>(nestedTypes.Length);
						for(int i = 0; i < nestedTypes.Length; i++)
						{
							if (!nestedTypes[i].IsGenericTypeDefinition)
							{
								list.Add(ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]));
							}
						}
						if(IsDelegate(type))
						{
							ClassLoaderWrapper classLoader = GetClassLoader();
							list.Add(classLoader.RegisterInitiatingLoader(new DelegateInnerClassTypeWrapper(Name + DelegateInterfaceSuffix, type, classLoader)));
						}
						if(IsAttribute(type))
						{
							list.Add(GetClassLoader().RegisterInitiatingLoader(new AttributeAnnotationTypeWrapper(Name + AttributeAnnotationSuffix, type)));
						}
						if(type.IsEnum && IsVisible(type))
						{
							list.Add(GetClassLoader().RegisterInitiatingLoader(new EnumEnumTypeWrapper(Name + EnumEnumSuffix, type)));
						}
						innerClasses = list.ToArray();
					}
				}
				return innerClasses;
			}
		}

		internal override bool IsFakeTypeContainer
		{
			get
			{
				return IsDelegate(type) || IsAttribute(type) || (type.IsEnum && IsVisible(type));
			}
		}

		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				if(outerClass == null)
				{
					Type outer = type.DeclaringType;
					if(outer != null && !type.IsGenericType)
					{
						outerClass = ClassLoaderWrapper.GetWrapperFromType(outer);
					}
				}
				return outerClass;
			}
		}

		internal override Modifiers ReflectiveModifiers
		{
			get
			{
				if(DeclaringTypeWrapper != null)
				{
					return Modifiers | Modifiers.Static;
				}
				return Modifiers;
			}
		}

		private FieldWrapper CreateFieldWrapperDotNet(Modifiers modifiers, string name, Type fieldType, FieldInfo field)
		{
			TypeWrapper type = ClassLoaderWrapper.GetWrapperFromType(fieldType);
			if(field.IsLiteral)
			{
				return new ConstantFieldWrapper(this, type, name, type.SigName, modifiers, field, null, MemberFlags.None);
			}
			else
			{
				return FieldWrapper.Create(this, type, field, name, type.SigName, new ExModifiers(modifiers, false));
			}
		}

		private MethodWrapper CreateMethodWrapper(string name, string sig, TypeWrapper[] argTypeWrappers, TypeWrapper retTypeWrapper, MethodBase mb, bool privateInterfaceImplHack)
		{
			ExModifiers exmods = AttributeHelper.GetModifiers(mb, true);
			Modifiers mods = exmods.Modifiers;
			if(name == "Finalize" && sig == "()V" && !mb.IsStatic &&
				TypeAsBaseType.IsSubclassOf(CoreClasses.java.lang.Object.Wrapper.TypeAsBaseType))
			{
				// TODO if the .NET also has a "finalize" method, we need to hide that one (or rename it, or whatever)
				MethodWrapper mw = new SimpleCallMethodWrapper(this, "finalize", "()V", (MethodInfo)mb, null, null, mods, MemberFlags.None, SimpleOpCode.Call, SimpleOpCode.Callvirt);
				mw.SetDeclaredExceptions(new string[] { "java.lang.Throwable" });
				return mw;
			}
			ParameterInfo[] parameters = mb.GetParameters();
			Type[] args = new Type[parameters.Length];
			bool hasByRefArgs = false;
			bool[] byrefs = null;
			for(int i = 0; i < parameters.Length; i++)
			{
				args[i] = parameters[i].ParameterType;
				if(parameters[i].ParameterType.IsByRef)
				{
					if(byrefs == null)
					{
						byrefs = new bool[args.Length];
					}
					byrefs[i] = true;
					hasByRefArgs = true;
				}
			}
			if(privateInterfaceImplHack)
			{
				mods &= ~Modifiers.Abstract;
				mods |= Modifiers.Final;
			}
			if(hasByRefArgs)
			{
				if(!(mb is ConstructorInfo) && !mb.IsStatic)
				{
					mods |= Modifiers.Final;
				}
				return new ByRefMethodWrapper(args, byrefs, this, name, sig, mb, retTypeWrapper, argTypeWrappers, mods, false);
			}
			else
			{
				if(mb is ConstructorInfo)
				{
					return new SmartConstructorMethodWrapper(this, name, sig, (ConstructorInfo)mb, argTypeWrappers, mods, MemberFlags.None);
				}
				else
				{
					return new SmartCallMethodWrapper(this, name, sig, (MethodInfo)mb, retTypeWrapper, argTypeWrappers, mods, MemberFlags.None, SimpleOpCode.Call, SimpleOpCode.Callvirt);
				}
			}
		}

		internal override Type TypeAsTBD
		{
			get
			{
				return type;
			}
		}

		internal override bool IsRemapped
		{
			get
			{
				return ClassLoaderWrapper.IsRemappedType(type);
			}
		}

		internal override void EmitInstanceOf(TypeWrapper context, CodeEmitter ilgen)
		{
			if(IsRemapped)
			{
				TypeWrapper shadow = ClassLoaderWrapper.GetWrapperFromType(type);
				MethodInfo method = shadow.TypeAsBaseType.GetMethod("__<instanceof>");
				if(method != null)
				{
					ilgen.Emit(OpCodes.Call, method);
					return;
				}
			}
			ilgen.LazyEmit_instanceof(type);
		}

		internal override void EmitCheckcast(TypeWrapper context, CodeEmitter ilgen)
		{
			if(IsRemapped)
			{
				TypeWrapper shadow = ClassLoaderWrapper.GetWrapperFromType(type);
				MethodInfo method = shadow.TypeAsBaseType.GetMethod("__<checkcast>");
				if(method != null)
				{
					ilgen.Emit(OpCodes.Call, method);
					return;
				}
			}
			ilgen.EmitCastclass(type);
		}

		internal override void Finish()
		{
			if(BaseTypeWrapper != null)
			{
				BaseTypeWrapper.Finish();
			}
			foreach(TypeWrapper tw in this.Interfaces)
			{
				tw.Finish();
			}
		}

		internal override object[] GetDeclaredAnnotations()
		{
			if(type.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
				return null;
			}
			return type.GetCustomAttributes(false);
		}

		internal override object[] GetFieldAnnotations(FieldWrapper fw)
		{
			FieldInfo fi = fw.GetField();
			if(fi == null)
			{
				return null;
			}
			if(fi.DeclaringType.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
				return null;
			}
			return fi.GetCustomAttributes(false);
		}

		internal override object[] GetMethodAnnotations(MethodWrapper mw)
		{
			MethodBase mb = mw.GetMethod();
			if(mb == null)
			{
				return null;
			}
			if(mb.DeclaringType.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
				return null;
			}
			return mb.GetCustomAttributes(false);
		}

		internal override object[][] GetParameterAnnotations(MethodWrapper mw)
		{
			MethodBase mb = mw.GetMethod();
			if(mb == null)
			{
				return null;
			}
			if(mb.DeclaringType.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
				return null;
			}
			ParameterInfo[] parameters = mb.GetParameters();
			object[][] attribs = new object[parameters.Length][];
			for(int i = 0; i < parameters.Length; i++)
			{
				attribs[i] = parameters[i].GetCustomAttributes(false);
			}
			return attribs;
		}

		internal override bool IsFastClassLiteralSafe
		{
			get { return true; }
		}
	}

@


1.314
log
@Moved ImplementInterfaceMethodStubs and ImplementInterfaceMethodStubsImpl to DynamicTypeWrapper.
@
text
@a3604 106
	static class BakedTypeCleanupHack
	{
#if NET_4_0
		internal static void Process(DynamicTypeWrapper wrapper) { }
#else
		private static readonly FieldInfo m_methodBuilder = typeof(ConstructorBuilder).GetField("m_methodBuilder", BindingFlags.Instance | BindingFlags.NonPublic);
		private static readonly FieldInfo[] methodBuilderFields = GetFieldList(typeof(MethodBuilder), new string[]
			{
				"m_ilGenerator",
				"m_ubBody",
				"m_RVAFixups",
				"m_mdMethodFixups",
				"m_localSignature",
				"m_localSymInfo",
				"m_exceptions",
				"m_parameterTypes",
				"m_retParam",
				"m_returnType",
				"m_signature"
			});
		private static readonly FieldInfo[] fieldBuilderFields = GetFieldList(typeof(FieldBuilder), new string[]
			{
				"m_data",
				"m_fieldType",
		});

		private static bool IsSupportedVersion
		{
			get
			{
				return Environment.Version.Major == 2 && Environment.Version.Minor == 0 && Environment.Version.Build == 50727 && Environment.Version.Revision == 4016;
			}
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		private static FieldInfo[] GetFieldList(Type type, string[] list)
		{
			if(JVM.SafeGetEnvironmentVariable("IKVM_DISABLE_TYPEBUILDER_HACK") != null || !IsSupportedVersion)
			{
				return null;
			}
			if(!SecurityManager.IsGranted(new SecurityPermission(SecurityPermissionFlag.Assertion)) ||
				!SecurityManager.IsGranted(new ReflectionPermission(ReflectionPermissionFlag.MemberAccess)))
			{
				return null;
			}
			FieldInfo[] fields = new FieldInfo[list.Length];
			for(int i = 0; i < list.Length; i++)
			{
				fields[i] = type.GetField(list[i], BindingFlags.Instance | BindingFlags.NonPublic);
				if(fields[i] == null)
				{
					return null;
				}
			}
			return fields;
		}

		[SecurityCritical]
		[SecurityTreatAsSafe]
		internal static void Process(DynamicTypeWrapper wrapper)
		{
			if(m_methodBuilder != null && methodBuilderFields != null && fieldBuilderFields != null)
			{
				foreach(MethodWrapper mw in wrapper.GetMethods())
				{
					MethodBuilder mb = mw.GetMethod() as MethodBuilder;
					if(mb == null)
					{
						ConstructorBuilder cb = mw.GetMethod() as ConstructorBuilder;
						if(cb != null)
						{
							new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
							mb = (MethodBuilder)m_methodBuilder.GetValue(cb);
							CodeAccessPermission.RevertAssert();
						}
					}
					if(mb != null)
					{
						new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
						foreach(FieldInfo fi in methodBuilderFields)
						{
							fi.SetValue(mb, null);
						}
						CodeAccessPermission.RevertAssert();
					}
				}
				foreach(FieldWrapper fw in wrapper.GetFields())
				{
					FieldBuilder fb = fw.GetField() as FieldBuilder;
					if(fb != null)
					{
						new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
						foreach(FieldInfo fi in fieldBuilderFields)
						{
							fi.SetValue(fb, null);
						}
						CodeAccessPermission.RevertAssert();
					}
				}
			}
		}
#endif // NET_4_0
	}

@


1.313
log
@Made ImplementInterfaceMethodStubs and ImplementInterfaceMethodStubsImpl static in preparation of moving them to DynamicTypeWrapper.
@
text
@a3149 140
		private static void ImplementInterfaceMethodStubImpl(MethodWrapper ifmethod, TypeBuilder typeBuilder, DynamicTypeWrapper wrapper)
		{
			// we're mangling the name to prevent subclasses from accidentally overriding this method and to
			// prevent clashes with overloaded method stubs that are erased to the same signature (e.g. unloadable types and ghost arrays)
			// HACK the signature and name are the wrong way around to work around a C++/CLI bug (apparantely it looks looks at the last n
			// characters of the method name, or something bizarre like that)
			// https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=234167
			string mangledName = ifmethod.DeclaringType.Name + "/" + ifmethod.Signature + ifmethod.Name;
			MethodWrapper mce = null;
			TypeWrapper lookup = wrapper;
			while(lookup != null)
			{
				mce = lookup.GetMethodWrapper(ifmethod.Name, ifmethod.Signature, true);
				if(mce == null || !mce.IsStatic)
				{
					break;
				}
				lookup = mce.DeclaringType.BaseTypeWrapper;
			}
			if(mce != null)
			{
				Debug.Assert(!mce.HasCallerID);
				if(mce.DeclaringType != wrapper)
				{
					// check the loader constraints
					bool error = false;
					if(mce.ReturnType != ifmethod.ReturnType)
					{
						// TODO handle unloadable
						error = true;
					}
					TypeWrapper[] mceparams = mce.GetParameters();
					TypeWrapper[] ifparams = ifmethod.GetParameters();
					for(int i = 0; i < mceparams.Length; i++)
					{
						if(mceparams[i] != ifparams[i])
						{
							// TODO handle unloadable
							error = true;
							break;
						}
					}
					if(error)
					{
						MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
						AttributeHelper.HideFromJava(mb);
						CodeEmitter.Create(mb).EmitThrow("java.lang.LinkageError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
						return;
					}
				}
				if(mce.IsMirandaMethod && mce.DeclaringType == wrapper)
				{
					// Miranda methods already have a methodimpl (if needed) to implement the correct interface method
				}
				else if(!mce.IsPublic)
				{
					// NOTE according to the ECMA spec it isn't legal for a privatescope method to be virtual, but this works and
					// it makes sense, so I hope the spec is wrong
					// UPDATE unfortunately, according to Serge Lidin the spec is correct, and it is not allowed to have virtual privatescope
					// methods. Sigh! So I have to use private methods and mangle the name
					MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
					AttributeHelper.HideFromJava(mb);
					CodeEmitter.Create(mb).EmitThrow("java.lang.IllegalAccessError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
					wrapper.HasIncompleteInterfaceImplementation = true;
				}
				else if(mce.GetMethod() == null || mce.RealName != ifmethod.RealName)
				{
					MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
					AttributeHelper.HideFromJava(mb);
					CodeEmitter ilGenerator = CodeEmitter.Create(mb);
					ilGenerator.Emit(OpCodes.Ldarg_0);
					int argc = mce.GetParameters().Length;
					for(int n = 0; n < argc; n++)
					{
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
					}
					mce.EmitCallvirt(ilGenerator);
					ilGenerator.Emit(OpCodes.Ret);
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
				}
				else if(!ReflectUtil.IsSameAssembly(mce.DeclaringType.TypeAsTBD, typeBuilder))
				{
					// NOTE methods inherited from base classes in a different assembly do *not* automatically implement
					// interface methods, so we have to generate a stub here that doesn't do anything but call the base
					// implementation
					MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
					AttributeHelper.HideFromJava(mb);
					CodeEmitter ilGenerator = CodeEmitter.Create(mb);
					ilGenerator.Emit(OpCodes.Ldarg_0);
					int argc = mce.GetParameters().Length;
					for(int n = 0; n < argc; n++)
					{
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
					}
					mce.EmitCallvirt(ilGenerator);
					ilGenerator.Emit(OpCodes.Ret);
				}
			}
			else
			{
				if(!wrapper.IsAbstract)
				{
					// the type doesn't implement the interface method and isn't abstract either. The JVM allows this, but the CLR doesn't,
					// so we have to create a stub method that throws an AbstractMethodError
					MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
					AttributeHelper.HideFromJava(mb);
					CodeEmitter.Create(mb).EmitThrow("java.lang.AbstractMethodError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
					wrapper.HasIncompleteInterfaceImplementation = true;
				}
			}
		}

		internal static void ImplementInterfaceMethodStubs(TypeBuilder typeBuilder, DynamicTypeWrapper wrapper, Dictionary<TypeWrapper, TypeWrapper> doneSet, TypeWrapper interfaceTypeWrapper)
		{
			Debug.Assert(interfaceTypeWrapper.IsInterface);

			// make sure we don't do the same method twice
			if (doneSet.ContainsKey(interfaceTypeWrapper))
			{
				return;
			}
			doneSet.Add(interfaceTypeWrapper, interfaceTypeWrapper);
			foreach (MethodWrapper method in interfaceTypeWrapper.GetMethods())
			{
				if(!method.IsStatic && !method.IsDynamicOnly)
				{
					ImplementInterfaceMethodStubImpl(method, typeBuilder, wrapper);
				}
			}
			TypeWrapper[] interfaces = interfaceTypeWrapper.Interfaces;
			for(int i = 0; i < interfaces.Length; i++)
			{
				ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet, interfaces[i]);
			}
		}

@


1.312
log
@Moved DynamicTypeWrapper class into its own source file.
@
text
@d3150 1
a3150 1
		private void ImplementInterfaceMethodStubImpl(MethodWrapper ifmethod, TypeBuilder typeBuilder, DynamicTypeWrapper wrapper)
d3157 1
a3157 1
			string mangledName = this.Name + "/" + ifmethod.Signature + ifmethod.Name;
d3266 1
a3266 1
		internal void ImplementInterfaceMethodStubs(TypeBuilder typeBuilder, DynamicTypeWrapper wrapper, Dictionary<TypeWrapper, TypeWrapper> doneSet)
d3268 1
a3268 1
			Debug.Assert(this.IsInterface);
d3270 2
a3271 4
			// make sure we don't do the same method twice and dynamic only interfaces
			// don't really exist, so there is no point in generating stub methods for
			// them (nor can we).
			if(doneSet.ContainsKey(this))
d3275 2
a3276 2
			doneSet.Add(this, this);
			foreach(MethodWrapper method in GetMethods())
d3283 1
a3283 1
			TypeWrapper[] interfaces = Interfaces;
d3286 1
a3286 1
				interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
@


1.311
log
@Removed EmitHelper class and moved its methods into CodeEmitter.
@
text
@a3852 5096
#if STATIC_COMPILER
	abstract class DynamicTypeWrapper : TypeWrapper
#else
	class DynamicTypeWrapper : TypeWrapper
#endif
	{
#if STATIC_COMPILER
		protected readonly CompilerClassLoader classLoader;
#else
		protected readonly ClassLoaderWrapper classLoader;
#endif
		private volatile DynamicImpl impl;
		private TypeWrapper[] interfaces;
		private readonly string sourceFileName;
#if !STATIC_COMPILER
		private byte[][] lineNumberTables;
#endif

		private static TypeWrapper LoadTypeWrapper(ClassLoaderWrapper classLoader, string name)
		{
			TypeWrapper tw = classLoader.LoadClassByDottedNameFast(name);
			if(tw == null)
			{
				throw new NoClassDefFoundError(name);
			}
			return tw;
		}

#if STATIC_COMPILER
		internal DynamicTypeWrapper(ClassFile f, CompilerClassLoader classLoader)
#else
		internal DynamicTypeWrapper(ClassFile f, ClassLoaderWrapper classLoader)
#endif
			: base(f.Modifiers, f.Name, f.IsInterface ? null : LoadTypeWrapper(classLoader, f.SuperClass))
		{
			Profiler.Count("DynamicTypeWrapper");
			this.classLoader = classLoader;
			this.IsInternal = f.IsInternal;
			this.sourceFileName = f.SourceFileAttribute;
			if(BaseTypeWrapper != null)
			{
				if(!BaseTypeWrapper.IsAccessibleFrom(this))
				{
					throw new IllegalAccessError("Class " + f.Name + " cannot access its superclass " + BaseTypeWrapper.Name);
				}
#if !STATIC_COMPILER
				if(!BaseTypeWrapper.IsPublic && !ReflectUtil.IsFromAssembly(BaseTypeWrapper.TypeAsBaseType, classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly))
				{
					// NOTE this can only happen if evil code calls ClassLoader.defineClass() on an assembly class loader (which we allow for compatibility with other slightly less evil code)
					throw new IllegalAccessError("Class " + f.Name + " cannot access its non-public superclass " + BaseTypeWrapper.Name + " from another assembly");
				}
#endif
				if(BaseTypeWrapper.IsFinal)
				{
					throw new VerifyError("Class " + f.Name + " extends final class " + BaseTypeWrapper.Name);
				}
				if(BaseTypeWrapper.IsInterface)
				{
					throw new IncompatibleClassChangeError("Class " + f.Name + " has interface " + BaseTypeWrapper.Name + " as superclass");
				}
				if(BaseTypeWrapper.TypeAsTBD == typeof(Delegate))
				{
					throw new VerifyError(BaseTypeWrapper.Name + " cannot be used as a base class");
				}
				// NOTE defining value types, enums is not supported in IKVM v1
				if(BaseTypeWrapper.TypeAsTBD == typeof(ValueType) || BaseTypeWrapper.TypeAsTBD == typeof(Enum))
				{
					throw new VerifyError("Defining value types in Java is not implemented in IKVM v1");
				}
				if(IsDelegate)
				{
					VerifyDelegate(f);
				}
			}

			ClassFile.ConstantPoolItemClass[] interfaces = f.Interfaces;
			this.interfaces = new TypeWrapper[interfaces.Length];
			for(int i = 0; i < interfaces.Length; i++)
			{
				TypeWrapper iface = LoadTypeWrapper(classLoader, interfaces[i].Name);
				if(!iface.IsAccessibleFrom(this))
				{
					throw new IllegalAccessError("Class " + f.Name + " cannot access its superinterface " + iface.Name);
				}
#if !STATIC_COMPILER
				if(!iface.IsPublic
					&& !ReflectUtil.IsFromAssembly(iface.TypeAsBaseType, classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly)
					&& ReflectUtil.GetAssembly(iface.TypeAsBaseType).GetType(DynamicClassLoader.GetProxyHelperName(iface.TypeAsTBD)) == null)
				{
					// NOTE this happens when you call Proxy.newProxyInstance() on a non-public .NET interface
					// (for ikvmc compiled Java types, ikvmc generates public proxy stubs).
					// NOTE we don't currently check interfaces inherited from other interfaces because mainstream .NET languages
					// don't allow public interfaces extending non-public interfaces.
					throw new IllegalAccessError("Class " + f.Name + " cannot access its non-public superinterface " + iface.Name + " from another assembly");
				}
#endif
				if(!iface.IsInterface)
				{
					throw new IncompatibleClassChangeError("Implementing class");
				}
				this.interfaces[i] = iface;
			}

			impl = new JavaTypeImpl(f, this);
		}

		private void VerifyDelegate(ClassFile f)
		{
			if (!f.IsFinal)
			{
				throw new VerifyError("Delegate must be final");
			}
			ClassFile.Method invoke = null;
			ClassFile.Method beginInvoke = null;
			ClassFile.Method endInvoke = null;
			ClassFile.Method constructor = null;
			foreach (ClassFile.Method m in f.Methods)
			{
				if (m.Name == "Invoke")
				{
					if (invoke != null)
					{
						throw new VerifyError("Delegate may only have a single Invoke method");
					}
					invoke = m;
				}
				else if (m.Name == "BeginInvoke")
				{
					if (beginInvoke != null)
					{
						throw new VerifyError("Delegate may only have a single BeginInvoke method");
					}
					beginInvoke = m;
				}
				else if (m.Name == "EndInvoke")
				{
					if (endInvoke != null)
					{
						throw new VerifyError("Delegate may only have a single EndInvoke method");
					}
					endInvoke = m;
				}
				else if (m.Name == "<init>")
				{
					if (constructor != null)
					{
						throw new VerifyError("Delegate may only have a single constructor");
					}
					constructor = m;
				}
				else if (m.IsNative)
				{
					throw new VerifyError("Delegate may not have any native methods besides Invoke, BeginInvoke and EndInvoke");
				}
			}
			if (invoke == null || constructor == null)
			{
				throw new VerifyError("Delegate must have a constructor and an Invoke method");
			}
			if (!invoke.IsPublic || !invoke.IsNative || invoke.IsFinal || invoke.IsStatic)
			{
				throw new VerifyError("Delegate Invoke method must be a public native non-final instance method");
			}
			if ((beginInvoke != null && endInvoke == null) || (beginInvoke == null && endInvoke != null))
			{
				throw new VerifyError("Delegate must have both BeginInvoke and EndInvoke or neither");
			}
			if (!constructor.IsPublic)
			{
				throw new VerifyError("Delegate constructor must be public");
			}
			if (constructor.Instructions.Length < 3
				|| constructor.Instructions[0].NormalizedOpCode != NormalizedByteCode.__aload
				|| constructor.Instructions[0].NormalizedArg1 != 0
				|| constructor.Instructions[1].NormalizedOpCode != NormalizedByteCode.__invokespecial
				|| constructor.Instructions[2].NormalizedOpCode != NormalizedByteCode.__return)
			{
				throw new VerifyError("Delegate constructor must be empty");
			}
			if (f.Fields.Length != 0)
			{
				throw new VerifyError("Delegate may not declare any fields");
			}
			TypeWrapper iface;
#if STATIC_COMPILER
			iface = classLoader.LoadCircularDependencyHack(this, f.Name + DotNetTypeWrapper.DelegateInterfaceSuffix);
#else
			iface = classLoader.LoadClassByDottedNameFast(f.Name + DotNetTypeWrapper.DelegateInterfaceSuffix);
#endif
			DelegateInnerClassCheck(iface != null);
			DelegateInnerClassCheck(iface.IsInterface);
			DelegateInnerClassCheck(iface.IsPublic);
			DelegateInnerClassCheck(iface.GetClassLoader() == classLoader);
			MethodWrapper[] methods = iface.GetMethods();
			DelegateInnerClassCheck(methods.Length == 1 && methods[0].Name == "Invoke");
			if (methods[0].Signature != invoke.Signature)
			{
				throw new VerifyError("Delegate Invoke method signature must be identical to inner interface Invoke method signature");
			}
			if (iface.Interfaces.Length != 0)
			{
				throw new VerifyError("Delegate inner interface may not extend any interfaces");
			}
			if (constructor.Signature != "(" + iface.SigName + ")V")
			{
				throw new VerifyError("Delegate constructor must take a single argument of type inner Method interface");
			}
			if (beginInvoke != null && beginInvoke.Signature != invoke.Signature.Substring(0, invoke.Signature.IndexOf(')')) + "Lcli.System.AsyncCallback;Ljava.lang.Object;)Lcli.System.IAsyncResult;")
			{
				throw new VerifyError("Delegate BeginInvoke method has incorrect signature");
			}
			if (endInvoke != null && endInvoke.Signature != "(Lcli.System.IAsyncResult;)" + invoke.Signature.Substring(invoke.Signature.IndexOf(')') + 1))
			{
				throw new VerifyError("Delegate EndInvoke method has incorrect signature");
			}
		}

		private static void DelegateInnerClassCheck(bool cond)
		{
			if (!cond)
			{
				throw new VerifyError("Delegate must have a public inner interface named Method with a single method named Invoke");
			}
		}

		private bool IsDelegate
		{
			get
			{
				TypeWrapper baseTypeWrapper = BaseTypeWrapper;
				return baseTypeWrapper != null && baseTypeWrapper.TypeAsTBD == typeof(MulticastDelegate);
			}
		}

		internal override ClassLoaderWrapper GetClassLoader()
		{
			return classLoader;
		}

		internal override Modifiers ReflectiveModifiers
		{
			get
			{
				return impl.ReflectiveModifiers;
			}
		}

		internal override TypeWrapper[] Interfaces
		{
			get
			{
				return interfaces;
			}
		}

		internal override TypeWrapper[] InnerClasses
		{
			get
			{
				return impl.InnerClasses;
			}
		}

		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				return impl.DeclaringTypeWrapper;
			}
		}

		internal override Type TypeAsTBD
		{
			get
			{
				return impl.Type;
			}
		}

#if STATIC_COMPILER
		internal override Annotation Annotation
		{
			get
			{
				return impl.Annotation;
			}
		}

		internal override Type EnumType
		{
			get
			{
				return impl.EnumType;
			}
		}
#endif // STATIC_COMPILER

		internal override void Finish()
		{
			// we don't need locking, because Finish is Thread safe
			impl = impl.Finish();
		}

		// NOTE can only be used if the type hasn't been finished yet!
		protected string GenerateUniqueMethodName(string basename, MethodWrapper mw)
		{
			return ((JavaTypeImpl)impl).GenerateUniqueMethodName(basename, mw);
		}

		// NOTE can only be used if the type hasn't been finished yet!
		internal string GenerateUniqueMethodName(string basename, Type returnType, Type[] parameterTypes)
		{
			return ((JavaTypeImpl)impl).GenerateUniqueMethodName(basename, returnType, parameterTypes);
		}

		internal void CreateStep1(out bool hasclinit)
		{
			((JavaTypeImpl)impl).CreateStep1(out hasclinit);
		}

		internal void CreateStep2NoFail(bool hasclinit, string mangledTypeName)
		{
			((JavaTypeImpl)impl).CreateStep2NoFail(hasclinit, mangledTypeName);
		}

		private bool IsSerializable
		{
			get
			{
				return this.IsSubTypeOf(ClassLoaderWrapper.LoadClassCritical("java.io.Serializable"));
			}
		}

		private abstract class DynamicImpl
		{
			internal abstract Type Type { get; }
			internal abstract TypeWrapper[] InnerClasses { get; }
			internal abstract TypeWrapper DeclaringTypeWrapper { get; }
			internal abstract Modifiers ReflectiveModifiers { get; }
#if STATIC_COMPILER
			internal abstract Annotation Annotation { get; }
			internal abstract Type EnumType { get; }
#endif
			internal abstract DynamicImpl Finish();
			internal abstract MethodBase LinkMethod(MethodWrapper mw);
			internal abstract FieldInfo LinkField(FieldWrapper fw);
			internal abstract void EmitRunClassConstructor(CodeEmitter ilgen);
			internal abstract string GetGenericSignature();
			internal abstract string[] GetEnclosingMethod();
			internal abstract string GetGenericMethodSignature(int index);
			internal abstract string GetGenericFieldSignature(int index);
			internal abstract object[] GetDeclaredAnnotations();
			internal abstract object GetMethodDefaultValue(int index);
			internal abstract object[] GetMethodAnnotations(int index);
			internal abstract object[][] GetParameterAnnotations(int index);
			internal abstract object[] GetFieldAnnotations(int index);
			internal abstract MethodInfo GetFinalizeMethod();
		}

		private sealed class JavaTypeImpl : DynamicImpl
		{
			private readonly ClassFile classFile;
			private readonly DynamicTypeWrapper wrapper;
			private TypeBuilder typeBuilder;
			private MethodWrapper[] methods;
			private MethodWrapper[] baseMethods;
			private FieldWrapper[] fields;
			private FinishedTypeImpl finishedType;
			private bool finishInProgress;
			private Dictionary<string, string> memberclashtable;
			private MethodBuilder clinitMethod;
			private MethodBuilder finalizeMethod;
#if STATIC_COMPILER
			private DynamicTypeWrapper outerClassWrapper;
			private AnnotationBuilder annotationBuilder;
			private TypeBuilder enumBuilder;
#endif

			internal JavaTypeImpl(ClassFile f, DynamicTypeWrapper wrapper)
			{
				Tracer.Info(Tracer.Compiler, "constructing JavaTypeImpl for " + f.Name);
				this.classFile = f;
				this.wrapper = wrapper;
			}

			internal void CreateStep1(out bool hasclinit)
			{
				// process all methods
				hasclinit = wrapper.BaseTypeWrapper == null ? false : wrapper.BaseTypeWrapper.HasStaticInitializer;
				methods = new MethodWrapper[classFile.Methods.Length];
				baseMethods = new MethodWrapper[classFile.Methods.Length];
				for(int i = 0; i < methods.Length; i++)
				{
					ClassFile.Method m = classFile.Methods[i];
					if(m.IsClassInitializer)
					{
#if STATIC_COMPILER
						bool noop;
						if(IsSideEffectFreeStaticInitializerOrNoop(m, out noop))
						{
							// because we cannot affect serialVersionUID computation (which is the only way the presence of a <clinit> can surface)
							// we cannot do this optimization if the class is serializable but doesn't have a serialVersionUID
							if(noop && (!wrapper.IsSerializable || classFile.HasSerialVersionUID))
							{
								methods[i] = new DummyMethodWrapper(wrapper);
								continue;
							}
						}
						else
						{
							hasclinit = true;
						}
#else
						hasclinit = true;
#endif
					}
					MemberFlags flags = MemberFlags.None;
					if(m.IsInternal)
					{
						flags |= MemberFlags.InternalAccess;
					}
					// we only support HasCallerID instance methods on final types, because we don't support interface stubs with CallerID
					if(m.HasCallerIDAnnotation
						&& (m.IsStatic || classFile.IsFinal)
						&& CoreClasses.java.lang.Object.Wrapper.InternalsVisibleTo(wrapper))
					{
						flags |= MemberFlags.CallerID;
					}
					if(wrapper.IsGhost)
					{
						methods[i] = new MethodWrapper.GhostMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, flags);
					}
					else if(ReferenceEquals(m.Name, StringConstants.INIT) && wrapper.IsDelegate)
					{
						methods[i] = new DelegateConstructorMethodWrapper(wrapper, m);
					}
					else if(ReferenceEquals(m.Name, StringConstants.INIT) || m.IsClassInitializer)
					{
						methods[i] = new SmartConstructorMethodWrapper(wrapper, m.Name, m.Signature, null, null, m.Modifiers, flags);
					}
					else
					{
						if(!classFile.IsInterface && !m.IsStatic && !m.IsPrivate)
						{
							bool explicitOverride = false;
							baseMethods[i] = FindBaseMethod(m.Name, m.Signature, out explicitOverride);
							if(explicitOverride)
							{
								flags |= MemberFlags.ExplicitOverride;
							}
						}
						methods[i] = new SmartCallMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, flags, SimpleOpCode.Call, SimpleOpCode.Callvirt);
					}
				}
				wrapper.HasStaticInitializer = hasclinit;
				if(!wrapper.IsInterface || wrapper.IsPublic)
				{
					List<MethodWrapper> methodsArray = null;
					List<MethodWrapper> baseMethodsArray = null;
					if(wrapper.IsAbstract)
					{
						methodsArray = new List<MethodWrapper>(methods);
						baseMethodsArray = new List<MethodWrapper>(baseMethods);
						AddMirandaMethods(methodsArray, baseMethodsArray, wrapper);
					}
#if STATIC_COMPILER
					if(!wrapper.IsInterface && wrapper.IsPublic)
					{
						TypeWrapper baseTypeWrapper = wrapper.BaseTypeWrapper;
						while(baseTypeWrapper != null && !baseTypeWrapper.IsPublic)
						{
							if(methodsArray == null)
							{
								methodsArray = new List<MethodWrapper>(methods);
								baseMethodsArray = new List<MethodWrapper>(baseMethods);
							}
							AddAccessStubMethods(methodsArray, baseMethodsArray, baseTypeWrapper);
							baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
						}
					}
#endif
					if(methodsArray != null)
					{
						this.methods = methodsArray.ToArray();
						this.baseMethods = baseMethodsArray.ToArray();
					}
				}
				wrapper.SetMethods(methods);

				fields = new FieldWrapper[classFile.Fields.Length];
				for(int i = 0; i < fields.Length; i++)
				{
					ClassFile.Field fld = classFile.Fields[i];
					if(fld.IsStatic && fld.IsFinal && fld.ConstantValue != null)
					{
						TypeWrapper fieldType = null;
#if !STATIC_COMPILER
						fieldType = ClassLoaderWrapper.GetBootstrapClassLoader().FieldTypeWrapperFromSig(fld.Signature);
#endif
						fields[i] = new ConstantFieldWrapper(wrapper, fieldType, fld.Name, fld.Signature, fld.Modifiers, null, fld.ConstantValue, MemberFlags.None);
					}
					else if(fld.IsProperty)
					{
						fields[i] = new DynamicPropertyFieldWrapper(wrapper, fld);
					}
					else
					{
						fields[i] = FieldWrapper.Create(wrapper, null, null, fld.Name, fld.Signature, new ExModifiers(fld.Modifiers, fld.IsInternal));
					}
				}
#if STATIC_COMPILER
				if(wrapper.IsPublic)
				{
					List<FieldWrapper> fieldsArray = new List<FieldWrapper>(fields);
					AddAccessStubFields(fieldsArray, wrapper);
					fields = fieldsArray.ToArray();
				}
				((AotTypeWrapper)wrapper).AddMapXmlFields(ref fields);
#endif
				wrapper.SetFields(fields);
			}

			internal void CreateStep2NoFail(bool hasclinit, string mangledTypeName)
			{
				// this method is not allowed to throw exceptions (if it does, the runtime will abort)
				ClassFile f = classFile;
				try
				{
					TypeAttributes typeAttribs = 0;
					if(f.IsAbstract)
					{
						typeAttribs |= TypeAttributes.Abstract;
					}
					if(f.IsFinal)
					{
						typeAttribs |= TypeAttributes.Sealed;
					}
					if(!hasclinit)
					{
						typeAttribs |= TypeAttributes.BeforeFieldInit;
					}
#if STATIC_COMPILER
					bool cantNest = false;
					bool setModifiers = false;
					TypeBuilder outer = null;
					// we only compile inner classes as nested types in the static compiler, because it has a higher cost
					// and doesn't buy us anything in dynamic mode (and if fact, due to an FXBUG it would make handling
					// the TypeResolve event very hard)
					ClassFile.InnerClass outerClass = getOuterClass();
					if(outerClass.outerClass != 0)
					{
						string outerClassName = classFile.GetConstantPoolClass(outerClass.outerClass);
						if(!CheckInnerOuterNames(f.Name, outerClassName))
						{
							Tracer.Warning(Tracer.Compiler, "Incorrect InnerClasses attribute on {0}", f.Name);
						}
						else
						{
							try
							{
								outerClassWrapper = wrapper.GetClassLoader().LoadCircularDependencyHack(wrapper, outerClassName) as DynamicTypeWrapper;
							}
							catch(RetargetableJavaException x)
							{
								Tracer.Warning(Tracer.Compiler, "Unable to load outer class {0} for inner class {1} ({2}: {3})", outerClassName, f.Name, x.GetType().Name, x.Message);
							}
							if(outerClassWrapper != null)
							{
								// make sure the relationship is reciprocal (otherwise we run the risk of
								// baking the outer type before the inner type) and that the inner and outer
								// class live in the same class loader (when doing a multi target compilation,
								// it is possible to split the two classes acros assemblies)
								if(outerClassWrapper.impl is JavaTypeImpl && outerClassWrapper.GetClassLoader() == wrapper.GetClassLoader())
								{
									ClassFile outerClassFile = ((JavaTypeImpl)outerClassWrapper.impl).classFile;
									ClassFile.InnerClass[] outerInnerClasses = outerClassFile.InnerClasses;
									if(outerInnerClasses == null)
									{
										outerClassWrapper = null;
									}
									else
									{
										bool ok = false;
										for(int i = 0; i < outerInnerClasses.Length; i++)
										{
											if(outerInnerClasses[i].outerClass != 0
												&& outerClassFile.GetConstantPoolClass(outerInnerClasses[i].outerClass) == outerClassFile.Name
												&& outerInnerClasses[i].innerClass != 0
												&& outerClassFile.GetConstantPoolClass(outerInnerClasses[i].innerClass) == f.Name)
											{
												ok = true;
												break;
											}
										}
										if(!ok)
										{
											outerClassWrapper = null;
										}
									}
								}
								else
								{
									outerClassWrapper = null;
								}
								if(outerClassWrapper != null)
								{
									outer = outerClassWrapper.TypeAsBuilder;
								}
								else
								{
									Tracer.Warning(Tracer.Compiler, "Non-reciprocal inner class {0}", f.Name);
								}
							}
						}
					}
					if(f.IsPublic)
					{
						if(outer != null)
						{
							if(outerClassWrapper.IsPublic)
							{
								typeAttribs |= TypeAttributes.NestedPublic;
							}
							else
							{
								// We're a public type nested inside a non-public type, this means that we can't compile this type as a nested type,
								// because that would mean it wouldn't be visible outside the assembly.
								cantNest = true;
								typeAttribs |= TypeAttributes.Public;
							}
						}
						else
						{
							typeAttribs |= TypeAttributes.Public;
						}
					}
					else if(outer != null)
					{
						typeAttribs |= TypeAttributes.NestedAssembly;
					}
#else // STATIC_COMPILER
					if(f.IsPublic)
					{
						typeAttribs |= TypeAttributes.Public;
					}
#endif // STATIC_COMPILER
					if(f.IsInterface)
					{
						typeAttribs |= TypeAttributes.Interface | TypeAttributes.Abstract;
#if STATIC_COMPILER
						if(outer != null && !cantNest)
						{
							if(wrapper.IsGhost)
							{
								// TODO this is low priority, since the current Java class library doesn't define any ghost interfaces
								// as inner classes
								throw new NotImplementedException();
							}
							// LAMESPEC the CLI spec says interfaces cannot contain nested types (Part.II, 9.6), but that rule isn't enforced
							// (and broken by J# as well), so we'll just ignore it too.
							typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs);
						}
						else
						{
							if(wrapper.IsGhost)
							{
								typeBuilder = wrapper.DefineGhostType(mangledTypeName, typeAttribs);
							}
							else
							{
								typeBuilder = wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs);
							}
						}
#else // STATIC_COMPILER
						typeBuilder = wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs);
#endif // STATIC_COMPILER
					}
					else
					{
						typeAttribs |= TypeAttributes.Class;
#if STATIC_COMPILER
						if(f.IsEffectivelyFinal)
						{
							if(outer == null)
							{
								setModifiers = true;
							}
							else
							{
								// we don't need a ModifiersAttribute, because the InnerClassAttribute already records
								// the modifiers
							}
							typeAttribs |= TypeAttributes.Sealed;
							Tracer.Info(Tracer.Compiler, "Sealing type {0}", f.Name);
						}
						if(outer != null && !cantNest)
						{
							// LAMESPEC the CLI spec says interfaces cannot contain nested types (Part.II, 9.6), but that rule isn't enforced
							// (and broken by J# as well), so we'll just ignore it too.
							typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs, wrapper.GetBaseTypeForDefineType());
						}
						else
#endif // STATIC_COMPILER
						{
							typeBuilder = wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs, wrapper.GetBaseTypeForDefineType());
						}
					}
#if STATIC_COMPILER
					if(outer != null && cantNest)
					{
						AttributeHelper.SetNonNestedOuterClass(typeBuilder, outerClassWrapper.Name);
						AttributeHelper.SetNonNestedInnerClass(outer, f.Name);
					}
					if(outer == null && mangledTypeName != wrapper.Name)
					{
						// HACK we abuse the InnerClassAttribute to record to real name
						AttributeHelper.SetInnerClass(typeBuilder, wrapper.Name, wrapper.Modifiers);
					}
					if(typeBuilder.FullName != wrapper.Name
						&& wrapper.Name.Replace('$', '+') != typeBuilder.FullName)
					{
						((CompilerClassLoader)wrapper.GetClassLoader()).AddNameMapping(wrapper.Name, typeBuilder.FullName);
					}
					if(f.IsAnnotation && Annotation.HasRetentionPolicyRuntime(f.Annotations))
					{
						annotationBuilder = new AnnotationBuilder(this);
						((AotTypeWrapper)wrapper).SetAnnotation(annotationBuilder);
					}
					// For Java 5 Enum types, we generate a nested .NET enum.
					// This is primarily to support annotations that take enum parameters.
					if(f.IsEnum && f.IsPublic)
					{
						// TODO make sure there isn't already a nested type with the __Enum name
						enumBuilder = wrapper.TypeAsBuilder.DefineNestedType("__Enum", TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.NestedPublic | TypeAttributes.Serializable, typeof(Enum));
						AttributeHelper.HideFromJava(enumBuilder);
						enumBuilder.DefineField("value__", typeof(int), FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
						for(int i = 0; i < f.Fields.Length; i++)
						{
							if(f.Fields[i].IsEnum)
							{
								FieldBuilder fieldBuilder = enumBuilder.DefineField(f.Fields[i].Name, enumBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
								fieldBuilder.SetConstant(i);
							}
						}
					}
					TypeWrapper[] interfaces = wrapper.Interfaces;
					string[] implements = new string[interfaces.Length];
					for(int i = 0; i < implements.Length; i++)
					{
						implements[i] = interfaces[i].Name;
					}
					if(outer != null)
					{
						Modifiers innerClassModifiers = outerClass.accessFlags;
						string innerClassName = classFile.GetConstantPoolClass(outerClass.innerClass);
						if(innerClassName == classFile.Name && innerClassName == outerClassWrapper.Name + "$" + typeBuilder.Name)
						{
							innerClassName = null;
						}
						AttributeHelper.SetInnerClass(typeBuilder, innerClassName, innerClassModifiers);
					}
					else if(outerClass.innerClass != 0)
					{
						AttributeHelper.SetInnerClass(typeBuilder, null, outerClass.accessFlags);
					}
					AttributeHelper.SetImplementsAttribute(typeBuilder, interfaces);
					if(classFile.DeprecatedAttribute)
					{
						AttributeHelper.SetDeprecatedAttribute(typeBuilder);
					}
					if(classFile.GenericSignature != null)
					{
						AttributeHelper.SetSignatureAttribute(typeBuilder, classFile.GenericSignature);
					}
					if(classFile.EnclosingMethod != null)
					{
						AttributeHelper.SetEnclosingMethodAttribute(typeBuilder, classFile.EnclosingMethod[0], classFile.EnclosingMethod[1], classFile.EnclosingMethod[2]);
					}
					if(wrapper.classLoader.EmitStackTraceInfo)
					{
						if(f.SourceFileAttribute != null)
						{
							if(f.SourceFileAttribute != typeBuilder.Name + ".java")
							{
								AttributeHelper.SetSourceFile(typeBuilder, f.SourceFileAttribute);
							}
						}
						else
						{
							AttributeHelper.SetSourceFile(typeBuilder, null);
						}
					}
					// NOTE in Whidbey we can (and should) use CompilerGeneratedAttribute to mark Synthetic types
					if(setModifiers || classFile.IsInternal || (classFile.Modifiers & (Modifiers.Synthetic | Modifiers.Annotation | Modifiers.Enum)) != 0)
					{
						AttributeHelper.SetModifiers(typeBuilder, classFile.Modifiers, classFile.IsInternal);
					}
#endif // STATIC_COMPILER
					if(hasclinit)
					{
						// We create a empty method that we can use to trigger our .cctor
						// (previously we used RuntimeHelpers.RunClassConstructor, but that is slow and requires additional privileges)
						MethodAttributes attribs = MethodAttributes.Static | MethodAttributes.SpecialName;
						if(classFile.IsAbstract)
						{
							bool hasfields = false;
							// If we have any public static fields, the cctor trigger must (and may) be public as well
							foreach(ClassFile.Field fld in classFile.Fields)
							{
								if(fld.IsPublic && fld.IsStatic)
								{
									hasfields = true;
									break;
								}
							}
							attribs |= hasfields ? MethodAttributes.Public : MethodAttributes.FamORAssem;
						}
						else
						{
							attribs |= MethodAttributes.Public;
						}
						clinitMethod = typeBuilder.DefineMethod("__<clinit>", attribs, null, null);
						clinitMethod.GetILGenerator().Emit(OpCodes.Ret);
						// FXBUG on .NET 2.0 RTM x64 the JIT sometimes throws an InvalidProgramException while trying to inline this method,
						// so we prevent inlining for now (it also turns out that on x86 not inlining this method actually has a positive perf impact in some cases...)
						// http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=285772
						clinitMethod.SetImplementationFlags(clinitMethod.GetMethodImplementationFlags() | MethodImplAttributes.NoInlining);
					}
					if(HasStructLayoutAttributeAnnotation(classFile))
					{
						// when we have a StructLayoutAttribute, field order is significant,
						// so we link all fields here to make sure they are created in class file order.
						foreach(FieldWrapper fw in fields)
						{
							fw.Link();
						}
					}
				}
				catch(Exception x)
				{
					JVM.CriticalFailure("Exception during JavaTypeImpl.CreateStep2NoFail", x);
				}
			}

			private sealed class DelegateConstructorMethodWrapper : MethodWrapper
			{
				private ConstructorBuilder constructor;
				private MethodInfo invoke;

				internal DelegateConstructorMethodWrapper(DynamicTypeWrapper tw, ClassFile.Method m)
					: base(tw, m.Name, m.Signature, null, null, null, m.Modifiers, MemberFlags.None)
				{
				}

				protected override void DoLinkMethod()
				{
					MethodAttributes attribs = MethodAttributes.HideBySig | MethodAttributes.Public;
					constructor = this.DeclaringType.TypeAsBuilder.DefineConstructor(attribs, CallingConventions.Standard, new Type[] { typeof(object), typeof(IntPtr) }, null, null);
					constructor.SetImplementationFlags(MethodImplAttributes.Runtime);
					MethodWrapper mw = GetParameters()[0].GetMethods()[0];
					mw.Link();
					invoke = (MethodInfo)mw.GetMethod();
				}

				internal override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
				{
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Ldvirtftn, invoke);
					ilgen.Emit(OpCodes.Newobj, constructor);
				}
			}

			private static bool HasStructLayoutAttributeAnnotation(ClassFile c)
			{
				if(c.Annotations != null)
				{
					foreach(object[] annot in c.Annotations)
					{
						if("Lcli/System/Runtime/InteropServices/StructLayoutAttribute$Annotation;".Equals(annot[1]))
						{
							return true;
						}
					}
				}
				return false;
			}

#if STATIC_COMPILER
			private ClassFile.InnerClass getOuterClass()
			{
				ClassFile.InnerClass[] innerClasses = classFile.InnerClasses;
				if(innerClasses != null)
				{
					for(int j = 0; j < innerClasses.Length; j++)
					{
						if(innerClasses[j].innerClass != 0
							&& classFile.GetConstantPoolClass(innerClasses[j].innerClass) == classFile.Name)
						{
							return innerClasses[j];
						}
					}
				}
				return new ClassFile.InnerClass();
			}

			private bool IsSideEffectFreeStaticInitializerOrNoop(ClassFile.Method m, out bool noop)
			{
				if(m.ExceptionTable.Length != 0)
				{
					noop = false;
					return false;
				}
				noop = true;
				for(int i = 0; i < m.Instructions.Length; i++)
				{
					NormalizedByteCode bc = m.Instructions[i].NormalizedOpCode;
					if(bc == NormalizedByteCode.__getstatic || bc == NormalizedByteCode.__putstatic)
					{
						ClassFile.ConstantPoolItemFieldref fld = classFile.SafeGetFieldref(m.Instructions[i].Arg1);
						if(fld == null || fld.Class != classFile.Name)
						{
							noop = false;
							return false;
						}
						// don't allow getstatic to load non-primitive fields, because that would
						// cause the verifier to try to load the type
						if(bc == NormalizedByteCode.__getstatic && "L[".IndexOf(fld.Signature[0]) != -1)
						{
							noop = false;
							return false;
						}
						if(bc == NormalizedByteCode.__putstatic)
						{
							ClassFile.Field field = classFile.GetField(fld.Name, fld.Signature);
							if(field == null)
							{
								noop = false;
								return false;
							}
							if(!field.IsFinal || !field.IsStatic || !field.IsProperty || field.PropertySetter != null)
							{
								noop = false;
							}
						}
					}
					else if(bc == NormalizedByteCode.__areturn ||
						bc == NormalizedByteCode.__ireturn ||
						bc == NormalizedByteCode.__lreturn ||
						bc == NormalizedByteCode.__freturn ||
						bc == NormalizedByteCode.__dreturn)
					{
						noop = false;
						return false;
					}
					else if(ByteCodeMetaData.CanThrowException(bc))
					{
						noop = false;
						return false;
					}
					else if(bc == NormalizedByteCode.__ldc
						&& classFile.SafeIsConstantPoolClass(m.Instructions[i].Arg1))
					{
						noop = false;
						return false;
					}
					else if(bc == NormalizedByteCode.__aconst_null
						|| bc == NormalizedByteCode.__return
						|| bc == NormalizedByteCode.__nop)
					{
						// valid instructions in a potential noop <clinit>
					}
					else
					{
						noop = false;
					}
				}
				// the method needs to be verifiable to be side effect free, since we already analysed it,
				// we know that the verifier won't try to load any types (which isn't allowed at this time)
				try
				{
					new MethodAnalyzer(wrapper, null, classFile, m, wrapper.classLoader);
					return true;
				}
				catch(VerifyError)
				{
					return false;
				}
			}

			private static bool ContainsMemberWrapper(List<FieldWrapper> members, string name, string sig)
			{
				foreach(MemberWrapper mw in members)
				{
					if(mw.Name == name && mw.Signature == sig)
					{
						return true;
					}
				}
				return false;
			}

			private static bool ContainsMemberWrapper(List<MethodWrapper> members, string name, string sig)
			{
				foreach(MemberWrapper mw in members)
				{
					if(mw.Name == name && mw.Signature == sig)
					{
						return true;
					}
				}
				return false;
			}
#endif // STATIC_COMPILER

			private MethodWrapper GetMethodWrapperDuringCtor(TypeWrapper lookup, List<MethodWrapper> methods, string name, string sig)
			{
				if(lookup == wrapper)
				{
					foreach(MethodWrapper mw in methods)
					{
						if(mw.Name == name && mw.Signature == sig)
						{
							return mw;
						}
					}
					if(lookup.BaseTypeWrapper == null)
					{
						return null;
					}
					else
					{
						return lookup.BaseTypeWrapper.GetMethodWrapper(name, sig, true);
					}
				}
				else
				{
					return lookup.GetMethodWrapper(name, sig, true);
				}
			}

			private void AddMirandaMethods(List<MethodWrapper> methods, List<MethodWrapper> baseMethods, TypeWrapper tw)
			{
				foreach(TypeWrapper iface in tw.Interfaces)
				{
					if(iface.IsPublic && this.wrapper.IsInterface)
					{
						// for interfaces, we only need miranda methods for non-public interfaces that we extend
						continue;
					}
					AddMirandaMethods(methods, baseMethods, iface);
					foreach(MethodWrapper ifmethod in iface.GetMethods())
					{
						// skip <clinit>
						if(!ifmethod.IsStatic)
						{
							TypeWrapper lookup = wrapper;
							while(lookup != null)
							{
								MethodWrapper mw = GetMethodWrapperDuringCtor(lookup, methods, ifmethod.Name, ifmethod.Signature);
								if(mw == null)
								{
									mw = new SmartCallMethodWrapper(wrapper, ifmethod.Name, ifmethod.Signature, null, null, null, Modifiers.Public | Modifiers.Abstract, MemberFlags.HideFromReflection | MemberFlags.MirandaMethod, SimpleOpCode.Call, SimpleOpCode.Callvirt);
									methods.Add(mw);
									baseMethods.Add(ifmethod);
									break;
								}
								if(!mw.IsStatic)
								{
									break;
								}
								lookup = mw.DeclaringType.BaseTypeWrapper;
							}
						}
					}
				}
			}

#if STATIC_COMPILER
			private void AddAccessStubMethods(List<MethodWrapper> methods, List<MethodWrapper> baseMethods, TypeWrapper tw)
			{
				foreach(MethodWrapper mw in tw.GetMethods())
				{
					if((mw.IsPublic || mw.IsProtected)
						&& mw.Name != "<init>"
						&& !ContainsMemberWrapper(methods, mw.Name, mw.Signature))
					{
						MethodWrapper stub = new SmartCallMethodWrapper(wrapper, mw.Name, mw.Signature, null, null, null, mw.Modifiers, MemberFlags.HideFromReflection | MemberFlags.AccessStub, SimpleOpCode.Call, SimpleOpCode.Callvirt);
						methods.Add(stub);
						baseMethods.Add(mw);
					}
				}
			}

			private void AddAccessStubFields(List<FieldWrapper> fields, TypeWrapper tw)
			{
				do
				{
					if(!tw.IsPublic)
					{
						foreach(FieldWrapper fw in tw.GetFields())
						{
							if((fw.IsPublic || fw.IsProtected)
								&& !ContainsMemberWrapper(fields, fw.Name, fw.Signature))
							{
								fields.Add(new AotAccessStubFieldWrapper(wrapper, fw));
							}
						}
					}
					foreach(TypeWrapper iface in tw.Interfaces)
					{
						AddAccessStubFields(fields, iface);
					}
					tw = tw.BaseTypeWrapper;
				} while(tw != null && !tw.IsPublic);
			}

			private static bool CheckInnerOuterNames(string inner, string outer)
			{
				// do some sanity checks on the inner/outer class names
				return inner.Length > outer.Length + 1 && inner[outer.Length] == '$' && inner.StartsWith(outer);
			}

			private static string GetInnerClassName(string outer, string inner)
			{
				Debug.Assert(CheckInnerOuterNames(inner, outer));
				return DynamicClassLoader.EscapeName(inner.Substring(outer.Length + 1));
			}
#endif // STATIC_COMPILER

			private int GetMethodIndex(MethodWrapper mw)
			{
				for(int i = 0; i < methods.Length; i++)
				{
					if(methods[i] == mw)
					{
						return i;
					}
				}
				throw new InvalidOperationException();
			}

			internal override MethodBase LinkMethod(MethodWrapper mw)
			{
				Debug.Assert(mw != null);
				bool unloadableOverrideStub = false;
				int index = GetMethodIndex(mw);
				MethodWrapper baseMethod = baseMethods[index];
				if(baseMethod != null)
				{
					baseMethod.Link();
					// check the loader constraints
					if(mw.ReturnType != baseMethod.ReturnType)
					{
						if(baseMethod.ReturnType.IsUnloadable || JVM.FinishingForDebugSave)
						{
							if(!mw.ReturnType.IsUnloadable || (!baseMethod.ReturnType.IsUnloadable && JVM.FinishingForDebugSave))
							{
								unloadableOverrideStub = true;
							}
						}
						else
						{
#if STATIC_COMPILER
							StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has a return type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has a return type \"{1}\"", mw.ReturnType, baseMethod.ReturnType, mw.DeclaringType.Name, mw.Name, mw.Signature, baseMethod.DeclaringType.Name);
#endif
							throw new LinkageError("Loader constraints violated");
						}
					}
					TypeWrapper[] here = mw.GetParameters();
					TypeWrapper[] there = baseMethod.GetParameters();
					for(int i = 0; i < here.Length; i++)
					{
						if(here[i] != there[i])
						{
							if(there[i].IsUnloadable || JVM.FinishingForDebugSave)
							{
								if(!here[i].IsUnloadable || (!there[i].IsUnloadable && JVM.FinishingForDebugSave))
								{
									unloadableOverrideStub = true;
								}
							}
							else
							{
#if STATIC_COMPILER
								StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has an argument type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has an argument type \"{1}\"", here[i], there[i], mw.DeclaringType.Name, mw.Name, mw.Signature, baseMethod.DeclaringType.Name);
#endif
								throw new LinkageError("Loader constraints violated");
							}
						}
					}
				}
				Debug.Assert(mw.GetMethod() == null);
				MethodBase mb = GenerateMethod(index, unloadableOverrideStub);
				if((mw.Modifiers & (Modifiers.Synchronized | Modifiers.Static)) == Modifiers.Synchronized)
				{
					// note that constructors cannot be synchronized in Java
					MethodBuilder mbld = (MethodBuilder)mb;
					mbld.SetImplementationFlags(mbld.GetMethodImplementationFlags() | MethodImplAttributes.Synchronized);
				}
				return mb;
			}

			private int GetFieldIndex(FieldWrapper fw)
			{
				for(int i = 0; i < fields.Length; i++)
				{
					if(fields[i] == fw)
					{
						return i;
					}
				}
				throw new InvalidOperationException();
			}

			internal override FieldInfo LinkField(FieldWrapper fw)
			{
				if(fw.IsAccessStub)
				{
					((AotAccessStubFieldWrapper)fw).DoLink(typeBuilder);
					return null;
				}
				if(fw is DynamicPropertyFieldWrapper)
				{
					((DynamicPropertyFieldWrapper)fw).DoLink(typeBuilder);
					return null;
				}
				int fieldIndex = GetFieldIndex(fw);
#if STATIC_COMPILER
				if(fieldIndex >= classFile.Fields.Length)
				{
					// this must be a field defined in map.xml
					FieldAttributes fieldAttribs = 0;
					if(fw.IsPublic)
					{
						fieldAttribs |= FieldAttributes.Public;
					}
					else if(fw.IsProtected)
					{
						fieldAttribs |= FieldAttributes.FamORAssem;
					}
					else if(fw.IsPrivate)
					{
						fieldAttribs |= FieldAttributes.Private;
					}
					else
					{
						fieldAttribs |= FieldAttributes.Assembly;
					}
					if(fw.IsStatic)
					{
						fieldAttribs |= FieldAttributes.Static;
					}
					if(fw.IsFinal)
					{
						fieldAttribs |= FieldAttributes.InitOnly;
					}
					return typeBuilder.DefineField(fw.Name, fw.FieldTypeWrapper.TypeAsSignatureType, fieldAttribs);
				}
#endif // STATIC_COMPILER
				FieldBuilder field;
				ClassFile.Field fld = classFile.Fields[fieldIndex];
				string fieldName = fld.Name;
				TypeWrapper typeWrapper = fw.FieldTypeWrapper;
				Type type = typeWrapper.TypeAsSignatureType;
				bool setNameSig = typeWrapper.IsErasedOrBoxedPrimitiveOrRemapped;
				if(setNameSig)
				{
					// TODO use clashtable
					// the field name is mangled here, because otherwise it can (theoretically)
					// conflict with another unloadable or object or ghost array field
					// (fields can be overloaded on type)
					fieldName += "/" + typeWrapper.Name;
				}
				FieldAttributes attribs = 0;
				MethodAttributes methodAttribs = MethodAttributes.HideBySig;
#if STATIC_COMPILER
				bool setModifiers = fld.IsInternal || (fld.Modifiers & (Modifiers.Synthetic | Modifiers.Enum)) != 0;
#endif
				bool isWrappedFinal = false;
				if(fld.IsPrivate)
				{
					attribs |= FieldAttributes.Private;
				}
				else if(fld.IsProtected)
				{
					attribs |= FieldAttributes.FamORAssem;
					methodAttribs |= MethodAttributes.FamORAssem;
				}
				else if(fld.IsPublic)
				{
					attribs |= FieldAttributes.Public;
					methodAttribs |= MethodAttributes.Public;
				}
				else
				{
					attribs |= FieldAttributes.Assembly;
					methodAttribs |= MethodAttributes.Assembly;
				}
				if(fld.IsStatic)
				{
					attribs |= FieldAttributes.Static;
					methodAttribs |= MethodAttributes.Static;
				}
				// NOTE "constant" static finals are converted into literals
				// TODO it would be possible for Java code to change the value of a non-blank static final, but I don't
				// know if we want to support this (since the Java JITs don't really support it either)
				object constantValue = fld.ConstantValue;
				if(fld.IsStatic && fld.IsFinal && constantValue != null)
				{
					Profiler.Count("Static Final Constant");
					attribs |= FieldAttributes.Literal;
					field = typeBuilder.DefineField(fieldName, type, attribs);
					field.SetConstant(constantValue);
				}
				else
				{
					if(fld.IsFinal)
					{
						isWrappedFinal = fw is GetterFieldWrapper;
						if(isWrappedFinal)
						{
							// NOTE public/protected blank final fields get converted into a read-only property with a private field
							// backing store
							attribs &= ~FieldAttributes.FieldAccessMask;
							attribs |= FieldAttributes.PrivateScope;
						}
						else if(wrapper.IsInterface || wrapper.classLoader.StrictFinalFieldSemantics)
						{
							attribs |= FieldAttributes.InitOnly;
						}
						else
						{
#if STATIC_COMPILER
							setModifiers = true;
#endif
						}
					}
					Type[] modreq = Type.EmptyTypes;
					if(fld.IsVolatile)
					{
						modreq = new Type[] { typeof(System.Runtime.CompilerServices.IsVolatile) };
					}
					field = typeBuilder.DefineField(fieldName, type, modreq, Type.EmptyTypes, attribs);
					if(fld.IsTransient)
					{
						CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(typeof(NonSerializedAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
						field.SetCustomAttribute(transientAttrib);
					}
#if STATIC_COMPILER
					// Instance fields can also have a ConstantValue attribute (and are inlined by the compiler),
					// and ikvmstub has to export them, so we have to add a custom attribute.
					if(constantValue != null)
					{
						AttributeHelper.SetConstantValue(field, constantValue);
					}
#endif // STATIC_COMPILER
					if(isWrappedFinal)
					{
						methodAttribs |= MethodAttributes.SpecialName;
						MethodBuilder getter = typeBuilder.DefineMethod(GenerateUniqueMethodName("get_" + fieldName, type, Type.EmptyTypes), methodAttribs, CallingConventions.Standard, type, Type.EmptyTypes);
						AttributeHelper.HideFromJava(getter);
						CodeEmitter ilgen = CodeEmitter.Create(getter);
						if(fld.IsStatic)
						{
							ilgen.Emit(OpCodes.Ldsfld, field);
						}
						else
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldfld, field);
						}
						ilgen.Emit(OpCodes.Ret);

						PropertyBuilder pb = typeBuilder.DefineProperty(fieldName, PropertyAttributes.None, type, Type.EmptyTypes);
						pb.SetGetMethod(getter);
						if(!fld.IsStatic)
						{
							// this method exist for use by reflection only
							// (that's why it only exists for instance fields, final static fields are not settable by reflection)
							MethodBuilder setter = typeBuilder.DefineMethod("__<set>", MethodAttributes.PrivateScope, CallingConventions.Standard, typeof(void), new Type[] { type });
							ilgen = CodeEmitter.Create(setter);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldarg_1);
							ilgen.Emit(OpCodes.Stfld, field);
							ilgen.Emit(OpCodes.Ret);
							pb.SetSetMethod(setter);
						}
						((GetterFieldWrapper)fw).SetGetter(getter);
#if STATIC_COMPILER
						if(setNameSig)
						{
							AttributeHelper.SetNameSig(getter, fld.Name, fld.Signature);
						}
						if(setModifiers || fld.IsTransient)
						{
							AttributeHelper.SetModifiers(getter, fld.Modifiers, fld.IsInternal);
						}
						if(fld.DeprecatedAttribute)
						{
							// NOTE for better interop with other languages, we set the ObsoleteAttribute on the property itself
							AttributeHelper.SetDeprecatedAttribute(pb);
						}
						if(fld.GenericSignature != null)
						{
							AttributeHelper.SetSignatureAttribute(getter, fld.GenericSignature);
						}
#endif // STATIC_COMPILER
					}
				}
#if STATIC_COMPILER
				if(!isWrappedFinal)
				{
					// if the Java modifiers cannot be expressed in .NET, we emit the Modifiers attribute to store
					// the Java modifiers
					if(setModifiers)
					{
						AttributeHelper.SetModifiers(field, fld.Modifiers, fld.IsInternal);
					}
					if(setNameSig)
					{
						AttributeHelper.SetNameSig(field, fld.Name, fld.Signature);
					}
					if(fld.DeprecatedAttribute)
					{
						AttributeHelper.SetDeprecatedAttribute(field);
					}
					if(fld.GenericSignature != null)
					{
						AttributeHelper.SetSignatureAttribute(field, fld.GenericSignature);
					}
				}
#endif // STATIC_COMPILER
				return field;
			}

			internal override void EmitRunClassConstructor(CodeEmitter ilgen)
			{
				if(clinitMethod != null)
				{
					ilgen.Emit(OpCodes.Call, clinitMethod);
				}
			}

			internal override DynamicImpl Finish()
			{
				if(wrapper.BaseTypeWrapper != null)
				{
					wrapper.BaseTypeWrapper.Finish();
				}
#if STATIC_COMPILER
				if(outerClassWrapper != null)
				{
					outerClassWrapper.Finish();
				}
#endif // STATIC_COMPILER
				// NOTE there is a bug in the CLR (.NET 1.0 & 1.1 [1.2 is not yet available]) that
				// causes the AppDomain.TypeResolve event to receive the incorrect type name for nested types.
				// The Name in the ResolveEventArgs contains only the nested type name, not the full type name,
				// for example, if the type being resolved is "MyOuterType+MyInnerType", then the event only
				// receives "MyInnerType" as the name. Since we only compile inner classes as nested types
				// when we're statically compiling, we can only run into this bug when we're statically compiling.
				// NOTE To work around this bug, we have to make sure that all types that are going to be
				// required in finished form, are finished explicitly here. It isn't clear what other types are
				// required to be finished. I instrumented a static compilation of classpath.dll and this
				// turned up no other cases of the TypeResolve event firing.
				for(int i = 0; i < wrapper.Interfaces.Length; i++)
				{
					wrapper.Interfaces[i].Finish();
				}
				// make sure all classes are loaded, before we start finishing the type. During finishing, we
				// may not run any Java code, because that might result in a request to finish the type that we
				// are in the process of finishing, and this would be a problem.
				classFile.Link(wrapper);
				for(int i = 0; i < fields.Length; i++)
				{
#if STATIC_COMPILER
					if(fields[i] is AotAccessStubFieldWrapper)
					{
						// HACK we skip access stubs, because we want to do the methods first
						// (to prevent the stub method from taking the name of a real method)
						continue;
					}
#endif
					fields[i].Link();
				}
				for(int i = 0; i < methods.Length; i++)
				{
					methods[i].Link();
				}
#if STATIC_COMPILER
				// HACK second pass for the access stubs (see above)
				for(int i = 0; i < fields.Length; i++)
				{
					if(fields[i] is AotAccessStubFieldWrapper)
					{
						fields[i].Link();
					}
				}
#endif
				// this is the correct lock, FinishCore doesn't call any user code and mutates global state,
				// so it needs to be protected by a lock.
				lock(this)
				{
					return FinishCore();
				}
			}

			private FinishedTypeImpl FinishCore()
			{
				// it is possible that the loading of the referenced classes triggered a finish of us,
				// if that happens, we just return
				if(finishedType != null)
				{
					return finishedType;
				}
				if(finishInProgress)
				{
					throw new InvalidOperationException("Recursive finish attempt for " + wrapper.Name);
				}
				finishInProgress = true;
				Tracer.Info(Tracer.Compiler, "Finishing: {0}", wrapper.Name);
				Profiler.Enter("JavaTypeImpl.Finish.Core");
				try
				{
					TypeWrapper declaringTypeWrapper = null;
					TypeWrapper[] innerClassesTypeWrappers = TypeWrapper.EmptyArray;
					// if we're an inner class, we need to attach an InnerClass attribute
					ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
					if (innerclasses != null)
					{
						// TODO consider not pre-computing innerClassesTypeWrappers and declaringTypeWrapper here
						List<TypeWrapper> wrappers = new List<TypeWrapper>();
						for (int i = 0; i < innerclasses.Length; i++)
						{
							if (innerclasses[i].innerClass != 0 && innerclasses[i].outerClass != 0)
							{
								if (classFile.GetConstantPoolClassType(innerclasses[i].outerClass) == wrapper)
								{
									wrappers.Add(classFile.GetConstantPoolClassType(innerclasses[i].innerClass));
								}
								if (classFile.GetConstantPoolClassType(innerclasses[i].innerClass) == wrapper)
								{
									declaringTypeWrapper = classFile.GetConstantPoolClassType(innerclasses[i].outerClass);
								}
							}
						}
						innerClassesTypeWrappers = wrappers.ToArray();
#if STATIC_COMPILER
						// before we bake our type, we need to link any inner annotations to allow them to create their attribute type (as a nested type)
						foreach(TypeWrapper tw in innerClassesTypeWrappers)
						{
							DynamicTypeWrapper dtw = tw as DynamicTypeWrapper;
							if(dtw != null)
							{
								JavaTypeImpl impl = dtw.impl as JavaTypeImpl;
								if(impl != null)
								{
									if(impl.annotationBuilder != null)
									{
										impl.annotationBuilder.Link();
									}
								}
							}
						}
#endif //STATIC_COMPILER
					}
					FinishContext context = new FinishContext(classFile, wrapper, typeBuilder);
#if STATIC_COMPILER
					if(annotationBuilder != null)
					{
						CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(AnnotationAttributeAttribute)).GetConstructor(new Type[] { typeof(string) }), new object[] { annotationBuilder.AttributeTypeName });
						typeBuilder.SetCustomAttribute(cab);
					}
					context.RegisterPostFinishProc(delegate
					{
						if (enumBuilder != null)
						{
							enumBuilder.CreateType();
						}
						if (annotationBuilder != null)
						{
							annotationBuilder.Finish(this);
						}
					});
#endif
					Type type = context.FinishImpl();
					MethodInfo finishedClinitMethod = clinitMethod;
#if !STATIC_COMPILER
					if(finishedClinitMethod != null)
					{
						// In dynamic mode, we may need to emit a call to this method from a DynamicMethod which doesn't support calling unfinished methods,
						// so we must resolve to the real method here.
						finishedClinitMethod = type.GetMethod("__<clinit>", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
					}
#endif
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, wrapper.ReflectiveModifiers, Metadata.Create(classFile), finishedClinitMethod, finalizeMethod
#if STATIC_COMPILER
						, annotationBuilder, enumBuilder
#endif
					);
					return finishedType;
				}
				catch(Exception x)
				{
					JVM.CriticalFailure("Exception during finishing of: " + wrapper.Name, x);
					return null;
				}
				finally
				{
					Profiler.Leave("JavaTypeImpl.Finish.Core");
				}
			}

#if STATIC_COMPILER
			private bool IsValidAnnotationElementType(string type)
			{
				if(type[0] == '[')
				{
					type = type.Substring(1);
				}
				switch(type)
				{
					case "Z":
					case "B":
					case "S":
					case "C":
					case "I":
					case "J":
					case "F":
					case "D":
					case "Ljava.lang.String;":
					case "Ljava.lang.Class;":
						return true;
				}
				if(type.StartsWith("L") && type.EndsWith(";"))
				{
					try
					{
						TypeWrapper tw = wrapper.GetClassLoader().LoadClassByDottedNameFast(type.Substring(1, type.Length - 2));
						if(tw != null)
						{
							if((tw.Modifiers & Modifiers.Annotation) != 0)
							{
								return true;
							}
							if((tw.Modifiers & Modifiers.Enum) != 0)
							{
								TypeWrapper enumType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast("java.lang.Enum");
								if(enumType != null && tw.IsSubTypeOf(enumType))
								{
									return true;
								}
							}
						}
					}
					catch
					{
					}
				}
				return false;
			}

			sealed class AnnotationBuilder : Annotation
			{
				private JavaTypeImpl impl;
				private TypeBuilder annotationTypeBuilder;
				private TypeBuilder attributeTypeBuilder;
				private ConstructorBuilder defineConstructor;

				internal AnnotationBuilder(JavaTypeImpl o)
				{
					this.impl = o;
				}

				internal void Link()
				{
					if(impl == null)
					{
						return;
					}
					JavaTypeImpl o = impl;
					impl = null;

					// Make sure the annotation type only has valid methods
					for(int i = 0; i < o.methods.Length; i++)
					{
						if(!o.methods[i].IsStatic)
						{
							if(!o.methods[i].Signature.StartsWith("()"))
							{
								return;
							}
							if(!o.IsValidAnnotationElementType(o.methods[i].Signature.Substring(2)))
							{
								return;
							}
						}
					}

					// we only set annotationTypeBuilder if we're valid
					annotationTypeBuilder = o.typeBuilder;

					TypeWrapper annotationAttributeBaseType = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.AnnotationAttributeBase");

					// TODO attribute should be .NET serializable
					TypeAttributes typeAttributes = TypeAttributes.Class | TypeAttributes.Sealed;
					if(o.outerClassWrapper != null)
					{
						if(o.wrapper.IsPublic)
						{
							typeAttributes |= TypeAttributes.NestedPublic;
						}
						else
						{
							typeAttributes |= TypeAttributes.NestedAssembly;
						}
						attributeTypeBuilder = o.outerClassWrapper.TypeAsBuilder.DefineNestedType(GetInnerClassName(o.outerClassWrapper.Name, o.classFile.Name) + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
					}
					else
					{
						if(o.wrapper.IsPublic)
						{
							typeAttributes |= TypeAttributes.Public;
						}
						else
						{
							typeAttributes |= TypeAttributes.NotPublic;
						}
						attributeTypeBuilder = o.wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(o.classFile.Name + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
					}
					if(o.wrapper.IsPublic)
					{
						// In the Java world, the class appears as a non-public proxy class
						AttributeHelper.SetModifiers(attributeTypeBuilder, Modifiers.Final, false);
					}
					// NOTE we "abuse" the InnerClassAttribute to add a custom attribute to name the class "$Proxy[Annotation]" in the Java world
					int dotindex = o.classFile.Name.LastIndexOf('.') + 1;
					AttributeHelper.SetInnerClass(attributeTypeBuilder, o.classFile.Name.Substring(0, dotindex) + "$Proxy" + o.classFile.Name.Substring(dotindex), Modifiers.Final);
					attributeTypeBuilder.AddInterfaceImplementation(o.typeBuilder);
					AttributeHelper.SetImplementsAttribute(attributeTypeBuilder, new TypeWrapper[] { o.wrapper });

					if(o.classFile.Annotations != null)
					{
						foreach(object[] def in o.classFile.Annotations)
						{
							if(def[1].Equals("Ljava/lang/annotation/Target;"))
							{
								for(int i = 2; i < def.Length; i += 2)
								{
									if(def[i].Equals("value"))
									{
										object[] val = def[i + 1] as object[];
										if(val != null
											&& val.Length > 0
											&& val[0].Equals(AnnotationDefaultAttribute.TAG_ARRAY))
										{
											AttributeTargets targets = 0;
											for(int j = 1; j < val.Length; j++)
											{
												object[] eval = val[j] as object[];
												if(eval != null
													&& eval.Length == 3
													&& eval[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)
													&& eval[1].Equals("Ljava/lang/annotation/ElementType;"))
												{
													switch((string)eval[2])
													{
														case "ANNOTATION_TYPE":
															targets |= AttributeTargets.Interface;
															break;
														case "CONSTRUCTOR":
															targets |= AttributeTargets.Constructor;
															break;
														case "FIELD":
															targets |= AttributeTargets.Field;
															break;
														case "LOCAL_VARIABLE":
															break;
														case "METHOD":
															targets |= AttributeTargets.Method;
															break;
														case "PACKAGE":
															targets |= AttributeTargets.Interface;
															break;
														case "PARAMETER":
															targets |= AttributeTargets.Parameter;
															break;
														case "TYPE":
															targets |= AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Delegate | AttributeTargets.Enum;
															break;
													}
												}
											}
											CustomAttributeBuilder cab2 = new CustomAttributeBuilder(typeof(AttributeUsageAttribute).GetConstructor(new Type[] { typeof(AttributeTargets) }), new object[] { targets });
											attributeTypeBuilder.SetCustomAttribute(cab2);
										}
									}
								}
							}
						}
					}

					defineConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { typeof(object[]) });
					AttributeHelper.SetEditorBrowsableNever(defineConstructor);
				}

				private static Type TypeWrapperToAnnotationParameterType(TypeWrapper tw)
				{
					bool isArray = false;
					if(tw.IsArray)
					{
						isArray = true;
						tw = tw.ElementTypeWrapper;
					}
					if(tw.Annotation != null)
					{
						// we don't support Annotation args
						return null;
					}
					else
					{
						Type argType;
						if(tw == CoreClasses.java.lang.Class.Wrapper)
						{
							argType = typeof(Type);
						}
						else if(tw.EnumType != null)
						{
							argType = tw.EnumType;
						}
						else
						{
							argType = tw.TypeAsSignatureType;
						}
						if(isArray)
						{
							argType = ArrayTypeWrapper.MakeArrayType(argType, 1);
						}
						return argType;
					}
				}

				internal string AttributeTypeName
				{
					get
					{
						Link();
						if(attributeTypeBuilder != null)
						{
							return attributeTypeBuilder.FullName;
						}
						return null;
					}
				}

				private static void EmitSetValueCall(TypeWrapper annotationAttributeBaseType, CodeEmitter ilgen, string name, TypeWrapper tw, int argIndex)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldstr, name);
					ilgen.Emit(OpCodes.Ldarg_S, (byte)argIndex);
					if(tw.TypeAsSignatureType.IsValueType)
					{
						ilgen.Emit(OpCodes.Box, tw.TypeAsSignatureType);
					}
					else if(tw.EnumType != null)
					{
						ilgen.Emit(OpCodes.Box, tw.EnumType);
					}
					MethodWrapper setValueMethod = annotationAttributeBaseType.GetMethodWrapper("setValue", "(Ljava.lang.String;Ljava.lang.Object;)V", false);
					setValueMethod.Link();
					setValueMethod.EmitCall(ilgen);
				}

				internal void Finish(JavaTypeImpl o)
				{
					Link();
					if(annotationTypeBuilder == null)
					{
						// not a valid annotation type
						return;
					}
					TypeWrapper annotationAttributeBaseType = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.AnnotationAttributeBase");
					annotationAttributeBaseType.Finish();

					int requiredArgCount = 0;
					int valueArg = -1;
					bool unsupported = false;
					for(int i = 0; i < o.methods.Length; i++)
					{
						if(!o.methods[i].IsStatic)
						{
							if(valueArg == -1 && o.methods[i].Name == "value")
							{
								valueArg = i;
							}
							if(o.classFile.Methods[i].AnnotationDefault == null)
							{
								if(TypeWrapperToAnnotationParameterType(o.methods[i].ReturnType) == null)
								{
									unsupported = true;
									break;
								}
								requiredArgCount++;
							}
						}
					}

					ConstructorBuilder defaultConstructor = attributeTypeBuilder.DefineConstructor(unsupported || requiredArgCount > 0 ? MethodAttributes.Private : MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
					CodeEmitter ilgen;

					if(!unsupported)
					{
						if(requiredArgCount > 0)
						{
							Type[] args = new Type[requiredArgCount];
							for(int i = 0, j = 0; i < o.methods.Length; i++)
							{
								if(!o.methods[i].IsStatic)
								{
									if(o.classFile.Methods[i].AnnotationDefault == null)
									{
										args[j++] = TypeWrapperToAnnotationParameterType(o.methods[i].ReturnType);
									}
								}
							}
							ConstructorBuilder reqArgConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, args);
							AttributeHelper.HideFromJava(reqArgConstructor);
							ilgen = CodeEmitter.Create(reqArgConstructor);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Call, defaultConstructor);
							for(int i = 0, j = 0; i < o.methods.Length; i++)
							{
								if(!o.methods[i].IsStatic)
								{
									if(o.classFile.Methods[i].AnnotationDefault == null)
									{
										reqArgConstructor.DefineParameter(++j, ParameterAttributes.None, o.methods[i].Name);
										EmitSetValueCall(annotationAttributeBaseType, ilgen, o.methods[i].Name, o.methods[i].ReturnType, j);
									}
								}
							}
							ilgen.Emit(OpCodes.Ret);
						}
						else if(valueArg != -1)
						{
							// We don't have any required parameters, but we do have an optional "value" parameter,
							// so we create an additional constructor (the default constructor will be public in this case)
							// that accepts the value parameter.
							Type argType = TypeWrapperToAnnotationParameterType(o.methods[valueArg].ReturnType);
							if(argType != null)
							{
								ConstructorBuilder cb = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { argType });
								AttributeHelper.HideFromJava(cb);
								cb.DefineParameter(1, ParameterAttributes.None, "value");
								ilgen = CodeEmitter.Create(cb);
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Call, defaultConstructor);
								EmitSetValueCall(annotationAttributeBaseType, ilgen, "value", o.methods[valueArg].ReturnType, 1);
								ilgen.Emit(OpCodes.Ret);
							}
						}
					}

					ilgen = CodeEmitter.Create(defaultConstructor);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.LazyEmitLoadClass(o.wrapper);
					annotationAttributeBaseType.GetMethodWrapper("<init>", "(Ljava.lang.Class;)V", false).EmitCall(ilgen);
					ilgen.Emit(OpCodes.Ret);

					ilgen = CodeEmitter.Create(defineConstructor);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Call, defaultConstructor);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldarg_1);
					annotationAttributeBaseType.GetMethodWrapper("setDefinition", "([Ljava.lang.Object;)V", false).EmitCall(ilgen);
					ilgen.Emit(OpCodes.Ret);

					MethodWrapper getValueMethod = annotationAttributeBaseType.GetMethodWrapper("getValue", "(Ljava.lang.String;)Ljava.lang.Object;", false);
					MethodWrapper getByteValueMethod = annotationAttributeBaseType.GetMethodWrapper("getByteValue", "(Ljava.lang.String;)B", false);
					MethodWrapper getBooleanValueMethod = annotationAttributeBaseType.GetMethodWrapper("getBooleanValue", "(Ljava.lang.String;)Z", false);
					MethodWrapper getCharValueMethod = annotationAttributeBaseType.GetMethodWrapper("getCharValue", "(Ljava.lang.String;)C", false);
					MethodWrapper getShortValueMethod = annotationAttributeBaseType.GetMethodWrapper("getShortValue", "(Ljava.lang.String;)S", false);
					MethodWrapper getIntValueMethod = annotationAttributeBaseType.GetMethodWrapper("getIntValue", "(Ljava.lang.String;)I", false);
					MethodWrapper getFloatValueMethod = annotationAttributeBaseType.GetMethodWrapper("getFloatValue", "(Ljava.lang.String;)F", false);
					MethodWrapper getLongValueMethod = annotationAttributeBaseType.GetMethodWrapper("getLongValue", "(Ljava.lang.String;)J", false);
					MethodWrapper getDoubleValueMethod = annotationAttributeBaseType.GetMethodWrapper("getDoubleValue", "(Ljava.lang.String;)D", false);
					for(int i = 0; i < o.methods.Length; i++)
					{
						// skip <clinit>
						if(!o.methods[i].IsStatic)
						{
							MethodBuilder mb = attributeTypeBuilder.DefineMethod(o.methods[i].Name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot, o.methods[i].ReturnTypeForDefineMethod, o.methods[i].GetParametersForDefineMethod());
							attributeTypeBuilder.DefineMethodOverride(mb, (MethodInfo)o.methods[i].GetMethod());
							ilgen = CodeEmitter.Create(mb);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldstr, o.methods[i].Name);
							if(o.methods[i].ReturnType.IsPrimitive)
							{
								if(o.methods[i].ReturnType == PrimitiveTypeWrapper.BYTE)
								{
									getByteValueMethod.EmitCall(ilgen);
								}
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.BOOLEAN)
								{
									getBooleanValueMethod.EmitCall(ilgen);
								}
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.CHAR)
								{
									getCharValueMethod.EmitCall(ilgen);
								}
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.SHORT)
								{
									getShortValueMethod.EmitCall(ilgen);
								}
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.INT)
								{
									getIntValueMethod.EmitCall(ilgen);
								}
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.FLOAT)
								{
									getFloatValueMethod.EmitCall(ilgen);
								}
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.LONG)
								{
									getLongValueMethod.EmitCall(ilgen);
								}
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.DOUBLE)
								{
									getDoubleValueMethod.EmitCall(ilgen);
								}
								else
								{
									throw new InvalidOperationException();
								}
							}
							else
							{
								getValueMethod.EmitCall(ilgen);
								o.methods[i].ReturnType.EmitCheckcast(null, ilgen);
							}
							ilgen.Emit(OpCodes.Ret);

							if(o.classFile.Methods[i].AnnotationDefault != null
								&& !(o.methods[i].Name == "value" && requiredArgCount == 0))
							{
								// now add a .NET property for this annotation optional parameter
								Type argType = TypeWrapperToAnnotationParameterType(o.methods[i].ReturnType);
								if(argType != null)
								{
									PropertyBuilder pb = attributeTypeBuilder.DefineProperty(o.methods[i].Name, PropertyAttributes.None, argType, Type.EmptyTypes);
									AttributeHelper.HideFromJava(pb);
									MethodBuilder setter = attributeTypeBuilder.DefineMethod("set_" + o.methods[i].Name, MethodAttributes.Public, typeof(void), new Type[] { argType });
									AttributeHelper.HideFromJava(setter);
									pb.SetSetMethod(setter);
									ilgen = CodeEmitter.Create(setter);
									EmitSetValueCall(annotationAttributeBaseType, ilgen, o.methods[i].Name, o.methods[i].ReturnType, 1);
									ilgen.Emit(OpCodes.Ret);
									MethodBuilder getter = attributeTypeBuilder.DefineMethod("get_" + o.methods[i].Name, MethodAttributes.Public, argType, Type.EmptyTypes);
									AttributeHelper.HideFromJava(getter);
									pb.SetGetMethod(getter);
									// TODO implement the getter method
									CodeEmitter.Create(getter).ThrowException(typeof(NotImplementedException));
								}
							}
						}
					}
					attributeTypeBuilder.CreateType();
				}

				internal override void Apply(ClassLoaderWrapper loader, TypeBuilder tb, object annotation)
				{
					Link();
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						tb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, MethodBuilder mb, object annotation)
				{
					Link();
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						mb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, ConstructorBuilder cb, object annotation)
				{
					Link();
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						cb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, FieldBuilder fb, object annotation)
				{
					Link();
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						fb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, ParameterBuilder pb, object annotation)
				{
					Link();
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						pb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, AssemblyBuilder ab, object annotation)
				{
					Link();
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						ab.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, PropertyBuilder pb, object annotation)
				{
					Link();
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						pb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
				}
			}
#endif // STATIC_COMPILER

			internal override TypeWrapper[] InnerClasses
			{
				get
				{
					throw new InvalidOperationException("InnerClasses is only available for finished types");
				}
			}

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
				{
					throw new InvalidOperationException("DeclaringTypeWrapper is only available for finished types");
				}
			}

			internal override Modifiers ReflectiveModifiers
			{
				get
				{
					ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
					if(innerclasses != null)
					{
						for(int i = 0; i < innerclasses.Length; i++)
						{
							if(innerclasses[i].innerClass != 0)
							{
								if(classFile.GetConstantPoolClass(innerclasses[i].innerClass) == wrapper.Name)
								{
									return innerclasses[i].accessFlags;
								}
							}
						}
					}
					return classFile.Modifiers;
				}
			}

			private void UpdateClashTable()
			{
				lock(this)
				{
					if(memberclashtable == null)
					{
						memberclashtable = new Dictionary<string, string>();
						for(int i = 0; i < methods.Length; i++)
						{
							// TODO at the moment we don't support constructor signature clash resolving, so we better
							// not put them in the clash table
							if(methods[i].IsLinked && methods[i].GetMethod() != null && methods[i].Name != "<init>")
							{
								string key = GenerateClashKey("method", methods[i].RealName, methods[i].ReturnTypeForDefineMethod, methods[i].GetParametersForDefineMethod());
								memberclashtable.Add(key, key);
							}
						}
					}
				}
			}

			private static string GenerateClashKey(string type, string name, Type retOrFieldType, Type[] args)
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder(type);
				sb.Append(':').Append(name).Append(':').Append(retOrFieldType.FullName);
				if(args != null)
				{
					foreach(Type t in args)
					{
						sb.Append(':').Append(t.FullName);
					}
				}
				return sb.ToString();
			}

			internal static ConstructorBuilder DefineClassInitializer(TypeBuilder typeBuilder)
			{
				if (typeBuilder.IsInterface)
				{
					// LAMESPEC the ECMA spec says (part. I, sect. 8.5.3.2) that all interface members must be public, so we make
					// the class constructor public.
					// NOTE it turns out that on .NET 2.0 this isn't necessary anymore (neither Ref.Emit nor the CLR verifier complain about it),
					// but the C# compiler still considers interfaces with non-public methods to be invalid, so to keep interop with C# we have
					// to keep making the .cctor method public.
					return typeBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
				}
				// NOTE we don't need to record the modifiers here, because they aren't visible from Java reflection
				return typeBuilder.DefineTypeInitializer();
			}

			// this finds the method that md is going to be overriding
			private MethodWrapper FindBaseMethod(string name, string sig, out bool explicitOverride)
			{
				Debug.Assert(!classFile.IsInterface);
				Debug.Assert(name != "<init>");

				explicitOverride = false;
				TypeWrapper tw = wrapper.BaseTypeWrapper;
				while(tw != null)
				{
					MethodWrapper baseMethod = tw.GetMethodWrapper(name, sig, true);
					if(baseMethod == null)
					{
						return null;
					}
					// here are the complex rules for determining whether this method overrides the method we found
					// RULE 1: final methods may not be overridden
					// (note that we intentionally not check IsStatic here!)
					if(baseMethod.IsFinal
						&& !baseMethod.IsPrivate
						&& (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)))
					{
						throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + baseMethod.DeclaringType.Name + " is overriden in " + wrapper.Name);
					}
					// RULE 1a: static methods are ignored (other than the RULE 1 check)
					if(baseMethod.IsStatic)
					{
					}
					// RULE 2: public & protected methods can be overridden (package methods are handled by RULE 4)
					// (by public, protected & *package* methods [even if they are in a different package])
					else if(baseMethod.IsPublic || baseMethod.IsProtected)
					{
						// if we already encountered a package method, we cannot override the base method of
						// that package method
						if(explicitOverride)
						{
							explicitOverride = false;
							return null;
						}
						return baseMethod;
					}
					// RULE 3: private and static methods are ignored
					else if(!baseMethod.IsPrivate)
					{
						// RULE 4: package methods can only be overridden in the same package
						if(baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)
							|| (baseMethod.IsInternal && baseMethod.DeclaringType.InternalsVisibleTo(wrapper)))
						{
							return baseMethod;
						}
						// since we encountered a method with the same name/signature that we aren't overriding,
						// we need to specify an explicit override
						// NOTE we only do this if baseMethod isn't private, because if it is, Reflection.Emit
						// will complain about the explicit MethodOverride (possibly a bug)
						explicitOverride = true;
					}
					tw = baseMethod.DeclaringType.BaseTypeWrapper;
				}
				return null;
			}

			internal string GenerateUniqueMethodName(string basename, MethodWrapper mw)
			{
				return GenerateUniqueMethodName(basename, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
			}

			internal string GenerateUniqueMethodName(string basename, Type returnType, Type[] parameterTypes)
			{
				string name = basename;
				string key = GenerateClashKey("method", name, returnType, parameterTypes);
				UpdateClashTable();
				lock (memberclashtable)
				{
					for (int clashcount = 0; memberclashtable.ContainsKey(key); clashcount++)
					{
						name = basename + "_" + clashcount;
						key = GenerateClashKey("method", name, returnType, parameterTypes);
					}
					memberclashtable.Add(key, key);
				}
				return name;
			}

			private static MethodInfo GetBaseFinalizeMethod(TypeWrapper wrapper)
			{
				for(;;)
				{
					// HACK we get called during method linking (which is probably a bad idea) and
					// it is possible for the base type not to be finished yet, so we look at the
					// private state of the unfinished base types to find the finalize method.
					DynamicTypeWrapper dtw = wrapper as DynamicTypeWrapper;
					if(dtw == null)
					{
						break;
					}
					MethodWrapper mw = dtw.GetMethodWrapper(StringConstants.FINALIZE, StringConstants.SIG_VOID, false);
					if(mw != null)
					{
						mw.Link();
					}
					MethodInfo finalizeImpl = dtw.impl.GetFinalizeMethod();
					if(finalizeImpl != null)
					{
						return finalizeImpl;
					}
					wrapper = wrapper.BaseTypeWrapper;
				}
				if(wrapper == CoreClasses.java.lang.Object.Wrapper || wrapper == CoreClasses.java.lang.Throwable.Wrapper)
				{
					return typeof(object).GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Instance);
				}
				Type type = wrapper.TypeAsBaseType;
				MethodInfo baseFinalize = type.GetMethod("__<Finalize>", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
				if(baseFinalize != null)
				{
					return baseFinalize;
				}
				while(type != null)
				{
					foreach(MethodInfo m in type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
					{
						if(m.Name == "Finalize"
							&& m.ReturnType == typeof(void)
							&& m.GetParameters().Length == 0)
						{
							if(m.GetBaseDefinition().DeclaringType == typeof(object))
							{
								return m;
							}
						}
					}
					type = type.BaseType;
				}
				return null;
			}

			private MethodAttributes GetPropertyAccess(MethodWrapper mw)
			{
				string sig = mw.ReturnType.SigName;
				if(sig == "V")
				{
					sig = mw.GetParameters()[0].SigName;
				}
				int access = -1;
				foreach(ClassFile.Field field in classFile.Fields)
				{
					if(field.IsProperty
						&& field.IsStatic == mw.IsStatic
						&& field.Signature == sig
						&& (field.PropertyGetter == mw.Name || field.PropertySetter == mw.Name))
					{
						int nacc;
						if(field.IsPublic)
						{
							nacc = 3;
						}
						else if(field.IsProtected)
						{
							nacc = 2;
						}
						else if(field.IsPrivate)
						{
							nacc = 0;
						}
						else
						{
							nacc = 1;
						}
						if(nacc > access)
						{
							access = nacc;
						}
					}
				}
				switch(access)
				{
					case 0:
						return MethodAttributes.Private;
					case 1:
						return MethodAttributes.Assembly;
					case 2:
						return MethodAttributes.FamORAssem;
					case 3:
						return MethodAttributes.Public;
					default:
						throw new InvalidOperationException();
				}
			}

			private MethodBase GenerateMethod(int index, bool unloadableOverrideStub)
			{
				methods[index].AssertLinked();
				Profiler.Enter("JavaTypeImpl.GenerateMethod");
				try
				{
					if(index >= classFile.Methods.Length)
					{
						if(methods[index].IsMirandaMethod)
						{
							// We're a Miranda method
							Debug.Assert(baseMethods[index].DeclaringType.IsInterface);
							string name = GenerateUniqueMethodName(methods[index].Name, baseMethods[index]);
							MethodBuilder mb = typeBuilder.DefineMethod(name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							AttributeHelper.HideFromReflection(mb);
#if STATIC_COMPILER
							if(unloadableOverrideStub || name != methods[index].Name)
							{
								// instead of creating an override stub, we created the Miranda method with the proper signature and
								// decorate it with a NameSigAttribute that contains the real signature
								AttributeHelper.SetNameSig(mb, methods[index].Name, methods[index].Signature);
							}
#endif // STATIC_COMPILER
							// if we changed the name or if the interface method name is remapped, we need to add an explicit methodoverride.
							if(!baseMethods[index].IsDynamicOnly && name != baseMethods[index].RealName)
							{
								typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethods[index].GetMethod());
							}
							return mb;
						}
						else if(methods[index].IsAccessStub)
						{
							Debug.Assert(!baseMethods[index].HasCallerID);
							MethodAttributes stubattribs = baseMethods[index].IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
							stubattribs |= MethodAttributes.HideBySig;
							if(baseMethods[index].IsStatic)
							{
								stubattribs |= MethodAttributes.Static;
							}
							else
							{
								stubattribs |= MethodAttributes.CheckAccessOnOverride | MethodAttributes.Virtual;
								if(baseMethods[index].IsAbstract && wrapper.IsAbstract)
								{
									stubattribs |= MethodAttributes.Abstract;
								}
								if(baseMethods[index].IsFinal)
								{
									// NOTE final methods still need to be virtual, because a subclass may need this method to
									// implement an interface method
									stubattribs |= MethodAttributes.Final | MethodAttributes.NewSlot;
								}
							}
							MethodBuilder mb = typeBuilder.DefineMethod(methods[index].Name, stubattribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							AttributeHelper.HideFromReflection(mb);
							if(!baseMethods[index].IsAbstract)
							{
								CodeEmitter ilgen = CodeEmitter.Create(mb);
								int argc = methods[index].GetParametersForDefineMethod().Length + (methods[index].IsStatic ? 0 : 1);
								for(int i = 0; i < argc; i++)
								{
									ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
								}
								baseMethods[index].EmitCall(ilgen);
								ilgen.Emit(OpCodes.Ret);
							}
							else if(!wrapper.IsAbstract)
							{
								CodeEmitter.Create(mb).EmitThrow("java.lang.AbstractMethodError", wrapper.Name + "." + methods[index].Name + methods[index].Signature);
							}
							return mb;
						}
						else
						{
							throw new InvalidOperationException();
						}
					}
					ClassFile.Method m = classFile.Methods[index];
					MethodBase method;
					bool setNameSig = methods[index].ReturnType.IsErasedOrBoxedPrimitiveOrRemapped;
					foreach(TypeWrapper tw in methods[index].GetParameters())
					{
						setNameSig |= tw.IsErasedOrBoxedPrimitiveOrRemapped;
					}
					bool setModifiers = false;
					if(methods[index].HasCallerID && (m.Modifiers & Modifiers.VarArgs) != 0)
					{
						// the implicit callerID parameter was added at the end so that means we shouldn't use ParamArrayAttribute,
						// so we need to explicitly record that the method is varargs
						setModifiers = true;
					}
					MethodAttributes attribs = MethodAttributes.HideBySig;
					if(m.IsNative)
					{
						if(wrapper.IsPInvokeMethod(m))
						{
							// this doesn't appear to be necessary, but we use the flag in Finish to know
							// that we shouldn't emit a method body
							attribs |= MethodAttributes.PinvokeImpl;
						}
						else
						{
							setModifiers = true;
						}
					}
					if(methods[index].IsPropertyAccessor)
					{
						attribs |= GetPropertyAccess(methods[index]);
						attribs |= MethodAttributes.SpecialName;
						setModifiers = true;
					}
					else
					{
						if(m.IsPrivate)
						{
							attribs |= MethodAttributes.Private;
						}
						else if(m.IsProtected)
						{
							attribs |= MethodAttributes.FamORAssem;
						}
						else if(m.IsPublic)
						{
							attribs |= MethodAttributes.Public;
						}
						else
						{
							attribs |= MethodAttributes.Assembly;
						}
					}
					if(ReferenceEquals(m.Name, StringConstants.INIT))
					{
						Type[][] modopt = null;
						if(setNameSig)
						{
							// we add optional modifiers to make the signature unique
							TypeWrapper[] parameters = methods[index].GetParameters();
							modopt = new Type[parameters.Length][];
							for(int i = 0; i < parameters.Length; i++)
							{
								if(parameters[i].IsGhostArray)
								{
									TypeWrapper elemTypeWrapper = parameters[i];
									while(elemTypeWrapper.IsArray)
									{
										elemTypeWrapper = elemTypeWrapper.ElementTypeWrapper;
									}
									modopt[i] = new Type[] { elemTypeWrapper.TypeAsTBD };
								}
								else if(parameters[i].IsBoxedPrimitive)
								{
									modopt[i] = new Type[] { typeof(object) };
								}
								else if(parameters[i].IsRemapped && parameters[i] is DotNetTypeWrapper)
								{
									modopt[i] = new Type[] { parameters[i].TypeAsSignatureType };
								}
								else if(parameters[i].IsUnloadable)
								{
									modopt[i] = new Type[] { wrapper.classLoader.GetTypeWrapperFactory().DefineUnloadable(parameters[i].Name) };
								}
							}
						}
						// strictfp is the only modifier that a constructor can have
						if(m.IsStrictfp)
						{
							setModifiers = true;
						}
						method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, methods[index].GetParametersForDefineMethod(), null, modopt);
						((ConstructorBuilder)method).SetImplementationFlags(MethodImplAttributes.NoInlining);
					}
					else if(m.IsClassInitializer)
					{
						method = DefineClassInitializer(typeBuilder);
					}
					else
					{
						if(m.IsAbstract)
						{
							// only if the classfile is abstract, we make the CLR method abstract, otherwise,
							// we have to generate a method that throws an AbstractMethodError (because the JVM
							// allows abstract methods in non-abstract classes)
							if(classFile.IsAbstract)
							{
								if(classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected))
								{
									setModifiers = true;
								}
								else
								{
									attribs |= MethodAttributes.Abstract;
								}
							}
							else
							{
								setModifiers = true;
							}
						}
						if(m.IsFinal)
						{
							if(!m.IsStatic && !m.IsPrivate)
							{
								attribs |= MethodAttributes.Final;
							}
							else
							{
								setModifiers = true;
							}
						}
						if(m.IsStatic)
						{
							attribs |= MethodAttributes.Static;
							if(m.IsSynchronized)
							{
								setModifiers = true;
							}
						}
						else if(!m.IsPrivate)
						{
							attribs |= MethodAttributes.Virtual | MethodAttributes.CheckAccessOnOverride;
						}
						string name = m.Name;
#if STATIC_COMPILER
						if((m.Modifiers & Modifiers.Bridge) != 0 && (m.IsPublic || m.IsProtected) && wrapper.IsPublic)
						{
							string sigbase = m.Signature.Substring(0, m.Signature.LastIndexOf(')') + 1);
							foreach(MethodWrapper mw in methods)
							{
								if(mw.Name == m.Name && mw.Signature.StartsWith(sigbase) && mw.Signature != m.Signature)
								{
									// To prevent bridge methods with covariant return types from confusing
									// other .NET compilers (like C#), we rename the bridge method.
									name = "<bridge>" + name;
									setNameSig = true;
									break;
								}
							}
						}
#endif
						// if a method is virtual, we need to find the method it overrides (if any), for several reasons:
						// - if we're overriding a method that has a different name (e.g. some of the virtual methods
						//   in System.Object [Equals <-> equals]) we need to add an explicit MethodOverride
						// - if one of the base classes has a similar method that is private (or package) that we aren't
						//   overriding, we need to specify an explicit MethodOverride
						MethodWrapper baseMce = baseMethods[index];
						bool explicitOverride = methods[index].IsExplicitOverride;
						if((attribs & MethodAttributes.Virtual) != 0 && !classFile.IsInterface)
						{
							// make sure the base method is already defined
							Debug.Assert(baseMce == null || baseMce.GetMethod() != null);
							if(baseMce == null || baseMce.DeclaringType.IsInterface)
							{
								// we need to set NewSlot here, to prevent accidentally overriding methods
								// (for example, if a Java class has a method "boolean Equals(object)", we don't want that method
								// to override System.Object.Equals)
								attribs |= MethodAttributes.NewSlot;
							}
							else
							{
								// if we have a method overriding a more accessible method (the JVM allows this), we need to make the
								// method more accessible, because otherwise the CLR will complain that we're reducing access
								MethodBase baseMethod = baseMce.GetMethod();
								if((baseMethod.IsPublic && !m.IsPublic) ||
									((baseMethod.IsFamily || baseMethod.IsFamilyOrAssembly) && !m.IsPublic && !m.IsProtected) ||
									(!m.IsPublic && !m.IsProtected && !baseMce.DeclaringType.IsPackageAccessibleFrom(wrapper)))
								{
									attribs &= ~MethodAttributes.MemberAccessMask;
									attribs |= baseMethod.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
									setModifiers = true;
								}
							}
						}
						MethodBuilder mb = null;
#if STATIC_COMPILER
						mb = wrapper.DefineGhostMethod(name, attribs, methods[index]);
#endif
						if(mb == null)
						{
							bool needFinalize = false;
							bool needDispatch = false;
							MethodInfo baseFinalize = null;
							if(baseMce != null && ReferenceEquals(m.Name, StringConstants.FINALIZE) && ReferenceEquals(m.Signature, StringConstants.SIG_VOID))
							{
								baseFinalize = GetBaseFinalizeMethod(wrapper.BaseTypeWrapper);
								if(baseMce.DeclaringType == CoreClasses.java.lang.Object.Wrapper)
								{
									// This type is the first type in the hierarchy to introduce a finalize method
									// (other than the one in java.lang.Object obviously), so we need to override
									// the real Finalize method and emit a dispatch call to our finalize method.
									needFinalize = true;
									needDispatch = true;
								}
								else if(m.IsFinal)
								{
									// One of our base classes already has a  finalize method, so we already are
									// hooked into the real Finalize, but we need to override it again, to make it
									// final (so that non-Java types cannot override it either).
									needFinalize = true;
									needDispatch = false;
									// If the base class finalize was optimized away, we need a dispatch call after all.
									if(baseFinalize.DeclaringType == typeof(object))
									{
										needDispatch = true;
									}
								}
								else
								{
									// One of our base classes already has a finalize method, but it may have been an empty
									// method so that the hookup to the real Finalize was optimized away, we need to check
									// for that.
									if(baseFinalize.DeclaringType == typeof(object))
									{
										needFinalize = true;
										needDispatch = true;
									}
								}
								if(needFinalize &&
									!m.IsAbstract && !m.IsNative &&
									(!m.IsFinal || classFile.IsFinal) &&
									m.Instructions.Length > 0 &&
									m.Instructions[0].NormalizedOpCode == NormalizedByteCode.__return)
								{
									// we've got an empty finalize method, so we don't need to override the real finalizer
									// (not having a finalizer makes a huge perf difference)
									needFinalize = false;
								}
							}
							if(setNameSig || memberclashtable != null)
							{
								// TODO we really should make sure that the name we generate doesn't already exist in a
								// base class (not in the Java method namespace, but in the CLR method namespace)
								name = GenerateUniqueMethodName(name, methods[index]);
								if(name != m.Name)
								{
									setNameSig = true;
								}
							}
							bool needMethodImpl = baseMce != null && (setNameSig || explicitOverride || baseMce.RealName != name) && !needFinalize;
							if(unloadableOverrideStub || needMethodImpl)
							{
								attribs |= MethodAttributes.NewSlot;
							}
							mb = typeBuilder.DefineMethod(name, attribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							if(unloadableOverrideStub)
							{
								GenerateUnloadableOverrideStub(wrapper, typeBuilder, baseMce, mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							}
							else if(needMethodImpl)
							{
								// assert that the method we're overriding is in fact virtual and not final!
								Debug.Assert(baseMce.GetMethod().IsVirtual && !baseMce.GetMethod().IsFinal);
								typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMce.GetMethod());
							}
							if(!m.IsStatic && !m.IsAbstract && !m.IsPrivate && baseMce != null && !baseMce.DeclaringType.IsPackageAccessibleFrom(wrapper))
							{
								// we may have to explicitly override another package accessible abstract method
								TypeWrapper btw = baseMce.DeclaringType.BaseTypeWrapper;
								while(btw != null)
								{
									MethodWrapper bmw = btw.GetMethodWrapper(m.Name, m.Signature, true);
									if(bmw == null)
									{
										break;
									}
									if(bmw.DeclaringType.IsPackageAccessibleFrom(wrapper) && bmw.IsAbstract && !(bmw.IsPublic || bmw.IsProtected))
									{
										if(bmw != baseMce)
										{
											typeBuilder.DefineMethodOverride(mb, (MethodInfo)bmw.GetMethod());
										}
										break;
									}
									btw = bmw.DeclaringType.BaseTypeWrapper;
								}
							}
							// if we're overriding java.lang.Object.finalize we need to emit a stub to override System.Object.Finalize,
							// or if we're subclassing a non-Java class that has a Finalize method, we need a new Finalize override
							if(needFinalize)
							{
								string finalizeName = baseFinalize.Name;
								MethodWrapper mwClash = wrapper.GetMethodWrapper(finalizeName, StringConstants.SIG_VOID, true);
								if(mwClash != null && mwClash.GetMethod() != baseFinalize)
								{
									finalizeName = "__<Finalize>";
								}
								MethodAttributes attr = MethodAttributes.HideBySig | MethodAttributes.Virtual;
								// make sure we don't reduce accessibility
								attr |= baseFinalize.IsPublic ? MethodAttributes.Public : MethodAttributes.Family;
								if(m.IsFinal)
								{
									attr |= MethodAttributes.Final;
								}
								finalizeMethod = typeBuilder.DefineMethod(finalizeName, attr, CallingConventions.Standard, typeof(void), Type.EmptyTypes);
								if(finalizeName != baseFinalize.Name)
								{
									typeBuilder.DefineMethodOverride(finalizeMethod, baseFinalize);
								}
								AttributeHelper.HideFromJava(finalizeMethod);
								CodeEmitter ilgen = CodeEmitter.Create(finalizeMethod);
								ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.SkipFinalizer);
								CodeEmitterLabel skip = ilgen.DefineLabel();
								ilgen.Emit(OpCodes.Brtrue_S, skip);
								if(needDispatch)
								{
									ilgen.BeginExceptionBlock();
									ilgen.Emit(OpCodes.Ldarg_0);
									ilgen.Emit(OpCodes.Callvirt, mb);
									ilgen.BeginCatchBlock(typeof(object));
									ilgen.EndExceptionBlock();
								}
								else
								{
									ilgen.Emit(OpCodes.Ldarg_0);
									ilgen.Emit(OpCodes.Call, baseFinalize);
								}
								ilgen.MarkLabel(skip);
								ilgen.Emit(OpCodes.Ret);
							}
#if STATIC_COMPILER
							if(classFile.Methods[index].AnnotationDefault != null)
							{
								CustomAttributeBuilder cab = new CustomAttributeBuilder(StaticCompiler.GetType("IKVM.Attributes.AnnotationDefaultAttribute").GetConstructor(new Type[] { typeof(object) }), new object[] { classFile.Methods[index].AnnotationDefault });
								mb.SetCustomAttribute(cab);
							}
#endif // STATIC_COMPILER
						}
						method = mb;
					}
					string[] exceptions = m.ExceptionsAttribute;
					methods[index].SetDeclaredExceptions(exceptions);
#if STATIC_COMPILER
					AttributeHelper.SetThrowsAttribute(method, exceptions);
					if(setModifiers || m.IsInternal || (m.Modifiers & (Modifiers.Synthetic | Modifiers.Bridge)) != 0)
					{
						if(method is ConstructorBuilder)
						{
							AttributeHelper.SetModifiers((ConstructorBuilder)method, m.Modifiers, m.IsInternal);
						}
						else
						{
							AttributeHelper.SetModifiers((MethodBuilder)method, m.Modifiers, m.IsInternal);
						}
					}
					if((m.Modifiers & (Modifiers.Synthetic | Modifiers.Bridge)) != 0
						&& (m.IsPublic || m.IsProtected)
						&& wrapper.IsPublic
						&& !IsAccessBridge(classFile, m))
					{
						if(method is ConstructorBuilder)
						{
							AttributeHelper.SetEditorBrowsableNever((ConstructorBuilder)method);
						}
						else
						{
							AttributeHelper.SetEditorBrowsableNever((MethodBuilder)method);
						}
						// TODO on WHIDBEY apply CompilerGeneratedAttribute
					}
					if(m.DeprecatedAttribute)
					{
						AttributeHelper.SetDeprecatedAttribute(method);
					}
					if(setNameSig)
					{
						AttributeHelper.SetNameSig(method, m.Name, m.Signature);
					}
					if(m.GenericSignature != null)
					{
						AttributeHelper.SetSignatureAttribute(method, m.GenericSignature);
					}
#else // STATIC_COMPILER
					if(setModifiers)
					{
						// shut up the compiler
					}
#endif // STATIC_COMPILER
					return method;
				}
				finally
				{
					Profiler.Leave("JavaTypeImpl.GenerateMethod");
				}
			}

#if STATIC_COMPILER
			// The classic example of an access bridge is StringBuilder.length(), the JDK 6 compiler
			// generates this to work around a reflection problem (which otherwise wouldn't surface the
			// length() method, because it is defined in the non-public base class AbstractStringBuilder.)
			private static bool IsAccessBridge(ClassFile classFile, ClassFile.Method m)
			{
				// HACK this is a pretty gross hack
				// We look at the method body to figure out if the bridge method calls another method with the exact
				// same name/signature and if that is the case, we assume that it is an access bridge.
				// This code is based on the javac algorithm in addBridgeIfNeeded(...) in com/sun/tools/javac/comp/TransTypes.java.
				if ((m.Modifiers & (Modifiers.Abstract | Modifiers.Native | Modifiers.Public | Modifiers.Bridge)) == (Modifiers.Public | Modifiers.Bridge))
				{
					foreach (ClassFile.Method.Instruction instr in m.Instructions)
					{
						if (instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
						{
							ClassFile.ConstantPoolItemMI cpi = classFile.SafeGetMethodref(instr.Arg1);
							return cpi != null && cpi.Name == m.Name && cpi.Signature == m.Signature;
						}
					}
				}
				return false;
			}
#endif // STATIC_COMPILER

			internal static void GenerateUnloadableOverrideStub(DynamicTypeWrapper wrapper, TypeBuilder typeBuilder, MethodWrapper baseMethod, MethodInfo target, Type targetRet, Type[] targetArgs)
			{
				Debug.Assert(!baseMethod.HasCallerID);

				Type stubret = baseMethod.ReturnTypeForDefineMethod;
				Type[] stubargs = baseMethod.GetParametersForDefineMethod();
				string name = wrapper.GenerateUniqueMethodName(baseMethod.RealName + "/unloadablestub", baseMethod);
				MethodBuilder overrideStub = typeBuilder.DefineMethod(name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final, stubret, stubargs);
				AttributeHelper.HideFromJava(overrideStub);
				typeBuilder.DefineMethodOverride(overrideStub, (MethodInfo)baseMethod.GetMethod());
				CodeEmitter ilgen = CodeEmitter.Create(overrideStub);
				ilgen.Emit(OpCodes.Ldarg_0);
				for (int i = 0; i < targetArgs.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldarg_S, (byte)(i + 1));
					if (targetArgs[i] != stubargs[i])
					{
						ilgen.Emit(OpCodes.Castclass, targetArgs[i]);
					}
				}
				ilgen.Emit(OpCodes.Callvirt, target);
				if (targetRet != stubret)
				{
					ilgen.Emit(OpCodes.Castclass, stubret);
				}
				ilgen.Emit(OpCodes.Ret);
			}

			internal override Type Type
			{
				get
				{
					return typeBuilder;
				}
			}

			internal override string GetGenericSignature()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override string[] GetEnclosingMethod()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override string GetGenericMethodSignature(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override string GetGenericFieldSignature(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[] GetDeclaredAnnotations()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object GetMethodDefaultValue(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[] GetMethodAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[][] GetParameterAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[] GetFieldAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override MethodInfo GetFinalizeMethod()
			{
				return finalizeMethod;
			}

#if STATIC_COMPILER
			internal override Annotation Annotation
			{
				get
				{
					return annotationBuilder;
				}
			}

			internal override Type EnumType
			{
				get
				{
					return enumBuilder;
				}
			}
#endif // STATIC_COMPILER
		}

		private sealed class Metadata
		{
			private string[] genericMetaData;
			private object[][] annotations;

			private Metadata(string[] genericMetaData, object[][] annotations)
			{
				this.genericMetaData = genericMetaData;
				this.annotations = annotations;
			}

			internal static Metadata Create(ClassFile classFile)
			{
				if(classFile.MajorVersion < 49)
				{
					return null;
				}
				string[] genericMetaData = null;
				object[][] annotations = null;
				for(int i = 0; i < classFile.Methods.Length; i++)
				{
					if(classFile.Methods[i].GenericSignature != null)
					{
						if(genericMetaData == null)
						{
							genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
						}
						genericMetaData[i + 4] = classFile.Methods[i].GenericSignature;
					}
					if(classFile.Methods[i].Annotations != null)
					{
						if(annotations == null)
						{
							annotations = new object[5][];
						}
						if(annotations[1] == null)
						{
							annotations[1] = new object[classFile.Methods.Length];
						}
						annotations[1][i] = classFile.Methods[i].Annotations;
					}
					if(classFile.Methods[i].ParameterAnnotations != null)
					{
						if(annotations == null)
						{
							annotations = new object[5][];
						}
						if(annotations[2] == null)
						{
							annotations[2] = new object[classFile.Methods.Length];
						}
						annotations[2][i] = classFile.Methods[i].ParameterAnnotations;
					}
					if(classFile.Methods[i].AnnotationDefault != null)
					{
						if(annotations == null)
						{
							annotations = new object[5][];
						}
						if(annotations[3] == null)
						{
							annotations[3] = new object[classFile.Methods.Length];
						}
						annotations[3][i] = classFile.Methods[i].AnnotationDefault;
					}
				}
				for(int i = 0; i < classFile.Fields.Length; i++)
				{
					if(classFile.Fields[i].GenericSignature != null)
					{
						if(genericMetaData == null)
						{
							genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
						}
						genericMetaData[i + 4 + classFile.Methods.Length] = classFile.Fields[i].GenericSignature;
					}
					if(classFile.Fields[i].Annotations != null)
					{
						if(annotations == null)
						{
							annotations = new object[5][];
						}
						if(annotations[4] == null)
						{
							annotations[4] = new object[classFile.Fields.Length][];
						}
						annotations[4][i] = classFile.Fields[i].Annotations;
					}
				}
				if(classFile.EnclosingMethod != null)
				{
					if(genericMetaData == null)
					{
						genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
					}
					genericMetaData[0] = classFile.EnclosingMethod[0];
					genericMetaData[1] = classFile.EnclosingMethod[1];
					genericMetaData[2] = classFile.EnclosingMethod[2];
				}
				if(classFile.GenericSignature != null)
				{
					if(genericMetaData == null)
					{
						genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
					}
					genericMetaData[3] = classFile.GenericSignature;
				}
				if(classFile.Annotations != null)
				{
					if(annotations == null)
					{
						annotations = new object[5][];
					}
					annotations[0] = classFile.Annotations;
				}
				if(genericMetaData != null || annotations != null)
				{
					return new Metadata(genericMetaData, annotations);
				}
				return null;
			}

			internal static string GetGenericSignature(Metadata m)
			{
				if(m != null && m.genericMetaData != null)
				{
					return m.genericMetaData[3];
				}
				return null;
			}

			internal static string[] GetEnclosingMethod(Metadata m)
			{
				if(m != null && m.genericMetaData != null && m.genericMetaData[0] != null)
				{
					return new string[] { m.genericMetaData[0], m.genericMetaData[1], m.genericMetaData[2] };
				}
				return null;
			}

			internal static string GetGenericMethodSignature(Metadata m, int index)
			{
				if(m != null && m.genericMetaData != null)
				{
					return m.genericMetaData[index + 4];
				}
				return null;
			}

			// note that the caller is responsible for computing the correct index (field index + method count)
			internal static string GetGenericFieldSignature(Metadata m, int index)
			{
				if(m != null && m.genericMetaData != null)
				{
					return m.genericMetaData[index + 4];
				}
				return null;
			}

			internal static object[] GetAnnotations(Metadata m)
			{
				if(m != null && m.annotations != null)
				{
					return m.annotations[0];
				}
				return null;
			}

			internal static object[] GetMethodAnnotations(Metadata m, int index)
			{
				if(m != null && m.annotations != null && m.annotations[1] != null)
				{
					return (object[])m.annotations[1][index];
				}
				return null;
			}

			internal static object[][] GetMethodParameterAnnotations(Metadata m, int index)
			{
				if(m != null && m.annotations != null && m.annotations[2] != null)
				{
					return (object[][])m.annotations[2][index];
				}
				return null;
			}

			internal static object GetMethodDefaultValue(Metadata m, int index)
			{
				if(m != null && m.annotations != null && m.annotations[3] != null)
				{
					return m.annotations[3][index];
				}
				return null;
			}

			// note that unlike GetGenericFieldSignature, the index is simply the field index 
			internal static object[] GetFieldAnnotations(Metadata m, int index)
			{
				if(m != null && m.annotations != null && m.annotations[4] != null)
				{
					return (object[])m.annotations[4][index];
				}
				return null;
			}
		}
	
		private sealed class FinishedTypeImpl : DynamicImpl
		{
			private Type type;
			private TypeWrapper[] innerclasses;
			private TypeWrapper declaringTypeWrapper;
			private Modifiers reflectiveModifiers;
			private MethodInfo clinitMethod;
			private MethodInfo finalizeMethod;
			private Metadata metadata;
#if STATIC_COMPILER
			private Annotation annotationBuilder;
			private TypeBuilder enumBuilder;
#endif

			internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers, Metadata metadata, MethodInfo clinitMethod, MethodInfo finalizeMethod
#if STATIC_COMPILER
				, Annotation annotationBuilder
				, TypeBuilder enumBuilder
#endif
				)
			{
				this.type = type;
				this.innerclasses = innerclasses;
				this.declaringTypeWrapper = declaringTypeWrapper;
				this.reflectiveModifiers = reflectiveModifiers;
				this.clinitMethod = clinitMethod;
				this.finalizeMethod = finalizeMethod;
				this.metadata = metadata;
#if STATIC_COMPILER
				this.annotationBuilder = annotationBuilder;
				this.enumBuilder = enumBuilder;
#endif
			}

			internal override TypeWrapper[] InnerClasses
			{
				get
				{
					// TODO compute the innerclasses lazily (and fix JavaTypeImpl to not always compute them)
					return innerclasses;
				}
			}

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
				{
					// TODO compute lazily (and fix JavaTypeImpl to not always compute it)
					return declaringTypeWrapper;
				}
			}

			internal override Modifiers ReflectiveModifiers
			{
				get
				{
					return reflectiveModifiers;
				}
			}

			internal override Type Type
			{
				get
				{
					return type;
				}
			}

			internal override void EmitRunClassConstructor(CodeEmitter ilgen)
			{
				if(clinitMethod != null)
				{
					ilgen.Emit(OpCodes.Call, clinitMethod);
				}
			}

			internal override DynamicImpl Finish()
			{
				return this;
			}

			internal override MethodBase LinkMethod(MethodWrapper mw)
			{
				// we should never be called, because all methods on a finished type are already linked
				Debug.Assert(false);
				return mw.GetMethod();
			}

			internal override FieldInfo LinkField(FieldWrapper fw)
			{
				// we should never be called, because all fields on a finished type are already linked
				Debug.Assert(false);
				return fw.GetField();
			}

			internal override string GetGenericSignature()
			{
				return Metadata.GetGenericSignature(metadata);
			}

			internal override string[] GetEnclosingMethod()
			{
				return Metadata.GetEnclosingMethod(metadata);
			}

			internal override string GetGenericMethodSignature(int index)
			{
				return Metadata.GetGenericMethodSignature(metadata, index);
			}

			// note that the caller is responsible for computing the correct index (field index + method count)
			internal override string GetGenericFieldSignature(int index)
			{
				return Metadata.GetGenericFieldSignature(metadata, index);
			}

			internal override object[] GetDeclaredAnnotations()
			{
				return Metadata.GetAnnotations(metadata);
			}

			internal override object GetMethodDefaultValue(int index)
			{
				return Metadata.GetMethodDefaultValue(metadata, index);
			}

			internal override object[] GetMethodAnnotations(int index)
			{
				return Metadata.GetMethodAnnotations(metadata, index);
			}

			internal override object[][] GetParameterAnnotations(int index)
			{
				return Metadata.GetMethodParameterAnnotations(metadata, index);
			}

			internal override object[] GetFieldAnnotations(int index)
			{
				return Metadata.GetFieldAnnotations(metadata, index);
			}

			internal override MethodInfo GetFinalizeMethod()
			{
				return finalizeMethod;
			}

#if STATIC_COMPILER
			internal override Annotation Annotation
			{
				get
				{
					return annotationBuilder;
				}
			}

			internal override Type EnumType
			{
				get
				{
					return enumBuilder;
				}
			}
#endif // STATIC_COMPILER
		}

		internal sealed class FinishContext
		{
			private readonly ClassFile classFile;
			private readonly DynamicTypeWrapper wrapper;
			private readonly TypeBuilder typeBuilder;
			private TypeBuilder typeCallerID;
			private MethodInfo callerIDMethod;
			private List<System.Threading.ThreadStart> postFinishProcs;

			internal FinishContext(ClassFile classFile, DynamicTypeWrapper wrapper, TypeBuilder typeBuilder)
			{
				this.classFile = classFile;
				this.wrapper = wrapper;
				this.typeBuilder = typeBuilder;
			}

			internal void EmitCallerID(CodeEmitter ilgen)
			{
				if (callerIDMethod == null)
				{
					CreateGetCallerID();
				}
				ilgen.Emit(OpCodes.Call, callerIDMethod);
			}

			private void CreateGetCallerID()
			{
				TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
				FieldBuilder callerIDField = typeBuilder.DefineField("__<callerID>", tw.TypeAsSignatureType, FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.SpecialName);
				MethodBuilder mb = typeBuilder.DefineMethod("__<GetCallerID>", MethodAttributes.Private | MethodAttributes.Static | MethodAttributes.SpecialName, tw.TypeAsSignatureType, Type.EmptyTypes);
				callerIDMethod = mb;
				CodeEmitter ilgen = CodeEmitter.Create(mb);
				ilgen.Emit(OpCodes.Ldsfld, callerIDField);
				CodeEmitterLabel done = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brtrue_S, done);
				EmitCallerIDInitialization(ilgen, callerIDField);
				ilgen.MarkLabel(done);
				ilgen.Emit(OpCodes.Ldsfld, callerIDField);
				ilgen.Emit(OpCodes.Ret);
			}

			internal void RegisterPostFinishProc(System.Threading.ThreadStart proc)
			{
				if (postFinishProcs == null)
				{
					postFinishProcs = new List<System.Threading.ThreadStart>();
				}
				postFinishProcs.Add(proc);
			}

			internal Type FinishImpl()
			{
				MethodWrapper[] methods = wrapper.GetMethods();
				FieldWrapper[] fields = wrapper.GetFields();
#if STATIC_COMPILER
				wrapper.FinishGhost(typeBuilder, methods);
#endif // STATIC_COMPILER
				// if we're not abstract make sure we don't inherit any abstract methods
				if (!wrapper.IsAbstract)
				{
					TypeWrapper parent = wrapper.BaseTypeWrapper;
					// if parent is not abstract, the .NET implementation will never have abstract methods (only
					// stubs that throw AbstractMethodError)
					// NOTE interfaces are supposed to be abstract, but the VM doesn't enforce this, so
					// we have to check for a null parent (interfaces have no parent).
					while (parent != null && parent.IsAbstract)
					{
						foreach (MethodWrapper mw in parent.GetMethods())
						{
							MethodInfo mi = mw.GetMethod() as MethodInfo;
							if (mi != null && mi.IsAbstract && !mi.DeclaringType.IsInterface)
							{
								bool needStub = false;
								bool needRename = false;
								if (mw.IsPublic || mw.IsProtected)
								{
									MethodWrapper fmw = wrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
									while (fmw != mw && (fmw.IsStatic || fmw.IsPrivate))
									{
										needRename = true;
										fmw = fmw.DeclaringType.BaseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
									}
									if (fmw == mw && fmw.DeclaringType != wrapper)
									{
										needStub = true;
									}
								}
								else
								{
									MethodWrapper fmw = wrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
									while (fmw != mw && (fmw.IsStatic || fmw.IsPrivate || !fmw.DeclaringType.IsPackageAccessibleFrom(mw.DeclaringType)))
									{
										needRename = true;
										fmw = fmw.DeclaringType.BaseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
									}
									if (fmw == mw && fmw.DeclaringType != wrapper)
									{
										needStub = true;
									}
								}
								if (needStub)
								{
									// NOTE in Sun's JRE 1.4.1 this method cannot be overridden by subclasses,
									// but I think this is a bug, so we'll support it anyway.
									string name = mi.Name;
									MethodAttributes attr = mi.Attributes & ~(MethodAttributes.Abstract | MethodAttributes.NewSlot);
									if (needRename)
									{
										name = "__<>" + name + "/" + mi.DeclaringType.FullName;
										attr = MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot;
									}
									MethodBuilder mb = typeBuilder.DefineMethod(name, attr, CallingConventions.Standard, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
									if (needRename)
									{
										typeBuilder.DefineMethodOverride(mb, mi);
									}
									AttributeHelper.HideFromJava(mb);
									CodeEmitter.Create(mb).EmitThrow("java.lang.AbstractMethodError", mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
								}
							}
						}
						parent = parent.BaseTypeWrapper;
					}
				}
				Dictionary<MethodKey, MethodInfo> invokespecialstubcache = new Dictionary<MethodKey, MethodInfo>();
				bool basehasclinit = wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasStaticInitializer;
				int clinitIndex = -1;
				bool hasConstructor = false;
				for (int i = 0; i < classFile.Methods.Length; i++)
				{
					ClassFile.Method m = classFile.Methods[i];
					MethodBase mb = methods[i].GetMethod();
					if (mb == null)
					{
						// method doesn't really exist (e.g. delegate constructor or <clinit> that is optimized away)
						if (m.Name == StringConstants.INIT)
						{
							hasConstructor = true;
						}
					}
					else if (mb is ConstructorBuilder)
					{
						if (m.IsClassInitializer)
						{
							// we handle the <clinit> after we've done the other methods,
							// to make it easier to inject code needed by the other methods
							clinitIndex = i;
							continue;
						}
						else
						{
							hasConstructor = true;
						}
						CodeEmitter ilGenerator = CodeEmitter.Create((ConstructorBuilder)mb);
						CompileConstructorBody(this, ilGenerator, i, invokespecialstubcache);
					}
					else
					{
						if (m.IsAbstract)
						{
							bool stub = false;
							if (!classFile.IsAbstract)
							{
								// NOTE in the JVM it is apparently legal for a non-abstract class to have abstract methods, but
								// the CLR doens't allow this, so we have to emit a method that throws an AbstractMethodError
								stub = true;
							}
							else if (classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected))
							{
								// We have an abstract package accessible method in our public class. To allow a class in another
								// assembly to subclass this class, we must fake the abstractness of this method.
								stub = true;
							}
							if (stub)
							{
								CodeEmitter ilGenerator = CodeEmitter.Create((MethodBuilder)mb);
								TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
								ilGenerator.EmitThrow("java.lang.AbstractMethodError", classFile.Name + "." + m.Name + m.Signature);
							}
						}
						else if (m.IsNative)
						{
							if ((mb.Attributes & MethodAttributes.PinvokeImpl) != 0)
							{
								continue;
							}
							if (wrapper.IsDelegate)
							{
								((MethodBuilder)mb).SetImplementationFlags(mb.GetMethodImplementationFlags() | MethodImplAttributes.Runtime);
								continue;
							}
							Profiler.Enter("JavaTypeImpl.Finish.Native");
							try
							{
								CodeEmitter ilGenerator = CodeEmitter.Create((MethodBuilder)mb);
								TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
#if STATIC_COMPILER
								// do we have a native implementation in map.xml?
								if (wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
								{
									continue;
								}
#endif
								// see if there exists a IKVM.NativeCode class for this type
								Type nativeCodeType = null;
#if STATIC_COMPILER
								nativeCodeType = StaticCompiler.GetType("IKVM.NativeCode." + classFile.Name.Replace('$', '+'), false);
#endif
								MethodInfo nativeMethod = null;
								TypeWrapper[] args = methods[i].GetParameters();
								if (nativeCodeType != null)
								{
									TypeWrapper[] nargs = args;
									if (!m.IsStatic)
									{
										nargs = new TypeWrapper[args.Length + 1];
										args.CopyTo(nargs, 1);
										nargs[0] = this.wrapper;
									}
									MethodInfo[] nativeCodeTypeMethods = nativeCodeType.GetMethods(BindingFlags.Static | BindingFlags.Public);
									foreach (MethodInfo method in nativeCodeTypeMethods)
									{
										ParameterInfo[] param = method.GetParameters();
										TypeWrapper[] match = new TypeWrapper[param.Length];
										for (int j = 0; j < param.Length; j++)
										{
											match[j] = ClassLoaderWrapper.GetWrapperFromType(param[j].ParameterType);
										}
										if (m.Name == method.Name && IsCompatibleArgList(nargs, match))
										{
											// TODO instead of taking the first matching method, we should find the best one
											nativeMethod = method;
											break;
										}
									}
								}
								if (nativeMethod != null)
								{
									int add = 0;
									if (!m.IsStatic)
									{
										ilGenerator.Emit(OpCodes.Ldarg_0);
										add = 1;
									}
									for (int j = 0; j < args.Length; j++)
									{
										ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
									}
									ilGenerator.Emit(OpCodes.Call, nativeMethod);
									TypeWrapper retTypeWrapper = methods[i].ReturnType;
									if (!retTypeWrapper.TypeAsTBD.Equals(nativeMethod.ReturnType) && !retTypeWrapper.IsGhost)
									{
										ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
									}
									ilGenerator.Emit(OpCodes.Ret);
								}
								else
								{
									if (wrapper.classLoader.NoJNI)
									{
										// since NoJniStubs can only be set when we're statically compiling, it is safe to use the "compiler" trace switch
										Tracer.Warning(Tracer.Compiler, "Native method not implemented: {0}.{1}.{2}", classFile.Name, m.Name, m.Signature);
										ilGenerator.EmitThrow("java.lang.UnsatisfiedLinkError", "Native method not implemented (compiled with -nojni): " + classFile.Name + "." + m.Name + m.Signature);
									}
									else
									{
										if (JVM.IsSaveDebugImage)
										{
#if !STATIC_COMPILER
											JniProxyBuilder.Generate(this, ilGenerator, wrapper, methods[i], typeBuilder, classFile, m, args);
#endif // !STATIC_COMPILER
										}
										else
										{
											JniBuilder.Generate(this, ilGenerator, wrapper, methods[i], typeBuilder, classFile, m, args, false);
										}
									}
								}
							}
							finally
							{
								Profiler.Leave("JavaTypeImpl.Finish.Native");
							}
						}
						else
						{
							MethodBuilder mbld = (MethodBuilder)mb;
							CodeEmitter ilGenerator = CodeEmitter.Create(mbld);
							TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
#if STATIC_COMPILER
							if (wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
							{
								continue;
							}
#endif // STATIC_COMPILER
							LineNumberTableAttribute.LineNumberWriter lineNumberTable = null;
							bool nonleaf = false;
							Compiler.Compile(this, wrapper, methods[i], classFile, m, ilGenerator, ref nonleaf, invokespecialstubcache, ref lineNumberTable);
							ilGenerator.CheckLabels();
							if (nonleaf)
							{
								mbld.SetImplementationFlags(mbld.GetMethodImplementationFlags() | MethodImplAttributes.NoInlining);
							}
							if (lineNumberTable != null)
							{
#if STATIC_COMPILER
								AttributeHelper.SetLineNumberTable(methods[i].GetMethod(), lineNumberTable);
#else // STATIC_COMPILER
								if (wrapper.lineNumberTables == null)
								{
									wrapper.lineNumberTables = new byte[methods.Length][];
								}
								wrapper.lineNumberTables[i] = lineNumberTable.ToArray();
#endif // STATIC_COMPILER
							}
						}
					}
				}

				if (clinitIndex != -1 || (basehasclinit && !classFile.IsInterface) || classFile.HasInitializedFields)
				{
					ConstructorBuilder cb;
					if (clinitIndex != -1)
					{
						cb = (ConstructorBuilder)methods[clinitIndex].GetMethod();
					}
					else
					{
						cb = JavaTypeImpl.DefineClassInitializer(typeBuilder);
						AttributeHelper.HideFromJava(cb);
					}
					CodeEmitter ilGenerator = CodeEmitter.Create(cb);
					// before we call the base class initializer, we need to set the non-final static ConstantValue fields
					EmitConstantValueInitialization(fields, ilGenerator);
					if (basehasclinit)
					{
						wrapper.BaseTypeWrapper.EmitRunClassConstructor(ilGenerator);
					}
					if (clinitIndex != -1)
					{
						CompileConstructorBody(this, ilGenerator, clinitIndex, invokespecialstubcache);
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ret);
					}
					ilGenerator.CheckLabels();
				}

				// add all interfaces that we implement (including the magic ones) and handle ghost conversions
				ImplementInterfaces(wrapper.Interfaces, new List<TypeWrapper>());

				// NOTE non-final fields aren't allowed in interfaces so we don't have to initialize constant fields
				if (!classFile.IsInterface)
				{
					// if a class has no constructor, we generate one otherwise Ref.Emit will create a default ctor
					// and that has several problems:
					// - base type may not have an accessible default constructor
					// - Ref.Emit uses BaseType.GetConstructors() which may trigger a TypeResolve event
					// - we don't want the synthesized constructor to show up in Java
					if (!hasConstructor)
					{
						ConstructorBuilder cb = typeBuilder.DefineConstructor(MethodAttributes.PrivateScope, CallingConventions.Standard, Type.EmptyTypes);
						CodeEmitter ilgen = CodeEmitter.Create(cb);
						ilgen.Emit(OpCodes.Ldnull);
						ilgen.Emit(OpCodes.Throw);
					}

					// here we loop thru all the interfaces to explicitly implement any methods that we inherit from
					// base types that may have a different name from the name in the interface
					// (e.g. interface that has an equals() method that should override System.Object.Equals())
					// also deals with interface methods that aren't implemented (generate a stub that throws AbstractMethodError)
					// and with methods that aren't public (generate a stub that throws IllegalAccessError)
					Dictionary<TypeWrapper, TypeWrapper> doneSet = new Dictionary<TypeWrapper, TypeWrapper>();
					TypeWrapper[] interfaces = wrapper.Interfaces;
					for (int i = 0; i < interfaces.Length; i++)
					{
						interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
					}
					// if any of our base classes has an incomplete interface implementation we need to look through all
					// the base class interfaces to see if we've got an implementation now
					TypeWrapper baseTypeWrapper = wrapper.BaseTypeWrapper;
					while (baseTypeWrapper.HasIncompleteInterfaceImplementation)
					{
						for (int i = 0; i < baseTypeWrapper.Interfaces.Length; i++)
						{
							baseTypeWrapper.Interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
						}
						baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
					}
					if (!wrapper.IsAbstract && wrapper.HasUnsupportedAbstractMethods)
					{
						AddUnsupportedAbstractMethods();
					}
					foreach (MethodWrapper mw in methods)
					{
						if (mw.Name != "<init>" && !mw.IsStatic && mw.IsPublic)
						{
							if (wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasIncompleteInterfaceImplementation)
							{
								Dictionary<TypeWrapper, TypeWrapper> hashtable = null;
								TypeWrapper tw = wrapper.BaseTypeWrapper;
								while (tw.HasIncompleteInterfaceImplementation)
								{
									foreach (TypeWrapper iface in tw.Interfaces)
									{
										AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Name, mw.Signature, ref hashtable, false);
									}
									tw = tw.BaseTypeWrapper;
								}
							}
							if (true)
							{
								Dictionary<TypeWrapper, TypeWrapper> hashtable = null;
								foreach (TypeWrapper iface in wrapper.Interfaces)
								{
									AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Name, mw.Signature, ref hashtable, true);
								}
							}
						}
					}
					Serialization.AddAutomagicSerialization(wrapper);
				}

#if STATIC_COMPILER
				// If we're an interface that has public/protected fields, we create an inner class
				// to expose these fields to C# (which stubbornly refuses to see fields in interfaces).
				TypeBuilder tbFields = null;
				if (classFile.IsInterface && classFile.IsPublic && !wrapper.IsGhost && classFile.Fields.Length > 0)
				{
					// TODO handle name clash
					tbFields = typeBuilder.DefineNestedType("__Fields", TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract);
					AttributeHelper.HideFromJava(tbFields);
					CodeEmitter ilgenClinit = null;
					for (int i = 0; i < classFile.Fields.Length; i++)
					{
						ClassFile.Field f = classFile.Fields[i];
						if (f.ConstantValue != null)
						{
							FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal;
							FieldBuilder fb = tbFields.DefineField(f.Name, fields[i].FieldTypeWrapper.TypeAsSignatureType, attribs);
							fb.SetConstant(f.ConstantValue);
						}
						else
						{
							FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.InitOnly;
							FieldBuilder fb = tbFields.DefineField(f.Name, fields[i].FieldTypeWrapper.TypeAsSignatureType, attribs);
							if (ilgenClinit == null)
							{
								ilgenClinit = CodeEmitter.Create(tbFields.DefineTypeInitializer());
							}
							wrapper.GetFieldWrapper(f.Name, f.Signature).EmitGet(ilgenClinit);
							ilgenClinit.Emit(OpCodes.Stsfld, fb);
						}
					}
					if (ilgenClinit != null)
					{
						ilgenClinit.Emit(OpCodes.Ret);
					}
				}

				// See if there is any additional metadata
				wrapper.EmitMapXmlMetadata(typeBuilder, classFile, fields, methods);
#endif // STATIC_COMPILER

				for (int i = 0; i < classFile.Methods.Length; i++)
				{
					ClassFile.Method m = classFile.Methods[i];
					MethodBase mb = methods[i].GetMethod();
					if (mb == null)
					{
						continue;
					}
					ParameterBuilder returnParameter = null;
					ParameterBuilder[] parameterBuilders = null;
					string[] parameterNames = null;
					if (wrapper.GetClassLoader().EmitDebugInfo
#if STATIC_COMPILER
 || (classFile.IsPublic && (m.IsPublic || m.IsProtected))
#endif
)
					{
						parameterNames = new string[methods[i].GetParameters().Length];
						GetParameterNamesFromLVT(m, parameterNames);
						GetParameterNamesFromSig(m.Signature, parameterNames);
#if STATIC_COMPILER
						((AotTypeWrapper)wrapper).GetParameterNamesFromXml(m.Name, m.Signature, parameterNames);
#endif
						parameterBuilders = GetParameterBuilders(mb, parameterNames.Length, parameterNames);
					}
#if STATIC_COMPILER
					if ((m.Modifiers & Modifiers.VarArgs) != 0 && !methods[i].HasCallerID)
					{
						if (parameterBuilders == null)
						{
							parameterBuilders = GetParameterBuilders(mb, methods[i].GetParameters().Length, null);
						}
						if (parameterBuilders.Length > 0)
						{
							AttributeHelper.SetParamArrayAttribute(parameterBuilders[parameterBuilders.Length - 1]);
						}
					}
					((AotTypeWrapper)wrapper).AddXmlMapParameterAttributes(mb, classFile.Name, m.Name, m.Signature, ref parameterBuilders);
#endif
					ConstructorBuilder cb = mb as ConstructorBuilder;
					MethodBuilder mBuilder = mb as MethodBuilder;
					if (m.Annotations != null)
					{
						foreach (object[] def in m.Annotations)
						{
							Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
							if (annotation != null)
							{
								if (cb != null)
								{
									annotation.Apply(wrapper.GetClassLoader(), cb, def);
								}
								if (mBuilder != null)
								{
									annotation.Apply(wrapper.GetClassLoader(), mBuilder, def);
									annotation.ApplyReturnValue(wrapper.GetClassLoader(), mBuilder, ref returnParameter, def);
								}
							}
						}
					}
					if (m.ParameterAnnotations != null)
					{
						if (parameterBuilders == null)
						{
							parameterBuilders = GetParameterBuilders(mb, methods[i].GetParameters().Length, null);
						}
						object[][] defs = m.ParameterAnnotations;
						for (int j = 0; j < defs.Length; j++)
						{
							foreach (object[] def in defs[j])
							{
								Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
								if (annotation != null)
								{
									annotation.Apply(wrapper.GetClassLoader(), parameterBuilders[j], def);
								}
							}
						}
					}
#if STATIC_COMPILER
					if (methods[i].HasCallerID)
					{
						AttributeHelper.SetEditorBrowsableNever((MethodBuilder)mb);
						EmitCallerIDStub(methods[i], parameterNames);
					}
#endif // STATIC_COMPILER
				}

				for (int i = 0; i < classFile.Fields.Length; i++)
				{
					if (classFile.Fields[i].Annotations != null)
					{
						foreach (object[] def in classFile.Fields[i].Annotations)
						{
							Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
							if (annotation != null)
							{
								GetterFieldWrapper getter = fields[i] as GetterFieldWrapper;
								if (getter != null)
								{
									annotation.Apply(wrapper.GetClassLoader(), (MethodBuilder)getter.GetGetter(), def);
								}
								else
								{
									DynamicPropertyFieldWrapper prop = fields[i] as DynamicPropertyFieldWrapper;
									if (prop != null)
									{
										annotation.Apply(wrapper.GetClassLoader(), prop.GetPropertyBuilder(), def);
									}
									else
									{
										annotation.Apply(wrapper.GetClassLoader(), (FieldBuilder)fields[i].GetField(), def);
									}
								}
							}
						}
					}
				}

				if (classFile.Annotations != null)
				{
					foreach (object[] def in classFile.Annotations)
					{
						Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
						if (annotation != null)
						{
							annotation.Apply(wrapper.GetClassLoader(), typeBuilder, def);
						}
					}
				}

				Type type;
				Profiler.Enter("TypeBuilder.CreateType");
				try
				{
					type = typeBuilder.CreateType();
					if (typeCallerID != null)
					{
						typeCallerID.CreateType();
					}
					if (postFinishProcs != null)
					{
						foreach (System.Threading.ThreadStart proc in postFinishProcs)
						{
							proc();
						}
					}
#if STATIC_COMPILER
					if (tbFields != null)
					{
						tbFields.CreateType();
					}
					if (classFile.IsInterface && !classFile.IsPublic)
					{
						((DynamicClassLoader)wrapper.classLoader.GetTypeWrapperFactory()).DefineProxyHelper(type);
					}
#endif
				}
				finally
				{
					Profiler.Leave("TypeBuilder.CreateType");
				}
				wrapper.GetClassLoader().SetWrapperForType(type, wrapper);
#if STATIC_COMPILER
				wrapper.FinishGhostStep2();
#endif
				BakedTypeCleanupHack.Process(wrapper);
				return type;
			}

#if !STATIC_COMPILER
			internal static class JniProxyBuilder
			{
				private static ModuleBuilder mod;
				private static int count;

				static JniProxyBuilder()
				{
					AssemblyName name = new AssemblyName();
					name.Name = "jniproxy";
					AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, JVM.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
					DynamicClassLoader.RegisterForSaveDebug(ab);
					mod = ab.DefineDynamicModule("jniproxy.dll", "jniproxy.dll");
					CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(JavaModuleAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
					mod.SetCustomAttribute(cab);
				}

				internal static void Generate(DynamicTypeWrapper.FinishContext context, CodeEmitter ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args)
				{
					TypeBuilder tb = mod.DefineType("__<jni>" + (count++), TypeAttributes.Public | TypeAttributes.Class);
					int instance = m.IsStatic ? 0 : 1;
					Type[] argTypes = new Type[args.Length + instance + 1];
					if (instance != 0)
					{
						argTypes[0] = typeof(object);
					}
					for (int i = 0; i < args.Length; i++)
					{
						// NOTE we take a shortcut here by assuming that all "special" types (i.e. ghost or value types)
						// are public and so we can get away with replacing all other types with object.
						argTypes[i + instance] = (args[i].IsPrimitive || args[i].IsGhost || args[i].IsNonPrimitiveValueType) ? args[i].TypeAsSignatureType : typeof(object);
					}
					argTypes[argTypes.Length - 1] = typeof(RuntimeMethodHandle);
					Type retType = (mw.ReturnType.IsPrimitive || mw.ReturnType.IsGhost || mw.ReturnType.IsNonPrimitiveValueType) ? mw.ReturnType.TypeAsSignatureType : typeof(object);
					MethodBuilder mb = tb.DefineMethod("method", MethodAttributes.Public | MethodAttributes.Static, retType, argTypes);
					AttributeHelper.HideFromJava(mb);
					JniBuilder.Generate(context, CodeEmitter.Create(mb), wrapper, mw, tb, classFile, m, args, true);
					tb.CreateType();
					for (int i = 0; i < argTypes.Length - 1; i++)
					{
						ilGenerator.Emit(OpCodes.Ldarg, (short)i);
					}
					ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
					ilGenerator.Emit(OpCodes.Call, mb);
					if (!mw.ReturnType.IsPrimitive && !mw.ReturnType.IsGhost && !mw.ReturnType.IsNonPrimitiveValueType)
					{
						ilGenerator.Emit(OpCodes.Castclass, mw.ReturnType.TypeAsSignatureType);
					}
					ilGenerator.Emit(OpCodes.Ret);
				}
			}
#endif // !STATIC_COMPILER

			private static class JniBuilder
			{
#if STATIC_COMPILER
				private static readonly Type localRefStructType = StaticCompiler.GetType("IKVM.Runtime.JNI+Frame");
#elif FIRST_PASS
				private static readonly Type localRefStructType = null;
#else
				private static readonly Type localRefStructType = JVM.LoadType(typeof(IKVM.Runtime.JNI.Frame));
#endif
				private static readonly MethodInfo jniFuncPtrMethod = localRefStructType.GetMethod("GetFuncPtr");
				private static readonly MethodInfo enterLocalRefStruct = localRefStructType.GetMethod("Enter");
				private static readonly MethodInfo leaveLocalRefStruct = localRefStructType.GetMethod("Leave");
				private static readonly MethodInfo makeLocalRef = localRefStructType.GetMethod("MakeLocalRef");
				private static readonly MethodInfo unwrapLocalRef = localRefStructType.GetMethod("UnwrapLocalRef");
				private static readonly MethodInfo writeLine = typeof(Console).GetMethod("WriteLine", new Type[] { typeof(object) }, null);
				private static readonly MethodInfo monitorEnter = typeof(System.Threading.Monitor).GetMethod("Enter", new Type[] { typeof(object) });
				private static readonly MethodInfo monitorExit = typeof(System.Threading.Monitor).GetMethod("Exit", new Type[] { typeof(object) });

				internal static void Generate(DynamicTypeWrapper.FinishContext context, CodeEmitter ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args, bool thruProxy)
				{
					LocalBuilder syncObject = null;
					if (m.IsSynchronized && m.IsStatic)
					{
						wrapper.EmitClassLiteral(ilGenerator);
						ilGenerator.Emit(OpCodes.Dup);
						syncObject = ilGenerator.DeclareLocal(typeof(object));
						ilGenerator.Emit(OpCodes.Stloc, syncObject);
						ilGenerator.Emit(OpCodes.Call, monitorEnter);
						ilGenerator.BeginExceptionBlock();
					}
					string sig = m.Signature.Replace('.', '/');
					// TODO use/unify JNI.METHOD_PTR_FIELD_PREFIX
					FieldBuilder methodPtr = typeBuilder.DefineField("__<jniptr>" + m.Name + sig, typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
					LocalBuilder localRefStruct = ilGenerator.DeclareLocal(localRefStructType);
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					ilGenerator.Emit(OpCodes.Initobj, localRefStructType);
					ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
					CodeEmitterLabel oklabel = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Brtrue, oklabel);
					if (thruProxy)
					{
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(args.Length + (mw.IsStatic ? 0 : 1)));
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
					}
					ilGenerator.Emit(OpCodes.Ldstr, classFile.Name.Replace('.', '/'));
					ilGenerator.Emit(OpCodes.Ldstr, m.Name);
					ilGenerator.Emit(OpCodes.Ldstr, sig);
					ilGenerator.Emit(OpCodes.Call, jniFuncPtrMethod);
					ilGenerator.Emit(OpCodes.Stsfld, methodPtr);
					ilGenerator.MarkLabel(oklabel);
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					if (thruProxy)
					{
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(args.Length + (mw.IsStatic ? 0 : 1)));
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
					}
					ilGenerator.Emit(OpCodes.Call, enterLocalRefStruct);
					LocalBuilder jnienv = ilGenerator.DeclareLocal(typeof(IntPtr));
					ilGenerator.Emit(OpCodes.Stloc, jnienv);
					ilGenerator.BeginExceptionBlock();
					TypeWrapper retTypeWrapper = mw.ReturnType;
					if (!retTypeWrapper.IsUnloadable && !retTypeWrapper.IsPrimitive)
					{
						// this one is for use after we return from "calli"
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					}
					ilGenerator.Emit(OpCodes.Ldloc, jnienv);
					Type[] modargs = new Type[args.Length + 2];
					modargs[0] = typeof(IntPtr);
					modargs[1] = typeof(IntPtr);
					for (int i = 0; i < args.Length; i++)
					{
						modargs[i + 2] = args[i].TypeAsSignatureType;
					}
					int add = 0;
					if (!m.IsStatic)
					{
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						ilGenerator.Emit(OpCodes.Ldarg_0);
						ilGenerator.Emit(OpCodes.Call, makeLocalRef);
						add = 1;
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						wrapper.EmitClassLiteral(ilGenerator);
						ilGenerator.Emit(OpCodes.Call, makeLocalRef);
					}
					for (int j = 0; j < args.Length; j++)
					{
						if (args[j].IsUnloadable || !args[j].IsPrimitive)
						{
							ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
							if (!args[j].IsUnloadable && args[j].IsNonPrimitiveValueType)
							{
								ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
								args[j].EmitBox(ilGenerator);
							}
							else if (!args[j].IsUnloadable && args[j].IsGhost)
							{
								ilGenerator.Emit(OpCodes.Ldarga_S, (byte)(j + add));
								ilGenerator.Emit(OpCodes.Ldfld, args[j].GhostRefField);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
							}
							ilGenerator.Emit(OpCodes.Call, makeLocalRef);
							modargs[j + 2] = typeof(IntPtr);
						}
						else
						{
							ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
						}
					}
					ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
					Type realRetType;
					if (retTypeWrapper == PrimitiveTypeWrapper.BOOLEAN)
					{
						realRetType = typeof(byte);
					}
					else if (retTypeWrapper.IsPrimitive)
					{
						realRetType = retTypeWrapper.TypeAsSignatureType;
					}
					else
					{
						realRetType = typeof(IntPtr);
					}
					ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, realRetType, modargs);
					LocalBuilder retValue = null;
					if (retTypeWrapper != PrimitiveTypeWrapper.VOID)
					{
						if (!retTypeWrapper.IsUnloadable && !retTypeWrapper.IsPrimitive)
						{
							ilGenerator.Emit(OpCodes.Call, unwrapLocalRef);
							if (retTypeWrapper.IsNonPrimitiveValueType)
							{
								retTypeWrapper.EmitUnbox(ilGenerator);
							}
							else if (retTypeWrapper.IsGhost)
							{
								LocalBuilder ghost = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
								LocalBuilder obj = ilGenerator.DeclareLocal(typeof(object));
								ilGenerator.Emit(OpCodes.Stloc, obj);
								ilGenerator.Emit(OpCodes.Ldloca, ghost);
								ilGenerator.Emit(OpCodes.Ldloc, obj);
								ilGenerator.Emit(OpCodes.Stfld, retTypeWrapper.GhostRefField);
								ilGenerator.Emit(OpCodes.Ldloc, ghost);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
							}
						}
						retValue = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
						ilGenerator.Emit(OpCodes.Stloc, retValue);
					}
					ilGenerator.BeginCatchBlock(typeof(object));
					ilGenerator.EmitWriteLine("*** exception in native code ***");
					ilGenerator.Emit(OpCodes.Call, writeLine);
					ilGenerator.Emit(OpCodes.Rethrow);
					ilGenerator.BeginFinallyBlock();
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					ilGenerator.Emit(OpCodes.Call, leaveLocalRefStruct);
					ilGenerator.EndExceptionBlock();
					if (m.IsSynchronized && m.IsStatic)
					{
						ilGenerator.BeginFinallyBlock();
						ilGenerator.Emit(OpCodes.Ldloc, syncObject);
						ilGenerator.Emit(OpCodes.Call, monitorExit);
						ilGenerator.EndExceptionBlock();
					}
					if (retTypeWrapper != PrimitiveTypeWrapper.VOID)
					{
						ilGenerator.Emit(OpCodes.Ldloc, retValue);
					}
					ilGenerator.Emit(OpCodes.Ret);
				}
			}

			private static class TraceHelper
			{
#if STATIC_COMPILER
				private readonly static MethodInfo methodIsTracedMethod = typeof(Tracer).GetMethod("IsTracedMethod");
#endif
				private readonly static MethodInfo methodMethodInfo = typeof(Tracer).GetMethod("MethodInfo");

				internal static void EmitMethodTrace(CodeEmitter ilgen, string tracemessage)
				{
					if (Tracer.IsTracedMethod(tracemessage))
					{
						CodeEmitterLabel label = ilgen.DefineLabel();
#if STATIC_COMPILER
						// TODO this should be a boolean field test instead of a call to Tracer.IsTracedMessage
						ilgen.Emit(OpCodes.Ldstr, tracemessage);
						ilgen.Emit(OpCodes.Call, methodIsTracedMethod);
						ilgen.Emit(OpCodes.Brfalse_S, label);
#endif
						ilgen.Emit(OpCodes.Ldstr, tracemessage);
						ilgen.Emit(OpCodes.Call, methodMethodInfo);
						ilgen.MarkLabel(label);
					}
				}
			}

#if STATIC_COMPILER
			private void EmitCallerIDStub(MethodWrapper mw, string[] parameterNames)
			{
				Type[] p = mw.GetParametersForDefineMethod();
				Type[] parameterTypes = new Type[p.Length - 1];
				for (int i = 0; i < parameterTypes.Length; i++)
				{
					parameterTypes[i] = p[i];
				}
				MethodAttributes attribs = MethodAttributes.HideBySig;
				int argcount = parameterTypes.Length;
				if (mw.IsStatic)
				{
					attribs |= MethodAttributes.Static;
				}
				else
				{
					argcount++;
				}
				if (mw.IsPublic)
				{
					attribs |= MethodAttributes.Public;
				}
				else if (mw.IsProtected)
				{
					attribs |= MethodAttributes.FamORAssem;
				}
				else if (mw.IsPrivate)
				{
					attribs |= MethodAttributes.Private;
				}
				else
				{
					attribs |= MethodAttributes.Assembly;
				}
				MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, attribs, mw.ReturnTypeForDefineMethod, parameterTypes);
				AttributeHelper.HideFromJava(mb);
				mb.SetImplementationFlags(MethodImplAttributes.NoInlining);
				CodeEmitter ilgen = CodeEmitter.Create(mb);
				for (int i = 0; i < argcount; i++)
				{
					if (parameterNames != null && (mw.IsStatic || i > 0))
					{
						ParameterBuilder pb = mb.DefineParameter(mw.IsStatic ? i + 1 : i, ParameterAttributes.None, parameterNames[mw.IsStatic ? i : i - 1]);
						if (i == argcount - 1 && (mw.Modifiers & Modifiers.VarArgs) != 0)
						{
							AttributeHelper.SetParamArrayAttribute(pb);
						}
					}
					ilgen.Emit(OpCodes.Ldarg, (short)i);
				}
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Ldc_I4_0);
				ilgen.Emit(OpCodes.Newobj, typeof(StackFrame).GetConstructor(new Type[] { typeof(int), typeof(bool) }));
				MethodWrapper callerID = CoreClasses.ikvm.@@internal.CallerID.Wrapper.GetMethodWrapper("create", "(Lcli.System.Diagnostics.StackFrame;)Likvm.internal.CallerID;", false);
				callerID.Link();
				callerID.EmitCall(ilgen);
				if (mw.IsStatic)
				{
					mw.EmitCall(ilgen);
				}
				else
				{
					mw.EmitCallvirt(ilgen);
				}
				ilgen.Emit(OpCodes.Ret);
			}
#endif // STATIC_COMPILER

			private void AddMethodOverride(MethodWrapper method, MethodBuilder mb, TypeWrapper iface, string name, string sig, ref Dictionary<TypeWrapper, TypeWrapper> hashtable, bool unloadableOnly)
			{
				if (hashtable != null && hashtable.ContainsKey(iface))
				{
					return;
				}
				MethodWrapper mw = iface.GetMethodWrapper(name, sig, false);
				if (mw != null)
				{
					if (hashtable == null)
					{
						hashtable = new Dictionary<TypeWrapper, TypeWrapper>();
					}
					hashtable.Add(iface, iface);
					if (CheckRequireOverrideStub(method, mw))
					{
						JavaTypeImpl.GenerateUnloadableOverrideStub(wrapper, typeBuilder, mw, mb, method.ReturnTypeForDefineMethod, method.GetParametersForDefineMethod());
					}
					else if (!unloadableOnly)
					{
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
					}
				}
				foreach (TypeWrapper iface2 in iface.Interfaces)
				{
					AddMethodOverride(method, mb, iface2, name, sig, ref hashtable, unloadableOnly);
				}
			}

			private static bool CheckRequireOverrideStub(MethodWrapper mw1, MethodWrapper mw2)
			{
				// TODO this is too late to generate LinkageErrors so we need to figure this out earlier
				if (mw1.ReturnType != mw2.ReturnType && !(mw1.ReturnType.IsUnloadable && mw2.ReturnType.IsUnloadable))
				{
					return true;
				}
				TypeWrapper[] args1 = mw1.GetParameters();
				TypeWrapper[] args2 = mw2.GetParameters();
				for (int i = 0; i < args1.Length; i++)
				{
					if (args1[i] != args2[i] && !(args1[i].IsUnloadable && args2[i].IsUnloadable))
					{
						return true;
					}
				}
				return false;
			}

			private void ImplementInterfaces(TypeWrapper[] interfaces, List<TypeWrapper> interfaceList)
			{
				foreach (TypeWrapper iface in interfaces)
				{
					if (!interfaceList.Contains(iface))
					{
						interfaceList.Add(iface);
						// NOTE we're using TypeAsBaseType for the interfaces!
						Type ifaceType = iface.TypeAsBaseType;
						if (!iface.IsPublic && !ReflectUtil.IsSameAssembly(ifaceType, typeBuilder))
						{
							ifaceType = ifaceType.Assembly.GetType(DynamicClassLoader.GetProxyHelperName(ifaceType));
						}
						typeBuilder.AddInterfaceImplementation(ifaceType);
#if STATIC_COMPILER
						if (!wrapper.IsInterface)
						{
							// look for "magic" interfaces that imply a .NET interface
							if (iface.GetClassLoader() == CoreClasses.java.lang.Object.Wrapper.GetClassLoader())
							{
								if (iface.Name == "java.lang.Iterable"
									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(typeof(System.Collections.IEnumerable))))
								{
									TypeWrapper enumeratorType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast("ikvm.lang.IterableEnumerator");
									if (enumeratorType != null)
									{
										typeBuilder.AddInterfaceImplementation(typeof(System.Collections.IEnumerable));
										// FXBUG we're using the same method name as the C# compiler here because both the .NET and Mono implementations of Xml serialization depend on this method name
										MethodBuilder mb = typeBuilder.DefineMethod("System.Collections.IEnumerable.GetEnumerator", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, typeof(System.Collections.IEnumerator), Type.EmptyTypes);
										AttributeHelper.HideFromJava(mb);
										typeBuilder.DefineMethodOverride(mb, typeof(System.Collections.IEnumerable).GetMethod("GetEnumerator"));
										CodeEmitter ilgen = CodeEmitter.Create(mb);
										ilgen.Emit(OpCodes.Ldarg_0);
										MethodWrapper mw = enumeratorType.GetMethodWrapper("<init>", "(Ljava.lang.Iterable;)V", false);
										mw.Link();
										mw.EmitNewobj(ilgen);
										ilgen.Emit(OpCodes.Ret);
									}
								}
								else if (iface.Name == "java.io.Closeable"
									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(typeof(IDisposable))))
								{
									typeBuilder.AddInterfaceImplementation(typeof(IDisposable));
									MethodBuilder mb = typeBuilder.DefineMethod("__<>Dispose", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, typeof(void), Type.EmptyTypes);
									typeBuilder.DefineMethodOverride(mb, typeof(IDisposable).GetMethod("Dispose"));
									CodeEmitter ilgen = CodeEmitter.Create(mb);
									ilgen.Emit(OpCodes.Ldarg_0);
									MethodWrapper mw = iface.GetMethodWrapper("close", "()V", false);
									mw.Link();
									mw.EmitCallvirt(ilgen);
									ilgen.Emit(OpCodes.Ret);
								}
							}
							// if we implement a ghost interface, add an implicit conversion to the ghost reference value type
							if (iface.IsGhost && wrapper.IsPublic)
							{
								MethodBuilder mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, iface.TypeAsSignatureType, new Type[] { wrapper.TypeAsSignatureType });
								CodeEmitter ilgen = CodeEmitter.Create(mb);
								LocalBuilder local = ilgen.DeclareLocal(iface.TypeAsSignatureType);
								ilgen.Emit(OpCodes.Ldloca, local);
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Stfld, iface.GhostRefField);
								ilgen.Emit(OpCodes.Ldloca, local);
								ilgen.Emit(OpCodes.Ldobj, iface.TypeAsSignatureType);
								ilgen.Emit(OpCodes.Ret);
							}
						}
#endif // STATIC_COMPILER
						// NOTE we're recursively "implementing" all interfaces that we inherit from the interfaces we implement.
						// The C# compiler also does this and the Compact Framework requires it.
						ImplementInterfaces(iface.Interfaces, interfaceList);
					}
				}
			}

			private void AddUnsupportedAbstractMethods()
			{
				foreach (MethodBase mb in wrapper.BaseTypeWrapper.TypeAsBaseType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
				{
					if (DotNetTypeWrapper.IsUnsupportedAbstractMethod(mb))
					{
						GenerateUnsupportedAbstractMethodStub(mb);
					}
				}
				Dictionary<MethodBase, MethodBase> h = new Dictionary<MethodBase, MethodBase>();
				TypeWrapper tw = wrapper;
				while (tw != null)
				{
					foreach (TypeWrapper iface in tw.Interfaces)
					{
						foreach (MethodBase mb in iface.TypeAsBaseType.GetMethods(BindingFlags.Public | BindingFlags.Instance))
						{
							if (!h.ContainsKey(mb))
							{
								h.Add(mb, mb);
								if (DotNetTypeWrapper.IsUnsupportedAbstractMethod(mb))
								{
									GenerateUnsupportedAbstractMethodStub(mb);
								}
							}
						}
					}
					tw = tw.BaseTypeWrapper;
				}
			}

			private void GenerateUnsupportedAbstractMethodStub(MethodBase mb)
			{
				ParameterInfo[] parameters = mb.GetParameters();
				Type[] parameterTypes = new Type[parameters.Length];
				for (int i = 0; i < parameters.Length; i++)
				{
					parameterTypes[i] = parameters[i].ParameterType;
				}
				MethodAttributes attr = MethodAttributes.NewSlot | MethodAttributes.Virtual | MethodAttributes.Private;
				MethodBuilder m = typeBuilder.DefineMethod("__<unsupported>" + mb.DeclaringType.FullName + "/" + mb.Name, attr, ((MethodInfo)mb).ReturnType, parameterTypes);
				CodeEmitter.Create(m).EmitThrow("java.lang.AbstractMethodError", "Method " + mb.DeclaringType.FullName + "." + mb.Name + " is unsupported by IKVM.");
				typeBuilder.DefineMethodOverride(m, (MethodInfo)mb);
			}

			private void CompileConstructorBody(FinishContext context, CodeEmitter ilGenerator, int methodIndex, Dictionary<MethodKey, MethodInfo> invokespecialstubcache)
			{
				MethodWrapper[] methods = wrapper.GetMethods();
				ClassFile.Method m = classFile.Methods[methodIndex];
				TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
#if STATIC_COMPILER
				// do we have a native implementation in map.xml?
				if (wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
				{
					return;
				}
#endif
				LineNumberTableAttribute.LineNumberWriter lineNumberTable = null;
				bool nonLeaf = false;
				Compiler.Compile(context, wrapper, methods[methodIndex], classFile, m, ilGenerator, ref nonLeaf, invokespecialstubcache, ref lineNumberTable);
				if (lineNumberTable != null)
				{
#if STATIC_COMPILER
					AttributeHelper.SetLineNumberTable(methods[methodIndex].GetMethod(), lineNumberTable);
#else // STATIC_COMPILER
					if (wrapper.lineNumberTables == null)
					{
						wrapper.lineNumberTables = new byte[methods.Length][];
					}
					wrapper.lineNumberTables[methodIndex] = lineNumberTable.ToArray();
#endif // STATIC_COMPILER
				}
			}

			private static bool IsCompatibleArgList(TypeWrapper[] caller, TypeWrapper[] callee)
			{
				if (caller.Length == callee.Length)
				{
					for (int i = 0; i < caller.Length; i++)
					{
						if (!caller[i].IsAssignableTo(callee[i]))
						{
							return false;
						}
					}
					return true;
				}
				return false;
			}

			private void EmitCallerIDInitialization(CodeEmitter ilGenerator, FieldInfo callerIDField)
			{
				{
					TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
					// we need to prohibit this optimization at runtime, because proxy classes may be injected into the boot class loader,
					// but they don't actually have access to core library internals
#if STATIC_COMPILER
					if (tw.GetClassLoader() == wrapper.GetClassLoader())
					{
						MethodWrapper create = tw.GetMethodWrapper("create", "(Lcli.System.RuntimeTypeHandle;)Likvm.internal.CallerID;", false);
						ilGenerator.Emit(OpCodes.Ldtoken, this.typeBuilder);
						create.Link();
						create.EmitCall(ilGenerator);
					}
					else
#endif
					{
						typeCallerID = typeBuilder.DefineNestedType("__<CallerID>", TypeAttributes.Sealed | TypeAttributes.NestedPrivate, tw.TypeAsBaseType);
						ConstructorBuilder cb = typeCallerID.DefineConstructor(MethodAttributes.Assembly, CallingConventions.Standard, null);
						CodeEmitter ctorIlgen = CodeEmitter.Create(cb);
						ctorIlgen.Emit(OpCodes.Ldarg_0);
						MethodWrapper mw = tw.GetMethodWrapper("<init>", "()V", false);
						mw.Link();
						mw.EmitCall(ctorIlgen);
						ctorIlgen.Emit(OpCodes.Ret);
						ilGenerator.Emit(OpCodes.Newobj, cb);
					}
					ilGenerator.Emit(OpCodes.Stsfld, callerIDField);
				}
			}

			private void EmitConstantValueInitialization(FieldWrapper[] fields, CodeEmitter ilGenerator)
			{
				ClassFile.Field[] flds = classFile.Fields;
				for (int i = 0; i < flds.Length; i++)
				{
					ClassFile.Field f = flds[i];
					if (f.IsStatic && !f.IsFinal)
					{
						object constant = f.ConstantValue;
						if (constant != null)
						{
							if (constant is int)
							{
								ilGenerator.Emit(OpCodes.Ldc_I4, (int)constant);
							}
							else if (constant is long)
							{
								ilGenerator.Emit(OpCodes.Ldc_I8, (long)constant);
							}
							else if (constant is double)
							{
								ilGenerator.Emit(OpCodes.Ldc_R8, (double)constant);
							}
							else if (constant is float)
							{
								ilGenerator.Emit(OpCodes.Ldc_R4, (float)constant);
							}
							else if (constant is string)
							{
								ilGenerator.Emit(OpCodes.Ldstr, (string)constant);
							}
							else
							{
								throw new InvalidOperationException();
							}
							fields[i].EmitSet(ilGenerator);
						}
					}
				}
			}
		}

		protected static void GetParameterNamesFromLVT(ClassFile.Method m, string[] parameterNames)
		{
			ClassFile.Method.LocalVariableTableEntry[] localVars = m.LocalVariableTableAttribute;
			if(localVars != null)
			{
				for(int i = m.IsStatic ? 0 : 1, pos = 0; i < m.ArgMap.Length; i++)
				{
					// skip double & long fillers
					if(m.ArgMap[i] != -1)
					{
						if(parameterNames[pos] == null)
						{
							for(int j = 0; j < localVars.Length; j++)
							{
								if(localVars[j].index == i)
								{
									parameterNames[pos] = localVars[j].name;
									break;
								}
							}
						}
						pos++;
					}
				}
			}
		}

		protected static void GetParameterNamesFromSig(string sig, string[] parameterNames)
		{
			List<string> names = new List<string>();
			for(int i = 1; sig[i] != ')'; i++)
			{
				if(sig[i] == 'L')
				{
					i++;
					int end = sig.IndexOf(';', i);
					names.Add(GetParameterName(sig.Substring(i, end - i)));
					i = end;
				}
				else if(sig[i] == '[')
				{
					while(sig[++i] == '[');
					if(sig[i] == 'L')
					{
						i++;
						int end = sig.IndexOf(';', i);
						names.Add(GetParameterName(sig.Substring(i, end - i)) + "arr");
						i = end;
					}
					else
					{
						switch(sig[i])
						{
							case 'B':
							case 'Z':
								names.Add("barr");
								break;
							case 'C':
								names.Add("charr");
								break;
							case 'S':
								names.Add("sarr");
								break;
							case 'I':
								names.Add("iarr");
								break;
							case 'J':
								names.Add("larr");
								break;
							case 'F':
								names.Add("farr");
								break;
							case 'D':
								names.Add("darr");
								break;
						}
					}
				}
				else
				{
					switch(sig[i])
					{
						case 'B':
						case 'Z':
							names.Add("b");
							break;
						case 'C':
							names.Add("ch");
							break;
						case 'S':
							names.Add("s");
							break;
						case 'I':
							names.Add("i");
							break;
						case 'J':
							names.Add("l");
							break;
						case 'F':
							names.Add("f");
							break;
						case 'D':
							names.Add("d");
							break;
					}
				}
			}
			for(int i = 0; i < parameterNames.Length; i++)
			{
				if(parameterNames[i] == null)
				{
					parameterNames[i] = (string)names[i];
				}
			}
		}

		protected static ParameterBuilder[] GetParameterBuilders(MethodBase mb, int parameterCount, string[] parameterNames)
		{
			ParameterBuilder[] parameterBuilders = new ParameterBuilder[parameterCount];
			Dictionary<string, int> clashes = null;
			for(int i = 0; i < parameterBuilders.Length; i++)
			{
				string name = null;
				if(parameterNames != null)
				{
					name = parameterNames[i];
					if(Array.IndexOf(parameterNames, name, i + 1) >= 0 || (clashes != null && clashes.ContainsKey(name)))
					{
						if(clashes == null)
						{
							clashes = new Dictionary<string, int>();
						}
						int clash = 1;
						if(clashes.ContainsKey(name))
						{
							clash = clashes[name] + 1;
						}
						clashes[name] = clash;
						name += clash;
					}
				}
				MethodBuilder mBuilder = mb as MethodBuilder;
				if(mBuilder != null)
				{
					parameterBuilders[i] = mBuilder.DefineParameter(i + 1, ParameterAttributes.None, name);
				}
				else
				{
					parameterBuilders[i] = ((ConstructorBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
				}
			}
			return parameterBuilders;
		}

		private static string GetParameterName(string type)
		{
			if(type == "java.lang.String")
			{
				return "str";
			}
			else if(type == "java.lang.Object")
			{
				return "obj";
			}
			else
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder();
				for(int i = type.LastIndexOf('.') + 1; i < type.Length; i++)
				{
					if(char.IsUpper(type, i))
					{
						sb.Append(char.ToLower(type[i]));
					}
				}
				return sb.ToString();
			}
		}

#if STATIC_COMPILER
		protected abstract void AddMapXmlFields(ref FieldWrapper[] fields);
		protected abstract bool EmitMapXmlMethodBody(CodeEmitter ilgen, ClassFile f, ClassFile.Method m);
		protected abstract void EmitMapXmlMetadata(TypeBuilder typeBuilder, ClassFile classFile, FieldWrapper[] fields, MethodWrapper[] methods);
		protected abstract MethodBuilder DefineGhostMethod(string name, MethodAttributes attribs, MethodWrapper mw);
		protected abstract void FinishGhost(TypeBuilder typeBuilder, MethodWrapper[] methods);
		protected abstract void FinishGhostStep2();
		protected abstract TypeBuilder DefineGhostType(string mangledTypeName, TypeAttributes typeAttribs);
#endif // STATIC_COMPILER

		protected virtual bool IsPInvokeMethod(ClassFile.Method m)
		{
#if CLASSGC
			// TODO PInvoke is not supported in RunAndCollect assemblies,
			if (JVM.classUnloading)
			{
				return false;
			}
#endif
			if (m.Annotations != null)
			{
				foreach(object[] annot in m.Annotations)
				{
					if("Lcli/System/Runtime/InteropServices/DllImportAttribute$Annotation;".Equals(annot[1]))
					{
						return true;
					}
				}
			}
			return false;
		}

		internal override MethodBase LinkMethod(MethodWrapper mw)
		{
			mw.AssertLinked();
			return impl.LinkMethod(mw);
		}

		internal override FieldInfo LinkField(FieldWrapper fw)
		{
			fw.AssertLinked();
			return impl.LinkField(fw);
		}

		internal override void EmitRunClassConstructor(CodeEmitter ilgen)
		{
			impl.EmitRunClassConstructor(ilgen);
		}

		internal override string GetGenericSignature()
		{
			return impl.GetGenericSignature();
		}

		internal override string GetGenericMethodSignature(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for(int i = 0; i < methods.Length; i++)
			{
				if(methods[i] == mw)
				{
					return impl.GetGenericMethodSignature(i);
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override string GetGenericFieldSignature(FieldWrapper fw)
		{
			FieldWrapper[] fields = GetFields();
			for(int i = 0; i < fields.Length; i++)
			{
				if(fields[i] == fw)
				{
					return impl.GetGenericFieldSignature(i + GetMethods().Length);
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override string[] GetEnclosingMethod()
		{
			return impl.GetEnclosingMethod();
		}

		internal override string GetSourceFileName()
		{
			return sourceFileName;
		}

#if !STATIC_COMPILER
		private int GetMethodBaseToken(MethodBase mb)
		{
			ConstructorInfo ci = mb as ConstructorInfo;
			if(ci != null)
			{
				return classLoader.GetTypeWrapperFactory().ModuleBuilder.GetConstructorToken(ci).Token;
			}
			else
			{
				return classLoader.GetTypeWrapperFactory().ModuleBuilder.GetMethodToken((MethodInfo)mb).Token;
			}
		}

		internal override int GetSourceLineNumber(MethodBase mb, int ilOffset)
		{
			if(lineNumberTables != null)
			{
				int token = GetMethodBaseToken(mb);
				MethodWrapper[] methods = GetMethods();
				for(int i = 0; i < methods.Length; i++)
				{
					if(GetMethodBaseToken(methods[i].GetMethod()) == token)
					{
						if(lineNumberTables[i] != null)
						{
							return new LineNumberTableAttribute(lineNumberTables[i]).GetLineNumber(ilOffset);
						}
						break;
					}
				}
			}
			return -1;
		}

		internal override object[] GetDeclaredAnnotations()
		{
			object[] annotations = impl.GetDeclaredAnnotations();
			if(annotations != null)
			{
				object[] objs = new object[annotations.Length];
				for(int i = 0; i < annotations.Length; i++)
				{
					objs[i] = JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[i]);
				}
				return objs;
			}
			return null;
		}

		internal override object[] GetMethodAnnotations(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for(int i = 0; i < methods.Length; i++)
			{
				if(methods[i] == mw)
				{
					object[] annotations = impl.GetMethodAnnotations(i);
					if(annotations != null)
					{
						object[] objs = new object[annotations.Length];
						for(int j = 0; j < annotations.Length; j++)
						{
							objs[j] = JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[j]);
						}
						return objs;
					}
					return null;
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override object[][] GetParameterAnnotations(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for(int i = 0; i < methods.Length; i++)
			{
				if(methods[i] == mw)
				{
					object[][] annotations = impl.GetParameterAnnotations(i);
					if(annotations != null)
					{
						object[][] objs = new object[annotations.Length][];
						for(int j = 0; j < annotations.Length; j++)
						{
							objs[j] = new object[annotations[j].Length];
							for(int k = 0; k < annotations[j].Length; k++)
							{
								objs[j][k] = JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[j][k]);
							}
						}
						return objs;
					}
					return null;
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override object[] GetFieldAnnotations(FieldWrapper fw)
		{
			FieldWrapper[] fields = GetFields();
			for(int i = 0; i < fields.Length; i++)
			{
				if(fields[i] == fw)
				{
					object[] annotations = impl.GetFieldAnnotations(i);
					if(annotations != null)
					{
						object[] objs = new object[annotations.Length];
						for(int j = 0; j < annotations.Length; j++)
						{
							objs[j] = JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[j]);
						}
						return objs;
					}
					return null;
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override object GetAnnotationDefault(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for(int i = 0; i < methods.Length; i++)
			{
				if(methods[i] == mw)
				{
					object defVal = impl.GetMethodDefaultValue(i);
					if(defVal != null)
					{
						return JVM.NewAnnotationElementValue(mw.DeclaringType.GetClassLoader().GetJavaClassLoader(), mw.ReturnType.ClassObject, defVal);
					}
					return null;
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}
#endif

		protected virtual Type GetBaseTypeForDefineType()
		{
			return BaseTypeWrapper.TypeAsBaseType;
		}

#if STATIC_COMPILER
		internal virtual MethodWrapper[] GetReplacedMethodsFor(MethodWrapper mw)
		{
			return null;
		}
#endif // STATIC_COMPILER
	}

@


1.310
log
@Removed vestigial compact framework support.
@
text
@a50 85
	static class EmitHelper
	{
		private static MethodInfo objectToString = typeof(object).GetMethod("ToString", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
		private static MethodInfo verboseCastFailure = JVM.SafeGetEnvironmentVariable("IKVM_VERBOSE_CAST") == null ? null : ByteCodeHelperMethods.VerboseCastFailure;
		private static MethodInfo getTypeHandle = typeof(Type).GetMethod("GetTypeHandle", BindingFlags.Public | BindingFlags.Static, null, new Type[] { typeof(object) }, null);
		private static MethodInfo get_Value = typeof(RuntimeTypeHandle).GetMethod("get_Value", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);

		internal static void Throw(CodeEmitter ilgen, string dottedClassName)
		{
			TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dottedClassName);
			MethodWrapper mw = exception.GetMethodWrapper("<init>", "()V", false);
			mw.Link();
			mw.EmitNewobj(ilgen);
			ilgen.Emit(OpCodes.Throw);
		}

		internal static void Throw(CodeEmitter ilgen, string dottedClassName, string message)
		{
			TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dottedClassName);
			ilgen.Emit(OpCodes.Ldstr, message);
			MethodWrapper mw = exception.GetMethodWrapper("<init>", "(Ljava.lang.String;)V", false);
			mw.Link();
			mw.EmitNewobj(ilgen);
			ilgen.Emit(OpCodes.Throw);
		}

		internal static void NullCheck(CodeEmitter ilgen)
		{
			// I think this is the most efficient way to generate a NullReferenceException if the
			// reference is null
			ilgen.Emit(OpCodes.Ldvirtftn, objectToString);
			ilgen.Emit(OpCodes.Pop);
		}

		internal static void Castclass(CodeEmitter ilgen, Type type)
		{
			if(verboseCastFailure != null)
			{
				LocalBuilder lb = ilgen.DeclareLocal(typeof(object));
				ilgen.Emit(OpCodes.Stloc, lb);
				ilgen.Emit(OpCodes.Ldloc, lb);
				ilgen.Emit(OpCodes.Isinst, type);
				ilgen.Emit(OpCodes.Dup);
				CodeEmitterLabel ok = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brtrue_S, ok);
				ilgen.Emit(OpCodes.Ldloc, lb);
				ilgen.Emit(OpCodes.Brfalse_S, ok);	// handle null
				ilgen.Emit(OpCodes.Ldtoken, type);
				ilgen.Emit(OpCodes.Ldloc, lb);
				ilgen.Emit(OpCodes.Call, verboseCastFailure);
				ilgen.MarkLabel(ok);
			}
			else
			{
				ilgen.Emit(OpCodes.Castclass, type);
			}
		}

		// This is basically the same as Castclass, except that it
		// throws an IncompatibleClassChangeError on failure.
		internal static void EmitAssertType(CodeEmitter ilgen, Type type)
		{
			LocalBuilder lb = ilgen.DeclareLocal(typeof(object));
			ilgen.Emit(OpCodes.Stloc, lb);
			ilgen.Emit(OpCodes.Ldloc, lb);
			ilgen.Emit(OpCodes.Isinst, type);
			ilgen.Emit(OpCodes.Dup);
			CodeEmitterLabel ok = ilgen.DefineLabel();
			ilgen.Emit(OpCodes.Brtrue_S, ok);
			ilgen.Emit(OpCodes.Ldloc, lb);
			ilgen.Emit(OpCodes.Brfalse_S, ok);	// handle null
			EmitHelper.Throw(ilgen, "java.lang.IncompatibleClassChangeError");
			ilgen.MarkLabel(ok);
		}

		internal static void GetTypeHandleValue(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, getTypeHandle);
			LocalBuilder local = ilgen.DeclareLocal(typeof(RuntimeTypeHandle));
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(OpCodes.Ldloca, local);
			ilgen.Emit(OpCodes.Call, get_Value);
		}
	}

d3196 1
a3196 1
						EmitHelper.Throw(CodeEmitter.Create(mb), "java.lang.LinkageError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
d3213 1
a3213 1
					EmitHelper.Throw(CodeEmitter.Create(mb), "java.lang.IllegalAccessError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
d3259 1
a3259 1
					EmitHelper.Throw(CodeEmitter.Create(mb), "java.lang.AbstractMethodError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
d3371 1
a3371 1
					EmitHelper.EmitAssertType(ilgen, TypeAsTBD);
d3415 1
a3415 1
				EmitHelper.Castclass(ilgen, TypeAsTBD);
d6339 1
a6339 1
								EmitHelper.Throw(CodeEmitter.Create(mb), "java.lang.AbstractMethodError", wrapper.Name + "." + methods[index].Name + methods[index].Signature);
d7382 1
a7382 1
									EmitHelper.Throw(CodeEmitter.Create(mb), "java.lang.AbstractMethodError", mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
d7442 1
a7442 1
								EmitHelper.Throw(ilGenerator, "java.lang.AbstractMethodError", classFile.Name + "." + m.Name + m.Signature);
d7527 1
a7527 1
										EmitHelper.Throw(ilGenerator, "java.lang.UnsatisfiedLinkError", "Native method not implemented (compiled with -nojni): " + classFile.Name + "." + m.Name + m.Signature);
d8398 1
a8398 1
				EmitHelper.Throw(CodeEmitter.Create(m), "java.lang.AbstractMethodError", "Method " + mb.DeclaringType.FullName + "." + mb.Name + " is unsupported by IKVM.");
d11923 1
a11923 1
				EmitHelper.Throw(ilgen, "java.lang.CloneNotSupportedException");
d11925 1
a11925 1
				EmitHelper.Throw(ilgen, "java.lang.NullPointerException");
d12579 1
a12579 1
			EmitHelper.Castclass(ilgen, type);
@


1.309
log
@Small code cleanup. Changed a couple of abstract methods in TypeWrapper to virtual and provided a default implementation and removed the implementation from a number of subclasses.
@
text
@d29 1
a29 1
#elif !COMPACT_FRAMEWORK
a50 1
#if !COMPACT_FRAMEWORK
a134 1
#endif
a137 1
#if !COMPACT_FRAMEWORK
a156 1
#endif // !COMPACT_FRAMEWORK
d178 1
a178 1
#if STATIC_COMPILER && !COMPACT_FRAMEWORK
a486 1
#if !COMPACT_FRAMEWORK
a633 1
#endif // !COMPACT_FRAMEWORK
a649 1
#if !COMPACT_FRAMEWORK
a695 1
#endif // !COMPACT_FRAMEWORK
d719 1
a719 1
#if STATIC_COMPILER && !COMPACT_FRAMEWORK
a752 1
#if !COMPACT_FRAMEWORK
a760 1
#endif
a778 1
#if !COMPACT_FRAMEWORK
a785 1
#endif
a800 1
#if !COMPACT_FRAMEWORK
a812 1
#endif
a827 1
#if !COMPACT_FRAMEWORK
a839 1
#endif
a858 1
#if !COMPACT_FRAMEWORK
a870 1
#endif
a939 1
#if !COMPACT_FRAMEWORK
a951 1
#endif
d989 1
a989 1
#if STATIC_COMPILER && !COMPACT_FRAMEWORK
d1200 1
a1200 1
#endif  // STATIC_COMPILER && !COMPACT_FRAMEWORK
a1212 1
#if !COMPACT_FRAMEWORK
a1220 1
#endif
a1235 1
#if !COMPACT_FRAMEWORK
a1243 1
#endif
a1247 1
#if !COMPACT_FRAMEWORK
a1257 1
#endif
a1269 1
#if !COMPACT_FRAMEWORK
a1277 1
#endif
a1292 1
#if !COMPACT_FRAMEWORK
a1300 1
#endif
a1321 1
#if !COMPACT_FRAMEWORK
a1329 1
#endif
a1344 1
#if !COMPACT_FRAMEWORK
a1352 1
#endif
a1367 1
#if !COMPACT_FRAMEWORK
a1375 1
#endif
a1390 1
#if !COMPACT_FRAMEWORK
a1398 1
#endif
a1413 1
#if !COMPACT_FRAMEWORK
a1421 1
#endif
a1436 1
#if !COMPACT_FRAMEWORK
a1444 1
#endif
a1462 1
#if !COMPACT_FRAMEWORK
a1470 1
#endif
a1485 1
#if !COMPACT_FRAMEWORK
a1493 1
#endif
a1511 1
#if !COMPACT_FRAMEWORK
a1519 1
#endif
a1538 1
#if !COMPACT_FRAMEWORK
a1545 1
#endif
a1579 1
#if !COMPACT_FRAMEWORK
a1587 1
#endif
a1601 1
#if !COMPACT_FRAMEWORK
a1608 1
#endif
a1622 1
#if !COMPACT_FRAMEWORK
a1630 1
#endif
a1644 1
#if !COMPACT_FRAMEWORK
a1652 1
#endif
a1666 1
#if !COMPACT_FRAMEWORK
a1674 1
#endif
a1694 1
#if !COMPACT_FRAMEWORK
a1709 1
#endif
d1742 1
a1742 1
#if STATIC_COMPILER && !COMPACT_FRAMEWORK
d1789 1
a1789 1
#endif // STATIC_COMPILER && !COMPACT_FRAMEWORK
a1800 1
#if !COMPACT_FRAMEWORK
a2110 1
#endif
a2295 1
#if !COMPACT_FRAMEWORK
a2297 1
#endif // !COMPACT_FRAMEWORK
a2964 1
#if !COMPACT_FRAMEWORK
a2973 1
#endif
a3234 1
#if !COMPACT_FRAMEWORK
a3375 1
#endif
a3398 1
#if !COMPACT_FRAMEWORK
a3532 1
#endif
a3545 1
#if !COMPACT_FRAMEWORK
a3548 1
#endif
a3620 1
#if !COMPACT_FRAMEWORK
a3635 1
#endif
a3726 1
#if !COMPACT_FRAMEWORK
a3739 1
#endif
a3831 1
#if !COMPACT_FRAMEWORK
a3936 1
#endif // !COMPACT_FRAMEWORK
a3937 1
#if !COMPACT_FRAMEWORK
a9032 1
#endif // !COMPACT_FRAMEWORK
a9757 1
#if !COMPACT_FRAMEWORK
a9799 1
#endif
a9913 1
#if !COMPACT_FRAMEWORK
a9922 1
#endif
a10080 1
#if !COMPACT_FRAMEWORK
a10185 1
#endif
a11162 1
#if !COMPACT_FRAMEWORK
a11237 1
#endif
a11293 1
#if !COMPACT_FRAMEWORK
a11390 1
#endif
a11494 1
#if !COMPACT_FRAMEWORK
a11675 1
#endif //!COMPACT_FRAMEWORK
a11775 1
#if !COMPACT_FRAMEWORK
a11802 1
#endif
a11820 1
#if !COMPACT_FRAMEWORK
a11868 1
#endif
a11882 1
#if !COMPACT_FRAMEWORK
a11888 1
#endif
a11900 1
#if !COMPACT_FRAMEWORK
a11917 1
#endif
a11966 1
#if !COMPACT_FRAMEWORK
a11972 1
#endif
a12276 1
#if !COMPACT_FRAMEWORK
a12287 1
#endif
a12636 1
#if !COMPACT_FRAMEWORK
a12665 1
#endif
@


1.308
log
@ArrayTypeWrapper: Fixed a race condition and avoid holding the lock while calling external code.
@
text
@d3624 4
a3627 1
		internal abstract string GetGenericSignature();
d3629 4
a3632 1
		internal abstract string GetGenericMethodSignature(MethodWrapper mw);
d3634 4
a3637 1
		internal abstract string GetGenericFieldSignature(FieldWrapper fw);
d3639 4
a3642 1
		internal abstract string[] GetEnclosingMethod();
a3817 20

		internal override string GetGenericSignature()
		{
			throw new InvalidOperationException("GetGenericSignature called on UnloadableTypeWrapper: " + Name);
		}

		internal override string GetGenericMethodSignature(MethodWrapper mw)
		{
			throw new InvalidOperationException("GetGenericMethodSignature called on UnloadableTypeWrapper: " + Name);
		}

		internal override string GetGenericFieldSignature(FieldWrapper fw)
		{
			throw new InvalidOperationException("GetGenericFieldSignature called on UnloadableTypeWrapper: " + Name);
		}

		internal override string[] GetEnclosingMethod()
		{
			throw new InvalidOperationException("GetEnclosingMethod called on UnloadableTypeWrapper: " + Name);
		}
a3907 20

		internal override string GetGenericSignature()
		{
			return null;
		}

		internal override string GetGenericMethodSignature(MethodWrapper mw)
		{
			return null;
		}

		internal override string GetGenericFieldSignature(FieldWrapper fw)
		{
			return null;
		}

		internal override string[] GetEnclosingMethod()
		{
			return null;
		}
a10572 20
			internal override string[] GetEnclosingMethod()
			{
				return null;
			}

			internal override string GetGenericFieldSignature(FieldWrapper fw)
			{
				return null;
			}

			internal override string GetGenericMethodSignature(MethodWrapper mw)
			{
				return null;
			}

			internal override string GetGenericSignature()
			{
				return null;
			}

a10633 20
			internal override string[] GetEnclosingMethod()
			{
				return null;
			}

			internal override string GetGenericFieldSignature(FieldWrapper fw)
			{
				return null;
			}

			internal override string GetGenericMethodSignature(MethodWrapper mw)
			{
				return null;
			}

			internal override string GetGenericSignature()
			{
				return null;
			}

a10858 20
			internal override string[] GetEnclosingMethod()
			{
				return null;
			}

			internal override string GetGenericFieldSignature(FieldWrapper fw)
			{
				return null;
			}

			internal override string GetGenericMethodSignature(MethodWrapper mw)
			{
				return null;
			}

			internal override string GetGenericSignature()
			{
				return null;
			}

a10904 20
			internal sealed override string[] GetEnclosingMethod()
			{
				return null;
			}

			internal sealed override string GetGenericFieldSignature(FieldWrapper fw)
			{
				return null;
			}

			internal sealed override string GetGenericMethodSignature(MethodWrapper mw)
			{
				return null;
			}

			internal sealed override string GetGenericSignature()
			{
				return null;
			}

a12786 20
		internal override string GetGenericSignature()
		{
			return null;
		}

		internal override string GetGenericMethodSignature(MethodWrapper mw)
		{
			return null;
		}

		internal override string GetGenericFieldSignature(FieldWrapper fw)
		{
			return null;
		}

		internal override string[] GetEnclosingMethod()
		{
			return null;
		}

a12997 20
		internal override string GetGenericSignature()
		{
			return null;
		}

		internal override string GetGenericMethodSignature(MethodWrapper mw)
		{
			return null;
		}

		internal override string GetGenericFieldSignature(FieldWrapper fw)
		{
			return null;
		}

		internal override string[] GetEnclosingMethod()
		{
			return null;
		}

@


1.307
log
@Added support for exposing open generic types as Java classes (special "handle" classes that can only be used for stack walking).
@
text
@d13075 1
a13075 1
				if(arrayType == null)
d13077 27
a13103 1
					arrayType = MakeArrayType(ultimateElementTypeWrapper.TypeAsArrayType, this.ArrayRank);
d13111 1
a13111 1
			lock(this)
d13113 2
a13114 1
				if(!finished)
d13116 4
d13121 1
a13121 2
					ultimateElementTypeWrapper.Finish();
					arrayType = MakeArrayType(ultimateElementTypeWrapper.TypeAsArrayType, this.ArrayRank);
@


1.306
log
@Implemented automatically enabling .NET serialization support for Java classes that are trivially serializable.
@
text
@d2258 1
d10385 1
a10385 6
			if(type.ContainsGenericParameters)
			{
				// open generic types are not visible
				return null;
			}
			if(type.IsGenericType)
d10550 37
a10586 1
			if(type.ContainsGenericParameters)
d10588 46
a10633 1
				return false;
a10634 1
			return true;
d11925 13
a11937 1
		internal DotNetTypeWrapper(Type type, string name)
@


1.305
log
@Implemented support for .NET serialization of Java enums.
(The CreateEnumEnum move in FakeTypes.cs is because java.lang.Enum now has a dependency on custom attribute annotations.)
@
text
@a4586 4
					if(f.IsEnum)
					{
						typeAttribs |= TypeAttributes.Serializable;
					}
d7879 1
@


1.304
log
@- Make IsFastClassLiteralSafe return true for various fake annotation types.
- Pass Type to java.lang.Class for "forbidden" and reflection-only types. This is now needed for Class serialization.
@
text
@d4587 4
@


1.303
log
@Fix NRE when getting annotations on delegate constructor for delegates defined in Java (because these constructors don't really exist).
@
text
@d2382 1
a2382 1
							clazz = new java.lang.Class(null);
d10943 5
a11800 5

			internal override bool IsFastClassLiteralSafe
			{
				get { return true; }
			}
@


1.302
log
@Optimized primitive class literals.
@
text
@d10113 5
d10129 5
@


1.301
log
@Implemented optimization to remove .cctor when it is empty (and the class isn't serializable or has a serialVersionUID).
@
text
@d2307 46
d2368 8
a2375 1
						clazz = new java.lang.Class(null);
d2409 20
d2440 5
@


1.300
log
@Made callerID initialization lazy.
@
text
@d4293 8
d4365 12
a4376 1
						if(!IsSideEffectFreeStaticInitializer(m))
d4873 1
a4873 1
			private bool IsSideEffectFreeStaticInitializer(ClassFile.Method m)
d4877 1
d4880 1
d4889 1
d4896 1
d4899 13
d4919 1
d4924 1
d4930 1
d4933 10
d7514 1
a7514 1
						// method doesn't really exist (e.g. delegate constructor)
@


1.299
log
@Moved responsibility for creating java.lang.Class instances for "fast literal" enable types into ClassLiteral<T>, this allows class literals to be really cheap, because non of the underlying reflection is needed, the class will cache the Type and lazily resolve it to its TypeWrapper.
@
text
@d7337 1
a7337 1
			private FieldInfo callerIDField;
d7347 1
a7347 1
			internal FieldInfo CallerIDField
d7349 1
a7349 1
				get
d7351 1
a7351 6
					if (callerIDField == null)
					{
						TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
						callerIDField = typeBuilder.DefineField("__<callerID>", tw.TypeAsSignatureType, FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.InitOnly | FieldAttributes.SpecialName);
					}
					return callerIDField;
d7353 17
d7650 1
a7650 1
				if (clinitIndex != -1 || (basehasclinit && !classFile.IsInterface) || classFile.HasInitializedFields || callerIDField != null)
a7662 11
					// HACK we start out by emitting the users code, because that may trigger the creation of caller id infrastructure
					CodeEmitterLabel label1 = null;
					if (clinitIndex != -1)
					{
						label1 = ilGenerator.DefineLabel();
						CodeEmitterLabel label2 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br, label2);
						ilGenerator.MarkLabel(label1);
						CompileConstructorBody(this, ilGenerator, clinitIndex, invokespecialstubcache);
						ilGenerator.MarkLabel(label2);
					}
a7664 1
					EmitCallerIDInitialization(ilGenerator);
d7671 1
a7671 1
						ilGenerator.Emit(OpCodes.Br, label1);
d8512 1
a8512 1
			private void EmitCallerIDInitialization(CodeEmitter ilGenerator)
a8513 1
				if (callerIDField != null)
@


1.298
log
@Made some classes sealed.
@
text
@d2219 2
a2220 1
			if (IsForbiddenTypeParameterType(type))
d2261 5
d2285 22
d2318 18
a2335 1
					java.lang.Class clazz = java.lang.Class.newClass();
d2361 1
d2363 19
a2381 1
			return (TypeWrapper)(object)((java.lang.Class)classObject).typeWrapper;
d10164 5
d10512 5
d10757 5
d11660 5
d12750 5
d12768 1
d12891 7
@


1.297
log
@Moved class literal emit code to TypeWrapper and added checks to prevent types that are illegal in type instantations from being used with ClassLiteral<T>.
@
text
@d3559 1
a3559 1
	class UnloadableTypeWrapper : TypeWrapper
d3685 1
a3685 1
	class PrimitiveTypeWrapper : TypeWrapper
d10355 1
a10355 1
		private class DelegateInnerClassTypeWrapper : TypeWrapper
d10478 1
a10478 1
		private class EnumEnumTypeWrapper : TypeWrapper
@


1.296
log
@Removed ByteCodeHelperMethods.GetClassFromTypeHandle usage from static compiler.
@
text
@d2213 47
a7271 1
			private FieldInfo classObjectField;
a7282 12
			internal FieldInfo ClassObjectField
			{
				get
				{
					if (classObjectField == null)
					{
						classObjectField = RuntimeHelperTypes.GetClassLiteralField(typeBuilder);
					}
					return classObjectField;
				}
			}

d7977 1
a7977 1
						ilGenerator.Emit(OpCodes.Ldsfld, context.ClassObjectField);
d8045 1
a8045 1
						ilGenerator.Emit(OpCodes.Ldsfld, context.ClassObjectField);
@


1.295
log
@Replaced last usage of ByteCodeHelperMethods.GetClassFromTypeHandle in runtime with LazyEmitLoadClass.
@
text
@d5773 1
a5773 3
					ilgen.Emit(OpCodes.Ldtoken, annotationTypeBuilder);
					ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.GetClassFromTypeHandle);
					CoreClasses.java.lang.Class.Wrapper.EmitCheckcast(null, ilgen);
@


1.294
log
@Added "RuntimeCompatibilityAttribute(WrapNonExceptionThrows = true)" to generated assemblies.
@
text
@d10502 1
a10502 3
					ilgen.Emit(OpCodes.Ldtoken, this.DeclaringType.TypeAsTBD);
					ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.GetClassFromTypeHandle);
					ilgen.Emit(OpCodes.Castclass, CoreClasses.java.lang.Class.Wrapper.TypeAsTBD);
@


1.293
log
@Implemented class gc (available only when compiling on .NET 4.0).
@
text
@d1852 9
@


1.292
log
@Added JavaModuleAttribute to dynamic module to make detection of Java types more straightforward.
@
text
@d7852 1
a7852 1
				ClassLoaderWrapper.SetWrapperForType(type, wrapper);
d8671 8
a8678 1
			if(m.Annotations != null)
d10459 1
a10459 1
					ClassLoaderWrapper.SetWrapperForType(enumType, decl);
d11472 9
a12737 1
					ClassLoaderWrapper.ResetWrapperForType(arrayType, this);
@


1.291
log
@- When building for .NET 4.0, don't use DefineDynamicAssembly() overload that takes assembly permission sets, because .NET 4.0 ignores them anyway.
- Fixed BakedTypeCleanupHack to work for .NET 2.0 SP2.
- Changes to remove warnings when building on .NET 4.0
@
text
@d10169 1
a10169 1
						else if(ClassLoaderWrapper.IsDynamicType(t) || AttributeHelper.IsJavaModule(t.Module))
@


1.290
log
@Added support for declarative security pseudo custom attribute annotations.
@
text
@d285 1
a285 1
			action = SecurityAction.Deny;
d3742 3
d3751 1
a3751 1
				"mm_mdMethodFixups",
d3770 1
a3770 1
				return Environment.Version.Major == 2 && Environment.Version.Minor == 0 && Environment.Version.Build == 50727 && Environment.Version.Revision == 1433;
d3774 2
d3799 2
d3843 1
d3845 1
a3845 1
#endif
@


1.289
log
@- Added hook to allow subclass of DynamicTypeWrapper to inject a different base class.
- Added support to CompiledTypeWrapper.GetBaseTypeWrapper() to skip base classes that aren't visible to Java.
@
text
@d283 1
a283 1
		private static bool IsCodeAccessSecurityAttribute(ClassLoaderWrapper loader, IKVM.Internal.MapXml.Attribute attr, out SecurityAction action, out PermissionSet pset)
d290 1
a290 1
				if(typeof(CodeAccessSecurityAttribute).IsAssignableFrom(t))
d296 1
a296 1
					CodeAccessSecurityAttribute attrib = ci.Invoke(args) as CodeAccessSecurityAttribute;
d311 1
a311 1
			if(IsCodeAccessSecurityAttribute(loader, attr, out action, out pset))
d335 1
a335 1
			if(IsCodeAccessSecurityAttribute(loader, attr, out action, out pset))
d349 1
a349 1
			if(IsCodeAccessSecurityAttribute(loader, attr, out action, out pset))
d408 1
a408 1
				if(typeof(CodeAccessSecurityAttribute).IsAssignableFrom(t))
d410 1
a410 1
					throw new NotImplementedException("CodeAccessSecurityAttribute support not implemented");
d1892 147
a11353 105
				private static object LookupEnumValue(Type enumType, string value)
				{
					FieldInfo field = enumType.GetField(value, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
					if(field != null)
					{
						return field.GetRawConstantValue();
					}
					// both __unspecified and missing values end up here
					return Activator.CreateInstance(Enum.GetUnderlyingType(enumType));
				}

				// note that we only support the integer types that C# supports
				// (the CLI also supports bool, char, IntPtr & UIntPtr)
				private static object OrBoxedIntegrals(object v1, object v2)
				{
					Debug.Assert(v1.GetType() == v2.GetType());
					if(v1 is ulong)
					{
						ulong l1 = (ulong)v1;
						ulong l2 = (ulong)v2;
						return l1 | l2;
					}
					else
					{
						long v = ((IConvertible)v1).ToInt64(null) | ((IConvertible)v2).ToInt64(null);
						switch(Type.GetTypeCode(v1.GetType()))
						{
							case TypeCode.SByte:
								return (sbyte)v;
							case TypeCode.Byte:
								return (byte)v;
							case TypeCode.Int16:
								return (short)v;
							case TypeCode.UInt16:
								return (ushort)v;
							case TypeCode.Int32:
								return (int)v;
							case TypeCode.UInt32:
								return (uint)v;
							case TypeCode.Int64:
								return (long)v;
							default:
								throw new InvalidOperationException();
						}
					}
				}

				private static object ConvertValue(ClassLoaderWrapper loader, Type targetType, object obj)
				{
					if(targetType.IsEnum)
					{
						// TODO check the obj descriptor matches the type we expect
						if(((object[])obj)[0].Equals(AnnotationDefaultAttribute.TAG_ARRAY))
						{
							object[] arr = (object[])obj;
							object value = null;
							for(int i = 1; i < arr.Length; i++)
							{
								// TODO check the obj descriptor matches the type we expect
								string s = ((object[])arr[i])[2].ToString();
								object newval = LookupEnumValue(targetType, s);
								if (value == null)
								{
									value = newval;
								}
								else
								{
									value = OrBoxedIntegrals(value, newval);
								}
							}
							return value;
						}
						else
						{
							string s = ((object[])obj)[2].ToString();
							if(s == "__unspecified")
							{
								// TODO we should probably return null and handle that
							}
							return LookupEnumValue(targetType, s);
						}
					}
					else if(targetType == typeof(Type))
					{
						// TODO check the obj descriptor matches the type we expect
						return loader.FieldTypeWrapperFromSig(((string)((object[])obj)[1]).Replace('/', '.')).TypeAsTBD;
					}
					else if(targetType.IsArray)
					{
						// TODO check the obj descriptor matches the type we expect
						object[] arr = (object[])obj;
						Type elementType = targetType.GetElementType();
						object[] targetArray = new object[arr.Length - 1];
						for(int i = 1; i < arr.Length; i++)
						{
							targetArray[i - 1] = ConvertValue(loader, elementType, arr[i]);
						}
						return targetArray;
					}
					else
					{
						return obj;
					}
				}

d11412 13
a11424 1
					tb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
d11429 13
a11441 1
					cb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
d11446 13
a11458 1
					mb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
d11463 8
a11470 1
					fb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
d11475 8
a11482 1
					pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
d11487 8
a11494 1
					ab.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
d11499 8
a11506 1
					pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
@


1.288
log
@Refactored method call replacement to allow it to be used by others than xml mapping stuff.
@
text
@d4373 1
a4373 1
							typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
d4378 1
a4378 1
							typeBuilder = wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
d8735 5
d8985 7
a8991 1
				return ClassLoaderWrapper.GetWrapperFromType(type.BaseType);
@


1.287
log
@Fix for bug #2777171.
- Use custom enum value decoding because Enum.Parse() doesn't work for ReflectionOnly types.
- Handle enums that use unsigned integer underlying type properly.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
d8734 7
@


1.286
log
@AttributeTargets.Interface wasn't mapped correctly to @@Target(TYPE).
Fixes bug #2777128.
@
text
@d11189 47
d11244 1
a11244 2
							string s = "";
							string sep = "";
d11248 7
a11254 2
								string val = ((object[])arr[i])[2].ToString();
								if(val != "__unspecified")
d11256 1
a11256 2
									s += sep + val;
									sep = ", ";
d11259 1
a11259 5
							if(s == "")
							{
								return Activator.CreateInstance(targetType);
							}
							return Enum.Parse(targetType, s);
d11266 1
a11266 2
								// TODO instead of this, we should probably return null and handle that
								return Activator.CreateInstance(targetType);
d11268 1
a11268 1
							return Enum.Parse(targetType, s);
d11281 1
a11281 1
						Array targetArray = Array.CreateInstance(elementType, arr.Length - 1);
d11284 1
a11284 1
							targetArray.SetValue(ConvertValue(loader, elementType, arr[i]), i - 1);
d11743 1
d11746 1
a11746 1
					underlyingType = typeof(byte);
d11750 1
a11750 1
					underlyingType = typeof(short);
d11754 1
a11754 1
					underlyingType = typeof(int);
d11758 5
a11762 1
					underlyingType = typeof(long);
d11764 1
a11764 1
				TypeWrapper fieldType = ClassLoaderWrapper.GetWrapperFromType(underlyingType);
@


1.285
log
@Removed jsr/ret support.
@
text
@d11148 1
a11148 1
				if ((validOn & (AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Delegate | AttributeTargets.Assembly)) != 0)
@


1.284
log
@Renamed CodeEmitter.Finish() to CheckLabels() and moved invocation to the right place.
@
text
@a2724 5
				// NOTE as a convenience to the compiler, we replace return address types with typeof(int)
				if(VerifierTypeWrapper.IsRet(this))
				{
					return typeof(int);
				}
@


1.283
log
@Delegate fixes.
@
text
@d7362 1
d7422 1
@


1.283.2.1
log
@Backport fix for bug #2777128.
@
text
@d11151 1
a11151 1
				if ((validOn & (AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Delegate | AttributeTargets.Assembly)) != 0)
@


1.283.2.2
log
@Backport fix for bug #2777171.
@
text
@a11191 47
				private static object LookupEnumValue(Type enumType, string value)
				{
					FieldInfo field = enumType.GetField(value, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
					if(field != null)
					{
						return field.GetRawConstantValue();
					}
					// both __unspecified and missing values end up here
					return Activator.CreateInstance(Enum.GetUnderlyingType(enumType));
				}

				// note that we only support the integer types that C# supports
				// (the CLI also supports bool, char, IntPtr & UIntPtr)
				private static object OrBoxedIntegrals(object v1, object v2)
				{
					Debug.Assert(v1.GetType() == v2.GetType());
					if(v1 is ulong)
					{
						ulong l1 = (ulong)v1;
						ulong l2 = (ulong)v2;
						return l1 | l2;
					}
					else
					{
						long v = ((IConvertible)v1).ToInt64(null) | ((IConvertible)v2).ToInt64(null);
						switch(Type.GetTypeCode(v1.GetType()))
						{
							case TypeCode.SByte:
								return (sbyte)v;
							case TypeCode.Byte:
								return (byte)v;
							case TypeCode.Int16:
								return (short)v;
							case TypeCode.UInt16:
								return (ushort)v;
							case TypeCode.Int32:
								return (int)v;
							case TypeCode.UInt32:
								return (uint)v;
							case TypeCode.Int64:
								return (long)v;
							default:
								throw new InvalidOperationException();
						}
					}
				}

d11200 2
a11201 1
							object value = null;
d11205 2
a11206 3
								string s = ((object[])arr[i])[2].ToString();
								object newval = LookupEnumValue(targetType, s);
								if (value == null)
d11208 2
a11209 5
									value = newval;
								}
								else
								{
									value = OrBoxedIntegrals(value, newval);
d11212 5
a11216 1
							return value;
d11223 2
a11224 1
								// TODO we should probably return null and handle that
d11226 1
a11226 1
							return LookupEnumValue(targetType, s);
d11239 1
a11239 1
						object[] targetArray = new object[arr.Length - 1];
d11242 1
a11242 1
							targetArray[i - 1] = ConvertValue(loader, elementType, arr[i]);
a11700 1
				Type javaUnderlyingType;
d11703 1
a11703 1
					javaUnderlyingType = typeof(byte);
d11707 1
a11707 1
					javaUnderlyingType = typeof(short);
d11711 1
a11711 1
					javaUnderlyingType = typeof(int);
d11715 1
a11715 5
					javaUnderlyingType = typeof(long);
				}
				else
				{
					javaUnderlyingType = underlyingType;
d11717 1
a11717 1
				TypeWrapper fieldType = ClassLoaderWrapper.GetWrapperFromType(javaUnderlyingType);
@


1.283.2.3
log
@Fixed regression introduced in 0.40 that caused ikvmstub on core class libraries to fail.
@
text
@a9704 5
			if(mb == null)
			{
				// delegate constructor
				return null;
			}
a9715 5
			if(mb == null)
			{
				// delegate constructor
				return null;
			}
@


1.282
log
@- Added virtual method to MethodWrapper to do custom linking (i.e. defining the method).
- Added the notion of Java methods that don't have a corresponding CLR method (currently only for delegate constructors).
@
text
@d3881 6
a3886 2
			// the inner class is required, if it doesn't exist LoadTypeWrapper will throw a NoClassDefFoundError
			TypeWrapper iface = LoadTypeWrapper(classLoader, f.Name + DotNetTypeWrapper.DelegateInterfaceSuffix);
d3905 1
a3905 1
			if (beginInvoke.Signature != invoke.Signature.Substring(0, invoke.Signature.IndexOf(')')) + "Lcli.System.AsyncCallback;Ljava.lang.Object;)Lcli.System.IAsyncResult;")
d3909 1
a3909 1
			if (endInvoke.Signature != "(Lcli.System.IAsyncResult;)" + invoke.Signature.Substring(invoke.Signature.IndexOf(')') + 1))
d4239 1
a4239 1
								outerClassWrapper = wrapper.GetClassLoader().LoadClassByDottedNameFast(outerClassName) as DynamicTypeWrapper;
@


1.281
log
@Added support for defining delegates in Java.
@
text
@d3865 4
d4521 3
d4529 10
d4542 2
a4543 5
					MethodWrapper mw = GetParameters()[0].GetMethods()[0];
					// TODO linking here is not safe
					mw.Link();
					ilgen.Emit(OpCodes.Ldvirtftn, (MethodInfo)mw.GetMethod());
					ilgen.Emit(OpCodes.Newobj, (ConstructorBuilder)GetMethod());
d6233 2
a6234 10
						if(methods[index] is DelegateConstructorMethodWrapper)
						{
							method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, new Type[] { typeof(object), typeof(IntPtr) }, null, null);
							((ConstructorBuilder)method).SetImplementationFlags(MethodImplAttributes.Runtime);
						}
						else
						{
							method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, methods[index].GetParametersForDefineMethod(), null, modopt);
							((ConstructorBuilder)method).SetImplementationFlags(MethodImplAttributes.NoInlining);
						}
d7192 9
a7200 1
					if (mb is ConstructorBuilder)
d7213 2
a7214 5
						if ((mb.GetMethodImplementationFlags() & MethodImplAttributes.Runtime) == 0)
						{
							CodeEmitter ilGenerator = CodeEmitter.Create((ConstructorBuilder)mb);
							CompileConstructorBody(this, ilGenerator, i, invokespecialstubcache);
						}
d7538 4
d9318 1
d9331 7
d9341 1
a9341 4
				MethodWrapper mw = GetParameters()[0].GetMethods()[0];
				// TODO is linking here safe?
				mw.Link();
				ilgen.Emit(OpCodes.Ldvirtftn, (MethodInfo)mw.GetMethod());
@


1.280
log
@Implemented ikvm.internal.ClassLiteral<T> to allow for more efficient class literals.
@
text
@a3757 11
				if(!f.IsFinal)
				{
					if(BaseTypeWrapper.TypeAsTBD == typeof(ValueType) || BaseTypeWrapper.TypeAsTBD == typeof(Enum))
					{
						throw new VerifyError("Value types must be final");
					}
					if(BaseTypeWrapper.TypeAsTBD == typeof(MulticastDelegate))
					{
						throw new VerifyError("Delegates must be final");
					}
				}
d3762 1
a3762 1
				// NOTE defining value types, enums and delegates is not supported in IKVM v1
d3767 1
a3767 1
				if(BaseTypeWrapper.TypeAsTBD == typeof(MulticastDelegate))
d3769 1
a3769 1
					throw new VerifyError("Defining delegates in Java is not implemented in IKVM v1");
d3804 120
d4103 4
d4515 18
d6219 10
a6228 2
						method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, methods[index].GetParametersForDefineMethod(), null, modopt);
						((ConstructorBuilder)method).SetImplementationFlags(MethodImplAttributes.NoInlining);
d7199 5
a7203 2
						CodeEmitter ilGenerator = CodeEmitter.Create((ConstructorBuilder)mb);
						CompileConstructorBody(this, ilGenerator, i, invokespecialstubcache);
d7235 5
d9300 26
d9328 1
d9345 4
d11396 8
d11746 6
@


1.279
log
@Made Mono compilation workarounds conditional on __MonoCS__.
@
text
@d6937 1
a6937 1
						classObjectField = typeBuilder.DefineField("__<classObject>", typeof(object), FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.SpecialName);
a7615 9
					FieldInfo classObjectField;
					if (thruProxy)
					{
						classObjectField = typeBuilder.DefineField("__<classObject>", typeof(object), FieldAttributes.Static | FieldAttributes.Private | FieldAttributes.SpecialName);
					}
					else
					{
						classObjectField = context.ClassObjectField;
					}
d7618 1
a7618 8
						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
						CodeEmitterLabel label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Brtrue_S, label);
						ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.GetClassFromTypeHandle);
						ilGenerator.Emit(OpCodes.Stsfld, classObjectField);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
d7686 1
a7686 10

						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
						CodeEmitterLabel label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Brtrue_S, label);
						ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.GetClassFromTypeHandle);
						ilGenerator.Emit(OpCodes.Stsfld, classObjectField);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);

@


1.278
log
@Workaround for apparent Mono (2.2 and 2.4 preview 2 tested) bug in Interlocked.Exchange. Doesn't repro in isolation (but I didn't try very hard).
@
text
@d2088 1
d2090 3
d2100 1
d2106 1
@


1.277
log
@Added caching to GetWrapperFromDotNetType.
@
text
@d2089 2
a2090 1
					System.Threading.Interlocked.Exchange(ref classObject, clazz);
@


1.276
log
@Use double checked locking to avoid taking the lock in the common case when accessing TypeWrapper.ClassObject.
@
text
@d9713 1
d11172 14
a11185 2
			// TODO this might benefit from caching
			return ClassLoaderWrapper.GetAssemblyClassLoader(type.Assembly).GetWrapperFromAssemblyType(type);
@


1.275
log
@Make sure we get the right Type.GetTypeHandle and RuntimeTypeHandle.get_Value methods and cache them.
@
text
@d2068 13
a2080 1
				lock(this)
a2081 2
					if(classObject == null)
					{
d2083 2
a2084 2
						// DynamicTypeWrapper should haved already had SetClassObject explicitly
						Debug.Assert(!(this is DynamicTypeWrapper));
d2087 3
a2089 3
						java.lang.Class clazz = java.lang.Class.newClass();
						SetTypeWrapperHack(ref clazz.typeWrapper, this);
						classObject = clazz;
a2090 1
					}
a2091 1
				return classObject;
@


1.274
log
@Intrisified two uses of Object.getClass().
@
text
@d56 2
d129 1
a129 1
			ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeHandle"));
d133 1
a133 1
			ilgen.Emit(OpCodes.Call, typeof(RuntimeTypeHandle).GetMethod("get_Value"));
@


1.273
log
@Changed "InternalsVisibleTo" handling to be based on Assembly instead of class loader.
@
text
@d124 9
@


1.272
log
@Fixed AssemblyClassLoader.GetAssembly() to handle fake types.
@
text
@d2604 1
a2604 1
				|| (IsInternal && GetClassLoader().InternalsVisibleTo(wrapper.GetClassLoader()))
d2608 5
d2615 1
a2615 1
			return MatchingPackageNames(name, wrapper.name) && GetClassLoader().InternalsVisibleTo(wrapper.GetClassLoader());
d3960 1
a3960 1
						&& CoreClasses.java.lang.Object.Wrapper.GetClassLoader().InternalsVisibleTo(wrapper.GetClassLoader()))
d5751 1
a5751 1
							|| (baseMethod.IsInternal && baseMethod.DeclaringType.GetClassLoader().InternalsVisibleTo(wrapper.GetClassLoader())))
@


1.271
log
@- Implemented GetEnclosingMethod for ReflectionOnly assemblies.
- Fixed pointer type check for method return types.
@
text
@d2221 9
@


1.270
log
@Fixed CallerID method detection to work correctly for core library classes that aren't in IKVM.OpenJDK.Core.dll.
@
text
@a147 1
		private static Type typeofEnclosingMethodAttribute = JVM.LoadType(typeof(EnclosingMethodAttribute));
d169 1
d1770 23
d9467 2
a9468 2
			object[] attr = type.GetCustomAttributes(typeof(EnclosingMethodAttribute), false);
			if(attr.Length == 1)
a9469 1
				EnclosingMethodAttribute enc = (EnclosingMethodAttribute)attr[0];
d11812 1
a11812 1
				if(type.IsPointer || type.IsByRef)
@


1.269
log
@Support CallerID in all core class library assemblies.
@
text
@d9056 1
a9056 1
				&& ClassLoaderWrapper.IsCoreAssemblyType(method.DeclaringType))
@


1.268
log
@Now that InternalsVisibleTo() has a side effect (in ikvmc, it potentially adds an InternalsVisibleToAttribute) swap around the tests, to only call InternalsVisibleTo() if the package names actually match.
@
text
@d3923 1
a3923 1
						&& wrapper.GetClassLoader() == CoreClasses.java.lang.Object.Wrapper.GetClassLoader())
@


1.267
log
@Made two access checks runtime-only, because for the static compiler they aren't necessary and they break InternalsVisibleToAttribute support.
@
text
@d2578 19
a2596 1
			if(GetClassLoader().InternalsVisibleTo(wrapper.GetClassLoader()))
d2598 15
a2612 32
				int index1 = name.LastIndexOf('.');
				int index2 = wrapper.name.LastIndexOf('.');
				if(index1 == -1 && index2 == -1)
				{
					return true;
				}
				// for array types we need to skip the brackets
				int skip1 = 0;
				int skip2 = 0;
				while(name[skip1] == '[')
				{
					skip1++;
				}
				while(wrapper.name[skip2] == '[')
				{
					skip2++;
				}
				if(skip1 > 0)
				{
					// skip over the L that follows the brackets
					skip1++;
				}
				if(skip2 > 0)
				{
					// skip over the L that follows the brackets
					skip2++;
				}
				if((index1 - skip1) != (index2 - skip2))
				{
					return false;
				}
				return String.CompareOrdinal(name, skip1, wrapper.name, skip2, index1 - skip1) == 0;
d2614 1
a2614 1
			return false;
d11116 1
@


1.266
log
@Fixed regression introduced in previous change the __<clinit> handling: In dynamic mode the MethodInfo that we're calling can't be an unfinished method, because DynamicMethod's ILGenerator can't handle that.
@
text
@d3679 1
d3685 1
d3729 1
d3740 1
@


1.265
log
@Always emit an explicit method override if we've mangled the name/sig, because we can't predict whether it will be needed or not (without keeping track of the mangling in the base classes) and the cost is minimal since this doesn't happen all that often.
@
text
@d5018 10
a5027 1
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, wrapper.ReflectiveModifiers, Metadata.Create(classFile), clinitMethod, finalizeMethod
@


1.264
log
@Miranda method should use mangled name (if the name is mangled).
@
text
@d6180 1
a6180 1
							bool needMethodImpl = baseMce != null && (explicitOverride || baseMce.RealName != name) && !needFinalize;
@


1.263
log
@Fixed pointer detection to work for types with multiple indirection levels.
@
text
@d5856 1
a5856 1
							MethodBuilder mb = typeBuilder.DefineMethod(methods[index].Name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
@


1.262
log
@Integrated IKVM.Reflection.Emit in ikvmc.
@
text
@d11685 1
a11685 1
				if(mi.ReturnType.IsPointer || mi.ReturnType.IsByRef)
d11691 1
a11691 1
					if(p.ParameterType.IsByRef || p.ParameterType.IsPointer)
d11700 13
d11730 1
a11730 1
				if(type.IsPointer)
a11739 8
					if(type.GetElementType().IsPointer)
					{
						name = null;
						sig = null;
						args = null;
						ret = null;
						return false;
					}
@


1.261
log
@Restructured handling of finalize() method a little, to prepare for IKVM.Reflection.Emit.
@
text
@d27 3
a29 1
#if !COMPACT_FRAMEWORK
d2981 1
a2981 1
				else if(!mce.DeclaringType.TypeAsTBD.Assembly.Equals(typeBuilder.Assembly))
d3679 1
a3679 1
				if(!BaseTypeWrapper.IsPublic && !BaseTypeWrapper.TypeAsBaseType.Assembly.Equals(classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly))
d3728 2
a3729 2
					&& !iface.TypeAsBaseType.Assembly.Equals(classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly)
					&& iface.TypeAsBaseType.Assembly.GetType(DynamicClassLoader.GetProxyHelperName(iface.TypeAsTBD)) == null)
d7881 1
a7881 1
						if (!iface.IsPublic && !ifaceType.Assembly.Equals(typeBuilder.Assembly))
@


1.260
log
@finalize() and clone() should be final in cli.System.Object and cli.System.Exception.
@
text
@d3859 1
d5016 1
a5016 1
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, wrapper.ReflectiveModifiers, Metadata.Create(classFile)
d5735 1
a5735 1
			private static MethodInfo GetBaseFinalizeMethod(TypeWrapper wrapper, out bool clash)
a5736 1
				clash = false;
a5746 5
					JavaTypeImpl impl = dtw.impl as JavaTypeImpl;
					if(impl == null)
					{
						break;
					}
d5752 2
a5753 1
					if(impl.finalizeMethod != null)
d5755 1
a5755 1
						return impl.finalizeMethod;
d5759 4
a5780 1
							clash = true;
a6120 1
							bool finalizeClash = false;
d6124 2
a6125 10
								baseFinalize = GetBaseFinalizeMethod(wrapper.BaseTypeWrapper, out finalizeClash);
								if(baseMce.RealName == "Finalize")
								{
									// We're overriding Finalize (that was renamed to finalize by DotNetTypeWrapper)
									// in a non-Java base class.
									attribs |= MethodAttributes.NewSlot;
									needFinalize = true;
									needDispatch = true;
								}
								else if(baseMce.DeclaringType == CoreClasses.java.lang.Object.Wrapper)
d6220 3
a6222 3
								string finalizeName = finalizeClash ? "__<Finalize>" : baseFinalize.Name;
								// if the Java class also defines a Finalize() method, we need to name the stub differently
								foreach(ClassFile.Method mi in classFile.Methods)
d6224 1
a6224 5
									if(mi.Name == "Finalize" && mi.Signature == "()V")
									{
										finalizeName = "__<Finalize>";
										break;
									}
d6440 5
d6677 1
d6684 1
a6684 1
			internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers, Metadata metadata
d6695 2
a6696 1
				this.clinitMethod = type.GetMethod("__<clinit>", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
d6811 5
@


1.259
log
@Hide nested types generated for callerID support.
@
text
@d11377 1
a11377 1
				: base(tw, "finalize", "()V", null, PrimitiveTypeWrapper.VOID, TypeWrapper.EmptyArray, Modifiers.Protected, MemberFlags.None)
d11395 1
a11395 1
				: base(tw, "clone", "()Ljava.lang.Object;", null, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Protected, MemberFlags.None)
@


1.258
log
@Added support for detecting "access" bridge methods and not hide them.
@
text
@d8880 1
a8880 1
						if(!AttributeHelper.IsHideFromJava(nestedTypes[i]))
@


1.258.2.1
log
@Backported fixes and updated version to 0.38.0.1:
- Hide callerID nested types.
- Made finalize() and clone() methods in cli.System.Object and cli.System.Exception final.
- Fixed reflection to work on .NET 2.0 RTM.
@
text
@d8880 1
a8880 1
						if(!AttributeHelper.IsHideFromJava(nestedTypes[i]) && !nestedTypes[i].Name.StartsWith("__<"))
d11377 1
a11377 1
				: base(tw, "finalize", "()V", null, PrimitiveTypeWrapper.VOID, TypeWrapper.EmptyArray, Modifiers.Protected | Modifiers.Final, MemberFlags.None)
d11395 1
a11395 1
				: base(tw, "clone", "()Ljava.lang.Object;", null, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Protected | Modifiers.Final, MemberFlags.None)
@


1.258.2.2
log
@Changed version to 0.38.0.3 and backported these fixes:
- Fixed the stack trace when an unwrapped java.lang.Error (or subclass) escapes from a static initializer.
- It turns out that we really should create an MBeanServer in sun.management.ManagementFactory.createPlatformMBeanServer(), even if we don't populate it with anything useful, applications might still want to register their own MBeans. This fix allows Derby 10.4.2.0 to work.
- Added helpful message to ClassCastException generated for ghost array casts.
- Added check for constructor with missing body in map.xml.
- Removed over eager state checking from java.util.zip.Deflater. Fixes Lucene issue.
- Fixed enclosing method discovery to work for ReflectionOnly assemblies. This allows ikvmstub to work with ikvmc generated assemblies.
- Always emit an explicit method override if we've mangled the name/sig, because we can't predict whether it will be needed or not (without keeping track of the mangling in the base classes) and the cost is minimal since this doesn't happen all that often.
- Miranda method should use mangled name (if the name is mangled).
- Fixed pointer detection to work for types with multiple indirection levels.
- If the last call site of a subroutine wasn't reachable, the return switch would fall through potentially causing the code to be unverifiable.
- The check for unloadable types on the stack indexed the stack in the wrong order.
- Fixed exception wrapping for java.security.AccessController.doPrivileged().
- Fixed tracer to only add a trace listener in executables.
@
text
@d146 1
a167 1
		private static Type typeofEnclosingMethodAttribute = JVM.LoadType(typeof(EnclosingMethodAttribute));
a1767 23
		internal static EnclosingMethodAttribute GetEnclosingMethodAttribute(Type type)
		{
			if (type.Assembly.ReflectionOnly)
			{
				foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
				{
					if (MatchTypes(cad.Constructor.DeclaringType, typeofEnclosingMethodAttribute))
					{
						return new EnclosingMethodAttribute((string)cad.ConstructorArguments[0].Value, (string)cad.ConstructorArguments[1].Value, (string)cad.ConstructorArguments[2].Value);
					}
				}
			}
			else
			{
				object[] attr = type.GetCustomAttributes(typeof(EnclosingMethodAttribute), false);
				if (attr.Length == 1)
				{
					return (EnclosingMethodAttribute)attr[0];
				}
			}
			return null;
		}

d5855 1
a5855 1
							MethodBuilder mb = typeBuilder.DefineMethod(name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
d6188 1
a6188 1
							bool needMethodImpl = baseMce != null && (setNameSig || explicitOverride || baseMce.RealName != name) && !needFinalize;
d9430 2
a9431 2
			EnclosingMethodAttribute enc = AttributeHelper.GetEnclosingMethodAttribute(type);
			if (enc != null)
d9433 1
d11685 1
a11685 1
				if(mi.ReturnType.IsByRef || IsPointerType(mi.ReturnType))
d11691 1
a11691 1
					if(p.ParameterType.IsByRef || IsPointerType(p.ParameterType))
a11699 13
		private static bool IsPointerType(Type type)
		{
			while(type.HasElementType)
			{
				if(type.IsPointer)
				{
					return true;
				}
				type = type.GetElementType();
			}
			return false;
		}

d11717 1
a11717 1
				if(IsPointerType(type))
d11727 8
d11770 1
a11770 1
				if(IsPointerType(type) || type.IsByRef)
@


1.257
log
@Removed last parts of old-style reflection.
@
text
@d6299 3
a6301 1
						&& (m.IsPublic || m.IsProtected) && wrapper.IsPublic)
d6339 25
@


1.256
log
@- Removed "slow" reflection.
- Removed MethodWrapper.Invoke().
- Removed FieldWrapper.GetValue()/SetValue().
- Added ICustomInvoke for the few MethodWrappers that still require custom reflection invocation.
@
text
@d9160 1
a9160 1
		private class CompiledRemappedMethodWrapper : SmartMethodWrapper, ICustomInvoke
d9224 1
a9224 1
			object ICustomInvoke.Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
d9226 6
a9231 2
				MethodBase mb;
				if(nonVirtual)
d9233 1
a9233 17
					if(DeclaringType.TypeAsBaseType.IsInstanceOfType(obj))
					{
						mb = GetMethod();
					}
					else if(mbNonvirtualHelper != null)
					{
						mb = mbNonvirtualHelper;
					}
					else if(mbHelper != null)
					{
						mb = mbHelper;
					}
					else
					{
						// we can end up here if someone calls a constructor with nonVirtual set (which is pointless, but legal)
						mb = GetMethod();
					}
d9235 10
a9244 5
				else
				{
					mb = mbHelper != null ? mbHelper : GetMethod();
				}
				return InvokeImpl(mb, obj, args, nonVirtual, callerID);
d9962 1
a9962 1
			object ICustomInvoke.Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
d10064 1
a10064 1
				object ICustomInvoke.Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
d10093 1
a10093 1
				object ICustomInvoke.Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
@


1.255
log
@Changed JNI reflection to be based on Java reflection (where possible).
@
text
@d9160 1
a9160 1
		private class CompiledRemappedMethodWrapper : SmartMethodWrapper
d9224 1
a9224 1
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
d9953 1
a9953 1
		private class DynamicOnlyMethodWrapper : MethodWrapper
d9969 1
a9969 1
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
d9971 11
a9981 3
				return TypeWrapper.FromClass(NativeCode.ikvm.runtime.Util.getClassFromObject(obj))
					.GetMethodWrapper(this.Name, this.Signature, true)
					.Invoke(obj, args, false, callerID);
d10014 5
d10030 1
a10030 1
				internal override object GetValue(object unused)
d10055 1
a10055 1
			private class EnumValuesMethodWrapper : MethodWrapper
d10071 1
a10071 1
				internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
d10077 1
a10077 1
						array[i] = values[i].GetValue(null);
d10084 1
a10084 1
			private class EnumValueOfMethodWrapper : MethodWrapper
d10100 1
a10100 1
				internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
d10107 1
a10107 1
							return values[i].GetValue(null);
d10479 2
a10480 1
						return mw.ReturnType.GetFieldWrapper("__unspecified", mw.ReturnType.SigName).GetValue(null);
a11173 9

#if !STATIC_COMPILER && !FIRST_PASS
			[HideFromJava]
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
			{
				// TODO map exceptions
				return Delegate.CreateDelegate(DeclaringType.TypeAsTBD, args[0], "Invoke");
			}
#endif // !STATIC_COMPILER && !FIRST_PASS
a11241 29

#if !STATIC_COMPILER && !FIRST_PASS
			[HideFromJava]
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
			{
				object[] newargs = (object[])args.Clone();
				for(int i = 0; i < newargs.Length; i++)
				{
					if(byrefs[i])
					{
						newargs[i] = ((Array)args[i]).GetValue(0);
					}
				}
				try
				{
					return base.Invoke(obj, newargs, nonVirtual, callerID);
				}
				finally
				{
					for(int i = 0; i < newargs.Length; i++)
					{
						if(byrefs[i])
						{
							((Array)args[i]).SetValue(newargs[i], 0);
						}
					}
				}
			}
#endif // !STATIC_COMPILER && !FIRST_PASS
a11263 8

#if !STATIC_COMPILER && !FIRST_PASS
			[HideFromJava]
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
			{
				return Enum.ToObject(DeclaringType.TypeAsTBD, ((IConvertible)args[0]).ToInt64(null));
			}
#endif // !STATIC_COMPILER && !FIRST_PASS
a11295 10
#if !STATIC_COMPILER
			internal override void SetValue(object obj, object val)
			{
				// NOTE even though the field is final, JNI reflection can still be used to set its value!
				// NOTE the CLI spec says that an enum has exactly one instance field, so we take advantage of that fact.
				FieldInfo f = DeclaringType.TypeAsTBD.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)[0];
				f.SetValue(obj, val);
			}
#endif // !STATIC_COMPILER

a11334 7

#if !STATIC_COMPILER
			internal override object GetValue(object obj)
			{
				return GetEnumPrimitiveValue(obj);
			}
#endif // !STATIC_COMPILER
a11351 12

#if !STATIC_COMPILER && !FIRST_PASS
			[HideFromJava]
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
			{
				if(obj == null)
				{
					obj = Activator.CreateInstance(DeclaringType.TypeAsTBD);
				}
				return obj;
			}
#endif // !STATIC_COMPILER && !FIRST_PASS
a11369 7

#if !STATIC_COMPILER && !FIRST_PASS
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
			{
				return null;
			}
#endif // !STATIC_COMPILER && !FIRST_PASS
a11397 7

#if !STATIC_COMPILER && !FIRST_PASS
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
			{
				return CoreClasses.java.lang.Object.Wrapper.GetMethodWrapper(Name, Signature, false).Invoke(obj, args, nonVirtual, callerID);
			}
#endif // !STATIC_COMPILER && !FIRST_PASS
a11657 8

#if !STATIC_COMPILER && !FIRST_PASS
			[HideFromJava]
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
			{
				return m.Invoke(obj, args, nonVirtual, callerID);
			}
#endif // !STATIC_COMPILER && !FIRST_PASS
@


1.254
log
@Generified all collections.
@
text
@d11318 7
a11324 1
				throw new InvalidOperationException();
@


1.253
log
@Removed unused per-type class caching.
@
text
@a24 1
using System.Collections;
a34 1

d1741 1
a1741 1
				ArrayList attrs = new ArrayList();
d3013 1
a3013 1
		internal void ImplementInterfaceMethodStubs(TypeBuilder typeBuilder, DynamicTypeWrapper wrapper, Hashtable doneSet)
d3871 1
a3871 1
			private Hashtable memberclashtable;
d3944 2
a3945 2
					ArrayList methodsArray = null;
					ArrayList baseMethodsArray = null;
d3948 2
a3949 2
						methodsArray = new ArrayList(methods);
						baseMethodsArray = new ArrayList(baseMethods);
d3960 2
a3961 2
								methodsArray = new ArrayList(methods);
								baseMethodsArray = new ArrayList(baseMethods);
d3970 2
a3971 2
						this.methods = (MethodWrapper[])methodsArray.ToArray(typeof(MethodWrapper));
						this.baseMethods = (MethodWrapper[])baseMethodsArray.ToArray(typeof(MethodWrapper));
d4000 1
a4000 1
					ArrayList fieldsArray = new ArrayList(fields);
d4002 1
a4002 1
					fields = (FieldWrapper[])fieldsArray.ToArray(typeof(FieldWrapper));
d4418 13
a4430 1
			private static bool ContainsMemberWrapper(ArrayList members, string name, string sig)
d4443 1
a4443 1
			private MethodWrapper GetMethodWrapperDuringCtor(TypeWrapper lookup, ArrayList methods, string name, string sig)
d4469 1
a4469 1
			private void AddMirandaMethods(ArrayList methods, ArrayList baseMethods, TypeWrapper tw)
d4507 1
a4507 1
			private void AddAccessStubMethods(ArrayList methods, ArrayList baseMethods, TypeWrapper tw)
d4522 1
a4522 1
			private void AddAccessStubFields(ArrayList fields, TypeWrapper tw)
d4960 1
a4960 1
						ArrayList wrappers = new ArrayList();
d4975 1
a4975 1
						innerClassesTypeWrappers = (TypeWrapper[])wrappers.ToArray(typeof(TypeWrapper));
d5607 1
a5607 1
						memberclashtable = new Hashtable();
d5722 1
a5722 1
				lock (memberclashtable.SyncRoot)
d6935 1
a6935 1
				Hashtable invokespecialstubcache = new Hashtable();
d7158 1
a7158 1
				ImplementInterfaces(wrapper.Interfaces, new ArrayList());
d7181 1
a7181 1
					Hashtable doneSet = new Hashtable();
d7208 1
a7208 1
								Hashtable hashtable = null;
d7221 1
a7221 1
								Hashtable hashtable = null;
d7797 1
a7797 1
			private void AddMethodOverride(MethodWrapper method, MethodBuilder mb, TypeWrapper iface, string name, string sig, ref Hashtable hashtable, bool unloadableOnly)
d7808 1
a7808 1
						hashtable = new Hashtable();
d7845 1
a7845 1
			private void ImplementInterfaces(TypeWrapper[] interfaces, ArrayList interfaceList)
d7866 1
a7866 1
									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(typeof(IEnumerable))))
d7871 1
a7871 1
										typeBuilder.AddInterfaceImplementation(typeof(IEnumerable));
d7873 1
a7873 1
										MethodBuilder mb = typeBuilder.DefineMethod("System.Collections.IEnumerable.GetEnumerator", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, typeof(IEnumerator), Type.EmptyTypes);
d7875 1
a7875 1
										typeBuilder.DefineMethodOverride(mb, typeof(IEnumerable).GetMethod("GetEnumerator"));
d7929 1
a7929 1
				Hashtable h = new Hashtable();
d7965 1
a7965 1
			private void CompileConstructorBody(FinishContext context, CodeEmitter ilGenerator, int methodIndex, Hashtable invokespecialstubcache)
d8113 1
a8113 1
			ArrayList names = new ArrayList();
d8203 1
a8203 1
			Hashtable clashes = null;
d8214 1
a8214 1
							clashes = new Hashtable();
d8219 1
a8219 1
							clash = (int)clashes[name] + 1;
d8554 2
a8555 2
				ArrayList methods = new ArrayList();
				ArrayList fields = new ArrayList();
d8604 2
a8605 2
				SetMethods((MethodWrapper[])methods.ToArray(typeof(MethodWrapper)));
				SetFields((FieldWrapper[])fields.ToArray(typeof(FieldWrapper)));
d8850 1
a8850 1
					ArrayList wrappers = new ArrayList();
d8862 1
a8862 1
					innerclasses = (TypeWrapper[])wrappers.ToArray(typeof(TypeWrapper));
d8964 1
a8964 1
			ArrayList list = new ArrayList();
d8996 1
a8996 1
						sigparam = (string[])list.ToArray(typeof(string));
d9077 2
a9078 2
			ArrayList methods = new ArrayList();
			ArrayList fields = new ArrayList();
d9156 2
a9157 2
			SetMethods((MethodWrapper[])methods.ToArray(typeof(MethodWrapper)));
			SetFields((FieldWrapper[])fields.ToArray(typeof(FieldWrapper)));
d10104 1
a10104 1
				ArrayList fields = new ArrayList();
d10115 1
a10115 1
				SetFields((FieldWrapper[])fields.ToArray(typeof(FieldWrapper)));
d10392 1
a10392 1
				ArrayList methods = new ArrayList();
d10415 1
a10415 1
				SetMethods((MethodWrapper[])methods.ToArray(typeof(MethodWrapper)));
d10800 1
a10800 1
							ArrayList list = new ArrayList();
d10810 1
a10810 1
							innerClasses = (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
d10971 4
a10974 4
					ArrayList properties = new ArrayList();
					ArrayList propertyValues = new ArrayList();
					ArrayList fields = new ArrayList();
					ArrayList fieldValues = new ArrayList();
d11007 4
a11010 4
						(PropertyInfo[])properties.ToArray(typeof(PropertyInfo)),
						(object[])propertyValues.ToArray(),
						(FieldInfo[])fields.ToArray(typeof(FieldInfo)),
						(object[])fieldValues.ToArray());
d11493 1
a11493 1
				ArrayList fieldsList = new ArrayList();
d11512 1
a11512 1
				SetFields((FieldWrapper[])fieldsList.ToArray(typeof(FieldWrapper)));
d11517 1
a11517 1
				ArrayList fieldsList = new ArrayList();
d11532 1
a11532 1
				SetFields((FieldWrapper[])fieldsList.ToArray(typeof(FieldWrapper)));
d11534 1
a11534 1
				Hashtable methodsList = new Hashtable();
d11593 2
a11594 1
							MethodWrapper existing = (MethodWrapper)methodsList[key];
d11631 2
a11632 1
										MethodWrapper existing = (MethodWrapper)methodsList[key];
d11931 1
a11931 1
						ArrayList list = new ArrayList(nestedTypes.Length);
d11952 1
a11952 1
						innerClasses = (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
@


1.252
log
@Eleminated some (CompilerClassLoader) downcasts by making the type of the DynamicTypeWrapper.classLoader field depend on whether we're compiling the runtime or ikvmc.
@
text
@d247 1
a247 1
					pi.SetValue(attrib, ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, new Hashtable(), prop.Sig), prop.Value), null);
d255 1
a255 1
					fi.SetValue(attrib, ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, new Hashtable(), field.Sig), field.Value));
d361 1
a361 1
			TypeWrapper[] twargs = ClassFile.ArgTypeWrapperListFromSig(loader, new Hashtable(), attr.Sig);
d370 1
a370 1
					tw = ClassFile.FieldTypeWrapperFromSig(loader, new Hashtable(), attr.Params[i].Sig);
d415 1
a415 1
						propertyValues[i] = ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, new Hashtable(), attr.Properties[i].Sig), attr.Properties[i].Value);
d432 1
a432 1
						fieldValues[i] = ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, new Hashtable(), attr.Fields[i].Sig), attr.Fields[i].Value);
d467 1
a467 1
						fieldValues[i] = ParseValue(loader, ClassFile.FieldTypeWrapperFromSig(loader, new Hashtable(), attr.Fields[i].Sig), attr.Fields[i].Value);
a3873 1
			private Hashtable classCache = Hashtable.Synchronized(new Hashtable());
d4891 1
a4891 1
				classFile.Link(wrapper, classCache);
@


1.251
log
@Replaced usage of BootstrapClassLoader with actual class loader in static compiler.
@
text
@d3640 3
d3644 1
d3662 3
d3666 1
@


1.250
log
@Don't generated nested type when the outer type is in a different class loader (this can now happen with ikvmc's multi target support).
@
text
@d172 1
a172 1
		private static object ParseValue(TypeWrapper tw, string val)
d194 1
a194 1
				TypeWrapper valtw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast(val);
d239 1
a239 1
		private static void SetPropertiesAndFields(Attribute attrib, IKVM.Internal.MapXml.Attribute attr)
d247 1
a247 1
					pi.SetValue(attrib, ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), prop.Sig), prop.Value), null);
d255 1
a255 1
					fi.SetValue(attrib, ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), field.Sig), field.Value));
d260 1
a260 1
		internal static Attribute InstantiatePseudoCustomAttribute(IKVM.Internal.MapXml.Attribute attr)
d265 1
a265 1
			GetAttributeArgsAndTypes(attr, out argTypes, out args);
d268 1
a268 1
			SetPropertiesAndFields(attrib, attr);
d272 1
a272 1
		private static bool IsCodeAccessSecurityAttribute(IKVM.Internal.MapXml.Attribute attr, out SecurityAction action, out PermissionSet pset)
d283 1
a283 1
					GetAttributeArgsAndTypes(attr, out argTypes, out args);
d286 1
a286 1
					SetPropertiesAndFields(attrib, attr);
d296 1
a296 1
		internal static void SetCustomAttribute(TypeBuilder tb, IKVM.Internal.MapXml.Attribute attr)
d300 1
a300 1
			if(IsCodeAccessSecurityAttribute(attr, out action, out pset))
d306 1
a306 1
				tb.SetCustomAttribute(CreateCustomAttribute(attr));
d310 1
a310 1
		internal static void SetCustomAttribute(FieldBuilder fb, IKVM.Internal.MapXml.Attribute attr)
d312 1
a312 1
			fb.SetCustomAttribute(CreateCustomAttribute(attr));
d315 1
a315 1
		internal static void SetCustomAttribute(ParameterBuilder pb, IKVM.Internal.MapXml.Attribute attr)
d317 1
a317 1
			pb.SetCustomAttribute(CreateCustomAttribute(attr));
d320 1
a320 1
		internal static void SetCustomAttribute(MethodBuilder mb, IKVM.Internal.MapXml.Attribute attr)
d324 1
a324 1
			if(IsCodeAccessSecurityAttribute(attr, out action, out pset))
d330 1
a330 1
				mb.SetCustomAttribute(CreateCustomAttribute(attr));
d334 1
a334 1
		internal static void SetCustomAttribute(ConstructorBuilder cb, IKVM.Internal.MapXml.Attribute attr)
d338 1
a338 1
			if(IsCodeAccessSecurityAttribute(attr, out action, out pset))
d344 1
a344 1
				cb.SetCustomAttribute(CreateCustomAttribute(attr));
d348 1
a348 1
		internal static void SetCustomAttribute(PropertyBuilder pb, IKVM.Internal.MapXml.Attribute attr)
d350 1
a350 1
			pb.SetCustomAttribute(CreateCustomAttribute(attr));
d353 1
a353 1
		internal static void SetCustomAttribute(AssemblyBuilder ab, IKVM.Internal.MapXml.Attribute attr)
d355 1
a355 1
			ab.SetCustomAttribute(CreateCustomAttribute(attr));
d358 1
a358 1
		private static void GetAttributeArgsAndTypes(IKVM.Internal.MapXml.Attribute attr, out Type[] argTypes, out object[] args)
d361 1
a361 1
			TypeWrapper[] twargs = ClassFile.ArgTypeWrapperListFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Sig);
d370 1
a370 1
					tw = ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Params[i].Sig);
d377 1
a377 1
						arr.SetValue(ParseValue(tw.ElementTypeWrapper, attr.Params[i].Elements[j].Value), j);
d383 1
a383 1
					args[i] = ParseValue(tw, attr.Params[i].Value);
d388 1
a388 1
		private static CustomAttributeBuilder CreateCustomAttribute(IKVM.Internal.MapXml.Attribute attr)
d393 1
a393 1
			GetAttributeArgsAndTypes(attr, out argTypes, out args);
d415 1
a415 1
						propertyValues[i] = ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Properties[i].Sig), attr.Properties[i].Value);
d432 1
a432 1
						fieldValues[i] = ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Fields[i].Sig), attr.Fields[i].Value);
d448 1
a448 1
				TypeWrapper t = ClassLoaderWrapper.LoadClassCritical(attr.Class);
d467 1
a467 1
						fieldValues[i] = ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Fields[i].Sig), attr.Fields[i].Value);
@


1.249
log
@Removed support for building with GNU Classpath class library.
@
text
@d4051 4
a4054 2
								// baking the outer type before the inner type)
								if(outerClassWrapper.impl is JavaTypeImpl)
@


1.248
log
@- Removed Mono workarounds that are no longer needed with Mono 2.0
- Fixed ikvmc build error introduced in previous patch.
@
text
@d2042 1
a2042 2
#if FIRST_PASS
#elif OPENJDK
a2045 2
#else
						classObject = JVM.Library.newClass(this, null, GetClassLoader().GetJavaClassLoader());
d2063 1
a2063 1
#elif OPENJDK
a2065 2
#else
			return (TypeWrapper)JVM.Library.getWrapperFromClass(classObject);
a3986 10
#if STATIC_COMPILER && !OPENJDK
					else if(fld.IsFinal
						&& (fld.IsPublic || fld.IsProtected)
						&& wrapper.IsPublic
						&& !wrapper.IsInterface
						&& (!wrapper.classLoader.StrictFinalFieldSemantics || wrapper.Name == "java.lang.System"))
					{
						fields[i] = new GetterFieldWrapper(wrapper, null, null, fld.Name, fld.Signature, new ExModifiers(fld.Modifiers, fld.IsInternal), null, null);
					}
#endif
@


1.247
log
@- Added ghost array tagging to be able to report the instantiated class (instead of object[] which is allocated instead).
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
@
text
@d2871 1
d2882 1
d4767 1
a4767 4
					// MONOBUG the __<> prefix for wrapped final fields is to work around a bug in mcs 1.1.17
					// it crashes when it tries to lookup the property with the same name as the privatescope field
					// http://bugzilla.ximian.com/show_bug.cgi?id=79451
					field = typeBuilder.DefineField(isWrappedFinal ? "__<>" + fieldName : fieldName, type, modreq, Type.EmptyTypes, attribs);
@


1.246
log
@Fix for bug #2006953.
@
text
@a2872 1
#if !FIRST_PASS && !STATIC_COMPILER
a2876 9
				if(thisWrapper.IsGhostArray)
				{
					TypeWrapper elementType = objWrapper;
					while(elementType.IsArray)
					{
						elementType = elementType.ElementTypeWrapper;
					}
					return thisWrapper.ArrayRank == objWrapper.ArrayRank && elementType == CoreClasses.java.lang.Object.Wrapper;
				}
a2878 1
#endif
@


1.245
log
@Fixed regression. Made TypeWrapper.IsGhostArray safe to call on Unloadable types.
@
text
@a4226 1
					string annotationAttributeType = null;
a4230 1
						annotationAttributeType = annotationBuilder.AttributeTypeName;
a4281 5
					if(annotationAttributeType != null)
					{
						CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(AnnotationAttributeAttribute)).GetConstructor(new Type[] { typeof(string) }), new object[] { annotationAttributeType });
						typeBuilder.SetCustomAttribute(cab);
					}
d4984 18
d5005 5
d5092 1
d5099 12
d5274 1
d5303 1
d5501 1
d5511 1
d5521 1
d5531 1
d5541 1
d5551 1
d5561 1
@


1.244
log
@Fixed bug introduced by CallerID support.
@
text
@d2219 1
a2219 1
				return IsArray && (ElementTypeWrapper.IsGhost || ElementTypeWrapper.IsGhostArray);
@


1.243
log
@- Renamed CountingILGenerator to CodeEmitter.
- Renamed CountingLabel to CodeEmitterLabel.
@
text
@d9424 7
a9430 2
			object[][] attribs = new object[parameters.Length - skip][];
			for(int i = skip; i < parameters.Length; i++)
@


1.242
log
@Marked all static classes as static.
@
text
@a29 2
using ILGenerator = IKVM.Internal.CountingILGenerator;
using Label = IKVM.Internal.CountingLabel;
d57 1
a57 1
		internal static void Throw(ILGenerator ilgen, string dottedClassName)
d66 1
a66 1
		internal static void Throw(ILGenerator ilgen, string dottedClassName, string message)
d76 1
a76 1
		internal static void NullCheck(ILGenerator ilgen)
d84 1
a84 1
		internal static void Castclass(ILGenerator ilgen, Type type)
d93 1
a93 1
				Label ok = ilgen.DefineLabel();
d110 1
a110 1
		internal static void EmitAssertType(ILGenerator ilgen, Type type)
d117 1
a117 1
			Label ok = ilgen.DefineLabel();
d2959 1
a2959 1
						EmitHelper.Throw(mb.GetILGenerator(), "java.lang.LinkageError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
d2976 1
a2976 1
					EmitHelper.Throw(mb.GetILGenerator(), "java.lang.IllegalAccessError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
d2984 1
a2984 1
					ILGenerator ilGenerator = mb.GetILGenerator();
d3003 1
a3003 1
					ILGenerator ilGenerator = mb.GetILGenerator();
d3022 1
a3022 1
					EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
d3079 1
a3079 1
		internal void EmitUnbox(CountingILGenerator ilgen)
d3086 1
a3086 1
		internal void EmitBox(CountingILGenerator ilgen)
d3093 1
a3093 1
		internal void EmitConvSignatureTypeToStackType(ILGenerator ilgen)
d3117 1
a3117 1
		internal void EmitConvStackTypeToSignatureType(ILGenerator ilgen, TypeWrapper sourceType)
d3150 1
a3150 1
		internal virtual void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
d3184 1
a3184 1
		internal virtual void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
d3228 1
a3228 1
		internal virtual void EmitRunClassConstructor(ILGenerator ilgen)
d3401 1
a3401 1
		internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
d3408 1
a3408 1
		internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
d3857 1
a3857 1
			internal abstract void EmitRunClassConstructor(ILGenerator ilgen);
d4805 1
a4805 1
						ILGenerator ilgen = getter.GetILGenerator();
d4824 1
a4824 1
							ilgen = setter.GetILGenerator();
d4879 1
a4879 1
			internal override void EmitRunClassConstructor(ILGenerator ilgen)
d5253 1
a5253 1
				private static void EmitSetValueCall(TypeWrapper annotationAttributeBaseType, ILGenerator ilgen, string name, TypeWrapper tw, int argIndex)
d5305 1
a5305 1
					ILGenerator ilgen;
d5324 1
a5324 1
							ilgen = reqArgConstructor.GetILGenerator();
d5351 1
a5351 1
								ilgen = cb.GetILGenerator();
d5360 1
a5360 1
					ilgen = defaultConstructor.GetILGenerator();
d5368 1
a5368 1
					ilgen = defineConstructor.GetILGenerator();
d5392 1
a5392 1
							ilgen = mb.GetILGenerator();
d5453 1
a5453 1
									ilgen = setter.GetILGenerator();
d5460 1
a5460 1
									getter.GetILGenerator().ThrowException(typeof(NotImplementedException));
d5869 1
a5869 1
								ILGenerator ilgen = mb.GetILGenerator();
d5880 1
a5880 1
								EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + methods[index].Name + methods[index].Signature);
d6223 1
a6223 1
								ILGenerator ilgen = finalizeMethod.GetILGenerator();
d6225 1
a6225 1
								Label skip = ilgen.DefineLabel();
d6317 1
a6317 1
				ILGenerator ilgen = overrideStub.GetILGenerator();
d6688 1
a6688 1
			internal override void EmitRunClassConstructor(CountingILGenerator ilgen)
d6898 1
a6898 1
									EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
d6926 1
a6926 1
						ILGenerator ilGenerator = ((ConstructorBuilder)mb).GetILGenerator();
d6948 1
a6948 1
								ILGenerator ilGenerator = ((MethodBuilder)mb).GetILGenerator();
d6962 1
a6962 1
								ILGenerator ilGenerator = ((MethodBuilder)mb).GetILGenerator();
d7055 1
a7055 1
							ILGenerator ilGenerator = mbld.GetILGenerator();
d7098 1
a7098 1
					ILGenerator ilGenerator = cb.GetILGenerator();
d7100 1
a7100 1
					Label label1 = null;
d7104 1
a7104 1
						Label label2 = ilGenerator.DefineLabel();
d7141 1
a7141 1
						ILGenerator ilgen = cb.GetILGenerator();
d7210 1
a7210 1
					ILGenerator ilgenClinit = null;
d7226 1
a7226 1
								ilgenClinit = tbFields.DefineTypeInitializer().GetILGenerator();
d7425 1
a7425 1
				internal static void Generate(DynamicTypeWrapper.FinishContext context, ILGenerator ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args)
d7444 1
a7444 1
					JniBuilder.Generate(context, mb.GetILGenerator(), wrapper, mw, tb, classFile, m, args, true);
d7479 1
a7479 1
				internal static void Generate(DynamicTypeWrapper.FinishContext context, ILGenerator ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args, bool thruProxy)
d7494 1
a7494 1
						Label label = ilGenerator.DefineLabel();
d7514 1
a7514 1
					Label oklabel = ilGenerator.DefineLabel();
d7570 1
a7570 1
						Label label = ilGenerator.DefineLabel();
d7680 1
a7680 1
				internal static void EmitMethodTrace(ILGenerator ilgen, string tracemessage)
d7684 1
a7684 1
						Label label = ilgen.DefineLabel();
d7736 1
a7736 1
				ILGenerator ilgen = mb.GetILGenerator();
d7846 1
a7846 1
										ILGenerator ilgen = mb.GetILGenerator();
d7860 1
a7860 1
									ILGenerator ilgen = mb.GetILGenerator();
d7872 1
a7872 1
								ILGenerator ilgen = mb.GetILGenerator();
d7931 1
a7931 1
				EmitHelper.Throw(m.GetILGenerator(), "java.lang.AbstractMethodError", "Method " + mb.DeclaringType.FullName + "." + mb.Name + " is unsupported by IKVM.");
d7935 1
a7935 1
			private void CompileConstructorBody(FinishContext context, ILGenerator ilGenerator, int methodIndex, Hashtable invokespecialstubcache)
d7980 1
a7980 1
			private void EmitCallerIDInitialization(ILGenerator ilGenerator)
d8000 1
a8000 1
						ILGenerator ctorIlgen = cb.GetILGenerator();
d8012 1
a8012 1
			private void EmitConstantValueInitialization(FieldWrapper[] fields, ILGenerator ilGenerator)
d8234 1
a8234 1
		protected abstract bool EmitMapXmlMethodBody(ILGenerator ilgen, ClassFile f, ClassFile.Method m);
d8269 1
a8269 1
		internal override void EmitRunClassConstructor(CountingILGenerator ilgen)
d9148 1
a9148 1
			protected override void CallImpl(ILGenerator ilgen)
d9162 1
a9162 1
			protected override void CallvirtImpl(ILGenerator ilgen)
d9176 1
a9176 1
			protected override void NewobjImpl(ILGenerator ilgen)
d9313 1
a9313 1
		internal override void EmitRunClassConstructor(ILGenerator ilgen)
d9991 1
a9991 1
				protected override void EmitGetImpl(ILGenerator ilgen)
d10002 1
a10002 1
				protected override void EmitSetImpl(ILGenerator ilgen)
d11097 1
a11097 1
			internal override void EmitNewobj(ILGenerator ilgen, MethodAnalyzer ma, int opcodeIndex)
d11153 1
a11153 1
			protected override void CallImpl(ILGenerator ilgen)
d11167 1
a11167 1
			protected override void CallvirtImpl(ILGenerator ilgen)
d11172 1
a11172 1
			protected override void NewobjImpl(ILGenerator ilgen)
d11177 1
a11177 1
			protected override void PreEmit(ILGenerator ilgen)
d11246 1
a11246 1
			internal override void EmitCall(ILGenerator ilgen)
d11274 1
a11274 1
			protected override void EmitGetImpl(ILGenerator ilgen)
d11281 1
a11281 1
			protected override void EmitSetImpl(ILGenerator ilgen)
d11353 1
a11353 1
			internal override void EmitNewobj(ILGenerator ilgen, MethodAnalyzer ma, int opcodeIndex)
d11381 1
a11381 1
			internal override void EmitCall(ILGenerator ilgen)
d11386 1
a11386 1
			internal override void EmitCallvirt(ILGenerator ilgen)
d11406 1
a11406 1
			internal override void EmitCall(ILGenerator ilgen)
d11410 1
a11410 1
				Label label1 = ilgen.DefineLabel();
d11412 1
a11412 1
				Label label2 = ilgen.DefineLabel();
d11421 1
a11421 1
			internal override void EmitCallvirt(ILGenerator ilgen)
d11678 1
a11678 1
			internal override void EmitCall(ILGenerator ilgen)
d11685 1
a11685 1
			internal override void EmitCallvirt(ILGenerator ilgen)
d12043 1
a12043 1
		internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
d12058 1
a12058 1
		internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
@


1.241
log
@Refactored finish state/methods from JavaTypeImpl into FinishContext.
@
text
@d54 1
a54 1
	class EmitHelper
a58 2
		static EmitHelper() {}

d129 1
a129 1
	class AttributeHelper
d3550 1
a3550 1
	class BakedTypeCleanupHack
d7411 1
a7411 1
			internal class JniProxyBuilder
d7463 1
a7463 1
			private class JniBuilder
d7675 1
a7675 1
			class TraceHelper
@


1.240
log
@- Renamed ClassFile.HasCallerID to distinguish it from MethodWrapper.HasCallerID.
- Added check to only recognize HasCallerID annotation in core library.
- Changed other locations that incorrectly used ClassFile.HasCallerID to use MethodWrapper.CallerID.
@
text
@a3826 18
		internal FieldInfo ClassObjectField
		{
			get
			{
				return ((JavaTypeImpl)impl).ClassObjectField;
			}
		}

		// NOTE can only be used if the type hasn't been finished yet!
		internal FieldInfo CallerIDField
		{
			get
			{
				return ((JavaTypeImpl)impl).CallerIDField;
			}
		}

		// NOTE can only be used if the type hasn't been finished yet!
a3884 3
			private FieldInfo classObjectField;
			private TypeBuilder typeCallerID;
			private FieldInfo callerIDField;
a3886 1
			private List<System.Threading.ThreadStart> postFinishProcs;
a4573 117
			private static bool IsCompatibleArgList(TypeWrapper[] caller, TypeWrapper[] callee)
			{
				if(caller.Length == callee.Length)
				{
					for(int i = 0; i < caller.Length; i++)
					{
						if(!caller[i].IsAssignableTo(callee[i]))
						{
							return false;
						}
					}
					return true;
				}
				return false;
			}

			private void EmitCallerIDInitialization(ILGenerator ilGenerator)
			{
				if (callerIDField != null)
				{
					TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
					// we need to prohibit this optimization at runtime, because proxy classes may be injected into the boot class loader,
					// but they don't actually have access to core library internals
#if STATIC_COMPILER
					if (tw.GetClassLoader() == wrapper.GetClassLoader())
					{
						MethodWrapper create = tw.GetMethodWrapper("create", "(Lcli.System.RuntimeTypeHandle;)Likvm.internal.CallerID;", false);
						ilGenerator.Emit(OpCodes.Ldtoken, this.typeBuilder);
						create.Link();
						create.EmitCall(ilGenerator);
					}
					else
#endif
					{
						typeCallerID = typeBuilder.DefineNestedType("__<CallerID>", TypeAttributes.Sealed | TypeAttributes.NestedPrivate, tw.TypeAsBaseType);
						ConstructorBuilder cb = typeCallerID.DefineConstructor(MethodAttributes.Assembly, CallingConventions.Standard, null);
						ILGenerator ctorIlgen = cb.GetILGenerator();
						ctorIlgen.Emit(OpCodes.Ldarg_0);
						MethodWrapper mw = tw.GetMethodWrapper("<init>", "()V", false);
						mw.Link();
						mw.EmitCall(ctorIlgen);
						ctorIlgen.Emit(OpCodes.Ret);
						ilGenerator.Emit(OpCodes.Newobj, cb);
					}
					ilGenerator.Emit(OpCodes.Stsfld, callerIDField);
				}
			}

			private void EmitConstantValueInitialization(ILGenerator ilGenerator)
			{
				ClassFile.Field[] fields = classFile.Fields;
				for(int i = 0; i < fields.Length; i++)
				{
					ClassFile.Field f = fields[i];
					if(f.IsStatic && !f.IsFinal)
					{
						object constant = f.ConstantValue;
						if(constant != null)
						{
							if(constant is int)
							{
								ilGenerator.Emit(OpCodes.Ldc_I4, (int)constant);
							}
							else if(constant is long)
							{
								ilGenerator.Emit(OpCodes.Ldc_I8, (long)constant);
							}
							else if(constant is double)
							{
								ilGenerator.Emit(OpCodes.Ldc_R8, (double)constant);
							}
							else if(constant is float)
							{
								ilGenerator.Emit(OpCodes.Ldc_R4, (float)constant);
							}
							else if(constant is string)
							{
								ilGenerator.Emit(OpCodes.Ldstr, (string)constant);
							}
							else
							{
								throw new InvalidOperationException();
							}
							this.fields[i].EmitSet(ilGenerator);
						}
					}
				}
			}

			internal FieldInfo ClassObjectField
			{
				get
				{
					lock(this)
					{
						if(classObjectField == null)
						{
							classObjectField = typeBuilder.DefineField("__<classObject>", typeof(object), FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.SpecialName);
						}
						return classObjectField;
					}
				}
			}

			internal FieldInfo CallerIDField
			{
				get
				{
					if(callerIDField == null)
					{
						TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
						callerIDField = typeBuilder.DefineField("__<callerID>", tw.TypeAsSignatureType, FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.InitOnly | FieldAttributes.SpecialName);
					}
					return callerIDField;
				}
			}

d4976 1
a4976 1
					if(innerclasses != null)
d4980 1
a4980 1
						for(int i = 0; i < innerclasses.Length; i++)
d4982 1
a4982 1
							if(innerclasses[i].innerClass != 0 && innerclasses[i].outerClass != 0)
d4984 1
a4984 1
								if(classFile.GetConstantPoolClassType(innerclasses[i].outerClass) == wrapper)
d4988 1
a4988 1
								if(classFile.GetConstantPoolClassType(innerclasses[i].innerClass) == wrapper)
d4996 16
d5013 40
a5052 4
					wrapper.FinishGhost(typeBuilder, methods);
#endif // STATIC_COMPILER
					// if we're not abstract make sure we don't inherit any abstract methods
					if(!wrapper.IsAbstract)
d5054 13
a5066 59
						TypeWrapper parent = wrapper.BaseTypeWrapper;
						// if parent is not abstract, the .NET implementation will never have abstract methods (only
						// stubs that throw AbstractMethodError)
						// NOTE interfaces are supposed to be abstract, but the VM doesn't enforce this, so
						// we have to check for a null parent (interfaces have no parent).
						while(parent != null && parent.IsAbstract)
						{
							foreach(MethodWrapper mw in parent.GetMethods())
							{
								MethodInfo mi = mw.GetMethod() as MethodInfo;
								if(mi != null && mi.IsAbstract && !mi.DeclaringType.IsInterface)
								{
									bool needStub = false;
									bool needRename = false;
									if(mw.IsPublic || mw.IsProtected)
									{
										MethodWrapper fmw = wrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
										while(fmw != mw && (fmw.IsStatic || fmw.IsPrivate))
										{
											needRename = true;
											fmw = fmw.DeclaringType.BaseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
										}
										if(fmw == mw && fmw.DeclaringType != wrapper)
										{
											needStub = true;
										}
									}
									else
									{
										MethodWrapper fmw = wrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
										while(fmw != mw && (fmw.IsStatic || fmw.IsPrivate || !fmw.DeclaringType.IsPackageAccessibleFrom(mw.DeclaringType)))
										{
											needRename = true;
											fmw = fmw.DeclaringType.BaseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
										}
										if(fmw == mw && fmw.DeclaringType != wrapper)
										{
											needStub = true;
										}
									}
									if(needStub)
									{
										// NOTE in Sun's JRE 1.4.1 this method cannot be overridden by subclasses,
										// but I think this is a bug, so we'll support it anyway.
										string name = mi.Name;
										MethodAttributes attr = mi.Attributes & ~(MethodAttributes.Abstract | MethodAttributes.NewSlot);
										if(needRename)
										{
											name = "__<>" + name + "/" + mi.DeclaringType.FullName;
											attr = MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot;
										}
										MethodBuilder mb = typeBuilder.DefineMethod(name, attr, CallingConventions.Standard, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
										if(needRename)
										{
											typeBuilder.DefineMethodOverride(mb, mi);
										}
										AttributeHelper.HideFromJava(mb);
										EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
									}
a5068 1
							parent = parent.BaseTypeWrapper;
d5071 17
a5087 5
					Hashtable invokespecialstubcache = new Hashtable();
					bool basehasclinit = wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasStaticInitializer;
					int clinitIndex = -1;
					bool hasConstructor = false;
					for(int i = 0; i < classFile.Methods.Length; i++)
d5089 1
a5089 3
						ClassFile.Method m = classFile.Methods[i];
						MethodBase mb = methods[i].GetMethod();
						if(mb is ConstructorBuilder)
d5091 1
a5091 1
							if(m.IsClassInitializer)
d5093 1
a5093 4
								// we handle the <clinit> after we've done the other methods,
								// to make it easier to inject code needed by the other methods
								clinitIndex = i;
								continue;
d5095 1
a5095 1
							else
d5097 1
a5097 1
								hasConstructor = true;
d5099 15
a5113 2
							ILGenerator ilGenerator = ((ConstructorBuilder)mb).GetILGenerator();
							CompileConstructorBody(ilGenerator, i, invokespecialstubcache);
d5117 32
a5148 1
							if(m.IsAbstract)
d5150 1
a5150 2
								bool stub = false;
								if(!classFile.IsAbstract)
d5152 1
a5152 31
									// NOTE in the JVM it is apparently legal for a non-abstract class to have abstract methods, but
									// the CLR doens't allow this, so we have to emit a method that throws an AbstractMethodError
									stub = true;
								}
								else if(classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected))
								{
									// We have an abstract package accessible method in our public class. To allow a class in another
									// assembly to subclass this class, we must fake the abstractness of this method.
									stub = true;
								}
								if(stub)
								{
									ILGenerator ilGenerator = ((MethodBuilder)mb).GetILGenerator();
									TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
									EmitHelper.Throw(ilGenerator, "java.lang.AbstractMethodError", classFile.Name + "." + m.Name + m.Signature);
								}
							}
							else if(m.IsNative)
							{
								if((mb.Attributes & MethodAttributes.PinvokeImpl) != 0)
								{
									continue;
								}
								Profiler.Enter("JavaTypeImpl.Finish.Native");
								try
								{
									ILGenerator ilGenerator = ((MethodBuilder)mb).GetILGenerator();
									TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
#if STATIC_COMPILER
									// do we have a native implementation in map.xml?
									if(wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
d5154 4
a5157 14
										continue;
									}
#endif
									// see if there exists a IKVM.NativeCode class for this type
									Type nativeCodeType = null;
#if STATIC_COMPILER
									nativeCodeType = StaticCompiler.GetType("IKVM.NativeCode." + classFile.Name.Replace('$', '+'), false);
#endif
									MethodInfo nativeMethod = null;
									TypeWrapper[] args = methods[i].GetParameters();
									if(nativeCodeType != null)
									{
										TypeWrapper[] nargs = args;
										if(!m.IsStatic)
d5159 2
a5160 10
											nargs = new TypeWrapper[args.Length + 1];
											args.CopyTo(nargs, 1);
											nargs[0] = this.wrapper;
										}
										MethodInfo[] nativeCodeTypeMethods = nativeCodeType.GetMethods(BindingFlags.Static | BindingFlags.Public);
										foreach(MethodInfo method in nativeCodeTypeMethods)
										{
											ParameterInfo[] param = method.GetParameters();
											TypeWrapper[] match = new TypeWrapper[param.Length];
											for(int j = 0; j < param.Length; j++)
d5162 33
a5194 49
												match[j] = ClassLoaderWrapper.GetWrapperFromType(param[j].ParameterType);
											}
											if(m.Name == method.Name && IsCompatibleArgList(nargs, match))
											{
												// TODO instead of taking the first matching method, we should find the best one
												nativeMethod = method;
												break;
											}
										}
									}
									if(nativeMethod != null)
									{
										int add = 0;
										if(!m.IsStatic)
										{
											ilGenerator.Emit(OpCodes.Ldarg_0);
											add = 1;
										}
										for(int j = 0; j < args.Length; j++)
										{
											ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
										}
										ilGenerator.Emit(OpCodes.Call, nativeMethod);
										TypeWrapper retTypeWrapper = methods[i].ReturnType;
										if(!retTypeWrapper.TypeAsTBD.Equals(nativeMethod.ReturnType) && !retTypeWrapper.IsGhost)
										{
											ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
										}
										ilGenerator.Emit(OpCodes.Ret);
									}
									else
									{
										if(wrapper.classLoader.NoJNI)
										{
											// since NoJniStubs can only be set when we're statically compiling, it is safe to use the "compiler" trace switch
											Tracer.Warning(Tracer.Compiler, "Native method not implemented: {0}.{1}.{2}", classFile.Name, m.Name, m.Signature);
											EmitHelper.Throw(ilGenerator, "java.lang.UnsatisfiedLinkError", "Native method not implemented (compiled with -nojni): " + classFile.Name + "." + m.Name + m.Signature);
										}
										else
										{
											if(JVM.IsSaveDebugImage)
											{
#if !STATIC_COMPILER
												JniProxyBuilder.Generate(ilGenerator, wrapper, methods[i], typeBuilder, classFile, m, args);
#endif // !STATIC_COMPILER
											}
											else
											{
												JniBuilder.Generate(ilGenerator, wrapper, methods[i], typeBuilder, classFile, m, args, false);
d5196 2
a5200 35
								finally
								{
									Profiler.Leave("JavaTypeImpl.Finish.Native");
								}
							}
							else
							{
								MethodBuilder mbld = (MethodBuilder)mb;
								ILGenerator ilGenerator = mbld.GetILGenerator();
								TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
#if STATIC_COMPILER
								if(wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
								{
									continue;
								}
#endif // STATIC_COMPILER
								LineNumberTableAttribute.LineNumberWriter lineNumberTable = null;
								bool nonleaf = false;
								Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref nonleaf, invokespecialstubcache, ref lineNumberTable);
								if(nonleaf)
								{
									mbld.SetImplementationFlags(mbld.GetMethodImplementationFlags() | MethodImplAttributes.NoInlining);
								}
								if(lineNumberTable != null)
								{
#if STATIC_COMPILER
									AttributeHelper.SetLineNumberTable(methods[i].GetMethod(), lineNumberTable);
#else // STATIC_COMPILER
									if(wrapper.lineNumberTables == null)
									{
										wrapper.lineNumberTables = new byte[methods.Length][];
									}
									wrapper.lineNumberTables[i] = lineNumberTable.ToArray();
#endif // STATIC_COMPILER
								}
d5205 13
a5217 1
					if(clinitIndex != -1 || (basehasclinit && !classFile.IsInterface) || classFile.HasInitializedFields || callerIDField != null)
d5219 7
a5225 2
						ConstructorBuilder cb;
						if(clinitIndex != -1)
d5227 1
a5227 1
							cb = (ConstructorBuilder)methods[clinitIndex].GetMethod();
d5229 1
a5229 1
						else
d5231 1
a5231 2
							cb = DefineClassInitializer();
							AttributeHelper.HideFromJava(cb);
d5233 1
a5233 16
						ILGenerator ilGenerator = cb.GetILGenerator();
						// HACK we start out by emitting the users code, because that may trigger the creation of caller id infrastructure
						Label label1 = null;
						if(clinitIndex != -1)
						{
							label1 = ilGenerator.DefineLabel();
							Label label2 = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Br, label2);
							ilGenerator.MarkLabel(label1);
							CompileConstructorBody(ilGenerator, clinitIndex, invokespecialstubcache);
							ilGenerator.MarkLabel(label2);
						}
						// before we call the base class initializer, we need to set the non-final static ConstantValue fields
						EmitConstantValueInitialization(ilGenerator);
						EmitCallerIDInitialization(ilGenerator);
						if(basehasclinit)
d5235 1
a5235 1
							wrapper.BaseTypeWrapper.EmitRunClassConstructor(ilGenerator);
d5237 1
a5237 1
						if(clinitIndex != -1)
d5239 1
a5239 1
							ilGenerator.Emit(OpCodes.Br, label1);
d5241 9
a5249 1
						else
d5251 1
a5251 1
							ilGenerator.Emit(OpCodes.Ret);
d5253 1
d5255 1
d5257 17
a5273 2
					// add all interfaces that we implement (including the magic ones) and handle ghost conversions
					ImplementInterfaces(wrapper.Interfaces, new ArrayList());
d5275 3
a5277 2
					// NOTE non-final fields aren't allowed in interfaces so we don't have to initialize constant fields
					if(!classFile.IsInterface)
d5279 5
a5283 12
						// if a class has no constructor, we generate one otherwise Ref.Emit will create a default ctor
						// and that has several problems:
						// - base type may not have an accessible default constructor
						// - Ref.Emit uses BaseType.GetConstructors() which may trigger a TypeResolve event
						// - we don't want the synthesized constructor to show up in Java
						if(!hasConstructor)
						{
							ConstructorBuilder cb = typeBuilder.DefineConstructor(MethodAttributes.PrivateScope, CallingConventions.Standard, Type.EmptyTypes);
							ILGenerator ilgen = cb.GetILGenerator();
							ilgen.Emit(OpCodes.Ldnull);
							ilgen.Emit(OpCodes.Throw);
						}
d5285 6
a5290 8
						// here we loop thru all the interfaces to explicitly implement any methods that we inherit from
						// base types that may have a different name from the name in the interface
						// (e.g. interface that has an equals() method that should override System.Object.Equals())
						// also deals with interface methods that aren't implemented (generate a stub that throws AbstractMethodError)
						// and with methods that aren't public (generate a stub that throws IllegalAccessError)
						Hashtable doneSet = new Hashtable();
						TypeWrapper[] interfaces = wrapper.Interfaces;
						for(int i = 0; i < interfaces.Length; i++)
d5292 5
a5296 8
							interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
						}
						// if any of our base classes has an incomplete interface implementation we need to look through all
						// the base class interfaces to see if we've got an implementation now
						TypeWrapper baseTypeWrapper = wrapper.BaseTypeWrapper;
						while(baseTypeWrapper.HasIncompleteInterfaceImplementation)
						{
							for(int i = 0; i < baseTypeWrapper.Interfaces.Length; i++)
d5298 6
a5303 1
								baseTypeWrapper.Interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
a5304 1
							baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
d5306 8
a5313 1
						if(!wrapper.IsAbstract && wrapper.HasUnsupportedAbstractMethods)
d5315 2
a5316 5
							AddUnsupportedAbstractMethods();
						}
						foreach(MethodWrapper mw in methods)
						{
							if(mw.Name != "<init>" && !mw.IsStatic && mw.IsPublic)
d5318 1
a5318 1
								if(wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasIncompleteInterfaceImplementation)
d5320 1
a5320 3
									Hashtable hashtable = null;
									TypeWrapper tw = wrapper.BaseTypeWrapper;
									while(tw.HasIncompleteInterfaceImplementation)
d5322 1
a5322 5
										foreach(TypeWrapper iface in tw.Interfaces)
										{
											AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Name, mw.Signature, ref hashtable, false);
										}
										tw = tw.BaseTypeWrapper;
d5325 9
a5333 1
								if(true)
d5335 1
a5335 2
									Hashtable hashtable = null;
									foreach(TypeWrapper iface in wrapper.Interfaces)
d5337 2
a5338 1
										AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Name, mw.Signature, ref hashtable, true);
d5342 1
d5344 7
a5350 22
					}

#if STATIC_COMPILER
					// If we're an interface that has public/protected fields, we create an inner class
					// to expose these fields to C# (which stubbornly refuses to see fields in interfaces).
					TypeBuilder tbFields = null;
					if(classFile.IsInterface && classFile.IsPublic && !wrapper.IsGhost && classFile.Fields.Length > 0)
					{
						// TODO handle name clash
						tbFields = typeBuilder.DefineNestedType("__Fields", TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract);
						AttributeHelper.HideFromJava(tbFields);
						ILGenerator ilgenClinit = null;
						foreach(ClassFile.Field f in classFile.Fields)
						{
							TypeWrapper typeWrapper = ClassFile.FieldTypeWrapperFromSig(wrapper.GetClassLoader(), classCache, f.Signature);
							if(f.ConstantValue != null)
							{
								FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal;
								FieldBuilder fb = tbFields.DefineField(f.Name, typeWrapper.TypeAsSignatureType, attribs);
								fb.SetConstant(f.ConstantValue);
							}
							else
d5352 8
a5359 8
								FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.InitOnly;
								FieldBuilder fb = tbFields.DefineField(f.Name, typeWrapper.TypeAsSignatureType, attribs);
								if(ilgenClinit == null)
								{
									ilgenClinit = tbFields.DefineTypeInitializer().GetILGenerator();
								}
								wrapper.GetFieldWrapper(f.Name, f.Signature).EmitGet(ilgenClinit);
								ilgenClinit.Emit(OpCodes.Stsfld, fb);
a5361 4
						if(ilgenClinit != null)
						{
							ilgenClinit.Emit(OpCodes.Ret);
						}
d5364 15
a5378 3
					// See if there is any additional metadata
					wrapper.EmitMapXmlMetadata(typeBuilder, classFile, fields, methods);
#endif // STATIC_COMPILER
d5380 10
a5389 1
					for(int i = 0; i < classFile.Methods.Length; i++)
d5391 2
a5392 10
						ClassFile.Method m = classFile.Methods[i];
						MethodBase mb = methods[i].GetMethod();
						ParameterBuilder returnParameter = null;
						ParameterBuilder[] parameterBuilders = null;
						string[] parameterNames = null;
						if(wrapper.GetClassLoader().EmitDebugInfo
#if STATIC_COMPILER
							|| (classFile.IsPublic && (m.IsPublic || m.IsProtected))
#endif
							)
d5394 6
a5399 12
							parameterNames = new string[methods[i].GetParameters().Length];
							GetParameterNamesFromLVT(m, parameterNames);
							GetParameterNamesFromSig(m.Signature, parameterNames);
#if STATIC_COMPILER
							((AotTypeWrapper)wrapper).GetParameterNamesFromXml(m.Name, m.Signature, parameterNames);
#endif
							parameterBuilders = GetParameterBuilders(mb, parameterNames.Length, parameterNames);
						}
#if STATIC_COMPILER
						if((m.Modifiers & Modifiers.VarArgs) != 0 && !methods[i].HasCallerID)
						{
							if(parameterBuilders == null)
d5401 33
a5433 17
								parameterBuilders = GetParameterBuilders(mb, methods[i].GetParameters().Length, null);
							}
							if(parameterBuilders.Length > 0)
							{
								AttributeHelper.SetParamArrayAttribute(parameterBuilders[parameterBuilders.Length - 1]);
							}
						}
						((AotTypeWrapper)wrapper).AddXmlMapParameterAttributes(mb, classFile.Name, m.Name, m.Signature, ref parameterBuilders);
#endif
						ConstructorBuilder cb = mb as ConstructorBuilder;
						MethodBuilder mBuilder = mb as MethodBuilder;
						if(m.Annotations != null)
						{
							foreach(object[] def in m.Annotations)
							{
								Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
								if(annotation != null)
d5435 1
a5435 9
									if(cb != null)
									{
										annotation.Apply(wrapper.GetClassLoader(), cb, def);
									}
									if(mBuilder != null)
									{
										annotation.Apply(wrapper.GetClassLoader(), mBuilder, def);
										annotation.ApplyReturnValue(wrapper.GetClassLoader(), mBuilder, ref returnParameter, def);
									}
d5438 1
a5438 4
						}
						if(m.ParameterAnnotations != null)
						{
							if(parameterBuilders == null)
d5440 2
a5441 1
								parameterBuilders = GetParameterBuilders(mb, methods[i].GetParameters().Length, null);
d5443 4
a5446 2
							object[][] defs = m.ParameterAnnotations;
							for(int j = 0; j < defs.Length; j++)
d5448 3
a5450 1
								foreach(object[] def in defs[j])
d5452 13
a5464 5
									Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
									if(annotation != null)
									{
										annotation.Apply(wrapper.GetClassLoader(), parameterBuilders[j], def);
									}
a5467 7
#if STATIC_COMPILER
						if(methods[i].HasCallerID)
						{
							AttributeHelper.SetEditorBrowsableNever((MethodBuilder)mb);
							EmitCallerIDStub(methods[i], parameterNames);
						}
#endif // STATIC_COMPILER
d5469 11
d5481 3
a5483 1
					for(int i = 0; i < classFile.Fields.Length; i++)
d5485 2
a5486 27
						if(classFile.Fields[i].Annotations != null)
						{
							foreach(object[] def in classFile.Fields[i].Annotations)
							{
								Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
								if(annotation != null)
								{
									GetterFieldWrapper getter = fields[i] as GetterFieldWrapper;
									if(getter != null)
									{
										annotation.Apply(wrapper.GetClassLoader(), (MethodBuilder)getter.GetGetter(), def);
									}
									else
									{
										DynamicPropertyFieldWrapper prop = fields[i] as DynamicPropertyFieldWrapper;
										if(prop != null)
										{
											annotation.Apply(wrapper.GetClassLoader(), prop.GetPropertyBuilder(), def);
										}
										else
										{
											annotation.Apply(wrapper.GetClassLoader(), (FieldBuilder)fields[i].GetField(), def);
										}
									}
								}
							}
						}
d5488 1
d5490 3
a5492 1
					if(classFile.Annotations != null)
d5494 2
a5495 8
						foreach(object[] def in classFile.Annotations)
						{
							Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
							if(annotation != null)
							{
								annotation.Apply(wrapper.GetClassLoader(), typeBuilder, def);
							}
						}
d5497 1
d5499 3
a5501 3
					Type type;
					Profiler.Enter("TypeBuilder.CreateType");
					try
d5503 2
a5504 30
						type = typeBuilder.CreateType();
						if(typeCallerID != null)
						{
							typeCallerID.CreateType();
						}
						if(postFinishProcs != null)
						{
							foreach(System.Threading.ThreadStart proc in postFinishProcs)
							{
								proc();
							}
						}
#if STATIC_COMPILER
						if(tbFields != null)
						{
							tbFields.CreateType();
						}
						if(enumBuilder != null)
						{
							enumBuilder.CreateType();
						}
						if(annotationBuilder != null)
						{
							annotationBuilder.Finish(this);
						}
						if(classFile.IsInterface && !classFile.IsPublic)
						{
							((DynamicClassLoader)wrapper.classLoader.GetTypeWrapperFactory()).DefineProxyHelper(type);
						}
#endif
d5506 5
a5510 1
					finally
d5512 2
a5513 1
						Profiler.Leave("TypeBuilder.CreateType");
a5514 11
					ClassLoaderWrapper.SetWrapperForType(type, wrapper);
#if STATIC_COMPILER
					wrapper.FinishGhostStep2();
#endif
					BakedTypeCleanupHack.Process(wrapper);
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, this.ReflectiveModifiers, Metadata.Create(classFile)
#if STATIC_COMPILER
						, annotationBuilder, enumBuilder
#endif
						);
					return finishedType;
d5516 2
a5517 1
				catch(Exception x)
d5519 5
a5523 2
					JVM.CriticalFailure("Exception during finishing of: " + wrapper.Name, x);
					return null;
d5525 2
a5526 1
				finally
d5528 5
a5532 1
					Profiler.Leave("JavaTypeImpl.Finish.Core");
d5535 1
d5537 1
a5537 2
#if STATIC_COMPILER
			private void EmitCallerIDStub(MethodWrapper mw, string[] parameterNames)
d5539 1
a5539 3
				Type[] p = mw.GetParametersForDefineMethod();
				Type[] parameterTypes = new Type[p.Length - 1];
				for (int i = 0; i < parameterTypes.Length; i++)
d5541 1
a5541 1
					parameterTypes[i] = p[i];
d5543 5
a5547 3
				MethodAttributes attribs = MethodAttributes.HideBySig;
				int argcount = parameterTypes.Length;
				if (mw.IsStatic)
d5549 1
a5549 1
					attribs |= MethodAttributes.Static;
d5551 5
a5555 1
				else
d5557 2
a5558 25
					argcount++;
				}
				if (mw.IsPublic)
				{
					attribs |= MethodAttributes.Public;
				}
				else if (mw.IsProtected)
				{
					attribs |= MethodAttributes.FamORAssem;
				}
				else if (mw.IsPrivate)
				{
					attribs |= MethodAttributes.Private;
				}
				else
				{
					attribs |= MethodAttributes.Assembly;
				}
				MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, attribs, mw.ReturnTypeForDefineMethod, parameterTypes);
				AttributeHelper.HideFromJava(mb);
				mb.SetImplementationFlags(MethodImplAttributes.NoInlining);
				ILGenerator ilgen = mb.GetILGenerator();
				for (int i = 0; i < argcount; i++)
				{
					if (parameterNames != null && (mw.IsStatic || i > 0))
d5560 1
a5560 2
						ParameterBuilder pb = mb.DefineParameter(mw.IsStatic ? i + 1 : i, ParameterAttributes.None, parameterNames[mw.IsStatic ? i : i - 1]);
						if (i == argcount - 1 && (mw.Modifiers & Modifiers.VarArgs) != 0)
d5562 7
a5568 1
							AttributeHelper.SetParamArrayAttribute(pb);
d5571 1
a5571 15
					ilgen.Emit(OpCodes.Ldarg, (short)i);
				}
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Ldc_I4_0);
				ilgen.Emit(OpCodes.Newobj, typeof(StackFrame).GetConstructor(new Type[] { typeof(int), typeof(bool) }));
				MethodWrapper callerID = CoreClasses.ikvm.@@internal.CallerID.Wrapper.GetMethodWrapper("create", "(Lcli.System.Diagnostics.StackFrame;)Likvm.internal.CallerID;", false);
				callerID.Link();
				callerID.EmitCall(ilgen);
				if (mw.IsStatic)
				{
					mw.EmitCall(ilgen);
				}
				else
				{
					mw.EmitCallvirt(ilgen);
a5572 1
				ilgen.Emit(OpCodes.Ret);
a5573 1
#endif // STATIC_COMPILER
d5575 1
a5575 1
			internal void RegisterPostFinishProc(System.Threading.ThreadStart proc)
d5579 1
a5579 1
					if(postFinishProcs == null)
d5581 11
a5591 1
						postFinishProcs = new List<System.Threading.ThreadStart>();
a5592 1
					postFinishProcs.Add(proc);
d5596 1
a5596 1
			private void CompileConstructorBody(ILGenerator ilGenerator, int methodIndex, Hashtable invokespecialstubcache)
d5598 3
a5600 5
				ClassFile.Method m = classFile.Methods[methodIndex];
				TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
#if STATIC_COMPILER
				// do we have a native implementation in map.xml?
				if(wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
d5602 4
a5605 1
					return;
d5607 6
a5612 5
#endif
				LineNumberTableAttribute.LineNumberWriter lineNumberTable = null;
				bool nonLeaf = false;
				Compiler.Compile(wrapper, methods[methodIndex], classFile, m, ilGenerator, ref nonLeaf, invokespecialstubcache, ref lineNumberTable);
				if(lineNumberTable != null)
d5614 6
a5619 9
#if STATIC_COMPILER
					AttributeHelper.SetLineNumberTable(methods[methodIndex].GetMethod(), lineNumberTable);
#else // STATIC_COMPILER
					if(wrapper.lineNumberTables == null)
					{
						wrapper.lineNumberTables = new byte[methods.Length][];
					}
					wrapper.lineNumberTables[methodIndex] = lineNumberTable.ToArray();
#endif // STATIC_COMPILER
d5621 2
d5625 2
a5626 1
			private void ImplementInterfaces(TypeWrapper[] interfaces, ArrayList interfaceList)
d5628 6
a5633 1
				foreach (TypeWrapper iface in interfaces)
d5635 21
a5655 1
					if (!interfaceList.Contains(iface))
d5657 3
a5659 4
						interfaceList.Add(iface);
						// NOTE we're using TypeAsBaseType for the interfaces!
						Type ifaceType = iface.TypeAsBaseType;
						if(!iface.IsPublic && !ifaceType.Assembly.Equals(typeBuilder.Assembly))
d5661 2
a5662 1
							ifaceType = ifaceType.Assembly.GetType(DynamicClassLoader.GetProxyHelperName(ifaceType));
d5664 8
a5671 3
						typeBuilder.AddInterfaceImplementation(ifaceType);
#if STATIC_COMPILER
						if (!wrapper.IsInterface)
d5673 1
a5673 49
							// look for "magic" interfaces that imply a .NET interface
							if (iface.GetClassLoader() == CoreClasses.java.lang.Object.Wrapper.GetClassLoader())
							{
								if (iface.Name == "java.lang.Iterable"
									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(typeof(IEnumerable))))
								{
									TypeWrapper enumeratorType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast("ikvm.lang.IterableEnumerator");
									if (enumeratorType != null)
									{
										typeBuilder.AddInterfaceImplementation(typeof(IEnumerable));
										// FXBUG we're using the same method name as the C# compiler here because both the .NET and Mono implementations of Xml serialization depend on this method name
										MethodBuilder mb = typeBuilder.DefineMethod("System.Collections.IEnumerable.GetEnumerator", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, typeof(IEnumerator), Type.EmptyTypes);
										AttributeHelper.HideFromJava(mb);
										typeBuilder.DefineMethodOverride(mb, typeof(IEnumerable).GetMethod("GetEnumerator"));
										ILGenerator ilgen = mb.GetILGenerator();
										ilgen.Emit(OpCodes.Ldarg_0);
										MethodWrapper mw = enumeratorType.GetMethodWrapper("<init>", "(Ljava.lang.Iterable;)V", false);
										mw.Link();
										mw.EmitNewobj(ilgen);
										ilgen.Emit(OpCodes.Ret);
									}
								}
								else if (iface.Name == "java.io.Closeable"
									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(typeof(IDisposable))))
								{
									typeBuilder.AddInterfaceImplementation(typeof(IDisposable));
									MethodBuilder mb = typeBuilder.DefineMethod("__<>Dispose", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, typeof(void), Type.EmptyTypes);
									typeBuilder.DefineMethodOverride(mb, typeof(IDisposable).GetMethod("Dispose"));
									ILGenerator ilgen = mb.GetILGenerator();
									ilgen.Emit(OpCodes.Ldarg_0);
									MethodWrapper mw = iface.GetMethodWrapper("close", "()V", false);
									mw.Link();
									mw.EmitCallvirt(ilgen);
									ilgen.Emit(OpCodes.Ret);
								}
							}
							// if we implement a ghost interface, add an implicit conversion to the ghost reference value type
							if(iface.IsGhost && wrapper.IsPublic)
							{
								MethodBuilder mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, iface.TypeAsSignatureType, new Type[] { wrapper.TypeAsSignatureType });
								ILGenerator ilgen = mb.GetILGenerator();
								LocalBuilder local = ilgen.DeclareLocal(iface.TypeAsSignatureType);
								ilgen.Emit(OpCodes.Ldloca, local);
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Stfld, iface.GhostRefField);
								ilgen.Emit(OpCodes.Ldloca, local);
								ilgen.Emit(OpCodes.Ldobj, iface.TypeAsSignatureType);
								ilgen.Emit(OpCodes.Ret);
							}
d5675 5
a5679 4
#endif // STATIC_COMPILER
						// NOTE we're recursively "implementing" all interfaces that we inherit from the interfaces we implement.
						// The C# compiler also does this and the Compact Framework requires it.
						ImplementInterfaces(iface.Interfaces, interfaceList);
d5681 1
d5683 6
d5691 1
a5691 1
			private void AddUnsupportedAbstractMethods()
d5693 4
a5696 1
				foreach(MethodBase mb in wrapper.BaseTypeWrapper.TypeAsBaseType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
d5698 1
a5698 1
					if(DotNetTypeWrapper.IsUnsupportedAbstractMethod(mb))
d5700 2
a5701 1
						GenerateUnsupportedAbstractMethodStub(mb);
d5703 1
d5705 1
a5705 20
				Hashtable h = new Hashtable();
				TypeWrapper tw = wrapper;
				while(tw != null)
				{
					foreach(TypeWrapper iface in tw.Interfaces)
					{
						foreach(MethodBase mb in iface.TypeAsBaseType.GetMethods(BindingFlags.Public | BindingFlags.Instance))
						{
							if(!h.ContainsKey(mb))
							{
								h.Add(mb, mb);
								if(DotNetTypeWrapper.IsUnsupportedAbstractMethod(mb))
								{
									GenerateUnsupportedAbstractMethodStub(mb);
								}
							}
						}
					}
					tw = tw.BaseTypeWrapper;
				}
d5708 1
a5708 1
			private void GenerateUnsupportedAbstractMethodStub(MethodBase mb)
d5710 2
a5711 3
				ParameterInfo[] parameters = mb.GetParameters();
				Type[] parameterTypes = new Type[parameters.Length];
				for(int i = 0; i < parameters.Length; i++)
d5713 29
a5741 1
					parameterTypes[i] = parameters[i].ParameterType;
d5743 1
a5743 14
				MethodAttributes attr = MethodAttributes.NewSlot | MethodAttributes.Virtual | MethodAttributes.Private;
				MethodBuilder m = typeBuilder.DefineMethod("__<unsupported>" + mb.DeclaringType.FullName + "/" + mb.Name, attr, ((MethodInfo)mb).ReturnType, parameterTypes);
				EmitHelper.Throw(m.GetILGenerator(), "java.lang.AbstractMethodError", "Method " + mb.DeclaringType.FullName + "." + mb.Name + " is unsupported by IKVM.");
				typeBuilder.DefineMethodOverride(m, (MethodInfo)mb);
			}

			class TraceHelper
			{
#if STATIC_COMPILER
				private readonly static MethodInfo methodIsTracedMethod = typeof(Tracer).GetMethod("IsTracedMethod");
#endif
				private readonly static MethodInfo methodMethodInfo = typeof(Tracer).GetMethod("MethodInfo");

				internal static void EmitMethodTrace(ILGenerator ilgen, string tracemessage)
d5745 1
a5745 1
					if(Tracer.IsTracedMethod(tracemessage))
d5747 10
a5756 10
						Label label = ilgen.DefineLabel();
#if STATIC_COMPILER
						// TODO this should be a boolean field test instead of a call to Tracer.IsTracedMessage
						ilgen.Emit(OpCodes.Ldstr, tracemessage);
						ilgen.Emit(OpCodes.Call, methodIsTracedMethod);
						ilgen.Emit(OpCodes.Brfalse_S, label);
#endif
						ilgen.Emit(OpCodes.Ldstr, tracemessage);
						ilgen.Emit(OpCodes.Call, methodMethodInfo);
						ilgen.MarkLabel(label);
d5758 1
d5760 1
d5763 1
a5763 2
#if STATIC_COMPILER
			private bool IsValidAnnotationElementType(string type)
d5765 2
a5766 1
				if(type[0] == '[')
d5768 1
a5768 1
					type = type.Substring(1);
d5770 2
a5771 1
				switch(type)
d5773 4
a5776 15
					case "Z":
					case "B":
					case "S":
					case "C":
					case "I":
					case "J":
					case "F":
					case "D":
					case "Ljava.lang.String;":
					case "Ljava.lang.Class;":
						return true;
				}
				if(type.StartsWith("L") && type.EndsWith(";"))
				{
					try
d5778 18
a5795 2
						TypeWrapper tw = wrapper.GetClassLoader().LoadClassByDottedNameFast(type.Substring(1, type.Length - 2));
						if(tw != null)
d5797 1
a5797 12
							if((tw.Modifiers & Modifiers.Annotation) != 0)
							{
								return true;
							}
							if((tw.Modifiers & Modifiers.Enum) != 0)
							{
								TypeWrapper enumType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast("java.lang.Enum");
								if(enumType != null && tw.IsSubTypeOf(enumType))
								{
									return true;
								}
							}
a5799 3
					catch
					{
					}
d5801 13
a5813 1
				return false;
d5816 1
a5816 1
			sealed class AnnotationBuilder : Annotation
d5818 3
a5820 5
				private TypeBuilder annotationTypeBuilder;
				private TypeBuilder attributeTypeBuilder;
				private ConstructorBuilder defineConstructor;

				internal AnnotationBuilder(JavaTypeImpl o)
d5822 1
a5822 2
					// Make sure the annotation type only has valid methods
					for(int i = 0; i < o.methods.Length; i++)
d5824 1
a5824 1
						if(!o.methods[i].IsStatic)
d5826 7
a5832 1
							if(!o.methods[i].Signature.StartsWith("()"))
d5834 3
a5836 1
								return;
d5838 3
a5840 1
							if(!o.IsValidAnnotationElementType(o.methods[i].Signature.Substring(2)))
d5842 1
a5842 1
								return;
d5844 1
d5846 1
a5846 12
					}

					// we only set annotationTypeBuilder if we're valid
					annotationTypeBuilder = o.typeBuilder;

					TypeWrapper annotationAttributeBaseType = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.AnnotationAttributeBase");

					// TODO attribute should be .NET serializable
					TypeAttributes typeAttributes = TypeAttributes.Class | TypeAttributes.Sealed;
					if(o.outerClassWrapper != null)
					{
						if(o.wrapper.IsPublic)
d5848 39
a5886 1
							typeAttributes |= TypeAttributes.NestedPublic;
d5890 1
a5890 1
							typeAttributes |= TypeAttributes.NestedAssembly;
a5891 1
						attributeTypeBuilder = o.outerClassWrapper.TypeAsBuilder.DefineNestedType(GetInnerClassName(o.outerClassWrapper.Name, o.classFile.Name) + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
d5893 4
a5896 1
					else
d5898 1
a5898 9
						if(o.wrapper.IsPublic)
						{
							typeAttributes |= TypeAttributes.Public;
						}
						else
						{
							typeAttributes |= TypeAttributes.NotPublic;
						}
						attributeTypeBuilder = o.wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(o.classFile.Name + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
d5900 2
a5901 1
					if(o.wrapper.IsPublic)
d5903 3
a5905 2
						// In the Java world, the class appears as a non-public proxy class
						AttributeHelper.SetModifiers(attributeTypeBuilder, Modifiers.Final, false);
d5907 2
a5908 7
					// NOTE we "abuse" the InnerClassAttribute to add a custom attribute to name the class "$Proxy[Annotation]" in the Java world
					int dotindex = o.classFile.Name.LastIndexOf('.') + 1;
					AttributeHelper.SetInnerClass(attributeTypeBuilder, o.classFile.Name.Substring(0, dotindex) + "$Proxy" + o.classFile.Name.Substring(dotindex), Modifiers.Final);
					attributeTypeBuilder.AddInterfaceImplementation(o.typeBuilder);
					AttributeHelper.SetImplementsAttribute(attributeTypeBuilder, new TypeWrapper[] { o.wrapper });

					if(o.classFile.Annotations != null)
d5910 7
a5916 1
						foreach(object[] def in o.classFile.Annotations)
d5918 1
a5918 54
							if(def[1].Equals("Ljava/lang/annotation/Target;"))
							{
								for(int i = 2; i < def.Length; i += 2)
								{
									if(def[i].Equals("value"))
									{
										object[] val = def[i + 1] as object[];
										if(val != null
											&& val.Length > 0
											&& val[0].Equals(AnnotationDefaultAttribute.TAG_ARRAY))
										{
											AttributeTargets targets = 0;
											for(int j = 1; j < val.Length; j++)
											{
												object[] eval = val[j] as object[];
												if(eval != null
													&& eval.Length == 3
													&& eval[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)
													&& eval[1].Equals("Ljava/lang/annotation/ElementType;"))
												{
													switch((string)eval[2])
													{
														case "ANNOTATION_TYPE":
															targets |= AttributeTargets.Interface;
															break;
														case "CONSTRUCTOR":
															targets |= AttributeTargets.Constructor;
															break;
														case "FIELD":
															targets |= AttributeTargets.Field;
															break;
														case "LOCAL_VARIABLE":
															break;
														case "METHOD":
															targets |= AttributeTargets.Method;
															break;
														case "PACKAGE":
															targets |= AttributeTargets.Interface;
															break;
														case "PARAMETER":
															targets |= AttributeTargets.Parameter;
															break;
														case "TYPE":
															targets |= AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Delegate | AttributeTargets.Enum;
															break;
													}
												}
											}
											CustomAttributeBuilder cab2 = new CustomAttributeBuilder(typeof(AttributeUsageAttribute).GetConstructor(new Type[] { typeof(AttributeTargets) }), new object[] { targets });
											attributeTypeBuilder.SetCustomAttribute(cab2);
										}
									}
								}
							}
d5921 1
a5921 9

					defineConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { typeof(object[]) });
					AttributeHelper.SetEditorBrowsableNever(defineConstructor);
				}

				private static Type TypeWrapperToAnnotationParameterType(TypeWrapper tw)
				{
					bool isArray = false;
					if(tw.IsArray)
d5923 3
a5925 7
						isArray = true;
						tw = tw.ElementTypeWrapper;
					}
					if(tw.Annotation != null)
					{
						// we don't support Annotation args
						return null;
d5929 1
a5929 2
						Type argType;
						if(tw == CoreClasses.java.lang.Class.Wrapper)
d5931 1
a5931 1
							argType = typeof(Type);
d5933 1
a5933 1
						else if(tw.EnumType != null)
d5935 1
a5935 1
							argType = tw.EnumType;
d5937 1
a5937 1
						else
d5939 1
a5939 1
							argType = tw.TypeAsSignatureType;
d5941 1
a5941 1
						if(isArray)
d5943 1
a5943 1
							argType = ArrayTypeWrapper.MakeArrayType(argType, 1);
a5944 1
						return argType;
d5946 1
a5946 5
				}

				internal string AttributeTypeName
				{
					get
d5948 33
a5980 1
						if(attributeTypeBuilder != null)
d5982 1
a5982 1
							return attributeTypeBuilder.FullName;
d5984 2
a5985 1
						return null;
d5987 1
a5987 8
				}

				private static void EmitSetValueCall(TypeWrapper annotationAttributeBaseType, ILGenerator ilgen, string name, TypeWrapper tw, int argIndex)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldstr, name);
					ilgen.Emit(OpCodes.Ldarg_S, (byte)argIndex);
					if(tw.TypeAsSignatureType.IsValueType)
d5989 1
a5989 1
						ilgen.Emit(OpCodes.Box, tw.TypeAsSignatureType);
d5991 1
a5991 1
					else if(tw.EnumType != null)
d5993 1
a5993 23
						ilgen.Emit(OpCodes.Box, tw.EnumType);
					}
					MethodWrapper setValueMethod = annotationAttributeBaseType.GetMethodWrapper("setValue", "(Ljava.lang.String;Ljava.lang.Object;)V", false);
					setValueMethod.Link();
					setValueMethod.EmitCall(ilgen);
				}

				internal void Finish(JavaTypeImpl o)
				{
					if(annotationTypeBuilder == null)
					{
						// not a valid annotation type
						return;
					}
					TypeWrapper annotationAttributeBaseType = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.AnnotationAttributeBase");
					annotationAttributeBaseType.Finish();

					int requiredArgCount = 0;
					int valueArg = -1;
					bool unsupported = false;
					for(int i = 0; i < o.methods.Length; i++)
					{
						if(!o.methods[i].IsStatic)
d5995 4
a5998 1
							if(valueArg == -1 && o.methods[i].Name == "value")
d6000 8
a6007 1
								valueArg = i;
d6009 1
a6009 1
							if(o.classFile.Methods[i].AnnotationDefault == null)
d6011 1
a6011 6
								if(TypeWrapperToAnnotationParameterType(o.methods[i].ReturnType) == null)
								{
									unsupported = true;
									break;
								}
								requiredArgCount++;
d6014 1
a6014 8
					}

					ConstructorBuilder defaultConstructor = attributeTypeBuilder.DefineConstructor(unsupported || requiredArgCount > 0 ? MethodAttributes.Private : MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
					ILGenerator ilgen;

					if(!unsupported)
					{
						if(requiredArgCount > 0)
d6016 1
a6016 2
							Type[] args = new Type[requiredArgCount];
							for(int i = 0, j = 0; i < o.methods.Length; i++)
d6018 1
a6018 7
								if(!o.methods[i].IsStatic)
								{
									if(o.classFile.Methods[i].AnnotationDefault == null)
									{
										args[j++] = TypeWrapperToAnnotationParameterType(o.methods[i].ReturnType);
									}
								}
d6020 1
a6020 6
							ConstructorBuilder reqArgConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, args);
							AttributeHelper.HideFromJava(reqArgConstructor);
							ilgen = reqArgConstructor.GetILGenerator();
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Call, defaultConstructor);
							for(int i = 0, j = 0; i < o.methods.Length; i++)
d6022 1
a6022 8
								if(!o.methods[i].IsStatic)
								{
									if(o.classFile.Methods[i].AnnotationDefault == null)
									{
										reqArgConstructor.DefineParameter(++j, ParameterAttributes.None, o.methods[i].Name);
										EmitSetValueCall(annotationAttributeBaseType, ilgen, o.methods[i].Name, o.methods[i].ReturnType, j);
									}
								}
a6023 1
							ilgen.Emit(OpCodes.Ret);
d6025 1
a6025 1
						else if(valueArg != -1)
d6027 2
a6028 5
							// We don't have any required parameters, but we do have an optional "value" parameter,
							// so we create an additional constructor (the default constructor will be public in this case)
							// that accepts the value parameter.
							Type argType = TypeWrapperToAnnotationParameterType(o.methods[valueArg].ReturnType);
							if(argType != null)
d6030 1
a6030 8
								ConstructorBuilder cb = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { argType });
								AttributeHelper.HideFromJava(cb);
								cb.DefineParameter(1, ParameterAttributes.None, "value");
								ilgen = cb.GetILGenerator();
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Call, defaultConstructor);
								EmitSetValueCall(annotationAttributeBaseType, ilgen, "value", o.methods[valueArg].ReturnType, 1);
								ilgen.Emit(OpCodes.Ret);
d6033 7
a6039 31
					}

					ilgen = defaultConstructor.GetILGenerator();
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldtoken, annotationTypeBuilder);
					ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.GetClassFromTypeHandle);
					CoreClasses.java.lang.Class.Wrapper.EmitCheckcast(null, ilgen);
					annotationAttributeBaseType.GetMethodWrapper("<init>", "(Ljava.lang.Class;)V", false).EmitCall(ilgen);
					ilgen.Emit(OpCodes.Ret);

					ilgen = defineConstructor.GetILGenerator();
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Call, defaultConstructor);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldarg_1);
					annotationAttributeBaseType.GetMethodWrapper("setDefinition", "([Ljava.lang.Object;)V", false).EmitCall(ilgen);
					ilgen.Emit(OpCodes.Ret);

					MethodWrapper getValueMethod = annotationAttributeBaseType.GetMethodWrapper("getValue", "(Ljava.lang.String;)Ljava.lang.Object;", false);
					MethodWrapper getByteValueMethod = annotationAttributeBaseType.GetMethodWrapper("getByteValue", "(Ljava.lang.String;)B", false);
					MethodWrapper getBooleanValueMethod = annotationAttributeBaseType.GetMethodWrapper("getBooleanValue", "(Ljava.lang.String;)Z", false);
					MethodWrapper getCharValueMethod = annotationAttributeBaseType.GetMethodWrapper("getCharValue", "(Ljava.lang.String;)C", false);
					MethodWrapper getShortValueMethod = annotationAttributeBaseType.GetMethodWrapper("getShortValue", "(Ljava.lang.String;)S", false);
					MethodWrapper getIntValueMethod = annotationAttributeBaseType.GetMethodWrapper("getIntValue", "(Ljava.lang.String;)I", false);
					MethodWrapper getFloatValueMethod = annotationAttributeBaseType.GetMethodWrapper("getFloatValue", "(Ljava.lang.String;)F", false);
					MethodWrapper getLongValueMethod = annotationAttributeBaseType.GetMethodWrapper("getLongValue", "(Ljava.lang.String;)J", false);
					MethodWrapper getDoubleValueMethod = annotationAttributeBaseType.GetMethodWrapper("getDoubleValue", "(Ljava.lang.String;)D", false);
					for(int i = 0; i < o.methods.Length; i++)
					{
						// skip <clinit>
						if(!o.methods[i].IsStatic)
d6041 2
a6042 6
							MethodBuilder mb = attributeTypeBuilder.DefineMethod(o.methods[i].Name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot, o.methods[i].ReturnTypeForDefineMethod, o.methods[i].GetParametersForDefineMethod());
							attributeTypeBuilder.DefineMethodOverride(mb, (MethodInfo)o.methods[i].GetMethod());
							ilgen = mb.GetILGenerator();
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldstr, o.methods[i].Name);
							if(o.methods[i].ReturnType.IsPrimitive)
d6044 1
a6044 1
								if(o.methods[i].ReturnType == PrimitiveTypeWrapper.BYTE)
d6046 5
a6050 1
									getByteValueMethod.EmitCall(ilgen);
d6052 29
a6080 1
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.BOOLEAN)
d6082 3
a6084 1
									getBooleanValueMethod.EmitCall(ilgen);
d6086 16
a6101 1
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.CHAR)
d6103 5
a6107 1
									getCharValueMethod.EmitCall(ilgen);
d6109 1
a6109 1
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.SHORT)
d6111 5
a6115 1
									getShortValueMethod.EmitCall(ilgen);
d6117 1
a6117 1
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.INT)
d6119 10
a6128 1
									getIntValueMethod.EmitCall(ilgen);
d6130 1
a6130 1
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.FLOAT)
d6132 8
a6139 1
									getFloatValueMethod.EmitCall(ilgen);
d6141 5
a6145 1
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.LONG)
d6147 3
a6149 1
									getLongValueMethod.EmitCall(ilgen);
d6151 7
a6157 1
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.DOUBLE)
d6159 1
a6159 5
									getDoubleValueMethod.EmitCall(ilgen);
								}
								else
								{
									throw new InvalidOperationException();
d6162 11
a6172 1
							else
d6174 3
a6176 2
								getValueMethod.EmitCall(ilgen);
								o.methods[i].ReturnType.EmitCheckcast(null, ilgen);
d6178 1
a6178 4
							ilgen.Emit(OpCodes.Ret);

							if(o.classFile.Methods[i].AnnotationDefault != null
								&& !(o.methods[i].Name == "value" && requiredArgCount == 0))
d6180 3
a6182 3
								// now add a .NET property for this annotation optional parameter
								Type argType = TypeWrapperToAnnotationParameterType(o.methods[i].ReturnType);
								if(argType != null)
d6184 14
a6197 13
									PropertyBuilder pb = attributeTypeBuilder.DefineProperty(o.methods[i].Name, PropertyAttributes.None, argType, Type.EmptyTypes);
									AttributeHelper.HideFromJava(pb);
									MethodBuilder setter = attributeTypeBuilder.DefineMethod("set_" + o.methods[i].Name, MethodAttributes.Public, typeof(void), new Type[] { argType });
									AttributeHelper.HideFromJava(setter);
									pb.SetSetMethod(setter);
									ilgen = setter.GetILGenerator();
									EmitSetValueCall(annotationAttributeBaseType, ilgen, o.methods[i].Name, o.methods[i].ReturnType, 1);
									ilgen.Emit(OpCodes.Ret);
									MethodBuilder getter = attributeTypeBuilder.DefineMethod("get_" + o.methods[i].Name, MethodAttributes.Public, argType, Type.EmptyTypes);
									AttributeHelper.HideFromJava(getter);
									pb.SetGetMethod(getter);
									// TODO implement the getter method
									getter.GetILGenerator().ThrowException(typeof(NotImplementedException));
d6200 82
d6283 13
d6297 2
a6298 6
					attributeTypeBuilder.CreateType();
				}

				internal override void Apply(ClassLoaderWrapper loader, TypeBuilder tb, object annotation)
				{
					if(annotationTypeBuilder != null)
d6300 1
a6300 2
						annotation = QualifyClassNames(loader, annotation);
						tb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
d6302 2
d6305 1
a6305 2

				internal override void Apply(ClassLoaderWrapper loader, MethodBuilder mb, object annotation)
d6307 1
a6307 5
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						mb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
d6309 5
d6315 9
a6323 1
				internal override void Apply(ClassLoaderWrapper loader, ConstructorBuilder cb, object annotation)
d6325 2
a6326 1
					if(annotationTypeBuilder != null)
d6328 1
a6328 2
						annotation = QualifyClassNames(loader, annotation);
						cb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
d6331 2
a6332 2

				internal override void Apply(ClassLoaderWrapper loader, FieldBuilder fb, object annotation)
d6334 1
a6334 5
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						fb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
d6336 2
d6339 3
a6341 1
				internal override void Apply(ClassLoaderWrapper loader, ParameterBuilder pb, object annotation)
d6343 1
a6343 5
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						pb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
d6345 55
d6401 4
a6404 1
				internal override void Apply(ClassLoaderWrapper loader, AssemblyBuilder ab, object annotation)
d6406 1
a6406 5
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						ab.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
d6408 1
d6410 3
a6412 1
				internal override void Apply(ClassLoaderWrapper loader, PropertyBuilder pb, object annotation)
d6414 1
a6414 5
					if(annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						pb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
d6418 1
d6420 6
a6425 2
#if !STATIC_COMPILER
			internal class JniProxyBuilder
d6427 3
a6429 2
				private static ModuleBuilder mod;
				private static int count;
d6431 3
a6433 1
				static JniProxyBuilder()
d6435 1
a6435 7
					AssemblyName name = new AssemblyName();
					name.Name = "jniproxy";
					AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, JVM.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
					DynamicClassLoader.RegisterForSaveDebug(ab);
					mod = ab.DefineDynamicModule("jniproxy.dll", "jniproxy.dll");
					CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(JavaModuleAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
					mod.SetCustomAttribute(cab);
d6437 3
a6439 2

				internal static void Generate(ILGenerator ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args)
d6441 1
a6441 4
					TypeBuilder tb = mod.DefineType("__<jni>" + (count++), TypeAttributes.Public | TypeAttributes.Class);
					int instance = m.IsStatic ? 0 : 1;
					Type[] argTypes = new Type[args.Length + instance + 1];
					if(instance != 0)
d6443 5
a6447 1
						argTypes[0] = typeof(object);
d6449 1
a6449 1
					for(int i = 0; i < args.Length; i++)
d6451 9
a6459 3
						// NOTE we take a shortcut here by assuming that all "special" types (i.e. ghost or value types)
						// are public and so we can get away with replacing all other types with object.
						argTypes[i + instance] = (args[i].IsPrimitive || args[i].IsGhost || args[i].IsNonPrimitiveValueType) ? args[i].TypeAsSignatureType : typeof(object);
d6461 1
a6461 7
					argTypes[argTypes.Length - 1] = typeof(RuntimeMethodHandle);
					Type retType = (mw.ReturnType.IsPrimitive || mw.ReturnType.IsGhost || mw.ReturnType.IsNonPrimitiveValueType) ? mw.ReturnType.TypeAsSignatureType : typeof(object);
					MethodBuilder mb = tb.DefineMethod("method", MethodAttributes.Public | MethodAttributes.Static, retType, argTypes);
					AttributeHelper.HideFromJava(mb);
					JniBuilder.Generate(mb.GetILGenerator(), wrapper, mw, tb, classFile, m, args, true);
					tb.CreateType();
					for(int i = 0; i < argTypes.Length - 1; i++)
d6463 9
a6471 1
						ilGenerator.Emit(OpCodes.Ldarg, (short)i);
d6473 1
a6473 3
					ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
					ilGenerator.Emit(OpCodes.Call, mb);
					if(!mw.ReturnType.IsPrimitive && !mw.ReturnType.IsGhost && !mw.ReturnType.IsNonPrimitiveValueType)
d6475 9
a6483 1
						ilGenerator.Emit(OpCodes.Castclass, mw.ReturnType.TypeAsSignatureType);
a6484 1
					ilGenerator.Emit(OpCodes.Ret);
d6486 1
a6486 22
			}
#endif // !STATIC_COMPILER

			private class JniBuilder
			{
#if STATIC_COMPILER
				private static readonly Type localRefStructType = StaticCompiler.GetType("IKVM.Runtime.JNI+Frame");
#elif FIRST_PASS
				private static readonly Type localRefStructType = null;
#else
				private static readonly Type localRefStructType = JVM.LoadType(typeof(IKVM.Runtime.JNI.Frame));
#endif
				private static readonly MethodInfo jniFuncPtrMethod = localRefStructType.GetMethod("GetFuncPtr");
				private static readonly MethodInfo enterLocalRefStruct = localRefStructType.GetMethod("Enter");
				private static readonly MethodInfo leaveLocalRefStruct = localRefStructType.GetMethod("Leave");
				private static readonly MethodInfo makeLocalRef = localRefStructType.GetMethod("MakeLocalRef");
				private static readonly MethodInfo unwrapLocalRef = localRefStructType.GetMethod("UnwrapLocalRef");
				private static readonly MethodInfo writeLine = typeof(Console).GetMethod("WriteLine", new Type[] { typeof(object) }, null);
				private static readonly MethodInfo monitorEnter = typeof(System.Threading.Monitor).GetMethod("Enter", new Type[] { typeof(object) });
				private static readonly MethodInfo monitorExit = typeof(System.Threading.Monitor).GetMethod("Exit", new Type[] { typeof(object) });

				internal static void Generate(ILGenerator ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args, bool thruProxy)
d6488 1
a6488 3
					LocalBuilder syncObject = null;
					FieldInfo classObjectField;
					if(thruProxy)
d6490 5
a6494 1
						classObjectField = typeBuilder.DefineField("__<classObject>", typeof(object), FieldAttributes.Static | FieldAttributes.Private | FieldAttributes.SpecialName);
d6496 1
a6496 1
					else
d6498 1
a6498 94
						classObjectField = wrapper.ClassObjectField;
					}
					if(m.IsSynchronized && m.IsStatic)
					{
						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
						Label label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Brtrue_S, label);
						ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.GetClassFromTypeHandle);
						ilGenerator.Emit(OpCodes.Stsfld, classObjectField);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
						ilGenerator.Emit(OpCodes.Dup);
						syncObject = ilGenerator.DeclareLocal(typeof(object));
						ilGenerator.Emit(OpCodes.Stloc, syncObject);
						ilGenerator.Emit(OpCodes.Call, monitorEnter);
						ilGenerator.BeginExceptionBlock();
					}
					string sig = m.Signature.Replace('.', '/');
					// TODO use/unify JNI.METHOD_PTR_FIELD_PREFIX
					FieldBuilder methodPtr = typeBuilder.DefineField("__<jniptr>" + m.Name + sig, typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
					LocalBuilder localRefStruct = ilGenerator.DeclareLocal(localRefStructType);
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					ilGenerator.Emit(OpCodes.Initobj, localRefStructType);
					ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
					Label oklabel = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Brtrue, oklabel);
					if(thruProxy)
					{
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(args.Length + (mw.IsStatic ? 0 : 1)));
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
					}
					ilGenerator.Emit(OpCodes.Ldstr, classFile.Name.Replace('.', '/'));
					ilGenerator.Emit(OpCodes.Ldstr, m.Name);
					ilGenerator.Emit(OpCodes.Ldstr, sig);
					ilGenerator.Emit(OpCodes.Call, jniFuncPtrMethod);
					ilGenerator.Emit(OpCodes.Stsfld, methodPtr);
					ilGenerator.MarkLabel(oklabel);
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					if(thruProxy)
					{
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(args.Length + (mw.IsStatic ? 0 : 1)));
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
					}
					ilGenerator.Emit(OpCodes.Call, enterLocalRefStruct);
					LocalBuilder jnienv = ilGenerator.DeclareLocal(typeof(IntPtr));
					ilGenerator.Emit(OpCodes.Stloc, jnienv);
					ilGenerator.BeginExceptionBlock();
					TypeWrapper retTypeWrapper = mw.ReturnType;
					if(!retTypeWrapper.IsUnloadable && !retTypeWrapper.IsPrimitive)
					{
						// this one is for use after we return from "calli"
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					}
					ilGenerator.Emit(OpCodes.Ldloc, jnienv);
					Type[] modargs = new Type[args.Length + 2];
					modargs[0] = typeof(IntPtr);
					modargs[1] = typeof(IntPtr);
					for(int i = 0; i < args.Length; i++)
					{
						modargs[i + 2] = args[i].TypeAsSignatureType;
					}
					int add = 0;
					if(!m.IsStatic)
					{
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						ilGenerator.Emit(OpCodes.Ldarg_0);
						ilGenerator.Emit(OpCodes.Call, makeLocalRef);
						add = 1;
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);

						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
						Label label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Brtrue_S, label);
						ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.GetClassFromTypeHandle);
						ilGenerator.Emit(OpCodes.Stsfld, classObjectField);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);

						ilGenerator.Emit(OpCodes.Call, makeLocalRef);
					}
					for(int j = 0; j < args.Length; j++)
					{
						if(args[j].IsUnloadable || !args[j].IsPrimitive)
d6500 1
a6500 17
							ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
							if(!args[j].IsUnloadable && args[j].IsNonPrimitiveValueType)
							{
								ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
								args[j].EmitBox(ilGenerator);
							}
							else if(!args[j].IsUnloadable && args[j].IsGhost)
							{
								ilGenerator.Emit(OpCodes.Ldarga_S, (byte)(j + add));
								ilGenerator.Emit(OpCodes.Ldfld, args[j].GhostRefField);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
							}
							ilGenerator.Emit(OpCodes.Call, makeLocalRef);
							modargs[j + 2] = typeof(IntPtr);
d6502 1
a6502 1
						else
d6504 1
a6504 1
							ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
d6506 1
d6508 4
a6511 3
					ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
					Type realRetType;
					if(retTypeWrapper == PrimitiveTypeWrapper.BOOLEAN)
d6513 1
a6513 1
						realRetType = typeof(byte);
d6515 7
a6521 1
					else if(retTypeWrapper.IsPrimitive)
d6523 1
a6523 1
						realRetType = retTypeWrapper.TypeAsSignatureType;
d6525 5
a6529 1
					else
d6531 1
a6531 1
						realRetType = typeof(IntPtr);
d6533 88
a6620 49
					ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, realRetType, modargs);
					LocalBuilder retValue = null;
					if(retTypeWrapper != PrimitiveTypeWrapper.VOID)
					{
						if(!retTypeWrapper.IsUnloadable && !retTypeWrapper.IsPrimitive)
						{
							ilGenerator.Emit(OpCodes.Call, unwrapLocalRef);
							if(retTypeWrapper.IsNonPrimitiveValueType)
							{
								retTypeWrapper.EmitUnbox(ilGenerator);
							}
							else if(retTypeWrapper.IsGhost)
							{
								LocalBuilder ghost = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
								LocalBuilder obj = ilGenerator.DeclareLocal(typeof(object));
								ilGenerator.Emit(OpCodes.Stloc, obj);
								ilGenerator.Emit(OpCodes.Ldloca, ghost);
								ilGenerator.Emit(OpCodes.Ldloc, obj);
								ilGenerator.Emit(OpCodes.Stfld, retTypeWrapper.GhostRefField);
								ilGenerator.Emit(OpCodes.Ldloc, ghost);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
							}
						}
						retValue = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
						ilGenerator.Emit(OpCodes.Stloc, retValue);
					}
					ilGenerator.BeginCatchBlock(typeof(object));
					ilGenerator.EmitWriteLine("*** exception in native code ***");
					ilGenerator.Emit(OpCodes.Call, writeLine);
					ilGenerator.Emit(OpCodes.Rethrow);
					ilGenerator.BeginFinallyBlock();
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					ilGenerator.Emit(OpCodes.Call, leaveLocalRefStruct);
					ilGenerator.EndExceptionBlock();
					if(m.IsSynchronized && m.IsStatic)
					{
						ilGenerator.BeginFinallyBlock();
						ilGenerator.Emit(OpCodes.Ldloc, syncObject);
						ilGenerator.Emit(OpCodes.Call, monitorExit);
						ilGenerator.EndExceptionBlock();
					}
					if(retTypeWrapper != PrimitiveTypeWrapper.VOID)
					{
						ilGenerator.Emit(OpCodes.Ldloc, retValue);
					}
					ilGenerator.Emit(OpCodes.Ret);
d6622 34
d6662 2
a6663 1
					throw new InvalidOperationException("InnerClasses is only available for finished types");
d6671 2
a6672 1
					throw new InvalidOperationException("DeclaringTypeWrapper is only available for finished types");
d6680 1
a6680 15
					ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
					if(innerclasses != null)
					{
						for(int i = 0; i < innerclasses.Length; i++)
						{
							if(innerclasses[i].innerClass != 0)
							{
								if(classFile.GetConstantPoolClass(innerclasses[i].innerClass) == wrapper.Name)
								{
									return innerclasses[i].accessFlags;
								}
							}
						}
					}
					return classFile.Modifiers;
d6684 1
a6684 1
			private void UpdateClashTable()
d6686 1
a6686 1
				lock(this)
d6688 1
a6688 14
					if(memberclashtable == null)
					{
						memberclashtable = new Hashtable();
						for(int i = 0; i < methods.Length; i++)
						{
							// TODO at the moment we don't support constructor signature clash resolving, so we better
							// not put them in the clash table
							if(methods[i].IsLinked && methods[i].GetMethod() != null && methods[i].Name != "<init>")
							{
								string key = GenerateClashKey("method", methods[i].RealName, methods[i].ReturnTypeForDefineMethod, methods[i].GetParametersForDefineMethod());
								memberclashtable.Add(key, key);
							}
						}
					}
d6692 1
a6692 1
			private static string GenerateClashKey(string type, string name, Type retOrFieldType, Type[] args)
d6694 1
a6694 3
				System.Text.StringBuilder sb = new System.Text.StringBuilder(type);
				sb.Append(':').Append(name).Append(':').Append(retOrFieldType.FullName);
				if(args != null)
d6696 1
a6696 4
					foreach(Type t in args)
					{
						sb.Append(':').Append(t.FullName);
					}
a6697 1
				return sb.ToString();
d6700 41
a6740 1
			private ConstructorBuilder DefineClassInitializer()
d6742 1
a6742 11
				if(typeBuilder.IsInterface)
				{
					// LAMESPEC the ECMA spec says (part. I, sect. 8.5.3.2) that all interface members must be public, so we make
					// the class constructor public.
					// NOTE it turns out that on .NET 2.0 this isn't necessary anymore (neither Ref.Emit nor the CLR verifier complain about it),
					// but the C# compiler still considers interfaces with non-public methods to be invalid, so to keep interop with C# we have
					// to keep making the .cctor method public.
					return typeBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
				}
				// NOTE we don't need to record the modifiers here, because they aren't visible from Java reflection
				return typeBuilder.DefineTypeInitializer();
d6745 1
a6745 2
			// this finds the method that md is going to be overriding
			private MethodWrapper FindBaseMethod(string name, string sig, out bool explicitOverride)
d6747 2
a6748 2
				Debug.Assert(!classFile.IsInterface);
				Debug.Assert(name != "<init>");
d6750 3
a6752 53
				explicitOverride = false;
				TypeWrapper tw = wrapper.BaseTypeWrapper;
				while(tw != null)
				{
					MethodWrapper baseMethod = tw.GetMethodWrapper(name, sig, true);
					if(baseMethod == null)
					{
						return null;
					}
					// here are the complex rules for determining whether this method overrides the method we found
					// RULE 1: final methods may not be overridden
					// (note that we intentionally not check IsStatic here!)
					if(baseMethod.IsFinal
						&& !baseMethod.IsPrivate
						&& (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)))
					{
						throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + baseMethod.DeclaringType.Name + " is overriden in " + wrapper.Name);
					}
					// RULE 1a: static methods are ignored (other than the RULE 1 check)
					if(baseMethod.IsStatic)
					{
					}
					// RULE 2: public & protected methods can be overridden (package methods are handled by RULE 4)
					// (by public, protected & *package* methods [even if they are in a different package])
					else if(baseMethod.IsPublic || baseMethod.IsProtected)
					{
						// if we already encountered a package method, we cannot override the base method of
						// that package method
						if(explicitOverride)
						{
							explicitOverride = false;
							return null;
						}
						return baseMethod;
					}
					// RULE 3: private and static methods are ignored
					else if(!baseMethod.IsPrivate)
					{
						// RULE 4: package methods can only be overridden in the same package
						if(baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)
							|| (baseMethod.IsInternal && baseMethod.DeclaringType.GetClassLoader().InternalsVisibleTo(wrapper.GetClassLoader())))
						{
							return baseMethod;
						}
						// since we encountered a method with the same name/signature that we aren't overriding,
						// we need to specify an explicit override
						// NOTE we only do this if baseMethod isn't private, because if it is, Reflection.Emit
						// will complain about the explicit MethodOverride (possibly a bug)
						explicitOverride = true;
					}
					tw = baseMethod.DeclaringType.BaseTypeWrapper;
				}
				return null;
d6755 1
a6755 1
			internal string GenerateUniqueMethodName(string basename, MethodWrapper mw)
d6757 1
a6757 1
				return GenerateUniqueMethodName(basename, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
d6760 1
a6760 1
			internal string GenerateUniqueMethodName(string basename, Type returnType, Type[] parameterTypes)
d6762 1
a6762 13
				string name = basename;
				string key = GenerateClashKey("method", name, returnType, parameterTypes);
				UpdateClashTable();
				lock(memberclashtable.SyncRoot)
				{
					for(int clashcount = 0; memberclashtable.ContainsKey(key); clashcount++)
					{
						name = basename + "_" + clashcount;
						key = GenerateClashKey("method", name, returnType, parameterTypes);
					}
					memberclashtable.Add(key, key);
				}
				return name;
d6765 2
a6766 1
			private static MethodInfo GetBaseFinalizeMethod(TypeWrapper wrapper, out bool clash)
d6768 1
a6768 2
				clash = false;
				for(;;)
d6770 1
a6770 23
					// HACK we get called during method linking (which is probably a bad idea) and
					// it is possible for the base type not to be finished yet, so we look at the
					// private state of the unfinished base types to find the finalize method.
					DynamicTypeWrapper dtw = wrapper as DynamicTypeWrapper;
					if(dtw == null)
					{
						break;
					}
					JavaTypeImpl impl = dtw.impl as JavaTypeImpl;
					if(impl == null)
					{
						break;
					}
					MethodWrapper mw = dtw.GetMethodWrapper(StringConstants.FINALIZE, StringConstants.SIG_VOID, false);
					if(mw != null)
					{
						mw.Link();
					}
					if(impl.finalizeMethod != null)
					{
						return impl.finalizeMethod;
					}
					wrapper = wrapper.BaseTypeWrapper;
d6772 5
a6776 3
				Type type = wrapper.TypeAsBaseType;
				MethodInfo baseFinalize = type.GetMethod("__<Finalize>", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
				if(baseFinalize != null)
d6778 1
a6778 1
					return baseFinalize;
d6780 24
a6803 1
				while(type != null)
d6805 1
a6805 1
					foreach(MethodInfo m in type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
d6807 1
a6807 10
						if(m.Name == "Finalize"
							&& m.ReturnType == typeof(void)
							&& m.GetParameters().Length == 0)
						{
							if(m.GetBaseDefinition().DeclaringType == typeof(object))
							{
								return m;
							}
							clash = true;
						}
d6809 1
a6809 1
					type = type.BaseType;
a6810 1
				return null;
d6813 1
a6813 1
			private MethodAttributes GetPropertyAccess(MethodWrapper mw)
d6815 1
a6815 7
				string sig = mw.ReturnType.SigName;
				if(sig == "V")
				{
					sig = mw.GetParameters()[0].SigName;
				}
				int access = -1;
				foreach(ClassFile.Field field in classFile.Fields)
d6817 1
a6817 4
					if(field.IsProperty
						&& field.IsStatic == mw.IsStatic
						&& field.Signature == sig
						&& (field.PropertyGetter == mw.Name || field.PropertySetter == mw.Name))
d6819 2
a6820 21
						int nacc;
						if(field.IsPublic)
						{
							nacc = 3;
						}
						else if(field.IsProtected)
						{
							nacc = 2;
						}
						else if(field.IsPrivate)
						{
							nacc = 0;
						}
						else
						{
							nacc = 1;
						}
						if(nacc > access)
						{
							access = nacc;
						}
d6822 1
d6824 5
a6828 1
				switch(access)
d6830 1
a6830 10
					case 0:
						return MethodAttributes.Private;
					case 1:
						return MethodAttributes.Assembly;
					case 2:
						return MethodAttributes.FamORAssem;
					case 3:
						return MethodAttributes.Public;
					default:
						throw new InvalidOperationException();
d6832 1
d6835 1
a6835 1
			private MethodBase GenerateMethod(int index, bool unloadableOverrideStub)
d6837 2
a6838 13
				methods[index].AssertLinked();
				Profiler.Enter("JavaTypeImpl.GenerateMethod");
				try
				{
					if(index >= classFile.Methods.Length)
					{
						if(methods[index].IsMirandaMethod)
						{
							// We're a Miranda method
							Debug.Assert(baseMethods[index].DeclaringType.IsInterface);
							string name = GenerateUniqueMethodName(methods[index].Name, baseMethods[index]);
							MethodBuilder mb = typeBuilder.DefineMethod(methods[index].Name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							AttributeHelper.HideFromReflection(mb);
d6840 1
a6840 6
							if(unloadableOverrideStub || name != methods[index].Name)
							{
								// instead of creating an override stub, we created the Miranda method with the proper signature and
								// decorate it with a NameSigAttribute that contains the real signature
								AttributeHelper.SetNameSig(mb, methods[index].Name, methods[index].Signature);
							}
d6842 18
a6859 20
							// if we changed the name or if the interface method name is remapped, we need to add an explicit methodoverride.
							if(!baseMethods[index].IsDynamicOnly && name != baseMethods[index].RealName)
							{
								typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethods[index].GetMethod());
							}
							return mb;
						}
						else if(methods[index].IsAccessStub)
						{
							Debug.Assert(!baseMethods[index].HasCallerID);
							MethodAttributes stubattribs = baseMethods[index].IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
							stubattribs |= MethodAttributes.HideBySig;
							if(baseMethods[index].IsStatic)
							{
								stubattribs |= MethodAttributes.Static;
							}
							else
							{
								stubattribs |= MethodAttributes.CheckAccessOnOverride | MethodAttributes.Virtual;
								if(baseMethods[index].IsAbstract && wrapper.IsAbstract)
d6861 10
a6870 1
									stubattribs |= MethodAttributes.Abstract;
d6872 1
a6872 1
								if(baseMethods[index].IsFinal)
d6874 7
a6880 96
									// NOTE final methods still need to be virtual, because a subclass may need this method to
									// implement an interface method
									stubattribs |= MethodAttributes.Final | MethodAttributes.NewSlot;
								}
							}
							MethodBuilder mb = typeBuilder.DefineMethod(methods[index].Name, stubattribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							AttributeHelper.HideFromReflection(mb);
							if(!baseMethods[index].IsAbstract)
							{
								ILGenerator ilgen = mb.GetILGenerator();
								int argc = methods[index].GetParametersForDefineMethod().Length + (methods[index].IsStatic ? 0 : 1);
								for(int i = 0; i < argc; i++)
								{
									ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
								}
								baseMethods[index].EmitCall(ilgen);
								ilgen.Emit(OpCodes.Ret);
							}
							else if(!wrapper.IsAbstract)
							{
								EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + methods[index].Name + methods[index].Signature);
							}
							return mb;
						}
						else
						{
							throw new InvalidOperationException();
						}
					}
					ClassFile.Method m = classFile.Methods[index];
					MethodBase method;
					bool setNameSig = methods[index].ReturnType.IsErasedOrBoxedPrimitiveOrRemapped;
					foreach(TypeWrapper tw in methods[index].GetParameters())
					{
						setNameSig |= tw.IsErasedOrBoxedPrimitiveOrRemapped;
					}
					bool setModifiers = false;
					if(methods[index].HasCallerID && (m.Modifiers & Modifiers.VarArgs) != 0)
					{
						// the implicit callerID parameter was added at the end so that means we shouldn't use ParamArrayAttribute,
						// so we need to explicitly record that the method is varargs
						setModifiers = true;
					}
					MethodAttributes attribs = MethodAttributes.HideBySig;
					if(m.IsNative)
					{
						if(wrapper.IsPInvokeMethod(m))
						{
							// this doesn't appear to be necessary, but we use the flag in Finish to know
							// that we shouldn't emit a method body
							attribs |= MethodAttributes.PinvokeImpl;
						}
						else
						{
							setModifiers = true;
						}
					}
					if(methods[index].IsPropertyAccessor)
					{
						attribs |= GetPropertyAccess(methods[index]);
						attribs |= MethodAttributes.SpecialName;
						setModifiers = true;
					}
					else
					{
						if(m.IsPrivate)
						{
							attribs |= MethodAttributes.Private;
						}
						else if(m.IsProtected)
						{
							attribs |= MethodAttributes.FamORAssem;
						}
						else if(m.IsPublic)
						{
							attribs |= MethodAttributes.Public;
						}
						else
						{
							attribs |= MethodAttributes.Assembly;
						}
					}
					if(ReferenceEquals(m.Name, StringConstants.INIT))
					{
						Type[][] modopt = null;
						if(setNameSig)
						{
							// we add optional modifiers to make the signature unique
							TypeWrapper[] parameters = methods[index].GetParameters();
							modopt = new Type[parameters.Length][];
							for(int i = 0; i < parameters.Length; i++)
							{
								if(parameters[i].IsGhostArray)
								{
									TypeWrapper elemTypeWrapper = parameters[i];
									while(elemTypeWrapper.IsArray)
d6882 1
a6882 1
										elemTypeWrapper = elemTypeWrapper.ElementTypeWrapper;
a6883 9
									modopt[i] = new Type[] { elemTypeWrapper.TypeAsTBD };
								}
								else if(parameters[i].IsBoxedPrimitive)
								{
									modopt[i] = new Type[] { typeof(object) };
								}
								else if(parameters[i].IsRemapped && parameters[i] is DotNetTypeWrapper)
								{
									modopt[i] = new Type[] { parameters[i].TypeAsSignatureType };
d6885 1
a6885 1
								else if(parameters[i].IsUnloadable)
d6887 16
a6902 1
									modopt[i] = new Type[] { wrapper.classLoader.GetTypeWrapperFactory().DefineUnloadable(parameters[i].Name) };
d6906 21
a6926 2
						// strictfp is the only modifier that a constructor can have
						if(m.IsStrictfp)
d6928 1
a6928 1
							setModifiers = true;
d6930 2
a6931 6
						method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, methods[index].GetParametersForDefineMethod(), null, modopt);
						((ConstructorBuilder)method).SetImplementationFlags(MethodImplAttributes.NoInlining);
					}
					else if(m.IsClassInitializer)
					{
						method = DefineClassInitializer();
d6935 1
a6935 1
						if(m.IsAbstract)
d6937 2
a6938 15
							// only if the classfile is abstract, we make the CLR method abstract, otherwise,
							// we have to generate a method that throws an AbstractMethodError (because the JVM
							// allows abstract methods in non-abstract classes)
							if(classFile.IsAbstract)
							{
								if(classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected))
								{
									setModifiers = true;
								}
								else
								{
									attribs |= MethodAttributes.Abstract;
								}
							}
							else
d6940 3
a6942 1
								setModifiers = true;
d6944 1
a6944 4
						}
						if(m.IsFinal)
						{
							if(!m.IsStatic && !m.IsPrivate)
d6946 3
a6948 1
								attribs |= MethodAttributes.Final;
d6950 1
a6950 1
							else
d6952 3
a6954 1
								setModifiers = true;
d6957 1
a6957 1
						if(m.IsStatic)
d6959 1
a6959 2
							attribs |= MethodAttributes.Static;
							if(m.IsSynchronized)
d6961 1
a6961 1
								setModifiers = true;
d6963 5
a6967 6
						}
						else if(!m.IsPrivate)
						{
							attribs |= MethodAttributes.Virtual | MethodAttributes.CheckAccessOnOverride;
						}
						string name = m.Name;
d6969 2
a6970 6
						if((m.Modifiers & Modifiers.Bridge) != 0 && (m.IsPublic || m.IsProtected) && wrapper.IsPublic)
						{
							string sigbase = m.Signature.Substring(0, m.Signature.LastIndexOf(')') + 1);
							foreach(MethodWrapper mw in methods)
							{
								if(mw.Name == m.Name && mw.Signature.StartsWith(sigbase) && mw.Signature != m.Signature)
d6972 1
a6972 5
									// To prevent bridge methods with covariant return types from confusing
									// other .NET compilers (like C#), we rename the bridge method.
									name = "<bridge>" + name;
									setNameSig = true;
									break;
a6973 2
							}
						}
d6975 2
a6976 34
						// if a method is virtual, we need to find the method it overrides (if any), for several reasons:
						// - if we're overriding a method that has a different name (e.g. some of the virtual methods
						//   in System.Object [Equals <-> equals]) we need to add an explicit MethodOverride
						// - if one of the base classes has a similar method that is private (or package) that we aren't
						//   overriding, we need to specify an explicit MethodOverride
						MethodWrapper baseMce = baseMethods[index];
						bool explicitOverride = methods[index].IsExplicitOverride;
						if((attribs & MethodAttributes.Virtual) != 0 && !classFile.IsInterface)
						{
							// make sure the base method is already defined
							Debug.Assert(baseMce == null || baseMce.GetMethod() != null);
							if(baseMce == null || baseMce.DeclaringType.IsInterface)
							{
								// we need to set NewSlot here, to prevent accidentally overriding methods
								// (for example, if a Java class has a method "boolean Equals(object)", we don't want that method
								// to override System.Object.Equals)
								attribs |= MethodAttributes.NewSlot;
							}
							else
							{
								// if we have a method overriding a more accessible method (the JVM allows this), we need to make the
								// method more accessible, because otherwise the CLR will complain that we're reducing access
								MethodBase baseMethod = baseMce.GetMethod();
								if((baseMethod.IsPublic && !m.IsPublic) ||
									((baseMethod.IsFamily || baseMethod.IsFamilyOrAssembly) && !m.IsPublic && !m.IsProtected) ||
									(!m.IsPublic && !m.IsProtected && !baseMce.DeclaringType.IsPackageAccessibleFrom(wrapper)))
								{
									attribs &= ~MethodAttributes.MemberAccessMask;
									attribs |= baseMethod.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
									setModifiers = true;
								}
							}
						}
						MethodBuilder mb = null;
d6978 1
a6978 1
						mb = wrapper.DefineGhostMethod(name, attribs, methods[index]);
d6980 3
a6982 10
						if(mb == null)
						{
							bool needFinalize = false;
							bool needDispatch = false;
							bool finalizeClash = false;
							MethodInfo baseFinalize = null;
							if(baseMce != null && ReferenceEquals(m.Name, StringConstants.FINALIZE) && ReferenceEquals(m.Signature, StringConstants.SIG_VOID))
							{
								baseFinalize = GetBaseFinalizeMethod(wrapper.BaseTypeWrapper, out finalizeClash);
								if(baseMce.RealName == "Finalize")
d6984 23
a7006 5
									// We're overriding Finalize (that was renamed to finalize by DotNetTypeWrapper)
									// in a non-Java base class.
									attribs |= MethodAttributes.NewSlot;
									needFinalize = true;
									needDispatch = true;
d7008 1
a7008 1
								else if(baseMce.DeclaringType == CoreClasses.java.lang.Object.Wrapper)
d7010 13
a7022 15
									// This type is the first type in the hierarchy to introduce a finalize method
									// (other than the one in java.lang.Object obviously), so we need to override
									// the real Finalize method and emit a dispatch call to our finalize method.
									needFinalize = true;
									needDispatch = true;
								}
								else if(m.IsFinal)
								{
									// One of our base classes already has a  finalize method, so we already are
									// hooked into the real Finalize, but we need to override it again, to make it
									// final (so that non-Java types cannot override it either).
									needFinalize = true;
									needDispatch = false;
									// If the base class finalize was optimized away, we need a dispatch call after all.
									if(baseFinalize.DeclaringType == typeof(object))
d7024 1
a7024 1
										needDispatch = true;
d7026 1
d7030 7
a7036 4
									// One of our base classes already has a finalize method, but it may have been an empty
									// method so that the hookup to the real Finalize was optimized away, we need to check
									// for that.
									if(baseFinalize.DeclaringType == typeof(object))
d7038 10
a7047 2
										needFinalize = true;
										needDispatch = true;
a7049 10
								if(needFinalize &&
									!m.IsAbstract && !m.IsNative &&
									(!m.IsFinal || classFile.IsFinal) &&
									m.Instructions.Length > 0 &&
									m.Instructions[0].NormalizedOpCode == NormalizedByteCode.__return)
								{
									// we've got an empty finalize method, so we don't need to override the real finalizer
									// (not having a finalizer makes a huge perf difference)
									needFinalize = false;
								}
d7051 1
a7051 1
							if(setNameSig || memberclashtable != null)
d7053 1
a7053 7
								// TODO we really should make sure that the name we generate doesn't already exist in a
								// base class (not in the Java method namespace, but in the CLR method namespace)
								name = GenerateUniqueMethodName(name, methods[index]);
								if(name != m.Name)
								{
									setNameSig = true;
								}
d7055 8
a7062 2
							bool needMethodImpl = baseMce != null && (explicitOverride || baseMce.RealName != name) && !needFinalize;
							if(unloadableOverrideStub || needMethodImpl)
d7064 1
a7064 1
								attribs |= MethodAttributes.NewSlot;
d7066 5
a7070 2
							mb = typeBuilder.DefineMethod(name, attribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							if(unloadableOverrideStub)
d7072 1
a7072 1
								GenerateUnloadableOverrideStub(baseMce, mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
d7074 1
a7074 1
							else if(needMethodImpl)
d7076 9
a7084 3
								// assert that the method we're overriding is in fact virtual and not final!
								Debug.Assert(baseMce.GetMethod().IsVirtual && !baseMce.GetMethod().IsFinal);
								typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMce.GetMethod());
d7086 95
a7180 1
							if(!m.IsStatic && !m.IsAbstract && !m.IsPrivate && baseMce != null && !baseMce.DeclaringType.IsPackageAccessibleFrom(wrapper))
d7182 3
a7184 3
								// we may have to explicitly override another package accessible abstract method
								TypeWrapper btw = baseMce.DeclaringType.BaseTypeWrapper;
								while(btw != null)
d7186 1
a7186 6
									MethodWrapper bmw = btw.GetMethodWrapper(m.Name, m.Signature, true);
									if(bmw == null)
									{
										break;
									}
									if(bmw.DeclaringType.IsPackageAccessibleFrom(wrapper) && bmw.IsAbstract && !(bmw.IsPublic || bmw.IsProtected))
d7188 1
a7188 5
										if(bmw != baseMce)
										{
											typeBuilder.DefineMethodOverride(mb, (MethodInfo)bmw.GetMethod());
										}
										break;
d7190 1
a7190 1
									btw = bmw.DeclaringType.BaseTypeWrapper;
d7193 1
a7193 3
							// if we're overriding java.lang.Object.finalize we need to emit a stub to override System.Object.Finalize,
							// or if we're subclassing a non-Java class that has a Finalize method, we need a new Finalize override
							if(needFinalize)
d7195 2
a7196 36
								string finalizeName = finalizeClash ? "__<Finalize>" : baseFinalize.Name;
								// if the Java class also defines a Finalize() method, we need to name the stub differently
								foreach(ClassFile.Method mi in classFile.Methods)
								{
									if(mi.Name == "Finalize" && mi.Signature == "()V")
									{
										finalizeName = "__<Finalize>";
										break;
									}
								}
								MethodAttributes attr = MethodAttributes.HideBySig | MethodAttributes.Virtual;
								// make sure we don't reduce accessibility
								attr |= baseFinalize.IsPublic ? MethodAttributes.Public : MethodAttributes.Family;
								if(m.IsFinal)
								{
									attr |= MethodAttributes.Final;
								}
								finalizeMethod = typeBuilder.DefineMethod(finalizeName, attr, CallingConventions.Standard, typeof(void), Type.EmptyTypes);
								if(finalizeName != baseFinalize.Name)
								{
									typeBuilder.DefineMethodOverride(finalizeMethod, baseFinalize);
								}
								AttributeHelper.HideFromJava(finalizeMethod);
								ILGenerator ilgen = finalizeMethod.GetILGenerator();
								ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.SkipFinalizer);
								Label skip = ilgen.DefineLabel();
								ilgen.Emit(OpCodes.Brtrue_S, skip);
								if(needDispatch)
								{
									ilgen.BeginExceptionBlock();
									ilgen.Emit(OpCodes.Ldarg_0);
									ilgen.Emit(OpCodes.Callvirt, mb);
									ilgen.BeginCatchBlock(typeof(object));
									ilgen.EndExceptionBlock();
								}
								else
d7198 1
a7198 2
									ilgen.Emit(OpCodes.Ldarg_0);
									ilgen.Emit(OpCodes.Call, baseFinalize);
a7199 8
								ilgen.MarkLabel(skip);
								ilgen.Emit(OpCodes.Ret);
							}
#if STATIC_COMPILER
							if(classFile.Methods[index].AnnotationDefault != null)
							{
								CustomAttributeBuilder cab = new CustomAttributeBuilder(StaticCompiler.GetType("IKVM.Attributes.AnnotationDefaultAttribute").GetConstructor(new Type[] { typeof(object) }), new object[] { classFile.Methods[index].AnnotationDefault });
								mb.SetCustomAttribute(cab);
a7200 1
#endif // STATIC_COMPILER
a7201 1
						method = mb;
d7203 2
a7204 2
					string[] exceptions = m.ExceptionsAttribute;
					methods[index].SetDeclaredExceptions(exceptions);
d7206 10
a7215 2
					AttributeHelper.SetThrowsAttribute(method, exceptions);
					if(setModifiers || m.IsInternal || (m.Modifiers & (Modifiers.Synthetic | Modifiers.Bridge)) != 0)
d7217 2
a7218 1
						if(method is ConstructorBuilder)
d7220 3
a7222 1
							AttributeHelper.SetModifiers((ConstructorBuilder)method, m.Modifiers, m.IsInternal);
d7226 8
a7233 1
							AttributeHelper.SetModifiers((MethodBuilder)method, m.Modifiers, m.IsInternal);
d7236 33
a7268 2
					if((m.Modifiers & (Modifiers.Synthetic | Modifiers.Bridge)) != 0
						&& (m.IsPublic || m.IsProtected) && wrapper.IsPublic)
d7270 1
a7270 1
						if(method is ConstructorBuilder)
d7272 1
a7272 1
							AttributeHelper.SetEditorBrowsableNever((ConstructorBuilder)method);
d7274 1
a7274 1
						else
d7276 1
a7276 1
							AttributeHelper.SetEditorBrowsableNever((MethodBuilder)method);
a7277 1
						// TODO on WHIDBEY apply CompilerGeneratedAttribute
d7279 5
a7283 1
					if(m.DeprecatedAttribute)
d7285 16
a7300 1
						AttributeHelper.SetDeprecatedAttribute(method);
d7302 1
a7302 1
					if(setNameSig)
d7304 16
a7319 1
						AttributeHelper.SetNameSig(method, m.Name, m.Signature);
d7321 2
a7322 6
					if(m.GenericSignature != null)
					{
						AttributeHelper.SetSignatureAttribute(method, m.GenericSignature);
					}
#else // STATIC_COMPILER
					if(setModifiers)
d7324 2
a7325 1
						// shut up the compiler
a7327 5
					return method;
				}
				finally
				{
					Profiler.Leave("JavaTypeImpl.GenerateMethod");
a7328 1
			}
d7330 1
a7330 13
			private void GenerateUnloadableOverrideStub(MethodWrapper baseMethod, MethodInfo target, Type targetRet, Type[] targetArgs)
			{
				Debug.Assert(!baseMethod.HasCallerID);

				Type stubret = baseMethod.ReturnTypeForDefineMethod;
				Type[] stubargs = baseMethod.GetParametersForDefineMethod();
				string name = GenerateUniqueMethodName(baseMethod.RealName + "/unloadablestub", baseMethod);
				MethodBuilder overrideStub = typeBuilder.DefineMethod(name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final, stubret, stubargs);
				AttributeHelper.HideFromJava(overrideStub);
				typeBuilder.DefineMethodOverride(overrideStub, (MethodInfo)baseMethod.GetMethod());
				ILGenerator ilgen = overrideStub.GetILGenerator();
				ilgen.Emit(OpCodes.Ldarg_0);
				for(int i = 0; i < targetArgs.Length; i++)
d7332 1
a7332 2
					ilgen.Emit(OpCodes.Ldarg_S, (byte)(i + 1));
					if(targetArgs[i] != stubargs[i])
d7334 24
a7357 1
						ilgen.Emit(OpCodes.Castclass, targetArgs[i]);
a7359 7
				ilgen.Emit(OpCodes.Callvirt, target);
				if(targetRet != stubret)
				{
					ilgen.Emit(OpCodes.Castclass, stubret);
				}
				ilgen.Emit(OpCodes.Ret);
			}
d7361 1
a7361 10
			private static bool CheckRequireOverrideStub(MethodWrapper mw1, MethodWrapper mw2)
			{
				// TODO this is too late to generate LinkageErrors so we need to figure this out earlier
				if(mw1.ReturnType != mw2.ReturnType  && !(mw1.ReturnType.IsUnloadable && mw2.ReturnType.IsUnloadable))
				{
					return true;
				}
				TypeWrapper[] args1 = mw1.GetParameters();
				TypeWrapper[] args2 = mw2.GetParameters();
				for(int i = 0; i < args1.Length; i++)
d7363 1
a7363 1
					if(args1[i] != args2[i] && !(args1[i].IsUnloadable && args2[i].IsUnloadable))
d7365 5
a7369 1
						return true;
a7371 2
				return false;
			}
d7373 3
a7375 3
			private void AddMethodOverride(MethodWrapper method, MethodBuilder mb, TypeWrapper iface, string name, string sig, ref Hashtable hashtable, bool unloadableOnly)
			{
				if(hashtable != null && hashtable.ContainsKey(iface))
d7377 6
a7382 6
					return;
				}
				MethodWrapper mw = iface.GetMethodWrapper(name, sig, false);
				if(mw != null)
				{
					if(hashtable == null)
d7384 4
a7387 1
						hashtable = new Hashtable();
d7389 2
a7390 2
					hashtable.Add(iface, iface);
					if(CheckRequireOverrideStub(method, mw))
d7392 1
a7392 1
						GenerateUnloadableOverrideStub(mw, mb, method.ReturnTypeForDefineMethod, method.GetParametersForDefineMethod());
d7394 1
a7394 1
					else if(!unloadableOnly)
d7396 1
a7396 1
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
d7398 1
d7400 1
a7400 9
				foreach(TypeWrapper iface2 in iface.Interfaces)
				{
					AddMethodOverride(method, mb, iface2, name, sig, ref hashtable, unloadableOnly);
				}
			}

			internal override Type Type
			{
				get
d7402 1
a7402 1
					return typeBuilder;
d7404 6
d7412 2
a7413 56
			internal override string GetGenericSignature()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override string[] GetEnclosingMethod()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override string GetGenericMethodSignature(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override string GetGenericFieldSignature(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[] GetDeclaredAnnotations()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object GetMethodDefaultValue(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[] GetMethodAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[][] GetParameterAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[] GetFieldAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

#if STATIC_COMPILER
			internal override Annotation Annotation
d7415 4
a7418 1
				get
d7420 7
a7426 1
					return annotationBuilder;
a7427 1
			}
d7429 1
a7429 3
			internal override Type EnumType
			{
				get
d7431 30
a7460 1
					return enumBuilder;
d7463 1
a7463 2
#endif // STATIC_COMPILER
		}
d7465 1
a7465 6
		private sealed class Metadata
		{
			private string[] genericMetaData;
			private object[][] annotations;

			private Metadata(string[] genericMetaData, object[][] annotations)
d7467 15
a7481 3
				this.genericMetaData = genericMetaData;
				this.annotations = annotations;
			}
d7483 1
a7483 3
			internal static Metadata Create(ClassFile classFile)
			{
				if(classFile.MajorVersion < 49)
d7485 85
a7569 7
					return null;
				}
				string[] genericMetaData = null;
				object[][] annotations = null;
				for(int i = 0; i < classFile.Methods.Length; i++)
				{
					if(classFile.Methods[i].GenericSignature != null)
d7571 12
a7582 5
						if(genericMetaData == null)
						{
							genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
						}
						genericMetaData[i + 4] = classFile.Methods[i].GenericSignature;
d7584 1
a7584 1
					if(classFile.Methods[i].Annotations != null)
d7586 1
a7586 1
						if(annotations == null)
d7588 17
a7604 1
							annotations = new object[5][];
d7606 1
a7606 1
						if(annotations[1] == null)
d7608 1
a7608 1
							annotations[1] = new object[classFile.Methods.Length];
a7609 1
						annotations[1][i] = classFile.Methods[i].Annotations;
d7611 17
a7627 1
					if(classFile.Methods[i].ParameterAnnotations != null)
d7629 1
a7629 1
						if(annotations == null)
d7631 19
a7649 1
							annotations = new object[5][];
d7651 17
a7667 5
						if(annotations[2] == null)
						{
							annotations[2] = new object[classFile.Methods.Length];
						}
						annotations[2][i] = classFile.Methods[i].ParameterAnnotations;
d7669 1
a7669 1
					if(classFile.Methods[i].AnnotationDefault != null)
d7671 1
a7671 9
						if(annotations == null)
						{
							annotations = new object[5][];
						}
						if(annotations[3] == null)
						{
							annotations[3] = new object[classFile.Methods.Length];
						}
						annotations[3][i] = classFile.Methods[i].AnnotationDefault;
d7673 1
d7675 10
a7684 1
				for(int i = 0; i < classFile.Fields.Length; i++)
d7686 1
a7686 1
					if(classFile.Fields[i].GenericSignature != null)
d7688 10
a7697 17
						if(genericMetaData == null)
						{
							genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
						}
						genericMetaData[i + 4 + classFile.Methods.Length] = classFile.Fields[i].GenericSignature;
					}
					if(classFile.Fields[i].Annotations != null)
					{
						if(annotations == null)
						{
							annotations = new object[5][];
						}
						if(annotations[4] == null)
						{
							annotations[4] = new object[classFile.Fields.Length][];
						}
						annotations[4][i] = classFile.Fields[i].Annotations;
d7700 34
a7733 1
				if(classFile.EnclosingMethod != null)
d7735 1
a7735 7
					if(genericMetaData == null)
					{
						genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
					}
					genericMetaData[0] = classFile.EnclosingMethod[0];
					genericMetaData[1] = classFile.EnclosingMethod[1];
					genericMetaData[2] = classFile.EnclosingMethod[2];
d7737 5
a7741 1
				if(classFile.GenericSignature != null)
d7743 1
a7743 1
					if(genericMetaData == null)
d7745 5
a7749 1
						genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
d7751 1
a7751 1
					genericMetaData[3] = classFile.GenericSignature;
d7753 7
a7759 1
				if(classFile.Annotations != null)
d7761 1
a7761 5
					if(annotations == null)
					{
						annotations = new object[5][];
					}
					annotations[0] = classFile.Annotations;
d7763 1
a7763 1
				if(genericMetaData != null || annotations != null)
d7765 1
a7765 1
					return new Metadata(genericMetaData, annotations);
d7767 1
a7767 1
				return null;
d7769 1
d7771 1
a7771 1
			internal static string GetGenericSignature(Metadata m)
d7773 1
a7773 1
				if(m != null && m.genericMetaData != null)
d7775 1
a7775 1
					return m.genericMetaData[3];
d7777 2
a7778 6
				return null;
			}

			internal static string[] GetEnclosingMethod(Metadata m)
			{
				if(m != null && m.genericMetaData != null && m.genericMetaData[0] != null)
d7780 13
a7792 1
					return new string[] { m.genericMetaData[0], m.genericMetaData[1], m.genericMetaData[2] };
d7794 1
a7794 6
				return null;
			}

			internal static string GetGenericMethodSignature(Metadata m, int index)
			{
				if(m != null && m.genericMetaData != null)
d7796 1
a7796 1
					return m.genericMetaData[index + 4];
a7797 1
				return null;
d7800 1
a7800 2
			// note that the caller is responsible for computing the correct index (field index + method count)
			internal static string GetGenericFieldSignature(Metadata m, int index)
d7802 2
a7803 1
				if(m != null && m.genericMetaData != null)
d7805 1
a7805 1
					return m.genericMetaData[index + 4];
d7807 3
a7809 6
				return null;
			}

			internal static object[] GetAnnotations(Metadata m)
			{
				if(m != null && m.annotations != null)
d7811 4
a7814 1
					return m.annotations[0];
d7816 1
a7816 1
				return null;
d7819 1
a7819 1
			internal static object[] GetMethodAnnotations(Metadata m, int index)
d7821 70
a7890 3
				if(m != null && m.annotations != null && m.annotations[1] != null)
				{
					return (object[])m.annotations[1][index];
a7891 1
				return null;
d7894 1
a7894 1
			internal static object[][] GetMethodParameterAnnotations(Metadata m, int index)
d7896 1
a7896 1
				if(m != null && m.annotations != null && m.annotations[2] != null)
d7898 4
a7901 1
					return (object[][])m.annotations[2][index];
d7903 3
a7905 6
				return null;
			}

			internal static object GetMethodDefaultValue(Metadata m, int index)
			{
				if(m != null && m.annotations != null && m.annotations[3] != null)
d7907 15
a7921 1
					return m.annotations[3][index];
a7922 1
				return null;
d7925 1
a7925 2
			// note that unlike GetGenericFieldSignature, the index is simply the field index 
			internal static object[] GetFieldAnnotations(Metadata m, int index)
d7927 3
a7929 1
				if(m != null && m.annotations != null && m.annotations[4] != null)
d7931 1
a7931 1
					return (object[])m.annotations[4][index];
d7933 4
a7936 1
				return null;
a7937 14
		}
	
		private sealed class FinishedTypeImpl : DynamicImpl
		{
			private Type type;
			private TypeWrapper[] innerclasses;
			private TypeWrapper declaringTypeWrapper;
			private Modifiers reflectiveModifiers;
			private MethodInfo clinitMethod;
			private Metadata metadata;
#if STATIC_COMPILER
			private Annotation annotationBuilder;
			private TypeBuilder enumBuilder;
#endif
d7939 1
a7939 6
			internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers, Metadata metadata
#if STATIC_COMPILER
				, Annotation annotationBuilder
				, TypeBuilder enumBuilder
#endif
				)
d7941 3
a7943 6
				this.type = type;
				this.innerclasses = innerclasses;
				this.declaringTypeWrapper = declaringTypeWrapper;
				this.reflectiveModifiers = reflectiveModifiers;
				this.clinitMethod = type.GetMethod("__<clinit>", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				this.metadata = metadata;
d7945 2
a7946 8
				this.annotationBuilder = annotationBuilder;
				this.enumBuilder = enumBuilder;
#endif
			}

			internal override TypeWrapper[] InnerClasses
			{
				get
d7948 1
a7948 2
					// TODO compute the innerclasses lazily (and fix JavaTypeImpl to not always compute them)
					return innerclasses;
d7950 5
a7954 5
			}

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
d7956 9
a7964 2
					// TODO compute lazily (and fix JavaTypeImpl to not always compute it)
					return declaringTypeWrapper;
d7968 1
a7968 1
			internal override Modifiers ReflectiveModifiers
d7970 1
a7970 1
				get
d7972 8
a7979 1
					return reflectiveModifiers;
d7981 1
d7984 1
a7984 1
			internal override Type Type
d7986 1
a7986 1
				get
d7988 3
a7990 77
					return type;
				}
			}

			internal override void EmitRunClassConstructor(CountingILGenerator ilgen)
			{
				if(clinitMethod != null)
				{
					ilgen.Emit(OpCodes.Call, clinitMethod);
				}
			}

			internal override DynamicImpl Finish()
			{
				return this;
			}

			internal override MethodBase LinkMethod(MethodWrapper mw)
			{
				// we should never be called, because all methods on a finished type are already linked
				Debug.Assert(false);
				return mw.GetMethod();
			}

			internal override FieldInfo LinkField(FieldWrapper fw)
			{
				// we should never be called, because all fields on a finished type are already linked
				Debug.Assert(false);
				return fw.GetField();
			}

			internal override string GetGenericSignature()
			{
				return Metadata.GetGenericSignature(metadata);
			}

			internal override string[] GetEnclosingMethod()
			{
				return Metadata.GetEnclosingMethod(metadata);
			}

			internal override string GetGenericMethodSignature(int index)
			{
				return Metadata.GetGenericMethodSignature(metadata, index);
			}

			// note that the caller is responsible for computing the correct index (field index + method count)
			internal override string GetGenericFieldSignature(int index)
			{
				return Metadata.GetGenericFieldSignature(metadata, index);
			}

			internal override object[] GetDeclaredAnnotations()
			{
				return Metadata.GetAnnotations(metadata);
			}

			internal override object GetMethodDefaultValue(int index)
			{
				return Metadata.GetMethodDefaultValue(metadata, index);
			}

			internal override object[] GetMethodAnnotations(int index)
			{
				return Metadata.GetMethodAnnotations(metadata, index);
			}

			internal override object[][] GetParameterAnnotations(int index)
			{
				return Metadata.GetMethodParameterAnnotations(metadata, index);
			}

			internal override object[] GetFieldAnnotations(int index)
			{
				return Metadata.GetFieldAnnotations(metadata, index);
			}

d7992 21
a8012 5
			internal override Annotation Annotation
			{
				get
				{
					return annotationBuilder;
d8016 1
a8016 1
			internal override Type EnumType
d8018 2
a8019 1
				get
d8021 33
a8053 1
					return enumBuilder;
a8055 1
#endif // STATIC_COMPILER
a8333 6
#endif // !STATIC_COMPILER

		internal void RegisterPostFinishProc(System.Threading.ThreadStart proc)
		{
			((JavaTypeImpl)impl).RegisterPostFinishProc(proc);
		}
a8334 1
#if !STATIC_COMPILER
@


1.239
log
@Added optimization to omit callerid nested type inside core library.
@
text
@d3948 3
a3950 1
					if(m.HasCallerID && (m.IsStatic || classFile.IsFinal))
d5564 1
a5564 1
						if((m.Modifiers & Modifiers.VarArgs) != 0 && !m.HasCallerID)
d5618 1
a5618 1
						if(m.HasCallerID)
d7122 1
a7122 1
					if(m.HasCallerID && (m.Modifiers & Modifiers.VarArgs) != 0)
@


1.238
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@d4612 1
a4612 1
				if(typeCallerID != null)
d4614 24
a4637 8
					ConstructorBuilder cb = typeCallerID.DefineConstructor(MethodAttributes.Assembly, CallingConventions.Standard, null);
					ILGenerator ctorIlgen = cb.GetILGenerator();
					ctorIlgen.Emit(OpCodes.Ldarg_0);
					MethodWrapper mw = CoreClasses.ikvm.@@internal.CallerID.Wrapper.GetMethodWrapper("<init>", "()V", false);
					mw.Link();
					mw.EmitCall(ctorIlgen);
					ctorIlgen.Emit(OpCodes.Ret);
					ilGenerator.Emit(OpCodes.Newobj, cb);
d4705 1
a4705 3
						tw.Finish();
						typeCallerID = typeBuilder.DefineNestedType("__<CallerID>", TypeAttributes.Sealed | TypeAttributes.NestedPrivate, tw.TypeAsBaseType);
						callerIDField = typeBuilder.DefineField("__<callerID>", typeCallerID, FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.InitOnly | FieldAttributes.SpecialName);
d5384 1
a5384 1
					if(clinitIndex != -1 || (basehasclinit && !classFile.IsInterface) || classFile.HasInitializedFields || typeCallerID != null)
@


1.237
log
@Restructured code to remove (mcs) compiler warnings.
@
text
@d2938 1
d3836 9
d3904 2
d3947 5
d4610 16
d4682 15
d5191 1
a5191 1
					bool hasclinit = false;
a5198 2
							ILGenerator ilGenerator = ((ConstructorBuilder)mb).GetILGenerator();
							TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
d5201 4
a5204 7
								if(basehasclinit && !classFile.IsInterface)
								{
									hasclinit = true;
									// before we call the base class initializer, we need to set the non-final static ConstantValue fields
									EmitConstantValueInitialization(ilGenerator);
									wrapper.BaseTypeWrapper.EmitRunClassConstructor(ilGenerator);
								}
d5210 2
a5211 22
#if STATIC_COMPILER
							// do we have a native implementation in map.xml?
							if(wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
							{
								continue;
							}
#endif
							LineNumberTableAttribute.LineNumberWriter lineNumberTable = null;
							bool nonLeaf = false;
							Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref nonLeaf, invokespecialstubcache, ref lineNumberTable);
							if(lineNumberTable != null)
							{
#if STATIC_COMPILER
								AttributeHelper.SetLineNumberTable(methods[i].GetMethod(), lineNumberTable);
#else // STATIC_COMPILER
								if(wrapper.lineNumberTables == null)
								{
									wrapper.lineNumberTables = new byte[methods.Length][];
								}
								wrapper.lineNumberTables[i] = lineNumberTable.ToArray();
#endif // STATIC_COMPILER
							}
d5370 41
a5416 28
						// if we don't have a <clinit> we may need to inject one
						if(!hasclinit)
						{
							bool hasconstantfields = false;
							if(!basehasclinit)
							{
								foreach(ClassFile.Field f in classFile.Fields)
								{
									if(f.IsStatic && !f.IsFinal && f.ConstantValue != null)
									{
										hasconstantfields = true;
										break;
									}
								}
							}
							if(basehasclinit || hasconstantfields)
							{
								ConstructorBuilder cb = DefineClassInitializer();
								AttributeHelper.HideFromJava(cb);
								ILGenerator ilGenerator = cb.GetILGenerator();
								EmitConstantValueInitialization(ilGenerator);
								if(basehasclinit)
								{
									wrapper.BaseTypeWrapper.EmitRunClassConstructor(ilGenerator);
								}
								ilGenerator.Emit(OpCodes.Ret);
							}
						}
d5532 1
d5539 1
a5539 1
							string[] parameterNames = new string[methods[i].GetParameters().Length];
d5548 1
a5548 1
						if((m.Modifiers & Modifiers.VarArgs) != 0)
d5601 7
d5658 4
d5715 69
d5796 28
d7053 1
d7106 6
d7518 2
d8551 2
a8552 1
						GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes);
d8575 2
a8576 1
				GetNameSigFromMethodBase(mb, out name, out sig, out retType, out paramTypes);
d8967 1
a8967 1
		private void GetNameSigFromMethodBase(MethodBase method, out string name, out string sig, out TypeWrapper retType, out TypeWrapper[] paramTypes)
d8971 11
a8981 2
			paramTypes = new TypeWrapper[parameters.Length];
			for(int i = 0; i < parameters.Length; i++)
a9057 1
							GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes);
d9061 1
d9182 1
a9182 1
#if !STATIC_COMPILER
d9184 1
a9184 1
			internal override object Invoke(object obj, object[] args, bool nonVirtual)
d9211 1
a9211 1
				return InvokeImpl(mb, obj, args, nonVirtual);
d9923 8
a9930 8
#if !STATIC_COMPILER
				internal override object Invoke(object obj, object[] args, bool nonVirtual)
				{
					return TypeWrapper.FromClass(NativeCode.ikvm.runtime.Util.getClassFromObject(obj))
						.GetMethodWrapper(this.Name, this.Signature, true)
						.Invoke(obj, args, false);
				}
#endif // !STATIC_COMPILER
d10012 2
a10013 2
#if !STATIC_COMPILER
				internal override object Invoke(object obj, object[] args, bool nonVirtual)
d10023 1
a10023 1
#endif // !STATIC_COMPILER
d10042 1
a10042 1
				internal override object Invoke(object obj, object[] args, bool nonVirtual)
d11116 1
a11116 1
#if !STATIC_COMPILER
d11118 1
a11118 1
			internal override object Invoke(object obj, object[] args, bool nonVirtual)
d11123 1
a11123 1
#endif // !STATIC_COMPILER
d11193 1
a11193 1
#if !STATIC_COMPILER
d11195 1
a11195 1
			internal override object Invoke(object obj, object[] args, bool nonVirtual)
d11207 1
a11207 1
					return base.Invoke(obj, newargs, nonVirtual);
d11220 1
a11220 1
#endif // !STATIC_COMPILER
d11244 1
a11244 1
#if !STATIC_COMPILER
d11246 1
a11246 1
			internal override object Invoke(object obj, object[] args, bool nonVirtual)
d11250 1
a11250 1
#endif // !STATIC_COMPILER
d11351 1
a11351 1
#if !STATIC_COMPILER
d11353 1
a11353 1
			internal override object Invoke(object obj, object[] args, bool nonVirtual)
d11361 1
a11361 1
#endif // !STATIC_COMPILER
d11381 2
a11382 2
#if !STATIC_COMPILER
			internal override object Invoke(object obj, object[] args, bool nonVirtual)
d11386 1
a11386 1
#endif // !STATIC_COMPILER
d11416 2
a11417 2
#if !STATIC_COMPILER
			internal override object Invoke(object obj, object[] args, bool nonVirtual)
d11419 1
a11419 1
				return CoreClasses.java.lang.Object.Wrapper.GetMethodWrapper(Name, Signature, false).Invoke(obj, args, nonVirtual);
d11421 1
a11421 1
#endif // !STATIC_COMPILER
d11681 1
a11681 1
#if !STATIC_COMPILER
d11683 1
a11683 1
			internal override object Invoke(object obj, object[] args, bool nonVirtual)
d11685 1
a11685 1
				return m.Invoke(obj, args, nonVirtual);
d11687 1
a11687 1
#endif // !STATIC_COMPILER
@


1.236
log
@Added workarounds for mcs compiler bug (related to the mutual dependency of the runtime and class library assemblies).
@
text
@d149 4
a157 1
		private static Type typeofModifiers = JVM.LoadType(typeof(Modifiers));
a160 3
		private static Type typeofSourceFileAttribute = JVM.LoadType(typeof(SourceFileAttribute));
		private static Type typeofLineNumberTableAttribute = JVM.LoadType(typeof(LineNumberTableAttribute));
		private static Type typeofEnclosingMethodAttribute = JVM.LoadType(typeof(EnclosingMethodAttribute));
a1369 1
				List<string> list = new List<string>();
a4257 11
					string sourceFile = null;
					if(wrapper.classLoader.EmitStackTraceInfo)
					{
						if(f.SourceFileAttribute != null)
						{
							if(f.SourceFileAttribute != typeBuilder.Name + ".java")
							{
								sourceFile = f.SourceFileAttribute;
							}
						}
					}
a4277 9
					string enclosingMethodClass = null;
					string enclosingMethodName = null;
					string enclosingMethodSig = null;
					if(classFile.EnclosingMethod != null)
					{
						enclosingMethodClass = classFile.EnclosingMethod[0];
						enclosingMethodName = classFile.EnclosingMethod[1];
						enclosingMethodSig = classFile.EnclosingMethod[2];
					}
d4377 1
a4394 1
#if STATIC_COMPILER
a4447 1
#endif // STATIC_COMPILER
d4460 1
d4525 1
d4575 1
d5801 1
d5803 1
d5824 1
a5872 1
#if STATIC_COMPILER
d8146 1
d8159 1
d8958 1
d8960 1
d8967 1
d8969 1
d10963 1
d10965 1
d10972 1
d10974 1
@


1.235
log
@- added more efficient float/double to/from int/long bits converters
- made Double.doubleToRawLongBits/longBitsToDouble and Float.floatToRawIntBits/intBitsToFloat intrinsics
- generalized the intrinsics support
@
text
@d2050 1
a2050 1
						clazz.typeWrapper = this;
d2061 6
d2072 2
a2073 1
			return ((java.lang.Class)classObject).typeWrapper;
@


1.234
log
@Forgot to cast result from GetClassFromTypeHandle to java.lang.Class.
@
text
@d4002 1
a4002 1
#if STATIC_COMPILER
d4007 1
a4007 1
						&& (!wrapper.classLoader.StrictFinalFieldSemantics || ReferenceEquals(wrapper.Name, StringConstants.JAVA_LANG_SYSTEM)))
@


1.233
log
@Added hack to support instantiating fake enums for types loaded in ReflectionOnly (to support custom attribute annotations that have enum values in ikvmstub).
@
text
@d9825 1
@


1.232
log
@Take advantage of the fact that we now have a real type to refer to, instead of doing the class lookup by name.
@
text
@d9782 14
d9899 1
a9899 1
				foreach(FieldInfo field in fakeType.GetGenericArguments()[0].GetFields(BindingFlags.Static | BindingFlags.Public))
@


1.231
log
@Moved "fake" type handling to the proper place.
@
text
@d9809 2
a9810 2
					ilgen.Emit(OpCodes.Ldstr, this.DeclaringType.Name);
					CoreClasses.java.lang.Class.Wrapper.GetMethodWrapper("forName", "(Ljava.lang.String;)Ljava.lang.Class;", false).EmitCall(ilgen);
@


1.230
log
@Fixed name mangling bug. Dots in nested type names should be mangled, because they shouldn't affect the package name.
@
text
@d8497 1
a8513 25
			if(type.IsGenericType)
			{
				string suffix;
				switch (type.GetGenericTypeDefinition().FullName)
				{
					case DotNetTypeWrapper.GenericEnumEnumTypeName:
						suffix = DotNetTypeWrapper.EnumEnumSuffix;
						break;
					case DotNetTypeWrapper.GenericDelegateInterfaceTypeName:
						suffix = DotNetTypeWrapper.DelegateInterfaceSuffix;
						break;
					case DotNetTypeWrapper.GenericAttributeAnnotationTypeName:
						suffix = DotNetTypeWrapper.AttributeAnnotationSuffix;
						break;
					case DotNetTypeWrapper.GenericAttributeAnnotationReturnValueTypeName:
						suffix = DotNetTypeWrapper.AttributeAnnotationReturnValueSuffix;
						break;
					case DotNetTypeWrapper.GenericAttributeAnnotationMultipleTypeName:
						suffix = DotNetTypeWrapper.AttributeAnnotationMultipleSuffix;
						break;
					default:
						throw new InvalidOperationException();
				}
				return ClassLoaderWrapper.GetWrapperFromType(type.GetGenericArguments()[0]).Name + suffix;
			}
@


1.229
log
@Added support for turning Java fields into .NET properties with an annotation.
@
text
@d9579 1
d9585 1
d9589 1
a9589 1
					|| (c == '.' && !escape))
@


1.228
log
@Restored the special case for interface .cctor methods to fix bug #1930303
@
text
@d824 29
d1045 14
d1983 1
d3998 4
d4753 5
d5594 9
a5602 1
										annotation.Apply(wrapper.GetClassLoader(), (FieldBuilder)fields[i].GetField(), def);
d6330 9
d6833 53
d6984 1
a6984 1
					if(m.IsPrivate)
d6986 3
a6988 9
						attribs |= MethodAttributes.Private;
					}
					else if(m.IsProtected)
					{
						attribs |= MethodAttributes.FamORAssem;
					}
					else if(m.IsPublic)
					{
						attribs |= MethodAttributes.Public;
d6992 16
a7007 1
						attribs |= MethodAttributes.Assembly;
d8966 11
a8976 1
									fields.Add(CreateFieldWrapper(property));
d9307 10
d9370 6
d10422 4
d10572 9
d10850 5
@


1.227
log
@Made __Fields nested class abstract (it was already sealed) and removed the constructor.
@
text
@d6612 9
@


1.226
log
@Restructured code to remove compiler warnings.
@
text
@d5415 1
a5415 2
						tbFields = typeBuilder.DefineNestedType("__Fields", TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed);
						tbFields.DefineDefaultConstructor(MethodAttributes.Private);
@


1.225
log
@Use custom modifiers to make sure constructor signature is unique (if necessary).
@
text
@d767 15
a782 2
			if(JVM.IsStaticCompiler || field.DeclaringType.Assembly.ReflectionOnly)
			{
d790 1
a792 9
#endif
			// In Java, instance fields can also have a ConstantValue attribute so we emulate that
			// with ConstantValueAttribute (for consumption by ikvmstub only)
			object[] attrib = field.GetCustomAttributes(typeof(ConstantValueAttribute), false);
			if(attrib.Length == 1)
			{
				return ((ConstantValueAttribute)attrib[0]).GetConstantValue();
			}
			return null;
d797 9
a806 2
			if(JVM.IsStaticCompiler || type.Assembly.ReflectionOnly)
			{
d819 1
a821 3
#endif
			object[] attr = type.GetCustomAttributes(typeof(ModifiersAttribute), false);
			return attr.Length == 1 ? (ModifiersAttribute)attr[0] : null;
d826 13
a839 2
			if(JVM.IsStaticCompiler || mb.DeclaringType.Assembly.ReflectionOnly)
			{
a851 2
			}
			else
a852 7
			{
				object[] customAttribute = mb.GetCustomAttributes(typeof(ModifiersAttribute), false);
				if(customAttribute.Length == 1)
				{
					ModifiersAttribute mod = (ModifiersAttribute)customAttribute[0];
					return new ExModifiers(mod.Modifiers, mod.IsInternal);
				}
d909 13
a922 2
			if(JVM.IsStaticCompiler || fi.DeclaringType.Assembly.ReflectionOnly)
			{
a934 2
			}
			else
a935 7
			{
				object[] customAttribute = fi.GetCustomAttributes(typeof(ModifiersAttribute), false);
				if(customAttribute.Length == 1)
				{
					ModifiersAttribute mod = (ModifiersAttribute)customAttribute[0];
					return new ExModifiers(mod.Modifiers, mod.IsInternal);
				}
d1174 9
a1183 2
			if(JVM.IsStaticCompiler || field.DeclaringType.Assembly.ReflectionOnly)
			{
d1192 1
a1194 3
#endif
			object[] attr = field.GetCustomAttributes(typeof(NameSigAttribute), false);
			return attr.Length == 1 ? (NameSigAttribute)attr[0] : null;
d1199 9
a1208 2
			if(JVM.IsStaticCompiler || method.DeclaringType.Assembly.ReflectionOnly)
			{
d1217 1
a1219 3
#endif
			object[] attr = method.GetCustomAttributes(typeof(NameSigAttribute), false);
			return attr.Length == 1 ? (NameSigAttribute)attr[0] : null;
d1237 9
a1246 2
			if(JVM.IsStaticCompiler || type.Assembly.ReflectionOnly)
			{
d1255 1
a1257 3
#endif
			object[] attribs = type.GetCustomAttributes(typeof(ImplementsAttribute), false);
			return attribs.Length == 1 ? (ImplementsAttribute)attribs[0] : null;
d1262 9
a1271 2
			if(JVM.IsStaticCompiler || mb.DeclaringType.Assembly.ReflectionOnly)
			{
d1280 1
a1282 3
#endif
			object[] attribs = mb.GetCustomAttributes(typeof(ThrowsAttribute), false);
			return attribs.Length == 1 ? (ThrowsAttribute)attribs[0] : null;
d1287 13
a1299 2
#if !COMPACT_FRAMEWORK
			if(JVM.IsStaticCompiler || t.Assembly.ReflectionOnly)
d1302 1
d1311 1
a1313 8
#endif
			object[] attribs = t.GetCustomAttributes(typeof(NonNestedInnerClassAttribute), false);
			string[] classes = new string[attribs.Length];
			for(int i = 0; i < attribs.Length; i++)
			{
				classes[i] = ((NonNestedInnerClassAttribute)attribs[i]).InnerClassName;
			}
			return classes;
d1318 8
a1325 2
#if !COMPACT_FRAMEWORK
			if(JVM.IsStaticCompiler || t.Assembly.ReflectionOnly)
d1328 1
d1337 1
a1339 3
#endif
			object[] attribs = t.GetCustomAttributes(typeof(NonNestedOuterClassAttribute), false);
			return attribs.Length == 1 ? ((NonNestedOuterClassAttribute)attribs[0]).OuterClassName : null;
d1344 9
a1353 2
			if(JVM.IsStaticCompiler || mb.DeclaringType.Assembly.ReflectionOnly)
			{
d1362 1
a1364 3
#endif
			object[] attribs = mb.GetCustomAttributes(typeof(SignatureAttribute), false);
			return attribs.Length == 1 ? (SignatureAttribute)attribs[0] : null;
d1369 9
a1378 2
			if(JVM.IsStaticCompiler || type.Assembly.ReflectionOnly)
			{
d1387 1
a1389 5
#endif
			object[] attribs = type.GetCustomAttributes(typeof(SignatureAttribute), false);
			// HACK for the time being we have to support having two signature attributes
			// (because of the hack in map.xml to make japi happy on the non-generics branch)
			return attribs.Length >= 1 ? (SignatureAttribute)attribs[0] : null;
d1394 9
a1403 2
			if(JVM.IsStaticCompiler || fi.DeclaringType.Assembly.ReflectionOnly)
			{
d1412 1
a1414 3
#endif
			object[] attribs = fi.GetCustomAttributes(typeof(SignatureAttribute), false);
			return attribs.Length == 1 ? (SignatureAttribute)attribs[0] : null;
d1419 9
a1428 2
			if(JVM.IsStaticCompiler || type.Assembly.ReflectionOnly)
			{
d1437 1
a1439 3
#endif
			object[] attribs = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
			return attribs.Length == 1 ? (InnerClassAttribute)attribs[0] : null;
d1444 10
a1453 2
#if !COMPACT_FRAMEWORK
			if(JVM.IsStaticCompiler || type.Assembly.ReflectionOnly)
d1456 4
a1459 1
					foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(type))
d1461 2
a1462 5
						if(MatchTypes(cad.Constructor.DeclaringType, typeofRemappedInterfaceMethodAttribute))
						{
							IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
							attrs.Add(new RemappedInterfaceMethodAttribute((string)args[0].Value, (string)args[1].Value));
						}
d1464 2
a1467 5
#endif
			object[] attr = type.GetCustomAttributes(typeof(RemappedInterfaceMethodAttribute), false);
			RemappedInterfaceMethodAttribute[] attr1 = new RemappedInterfaceMethodAttribute[attr.Length];
			Array.Copy(attr, attr1, attr.Length);
			return attr1;
d1472 9
a1481 2
			if(JVM.IsStaticCompiler || type.Assembly.ReflectionOnly)
			{
d1490 1
a1492 3
#endif
			object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
			return attribs.Length == 1 ? (RemappedTypeAttribute)attribs[0] : null;
d1497 10
a1506 2
#if !COMPACT_FRAMEWORK
			if(JVM.IsStaticCompiler || coreAssembly.ReflectionOnly)
d1509 4
a1512 1
					foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(coreAssembly))
d1514 2
a1515 5
						if(MatchTypes(cad.Constructor.DeclaringType, typeofRemappedClassAttribute))
						{
							IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
							attrs.Add(new RemappedClassAttribute((string)args[0].Value, (Type)args[1].Value));
						}
d1517 2
a1520 5
#endif
			object[] attr = coreAssembly.GetCustomAttributes(typeof(RemappedClassAttribute), false);
			RemappedClassAttribute[] attr1 = new RemappedClassAttribute[attr.Length];
			Array.Copy(attr, attr1, attr.Length);
			return attr1;
d1525 13
a1538 2
			if(JVM.IsStaticCompiler || type.Assembly.ReflectionOnly)
			{
d1546 1
a1548 7
#endif
			object[] attr = type.GetCustomAttributes(typeof(AnnotationAttributeAttribute), false);
			if(attr.Length == 1)
			{
				return ((AnnotationAttributeAttribute)attr[0]).AttributeType;
			}
			return null;
d1573 8
a1581 2
			if(JVM.IsStaticCompiler || mod.Assembly.ReflectionOnly)
			{
d1590 1
a1592 2
#endif
			return mod.IsDefined(attribute, false);
d1597 8
a1605 2
			if(JVM.IsStaticCompiler || asm.ReflectionOnly)
			{
d1613 1
a1615 2
#endif
			return asm.IsDefined(attribute, false);
d1620 8
a1628 2
			if(JVM.IsStaticCompiler || type.Assembly.ReflectionOnly)
			{
d1637 1
a1639 2
#endif
			return type.IsDefined(attribute, false);
d1644 8
a1652 2
			if(JVM.IsStaticCompiler || pi.Member.DeclaringType.Assembly.ReflectionOnly)
			{
d1661 1
a1663 2
#endif
			return pi.IsDefined(attribute, false);
d1668 8
a1676 2
			if(JVM.IsStaticCompiler || member.DeclaringType.Assembly.ReflectionOnly)
			{
d1685 1
a1687 2
#endif
			return member.IsDefined(attribute, false);
d1697 7
a1703 2
#if !COMPACT_FRAMEWORK
			if(JVM.IsStaticCompiler || mod.Assembly.ReflectionOnly)
d1706 1
d1722 1
a1724 2
#endif
			return mod.GetCustomAttributes(typeofJavaModuleAttribute, false);
@


1.224
log
@Replaced notion of DynamicOnly types with Fake types. Fake types are implemented as generic type instances and can have DynamicOnly methods.
@
text
@d2156 8
d2169 1
a2169 1
				return erased || (!IsPrimitive && IsJavaPrimitive(TypeAsSignatureType)) || (IsRemapped && this is DotNetTypeWrapper);
d6759 1
d6762 27
a6788 1
							// TODO we might have to mangle the signature to make it unique
d6795 1
a6795 1
						method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, methods[index].GetParametersForDefineMethod());
@


1.223
log
@Hide ikvmc generated GetEnumerator() method from Java.
@
text
@d2037 8
d2160 1
a2160 1
				bool erased = IsUnloadable || IsGhostArray || IsDynamicOnly;
a2164 17
		internal virtual bool IsDynamicOnly
		{
			get
			{
				return false;
			}
		}

		// is this an array type of which the ultimate element type is dynamic-only?
		internal bool IsDynamicOnlyArray
		{
			get
			{
				return IsArray && (ElementTypeWrapper.IsDynamicOnly || ElementTypeWrapper.IsDynamicOnlyArray);
			}
		}

a2720 14
				if(thisWrapper.IsDynamicOnlyArray)
				{
					TypeWrapper elementType = thisWrapper;
					while(elementType.IsArray)
					{
						elementType = elementType.ElementTypeWrapper;
					}
					elementType = elementType.BaseTypeWrapper;
					if(elementType == null)
					{
						elementType = CoreClasses.java.lang.Object.Wrapper;
					}
					thisWrapper = elementType.MakeArrayType(thisWrapper.ArrayRank);
				}
d2869 1
a2869 1
			if(doneSet.ContainsKey(this) || this.IsDynamicOnly)
d2876 1
a2876 1
				if(!method.IsStatic)
a3010 6
			else if(IsDynamicOnly)
			{
				ilgen.Emit(OpCodes.Ldtoken, context.TypeAsTBD);
				ilgen.Emit(OpCodes.Ldstr, this.Name);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicCast);
			}
a3040 6
			else if(IsDynamicOnly)
			{
				ilgen.Emit(OpCodes.Ldtoken, context.TypeAsTBD);
				ilgen.Emit(OpCodes.Ldstr, this.Name);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicInstanceOf);
			}
d5518 3
a5520 3
						// skip interfaces that don't really exist
						// (e.g. delegate "Method" and attribute "Annotation" inner interfaces)
						if (!iface.IsDynamicOnly)
d5522 1
a5522 7
							// NOTE we're using TypeAsBaseType for the interfaces!
							Type ifaceType = iface.TypeAsBaseType;
							if(!iface.IsPublic && !ifaceType.Assembly.Equals(typeBuilder.Assembly))
							{
								ifaceType = ifaceType.Assembly.GetType(DynamicClassLoader.GetProxyHelperName(ifaceType));
							}
							typeBuilder.AddInterfaceImplementation(ifaceType);
d5524 1
d6659 1
a6659 1
							if(!baseMethods[index].DeclaringType.IsDynamicOnly && name != baseMethods[index].RealName)
d8226 25
d9124 5
d9368 1
a9368 1
			private Type delegateType;
d9373 5
a9377 1
				this.delegateType = delegateType;
a9393 8
			internal override bool IsDynamicOnly
			{
				get
				{
					return true;
				}
			}

d9398 1
a9398 1
					return ClassLoaderWrapper.GetWrapperFromType(delegateType);
d9451 1
a9451 9
					return typeof(object);
				}
			}

			internal override Type TypeAsBaseType
			{
				get
				{
					throw new InvalidOperationException();
d9463 8
d9483 1
a9483 1
			private Type enumType;
d9488 5
a9492 1
				this.enumType = enumType;
a9498 2
				private static ConstructorInfo enumEnumConstructor;
				private static FieldInfo enumEnumTypeField;
d9508 1
a9508 1
					lock(this)
d9510 1
a9510 14
						if(val == null)
						{
							if(enumEnumConstructor == null)
							{
								enumEnumConstructor = JVM.CoreAssembly.GetType("ikvm.internal.EnumEnum").GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[] { typeof(string), typeof(int) }, null);
							}
							object obj = enumEnumConstructor.Invoke(new object[] { this.Name, ordinal });
							if(enumEnumTypeField == null)
							{
								enumEnumTypeField = enumEnumConstructor.DeclaringType.GetField("typeWrapper", BindingFlags.NonPublic | BindingFlags.Instance);
							}
							enumEnumTypeField.SetValue(obj, this.DeclaringType);
							val = obj;
						}
d9517 1
d9522 1
d9537 8
d9566 8
d9594 1
a9594 1
				foreach(FieldInfo field in enumType.GetFields(BindingFlags.Static | BindingFlags.Public))
d9612 1
a9612 1
					return ClassLoaderWrapper.GetWrapperFromType(enumType);
a9660 8
			internal override bool IsDynamicOnly
			{
				get
				{
					return true;
				}
			}

d9665 1
a9665 10
					// return java.lang.Enum instead
					return BaseTypeWrapper.TypeAsTBD;
				}
			}

			internal override Type TypeAsBaseType
			{
				get
				{
					throw new InvalidOperationException();
a9712 24

			internal sealed override bool IsDynamicOnly
			{
				get
				{
					return true;
				}
			}

			internal sealed override Type TypeAsTBD
			{
				get
				{
					return typeof(object);
				}
			}

			internal sealed override Type TypeAsBaseType
			{
				get
				{
					throw new InvalidOperationException();
				}
			}
d9717 2
a9718 1
			private Type attributeType;
d9724 5
d9973 8
d9983 2
a9984 1
				private AttributeAnnotationTypeWrapper declaringType;
d9989 5
d10024 8
d10123 2
a10124 1
				private AttributeAnnotationTypeWrapper declaringType;
d10129 5
d10160 8
d10292 8
d11423 8
@


1.222
log
@- Reintroduced guard against recursive FinishCore invocations.
- Implemented support for annotations on .NET fields/methods/parameters.
@
text
@d5580 1
@


1.221
log
@Fixed regression in return value annotation value.
@
text
@d3755 1
d4912 5
d11608 11
a11618 2
			// TODO on Whidbey this must be implemented
			return null;
d11623 11
a11633 2
			// TODO on Whidbey this must be implemented
			return null;
d11638 17
a11654 2
			// TODO on Whidbey this must be implemented
			return null;
@


1.220
log
@Construct custom attribute annotation proxies directly instead of going through the trouble to encode/decode them.
@
text
@d10049 1
a10049 1
					targetMap.put("value", java.lang.annotation.ElementType.METHOD);
@


1.219
log
@- Don't instantiate DotNetTypeWrapper before knowing it's the right one.
- Reuse name instead of recomputing it in the DotNetTypeWrapper constructor.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d10045 1
a10045 1
#if !STATIC_COMPILER
d10048 4
d10053 3
a10055 5
										JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Target", "value", 
											new object[] { AnnotationDefaultAttribute.TAG_ARRAY, new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "METHOD" } }
										}),
										JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Retention", "value", new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/RetentionPolicy;", "RUNTIME" } })
									};
d10323 1
a10323 1
#if !STATIC_COMPILER
d10328 2
a10329 3
				ArrayList targets = new ArrayList();
				targets.Add(AnnotationDefaultAttribute.TAG_ARRAY);
				if((validOn & (AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Delegate | AttributeTargets.Assembly)) != 0)
d10331 1
a10331 1
					targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "TYPE" });
d10333 1
a10333 1
				if((validOn & AttributeTargets.Constructor) != 0)
d10335 1
a10335 1
					targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "CONSTRUCTOR" });
d10337 1
a10337 1
				if((validOn & AttributeTargets.Field) != 0)
d10339 1
a10339 1
					targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "FIELD" });
d10341 1
a10341 1
				if((validOn & AttributeTargets.Method) != 0)
d10343 1
a10343 1
					targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "METHOD" });
d10345 1
a10345 1
				if((validOn & AttributeTargets.Parameter) != 0)
d10347 1
a10347 1
					targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "PARAMETER" });
d10349 4
d10354 3
a10356 3
										JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Target", "value", (object[])targets.ToArray() }),
										JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Retention", "value", new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/RetentionPolicy;", "RUNTIME" } })
									};
@


1.218
log
@Reintroduced baked TypeBuilder scrubbing hack for .NET 2.0 SP1.
@
text
@d10554 2
a10555 2
		internal DotNetTypeWrapper(Type type)
			: base(GetModifiers(type), GetName(type), GetBaseTypeWrapper(type))
@


1.217
log
@- Use assembly qualified type names in annotation parameters when referencing a class.
- Renamed GetEnumerator method in implicit IEnumerable implementation to work around lame bug in Xml serialization.
@
text
@d3416 100
d5509 1
@


1.216
log
@Fixed JNI regression in ikvmc.
@
text
@d1737 85
d5471 2
a5472 1
										MethodBuilder mb = typeBuilder.DefineMethod("__<>GetEnumerator", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, typeof(IEnumerator), Type.EmptyTypes);
d6033 1
d6042 1
d6051 1
d6060 1
d6069 1
d6078 1
d8937 1
d8943 1
d8949 1
d8955 1
d8961 1
d8967 1
@


1.215
log
@Indirectly refer to JNI assembly.
@
text
@d6049 1
a6049 1
				private static readonly Type localRefStructType = StaticCompiler.GetType("IKVM.Runtime.JNI.Frame");
@


1.214
log
@Added support for registering a delegate that gets called after the type is baked.
@
text
@d9158 1
a9158 1
			if(type.Assembly == typeof(IKVM.Runtime.JNI).Assembly)
@


1.213
log
@Generic type instances can't be inner classes.
@
text
@d3575 1
d5290 7
d5342 12
d7722 5
@


1.212
log
@- Changed <clinit> method to SmartConstructorMethodWrapper to support calling it in map.xml
- Removed call to unnecessary call to MatchTypes (to support partial trust)
@
text
@d11192 1
a11192 1
					if(outer != null)
@


1.211
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@d1474 1
a1474 1
				if(MatchTypes(cad.Constructor.DeclaringType, typeof(System.Runtime.CompilerServices.InternalsVisibleToAttribute)))
d3617 1
a3617 1
					else if(ReferenceEquals(m.Name, StringConstants.INIT))
@


1.210
log
@Moved JNI implementation into a separate assembly (IKVM.Runtime.JNI.dll) to make IKVM.Runtime.dll verifiable.
@
text
@d1806 6
d1813 1
d1822 5
d1828 1
d3068 1
a3068 1
					return JVM.Library.newAnnotationElementValue(mw.DeclaringType.GetClassLoader().GetJavaClassLoader(), mw.ReturnType.ClassObject, ((AnnotationDefaultAttribute)attr[0]).Value);
d7732 1
a7732 1
					objs[i] = JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[i]);
d7752 1
a7752 1
							objs[j] = JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[j]);
d7779 1
a7779 1
								objs[j][k] = JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[j][k]);
d7804 1
a7804 1
							objs[j] = JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[j]);
d7825 1
a7825 1
						return JVM.Library.newAnnotationElementValue(mw.DeclaringType.GetClassLoader().GetJavaClassLoader(), mw.ReturnType.ClassObject, defVal);
d9128 1
a9132 1
#if !FIRST_PASS && !STATIC_COMPILER
d9825 1
a9825 1
										JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Target", "value", 
d9828 1
a9828 1
										JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Retention", "value", new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/RetentionPolicy;", "RUNTIME" } })
d10125 2
a10126 2
										JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Target", "value", (object[])targets.ToArray() }),
										JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Retention", "value", new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/RetentionPolicy;", "RUNTIME" } })
@


1.209
log
@Implemented support for InternalsVisibleToAttribute.
@
text
@d6017 2
d9119 6
@


1.208
log
@Removed mono workarounds.
@
text
@d1469 20
d2322 2
a2323 2
				|| (IsInternal && GetClassLoader() == wrapper.GetClassLoader())
				|| IsInSamePackageAs(wrapper);
d2326 1
a2326 1
		internal bool IsInSamePackageAs(TypeWrapper wrapper)
d2328 1
a2328 1
			if(GetClassLoader() == wrapper.GetClassLoader())
d4776 1
a4776 1
										while(fmw != mw && (fmw.IsStatic || fmw.IsPrivate || !fmw.DeclaringType.IsInSamePackageAs(mw.DeclaringType)))
d6322 1
a6322 1
						&& (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.DeclaringType.IsInSamePackageAs(wrapper)))
d6347 2
a6348 2
						if(baseMethod.DeclaringType.IsInSamePackageAs(wrapper)
							|| (baseMethod.IsInternal && baseMethod.DeclaringType.GetClassLoader() == wrapper.GetClassLoader()))
d6661 1
a6661 1
									(!m.IsPublic && !m.IsProtected && !baseMce.DeclaringType.IsInSamePackageAs(wrapper)))
d6759 1
a6759 1
							if(!m.IsStatic && !m.IsAbstract && !m.IsPrivate && baseMce != null && !baseMce.DeclaringType.IsInSamePackageAs(wrapper))
d6770 1
a6770 1
									if(bmw.DeclaringType.IsInSamePackageAs(wrapper) && bmw.IsAbstract && !(bmw.IsPublic || bmw.IsProtected))
@


1.207
log
@Workaround the fact that Mono doesn't currently implement FieldInfo.GetRawConstantValue().
@
text
@d10694 1
a10694 11
						object rawval;
						try
						{
							rawval = fields[i].GetRawConstantValue();
						}
						catch(NotSupportedException)
						{
							// MONOBUG GetRawConstantValue() is not implemented on Mono 1.2.6
							rawval = fields[i].GetValue(null);
						}
						object val = EnumValueFieldWrapper.GetEnumPrimitiveValue(underlyingType, rawval);
@


1.206
log
@Removed more .NET 1.1 workarounds.
@
text
@d10694 11
a10704 1
						object val = EnumValueFieldWrapper.GetEnumPrimitiveValue(underlyingType, fields[i].GetRawConstantValue());
@


1.205
log
@More .NET 1.1 -> 2.0 work.
@
text
@a6277 6
				if(typeBuilder.IsInterface)
				{
					// LAMESPEC the ECMA spec says (part. I, sect. 8.5.3.2) that all interface members must be public, so we make
					// the class constructor public
					return typeBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
				}
@


1.204
log
@More .NET 1.1 -> 2.0 work.
@
text
@d3977 1
a3977 1
					if(!classFile.IsInterface && hasclinit)
@


1.203
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@a3297 98
	class BakedTypeCleanupHack
	{
		private static readonly FieldInfo m_methodBuilder = typeof(ConstructorBuilder).GetField("m_methodBuilder", BindingFlags.Instance | BindingFlags.NonPublic);
		private static readonly FieldInfo[] methodBuilderFields = GetFieldList(typeof(MethodBuilder), new string[]
			{
				"m_ilGenerator",
				"m_ubBody",
				"m_RVAFixups",
				"mm_mdMethodFixups",
				"m_localSignature",
				"m_localSymInfo",
				"m_exceptions",
				"m_parameterTypes",
				"m_retParam",
				"m_returnType",
				"m_signature"
			});
		private static readonly FieldInfo[] fieldBuilderFields = GetFieldList(typeof(FieldBuilder), new string[]
			{
				"m_data",
				"m_fieldType",
		});

		private static bool IsSupportedVersion
		{
			get
			{
				return Environment.Version.Major == 1 && Environment.Version.Minor == 1 && Environment.Version.Build == 4322;
			}
		}

		private static FieldInfo[] GetFieldList(Type type, string[] list)
		{
			if(JVM.SafeGetEnvironmentVariable("IKVM_DISABLE_TYPEBUILDER_HACK") != null || !IsSupportedVersion)
			{
				return null;
			}
			if(!SecurityManager.IsGranted(new SecurityPermission(SecurityPermissionFlag.Assertion)) ||
				!SecurityManager.IsGranted(new ReflectionPermission(ReflectionPermissionFlag.MemberAccess)))
			{
				return null;
			}
			FieldInfo[] fields = new FieldInfo[list.Length];
			for(int i = 0; i < list.Length; i++)
			{
				fields[i] = type.GetField(list[i], BindingFlags.Instance | BindingFlags.NonPublic);
				if(fields[i] == null)
				{
					return null;
				}
			}
			return fields;
		}

		internal static void Process(DynamicTypeWrapper wrapper)
		{
			if(m_methodBuilder != null && methodBuilderFields != null && fieldBuilderFields != null)
			{
				foreach(MethodWrapper mw in wrapper.GetMethods())
				{
					MethodBuilder mb = mw.GetMethod() as MethodBuilder;
					if(mb == null)
					{
						ConstructorBuilder cb = mw.GetMethod() as ConstructorBuilder;
						if(cb != null)
						{
							new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
							mb = (MethodBuilder)m_methodBuilder.GetValue(cb);
							CodeAccessPermission.RevertAssert();
						}
					}
					if(mb != null)
					{
						new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
						foreach(FieldInfo fi in methodBuilderFields)
						{
							fi.SetValue(mb, null);
						}
						CodeAccessPermission.RevertAssert();
					}
				}
				foreach(FieldWrapper fw in wrapper.GetFields())
				{
					FieldBuilder fb = fw.GetField() as FieldBuilder;
					if(fb != null)
					{
						new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
						foreach(FieldInfo fi in fieldBuilderFields)
						{
							fi.SetValue(fb, null);
						}
						CodeAccessPermission.RevertAssert();
					}
				}
			}
		}
	}

a5282 1
					BakedTypeCleanupHack.Process(wrapper);
a8870 109
	sealed class Whidbey
	{
		private static readonly object[] noargs = new object[0];
		private static readonly MethodInfo get_IsGenericTypeDefinition = typeof(Type).GetMethod("get_IsGenericTypeDefinition");
		private static readonly MethodInfo get_ContainsGenericParameters = typeof(Type).GetMethod("get_ContainsGenericParameters");
		private static readonly MethodInfo get_IsGenericMethodDefinition = typeof(MethodBase).GetMethod("get_IsGenericMethodDefinition");
		private static readonly MethodInfo get_IsGenericType = typeof(Type).GetMethod("get_IsGenericType");
		private static readonly MethodInfo get_ReflectionOnly = typeof(Assembly).GetMethod("get_ReflectionOnly");
		private static readonly MethodInfo method_GetGenericTypeDefinition = typeof(Type).GetMethod("GetGenericTypeDefinition");
		private static readonly MethodInfo method_GetGenericArguments = typeof(Type).GetMethod("GetGenericArguments");
		private static readonly MethodInfo method_MakeGenericType = typeof(Type).GetMethod("MakeGenericType");

		internal static bool IsGenericTypeDefinition(Type type)
		{
			try
			{
				return get_IsGenericTypeDefinition != null && (bool)get_IsGenericTypeDefinition.Invoke(type, noargs);
			}
			catch(TargetInvocationException x)
			{
				throw x.InnerException;
			}
		}

		internal static bool ContainsGenericParameters(Type type)
		{
			try
			{
				return get_ContainsGenericParameters != null && (bool)get_ContainsGenericParameters.Invoke(type, noargs);
			}
			catch(TargetInvocationException x)
			{
				throw x.InnerException;
			}
		}

		internal static bool IsGenericMethodDefinition(MethodBase mb)
		{
			try
			{
				return get_IsGenericMethodDefinition != null && (bool)get_IsGenericMethodDefinition.Invoke(mb, noargs);
			}
			catch(TargetInvocationException x)
			{
				throw x.InnerException;
			}
		}

		internal static bool IsGenericType(Type type)
		{
			try
			{
				return get_IsGenericType != null && (bool)get_IsGenericType.Invoke(type, noargs);
			}
			catch(TargetInvocationException x)
			{
				throw x.InnerException;
			}
		}

		internal static Type GetGenericTypeDefinition(Type type)
		{
			try
			{
				return method_GetGenericTypeDefinition == null ? null : (Type)method_GetGenericTypeDefinition.Invoke(type, noargs);
			}
			catch(TargetInvocationException x)
			{
				throw x.InnerException;
			}
		}

		internal static Type[] GetGenericArguments(Type type)
		{
			try
			{
				return method_GetGenericArguments == null ? Type.EmptyTypes : (Type[])method_GetGenericArguments.Invoke(type, noargs);
			}
			catch(TargetInvocationException x)
			{
				throw x.InnerException;
			}
		}

		internal static Type MakeGenericType(Type type, Type[] typeArguments)
		{
			try
			{
				return (Type)method_MakeGenericType.Invoke(type, new object[] { typeArguments });
			}
			catch(TargetInvocationException x)
			{
				throw x.InnerException;
			}
		}

		internal static bool ReflectionOnly(Assembly asm)
		{
			try
			{
				return get_ReflectionOnly != null && (bool)get_ReflectionOnly.Invoke(asm, noargs);
			}
			catch(TargetInvocationException x)
			{
				throw x.InnerException;
			}
		}
	}

d8941 1
a8941 1
			if(Whidbey.ContainsGenericParameters(type))
d8946 1
a8946 1
			if(Whidbey.IsGenericType(type))
d8949 1
a8949 1
				sb.Append(MangleTypeName(Whidbey.GetGenericTypeDefinition(type).FullName));
d8952 1
a8952 1
				foreach(Type t1 in Whidbey.GetGenericArguments(type))
d9103 1
a9103 1
			if(Whidbey.ContainsGenericParameters(type))
d10309 1
a10309 1
			if(Whidbey.IsGenericType(type))
d10950 1
a10950 1
			if(Whidbey.IsGenericMethodDefinition(mb))
d11125 1
a11125 1
							if(!Whidbey.IsGenericTypeDefinition(nestedTypes[i]))
@


1.202
log
@- Fixed AotTypeWrapper.EmitCheckCast() for ghost arrays (which apparently isn't used in the current core library).
- Fixed TypeWrapper.EmitCheckCast() for ghost arrays to actually cast to an array type.
@
text
@a25 1
#if WHIDBEY
a26 1
#endif
a35 1
using IKVM.Runtime;
a183 1
#if WHIDBEY
a193 1
#endif
d754 1
a754 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d767 1
a767 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d792 1
a792 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d816 1
a816 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d897 1
a897 1
#if WHIDBEY && !COMPACT_FRAMEWORK
a951 1
#if WHIDBEY
a955 1
#endif
d1160 1
a1160 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1180 1
a1180 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1198 1
a1198 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1213 1
a1213 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1233 1
a1233 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1253 1
a1253 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1279 1
a1279 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1300 1
a1300 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1320 1
a1320 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1342 1
a1342 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1362 1
a1362 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1382 1
a1382 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1405 1
a1405 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1425 1
a1425 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1448 1
a1448 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1471 1
a1471 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1490 1
a1490 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1508 1
a1508 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1527 1
a1527 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1546 1
a1546 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d1570 1
a1570 1
#if WHIDBEY && !COMPACT_FRAMEWORK
a3026 1
#if WHIDBEY
a3031 1
#endif // WHIDBEY
a4608 1
#if WHIDBEY
a4613 2
					field = typeBuilder.DefineField(isWrappedFinal ? "__<>" + fieldName : fieldName, type, modreq, Type.EmptyTypes, attribs);
#else // WHIDBEY
d4617 1
a4617 2
					field = typeBuilder.DefineField(isWrappedFinal ? "__<>" + fieldName : fieldName, type, attribs);
#endif // WHIDBEY
a4623 6
#if !WHIDBEY
					if(fld.IsVolatile)
					{
						setModifiers = true;
					}
#endif // !WHIDBEY
d6094 3
d6098 1
d6949 1
a6949 3
#if WHIDBEY
						// TODO apply CompilerGeneratedAttribute
#endif
d7968 1
a7968 1
				MemberInfo[] members = FilterDuplicates(type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance));
a8473 28
		private static MemberInfo[] FilterDuplicates(MemberInfo[] members)
		{
#if !WHIDBEY
			// FXBUG on .NET 1.1 methods that explicitly override another method are returned twice, so we filter them here
			for(int i = 1; i < members.Length; i++)
			{
				MethodBase m1 = members[i] as MethodBase;
				if(m1 != null)
				{
					for(int j = 0; j < i; j++)
					{
						MethodBase m2 = members[j] as MethodBase;
						if(m2 != null && m1.MethodHandle.Value == m2.MethodHandle.Value)
						{
							MemberInfo[] newArray = new MemberInfo[members.Length - 1];
							Array.Copy(members, newArray, i);
							Array.Copy(members, i + 1, newArray, i, newArray.Length - i);
							members = newArray;
							i--;
							break;
						}
					}
				}
			}
#endif
			return members;
		}

d8479 1
a8479 1
			MemberInfo[] members = FilterDuplicates(type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance));
a8806 1
#if WHIDBEY
d8809 1
a8809 1
				// TODO
a8811 1
#endif // WHIDBEY
a8817 1
#if WHIDBEY
d8820 1
a8820 1
				// TODO
a8822 1
#endif // WHIDBEY
a8828 1
#if WHIDBEY
d8831 1
a8831 1
				// TODO
a8833 1
#endif // WHIDBEY
a8852 1
#if WHIDBEY
d8855 1
a8855 1
					// TODO
a8857 1
#endif // WHIDBEY
a8862 1
#if WHIDBEY
d8865 1
a8865 1
					// TODO
a8867 1
#endif // WHIDBEY
a10239 1
#if WHIDBEY
a10267 8
#else // WHIDBEY
				object[] attr = attributeType.GetCustomAttributes(typeof(AttributeUsageAttribute), false);
				if(attr.Length == 1)
				{
					return (AttributeUsageAttribute)attr[0];
				}
				return new AttributeUsageAttribute(AttributeTargets.All);
#endif // WHIDBEY
a10907 1
#if WHIDBEY
a10908 3
#else
						object val = EnumValueFieldWrapper.GetEnumPrimitiveValue(fields[i].GetValue(null));
#endif
a11535 1
#if WHIDBEY
d11538 1
a11538 1
				// TODO
a11540 1
#endif
d11546 1
a11546 1
			// TODO
d11552 1
a11552 1
			// TODO
d11558 1
a11558 1
			// TODO
a11698 1
#if WHIDBEY
a11707 33
#else // WHIDBEY
			string name = type.FullName + "[]";
			for(int i = 1; i < dims; i++)
			{
				name += "[]";
			}
#if !COMPACT_FRAMEWORK
			ModuleBuilder mb = type.Module as ModuleBuilder;
			if(mb != null)
			{
				// FXBUG ModuleBuilder.GetType() is broken on .NET 1.1, it fires a TypeResolveEvent when
				// you try to construct an array type from an unfinished type. I don't think it should
				// do that. We have to work around that by setting a global flag (yuck) to prevent us
				// from responding to the TypeResolveEvent.
				lock(DynamicClassLoader.arrayConstructionLock)
				{
					DynamicClassLoader.arrayConstructionHack = true;
					try
					{
						return mb.GetType(name);
					}
					finally
					{
						DynamicClassLoader.arrayConstructionHack = false;
					}
				}
			}
			else
#endif // !COMPACT_FRAMEWORK
			{
				return type.Assembly.GetType(name, true);
			}
#endif // WHIDBEY
@


1.201
log
@Added support for the fact that .NET generic type instances can now refer to dynamically loaded Java types.
@
text
@d2901 1
a2901 1
				// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
d2910 1
a2910 1
				// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
d2921 1
@


1.200
log
@Added support for custom assembly class loaders.
@
text
@d9242 1
a9242 1
						else if(AttributeHelper.IsJavaModule(t.Module))
@


1.199
log
@Disable inlining of __<clinit> method to work around x64 JIT bug.
@
text
@d9031 1
d9119 12
@


1.198
log
@Fix for bug #1802125.
@
text
@d4108 4
@


1.197
log
@JLS binary compat fix. Public inner classes should not be nested inside non public types.
@
text
@d2740 1
a2740 1
				else if(mce.DeclaringType.TypeAsTBD.Assembly != typeBuilder.Assembly)
d3441 1
a3441 1
				if(!BaseTypeWrapper.IsPublic && BaseTypeWrapper.TypeAsTBD.Assembly != classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly)
d3490 2
a3491 2
					&& iface.TypeAsTBD.Assembly != classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly
					&& iface.TypeAsTBD.Assembly.GetType(DynamicClassLoader.GetProxyHelperName(iface.TypeAsTBD)) == null)
d5427 1
a5427 1
							if(!iface.IsPublic && ifaceType.Assembly != typeBuilder.Assembly)
@


1.196
log
@Fixed RunClassInit() for remapped types.
@
text
@d150 2
d175 2
d600 18
d1258 47
d3802 1
d3877 11
a3887 1
							typeAttribs |= TypeAttributes.NestedPublic;
d3908 1
a3908 1
						if(outer != null)
d3953 1
a3953 1
						if(outer != null)
d3966 5
d8279 4
d8298 5
@


1.195
log
@Cache ReflectiveModifiers in CompiledTypeWrapper. AttributeHelper.GetInnerClass() is expensive and this property is called directly in response to Class.getModifiers(), so caching the modifiers results in a significant speedup of Class.getModifiers() which in turns speeds up Constructor.newInstance().
@
text
@d2747 1
a2747 1
			Type t = TypeAsTBD;
@


1.194
log
@Added extra checks to prevent critical failures when trying to extend or implement non-public base classes/interfaces in another assembly.
@
text
@d7840 1
d8217 1
a8217 2
				InnerClassAttribute attr = AttributeHelper.GetInnerClass(type);
				if(attr != null)
d8219 9
a8227 1
					return attr.Modifiers;
d8229 1
a8229 1
				return Modifiers;
@


1.193
log
@Implemented support for creating proxies for non-public interfaces from ikvmc compiled assemblies.
@
text
@d3372 5
d3420 10
@


1.192
log
@Fixed handling of finalize method to deal with scenarios where the base class isn't yet finished when the derived class' finalize method is linked.
@
text
@d487 9
d5281 4
d5326 6
a5331 1
							typeBuilder.AddInterfaceImplementation(iface.TypeAsBaseType);
@


1.191
log
@Stub package accessible abstract methods in public classes to allow JLS binary compatibility across assembly boundaries.
@
text
@d3554 1
d6362 1
a6362 1
			private static MethodInfo GetBaseFinalizeMethod(Type type, out bool clash)
d6365 27
d6658 1
a6658 1
								baseFinalize = GetBaseFinalizeMethod(typeBuilder.BaseType, out finalizeClash);
d6779 1
a6779 1
								MethodBuilder finalize = typeBuilder.DefineMethod(finalizeName, attr, CallingConventions.Standard, typeof(void), Type.EmptyTypes);
d6782 1
a6782 1
									typeBuilder.DefineMethodOverride(finalize, baseFinalize);
d6784 2
a6785 2
								AttributeHelper.HideFromJava(finalize);
								ILGenerator ilgen = finalize.GetILGenerator();
@


1.190
log
@Improved handling of abstract methods that aren't implemented in non-abstract classes (JLS binary compatibility).
@
text
@d4845 1
a4845 2
								// NOTE in the JVM it is apparently legal for a non-abstract class to have abstract methods, but
								// the CLR doens't allow this, so we have to emit a method that throws an AbstractMethodError
d4848 12
d6530 8
a6537 1
								attribs |= MethodAttributes.Abstract;
@


1.189
log
@Add support for overriding package virtual methods that have a different vtable slot from the non-package virtual method that we're overriding.
@
text
@d4738 1
a4738 1
								if(mi != null && mi.IsAbstract && !mi.DeclaringType.IsInterface && wrapper.GetMethodWrapper(mw.Name, mw.Signature, true) == mw)
d4740 47
a4786 5
									// NOTE in Sun's JRE 1.4.1 this method cannot be overridden by subclasses,
									// but I think this is a bug, so we'll support it anyway.
									MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & ~(MethodAttributes.Abstract|MethodAttributes.NewSlot), CallingConventions.Standard, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
									AttributeHelper.HideFromJava(mb);
									EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + mw.Name + mw.Signature);
@


1.188
log
@Only public methods can implement missing interface methods.
@
text
@d6648 22
@


1.187
log
@Fixed code generator bug that could cause AbstractMethodError to be thrown when subclassing a .NET type that has an explicit interface method implementation.
@
text
@d5020 1
a5020 1
							if(mw.Name != "<init>" && !mw.IsStatic && !mw.IsPrivate)
@


1.187.2.1
log
@Ported fixes from trunk. Changed version to 0.36.0.1.
@
text
@a486 9
		internal static void SetEditorBrowsableNever(TypeBuilder tb)
		{
			if(editorBrowsableNever == null)
			{
				editorBrowsableNever = new CustomAttributeBuilder(StaticCompiler.GetType("System.ComponentModel.EditorBrowsableAttribute").GetConstructor(new Type[] { StaticCompiler.GetType("System.ComponentModel.EditorBrowsableState") }), new object[] { (int)System.ComponentModel.EditorBrowsableState.Never });
			}
			tb.SetCustomAttribute(editorBrowsableNever);
		}

a3553 1
			private MethodBuilder finalizeMethod;
d4738 1
a4738 1
								if(mi != null && mi.IsAbstract && !mi.DeclaringType.IsInterface)
d4740 5
a4744 47
									bool needStub = false;
									bool needRename = false;
									if(mw.IsPublic || mw.IsProtected)
									{
										MethodWrapper fmw = wrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
										while(fmw != mw && (fmw.IsStatic || fmw.IsPrivate))
										{
											needRename = true;
											fmw = fmw.DeclaringType.BaseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
										}
										if(fmw == mw && fmw.DeclaringType != wrapper)
										{
											needStub = true;
										}
									}
									else
									{
										MethodWrapper fmw = wrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
										while(fmw != mw && (fmw.IsStatic || fmw.IsPrivate || !fmw.DeclaringType.IsInSamePackageAs(mw.DeclaringType)))
										{
											needRename = true;
											fmw = fmw.DeclaringType.BaseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
										}
										if(fmw == mw && fmw.DeclaringType != wrapper)
										{
											needStub = true;
										}
									}
									if(needStub)
									{
										// NOTE in Sun's JRE 1.4.1 this method cannot be overridden by subclasses,
										// but I think this is a bug, so we'll support it anyway.
										string name = mi.Name;
										MethodAttributes attr = mi.Attributes & ~(MethodAttributes.Abstract | MethodAttributes.NewSlot);
										if(needRename)
										{
											name = "__<>" + name + "/" + mi.DeclaringType.FullName;
											attr = MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot;
										}
										MethodBuilder mb = typeBuilder.DefineMethod(name, attr, CallingConventions.Standard, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
										if(needRename)
										{
											typeBuilder.DefineMethodOverride(mb, mi);
										}
										AttributeHelper.HideFromJava(mb);
										EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
									}
d4803 2
a4804 1
								bool stub = false;
a4806 12
									// NOTE in the JVM it is apparently legal for a non-abstract class to have abstract methods, but
									// the CLR doens't allow this, so we have to emit a method that throws an AbstractMethodError
									stub = true;
								}
								else if(classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected))
								{
									// We have an abstract package accessible method in our public class. To allow a class in another
									// assembly to subclass this class, we must fake the abstractness of this method.
									stub = true;
								}
								if(stub)
								{
d5020 1
a5020 1
							if(mw.Name != "<init>" && !mw.IsStatic && mw.IsPublic)
a5217 4
						if(classFile.IsInterface && !classFile.IsPublic)
						{
							((DynamicClassLoader)wrapper.classLoader.GetTypeWrapperFactory()).DefineProxyHelper(type);
						}
d5259 1
a5259 6
							Type ifaceType = iface.TypeAsBaseType;
							if(!iface.IsPublic && ifaceType.Assembly != typeBuilder.Assembly)
							{
								ifaceType = ifaceType.Assembly.GetType(DynamicClassLoader.GetProxyHelperName(ifaceType));
							}
							typeBuilder.AddInterfaceImplementation(ifaceType);
d6308 1
a6308 1
			private static MethodInfo GetBaseFinalizeMethod(TypeWrapper wrapper, out bool clash)
a6310 27
				for(;;)
				{
					// HACK we get called during method linking (which is probably a bad idea) and
					// it is possible for the base type not to be finished yet, so we look at the
					// private state of the unfinished base types to find the finalize method.
					DynamicTypeWrapper dtw = wrapper as DynamicTypeWrapper;
					if(dtw == null)
					{
						break;
					}
					JavaTypeImpl impl = dtw.impl as JavaTypeImpl;
					if(impl == null)
					{
						break;
					}
					MethodWrapper mw = dtw.GetMethodWrapper(StringConstants.FINALIZE, StringConstants.SIG_VOID, false);
					if(mw != null)
					{
						mw.Link();
					}
					if(impl.finalizeMethod != null)
					{
						return impl.finalizeMethod;
					}
					wrapper = wrapper.BaseTypeWrapper;
				}
				Type type = wrapper.TypeAsBaseType;
d6477 1
a6477 8
								if(classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected))
								{
									setModifiers = true;
								}
								else
								{
									attribs |= MethodAttributes.Abstract;
								}
d6570 1
a6570 1
								baseFinalize = GetBaseFinalizeMethod(wrapper.BaseTypeWrapper, out finalizeClash);
a6647 22
							if(!m.IsStatic && !m.IsAbstract && !m.IsPrivate && baseMce != null && !baseMce.DeclaringType.IsInSamePackageAs(wrapper))
							{
								// we may have to explicitly override another package accessible abstract method
								TypeWrapper btw = baseMce.DeclaringType.BaseTypeWrapper;
								while(btw != null)
								{
									MethodWrapper bmw = btw.GetMethodWrapper(m.Name, m.Signature, true);
									if(bmw == null)
									{
										break;
									}
									if(bmw.DeclaringType.IsInSamePackageAs(wrapper) && bmw.IsAbstract && !(bmw.IsPublic || bmw.IsProtected))
									{
										if(bmw != baseMce)
										{
											typeBuilder.DefineMethodOverride(mb, (MethodInfo)bmw.GetMethod());
										}
										break;
									}
									btw = bmw.DeclaringType.BaseTypeWrapper;
								}
							}
d6669 1
a6669 1
								finalizeMethod = typeBuilder.DefineMethod(finalizeName, attr, CallingConventions.Standard, typeof(void), Type.EmptyTypes);
d6672 1
a6672 1
									typeBuilder.DefineMethodOverride(finalizeMethod, baseFinalize);
d6674 2
a6675 2
								AttributeHelper.HideFromJava(finalizeMethod);
								ILGenerator ilgen = finalizeMethod.GetILGenerator();
@


1.187.2.2
log
@Backported fixes from trunk. Changed version to 0.36.0.2.
@
text
@a3371 5
				if(!BaseTypeWrapper.IsPublic && BaseTypeWrapper.TypeAsTBD.Assembly != classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly)
				{
					// NOTE this can only happen if evil code calls ClassLoader.defineClass() on an assembly class loader (which we allow for compatibility with other slightly less evil code)
					throw new IllegalAccessError("Class " + f.Name + " cannot access its non-public superclass " + BaseTypeWrapper.Name + " from another assembly");
				}
a3414 10
				if(!iface.IsPublic
					&& iface.TypeAsTBD.Assembly != classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly
					&& iface.TypeAsTBD.Assembly.GetType(DynamicClassLoader.GetProxyHelperName(iface.TypeAsTBD)) == null)
				{
					// NOTE this happens when you call Proxy.newProxyInstance() on a non-public .NET interface
					// (for ikvmc compiled Java types, ikvmc generates public proxy stubs).
					// NOTE we don't currently check interfaces inherited from other interfaces because mainstream .NET languages
					// don't allow public interfaces extending non-public interfaces.
					throw new IllegalAccessError("Class " + f.Name + " cannot access its non-public superinterface " + iface.Name + " from another assembly");
				}
a7824 1
		private Modifiers reflectiveModifiers;
d8201 2
a8202 1
				if (reflectiveModifiers == 0)
d8204 1
a8204 9
					InnerClassAttribute attr = AttributeHelper.GetInnerClass(type);
					if (attr != null)
					{
						reflectiveModifiers = attr.Modifiers;
					}
					else
					{
						reflectiveModifiers = Modifiers;
					}
d8206 1
a8206 1
				return reflectiveModifiers;
@


1.187.2.3
log
@Backported fixes from trunk. Changed version to 0.36.0.3.
@
text
@d2747 1
a2747 1
			Type t = IsRemapped ? TypeAsBaseType : TypeAsTBD;
@


1.187.2.4
log
@Backported fixes. Changed version to 0.36.0.4.
@
text
@a149 2
		private static ConstructorInfo nonNestedInnerClassAttribute;
		private static ConstructorInfo nonNestedOuterClassAttribute;
a172 2
		private static Type typeofNonNestedInnerClassAttribute = JVM.LoadType(typeof(NonNestedInnerClassAttribute));
		private static Type typeofNonNestedOuterClassAttribute = JVM.LoadType(typeof(NonNestedOuterClassAttribute));
a595 18

		internal static void SetNonNestedInnerClass(TypeBuilder typeBuilder, string className)
		{
			if(nonNestedInnerClassAttribute == null)
			{
				nonNestedInnerClassAttribute = typeofNonNestedInnerClassAttribute.GetConstructor(new Type[] { typeof(string) });
			}
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(nonNestedInnerClassAttribute, new object[] { className }));
		}

		internal static void SetNonNestedOuterClass(TypeBuilder typeBuilder, string className)
		{
			if(nonNestedOuterClassAttribute == null)
			{
				nonNestedOuterClassAttribute = typeofNonNestedOuterClassAttribute.GetConstructor(new Type[] { typeof(string) });
			}
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(nonNestedOuterClassAttribute, new object[] { className }));
		}
a1235 47
		internal static string[] GetNonNestedInnerClasses(Type t)
		{
#if WHIDBEY && !COMPACT_FRAMEWORK
			if(JVM.IsStaticCompiler || t.Assembly.ReflectionOnly)
			{
				List<string> list = new List<string>();
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(t))
				{
					if(MatchTypes(cad.Constructor.DeclaringType, typeofNonNestedInnerClassAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						list.Add((string)args[0].Value);
					}
				}
				return list.ToArray();
			}
#endif
			object[] attribs = t.GetCustomAttributes(typeof(NonNestedInnerClassAttribute), false);
			string[] classes = new string[attribs.Length];
			for(int i = 0; i < attribs.Length; i++)
			{
				classes[i] = ((NonNestedInnerClassAttribute)attribs[i]).InnerClassName;
			}
			return classes;
		}

		internal static string GetNonNestedOuterClasses(Type t)
		{
#if WHIDBEY && !COMPACT_FRAMEWORK
			if(JVM.IsStaticCompiler || t.Assembly.ReflectionOnly)
			{
				List<string> list = new List<string>();
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(t))
				{
					if(MatchTypes(cad.Constructor.DeclaringType, typeofNonNestedOuterClassAttribute))
					{
						IList<CustomAttributeTypedArgument> args = cad.ConstructorArguments;
						return (string)args[0].Value;
					}
				}
				return null;
			}
#endif
			object[] attribs = t.GetCustomAttributes(typeof(NonNestedOuterClassAttribute), false);
			return attribs.Length == 1 ? ((NonNestedOuterClassAttribute)attribs[0]).OuterClassName : null;
		}

d2671 1
a2671 1
				else if(!mce.DeclaringType.TypeAsTBD.Assembly.Equals(typeBuilder.Assembly))
d3372 1
a3372 1
				if(!BaseTypeWrapper.IsPublic && !BaseTypeWrapper.TypeAsBaseType.Assembly.Equals(classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly))
d3421 2
a3422 2
					&& !iface.TypeAsBaseType.Assembly.Equals(classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly)
					&& iface.TypeAsBaseType.Assembly.GetType(DynamicClassLoader.GetProxyHelperName(iface.TypeAsTBD)) == null)
a3732 1
					bool cantNest = false;
d3807 1
a3807 11
							if(outerClassWrapper.IsPublic)
							{
								typeAttribs |= TypeAttributes.NestedPublic;
							}
							else
							{
								// We're a public type nested inside a non-public type, this means that we can't compile this type as a nested type,
								// because that would mean it wouldn't be visible outside the assembly.
								cantNest = true;
								typeAttribs |= TypeAttributes.Public;
							}
d3828 1
a3828 1
						if(outer != null && !cantNest)
d3873 1
a3873 1
						if(outer != null && !cantNest)
a3885 5
					if(outer != null && cantNest)
					{
						AttributeHelper.SetNonNestedOuterClass(typeBuilder, outerClassWrapper.Name);
						AttributeHelper.SetNonNestedInnerClass(outer, f.Name);
					}
a4022 4
						// FXBUG on .NET 2.0 RTM x64 the JIT sometimes throws an InvalidProgramException while trying to inline this method,
						// so we prevent inlining for now (it also turns out that on x86 not inlining this method actually has a positive perf impact in some cases...)
						// http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=285772
						clinitMethod.SetImplementationFlags(clinitMethod.GetMethodImplementationFlags() | MethodImplAttributes.NoInlining);
d5342 1
a5342 1
							if(!iface.IsPublic && !ifaceType.Assembly.Equals(typeBuilder.Assembly))
a8193 4
					foreach(string s in AttributeHelper.GetNonNestedInnerClasses(type))
					{
						wrappers.Add(GetClassLoader().LoadClassByDottedName(s));
					}
a8208 5
				string decl = AttributeHelper.GetNonNestedOuterClasses(type);
				if(decl != null)
				{
					return GetClassLoader().LoadClassByDottedName(decl);
				}
@


1.187.2.5
log
@Backported fixes and changed version to 0.36.0.5
@
text
@d2901 1
a2901 1
				// NOTE for dynamic ghosts we don't end up here because AotTypeWrapper overrides this method,
d2910 1
a2910 1
				// NOTE for dynamic ghosts we don't end up here because AotTypeWrapper overrides this method,
a2920 1
				ilgen.Emit(OpCodes.Castclass, ArrayTypeWrapper.MakeArrayType(typeof(object), rank));
a9030 1
		private static readonly MethodInfo get_ReflectionOnly = typeof(Assembly).GetMethod("get_ReflectionOnly");
a9117 12

		internal static bool ReflectionOnly(Assembly asm)
		{
			try
			{
				return get_ReflectionOnly != null && (bool)get_ReflectionOnly.Invoke(asm, noargs);
			}
			catch(TargetInvocationException x)
			{
				throw x.InnerException;
			}
		}
d9229 1
a9229 1
						else if(ClassLoaderWrapper.IsDynamicType(t) || AttributeHelper.IsJavaModule(t.Module))
@


1.187.2.6
log
@- Updated version to 0.36.0.6
- Fix for issue reported in http://sourceforge.net/mailarchive/message.php?msg_name=477171a5.1ec37e0a.1f81.7bc8%40mx.google.com
- Fix for bug #1865922
@
text
@a1723 85
		protected static object QualifyClassNames(ClassLoaderWrapper loader, object annotation)
		{
			bool copy = false;
			object[] def = (object[])annotation;
			for(int i = 3; i < def.Length; i += 2)
			{
				object[] val = def[i] as object[];
				if(val != null)
				{
					object[] newval = ValueQualifyClassNames(loader, val);
					if(newval != val)
					{
						if(!copy)
						{
							copy = true;
							object[] newdef = new object[def.Length];
							Array.Copy(def, newdef, def.Length);
							def = newdef;
						}
						def[i] = newval;
					}
				}
			}
			return def;
		}

		private static object[] ValueQualifyClassNames(ClassLoaderWrapper loader, object[] val)
		{
			if(val[0].Equals(AnnotationDefaultAttribute.TAG_ANNOTATION))
			{
				return (object[])QualifyClassNames(loader, val);
			}
			else if(val[0].Equals(AnnotationDefaultAttribute.TAG_CLASS))
			{
				string sig = (string)val[1];
				if(sig.StartsWith("L"))
				{
					TypeWrapper tw = loader.LoadClassByDottedNameFast(sig.Substring(1, sig.Length - 2).Replace('/', '.'));
					if(tw != null)
					{
						return new object[] { AnnotationDefaultAttribute.TAG_CLASS, "L" + tw.TypeAsBaseType.AssemblyQualifiedName.Replace('.', '/') + ";" };
					}
				}
				return val;
			}
			else if(val[0].Equals(AnnotationDefaultAttribute.TAG_ENUM))
			{
				string sig = (string)val[1];
				TypeWrapper tw = loader.LoadClassByDottedNameFast(sig.Substring(1, sig.Length - 2).Replace('/', '.'));
				if(tw != null)
				{
					return new object[] { AnnotationDefaultAttribute.TAG_ENUM, "L" + tw.TypeAsBaseType.AssemblyQualifiedName.Replace('.', '/') + ";", val[2] };
				}
				return val;
			}
			else if(val[0].Equals(AnnotationDefaultAttribute.TAG_ARRAY))
			{
				bool copy = false;
				for(int i = 1; i < val.Length; i++)
				{
					object[] nval = val[i] as object[];
					if(nval != null)
					{
						object newnval = ValueQualifyClassNames(loader, nval);
						if(newnval != nval)
						{
							if(!copy)
							{
								copy = true;
								object[] newval = new object[val.Length];
								Array.Copy(val, newval, val.Length);
								val = newval;
							}
							val[i] = newnval;
						}
					}
				}
				return val;
			}
			else
			{
				throw new InvalidOperationException();
			}
		}

a6011 1
						annotation = QualifyClassNames(loader, annotation);
a6019 1
						annotation = QualifyClassNames(loader, annotation);
a6027 1
						annotation = QualifyClassNames(loader, annotation);
a6035 1
						annotation = QualifyClassNames(loader, annotation);
a6043 1
						annotation = QualifyClassNames(loader, annotation);
a6051 1
						annotation = QualifyClassNames(loader, annotation);
a8944 1
				annotation = QualifyClassNames(loader, annotation);
a8949 1
				annotation = QualifyClassNames(loader, annotation);
a8954 1
				annotation = QualifyClassNames(loader, annotation);
a8959 1
				annotation = QualifyClassNames(loader, annotation);
a8964 1
				annotation = QualifyClassNames(loader, annotation);
a8969 1
				annotation = QualifyClassNames(loader, annotation);
d11433 1
a11433 1
					if(outer != null && !Whidbey.IsGenericType(type))
@


1.187.2.7
log
@- Don't instantiate a DotNetTypeWrapper unless the name is actually the canonical name (this fixes a problem with ikvmc when referencing a .NET assembly that contains a type named java.lang.Object).
- As an optimization going from a Type to a TypeWrapper now also reuses the name it already computed.
@
text
@d10664 2
a10665 2
		internal DotNetTypeWrapper(Type type, string name)
			: base(GetModifiers(type), name, GetBaseTypeWrapper(type))
@


1.187.2.8
log
@- Added workaround for .NET 1.1 bug assembly qualified type names in the assembly that is currently being built not to have a Culture.
- Implemented field/method/parameter annotation support for .NET types.
@
text
@a1749 11
		private static string GetAssemblyQualifiedTypeName(Type type)
		{
			string name = type.AssemblyQualifiedName;
			if(name.IndexOf("Culture=") == -1)
			{
				// FXBUG on .NET 1.1 an AssemblyBuilder with neutral culture will not return a proper assembly name
				name += ", Culture=neutral";
			}
			return name;
		}

d1764 1
a1764 1
						return new object[] { AnnotationDefaultAttribute.TAG_CLASS, "L" + GetAssemblyQualifiedTypeName(tw.TypeAsBaseType).Replace('.', '/') + ";" };
d1775 1
a1775 1
					return new object[] { AnnotationDefaultAttribute.TAG_ENUM, "L" + GetAssemblyQualifiedTypeName(tw.TypeAsBaseType).Replace('.', '/') + ";", val[2] };
d11713 2
a11714 12
			FieldInfo fi = fw.GetField();
			if(fi == null)
			{
				return null;
			}
#if WHIDBEY
			if(fi.DeclaringType.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
			}
#endif
			return fi.GetCustomAttributes(false);
d11719 2
a11720 13
			MethodBase mb = mw.GetMethod();
			if(mb == null)
			{
				return null;
			}
#if WHIDBEY
			if(mb.DeclaringType.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
				return null;
			}
#endif
			return mb.GetCustomAttributes(false);
d11725 2
a11726 19
			MethodBase mb = mw.GetMethod();
			if(mb == null)
			{
				return null;
			}
#if WHIDBEY
			if(mb.DeclaringType.Assembly.ReflectionOnly)
			{
				// TODO on Whidbey this must be implemented
				return null;
			}
#endif
			ParameterInfo[] parameters = mb.GetParameters();
			object[][] attribs = new object[parameters.Length][];
			for(int i = 0; i < parameters.Length; i++)
			{
				attribs[i] = parameters[i].GetCustomAttributes(false);
			}
			return attribs;
@


1.187.2.9
log
@Added recursion protection (back) in FinishCore.
@
text
@a3739 1
			private bool finishInProgress;
a4904 5
				if(finishInProgress)
				{
					throw new InvalidOperationException("Recursive finish attempt for " + wrapper.Name);
				}
				finishInProgress = true;
@


1.187.2.10
log
@Ignore field annotations on ReflectionOnly assemblies when compiled for .NET 2.0.
@
text
@a11738 1
				return null;
@


1.187.2.11
log
@Back ported the following fixes:
- Remapped exceptions with explicit remapping code now call suppressFullInStackTrace (to make sure the proper stack trace is captured).
- Fixed memory mapped file bug (mapping at a non-zero offset would fail).
- Fixed .NET type name mangling for nested types that contain a dot in their name (which the C# 3.0 compiler generates for some helper types).
- Fixed bug in deserialization of double arrays.
- Fixed path canonicalization to swallow NotSupportedException (thrown when the path contains a colon, other than the one following the drive letter).
@
text
@a9392 1
			bool nested = false;
a9397 1
					nested = true;
d9401 1
a9401 1
					|| (c == '.' && !escape && !nested))
@


1.187.2.12
log
@Back ported various fixes:
- Changed version to 0.36.0.13.
- Fixed ikvmc not to open the key file for write access.
- Added more efficient float/double to/from int/long bits converters.
- Fixed libikvm-native.so build to include reference to gmodule-2.0 library.
- Fixed ikvmc not to open the key file for write access.
- Fixed Graphics2D.rotate() to convert rotation angle from radians (Java) to degrees (.NET).
- Applied awt patch #1979656 by Daniel Wilson.
- Fixed three String bugs found by OpenJDK string tests.
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
- Removed incorrect DataFormatException thrown in java.util.zip.InflaterHuffmanTree.
- Fixed #2001802 contributed by Andy Malakov.
- Fixed #2001799.
- Fixed #2006953.
- Made finalize() and clone() methods in cli.System.Object and cli.System.Exception final.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
d4079 1
d4084 1
d4156 5
a4937 18
#if STATIC_COMPILER
						// before we bake our type, we need to link any inner annotations to allow them to create their attribute type (as a nested type)
						foreach(TypeWrapper tw in innerClassesTypeWrappers)
						{
							DynamicTypeWrapper dtw = tw as DynamicTypeWrapper;
							if(dtw != null)
							{
								JavaTypeImpl impl = dtw.impl as JavaTypeImpl;
								if(impl != null)
								{
									if(impl.annotationBuilder != null)
									{
										impl.annotationBuilder.Link();
									}
								}
							}
						}
#endif // STATIC_COMPILER
a4939 5
					if(annotationBuilder != null)
					{
						CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(AnnotationAttributeAttribute)).GetConstructor(new Type[] { typeof(string) }), new object[] { annotationBuilder.AttributeTypeName });
						typeBuilder.SetCustomAttribute(cab);
					}
a5717 1
				private JavaTypeImpl impl;
a5723 12
					this.impl = o;
				}

				internal void Link()
				{
					if(impl == null)
					{
						return;
					}
					JavaTypeImpl o = impl;
					impl = null;

a5886 1
						Link();
a5914 1
					Link();
a6111 1
					Link();
a6120 1
					Link();
a6129 1
					Link();
a6138 1
					Link();
a6147 1
					Link();
a6156 1
					Link();
d10993 1
a10993 1
				: base(tw, "finalize", "()V", null, PrimitiveTypeWrapper.VOID, TypeWrapper.EmptyArray, Modifiers.Protected | Modifiers.Final, MemberFlags.None)
d11018 1
a11018 1
				: base(tw, "clone", "()Ljava.lang.Object;", null, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Protected | Modifiers.Final, MemberFlags.None)
@


1.186
log
@Added support for StructLayoutAttribute annotations.
@
text
@d4738 1
a4738 1
								if(mi != null && mi.IsAbstract && wrapper.GetMethodWrapper(mw.Name, mw.Signature, true) == mw)
@


1.185
log
@Added HideFromJava to AnnotationAttribute type member that can potentially use HideFromJava types.
@
text
@d3999 9
d4015 15
d9542 6
d10226 7
@


1.184
log
@Fixed ArrayTypeWrapper.Finish().
@
text
@d5662 1
d5688 1
d5788 1
d5790 1
d5796 1
@


1.183
log
@Added support for generating access stubs in public interfaces that extend non-public interfaces.
@
text
@d11334 1
a11427 8
		private bool IsFinished
		{
			get
			{
				return !(ultimateElementTypeWrapper.TypeAsArrayType is TypeBuilder);
			}
		}

d11432 1
a11432 1
				if(!IsFinished)
d11434 1
d11437 1
a11437 1
					ClassLoaderWrapper.SetWrapperForType(arrayType, this);
@


1.182
log
@Added method name clash handling for AOT access stub methods.
@
text
@d3615 1
a3615 1
				if(!wrapper.IsInterface)
d3626 1
a3626 1
					if(wrapper.IsPublic)
d3677 1
a3677 1
				if(!wrapper.IsInterface && wrapper.IsPublic)
d4121 5
@


1.181
log
@- Fixed assembly annotation support (annotations are now applied, even though "assembly" type already exists in core library).
- Added ikvmc warning when annotation type isn't found.
@
text
@d3500 6
d4625 8
d4639 10
d6257 1
a6257 1
			private string GenerateUniqueMethodName(string basename, Type returnType, Type[] parameterTypes)
@


1.180
log
@Allow Object[] to be cast/assigned to ghost array. Fix for bug 1757889.
@
text
@d1603 8
a1610 1
			catch(RetargetableJavaException)
a5141 9
#if STATIC_COMPILER
								// NOTE the "assembly" type in the unnamed package is a magic type
								// that acts as the placeholder for assembly attributes
								if(classFile.Name == "assembly")
								{
									annotation.Apply(wrapper.GetClassLoader(), (AssemblyBuilder)typeBuilder.Assembly, def);
									continue;
								}
#endif
@


1.179
log
@- Added workaround for .NET 1.1 reflection bug (methods that explicitly override a method are returned twice)
- Removed duplicate method workaround from stub generator.
@
text
@d2513 1
a2513 1
				return !elem1.IsNonPrimitiveValueType && elem1.IsSubTypeOf(elem2);
@


1.178
log
@Restructured handling of fields defined in map.xml to enable referencing them from map.xml method  bodies.
@
text
@d7695 1
a7695 1
				MemberInfo[] members = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
a7704 1
							// FXBUG on .NET 1.1 Throwable.toString() shows up twice
d8185 28
d8218 1
a8218 1
			MemberInfo[] members = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
@


1.177
log
@Fixed private interface implementation support in .NET type reflection to ignore methods with the same name/signature that aren't public either. This fixes a bug where ikvmstub generated jar of System.Web yields a System.Web.UI.Control class that doesn't implement the interfaces that it claims to implement (and javac will complain when you try to extend the class).
@
text
@d3670 1
d4350 33
d4384 1
a4384 1
				ClassFile.Field fld = classFile.Fields[GetFieldIndex(fw)];
d7403 1
@


1.176
log
@Fixed GetParameterAnnotations() to return the correct array length for instancehelper__ methods (static methods that represent instance methods on remapped types).
@
text
@d10681 2
a10682 2
				// HACK private interface implementations need to be published as well
				// (otherwise the type appears abstract while it isn't)
d10688 3
a10690 1
						if(interfaces[i].IsPublic)
d10695 2
a10696 1
								if(!map.TargetMethods[j].IsPublic && map.TargetMethods[j].DeclaringType == type)
d10704 3
a10706 1
										if(BaseTypeWrapper != null)
d10714 1
a10714 3
										string key = name + sig;
										MethodWrapper existing = (MethodWrapper)methodsList[key];
										if(existing == null || existing is ByRefMethodWrapper)
d10716 3
@


1.175
log
@Added support for replacing constructor and static initializer method bodies in map.xml.
@
text
@d8518 7
a8524 2
			object[][] attribs = new object[parameters.Length][];
			for(int i = 0; i < parameters.Length; i++)
d8526 1
a8526 1
				attribs[i] = parameters[i].GetCustomAttributes(false);
@


1.174
log
@Fixed compilation error.
@
text
@d4682 7
@


1.173
log
@Moved "instance of" test to TypeWrapper and added support for ghost and dynamiconly type arrays.
@
text
@d2520 1
d2550 1
@


1.172
log
@Fixed infnite recursion bug when DotNetTypeWrapper.GetName() was used on DerivedType where DerivedType extends BaseType<DerivedType>.
@
text
@d1969 9
d2518 34
@


1.171
log
@Fixed varargs regression introduced by recent ParameterBuilder handling rewrite.
@
text
@d3087 13
d8777 1
a8777 1
				foreach(Type t in Whidbey.GetGenericArguments(type))
d8779 1
d8781 9
a8789 2
					TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(t);
					while(tw.IsArray)
d8791 1
a8791 1
						tw = tw.ElementTypeWrapper;
d8794 1
a8794 1
					if(tw.IsPrimitive)
d8796 1
a8796 1
						sb.Append(tw.SigName);
d8800 13
a8812 1
						string s = tw.Name;
@


1.170
log
@Fix ArrayIndexOutOfBoundsException when accessing generic metadata on a class that has no generic methods or fields, but does have a generic signature for the class or a class that is nested in a method.
@
text
@d4951 12
a4962 1
						((AotTypeWrapper)wrapper).AddParameterAttributes(m, mb, ref parameterBuilders);
@


1.169
log
@Simplified VM -> Class Library interface by taking advantage of the fact that IKVM.Runtime.dll is now compiled in two passes with the second pass linking against the class library.
@
text
@d6843 1
a6843 1
						genericMetaData = new string[4];
d6853 1
a6853 1
						genericMetaData = new string[4];
@


1.168
log
@- Added support for applying custom attributes to return values.
- Added support for applying AllowMultiple custom attributes multiple times to the same element.
- Restructured ParameterBuilder handling.
@
text
@d9096 1
a9096 1
#if !STATIC_COMPILER
d9107 1
a9107 1
					throw JavaException.IllegalArgumentException("{0}", args[0]);
d9109 1
a9109 1
#endif // !STATIC_COMPILER
d9458 1
a9458 1
#if !STATIC_COMPILER
d9465 1
a9465 1
						return JVM.Library.box(false);
d9469 1
a9469 1
						return JVM.Library.box((byte)0);
d9473 1
a9473 1
						return JVM.Library.box((char)0);
d9477 1
a9477 1
						return JVM.Library.box((short)0);
d9481 1
a9481 1
						return JVM.Library.box(0);
d9485 1
a9485 1
						return JVM.Library.box(0F);
d9489 1
a9489 1
						return JVM.Library.box(0L);
d9493 1
a9493 1
						return JVM.Library.box(0D);
d9501 1
a9501 1
						return ClassLoaderWrapper.LoadClassCritical("ikvm.internal.__unspecified").ClassObject;
d9514 1
a9514 1
#endif // !STATIC_COMPILER
@


1.167
log
@Implement major chunk of custom attribute as annotations support.
@
text
@d1589 3
a1591 1
			if(!annotationClass.EndsWith("$Annotation;"))
d1645 4
d4934 21
a4961 1
									ConstructorBuilder cb = mb as ConstructorBuilder;
a4965 1
									MethodBuilder mBuilder = mb as MethodBuilder;
d4969 20
a6296 1
						wrapper.AddParameterNames(classFile, m, method);
a6536 1
						wrapper.AddParameterNames(classFile, m, mb);
d7114 1
a7114 1
		protected static ParameterBuilder[] AddParameterNames(MethodBase mb, ClassFile.Method m, string[] parameterNames)
a7118 6
				if(parameterNames == null)
				{
					// we're allocating the worst case length here
					// (double & long args take two slots and for instance methods there's the this arg)
					parameterNames = new string[m.ArgMap.Length];
				}
a7138 1
			return AddParameterNames(mb, m.Signature, parameterNames);
d7141 1
a7141 1
		protected static ParameterBuilder[] AddParameterNames(MethodBase mb, string sig, string[] parameterNames)
d7221 1
a7221 3
			ParameterBuilder[] parameterBuilders = new ParameterBuilder[names.Count];
			Hashtable clashes = new Hashtable();
			for(int i = 0; i < names.Count; i++)
d7223 1
a7223 2
				string name = (string)names[i];
				if(parameterNames != null && parameterNames[i] != null)
d7225 1
a7225 1
					name = parameterNames[i];
d7227 11
a7237 2
				ParameterBuilder pb;
				if(names.IndexOf(name, i + 1) >= 0 || clashes.ContainsKey(name))
d7239 2
a7240 2
					int clash = 1;
					if(clashes.ContainsKey(name))
d7242 11
a7252 1
						clash = (int)clashes[name] + 1;
a7253 2
					clashes[name] = clash;
					name += clash;
d7255 2
a7256 1
				if(mb is MethodBuilder)
d7258 1
a7258 1
					pb = ((MethodBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
d7262 1
a7262 1
					pb = ((ConstructorBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
a7263 1
				parameterBuilders[i] = pb;
a7292 1
		protected abstract void AddParameterNames(ClassFile classFile, ClassFile.Method m, MethodBase method);
a7298 8
#else
		private void AddParameterNames(ClassFile classFile, ClassFile.Method m, MethodBase method)
		{
			if(GetClassLoader().EmitDebugInfo)
			{
				AddParameterNames(method, m, null);
			}
		}
d8677 2
d9209 70
a9278 1
		private class AttributeAnnotationTypeWrapper : TypeWrapper
d9281 1
d9284 1
a9284 1
				: base(Modifiers.Public | Modifiers.Interface | Modifiers.Abstract | Modifiers.Annotation, name, null)
d9524 1
a9524 1
			internal override void Finish()
d9526 111
a9636 1
			}
d9638 8
a9645 3
			internal override ClassLoaderWrapper GetClassLoader()
			{
				return DeclaringTypeWrapper.GetClassLoader();
d9648 1
a9648 1
			internal override string[] GetEnclosingMethod()
d9650 1
a9650 2
				return null;
			}
d9652 5
a9656 4
			internal override string GetGenericFieldSignature(FieldWrapper fw)
			{
				return null;
			}
d9658 6
a9663 4
			internal override string GetGenericMethodSignature(MethodWrapper mw)
			{
				return null;
			}
d9665 7
a9671 4
			internal override string GetGenericSignature()
			{
				return null;
			}
d9673 1
a9673 3
			internal override TypeWrapper[] InnerClasses
			{
				get
d9675 4
a9678 1
					return TypeWrapper.EmptyArray;
a9679 1
			}
d9681 2
a9682 3
			internal override TypeWrapper[] Interfaces
			{
				get
d9684 1
a9684 1
					return new TypeWrapper[] { ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.annotation.Annotation") };
d9686 1
a9686 1
			}
d9688 2
a9689 3
			internal override bool IsDynamicOnly
			{
				get
d9691 77
a9767 1
					return true;
a9768 1
			}
d9770 1
a9770 3
			internal override Type TypeAsTBD
			{
				get
d9772 4
a9775 1
					return typeof(object);
d9777 1
d9780 1
a9780 1
			internal override Type TypeAsBaseType
d9784 18
a9801 1
					throw new InvalidOperationException();
d9805 1
a9805 2
#if !STATIC_COMPILER
			internal override object[] GetDeclaredAnnotations()
d9807 1
d9809 2
a9810 1
#if WHIDBEY
d9818 11
a9828 1
							break;
d9832 4
d9840 1
a9840 3
					AttributeUsageAttribute aua = (AttributeUsageAttribute)attr[0];
					validOn = aua.ValidOn;
					// TODO figure out if AttributeUsageAttribute.Inherited maps to java.lang.annotation.Inherited
d9842 1
d9844 7
d9987 4
@


1.166
log
@Added workaround for .NET bug.
@
text
@d1637 6
a1642 6
		internal abstract void Apply(TypeBuilder tb, object annotation);
		internal abstract void Apply(MethodBuilder mb, object annotation);
		internal abstract void Apply(ConstructorBuilder cb, object annotation);
		internal abstract void Apply(FieldBuilder fb, object annotation);
		internal abstract void Apply(ParameterBuilder pb, object annotation);
		internal abstract void Apply(AssemblyBuilder ab, object annotation);
d4938 1
a4938 1
										annotation.Apply(cb, def);
d4943 1
a4943 1
										annotation.Apply(mBuilder, def);
d4962 1
a4962 1
										annotation.Apply((MethodBuilder)getter.GetGetter(), def);
d4966 1
a4966 1
										annotation.Apply((FieldBuilder)fields[i].GetField(), def);
d4985 1
a4985 1
									annotation.Apply((AssemblyBuilder)typeBuilder.Assembly, def);
d4989 1
a4989 1
								annotation.Apply(typeBuilder, def);
d5620 1
a5620 1
				internal override void Apply(TypeBuilder tb, object annotation)
d5628 1
a5628 1
				internal override void Apply(MethodBuilder mb, object annotation)
d5636 1
a5636 1
				internal override void Apply(ConstructorBuilder cb, object annotation)
d5644 1
a5644 1
				internal override void Apply(FieldBuilder fb, object annotation)
d5652 1
a5652 1
				internal override void Apply(ParameterBuilder pb, object annotation)
d5660 1
a5660 1
				internal override void Apply(AssemblyBuilder ab, object annotation)
d8453 1
a8453 1
			internal override void Apply(TypeBuilder tb, object annotation)
d8458 1
a8458 1
			internal override void Apply(ConstructorBuilder cb, object annotation)
d8463 1
a8463 1
			internal override void Apply(MethodBuilder mb, object annotation)
d8468 1
a8468 1
			internal override void Apply(FieldBuilder fb, object annotation)
d8473 1
a8473 1
			internal override void Apply(ParameterBuilder pb, object annotation)
d8478 1
a8478 1
			internal override void Apply(AssemblyBuilder ab, object annotation)
d9176 1
a9176 1
			protected override void LazyPublishMembers()
d9178 24
a9201 2
				ArrayList methods = new ArrayList();
				foreach(ConstructorInfo ci in attributeType.GetConstructors(BindingFlags.Public | BindingFlags.Instance))
d9203 6
a9208 3
					ParameterInfo[] p = ci.GetParameters();
					// TODO support other constructors
					if(p.Length == 1)
d9210 1
a9210 2
						// TODO support other types
						if(p[0].ParameterType == typeof(string))
d9212 7
a9218 2
							TypeWrapper returnType = ClassLoaderWrapper.GetWrapperFromType(p[0].ParameterType);
							methods.Add(new DynamicOnlyMethodWrapper(this, "value", "()" + returnType.SigName, returnType, TypeWrapper.EmptyArray));
d9222 13
a9234 1
				foreach(FieldInfo fi in attributeType.GetFields(BindingFlags.Public | BindingFlags.Instance))
d9236 41
a9276 2
					// TODO add other field validations to make sure it is appropriate
					if(!fi.IsInitOnly)
d9278 1
a9278 3
						// TODO support other types
						// TODO handle the case where the field name is "value"
						if(fi.FieldType == typeof(bool))
d9280 1
a9280 6
							TypeWrapper returnType = ClassLoaderWrapper.GetWrapperFromType(fi.FieldType);
							methods.Add(new DynamicOnlyMethodWrapper(this, fi.Name, "()" + returnType.SigName, returnType, TypeWrapper.EmptyArray));
						}
						else if(fi.FieldType.IsEnum)
						{
							foreach(TypeWrapper tw in ClassLoaderWrapper.GetWrapperFromType(fi.FieldType).InnerClasses)
d9282 1
a9282 1
								if(tw is EnumEnumTypeWrapper)
d9284 1
a9284 2
									methods.Add(new DynamicOnlyMethodWrapper(this, fi.Name, "()" + tw.SigName, tw, TypeWrapper.EmptyArray));
									break;
d9286 1
d9289 50
d9348 1
a9348 2
				// HACK
				if(mw.Name == "value")
d9350 48
a9397 9
					return null;
				}
				else if(mw.ReturnType == PrimitiveTypeWrapper.BOOLEAN)
				{
					return JVM.Library.box(false);
				}
				else if(mw.ReturnType is EnumEnumTypeWrapper)
				{
					return mw.ReturnType.GetFieldWrapper("__unspecified", mw.ReturnType.SigName).GetValue(null);
d9544 1
a9544 1
				private CustomAttributeBuilder MakeCustomAttributeBuilder(object annotation)
d9546 36
a9581 3
					// TODO implement this
					object[] arr = (object[])annotation;
					if(arr.Length == 2)
d9583 2
a9584 1
						return new CustomAttributeBuilder(type.GetConstructor(Type.EmptyTypes), new object[0]);
d9586 1
a9586 1
					else if(arr.Length == 4 && "value".Equals(arr[2]) && arr[3] is string)
d9588 9
a9596 1
						return new CustomAttributeBuilder(type.GetConstructor(new Type[] { typeof(string) }), new object[] { arr[3] });
d9598 1
a9598 1
					else if(arr.Length == 6 && "value".Equals(arr[2]) && arr[3] is string && arr[5] is bool)
d9600 1
a9600 3
						FieldInfo field = type.GetField((string)arr[4]);
						return new CustomAttributeBuilder(type.GetConstructor(new Type[] { typeof(string) }), new object[] { arr[3] },
							new FieldInfo[] { field }, new object[] { arr[5] });
a9601 1
					throw new NotImplementedException();
d9604 1
a9604 1
				internal override void Apply(TypeBuilder tb, object annotation)
d9606 46
a9651 1
					tb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d9654 1
a9654 1
				internal override void Apply(ConstructorBuilder cb, object annotation)
d9656 1
a9656 1
					cb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d9659 1
a9659 1
				internal override void Apply(MethodBuilder mb, object annotation)
d9661 1
a9661 1
					mb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d9664 1
a9664 1
				internal override void Apply(FieldBuilder fb, object annotation)
d9666 1
a9666 1
					fb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d9669 1
a9669 1
				internal override void Apply(ParameterBuilder pb, object annotation)
d9671 1
a9671 1
					pb.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d9674 1
a9674 1
				internal override void Apply(AssemblyBuilder ab, object annotation)
d9676 1
a9676 1
					ab.SetCustomAttribute(MakeCustomAttributeBuilder(annotation));
d10492 17
a10508 31
				// TODO for the time being we only support attributes that have either
				// a default constructor or single arg string constructor
				ConstructorInfo defaultConstructor = null;
				ConstructorInfo maxArgConstructor = null;
				int maxArgs = -1;
				int constructorCount = 0;
				foreach(ConstructorInfo ci in type.GetConstructors(BindingFlags.Public | BindingFlags.Instance))
				{
					constructorCount++;
					int args = ci.GetParameters().Length;
					if(args == 0)
					{
						defaultConstructor = ci;
					}
					if(args > maxArgs)
					{
						maxArgs = args;
						maxArgConstructor = ci;
					}
				}
				if(constructorCount == 1)
				{
					if(defaultConstructor != null)
					{
						return true;
					}
					if(maxArgs == 1)
					{
						return maxArgConstructor.GetParameters()[0].ParameterType == typeof(string);
					}
				}
@


1.166.2.1
log
@Back ported fix for ArrayIndexOutOfBoundsException in generic metadata reflection on dynamically compiled types.
@
text
@d6800 1
a6800 1
						genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
d6810 1
a6810 1
						genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
@


1.166.2.2
log
@Fixed infinite recursion bug when DotNetTypeWrapper.GetName() was used on DerivedType where DerivedType extends BaseType<DerivedType>.
@
text
@a3080 13
		internal static bool IsPrimitiveType(Type type)
		{
			return type == BYTE.type
				|| type == CHAR.type
				|| type == DOUBLE.type
				|| type == FLOAT.type
				|| type == INT.type
				|| type == LONG.type
				|| type == SHORT.type
				|| type == BOOLEAN.type
				|| type == VOID.type;
		}

d8710 1
a8710 1
				foreach(Type t1 in Whidbey.GetGenericArguments(type))
a8711 1
					Type t = t1;
d8713 2
a8714 9
					// NOTE we can't use ClassLoaderWrapper.GetWrapperFromType() here to get t's name,
					// because we might be resolving a generic type that refers to a type that is in
					// the process of being constructed.
					//
					// For example:
					//   class Base<T> { } 
					//   class Derived : Base<Derived> { }
					//
					while(ClassLoaderWrapper.IsVector(t))
d8716 1
a8716 1
						t = t.GetElementType();
d8719 1
a8719 1
					if(PrimitiveTypeWrapper.IsPrimitiveType(t))
d8721 1
a8721 1
						sb.Append(ClassLoaderWrapper.GetWrapperFromType(t).SigName);
d8725 1
a8725 13
						string s;
						if(ClassLoaderWrapper.IsRemappedType(t))
						{
							s = ClassLoaderWrapper.GetWrapperFromType(t).Name;
						}
						else if(AttributeHelper.IsJavaModule(t.Module))
						{
							s = CompiledTypeWrapper.GetName(t);
						}
						else
						{
							s = DotNetTypeWrapper.GetName(t);
						}
@


1.166.2.3
log
@back ported the follwing fixes and incremented version to 0.34.0.4:
- magic assembly type for assembly attribute annotations (bug #1721688)
- LocalVariableTable robustness fix (bug #1765952)
- public interfaces extending non-public interfaces
- parameter annotations on redirected contructors
- casting ghost interface arrays (bug #1757889)
- JNI NewObject fix
- make sure all implemented interface methods on .NET types are public (so that ikvmstub generates jars that javac is happy with)
@
text
@d2498 1
a2498 1
				return (!elem1.IsNonPrimitiveValueType && elem1.IsSubTypeOf(elem2)) || (rank1 == rank2 && elem2.IsGhost && elem1 == CoreClasses.java.lang.Object.Wrapper);
d3551 1
a3551 1
				if(!wrapper.IsInterface || wrapper.IsPublic)
d3562 1
a3562 1
					if(!wrapper.IsInterface && wrapper.IsPublic)
d3613 1
a3613 1
				if(wrapper.IsPublic)
a4055 5
					if(iface.IsPublic && this.wrapper.IsInterface)
					{
						// for interfaces, we only need miranda methods for non-public interfaces that we extend
						continue;
					}
d4993 9
d8414 2
a8415 2
			int skip = 0;
			if(mb.IsStatic && !mw.IsStatic && mw.Name != "<init>")
d8417 1
a8417 6
				skip = 1;
			}
			object[][] attribs = new object[parameters.Length - skip][];
			for(int i = skip; i < parameters.Length; i++)
			{
				attribs[i - skip] = parameters[i].GetCustomAttributes(false);
d10018 2
a10019 2
				// make sure that all the interface methods that we implement are available as public methods,
				// otherwise javac won't like the class.
d10025 1
a10025 3
						// we only handle public (or nested public) types, because we're potentially adding a
						// method that should be callable by anyone through the interface
						if(IsVisible(interfaces[i]))
d10030 1
a10030 2
								if((!map.TargetMethods[j].IsPublic || map.TargetMethods[j].Name != map.InterfaceMethods[j].Name)
									&& map.TargetMethods[j].DeclaringType == type)
d10038 1
a10038 3
										string key = name + sig;
										MethodWrapper existing = (MethodWrapper)methodsList[key];
										if(existing == null && BaseTypeWrapper != null)
d10046 3
a10048 1
										if(existing == null || existing is ByRefMethodWrapper || existing.IsStatic || !existing.IsPublic)
a10049 3
											// TODO if existing != null, we need to rename the existing method (but this is complicated because
											// it also affects subclasses). This is especially required is the existing method is abstract,
											// because otherwise we won't be able to create any subclasses in Java.
a10058 1

@


1.165
log
@- .NET "generic class loaders" now return something sensible when toString() is called on them.
- Ikvmc no longer warns about generic stubs.
- Ikvmstub now has WHIDBEY conditional code to properly determine if a class is a generic type instance (instead of the name based hack).
- Fixed .NET generic type name mangling bug (nested generic types were double encoded).
- Added support for loading .NET generic type stubs.
- Fixed several .NET generic type loading bugs.
- Fixed ikvm.runtime.Util.getInstanceTypeFromClass() to return null instead of throw an exception when it is called on a "dynamic only" class.
@
text
@d1556 18
a1573 1
			CustomAttributeBuilder constantValueAttrib = new CustomAttributeBuilder(typeofConstantValueAttribute.GetConstructor(new Type[] { constantValue.GetType() }), new object[] { constantValue });
@


1.164
log
@Fixed several .NET 2.0 "ReflectionOnly" bugs.
@
text
@d8709 7
a8715 2
						s = s.Replace("__", "$$005F$$005F");
						s = s.Replace(".", "__");
@


1.163
log
@Implemented support in ikvmc to automatically add an implementation of IDisposable or IEnumerable to classes that implement java.io.Closeable or java.lang.Iterable.
@
text
@d172 1
d739 25
d1377 13
d2880 7
d2895 1
a2895 1
#endif
d8350 7
d8362 9
a8370 1
			return mw.GetMethod().GetCustomAttributes(false);
d8375 9
a8383 1
			ParameterInfo[] parameters = mw.GetMethod().GetParameters();
d8397 7
d8409 7
d9300 14
a9313 1
				object target = null;
a9316 2
					ArrayList targets = new ArrayList();
					targets.Add(AnnotationDefaultAttribute.TAG_ARRAY);
d9318 1
a9318 21
					if((aua.ValidOn & (AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Delegate | AttributeTargets.Assembly)) != 0)
					{
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "TYPE" });
					}
					if((aua.ValidOn & AttributeTargets.Constructor) != 0)
					{
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "CONSTRUCTOR" });
					}
					if((aua.ValidOn & AttributeTargets.Field) != 0)
					{
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "FIELD" });
					}
					if((aua.ValidOn & AttributeTargets.Method) != 0)
					{
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "METHOD" });
					}
					if((aua.ValidOn & AttributeTargets.Parameter) != 0)
					{
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/ElementType;", "PARAMETER" });
					}
					target = JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Target", "value", (object[])targets.ToArray() });
d9321 23
d9345 1
a9345 1
										target,
d9689 6
a9694 1
				Type underlyingType = Enum.GetUnderlyingType(obj.GetType());
d9861 1
a9861 1
						object val = fields[i].GetRawConstantValue();
d10500 7
d10509 18
@


1.162
log
@Fixed previous fix.
@
text
@a3718 1
					ImplementInterfaces(wrapper.Interfaces, new ArrayList());
a3864 21
			private void ImplementInterfaces(TypeWrapper[] interfaces, ArrayList interfaceList)
			{
				foreach(TypeWrapper iface in interfaces)
				{
					if(!interfaceList.Contains(iface))
					{
						interfaceList.Add(iface);
						// skip interfaces that don't really exist
						// (e.g. delegate "Method" and attribute "Annotation" inner interfaces)
						if(!iface.IsDynamicOnly)
						{
							// NOTE we're using TypeAsBaseType for the interfaces!
							typeBuilder.AddInterfaceImplementation(iface.TypeAsBaseType);
						}
						// NOTE we're recursively "implementing" all interfaces that we inherit from the interfaces we implement.
						// The C# compiler also does this and the Compact Framework requires it.
						ImplementInterfaces(iface.Interfaces, interfaceList);
					}
				}
			}

d4716 4
a4772 16
#if STATIC_COMPILER
							// if we implement a ghost interface, add an implicit conversion to the ghost reference value type
							// TODO do this for indirectly implemented interfaces (interfaces implemented by interfaces) as well
							if(interfaces[i].IsGhost && wrapper.IsPublic)
							{
								MethodBuilder mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, interfaces[i].TypeAsSignatureType, new Type[] { wrapper.TypeAsSignatureType });
								ILGenerator ilgen = mb.GetILGenerator();
								LocalBuilder local = ilgen.DeclareLocal(interfaces[i].TypeAsSignatureType);
								ilgen.Emit(OpCodes.Ldloca, local);
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Stfld, interfaces[i].GhostRefField);
								ilgen.Emit(OpCodes.Ldloca, local);
								ilgen.Emit(OpCodes.Ldobj, interfaces[i].TypeAsSignatureType);
								ilgen.Emit(OpCodes.Ret);
							}
#endif
d4978 73
@


1.161
log
@Fixed interface implementation to recurse all the way up.
@
text
@d3719 1
a3719 1
					ImplementInterfaces(wrapper.Interfaces, null);
d3870 1
a3870 1
					if(iface.IsDynamicOnly)
d3872 1
d3875 1
a3875 16
					}
					else if(interfaceList != null && interfaceList.Contains(iface))
					{
						// we've already done this interface
					}
					else
					{
						// NOTE we're using TypeAsBaseType for the interfaces!
						typeBuilder.AddInterfaceImplementation(iface.TypeAsBaseType);
					}
					// NOTE we're recursively "implementing" all interfaces that we inherit from the interfaces we implement.
					// The C# compiler also does this and the Compact Framework requires it.
					TypeWrapper[] inheritedInterfaces = iface.Interfaces;
					if(inheritedInterfaces.Length > 0)
					{
						if(interfaceList == null)
d3877 2
a3878 1
							interfaceList = new ArrayList();
d3880 3
a3882 1
						ImplementInterfaces(inheritedInterfaces, interfaceList);
@


1.160
log
@Made method parameter name handling robust against invalid or incomplete local variables tables.
@
text
@d3719 1
a3730 41
#endif // STATIC_COMPILER
					ArrayList interfaceList = null;
					TypeWrapper[] interfaces = wrapper.Interfaces;
					for(int i = 0; i < interfaces.Length; i++)
					{
						// skip interfaces that don't really exist
						// (e.g. delegate "Method" and attribute "Annotation" inner interfaces)
						if(!interfaces[i].IsDynamicOnly)
						{
							// NOTE we're using TypeAsBaseType for the interfaces!
							typeBuilder.AddInterfaceImplementation(interfaces[i].TypeAsBaseType);
						}
						// NOTE we're also "implementing" all interfaces that we inherit from the interfaces we implement.
						// The C# compiler also does this and the Compact Framework requires it.
						TypeWrapper[] inheritedInterfaces = interfaces[i].Interfaces;
						if(inheritedInterfaces.Length > 0)
						{
							if(interfaceList == null)
							{
								interfaceList = new ArrayList();
								foreach(TypeWrapper tw1 in interfaces)
								{
									if(!tw1.IsDynamicOnly)
									{
										interfaceList.Add(tw1.TypeAsBaseType);
									}
								}
							}
							foreach(TypeWrapper tw in inheritedInterfaces)
							{
								if(!tw.IsDynamicOnly && !interfaceList.Contains(tw.TypeAsBaseType))
								{
									interfaceList.Add(tw.TypeAsBaseType);
									// NOTE we don't have to recurse upwards, because we assume that
									// all interfaces follow this rule (of explicitly listed all of the base interfaces)
									typeBuilder.AddInterfaceImplementation(tw.TypeAsBaseType);
								}
							}
						}
					}
#if STATIC_COMPILER
d3766 1
d3866 32
@


1.159
log
@- Regenerated mscorlib.jar and System.jar
- Changed RetentionPolicy on .NET custom attribute annotations to RUNTIME, so that ikvmc sees them (fixes a regression).
- Handled method signature clashes in .NET types.
@
text
@d6992 1
a6992 2
				int bias = 1;
				if(m.IsStatic)
d6994 3
a6996 1
					bias = 0;
d6998 1
a6998 2
				ParameterBuilder[] parameterBuilders = new ParameterBuilder[m.ArgMap.Length - bias];
				for(int i = bias; i < m.ArgMap.Length; i++)
d7000 1
d7003 1
a7003 1
						for(int j = 0; j < localVars.Length; j++)
d7005 1
a7005 1
							if(localVars[j].index == i && parameterBuilders[i - bias] == null)
d7007 1
a7007 2
								string name = localVars[j].name;
								if(parameterNames != null && parameterNames[i - bias] != null)
d7009 2
a7010 10
									name = parameterNames[i - bias];
								}
								ParameterBuilder pb;
								if(mb is MethodBuilder)
								{
									pb = ((MethodBuilder)mb).DefineParameter(m.ArgMap[i] + 1 - bias, ParameterAttributes.None, name);
								}
								else
								{
									pb = ((ConstructorBuilder)mb).DefineParameter(m.ArgMap[i], ParameterAttributes.None, name);
a7011 2
								parameterBuilders[i - bias] = pb;
								break;
d7014 1
a7016 5
				return parameterBuilders;
			}
			else
			{
				return AddParameterNames(mb, m.Signature, parameterNames);
d7018 1
@


1.158
log
@Added support for stubbing abstract methods that contain unsupported argument types (ByRef and Pointers)
@
text
@d9241 1
a9241 1
										JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Retention", "value", new object[] { AnnotationDefaultAttribute.TAG_ENUM, "Ljava/lang/annotation/RetentionPolicy;", "CLASS" } })
a9713 2
			ArrayList fieldsList = new ArrayList();
			ArrayList methodsList = new ArrayList();
d9736 1
d9759 2
a9760 1
				methodsList.Add(new EnumWrapMethodWrapper(this, fieldType));
d9764 1
d9779 3
d9787 2
a9788 1
					methodsList.Add(new DelegateMethodWrapper(this, (DelegateInnerClassTypeWrapper)iface));
a9790 2
				bool fabricateDefaultCtor = type.IsValueType;

d9800 3
a9802 1
						if(fabricateDefaultCtor && !constructors[i].IsStatic && sig == "()V")
d9804 1
a9804 1
							fabricateDefaultCtor = false;
a9805 2
						// TODO handle name/signature clash
						methodsList.Add(CreateMethodWrapper(name, sig, args, ret, constructors[i], false));
d9809 1
a9809 1
				if(fabricateDefaultCtor)
d9812 1
a9812 1
					methodsList.Add(new ValueTypeDefaultCtor(this));
d9838 7
a9844 2
							// TODO handle name/signature clash
							methodsList.Add(CreateMethodWrapper(name, sig, args, ret, methods[i], false));
a9856 1
					Hashtable clash = null;
d9881 3
a9883 9
										if(clash == null)
										{
											clash = new Hashtable();
											foreach(MethodWrapper mw in methodsList)
											{
												clash.Add(mw.Name + mw.Signature, null);
											}										
										}
										if(!clash.ContainsKey(name + sig))
d9885 1
a9885 2
											clash.Add(name + sig, null);
											methodsList.Add(CreateMethodWrapper(name, sig, args, ret, map.InterfaceMethods[j], true));
a9900 1
					Hashtable h = new Hashtable();
d9908 2
a9909 1
								if(!h.ContainsKey(m.Name + m.Signature))
a9910 2
									h.Add(m.Name + m.Signature, "");
									// TODO handle name/sig clash (what should we do?)
d9915 1
a9915 1
											methodsList.Add(new FinalizeMethodWrapper(this));
d9919 1
a9919 1
											methodsList.Add(new CloneMethodWrapper(this));
d9929 1
a9929 1
										methodsList.Add(new BaseFinalMethodWrapper(this, m));
d9937 3
a9940 2
			SetMethods((MethodWrapper[])methodsList.ToArray(typeof(MethodWrapper)));
			SetFields((FieldWrapper[])fieldsList.ToArray(typeof(FieldWrapper)));
@


1.157
log
@Restructured mutual dependency of IKVM.Runtime and IKVM.GNU.Classpath to work around Mono C# compiler limitation.
@
text
@d1598 1
d1692 27
d4838 4
d5030 45
d9838 4
d9977 20
@


1.156
log
@- fixed handling of bridge methods with covariant return types in ikvmc (to allow other .NET languages to call these methods)
- added EditorBrowsable(Never) attribute to bridge and synthetic methods
@
text
@a8648 5
				// HACK make an exception for the vm/library interface
				if(type == typeof(ikvm.@@internal.LibraryVMInterface))
				{
					return true;
				}
@


1.155
log
@- Changed ikvmc to fail with a Link Error when it detects a loader constraints violation (instead of emitting code that throws a LinkageError at runtime).
@
text
@d6137 17
d6350 15
@


1.154
log
@- Fixed AnnotationBuilder to add ImplementsAttribute to annotation attribute, so that reflection correctly reports the implemented annotation interface.
- Fixed AnnotationBuilder to ignore annotation attribute properties of type annotation.
@
text
@d4175 3
d4196 3
@


1.153
log
@Fixed handling of non-vector arrays.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d5128 1
d5434 13
a5446 10
								PropertyBuilder pb = attributeTypeBuilder.DefineProperty(o.methods[i].Name, PropertyAttributes.None, argType, Type.EmptyTypes);
								MethodBuilder setter = attributeTypeBuilder.DefineMethod("set_" + o.methods[i].Name, MethodAttributes.Public, typeof(void), new Type[] { argType });
								pb.SetSetMethod(setter);
								ilgen = setter.GetILGenerator();
								EmitSetValueCall(annotationAttributeBaseType, ilgen, o.methods[i].Name, o.methods[i].ReturnType, 1);
								ilgen.Emit(OpCodes.Ret);
								MethodBuilder getter = attributeTypeBuilder.DefineMethod("get_" + o.methods[i].Name, MethodAttributes.Public, argType, Type.EmptyTypes);
								pb.SetGetMethod(getter);
								// TODO implement the getter method
								getter.GetILGenerator().ThrowException(typeof(NotImplementedException));
@


1.152
log
@Fixed application of AnnotationAttributeAttribute to use JVM.LoadType to get the type from the ReflectionOnly assembly on WHIDBEY
@
text
@d2586 1
a2586 1
				while(type.IsArray)
d7540 1
a7540 1
			Debug.Assert(!type.IsArray);
d8462 1
a8462 1
			Debug.Assert(!type.IsArray && !AttributeHelper.IsJavaModule(type.Module));
d9241 1
a9241 1
			Debug.Assert(!(type.IsArray), type.FullName);
@


1.151
log
@*** empty log message ***
@
text
@d3821 1
a3821 1
						CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(AnnotationAttributeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { annotationAttributeType });
@


1.150
log
@*** empty log message ***
@
text
@d8798 44
d8856 1
d8925 2
a8926 1
					return typeof(object);
d9104 1
a9104 1
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "java.lang.annotation.ElementType", "TYPE" });
d9108 1
a9108 1
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "java.lang.annotation.ElementType", "CONSTRUCTOR" });
d9112 1
a9112 1
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "java.lang.annotation.ElementType", "FIELD" });
d9116 1
a9116 1
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "java.lang.annotation.ElementType", "METHOD" });
d9120 1
a9120 1
						targets.Add(new object[] { AnnotationDefaultAttribute.TAG_ENUM, "java.lang.annotation.ElementType", "PARAMETER" });
d9127 1
a9127 1
										JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), new object[] { AnnotationDefaultAttribute.TAG_ANNOTATION, "java.lang.annotation.Retention", "value", new object[] { AnnotationDefaultAttribute.TAG_ENUM, "java.lang.annotation.RetentionPolicy", "CLASS" } })
@


1.149
log
@*** empty log message ***
@
text
@d8409 1
d8740 153
a8896 1
			// TODO we should surface all of the appropriate annotations (e.g. Retention and Target)
d8926 1
a8928 1
							// TODO handle the case where the field name is "value"
d8932 11
d8961 4
d9046 40
d10018 4
@


1.148
log
@*** empty log message ***
@
text
@d495 9
d2831 8
d3299 18
d3354 4
d3389 1
d3750 17
a4872 21

					TypeBuilder enumBuilder = null;
					if(true)
					{
//						// For Java 5 Enum types, we generate a nested .NET enum
//						if(classFile.IsEnum)
//						{
//							// TODO if wrapper is inner class, the Enum should be defined as an innerclass as well
//							enumBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(classFile.Name + "Enum", TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.Public | TypeAttributes.Serializable, typeof(Enum));
//							AttributeHelper.HideFromJava(enumBuilder);
//							enumBuilder.DefineField("value__", typeof(int), FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
//							for(int i = 0; i < classFile.Fields.Length; i++)
//							{
//								if(classFile.Fields[i].IsEnum)
//								{
//									FieldBuilder fieldBuilder = enumBuilder.DefineField(classFile.Fields[i].Name, enumBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
//									fieldBuilder.SetConstant(i);
//								}
//							}
//						}
					}
d4974 5
a4978 1
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, this.ReflectiveModifiers, Metadata.Create(classFile));
a5067 1
				private ConstructorBuilder defaultConstructor;
a5189 1
					defaultConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
d5191 37
d5242 18
d5270 78
a5347 1
					ILGenerator ilgen = defaultConstructor.GetILGenerator();
d5377 2
a5378 1
							MethodBuilder mb = attributeTypeBuilder.DefineMethod(o.methods[i].Name, MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot, o.methods[i].ReturnTypeForDefineMethod, o.methods[i].GetParametersForDefineMethod());
a5415 6
								else if(o.methods[i].ReturnType == PrimitiveTypeWrapper.VOID)
								{
									// TODO what to do here?
									ilgen.Emit(OpCodes.Pop);
									ilgen.Emit(OpCodes.Pop);
								}
d5427 17
d6484 18
d6718 4
d6723 6
a6728 1
			internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers, Metadata metadata)
d6736 4
d6848 18
d8270 12
@


1.147
log
@*** empty log message ***
@
text
@d5625 1
a5625 1
							if(methods[i].IsLinked && methods[i].Name != "<init>")
d9182 3
a9184 1
					if(MakeMethodDescriptor(constructors[i], out name, out sig))
d9191 1
a9191 1
						methodsList.Add(CreateMethodWrapper(name, sig, constructors[i], false));
d9212 3
a9214 1
						if(MakeMethodDescriptor(methods[i], out name, out sig))
d9225 1
a9225 1
							methodsList.Add(CreateMethodWrapper(name, sig, methods[i], false));
d9247 3
a9249 1
									if(MakeMethodDescriptor(map.InterfaceMethods[j], out name, out sig))
d9270 1
a9270 1
											methodsList.Add(CreateMethodWrapper(name, sig, map.InterfaceMethods[j], true));
d9362 1
a9362 1
		private bool MakeMethodDescriptor(MethodBase mb, out string name, out string sig)
d9368 2
d9375 1
a9375 1
			TypeWrapper[] args = new TypeWrapper[parameters.Length];
d9383 2
d9393 2
d9404 2
d9416 1
a9416 1
				TypeWrapper ret = PrimitiveTypeWrapper.VOID;
d9436 1
d9439 1
a9439 1
				TypeWrapper ret = ClassLoaderWrapper.GetWrapperFromType(type);
d9615 1
a9615 1
		private MethodWrapper CreateMethodWrapper(string name, string sig, MethodBase mb, bool privateInterfaceImplHack)
d9655 1
a9655 2
				// TODO pass in the argument and return types
				return new ByRefMethodWrapper(args, byrefs, this, name, sig, mb, null, null, mods, false);
d9661 1
a9661 2
					// TODO pass in the argument and return types
					return new SmartConstructorMethodWrapper(this, name, sig, (ConstructorInfo)mb, null, mods, MemberFlags.None);
d9665 1
a9665 2
					// TODO pass in the argument and return types
					return new SmartCallMethodWrapper(this, name, sig, (MethodInfo)mb, null, null, mods, MemberFlags.None, SimpleOpCode.Call, SimpleOpCode.Callvirt);
a9727 9
			// TODO instead of linking here, we should just pre-link in LazyPublishMembers
			foreach(MethodWrapper mw in GetMethods())
			{
				mw.Link();
			}
			foreach(FieldWrapper fw in GetFields())
			{
				fw.Link();
			}
@


1.146
log
@*** empty log message ***
@
text
@d2737 1
a2737 3
				ilgen.Emit(OpCodes.Isinst, TypeAsTBD);
				ilgen.Emit(OpCodes.Ldnull);
				ilgen.Emit(OpCodes.Cgt_Un);
d8937 2
a8938 1
			// NOTE if the reference on the stack is null, we *want* the NullReferenceException, so we don't use TypeWrapper.EmitUnbox
d8942 1
d8948 3
a8950 29
				DotNetTypeWrapper tw = (DotNetTypeWrapper)this.DeclaringType;
				if(ilgen.IsBoxPending(tw.type))
				{
					ilgen.ClearPendingBox();
				}
				else
				{
					ilgen.Emit(OpCodes.Unbox, tw.type);
					// FXBUG the .NET 1.1 verifier doesn't understand that ldobj on an enum that has an underlying type
					// of byte or short that the resulting type on the stack is an int32, so we have to
					// to it the hard way. Note that this is fixed in Whidbey.
					Type underlyingType = Enum.GetUnderlyingType(tw.type);
					if(underlyingType == typeof(sbyte) || underlyingType == typeof(byte))
					{
						ilgen.Emit(OpCodes.Ldind_I1);
					}
					else if(underlyingType == typeof(short) || underlyingType == typeof(ushort))
					{
						ilgen.Emit(OpCodes.Ldind_I2);
					}
					else if(underlyingType == typeof(int) || underlyingType == typeof(uint))
					{
						ilgen.Emit(OpCodes.Ldind_I4);
					}
					else if(underlyingType == typeof(long) || underlyingType == typeof(ulong))
					{
						ilgen.Emit(OpCodes.Ldind_I8);
					}
				}
d9687 1
a9687 3
			ilgen.Emit(OpCodes.Isinst, type);
			ilgen.Emit(OpCodes.Ldnull);
			ilgen.Emit(OpCodes.Cgt_Un);
@


1.145
log
@*** empty log message ***
@
text
@d7722 9
a7730 1
				ilgen.Emit(mbHelper.IsStatic ? OpCodes.Call : OpCodes.Callvirt, mbHelper);
d9067 60
d9318 20
a9337 1
									methodsList.Add(new BaseFinalMethodWrapper(this, m));
@


1.144
log
@*** empty log message ***
@
text
@d2434 4
a2437 1
			string mangledName = this.Name + "/" + ifmethod.Name + ifmethod.Signature;
@


1.143
log
@*** empty log message ***
@
text
@d3519 1
a3519 1
								Tracer.Warning(Tracer.Compiler, "Unable to load outer class {0} for innner class {1} ({2}: {3})", outerClassName, f.Name, x.GetType().Name, x.Message);
@


1.142
log
@*** empty log message ***
@
text
@d1840 13
d1858 1
a1858 1
				return erased || (TypeAsSignatureType.IsPrimitive && !IsPrimitive) || (IsRemapped && this is DotNetTypeWrapper);
d8354 2
a8355 3
				// HACK make an exception for the two published types
				if(type == typeof(ikvm.@@internal.LibraryVMInterface)
					|| type == typeof(gnu.classpath.Pointer))
a9057 8
			// HACK don't expose any of the members of gnu.classpath.Pointer
			// (for security reasons)
			if(type == typeof(gnu.classpath.Pointer))
			{
				SetMethods(MethodWrapper.EmptyArray);
				SetFields(FieldWrapper.EmptyArray);
				return;
			}
@


1.141
log
@*** empty log message ***
@
text
@d9698 1
@


1.140
log
@*** empty log message ***
@
text
@d3433 5
a3437 1
						fields[i] = new ConstantFieldWrapper(wrapper, null, fld.Name, fld.Signature, fld.Modifiers, null, fld.ConstantValue, MemberFlags.LiteralField);
d7800 1
a7800 1
				MemberFlags flags = MemberFlags.LiteralField;
d9096 1
a9096 1
						fieldsList.Add(new ConstantFieldWrapper(this, fieldType, name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], val, MemberFlags.LiteralField));
d9524 1
a9524 1
				return new ConstantFieldWrapper(this, type, name, type.SigName, modifiers, field, null, MemberFlags.LiteralField);
@


1.139
log
@*** empty log message ***
@
text
@d1451 22
@


1.138
log
@*** empty log message ***
@
text
@d3459 1
d3585 14
d3742 1
a3742 1
					if(classFile.IsInternal || (classFile.Modifiers & (Modifiers.Synthetic | Modifiers.Annotation | Modifiers.Enum)) != 0)
@


1.137
log
@*** empty log message ***
@
text
@a1098 8
#if !COMPACT_FRAMEWORK
		internal static void SetJavaModule(ModuleBuilder moduleBuilder)
		{
			CustomAttributeBuilder ikvmModuleAttr = new CustomAttributeBuilder(typeofJavaModuleAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			moduleBuilder.SetCustomAttribute(ikvmModuleAttr);
		}
#endif //!COMPACT_FRAMEWORK

d1449 5
d5275 2
a5276 1
					AttributeHelper.SetJavaModule(mod);
@


1.136
log
@*** empty log message ***
@
text
@d891 6
a896 1
			// TODO reflection doesn't support volatile
d4197 8
d4209 1
d4216 1
a4218 1
						// TODO the field should be marked as modreq(IsVolatile), but Reflection.Emit doesn't have a way of doing this
d4221 1
@


1.135
log
@*** empty log message ***
@
text
@d539 9
d1816 1
a1816 1
		internal bool IsErased
d1820 2
a1821 1
				return IsUnloadable || IsGhostArray || IsDynamicOnly;
d2844 2
a2845 2
			} 
		} 
d4119 1
a4119 1
				bool setNameSig = typeWrapper.IsErased;
d4130 4
a4133 1
				bool setModifiers = false;
a4170 1
					bool isWrappedFinal = fw is GetterFieldWrapper;
d4173 1
d4187 1
d4189 1
d4230 1
a4230 11
#if STATIC_COMPILER
						if(setNameSig)
						{
							setNameSig = false;
							AttributeHelper.SetNameSig(getter, fld.Name, fld.Signature);
						}
						if(fld.IsTransient)
						{
							AttributeHelper.SetModifiers(getter, fld.Modifiers, fld.IsInternal);
						}
#endif // STATIC_COMPILER
d4246 19
d4268 1
a4268 3
				// if the Java modifiers cannot be expressed in .NET, we emit the Modifiers attribute to store
				// the Java modifiers
				if(setModifiers || fld.IsInternal || (fld.Modifiers & (Modifiers.Synthetic | Modifiers.Enum)) != 0)
d4270 18
a4287 18
					AttributeHelper.SetModifiers(field, fld.Modifiers, fld.IsInternal);
				}
				if(setNameSig)
				{
					AttributeHelper.SetNameSig(field, fld.Name, fld.Signature);
				}
				if(fld.DeprecatedAttribute)
				{
					AttributeHelper.SetDeprecatedAttribute(field);
				}
				if(fld.GenericSignature != null)
				{
					AttributeHelper.SetSignatureAttribute(field, fld.GenericSignature);
				}
#else // STATIC_COMPILER
				if(setModifiers)
				{
					// shut up the compiler
d4807 9
a4815 1
									annotation.Apply((FieldBuilder)fields[i].GetField(), def);
d5782 1
a5782 1
					bool setNameSig = methods[index].ReturnType.IsErased;
d5785 1
a5785 1
						setNameSig |= tw.IsErased;
d7404 15
d7425 12
d7842 12
d7891 11
a7901 1
			return fw.GetField().GetCustomAttributes(false);
@


1.134
log
@*** empty log message ***
@
text
@d173 1
d182 1
a182 1
#if WHIDBEY && !COMPACT_FRAMEWORK
d198 5
d242 1
a242 1
#if STATIC_COMPILER && !COMPACT_FRAMEWORK
@


1.133
log
@*** empty log message ***
@
text
@d634 12
a645 1
#endif
d7534 2
@


1.132
log
@*** empty log message ***
@
text
@d4160 4
a4163 1
					field = typeBuilder.DefineField(fieldName, type, attribs);
@


1.131
log
@*** empty log message ***
@
text
@d1577 1
a1577 1
				Debug.Assert(!IsUnloadable && !IsVerifierType && !JVM.IsStaticCompiler);
d3082 3
d3086 1
d3384 6
a3389 2
					else if(fld.IsFinal && (JVM.IsStaticCompiler && (fld.IsPublic || fld.IsProtected))
						&& !wrapper.IsInterface && (!wrapper.classLoader.StrictFinalFieldSemantics || ReferenceEquals(wrapper.Name, StringConstants.JAVA_LANG_SYSTEM)))
d3393 1
a3536 1
#endif // STATIC_COMPILER
d3538 8
a3545 1
							typeBuilder = wrapper.DefineType(mangledTypeName, typeAttribs);
d3547 3
d4341 1
d4343 1
d4435 1
d4441 1
d4528 1
d4533 1
d4817 1
d4819 1
d5860 4
a5863 1
						MethodBuilder mb = wrapper.DefineGhostMethod(name, attribs, methods[index]);
d6703 10
a6712 1
		protected virtual void AddParameterNames(ClassFile classFile, ClassFile.Method m, MethodBase method)
d6714 1
a6714 1
			if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || GetClassLoader().EmitDebugInfo)
d6719 1
a6719 5

		protected virtual bool EmitMapXmlMethodBody(ILGenerator ilgen, ClassFile f, ClassFile.Method m)
		{
			return false;
		}
a6735 22
		protected virtual void EmitMapXmlMetadata(TypeBuilder typeBuilder, ClassFile classFile, FieldWrapper[] fields, MethodWrapper[] methods)
		{
		}

		protected virtual MethodBuilder DefineGhostMethod(string name, MethodAttributes attribs, MethodWrapper mw)
		{
			return null;
		}

		protected virtual void FinishGhost(TypeBuilder typeBuilder, MethodWrapper[] methods)
		{
		}

		protected virtual void FinishGhostStep2()
		{
		}

		protected virtual TypeBuilder DefineType(string mangledTypeName, TypeAttributes typeAttribs)
		{
			return classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs);
		}

@


1.130
log
@*** empty log message ***
@
text
@d4483 1
a4483 1
											if(DynamicClassLoader.IsSaveDebugImage)
d4485 1
d4487 1
d5174 1
d5184 1
a5184 1
					AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, DynamicClassLoader.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
d5224 1
@


1.129
log
@*** empty log message ***
@
text
@a2047 5
		internal abstract Assembly Assembly
		{
			get;
		}

d2052 1
a2052 1
				|| (IsInternal && this.Assembly == wrapper.Assembly)
d2058 1
a2058 4
			if(GetClassLoader() == wrapper.GetClassLoader() &&
				// Both types must also be in the same assembly, otherwise
				// the packages are not accessible.
				wrapper.Assembly == this.Assembly)
a2793 8
		internal override Assembly Assembly
		{
			get
			{
				return null;
			}
		}

a2907 8
		internal override Assembly Assembly
		{
			get
			{
				return null;
			}
		}

a3172 8
		internal override Assembly Assembly
		{
			get
			{
				return classLoader.GetTypeWrapperFactory().AssemblyBuilder;
			}
		}

d5559 1
a5559 1
							|| (baseMethod.IsInternal && baseMethod.DeclaringType.Assembly == wrapper.Assembly))
a7241 8
		internal override Assembly Assembly
		{
			get
			{
				return type.Assembly;
			}
		}

a8216 8
			internal override Assembly Assembly
			{
				get
				{
					return delegateType.Assembly;
				}
			}

a8365 8
			internal override Assembly Assembly
			{
				get
				{
					return attributeType.Assembly;
				}
			}

a8843 8
		internal override Assembly Assembly
		{
			get
			{
				return type.Assembly;
			}
		}

a9561 8
		internal override Assembly Assembly
		{
			get
			{
				return ultimateElementTypeWrapper.Assembly;
			}
		}

@


1.128
log
@*** empty log message ***
@
text
@d3413 1
a3413 1
						&& !wrapper.IsInterface && (!JVM.StrictFinalFieldSemantics || ReferenceEquals(wrapper.Name, StringConstants.JAVA_LANG_SYSTEM)))
d3641 1
a3641 1
					if(!JVM.NoStackTraceInfo)
d3697 1
a3697 1
					if(!JVM.NoStackTraceInfo)
d3813 1
a3813 1
					new MethodAnalyzer(wrapper, null, classFile, m, null);
d4165 1
a4165 1
						else if(wrapper.IsInterface || JVM.StrictFinalFieldSemantics)
d4507 1
a4507 1
										if(JVM.NoJniStubs)
d5256 1
a5256 5
#if STATIC_COMPILER
				private static readonly Type localRefStructType = StaticCompiler.GetType("IKVM.Runtime.JNI+Frame");
#else
				private static readonly Type localRefStructType = typeof(IKVM.Runtime.JNI.Frame);
#endif
d6704 1
a6704 1
			if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || JVM.Debug || DynamicClassLoader.IsSaveDebugImage)
d9267 1
a9267 1
						for(int i = 0; i < interfaces.Length; i++)
@


1.127
log
@*** empty log message ***
@
text
@d1790 16
d2490 4
a2493 2
			// make sure we don't do the same method twice
			if(doneSet.ContainsKey(this))
d2634 6
d2670 6
d3597 7
a3603 2
						// NOTE we're using TypeAsBaseType for the interfaces!
						typeBuilder.AddInterfaceImplementation(interfaces[i].TypeAsBaseType);
d3614 4
a3617 1
									interfaceList.Add(tw1.TypeAsBaseType);
d3622 1
a3622 1
								if(!interfaceList.Contains(tw.TypeAsBaseType))
d4106 1
a4106 1
				bool setNameSig = typeWrapper.IsUnloadable || typeWrapper.IsGhostArray;
d5684 1
a5684 1
							if(name != baseMethods[index].RealName)
d5738 1
a5738 1
					bool setNameSig = methods[index].ReturnType.IsUnloadable || methods[index].ReturnType.IsGhostArray;
d5741 1
a5741 1
						setNameSig |= tw.IsUnloadable || tw.IsGhostArray;
a8231 1
			private Type type;
d8239 1
a8239 2
				Type[] args = new Type[parameters.Length];
				TypeWrapper[] argTypeWrappers = new TypeWrapper[args.Length];
d8241 1
a8241 1
				for(int i = 0; i < args.Length; i++)
d8243 1
a8243 2
					args[i] = parameters[i].ParameterType;
					argTypeWrappers[i] = ClassLoaderWrapper.GetWrapperFromType(args[i]);
d8248 1
a8248 20
				MethodInfo method = null;
#if WHIDBEY && !STATIC_COMPILER
				if(!delegateType.Assembly.ReflectionOnly)
#endif // WHIDBEY && !STATIC_COMPILER
				{
					// HACK the class loader that defines the delegate is hardly the right one for this inner class,
					// but we know that we'll only ever generate one assembly, so this will work.
					TypeWrapperFactory factory = classLoader.GetTypeWrapperFactory();
					ModuleBuilder moduleBuilder = factory.ModuleBuilder;
					// NOTE we chop off the prefix ("cli.") because C++/CLI doesn't like assemblies
					// that have types in the cli namespace (lame!)
					TypeBuilder typeBuilder = moduleBuilder.DefineType(factory.AllocMangledName(Name.Substring(NamePrefix.Length)), TypeAttributes.NotPublic | TypeAttributes.Interface | TypeAttributes.Abstract);
#if STATIC_COMPILER
					AttributeHelper.HideFromJava(typeBuilder);
#endif //STATIC_COMPILER
					typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Abstract | MethodAttributes.Virtual, CallingConventions.Standard, invoke.ReturnType, args);
					type = typeBuilder.CreateType();
					method = type.GetMethod("Invoke");
				}
				MethodWrapper invokeMethod = new DelegateInnerClassMethodWrapper(this, sb.ToString(), method, returnType, argTypeWrappers);
d8253 1
a8253 1
			private class DelegateInnerClassMethodWrapper : MethodWrapper
d8255 1
a8255 2
				internal DelegateInnerClassMethodWrapper(TypeWrapper declaringType, string sig, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes)
					: base(declaringType, "Invoke", sig, method, returnType, parameterTypes, Modifiers.Public | Modifiers.Abstract, MemberFlags.None)
d8257 1
d8326 9
a8334 1
					return type;
d8339 17
a8366 8
			private class AnnotationMethodWrapper : MethodWrapper
			{
				internal AnnotationMethodWrapper(TypeWrapper declaringType, string name, TypeWrapper valueType)
					: base(declaringType, name, "()" + valueType.SigName, null, valueType, TypeWrapper.EmptyArray, Modifiers.Public | Modifiers.Abstract, MemberFlags.None)
				{
				}
			}

d8379 2
a8380 1
							methods.Add(new AnnotationMethodWrapper(this, "value", ClassLoaderWrapper.GetWrapperFromType(p[0].ParameterType)));
d8393 2
a8394 1
							methods.Add(new AnnotationMethodWrapper(this, fi.Name, ClassLoaderWrapper.GetWrapperFromType(fi.FieldType)));
d8479 8
d8491 9
a8499 2
					// TODO
					return null;
d8641 1
a8641 1
			internal override void EmitNewobj(ILGenerator ilgen)
d8643 24
a8666 8
				ilgen.Emit(OpCodes.Dup);
				// we know that a DelegateInnerClassTypeWrapper has only one method
				Debug.Assert(iface.GetMethods().Length == 1);
				MethodWrapper mw = iface.GetMethods()[0];
				// linking here is safe, because a delegate never references a dynamic type
				mw.Link();
				ilgen.Emit(OpCodes.Ldvirtftn, (MethodInfo)mw.GetMethod());
				ilgen.Emit(OpCodes.Newobj, delegateConstructor);
d8920 1
a8920 1
			internal override void EmitNewobj(ILGenerator ilgen)
@


1.126
log
@*** empty log message ***
@
text
@d1536 3
a1538 1
		HasStaticInitializer = 4
d1652 40
@


1.125
log
@*** empty log message ***
@
text
@a1460 18

		/*
		internal static void SetTypeMetadata(TypeBuilder typeBuilder, TypeMetadataFlags flags, string sourceFile, string[] implements)
		{
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(TypeMetadataAttribute).GetConstructor(new Type[] { typeof(TypeMetadataFlags), typeof(string), typeof(string[]) }), new object[] { flags, sourceFile, implements });
			typeBuilder.SetCustomAttribute(cab);
		}

		internal static void SetTypeMetadata(TypeBuilder typeBuilder, TypeMetadataFlags flags, string sourceFile, string[] implements,
			string name, Modifiers modifiers, Modifiers innerClassModifiers, string genericSignature,
			string enclosingMethodClass, string enclosingMethodName, string enclosingMethodSig,
			string annotationAttributeType)
		{
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(TypeMetadataAttribute).GetConstructor(new Type[] { typeof(TypeMetadataFlags), typeof(string), typeof(string[]), typeof(string), typeof(Modifiers), typeof(Modifiers), typeof(string), typeof(string), typeof(string), typeof(string), typeof(string) }),
				new object[] { flags, sourceFile, implements, name, modifiers, innerClassModifiers, genericSignature, enclosingMethodClass, enclosingMethodName, enclosingMethodSig, annotationAttributeType });
			typeBuilder.SetCustomAttribute(cab);
		}
		*/		
d3040 1
d3042 1
a3559 1
					//TypeMetadataFlags flags = TypeMetadataFlags.None;
a3560 1
					bool reqSimple = interfaces.Length > 0;
a3566 1
								reqSimple = true;
a3568 8
							else
							{
								//flags |= TypeMetadataFlags.SourceNameIsClassName;
							}
						}
						else
						{
							reqSimple = true;
a3570 7
					bool reqComplex = classFile.GenericSignature != null
						|| classFile.EnclosingMethod != null
						|| classFile.IsInternal
						|| (classFile.Modifiers & (Modifiers.Synthetic | Modifiers.Annotation | Modifiers.Enum)) != 0
						|| annotationAttributeType != null
						|| outerClass.innerClass != 0;

d3576 1
a3576 2

					if(reqComplex)
d3578 3
a3580 1
						if(classFile.IsInternal)
d3582 1
a3582 1
							//flags |= TypeMetadataFlags.InternalAccess;
d3584 5
a3588 28
						// NOTE in Whidbey we could (and probably should) use CompilerGeneratedAttribute to mark Synthetic types
						if(outer != null)
						{
							Modifiers innerClassModifiers = outerClass.accessFlags;
							string innerClassName = classFile.GetConstantPoolClass(outerClass.innerClass);
							if(innerClassName == classFile.Name && innerClassName == outerClassWrapper.Name + "$" + typeBuilder.Name)
							{
								innerClassName = null;
							}
							AttributeHelper.SetInnerClass(typeBuilder, innerClassName, innerClassModifiers);
						}
						else if(outerClass.innerClass != 0)
						{
							AttributeHelper.SetInnerClass(typeBuilder, null, outerClass.accessFlags);
						}
						string enclosingMethodClass = null;
						string enclosingMethodName = null;
						string enclosingMethodSig = null;
						if(classFile.EnclosingMethod != null)
						{
							enclosingMethodClass = classFile.EnclosingMethod[0];
							enclosingMethodName = classFile.EnclosingMethod[1];
							enclosingMethodSig = classFile.EnclosingMethod[2];
						}
//						AttributeHelper.SetTypeMetadata(typeBuilder, flags, sourceFile, implements, innerClassName,
//							classFile.Modifiers, innerClassModifiers, classFile.GenericSignature,
//							enclosingMethodClass, enclosingMethodName, enclosingMethodSig,
//							annotationAttributeType);
d3590 4
a3593 1
					else if(reqSimple)
d3595 3
a3597 1
//						AttributeHelper.SetTypeMetadata(typeBuilder, flags, sourceFile, implements);
d4100 1
a4105 1
#if STATIC_COMPILER
d4176 5
d5958 5
d6749 1
a6770 1
#if !STATIC_COMPILER
@


1.124
log
@*** empty log message ***
@
text
@d7629 2
@


1.123
log
@*** empty log message ***
@
text
@d1602 1
a1602 1
						classObject = JVM.Library.newClass(this, null);
d3359 1
a3359 1
						fields[i] = new GetterFieldWrapper(wrapper, null, null, fld.Name, fld.Signature, new ExModifiers(fld.Modifiers, fld.IsInternal), null);
a4132 2
							// we used to make the field privatescope, but that really serves no purpose (and it hinders
							// serialization, which uses .NET reflection to get at the field)
d4134 1
a4134 2
							attribs |= FieldAttributes.Private;
							setModifiers = true;
d4167 1
a4167 2
						// TODO we should ensure that the getter method name doesn't clash with an existing method
						MethodBuilder getter = typeBuilder.DefineMethod("get_" + fld.Name, methodAttribs, CallingConventions.Standard, type, Type.EmptyTypes);
d4180 12
a4191 1
						PropertyBuilder pb = typeBuilder.DefineProperty(fld.Name, PropertyAttributes.None, type, Type.EmptyTypes);
d4193 12
d5578 5
d5584 1
a5584 1
				string key = GenerateClashKey("method", name, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
d5591 1
a5591 1
						key = GenerateClashKey("method", name, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
d5898 4
d7518 4
d7625 15
d7652 1
a7652 11
			// If the backing field is private, but the modifiers aren't, we've got a final field that
			// has a property accessor method.
			if(field.IsPrivate && ((modifiers.Modifiers & Modifiers.Private) == 0))
			{
				BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public;
				bindingFlags |= field.IsStatic ? BindingFlags.Static : BindingFlags.Instance;
				PropertyInfo prop = field.DeclaringType.GetProperty(field.Name, bindingFlags, null, field.FieldType, Type.EmptyTypes, null);
				MethodInfo getter = prop.GetGetMethod(true);
				return new GetterFieldWrapper(this, type, field, name, type.SigName, modifiers, getter);
			}
			else if(field.IsLiteral)
@


1.122
log
@*** empty log message ***
@
text
@d3530 5
a3534 2
						// TODO once we've implemented an assembly class loader, add the name mapping to that,
						// so that the renamed type can be found again at runtime.
d3905 1
a3905 1
				return inner.Length > outer.Length + 1 && inner[outer.Length] == '$' && inner.IndexOf('$', outer.Length + 1) == -1;
d3911 1
a3911 1
				return inner.Substring(outer.Length + 1);
d4274 1
d4331 1
d4340 1
a4340 1
							if(basehasclinit && m.IsClassInitializer && !classFile.IsInterface)
d4342 11
a4352 4
								hasclinit = true;
								// before we call the base class initializer, we need to set the non-final static ConstantValue fields
								EmitConstantValueInitialization(ilGenerator);
								wrapper.BaseTypeWrapper.EmitRunClassConstructor(ilGenerator);
d4540 12
a8150 17
		internal static TypeWrapper CreateDotNetTypeWrapper(ClassLoaderWrapper loader, string name)
		{
			Type type = loader.GetType(DemangleTypeName(name));
			if(type != null
				&& !AttributeHelper.IsJavaModule(type.Module)
				&& IsAllowedOutside(type))
			{
				TypeWrapper tw = new DotNetTypeWrapper(type);
				// check the name to make sure that the canonical name was used
				if(tw.Name == name)
				{
					return loader.RegisterInitiatingLoader(tw);
				}
			}
			return null;
		}

d8487 1
a8487 2
			// TODO there should be a better way
			return ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(DotNetTypeWrapper.GetName(type));
@


1.121
log
@*** empty log message ***
@
text
@d3295 1
a3295 1
					else if(ReferenceEquals(m.Name, "<init>"))
d3357 1
a3357 1
						&& !wrapper.IsInterface && (!JVM.StrictFinalFieldSemantics || ReferenceEquals(wrapper.Name, "java.lang.System")))
d5692 1
a5692 1
					if(ReferenceEquals(m.Name, "<init>"))
d5791 1
a5791 1
							if(baseMce != null && ReferenceEquals(m.Name, "finalize") && ReferenceEquals(m.Signature, "()V"))
@


1.121.2.1
log
@*** empty log message ***
@
text
@a4326 1
					bool hasConstructor = false;
d4335 1
a4335 1
							if(m.IsClassInitializer)
d4337 4
a4340 11
								if(basehasclinit && !classFile.IsInterface)
								{
									hasclinit = true;
									// before we call the base class initializer, we need to set the non-final static ConstantValue fields
									EmitConstantValueInitialization(ilGenerator);
									wrapper.BaseTypeWrapper.EmitRunClassConstructor(ilGenerator);
								}
							}
							else
							{
								hasConstructor = true;
a4527 9
						// if a class has no constructor, we generate one (otherwise Ref.Emit will create a default ctor
						// and that will potentially be public [and it may also trigger a TypeResolve event])
						if(!hasConstructor)
						{
							ConstructorBuilder cb = typeBuilder.DefineConstructor(MethodAttributes.PrivateScope, CallingConventions.Standard, Type.EmptyTypes);
							ILGenerator ilgen = cb.GetILGenerator();
							ilgen.Emit(OpCodes.Ldnull);
							ilgen.Emit(OpCodes.Throw);
						}
@


1.120
log
@*** empty log message ***
@
text
@d3530 2
d7827 8
a7834 1
			return get_IsGenericTypeDefinition != null && (bool)get_IsGenericTypeDefinition.Invoke(type, noargs);
d7839 8
a7846 1
			return get_ContainsGenericParameters != null && (bool)get_ContainsGenericParameters.Invoke(type, noargs);
d7851 8
a7858 1
			return get_IsGenericMethodDefinition != null && (bool)get_IsGenericMethodDefinition.Invoke(mb, noargs);
d7863 8
a7870 1
			return get_IsGenericType != null && (bool)get_IsGenericType.Invoke(type, noargs);
d7875 8
a7882 1
			return method_GetGenericTypeDefinition == null ? null : (Type)method_GetGenericTypeDefinition.Invoke(type, noargs);
d7887 8
a7894 1
			return method_GetGenericArguments == null ? Type.EmptyTypes : (Type[])method_GetGenericArguments.Invoke(type, noargs);
d7899 8
a7906 1
			return (Type)method_MakeGenericType.Invoke(type, new object[] { typeArguments });
d9476 2
a9477 3
		private Type type;
		private Modifiers reflectiveModifiers;
		private ClassLoaderWrapper classLoader;
d9479 2
a9480 2
		internal ArrayTypeWrapper(Type type, Modifiers modifiers, Modifiers reflectiveModifiers, string name, ClassLoaderWrapper classLoader)
			: base(modifiers, name, CoreClasses.java.lang.Object.Wrapper)
d9482 1
a9482 3
			this.type = type;
			this.reflectiveModifiers = reflectiveModifiers;
			this.classLoader = classLoader;
d9487 1
a9487 1
			return classLoader;
d9514 1
a9514 1
				return reflectiveModifiers;
d9522 1
a9522 1
				return type.Assembly;
d9570 5
a9574 1
				return type;
d9582 1
a9582 6
				Type elem = type.GetElementType();
				while(elem.IsArray)
				{
					elem = elem.GetElementType();
				}
				return !(elem is TypeBuilder);
a9589 1
				// TODO optimize this
d9592 3
a9594 4
					TypeWrapper elementTypeWrapper = ElementTypeWrapper;
					elementTypeWrapper.Finish();
					type = MakeArrayType(elementTypeWrapper.TypeAsArrayType, 1);
					ClassLoaderWrapper.SetWrapperForType(type, this);
@


1.119
log
@*** empty log message ***
@
text
@a2715 4
#if STATIC_COMPILER
		private static Hashtable warningHashtable;
#endif

a2721 4
				if(warningHashtable == null)
				{
					warningHashtable = new Hashtable();
				}
d2728 1
a2728 5
				if(!warningHashtable.ContainsKey(name))
				{
					warningHashtable.Add(name, name);
					Console.Error.WriteLine("Warning: class \"{0}\" not found", name);
				}
d3145 1
a3145 1
				return classLoader.ModuleBuilder.Assembly;
d3522 1
a3522 1
							typeBuilder = wrapper.classLoader.ModuleBuilder.DefineType(mangledTypeName, typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
d4886 1
a4886 1
						attributeTypeBuilder = o.wrapper.classLoader.ModuleBuilder.DefineType(o.classFile.Name + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
d6660 1
a6660 1
			return classLoader.ModuleBuilder.DefineType(mangledTypeName, typeAttribs);
d6728 1
a6728 1
				return classLoader.ModuleBuilder.GetConstructorToken(ci).Token;
d6732 1
a6732 1
				return classLoader.ModuleBuilder.GetMethodToken((MethodInfo)mb).Token;
a8075 3
		// this method returns a new TypeWrapper instance for each invocation (doesn't prevent duplicates)
		// the caller is responsible for making sure that only one TypeWrapper with the specified name escapes
		// out into the world
d8087 1
a8087 1
					return tw;
d8098 1
a8098 1
			internal DelegateInnerClassTypeWrapper(string name, Type delegateType)
d8120 4
a8123 2
					// HACK this is an ugly hack to obtain the global ModuleBuilder
					ModuleBuilder moduleBuilder = ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder;
d8126 1
a8126 1
					TypeBuilder typeBuilder = moduleBuilder.DefineType(Name.Substring(NamePrefix.Length), TypeAttributes.NotPublic | TypeAttributes.Interface | TypeAttributes.Abstract);
d9211 2
a9212 1
							list.Add(GetClassLoader().RegisterInitiatingLoader(new DelegateInnerClassTypeWrapper(Name + DelegateInterfaceSuffix, type)));
@


1.118
log
@*** empty log message ***
@
text
@d8487 4
@


1.117
log
@*** empty log message ***
@
text
@a8092 22
#if !COMPACT_FRAMEWORK
			if(name.EndsWith(DelegateInterfaceSuffix))
			{
				TypeWrapper tw = loader.LoadClassByDottedNameFast(name.Substring(0, name.Length - DelegateInterfaceSuffix.Length));
				if(tw is DotNetTypeWrapper
					&& IsDelegate(tw.TypeAsTBD)
					&& tw.Name + DelegateInterfaceSuffix == name)
				{
					return new DelegateInnerClassTypeWrapper(name, tw.TypeAsTBD);
				}
			}
			else if(name.EndsWith(AttributeAnnotationSuffix))
			{
				TypeWrapper tw = loader.LoadClassByDottedNameFast(name.Substring(0, name.Length - AttributeAnnotationSuffix.Length));
				if(tw is DotNetTypeWrapper
					&& IsAttribute(tw.TypeAsTBD)
					&& tw.Name + AttributeAnnotationSuffix == name)
				{
					return new AttributeAnnotationTypeWrapper(name, tw.TypeAsTBD);
				}
			}
#endif // !COMPACT_FRAMEWORK
d8099 1
d9220 1
a9220 1
							list.Add(GetClassLoader().LoadClassByDottedName(Name + DelegateInterfaceSuffix));
d9224 1
a9224 1
							list.Add(GetClassLoader().LoadClassByDottedName(Name + AttributeAnnotationSuffix));
@


1.116
log
@*** empty log message ***
@
text
@d7830 3
d7850 15
d7934 1
a7934 1
				// open generic types don't have a full name
d7938 39
a7976 1
			if(AttributeHelper.IsNoPackagePrefix(type))
a7977 1
				// TODO figure out if this is even required
a7986 1
			int quoteMode = 0;
a7990 8
				if(c == '[' && !escape)
				{
					quoteMode++;
				}
				if(c == ']' && !escape)
				{
					quoteMode--;
				}
d7996 1
a7996 1
					|| (c == '.' && quoteMode == 0))
d8019 3
d8024 1
a8024 5
			Debug.Assert(name.StartsWith(NamePrefix));
			System.Text.StringBuilder sb = new System.Text.StringBuilder(name.Length - NamePrefix.Length);
			int end = name.Length;
			bool hasDelegateSuffix = name.EndsWith(DelegateInterfaceSuffix);
			if(hasDelegateSuffix)
d8026 1
a8026 1
				end -= DelegateInterfaceSuffix.Length;
d8028 2
a8029 7
			bool hasAnnotationSuffix = name.EndsWith(AttributeAnnotationSuffix);
			if(hasAnnotationSuffix)
			{
				end -= AttributeAnnotationSuffix.Length;
			}
			// TODO we should enforce canonical form
			for(int i = NamePrefix.Length; i < end; i++)
d8034 1
a8034 1
					if(i + 1 < end && name[i + 1] != '$')
d8041 1
a8041 1
						if(i + 5 > end)
a8060 8
			if(hasDelegateSuffix)
			{
				sb.Append(DelegateInterfaceSuffix);
			}
			if(hasAnnotationSuffix)
			{
				sb.Append(AttributeAnnotationSuffix);
			}
d8091 1
a8091 1
		internal static TypeWrapper CreateDotNetTypeWrapper(string name)
d8093 2
a8094 14
			string origname = name;
			bool prefixed = name.StartsWith(NamePrefix);
			if(prefixed)
			{
				// mangled names cannot contain commas and since we're later on going to chop off the comma
				// (to deal with assembly qualified names in generic types) we don't want to pass it along here
				if(name.IndexOf(',') >= 0)
				{
					return null;
				}
				name = DemangleTypeName(name);
			}
			Type type = LoadTypeFromLoadedAssemblies(name);
			if(type != null)
d8096 4
a8099 1
				if(!IsAllowedOutside(type))
d8101 1
a8101 5
					return null;
				}
				if(prefixed || AttributeHelper.IsNoPackagePrefix(type))
				{
					return new DotNetTypeWrapper(type);
d8104 1
a8104 2
#if !COMPACT_FRAMEWORK
			if(name.EndsWith(DelegateInterfaceSuffix))
d8106 4
a8109 2
				Type delegateType = LoadTypeFromLoadedAssemblies(name.Substring(0, name.Length - DelegateInterfaceSuffix.Length));
				if(delegateType != null && IsDelegate(delegateType))
d8111 1
a8111 4
					if(prefixed || AttributeHelper.IsNoPackagePrefix(delegateType))
					{
						return new DelegateInnerClassTypeWrapper(origname, delegateType);
					}
d8114 5
a8118 1
			else if(name.EndsWith(AttributeAnnotationSuffix))
d8120 2
a8121 2
				Type attributeType = LoadTypeFromLoadedAssemblies(name.Substring(0, name.Length - AttributeAnnotationSuffix.Length));
				if(attributeType != null && IsAttribute(attributeType))
d8123 1
a8123 4
					if(prefixed || AttributeHelper.IsNoPackagePrefix(attributeType))
					{
						return new AttributeAnnotationTypeWrapper(origname, attributeType);
					}
a8125 1
#endif // !COMPACT_FRAMEWORK
a8460 112
		private static string[] ParseGenericArgs(string args)
		{
			if(args[0] != '[')
				throw new NotSupportedException();
			ArrayList list = new ArrayList();
			int start = 1;
			int depth = 1;
			for(int i = 1; i < args.Length; i++)
			{
				if(args[i] == '[')
				{
					depth++;
					if(depth == 1)
					{
						start = i + 1;
					}
				}
				else if(args[i] == ']')
				{
					depth--;
					if(depth == 0)
					{
						list.Add(args.Substring(start, i - start));
					}
				}
			}
			return (string[])list.ToArray(typeof(string));
		}

		private static Type LoadTypeFromLoadedAssemblies(string name)
		{
			// HACK handle generic types here
			int index = name.IndexOf("[[");
			if(index > 0)
			{
				int lastIndex = name.LastIndexOf("]]");
				if(lastIndex == -1 || (lastIndex + 2 < name.Length && name[lastIndex + 2] != ','))
				{
					return null;
				}
				Type t = LoadTypeFromLoadedAssemblies(name.Substring(0, index));
				if(t != null && Whidbey.IsGenericTypeDefinition(t))
				{
					string[] typeArgStrings = ParseGenericArgs(name.Substring(index + 1, lastIndex - index));
					Type[] typeArgs = new Type[typeArgStrings.Length];
					for(int i = 0; i < typeArgs.Length; i++)
					{
						typeArgs[i] = LoadTypeFromLoadedAssemblies(typeArgStrings[i]);
						if(typeArgs[i] == null)
						{
							return null;
						}
					}
					return Whidbey.MakeGenericType(t, typeArgs);
				}
			}
			// HACK we ignore the assembly name (we have to do that to make the generic type arguments work)
			int comma = name.IndexOf(',');
			if(comma >= 0)
			{
				name = name.Substring(0, comma);
			}

#if WHIDBEY
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
			{
				foreach(Assembly a in AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies())
				{
					if(!(a is AssemblyBuilder))
					{
						Type t = a.GetType(name);
						if(t != null
							&& !AttributeHelper.IsJavaModule(t.Module))
						{
							return t;
						}
						// HACK we might be looking for an inner classes
						// (if we remove the mangling of NoPackagePrefix types from GetName, we don't need this anymore)
						t = a.GetType(name.Replace('$', '+'));
						if(t != null
							&& !AttributeHelper.IsJavaModule(t.Module))
						{
							return t;
						}
					}
				}
				return Type.GetType(name);
			}
#endif
			foreach(Assembly a in AppDomain.CurrentDomain.GetAssemblies())
			{
				if(!(a is AssemblyBuilder))
				{
					Type t = a.GetType(name);
					if(t != null
						&& !AttributeHelper.IsJavaModule(t.Module))
					{
						return t;
					}
					// HACK we might be looking for an inner classes
					// (if we remove the mangling of NoPackagePrefix types from GetName, we don't need this anymore)
					t = a.GetType(name.Replace('$', '+'));
					if(t != null
						&& !AttributeHelper.IsJavaModule(t.Module))
					{
						return t;
					}
				}
			}
			return null;
		}

@


1.115
log
@*** empty log message ***
@
text
@d5560 28
d5799 2
d5803 1
d5828 1
a5828 2
									Type baseFinalizeType = typeBuilder.BaseType.GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null).DeclaringType;
									if(baseFinalizeType == typeof(object))
d5838 1
a5838 2
									Type baseFinalizeType = typeBuilder.BaseType.GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null).DeclaringType;
									if(baseFinalizeType == typeof(object))
d5881 10
a5890 1
								MethodInfo baseFinalize = typeBuilder.BaseType.GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
d5898 5
a5902 3
								// TODO if the Java class also defines a Finalize() method, we need to name the stub differently
								// (and make it effectively appear hidden by the class's Finalize method)
								MethodBuilder finalize = typeBuilder.DefineMethod("Finalize", attr, CallingConventions.Standard, typeof(void), Type.EmptyTypes);
@


1.114
log
@*** empty log message ***
@
text
@d3537 7
@


1.113
log
@*** empty log message ***
@
text
@d181 1
a181 1
#if WHIDBEY
d692 11
d705 1
a705 1
#if WHIDBEY
d710 1
a710 1
					if(cad.Constructor.DeclaringType == typeofModifiersAttribute)
d729 1
a729 1
#if WHIDBEY
d734 1
a734 1
					if(cad.Constructor.DeclaringType == typeofModifiersAttribute)
d810 1
a810 1
#if WHIDBEY
d815 1
a815 1
					if(cad.Constructor.DeclaringType == typeofModifiersAttribute)
d1078 1
a1078 1
#if WHIDBEY
d1083 1
a1083 1
					if(cad.Constructor.DeclaringType == typeofNameSigAttribute)
d1098 1
a1098 1
#if WHIDBEY
d1103 1
a1103 1
					if(cad.Constructor.DeclaringType == typeofNameSigAttribute)
d1136 1
a1136 1
					if(cad.Constructor.DeclaringType == typeofImplementsAttribute)
d1149 82
d1238 1
a1238 1
					if(cad.Constructor.DeclaringType == typeofInnerClassAttribute)
d1259 1
a1259 1
						if(cad.Constructor.DeclaringType == typeofRemappedInterfaceMethodAttribute)
d1281 1
a1281 1
					if(cad.Constructor.DeclaringType == typeofRemappedTypeAttribute)
d1297 1
a1297 1
			if(JVM.IsStaticCompiler)
d1302 1
a1302 1
						if(cad.Constructor.DeclaringType == typeofRemappedClassAttribute)
d1335 1
a1335 1
					if(cad.Constructor.DeclaringType == attribute)
d1353 1
a1353 1
					if(cad.Constructor.DeclaringType == attribute)
d1372 1
a1372 1
					if(cad.Constructor.DeclaringType == attribute)
d1391 1
a1391 1
					if(cad.Constructor.DeclaringType == attribute)
d1410 1
a1410 1
					if(cad.Constructor.DeclaringType == attribute)
d2213 1
a2213 1
		internal virtual TypeWrapper MakeArrayType(int rank)
a7072 7
		internal override TypeWrapper MakeArrayType(int rank)
		{
			Debug.Assert(rank != 0);
			// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
			return ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast(new String('[', rank) + this.SigName);
		}

d7523 2
a7524 2
				object[] attr = (mbHelper != null ? mbHelper : GetMethod()).GetCustomAttributes(typeof(SignatureAttribute), false);
				if(attr.Length == 1)
d7526 1
a7526 1
					return ((SignatureAttribute)attr[0]).Signature;
d7615 2
a7616 4
			object[] attr = type.GetCustomAttributes(typeof(SignatureAttribute), false);
			// HACK for the time being we have to support having two signature attributes
			// (because of the hack in map.xml to make japi happy on the non-generics branch)
			if(attr.Length >= 1)
d7618 1
a7618 1
				return ((SignatureAttribute)attr[0]).Signature;
d7632 2
a7633 2
				object[] attr = mb.GetCustomAttributes(typeof(SignatureAttribute), false);
				if(attr.Length == 1)
d7635 1
a7635 1
					return ((SignatureAttribute)attr[0]).Signature;
d7646 2
a7647 2
				object[] attr = fi.GetCustomAttributes(typeof(SignatureAttribute), false);
				if(attr.Length == 1)
d7649 1
a7649 1
					return ((SignatureAttribute)attr[0]).Signature;
d7926 1
a7926 1
		private static string DemangleTypeName(string name)
a8558 7
		internal override TypeWrapper MakeArrayType(int rank)
		{
			Debug.Assert(rank != 0);
			// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
			return ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast(new String('[', rank) + this.SigName);
		}

@


1.112
log
@*** empty log message ***
@
text
@d1057 1
d1063 1
d1505 1
d1508 1
d2973 1
a2973 1
		protected readonly DynamicClassLoader classLoader;
d2989 1
a2989 1
		internal DynamicTypeWrapper(ClassFile f, DynamicClassLoader classLoader)
d8009 2
a8010 2
					ModuleBuilder moduleBuilder = new DynamicClassLoader(null).ModuleBuilder;
					// NOTE we chop of the prefix ("cli.") because C++/CLI doesn't like assemblies
d8241 1
d8310 1
@


1.111
log
@*** empty log message ***
@
text
@a9540 1
					Type elementType = elementTypeWrapper.TypeAsArrayType;
d9542 1
a9542 1
					type = MakeArrayType(elementType, 1);
@


1.110
log
@*** empty log message ***
@
text
@d695 1
a695 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d719 1
a719 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d800 1
a800 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1066 1
a1066 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1086 1
a1086 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1119 1
a1119 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1139 1
a1139 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1159 1
a1159 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1182 1
a1182 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1235 1
a1235 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1254 1
a1254 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1272 1
a1272 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1291 1
a1291 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d1310 1
a1310 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
@


1.109
log
@*** empty log message ***
@
text
@d1994 1
a1994 7
					int rank = ArrayRank;
					string type = "System.Object";
					for(int i = 0; i < rank; i++)
					{
						type += "[]";
					}
					return Type.GetType(type, true);
d2028 1
a2028 7
					int rank = ArrayRank;
					string type = "System.Object";
					for(int i = 0; i < rank; i++)
					{
						type += "[]";
					}
					return Type.GetType(type, true);
d2045 1
a2045 7
					int rank = ArrayRank;
					string type = "System.Object";
					for(int i = 0; i < rank; i++)
					{
						type += "[]";
					}
					return Type.GetType(type, true);
d8557 1
a8557 1
						type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
d9046 1
a9046 7
#if WHIDBEY
					// NOTE this is not just an optimization, but it is also required to
					// make sure that ReflectionOnly types stay ReflectionOnly types.
					type = type.GetElementType().MakeArrayType(1);
#else
					type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
#endif
d9543 1
a9543 1
					type = elementType.Assembly.GetType(elementType.FullName + "[]", true);
d9568 47
@


1.108
log
@*** empty log message ***
@
text
@d9064 5
d9070 1
@


1.107
log
@*** empty log message ***
@
text
@d3671 2
a3672 2
						ClassFile.ConstantPoolItemFieldref fld = classFile.GetFieldref(m.Instructions[i].Arg1);
						if(fld.Class != classFile.Name)
d3695 5
@


1.106
log
@*** empty log message ***
@
text
@d1450 1
d4626 9
d5035 8
d7656 5
d8147 13
d8164 16
d8271 6
d8304 5
d9138 35
a9172 1
			return !type.IsAbstract && type.IsSubclassOf(typeof(Attribute)) && IsVisible(type);
@


1.105
log
@*** empty log message ***
@
text
@d1391 1
d1396 8
d2406 5
a2410 1
			System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(TypeAsTBD.TypeHandle);
d4574 2
d4577 5
a4581 1
						for(int i = 0; i < classFile.Methods.Length; i++)
d4583 1
a4583 3
							ClassFile.Method m = classFile.Methods[i];
							MethodBase mb = methods[i].GetMethod();
							if(m.Annotations != null)
d4585 2
a4586 1
								foreach(object[] def in m.Annotations)
d4588 2
a4589 2
									Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
									if(annotation != null)
d4591 6
a4596 10
										ConstructorBuilder cb = mb as ConstructorBuilder;
										if(cb != null)
										{
											annotation.Apply(cb, def);
										}
										MethodBuilder mBuilder = mb as MethodBuilder;
										if(mBuilder != null)
										{
											annotation.Apply(mBuilder, def);
										}
d4601 1
d4603 3
a4605 1
						for(int i = 0; i < classFile.Fields.Length; i++)
d4607 1
a4607 1
							if(classFile.Fields[i].Annotations != null)
d4609 2
a4610 1
								foreach(object[] def in classFile.Fields[i].Annotations)
d4612 1
a4612 5
									Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
									if(annotation != null)
									{
										annotation.Apply((FieldBuilder)fields[i].GetField(), def);
									}
d4616 1
d4618 3
a4620 1
						if(classFile.Annotations != null)
d4622 2
a4623 1
							foreach(object[] def in classFile.Annotations)
d4625 1
a4625 5
								Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
								if(annotation != null)
								{
									annotation.Apply(typeBuilder, def);
								}
a4628 1
#endif // STATIC_COMPILER
d6491 10
d7712 1
d7838 5
d7880 4
d7952 11
d8089 168
d9073 5
d9111 9
d9122 1
a9122 1
							innerClasses = new TypeWrapper[] { GetClassLoader().LoadClassByDottedName(Name + DelegateInterfaceSuffix) };
d9124 1
a9124 1
						else
d9126 1
a9126 10
							Type[] nestedTypes = type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic);
							ArrayList list = new ArrayList(nestedTypes.Length);
							for(int i = 0; i < nestedTypes.Length; i++)
							{
								if(!Whidbey.IsGenericTypeDefinition(nestedTypes[i]))
								{
									list.Add(ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]));
								}
							}
							innerClasses = (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
d9128 1
@


1.104
log
@*** empty log message ***
@
text
@d2519 9
a2527 1
				ilgen.Emit(OpCodes.Call, TypeAsTBD.GetMethod("IsInstanceArray"));
@


1.103
log
@*** empty log message ***
@
text
@a172 4
		// make sure we don't get the "beforefieldinit" flag as that could cause our cctor to run before
		// JVM.IsStaticCompiler is set
		static AttributeHelper() {}

a2529 56
		internal static string GetSigNameFromType(Type type)
		{
			TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromTypeFast(type);

			if(wrapper != null)
			{
				return wrapper.SigName;
			}

			if(type.IsArray)
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder();
				while(type.IsArray)
				{
					sb.Append('[');
					type = type.GetElementType();
				}
				return sb.Append(GetSigNameFromType(type)).ToString();
			}

			string s = TypeWrapper.GetNameFromType(type);
			if(s[0] != '[')
			{
				s = "L" + s + ";";
			}
			return s;
		}

		// NOTE returns null for primitive types and types that are not visible from Java (e.g. open generic types)
		internal static string GetNameFromType(Type type)
		{
			TypeWrapper.AssertFinished(type);

			if(type.IsArray)
			{
				return GetSigNameFromType(type);
			}

			// first we check if a wrapper exists, because if it does we must use the name from the wrapper to
			// make sure that remapped types return the proper name
			TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromTypeFast(type);
			if(wrapper != null)
			{
				return wrapper.Name;
			}

			if(AttributeHelper.IsJavaModule(type.Module))
			{
				return CompiledTypeWrapper.GetName(type);
			}
			else
			{
				return DotNetTypeWrapper.GetName(type);
			}
		}

d9029 1
a9029 1
				TypeWrapper shadow = ClassLoaderWrapper.GetWrapperFromTypeFast(type);
d9046 1
a9046 1
				TypeWrapper shadow = ClassLoaderWrapper.GetWrapperFromTypeFast(type);
@


1.102
log
@*** empty log message ***
@
text
@d1370 18
d3212 1
a3212 1
		private class JavaTypeImpl : DynamicImpl
a3220 1
			private DynamicTypeWrapper outerClassWrapper;
d3226 1
d3350 1
a3351 2
				// from now on we shouldn't be throwing any exceptions (to be precise, after we've
				// called ModuleBuilder.DefineType)
d3367 1
d3369 5
a3373 3
					// only if requested, we compile inner classes as nested types, because it has a higher cost
					// and doesn't buy us anything, unless we're compiling a library that could be used from C# (e.g.)
					if(JVM.CompileInnerClassesAsNestedTypes)
d3375 6
a3380 2
						string outerClassName = getOuterClassName();
						if(outerClassName != null)
d3382 1
a3382 1
							if(!CheckInnerOuterNames(f.Name, outerClassName))
d3384 1
a3384 1
								Tracer.Warning(Tracer.Compiler, "Incorrect InnerClasses attribute on {0}", f.Name);
d3386 5
a3390 1
							else
d3392 3
a3394 1
								try
d3396 7
a3402 13
									outerClassWrapper = wrapper.GetClassLoader().LoadClassByDottedNameFast(outerClassName) as DynamicTypeWrapper;
								}
								catch(RetargetableJavaException x)
								{
									Tracer.Warning(Tracer.Compiler, "Unable to load outer class {0} for innner class {1} ({2}: {3})", outerClassName, f.Name, x.GetType().Name, x.Message);
								}
								if(outerClassWrapper != null)
								{
									// make sure the relationship is reciprocal (otherwise we run the risk of
									// baking the outer type before the inner type)
									// NOTE this lock is bogus (and not required), because this code path is only
									// applicable to static compilation, which requires no locking.
									lock(outerClassWrapper)
d3404 2
a3405 1
										if(outerClassWrapper.impl is JavaTypeImpl)
d3407 4
a3410 3
											ClassFile outerClassFile = ((JavaTypeImpl)outerClassWrapper.impl).classFile;
											ClassFile.InnerClass[] outerInnerClasses = outerClassFile.InnerClasses;
											if(outerInnerClasses == null)
d3412 2
a3413 20
												outerClassWrapper = null;
											}
											else
											{
												bool ok = false;
												for(int i = 0; i < outerInnerClasses.Length; i++)
												{
													if(outerInnerClasses[i].outerClass != 0
														&& outerClassFile.GetConstantPoolClass(outerInnerClasses[i].outerClass) == outerClassFile.Name
														&& outerInnerClasses[i].innerClass != 0
														&& outerClassFile.GetConstantPoolClass(outerInnerClasses[i].innerClass) == f.Name)
													{
														ok = true;
														break;
													}
												}
												if(!ok)
												{
													outerClassWrapper = null;
												}
d3416 1
a3416 1
										else
d3421 12
a3432 8
									if(outerClassWrapper != null)
									{
										outer = outerClassWrapper.TypeAsBuilder;
									}
									else
									{
										Tracer.Warning(Tracer.Compiler, "Non-reciprocal inner class {0}", f.Name);
									}
d3452 6
d3461 1
d3475 1
d3483 1
d3491 1
d3528 81
d3622 5
d3641 5
a3672 7
#if STATIC_COMPILER
					if(f.IsAnnotation && Annotation.HasRetentionPolicyRuntime(f.Annotations))
					{
						annotationBuilder = new AnnotationBuilder(this);
						((AotTypeWrapper)wrapper).SetAnnotation(annotationBuilder);
					}
#endif
d3680 1
a3680 1
			private string getOuterClassName()
d3687 1
a3687 2
						if(innerClasses[j].outerClass != 0
							&& innerClasses[j].innerClass != 0
d3690 1
a3690 1
							return classFile.GetConstantPoolClass(innerClasses[j].outerClass);
d3694 1
a3694 1
				return null;
d4180 1
d4185 1
a4249 8
									string inner = classFile.GetConstantPoolClass(innerclasses[i].innerClass);
									if(inner == classFile.Name && inner == declaringTypeWrapper.Name + "$" + typeBuilder.Name)
									{
										inner = null;
									}
#if STATIC_COMPILER
									AttributeHelper.SetInnerClass(typeBuilder, inner, innerclasses[i].accessFlags);
#endif // STATIC_COMPILER
a4596 6
						// NOTE in Whidbey we can (and should) use CompilerGeneratedAttribute to mark Synthetic types
						if(classFile.IsInternal || (classFile.Modifiers & (Modifiers.Synthetic | Modifiers.Annotation | Modifiers.Enum)) != 0)
						{
							AttributeHelper.SetModifiers(typeBuilder, classFile.Modifiers, classFile.IsInternal);
						}

a4842 1
#if STATIC_COMPILER
a4845 1
#endif // STATIC_COMPILER
a4846 2
					CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(AnnotationAttributeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { attributeTypeBuilder.FullName });
					o.typeBuilder.SetCustomAttribute(cab);
d4913 12
d6204 1
a6204 1
		private class FinishedTypeImpl : DynamicImpl
d6962 4
a6965 1
				return GetName(type.DeclaringType) + "$" + type.Name;
d7024 1
a7024 1
			return JVM.IsStaticCompiler || ClassLoaderWrapper.IsCoreAssemblyType(type) ? ClassLoaderWrapper.GetBootstrapClassLoader() : ClassLoaderWrapper.GetSystemClassLoader();
d7906 24
d7939 6
d7950 1
a7950 8
				// SECURITY we never expose types from IKVM.Runtime, because doing so would lead to a security hole,
				// since the reflection implementation lives inside this assembly, all internal members would
				// be accessible through Java reflection.
				if(type.Assembly == typeof(DotNetTypeWrapper).Assembly)
				{
					return null;
				}
				if(Whidbey.ContainsGenericParameters(type))
d7967 1
a7967 17
						MethodInfo invoke = delegateType.GetMethod("Invoke");
						ParameterInfo[] parameters = invoke.GetParameters();
						Type[] args = new Type[parameters.Length];
						for(int i = 0; i < args.Length; i++)
						{
							// we know there aren't any unsupported parameter types, because IsDelegate() returned true
							args[i] = parameters[i].ParameterType;
						}
						// HACK this is an ugly hack to obtain the global ModuleBuilder
						ModuleBuilder moduleBuilder = new DynamicClassLoader(null).ModuleBuilder;
						TypeBuilder typeBuilder = moduleBuilder.DefineType(origname.Substring(NamePrefix.Length), TypeAttributes.NotPublic | TypeAttributes.Interface | TypeAttributes.Abstract);
						AttributeHelper.HideFromJava(typeBuilder);
#if STATIC_COMPILER
						AttributeHelper.SetModifiers(typeBuilder, Modifiers.Public | Modifiers.Interface | Modifiers.Abstract, false);
#endif // STATIC_COMPILER
						typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Abstract | MethodAttributes.Virtual, CallingConventions.Standard, invoke.ReturnType, args);
						return CompiledTypeWrapper.newInstance(origname, typeBuilder.CreateType());
d7975 122
d8256 1
a8256 1
			return ClassLoaderWrapper.GetSystemClassLoader();
d8269 1
a8269 1
			private MethodInfo method;
d8271 1
a8271 1
			internal DelegateMethodWrapper(TypeWrapper declaringType, Type delegateType, TypeWrapper iface)
d8274 2
a8275 2
				this.delegateConstructor = delegateType.GetConstructor(new Type[] { typeof(object), typeof(IntPtr) });
				this.method = iface.TypeAsTBD.GetMethod("Invoke");
d8282 6
a8287 1
				ilgen.Emit(OpCodes.Ldvirtftn, method);
d8565 8
d8642 1
a8642 3
					Debug.Assert(iface is CompiledTypeWrapper);
					iface.Finish();
					methodsList.Add(new DelegateMethodWrapper(this, type, iface));
d8948 1
a8948 1
							innerClasses = new TypeWrapper[] { ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(Name + DelegateInterfaceSuffix) };
@


1.101
log
@*** empty log message ***
@
text
@d3205 1
a3205 1
			private Hashtable classCache = new Hashtable();
d4096 1
a4096 6
				// TODO this locking is incorrect, we shouldn't be holding any locks while calling user code
				// (Link will do class loading and class loading results in calling user code)
				lock(classFile)
				{
					classFile.Link(wrapper, classCache);
				}
@


1.100
log
@*** empty log message ***
@
text
@d3144 2
a3145 12
			lock(this)
			{
				Profiler.Enter("DynamicTypeWrapper.Finish");
				try
				{
					impl = impl.Finish();
				}
				finally
				{
					Profiler.Leave("DynamicTypeWrapper.Finish");
				}
			}
d3163 10
d3198 1
a3198 1
			private readonly TypeBuilder typeBuilder;
d3203 1
a3203 1
			private readonly DynamicTypeWrapper outerClassWrapper;
d3217 1
d3219 2
d3222 1
a3222 1
				bool hasclinit = wrapper.BaseTypeWrapper == null ? false : wrapper.BaseTypeWrapper.HasStaticInitializer;
d3328 1
d3330 3
d3376 2
d3457 1
a3457 1
							typeBuilder = wrapper.DefineType(typeAttribs);
d3471 1
a3471 1
							typeBuilder = wrapper.classLoader.ModuleBuilder.DefineType(wrapper.classLoader.MangleTypeName(f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
d3570 1
a3570 5
					if(typeBuilder != null)
					{
						JVM.CriticalFailure("Exception during critical part of JavaTypeImpl construction", x);
					}
					throw;
d4096 6
a4101 1
				classFile.Link(wrapper, classCache);
d4110 10
d6454 1
a6454 1
		protected virtual TypeBuilder DefineType(TypeAttributes typeAttribs)
d6456 1
a6456 1
			return classLoader.ModuleBuilder.DefineType(classLoader.MangleTypeName(Name), typeAttribs);
@


1.99
log
@*** empty log message ***
@
text
@d6499 13
d6516 1
d6520 1
a6520 1
					if(methods[i].GetMethod().MethodHandle.Value == mb.MethodHandle.Value)
@


1.98
log
@*** empty log message ***
@
text
@d137 2
a139 1
		private static CustomAttributeBuilder hideFromJavaAttribute;
a140 1
#if STATIC_COMPILER
a141 1
#endif
d150 2
a151 1
#endif
a500 1
#endif // STATIC_COMPILER
d566 1
d662 1
a662 1
#if !COMPACT_FRAMEWORK
d862 1
a862 1
#if !COMPACT_FRAMEWORK
a957 6
		internal static void SetJavaModule(ModuleBuilder moduleBuilder)
		{
			CustomAttributeBuilder ikvmModuleAttr = new CustomAttributeBuilder(typeofJavaModuleAttribute.GetConstructor(Type.EmptyTypes), new object[0]);
			moduleBuilder.SetCustomAttribute(ikvmModuleAttr);
		}

d1059 7
a1065 1
#endif
d1340 1
a1340 1
#if !COMPACT_FRAMEWORK
d1370 1
a1370 1
#endif
d2618 10
d3010 2
d3029 1
d3496 1
d3498 1
a3498 1
					if(JVM.IsStaticCompiler || DynamicClassLoader.IsSaveDebugImage)
d3500 9
a3508 12
						if(classFile.DeprecatedAttribute)
						{
							AttributeHelper.SetDeprecatedAttribute(typeBuilder);
						}
						if(classFile.GenericSignature != null)
						{
							AttributeHelper.SetSignatureAttribute(typeBuilder, classFile.GenericSignature);
						}
						if(classFile.EnclosingMethod != null)
						{
							AttributeHelper.SetEnclosingMethodAttribute(typeBuilder, classFile.EnclosingMethod[0], classFile.EnclosingMethod[1], classFile.EnclosingMethod[2]);
						}
d3524 1
d4003 1
d4010 1
d4033 16
a4048 1
				if(JVM.IsStaticCompiler || DynamicClassLoader.IsSaveDebugImage)
d4050 1
a4050 18
					// if the Java modifiers cannot be expressed in .NET, we emit the Modifiers attribute to store
					// the Java modifiers
					if(setModifiers || fld.IsInternal || (fld.Modifiers & (Modifiers.Synthetic | Modifiers.Enum)) != 0)
					{
						AttributeHelper.SetModifiers(field, fld.Modifiers, fld.IsInternal);
					}
					if(setNameSig)
					{
						AttributeHelper.SetNameSig(field, fld.Name, fld.Signature);
					}
					if(fld.DeprecatedAttribute)
					{
						AttributeHelper.SetDeprecatedAttribute(field);
					}
					if(fld.GenericSignature != null)
					{
						AttributeHelper.SetSignatureAttribute(field, fld.GenericSignature);
					}
d4052 1
d4133 1
d4135 1
d4185 15
a4199 1
							Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, invokespecialstubcache);
d4318 1
d4320 1
a4320 1
								Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref nonleaf, invokespecialstubcache);
d4325 12
d4735 1
d4739 1
d5389 1
d5396 1
d5704 1
a5704 1
#endif
d5711 3
a5713 1
					if(JVM.IsStaticCompiler || DynamicClassLoader.IsSaveDebugImage)
d5715 1
a5715 2
						AttributeHelper.SetThrowsAttribute(method, exceptions);
						if(setModifiers || m.IsInternal || (m.Modifiers & (Modifiers.Synthetic | Modifiers.Bridge)) != 0)
d5717 1
a5717 8
							if(method is ConstructorBuilder)
							{
								AttributeHelper.SetModifiers((ConstructorBuilder)method, m.Modifiers, m.IsInternal);
							}
							else
							{
								AttributeHelper.SetModifiers((MethodBuilder)method, m.Modifiers, m.IsInternal);
							}
d5719 1
a5719 1
						if(m.DeprecatedAttribute)
d5721 1
a5721 9
							AttributeHelper.SetDeprecatedAttribute(method);
						}
						if(setNameSig)
						{
							AttributeHelper.SetNameSig(method, m.Name, m.Signature);
						}
						if(m.GenericSignature != null)
						{
							AttributeHelper.SetSignatureAttribute(method, m.GenericSignature);
d5724 13
d6494 25
d7548 24
d7823 1
d7825 1
d7831 1
a7831 1
#endif
@


1.97
log
@*** empty log message ***
@
text
@d1838 4
d1844 3
a1846 1
				if(mw.Name == name && mw.Signature == sig)
d3232 1
a3232 1
					else if(m.Name == "<init>")
d3294 1
a3294 1
						&& !wrapper.IsInterface && (!JVM.StrictFinalFieldSemantics || wrapper.Name == "java.lang.System"))
d5442 1
a5442 1
					if(m.Name == "<init>")
d5539 1
a5539 1
							if(baseMce != null && m.Name == "finalize" && m.Signature == "()V")
@


1.96
log
@*** empty log message ***
@
text
@d4954 1
a4954 1
				private static readonly Type localRefStructType = StaticCompiler.GetType("IKVM.Runtime.JNI.Frame");
@


1.95
log
@*** empty log message ***
@
text
@d1393 29
d3534 1
a3534 1
					if(f.IsAnnotation && f.Annotations != null)
d3536 2
a3537 23
						foreach(object[] def in f.Annotations)
						{
							if(def[1].Equals("Ljava/lang/annotation/Retention;"))
							{
								for(int i = 2; i < def.Length; i += 2)
								{
									if(def[i].Equals("value"))
									{
										object[] val = def[i + 1] as object[];
										if(val != null
											&& val.Length == 3
											&& val[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)
											&& val[1].Equals("Ljava/lang/annotation/RetentionPolicy;")
											&& val[2].Equals("RUNTIME"))
										{
											annotationBuilder = new AnnotationBuilder(this);
											((AotTypeWrapper)wrapper).SetAnnotation(annotationBuilder);
											break;
										}
									}
								}
							}
						}
d4694 61
@


1.94
log
@*** empty log message ***
@
text
@d3505 1
a3505 1
					if(f.IsAnnotation)
d3507 23
a3529 2
						annotationBuilder = new AnnotationBuilder(this);
						((AotTypeWrapper)wrapper).SetAnnotation(annotationBuilder);
@


1.93
log
@*** empty log message ***
@
text
@d7251 3
a7253 1
			if(attr.Length == 1)
@


1.92
log
@*** empty log message ***
@
text
@d1376 17
d1394 4
d4429 1
a4429 1
						if(classFile.Annotations != null)
d4431 3
a4433 1
							foreach(object[] def in classFile.Annotations)
d4435 1
a4435 4
								Debug.Assert(def[0].Equals(AnnotationDefaultAttribute.TAG_ANNOTATION));
								string annotationClass = (string)def[1];
								Annotation annotation = null;
								try
d4437 14
a4450 2
									TypeWrapper annot = wrapper.GetClassLoader().RetTypeWrapperFromSig(annotationClass.Replace('/', '.'));
									annotation = annot.Annotation;
d4452 8
a4459 1
								catch(RetargetableJavaException)
d4461 5
a4465 1
									Tracer.Warning(Tracer.Compiler, "Unable to load annotation class {0}", annotationClass);
d4467 9
a4475 5
								if(annotation == null)
								{
									// TODO figure out what to do here
								}
								else
d4776 32
d7306 21
d7337 5
d7344 21
a7364 2
				// TODO set the properties
				tb.SetCustomAttribute(new CustomAttributeBuilder(type.GetConstructor(Type.EmptyTypes), new object[0]));
@


1.91
log
@*** empty log message ***
@
text
@d2547 15
d3120 3
d5642 18
d5860 1
a5860 1
				if(m != null && m.annotations != null && m.annotations[3] != null)
d5978 15
d6278 68
a6345 2
			object[] objs = new object[annotations.Length];
			for(int i = 0; i < annotations.Length; i++)
d6347 14
a6360 1
				objs[i] = JVM.Library.newAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[i]);
d6362 2
a6363 1
			return objs;
d6373 6
a6378 1
					return JVM.Library.newAnnotationElementValue(mw.DeclaringType.GetClassLoader().GetJavaClassLoader(), mw.ReturnType.ClassObject, impl.GetMethodDefaultValue(i));
@


1.90
log
@*** empty log message ***
@
text
@d3501 1
d3550 1
d4531 1
d4712 1
@


1.89
log
@*** empty log message ***
@
text
@d140 1
d142 1
d1226 10
d4762 5
a4766 1
				private static readonly Type localRefStructType = JVM.LoadType(typeof(IKVM.Runtime.JNI.Frame));
d5458 1
a5458 1
								CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(AnnotationDefaultAttribute)).GetConstructor(new Type[] { typeof(object) }), new object[] { classFile.Methods[index].AnnotationDefault });
d7108 2
a7109 2
				object[] attr = type.GetCustomAttributes(typeof(AnnotationAttributeAttribute), false);
				if(attr.Length == 1)
d7111 1
a7111 5
					Type annotationAttribute = type.Assembly.GetType(((AnnotationAttributeAttribute)attr[0]).AttributeType);
					if(annotationAttribute != null)
					{
						return new CompiledAnnotation(annotationAttribute);
					}
@


1.88
log
@*** empty log message ***
@
text
@d60 1
a60 1
		private static MethodInfo verboseCastFailure = JVM.SafeGetEnvironmentVariable("IKVM_VERBOSE_CAST") == null ? null : JVM.LoadType(typeof(ByteCodeHelper)).GetMethod("VerboseCastFailure");
d2676 1
a2676 1
			ilgen.Emit(OpCodes.Call, JVM.LoadType(typeof(ByteCodeHelper)).GetMethod("DynamicCast"));
d2683 1
a2683 1
			ilgen.Emit(OpCodes.Call, JVM.LoadType(typeof(ByteCodeHelper)).GetMethod("DynamicInstanceOf"));
d4602 1
a4602 1
					ilgen.Emit(OpCodes.Call, JVM.LoadType(typeof(ByteCodeHelper)).GetMethod("GetClassFromTypeHandle"));
a4755 1
				private static readonly MethodInfo getClassFromTypeHandle = JVM.LoadType(typeof(ByteCodeHelper)).GetMethod("GetClassFromTypeHandle");
d4778 1
a4778 1
						ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandle);
d4854 1
a4854 1
						ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandle);
d5420 1
a5420 1
								ilgen.Emit(OpCodes.Call, JVM.LoadType(typeof(ByteCodeHelper)).GetMethod("SkipFinalizer"));
@


1.87
log
@*** empty log message ***
@
text
@a6230 1000

#if STATIC_COMPILER
	class AotTypeWrapper : DynamicTypeWrapper
	{
		private FieldInfo ghostRefField;
		private MethodBuilder ghostIsInstanceMethod;
		private MethodBuilder ghostIsInstanceArrayMethod;
		private MethodBuilder ghostCastMethod;
		private MethodBuilder ghostCastArrayMethod;
		private TypeBuilder typeBuilderGhostInterface;
		private Annotation annotation;
		private static Hashtable ghosts;
		private static TypeWrapper[] mappedExceptions;
		private static bool[] mappedExceptionsAllSubClasses;
		private static Hashtable mapxml;

		internal AotTypeWrapper(ClassFile f, CompilerClassLoader loader)
			: base(f, loader)
		{
		}

		internal static void SetupGhosts(IKVM.Internal.MapXml.Root map)
		{
			ghosts = new Hashtable();

			// find the ghost interfaces
			foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
			{
				if(c.Shadows != null && c.Interfaces != null)
				{
					// NOTE we don't support interfaces that inherit from other interfaces
					// (actually, if they are explicitly listed it would probably work)
					TypeWrapper typeWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(c.Name);
					foreach(IKVM.Internal.MapXml.Interface iface in c.Interfaces)
					{
						TypeWrapper ifaceWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(iface.Name);
						if(ifaceWrapper == null || !ifaceWrapper.TypeAsTBD.IsAssignableFrom(typeWrapper.TypeAsTBD))
						{
							AddGhost(iface.Name, typeWrapper);
						}
					}
				}
			}
			// we manually add the array ghost interfaces
			TypeWrapper array = ClassLoaderWrapper.GetWrapperFromType(typeof(Array));
			AddGhost("java.io.Serializable", array);
			AddGhost("java.lang.Cloneable", array);
		}

		private static void AddGhost(string interfaceName, TypeWrapper implementer)
		{
			ArrayList list = (ArrayList)ghosts[interfaceName];
			if(list == null)
			{
				list = new ArrayList();
				ghosts[interfaceName] = list;
			}
			list.Add(implementer);
		}

		internal override bool IsGhost
		{
			get
			{
				return ghosts != null && IsInterface && ghosts.ContainsKey(Name);
			}
		}

		private class ExceptionMapEmitter : CodeEmitter
		{
			private IKVM.Internal.MapXml.ExceptionMapping[] map;

			internal ExceptionMapEmitter(IKVM.Internal.MapXml.ExceptionMapping[] map)
			{
				this.map = map;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				MethodWrapper mwSuppressFillInStackTrace = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("__<suppressFillInStackTrace>", "()V", false);
				mwSuppressFillInStackTrace.Link();
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Callvirt, typeof(Object).GetMethod("GetType"));
				MethodInfo GetTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle");
				for(int i = 0; i < map.Length; i++)
				{
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Ldtoken, Type.GetType(map[i].src));
					ilgen.Emit(OpCodes.Call, GetTypeFromHandle);
					ilgen.Emit(OpCodes.Ceq);
					Label label = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, label);
					ilgen.Emit(OpCodes.Pop);
					if(map[i].code != null)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						// TODO we should manually walk the instruction list and add a suppressFillInStackTrace call
						// before each newobj that instantiates an exception
						map[i].code.Emit(ilgen);
						ilgen.Emit(OpCodes.Ret);
					}
					else
					{
						TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map[i].dst);
						MethodWrapper mw = tw.GetMethodWrapper("<init>", "()V", false);
						mw.Link();
						mwSuppressFillInStackTrace.EmitCall(ilgen);
						mw.EmitNewobj(ilgen);
						ilgen.Emit(OpCodes.Ret);
					}
					ilgen.MarkLabel(label);
				}
				ilgen.Emit(OpCodes.Pop);
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Ret);
			}
		}

		internal static void LoadMapXml(IKVM.Internal.MapXml.Root map)
		{
			mapxml = new Hashtable();
			// HACK we've got a hardcoded location for the exception mapping method that is generated from the xml mapping
			mapxml["java.lang.ExceptionHelper.MapExceptionImpl(Ljava.lang.Throwable;)Ljava.lang.Throwable;"] = new ExceptionMapEmitter(map.exceptionMappings);
			foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
			{
				// HACK if it is not a remapped type, we assume it is a container for native methods
				if(c.Shadows == null)
				{
					string className = c.Name;
					mapxml.Add(className, c);
					if(c.Methods != null)
					{
						foreach(IKVM.Internal.MapXml.Method method in c.Methods)
						{
							if(method.body != null)
							{
								string methodName = method.Name;
								string methodSig = method.Sig;
								mapxml.Add(className + "." + methodName + methodSig, method.body);
							}
						}
					}
				}
			}
		}

		internal override bool IsMapUnsafeException
		{
			get
			{
				if(mappedExceptions != null)
				{
					for(int i = 0; i < mappedExceptions.Length; i++)
					{
						if(mappedExceptions[i].IsSubTypeOf(this) ||
							(mappedExceptionsAllSubClasses[i] && this.IsSubTypeOf(mappedExceptions[i])))
						{
							return true;
						}
					}
				}
				return false;
			}
		}

		internal static void LoadMappedExceptions(IKVM.Internal.MapXml.Root map)
		{
			if(map.exceptionMappings != null)
			{
				mappedExceptionsAllSubClasses = new bool[map.exceptionMappings.Length];
				mappedExceptions = new TypeWrapper[map.exceptionMappings.Length];
				for(int i = 0; i < mappedExceptions.Length; i++)
				{
					string dst = map.exceptionMappings[i].dst;
					if(dst[0] == '*')
					{
						mappedExceptionsAllSubClasses[i] = true;
						dst = dst.Substring(1);
					}
					mappedExceptions[i] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dst);
				}
			}
		}

		private static TypeWrapper[] GetGhostImplementers(TypeWrapper wrapper)
		{
			ArrayList list = (ArrayList)ghosts[wrapper.Name];
			if(list == null)
			{
				return TypeWrapper.EmptyArray;
			}
			return (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
		}

		internal override Type TypeAsBaseType
		{
			get
			{
				return typeBuilderGhostInterface != null ? typeBuilderGhostInterface : base.TypeAsBaseType;
			}
		}

		private static IKVM.Internal.MapXml.Param[] GetXmlMapParameters(string classname, string method, string sig)
		{
			if(mapxml != null)
			{
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[classname];
				if(clazz != null)
				{
					if(method == "<init>" && clazz.Constructors != null)
					{
						for(int i = 0; i < clazz.Constructors.Length; i++)
						{
							if(clazz.Constructors[i].Sig == sig)
							{
								return clazz.Constructors[i].Params;
							}
						}
					}
					else if(clazz.Methods != null)
					{
						for(int i = 0; i < clazz.Methods.Length; i++)
						{
							if(clazz.Methods[i].Name == method && clazz.Methods[i].Sig == sig)
							{
								return clazz.Methods[i].Params;
							}
						}
					}
				}
			}
			return null;
		}

		protected override void AddParameterNames(ClassFile classFile, ClassFile.Method m, MethodBase method)
		{
			IKVM.Internal.MapXml.Param[] parameters = GetXmlMapParameters(classFile.Name, m.Name, m.Signature);
			if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || parameters != null || JVM.Debug || DynamicClassLoader.IsSaveDebugImage)
			{
				string[] parameterNames = null;
				if(parameters != null)
				{
					parameterNames = new string[parameters.Length];
					for(int i = 0; i < parameters.Length; i++)
					{
						parameterNames[i] = parameters[i].Name;
					}
				}
				ParameterBuilder[] pbs = AddParameterNames(method, m, parameterNames);
				if((m.Modifiers & Modifiers.VarArgs) != 0 && pbs.Length > 0)
				{
					AttributeHelper.SetParamArrayAttribute(pbs[pbs.Length - 1]);
				}
				if(parameters != null)
				{
					for(int i = 0; i < pbs.Length; i++)
					{
						if(parameters[i].Attributes != null)
						{
							foreach(IKVM.Internal.MapXml.Attribute attr in parameters[i].Attributes)
							{
								AttributeHelper.SetCustomAttribute(pbs[i], attr);
							}
						}
					}
				}
			}
		}

		private void AddParameterNames(MethodBuilder method, MethodWrapper mw)
		{
			IKVM.Internal.MapXml.Param[] parameters = GetXmlMapParameters(Name, mw.Name, mw.Signature);
			if((JVM.IsStaticCompiler && mw.DeclaringType.IsPublic && (mw.IsPublic || mw.IsProtected)) || parameters != null || JVM.Debug || DynamicClassLoader.IsSaveDebugImage)
			{
				string[] parameterNames = null;
				if(parameters != null)
				{
					parameterNames = new string[parameters.Length];
					for(int i = 0; i < parameters.Length; i++)
					{
						parameterNames[i] = parameters[i].Name;
					}
				}
				ParameterBuilder[] pbs = AddParameterNames(method, mw.Signature, parameterNames);
				if((mw.Modifiers & Modifiers.VarArgs) != 0 && pbs.Length > 0)
				{
					AttributeHelper.SetParamArrayAttribute(pbs[pbs.Length - 1]);
				}
				if(parameters != null)
				{
					for(int i = 0; i < pbs.Length; i++)
					{
						if(parameters[i].Attributes != null)
						{
							foreach(IKVM.Internal.MapXml.Attribute attr in parameters[i].Attributes)
							{
								AttributeHelper.SetCustomAttribute(pbs[i], attr);
							}
						}
					}
				}
			}
		}

		protected override bool EmitMapXmlMethodBody(CountingILGenerator ilgen, ClassFile f, ClassFile.Method m)
		{
			if(mapxml != null)
			{
				CodeEmitter opcodes = (CodeEmitter)mapxml[f.Name + "." + m.Name + m.Signature];
				if(opcodes != null)
				{
					opcodes.Emit(ilgen);
					return true;
				}
			}
			return false;
		}

		private void PublishAttributes(TypeBuilder typeBuilder, IKVM.Internal.MapXml.Class clazz)
		{
			foreach(IKVM.Internal.MapXml.Attribute attr in clazz.Attributes)
			{
				AttributeHelper.SetCustomAttribute(typeBuilder, attr);
			}
		}

		private static bool CheckPropertyArgs(Type[] args1, Type[] args2)
		{
			if(args1.Length == args2.Length)
			{
				for(int i = 0; i < args1.Length; i++)
				{
					if(args1[i] != args2[i])
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		private static MethodAttributes GetPropertyMethodAttributes(MethodWrapper mw, bool final)
		{
			MethodAttributes attribs = MethodAttributes.HideBySig;
			if(mw.IsStatic)
			{
				attribs |= MethodAttributes.Static;
			}
			else
			{
				// NOTE in order for IntelliSense to consider the property a "real" property,
				// the getter and setter methods need to have substantially the same method attributes,
				// so we may need to look at our peer to determine whether we should be final
				// or not (and vice versa).
				attribs |= MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.CheckAccessOnOverride;
				if(final)
				{
					attribs |= MethodAttributes.Final;
				}
			}
			// TODO what happens if accessibility doesn't match our peer?
			if(mw.IsPublic)
			{
				attribs |= MethodAttributes.Public;
			}
			else if(mw.IsProtected)
			{
				attribs |= MethodAttributes.FamORAssem;
			}
			else if(mw.IsPrivate)
			{
				attribs |= MethodAttributes.Private;
			}
			else
			{
				attribs |= MethodAttributes.Assembly;
			}
			return attribs;
		}

		private void PublishProperties(TypeBuilder typeBuilder, IKVM.Internal.MapXml.Class clazz)
		{
			Hashtable classCache = new Hashtable();
			foreach(IKVM.Internal.MapXml.Property prop in clazz.Properties)
			{
				TypeWrapper typeWrapper = ClassFile.RetTypeWrapperFromSig(GetClassLoader(), classCache, prop.Sig);
				TypeWrapper[] propargs = ClassFile.ArgTypeWrapperListFromSig(GetClassLoader(), classCache, prop.Sig);
				Type[] indexer = new Type[propargs.Length];
				for(int i = 0; i < propargs.Length; i++)
				{
					indexer[i] = propargs[i].TypeAsSignatureType;
				}
				PropertyBuilder propbuilder = typeBuilder.DefineProperty(prop.Name, PropertyAttributes.None, typeWrapper.TypeAsSignatureType, indexer);
				if(prop.Attributes != null)
				{
					foreach(IKVM.Internal.MapXml.Attribute attr in prop.Attributes)
					{
						AttributeHelper.SetCustomAttribute(propbuilder, attr);
					}
				}
				MethodWrapper getter = null;
				MethodWrapper setter = null;
				if(prop.getter != null)
				{
					getter = GetMethodWrapper(prop.getter.Name, prop.getter.Sig, true);
					if(getter == null)
					{
						Console.Error.WriteLine("Warning: getter not found for {0}::{1}", clazz.Name, prop.Name);
					}
				}
				if(prop.setter != null)
				{
					setter = GetMethodWrapper(prop.setter.Name, prop.setter.Sig, true);
					if(setter == null)
					{
						Console.Error.WriteLine("Warning: setter not found for {0}::{1}", clazz.Name, prop.Name);
					}
				}
				bool final = (getter != null && getter.IsFinal) || (setter != null && setter.IsFinal);
				if(getter != null)
				{
					MethodWrapper mw = getter;
					if(!CheckPropertyArgs(mw.GetParametersForDefineMethod(), indexer) || mw.ReturnType != typeWrapper)
					{
						Console.Error.WriteLine("Warning: ignoring invalid property getter for {0}::{1}", clazz.Name, prop.Name);
					}
					else
					{
						MethodBuilder mb = mw.GetMethod() as MethodBuilder;
						if(mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final))
						{
							mb = typeBuilder.DefineMethod(GenerateUniqueMethodName("get_" + prop.Name, mw), GetPropertyMethodAttributes(mw, final), typeWrapper.TypeAsSignatureType, indexer);
							AttributeHelper.HideFromJava(mb);
							ILGenerator ilgen = new CountingILGenerator(mb.GetILGenerator());
							if(mw.IsStatic)
							{
								for(int i = 0; i < indexer.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, i);
								}
								mw.EmitCall(ilgen);
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								for(int i = 0; i < indexer.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, i + 1);
								}
								mw.EmitCallvirt(ilgen);
							}
							ilgen.Emit(OpCodes.Ret);
						}
						propbuilder.SetGetMethod(mb);
					}
				}
				if(setter != null)
				{
					MethodWrapper mw = setter;
					Type[] args = new Type[indexer.Length + 1];
					indexer.CopyTo(args, 0);
					args[args.Length - 1] = typeWrapper.TypeAsSignatureType;
					if(!CheckPropertyArgs(args, mw.GetParametersForDefineMethod()))
					{
						Console.Error.WriteLine("Warning: ignoring invalid property setter for {0}::{1}", clazz.Name, prop.Name);
					}
					else
					{
						MethodBuilder mb = mw.GetMethod() as MethodBuilder;
						if(mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final))
						{
							mb = typeBuilder.DefineMethod(GenerateUniqueMethodName("set_" + prop.Name, mw), GetPropertyMethodAttributes(mw, final), mw.ReturnTypeForDefineMethod, args);
							AttributeHelper.HideFromJava(mb);
							ILGenerator ilgen = new CountingILGenerator(mb.GetILGenerator());
							if(mw.IsStatic)
							{
								for(int i = 0; i <= indexer.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, i);
								}
								mw.EmitCall(ilgen);
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								for(int i = 0; i <= indexer.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, i + 1);
								}
								mw.EmitCallvirt(ilgen);
							}
							ilgen.Emit(OpCodes.Ret);
						}
						propbuilder.SetSetMethod(mb);
					}
				}
			}
		}

		protected override bool IsPInvokeMethod(ClassFile.Method m)
		{
			if(mapxml != null)
			{
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[Name];
				if(clazz != null && clazz.Methods != null)
				{
					foreach(IKVM.Internal.MapXml.Method method in clazz.Methods)
					{
						if(method.Name == m.Name && method.Sig == m.Signature)
						{
							if(method.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute attr in method.Attributes)
								{
									if(Type.GetType(attr.Type) == typeof(System.Runtime.InteropServices.DllImportAttribute))
									{
										return true;
									}
								}
							}
							break;
						}
					}
				}
			}
			return base.IsPInvokeMethod(m);
		}

		protected override void EmitMapXmlMetadata(TypeBuilder typeBuilder, ClassFile classFile, FieldWrapper[] fields, MethodWrapper[] methods)
		{
			if(mapxml != null)
			{
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[classFile.Name];
				if(clazz != null)
				{
					if(clazz.Attributes != null)
					{
						PublishAttributes(typeBuilder, clazz);
					}
					if(clazz.Properties != null)
					{
						PublishProperties(typeBuilder, clazz);
					}
					if(clazz.Fields != null)
					{
						foreach(IKVM.Internal.MapXml.Field field in clazz.Fields)
						{
							if(field.Attributes != null)
							{
								foreach(FieldWrapper fw in fields)
								{
									if(fw.Name == field.Name && fw.Signature == field.Sig)
									{
										FieldBuilder fb = fw.GetField() as FieldBuilder;
										if(fb != null)
										{
											foreach(IKVM.Internal.MapXml.Attribute attr in field.Attributes)
											{
												AttributeHelper.SetCustomAttribute(fb, attr);
											}
										}
									}
								}
							}
						}
					}
					if(clazz.Constructors != null)
					{
						foreach(IKVM.Internal.MapXml.Constructor constructor in clazz.Constructors)
						{
							if(constructor.Attributes != null)
							{
								foreach(MethodWrapper mw in methods)
								{
									if(mw.Name == "<init>" && mw.Signature == constructor.Sig)
									{
										ConstructorBuilder mb = mw.GetMethod() as ConstructorBuilder;
										if(mb != null)
										{
											foreach(IKVM.Internal.MapXml.Attribute attr in constructor.Attributes)
											{
												AttributeHelper.SetCustomAttribute(mb, attr);
											}
										}
									}
								}
							}
						}
					}
					if(clazz.Methods != null)
					{
						// HACK this isn't the right place to do this, but for now it suffices
						foreach(IKVM.Internal.MapXml.Method method in clazz.Methods)
						{
							// are we adding a new method?
							if(GetMethodWrapper(method.Name, method.Sig, false) == null)
							{
								bool setmodifiers = false;
								MethodAttributes attribs = method.MethodAttributes;
								Modifiers modifiers = (Modifiers)method.Modifiers;
								if((modifiers & Modifiers.Public) != 0)
								{
									attribs |= MethodAttributes.Public;
								}
								else if((modifiers & Modifiers.Protected) != 0)
								{
									attribs |= MethodAttributes.FamORAssem;
								}
								else if((modifiers & Modifiers.Private) != 0)
								{
									attribs |= MethodAttributes.Private;
								}
								else
								{
									attribs |= MethodAttributes.Assembly;
								}
								if((modifiers & Modifiers.Static) != 0)
								{
									attribs |= MethodAttributes.Static;
									if((modifiers & Modifiers.Final) != 0)
									{
										setmodifiers = true;
									}
								}
								else if(method.Name != "<init>")
								{
									attribs |= MethodAttributes.Virtual;
									if((modifiers & Modifiers.Final) != 0)
									{
										attribs |= MethodAttributes.Final;
									}
									else if((modifiers & Modifiers.Abstract) != 0)
									{
										attribs |= MethodAttributes.Abstract;
									}
								}
								if((modifiers & Modifiers.Synchronized) != 0)
								{
									throw new NotImplementedException();
								}
								if(method.Name == "<init>")
								{
									throw new NotImplementedException();
								}
								Hashtable classCache = new Hashtable();
								Type returnType = ClassFile.RetTypeWrapperFromSig(GetClassLoader(), classCache, method.Sig).TypeAsSignatureType;
								TypeWrapper[] parameterTypeWrappers = ClassFile.ArgTypeWrapperListFromSig(GetClassLoader(), classCache, method.Sig);
								Type[] parameterTypes = new Type[parameterTypeWrappers.Length];
								for(int i = 0; i < parameterTypeWrappers.Length; i++)
								{
									parameterTypes[i] = parameterTypeWrappers[i].TypeAsSignatureType;
								}
								MethodBuilder mb = typeBuilder.DefineMethod(method.Name, attribs, returnType, parameterTypes);
								if(setmodifiers)
								{
									AttributeHelper.SetModifiers(mb, modifiers, false);
								}
								ILGenerator ilgen = mb.GetILGenerator();
								method.body.Emit(ilgen);
								if(method.Attributes != null)
								{
									foreach(IKVM.Internal.MapXml.Attribute attr in method.Attributes)
									{
										AttributeHelper.SetCustomAttribute(mb, attr);
									}
								}
							}
						}
						foreach(IKVM.Internal.MapXml.Method method in clazz.Methods)
						{
							if(method.Attributes != null)
							{
								foreach(MethodWrapper mw in methods)
								{
									if(mw.Name == method.Name && mw.Signature == method.Sig)
									{
										MethodBuilder mb = mw.GetMethod() as MethodBuilder;
										if(mb != null)
										{
											foreach(IKVM.Internal.MapXml.Attribute attr in method.Attributes)
											{
												AttributeHelper.SetCustomAttribute(mb, attr);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		protected override MethodBuilder DefineGhostMethod(string name, MethodAttributes attribs, MethodWrapper mw)
		{
			if(typeBuilderGhostInterface != null)
			{
				return typeBuilderGhostInterface.DefineMethod(name, attribs, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
			}
			else
			{
				return base.DefineGhostMethod(name, attribs, mw);
			}
		}

		protected override void FinishGhost(TypeBuilder typeBuilder, MethodWrapper[] methods)
		{
			if(typeBuilderGhostInterface != null)
			{
				// TODO consider adding methods from base interface and java.lang.Object as well
				for(int i = 0; i < methods.Length; i++)
				{
					// skip <clinit>
					if(!methods[i].IsStatic)
					{
						TypeWrapper[] args = methods[i].GetParameters();
						MethodBuilder stub = typeBuilder.DefineMethod(methods[i].Name, MethodAttributes.Public, methods[i].ReturnTypeForDefineMethod, methods[i].GetParametersForDefineMethod());
						AddParameterNames(stub, methods[i]);
						AttributeHelper.SetModifiers(stub, methods[i].Modifiers, methods[i].IsInternal);
						ILGenerator ilgen = stub.GetILGenerator();
						Label end = ilgen.DefineLabel();
						TypeWrapper[] implementers = GetGhostImplementers(this);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Ldfld, ghostRefField);
						ilgen.Emit(OpCodes.Dup);
						ilgen.Emit(OpCodes.Isinst, typeBuilderGhostInterface);
						Label label = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brfalse_S, label);
						ilgen.Emit(OpCodes.Castclass, typeBuilderGhostInterface);
						for(int k = 0; k < args.Length; k++)
						{
							ilgen.Emit(OpCodes.Ldarg_S, (byte)(k + 1));
						}
						ilgen.Emit(OpCodes.Callvirt, (MethodInfo)methods[i].GetMethod());
						ilgen.Emit(OpCodes.Br, end);
						ilgen.MarkLabel(label);
						for(int j = 0; j < implementers.Length; j++)
						{
							ilgen.Emit(OpCodes.Dup);
							ilgen.Emit(OpCodes.Isinst, implementers[j].TypeAsTBD);
							label = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brfalse_S, label);
							ilgen.Emit(OpCodes.Castclass, implementers[j].TypeAsTBD);
							for(int k = 0; k < args.Length; k++)
							{
								ilgen.Emit(OpCodes.Ldarg_S, (byte)(k + 1));
							}
							MethodWrapper mw = implementers[j].GetMethodWrapper(methods[i].Name, methods[i].Signature, true);
							mw.EmitCallvirt(ilgen);
							ilgen.Emit(OpCodes.Br, end);
							ilgen.MarkLabel(label);
						}
						// we need to do a null check (null fails all the isinst checks)
						EmitHelper.NullCheck(ilgen);
						EmitHelper.Throw(ilgen, "java.lang.IncompatibleClassChangeError", Name);
						ilgen.MarkLabel(end);
						ilgen.Emit(OpCodes.Ret);
					}
				}
				// HACK create a scope to enable reuse of "implementers" name
				if(true)
				{
					MethodBuilder mb;
					ILGenerator ilgen;
					LocalBuilder local;
					// add implicit conversions for all the ghost implementers
					TypeWrapper[] implementers = GetGhostImplementers(this);
					for(int i = 0; i < implementers.Length; i++)
					{
						mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, TypeAsSignatureType, new Type[] { implementers[i].TypeAsSignatureType });
						ilgen = mb.GetILGenerator();
						local = ilgen.DeclareLocal(TypeAsSignatureType);
						ilgen.Emit(OpCodes.Ldloca, local);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Stfld, ghostRefField);
						ilgen.Emit(OpCodes.Ldloca, local);
						ilgen.Emit(OpCodes.Ldobj, TypeAsSignatureType);			
						ilgen.Emit(OpCodes.Ret);
					}
					// Implement the "IsInstance" method
					mb = ghostIsInstanceMethod;
					AttributeHelper.HideFromJava(mb);
					ilgen = mb.GetILGenerator();
					Label end = ilgen.DefineLabel();
					for(int i = 0; i < implementers.Length; i++)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
						Label label = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brfalse_S, label);
						ilgen.Emit(OpCodes.Ldc_I4_1);
						ilgen.Emit(OpCodes.Br, end);
						ilgen.MarkLabel(label);
					}
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Isinst, typeBuilderGhostInterface);
					ilgen.Emit(OpCodes.Ldnull);
					ilgen.Emit(OpCodes.Cgt_Un);
					ilgen.MarkLabel(end);
					ilgen.Emit(OpCodes.Ret);
					// Implement the "IsInstanceArray" method
					mb = ghostIsInstanceArrayMethod;
					AttributeHelper.HideFromJava(mb);
					ilgen = mb.GetILGenerator();
					LocalBuilder localType = ilgen.DeclareLocal(typeof(Type));
					ilgen.Emit(OpCodes.Ldarg_0);
					Label skip = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brtrue_S, skip);
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ret);
					ilgen.MarkLabel(skip);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Call, typeof(object).GetMethod("GetType"));
					ilgen.Emit(OpCodes.Stloc, localType);
					skip = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Br_S, skip);
					Label iter = ilgen.DefineLabel();
					ilgen.MarkLabel(iter);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Ldc_I4_1);
					ilgen.Emit(OpCodes.Sub);
					ilgen.Emit(OpCodes.Starg_S, (byte)1);
					ilgen.Emit(OpCodes.Ldloc, localType);
					ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("GetElementType"));
					ilgen.Emit(OpCodes.Stloc, localType);
					ilgen.MarkLabel(skip);
					ilgen.Emit(OpCodes.Ldloc, localType);
					ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("get_IsArray"));
					ilgen.Emit(OpCodes.Brtrue_S, iter);
					ilgen.Emit(OpCodes.Ldarg_1);
					skip = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, skip);
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ret);
					ilgen.MarkLabel(skip);
					for(int i = 0; i < implementers.Length; i++)
					{
						ilgen.Emit(OpCodes.Ldtoken, implementers[i].TypeAsTBD);
						ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
						ilgen.Emit(OpCodes.Ldloc, localType);
						ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("IsAssignableFrom"));
						Label label = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brfalse_S, label);
						ilgen.Emit(OpCodes.Ldc_I4_1);
						ilgen.Emit(OpCodes.Ret);
						ilgen.MarkLabel(label);
					}
					ilgen.Emit(OpCodes.Ldtoken, typeBuilderGhostInterface);
					ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
					ilgen.Emit(OpCodes.Ldloc, localType);
					ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("IsAssignableFrom"));
					ilgen.Emit(OpCodes.Ret);
						
					// Implement the "Cast" method
					mb = ghostCastMethod;
					AttributeHelper.HideFromJava(mb);
					ilgen = mb.GetILGenerator();
					end = ilgen.DefineLabel();
					for(int i = 0; i < implementers.Length; i++)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
						ilgen.Emit(OpCodes.Brtrue, end);
					}
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Castclass, typeBuilderGhostInterface);
					ilgen.Emit(OpCodes.Pop);
					ilgen.MarkLabel(end);
					local = ilgen.DeclareLocal(TypeAsSignatureType);
					ilgen.Emit(OpCodes.Ldloca, local);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Stfld, ghostRefField);
					ilgen.Emit(OpCodes.Ldloca, local);
					ilgen.Emit(OpCodes.Ldobj, TypeAsSignatureType);	
					ilgen.Emit(OpCodes.Ret);
					// Add "ToObject" methods
					mb = typeBuilder.DefineMethod("ToObject", MethodAttributes.HideBySig | MethodAttributes.Public, typeof(object), Type.EmptyTypes);
					AttributeHelper.HideFromJava(mb);
					ilgen = mb.GetILGenerator();
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldfld, ghostRefField);
					ilgen.Emit(OpCodes.Ret);

					// Implement the "CastArray" method
					// NOTE unlike "Cast" this doesn't return anything, it just throws a ClassCastException if the
					// cast is unsuccessful. Also, because of the complexity of this test, we call IsInstanceArray
					// instead of reimplementing the check here.
					mb = ghostCastArrayMethod;
					AttributeHelper.HideFromJava(mb);
					ilgen = mb.GetILGenerator();
					end = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Brfalse_S, end);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Call, ghostIsInstanceArrayMethod);
					ilgen.Emit(OpCodes.Brtrue_S, end);
					EmitHelper.Throw(ilgen, "java.lang.ClassCastException");
					ilgen.MarkLabel(end);
					ilgen.Emit(OpCodes.Ret);
				}
			}
		}

		protected override void FinishGhostStep2()
		{
			if(typeBuilderGhostInterface != null)
			{
				typeBuilderGhostInterface.CreateType();
			}
		}

		protected override TypeBuilder DefineType(TypeAttributes typeAttribs)
		{
			if(IsGhost)
			{
				typeAttribs &= ~(TypeAttributes.Interface | TypeAttributes.Abstract);
				typeAttribs |= TypeAttributes.Class | TypeAttributes.Sealed;
				TypeBuilder typeBuilder = classLoader.ModuleBuilder.DefineType(classLoader.MangleTypeName(Name), typeAttribs, typeof(ValueType));
				AttributeHelper.SetGhostInterface(typeBuilder);
				AttributeHelper.SetModifiers(typeBuilder, Modifiers, IsInternal);
				ghostRefField = typeBuilder.DefineField("__<ref>", typeof(object), FieldAttributes.Public | FieldAttributes.SpecialName);
				typeBuilderGhostInterface = typeBuilder.DefineNestedType("__Interface", TypeAttributes.Interface | TypeAttributes.Abstract | TypeAttributes.NestedPublic);
				AttributeHelper.HideFromJava(typeBuilderGhostInterface);
				ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object) });
				ghostIsInstanceMethod.DefineParameter(1, ParameterAttributes.None, "obj");
				ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object), typeof(int) });
				ghostIsInstanceArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
				ghostIsInstanceArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
				ghostCastMethod = typeBuilder.DefineMethod("Cast", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeBuilder, new Type[] { typeof(object) });
				ghostCastMethod.DefineParameter(1, ParameterAttributes.None, "obj");
				ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(object), typeof(int) });
				ghostCastArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
				ghostCastArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
				return typeBuilder;
			}
			else
			{
				return base.DefineType(typeAttribs);
			}
		}

		internal override FieldInfo GhostRefField
		{
			get
			{
				return ghostRefField;
			}
		}

		internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
		{
			if(IsGhost)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Call, ghostCastMethod);
				ilgen.Emit(OpCodes.Pop);
			}
			else if(IsGhostArray)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Call, ghostCastArrayMethod);
			}
			else
			{
				base.EmitCheckcast(context, ilgen);
			}
		}

		internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
		{
			if(IsGhost)
			{
				ilgen.Emit(OpCodes.Call, ghostIsInstanceMethod);
			}
			else if(IsGhostArray)
			{
				ilgen.Emit(OpCodes.Call, ghostIsInstanceArrayMethod);
			}
			else
			{
				base.EmitInstanceOf(context, ilgen);
			}
		}

		internal void SetAnnotation(Annotation annotation)
		{
			this.annotation = annotation;
		}

		internal override Annotation Annotation
		{
			get
			{
				return annotation;
			}
		}
	}
#endif // STATIC_COMPILER
@


1.86
log
@*** empty log message ***
@
text
@a131 29

	class StaticCompiler
	{
		internal static Type GetType(string name)
		{
#if WHIDBEY
			foreach(Assembly asm in AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies())
			{
				Type t = asm.GetType(name, false);
				if(t != null)
				{
					return t;
				}
			}
			// try mscorlib as well
			return typeof(object).Assembly.GetType(name, true);
#else
			foreach(Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
			{
				Type t = asm.GetType(name, false);
				if(t != null)
				{
					return t;
				}
			}
			throw new TypeLoadException(name);
#endif
		}
	}
d238 1
a238 1
#if !NO_STATIC_COMPILER && !COMPACT_FRAMEWORK
d481 1
d486 1
a486 8
				if(JVM.IsStaticCompiler)
				{
					editorBrowsableNever = new CustomAttributeBuilder(StaticCompiler.GetType("System.ComponentModel.EditorBrowsableAttribute").GetConstructor(new Type[] { StaticCompiler.GetType("System.ComponentModel.EditorBrowsableState") }), new object[] { (int)System.ComponentModel.EditorBrowsableState.Never });
				}
				else
				{
					editorBrowsableNever = new CustomAttributeBuilder(typeof(System.ComponentModel.EditorBrowsableAttribute).GetConstructor(new Type[] { typeof(System.ComponentModel.EditorBrowsableState) }), new object[] { System.ComponentModel.EditorBrowsableState.Never });
				}
d495 1
a495 8
				if(JVM.IsStaticCompiler)
				{
					editorBrowsableNever = new CustomAttributeBuilder(StaticCompiler.GetType("System.ComponentModel.EditorBrowsableAttribute").GetConstructor(new Type[] { StaticCompiler.GetType("System.ComponentModel.EditorBrowsableState") }), new object[] { (int)System.ComponentModel.EditorBrowsableState.Never });
				}
				else
				{
					editorBrowsableNever = new CustomAttributeBuilder(typeof(System.ComponentModel.EditorBrowsableAttribute).GetConstructor(new Type[] { typeof(System.ComponentModel.EditorBrowsableState) }), new object[] { System.ComponentModel.EditorBrowsableState.Never });
				}
d499 1
d583 1
a583 1
#endif
d1376 1
a1376 1
	public abstract class TypeWrapper
d1384 1
d1386 1
d1402 1
d1430 1
d2535 1
d2549 1
d2564 1
d2566 1
d2571 2
a2572 1
			if(JVM.IsStaticCompiler && name != "<verifier>")
d2590 1
d3109 1
d3111 1
d3128 2
a3129 8
						if(JVM.IsStaticCompiler)
						{
							if(!IsSideEffectFreeStaticInitializer(m))
							{
								hasclinit = true;
							}
						}
						else
d3133 3
d3175 2
a3176 1
					if(wrapper.IsPublic && JVM.IsStaticCompiler)
d3190 1
d3217 2
a3218 1
				if(!wrapper.IsInterface && wrapper.IsPublic && JVM.IsStaticCompiler)
d3224 1
d3453 2
a3454 1
					if(JVM.IsStaticCompiler && f.IsAnnotation)
d3459 1
d4074 1
a4074 1
							Tracer.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
d4093 1
a4093 1
									Tracer.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
d4107 1
a4107 1
									Tracer.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
d4114 4
a4117 5
									Type nativeCodeType = Type.GetType("IKVM.NativeCode." + classFile.Name.Replace('$', '+'));
									if(nativeCodeType != null)
									{
										nativeCodeType = JVM.LoadType(nativeCodeType);
									}
d4196 1
a4196 1
								Tracer.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
d4251 1
d4254 1
a4254 1
							if(JVM.IsStaticCompiler && interfaces[i].IsGhost && wrapper.IsPublic)
d4266 1
d4309 1
d4313 1
a4313 1
					if(JVM.IsStaticCompiler && classFile.IsInterface && classFile.IsPublic && !wrapper.IsGhost && classFile.Fields.Length > 0)
d4351 1
a4351 1
					if(JVM.IsStaticCompiler || DynamicClassLoader.IsSaveDebugImage)
d4403 1
d4410 1
d4423 1
d4446 23
d4790 2
a4791 1
					FieldBuilder methodPtr = typeBuilder.DefineField(JNI.METHOD_PTR_FIELD_PREFIX + m.Name + sig, typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
d5440 2
a5441 1
							if(JVM.IsStaticCompiler && classFile.Methods[index].AnnotationDefault != null)
d5443 1
a5443 1
								CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(AnnotationDefaultAttribute).GetConstructor(new Type[] { typeof(object) }), new object[] { classFile.Methods[index].AnnotationDefault });
d5446 1
d6204 1
d6229 1
d6232 1
a6232 1
#if !NO_STATIC_COMPILER
d7230 1
a7230 1
#endif // !NO_STATIC_COMPILER
d7889 1
d7920 1
d8556 1
d8563 1
d8629 1
d8656 1
d8680 1
d8686 1
d8737 1
d8745 1
d8782 1
d8787 1
d8814 1
d8824 1
d9056 1
d9062 1
@


1.85
log
@*** empty log message ***
@
text
@a3139 1
#if GENERICS
a3140 1
#endif
a3480 1
#if GENERICS
a3485 1
#endif
a4440 1
#if GENERICS
a4444 1
#endif
a4523 2
					annotationTypeBuilder = o.typeBuilder;

d4540 3
d4589 5
d4689 4
a4692 1
					tb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
@


1.84
log
@*** empty log message ***
@
text
@d44 12
d745 4
d756 1
a756 1
			return attr.Length == 1 ? new ModifiersAttribute(((ModifiersAttribute)attr[0]).Modifiers) : null;
d759 1
a759 1
		internal static Modifiers GetModifiers(MethodBase mb, bool assemblyIsPrivate)
d769 5
a773 1
						return (Modifiers)args[0].Value;
d783 2
a784 1
					return ((ModifiersAttribute)customAttribute[0]).Modifiers;
d837 1
a837 1
			return modifiers;
d840 1
a840 1
		internal static Modifiers GetModifiers(FieldInfo fi, bool assemblyIsPrivate)
d850 5
a854 1
						return (Modifiers)args[0].Value;
d864 2
a865 1
					return ((ModifiersAttribute)customAttribute[0]).Modifiers;
d898 1
a898 1
			return modifiers;
d902 1
a902 1
		internal static void SetModifiers(MethodBuilder mb, Modifiers modifiers)
d904 9
a912 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers }), new object[] { modifiers });
d916 1
a916 1
		internal static void SetModifiers(ConstructorBuilder cb, Modifiers modifiers)
d918 9
a926 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers }), new object[] { modifiers });
d930 1
a930 1
		internal static void SetModifiers(FieldBuilder fb, Modifiers modifiers)
d932 9
a940 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers }), new object[] { modifiers });
d944 1
a944 1
		internal static void SetModifiers(TypeBuilder tb, Modifiers modifiers)
d946 9
a954 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers }), new object[] { modifiers });
d1409 8
d1421 1
a1425 1
		private bool hasIncompleteInterfaceImplementation;
d1486 1
a1486 1
				return hasIncompleteInterfaceImplementation || (baseWrapper != null && baseWrapper.HasIncompleteInterfaceImplementation);
d1490 9
a1498 1
				hasIncompleteInterfaceImplementation = value;
d1506 13
a1518 1
				return false;
d1664 20
d1864 3
a1866 1
			return IsPublic || IsInSamePackageAs(wrapper);
a2947 1
		private bool hasStaticInitializer;
d2964 1
a3028 8
		internal override bool HasStaticInitializer
		{
			get
			{
				return hasStaticInitializer;
			}
		}

d3171 5
d3178 1
a3178 1
						methods[i] = new MethodWrapper.GhostMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, MemberFlags.None);
d3182 1
a3182 1
						methods[i] = new SmartConstructorMethodWrapper(wrapper, m.Name, m.Signature, null, null, m.Modifiers, MemberFlags.None);
a3185 1
						bool explicitOverride = false;
d3188 1
d3190 4
d3195 1
a3195 1
						methods[i] = new SmartCallMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, explicitOverride ? MemberFlags.ExplicitOverride : MemberFlags.None, SimpleOpCode.Call, SimpleOpCode.Callvirt);
d3198 1
a3198 1
				wrapper.hasStaticInitializer = hasclinit;
d3242 1
a3242 1
						fields[i] = new GetterFieldWrapper(wrapper, null, null, fld.Name, fld.Signature, fld.Modifiers, null);
d3246 1
a3246 1
						fields[i] = FieldWrapper.Create(wrapper, null, null, fld.Name, fld.Signature, fld.Modifiers);
d3347 1
a3347 1
					if(f.IsPublic && !f.IsInternal)
d3872 1
a3872 1
				else if(fld.IsPublic && !fld.IsInternal)
d3965 1
a3965 1
					if(setModifiers || (fld.Modifiers & (Modifiers.Synthetic | Modifiers.Enum)) != 0)
d3967 1
a3967 6
						Modifiers mods = fld.Modifiers;
						if(fld.IsPublic && fld.IsInternal)
						{
							mods &= ~Modifiers.Public;
						}
						AttributeHelper.SetModifiers(field, mods);
d4382 1
a4382 1
						if((classFile.Modifiers & (Modifiers.Synthetic | Modifiers.Annotation | Modifiers.Enum)) != 0)
d4384 1
a4384 6
							Modifiers mods = classFile.Modifiers;
							if(classFile.IsPublic && classFile.IsInternal)
							{
								mods &= ~Modifiers.Public;
							}
							AttributeHelper.SetModifiers(typeBuilder, mods);
d4579 1
a4579 1
						AttributeHelper.SetModifiers(attributeTypeBuilder, Modifiers.Final);
a5043 1
					// TODO we need to handle static methods (duh!)
d5051 4
a5054 1
					if(baseMethod.IsFinal && !baseMethod.IsPrivate)
d5058 4
d5064 1
a5064 1
					if(baseMethod.IsPublic || baseMethod.IsProtected)
d5075 2
a5076 2
					// RULE 3: private methods are ignored
					if(!baseMethod.IsPrivate)
d5079 2
a5080 1
						if(baseMethod.DeclaringType.IsInSamePackageAs(wrapper))
d5216 1
a5216 1
					else if(m.IsPublic && !m.IsInternal)
d5307 1
a5307 1
									((baseMethod.IsFamily || baseMethod.IsFamilyOrAssembly) && (!m.IsPublic || m.IsInternal) && !m.IsProtected) ||
d5448 1
a5448 1
						if(setModifiers || (m.Modifiers & (Modifiers.Synthetic | Modifiers.Bridge)) != 0)
a5449 5
							Modifiers mods = m.Modifiers;
							if(m.IsPublic && m.IsInternal)
							{
								mods &= ~Modifiers.Public;
							}
d5452 1
a5452 1
								AttributeHelper.SetModifiers((ConstructorBuilder)method, mods);
d5456 1
a5456 1
								AttributeHelper.SetModifiers((MethodBuilder)method, mods);
d6877 1
a6877 1
									AttributeHelper.SetModifiers(mb, modifiers);
d6940 1
a6940 1
						AttributeHelper.SetModifiers(stub, methods[i].Modifiers);
d7142 1
a7142 1
				AttributeHelper.SetModifiers(typeBuilder, Modifiers);
d7293 1
d7314 1
a7314 1
						Modifiers modifiers = AttributeHelper.GetModifiers(method, false);
d7337 1
a7337 1
				Modifiers modifiers = AttributeHelper.GetModifiers(mb, false);
d7344 1
d7362 1
a7362 1
				return new CompiledRemappedMethodWrapper(this, name, sig, mb, retType, paramTypes, modifiers, false, mbHelper, mbNonvirtualHelper);
d7464 6
d7471 1
a7471 1
			: base(GetModifiers(type), name, GetBaseTypeWrapper(type))
d7484 1
a7484 1
		private static Modifiers GetModifiers(Type type)
d7489 1
a7489 1
				return attr.Modifiers;
d7528 1
a7528 1
			return modifiers;
d7787 6
a7792 1
							methods.Add(MethodWrapper.Create(this, name, sig, method, retType, paramTypes, AttributeHelper.GetModifiers(method, false), flags));
d7834 3
a7836 2
			internal CompiledRemappedMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection, MethodInfo mbHelper, MethodInfo mbNonvirtualHelper)
				: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
d7923 1
a7923 1
			Modifiers modifiers = AttributeHelper.GetModifiers(field, false);
d7935 1
a7935 1
			if(field.IsPrivate && ((modifiers & Modifiers.Private) == 0))
d7950 5
a7954 1
				return new ConstantFieldWrapper(this, type, name, type.SigName, modifiers, field, null, flags);
d8344 1
a8344 1
						AttributeHelper.SetModifiers(typeBuilder, Modifiers.Public | Modifiers.Interface | Modifiers.Abstract);
d8675 1
a8675 1
				: base(tw, fieldType, "Value", fieldType.SigName, Modifiers.Public | Modifiers.Final, null)
d8866 1
a8866 1
						fieldsList.Add(CreateFieldWrapperDotNet(AttributeHelper.GetModifiers(fields[i], true), fields[i].Name, fields[i].FieldType, fields[i]));
d9238 1
a9238 1
				return FieldWrapper.Create(this, type, field, name, type.SigName, modifiers);
d9244 2
a9245 1
			Modifiers mods = AttributeHelper.GetModifiers(mb, true);
@


1.83
log
@*** empty log message ***
@
text
@d3238 1
a3238 1
					if(f.IsPublic)
d3763 1
a3763 1
				else if(fld.IsPublic)
d3858 6
a3863 1
						AttributeHelper.SetModifiers(field, fld.Modifiers);
d4280 6
a4285 1
							AttributeHelper.SetModifiers(typeBuilder, classFile.Modifiers);
d5110 1
a5110 1
					else if(m.IsPublic)
d5201 1
a5201 1
									((baseMethod.IsFamily || baseMethod.IsFamilyOrAssembly) && !m.IsPublic && !m.IsProtected) ||
d5344 5
d5351 1
a5351 1
								AttributeHelper.SetModifiers((ConstructorBuilder)method, m.Modifiers);
d5355 1
a5355 1
								AttributeHelper.SetModifiers((MethodBuilder)method, m.Modifiers);
@


1.82
log
@*** empty log message ***
@
text
@d1398 5
@


1.81
log
@*** empty log message ***
@
text
@a1206 30
		private static object[] GetCustomAttributes(MemberInfo member, Type attribute)
		{
#if WHIDBEY && !COMPACT_FRAMEWORK
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
			{
				ArrayList attrs = new ArrayList();
				foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(member))
				{
					// NOTE we don't support subtyping relations!
					if(cad.Constructor.DeclaringType == attribute)
					{
						ConstructorInfo ci = cad.Constructor;
						object[] parameters = new object[cad.ConstructorArguments.Count];
						for(int i = 0; i < parameters.Length; i++)
						{
							parameters[i] = cad.ConstructorArguments[i];
						}
						if(cad.NamedArguments.Count > 0)
						{
							throw new NotImplementedException("NamedArguments: " + attribute.Name);
						}
						attrs.Add(ci.Invoke(parameters));
					}
				}
				return attrs.ToArray();
			}
#endif
			return member.GetCustomAttributes(attribute, false);
		}

@


1.80
log
@*** empty log message ***
@
text
@a1382 1
		private readonly ClassLoaderWrapper classLoader;
d1388 1
a1388 1
		private readonly object classObject;
d1394 1
a1394 1
		internal TypeWrapper(Modifiers modifiers, string name, TypeWrapper baseWrapper, ClassLoaderWrapper classLoader, object protectionDomain)
d1403 5
a1407 9
			this.classLoader = classLoader;
			if(IsUnloadable || IsVerifierType || JVM.IsStaticCompiler)
			{
				this.classObject = null;
			}
			else
			{
				this.classObject = JVM.Library.newClass(this, protectionDomain);
			}
d1414 10
a1423 1
				Debug.Assert(!IsUnloadable && !IsVerifierType);
d1654 1
a1654 4
		internal virtual ClassLoaderWrapper GetClassLoader()
		{
			return classLoader;
		}
d1969 1
a1969 1
						return classLoader.LoadClassByDottedNameFast(name.Substring(1));
d1973 1
a1973 1
						return classLoader.LoadClassByDottedNameFast(name.Substring(2, name.Length - 3));
d2519 1
a2519 1
			: base(TypeWrapper.UnloadableModifiersHack, name, null, null, null)
d2541 5
d2672 1
a2672 1
			: base(Modifiers.Public | Modifiers.Abstract | Modifiers.Final, null, null, null, null)
d2862 1
d2877 2
a2878 2
		internal DynamicTypeWrapper(ClassFile f, ClassLoaderWrapper classLoader, object protectionDomain)
			: base(f.Modifiers, f.Name, f.IsInterface ? null : LoadTypeWrapper(classLoader, f.SuperClass), classLoader, protectionDomain)
d2881 1
d2941 5
d2958 1
a2958 1
				return ((DynamicClassLoader)GetClassLoader()).ModuleBuilder.Assembly;
d3309 1
a3309 1
							typeBuilder = ((DynamicClassLoader)wrapper.GetClassLoader()).ModuleBuilder.DefineType(((DynamicClassLoader)wrapper.GetClassLoader()).MangleTypeName(f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
d4490 1
a4490 1
						attributeTypeBuilder = ((DynamicClassLoader)o.wrapper.GetClassLoader()).ModuleBuilder.DefineType(o.classFile.Name + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
d6047 1
a6047 1
			return ((DynamicClassLoader)GetClassLoader()).ModuleBuilder.DefineType(((DynamicClassLoader)GetClassLoader()).MangleTypeName(Name), typeAttribs);
d6146 2
a6147 2
		internal AotTypeWrapper(ClassFile f, ClassLoaderWrapper loader)
			: base(f, loader, null)
d7049 1
a7049 1
				TypeBuilder typeBuilder = ((DynamicClassLoader)GetClassLoader()).ModuleBuilder.DefineType(((DynamicClassLoader)GetClassLoader()).MangleTypeName(Name), typeAttribs, typeof(ValueType));
a7370 5
		private static ClassLoaderWrapper GetClassLoader(Type type)
		{
			return JVM.IsStaticCompiler || ClassLoaderWrapper.IsCoreAssemblyType(type) ? ClassLoaderWrapper.GetBootstrapClassLoader() : ClassLoaderWrapper.GetSystemClassLoader();
		}

d7372 1
a7372 1
			: base(GetModifiers(type), name, GetBaseTypeWrapper(type), GetClassLoader(type), null)
d7380 5
d8391 1
a8391 1
			: base(GetModifiers(type), GetName(type), GetBaseTypeWrapper(type), null, null)
d9293 1
d9296 1
a9296 1
			: base(modifiers, name, CoreClasses.java.lang.Object.Wrapper, classLoader, null)
d9300 6
@


1.79
log
@*** empty log message ***
@
text
@d7858 8
d9229 8
@


1.78
log
@*** empty log message ***
@
text
@d2945 1
a2945 1
				return GetClassLoader().ModuleBuilder.Assembly;
d3296 1
a3296 1
							typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
d3331 1
a3331 1
					if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage)
d3864 1
a3864 1
				if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage)
d4110 1
a4110 1
											if(ClassLoaderWrapper.IsSaveDebugImage)
d4282 1
a4282 1
					if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage)
d4477 1
a4477 1
						attributeTypeBuilder = o.wrapper.GetClassLoader().ModuleBuilder.DefineType(o.classFile.Name + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
d4605 2
a4606 2
					AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, ClassLoaderWrapper.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
					ClassLoaderWrapper.RegisterForSaveDebug(ab);
d5341 1
a5341 1
					if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage)
d5999 1
a5999 1
			if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d6034 1
a6034 1
			return GetClassLoader().ModuleBuilder.DefineType(GetClassLoader().MangleTypeName(Name), typeAttribs);
d6354 1
a6354 1
			if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || parameters != null || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d6389 1
a6389 1
			if((JVM.IsStaticCompiler && mw.DeclaringType.IsPublic && (mw.IsPublic || mw.IsProtected)) || parameters != null || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d7036 1
a7036 1
				TypeBuilder typeBuilder = GetClassLoader().ModuleBuilder.DefineType(GetClassLoader().MangleTypeName(Name), typeAttribs, typeof(ValueType));
d8210 2
a8211 1
						ModuleBuilder moduleBuilder = ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder;
@


1.77
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
d2429 1
a2429 1
		// NOTE returns null for primitive types
d7970 1
d7979 5
d8053 8
d8064 1
a8064 1
				return type.FullName.Replace('+', '$');
d8067 1
a8067 1
			return MangleTypeName(type.FullName);
d8185 1
a8185 1
				if(Whidbey.IsGenericTypeDefinition(type))
@


1.76
log
@*** empty log message ***
@
text
@d33 1
@


1.75
log
@*** empty log message ***
@
text
@d8537 1
a8537 6
				ilgen.Emit(OpCodes.Unbox, tw.type);
				// FXBUG the .NET 1.1 verifier doesn't understand that ldobj on an enum that has an underlying type
				// of byte or short that the resulting type on the stack is an int32, so we have to
				// to it the hard way. Note that this is fixed in Whidbey.
				Type underlyingType = Enum.GetUnderlyingType(tw.type);
				if(underlyingType == typeof(sbyte) || underlyingType == typeof(byte))
d8539 1
a8539 1
					ilgen.Emit(OpCodes.Ldind_I1);
d8541 1
a8541 1
				else if(underlyingType == typeof(short) || underlyingType == typeof(ushort))
d8543 21
a8563 9
					ilgen.Emit(OpCodes.Ldind_I2);
				}
				else if(underlyingType == typeof(int) || underlyingType == typeof(uint))
				{
					ilgen.Emit(OpCodes.Ldind_I4);
				}
				else if(underlyingType == typeof(long) || underlyingType == typeof(ulong))
				{
					ilgen.Emit(OpCodes.Ldind_I8);
@


1.74
log
@*** empty log message ***
@
text
@d725 1
a725 1
			if(JVM.IsStaticCompiler)
d745 1
a745 1
			if(JVM.IsStaticCompiler)
d821 1
a821 1
			if(JVM.IsStaticCompiler)
d1050 1
a1050 1
			if(JVM.IsStaticCompiler)
d1070 1
a1070 1
			if(JVM.IsStaticCompiler)
d1088 1
a1088 1
		private static T[] DecodeArray<T>(CustomAttributeTypedArgument arg)
d1103 1
a1103 1
			if(JVM.IsStaticCompiler)
d1123 1
a1123 1
			if(JVM.IsStaticCompiler)
d1143 1
a1143 1
			if(JVM.IsStaticCompiler)
d1166 1
a1166 1
			if(JVM.IsStaticCompiler)
d1209 1
a1209 1
			if(JVM.IsStaticCompiler)
d1239 1
a1239 1
			if(JVM.IsStaticCompiler)
d1258 1
a1258 1
			if(JVM.IsStaticCompiler)
d1276 1
a1276 1
			if(JVM.IsStaticCompiler)
d1295 1
a1295 1
			if(JVM.IsStaticCompiler)
d1314 1
a1314 1
			if(JVM.IsStaticCompiler)
d2271 1
a2271 1
		internal void EmitUnbox(ILGenerator ilgen)
d2275 1
a2275 13
			Type type = this.TypeAsTBD;
			// NOTE if the reference is null, we treat it as a default instance of the value type.
			ilgen.Emit(OpCodes.Dup);
			Label label1 = ilgen.DefineLabel();
			ilgen.Emit(OpCodes.Brtrue_S, label1);
			ilgen.Emit(OpCodes.Pop);
			ilgen.Emit(OpCodes.Ldloc, ilgen.DeclareLocal(type));
			Label label2 = ilgen.DefineLabel();
			ilgen.Emit(OpCodes.Br_S, label2);
			ilgen.MarkLabel(label1);
			ilgen.Emit(OpCodes.Unbox, type);
			ilgen.Emit(OpCodes.Ldobj, type);
			ilgen.MarkLabel(label2);
d2278 1
a2278 1
		internal void EmitBox(ILGenerator ilgen)
d2282 1
a2282 1
			ilgen.Emit(OpCodes.Box, this.TypeAsTBD);
d3298 1
d3304 24
d7970 1
d7981 5
d8208 29
d8239 32
d8272 1
a8272 1
			if(JVM.IsStaticCompiler)
d8294 1
@


1.73
log
@*** empty log message ***
@
text
@d26 3
d30 1
d32 2
a39 1
using ILGenerator = IKVM.Internal.CountingILGenerator;
d43 1
d47 3
a49 1
		private static MethodInfo verboseCastFailure = JVM.SafeGetEnvironmentVariable("IKVM_VERBOSE_CAST") == null ? null : typeof(ByteCodeHelper).GetMethod("VerboseCastFailure");
d120 30
d152 1
d165 25
d199 12
d254 1
a254 1
#if! NO_STATIC_COMPILER
d278 1
a278 1
			Type t = Type.GetType(attr.Type, true);
d294 1
a294 1
				Type t = Type.GetType(attr.Type, true);
d412 1
a412 1
				Type t = Type.GetType(attr.Type, true);
d418 4
d468 4
d495 2
d501 8
a508 1
				editorBrowsableNever = new CustomAttributeBuilder(typeof(System.ComponentModel.EditorBrowsableAttribute).GetConstructor(new Type[] { typeof(System.ComponentModel.EditorBrowsableState) }), new object[] { System.ComponentModel.EditorBrowsableState.Never });
d517 8
a524 1
				editorBrowsableNever = new CustomAttributeBuilder(typeof(System.ComponentModel.EditorBrowsableAttribute).GetConstructor(new Type[] { typeof(System.ComponentModel.EditorBrowsableState) }), new object[] { System.ComponentModel.EditorBrowsableState.Never });
d570 1
a570 1
					throwsAttribute = typeof(ThrowsAttribute).GetConstructor(new Type[] { typeof(string[]) });
d589 1
a589 1
				ghostInterfaceAttribute = new CustomAttributeBuilder(typeof(GhostInterfaceAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d596 1
a596 1
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d602 1
a602 1
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d608 1
a608 1
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d611 1
d615 1
a615 1
			return mi.IsDefined(typeof(HideFromReflectionAttribute), false);
d620 1
a620 1
			return fi.IsDefined(typeof(HideFromReflectionAttribute), false);
d625 1
a625 1
			return pi.IsDefined(typeof(HideFromReflectionAttribute), false);
d628 1
d633 1
a633 1
				hideFromJavaAttribute = new CustomAttributeBuilder(typeof(HideFromJavaAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d642 1
a642 1
				hideFromJavaAttribute = new CustomAttributeBuilder(typeof(HideFromJavaAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d651 1
a651 1
				hideFromJavaAttribute = new CustomAttributeBuilder(typeof(HideFromJavaAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d660 1
a660 1
				hideFromJavaAttribute = new CustomAttributeBuilder(typeof(HideFromJavaAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d664 6
d685 1
a685 1
			return mi.IsDefined(typeof(HideFromJavaAttribute), false);
d688 1
d700 1
a700 1
					implementsAttribute = typeof(ImplementsAttribute).GetConstructor(new Type[] { typeof(string[]) });
d705 36
d744 2
a745 2
			object[] customAttribute = mb.GetCustomAttributes(typeof(ModifiersAttribute), false);
			if(customAttribute.Length == 1)
d747 17
a763 1
				return ((ModifiersAttribute)customAttribute[0]).Modifiers;
d811 1
a811 1
			if(parameters.Length > 0 && parameters[parameters.Length - 1].IsDefined(typeof(ParamArrayAttribute), false))
d820 14
a833 2
			object[] customAttribute = fi.GetCustomAttributes(typeof(ModifiersAttribute), false);
			if(customAttribute.Length == 1)
d835 5
a839 1
				return ((ModifiersAttribute)customAttribute[0]).Modifiers;
d874 1
d877 1
a877 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
d883 1
a883 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
d889 1
a889 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
d895 1
a895 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
d901 1
a901 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(NameSigAttribute).GetConstructor(new Type[] { typeof(string), typeof(string) }), new object[] { name, sig });
d915 1
a915 1
			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(NameSigAttribute).GetConstructor(new Type[] { typeof(string), typeof(string) }), new object[] { name, sig });
d931 1
a931 1
			Type[] argTypes = new Type[] { typeof(string), typeof(Modifiers) };
d933 1
a933 1
			ConstructorInfo ci = typeof(InnerClassAttribute).GetConstructor(argTypes);
d938 6
d948 1
a948 1
				sourceFileAttribute = typeof(SourceFileAttribute).GetConstructor(new Type[] { typeof(string) });
d953 9
d970 1
a970 1
					lineNumberTableAttribute2 = typeof(LineNumberTableAttribute).GetConstructor(new Type[] { typeof(ushort) });
d979 1
a979 1
					lineNumberTableAttribute1 = typeof(LineNumberTableAttribute).GetConstructor(new Type[] { typeof(byte[]) });
d998 1
a998 1
				enclosingMethodAttribute = typeof(EnclosingMethodAttribute).GetConstructor(new Type[] { typeof(string), typeof(string), typeof(string) });
d1007 1
a1007 1
				signatureAttribute = typeof(SignatureAttribute).GetConstructor(new Type[] { typeof(string) });
d1016 1
a1016 1
				signatureAttribute = typeof(SignatureAttribute).GetConstructor(new Type[] { typeof(string) });
d1025 1
a1025 1
				signatureAttribute = typeof(SignatureAttribute).GetConstructor(new Type[] { typeof(string) });
d1045 326
d1373 1
d1378 1
d1832 1
d1842 1
d2114 1
d2250 1
d2270 1
d2410 1
d2458 1
a2458 1
			if(type.Module.IsDefined(typeof(JavaModuleAttribute), false))
d2480 1
d2484 1
d2513 1
d2521 1
d2624 1
d2629 1
a2629 1
			ilgen.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicCast"));
d2636 1
a2636 1
			ilgen.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicInstanceOf"));
d2638 1
d2766 1
d3063 1
d3065 1
d3826 1
a3826 2
						CustomAttributeBuilder constantValueAttrib = new CustomAttributeBuilder(typeof(ConstantValueAttribute).GetConstructor(new Type[] { constantValue.GetType() }), new object[] { constantValue });
						field.SetCustomAttribute(constantValueAttrib);
d3983 1
d4001 1
a4001 1
							Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator);
d4034 4
d4122 1
a4122 1
								Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref nonleaf);
d4334 1
d4339 1
d4489 1
a4489 1
					ilgen.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("GetClassFromTypeHandle"));
d4594 1
a4594 2
					CustomAttributeBuilder ikvmModuleAttr = new CustomAttributeBuilder(typeof(JavaModuleAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
					mod.SetCustomAttribute(ikvmModuleAttr);					
d4634 1
a4634 1
				private static readonly Type localRefStructType = typeof(IKVM.Runtime.JNI.Frame);
d4640 1
a4640 1
				private static readonly MethodInfo getClassFromTypeHandle = typeof(ByteCodeHelper).GetMethod("GetClassFromTypeHandle");
d5297 1
a5297 1
								ilgen.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("SkipFinalizer"));
d7102 2
a7103 1
#endif
d7116 1
a7116 1
			if(type.IsValueType && type.IsDefined(typeof(GhostInterfaceAttribute), false))
d7120 1
a7120 1
			else if(type.IsDefined(typeof(RemappedTypeAttribute), false))
d7137 2
a7138 2
				object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
				if(attribs.Length != 1)
d7142 1
a7142 1
				remappedType = ((RemappedTypeAttribute)attribs[0]).Type;
d7191 1
a7191 1
					foreach(RemappedInterfaceMethodAttribute m in type.GetCustomAttributes(typeof(RemappedInterfaceMethodAttribute), false))
d7291 1
a7291 1
			Debug.Assert(type.Module.IsDefined(typeof(JavaModuleAttribute), false));
d7294 2
a7295 2
			Object[] attribs = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
			if(attribs.Length == 1)
d7297 1
a7297 1
				string name = ((InnerClassAttribute)attribs[0]).InnerClassName;
d7310 1
a7310 1
			if(type.IsInterface || type.IsDefined(typeof(GhostInterfaceAttribute), false))
d7321 2
a7322 2
				object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
				if(attribs.Length == 1)
d7324 1
a7324 1
					if(((RemappedTypeAttribute)attribs[0]).Type == typeof(object))
d7346 1
a7346 1
			return ClassLoaderWrapper.IsCoreAssemblyType(type) ? ClassLoaderWrapper.GetBootstrapClassLoader() : ClassLoaderWrapper.GetSystemClassLoader();
d7360 2
a7361 2
			object[] customAttribute = type.GetCustomAttributes(typeof(ModifiersAttribute), false);
			if(customAttribute.Length == 1)
d7363 1
a7363 1
				return ((ModifiersAttribute)customAttribute[0]).Modifiers;
d7433 2
a7434 2
					object[] attribs = type.GetCustomAttributes(typeof(ImplementsAttribute), false);
					if(attribs.Length == 1)
d7436 1
a7436 1
						string[] interfaceNames = ((ImplementsAttribute)attribs[0]).Interfaces;
d7492 2
a7493 2
				object[] customAttribute = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
				if(customAttribute.Length == 1)
d7495 1
a7495 1
					return ((InnerClassAttribute)customAttribute[0]).Modifiers;
d7584 2
a7585 1
			if(method.IsDefined(typeof(NameSigAttribute), false))
a7586 1
				NameSigAttribute attr = (NameSigAttribute)method.GetCustomAttributes(typeof(NameSigAttribute), false)[0];
d7710 1
d7745 1
d7794 2
a7795 1
			if(field.IsDefined(typeof(NameSigAttribute), false))
a7796 1
				NameSigAttribute attr = (NameSigAttribute)field.GetCustomAttributes(typeof(NameSigAttribute), false)[0];
d7838 1
a7838 1
				return type.IsDefined(typeof(ExceptionIsUnsafeForMappingAttribute), false);
d7846 1
d7856 1
d7916 1
d7949 1
d8025 1
a8025 1
			Debug.Assert(!type.IsArray && !type.Module.IsDefined(typeof(JavaModuleAttribute), false));
d8027 1
a8027 1
			if(type.IsDefined(typeof(NoPackagePrefixAttribute), false) || type.Assembly.IsDefined(typeof(NoPackagePrefixAttribute), false))
d8155 1
a8155 1
				if(prefixed || type.IsDefined(typeof(NoPackagePrefixAttribute), false) || type.Assembly.IsDefined(typeof(NoPackagePrefixAttribute), false))
d8160 1
d8166 1
a8166 1
					if(prefixed || delegateType.IsDefined(typeof(NoPackagePrefixAttribute), false) || delegateType.Assembly.IsDefined(typeof(NoPackagePrefixAttribute), false))
d8185 1
d8191 25
d8222 1
a8222 1
						&& !t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d8230 1
a8230 1
						&& !t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d8279 1
a8279 1
			Debug.Assert(!(type.Module.IsDefined(typeof(JavaModuleAttribute), false)));
d8308 1
d8315 1
d8337 1
d8386 1
d8428 1
d8435 1
d8452 1
d8483 1
d8549 1
d8556 1
d8608 3
d8612 1
d8784 1
d8796 1
d8894 1
a8894 1
								interfaceTypes[i].IsDefined(typeof(HideFromJavaAttribute), false) &&
d9081 1
d9113 1
@


1.72
log
@Fixed bug 1310397
@
text
@d854 5
d1471 1
a1471 1
		internal TypeWrapper MakeArrayType(int rank)
d1964 27
d2511 2
d2529 1
d2836 7
d3727 1
d3735 44
d3790 8
d3806 37
a3842 2
					string[] genericMetaData = null;
					for(int i = 0; i < classFile.Methods.Length; i++)
d3844 2
a3845 1
						if(classFile.Methods[i].GenericSignature != null)
d3847 1
a3847 1
							if(genericMetaData == null)
d3849 9
a3857 1
								genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
a3858 1
							genericMetaData[i + 4] = classFile.Methods[i].GenericSignature;
d3861 20
a3880 1
					for(int i = 0; i < classFile.Fields.Length; i++)
d3882 1
a3882 1
						if(classFile.Fields[i].GenericSignature != null)
d3884 5
a3888 1
							if(genericMetaData == null)
d3890 1
a3890 1
								genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
a3891 1
							genericMetaData[i + 4 + classFile.Methods.Length] = classFile.Fields[i].GenericSignature;
d3894 6
a3899 1
					if(classFile.EnclosingMethod != null)
d3901 5
a3905 1
						if(genericMetaData == null)
d3907 1
a3907 1
							genericMetaData = new string[4];
d3909 1
a3909 3
						genericMetaData[0] = classFile.EnclosingMethod[0];
						genericMetaData[1] = classFile.EnclosingMethod[1];
						genericMetaData[2] = classFile.EnclosingMethod[2];
d3911 1
a3911 1
					if(classFile.GenericSignature != null)
d3913 5
a3917 1
						if(genericMetaData == null)
d3919 1
a3919 1
							genericMetaData = new string[4];
d3921 1
a3921 1
						genericMetaData[3] = classFile.GenericSignature;
d3923 14
a3936 2
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, this.ReflectiveModifiers, genericMetaData);
					return finishedType;
d3938 2
a3939 1
				catch(Exception x)
d3941 91
a4031 2
					JVM.CriticalFailure("Exception during finishing of: " + wrapper.Name, x);
					return null;
d4033 2
a4034 1
				finally
d4036 1
a4036 1
					Profiler.Leave("JavaTypeImpl.Finish.Core");
d4775 5
d4926 218
d5153 1
a5153 1
			private string[] genericMetaData;	/* [0..2] = enclosing method, [3] = class signature, [4..n] = method signatures */
d5155 1
a5155 1
			internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers, string[] genericMetaData)
d5162 1
a5162 1
				this.genericMetaData = genericMetaData;
d5228 1
a5228 5
				if(genericMetaData != null)
				{
					return genericMetaData[3];
				}
				return null;
d5233 1
a5233 5
				if(genericMetaData != null && genericMetaData[0] != null)
				{
					return new string[] { genericMetaData[0], genericMetaData[1], genericMetaData[2] };
				}
				return null;
d5238 1
a5238 5
				if(genericMetaData != null)
				{
					return genericMetaData[index + 4];
				}
				return null;
d5244 11
a5254 5
				if(genericMetaData != null)
				{
					return genericMetaData[index + 4];
				}
				return null;
d5536 25
d5572 1
d6547 13
d6795 7
d7364 38
d7714 7
d8554 5
@


1.71
log
@*** empty log message ***
@
text
@d3394 1
a3394 1
								if(mi != null && mi.IsAbstract && wrapper.GetMethodWrapper(mw.Name, mw.Signature, true).IsAbstract)
d4218 1
a4218 1
								if(baseMethods[index].IsAbstract)
d4242 4
@


1.70
log
@*** empty log message ***
@
text
@d123 3
d649 5
d800 52
d1951 8
d2074 20
d2179 20
d2475 4
d2746 1
a2746 1
					if(JVM.IsStaticCompiler && classFile.DeprecatedAttribute)
d2748 12
a2759 1
						AttributeHelper.SetDeprecatedAttribute(typeBuilder);
d3273 1
a3273 3
				// if the Java modifiers cannot be expressed in .NET, we emit the Modifiers attribute to store
				// the Java modifiers
				if(setModifiers)
d3275 18
a3292 9
					AttributeHelper.SetModifiers(field, fld.Modifiers);
				}
				if(setNameSig)
				{
					AttributeHelper.SetNameSig(field, fld.Name, fld.Signature);
				}
				if(JVM.IsStaticCompiler && fld.DeprecatedAttribute)
				{
					AttributeHelper.SetDeprecatedAttribute(field);
d3685 9
d3711 42
a3752 1
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, this.ReflectiveModifiers);
a4498 4
						if((JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage) && setModifiers)
						{
							AttributeHelper.SetModifiers(mb, m.Modifiers);
						}
d4506 11
d4525 4
d4619 24
d4652 1
d4654 1
a4654 1
			internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers)
d4661 1
d4724 37
d5003 38
d5290 4
d5325 4
d6692 10
d6770 53
d7948 20
d8096 20
@


1.69
log
@*** empty log message ***
@
text
@d4156 4
@


1.68
log
@*** empty log message ***
@
text
@d1566 1
a1566 1
						MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d1583 1
a1583 1
					MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d1591 1
a1591 1
					MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d1609 1
a1609 1
					MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d1629 1
a1629 1
					MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d3049 1
a3049 1
				MethodAttributes methodAttribs = 0;
d3463 1
a3463 1
								MethodBuilder mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, interfaces[i].TypeAsSignatureType, new Type[] { wrapper.TypeAsSignatureType });
d4012 1
a4012 1
							MethodBuilder mb = typeBuilder.DefineMethod(methods[index].Name, MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
d4030 1
d4077 1
a4077 1
					MethodAttributes attribs = 0;
d4282 1
a4282 1
								MethodAttributes attr = MethodAttributes.Virtual;
d5081 1
a5081 1
			MethodAttributes attribs = (MethodAttributes)0;
d5507 1
a5507 1
						mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, TypeAsSignatureType, new Type[] { implementers[i].TypeAsSignatureType });
d5614 1
a5614 1
					mb = typeBuilder.DefineMethod("ToObject", MethodAttributes.Public, typeof(object), Type.EmptyTypes);
d5662 1
a5662 1
				ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object) });
d5664 1
a5664 1
				ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object), typeof(int) });
d5667 1
a5667 1
				ghostCastMethod = typeBuilder.DefineMethod("Cast", MethodAttributes.Public | MethodAttributes.Static, typeBuilder, new Type[] { typeof(object) });
d5669 1
a5669 1
				ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray", MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(object), typeof(int) });
@


1.67
log
@*** empty log message ***
@
text
@d6477 1
a6477 1
		private const string DelegateInterfaceSuffix = "$Method";
d6670 17
a6686 13
					MethodInfo invoke = delegateType.GetMethod("Invoke");
					ParameterInfo[] parameters = invoke.GetParameters();
					Type[] args = new Type[parameters.Length];
					for(int i = 0; i < args.Length; i++)
					{
						// we know there aren't any unsupported parameter types, because IsDelegate() returned true
						args[i] = parameters[i].ParameterType;
					}
					ModuleBuilder moduleBuilder = ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder;
					TypeBuilder typeBuilder = moduleBuilder.DefineType(origname, TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract);
					AttributeHelper.SetInnerClass(typeBuilder, origname, Modifiers.Public | Modifiers.Interface | Modifiers.Static | Modifiers.Abstract);
					typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Abstract | MethodAttributes.Virtual, CallingConventions.Standard, invoke.ReturnType, args);
					return CompiledTypeWrapper.newInstance(origname, typeBuilder.CreateType());
a6695 1
				// HACK we also look inside Java assemblies, because precompiled delegate interfaces might have ended up there
d6699 2
a6700 1
					if(t != null)
d6707 2
a6708 1
					if(t != null)
@


1.66
log
@*** empty log message ***
@
text
@d1922 1
a1922 8
			TypeWrapper tw = null;
			try
			{
				tw = loader.LoadClassByDottedNameFast(this.Name);
			}
			catch
			{
			}
d2523 1
a2523 1
								catch(Exception x) // TODO should we be catching Exception here?
@


1.65
log
@*** empty log message ***
@
text
@a61 15
		internal static void RunClassConstructor(ILGenerator ilgen, Type type)
		{
			// NOTE we're *not* running the .cctor if the class is not a Java class
			// NOTE this is a potential versioning problem, if the base class lives in another assembly and doesn't
			// have a <clinit> now, a newer version that does have a <clinit> will not have it's <clinit> called by us.
			// A possible solution would be to use RuntimeHelpers.RunClassConstructor when "type" is a Java type and
			// lives in another assembly as the caller (which we don't know at the moment).
			FieldInfo field = type.GetField("__<clinit>", BindingFlags.Static | BindingFlags.NonPublic);
			if(field != null)
			{
				ilgen.Emit(OpCodes.Ldsfld, field);
				ilgen.Emit(OpCodes.Pop);
			}
		}

d1887 4
d2373 1
d2389 1
d2659 26
d3174 8
d3298 1
a3298 1
								EmitHelper.RunClassConstructor(ilGenerator, Type.BaseType);
d3451 1
a3451 1
									EmitHelper.RunClassConstructor(ilGenerator, Type.BaseType);
a3924 6
				if(!classFile.IsFinal && !classFile.IsInterface && wrapper.HasStaticInitializer)
				{
					// We create a field that the derived classes can access in their .cctor to trigger our .cctor
					// (previously we used RuntimeHelpers.RunClassConstructor, but that is slow and requires additional privileges)
					FieldBuilder field = typeBuilder.DefineField("__<clinit>", typeof(int), FieldAttributes.SpecialName | FieldAttributes.Family | FieldAttributes.Static);
				}
d4438 1
d4446 1
d4483 8
d4746 5
d5736 1
d6028 3
a6030 1
				return type.GetField("__<clinit>", BindingFlags.NonPublic | BindingFlags.Static) != null;
d6254 1
d6265 2
a6266 1
						if(method.IsSpecialName && method.Name == "op_Implicit")
d6452 10
@


1.64
log
@*** empty log message ***
@
text
@d136 2
a137 1
		private static ConstructorInfo lineNumberTableAttribute;
d776 1
a776 1
		internal static void SetLineNumberTable(MethodBase mb, byte[] table)
d778 3
a780 1
			if(lineNumberTableAttribute == null)
d782 15
a796 1
				lineNumberTableAttribute = typeof(LineNumberTableAttribute).GetConstructor(new Type[] { typeof(byte[]) });
d800 1
a800 1
				((ConstructorBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(lineNumberTableAttribute, new object[] { table }));
d804 1
a804 1
				((MethodBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(lineNumberTableAttribute, new object[] { table }));
@


1.63
log
@Fixed bug 1257044.
@
text
@d1406 1
d5284 77
@


1.62
log
@*** empty log message ***
@
text
@d505 1
a505 1
		internal static void MirandaMethod(MethodBuilder mb)
d507 1
a507 1
			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(MirandaMethodAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d511 1
a511 1
		internal static bool IsMirandaMethod(MethodInfo mi)
d513 23
a535 1
			return mi.IsAbstract && mi.IsDefined(typeof(MirandaMethodAttribute), false);
d2428 1
a2428 1
				if(wrapper.IsAbstract && !wrapper.IsInterface)
d2430 27
a2456 5
					ArrayList methodsArray = new ArrayList(methods);
					ArrayList baseMethodsArray = new ArrayList(baseMethods);
					AddMirandaMethods(methodsArray, baseMethodsArray, wrapper);
					this.methods = (MethodWrapper[])methodsArray.ToArray(typeof(MethodWrapper));
					this.baseMethods = (MethodWrapper[])baseMethodsArray.ToArray(typeof(MethodWrapper));
d2466 1
a2466 1
						fields[i] = new ConstantFieldWrapper(wrapper, null, fld.Name, fld.Signature, fld.Modifiers, null, fld.ConstantValue);
d2478 6
d2728 12
d2798 38
d3001 5
a3005 1
				Debug.Assert(fw != null);
d3482 1
a3482 1
					if(JVM.IsStaticCompiler && classFile.IsInterface && !wrapper.IsGhost && classFile.Fields.Length > 0)
d3977 55
a4031 11
						// We're a Miranda method
						Debug.Assert(baseMethods[index].DeclaringType.IsInterface);
						string name = GenerateUniqueMethodName(methods[index].Name, baseMethods[index]);
						// TODO if the interface is not public, we probably shouldn't make the Miranda method public
						MethodBuilder mb = typeBuilder.DefineMethod(methods[index].Name, MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
						AttributeHelper.MirandaMethod(mb);
						if(unloadableOverrideStub || name != methods[index].Name)
						{
							// instead of creating an override stub, we created the Miranda method with the proper signature and
							// decorate it with a NameSigAttribute that contains the real signature
							AttributeHelper.SetNameSig(mb, methods[index].Name, methods[index].Signature);
d4033 1
a4033 2
						// if we changed the name or if the interface method name is remapped, we need to add an explicit methodoverride.
						if(name != baseMethods[index].RealName)
d4035 1
a4035 1
							typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethods[index].GetMethod());
a4036 1
						return mb;
d6144 2
a6145 2
							bool miranda = mi != null ? AttributeHelper.IsMirandaMethod(mi) : false;
							MemberFlags flags = miranda ? MemberFlags.MirandaMethod | MemberFlags.HideFromReflection : MemberFlags.None;
d6163 13
d6286 6
a6291 1
				return new ConstantFieldWrapper(this, type, name, type.SigName, modifiers, field, null);
d6928 1
a6928 1
						fieldsList.Add(new ConstantFieldWrapper(this, fieldType, name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], val));
d7313 1
a7313 1
				return new ConstantFieldWrapper(this, type, name, type.SigName, modifiers, field, null);
@


1.61
log
@*** empty log message ***
@
text
@d3453 7
a3459 1
					mod = ((AssemblyBuilder)ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder.Assembly).DefineDynamicModule("jniproxy.dll", "jniproxy.dll");
d3464 1
a3464 1
					TypeBuilder tb = mod.DefineType("class" + (count++), TypeAttributes.Public | TypeAttributes.Class);
d3469 1
a3469 1
						argTypes[0] = wrapper.TypeAsSignatureType;
d3473 3
a3475 1
						argTypes[i + instance] = args[i].TypeAsSignatureType;
d3478 3
a3480 1
					MethodBuilder mb = tb.DefineMethod("method", MethodAttributes.Public | MethodAttributes.Static, mw.ReturnType.TypeAsSignatureType, argTypes);
d3482 1
d3489 4
a3493 6
					Type type = tb.CreateType();
					// HACK since we're creating a type in the dynamic assembly, we must also register its wrapper,
					// because the ClassLoaderWrapper assumes that all dynamic types are in its hashtable,
					// but note that this only registers it for reverse lookup (from Type -> TypeWrapper), this
					// is necessary to make stack walking work.
					ClassLoaderWrapper.SetWrapperForType(type, CompiledTypeWrapper.newInstance(type.FullName, type));
@


1.60
log
@*** empty log message ***
@
text
@d1731 4
@


1.59
log
@*** empty log message ***
@
text
@d1499 1
a1499 6
		internal void Finish()
		{
			Finish(false);
		}

		internal abstract void Finish(bool forDebugSave);
d1962 1
a1962 1
		internal override void Finish(bool forDebugSave)
d2057 1
a2057 1
		internal override void Finish(bool forDebugSave)
d2300 1
a2300 1
		internal override void Finish(bool forDebugSave)
d2307 1
a2307 1
					impl = impl.Finish(forDebugSave);
d2337 1
a2337 1
			internal abstract DynamicImpl Finish(bool forDebugSave);
a2349 1
			private bool finishingForDebugSave;
d2840 1
a2840 1
						if(baseMethod.ReturnType.IsUnloadable || finishingForDebugSave)
d2842 1
a2842 1
							if(!mw.ReturnType.IsUnloadable || (!baseMethod.ReturnType.IsUnloadable && finishingForDebugSave))
d2858 1
a2858 1
							if(there[i].IsUnloadable || finishingForDebugSave)
d2860 1
a2860 1
								if(!here[i].IsUnloadable || (!there[i].IsUnloadable && finishingForDebugSave))
d3031 1
a3031 1
			internal override DynamicImpl Finish(bool forDebugSave)
a3032 1
				this.finishingForDebugSave = forDebugSave;
d3035 1
a3035 1
					wrapper.BaseTypeWrapper.Finish(forDebugSave);
d3039 1
a3039 1
					outerClassWrapper.Finish(forDebugSave);
d3053 1
a3053 1
					wrapper.Interfaces[i].Finish(forDebugSave);
d3864 1
a3864 1
						MethodBuilder mb = typeBuilder.DefineMethod(methods[index].Name, MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride, baseMethods[index].ReturnTypeForDefineMethod, baseMethods[index].GetParametersForDefineMethod());
d4065 1
a4065 1
							if(unloadableOverrideStub)
d4067 3
a4069 1
								attribs |= MethodAttributes.NewSlot;
d4071 2
a4072 1
							if(setNameSig || memberclashtable != null)
d4074 1
a4074 1
								name = GenerateUniqueMethodName(name, methods[index]);
d4081 1
a4081 1
							else if(baseMce != null && (explicitOverride || baseMce.RealName != name) && !needFinalize)
d4285 1
a4285 1
			internal override DynamicImpl Finish(bool forDebugSave)
d6138 1
a6138 1
		internal override void Finish(bool forDebugSave)
d7249 1
a7249 1
		internal override void Finish(bool forDebugSave)
d7277 1
a7277 1
		protected override void LazyPublishMembers()
d7279 1
a7279 1
			if(clone == null)
d7281 5
a7285 1
				clone = typeof(Array).GetMethod("Clone", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
d7287 5
a7291 1
			MethodWrapper mw = new SimpleCallMethodWrapper(this, "clone", "()Ljava.lang.Object;", clone, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Public, MemberFlags.HideFromReflection, SimpleOpCode.Callvirt, SimpleOpCode.Callvirt);
d7374 1
a7374 1
		internal override void Finish(bool forDebugSave)
@


1.58
log
@*** empty log message ***
@
text
@d2105 1
a2105 1
			if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage || !IsSupportedVersion)
a2106 2
				// if we're going to be saving the image, we cannot bash the MethodBuilder fields,
				// because the data is required to generated the PE file.
d2357 1
a2357 1
			private readonly TypeWrapper outerClassWrapper;
d2460 2
a2461 1
						if(f.OuterClass != null)
d2463 1
a2463 1
							if(!CheckInnerOuterNames(f.Name, f.OuterClass.Name))
d2469 5
a2473 2
								outerClassWrapper = wrapper.GetClassLoader().LoadClassByDottedName(f.OuterClass.Name);
								if(outerClassWrapper is DynamicTypeWrapper)
d2475 49
a2523 1
									outer = outerClassWrapper.TypeAsBuilder;
d2613 18
a3039 8
				// NOTE if a finish is triggered during static compilation phase 1, it cannot be handled properly,
				// so we bail out.
				// (this should only happen during compilation of classpath.dll and is most likely caused by a bug somewhere)
				if(JVM.IsStaticCompilerPhase1)
				{
					JVM.CriticalFailure("Finish triggered during phase 1 of compilation.", null);
					return null;
				}
a3426 1
						BakedTypeCleanupHack.Process(wrapper);
d3434 1
@


1.57
log
@*** empty log message ***
@
text
@d1524 29
@


1.56
log
@*** empty log message ***
@
text
@d2171 1
a2171 1
					throw new VerifyError("Cannot inherit from final class");
a2285 2
					// call Finish again to get the verify error for doomed types
					impl.Finish(forDebugSave);
a3049 1
					string verifyError = null;
d3067 1
a3067 1
							Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref verifyError);
d3184 1
a3184 1
								Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref verifyError, ref nonleaf);
d3345 3
a3347 10
					if(verifyError != null)
					{
						return new DoomedTypeImpl(verifyError);
					}
					else
					{
						wrapper.FinishGhostStep2();
						finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, this.ReflectiveModifiers);
						return finishedType;
					}
d3914 1
a3914 1
									(baseMethod.IsFamily && !m.IsPublic && !m.IsProtected) ||
a4150 61
		private class DoomedTypeImpl : DynamicImpl
		{
			private string message;

			internal DoomedTypeImpl(string message)
			{
				this.message = message;
			}

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
				{
					return null;
				}
			}

			internal override DynamicImpl Finish(bool forDebugSave)
			{
				if(!forDebugSave)
				{
					throw new VerifyError(message);
				}
				return this;
			}

			internal override TypeWrapper[] InnerClasses
			{
				get
				{
					return null;
				}
			}

			internal override FieldInfo LinkField(FieldWrapper fw)
			{
				return null;
			}

			internal override MethodBase LinkMethod(MethodWrapper mw)
			{
				return null;
			}

			internal override Modifiers ReflectiveModifiers
			{
				get
				{
					return (Modifiers)0;
				}
			}

			internal override Type Type
			{
				get
				{
					return null;
				}
			}
		}

@


1.55
log
@*** empty log message ***
@
text
@d2544 2
a2545 2
					ByteCode bc = m.Instructions[i].OpCode;
					if(bc == ByteCode.__getstatic || bc == ByteCode.__putstatic)
d2554 1
a2554 1
						if(bc == ByteCode.__getstatic && "L[".IndexOf(fld.Signature[0]) != -1)
d2559 5
a2563 5
					else if(bc == ByteCode.__areturn ||
						bc == ByteCode.__ireturn ||
						bc == ByteCode.__lreturn ||
						bc == ByteCode.__freturn ||
						bc == ByteCode.__dreturn)
@


1.54
log
@*** empty log message ***
@
text
@d791 1
a791 1
			this.name = name;
@


1.53
log
@*** empty log message ***
@
text
@d2720 1
a2720 2
							classObjectField = typeBuilder.DefineField("__<classObject>", typeof(object), FieldAttributes.Private | FieldAttributes.Static);
							AttributeHelper.HideFromJava((FieldBuilder)classObjectField);
d3238 1
a3238 1
							if(interfaces[i].IsGhost)
a3240 1
								AttributeHelper.HideFromJava(mb);
d3431 1
a3431 1
						classObjectField = typeBuilder.DefineField("__<classObject>", typeof(object), FieldAttributes.Static | FieldAttributes.Private);
a3697 1
					AttributeHelper.HideFromJava(field);
a5211 1
						AttributeHelper.HideFromJava(mb);
a5363 1
				AttributeHelper.HideFromJava((FieldBuilder)ghostRefField);
d5959 16
a5974 9
						string name;
						string sig;
						TypeWrapper retType;
						TypeWrapper[] paramTypes;
						GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes);
						MethodInfo mi = method as MethodInfo;
						bool miranda = mi != null ? AttributeHelper.IsMirandaMethod(mi) : false;
						MemberFlags flags = miranda ? MemberFlags.MirandaMethod | MemberFlags.HideFromReflection : MemberFlags.None;
						methods.Add(MethodWrapper.Create(this, name, sig, method, retType, paramTypes, AttributeHelper.GetModifiers(method, false), flags));
d5981 8
a5988 1
							fields.Add(CreateFieldWrapper(field));
@


1.52
log
@*** empty log message ***
@
text
@d2401 2
a2402 1
					else if(fld.IsFinal && (fld.IsPublic || fld.IsProtected) && !wrapper.IsInterface)
d2864 2
a2865 2
					bool isWrappedFinal = false;
					if(fld.IsFinal && (fld.IsPublic || fld.IsProtected))
d2867 1
a2867 5
						if(wrapper.IsInterface)
						{
							attribs |= FieldAttributes.InitOnly;
						}
						else
a2875 1
							isWrappedFinal = true;
d2877 8
a2884 4
					}
					else if(fld.IsFinal)
					{
						setModifiers = true;
@


1.51
log
@*** empty log message ***
@
text
@d735 1
a735 1
		internal static void SetInnerClass(TypeBuilder typeBuilder, string innerClass, string outerClass, string name, Modifiers modifiers)
d737 2
a738 2
			Type[] argTypes = new Type[] { typeof(string), typeof(string), typeof(string), typeof(Modifiers) };
			object[] args = new object[] { innerClass, outerClass, name, modifiers };
d2510 1
a2510 1
					if(f.SourceFileAttribute != null && !JVM.NoStackTraceInfo)
d2512 11
a2522 1
						AttributeHelper.SetSourceFile(typeBuilder, f.SourceFileAttribute);
d3016 6
a3021 5
									AttributeHelper.SetInnerClass(typeBuilder,
										classFile.GetConstantPoolClass(innerclasses[i].innerClass),
										classFile.GetConstantPoolClass(innerclasses[i].outerClass),
										innerclasses[i].name == 0 ? null : classFile.GetConstantPoolUtf8String(innerclasses[i].name),
										innerclasses[i].accessFlags);
d5625 6
a5630 1
				return ((InnerClassAttribute)attribs[0]).InnerClassName;
d6343 1
a6343 1
					AttributeHelper.SetInnerClass(typeBuilder, origname, MangleTypeName(delegateType.FullName), "Method", Modifiers.Public | Modifiers.Interface | Modifiers.Static | Modifiers.Abstract);
@


1.50
log
@*** empty log message ***
@
text
@d3721 1
a3721 1
						throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + tw.Name + " is overriden in " + wrapper.Name);
@


1.49
log
@*** empty log message ***
@
text
@d6192 1
d6196 1
a6196 1
				if(c == '[')
a6197 1
					// TODO we shouldn't go to quote mode if the '[' was escaped (i.e. preceded by a backslash)
d6200 1
a6200 1
				if(c == ']')
d6204 1
a6204 1
				if(c == '+')
d6208 1
a6208 1
				else if("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".IndexOf(c) != -1
d6215 1
a6215 1
					sb.Append('_');
d6218 8
d6248 1
a6248 5
					sb.Append('+');
				}
				else if(c == '_')
				{
					if(i + 5 > end)
d6250 1
a6250 1
						return name;
d6252 1
a6252 5
					int digit0 = "0123456789ABCDEF".IndexOf(name[++i]);
					int digit1 = "0123456789ABCDEF".IndexOf(name[++i]);
					int digit2 = "0123456789ABCDEF".IndexOf(name[++i]);
					int digit3 = "0123456789ABCDEF".IndexOf(name[++i]);
					if(digit0 == -1 || digit1 == -1 || digit2 == -1 || digit3 == -1)
d6254 14
a6267 1
						return name;
a6268 1
					sb.Append((char)((digit0 << 12) + (digit1 << 8) + (digit2 << 4) + digit3));
@


1.48
log
@*** empty log message ***
@
text
@d6275 1
d6314 2
a6315 2
					TypeBuilder typeBuilder = moduleBuilder.DefineType(NamePrefix + name, TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract);
					AttributeHelper.SetInnerClass(typeBuilder, NamePrefix + name, NamePrefix + delegateType.FullName, "Method", Modifiers.Public | Modifiers.Interface | Modifiers.Static | Modifiers.Abstract);
d6317 1
a6317 1
					return CompiledTypeWrapper.newInstance(NamePrefix + name, typeBuilder.CreateType());
@


1.47
log
@*** empty log message ***
@
text
@d6190 30
a6219 2
			// TODO a fully reversible name mangling should be used (all characters not supported by Java should be escaped)
			return NamePrefix + name.Replace('+', '$');
d6222 2
d6227 37
a6263 3
			// TODO a fully reversible name mangling should be used (all characters not supported by Java should be escaped)
			name = name.Substring(NamePrefix.Length);
			if(name.EndsWith(DelegateInterfaceSuffix))
d6265 1
a6265 2
				// HACK if we're a delegate nested type, don't replace the $ sign
				return name;
d6267 1
a6267 1
			return name.Replace('$', '+');
@


1.46
log
@*** empty log message ***
@
text
@d3478 1
@


1.45
log
@*** empty log message ***
@
text
@a32 1
using IKVM.Internal;
d34 1
a34 1
using ILGenerator = CountingILGenerator;
d36 1
a36 1
class EmitHelper
d38 13
a50 2
	private static MethodInfo objectToString = typeof(object).GetMethod("ToString", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
	private static MethodInfo verboseCastFailure = JVM.SafeGetEnvironmentVariable("IKVM_VERBOSE_CAST") == null ? null : typeof(ByteCodeHelper).GetMethod("VerboseCastFailure");
d52 9
a60 8
	internal static void Throw(ILGenerator ilgen, string dottedClassName)
	{
		TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dottedClassName);
		MethodWrapper mw = exception.GetMethodWrapper("<init>", "()V", false);
		mw.Link();
		mw.EmitNewobj(ilgen);
		ilgen.Emit(OpCodes.Throw);
	}
d62 14
a75 9
	internal static void Throw(ILGenerator ilgen, string dottedClassName, string message)
	{
		TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dottedClassName);
		ilgen.Emit(OpCodes.Ldstr, message);
		MethodWrapper mw = exception.GetMethodWrapper("<init>", "(Ljava.lang.String;)V", false);
		mw.Link();
		mw.EmitNewobj(ilgen);
		ilgen.Emit(OpCodes.Throw);
	}
d77 1
a77 9
	internal static void RunClassConstructor(ILGenerator ilgen, Type type)
	{
		// NOTE we're *not* running the .cctor if the class is not a Java class
		// NOTE this is a potential versioning problem, if the base class lives in another assembly and doesn't
		// have a <clinit> now, a newer version that does have a <clinit> will not have it's <clinit> called by us.
		// A possible solution would be to use RuntimeHelpers.RunClassConstructor when "type" is a Java type and
		// lives in another assembly as the caller (which we don't know at the moment).
		FieldInfo field = type.GetField("__<clinit>", BindingFlags.Static | BindingFlags.NonPublic);
		if(field != null)
d79 3
a81 1
			ilgen.Emit(OpCodes.Ldsfld, field);
a83 1
	}
d85 23
a107 7
	internal static void NullCheck(ILGenerator ilgen)
	{
		// I think this is the most efficient way to generate a NullReferenceException if the
		// reference is null
		ilgen.Emit(OpCodes.Ldvirtftn, objectToString);
		ilgen.Emit(OpCodes.Pop);
	}
d109 3
a111 3
	internal static void Castclass(ILGenerator ilgen, Type type)
	{
		if(verboseCastFailure != null)
d122 1
a122 3
			ilgen.Emit(OpCodes.Ldtoken, type);
			ilgen.Emit(OpCodes.Ldloc, lb);
			ilgen.Emit(OpCodes.Call, verboseCastFailure);
a124 4
		else
		{
			ilgen.Emit(OpCodes.Castclass, type);
		}
d127 1
a127 3
	// This is basically the same as Castclass, except that it
	// throws an IncompatibleClassChangeError on failure.
	internal static void EmitAssertType(ILGenerator ilgen, Type type)
d129 8
a136 24
		LocalBuilder lb = ilgen.DeclareLocal(typeof(object));
		ilgen.Emit(OpCodes.Stloc, lb);
		ilgen.Emit(OpCodes.Ldloc, lb);
		ilgen.Emit(OpCodes.Isinst, type);
		ilgen.Emit(OpCodes.Dup);
		Label ok = ilgen.DefineLabel();
		ilgen.Emit(OpCodes.Brtrue_S, ok);
		ilgen.Emit(OpCodes.Ldloc, lb);
		ilgen.Emit(OpCodes.Brfalse_S, ok);	// handle null
		EmitHelper.Throw(ilgen, "java.lang.IncompatibleClassChangeError");
		ilgen.MarkLabel(ok);
	}
}

class AttributeHelper
{
	private static CustomAttributeBuilder ghostInterfaceAttribute;
	private static CustomAttributeBuilder hideFromJavaAttribute;
	private static CustomAttributeBuilder deprecatedAttribute;
	private static CustomAttributeBuilder editorBrowsableNever;
	private static ConstructorInfo implementsAttribute;
	private static ConstructorInfo throwsAttribute;
	private static ConstructorInfo sourceFileAttribute;
	private static ConstructorInfo lineNumberTableAttribute;
d138 1
a138 3
	private static object ParseValue(TypeWrapper tw, string val)
	{
		if(tw == CoreClasses.java.lang.String.Wrapper)
d140 48
a187 1
			return val;
d189 2
a190 1
		else if(tw.TypeAsTBD.IsEnum)
d192 17
a208 1
			return Enum.Parse(tw.TypeAsTBD, val);
d210 2
a211 1
		else if(tw.TypeAsTBD == typeof(Type))
d213 32
a244 1
			return Type.GetType(val, true);
d246 2
a247 1
		else if(tw == PrimitiveTypeWrapper.BOOLEAN)
d249 10
a258 1
			return bool.Parse(val);
d260 2
a261 1
		else if(tw == PrimitiveTypeWrapper.BYTE)
d263 1
a263 1
			return (byte)sbyte.Parse(val);
d265 2
a266 1
		else if(tw == PrimitiveTypeWrapper.CHAR)
d268 1
a268 1
			return char.Parse(val);
d270 2
a271 13
		else if(tw == PrimitiveTypeWrapper.SHORT)
		{
			return short.Parse(val);
		}
		else if(tw == PrimitiveTypeWrapper.INT)
		{
			return int.Parse(val);
		}
		else if(tw == PrimitiveTypeWrapper.FLOAT)
		{
			return float.Parse(val);
		}
		else if(tw == PrimitiveTypeWrapper.LONG)
d273 3
a275 18
			return long.Parse(val);
		}
		else if(tw == PrimitiveTypeWrapper.DOUBLE)
		{
			return double.Parse(val);
		}
		else
		{
			throw new NotImplementedException();
		}
	}
#if! NO_STATIC_COMPILER
	private static void SetPropertiesAndFields(Attribute attrib, IKVM.Internal.MapXml.Attribute attr)
	{
		Type t = attrib.GetType();
		if(attr.Properties != null)
		{
			foreach(IKVM.Internal.MapXml.Param prop in attr.Properties)
d277 1
a277 2
				PropertyInfo pi = t.GetProperty(prop.Name);
				pi.SetValue(attrib, ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), prop.Sig), prop.Value), null);
d279 1
a279 4
		}
		if(attr.Fields != null)
		{
			foreach(IKVM.Internal.MapXml.Param field in attr.Fields)
d281 1
a281 2
				FieldInfo fi = t.GetField(field.Name);
				fi.SetValue(attrib, ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), field.Sig), field.Value));
a283 13
	}

	internal static Attribute InstantiatePseudoCustomAttribute(IKVM.Internal.MapXml.Attribute attr)
	{
		Type t = Type.GetType(attr.Type, true);
		Type[] argTypes;
		object[] args;
		GetAttributeArgsAndTypes(attr, out argTypes, out args);
		ConstructorInfo ci = t.GetConstructor(argTypes);
		Attribute attrib = ci.Invoke(args) as Attribute;
		SetPropertiesAndFields(attrib, attr);
		return attrib;
	}
d285 1
a285 5
	private static bool IsCodeAccessSecurityAttribute(IKVM.Internal.MapXml.Attribute attr, out SecurityAction action, out PermissionSet pset)
	{
		action = SecurityAction.Deny;
		pset = null;
		if(attr.Type != null)
d287 7
a293 2
			Type t = Type.GetType(attr.Type, true);
			if(typeof(CodeAccessSecurityAttribute).IsAssignableFrom(t))
d295 1
a295 10
				Type[] argTypes;
				object[] args;
				GetAttributeArgsAndTypes(attr, out argTypes, out args);
				ConstructorInfo ci = t.GetConstructor(argTypes);
				CodeAccessSecurityAttribute attrib = ci.Invoke(args) as CodeAccessSecurityAttribute;
				SetPropertiesAndFields(attrib, attr);
				action = attrib.Action;
				pset = new PermissionSet(PermissionState.None);
				pset.AddPermission(attrib.CreatePermission());
				return true;
a297 2
		return false;
	}
d299 1
a299 9
	internal static void SetCustomAttribute(TypeBuilder tb, IKVM.Internal.MapXml.Attribute attr)
	{
		SecurityAction action;
		PermissionSet pset;
		if(IsCodeAccessSecurityAttribute(attr, out action, out pset))
		{
			tb.AddDeclarativeSecurity(action, pset);
		}
		else
d301 1
a301 1
			tb.SetCustomAttribute(CreateCustomAttribute(attr));
a302 11
	}

	internal static void SetCustomAttribute(FieldBuilder fb, IKVM.Internal.MapXml.Attribute attr)
	{
		fb.SetCustomAttribute(CreateCustomAttribute(attr));
	}

	internal static void SetCustomAttribute(ParameterBuilder pb, IKVM.Internal.MapXml.Attribute attr)
	{
		pb.SetCustomAttribute(CreateCustomAttribute(attr));
	}
d304 1
a304 9
	internal static void SetCustomAttribute(MethodBuilder mb, IKVM.Internal.MapXml.Attribute attr)
	{
		SecurityAction action;
		PermissionSet pset;
		if(IsCodeAccessSecurityAttribute(attr, out action, out pset))
		{
			mb.AddDeclarativeSecurity(action, pset);
		}
		else
d306 1
a306 1
			mb.SetCustomAttribute(CreateCustomAttribute(attr));
a307 1
	}
d309 1
a309 5
	internal static void SetCustomAttribute(ConstructorBuilder cb, IKVM.Internal.MapXml.Attribute attr)
	{
		SecurityAction action;
		PermissionSet pset;
		if(IsCodeAccessSecurityAttribute(attr, out action, out pset))
d311 26
a336 5
			cb.AddDeclarativeSecurity(action, pset);
		}
		else
		{
			cb.SetCustomAttribute(CreateCustomAttribute(attr));
a337 6
	}

	internal static void SetCustomAttribute(PropertyBuilder pb, IKVM.Internal.MapXml.Attribute attr)
	{
		pb.SetCustomAttribute(CreateCustomAttribute(attr));
	}
d339 1
a339 12
	internal static void SetCustomAttribute(AssemblyBuilder ab, IKVM.Internal.MapXml.Attribute attr)
	{
		ab.SetCustomAttribute(CreateCustomAttribute(attr));
	}

	private static void GetAttributeArgsAndTypes(IKVM.Internal.MapXml.Attribute attr, out Type[] argTypes, out object[] args)
	{
		// TODO add error handling
		TypeWrapper[] twargs = ClassFile.ArgTypeWrapperListFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Sig);
		argTypes = new Type[twargs.Length];
		args = new object[argTypes.Length];
		for(int i = 0; i < twargs.Length; i++)
d341 5
a345 3
			argTypes[i] = twargs[i].TypeAsSignatureType;
			TypeWrapper tw = twargs[i];
			if(tw == CoreClasses.java.lang.Object.Wrapper)
d347 41
a387 1
				tw = ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Params[i].Sig);
d389 1
a389 1
			if(tw.IsArray)
d391 23
a413 2
				Array arr = Array.CreateInstance(tw.ElementTypeWrapper.TypeAsArrayType, attr.Params[i].Elements.Length);
				for(int j = 0; j < arr.Length; j++)
d415 2
a416 1
					arr.SetValue(ParseValue(tw.ElementTypeWrapper, attr.Params[i].Elements[j].Value), j);
d418 1
a418 1
				args[i] = arr;
d420 5
a424 1
			else
d426 1
a426 1
				args[i] = ParseValue(tw, attr.Params[i].Value);
d428 1
a429 1
	}
d431 1
a431 7
	private static CustomAttributeBuilder CreateCustomAttribute(IKVM.Internal.MapXml.Attribute attr)
	{
		// TODO add error handling
		Type[] argTypes;
		object[] args;
		GetAttributeArgsAndTypes(attr, out argTypes, out args);
		if(attr.Type != null)
d433 1
a433 2
			Type t = Type.GetType(attr.Type, true);
			if(typeof(CodeAccessSecurityAttribute).IsAssignableFrom(t))
d435 1
a435 1
				throw new NotImplementedException("CodeAccessSecurityAttribute support not implemented");
d437 6
a442 4
			ConstructorInfo ci = t.GetConstructor(argTypes);
			PropertyInfo[] namedProperties;
			object[] propertyValues;
			if(attr.Properties != null)
d444 1
a444 7
				namedProperties = new PropertyInfo[attr.Properties.Length];
				propertyValues = new object[attr.Properties.Length];
				for(int i = 0; i < namedProperties.Length; i++)
				{
					namedProperties[i] = t.GetProperty(attr.Properties[i].Name);
					propertyValues[i] = ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Properties[i].Sig), attr.Properties[i].Value);
				}
d446 2
a447 1
			else
d449 1
a449 2
				namedProperties = new PropertyInfo[0];
				propertyValues = new object[0];
d451 1
a451 3
			FieldInfo[] namedFields;
			object[] fieldValues;
			if(attr.Fields != null)
d453 1
a453 7
				namedFields = new FieldInfo[attr.Fields.Length];
				fieldValues = new object[attr.Fields.Length];
				for(int i = 0; i < namedFields.Length; i++)
				{
					namedFields[i] = t.GetField(attr.Fields[i].Name);
					fieldValues[i] = ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Fields[i].Sig), attr.Fields[i].Value);
				}
d455 5
a459 1
			else
d461 1
a461 2
				namedFields = new FieldInfo[0];
				fieldValues = new object[0];
d463 1
a463 1
			return new CustomAttributeBuilder(ci, args, namedProperties, propertyValues, namedFields, fieldValues);
d465 2
a466 1
		else
d468 1
a468 1
			if(attr.Properties != null)
d470 1
a470 1
				throw new NotImplementedException("Setting property values on Java attributes is not implemented");
d472 6
a477 7
			TypeWrapper t = ClassLoaderWrapper.LoadClassCritical(attr.Class);
			MethodWrapper mw = t.GetMethodWrapper("<init>", attr.Sig, false);
			mw.Link();
			ConstructorInfo ci = (ConstructorInfo)mw.GetMethod();
			FieldInfo[] namedFields;
			object[] fieldValues;
			if(attr.Fields != null)
d479 13
a491 8
				namedFields = new FieldInfo[attr.Fields.Length];
				fieldValues = new object[attr.Fields.Length];
				for(int i = 0; i < namedFields.Length; i++)
				{
					FieldWrapper fw = t.GetFieldWrapper(attr.Fields[i].Name, attr.Fields[i].Sig);
					fw.Link();
					namedFields[i] = fw.GetField();
					fieldValues[i] = ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), attr.Fields[i].Sig), attr.Fields[i].Value);
d494 5
a498 1
			else
d500 1
a500 2
				namedFields = new FieldInfo[0];
				fieldValues = new object[0];
d502 1
a502 1
			return new CustomAttributeBuilder(ci, args, namedFields, fieldValues);
d504 2
a505 5
	}
#endif
	internal static void SetEditorBrowsableNever(MethodBuilder mb)
	{
		if(editorBrowsableNever == null)
d507 2
a508 1
			editorBrowsableNever = new CustomAttributeBuilder(typeof(System.ComponentModel.EditorBrowsableAttribute).GetConstructor(new Type[] { typeof(System.ComponentModel.EditorBrowsableState) }), new object[] { System.ComponentModel.EditorBrowsableState.Never });
a509 2
		mb.SetCustomAttribute(editorBrowsableNever);
	}
d511 1
a511 3
	internal static void SetEditorBrowsableNever(PropertyBuilder pb)
	{
		if(editorBrowsableNever == null)
d513 1
a513 1
			editorBrowsableNever = new CustomAttributeBuilder(typeof(System.ComponentModel.EditorBrowsableAttribute).GetConstructor(new Type[] { typeof(System.ComponentModel.EditorBrowsableState) }), new object[] { System.ComponentModel.EditorBrowsableState.Never });
a514 2
		pb.SetCustomAttribute(editorBrowsableNever);
	}
d516 1
a516 3
	internal static void SetDeprecatedAttribute(MethodBase mb)
	{
		if(deprecatedAttribute == null)
d518 5
a522 1
			deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d524 2
a525 2
		MethodBuilder method = mb as MethodBuilder;
		if(method != null)
d527 5
a531 5
			method.SetCustomAttribute(deprecatedAttribute);
		}
		else
		{
			((ConstructorBuilder)mb).SetCustomAttribute(deprecatedAttribute);
a532 1
	}
d534 1
a534 3
	internal static void SetDeprecatedAttribute(TypeBuilder tb)
	{
		if(deprecatedAttribute == null)
d536 5
a540 1
			deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
a541 2
		tb.SetCustomAttribute(deprecatedAttribute);
	}
d543 1
a543 3
	internal static void SetDeprecatedAttribute(FieldBuilder fb)
	{
		if(deprecatedAttribute == null)
d545 5
a549 1
			deprecatedAttribute = new CustomAttributeBuilder(typeof(ObsoleteAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
a550 2
		fb.SetCustomAttribute(deprecatedAttribute);
	}
d552 1
a552 3
	internal static void SetThrowsAttribute(MethodBase mb, string[] exceptions)
	{
		if(exceptions != null && exceptions.Length != 0)
d554 4
a557 1
			if(throwsAttribute == null)
d559 1
a559 1
				throwsAttribute = typeof(ThrowsAttribute).GetConstructor(new Type[] { typeof(string[]) });
d561 2
a562 1
			if(mb is MethodBuilder)
d564 1
a564 2
				MethodBuilder method = (MethodBuilder)mb;
				method.SetCustomAttribute(new CustomAttributeBuilder(throwsAttribute, new object[] { exceptions }));
d566 6
a571 1
			else
d573 10
a582 2
				ConstructorBuilder constructor = (ConstructorBuilder)mb;
				constructor.SetCustomAttribute(new CustomAttributeBuilder(throwsAttribute, new object[] { exceptions }));
a584 1
	}
d586 1
a586 3
	internal static void SetGhostInterface(TypeBuilder typeBuilder)
	{
		if(ghostInterfaceAttribute == null)
d588 51
a638 1
			ghostInterfaceAttribute = new CustomAttributeBuilder(typeof(GhostInterfaceAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
a639 13
		typeBuilder.SetCustomAttribute(ghostInterfaceAttribute);
	}

	internal static void MirandaMethod(MethodBuilder mb)
	{
		CustomAttributeBuilder cab = new CustomAttributeBuilder(typeof(MirandaMethodAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
		mb.SetCustomAttribute(cab);
	}

	internal static bool IsMirandaMethod(MethodInfo mi)
	{
		return mi.IsAbstract && mi.IsDefined(typeof(MirandaMethodAttribute), false);
	}
d641 1
a641 3
	internal static void HideFromJava(TypeBuilder typeBuilder)
	{
		if(hideFromJavaAttribute == null)
d643 36
a678 1
			hideFromJavaAttribute = new CustomAttributeBuilder(typeof(HideFromJavaAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
a679 2
		typeBuilder.SetCustomAttribute(hideFromJavaAttribute);
	}
d681 1
a681 3
	internal static void HideFromJava(ConstructorBuilder cb)
	{
		if(hideFromJavaAttribute == null)
d683 2
a684 1
			hideFromJavaAttribute = new CustomAttributeBuilder(typeof(HideFromJavaAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
a685 2
		cb.SetCustomAttribute(hideFromJavaAttribute);
	}
d687 1
a687 3
	internal static void HideFromJava(MethodBuilder mb)
	{
		if(hideFromJavaAttribute == null)
d689 2
a690 1
			hideFromJavaAttribute = new CustomAttributeBuilder(typeof(HideFromJavaAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
a691 2
		mb.SetCustomAttribute(hideFromJavaAttribute);
	}
d693 1
a693 3
	internal static void HideFromJava(FieldBuilder fb)
	{
		if(hideFromJavaAttribute == null)
d695 2
a696 1
			hideFromJavaAttribute = new CustomAttributeBuilder(typeof(HideFromJavaAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
a697 2
		fb.SetCustomAttribute(hideFromJavaAttribute);
	}
d699 1
a699 11
	internal static bool IsHideFromJava(MemberInfo mi)
	{
		// NOTE all privatescope fields and methods are "hideFromJava"
		// because Java cannot deal with the potential name clashes
		FieldInfo fi = mi as FieldInfo;
		if(fi != null && (fi.Attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.PrivateScope)
		{
			return true;
		}
		MethodBase mb = mi as MethodBase;
		if(mb != null && (mb.Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.PrivateScope)
d701 2
a702 1
			return true;
a703 2
		return mi.IsDefined(typeof(HideFromJavaAttribute), false);
	}
d705 1
a705 3
	internal static void SetImplementsAttribute(TypeBuilder typeBuilder, TypeWrapper[] ifaceWrappers)
	{
		if(ifaceWrappers != null && ifaceWrappers.Length != 0)
d707 3
a709 2
			string[] interfaces = new string[ifaceWrappers.Length];
			for(int i = 0; i < interfaces.Length; i++)
d711 1
a711 1
				interfaces[i] = ifaceWrappers[i].Name;
d713 1
a713 1
			if(implementsAttribute == null)
d715 1
a715 1
				implementsAttribute = typeof(ImplementsAttribute).GetConstructor(new Type[] { typeof(string[]) });
a716 1
			typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(implementsAttribute, new object[] { interfaces }));
a717 1
	}
d719 1
a719 4
	internal static Modifiers GetModifiers(MethodBase mb, bool assemblyIsPrivate)
	{
		object[] customAttribute = mb.GetCustomAttributes(typeof(ModifiersAttribute), false);
		if(customAttribute.Length == 1)
d721 2
a722 1
			return ((ModifiersAttribute)customAttribute[0]).Modifiers;
d724 2
a725 2
		Modifiers modifiers = 0;
		if(mb.IsPublic)
d727 6
a732 1
			modifiers |= Modifiers.Public;
d734 2
a735 1
		else if(mb.IsPrivate)
d737 5
a741 1
			modifiers |= Modifiers.Private;
d743 2
a744 1
		else if(mb.IsFamily || mb.IsFamilyOrAssembly)
d746 5
a750 1
			modifiers |= Modifiers.Protected;
d752 2
a753 1
		else if(assemblyIsPrivate)
d755 9
a763 18
			modifiers |= Modifiers.Private;
		}
		// NOTE Java doesn't support non-virtual methods, but we set the Final modifier for
		// non-virtual methods to approximate the semantics
		if((mb.IsFinal || (!mb.IsVirtual && ((modifiers & Modifiers.Private) == 0))) && !mb.IsStatic && !mb.IsConstructor)
		{
			modifiers |= Modifiers.Final;
		}
		if(mb.IsAbstract)
		{
			modifiers |= Modifiers.Abstract;
		}
		else
		{
			// Some .NET interfaces (like System._AppDomain) have synchronized methods,
			// Java doesn't allow synchronized on an abstract methods, so we ignore it for
			// abstract methods.
			if((mb.GetMethodImplementationFlags() & MethodImplAttributes.Synchronized) != 0)
d765 1
a765 1
				modifiers |= Modifiers.Synchronized;
a767 9
		if(mb.IsStatic)
		{
			modifiers |= Modifiers.Static;
		}
		if((mb.Attributes & MethodAttributes.PinvokeImpl) != 0)
		{
			modifiers |= Modifiers.Native;
		}
		return modifiers;
d770 1
a770 1
	internal static Modifiers GetModifiers(FieldInfo fi, bool assemblyIsPrivate)
d772 30
a801 4
		object[] customAttribute = fi.GetCustomAttributes(typeof(ModifiersAttribute), false);
		if(customAttribute.Length == 1)
		{
			return ((ModifiersAttribute)customAttribute[0]).Modifiers;
d803 2
a804 2
		Modifiers modifiers = 0;
		if(fi.IsPublic)
d806 5
a810 1
			modifiers |= Modifiers.Public;
d812 2
a813 1
		else if(fi.IsPrivate)
d815 1
a815 1
			modifiers |= Modifiers.Private;
d817 5
a821 1
		else if(fi.IsFamily || fi.IsFamilyOrAssembly)
d823 1
a823 1
			modifiers |= Modifiers.Protected;
d825 2
a826 1
		else if(assemblyIsPrivate)
d828 8
a835 1
			modifiers |= Modifiers.Private;
d837 2
a838 1
		if(fi.IsInitOnly || fi.IsLiteral)
d840 4
a843 1
			modifiers |= Modifiers.Final;
d845 5
a849 1
		if(fi.IsNotSerialized)
d851 4
a854 1
			modifiers |= Modifiers.Transient;
d856 3
a858 1
		if(fi.IsStatic)
d860 4
a863 1
			modifiers |= Modifiers.Static;
a864 15
		// TODO reflection doesn't support volatile
		return modifiers;
	}

	internal static void SetModifiers(MethodBuilder mb, Modifiers modifiers)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
		mb.SetCustomAttribute(customAttributeBuilder);
	}

	internal static void SetModifiers(ConstructorBuilder cb, Modifiers modifiers)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
		cb.SetCustomAttribute(customAttributeBuilder);
	}
d866 1
a866 17
	internal static void SetModifiers(FieldBuilder fb, Modifiers modifiers)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
		fb.SetCustomAttribute(customAttributeBuilder);
	}

	internal static void SetModifiers(TypeBuilder tb, Modifiers modifiers)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(ModifiersAttribute).GetConstructor(new Type[] { typeof(Modifiers) }), new object[] { modifiers });
		tb.SetCustomAttribute(customAttributeBuilder);
	}

	internal static void SetNameSig(MethodBase mb, string name, string sig)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(NameSigAttribute).GetConstructor(new Type[] { typeof(string), typeof(string) }), new object[] { name, sig });
		MethodBuilder method = mb as MethodBuilder;
		if(method != null)
d868 4
a871 1
			method.SetCustomAttribute(customAttributeBuilder);
d873 2
a874 1
		else
d876 4
a879 1
			((ConstructorBuilder)mb).SetCustomAttribute(customAttributeBuilder);
a880 26
	}

	internal static void SetNameSig(FieldBuilder fb, string name, string sig)
	{
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeof(NameSigAttribute).GetConstructor(new Type[] { typeof(string), typeof(string) }), new object[] { name, sig });
		fb.SetCustomAttribute(customAttributeBuilder);
	}

	internal static byte[] FreezeDryType(Type type)
	{
		System.IO.MemoryStream mem = new System.IO.MemoryStream();
		System.IO.BinaryWriter bw = new System.IO.BinaryWriter(mem, System.Text.UTF8Encoding.UTF8);
		bw.Write((short)1);
		bw.Write(type.FullName);
		bw.Write((short)0);
		return mem.ToArray();
	}

	internal static void SetInnerClass(TypeBuilder typeBuilder, string innerClass, string outerClass, string name, Modifiers modifiers)
	{
		Type[] argTypes = new Type[] { typeof(string), typeof(string), typeof(string), typeof(Modifiers) };
		object[] args = new object[] { innerClass, outerClass, name, modifiers };
		ConstructorInfo ci = typeof(InnerClassAttribute).GetConstructor(argTypes);
		CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(ci, args);
		typeBuilder.SetCustomAttribute(customAttributeBuilder);
	}
d882 1
a882 3
	internal static void SetSourceFile(TypeBuilder typeBuilder, string filename)
	{
		if(sourceFileAttribute == null)
d884 4
a887 1
			sourceFileAttribute = typeof(SourceFileAttribute).GetConstructor(new Type[] { typeof(string) });
a888 2
		typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(sourceFileAttribute, new object[] { filename }));
	}
d890 2
a891 3
	internal static void SetLineNumberTable(MethodBase mb, byte[] table)
	{
		if(lineNumberTableAttribute == null)
d893 12
a904 1
			lineNumberTableAttribute = typeof(LineNumberTableAttribute).GetConstructor(new Type[] { typeof(byte[]) });
d906 2
a907 1
		if(mb is ConstructorBuilder)
d909 4
a912 1
			((ConstructorBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(lineNumberTableAttribute, new object[] { table }));
d914 2
a915 1
		else
d917 4
a920 1
			((MethodBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(lineNumberTableAttribute, new object[] { table }));
a921 22
	}
}

abstract class TypeWrapper
{
	private readonly ClassLoaderWrapper classLoader;
	private readonly string name;		// java name (e.g. java.lang.Object)
	private readonly Modifiers modifiers;
	private MethodWrapper[] methods;
	private FieldWrapper[] fields;
	private readonly TypeWrapper baseWrapper;
	private readonly object classObject;
	private bool hasIncompleteInterfaceImplementation;
	internal static readonly TypeWrapper[] EmptyArray = new TypeWrapper[0];
	internal const Modifiers UnloadableModifiersHack = Modifiers.Final | Modifiers.Interface | Modifiers.Private;
	internal const Modifiers VerifierTypeModifiersHack = Modifiers.Final | Modifiers.Interface;

	internal TypeWrapper(Modifiers modifiers, string name, TypeWrapper baseWrapper, ClassLoaderWrapper classLoader, object protectionDomain)
	{
		Profiler.Count("TypeWrapper");
		// class name should be dotted or null for primitives
		Debug.Assert(name == null || name.IndexOf('/') < 0);
d923 1
a923 5
		this.modifiers = modifiers;
		this.name = name;
		this.baseWrapper = baseWrapper;
		this.classLoader = classLoader;
		if(IsUnloadable || IsVerifierType || JVM.IsStaticCompiler)
d925 4
a928 1
			this.classObject = null;
d930 2
a931 1
		else
d933 9
a941 1
			this.classObject = JVM.Library.newClass(this, protectionDomain);
a942 1
	}
d944 1
a944 3
	internal object ClassObject
	{
		get
d946 5
a950 2
			Debug.Assert(!IsUnloadable && !IsVerifierType);
			return classObject;
a951 14
	}

	public override string ToString()
	{
		return GetType().Name + "[" + name + "]";
	}

	// For UnloadableTypeWrapper it tries to load the type through the specified loader
	// and if that fails it throw a NoClassDefFoundError (not a java.lang.NoClassDefFoundError),
	// for all other types this is a no-op.
	internal virtual TypeWrapper EnsureLoadable(ClassLoaderWrapper loader)
	{
		return this;
	}
d953 1
a953 3
	internal bool HasIncompleteInterfaceImplementation
	{
		get
d955 5
a959 1
			return hasIncompleteInterfaceImplementation || (baseWrapper != null && baseWrapper.HasIncompleteInterfaceImplementation);
d961 2
a962 1
		set
d964 4
a967 1
			hasIncompleteInterfaceImplementation = value;
a968 1
	}
d970 1
a970 3
	internal virtual bool HasStaticInitializer
	{
		get
d972 4
a975 1
			return false;
a976 1
	}
d978 3
a980 6
	// a ghost is an interface that appears to be implemented by a .NET type
	// (e.g. System.String (aka java.lang.String) appears to implement java.lang.CharSequence,
	// so java.lang.CharSequence is a ghost)
	internal virtual bool IsGhost
	{
		get
d982 4
a985 1
			return false;
a986 1
	}
d988 1
a988 4
	// is this an array type of which the ultimate element type is a ghost?
	internal bool IsGhostArray
	{
		get
d990 4
a993 1
			return IsArray && (ElementTypeWrapper.IsGhost || ElementTypeWrapper.IsGhostArray);
a994 1
	}
d996 1
a996 3
	internal virtual FieldInfo GhostRefField
	{
		get
d998 5
a1002 1
			throw new InvalidOperationException();
a1003 1
	}
d1005 1
a1005 3
	internal virtual bool IsRemapped
	{
		get
d1007 4
a1010 1
			return false;
a1011 1
	}
d1013 1
a1013 3
	internal bool IsArray
	{
		get
d1015 5
a1019 1
			return name != null && name[0] == '[';
a1020 1
	}
d1022 5
a1026 4
	// NOTE for non-array types this returns 0
	internal int ArrayRank
	{
		get
d1028 1
a1028 2
			int i = 0;
			if(name != null)
d1030 2
a1031 1
				while(name[i] == '[')
d1033 1
a1033 1
					i++;
d1035 1
a1036 1
			return i;
a1037 1
	}
d1039 1
a1039 3
	internal bool IsNonPrimitiveValueType
	{
		get
d1041 1
a1041 1
			return this != VerifierTypeWrapper.Null && !IsPrimitive && !IsGhost && TypeAsTBD.IsValueType;
a1042 1
	}
d1044 1
a1044 3
	internal bool IsPrimitive
	{
		get
d1046 27
a1072 1
			return name == null;
a1073 1
	}
d1075 1
a1075 3
	internal bool IsWidePrimitive
	{
		get
d1077 8
a1084 1
			return this == PrimitiveTypeWrapper.LONG || this == PrimitiveTypeWrapper.DOUBLE;
a1085 1
	}
d1087 1
a1087 3
	internal bool IsIntOnStackPrimitive
	{
		get
d1089 8
a1096 6
			return name == null &&
				(this == PrimitiveTypeWrapper.BOOLEAN ||
				this == PrimitiveTypeWrapper.BYTE ||
				this == PrimitiveTypeWrapper.CHAR ||
				this == PrimitiveTypeWrapper.SHORT ||
				this == PrimitiveTypeWrapper.INT);
a1097 1
	}
d1099 1
a1099 3
	internal bool IsUnloadable
	{
		get
d1101 8
a1108 2
			// NOTE we abuse modifiers to note unloadable classes
			return modifiers == UnloadableModifiersHack;
a1109 1
	}
d1111 1
a1111 3
	internal bool IsVerifierType
	{
		get
d1113 19
a1131 2
			// NOTE we abuse modifiers to note verifier types
			return modifiers == VerifierTypeModifiersHack;
a1132 1
	}
d1134 1
a1134 3
	internal virtual bool IsMapUnsafeException
	{
		get
d1136 2
a1137 1
			return false;
a1138 1
	}
d1140 1
a1140 3
	internal Modifiers Modifiers
	{
		get
d1142 2
a1143 1
			return modifiers;
a1144 1
	}
d1146 1
a1146 5
	// since for inner classes, the modifiers returned by Class.getModifiers are different from the actual
	// modifiers (as used by the VM access control mechanism), we have this additional property
	internal virtual Modifiers ReflectiveModifiers
	{
		get
d1148 4
a1151 1
			return modifiers;
a1152 1
	}
d1154 2
a1155 3
	internal bool IsPublic
	{
		get
d1157 4
a1160 1
			return (modifiers & Modifiers.Public) != 0;
a1161 1
	}
d1163 1
a1163 3
	internal bool IsAbstract
	{
		get
d1165 1
a1165 2
			// interfaces don't need to marked abstract explicitly (and javac 1.1 didn't do it)
			return (modifiers & (Modifiers.Abstract | Modifiers.Interface)) != 0;
a1166 1
	}
d1168 2
a1169 3
	internal bool IsFinal
	{
		get
d1171 1
a1171 1
			return (modifiers & Modifiers.Final) != 0;
a1172 1
	}
d1174 1
a1174 3
	internal bool IsInterface
	{
		get
d1176 39
a1214 2
			Debug.Assert(!IsUnloadable && !IsVerifierType);
			return (modifiers & Modifiers.Interface) != 0;
a1215 1
	}
d1217 1
a1217 7
	// this exists because interfaces and arrays of interfaces are treated specially
	// by the verifier, interfaces don't have a common base (other than java.lang.Object)
	// so any object reference or object array reference can be used where an interface
	// or interface array reference is expected (the compiler will insert the required casts).
	internal bool IsInterfaceOrInterfaceArray
	{
		get
d1219 1
a1219 6
			TypeWrapper tw = this;
			while(tw.IsArray)
			{
				tw = tw.ElementTypeWrapper;
			}
			return tw.IsInterface;
a1220 6
	}

	internal virtual ClassLoaderWrapper GetClassLoader()
	{
		return classLoader;
	}
d1222 1
a1222 3
	internal FieldWrapper GetFieldWrapper(string fieldName, string fieldSig)
	{
		lock(this)
d1224 1
a1224 1
			if(fields == null)
d1226 3
a1228 1
				LazyPublishMembers();
d1231 2
a1232 1
		foreach(FieldWrapper fw in fields)
d1234 1
a1234 1
			if(fw.Name == fieldName && fw.Signature == fieldSig)
d1236 16
a1251 2
				return fw;
			}	
d1253 2
a1254 1
		foreach(TypeWrapper iface in this.Interfaces)
d1256 1
a1256 2
			FieldWrapper fw = iface.GetFieldWrapper(fieldName, fieldSig);
			if(fw != null)
d1258 1
a1258 1
				return fw;
a1260 6
		if(baseWrapper != null)
		{
			return baseWrapper.GetFieldWrapper(fieldName, fieldSig);
		}
		return null;
	}
d1262 1
a1262 3
	protected virtual void LazyPublishMembers()
	{
		if(methods == null)
d1264 28
a1291 5
			methods = MethodWrapper.EmptyArray;
		}
		if(fields == null)
		{
			fields = FieldWrapper.EmptyArray;
a1292 1
	}
d1294 2
a1295 3
	internal MethodWrapper[] GetMethods()
	{
		lock(this)
d1297 1
a1297 1
			if(methods == null)
d1299 15
a1313 1
				LazyPublishMembers();
a1315 2
		return methods;
	}
d1317 1
a1317 3
	internal FieldWrapper[] GetFields()
	{
		lock(this)
d1319 1
a1319 1
			if(fields == null)
d1321 5
a1325 1
				LazyPublishMembers();
a1327 2
		return fields;
	}
d1329 1
a1329 3
	internal MethodWrapper GetMethodWrapper(string name, string sig, bool inherit)
	{
		lock(this)
d1331 1
a1331 1
			if(methods == null)
d1333 1
a1333 1
				LazyPublishMembers();
d1336 2
a1337 1
		foreach(MethodWrapper mw in methods)
d1339 1
a1339 1
			if(mw.Name == name && mw.Signature == sig)
d1341 38
a1378 1
				return mw;
d1381 2
a1382 1
		if(inherit && baseWrapper != null)
d1384 2
a1385 1
			return baseWrapper.GetMethodWrapper(name, sig, inherit);
a1386 14
		return null;
	}

	internal void SetMethods(MethodWrapper[] methods)
	{
		Debug.Assert(methods != null);
		this.methods = methods;
	}

	internal void SetFields(FieldWrapper[] fields)
	{
		Debug.Assert(fields != null);
		this.fields = fields;
	}
d1388 1
a1388 3
	internal string Name
	{
		get
d1390 18
a1407 1
			return name;
a1408 1
	}
d1410 1
a1410 4
	// the name of the type as it appears in a Java signature string (e.g. "Ljava.lang.Object;" or "I")
	internal virtual string SigName
	{
		get
d1412 6
a1417 3
			return "L" + this.Name + ";";
		}
	}
d1419 10
a1428 21
	internal abstract Assembly Assembly
	{
		get;
	}

	// returns true iff wrapper is allowed to access us
	internal bool IsAccessibleFrom(TypeWrapper wrapper)
	{
		return IsPublic || IsInSamePackageAs(wrapper);
	}

	internal bool IsInSamePackageAs(TypeWrapper wrapper)
	{
		if(GetClassLoader() == wrapper.GetClassLoader() &&
			// Both types must also be in the same assembly, otherwise
			// the packages are not accessible.
			wrapper.Assembly == this.Assembly)
		{
			int index1 = name.LastIndexOf('.');
			int index2 = wrapper.name.LastIndexOf('.');
			if(index1 == -1 && index2 == -1)
d1432 15
a1446 4
			// for array types we need to skip the brackets
			int skip1 = 0;
			int skip2 = 0;
			while(name[skip1] == '[')
d1448 1
a1448 1
				skip1++;
d1450 1
a1450 1
			while(wrapper.name[skip2] == '[')
d1452 1
a1452 1
				skip2++;
d1454 1
a1454 1
			if(skip1 > 0)
d1456 1
a1456 2
				// skip over the L that follows the brackets
				skip1++;
d1458 1
a1458 1
			if(skip2 > 0)
d1460 1
a1460 2
				// skip over the L that follows the brackets
				skip2++;
d1462 3
a1464 1
			if((index1 - skip1) != (index2 - skip2))
d1466 12
a1477 1
				return false;
d1479 1
a1479 1
			return String.CompareOrdinal(name, skip1, wrapper.name, skip2, index1 - skip1) == 0;
a1480 2
		return false;
	}
d1482 4
a1485 4
	internal abstract Type TypeAsTBD
	{
		get;
	}
d1487 2
a1488 3
	internal virtual TypeBuilder TypeAsBuilder
	{
		get
d1490 1
a1490 3
			TypeBuilder typeBuilder = TypeAsTBD as TypeBuilder;
			Debug.Assert(typeBuilder != null);
			return typeBuilder;
a1491 1
	}
d1493 2
a1494 3
	internal Type TypeAsSignatureType
	{
		get
d1496 1
a1496 15
			if(IsUnloadable)
			{
				return typeof(object);
			}
			if(IsGhostArray)
			{
				int rank = ArrayRank;
				string type = "System.Object";
				for(int i = 0; i < rank; i++)
				{
					type += "[]";
				}
				return Type.GetType(type, true);
			}
			return TypeAsTBD;
a1497 1
	}
d1499 1
a1499 3
	internal virtual Type TypeAsBaseType
	{
		get
d1501 1
a1501 1
			return TypeAsTBD;
a1502 1
	}
d1504 3
a1506 3
	internal Type TypeAsLocalOrStackType
	{
		get
d1508 6
a1513 2
			// NOTE as a convenience to the compiler, we replace return address types with typeof(int)
			if(VerifierTypeWrapper.IsRet(this))
d1515 6
a1520 10
				return typeof(int);
			}
			if(IsUnloadable || IsGhost)
			{
				return typeof(object);
			}
			if(IsNonPrimitiveValueType)
			{
				// return either System.ValueType or System.Enum
				return TypeAsTBD.BaseType;
d1522 1
a1522 1
			if(IsGhostArray)
d1524 1
a1524 3
				int rank = ArrayRank;
				string type = "System.Object";
				for(int i = 0; i < rank; i++)
d1526 59
a1584 1
					type += "[]";
a1585 1
				return Type.GetType(type, true);
a1586 1
			return TypeAsTBD;
a1587 1
	}
d1589 1
a1589 4
	/** <summary>Use this if the type is used as an array or array element</summary> */
	internal Type TypeAsArrayType
	{
		get
d1591 4
a1594 1
			if(IsUnloadable || IsGhost)
d1596 1
a1596 1
				return typeof(object);
d1598 2
a1599 1
			if(IsGhostArray)
d1601 1
a1601 3
				int rank = ArrayRank;
				string type = "System.Object";
				for(int i = 0; i < rank; i++)
d1603 1
a1603 1
					type += "[]";
a1604 1
				return Type.GetType(type, true);
d1606 5
a1610 1
			return TypeAsTBD;
a1611 1
	}
d1613 2
a1614 3
	internal Type TypeAsExceptionType
	{
		get
d1616 1
a1616 1
			if(IsUnloadable)
d1618 5
a1622 1
				return typeof(Exception);
a1623 1
			return TypeAsTBD;
a1624 1
	}
d1626 6
a1631 3
	internal TypeWrapper BaseTypeWrapper
	{
		get
d1633 15
a1647 1
			return baseWrapper;
a1648 1
	}
d1650 1
a1650 3
	internal TypeWrapper ElementTypeWrapper
	{
		get
d1652 4
a1655 2
			Debug.Assert(!this.IsUnloadable);
			Debug.Assert(this == VerifierTypeWrapper.Null || this.IsArray);
d1657 10
a1666 1
			if(this == VerifierTypeWrapper.Null)
d1668 1
a1668 1
				return VerifierTypeWrapper.Null;
d1670 1
a1670 3

			// TODO consider caching the element type
			switch(name[1])
d1672 4
a1675 26
				case '[':
					// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
					// (because the ultimate element type was already loaded when this type was created)
					return classLoader.LoadClassByDottedNameFast(name.Substring(1));
				case 'L':
					// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
					// (because the ultimate element type was already loaded when this type was created)
					return classLoader.LoadClassByDottedNameFast(name.Substring(2, name.Length - 3));
				case 'Z':
					return PrimitiveTypeWrapper.BOOLEAN;
				case 'B':
					return PrimitiveTypeWrapper.BYTE;
				case 'S':
					return PrimitiveTypeWrapper.SHORT;
				case 'C':
					return PrimitiveTypeWrapper.CHAR;
				case 'I':
					return PrimitiveTypeWrapper.INT;
				case 'J':
					return PrimitiveTypeWrapper.LONG;
				case 'F':
					return PrimitiveTypeWrapper.FLOAT;
				case 'D':
					return PrimitiveTypeWrapper.DOUBLE;
				default:
					throw new InvalidOperationException(name);
a1677 1
	}
d1679 3
a1681 10
	internal TypeWrapper MakeArrayType(int rank)
	{
		// NOTE this call to LoadClassByDottedNameFast can never fail and will not trigger a class load
		return GetClassLoader().LoadClassByDottedNameFast(new String('[', rank) + this.SigName);
	}

	internal bool ImplementsInterface(TypeWrapper interfaceWrapper)
	{
		TypeWrapper typeWrapper = this;
		while(typeWrapper != null)
d1683 1
a1683 2
			TypeWrapper[] interfaces = typeWrapper.Interfaces;
			for(int i = 0; i < interfaces.Length; i++)
d1685 14
a1698 1
				if(interfaces[i] == interfaceWrapper)
d1700 2
a1701 1
					return true;
d1703 1
a1703 1
				if(interfaces[i].ImplementsInterface(interfaceWrapper))
d1705 1
a1705 1
					return true;
a1707 1
			typeWrapper = typeWrapper.BaseTypeWrapper;
a1708 11
		return false;
	}

	internal bool IsSubTypeOf(TypeWrapper baseType)
	{
		// make sure IsSubTypeOf isn't used on primitives
		Debug.Assert(!this.IsPrimitive);
		Debug.Assert(!baseType.IsPrimitive);
		// can't be used on Unloadable
		Debug.Assert(!this.IsUnloadable);
		Debug.Assert(!baseType.IsUnloadable);
d1710 1
a1710 1
		if(baseType.IsInterface)
d1712 10
a1721 1
			if(baseType == this)
d1723 13
a1735 1
				return true;
d1737 1
a1737 12
			return ImplementsInterface(baseType);
		}
		// NOTE this isn't just an optimization, it is also required when this is an interface
		if(baseType == CoreClasses.java.lang.Object.Wrapper)
		{
			return true;
		}
		TypeWrapper subType = this;
		while(subType != baseType)
		{
			subType = subType.BaseTypeWrapper;
			if(subType == null)
d1739 1
a1739 1
				return false;
a1741 2
		return true;
	}
d1743 1
a1743 3
	internal bool IsAssignableTo(TypeWrapper wrapper)
	{
		if(this == wrapper)
d1745 15
a1759 23
			return true;
		}
		if(this.IsPrimitive || wrapper.IsPrimitive)
		{
			return false;
		}
		if(this == VerifierTypeWrapper.Null)
		{
			return true;
		}
		if(wrapper.IsInterface)
		{
			return ImplementsInterface(wrapper);
		}
		int rank1 = this.ArrayRank;
		int rank2 = wrapper.ArrayRank;
		if(rank1 > 0 && rank2 > 0)
		{
			rank1--;
			rank2--;
			TypeWrapper elem1 = this.ElementTypeWrapper;
			TypeWrapper elem2 = wrapper.ElementTypeWrapper;
			while(rank1 != 0 && rank2 != 0)
d1761 3
a1763 4
				elem1 = elem1.ElementTypeWrapper;
				elem2 = elem2.ElementTypeWrapper;
				rank1--;
				rank2--;
a1764 1
			return !elem1.IsNonPrimitiveValueType && elem1.IsSubTypeOf(elem2);
a1765 2
		return this.IsSubTypeOf(wrapper);
	}
d1767 3
a1769 4
	internal abstract TypeWrapper[] Interfaces
	{
		get;
	}
d1771 4
a1774 5
	// NOTE this property can only be called for finished types!
	internal abstract TypeWrapper[] InnerClasses
	{
		get;
	}
d1776 10
a1785 10
	// NOTE this property can only be called for finished types!
	internal abstract TypeWrapper DeclaringTypeWrapper
	{
		get;
	}

	internal void Finish()
	{
		Finish(false);
	}
d1787 2
a1788 13
	internal abstract void Finish(bool forDebugSave);

	private void ImplementInterfaceMethodStubImpl(MethodWrapper ifmethod, TypeBuilder typeBuilder, DynamicTypeWrapper wrapper)
	{
		// we're mangling the name to prevent subclasses from accidentally overriding this method and to
		// prevent clashes with overloaded method stubs that are erased to the same signature (e.g. unloadable types and ghost arrays)
		string mangledName = this.Name + "/" + ifmethod.Name + ifmethod.Signature;
		MethodWrapper mce = null;
		TypeWrapper lookup = wrapper;
		while(lookup != null)
		{
			mce = lookup.GetMethodWrapper(ifmethod.Name, ifmethod.Signature, true);
			if(mce == null || !mce.IsStatic)
d1790 1
a1790 1
				break;
d1792 1
a1792 1
			lookup = mce.DeclaringType.BaseTypeWrapper;
d1794 3
a1796 1
		if(mce != null)
d1798 3
a1800 1
			if(mce.IsMirandaMethod && mce.DeclaringType == wrapper)
d1802 1
a1802 1
				// Miranda methods already have a methodimpl (if needed) to implement the correct interface method
d1804 5
a1808 1
			else if(!mce.IsPublic)
d1810 1
a1810 9
				// NOTE according to the ECMA spec it isn't legal for a privatescope method to be virtual, but this works and
				// it makes sense, so I hope the spec is wrong
				// UPDATE unfortunately, according to Serge Lidin the spec is correct, and it is not allowed to have virtual privatescope
				// methods. Sigh! So I have to use private methods and mangle the name
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
				AttributeHelper.HideFromJava(mb);
				EmitHelper.Throw(mb.GetILGenerator(), "java.lang.IllegalAccessError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
				wrapper.HasIncompleteInterfaceImplementation = true;
d1812 2
a1813 1
			else if(mce.GetMethod() == null || mce.RealName != ifmethod.RealName)
d1815 1
a1815 12
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
				AttributeHelper.HideFromJava(mb);
				ILGenerator ilGenerator = mb.GetILGenerator();
				ilGenerator.Emit(OpCodes.Ldarg_0);
				int argc = mce.GetParameters().Length;
				for(int n = 0; n < argc; n++)
				{
					ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
				}
				mce.EmitCallvirt(ilGenerator);
				ilGenerator.Emit(OpCodes.Ret);
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
d1817 1
a1817 1
			else if(mce.DeclaringType.TypeAsTBD.Assembly != typeBuilder.Assembly)
d1819 1
a1819 15
				// NOTE methods inherited from base classes in a different assembly do *not* automatically implement
				// interface methods, so we have to generate a stub here that doesn't do anything but call the base
				// implementation
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
				AttributeHelper.HideFromJava(mb);
				ILGenerator ilGenerator = mb.GetILGenerator();
				ilGenerator.Emit(OpCodes.Ldarg_0);
				int argc = mce.GetParameters().Length;
				for(int n = 0; n < argc; n++)
				{
					ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
				}
				mce.EmitCallvirt(ilGenerator);
				ilGenerator.Emit(OpCodes.Ret);
d1822 9
a1830 1
		else
d1832 1
a1832 10
			if(!wrapper.IsAbstract)
			{
				// the type doesn't implement the interface method and isn't abstract either. The JVM allows this, but the CLR doesn't,
				// so we have to create a stub method that throws an AbstractMethodError
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
				AttributeHelper.HideFromJava(mb);
				EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
				wrapper.HasIncompleteInterfaceImplementation = true;
			}
d1836 1
a1836 1
	internal void ImplementInterfaceMethodStubs(TypeBuilder typeBuilder, DynamicTypeWrapper wrapper, Hashtable doneSet)
d1838 1
a1838 1
		Debug.Assert(this.IsInterface);
d1840 2
a1841 2
		// make sure we don't do the same method twice
		if(doneSet.ContainsKey(this))
d1843 18
a1860 1
			return;
d1862 2
a1863 2
		doneSet.Add(this, this);
		foreach(MethodWrapper method in GetMethods())
d1865 6
a1870 1
			if(!method.IsStatic)
a1871 1
				ImplementInterfaceMethodStubImpl(method, typeBuilder, wrapper);
d1873 5
d1879 2
a1880 2
		TypeWrapper[] interfaces = Interfaces;
		for(int i = 0; i < interfaces.Length; i++)
d1882 4
a1885 1
			interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
a1886 1
	}
d1888 1
a1888 4
	[Conditional("DEBUG")]
	internal static void AssertFinished(Type type)
	{
		if(type != null)
d1890 1
a1890 1
			while(type.IsArray)
d1892 6
a1897 1
				type = type.GetElementType();
a1898 1
			Debug.Assert(!(type is TypeBuilder));
a1899 1
	}
d1901 1
a1901 34
	internal void RunClassInit()
	{
		System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(TypeAsTBD.TypeHandle);
	}

	internal void EmitUnbox(ILGenerator ilgen)
	{
		Debug.Assert(this.IsNonPrimitiveValueType);

		Type type = this.TypeAsTBD;
		// NOTE if the reference is null, we treat it as a default instance of the value type.
		ilgen.Emit(OpCodes.Dup);
		Label label1 = ilgen.DefineLabel();
		ilgen.Emit(OpCodes.Brtrue_S, label1);
		ilgen.Emit(OpCodes.Pop);
		ilgen.Emit(OpCodes.Ldloc, ilgen.DeclareLocal(type));
		Label label2 = ilgen.DefineLabel();
		ilgen.Emit(OpCodes.Br_S, label2);
		ilgen.MarkLabel(label1);
		ilgen.Emit(OpCodes.Unbox, type);
		ilgen.Emit(OpCodes.Ldobj, type);
		ilgen.MarkLabel(label2);
	}

	internal void EmitBox(ILGenerator ilgen)
	{
		Debug.Assert(this.IsNonPrimitiveValueType);

		ilgen.Emit(OpCodes.Box, this.TypeAsTBD);
	}

	internal void EmitConvSignatureTypeToStackType(ILGenerator ilgen)
	{
		if(IsUnloadable)
d1903 1
d1905 2
a1906 1
		else if(this == PrimitiveTypeWrapper.BYTE)
d1908 7
a1914 3
			ilgen.Emit(OpCodes.Conv_I1);
		}
		else if(IsNonPrimitiveValueType)
d1916 4
a1919 1
			EmitBox(ilgen);
d1921 2
a1922 1
		else if(IsGhost)
d1924 4
a1927 4
			LocalBuilder local = ilgen.DeclareLocal(TypeAsSignatureType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(OpCodes.Ldloca, local);
			ilgen.Emit(OpCodes.Ldfld, GhostRefField);
a1928 1
	}
d1930 1
a1930 5
	// NOTE sourceType is optional and only used for interfaces,
	// it is *not* used to automatically downcast
	internal void EmitConvStackTypeToSignatureType(ILGenerator ilgen, TypeWrapper sourceType)
	{
		if(!IsUnloadable)
d1932 1
a1932 14
			if(IsGhost)
			{
				LocalBuilder local1 = ilgen.DeclareLocal(TypeAsLocalOrStackType);
				ilgen.Emit(OpCodes.Stloc, local1);
				LocalBuilder local2 = ilgen.DeclareLocal(TypeAsSignatureType);
				ilgen.Emit(OpCodes.Ldloca, local2);
				ilgen.Emit(OpCodes.Ldloc, local1);
				ilgen.Emit(OpCodes.Stfld, GhostRefField);
				ilgen.Emit(OpCodes.Ldloca, local2);
				ilgen.Emit(OpCodes.Ldobj, TypeAsSignatureType);
			}
				// because of the way interface merging works, any reference is valid
				// for any interface reference
			else if(IsInterfaceOrInterfaceArray && (sourceType == null || sourceType.IsUnloadable || !sourceType.IsAssignableTo(this)))
d1934 1
a1934 6
				EmitHelper.EmitAssertType(ilgen, TypeAsTBD);
				Profiler.Count("InterfaceDownCast");
			}
			else if(IsNonPrimitiveValueType)
			{
				EmitUnbox(ilgen);
a1936 1
	}
d1938 1
a1938 3
	internal virtual void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
	{
		if(IsGhost)
d1940 1
a1940 6
			ilgen.Emit(OpCodes.Dup);
			// TODO make sure we get the right "Cast" method and cache it
			// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
			// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
			ilgen.Emit(OpCodes.Call, TypeAsTBD.GetMethod("Cast"));
			ilgen.Emit(OpCodes.Pop);
d1942 2
a1943 1
		else if(IsGhostArray)
d1945 3
a1947 13
			ilgen.Emit(OpCodes.Dup);
			// TODO make sure we get the right "CastArray" method and cache it
			// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
			// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
			TypeWrapper tw = this;
			int rank = 0;
			while(tw.IsArray)
			{
				rank++;
				tw = tw.ElementTypeWrapper;
			}
			ilgen.Emit(OpCodes.Ldc_I4, rank);
			ilgen.Emit(OpCodes.Call, tw.TypeAsTBD.GetMethod("CastArray"));
d1949 2
a1950 1
		else
d1952 3
a1954 1
			EmitHelper.Castclass(ilgen, TypeAsTBD);
d1958 1
a1958 1
	internal virtual void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
d1960 15
a1974 1
		if(IsGhost)
d1976 2
a1977 4
			// TODO make sure we get the right "IsInstance" method and cache it
			// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
			// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
			ilgen.Emit(OpCodes.Call, TypeAsTBD.GetMethod("IsInstance"));
d1979 2
a1980 1
		else if(IsGhostArray)
d1982 4
a1985 4
			// TODO make sure we get the right "IsInstanceArray" method and cache it
			// NOTE for dynamic ghosts we don't end up here because DynamicTypeWrapper overrides this method,
			// so we're safe to call GetMethod on TypeAsTBD (because it has to be a compiled type, if we're here)
			ilgen.Emit(OpCodes.Call, TypeAsTBD.GetMethod("IsInstanceArray"));
d1987 2
a1988 1
		else
d1990 4
a1993 3
			ilgen.Emit(OpCodes.Isinst, TypeAsTBD);
			ilgen.Emit(OpCodes.Ldnull);
			ilgen.Emit(OpCodes.Cgt_Un);
a1994 5
	}

	internal static string GetSigNameFromType(Type type)
	{
		TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromTypeFast(type);
d1996 1
a1996 1
		if(wrapper != null)
d1998 1
a1998 1
			return wrapper.SigName;
d2001 1
a2001 1
		if(type.IsArray)
d2003 1
a2003 2
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			while(type.IsArray)
d2005 1
a2005 2
				sb.Append('[');
				type = type.GetElementType();
a2006 1
			return sb.Append(GetSigNameFromType(type)).ToString();
d2009 1
a2009 2
		string s = TypeWrapper.GetNameFromType(type);
		if(s[0] != '[')
d2011 4
a2014 1
			s = "L" + s + ";";
a2015 2
		return s;
	}
d2017 1
a2017 6
	// NOTE returns null for primitive types
	internal static string GetNameFromType(Type type)
	{
		TypeWrapper.AssertFinished(type);

		if(type.IsArray)
d2019 4
a2022 1
			return GetSigNameFromType(type);
d2025 1
a2025 4
		// first we check if a wrapper exists, because if it does we must use the name from the wrapper to
		// make sure that remapped types return the proper name
		TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromTypeFast(type);
		if(wrapper != null)
d2027 4
a2030 1
			return wrapper.Name;
d2033 1
a2033 1
		if(type.Module.IsDefined(typeof(JavaModuleAttribute), false))
a2034 1
			return CompiledTypeWrapper.GetName(type);
d2036 2
a2037 1
		else
d2039 1
a2039 1
			return DotNetTypeWrapper.GetName(type);
d2043 1
a2043 2
	// NOTE don't call this method, call MethodWrapper.Link instead
	internal virtual MethodBase LinkMethod(MethodWrapper mw)
d2045 6
a2050 225
		return mw.GetMethod();
	}

	// NOTE don't call this method, call FieldWrapper.Link instead
	internal virtual FieldInfo LinkField(FieldWrapper fw)
	{
		return fw.GetField();
	}
}

class UnloadableTypeWrapper : TypeWrapper
{
	private static Hashtable warningHashtable;

	internal UnloadableTypeWrapper(string name)
		: base(TypeWrapper.UnloadableModifiersHack, name, null, null, null)
	{
		if(JVM.IsStaticCompiler && name != "<verifier>")
		{
			if(warningHashtable == null)
			{
				warningHashtable = new Hashtable();
			}
			if(name.StartsWith("["))
			{
				int skip = 1;
				while(name[skip++] == '[');
				name = name.Substring(skip, name.Length - skip - 1);
			}
			if(!warningHashtable.ContainsKey(name))
			{
				warningHashtable.Add(name, name);
				Console.Error.WriteLine("Warning: class \"{0}\" not found", name);
			}
		}
	}

	internal override TypeWrapper EnsureLoadable(ClassLoaderWrapper loader)
	{
		TypeWrapper tw = null;
		try
		{
			tw = loader.LoadClassByDottedNameFast(this.Name);
		}
		catch
		{
		}
		if(tw == null)
		{
			throw new NoClassDefFoundError(this.Name);
		}
		return tw;
	}

	internal override Assembly Assembly
	{
		get
		{
			return null;
		}
	}

	internal override string SigName
	{
		get
		{
			string name = Name;
			if(name.StartsWith("["))
			{
				return name;
			}
			return "L" + name + ";";
		}
	}

	protected override void LazyPublishMembers()
	{
		throw new InvalidOperationException("LazyPublishMembers called on UnloadableTypeWrapper: " + Name);
	}

	internal override Type TypeAsTBD
	{
		get
		{
			throw new InvalidOperationException("get_Type called on UnloadableTypeWrapper: " + Name);
		} 
	} 

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			throw new InvalidOperationException("get_Interfaces called on UnloadableTypeWrapper: " + Name);
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			throw new InvalidOperationException("get_InnerClasses called on UnloadableTypeWrapper: " + Name);
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			throw new InvalidOperationException("get_DeclaringTypeWrapper called on UnloadableTypeWrapper: " + Name);
		}
	}

	internal override void Finish(bool forDebugSave)
	{
		throw new InvalidOperationException("Finish called on UnloadableTypeWrapper: " + Name);
	}

	internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
	{
		ilgen.Emit(OpCodes.Ldtoken, context.TypeAsTBD);
		ilgen.Emit(OpCodes.Ldstr, Name);
		ilgen.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicCast"));
	}

	internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
	{
		ilgen.Emit(OpCodes.Ldtoken, context.TypeAsTBD);
		ilgen.Emit(OpCodes.Ldstr, Name);
		ilgen.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicInstanceOf"));
	}
}

class PrimitiveTypeWrapper : TypeWrapper
{
	internal static readonly PrimitiveTypeWrapper BYTE = new PrimitiveTypeWrapper(typeof(byte), "B");
	internal static readonly PrimitiveTypeWrapper CHAR = new PrimitiveTypeWrapper(typeof(char), "C");
	internal static readonly PrimitiveTypeWrapper DOUBLE = new PrimitiveTypeWrapper(typeof(double), "D");
	internal static readonly PrimitiveTypeWrapper FLOAT = new PrimitiveTypeWrapper(typeof(float), "F");
	internal static readonly PrimitiveTypeWrapper INT = new PrimitiveTypeWrapper(typeof(int), "I");
	internal static readonly PrimitiveTypeWrapper LONG = new PrimitiveTypeWrapper(typeof(long), "J");
	internal static readonly PrimitiveTypeWrapper SHORT = new PrimitiveTypeWrapper(typeof(short), "S");
	internal static readonly PrimitiveTypeWrapper BOOLEAN = new PrimitiveTypeWrapper(typeof(bool), "Z");
	internal static readonly PrimitiveTypeWrapper VOID = new PrimitiveTypeWrapper(typeof(void), "V");

	private readonly Type type;
	private readonly string sigName;

	private PrimitiveTypeWrapper(Type type, string sigName)
		: base(Modifiers.Public | Modifiers.Abstract | Modifiers.Final, null, null, null, null)
	{
		this.type = type;
		this.sigName = sigName;
	}

	internal override Assembly Assembly
	{
		get
		{
			return null;
		}
	}

	internal override string SigName
	{
		get
		{
			return sigName;
		}
	}

	internal override ClassLoaderWrapper GetClassLoader()
	{
		return ClassLoaderWrapper.GetBootstrapClassLoader();
	}

	internal override Type TypeAsTBD
	{
		get
		{
			return type;
		}
	}

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			return TypeWrapper.EmptyArray;
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			return TypeWrapper.EmptyArray;
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			return null;
		}
	}

	internal override void Finish(bool forDebugSave)
	{
	}

	public override string ToString()
	{
		return "PrimitiveTypeWrapper[" + sigName + "]";
	}
}

class BakedTypeCleanupHack
{
	private static readonly FieldInfo m_methodBuilder = typeof(ConstructorBuilder).GetField("m_methodBuilder", BindingFlags.Instance | BindingFlags.NonPublic);
	private static readonly FieldInfo[] methodBuilderFields = GetFieldList(typeof(MethodBuilder), new string[]
			{
				"m_ilGenerator",
				"m_ubBody",
				"m_RVAFixups",
d2060 1
a2060 1
	private static readonly FieldInfo[] fieldBuilderFields = GetFieldList(typeof(FieldBuilder), new string[]
d2064 1
a2064 1
			});
d2066 1
a2066 3
	private static bool IsSupportedVersion
	{
		get
d2068 4
a2071 1
			return Environment.Version.Major == 1 && Environment.Version.Minor == 1 && Environment.Version.Build == 4322;
a2072 1
	}
d2074 1
a2074 3
	private static FieldInfo[] GetFieldList(Type type, string[] list)
	{
		if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage || !IsSupportedVersion)
d2076 8
a2083 14
			// if we're going to be saving the image, we cannot bash the MethodBuilder fields,
			// because the data is required to generated the PE file.
			return null;
		}
		if(!SecurityManager.IsGranted(new SecurityPermission(SecurityPermissionFlag.Assertion)) ||
			!SecurityManager.IsGranted(new ReflectionPermission(ReflectionPermissionFlag.MemberAccess)))
		{
			return null;
		}
		FieldInfo[] fields = new FieldInfo[list.Length];
		for(int i = 0; i < list.Length; i++)
		{
			fields[i] = type.GetField(list[i], BindingFlags.Instance | BindingFlags.NonPublic);
			if(fields[i] == null)
d2087 10
a2097 2
		return fields;
	}
d2099 1
a2099 3
	internal static void Process(DynamicTypeWrapper wrapper)
	{
		if(m_methodBuilder != null && methodBuilderFields != null && fieldBuilderFields != null)
d2101 1
a2101 1
			foreach(MethodWrapper mw in wrapper.GetMethods())
d2103 1
a2103 2
				MethodBuilder mb = mw.GetMethod() as MethodBuilder;
				if(mb == null)
d2105 12
a2116 2
					ConstructorBuilder cb = mw.GetMethod() as ConstructorBuilder;
					if(cb != null)
d2119 4
a2122 1
						mb = (MethodBuilder)m_methodBuilder.GetValue(cb);
d2126 1
a2126 1
				if(mb != null)
d2128 2
a2129 2
					new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
					foreach(FieldInfo fi in methodBuilderFields)
d2131 6
a2136 14
						fi.SetValue(mb, null);
					}
					CodeAccessPermission.RevertAssert();
				}
			}
			foreach(FieldWrapper fw in wrapper.GetFields())
			{
				FieldBuilder fb = fw.GetField() as FieldBuilder;
				if(fb != null)
				{
					new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
					foreach(FieldInfo fi in fieldBuilderFields)
					{
						fi.SetValue(fb, null);
a2137 1
					CodeAccessPermission.RevertAssert();
a2141 1
}
d2143 5
a2147 5
class DynamicTypeWrapper : TypeWrapper
{
	private volatile DynamicImpl impl;
	private TypeWrapper[] interfaces;
	private bool hasStaticInitializer;
d2149 1
a2149 4
	private static TypeWrapper LoadTypeWrapper(ClassLoaderWrapper classLoader, string name)
	{
		TypeWrapper tw = classLoader.LoadClassByDottedNameFast(name);
		if(tw == null)
d2151 6
a2156 1
			throw new NoClassDefFoundError(name);
a2157 2
		return tw;
	}
d2159 2
a2160 5
	internal DynamicTypeWrapper(ClassFile f, ClassLoaderWrapper classLoader, object protectionDomain)
		: base(f.Modifiers, f.Name, f.IsInterface ? null : LoadTypeWrapper(classLoader, f.SuperClass), classLoader, protectionDomain)
	{
		Profiler.Count("DynamicTypeWrapper");
		if(BaseTypeWrapper != null)
d2162 2
a2163 13
			if(!BaseTypeWrapper.IsAccessibleFrom(this))
			{
				throw new IllegalAccessError("Class " + f.Name + " cannot access its superclass " + BaseTypeWrapper.Name);
			}
			if(BaseTypeWrapper.IsFinal)
			{
				throw new VerifyError("Cannot inherit from final class");
			}
			if(BaseTypeWrapper.IsInterface)
			{
				throw new IncompatibleClassChangeError("Class " + f.Name + " has interface " + BaseTypeWrapper.Name + " as superclass");
			}
			if(!f.IsFinal)
d2165 28
d2195 1
a2195 1
					throw new VerifyError("Value types must be final");
d2199 1
a2199 1
					throw new VerifyError("Delegates must be final");
d2202 4
a2205 1
			if(BaseTypeWrapper.TypeAsTBD == typeof(Delegate))
d2207 10
a2216 10
				throw new VerifyError(BaseTypeWrapper.Name + " cannot be used as a base class");
			}
			// NOTE defining value types, enums and delegates is not supported in IKVM v1
			if(BaseTypeWrapper.TypeAsTBD == typeof(ValueType) || BaseTypeWrapper.TypeAsTBD == typeof(Enum))
			{
				throw new VerifyError("Defining value types in Java is not implemented in IKVM v1");
			}
			if(BaseTypeWrapper.TypeAsTBD == typeof(MulticastDelegate))
			{
				throw new VerifyError("Defining delegates in Java is not implemented in IKVM v1");
d2218 2
d2222 1
a2222 3
		ClassFile.ConstantPoolItemClass[] interfaces = f.Interfaces;
		this.interfaces = new TypeWrapper[interfaces.Length];
		for(int i = 0; i < interfaces.Length; i++)
d2224 1
a2224 2
			TypeWrapper iface = LoadTypeWrapper(classLoader, interfaces[i].Name);
			if(!iface.IsAccessibleFrom(this))
d2226 1
a2226 1
				throw new IllegalAccessError("Class " + f.Name + " cannot access its superinterface " + iface.Name);
a2227 5
			if(!iface.IsInterface)
			{
				throw new IncompatibleClassChangeError("Implementing class");
			}
			this.interfaces[i] = iface;
d2230 1
a2230 6
		impl = new JavaTypeImpl(f, this);
	}

	internal override bool HasStaticInitializer
	{
		get
d2232 4
a2235 1
			return hasStaticInitializer;
a2236 1
	}
d2238 1
a2238 3
	internal override Assembly Assembly
	{
		get
d2240 4
a2243 1
			return GetClassLoader().ModuleBuilder.Assembly;
a2244 1
	}
d2246 1
a2246 3
	internal override Modifiers ReflectiveModifiers
	{
		get
d2248 4
a2251 1
			return impl.ReflectiveModifiers;
a2252 1
	}
d2254 1
a2254 3
	internal override TypeWrapper[] Interfaces
	{
		get
d2256 4
a2259 1
			return interfaces;
a2260 1
	}
d2262 1
a2262 3
	internal override TypeWrapper[] InnerClasses
	{
		get
d2264 4
a2267 1
			return impl.InnerClasses;
a2268 1
	}
d2270 1
a2270 3
	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
d2272 4
a2275 1
			return impl.DeclaringTypeWrapper;
a2276 1
	}
d2278 1
a2278 3
	internal override Type TypeAsTBD
	{
		get
d2280 14
a2293 1
			return impl.Type;
a2294 1
	}
d2296 2
a2297 3
	internal override void Finish(bool forDebugSave)
	{
		lock(this)
d2299 1
a2299 8
			Profiler.Enter("DynamicTypeWrapper.Finish");
			try
			{
				impl = impl.Finish(forDebugSave);
				// call Finish again to get the verify error for doomed types
				impl.Finish(forDebugSave);
			}
			finally
d2301 1
a2301 1
				Profiler.Leave("DynamicTypeWrapper.Finish");
a2303 1
	}
d2305 2
a2306 4
	// NOTE can only be used if the type hasn't been finished yet!
	internal FieldInfo ClassObjectField
	{
		get
d2308 1
a2308 1
			return ((JavaTypeImpl)impl).ClassObjectField;
a2309 1
	}
d2311 10
a2320 5
	// NOTE can only be used if the type hasn't been finished yet!
	protected string GenerateUniqueMethodName(string basename, MethodWrapper mw)
	{
		return ((JavaTypeImpl)impl).GenerateUniqueMethodName(basename, mw);
	}
d2322 14
a2335 10
	private abstract class DynamicImpl
	{
		internal abstract Type Type { get; }
		internal abstract TypeWrapper[] InnerClasses { get; }
		internal abstract TypeWrapper DeclaringTypeWrapper { get; }
		internal abstract Modifiers ReflectiveModifiers { get; }
		internal abstract DynamicImpl Finish(bool forDebugSave);
		internal abstract MethodBase LinkMethod(MethodWrapper mw);
		internal abstract FieldInfo LinkField(FieldWrapper fw);
	}
d2337 1
a2337 26
	private class JavaTypeImpl : DynamicImpl
	{
		private readonly ClassFile classFile;
		private readonly DynamicTypeWrapper wrapper;
		private readonly TypeBuilder typeBuilder;
		private MethodWrapper[] methods;
		private MethodWrapper[] baseMethods;
		private FieldWrapper[] fields;
		private bool finishingForDebugSave;
		private FinishedTypeImpl finishedType;
		private readonly TypeWrapper outerClassWrapper;
		private Hashtable memberclashtable;
		private Hashtable classCache = new Hashtable();
		private FieldInfo classObjectField;

		internal JavaTypeImpl(ClassFile f, DynamicTypeWrapper wrapper)
		{
			Tracer.Info(Tracer.Compiler, "constructing JavaTypeImpl for " + f.Name);
			this.classFile = f;
			this.wrapper = wrapper;

			// process all methods
			bool hasclinit = wrapper.BaseTypeWrapper == null ? false : wrapper.BaseTypeWrapper.HasStaticInitializer;
			methods = new MethodWrapper[classFile.Methods.Length];
			baseMethods = new MethodWrapper[classFile.Methods.Length];
			for(int i = 0; i < methods.Length; i++)
d2339 9
a2347 2
				ClassFile.Method m = classFile.Methods[i];
				if(m.IsClassInitializer)
d2349 2
a2350 1
					if(JVM.IsStaticCompiler)
d2352 8
a2359 1
						if(!IsSideEffectFreeStaticInitializer(m))
d2364 8
d2374 6
a2379 1
						hasclinit = true;
d2382 2
a2383 1
				if(wrapper.IsGhost)
d2385 5
a2389 1
					methods[i] = new MethodWrapper.GhostMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, MemberFlags.None);
d2391 4
a2394 1
				else if(m.Name == "<init>")
d2396 10
a2405 6
					methods[i] = new SmartConstructorMethodWrapper(wrapper, m.Name, m.Signature, null, null, m.Modifiers, MemberFlags.None);
				}
				else
				{
					bool explicitOverride = false;
					if(!classFile.IsInterface && !m.IsStatic && !m.IsPrivate)
d2407 1
a2407 1
						baseMethods[i] = FindBaseMethod(m.Name, m.Signature, out explicitOverride);
a2408 1
					methods[i] = new SmartCallMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, explicitOverride ? MemberFlags.ExplicitOverride : MemberFlags.None, SimpleOpCode.Call, SimpleOpCode.Callvirt);
d2410 1
a2410 11
			}
			wrapper.hasStaticInitializer = hasclinit;
			if(wrapper.IsAbstract && !wrapper.IsInterface)
			{
				ArrayList methodsArray = new ArrayList(methods);
				ArrayList baseMethodsArray = new ArrayList(baseMethods);
				AddMirandaMethods(methodsArray, baseMethodsArray, wrapper);
				this.methods = (MethodWrapper[])methodsArray.ToArray(typeof(MethodWrapper));
				this.baseMethods = (MethodWrapper[])baseMethodsArray.ToArray(typeof(MethodWrapper));
			}
			wrapper.SetMethods(methods);
d2412 3
a2414 5
			fields = new FieldWrapper[classFile.Fields.Length];
			for(int i = 0; i < fields.Length; i++)
			{
				ClassFile.Field fld = classFile.Fields[i];
				if(fld.IsStatic && fld.IsFinal && fld.ConstantValue != null)
d2416 35
a2450 36
					fields[i] = new ConstantFieldWrapper(wrapper, null, fld.Name, fld.Signature, fld.Modifiers, null, fld.ConstantValue);
				}
				else if(fld.IsFinal && (fld.IsPublic || fld.IsProtected) && !wrapper.IsInterface)
				{
					fields[i] = new GetterFieldWrapper(wrapper, null, null, fld.Name, fld.Signature, fld.Modifiers, null);
				}
				else
				{
					fields[i] = FieldWrapper.Create(wrapper, null, null, fld.Name, fld.Signature, fld.Modifiers);
				}
			}
			wrapper.SetFields(fields);

			// from now on we shouldn't be throwing any exceptions (to be precise, after we've
			// called ModuleBuilder.DefineType)
			try
			{
				TypeAttributes typeAttribs = 0;
				if(f.IsAbstract)
				{
					typeAttribs |= TypeAttributes.Abstract;
				}
				if(f.IsFinal)
				{
					typeAttribs |= TypeAttributes.Sealed;
				}
				if(!hasclinit)
				{
					typeAttribs |= TypeAttributes.BeforeFieldInit;
				}
				TypeBuilder outer = null;
				// only if requested, we compile inner classes as nested types, because it has a higher cost
				// and doesn't buy us anything, unless we're compiling a library that could be used from C# (e.g.)
				if(JVM.CompileInnerClassesAsNestedTypes)
				{
					if(f.OuterClass != null)
d2452 1
a2452 1
						if(!CheckInnerOuterNames(f.Name, f.OuterClass.Name))
d2454 1
a2454 1
							Tracer.Warning(Tracer.Compiler, "Incorrect InnerClasses attribute on {0}", f.Name);
d2458 13
a2470 2
							outerClassWrapper = wrapper.GetClassLoader().LoadClassByDottedName(f.OuterClass.Name);
							if(outerClassWrapper is DynamicTypeWrapper)
d2472 3
a2474 1
								outer = outerClassWrapper.TypeAsBuilder;
d2476 7
d2485 1
a2485 4
				}
				if(f.IsPublic)
				{
					if(outer != null)
d2487 11
a2497 1
						typeAttribs |= TypeAttributes.NestedPublic;
d2499 2
a2500 1
					else
d2502 2
a2503 1
						typeAttribs |= TypeAttributes.Public;
d2505 2
a2506 9
				}
				else if(outer != null)
				{
					typeAttribs |= TypeAttributes.NestedAssembly;
				}
				if(f.IsInterface)
				{
					typeAttribs |= TypeAttributes.Interface | TypeAttributes.Abstract;
					if(outer != null)
d2508 1
a2508 9
						if(wrapper.IsGhost)
						{
							// TODO this is low priority, since the current Java class library doesn't define any ghost interfaces
							// as inner classes
							throw new NotImplementedException();
						}
						// LAMESPEC the CLI spec says interfaces cannot contain nested types (Part.II, 9.6), but that rule isn't enforced
						// (and broken by J# as well), so we'll just ignore it too.
						typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs);
d2510 1
a2510 1
					else
d2512 1
a2512 1
						typeBuilder = wrapper.DefineType(typeAttribs);
d2515 1
a2515 1
				else
d2517 1
a2517 8
					typeAttribs |= TypeAttributes.Class;
					if(outer != null)
					{
						// LAMESPEC the CLI spec says interfaces cannot contain nested types (Part.II, 9.6), but that rule isn't enforced
						// (and broken by J# as well), so we'll just ignore it too.
						typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
					}
					else
d2519 1
a2519 1
						typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
d2521 1
d2523 5
a2527 2
				TypeWrapper[] interfaces = wrapper.Interfaces;
				for(int i = 0; i < interfaces.Length; i++)
d2529 1
a2529 2
					// NOTE we're using TypeAsBaseType for the interfaces!
					typeBuilder.AddInterfaceImplementation(interfaces[i].TypeAsBaseType);
d2531 1
a2531 2
				AttributeHelper.SetImplementsAttribute(typeBuilder, interfaces);
				if(JVM.IsStaticCompiler && classFile.DeprecatedAttribute)
d2533 27
a2559 1
					AttributeHelper.SetDeprecatedAttribute(typeBuilder);
d2561 3
a2563 1
				if(f.SourceFileAttribute != null && !JVM.NoStackTraceInfo)
d2565 2
a2566 1
					AttributeHelper.SetSourceFile(typeBuilder, f.SourceFileAttribute);
d2568 1
a2568 4
			}
			catch(Exception x)
			{
				if(typeBuilder != null)
d2570 1
a2570 1
					JVM.CriticalFailure("Exception during critical part of JavaTypeImpl construction", x);
a2571 1
				throw;
a2572 1
		}
d2574 1
a2574 7
		private bool IsSideEffectFreeStaticInitializer(ClassFile.Method m)
		{
			if(m.ExceptionTable.Length != 0)
			{
				return false;
			}
			for(int i = 0; i < m.Instructions.Length; i++)
d2576 1
a2576 2
				ByteCode bc = m.Instructions[i].OpCode;
				if(bc == ByteCode.__getstatic || bc == ByteCode.__putstatic)
d2578 1
a2578 2
					ClassFile.ConstantPoolItemFieldref fld = classFile.GetFieldref(m.Instructions[i].Arg1);
					if(fld.Class != classFile.Name)
d2580 4
a2583 1
						return false;
d2585 1
a2585 3
					// don't allow getstatic to load non-primitive fields, because that would
					// cause the verifier to try to load the type
					if(bc == ByteCode.__getstatic && "L[".IndexOf(fld.Signature[0]) != -1)
d2587 5
a2591 1
						return false;
d2594 1
a2594 5
				else if(bc == ByteCode.__areturn ||
					bc == ByteCode.__ireturn ||
					bc == ByteCode.__lreturn ||
					bc == ByteCode.__freturn ||
					bc == ByteCode.__dreturn)
d2596 1
a2596 1
					return false;
d2598 5
a2602 1
				else if(ByteCodeMetaData.CanThrowException(bc))
d2604 25
a2628 1
					return false;
d2631 2
a2632 3
			// the method needs to be verifiable to be side effect free, since we already analysed it,
			// we know that the verifier won't try to load any types (which isn't allowed at this time)
			try
d2634 2
a2635 2
				new MethodAnalyzer(wrapper, null, classFile, m, null);
				return true;
d2637 2
a2638 1
			catch(VerifyError)
d2640 2
a2641 1
				return false;
a2642 1
		}
d2644 1
a2644 3
		private MethodWrapper GetMethodWrapperDuringCtor(TypeWrapper lookup, ArrayList methods, string name, string sig)
		{
			if(lookup == wrapper)
d2646 1
a2646 1
				foreach(MethodWrapper mw in methods)
d2648 1
a2648 1
					if(mw.Name == name && mw.Signature == sig)
d2650 4
a2653 1
						return mw;
d2655 1
d2657 1
a2657 12
				if(lookup.BaseTypeWrapper == null)
				{
					return null;
				}
				else
				{
					return lookup.BaseTypeWrapper.GetMethodWrapper(name, sig, true);
				}
			}
			else
			{
				return lookup.GetMethodWrapper(name, sig, true);
a2658 1
		}
d2660 1
a2660 3
		private void AddMirandaMethods(ArrayList methods, ArrayList baseMethods, TypeWrapper tw)
		{
			foreach(TypeWrapper iface in tw.Interfaces)
d2662 2
a2663 2
				AddMirandaMethods(methods, baseMethods, iface);
				foreach(MethodWrapper ifmethod in iface.GetMethods())
d2665 2
a2666 2
					// skip <clinit>
					if(!ifmethod.IsStatic)
d2668 2
a2669 2
						TypeWrapper lookup = wrapper;
						while(lookup != null)
d2671 9
a2679 2
							MethodWrapper mw = GetMethodWrapperDuringCtor(lookup, methods, ifmethod.Name, ifmethod.Signature);
							if(mw == null)
d2681 5
a2685 4
								mw = new SmartCallMethodWrapper(wrapper, ifmethod.Name, ifmethod.Signature, null, null, null, Modifiers.Public | Modifiers.Abstract, MemberFlags.HideFromReflection | MemberFlags.MirandaMethod, SimpleOpCode.Call, SimpleOpCode.Callvirt);
								methods.Add(mw);
								baseMethods.Add(ifmethod);
								break;
d2687 1
a2687 1
							if(!mw.IsStatic)
d2689 5
a2693 1
								break;
d2695 1
a2695 1
							lookup = mw.DeclaringType.BaseTypeWrapper;
a2699 1
		}
d2701 15
a2715 5
		private static bool CheckInnerOuterNames(string inner, string outer)
		{
			// do some sanity checks on the inner/outer class names
			return inner.Length > outer.Length + 1 && inner[outer.Length] == '$' && inner.IndexOf('$', outer.Length + 1) == -1;
		}
d2717 1
a2717 9
		private static string GetInnerClassName(string outer, string inner)
		{
			Debug.Assert(CheckInnerOuterNames(inner, outer));
			return inner.Substring(outer.Length + 1);
		}

		private static bool IsCompatibleArgList(TypeWrapper[] caller, TypeWrapper[] callee)
		{
			if(caller.Length == callee.Length)
d2719 1
a2719 1
				for(int i = 0; i < caller.Length; i++)
d2721 1
a2721 1
					if(!caller[i].IsAssignableTo(callee[i]))
d2723 1
a2723 1
						return false;
d2726 1
a2726 1
				return true;
a2727 2
			return false;
		}
d2729 1
a2729 4
		private void EmitConstantValueInitialization(ILGenerator ilGenerator)
		{
			ClassFile.Field[] fields = classFile.Fields;
			for(int i = 0; i < fields.Length; i++)
d2731 5
a2735 2
				ClassFile.Field f = fields[i];
				if(f.IsStatic && !f.IsFinal)
d2737 3
a2739 2
					object constant = f.ConstantValue;
					if(constant != null)
d2741 1
a2741 1
						if(constant is int)
d2743 4
a2746 1
							ilGenerator.Emit(OpCodes.Ldc_I4, (int)constant);
d2748 1
a2748 1
						else if(constant is long)
d2750 1
a2750 1
							ilGenerator.Emit(OpCodes.Ldc_I8, (long)constant);
d2752 6
a2757 1
						else if(constant is double)
d2759 11
a2769 9
							ilGenerator.Emit(OpCodes.Ldc_R8, (double)constant);
						}
						else if(constant is float)
						{
							ilGenerator.Emit(OpCodes.Ldc_R4, (float)constant);
						}
						else if(constant is string)
						{
							ilGenerator.Emit(OpCodes.Ldstr, (string)constant);
a2770 5
						else
						{
							throw new InvalidOperationException();
						}
						this.fields[i].EmitSet(ilGenerator);
d2773 9
a2782 1
		}
d2784 1
a2784 3
		internal FieldInfo ClassObjectField
		{
			get
d2786 1
a2786 1
				lock(this)
d2788 1
a2788 1
					if(classObjectField == null)
d2790 1
a2790 2
						classObjectField = typeBuilder.DefineField("__<classObject>", typeof(object), FieldAttributes.Private | FieldAttributes.Static);
						AttributeHelper.HideFromJava((FieldBuilder)classObjectField);
a2791 1
					return classObjectField;
d2793 1
a2794 1
		}
d2796 1
a2796 3
		private int GetMethodIndex(MethodWrapper mw)
		{
			for(int i = 0; i < methods.Length; i++)
d2798 38
a2835 1
				if(methods[i] == mw)
d2837 2
a2838 1
					return i;
d2840 12
a2851 15
			}
			throw new InvalidOperationException();
		}

		internal override MethodBase LinkMethod(MethodWrapper mw)
		{
			Debug.Assert(mw != null);
			bool unloadableOverrideStub = false;
			int index = GetMethodIndex(mw);
			MethodWrapper baseMethod = baseMethods[index];
			if(baseMethod != null)
			{
				baseMethod.Link();
				// check the loader constraints
				if(mw.ReturnType != baseMethod.ReturnType)
d2853 2
a2854 1
					if(baseMethod.ReturnType.IsUnloadable || finishingForDebugSave)
d2856 1
a2856 1
						if(!mw.ReturnType.IsUnloadable || (!baseMethod.ReturnType.IsUnloadable && finishingForDebugSave))
d2858 12
a2869 1
							unloadableOverrideStub = true;
d2872 6
a2877 1
					else
d2879 2
a2880 1
						throw new LinkageError("Loader constraints violated");
d2882 1
a2882 6
				}
				TypeWrapper[] here = mw.GetParameters();
				TypeWrapper[] there = baseMethod.GetParameters();
				for(int i = 0; i < here.Length; i++)
				{
					if(here[i] != there[i])
d2884 18
a2901 1
						if(there[i].IsUnloadable || finishingForDebugSave)
d2903 1
a2903 4
							if(!here[i].IsUnloadable || (!there[i].IsUnloadable && finishingForDebugSave))
							{
								unloadableOverrideStub = true;
							}
d2907 2
a2908 1
							throw new LinkageError("Loader constraints violated");
d2910 4
d2916 15
a2931 10
			Debug.Assert(mw.GetMethod() == null);
			MethodBase mb = GenerateMethod(index, unloadableOverrideStub);
			if((mw.Modifiers & (Modifiers.Synchronized | Modifiers.Static)) == Modifiers.Synchronized)
			{
				// note that constructors cannot be synchronized in Java
				MethodBuilder mbld = (MethodBuilder)mb;
				mbld.SetImplementationFlags(mbld.GetMethodImplementationFlags() | MethodImplAttributes.Synchronized);
			}
			return mb;
		}
d2933 1
a2933 3
		private int GetFieldIndex(FieldWrapper fw)
		{
			for(int i = 0; i < fields.Length; i++)
d2935 5
a2939 1
				if(fields[i] == fw)
d2941 2
a2942 1
					return i;
d2944 1
a2944 63
			}
			throw new InvalidOperationException();
		}

		internal override FieldInfo LinkField(FieldWrapper fw)
		{
			Debug.Assert(fw != null);
			FieldBuilder field;
			ClassFile.Field fld = classFile.Fields[GetFieldIndex(fw)];
			string fieldName = fld.Name;
			TypeWrapper typeWrapper = fw.FieldTypeWrapper;
			Type type = typeWrapper.TypeAsSignatureType;
			bool setNameSig = typeWrapper.IsUnloadable || typeWrapper.IsGhostArray;
			if(setNameSig)
			{
				// TODO use clashtable
				// the field name is mangled here, because otherwise it can (theoretically)
				// conflict with another unloadable or object or ghost array field
				// (fields can be overloaded on type)
				fieldName += "/" + typeWrapper.Name;
			}
			FieldAttributes attribs = 0;
			MethodAttributes methodAttribs = 0;
			bool setModifiers = false;
			if(fld.IsPrivate)
			{
				attribs |= FieldAttributes.Private;
			}
			else if(fld.IsProtected)
			{
				attribs |= FieldAttributes.FamORAssem;
				methodAttribs |= MethodAttributes.FamORAssem;
			}
			else if(fld.IsPublic)
			{
				attribs |= FieldAttributes.Public;
				methodAttribs |= MethodAttributes.Public;
			}
			else
			{
				attribs |= FieldAttributes.Assembly;
				methodAttribs |= MethodAttributes.Assembly;
			}
			if(fld.IsStatic)
			{
				attribs |= FieldAttributes.Static;
				methodAttribs |= MethodAttributes.Static;
			}
			// NOTE "constant" static finals are converted into literals
			// TODO it would be possible for Java code to change the value of a non-blank static final, but I don't
			// know if we want to support this (since the Java JITs don't really support it either)
			object constantValue = fld.ConstantValue;
			if(fld.IsStatic && fld.IsFinal && constantValue != null)
			{
				Profiler.Count("Static Final Constant");
				attribs |= FieldAttributes.Literal;
				field = typeBuilder.DefineField(fieldName, type, attribs);
				field.SetConstant(constantValue);
			}
			else
			{
				bool isWrappedFinal = false;
				if(fld.IsFinal && (fld.IsPublic || fld.IsProtected))
d2946 1
a2946 15
					if(wrapper.IsInterface)
					{
						attribs |= FieldAttributes.InitOnly;
					}
					else
					{
						// NOTE public/protected blank final fields get converted into a read-only property with a private field
						// backing store
						// we used to make the field privatescope, but that really serves no purpose (and it hinders
						// serialization, which uses .NET reflection to get at the field)
						attribs &= ~FieldAttributes.FieldAccessMask;
						attribs |= FieldAttributes.Private;
						setModifiers = true;
						isWrappedFinal = true;
					}
d2948 1
a2948 1
				else if(fld.IsFinal)
d2950 1
a2950 1
					setModifiers = true;
d2952 11
a2962 2
				field = typeBuilder.DefineField(fieldName, type, attribs);
				if(fld.IsTransient)
d2964 1
a2964 2
					CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(typeof(NonSerializedAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
					field.SetCustomAttribute(transientAttrib);
d2966 5
a2970 1
				if(fld.IsVolatile)
d2972 1
a2972 2
					// TODO the field should be marked as modreq(IsVolatile), but Reflection.Emit doesn't have a way of doing this
					setModifiers = true;
d2974 1
a2974 3
				// Instance fields can also have a ConstantValue attribute (and are inlined by the compiler),
				// and ikvmstub has to export them, so we have to add a custom attribute.
				if(constantValue != null)
d2976 1
a2976 2
					CustomAttributeBuilder constantValueAttrib = new CustomAttributeBuilder(typeof(ConstantValueAttribute).GetConstructor(new Type[] { constantValue.GetType() }), new object[] { constantValue });
					field.SetCustomAttribute(constantValueAttrib);
d2978 3
a2980 1
				if(isWrappedFinal)
d2982 1
a2982 18
					methodAttribs |= MethodAttributes.SpecialName;
					// TODO we should ensure that the getter method name doesn't clash with an existing method
					MethodBuilder getter = typeBuilder.DefineMethod("get_" + fld.Name, methodAttribs, CallingConventions.Standard, type, Type.EmptyTypes);
					AttributeHelper.HideFromJava(getter);
					ILGenerator ilgen = getter.GetILGenerator();
					if(fld.IsStatic)
					{
						ilgen.Emit(OpCodes.Ldsfld, field);
					}
					else
					{
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Ldfld, field);
					}
					ilgen.Emit(OpCodes.Ret);
					PropertyBuilder pb = typeBuilder.DefineProperty(fld.Name, PropertyAttributes.None, type, Type.EmptyTypes);
					pb.SetGetMethod(getter);
					((GetterFieldWrapper)fw).SetGetter(getter);
d2984 2
a2985 77
			}
			// if the Java modifiers cannot be expressed in .NET, we emit the Modifiers attribute to store
			// the Java modifiers
			if(setModifiers)
			{
				AttributeHelper.SetModifiers(field, fld.Modifiers);
			}
			if(setNameSig)
			{
				AttributeHelper.SetNameSig(field, fld.Name, fld.Signature);
			}
			if(JVM.IsStaticCompiler && fld.DeprecatedAttribute)
			{
				AttributeHelper.SetDeprecatedAttribute(field);
			}
			return field;
		}

		internal override DynamicImpl Finish(bool forDebugSave)
		{
			this.finishingForDebugSave = forDebugSave;
			// NOTE if a finish is triggered during static compilation phase 1, it cannot be handled properly,
			// so we bail out.
			// (this should only happen during compilation of classpath.dll and is most likely caused by a bug somewhere)
			if(JVM.IsStaticCompilerPhase1)
			{
				JVM.CriticalFailure("Finish triggered during phase 1 of compilation.", null);
				return null;
			}
			if(wrapper.BaseTypeWrapper != null)
			{
				wrapper.BaseTypeWrapper.Finish(forDebugSave);
			}
			if(outerClassWrapper != null)
			{
				outerClassWrapper.Finish(forDebugSave);
			}
			// NOTE there is a bug in the CLR (.NET 1.0 & 1.1 [1.2 is not yet available]) that
			// causes the AppDomain.TypeResolve event to receive the incorrect type name for nested types.
			// The Name in the ResolveEventArgs contains only the nested type name, not the full type name,
			// for example, if the type being resolved is "MyOuterType+MyInnerType", then the event only
			// receives "MyInnerType" as the name. Since we only compile inner classes as nested types
			// when we're statically compiling, we can only run into this bug when we're statically compiling.
			// NOTE To work around this bug, we have to make sure that all types that are going to be
			// required in finished form, are finished explicitly here. It isn't clear what other types are
			// required to be finished. I instrumented a static compilation of classpath.dll and this
			// turned up no other cases of the TypeResolve event firing.
			for(int i = 0; i < wrapper.Interfaces.Length; i++)
			{
				wrapper.Interfaces[i].Finish(forDebugSave);
			}
			// make sure all classes are loaded, before we start finishing the type. During finishing, we
			// may not run any Java code, because that might result in a request to finish the type that we
			// are in the process of finishing, and this would be a problem.
			classFile.Link(wrapper, classCache);
			for(int i = 0; i < fields.Length; i++)
			{
				fields[i].Link();
			}
			for(int i = 0; i < methods.Length; i++)
			{
				methods[i].Link();
			}
			// it is possible that the loading of the referenced classes triggered a finish of us,
			// if that happens, we just return
			if(finishedType != null)
			{
				return finishedType;
			}
			Profiler.Enter("JavaTypeImpl.Finish.Core");
			try
			{
				TypeWrapper declaringTypeWrapper = null;
				TypeWrapper[] innerClassesTypeWrappers = TypeWrapper.EmptyArray;
				// if we're an inner class, we need to attach an InnerClass attribute
				ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
				if(innerclasses != null)
d2987 9
a2995 5
					// TODO consider not pre-computing innerClassesTypeWrappers and declaringTypeWrapper here
					ArrayList wrappers = new ArrayList();
					for(int i = 0; i < innerclasses.Length; i++)
					{
						if(innerclasses[i].innerClass != 0 && innerclasses[i].outerClass != 0)
d2997 1
a2997 1
							if(classFile.GetConstantPoolClassType(innerclasses[i].outerClass) == wrapper)
d2999 13
a3011 10
								wrappers.Add(classFile.GetConstantPoolClassType(innerclasses[i].innerClass));
							}
							if(classFile.GetConstantPoolClassType(innerclasses[i].innerClass) == wrapper)
							{
								declaringTypeWrapper = classFile.GetConstantPoolClassType(innerclasses[i].outerClass);
								AttributeHelper.SetInnerClass(typeBuilder,
									classFile.GetConstantPoolClass(innerclasses[i].innerClass),
									classFile.GetConstantPoolClass(innerclasses[i].outerClass),
									innerclasses[i].name == 0 ? null : classFile.GetConstantPoolUtf8String(innerclasses[i].name),
									innerclasses[i].accessFlags);
d3014 1
d3016 22
a3037 23
					innerClassesTypeWrappers = (TypeWrapper[])wrappers.ToArray(typeof(TypeWrapper));
				}
				wrapper.FinishGhost(typeBuilder, methods);
				// if we're not abstract make sure we don't inherit any abstract methods
				if(!wrapper.IsAbstract)
				{
					TypeWrapper parent = wrapper.BaseTypeWrapper;
					// if parent is not abstract, the .NET implementation will never have abstract methods (only
					// stubs that throw AbstractMethodError)
					// NOTE interfaces are supposed to be abstract, but the VM doesn't enforce this, so
					// we have to check for a null parent (interfaces have no parent).
					while(parent != null && parent.IsAbstract)
					{
						foreach(MethodWrapper mw in parent.GetMethods())
						{
							MethodInfo mi = mw.GetMethod() as MethodInfo;
							if(mi != null && mi.IsAbstract && wrapper.GetMethodWrapper(mw.Name, mw.Signature, true).IsAbstract)
							{
								// NOTE in Sun's JRE 1.4.1 this method cannot be overridden by subclasses,
								// but I think this is a bug, so we'll support it anyway.
								MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & ~(MethodAttributes.Abstract|MethodAttributes.NewSlot), CallingConventions.Standard, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
								AttributeHelper.HideFromJava(mb);
								EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + mw.Name + mw.Signature);
d3039 1
a3040 1
						parent = parent.BaseTypeWrapper;
d3042 4
a3045 9
				}
				string verifyError = null;
				bool basehasclinit = wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasStaticInitializer;
				bool hasclinit = false;
				for(int i = 0; i < classFile.Methods.Length; i++)
				{
					ClassFile.Method m = classFile.Methods[i];
					MethodBase mb = methods[i].GetMethod();
					if(mb is ConstructorBuilder)
d3047 3
a3049 3
						ILGenerator ilGenerator = ((ConstructorBuilder)mb).GetILGenerator();
						Tracer.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
						if(basehasclinit && m.IsClassInitializer && !classFile.IsInterface)
d3051 3
a3053 14
							hasclinit = true;
							// before we call the base class initializer, we need to set the non-final static ConstantValue fields
							EmitConstantValueInitialization(ilGenerator);
							EmitHelper.RunClassConstructor(ilGenerator, Type.BaseType);
						}
						Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref verifyError);
					}
					else
					{
						if(m.IsAbstract)
						{
							// NOTE in the JVM it is apparently legal for a non-abstract class to have abstract methods, but
							// the CLR doens't allow this, so we have to emit a method that throws an AbstractMethodError
							if(!classFile.IsAbstract)
d3055 4
a3058 3
								ILGenerator ilGenerator = ((MethodBuilder)mb).GetILGenerator();
								Tracer.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
								EmitHelper.Throw(ilGenerator, "java.lang.AbstractMethodError", classFile.Name + "." + m.Name + m.Signature);
d3060 1
d3062 1
a3062 1
						else if(m.IsNative)
d3064 1
a3064 1
							if((mb.Attributes & MethodAttributes.PinvokeImpl) != 0)
d3066 8
a3073 1
								continue;
d3075 1
a3075 2
							Profiler.Enter("JavaTypeImpl.Finish.Native");
							try
d3077 1
a3077 4
								ILGenerator ilGenerator = ((MethodBuilder)mb).GetILGenerator();
								Tracer.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
								// do we have a native implementation in map.xml?
								if(wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
d3081 2
a3082 5
								// see if there exists a IKVM.NativeCode class for this type
								Type nativeCodeType = Type.GetType("IKVM.NativeCode." + classFile.Name.Replace('$', '+'));
								MethodInfo nativeMethod = null;
								TypeWrapper[] args = methods[i].GetParameters();
								if(nativeCodeType != null)
d3084 4
a3087 2
									TypeWrapper[] nargs = args;
									if(!m.IsStatic)
d3089 1
a3089 3
										nargs = new TypeWrapper[args.Length + 1];
										args.CopyTo(nargs, 1);
										nargs[0] = this.wrapper;
d3091 5
a3095 2
									MethodInfo[] nativeCodeTypeMethods = nativeCodeType.GetMethods(BindingFlags.Static | BindingFlags.Public);
									foreach(MethodInfo method in nativeCodeTypeMethods)
d3097 2
a3098 3
										ParameterInfo[] param = method.GetParameters();
										TypeWrapper[] match = new TypeWrapper[param.Length];
										for(int j = 0; j < param.Length; j++)
d3100 3
a3102 1
											match[j] = ClassLoaderWrapper.GetWrapperFromType(param[j].ParameterType);
d3104 2
a3105 1
										if(m.Name == method.Name && IsCompatibleArgList(nargs, match))
d3107 12
a3118 3
											// TODO instead of taking the first matching method, we should find the best one
											nativeMethod = method;
											break;
d3121 1
a3121 5
								}
								if(nativeMethod != null)
								{
									int add = 0;
									if(!m.IsStatic)
d3123 17
a3139 22
										ilGenerator.Emit(OpCodes.Ldarg_0);
										add = 1;
									}
									for(int j = 0; j < args.Length; j++)
									{
										ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
									}
									ilGenerator.Emit(OpCodes.Call, nativeMethod);
									TypeWrapper retTypeWrapper = methods[i].ReturnType;
									if(!retTypeWrapper.TypeAsTBD.Equals(nativeMethod.ReturnType) && !retTypeWrapper.IsGhost)
									{
										ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
									}
									ilGenerator.Emit(OpCodes.Ret);
								}
								else
								{
									if(JVM.NoJniStubs)
									{
										// since NoJniStubs can only be set when we're statically compiling, it is safe to use the "compiler" trace switch
										Tracer.Warning(Tracer.Compiler, "Native method not implemented: {0}.{1}.{2}", classFile.Name, m.Name, m.Signature);
										EmitHelper.Throw(ilGenerator, "java.lang.UnsatisfiedLinkError", "Native method not implemented (compiled with -nojni): " + classFile.Name + "." + m.Name + m.Signature);
d3143 1
a3143 1
										if(ClassLoaderWrapper.IsSaveDebugImage)
d3145 3
a3147 1
											JniProxyBuilder.Generate(ilGenerator, wrapper, methods[i], typeBuilder, classFile, m, args);
d3151 8
a3158 1
											JniBuilder.Generate(ilGenerator, wrapper, methods[i], typeBuilder, classFile, m, args, false);
d3162 4
d3167 1
a3167 1
							finally
d3169 13
a3181 17
								Profiler.Leave("JavaTypeImpl.Finish.Native");
							}
						}
						else
						{
							MethodBuilder mbld = (MethodBuilder)mb;
							ILGenerator ilGenerator = mbld.GetILGenerator();
							Tracer.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
							if(wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
							{
								continue;
							}
							bool nonleaf = false;
							Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref verifyError, ref nonleaf);
							if(nonleaf)
							{
								mbld.SetImplementationFlags(mbld.GetMethodImplementationFlags() | MethodImplAttributes.NoInlining);
d3185 2
a3186 6
				}
				// NOTE non-final fields aren't allowed in interfaces so we don't have to initialize constant fields
				if(!classFile.IsInterface)
				{
					// if we don't have a <clinit> we may need to inject one
					if(!hasclinit)
d3188 2
a3189 2
						bool hasconstantfields = false;
						if(!basehasclinit)
d3191 2
a3192 1
							foreach(ClassFile.Field f in classFile.Fields)
d3194 1
a3194 1
								if(f.IsStatic && !f.IsFinal && f.ConstantValue != null)
d3196 5
a3200 2
									hasconstantfields = true;
									break;
d3203 1
a3203 8
						}
						if(basehasclinit || hasconstantfields)
						{
							ConstructorBuilder cb = DefineClassInitializer();
							AttributeHelper.HideFromJava(cb);
							ILGenerator ilGenerator = cb.GetILGenerator();
							EmitConstantValueInitialization(ilGenerator);
							if(basehasclinit)
d3205 9
a3213 1
								EmitHelper.RunClassConstructor(ilGenerator, Type.BaseType);
a3214 1
							ilGenerator.Emit(OpCodes.Ret);
a3215 1
					}
d3217 8
a3224 12
					// here we loop thru all the interfaces to explicitly implement any methods that we inherit from
					// base types that may have a different name from the name in the interface
					// (e.g. interface that has an equals() method that should override System.Object.Equals())
					// also deals with interface methods that aren't implemented (generate a stub that throws AbstractMethodError)
					// and with methods that aren't public (generate a stub that throws IllegalAccessError)
					Hashtable doneSet = new Hashtable();
					TypeWrapper[] interfaces = wrapper.Interfaces;
					for(int i = 0; i < interfaces.Length; i++)
					{
						// if we implement a ghost interface, add an implicit conversion to the ghost reference value type
						// TODO do this for indirectly implemented interfaces (interfaces implemented by interfaces) as well
						if(interfaces[i].IsGhost)
d3226 16
a3241 10
							MethodBuilder mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, interfaces[i].TypeAsSignatureType, new Type[] { wrapper.TypeAsSignatureType });
							AttributeHelper.HideFromJava(mb);
							ILGenerator ilgen = mb.GetILGenerator();
							LocalBuilder local = ilgen.DeclareLocal(interfaces[i].TypeAsSignatureType);
							ilgen.Emit(OpCodes.Ldloca, local);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Stfld, interfaces[i].GhostRefField);
							ilgen.Emit(OpCodes.Ldloca, local);
							ilgen.Emit(OpCodes.Ldobj, interfaces[i].TypeAsSignatureType);
							ilgen.Emit(OpCodes.Ret);
d3243 4
a3246 8
						interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
					}
					// if any of our base classes has an incomplete interface implementation we need to look through all
					// the base class interfaces to see if we've got an implementation now
					TypeWrapper baseTypeWrapper = wrapper.BaseTypeWrapper;
					while(baseTypeWrapper.HasIncompleteInterfaceImplementation)
					{
						for(int i = 0; i < baseTypeWrapper.Interfaces.Length; i++)
d3248 5
a3252 1
							baseTypeWrapper.Interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
d3254 1
a3254 5
						baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
					}
					foreach(MethodWrapper mw in methods)
					{
						if(mw.Name != "<init>" && !mw.IsStatic && !mw.IsPrivate)
d3256 1
a3256 1
							if(wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasIncompleteInterfaceImplementation)
d3258 14
a3271 3
								Hashtable hashtable = null;
								TypeWrapper tw = wrapper.BaseTypeWrapper;
								while(tw.HasIncompleteInterfaceImplementation)
d3273 28
a3300 6
									foreach(TypeWrapper iface in tw.Interfaces)
									{
										AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Name, mw.Signature, ref hashtable, false);
									}
									tw = tw.BaseTypeWrapper;
								}
d3302 1
a3302 1
							if(true)
d3304 3
a3306 2
								Hashtable hashtable = null;
								foreach(TypeWrapper iface in wrapper.Interfaces)
d3308 1
a3308 1
									AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Name, mw.Signature, ref hashtable, true);
d3310 2
d3314 4
a3318 1
				}
d3320 6
a3325 11
				// If we're an interface that has public/protected fields, we create an inner class
				// to expose these fields to C# (which stubbornly refuses to see fields in interfaces).
				TypeBuilder tbFields = null;
				if(JVM.IsStaticCompiler && classFile.IsInterface && !wrapper.IsGhost && classFile.Fields.Length > 0)
				{
					// TODO handle name clash
					tbFields = typeBuilder.DefineNestedType("__Fields", TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed);
					tbFields.DefineDefaultConstructor(MethodAttributes.Private);
					AttributeHelper.HideFromJava(tbFields);
					ILGenerator ilgenClinit = null;
					foreach(ClassFile.Field f in classFile.Fields)
d3327 2
a3328 2
						TypeWrapper typeWrapper = ClassFile.FieldTypeWrapperFromSig(wrapper.GetClassLoader(), classCache, f.Signature);
						if(f.ConstantValue != null)
d3330 1
a3330 14
							FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal;
							FieldBuilder fb = tbFields.DefineField(f.Name, typeWrapper.TypeAsSignatureType, attribs);
							fb.SetConstant(f.ConstantValue);
						}
						else
						{
							FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.InitOnly;
							FieldBuilder fb = tbFields.DefineField(f.Name, typeWrapper.TypeAsSignatureType, attribs);
							if(ilgenClinit == null)
							{
								ilgenClinit = tbFields.DefineTypeInitializer().GetILGenerator();
							}
							wrapper.GetFieldWrapper(f.Name, f.Signature).EmitGet(ilgenClinit);
							ilgenClinit.Emit(OpCodes.Stsfld, fb);
d3332 5
d3338 2
a3339 1
					if(ilgenClinit != null)
d3341 1
a3341 1
						ilgenClinit.Emit(OpCodes.Ret);
d3343 1
a3343 11
				}

				// See if there is any additional metadata
				wrapper.EmitMapXmlMetadata(typeBuilder, classFile, fields, methods);

				Type type;
				Profiler.Enter("TypeBuilder.CreateType");
				try
				{
					type = typeBuilder.CreateType();
					if(tbFields != null)
d3345 3
a3347 1
						tbFields.CreateType();
a3348 1
					BakedTypeCleanupHack.Process(wrapper);
d3350 1
a3350 1
				finally
d3352 2
a3353 1
					Profiler.Leave("TypeBuilder.CreateType");
d3355 1
a3355 6
				ClassLoaderWrapper.SetWrapperForType(type, wrapper);
				if(verifyError != null)
				{
					return new DoomedTypeImpl(verifyError);
				}
				else
d3357 1
a3357 3
					wrapper.FinishGhostStep2();
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, this.ReflectiveModifiers);
					return finishedType;
a3359 15
			catch(Exception x)
			{
				JVM.CriticalFailure("Exception during finishing of: " + wrapper.Name, x);
				return null;
			}
			finally
			{
				Profiler.Leave("JavaTypeImpl.Finish.Core");
			}
		}

		internal class JniProxyBuilder
		{
			private static ModuleBuilder mod;
			private static int count;
d3361 1
a3361 1
			static JniProxyBuilder()
d3363 2
a3364 2
				mod = ((AssemblyBuilder)ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder.Assembly).DefineDynamicModule("jniproxy.dll", "jniproxy.dll");
			}
d3366 1
a3366 6
			internal static void Generate(ILGenerator ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args)
			{
				TypeBuilder tb = mod.DefineType("class" + (count++), TypeAttributes.Public | TypeAttributes.Class);
				int instance = m.IsStatic ? 0 : 1;
				Type[] argTypes = new Type[args.Length + instance + 1];
				if(instance != 0)
d3368 1
a3368 1
					argTypes[0] = wrapper.TypeAsSignatureType;
d3370 2
a3371 1
				for(int i = 0; i < args.Length; i++)
d3373 27
a3399 1
					argTypes[i + instance] = args[i].TypeAsSignatureType;
a3400 16
				argTypes[argTypes.Length - 1] = typeof(RuntimeMethodHandle);
				MethodBuilder mb = tb.DefineMethod("method", MethodAttributes.Public | MethodAttributes.Static, mw.ReturnType.TypeAsSignatureType, argTypes);
				JniBuilder.Generate(mb.GetILGenerator(), wrapper, mw, tb, classFile, m, args, true);
				for(int i = 0; i < argTypes.Length - 1; i++)
				{
					ilGenerator.Emit(OpCodes.Ldarg, (short)i);
				}
				ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
				ilGenerator.Emit(OpCodes.Call, mb);
				ilGenerator.Emit(OpCodes.Ret);
				Type type = tb.CreateType();
				// HACK since we're creating a type in the dynamic assembly, we must also register its wrapper,
				// because the ClassLoaderWrapper assumes that all dynamic types are in its hashtable,
				// but note that this only registers it for reverse lookup (from Type -> TypeWrapper), this
				// is necessary to make stack walking work.
				ClassLoaderWrapper.SetWrapperForType(type, CompiledTypeWrapper.newInstance(type.FullName, type));
a3401 1
		}
d3403 44
a3446 79
		private class JniBuilder
		{
			private static readonly Type localRefStructType = typeof(IKVM.Runtime.JNI.Frame);
			private static readonly MethodInfo jniFuncPtrMethod = localRefStructType.GetMethod("GetFuncPtr");
			private static readonly MethodInfo enterLocalRefStruct = localRefStructType.GetMethod("Enter");
			private static readonly MethodInfo leaveLocalRefStruct = localRefStructType.GetMethod("Leave");
			private static readonly MethodInfo makeLocalRef = localRefStructType.GetMethod("MakeLocalRef");
			private static readonly MethodInfo unwrapLocalRef = localRefStructType.GetMethod("UnwrapLocalRef");
			private static readonly MethodInfo getClassFromTypeHandle = typeof(ByteCodeHelper).GetMethod("GetClassFromTypeHandle");
			private static readonly MethodInfo writeLine = typeof(Console).GetMethod("WriteLine", new Type[] { typeof(object) }, null);
			private static readonly MethodInfo monitorEnter = typeof(System.Threading.Monitor).GetMethod("Enter", new Type[] { typeof(object) });
			private static readonly MethodInfo monitorExit = typeof(System.Threading.Monitor).GetMethod("Exit", new Type[] { typeof(object) });

			internal static void Generate(ILGenerator ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args, bool thruProxy)
			{
				LocalBuilder syncObject = null;
				FieldInfo classObjectField;
				if(thruProxy)
				{
					classObjectField = typeBuilder.DefineField("__<classObject>", typeof(object), FieldAttributes.Static | FieldAttributes.Private);
				}
				else
				{
					classObjectField = wrapper.ClassObjectField;
				}
				if(m.IsSynchronized && m.IsStatic)
				{
					ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
					Label label = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Brtrue_S, label);
					ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
					ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandle);
					ilGenerator.Emit(OpCodes.Stsfld, classObjectField);
					ilGenerator.MarkLabel(label);
					ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
					ilGenerator.Emit(OpCodes.Dup);
					syncObject = ilGenerator.DeclareLocal(typeof(object));
					ilGenerator.Emit(OpCodes.Stloc, syncObject);
					ilGenerator.Emit(OpCodes.Call, monitorEnter);
					ilGenerator.BeginExceptionBlock();
				}
				string sig = m.Signature.Replace('.', '/');
				FieldBuilder methodPtr = typeBuilder.DefineField(JNI.METHOD_PTR_FIELD_PREFIX + m.Name + sig, typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
				LocalBuilder localRefStruct = ilGenerator.DeclareLocal(localRefStructType);
				ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
				ilGenerator.Emit(OpCodes.Initobj, localRefStructType);
				ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
				Label oklabel = ilGenerator.DefineLabel();
				ilGenerator.Emit(OpCodes.Brtrue, oklabel);
				if(thruProxy)
				{
					ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(args.Length + (mw.IsStatic ? 0 : 1)));
				}
				else
				{
					ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
				}
				ilGenerator.Emit(OpCodes.Ldstr, classFile.Name.Replace('.', '/'));
				ilGenerator.Emit(OpCodes.Ldstr, m.Name);
				ilGenerator.Emit(OpCodes.Ldstr, sig);
				ilGenerator.Emit(OpCodes.Call, jniFuncPtrMethod);
				ilGenerator.Emit(OpCodes.Stsfld, methodPtr);
				ilGenerator.MarkLabel(oklabel);
				ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
				if(thruProxy)
				{
					ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(args.Length + (mw.IsStatic ? 0 : 1)));
				}
				else
				{
					ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
				}
				ilGenerator.Emit(OpCodes.Call, enterLocalRefStruct);
				LocalBuilder jnienv = ilGenerator.DeclareLocal(typeof(IntPtr));
				ilGenerator.Emit(OpCodes.Stloc, jnienv);
				TypeWrapper retTypeWrapper = mw.ReturnType;
				if(!retTypeWrapper.IsUnloadable && !retTypeWrapper.IsPrimitive)
				{
					// this one is for use after we return from "calli"
d3448 18
a3465 19
				}
				ilGenerator.Emit(OpCodes.Ldloc, jnienv);
				Type[] modargs = new Type[args.Length + 2];
				modargs[0] = typeof(IntPtr);
				modargs[1] = typeof(IntPtr);
				for(int i = 0; i < args.Length; i++)
				{
					modargs[i + 2] = args[i].TypeAsSignatureType;
				}
				int add = 0;
				if(!m.IsStatic)
				{
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					ilGenerator.Emit(OpCodes.Ldarg_0);
					ilGenerator.Emit(OpCodes.Call, makeLocalRef);
					add = 1;
				}
				else
				{
d3467 36
d3504 8
a3511 8
					ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
					Label label = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Brtrue_S, label);
					ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
					ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandle);
					ilGenerator.Emit(OpCodes.Stsfld, classObjectField);
					ilGenerator.MarkLabel(label);
					ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
d3513 3
a3515 5
					ilGenerator.Emit(OpCodes.Call, makeLocalRef);
				}
				for(int j = 0; j < args.Length; j++)
				{
					if(args[j].IsUnloadable || !args[j].IsPrimitive)
d3517 1
a3517 2
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						if(!args[j].IsUnloadable && args[j].IsNonPrimitiveValueType)
d3519 17
a3535 7
							ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
							args[j].EmitBox(ilGenerator);
						}
						else if(!args[j].IsUnloadable && args[j].IsGhost)
						{
							ilGenerator.Emit(OpCodes.Ldarga_S, (byte)(j + add));
							ilGenerator.Emit(OpCodes.Ldfld, args[j].GhostRefField);
d3541 10
a3550 2
						ilGenerator.Emit(OpCodes.Call, makeLocalRef);
						modargs[j + 2] = typeof(IntPtr);
d3554 1
a3554 1
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
d3556 3
a3558 20
				}
				ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
				Type realRetType;
				if(retTypeWrapper == PrimitiveTypeWrapper.BOOLEAN)
				{
					realRetType = typeof(byte);
				}
				else if(retTypeWrapper.IsPrimitive)
				{
					realRetType = retTypeWrapper.TypeAsSignatureType;
				}
				else
				{
					realRetType = typeof(IntPtr);
				}
				ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, realRetType, modargs);
				LocalBuilder retValue = null;
				if(retTypeWrapper != PrimitiveTypeWrapper.VOID)
				{
					if(!retTypeWrapper.IsUnloadable && !retTypeWrapper.IsPrimitive)
d3560 1
a3560 2
						ilGenerator.Emit(OpCodes.Call, unwrapLocalRef);
						if(retTypeWrapper.IsNonPrimitiveValueType)
d3562 19
a3580 15
							retTypeWrapper.EmitUnbox(ilGenerator);
						}
						else if(retTypeWrapper.IsGhost)
						{
							LocalBuilder ghost = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
							LocalBuilder obj = ilGenerator.DeclareLocal(typeof(object));
							ilGenerator.Emit(OpCodes.Stloc, obj);
							ilGenerator.Emit(OpCodes.Ldloca, ghost);
							ilGenerator.Emit(OpCodes.Ldloc, obj);
							ilGenerator.Emit(OpCodes.Stfld, retTypeWrapper.GhostRefField);
							ilGenerator.Emit(OpCodes.Ldloc, ghost);
						}
						else
						{
							ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
d3582 2
d3585 4
a3588 13
					retValue = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
					ilGenerator.Emit(OpCodes.Stloc, retValue);
				}
				ilGenerator.BeginCatchBlock(typeof(object));
				ilGenerator.EmitWriteLine("*** exception in native code ***");
				ilGenerator.Emit(OpCodes.Call, writeLine);
				ilGenerator.Emit(OpCodes.Rethrow);
				ilGenerator.BeginFinallyBlock();
				ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
				ilGenerator.Emit(OpCodes.Call, leaveLocalRefStruct);
				ilGenerator.EndExceptionBlock();
				if(m.IsSynchronized && m.IsStatic)
				{
d3590 2
a3591 2
					ilGenerator.Emit(OpCodes.Ldloc, syncObject);
					ilGenerator.Emit(OpCodes.Call, monitorExit);
d3593 12
a3605 5
				if(retTypeWrapper != PrimitiveTypeWrapper.VOID)
				{
					ilGenerator.Emit(OpCodes.Ldloc, retValue);
				}
				ilGenerator.Emit(OpCodes.Ret);
a3606 1
		}
d3608 1
a3608 3
		internal override TypeWrapper[] InnerClasses
		{
			get
d3610 4
a3613 1
				throw new InvalidOperationException("InnerClasses is only available for finished types");
a3614 1
		}
d3616 1
a3616 3
		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
d3618 4
a3621 1
				throw new InvalidOperationException("DeclaringTypeWrapper is only available for finished types");
a3622 1
		}
d3624 1
a3624 3
		internal override Modifiers ReflectiveModifiers
		{
			get
d3626 1
a3626 2
				ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
				if(innerclasses != null)
d3628 2
a3629 1
					for(int i = 0; i < innerclasses.Length; i++)
d3631 1
a3631 1
						if(innerclasses[i].innerClass != 0)
d3633 1
a3633 1
							if(classFile.GetConstantPoolClass(innerclasses[i].innerClass) == wrapper.Name)
d3635 4
a3638 1
								return innerclasses[i].accessFlags;
d3642 1
a3643 1
				return classFile.Modifiers;
a3644 1
		}
d3646 1
a3646 3
		private void UpdateClashTable()
		{
			lock(this)
d3648 1
a3648 1
				if(memberclashtable == null)
d3650 1
a3650 2
					memberclashtable = new Hashtable();
					for(int i = 0; i < methods.Length; i++)
d3652 2
a3653 3
						// TODO at the moment we don't support constructor signature clash resolving, so we better
						// not put them in the clash table
						if(methods[i].IsLinked && methods[i].Name != "<init>")
d3655 7
a3661 2
							string key = GenerateClashKey("method", methods[i].RealName, methods[i].ReturnTypeForDefineMethod, methods[i].GetParametersForDefineMethod());
							memberclashtable.Add(key, key);
a3665 1
		}
d3667 1
a3667 5
		private static string GenerateClashKey(string type, string name, Type retOrFieldType, Type[] args)
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder(type);
			sb.Append(':').Append(name).Append(':').Append(retOrFieldType.FullName);
			if(args != null)
d3669 3
a3671 1
				foreach(Type t in args)
d3673 4
a3676 1
					sb.Append(':').Append(t.FullName);
d3678 1
a3679 27
			return sb.ToString();
		}

		private ConstructorBuilder DefineClassInitializer()
		{
			if(!classFile.IsFinal && !classFile.IsInterface && wrapper.HasStaticInitializer)
			{
				// We create a field that the derived classes can access in their .cctor to trigger our .cctor
				// (previously we used RuntimeHelpers.RunClassConstructor, but that is slow and requires additional privileges)
				FieldBuilder field = typeBuilder.DefineField("__<clinit>", typeof(int), FieldAttributes.SpecialName | FieldAttributes.Family | FieldAttributes.Static);
				AttributeHelper.HideFromJava(field);
			}
			if(typeBuilder.IsInterface)
			{
				// LAMESPEC the ECMA spec says (part. I, sect. 8.5.3.2) that all interface members must be public, so we make
				// the class constructor public
				return typeBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
			}
			// NOTE we don't need to record the modifiers here, because they aren't visible from Java reflection
			return typeBuilder.DefineTypeInitializer();
		}

		// this finds the method that md is going to be overriding
		private MethodWrapper FindBaseMethod(string name, string sig, out bool explicitOverride)
		{
			Debug.Assert(!classFile.IsInterface);
			Debug.Assert(name != "<init>");
d3681 1
a3681 3
			explicitOverride = false;
			TypeWrapper tw = wrapper.BaseTypeWrapper;
			while(tw != null)
d3683 1
a3683 3
				// TODO we need to handle static methods (duh!)
				MethodWrapper baseMethod = tw.GetMethodWrapper(name, sig, true);
				if(baseMethod == null)
d3685 4
a3688 1
					return null;
d3690 1
a3690 3
				// here are the complex rules for determining whether this method overrides the method we found
				// RULE 1: final methods may not be overridden
				if(baseMethod.IsFinal && !baseMethod.IsPrivate)
d3692 3
a3694 1
					throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + tw.Name + " is overriden in " + wrapper.Name);
d3696 13
a3708 3
				// RULE 2: public & protected methods can be overridden (package methods are handled by RULE 4)
				// (by public, protected & *package* methods [even if they are in a different package])
				if(baseMethod.IsPublic || baseMethod.IsProtected)
d3710 3
a3712 3
					// if we already encountered a package method, we cannot override the base method of
					// that package method
					if(explicitOverride)
a3713 1
						explicitOverride = false;
d3716 21
a3736 7
					return baseMethod;
				}
				// RULE 3: private methods are ignored
				if(!baseMethod.IsPrivate)
				{
					// RULE 4: package methods can only be overridden in the same package
					if(baseMethod.DeclaringType.IsInSamePackageAs(wrapper))
d3738 10
a3747 1
						return baseMethod;
d3749 1
a3749 5
					// since we encountered a method with the same name/signature that we aren't overriding,
					// we need to specify an explicit override
					// NOTE we only do this if baseMethod isn't private, because if it is, Reflection.Emit
					// will complain about the explicit MethodOverride (possibly a bug)
					explicitOverride = true;
d3751 1
a3751 1
				tw = baseMethod.DeclaringType.BaseTypeWrapper;
a3752 2
			return null;
		}
d3754 1
a3754 6
		internal string GenerateUniqueMethodName(string basename, MethodWrapper mw)
		{
			string name = basename;
			string key = GenerateClashKey("method", name, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
			UpdateClashTable();
			lock(memberclashtable.SyncRoot)
d3756 4
a3759 1
				for(int clashcount = 0; memberclashtable.ContainsKey(key); clashcount++)
d3761 6
a3766 2
					name = basename + "_" + clashcount;
					key = GenerateClashKey("method", name, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
d3768 1
a3768 1
				memberclashtable.Add(key, key);
a3769 2
			return name;
		}
d3771 1
a3771 5
		private MethodBase GenerateMethod(int index, bool unloadableOverrideStub)
		{
			methods[index].AssertLinked();
			Profiler.Enter("JavaTypeImpl.GenerateMethod");
			try
d3773 3
a3775 1
				if(index >= classFile.Methods.Length)
d3777 1
a3777 7
					// We're a Miranda method
					Debug.Assert(baseMethods[index].DeclaringType.IsInterface);
					string name = GenerateUniqueMethodName(methods[index].Name, baseMethods[index]);
					// TODO if the interface is not public, we probably shouldn't make the Miranda method public
					MethodBuilder mb = typeBuilder.DefineMethod(methods[index].Name, MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride, baseMethods[index].ReturnTypeForDefineMethod, baseMethods[index].GetParametersForDefineMethod());
					AttributeHelper.MirandaMethod(mb);
					if(unloadableOverrideStub || name != methods[index].Name)
d3779 18
a3796 54
						// instead of creating an override stub, we created the Miranda method with the proper signature and
						// decorate it with a NameSigAttribute that contains the real signature
						AttributeHelper.SetNameSig(mb, methods[index].Name, methods[index].Signature);
					}
					// if we changed the name or if the interface method name is remapped, we need to add an explicit methodoverride.
					if(name != baseMethods[index].RealName)
					{
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethods[index].GetMethod());
					}
					return mb;
				}
				ClassFile.Method m = classFile.Methods[index];
				MethodBase method;
				bool setNameSig = methods[index].ReturnType.IsUnloadable || methods[index].ReturnType.IsGhostArray;
				foreach(TypeWrapper tw in methods[index].GetParameters())
				{
					setNameSig |= tw.IsUnloadable || tw.IsGhostArray;
				}
				bool setModifiers = false;
				MethodAttributes attribs = 0;
				if(m.IsNative)
				{
					if(wrapper.IsPInvokeMethod(m))
					{
						// this doesn't appear to be necessary, but we use the flag in Finish to know
						// that we shouldn't emit a method body
						attribs |= MethodAttributes.PinvokeImpl;
					}
					else
					{
						setModifiers = true;
					}
				}
				if(m.IsPrivate)
				{
					attribs |= MethodAttributes.Private;
				}
				else if(m.IsProtected)
				{
					attribs |= MethodAttributes.FamORAssem;
				}
				else if(m.IsPublic)
				{
					attribs |= MethodAttributes.Public;
				}
				else
				{
					attribs |= MethodAttributes.Assembly;
				}
				if(m.Name == "<init>")
				{
					if(setNameSig)
					{
						// TODO we might have to mangle the signature to make it unique
d3798 4
a3801 2
					// strictfp is the only modifier that a constructor can have
					if(m.IsStrictfp)
d3803 1
a3803 1
						setModifiers = true;
d3805 3
a3807 11
					method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, methods[index].GetParametersForDefineMethod());
					((ConstructorBuilder)method).SetImplementationFlags(MethodImplAttributes.NoInlining);
					wrapper.AddParameterNames(classFile, m, method);
				}
				else if(m.IsClassInitializer)
				{
					method = DefineClassInitializer();
				}
				else
				{
					if(m.IsAbstract)
d3809 1
a3809 4
						// only if the classfile is abstract, we make the CLR method abstract, otherwise,
						// we have to generate a method that throws an AbstractMethodError (because the JVM
						// allows abstract methods in non-abstract classes)
						if(classFile.IsAbstract)
d3811 3
a3813 1
							attribs |= MethodAttributes.Abstract;
d3820 17
a3836 1
					if(m.IsFinal)
d3838 1
a3838 1
						if(!m.IsStatic && !m.IsPrivate)
d3840 1
a3840 1
							attribs |= MethodAttributes.Final;
d3842 2
a3843 1
						else
d3847 3
d3851 1
a3851 1
					if(m.IsStatic)
d3853 1
a3853 1
						attribs |= MethodAttributes.Static;
d3855 1
a3855 1
					else if(!m.IsPrivate)
d3857 13
a3869 20
						attribs |= MethodAttributes.Virtual | MethodAttributes.CheckAccessOnOverride;
					}
					string name = m.Name;
					// if a method is virtual, we need to find the method it overrides (if any), for several reasons:
					// - if we're overriding a method that has a different name (e.g. some of the virtual methods
					//   in System.Object [Equals <-> equals]) we need to add an explicit MethodOverride
					// - if one of the base classes has a similar method that is private (or package) that we aren't
					//   overriding, we need to specify an explicit MethodOverride
					MethodWrapper baseMce = baseMethods[index];
					bool explicitOverride = methods[index].IsExplicitOverride;
					if((attribs & MethodAttributes.Virtual) != 0 && !classFile.IsInterface)
					{
						// make sure the base method is already defined
						Debug.Assert(baseMce == null || baseMce.GetMethod() != null);
						if(baseMce == null || baseMce.DeclaringType.IsInterface)
						{
							// we need to set NewSlot here, to prevent accidentally overriding methods
							// (for example, if a Java class has a method "boolean Equals(object)", we don't want that method
							// to override System.Object.Equals)
							attribs |= MethodAttributes.NewSlot;
d3871 1
a3871 1
						else
d3873 5
a3877 6
							// if we have a method overriding a more accessible method (the JVM allows this), we need to make the
							// method more accessible, because otherwise the CLR will complain that we're reducing access
							MethodBase baseMethod = baseMce.GetMethod();
							if((baseMethod.IsPublic && !m.IsPublic) ||
								(baseMethod.IsFamily && !m.IsPublic && !m.IsProtected) ||
								(!m.IsPublic && !m.IsProtected && !baseMce.DeclaringType.IsInSamePackageAs(wrapper)))
a3878 2
								attribs &= ~MethodAttributes.MemberAccessMask;
								attribs |= baseMethod.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
d3882 5
a3886 7
					}
					MethodBuilder mb = wrapper.DefineGhostMethod(name, attribs, methods[index]);
					if(mb == null)
					{
						bool needFinalize = false;
						bool needDispatch = false;
						if(baseMce != null && m.Name == "finalize" && m.Signature == "()V")
d3888 19
a3906 4
							if(baseMce.RealName == "Finalize")
							{
								// We're overriding Finalize (that was renamed to finalize by DotNetTypeWrapper)
								// in a non-Java base class.
a3907 2
								needFinalize = true;
								needDispatch = true;
d3909 1
a3909 1
							else if(baseMce.DeclaringType == CoreClasses.java.lang.Object.Wrapper)
d3911 6
a3916 16
								// This type is the first type in the hierarchy to introduce a finalize method
								// (other than the one in java.lang.Object obviously), so we need to override
								// the real Finalize method and emit a dispatch call to our finalize method.
								needFinalize = true;
								needDispatch = true;
							}
							else if(m.IsFinal)
							{
								// One of our base classes already has a  finalize method, so we already are
								// hooked into the real Finalize, but we need to override it again, to make it
								// final (so that non-Java types cannot override it either).
								needFinalize = true;
								needDispatch = false;
								// If the base class finalize was optimized away, we need a dispatch call after all.
								Type baseFinalizeType = typeBuilder.BaseType.GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null).DeclaringType;
								if(baseFinalizeType == typeof(object))
d3918 3
a3920 1
									needDispatch = true;
d3923 7
a3929 1
							else
d3931 9
a3939 5
								// One of our base classes already has a finalize method, but it may have been an empty
								// method so that the hookup to the real Finalize was optimized away, we need to check
								// for that.
								Type baseFinalizeType = typeBuilder.BaseType.GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null).DeclaringType;
								if(baseFinalizeType == typeof(object))
d3941 3
d3947 40
d3988 1
a3988 5
							if(needFinalize &&
								!m.IsAbstract && !m.IsNative &&
								(!m.IsFinal || classFile.IsFinal) &&
								m.Instructions.Length > 0 &&
								m.Instructions[0].NormalizedOpCode == NormalizedByteCode.__return)
d3990 1
a3990 3
								// we've got an empty finalize method, so we don't need to override the real finalizer
								// (not having a finalizer makes a huge perf difference)
								needFinalize = false;
d3992 2
a3993 29
						}
						if(unloadableOverrideStub)
						{
							attribs |= MethodAttributes.NewSlot;
						}
						if(setNameSig || memberclashtable != null)
						{
							name = GenerateUniqueMethodName(name, methods[index]);
						}
						mb = typeBuilder.DefineMethod(name, attribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
						if(unloadableOverrideStub)
						{
							GenerateUnloadableOverrideStub(baseMce, mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
						}
						else if(baseMce != null && (explicitOverride || baseMce.RealName != name) && !needFinalize)
						{
							// assert that the method we're overriding is in fact virtual and not final!
							Debug.Assert(baseMce.GetMethod().IsVirtual && !baseMce.GetMethod().IsFinal);
							typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMce.GetMethod());
						}
						// if we're overriding java.lang.Object.finalize we need to emit a stub to override System.Object.Finalize,
						// or if we're subclassing a non-Java class that has a Finalize method, we need a new Finalize override
						if(needFinalize)
						{
							MethodInfo baseFinalize = typeBuilder.BaseType.GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
							MethodAttributes attr = MethodAttributes.Virtual;
							// make sure we don't reduce accessibility
							attr |= baseFinalize.IsPublic ? MethodAttributes.Public : MethodAttributes.Family;
							if(m.IsFinal)
d3995 1
a3995 1
								attr |= MethodAttributes.Final;
d3997 1
a3997 9
							// TODO if the Java class also defines a Finalize() method, we need to name the stub differently
							// (and make it effectively appear hidden by the class's Finalize method)
							MethodBuilder finalize = typeBuilder.DefineMethod("Finalize", attr, CallingConventions.Standard, typeof(void), Type.EmptyTypes);
							AttributeHelper.HideFromJava(finalize);
							ILGenerator ilgen = finalize.GetILGenerator();
							ilgen.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("SkipFinalizer"));
							Label skip = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brtrue_S, skip);
							if(needDispatch)
d3999 3
a4001 5
								ilgen.BeginExceptionBlock();
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Callvirt, mb);
								ilgen.BeginCatchBlock(typeof(object));
								ilgen.EndExceptionBlock();
d4003 3
a4005 1
							else
d4007 31
a4037 2
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Call, baseFinalize);
a4038 2
							ilgen.MarkLabel(skip);
							ilgen.Emit(OpCodes.Ret);
d4040 6
d4047 3
a4049 2
					wrapper.AddParameterNames(classFile, m, mb);
					if((JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage) && setModifiers)
d4051 9
a4059 1
						AttributeHelper.SetModifiers(mb, m.Modifiers);
d4061 5
a4065 1
					method = mb;
d4067 13
a4079 3
				string[] exceptions = m.ExceptionsAttribute;
				methods[index].SetDeclaredExceptions(exceptions);
				if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage)
d4081 2
a4082 2
					AttributeHelper.SetThrowsAttribute(method, exceptions);
					if(m.DeprecatedAttribute)
d4084 1
a4084 1
						AttributeHelper.SetDeprecatedAttribute(method);
d4086 21
a4106 1
					if(setNameSig)
d4108 1
a4108 1
						AttributeHelper.SetNameSig(method, m.Name, m.Signature);
d4111 1
a4111 1
				return method;
d4113 2
a4114 1
			finally
d4116 25
a4140 1
				Profiler.Leave("JavaTypeImpl.GenerateMethod");
a4141 1
		}
d4143 1
a4143 11
		private void GenerateUnloadableOverrideStub(MethodWrapper baseMethod, MethodInfo target, Type targetRet, Type[] targetArgs)
		{
			Type stubret = baseMethod.ReturnTypeForDefineMethod;
			Type[] stubargs = baseMethod.GetParametersForDefineMethod();
			string name = GenerateUniqueMethodName(baseMethod.RealName + "/unloadablestub", baseMethod);
			MethodBuilder overrideStub = typeBuilder.DefineMethod(name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final, stubret, stubargs);
			AttributeHelper.HideFromJava(overrideStub);
			typeBuilder.DefineMethodOverride(overrideStub, (MethodInfo)baseMethod.GetMethod());
			ILGenerator ilgen = overrideStub.GetILGenerator();
			ilgen.Emit(OpCodes.Ldarg_0);
			for(int i = 0; i < targetArgs.Length; i++)
d4145 1
a4145 2
				ilgen.Emit(OpCodes.Ldarg_S, (byte)(i + 1));
				if(targetArgs[i] != stubargs[i])
d4147 1
a4147 1
					ilgen.Emit(OpCodes.Castclass, targetArgs[i]);
a4149 6
			ilgen.Emit(OpCodes.Callvirt, target);
			if(targetRet != stubret)
			{
				ilgen.Emit(OpCodes.Castclass, stubret);
			}
			ilgen.Emit(OpCodes.Ret);
d4151 4
d4156 1
a4156 4
		private static bool CheckRequireOverrideStub(MethodWrapper mw1, MethodWrapper mw2)
		{
			// TODO this is too late to generate LinkageErrors so we need to figure this out earlier
			if(mw1.ReturnType != mw2.ReturnType  && !(mw1.ReturnType.IsUnloadable && mw2.ReturnType.IsUnloadable))
d4158 1
a4158 1
				return true;
d4160 2
a4161 3
			TypeWrapper[] args1 = mw1.GetParameters();
			TypeWrapper[] args2 = mw2.GetParameters();
			for(int i = 0; i < args1.Length; i++)
d4163 1
a4163 1
				if(args1[i] != args2[i] && !(args1[i].IsUnloadable && args2[i].IsUnloadable))
d4165 1
a4165 1
					return true;
a4167 2
			return false;
		}
d4169 1
a4169 3
		private void AddMethodOverride(MethodWrapper method, MethodBuilder mb, TypeWrapper iface, string name, string sig, ref Hashtable hashtable, bool unloadableOnly)
		{
			if(hashtable != null && hashtable.ContainsKey(iface))
d4171 5
a4175 1
				return;
d4177 2
a4178 2
			MethodWrapper mw = iface.GetMethodWrapper(name, sig, false);
			if(mw != null)
d4180 1
a4180 1
				if(hashtable == null)
d4182 1
a4182 10
					hashtable = new Hashtable();
				}
				hashtable.Add(iface, iface);
				if(CheckRequireOverrideStub(method, mw))
				{
					GenerateUnloadableOverrideStub(mw, mb, method.ReturnTypeForDefineMethod, method.GetParametersForDefineMethod());
				}
				else if(!unloadableOnly)
				{
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
a4184 5
			foreach(TypeWrapper iface2 in iface.Interfaces)
			{
				AddMethodOverride(method, mb, iface2, name, sig, ref hashtable, unloadableOnly);
			}
		}
d4186 1
a4186 3
		internal override Type Type
		{
			get
d4188 1
a4188 1
				return typeBuilder;
a4189 11
		}
	}
	
	private class DoomedTypeImpl : DynamicImpl
	{
		private string message;

		internal DoomedTypeImpl(string message)
		{
			this.message = message;
		}
d4191 1
a4191 3
		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
a4194 1
		}
d4196 1
a4196 3
		internal override DynamicImpl Finish(bool forDebugSave)
		{
			if(!forDebugSave)
d4198 4
a4201 1
				throw new VerifyError(message);
a4202 2
			return this;
		}
d4204 1
a4204 3
		internal override TypeWrapper[] InnerClasses
		{
			get
d4206 4
a4209 1
				return null;
d4213 1
a4213 1
		internal override FieldInfo LinkField(FieldWrapper fw)
d4215 4
a4218 2
			return null;
		}
d4220 7
a4226 4
		internal override MethodBase LinkMethod(MethodWrapper mw)
		{
			return null;
		}
d4228 1
a4228 3
		internal override Modifiers ReflectiveModifiers
		{
			get
d4230 5
a4234 1
				return (Modifiers)0;
a4235 1
		}
d4237 1
a4237 3
		internal override Type Type
		{
			get
d4239 5
a4243 1
				return null;
a4244 2
		}
	}
d4246 7
a4252 6
	private class FinishedTypeImpl : DynamicImpl
	{
		private Type type;
		private TypeWrapper[] innerclasses;
		private TypeWrapper declaringTypeWrapper;
		private Modifiers reflectiveModifiers;
d4254 1
a4254 11
		internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers)
		{
			this.type = type;
			this.innerclasses = innerclasses;
			this.declaringTypeWrapper = declaringTypeWrapper;
			this.reflectiveModifiers = reflectiveModifiers;
		}

		internal override TypeWrapper[] InnerClasses
		{
			get
d4256 4
a4259 2
				// TODO compute the innerclasses lazily (and fix JavaTypeImpl to not always compute them)
				return innerclasses;
a4260 1
		}
d4262 1
a4262 3
		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
d4264 1
a4264 2
				// TODO compute lazily (and fix JavaTypeImpl to not always compute it)
				return declaringTypeWrapper;
a4265 1
		}
d4267 1
a4267 3
		internal override Modifiers ReflectiveModifiers
		{
			get
d4269 3
a4271 1
				return reflectiveModifiers;
a4272 1
		}
d4274 1
a4274 3
		internal override Type Type
		{
			get
d4276 3
a4278 1
				return type;
d4282 1
a4282 1
		internal override DynamicImpl Finish(bool forDebugSave)
d4284 2
a4285 25
			return this;
		}

		internal override MethodBase LinkMethod(MethodWrapper mw)
		{
			// we should never be called, because all methods on a finished type are already linked
			Debug.Assert(false);
			return mw.GetMethod();
		}

		internal override FieldInfo LinkField(FieldWrapper fw)
		{
			// we should never be called, because all fields on a finished type are already linked
			Debug.Assert(false);
			return fw.GetField();
		}
	}

	protected static ParameterBuilder[] AddParameterNames(MethodBase mb, ClassFile.Method m, string[] parameterNames)
	{
		ClassFile.Method.LocalVariableTableEntry[] localVars = m.LocalVariableTableAttribute;
		if(localVars != null)
		{
			int bias = 1;
			if(m.IsStatic)
d4287 7
a4293 6
				bias = 0;
			}
			ParameterBuilder[] parameterBuilders = new ParameterBuilder[m.ArgMap.Length - bias];
			for(int i = bias; i < m.ArgMap.Length; i++)
			{
				if(m.ArgMap[i] != -1)
d4295 1
a4295 1
					for(int j = 0; j < localVars.Length; j++)
d4297 1
a4297 1
						if(localVars[j].index == i && parameterBuilders[i - bias] == null)
d4299 1
a4299 2
							string name = localVars[j].name;
							if(parameterNames != null && parameterNames[i - bias] != null)
d4301 16
a4316 10
								name = parameterNames[i - bias];
							}
							ParameterBuilder pb;
							if(mb is MethodBuilder)
							{
								pb = ((MethodBuilder)mb).DefineParameter(m.ArgMap[i] + 1 - bias, ParameterAttributes.None, name);
							}
							else
							{
								pb = ((ConstructorBuilder)mb).DefineParameter(m.ArgMap[i], ParameterAttributes.None, name);
a4317 2
							parameterBuilders[i - bias] = pb;
							break;
d4321 5
a4326 5
			return parameterBuilders;
		}
		else
		{
			return AddParameterNames(mb, m.Signature, parameterNames);
a4327 1
	}
d4329 1
a4329 4
	protected static ParameterBuilder[] AddParameterNames(MethodBase mb, string sig, string[] parameterNames)
	{
		ArrayList names = new ArrayList();
		for(int i = 1; sig[i] != ')'; i++)
d4331 2
a4332 8
			if(sig[i] == 'L')
			{
				i++;
				int end = sig.IndexOf(';', i);
				names.Add(GetParameterName(sig.Substring(i, end - i)));
				i = end;
			}
			else if(sig[i] == '[')
a4333 1
				while(sig[++i] == '[');
d4338 1
a4338 1
					names.Add(GetParameterName(sig.Substring(i, end - i)) + "arr");
d4341 39
d4386 1
a4386 1
							names.Add("barr");
d4389 1
a4389 1
							names.Add("charr");
d4392 1
a4392 1
							names.Add("sarr");
d4395 1
a4395 1
							names.Add("iarr");
d4398 1
a4398 1
							names.Add("larr");
d4401 1
a4401 1
							names.Add("farr");
d4404 1
a4404 1
							names.Add("darr");
d4409 3
a4411 1
			else
d4413 21
a4433 1
				switch(sig[i])
d4435 1
a4435 22
					case 'B':
					case 'Z':
						names.Add("b");
						break;
					case 'C':
						names.Add("ch");
						break;
					case 'S':
						names.Add("s");
						break;
					case 'I':
						names.Add("i");
						break;
					case 'J':
						names.Add("l");
						break;
					case 'F':
						names.Add("f");
						break;
					case 'D':
						names.Add("d");
						break;
d4437 1
d4439 1
d4441 2
a4442 3
		ParameterBuilder[] parameterBuilders = new ParameterBuilder[names.Count];
		Hashtable clashes = new Hashtable();
		for(int i = 0; i < names.Count; i++)
d4444 5
a4448 2
			string name = (string)names[i];
			if(parameterNames != null && parameterNames[i] != null)
d4450 1
a4450 1
				name = parameterNames[i];
d4452 1
a4452 2
			ParameterBuilder pb;
			if(names.IndexOf(name, i + 1) >= 0 || clashes.ContainsKey(name))
d4454 2
a4455 2
				int clash = 1;
				if(clashes.ContainsKey(name))
d4457 4
a4460 1
					clash = (int)clashes[name] + 1;
d4462 1
a4462 2
				clashes[name] = clash;
				name += clash;
d4464 5
a4468 5
			if(mb is MethodBuilder)
			{
				pb = ((MethodBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
			}
			else
d4470 1
a4470 1
				pb = ((ConstructorBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
a4471 1
			parameterBuilders[i] = pb;
a4472 2
		return parameterBuilders;
	}
d4474 1
a4474 3
	private static string GetParameterName(string type)
	{
		if(type == "java.lang.String")
d4476 1
a4476 1
			return "str";
d4478 2
a4479 1
		else if(type == "java.lang.Object")
d4481 1
a4481 1
			return "obj";
d4483 2
a4484 1
		else
a4485 9
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			for(int i = type.LastIndexOf('.') + 1; i < type.Length; i++)
			{
				if(char.IsUpper(type, i))
				{
					sb.Append(char.ToLower(type[i]));
				}
			}
			return sb.ToString();
a4486 1
	}
d4488 1
a4488 3
	protected virtual void AddParameterNames(ClassFile classFile, ClassFile.Method m, MethodBase method)
	{
		if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d4490 1
a4490 1
			AddParameterNames(method, m, null);
a4491 1
	}
d4493 3
a4495 4
	protected virtual bool EmitMapXmlMethodBody(ILGenerator ilgen, ClassFile f, ClassFile.Method m)
	{
		return false;
	}
d4497 3
a4499 4
	protected virtual bool IsPInvokeMethod(ClassFile.Method m)
	{
		return false;
	}
d4501 4
a4504 3
	protected virtual void EmitMapXmlMetadata(TypeBuilder typeBuilder, ClassFile classFile, FieldWrapper[] fields, MethodWrapper[] methods)
	{
	}
d4506 5
a4510 4
	protected virtual MethodBuilder DefineGhostMethod(string name, MethodAttributes attribs, MethodWrapper mw)
	{
		return null;
	}
d4512 5
a4516 23
	protected virtual void FinishGhost(TypeBuilder typeBuilder, MethodWrapper[] methods)
	{
	}

	protected virtual void FinishGhostStep2()
	{
	}

	protected virtual TypeBuilder DefineType(TypeAttributes typeAttribs)
	{
		return GetClassLoader().ModuleBuilder.DefineType(GetClassLoader().MangleTypeName(Name), typeAttribs);
	}

	internal override MethodBase LinkMethod(MethodWrapper mw)
	{
		mw.AssertLinked();
		return impl.LinkMethod(mw);
	}

	internal override FieldInfo LinkField(FieldWrapper fw)
	{
		fw.AssertLinked();
		return impl.LinkField(fw);
a4517 1
}
d4520 1
a4520 15
class AotTypeWrapper : DynamicTypeWrapper
{
	private FieldInfo ghostRefField;
	private MethodBuilder ghostIsInstanceMethod;
	private MethodBuilder ghostIsInstanceArrayMethod;
	private MethodBuilder ghostCastMethod;
	private MethodBuilder ghostCastArrayMethod;
	private TypeBuilder typeBuilderGhostInterface;
	private static Hashtable ghosts;
	private static TypeWrapper[] mappedExceptions;
	private static bool[] mappedExceptionsAllSubClasses;
	private static Hashtable mapxml;

	internal AotTypeWrapper(ClassFile f, ClassLoaderWrapper loader)
		: base(f, loader, null)
d4522 10
a4531 1
	}
d4533 4
a4536 3
	internal static void SetupGhosts(IKVM.Internal.MapXml.Root map)
	{
		ghosts = new Hashtable();
d4538 1
a4538 2
		// find the ghost interfaces
		foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
d4540 4
a4543 1
			if(c.Shadows != null && c.Interfaces != null)
d4545 1
a4545 4
				// NOTE we don't support interfaces that inherit from other interfaces
				// (actually, if they are explicitly listed it would probably work)
				TypeWrapper typeWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(c.Name);
				foreach(IKVM.Internal.MapXml.Interface iface in c.Interfaces)
d4547 4
a4550 2
					TypeWrapper ifaceWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(iface.Name);
					if(ifaceWrapper == null || !ifaceWrapper.TypeAsTBD.IsAssignableFrom(typeWrapper.TypeAsTBD))
d4552 5
a4556 1
						AddGhost(iface.Name, typeWrapper);
d4560 4
a4564 5
		// we manually add the array ghost interfaces
		TypeWrapper array = ClassLoaderWrapper.GetWrapperFromType(typeof(Array));
		AddGhost("java.io.Serializable", array);
		AddGhost("java.lang.Cloneable", array);
	}
d4566 1
a4566 4
	private static void AddGhost(string interfaceName, TypeWrapper implementer)
	{
		ArrayList list = (ArrayList)ghosts[interfaceName];
		if(list == null)
d4568 7
a4574 2
			list = new ArrayList();
			ghosts[interfaceName] = list;
a4575 2
		list.Add(implementer);
	}
d4577 1
a4577 3
	internal override bool IsGhost
	{
		get
d4579 4
a4582 1
			return ghosts != null && IsInterface && ghosts.ContainsKey(Name);
a4583 1
	}
d4585 3
a4587 3
	private class ExceptionMapEmitter : CodeEmitter
	{
		private IKVM.Internal.MapXml.ExceptionMapping[] map;
d4589 4
a4592 4
		internal ExceptionMapEmitter(IKVM.Internal.MapXml.ExceptionMapping[] map)
		{
			this.map = map;
		}
d4594 1
a4594 8
		internal override void Emit(ILGenerator ilgen)
		{
			MethodWrapper mwSuppressFillInStackTrace = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("__<suppressFillInStackTrace>", "()V", false);
			mwSuppressFillInStackTrace.Link();
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Callvirt, typeof(Object).GetMethod("GetType"));
			MethodInfo GetTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle");
			for(int i = 0; i < map.Length; i++)
d4596 6
a4601 8
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Ldtoken, Type.GetType(map[i].src));
				ilgen.Emit(OpCodes.Call, GetTypeFromHandle);
				ilgen.Emit(OpCodes.Ceq);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brfalse_S, label);
				ilgen.Emit(OpCodes.Pop);
				if(map[i].code != null)
d4603 25
a4627 5
					ilgen.Emit(OpCodes.Ldarg_0);
					// TODO we should manually walk the instruction list and add a suppressFillInStackTrace call
					// before each newobj that instantiates an exception
					map[i].code.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
d4629 3
a4631 10
				else
				{
					TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map[i].dst);
					MethodWrapper mw = tw.GetMethodWrapper("<init>", "()V", false);
					mw.Link();
					mwSuppressFillInStackTrace.EmitCall(ilgen);
					mw.EmitNewobj(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
				ilgen.MarkLabel(label);
a4632 3
			ilgen.Emit(OpCodes.Pop);
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Ret);
a4633 1
	}
d4635 1
a4635 6
	internal static void LoadMapXml(IKVM.Internal.MapXml.Root map)
	{
		mapxml = new Hashtable();
		// HACK we've got a hardcoded location for the exception mapping method that is generated from the xml mapping
		mapxml["java.lang.ExceptionHelper.MapExceptionImpl(Ljava.lang.Throwable;)Ljava.lang.Throwable;"] = new ExceptionMapEmitter(map.exceptionMappings);
		foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
d4637 4
a4640 2
			// HACK if it is not a remapped type, we assume it is a container for native methods
			if(c.Shadows == null)
d4642 2
a4643 3
				string className = c.Name;
				mapxml.Add(className, c);
				if(c.Methods != null)
d4645 3
a4647 1
					foreach(IKVM.Internal.MapXml.Method method in c.Methods)
d4649 1
a4649 1
						if(method.body != null)
d4651 6
a4656 3
							string methodName = method.Name;
							string methodSig = method.Sig;
							mapxml.Add(className + "." + methodName + methodSig, method.body);
a4661 1
	}
d4663 1
a4663 3
	internal override bool IsMapUnsafeException
	{
		get
d4665 1
a4665 1
			if(mappedExceptions != null)
d4667 1
a4667 1
				for(int i = 0; i < mappedExceptions.Length; i++)
d4669 1
a4669 2
					if(mappedExceptions[i].IsSubTypeOf(this) ||
						(mappedExceptionsAllSubClasses[i] && this.IsSubTypeOf(mappedExceptions[i])))
d4671 5
a4675 1
						return true;
d4678 1
a4679 1
			return false;
a4680 1
	}
d4682 1
a4682 3
	internal static void LoadMappedExceptions(IKVM.Internal.MapXml.Root map)
	{
		if(map.exceptionMappings != null)
d4684 1
a4684 3
			mappedExceptionsAllSubClasses = new bool[map.exceptionMappings.Length];
			mappedExceptions = new TypeWrapper[map.exceptionMappings.Length];
			for(int i = 0; i < mappedExceptions.Length; i++)
d4686 3
a4688 2
				string dst = map.exceptionMappings[i].dst;
				if(dst[0] == '*')
d4690 7
a4696 2
					mappedExceptionsAllSubClasses[i] = true;
					dst = dst.Substring(1);
a4697 1
				mappedExceptions[i] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dst);
a4699 1
	}
d4701 1
a4701 4
	private static TypeWrapper[] GetGhostImplementers(TypeWrapper wrapper)
	{
		ArrayList list = (ArrayList)ghosts[wrapper.Name];
		if(list == null)
d4703 6
a4708 1
			return TypeWrapper.EmptyArray;
a4709 2
		return (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
	}
d4711 1
a4711 3
	internal override Type TypeAsBaseType
	{
		get
d4713 4
a4716 1
			return typeBuilderGhostInterface != null ? typeBuilderGhostInterface : base.TypeAsBaseType;
a4717 1
	}
d4719 1
a4719 3
	private static IKVM.Internal.MapXml.Param[] GetXmlMapParameters(string classname, string method, string sig)
	{
		if(mapxml != null)
d4721 1
a4721 2
			IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[classname];
			if(clazz != null)
d4723 2
a4724 1
				if(method == "<init>" && clazz.Constructors != null)
d4726 1
a4726 1
					for(int i = 0; i < clazz.Constructors.Length; i++)
d4728 1
a4728 1
						if(clazz.Constructors[i].Sig == sig)
d4730 4
a4733 1
							return clazz.Constructors[i].Params;
d4736 1
a4736 4
				}
				else if(clazz.Methods != null)
				{
					for(int i = 0; i < clazz.Methods.Length; i++)
d4738 1
a4738 1
						if(clazz.Methods[i].Name == method && clazz.Methods[i].Sig == sig)
d4740 4
a4743 1
							return clazz.Methods[i].Params;
d4748 1
a4749 2
		return null;
	}
d4751 1
a4751 4
	protected override void AddParameterNames(ClassFile classFile, ClassFile.Method m, MethodBase method)
	{
		IKVM.Internal.MapXml.Param[] parameters = GetXmlMapParameters(classFile.Name, m.Name, m.Signature);
		if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || parameters != null || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d4753 2
a4754 2
			string[] parameterNames = null;
			if(parameters != null)
d4756 2
a4757 2
				parameterNames = new string[parameters.Length];
				for(int i = 0; i < parameters.Length; i++)
d4759 5
a4763 1
					parameterNames[i] = parameters[i].Name;
d4765 2
a4766 5
			}
			ParameterBuilder[] pbs = AddParameterNames(method, m, parameterNames);
			if(parameters != null)
			{
				for(int i = 0; i < pbs.Length; i++)
d4768 1
a4768 1
					if(parameters[i].Attributes != null)
d4770 1
a4770 1
						foreach(IKVM.Internal.MapXml.Attribute attr in parameters[i].Attributes)
d4772 4
a4775 1
							AttributeHelper.SetCustomAttribute(pbs[i], attr);
a4780 1
	}
d4782 1
a4782 4
	private void AddParameterNames(MethodBuilder method, MethodWrapper mw)
	{
		IKVM.Internal.MapXml.Param[] parameters = GetXmlMapParameters(Name, mw.Name, mw.Signature);
		if((JVM.IsStaticCompiler && mw.DeclaringType.IsPublic && (mw.IsPublic || mw.IsProtected)) || parameters != null || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d4784 2
a4785 2
			string[] parameterNames = null;
			if(parameters != null)
d4787 2
a4788 2
				parameterNames = new string[parameters.Length];
				for(int i = 0; i < parameters.Length; i++)
d4790 5
a4794 1
					parameterNames[i] = parameters[i].Name;
d4796 2
a4797 5
			}
			ParameterBuilder[] pbs = AddParameterNames(method, mw.Signature, parameterNames);
			if(parameters != null)
			{
				for(int i = 0; i < pbs.Length; i++)
d4799 1
a4799 1
					if(parameters[i].Attributes != null)
d4801 1
a4801 1
						foreach(IKVM.Internal.MapXml.Attribute attr in parameters[i].Attributes)
d4803 4
a4806 1
							AttributeHelper.SetCustomAttribute(pbs[i], attr);
a4811 1
	}
d4813 1
a4813 3
	protected override bool EmitMapXmlMethodBody(CountingILGenerator ilgen, ClassFile f, ClassFile.Method m)
	{
		if(mapxml != null)
d4815 1
a4815 2
			CodeEmitter opcodes = (CodeEmitter)mapxml[f.Name + "." + m.Name + m.Signature];
			if(opcodes != null)
d4817 6
a4822 2
				opcodes.Emit(ilgen);
				return true;
d4824 1
a4825 2
		return false;
	}
d4827 1
a4827 3
	private void PublishAttributes(TypeBuilder typeBuilder, IKVM.Internal.MapXml.Class clazz)
	{
		foreach(IKVM.Internal.MapXml.Attribute attr in clazz.Attributes)
d4829 4
a4832 1
			AttributeHelper.SetCustomAttribute(typeBuilder, attr);
a4833 1
	}
d4835 1
a4835 3
	private static bool CheckPropertyArgs(Type[] args1, Type[] args2)
	{
		if(args1.Length == args2.Length)
d4837 1
a4837 1
			for(int i = 0; i < args1.Length; i++)
d4839 1
a4839 1
				if(args1[i] != args2[i])
d4841 4
a4844 1
					return false;
d4846 1
d4848 1
a4848 36
			return true;
		}
		return false;
	}

	private static MethodAttributes GetPropertyMethodAttributes(MethodWrapper mw, bool final)
	{
		MethodAttributes attribs = (MethodAttributes)0;
		if(mw.IsStatic)
		{
			attribs |= MethodAttributes.Static;
		}
		else
		{
			// NOTE in order for IntelliSense to consider the property a "real" property,
			// the getter and setter methods need to have substantially the same method attributes,
			// so we may need to look at our peer to determine whether we should be final
			// or not (and vice versa).
			attribs |= MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.CheckAccessOnOverride;
			if(final)
			{
				attribs |= MethodAttributes.Final;
			}
		}
		// TODO what happens if accessibility doesn't match our peer?
		if(mw.IsPublic)
		{
			attribs |= MethodAttributes.Public;
		}
		else if(mw.IsProtected)
		{
			attribs |= MethodAttributes.FamORAssem;
		}
		else if(mw.IsPrivate)
		{
			attribs |= MethodAttributes.Private;
a4849 6
		else
		{
			attribs |= MethodAttributes.Assembly;
		}
		return attribs;
	}
d4851 1
a4851 4
	private void PublishProperties(TypeBuilder typeBuilder, IKVM.Internal.MapXml.Class clazz)
	{
		Hashtable classCache = new Hashtable();
		foreach(IKVM.Internal.MapXml.Property prop in clazz.Properties)
d4853 2
a4854 4
			TypeWrapper typeWrapper = ClassFile.RetTypeWrapperFromSig(GetClassLoader(), classCache, prop.Sig);
			TypeWrapper[] propargs = ClassFile.ArgTypeWrapperListFromSig(GetClassLoader(), classCache, prop.Sig);
			Type[] indexer = new Type[propargs.Length];
			for(int i = 0; i < propargs.Length; i++)
d4856 1
a4856 1
				indexer[i] = propargs[i].TypeAsSignatureType;
d4858 1
a4858 2
			PropertyBuilder propbuilder = typeBuilder.DefineProperty(prop.Name, PropertyAttributes.None, typeWrapper.TypeAsSignatureType, indexer);
			if(prop.Attributes != null)
d4860 6
a4865 1
				foreach(IKVM.Internal.MapXml.Attribute attr in prop.Attributes)
d4867 1
a4867 1
					AttributeHelper.SetCustomAttribute(propbuilder, attr);
d4870 24
a4893 3
			MethodWrapper getter = null;
			MethodWrapper setter = null;
			if(prop.getter != null)
d4895 9
a4903 2
				getter = GetMethodWrapper(prop.getter.Name, prop.getter.Sig, true);
				if(getter == null)
d4905 4
a4908 1
					Console.Error.WriteLine("Warning: getter not found for {0}::{1}", clazz.Name, prop.Name);
d4910 3
a4912 5
			}
			if(prop.setter != null)
			{
				setter = GetMethodWrapper(prop.setter.Name, prop.setter.Sig, true);
				if(setter == null)
d4914 5
a4918 1
					Console.Error.WriteLine("Warning: setter not found for {0}::{1}", clazz.Name, prop.Name);
d4920 1
a4920 6
			}
			bool final = (getter != null && getter.IsFinal) || (setter != null && setter.IsFinal);
			if(getter != null)
			{
				MethodWrapper mw = getter;
				if(!CheckPropertyArgs(mw.GetParametersForDefineMethod(), indexer) || mw.ReturnType != typeWrapper)
d4922 5
a4926 1
					Console.Error.WriteLine("Warning: ignoring invalid property getter for {0}::{1}", clazz.Name, prop.Name);
d4928 2
a4929 1
				else
d4931 6
a4936 2
					MethodBuilder mb = mw.GetMethod() as MethodBuilder;
					if(mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final))
d4938 2
a4939 4
						mb = typeBuilder.DefineMethod(GenerateUniqueMethodName("get_" + prop.Name, mw), GetPropertyMethodAttributes(mw, final), typeWrapper.TypeAsSignatureType, indexer);
						AttributeHelper.HideFromJava(mb);
						ILGenerator ilgen = new CountingILGenerator(mb.GetILGenerator());
						if(mw.IsStatic)
d4941 4
a4944 1
							for(int i = 0; i < indexer.Length; i++)
d4946 5
a4950 1
								ilgen.Emit(OpCodes.Ldarg, i);
d4952 1
a4952 6
							mw.EmitCall(ilgen);
						}
						else
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							for(int i = 0; i < indexer.Length; i++)
d4954 6
a4959 1
								ilgen.Emit(OpCodes.Ldarg, i + 1);
d4961 1
a4961 1
							mw.EmitCallvirt(ilgen);
d4963 1
a4963 1
						ilgen.Emit(OpCodes.Ret);
a4964 1
					propbuilder.SetGetMethod(mb);
d4966 1
a4966 8
			}
			if(setter != null)
			{
				MethodWrapper mw = setter;
				Type[] args = new Type[indexer.Length + 1];
				indexer.CopyTo(args, 0);
				args[args.Length - 1] = typeWrapper.TypeAsSignatureType;
				if(!CheckPropertyArgs(args, mw.GetParametersForDefineMethod()))
d4968 9
a4976 6
					Console.Error.WriteLine("Warning: ignoring invalid property setter for {0}::{1}", clazz.Name, prop.Name);
				}
				else
				{
					MethodBuilder mb = mw.GetMethod() as MethodBuilder;
					if(mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final))
d4978 2
a4979 4
						mb = typeBuilder.DefineMethod(GenerateUniqueMethodName("set_" + prop.Name, mw), GetPropertyMethodAttributes(mw, final), mw.ReturnTypeForDefineMethod, args);
						AttributeHelper.HideFromJava(mb);
						ILGenerator ilgen = new CountingILGenerator(mb.GetILGenerator());
						if(mw.IsStatic)
d4981 4
a4984 1
							for(int i = 0; i <= indexer.Length; i++)
d4986 5
a4990 1
								ilgen.Emit(OpCodes.Ldarg, i);
d4992 1
a4992 6
							mw.EmitCall(ilgen);
						}
						else
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							for(int i = 0; i <= indexer.Length; i++)
d4994 6
a4999 1
								ilgen.Emit(OpCodes.Ldarg, i + 1);
d5001 1
a5001 1
							mw.EmitCallvirt(ilgen);
d5003 1
a5003 1
						ilgen.Emit(OpCodes.Ret);
a5004 1
					propbuilder.SetSetMethod(mb);
a5007 1
	}
d5009 1
a5009 3
	protected override bool IsPInvokeMethod(ClassFile.Method m)
	{
		if(mapxml != null)
d5011 1
a5011 2
			IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[Name];
			if(clazz != null && clazz.Methods != null)
d5013 2
a5014 1
				foreach(IKVM.Internal.MapXml.Method method in clazz.Methods)
d5016 1
a5016 1
					if(method.Name == m.Name && method.Sig == m.Signature)
d5018 1
a5018 1
						if(method.Attributes != null)
d5020 1
a5020 1
							foreach(IKVM.Internal.MapXml.Attribute attr in method.Attributes)
d5022 1
a5022 1
								if(Type.GetType(attr.Type) == typeof(System.Runtime.InteropServices.DllImportAttribute))
d5024 4
a5027 1
									return true;
d5030 1
a5031 1
						break;
d5035 1
a5036 2
		return base.IsPInvokeMethod(m);
	}
d5038 1
a5038 3
	protected override void EmitMapXmlMetadata(TypeBuilder typeBuilder, ClassFile classFile, FieldWrapper[] fields, MethodWrapper[] methods)
	{
		if(mapxml != null)
d5040 1
a5040 2
			IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[classFile.Name];
			if(clazz != null)
d5042 2
a5043 1
				if(clazz.Attributes != null)
d5045 9
a5053 9
					PublishAttributes(typeBuilder, clazz);
				}
				if(clazz.Properties != null)
				{
					PublishProperties(typeBuilder, clazz);
				}
				if(clazz.Fields != null)
				{
					foreach(IKVM.Internal.MapXml.Field field in clazz.Fields)
d5055 1
a5055 1
						if(field.Attributes != null)
d5057 1
a5057 1
							foreach(FieldWrapper fw in fields)
d5059 1
a5059 1
								if(fw.Name == field.Name && fw.Signature == field.Sig)
d5061 1
a5061 2
									FieldBuilder fb = fw.GetField() as FieldBuilder;
									if(fb != null)
d5063 2
a5064 1
										foreach(IKVM.Internal.MapXml.Attribute attr in field.Attributes)
d5066 4
a5069 1
											AttributeHelper.SetCustomAttribute(fb, attr);
d5076 1
a5076 4
				}
				if(clazz.Constructors != null)
				{
					foreach(IKVM.Internal.MapXml.Constructor constructor in clazz.Constructors)
d5078 1
a5078 1
						if(constructor.Attributes != null)
d5080 1
a5080 1
							foreach(MethodWrapper mw in methods)
d5082 1
a5082 1
								if(mw.Name == "<init>" && mw.Signature == constructor.Sig)
d5084 1
a5084 2
									ConstructorBuilder mb = mw.GetMethod() as ConstructorBuilder;
									if(mb != null)
d5086 2
a5087 1
										foreach(IKVM.Internal.MapXml.Attribute attr in constructor.Attributes)
d5089 4
a5092 1
											AttributeHelper.SetCustomAttribute(mb, attr);
d5099 1
a5099 4
				}
				if(clazz.Methods != null)
				{
					foreach(IKVM.Internal.MapXml.Method method in clazz.Methods)
d5101 1
a5101 1
						if(method.Attributes != null)
d5103 1
a5103 1
							foreach(MethodWrapper mw in methods)
d5105 1
a5105 1
								if(mw.Name == method.Name && mw.Signature == method.Sig)
d5107 1
a5107 2
									MethodBuilder mb = mw.GetMethod() as MethodBuilder;
									if(mb != null)
d5109 2
a5110 1
										foreach(IKVM.Internal.MapXml.Attribute attr in method.Attributes)
d5112 4
a5115 1
											AttributeHelper.SetCustomAttribute(mb, attr);
a5124 1
	}
d5126 1
a5126 3
	protected override MethodBuilder DefineGhostMethod(string name, MethodAttributes attribs, MethodWrapper mw)
	{
		if(typeBuilderGhostInterface != null)
d5128 8
a5135 5
			return typeBuilderGhostInterface.DefineMethod(name, attribs, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
		}
		else
		{
			return base.DefineGhostMethod(name, attribs, mw);
a5136 1
	}
d5138 1
a5138 3
	protected override void FinishGhost(TypeBuilder typeBuilder, MethodWrapper[] methods)
	{
		if(typeBuilderGhostInterface != null)
d5140 1
a5140 2
			// TODO consider adding methods from base interface and java.lang.Object as well
			for(int i = 0; i < methods.Length; i++)
d5142 2
a5143 2
				// skip <clinit>
				if(!methods[i].IsStatic)
d5145 2
a5146 22
					TypeWrapper[] args = methods[i].GetParameters();
					MethodBuilder stub = typeBuilder.DefineMethod(methods[i].Name, MethodAttributes.Public, methods[i].ReturnTypeForDefineMethod, methods[i].GetParametersForDefineMethod());
					AddParameterNames(stub, methods[i]);
					AttributeHelper.SetModifiers(stub, methods[i].Modifiers);
					ILGenerator ilgen = stub.GetILGenerator();
					Label end = ilgen.DefineLabel();
					TypeWrapper[] implementers = GetGhostImplementers(this);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldfld, ghostRefField);
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Isinst, typeBuilderGhostInterface);
					Label label = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, label);
					ilgen.Emit(OpCodes.Castclass, typeBuilderGhostInterface);
					for(int k = 0; k < args.Length; k++)
					{
						ilgen.Emit(OpCodes.Ldarg_S, (byte)(k + 1));
					}
					ilgen.Emit(OpCodes.Callvirt, (MethodInfo)methods[i].GetMethod());
					ilgen.Emit(OpCodes.Br, end);
					ilgen.MarkLabel(label);
					for(int j = 0; j < implementers.Length; j++)
d5148 9
d5158 2
a5159 2
						ilgen.Emit(OpCodes.Isinst, implementers[j].TypeAsTBD);
						label = ilgen.DefineLabel();
d5161 1
a5161 1
						ilgen.Emit(OpCodes.Castclass, implementers[j].TypeAsTBD);
d5166 59
a5224 2
						MethodWrapper mw = implementers[j].GetMethodWrapper(methods[i].Name, methods[i].Signature, true);
						mw.EmitCallvirt(ilgen);
d5228 4
a5231 3
					// we need to do a null check (null fails all the isinst checks)
					EmitHelper.NullCheck(ilgen);
					EmitHelper.Throw(ilgen, "java.lang.IncompatibleClassChangeError", Name);
d5234 2
a5235 13
				}
			}
			// HACK create a scope to enable reuse of "implementers" name
			if(true)
			{
				MethodBuilder mb;
				ILGenerator ilgen;
				LocalBuilder local;
				// add implicit conversions for all the ghost implementers
				TypeWrapper[] implementers = GetGhostImplementers(this);
				for(int i = 0; i < implementers.Length; i++)
				{
					mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, TypeAsSignatureType, new Type[] { implementers[i].TypeAsSignatureType });
d5238 1
a5238 2
					local = ilgen.DeclareLocal(TypeAsSignatureType);
					ilgen.Emit(OpCodes.Ldloca, local);
d5240 3
a5242 3
					ilgen.Emit(OpCodes.Stfld, ghostRefField);
					ilgen.Emit(OpCodes.Ldloca, local);
					ilgen.Emit(OpCodes.Ldobj, TypeAsSignatureType);			
d5244 1
a5244 8
				}
				// Implement the "IsInstance" method
				mb = ghostIsInstanceMethod;
				AttributeHelper.HideFromJava(mb);
				ilgen = mb.GetILGenerator();
				Label end = ilgen.DefineLabel();
				for(int i = 0; i < implementers.Length; i++)
				{
d5246 7
a5252 3
					ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
					Label label = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, label);
d5254 28
a5281 47
					ilgen.Emit(OpCodes.Br, end);
					ilgen.MarkLabel(label);
				}
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Isinst, typeBuilderGhostInterface);
				ilgen.Emit(OpCodes.Ldnull);
				ilgen.Emit(OpCodes.Cgt_Un);
				ilgen.MarkLabel(end);
				ilgen.Emit(OpCodes.Ret);
				// Implement the "IsInstanceArray" method
				mb = ghostIsInstanceArrayMethod;
				AttributeHelper.HideFromJava(mb);
				ilgen = mb.GetILGenerator();
				LocalBuilder localType = ilgen.DeclareLocal(typeof(Type));
				ilgen.Emit(OpCodes.Ldarg_0);
				Label skip = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brtrue_S, skip);
				ilgen.Emit(OpCodes.Ldc_I4_0);
				ilgen.Emit(OpCodes.Ret);
				ilgen.MarkLabel(skip);
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Call, typeof(object).GetMethod("GetType"));
				ilgen.Emit(OpCodes.Stloc, localType);
				skip = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Br_S, skip);
				Label iter = ilgen.DefineLabel();
				ilgen.MarkLabel(iter);
				ilgen.Emit(OpCodes.Ldarg_1);
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Sub);
				ilgen.Emit(OpCodes.Starg_S, (byte)1);
				ilgen.Emit(OpCodes.Ldloc, localType);
				ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("GetElementType"));
				ilgen.Emit(OpCodes.Stloc, localType);
				ilgen.MarkLabel(skip);
				ilgen.Emit(OpCodes.Ldloc, localType);
				ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("get_IsArray"));
				ilgen.Emit(OpCodes.Brtrue_S, iter);
				ilgen.Emit(OpCodes.Ldarg_1);
				skip = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brfalse_S, skip);
				ilgen.Emit(OpCodes.Ldc_I4_0);
				ilgen.Emit(OpCodes.Ret);
				ilgen.MarkLabel(skip);
				for(int i = 0; i < implementers.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldtoken, implementers[i].TypeAsTBD);
a5284 3
					Label label = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, label);
					ilgen.Emit(OpCodes.Ldc_I4_1);
a5285 7
					ilgen.MarkLabel(label);
				}
				ilgen.Emit(OpCodes.Ldtoken, typeBuilderGhostInterface);
				ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
				ilgen.Emit(OpCodes.Ldloc, localType);
				ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("IsAssignableFrom"));
				ilgen.Emit(OpCodes.Ret);
d5287 40
a5326 7
				// Implement the "Cast" method
				mb = ghostCastMethod;
				AttributeHelper.HideFromJava(mb);
				ilgen = mb.GetILGenerator();
				end = ilgen.DefineLabel();
				for(int i = 0; i < implementers.Length; i++)
				{
d5328 6
a5333 2
					ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
					ilgen.Emit(OpCodes.Brtrue, end);
a5334 36
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Castclass, typeBuilderGhostInterface);
				ilgen.Emit(OpCodes.Pop);
				ilgen.MarkLabel(end);
				local = ilgen.DeclareLocal(TypeAsSignatureType);
				ilgen.Emit(OpCodes.Ldloca, local);
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Stfld, ghostRefField);
				ilgen.Emit(OpCodes.Ldloca, local);
				ilgen.Emit(OpCodes.Ldobj, TypeAsSignatureType);	
				ilgen.Emit(OpCodes.Ret);
				// Add "ToObject" methods
				mb = typeBuilder.DefineMethod("ToObject", MethodAttributes.Public, typeof(object), Type.EmptyTypes);
				AttributeHelper.HideFromJava(mb);
				ilgen = mb.GetILGenerator();
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Ldfld, ghostRefField);
				ilgen.Emit(OpCodes.Ret);

				// Implement the "CastArray" method
				// NOTE unlike "Cast" this doesn't return anything, it just throws a ClassCastException if the
				// cast is unsuccessful. Also, because of the complexity of this test, we call IsInstanceArray
				// instead of reimplementing the check here.
				mb = ghostCastArrayMethod;
				AttributeHelper.HideFromJava(mb);
				ilgen = mb.GetILGenerator();
				end = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Brfalse_S, end);
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Ldarg_1);
				ilgen.Emit(OpCodes.Call, ghostIsInstanceArrayMethod);
				ilgen.Emit(OpCodes.Brtrue_S, end);
				EmitHelper.Throw(ilgen, "java.lang.ClassCastException");
				ilgen.MarkLabel(end);
				ilgen.Emit(OpCodes.Ret);
a5336 67
	}

	protected override void FinishGhostStep2()
	{
		if(typeBuilderGhostInterface != null)
		{
			typeBuilderGhostInterface.CreateType();
		}
	}

	protected override TypeBuilder DefineType(TypeAttributes typeAttribs)
	{
		if(IsGhost)
		{
			typeAttribs &= ~(TypeAttributes.Interface | TypeAttributes.Abstract);
			typeAttribs |= TypeAttributes.Class | TypeAttributes.Sealed;
			TypeBuilder typeBuilder = GetClassLoader().ModuleBuilder.DefineType(GetClassLoader().MangleTypeName(Name), typeAttribs, typeof(ValueType));
			AttributeHelper.SetGhostInterface(typeBuilder);
			AttributeHelper.SetModifiers(typeBuilder, Modifiers);
			ghostRefField = typeBuilder.DefineField("__<ref>", typeof(object), FieldAttributes.Public | FieldAttributes.SpecialName);
			AttributeHelper.HideFromJava((FieldBuilder)ghostRefField);
			typeBuilderGhostInterface = typeBuilder.DefineNestedType("__Interface", TypeAttributes.Interface | TypeAttributes.Abstract | TypeAttributes.NestedPublic);
			AttributeHelper.HideFromJava(typeBuilderGhostInterface);
			ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object) });
			ghostIsInstanceMethod.DefineParameter(1, ParameterAttributes.None, "obj");
			ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object), typeof(int) });
			ghostIsInstanceArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
			ghostIsInstanceArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
			ghostCastMethod = typeBuilder.DefineMethod("Cast", MethodAttributes.Public | MethodAttributes.Static, typeBuilder, new Type[] { typeof(object) });
			ghostCastMethod.DefineParameter(1, ParameterAttributes.None, "obj");
			ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray", MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(object), typeof(int) });
			ghostCastArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
			ghostCastArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
			return typeBuilder;
		}
		else
		{
			return base.DefineType(typeAttribs);
		}
	}

	internal override FieldInfo GhostRefField
	{
		get
		{
			return ghostRefField;
		}
	}

	internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
	{
		if(IsGhost)
		{
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Call, ghostCastMethod);
			ilgen.Emit(OpCodes.Pop);
		}
		else if(IsGhostArray)
		{
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Call, ghostCastArrayMethod);
		}
		else
		{
			base.EmitCheckcast(context, ilgen);
		}
	}
d5338 1
a5338 7
	internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
	{
		if(IsGhost)
		{
			ilgen.Emit(OpCodes.Call, ghostIsInstanceMethod);
		}
		else if(IsGhostArray)
d5340 4
a5343 1
			ilgen.Emit(OpCodes.Call, ghostIsInstanceArrayMethod);
d5345 2
a5346 1
		else
d5348 27
a5374 1
			base.EmitInstanceOf(context, ilgen);
a5375 3
	}
}
#endif
d5377 1
a5377 11
class CompiledTypeWrapper : TypeWrapper
{
	private readonly Type type;
	private TypeWrapper[] interfaces;
	private TypeWrapper[] innerclasses;

	internal static CompiledTypeWrapper newInstance(string name, Type type)
	{
		// TODO since ghost and remapped types can only exist in the core library assembly, we probably
		// should be able to remove the Type.IsDefined() tests in most cases
		if(type.IsValueType && type.IsDefined(typeof(GhostInterfaceAttribute), false))
d5379 4
a5382 1
			return new CompiledGhostTypeWrapper(name, type);
d5384 2
a5385 1
		else if(type.IsDefined(typeof(RemappedTypeAttribute), false))
d5387 15
a5401 1
			return new CompiledRemappedTypeWrapper(name, type);
d5403 2
a5404 1
		else
d5406 12
a5417 1
			return new CompiledTypeWrapper(name, type);
d5420 1
d5422 1
a5422 1
	private sealed class CompiledRemappedTypeWrapper : CompiledTypeWrapper
d5424 3
a5426 1
		private readonly Type remappedType;
d5428 1
a5428 2
		internal CompiledRemappedTypeWrapper(string name, Type type)
			: base(name, type)
d5430 11
a5440 2
			object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
			if(attribs.Length != 1)
d5442 1
a5442 1
				throw new InvalidOperationException();
a5443 1
			remappedType = ((RemappedTypeAttribute)attribs[0]).Type;
d5446 1
a5446 1
		internal override Type TypeAsTBD
d5448 14
a5461 1
			get
d5463 4
a5466 1
				return remappedType;
a5467 1
		}
d5469 1
a5469 3
		internal override bool IsRemapped
		{
			get
d5471 4
a5474 1
				return true;
a5475 1
		}
d5477 1
a5477 6
		protected override void LazyPublishMembers()
		{
			ArrayList methods = new ArrayList();
			ArrayList fields = new ArrayList();
			MemberInfo[] members = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			foreach(MemberInfo m in members)
d5479 4
a5482 1
				if(!AttributeHelper.IsHideFromJava(m))
d5484 1
a5484 4
					MethodBase method = m as MethodBase;
					if(method != null &&
						(remappedType.IsSealed || !m.Name.StartsWith("instancehelper_")) &&
						(!remappedType.IsSealed || method.IsStatic))
d5486 15
a5500 1
						methods.Add(CreateRemappedMethodWrapper(method));
d5502 6
a5507 1
					else
d5509 9
a5517 2
						FieldInfo field = m as FieldInfo;
						if(field != null)
d5519 5
a5523 1
							fields.Add(CreateFieldWrapper(field));
d5525 1
d5528 2
d5531 2
a5532 2
			// if we're a remapped interface, we need to get the methods from the real interface
			if(remappedType.IsInterface)
d5534 9
a5542 2
				Type nestedHelper = type.GetNestedType("__Helper", BindingFlags.Public | BindingFlags.Static);
				foreach(RemappedInterfaceMethodAttribute m in type.GetCustomAttributes(typeof(RemappedInterfaceMethodAttribute), false))
d5544 9
a5552 9
					MethodInfo method = remappedType.GetMethod(m.MappedTo);
					MethodInfo mbHelper = method;
					Modifiers modifiers = AttributeHelper.GetModifiers(method, false);
					string name;
					string sig;
					TypeWrapper retType;
					TypeWrapper[] paramTypes;
					GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes);
					if(nestedHelper != null)
d5554 1
a5554 5
						mbHelper = nestedHelper.GetMethod(m.Name);
						if(mbHelper == null)
						{
							mbHelper = method;
						}
d5556 1
a5556 1
					methods.Add(new CompiledRemappedMethodWrapper(this, m.Name, sig, method, retType, paramTypes, modifiers, false, mbHelper, null));
d5558 1
a5559 2
			SetMethods((MethodWrapper[])methods.ToArray(typeof(MethodWrapper)));
			SetFields((FieldWrapper[])fields.ToArray(typeof(FieldWrapper)));
d5562 1
a5562 1
		private MethodWrapper CreateRemappedMethodWrapper(MethodBase mb)
d5564 9
a5572 9
			Modifiers modifiers = AttributeHelper.GetModifiers(mb, false);
			string name;
			string sig;
			TypeWrapper retType;
			TypeWrapper[] paramTypes;
			GetNameSigFromMethodBase(mb, out name, out sig, out retType, out paramTypes);
			MethodInfo mbHelper = mb as MethodInfo;
			MethodInfo mbNonvirtualHelper = null;
			if(!mb.IsStatic && !mb.IsConstructor)
d5574 1
a5574 4
				ParameterInfo[] parameters = mb.GetParameters();
				Type[] argTypes = new Type[parameters.Length + 1];
				argTypes[0] = remappedType;
				for(int i = 0; i < parameters.Length; i++)
d5576 5
a5580 6
					argTypes[i + 1] = parameters[i].ParameterType;
				}
				MethodInfo helper = type.GetMethod("instancehelper_" + mb.Name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static, null, argTypes, null);
				if(helper != null)
				{
					mbHelper = helper;
a5581 1
				mbNonvirtualHelper = type.GetMethod("nonvirtualhelper/" + mb.Name, BindingFlags.NonPublic | BindingFlags.Static, null, argTypes, null);
a5582 13
			return new CompiledRemappedMethodWrapper(this, name, sig, mb, retType, paramTypes, modifiers, false, mbHelper, mbNonvirtualHelper);
		}
	}

	private sealed class CompiledGhostTypeWrapper : CompiledTypeWrapper
	{
		private FieldInfo ghostRefField;
		private Type typeAsBaseType;

		internal CompiledGhostTypeWrapper(string name, Type type)
			: base(name, type)
		{
		}
d5584 1
a5584 3
		internal override Type TypeAsBaseType
		{
			get
d5586 1
a5586 1
				if(typeAsBaseType == null)
d5588 5
a5592 1
					typeAsBaseType = type.GetNestedType("__Interface");
a5593 1
				return typeAsBaseType;
a5594 1
		}
d5596 1
a5596 3
		internal override FieldInfo GhostRefField
		{
			get
d5598 1
a5598 1
				if(ghostRefField == null)
d5600 1
a5600 1
					ghostRefField = type.GetField("__<ref>");
a5601 1
				return ghostRefField;
d5605 1
a5605 1
		internal override bool IsGhost
d5607 5
a5611 1
			get
d5613 1
a5613 1
				return true;
d5615 1
a5616 5
	}

	internal static string GetName(Type type)
	{
		Debug.Assert(type.Module.IsDefined(typeof(JavaModuleAttribute), false));
d5618 2
a5619 3
		// look for our custom attribute, that contains the real name of the type (for inner classes)
		Object[] attribs = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
		if(attribs.Length == 1)
d5621 10
a5630 21
			return ((InnerClassAttribute)attribs[0]).InnerClassName;
		}
		return type.FullName;
	}

	// TODO consider resolving the baseType lazily
	private static TypeWrapper GetBaseTypeWrapper(Type type)
	{
		if(type.IsInterface || type.IsDefined(typeof(GhostInterfaceAttribute), false))
		{
			return null;
		}
		else if(type.BaseType == null)
		{
			// System.Object must appear to be derived from java.lang.Object
			return CoreClasses.java.lang.Object.Wrapper;
		}
		else
		{
			object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
			if(attribs.Length == 1)
d5632 2
a5633 1
				if(((RemappedTypeAttribute)attribs[0]).Type == typeof(object))
d5635 8
a5642 5
					return null;
				}
				else
				{
					return CoreClasses.java.lang.Object.Wrapper;
d5644 1
a5645 1
			return ClassLoaderWrapper.GetWrapperFromType(type.BaseType);
a5646 15
	}

	private static ClassLoaderWrapper GetClassLoader(Type type)
	{
		return ClassLoaderWrapper.IsCoreAssemblyType(type) ? ClassLoaderWrapper.GetBootstrapClassLoader() : ClassLoaderWrapper.GetSystemClassLoader();
	}

	private CompiledTypeWrapper(string name, Type type)
		: base(GetModifiers(type), name, GetBaseTypeWrapper(type), GetClassLoader(type), null)
	{
		Debug.Assert(!(type is TypeBuilder));
		Debug.Assert(!type.IsArray);

		this.type = type;
	}
d5648 1
a5648 4
	private static Modifiers GetModifiers(Type type)
	{
		object[] customAttribute = type.GetCustomAttributes(typeof(ModifiersAttribute), false);
		if(customAttribute.Length == 1)
d5650 1
a5650 1
			return ((ModifiersAttribute)customAttribute[0]).Modifiers;
d5652 3
a5654 4
		// only returns public, protected, private, final, static, abstract and interface (as per
		// the documentation of Class.getModifiers())
		Modifiers modifiers = 0;
		if(type.IsPublic)
d5656 4
a5659 1
			modifiers |= Modifiers.Public;
d5661 2
a5662 2
		// TODO do we really need to look for nested attributes? I think all inner classes will have the ModifiersAttribute.
		else if(type.IsNestedPublic)
d5664 43
a5706 13
			modifiers |= Modifiers.Public | Modifiers.Static;
		}
		else if(type.IsNestedPrivate)
		{
			modifiers |= Modifiers.Private | Modifiers.Static;
		}
		else if(type.IsNestedFamily || type.IsNestedFamORAssem)
		{
			modifiers |= Modifiers.Protected | Modifiers.Static;
		}
		else if(type.IsNestedAssembly || type.IsNestedFamANDAssem)
		{
			modifiers |= Modifiers.Static;
d5709 1
a5709 1
		if(type.IsSealed)
d5711 4
a5714 9
			modifiers |= Modifiers.Final;
		}
		if(type.IsAbstract)
		{
			modifiers |= Modifiers.Abstract;
		}
		if(type.IsInterface)
		{
			modifiers |= Modifiers.Interface;
a5715 2
		return modifiers;
	}
d5717 1
a5717 3
	internal override bool HasStaticInitializer
	{
		get
d5719 4
a5722 1
			return type.GetField("__<clinit>", BindingFlags.NonPublic | BindingFlags.Static) != null;
a5723 1
	}
d5725 1
a5725 3
	internal override Assembly Assembly
	{
		get
d5727 26
a5752 1
			return type.Assembly;
a5753 1
	}
d5755 1
a5755 3
	internal override TypeWrapper[] Interfaces
	{
		get
d5757 1
a5757 1
			if(interfaces == null)
d5759 2
a5760 6
				// NOTE instead of getting the interfaces list from Type, we use a custom
				// attribute to list the implemented interfaces, because Java reflection only
				// reports the interfaces *directly* implemented by the type, not the inherited
				// interfaces. This is significant for serialVersionUID calculation (for example).
				object[] attribs = type.GetCustomAttributes(typeof(ImplementsAttribute), false);
				if(attribs.Length == 1)
d5762 3
a5764 3
					string[] interfaceNames = ((ImplementsAttribute)attribs[0]).Interfaces;
					TypeWrapper[] interfaceWrappers = new TypeWrapper[interfaceNames.Length];
					for(int i = 0; i < interfaceWrappers.Length; i++)
d5766 4
a5769 1
						interfaceWrappers[i] = GetClassLoader().LoadClassByDottedName(interfaceNames[i]);
d5771 1
a5771 5
					this.interfaces = interfaceWrappers;
				}
				else
				{
					interfaces = TypeWrapper.EmptyArray;
d5773 1
a5774 1
			return interfaces;
a5775 1
	}
d5777 1
a5777 3
	internal override TypeWrapper[] InnerClasses
	{
		get
d5779 1
a5779 2
			// TODO why are we caching this?
			if(innerclasses == null)
d5781 2
a5782 3
				Type[] nestedTypes = type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly);
				ArrayList wrappers = new ArrayList();
				for(int i = 0; i < nestedTypes.Length; i++)
d5784 1
a5784 4
					if(!AttributeHelper.IsHideFromJava(nestedTypes[i]))
					{
						wrappers.Add(ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]));
					}
d5786 1
a5786 1
				innerclasses = (TypeWrapper[])wrappers.ToArray(typeof(TypeWrapper));
a5787 1
			return innerclasses;
a5788 1
	}
d5790 1
a5790 3
	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
d5792 1
a5792 2
			Type declaringType = type.DeclaringType;
			if(declaringType != null)
d5794 6
a5799 1
				return ClassLoaderWrapper.GetWrapperFromType(declaringType);
a5800 1
			return null;
a5801 1
	}
d5803 1
a5803 3
	internal override Modifiers ReflectiveModifiers
	{
		get
d5805 1
a5805 2
			object[] customAttribute = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
			if(customAttribute.Length == 1)
d5807 1
a5807 1
				return ((InnerClassAttribute)customAttribute[0]).Modifiers;
a5808 9
			return Modifiers;
		}
	}

	internal override Type TypeAsBaseType
	{
		get
		{
			return type;
a5809 1
	}
d5811 1
a5811 3
	private void SigTypePatchUp(string sigtype, ref TypeWrapper type)
	{
		if(sigtype != type.SigName)
d5813 1
a5813 3
			// if type is an array, we know that it is a ghost array, because arrays of unloadable are compiled
			// as object (not as arrays of object)
			if(type.IsArray)
d5815 7
a5821 5
				type = GetClassLoader().FieldTypeWrapperFromSig(sigtype);
			}
			else
			{
				if(sigtype[0] == 'L')
d5823 5
a5827 1
					sigtype = sigtype.Substring(1, sigtype.Length - 2);
a5828 1
				type = new UnloadableTypeWrapper(sigtype);
a5830 1
	}
d5832 1
a5832 5
	private static void ParseSig(string sig, out string[] sigparam, out string sigret)
	{
		ArrayList list = new ArrayList();
		int pos = 1;
		for(;;)
d5834 3
a5836 1
			switch(sig[pos])
d5838 1
a5838 8
				case 'L':
				{
					int end = sig.IndexOf(';', pos) + 1;
					list.Add(sig.Substring(pos, end - pos));
					pos = end;
					break;
				}
				case '[':
d5840 1
a5840 3
					int skip = 1;
					while(sig[pos + skip] == '[') skip++;
					if(sig[pos + skip] == 'L')
d5845 1
d5847 1
a5847 1
					else
d5849 15
a5863 3
						skip++;
						list.Add(sig.Substring(pos, skip));
						pos += skip;
d5865 8
a5872 1
					break;
a5873 8
				case ')':
					sigparam = (string[])list.ToArray(typeof(string));
					sigret = sig.Substring(pos + 1);
					return;
				default:
					list.Add(sig.Substring(pos, 1));
					pos++;
					break;
a5875 1
	}
d5877 1
a5877 10
	private void GetNameSigFromMethodBase(MethodBase method, out string name, out string sig, out TypeWrapper retType, out TypeWrapper[] paramTypes)
	{
		retType = method is ConstructorInfo ? PrimitiveTypeWrapper.VOID : ClassLoaderWrapper.GetWrapperFromType(((MethodInfo)method).ReturnType);
		ParameterInfo[] parameters = method.GetParameters();
		paramTypes = new TypeWrapper[parameters.Length];
		for(int i = 0; i < parameters.Length; i++)
		{
			paramTypes[i] = ClassLoaderWrapper.GetWrapperFromType(parameters[i].ParameterType);
		}
		if(method.IsDefined(typeof(NameSigAttribute), false))
d5879 4
a5882 8
			NameSigAttribute attr = (NameSigAttribute)method.GetCustomAttributes(typeof(NameSigAttribute), false)[0];
			name = attr.Name;
			sig = attr.Sig;
			string[] sigparams;
			string sigret;
			ParseSig(sig, out sigparams, out sigret);
			// HACK newhelper methods have a return type, but it should be void
			if(name == "<init>")
d5884 1
a5884 1
				retType = PrimitiveTypeWrapper.VOID;
d5886 1
a5886 4
			SigTypePatchUp(sigret, ref retType);
			// if we have a remapped method, the paramTypes array contains an additional entry for "this" so we have
			// to remove that
			if(paramTypes.Length == sigparams.Length + 1)
d5888 25
a5912 15
				TypeWrapper[] temp = paramTypes;
				paramTypes = new TypeWrapper[sigparams.Length];
				Array.Copy(temp, 1, paramTypes, 0, paramTypes.Length);
			}
			Debug.Assert(sigparams.Length == paramTypes.Length);
			for(int i = 0; i < sigparams.Length; i++)
			{
				SigTypePatchUp(sigparams[i], ref paramTypes[i]);
			}
		}
		else
		{
			if(method is ConstructorInfo)
			{
				name = method.IsStatic ? "<clinit>" : "<init>";
d5916 16
a5931 6
				name = method.Name;
			}
			System.Text.StringBuilder sb = new System.Text.StringBuilder("(");
			foreach(TypeWrapper tw in paramTypes)
			{
				sb.Append(tw.SigName);
a5932 3
			sb.Append(")");
			sb.Append(retType.SigName);
			sig = sb.ToString();
a5933 1
	}
d5935 1
a5935 6
	protected override void LazyPublishMembers()
	{
		ArrayList methods = new ArrayList();
		ArrayList fields = new ArrayList();
		MemberInfo[] members = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
		foreach(MemberInfo m in members)
d5937 4
a5940 1
			if(!AttributeHelper.IsHideFromJava(m))
d5942 1
a5942 2
				MethodBase method = m as MethodBase;
				if(method != null)
d5944 14
a5957 14
					string name;
					string sig;
					TypeWrapper retType;
					TypeWrapper[] paramTypes;
					GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes);
					MethodInfo mi = method as MethodInfo;
					bool miranda = mi != null ? AttributeHelper.IsMirandaMethod(mi) : false;
					MemberFlags flags = miranda ? MemberFlags.MirandaMethod | MemberFlags.HideFromReflection : MemberFlags.None;
					methods.Add(MethodWrapper.Create(this, name, sig, method, retType, paramTypes, AttributeHelper.GetModifiers(method, false), flags));
				}
				else
				{
					FieldInfo field = m as FieldInfo;
					if(field != null)
d5959 5
a5963 1
						fields.Add(CreateFieldWrapper(field));
d5967 2
a5969 3
		SetMethods((MethodWrapper[])methods.ToArray(typeof(MethodWrapper)));
		SetFields((FieldWrapper[])fields.ToArray(typeof(FieldWrapper)));
	}
d5971 1
a5971 7
	private class CompiledRemappedMethodWrapper : SmartMethodWrapper
	{
		private MethodInfo mbHelper;
		private MethodInfo mbNonvirtualHelper;

		internal CompiledRemappedMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection, MethodInfo mbHelper, MethodInfo mbNonvirtualHelper)
			: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
d5973 2
a5974 3
			this.mbHelper = mbHelper;
			this.mbNonvirtualHelper = mbNonvirtualHelper;
		}
d5976 2
a5977 5
		protected override void CallImpl(ILGenerator ilgen)
		{
			MethodBase mb = GetMethod();
			MethodInfo mi = mb as MethodInfo;
			if(mi != null)
d5979 2
a5980 1
				ilgen.Emit(OpCodes.Call, mi);
d5982 2
a5983 1
			else
d5985 10
a5994 1
				ilgen.Emit(OpCodes.Call, (ConstructorInfo)mb);
a5995 1
		}
d5997 1
a5997 11
		protected override void CallvirtImpl(ILGenerator ilgen)
		{
			Debug.Assert(!mbHelper.IsStatic || mbHelper.Name.StartsWith("instancehelper_") || mbHelper.DeclaringType.Name == "__Helper");
			ilgen.Emit(mbHelper.IsStatic ? OpCodes.Call : OpCodes.Callvirt, mbHelper);
		}

		protected override void NewobjImpl(ILGenerator ilgen)
		{
			MethodBase mb = GetMethod();
			MethodInfo mi = mb as MethodInfo;
			if(mi != null)
d5999 2
a6000 2
				Debug.Assert(mi.Name == "newhelper");
				ilgen.Emit(OpCodes.Call, mi);
a6001 5
			else
			{
				ilgen.Emit(OpCodes.Newobj, (ConstructorInfo)mb);
			}
		}
d6003 1
a6003 5
		[HideFromJava]
		internal override object Invoke(object obj, object[] args, bool nonVirtual)
		{
			MethodBase mb;
			if(nonVirtual)
d6005 3
a6007 1
				if(DeclaringType.TypeAsBaseType.IsInstanceOfType(obj))
d6009 2
a6010 1
					mb = GetMethod();
d6012 1
a6012 1
				else if(mbNonvirtualHelper != null)
d6014 1
a6014 1
					mb = mbNonvirtualHelper;
d6016 7
a6022 1
				else if(mbHelper != null)
d6024 17
a6040 1
					mb = mbHelper;
d6044 1
a6044 2
					// we can end up here if someone calls a constructor with nonVirtual set (which is pointless, but legal)
					mb = GetMethod();
d6046 1
a6047 5
			else
			{
				mb = mbHelper != null ? mbHelper : GetMethod();
			}
			return InvokeImpl(mb, obj, args, nonVirtual);
a6048 1
	}
d6050 1
a6050 6
	private FieldWrapper CreateFieldWrapper(FieldInfo field)
	{
		Modifiers modifiers = AttributeHelper.GetModifiers(field, false);
		string name = field.Name;
		TypeWrapper type = ClassLoaderWrapper.GetWrapperFromType(field.FieldType);
		if(field.IsDefined(typeof(NameSigAttribute), false))
d6052 9
a6060 4
			NameSigAttribute attr = (NameSigAttribute)field.GetCustomAttributes(typeof(NameSigAttribute), false)[0];
			name = attr.Name;
			SigTypePatchUp(attr.Sig, ref type);
		}
d6062 18
a6079 13
		// If the backing field is private, but the modifiers aren't, we've got a final field that
		// has a property accessor method.
		if(field.IsPrivate && ((modifiers & Modifiers.Private) == 0))
		{
			BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public;
			bindingFlags |= field.IsStatic ? BindingFlags.Static : BindingFlags.Instance;
			PropertyInfo prop = field.DeclaringType.GetProperty(field.Name, bindingFlags, null, field.FieldType, Type.EmptyTypes, null);
			MethodInfo getter = prop.GetGetMethod(true);
			return new GetterFieldWrapper(this, type, field, name, type.SigName, modifiers, getter);
		}
		else if(field.IsLiteral)
		{
			return new ConstantFieldWrapper(this, type, name, type.SigName, modifiers, field, null);
a6080 5
		else
		{
			return FieldWrapper.Create(this, type, field, name, type.SigName, modifiers);
		}
	}
d6082 1
a6082 3
	internal override Type TypeAsTBD
	{
		get
d6084 4
a6087 1
			return type;
a6088 1
	}
d6090 1
a6090 3
	internal override bool IsMapUnsafeException
	{
		get
d6092 1
a6092 46
			return type.IsDefined(typeof(ExceptionIsUnsafeForMappingAttribute), false);
		}
	}

	internal override void Finish(bool forDebugSave)
	{
	}
}

sealed class Whidbey
{
	private static readonly object[] noargs = new object[0];
	private static readonly MethodInfo get_IsGenericTypeDefinition = typeof(Type).GetMethod("get_IsGenericTypeDefinition");
	private static readonly MethodInfo get_IsGenericMethodDefinition = typeof(MethodBase).GetMethod("get_IsGenericMethodDefinition");

	internal static bool IsGenericTypeDefinition(Type type)
	{
		return get_IsGenericTypeDefinition != null && (bool)get_IsGenericTypeDefinition.Invoke(type, noargs);
	}

	internal static bool IsGenericMethodDefinition(MethodBase mb)
	{
		return get_IsGenericMethodDefinition != null && (bool)get_IsGenericMethodDefinition.Invoke(mb, noargs);
	}
}

sealed class DotNetTypeWrapper : TypeWrapper
{
	private const string NamePrefix = "cli.";
	private const string DelegateInterfaceSuffix = "$Method";
	private readonly Type type;
	private TypeWrapper[] innerClasses;
	private TypeWrapper outerClass;
	private TypeWrapper[] interfaces;

	private static Modifiers GetModifiers(Type type)
	{
		Modifiers modifiers = 0;
		if(type.IsPublic)
		{
			modifiers |= Modifiers.Public;
		}
		else if(type.IsNestedPublic)
		{
			modifiers |= Modifiers.Static;
			if(IsVisible(type))
d6094 1
a6094 1
				modifiers |= Modifiers.Public;
a6096 12
		else if(type.IsNestedPrivate)
		{
			modifiers |= Modifiers.Private | Modifiers.Static;
		}
		else if(type.IsNestedFamily || type.IsNestedFamORAssem)
		{
			modifiers |= Modifiers.Protected | Modifiers.Static;
		}
		else if(type.IsNestedAssembly || type.IsNestedFamANDAssem)
		{
			modifiers |= Modifiers.Static;
		}
d6098 1
a6098 9
		if(type.IsSealed)
		{
			modifiers |= Modifiers.Final;
		}
		else if(type.IsAbstract) // we can't be abstract if we're final
		{
			modifiers |= Modifiers.Abstract;
		}
		if(type.IsInterface)
a6099 1
			modifiers |= Modifiers.Interface;
a6100 1
		return modifiers;
d6103 1
a6103 3
	// NOTE when this is called on a remapped type, the "warped" underlying type name is returned.
	// E.g. GetName(typeof(object)) returns "cli.System.Object".
	internal static string GetName(Type type)
d6105 3
a6107 1
		Debug.Assert(!type.IsArray && !type.Module.IsDefined(typeof(JavaModuleAttribute), false));
d6109 1
a6109 1
		if(type.IsDefined(typeof(NoPackagePrefixAttribute), false) || type.Assembly.IsDefined(typeof(NoPackagePrefixAttribute), false))
d6111 1
a6111 2
			// TODO figure out if this is even required
			return type.FullName.Replace('+', '$');
d6114 1
a6114 15
		return MangleTypeName(type.FullName);
	}

	private static string MangleTypeName(string name)
	{
		// TODO a fully reversible name mangling should be used (all characters not supported by Java should be escaped)
		return NamePrefix + name.Replace('+', '$');
	}

	private static string DemangleTypeName(string name)
	{
		Debug.Assert(name.StartsWith(NamePrefix));
		// TODO a fully reversible name mangling should be used (all characters not supported by Java should be escaped)
		name = name.Substring(NamePrefix.Length);
		if(name.EndsWith(DelegateInterfaceSuffix))
d6116 1
a6116 2
			// HACK if we're a delegate nested type, don't replace the $ sign
			return name;
a6117 1
		return name.Replace('$', '+');
d6120 1
a6120 4
	// this method returns a new TypeWrapper instance for each invocation (doesn't prevent duplicates)
	// the caller is responsible for making sure that only one TypeWrapper with the specified name escapes
	// out into the world
	internal static TypeWrapper CreateDotNetTypeWrapper(string name)
d6122 8
a6129 2
		bool prefixed = name.StartsWith(NamePrefix);
		if(prefixed)
d6131 2
a6132 9
			name = DemangleTypeName(name);
		}
		Type type = LoadTypeFromLoadedAssemblies(name);
		if(type != null)
		{
			// SECURITY we never expose types from IKVM.Runtime, because doing so would lead to a security hole,
			// since the reflection implementation lives inside this assembly, all internal members would
			// be accessible through Java reflection.
			if(type.Assembly == typeof(DotNetTypeWrapper).Assembly)
d6134 1
a6134 1
				return null;
d6136 1
a6136 1
			if(Whidbey.IsGenericTypeDefinition(type))
d6138 5
a6142 5
				return null;
			}
			if(prefixed || type.IsDefined(typeof(NoPackagePrefixAttribute), false) || type.Assembly.IsDefined(typeof(NoPackagePrefixAttribute), false))
			{
				return new DotNetTypeWrapper(type);
d6144 1
a6144 5
		}
		if(name.EndsWith(DelegateInterfaceSuffix))
		{
			Type delegateType = LoadTypeFromLoadedAssemblies(name.Substring(0, name.Length - DelegateInterfaceSuffix.Length));
			if(delegateType != null && IsDelegate(delegateType))
d6146 1
a6146 13
				MethodInfo invoke = delegateType.GetMethod("Invoke");
				ParameterInfo[] parameters = invoke.GetParameters();
				Type[] args = new Type[parameters.Length];
				for(int i = 0; i < args.Length; i++)
				{
					// we know there aren't any unsupported parameter types, because IsDelegate() returned true
					args[i] = parameters[i].ParameterType;
				}
				ModuleBuilder moduleBuilder = ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder;
				TypeBuilder typeBuilder = moduleBuilder.DefineType(NamePrefix + name, TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract);
				AttributeHelper.SetInnerClass(typeBuilder, NamePrefix + name, NamePrefix + delegateType.FullName, "Method", Modifiers.Public | Modifiers.Interface | Modifiers.Static | Modifiers.Abstract);
				typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Abstract | MethodAttributes.Virtual, CallingConventions.Standard, invoke.ReturnType, args);
				return CompiledTypeWrapper.newInstance(NamePrefix + name, typeBuilder.CreateType());
d6148 1
a6148 10
		}
		return null;
	}

	private static Type LoadTypeFromLoadedAssemblies(string name)
	{
		foreach(Assembly a in AppDomain.CurrentDomain.GetAssemblies())
		{
			// HACK we also look inside Java assemblies, because precompiled delegate interfaces might have ended up there
			if(!(a is AssemblyBuilder))
d6150 1
a6150 12
				Type t = a.GetType(name);
				if(t != null)
				{
					return t;
				}
				// HACK we might be looking for an inner classes
				// (if we remove the mangling of NoPackagePrefix types from GetName, we don't need this anymore)
				t = a.GetType(name.Replace('$', '+'));
				if(t != null)
				{
					return t;
				}
d6152 1
a6152 22
		}
		return null;
	}

	internal static TypeWrapper GetWrapperFromDotNetType(Type type)
	{
		// TODO there should be a better way
		return ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(DotNetTypeWrapper.GetName(type));
	}

	private static TypeWrapper GetBaseTypeWrapper(Type type)
	{
		if(type.IsInterface)
		{
			return null;
		}
		else if(ClassLoaderWrapper.IsRemappedType(type))
		{
			// Remapped types extend their alter ego
			// (e.g. cli.System.Object must appear to be derived from java.lang.Object)
			// except when they're sealed, of course.
			if(type.IsSealed)
d6154 1
a6154 1
				return CoreClasses.java.lang.Object.Wrapper;
a6155 40
			return ClassLoaderWrapper.GetWrapperFromType(type);
		}
		else if(ClassLoaderWrapper.IsRemappedType(type.BaseType))
		{
			return GetWrapperFromDotNetType(type.BaseType);
		}
		else
		{
			return ClassLoaderWrapper.GetWrapperFromType(type.BaseType);
		}
	}

	internal DotNetTypeWrapper(Type type)
		: base(GetModifiers(type), GetName(type), GetBaseTypeWrapper(type), null, null)
	{
		Debug.Assert(!(type.IsByRef), type.FullName);
		Debug.Assert(!(type.IsPointer), type.FullName);
		Debug.Assert(!(type.IsArray), type.FullName);
		Debug.Assert(!(type is TypeBuilder), type.FullName);
		Debug.Assert(!(type.Module.IsDefined(typeof(JavaModuleAttribute), false)));

		this.type = type;
	}

	internal override ClassLoaderWrapper GetClassLoader()
	{
		return ClassLoaderWrapper.GetSystemClassLoader();
	}

	private class DelegateMethodWrapper : MethodWrapper
	{
		private ConstructorInfo delegateConstructor;
		private MethodInfo method;

		internal DelegateMethodWrapper(TypeWrapper declaringType, Type delegateType, TypeWrapper iface)
			: base(declaringType, "<init>", "(" + iface.SigName + ")V", null, PrimitiveTypeWrapper.VOID, new TypeWrapper[] { iface }, Modifiers.Public, MemberFlags.None)
		{
			this.delegateConstructor = delegateType.GetConstructor(new Type[] { typeof(object), typeof(IntPtr) });
			this.method = iface.TypeAsTBD.GetMethod("Invoke");
		}
d6157 13
a6169 5
		internal override void EmitNewobj(ILGenerator ilgen)
		{
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Ldvirtftn, method);
			ilgen.Emit(OpCodes.Newobj, delegateConstructor);
d6172 3
a6174 15
		[HideFromJava]
		internal override object Invoke(object obj, object[] args, bool nonVirtual)
		{
			// TODO map exceptions
			return Delegate.CreateDelegate(DeclaringType.TypeAsTBD, args[0], "Invoke");
		}
	}

	private class ByRefMethodWrapper : SmartMethodWrapper
	{
		private bool[] byrefs;
		private Type[] args;

		internal ByRefMethodWrapper(Type[] args, bool[] byrefs, TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection)
			: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
d6176 1
a6176 3
			this.args = args;
			this.byrefs = byrefs;
		}
d6178 1
a6178 5
		protected override void CallImpl(ILGenerator ilgen)
		{
			MethodBase mb = GetMethod();
			MethodInfo mi = mb as MethodInfo;
			if(mi != null)
d6180 2
a6181 5
				ilgen.Emit(OpCodes.Call, mi);
			}
			else
			{
				ilgen.Emit(OpCodes.Call, (ConstructorInfo)mb);
d6183 2
d6187 1
a6187 1
		protected override void CallvirtImpl(ILGenerator ilgen)
d6189 2
a6190 1
			ilgen.Emit(OpCodes.Callvirt, (MethodInfo)GetMethod());
d6193 1
a6193 1
		protected override void NewobjImpl(ILGenerator ilgen)
d6195 9
a6203 1
			ilgen.Emit(OpCodes.Newobj, (ConstructorInfo)GetMethod());
d6206 4
a6209 1
		protected override void PreEmit(ILGenerator ilgen)
d6211 7
a6217 2
			LocalBuilder[] locals = new LocalBuilder[args.Length];
			for(int i = args.Length - 1; i >= 0; i--)
d6219 12
a6230 2
				Type type = args[i];
				if(type.IsByRef)
d6232 1
a6232 1
					type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
a6233 2
				locals[i] = ilgen.DeclareLocal(type);
				ilgen.Emit(OpCodes.Stloc, locals[i]);
d6235 1
a6235 1
			for(int i = 0; i < args.Length; i++)
d6237 2
a6238 2
				ilgen.Emit(OpCodes.Ldloc, locals[i]);
				if(args[i].IsByRef)
d6240 13
a6252 2
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ldelema, args[i].GetElementType());
d6255 1
a6255 1
			base.PreEmit(ilgen);
d6258 1
a6258 2
		[HideFromJava]
		internal override object Invoke(object obj, object[] args, bool nonVirtual)
d6260 1
a6260 2
			object[] newargs = (object[])args.Clone();
			for(int i = 0; i < newargs.Length; i++)
d6262 2
a6263 1
				if(byrefs[i])
d6265 9
a6273 12
					newargs[i] = ((Array)args[i]).GetValue(0);
				}
			}
			try
			{
				return base.Invoke(obj, newargs, nonVirtual);
			}
			finally
			{
				for(int i = 0; i < newargs.Length; i++)
				{
					if(byrefs[i])
d6275 1
a6275 1
						((Array)args[i]).SetValue(newargs[i], 0);
d6279 1
a6279 20
		}
	}

	internal static bool IsVisible(Type type)
	{
		return type.IsPublic || (type.IsNestedPublic && IsVisible(type.DeclaringType));
	}

	private class EnumWrapMethodWrapper : MethodWrapper
	{
		internal EnumWrapMethodWrapper(DotNetTypeWrapper tw, TypeWrapper fieldType)
			: base(tw, "wrap", "(" + fieldType.SigName + ")" + tw.SigName, null, tw, new TypeWrapper[] { fieldType }, Modifiers.Static | Modifiers.Public, MemberFlags.None)
		{
		}

		internal override void EmitCall(ILGenerator ilgen)
		{
			// We don't actually need to do anything here!
			// The compiler will insert a boxing operation after calling us and that will
			// result in our argument being boxed (since that's still sitting on the stack).
d6282 1
a6282 12
		[HideFromJava]
		internal override object Invoke(object obj, object[] args, bool nonVirtual)
		{
			return Enum.ToObject(DeclaringType.TypeAsTBD, ((IConvertible)args[0]).ToInt64(null));
		}
	}

	internal class EnumValueFieldWrapper : FieldWrapper
	{
		// NOTE if the reference on the stack is null, we *want* the NullReferenceException, so we don't use TypeWrapper.EmitUnbox
		internal EnumValueFieldWrapper(DotNetTypeWrapper tw, TypeWrapper fieldType)
			: base(tw, fieldType, "Value", fieldType.SigName, Modifiers.Public | Modifiers.Final, null)
d6284 2
d6288 1
a6288 1
		protected override void EmitGetImpl(ILGenerator ilgen)
d6290 1
a6290 7
			DotNetTypeWrapper tw = (DotNetTypeWrapper)this.DeclaringType;
			ilgen.Emit(OpCodes.Unbox, tw.type);
			// FXBUG the .NET 1.1 verifier doesn't understand that ldobj on an enum that has an underlying type
			// of byte or short that the resulting type on the stack is an int32, so we have to
			// to it the hard way. Note that this is fixed in Whidbey.
			Type underlyingType = Enum.GetUnderlyingType(tw.type);
			if(underlyingType == typeof(sbyte) || underlyingType == typeof(byte))
d6292 1
a6292 1
				ilgen.Emit(OpCodes.Ldind_I1);
d6294 1
a6294 1
			else if(underlyingType == typeof(short) || underlyingType == typeof(ushort))
d6296 8
a6303 1
				ilgen.Emit(OpCodes.Ldind_I2);
d6305 1
a6305 1
			else if(underlyingType == typeof(int) || underlyingType == typeof(uint))
d6307 1
a6307 1
				ilgen.Emit(OpCodes.Ldind_I4);
d6309 1
a6309 1
			else if(underlyingType == typeof(long) || underlyingType == typeof(ulong))
d6311 1
a6311 1
				ilgen.Emit(OpCodes.Ldind_I8);
d6315 2
a6316 1
		protected override void EmitSetImpl(ILGenerator ilgen)
d6318 7
a6324 1
			throw new InvalidOperationException();
d6327 1
a6327 1
		internal override void SetValue(object obj, object val)
d6329 1
a6329 4
			// NOTE even though the field is final, JNI reflection can still be used to set its value!
			// NOTE the CLI spec says that an enum has exactly one instance field, so we take advantage of that fact.
			FieldInfo f = DeclaringType.TypeAsTBD.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)[0];
			f.SetValue(obj, val);
d6332 1
a6332 3
		// this method takes a boxed Enum and returns its value as a boxed primitive
		// of the subset of Java primitives (i.e. byte, short, int, long)
		internal static object GetEnumPrimitiveValue(object obj)
d6334 11
a6344 2
			Type underlyingType = Enum.GetUnderlyingType(obj.GetType());
			if(underlyingType == typeof(sbyte) || underlyingType == typeof(byte))
d6346 3
a6348 1
				return unchecked((byte)((IConvertible)obj).ToInt32(null));
d6350 3
a6352 1
			else if(underlyingType == typeof(short) || underlyingType == typeof(ushort))
d6354 2
a6355 1
				return unchecked((short)((IConvertible)obj).ToInt32(null));
d6357 9
a6365 1
			else if(underlyingType == typeof(int))
d6367 2
a6368 1
				return ((IConvertible)obj).ToInt32(null);
d6370 2
a6371 1
			else if(underlyingType == typeof(uint))
d6373 10
a6382 1
				return unchecked((int)((IConvertible)obj).ToUInt32(null));
d6384 2
a6385 1
			else if(underlyingType == typeof(long))
d6387 1
a6387 1
				return ((IConvertible)obj).ToInt64(null);
d6389 2
a6390 1
			else if(underlyingType == typeof(ulong))
d6392 1
a6392 1
				return unchecked((long)((IConvertible)obj).ToUInt64(null));
d6394 2
a6395 1
			else
d6397 21
a6417 1
				throw new InvalidOperationException();
a6418 1
		}
d6420 26
a6445 3
		internal override object GetValue(object obj)
		{
			return GetEnumPrimitiveValue(obj);
a6446 1
	}
d6448 1
a6448 3
	internal override Assembly Assembly
	{
		get
d6450 1
a6450 1
			return type.Assembly;
a6451 1
	}
d6453 1
a6453 4
	private class ValueTypeDefaultCtor : MethodWrapper
	{
		internal ValueTypeDefaultCtor(DotNetTypeWrapper tw)
			: base(tw, "<init>", "()V", null, PrimitiveTypeWrapper.VOID, TypeWrapper.EmptyArray, Modifiers.Public, MemberFlags.None)
d6455 4
a6458 1
		}
d6460 6
a6465 6
		internal override void EmitNewobj(ILGenerator ilgen)
		{
			LocalBuilder local = ilgen.DeclareLocal(DeclaringType.TypeAsTBD);
			ilgen.Emit(OpCodes.Ldloc, local);
			ilgen.Emit(OpCodes.Box, DeclaringType.TypeAsTBD);
		}
d6467 2
a6468 4
		[HideFromJava]
		internal override object Invoke(object obj, object[] args, bool nonVirtual)
		{
			if(obj == null)
d6470 1
a6470 1
				obj = Activator.CreateInstance(DeclaringType.TypeAsTBD);
a6471 1
			return obj;
a6472 1
	}
d6474 1
a6474 6
	protected override void LazyPublishMembers()
	{
		ArrayList fieldsList = new ArrayList();
		ArrayList methodsList = new ArrayList();
		// special support for enums
		if(type.IsEnum)
d6476 3
a6478 2
			Type underlyingType = Enum.GetUnderlyingType(type);
			if(underlyingType == typeof(sbyte))
a6479 1
				underlyingType = typeof(byte);
d6481 2
a6482 1
			else if(underlyingType == typeof(ushort))
d6484 22
a6505 1
				underlyingType = typeof(short);
d6507 2
a6508 1
			else if(underlyingType == typeof(uint))
d6510 1
a6510 1
				underlyingType = typeof(int);
d6512 2
a6513 1
			else if(underlyingType == typeof(ulong))
d6515 4
a6518 1
				underlyingType = typeof(long);
d6520 4
a6523 3
			TypeWrapper fieldType = ClassLoaderWrapper.GetWrapperFromType(underlyingType);
			FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Static);
			for(int i = 0; i < fields.Length; i++)
d6525 18
a6542 1
				if(fields[i].FieldType == type)
d6544 1
a6544 11
					string name = fields[i].Name;
					if(name == "Value")
					{
						name = "_Value";
					}
					else if(name.StartsWith("_") && name.EndsWith("Value"))
					{
						name = "_" + name;
					}
					object val = EnumValueFieldWrapper.GetEnumPrimitiveValue(fields[i].GetValue(null));
					fieldsList.Add(new ConstantFieldWrapper(this, fieldType, name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], val));
d6546 1
a6546 11
			}
			fieldsList.Add(new EnumValueFieldWrapper(this, fieldType));
			methodsList.Add(new EnumWrapMethodWrapper(this, fieldType));
		}
		else
		{
			FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			for(int i = 0; i < fields.Length; i++)
			{
				// TODO for remapped types, instance fields need to be converted to static getter/setter methods
				if(fields[i].FieldType.IsPointer)
d6548 1
a6548 1
					// skip, pointer fields are not supported
d6552 1
a6552 2
					// TODO handle name/signature clash
					fieldsList.Add(CreateFieldWrapperDotNet(AttributeHelper.GetModifiers(fields[i], true), fields[i].Name, fields[i].FieldType, fields[i]));
d6556 22
a6577 2
			// special case for delegate constructors!
			if(IsDelegate(type))
d6579 3
a6581 4
				TypeWrapper iface = InnerClasses[0];
				Debug.Assert(iface is CompiledTypeWrapper);
				iface.Finish();
				methodsList.Add(new DelegateMethodWrapper(this, type, iface));
d6584 10
a6593 1
			bool fabricateDefaultCtor = type.IsValueType;
d6595 6
a6600 2
			ConstructorInfo[] constructors = type.GetConstructors(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			for(int i = 0; i < constructors.Length; i++)
d6602 20
a6621 3
				string name;
				string sig;
				if(MakeMethodDescriptor(constructors[i], out name, out sig))
d6623 1
a6623 1
					if(fabricateDefaultCtor && !constructors[i].IsStatic && sig == "()V")
d6625 11
a6635 1
						fabricateDefaultCtor = false;
a6636 2
					// TODO handle name/signature clash
					methodsList.Add(CreateMethodWrapper(name, sig, constructors[i], false));
d6638 2
d6641 1
a6641 2

			if(fabricateDefaultCtor)
d6643 14
a6656 3
				// Value types have an implicit default ctor
				methodsList.Add(new ValueTypeDefaultCtor(this));
			}
d6658 2
a6659 4
			MethodInfo[] methods = type.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			for(int i = 0; i < methods.Length; i++)
			{
				if(methods[i].IsStatic && type.IsInterface)
d6661 4
a6664 1
					// skip, Java cannot deal with static methods on interfaces
d6666 5
a6670 1
				else
d6674 25
a6698 1
					if(MakeMethodDescriptor(methods[i], out name, out sig))
d6700 3
a6702 1
						if(!methods[i].IsStatic && !methods[i].IsPrivate && BaseTypeWrapper != null)
d6704 1
a6704 2
							MethodWrapper baseMethod = BaseTypeWrapper.GetMethodWrapper(name, sig, true);
							if(baseMethod != null && baseMethod.IsFinal && !baseMethod.IsStatic && !baseMethod.IsPrivate)
d6706 5
a6710 1
								continue;
d6712 2
a6714 2
						// TODO handle name/signature clash
						methodsList.Add(CreateMethodWrapper(name, sig, methods[i], false));
a6716 1
			}
d6718 3
a6720 7
			// HACK private interface implementations need to be published as well
			// (otherwise the type appears abstract while it isn't)
			if(!type.IsInterface)
			{
				Hashtable clash = null;
				Type[] interfaces = type.GetInterfaces();
				for(int i = 0; i < interfaces.Length; i++)
d6722 3
a6724 1
					if(interfaces[i].IsPublic)
d6726 1
a6726 2
						InterfaceMapping map = type.GetInterfaceMap(interfaces[i]);
						for(int j = 0; j < map.InterfaceMethods.Length; j++)
d6728 2
a6729 1
							if(!map.TargetMethods[j].IsPublic && map.TargetMethods[j].DeclaringType == type)
d6731 1
a6731 3
								string name;
								string sig;
								if(MakeMethodDescriptor(map.InterfaceMethods[j], out name, out sig))
d6733 3
a6735 1
									if(BaseTypeWrapper != null)
d6737 9
a6745 2
										MethodWrapper baseMethod = BaseTypeWrapper.GetMethodWrapper(name, sig, true);
										if(baseMethod != null && !baseMethod.IsStatic && baseMethod.IsPublic)
d6747 5
a6751 1
											continue;
d6753 1
a6753 5
									}
									if(clash == null)
									{
										clash = new Hashtable();
										foreach(MethodWrapper mw in methodsList)
d6755 3
a6757 7
											clash.Add(mw.Name + mw.Signature, null);
										}										
									}
									if(!clash.ContainsKey(name + sig))
									{
										clash.Add(name + sig, null);
										methodsList.Add(CreateMethodWrapper(name, sig, map.InterfaceMethods[j], true));
a6763 1
			}
d6765 10
a6774 12
			// for non-final remapped types, we need to add all the virtual methods in our alter ego (which
			// appears as our base class) and make them final (to prevent Java code from overriding these
			// methods, which don't really exist).
			if(ClassLoaderWrapper.IsRemappedType(type) && !type.IsSealed && !type.IsInterface)
			{
				// Finish the type, to make sure the methods are populated
				this.BaseTypeWrapper.Finish();
				Hashtable h = new Hashtable();
				TypeWrapper baseTypeWrapper = this.BaseTypeWrapper;
				while(baseTypeWrapper != null)
				{
					foreach(MethodWrapper m in baseTypeWrapper.GetMethods())
d6776 1
a6776 1
						if(!m.IsStatic && !m.IsFinal && (m.IsPublic || m.IsProtected) && m.Name != "<init>")
d6778 1
a6778 1
							if(!h.ContainsKey(m.Name + m.Signature))
d6780 6
a6785 3
								h.Add(m.Name + m.Signature, "");
								// TODO handle name/sig clash (what should we do?)
								methodsList.Add(new BaseFinalMethodWrapper(this, m));
d6788 1
a6789 1
					baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
d6792 2
a6794 7
		SetMethods((MethodWrapper[])methodsList.ToArray(typeof(MethodWrapper)));
		SetFields((FieldWrapper[])fieldsList.ToArray(typeof(FieldWrapper)));
	}

	private class BaseFinalMethodWrapper : MethodWrapper
	{
		private MethodWrapper m;
d6796 1
a6796 2
		internal BaseFinalMethodWrapper(DotNetTypeWrapper tw, MethodWrapper m)
			: base(tw, m.Name, m.Signature, m.GetMethod(), m.ReturnType, m.GetParameters(), m.Modifiers | Modifiers.Final, MemberFlags.None)
d6798 7
a6804 2
			this.m = m;
		}
d6806 6
a6811 6
		internal override void EmitCall(ILGenerator ilgen)
		{
			// we direct EmitCall to EmitCallvirt, because we always want to end up at the instancehelper method
			// (EmitCall would go to our alter ego .NET type and that wouldn't be legal)
			m.EmitCallvirt(ilgen);
		}
d6813 4
a6816 4
		internal override void EmitCallvirt(ILGenerator ilgen)
		{
			m.EmitCallvirt(ilgen);
		}
d6818 5
a6822 4
		[HideFromJava]
		internal override object Invoke(object obj, object[] args, bool nonVirtual)
		{
			return m.Invoke(obj, args, nonVirtual);
a6823 1
	}
d6825 1
a6825 13
	private bool MakeMethodDescriptor(MethodBase mb, out string name, out string sig)
	{
		if(Whidbey.IsGenericMethodDefinition(mb))
		{
			name = null;
			sig = null;
			return false;
		}
		System.Text.StringBuilder sb = new System.Text.StringBuilder();
		sb.Append('(');
		ParameterInfo[] parameters = mb.GetParameters();
		TypeWrapper[] args = new TypeWrapper[parameters.Length];
		for(int i = 0; i < parameters.Length; i++)
d6827 1
a6827 2
			Type type = parameters[i].ParameterType;
			if(type.IsPointer)
d6833 5
a6837 1
			if(type.IsByRef)
d6839 2
a6840 1
				if(type.GetElementType().IsPointer)
d6846 1
a6846 2
				type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
				if(mb.IsAbstract)
d6848 15
a6862 5
					// Since we cannot override methods with byref arguments, we don't report abstract
					// methods with byref args.
					name = null;
					sig = null;
					return false;
d6864 3
d6868 2
a6869 9
			TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(type);
			args[i] = tw;
			sb.Append(tw.SigName);
		}
		sb.Append(')');
		if(mb is ConstructorInfo)
		{
			TypeWrapper ret = PrimitiveTypeWrapper.VOID;
			if(mb.IsStatic)
d6871 12
a6882 1
				name = "<clinit>";
d6886 12
a6897 14
				name = "<init>";
			}
			sb.Append(ret.SigName);
			sig = sb.ToString();
			return true;
		}
		else
		{
			Type type = ((MethodInfo)mb).ReturnType;
			if(type.IsPointer || type.IsByRef)
			{
				name = null;
				sig = null;
				return false;
a6898 5
			TypeWrapper ret = ClassLoaderWrapper.GetWrapperFromType(type);
			sb.Append(ret.SigName);
			name = mb.Name;
			sig = sb.ToString();
			return true;
a6899 1
	}
d6901 1
a6901 3
	internal override TypeWrapper[] Interfaces
	{
		get
d6903 1
a6903 1
			lock(this)
d6905 1
a6905 1
				if(interfaces == null)
d6907 1
a6907 3
					Type[] interfaceTypes = type.GetInterfaces();
					interfaces = new TypeWrapper[interfaceTypes.Length];
					for(int i = 0; i < interfaces.Length; i++)
d6909 15
a6923 10
						if(interfaceTypes[i].DeclaringType != null &&
							interfaceTypes[i].IsDefined(typeof(HideFromJavaAttribute), false) &&
							interfaceTypes[i].Name == "__Interface")
						{
							// we have to return the declaring type for ghost interfaces
							interfaces[i] = ClassLoaderWrapper.GetWrapperFromType(interfaceTypes[i].DeclaringType);
						}
						else
						{
							interfaces[i] = ClassLoaderWrapper.GetWrapperFromType(interfaceTypes[i]);
d6926 1
a6927 1
				return interfaces;
a6929 1
	}
d6931 1
a6931 7
	private static bool IsDelegate(Type type)
	{
		// HACK non-public delegates do not get the special treatment (because they are likely to refer to
		// non-public types in the arg list and they're not really useful anyway)
		// NOTE we don't have to check in what assembly the type lives, because this is a DotNetTypeWrapper,
		// we know that it is a different assembly.
		if(!type.IsAbstract && type.IsSubclassOf(typeof(MulticastDelegate)) && IsVisible(type))
d6933 5
a6937 2
			MethodInfo invoke = type.GetMethod("Invoke");
			if(invoke != null)
d6939 2
a6940 1
				foreach(ParameterInfo p in invoke.GetParameters())
d6942 1
a6942 2
					// TODO at the moment we don't support delegates with pointer or byref parameters
					if(p.ParameterType.IsPointer || p.ParameterType.IsByRef)
d6944 5
a6948 1
						return false;
d6950 1
a6951 1
				return true;
d6953 1
a6954 2
		return false;
	}
d6956 1
a6956 3
	internal override TypeWrapper[] InnerClasses
	{
		get
d6958 1
a6958 1
			lock(this)
d6960 1
a6960 1
				if(innerClasses == null)
d6962 1
a6962 1
					if(IsDelegate(type))
d6964 5
a6968 7
						innerClasses = new TypeWrapper[] { ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(Name + DelegateInterfaceSuffix) };
					}
					else
					{
						Type[] nestedTypes = type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic);
						ArrayList list = new ArrayList(nestedTypes.Length);
						for(int i = 0; i < nestedTypes.Length; i++)
d6970 3
a6972 1
							if(!Whidbey.IsGenericTypeDefinition(nestedTypes[i]))
d6974 4
a6977 1
								list.Add(ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]));
d6979 1
a6980 1
						innerClasses = (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
d6983 1
a6984 1
			return innerClasses;
a6985 1
	}
d6987 1
a6987 3
	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
d6989 1
a6989 1
			if(outerClass == null)
d6991 1
a6991 2
				Type outer = type.DeclaringType;
				if(outer != null)
d6993 5
a6997 1
					outerClass = ClassLoaderWrapper.GetWrapperFromType(outer);
d6999 1
a7000 1
			return outerClass;
a7001 1
	}
d7003 1
a7003 3
	internal override Modifiers ReflectiveModifiers
	{
		get
d7005 1
a7005 1
			if(DeclaringTypeWrapper != null)
d7007 5
a7011 1
				return Modifiers | Modifiers.Static;
a7012 1
			return Modifiers;
a7013 1
	}
d7015 1
a7015 4
	private FieldWrapper CreateFieldWrapperDotNet(Modifiers modifiers, string name, Type fieldType, FieldInfo field)
	{
		TypeWrapper type = ClassLoaderWrapper.GetWrapperFromType(fieldType);
		if(field.IsLiteral)
d7017 9
a7025 5
			return new ConstantFieldWrapper(this, type, name, type.SigName, modifiers, field, null);
		}
		else
		{
			return FieldWrapper.Create(this, type, field, name, type.SigName, modifiers);
a7026 1
	}
d7028 1
a7028 5
	private MethodWrapper CreateMethodWrapper(string name, string sig, MethodBase mb, bool privateInterfaceImplHack)
	{
		Modifiers mods = AttributeHelper.GetModifiers(mb, true);
		if(name == "Finalize" && sig == "()V" && !mb.IsStatic &&
			TypeAsBaseType.IsSubclassOf(CoreClasses.java.lang.Object.Wrapper.TypeAsBaseType))
d7030 14
a7043 13
			// TODO if the .NET also has a "finalize" method, we need to hide that one (or rename it, or whatever)
			MethodWrapper mw = new SimpleCallMethodWrapper(this, "finalize", "()V", (MethodInfo)mb, null, null, mods, MemberFlags.None, SimpleOpCode.Call, SimpleOpCode.Callvirt);
			mw.SetDeclaredExceptions(new string[] { "java.lang.Throwable" });
			return mw;
		}
		ParameterInfo[] parameters = mb.GetParameters();
		Type[] args = new Type[parameters.Length];
		bool hasByRefArgs = false;
		bool[] byrefs = null;
		for(int i = 0; i < parameters.Length; i++)
		{
			args[i] = parameters[i].ParameterType;
			if(parameters[i].ParameterType.IsByRef)
d7045 2
a7046 1
				if(byrefs == null)
d7048 6
a7053 1
					byrefs = new bool[args.Length];
a7054 2
				byrefs[i] = true;
				hasByRefArgs = true;
d7056 1
a7056 9
		}
		if(privateInterfaceImplHack)
		{
			mods &= ~Modifiers.Abstract;
			mods |= Modifiers.Final;
		}
		if(hasByRefArgs)
		{
			if(!(mb is ConstructorInfo) && !mb.IsStatic)
d7058 1
d7061 1
a7061 6
			// TODO pass in the argument and return types
			return new ByRefMethodWrapper(args, byrefs, this, name, sig, mb, null, null, mods, false);
		}
		else
		{
			if(mb is ConstructorInfo)
d7063 4
d7068 1
a7068 1
				return new SmartConstructorMethodWrapper(this, name, sig, (ConstructorInfo)mb, null, mods, MemberFlags.None);
d7072 10
a7081 2
				// TODO pass in the argument and return types
				return new SmartCallMethodWrapper(this, name, sig, (MethodInfo)mb, null, null, mods, MemberFlags.None, SimpleOpCode.Call, SimpleOpCode.Callvirt);
a7083 1
	}
d7085 1
a7085 3
	internal override Type TypeAsTBD
	{
		get
d7087 4
a7090 1
			return type;
a7091 1
	}
d7093 1
a7093 3
	internal override bool IsRemapped
	{
		get
d7095 4
a7098 1
			return ClassLoaderWrapper.IsRemappedType(type);
a7099 1
	}
d7101 1
a7101 3
	internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
	{
		if(IsRemapped)
d7103 1
a7103 3
			TypeWrapper shadow = ClassLoaderWrapper.GetWrapperFromTypeFast(type);
			MethodInfo method = shadow.TypeAsBaseType.GetMethod("__<instanceof>");
			if(method != null)
d7105 7
a7111 2
				ilgen.Emit(OpCodes.Call, method);
				return;
d7113 3
a7116 4
		ilgen.Emit(OpCodes.Isinst, type);
		ilgen.Emit(OpCodes.Ldnull);
		ilgen.Emit(OpCodes.Cgt_Un);
	}
d7118 1
a7118 3
	internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
	{
		if(IsRemapped)
d7120 1
a7120 3
			TypeWrapper shadow = ClassLoaderWrapper.GetWrapperFromTypeFast(type);
			MethodInfo method = shadow.TypeAsBaseType.GetMethod("__<checkcast>");
			if(method != null)
d7122 7
a7128 2
				ilgen.Emit(OpCodes.Call, method);
				return;
d7130 1
a7131 2
		EmitHelper.Castclass(ilgen, type);
	}
d7133 1
a7133 4
	internal override void Finish(bool forDebugSave)
	{
		// TODO instead of linking here, we should just pre-link in LazyPublishMembers
		foreach(MethodWrapper mw in GetMethods())
d7135 9
a7143 5
			mw.Link();
		}
		foreach(FieldWrapper fw in GetFields())
		{
			fw.Link();
a7145 1
}
d7147 6
a7152 6
sealed class ArrayTypeWrapper : TypeWrapper
{
	private static TypeWrapper[] interfaces;
	private static MethodInfo clone;
	private Type type;
	private Modifiers reflectiveModifiers;
d7154 6
a7159 6
	internal ArrayTypeWrapper(Type type, Modifiers modifiers, Modifiers reflectiveModifiers, string name, ClassLoaderWrapper classLoader)
		: base(modifiers, name, CoreClasses.java.lang.Object.Wrapper, classLoader, null)
	{
		this.type = type;
		this.reflectiveModifiers = reflectiveModifiers;
	}
d7161 1
a7161 3
	protected override void LazyPublishMembers()
	{
		if(clone == null)
d7163 8
a7170 1
			clone = typeof(Array).GetMethod("Clone", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
a7171 5
		MethodWrapper mw = new SimpleCallMethodWrapper(this, "clone", "()Ljava.lang.Object;", clone, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Public, MemberFlags.HideFromReflection, SimpleOpCode.Callvirt, SimpleOpCode.Callvirt);
		mw.Link();
		SetMethods(new MethodWrapper[] { mw });
		SetFields(FieldWrapper.EmptyArray);
	}
d7173 1
a7173 3
	internal override Modifiers ReflectiveModifiers
	{
		get
d7175 4
a7178 1
			return reflectiveModifiers;
a7179 1
	}
d7181 1
a7181 3
	internal override Assembly Assembly
	{
		get
d7183 4
a7186 1
			return type.Assembly;
a7187 1
	}
d7189 1
a7189 3
	internal override string SigName
	{
		get
d7191 5
a7195 2
			// for arrays the signature name is the same as the normal name
			return Name;
a7196 1
	}
d7198 1
a7198 3
	internal override TypeWrapper[] Interfaces
	{
		get
d7200 1
a7200 1
			if(interfaces == null)
d7202 8
a7209 4
				TypeWrapper[] tw = new TypeWrapper[2];
				tw[0] = ClassLoaderWrapper.LoadClassCritical("java.lang.Cloneable");
				tw[1] = ClassLoaderWrapper.LoadClassCritical("java.io.Serializable");
				interfaces = tw;
a7210 1
			return interfaces;
a7211 1
	}
d7213 1
a7213 3
	internal override TypeWrapper[] InnerClasses
	{
		get
d7215 4
a7218 1
			return TypeWrapper.EmptyArray;
a7219 1
	}
d7221 1
a7221 3
	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
d7223 4
a7226 1
			return null;
a7227 1
	}
d7229 1
a7229 3
	internal override Type TypeAsTBD
	{
		get
d7231 4
a7234 1
			return type;
a7235 1
	}
d7237 1
a7237 3
	private bool IsFinished
	{
		get
d7239 1
a7239 2
			Type elem = type.GetElementType();
			while(elem.IsArray)
d7241 6
a7246 1
				elem = elem.GetElementType();
a7247 1
			return !(elem is TypeBuilder);
a7248 1
	}
d7250 1
a7250 3
	internal override void Finish(bool forDebugSave)
	{
		lock(this)
d7252 1
a7252 2
			// TODO optimize this
			if(!IsFinished)
d7254 9
a7262 5
				TypeWrapper elementTypeWrapper = ElementTypeWrapper;
				Type elementType = elementTypeWrapper.TypeAsArrayType;
				elementTypeWrapper.Finish();
				type = elementType.Assembly.GetType(elementType.FullName + "[]", true);
				ClassLoaderWrapper.SetWrapperForType(type, this);
@


1.44
log
@*** empty log message ***
@
text
@a2328 1
		private bool finishing;
a2985 2
				Debug.Assert(!finishing);
				finishing = true;
a3369 10
			private static string Cleanup(string n)
			{
				n = n.Replace('\\', '_');
				n = n.Replace('[', '_');
				n = n.Replace(']', '_');
				n = n.Replace('+', '_');
				n = n.Replace(',', '_');
				return n;
			}

a3476 1
				Label tryBlock = ilGenerator.BeginExceptionBlock();
@


1.43
log
@*** empty log message ***
@
text
@a245 14
	private static bool IsPseudoCustomAttribute(Type type)
	{
		// why is there no .NET API for this?
		return type == typeof(System.Reflection.AssemblyAlgorithmIdAttribute)
			|| type == typeof(System.Reflection.AssemblyFlagsAttribute)
			|| type == typeof(System.Runtime.InteropServices.DllImportAttribute)
			|| type == typeof(System.Runtime.InteropServices.FieldOffsetAttribute)
			|| type == typeof(System.Runtime.InteropServices.InAttribute)
			|| type == typeof(System.Runtime.InteropServices.MarshalAsAttribute)
			|| type == typeof(System.Runtime.CompilerServices.MethodImplAttribute)
			|| type == typeof(System.Runtime.InteropServices.OutAttribute)
			|| type == typeof(System.Runtime.InteropServices.StructLayoutAttribute);
	}

a350 4
			if(IsPseudoCustomAttribute(t))
			{
				throw new NotImplementedException(string.Format("Pseudo Custom Attribute {0} support not implemented", t.FullName));
			}
d3818 1
a3818 1
				bool setModifiers = m.IsNative;
d3820 13
d4005 1
a4005 43
						System.Runtime.InteropServices.DllImportAttribute dllimport = wrapper.GetDllImportAttribute(methods[index]);
						if(dllimport != null)
						{
							// TODO dllimport.PreserveSig should use mb.SetImplementationFlags(MethodImplAttributes.PreserveSig)
							// NOTE there doesn't seem to be a way to support BestFitMapping, SetLastError and ThrowOnUnmappableChar
							System.Runtime.InteropServices.CallingConvention nativeCallConv = dllimport.CallingConvention;
							if((int)nativeCallConv == 0)
							{
								nativeCallConv = System.Runtime.InteropServices.CallingConvention.Winapi;
							}
							System.Runtime.InteropServices.CharSet nativeCharSet = dllimport.CharSet;
							if((int)nativeCharSet == 0)
							{
								nativeCharSet = System.Runtime.InteropServices.CharSet.Auto;
							}
							if(dllimport.EntryPoint != null)
							{
								mb = typeBuilder.DefinePInvokeMethod(name,
									dllimport.Value,
									dllimport.EntryPoint,
									attribs | MethodAttributes.PinvokeImpl,
									CallingConventions.Standard,
									methods[index].ReturnTypeForDefineMethod,
									methods[index].GetParametersForDefineMethod(),
									nativeCallConv,
									nativeCharSet);
							}
							else
							{
								mb = typeBuilder.DefinePInvokeMethod(name,
									dllimport.Value,
									attribs | MethodAttributes.PinvokeImpl,
									CallingConventions.Standard,
									methods[index].ReturnTypeForDefineMethod,
									methods[index].GetParametersForDefineMethod(),
									nativeCallConv,
									nativeCharSet);
							}
						}
						else
						{
							mb = typeBuilder.DefineMethod(name, attribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
						}
d4492 1
a4492 1
	protected virtual System.Runtime.InteropServices.DllImportAttribute GetDllImportAttribute(MethodWrapper mw)
d4494 1
a4494 1
		return null;
d5022 1
a5022 1
	protected override System.Runtime.InteropServices.DllImportAttribute GetDllImportAttribute(MethodWrapper mw)
d5024 1
a5024 1
		if(mapxml != null && (mw.Modifiers & Modifiers.Native) != 0)
d5026 1
a5026 1
			IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[mw.DeclaringType.Name];
d5029 1
a5029 1
				foreach(IKVM.Internal.MapXml.Method m in clazz.Methods)
d5031 1
a5031 1
					if(m.Name == mw.Name && m.Sig == mw.Signature)
d5033 1
a5033 1
						if(m.Attributes != null)
d5035 1
a5035 1
							foreach(IKVM.Internal.MapXml.Attribute attr in m.Attributes)
d5039 1
a5039 5
									// HACK now remove the element from the array
									ArrayList list = new ArrayList(m.Attributes);
									list.Remove(attr);
									m.Attributes = (IKVM.Internal.MapXml.Attribute[])list.ToArray(typeof(IKVM.Internal.MapXml.Attribute));
									return (System.Runtime.InteropServices.DllImportAttribute)AttributeHelper.InstantiatePseudoCustomAttribute(attr);
d5048 1
a5048 1
		return base.GetDllImportAttribute(mw);
@


1.42
log
@*** empty log message ***
@
text
@d188 1
a188 1

d438 1
a438 1

d2160 1
a2160 1
sealed class DynamicTypeWrapper : TypeWrapper
a2163 5
	private FieldInfo ghostRefField;
	private MethodBuilder ghostIsInstanceMethod;
	private MethodBuilder ghostIsInstanceArrayMethod;
	private MethodBuilder ghostCastMethod;
	private MethodBuilder ghostCastArrayMethod;
a2164 4
	private static TypeWrapper[] mappedExceptions;
	private static bool[] mappedExceptionsAllSubClasses;
	private static Hashtable ghosts;
	private static Hashtable mapxml;
a2254 8
	internal override FieldInfo GhostRefField
	{
		get
		{
			return ghostRefField;
		}
	}

a2294 8
	internal override Type TypeAsBaseType
	{
		get
		{
			return impl.TypeAsBaseType;
		}
	}

d2313 2
a2314 40
	internal static void SetupGhosts(IKVM.Internal.MapXml.Root map)
	{
		ghosts = new Hashtable();

		// find the ghost interfaces
		foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
		{
			if(c.Shadows != null && c.Interfaces != null)
			{
				// NOTE we don't support interfaces that inherit from other interfaces
				// (actually, if they are explicitly listed it would probably work)
				TypeWrapper typeWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(c.Name);
				foreach(IKVM.Internal.MapXml.Interface iface in c.Interfaces)
				{
					TypeWrapper ifaceWrapper = ClassLoaderWrapper.GetBootstrapClassLoader().GetLoadedClass(iface.Name);
					if(ifaceWrapper == null || !ifaceWrapper.TypeAsTBD.IsAssignableFrom(typeWrapper.TypeAsTBD))
					{
						AddGhost(iface.Name, typeWrapper);
					}
				}
			}
		}
		// we manually add the array ghost interfaces
		TypeWrapper array = ClassLoaderWrapper.GetWrapperFromType(typeof(Array));
		AddGhost("java.io.Serializable", array);
		AddGhost("java.lang.Cloneable", array);
	}

	private static void AddGhost(string interfaceName, TypeWrapper implementer)
	{
		ArrayList list = (ArrayList)ghosts[interfaceName];
		if(list == null)
		{
			list = new ArrayList();
			ghosts[interfaceName] = list;
		}
		list.Add(implementer);
	}

	internal override bool IsGhost
d2318 1
a2318 127
			return ghosts != null && IsInterface && ghosts.ContainsKey(Name);
		}
	}

	private static TypeWrapper[] GetGhostImplementers(TypeWrapper wrapper)
	{
		ArrayList list = (ArrayList)ghosts[wrapper.Name];
		if(list == null)
		{
			return TypeWrapper.EmptyArray;
		}
		return (TypeWrapper[])list.ToArray(typeof(TypeWrapper));
	}

	private class ExceptionMapEmitter : CodeEmitter
	{
		private IKVM.Internal.MapXml.ExceptionMapping[] map;

		internal ExceptionMapEmitter(IKVM.Internal.MapXml.ExceptionMapping[] map)
		{
			this.map = map;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			MethodWrapper mwSuppressFillInStackTrace = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("__<suppressFillInStackTrace>", "()V", false);
			mwSuppressFillInStackTrace.Link();
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Callvirt, typeof(Object).GetMethod("GetType"));
			MethodInfo GetTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle");
			for(int i = 0; i < map.Length; i++)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Ldtoken, Type.GetType(map[i].src));
				ilgen.Emit(OpCodes.Call, GetTypeFromHandle);
				ilgen.Emit(OpCodes.Ceq);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Brfalse_S, label);
				ilgen.Emit(OpCodes.Pop);
				if(map[i].code != null)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					// TODO we should manually walk the instruction list and add a suppressFillInStackTrace call
					// before each newobj that instantiates an exception
					map[i].code.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
				else
				{
					TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map[i].dst);
					MethodWrapper mw = tw.GetMethodWrapper("<init>", "()V", false);
					mw.Link();
					mwSuppressFillInStackTrace.EmitCall(ilgen);
					mw.EmitNewobj(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
				ilgen.MarkLabel(label);
			}
			ilgen.Emit(OpCodes.Pop);
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Ret);
		}
	}

	internal static void LoadMapXml(IKVM.Internal.MapXml.Root map)
	{
		mapxml = new Hashtable();
		// HACK we've got a hardcoded location for the exception mapping method that is generated from the xml mapping
		mapxml["java.lang.ExceptionHelper.MapExceptionImpl(Ljava.lang.Throwable;)Ljava.lang.Throwable;"] = new ExceptionMapEmitter(map.exceptionMappings);
		foreach(IKVM.Internal.MapXml.Class c in map.assembly.Classes)
		{
			// HACK if it is not a remapped type, we assume it is a container for native methods
			if(c.Shadows == null)
			{
				string className = c.Name;
				mapxml.Add(className, c);
				if(c.Methods != null)
				{
					foreach(IKVM.Internal.MapXml.Method method in c.Methods)
					{
						if(method.body != null)
						{
							string methodName = method.Name;
							string methodSig = method.Sig;
							mapxml.Add(className + "." + methodName + methodSig, method.body);
						}
					}
				}
			}
		}
	}

	internal override bool IsMapUnsafeException
	{
		get
		{
			if(mappedExceptions != null)
			{
				for(int i = 0; i < mappedExceptions.Length; i++)
				{
					if(mappedExceptions[i].IsSubTypeOf(this) ||
						(mappedExceptionsAllSubClasses[i] && this.IsSubTypeOf(mappedExceptions[i])))
					{
						return true;
					}
				}
			}
			return false;
		}
	}

	internal static void LoadMappedExceptions(IKVM.Internal.MapXml.Root map)
	{
		if(map.exceptionMappings != null)
		{
			mappedExceptionsAllSubClasses = new bool[map.exceptionMappings.Length];
			mappedExceptions = new TypeWrapper[map.exceptionMappings.Length];
			for(int i = 0; i < mappedExceptions.Length; i++)
			{
				string dst = map.exceptionMappings[i].dst;
				if(dst[0] == '*')
				{
					mappedExceptionsAllSubClasses[i] = true;
					dst = dst.Substring(1);
				}
				mappedExceptions[i] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dst);
			}
d2323 1
a2323 1
	internal FieldInfo ClassObjectField
d2325 1
a2325 4
		get
		{
			return ((JavaTypeImpl)impl).ClassObjectField;
		}
a2330 1
		internal abstract Type TypeAsBaseType { get; }
a2350 1
		private readonly TypeBuilder typeBuilderGhostInterface;
d2500 1
a2500 26
						if(wrapper.IsGhost)
						{
							typeAttribs &= ~(TypeAttributes.Interface | TypeAttributes.Abstract);
							typeAttribs |= TypeAttributes.Class | TypeAttributes.Sealed;
							typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs, typeof(ValueType));
							AttributeHelper.SetGhostInterface(typeBuilder);
							AttributeHelper.SetModifiers(typeBuilder, wrapper.Modifiers);
							wrapper.ghostRefField = typeBuilder.DefineField("__<ref>", typeof(object), FieldAttributes.Public | FieldAttributes.SpecialName);
							AttributeHelper.HideFromJava((FieldBuilder)wrapper.ghostRefField);
							typeBuilderGhostInterface = typeBuilder.DefineNestedType("__Interface", TypeAttributes.Interface | TypeAttributes.Abstract | TypeAttributes.NestedPublic);
							AttributeHelper.HideFromJava(typeBuilderGhostInterface);
							wrapper.ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object) });
							wrapper.ghostIsInstanceMethod.DefineParameter(1, ParameterAttributes.None, "obj");
							wrapper.ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object), typeof(int) });
							wrapper.ghostIsInstanceArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
							wrapper.ghostIsInstanceArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
							wrapper.ghostCastMethod = typeBuilder.DefineMethod("Cast", MethodAttributes.Public | MethodAttributes.Static, typeBuilder, new Type[] { typeof(object) });
							wrapper.ghostCastMethod.DefineParameter(1, ParameterAttributes.None, "obj");
							wrapper.ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray", MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(object), typeof(int) });
							wrapper.ghostCastArrayMethod.DefineParameter(1, ParameterAttributes.None, "obj");
							wrapper.ghostCastArrayMethod.DefineParameter(2, ParameterAttributes.None, "rank");
						}
						else
						{
							typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs);
						}
d3036 3
a3038 1
				if(typeBuilderGhostInterface != null)
d3040 6
a3045 2
					// TODO consider adding methods from base interface and java.lang.Object as well
					for(int i = 0; i < methods.Length; i++)
d3047 1
a3047 2
						// skip <clinit>
						if(!methods[i].IsStatic)
d3049 9
a3057 46
							TypeWrapper[] args = methods[i].GetParameters();
							MethodBuilder stub = typeBuilder.DefineMethod(methods[i].Name, MethodAttributes.Public, methods[i].ReturnTypeForDefineMethod, methods[i].GetParametersForDefineMethod());
							IKVM.Internal.MapXml.Param[] parameters = GetXmlMapParameters(classFile.Name, methods[i].Name, methods[i].Signature);
							if((JVM.IsStaticCompiler && classFile.IsPublic) || parameters != null || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
							{
								AddParameterNames(stub, methods[i].Signature, parameters);
							}
							AttributeHelper.SetModifiers(stub, methods[i].Modifiers);
							ILGenerator ilgen = stub.GetILGenerator();
							Label end = ilgen.DefineLabel();
							TypeWrapper[] implementers = GetGhostImplementers(wrapper);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldfld, wrapper.GhostRefField);
							ilgen.Emit(OpCodes.Dup);
							ilgen.Emit(OpCodes.Isinst, wrapper.TypeAsBaseType);
							Label label = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brfalse_S, label);
							ilgen.Emit(OpCodes.Castclass, wrapper.TypeAsBaseType);
							for(int k = 0; k < args.Length; k++)
							{
								ilgen.Emit(OpCodes.Ldarg_S, (byte)(k + 1));
							}
							ilgen.Emit(OpCodes.Callvirt, (MethodInfo)methods[i].GetMethod());
							ilgen.Emit(OpCodes.Br, end);
							ilgen.MarkLabel(label);
							for(int j = 0; j < implementers.Length; j++)
							{
								ilgen.Emit(OpCodes.Dup);
								ilgen.Emit(OpCodes.Isinst, implementers[j].TypeAsTBD);
								label = ilgen.DefineLabel();
								ilgen.Emit(OpCodes.Brfalse_S, label);
								ilgen.Emit(OpCodes.Castclass, implementers[j].TypeAsTBD);
								for(int k = 0; k < args.Length; k++)
								{
									ilgen.Emit(OpCodes.Ldarg_S, (byte)(k + 1));
								}
								MethodWrapper mw = implementers[j].GetMethodWrapper(methods[i].Name, methods[i].Signature, true);
								mw.EmitCallvirt(ilgen);
								ilgen.Emit(OpCodes.Br, end);
								ilgen.MarkLabel(label);
							}
							// we need to do a null check (null fails all the isinst checks)
							EmitHelper.NullCheck(ilgen);
							EmitHelper.Throw(ilgen, "java.lang.IncompatibleClassChangeError", wrapper.Name);
							ilgen.MarkLabel(end);
							ilgen.Emit(OpCodes.Ret);
d3059 1
d3061 9
a3069 2
					// HACK create a scope to enable reuse of "implementers" name
					if(true)
d3071 3
a3073 6
						MethodBuilder mb;
						ILGenerator ilgen;
						LocalBuilder local;
						// add implicit conversions for all the ghost implementers
						TypeWrapper[] implementers = GetGhostImplementers(wrapper);
						for(int i = 0; i < implementers.Length; i++)
d3075 4
a3078 10
							mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, wrapper.TypeAsSignatureType, new Type[] { implementers[i].TypeAsSignatureType });
							AttributeHelper.HideFromJava(mb);
							ilgen = mb.GetILGenerator();
							local = ilgen.DeclareLocal(wrapper.TypeAsSignatureType);
							ilgen.Emit(OpCodes.Ldloca, local);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Stfld, wrapper.GhostRefField);
							ilgen.Emit(OpCodes.Ldloca, local);
							ilgen.Emit(OpCodes.Ldobj, wrapper.TypeAsSignatureType);			
							ilgen.Emit(OpCodes.Ret);
d3080 4
a3083 170
						// Implement the "IsInstance" method
						mb = wrapper.ghostIsInstanceMethod;
						AttributeHelper.HideFromJava(mb);
						ilgen = mb.GetILGenerator();
						Label end = ilgen.DefineLabel();
						for(int i = 0; i < implementers.Length; i++)
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
							Label label = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brfalse_S, label);
							ilgen.Emit(OpCodes.Ldc_I4_1);
							ilgen.Emit(OpCodes.Br, end);
							ilgen.MarkLabel(label);
						}
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Isinst, wrapper.TypeAsBaseType);
						ilgen.Emit(OpCodes.Ldnull);
						ilgen.Emit(OpCodes.Cgt_Un);
						ilgen.MarkLabel(end);
						ilgen.Emit(OpCodes.Ret);
						// Implement the "IsInstanceArray" method
						mb = wrapper.ghostIsInstanceArrayMethod;
						AttributeHelper.HideFromJava(mb);
						ilgen = mb.GetILGenerator();
						LocalBuilder localType = ilgen.DeclareLocal(typeof(Type));
						ilgen.Emit(OpCodes.Ldarg_0);
						Label skip = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brtrue_S, skip);
						ilgen.Emit(OpCodes.Ldc_I4_0);
						ilgen.Emit(OpCodes.Ret);
						ilgen.MarkLabel(skip);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Call, typeof(object).GetMethod("GetType"));
						ilgen.Emit(OpCodes.Stloc, localType);
						skip = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Br_S, skip);
						Label iter = ilgen.DefineLabel();
						ilgen.MarkLabel(iter);
						ilgen.Emit(OpCodes.Ldarg_1);
						ilgen.Emit(OpCodes.Ldc_I4_1);
						ilgen.Emit(OpCodes.Sub);
						ilgen.Emit(OpCodes.Starg_S, (byte)1);
						ilgen.Emit(OpCodes.Ldloc, localType);
						ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("GetElementType"));
						ilgen.Emit(OpCodes.Stloc, localType);
						ilgen.MarkLabel(skip);
						ilgen.Emit(OpCodes.Ldloc, localType);
						ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("get_IsArray"));
						ilgen.Emit(OpCodes.Brtrue_S, iter);
						ilgen.Emit(OpCodes.Ldarg_1);
						skip = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brfalse_S, skip);
						ilgen.Emit(OpCodes.Ldc_I4_0);
						ilgen.Emit(OpCodes.Ret);
						ilgen.MarkLabel(skip);
						for(int i = 0; i < implementers.Length; i++)
						{
							ilgen.Emit(OpCodes.Ldtoken, implementers[i].TypeAsTBD);
							ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
							ilgen.Emit(OpCodes.Ldloc, localType);
							ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("IsAssignableFrom"));
							Label label = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brfalse_S, label);
							ilgen.Emit(OpCodes.Ldc_I4_1);
							ilgen.Emit(OpCodes.Ret);
							ilgen.MarkLabel(label);
						}
						ilgen.Emit(OpCodes.Ldtoken, wrapper.TypeAsBaseType);
						ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
						ilgen.Emit(OpCodes.Ldloc, localType);
						ilgen.Emit(OpCodes.Callvirt, typeof(Type).GetMethod("IsAssignableFrom"));
						ilgen.Emit(OpCodes.Ret);
						
						// Implement the "Cast" method
						mb = wrapper.ghostCastMethod;
						AttributeHelper.HideFromJava(mb);
						ilgen = mb.GetILGenerator();
						end = ilgen.DefineLabel();
						for(int i = 0; i < implementers.Length; i++)
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Isinst, implementers[i].TypeAsTBD);
							ilgen.Emit(OpCodes.Brtrue, end);
						}
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Castclass, wrapper.TypeAsBaseType);
						ilgen.Emit(OpCodes.Pop);
						ilgen.MarkLabel(end);
						local = ilgen.DeclareLocal(wrapper.TypeAsSignatureType);
						ilgen.Emit(OpCodes.Ldloca, local);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Stfld, wrapper.ghostRefField);
						ilgen.Emit(OpCodes.Ldloca, local);
						ilgen.Emit(OpCodes.Ldobj, wrapper.TypeAsSignatureType);	
						ilgen.Emit(OpCodes.Ret);
						// Add "ToObject" methods
						mb = typeBuilder.DefineMethod("ToObject", MethodAttributes.Public, typeof(object), Type.EmptyTypes);
						AttributeHelper.HideFromJava(mb);
						ilgen = mb.GetILGenerator();
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Ldfld, wrapper.GhostRefField);
						ilgen.Emit(OpCodes.Ret);

						// Implement the "CastArray" method
						// NOTE unlike "Cast" this doesn't return anything, it just throws a ClassCastException if the
						// cast is unsuccessful. Also, because of the complexity of this test, we call IsInstanceArray
						// instead of reimplementing the check here.
						mb = wrapper.ghostCastArrayMethod;
						AttributeHelper.HideFromJava(mb);
						ilgen = mb.GetILGenerator();
						end = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Brfalse_S, end);
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Ldarg_1);
						ilgen.Emit(OpCodes.Call, wrapper.ghostIsInstanceArrayMethod);
						ilgen.Emit(OpCodes.Brtrue_S, end);
						EmitHelper.Throw(ilgen, "java.lang.ClassCastException");
						ilgen.MarkLabel(end);
						ilgen.Emit(OpCodes.Ret);
					}
				}
				// if we're not abstract make sure we don't inherit any abstract methods
				if(!wrapper.IsAbstract)
				{
					TypeWrapper parent = wrapper.BaseTypeWrapper;
					// if parent is not abstract, the .NET implementation will never have abstract methods (only
					// stubs that throw AbstractMethodError)
					// NOTE interfaces are supposed to be abstract, but the VM doesn't enforce this, so
					// we have to check for a null parent (interfaces have no parent).
					while(parent != null && parent.IsAbstract)
					{
						foreach(MethodWrapper mw in parent.GetMethods())
						{
							MethodInfo mi = mw.GetMethod() as MethodInfo;
							if(mi != null && mi.IsAbstract && wrapper.GetMethodWrapper(mw.Name, mw.Signature, true).IsAbstract)
							{
								// NOTE in Sun's JRE 1.4.1 this method cannot be overridden by subclasses,
								// but I think this is a bug, so we'll support it anyway.
								MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & ~(MethodAttributes.Abstract|MethodAttributes.NewSlot), CallingConventions.Standard, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
								AttributeHelper.HideFromJava(mb);
								EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + mw.Name + mw.Signature);
							}
						}
						parent = parent.BaseTypeWrapper;
					}
				}
				string verifyError = null;
				bool basehasclinit = wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasStaticInitializer;
				bool hasclinit = false;
				for(int i = 0; i < classFile.Methods.Length; i++)
				{
					ClassFile.Method m = classFile.Methods[i];
					MethodBase mb = methods[i].GetMethod();
					if(mb is ConstructorBuilder)
					{
						ILGenerator ilGenerator = ((ConstructorBuilder)mb).GetILGenerator();
						Tracer.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
						if(basehasclinit && m.IsClassInitializer && !classFile.IsInterface)
						{
							hasclinit = true;
							// before we call the base class initializer, we need to set the non-final static ConstantValue fields
							EmitConstantValueInitialization(ilGenerator);
							EmitHelper.RunClassConstructor(ilGenerator, Type.BaseType);
						}
						Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref verifyError);
					}
					else
					{
d3107 1
a3107 1
								if(mapxml != null)
d3109 1
a3109 6
									CodeEmitter opcodes = (CodeEmitter)mapxml[classFile.Name + "." + m.Name + m.Signature];
									if(opcodes != null)
									{
										opcodes.Emit(ilGenerator);
										continue;
									}
d3192 1
a3192 1
							if(mapxml != null)
d3194 1
a3194 6
								CodeEmitter opcodes = (CodeEmitter)mapxml[classFile.Name + "." + m.Name + m.Signature];
								if(opcodes != null)
								{
									opcodes.Emit(ilGenerator);
									continue;
								}
d3341 1
a3341 84
				if(mapxml != null)
				{
					IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[classFile.Name];
					if(clazz != null)
					{
						if(clazz.Attributes != null)
						{
							PublishAttributes(clazz);
						}
						if(clazz.Properties != null)
						{
							PublishProperties(clazz);
						}
						if(clazz.Fields != null)
						{
							foreach(IKVM.Internal.MapXml.Field field in clazz.Fields)
							{
								if(field.Attributes != null)
								{
									foreach(FieldWrapper fw in fields)
									{
										if(fw.Name == field.Name && fw.Signature == field.Sig)
										{
											FieldBuilder fb = fw.GetField() as FieldBuilder;
											if(fb != null)
											{
												foreach(IKVM.Internal.MapXml.Attribute attr in field.Attributes)
												{
													AttributeHelper.SetCustomAttribute(fb, attr);
												}
											}
										}
									}
								}
							}
						}
						if(clazz.Constructors != null)
						{
							foreach(IKVM.Internal.MapXml.Constructor constructor in clazz.Constructors)
							{
								if(constructor.Attributes != null)
								{
									foreach(MethodWrapper mw in methods)
									{
										if(mw.Name == "<init>" && mw.Signature == constructor.Sig)
										{
											ConstructorBuilder mb = mw.GetMethod() as ConstructorBuilder;
											if(mb != null)
											{
												foreach(IKVM.Internal.MapXml.Attribute attr in constructor.Attributes)
												{
													AttributeHelper.SetCustomAttribute(mb, attr);
												}
											}
										}
									}
								}
							}
						}
						if(clazz.Methods != null)
						{
							foreach(IKVM.Internal.MapXml.Method method in clazz.Methods)
							{
								if(method.Attributes != null)
								{
									foreach(MethodWrapper mw in methods)
									{
										if(mw.Name == method.Name && mw.Signature == method.Sig)
										{
											MethodBuilder mb = mw.GetMethod() as MethodBuilder;
											if(mb != null)
											{
												foreach(IKVM.Internal.MapXml.Attribute attr in method.Attributes)
												{
													AttributeHelper.SetCustomAttribute(mb, attr);
												}
											}
										}
									}
								}
							}
						}
					}
				}
d3365 2
a3366 1
					finishedType = new FinishedTypeImpl(type, typeBuilderGhostInterface != null ? typeBuilderGhostInterface.CreateType() : null, innerClassesTypeWrappers, declaringTypeWrapper, this.ReflectiveModifiers);
a3380 181
		private static MethodAttributes GetPropertyMethodAttributes(MethodWrapper mw, bool final)
		{
			MethodAttributes attribs = (MethodAttributes)0;
			if(mw.IsStatic)
			{
				attribs |= MethodAttributes.Static;
			}
			else
			{
				// NOTE in order for IntelliSense to consider the property a "real" property,
				// the getter and setter methods need to have substantially the same method attributes,
				// so we may need to look at our peer to determine whether we should be final
				// or not (and vice versa).
				attribs |= MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.CheckAccessOnOverride;
				if(final)
				{
					attribs |= MethodAttributes.Final;
				}
			}
			// TODO what happens if accessibility doesn't match our peer?
			if(mw.IsPublic)
			{
				attribs |= MethodAttributes.Public;
			}
			else if(mw.IsProtected)
			{
				attribs |= MethodAttributes.FamORAssem;
			}
			else if(mw.IsPrivate)
			{
				attribs |= MethodAttributes.Private;
			}
			else
			{
				attribs |= MethodAttributes.Assembly;
			}
			return attribs;
		}

		private static bool CheckPropertyArgs(Type[] args1, Type[] args2)
		{
			if(args1.Length == args2.Length)
			{
				for(int i = 0; i < args1.Length; i++)
				{
					if(args1[i] != args2[i])
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		private void PublishAttributes(IKVM.Internal.MapXml.Class clazz)
		{
			foreach(IKVM.Internal.MapXml.Attribute attr in clazz.Attributes)
			{
				AttributeHelper.SetCustomAttribute(typeBuilder, attr);
			}
		}

		private void PublishProperties(IKVM.Internal.MapXml.Class clazz)
		{
			foreach(IKVM.Internal.MapXml.Property prop in clazz.Properties)
			{
				TypeWrapper typeWrapper = ClassFile.RetTypeWrapperFromSig(wrapper.GetClassLoader(), classCache, prop.Sig);
				TypeWrapper[] propargs = ClassFile.ArgTypeWrapperListFromSig(wrapper.GetClassLoader(), classCache, prop.Sig);
				Type[] indexer = new Type[propargs.Length];
				for(int i = 0; i < propargs.Length; i++)
				{
					indexer[i] = propargs[i].TypeAsSignatureType;
				}
				PropertyBuilder propbuilder = typeBuilder.DefineProperty(prop.Name, PropertyAttributes.None, typeWrapper.TypeAsSignatureType, indexer);
				if(prop.Attributes != null)
				{
					foreach(IKVM.Internal.MapXml.Attribute attr in prop.Attributes)
					{
						AttributeHelper.SetCustomAttribute(propbuilder, attr);
					}
				}
				MethodWrapper getter = null;
				MethodWrapper setter = null;
				if(prop.getter != null)
				{
					getter = wrapper.GetMethodWrapper(prop.getter.Name, prop.getter.Sig, true);
					if(getter == null)
					{
						Console.Error.WriteLine("Warning: getter not found for {0}::{1}", clazz.Name, prop.Name);
					}
				}
				if(prop.setter != null)
				{
					setter = wrapper.GetMethodWrapper(prop.setter.Name, prop.setter.Sig, true);
					if(setter == null)
					{
						Console.Error.WriteLine("Warning: setter not found for {0}::{1}", clazz.Name, prop.Name);
					}
				}
				bool final = (getter != null && getter.IsFinal) || (setter != null && setter.IsFinal);
				if(getter != null)
				{
					MethodWrapper mw = getter;
					if(!CheckPropertyArgs(mw.GetParametersForDefineMethod(), indexer) || mw.ReturnType != typeWrapper)
					{
						Console.Error.WriteLine("Warning: ignoring invalid property getter for {0}::{1}", clazz.Name, prop.Name);
					}
					else
					{
						MethodBuilder mb = mw.GetMethod() as MethodBuilder;
						if(mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final))
						{
							mb = typeBuilder.DefineMethod(GenerateUniqueMethodName("get_" + prop.Name, mw), GetPropertyMethodAttributes(mw, final), typeWrapper.TypeAsSignatureType, indexer);
							AttributeHelper.HideFromJava(mb);
							ILGenerator ilgen = new CountingILGenerator(mb.GetILGenerator());
							if(mw.IsStatic)
							{
								for(int i = 0; i < indexer.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, i);
								}
								mw.EmitCall(ilgen);
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								for(int i = 0; i < indexer.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, i + 1);
								}
								mw.EmitCallvirt(ilgen);
							}
							ilgen.Emit(OpCodes.Ret);
						}
						propbuilder.SetGetMethod(mb);
					}
				}
				if(setter != null)
				{
					MethodWrapper mw = setter;
					Type[] args = new Type[indexer.Length + 1];
					indexer.CopyTo(args, 0);
					args[args.Length - 1] = typeWrapper.TypeAsSignatureType;
					if(!CheckPropertyArgs(args, mw.GetParametersForDefineMethod()))
					{
						Console.Error.WriteLine("Warning: ignoring invalid property setter for {0}::{1}", clazz.Name, prop.Name);
					}
					else
					{
						MethodBuilder mb = mw.GetMethod() as MethodBuilder;
						if(mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final))
						{
							mb = typeBuilder.DefineMethod(GenerateUniqueMethodName("set_" + prop.Name, mw), GetPropertyMethodAttributes(mw, final), mw.ReturnTypeForDefineMethod, args);
							AttributeHelper.HideFromJava(mb);
							ILGenerator ilgen = new CountingILGenerator(mb.GetILGenerator());
							if(mw.IsStatic)
							{
								for(int i = 0; i <= indexer.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, i);
								}
								mw.EmitCall(ilgen);
							}
							else
							{
								ilgen.Emit(OpCodes.Ldarg_0);
								for(int i = 0; i <= indexer.Length; i++)
								{
									ilgen.Emit(OpCodes.Ldarg, i + 1);
								}
								mw.EmitCallvirt(ilgen);
							}
							ilgen.Emit(OpCodes.Ret);
						}
						propbuilder.SetSetMethod(mb);
					}
				}
			}
		}

d3698 1
a3698 1
		private string GenerateClashKey(string type, string name, Type retOrFieldType, Type[] args)
d3785 1
a3785 1
		private string GenerateUniqueMethodName(string basename, MethodWrapper mw)
d3867 1
a3867 5
					IKVM.Internal.MapXml.Param[] parameters = GetXmlMapParameters(classFile.Name, m.Name, m.Signature);
					if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || parameters != null || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
					{
						AddParameterNames(method, m, parameters);
					}
d3942 2
a3943 6
					MethodBuilder mb;
					if(typeBuilderGhostInterface != null)
					{
						mb = typeBuilderGhostInterface.DefineMethod(name, attribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
					}
					else
d4010 1
a4010 1
						System.Runtime.InteropServices.DllImportAttribute dllimport = GetDllImportAttribute(methods[index]);
d4100 1
a4100 5
					IKVM.Internal.MapXml.Param[] parameters = GetXmlMapParameters(classFile.Name, m.Name, m.Signature);
					if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || parameters != null || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
					{
						AddParameterNames(mb, m, parameters);
					}
d4129 1
a4129 1
		private System.Runtime.InteropServices.DllImportAttribute GetDllImportAttribute(MethodWrapper mw)
d4131 9
a4139 1
			if(mapxml != null && (mw.Modifiers & Modifiers.Native) != 0)
d4141 2
a4142 2
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[mw.DeclaringType.Name];
				if(clazz != null && clazz.Methods != null)
d4144 1
a4144 21
					foreach(IKVM.Internal.MapXml.Method m in clazz.Methods)
					{
						if(m.Name == mw.Name && m.Sig == mw.Signature)
						{
							if(m.Attributes != null)
							{
								foreach(IKVM.Internal.MapXml.Attribute attr in m.Attributes)
								{
									if(Type.GetType(attr.Type) == typeof(System.Runtime.InteropServices.DllImportAttribute))
									{
										// HACK now remove the element from the array
										ArrayList list = new ArrayList(m.Attributes);
										list.Remove(attr);
										m.Attributes = (IKVM.Internal.MapXml.Attribute[])list.ToArray(typeof(IKVM.Internal.MapXml.Attribute));
										return (System.Runtime.InteropServices.DllImportAttribute)AttributeHelper.InstantiatePseudoCustomAttribute(attr);
									}
								}
							}
							break;
						}
					}
d4147 3
a4149 254
			return null;
		}

		private static IKVM.Internal.MapXml.Param[] GetXmlMapParameters(string classname, string method, string sig)
		{
			if(mapxml != null)
			{
				IKVM.Internal.MapXml.Class clazz = (IKVM.Internal.MapXml.Class)mapxml[classname];
				if(clazz != null)
				{
					if(method == "<init>" && clazz.Constructors != null)
					{
						for(int i = 0; i < clazz.Constructors.Length; i++)
						{
							if(clazz.Constructors[i].Sig == sig)
							{
								return clazz.Constructors[i].Params;
							}
						}
					}
					else if(clazz.Methods != null)
					{
						for(int i = 0; i < clazz.Methods.Length; i++)
						{
							if(clazz.Methods[i].Name == method && clazz.Methods[i].Sig == sig)
							{
								return clazz.Methods[i].Params;
							}
						}
					}
				}
			}
			return null;
		}

		private static ParameterBuilder[] AddParameterNames(MethodBase mb, ClassFile.Method m, IKVM.Internal.MapXml.Param[] xmlparams)
		{
			ClassFile.Method.LocalVariableTableEntry[] localVars = m.LocalVariableTableAttribute;
			if(localVars != null)
			{
				int bias = 1;
				if(m.IsStatic)
				{
					bias = 0;
				}
				ParameterBuilder[] parameterBuilders = new ParameterBuilder[m.ArgMap.Length - bias];
				for(int i = bias; i < m.ArgMap.Length; i++)
				{
					if(m.ArgMap[i] != -1)
					{
						for(int j = 0; j < localVars.Length; j++)
						{
							if(localVars[j].index == i && parameterBuilders[i - bias] == null)
							{
								string name = localVars[j].name;
								if(xmlparams != null && xmlparams[i - bias].Name != null)
								{
									name = xmlparams[i - bias].Name;
								}
								ParameterBuilder pb;
								if(mb is MethodBuilder)
								{
									pb = ((MethodBuilder)mb).DefineParameter(m.ArgMap[i] + 1 - bias, ParameterAttributes.None, name);
								}
								else
								{
									pb = ((ConstructorBuilder)mb).DefineParameter(m.ArgMap[i], ParameterAttributes.None, name);
								}
								parameterBuilders[i - bias] = pb;
								if(xmlparams != null && xmlparams[i - bias].Attributes != null)
								{
									for(int k = 0; k < xmlparams[i - bias].Attributes.Length; k++)
									{
										AttributeHelper.SetCustomAttribute(pb, xmlparams[i - bias].Attributes[k]);
									}
								}
								break;
							}
						}
					}
				}
				return parameterBuilders;
			}
			else
			{
				return AddParameterNames(mb, m.Signature, xmlparams);
			}
		}

		private static ParameterBuilder[] AddParameterNames(MethodBase mb, string sig, IKVM.Internal.MapXml.Param[] xmlparams)
		{
			ArrayList names = new ArrayList();
			for(int i = 1; sig[i] != ')'; i++)
			{
				if(sig[i] == 'L')
				{
					i++;
					int end = sig.IndexOf(';', i);
					names.Add(GetParameterName(sig.Substring(i, end - i)));
					i = end;
				}
				else if(sig[i] == '[')
				{
					while(sig[++i] == '[');
					if(sig[i] == 'L')
					{
						i++;
						int end = sig.IndexOf(';', i);
						names.Add(GetParameterName(sig.Substring(i, end - i)) + "arr");
						i = end;
					}
					else
					{
						switch(sig[i])
						{
							case 'B':
							case 'Z':
								names.Add("barr");
								break;
							case 'C':
								names.Add("charr");
								break;
							case 'S':
								names.Add("sarr");
								break;
							case 'I':
								names.Add("iarr");
								break;
							case 'J':
								names.Add("larr");
								break;
							case 'F':
								names.Add("farr");
								break;
							case 'D':
								names.Add("darr");
								break;
						}
					}
				}
				else
				{
					switch(sig[i])
					{
						case 'B':
						case 'Z':
							names.Add("b");
							break;
						case 'C':
							names.Add("ch");
							break;
						case 'S':
							names.Add("s");
							break;
						case 'I':
							names.Add("i");
							break;
						case 'J':
							names.Add("l");
							break;
						case 'F':
							names.Add("f");
							break;
						case 'D':
							names.Add("d");
							break;
					}
				}
			}
			ParameterBuilder[] parameterBuilders = new ParameterBuilder[names.Count];
			Hashtable clashes = new Hashtable();
			for(int i = 0; i < names.Count; i++)
			{
				string name = (string)names[i];
				if(xmlparams != null && xmlparams[i].Name != null)
				{
					name = xmlparams[i].Name;
				}
				ParameterBuilder pb;
				if(names.IndexOf(name, i + 1) >= 0 || clashes.ContainsKey(name))
				{
					int clash = 1;
					if(clashes.ContainsKey(name))
					{
						clash = (int)clashes[name] + 1;
					}
					clashes[name] = clash;
					name += clash;
				}
				if(mb is MethodBuilder)
				{
					pb = ((MethodBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
				}
				else
				{
					pb = ((ConstructorBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
				}
				parameterBuilders[i] = pb;
				if(xmlparams != null && xmlparams[i].Attributes != null)
				{
					for(int k = 0; k < xmlparams[i].Attributes.Length; k++)
					{
						AttributeHelper.SetCustomAttribute(pb, xmlparams[i].Attributes[k]);
					}
				}
			}
			return parameterBuilders;
		}

		private static string GetParameterName(string type)
		{
			if(type == "java.lang.String")
			{
				return "str";
			}
			else if(type == "java.lang.Object")
			{
				return "obj";
			}
			else
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder();
				for(int i = type.LastIndexOf('.') + 1; i < type.Length; i++)
				{
					if(char.IsUpper(type, i))
					{
						sb.Append(char.ToLower(type[i]));
					}
				}
				return sb.ToString();
			}
		}

		private void GenerateUnloadableOverrideStub(MethodWrapper baseMethod, MethodInfo target, Type targetRet, Type[] targetArgs)
		{
			Type stubret = baseMethod.ReturnTypeForDefineMethod;
			Type[] stubargs = baseMethod.GetParametersForDefineMethod();
			string name = GenerateUniqueMethodName(baseMethod.RealName + "/unloadablestub", baseMethod);
			MethodBuilder overrideStub = typeBuilder.DefineMethod(name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final, stubret, stubargs);
			AttributeHelper.HideFromJava(overrideStub);
			typeBuilder.DefineMethodOverride(overrideStub, (MethodInfo)baseMethod.GetMethod());
			ILGenerator ilgen = overrideStub.GetILGenerator();
			ilgen.Emit(OpCodes.Ldarg_0);
			for(int i = 0; i < targetArgs.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldarg_S, (byte)(i + 1));
				if(targetArgs[i] != stubargs[i])
				{
					ilgen.Emit(OpCodes.Castclass, targetArgs[i]);
				}
			}
			ilgen.Emit(OpCodes.Callvirt, target);
			if(targetRet != stubret)
			{
a4209 8

		internal override Type TypeAsBaseType
		{
			get
			{
				return typeBuilderGhostInterface != null ? typeBuilderGhostInterface : typeBuilder;
			}
		}
a4270 8

		internal override Type TypeAsBaseType
		{
			get
			{
				return null;
			}
		}
a4275 1
		private Type typeGhostInterface;
d4280 1
a4280 1
		internal FinishedTypeImpl(Type type, Type typeGhostInterface, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers)
a4282 1
			this.typeGhostInterface = typeGhostInterface;
a4321 8
		internal override Type TypeAsBaseType
		{
			get
			{
				return typeGhostInterface != null ? typeGhostInterface : type;
			}
		}

d4342 1
a4342 1
	internal override void EmitCheckcast(TypeWrapper context, ILGenerator ilgen)
d4344 2
a4345 1
		if(IsGhost)
d4347 35
a4381 8
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Call, ghostCastMethod);
			ilgen.Emit(OpCodes.Pop);
		}
		else if(IsGhostArray)
		{
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Call, ghostCastArrayMethod);
d4385 1
a4385 1
			base.EmitCheckcast(context, ilgen);
d4389 1
a4389 1
	internal override void EmitInstanceOf(TypeWrapper context, ILGenerator ilgen)
d4391 2
a4392 1
		if(IsGhost)
d4394 104
a4497 1
			ilgen.Emit(OpCodes.Call, ghostIsInstanceMethod);
d4499 10
a4508 1
		else if(IsGhostArray)
d4510 1
a4510 1
			ilgen.Emit(OpCodes.Call, ghostIsInstanceArrayMethod);
d4514 17
a4530 1
			base.EmitInstanceOf(context, ilgen);
d4534 32
d4579 907
@


1.41
log
@*** empty log message ***
@
text
@d189 33
d236 1
a236 8
				if(attr.Properties != null)
				{
					foreach(IKVM.Internal.MapXml.Param prop in attr.Properties)
					{
						PropertyInfo pi = t.GetProperty(prop.Name);
						pi.SetValue(attrib, ParseValue(ClassFile.FieldTypeWrapperFromSig(ClassLoaderWrapper.GetBootstrapClassLoader(), new Hashtable(), prop.Sig), prop.Value), null);
					}
				}
d246 14
d365 4
d3515 4
d4709 43
a4751 1
						mb = typeBuilder.DefineMethod(name, attribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
d4832 33
@


1.40
log
@*** empty log message ***
@
text
@d239 5
d3221 2
a3222 1
							if((JVM.IsStaticCompiler && classFile.IsPublic) || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d3224 1
a3224 1
								AddParameterNames(stub, methods[i].Signature);
d4510 2
a4511 1
					if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d4513 1
a4513 1
						AddParameterNames(method, m);
d4709 2
a4710 1
					if((JVM.IsStaticCompiler && classFile.IsPublic && (m.IsPublic || m.IsProtected)) || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d4712 1
a4712 1
						AddParameterNames(mb, m);
d4742 33
a4774 1
		private static ParameterBuilder[] AddParameterNames(MethodBase mb, ClassFile.Method m)
d4793 6
d4801 1
a4801 1
									parameterBuilders[i - bias] = ((MethodBuilder)mb).DefineParameter(m.ArgMap[i] + 1 - bias, ParameterAttributes.None, localVars[j].name);
d4803 1
a4803 1
								else if(mb is ConstructorBuilder)
d4805 9
a4813 1
									parameterBuilders[i - bias] = ((ConstructorBuilder)mb).DefineParameter(m.ArgMap[i], ParameterAttributes.None, localVars[j].name);
d4824 1
a4824 1
				return AddParameterNames(mb, m.Signature);
d4828 1
a4828 1
		private static ParameterBuilder[] AddParameterNames(MethodBase mb, string sig)
d4913 5
d4930 1
a4930 1
					parameterBuilders[i] = ((MethodBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
d4932 1
a4932 1
				else if(mb is ConstructorBuilder)
d4934 9
a4942 1
					parameterBuilders[i] = ((ConstructorBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
@


1.39
log
@*** empty log message ***
@
text
@d3216 4
d4504 1
a4504 1
					if(JVM.IsStaticCompiler || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d4702 1
a4702 1
					if(JVM.IsStaticCompiler || JVM.Debug || ClassLoaderWrapper.IsSaveDebugImage)
d4705 4
a4708 4
						if(setModifiers)
						{
							AttributeHelper.SetModifiers(mb, m.Modifiers);
						}
d4768 135
a4902 1
			return null;
@


1.38
log
@*** empty log message ***
@
text
@d2657 1
d2659 2
d2662 1
d2664 2
@


1.37
log
@*** empty log message ***
@
text
@d29 2
d40 1
a40 1
	private static MethodInfo verboseCastFailure = Environment.GetEnvironmentVariable("IKVM_VERBOSE_CAST") == null ? null : typeof(ByteCodeHelper).GetMethod("VerboseCastFailure");
d189 89
a277 1
	internal static CustomAttributeBuilder CreateCustomAttribute(IKVM.Internal.MapXml.Attribute attr)
d281 2
a282 2
		Type[] argTypes = new Type[twargs.Length];
		object[] args = new object[argTypes.Length];
d305 8
d316 4
d481 1
a481 1
		return mi.IsDefined(typeof(MirandaMethodAttribute), false);
d1492 5
a1496 1
			if(!mce.IsPublic)
d1817 6
d2050 5
d2079 1
d2081 1
d2086 1
d2091 1
d2099 1
d2104 1
d2357 2
d2374 2
d2384 1
d2798 1
a2798 1
								mw = new SmartCallMethodWrapper(wrapper, ifmethod.Name, ifmethod.Signature, null, null, null, Modifiers.Public | Modifiers.Abstract, MemberFlags.HideFromReflection, SimpleOpCode.Call, SimpleOpCode.Callvirt);
d3733 1
a3733 1
													fb.SetCustomAttribute(AttributeHelper.CreateCustomAttribute(attr));
d3756 1
a3756 1
													mb.SetCustomAttribute(AttributeHelper.CreateCustomAttribute(attr));
d3779 1
a3779 1
													mb.SetCustomAttribute(AttributeHelper.CreateCustomAttribute(attr));
d3886 1
a3886 1
				typeBuilder.SetCustomAttribute(AttributeHelper.CreateCustomAttribute(attr));
d3906 1
a3906 1
						propbuilder.SetCustomAttribute(AttributeHelper.CreateCustomAttribute(attr));
d4494 1
a4494 1
					if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage)
d4692 1
a4692 1
					if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage)
d5580 2
a5581 1
					methods.Add(MethodWrapper.Create(this, name, sig, method, retType, paramTypes, AttributeHelper.GetModifiers(method, false), miranda));
d5644 1
d5845 7
d5977 1
d6046 1
d6093 1
d6210 1
d6444 1
d6661 1
a6661 1
			MethodWrapper mw = new SimpleCallMethodWrapper(this, "finalize", "()V", (MethodInfo)mb, null, null, mods, false, SimpleOpCode.Call, SimpleOpCode.Callvirt);
d6701 1
a6701 1
				return new SmartConstructorMethodWrapper(this, name, sig, (ConstructorInfo)mb, null, mods, false);
d6706 1
a6706 1
				return new SmartCallMethodWrapper(this, name, sig, (MethodInfo)mb, null, null, mods, false, SimpleOpCode.Call, SimpleOpCode.Callvirt);
d6793 1
a6793 1
		MethodWrapper mw = new SimpleCallMethodWrapper(this, "clone", "()Ljava.lang.Object;", clone, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Public, true, SimpleOpCode.Callvirt, SimpleOpCode.Callvirt);
@


1.36
log
@*** empty log message ***
@
text
@d4544 3
d4560 1
@


1.35
log
@*** empty log message ***
@
text
@d4498 1
@


1.34
log
@*** empty log message ***
@
text
@d4073 14
a4086 1
				ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, (retTypeWrapper.IsPrimitive) ? retTypeWrapper.TypeAsSignatureType : typeof(IntPtr), modargs);
@


1.33
log
@*** empty log message ***
@
text
@d135 153
d2171 1
a2171 1
		foreach(IKVM.Internal.MapXml.Class c in map.assembly)
d2273 1
a2273 1
		foreach(IKVM.Internal.MapXml.Class c in map.assembly)
d2279 1
a2279 1
				mapxml[className] = c;
d2288 1
a2288 1
							mapxml[className + "." + methodName + methodSig] = method.body;
a2930 5
				if(JVM.IsTlsEnabled && fieldName.StartsWith("__tls_"))
				{
					CustomAttributeBuilder threadStaticAttrib = new CustomAttributeBuilder(typeof(ThreadStaticAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
					field.SetCustomAttribute(threadStaticAttrib);
				}
d3398 1
a3398 1
										EmitHelper.Throw(ilGenerator, "java.lang.UnsatisfiedLinkError", "Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
d3580 1
a3580 1
					if(clazz != null && clazz.Properties != null)
d3582 77
a3658 1
						PublishProperties(clazz);
d3754 8
d3774 7
d6187 1
a6187 1
			if(!type.IsAbstract)
@


1.32
log
@*** empty log message ***
@
text
@d3514 16
d3534 8
a3541 2
				TypeWrapper typeWrapper = ClassFile.FieldTypeWrapperFromSig(wrapper.GetClassLoader(), classCache, prop.Sig);
				PropertyBuilder propbuilder = typeBuilder.DefineProperty(prop.Name, PropertyAttributes.None, typeWrapper.TypeAsSignatureType, Type.EmptyTypes);
d3547 4
d3555 4
d3561 1
a3561 1
				if(prop.getter != null)
d3564 1
a3564 1
					if(mw == null || mw.GetParameters().Length != 0 || mw.ReturnType != typeWrapper)
d3573 1
a3573 1
							mb = typeBuilder.DefineMethod("<propget>" + prop.Name, GetPropertyMethodAttributes(mw, final), typeWrapper.TypeAsSignatureType, Type.EmptyTypes);
d3578 4
d3587 4
d3598 1
a3598 1
				if(prop.setter != null)
d3601 4
a3604 2
					if(mw == null || mw.GetParameters().Length != 1 || mw.GetParameters()[0] != typeWrapper
						|| mw.ReturnType != PrimitiveTypeWrapper.VOID)
d3613 1
a3613 1
							mb = typeBuilder.DefineMethod("<propset>" + prop.Name, GetPropertyMethodAttributes(mw, final), typeof(void), new Type[] { typeWrapper.TypeAsSignatureType });
d3618 4
a3621 1
								ilgen.Emit(OpCodes.Ldarg_0);
d3627 4
a3630 1
								ilgen.Emit(OpCodes.Ldarg_1);
d4041 1
a4041 1
					name = basename + "$" + clashcount;
@


1.31
log
@*** empty log message ***
@
text
@d1848 1
a1848 1
	private static Hashtable nativeMethods;
d2115 1
a2115 1
	internal static void LoadNativeMethods(IKVM.Internal.MapXml.Root map)
d2117 1
a2117 1
		nativeMethods = new Hashtable();
d2119 1
a2119 1
		nativeMethods["java.lang.ExceptionHelper.MapExceptionImpl(Ljava.lang.Throwable;)Ljava.lang.Throwable;"] = new ExceptionMapEmitter(map.exceptionMappings);
d2126 2
a2127 1
				foreach(IKVM.Internal.MapXml.Method method in c.Methods)
d2129 1
a2129 1
					if(method.body != null)
d2131 6
a2136 3
						string methodName = method.Name;
						string methodSig = method.Sig;
						nativeMethods[className + "." + methodName + methodSig] = method.body;
d2164 1
a2164 3
		mappedExceptionsAllSubClasses = new bool[map.exceptionMappings.Length];
		mappedExceptions = new TypeWrapper[map.exceptionMappings.Length];
		for(int i = 0; i < mappedExceptions.Length; i++)
d2166 3
a2168 2
			string dst = map.exceptionMappings[i].dst;
			if(dst[0] == '*')
d2170 7
a2176 2
				mappedExceptionsAllSubClasses[i] = true;
				dst = dst.Substring(1);
a2177 1
			mappedExceptions[i] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dst);
d3185 1
a3185 1
								if(nativeMethods != null)
d3187 1
a3187 1
									CodeEmitter opcodes = (CodeEmitter)nativeMethods[classFile.Name + "." + m.Name + m.Signature];
d3275 1
a3275 1
							if(nativeMethods != null)
d3277 1
a3277 1
								CodeEmitter opcodes = (CodeEmitter)nativeMethods[classFile.Name + "." + m.Name + m.Signature];
d3428 10
d3475 120
@


1.30
log
@*** empty log message ***
@
text
@d3506 1
a3506 1
				ClassLoaderWrapper.SetWrapperForType(type, new CompiledTypeWrapper(type.FullName, type));
d4480 1
a4480 1
sealed class CompiledTypeWrapper : TypeWrapper
d4485 177
a4661 3
	private FieldInfo ghostRefField;
	private Type typeAsBaseType;
	private Type remappedType;
d4711 1
a4711 1
	internal CompiledTypeWrapper(string name, Type type)
a4716 7
		object[] attribs = type.GetCustomAttributes(typeof(RemappedTypeAttribute), false);
		if(attribs.Length == 1)
		{
			this.typeAsBaseType = type;
			this.remappedType = ((RemappedTypeAttribute)attribs[0]).Type;
		}

d4817 1
d4865 1
a4865 24
			if(typeAsBaseType == null)
			{
				if(IsGhost)
				{
					typeAsBaseType = type.GetNestedType("__Interface");
				}
				else
				{
					typeAsBaseType = type;
				}
			}
			return typeAsBaseType;
		}
	}

	internal override FieldInfo GhostRefField
	{
		get
		{
			if(ghostRefField == null)
			{
				ghostRefField = type.GetField("__<ref>");
			}
			return ghostRefField;
d4998 1
a4998 30
		if(remappedType == null)
		{
			foreach(MemberInfo m in members)
			{
				if(!AttributeHelper.IsHideFromJava(m))
				{
					MethodBase method = m as MethodBase;
					if(method != null)
					{
						string name;
						string sig;
						TypeWrapper retType;
						TypeWrapper[] paramTypes;
						GetNameSigFromMethodBase(method, out name, out sig, out retType, out paramTypes);
						MethodInfo mi = method as MethodInfo;
						bool miranda = mi != null ? AttributeHelper.IsMirandaMethod(mi) : false;
						methods.Add(MethodWrapper.Create(this, name, sig, method, retType, paramTypes, AttributeHelper.GetModifiers(method, false), miranda));
					}
					else
					{
						FieldInfo field = m as FieldInfo;
						if(field != null)
						{
							fields.Add(CreateFieldWrapper(field));
						}
					}
				}
			}
		}
		else
d5000 1
a5000 23
			foreach(MemberInfo m in members)
			{
				if(!AttributeHelper.IsHideFromJava(m))
				{
					MethodBase method = m as MethodBase;
					if(method != null &&
						(remappedType.IsSealed || !m.Name.StartsWith("instancehelper_")) &&
						(!remappedType.IsSealed || method.IsStatic))
					{
						methods.Add(CreateRemappedMethodWrapper(method));
					}
					else
					{
						FieldInfo field = m as FieldInfo;
						if(field != null)
						{
							fields.Add(CreateFieldWrapper(field));
						}
					}
				}
			}
			// if we're a remapped interface, we need to get the methods from the real interface
			if(remappedType.IsInterface)
d5002 2
a5003 2
				Type nestedHelper = type.GetNestedType("__Helper", BindingFlags.Public | BindingFlags.Static);
				foreach(RemappedInterfaceMethodAttribute m in type.GetCustomAttributes(typeof(RemappedInterfaceMethodAttribute), false))
a5004 3
					MethodInfo method = remappedType.GetMethod(m.MappedTo);
					MethodInfo mbHelper = method;
					Modifiers modifiers = AttributeHelper.GetModifiers(method, false);
d5010 8
a5017 1
					if(nestedHelper != null)
d5019 1
a5019 5
						mbHelper = nestedHelper.GetMethod(m.Name);
						if(mbHelper == null)
						{
							mbHelper = method;
						}
a5020 1
					methods.Add(new CompiledRemappedMethodWrapper(this, m.Name, sig, method, retType, paramTypes, modifiers, false, mbHelper, null));
a5105 29
	private MethodWrapper CreateRemappedMethodWrapper(MethodBase mb)
	{
		Modifiers modifiers = AttributeHelper.GetModifiers(mb, false);
		string name;
		string sig;
		TypeWrapper retType;
		TypeWrapper[] paramTypes;
		GetNameSigFromMethodBase(mb, out name, out sig, out retType, out paramTypes);
		MethodInfo mbHelper = mb as MethodInfo;
		MethodInfo mbNonvirtualHelper = null;
		if(!mb.IsStatic && !mb.IsConstructor)
		{
			ParameterInfo[] parameters = mb.GetParameters();
			Type[] argTypes = new Type[parameters.Length + 1];
			argTypes[0] = remappedType;
			for(int i = 0; i < parameters.Length; i++)
			{
				argTypes[i + 1] = parameters[i].ParameterType;
			}
			MethodInfo helper = type.GetMethod("instancehelper_" + mb.Name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static, null, argTypes, null);
			if(helper != null)
			{
				mbHelper = helper;
			}
			mbNonvirtualHelper = type.GetMethod("nonvirtualhelper/" + mb.Name, BindingFlags.NonPublic | BindingFlags.Static, null, argTypes, null);
		}
		return new CompiledRemappedMethodWrapper(this, name, sig, mb, retType, paramTypes, modifiers, false, mbHelper, mbNonvirtualHelper);
	}

a5137 16
	internal override bool IsGhost
	{
		get
		{
			return type.IsDefined(typeof(GhostInterfaceAttribute), false);
		}
	}

	internal override bool IsRemapped
	{
		get
		{
			return remappedType != null;
		}
	}

d5142 1
a5142 1
			return remappedType != null ? remappedType : type;
d5301 1
a5301 1
				return new CompiledTypeWrapper(NamePrefix + name, typeBuilder.CreateType());
@


1.29
log
@*** empty log message ***
@
text
@a133 10
	private static ConstructorInfo methodImplAttribute;

	internal static void SetMethodImplAttribute(MethodBuilder mb, System.Runtime.CompilerServices.MethodImplOptions options)
	{
		if(methodImplAttribute == null)
		{
			methodImplAttribute = typeof(System.Runtime.CompilerServices.MethodImplAttribute).GetConstructor(new Type[] { typeof(System.Runtime.CompilerServices.MethodImplOptions) });
		}
		mb.SetCustomAttribute(new CustomAttributeBuilder(methodImplAttribute, new object[] { options }));
	}
d2672 2
a2673 1
				AttributeHelper.SetMethodImplAttribute((MethodBuilder)mb, System.Runtime.CompilerServices.MethodImplOptions.Synchronized);
d3265 2
a3266 1
							ILGenerator ilGenerator = ((MethodBuilder)mb).GetILGenerator();
d3277 6
a3282 1
							Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator, ref verifyError);
d3930 1
a4090 7
						// HACK extremely lame hack!!! Eclipse 3.0 sucks and assumes that it will find this class
						// in the stack trace, but since it contains only very small static methods by default
						// the CLR will inline these methods.
						if(wrapper.Name == "org.eclipse.ui.editors.text.EditorsUI")
						{
							mb.SetImplementationFlags(MethodImplAttributes.NoInlining);
						}
@


1.28
log
@*** empty log message ***
@
text
@d541 8
d1557 2
d1562 29
d3554 2
a3555 1
				FieldBuilder methodPtr = typeBuilder.DefineField(JNI.METHOD_PTR_FIELD_PREFIX + m.Name + m.Signature + ">", typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
d3572 1
a3572 1
				ilGenerator.Emit(OpCodes.Ldstr, m.Signature.Replace('.', '/'));
d4093 7
@


1.27
log
@*** empty log message ***
@
text
@d92 1
a92 1
			ilgen.Emit(OpCodes.Brtrue, ok);
d94 1
a94 1
			ilgen.Emit(OpCodes.Brfalse, ok);	// handle null
d105 17
d1411 2
a1412 1
				ilgen.Emit(OpCodes.Castclass, TypeAsTBD);
d2741 5
@


1.26
log
@*** empty log message ***
@
text
@d38 1
d81 24
d1432 1
a1432 1
			ilgen.Emit(OpCodes.Castclass, TypeAsTBD);
d3565 1
a3565 1
					if(!args[j].IsPrimitive)
d3568 1
a3568 1
						if(args[j].IsNonPrimitiveValueType)
d3573 1
a3573 1
						else if(args[j].IsGhost)
d5178 1
a5178 1
			if(delegateType != null && delegateType.IsSubclassOf(typeof(Delegate)))
d5180 8
d5191 2
a5192 23
				MethodInfo invoke = delegateType.GetMethod("Invoke");
				if(invoke != null)
				{
					ParameterInfo[] parameters = invoke.GetParameters();
					Type[] args = new Type[parameters.Length];
					for(int i = 0; i < args.Length; i++)
					{
						// HACK if the delegate has pointer args, we cannot handle them, but it is already
						// too late to refuse to load the class, so we replace pointers with IntPtr.
						// This is not a solution, because if the delegate would be instantiated the generated
						// code would be invalid.
						if(parameters[i].ParameterType.IsPointer)
						{
							args[i] = typeof(IntPtr);
						}
						else
						{
							args[i] = parameters[i].ParameterType;
						}
					}
					typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Abstract | MethodAttributes.Virtual, CallingConventions.Standard, invoke.ReturnType, args);
					return new CompiledTypeWrapper(NamePrefix + name, typeBuilder.CreateType());
				}
d5595 1
a5595 1
			if(IsDelegate)
d5866 1
a5866 1
	private bool IsDelegate
d5868 5
a5872 1
		get
d5874 13
a5886 5
			// HACK non-public delegates do not get the special treatment (because they are likely to refer to
			// non-public types in the arg list and they're not really useful anyway)
			// NOTE we don't have to check in what assembly the type lives, because this is a DotNetTypeWrapper,
			// we know that it is a different assembly.
			return !type.IsAbstract && type.IsSubclassOf(typeof(MulticastDelegate)) && IsVisible(type);
d5888 1
d5899 1
a5899 1
					if(IsDelegate)
d5901 1
a5901 1
						innerClasses = new TypeWrapper[] { GetClassLoader().LoadClassByDottedName(Name + DelegateInterfaceSuffix) };
d6065 1
a6065 1
		ilgen.Emit(OpCodes.Castclass, type);
@


1.25
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d475 1
a475 1
		if(JVM.IsStaticCompiler)
d489 1
a489 1
			Debug.Assert(!IsUnloadable);
d905 1
a905 9
	internal Type TypeAsFieldType
	{
		get
		{
			return TypeAsParameterType;
		}
	}

	internal Type TypeAsParameterType
d986 1
a986 7
			Type t = TypeAsTBD;
			// HACK BYTE[]
			//if(t == typeof(sbyte))
			//{
			//	return typeof(byte);
			//}
			return t;
d1326 23
a1348 1
	// NOTE sourceType is optional and only used for special types (e.g. interfaces),
d1350 1
a1350 1
	internal void EmitConvStackToParameterType(ILGenerator ilgen, TypeWrapper sourceType)
d1358 1
a1358 1
				LocalBuilder local2 = ilgen.DeclareLocal(TypeAsParameterType);
d1363 1
a1363 1
				ilgen.Emit(OpCodes.Ldobj, TypeAsParameterType);
a1377 19
	internal void EmitConvParameterToStackType(ILGenerator ilgen)
	{
		if(IsUnloadable)
		{
			// nothing to do
		}
		else if(IsNonPrimitiveValueType)
		{
			EmitBox(ilgen);
		}
		else if(IsGhost)
		{
			LocalBuilder local = ilgen.DeclareLocal(TypeAsParameterType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(OpCodes.Ldloca, local);
			ilgen.Emit(OpCodes.Ldfld, GhostRefField);
		}
	}

d1591 1
a1591 1
	internal static readonly PrimitiveTypeWrapper BYTE = new PrimitiveTypeWrapper(typeof(sbyte), "B");
d1667 5
d2275 2
d2472 1
a2472 5
					if(caller[i].TypeAsParameterType == typeof(sbyte[]) && callee[i].TypeAsParameterType == typeof(byte[]))
					{
						// special case for byte array cheating...
					}
					else if(!caller[i].IsAssignableTo(callee[i]))
d2624 1
a2624 1
			Type type = typeWrapper.TypeAsFieldType;
d2900 1
a2900 1
							mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, wrapper.TypeAsParameterType, new Type[] { implementers[i].TypeAsParameterType });
d2903 1
a2903 1
							local = ilgen.DeclareLocal(wrapper.TypeAsParameterType);
d2908 1
a2908 1
							ilgen.Emit(OpCodes.Ldobj, wrapper.TypeAsParameterType);			
d3000 1
a3000 1
						local = ilgen.DeclareLocal(wrapper.TypeAsParameterType);
d3005 1
a3005 1
						ilgen.Emit(OpCodes.Ldobj, wrapper.TypeAsParameterType);	
d3247 1
a3247 1
							MethodBuilder mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, interfaces[i].TypeAsParameterType, new Type[] { wrapper.TypeAsParameterType });
d3250 1
a3250 1
							LocalBuilder local = ilgen.DeclareLocal(interfaces[i].TypeAsParameterType);
d3255 1
a3255 1
							ilgen.Emit(OpCodes.Ldobj, interfaces[i].TypeAsParameterType);			
d3316 1
a3316 1
							FieldBuilder fb = tbFields.DefineField(f.Name, typeWrapper.TypeAsFieldType, attribs);
d3322 1
a3322 1
							FieldBuilder fb = tbFields.DefineField(f.Name, typeWrapper.TypeAsFieldType, attribs);
d3401 1
a3401 1
					argTypes[0] = wrapper.TypeAsParameterType;
d3405 1
a3405 1
					argTypes[i + instance] = args[i].TypeAsParameterType;
d3408 1
a3408 1
				MethodBuilder mb = tb.DefineMethod("method", MethodAttributes.Public | MethodAttributes.Static, mw.ReturnType.TypeAsParameterType, argTypes);
d3502 1
a3502 1
				if(!retTypeWrapper.IsPrimitive)
d3513 1
a3513 1
					modargs[i + 2] = args[i].TypeAsParameterType;
a3542 1
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
d3545 1
d3548 9
d3566 1
a3566 1
				ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, (retTypeWrapper.IsPrimitive) ? retTypeWrapper.TypeAsParameterType : typeof(IntPtr), modargs);
d3577 11
a3587 1
						else if(!retTypeWrapper.IsGhost)
d3592 1
a3592 1
					retValue = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
d5083 1
a5083 1
		if(type.IsAbstract)
d5388 3
a5390 2
			// NOTE we don't support custom boxing rules for enums
			ilgen.Emit(OpCodes.Box, ((DotNetTypeWrapper)DeclaringType).type);
d5447 1
a5447 1
		// of the subset of Java primitives (i.e. sbyte, short, int, long)
d5453 1
a5453 1
				return unchecked((sbyte)((IConvertible)obj).ToInt32(null));
d5527 1
a5527 1
			if(underlyingType == typeof(byte))
d5529 1
a5529 1
				underlyingType = typeof(sbyte);
d5646 1
d5669 13
a5681 2
									// TODO handle name/signature clash
									methodsList.Add(CreateMethodWrapper(name, sig, map.InterfaceMethods[j], true));
@


1.24
log
@*** empty log message ***
@
text
@d1703 8
d1713 1
a1713 1
		if(JVM.IsStaticCompiler || ClassLoaderWrapper.IsSaveDebugImage)
@


1.23
log
@*** empty log message ***
@
text
@a34 43
sealed class MethodDescriptor
{
	private string name;
	private string sig;

	internal MethodDescriptor(string name, string sig)
	{
		Debug.Assert(name != null && sig != null);
		// class name in the sig should be dotted
		Debug.Assert(sig.IndexOf('/') < 0);

		this.name = name;
		this.sig = sig;
	}

	internal string Name
	{
		get
		{
			return name;
		}
	}

	internal string Signature
	{
		get
		{
			return sig;
		}
	}

	public override bool Equals(object o)
	{
		MethodDescriptor md = o as MethodDescriptor;
		return md != null && md.name == name && md.sig == sig;
	}

	public override int GetHashCode()
	{
		return name.GetHashCode() ^ sig.GetHashCode();
	}
}

d37 1
a37 1
	private static MethodInfo objectToString = typeof(object).GetMethod("ToString");
d42 1
a42 2
		MethodDescriptor md = new MethodDescriptor("<init>", "()V");
		MethodWrapper mw = exception.GetMethodWrapper(md, false);
d52 1
a52 2
		MethodDescriptor md = new MethodDescriptor("<init>", "(Ljava.lang.String;)V");
		MethodWrapper mw = exception.GetMethodWrapper(md, false);
d92 10
d456 2
a457 2
	private readonly Hashtable methods = new Hashtable();
	private readonly Hashtable fields = new Hashtable();
d717 1
a717 3
	protected abstract FieldWrapper GetFieldImpl(string fieldName, string fieldSig);

	internal virtual FieldWrapper GetFieldWrapper(string fieldName, string fieldSig)
d719 15
a733 1
		lock(fields.SyncRoot)
d735 2
a736 3
			string key = fieldName + fieldSig;
			FieldWrapper fae = (FieldWrapper)fields[key];
			if(fae == null)
d738 1
a738 18
				fae = GetFieldImpl(fieldName, fieldSig);
				if(fae == null)
				{
					foreach(TypeWrapper iface in this.Interfaces)
					{
						fae = iface.GetFieldWrapper(fieldName, fieldSig);
						if(fae != null)
						{
							return fae;
						}
					}
					if(baseWrapper != null)
					{
						return baseWrapper.GetFieldWrapper(fieldName, fieldSig);
					}
					return null;
				}
				fields[key] = fae;
a739 1
			return fae;
d741 5
d748 1
a748 5
	// TODO figure out when it is safe to call this
	// HACK for now we assume that the method hashtable has always been filled when this method is called (by java.lang.Class)
	// UPDATE the above concerns should no longer apply, DynamicTypeWrappers now publish their methods eagerly and all
	// others (derived from LazyTypeWrapper) override this method to do the publishing
	internal virtual MethodWrapper[] GetMethods()
d750 20
a769 3
		MethodWrapper[] wrappers = new MethodWrapper[methods.Count];
		methods.Values.CopyTo(wrappers, 0);
		return wrappers;
d772 1
a772 3
	// TODO figure out when it is safe to call this
	// HACK for now we assume that the fields hashtable has always been filled when this method is called (by java.lang.Class)
	internal virtual FieldWrapper[] GetFields()
d774 8
a781 3
		FieldWrapper[] wrappers = new FieldWrapper[fields.Count];
		fields.Values.CopyTo(wrappers, 0);
		return wrappers;
d784 1
a784 1
	internal virtual MethodWrapper GetMethodWrapper(MethodDescriptor md, bool inherit)
d786 15
a800 2
		MethodWrapper mw = (MethodWrapper)methods[md];
		if(mw == null && inherit && baseWrapper != null)
d802 1
a802 1
			mw = baseWrapper.GetMethodWrapper(md, inherit);
d804 1
a804 1
		return mw;
d807 1
a807 1
	internal void AddMethod(MethodWrapper method)
d809 2
a810 2
		Debug.Assert(method != null);
		methods[method.Descriptor] = method;
d813 1
a813 1
	internal void AddField(FieldWrapper field)
d815 2
a816 2
		Debug.Assert(field != null);
		fields[field.Name + field.FieldTypeWrapper.SigName] = field;
d947 1
a947 1
			// HACK as a convenience to the compiler, we replace return address types with typeof(int)
a1194 1
		MethodDescriptor md = ifmethod.Descriptor;
d1202 1
a1202 1
			mce = lookup.GetMethodWrapper(md, true);
d1219 1
a1219 1
				EmitHelper.Throw(mb.GetILGenerator(), "java.lang.IllegalAccessError", wrapper.Name + "." + md.Name + md.Signature);
d1265 1
a1265 1
				EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + md.Name + md.Signature);
d1509 1
a1509 1
	internal virtual void LinkField(FieldWrapper fw)
d1511 1
d1543 1
a1543 1
	protected override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
d1545 1
a1545 6
		throw new InvalidOperationException("GetFieldImpl called on UnloadableTypeWrapper: " + Name);
	}

	internal override MethodWrapper GetMethodWrapper(MethodDescriptor md, bool inherit)
	{
		throw new InvalidOperationException("GetMethodWrapper called on UnloadableTypeWrapper: " + Name);
a1650 5
	protected override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
	{
		return null;
	}

d1680 81
a1880 5
	protected override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
	{
		return impl.GetFieldImpl(fieldName, fieldSig);
	}

d2028 1
a2028 1
					MethodWrapper mw = tw.GetMethodWrapper(new MethodDescriptor("<init>", "()V"), false);
a2110 1
		internal abstract FieldWrapper GetFieldImpl(string fieldName, string fieldSig);
d2118 1
a2118 1
		internal abstract void LinkField(FieldWrapper fw);
a2128 2
		private Hashtable methodLookup;
		private Hashtable fieldLookup;
a2147 1
			methodLookup = new Hashtable();
a2164 1
				MethodDescriptor md = new MethodDescriptor(m.Name, m.Signature);
d2167 1
a2167 1
					methods[i] = new MethodWrapper.GhostMethodWrapper(wrapper, md, null, null, null, m.Modifiers, MemberFlags.None);
d2171 1
a2171 1
					methods[i] = new SmartConstructorMethodWrapper(wrapper, md, null, null, m.Modifiers, MemberFlags.None);
d2178 1
a2178 1
						baseMethods[i] = FindBaseMethod(md, out explicitOverride);
d2180 1
a2180 1
					methods[i] = new SmartCallMethodWrapper(wrapper, md, null, null, null, m.Modifiers, explicitOverride ? MemberFlags.ExplicitOverride : MemberFlags.None, OpCodes.Call, OpCodes.Callvirt);
a2181 2
				methodLookup[md] = i;
				wrapper.AddMethod(methods[i]);
d2192 20
d2392 26
d2431 1
a2431 1
							MethodWrapper mw = lookup.GetMethodWrapper(ifmethod.Descriptor, true);
d2434 1
a2434 2
								mw = new SmartCallMethodWrapper(wrapper, ifmethod.Descriptor, null, null, null, Modifiers.Public | Modifiers.Abstract, MemberFlags.HideFromReflection, OpCodes.Call, OpCodes.Callvirt);
								methodLookup[ifmethod.Descriptor] = methods.Count;
a2436 1
								wrapper.AddMethod(mw);
d2539 12
d2555 1
a2555 1
			int index = (int)methodLookup[mw.Descriptor];
d2596 19
a2614 1
			return GenerateMethod(index, unloadableOverrideStub);
d2617 1
a2617 1
		internal override void LinkField(FieldWrapper fw)
d2620 132
a2751 1
			// TODO
d2791 4
a2794 4
//			for(int i = 0; i < fields.Length; i++)
//			{
//				fields[i].Link();
//			}
a2838 17
				if(fieldLookup == null)
				{
					fields = new FieldWrapper[classFile.Fields.Length];
					fieldLookup = new Hashtable();
					for(int i = 0; i < classFile.Fields.Length; i++)
					{
						fieldLookup[classFile.Fields[i].Name + classFile.Fields[i].Signature] = i;
					}
				}
				for(int i = 0; i < fields.Length; i++)
				{
					if(fields[i] == null)
					{
						GenerateField(i);
						wrapper.AddField(fields[i]);
					}
				}
d2878 1
a2878 1
								MethodWrapper mw = implementers[j].GetMethodWrapper(methods[i].Descriptor, true);
d3047 1
a3047 1
							if(mi != null && mi.IsAbstract && wrapper.GetMethodWrapper(mw.Descriptor, true).IsAbstract)
d3283 1
a3283 1
										AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Descriptor, ref hashtable, false);
d3293 1
a3293 1
									AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Descriptor, ref hashtable, true);
d3300 37
d3342 5
d3436 1
a3436 1
			private static readonly MethodInfo monitorEnter = typeof(ByteCodeHelper).GetMethod("monitorenter");
d3451 1
a3451 1
				if(m.IsSynchronized)
d3453 8
a3460 15
					if(m.IsStatic)
					{
						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
						Label label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Brtrue_S, label);
						ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
						ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandle);
						ilGenerator.Emit(OpCodes.Stsfld, classObjectField);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Ldsfld, classObjectField);
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldarg_0);
					}
d3584 1
a3584 1
				if(m.IsSynchronized)
a3636 24
		internal override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
		{
			if(fieldLookup == null)
			{
				fields = new FieldWrapper[classFile.Fields.Length];
				fieldLookup = new Hashtable();
				for(int i = 0; i < classFile.Fields.Length; i++)
				{
					fieldLookup[classFile.Fields[i].Name + classFile.Fields[i].Signature] = i;
				}
			}
			object index = fieldLookup[fieldName + fieldSig];
			if(index != null)
			{
				int i = (int)index;
				if(fields[i] == null)
				{
					GenerateField(i);
				}
				return fields[i];
			}
			return null;
		}

a3671 141
		private void GenerateField(int i)
		{
			Profiler.Enter("JavaTypeImpl.GenerateField");
			try
			{
				FieldBuilder field;
				ClassFile.Field fld = classFile.Fields[i];
				string fieldName = fld.Name;
				// TODO we're not allowed to load types here (potentially), it needs to be done in the Link step
				TypeWrapper typeWrapper = ClassFile.FieldTypeWrapperFromSig(wrapper.GetClassLoader(), classCache, fld.Signature);
				Type type = typeWrapper.TypeAsFieldType;
				bool setNameSig = typeWrapper.IsUnloadable || typeWrapper.IsGhostArray;
				if(setNameSig)
				{
					// TODO use clashtable
					// the field name is mangled here, because otherwise it can (theoretically)
					// conflict with another unloadable or object or ghost array field
					// (fields can be overloaded on type)
					fieldName += "/" + typeWrapper.Name;
				}
				FieldAttributes attribs = 0;
				MethodAttributes methodAttribs = 0;
				bool setModifiers = false;
				if(fld.IsPrivate)
				{
					attribs |= FieldAttributes.Private;
				}
				else if(fld.IsProtected)
				{
					attribs |= FieldAttributes.FamORAssem;
					methodAttribs |= MethodAttributes.FamORAssem;
				}
				else if(fld.IsPublic)
				{
					attribs |= FieldAttributes.Public;
					methodAttribs |= MethodAttributes.Public;
				}
				else
				{
					attribs |= FieldAttributes.Assembly;
					methodAttribs |= MethodAttributes.Assembly;
				}
				if(fld.IsStatic)
				{
					attribs |= FieldAttributes.Static;
					methodAttribs |= MethodAttributes.Static;
				}
				// NOTE "constant" static finals are converted into literals
				// TODO it would be possible for Java code to change the value of a non-blank static final, but I don't
				// know if we want to support this (since the Java JITs don't really support it either)
				object constantValue = fld.ConstantValue;
				if(fld.IsStatic && fld.IsFinal && constantValue != null)
				{
					Profiler.Count("Static Final Constant");
					attribs |= FieldAttributes.Literal;
					field = typeBuilder.DefineField(fieldName, type, attribs);
					field.SetConstant(constantValue);
					fields[i] = new ConstantFieldWrapper(wrapper, typeWrapper, fld.Name, fld.Signature, fld.Modifiers, field, constantValue);
				}
				else
				{
					bool isWrappedFinal = fld.IsFinal && (fld.IsPublic || fld.IsProtected) && !wrapper.IsInterface;
					if(isWrappedFinal)
					{
						// NOTE public/protected blank final fields get converted into a read-only property with a private field
						// backing store
						// we used to make the field privatescope, but that really serves no purpose (and it hinders
						// serialization, which uses .NET reflection to get at the field)
						attribs &= ~FieldAttributes.FieldAccessMask;
						attribs |= FieldAttributes.Private;
						setModifiers = true;
					}
					else if(fld.IsFinal)
					{
						setModifiers = true;
					}
					field = typeBuilder.DefineField(fieldName, type, attribs);
					if(fld.IsTransient)
					{
						CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(typeof(NonSerializedAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
						field.SetCustomAttribute(transientAttrib);
					}
					if(fld.IsVolatile)
					{
						// TODO the field should be marked as modreq(IsVolatile), but Reflection.Emit doesn't have a way of doing this
						setModifiers = true;
					}
					// Instance fields can also have a ConstantValue attribute (and are inlined by the compiler),
					// and ikvmstub has to export them, so we have to add a custom attribute.
					if(constantValue != null)
					{
						CustomAttributeBuilder constantValueAttrib = new CustomAttributeBuilder(typeof(ConstantValueAttribute).GetConstructor(new Type[] { constantValue.GetType() }), new object[] { constantValue });
						field.SetCustomAttribute(constantValueAttrib);
					}
					if(isWrappedFinal)
					{
						methodAttribs |= MethodAttributes.SpecialName;
						// TODO we should ensure that the getter method name doesn't clash with an existing method
						MethodBuilder getter = typeBuilder.DefineMethod("get_" + fld.Name, methodAttribs, CallingConventions.Standard, type, Type.EmptyTypes);
						AttributeHelper.HideFromJava(getter);
						ILGenerator ilgen = getter.GetILGenerator();
						if(fld.IsStatic)
						{
							ilgen.Emit(OpCodes.Ldsfld, field);
						}
						else
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldfld, field);
						}
						ilgen.Emit(OpCodes.Ret);
						PropertyBuilder pb = typeBuilder.DefineProperty(fld.Name, PropertyAttributes.None, type, Type.EmptyTypes);
						pb.SetGetMethod(getter);
						fields[i] = new GetterFieldWrapper(wrapper, typeWrapper, field, fld.Name, fld.Signature, fld.Modifiers, getter);
					}
					else
					{
						fields[i] = FieldWrapper.Create(wrapper, typeWrapper, field, fld.Name, fld.Signature, fld.Modifiers);
					}
				}
				// if the Java modifiers cannot be expressed in .NET, we emit the Modifiers attribute to store
				// the Java modifiers
				if(setModifiers)
				{
					AttributeHelper.SetModifiers(field, fld.Modifiers);
				}
				if(setNameSig)
				{
					AttributeHelper.SetNameSig(field, fld.Name, fld.Signature);
				}
				if(JVM.IsStaticCompiler && fld.DeprecatedAttribute)
				{
					AttributeHelper.SetDeprecatedAttribute(field);
				}
			}
			finally
			{
				Profiler.Leave("JavaTypeImpl.GenerateField");
			}
		}

d3692 1
a3692 1
		private MethodWrapper FindBaseMethod(MethodDescriptor md, out bool explicitOverride)
d3695 1
a3695 1
			Debug.Assert(md.Name != "<init>");
d3702 1
a3702 1
				MethodWrapper baseMethod = tw.GetMethodWrapper(md, true);
a3870 1
					MethodDescriptor md = methods[index].Descriptor;
d3913 1
a3913 1
						if(baseMce != null && md.Name == "finalize" && md.Signature == "()V")
d4133 1
a4133 1
		private void AddMethodOverride(MethodWrapper method, MethodBuilder mb, TypeWrapper iface, MethodDescriptor md, ref Hashtable hashtable, bool unloadableOnly)
d4139 1
a4139 1
			MethodWrapper mw = iface.GetMethodWrapper(md, false);
d4158 1
a4158 1
				AddMethodOverride(method, mb, iface2, md, ref hashtable, unloadableOnly);
a4204 5
		internal override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
		{
			return null;
		}

d4213 1
a4213 1
		internal override void LinkField(FieldWrapper fw)
d4215 1
a4290 5
		internal override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
		{
			return null;
		}
	
d4319 1
a4319 1
		internal override void LinkField(FieldWrapper fw)
d4323 1
d4368 1
a4368 1
	internal override void LinkField(FieldWrapper fw)
d4371 1
a4371 91
		impl.LinkField(fw);
	}
}

// TODO this is the base class of CompiledTypeWrapper (ikmvc compiled Java types)
// and DotNetTypeWrapper (.NET types), it should have a better name.
abstract class LazyTypeWrapper : TypeWrapper
{
	private bool membersPublished;

	protected LazyTypeWrapper(Modifiers modifiers, string name, TypeWrapper baseTypeWrapper, ClassLoaderWrapper classLoader)
		: base(modifiers, name, baseTypeWrapper, classLoader, null)
	{
	}

	protected abstract void LazyPublishMembers();

	private void Publish()
	{
		LazyPublishMembers();
		foreach(MethodWrapper mw in GetMethods())
		{
			mw.Link();
		}
		foreach(FieldWrapper fw in GetFields())
		{
			fw.Link();
		}
	}

	internal override MethodWrapper[] GetMethods()
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				Publish();
			}
		}
		return base.GetMethods();
	}

	internal override MethodWrapper GetMethodWrapper(MethodDescriptor md, bool inherit)
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				Publish();
			}
		}
		return base.GetMethodWrapper(md, inherit);
	}

	internal override FieldWrapper[] GetFields()
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				Publish();
			}
		}
		return base.GetFields ();
	}

	internal override FieldWrapper GetFieldWrapper(string fieldName, string fieldSig)
	{
		lock(this)
		{
			if(!membersPublished)
			{
				membersPublished = true;
				Publish();
			}
		}
		return base.GetFieldWrapper (fieldName, fieldSig);
	}

	protected sealed override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
	{
		return null;
	}

	internal sealed override void Finish(bool forDebugSave)
	{
		// NOTE the whole notion of "finishing" doesn't apply to .NET and statically compiled types,
		// because instances of these types can be created without needing to involve the IKVM runtime
d4375 1
a4375 1
sealed class CompiledTypeWrapper : LazyTypeWrapper
d4433 1
a4433 1
		: base(GetModifiers(type), name, GetBaseTypeWrapper(type), GetClassLoader(type))
d4745 2
d4764 1
a4764 1
						AddMethod(MethodWrapper.Create(this, new MethodDescriptor(name, sig), method, retType, paramTypes, AttributeHelper.GetModifiers(method, false), miranda));
d4771 1
a4771 1
							AddField(CreateFieldWrapper(field));
d4788 1
a4788 1
						AddMethod(CreateRemappedMethodWrapper(method));
d4795 1
a4795 1
							AddField(CreateFieldWrapper(field));
d4822 1
a4822 1
					AddMethod(new CompiledRemappedMethodWrapper(this, new MethodDescriptor(m.Name, sig), method, retType, paramTypes, modifiers, false, mbHelper, null));
d4826 2
d4835 2
a4836 2
		internal CompiledRemappedMethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection, MethodInfo mbHelper, MethodInfo mbNonvirtualHelper)
			: base(declaringType, md, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
d4934 1
a4934 1
		return new CompiledRemappedMethodWrapper(this, new MethodDescriptor(name, sig), mb, retType, paramTypes, modifiers, false, mbHelper, mbNonvirtualHelper);
d5000 4
d5023 1
a5023 1
sealed class DotNetTypeWrapper : LazyTypeWrapper
d5225 1
a5225 1
		: base(GetModifiers(type), GetName(type), GetBaseTypeWrapper(type), null)
d5247 1
a5247 1
			: base(declaringType, new MethodDescriptor("<init>", "(" + iface.SigName + ")V"), null, PrimitiveTypeWrapper.VOID, new TypeWrapper[] { iface }, Modifiers.Public, MemberFlags.None)
d5272 2
a5273 2
		internal ByRefMethodWrapper(Type[] args, bool[] byrefs, TypeWrapper declaringType, MethodDescriptor md, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection)
			: base(declaringType, md, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
d5363 1
a5363 1
			: base(tw, new MethodDescriptor("wrap", "(" + fieldType.SigName + ")" + tw.SigName), null, tw, new TypeWrapper[] { fieldType }, Modifiers.Static | Modifiers.Public, MemberFlags.None)
d5478 1
a5478 1
			: base(tw, new MethodDescriptor("<init>", "()V"), null, PrimitiveTypeWrapper.VOID, TypeWrapper.EmptyArray, Modifiers.Public, MemberFlags.None)
d5501 2
d5539 1
a5539 1
					AddField(new ConstantFieldWrapper(this, fieldType, name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], val));
d5542 2
a5543 2
			AddField(new EnumValueFieldWrapper(this, fieldType));
			AddMethod(new EnumWrapMethodWrapper(this, fieldType));
d5558 1
a5558 1
					AddField(CreateFieldWrapperDotNet(AttributeHelper.GetModifiers(fields[i], true), fields[i].Name, fields[i].FieldType, fields[i]));
d5568 1
a5568 1
				AddMethod(new DelegateMethodWrapper(this, type, iface));
d5576 3
a5578 2
				MethodDescriptor md = MakeMethodDescriptor(constructors[i]);
				if(md != null)
d5580 1
a5580 1
					if(fabricateDefaultCtor && !constructors[i].IsStatic && md.Signature == "()V")
d5585 1
a5585 1
					AddMethod(CreateMethodWrapper(md, constructors[i], false));
d5592 1
a5592 1
				AddMethod(new ValueTypeDefaultCtor(this));
d5604 3
a5606 2
					MethodDescriptor md = MakeMethodDescriptor(methods[i]);
					if(md != null)
d5610 1
a5610 1
							MethodWrapper baseMethod = BaseTypeWrapper.GetMethodWrapper(md, true);
d5617 1
a5617 1
						AddMethod(CreateMethodWrapper(md, methods[i], false));
d5636 3
a5638 2
								MethodDescriptor md = MakeMethodDescriptor(map.InterfaceMethods[j]);
								if(md != null)
d5642 1
a5642 1
										MethodWrapper baseMethod = BaseTypeWrapper.GetMethodWrapper(md, true);
d5649 1
a5649 1
									AddMethod(CreateMethodWrapper(md, map.InterfaceMethods[j], true));
d5676 1
a5676 1
								AddMethod(new BaseFinalMethodWrapper(this, m));
d5684 2
d5693 1
a5693 1
			: base(tw, m.Descriptor, m.GetMethod(), m.ReturnType, m.GetParameters(), m.Modifiers | Modifiers.Final, MemberFlags.None)
d5716 1
a5716 1
	private MethodDescriptor MakeMethodDescriptor(MethodBase mb)
d5720 3
a5722 1
			return null;
d5733 3
a5735 1
				return null;
d5741 3
a5743 1
					return null;
d5750 3
a5752 1
					return null;
a5762 1
			string name;
d5772 2
a5773 1
			return new MethodDescriptor(name, sb.ToString());
d5780 3
a5782 1
				return null;
d5786 3
a5788 1
			return new MethodDescriptor(mb.Name, sb.ToString());
d5906 1
a5906 1
	private MethodWrapper CreateMethodWrapper(MethodDescriptor md, MethodBase mb, bool privateInterfaceImplHack)
d5909 1
a5909 1
		if(md.Name == "Finalize" && md.Signature == "()V" && !mb.IsStatic &&
d5913 1
a5913 1
			MethodWrapper mw = new SimpleCallMethodWrapper(this, new MethodDescriptor("finalize", "()V"), (MethodInfo)mb, null, null, mods, false, OpCodes.Call, OpCodes.Callvirt);
d5946 1
a5946 1
			return new ByRefMethodWrapper(args, byrefs, this, md, mb, null, null, mods, false);
d5953 1
a5953 1
				return new SmartConstructorMethodWrapper(this, md, (ConstructorInfo)mb, null, mods, false);
d5958 1
a5958 1
				return new SmartCallMethodWrapper(this, md, (MethodInfo)mb, null, null, mods, false, OpCodes.Call, OpCodes.Callvirt);
d6010 13
d6037 4
d6043 1
a6043 1
			clone = typeof(Array).GetMethod("Clone");
d6045 1
a6045 1
		MethodWrapper mw = new SimpleCallMethodWrapper(this, new MethodDescriptor("clone", "()Ljava.lang.Object;"), clone, CoreClasses.java.lang.Object.Wrapper, TypeWrapper.EmptyArray, Modifiers.Public, true, OpCodes.Callvirt, OpCodes.Callvirt);
d6047 2
a6048 1
		AddMethod(mw);
a6114 5
	protected override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
	{
		return null;
	}

@


1.22
log
@*** empty log message ***
@
text
@d5980 1
d5982 1
a5982 2
	// TODO what's the protection domain of an array type?
	internal ArrayTypeWrapper(Type type, Modifiers modifiers, string name, ClassLoaderWrapper classLoader)
d5986 1
d5996 8
@


1.21
log
@*** empty log message ***
@
text
@d494 1
d500 1
a500 1
	internal TypeWrapper(Modifiers modifiers, string name, TypeWrapper baseWrapper, ClassLoaderWrapper classLoader)
d510 17
d1526 1
a1526 1
		: base(TypeWrapper.UnloadableModifiersHack, name, null, null)
d1629 1
a1629 1
		: base(Modifiers.Public | Modifiers.Abstract | Modifiers.Final, null, null, null)
d1723 2
a1724 2
	internal DynamicTypeWrapper(ClassFile f, ClassLoaderWrapper classLoader)
		: base(f.Modifiers, f.Name, f.IsInterface ? null : LoadTypeWrapper(classLoader, f.SuperClass), classLoader)
d4282 1
a4282 1
		: base(modifiers, name, baseTypeWrapper, classLoader)
d5981 1
d5983 1
a5983 1
		: base(modifiers, name, CoreClasses.java.lang.Object.Wrapper, classLoader)
@


1.20
log
@*** empty log message ***
@
text
@d1853 2
d2802 1
d2820 1
a2820 1
						Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator);
d2941 1
a2941 1
							Compiler.Compile(wrapper, methods[i], classFile, m, ilGenerator);
d3054 9
a3062 2
				finishedType = new FinishedTypeImpl(type, typeBuilderGhostInterface != null ? typeBuilderGhostInterface.CreateType() : null, innerClassesTypeWrappers, declaringTypeWrapper, this.ReflectiveModifiers);
				return finishedType;
a3494 4
						if(constantValue is bool)
						{
							constantValue = ((bool)constantValue) ? 1 : 0;
						}
d4052 73
d5343 1
a5343 1
	private class EnumValueFieldWrapper : FieldWrapper
d5355 20
a5374 1
			ilgen.Emit(OpCodes.Ldobj, tw.type);
d5390 3
a5392 1
		internal override object GetValue(object obj)
d5394 18
a5411 1
			if(FieldTypeWrapper == PrimitiveTypeWrapper.LONG)
d5415 4
d5421 1
a5421 1
				return ((IConvertible)obj).ToInt32(null);
d5424 5
d5468 18
a5485 2
			// TODO handle unsigned underlying type
			TypeWrapper fieldType = ClassLoaderWrapper.GetWrapperFromType(Enum.GetUnderlyingType(type));
d5500 1
a5500 9
					object val;
					if(fieldType == PrimitiveTypeWrapper.LONG)
					{
						val = ((IConvertible)fields[i].GetValue(null)).ToInt64(null);
					}
					else
					{
						val = ((IConvertible)fields[i].GetValue(null)).ToInt32(null);
					}
@


1.19
log
@*** empty log message ***
@
text
@d3785 2
a3786 1
								//baseMethod = null;
d3793 3
d3801 3
d3806 27
d3848 1
a3848 1
						else if(baseMce != null && (explicitOverride || baseMce.RealName != name))
d5615 11
a5625 1
						interfaces[i] = ClassLoaderWrapper.GetWrapperFromType(interfaceTypes[i]);
@


1.18
log
@*** empty log message ***
@
text
@d3485 4
d5324 10
a5333 1
					AddField(new ConstantFieldWrapper(this, fieldType, name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], null));
@


1.17
log
@*** empty log message ***
@
text
@d132 1
d137 18
a154 1
	private static ConstructorInfo wideLineNumberTableAttribute;
a470 16
		if(wideLineNumberTableAttribute == null)
		{
			wideLineNumberTableAttribute = typeof(LineNumberTableAttribute).GetConstructor(new Type[] { typeof(byte[]) });
		}
		if(mb is ConstructorBuilder)
		{
			((ConstructorBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(wideLineNumberTableAttribute, new object[] { table }));
		}
		else
		{
			((MethodBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(wideLineNumberTableAttribute, new object[] { table }));
		}
	}

	internal static void SetLineNumberTable(MethodBase mb, ushort[] table)
	{
d473 1
a473 1
			lineNumberTableAttribute = typeof(LineNumberTableAttribute).GetConstructor(new Type[] { typeof(ushort[]) });
d2197 1
a2197 1
							wrapper.ghostRefField = typeBuilder.DefineField("__ref", typeof(object), FieldAttributes.Public | FieldAttributes.SpecialName);
d2929 9
d3165 1
a3165 1
				FieldBuilder methodPtr = typeBuilder.DefineField("__<jniptr/" + m.Name + m.Signature + ">", typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
d4468 1
a4468 1
				ghostRefField = type.GetField("__ref");
d5738 1
a5738 1
			MethodInfo method = shadow.TypeAsBaseType.GetMethod("shadow/instanceof");
d5755 1
a5755 1
			MethodInfo method = shadow.TypeAsBaseType.GetMethod("shadow/checkcast");
@


1.16
log
@*** empty log message ***
@
text
@d3061 1
a3061 1
				mod = ((AssemblyBuilder)ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder.Assembly).DefineDynamicModule("jniproxy", "jniproxy.dll");
d3154 1
a3154 5
				FieldBuilder methodPtr = wrapper.TypeAsBuilder.DefineField("jniptr/" + m.Name + m.Signature, typeof(IntPtr), FieldAttributes.Static | (thruProxy ? FieldAttributes.Assembly : FieldAttributes.PrivateScope));
				if(thruProxy)
				{
					AttributeHelper.HideFromJava(methodPtr);
				}
d3470 7
@


1.15
log
@*** empty log message ***
@
text
@d5058 1
a5058 1
		: base(GetModifiers(type), GetName(type), GetBaseTypeWrapper(type), ClassLoaderWrapper.GetSystemClassLoader())
d5069 5
@


1.14
log
@*** empty log message ***
@
text
@d310 1
a310 1
		if((mb.IsFinal || (!mb.IsVirtual && !mb.IsPrivate && !assemblyIsPrivate)) && !mb.IsStatic && !mb.IsConstructor)
d3361 3
a3363 1
						if(methods[i].IsLinked)
d5024 6
d5047 4
d5368 8
d5399 8
@


1.13
log
@*** empty log message ***
@
text
@d33 2
d105 1
a105 1
		// NOTE we're *not* running the .cctor is the class is not a Java class
d134 3
d441 41
a657 2
	// TODO since for inner classes, the modifiers returned by Class.getModifiers are different from the actual
	// modifiers (as used by the VM access control mechanism), we need an additional property (e.g. InnerClassModifiers)
a667 1
	// NOTE this property can only be called for finished types!
d688 2
a689 1
			return (modifiers & Modifiers.Abstract) != 0;
a823 13
	internal string PackageName
	{
		get
		{
			int index = name.LastIndexOf('.');
			if(index == -1)
			{
				return "";
			}
			return name.Substring(0, index);
		}
	}

d1322 1
a1322 1
	internal virtual void EmitBox(ILGenerator ilgen)
d2235 4
d2823 1
a2823 1
							if(!classFile.IsAbstract && !classFile.IsInterface)
d3689 1
a3689 1
						if(classFile.IsAbstract || classFile.IsInterface)
d5244 24
d5321 2
d5329 4
d5338 6
d5364 1
a5364 1
			if(!type.IsInterface && !type.IsAbstract)
d5685 32
@


1.12
log
@*** empty log message ***
@
text
@d688 1
a688 1
	protected abstract FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType);
d690 1
a690 1
	internal virtual FieldWrapper GetFieldWrapper(string fieldName, TypeWrapper fieldType)
d694 1
a694 1
			string key = fieldName + fieldType.SigName;
d698 1
a698 1
				fae = GetFieldImpl(fieldName, fieldType);
d703 1
a703 1
						fae = iface.GetFieldWrapper(fieldName, fieldType);
d711 1
a711 1
						return baseWrapper.GetFieldWrapper(fieldName, fieldType);
d1500 1
a1500 1
	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
d1613 1
a1613 1
	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
d1690 24
d1767 1
a1767 1
	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
d1769 1
a1769 1
		return impl.GetFieldImpl(fieldName, fieldType);
a1893 40
		// MONOBUG this method doesn't work on Mono yet, so we use a Type based approach instead
#if USE_TYPEHANDLE_EXCEPTION_MAPPING
		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeHandle"));
			LocalBuilder typehandle = ilgen.DeclareLocal(typeof(RuntimeTypeHandle));
			ilgen.Emit(OpCodes.Stloc, typehandle);
			ilgen.Emit(OpCodes.Ldloca, typehandle);
			MethodInfo get_Value = typeof(RuntimeTypeHandle).GetMethod("get_Value");
			ilgen.Emit(OpCodes.Call, get_Value);
			for(int i = 0; i < map.Length; i++)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Ldtoken, Type.GetType(map[i].src));
				ilgen.Emit(OpCodes.Stloc, typehandle);
				ilgen.Emit(OpCodes.Ldloca, typehandle);
				ilgen.Emit(OpCodes.Call, get_Value);
				Label label = ilgen.DefineLabel();
				ilgen.Emit(OpCodes.Bne_Un_S, label);
				ilgen.Emit(OpCodes.Pop);
				if(map[i].code != null)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					map[i].code.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
				else
				{
					TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map[i].dst);
					tw.GetMethodWrapper(MethodDescriptor.FromNameSig(tw.GetClassLoader(), "<init>", "()V"), false).EmitNewobj.Emit(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
				ilgen.MarkLabel(label);
			}
			ilgen.Emit(OpCodes.Pop);
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.Emit(OpCodes.Ret);
		}
#else // USE_TYPEHANDLE_EXCEPTION_MAPPING
a1927 1
#endif // USE_TYPEHANDLE_EXCEPTION_MAPPING
d2000 1
a2000 1
		internal abstract FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType);
d3293 1
a3293 1
		internal override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
d3304 1
a3304 1
			object index = fieldLookup[fieldName + fieldType.SigName];
d3407 1
a3407 1
					fields[i] = new FieldWrapper.ConstantFieldWrapper(wrapper, typeWrapper, fld.Name, fld.Signature, fld.Modifiers, field, constantValue);
a3443 4
						if(fld.IsVolatile)
						{
							ilgen.Emit(OpCodes.Volatile);
						}
d3456 1
a3456 15
						CodeEmitter emitGet = CodeEmitter.Create(OpCodes.Call, getter);
						CodeEmitter emitSet = null;
						if(fld.IsVolatile)
						{
							emitSet += CodeEmitter.Volatile;
						}
						if(fld.IsStatic)
						{
							emitSet += CodeEmitter.Create(OpCodes.Stsfld, field);
						}
						else
						{
							emitSet += CodeEmitter.Create(OpCodes.Stfld, field);
						}
						fields[i] = FieldWrapper.Create1(wrapper, typeWrapper, fld.Name, fld.Signature, fld.Modifiers, field, emitGet, emitSet);
d3460 1
a3460 1
						fields[i] = FieldWrapper.Create3(wrapper, typeWrapper, field, fld.Signature, fld.Modifiers);
d4001 1
a4001 1
		internal override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
d4141 14
a4154 1
	internal override FieldWrapper GetFieldWrapper(string fieldName, TypeWrapper fieldType)
d4164 1
a4164 1
		return base.GetFieldWrapper (fieldName, fieldType);
d4167 1
a4167 1
	protected sealed override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
d4231 5
d4237 1
a4237 1
		: base(GetModifiers(type), name, GetBaseTypeWrapper(type), ClassLoaderWrapper.GetBootstrapClassLoader())
a4738 1
		MethodInfo getter = null;
d4740 8
d4756 2
a4757 14
			Debug.Assert(prop != null);
			if(prop != null)
			{
				getter = prop.GetGetMethod(true);
			}
		}

		CodeEmitter emitGet;
		CodeEmitter emitSet;
		if((modifiers & Modifiers.Private) != 0)
		{
			// there is no way to emit code to access a private member, so we don't need to generate these
			emitGet = CodeEmitter.InternalError;
			emitSet = CodeEmitter.InternalError;
d4761 1
a4761 20
			if((modifiers & Modifiers.Static) == 0)
			{
				throw new InvalidOperationException("Invalid assembly, a non-static literal field was encountered.");
			}
			// if field is a literal, we must emit an ldc instead of a ldsfld
			emitGet = CodeEmitter.CreateLoadConstantField(field);
			// it is never legal to emit code to set a final field (from outside the class)
			emitSet = CodeEmitter.InternalError;
		}
		else if((modifiers & Modifiers.Static) != 0)
		{
			if(getter != null)
			{
				emitGet = CodeEmitter.Create(OpCodes.Call, getter);
			}
			else
			{
				emitGet = CodeEmitter.Create(OpCodes.Ldsfld, field);
			}
			emitSet = CodeEmitter.Create(OpCodes.Stsfld, field);
d4765 1
a4765 18
			if(getter != null)
			{
				emitGet = CodeEmitter.Create(OpCodes.Callvirt, getter);
			}
			else
			{
				emitGet = CodeEmitter.Create(OpCodes.Ldfld, field);
			}
			emitSet = CodeEmitter.Create(OpCodes.Stfld, field);
		}
		// if the field name is mangled (because its type is unloadable), chop off the mangled bit
		string name = field.Name;
		TypeWrapper type = ClassLoaderWrapper.GetWrapperFromType(field.FieldType);
		if(field.IsDefined(typeof(NameSigAttribute), false))
		{
			NameSigAttribute attr = (NameSigAttribute)field.GetCustomAttributes(typeof(NameSigAttribute), false)[0];
			name = attr.Name;
			SigTypePatchUp(attr.Sig, ref type);
a4766 1
		return FieldWrapper.Create1(this, type, name, type.SigName, modifiers, field, emitGet, emitSet);
d4802 17
d4918 4
d5011 1
a5011 1
		: base(GetModifiers(type), GetName(type), GetBaseTypeWrapper(type), ClassLoaderWrapper.GetBootstrapClassLoader())
d5164 12
a5175 2
			: base(tw, fieldType, "Value", fieldType.SigName, Modifiers.Public | Modifiers.Final, null,
					CodeEmitter.Create(OpCodes.Unbox, tw.type) + CodeEmitter.Create(OpCodes.Ldobj, tw.type), CodeEmitter.Pop + CodeEmitter.Pop)
d5177 1
d5230 1
a5230 1
					AddField(FieldWrapper.Create1(this, fieldType, name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], CodeEmitter.CreateLoadConstantField(fields[i]), CodeEmitter.Pop));
d5249 1
a5249 1
					AddField(CreateFieldWrapper(AttributeHelper.GetModifiers(fields[i], true), fields[i].Name, fields[i].FieldType, fields[i], null));
d5376 4
d5393 4
d5485 1
a5485 1
						innerClasses = new TypeWrapper[nestedTypes.Length];
d5488 4
a5491 1
							innerClasses[i] = ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]);
d5493 1
d5529 1
a5529 3
	// TODO support NonPrimitiveValueTypes
	// TODO why doesn't this use the standard FieldWrapper.Create?
	private FieldWrapper CreateFieldWrapper(Modifiers modifiers, string name, Type fieldType, FieldInfo field, MethodInfo getter)
d5531 2
a5532 3
		CodeEmitter emitGet;
		CodeEmitter emitSet;
		if((modifiers & Modifiers.Private) != 0)
d5534 1
a5534 30
			// there is no way to emit code to access a private member, so we don't need to generate these
			emitGet = CodeEmitter.InternalError;
			emitSet = CodeEmitter.InternalError;
		}
		else if((modifiers & Modifiers.Static) != 0)
		{
			if(getter != null)
			{
				emitGet = CodeEmitter.Create(OpCodes.Call, getter);
			}
			else
			{
				// if field is a literal, we must emit an ldc instead of a ldsfld
				if(field.IsLiteral)
				{
					emitGet = CodeEmitter.CreateLoadConstantField(field);
				}
				else
				{
					emitGet = CodeEmitter.Create(OpCodes.Ldsfld, field);
				}
			}
			if(field != null && !field.IsLiteral)
			{
				emitSet = CodeEmitter.Create(OpCodes.Stsfld, field);
			}
			else
			{
				emitSet = CodeEmitter.InternalError;
			}
d5538 1
a5538 16
			if(getter != null)
			{
				emitGet = CodeEmitter.Create(OpCodes.Callvirt, getter);
			}
			else
			{
				emitGet = CodeEmitter.Create(OpCodes.Ldfld, field);
			}
			if(field != null)
			{
				emitSet = CodeEmitter.Create(OpCodes.Stfld, field);
			}
			else
			{
				emitSet = CodeEmitter.InternalError;
			}
a5539 2
		TypeWrapper type = ClassLoaderWrapper.GetWrapperFromType(fieldType);
		return FieldWrapper.Create1(this, type, name, type.SigName, modifiers, field, emitGet, emitSet);
d5691 1
a5691 1
	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
@


1.11
log
@*** empty log message ***
@
text
@d1870 1
a1870 1
		// this method doesn't work on Mono yet, so we use a Type based approach instead
d3065 1
a3065 1
				for(int i = instance; i < argTypes.Length - 1 + instance; i++)
d3067 1
a3067 1
					argTypes[i] = args[i].TypeAsParameterType;
d3098 2
d3103 38
a3140 1
				FieldBuilder methodPtr = typeBuilder.DefineField("jniptr/" + m.Name + m.Signature, typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
a3199 10
					FieldInfo classObjectField;
					if(thruProxy)
					{
						classObjectField = typeBuilder.DefineField("__<classObject>", typeof(object), FieldAttributes.Static | FieldAttributes.Private);
					}
					else
					{
						classObjectField = wrapper.ClassObjectField;
					}

d3257 7
@


1.10
log
@*** empty log message ***
@
text
@d2396 1
a2396 1
						classObjectField = typeBuilder.DefineField("__<classObject>", CoreClasses.java.lang.Class.Wrapper.TypeAsFieldType, FieldAttributes.Private | FieldAttributes.Static);
d3164 1
a3164 1
						classObjectField = typeBuilder.DefineField("__<classObject>", CoreClasses.java.lang.Class.Wrapper.TypeAsFieldType, FieldAttributes.Static | FieldAttributes.Private);
@


1.9
log
@*** empty log message ***
@
text
@d2006 9
d2045 1
d2388 16
d3056 1
a3056 1
			internal static void Generate(ILGenerator ilGenerator, TypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args)
d3099 1
a3099 1
			internal static void Generate(ILGenerator ilGenerator, TypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args, bool thruProxy)
d3160 14
d3176 4
a3805 7
					// since Java constructors aren't allowed to be synchronized, we only check this here
					if(m.IsSynchronized && !m.IsStatic)
					{
						// NOTE for static methods we cannot get by with setting the MethodImplAttributes.Synchronized flag,
						// we actually need to emit code to lock the Class object!
						mb.SetImplementationFlags(method.GetMethodImplementationFlags() | MethodImplAttributes.Synchronized);
					}
@


1.8
log
@*** empty log message ***
@
text
@d480 8
d1656 1
d1711 8
d2044 1
d2051 14
d2086 1
d2109 4
d2222 49
d2754 1
a2754 1
				bool basehasclinit = wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.TypeAsTBD.TypeInitializer != null;
d3441 1
a3441 2
			// NOTE we don't need to record the modifiers here, because they aren't visible from Java reflection
			if(!classFile.IsFinal && !classFile.IsInterface)
d3454 1
d4243 8
@


1.7
log
@*** empty log message ***
@
text
@d29 3
d901 1
a901 1
			if(IsUnloadable || IsGhost || IsNonPrimitiveValueType)
d905 5
d1787 1
a1787 1
	internal static void SetupGhosts(MapXml.Root map)
d1792 1
a1792 1
		foreach(MapXml.Class c in map.assembly)
d1799 1
a1799 1
				foreach(MapXml.Interface iface in c.Interfaces)
d1846 1
a1846 1
		private MapXml.ExceptionMapping[] map;
d1848 1
a1848 1
		internal ExceptionMapEmitter(MapXml.ExceptionMapping[] map)
d1930 1
a1930 1
	internal static void LoadNativeMethods(MapXml.Root map)
d1935 1
a1935 1
		foreach(MapXml.Class c in map.assembly)
d1941 1
a1941 1
				foreach(MapXml.Method method in c.Methods)
d1973 1
a1973 1
	internal static void LoadMappedExceptions(MapXml.Root map)
d2717 2
a2718 2
								// see if there exists a NativeCode class for this type
								Type nativeCodeType = Type.GetType("NativeCode." + classFile.Name.Replace('$', '+'));
d2978 1
a2978 1
			private static readonly Type localRefStructType = typeof(JniFrame);
d2984 1
a2984 2
			private static readonly MethodInfo getTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle");
			private static readonly MethodInfo getClassFromType = typeof(NativeCode.java.lang.VMClass).GetMethod("getClassFromType");
d3049 1
a3049 2
					ilGenerator.Emit(OpCodes.Call, getTypeFromHandle);
					ilGenerator.Emit(OpCodes.Call, getClassFromType);
@


1.6
log
@*** empty log message ***
@
text
@d2775 1
a2775 1
											JniBuilder.Generate(ilGenerator, wrapper, methods[i], typeBuilder, classFile, m, args);
d2921 5
a2937 4
				if(mod == null)
				{
					mod = ((AssemblyBuilder)ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder.Assembly).DefineDynamicModule("jniproxy", "jniproxy.dll");
				}
d2940 1
a2940 1
				Type[] argTypes = new Type[args.Length + instance];
d2945 1
a2945 1
				for(int i = instance; i < argTypes.Length + instance; i++)
d2949 1
d2951 2
a2952 2
				JniBuilder.Generate(mb.GetILGenerator(), wrapper, mw, tb, classFile, m, args);
				for(int i = 0; i < argTypes.Length; i++)
d2956 1
d2980 1
a2980 1
			internal static void Generate(ILGenerator ilGenerator, TypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args)
d2989 8
a2996 1
				ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
d3004 8
a3011 1
				ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
d5108 1
a5108 1
			if(!type.IsAbstract && type.IsSubclassOf(typeof(Delegate)))
d5110 4
a5113 12
				// HACK non-public delegates do not get the special treatment (because they are likely to refer to
				// non-public types in the arg list and they're not really useful anyway)
				// NOTE we don't have to check in what assembly the type lives, because this is a DotNetTypeWrapper,
				// we know that it is a different assembly.
				if(IsVisible(type))
				{
					TypeWrapper iface = GetClassLoader().LoadClassByDottedName(this.Name + DelegateInterfaceSuffix);
					Debug.Assert(iface is CompiledTypeWrapper);
					iface.Finish();
					AddMethod(new DelegateMethodWrapper(this, type, iface));
					innerClasses = new TypeWrapper[] { iface };
				}
d5304 12
d5324 1
a5324 3
					Type[] nestedTypes = type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic);
					innerClasses = new TypeWrapper[nestedTypes.Length];
					for(int i = 0; i < nestedTypes.Length; i++)
d5326 10
a5335 1
						innerClasses[i] = ClassLoaderWrapper.GetWrapperFromType(nestedTypes[i]);
@


1.5
log
@*** empty log message ***
@
text
@d105 1
a105 1
		FieldInfo field = type.GetField("__<clinit>");
a678 4
//	internal FieldWrapper GetFieldWrapper(string fieldName, string fieldSig)
//	{
//	}

d1384 1
a1384 3
			ilgen.Emit(OpCodes.Ceq);
			ilgen.Emit(OpCodes.Ldc_I4_0);
			ilgen.Emit(OpCodes.Ceq);
d2010 1
d2374 1
a2374 1
			classFile.Link(wrapper);
d2406 1
a2406 1
							if(classFile.GetConstantPoolClassType(innerclasses[i].outerClass, wrapper.GetClassLoader()) == wrapper)
d2408 1
a2408 1
								wrappers.Add(classFile.GetConstantPoolClassType(innerclasses[i].innerClass, wrapper.GetClassLoader()));
d2410 1
a2410 1
							if(classFile.GetConstantPoolClassType(innerclasses[i].innerClass, wrapper.GetClassLoader()) == wrapper)
d2412 1
a2412 1
								declaringTypeWrapper = classFile.GetConstantPoolClassType(innerclasses[i].outerClass, wrapper.GetClassLoader());
d2530 1
a2530 3
						ilgen.Emit(OpCodes.Ceq);
						ilgen.Emit(OpCodes.Ldc_I4_0);
						ilgen.Emit(OpCodes.Ceq);
d2669 1
a2669 1
						Tracer.EmitMethodTrace(ilGenerator, m.ClassFile.Name + "." + m.Name + m.Signature);
d2677 1
a2677 1
						Compiler.Compile(wrapper, m, ilGenerator);
d2685 1
a2685 1
							if(!m.ClassFile.IsAbstract && !m.ClassFile.IsInterface)
d2688 2
a2689 2
								Tracer.EmitMethodTrace(ilGenerator, m.ClassFile.Name + "." + m.Name + m.Signature);
								EmitHelper.Throw(ilGenerator, "java.lang.AbstractMethodError", m.ClassFile.Name + "." + m.Name + m.Signature);
d2698 1
a2698 1
								Tracer.EmitMethodTrace(ilGenerator, m.ClassFile.Name + "." + m.Name + m.Signature);
d2712 1
a2712 1
								TypeWrapper[] args = m.GetArgTypes(wrapper.GetClassLoader());
d2771 1
a2771 1
											JniProxyBuilder.Generate(ilGenerator, wrapper, typeBuilder, m, args);
d2775 1
a2775 1
											JniBuilder.Generate(ilGenerator, wrapper, typeBuilder, m, args);
d2788 2
a2789 2
							Tracer.EmitMethodTrace(ilGenerator, m.ClassFile.Name + "." + m.Name + m.Signature);
							Compiler.Compile(wrapper, m, ilGenerator);
d2931 1
a2931 1
			internal static void Generate(ILGenerator ilGenerator, TypeWrapper wrapper, TypeBuilder typeBuilder, ClassFile.Method m, TypeWrapper[] args)
d2948 2
a2949 2
				MethodBuilder mb = tb.DefineMethod("method", MethodAttributes.Public | MethodAttributes.Static, m.GetRetType(wrapper.GetClassLoader()).TypeAsParameterType, argTypes);
				JniBuilder.Generate(mb.GetILGenerator(), wrapper, tb, m, args);
d2967 2
a2968 2
			private static readonly Type localRefStructType = JVM.JniProvider.GetLocalRefStructType();
			private static readonly MethodInfo jniFuncPtrMethod = JVM.JniProvider.GetJniFuncPtrMethod();
d2977 1
a2977 1
			internal static void Generate(ILGenerator ilGenerator, TypeWrapper wrapper, TypeBuilder typeBuilder, ClassFile.Method m, TypeWrapper[] args)
d2979 1
a2979 1
				FieldBuilder methodPtr = typeBuilder.DefineField(m.Name + "$Ptr", typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
d2986 2
a2989 1
				ilGenerator.Emit(OpCodes.Ldstr, m.ClassFile.Name.Replace('.', '/'));
d2994 1
d2999 1
a2999 1
				TypeWrapper retTypeWrapper = m.GetRetType(wrapper.GetClassLoader());
d3186 2
a3187 1
				TypeWrapper typeWrapper = fld.GetFieldType(wrapper.GetClassLoader());
d3235 1
a3235 1
					fields[i] = new FieldWrapper.ConstantFieldWrapper(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), fld.Name, fld.Signature, fld.Modifiers, field, constantValue);
d3243 2
a3244 1
						// backing store we used to make the field privatescope, but that really serves no purpose (and it hinders
d3302 1
a3302 1
						fields[i] = FieldWrapper.Create1(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), fld.Name, fld.Signature, fld.Modifiers, field, emitGet, emitSet);
d3306 1
a3306 1
						fields[i] = FieldWrapper.Create3(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), field, fld.Signature, fld.Modifiers);
d3337 1
a3337 1
				FieldBuilder field = typeBuilder.DefineField("__<clinit>", typeof(int), FieldAttributes.SpecialName | FieldAttributes.Public | FieldAttributes.Static);
d3500 1
a3500 1
						if(m.ClassFile.IsAbstract || m.ClassFile.IsInterface)
d3685 2
a3686 1
			if(m.CodeAttribute != null)
d3688 7
a3694 2
				ClassFile.Method.LocalVariableTableEntry[] localVars = m.CodeAttribute.LocalVariableTableAttribute;
				if(localVars != null)
d3696 1
a3696 7
					int bias = 1;
					if(m.IsStatic)
					{
						bias = 0;
					}
					ParameterBuilder[] parameterBuilders = new ParameterBuilder[m.CodeAttribute.ArgMap.Length - bias];
					for(int i = bias; i < m.CodeAttribute.ArgMap.Length; i++)
d3698 1
a3698 1
						if(m.CodeAttribute.ArgMap[i] != -1)
d3700 1
a3700 1
							for(int j = 0; j < localVars.Length; j++)
d3702 1
a3702 1
								if(localVars[j].index == i && parameterBuilders[i - bias] == null)
d3704 5
a3708 9
									if(mb is MethodBuilder)
									{
										parameterBuilders[i - bias] = ((MethodBuilder)mb).DefineParameter(m.CodeAttribute.ArgMap[i] + 1 - bias, ParameterAttributes.None, localVars[j].name);
									}
									else if(mb is ConstructorBuilder)
									{
										parameterBuilders[i - bias] = ((ConstructorBuilder)mb).DefineParameter(m.CodeAttribute.ArgMap[i], ParameterAttributes.None, localVars[j].name);
									}
									break;
d3710 1
a3713 1
					return parameterBuilders;
d3715 1
@


1.4
log
@*** empty log message ***
@
text
@a31 1
	private ClassLoaderWrapper classLoader;
a33 3
	private Type[] args;
	private TypeWrapper[] argTypeWrappers;
	private TypeWrapper retTypeWrapper;
d35 1
a35 2
	internal MethodDescriptor(ClassLoaderWrapper classLoader, ClassFile.ConstantPoolItemFMI cpi)
		: this(classLoader, cpi.Name, cpi.Signature, cpi.GetArgTypes(classLoader), cpi.GetRetType(classLoader))
d37 1
a37 10
	}

	internal MethodDescriptor(ClassLoaderWrapper classLoader, ClassFile.Method method)
		: this(classLoader, method.Name, method.Signature, method.GetArgTypes(classLoader), method.GetRetType(classLoader))
	{
	}

	internal MethodDescriptor(ClassLoaderWrapper classLoader, string name, string sig, TypeWrapper[] args, TypeWrapper ret)
	{
		Debug.Assert(classLoader != null);
a40 6
		if(name == null || sig == null)
		{
			throw new ArgumentNullException();
		}

		this.classLoader = classLoader;
a42 2
		this.argTypeWrappers = args;
		this.retTypeWrapper = ret;
a60 70
	internal int ArgCount
	{
		get
		{
			return ArgTypeWrappers.Length;
		}
	}

	// NOTE this exposes potentially unfinished types!
	internal Type[] ArgTypesForDefineMethod
	{
		get
		{
			if(args == null)
			{
				TypeWrapper[] wrappers = ArgTypeWrappers;
				Type[] temp = new Type[wrappers.Length];
				for(int i = 0; i < wrappers.Length; i++)
				{
					temp[i] = wrappers[i].TypeAsParameterType;
				}
				args = temp;
			}
			return args;
		}
	}

	// NOTE this exposes potentially unfinished types!
	// HACK this should not be used and all existing uses should be reworked
	internal Type[] ArgTypesDontUse
	{
		get
		{
			return ArgTypesForDefineMethod;
		}
	}

	internal TypeWrapper[] ArgTypeWrappers
	{
		get
		{
			if(argTypeWrappers == null)
			{
				argTypeWrappers = classLoader.ArgTypeWrapperListFromSig(sig);
			}
			return argTypeWrappers;
		}
	}

	// NOTE this exposes a potentially unfinished type!
	internal Type RetTypeForDefineMethod
	{
		get
		{
			return RetTypeWrapper.TypeAsParameterType;
		}
	}

	internal TypeWrapper RetTypeWrapper
	{
		get
		{
			if(retTypeWrapper == null)
			{
				retTypeWrapper = classLoader.RetTypeWrapperFromSig(sig);
			}
			return retTypeWrapper;
		}
	}

a62 2
		// TODO instead of comparing the signature strings, we should compare the actual types
		// (because, in the face of multiple class loaders, there can be multiple classes with the same name)
a70 123

	private static void CrackSig(ParameterInfo param, out string name, out TypeWrapper typeWrapper)
	{
		Type type = param.ParameterType;
		if(type == typeof(object))
		{
			CrackSigFromCustomAttribute(param, out name, out typeWrapper);
		}
		else
		{
			if(type.IsByRef)
			{
				type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
				// TODO test type for unsupported types
			}
			name = TypeWrapper.GetSigNameFromType(type);
			typeWrapper = ClassLoaderWrapper.GetWrapperFromType(type);
		}
	}

	private static void CrackSig(MethodInfo method, out string name, out TypeWrapper typeWrapper)
	{
		Type type = method.ReturnType;
		if(type == typeof(object))
		{
			CrackSigFromCustomAttribute(method, out name, out typeWrapper);
		}
		else
		{
			name = TypeWrapper.GetSigNameFromType(type);
			typeWrapper = ClassLoaderWrapper.GetWrapperFromType(type);
		}
	}

	internal static string GetFieldSigName(FieldInfo field)
	{
		Type type = field.FieldType;
		if(type == typeof(object))
		{
			return GetSigNameFromCustomAttribute(field);
		}
		return TypeWrapper.GetSigNameFromType(type);
	}

	private static void CrackSigFromCustomAttribute(ICustomAttributeProvider provider, out string name, out TypeWrapper typeWrapper)
	{
		object[] attribs = provider.GetCustomAttributes(typeof(UnloadableTypeAttribute), false);
		if(attribs.Length == 1)
		{
			string s = ((UnloadableTypeAttribute)attribs[0]).Name;
			if(s.StartsWith("["))
			{
				name = s;
			}
			else
			{
				name = "L" + s + ";";
			}
			// TODO it might be loadable now, what do we do? I don't think we can try to load the type here,
			// because that will cause Java code to run and that isn't allowed while we're finishing (which we
			// might be doing when we get here).
			typeWrapper = new UnloadableTypeWrapper(s);
		}
		else
		{
			name = "Ljava.lang.Object;";
			typeWrapper = CoreClasses.java.lang.Object.Wrapper;
		}
	}

	private static string GetSigNameFromCustomAttribute(ICustomAttributeProvider provider)
	{
		object[] attribs = provider.GetCustomAttributes(typeof(UnloadableTypeAttribute), false);
		if(attribs.Length == 1)
		{
			string name = ((UnloadableTypeAttribute)attribs[0]).Name;
			if(name.StartsWith("["))
			{
				return name;
			}
			else
			{
				return "L" + name + ";";
			}
		}
		return "Ljava.lang.Object;";
	}

	// TODO ensure that FromMethodBase is only used on statically compiled Java types, and
	// remove support for ByRef
	internal static MethodDescriptor FromMethodBase(MethodBase mb)
	{
		System.Text.StringBuilder sb = new System.Text.StringBuilder();
		sb.Append('(');
		ParameterInfo[] parameters = mb.GetParameters();
		TypeWrapper[] args = new TypeWrapper[parameters.Length];
		for(int i = 0; i < parameters.Length; i++)
		{
			string name;
			CrackSig(parameters[i], out name, out args[i]);
			sb.Append(name);
		}
		sb.Append(')');
		if(mb is ConstructorInfo)
		{
			sb.Append('V');
			return new MethodDescriptor(ClassLoaderWrapper.GetClassLoader(mb.DeclaringType), mb.IsStatic ? "<clinit>" : "<init>", sb.ToString(), args, PrimitiveTypeWrapper.VOID);
		}
		else
		{
			string name;
			TypeWrapper ret;
			CrackSig((MethodInfo)mb, out name, out ret);
			sb.Append(name);
			return new MethodDescriptor(ClassLoaderWrapper.GetClassLoader(mb.DeclaringType), mb.Name, sb.ToString(), args, ret);
		}
	}

	internal static MethodDescriptor FromNameSig(ClassLoaderWrapper classLoader, string name, string sig)
	{
		// TODO why are we not resolving the signature here?
		return new MethodDescriptor(classLoader, name, sig, null, null);
	}
d80 4
a83 2
		MethodDescriptor md = MethodDescriptor.FromNameSig(exception.GetClassLoader(), "<init>", "()V");
		exception.GetMethodWrapper(md, false).EmitNewobj.Emit(ilgen);
d91 4
a94 2
		MethodDescriptor md = MethodDescriptor.FromNameSig(exception.GetClassLoader(), "<init>", "(Ljava.lang.String;)V");
		exception.GetMethodWrapper(md, false).EmitNewobj.Emit(ilgen);
d125 1
a125 1
	private static CustomAttributeBuilder hideFromReflectionAttribute;
d195 1
a195 1
	internal static void HideFromReflection(TypeBuilder typeBuilder)
d197 12
a208 1
		if(hideFromReflectionAttribute == null)
d210 1
a210 1
			hideFromReflectionAttribute = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d212 1
a212 1
		typeBuilder.SetCustomAttribute(hideFromReflectionAttribute);
d215 1
a215 1
	internal static void HideFromReflection(ConstructorBuilder cb)
d217 1
a217 1
		if(hideFromReflectionAttribute == null)
d219 1
a219 1
			hideFromReflectionAttribute = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d221 1
a221 1
		cb.SetCustomAttribute(hideFromReflectionAttribute);
d224 1
a224 1
	internal static void HideFromReflection(MethodBuilder mb)
d226 1
a226 1
		if(hideFromReflectionAttribute == null)
d228 1
a228 1
			hideFromReflectionAttribute = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d230 1
a230 1
		mb.SetCustomAttribute(hideFromReflectionAttribute);
d233 1
a233 1
	internal static void HideFromReflection(FieldBuilder fb)
d235 1
a235 1
		if(hideFromReflectionAttribute == null)
d237 1
a237 1
			hideFromReflectionAttribute = new CustomAttributeBuilder(typeof(HideFromReflectionAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d239 1
a239 1
		fb.SetCustomAttribute(hideFromReflectionAttribute);
d242 1
a242 1
	internal static bool IsHideFromReflection(MemberInfo mi)
d244 1
a244 1
		// NOTE all privatescope fields and methods are "hideFromReflection"
d256 1
a256 1
		return mi.IsDefined(typeof(HideFromReflectionAttribute), false);
d395 20
a424 6
	internal static void SetUnloadableType(FieldBuilder field, string name)
	{
		CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { name });
		field.SetCustomAttribute(attrib);
	}

d679 5
a683 1
	internal FieldWrapper GetFieldWrapper(string fieldName, TypeWrapper fieldType)
d685 1
a685 3
		string key = fieldName + fieldType.SigName;
		FieldWrapper fae = (FieldWrapper)fields[key];
		if(fae == null)
d687 2
a688 1
			fae = GetFieldImpl(fieldName, fieldType);
d691 2
a692 1
				foreach(TypeWrapper iface in this.Interfaces)
d694 1
a694 2
					fae = iface.GetFieldWrapper(fieldName, fieldType);
					if(fae != null)
d696 9
a704 1
						return fae;
d706 1
d708 1
a708 5
				if(baseWrapper != null)
				{
					return baseWrapper.GetFieldWrapper(fieldName, fieldType);
				}
				return null;
d710 1
a710 1
			fields[key] = fae;
a711 1
		return fae;
d716 2
d734 1
a734 3
	protected abstract MethodWrapper GetMethodImpl(MethodDescriptor md);

	internal MethodWrapper GetMethodWrapper(MethodDescriptor md, bool inherit)
d736 2
a737 2
		MethodWrapper mce = (MethodWrapper)methods[md];
		if(mce == null)
d739 1
a739 10
			mce = GetMethodImpl(md);
			if(mce == null)
			{
				if(inherit && baseWrapper != null)
				{
					return baseWrapper.GetMethodWrapper(md, inherit);
				}
				return null;
			}
			methods[md] = mce;
d741 1
a741 1
		return mce;
d786 5
d799 4
a802 1
		if(GetClassLoader() == wrapper.GetClassLoader())
d939 7
a945 1
			return TypeAsTBD;
d1131 6
a1136 1
	internal abstract void Finish();
d1138 1
a1138 1
	private void ImplementInterfaceMethodStubImpl(MethodDescriptor md, MethodBase ifmethod, TypeBuilder typeBuilder, DynamicTypeWrapper wrapper)
d1140 14
a1153 10
		// we're mangling the name to prevent subclasses from accidentally overriding this method
		string mangledName = this.Name + "/" + ifmethod.Name;
		MethodWrapper mce = wrapper.GetMethodWrapper(md, true);
		if(mce != null && mce.HasUnloadableArgsOrRet)
		{
			// TODO for now we make it seem as if the method isn't there, we should be emitting
			// a stub that throws a NoClassDefFoundError
			// NOTE AFAICT this can only happen when code explicitly messes around with the custom class loaders
			// that violate the class loader rules.
			mce = null;
d1163 2
a1164 2
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				AttributeHelper.HideFromReflection(mb);
d1166 1
a1166 1
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
d1169 1
a1169 1
			else if(mce.GetMethod() == null || mce.RealName != ifmethod.Name)
d1171 2
a1172 2
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				AttributeHelper.HideFromReflection(mb);
d1175 1
a1175 1
				int argc = md.ArgCount;
d1180 1
a1180 1
				mce.EmitCallvirt.Emit(ilGenerator);
d1182 1
a1182 1
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
d1189 3
a1191 3
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
				AttributeHelper.HideFromReflection(mb);
d1194 1
a1194 1
				int argc = md.ArgCount;
d1199 1
a1199 1
				mce.EmitCallvirt.Emit(ilGenerator);
d1209 2
a1210 2
				MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				AttributeHelper.HideFromReflection(mb);
d1212 1
a1212 1
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
a1214 52
			else
			{
				// because of a bug in the .NET 1.0 CLR, we have emit an abstract Miranda method, otherwise
				// the class will not be loadable under some circumstances
				// Example (compile with Jikes 1.18):
				//interface __Shape
				//{
				//    public abstract __Rectangle getBounds();
				//    public abstract __Rectangle2D getBounds2D();
				//}
				//
				//abstract class __RectangularShape implements __Shape
				//{
				//    public __Rectangle getBounds()
				//    {
				//	     return null;
				//    }
				//}
				//
				//abstract class __Rectangle2D extends __RectangularShape
				//{
				//    public __Rectangle2D getBounds2D()
				//    {
				//        return null;
				//    }
				//}
				//
				//class __Rectangle extends __Rectangle2D implements __Shape
				//{
				//    public __Rectangle getBounds()
				//    {
				//        return null;
				//    }
				//
				//    public __Rectangle2D getBounds2D()
				//    {
				//        return null;
				//    }
				//}
				MethodBuilder mb = typeBuilder.DefineMethod(md.Name, MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
				AttributeHelper.HideFromReflection(mb);
				// NOTE because we are introducing a Miranda method, we must also update the corresponding wrapper.
				// If we don't do this, subclasses might think they are introducing a new method, instead of overriding
				// this one.
				wrapper.AddMethod(MethodWrapper.Create(wrapper, md, mb, Modifiers.Public | Modifiers.Abstract, true));
				// NOTE if the interface method name is remapped, we need to add an explicit methodoverride. Note that when this
				// is required we always need to emit this stub, even if the above mentioned bug is fixed in the CLR
				if(md.Name != ifmethod.Name)
				{
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod);
				}
			}
a1221 2
		// TODO interfaces that implement other interfaces need to be handled as well...

d1228 1
a1228 19
		Finish();
		// NOTE for dynamic types it isn't legal to call Type.GetMethods() (because
		// that might trigger finishing of types that are already in the process of
		// being finished) and for RemappedTypeWrappers it makes no sense, so both
		// of these (ab)use the methods hashtable to obtain a list of methods
		// NOTE since the types have been finished, we know for sure that all methods
		// are in fact in the methods cache
		if(TypeAsTBD.Assembly is AssemblyBuilder || this.IsRemapped)
		{
			foreach(MethodWrapper method in methods.Values)
			{
				MethodBase ifmethod = method.GetMethod();
				if(!ifmethod.IsStatic)
				{
					ImplementInterfaceMethodStubImpl(method.Descriptor, ifmethod, typeBuilder, wrapper);
				}
			}
		}
		else
d1230 1
a1230 2
			MethodInfo[] methods = TypeAsBaseType.GetMethods();
			for(int i = 0; i < methods.Length; i++)
d1232 1
a1232 5
				MethodInfo ifmethod = methods[i];
				if(!ifmethod.IsStatic)
				{
					ImplementInterfaceMethodStubImpl(MethodDescriptor.FromMethodBase(ifmethod), ifmethod, typeBuilder, wrapper);
				}
d1303 2
a1304 2
			// because of the way interface merging works, any reference is valid
			// for any interface reference
d1449 11
d1469 21
d1495 1
a1495 1
	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
d1497 1
a1497 1
		throw new InvalidOperationException("GetMethodImpl called on UnloadableTypeWrapper: " + Name);
d1532 1
a1532 1
	internal override void Finish()
d1574 8
a1607 5
	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		return null;
	}

a1611 1
			// TODO does a primitive implement any interfaces?
d1632 1
a1632 1
	internal override void Finish()
d1637 1
a1637 1
class DynamicTypeWrapper : TypeWrapper
d1639 1
a1639 1
	private DynamicImpl impl;
d1651 10
d1662 1
a1662 1
		: base(f.Modifiers, f.Name, f.IsInterface ? null : f.GetSuperTypeWrapper(classLoader), classLoader)
a1666 4
			if(BaseTypeWrapper.IsUnloadable)
			{
				throw JavaException.NoClassDefFoundError(BaseTypeWrapper.Name);
			}
d1669 1
a1669 1
				throw JavaException.IllegalAccessError("Class {0} cannot access its superclass {1}", f.Name, BaseTypeWrapper.Name);
d1673 1
a1673 1
				throw JavaException.VerifyError("Cannot inherit from final class");
d1677 1
a1677 1
				throw JavaException.IncompatibleClassChangeError("Class {0} has interface {1} as superclass", f.Name, BaseTypeWrapper.Name);
d1680 3
a1682 1
		interfaces = f.GetInterfaceTypeWrappers(classLoader);
d1685 2
a1686 1
			if(interfaces[i].IsUnloadable)
d1688 1
a1688 1
				throw JavaException.NoClassDefFoundError(interfaces[i].Name);
d1690 1
a1690 1
			if(!interfaces[i].IsInterface)
d1692 1
a1692 5
				throw JavaException.IncompatibleClassChangeError("Implementing class");
			}
			if(!interfaces[i].IsAccessibleFrom(this))
			{
				throw JavaException.IllegalAccessError("Class {0} cannot access its superinterface {1}", f.Name, interfaces[i].Name);
d1694 1
d1700 8
a1728 5
	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		return impl.GetMethodImpl(md);
	}

d1769 1
a1769 1
	internal override void Finish()
d1771 1
a1771 1
		lock(GetType())
d1776 1
a1776 1
				impl = impl.Finish();
d1914 3
a1916 1
					tw.GetMethodWrapper(MethodDescriptor.FromNameSig(tw.GetClassLoader(), "<init>", "()V"), false).EmitNewobj.Emit(ilgen);
d1989 2
a1990 3
		public abstract FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType);
		public abstract MethodWrapper GetMethodImpl(MethodDescriptor md);
		public abstract Type Type { get; }
d1992 6
a1997 4
		public abstract TypeWrapper[] InnerClasses { get; }
		public abstract TypeWrapper DeclaringTypeWrapper { get; }
		public abstract Modifiers ReflectiveModifiers { get; }
		public abstract DynamicImpl Finish();
d2006 1
d2011 1
d2015 1
d2023 5
a2027 2
			TypeAttributes typeAttribs = 0;
			if(f.IsAbstract)
d2029 7
a2035 12
				typeAttribs |= TypeAttributes.Abstract;
			}
			if(f.IsFinal)
			{
				typeAttribs |= TypeAttributes.Sealed;
			}
			TypeBuilder outer = null;
			// only if requested, we compile inner classes as nested types, because it has a higher cost
			// and doesn't buy us anything, unless we're compiling a library that could be used from C# (e.g.)
			if(JVM.CompileInnerClassesAsNestedTypes)
			{
				if(f.OuterClass != null)
d2037 6
a2042 1
					if(!CheckInnerOuterNames(f.Name, f.OuterClass.Name))
d2044 1
a2044 1
						Tracer.Warning(Tracer.Compiler, "Incorrect InnerClasses attribute on {0}", f.Name);
d2046 33
a2078 1
					else
d2080 1
a2080 2
						outerClassWrapper = wrapper.GetClassLoader().LoadClassByDottedName(f.OuterClass.Name);
						if(outerClassWrapper is DynamicTypeWrapper)
d2082 9
a2090 1
							outer = outerClassWrapper.TypeAsBuilder;
d2094 1
a2094 4
			}
			if(f.IsPublic)
			{
				if(outer != null)
d2096 8
a2103 1
					typeAttribs |= TypeAttributes.NestedPublic;
d2105 1
a2105 1
				else
d2107 1
a2107 1
					typeAttribs |= TypeAttributes.Public;
d2109 1
a2109 9
			}
			else if(outer != null)
			{
				typeAttribs |= TypeAttributes.NestedAssembly;
			}
			if(f.IsInterface)
			{
				typeAttribs |= TypeAttributes.Interface | TypeAttributes.Abstract;
				if(outer != null)
d2111 2
a2112 1
					if(wrapper.IsGhost)
d2114 30
a2143 1
						throw new NotImplementedException();
a2144 3
					// LAMESPEC the CLI spec says interfaces cannot contain nested types (Part.II, 9.6), but that rule isn't enforced
					// (and broken by J# as well), so we'll just ignore it too.
					typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs);
d2148 2
a2149 1
					if(wrapper.IsGhost)
d2151 3
a2153 13
						typeAttribs &= ~(TypeAttributes.Interface | TypeAttributes.Abstract);
						typeAttribs |= TypeAttributes.Class | TypeAttributes.Sealed;
						typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs, typeof(ValueType));
						AttributeHelper.SetGhostInterface(typeBuilder);
						AttributeHelper.SetModifiers(typeBuilder, wrapper.Modifiers);
						wrapper.ghostRefField = typeBuilder.DefineField("__ref", typeof(object), FieldAttributes.Public | FieldAttributes.SpecialName);
						AttributeHelper.HideFromReflection((FieldBuilder)wrapper.ghostRefField);
						typeBuilderGhostInterface = typeBuilder.DefineNestedType("__Interface", TypeAttributes.Interface | TypeAttributes.Abstract | TypeAttributes.NestedPublic);
						AttributeHelper.HideFromReflection(typeBuilderGhostInterface);
						wrapper.ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object) });
						wrapper.ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray", MethodAttributes.Public | MethodAttributes.Static, typeof(bool), new Type[] { typeof(object), typeof(int) });
						wrapper.ghostCastMethod = typeBuilder.DefineMethod("Cast", MethodAttributes.Public | MethodAttributes.Static, typeBuilder, new Type[] { typeof(object) });
						wrapper.ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray", MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(object), typeof(int) });
d2157 1
a2157 1
						typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs);
d2160 2
a2161 5
			}
			else
			{
				typeAttribs |= TypeAttributes.Class;
				if(outer != null)
d2163 2
a2164 2
					// TODO in the CLR interfaces cannot contain nested types! (well, it works fine, but the spec says it isn't allowed)
					typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
d2166 2
a2167 1
				else
d2169 1
a2169 1
					typeBuilder = wrapper.GetClassLoader().ModuleBuilder.DefineType(wrapper.GetClassLoader().MangleTypeName(f.Name), typeAttribs, wrapper.BaseTypeWrapper.TypeAsBaseType);
d2172 1
a2172 2
			TypeWrapper[] interfaces = wrapper.Interfaces;
			for(int i = 0; i < interfaces.Length; i++)
d2174 5
a2178 2
				// NOTE we're using TypeAsBaseType for the interfaces!
				typeBuilder.AddInterfaceImplementation(interfaces[i].TypeAsBaseType);
d2180 5
a2184 2
			AttributeHelper.SetImplementsAttribute(typeBuilder, interfaces);
			if(JVM.IsStaticCompiler && classFile.DeprecatedAttribute)
d2186 27
a2212 1
				AttributeHelper.SetDeprecatedAttribute(typeBuilder);
d2283 47
a2329 1
						this.fields[i].EmitSet.Emit(ilGenerator);
d2333 8
d2343 1
a2343 1
		public override DynamicImpl Finish()
d2345 1
d2356 1
a2356 3
				// make sure that the base type is already finished (because we need any Miranda methods it
				// might introduce to be visible)
				wrapper.BaseTypeWrapper.Finish();
d2360 1
a2360 1
				outerClassWrapper.Finish();
d2374 1
a2374 1
				wrapper.Interfaces[i].Finish();
d2379 9
a2387 1
			classFile.LoadAllReferencedTypes(wrapper.GetClassLoader());
a2398 1
				Modifiers reflectiveModifiers = wrapper.Modifiers;
a2417 1
								reflectiveModifiers = innerclasses[i].accessFlags;
d2422 1
a2422 1
									reflectiveModifiers);
a2427 1
				//Console.WriteLine("finishing TypeFactory for " + classFile.Name);
a2444 22
				MethodDescriptor[] methodDescriptors = new MethodDescriptor[classFile.Methods.Length];
				for(int i = 0; i < classFile.Methods.Length; i++)
				{
					methodDescriptors[i] = new MethodDescriptor(wrapper.GetClassLoader(), classFile.Methods[i]);
				}
				if(methodLookup == null)
				{
					methods = new MethodWrapper[classFile.Methods.Length];
					methodLookup = new Hashtable();
					for(int i = 0; i < classFile.Methods.Length; i++)
					{
						methodLookup[methodDescriptors[i]] = i;
					}
				}
				for(int i = 0; i < methods.Length; i++)
				{
					if(methods[i] == null)
					{
						GenerateMethod(i);
						wrapper.AddMethod(methods[i]);
					}
				}
d2453 2
a2454 2
							TypeWrapper[] args = methods[i].Descriptor.ArgTypeWrappers;
							MethodBuilder stub = typeBuilder.DefineMethod(methods[i].Name, MethodAttributes.Public, methods[i].Descriptor.RetTypeForDefineMethod, methods[i].Descriptor.ArgTypesForDefineMethod);
d2485 1
a2485 1
								mw.EmitCallvirt.Emit(ilgen);
d2507 1
a2507 1
							AttributeHelper.HideFromReflection(mb);
d2519 1
a2519 1
						AttributeHelper.HideFromReflection(mb);
d2542 1
a2542 1
						AttributeHelper.HideFromReflection(mb);
d2595 1
a2595 1
						AttributeHelper.HideFromReflection(mb);
d2617 1
a2617 1
						AttributeHelper.HideFromReflection(mb);
d2628 1
a2628 1
						AttributeHelper.HideFromReflection(mb);
d2652 1
a2652 2
						MethodWrapper[] methods = parent.GetMethods();
						for(int i = 0; i < methods.Length; i++)
d2654 2
a2655 3
							MethodInfo mi = methods[i].GetMethod() as MethodInfo;
							MethodDescriptor md = methods[i].Descriptor;
							if(mi != null && mi.IsAbstract && wrapper.GetMethodWrapper(md, true).IsAbstract)
d2659 3
a2661 3
								MethodBuilder mb = typeBuilder.DefineMethod(mi.Name, mi.Attributes & ~(MethodAttributes.Abstract|MethodAttributes.NewSlot), CallingConventions.Standard, md.RetTypeForDefineMethod, md.ArgTypesForDefineMethod);
								AttributeHelper.SetModifiers(mb, methods[i].Modifiers);
								EmitHelper.Throw(mb.GetILGenerator(), "java.lang.AbstractMethodError", wrapper.Name + "." + md.Name + md.Signature);
d2667 1
a2667 1
				bool basehasclinit = (wrapper.BaseTypeWrapper == null) ? false : wrapper.BaseTypeWrapper.TypeAsTBD.TypeInitializer != null;
d2669 1
a2669 1
				for(int i = 0; i < methods.Length; i++)
d2671 1
a2671 1
					ILGenerator ilGenerator;
d2675 3
a2677 2
						ilGenerator = ((ConstructorBuilder)mb).GetILGenerator();
						if(basehasclinit && classFile.Methods[i].IsClassInitializer && !classFile.IsInterface)
d2684 1
a2684 4
					}
					else if(mb != null)
					{
						ilGenerator = ((MethodBuilder)mb).GetILGenerator();
d2688 1
a2688 12
						// HACK methods that have unloadable types in the signature do not have an underlying method, so we end
						// up here
						// TODO I don't think the above is true anymore, this needs to be tested...
						continue;
					}
					ClassFile.Method m = classFile.Methods[i];
					Tracer.EmitMethodTrace(ilGenerator, m.ClassFile.Name + "." + m.Name + m.Signature);
					if(m.IsAbstract)
					{
						// NOTE in the JVM it is apparently legal for a non-abstract class to have abstract methods, but
						// the CLR doens't allow this, so we have to emit a method that throws an AbstractMethodError
						if(!m.ClassFile.IsAbstract && !m.ClassFile.IsInterface)
d2690 8
a2697 1
							EmitHelper.Throw(ilGenerator, "java.lang.AbstractMethodError", m.ClassFile.Name + "." + m.Name + m.Signature);
d2699 1
a2699 5
					}
					else if(m.IsNative)
					{
						Profiler.Enter("JavaTypeImpl.Finish.Native");
						try
d2701 2
a2702 2
							// do we have a native implementation in map.xml?
							if(nativeMethods != null)
d2704 4
a2707 2
								CodeEmitter opcodes = (CodeEmitter)nativeMethods[classFile.Name + "." + m.Name + m.Signature];
								if(opcodes != null)
d2709 6
a2714 2
									opcodes.Emit(ilGenerator);
									continue;
d2716 5
a2720 9
							}
							// see if there exists a NativeCode class for this type
							Type nativeCodeType = Type.GetType("NativeCode." + classFile.Name.Replace('$', '+'));
							MethodInfo nativeMethod = null;
							TypeWrapper[] args = m.GetArgTypes(wrapper.GetClassLoader());
							if(nativeCodeType != null)
							{
								TypeWrapper[] nargs = args;
								if(!m.IsStatic)
d2722 23
a2744 3
									nargs = new TypeWrapper[args.Length + 1];
									args.CopyTo(nargs, 1);
									nargs[0] = this.wrapper;
d2746 1
a2746 2
								MethodInfo[] nativeCodeTypeMethods = nativeCodeType.GetMethods(BindingFlags.Static | BindingFlags.Public);
								foreach(MethodInfo method in nativeCodeTypeMethods)
d2748 7
a2754 3
									ParameterInfo[] param = method.GetParameters();
									TypeWrapper[] match = new TypeWrapper[param.Length];
									for(int j = 0; j < param.Length; j++)
d2756 1
a2756 1
										match[j] = ClassLoaderWrapper.GetWrapperFromType(param[j].ParameterType);
d2758 3
a2760 1
									if(m.Name == method.Name && IsCompatibleArgList(nargs, match))
d2762 1
a2762 3
										// TODO instead of taking the first matching method, we should find the best one
										nativeMethod = method;
										break;
d2764 1
d2766 1
a2766 5
							}
							if(nativeMethod != null)
							{
								int add = 0;
								if(!m.IsStatic)
d2768 17
a2784 12
									ilGenerator.Emit(OpCodes.Ldarg_0);
									add = 1;
								}
								for(int j = 0; j < args.Length; j++)
								{
									ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
								}
								ilGenerator.Emit(OpCodes.Call, nativeMethod);
								TypeWrapper retTypeWrapper = m.GetRetType(wrapper.GetClassLoader());
								if(!retTypeWrapper.TypeAsTBD.Equals(nativeMethod.ReturnType) && !retTypeWrapper.IsGhost)
								{
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
a2785 1
								ilGenerator.Emit(OpCodes.Ret);
d2787 1
a2787 1
							else
d2789 1
a2789 11
								if(JVM.NoJniStubs)
								{
									// since NoJniStubs can only be set when we're statically compiling, it is safe to use the "compiler" trace switch
									Tracer.Warning(Tracer.Compiler, "Native method not implemented: {0}.{1}.{2}", classFile.Name, m.Name, m.Signature);
									EmitHelper.Throw(ilGenerator, "java.lang.UnsatisfiedLinkError", "Native method not implemented: " + classFile.Name + "." + m.Name + m.Signature);
								}
								else
								{
									JniBuilder.Generate(ilGenerator, wrapper, typeBuilder, m, args);
									//JniProxyBuilder.Generate(ilGenerator, wrapper, typeBuilder, m, args);
								}
d2792 1
a2792 1
						finally
d2794 3
a2796 1
							Profiler.Leave("JavaTypeImpl.Finish.Native");
a2798 4
					else
					{
						Compiler.Compile(wrapper, m, ilGenerator);
					}
d2800 1
d2821 1
a2821 1
							AttributeHelper.HideFromReflection(cb);
d2842 1
d2846 1
a2846 1
							AttributeHelper.HideFromReflection(mb);
d2869 27
d2909 1
a2909 1
				finishedType = new FinishedTypeImpl(type, typeBuilderGhostInterface != null ? typeBuilderGhostInterface.CreateType() : null, innerClassesTypeWrappers, declaringTypeWrapper, reflectiveModifiers);
d2959 1
a2959 1
					ilGenerator.Emit(OpCodes.Ldarg, (ushort)i);
d2963 6
a2968 1
				tb.CreateType();
d3088 1
a3088 1
		public override TypeWrapper[] InnerClasses
d3096 1
a3096 1
		public override TypeWrapper DeclaringTypeWrapper
d3104 1
a3104 1
		public override Modifiers ReflectiveModifiers
d3108 15
a3122 1
				throw new InvalidOperationException("ReflectiveModifiers is only available for finished types");
d3126 1
a3126 1
		public override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
d3150 33
d3193 2
a3194 1
				if(typeWrapper.IsUnloadable)
d3196 1
d3198 1
a3198 1
					// conflict with another unloadable or object field
d3239 1
a3239 8
					// NOTE even though you're not supposed to access a constant static final (the compiler is supposed
					// to inline them), we have to support it (because it does happen, e.g. if the field becomes final
					// after the referencing class was compiled)
					CodeEmitter emitGet = CodeEmitter.CreateLoadConstant(constantValue);
					// when non-blank final fields are updated, the JIT normally doesn't see that (because the
					// constant value is inlined), so we emulate that behavior by emitting a Pop
					CodeEmitter emitSet = CodeEmitter.Pop;
					fields[i] = FieldWrapper.Create(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), fld.Name, fld.Signature, fld.Modifiers, field, emitGet, emitSet);
d3273 1
a3273 1
						AttributeHelper.HideFromReflection(getter);
d3305 1
a3305 1
						fields[i] = FieldWrapper.Create(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), fld.Name, fld.Signature, fld.Modifiers, field, emitGet, emitSet);
d3309 1
a3309 1
						fields[i] = FieldWrapper.Create(wrapper, fld.GetFieldType(wrapper.GetClassLoader()), field, fld.Signature, fld.Modifiers);
a3311 8
				if(typeWrapper.IsUnloadable)
				{
					AttributeHelper.SetUnloadableType(field, typeWrapper.Name);
				}
				else if(typeWrapper.IsGhostArray)
				{
					// TODO we need to annotate the field so that we know the real type of the field (for reflection)
				}
d3318 4
a3332 25
		public override MethodWrapper GetMethodImpl(MethodDescriptor md)
		{
			if(methodLookup == null)
			{
				methods = new MethodWrapper[classFile.Methods.Length];
				methodLookup = new Hashtable();
				for(int i = 0; i < classFile.Methods.Length; i++)
				{
					Profiler.Count("DynamicMethod");
					methodLookup[new MethodDescriptor(wrapper.GetClassLoader(), classFile.Methods[i])] = i;
				}
			}
			object index = methodLookup[md];
			if(index != null)
			{
				int i = (int)index;
				if(methods[i] == null)
				{
					GenerateMethod(i);
				}
				return methods[i];
			}
			return null;
		}

a3335 1
			// (well they might be visible from JNI reflection, but that isn't important enough to justify the custom attribute)
d3341 1
a3341 1
				AttributeHelper.HideFromReflection(field);
d3352 2
a3353 1
		private void GenerateMethod(int index)
d3355 16
a3370 17
			Profiler.Enter("JavaTypeImpl.GenerateMethod");
			try
			{
				Debug.Assert(methods[index] == null);
				// TODO things to consider when we support unloadable types on the argument list on return type:
				// - later on, the method can be overriden by a class that does have access to the type, so
				//   this should be detected and an appropriate override stub should be generated
				// - overloading might conflict with the generalised argument list (unloadable types appear
				//   as System.Object). The nicest way to solve this would be to emit a modreq attribute on the parameter,
				//   but Reflection.Emit doesn't support this, so we'll probably have to use a name mangling scheme
				MethodBase method;
				ClassFile.Method m = classFile.Methods[index];
				TypeWrapper[] argTypeWrappers = m.GetArgTypes(wrapper.GetClassLoader());
				TypeWrapper retTypeWrapper = m.GetRetType(wrapper.GetClassLoader());
				Type[] args = new Type[argTypeWrappers.Length];
				Type retType = retTypeWrapper.TypeAsParameterType;
				for(int i = 0; i < args.Length; i++)
d3372 1
a3372 1
					args[i] = argTypeWrappers[i].TypeAsParameterType;
d3374 3
a3376 3
				bool setModifiers = m.IsNative;
				MethodAttributes attribs = 0;
				if(m.IsAbstract)
d3378 3
a3380 4
					// only if the classfile is abstract, we make the CLR method abstract, otherwise,
					// we have to generate a method that throws an AbstractMethodError (because the JVM
					// allows abstract methods in non-abstract classes)
					if(m.ClassFile.IsAbstract || m.ClassFile.IsInterface)
d3382 2
a3383 1
						attribs |= MethodAttributes.Abstract;
d3385 7
a3391 1
					else
d3393 1
a3393 1
						setModifiers = true;
d3395 22
d3418 12
a3429 1
				if(m.IsFinal)
d3431 11
a3441 3
					if(!m.IsStatic && !m.IsPrivate)
					{
						attribs |= MethodAttributes.Final;
d3443 2
a3444 1
					else
d3446 1
a3446 1
						setModifiers = true;
d3448 1
d3450 9
a3474 4
				if(m.IsStatic)
				{
					attribs |= MethodAttributes.Static;
				}
d3477 11
a3487 5
					// NOTE we don't need to record the modifiers here, because only access modifiers are valid for
					// constructors and we have a well defined (reversible) mapping from them
					method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, args);
					ParameterBuilder[] parameterBuilders = null;
					if(JVM.IsStaticCompiler)
d3489 1
a3489 1
						parameterBuilders = AddParameterNames(method, m);
d3498 30
a3527 1
					if(!m.IsPrivate && !m.IsStatic)
d3532 1
a3532 1
					MethodDescriptor md = new MethodDescriptor(wrapper.GetClassLoader(), m);
d3538 2
a3539 3
					MethodBase baseMethod = null;
					MethodWrapper baseMce = null;
					bool explicitOverride = false;
d3542 3
a3544 47
						TypeWrapper tw = wrapper.BaseTypeWrapper;
						while(tw != null)
						{
							baseMce = tw.GetMethodWrapper(md, true);
							if(baseMce == null)
							{
								break;
							}
							// here are the complex rules for determining whether this method overrides the method we found
							// RULE 1: final methods may not be overridden
							if(baseMce.IsFinal && !baseMce.IsPrivate)
							{
								// TODO make sure the VerifyError is translated into a java.lang.VerifyError
								throw new VerifyError("final method " + baseMce.Name + baseMce.Descriptor.Signature + " in " + tw.Name + " is overriden in " + wrapper.Name);
							}
							// RULE 2: public & protected methods can be overridden (package methods are handled by RULE 4)
							// (by public, protected & *package* methods [even if they are in a different package])
							if(baseMce.IsPublic || baseMce.IsProtected)
							{
								// if we already encountered a package method, we cannot override the base method of
								// that package method
								if(explicitOverride)
								{
									explicitOverride = false;
									break;
								}
								baseMethod = baseMce.GetMethod();
								break;
							}
							// RULE 3: private methods are ignored
							if(!baseMce.IsPrivate)
							{
								// RULE 4: package methods can only be overridden in the same package
								if(baseMce.DeclaringType.IsInSamePackageAs(wrapper))
								{
									baseMethod = baseMce.GetMethod();
									break;
								}
								// since we encountered a method with the same name/signature that we aren't overriding,
								// we need to specify an explicit override
								// NOTE we only do this if baseMce isn't private, because if it is, Reflection.Emit
								// will complain about the explicit MethodOverride (possibly a bug)
								explicitOverride = true;
							}
							tw = baseMce.DeclaringType.BaseTypeWrapper;
						}
						if(baseMethod == null)
d3546 1
a3546 1
							// we need set NewSlot here, to prevent accidentally overriding methods
d3549 1
a3549 7
							// Unless, of course, we're implementing an inherited interface method (the miranda method might not
							// have been created at this point, because that happens during the finishing of our base class)
							// TODO a better way to fix this would be to move Miranda method creation from Finish to GetMethodImpl
							if(wrapper.BaseTypeWrapper == null || !IsInterfaceMethod(wrapper.BaseTypeWrapper, md))
							{
								attribs |= MethodAttributes.NewSlot;
							}
d3553 3
a3555 2
							// if we have a method overriding a more accessible method (yes, this does work), we need to make the
							// method more accessible, because otherwise the CLR will complain that we're reducing access)
d3569 1
a3569 1
						mb = typeBuilderGhostInterface.DefineMethod(name, attribs, retType, args);
d3575 1
a3575 1
						if(baseMethod != null && md.Name == "finalize" && md.Signature == "()V")
d3577 1
a3577 1
							if(baseMethod.Name == "Finalize")
d3579 1
a3579 1
								baseMethod = null;
d3584 1
a3584 1
							else if(baseMethod.DeclaringType == CoreClasses.java.lang.Object.Wrapper.TypeAsBaseType)
d3595 19
a3613 1
						mb = typeBuilder.DefineMethod(name, attribs, retType, args);
d3626 2
d3629 1
a3629 1
							AttributeHelper.HideFromReflection(finalize);
d3647 1
a3647 6
					ParameterBuilder[] parameterBuilders = null;
					if(JVM.IsStaticCompiler)
					{
						parameterBuilders = AddParameterNames(mb, m);
					}
					if(setModifiers)
d3649 2
a3650 33
						AttributeHelper.SetModifiers(mb, m.Modifiers);
					}
					// if we're public and we're overriding a method that is not public, then we might be also
					// be implementing an interface method that has an IllegalAccessError stub
					// Example:
					//   class Base {
					//     protected void Foo() {}
					//   }
					//   interface IFoo {
					//     public void Foo();
					//   }
					//   class Derived extends Base implements IFoo {
					//   }
					//   class MostDerived extends Derived {
					//     public void Foo() {} 
					//   }
					// TODO this implementation isn't correct. I need to find out what happens for the following:
					//   class Base {
					//     public void Foo() {}
					//   }
					//   interface IFoo {
					//     public void Foo() {}
					//   }
					//   class Derived extends Base implements IFoo {
					//   }
					//   class MostDerived extends Derived {
					//     protected void Foo() {}
					//   }
					if(wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasIncompleteInterfaceImplementation)
					{
						Hashtable hashtable = null;
						TypeWrapper tw = wrapper.BaseTypeWrapper;
						while(tw.HasIncompleteInterfaceImplementation)
d3652 1
a3652 5
							foreach(TypeWrapper iface in tw.Interfaces)
							{
								AddMethodOverride(typeBuilder, mb, iface, md, ref hashtable);
							}
							tw = tw.BaseTypeWrapper;
d3663 7
a3669 1
					if(baseMethod != null && (explicitOverride || baseMethod.Name != name))
d3671 1
a3671 3
						// assert that the method we're overriding is in fact virtual and not final!
						Debug.Assert(baseMethod.IsVirtual && !baseMethod.IsFinal);
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethod);
d3673 1
a3673 11
				}
				if(retTypeWrapper.IsUnloadable)
				{
					CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { retTypeWrapper.Name });
					// NOTE since DefineParameter(0, ...) throws an exception (bug in .NET, I believe),
					// we attach the attribute to the method instead of the return value
					((MethodBuilder)method).SetCustomAttribute(attrib);
				}
				for(int i = 0; i < argTypeWrappers.Length; i++)
				{
					if(argTypeWrappers[i].IsUnloadable)
d3675 1
a3675 9
						CustomAttributeBuilder attrib = new CustomAttributeBuilder(typeof(UnloadableTypeAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { argTypeWrappers[i].Name });
						if(method is MethodBuilder)
						{
							((MethodBuilder)method).DefineParameter(i + 1, ParameterAttributes.None, null).SetCustomAttribute(attrib);
						}
						else
						{
							((ConstructorBuilder)method).DefineParameter(i + 1, ParameterAttributes.None, null).SetCustomAttribute(attrib);
						}
d3678 1
a3678 8
				string[] exceptions = m.ExceptionsAttribute;
				AttributeHelper.SetThrowsAttribute(method, exceptions);
				methods[index] = MethodWrapper.Create(wrapper, new MethodDescriptor(wrapper.GetClassLoader(), m), method, m.Modifiers, false);
				methods[index].SetDeclaredExceptions(exceptions);
				if(JVM.IsStaticCompiler && m.DeprecatedAttribute)
				{
					AttributeHelper.SetDeprecatedAttribute(method);
				}
d3726 27
a3752 1
		private static bool IsInterfaceMethod(TypeWrapper wrapper, MethodDescriptor md)
d3754 8
a3761 1
			while(wrapper != null)
d3763 1
a3763 1
				foreach(TypeWrapper iface in wrapper.Interfaces)
d3765 1
a3765 4
					if(iface.GetMethodWrapper(md, false) != null || IsInterfaceMethod(iface, md))
					{
						return true;
					}
a3766 1
				wrapper = wrapper.BaseTypeWrapper;
d3771 1
a3771 1
		private static void AddMethodOverride(TypeBuilder typeBuilder, MethodBuilder mb, TypeWrapper iface, MethodDescriptor md, ref Hashtable hashtable)
d3785 8
a3792 1
				typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
d3796 1
a3796 1
				AddMethodOverride(typeBuilder, mb, iface2, md, ref hashtable);
d3800 1
a3800 1
		public override Type Type
d3825 1
a3825 1
		public FinishedTypeImpl(Type type, Type typeGhostInterface, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers)
d3834 1
a3834 1
		public override TypeWrapper[] InnerClasses
d3843 1
a3843 1
		public override TypeWrapper DeclaringTypeWrapper
d3852 1
a3852 1
		public override Modifiers ReflectiveModifiers
d3860 1
a3860 1
		public override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
d3865 1
a3865 6
		public override MethodWrapper GetMethodImpl(MethodDescriptor md)
		{
			return null;
		}

		public override Type Type
d3881 1
a3881 1
		public override DynamicImpl Finish()
d3885 13
d3934 12
d3961 14
a3974 1
	protected sealed override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
d3981 1
a3981 2
				LazyPublishMembers();
				return GetFieldWrapper(fieldName, fieldType);
d3984 1
a3984 1
		return null;
d3987 1
a3987 1
	protected sealed override MethodWrapper GetMethodImpl(MethodDescriptor md)
d3994 1
a3994 2
				LazyPublishMembers();
				return GetMethodWrapper(md, false);
d3997 1
a3997 1
		return null;
d4000 1
a4000 1
	internal sealed override void Finish()
d4007 1
a4007 1
				LazyPublishMembers();
d4010 12
d4025 1
a4025 1
class CompiledTypeWrapper : LazyTypeWrapper
d4140 8
d4188 1
a4188 1
					if(!nestedTypes[i].IsDefined(typeof(HideFromReflectionAttribute), false))
d4214 45
a4258 1
		get
d4260 7
a4266 2
			object[] customAttribute = type.GetCustomAttributes(typeof(InnerClassAttribute), false);
			if(customAttribute.Length == 1)
d4268 5
a4272 1
				return ((InnerClassAttribute)customAttribute[0]).Modifiers;
a4273 1
			return Modifiers;
d4277 1
a4277 1
	internal override Type TypeAsBaseType
d4279 3
a4281 1
		get
d4283 1
a4283 1
			if(typeAsBaseType == null)
d4285 1
a4285 1
				if(IsGhost)
d4287 4
a4290 1
					typeAsBaseType = type.GetNestedType("__Interface");
d4292 1
a4292 1
				else
d4294 24
a4317 2
					typeAsBaseType = type;
				}
a4318 1
			return typeAsBaseType;
d4322 1
a4322 1
	internal override FieldInfo GhostRefField
d4324 36
a4359 1
		get
d4361 10
a4370 1
			if(ghostRefField == null)
d4372 1
a4372 1
				ghostRefField = type.GetField("__ref");
d4374 3
a4376 1
			return ghostRefField;
d4387 1
a4387 1
				if(!m.IsDefined(typeof(HideFromReflectionAttribute), false))
d4392 8
a4399 1
						AddMethod(MethodWrapper.Create(this, MethodDescriptor.FromMethodBase(method), method, AttributeHelper.GetModifiers(method, false), false));
d4416 1
a4416 1
				if(!m.IsDefined(typeof(HideFromReflectionAttribute), false))
d4442 1
a4442 1
					MethodInfo mbHelper = null;
d4444 5
a4448 2
					MethodDescriptor md = MethodDescriptor.FromMethodBase(method);
					md = MethodDescriptor.FromNameSig(GetClassLoader(), m.Name, md.Signature);
d4452 4
d4457 1
a4457 5
					MethodWrapper mw = new CompiledRemappedMethodWrapper(this, md, method, modifiers, false, mbHelper != null ? mbHelper : method);
					mw.EmitCall = CodeEmitter.InternalError;
					mw.EmitCallvirt = CodeEmitter.Create(mbHelper != null ? OpCodes.Call : OpCodes.Callvirt, mbHelper != null ? mbHelper : method);
					mw.EmitNewobj = CodeEmitter.InternalError;
					AddMethod(mw);
d4463 1
a4463 1
	private class CompiledRemappedMethodWrapper : MethodWrapper
d4465 2
a4466 1
		private MethodBase mbHelper;
d4468 2
a4469 2
		internal CompiledRemappedMethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase method, Modifiers modifiers, bool hideFromReflection, MethodBase mbHelper)
			: base(declaringType, md, method, modifiers, hideFromReflection)
d4472 1
d4475 1
a4475 1
		internal override object Invoke(object obj, object[] args, bool nonVirtual)
d4477 10
a4486 1
			return InvokeImpl(mbHelper, obj, args, nonVirtual);
a4487 1
	}
d4489 4
a4492 18
	private MethodWrapper CreateRemappedMethodWrapper(MethodBase mb)
	{
		bool instancehelper = false;
		Modifiers modifiers = AttributeHelper.GetModifiers(mb, false);
		MethodDescriptor md = MethodDescriptor.FromMethodBase(mb);
		MethodBase mbHelper = mb;
		if(md.Name.StartsWith("instancehelper_"))
		{
			instancehelper = true;
			string sig = md.Signature;
			md = MethodDescriptor.FromNameSig(GetClassLoader(), md.Name.Substring(15), "(" + sig.Substring(sig.IndexOf(';') + 1));
			modifiers &= ~Modifiers.Static;
		}
		else if(md.Name == "newhelper")
		{
			string sig = md.Signature;
			md = MethodDescriptor.FromNameSig(GetClassLoader(), "<init>", sig.Substring(0, sig.LastIndexOf(')')) + ")V");
			modifiers &= ~Modifiers.Static;
d4494 2
a4495 1
		else if(!mb.IsStatic && !mb.IsConstructor)
d4497 3
a4499 4
			ParameterInfo[] parameters = mb.GetParameters();
			Type[] argTypes = new Type[parameters.Length + 1];
			argTypes[0] = remappedType;
			for(int i = 0; i < parameters.Length; i++)
d4501 2
a4502 1
				argTypes[i + 1] = parameters[i].ParameterType;
d4504 1
a4504 2
			mbHelper = type.GetMethod("instancehelper_" + mb.Name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static, null, argTypes, null);
			if(mbHelper == null)
d4506 1
a4506 1
				mbHelper = mb;
d4509 2
a4510 8
		MethodWrapper method = new CompiledRemappedMethodWrapper(this, md, mb, modifiers, false, mbHelper);
		if(mb is ConstructorInfo)
		{
			method.EmitCallvirt = CodeEmitter.InternalError;
			method.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)mb);
			method.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)mb);
		}
		else
d4512 2
a4513 1
			if(mb.IsStatic)
d4515 1
a4515 1
				if(mb.Name == "newhelper")
d4517 1
a4517 3
					method.EmitCall = CodeEmitter.InternalError;
					method.EmitCallvirt = CodeEmitter.InternalError;
					method.EmitNewobj = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
d4519 1
a4519 1
				else
d4521 1
a4521 12
					if(instancehelper)
					{
						method.EmitCall = CodeEmitter.InternalError;
						method.EmitCallvirt = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
						method.EmitNewobj = CodeEmitter.InternalError;
					}
					else
					{
						method.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
						method.EmitCallvirt = CodeEmitter.InternalError;
						method.EmitNewobj = CodeEmitter.InternalError;
					}
d4523 1
a4523 5
			}
			else
			{
				method.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
				if(mbHelper != mb)
d4525 1
a4525 1
					method.EmitCallvirt = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mbHelper);
d4529 2
a4530 1
					method.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)mb);
a4531 1
				method.EmitNewobj = CodeEmitter.InternalError;
d4533 29
a4561 2
			TypeWrapper retType = method.ReturnType;
			if(!retType.IsUnloadable)
d4563 1
a4563 10
				if(retType.IsNonPrimitiveValueType)
				{
					method.EmitCall += CodeEmitter.CreateEmitBoxCall(retType);
					method.EmitCallvirt += CodeEmitter.CreateEmitBoxCall(retType);
				}
				else if(retType.IsGhost)
				{
					method.EmitCall += new MethodWrapper.GhostUnwrapper(retType);
					method.EmitCallvirt += new MethodWrapper.GhostUnwrapper(retType);
				}
d4565 1
d4567 1
a4567 1
		return method;
d4575 1
a4575 1
		// If the backing field is private, but the modifiers aren't, we've got a static final that
d4633 7
a4639 5
		string fieldName = field.Name;
		int idx = fieldName.IndexOf('/');
		if(idx >= 0)
		{
			fieldName = fieldName.Substring(0, idx);
d4641 1
a4641 1
		return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(field.FieldType), fieldName, MethodDescriptor.GetFieldSigName(field), modifiers, field, emitGet, emitSet);
d4677 1
a4677 1
class DotNetTypeWrapper : LazyTypeWrapper
d4684 1
d4763 4
a4766 2
	// this method should only be called once for each name, it doesn't do any caching or duplicate prevention
	internal static TypeWrapper LoadDotNetTypeWrapper(string name)
d4878 11
a4888 2
		internal DelegateMethodWrapper(TypeWrapper declaringType, MethodDescriptor md)
			: base(declaringType, md, null, Modifiers.Public, false)
d4890 3
d4902 1
a4902 1
	private class ByRefMethodWrapper : MethodWrapper
d4905 1
d4907 2
a4908 2
		internal ByRefMethodWrapper(bool[] byrefs, TypeWrapper declaringType, MethodDescriptor md, MethodBase method, Modifiers modifiers, bool hideFromReflection)
			: base(declaringType, md, method, modifiers, hideFromReflection)
d4910 1
d4914 49
d4998 5
a5002 1
			: base(tw, MethodDescriptor.FromNameSig(tw.GetClassLoader(), "wrap", "(" + fieldType.SigName + ")" + tw.SigName), null, Modifiers.Static | Modifiers.Public, false)
d5005 1
a5005 1
			EmitCall = CodeEmitter.Create(OpCodes.Box, tw.type);
d5044 8
d5073 1
a5073 1
					AddField(FieldWrapper.Create(this, fieldType, name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], CodeEmitter.CreateLoadConstantField(fields[i]), CodeEmitter.Pop));
d5108 1
a5108 4
					MethodDescriptor md = MethodDescriptor.FromNameSig(GetClassLoader(), "<init>", "(" + iface.SigName + ")V");
					MethodWrapper method = new DelegateMethodWrapper(this, md);
					method.EmitNewobj = new DelegateConstructorEmitter(type.GetConstructor(new Type[] { typeof(object), typeof(IntPtr) }), iface.TypeAsTBD.GetMethod("Invoke"));
					AddMethod(method);
d5144 1
a5144 1
			if(!type.IsInterface)
d5183 1
a5183 1
							if(!h.ContainsKey(m.Descriptor.Name + m.Descriptor.Signature))
d5185 1
a5185 7
								h.Add(m.Descriptor.Name + m.Descriptor.Signature, "");
								MethodWrapper newmw = new MethodWrapper(this, m.Descriptor, m.GetMethod(), m.Modifiers | Modifiers.Final, false);
								newmw.EmitNewobj = CodeEmitter.InternalError;
								// we bind EmitCall to EmitCallvirt, because we always want to end up at the instancehelper method
								// (EmitCall would go to our alter ego .NET type and that wouldn't be legal)
								newmw.EmitCall = m.EmitCallvirt;
								newmw.EmitCallvirt = m.EmitCallvirt;
d5187 1
a5187 1
								AddMethod(newmw);
d5197 28
d5266 1
a5266 1
			return new MethodDescriptor(GetClassLoader(), name, sb.ToString(), args, ret);
d5277 1
a5277 1
			return new MethodDescriptor(GetClassLoader(), mb.Name, sb.ToString(), args, ret);
d5285 1
a5285 3
			// remapped type cannot be instantiated, so it wouldn't make sense to implement
			// interfaces
			if(ClassLoaderWrapper.IsRemappedType(type) && !IsInterface)
d5287 10
a5296 7
				return TypeWrapper.EmptyArray;
			}
			Type[] interfaces = type.GetInterfaces();
			TypeWrapper[] interfaceWrappers = new TypeWrapper[interfaces.Length];
			for(int i = 0; i < interfaces.Length; i++)
			{
				interfaceWrappers[i] = ClassLoaderWrapper.GetWrapperFromType(interfaces[i]);
a5297 1
			return interfaceWrappers;
d5385 1
a5385 4
				// TODO what happens when you try to set a final field?
				// through reflection: java.lang.IllegalAccessException: Field is final
				// through code: java.lang.IllegalAccessError: Field <class>.<field> is final
				emitSet = CodeEmitter.Nop;
a5395 1
				// TODO is it possible to have literal instance fields?
d5404 1
a5404 3
				// TODO what happens when you try to set a final field through reflection?
				// see above
				emitSet = CodeEmitter.Nop;
d5407 2
a5408 1
		return FieldWrapper.Create(this, ClassLoaderWrapper.GetWrapperFromType(fieldType), name, MethodDescriptor.GetFieldSigName(field), modifiers, field, emitGet, emitSet);
a5410 1
	// TODO why doesn't this use the standard MethodWrapper.Create?
d5418 1
a5418 1
			MethodWrapper mw = new MethodWrapper(this, MethodDescriptor.FromNameSig(GetClassLoader(), "finalize", "()V"), mb, mods, false);
a5419 3
			mw.EmitCall = CodeEmitter.Create(OpCodes.Call, mb);
			mw.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, mb);
			mw.EmitNewobj = CodeEmitter.InternalError;
d5444 1
a5444 1
		if(hasByRefArgs && !(mb is ConstructorInfo) && !mb.IsStatic)
d5446 3
a5448 13
			mods |= Modifiers.Final;
		}
		MethodWrapper method = hasByRefArgs ?
			new ByRefMethodWrapper(byrefs, this, md, mb, mods, false) : new MethodWrapper(this, md, mb, mods, false);
		if(mb is ConstructorInfo)
		{
			method.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)mb);
			method.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)mb);
			if(this.IsNonPrimitiveValueType)
			{
				// HACK after constructing a new object, we don't want the custom boxing rule to run
				// (because that would turn "new IntPtr" into a null reference)
				method.EmitNewobj += CodeEmitter.Create(OpCodes.Box, this.TypeAsTBD);
d5450 2
d5455 1
a5455 3
			bool nonPrimitiveValueType = md.RetTypeWrapper.IsNonPrimitiveValueType;
			method.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
			if(nonPrimitiveValueType)
d5457 2
a5458 1
				method.EmitCall += CodeEmitter.CreateEmitBoxCall(md.RetTypeWrapper);
d5460 1
a5460 1
			if(!mb.IsStatic)
d5462 2
a5463 65
				method.EmitCallvirt = CodeEmitter.Create(this.IsNonPrimitiveValueType ? OpCodes.Call : OpCodes.Callvirt, (MethodInfo)mb);
				if(nonPrimitiveValueType)
				{
					method.EmitCallvirt += CodeEmitter.CreateEmitBoxCall(md.RetTypeWrapper);
				}
			}
		}
		if(hasByRefArgs)
		{
			method.EmitCall = new RefArgConverter(args) + method.EmitCall;
			method.EmitCallvirt = new RefArgConverter(args) + method.EmitCallvirt;
			method.EmitNewobj = new RefArgConverter(args) + method.EmitNewobj;
		}
		return method;
	}

	private class DelegateConstructorEmitter : CodeEmitter
	{
		private ConstructorInfo delegateConstructor;
		private MethodInfo method;

		internal DelegateConstructorEmitter(ConstructorInfo delegateConstructor, MethodInfo method)
		{
			this.delegateConstructor = delegateConstructor;
			this.method = method;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			ilgen.Emit(OpCodes.Dup);
			ilgen.Emit(OpCodes.Ldvirtftn, method);
			ilgen.Emit(OpCodes.Newobj, delegateConstructor);
		}
	}

	private class RefArgConverter : CodeEmitter
	{
		private Type[] args;

		internal RefArgConverter(Type[] args)
		{
			this.args = args;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			LocalBuilder[] locals = new LocalBuilder[args.Length];
			for(int i = args.Length - 1; i >= 0; i--)
			{
				Type type = args[i];
				if(type.IsByRef)
				{
					type = type.Assembly.GetType(type.GetElementType().FullName + "[]", true);
				}
				locals[i] = ilgen.DeclareLocal(type);
				ilgen.Emit(OpCodes.Stloc, locals[i]);
			}
			for(int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldloc, locals[i]);
				if(args[i].IsByRef)
				{
					ilgen.Emit(OpCodes.Ldc_I4_0);
					ilgen.Emit(OpCodes.Ldelema, args[i].GetElementType());
				}
d5485 1
a5485 1
class ArrayTypeWrapper : TypeWrapper
a5487 1
	private static MethodDescriptor mdClone;
a5488 1
	private static CodeEmitter callclone;
a5494 4
		if(mdClone == null)
		{
			mdClone = MethodDescriptor.FromNameSig(ClassLoaderWrapper.GetBootstrapClassLoader(), "clone", "()Ljava.lang.Object;");
		}
d5499 8
a5506 2
		MethodWrapper mw = new MethodWrapper(this, mdClone, clone, Modifiers.Public, true);
		if(callclone == null)
d5508 1
a5508 1
			callclone = CodeEmitter.Create(OpCodes.Callvirt, clone);
a5509 3
		mw.EmitCall = callclone;
		mw.EmitCallvirt = callclone;
		AddMethod(mw);
a5564 5
	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
	{
		return null;
	}

d5578 1
a5578 1
	internal override void Finish()
d5582 1
@


1.3
log
@*** empty log message ***
@
text
@d504 1
a504 1
		if((mb.IsFinal || !mb.IsVirtual) && !mb.IsStatic && !mb.IsConstructor)
d1857 1
d2159 2
a2160 1
					if(mappedExceptions[i].IsSubTypeOf(this))
d2172 1
d2176 7
a2182 1
			mappedExceptions[i] = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(map.exceptionMappings[i].dst);
d3490 1
a3490 1
							if(baseMce.IsFinal)
a3491 2
								// NOTE we don't need to test for our method being private, because if it is
								// we'll never get here (because private methods aren't virtual)
d3756 1
a3756 1
			foreach(TypeWrapper iface in wrapper.Interfaces)
d3758 1
a3758 1
				if(iface.GetMethodWrapper(md, false) != null || IsInterfaceMethod(iface, md))
d3760 4
a3763 1
					return true;
d3765 1
d4248 1
d4252 1
d4256 5
a4260 1
					MethodWrapper mw = new MethodWrapper(this, md, method, modifiers, false);
d4262 1
a4262 1
					mw.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, method);
d4506 5
a4510 1
			modifiers |= Modifiers.Public | Modifiers.Static;
d4736 1
a4736 1
	private static bool IsVisible(Type type)
@


1.2
log
@*** empty log message ***
@
text
@d4349 14
d4720 45
d4777 10
a4786 2
					// TODO handle name/signature clash
					AddField(FieldWrapper.Create(this, fieldType, fields[i].Name, fieldType.SigName, Modifiers.Public | Modifiers.Static | Modifiers.Final, fields[i], CodeEmitter.CreateLoadConstantField(fields[i]), CodeEmitter.Pop));
d4789 2
a4790 9
			// NOTE if the reference on the stack is null, we *want* the NullReferenceException, so we don't use TypeWrapper.EmitUnbox
			CodeEmitter getter = CodeEmitter.Create(OpCodes.Unbox, type) + CodeEmitter.Create(OpCodes.Ldobj, type);
			CodeEmitter setter = CodeEmitter.Pop + CodeEmitter.Pop;
			FieldWrapper fw = FieldWrapper.Create(this, fieldType, "Value", fieldType.SigName, Modifiers.Public | Modifiers.Final, null, getter, setter);
			AddField(fw);
			MethodWrapper mw = new MethodWrapper(this, MethodDescriptor.FromNameSig(GetClassLoader(), "wrap", "(" + fieldType.SigName + ")" + this.SigName), null, Modifiers.Static | Modifiers.Public, false);
			// NOTE we don't support custom boxing rules for enums
			mw.EmitCall = CodeEmitter.Create(OpCodes.Box, type);
			AddMethod(mw);
@


1.1
log
@*** empty log message ***
@
text
@d1426 1
a1426 1
				wrapper.AddMethod(MethodWrapper.Create(wrapper, md, mb, mb, Modifiers.Public | Modifiers.Abstract, true));
d3694 1
a3694 1
				methods[index] = MethodWrapper.Create(wrapper, new MethodDescriptor(wrapper.GetClassLoader(), m), method, method, m.Modifiers, false);
d4198 1
a4198 1
						AddMethod(CreateMethodWrapper(method));
d4243 1
a4243 1
					MethodWrapper mw = new MethodWrapper(this, md, method, null, modifiers, false);
d4253 16
d4274 1
d4288 16
a4303 1
		MethodWrapper method = new MethodWrapper(this, md, mb, null, modifiers, false);
d4339 1
a4339 4
				ParameterInfo[] parameters = mb.GetParameters();
				Type[] argTypes = new Type[parameters.Length + 1];
				argTypes[0] = remappedType;
				for(int i = 0; i < parameters.Length; i++)
d4341 1
a4341 6
					argTypes[i + 1] = parameters[i].ParameterType;
				}
				MethodInfo helper = type.GetMethod("instancehelper_" + mb.Name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static, null, argTypes, null);
				if(helper != null)
				{
					method.EmitCallvirt = CodeEmitter.Create(OpCodes.Call, helper);
a4352 35
	private MethodWrapper CreateMethodWrapper(MethodBase mb)
	{
		MethodDescriptor md = MethodDescriptor.FromMethodBase(mb);
		MethodWrapper method = new MethodWrapper(this, md, mb, null, AttributeHelper.GetModifiers(mb, false), false);
		if(IsGhost)
		{
			method.EmitCall = CodeEmitter.InternalError;
			method.EmitCallvirt = new MethodWrapper.GhostCallEmitter(this, md, mb);
			method.EmitNewobj = CodeEmitter.InternalError;
		}
		else
		{
			if(mb is ConstructorInfo)
			{
				method.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)mb);
				method.EmitCallvirt = CodeEmitter.InternalError;
				method.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)mb);
			}
			else
			{
				method.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)mb);
				if(!mb.IsStatic)
				{
					method.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)mb);
				}
				else
				{
					method.EmitCallvirt = CodeEmitter.InternalError;
				}
				method.EmitNewobj = CodeEmitter.InternalError;
			}
		}
		return method;
	}

d4653 1
a4653 1
			: base(declaringType, md, null, null, Modifiers.Public, false)
d4668 2
a4669 2
		internal ByRefMethodWrapper(bool[] byrefs, TypeWrapper declaringType, MethodDescriptor md, MethodBase originalMethod, MethodBase method, Modifiers modifiers, bool hideFromReflection)
			: base(declaringType, md, originalMethod, method, modifiers, hideFromReflection)
d4727 1
a4727 1
			MethodWrapper mw = new MethodWrapper(this, MethodDescriptor.FromNameSig(GetClassLoader(), "wrap", "(" + fieldType.SigName + ")" + this.SigName), null, null, Modifiers.Static | Modifiers.Public, false);
d4842 1
a4842 1
								MethodWrapper newmw = new MethodWrapper(this, m.Descriptor, m.GetMethod(), m.GetMethod(), m.Modifiers | Modifiers.Final, false);
d5058 1
a5058 1
			MethodWrapper mw = new MethodWrapper(this, MethodDescriptor.FromNameSig(GetClassLoader(), "finalize", "()V"), mb, null, mods, false);
d5092 1
a5092 1
			new ByRefMethodWrapper(byrefs, this, md, mb, null, mods, false) : new MethodWrapper(this, md, mb, null, mods, false);
d5220 1
a5220 1
		MethodWrapper mw = new MethodWrapper(this, mdClone, clone, null, Modifiers.Public, true);
@

