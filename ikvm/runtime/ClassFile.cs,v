head	1.139;
access;
symbols
	v8_1_5717_0:1.139
	v8_1:1.139.0.2
	v8_0_5449_1:1.131
	v8_0_5449_0:1.131
	v8_0:1.131.0.2
	v7_4_5196_0:1.118
	v7_4:1.118.0.2
	v7_3:1.106.0.2
	v7_2_4630_6:1.97
	v7_2_4630_5:1.97
	v7_2_4630_4:1.97
	v7_2_4630_3:1.97
	v7_2_4630_2:1.97
	v0_46_0_4:1.81
	v7_2_4630_1:1.97
	v7_2:1.97.0.2
	v7_1_4532_2:1.94
	v7_1_4532_1:1.94
	v7_1_4532_0:1.94
	v7_1:1.94.0.2
	v7_0_4335_3:1.87.2.1
	v7_0_4335_2:1.87.2.1
	v7_0_4335_1:1.87.2.1
	v0_46_0_2:1.81
	v7_0_4335_0:1.87
	v7_0:1.87.0.2
	v0_40_0_6:1.64.2.1
	v0_40_0_5:1.64.2.1
	v0_46_0_1:1.81
	v0_46_0_0:1.81
	v0_46:1.81.0.2
	v0_36_0_14:1.51.2.1
	v0_44_0_6:1.78
	v0_44_0_5:1.78
	v0_44_0_4:1.78
	v0_44_0_3:1.78
	v0_44_0_2:1.78
	v0_42_0_7:1.69
	v0_44_0_1:1.78
	v0_44_0_0:1.78
	v0_44:1.78.0.2
	v0_42_0_6:1.69
	v0_42_0_5:1.69
	v0_42_0_4:1.69
	v0_42_0_3:1.69
	v0_42_0_2:1.69
	v0_42_0_1:1.69
	v0_42_0_0:1.69
	v0_42:1.69.0.2
	v0_40_0_3:1.64.2.1
	v0_40_0_2:1.64.2.1
	v0_40_0_1:1.64
	v0_40_0_0:1.64
	v0_40:1.64.0.2
	v0_36_0_13:1.51.2.1
	v0_38_0_1:1.62
	v0_38_0_0:1.62
	v0_38:1.62.0.2
	v0_36_0_9:1.51.2.1
	v0_36_0_7:1.51
	v0_36_0_5:1.51
	v0_36_0_4:1.51
	v0_36_0_3:1.51
	v0_36_0_2:1.51
	v0_36_0_1:1.51
	v0_36_0_0:1.51
	v0_36:1.51.0.2
	v0_34_0_3:1.50
	v0_34_0_2:1.50
	v0_34_0_1:1.50
	v0_34_0_0:1.50
	v0_34:1.50.0.4
	v0_32:1.50.0.2
	v0_32_0_0:1.50
	v0_30:1.44.0.2
	v0_28_0_0:1.40
	v0_26_0_1:1.30
	v0_26_0_0:1.30
	v0_24_0_1:1.29
	v0_24_0_0:1.29
	v0_22_0_0:1.28
	v0_20_0_0:1.26
	v0_18_0_0:1.20
	v0_16_0_0:1.20
	v0_14_0_1:1.17
	v0_14_0_0:1.17
	v0_12_0_0:1.17
	v0_10_0_1:1.16
	v0_10_0_0:1.15
	v0_8_0_0:1.2;
locks; strict;
comment	@ * @;


1.139
date	2015.07.02.07.21.18;	author jfrijters;	state Exp;
branches;
next	1.138;

1.138
date	2015.06.29.10.15.15;	author jfrijters;	state Exp;
branches;
next	1.137;

1.137
date	2015.06.26.11.22.19;	author jfrijters;	state Exp;
branches;
next	1.136;

1.136
date	2015.03.31.08.19.32;	author jfrijters;	state Exp;
branches;
next	1.135;

1.135
date	2015.03.24.09.31.46;	author jfrijters;	state Exp;
branches;
next	1.134;

1.134
date	2015.03.24.09.15.03;	author jfrijters;	state Exp;
branches;
next	1.133;

1.133
date	2015.03.13.12.54.26;	author jfrijters;	state Exp;
branches;
next	1.132;

1.132
date	2015.03.11.12.57.37;	author jfrijters;	state Exp;
branches;
next	1.131;

1.131
date	2014.06.24.12.06.44;	author jfrijters;	state Exp;
branches;
next	1.130;

1.130
date	2014.06.24.11.15.26;	author jfrijters;	state Exp;
branches;
next	1.129;

1.129
date	2014.06.05.11.08.57;	author jfrijters;	state Exp;
branches;
next	1.128;

1.128
date	2014.06.03.14.28.37;	author jfrijters;	state Exp;
branches;
next	1.127;

1.127
date	2014.06.03.12.04.41;	author jfrijters;	state Exp;
branches;
next	1.126;

1.126
date	2014.06.03.07.14.04;	author jfrijters;	state Exp;
branches;
next	1.125;

1.125
date	2014.05.27.12.32.26;	author jfrijters;	state Exp;
branches;
next	1.124;

1.124
date	2014.05.19.09.09.57;	author jfrijters;	state Exp;
branches;
next	1.123;

1.123
date	2014.04.28.13.39.41;	author jfrijters;	state Exp;
branches;
next	1.122;

1.122
date	2014.04.24.16.06.05;	author jfrijters;	state Exp;
branches;
next	1.121;

1.121
date	2014.04.17.11.34.52;	author jfrijters;	state Exp;
branches;
next	1.120;

1.120
date	2014.04.16.09.10.40;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2014.04.14.09.05.36;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2014.02.24.17.05.25;	author jfrijters;	state Exp;
branches;
next	1.117;

1.117
date	2014.02.21.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2014.02.20.16.51.25;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2014.02.20.15.51.03;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2013.08.12.07.55.58;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2013.08.05.12.47.14;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2013.08.05.11.52.59;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2013.08.05.11.48.37;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2013.05.03.10.30.08;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2013.04.01.05.35.31;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2013.03.30.06.28.26;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2013.03.27.11.36.20;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2013.03.06.10.06.25;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2013.03.06.06.54.14;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2013.03.05.15.59.58;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2013.03.05.13.29.09;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2013.02.09.10.04.13;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2013.02.07.19.34.06;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2013.01.30.17.39.46;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2013.01.08.14.47.50;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2012.09.21.11.23.09;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2012.08.06.14.52.11;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2012.07.20.08.46.34;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2012.06.20.09.49.51;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2012.05.01.07.55.37;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2012.03.24.08.54.13;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2012.03.12.08.33.27;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2011.11.28.08.14.13;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2011.11.28.06.47.24;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2011.11.14.06.17.52;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2011.11.11.15.35.14;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2011.10.20.08.06.07;	author jfrijters;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2011.08.15.16.11.00;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2011.08.12.13.06.46;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2011.08.10.10.12.10;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2011.08.10.09.06.27;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2011.06.19.09.33.09;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2011.02.17.12.43.18;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2010.12.07.06.47.30;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2010.09.27.04.42.56;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2010.06.07.12.36.49;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2010.06.07.10.05.28;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2010.06.07.06.13.05;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2010.06.01.04.09.48;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2010.05.21.13.38.46;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2010.01.28.06.37.48;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2010.01.28.06.24.13;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2009.12.11.08.06.17;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2009.11.30.09.13.48;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2009.07.16.06.26.47;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2009.06.18.05.55.47;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2009.04.16.05.34.21;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2009.04.07.04.53.56;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2008.12.23.06.07.11;	author jfrijters;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2008.11.14.07.54.11;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2008.09.21.09.50.41;	author jfrijters;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2008.08.15.12.01.15;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2008.08.15.06.27.13;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.03.07.13.49;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.02.06.20.29;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.31.15.20.38;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2008.05.09.05.57.59;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2008.04.14.05.13.41;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.27.09.04.20;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2007.12.19.11.28.11;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.12.09.48.36;	author jfrijters;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2006.11.16.07.32.45;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2006.10.09.12.32.33;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.21.05.15.52;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.17.07.33.40;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2006.08.06.09.27.20;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2006.07.27.11.57.33;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.24.08.21.11;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.06.13.53.51;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.22.10.04.07;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.06.10.46.51;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.03.08.52.52;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.23.10.46.51;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.20.13.20.58;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.19.15.49.57;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.05.11.04.44;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.05.08.19.00;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.27.16.21.32;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.27.07.59.35;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.31.10.13.32;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.01.14.01.43;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.01.11.16.12;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.24.11.35.00;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.05.08.40.54;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.03.12.59.16;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.02.07.24.54;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.20.10.48.00;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.20.09.42.11;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.01.09.49.30;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.31.15.30.36;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.23.08.24.08;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.02.15.12.03;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.10.08.24.28;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.06.09.36.49;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.05.12.32.00;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.21.10.26.53;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.29.09.48.05;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.16.11.11.54;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.19.13.43.56;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.04.19.30.54;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.05.09.37.59;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.30.15.56.24;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.14.10.36.39;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;

1.51.2.1
date	2008.02.27.07.04.01;	author jfrijters;	state Exp;
branches;
next	;

1.62.2.1
date	2008.11.11.18.32.19;	author jfrijters;	state Exp;
branches;
next	;

1.64.2.1
date	2009.06.15.04.56.38;	author jfrijters;	state Exp;
branches;
next	;

1.87.2.1
date	2012.01.03.12.16.37;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.139
log
@Improved -removeassertions ikvmc optimization to remove more code (esp. allow otherwise empty <clinit> methods to be optimized away).
@
text
@/*
  Copyright (C) 2002-2015 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.IO;
using System.Collections.Generic;
using IKVM.Attributes;

namespace IKVM.Internal
{
	enum HardError : short
	{
		NoClassDefFoundError,
		IllegalAccessError,
		InstantiationError,
		IncompatibleClassChangeError,
		NoSuchFieldError,
		AbstractMethodError,
		NoSuchMethodError,
		LinkageError,
		// "exceptions" that are wrapped in an IncompatibleClassChangeError
		IllegalAccessException,
		// if an error is added here, it must also be added to MethodAnalyzer.SetHardError()
	}

	[Flags]
	enum ClassFileParseOptions
	{
		None = 0,
		LocalVariableTable = 1,
		LineNumberTable = 2,
		RelaxedClassNameValidation = 4,
		TrustedAnnotations = 8,
		RemoveAssertions = 16,
	}

	sealed class ClassFile
	{
		private ConstantPoolItem[] constantpool;
		// Modifiers is a ushort, so the next four fields combine into two 32 bit slots
		private Modifiers access_flags;
		private ushort this_class;
		private ushort super_class;
		private ushort flags;
		private const ushort FLAG_MASK_MAJORVERSION = 0xFF;
		private const ushort FLAG_MASK_DEPRECATED = 0x100;
		private const ushort FLAG_MASK_INTERNAL = 0x200;
		private const ushort FLAG_CALLERSENSITIVE = 0x400;
		private const ushort FLAG_LAMBDAFORM_COMPILED = 0x800;
		private const ushort FLAG_LAMBDAFORM_HIDDEN = 0x1000;
		private const ushort FLAG_FORCEINLINE = 0x2000;
		private const ushort FLAG_HAS_ASSERTIONS = 0x4000;
		private ConstantPoolItemClass[] interfaces;
		private Field[] fields;
		private Method[] methods;
		private string sourceFile;
#if STATIC_COMPILER
		private string sourcePath;
#endif
		private string ikvmAssembly;
		private InnerClass[] innerClasses;
		private object[] annotations;
		private string signature;
		private string[] enclosingMethod;
		private BootstrapMethod[] bootstrapMethods;
		private byte[] runtimeVisibleTypeAnnotations;

		private static class SupportedVersions
		{
			internal static readonly int Minimum = 45;
			internal static readonly int Maximum = Experimental.JDK_9 ? 53 : 52;
		}

#if STATIC_COMPILER
		// This method parses just enough of the class file to obtain its name and
		// determine if the class is a possible ikvmstub generated stub, it doesn't
		// validate the class file structure, but it may throw a ClassFormatError if it
		// encounters bogus data
		internal static string GetClassName(byte[] buf, int offset, int length, out bool isstub)
		{
			isstub = false;
			BigEndianBinaryReader br = new BigEndianBinaryReader(buf, offset, length);
			if(br.ReadUInt32() != 0xCAFEBABE)
			{
				throw new ClassFormatError("Bad magic number");
			}
			int minorVersion = br.ReadUInt16();
			int majorVersion = br.ReadUInt16();
			if((majorVersion & FLAG_MASK_MAJORVERSION) != majorVersion
				|| majorVersion < SupportedVersions.Minimum
				|| majorVersion > SupportedVersions.Maximum
				|| (majorVersion == SupportedVersions.Minimum && minorVersion < 3)
				|| (majorVersion == SupportedVersions.Maximum && minorVersion != 0))
			{
				throw new UnsupportedClassVersionError(majorVersion + "." + minorVersion);
			}
			int constantpoolcount = br.ReadUInt16();
			int[] cpclass = new int[constantpoolcount];
			string[] utf8_cp = new string[constantpoolcount];
			for(int i = 1; i < constantpoolcount; i++)
			{
				Constant tag = (Constant)br.ReadByte();
				switch(tag)
				{
					case Constant.Class:
						cpclass[i] = br.ReadUInt16();
						break;
					case Constant.Double:
					case Constant.Long:
						br.Skip(8);
						i++;
						break;
					case Constant.Fieldref:
					case Constant.InterfaceMethodref:
					case Constant.Methodref:
					case Constant.InvokeDynamic:
					case Constant.NameAndType:
					case Constant.Float:
					case Constant.Integer:
						br.Skip(4);
						break;
					case Constant.MethodHandle:
						br.Skip(3);
						break;
					case Constant.String:
					case Constant.MethodType:
						br.Skip(2);
						break;
					case Constant.Utf8:
						isstub |= (utf8_cp[i] = br.ReadString(null, majorVersion)) == "IKVM.NET.Assembly";
						break;
					default:
						throw new ClassFormatError("Illegal constant pool type 0x{0:X}", tag);
				}
			}
			br.ReadUInt16(); // access_flags
			try
			{
				return String.Intern(utf8_cp[cpclass[br.ReadUInt16()]].Replace('/', '.'));
			}
			catch(Exception x)
			{
				throw new ClassFormatError("{0}: {1}", x.GetType().Name, x.Message);
			}
		}
#endif // STATIC_COMPILER

		internal ClassFile(byte[] buf, int offset, int length, string inputClassName, ClassFileParseOptions options, object[] constantPoolPatches)
		{
			try
			{
				BigEndianBinaryReader br = new BigEndianBinaryReader(buf, offset, length);
				if(br.ReadUInt32() != 0xCAFEBABE)
				{
					throw new ClassFormatError("{0} (Bad magic number)", inputClassName);
				}
				ushort minorVersion = br.ReadUInt16();
				ushort majorVersion = br.ReadUInt16();
				if((majorVersion & FLAG_MASK_MAJORVERSION) != majorVersion
					|| majorVersion < SupportedVersions.Minimum
					|| majorVersion > SupportedVersions.Maximum
					|| (majorVersion == SupportedVersions.Minimum && minorVersion < 3)
					|| (majorVersion == SupportedVersions.Maximum && minorVersion != 0))
				{
					throw new UnsupportedClassVersionError(inputClassName + " (" + majorVersion + "." + minorVersion + ")");
				}
				flags = majorVersion;
				int constantpoolcount = br.ReadUInt16();
				constantpool = new ConstantPoolItem[constantpoolcount];
				string[] utf8_cp = new string[constantpoolcount];
				for(int i = 1; i < constantpoolcount; i++)
				{
					Constant tag = (Constant)br.ReadByte();
					switch(tag)
					{
						case Constant.Class:
							constantpool[i] = new ConstantPoolItemClass(br);
							break;
						case Constant.Double:
							constantpool[i] = new ConstantPoolItemDouble(br);
							i++;
							break;
						case Constant.Fieldref:
							constantpool[i] = new ConstantPoolItemFieldref(br);
							break;
						case Constant.Float:
							constantpool[i] = new ConstantPoolItemFloat(br);
							break;
						case Constant.Integer:
							constantpool[i] = new ConstantPoolItemInteger(br);
							break;
						case Constant.InterfaceMethodref:
							constantpool[i] = new ConstantPoolItemInterfaceMethodref(br);
							break;
						case Constant.Long:
							constantpool[i] = new ConstantPoolItemLong(br);
							i++;
							break;
						case Constant.Methodref:
							constantpool[i] = new ConstantPoolItemMethodref(br);
							break;
						case Constant.NameAndType:
							constantpool[i] = new ConstantPoolItemNameAndType(br);
							break;
						case Constant.MethodHandle:
							if (majorVersion < 51)
								goto default;
							constantpool[i] = new ConstantPoolItemMethodHandle(br);
							break;
						case Constant.MethodType:
							if (majorVersion < 51)
								goto default;
							constantpool[i] = new ConstantPoolItemMethodType(br);
							break;
						case Constant.InvokeDynamic:
							if (majorVersion < 51)
								goto default;
							constantpool[i] = new ConstantPoolItemInvokeDynamic(br);
							break;
						case Constant.String:
							constantpool[i] = new ConstantPoolItemString(br);
							break;
						case Constant.Utf8:
							utf8_cp[i] = br.ReadString(inputClassName, majorVersion);
							break;
						default:
							throw new ClassFormatError("{0} (Illegal constant pool type 0x{1:X})", inputClassName, tag);
					}
				}
				if (constantPoolPatches != null)
				{
					PatchConstantPool(constantPoolPatches, utf8_cp, inputClassName);
				}
				for(int i = 1; i < constantpoolcount; i++)
				{
					if(constantpool[i] != null)
					{
						try
						{
							constantpool[i].Resolve(this, utf8_cp, options);
						}
						catch(ClassFormatError x)
						{
							// HACK at this point we don't yet have the class name, so any exceptions throw
							// are missing the class name
							throw new ClassFormatError("{0} ({1})", inputClassName, x.Message);
						}
						catch(IndexOutOfRangeException)
						{
							throw new ClassFormatError("{0} (Invalid constant pool item #{1})", inputClassName, i);
						}
						catch(InvalidCastException)
						{
							throw new ClassFormatError("{0} (Invalid constant pool item #{1})", inputClassName, i);
						}
					}
				}
				access_flags = (Modifiers)br.ReadUInt16();
				// NOTE although the vmspec says (in 4.1) that interfaces must be marked abstract, earlier versions of
				// javac (JDK 1.1) didn't do this, so the VM doesn't enforce this rule for older class files.
				// NOTE although the vmspec implies (in 4.1) that ACC_SUPER is illegal on interfaces, it doesn't enforce this
				// for older class files.
				// (See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6320322)
				if((IsInterface && IsFinal)
					|| (IsAbstract && IsFinal)
					|| (majorVersion >= 49 && IsAnnotation && !IsInterface)
					|| (majorVersion >= 49 && IsInterface && (!IsAbstract || IsSuper || IsEnum)))
				{
					throw new ClassFormatError("{0} (Illegal class modifiers 0x{1:X})", inputClassName, access_flags);
				}
				this_class = br.ReadUInt16();
				ValidateConstantPoolItemClass(inputClassName, this_class);
				super_class = br.ReadUInt16();
				ValidateConstantPoolItemClass(inputClassName, super_class);
				if(IsInterface && (super_class == 0 || this.SuperClass.Name != "java.lang.Object"))
				{
					throw new ClassFormatError("{0} (Interfaces must have java.lang.Object as superclass)", Name);
				}
				// most checks are already done by ConstantPoolItemClass.Resolve, but since it allows
				// array types, we do need to check for that
				if(this.Name[0] == '[')
				{
					throw new ClassFormatError("Bad name");
				}
				int interfaces_count = br.ReadUInt16();
				interfaces = new ConstantPoolItemClass[interfaces_count];
				for(int i = 0; i < interfaces.Length; i++)
				{
					int index = br.ReadUInt16();
					if(index == 0 || index >= constantpool.Length)
					{
						throw new ClassFormatError("{0} (Illegal constant pool index)", Name);
					}
					ConstantPoolItemClass cpi = constantpool[index] as ConstantPoolItemClass;
					if(cpi == null)
					{
						throw new ClassFormatError("{0} (Interface name has bad constant type)", Name);
					}
					interfaces[i] = cpi;
				}
				CheckDuplicates(interfaces, "Repetitive interface name");
				int fields_count = br.ReadUInt16();
				fields = new Field[fields_count];
				for(int i = 0; i < fields_count; i++)
				{
					fields[i] = new Field(this, utf8_cp, br);
					string name = fields[i].Name;
					if(!IsValidFieldName(name, majorVersion))
					{
						throw new ClassFormatError("{0} (Illegal field name \"{1}\")", Name, name);
					}
				}
				CheckDuplicates<FieldOrMethod>(fields, "Repetitive field name/signature");
				int methods_count = br.ReadUInt16();
				methods = new Method[methods_count];
				for(int i = 0; i < methods_count; i++)
				{
					methods[i] = new Method(this, utf8_cp, options, br);
					string name = methods[i].Name;
					string sig = methods[i].Signature;
					if(!IsValidMethodName(name, majorVersion))
					{
						if(!ReferenceEquals(name, StringConstants.INIT) && !ReferenceEquals(name, StringConstants.CLINIT))
						{
							throw new ClassFormatError("{0} (Illegal method name \"{1}\")", Name, name);
						}
						if(!sig.EndsWith("V"))
						{
							throw new ClassFormatError("{0} (Method \"{1}\" has illegal signature \"{2}\")", Name, name, sig);
						}
						if((options & ClassFileParseOptions.RemoveAssertions) != 0 && methods[i].IsClassInitializer)
						{
							RemoveAssertionInit(methods[i]);
						}
					}
				}
				CheckDuplicates<FieldOrMethod>(methods, "Repetitive method name/signature");
				int attributes_count = br.ReadUInt16();
				for(int i = 0; i < attributes_count; i++)
				{
					switch(GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16()))
					{
						case "Deprecated":
							if(br.ReadUInt32() != 0)
							{
								throw new ClassFormatError("Invalid Deprecated attribute length");
							}
							flags |= FLAG_MASK_DEPRECATED;
							break;
						case "SourceFile":
							if(br.ReadUInt32() != 2)
							{
								throw new ClassFormatError("SourceFile attribute has incorrect length");
							}
							sourceFile = GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16());
							break;
						case "InnerClasses":
						{
							BigEndianBinaryReader rdr = br;
							uint attribute_length = br.ReadUInt32();
							ushort count = rdr.ReadUInt16();
							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))
							{
								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)", this.Name);
							}
							innerClasses = new InnerClass[count];
							for(int j = 0; j < innerClasses.Length; j++)
							{
								innerClasses[j].innerClass = rdr.ReadUInt16();
								innerClasses[j].outerClass = rdr.ReadUInt16();
								innerClasses[j].name = rdr.ReadUInt16();
								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();
								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))
								{
									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)", this.Name);
								}
								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))
								{
									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)", this.Name);
								}
								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)
								{
									throw new ClassFormatError("{0} (inner class name has bad constant pool index)", this.Name);
								}
								if(innerClasses[j].innerClass == innerClasses[j].outerClass)
								{
									throw new ClassFormatError("{0} (Class is both inner and outer class)", this.Name);
								}
								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)
								{
									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);
									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);
								}
							}
							break;
						}
						case "Signature":
							if(majorVersion < 49)
							{
								goto default;
							}
							if(br.ReadUInt32() != 2)
							{
								throw new ClassFormatError("Signature attribute has incorrect length");
							}
							signature = GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16());
							break;
						case "EnclosingMethod":
							if(majorVersion < 49)
							{
								goto default;
							}
							if(br.ReadUInt32() != 4)
							{
								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");
							}
							else
							{
								ushort class_index = br.ReadUInt16();
								ushort method_index = br.ReadUInt16();
								ValidateConstantPoolItemClass(inputClassName, class_index);
								if(method_index == 0)
								{
									enclosingMethod = new string[] {
										GetConstantPoolClass(class_index),
										null,
										null
																   };
								}
								else
								{
									ConstantPoolItemNameAndType m = GetConstantPoolItem(method_index) as ConstantPoolItemNameAndType;
									if(m == null)
									{
										throw new ClassFormatError("{0} (Bad constant pool index #{1})", inputClassName, method_index);
									}
									enclosingMethod = new string[] {
										GetConstantPoolClass(class_index),
										GetConstantPoolUtf8String(utf8_cp, m.name_index),
										GetConstantPoolUtf8String(utf8_cp, m.descriptor_index).Replace('/', '.')
																   };
								}
							}
							break;
						case "RuntimeVisibleAnnotations":
							if(majorVersion < 49)
							{
								goto default;
							}
							annotations = ReadAnnotations(br, this, utf8_cp);
							break;
#if STATIC_COMPILER
						case "RuntimeInvisibleAnnotations":
							if(majorVersion < 49)
							{
								goto default;
							}
							foreach(object[] annot in ReadAnnotations(br, this, utf8_cp))
							{
								if(annot[1].Equals("Likvm/lang/Internal;"))
								{
									this.access_flags &= ~Modifiers.AccessMask;
									flags |= FLAG_MASK_INTERNAL;
								}
							}
							break;
#endif
						case "BootstrapMethods":
							if(majorVersion < 51)
							{
								goto default;
							}
							bootstrapMethods = ReadBootstrapMethods(br, this);
							break;
						case "RuntimeVisibleTypeAnnotations":
							if(majorVersion < 52)
							{
								goto default;
							}
							CreateUtf8ConstantPoolItems(utf8_cp);
							runtimeVisibleTypeAnnotations = br.Section(br.ReadUInt32()).ToArray();
							break;
						case "IKVM.NET.Assembly":
							if(br.ReadUInt32() != 2)
							{
								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");
							}
							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16());
							break;
						default:
							br.Skip(br.ReadUInt32());
							break;
					}
				}
				// validate the invokedynamic entries to point into the bootstrapMethods array
				for(int i = 1; i < constantpoolcount; i++)
				{
					ConstantPoolItemInvokeDynamic cpi;
					if(constantpool[i] != null
						&& (cpi = constantpool[i] as ConstantPoolItemInvokeDynamic) != null)
					{
						if(bootstrapMethods == null || cpi.BootstrapMethod >= bootstrapMethods.Length)
						{
							throw new ClassFormatError("Short length on BootstrapMethods in class file");
						}
					}
				}
				if(br.Position != offset + length)
				{
					throw new ClassFormatError("Extra bytes at the end of the class file");
				}
			}
			catch(OverflowException)
			{
				throw new ClassFormatError("Truncated class file (or section)");
			}
			catch(IndexOutOfRangeException)
			{
				// TODO we should throw more specific errors
				throw new ClassFormatError("Unspecified class file format error");
			}
			//		catch(Exception x)
			//		{
			//			Console.WriteLine(x);
			//			FileStream fs = File.Create(inputClassName + ".broken");
			//			fs.Write(buf, offset, length);
			//			fs.Close();
			//			throw;
			//		}
		}

		private void CreateUtf8ConstantPoolItems(string[] utf8_cp)
		{
			for (int i = 0; i < constantpool.Length; i++)
			{
				if (constantpool[i] == null && utf8_cp[i] != null)
				{
					constantpool[i] = new ConstantPoolItemUtf8(utf8_cp[i]);
				}
			}
		}

		private void CheckDuplicates<T>(T[] members, string msg)
			where T : IEquatable<T>
		{
			if (members.Length < 100)
			{
				for (int i = 0; i < members.Length; i++)
				{
					for (int j = 0; j < i; j++)
					{
						if (members[i].Equals(members[j]))
						{
							throw new ClassFormatError("{0} ({1})", Name, msg);
						}
					}
				}
			}
			else
			{
				Dictionary<T, object> dict = new Dictionary<T, object>();
				for (int i = 0; i < members.Length; i++)
				{
					if (dict.ContainsKey(members[i]))
					{
						throw new ClassFormatError("{0} ({1})", Name, msg);
					}
					dict.Add(members[i], null);
				}
			}
		}

		private void PatchConstantPool(object[] constantPoolPatches, string[] utf8_cp, string inputClassName)
		{
#if !STATIC_COMPILER && !FIRST_PASS
			for (int i = 0; i < constantPoolPatches.Length; i++)
			{
				if (constantPoolPatches[i] != null)
				{
					if (utf8_cp[i] != null)
					{
						if (!(constantPoolPatches[i] is string))
						{
							throw new ClassFormatError("Illegal utf8 patch at {0} in class file {1}", i, inputClassName);
						}
						utf8_cp[i] = (string)constantPoolPatches[i];
					}
					else if (constantpool[i] != null)
					{
						switch (constantpool[i].GetConstantType())
						{
							case ConstantType.String:
								constantpool[i] = new ConstantPoolItemLiveObject(constantPoolPatches[i]);
								break;
							case ConstantType.Class:
								java.lang.Class clazz;
								string name;
								if ((clazz = constantPoolPatches[i] as java.lang.Class) != null)
								{
									TypeWrapper tw = TypeWrapper.FromClass(clazz);
									constantpool[i] = new ConstantPoolItemClass(tw.Name, tw);
								}
								else if ((name = constantPoolPatches[i] as string) != null)
								{
									constantpool[i] = new ConstantPoolItemClass(String.Intern(name.Replace('/', '.')), null);
								}
								else
								{
									throw new ClassFormatError("Illegal class patch at {0} in class file {1}", i, inputClassName);
								}
								break;
							case ConstantType.Integer:
								((ConstantPoolItemInteger)constantpool[i]).v = ((java.lang.Integer)constantPoolPatches[i]).intValue();
								break;
							case ConstantType.Long:
								((ConstantPoolItemLong)constantpool[i]).l = ((java.lang.Long)constantPoolPatches[i]).longValue();
								break;
							case ConstantType.Float:
								((ConstantPoolItemFloat)constantpool[i]).v = ((java.lang.Float)constantPoolPatches[i]).floatValue();
								break;
							case ConstantType.Double:
								((ConstantPoolItemDouble)constantpool[i]).d = ((java.lang.Double)constantPoolPatches[i]).doubleValue();
								break;
							default:
								throw new NotImplementedException("ConstantPoolPatch: " + constantPoolPatches[i]);
						}
					}
				}
			}
#endif
		}

		private void MarkLinkRequiredConstantPoolItem(int index)
		{
			if (index > 0 && index < constantpool.Length && constantpool[index] != null)
			{
				constantpool[index].MarkLinkRequired();
			}
		}

		private static BootstrapMethod[] ReadBootstrapMethods(BigEndianBinaryReader br, ClassFile classFile)
		{
			BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
			ushort count = rdr.ReadUInt16();
			BootstrapMethod[] bsm = new BootstrapMethod[count];
			for(int i = 0; i < bsm.Length; i++)
			{
				ushort bsm_index = rdr.ReadUInt16();
				if(bsm_index >= classFile.constantpool.Length || !(classFile.constantpool[bsm_index] is ConstantPoolItemMethodHandle))
				{
					throw new ClassFormatError("bootstrap_method_index {0} has bad constant type in class file {1}", bsm_index, classFile.Name);
				}
				classFile.MarkLinkRequiredConstantPoolItem(bsm_index);
				ushort argument_count = rdr.ReadUInt16();
				ushort[] args = new ushort[argument_count];
				for(int j = 0; j < args.Length; j++)
				{
					ushort argument_index = rdr.ReadUInt16();
					if(!classFile.IsValidConstant(argument_index))
					{
						throw new ClassFormatError("argument_index {0} has bad constant type in class file {1}", argument_index, classFile.Name);
					}
					classFile.MarkLinkRequiredConstantPoolItem(argument_index);
					args[j] = argument_index;
				}
				bsm[i] = new BootstrapMethod(bsm_index, args);
			}
			if(!rdr.IsAtEnd)
			{
				throw new ClassFormatError("Bad length on BootstrapMethods in class file {0}", classFile.Name);
			}
			return bsm;
		}

		private bool IsValidConstant(ushort index)
		{
			if(index < constantpool.Length && constantpool[index] != null)
			{
				try
				{
					constantpool[index].GetConstantType();
					return true;
				}
				catch (InvalidOperationException) { }
			}
			return false;
		}

		private static object[] ReadAnnotations(BigEndianBinaryReader br, ClassFile classFile, string[] utf8_cp)
		{
			BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
			ushort num_annotations = rdr.ReadUInt16();
			object[] annotations = new object[num_annotations];
			for(int i = 0; i < annotations.Length; i++)
			{
				annotations[i] = ReadAnnotation(rdr, classFile, utf8_cp);
			}
			if(!rdr.IsAtEnd)
			{
				throw new ClassFormatError("{0} (RuntimeVisibleAnnotations attribute has wrong length)", classFile.Name);
			}
			return annotations;
		}

		private static object ReadAnnotation(BigEndianBinaryReader rdr, ClassFile classFile, string[] utf8_cp)
		{
			string type = classFile.GetConstantPoolUtf8String(utf8_cp, rdr.ReadUInt16());
			ushort num_element_value_pairs = rdr.ReadUInt16();
			object[] annot = new object[2 + num_element_value_pairs * 2];
			annot[0] = AnnotationDefaultAttribute.TAG_ANNOTATION;
			annot[1] = type;
			for(int i = 0; i < num_element_value_pairs; i++)
			{
				annot[2 + i * 2 + 0] = classFile.GetConstantPoolUtf8String(utf8_cp, rdr.ReadUInt16());
				annot[2 + i * 2 + 1] = ReadAnnotationElementValue(rdr, classFile, utf8_cp);
			}
			return annot;
		}

		private static object ReadAnnotationElementValue(BigEndianBinaryReader rdr, ClassFile classFile, string[] utf8_cp)
		{
			try
			{
				byte tag = rdr.ReadByte();
				switch (tag)
				{
					case (byte)'Z':
						return classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16()) != 0;
					case (byte)'B':
						return (byte)classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16());
					case (byte)'C':
						return (char)classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16());
					case (byte)'S':
						return (short)classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16());
					case (byte)'I':
						return classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16());
					case (byte)'F':
						return classFile.GetConstantPoolConstantFloat(rdr.ReadUInt16());
					case (byte)'J':
						return classFile.GetConstantPoolConstantLong(rdr.ReadUInt16());
					case (byte)'D':
						return classFile.GetConstantPoolConstantDouble(rdr.ReadUInt16());
					case (byte)'s':
						return classFile.GetConstantPoolUtf8String(utf8_cp, rdr.ReadUInt16());
					case (byte)'e':
						{
							ushort type_name_index = rdr.ReadUInt16();
							ushort const_name_index = rdr.ReadUInt16();
							return new object[] {
											AnnotationDefaultAttribute.TAG_ENUM,
											classFile.GetConstantPoolUtf8String(utf8_cp, type_name_index),
											classFile.GetConstantPoolUtf8String(utf8_cp, const_name_index)
										};
						}
					case (byte)'c':
						return new object[] {
											AnnotationDefaultAttribute.TAG_CLASS,
											classFile.GetConstantPoolUtf8String(utf8_cp, rdr.ReadUInt16())
										};
					case (byte)'@@':
						return ReadAnnotation(rdr, classFile, utf8_cp);
					case (byte)'[':
						{
							ushort num_values = rdr.ReadUInt16();
							object[] array = new object[num_values + 1];
							array[0] = AnnotationDefaultAttribute.TAG_ARRAY;
							for (int i = 0; i < num_values; i++)
							{
								array[i + 1] = ReadAnnotationElementValue(rdr, classFile, utf8_cp);
							}
							return array;
						}
					default:
						throw new ClassFormatError("Invalid tag {0} in annotation element_value", tag);
				}
			}
			catch (NullReferenceException)
			{
			}
			catch (InvalidCastException)
			{
			}
			catch (IndexOutOfRangeException)
			{
			}
			return new object[] { AnnotationDefaultAttribute.TAG_ERROR, "java.lang.IllegalArgumentException", "Wrong type at constant pool index" };
		}

		private void ValidateConstantPoolItemClass(string classFile, ushort index)
		{
			if(index >= constantpool.Length || !(constantpool[index] is ConstantPoolItemClass))
			{
				throw new ClassFormatError("{0} (Bad constant pool index #{1})", classFile, index);
			}
		}

		private static bool IsValidMethodName(string name, int majorVersion)
		{
			if(name.Length == 0)
			{
				return false;
			}
			for(int i = 0; i < name.Length; i++)
			{
				if(".;[/<>".IndexOf(name[i]) != -1)
				{
					return false;
				}
			}
			return majorVersion >= 49 || IsValidPre49Identifier(name);
		}

		private static bool IsValidFieldName(string name, int majorVersion)
		{
			if(name.Length == 0)
			{
				return false;
			}
			for(int i = 0; i < name.Length; i++)
			{
				if(".;[/".IndexOf(name[i]) != -1)
				{
					return false;
				}
			}
			return majorVersion >= 49 || IsValidPre49Identifier(name);
		}

		private static bool IsValidPre49Identifier(string name)
		{
			if(!Char.IsLetter(name[0]) && "$_".IndexOf(name[0]) == -1)
			{
				return false;
			}
			for(int i = 1; i < name.Length; i++)
			{
				if(!Char.IsLetterOrDigit(name[i]) && "$_".IndexOf(name[i]) == -1)
				{
					return false;
				}
			}
			return true;
		}

		internal static bool IsValidFieldSig(string sig)
		{
			return IsValidFieldSigImpl(sig, 0, sig.Length);
		}

		private static bool IsValidFieldSigImpl(string sig, int start, int end)
		{
			if(start >= end)
			{
				return false;
			}
			switch(sig[start])
			{
				case 'L':
					return sig.IndexOf(';', start + 1) == end - 1;
				case '[':
					while(sig[start] == '[')
					{
						start++;
						if(start == end)
						{
							return false;
						}
					}
					return IsValidFieldSigImpl(sig, start, end);
				case 'B':
				case 'Z':
				case 'C':
				case 'S':
				case 'I':
				case 'J':
				case 'F':
				case 'D':
					return start == end - 1;
				default:
					return false;
			}
		}

		internal static bool IsValidMethodSig(string sig)
		{
			if(sig.Length < 3 || sig[0] != '(')
			{
				return false;
			}
			int end = sig.IndexOf(')');
			if(end == -1)
			{
				return false;
			}
			if(!sig.EndsWith(")V") && !IsValidFieldSigImpl(sig, end + 1, sig.Length))
			{
				return false;
			}
			for(int i = 1; i < end; i++)
			{
				switch(sig[i])
				{
					case 'B':
					case 'Z':
					case 'C':
					case 'S':
					case 'I':
					case 'J':
					case 'F':
					case 'D':
						break;
					case 'L':
						i = sig.IndexOf(';', i);
						break;
					case '[':
						while(sig[i] == '[')
						{
							i++;
						}
						if("BZCSIJFDL".IndexOf(sig[i]) == -1)
						{
							return false;
						}
						if(sig[i] == 'L')
						{
							i = sig.IndexOf(';', i);
						}
						break;
					default:
						return false;
				}
				if(i == -1 || i >= end)
				{
					return false;
				}
			}
			return true;
		}

		internal int MajorVersion
		{
			get
			{
				return flags & FLAG_MASK_MAJORVERSION;
			}
		}

		internal void Link(TypeWrapper thisType, LoadMode mode)
		{
			// this is not just an optimization, it's required for anonymous classes to be able to refer to themselves
			((ConstantPoolItemClass)constantpool[this_class]).LinkSelf(thisType);
			for(int i = 1; i < constantpool.Length; i++)
			{
				if(constantpool[i] != null)
				{
					constantpool[i].Link(thisType, mode);
				}
			}
		}

		internal Modifiers Modifiers
		{
			get
			{
				return access_flags;
			}
		}

		internal bool IsAbstract
		{
			get
			{
				// interfaces are implicitly abstract
				return (access_flags & (Modifiers.Abstract | Modifiers.Interface)) != 0;
			}
		}

		internal bool IsFinal
		{
			get
			{
				return (access_flags & Modifiers.Final) != 0;
			}
		}

		internal bool IsPublic
		{
			get
			{
				return (access_flags & Modifiers.Public) != 0;
			}
		}

		internal bool IsInterface
		{
			get
			{
				return (access_flags & Modifiers.Interface) != 0;
			}
		}

		internal bool IsEnum
		{
			get
			{
				return (access_flags & Modifiers.Enum) != 0;
			}
		}

		internal bool IsAnnotation
		{
			get
			{
				return (access_flags & Modifiers.Annotation) != 0;
			}
		}

		internal bool IsSuper
		{
			get
			{
				return (access_flags & Modifiers.Super) != 0;
			}
		}

		internal bool IsReferenced(Field fld)
		{
			foreach(ConstantPoolItem cpi in constantpool)
			{
				ConstantPoolItemFieldref fieldref = cpi as ConstantPoolItemFieldref;
				if(fieldref != null && 
					fieldref.Class == this.Name && 
					fieldref.Name == fld.Name && 
					fieldref.Signature == fld.Signature)
				{
					return true;
				}
			}
			return false;
		}

		internal ConstantPoolItemFieldref GetFieldref(int index)
		{
			return (ConstantPoolItemFieldref)constantpool[index];
		}

		// this won't throw an exception if index is invalid
		// (used by IsSideEffectFreeStaticInitializer)
		internal ConstantPoolItemFieldref SafeGetFieldref(int index)
		{
			if(index > 0 && index < constantpool.Length)
			{
				return constantpool[index] as ConstantPoolItemFieldref;
			}
			return null;
		}

		// NOTE this returns an MI, because it used for both normal methods and interface methods
		internal ConstantPoolItemMI GetMethodref(int index)
		{
			return (ConstantPoolItemMI)constantpool[index];
		}

		// this won't throw an exception if index is invalid
		// (used by IsAccessBridge)
		internal ConstantPoolItemMI SafeGetMethodref(int index)
		{
			if (index > 0 && index < constantpool.Length)
			{
				return constantpool[index] as ConstantPoolItemMI;
			}
			return null;
		}

		internal ConstantPoolItemInvokeDynamic GetInvokeDynamic(int index)
		{
			return (ConstantPoolItemInvokeDynamic)constantpool[index];
		}

		private ConstantPoolItem GetConstantPoolItem(int index)
		{
			return constantpool[index];
		}

		internal string GetConstantPoolClass(int index)
		{
			return ((ConstantPoolItemClass)constantpool[index]).Name;
		}

		private bool SafeIsConstantPoolClass(int index)
		{
			if(index > 0 && index < constantpool.Length)
			{
				return constantpool[index] as ConstantPoolItemClass != null;
			}
			return false;
		}

		internal TypeWrapper GetConstantPoolClassType(int index)
		{
			return ((ConstantPoolItemClass)constantpool[index]).GetClassType();
		}

		private string GetConstantPoolUtf8String(string[] utf8_cp, int index)
		{
			string s = utf8_cp[index];
			if(s == null)
			{
				if(this_class == 0)
				{
					throw new ClassFormatError("Bad constant pool index #{0}", index);
				}
				else
				{
					throw new ClassFormatError("{0} (Bad constant pool index #{1})", this.Name, index);
				}
			}
			return s;
		}

		internal ConstantType GetConstantPoolConstantType(int index)
		{
			return constantpool[index].GetConstantType();
		}

		internal double GetConstantPoolConstantDouble(int index)
		{
			return ((ConstantPoolItemDouble)constantpool[index]).Value;
		}

		internal float GetConstantPoolConstantFloat(int index)
		{
			return ((ConstantPoolItemFloat)constantpool[index]).Value;
		}

		internal int GetConstantPoolConstantInteger(int index)
		{
			return ((ConstantPoolItemInteger)constantpool[index]).Value;
		}

		internal long GetConstantPoolConstantLong(int index)
		{
			return ((ConstantPoolItemLong)constantpool[index]).Value;
		}

		internal string GetConstantPoolConstantString(int index)
		{
			return ((ConstantPoolItemString)constantpool[index]).Value;
		}

		internal ConstantPoolItemMethodHandle GetConstantPoolConstantMethodHandle(int index)
		{
			return (ConstantPoolItemMethodHandle)constantpool[index];
		}

		internal ConstantPoolItemMethodType GetConstantPoolConstantMethodType(int index)
		{
			return (ConstantPoolItemMethodType)constantpool[index];
		}

		internal object GetConstantPoolConstantLiveObject(int index)
		{
			return ((ConstantPoolItemLiveObject)constantpool[index]).Value;
		}

		internal string Name
		{
			get
			{
				return GetConstantPoolClass(this_class);
			}
		}

		internal ConstantPoolItemClass SuperClass
		{
			get
			{
				return (ConstantPoolItemClass)constantpool[super_class];
			}
		}

		internal Field[] Fields
		{
			get
			{
				return fields;
			}
		}

		internal Method[] Methods
		{
			get
			{
				return methods;
			}
		}

		internal ConstantPoolItemClass[] Interfaces
		{
			get
			{
				return interfaces;
			}
		}

		internal string SourceFileAttribute
		{
			get
			{
				return sourceFile;
			}
		}

		internal string SourcePath
		{
#if STATIC_COMPILER
			get { return sourcePath; }
			set { sourcePath = value; }
#else
			get { return sourceFile; }
#endif
		}

		internal object[] Annotations
		{
			get
			{
				return annotations;
			}
		}

		internal string GenericSignature
		{
			get
			{
				return signature;
			}
		}

		internal string[] EnclosingMethod
		{
			get
			{
				return enclosingMethod;
			}
		}

		internal byte[] RuntimeVisibleTypeAnnotations
		{
			get
			{
				return runtimeVisibleTypeAnnotations;
			}
		}

		internal object[] GetConstantPool()
		{
			object[] cp = new object[constantpool.Length];
			for (int i = 1; i < cp.Length; i++)
			{
				if (constantpool[i] != null)
				{
					cp[i] = constantpool[i].GetRuntimeValue();
				}
			}
			return cp;
		}

		internal string IKVMAssemblyAttribute
		{
			get
			{
				return ikvmAssembly;
			}
		}

		internal bool DeprecatedAttribute
		{
			get
			{
				return (flags & FLAG_MASK_DEPRECATED) != 0;
			}
		}

		internal bool IsInternal
		{
			get
			{
				return (flags & FLAG_MASK_INTERNAL) != 0;
			}
		}

		// for use by ikvmc (to implement the -privatepackage option)
		internal void SetInternal()
		{
			access_flags &= ~Modifiers.AccessMask;
			flags |= FLAG_MASK_INTERNAL;
		}

		internal bool HasAssertions
		{
			get
			{
				return (flags & FLAG_HAS_ASSERTIONS) != 0;
			}
		}

		internal bool HasInitializedFields
		{
			get
			{
				foreach (Field f in fields)
				{
					if (f.IsStatic && !f.IsFinal && f.ConstantValue != null)
					{
						return true;
					}
				}
				return false;
			}
		}

		internal BootstrapMethod GetBootstrapMethod(int index)
		{
			return bootstrapMethods[index];
		}

		internal struct BootstrapMethod
		{
			private ushort bsm_index;
			private ushort[] args;

			internal BootstrapMethod(ushort bsm_index, ushort[] args)
			{
				this.bsm_index = bsm_index;
				this.args = args;
			}

			internal int BootstrapMethodIndex
			{
				get { return bsm_index; }
			}

			internal int ArgumentCount
			{
				get { return args.Length; }
			}

			internal int GetArgument(int index)
			{
				return args[index];
			}
		}

		internal struct InnerClass
		{
			internal ushort innerClass;		// ConstantPoolItemClass
			internal ushort outerClass;		// ConstantPoolItemClass
			internal ushort name;			// ConstantPoolItemUtf8
			internal Modifiers accessFlags;
		}

		internal InnerClass[] InnerClasses
		{
			get
			{
				return innerClasses;
			}
		}

		internal enum RefKind
		{
			getField = 1,
			getStatic = 2,
			putField = 3,
			putStatic = 4,
			invokeVirtual = 5,
			invokeStatic = 6,
			invokeSpecial = 7,
			newInvokeSpecial = 8,
			invokeInterface = 9
		}

		internal enum ConstantType
		{
			Integer,
			Long,
			Float,
			Double,
			String,
			Class,
			MethodHandle,
			MethodType,
			LiveObject,		// used by anonymous class constant pool patching
		}

		internal abstract class ConstantPoolItem
		{
			internal virtual void Resolve(ClassFile classFile, string[] utf8_cp, ClassFileParseOptions options)
			{
			}

			internal virtual void Link(TypeWrapper thisType, LoadMode mode)
			{
			}

			internal virtual ConstantType GetConstantType()
			{
				throw new InvalidOperationException();
			}

			internal virtual void MarkLinkRequired()
			{
			}

			// this is used for sun.reflect.ConstantPool
			// it returns a boxed System.Int32, System.Int64, System.Float, System.Double or a string
			internal virtual object GetRuntimeValue()
			{
				return null;
			}
		}

		internal sealed class ConstantPoolItemClass : ConstantPoolItem, IEquatable<ConstantPoolItemClass>
		{
			private ushort name_index;
			private string name;
			private TypeWrapper typeWrapper;
			private static char[] invalidJava15Characters = { '.', ';', '[', ']' };

			internal ConstantPoolItemClass(BigEndianBinaryReader br)
			{
				name_index = br.ReadUInt16();
			}

			internal ConstantPoolItemClass(string name, TypeWrapper typeWrapper)
			{
				this.name = name;
				this.typeWrapper = typeWrapper;
			}

			internal override void Resolve(ClassFile classFile, string[] utf8_cp, ClassFileParseOptions options)
			{
				// if the item was patched, we already have a name
				if(name != null)
				{
					return;
				}
				name = classFile.GetConstantPoolUtf8String(utf8_cp, name_index);
				if(name.Length > 0)
				{
					// We don't enforce the strict class name rules in the static compiler, since HotSpot doesn't enforce *any* rules on
					// class names for the system (and boot) class loader. We still need to enforce the 1.5 restrictions, because we
					// rely on those invariants.
#if !STATIC_COMPILER
					if(classFile.MajorVersion < 49 && (options & ClassFileParseOptions.RelaxedClassNameValidation) == 0)
					{
						char prev = name[0];
						if(Char.IsLetter(prev) || prev == '$' || prev == '_' || prev == '[' || prev == '/')
						{
							int skip = 1;
							int end = name.Length;
							if(prev == '[')
							{
								if(!IsValidFieldSig(name))
								{
									goto barf;
								}
								while(name[skip] == '[')
								{
									skip++;
								}
								if(name.EndsWith(";"))
								{
									end--;
								}
							}
							for(int i = skip; i < end; i++)
							{
								char c = name[i];
								if(!Char.IsLetterOrDigit(c) && c != '$' && c != '_' && (c != '/' || prev == '/'))
								{
									goto barf;
								}
								prev = c;
							}
							name = String.Intern(name.Replace('/', '.'));
							return;
						}
					}
					else
#endif
					{
						// since 1.5 the restrictions on class names have been greatly reduced
						int start = 0;
						int end = name.Length;
						if(name[0] == '[')
						{
							if(!IsValidFieldSig(name))
							{
								goto barf;
							}
							// the semicolon is only allowed at the end and IsValidFieldSig enforces this,
							// but since invalidJava15Characters contains the semicolon, we decrement end
							// to make the following check against invalidJava15Characters ignore the
							// trailing semicolon.
							if(name[end - 1] == ';')
							{
								end--;
							}
							while(name[start] == '[')
							{
								start++;
							}
						}
						if(name.IndexOfAny(invalidJava15Characters, start, end - start) >= 0)
						{
							goto barf;
						}
						name = String.Intern(name.Replace('/', '.'));
						return;
					}
				}
				barf:
					throw new ClassFormatError("Invalid class name \"{0}\"", name);
			}

			internal override void MarkLinkRequired()
			{
				if(typeWrapper == null)
				{
					typeWrapper = VerifierTypeWrapper.Null;
				}
			}

			internal void LinkSelf(TypeWrapper thisType)
			{
				this.typeWrapper = thisType;
			}

			internal override void Link(TypeWrapper thisType, LoadMode mode)
			{
				if(typeWrapper == VerifierTypeWrapper.Null)
				{
					TypeWrapper tw = thisType.GetClassLoader().LoadClass(name, mode | LoadMode.WarnClassNotFound);
#if !STATIC_COMPILER && !FIRST_PASS
					if(!tw.IsUnloadable)
					{
						try
						{
							thisType.GetClassLoader().CheckPackageAccess(tw, thisType.ClassObject.pd);
						}
						catch(java.lang.SecurityException)
						{
							tw = new UnloadableTypeWrapper(name);
						}
					}
#endif
					typeWrapper = tw;
				}
			}

			internal string Name
			{
				get
				{
					return name;
				}
			}

			internal TypeWrapper GetClassType()
			{
				return typeWrapper;
			}

			internal override ConstantType GetConstantType()
			{
				return ConstantType.Class;
			}

			public sealed override int GetHashCode()
			{
				return name.GetHashCode();
			}

			public bool Equals(ConstantPoolItemClass other)
			{
				return ReferenceEquals(name, other.name);
			}
		}

		private sealed class ConstantPoolItemDouble : ConstantPoolItem
		{
			internal double d;

			internal ConstantPoolItemDouble(BigEndianBinaryReader br)
			{
				d = br.ReadDouble();
			}

			internal override ConstantType GetConstantType()
			{
				return ConstantType.Double;
			}

			internal double Value
			{
				get
				{
					return d;
				}
			}

			internal override object GetRuntimeValue()
			{
				return d;
			}
		}

		internal abstract class ConstantPoolItemFMI : ConstantPoolItem
		{
			private ushort class_index;
			private ushort name_and_type_index;
			private ConstantPoolItemClass clazz;
			private string name;
			private string descriptor;

			internal ConstantPoolItemFMI(BigEndianBinaryReader br)
			{
				class_index = br.ReadUInt16();
				name_and_type_index = br.ReadUInt16();
			}

			internal override void Resolve(ClassFile classFile, string[] utf8_cp, ClassFileParseOptions options)
			{
				ConstantPoolItemNameAndType name_and_type = (ConstantPoolItemNameAndType)classFile.GetConstantPoolItem(name_and_type_index);
				clazz = (ConstantPoolItemClass)classFile.GetConstantPoolItem(class_index);
				// if the constant pool items referred to were strings, GetConstantPoolItem returns null
				if(name_and_type == null || clazz == null)
				{
					throw new ClassFormatError("Bad index in constant pool");
				}
				name = String.Intern(classFile.GetConstantPoolUtf8String(utf8_cp, name_and_type.name_index));
				descriptor = classFile.GetConstantPoolUtf8String(utf8_cp, name_and_type.descriptor_index);
				Validate(name, descriptor, classFile.MajorVersion);
				descriptor = String.Intern(descriptor.Replace('/', '.'));
			}

			protected abstract void Validate(string name, string descriptor, int majorVersion);

			internal override void MarkLinkRequired()
			{
				clazz.MarkLinkRequired();
			}

			internal override void Link(TypeWrapper thisType, LoadMode mode)
			{
				clazz.Link(thisType, mode);
			}

			internal string Name
			{
				get
				{
					return name;
				}
			}

			internal string Signature
			{
				get
				{
					return descriptor;
				}
			}

			internal string Class
			{
				get
				{
					return clazz.Name;
				}
			}

			internal TypeWrapper GetClassType()
			{
				return clazz.GetClassType();
			}

			internal abstract MemberWrapper GetMember();
		}

		internal sealed class ConstantPoolItemFieldref : ConstantPoolItemFMI
		{
			private FieldWrapper field;
			private TypeWrapper fieldTypeWrapper;

			internal ConstantPoolItemFieldref(BigEndianBinaryReader br) : base(br)
			{
			}

			protected override void Validate(string name, string descriptor, int majorVersion)
			{
				if(!IsValidFieldSig(descriptor))
				{
					throw new ClassFormatError("Invalid field signature \"{0}\"", descriptor);
				}
				if(!IsValidFieldName(name, majorVersion))
				{
					throw new ClassFormatError("Invalid field name \"{0}\"", name);
				}
			}

			internal TypeWrapper GetFieldType()
			{
				return fieldTypeWrapper;
			}

			internal override void Link(TypeWrapper thisType, LoadMode mode)
			{
				base.Link(thisType, mode);
				lock(this)
				{
					if(fieldTypeWrapper != null)
					{
						return;
					}
				}
				FieldWrapper fw = null;
				TypeWrapper wrapper = GetClassType();
				if(wrapper == null)
				{
					return;
				}
				if(!wrapper.IsUnloadable)
				{
					fw = wrapper.GetFieldWrapper(Name, Signature);
					if(fw != null)
					{
						fw.Link(mode);
					}
				}
				ClassLoaderWrapper classLoader = thisType.GetClassLoader();
				TypeWrapper fld = classLoader.FieldTypeWrapperFromSig(this.Signature, mode);
				lock(this)
				{
					if(fieldTypeWrapper == null)
					{
						fieldTypeWrapper = fld;
						field = fw;
					}
				}
			}

			internal FieldWrapper GetField()
			{
				return field;
			}

			internal override MemberWrapper GetMember()
			{
				return field;
			}
		}

		internal class ConstantPoolItemMI : ConstantPoolItemFMI
		{
			private TypeWrapper[] argTypeWrappers;
			private TypeWrapper retTypeWrapper;
			protected MethodWrapper method;
			protected MethodWrapper invokespecialMethod;

			internal ConstantPoolItemMI(BigEndianBinaryReader br) : base(br)
			{
			}

			protected override void Validate(string name, string descriptor, int majorVersion)
			{
				if(!IsValidMethodSig(descriptor))
				{
					throw new ClassFormatError("Method {0} has invalid signature {1}", name, descriptor);
				}
				if(!IsValidMethodName(name, majorVersion))
				{
					if(!ReferenceEquals(name, StringConstants.INIT))
					{
						throw new ClassFormatError("Invalid method name \"{0}\"", name);
					}
					if(!descriptor.EndsWith("V"))
					{
						throw new ClassFormatError("Method {0} has invalid signature {1}", name, descriptor);
					}
				}
			}

			internal override void Link(TypeWrapper thisType, LoadMode mode)
			{
				base.Link(thisType, mode);
				lock(this)
				{
					if(argTypeWrappers != null)
					{
						return;
					}
				}
				ClassLoaderWrapper classLoader = thisType.GetClassLoader();
				TypeWrapper[] args = classLoader.ArgTypeWrapperListFromSig(this.Signature, mode);
				TypeWrapper ret = classLoader.RetTypeWrapperFromSig(this.Signature, mode);
				lock(this)
				{
					if(argTypeWrappers == null)
					{
						argTypeWrappers = args;
						retTypeWrapper = ret;
					}
				}
			}

			internal TypeWrapper[] GetArgTypes()
			{
				return argTypeWrappers;
			}

			internal TypeWrapper GetRetType()
			{
				return retTypeWrapper;
			}

			internal MethodWrapper GetMethod()
			{
				return method;
			}

			internal MethodWrapper GetMethodForInvokespecial()
			{
				return invokespecialMethod != null ? invokespecialMethod : method;
			}

			internal override MemberWrapper GetMember()
			{
				return method;
			}
		}

		internal sealed class ConstantPoolItemMethodref : ConstantPoolItemMI
		{
			internal ConstantPoolItemMethodref(BigEndianBinaryReader br) : base(br)
			{
			}

			internal override void Link(TypeWrapper thisType, LoadMode mode)
			{
				base.Link(thisType, mode);
				TypeWrapper wrapper = GetClassType();
				if(wrapper != null && !wrapper.IsUnloadable)
				{
					method = wrapper.GetMethodWrapper(Name, Signature, !ReferenceEquals(Name, StringConstants.INIT));
					if(method != null)
					{
						method.Link(mode);
					}
					if(Name != StringConstants.INIT
						&& !thisType.IsInterface
						&& (!JVM.AllowNonVirtualCalls || (thisType.Modifiers & Modifiers.Super) == Modifiers.Super)
						&& thisType != wrapper
						&& thisType.IsSubTypeOf(wrapper))
					{
						invokespecialMethod = thisType.BaseTypeWrapper.GetMethodWrapper(Name, Signature, true);
						if(invokespecialMethod != null)
						{
							invokespecialMethod.Link(mode);
						}
					}
				}
			}
		}

		internal sealed class ConstantPoolItemInterfaceMethodref : ConstantPoolItemMI
		{
			internal ConstantPoolItemInterfaceMethodref(BigEndianBinaryReader br) : base(br)
			{
			}

			internal override void Link(TypeWrapper thisType, LoadMode mode)
			{
				base.Link(thisType, mode);
				TypeWrapper wrapper = GetClassType();
				if(wrapper != null)
				{
					if(!wrapper.IsUnloadable)
					{
						method = wrapper.GetInterfaceMethod(Name, Signature);
					}
					if(method == null)
					{
						// NOTE vmspec 5.4.3.4 clearly states that an interfacemethod may also refer to a method in Object
						method = CoreClasses.java.lang.Object.Wrapper.GetMethodWrapper(Name, Signature, false);
					}
					if(method != null)
					{
						method.Link(mode);
					}
				}
			}
		}

		private sealed class ConstantPoolItemFloat : ConstantPoolItem
		{
			internal float v;

			internal ConstantPoolItemFloat(BigEndianBinaryReader br)
			{
				v = br.ReadSingle();
			}

			internal override ConstantType GetConstantType()
			{
				return ConstantType.Float;
			}

			internal float Value
			{
				get
				{
					return v;
				}
			}

			internal override object GetRuntimeValue()
			{
				return v;
			}
		}

		private sealed class ConstantPoolItemInteger : ConstantPoolItem
		{
			internal int v;

			internal ConstantPoolItemInteger(BigEndianBinaryReader br)
			{
				v = br.ReadInt32();
			}

			internal override ConstantType GetConstantType()
			{
				return ConstantType.Integer;
			}

			internal int Value
			{
				get
				{
					return v;
				}
			}

			internal override object GetRuntimeValue()
			{
				return v;
			}
		}

		private sealed class ConstantPoolItemLong : ConstantPoolItem
		{
			internal long l;

			internal ConstantPoolItemLong(BigEndianBinaryReader br)
			{
				l = br.ReadInt64();
			}

			internal override ConstantType GetConstantType()
			{
				return ConstantType.Long;
			}

			internal long Value
			{
				get
				{
					return l;
				}
			}

			internal override object GetRuntimeValue()
			{
				return l;
			}
		}

		private sealed class ConstantPoolItemNameAndType : ConstantPoolItem
		{
			internal ushort name_index;
			internal ushort descriptor_index;

			internal ConstantPoolItemNameAndType(BigEndianBinaryReader br)
			{
				name_index = br.ReadUInt16();
				descriptor_index = br.ReadUInt16();
			}

			internal override void Resolve(ClassFile classFile, string[] utf8_cp, ClassFileParseOptions options)
			{
				if(classFile.GetConstantPoolUtf8String(utf8_cp, name_index) == null
					|| classFile.GetConstantPoolUtf8String(utf8_cp, descriptor_index) == null)
				{
					throw new ClassFormatError("Illegal constant pool index");
				}
			}
		}

		internal sealed class ConstantPoolItemMethodHandle : ConstantPoolItem
		{
			private byte ref_kind;
			private ushort method_index;
			private ConstantPoolItemFMI cpi;

			internal ConstantPoolItemMethodHandle(BigEndianBinaryReader br)
			{
				ref_kind = br.ReadByte();
				method_index = br.ReadUInt16();
			}

			internal override void Resolve(ClassFile classFile, string[] utf8_cp, ClassFileParseOptions options)
			{
				switch ((RefKind)ref_kind)
				{
					case RefKind.getField:
					case RefKind.getStatic:
					case RefKind.putField:
					case RefKind.putStatic:
						cpi = classFile.GetConstantPoolItem(method_index) as ConstantPoolItemFieldref;
						break;
					case RefKind.invokeSpecial:
					case RefKind.invokeVirtual:
					case RefKind.invokeStatic:
					case RefKind.newInvokeSpecial:
						cpi = classFile.GetConstantPoolItem(method_index) as ConstantPoolItemMethodref;
						if (cpi == null && classFile.MajorVersion >= 52 && ((RefKind)ref_kind == RefKind.invokeStatic || (RefKind)ref_kind == RefKind.invokeSpecial))
							goto case RefKind.invokeInterface;
						break;
					case RefKind.invokeInterface:
						cpi = classFile.GetConstantPoolItem(method_index) as ConstantPoolItemInterfaceMethodref;
						break;
				}
				if (cpi == null)
				{
					throw new ClassFormatError("Invalid constant pool item MethodHandle");
				}
				if (ReferenceEquals(cpi.Name, StringConstants.INIT) && Kind != RefKind.newInvokeSpecial)
				{
					throw new ClassFormatError("Bad method name");
				}
			}

			internal override void MarkLinkRequired()
			{
				cpi.MarkLinkRequired();
			}

			internal string Class
			{
				get { return cpi.Class; }
			}

			internal string Name
			{
				get { return cpi.Name; }
			}

			internal string Signature
			{
				get { return cpi.Signature; }
			}

			internal ConstantPoolItemFMI MemberConstantPoolItem
			{
				get { return cpi; }
			}

			internal RefKind Kind
			{
				get { return (RefKind)ref_kind; }
			}

			internal MemberWrapper Member
			{
				get { return cpi.GetMember(); }
			}

			internal TypeWrapper GetClassType()
			{
				return cpi.GetClassType();
			}

			internal override void Link(TypeWrapper thisType, LoadMode mode)
			{
				cpi.Link(thisType, mode);
			}

			internal override ConstantType GetConstantType()
			{
				return ConstantType.MethodHandle;
			}
		}

		internal sealed class ConstantPoolItemMethodType : ConstantPoolItem
		{
			private ushort signature_index;
			private string descriptor;
			private TypeWrapper[] argTypeWrappers;
			private TypeWrapper retTypeWrapper;

			internal ConstantPoolItemMethodType(BigEndianBinaryReader br)
			{
				signature_index = br.ReadUInt16();
			}

			internal override void Resolve(ClassFile classFile, string[] utf8_cp, ClassFileParseOptions options)
			{
				string descriptor = classFile.GetConstantPoolUtf8String(utf8_cp, signature_index);
				if (descriptor == null || !IsValidMethodSig(descriptor))
				{
					throw new ClassFormatError("Invalid MethodType signature");
				}
				this.descriptor = String.Intern(descriptor.Replace('/', '.'));
			}

			internal override void Link(TypeWrapper thisType, LoadMode mode)
			{
				lock (this)
				{
					if (argTypeWrappers != null)
					{
						return;
					}
				}
				ClassLoaderWrapper classLoader = thisType.GetClassLoader();
				TypeWrapper[] args = classLoader.ArgTypeWrapperListFromSig(descriptor, mode);
				TypeWrapper ret = classLoader.RetTypeWrapperFromSig(descriptor, mode);
				lock (this)
				{
					if (argTypeWrappers == null)
					{
						argTypeWrappers = args;
						retTypeWrapper = ret;
					}
				}
			}

			internal string Signature
			{
				get { return descriptor; }
			}

			internal TypeWrapper[] GetArgTypes()
			{
				return argTypeWrappers;
			}

			internal TypeWrapper GetRetType()
			{
				return retTypeWrapper;
			}

			internal override ConstantType GetConstantType()
			{
				return ConstantType.MethodType;
			}
		}

		internal sealed class ConstantPoolItemInvokeDynamic : ConstantPoolItem
		{
			private ushort bootstrap_specifier_index;
			private ushort name_and_type_index;
			private string name;
			private string descriptor;
			private TypeWrapper[] argTypeWrappers;
			private TypeWrapper retTypeWrapper;

			internal ConstantPoolItemInvokeDynamic(BigEndianBinaryReader br)
			{
				bootstrap_specifier_index = br.ReadUInt16();
				name_and_type_index = br.ReadUInt16();
			}

			internal override void Resolve(ClassFile classFile, string[] utf8_cp, ClassFileParseOptions options)
			{
				ConstantPoolItemNameAndType name_and_type = (ConstantPoolItemNameAndType)classFile.GetConstantPoolItem(name_and_type_index);
				// if the constant pool items referred to were strings, GetConstantPoolItem returns null
				if (name_and_type == null)
				{
					throw new ClassFormatError("Bad index in constant pool");
				}
				name = String.Intern(classFile.GetConstantPoolUtf8String(utf8_cp, name_and_type.name_index));
				descriptor = String.Intern(classFile.GetConstantPoolUtf8String(utf8_cp, name_and_type.descriptor_index).Replace('/', '.'));
			}

			internal override void Link(TypeWrapper thisType, LoadMode mode)
			{
				lock (this)
				{
					if (argTypeWrappers != null)
					{
						return;
					}
				}
				ClassLoaderWrapper classLoader = thisType.GetClassLoader();
				TypeWrapper[] args = classLoader.ArgTypeWrapperListFromSig(descriptor, mode);
				TypeWrapper ret = classLoader.RetTypeWrapperFromSig(descriptor, mode);
				lock (this)
				{
					if (argTypeWrappers == null)
					{
						argTypeWrappers = args;
						retTypeWrapper = ret;
					}
				}
			}

			internal TypeWrapper[] GetArgTypes()
			{
				return argTypeWrappers;
			}

			internal TypeWrapper GetRetType()
			{
				return retTypeWrapper;
			}

			internal string Name
			{
				get { return name; }
			}

			internal string Signature
			{
				get { return descriptor; }
			}

			internal ushort BootstrapMethod
			{
				get { return bootstrap_specifier_index; }
			}
		}

		private sealed class ConstantPoolItemString : ConstantPoolItem
		{
			private ushort string_index;
			private string s;

			internal ConstantPoolItemString(BigEndianBinaryReader br)
			{
				string_index = br.ReadUInt16();
			}

			internal override void Resolve(ClassFile classFile, string[] utf8_cp, ClassFileParseOptions options)
			{
				s = classFile.GetConstantPoolUtf8String(utf8_cp, string_index);
			}

			internal override ConstantType GetConstantType()
			{
				return ConstantType.String;
			}

			internal string Value
			{
				get
				{
					return s;
				}
			}
		}

		// this is only used to copy strings into "constantpool" when we see a RuntimeVisibleTypeAnnotations attribute,
		// because we need a consistent way of exposing constant pool items to the runtime and that case
		private sealed class ConstantPoolItemUtf8 : ConstantPoolItem
		{
			private readonly string str;

			internal ConstantPoolItemUtf8(string str)
			{
				this.str = str;
			}

			internal override object GetRuntimeValue()
			{
				return str;
			}
		}

		private sealed class ConstantPoolItemLiveObject : ConstantPoolItem
		{
			internal readonly object Value;

			internal ConstantPoolItemLiveObject(object value)
			{
				this.Value = value;
			}

			internal override ConstantType GetConstantType()
			{
				return ConstantType.LiveObject;
			}
		}

		internal enum Constant
		{
			Utf8 = 1,
			Integer = 3,
			Float = 4,
			Long = 5,
			Double = 6,
			Class = 7,
			String = 8,
			Fieldref = 9,
			Methodref = 10,
			InterfaceMethodref = 11,
			NameAndType = 12,
			MethodHandle = 15,
			MethodType = 16,
			InvokeDynamic = 18,
		}

		internal abstract class FieldOrMethod : IEquatable<FieldOrMethod>
		{
			// Note that Modifiers is a ushort, so it combines nicely with the following ushort field
			protected Modifiers access_flags;
			protected ushort flags;
			private string name;
			private string descriptor;
			protected string signature;
			protected object[] annotations;
			protected byte[] runtimeVisibleTypeAnnotations;

			internal FieldOrMethod(ClassFile classFile, string[] utf8_cp, BigEndianBinaryReader br)
			{
				access_flags = (Modifiers)br.ReadUInt16();
				name = String.Intern(classFile.GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16()));
				descriptor = classFile.GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16());
				ValidateSig(classFile, descriptor);
				descriptor = String.Intern(descriptor.Replace('/', '.'));
			}

			protected abstract void ValidateSig(ClassFile classFile, string descriptor);

			internal string Name
			{
				get
				{
					return name;
				}
			}

			internal string Signature
			{
				get
				{
					return descriptor;
				}
			}

			internal object[] Annotations
			{
				get
				{
					return annotations;
				}
			}

			internal string GenericSignature
			{
				get
				{
					return signature;
				}
			}

			internal Modifiers Modifiers
			{
				get
				{
					return (Modifiers)access_flags;
				}
			}

			internal bool IsAbstract
			{
				get
				{
					return (access_flags & Modifiers.Abstract) != 0;
				}
			}

			internal bool IsFinal
			{
				get
				{
					return (access_flags & Modifiers.Final) != 0;
				}
			}

			internal bool IsPublic
			{
				get
				{
					return (access_flags & Modifiers.Public) != 0;
				}
			}

			internal bool IsPrivate
			{
				get
				{
					return (access_flags & Modifiers.Private) != 0;
				}
			}

			internal bool IsProtected
			{
				get
				{
					return (access_flags & Modifiers.Protected) != 0;
				}
			}

			internal bool IsStatic
			{
				get
				{
					return (access_flags & Modifiers.Static) != 0;
				}
			}

			internal bool IsSynchronized
			{
				get
				{
					return (access_flags & Modifiers.Synchronized) != 0;
				}
			}

			internal bool IsVolatile
			{
				get
				{
					return (access_flags & Modifiers.Volatile) != 0;
				}
			}

			internal bool IsTransient
			{
				get
				{
					return (access_flags & Modifiers.Transient) != 0;
				}
			}

			internal bool IsNative
			{
				get
				{
					return (access_flags & Modifiers.Native) != 0;
				}
			}

			internal bool IsEnum
			{
				get
				{
					return (access_flags & Modifiers.Enum) != 0;
				}
			}

			internal bool DeprecatedAttribute
			{
				get
				{
					return (flags & FLAG_MASK_DEPRECATED) != 0;
				}
			}

			internal bool IsInternal
			{
				get
				{
					return (flags & FLAG_MASK_INTERNAL) != 0;
				}
			}

			internal byte[] RuntimeVisibleTypeAnnotations
			{
				get
				{
					return runtimeVisibleTypeAnnotations;
				}
			}

			public sealed override int GetHashCode()
			{
				return name.GetHashCode() ^ descriptor.GetHashCode();
			}

			public bool Equals(FieldOrMethod other)
			{
				return ReferenceEquals(name, other.name) && ReferenceEquals(descriptor, other.descriptor);
			}
		}

		internal sealed class Field : FieldOrMethod
		{
			private object constantValue;
			private string[] propertyGetterSetter;

			internal Field(ClassFile classFile, string[] utf8_cp, BigEndianBinaryReader br) : base(classFile, utf8_cp, br)
			{
				if((IsPrivate && IsPublic) || (IsPrivate && IsProtected) || (IsPublic && IsProtected)
					|| (IsFinal && IsVolatile)
					|| (classFile.IsInterface && (!IsPublic || !IsStatic || !IsFinal || IsTransient)))
				{
					throw new ClassFormatError("{0} (Illegal field modifiers: 0x{1:X})", classFile.Name, access_flags);
				}
				int attributes_count = br.ReadUInt16();
				for(int i = 0; i < attributes_count; i++)
				{
					switch(classFile.GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16()))
					{
						case "Deprecated":
							if(br.ReadUInt32() != 0)
							{
								throw new ClassFormatError("Invalid Deprecated attribute length");
							}
							flags |= FLAG_MASK_DEPRECATED;
							break;
						case "ConstantValue":
						{
							if(br.ReadUInt32() != 2)
							{
								throw new ClassFormatError("Invalid ConstantValue attribute length");
							}
							ushort index = br.ReadUInt16();
							try
							{
								switch(Signature)
								{
									case "I":
										constantValue = classFile.GetConstantPoolConstantInteger(index);
										break;
									case "S":
										constantValue = (short)classFile.GetConstantPoolConstantInteger(index);
										break;
									case "B":
										constantValue = (byte)classFile.GetConstantPoolConstantInteger(index);
										break;
									case "C":
										constantValue = (char)classFile.GetConstantPoolConstantInteger(index);
										break;
									case "Z":
										constantValue = classFile.GetConstantPoolConstantInteger(index) != 0;
										break;
									case "J":
										constantValue = classFile.GetConstantPoolConstantLong(index);
										break;
									case "F":
										constantValue = classFile.GetConstantPoolConstantFloat(index);
										break;
									case "D":
										constantValue = classFile.GetConstantPoolConstantDouble(index);
										break;
									case "Ljava.lang.String;":
										constantValue = classFile.GetConstantPoolConstantString(index);
										break;
									default:
										throw new ClassFormatError("{0} (Invalid signature for constant)", classFile.Name);
								}
							}
							catch(InvalidCastException)
							{
								throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
							}
							catch(IndexOutOfRangeException)
							{
								throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
							}
							catch(InvalidOperationException)
							{
								throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
							}
							catch(NullReferenceException)
							{
								throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
							}
							break;
						}
						case "Signature":
							if(classFile.MajorVersion < 49)
							{
								goto default;
							}
							if(br.ReadUInt32() != 2)
							{
								throw new ClassFormatError("Signature attribute has incorrect length");
							}
							signature = classFile.GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16());
							break;
						case "RuntimeVisibleAnnotations":
							if(classFile.MajorVersion < 49)
							{
								goto default;
							}
							annotations = ReadAnnotations(br, classFile, utf8_cp);
							break;
						case "RuntimeInvisibleAnnotations":
							if(classFile.MajorVersion < 49)
							{
								goto default;
							}
							foreach(object[] annot in ReadAnnotations(br, classFile, utf8_cp))
							{
								if(annot[1].Equals("Likvm/lang/Property;"))
								{
									DecodePropertyAnnotation(classFile, annot);
								}
#if STATIC_COMPILER
								else if(annot[1].Equals("Likvm/lang/Internal;"))
								{
									this.access_flags &= ~Modifiers.AccessMask;
									flags |= FLAG_MASK_INTERNAL;
								}
#endif
							}
							break;
						case "RuntimeVisibleTypeAnnotations":
							if (classFile.MajorVersion < 52)
							{
								goto default;
							}
							classFile.CreateUtf8ConstantPoolItems(utf8_cp);
							runtimeVisibleTypeAnnotations = br.Section(br.ReadUInt32()).ToArray();
							break;
						default:
							br.Skip(br.ReadUInt32());
							break;
					}
				}
			}

			private void DecodePropertyAnnotation(ClassFile classFile, object[] annot)
			{
				if(propertyGetterSetter != null)
				{
					Tracer.Error(Tracer.ClassLoading, "Ignoring duplicate ikvm.lang.Property annotation on {0}.{1}", classFile.Name, this.Name);
					return;
				}
				propertyGetterSetter = new string[2];
				for(int i = 2; i < annot.Length - 1; i += 2)
				{
					string value = annot[i + 1] as string;
					if(value == null)
					{
						propertyGetterSetter = null;
						break;
					}
					if(annot[i].Equals("get") && propertyGetterSetter[0] == null)
					{
						propertyGetterSetter[0] = value;
					}
					else if(annot[i].Equals("set") && propertyGetterSetter[1] == null)
					{
						propertyGetterSetter[1] = value;
					}
					else
					{
						propertyGetterSetter = null;
						break;
					}
				}
				if(propertyGetterSetter == null || propertyGetterSetter[0] == null)
				{
					propertyGetterSetter = null;
					Tracer.Error(Tracer.ClassLoading, "Ignoring malformed ikvm.lang.Property annotation on {0}.{1}", classFile.Name, this.Name);
					return;
				}
			}

			protected override void ValidateSig(ClassFile classFile, string descriptor)
			{
				if(!IsValidFieldSig(descriptor))
				{
					throw new ClassFormatError("{0} (Field \"{1}\" has invalid signature \"{2}\")", classFile.Name, this.Name, descriptor);
				}
			}

			internal object ConstantValue
			{
				get
				{
					return constantValue;
				}
			}

			internal void PatchConstantValue(object value)
			{
				constantValue = value;
			}

			internal bool IsStaticFinalConstant
			{
				get { return (access_flags & (Modifiers.Final | Modifiers.Static)) == (Modifiers.Final | Modifiers.Static) && constantValue != null; }
			}

			internal bool IsProperty
			{
				get
				{
					return propertyGetterSetter != null;
				}
			}

			internal string PropertyGetter
			{
				get
				{
					return propertyGetterSetter[0];
				}
			}

			internal string PropertySetter
			{
				get
				{
					return propertyGetterSetter[1];
				}
			}
		}

		internal sealed class Method : FieldOrMethod
		{
			private Code code;
			private string[] exceptions;
			private LowFreqData low;
			private MethodParametersEntry[] parameters;

			sealed class LowFreqData
			{
				internal object annotationDefault;
				internal object[][] parameterAnnotations;
#if STATIC_COMPILER
				internal string DllExportName;
				internal int DllExportOrdinal;
				internal string InterlockedCompareAndSetField;
#endif
			}

			internal Method(ClassFile classFile, string[] utf8_cp, ClassFileParseOptions options, BigEndianBinaryReader br) : base(classFile, utf8_cp, br)
			{
				// vmspec 4.6 says that all flags, except ACC_STRICT are ignored on <clinit>
				// however, since Java 7 it does need to be marked static
				if(ReferenceEquals(Name, StringConstants.CLINIT) && ReferenceEquals(Signature, StringConstants.SIG_VOID) && (classFile.MajorVersion < 51 || IsStatic))
				{
					access_flags &= Modifiers.Strictfp;
					access_flags |= (Modifiers.Static | Modifiers.Private);
				}
				else
				{
					// LAMESPEC: vmspec 4.6 says that abstract methods can not be strictfp (and this makes sense), but
					// javac (pre 1.5) is broken and marks abstract methods as strictfp (if you put the strictfp on the class)
					if((ReferenceEquals(Name, StringConstants.INIT) && (IsStatic || IsSynchronized || IsFinal || IsAbstract || IsNative))
						|| (IsPrivate && IsPublic) || (IsPrivate && IsProtected) || (IsPublic && IsProtected)
						|| (IsAbstract && (IsFinal || IsNative || IsPrivate || IsStatic || IsSynchronized))
						|| (classFile.IsInterface && classFile.MajorVersion <= 51 && (!IsPublic || IsFinal || IsNative || IsSynchronized || !IsAbstract))
						|| (classFile.IsInterface && classFile.MajorVersion >= 52 && (!(IsPublic || IsPrivate) || IsFinal || IsNative || IsSynchronized)))
					{
						throw new ClassFormatError("Method {0} in class {1} has illegal modifiers: 0x{2:X}", Name, classFile.Name, (int)access_flags);
					}
				}
				int attributes_count = br.ReadUInt16();
				for(int i = 0; i < attributes_count; i++)
				{
					switch(classFile.GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16()))
					{
						case "Deprecated":
							if(br.ReadUInt32() != 0)
							{
								throw new ClassFormatError("Invalid Deprecated attribute length");
							}
							flags |= FLAG_MASK_DEPRECATED;
							break;
						case "Code":
						{
							if(!code.IsEmpty)
							{
								throw new ClassFormatError("{0} (Duplicate Code attribute)", classFile.Name);
							}
							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
							code.Read(classFile, utf8_cp, this, rdr, options);
							if(!rdr.IsAtEnd)
							{
								throw new ClassFormatError("{0} (Code attribute has wrong length)", classFile.Name);
							}
							break;
						}
						case "Exceptions":
						{
							if(exceptions != null)
							{
								throw new ClassFormatError("{0} (Duplicate Exceptions attribute)", classFile.Name);
							}
							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
							ushort count = rdr.ReadUInt16();
							exceptions = new string[count];
							for(int j = 0; j < count; j++)
							{
								exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());
							}
							if(!rdr.IsAtEnd)
							{
								throw new ClassFormatError("{0} (Exceptions attribute has wrong length)", classFile.Name);
							}
							break;
						}
						case "Signature":
							if(classFile.MajorVersion < 49)
							{
								goto default;
							}
							if(br.ReadUInt32() != 2)
							{
								throw new ClassFormatError("Signature attribute has incorrect length");
							}
							signature = classFile.GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16());
							break;
						case "RuntimeVisibleAnnotations":
							if(classFile.MajorVersion < 49)
							{
								goto default;
							}
							annotations = ReadAnnotations(br, classFile, utf8_cp);
							if ((options & ClassFileParseOptions.TrustedAnnotations) != 0)
							{
								foreach(object[] annot in annotations)
								{
									switch((string)annot[1])
									{
#if STATIC_COMPILER
										case "Lsun/reflect/CallerSensitive;":
											flags |= FLAG_CALLERSENSITIVE;
											break;
#endif
										case "Ljava/lang/invoke/LambdaForm$Compiled;":
											flags |= FLAG_LAMBDAFORM_COMPILED;
											break;
										case "Ljava/lang/invoke/LambdaForm$Hidden;":
											flags |= FLAG_LAMBDAFORM_HIDDEN;
											break;
										case "Ljava/lang/invoke/ForceInline;":
											flags |= FLAG_FORCEINLINE;
											break;
									}
								}
							}
							break;
						case "RuntimeVisibleParameterAnnotations":
						{
							if(classFile.MajorVersion < 49)
							{
								goto default;
							}
							if(low == null)
							{
								low = new LowFreqData();
							}
							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
							byte num_parameters = rdr.ReadByte();
							low.parameterAnnotations = new object[num_parameters][];
							for(int j = 0; j < num_parameters; j++)
							{
								ushort num_annotations = rdr.ReadUInt16();
								low.parameterAnnotations[j] = new object[num_annotations];
								for(int k = 0; k < num_annotations; k++)
								{
									low.parameterAnnotations[j][k] = ReadAnnotation(rdr, classFile, utf8_cp);
								}
							}
							if(!rdr.IsAtEnd)
							{
								throw new ClassFormatError("{0} (RuntimeVisibleParameterAnnotations attribute has wrong length)", classFile.Name);
							}
							break;
						}
						case "AnnotationDefault":
						{
							if(classFile.MajorVersion < 49)
							{
								goto default;
							}
							if(low == null)
							{
								low = new LowFreqData();
							}
							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
							low.annotationDefault = ReadAnnotationElementValue(rdr, classFile, utf8_cp);
							if(!rdr.IsAtEnd)
							{
								throw new ClassFormatError("{0} (AnnotationDefault attribute has wrong length)", classFile.Name);
							}
							break;
						}
#if STATIC_COMPILER
						case "RuntimeInvisibleAnnotations":
							if(classFile.MajorVersion < 49)
							{
								goto default;
							}
							foreach(object[] annot in ReadAnnotations(br, classFile, utf8_cp))
							{
								if(annot[1].Equals("Likvm/lang/Internal;"))
								{
									if (classFile.IsInterface)
									{
										StaticCompiler.IssueMessage(Message.InterfaceMethodCantBeInternal, classFile.Name, this.Name, this.Signature);
									}
									else
									{
										this.access_flags &= ~Modifiers.AccessMask;
										flags |= FLAG_MASK_INTERNAL;
									}
								}
								if(annot[1].Equals("Likvm/lang/DllExport;"))
								{
									string name = null;
									int? ordinal = null;
									for (int j = 2; j < annot.Length; j += 2)
									{
										if (annot[j].Equals("name") && annot[j + 1] is string)
										{
											name = (string)annot[j + 1];
										}
										else if (annot[j].Equals("ordinal") && annot[j + 1] is int)
										{
											ordinal = (int)annot[j + 1];
										}
									}
									if (name != null && ordinal != null)
									{
										if (!IsStatic)
										{
											StaticCompiler.IssueMessage(Message.DllExportMustBeStaticMethod, classFile.Name, this.Name, this.Signature);
										}
										else
										{
											if (low == null)
											{
												low = new LowFreqData();
											}
											low.DllExportName = name;
											low.DllExportOrdinal = ordinal.Value;
										}
									}
								}
								if(annot[1].Equals("Likvm/internal/InterlockedCompareAndSet;"))
								{
									string field = null;
									for (int j = 2; j < annot.Length; j += 2)
									{
										if (annot[j].Equals("value") && annot[j + 1] is string)
										{
											field = (string)annot[j + 1];
										}
									}
									if (field != null)
									{
										if (low == null)
										{
											low = new LowFreqData();
										}
										low.InterlockedCompareAndSetField = field;
									}
								}
							}
							break;
#endif
						case "MethodParameters":
						{
							if(classFile.MajorVersion < 52)
							{
								goto default;
							}
							if(parameters != null)
							{
								throw new ClassFormatError("{0} (Duplicate MethodParameters attribute)", classFile.Name);
							}
							parameters = ReadMethodParameters(br, utf8_cp);
							break;
						}
						case "RuntimeVisibleTypeAnnotations":
							if (classFile.MajorVersion < 52)
							{
								goto default;
							}
							classFile.CreateUtf8ConstantPoolItems(utf8_cp);
							runtimeVisibleTypeAnnotations = br.Section(br.ReadUInt32()).ToArray();
							break;
						default:
							br.Skip(br.ReadUInt32());
							break;
					}
				}
				if(IsAbstract || IsNative)
				{
					if(!code.IsEmpty)
					{
						throw new ClassFormatError("Code attribute in native or abstract methods in class file " + classFile.Name);
					}
				}
				else
				{
					if(code.IsEmpty)
					{
						if(ReferenceEquals(this.Name, StringConstants.CLINIT))
						{
							code.verifyError = string.Format("Class {0}, method {1} signature {2}: No Code attribute", classFile.Name, this.Name, this.Signature);
							return;
						}
						throw new ClassFormatError("Absent Code attribute in method that is not native or abstract in class file " + classFile.Name);
					}
				}
			}

			private static MethodParametersEntry[] ReadMethodParameters(BigEndianBinaryReader br, string[] utf8_cp)
			{
				uint length = br.ReadUInt32();
				if(length > 0)
				{
					BigEndianBinaryReader rdr = br.Section(length);
					byte parameters_count = rdr.ReadByte();
					if(length == 1 + parameters_count * 4)
					{
						MethodParametersEntry[] parameters = new MethodParametersEntry[parameters_count];
						for(int j = 0; j < parameters_count; j++)
						{
							ushort name = rdr.ReadUInt16();
							if(name >= utf8_cp.Length || (name != 0 && utf8_cp[name] == null))
							{
								return MethodParametersEntry.Malformed;
							}
							parameters[j].name = utf8_cp[name];
							parameters[j].flags = rdr.ReadUInt16();
						}
						return parameters;
					}
				}
				throw new ClassFormatError("Invalid MethodParameters method attribute length " + length + " in class file");
			}

			protected override void ValidateSig(ClassFile classFile, string descriptor)
			{
				if(!IsValidMethodSig(descriptor))
				{
					throw new ClassFormatError("{0} (Method \"{1}\" has invalid signature \"{2}\")", classFile.Name, this.Name, descriptor);
				}
			}

			internal bool IsStrictfp
			{
				get
				{
					return (access_flags & Modifiers.Strictfp) != 0;
				}
			}

			internal bool IsVirtual
			{
				get
				{
					return (access_flags & (Modifiers.Static | Modifiers.Private)) == 0
						&& !IsConstructor;
				}
			}

			// Is this the <clinit>()V method?
			internal bool IsClassInitializer
			{
				get
				{
					return ReferenceEquals(Name, StringConstants.CLINIT) && ReferenceEquals(Signature, StringConstants.SIG_VOID) && IsStatic;
				}
			}

			internal bool IsConstructor
			{
				get
				{
					return ReferenceEquals(Name, StringConstants.INIT);
				}
			}

#if STATIC_COMPILER
			internal bool IsCallerSensitive
			{
				get
				{
					return (flags & FLAG_CALLERSENSITIVE) != 0;
				}
			}
#endif

			internal bool IsLambdaFormCompiled
			{
				get
				{
					return (flags & FLAG_LAMBDAFORM_COMPILED) != 0;
				}
			}

			internal bool IsLambdaFormHidden
			{
				get
				{
					return (flags & FLAG_LAMBDAFORM_HIDDEN) != 0;
				}
			}

			internal bool IsForceInline
			{
				get
				{
					return (flags & FLAG_FORCEINLINE) != 0;
				}
			}

			internal string[] ExceptionsAttribute
			{
				get
				{
					return exceptions;
				}
			}

			internal object[][] ParameterAnnotations
			{
				get
				{
					return low == null ? null : low.parameterAnnotations;
				}
			}

			internal object AnnotationDefault
			{
				get
				{
					return low == null ? null : low.annotationDefault;
				}
			}

#if STATIC_COMPILER
			internal string DllExportName
			{
				get
				{
					return low == null ? null : low.DllExportName;
				}
			}

			internal int DllExportOrdinal
			{
				get
				{
					return low == null ? -1 : low.DllExportOrdinal;
				}
			}

			internal string InterlockedCompareAndSetField
			{
				get
				{
					return low == null ? null : low.InterlockedCompareAndSetField;
				}
			}
#endif

			internal string VerifyError
			{
				get
				{
					return code.verifyError;
				}
			}

			// maps argument 'slot' (as encoded in the xload/xstore instructions) into the ordinal
			internal int[] ArgMap
			{
				get
				{
					return code.argmap;
				}
			}

			internal int MaxStack
			{
				get
				{
					return code.max_stack;
				}
			}

			internal int MaxLocals
			{
				get
				{
					return code.max_locals;
				}
			}

			internal Instruction[] Instructions
			{
				get
				{
					return code.instructions;
				}
				set
				{
					code.instructions = value;
				}
			}

			internal ExceptionTableEntry[] ExceptionTable
			{
				get
				{
					return code.exception_table;
				}
				set
				{
					code.exception_table = value;
				}
			}

			internal LineNumberTableEntry[] LineNumberTableAttribute
			{
				get
				{
					return code.lineNumberTable;
				}
			}

			internal LocalVariableTableEntry[] LocalVariableTableAttribute
			{
				get
				{
					return code.localVariableTable;
				}
			}

			internal MethodParametersEntry[] MethodParameters
			{
				get
				{
					return parameters;
				}
			}

			internal bool MalformedMethodParameters
			{
				get
				{
					return parameters == MethodParametersEntry.Malformed;
				}
			}

			internal bool HasJsr
			{
				get
				{
					return code.hasJsr;
				}
			}

			private struct Code
			{
				internal bool hasJsr;
				internal string verifyError;
				internal ushort max_stack;
				internal ushort max_locals;
				internal Instruction[] instructions;
				internal ExceptionTableEntry[] exception_table;
				internal int[] argmap;
				internal LineNumberTableEntry[] lineNumberTable;
				internal LocalVariableTableEntry[] localVariableTable;

				internal void Read(ClassFile classFile, string[] utf8_cp, Method method, BigEndianBinaryReader br, ClassFileParseOptions options)
				{
					max_stack = br.ReadUInt16();
					max_locals = br.ReadUInt16();
					uint code_length = br.ReadUInt32();
					if(code_length == 0 || code_length > 65535)
					{
						throw new ClassFormatError("Invalid method Code length {1} in class file {0}", classFile.Name, code_length);
					}
					Instruction[] instructions = new Instruction[code_length + 1];
					int basePosition = br.Position;
					int instructionIndex = 0;
					try
					{
						BigEndianBinaryReader rdr = br.Section(code_length);
						while(!rdr.IsAtEnd)
						{
							instructions[instructionIndex].Read((ushort)(rdr.Position - basePosition), rdr, classFile);
							hasJsr |= instructions[instructionIndex].NormalizedOpCode == NormalizedByteCode.__jsr;
							instructionIndex++;
						}
						// we add an additional nop instruction to make it easier for consumers of the code array
						instructions[instructionIndex++].SetTermNop((ushort)(rdr.Position - basePosition));
					}
					catch(ClassFormatError x)
					{
						// any class format errors in the code block are actually verify errors
						verifyError = x.Message;
					}
					this.instructions = new Instruction[instructionIndex];
					Array.Copy(instructions, 0, this.instructions, 0, instructionIndex);
					// build the pcIndexMap
					int[] pcIndexMap = new int[this.instructions[instructionIndex - 1].PC + 1];
					for(int i = 0; i < pcIndexMap.Length; i++)
					{
						pcIndexMap[i] = -1;
					}
					for(int i = 0; i < instructionIndex - 1; i++)
					{
						pcIndexMap[this.instructions[i].PC] = i;
					}
					// convert branch offsets to indexes
					for(int i = 0; i < instructionIndex - 1; i++)
					{
						switch(this.instructions[i].NormalizedOpCode)
						{
							case NormalizedByteCode.__ifeq:
							case NormalizedByteCode.__ifne:
							case NormalizedByteCode.__iflt:
							case NormalizedByteCode.__ifge:
							case NormalizedByteCode.__ifgt:
							case NormalizedByteCode.__ifle:
							case NormalizedByteCode.__if_icmpeq:
							case NormalizedByteCode.__if_icmpne:
							case NormalizedByteCode.__if_icmplt:
							case NormalizedByteCode.__if_icmpge:
							case NormalizedByteCode.__if_icmpgt:
							case NormalizedByteCode.__if_icmple:
							case NormalizedByteCode.__if_acmpeq:
							case NormalizedByteCode.__if_acmpne:
							case NormalizedByteCode.__ifnull:
							case NormalizedByteCode.__ifnonnull:
							case NormalizedByteCode.__goto:
							case NormalizedByteCode.__jsr:
								this.instructions[i].SetTargetIndex(pcIndexMap[this.instructions[i].Arg1 + this.instructions[i].PC]);
								break;
							case NormalizedByteCode.__tableswitch:
							case NormalizedByteCode.__lookupswitch:
								this.instructions[i].MapSwitchTargets(pcIndexMap);
								break;
						}
					}
					// read exception table
					ushort exception_table_length = br.ReadUInt16();
					exception_table = new ExceptionTableEntry[exception_table_length];
					for(int i = 0; i < exception_table_length; i++)
					{
						ushort start_pc = br.ReadUInt16();
						ushort end_pc = br.ReadUInt16();
						ushort handler_pc = br.ReadUInt16();
						ushort catch_type = br.ReadUInt16();
						if(start_pc >= end_pc
							|| end_pc > code_length
							|| handler_pc >= code_length
							|| (catch_type != 0 && !classFile.SafeIsConstantPoolClass(catch_type)))
						{
							throw new ClassFormatError("Illegal exception table: {0}.{1}{2}", classFile.Name, method.Name, method.Signature);
						}
						classFile.MarkLinkRequiredConstantPoolItem(catch_type);
						// if start_pc, end_pc or handler_pc is invalid (i.e. doesn't point to the start of an instruction),
						// the index will be -1 and this will be handled by the verifier
						int startIndex = pcIndexMap[start_pc];
						int endIndex;
						if (end_pc == code_length)
						{
							// it is legal for end_pc to point to just after the last instruction,
							// but since there isn't an entry in our pcIndexMap for that, we have
							// a special case for this
							endIndex = instructionIndex - 1;
						}
						else
						{
							endIndex = pcIndexMap[end_pc];
						}
						int handlerIndex = pcIndexMap[handler_pc];
						exception_table[i] = new ExceptionTableEntry(startIndex, endIndex, handlerIndex, catch_type, i);
					}
					ushort attributes_count = br.ReadUInt16();
					for(int i = 0; i < attributes_count; i++)
					{
						switch(classFile.GetConstantPoolUtf8String(utf8_cp, br.ReadUInt16()))
						{
							case "LineNumberTable":
								if((options & ClassFileParseOptions.LineNumberTable) != 0)
								{
									BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
									int count = rdr.ReadUInt16();
									lineNumberTable = new LineNumberTableEntry[count];
									for(int j = 0; j < count; j++)
									{
										lineNumberTable[j].start_pc = rdr.ReadUInt16();
										lineNumberTable[j].line_number = rdr.ReadUInt16();
										if(lineNumberTable[j].start_pc >= code_length)
										{
											throw new ClassFormatError("{0} (LineNumberTable has invalid pc)", classFile.Name);
										}
									}
									if(!rdr.IsAtEnd)
									{
										throw new ClassFormatError("{0} (LineNumberTable attribute has wrong length)", classFile.Name);
									}
								}
								else
								{
									br.Skip(br.ReadUInt32());
								}
								break;
							case "LocalVariableTable":
								if((options & ClassFileParseOptions.LocalVariableTable) != 0)
								{
									BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
									int count = rdr.ReadUInt16();
									localVariableTable = new LocalVariableTableEntry[count];
									for(int j = 0; j < count; j++)
									{
										localVariableTable[j].start_pc = rdr.ReadUInt16();
										localVariableTable[j].length = rdr.ReadUInt16();
										localVariableTable[j].name = classFile.GetConstantPoolUtf8String(utf8_cp, rdr.ReadUInt16());
										localVariableTable[j].descriptor = classFile.GetConstantPoolUtf8String(utf8_cp, rdr.ReadUInt16()).Replace('/', '.');
										localVariableTable[j].index = rdr.ReadUInt16();
									}
									// NOTE we're intentionally not checking that we're at the end of the section
									// (optional attributes shouldn't cause ClassFormatError)
								}
								else
								{
									br.Skip(br.ReadUInt32());
								}
								break;
							default:
								br.Skip(br.ReadUInt32());
								break;
						}
					}
					// build the argmap
					string sig = method.Signature;
					List<int> args = new List<int>();
					int pos = 0;
					if(!method.IsStatic)
					{
						args.Add(pos++);
					}
					for(int i = 1; sig[i] != ')'; i++)
					{
						args.Add(pos++);
						switch(sig[i])
						{
							case 'L':
								i = sig.IndexOf(';', i);
								break;
							case 'D':
							case 'J':
								args.Add(-1);
								break;
							case '[':
							{
								while(sig[i] == '[')
								{
									i++;
								}
								if(sig[i] == 'L')
								{
									i = sig.IndexOf(';', i);
								}
								break;
							}
						}
					}
					argmap = args.ToArray();
					if(args.Count > max_locals)
					{
						throw new ClassFormatError("{0} (Arguments can't fit into locals)", classFile.Name);
					}
				}

				internal bool IsEmpty
				{
					get
					{
						return instructions == null;
					}
				}
			}

			internal sealed class ExceptionTableEntry
			{
				internal readonly int startIndex;
				internal readonly int endIndex;
				internal readonly int handlerIndex;
				internal readonly ushort catch_type;
				internal readonly int ordinal;
				internal readonly bool isFinally;

				internal ExceptionTableEntry(int startIndex, int endIndex, int handlerIndex, ushort catch_type, int ordinal)
					: this(startIndex, endIndex, handlerIndex, catch_type, ordinal, false)
				{
				}

				internal ExceptionTableEntry(int startIndex, int endIndex, int handlerIndex, ushort catch_type, int ordinal, bool isFinally)
				{
					this.startIndex = startIndex;
					this.endIndex = endIndex;
					this.handlerIndex = handlerIndex;
					this.catch_type = catch_type;
					this.ordinal = ordinal;
					this.isFinally = isFinally;
				}
			}

			[Flags]
			internal enum InstructionFlags : byte
			{
				Reachable = 1,
				Processed = 2,
				BranchTarget = 4,
			}

			internal struct Instruction
			{
				private ushort pc;
				private NormalizedByteCode normopcode;
				private int arg1;
				private short arg2;
				private SwitchEntry[] switch_entries;

				struct SwitchEntry
				{
					internal int value;
					internal int target;
				}

				internal void SetHardError(HardError error, int messageId)
				{
					normopcode = NormalizedByteCode.__static_error;
					arg2 = (short)error;
					arg1 = messageId;
				}

				internal HardError HardError
				{
					get
					{
						return (HardError)arg2;
					}
				}

				internal int HandlerIndex
				{
					get { return (ushort)arg2; }
				}

				internal int HardErrorMessageId
				{
					get
					{
						return arg1;
					}
				}

				internal void PatchOpCode(NormalizedByteCode bc)
				{
					this.normopcode = bc;
				}

				internal void PatchOpCode(NormalizedByteCode bc, int arg1)
				{
					this.normopcode = bc;
					this.arg1 = arg1;
				}

				internal void PatchOpCode(NormalizedByteCode bc, int arg1, short arg2)
				{
					this.normopcode = bc;
					this.arg1 = arg1;
					this.arg2 = arg2;
				}

				internal void SetPC(int pc)
				{
					this.pc = (ushort)pc;
				}

				internal void SetTargetIndex(int targetIndex)
				{
					this.arg1 = targetIndex;
				}

				internal void SetTermNop(ushort pc)
				{
					// TODO what happens if we already have exactly the maximum number of instructions?
					this.pc = pc;
					this.normopcode = NormalizedByteCode.__nop;
				}

				internal void MapSwitchTargets(int[] pcIndexMap)
				{
					arg1 = pcIndexMap[arg1 + pc];
					for (int i = 0; i < switch_entries.Length; i++)
					{
						switch_entries[i].target = pcIndexMap[switch_entries[i].target + pc];
					}
				}

				internal void Read(ushort pc, BigEndianBinaryReader br, ClassFile classFile)
				{
					this.pc = pc;
					ByteCode bc = (ByteCode)br.ReadByte();
					switch(ByteCodeMetaData.GetMode(bc))
					{
						case ByteCodeMode.Simple:
							break;
						case ByteCodeMode.Constant_1:
							arg1 = br.ReadByte();
							classFile.MarkLinkRequiredConstantPoolItem(arg1);
							break;
						case ByteCodeMode.Local_1:
							arg1 = br.ReadByte();
							break;
						case ByteCodeMode.Constant_2:
							arg1 = br.ReadUInt16();
							classFile.MarkLinkRequiredConstantPoolItem(arg1);
							break;
						case ByteCodeMode.Branch_2:
							arg1 = br.ReadInt16();
							break;
						case ByteCodeMode.Branch_4:
							arg1 = br.ReadInt32();
							break;
						case ByteCodeMode.Constant_2_1_1:
							arg1 = br.ReadUInt16();
							classFile.MarkLinkRequiredConstantPoolItem(arg1);
							arg2 = br.ReadByte();
							if(br.ReadByte() != 0)
							{
								throw new ClassFormatError("invokeinterface filler must be zero");
							}
							break;
						case ByteCodeMode.Immediate_1:
							arg1 = br.ReadSByte();
							break;
						case ByteCodeMode.Immediate_2:
							arg1 = br.ReadInt16();
							break;
						case ByteCodeMode.Local_1_Immediate_1:
							arg1 = br.ReadByte();
							arg2 = br.ReadSByte();
							break;
						case ByteCodeMode.Constant_2_Immediate_1:
							arg1 = br.ReadUInt16();
							classFile.MarkLinkRequiredConstantPoolItem(arg1);
							arg2 = br.ReadSByte();
							break;
						case ByteCodeMode.Tableswitch:
						{
							// skip the padding
							uint p = pc + 1u;
							uint align = ((p + 3) & 0x7ffffffc) - p;
							br.Skip(align);
							int default_offset = br.ReadInt32();
							this.arg1 = default_offset;
							int low = br.ReadInt32();
							int high = br.ReadInt32();
							if(low > high || high > 16384L + low)
							{
								throw new ClassFormatError("Incorrect tableswitch");
							}
							SwitchEntry[] entries = new SwitchEntry[high - low + 1];
							for(int i = low; i < high; i++)
							{
								entries[i - low].value = i;
								entries[i - low].target = br.ReadInt32();
							}
							// do the last entry outside the loop, to avoid overflowing "i", if high == int.MaxValue
							entries[high - low].value = high;
							entries[high - low].target = br.ReadInt32();
							this.switch_entries = entries;
							break;
						}
						case ByteCodeMode.Lookupswitch:
						{
							// skip the padding
							uint p = pc + 1u;
							uint align = ((p + 3) & 0x7ffffffc) - p;
							br.Skip(align);
							int default_offset = br.ReadInt32();
							this.arg1 = default_offset;
							int count = br.ReadInt32();
							if(count < 0 || count > 16384)
							{
								throw new ClassFormatError("Incorrect lookupswitch");
							}
							SwitchEntry[] entries = new SwitchEntry[count];
							for(int i = 0; i < count; i++)
							{
								entries[i].value = br.ReadInt32();
								entries[i].target = br.ReadInt32();
							}
							this.switch_entries = entries;
							break;
						}
						case ByteCodeMode.WidePrefix:
							bc = (ByteCode)br.ReadByte();
							// NOTE the PC of a wide instruction is actually the PC of the
							// wide prefix, not the following instruction (vmspec 4.9.2)
						switch(ByteCodeMetaData.GetWideMode(bc))
						{
							case ByteCodeModeWide.Local_2:
								arg1 = br.ReadUInt16();
								break;
							case ByteCodeModeWide.Local_2_Immediate_2:
								arg1 = br.ReadUInt16();
								arg2 = br.ReadInt16();
								break;
							default:
								throw new ClassFormatError("Invalid wide prefix on opcode: {0}", bc);
						}
							break;
						default:
							throw new ClassFormatError("Invalid opcode: {0}", bc);
					}
					this.normopcode = ByteCodeMetaData.GetNormalizedByteCode(bc);
					arg1 = ByteCodeMetaData.GetArg(bc, arg1);
				}

				internal int PC
				{
					get
					{
						return pc;
					}
				}

				internal NormalizedByteCode NormalizedOpCode
				{
					get
					{
						return normopcode;
					}
				}

				internal int Arg1
				{
					get
					{
						return arg1;
					}
				}

				internal int TargetIndex
				{
					get
					{
						return arg1;
					}
					set
					{
						arg1 = value;
					}
				}

				internal int Arg2
				{
					get
					{
						return arg2;
					}
				}

				internal int NormalizedArg1
				{
					get
					{
						return arg1;
					}
				}

				internal int DefaultTarget
				{
					get
					{
						return arg1;
					}
					set
					{
						arg1 = value;
					}
				}

				internal int SwitchEntryCount
				{
					get
					{
						return switch_entries.Length;
					}
				}

				internal int GetSwitchValue(int i)
				{
					return switch_entries[i].value;
				}

				internal int GetSwitchTargetIndex(int i)
				{
					return switch_entries[i].target;
				}

				internal void SetSwitchTargets(int[] targets)
				{
					SwitchEntry[] newEntries = (SwitchEntry[])switch_entries.Clone();
					for (int i = 0; i < newEntries.Length; i++)
					{
						newEntries[i].target = targets[i];
					}
					switch_entries = newEntries;
				}
			}

			internal struct LineNumberTableEntry
			{
				internal ushort start_pc;
				internal ushort line_number;
			}

			internal struct LocalVariableTableEntry
			{
				internal ushort start_pc;
				internal ushort length;
				internal string name;
				internal string descriptor;
				internal ushort index;
			}
		}

		internal Field GetField(string name, string sig)
		{
			for (int i = 0; i < fields.Length; i++)
			{
				if (fields[i].Name == name && fields[i].Signature == sig)
				{
					return fields[i];
				}
			}
			return null;
		}

		private void RemoveAssertionInit(Method m)
		{
			/* We match the following code sequence:
			 *   0  ldc <class X>
			 *   2  invokevirtual <Method java/lang/Class desiredAssertionStatus()Z>
			 *   5  ifne 12
			 *   8  iconst_1
			 *   9  goto 13
			 *  12  iconst_0
			 *  13  putstatic <Field <this class> boolean <static final field>>
			 */
			ConstantPoolItemFieldref fieldref;
			Field field;
			if (m.Instructions[0].NormalizedOpCode == NormalizedByteCode.__ldc && SafeIsConstantPoolClass(m.Instructions[0].Arg1)
				&& m.Instructions[1].NormalizedOpCode == NormalizedByteCode.__invokevirtual && IsDesiredAssertionStatusMethodref(m.Instructions[1].Arg1)
				&& m.Instructions[2].NormalizedOpCode == NormalizedByteCode.__ifne && m.Instructions[2].TargetIndex == 5
				&& m.Instructions[3].NormalizedOpCode == NormalizedByteCode.__iconst && m.Instructions[3].Arg1 == 1
				&& m.Instructions[4].NormalizedOpCode == NormalizedByteCode.__goto && m.Instructions[4].TargetIndex == 6
				&& m.Instructions[5].NormalizedOpCode == NormalizedByteCode.__iconst && m.Instructions[5].Arg1 == 0
				&& m.Instructions[6].NormalizedOpCode == NormalizedByteCode.__putstatic && (fieldref = SafeGetFieldref(m.Instructions[6].Arg1)) != null
				&& fieldref.Class == Name && fieldref.Signature == "Z"
				&& (field = GetField(fieldref.Name, fieldref.Signature)) != null
				&& field.IsStatic && field.IsFinal
				&& !HasBranchIntoRegion(m.Instructions, 7, m.Instructions.Length, 0, 7)
				&& !HasStaticFieldWrite(m.Instructions, 7, m.Instructions.Length, field)
				&& !HasExceptionHandlerInRegion(m.ExceptionTable, 0, 7))
			{
				field.PatchConstantValue(true);
				m.Instructions[0].PatchOpCode(NormalizedByteCode.__goto, 7);
				flags |= FLAG_HAS_ASSERTIONS;
			}
		}

		private bool IsDesiredAssertionStatusMethodref(int cpi)
		{
			ConstantPoolItemMethodref method = SafeGetMethodref(cpi) as ConstantPoolItemMethodref;
			return method != null
				&& method.Class == "java.lang.Class"
				&& method.Name == "desiredAssertionStatus"
				&& method.Signature == "()Z";
		}

		private static bool HasBranchIntoRegion(Method.Instruction[] instructions, int checkStart, int checkEnd, int regionStart, int regionEnd)
		{
			for (int i = checkStart; i < checkEnd; i++)
			{
				switch (instructions[i].NormalizedOpCode)
				{
					case NormalizedByteCode.__ifeq:
					case NormalizedByteCode.__ifne:
					case NormalizedByteCode.__iflt:
					case NormalizedByteCode.__ifge:
					case NormalizedByteCode.__ifgt:
					case NormalizedByteCode.__ifle:
					case NormalizedByteCode.__if_icmpeq:
					case NormalizedByteCode.__if_icmpne:
					case NormalizedByteCode.__if_icmplt:
					case NormalizedByteCode.__if_icmpge:
					case NormalizedByteCode.__if_icmpgt:
					case NormalizedByteCode.__if_icmple:
					case NormalizedByteCode.__if_acmpeq:
					case NormalizedByteCode.__if_acmpne:
					case NormalizedByteCode.__ifnull:
					case NormalizedByteCode.__ifnonnull:
					case NormalizedByteCode.__goto:
					case NormalizedByteCode.__jsr:
						if (instructions[i].TargetIndex > regionStart && instructions[i].TargetIndex < regionEnd)
						{
							return true;
						}
						break;
					case NormalizedByteCode.__tableswitch:
					case NormalizedByteCode.__lookupswitch:
						if (instructions[i].DefaultTarget > regionStart && instructions[i].DefaultTarget < regionEnd)
						{
							return true;
						}
						for (int j = 0; j < instructions[i].SwitchEntryCount; j++)
						{
							if (instructions[i].GetSwitchTargetIndex(j) > regionStart && instructions[i].GetSwitchTargetIndex(j) < regionEnd)
							{
								return true;
							}
						}
						break;
				}
			}
			return false;
		}

		private bool HasStaticFieldWrite(Method.Instruction[] instructions, int checkStart, int checkEnd, Field field)
		{
			for (int i = checkStart; i < checkEnd; i++)
			{
				if (instructions[i].NormalizedOpCode == NormalizedByteCode.__putstatic)
				{
					ConstantPoolItemFieldref fieldref = SafeGetFieldref(instructions[i].Arg1);
					if (fieldref != null && fieldref.Class == Name && fieldref.Name == field.Name && fieldref.Signature == field.Signature)
					{
						return true;
					}
				}
			}
			return false;
		}

		private static bool HasExceptionHandlerInRegion(Method.ExceptionTableEntry[] entries, int regionStart, int regionEnd)
		{
			for (int i = 0; i < entries.Length; i++)
			{
				if (entries[i].handlerIndex > regionStart && entries[i].handlerIndex < regionEnd)
				{
					return true;
				}
			}
			return false;
		}
	}
}
@


1.138
log
@Cleaned up static initializer optimization to use FieldWrapper.IsSerialVersionUID.
@
text
@d54 1
d72 1
d351 4
d1320 8
d2723 5
d3886 118
@


1.137
log
@Moved unused field removal optimization to a later stage in the compilation. Also made the check more strict to only remove final fields and not remove fields that have annotations.
@
text
@a3866 9

		internal bool HasSerialVersionUID
		{
			get
			{
				Field field = GetField("serialVersionUID", "J");
				return field != null && field.IsStatic && field.IsFinal;
			}
		}
@


1.136
log
@Bug fix. Don't enforce canonical UTF8 encoding for class file versions <= 47.
@
text
@d1040 1
a1040 19
		internal void RemoveUnusedFields()
		{
			List<Field> list = new List<Field>();
			foreach(Field f in fields)
			{
				if(f.IsPrivate && f.IsStatic && f.Name != "serialVersionUID" && !IsReferenced(f))
				{
					// unused, so we skip it
					Tracer.Info(Tracer.Compiler, "Unused field {0}::{1}", this.Name, f.Name);
				}
				else
				{
					list.Add(f);
				}
			}
			fields = list.ToArray();
		}

		private bool IsReferenced(Field fld)
@


1.135
log
@Avoid infinite recursion if (broken) class loader triggers a load of a class currently being finished.
@
text
@d148 1
a148 1
						isstub |= (utf8_cp[i] = br.ReadString("<unknown>")) == "IKVM.NET.Assembly";
d242 1
a242 1
							utf8_cp[i] = br.ReadString(inputClassName);
@


1.134
log
@Minor class loading refactoring.
@
text
@d962 1
a962 1
		internal void Link(TypeWrapper thisType)
d970 1
a970 1
					constantpool[i].Link(thisType);
d1427 1
a1427 1
			internal virtual void Link(TypeWrapper thisType)
d1565 1
a1565 1
			internal override void Link(TypeWrapper thisType)
d1569 1
a1569 1
					TypeWrapper tw = thisType.GetClassLoader().LoadClass(name, LoadMode.Link | LoadMode.WarnClassNotFound);
d1680 1
a1680 1
			internal override void Link(TypeWrapper thisType)
d1682 1
a1682 1
				clazz.Link(thisType);
d1743 1
a1743 1
			internal override void Link(TypeWrapper thisType)
d1745 1
a1745 1
				base.Link(thisType);
d1764 1
a1764 1
						fw.Link();
d1768 1
a1768 1
				TypeWrapper fld = classLoader.FieldTypeWrapperFromSigNoThrow(this.Signature);
d1820 1
a1820 1
			internal override void Link(TypeWrapper thisType)
d1822 1
a1822 1
				base.Link(thisType);
d1831 2
a1832 2
				TypeWrapper[] args = classLoader.ArgTypeWrapperListFromSigNoThrow(this.Signature);
				TypeWrapper ret = classLoader.RetTypeWrapperFromSigNoThrow(this.Signature);
d1875 1
a1875 1
			internal override void Link(TypeWrapper thisType)
d1877 1
a1877 1
				base.Link(thisType);
d1884 1
a1884 1
						method.Link();
d1895 1
a1895 1
							invokespecialMethod.Link();
d1908 1
a1908 1
			internal override void Link(TypeWrapper thisType)
d1910 1
a1910 1
				base.Link(thisType);
d1925 1
a1925 1
						method.Link();
d2120 1
a2120 1
			internal override void Link(TypeWrapper thisType)
d2122 1
a2122 1
				cpi.Link(thisType);
d2153 1
a2153 1
			internal override void Link(TypeWrapper thisType)
d2163 2
a2164 2
				TypeWrapper[] args = classLoader.ArgTypeWrapperListFromSigNoThrow(descriptor);
				TypeWrapper ret = classLoader.RetTypeWrapperFromSigNoThrow(descriptor);
d2223 1
a2223 1
			internal override void Link(TypeWrapper thisType)
d2233 2
a2234 2
				TypeWrapper[] args = classLoader.ArgTypeWrapperListFromSigNoThrow(descriptor);
				TypeWrapper ret = classLoader.RetTypeWrapperFromSigNoThrow(descriptor);
@


1.133
log
@Bug fix. MethodHandle interface method lookup should support methods inherited from base interfaces.
@
text
@d1569 1
a1569 1
					TypeWrapper tw = ClassLoaderWrapper.LoadClassNoThrow(thisType.GetClassLoader(), name, true);
@


1.132
log
@Bug fix. Allow invokedynamic with unloadable type in signature.
@
text
@a1907 23
			private static MethodWrapper GetInterfaceMethod(TypeWrapper wrapper, string name, string sig)
			{
				if(wrapper.IsUnloadable)
				{
					return null;
				}
				MethodWrapper method = wrapper.GetMethodWrapper(name, sig, false);
				if(method != null)
				{
					return method;
				}
				TypeWrapper[] interfaces = wrapper.Interfaces;
				for(int i = 0; i < interfaces.Length; i++)
				{
					method = GetInterfaceMethod(interfaces[i], name, sig);
					if(method != null)
					{
						return method;
					}
				}
				return null;
			}

d1914 4
a1917 1
					method = GetInterfaceMethod(wrapper, Name, Signature);
@


1.131
log
@Updated ldc <methodhandle> error behavior to match Java 8.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2014 Jeroen Frijters
d2280 5
@


1.130
log
@Bug fix. Since Java 1.7 class names aren't allowed to have [ and ] characters.
@
text
@a41 2
		NoSuchFieldException,
		NoSuchMethodException,
@


1.129
log
@Implemented type annotation reflection for dynamically loaded classes.
@
text
@d1455 1
a1455 1
			private static char[] invalidJava15Characters = { '.', ';' };
d1521 1
d1537 4
d1542 1
a1542 1
						if(name.IndexOfAny(invalidJava15Characters, 0, end) >= 0)
@


1.128
log
@Match OpenJDK handling of invalid MethodParameters attribute.
@
text
@d86 1
d491 8
d548 11
d1282 21
d1441 7
d1634 5
d1969 5
d1997 5
d2025 5
d2312 17
d2371 1
d2528 8
d2670 8
d3028 8
@


1.127
log
@- Enabled MethodParameter rendering in runtime stub generator.
- Support round tripping malformed MethodParameter attribute in stub generator.
- Use new general method parameter interface in ikvmstub.
- Added support for method parameter reflection on .NET types.
@
text
@d2965 1
a2965 1
							if(name <= 0 || name >= utf8_cp.Length || utf8_cp[name] == null)
d2975 1
a2975 1
				return MethodParametersEntry.Malformed;
@


1.126
log
@Malformed MethodParameters attribute should not throw ClassFormatError.
@
text
@a3773 7

			internal struct MethodParametersEntry
			{
				internal static readonly MethodParametersEntry[] Malformed = new MethodParametersEntry[0];
				internal string name;
				internal ushort flags;
			}
@


1.125
log
@Replaced Unsafe cas operations in Class with Interlocked.CompareExchange().
@
text
@d2923 1
a2923 12
							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
							byte parameters_count = rdr.ReadByte();
							parameters = new MethodParametersEntry[parameters_count];
							for(int j = 0; j < parameters_count; j++)
							{
								parameters[j].name = classFile.GetConstantPoolUtf8String(utf8_cp, rdr.ReadUInt16());
								parameters[j].flags = rdr.ReadUInt16();
							}
							if(!rdr.IsAtEnd)
							{
								throw new ClassFormatError("{0} (MethodParameters attribute has wrong length)", classFile.Name);
							}
d2952 26
d3185 8
d3777 1
@


1.124
log
@Fixed class file validation:
- Field and method names cannot contain '[' character.
- Code length cannot be zero.
@
text
@d2681 1
d2891 19
d3079 8
@


1.123
log
@In JDK 8 HotSpot no longer cares about anonymous class constant pool patches to constant pool dummy entries.
@
text
@d801 1
a801 1
				if(".;/<>".IndexOf(name[i]) != -1)
d817 1
a817 1
				if(".;/".IndexOf(name[i]) != -1)
d3167 1
a3167 1
					if(code_length > 65535)
d3169 1
a3169 1
						throw new ClassFormatError("{0} (Invalid Code length {1})", classFile.Name, code_length);
@


1.122
log
@- Added IsVirtual property to ClassFile.Method and MethodWrapper to make the code a bit easier to read.
- Fixed Java 8 interface method handling for annotations and ghost interfaces.
@
text
@d584 1
a584 5
					else if (constantpool[i] == null)
					{
						throw new ClassFormatError("Unused constant pool patch at {0} in class file {1}", i, inputClassName);
					}
					else
@


1.121
log
@Match OpenJDK error message.
@
text
@d2963 9
@


1.120
log
@In Java 8 a method handle constant can be an invokeSpecial to an interface method.
@
text
@d2930 1
a2930 1
						throw new ClassFormatError("Abstract or native method cannot have a Code attribute");
@


1.119
log
@Start of Java 8 support.
@
text
@d2016 1
a2016 1
						if (cpi == null && classFile.MajorVersion >= 52 && (RefKind)ref_kind == RefKind.invokeStatic)
@


1.118
log
@Added support for (implementation specific) LambdaForm annotations.
@
text
@d90 1
a90 1
			internal static readonly int Maximum = Experimental.JDK_8 ? 52 : 51;
@


1.117
log
@Added a ClassFileParseOptions to enable trusted annotations to prepare for more of them.
@
text
@d70 3
a2771 1
#if STATIC_COMPILER
d2778 1
d2782 10
a2794 1
#endif
d2990 24
@


1.116
log
@Added Unsafe.defineAnonymousClass().
@
text
@d55 1
d2770 1
a2770 1
							foreach(object[] annot in annotations)
d2772 1
a2772 1
								if(annot[1].Equals("Lsun/reflect/CallerSensitive;"))
d2774 6
a2779 1
									flags |= FLAG_CALLERSENSITIVE;
@


1.115
log
@Minor refactoring to prepare for class file constant pool patching.
@
text
@d163 1
a163 1
		internal ClassFile(byte[] buf, int offset, int length, string inputClassName, ClassFileParseOptions options)
d245 4
d565 64
d946 2
d1175 5
d1379 1
d1414 6
d1422 5
d1503 9
a1511 1
				typeWrapper = VerifierTypeWrapper.Null;
d1567 1
a1567 1
			private double d;
d1897 1
a1897 1
			private float v;
d1920 1
a1920 1
			private int v;
d1943 1
a1943 1
			private long l;
d2244 15
@


1.114
log
@Switched from @@HasCallerID to @@CallerSensitive and merged CallerSenstive related 7u40 changes.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
d286 1
a286 1
				if(IsInterface && (super_class == 0 || this.SuperClass != "java.lang.Object"))
d1113 1
a1113 1
		internal string SuperClass
d1117 1
a1117 1
				return GetConstantPoolClass(super_class);
@


1.113
log
@Allow Java 8 classes to use invokeStatic method handle constants that refer to InterfaceMethodref.
@
text
@d68 1
a68 1
		private const ushort FLAG_HAS_CALLERID = 0x400;
d2658 9
a2733 4
								if(annot[1].Equals("Likvm/internal/HasCallerID;"))
								{
									flags |= FLAG_HAS_CALLERID;
								}
d2852 2
a2853 2
			// for use by ikvmc only
			internal bool HasCallerIDAnnotation
d2857 1
a2857 1
					return (flags & FLAG_HAS_CALLERID) != 0;
d2860 1
@


1.112
log
@Allow private interface methods (but not yet implemented).
@
text
@d1917 2
@


1.111
log
@Change class format error exception message for missing Code attribute to same text as OpenJDK.
@
text
@d2588 2
a2589 1
						|| (classFile.IsInterface && (!IsPublic || IsFinal || IsNative || IsSynchronized || (!IsAbstract && classFile.MajorVersion < 52))))
@


1.110
log
@Add @@Repeatable annotation to custom attribute annotations that AllowMultiple (when IKVM_EXPERIMENTAL_JDK_8 is defined).
@
text
@d2806 1
a2806 1
						throw new ClassFormatError("Method has no Code attribute");
@


1.109
log
@Don't issue "warning IKVMC0100: Class "{0}" not found" for types that are only used in signatures.
@
text
@d86 1
a86 1
			internal static readonly int Maximum = JVM.SafeGetEnvironmentVariable("IKVM_EXPERIMENTAL_JDK_8") != null ? 52 : 51;
@


1.108
log
@Validate constant pool items referenced by EnclosingMethod attribute.
@
text
@d1423 1
a1423 1
					TypeWrapper tw = ClassLoaderWrapper.LoadClassNoThrow(thisType.GetClassLoader(), name);
@


1.107
log
@Added (partial) support for Java 8 MethodParameters attribute.
@
text
@d426 3
a428 2
								int class_index = br.ReadUInt16();
								int method_index = br.ReadUInt16();
d439 5
a443 1
									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);
@


1.106
log
@Don't try to resolve interface methods in unloadable types.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2012 Jeroen Frijters
d2555 1
d2756 24
d2963 8
d3552 6
@


1.105
log
@- Now that we allow non-abstract interface methods (in Java 8 class files), we need to explicitly check for illegal modifiers on interface methods.
- Changed ClassFormatError message to match JDK.
@
text
@d1754 4
d1779 1
a1779 1
				if(wrapper != null && !wrapper.IsUnloadable)
@


1.104
log
@- Allow static methods in interfaces (for Java 8 class files).
- Allow default interfaces methods (for Java 8 class files), but no actual support for them yet.
@
text
@d2578 1
a2578 1
						|| (classFile.IsInterface && (!IsPublic || (!IsAbstract && classFile.MajorVersion < 52))))
d2580 1
a2580 1
						throw new ClassFormatError("{0} (Illegal method modifiers: 0x{1:X})", classFile.Name, access_flags);
@


1.103
log
@Removed "effectively final" optimization because it breaks the ability to dynamically load subclasses.
@
text
@d2578 1
a2578 1
						|| (classFile.IsInterface && (!IsPublic || !IsAbstract)))
@


1.102
log
@Improved ldc MethodType:
- use nested type with class constructor to create values with statically know signatures (like ldc MethodHandle).
- use caching for dynamicallly constructed MethodType values but retry on failure.
@
text
@d68 1
a68 2
		private const ushort FLAG_MASK_EFFECTIVELY_FINAL = 0x400;
		private const ushort FLAG_HAS_CALLERID = 0x800;
a1212 13
		internal void SetEffectivelyFinal()
		{
			flags |= FLAG_MASK_EFFECTIVELY_FINAL;
		}

		internal bool IsEffectivelyFinal
		{
			get
			{
				return (flags & FLAG_MASK_EFFECTIVELY_FINAL) != 0;
			}
		}

@


1.101
log
@Stop considering ACC_SUPER when linking invokespecial (unless compatibility switch is set). This change matches the security change in Java 7u13.
@
text
@d2032 5
@


1.100
log
@Implemented package access checks (dynamic mode only).
@
text
@d1744 5
a1748 3
					if(Name != StringConstants.INIT && 
						(thisType.Modifiers & (Modifiers.Interface | Modifiers.Super)) == Modifiers.Super &&
						thisType != wrapper && thisType.IsSubTypeOf(wrapper))
@


1.99
log
@Officially deprecated compiling with stubs.
@
text
@d1432 15
a1446 1
					typeWrapper = ClassLoaderWrapper.LoadClassNoThrow(thisType.GetClassLoader(), name);
@


1.98
log
@Removed some O(n^2) operations to improve handling of class files with a large number of fields.
@
text
@d91 2
a92 1
		// This method parses just enough of the class file to obtain its name, it doesn't
d95 1
a95 1
		internal static string GetClassName(byte[] buf, int offset, int length)
d97 1
d146 1
a146 1
						utf8_cp[i] = br.ReadString("<unknown>");
@


1.97
log
@Added ClassFile.Method.IsConstructor helper property.
@
text
@a309 7
					for(int j = 0; j < i; j++)
					{
						if(ReferenceEquals(interfaces[j].Name, cpi.Name))
						{
							throw new ClassFormatError("{0} (Repetitive interface name)", Name);
						}
					}
d311 1
a321 7
					for(int j = 0; j < i; j++)
					{
						if(ReferenceEquals(fields[j].Name, name) && ReferenceEquals(fields[j].Signature, fields[i].Signature))
						{
							throw new ClassFormatError("{0} (Repetitive field name/signature)", Name);
						}
					}
d323 1
a341 7
					for(int j = 0; j < i; j++)
					{
						if(ReferenceEquals(methods[j].Name, name) && ReferenceEquals(methods[j].Signature, sig))
						{
							throw new ClassFormatError("{0} (Repetitive method name/signature)", Name);
						}
					}
d343 1
d525 30
d1333 1
a1333 1
		internal sealed class ConstantPoolItemClass : ConstantPoolItem
d1451 10
d2147 1
a2147 1
		internal abstract class FieldOrMethod
d2311 10
@


1.96
log
@Bug fix. If a bytecode instruction refers to an invalid constant pool entry, MarkLinkRequiredConstantPoolItem should not throw an exception, but simply ignore the mark, the incorrect bytecode will be reported later during verification.
@
text
@d2761 8
@


1.95
log
@Added ClassFile.Field.IsStaticFinalConstant property to avoid duplicating the check.
@
text
@d545 1
a545 1
			if (index != 0)
@


1.94
log
@Removed utf8_cp field from ClassFile (as it was only used during ClassFile construction).
@
text
@d2475 5
@


1.93
log
@Added support to ikvmc to automatically set the full source path in the debugging info if the source file lives next to the .class file.
@
text
@a59 1
		private string[] utf8_cp;
d184 1
a184 1
				utf8_cp = new string[constantpoolcount];
d250 1
a250 1
							constantpool[i].Resolve(this, options);
d322 1
a322 1
					fields[i] = new Field(this, br);
d340 1
a340 1
					methods[i] = new Method(this, options, br);
d365 1
a365 1
					switch(GetConstantPoolUtf8String(br.ReadUInt16()))
d379 1
a379 1
							sourceFile = GetConstantPoolUtf8String(br.ReadUInt16());
d430 1
a430 1
							signature = GetConstantPoolUtf8String(br.ReadUInt16());
d458 2
a459 2
										GetConstantPoolUtf8String(m.name_index),
										GetConstantPoolUtf8String(m.descriptor_index).Replace('/', '.')
d469 1
a469 1
							annotations = ReadAnnotations(br, this);
d477 1
a477 1
							foreach(object[] annot in ReadAnnotations(br, this))
d499 1
a499 1
							ikvmAssembly = GetConstantPoolUtf8String(br.ReadUInt16());
a518 3
				// now that we've constructed the high level objects, the utf8 table isn't needed anymore
				// TODO remove utf8_cp field from ClassFile object
				utf8_cp = null;
d599 1
a599 1
		private static object[] ReadAnnotations(BigEndianBinaryReader br, ClassFile classFile)
d606 1
a606 1
				annotations[i] = ReadAnnotation(rdr, classFile);
d615 1
a615 1
		private static object ReadAnnotation(BigEndianBinaryReader rdr, ClassFile classFile)
d617 1
a617 1
			string type = classFile.GetConstantPoolUtf8String(rdr.ReadUInt16());
d624 2
a625 2
				annot[2 + i * 2 + 0] = classFile.GetConstantPoolUtf8String(rdr.ReadUInt16());
				annot[2 + i * 2 + 1] = ReadAnnotationElementValue(rdr, classFile);
d630 1
a630 1
		private static object ReadAnnotationElementValue(BigEndianBinaryReader rdr, ClassFile classFile)
d654 1
a654 1
						return classFile.GetConstantPoolUtf8String(rdr.ReadUInt16());
d661 2
a662 2
											classFile.GetConstantPoolUtf8String(type_name_index),
											classFile.GetConstantPoolUtf8String(const_name_index)
d668 1
a668 1
											classFile.GetConstantPoolUtf8String(rdr.ReadUInt16())
d671 1
a671 1
						return ReadAnnotation(rdr, classFile);
d679 1
a679 1
								array[i + 1] = ReadAnnotationElementValue(rdr, classFile);
d1030 1
a1030 1
		internal string GetConstantPoolUtf8String(int index)
d1303 1
a1303 1
			internal virtual void Resolve(ClassFile classFile, ClassFileParseOptions options)
d1333 1
a1333 1
			internal override void Resolve(ClassFile classFile, ClassFileParseOptions options)
d1335 1
a1335 1
				name = classFile.GetConstantPoolUtf8String(name_index);
d1478 1
a1478 1
			internal override void Resolve(ClassFile classFile, ClassFileParseOptions options)
d1487 2
a1488 2
				name = String.Intern(classFile.GetConstantPoolUtf8String(name_and_type.name_index));
				descriptor = classFile.GetConstantPoolUtf8String(name_and_type.descriptor_index);
d1845 1
a1845 1
			internal override void Resolve(ClassFile classFile, ClassFileParseOptions options)
d1847 2
a1848 2
				if(classFile.GetConstantPoolUtf8String(name_index) == null
					|| classFile.GetConstantPoolUtf8String(descriptor_index) == null)
d1867 1
a1867 1
			internal override void Resolve(ClassFile classFile, ClassFileParseOptions options)
d1960 1
a1960 1
			internal override void Resolve(ClassFile classFile, ClassFileParseOptions options)
d1962 1
a1962 1
				string descriptor = classFile.GetConstantPoolUtf8String(signature_index);
d2023 1
a2023 1
			internal override void Resolve(ClassFile classFile, ClassFileParseOptions options)
d2031 2
a2032 2
				name = String.Intern(classFile.GetConstantPoolUtf8String(name_and_type.name_index));
				descriptor = String.Intern(classFile.GetConstantPoolUtf8String(name_and_type.descriptor_index).Replace('/', '.'));
d2088 1
a2088 1
			internal override void Resolve(ClassFile classFile, ClassFileParseOptions options)
d2090 1
a2090 1
				s = classFile.GetConstantPoolUtf8String(string_index);
d2135 1
a2135 1
			internal FieldOrMethod(ClassFile classFile, BigEndianBinaryReader br)
d2138 2
a2139 2
				name = String.Intern(classFile.GetConstantPoolUtf8String(br.ReadUInt16()));
				descriptor = classFile.GetConstantPoolUtf8String(br.ReadUInt16());
d2296 1
a2296 1
			internal Field(ClassFile classFile, BigEndianBinaryReader br) : base(classFile, br)
d2307 1
a2307 1
					switch(classFile.GetConstantPoolUtf8String(br.ReadUInt16()))
d2385 1
a2385 1
							signature = classFile.GetConstantPoolUtf8String(br.ReadUInt16());
d2392 1
a2392 1
							annotations = ReadAnnotations(br, classFile);
d2399 1
a2399 1
							foreach(object[] annot in ReadAnnotations(br, classFile))
d2516 1
a2516 1
			internal Method(ClassFile classFile, ClassFileParseOptions options, BigEndianBinaryReader br) : base(classFile, br)
d2540 1
a2540 1
					switch(classFile.GetConstantPoolUtf8String(br.ReadUInt16()))
d2556 1
a2556 1
							code.Read(classFile, this, rdr, options);
d2591 1
a2591 1
							signature = classFile.GetConstantPoolUtf8String(br.ReadUInt16());
d2598 1
a2598 1
							annotations = ReadAnnotations(br, classFile);
d2619 1
a2619 1
									low.parameterAnnotations[j][k] = ReadAnnotation(rdr, classFile);
d2639 1
a2639 1
							low.annotationDefault = ReadAnnotationElementValue(rdr, classFile);
d2652 1
a2652 1
							foreach(object[] annot in ReadAnnotations(br, classFile))
d2900 1
a2900 1
				internal void Read(ClassFile classFile, Method method, BigEndianBinaryReader br, ClassFileParseOptions options)
d3010 1
a3010 1
						switch(classFile.GetConstantPoolUtf8String(br.ReadUInt16()))
d3047 2
a3048 2
										localVariableTable[j].name = classFile.GetConstantPoolUtf8String(rdr.ReadUInt16());
										localVariableTable[j].descriptor = classFile.GetConstantPoolUtf8String(rdr.ReadUInt16()).Replace('/', '.');
@


1.92
log
@Avoid linking class constant pool entries that aren't used (or are only used by name). This avoids spurious IKVMC0100 warnings and unnecessary class load attempts.
@
text
@d75 3
d1139 10
@


1.91
log
@Relax class name validation for trusted class loaders.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d411 5
d544 8
d564 1
d574 1
d1306 4
d1400 5
d1407 1
a1407 1
				if(typeWrapper == null)
d1486 5
d1566 4
d1690 1
a1690 1
				if(!wrapper.IsUnloadable)
d1740 1
a1740 1
				if(!wrapper.IsUnloadable)
d1888 5
d2908 1
a2908 1
							instructions[instructionIndex].Read((ushort)(rdr.Position - basePosition), rdr);
d2979 1
d3224 1
a3224 1
				internal void Read(ushort pc, BigEndianBinaryReader br)
d3233 3
d3241 1
d3251 1
d3270 1
@


1.90
log
@Don't enforce pre-1.5 class name rules in ikvmc (since HotSpot doesn't enforce any naming rules for classes loaded by the system (and boot) class loader, by default). Fix for #3443373.
@
text
@d54 1
d248 1
a248 1
							constantpool[i].Resolve(this);
d1279 1
a1279 1
			internal virtual void Resolve(ClassFile classFile)
d1305 1
a1305 1
			internal override void Resolve(ClassFile classFile)
d1314 1
a1314 1
					if(classFile.MajorVersion < 49)
d1445 1
a1445 1
			internal override void Resolve(ClassFile classFile)
d1803 1
a1803 1
			internal override void Resolve(ClassFile classFile)
d1825 1
a1825 1
			internal override void Resolve(ClassFile classFile)
d1913 1
a1913 1
			internal override void Resolve(ClassFile classFile)
d1976 1
a1976 1
			internal override void Resolve(ClassFile classFile)
d2041 1
a2041 1
			internal override void Resolve(ClassFile classFile)
@


1.89
log
@Remove unused members from runtime.
@
text
@d1309 4
d1349 1
@


1.88
log
@Added ikvm.lang.DllExport annotation to export static methods as unmanaged exports.
@
text
@d2457 1
d2460 1
d2736 1
d2752 1
@


1.87
log
@Starting with class file version 51 the <clinit> methods need to be static.
@
text
@d2451 9
a2459 2
			private object annotationDefault;
			private object[][] parameterAnnotations;
d2551 4
d2557 1
a2557 1
							parameterAnnotations = new object[num_parameters][];
d2561 1
a2561 1
								parameterAnnotations[j] = new object[num_annotations];
d2564 1
a2564 1
									parameterAnnotations[j][k] = ReadAnnotation(rdr, classFile);
d2579 4
d2584 1
a2584 1
							annotationDefault = ReadAnnotationElementValue(rdr, classFile);
d2615 32
d2722 1
a2722 1
					return parameterAnnotations;
d2730 17
a2746 1
					return annotationDefault;
@


1.87.2.1
log
@Backported fixes:
- FileStore for non-accessible drive should throw exception when trying to create the FileStore, not when accessing the name() or type() properties.
- Graphics2D.clip(null) should only throw NPE for a Component graphics.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Handle Main-Class manifest value that spans multiple lines. Fix for bug #3461012.
- Informational messages should not be treated as error when -warnaserror is specified. Fix for #3443377.
- Don't enforce pre-1.5 class name rules in ikvmc (since HotSpot doesn't enforce any naming rules for classes loaded by the system (and boot) class loader, by default). Fix for #3443373.
- Fix for #3441959.
- Throwable.addSuppressed() didn't have a proper parameter name.
- mark getSpace0 with SecuritySafeCritical to avoid getting an exception with .NET 4
- Bug fix. Removed incorrect check for uninitialized objects on backward branch.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Added AssemblyInformationalVersionAttribute to OpenJDK assemblies (to set the "Product Version"). Part of patch #3458997.
- Include copyright and metadata in IKVM.OpenJDK.Tools.dll. Part of patch #3458997.
- Bug fix. Don't call Finish on unloadable TypeWrapper.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
- Suppress annotation custom attributes when enumerating inner classes.
- IKVM.Reflection: Bug fix. Fixed copy/paste error. FieldInfo.IsAssembly should test for FieldAttributes.Assembly access, not FieldAttributes.Family.
@
text
@a1308 4
					// We don't enforce the strict class name rules in the static compiler, since HotSpot doesn't enforce *any* rules on
					// class names for the system (and boot) class loader. We still need to enforce the 1.5 restrictions, because we
					// rely on those invariants.
#if !STATIC_COMPILER
a1344 1
#endif
@


1.86
log
@Implemented invokedynamic instruction.
@
text
@d2457 2
a2458 1
				if(ReferenceEquals(Name, StringConstants.CLINIT) && ReferenceEquals(Signature, StringConstants.SIG_VOID))
d2650 1
a2650 1
					return ReferenceEquals(Name, StringConstants.CLINIT) && ReferenceEquals(Signature, StringConstants.SIG_VOID);
@


1.85
log
@Added support for MethodHandle constants (ldc <MethodHandle>).
@
text
@d79 1
d226 5
d479 7
d498 13
d538 46
d986 5
d1203 32
d1955 70
@


1.84
log
@Added support for MethodType constants (ldc <MethodType>).
@
text
@d40 5
a44 1
		LinkageError
d215 5
d985 5
d1142 13
d1380 2
d1446 5
d1525 5
d1698 88
@


1.83
log
@Bug fix. The "ldc <class>" bytecode can throw an exception, so we need to treat it as such (previously it wasn't marked as throwing an exception, so an exception handler surrounding it could be "optimized" away). The new scheme is to patch the safe versions of ldc opcode into a ldc_nothrow.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2010 Jeroen Frijters
d122 1
d128 3
d132 1
d211 5
d976 5
d1135 3
a1137 1
			Class
d1659 60
d1760 4
a1763 1
			NameAndType = 12
@


1.82
log
@- Enable ikvmc support for class file version 51.
- Change build to support hybrid OpenJDK 6 & 7 build.
@
text
@d905 1
a905 3
		// this won't throw an exception if index is invalid
		// (used by IsSideEffectFreeStaticInitializer)
		internal bool SafeIsConstantPoolClass(int index)
@


1.81
log
@Interface methods must be public, so we ignore the @@ikvm.lang.Internal annotation and emit a warning.
@
text
@d79 1
a79 1
			internal static readonly int Maximum = JVM.SafeGetEnvironmentVariable("IKVM_EXPERIMENTAL_JDK_7") != null ? 51 : 50;
@


1.80
log
@Added support for encoding incorrect annotation values and reporting the exception back when the annotation is queried.
Removed old (GNU Classpath based) version of AnnotationAttributeBase.java.
@
text
@d2201 9
a2209 2
									this.access_flags &= ~Modifiers.AccessMask;
									flags |= FLAG_MASK_INTERNAL;
@


1.79
log
@Implemented first stab at converting suitable fault blocks into finally blocks.
@
text
@d526 1
a526 2
			byte tag = rdr.ReadByte();
			switch(tag)
d528 26
a553 23
				case (byte)'Z':
					return classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16()) != 0;
				case (byte)'B':
					return (byte)classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16());
				case (byte)'C':
					return (char)classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16());
				case (byte)'S':
					return (short)classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16());
				case (byte)'I':
					return classFile.GetConstantPoolConstantInteger(rdr.ReadUInt16());
				case (byte)'F':
					return classFile.GetConstantPoolConstantFloat(rdr.ReadUInt16());
				case (byte)'J':
					return classFile.GetConstantPoolConstantLong(rdr.ReadUInt16());
				case (byte)'D':
					return classFile.GetConstantPoolConstantDouble(rdr.ReadUInt16());
				case (byte)'s':
					return classFile.GetConstantPoolUtf8String(rdr.ReadUInt16());
				case (byte)'e':
				{
					ushort type_name_index = rdr.ReadUInt16();
					ushort const_name_index = rdr.ReadUInt16();
					return new object[] {
d558 3
a560 3
				}
				case (byte)'c':
					return new object[] {
d564 15
a578 12
				case (byte)'@@':
					return ReadAnnotation(rdr, classFile);
				case (byte)'[':
				{
					ushort num_values = rdr.ReadUInt16();
					object[] array = new object[num_values + 1];
					array[0] = AnnotationDefaultAttribute.TAG_ARRAY;
					for(int i = 0; i < num_values; i++)
					{
						array[i + 1] = ReadAnnotationElementValue(rdr, classFile);
					}
					return array;
a579 2
				default:
					throw new ClassFormatError("Invalid tag {0} in annotation element_value", tag);
d581 10
@


1.78
log
@Made ExceptionTableEntry completely immutable by making ordinal readonly as well.
@
text
@d2595 1
d2598 5
d2609 1
d2650 5
d2674 7
@


1.77
log
@Made ExceptionTableEntry mostly immutable (ordinal will be next).
@
text
@d2479 1
a2479 2
						exception_table[i] = new ExceptionTableEntry(startIndex, endIndex, handlerIndex, catch_type);
						exception_table[i].ordinal = i;
d2594 1
a2594 1
				internal int ordinal;
d2596 1
a2596 1
				internal ExceptionTableEntry(int startIndex, int endIndex, int handlerIndex, ushort catch_type)
d2602 1
@


1.76
log
@Removed mutable flags field from Instruction.
@
text
@a2462 3
						exception_table[i] = new ExceptionTableEntry();
						exception_table[i].catch_type = catch_type;
						exception_table[i].ordinal = i;
d2465 2
a2466 1
						exception_table[i].startIndex = pcIndexMap[start_pc];
d2472 1
a2472 1
							exception_table[i].endIndex = instructionIndex - 1;
d2476 1
a2476 1
							exception_table[i].endIndex = pcIndexMap[end_pc];
d2478 3
a2480 1
						exception_table[i].handlerIndex = pcIndexMap[handler_pc];
d2591 4
a2594 4
				internal int startIndex;
				internal int endIndex;
				internal int handlerIndex;
				internal ushort catch_type;
d2596 8
@


1.75
log
@Fixed loop counter integer overflow. Bug #3009543.
@
text
@a2609 1
				internal InstructionFlags flags;
a2642 16
				internal bool IsReachable
				{
					get
					{
						return (flags & InstructionFlags.Reachable) != 0;
					}
				}

				internal bool IsBranchTarget
				{
					get
					{
						return (flags & InstructionFlags.BranchTarget) != 0;
					}
				}

@


1.74
log
@Handle the case where the exception block ends at the end of the method (scala compiler generates code like this).
@
text
@d2755 1
a2755 1
							for(int i = low; i <= high; i++)
d2760 3
@


1.73
log
@Moved non-throwing signature parsing from ClassFile.cs to ClassLoaderWrapper.cs (and merged it with the throwing variant). This avoids new stub generator having to include ClassFile.cs.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
d2469 11
a2479 1
						exception_table[i].endIndex = pcIndexMap[end_pc];
@


1.72
log
@Moved StringConstants from ClassFile.cs to TypeWrapper.cs, to avoid new stub generator (to be checked in later) to have to include ClassFile.cs
@
text
@d1215 1
a1215 1
					typeWrapper = LoadClassHelper(thisType.GetClassLoader(), name);
a1237 131
		private static TypeWrapper LoadClassHelper(ClassLoaderWrapper classLoader, string name)
		{
			try
			{
				TypeWrapper wrapper = classLoader.LoadClassByDottedNameFast(name);
				if(wrapper == null)
				{
					Tracer.Error(Tracer.ClassLoading, "Class not found: {0}", name);
					wrapper = new UnloadableTypeWrapper(name);
				}
				return wrapper;
			}
			catch(RetargetableJavaException x)
			{
				// HACK keep the compiler from warning about unused local
				GC.KeepAlive(x);
#if !STATIC_COMPILER && !FIRST_PASS
				if(Tracer.ClassLoading.TraceError)
				{
					java.lang.ClassLoader cl = (java.lang.ClassLoader)classLoader.GetJavaClassLoader();
					if(cl != null)
					{
						System.Text.StringBuilder sb = new System.Text.StringBuilder();
						string sep = "";
						while(cl != null)
						{
							sb.Append(sep).Append(cl);
							sep = " -> ";
							cl = cl.getParent();
						}
						Tracer.Error(Tracer.ClassLoading, "ClassLoader chain: {0}", sb);
					}
					Exception m = ikvm.runtime.Util.mapException(x.ToJava());
					Tracer.Error(Tracer.ClassLoading, m.ToString() + Environment.NewLine + m.StackTrace);
				}
#endif // !STATIC_COMPILER && !FIRST_PASS
				return new UnloadableTypeWrapper(name);
			}
		}

		private static TypeWrapper SigDecoderWrapper(ClassLoaderWrapper classLoader, ref int index, string sig)
		{
			switch(sig[index++])
			{
				case 'B':
					return PrimitiveTypeWrapper.BYTE;
				case 'C':
					return PrimitiveTypeWrapper.CHAR;
				case 'D':
					return PrimitiveTypeWrapper.DOUBLE;
				case 'F':
					return PrimitiveTypeWrapper.FLOAT;
				case 'I':
					return PrimitiveTypeWrapper.INT;
				case 'J':
					return PrimitiveTypeWrapper.LONG;
				case 'L':
				{
					int pos = index;
					index = sig.IndexOf(';', index) + 1;
					return LoadClassHelper(classLoader, sig.Substring(pos, index - pos - 1));
				}
				case 'S':
					return PrimitiveTypeWrapper.SHORT;
				case 'Z':
					return PrimitiveTypeWrapper.BOOLEAN;
				case 'V':
					return PrimitiveTypeWrapper.VOID;
				case '[':
				{
					// TODO this can be optimized
					string array = "[";
					while(sig[index] == '[')
					{
						index++;
						array += "[";
					}
					switch(sig[index])
					{
						case 'L':
						{
							int pos = index;
							index = sig.IndexOf(';', index) + 1;
							return LoadClassHelper(classLoader, array + sig.Substring(pos, index - pos));
						}
						case 'B':
						case 'C':
						case 'D':
						case 'F':
						case 'I':
						case 'J':
						case 'S':
						case 'Z':
							return LoadClassHelper(classLoader, array + sig[index++]);
						default:
							// TODO this should never happen, because ClassFile should validate the descriptors
							throw new InvalidOperationException(sig.Substring(index));
					}
				}
				default:
					// TODO this should never happen, because ClassFile should validate the descriptors
					throw new InvalidOperationException(sig.Substring(index));
			}
		}

		internal static TypeWrapper[] ArgTypeWrapperListFromSig(ClassLoaderWrapper classLoader, string sig)
		{
			if(sig[1] == ')')
			{
				return TypeWrapper.EmptyArray;
			}
			List<TypeWrapper> list = new List<TypeWrapper>();
			for(int i = 1; sig[i] != ')';)
			{
				list.Add(SigDecoderWrapper(classLoader, ref i, sig));
			}
			return list.ToArray();
		}

		internal static TypeWrapper FieldTypeWrapperFromSig(ClassLoaderWrapper classLoader, string sig)
		{
			int index = 0;
			return SigDecoderWrapper(classLoader, ref index, sig);
		}

		internal static TypeWrapper RetTypeWrapperFromSig(ClassLoaderWrapper classLoader, string sig)
		{
			int index = sig.IndexOf(')') + 1;
			return SigDecoderWrapper(classLoader, ref index, sig);
		}

d1374 1
a1374 1
				TypeWrapper fld = FieldTypeWrapperFromSig(classLoader, this.Signature);
d1432 2
a1433 2
				TypeWrapper[] args = ArgTypeWrapperListFromSig(classLoader, this.Signature);
				TypeWrapper ret = RetTypeWrapperFromSig(classLoader, this.Signature);
@


1.71
log
@Added basic signature validation for remap file (map.xml). Fixes bug 2908683.
@
text
@a51 9
	static class StringConstants
	{
		internal static readonly string CLINIT = string.Intern("<clinit>");
		internal static readonly string INIT = string.Intern("<init>");
		internal static readonly string SIG_VOID = string.Intern("()V");
		internal static readonly string FINALIZE = string.Intern("finalize");
		internal static readonly string CLONE = string.Intern("clone");
	}

@


1.70
log
@Added IKVM_EXPERIMENTAL_JDK_7 environment variable to enable loading Java 7 class files.
@
text
@d645 1
a645 1
		private static bool IsValidFieldSig(string sig)
d684 1
a684 1
		private static bool IsValidMethodSig(string sig)
@


1.69
log
@Removed vestigial compact framework support.
@
text
@d88 1
a88 1
			internal static readonly int Maximum = 50;
@


1.68
log
@Implemented optimization to remove .cctor when it is empty (and the class isn't serializable or has a serialVersionUID).
@
text
@d1263 1
a1263 1
#if !STATIC_COMPILER && !COMPACT_FRAMEWORK && !FIRST_PASS
d1282 1
a1282 1
#endif // !STATIC_COMPILER
@


1.67
log
@Fixed jsr/ret handling bug.
@
text
@d3047 21
@


1.66
log
@Added support for inlining subroutines (jsr/ret) to allow the verifier and compiler to be simplified and to hopefully pave the way for future codegen optimizations.
@
text
@a2733 1
				JsrHasRet = 8,
@


1.65
log
@Changed bytecode stream and exception tables to use instruction indexes instead of PC.
@
text
@d2461 4
d2473 4
d2495 8
d2505 1
d2532 3
a2534 1
							instructions[instructionIndex++].Read((ushort)(rdr.Position - basePosition), rdr);
d2583 1
a2583 1
								this.instructions[i].SetSwitchTargets(pcIndexMap);
d2802 5
d2819 1
a2819 1
				internal void SetSwitchTargets(int[] pcIndexMap)
d2970 4
d2998 4
d3021 10
@


1.64
log
@Make ikvmc emit a warning whenever it emits code that throws a hard error.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
a2462 9
			// maps a PC to an index in the Instruction[], invalid PCs return -1
			internal int[] PcIndexMap
			{
				get
				{
					return code.pcIndexMap;
				}
			}

a2492 1
				internal int[] pcIndexMap;
d2527 42
a2584 3
						exception_table[i].start_pc = start_pc;
						exception_table[i].end_pc = end_pc;
						exception_table[i].handler_pc = handler_pc;
d2587 5
a2649 10
					// build the pcIndexMap
					pcIndexMap = new int[this.instructions[instructionIndex - 1].PC + 1];
					for(int i = 0; i < pcIndexMap.Length; i++)
					{
						pcIndexMap[i] = -1;
					}
					for(int i = 0; i < instructionIndex - 1; i++)
					{
						pcIndexMap[this.instructions[i].PC] = i;
					}
d2702 3
a2704 3
				internal ushort start_pc;
				internal ushort end_pc;
				internal ushort handler_pc;
d2730 1
a2730 1
					internal int target_offset;
d2783 5
d2795 9
d2865 1
a2865 1
								entries[i - low].target_offset = br.ReadInt32();
d2887 1
a2887 1
								entries[i].target_offset = br.ReadInt32();
d2940 8
d2964 1
a2964 1
				internal int DefaultOffset
d2985 1
a2985 1
				internal int GetSwitchTargetOffset(int i)
d2987 1
a2987 1
					return switch_entries[i].target_offset;
@


1.64.2.1
log
@- Changed version to 0.40.0.2
- Added rmic step to build to remove dependency on .class files
- Fixed verifier bug in merging of jsr/ret state
- Fixed verifier bugs that could cause potential LocalStoreSites corruption
@
text
@d2691 1
@


1.63
log
@Fix bug in handling of jsr instruction.
@
text
@d41 1
@


1.62
log
@Added support for detecting "access" bridge methods and not hide them.
@
text
@d2689 2
a2690 1
				BranchTarget = 4
@


1.62.2.1
log
@- Changed version to 0.38.0.2
- Fixed openjdk.build BOM issue on Linux
- Fixed verifier bug in handling of jsr instruction
@
text
@d2689 1
a2689 2
				BranchTarget = 4,
				JsrHasRet = 8,
@


1.61
log
@Generified all collections.
@
text
@d879 11
@


1.60
log
@Removed unused per-type class caching.
@
text
@d26 1
a26 1
using System.Collections;
d825 1
a825 1
			ArrayList list = new ArrayList();
d838 1
a838 1
			fields = (Field[])list.ToArray(typeof(Field));
d1346 1
a1346 1
			ArrayList list = new ArrayList();
d1351 1
a1351 3
			TypeWrapper[] types = new TypeWrapper[list.Count];
			list.CopyTo(types);
			return types;
d2616 1
a2616 1
					ArrayList args = new ArrayList();
d2648 1
a2648 2
					argmap = new int[args.Count];
					args.CopyTo(argmap);
@


1.59
log
@Marked all static classes as static.
@
text
@d747 1
a747 1
		internal void Link(TypeWrapper thisType, Hashtable classCache)
d753 1
a753 1
					constantpool[i].Link(thisType, classCache);
d1115 1
a1115 1
			internal virtual void Link(TypeWrapper thisType, Hashtable classCache)
d1208 1
a1208 1
			internal override void Link(TypeWrapper thisType, Hashtable classCache)
d1212 1
a1212 1
					typeWrapper = LoadClassHelper(thisType.GetClassLoader(), classCache, name);
d1235 1
a1235 1
		private static TypeWrapper LoadClassHelper(ClassLoaderWrapper classLoader, Hashtable classCache, string name)
d1239 1
a1239 6
				TypeWrapper wrapper = (TypeWrapper)classCache[name];
				if(wrapper != null)
				{
					return wrapper;
				}
				wrapper = classLoader.LoadClassByDottedNameFast(name);
d1275 1
a1275 1
		private static TypeWrapper SigDecoderWrapper(ClassLoaderWrapper classLoader, Hashtable classCache, ref int index, string sig)
d1295 1
a1295 1
					return LoadClassHelper(classLoader, classCache, sig.Substring(pos, index - pos - 1));
d1318 1
a1318 1
							return LoadClassHelper(classLoader, classCache, array + sig.Substring(pos, index - pos));
d1328 1
a1328 1
							return LoadClassHelper(classLoader, classCache, array + sig[index++]);
d1340 1
a1340 1
		internal static TypeWrapper[] ArgTypeWrapperListFromSig(ClassLoaderWrapper classLoader, Hashtable classCache, string sig)
d1349 1
a1349 1
				list.Add(SigDecoderWrapper(classLoader, classCache, ref i, sig));
d1356 1
a1356 1
		internal static TypeWrapper FieldTypeWrapperFromSig(ClassLoaderWrapper classLoader, Hashtable classCache, string sig)
d1359 1
a1359 1
			return SigDecoderWrapper(classLoader, classCache, ref index, sig);
d1362 1
a1362 1
		internal static TypeWrapper RetTypeWrapperFromSig(ClassLoaderWrapper classLoader, Hashtable classCache, string sig)
d1365 1
a1365 1
			return SigDecoderWrapper(classLoader, classCache, ref index, sig);
d1422 1
a1422 1
			internal override void Link(TypeWrapper thisType, Hashtable classCache)
d1424 1
a1424 1
				clazz.Link(thisType, classCache);
d1483 1
a1483 1
			internal override void Link(TypeWrapper thisType, Hashtable classCache)
d1485 1
a1485 1
				base.Link(thisType, classCache);
d1504 1
a1504 1
				TypeWrapper fld = FieldTypeWrapperFromSig(classLoader, classCache, this.Signature);
d1551 1
a1551 1
			internal override void Link(TypeWrapper thisType, Hashtable classCache)
d1553 1
a1553 1
				base.Link(thisType, classCache);
d1562 2
a1563 2
				TypeWrapper[] args = ArgTypeWrapperListFromSig(classLoader, classCache, this.Signature);
				TypeWrapper ret = RetTypeWrapperFromSig(classLoader, classCache, this.Signature);
d1601 1
a1601 1
			internal override void Link(TypeWrapper thisType, Hashtable classCache)
d1603 1
a1603 1
				base.Link(thisType, classCache);
d1651 1
a1651 1
			internal override void Link(TypeWrapper thisType, Hashtable classCache)
d1653 1
a1653 1
				base.Link(thisType, classCache);
@


1.58
log
@- Renamed ClassFile.HasCallerID to distinguish it from MethodWrapper.HasCallerID.
- Added check to only recognize HasCallerID annotation in core library.
- Changed other locations that incorrectly used ClassFile.HasCallerID to use MethodWrapper.CallerID.
@
text
@d84 1
a84 1
		private class SupportedVersions
@


1.57
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@d2385 1
a2385 1
			internal bool HasCallerID
@


1.56
log
@- added more efficient float/double to/from int/long bits converters
- made Double.doubleToRawLongBits/longBitsToDouble and Float.floatToRawIntBits/intBitsToFloat intrinsics
- generalized the intrinsics support
@
text
@d73 1
d1068 15
d2326 4
d2384 9
@


1.55
log
@Added support for turning Java fields into .NET properties with an annotation.
@
text
@d51 1
a51 1
	sealed class StringConstants
a52 2
		private StringConstants() {}

a55 5

		internal static readonly string JAVA_LANG_SYSTEM = string.Intern("java.lang.System");
		internal static readonly string JAVA_LANG_VMSYSTEM = string.Intern("java.lang.VMSystem");
		internal static readonly string ARRAYCOPY = string.Intern("arraycopy");
		internal static readonly string SIG_ARRAYCOPY = string.Intern("(Ljava.lang.Object;ILjava.lang.Object;II)V");
a57 2
		internal static readonly string TOCHARARRAY = string.Intern("toCharArray");
		internal static readonly string SIG_TOCHARARRAY = string.Intern("()[C");
@


1.54
log
@- Added -removeassertions optimization option to ikvmc.
- Added -removeassertions to IKVM.OpenJDK.ClassLibrary.dll build.
- Don't look at unreachable instructions when determining if a method needs a line number table.
@
text
@d1972 1
a2071 1
#if STATIC_COMPILER
d2079 6
a2084 1
								if(annot[1].Equals("Likvm/lang/Internal;"))
d2089 1
a2091 1
#endif
d2099 38
d2152 24
@


1.53
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d2661 6
@


1.52
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d1249 1
a1249 1
#if !STATIC_COMPILER && !COMPACT_FRAMEWORK
d1252 1
a1252 1
					object cl = classLoader.GetJavaClassLoader();
d1256 2
a1257 2
						Type type = cl.GetType();
						while(type.FullName != "java.lang.ClassLoader")
d1259 3
a1261 12
							type = type.BaseType;
						}
						System.Reflection.FieldInfo parentField = type.GetField("parent", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
						if(parentField != null)
						{
							string sep = "";
							while(cl != null)
							{
								sb.Append(sep).Append(cl);
								sep = " -> ";
								cl = parentField.GetValue(cl);
							}
d1265 1
a1265 1
					Exception m = JVM.Library.mapException(x.ToJava());
@


1.51
log
@Implemented ikvmc optimization for string literals that are only used to call toCharArray() on.
@
text
@a27 1
using IKVM.Runtime;
@


1.51.2.1
log
@Added method to patch instructions taking an argument.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
a2670 6
				internal void PatchOpCode(NormalizedByteCode bc, int arg1)
				{
					this.normopcode = bc;
					this.arg1 = arg1;
				}

@


1.50
log
@*** empty log message ***
@
text
@d66 2
@


1.49
log
@*** empty log message ***
@
text
@d94 1
a94 1
			internal static readonly int Maximum = 49;
@


1.48
log
@*** empty log message ***
@
text
@d80 1
d1062 13
@


1.47
log
@*** empty log message ***
@
text
@d44 8
d96 1
a101 1
			const string inputClassName = "(unknown)";
d105 1
a105 1
				throw new ClassFormatError("{0} (Bad magic number)", inputClassName);
d111 3
a113 1
				|| majorVersion > SupportedVersions.Maximum)
d115 1
a115 1
				throw new UnsupportedClassVersionError(inputClassName + " (" + majorVersion + "." + minorVersion + ")");
d145 1
a145 1
						utf8_cp[i] = br.ReadString(inputClassName);
d148 1
a148 1
						throw new ClassFormatError("{0} (Illegal constant pool type 0x{1:X})", inputClassName, tag);
d161 1
d163 1
a163 1
		internal ClassFile(byte[] buf, int offset, int length, string inputClassName)
d326 1
a326 1
					methods[i] = new Method(this, br);
d2112 1
a2112 1
			internal Method(ClassFile classFile, BigEndianBinaryReader br) : base(classFile, br)
d2151 1
a2151 1
							code.Read(classFile, this, rdr);
d2410 1
a2410 1
				internal void Read(ClassFile classFile, Method method, BigEndianBinaryReader br)
d2467 1
a2467 5
								if(JVM.NoStackTraceInfo)
								{
									br.Skip(br.ReadUInt32());
								}
								else
d2486 4
d2492 1
a2492 1
								if(JVM.Debug || JVM.IsStaticCompiler)
@


1.46
log
@*** empty log message ***
@
text
@d165 3
a167 1
					|| majorVersion > SupportedVersions.Maximum)
d299 1
a299 1
					if(!IsValidFieldName(name))
d318 1
a318 1
					if(!IsValidMethodName(name))
d343 4
a347 1
							br.Skip(br.ReadUInt32());
a357 3
							// Sun totally ignores the length of InnerClasses attribute,
							// so when we're running Fuzz this used to show up as lots of differences,
							// now we do the same.
d359 1
a359 1
							br.ReadUInt32();
d361 4
d591 1
a591 1
		private static bool IsValidMethodName(string name)
d599 1
a599 1
				if(".;[/<>".IndexOf(name[i]) != -1)
d604 1
a604 1
			return true;
d607 1
a607 1
		private static bool IsValidFieldName(string name)
d615 17
a631 1
				if(".;[/".IndexOf(name[i]) != -1)
d1112 1
a1112 1
						if(Char.IsLetter(prev) || prev == '$' || prev == '_' || prev == '[')
d1134 1
a1134 1
								if(!Char.IsLetterOrDigit(c) && c != '$' && c != '_' && c != '-' && (c != '/' || prev == '/'))
d1397 1
a1397 1
				Validate(name, descriptor);
d1401 1
a1401 1
			protected abstract void Validate(string name, string descriptor);
d1447 1
a1447 1
			protected override void Validate(string name, string descriptor)
d1453 1
a1453 1
				if(!IsValidFieldName(name))
d1513 1
a1513 1
			protected override void Validate(string name, string descriptor)
d1519 1
a1519 1
				if(!IsValidMethodName(name))
d1521 1
a1521 1
					if(!ReferenceEquals(name, StringConstants.INIT) && !ReferenceEquals(name, StringConstants.CLINIT))
d1721 1
a1721 1
		internal sealed class ConstantPoolItemNameAndType : ConstantPoolItem
d1731 9
d1970 4
a1974 1
							br.Skip(br.ReadUInt32());
d2127 4
a2131 1
							br.Skip(br.ReadUInt32());
d2404 1
a2404 1
					if(code_length > 65536)
d2432 11
d2444 4
a2447 4
						exception_table[i].start_pc = br.ReadUInt16();
						exception_table[i].end_pc = br.ReadUInt16();
						exception_table[i].handler_pc = br.ReadUInt16();
						exception_table[i].catch_type = br.ReadUInt16();
@


1.45
log
@*** empty log message ***
@
text
@d1226 1
a1226 1
					Exception m = IKVM.Runtime.Util.MapException(x.ToJava());
@


1.44
log
@*** empty log message ***
@
text
@d44 16
d316 1
a316 1
					if(!IsValidMethodName(name) && !ReferenceEquals(name, "<init>") && !ReferenceEquals(name, "<clinit>"))
d318 8
a325 5
						throw new ClassFormatError("{0} (Illegal method name \"{1}\")", Name, name);
					}
					if((ReferenceEquals(name, "<init>") || ReferenceEquals(name, "<clinit>")) && !sig.EndsWith("V"))
					{
						throw new ClassFormatError("{0} (Method \"{1}\" has illegal signature \"{2}\")", Name, name, sig);
d1497 1
a1497 1
				if(ReferenceEquals(name, "<init>") || ReferenceEquals(name, "<clinit>"))
d1499 4
a1507 4
				else if(!IsValidMethodName(name))
				{
					throw new ClassFormatError("Invalid method name \"{0}\"", name);
				}
d1566 1
a1566 1
					method = wrapper.GetMethodWrapper(Name, Signature, !ReferenceEquals(Name, "<init>"));
d1571 1
a1571 1
					if(Name != "<init>" && 
d2070 1
a2070 1
				if(ReferenceEquals(Name, "<clinit>") && ReferenceEquals(Signature, "()V"))
d2079 1
a2079 1
					if((ReferenceEquals(Name, "<init>") && (IsStatic || IsSynchronized || IsFinal || IsAbstract || IsNative))
d2217 1
a2217 1
						if(ReferenceEquals(this.Name, "<clinit>"))
d2248 1
a2248 1
					return ReferenceEquals(Name, "<clinit>") && ReferenceEquals(Signature, "()V");
@


1.43
log
@*** empty log message ***
@
text
@a611 1
					// TODO we might consider doing more checking here
d1056 1
a1076 1
								// TODO optimize this
d1106 18
a1123 3
						if(name.IndexOf('.') >= 0)
							goto barf;
						if(name[0] == '[' && !IsValidFieldSig(name))
d1125 1
@


1.42
log
@*** empty log message ***
@
text
@d1068 1
a1068 2
					char prev = name[0];
					if(Char.IsLetter(prev) || prev == '$' || prev == '_' || prev == '[')
d1070 2
a1071 3
						int skip = 1;
						int end = name.Length;
						if(prev == '[')
d1073 3
a1075 2
							// TODO optimize this
							if(!IsValidFieldSig(name))
d1077 13
a1089 1
								goto barf;
d1091 1
a1091 1
							while(name[skip] == '[')
d1093 6
a1098 5
								skip++;
							}
							if(name.EndsWith(";"))
							{
								end--;
d1100 2
d1103 8
a1110 9
						for(int i = skip; i < end; i++)
						{
							char c = name[i];
							if(!Char.IsLetterOrDigit(c) && c != '$' && c != '_' && c != '-' && (c != '/' || prev == '/'))
							{
								goto barf;
							}
							prev = c;
						}
@


1.41
log
@*** empty log message ***
@
text
@a23 1
#if !COMPACT_FRAMEWORK
d1154 1
a1154 1
#if !STATIC_COMPILER
a2751 1
#endif
@


1.40
log
@*** empty log message ***
@
text
@d818 11
d845 11
@


1.39
log
@*** empty log message ***
@
text
@d1377 1
a1377 1
				if(fieldTypeWrapper == null)
d1379 1
a1379 4
					ClassLoaderWrapper classLoader = thisType.GetClassLoader();
					fieldTypeWrapper = FieldTypeWrapperFromSig(classLoader, classCache, this.Signature);
					TypeWrapper wrapper = GetClassType();
					if(!wrapper.IsUnloadable)
d1381 21
a1401 17
						field = wrapper.GetFieldWrapper(Name, Signature);
						if(field != null)
						{
							bool ok = false;
							try
							{
								field.Link();
								ok = true;
							}
							finally
							{
								if(!ok)
								{
									fieldTypeWrapper = null;
								}
							}
						}
d1445 1
a1445 1
				if(argTypeWrappers == null)
d1447 15
a1461 3
					ClassLoaderWrapper classLoader = thisType.GetClassLoader();
					argTypeWrappers = ArgTypeWrapperListFromSig(classLoader, classCache, this.Signature);
					retTypeWrapper = RetTypeWrapperFromSig(classLoader, classCache, this.Signature);
@


1.38
log
@*** empty log message ***
@
text
@d228 1
a228 1
				// javac (JDK 1.1) didn't do this, so the VM doesn't enforce this rule
d230 2
a231 1
				// TODO consider implementing http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6320322
d234 2
a235 1
					|| (majorVersion >= 49 && IsAnnotation && !IsInterface))
d301 1
a301 1
					if(!IsValidMethodName(name) && name != "<init>" && name != "<clinit>")
d305 1
a305 1
					if((name == "<init>" || name == "<clinit>") && !sig.EndsWith("V"))
d1428 1
a1428 1
				if(name == "<init>" || name == "<clinit>")
d1485 1
a1485 1
					method = wrapper.GetMethodWrapper(Name, Signature, Name != "<init>");
d1989 1
a1989 1
				if(Name == "<clinit>" && Signature == "()V")
d1998 1
a1998 1
					if((Name == "<init>" && (IsStatic || IsSynchronized || IsFinal || IsAbstract || IsNative))
d2136 1
a2136 1
						if(this.Name == "<clinit>")
d2167 1
a2167 1
					return Name == "<clinit>" && Signature == "()V";
@


1.37
log
@*** empty log message ***
@
text
@d1069 1
a1069 1
							if(!Char.IsLetterOrDigit(c) && c != '$' && c != '_' && (c != '/' || prev == '/'))
@


1.36
log
@*** empty log message ***
@
text
@d2500 8
@


1.35
log
@*** empty log message ***
@
text
@d1982 1
d2064 24
d2181 1
a2181 2
					// TODO
					return null;
@


1.34
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
d415 1
d417 1
a417 1
							if(majorVersion < 49 || !JVM.IsStaticCompiler)
d430 1
d1129 4
a1132 1
				if(!JVM.IsStaticCompiler && Tracer.ClassLoading.TraceError)
d1159 1
d1937 1
d1939 1
a1939 1
							if(classFile.MajorVersion < 49 || !JVM.IsStaticCompiler)
d1952 1
d2077 1
d2079 1
a2079 1
							if(classFile.MajorVersion < 49 || !JVM.IsStaticCompiler)
d2092 1
@


1.33
log
@*** empty log message ***
@
text
@a62 1
#if GENERICS
a65 1
#endif
a69 1
#if GENERICS
a70 3
#else
			internal static readonly int Maximum = JVM.SafeGetEnvironmentVariable("IKVM_EXPERIMENTAL_JDK_5_0") == null ? 48 : 49;
#endif
a364 1
#if GENERICS
a414 1
#endif
a933 1
#if GENERICS
a934 3
#else
				return null;
#endif
a941 1
#if GENERICS
a942 3
#else
				return null;
#endif
a949 1
#if GENERICS
a950 3
#else
				return null;
#endif
a1672 1
#if GENERICS
a1674 1
#endif
a1706 1
#if GENERICS
a1707 3
#else
					return null;
#endif
a1714 1
#if GENERICS
a1715 3
#else
					return null;
#endif
a1912 1
#if GENERICS
a1930 1
#endif
a1972 1
#if GENERICS
a1973 1
#endif
a2036 1
#if GENERICS
a2068 1
#endif
a2154 1
#if GENERICS
a2155 3
#else
					return null;
#endif
@


1.32
log
@*** empty log message ***
@
text
@d432 1
d998 7
d1972 1
d2114 1
@


1.31
log
@*** empty log message ***
@
text
@d49 1
d53 4
a60 2
		private ushort majorVersion;
		private bool deprecated;
d92 3
a94 1
			if(majorVersion < SupportedVersions.Minimum || majorVersion > SupportedVersions.Maximum)
d152 5
a156 3
				int minorVersion = br.ReadUInt16();
				majorVersion = br.ReadUInt16();
				if(majorVersion < SupportedVersions.Minimum || majorVersion > SupportedVersions.Maximum)
d160 1
d327 1
a327 1
							deprecated = true;
d423 13
d474 1
a474 1
#if GENERICS
d561 1
a561 1
#endif // GENERICS
d702 1
a702 1
				return majorVersion;
d985 9
a993 1
				return deprecated;
d1680 1
d1682 1
a1684 1
			protected bool deprecated;
d1841 9
a1849 1
					return deprecated;
d1872 1
a1872 1
							deprecated = true;
d1937 1
a1937 1
							if(classFile.majorVersion < 49)
d1948 1
a1948 1
							if(classFile.majorVersion < 49)
d1955 13
d2026 1
a2026 1
							deprecated = true;
d2064 1
a2064 1
							if(classFile.majorVersion < 49)
d2075 1
a2075 1
							if(classFile.majorVersion < 49)
d2083 1
a2083 1
							if(classFile.majorVersion < 49)
d2096 13
@


1.30
log
@*** empty log message ***
@
text
@d453 1
a453 1

d540 1
a540 1

a580 20
		private static bool IsValidClassName(string name)
		{
			if(name.Length == 0)
			{
				return false;
			}
			if(!Char.IsLetter(name[0]) && name[0] != '$' && name[0] != '_')
			{
				return false;
			}
			for(int i = 1; i < name.Length; i++)
			{
				if(!Char.IsLetterOrDigit(name[i]) && name[i] != '$' && name[i] != '_')
				{
					return false;
				}
			}
			return true;
		}

@


1.29
log
@*** empty log message ***
@
text
@d228 1
@


1.28
log
@*** empty log message ***
@
text
@d24 1
a57 2
		private string signature;
		private string[] enclosingMethod;
d60 1
d62 3
d939 1
d941 3
d951 1
d953 3
d963 1
d965 3
d1674 1
d1677 1
d1710 1
d1712 3
d1722 1
d1724 3
d1964 1
d1966 1
d2136 1
d2138 3
d2659 1
@


1.27
log
@*** empty log message ***
@
text
@d61 1
d225 3
a227 1
				if((IsInterface && IsFinal) || (IsAbstract && IsFinal))
d274 1
a274 1
					if(!IsValidIdentifier(name))
d293 1
a293 1
					if(!IsValidIdentifier(name) && name != "<init>" && name != "<clinit>")
d326 1
d358 2
d403 8
d450 87
d545 33
a577 1
		private static bool IsValidIdentifier(string name)
d753 16
d932 8
d1342 1
a1342 1
				if(!IsValidIdentifier(name))
d1414 1
a1414 1
				else if(!IsValidIdentifier(name))
d1660 1
d1689 8
d1793 8
d1891 1
d1903 8
d1939 1
d2003 1
d2015 22
d2096 17
@


1.26
log
@*** empty log message ***
@
text
@d57 2
d65 3
d69 1
d354 43
d783 16
d1502 1
d1531 8
d1717 11
d1819 11
@


1.25
log
@*** empty log message ***
@
text
@d890 1
a890 1
			catch(Exception x)
a891 1
				// TODO it might not be a good idea to catch .NET system exceptions here
d916 2
a917 2
					x = IKVM.Runtime.Util.MapException(x);
					Tracer.Error(Tracer.ClassLoading, x.ToString() + Environment.NewLine + x.StackTrace);
@


1.24
log
@*** empty log message ***
@
text
@d2101 5
@


1.23
log
@*** empty log message ***
@
text
@a54 1
		private ClassFile outerClass;
d66 63
a128 1
		internal ClassFile(byte[] buf, int offset, int length, string inputClassName, bool allowJavaLangObject)
d225 1
a225 13
				// NOTE for convenience we allow parsing java/lang/Object (which has no super class), so
				// we check for super_class != 0
				if(super_class != 0)
				{
					ValidateConstantPoolItemClass(inputClassName, super_class);
				}
				else
				{
					if(this.Name != "java.lang.Object" || !allowJavaLangObject)
					{
						throw new ClassFormatError("{0} (Bad superclass index)", Name);
					}
				}
a518 14
		// NOTE this property is only used when statically compiling
		// (and it is set by the static compiler's class loader in vm.cs)
		internal ClassFile OuterClass
		{
			get
			{
				return outerClass;
			}
			set
			{
				outerClass = value;
			}
		}

@


1.22
log
@*** empty log message ***
@
text
@d32 12
d2012 8
d2024 1
d2035 31
@


1.21
log
@*** empty log message ***
@
text
@a2002 1
				private ByteCode opcode;
d2018 1
a2018 1
					this.opcode = ByteCode.__nop;
a2128 1
					this.opcode = bc;
d2130 1
a2130 1
					arg1 = ByteCodeMetaData.GetArg(opcode, arg1);
a2140 8
				internal ByteCode OpCode
				{
					get
					{
						return opcode;
					}
				}

@


1.20
log
@*** empty log message ***
@
text
@d192 1
a192 1
						if(interfaces[j].Name == cpi.Name)
a199 1
				Hashtable fieldNameSigs = new Hashtable();
d208 1
a208 1
					try
d210 4
a213 5
						fieldNameSigs.Add(name + fields[i].Signature, null);
					}
					catch(ArgumentException)
					{
						throw new ClassFormatError("{0} (Repetitive field name/signature)", Name);
a217 1
				Hashtable methodNameSigs = new Hashtable();
d231 1
a231 1
					try
d233 4
a236 5
						methodNameSigs.Add(name + sig, null);
					}
					catch(ArgumentException)
					{
						throw new ClassFormatError("{0} (Repetitive method name/signature)", Name);
d299 3
@


1.19
log
@*** empty log message ***
@
text
@a28 1
using IKVM.Internal;
d30 1
a30 1
sealed class ClassFile
d32 16
a47 14
	private ConstantPoolItem[] constantpool;
	private string[] utf8_cp;
	private Modifiers access_flags;
	private ushort this_class;
	private ushort super_class;
	private ConstantPoolItemClass[] interfaces;
	private Field[] fields;
	private Method[] methods;
	private string sourceFile;
	private ClassFile outerClass;
	private ushort majorVersion;
	private bool deprecated;
	private string ikvmAssembly;
	private InnerClass[] innerClasses;
d49 5
a53 5
	private class SupportedVersions
	{
		internal static readonly int Minimum = 45;
		internal static readonly int Maximum = JVM.SafeGetEnvironmentVariable("IKVM_EXPERIMENTAL_JDK_5_0") == null ? 48 : 49;
	}
d55 1
a55 3
	internal ClassFile(byte[] buf, int offset, int length, string inputClassName, bool allowJavaLangObject)
	{
		try
d57 1
a57 2
			BigEndianBinaryReader br = new BigEndianBinaryReader(buf, offset, length);
			if(br.ReadUInt32() != 0xCAFEBABE)
d59 8
a66 15
				throw new ClassFormatError("{0} (Bad magic number)", inputClassName);
			}
			int minorVersion = br.ReadUInt16();
			majorVersion = br.ReadUInt16();
			if(majorVersion < SupportedVersions.Minimum || majorVersion > SupportedVersions.Maximum)
			{
				throw new UnsupportedClassVersionError(inputClassName + " (" + majorVersion + "." + minorVersion + ")");
			}
			int constantpoolcount = br.ReadUInt16();
			constantpool = new ConstantPoolItem[constantpoolcount];
			utf8_cp = new string[constantpoolcount];
			for(int i = 1; i < constantpoolcount; i++)
			{
				Constant tag = (Constant)br.ReadByte();
				switch(tag)
d68 1
a68 37
					case Constant.Class:
						constantpool[i] = new ConstantPoolItemClass(br);
						break;
					case Constant.Double:
						constantpool[i] = new ConstantPoolItemDouble(br);
						i++;
						break;
					case Constant.Fieldref:
						constantpool[i] = new ConstantPoolItemFieldref(br);
						break;
					case Constant.Float:
						constantpool[i] = new ConstantPoolItemFloat(br);
						break;
					case Constant.Integer:
						constantpool[i] = new ConstantPoolItemInteger(br);
						break;
					case Constant.InterfaceMethodref:
						constantpool[i] = new ConstantPoolItemInterfaceMethodref(br);
						break;
					case Constant.Long:
						constantpool[i] = new ConstantPoolItemLong(br);
						i++;
						break;
					case Constant.Methodref:
						constantpool[i] = new ConstantPoolItemMethodref(br);
						break;
					case Constant.NameAndType:
						constantpool[i] = new ConstantPoolItemNameAndType(br);
						break;
					case Constant.String:
						constantpool[i] = new ConstantPoolItemString(br);
						break;
					case Constant.Utf8:
						utf8_cp[i] = br.ReadString(inputClassName);
						break;
					default:
						throw new ClassFormatError("{0} (Illegal constant pool type 0x{1:X})", inputClassName, tag);
d70 4
a73 4
			}
			for(int i = 1; i < constantpoolcount; i++)
			{
				if(constantpool[i] != null)
d75 2
a76 1
					try
d78 37
a114 1
						constantpool[i].Resolve(this);
d116 4
a119 1
					catch(ClassFormatError x)
d121 18
a138 7
						// HACK at this point we don't yet have the class name, so any exceptions throw
						// are missing the class name
						throw new ClassFormatError("{0} ({1})", inputClassName, x.Message);
					}
					catch(IndexOutOfRangeException)
					{
						throw new ClassFormatError("{0} (Invalid constant pool item #{1})", inputClassName, i);
a139 28
					catch(InvalidCastException)
					{
						throw new ClassFormatError("{0} (Invalid constant pool item #{1})", inputClassName, i);
					}
				}
			}
			access_flags = (Modifiers)br.ReadUInt16();
			// NOTE although the vmspec says (in 4.1) that interfaces must be marked abstract, earlier versions of
			// javac (JDK 1.1) didn't do this, so the VM doesn't enforce this rule
			// NOTE although the vmspec implies (in 4.1) that ACC_SUPER is illegal on interfaces, it doesn't enforce this
			if((IsInterface && IsFinal) || (IsAbstract && IsFinal))
			{
				throw new ClassFormatError("{0} (Illegal class modifiers 0x{1:X})", inputClassName, access_flags);
			}
			this_class = br.ReadUInt16();
			ValidateConstantPoolItemClass(inputClassName, this_class);
			super_class = br.ReadUInt16();
			// NOTE for convenience we allow parsing java/lang/Object (which has no super class), so
			// we check for super_class != 0
			if(super_class != 0)
			{
				ValidateConstantPoolItemClass(inputClassName, super_class);
			}
			else
			{
				if(this.Name != "java.lang.Object" || !allowJavaLangObject)
				{
					throw new ClassFormatError("{0} (Bad superclass index)", Name);
d141 5
a145 17
			}
			if(IsInterface && (super_class == 0 || this.SuperClass != "java.lang.Object"))
			{
				throw new ClassFormatError("{0} (Interfaces must have java.lang.Object as superclass)", Name);
			}
			// most checks are already done by ConstantPoolItemClass.Resolve, but since it allows
			// array types, we do need to check for that
			if(this.Name[0] == '[')
			{
				throw new ClassFormatError("Bad name");
			}
			int interfaces_count = br.ReadUInt16();
			interfaces = new ConstantPoolItemClass[interfaces_count];
			for(int i = 0; i < interfaces.Length; i++)
			{
				int index = br.ReadUInt16();
				if(index == 0 || index >= constantpool.Length)
d147 1
a147 1
					throw new ClassFormatError("{0} (Illegal constant pool index)", Name);
d149 6
a154 2
				ConstantPoolItemClass cpi = constantpool[index] as ConstantPoolItemClass;
				if(cpi == null)
d156 1
a156 1
					throw new ClassFormatError("{0} (Interface name has bad constant type)", Name);
d158 1
a158 2
				interfaces[i] = cpi;
				for(int j = 0; j < i; j++)
d160 1
a160 1
					if(interfaces[j].Name == cpi.Name)
d162 1
a162 1
						throw new ClassFormatError("{0} (Repetitive interface name)", Name);
d165 1
a165 9
			}
			int fields_count = br.ReadUInt16();
			fields = new Field[fields_count];
			Hashtable fieldNameSigs = new Hashtable();
			for(int i = 0; i < fields_count; i++)
			{
				fields[i] = new Field(this, br);
				string name = fields[i].Name;
				if(!IsValidIdentifier(name))
d167 1
a167 1
					throw new ClassFormatError("{0} (Illegal field name \"{1}\")", Name, name);
d169 3
a171 1
				try
d173 1
a173 1
					fieldNameSigs.Add(name + fields[i].Signature, null);
d175 3
a177 1
				catch(ArgumentException)
d179 18
a196 1
					throw new ClassFormatError("{0} (Repetitive field name/signature)", Name);
d198 4
a201 10
			}
			int methods_count = br.ReadUInt16();
			methods = new Method[methods_count];
			Hashtable methodNameSigs = new Hashtable();
			for(int i = 0; i < methods_count; i++)
			{
				methods[i] = new Method(this, br);
				string name = methods[i].Name;
				string sig = methods[i].Signature;
				if(!IsValidIdentifier(name) && name != "<init>" && name != "<clinit>")
d203 14
a216 1
					throw new ClassFormatError("{0} (Illegal method name \"{1}\")", Name, name);
d218 4
a221 1
				if((name == "<init>" || name == "<clinit>") && !sig.EndsWith("V"))
d223 19
a241 1
					throw new ClassFormatError("{0} (Method \"{1}\" has illegal signature \"{2}\")", Name, name, sig);
d243 2
a244 1
				try
d246 8
a253 38
					methodNameSigs.Add(name + sig, null);
				}
				catch(ArgumentException)
				{
					throw new ClassFormatError("{0} (Repetitive method name/signature)", Name);
				}
			}
			int attributes_count = br.ReadUInt16();
			for(int i = 0; i < attributes_count; i++)
			{
				switch(GetConstantPoolUtf8String(br.ReadUInt16()))
				{
					case "Deprecated":
						deprecated = true;
						br.Skip(br.ReadUInt32());
						break;
					case "SourceFile":
						if(br.ReadUInt32() != 2)
						{
							throw new ClassFormatError("SourceFile attribute has incorrect length");
						}
						sourceFile = GetConstantPoolUtf8String(br.ReadUInt16());
						break;
					case "InnerClasses":
						// Sun totally ignores the length of InnerClasses attribute,
						// so when we're running Fuzz this used to show up as lots of differences,
						// now we do the same.
						BigEndianBinaryReader rdr = br;
						br.ReadUInt32();
						ushort count = rdr.ReadUInt16();
						innerClasses = new InnerClass[count];
						for(int j = 0; j < innerClasses.Length; j++)
						{
							innerClasses[j].innerClass = rdr.ReadUInt16();
							innerClasses[j].outerClass = rdr.ReadUInt16();
							innerClasses[j].name = rdr.ReadUInt16();
							innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();
							if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))
d255 1
a255 1
								throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)", this.Name);
d257 11
a267 1
							if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))
d269 20
a288 1
								throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)", this.Name);
d290 3
a292 1
							if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)
d294 1
a294 1
								throw new ClassFormatError("{0} (inner class name has bad constant pool index)", this.Name);
d296 10
a305 16
							if(innerClasses[j].innerClass == innerClasses[j].outerClass)
							{
								throw new ClassFormatError("{0} (Class is both inner and outer class)", this.Name);
							}
						}
						break;
					case "IKVM.NET.Assembly":
						if(br.ReadUInt32() != 2)
						{
							throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");
						}
						ikvmAssembly = GetConstantPoolUtf8String(br.ReadUInt16());
						break;
					default:
						br.Skip(br.ReadUInt32());
						break;
d308 5
a312 1
			if(br.Position != offset + length)
d314 2
a315 1
				throw new ClassFormatError("Extra bytes at the end of the class file");
d317 8
a325 18
		catch(OverflowException)
		{
			throw new ClassFormatError("Truncated class file (or section)");
		}
		catch(IndexOutOfRangeException)
		{
			// TODO we should throw more specific errors
			throw new ClassFormatError("Unspecified class file format error");
		}
//		catch(Exception x)
//		{
//			Console.WriteLine(x);
//			FileStream fs = File.Create(inputClassName + ".broken");
//			fs.Write(buf, offset, length);
//			fs.Close();
//			throw;
//		}
	}
d327 1
a327 3
	private void ValidateConstantPoolItemClass(string classFile, ushort index)
	{
		if(index >= constantpool.Length || !(constantpool[index] is ConstantPoolItemClass))
d329 4
a332 1
			throw new ClassFormatError("{0} (Bad constant pool index #{1})", classFile, index);
a333 1
	}
d335 1
a335 3
	private static bool IsValidIdentifier(string name)
	{
		if(name.Length == 0)
d337 5
a341 9
			return false;
		}
		if(!Char.IsLetter(name[0]) && name[0] != '$' && name[0] != '_')
		{
			return false;
		}
		for(int i = 1; i < name.Length; i++)
		{
			if(!Char.IsLetterOrDigit(name[i]) && name[i] != '$' && name[i] != '_')
d345 3
a347 22
		}
		return true;
	}

	private static bool IsValidFieldSig(string sig)
	{
		return IsValidFieldSigImpl(sig, 0, sig.Length);
	}

	private static bool IsValidFieldSigImpl(string sig, int start, int end)
	{
		if(start >= end)
		{
			return false;
		}
		switch(sig[start])
		{
			case 'L':
				// TODO we might consider doing more checking here
				return sig.IndexOf(';', start + 1) == end - 1;
			case '[':
				while(sig[start] == '[')
d349 1
a349 5
					start++;
					if(start == end)
					{
						return false;
					}
d351 2
a352 12
				return IsValidFieldSigImpl(sig, start, end);
			case 'B':
			case 'Z':
			case 'C':
			case 'S':
			case 'I':
			case 'J':
			case 'F':
			case 'D':
				return start == end - 1;
			default:
				return false;
a353 1
	}
d355 1
a355 3
	private static bool IsValidMethodSig(string sig)
	{
		if(sig.Length < 3 || sig[0] != '(')
d357 1
a357 1
			return false;
d359 2
a360 2
		int end = sig.IndexOf(')');
		if(end == -1)
d362 5
a366 9
			return false;
		}
		if(!sig.EndsWith(")V") && !IsValidFieldSigImpl(sig, end + 1, sig.Length))
		{
			return false;
		}
		for(int i = 1; i < end; i++)
		{
			switch(sig[i])
d368 13
d389 1
a389 18
					break;
				case 'L':
					i = sig.IndexOf(';', i);
					break;
				case '[':
					while(sig[i] == '[')
					{
						i++;
					}
					if("BZCSIJFDL".IndexOf(sig[i]) == -1)
					{
						return false;
					}
					if(sig[i] == 'L')
					{
						i = sig.IndexOf(';', i);
					}
					break;
d393 5
a397 1
			if(i == -1 || i >= end)
d401 48
a449 2
		return true;
	}
d451 1
a451 3
	internal int MajorVersion
	{
		get
d453 4
a456 1
			return majorVersion;
a457 1
	}
d459 3
a461 5
	// NOTE this property is only used when statically compiling
	// (and it is set by the static compiler's class loader in vm.cs)
	internal ClassFile OuterClass
	{
		get
d463 8
a470 5
			return outerClass;
		}
		set
		{
			outerClass = value;
a471 1
	}
d473 1
a473 3
	internal void Link(TypeWrapper thisType, Hashtable classCache)
	{
		for(int i = 1; i < constantpool.Length; i++)
d475 1
a475 1
			if(constantpool[i] != null)
d477 4
a480 1
				constantpool[i].Link(thisType, classCache);
a482 1
	}
d484 1
a484 3
	internal Modifiers Modifiers
	{
		get
d486 4
a489 1
			return access_flags;
a490 1
	}
d492 1
a492 3
	internal bool IsAbstract
	{
		get
d494 5
a498 2
			// interfaces are implicitly abstract
			return (access_flags & (Modifiers.Abstract | Modifiers.Interface)) != 0;
a499 1
	}
d501 1
a501 3
	internal bool IsFinal
	{
		get
d503 4
a506 1
			return (access_flags & Modifiers.Final) != 0;
a507 1
	}
d509 1
a509 3
	internal bool IsPublic
	{
		get
d511 4
a514 1
			return (access_flags & Modifiers.Public) != 0;
a515 1
	}
d517 1
a517 3
	internal bool IsInterface
	{
		get
d519 4
a522 1
			return (access_flags & Modifiers.Interface) != 0;
a523 1
	}
d525 1
a525 3
	internal bool IsSuper
	{
		get
d527 4
a530 1
			return (access_flags & Modifiers.Super) != 0;
a531 1
	}
d533 1
a533 4
	internal void RemoveUnusedFields()
	{
		ArrayList list = new ArrayList();
		foreach(Field f in fields)
d535 2
a536 1
			if(f.IsPrivate && f.IsStatic && f.Name != "serialVersionUID" && !IsReferenced(f))
d538 9
a546 6
				// unused, so we skip it
				Tracer.Info(Tracer.Compiler, "Unused field {0}::{1}", this.Name, f.Name);
			}
			else
			{
				list.Add(f);
d548 1
a549 2
		fields = (Field[])list.ToArray(typeof(Field));
	}
d551 1
a551 3
	private bool IsReferenced(Field fld)
	{
		foreach(ConstantPoolItem cpi in constantpool)
d553 1
a553 5
			ConstantPoolItemFieldref fieldref = cpi as ConstantPoolItemFieldref;
			if(fieldref != null && 
				fieldref.Class == this.Name && 
				fieldref.Name == fld.Name && 
				fieldref.Signature == fld.Signature)
d555 8
a562 1
				return true;
d564 1
a565 2
		return false;
	}
d567 4
a570 4
	internal ConstantPoolItemFieldref GetFieldref(int index)
	{
		return (ConstantPoolItemFieldref)constantpool[index];
	}
d572 5
a576 5
	// NOTE this returns an MI, because it used for both normal methods and interface methods
	internal ConstantPoolItemMI GetMethodref(int index)
	{
		return (ConstantPoolItemMI)constantpool[index];
	}
d578 4
a581 4
	private ConstantPoolItem GetConstantPoolItem(int index)
	{
		return constantpool[index];
	}
d583 4
a586 4
	internal string GetConstantPoolClass(int index)
	{
		return ((ConstantPoolItemClass)constantpool[index]).Name;
	}
d588 4
a591 4
	internal TypeWrapper GetConstantPoolClassType(int index)
	{
		return ((ConstantPoolItemClass)constantpool[index]).GetClassType();
	}
d593 1
a593 4
	internal string GetConstantPoolUtf8String(int index)
	{
		string s = utf8_cp[index];
		if(s == null)
d595 2
a596 1
			if(this_class == 0)
d598 8
a605 5
				throw new ClassFormatError("Bad constant pool index #{0}", index);
			}
			else
			{
				throw new ClassFormatError("{0} (Bad constant pool index #{1})", this.Name, index);
d607 1
a608 2
		return s;
	}
d610 4
a613 4
	internal ConstantType GetConstantPoolConstantType(int index)
	{
		return constantpool[index].GetConstantType();
	}
d615 4
a618 4
	internal double GetConstantPoolConstantDouble(int index)
	{
		return ((ConstantPoolItemDouble)constantpool[index]).Value;
	}
d620 4
a623 4
	internal float GetConstantPoolConstantFloat(int index)
	{
		return ((ConstantPoolItemFloat)constantpool[index]).Value;
	}
d625 4
a628 4
	internal int GetConstantPoolConstantInteger(int index)
	{
		return ((ConstantPoolItemInteger)constantpool[index]).Value;
	}
d630 4
a633 4
	internal long GetConstantPoolConstantLong(int index)
	{
		return ((ConstantPoolItemLong)constantpool[index]).Value;
	}
d635 4
a638 4
	internal string GetConstantPoolConstantString(int index)
	{
		return ((ConstantPoolItemString)constantpool[index]).Value;
	}
d640 1
a640 3
	internal string Name
	{
		get
d642 4
a645 1
			return GetConstantPoolClass(this_class);
a646 1
	}
d648 1
a648 3
	internal string SuperClass
	{
		get
d650 4
a653 1
			return GetConstantPoolClass(super_class);
a654 1
	}
d656 1
a656 3
	internal Field[] Fields
	{
		get
d658 4
a661 1
			return fields;
a662 1
	}
d664 1
a664 3
	internal Method[] Methods
	{
		get
d666 4
a669 1
			return methods;
a670 1
	}
d672 1
a672 3
	internal ConstantPoolItemClass[] Interfaces
	{
		get
d674 4
a677 1
			return interfaces;
a678 1
	}
d680 1
a680 3
	internal string SourceFileAttribute
	{
		get
d682 4
a685 1
			return sourceFile;
a686 1
	}
d688 1
a688 3
	internal string IKVMAssemblyAttribute
	{
		get
d690 4
a693 1
			return ikvmAssembly;
a694 1
	}
d696 1
a696 3
	internal bool DeprecatedAttribute
	{
		get
d698 4
a701 1
			return deprecated;
a702 9
	}

	internal struct InnerClass
	{
		internal ushort innerClass;		// ConstantPoolItemClass
		internal ushort outerClass;		// ConstantPoolItemClass
		internal ushort name;			// ConstantPoolItemUtf8
		internal Modifiers accessFlags;
	}
d704 1
a704 3
	internal InnerClass[] InnerClasses
	{
		get
d706 4
a709 1
			return innerClasses;
a710 1
	}
d712 1
a712 13
	internal enum ConstantType
	{
		Integer,
		Long,
		Float,
		Double,
		String,
		Class
	}

	internal abstract class ConstantPoolItem
	{
		internal virtual void Resolve(ClassFile classFile)
d714 4
d720 1
a720 1
		internal virtual void Link(TypeWrapper thisType, Hashtable classCache)
d722 6
d730 1
a730 1
		internal virtual ConstantType GetConstantType()
d732 3
a734 3
			throw new InvalidOperationException();
		}
	}
d736 3
a738 5
	internal sealed class ConstantPoolItemClass : ConstantPoolItem
	{
		private ushort name_index;
		private string name;
		private TypeWrapper typeWrapper;
d740 4
a743 3
		internal ConstantPoolItemClass(BigEndianBinaryReader br)
		{
			name_index = br.ReadUInt16();
d746 1
a746 1
		internal override void Resolve(ClassFile classFile)
d748 5
a752 2
			name = classFile.GetConstantPoolUtf8String(name_index);
			if(name.Length > 0)
d754 7
a760 2
				char prev = name[0];
				if(Char.IsLetter(prev) || prev == '$' || prev == '_' || prev == '[')
d762 2
a763 3
					int skip = 1;
					int end = name.Length;
					if(prev == '[')
d765 3
a767 2
						// TODO optimize this
						if(!IsValidFieldSig(name))
d769 13
a781 1
							goto barf;
d783 1
a783 1
						while(name[skip] == '[')
d785 6
a790 5
							skip++;
						}
						if(name.EndsWith(";"))
						{
							end--;
d792 2
a794 11
					for(int i = skip; i < end; i++)
					{
						char c = name[i];
						if(!Char.IsLetterOrDigit(c) && c != '$' && c != '_' && (c != '/' || prev == '/'))
						{
							goto barf;
						}
						prev = c;
					}
					name = String.Intern(name.Replace('/', '.'));
					return;
d796 2
a798 3
			barf:
			throw new ClassFormatError("Invalid class name \"{0}\"", name);
		}
d800 1
a800 3
		internal override void Link(TypeWrapper thisType, Hashtable classCache)
		{
			if(typeWrapper == null)
d802 4
a805 1
				typeWrapper = LoadClassHelper(thisType.GetClassLoader(), classCache, name);
a806 1
		}
d808 1
a808 3
		internal string Name
		{
			get
d810 4
a813 1
				return name;
a814 12
		}

		internal TypeWrapper GetClassType()
		{
			return typeWrapper;
		}

		internal override ConstantType GetConstantType()
		{
			return ConstantType.Class;
		}
	}
d816 1
a816 6
	private static TypeWrapper LoadClassHelper(ClassLoaderWrapper classLoader, Hashtable classCache, string name)
	{
		try
		{
			TypeWrapper wrapper = (TypeWrapper)classCache[name];
			if(wrapper != null)
d818 1
a818 1
				return wrapper;
d820 2
a821 2
			wrapper = classLoader.LoadClassByDottedNameFast(name);
			if(wrapper == null)
d823 1
a823 2
				Tracer.Error(Tracer.ClassLoading, "Class not found: {0}", name);
				wrapper = new UnloadableTypeWrapper(name);
a824 1
			return wrapper;
d826 2
a827 1
		catch(Exception x)
d829 16
a844 2
			// TODO it might not be a good idea to catch .NET system exceptions here
			if(!JVM.IsStaticCompiler && Tracer.ClassLoading.TraceError)
d846 2
a847 2
				object cl = classLoader.GetJavaClassLoader();
				if(cl != null)
d849 2
a850 3
					System.Text.StringBuilder sb = new System.Text.StringBuilder();
					Type type = cl.GetType();
					while(type.FullName != "java.lang.ClassLoader")
d852 8
a859 7
						type = type.BaseType;
					}
					System.Reflection.FieldInfo parentField = type.GetField("parent", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
					if(parentField != null)
					{
						string sep = "";
						while(cl != null)
d861 7
a867 3
							sb.Append(sep).Append(cl);
							sep = " -> ";
							cl = parentField.GetValue(cl);
d869 1
d871 2
a872 1
					Tracer.Error(Tracer.ClassLoading, "ClassLoader chain: {0}", sb);
d874 1
a874 2
				x = IKVM.Runtime.Util.MapException(x);
				Tracer.Error(Tracer.ClassLoading, x.ToString() + Environment.NewLine + x.StackTrace);
a875 1
			return new UnloadableTypeWrapper(name);
a876 1
	}
d878 1
a878 3
	private static TypeWrapper SigDecoderWrapper(ClassLoaderWrapper classLoader, Hashtable classCache, ref int index, string sig)
	{
		switch(sig[index++])
d880 15
a894 29
			case 'B':
				return PrimitiveTypeWrapper.BYTE;
			case 'C':
				return PrimitiveTypeWrapper.CHAR;
			case 'D':
				return PrimitiveTypeWrapper.DOUBLE;
			case 'F':
				return PrimitiveTypeWrapper.FLOAT;
			case 'I':
				return PrimitiveTypeWrapper.INT;
			case 'J':
				return PrimitiveTypeWrapper.LONG;
			case 'L':
			{
				int pos = index;
				index = sig.IndexOf(';', index) + 1;
				return LoadClassHelper(classLoader, classCache, sig.Substring(pos, index - pos - 1));
			}
			case 'S':
				return PrimitiveTypeWrapper.SHORT;
			case 'Z':
				return PrimitiveTypeWrapper.BOOLEAN;
			case 'V':
				return PrimitiveTypeWrapper.VOID;
			case '[':
			{
				// TODO this can be optimized
				string array = "[";
				while(sig[index] == '[')
d896 3
a898 2
					index++;
					array += "[";
d900 7
a906 1
				switch(sig[index])
d908 8
a915 1
					case 'L':
d917 18
a934 3
						int pos = index;
						index = sig.IndexOf(';', index) + 1;
						return LoadClassHelper(classLoader, classCache, array + sig.Substring(pos, index - pos));
a935 12
					case 'B':
					case 'C':
					case 'D':
					case 'F':
					case 'I':
					case 'J':
					case 'S':
					case 'Z':
						return LoadClassHelper(classLoader, classCache, array + sig[index++]);
					default:
						// TODO this should never happen, because ClassFile should validate the descriptors
						throw new InvalidOperationException(sig.Substring(index));
d937 3
a940 3
			default:
				// TODO this should never happen, because ClassFile should validate the descriptors
				throw new InvalidOperationException(sig.Substring(index));
a941 1
	}
d943 1
a943 3
	internal static TypeWrapper[] ArgTypeWrapperListFromSig(ClassLoaderWrapper classLoader, Hashtable classCache, string sig)
	{
		if(sig[1] == ')')
d945 12
a956 1
			return TypeWrapper.EmptyArray;
d958 2
a959 2
		ArrayList list = new ArrayList();
		for(int i = 1; sig[i] != ')';)
d961 2
a962 1
			list.Add(SigDecoderWrapper(classLoader, classCache, ref i, sig));
a963 16
		TypeWrapper[] types = new TypeWrapper[list.Count];
		list.CopyTo(types);
		return types;
	}

	internal static TypeWrapper FieldTypeWrapperFromSig(ClassLoaderWrapper classLoader, Hashtable classCache, string sig)
	{
		int index = 0;
		return SigDecoderWrapper(classLoader, classCache, ref index, sig);
	}

	internal static TypeWrapper RetTypeWrapperFromSig(ClassLoaderWrapper classLoader, Hashtable classCache, string sig)
	{
		int index = sig.IndexOf(')') + 1;
		return SigDecoderWrapper(classLoader, classCache, ref index, sig);
	}
d965 1
a965 5
	private sealed class ConstantPoolItemDouble : ConstantPoolItem
	{
		private double d;

		internal ConstantPoolItemDouble(BigEndianBinaryReader br)
d967 2
a968 1
			d = br.ReadDouble();
d971 1
a971 1
		internal override ConstantType GetConstantType()
d973 1
a973 2
			return ConstantType.Double;
		}
d975 1
a975 3
		internal double Value
		{
			get
d977 1
a977 1
				return d;
a978 2
		}
	}
d980 4
a983 7
	internal abstract class ConstantPoolItemFMI : ConstantPoolItem
	{
		private ushort class_index;
		private ushort name_and_type_index;
		private ConstantPoolItemClass clazz;
		private string name;
		private string descriptor;
d985 7
a991 4
		internal ConstantPoolItemFMI(BigEndianBinaryReader br)
		{
			class_index = br.ReadUInt16();
			name_and_type_index = br.ReadUInt16();
d994 1
a994 1
		internal override void Resolve(ClassFile classFile)
d996 13
a1008 4
			ConstantPoolItemNameAndType name_and_type = (ConstantPoolItemNameAndType)classFile.GetConstantPoolItem(name_and_type_index);
			clazz = (ConstantPoolItemClass)classFile.GetConstantPoolItem(class_index);
			// if the constant pool items referred to were strings, GetConstantPoolItem returns null
			if(name_and_type == null || clazz == null)
d1010 11
a1020 1
				throw new ClassFormatError("Bad index in constant pool");
a1021 5
			name = String.Intern(classFile.GetConstantPoolUtf8String(name_and_type.name_index));
			descriptor = classFile.GetConstantPoolUtf8String(name_and_type.descriptor_index);
			Validate(name, descriptor);
			descriptor = String.Intern(descriptor.Replace('/', '.'));
		}
d1023 1
a1023 1
		protected abstract void Validate(string name, string descriptor);
d1025 4
a1028 4
		internal override void Link(TypeWrapper thisType, Hashtable classCache)
		{
			clazz.Link(thisType, classCache);
		}
d1030 1
a1030 3
		internal string Name
		{
			get
d1032 4
a1035 1
				return name;
a1036 1
		}
d1038 1
a1038 3
		internal string Signature
		{
			get
d1040 4
a1043 1
				return descriptor;
a1044 1
		}
d1046 1
a1046 3
		internal string Class
		{
			get
d1048 4
a1051 1
				return clazz.Name;
a1052 1
		}
d1054 4
a1057 3
		internal TypeWrapper GetClassType()
		{
			return clazz.GetClassType();
a1058 6
	}

	internal sealed class ConstantPoolItemFieldref : ConstantPoolItemFMI
	{
		private FieldWrapper field;
		private TypeWrapper fieldTypeWrapper;
d1060 1
a1060 1
		internal ConstantPoolItemFieldref(BigEndianBinaryReader br) : base(br)
d1062 2
a1063 1
		}
d1065 1
a1065 3
		protected override void Validate(string name, string descriptor)
		{
			if(!IsValidFieldSig(descriptor))
a1066 1
				throw new ClassFormatError("Invalid field signature \"{0}\"", descriptor);
d1068 2
a1069 1
			if(!IsValidIdentifier(name))
d1071 8
a1078 1
				throw new ClassFormatError("Invalid field name \"{0}\"", name);
a1079 1
		}
d1081 4
a1084 4
		internal TypeWrapper GetFieldType()
		{
			return fieldTypeWrapper;
		}
d1086 1
a1086 4
		internal override void Link(TypeWrapper thisType, Hashtable classCache)
		{
			base.Link(thisType, classCache);
			if(fieldTypeWrapper == null)
d1088 2
a1089 4
				ClassLoaderWrapper classLoader = thisType.GetClassLoader();
				fieldTypeWrapper = FieldTypeWrapperFromSig(classLoader, classCache, this.Signature);
				TypeWrapper wrapper = GetClassType();
				if(!wrapper.IsUnloadable)
d1091 4
a1094 2
					field = wrapper.GetFieldWrapper(Name, Signature);
					if(field != null)
d1096 2
a1097 2
						bool ok = false;
						try
d1099 7
a1105 6
							field.Link();
							ok = true;
						}
						finally
						{
							if(!ok)
d1107 4
a1110 1
								fieldTypeWrapper = null;
a1115 1
		}
d1117 4
a1120 3
		internal FieldWrapper GetField()
		{
			return field;
a1121 1
	}
d1123 1
a1123 8
	internal class ConstantPoolItemMI : ConstantPoolItemFMI
	{
		private TypeWrapper[] argTypeWrappers;
		private TypeWrapper retTypeWrapper;
		protected MethodWrapper method;
		protected MethodWrapper invokespecialMethod;

		internal ConstantPoolItemMI(BigEndianBinaryReader br) : base(br)
d1125 4
a1128 1
		}
d1130 1
a1130 3
		protected override void Validate(string name, string descriptor)
		{
			if(!IsValidMethodSig(descriptor))
a1131 1
				throw new ClassFormatError("Method {0} has invalid signature {1}", name, descriptor);
d1133 2
a1134 1
			if(name == "<init>" || name == "<clinit>")
d1136 1
a1136 1
				if(!descriptor.EndsWith("V"))
d1140 22
d1163 2
a1164 1
			else if(!IsValidIdentifier(name))
d1166 1
a1166 1
				throw new ClassFormatError("Invalid method name \"{0}\"", name);
a1167 1
		}
d1169 1
a1169 4
		internal override void Link(TypeWrapper thisType, Hashtable classCache)
		{
			base.Link(thisType, classCache);
			if(argTypeWrappers == null)
d1171 1
a1171 3
				ClassLoaderWrapper classLoader = thisType.GetClassLoader();
				argTypeWrappers = ArgTypeWrapperListFromSig(classLoader, classCache, this.Signature);
				retTypeWrapper = RetTypeWrapperFromSig(classLoader, classCache, this.Signature);
a1172 1
		}
d1174 4
a1177 4
		internal TypeWrapper[] GetArgTypes()
		{
			return argTypeWrappers;
		}
d1179 4
a1182 3
		internal TypeWrapper GetRetType()
		{
			return retTypeWrapper;
d1185 1
a1185 1
		internal MethodWrapper GetMethod()
d1187 3
a1189 2
			return method;
		}
d1191 23
a1213 3
		internal MethodWrapper GetMethodForInvokespecial()
		{
			return invokespecialMethod != null ? invokespecialMethod : method;
a1214 1
	}
d1216 1
a1216 3
	internal sealed class ConstantPoolItemMethodref : ConstantPoolItemMI
	{
		internal ConstantPoolItemMethodref(BigEndianBinaryReader br) : base(br)
d1218 3
a1220 1
		}
d1222 1
a1222 5
		internal override void Link(TypeWrapper thisType, Hashtable classCache)
		{
			base.Link(thisType, classCache);
			TypeWrapper wrapper = GetClassType();
			if(!wrapper.IsUnloadable)
d1224 1
a1224 1
				method = wrapper.GetMethodWrapper(Name, Signature, Name != "<init>");
d1227 10
a1236 1
					method.Link();
d1238 8
a1245 3
				if(Name != "<init>" && 
					(thisType.Modifiers & (Modifiers.Interface | Modifiers.Super)) == Modifiers.Super &&
					thisType != wrapper && thisType.IsSubTypeOf(wrapper))
d1247 2
a1248 2
					invokespecialMethod = thisType.BaseTypeWrapper.GetMethodWrapper(Name, Signature, true);
					if(invokespecialMethod != null)
d1250 6
a1255 1
						invokespecialMethod.Link();
a1259 1
	}
d1261 1
a1261 3
	internal sealed class ConstantPoolItemInterfaceMethodref : ConstantPoolItemMI
	{
		internal ConstantPoolItemInterfaceMethodref(BigEndianBinaryReader br) : base(br)
d1263 6
a1268 1
		}
d1270 1
a1270 4
		private static MethodWrapper GetInterfaceMethod(TypeWrapper wrapper, string name, string sig)
		{
			MethodWrapper method = wrapper.GetMethodWrapper(name, sig, false);
			if(method != null)
d1272 1
a1272 1
				return method;
d1274 2
a1275 2
			TypeWrapper[] interfaces = wrapper.Interfaces;
			for(int i = 0; i < interfaces.Length; i++)
d1277 1
a1277 2
				method = GetInterfaceMethod(interfaces[i], name, sig);
				if(method != null)
d1279 1
a1279 1
					return method;
a1281 1
			return null;
d1284 1
a1284 1
		internal override void Link(TypeWrapper thisType, Hashtable classCache)
d1286 13
a1298 3
			base.Link(thisType, classCache);
			TypeWrapper wrapper = GetClassType();
			if(!wrapper.IsUnloadable)
d1300 1
a1300 7
				method = GetInterfaceMethod(wrapper, Name, Signature);
				if(method == null)
				{
					// NOTE vmspec 5.4.3.4 clearly states that an interfacemethod may also refer to a method in Object
					method = CoreClasses.java.lang.Object.Wrapper.GetMethodWrapper(Name, Signature, false);
				}
				if(method != null)
d1302 1
a1302 1
					method.Link();
a1305 5
	}

	private sealed class ConstantPoolItemFloat : ConstantPoolItem
	{
		private float v;
d1307 1
a1307 1
		internal ConstantPoolItemFloat(BigEndianBinaryReader br)
d1309 1
a1309 2
			v = br.ReadSingle();
		}
d1311 4
a1314 4
		internal override ConstantType GetConstantType()
		{
			return ConstantType.Float;
		}
d1316 1
a1316 3
		internal float Value
		{
			get
d1318 1
a1318 1
				return v;
a1319 16
		}
	}

	private sealed class ConstantPoolItemInteger : ConstantPoolItem
	{
		private int v;

		internal ConstantPoolItemInteger(BigEndianBinaryReader br)
		{
			v = br.ReadInt32();
		}

		internal override ConstantType GetConstantType()
		{
			return ConstantType.Integer;
		}
d1321 1
a1321 3
		internal int Value
		{
			get
d1323 4
a1326 1
				return v;
a1328 5
	}

	private sealed class ConstantPoolItemLong : ConstantPoolItem
	{
		private long l;
d1330 1
a1330 1
		internal ConstantPoolItemLong(BigEndianBinaryReader br)
d1332 8
a1339 1
			l = br.ReadInt64();
d1342 1
a1342 1
		internal override ConstantType GetConstantType()
d1344 2
a1345 2
			return ConstantType.Long;
		}
d1347 1
a1347 3
		internal long Value
		{
			get
d1349 1
a1349 1
				return l;
a1350 2
		}
	}
d1352 4
a1355 4
	internal sealed class ConstantPoolItemNameAndType : ConstantPoolItem
	{
		internal ushort name_index;
		internal ushort descriptor_index;
d1357 4
a1360 6
		internal ConstantPoolItemNameAndType(BigEndianBinaryReader br)
		{
			name_index = br.ReadUInt16();
			descriptor_index = br.ReadUInt16();
		}
	}
d1362 7
a1368 8
	private sealed class ConstantPoolItemString : ConstantPoolItem
	{
		private ushort string_index;
		private string s;

		internal ConstantPoolItemString(BigEndianBinaryReader br)
		{
			string_index = br.ReadUInt16();
d1371 1
a1371 1
		internal override void Resolve(ClassFile classFile)
d1373 11
a1383 1
			s = classFile.GetConstantPoolUtf8String(string_index);
d1386 1
a1386 1
		internal override ConstantType GetConstantType()
d1388 4
a1391 2
			return ConstantType.String;
		}
d1393 1
a1393 3
		internal string Value
		{
			get
d1395 5
a1399 1
				return s;
a1400 33
		}
	}

	internal enum Constant
	{
		Utf8 = 1,
		Integer = 3,
		Float = 4,
		Long = 5,
		Double = 6,
		Class = 7,
		String = 8,
		Fieldref = 9,
		Methodref = 10,
		InterfaceMethodref = 11,
		NameAndType = 12
	}

	internal abstract class FieldOrMethod
	{
		protected Modifiers access_flags;
		private string name;
		private string descriptor;
		protected bool deprecated;

		internal FieldOrMethod(ClassFile classFile, BigEndianBinaryReader br)
		{
			access_flags = (Modifiers)br.ReadUInt16();
			name = String.Intern(classFile.GetConstantPoolUtf8String(br.ReadUInt16()));
			descriptor = classFile.GetConstantPoolUtf8String(br.ReadUInt16());
			ValidateSig(classFile, descriptor);
			descriptor = String.Intern(descriptor.Replace('/', '.'));
		}
d1402 1
a1402 1
		protected abstract void ValidateSig(ClassFile classFile, string descriptor);
d1404 1
a1404 3
		internal string Name
		{
			get
d1406 4
a1409 1
				return name;
a1410 1
		}
d1412 1
a1412 3
		internal string Signature
		{
			get
d1414 4
a1417 1
				return descriptor;
a1418 1
		}
d1420 1
a1420 3
		internal Modifiers Modifiers
		{
			get
d1422 4
a1425 1
				return (Modifiers)access_flags;
a1426 1
		}
d1428 1
a1428 3
		internal bool IsAbstract
		{
			get
d1430 4
a1433 1
				return (access_flags & Modifiers.Abstract) != 0;
a1434 1
		}
d1436 1
a1436 3
		internal bool IsFinal
		{
			get
d1438 4
a1441 1
				return (access_flags & Modifiers.Final) != 0;
a1442 1
		}
d1444 1
a1444 3
		internal bool IsPublic
		{
			get
d1446 4
a1449 1
				return (access_flags & Modifiers.Public) != 0;
a1450 1
		}
d1452 1
a1452 3
		internal bool IsPrivate
		{
			get
d1454 4
a1457 1
				return (access_flags & Modifiers.Private) != 0;
a1458 1
		}
d1460 1
a1460 3
		internal bool IsProtected
		{
			get
d1462 4
a1465 1
				return (access_flags & Modifiers.Protected) != 0;
a1466 1
		}
d1468 1
a1468 3
		internal bool IsStatic
		{
			get
d1470 4
a1473 1
				return (access_flags & Modifiers.Static) != 0;
a1474 1
		}
d1476 1
a1476 3
		internal bool IsSynchronized
		{
			get
d1478 4
a1481 1
				return (access_flags & Modifiers.Synchronized) != 0;
a1482 1
		}
d1484 1
a1484 3
		internal bool IsVolatile
		{
			get
d1486 4
a1489 1
				return (access_flags & Modifiers.Volatile) != 0;
a1490 1
		}
d1492 1
a1492 3
		internal bool IsTransient
		{
			get
d1494 4
a1497 1
				return (access_flags & Modifiers.Transient) != 0;
a1498 1
		}
d1500 1
a1500 3
		internal bool IsNative
		{
			get
d1502 4
a1505 1
				return (access_flags & Modifiers.Native) != 0;
a1506 1
		}
d1508 1
a1508 3
		internal bool DeprecatedAttribute
		{
			get
d1510 4
a1513 1
				return deprecated;
a1515 1
	}
d1517 3
a1519 3
	internal sealed class Field : FieldOrMethod
	{
		private object constantValue;
d1521 1
a1521 5
		internal Field(ClassFile classFile, BigEndianBinaryReader br) : base(classFile, br)
		{
			if((IsPrivate && IsPublic) || (IsPrivate && IsProtected) || (IsPublic && IsProtected)
				|| (IsFinal && IsVolatile)
				|| (classFile.IsInterface && (!IsPublic || !IsStatic || !IsFinal || IsTransient)))
d1523 8
a1530 6
				throw new ClassFormatError("{0} (Illegal field modifiers: 0x{1:X})", classFile.Name, access_flags);
			}
			int attributes_count = br.ReadUInt16();
			for(int i = 0; i < attributes_count; i++)
			{
				switch(classFile.GetConstantPoolUtf8String(br.ReadUInt16()))
d1532 1
a1532 5
					case "Deprecated":
						deprecated = true;
						br.Skip(br.ReadUInt32());
						break;
					case "ConstantValue":
d1534 5
a1538 1
						if(br.ReadUInt32() != 2)
d1540 53
a1592 6
							throw new ClassFormatError("Invalid ConstantValue attribute length");
						}
						ushort index = br.ReadUInt16();
						try
						{
							switch(Signature)
d1594 1
a1594 29
								case "I":
									constantValue = classFile.GetConstantPoolConstantInteger(index);
									break;
								case "S":
									constantValue = (short)classFile.GetConstantPoolConstantInteger(index);
									break;
								case "B":
									constantValue = (byte)classFile.GetConstantPoolConstantInteger(index);
									break;
								case "C":
									constantValue = (char)classFile.GetConstantPoolConstantInteger(index);
									break;
								case "Z":
									constantValue = classFile.GetConstantPoolConstantInteger(index) != 0;
									break;
								case "J":
									constantValue = classFile.GetConstantPoolConstantLong(index);
									break;
								case "F":
									constantValue = classFile.GetConstantPoolConstantFloat(index);
									break;
								case "D":
									constantValue = classFile.GetConstantPoolConstantDouble(index);
									break;
								case "Ljava.lang.String;":
									constantValue = classFile.GetConstantPoolConstantString(index);
									break;
								default:
									throw new ClassFormatError("{0} (Invalid signature for constant)", classFile.Name);
d1596 1
d1598 3
a1600 17
						catch(InvalidCastException)
						{
							throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
						}
						catch(IndexOutOfRangeException)
						{
							throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
						}
						catch(InvalidOperationException)
						{
							throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
						}
						catch(NullReferenceException)
						{
							throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
						}
						break;
a1601 3
					default:
						br.Skip(br.ReadUInt32());
						break;
a1603 1
		}
d1605 1
a1605 3
		protected override void ValidateSig(ClassFile classFile, string descriptor)
		{
			if(!IsValidFieldSig(descriptor))
d1607 4
a1610 1
				throw new ClassFormatError("{0} (Field \"{1}\" has invalid signature \"{2}\")", classFile.Name, this.Name, descriptor);
a1611 1
		}
d1613 1
a1613 3
		internal object ConstantValue
		{
			get
d1615 4
a1618 1
				return constantValue;
a1620 1
	}
d1622 4
a1625 4
	internal sealed class Method : FieldOrMethod
	{
		private Code code;
		private string[] exceptions;
d1627 1
a1627 9
		internal Method(ClassFile classFile, BigEndianBinaryReader br) : base(classFile, br)
		{
			// vmspec 4.6 says that all flags, except ACC_STRICT are ignored on <clinit>
			if(Name == "<clinit>" && Signature == "()V")
			{
				access_flags &= Modifiers.Strictfp;
				access_flags |= (Modifiers.Static | Modifiers.Private);
			}
			else
d1629 2
a1630 6
				// LAMESPEC: vmspec 4.6 says that abstract methods can not be strictfp (and this makes sense), but
				// javac (pre 1.5) is broken and marks abstract methods as strictfp (if you put the strictfp on the class)
				if((Name == "<init>" && (IsStatic || IsSynchronized || IsFinal || IsAbstract || IsNative))
					|| (IsPrivate && IsPublic) || (IsPrivate && IsProtected) || (IsPublic && IsProtected)
					|| (IsAbstract && (IsFinal || IsNative || IsPrivate || IsStatic || IsSynchronized))
					|| (classFile.IsInterface && (!IsPublic || !IsAbstract)))
d1632 2
a1633 1
					throw new ClassFormatError("{0} (Illegal method modifiers: 0x{1:X})", classFile.Name, access_flags);
d1635 1
a1635 5
			}
			int attributes_count = br.ReadUInt16();
			for(int i = 0; i < attributes_count; i++)
			{
				switch(classFile.GetConstantPoolUtf8String(br.ReadUInt16()))
d1637 6
a1642 5
					case "Deprecated":
						deprecated = true;
						br.Skip(br.ReadUInt32());
						break;
					case "Code":
d1644 1
a1644 11
						if(!code.IsEmpty)
						{
							throw new ClassFormatError("{0} (Duplicate Code attribute)", classFile.Name);
						}
						BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
						code.Read(classFile, this, rdr);
						if(!rdr.IsAtEnd)
						{
							throw new ClassFormatError("{0} (Code attribute has wrong length)", classFile.Name);
						}
						break;
d1646 5
a1650 1
					case "Exceptions":
d1652 5
a1656 1
						if(exceptions != null)
d1658 11
a1668 1
							throw new ClassFormatError("{0} (Duplicate Exceptions attribute)", classFile.Name);
d1670 1
a1670 4
						BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
						ushort count = rdr.ReadUInt16();
						exceptions = new string[count];
						for(int j = 0; j < count; j++)
d1672 16
a1687 1
							exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());
d1689 3
a1691 5
						if(!rdr.IsAtEnd)
						{
							throw new ClassFormatError("{0} (Exceptions attribute has wrong length)", classFile.Name);
						}
						break;
a1692 3
					default:
						br.Skip(br.ReadUInt32());
						break;
d1694 1
a1694 4
			}
			if(IsAbstract || IsNative)
			{
				if(!code.IsEmpty)
d1696 4
a1699 1
					throw new ClassFormatError("Abstract or native method cannot have a Code attribute");
d1701 1
a1701 4
			}
			else
			{
				if(code.IsEmpty)
d1703 1
a1703 1
					if(this.Name == "<clinit>")
d1705 6
a1710 2
						code.verifyError = string.Format("Class {0}, method {1} signature {2}: No Code attribute", classFile.Name, this.Name, this.Signature);
						return;
a1711 1
					throw new ClassFormatError("Method has no Code attribute");
a1713 1
		}
d1715 1
a1715 3
		protected override void ValidateSig(ClassFile classFile, string descriptor)
		{
			if(!IsValidMethodSig(descriptor))
d1717 4
a1720 1
				throw new ClassFormatError("{0} (Method \"{1}\" has invalid signature \"{2}\")", classFile.Name, this.Name, descriptor);
a1721 1
		}
d1723 1
a1723 3
		internal bool IsStrictfp
		{
			get
d1725 4
a1728 1
				return (access_flags & Modifiers.Strictfp) != 0;
a1729 1
		}
d1731 2
a1732 4
		// Is this the <clinit>()V method?
		internal bool IsClassInitializer
		{
			get
d1734 4
a1737 1
				return Name == "<clinit>" && Signature == "()V";
a1738 1
		}
d1740 1
a1740 3
		internal string[] ExceptionsAttribute
		{
			get
d1742 4
a1745 1
				return exceptions;
a1746 1
		}
d1748 1
a1748 3
		internal string VerifyError
		{
			get
d1750 4
a1753 1
				return code.verifyError;
a1754 1
		}
d1756 2
a1757 4
		// maps argument 'slot' (as encoded in the xload/xstore instructions) into the ordinal
		internal int[] ArgMap
		{
			get
d1759 4
a1762 1
				return code.argmap;
a1763 1
		}
d1765 1
a1765 3
		internal int MaxStack
		{
			get
d1767 4
a1770 1
				return code.max_stack;
a1771 1
		}
d1773 1
a1773 3
		internal int MaxLocals
		{
			get
d1775 4
a1778 1
				return code.max_locals;
a1779 1
		}
d1781 1
a1781 3
		internal Instruction[] Instructions
		{
			get
d1783 4
a1786 1
				return code.instructions;
a1787 1
		}
d1789 2
a1790 4
		// maps a PC to an index in the Instruction[], invalid PCs return -1
		internal int[] PcIndexMap
		{
			get
d1792 4
a1795 1
				return code.pcIndexMap;
a1796 1
		}
d1798 1
a1798 3
		internal ExceptionTableEntry[] ExceptionTable
		{
			get
d1800 4
a1803 1
				return code.exception_table;
a1804 1
		}
d1806 1
a1806 3
		internal LineNumberTableEntry[] LineNumberTableAttribute
		{
			get
d1808 4
a1811 1
				return code.lineNumberTable;
a1812 1
		}
d1814 1
a1814 3
		internal LocalVariableTableEntry[] LocalVariableTableAttribute
		{
			get
d1816 4
a1819 1
				return code.localVariableTable;
a1820 1
		}
d1822 11
a1832 11
		private struct Code
		{
			internal string verifyError;
			internal ushort max_stack;
			internal ushort max_locals;
			internal Instruction[] instructions;
			internal int[] pcIndexMap;
			internal ExceptionTableEntry[] exception_table;
			internal int[] argmap;
			internal LineNumberTableEntry[] lineNumberTable;
			internal LocalVariableTableEntry[] localVariableTable;
d1834 1
a1834 6
			internal void Read(ClassFile classFile, Method method, BigEndianBinaryReader br)
			{
				max_stack = br.ReadUInt16();
				max_locals = br.ReadUInt16();
				uint code_length = br.ReadUInt32();
				if(code_length > 65536)
d1836 21
a1856 9
					throw new ClassFormatError("{0} (Invalid Code length {1})", classFile.Name, code_length);
				}
				Instruction[] instructions = new Instruction[code_length + 1];
				int basePosition = br.Position;
				int instructionIndex = 0;
				try
				{
					BigEndianBinaryReader rdr = br.Section(code_length);
					while(!rdr.IsAtEnd)
d1858 2
a1859 1
						instructions[instructionIndex++].Read((ushort)(rdr.Position - basePosition), rdr);
d1861 15
a1875 25
					// we add an additional nop instruction to make it easier for consumers of the code array
					instructions[instructionIndex++].SetTermNop((ushort)(rdr.Position - basePosition));
				}
				catch(ClassFormatError x)
				{
					// any class format errors in the code block are actually verify errors
					verifyError = x.Message;
				}
				this.instructions = new Instruction[instructionIndex];
				Array.Copy(instructions, 0, this.instructions, 0, instructionIndex);
				ushort exception_table_length = br.ReadUInt16();
				exception_table = new ExceptionTableEntry[exception_table_length];
				for(int i = 0; i < exception_table_length; i++)
				{
					exception_table[i] = new ExceptionTableEntry();
					exception_table[i].start_pc = br.ReadUInt16();
					exception_table[i].end_pc = br.ReadUInt16();
					exception_table[i].handler_pc = br.ReadUInt16();
					exception_table[i].catch_type = br.ReadUInt16();
					exception_table[i].ordinal = i;
				}
				ushort attributes_count = br.ReadUInt16();
				for(int i = 0; i < attributes_count; i++)
				{
					switch(classFile.GetConstantPoolUtf8String(br.ReadUInt16()))
d1877 8
a1884 11
						case "LineNumberTable":
							if(JVM.NoStackTraceInfo)
							{
								br.Skip(br.ReadUInt32());
							}
							else
							{
								BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
								int count = rdr.ReadUInt16();
								lineNumberTable = new LineNumberTableEntry[count];
								for(int j = 0; j < count; j++)
d1886 4
a1889 3
									lineNumberTable[j].start_pc = rdr.ReadUInt16();
									lineNumberTable[j].line_number = rdr.ReadUInt16();
									if(lineNumberTable[j].start_pc >= code_length)
d1891 10
a1900 1
										throw new ClassFormatError("{0} (LineNumberTable has invalid pc)", classFile.Name);
d1903 3
a1905 1
								if(!rdr.IsAtEnd)
d1907 13
a1919 1
									throw new ClassFormatError("{0} (LineNumberTable attribute has wrong length)", classFile.Name);
d1921 1
a1921 9
							}
							break;
						case "LocalVariableTable":
							if(JVM.Debug || JVM.IsStaticCompiler)
							{
								BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
								int count = rdr.ReadUInt16();
								localVariableTable = new LocalVariableTableEntry[count];
								for(int j = 0; j < count; j++)
d1923 1
a1923 5
									localVariableTable[j].start_pc = rdr.ReadUInt16();
									localVariableTable[j].length = rdr.ReadUInt16();
									localVariableTable[j].name = classFile.GetConstantPoolUtf8String(rdr.ReadUInt16());
									localVariableTable[j].descriptor = classFile.GetConstantPoolUtf8String(rdr.ReadUInt16()).Replace('/', '.');
									localVariableTable[j].index = rdr.ReadUInt16();
d1925 2
a1926 5
								// NOTE we're intentionally not checking that we're at the end of the section
								// (optional attributes shouldn't cause ClassFormatError)
							}
							else
							{
d1928 20
a1947 5
							}
							break;
						default:
							br.Skip(br.ReadUInt32());
							break;
d1949 1
a1949 23
				}
				// build the pcIndexMap
				pcIndexMap = new int[this.instructions[instructionIndex - 1].PC + 1];
				for(int i = 0; i < pcIndexMap.Length; i++)
				{
					pcIndexMap[i] = -1;
				}
				for(int i = 0; i < instructionIndex - 1; i++)
				{
					pcIndexMap[this.instructions[i].PC] = i;
				}
				// build the argmap
				string sig = method.Signature;
				ArrayList args = new ArrayList();
				int pos = 0;
				if(!method.IsStatic)
				{
					args.Add(pos++);
				}
				for(int i = 1; sig[i] != ')'; i++)
				{
					args.Add(pos++);
					switch(sig[i])
d1951 2
a1952 8
						case 'L':
							i = sig.IndexOf(';', i);
							break;
						case 'D':
						case 'J':
							args.Add(-1);
							break;
						case '[':
d1954 8
a1961 1
							while(sig[i] == '[')
d1963 9
a1971 5
								i++;
							}
							if(sig[i] == 'L')
							{
								i = sig.IndexOf(';', i);
a1972 1
							break;
d1975 6
d1982 2
a1983 3
				argmap = new int[args.Count];
				args.CopyTo(argmap);
				if(args.Count > max_locals)
d1985 4
a1988 1
					throw new ClassFormatError("{0} (Arguments can't fit into locals)", classFile.Name);
d1992 1
a1992 1
			internal bool IsEmpty
d1994 5
a1998 4
				get
				{
					return instructions == null;
				}
a1999 1
		}
d2001 8
a2008 8
		internal sealed class ExceptionTableEntry
		{
			internal ushort start_pc;
			internal ushort end_pc;
			internal ushort handler_pc;
			internal ushort catch_type;
			internal int ordinal;
		}
d2010 5
a2014 8
		internal struct Instruction
		{
			private ushort pc;
			private ByteCode opcode;
			private NormalizedByteCode normopcode;
			private int arg1;
			private short arg2;
			private SwitchEntry[] switch_entries;
d2016 6
a2021 12
			struct SwitchEntry
			{
				internal int value;
				internal int target_offset;
			}

			internal void SetTermNop(ushort pc)
			{
				// TODO what happens if we already have exactly the maximum number of instructions?
				this.pc = pc;
				this.opcode = ByteCode.__nop;
			}
d2023 1
a2023 5
			internal void Read(ushort pc, BigEndianBinaryReader br)
			{
				this.pc = pc;
				ByteCode bc = (ByteCode)br.ReadByte();
				switch(ByteCodeMetaData.GetMode(bc))
d2025 3
a2027 38
					case ByteCodeMode.Simple:
						break;
					case ByteCodeMode.Constant_1:
					case ByteCodeMode.Local_1:
						arg1 = br.ReadByte();
						break;
					case ByteCodeMode.Constant_2:
						arg1 = br.ReadUInt16();
						break;
					case ByteCodeMode.Branch_2:
						arg1 = br.ReadInt16();
						break;
					case ByteCodeMode.Branch_4:
						arg1 = br.ReadInt32();
						break;
					case ByteCodeMode.Constant_2_1_1:
						arg1 = br.ReadUInt16();
						arg2 = br.ReadByte();
						if(br.ReadByte() != 0)
						{
							throw new ClassFormatError("invokeinterface filler must be zero");
						}
						break;
					case ByteCodeMode.Immediate_1:
						arg1 = br.ReadSByte();
						break;
					case ByteCodeMode.Immediate_2:
						arg1 = br.ReadInt16();
						break;
					case ByteCodeMode.Local_1_Immediate_1:
						arg1 = br.ReadByte();
						arg2 = br.ReadSByte();
						break;
					case ByteCodeMode.Constant_2_Immediate_1:
						arg1 = br.ReadUInt16();
						arg2 = br.ReadSByte();
						break;
					case ByteCodeMode.Tableswitch:
d2029 38
a2066 14
						// skip the padding
						uint p = pc + 1u;
						uint align = ((p + 3) & 0x7ffffffc) - p;
						br.Skip(align);
						int default_offset = br.ReadInt32();
						this.arg1 = default_offset;
						int low = br.ReadInt32();
						int high = br.ReadInt32();
						if(low > high || high > 16384L + low)
						{
							throw new ClassFormatError("Incorrect tableswitch");
						}
						SwitchEntry[] entries = new SwitchEntry[high - low + 1];
						for(int i = low; i <= high; i++)
d2068 20
a2087 18
							entries[i - low].value = i;
							entries[i - low].target_offset = br.ReadInt32();
						}
						this.switch_entries = entries;
						break;
					}
					case ByteCodeMode.Lookupswitch:
					{
						// skip the padding
						uint p = pc + 1u;
						uint align = ((p + 3) & 0x7ffffffc) - p;
						br.Skip(align);
						int default_offset = br.ReadInt32();
						this.arg1 = default_offset;
						int count = br.ReadInt32();
						if(count < 0 || count > 16384)
						{
							throw new ClassFormatError("Incorrect lookupswitch");
d2089 1
a2089 2
						SwitchEntry[] entries = new SwitchEntry[count];
						for(int i = 0; i < count; i++)
d2091 19
a2109 2
							entries[i].value = br.ReadInt32();
							entries[i].target_offset = br.ReadInt32();
d2111 4
a2114 7
						this.switch_entries = entries;
						break;
					}
					case ByteCodeMode.WidePrefix:
						bc = (ByteCode)br.ReadByte();
						// NOTE the PC of a wide instruction is actually the PC of the
						// wide prefix, not the following instruction (vmspec 4.9.2)
d2127 23
a2149 3
						break;
					default:
						throw new ClassFormatError("Invalid opcode: {0}", bc);
a2150 4
				this.opcode = bc;
				this.normopcode = ByteCodeMetaData.GetNormalizedByteCode(bc);
				arg1 = ByteCodeMetaData.GetArg(opcode, arg1);
			}
d2152 1
a2152 3
			internal int PC
			{
				get
d2154 4
a2157 1
					return pc;
a2158 1
			}
d2160 1
a2160 3
			internal ByteCode OpCode
			{
				get
d2162 4
a2165 1
					return opcode;
a2166 1
			}
d2168 1
a2168 3
			internal NormalizedByteCode NormalizedOpCode
			{
				get
d2170 4
a2173 1
					return normopcode;
a2174 1
			}
d2176 1
a2176 3
			internal int Arg1
			{
				get
d2178 4
a2181 1
					return arg1;
a2182 1
			}
d2184 1
a2184 3
			internal int Arg2
			{
				get
d2186 4
a2189 1
					return arg2;
a2190 1
			}
d2192 1
a2192 3
			internal int NormalizedArg1
			{
				get
d2194 4
a2197 1
					return arg1;
a2198 1
			}
d2200 1
a2200 3
			internal int DefaultOffset
			{
				get
d2202 1
a2202 1
					return arg1;
a2203 1
			}
d2205 1
a2205 3
			internal int SwitchEntryCount
			{
				get
d2207 1
a2207 1
					return switch_entries.Length;
d2211 1
a2211 1
			internal int GetSwitchValue(int i)
d2213 2
a2214 1
				return switch_entries[i].value;
d2217 1
a2217 1
			internal int GetSwitchTargetOffset(int i)
d2219 5
a2223 1
				return switch_entries[i].target_offset;
a2225 15

		internal struct LineNumberTableEntry
		{
			internal ushort start_pc;
			internal ushort line_number;
		}

		internal struct LocalVariableTableEntry
		{
			internal ushort start_pc;
			internal ushort length;
			internal string name;
			internal string descriptor;
			internal ushort index;
		}
@


1.18
log
@*** empty log message ***
@
text
@a23 2
#define FUZZ_HACK

a30 3
// MONOBUG mcs 1.0 still has problems resolving properties vs. type names
using __Modifiers = IKVM.Attributes.Modifiers;

a248 1
#if FUZZ_HACK
a249 6
#else
						if(br.ReadUInt32() != 0)
						{
							throw new ClassFormatError("Deprecated attribute has non-zero length");
						}
#endif
a258 1
#if FUZZ_HACK
d260 2
a261 2
						// so when we're running Fuzz this shows up as lots of differences.
						// To get rid off these differences define the FUZZ_HACK symbol.
a263 3
#else
						BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());
#endif
a288 6
#if !FUZZ_HACK
						if(!rdr.IsAtEnd)
						{
							throw new ClassFormatError("{0} (InnerClasses attribute has wrong length)", this.Name);
						}
#endif
d1202 1
a1202 1
					(thisType.Modifiers & (__Modifiers.Interface | __Modifiers.Super)) == __Modifiers.Super &&
a1534 1
#if FUZZ_HACK
a1535 6
#else
						if(br.ReadUInt32() != 0)
						{
							throw new ClassFormatError("Deprecated attribute has non-zero length");
						}
#endif
a1652 1
#if FUZZ_HACK
a1653 6
#else
						if(br.ReadUInt32() != 0)
						{
							throw new ClassFormatError("{0} (Deprecated attribute has non-zero length)", classFile.Name);
						}
#endif
a1703 1
#if FUZZ_HACK
a1708 1
#endif
@


1.17
log
@*** empty log message ***
@
text
@d56 1
a56 1
		internal static readonly int Maximum = Environment.GetEnvironmentVariable("IKVM_EXPERIMENTAL_JDK_5_0") == null ? 48 : 49;
d868 1
a868 1
			if(Tracer.ClassLoading.TraceError)
@


1.16
log
@*** empty log message ***
@
text
@d1120 13
a1132 1
						field.Link();
d1584 1
a1584 1
									constantValue = (sbyte)classFile.GetConstantPoolConstantInteger(index);
@


1.15
log
@*** empty log message ***
@
text
@d53 6
d70 1
a70 1
			if(majorVersion < 45 || majorVersion > 48)
@


1.14
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d553 1
a553 1
			if(f.IsPrivate && f.Name != "serialVersionUID" && !IsReferenced(f))
@


1.13
log
@*** empty log message ***
@
text
@d36 1
a36 1
class ClassFile
d548 34
d761 1
a761 1
	internal class ConstantPoolItemClass : ConstantPoolItem
d986 1
a986 1
	private class ConstantPoolItemDouble : ConstantPoolItem
d1075 1
a1075 1
	internal class ConstantPoolItemFieldref : ConstantPoolItemFMI
d1188 1
a1188 1
	internal class ConstantPoolItemMethodref : ConstantPoolItemMI
d1219 1
a1219 1
	internal class ConstantPoolItemInterfaceMethodref : ConstantPoolItemMI
d1264 1
a1264 1
	private class ConstantPoolItemFloat : ConstantPoolItem
d1287 1
a1287 1
	private class ConstantPoolItemInteger : ConstantPoolItem
d1310 1
a1310 1
	private class ConstantPoolItemLong : ConstantPoolItem
d1333 1
a1333 1
	internal class ConstantPoolItemNameAndType : ConstantPoolItem
d1345 1
a1345 1
	private class ConstantPoolItemString : ConstantPoolItem
d1520 1
a1520 1
	internal class Field : FieldOrMethod
d1632 1
a1632 1
	internal class Method : FieldOrMethod
d2011 1
a2011 1
		internal class ExceptionTableEntry
@


1.12
log
@*** empty log message ***
@
text
@d773 1
a773 1
					name = name.Replace('/', '.');
d998 1
a998 1
			name = classFile.GetConstantPoolUtf8String(name_and_type.name_index);
d1001 1
a1001 1
			descriptor = descriptor.Replace('/', '.');
d1166 1
a1166 2
				MethodDescriptor md = new MethodDescriptor(Name, Signature);
				method = wrapper.GetMethodWrapper(md, Name != "<init>");
d1175 1
a1175 1
					invokespecialMethod = thisType.BaseTypeWrapper.GetMethodWrapper(md, true);
d1191 1
a1191 1
		private static MethodWrapper GetInterfaceMethod(TypeWrapper wrapper, MethodDescriptor md)
d1193 1
a1193 1
			MethodWrapper method = wrapper.GetMethodWrapper(md, false);
d1201 1
a1201 1
				method = GetInterfaceMethod(interfaces[i], md);
d1216 1
a1216 2
				MethodDescriptor md = new MethodDescriptor(Name, Signature);
				method = GetInterfaceMethod(wrapper, md);
d1220 1
a1220 1
					method = CoreClasses.java.lang.Object.Wrapper.GetMethodWrapper(md, false);
d1365 1
a1365 1
			name = classFile.GetConstantPoolUtf8String(br.ReadUInt16());
d1368 1
a1368 1
			descriptor = descriptor.Replace('/', '.');
@


1.11
log
@*** empty log message ***
@
text
@d24 2
d41 2
a42 2
	private ConstantPoolItemClass this_cpi;
	private ConstantPoolItemClass super_cpi;
a51 1
	private static readonly char[] illegalcharacters = { '<', '>' };
d60 1
a60 1
				throw new ClassFormatError("Bad magic number");
d66 1
a66 1
				throw new UnsupportedClassVersionError(majorVersion + "." + minorVersion);
d109 1
a109 1
						utf8_cp[i] = br.ReadString();
d123 6
d147 3
a149 10
			int this_class = br.ReadUInt16();
			try
			{
				this_cpi = (ConstantPoolItemClass)constantpool[this_class];
			}
			catch(Exception)
			{
				throw new ClassFormatError("{0} (Class name has bad constant pool index)", inputClassName);
			}
			int super_class = br.ReadUInt16();
d154 1
a154 8
				try
				{
					super_cpi = (ConstantPoolItemClass)constantpool[super_class];
				}
				catch(Exception)
				{
					throw new ClassFormatError("{0} (Bad superclass constant pool index)", inputClassName);
				}
d163 1
a163 1
			if(IsInterface && (super_class == 0 || super_cpi.Name != "java.lang.Object"))
d167 3
a169 2
			// TODO are there any more checks we need to do on the class name?
			if(Name.Length == 0 || Name[0] == '[')
d203 1
a203 3
				// NOTE It's not in the vmspec (as far as I can tell), but Sun's VM doesn't allow names that
				// contain '<' or '>'
				if(name.Length == 0 || name.IndexOfAny(illegalcharacters) != -1)
d224 1
a224 1
				if(name.Length == 0 || (name.IndexOfAny(illegalcharacters) != -1 && name != "<init>" && name != "<clinit>"))
d248 3
d255 1
d265 7
d273 1
d282 21
d304 1
d323 4
d329 2
a330 1
			throw new ClassFormatError("Truncated class file");
d332 1
a332 1
//		catch(Exception)
d334 1
d342 124
a573 5
	private string GetConstantPoolString(int index)
	{
		return ((ConstantPoolItemString)constantpool[index]).Value;
	}

d576 13
a588 1
		return utf8_cp[index];
d625 1
a625 1
			return this_cpi.Name;
d633 1
a633 1
			return super_cpi.Name;
d740 39
a778 1
			name = classFile.GetConstantPoolUtf8String(name_index).Replace('/', '.');
d975 1
a975 1
	internal class ConstantPoolItemFMI : ConstantPoolItem
a978 1
		protected ConstantPoolItemNameAndType name_and_type;
d980 2
d991 1
a991 1
			name_and_type = (ConstantPoolItemNameAndType)classFile.GetConstantPoolItem(name_and_type_index);
d993 9
d1004 2
a1007 1
			name_and_type.Link(thisType, classCache);
d1015 1
a1015 1
				return name_and_type.Name;
d1023 1
a1023 1
				return name_and_type.Type;
d1044 1
d1050 12
d1064 1
a1064 1
			return name_and_type.GetFieldType();
d1070 1
a1070 2
			TypeWrapper wrapper = GetClassType();
			if(!wrapper.IsUnloadable)
d1072 4
a1075 2
				field = wrapper.GetFieldWrapper(Name, Signature);
				if(field != null)
d1077 5
a1081 1
					field.Link();
d1094 2
d1103 30
d1135 1
a1135 1
			return name_and_type.GetArgTypes();
d1140 1
a1140 1
			return name_and_type.GetRetType();
d1303 2
a1304 7
		private ushort name_index;
		private ushort descriptor_index;
		private string name;
		private string descriptor;
		private TypeWrapper[] argTypeWrappers;
		private TypeWrapper retTypeWrapper;
		private TypeWrapper fieldTypeWrapper;
a1310 58

		internal override void Resolve(ClassFile classFile)
		{
			name = classFile.GetConstantPoolUtf8String(name_index).Replace('/', '.');
			descriptor = classFile.GetConstantPoolUtf8String(descriptor_index).Replace('/', '.');
		}

		internal override void Link(TypeWrapper thisType, Hashtable classCache)
		{
			if(descriptor[0] == '(')
			{
				if(argTypeWrappers == null)
				{
					ClassLoaderWrapper classLoader = thisType.GetClassLoader();
					argTypeWrappers = ArgTypeWrapperListFromSig(classLoader, classCache, descriptor);
					retTypeWrapper = RetTypeWrapperFromSig(classLoader, classCache, descriptor);
				}
			}
			else
			{
				if(fieldTypeWrapper == null)
				{
					ClassLoaderWrapper classLoader = thisType.GetClassLoader();
					fieldTypeWrapper = FieldTypeWrapperFromSig(classLoader, classCache, descriptor);
				}
			}
		}

		internal string Name
		{
			get
			{
				return name;
			}
		}

		internal string Type
		{
			get
			{
				return descriptor;
			}
		}

		internal TypeWrapper[] GetArgTypes()
		{
			return argTypeWrappers;
		}

		internal TypeWrapper GetRetType()
		{
			return retTypeWrapper;
		}

		internal TypeWrapper GetFieldType()
		{
			return fieldTypeWrapper;
		}
d1357 1
a1357 1
	internal class FieldOrMethod
d1368 3
a1370 2
			// TODO validate the descriptor
			descriptor = classFile.GetConstantPoolUtf8String(br.ReadUInt16()).Replace('/', '.');
d1373 2
d1507 3
d1514 1
d1583 8
d1632 3
d1637 1
a1637 1
							throw new ClassFormatError("Deprecated attribute has non-zero length");
d1639 1
d1642 1
d1645 7
a1651 1
							throw new ClassFormatError("Duplicate Code attribute");
a1652 1
						code.Read(classFile, this, br.Section(br.ReadUInt32()));
d1654 1
d1656 1
d1659 1
a1659 1
							throw new ClassFormatError("Duplicate Exceptions attribute");
d1668 4
d1673 1
d1690 7
d1702 8
d1735 8
d1811 1
d1826 4
d1833 1
a1833 1
				while(br.Position - basePosition < code_length)
d1835 12
a1846 1
					instructions[instructionIndex++].Read((ushort)(br.Position - basePosition), br);
a1847 2
				// we add an additional nop instruction to make it easier for consumers of the code array
				instructions[instructionIndex++].SetTermNop((ushort)(br.Position - basePosition));
d1880 8
d1905 2
d1964 4
d2033 5
a2037 3
						// TODO validate these
						br.ReadByte();	// count
						br.ReadByte();	// unused
d2063 1
a2063 1
						if(low > high)
d2065 1
a2065 2
							// TODO is this the right exception?
							throw new ClassFormatError("Incorrect tableswitch (low > high)");
d2085 1
a2085 1
						if(count < 0)
d2087 1
a2087 2
							// TODO is this the right exception?
							throw new ClassFormatError("Incorrect lookupswitch (npairs < 0)");
@


1.10
log
@*** empty log message ***
@
text
@d651 1
a651 1
				x = ExceptionHelper.MapExceptionFast(x);
@


1.9
log
@*** empty log message ***
@
text
@d1616 1
a1616 1
							if(JVM.Debug)
@


1.8
log
@*** empty log message ***
@
text
@a1374 7
			// spec (4.7.2) says we should silently ignore ConstantValue attribute on non-static fields
			// NOTE a field doesn't have to be final to have a constant value!
			if(!IsStatic)
			{
				// TODO is this needed?
				constantValue = null;
			}
@


1.7
log
@*** empty log message ***
@
text
@d355 2
a356 1
			return (access_flags & Modifiers.Abstract) != 0;
d638 2
a639 2
					string sep = "";
					while(cl != null)
d641 7
a647 3
						sb.Append(sep).Append(cl);
						sep = " -> ";
						cl = type.InvokeMember("getParent", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.InvokeMethod | System.Reflection.BindingFlags.Instance, null, cl, new object[0]);
d1606 5
a1610 1
							if(JVM.Debug)
a1620 4
							else
							{
								br.Skip(br.ReadUInt32());
							}
@


1.6
log
@*** empty log message ***
@
text
@d843 1
a843 1
				field = wrapper.GetFieldWrapper(Name, GetFieldType());
@


1.5
log
@*** empty log message ***
@
text
@d27 4
d32 1
a32 1
using __Modifiers = Modifiers;
@


1.4
log
@*** empty log message ***
@
text
@d1578 2
a1579 1
				this.instructions = instructions;
@


1.3
log
@*** empty log message ***
@
text
@d27 2
d33 1
a39 1
	private Attribute[] attributes;
a40 1
	private bool sourceFileCached;
d42 4
a45 1
	private int majorVersion;
d48 1
a48 1
	internal ClassFile(byte[] buf, int offset, int length, string inputClassName)
d52 1
a52 1
			BigEndianBinaryReader br = new BigEndianBinaryReader(buf, offset);
a62 1
			Hashtable classCache = new Hashtable();
d65 1
d68 2
a69 3
				constantpool[i] = ConstantPoolItem.Read(inputClassName, classCache, br);
				// LONG and DOUBLE items take up two slots...
				if(constantpool[i].IsWide)
d71 37
a107 1
					i++;
d161 1
a161 1
				if(this.Name != "java.lang.Object")
d177 1
a177 2
			Hashtable interfaceNames = new Hashtable();
			for(int i = 0; i < interfaces_count; i++)
d189 2
a190 2
				interfaces[i] = (ConstantPoolItemClass)GetConstantPoolItem(index);
				if(interfaceNames.ContainsKey(interfaces[i]))
d192 4
a195 1
					throw new ClassFormatError("{0} (Repetitive interface name)", Name);
a196 1
				interfaceNames.Add(interfaces[i], interfaces[i]);
d203 1
a203 1
				fields[i] = new Field(this, classCache, br);
d205 1
a205 1
				// NOTE It's not in the vmspec (as far as I can tell), but Sun's VM doens't allow names that
d211 5
a215 2
				string nameSig = name + fields[i].Signature;
				if(fieldNameSigs.ContainsKey(nameSig))
a218 1
				fieldNameSigs.Add(nameSig, nameSig);
d225 1
a225 1
				methods[i] = new Method(this, classCache, br);
d236 5
a240 2
				string nameSig = name + sig;
				if(methodNameSigs.ContainsKey(nameSig))
a243 1
				methodNameSigs.Add(nameSig, nameSig);
a245 1
			attributes = new Attribute[attributes_count];
d248 39
a286 1
				attributes[i] = Attribute.Read(this, br);
d290 1
a290 8
				if(br.Position > offset + length)
				{
					throw new ClassFormatError("Truncated class file");
				}
				else
				{
					throw new ClassFormatError("Extra bytes at the end of the class file");
				}
d328 1
a328 1
	internal void Link(TypeWrapper thisType)
d334 1
a334 1
				constantpool[i].Link(thisType);
d408 1
a408 1
	internal TypeWrapper GetConstantPoolClassType(int index, ClassLoaderWrapper classLoader)
d410 1
a410 1
		return ((ConstantPoolItemClass)constantpool[index]).GetClassType(classLoader);
a417 5
	private ConstantPoolItemUtf8 GetConstantPoolUtf8(int index)
	{
		return ((ConstantPoolItemUtf8)constantpool[index]);
	}

d420 1
a420 1
		return GetConstantPoolUtf8(index).Value;
a460 14
	internal string PackageName
	{
		get
		{
			string name = Name;
			int index = name.LastIndexOf('.');
			if(index == -1)
			{
				return "";
			}
			return name.Substring(0, index);
		}
	}

a492 12
	private Attribute GetAttribute(string name)
	{
		for(int i = 0; i < attributes.Length; i++)
		{
			if(attributes[i].Name == name)
			{
				return attributes[i];
			}
		}
		return null;
	}

a496 9
			if(!sourceFileCached)
			{
				sourceFileCached = true;
				Attribute attr = GetAttribute("SourceFile");
				if(attr != null)
				{
					sourceFile = ((ConstantPoolItemUtf8)GetConstantPoolItem(attr.Data.ReadUInt16())).Value;
				}
			}
d505 1
a505 6
			Attribute attr = GetAttribute("IKVM.NET.Assembly");
			if(attr != null)
			{
				return ((ConstantPoolItemUtf8)GetConstantPoolItem(attr.Data.ReadUInt16())).Value;
			}
			return null;
d513 1
a513 1
			return GetAttribute("Deprecated") != null;
d519 3
a521 3
		internal int innerClass;		// ConstantPoolItemClass
		internal int outerClass;		// ConstantPoolItemClass
		internal int name;				// ConstantPoolItemUtf8
d529 1
a529 16
			Attribute attr = GetAttribute("InnerClasses");
			if(attr != null)
			{
				BigEndianBinaryReader rdr = attr.Data;
				ushort count = rdr.ReadUInt16();
				InnerClass[] list = new InnerClass[count];
				for(int i = 0; i < list.Length; i++)
				{
					list[i].innerClass = rdr.ReadUInt16();
					list[i].outerClass = rdr.ReadUInt16();
					list[i].name = rdr.ReadUInt16();
					list[i].accessFlags = (Modifiers)rdr.ReadUInt16();
				}
				return list;
			}
			return null;
a544 8
		internal virtual bool IsWide
		{
			get
			{
				return false;
			}
		}

d549 1
a549 1
		internal virtual void Link(TypeWrapper thisType)
a556 32

		internal static ConstantPoolItem Read(string inputClassName, Hashtable classCache, BigEndianBinaryReader br)
		{
			byte tag = br.ReadByte();
			switch((Constant)tag)
			{
				case Constant.Class:
					return new ConstantPoolItemClass(classCache, br);
				case Constant.Double:
					return new ConstantPoolItemDouble(br);
				case Constant.Fieldref:
					return new ConstantPoolItemFieldref(br);
				case Constant.Float:
					return new ConstantPoolItemFloat(br);
				case Constant.Integer:
					return new ConstantPoolItemInteger(br);
				case Constant.InterfaceMethodref:
					return new ConstantPoolItemInterfaceMethodref(br);
				case Constant.Long:
					return new ConstantPoolItemLong(br);
				case Constant.Methodref:
					return new ConstantPoolItemMethodref(br);
				case Constant.NameAndType:
					return new ConstantPoolItemNameAndType(classCache, br);
				case Constant.String:
					return new ConstantPoolItemString(br);
				case Constant.Utf8:
					return new ConstantPoolItemUtf8(inputClassName, br);
				default:
					throw new ClassFormatError("{0} (Illegal constant pool type 0x{1:X})", inputClassName, tag);
			}
		}
a563 1
		private Hashtable classCache;
d565 1
a565 1
		internal ConstantPoolItemClass(Hashtable classCache, BigEndianBinaryReader br)
a566 1
			this.classCache = classCache;
d572 9
a580 1
			name = ((ConstantPoolItemUtf8)classFile.GetConstantPoolItem(name_index)).DottifiedValue;;
d591 1
a591 1
		internal TypeWrapper GetClassType(ClassLoaderWrapper classLoader)
a592 4
			if(typeWrapper == null)
			{
				typeWrapper = LoadClassHelper(classLoader, classCache, name);
			}
a762 8

		internal override bool IsWide
		{
			get
			{
				return true;
			}
		}
d784 6
d814 1
a814 1
		internal TypeWrapper GetClassType(ClassLoaderWrapper classLoader)
d816 1
a816 1
			return clazz.GetClassType(classLoader);
d828 1
a828 1
		internal TypeWrapper GetFieldType(ClassLoaderWrapper classLoader)
d830 1
a830 1
			return name_and_type.GetFieldType(classLoader);
d833 1
a833 1
		internal override void Link(TypeWrapper thisType)
d835 2
a836 3
			ClassLoaderWrapper classLoader = thisType.GetClassLoader();
			GetFieldType(classLoader);
			TypeWrapper wrapper = GetClassType(classLoader);
d839 1
a839 1
				field = wrapper.GetFieldWrapper(Name, GetFieldType(classLoader));
d862 1
a862 1
		internal TypeWrapper[] GetArgTypes(ClassLoaderWrapper classLoader)
d864 1
a864 1
			return name_and_type.GetArgTypes(classLoader);
d867 1
a867 1
		internal TypeWrapper GetRetType(ClassLoaderWrapper classLoader)
d869 1
a869 1
			return name_and_type.GetRetType(classLoader);
d889 1
a889 1
		internal override void Link(TypeWrapper thisType)
d891 2
a892 4
			ClassLoaderWrapper classLoader = thisType.GetClassLoader();
			TypeWrapper wrapper = GetClassType(classLoader);
			GetArgTypes(classLoader);
			GetRetType(classLoader);
d902 1
a902 1
					(thisType.Modifiers & (Modifiers.Interface | Modifiers.Super)) == Modifiers.Super &&
d940 1
a940 1
		internal override void Link(TypeWrapper thisType)
d942 2
a943 4
			ClassLoaderWrapper classLoader = thisType.GetClassLoader();
			TypeWrapper wrapper = GetClassType(classLoader);
			GetArgTypes(classLoader);
			GetRetType(classLoader);
a1027 8

		internal override bool IsWide
		{
			get
			{
				return true;
			}
		}
a1038 1
		private Hashtable classCache;
d1040 1
a1040 1
		internal ConstantPoolItemNameAndType(Hashtable classCache, BigEndianBinaryReader br)
a1041 1
			this.classCache = classCache;
d1048 23
a1070 6
			ConstantPoolItemUtf8 nameUtf8 = (ConstantPoolItemUtf8)classFile.GetConstantPoolItem(name_index);
			nameUtf8.Resolve(classFile);
			name = nameUtf8.Value;
			ConstantPoolItemUtf8 descriptorUtf8 = (ConstantPoolItemUtf8)classFile.GetConstantPoolItem(descriptor_index);
			descriptorUtf8.Resolve(classFile);
			descriptor = descriptorUtf8.DottifiedValue;
d1089 1
a1089 1
		internal TypeWrapper[] GetArgTypes(ClassLoaderWrapper classLoader)
a1090 4
			if(argTypeWrappers == null)
			{
				argTypeWrappers = ArgTypeWrapperListFromSig(classLoader, classCache, descriptor);
			}
d1094 1
a1094 1
		internal TypeWrapper GetRetType(ClassLoaderWrapper classLoader)
a1095 4
			if(retTypeWrapper == null)
			{
				retTypeWrapper = RetTypeWrapperFromSig(classLoader, classCache, descriptor);
			}
d1099 1
a1099 1
		internal TypeWrapper GetFieldType(ClassLoaderWrapper classLoader)
a1100 4
			if(fieldTypeWrapper == null)
			{
				fieldTypeWrapper = FieldTypeWrapperFromSig(classLoader, classCache, descriptor);
			}
d1117 1
a1117 3
			ConstantPoolItemUtf8 utf8 = (ConstantPoolItemUtf8)classFile.GetConstantPoolItem(string_index);
			utf8.Resolve(classFile);
			s = utf8.Value;
d1134 1
a1134 34
	private class ConstantPoolItemUtf8 : ConstantPoolItem
	{
		private string s;

		internal ConstantPoolItemUtf8(string inputClassName, BigEndianBinaryReader br)
		{
			try
			{
				s = br.ReadString();
			}
			catch(FormatException)
			{
				throw new ClassFormatError("{0} (Illegal UTF8 string in constant pool)", inputClassName);
			}
		}

		internal string Value
		{
			get
			{
				return s;
			}
		}

		internal string DottifiedValue
		{
			get
			{
				return s.Replace('/', '.');
			}
		}
	}

	private enum Constant
a1148 50
	internal class Attribute
	{
		private string name;
		private BigEndianBinaryReader data;

		private Attribute()
		{
		}

		internal static Attribute Read(ClassFile classFile, BigEndianBinaryReader br)
		{
			try
			{
				int name_index = br.ReadUInt16();
				string name = classFile.GetConstantPoolUtf8(name_index).Value;
				int attribute_length = br.ReadInt32();
				Attribute a = new Attribute();
				a.name = name;
				a.data = br.Section(attribute_length);
				return a;
			}
			catch(InvalidCastException)
			{
			}
			catch(NullReferenceException)
			{
			}
			catch(IndexOutOfRangeException)
			{
			}
			throw new ClassFormatError("{0} (Attribute name invalid type)", classFile.Name);
		}

		internal string Name
		{
			get
			{
				return name;
			}
		}

		internal BigEndianBinaryReader Data
		{
			get
			{
				return data.Duplicate();
			}
		}
	}

a1150 1
		private ClassFile classFile;
d1152 3
a1154 7
		private ushort name_index;
		private ushort descriptor_index;
		private Attribute[] attributes;
		private TypeWrapper[] argTypeWrappers;
		private TypeWrapper retTypeWrapper;
		private TypeWrapper fieldTypeWrapper;
		private Hashtable classCache;
d1156 1
a1156 1
		internal FieldOrMethod(ClassFile classFile, Hashtable classCache, BigEndianBinaryReader br)
a1157 2
			this.classFile = classFile;
			this.classCache = classCache;
d1159 3
a1161 10
			// TODO check that name is ConstantPoolItemUtf8
			name_index = br.ReadUInt16();
			// TODO check that descriptor is ConstantPoolItemUtf8 and validate the descriptor
			descriptor_index = br.ReadUInt16();
			int attributes_count = br.ReadUInt16();
			attributes = new Attribute[attributes_count];
			for(int i = 0; i < attributes_count; i++)
			{
				attributes[i] = Attribute.Read(classFile, br);
			}
d1168 1
a1168 1
				return classFile.GetConstantPoolUtf8(name_index).Value;
d1176 1
a1176 1
				return classFile.GetConstantPoolUtf8(descriptor_index).DottifiedValue;
a1179 27
		internal TypeWrapper[] GetArgTypes(ClassLoaderWrapper classLoader)
		{
			if(argTypeWrappers == null)
			{
				argTypeWrappers = ArgTypeWrapperListFromSig(classLoader, classCache, Signature);
			}
			return argTypeWrappers;
		}

		internal TypeWrapper GetRetType(ClassLoaderWrapper classLoader)
		{
			if(retTypeWrapper == null)
			{
				retTypeWrapper = RetTypeWrapperFromSig(classLoader, classCache, Signature);
			}
			return retTypeWrapper;
		}

		internal TypeWrapper GetFieldType(ClassLoaderWrapper classLoader)
		{
			if(fieldTypeWrapper == null)
			{
				fieldTypeWrapper = FieldTypeWrapperFromSig(classLoader, classCache, Signature);
			}
			return fieldTypeWrapper;
		}

a1267 20
		protected Attribute GetAttribute(string name)
		{
			foreach(Attribute attr in attributes)
			{
				if(attr.Name == name)
				{
					return attr;
				}
			}
			return null;
		}

		internal ClassFile ClassFile
		{
			get
			{
				return classFile;
			}
		}

d1272 1
a1272 1
				return GetAttribute("Deprecated") != null;
d1281 1
a1281 1
		internal Field(ClassFile classFile, Hashtable classCache, BigEndianBinaryReader br) : base(classFile, classCache, br)
d1289 2
a1290 3
			// spec (4.7.2) says we should silently ignore ConstantValue attribute on non-static fields
			// NOTE a field doesn't have to be final to have a constant value!
			if(IsStatic)
d1292 1
a1292 2
				Attribute attr = GetAttribute("ConstantValue");
				if(attr != null)
d1294 8
a1301 2
					ushort index = attr.Data.ReadUInt16();
					try
d1303 49
a1351 1
						switch(Signature)
d1353 5
a1357 29
							case "I":
								constantValue = classFile.GetConstantPoolConstantInteger(index);
								break;
							case "S":
								constantValue = (short)classFile.GetConstantPoolConstantInteger(index);
								break;
							case "B":
								constantValue = (sbyte)classFile.GetConstantPoolConstantInteger(index);
								break;
							case "C":
								constantValue = (char)classFile.GetConstantPoolConstantInteger(index);
								break;
							case "Z":
								constantValue = classFile.GetConstantPoolConstantInteger(index) != 0;
								break;
							case "J":
								constantValue = classFile.GetConstantPoolConstantLong(index);
								break;
							case "F":
								constantValue = classFile.GetConstantPoolConstantFloat(index);
								break;
							case "D":
								constantValue = classFile.GetConstantPoolConstantDouble(index);
								break;
							case "Ljava.lang.String;":
								constantValue = classFile.GetConstantPoolConstantString(index);
								break;
							default:
								throw new ClassFormatError("{0} (Invalid signature for constant)", classFile.Name);
d1359 1
d1361 3
a1363 16
					catch(InvalidCastException)
					{
						throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
					}
					catch(IndexOutOfRangeException)
					{
						throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
					}
					catch(InvalidOperationException)
					{
						throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
					}
					catch(NullReferenceException)
					{
						throw new ClassFormatError("{0} (Bad index into constant pool)", classFile.Name);
					}
d1366 7
d1387 1
d1389 1
a1389 1
		internal Method(ClassFile classFile, Hashtable classCache, BigEndianBinaryReader br) : base(classFile, classCache, br)
d1409 51
a1459 2
			// TODO if the method is abstract or native it may not have a Code attribute (right?)
			// and if it is not abstract or native, it must have a Code attribute
d1479 59
a1537 1
		internal Code CodeAttribute
d1541 1
a1541 9
				if(code == null)
				{
					Attribute attr = GetAttribute("Code");
					if(attr != null)
					{
						code = new Code(this, attr);
					}
				}
				return code;
d1545 1
a1545 1
		internal string[] ExceptionsAttribute
d1549 1
a1549 13
				Attribute attr = GetAttribute("Exceptions");
				if(attr != null)
				{
					BigEndianBinaryReader rdr = attr.Data;
					ushort count = rdr.ReadUInt16();
					string[] exceptions = new string[count];
					for(int i = 0; i < count; i++)
					{
						exceptions[i] = ClassFile.GetConstantPoolClass(rdr.ReadUInt16());
					}
					return exceptions;
				}
				return null;
d1553 1
a1553 1
		internal class Code
d1555 8
a1562 12
			private Method method;
			private ushort max_stack;
			private ushort max_locals;
			private Instruction[] instructions;
			private int[] pcIndexMap;
			private ExceptionTableEntry[] exception_table;
			private Attribute[] codeAttributes;
			private int[] argmap;
			private LineNumberTableEntry[] lineNumberTable;
			private bool lineNumberTableCached;
			private LocalVariableTableEntry[] localVariableTable;
			private bool localVariableTableCached;
d1564 1
a1564 1
			internal Code(Method method, Attribute attr)
a1565 2
				this.method = method;
				BigEndianBinaryReader br = attr.Data;
d1569 1
a1569 1
				ArrayList instructions = new ArrayList();
d1571 1
d1574 1
a1574 1
					instructions.Add(Instruction.Read(this, br.Position - basePosition, br));
d1577 2
a1578 2
				instructions.Add(new Instruction(this, br.Position - basePosition, ByteCode.__nop));
				this.instructions = (Instruction[])instructions.ToArray(typeof(Instruction));
a1590 1
				codeAttributes = new Attribute[attributes_count];
d1593 43
a1635 1
					codeAttributes[i] = Attribute.Read(method.ClassFile, br);
d1638 1
a1638 1
				pcIndexMap = new int[this.instructions[this.instructions.Length - 1].PC + 1];
d1643 1
a1643 1
				for(int i = 0; i < this.instructions.Length - 1; i++)
d1647 21
a1667 13
			}

			// maps argument 'slot' (as encoded in the xload/xstore instructions) into the ordinal
			internal int[] ArgMap
			{
				get
				{
					if(argmap == null)
					{
						string sig = method.Signature;
						ArrayList args = new ArrayList();
						int pos = 0;
						if(!method.IsStatic)
d1669 1
a1669 6
							args.Add(pos++);
						}
						for(int i = 1; sig[i] != ')'; i++)
						{
							args.Add(pos++);
							switch(sig[i])
d1671 1
a1671 19
								case 'L':
									i = sig.IndexOf(';', i);
									break;
								case 'D':
								case 'J':
									args.Add(-1);
									break;
								case '[':
								{
									while(sig[i] == '[')
									{
										i++;
									}
									if(sig[i] == 'L')
									{
										i = sig.IndexOf(';', i);
									}
									break;
								}
d1673 1
a1673 83
						}
						argmap = new int[args.Count];
						args.CopyTo(argmap);
					}
					return argmap;
				}
			}

			internal Method Method
			{
				get
				{
					return method;
				}
			}

			internal int MaxStack
			{
				get
				{
					return max_stack;
				}
			}

			internal int MaxLocals
			{
				get
				{
					return max_locals;
				}
			}

			internal Instruction[] Instructions
			{
				get
				{
					return instructions;
				}
			}

			// maps a PC to an index in the Instruction[], invalid PCs return -1
			internal int[] PcIndexMap
			{
				get
				{
					return pcIndexMap;
				}
			}

			internal ExceptionTableEntry[] ExceptionTable
			{
				get
				{
					return exception_table;
				}
			}

			private Attribute GetAttribute(string name)
			{
				foreach(Attribute attr in codeAttributes)
				{
					if(attr.Name == name)
					{
						return attr;
					}
				}
				return null;
			}

			internal LineNumberTableEntry[] LineNumberTableAttribute
			{
				get
				{
					if(!lineNumberTableCached)
					{
						lineNumberTableCached = true;
						Attribute attr = GetAttribute("LineNumberTable");
						if(attr != null)
						{
							BigEndianBinaryReader rdr = attr.Data;
							int count = rdr.ReadUInt16();
							lineNumberTable = new LineNumberTableEntry[count];
							for(int i = 0; i < count; i++)
d1675 1
a1675 2
								lineNumberTable[i].start_pc = rdr.ReadUInt16();
								lineNumberTable[i].line_number = rdr.ReadUInt16();
d1677 1
a1679 1
					return lineNumberTable;
d1681 2
d1685 1
a1685 1
			internal LocalVariableTableEntry[] LocalVariableTableAttribute
d1689 1
a1689 20
					if(!localVariableTableCached)
					{
						localVariableTableCached = true;
						Attribute attr = GetAttribute("LocalVariableTable");
						if(attr != null)
						{
							BigEndianBinaryReader rdr = attr.Data;
							int count = rdr.ReadUInt16();
							localVariableTable = new LocalVariableTableEntry[count];
							for(int i = 0; i < count; i++)
							{
								localVariableTable[i].start_pc = rdr.ReadUInt16();
								localVariableTable[i].length = rdr.ReadUInt16();
								localVariableTable[i].name = method.ClassFile.GetConstantPoolUtf8(rdr.ReadUInt16()).Value;
								localVariableTable[i].descriptor = method.ClassFile.GetConstantPoolUtf8(rdr.ReadUInt16()).DottifiedValue;
								localVariableTable[i].index = rdr.ReadUInt16();
							}
						}
					}
					return localVariableTable;
d1703 1
a1703 1
		internal class Instruction
d1705 1
a1705 2
			private Method.Code method;
			private int pc;
d1707 1
d1709 2
a1710 4
			private int arg2;
			private int default_offset;
			private int[] values;
			private int[] target_offsets;
d1712 1
a1712 2
			internal Instruction(Method.Code method, int pc, ByteCode opcode)
				: this(method, pc, opcode, 0)
d1714 2
d1718 1
a1718 2
			private Instruction(Method.Code method, int pc, ByteCode opcode, int arg1)
				: this(method, pc, opcode, arg1, 0)
d1720 3
d1725 1
a1725 1
			private Instruction(Method.Code method, int pc, ByteCode opcode, int arg1, int arg2)
a1726 1
				this.method = method;
a1727 15
				this.opcode = opcode;
				this.arg1 = arg1;
				this.arg2 = arg2;
			}

			private Instruction(Method.Code method, int pc, ByteCode opcode, int default_offset, int[] values, int[] target_offsets)
				: this(method, pc, opcode)
			{
				this.default_offset = default_offset;
				this.values = values;
				this.target_offsets = target_offsets;
			}

			internal static Instruction Read(Method.Code method, int pc, BigEndianBinaryReader br)
			{
d1729 1
a1729 9
				ByteCodeMode mode = ByteCodeMetaData.GetMode(bc);
				if(bc == ByteCode.__wide)
				{
					bc = (ByteCode)br.ReadByte();
					// NOTE the PC of a wide instruction is actually the PC of the
					// wide prefix, not the following instruction (vmspec 4.9.2)
					mode = ByteCodeMetaData.GetWideMode(bc);
				}
				switch(mode)
d1732 1
a1732 1
						return new Instruction(method, pc, bc);
d1735 2
a1736 1
						return new Instruction(method, pc, bc, br.ReadByte());
d1738 2
a1739 2
					case ByteCodeMode.Local_2:
						return new Instruction(method, pc, bc, br.ReadUInt16());
d1741 2
a1742 1
						return new Instruction(method, pc, bc, br.ReadInt16());
d1744 2
a1745 1
						return new Instruction(method, pc, bc, br.ReadInt32());
d1747 1
a1747 2
					{
						Instruction instr = new Instruction(method, pc, bc, br.ReadUInt16());
d1751 1
a1751 2
						return instr;
					}
d1753 2
a1754 1
						return new Instruction(method, pc, bc, br.ReadSByte());
d1756 2
a1757 1
						return new Instruction(method, pc, bc, br.ReadInt16());
d1759 3
a1761 3
						return new Instruction(method, pc, bc, br.ReadByte(), br.ReadSByte());
					case ByteCodeMode.Local_2_Immediate_2:
						return new Instruction(method, pc, bc, br.ReadUInt16(), br.ReadInt16());
d1763 3
a1765 1
						return new Instruction(method, pc, bc, br.ReadUInt16(), br.ReadSByte());
d1769 3
a1771 6
						int p = pc + 1;
						int align = ((p + 3) & 0x7ffffffc) - p;
						for(int i = 0; i < align; i++)
						{
							br.ReadByte();
						}
d1773 1
d1776 6
a1781 2
						int[] values = new int[high - low + 1];
						int[] target_offset = new int[high - low + 1];
d1784 2
a1785 2
							values[i - low] = i;
							target_offset[i - low] = br.ReadInt32();
d1787 2
a1788 1
						return new Instruction(method, pc, bc, default_offset, values, target_offset);
d1793 7
a1799 3
						int p = pc + 1;
						int align = ((p + 3) & 0x7ffffffc) - p;
						for(int i = 0; i < align; i++)
d1801 2
a1802 1
							br.ReadByte();
d1804 1
a1804 4
						int default_offset = br.ReadInt32();
						int count = br.ReadInt32();
						int[] values = new int[count];
						int[] target_offset = new int[count];
d1807 2
a1808 2
							values[i] = br.ReadInt32();
							target_offset[i] = br.ReadInt32();
d1810 2
a1811 1
						return new Instruction(method, pc, bc, default_offset, values, target_offset);
d1813 17
d1833 3
d1858 1
a1858 1
					return ByteCodeMetaData.GetNormalizedByteCode(opcode);
d1882 1
a1882 1
					return ByteCodeMetaData.GetArg(opcode, arg1);
d1890 1
a1890 1
					return default_offset;
d1894 1
a1894 1
			internal int[] Values
d1898 1
a1898 1
					return values;
d1902 1
a1902 1
			internal int[] TargetOffsets
d1904 1
a1904 4
				get
				{
					return target_offsets;
				}
d1907 1
a1907 1
			internal Method.Code MethodCode
d1909 1
a1909 4
				get
				{
					return method;
				}
d1915 2
a1916 2
			internal int start_pc;
			internal int line_number;
d1921 2
a1922 2
			internal int start_pc;
			internal int length;
d1925 1
a1925 1
			internal int index;
@


1.2
log
@*** empty log message ***
@
text
@a34 1
	private TypeWrapper[] interfaceTypeWrappers;
a43 16
	internal class ClassFormatError : ApplicationException
	{
		internal ClassFormatError(string msg, params object[] p)
			: base(string.Format(msg, p))
		{
		}
	}

	internal class UnsupportedClassVersionError : ClassFormatError
	{
		internal UnsupportedClassVersionError(string msg)
			: base(msg)
		{
		}
	}

d55 1
a55 1
			if(majorVersion < 45 || majorVersion > 49)
d59 1
a59 4
			if(majorVersion == 49)
			{
				Tracer.Warning(Tracer.Runtime, "WARNING: Support for JDK 1.5 is experimental");
			}
d64 1
a64 1
				constantpool[i] = ConstantPoolItem.Read(inputClassName, br);
d131 5
d163 1
a163 1
				fields[i] = new Field(this, br);
d183 1
a183 1
				methods[i] = new Method(this, br);
d254 1
a254 1
	internal void LoadAllReferencedTypes(ClassLoaderWrapper classLoader)
d260 1
a260 1
				constantpool[i].LoadAllReferencedTypes(classLoader);
a262 9
		for(int i = 0; i < fields.Length; i++)
		{
			fields[i].GetFieldType(classLoader);
		}
		for(int i = 0; i < methods.Length; i++)
		{
			methods[i].GetArgTypes(classLoader);
			methods[i].GetRetType(classLoader);
		}
d318 2
a319 2
	// NOTE this returns an FMI, because it used for both normal methods and interface methods
	internal ConstantPoolItemFMI GetMethodref(int index)
d321 1
a321 1
		return (ConstantPoolItemFMI)constantpool[index];
a405 5
	internal TypeWrapper GetSuperTypeWrapper(ClassLoaderWrapper classLoader)
	{
		return super_cpi.GetClassType(classLoader);
	}

d430 1
a430 16
	internal TypeWrapper[] GetInterfaceTypeWrappers(ClassLoaderWrapper classLoader)
	{
		if(interfaceTypeWrappers == null)
		{
			TypeWrapper[] tw = new TypeWrapper[interfaces.Length];
			for(int i = 0; i < tw.Length; i++)
			{
				tw[i] = interfaces[i].GetClassType(classLoader);
			}
			interfaceTypeWrappers = tw;
		}
		return interfaceTypeWrappers;
	}

	// TODO this is legacy and needs to be removed in the future
	internal string[] Interfaces
d434 1
a434 6
			string[] s = new string[interfaces.Length];
			for(int i = 0; i < s.Length; i++)
			{
				s[i] = interfaces[i].Name;
			}
			return s;
d467 1
a467 1
	internal string NetExpAssemblyAttribute
d543 1
a543 1
		internal virtual void LoadAllReferencedTypes(ClassLoaderWrapper classLoader)
d552 1
a552 1
		internal static ConstantPoolItem Read(string inputClassName, BigEndianBinaryReader br)
d558 1
a558 1
					return new ConstantPoolItemClass(br);
d574 1
a574 1
					return new ConstantPoolItemNameAndType(br);
d585 1
a585 1
	private class ConstantPoolItemClass : ConstantPoolItem
d590 1
d592 1
a592 1
		internal ConstantPoolItemClass(BigEndianBinaryReader br)
d594 1
a602 5
		internal override void LoadAllReferencedTypes(ClassLoaderWrapper classLoader)
		{
			GetClassType(classLoader);
		}

d615 1
a615 1
				typeWrapper = LoadClassHelper(classLoader, name);
d626 1
a626 1
	private static TypeWrapper LoadClassHelper(ClassLoaderWrapper classLoader, string name)
d630 6
a635 1
			TypeWrapper wrapper = classLoader.LoadClassByDottedNameFast(name);
d673 1
a673 1
	private static TypeWrapper SigDecoderWrapper(ClassLoaderWrapper classLoader, ref int index, string sig)
d693 1
a693 1
				return LoadClassHelper(classLoader, sig.Substring(pos, index - pos - 1));
d716 1
a716 1
						return LoadClassHelper(classLoader, array + sig.Substring(pos, index - pos));
d726 1
a726 1
						return LoadClassHelper(classLoader, array + sig[index++]);
d738 1
a738 1
	private static TypeWrapper[] ArgTypeWrapperListFromSig(ClassLoaderWrapper classLoader, string sig)
d747 1
a747 1
			list.Add(SigDecoderWrapper(classLoader, ref i, sig));
d754 1
a754 1
	private static TypeWrapper FieldTypeWrapperFromSig(ClassLoaderWrapper classLoader, string sig)
d757 1
a757 1
		return SigDecoderWrapper(classLoader, ref index, sig);
d760 1
a760 1
	private static TypeWrapper RetTypeWrapperFromSig(ClassLoaderWrapper classLoader, string sig)
d763 1
a763 1
		return SigDecoderWrapper(classLoader, ref index, sig);
d801 1
a801 1
		private ConstantPoolItemNameAndType name_and_type;
d844 44
d899 1
a899 1
		internal TypeWrapper GetFieldType(ClassLoaderWrapper classLoader)
d901 1
a901 1
			return name_and_type.GetFieldType(classLoader);
a902 1
	}
d904 1
a904 3
	internal class ConstantPoolItemFieldref : ConstantPoolItemFMI
	{
		internal ConstantPoolItemFieldref(BigEndianBinaryReader br) : base(br)
d906 1
d910 1
a910 1
	internal class ConstantPoolItemMethodref : ConstantPoolItemFMI
d915 27
d944 1
a944 1
	internal class ConstantPoolItemInterfaceMethodref : ConstantPoolItemFMI
d949 41
d1069 1
a1069 1
	private class ConstantPoolItemNameAndType : ConstantPoolItem
d1078 1
d1080 1
a1080 1
		internal ConstantPoolItemNameAndType(BigEndianBinaryReader br)
d1082 1
a1096 13
		internal override void LoadAllReferencedTypes(ClassLoaderWrapper classLoader)
		{
			if(descriptor[0] == '(')
			{
				GetArgTypes(classLoader);
				GetRetType(classLoader);
			}
			else
			{
				GetFieldType(classLoader);
			}
		}

d1117 1
a1117 1
				argTypeWrappers = ArgTypeWrapperListFromSig(classLoader, descriptor);
d1126 1
a1126 1
				retTypeWrapper = RetTypeWrapperFromSig(classLoader, descriptor);
d1135 1
a1135 1
				fieldTypeWrapper = FieldTypeWrapperFromSig(classLoader, descriptor);
d1238 1
a1238 2
				a.data = br.Duplicate();
				br.Skip(attribute_length);
d1280 1
d1282 1
a1282 1
		internal FieldOrMethod(ClassFile classFile, BigEndianBinaryReader br)
d1285 1
d1319 1
a1319 1
				argTypeWrappers = ArgTypeWrapperListFromSig(classLoader, Signature);
d1328 1
a1328 1
				retTypeWrapper = RetTypeWrapperFromSig(classLoader, Signature);
d1337 1
a1337 1
				fieldTypeWrapper = FieldTypeWrapperFromSig(classLoader, Signature);
d1463 1
a1463 1
		internal Field(ClassFile classFile, BigEndianBinaryReader br) : base(classFile, br)
d1547 1
a1547 1
		internal Method(ClassFile classFile, BigEndianBinaryReader br) : base(classFile, br)
d1559 1
a1559 1
				if((Name == "<init>" && (IsStatic || IsSynchronized || IsFinal || IsAbstract))
a1587 18
		internal string[] NetExpSigAttribute
		{
			get
			{
				Attribute attr = GetAttribute("IK.VM.NET.Sig");
				if(attr != null)
				{
					string s = ClassFile.GetConstantPoolUtf8(attr.Data.ReadUInt16()).Value;
					if(s.Length == 0)
					{
						return new string[0];
					}
					return s.Split('|');
				}
				return null;
			}
		}

@


1.1
log
@*** empty log message ***
@
text
@d1504 2
d1508 1
a1508 1
					|| (IsAbstract && (IsFinal || IsNative || IsPrivate || IsStatic || IsStrictfp || IsSynchronized))
@

