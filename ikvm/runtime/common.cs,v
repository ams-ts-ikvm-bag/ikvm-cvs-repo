head	1.82;
access;
symbols
	v8_1_5717_0:1.82
	v8_1:1.82.0.2
	v8_0_5449_1:1.81
	v8_0_5449_0:1.81
	v8_0:1.81.0.2
	v7_4_5196_0:1.77
	v7_4:1.77.0.2
	v7_3:1.71.0.2
	v7_2_4630_6:1.52
	v7_2_4630_5:1.52
	v7_2_4630_4:1.52
	v7_2_4630_3:1.52
	v7_2_4630_2:1.52
	v0_46_0_4:1.48.2.1
	v7_2_4630_1:1.52
	v7_2:1.52.0.2
	v7_1_4532_2:1.51
	v7_1_4532_1:1.51
	v7_1_4532_0:1.51
	v7_1:1.51.0.2
	v7_0_4335_3:1.48
	v7_0_4335_2:1.48
	v7_0_4335_1:1.48
	v0_46_0_2:1.48
	v7_0_4335_0:1.48
	v7_0:1.48.0.4
	v0_40_0_6:1.25
	v0_40_0_5:1.25
	v0_46_0_1:1.48
	v0_46_0_0:1.48
	v0_46:1.48.0.2
	v0_36_0_14:1.2.2.2
	v0_44_0_6:1.44
	v0_44_0_5:1.44
	v0_44_0_4:1.44
	v0_44_0_3:1.44
	v0_44_0_2:1.44
	v0_42_0_7:1.32.2.1
	v0_44_0_1:1.44
	v0_44_0_0:1.44
	v0_44:1.44.0.2
	v0_42_0_6:1.32.2.1
	v0_42_0_5:1.32
	v0_42_0_4:1.32
	v0_42_0_3:1.32
	v0_42_0_2:1.32
	v0_42_0_1:1.32
	v0_42_0_0:1.32
	v0_42:1.32.0.2
	v0_40_0_3:1.25
	v0_40_0_2:1.25
	v0_40_0_1:1.25
	v0_40_0_0:1.25
	v0_40:1.25.0.2
	v0_36_0_13:1.2.2.2
	v0_38_0_1:1.20
	v0_38_0_0:1.20
	v0_38:1.20.0.2
	v0_36_0_9:1.2.2.2
	v0_36_0_7:1.2.2.2
	v0_36_0_5:1.2.2.2
	v0_36_0_4:1.2.2.1
	v0_36_0_3:1.2.2.1
	v0_36_0_2:1.2.2.1
	v0_36_0_1:1.2.2.1
	v0_36_0_0:1.2
	v0_36:1.2.0.2;
locks; strict;
comment	@ * @;


1.82
date	2015.06.25.13.59.10;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2014.06.13.06.54.06;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2014.06.03.12.04.42;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2014.06.02.13.25.40;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2014.05.19.12.43.42;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2014.03.04.07.53.35;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2013.09.02.12.56.16;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2013.08.12.09.02.13;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2013.04.21.10.48.05;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2013.03.26.19.27.25;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2013.03.22.10.41.20;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2013.02.28.07.38.42;	author jfrijters;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2013.02.23.12.41.02;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2013.02.23.08.50.01;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2013.02.23.08.27.18;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2013.02.23.08.10.56;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2013.02.22.10.39.58;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2013.02.21.16.56.09;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2013.02.21.15.20.10;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2013.02.21.13.31.03;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2013.02.21.12.32.11;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2013.02.21.07.06.25;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2013.02.21.07.00.37;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2013.02.20.12.27.50;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2013.02.19.19.42.32;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2013.02.19.09.51.05;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2013.02.19.07.17.50;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2013.02.17.12.07.08;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2013.02.14.10.40.51;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2013.02.12.11.09.16;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2012.07.09.06.07.40;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2012.05.23.09.09.23;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2011.11.24.12.31.39;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2011.11.24.08.35.47;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2010.08.19.09.26.20;	author jfrijters;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2010.08.19.09.04.25;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.11.08.02.32;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.05.13.43.01;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.31.05.58.37;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.30.06.53.49;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.27.16.07.57;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.27.14.08.58;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.27.10.54.34;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.21.06.25.06;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.20.06.00.48;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.10.04.47.34;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2010.02.26.13.31.39;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2010.02.11.10.00.16;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.29.07.08.56;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.03.07.06.36;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.07.04.46.01;	author jfrijters;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2009.08.27.14.40.43;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.03.06.57.07;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.03.06.40.52;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.03.05.55.58;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.28.05.58.35;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.26.10.17.57;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.27.05.57.35;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.24.06.11.54;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.10.07.27.25;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.04.07.24.44;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.18.05.35.58;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.15.12.01.22;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.06.05.25.20;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.31.15.20.42;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.20.07.36.51;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.03.07.05.20;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.15.15.20.14;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.10.11.20.54;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.19.11.28.11;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.18.11.05.31;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.26.09.01.35;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.02.05.11.47;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.26.07.11.17;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.25.12.56.24;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.22.08.09.20;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.22.05.13.09;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.18.13.54.11;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.11.12.06.21;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.22.11.47.22;	author jfrijters;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2007.06.13.11.46.24;	author jfrijters;	state Exp;
branches;
next	;

1.2.2.1
date	2007.09.13.07.30.16;	author jfrijters;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2007.12.04.06.04.33;	author jfrijters;	state Exp;
branches;
next	;

1.32.2.1
date	2010.04.06.05.10.26;	author jfrijters;	state Exp;
branches;
next	;

1.48.2.1
date	2012.10.03.06.18.57;	author jfrijters;	state Exp;
branches;
next	;

1.71.2.1
date	2013.03.27.13.58.30;	author jfrijters;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2013.03.27.16.12.18;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Extract Windows version from kernel32.dll to avoid version lie.
@
text
@/*
  Copyright (C) 2002-2015 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using IKVM.Attributes;
using IKVM.Runtime;
using IKVM.Internal;
using AssemblyClassLoader_ = IKVM.Internal.AssemblyClassLoader;
using jlClass = java.lang.Class;
#if !FIRST_PASS
using NegativeArraySizeException = java.lang.NegativeArraySizeException;
using IllegalArgumentException = java.lang.IllegalArgumentException;
using IllegalAccessException = java.lang.IllegalAccessException;
using NumberFormatException = java.lang.NumberFormatException;
using jlNoClassDefFoundError = java.lang.NoClassDefFoundError;
using jlrConstructor = java.lang.reflect.Constructor;
using jlrField = java.lang.reflect.Field;
#endif

namespace IKVM.NativeCode.gnu.java.net.protocol.ikvmres
{
	static class Handler
	{
		public static byte[] GenerateStub(jlClass c)
		{
			MemoryStream mem = new MemoryStream();
#if !FIRST_PASS
			bool includeNonPublicInterfaces = !"true".Equals(global::java.lang.Props.props.getProperty("ikvm.stubgen.skipNonPublicInterfaces"), StringComparison.OrdinalIgnoreCase);
			IKVM.StubGen.StubGenerator.WriteClass(mem, TypeWrapper.FromClass(c), includeNonPublicInterfaces, false, false, true);
#endif
			return mem.ToArray();
		}

		public static Stream ReadResourceFromAssemblyImpl(Assembly asm, string resource)
		{
			// chop off the leading slash
			resource = resource.Substring(1);
			string mangledName = JVM.MangleResourceName(resource);
			ManifestResourceInfo info = asm.GetManifestResourceInfo(mangledName);
			if(info != null && info.FileName != null)
			{
				return asm.GetManifestResourceStream(mangledName);
			}
			Stream s = asm.GetManifestResourceStream(mangledName);
			if(s == null)
			{
				Tracer.Warning(Tracer.ClassLoading, "Resource \"{0}\" not found in {1}", resource, asm.FullName);
				throw new FileNotFoundException("resource " + resource + " not found in assembly " + asm.FullName);
			}
			switch (s.ReadByte())
			{
				case 0:
					Tracer.Info(Tracer.ClassLoading, "Reading resource \"{0}\" from {1}", resource, asm.FullName);
					return s;
				case 1:
					Tracer.Info(Tracer.ClassLoading, "Reading compressed resource \"{0}\" from {1}", resource, asm.FullName);
					return new System.IO.Compression.DeflateStream(s, System.IO.Compression.CompressionMode.Decompress, false);
				default:
					Tracer.Error(Tracer.ClassLoading, "Resource \"{0}\" in {1} has an unsupported encoding", resource, asm.FullName);
					throw new IOException("Unsupported resource encoding for resource " + resource + " found in assembly " + asm.FullName);
			}
		}

		public static object LoadClassFromAssembly(Assembly asm, string className)
		{
			TypeWrapper tw = AssemblyClassLoader.FromAssembly(asm).LoadClassByDottedNameFast(className);
			if(tw != null)
			{
				return tw.ClassObject;
			}
			return null;
		}

		public static Assembly LoadAssembly(string name)
		{
			return Assembly.Load(name);
		}

		public static global::java.lang.ClassLoader GetGenericClassLoaderById(int id)
		{
			return ClassLoaderWrapper.GetGenericClassLoaderById(id).GetJavaClassLoader();
		}
	}
}

namespace IKVM.NativeCode.java.lang
{
	static class VMSystemProperties
	{
		public static string getVirtualFileSystemRoot()
		{
			return VirtualFileSystem.RootPath;
		}

		public static string getBootClassPath()
		{
			return VirtualFileSystem.GetAssemblyClassesPath(JVM.CoreAssembly);
		}

		public static string getStdoutEncoding()
		{
			return IsWindowsConsole(true) ? GetConsoleEncoding() : null;
		}

		public static string getStderrEncoding()
		{
			return IsWindowsConsole(false) ? GetConsoleEncoding() : null;
		}

		public static FileVersionInfo getKernel32FileVersionInfo()
		{
			try
			{
				foreach (ProcessModule module in Process.GetCurrentProcess().Modules)
				{
					if (string.Compare(module.ModuleName, "kernel32.dll", StringComparison.OrdinalIgnoreCase) == 0)
					{
						return module.FileVersionInfo;
					}
				}
			}
			catch
			{
			}
			return null;
		}

		private static bool IsWindowsConsole(bool stdout)
		{
			if (Environment.OSVersion.Platform != PlatformID.Win32NT)
			{
				return false;
			}
			// these properties are available starting with .NET 4.5
			PropertyInfo pi = typeof(Console).GetProperty(stdout ? "IsOutputRedirected" : "IsErrorRedirected");
			if (pi != null)
			{
				return !(bool)pi.GetValue(null, null);
			}
			const int STD_OUTPUT_HANDLE = -11;
			const int STD_ERROR_HANDLE = -12;
			IntPtr handle = GetStdHandle(stdout ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);
			if (handle == IntPtr.Zero)
			{
				return false;
			}
			const int FILE_TYPE_CHAR = 2;
			return GetFileType(handle) == FILE_TYPE_CHAR;
		}

		private static string GetConsoleEncoding()
		{
			int codepage = Console.InputEncoding.CodePage;
			return codepage >= 847 && codepage <= 950
				? "ms" + codepage
				: "cp" + codepage;
		}

		[DllImport("kernel32")]
		private static extern int GetFileType(IntPtr hFile);

		[DllImport("kernel32")]
		private static extern IntPtr GetStdHandle(int nStdHandle);
	}
}

namespace IKVM.NativeCode.ikvm.@@internal
{
	static class CallerID
	{
		public static jlClass GetClass(object obj)
		{
			return ClassLoaderWrapper.GetWrapperFromType(obj.GetType().DeclaringType).ClassObject;
		}

		public static global::java.lang.ClassLoader GetClassLoader(object obj)
		{
			return ClassLoaderWrapper.GetWrapperFromType(obj.GetType().DeclaringType).GetClassLoader().GetJavaClassLoader();
		}

		public static global::java.lang.ClassLoader GetAssemblyClassLoader(Assembly asm)
		{
			return AssemblyClassLoader.FromAssembly(asm).GetJavaClassLoader();
		}
	}

	static class AnnotationAttributeBase
	{
		public static object[] unescapeInvalidSurrogates(object[] def)
		{
			return (object[])AnnotationDefaultAttribute.Unescape(def);
		}

		public static object newAnnotationInvocationHandler(jlClass type, object memberValues)
		{
#if FIRST_PASS
			return null;
#else
			return new global::sun.reflect.annotation.AnnotationInvocationHandler(type, (global::java.util.Map)memberValues);
#endif
		}

		public static object newAnnotationTypeMismatchExceptionProxy(string msg)
		{
#if FIRST_PASS
			return null;
#else
			return new global::sun.reflect.annotation.AnnotationTypeMismatchExceptionProxy(msg);
#endif
		}
	}
}

namespace IKVM.NativeCode.ikvm.runtime
{
	static class AssemblyClassLoader
	{
		public static void setWrapper(global::java.lang.ClassLoader _this, Assembly assembly)
		{
			ClassLoaderWrapper.SetWrapperForClassLoader(_this, IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly));
		}

		public static global::java.lang.Class loadClass(global::java.lang.ClassLoader _this, string name, bool resolve)
		{
#if FIRST_PASS
			return null;
#else
			try
			{
				if (!global::java.lang.ClassLoader.checkName(name))
				{
					throw new ClassNotFoundException(name);
				}
				AssemblyClassLoader_ wrapper = (AssemblyClassLoader_)ClassLoaderWrapper.GetClassLoaderWrapper(_this);
				TypeWrapper tw = wrapper.LoadClass(name);
				if (tw == null)
				{
					Tracer.Info(Tracer.ClassLoading, "Failed to load class \"{0}\" from {1}", name, _this);
					global::java.lang.Throwable.suppressFillInStackTrace = true;
					throw new global::java.lang.ClassNotFoundException(name);
				}
				Tracer.Info(Tracer.ClassLoading, "Loaded class \"{0}\" from {1}", name, _this);
				return tw.ClassObject;
			}
			catch (ClassNotFoundException x)
			{
				Tracer.Info(Tracer.ClassLoading, "Failed to load class \"{0}\" from {1}", name, _this);
				throw new global::java.lang.ClassNotFoundException(x.Message);
			}
			catch (ClassLoadingException x)
			{
				Tracer.Info(Tracer.ClassLoading, "Failed to load class \"{0}\" from {1}", name, _this);
				throw x.InnerException;
			}
			catch (RetargetableJavaException x)
			{
				Tracer.Info(Tracer.ClassLoading, "Failed to load class \"{0}\" from {1}", name, _this);
				throw x.ToJava();
			}
#endif
		}

		public static global::java.net.URL getResource(global::java.lang.ClassLoader _this, string name)
		{
#if !FIRST_PASS
			AssemblyClassLoader_ wrapper = (AssemblyClassLoader_)ClassLoaderWrapper.GetClassLoaderWrapper(_this);
			foreach (global::java.net.URL url in wrapper.GetResources(name))
			{
				return url;
			}
#endif
			return null;
		}

		public static global::java.util.Enumeration getResources(global::java.lang.ClassLoader _this, string name)
		{
#if FIRST_PASS
			return null;
#else
			return new global::ikvm.runtime.EnumerationWrapper(((AssemblyClassLoader_)ClassLoaderWrapper.GetClassLoaderWrapper(_this)).GetResources(name));
#endif
		}

		public static global::java.net.URL findResource(global::java.lang.ClassLoader _this, string name)
		{
#if !FIRST_PASS
			AssemblyClassLoader_ wrapper = (AssemblyClassLoader_)ClassLoaderWrapper.GetClassLoaderWrapper(_this);
			foreach (global::java.net.URL url in wrapper.FindResources(name))
			{
				return url;
			}
#endif
			return null;
		}

		public static global::java.util.Enumeration findResources(global::java.lang.ClassLoader _this, string name)
		{
#if FIRST_PASS
			return null;
#else
			return new global::ikvm.runtime.EnumerationWrapper(((AssemblyClassLoader_)ClassLoaderWrapper.GetClassLoaderWrapper(_this)).FindResources(name));
#endif
		}

#if !FIRST_PASS
		private static global::java.net.URL GetCodeBase(Assembly assembly)
		{
			try
			{
				return new global::java.net.URL(assembly.CodeBase);
			}
			catch (NotSupportedException)
			{
			}
			catch (global::java.net.MalformedURLException)
			{
			}
			return null;
		}

		private static string GetAttributeValue(global::java.util.jar.Attributes.Name name, global::java.util.jar.Attributes first, global::java.util.jar.Attributes second)
		{
			string result = null;
			if (first != null)
			{
				result = first.getValue(name);
			}
			if (second != null && result == null)
			{
				result = second.getValue(name);
			}
			return result;
		}
#endif

		public static void lazyDefinePackages(global::java.lang.ClassLoader _this)
		{
#if !FIRST_PASS
			AssemblyClassLoader_ wrapper = (AssemblyClassLoader_)ClassLoaderWrapper.GetClassLoaderWrapper(_this);
			global::java.net.URL sealBase = GetCodeBase(wrapper.MainAssembly);
			foreach (KeyValuePair<string, string[]> packages in wrapper.GetPackageInfo())
			{
				global::java.util.jar.Manifest manifest = null;
				global::java.util.jar.Attributes attr = null;
				if (packages.Key != null)
				{
					global::java.util.jar.JarFile jarFile = new global::java.util.jar.JarFile(VirtualFileSystem.GetAssemblyResourcesPath(wrapper.MainAssembly) + packages.Key);
					manifest = jarFile.getManifest();
				}
				if (manifest != null)
				{
					attr = manifest.getMainAttributes();
				}
				foreach (string name in packages.Value)
				{
					if (_this.getPackage(name) == null)
					{
						global::java.util.jar.Attributes entryAttr = null;
						if (manifest != null)
						{
							entryAttr = manifest.getAttributes(name.Replace('.', '/') + '/');
						}
						_this.definePackage(name,
							GetAttributeValue(global::java.util.jar.Attributes.Name.SPECIFICATION_TITLE, entryAttr, attr),
							GetAttributeValue(global::java.util.jar.Attributes.Name.SPECIFICATION_VERSION, entryAttr, attr),
							GetAttributeValue(global::java.util.jar.Attributes.Name.SPECIFICATION_VENDOR, entryAttr, attr),
							GetAttributeValue(global::java.util.jar.Attributes.Name.IMPLEMENTATION_TITLE, entryAttr, attr),
							GetAttributeValue(global::java.util.jar.Attributes.Name.IMPLEMENTATION_VERSION, entryAttr, attr),
							GetAttributeValue(global::java.util.jar.Attributes.Name.IMPLEMENTATION_VENDOR, entryAttr, attr),
							"true".Equals(GetAttributeValue(global::java.util.jar.Attributes.Name.SEALED, entryAttr, attr), StringComparison.OrdinalIgnoreCase) ? sealBase : null);
					}
				}
			}
#endif
		}

		public static string toString(global::java.lang.ClassLoader _this)
		{
			return ((AssemblyClassLoader_)ClassLoaderWrapper.GetClassLoaderWrapper(_this)).MainAssembly.FullName;
		}

		public static global::java.lang.ClassLoader getAssemblyClassLoader(Assembly asm)
		{
			// note that we don't do a security check here, because if you have the Assembly object,
			// you can already get at all the types in it.
			return AssemblyClassLoader_.FromAssembly(asm).GetJavaClassLoader();
		}
	}

	static class AppDomainAssemblyClassLoader
	{
		public static object loadClassFromAssembly(Assembly asm, string className)
		{
			if(ReflectUtil.IsDynamicAssembly(asm))
			{
				return null;
			}
			TypeWrapper tw = IKVM.Internal.AssemblyClassLoader.FromAssembly(asm).DoLoad(className);
			return tw != null ? tw.ClassObject : null;
		}

		private static IEnumerable<global::java.net.URL> FindResources(string name)
		{
			List<IKVM.Internal.AssemblyClassLoader> done = new List<IKVM.Internal.AssemblyClassLoader>();
			foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
			{
				if (!ReflectUtil.IsDynamicAssembly(asm))
				{
					IKVM.Internal.AssemblyClassLoader acl = IKVM.Internal.AssemblyClassLoader.FromAssembly(asm);
					if (!done.Contains(acl))
					{
						done.Add(acl);
						foreach (global::java.net.URL url in acl.FindResources(name))
						{
							yield return url;
						}
					}
				}
			}
		}

		public static global::java.net.URL findResource(object thisObj, string name)
		{
			foreach (global::java.net.URL url in FindResources(name))
			{
				return url;
			}
			return null;
		}

		public static void getResources(global::java.util.Vector v, string name)
		{
#if !FIRST_PASS
			foreach (global::java.net.URL url in FindResources(name))
			{
				if (url != null && !v.contains(url))
				{
					v.add(url);
				}
			}
#endif
		}
	}

	static class GenericClassLoader
	{
		public static string toString(global::java.lang.ClassLoader _this)
		{
			return ((GenericClassLoaderWrapper)ClassLoaderWrapper.GetClassLoaderWrapper(_this)).GetName();
		}

		public static global::java.util.Enumeration getResources(global::java.lang.ClassLoader _this, string name)
		{
			return ((GenericClassLoaderWrapper)ClassLoaderWrapper.GetClassLoaderWrapper(_this)).GetResources(name);
		}

		public static global::java.net.URL findResource(global::java.lang.ClassLoader _this, string name)
		{
			return ((GenericClassLoaderWrapper)ClassLoaderWrapper.GetClassLoaderWrapper(_this)).FindResource(name);
		}
	}

	static class Util
	{
		public static jlClass getClassFromObject(object o)
		{
			return GetTypeWrapperFromObject(o).ClassObject;
		}

		internal static TypeWrapper GetTypeWrapperFromObject(object o)
		{
			TypeWrapper ghostType = GhostTag.GetTag(o);
			if(ghostType != null)
			{
				return ghostType;
			}
			Type t = o.GetType();
			if(t.IsPrimitive || (ClassLoaderWrapper.IsRemappedType(t) && !t.IsSealed))
			{
				return DotNetTypeWrapper.GetWrapperFromDotNetType(t);
			}
			for(; ; )
			{
				TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(t);
				// if GetWrapperFromType returns null (or if tw.IsAbstract), that
				// must mean that the Type of the object is an implementation helper class
				// (e.g. an AtomicReferenceFieldUpdater or ThreadLocal instrinsic subclass)
				if(tw != null && (!tw.IsAbstract || tw.IsArray))
				{
					return tw;
				}
				t = t.BaseType;
			}
		}

		public static jlClass getClassFromTypeHandle(RuntimeTypeHandle handle)
		{
			Type t = Type.GetTypeFromHandle(handle);
			if(t.IsPrimitive || ClassLoaderWrapper.IsRemappedType(t) || t == typeof(void))
			{
				return DotNetTypeWrapper.GetWrapperFromDotNetType(t).ClassObject;
			}
			if(!IsVisibleAsClass(t))
			{
				return null;
			}
			TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(t);
			if(tw != null)
			{
				return tw.ClassObject;
			}
			return null;
		}

		public static jlClass getClassFromTypeHandle(RuntimeTypeHandle handle, int rank)
		{
			Type t = Type.GetTypeFromHandle(handle);
			if(t.IsPrimitive || ClassLoaderWrapper.IsRemappedType(t) || t == typeof(void))
			{
				return DotNetTypeWrapper.GetWrapperFromDotNetType(t).MakeArrayType(rank).ClassObject;
			}
			if(!IsVisibleAsClass(t))
			{
				return null;
			}
			TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(t);
			if(tw != null)
			{
				return tw.MakeArrayType(rank).ClassObject;
			}
			return null;
		}

		public static jlClass getFriendlyClassFromType(Type type)
		{
			int rank = 0;
			while(ReflectUtil.IsVector(type))
			{
				type = type.GetElementType();
				rank++;
			}
			if(type.DeclaringType != null
				&& AttributeHelper.IsGhostInterface(type.DeclaringType))
			{
				type = type.DeclaringType;
			}
			if(!IsVisibleAsClass(type))
			{
				return null;
			}
			TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromType(type);
			if(wrapper == null)
			{
				return null;
			}
			if(rank > 0)
			{
				wrapper = wrapper.MakeArrayType(rank);
			}
			return wrapper.ClassObject;
		}

		private static bool IsVisibleAsClass(Type type)
		{
			while (type.HasElementType)
			{
				if (type.IsPointer || type.IsByRef)
				{
					return false;
				}
				type = type.GetElementType();
			}
			if (type.ContainsGenericParameters && !type.IsGenericTypeDefinition)
			{
				return false;
			}
			System.Reflection.Emit.TypeBuilder tb = type as System.Reflection.Emit.TypeBuilder;
			if (tb != null && !tb.IsCreated())
			{
				return false;
			}
			return true;
		}

		public static Type getInstanceTypeFromClass(jlClass clazz)
		{
			TypeWrapper wrapper = TypeWrapper.FromClass(clazz);
			if(wrapper.IsRemapped && wrapper.IsFinal)
			{
				return wrapper.TypeAsTBD;
			}
			return wrapper.TypeAsBaseType;
		}

		[HideFromJava]
		public static Exception mapException(Exception x)
		{
			return ExceptionHelper.MapException<Exception>(x, true, false);
		}

		public static Exception unmapException(Exception x)
		{
			return ExceptionHelper.UnmapException(x);
		}
	}
}
@


1.81
log
@Bug fix. Handle malformed UTF-16 (invalid surrogates) in type/member names and annotations.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2014 Jeroen Frijters
d26 1
d135 18
@


1.80
log
@- Enabled MethodParameter rendering in runtime stub generator.
- Support round tripping malformed MethodParameter attribute in stub generator.
- Use new general method parameter interface in ikvmstub.
- Added support for method parameter reflection on .NET types.
@
text
@d195 5
@


1.79
log
@Fixed PackageListAttribute to be ECMA compliant.
@
text
@d53 1
a53 1
			IKVM.StubGen.StubGenerator.WriteClass(mem, TypeWrapper.FromClass(c), includeNonPublicInterfaces, false, false, false);
@


1.78
log
@First part of OpenJDK 8 integration.
@
text
@d342 1
a342 1
			foreach (string[] packages in wrapper.GetPackageInfo())
d346 1
a346 1
				if (packages[0] != null)
d348 1
a348 1
					global::java.util.jar.JarFile jarFile = new global::java.util.jar.JarFile(VirtualFileSystem.GetAssemblyResourcesPath(wrapper.MainAssembly) + packages[0]);
d355 1
a355 1
				for (int i = 1; i < packages.Length; i++)
a356 1
					string name = packages[i];
@


1.77
log
@Added support for getting package information from the right jar manifest for ikvmc compiled jars.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2007, 2010 Jeroen Frijters
d28 1
d123 47
@


1.76
log
@Bug fixes:
- If an annotation is of a type that is not an annotation, it should be ignored.
- Annotations that contain no longer existing values should not fail, but just ignore the value.
- Class or enum values in annotations that refer to non-existing types should use TypeNotPresentExceptionProxy as the value, instead of failing to create the annotation.
- Emulate some JDK bugs.
- If an annotation value is of the wrong type, use AnnotationTypeMismatchExceptionProxy as the value, instead of failing to create the annotation.
@
text
@a273 19
		private static global::java.util.jar.Manifest GetManifest(global::java.lang.ClassLoader _this)
		{
			try
			{
				global::java.net.URL url = findResource(_this, "META-INF/MANIFEST.MF");
				if (url != null)
				{
					return new global::java.util.jar.Manifest(url.openStream());
				}
			}
			catch (global::java.net.MalformedURLException)
			{
			}
			catch (global::java.io.IOException)
			{
			}
			return null;
		}

d294 1
a294 3
			global::java.util.jar.Manifest manifest = GetManifest(_this);
			global::java.util.jar.Attributes attr = null;
			if (manifest != null)
d296 12
a307 7
				attr = manifest.getMainAttributes();
			}
			string[] packages = wrapper.GetPackages();
			for (int i = 0; i < packages.Length; i++)
			{
				string name = packages[i];
				if (_this.getPackage(name) == null)
d309 2
a310 2
					global::java.util.jar.Attributes entryAttr = null;
					if (manifest != null)
d312 13
a324 1
						entryAttr = manifest.getAttributes(name.Replace('.', '/') + '/');
a325 8
					_this.definePackage(name,
						GetAttributeValue(global::java.util.jar.Attributes.Name.SPECIFICATION_TITLE, entryAttr, attr),
						GetAttributeValue(global::java.util.jar.Attributes.Name.SPECIFICATION_VERSION, entryAttr, attr),
						GetAttributeValue(global::java.util.jar.Attributes.Name.SPECIFICATION_VENDOR, entryAttr, attr),
						GetAttributeValue(global::java.util.jar.Attributes.Name.IMPLEMENTATION_TITLE, entryAttr, attr),
						GetAttributeValue(global::java.util.jar.Attributes.Name.IMPLEMENTATION_VERSION, entryAttr, attr),
						GetAttributeValue(global::java.util.jar.Attributes.Name.IMPLEMENTATION_VENDOR, entryAttr, attr),
						"true".Equals(GetAttributeValue(global::java.util.jar.Attributes.Name.SEALED, entryAttr, attr), StringComparison.OrdinalIgnoreCase) ? sealBase : null);
@


1.75
log
@Added ikvmstub -parameters option to add parameter names to stub classes.
@
text
@d155 9
@


1.74
log
@Performance fix. When throwing a ClassNotFoundException from Class.forName() or AssemblyClassLoader.loadClass() we should avoid calling fillInStackTrace() on the exception.
@
text
@d52 1
a52 1
			IKVM.StubGen.StubGenerator.WriteClass(mem, TypeWrapper.FromClass(c), includeNonPublicInterfaces, false, false);
@


1.73
log
@- Removed unneeded use of reflection.
- Made accidentally public methods newAnnotation() and decodeElementValue() internal.
- Made writeReplace() method private.
@
text
@d182 3
a184 1
					throw new ClassNotFoundException(name);
@


1.72
log
@Removed unused code.
@
text
@d144 12
@


1.71
log
@VirtualFileSystem.GetAssemblyClassesPath() is now available in first compilation pass.
@
text
@a143 57

	namespace stubgen
	{
		static class StubGenerator
		{
			public static int getRealModifiers(jlClass c)
			{
				return (int)TypeWrapper.FromClass(c).Modifiers;
			}

			public static string getAssemblyName(jlClass c)
			{
				TypeWrapper wrapper = TypeWrapper.FromClass(c);
				ClassLoaderWrapper loader = wrapper.GetClassLoader();
				IKVM.Internal.AssemblyClassLoader acl = loader as IKVM.Internal.AssemblyClassLoader;
				if(acl != null)
				{
					return acl.GetAssembly(wrapper).FullName;
				}
				else
				{
					return ((GenericClassLoaderWrapper)loader).GetName();
				}
			}

			public static object getFieldConstantValue(object field)
			{
				return FieldWrapper.FromField(field).GetConstant();
			}

			public static bool isFieldDeprecated(object field)
			{
				FieldWrapper fieldWrapper = FieldWrapper.FromField(field);
				FieldInfo fi = fieldWrapper.GetField();
				if(fi != null)
				{
					return fi.IsDefined(typeof(ObsoleteAttribute), false);
				}
				return false;
			}

			public static bool isMethodDeprecated(object method)
			{
				MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(method);
				MethodBase mb = mw.GetMethod();
				return mb != null && mb.IsDefined(typeof(ObsoleteAttribute), false);
			}

			public static bool isClassDeprecated(jlClass clazz)
			{
				Type type = TypeWrapper.FromClass(clazz).TypeAsTBD;
				// we need to check type for null, because ReflectionOnly
				// generated delegate inner interfaces don't really exist
				return type != null && type.IsDefined(typeof(ObsoleteAttribute), false);
			}
		}
	}
@


1.71.2.1
log
@Removed unused code.
@
text
@d144 57
@


1.71.2.2
log
@Backported fixes:
- Volatile long/double fields should not use slow reflection.
- Reduce complexity of annotation custom attributes to improve perf and lower risk (in broken apps that should have used ReflectionOnly).
- Removed accidentally public methods from AnnotationAttributeBase.
- Fixed AnnotationAttributeBase to freeze in writeReplace/Equals/GetHashCode/ToString.
@
text
@a143 12

	static class AnnotationAttributeBase
	{
		public static object newAnnotationInvocationHandler(jlClass type, object memberValues)
		{
#if FIRST_PASS
			return null;
#else
			return new global::sun.reflect.annotation.AnnotationInvocationHandler(type, (global::java.util.Map)memberValues);
#endif
		}
	}
@


1.70
log
@Simplified class loading exception handling.
@
text
@a119 3
#if FIRST_PASS
			return null;
#else
a120 1
#endif
@


1.69
log
@Remove Assembly field from AssemblyClassLoader, instead associate the ikvm.runtime.AssemblyClassLoader with the runtime AssemblyClassLoader.
@
text
@d218 3
a220 6
#if !FIRST_PASS
			if (!global::java.lang.ClassLoader.checkName(name))
			{
				throw new global::java.lang.ClassNotFoundException(name);
			}
#endif
d223 4
d229 1
a229 1
				if(tw == null)
d236 11
a246 1
			catch(RetargetableJavaException x)
d251 1
@


1.68
log
@Moved AssemblyClassLoader package definition to runtime.
@
text
@d211 6
a216 1
		public static global::java.lang.Class LoadClass(global::java.lang.ClassLoader classLoader, Assembly assembly, string name)
d226 1
a226 1
				IKVM.Internal.AssemblyClassLoader wrapper = IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
d232 1
a232 1
				Tracer.Info(Tracer.ClassLoading, "Loaded class \"{0}\" from {1}", name, classLoader == null ? "boot class loader" : (object)classLoader);
d237 1
a237 1
				Tracer.Info(Tracer.ClassLoading, "Failed to load class \"{0}\" from {1}", name, classLoader == null ? "boot class loader" : (object)classLoader);
d242 1
a242 1
		public static global::java.net.URL getResource(Assembly assembly, string name)
d245 1
a245 1
			IKVM.Internal.AssemblyClassLoader wrapper = IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
d254 1
a254 1
		public static global::java.util.Enumeration getResources(Assembly assembly, string name)
d259 22
a280 1
			return new global::ikvm.runtime.EnumerationWrapper(IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly).GetResources(name));
d304 1
a304 1
				global::java.net.URL url = _this.findResource("META-INF/MANIFEST.MF");
d369 5
@


1.67
log
@Removed now unused methods.
@
text
@a236 14
		public static global::java.net.URL GetManifest(Assembly assembly)
		{
#if FIRST_PASS
			return null;
#else
			IKVM.Internal.AssemblyClassLoader wrapper = IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
			foreach (global::java.net.URL url in wrapper.FindResources("META-INF/MANIFEST.MF"))
			{
				return url;
			}
			return null;
#endif
		}

d258 36
a293 2
		// NOTE the array may contain duplicates!
		public static string[] GetPackages(Assembly assembly)
d295 26
a320 3
			IKVM.Internal.AssemblyClassLoader wrapper = IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
			string[] packages = new string[0];
			foreach(Module m in wrapper.MainAssembly.GetModules(false))
d322 2
a323 2
				object[] attr = m.GetCustomAttributes(typeof(PackageListAttribute), false);
				foreach(PackageListAttribute p in attr)
d325 13
a337 5
					string[] mp = p.GetPackages();
					string[] tmp = new string[packages.Length + mp.Length];
					Array.Copy(packages, 0, tmp, 0, packages.Length);
					Array.Copy(mp, 0, tmp, packages.Length, mp.Length);
					packages = tmp;
d340 1
a340 1
			return packages;
@


1.66
log
@- More class loading refactoring.
- When we call a custom class loader and it fails to load a class, don't attempt to do a dynamic load. It is the responsibility of the custom class loader to load dynamic classes from the assembly (typically by delegating to an ikvm.runtime.AssemblyClassLoader parent).
- Allow dynamic class loading from boot class "path" and referenced assemblies.
@
text
@a271 12
		private static Assembly GetAssemblyFromClass(jlClass clazz)
		{
			TypeWrapper wrapper = TypeWrapper.FromClass(clazz);
			AssemblyClassLoader_ acl = wrapper.GetClassLoader() as AssemblyClassLoader_;
			return acl != null ? acl.GetAssembly(wrapper) : null;
		}

		private static bool IsDynamic(jlClass clazz)
		{
			return TypeWrapper.FromClass(clazz) is DynamicTypeWrapper;
		}

@


1.65
log
@Removed the old Java stub class generator and replaced it with the ikvmstub core.
@
text
@d221 3
a223 2
				TypeWrapper tw = null;
				if(classLoader == null)
d225 1
a225 27
					tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(name);
				}
				else if(assembly != null)
				{
					AssemblyClassLoader_ acl = global::IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
					tw = acl.FindLoadedClass(name);
					if(tw == null)
					{
						tw = acl.FindOrLoadGenericClass(name, false);
					}
					if(tw == null)
					{
						tw = acl.LoadBootstrapIfNonJavaAssembly(name);
					}
					if(tw == null)
					{
						tw = acl.LoadDynamic(name);
					}
					if(tw == null)
					{
						throw new ClassNotFoundException(name);
					}
				}
				else
				{
					// this must be a GenericClassLoader
					tw = ((GenericClassLoaderWrapper)ClassLoaderWrapper.GetClassLoaderWrapper(classLoader)).LoadClassByDottedName(name);
@


1.64
log
@Use EnumerationWrapper to lazily expose the resources.
@
text
@d47 10
@


1.63
log
@Removed remains of generic class loader support from AssemblyClassLoader.
@
text
@d283 1
a283 7
			global::java.util.Vector v = new global::java.util.Vector();
			IKVM.Internal.AssemblyClassLoader wrapper = IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
			foreach (global::java.net.URL url in wrapper.GetResources(name))
			{
				v.addElement(url);
			}
			return v.elements();
@


1.62
log
@Untangled generic class loader resource loading.
@
text
@d266 1
a266 1
		public static global::java.net.URL getResource(global::java.lang.ClassLoader classLoader, Assembly assembly, string name)
d268 3
a270 4
#if FIRST_PASS
			return null;
#else
			if (assembly != null)
d272 1
a272 5
				IKVM.Internal.AssemblyClassLoader wrapper = IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
				foreach (global::java.net.URL url in wrapper.GetResources(name))
				{
					return url;
				}
a273 1
			return GetClassResource(classLoader, assembly, name);
d275 1
d278 1
a278 1
		public static global::java.util.Enumeration getResources(global::java.lang.ClassLoader classLoader, Assembly assembly, string name)
d284 2
a285 1
			if (assembly != null)
d287 1
a287 14
				IKVM.Internal.AssemblyClassLoader wrapper = IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
				foreach (global::java.net.URL url in wrapper.GetResources(name))
				{
					v.addElement(url);
				}
			}
			// we'll only generate a stub class if there isn't already a resource with this name
			if (v.isEmpty())
			{
				global::java.net.URL curl = GetClassResource(classLoader, assembly, name);
				if (curl != null)
				{
					v.addElement(curl);
				}
a292 42
#if !FIRST_PASS
		private static global::java.net.URL GetClassResource(global::java.lang.ClassLoader classLoader, Assembly assembly, string name)
		{
			if (name.EndsWith(".class", StringComparison.Ordinal) && name.IndexOf('.') == name.Length - 6)
			{
				global::java.lang.Class c = null;
				try
				{
					c = LoadClass(classLoader, assembly, name.Substring(0, name.Length - 6).Replace('/', '.'));
				}
				catch (global::java.lang.ClassNotFoundException)
				{
				}
				catch (global::java.lang.LinkageError)
				{
				}
				if (c != null && !IsDynamic(c))
				{
					assembly = GetAssemblyFromClass(c);
					try
					{
						if (assembly != null)
						{
							return new global::java.io.File(VirtualFileSystem.GetAssemblyClassesPath(assembly) + name).toURI().toURL();
						}
						else
						{
							// HACK we use an index to identify the generic class loader in the url
							// TODO this obviously isn't persistable, we should use a list of assemblies instead.
							return new global::java.net.URL("ikvmres", "gen", ClassLoaderWrapper.GetGenericClassLoaderId(ClassLoaderWrapper.GetClassLoaderWrapper(c.getClassLoader())), "/" + name);
						}
					}
					catch (global::java.net.MalformedURLException x)
					{
						throw (global::java.lang.InternalError)new global::java.lang.InternalError().initCause(x);
					}
				}
			}
			return null;
		}
#endif

@


1.61
log
@Inlined function that's only used once.
@
text
@d453 10
@


1.60
log
@Stop abusing ikvm.runtime.AssemblyClassLoader as a class loader for generic types.
@
text
@d339 1
a339 1
							return new global::java.net.URL("ikvmres", "gen", GetGenericClassLoaderId(c.getClassLoader()), "/" + name);
a383 9
		public static int GetGenericClassLoaderId(global::java.lang.ClassLoader classLoader)
		{
#if FIRST_PASS
            return 0;
#else
			return ClassLoaderWrapper.GetGenericClassLoaderId(ClassLoaderWrapper.GetClassLoaderWrapper(classLoader));
#endif
		}

@


1.59
log
@FindLoadedClass() should also returned types from referenced assemblies.
@
text
@d159 1
a159 1
					return ((IKVM.Internal.GenericClassLoader)loader).GetName();
d240 1
a240 1
					tw = ((GenericClassLoader)ClassLoaderWrapper.GetClassLoaderWrapper(classLoader)).LoadClassByDottedName(name);
d387 1
a387 1
			return 0;
a392 9
		public static string GetGenericClassLoaderName(global::java.lang.ClassLoader classLoader)
		{
#if FIRST_PASS
			return null;
#else
			return ((GenericClassLoader)ClassLoaderWrapper.GetClassLoaderWrapper(classLoader)).GetName();
#endif
		}

d456 8
@


1.58
log
@Changed AssemblyClassLoader.FindLoadedClassImpl() to return generic types.
@
text
@d226 1
a226 1
						tw = acl.LoadReferenced(name);
@


1.57
log
@Bug fix. Disallow invalid class names in AssemblyClassLoader.loadClass().
@
text
@d222 1
a222 1
						tw = acl.LoadGenericClass(name);
@


1.56
log
@Renamed ClassLoaderWrapper.GetLoadedClass() to FindLoadedClass().
@
text
@d203 6
@


1.55
log
@- Allow dynamic class loading (from resources) when there is no custom assembly class loader.
- Allow dynamic class loading when calling AssemblyClassLoader.loadClass() directly.
@
text
@d213 1
a213 1
					tw = acl.GetLoadedClass(name);
@


1.54
log
@Changed object to java.lang.ClassLoader in some signatures.
@
text
@d224 4
@


1.53
log
@Added more Class and ClassLoader types in signatures.
@
text
@d201 1
a201 1
		public static global::java.lang.Class LoadClass(object classLoader, Assembly assembly, string name)
d232 1
a232 1
				Tracer.Info(Tracer.ClassLoading, "Loaded class \"{0}\" from {1}", name, classLoader == null ? "boot class loader" : classLoader);
d237 1
a237 1
				Tracer.Info(Tracer.ClassLoading, "Failed to load class \"{0}\" from {1}", name, classLoader == null ? "boot class loader" : classLoader);
d374 1
a374 1
		public static int GetGenericClassLoaderId(object classLoader)
d383 1
a383 1
		public static string GetGenericClassLoaderName(object classLoader)
@


1.52
log
@Fixed some minor class modifiers issues:
- stub generator now reproduces exact class modifier bits
- unused bits are now properly masked and returned
- non-abstract interfaces now properly return ACC_ABSTRACT
@
text
@d92 1
a92 1
		public static object GetGenericClassLoaderById(int id)
d123 1
a123 1
		public static object GetClass(object obj)
d128 1
a128 1
		public static object GetClassLoader(object obj)
d133 1
a133 1
		public static object GetAssemblyClassLoader(Assembly asm)
d392 1
a392 1
		public static object getAssemblyClassLoader(Assembly asm)
@


1.51
log
@Fixed regression introduced in 7.0 that caused the manifest to be ignored when creating the Package objects.
@
text
@d143 5
@


1.50
log
@Removed legacy remap feature that allowed final fields as properties to be defined (long time ago this was used for the System.in/out/err fields).
@
text
@d237 14
@


1.49
log
@Added support for classes that represent arrays of remapped .NET types and .NET primitives.
@
text
@a170 5
				GetterFieldWrapper getter = fieldWrapper as GetterFieldWrapper;
				if(getter != null)
				{
					return getter.GetProperty().IsDefined(typeof(ObsoleteAttribute), false);
				}
@


1.48
log
@Set system property "sun.boot.class.path" to point to the /classes/ directory of IKVM.OpenJDK.Core.dll
@
text
@d493 19
@


1.48.2.1
log
@Backported fixes for 0.46.0.3:
- Bug fix. java.lang.Package was not populated from manifest for ikvmc compiled assemblies.
- Bug fix. When writing a direct ByteBuffer to a non-blocking socket and the write fails because there is no kernel buffer available, we should not advance the ByteBuffer position.
- Bug fix. When adding certificates to virtual cacerts file make sure that the aliases are unique.
- Bug fix. If a finally/fault handler contains reachable code before the handler's start index, the handler should branch to the handler start index.
- Bug fix. After emitting a finally/fault handler block, we should emit the block leave stubs (even though you can't leave the block, they also emit the backward branch stubs).
- Bug fix. If a Java class extends a remapped .NET type (cli.System.Object or cli.System.Exception), we should correctly report the base class.
- Bug fix. If we encounter a jsr or ret instruction, we should throw a VerifyError (instead of NotImplementedException).
- Bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
- Disable AppDomain.ProcessExit hook to run shutdown hooks when running on Mono to workaround https://bugzilla.xamarin.com/show_bug.cgi?id=5650
- Bug fix. Custom attribute properties that don't have a public getter and setter should not be exposed as annotation properties.
- Bug fix. Non-public property getter/setter methods should be ignored when we create properties to hide properties inherited from shadow types. This fixes a build break with .NET 4.5 beta which introduces a protected setter for Exception.HResult.
- Bug fix. The $Method inner class for delegates should also be loadable for generic delegates. Thanks to Michael Bayne for reporting this.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Replaced non-ascii character (micro) with ascii 'u' in Win32PrintService.java.
- IKVM.Reflection: Bug fix. Resource Directory Entries must be sorted and names are case-insensitive

Backported for 0.46.0.4:
- Fixed ikvmc to retain transient modifier on constant static final fields.
- Fixed Field.getModifiers() to only return the relevant modifiers.
- Fixed IKVM.Reflection to set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@a241 14
		public static global::java.net.URL GetManifest(Assembly assembly)
		{
#if FIRST_PASS
			return null;
#else
			IKVM.Internal.AssemblyClassLoader wrapper = IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
			foreach (global::java.net.URL url in wrapper.FindResources("META-INF/MANIFEST.MF"))
			{
				return url;
			}
			return null;
#endif
		}

@


1.47
log
@Don't generate stub class if the assembly already contains a resource with the same name.
@
text
@d107 9
@


1.46
log
@Fixed regression that caused getResources() on generic class loader to throw NPE.
@
text
@d264 2
a265 2
			global::java.net.URL curl = GetClassResource(classLoader, assembly, name);
			if (curl != null)
d267 5
a271 1
				v.addElement(curl);
@


1.45
log
@Massive change to change resource handling. Java resources are now stored in jars that are stored as managed .NET resources. The jars are projected into VFS and the assembly class loaders know how to load resources from these jars.
@
text
@d256 1
a256 2
			IKVM.Internal.AssemblyClassLoader wrapper = IKVM.Internal.AssemblyClassLoader.FromAssembly(assembly);
			foreach (global::java.net.URL url in wrapper.GetResources(name))
d258 5
a262 1
				v.addElement(url);
@


1.44
log
@Made MapException generic, instead of passing the type explicitly.
@
text
@d25 1
d192 1
a192 1
		public static object LoadClass(object classLoader, Assembly assembly, string name)
d233 1
a233 1
		public static Assembly[] FindResourceAssemblies(Assembly assembly, string name, bool firstOnly)
d235 21
d257 1
a257 2
			Assembly[] assemblies = wrapper.FindResourceAssemblies(name, firstOnly);
			if(assemblies == null || assemblies.Length == 0)
d259 1
a259 2
				Tracer.Info(Tracer.ClassLoading, "Failed to find resource \"{0}\" in {1}", name, assembly.FullName);
				return null;
d261 2
a262 1
			foreach(Assembly asm in assemblies)
d264 1
a264 1
				Tracer.Info(Tracer.ClassLoading, "Found resource \"{0}\" in {1}", name, asm.FullName);
d266 2
a267 1
			return assemblies;
d270 43
a312 1
		public static Assembly GetAssemblyFromClass(jlClass clazz)
d319 1
a319 1
		public static bool IsDynamic(jlClass clazz)
d382 30
a411 1
		public static bool findResourceInAssembly(Assembly asm, string resourceName)
d413 2
a414 1
			if(ReflectUtil.IsDynamicAssembly(asm))
d416 4
a419 1
				return false;
d421 1
a421 1
			return asm.GetManifestResourceInfo(JVM.MangleResourceName(resourceName)) != null;
@


1.43
log
@Removed exception mapping methods from Throwable and consolidated into a single method (actually, two methods, but the dynamic one should not be necessary and should be removed later).
@
text
@d444 1
a444 1
			return ExceptionHelper.MapException(x, typeof(Exception), true, false);
@


1.42
log
@Moved ExceptionHelper into proper namespace and some cleanup.
@
text
@d444 1
a444 1
			return ExceptionHelper.MapExceptionFast(x, true);
@


1.41
log
@- Added new public API to unmap exception (ikvm.runtime.Util.unmapException()).
- Moved (parts of) mapping and unmapping to C# side.
@
text
@d444 1
a444 5
#if FIRST_PASS
			return null;
#else
			return global::IKVM.NativeCode.java.lang.ExceptionHelper.MapExceptionFast(x, true);
#endif
d449 1
a449 5
#if FIRST_PASS
			return null;
#else
			return global::IKVM.NativeCode.java.lang.ExceptionHelper.UnmapException(x);
#endif
@


1.40
log
@More object -> java.lang.Class updates.
@
text
@d440 19
@


1.39
log
@The AssemblyClassLoader should not claim to be able to load .class resources for dynamically loaded classes.
@
text
@d31 1
d133 1
a133 1
			public static string getAssemblyName(object c)
d176 1
a176 1
			public static bool isClassDeprecated(object clazz)
d248 1
a248 1
		public static Assembly GetAssemblyFromClass(object clazz)
d255 1
a255 1
		public static bool IsDynamic(object clazz)
d330 1
a330 1
		public static object getClassFromObject(object o)
d361 1
a361 1
		public static object getClassFromTypeHandle(RuntimeTypeHandle handle)
d380 1
a380 1
		public static object getFriendlyClassFromType(Type type)
d431 1
a431 1
		public static Type getInstanceTypeFromClass(object clazz)
@


1.38
log
@We don't need to use our own version of IsDefined to test for custom attributes, because there is no confusion about what runtime types to use anymore.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d254 5
@


1.37
log
@Added a couple of checks to avoid problems when user code tries to convert .NET types that aren't supported into a Class.
@
text
@d158 1
a158 1
					return AttributeHelper.IsDefined(fi, typeof(ObsoleteAttribute));
d163 1
a163 1
					return AttributeHelper.IsDefined(getter.GetProperty(), typeof(ObsoleteAttribute));
d172 1
a172 1
				return mb != null && AttributeHelper.IsDefined(mb, typeof(ObsoleteAttribute));
d180 1
a180 1
				return type != null && AttributeHelper.IsDefined(type, typeof(ObsoleteAttribute));
@


1.36
log
@Replaced incorrect usages of Type.IsArray with ReflectUtil.IsVector().
@
text
@d362 4
d387 4
d403 22
@


1.35
log
@When an object is an instance of a HideFromJava type, hide that type and traverse up the type hierarchy to find the first non-HideFromJava non-abstract type.
@
text
@d373 1
a373 1
			while(type.IsArray)
@


1.34
log
@Removed ReflectionOnly support from runtime. Now that ikvmstub no longer requires it, there's no good reason to allow Java code to see ReflectionOnly types.
@
text
@d341 1
a341 1
			else
d343 9
a351 1
				return ClassLoaderWrapper.GetWrapperFromType(t);
@


1.33
log
@Added public API to get ClassLoader from Assembly.
@
text
@a86 4
			if(name.EndsWith("[ReflectionOnly]"))
			{
				return Assembly.ReflectionOnlyLoad(name.Substring(0, name.Length - 16));
			}
a273 5
		public static bool IsReflectionOnly(Assembly asm)
		{
			return asm.ReflectionOnly;
		}

@


1.32
log
@Moved GetAssemblyClassLoader() (and related stuff) from ClassLoaderWrapper to AssemblyClassLoader and renamed it to FromAssembly().
@
text
@d300 7
@


1.32.2.1
log
@back ported fix: don't use Type.IsArray when we only want to deal with vectors.
@
text
@d367 1
a367 1
			while(ReflectUtil.IsVector(type))
@


1.31
log
@Added support for exposing open generic types as Java classes (special "handle" classes that can only be used for stack walking).
@
text
@d77 1
a77 1
			TypeWrapper tw = ClassLoaderWrapper.GetAssemblyClassLoader(asm).LoadClassByDottedNameFast(className);
d128 1
a128 1
			return ClassLoaderWrapper.GetAssemblyClassLoader(asm).GetJavaClassLoader();
d205 1
a205 1
					AssemblyClassLoader_ acl = ClassLoaderWrapper.GetAssemblyClassLoader(assembly);
d237 1
a237 1
			IKVM.Internal.AssemblyClassLoader wrapper = ClassLoaderWrapper.GetAssemblyClassLoader(assembly);
d261 1
a261 1
			IKVM.Internal.AssemblyClassLoader wrapper = ClassLoaderWrapper.GetAssemblyClassLoader(assembly);
d310 1
a310 1
			TypeWrapper tw = ClassLoaderWrapper.GetAssemblyClassLoader(asm).DoLoad(className);
@


1.30
log
@- Set runtime version during build, instead of computing it a runtime.
- Set OpenJDK version in openjdk.build instead of VMSystemProperty source.
@
text
@a355 4
			if(t.ContainsGenericParameters)
			{
				return null;
			}
a365 4
			if(type.ContainsGenericParameters)
			{
				return null;
			}
@


1.29
log
@- Consolidated system property initialization in VMSystemProperties.
- Fixed bug that caused startup properties set with ikvm.runtime.Startup.setProperties() to be forgotten when doing a System.setProperties(null).
@
text
@a108 12

		public static string getVersion()
		{
			try
			{
				return JVM.SafeGetAssemblyVersion(typeof(VMSystemProperties).Assembly).ToString();
			}
			catch(Exception)
			{
				return "(unknown)";
			}
		}
@


1.28
log
@Moved VMSystemProperties from gnu.classpath to java.lang.
@
text
@d105 5
@


1.27
log
@Made dynamic assembly detection more reliable and moved the utility method to ReflectUtil.
@
text
@d101 1
a101 1
namespace IKVM.NativeCode.gnu.classpath
@


1.26
log
@Changed DynamicClassLoader API to make it easier to move from global AssemblyBuilder to per ClassLoader.
@
text
@d313 1
a313 1
			if(DynamicClassLoader.IsDynamicAssembly(asm))
d323 1
a323 1
			if(DynamicClassLoader.IsDynamicAssembly(asm))
@


1.25
log
@Reverted previous optimization that I'm not sure about anymore. The startup overhead of using a ConcurrentHashMap here may be too great.
@
text
@d313 1
a313 1
			if(asm is System.Reflection.Emit.AssemblyBuilder)
a316 5
			if(asm.Equals(DynamicClassLoader.Instance.ModuleBuilder.Assembly))
			{
				// this can happen on Orcas, where an AssemblyBuilder has a corresponding Assembly
				return null;
			}
d323 1
a323 5
			if(asm is System.Reflection.Emit.AssemblyBuilder)
			{
				return false;
			}
			if(asm.Equals(DynamicClassLoader.Instance.ModuleBuilder.Assembly))
a324 1
				// this can happen on Orcas, where an AssemblyBuilder has a corresponding Assembly
@


1.24
log
@Added caching to speed up Object.getClass().
@
text
@a342 4
#if !FIRST_PASS
		private static readonly global::java.util.concurrent.ConcurrentHashMap instanceTypeWrappers = new global::java.util.concurrent.ConcurrentHashMap();
#endif

a349 3
#if FIRST_PASS
            return null;
#else
a355 5
			TypeWrapper tw = (TypeWrapper)instanceTypeWrappers.get(t);
			if(tw != null)
			{
				return tw;
			}
d358 1
a358 1
				tw = DotNetTypeWrapper.GetWrapperFromDotNetType(t);
d362 1
a362 1
				tw = ClassLoaderWrapper.GetWrapperFromType(t);
a363 3
			instanceTypeWrappers.put(t, tw);
			return tw;
#endif
@


1.23
log
@Renamed AssemblyClassLoader.Assembly to MainAssembly.
@
text
@d343 4
d354 8
d363 5
d370 1
a370 1
				return DotNetTypeWrapper.GetWrapperFromDotNetType(t);
d372 1
a372 2
			TypeWrapper ghostType = GhostTag.GetTag(o);
			if(ghostType != null)
d374 1
a374 1
				return ghostType;
d376 3
a378 1
			return ClassLoaderWrapper.GetWrapperFromType(t);
@


1.22
log
@Added AssemblyClassLoader.GetAssembly(TypeWrapper) and changed most code that assumed that an AssemblyClassLoader represented a single assembly to use it.
@
text
@d270 1
a270 1
			foreach(Module m in wrapper.Assembly.GetModules(false))
@


1.21
log
@Removed our version of System.Runtime.CompilerServices.ExtensionAttribute and instead add System.Core.jar to the compilation, this will allow us to reference the real ExtensionAttribute when it is available and yet the build will still work (albeit with a warning and without the ExtensionAttribute) when it is not available (i.e. when building on .NET 2.0).
@
text
@d145 2
a146 1
				ClassLoaderWrapper loader = TypeWrapper.FromClass(c).GetClassLoader();
d150 1
a150 1
					return acl.Assembly.FullName;
d248 1
a248 1
				Tracer.Info(Tracer.ClassLoading, "Failed to find resource \"{0}\" in {1}", name, wrapper.Assembly.FullName);
d258 1
a258 1
		public static Assembly GetAssemblyFromClassLoader(object classLoader)
d260 3
a262 2
			AssemblyClassLoader_ acl = ClassLoaderWrapper.GetClassLoaderWrapper(classLoader) as AssemblyClassLoader_;
			return acl != null ? acl.Assembly : null;
a298 5
		public static Assembly GetBootClassLoaderAssembly()
		{
			return ClassLoaderWrapper.GetBootstrapClassLoader().Assembly;
		}

@


1.20
log
@Generified all collections.
@
text
@a40 19
// HACK we have our own version of ExtensionAttribute to avoid a System.Core.dll (i.e. .NET 3.5) dependency
// it turns out that the C# compiler will honor the attribute, even if it's from a different assembly
// (note that it's internal because it should only be used by the core class library assembly and it will
// go away at some point in the future (when taking a .NET 3.5 dependency is acceptable))
namespace System.Runtime.CompilerServices
{
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
	// HACK we only "see" public attributes (as Java annotations),
	// so we make our ExtensionAttribute public in the first compilation pass
	// (we don't want it to be public later on, because that will cause conflicts
	// with the real ExtensionAttribute).
#if FIRST_PASS
	public
#endif
	sealed class ExtensionAttribute : Attribute
	{
	}
}

@


1.19
log
@- Added ghost array tagging to be able to report the instantiated class (instead of object[] which is allocated instead).
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
@
text
@a24 1
using System.Collections;
a26 7
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Runtime.Serialization;
using SystemArray = System.Array;
@


1.18
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@d385 5
@


1.17
log
@Added workarounds for mcs compiler bug (related to the mutual dependency of the runtime and class library assemblies).
@
text
@d148 18
@


1.16
log
@Replaced notion of DynamicOnly types with Fake types. Fake types are implemented as generic type instances and can have DynamicOnly methods.
@
text
@a300 2
#elif OPENJDK
			return ClassLoaderWrapper.GetGenericClassLoaderId(((global::java.lang.ClassLoader)classLoader).wrapper);
d302 1
a302 1
			return ClassLoaderWrapper.GetGenericClassLoaderId((ClassLoaderWrapper)JVM.Library.getWrapperFromClassLoader(classLoader));
a314 2
#elif OPENJDK
			return ((GenericClassLoader)((global::java.lang.ClassLoader)classLoader).wrapper).GetName();
d316 1
a316 1
			return ((GenericClassLoader)JVM.Library.getWrapperFromClassLoader(classLoader)).GetName();
@


1.15
log
@Made ExtensionAttribute public during first-pass compilation, otherwise ikvmc won't see it.
@
text
@a358 6
		private static Type enumEnumType = JVM.CoreAssembly.GetType("ikvm.internal.EnumEnum");
		private static FieldInfo enumEnumTypeField = enumEnumType.GetField("typeWrapper", BindingFlags.Instance | BindingFlags.NonPublic);

		// we don't want "beforefieldinit"
		static Util() {}

a370 4
			if(t == enumEnumType)
			{
				return (TypeWrapper)enumEnumTypeField.GetValue(o);
			}
a424 4
			if(wrapper.IsDynamicOnly)
			{
				return null;
			}
@


1.14
log
@- Added support for defining extension methods in the core class library assembly (without taking a System.Core.dll dependency).
- Added the first two extension methods.
@
text
@d56 7
@


1.13
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@d49 12
@


1.12
log
@Made all "native" method classes internal.
@
text
@d280 5
d286 1
d296 5
d302 1
@


1.11
log
@More .NET 1.1 -> 2.0 work.
@
text
@d51 1
a51 1
	public class Handler
d111 1
a111 1
	public class VMSystemProperties
d131 1
a131 1
		public class StubGenerator
d188 1
a188 1
	public class AssemblyClassLoader
d294 1
a294 1
	public class AppDomainAssemblyClassLoader
d326 1
a326 1
	public class Util
@


1.10
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@a274 1
#if WHIDBEY
a275 3
#else
			return false;
#endif
d360 1
a360 1
			if(Whidbey.ContainsGenericParameters(t))
d374 1
a374 1
			if(Whidbey.ContainsGenericParameters(type))
@


1.9
log
@Fixed AppDomainAssemblyClassLoader to ignore AssemblyBuilders.
@
text
@a50 200
#if !WHIDBEY
	class LZInputStream : Stream 
	{
		private Stream inp;
		private int[] ptr_tbl;
		private int[] char_tbl;
		private int[] stack;
		private int table_size;
		private int count;
		private int bitoff;
		private int bitbuf;
		private int prev = -1;
		private int bits;
		private int cc;
		private int fc;
		private int sp;

		public LZInputStream(Stream inp)
		{
			this.inp = inp;
			bitoff = 0;
			count = 0;
			table_size = 256;
			bits = 9;
			ptr_tbl = new int[table_size];
			char_tbl = new int[table_size];
			stack = new int[table_size];
			sp = 0;
			cc = prev = incode();
			stack[sp++] = cc;
		}

		private int read()
		{
			if (sp == 0) 
			{
				if (stack.Length != table_size) 
				{
					stack = new int[table_size];
				}
				int ic = cc = incode();
				if (cc == -1) 
				{
					return -1;
				}
				if (count >= 0 && cc >= count + 256) 
				{
					stack[sp++] = fc;
					cc = prev;
					ic = find(prev, fc);
				}
				while (cc >= 256) 
				{
					stack[sp++] = char_tbl[cc - 256];
					cc = ptr_tbl[cc - 256];
				}
				stack[sp++] = cc;
				fc = cc;
				if (count >= 0) 
				{
					ptr_tbl[count] = prev;
					char_tbl[count] = fc;
				}
				count++;
				if (count == table_size) 
				{
					count = -1;
					if (bits == 12)
					{
						table_size = 256;
						bits = 9;
					}
					else
					{
						bits++;
						table_size = (1 << bits) - 256;
					}
					ptr_tbl = null;
					char_tbl = null;
					ptr_tbl = new int[table_size];
					char_tbl= new int[table_size];
				}
				prev = ic;
			}
			return stack[--sp] & 0xFF;
		}

		private int find(int p, int c) 
		{
			int i;
			for (i = 0; i < count; i++) 
			{
				if (ptr_tbl[i] == p && char_tbl[i] == c) 
				{
					break;
				}
			}
			return i + 256;
		}

		private int incode()
		{
			while (bitoff < bits) 
			{
				int v = inp.ReadByte();
				if (v == -1) 
				{
					return -1;
				}
				bitbuf |= (v & 0xFF) << bitoff;
				bitoff += 8;
			}
			bitoff -= bits;
			int result = bitbuf;
			bitbuf >>= bits;
			result -= bitbuf << bits;
			return result;
		}

		public override int Read(byte[] b, int off, int len)
		{
			int i = 0;
			for (; i < len ; i++)
			{
				int r = read();
				if(r == -1)
				{
					break;
				}
				b[off + i] = (byte)r;
			}
			return i;
		}

		public override bool CanRead
		{
			get
			{
				return true;
			}
		}

		public override bool CanSeek
		{
			get
			{
				return false;
			}
		}

		public override bool CanWrite
		{
			get
			{
				return false;
			}
		}

		public override void Flush()
		{
			throw new NotSupportedException();
		}

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}
	}
#endif // !WHIDBEY

a62 1
#if WHIDBEY
a80 33
#else
			using(Stream s = asm.GetManifestResourceStream(mangledName))
			{
				if(s == null)
				{
					Tracer.Warning(Tracer.ClassLoading, "Resource \"{0}\" not found in {1}", resource, asm.FullName);
					throw new FileNotFoundException("resource " + resource + " not found in assembly " + asm.FullName);
				}
				using(System.Resources.ResourceReader r = new System.Resources.ResourceReader(s))
				{
					foreach(DictionaryEntry de in r)
					{
						if((string)de.Key == "lz")
						{
							Tracer.Info(Tracer.ClassLoading, "Reading compressed resource \"{0}\" from {1}", resource, asm.FullName);
							return new LZInputStream(new MemoryStream((byte[])de.Value));
						}
						else if((string)de.Key == "ikvm")
						{
							Tracer.Info(Tracer.ClassLoading, "Reading resource \"{0}\" from {1}", resource, asm.FullName);
							return new MemoryStream((byte[])de.Value);
						}
						else
						{
							Tracer.Error(Tracer.ClassLoading, "Resource \"{0}\" in {1} has an unsupported encoding", resource, asm.FullName);
							throw new IOException("Unsupported resource encoding " + de.Key + " for resource " + resource + " found in assembly " + asm.FullName);
						}
					}
					Tracer.Error(Tracer.ClassLoading, "Resource \"{0}\" in {1} is invalid", resource, asm.FullName);
					throw new IOException("Invalid resource " + resource + " found in assembly " + asm.FullName);
				}
			}
#endif
a94 1
#if WHIDBEY
a98 1
#endif
@


1.8
log
@- Did more work to keep up the pretense that an AssemblyClassLoader has already loaded all classes in the assembly.
- Restructured AssemblyClassLoader.GetProtectionDomain() to avoid calling any code while holding the lock.
@
text
@d538 9
d553 9
@


1.7
log
@Made AssemblyClassLoader public and moved it to ikvm.runtime package.
@
text
@d438 2
a439 3
					// HACK we need to support generic type instantiations here, because we may not have gone
					// through LoadClassByDottedNameFastImpl.
					if(name.EndsWith("_$$$$_") && name.IndexOf("_$$$_") > 0)
d445 1
a445 1
						tw = acl.LoadClass(name);
@


1.6
log
@Implemented two custom assembly class loaders.
@
text
@d365 59
a534 59
	namespace stubgen
	{
		public class StubGenerator
		{
			public static string getAssemblyName(object c)
			{
				ClassLoaderWrapper loader = TypeWrapper.FromClass(c).GetClassLoader();
				IKVM.Internal.AssemblyClassLoader acl = loader as IKVM.Internal.AssemblyClassLoader;
				if(acl != null)
				{
					return acl.Assembly.FullName;
				}
				else
				{
					return ((IKVM.Internal.GenericClassLoader)loader).GetName();
				}
			}

			public static object getFieldConstantValue(object field)
			{
				return FieldWrapper.FromField(field).GetConstant();
			}

			public static bool isFieldDeprecated(object field)
			{
				FieldWrapper fieldWrapper = FieldWrapper.FromField(field);
				FieldInfo fi = fieldWrapper.GetField();
				if(fi != null)
				{
					return AttributeHelper.IsDefined(fi, typeof(ObsoleteAttribute));
				}
				GetterFieldWrapper getter = fieldWrapper as GetterFieldWrapper;
				if(getter != null)
				{
					return AttributeHelper.IsDefined(getter.GetProperty(), typeof(ObsoleteAttribute));
				}
				return false;
			}

			public static bool isMethodDeprecated(object method)
			{
				MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(method);
				MethodBase mb = mw.GetMethod();
				return mb != null && AttributeHelper.IsDefined(mb, typeof(ObsoleteAttribute));
			}

			public static bool isClassDeprecated(object clazz)
			{
				Type type = TypeWrapper.FromClass(clazz).TypeAsTBD;
				// we need to check type for null, because ReflectionOnly
				// generated delegate inner interfaces don't really exist
				return type != null && AttributeHelper.IsDefined(type, typeof(ObsoleteAttribute));
			}
		}
	}
}

namespace IKVM.NativeCode.ikvm.runtime
{
@


1.5
log
@Changed AssemblyClassLoader to be useable as a delegation parent for custom assembly class loaders.
@
text
@d535 14
@


1.4
log
@Refactored assembly class loading to be more like regular class loading and prepare for future custom assembly class loaders.
@
text
@d367 1
a367 1
		public static object LoadClass(object classLoader, string name)
d376 1
a376 1
				else
d378 8
a385 3
					ClassLoaderWrapper classLoaderWrapper = (ClassLoaderWrapper)JVM.Library.getWrapperFromClassLoader(classLoader);
					AssemblyClassLoader_ acl = classLoaderWrapper as AssemblyClassLoader_;
					if(acl != null)
d387 1
a387 14
						// HACK we need to support generic type instantiations here, because we may not have gone
						// through LoadClassByDottedNameFastImpl.
						if(name.EndsWith("_$$$$_") && name.IndexOf("_$$$_") > 0)
						{
							tw = acl.LoadGenericClass(name);
						}
						if(tw == null)
						{
							tw = acl.LoadClass(name);
						}
						if(tw == null)
						{
							throw new ClassNotFoundException(name);
						}
d389 1
a389 1
					else
d391 1
a391 2
						// this must be a GenericClassLoader
						tw = ((GenericClassLoader)classLoaderWrapper).LoadClassByDottedName(name);
d394 5
d409 1
a409 1
		public static Assembly[] FindResourceAssemblies(object classLoader, string name, bool firstOnly)
d411 1
a411 7
			IKVM.Internal.AssemblyClassLoader wrapper = classLoader == null ? ClassLoaderWrapper.GetBootstrapClassLoader() : (JVM.Library.getWrapperFromClassLoader(classLoader) as IKVM.Internal.AssemblyClassLoader);
			if(wrapper == null)
			{
				// must be a GenericClassLoader
				Tracer.Info(Tracer.ClassLoading, "Failed to find resource \"{0}\" in generic class loader", name);
				return null;
			}
d425 6
d432 1
a432 1
		public static string[] GetPackages(object classLoader)
d434 1
a434 6
			IKVM.Internal.AssemblyClassLoader wrapper = classLoader == null ? ClassLoaderWrapper.GetBootstrapClassLoader() : (JVM.Library.getWrapperFromClassLoader(classLoader) as IKVM.Internal.AssemblyClassLoader);
			if(wrapper == null)
			{
				// must be a GenericClassLoader
				return null;
			}
d467 1
a467 1
			return ((IKVM.Internal.AssemblyClassLoader)ClassLoaderWrapper.GetBootstrapClassLoader()).Assembly;
@


1.3
log
@Handle types that aren't exposed to Java.
@
text
@d38 1
d371 32
a402 2
				ClassLoaderWrapper wrapper = classLoader == null ? ClassLoaderWrapper.GetBootstrapClassLoader() : (ClassLoaderWrapper)JVM.Library.getWrapperFromClassLoader(classLoader);
				TypeWrapper tw = wrapper.LoadClassByDottedName(name);
@


1.2
log
@Moved VMSystemProperties.getVersion() "native" method to common.cs.
@
text
@d577 4
@


1.2.2.1
log
@Ported fixes from trunk. Changed version to 0.36.0.1.
@
text
@a576 4
			if(wrapper == null)
			{
				return null;
			}
@


1.2.2.2
log
@Backported fixes and changed version to 0.36.0.5
@
text
@a37 1
using AssemblyClassLoader_ = IKVM.Internal.AssemblyClassLoader;
a363 59
	namespace stubgen
	{
		public class StubGenerator
		{
			public static string getAssemblyName(object c)
			{
				ClassLoaderWrapper loader = TypeWrapper.FromClass(c).GetClassLoader();
				IKVM.Internal.AssemblyClassLoader acl = loader as IKVM.Internal.AssemblyClassLoader;
				if(acl != null)
				{
					return acl.Assembly.FullName;
				}
				else
				{
					return ((IKVM.Internal.GenericClassLoader)loader).GetName();
				}
			}

			public static object getFieldConstantValue(object field)
			{
				return FieldWrapper.FromField(field).GetConstant();
			}

			public static bool isFieldDeprecated(object field)
			{
				FieldWrapper fieldWrapper = FieldWrapper.FromField(field);
				FieldInfo fi = fieldWrapper.GetField();
				if(fi != null)
				{
					return AttributeHelper.IsDefined(fi, typeof(ObsoleteAttribute));
				}
				GetterFieldWrapper getter = fieldWrapper as GetterFieldWrapper;
				if(getter != null)
				{
					return AttributeHelper.IsDefined(getter.GetProperty(), typeof(ObsoleteAttribute));
				}
				return false;
			}

			public static bool isMethodDeprecated(object method)
			{
				MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(method);
				MethodBase mb = mw.GetMethod();
				return mb != null && AttributeHelper.IsDefined(mb, typeof(ObsoleteAttribute));
			}

			public static bool isClassDeprecated(object clazz)
			{
				Type type = TypeWrapper.FromClass(clazz).TypeAsTBD;
				// we need to check type for null, because ReflectionOnly
				// generated delegate inner interfaces don't really exist
				return type != null && AttributeHelper.IsDefined(type, typeof(ObsoleteAttribute));
			}
		}
	}
}

namespace IKVM.NativeCode.ikvm.runtime
{
d366 1
a366 1
		public static object LoadClass(object classLoader, Assembly assembly, string name)
d370 2
a371 27
				TypeWrapper tw = null;
				if(classLoader == null)
				{
					tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(name);
				}
				else if(assembly != null)
				{
					AssemblyClassLoader_ acl = ClassLoaderWrapper.GetAssemblyClassLoader(assembly);
					tw = acl.GetLoadedClass(name);
					if(tw == null)
					{
						tw = acl.LoadGenericClass(name);
					}
					if(tw == null)
					{
						tw = acl.LoadReferenced(name);
					}
					if(tw == null)
					{
						throw new ClassNotFoundException(name);
					}
				}
				else
				{
					// this must be a GenericClassLoader
					tw = ((GenericClassLoader)ClassLoaderWrapper.GetClassLoaderWrapper(classLoader)).LoadClassByDottedName(name);
				}
d382 1
a382 1
		public static Assembly[] FindResourceAssemblies(Assembly assembly, string name, bool firstOnly)
d384 7
a390 1
			IKVM.Internal.AssemblyClassLoader wrapper = ClassLoaderWrapper.GetAssemblyClassLoader(assembly);
a403 6
		public static Assembly GetAssemblyFromClassLoader(object classLoader)
		{
			AssemblyClassLoader_ acl = ClassLoaderWrapper.GetClassLoaderWrapper(classLoader) as AssemblyClassLoader_;
			return acl != null ? acl.Assembly : null;
		}

d405 1
a405 1
		public static string[] GetPackages(Assembly assembly)
d407 6
a412 1
			IKVM.Internal.AssemblyClassLoader wrapper = ClassLoaderWrapper.GetAssemblyClassLoader(assembly);
d445 1
a445 1
			return ClassLoaderWrapper.GetBootstrapClassLoader().Assembly;
d454 1
a454 1
	public class AppDomainAssemblyClassLoader
d456 1
a456 1
		public static object loadClassFromAssembly(Assembly asm, string className)
d458 1
a458 1
			if(asm is System.Reflection.Emit.AssemblyBuilder)
d460 10
a469 1
				return null;
d471 2
a472 1
			if(asm.Equals(DynamicClassLoader.Instance.ModuleBuilder.Assembly))
d474 1
a474 2
				// this can happen on Orcas, where an AssemblyBuilder has a corresponding Assembly
				return null;
a475 3
			TypeWrapper tw = ClassLoaderWrapper.GetAssemblyClassLoader(asm).DoLoad(className);
			return tw != null ? tw.ClassObject : null;
		}
d477 1
a477 3
		public static bool findResourceInAssembly(Assembly asm, string resourceName)
		{
			if(asm is System.Reflection.Emit.AssemblyBuilder)
d479 11
d492 9
a500 1
			if(asm.Equals(DynamicClassLoader.Instance.ModuleBuilder.Assembly))
d502 4
a505 2
				// this can happen on Orcas, where an AssemblyBuilder has a corresponding Assembly
				return false;
a506 1
			return asm.GetManifestResourceInfo(JVM.MangleResourceName(resourceName)) != null;
d509 1
d511 2
@


1.1
log
@Moved common (between GNU Classpath & OpenJDK) "native" code to common.cs.
@
text
@d344 18
@

