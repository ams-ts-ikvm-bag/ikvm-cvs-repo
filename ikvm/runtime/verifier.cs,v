head	1.126;
access;
symbols
	v8_1_5717_0:1.126
	v8_1:1.126.0.2
	v8_0_5449_1:1.123
	v8_0_5449_0:1.123
	v8_0:1.123.0.2
	v7_4_5196_0:1.118
	v7_4:1.118.0.2
	v7_3:1.109.0.2
	v7_2_4630_6:1.99.2.1
	v7_2_4630_5:1.99.2.1
	v7_2_4630_4:1.99.2.1
	v7_2_4630_3:1.99
	v7_2_4630_2:1.99
	v0_46_0_4:1.84.2.3
	v7_2_4630_1:1.99
	v7_2:1.99.0.2
	v7_1_4532_2:1.93.2.1
	v7_1_4532_1:1.93
	v7_1_4532_0:1.93
	v7_1:1.93.0.2
	v7_0_4335_3:1.91.2.1
	v7_0_4335_2:1.91.2.1
	v7_0_4335_1:1.91.2.1
	v0_46_0_2:1.84.2.2
	v7_0_4335_0:1.91
	v7_0:1.91.0.2
	v0_40_0_6:1.50.2.1
	v0_40_0_5:1.50.2.1
	v0_46_0_1:1.84
	v0_46_0_0:1.84
	v0_46:1.84.0.2
	v0_36_0_14:1.41.2.1
	v0_44_0_6:1.72.2.2
	v0_44_0_5:1.72.2.2
	v0_44_0_4:1.72.2.2
	v0_44_0_3:1.72.2.2
	v0_44_0_2:1.72.2.1
	v0_42_0_7:1.58
	v0_44_0_1:1.72.2.1
	v0_44_0_0:1.72
	v0_44:1.72.0.2
	v0_42_0_6:1.58
	v0_42_0_5:1.58
	v0_42_0_4:1.58
	v0_42_0_3:1.58
	v0_42_0_2:1.58
	v0_42_0_1:1.58
	v0_42_0_0:1.58
	v0_42:1.58.0.2
	v0_40_0_3:1.50.2.1
	v0_40_0_2:1.50.2.1
	v0_40_0_1:1.50
	v0_40_0_0:1.50
	v0_40:1.50.0.2
	v0_36_0_13:1.41.2.1
	v0_38_0_1:1.47
	v0_38_0_0:1.47
	v0_38:1.47.0.2
	v0_36_0_9:1.41.2.1
	v0_36_0_7:1.41
	v0_36_0_5:1.41
	v0_36_0_4:1.41
	v0_36_0_3:1.41
	v0_36_0_2:1.41
	v0_36_0_1:1.41
	v0_36_0_0:1.41
	v0_36:1.41.0.2
	v0_34_0_3:1.39.2.1
	v0_34_0_2:1.39
	v0_34_0_1:1.39
	v0_34_0_0:1.39
	v0_34:1.39.0.2
	v0_32:1.38.0.2
	v0_32_0_0:1.38
	v0_30:1.34.0.2
	v0_28_0_0:1.34
	v0_26_0_1:1.29
	v0_26_0_0:1.29
	v0_24_0_1:1.28
	v0_24_0_0:1.28
	v0_22_0_0:1.26
	v0_20_0_0:1.24
	v0_18_0_0:1.17
	v0_16_0_0:1.17
	v0_14_0_1:1.15
	v0_14_0_0:1.15
	v0_12_0_0:1.14
	v0_10_0_1:1.13
	v0_10_0_0:1.13
	v0_8_0_0:1.3;
locks; strict;
comment	@ * @;


1.126
date	2015.07.02.07.21.18;	author jfrijters;	state Exp;
branches;
next	1.125;

1.125
date	2015.03.19.09.50.52;	author jfrijters;	state Exp;
branches;
next	1.124;

1.124
date	2015.03.05.12.15.08;	author jfrijters;	state Exp;
branches;
next	1.123;

1.123
date	2014.06.24.12.06.44;	author jfrijters;	state Exp;
branches;
next	1.122;

1.122
date	2014.05.01.08.07.51;	author jfrijters;	state Exp;
branches;
next	1.121;

1.121
date	2014.04.28.14.26.38;	author jfrijters;	state Exp;
branches;
next	1.120;

1.120
date	2014.04.17.11.47.05;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2014.04.17.10.24.31;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2014.02.27.06.57.36;	author jfrijters;	state Exp;
branches;
next	1.117;

1.117
date	2014.02.21.10.44.35;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2014.02.20.16.51.25;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2014.02.11.13.54.00;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2013.10.20.12.12.48;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2013.10.19.12.45.50;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2013.10.19.08.42.15;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2013.10.19.07.38.02;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2013.09.24.07.24.35;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2013.03.06.15.26.04;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2013.03.05.15.59.58;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2013.03.05.12.32.51;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2013.03.05.10.29.27;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2013.02.09.10.12.11;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2013.01.31.17.39.18;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2013.01.31.15.45.23;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2013.01.29.16.43.52;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2012.10.31.09.52.49;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2012.10.31.08.05.42;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2012.08.06.14.52.11;	author jfrijters;	state Exp;
branches
	1.99.2.1;
next	1.98;

1.98
date	2012.07.20.08.47.34;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2012.07.20.08.42.24;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2012.07.05.09.57.09;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2012.07.03.14.43.30;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2012.06.28.13.55.10;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2011.12.08.13.48.04;	author jfrijters;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2011.12.07.14.17.59;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2011.08.29.06.36.08;	author jfrijters;	state Exp;
branches
	1.91.2.1;
next	1.90;

1.90
date	2011.08.15.16.11.00;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2011.08.12.13.06.46;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2011.08.10.10.12.10;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2011.08.10.09.06.27;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2011.07.25.23.29.25;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2011.07.25.23.11.10;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2010.09.27.09.37.02;	author jfrijters;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2010.09.27.05.48.40;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2010.09.27.04.42.56;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2010.09.22.04.01.36;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2010.09.14.09.02.21;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2010.09.14.07.38.42;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2010.09.14.05.57.24;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2010.09.13.06.53.16;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2010.09.13.05.10.19;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2010.08.03.12.43.58;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2010.07.16.08.50.40;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2010.07.12.06.57.23;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.08.05.25.14;	author jfrijters;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2010.06.08.04.15.40;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.07.12.36.49;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2010.06.07.10.05.28;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2010.06.07.06.13.05;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2010.06.02.12.38.15;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2010.06.02.12.29.16;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.02.10.31.58;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2010.06.02.07.43.51;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2010.06.02.06.37.35;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.31.09.33.28;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.28.06.09.20;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.25.07.53.31;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2009.08.28.06.20.22;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.18.06.29.05;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.18.06.27.11;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.18.06.22.29;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.18.06.21.11;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2009.04.16.05.44.48;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2009.04.07.04.53.56;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2009.02.04.06.52.53;	author jfrijters;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2008.12.23.06.07.11;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.14.07.54.12;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.15.12.01.22;	author jfrijters;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2008.08.12.14.45.24;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2008.05.20.07.43.44;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2008.02.27.09.04.21;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.09.17.35.30;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2007.08.08.13.51.55;	author jfrijters;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2007.05.04.06.41.46;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.01.07.13.02;	author jfrijters;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2006.08.31.09.22.12;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2006.08.21.05.15.53;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.06.09.27.20;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.03.08.52.53;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.28.14.16.26;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.28.11.50.38;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.23.11.57.45;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.31.10.13.32;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.29.09.57.41;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.01.14.01.43;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.01.11.16.12;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.29.07.26.06;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.07.12.31.24;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.05.12.18.36;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.05.08.40.55;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.02.07.24.54;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.01.14.32.15;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.20.10.48.04;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.31.15.30.39;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.17.13.32.17;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.18.16.59.59;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.23.12.58.35;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.21.14.59.46;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.21.10.26.55;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.12.14.36.26;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.19.13.43.57;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.04.19.30.55;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.15.13.35.58;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.30.15.56.25;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.25.09.38.07;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.28.14.35.00;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;

1.39.2.1
date	2007.05.30.10.30.38;	author jfrijters;	state Exp;
branches;
next	;

1.41.2.1
date	2008.02.27.07.09.47;	author jfrijters;	state Exp;
branches;
next	;

1.47.2.1
date	2008.11.11.18.32.19;	author jfrijters;	state Exp;
branches;
next	;

1.50.2.1
date	2009.06.15.04.56.38;	author jfrijters;	state Exp;
branches;
next	;

1.72.2.1
date	2010.07.12.07.04.10;	author jfrijters;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2010.08.03.13.17.43;	author jfrijters;	state Exp;
branches;
next	;

1.84.2.1
date	2011.12.20.08.31.01;	author jfrijters;	state Exp;
branches;
next	1.84.2.2;

1.84.2.2
date	2011.12.20.12.37.23;	author jfrijters;	state Exp;
branches;
next	1.84.2.3;

1.84.2.3
date	2012.10.03.06.18.57;	author jfrijters;	state Exp;
branches;
next	1.84.2.4;

1.84.2.4
date	2013.09.10.15.16.05;	author jfrijters;	state Exp;
branches;
next	;

1.91.2.1
date	2012.01.03.12.16.37;	author jfrijters;	state Exp;
branches;
next	;

1.93.2.1
date	2012.06.29.06.36.04;	author jfrijters;	state Exp;
branches;
next	;

1.99.2.1
date	2012.10.31.12.35.37;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.126
log
@Improved -removeassertions ikvmc optimization to remove more code (esp. allow otherwise empty <clinit> methods to be optimized away).
@
text
@/*
  Copyright (C) 2002-2014 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.IO;
using System.Collections.Generic;
using System.Diagnostics;
using IKVM.Internal;
using InstructionFlags = IKVM.Internal.ClassFile.Method.InstructionFlags;
using ExceptionTableEntry = IKVM.Internal.ClassFile.Method.ExceptionTableEntry;

sealed class InstructionState
{
	private struct LocalStoreSites
	{
		private int[] data;
		private int count;
		private bool shared;

		internal LocalStoreSites Copy()
		{
			LocalStoreSites n = new LocalStoreSites();
			n.data = data;
			n.count = count;
			n.shared = true;
			return n;
		}

		internal static LocalStoreSites Alloc()
		{
			LocalStoreSites n = new LocalStoreSites();
			n.data = new int[4];
			return n;
		}

		internal void Add(int store)
		{
			for(int i = 0; i < count; i++)
			{
				if(data[i] == store)
				{
					return;
				}
			}
			if(count == data.Length)
			{
				int[] newarray = new int[data.Length * 2];
				Buffer.BlockCopy(data, 0, newarray, 0, data.Length * 4);
				data = newarray;
				shared = false;
			}
			if(shared)
			{
				shared = false;
				data = (int[])data.Clone();
			}
			data[count++] = store;
		}

		internal int this[int index]
		{
			get
			{
				return data[index];
			}
		}

		internal int Count
		{
			get
			{
				return count;
			}
		}

		internal static void MarkShared(LocalStoreSites[] localStoreSites)
		{
			for(int i = 0; i < localStoreSites.Length; i++)
			{
				localStoreSites[i].shared = true;
			}
		}
	}
	private TypeWrapper[] stack;
	private int stackSize;
	private int stackEnd;
	private TypeWrapper[] locals;
	private bool unitializedThis;
	internal bool changed = true;
	private enum ShareFlags : byte
	{
		None = 0,
		Stack = 1,
		Locals = 2,
		All = Stack | Locals
	}
	private ShareFlags flags;

	private InstructionState(TypeWrapper[] stack, int stackSize, int stackEnd, TypeWrapper[] locals, bool unitializedThis)
	{
		this.flags = ShareFlags.All;
		this.stack = stack;
		this.stackSize = stackSize;
		this.stackEnd = stackEnd;
		this.locals = locals;
		this.unitializedThis = unitializedThis;
	}

	internal InstructionState(int maxLocals, int maxStack)
	{
		this.flags = ShareFlags.None;
		this.stack = new TypeWrapper[maxStack];
		this.stackEnd = maxStack;
		this.locals = new TypeWrapper[maxLocals];
	}

	internal InstructionState Copy()
	{
		return new InstructionState(stack, stackSize, stackEnd, locals, unitializedThis);
	}

	internal void CopyTo(InstructionState target)
	{
		target.flags = ShareFlags.All;
		target.stack = stack;
		target.stackSize = stackSize;
		target.stackEnd = stackEnd;
		target.locals = locals;
		target.unitializedThis = unitializedThis;
		target.changed = true;
	}

	internal InstructionState CopyLocals()
	{
		InstructionState copy = new InstructionState(new TypeWrapper[stack.Length], 0, stack.Length, locals, unitializedThis);
		copy.flags &= ~ShareFlags.Stack;
		return copy;
	}

	public static InstructionState operator+(InstructionState s1, InstructionState s2)
	{
		if(s1 == null)
		{
			return s2.Copy();
		}
		if(s1.stackSize != s2.stackSize || s1.stackEnd != s2.stackEnd)
		{
			throw new VerifyError(string.Format("Inconsistent stack height: {0} != {1}",
				s1.stackSize + s1.stack.Length - s1.stackEnd,
				s2.stackSize + s2.stack.Length - s2.stackEnd));
		}
		InstructionState s = s1.Copy();
		s.changed = s1.changed;
		for(int i = 0; i < s.stackSize; i++)
		{
			TypeWrapper type = s.stack[i];
			TypeWrapper type2 = s2.stack[i];
			if(type == type2)
			{
				// perfect match, nothing to do
			}
			else if((type == VerifierTypeWrapper.ExtendedDouble && type2 == PrimitiveTypeWrapper.DOUBLE)
				|| (type2 == VerifierTypeWrapper.ExtendedDouble && type == PrimitiveTypeWrapper.DOUBLE))
			{
				if(type != VerifierTypeWrapper.ExtendedDouble)
				{
					s.StackCopyOnWrite();
					s.stack[i] = VerifierTypeWrapper.ExtendedDouble;
					s.changed = true;
				}
			}
			else if((type == VerifierTypeWrapper.ExtendedFloat && type2 == PrimitiveTypeWrapper.FLOAT)
				|| (type2 == VerifierTypeWrapper.ExtendedFloat && type == PrimitiveTypeWrapper.FLOAT))
			{
				if(type != VerifierTypeWrapper.ExtendedFloat)
				{
					s.StackCopyOnWrite();
					s.stack[i] = VerifierTypeWrapper.ExtendedFloat;
					s.changed = true;
				}
			}
			else if(!type.IsPrimitive)
			{
				TypeWrapper baseType = InstructionState.FindCommonBaseType(type, type2);
				if(baseType == VerifierTypeWrapper.Invalid)
				{
					throw new VerifyError(string.Format("cannot merge {0} and {1}", type.Name, type2.Name));
				}
				if(type != baseType)
				{
					s.StackCopyOnWrite();
					s.stack[i] = baseType;
					s.changed = true;
				}
			}
			else
			{
				throw new VerifyError(string.Format("cannot merge {0} and {1}", type.Name, type2.Name));
			}
		}
		for(int i = 0; i < s.locals.Length; i++)
		{
			TypeWrapper type = s.locals[i];
			TypeWrapper type2 = s2.locals[i];
			TypeWrapper baseType = InstructionState.FindCommonBaseType(type, type2);
			if(type != baseType)
			{
				s.LocalsCopyOnWrite();
				s.locals[i] = baseType;
				s.changed = true;
			}
		}
		if(!s.unitializedThis && s2.unitializedThis)
		{
			s.unitializedThis = true;
			s.changed = true;
		}
		return s;
	}

	private static LocalStoreSites MergeStoreSites(LocalStoreSites h1, LocalStoreSites h2)
	{
		if(h1.Count == 0)
		{
			return h2.Copy();
		}
		if(h2.Count == 0)
		{
			return h1.Copy();
		}
		LocalStoreSites h = h1.Copy();
		for(int i = 0; i < h2.Count; i++)
		{
			h.Add(h2[i]);
		}
		return h;
	}

	internal void SetUnitializedThis(bool state)
	{
		unitializedThis = state;
	}

	internal void CheckUninitializedThis()
	{
		if(unitializedThis)
		{
			throw new VerifyError("Base class constructor wasn't called");
		}
	}

	internal static TypeWrapper FindCommonBaseType(TypeWrapper type1, TypeWrapper type2)
	{
		if(type1 == type2)
		{
			return type1;
		}
		if(type1 == VerifierTypeWrapper.Null)
		{
			return type2;
		}
		if(type2 == VerifierTypeWrapper.Null)
		{
			return type1;
		}
		if(type1 == VerifierTypeWrapper.Invalid || type2 == VerifierTypeWrapper.Invalid)
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(VerifierTypeWrapper.IsFaultBlockException(type1))
		{
			VerifierTypeWrapper.ClearFaultBlockException(type1);
			return FindCommonBaseType(CoreClasses.java.lang.Throwable.Wrapper, type2);
		}
		if(VerifierTypeWrapper.IsFaultBlockException(type2))
		{
			VerifierTypeWrapper.ClearFaultBlockException(type2);
			return FindCommonBaseType(type1, CoreClasses.java.lang.Throwable.Wrapper);
		}
		if(type1.IsPrimitive || type2.IsPrimitive)
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(type1 == VerifierTypeWrapper.UninitializedThis || type2 == VerifierTypeWrapper.UninitializedThis)
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(VerifierTypeWrapper.IsNew(type1) || VerifierTypeWrapper.IsNew(type2))
		{
			return VerifierTypeWrapper.Invalid;
		}
		if(VerifierTypeWrapper.IsThis(type1))
		{
			type1 = ((VerifierTypeWrapper)type1).UnderlyingType;
		}
		if(VerifierTypeWrapper.IsThis(type2))
		{
			type2 = ((VerifierTypeWrapper)type2).UnderlyingType;
		}
		if(type1.IsUnloadable || type2.IsUnloadable)
		{
			return VerifierTypeWrapper.Unloadable;
		}
		if(type1.ArrayRank > 0 && type2.ArrayRank > 0)
		{
			int rank = 1;
			int rank1 = type1.ArrayRank - 1;
			int rank2 = type2.ArrayRank - 1;
			TypeWrapper elem1 = type1.ElementTypeWrapper;
			TypeWrapper elem2 = type2.ElementTypeWrapper;
			while(rank1 != 0 && rank2 != 0)
			{
				elem1 = elem1.ElementTypeWrapper;
				elem2 = elem2.ElementTypeWrapper;
				rank++;
				rank1--;
				rank2--;
			}
			// NOTE arrays of value types have special merging semantics!
			// NOTE we don't have to test for the case where the element types are the same, because that
			// is only relevant if the ranks are the same, but if that is the case the types are completely
			// identical, in which case the identity test at the top of this method already returned.
			TypeWrapper baseType;
			if(elem1.IsPrimitive || elem2.IsPrimitive || elem1.IsNonPrimitiveValueType || elem2.IsNonPrimitiveValueType)
			{
				baseType = CoreClasses.java.lang.Object.Wrapper;
				rank--;
				if(rank == 0)
				{
					return baseType;
				}
			}
			else
			{
				baseType = FindCommonBaseTypeHelper(elem1, elem2);
			}
			return baseType.MakeArrayType(rank);
		}
		return FindCommonBaseTypeHelper(type1, type2);
	}

	private static TypeWrapper FindCommonBaseTypeHelper(TypeWrapper t1, TypeWrapper t2)
	{
		if(t1 == t2)
		{
			return t1;
		}
		if(t1.IsInterface || t2.IsInterface)
		{
			// NOTE according to a paper by Alessandro Coglio & Allen Goldberg titled
			// "Type Safety in the JVM: Some Problems in Java 2 SDK 1.2 and Proposed Solutions"
			// the common base of two interfaces is java.lang.Object, and there is special
			// treatment for java.lang.Object types that allow it to be assigned to any interface
			// type, the JVM's typesafety then depends on the invokeinterface instruction to make
			// sure that the reference actually implements the interface.
			// NOTE the ECMA CLI spec also specifies this interface merging algorithm, so we can't
			// really do anything more clever than this.
			return CoreClasses.java.lang.Object.Wrapper;
		}
		Stack<TypeWrapper> st1 = new Stack<TypeWrapper>();
		Stack<TypeWrapper> st2 = new Stack<TypeWrapper>();
		while(t1 != null)
		{
			st1.Push(t1);
			t1 = t1.BaseTypeWrapper;
		}
		while(t2 != null)
		{
			st2.Push(t2);
			t2 = t2.BaseTypeWrapper;
		}
		if(HasMissingBaseType(st1) || HasMissingBaseType(st2))
		{
			return VerifierTypeWrapper.Unloadable;
		}
		TypeWrapper type = CoreClasses.java.lang.Object.Wrapper;
		for(;;)
		{
			t1 = st1.Count > 0 ? st1.Pop() : null;
			t2 = st2.Count > 0 ? st2.Pop() : null;
			if(t1 != t2)
			{
				return type;
			}
			type = t1;
		}
	}

	private static bool HasMissingBaseType(Stack<TypeWrapper> st)
	{
#if STATIC_COMPILER
		if (st.Pop().IsUnloadable)
		{
			// we have a missing type in base class hierarchy
			StaticCompiler.IssueMissingTypeMessage(st.Pop().TypeAsBaseType.BaseType);
			return true;
		}
#endif
		return false;
	}

	private void SetLocal1(int index, TypeWrapper type)
	{
		try
		{
			LocalsCopyOnWrite();
			if(index > 0 && locals[index - 1] != VerifierTypeWrapper.Invalid && locals[index - 1].IsWidePrimitive)
			{
				locals[index - 1] = VerifierTypeWrapper.Invalid;
			}
			locals[index] = type;
		}
		catch(IndexOutOfRangeException)
		{
			throw new VerifyError("Illegal local variable number");
		}
	}

	private void SetLocal2(int index, TypeWrapper type)
	{
		try
		{
			LocalsCopyOnWrite();
			if(index > 0 && locals[index - 1] != VerifierTypeWrapper.Invalid && locals[index - 1].IsWidePrimitive)
			{
				locals[index - 1] = VerifierTypeWrapper.Invalid;
			}
			locals[index] = type;
			locals[index + 1] = VerifierTypeWrapper.Invalid;
		}
		catch(IndexOutOfRangeException)
		{
			throw new VerifyError("Illegal local variable number");
		}
	}

	internal void GetLocalInt(int index)
	{
		if(GetLocalType(index) != PrimitiveTypeWrapper.INT)
		{
			throw new VerifyError("Invalid local type");
		}
	}

	internal void SetLocalInt(int index, int instructionIndex)
	{
		SetLocal1(index, PrimitiveTypeWrapper.INT);
	}

	internal void GetLocalLong(int index)
	{
		if(GetLocalType(index) != PrimitiveTypeWrapper.LONG)
		{
			throw new VerifyError("incorrect local type, not long");
		}
	}

	internal void SetLocalLong(int index, int instructionIndex)
	{
		SetLocal2(index, PrimitiveTypeWrapper.LONG);
	}

	internal void GetLocalFloat(int index)
	{
		if(GetLocalType(index) != PrimitiveTypeWrapper.FLOAT)
		{
			throw new VerifyError("incorrect local type, not float");
		}
	}

	internal void SetLocalFloat(int index, int instructionIndex)
	{
		SetLocal1(index, PrimitiveTypeWrapper.FLOAT);
	}

	internal void GetLocalDouble(int index)
	{
		if(GetLocalType(index) != PrimitiveTypeWrapper.DOUBLE)
		{
			throw new VerifyError("incorrect local type, not double");
		}
	}

	internal void SetLocalDouble(int index, int instructionIndex)
	{
		SetLocal2(index, PrimitiveTypeWrapper.DOUBLE);
	}

	internal TypeWrapper GetLocalType(int index)
	{
		try
		{
			return locals[index];
		}
		catch(IndexOutOfRangeException)
		{
			throw new VerifyError("Illegal local variable number");
		}
	}

	// this is used by the compiler (indirectly, through MethodAnalyzer.GetLocalTypeWrapper),
	// we've already verified the code so we know we won't run outside the array boundary,
	// and we don't need to record the fact that we're reading the local.
	internal TypeWrapper GetLocalTypeEx(int index)
	{
		return locals[index];
	}

	internal void SetLocalType(int index, TypeWrapper type, int instructionIndex)
	{
		if(type.IsWidePrimitive)
		{
			SetLocal2(index, type);
		}
		else
		{
			SetLocal1(index, type);
		}
	}

	internal void PushType(TypeWrapper type)
	{
		if(type.IsIntOnStackPrimitive)
		{
			type = PrimitiveTypeWrapper.INT;
		}
		PushHelper(type);
	}

	internal void PushInt()
	{
		PushHelper(PrimitiveTypeWrapper.INT);
	}

	internal void PushLong()
	{
		PushHelper(PrimitiveTypeWrapper.LONG);
	}

	internal void PushFloat()
	{
		PushHelper(PrimitiveTypeWrapper.FLOAT);
	}

	internal void PushExtendedFloat()
	{
		PushHelper(VerifierTypeWrapper.ExtendedFloat);
	}

	internal void PushDouble()
	{
		PushHelper(PrimitiveTypeWrapper.DOUBLE);
	}

	internal void PushExtendedDouble()
	{
		PushHelper(VerifierTypeWrapper.ExtendedDouble);
	}

	internal void PopInt()
	{
		PopIntImpl(PopAnyType());
	}

	internal static void PopIntImpl(TypeWrapper type)
	{
		if (type != PrimitiveTypeWrapper.INT)
		{
			throw new VerifyError("Int expected on stack");
		}
	}

	internal bool PopFloat()
	{
		TypeWrapper tw = PopAnyType();
		PopFloatImpl(tw);
		return tw == VerifierTypeWrapper.ExtendedFloat;
	}

	internal static void PopFloatImpl(TypeWrapper tw)
	{
		if(tw != PrimitiveTypeWrapper.FLOAT && tw != VerifierTypeWrapper.ExtendedFloat)
		{
			throw new VerifyError("Float expected on stack");
		}
	}

	internal bool PopDouble()
	{
		TypeWrapper tw = PopAnyType();
		PopDoubleImpl(tw);
		return tw == VerifierTypeWrapper.ExtendedDouble;
	}

	internal static void PopDoubleImpl(TypeWrapper tw)
	{
		if(tw != PrimitiveTypeWrapper.DOUBLE && tw != VerifierTypeWrapper.ExtendedDouble)
		{
			throw new VerifyError("Double expected on stack");
		}
	}

	internal void PopLong()
	{
		PopLongImpl(PopAnyType());
	}

	internal static void PopLongImpl(TypeWrapper tw)
	{
		if(tw != PrimitiveTypeWrapper.LONG)
		{
			throw new VerifyError("Long expected on stack");
		}
	}

	internal TypeWrapper PopArrayType()
	{
		return PopArrayTypeImpl(PopAnyType());
	}

	internal static TypeWrapper PopArrayTypeImpl(TypeWrapper type)
	{
		if(!VerifierTypeWrapper.IsNullOrUnloadable(type) && type.ArrayRank == 0)
		{
			throw new VerifyError("Array reference expected on stack");
		}
		return type;
	}

	// null or an initialized object reference
	internal TypeWrapper PopObjectType()
	{
		return PopObjectTypeImpl(PopType());
	}

	internal static TypeWrapper PopObjectTypeImpl(TypeWrapper type)
	{
		if(type.IsPrimitive || VerifierTypeWrapper.IsNew(type) || type == VerifierTypeWrapper.UninitializedThis)
		{
			throw new VerifyError("Expected object reference on stack");
		}
		return type;
	}

	// null or an initialized object reference derived from baseType (or baseType)
	internal TypeWrapper PopObjectType(TypeWrapper baseType)
	{
		return PopObjectTypeImpl(baseType, PopObjectType());
	}

	internal static TypeWrapper PopObjectTypeImpl(TypeWrapper baseType, TypeWrapper type)
	{
		// HACK because of the way interfaces references works, if baseType
		// is an interface or array of interfaces, any reference will be accepted
		if(!baseType.IsUnloadable && !baseType.IsInterfaceOrInterfaceArray && !(type.IsUnloadable || type.IsAssignableTo(baseType)))
		{
			throw new VerifyError("Unexpected type " + type.Name + " where " + baseType.Name + " was expected");
		}
		return type;
	}

	internal TypeWrapper PeekType()
	{
		if(stackSize == 0)
		{
			throw new VerifyError("Unable to pop operand off an empty stack");
		}
		return stack[stackSize - 1];
	}

	internal void MultiPopAnyType(int count)
	{
		while(count-- != 0)
		{
			PopAnyType();
		}
	}

	internal TypeWrapper PopFaultBlockException()
	{
		return stack[--stackSize];
	}

	internal TypeWrapper PopAnyType()
	{
		if(stackSize == 0)
		{
			throw new VerifyError("Unable to pop operand off an empty stack");
		}
		TypeWrapper type = stack[--stackSize];
		if(type.IsWidePrimitive || type == VerifierTypeWrapper.ExtendedDouble)
		{
			stackEnd++;
		}
		if(VerifierTypeWrapper.IsThis(type))
		{
			type = ((VerifierTypeWrapper)type).UnderlyingType;
		}
		if(VerifierTypeWrapper.IsFaultBlockException(type))
		{
			VerifierTypeWrapper.ClearFaultBlockException(type);
			type = CoreClasses.java.lang.Throwable.Wrapper;
		}
		return type;
	}

	// NOTE this can *not* be used to pop double or long
	internal TypeWrapper PopType()
	{
		return PopTypeImpl(PopAnyType());
	}

	internal static TypeWrapper PopTypeImpl(TypeWrapper type)
	{
		if(type.IsWidePrimitive || type == VerifierTypeWrapper.ExtendedDouble)
		{
			throw new VerifyError("Attempt to split long or double on the stack");
		}
		return type;
	}

	// this will accept null, a primitive type of the specified type or an initialized reference of the
	// specified type or derived from it
	// NOTE this can also be used to pop double or long
	internal TypeWrapper PopType(TypeWrapper baseType)
	{
		return PopTypeImpl(baseType, PopAnyType());
	}

	internal static TypeWrapper PopTypeImpl(TypeWrapper baseType, TypeWrapper type)
	{
		if(baseType.IsIntOnStackPrimitive)
		{
			baseType = PrimitiveTypeWrapper.INT;
		}
		if(VerifierTypeWrapper.IsNew(type) || type == VerifierTypeWrapper.UninitializedThis)
		{
			throw new VerifyError("Expecting to find object/array on stack");
		}
		if(type == baseType)
		{
			return type;
		}
		else if(type == VerifierTypeWrapper.ExtendedDouble && baseType == PrimitiveTypeWrapper.DOUBLE)
		{
			return type;
		}
		else if(type == VerifierTypeWrapper.ExtendedFloat && baseType == PrimitiveTypeWrapper.FLOAT)
		{
			return type;
		}
		else if(type.IsPrimitive || baseType.IsPrimitive)
		{
			// throw at the end of the method
		}
		else if(baseType == CoreClasses.java.lang.Object.Wrapper)
		{
			return type;
		}
		else if(type.IsUnloadable || baseType.IsUnloadable)
		{
			return type;
		}
		else if (baseType.IsInterfaceOrInterfaceArray)
		{
			// because of the way interfaces references works, if baseType
			// is an interface or array of interfaces, any reference will be accepted
			return type;
		}
		else if (type.IsAssignableTo(baseType))
		{
			return type;
		}
		else if (HasMissingBaseType(type) || HasMissingBaseType(baseType))
		{
			return type;
		}
		throw new VerifyError("Unexpected type " + type.Name + " where " + baseType.Name + " was expected");
	}

	private static bool HasMissingBaseType(TypeWrapper tw)
	{
#if STATIC_COMPILER
		for (TypeWrapper baseTypeWrapper; (baseTypeWrapper = tw.BaseTypeWrapper) != null; tw = baseTypeWrapper)
		{
			if (baseTypeWrapper.IsUnloadable)
			{
				StaticCompiler.IssueMissingTypeMessage(tw.TypeAsBaseType.BaseType);
				return true;
			}
		}
#endif
		return false;
	}

	internal int GetStackHeight()
	{
		return stackSize;
	}

	internal TypeWrapper GetStackSlot(int pos)
	{
		TypeWrapper tw = stack[stackSize - 1 - pos];
		if(tw == VerifierTypeWrapper.ExtendedDouble)
		{
			tw = PrimitiveTypeWrapper.DOUBLE;
		}
		else if(tw == VerifierTypeWrapper.ExtendedFloat)
		{
			tw = PrimitiveTypeWrapper.FLOAT;
		}
		return tw;
	}

	internal TypeWrapper GetStackSlotEx(int pos)
	{
		return stack[stackSize - 1 - pos];
	}

	internal TypeWrapper GetStackByIndex(int index)
	{
		return stack[index];
	}

	private void PushHelper(TypeWrapper type)
	{
		if(type.IsWidePrimitive || type == VerifierTypeWrapper.ExtendedDouble)
		{
			stackEnd--;
		}
		if(stackSize >= stackEnd)
		{
			throw new VerifyError("Stack overflow");
		}
		StackCopyOnWrite();
		stack[stackSize++] = type;
	}

	internal void MarkInitialized(TypeWrapper type, TypeWrapper initType, int instructionIndex)
	{
		System.Diagnostics.Debug.Assert(type != null && initType != null);

		for(int i = 0; i < locals.Length; i++)
		{
			if(locals[i] == type)
			{
				LocalsCopyOnWrite();
				locals[i] = initType;
			}
		}
		for(int i = 0; i < stackSize; i++)
		{
			if(stack[i] == type)
			{
				StackCopyOnWrite();
				stack[i] = initType;
			}
		}
	}

	private void StackCopyOnWrite()
	{
		if((flags & ShareFlags.Stack) != 0)
		{
			flags &= ~ShareFlags.Stack;
			stack = (TypeWrapper[])stack.Clone();
		}
	}

	private void LocalsCopyOnWrite()
	{
		if((flags & ShareFlags.Locals) != 0)
		{
			flags &= ~ShareFlags.Locals;
			locals = (TypeWrapper[])locals.Clone();
		}
	}

	internal void DumpLocals()
	{
		Console.Write("// ");
		string sep = "";
		for(int i = 0; i < locals.Length; i++)
		{
			Console.Write(sep);
			Console.Write(locals[i]);
			sep = ", ";
		}
		Console.WriteLine();
	}

	internal void DumpStack()
	{
		Console.Write("// ");
		string sep = "";
		for(int i = 0; i < stackSize; i++)
		{
			Console.Write(sep);
			Console.Write(stack[i]);
			sep = ", ";
		}
		Console.WriteLine();
	}

	internal void ClearFaultBlockException()
	{
		if(VerifierTypeWrapper.IsFaultBlockException(stack[0]))
		{
			StackCopyOnWrite();
			changed = true;
			stack[0] = CoreClasses.java.lang.Throwable.Wrapper;
		}
	}
}

struct StackState
{
	private InstructionState state;
	private int sp;

	internal StackState(InstructionState state)
	{
		this.state = state;
		sp = state.GetStackHeight();
	}

	internal TypeWrapper PeekType()
	{
		if(sp == 0)
		{
			throw new VerifyError("Unable to pop operand off an empty stack");
		}
		TypeWrapper type = state.GetStackByIndex(sp - 1);
		if(VerifierTypeWrapper.IsThis(type))
		{
			type = ((VerifierTypeWrapper)type).UnderlyingType;
		}
		return type;
	}

	internal TypeWrapper PopAnyType()
	{
		if(sp == 0)
		{
			throw new VerifyError("Unable to pop operand off an empty stack");
		}
		TypeWrapper type = state.GetStackByIndex(--sp);
		if(VerifierTypeWrapper.IsThis(type))
		{
			type = ((VerifierTypeWrapper)type).UnderlyingType;
		}
		if(VerifierTypeWrapper.IsFaultBlockException(type))
		{
			VerifierTypeWrapper.ClearFaultBlockException(type);
			type = CoreClasses.java.lang.Throwable.Wrapper;
		}
		return type;
	}

	internal TypeWrapper PopType(TypeWrapper baseType)
	{
		return InstructionState.PopTypeImpl(baseType, PopAnyType());
	}

	// NOTE this can *not* be used to pop double or long
	internal TypeWrapper PopType()
	{
		return InstructionState.PopTypeImpl(PopAnyType());
	}

	internal void PopInt()
	{
		InstructionState.PopIntImpl(PopAnyType());
	}

	internal void PopFloat()
	{
		InstructionState.PopFloatImpl(PopAnyType());
	}

	internal void PopDouble()
	{
		InstructionState.PopDoubleImpl(PopAnyType());
	}

	internal void PopLong()
	{
		InstructionState.PopLongImpl(PopAnyType());
	}

	internal TypeWrapper PopArrayType()
	{
		return InstructionState.PopArrayTypeImpl(PopAnyType());
	}

	// either null or an initialized object reference
	internal TypeWrapper PopObjectType()
	{
		return InstructionState.PopObjectTypeImpl(PopAnyType());
	}

	// null or an initialized object reference derived from baseType (or baseType)
	internal TypeWrapper PopObjectType(TypeWrapper baseType)
	{
		return InstructionState.PopObjectTypeImpl(baseType, PopObjectType());
	}
}

sealed class ExceptionSorter : IComparer<ExceptionTableEntry>
{
	public int Compare(ExceptionTableEntry e1, ExceptionTableEntry e2)
	{
		if (e1.startIndex < e2.startIndex)
		{
			return -1;
		}
		if (e1.startIndex == e2.startIndex)
		{
			if (e1.endIndex == e2.endIndex)
			{
				if (e1.ordinal > e2.ordinal)
				{
					return -1;
				}
				if (e1.ordinal == e2.ordinal)
				{
					return 0;
				}
				return 1;
			}
			if (e1.endIndex > e2.endIndex)
			{
				return -1;
			}
		}
		return 1;
	}
}

struct UntangledExceptionTable
{
	private readonly ExceptionTableEntry[] exceptions;

	internal UntangledExceptionTable(ExceptionTableEntry[] exceptions)
	{
#if DEBUG
		for (int i = 0; i < exceptions.Length; i++)
		{
			for (int j = i + 1; j < exceptions.Length; j++)
			{
				// check for partially overlapping try blocks (which is legal for the JVM, but not the CLR)
				if (exceptions[i].startIndex < exceptions[j].startIndex &&
					exceptions[j].startIndex < exceptions[i].endIndex &&
					exceptions[i].endIndex < exceptions[j].endIndex)
				{
					throw new InvalidOperationException("Partially overlapping try blocks is broken");
				}
				// check that we didn't destroy the ordering, when sorting
				if (exceptions[i].startIndex <= exceptions[j].startIndex &&
					exceptions[i].endIndex >= exceptions[j].endIndex &&
					exceptions[i].ordinal < exceptions[j].ordinal)
				{
					throw new InvalidOperationException("Non recursive try blocks is broken");
				}
			}
		}
#endif
		this.exceptions = exceptions;
	}

	internal ExceptionTableEntry this[int index]
	{
		get { return exceptions[index]; }
	}

	internal int Length
	{
		get { return exceptions.Length; }
	}

	internal void SetFinally(int index)
	{
		exceptions[index] = new ExceptionTableEntry(exceptions[index].startIndex, exceptions[index].endIndex, exceptions[index].handlerIndex, exceptions[index].catch_type, exceptions[index].ordinal, true);
	}
}

struct CodeInfo
{
	private readonly InstructionState[] state;

	internal CodeInfo(InstructionState[] state)
	{
		this.state = state;
	}

	internal bool HasState(int index)
	{
		return state[index] != null;
	}

	internal int GetStackHeight(int index)
	{
		return state[index].GetStackHeight();
	}

	internal TypeWrapper GetStackTypeWrapper(int index, int pos)
	{
		TypeWrapper type = state[index].GetStackSlot(pos);
		if (VerifierTypeWrapper.IsThis(type))
		{
			type = ((VerifierTypeWrapper)type).UnderlyingType;
		}
		return type;
	}

	internal TypeWrapper GetRawStackTypeWrapper(int index, int pos)
	{
		return state[index].GetStackSlot(pos);
	}

	internal bool IsStackTypeExtendedDouble(int index, int pos)
	{
		return state[index].GetStackSlotEx(pos) == VerifierTypeWrapper.ExtendedDouble;
	}

	internal TypeWrapper GetLocalTypeWrapper(int index, int local)
	{
		return state[index].GetLocalTypeEx(local);
	}
}

sealed class MethodAnalyzer
{
	private readonly static TypeWrapper ByteArrayType;
	private readonly static TypeWrapper BooleanArrayType;
	private readonly static TypeWrapper ShortArrayType;
	private readonly static TypeWrapper CharArrayType;
	private readonly static TypeWrapper IntArrayType;
	private readonly static TypeWrapper FloatArrayType;
	private readonly static TypeWrapper DoubleArrayType;
	private readonly static TypeWrapper LongArrayType;
	private readonly static TypeWrapper java_lang_ThreadDeath;
	private readonly TypeWrapper host;	// used to by Unsafe.defineAnonymousClass() to provide access to private members of the host
	private readonly TypeWrapper wrapper;
	private readonly MethodWrapper mw;
	private readonly ClassFile classFile;
	private readonly ClassFile.Method method;
	private readonly ClassLoaderWrapper classLoader;
	private readonly TypeWrapper thisType;
	private readonly InstructionState[] state;
	private List<string> errorMessages;
	private readonly Dictionary<int, TypeWrapper> newTypes = new Dictionary<int, TypeWrapper>();
	private readonly Dictionary<int, TypeWrapper> faultTypes = new Dictionary<int, TypeWrapper>();

	static MethodAnalyzer()
	{
		ByteArrayType = PrimitiveTypeWrapper.BYTE.MakeArrayType(1);
		BooleanArrayType = PrimitiveTypeWrapper.BOOLEAN.MakeArrayType(1);
		ShortArrayType = PrimitiveTypeWrapper.SHORT.MakeArrayType(1);
		CharArrayType = PrimitiveTypeWrapper.CHAR.MakeArrayType(1);
		IntArrayType = PrimitiveTypeWrapper.INT.MakeArrayType(1);
		FloatArrayType = PrimitiveTypeWrapper.FLOAT.MakeArrayType(1);
		DoubleArrayType = PrimitiveTypeWrapper.DOUBLE.MakeArrayType(1);
		LongArrayType = PrimitiveTypeWrapper.LONG.MakeArrayType(1);
		java_lang_ThreadDeath = ClassLoaderWrapper.LoadClassCritical("java.lang.ThreadDeath");
	}

	internal MethodAnalyzer(TypeWrapper host, TypeWrapper wrapper, MethodWrapper mw, ClassFile classFile, ClassFile.Method method, ClassLoaderWrapper classLoader)
	{
		if(method.VerifyError != null)
		{
			throw new VerifyError(method.VerifyError);
		}

		this.host = host;
		this.wrapper = wrapper;
		this.mw = mw;
		this.classFile = classFile;
		this.method = method;
		this.classLoader = classLoader;
		state = new InstructionState[method.Instructions.Length];

		try
		{
			// ensure that exception blocks and handlers start and end at instruction boundaries
			for(int i = 0; i < method.ExceptionTable.Length; i++)
			{
				int start = method.ExceptionTable[i].startIndex;
				int end = method.ExceptionTable[i].endIndex;
				int handler = method.ExceptionTable[i].handlerIndex;
				if(start >= end || start == -1 || end == -1 || handler <= 0)
				{
					throw new IndexOutOfRangeException();
				}
			}
		}
		catch(IndexOutOfRangeException)
		{
			// TODO figure out if we should throw this during class loading
			throw new ClassFormatError(string.Format("Illegal exception table (class: {0}, method: {1}, signature: {2}", classFile.Name, method.Name, method.Signature));
		}

		// start by computing the initial state, the stack is empty and the locals contain the arguments
		state[0] = new InstructionState(method.MaxLocals, method.MaxStack);
		int firstNonArgLocalIndex = 0;
		if(!method.IsStatic)
		{
			thisType = VerifierTypeWrapper.MakeThis(wrapper);
			// this reference. If we're a constructor, the this reference is uninitialized.
			if(method.IsConstructor)
			{
				state[0].SetLocalType(firstNonArgLocalIndex++, VerifierTypeWrapper.UninitializedThis, -1);
				state[0].SetUnitializedThis(true);
			}
			else
			{
				state[0].SetLocalType(firstNonArgLocalIndex++, thisType, -1);
			}
		}
		else
		{
			thisType = null;
		}
		// mw can be null when we're invoked from IsSideEffectFreeStaticInitializer
		TypeWrapper[] argTypeWrappers = mw == null ? TypeWrapper.EmptyArray : mw.GetParameters();
		for(int i = 0; i < argTypeWrappers.Length; i++)
		{
			TypeWrapper type = argTypeWrappers[i];
			if(type.IsIntOnStackPrimitive)
			{
				type = PrimitiveTypeWrapper.INT;
			}
			state[0].SetLocalType(firstNonArgLocalIndex++, type, -1);
			if(type.IsWidePrimitive)
			{
				firstNonArgLocalIndex++;
			}
		}
		AnalyzeTypeFlow();
		VerifyPassTwo();
		PatchLoadConstants();
	}

	private void PatchLoadConstants()
	{
		ClassFile.Method.Instruction[] code = method.Instructions;
		for (int i = 0; i < code.Length; i++)
		{
			if (state[i] != null)
			{
				switch (code[i].NormalizedOpCode)
				{
					case NormalizedByteCode.__ldc:
						switch (GetConstantPoolConstantType(code[i].Arg1))
						{
							case ClassFile.ConstantType.Double:
							case ClassFile.ConstantType.Float:
							case ClassFile.ConstantType.Integer:
							case ClassFile.ConstantType.Long:
							case ClassFile.ConstantType.String:
							case ClassFile.ConstantType.LiveObject:
								code[i].PatchOpCode(NormalizedByteCode.__ldc_nothrow);
								break;
						}
						break;
				}
			}
		}
	}

	internal CodeInfo GetCodeInfoAndErrors(UntangledExceptionTable exceptions, out List<string> errors)
	{
		CodeInfo codeInfo = new CodeInfo(state);
		OptimizationPass(codeInfo, classFile, method, exceptions, wrapper, classLoader);
		PatchHardErrorsAndDynamicMemberAccess(wrapper, mw);
		errors = errorMessages;
		if (AnalyzePotentialFaultBlocks(codeInfo, method, exceptions))
		{
			AnalyzeTypeFlow();
		}
		ConvertFinallyBlocks(codeInfo, method, exceptions);
		return codeInfo;
	}

	private void AnalyzeTypeFlow()
	{
		InstructionState s = new InstructionState(method.MaxLocals, method.MaxStack);
		bool done = false;
		ClassFile.Method.Instruction[] instructions = method.Instructions;
		while(!done)
		{
			done = true;
			for(int i = 0; i < instructions.Length; i++)
			{
				if(state[i] != null && state[i].changed)
				{
					try
					{
						//Console.WriteLine(method.Instructions[i].PC + ": " + method.Instructions[i].OpCode.ToString());
						done = false;
						state[i].changed = false;
						// mark the exception handlers reachable from this instruction
						for(int j = 0; j < method.ExceptionTable.Length; j++)
						{
							if(method.ExceptionTable[j].startIndex <= i && i < method.ExceptionTable[j].endIndex)
							{
								MergeExceptionHandler(j, state[i]);
							}
						}
						state[i].CopyTo(s);
						ClassFile.Method.Instruction instr = instructions[i];
						switch(instr.NormalizedOpCode)
						{
							case NormalizedByteCode.__aload:
							{
								TypeWrapper type = s.GetLocalType(instr.NormalizedArg1);
								if(type == VerifierTypeWrapper.Invalid || type.IsPrimitive)
								{
									throw new VerifyError("Object reference expected");
								}
								s.PushType(type);
								break;
							}
							case NormalizedByteCode.__astore:
							{
								if(VerifierTypeWrapper.IsFaultBlockException(s.PeekType()))
								{
									s.SetLocalType(instr.NormalizedArg1, s.PopFaultBlockException(), i);
									break;
								}
								// NOTE since the reference can be uninitialized, we cannot use PopObjectType
								TypeWrapper type = s.PopType();
								if(type.IsPrimitive)
								{
									throw new VerifyError("Object reference expected");
								}
								s.SetLocalType(instr.NormalizedArg1, type, i);
								break;
							}
							case NormalizedByteCode.__aconst_null:
								s.PushType(VerifierTypeWrapper.Null);
								break;
							case NormalizedByteCode.__aaload:
							{
								s.PopInt();
								TypeWrapper type = s.PopArrayType();
								if(type == VerifierTypeWrapper.Null)
								{
									// if the array is null, we have use null as the element type, because
									// otherwise the rest of the code will not verify correctly
									s.PushType(VerifierTypeWrapper.Null);
								}
								else if(type.IsUnloadable)
								{
									s.PushType(VerifierTypeWrapper.Unloadable);
								}
								else
								{
									type = type.ElementTypeWrapper;
									if(type.IsPrimitive)
									{
										throw new VerifyError("Object array expected");
									}
									s.PushType(type);
								}
								break;
							}
							case NormalizedByteCode.__aastore:
								s.PopObjectType();
								s.PopInt();
								s.PopArrayType();
								// TODO check that elem is assignable to the array
								break;
							case NormalizedByteCode.__baload:
							{
								s.PopInt();
								TypeWrapper type = s.PopArrayType();
								if(!VerifierTypeWrapper.IsNullOrUnloadable(type) &&
									type != ByteArrayType &&
									type != BooleanArrayType)
								{
									throw new VerifyError();
								}
								s.PushInt();
								break;
							}
							case NormalizedByteCode.__bastore:
							{
								s.PopInt();
								s.PopInt();
								TypeWrapper type = s.PopArrayType();
								if(!VerifierTypeWrapper.IsNullOrUnloadable(type) &&
									type != ByteArrayType &&
									type != BooleanArrayType)
								{
									throw new VerifyError();
								}
								break;
							}
							case NormalizedByteCode.__caload:
								s.PopInt();
								s.PopObjectType(CharArrayType);
								s.PushInt();
								break;
							case NormalizedByteCode.__castore:
								s.PopInt();
								s.PopInt();
								s.PopObjectType(CharArrayType);
								break;
							case NormalizedByteCode.__saload:
								s.PopInt();
								s.PopObjectType(ShortArrayType);
								s.PushInt();
								break;
							case NormalizedByteCode.__sastore:
								s.PopInt();
								s.PopInt();
								s.PopObjectType(ShortArrayType);
								break;
							case NormalizedByteCode.__iaload:
								s.PopInt();
								s.PopObjectType(IntArrayType);
								s.PushInt();
								break;
							case NormalizedByteCode.__iastore:
								s.PopInt();
								s.PopInt();
								s.PopObjectType(IntArrayType);
								break;
							case NormalizedByteCode.__laload:
								s.PopInt();
								s.PopObjectType(LongArrayType);
								s.PushLong();
								break;
							case NormalizedByteCode.__lastore:
								s.PopLong();
								s.PopInt();
								s.PopObjectType(LongArrayType);
								break;
							case NormalizedByteCode.__daload:
								s.PopInt();
								s.PopObjectType(DoubleArrayType);
								s.PushDouble();
								break;
							case NormalizedByteCode.__dastore:
								s.PopDouble();
								s.PopInt();
								s.PopObjectType(DoubleArrayType);
								break;
							case NormalizedByteCode.__faload:
								s.PopInt();
								s.PopObjectType(FloatArrayType);
								s.PushFloat();
								break;
							case NormalizedByteCode.__fastore:
								s.PopFloat();
								s.PopInt();
								s.PopObjectType(FloatArrayType);
								break;
							case NormalizedByteCode.__arraylength:
								s.PopArrayType();
								s.PushInt();
								break;
							case NormalizedByteCode.__iconst:
								s.PushInt();
								break;
							case NormalizedByteCode.__if_icmpeq:
							case NormalizedByteCode.__if_icmpne:
							case NormalizedByteCode.__if_icmplt:
							case NormalizedByteCode.__if_icmpge:
							case NormalizedByteCode.__if_icmpgt:
							case NormalizedByteCode.__if_icmple:
								s.PopInt();
								s.PopInt();
								break;
							case NormalizedByteCode.__ifeq:
							case NormalizedByteCode.__ifge:
							case NormalizedByteCode.__ifgt:
							case NormalizedByteCode.__ifle:
							case NormalizedByteCode.__iflt:
							case NormalizedByteCode.__ifne:
								s.PopInt();
								break;
							case NormalizedByteCode.__ifnonnull:
							case NormalizedByteCode.__ifnull:
								// TODO it might be legal to use an unitialized ref here
								s.PopObjectType();
								break;
							case NormalizedByteCode.__if_acmpeq:
							case NormalizedByteCode.__if_acmpne:
								// TODO it might be legal to use an unitialized ref here
								s.PopObjectType();
								s.PopObjectType();
								break;
							case NormalizedByteCode.__getstatic:
							case NormalizedByteCode.__dynamic_getstatic:
								// special support for when we're being called from IsSideEffectFreeStaticInitializer
								if(mw == null)
								{
									switch(GetFieldref(instr.Arg1).Signature[0])
									{
										case 'B':
										case 'Z':
										case 'C':
										case 'S':
										case 'I':
											s.PushInt();
											break;
										case 'F':
											s.PushFloat();
											break;
										case 'D':
											s.PushDouble();
											break;
										case 'J':
											s.PushLong();
											break;
										case 'L':
										case '[':
											throw new VerifyError();
										default:
											throw new InvalidOperationException();
									}
								}
								else
								{
									ClassFile.ConstantPoolItemFieldref cpi = GetFieldref(instr.Arg1);
									if(cpi.GetField() != null && cpi.GetField().FieldTypeWrapper.IsUnloadable)
									{
										s.PushType(cpi.GetField().FieldTypeWrapper);
									}
									else
									{
										s.PushType(cpi.GetFieldType());
									}
								}
								break;
							case NormalizedByteCode.__putstatic:
							case NormalizedByteCode.__dynamic_putstatic:
								// special support for when we're being called from IsSideEffectFreeStaticInitializer
								if(mw == null)
								{
									switch(GetFieldref(instr.Arg1).Signature[0])
									{
										case 'B':
										case 'Z':
										case 'C':
										case 'S':
										case 'I':
											s.PopInt();
											break;
										case 'F':
											s.PopFloat();
											break;
										case 'D':
											s.PopDouble();
											break;
										case 'J':
											s.PopLong();
											break;
										case 'L':
										case '[':
											if(s.PopAnyType() != VerifierTypeWrapper.Null)
											{
												throw new VerifyError();
											}
											break;
										default:
											throw new InvalidOperationException();
									}
								}
								else
								{
									s.PopType(GetFieldref(instr.Arg1).GetFieldType());
								}
								break;
							case NormalizedByteCode.__getfield:
							case NormalizedByteCode.__dynamic_getfield:
							{
								s.PopObjectType(GetFieldref(instr.Arg1).GetClassType());
								ClassFile.ConstantPoolItemFieldref cpi = GetFieldref(instr.Arg1);
								if(cpi.GetField() != null && cpi.GetField().FieldTypeWrapper.IsUnloadable)
								{
									s.PushType(cpi.GetField().FieldTypeWrapper);
								}
								else
								{
									s.PushType(cpi.GetFieldType());
								}
								break;
							}
							case NormalizedByteCode.__putfield:
							case NormalizedByteCode.__dynamic_putfield:
								s.PopType(GetFieldref(instr.Arg1).GetFieldType());
								// putfield is allowed to access the uninitialized this
								if(s.PeekType() == VerifierTypeWrapper.UninitializedThis
									&& wrapper.IsAssignableTo(GetFieldref(instr.Arg1).GetClassType()))
								{
									s.PopType();
								}
								else
								{
									s.PopObjectType(GetFieldref(instr.Arg1).GetClassType());
								}
								break;
							case NormalizedByteCode.__ldc_nothrow:
							case NormalizedByteCode.__ldc:
							{
								switch(GetConstantPoolConstantType(instr.Arg1))
								{
									case ClassFile.ConstantType.Double:
										s.PushDouble();
										break;
									case ClassFile.ConstantType.Float:
										s.PushFloat();
										break;
									case ClassFile.ConstantType.Integer:
										s.PushInt();
										break;
									case ClassFile.ConstantType.Long:
										s.PushLong();
										break;
									case ClassFile.ConstantType.String:
										s.PushType(CoreClasses.java.lang.String.Wrapper);
										break;
									case ClassFile.ConstantType.LiveObject:
										s.PushType(CoreClasses.java.lang.Object.Wrapper);
										break;
									case ClassFile.ConstantType.Class:
										if(classFile.MajorVersion < 49)
										{
											throw new VerifyError("Illegal type in constant pool");
										}
										s.PushType(CoreClasses.java.lang.Class.Wrapper);
										break;
									case ClassFile.ConstantType.MethodHandle:
										s.PushType(CoreClasses.java.lang.invoke.MethodHandle.Wrapper);
										break;
									case ClassFile.ConstantType.MethodType:
										s.PushType(CoreClasses.java.lang.invoke.MethodType.Wrapper);
										break;
									default:
										// NOTE this is not a VerifyError, because it cannot happen (unless we have
										// a bug in ClassFile.GetConstantPoolConstantType)
										throw new InvalidOperationException();
								}
								break;
							}
							case NormalizedByteCode.__clone_array:
							case NormalizedByteCode.__invokevirtual:
							case NormalizedByteCode.__invokespecial:
							case NormalizedByteCode.__invokeinterface:
							case NormalizedByteCode.__invokestatic:
							case NormalizedByteCode.__dynamic_invokevirtual:
							case NormalizedByteCode.__dynamic_invokespecial:
							case NormalizedByteCode.__dynamic_invokeinterface:
							case NormalizedByteCode.__dynamic_invokestatic:
							case NormalizedByteCode.__privileged_invokevirtual:
							case NormalizedByteCode.__privileged_invokespecial:
							case NormalizedByteCode.__privileged_invokestatic:
							case NormalizedByteCode.__methodhandle_invoke:
							case NormalizedByteCode.__methodhandle_link:
							{
								ClassFile.ConstantPoolItemMI cpi = GetMethodref(instr.Arg1);
								TypeWrapper retType = cpi.GetRetType();
								// HACK to allow the result of Unsafe.getObjectVolatile() (on an array)
								// to be used with Unsafe.putObject() we need to propagate the
								// element type here as the return type (instead of object)
								if(cpi.GetMethod() != null
									&& cpi.GetMethod().IsIntrinsic
									&& cpi.Class == "sun.misc.Unsafe"
									&& cpi.Name == "getObjectVolatile"
									&& Intrinsics.IsSupportedArrayTypeForUnsafeOperation(s.GetStackSlot(1)))
								{
									retType = s.GetStackSlot(1).ElementTypeWrapper;
								}
								s.MultiPopAnyType(cpi.GetArgTypes().Length);
								if(instr.NormalizedOpCode != NormalizedByteCode.__invokestatic
									&& instr.NormalizedOpCode != NormalizedByteCode.__dynamic_invokestatic)
								{
									TypeWrapper type = s.PopType();
									if(ReferenceEquals(cpi.Name, StringConstants.INIT))
									{
										// after we've invoked the constructor, the uninitialized references
										// are now initialized
										if(type == VerifierTypeWrapper.UninitializedThis)
										{
											if(s.GetLocalTypeEx(0) == type)
											{
												s.SetLocalType(0, thisType, i);
											}
											s.MarkInitialized(type, wrapper, i);
											s.SetUnitializedThis(false);
										}
										else if(VerifierTypeWrapper.IsNew(type))
										{
											s.MarkInitialized(type, ((VerifierTypeWrapper)type).UnderlyingType, i);
										}
										else
										{
											// This is a VerifyError, but it will be caught by our second pass
										}
									}
								}
								if(retType != PrimitiveTypeWrapper.VOID)
								{
									if(cpi.GetMethod() != null && cpi.GetMethod().ReturnType.IsUnloadable)
									{
										s.PushType(cpi.GetMethod().ReturnType);
									}
									else if(retType == PrimitiveTypeWrapper.DOUBLE)
									{
										s.PushExtendedDouble();
									}
									else if(retType == PrimitiveTypeWrapper.FLOAT)
									{
										s.PushExtendedFloat();
									}
									else
									{
										s.PushType(retType);
									}
								}
								break;
							}
							case NormalizedByteCode.__invokedynamic:
							{
								ClassFile.ConstantPoolItemInvokeDynamic cpi = GetInvokeDynamic(instr.Arg1);
								s.MultiPopAnyType(cpi.GetArgTypes().Length);
								TypeWrapper retType = cpi.GetRetType();
								if (retType != PrimitiveTypeWrapper.VOID)
								{
									if (retType == PrimitiveTypeWrapper.DOUBLE)
									{
										s.PushExtendedDouble();
									}
									else if (retType == PrimitiveTypeWrapper.FLOAT)
									{
										s.PushExtendedFloat();
									}
									else
									{
										s.PushType(retType);
									}
								}
								break;
							}
							case NormalizedByteCode.__goto:
								break;
							case NormalizedByteCode.__istore:
								s.PopInt();
								s.SetLocalInt(instr.NormalizedArg1, i);
								break;
							case NormalizedByteCode.__iload:
								s.GetLocalInt(instr.NormalizedArg1);
								s.PushInt();
								break;
							case NormalizedByteCode.__ineg:
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__iadd:
							case NormalizedByteCode.__isub:
							case NormalizedByteCode.__imul:
							case NormalizedByteCode.__idiv:
							case NormalizedByteCode.__irem:
							case NormalizedByteCode.__iand:
							case NormalizedByteCode.__ior:
							case NormalizedByteCode.__ixor:
							case NormalizedByteCode.__ishl:
							case NormalizedByteCode.__ishr:
							case NormalizedByteCode.__iushr:
								s.PopInt();
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__lneg:
								s.PopLong();
								s.PushLong();
								break;
							case NormalizedByteCode.__ladd:
							case NormalizedByteCode.__lsub:
							case NormalizedByteCode.__lmul:
							case NormalizedByteCode.__ldiv:
							case NormalizedByteCode.__lrem:
							case NormalizedByteCode.__land:
							case NormalizedByteCode.__lor:
							case NormalizedByteCode.__lxor:
								s.PopLong();
								s.PopLong();
								s.PushLong();
								break;
							case NormalizedByteCode.__lshl:
							case NormalizedByteCode.__lshr:
							case NormalizedByteCode.__lushr:
								s.PopInt();
								s.PopLong();
								s.PushLong();
								break;
							case NormalizedByteCode.__fneg:
								if(s.PopFloat())
								{
									s.PushExtendedFloat();
								}
								else
								{
									s.PushFloat();
								}
								break;
							case NormalizedByteCode.__fadd:
							case NormalizedByteCode.__fsub:
							case NormalizedByteCode.__fmul:
							case NormalizedByteCode.__fdiv:
							case NormalizedByteCode.__frem:
								s.PopFloat();
								s.PopFloat();
								s.PushExtendedFloat();
								break;
							case NormalizedByteCode.__dneg:
								if(s.PopDouble())
								{
									s.PushExtendedDouble();
								}
								else
								{
									s.PushDouble();
								}
								break;
							case NormalizedByteCode.__dadd:
							case NormalizedByteCode.__dsub:
							case NormalizedByteCode.__dmul:
							case NormalizedByteCode.__ddiv:
							case NormalizedByteCode.__drem:
								s.PopDouble();
								s.PopDouble();
								s.PushExtendedDouble();
								break;
							case NormalizedByteCode.__new:
							{
								// mark the type, so that we can ascertain that it is a "new object"
								TypeWrapper type;
								if(!newTypes.TryGetValue(i, out type))
								{
									type = GetConstantPoolClassType(instr.Arg1);
									if(type.IsArray)
									{
										throw new VerifyError("Illegal use of array type");
									}
									type = VerifierTypeWrapper.MakeNew(type, i);
									newTypes[i] = type;
								}
								s.PushType(type);
								break;
							}
							case NormalizedByteCode.__multianewarray:
							{
								if(instr.Arg2 < 1)
								{
									throw new VerifyError("Illegal dimension argument");
								}
								for(int j = 0; j < instr.Arg2; j++)
								{
									s.PopInt();
								}
								TypeWrapper type = GetConstantPoolClassType(instr.Arg1);
								if(type.ArrayRank < instr.Arg2)
								{
									throw new VerifyError("Illegal dimension argument");
								}
								s.PushType(type);
								break;
							}
							case NormalizedByteCode.__anewarray:
							{
								s.PopInt();
								TypeWrapper type = GetConstantPoolClassType(instr.Arg1);
								if(type.IsUnloadable)
								{
									s.PushType(new UnloadableTypeWrapper("[" + type.SigName));
								}
								else
								{
									s.PushType(type.MakeArrayType(1));
								}
								break;
							}
							case NormalizedByteCode.__newarray:
								s.PopInt();
							switch(instr.Arg1)
							{
								case 4:
									s.PushType(BooleanArrayType);
									break;
								case 5:
									s.PushType(CharArrayType);
									break;
								case 6:
									s.PushType(FloatArrayType);
									break;
								case 7:
									s.PushType(DoubleArrayType);
									break;
								case 8:
									s.PushType(ByteArrayType);
									break;
								case 9:
									s.PushType(ShortArrayType);
									break;
								case 10:
									s.PushType(IntArrayType);
									break;
								case 11:
									s.PushType(LongArrayType);
									break;
								default:
									throw new VerifyError("Bad type");
							}
								break;
							case NormalizedByteCode.__swap:
							{
								TypeWrapper t1 = s.PopType();
								TypeWrapper t2 = s.PopType();
								s.PushType(t1);
								s.PushType(t2);
								break;
							}
							case NormalizedByteCode.__dup:
							{
								TypeWrapper t = s.PopType();
								s.PushType(t);
								s.PushType(t);
								break;
							}
							case NormalizedByteCode.__dup2:
							{
								TypeWrapper t = s.PopAnyType();
								if(t.IsWidePrimitive || t == VerifierTypeWrapper.ExtendedDouble)
								{
									s.PushType(t);
									s.PushType(t);
								}
								else
								{
									TypeWrapper t2 = s.PopType();
									s.PushType(t2);
									s.PushType(t);
									s.PushType(t2);
									s.PushType(t);
								}
								break;
							}
							case NormalizedByteCode.__dup_x1:
							{
								TypeWrapper value1 = s.PopType();
								TypeWrapper value2 = s.PopType();
								s.PushType(value1);
								s.PushType(value2);
								s.PushType(value1);
								break;
							}
							case NormalizedByteCode.__dup2_x1:
							{
								TypeWrapper value1 = s.PopAnyType();
								if(value1.IsWidePrimitive || value1 == VerifierTypeWrapper.ExtendedDouble)
								{
									TypeWrapper value2 = s.PopType();
									s.PushType(value1);
									s.PushType(value2);
									s.PushType(value1);
								}
								else
								{
									TypeWrapper value2 = s.PopType();
									TypeWrapper value3 = s.PopType();
									s.PushType(value2);
									s.PushType(value1);
									s.PushType(value3);
									s.PushType(value2);
									s.PushType(value1);
								}
								break;
							}
							case NormalizedByteCode.__dup_x2:
							{
								TypeWrapper value1 = s.PopType();
								TypeWrapper value2 = s.PopAnyType();
								if(value2.IsWidePrimitive || value2 == VerifierTypeWrapper.ExtendedDouble)
								{
									s.PushType(value1);
									s.PushType(value2);
									s.PushType(value1);
								}
								else
								{
									TypeWrapper value3 = s.PopType();
									s.PushType(value1);
									s.PushType(value3);
									s.PushType(value2);
									s.PushType(value1);
								}
								break;
							}
							case NormalizedByteCode.__dup2_x2:
							{
								TypeWrapper value1 = s.PopAnyType();
								if(value1.IsWidePrimitive || value1 == VerifierTypeWrapper.ExtendedDouble)
								{
									TypeWrapper value2 = s.PopAnyType();
									if(value2.IsWidePrimitive || value2 == VerifierTypeWrapper.ExtendedDouble)
									{
										// Form 4
										s.PushType(value1);
										s.PushType(value2);
										s.PushType(value1);
									}
									else
									{
										// Form 2
										TypeWrapper value3 = s.PopType();
										s.PushType(value1);
										s.PushType(value3);
										s.PushType(value2);
										s.PushType(value1);
									}
								}
								else
								{
									TypeWrapper value2 = s.PopType();
									TypeWrapper value3 = s.PopAnyType();
									if(value3.IsWidePrimitive || value3 == VerifierTypeWrapper.ExtendedDouble)
									{
										// Form 3
										s.PushType(value2);
										s.PushType(value1);
										s.PushType(value3);
										s.PushType(value2);
										s.PushType(value1);
									}
									else
									{
										// Form 4
										TypeWrapper value4 = s.PopType();
										s.PushType(value2);
										s.PushType(value1);
										s.PushType(value4);
										s.PushType(value3);
										s.PushType(value2);
										s.PushType(value1);
									}
								}
								break;
							}
							case NormalizedByteCode.__pop:
								s.PopType();
								break;
							case NormalizedByteCode.__pop2:
							{
								TypeWrapper type = s.PopAnyType();
								if(!type.IsWidePrimitive && type != VerifierTypeWrapper.ExtendedDouble)
								{
									s.PopType();
								}
								break;
							}
							case NormalizedByteCode.__monitorenter:
							case NormalizedByteCode.__monitorexit:
								// TODO these bytecodes are allowed on an uninitialized object, but
								// we don't support that at the moment...
								s.PopObjectType();
								break;
							case NormalizedByteCode.__return:
								// mw is null if we're called from IsSideEffectFreeStaticInitializer
								if(mw != null)
								{
									if(mw.ReturnType != PrimitiveTypeWrapper.VOID)
									{
										throw new VerifyError("Wrong return type in function");
									}
									// if we're a constructor, make sure we called the base class constructor
									s.CheckUninitializedThis();
								}
								break;
							case NormalizedByteCode.__areturn:
								s.PopObjectType(mw.ReturnType);
								break;
							case NormalizedByteCode.__ireturn:
							{
								s.PopInt();
								if(!mw.ReturnType.IsIntOnStackPrimitive)
								{
									throw new VerifyError("Wrong return type in function");
								}
								break;
							}
							case NormalizedByteCode.__lreturn:
								s.PopLong();
								if(mw.ReturnType != PrimitiveTypeWrapper.LONG)
								{
									throw new VerifyError("Wrong return type in function");
								}
								break;
							case NormalizedByteCode.__freturn:
								s.PopFloat();
								if(mw.ReturnType != PrimitiveTypeWrapper.FLOAT)
								{
									throw new VerifyError("Wrong return type in function");
								}
								break;
							case NormalizedByteCode.__dreturn:
								s.PopDouble();
								if(mw.ReturnType != PrimitiveTypeWrapper.DOUBLE)
								{
									throw new VerifyError("Wrong return type in function");
								}
								break;
							case NormalizedByteCode.__fload:
								s.GetLocalFloat(instr.NormalizedArg1);
								s.PushFloat();
								break;
							case NormalizedByteCode.__fstore:
								s.PopFloat();
								s.SetLocalFloat(instr.NormalizedArg1, i);
								break;
							case NormalizedByteCode.__dload:
								s.GetLocalDouble(instr.NormalizedArg1);
								s.PushDouble();
								break;
							case NormalizedByteCode.__dstore:
								s.PopDouble();
								s.SetLocalDouble(instr.NormalizedArg1, i);
								break;
							case NormalizedByteCode.__lload:
								s.GetLocalLong(instr.NormalizedArg1);
								s.PushLong();
								break;
							case NormalizedByteCode.__lstore:
								s.PopLong();
								s.SetLocalLong(instr.NormalizedArg1, i);
								break;
							case NormalizedByteCode.__lconst_0:
							case NormalizedByteCode.__lconst_1:
								s.PushLong();
								break;
							case NormalizedByteCode.__fconst_0:
							case NormalizedByteCode.__fconst_1:
							case NormalizedByteCode.__fconst_2:
								s.PushFloat();
								break;
							case NormalizedByteCode.__dconst_0:
							case NormalizedByteCode.__dconst_1:
								s.PushDouble();
								break;
							case NormalizedByteCode.__lcmp:
								s.PopLong();
								s.PopLong();
								s.PushInt();
								break;
							case NormalizedByteCode.__fcmpl:
							case NormalizedByteCode.__fcmpg:
								s.PopFloat();
								s.PopFloat();
								s.PushInt();
								break;
							case NormalizedByteCode.__dcmpl:
							case NormalizedByteCode.__dcmpg:
								s.PopDouble();
								s.PopDouble();
								s.PushInt();
								break;
							case NormalizedByteCode.__checkcast:
								s.PopObjectType();
								s.PushType(GetConstantPoolClassType(instr.Arg1));
								break;
							case NormalizedByteCode.__instanceof:
								s.PopObjectType();
								s.PushInt();
								break;
							case NormalizedByteCode.__iinc:
								s.GetLocalInt(instr.Arg1);
								break;
							case NormalizedByteCode.__athrow:
								if (VerifierTypeWrapper.IsFaultBlockException(s.PeekType()))
								{
									s.PopFaultBlockException();
								}
								else
								{
									s.PopObjectType(CoreClasses.java.lang.Throwable.Wrapper);
								}
								break;
							case NormalizedByteCode.__tableswitch:
							case NormalizedByteCode.__lookupswitch:
								s.PopInt();
								break;
							case NormalizedByteCode.__i2b:
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__i2c:
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__i2s:
								s.PopInt();
								s.PushInt();
								break;
							case NormalizedByteCode.__i2l:
								s.PopInt();
								s.PushLong();
								break;
							case NormalizedByteCode.__i2f:
								s.PopInt();
								s.PushFloat();
								break;
							case NormalizedByteCode.__i2d:
								s.PopInt();
								s.PushDouble();
								break;
							case NormalizedByteCode.__l2i:
								s.PopLong();
								s.PushInt();
								break;
							case NormalizedByteCode.__l2f:
								s.PopLong();
								s.PushFloat();
								break;
							case NormalizedByteCode.__l2d:
								s.PopLong();
								s.PushDouble();
								break;
							case NormalizedByteCode.__f2i:
								s.PopFloat();
								s.PushInt();
								break;
							case NormalizedByteCode.__f2l:
								s.PopFloat();
								s.PushLong();
								break;
							case NormalizedByteCode.__f2d:
								s.PopFloat();
								s.PushDouble();
								break;
							case NormalizedByteCode.__d2i:
								s.PopDouble();
								s.PushInt();
								break;
							case NormalizedByteCode.__d2f:
								s.PopDouble();
								s.PushFloat();
								break;
							case NormalizedByteCode.__d2l:
								s.PopDouble();
								s.PushLong();
								break;
							case NormalizedByteCode.__nop:
								if(i + 1 == instructions.Length)
								{
									throw new VerifyError("Falling off the end of the code");
								}
								break;
							case NormalizedByteCode.__static_error:
								break;
							case NormalizedByteCode.__jsr:
							case NormalizedByteCode.__ret:
								throw new VerifyError("Bad instruction");
							default:
								throw new NotImplementedException(instr.NormalizedOpCode.ToString());
						}
						if(s.GetStackHeight() > method.MaxStack)
						{
							throw new VerifyError("Stack size too large");
						}
						for(int j = 0; j < method.ExceptionTable.Length; j++)
						{
							if(method.ExceptionTable[j].endIndex == i + 1)
							{
								MergeExceptionHandler(j, s);
							}
						}
						try
						{
							switch(ByteCodeMetaData.GetFlowControl(instr.NormalizedOpCode))
							{
								case ByteCodeFlowControl.Switch:
									for(int j = 0; j < instr.SwitchEntryCount; j++)
									{
										state[instr.GetSwitchTargetIndex(j)] += s;
									}
									state[instr.DefaultTarget] += s;
									break;
								case ByteCodeFlowControl.CondBranch:
									state[i + 1] += s;
									state[instr.TargetIndex] += s;
									break;
								case ByteCodeFlowControl.Branch:
									state[instr.TargetIndex] += s;
									break;
								case ByteCodeFlowControl.Return:
								case ByteCodeFlowControl.Throw:
									break;
								case ByteCodeFlowControl.Next:
									state[i + 1] += s;
									break;
								default:
									throw new InvalidOperationException();
							}
						}
						catch(IndexOutOfRangeException)
						{
							// we're going to assume that this always means that we have an invalid branch target
							// NOTE because PcIndexMap returns -1 for illegal PCs (in the middle of an instruction) and
							// we always use that value as an index into the state array, any invalid PC will result
							// in an IndexOutOfRangeException
							throw new VerifyError("Illegal target of jump or branch");
						}
					}
					catch(VerifyError x)
					{
						string opcode = instructions[i].NormalizedOpCode.ToString();
						if(opcode.StartsWith("__"))
						{
							opcode = opcode.Substring(2);
						}
						throw new VerifyError(string.Format("{5} (class: {0}, method: {1}, signature: {2}, offset: {3}, instruction: {4})",
							classFile.Name, method.Name, method.Signature, instructions[i].PC, opcode, x.Message), x);
					}
				}
			}
		}
	}

	private void MergeExceptionHandler(int exceptionIndex, InstructionState curr)
	{
		int idx = method.ExceptionTable[exceptionIndex].handlerIndex;
		InstructionState ex = curr.CopyLocals();
		int catch_type = method.ExceptionTable[exceptionIndex].catch_type;
		if (catch_type == 0)
		{
			TypeWrapper tw;
			if (!faultTypes.TryGetValue(idx, out tw))
			{
				tw = VerifierTypeWrapper.MakeFaultBlockException(this, idx);
				faultTypes.Add(idx, tw);
			}
			ex.PushType(tw);
		}
		else
		{
			// TODO if the exception type is unloadable we should consider pushing
			// Throwable as the type and recording a loader constraint
			ex.PushType(GetConstantPoolClassType(catch_type));
		}
		state[idx] += ex;
	}

	// this verification pass must run on the unmodified bytecode stream
	private void VerifyPassTwo()
	{
		ClassFile.Method.Instruction[] instructions = method.Instructions;
		for (int i = 0; i < instructions.Length; i++)
		{
			if (state[i] != null)
			{
				try
				{
					switch (instructions[i].NormalizedOpCode)
					{
						case NormalizedByteCode.__invokeinterface:
						case NormalizedByteCode.__invokespecial:
						case NormalizedByteCode.__invokestatic:
						case NormalizedByteCode.__invokevirtual:
							VerifyInvokePassTwo(i);
							break;
						case NormalizedByteCode.__invokedynamic:
							VerifyInvokeDynamic(i);
							break;
					}
				}
				catch (VerifyError x)
				{
					string opcode = instructions[i].NormalizedOpCode.ToString();
					if (opcode.StartsWith("__"))
					{
						opcode = opcode.Substring(2);
					}
					throw new VerifyError(string.Format("{5} (class: {0}, method: {1}, signature: {2}, offset: {3}, instruction: {4})",
						classFile.Name, method.Name, method.Signature, instructions[i].PC, opcode, x.Message), x);
				}
			}
		}
	}

	private void VerifyInvokePassTwo(int index)
	{
		StackState stack = new StackState(state[index]);
		NormalizedByteCode invoke = method.Instructions[index].NormalizedOpCode;
		ClassFile.ConstantPoolItemMI cpi = GetMethodref(method.Instructions[index].Arg1);
		if ((invoke == NormalizedByteCode.__invokestatic || invoke == NormalizedByteCode.__invokespecial) && classFile.MajorVersion >= 52)
		{
			// invokestatic and invokespecial may be used to invoke interface methods in Java 8
			// but invokespecial can only invoke methods in the current interface or a directly implemented interface
			if (invoke == NormalizedByteCode.__invokespecial && cpi is ClassFile.ConstantPoolItemInterfaceMethodref)
			{
				if (cpi.GetClassType() == host)
				{
					// ok
				}
				else if (cpi.GetClassType() != wrapper && Array.IndexOf(wrapper.Interfaces, cpi.GetClassType()) == -1)
				{
					throw new VerifyError("Bad invokespecial instruction: interface method reference is in an indirect superinterface.");
				}
			}
		}
		else if ((cpi is ClassFile.ConstantPoolItemInterfaceMethodref) != (invoke == NormalizedByteCode.__invokeinterface))
		{
			throw new VerifyError("Illegal constant pool index");
		}
		if (invoke != NormalizedByteCode.__invokespecial && ReferenceEquals(cpi.Name, StringConstants.INIT))
		{
			throw new VerifyError("Must call initializers using invokespecial");
		}
		if (ReferenceEquals(cpi.Name, StringConstants.CLINIT))
		{
			throw new VerifyError("Illegal call to internal method");
		}
		TypeWrapper[] args = cpi.GetArgTypes();
		for (int j = args.Length - 1; j >= 0; j--)
		{
			stack.PopType(args[j]);
		}
		if (invoke == NormalizedByteCode.__invokeinterface)
		{
			int argcount = args.Length + 1;
			for (int j = 0; j < args.Length; j++)
			{
				if (args[j].IsWidePrimitive)
				{
					argcount++;
				}
			}
			if (method.Instructions[index].Arg2 != argcount)
			{
				throw new VerifyError("Inconsistent args size");
			}
		}
		bool isnew = false;
		TypeWrapper thisType;
		if (invoke == NormalizedByteCode.__invokestatic)
		{
			thisType = null;
		}
		else
		{
			thisType = SigTypeToClassName(stack.PeekType(), cpi.GetClassType(), wrapper);
			if (ReferenceEquals(cpi.Name, StringConstants.INIT))
			{
				TypeWrapper type = stack.PopType();
				isnew = VerifierTypeWrapper.IsNew(type);
				if ((isnew && ((VerifierTypeWrapper)type).UnderlyingType != cpi.GetClassType()) ||
					(type == VerifierTypeWrapper.UninitializedThis && cpi.GetClassType() != wrapper.BaseTypeWrapper && cpi.GetClassType() != wrapper) ||
					(!isnew && type != VerifierTypeWrapper.UninitializedThis))
				{
					// TODO oddly enough, Java fails verification for the class without
					// even running the constructor, so maybe constructors are always
					// verified...
					// NOTE when a constructor isn't verifiable, the static initializer
					// doesn't run either
					throw new VerifyError("Call to wrong initialization method");
				}
			}
			else
			{
				if (invoke != NormalizedByteCode.__invokeinterface)
				{
					TypeWrapper refType = stack.PopObjectType();
					TypeWrapper targetType = cpi.GetClassType();
					if (!VerifierTypeWrapper.IsNullOrUnloadable(refType) &&
						!targetType.IsUnloadable &&
						!refType.IsAssignableTo(targetType))
					{
						throw new VerifyError("Incompatible object argument for function call");
					}
					// for invokespecial we also need to make sure we're calling ourself or a base class
					if (invoke == NormalizedByteCode.__invokespecial)
					{
						if (VerifierTypeWrapper.IsNullOrUnloadable(refType))
						{
							// ok
						}
						else if (refType.IsSubTypeOf(wrapper))
						{
							// ok
						}
						else if (host != null && refType.IsSubTypeOf(host))
						{
							// ok
						}
						else
						{
							throw new VerifyError("Incompatible target object for invokespecial");
						}
						if (targetType.IsUnloadable)
						{
							// ok
						}
						else if (wrapper.IsSubTypeOf(targetType))
						{
							// ok
						}
						else if (host != null && host.IsSubTypeOf(targetType))
						{
							// ok
						}
						else
						{
							throw new VerifyError("Invokespecial cannot call subclass methods");
						}
					}
				}
				else /* __invokeinterface */
				{
					// NOTE unlike in the above case, we also allow *any* interface target type
					// regardless of whether it is compatible or not, because if it is not compatible
					// we want an IncompatibleClassChangeError at runtime
					TypeWrapper refType = stack.PopObjectType();
					TypeWrapper targetType = cpi.GetClassType();
					if (!VerifierTypeWrapper.IsNullOrUnloadable(refType)
						&& !targetType.IsUnloadable
						&& !refType.IsAssignableTo(targetType)
						&& !targetType.IsInterface)
					{
						throw new VerifyError("Incompatible object argument for function call");
					}
				}
			}
		}
	}

	private void VerifyInvokeDynamic(int index)
	{
		StackState stack = new StackState(state[index]);
		ClassFile.ConstantPoolItemInvokeDynamic cpi = GetInvokeDynamic(method.Instructions[index].Arg1);
		TypeWrapper[] args = cpi.GetArgTypes();
		for (int j = args.Length - 1; j >= 0; j--)
		{
			stack.PopType(args[j]);
		}
	}

	private static void OptimizationPass(CodeInfo codeInfo, ClassFile classFile, ClassFile.Method method, UntangledExceptionTable exceptions, TypeWrapper wrapper, ClassLoaderWrapper classLoader)
	{
		// Optimization pass
		if (classLoader.RemoveAsserts)
		{
			// While the optimization is general, in practice it never happens that a getstatic is used on a final field,
			// so we only look for this if assert initialization has been optimized out.
			if (classFile.HasAssertions)
			{
				// compute branch targets
				InstructionFlags[] flags = MethodAnalyzer.ComputePartialReachability(codeInfo, method.Instructions, exceptions, 0, false);
				ClassFile.Method.Instruction[] instructions = method.Instructions;
				for (int i = 0; i < instructions.Length; i++)
				{
					if (instructions[i].NormalizedOpCode == NormalizedByteCode.__getstatic
						&& instructions[i + 1].NormalizedOpCode == NormalizedByteCode.__ifne
						&& instructions[i + 1].TargetIndex > i
						&& (flags[i + 1] & InstructionFlags.BranchTarget) == 0)
					{
						ConstantFieldWrapper field = classFile.GetFieldref(instructions[i].Arg1).GetField() as ConstantFieldWrapper;
						if (field != null && field.FieldTypeWrapper == PrimitiveTypeWrapper.BOOLEAN && (bool)field.GetConstantValue())
						{
							// We know the branch will always be taken, so we replace the getstatic/ifne by a goto.
							instructions[i].PatchOpCode(NormalizedByteCode.__goto, instructions[i + 1].TargetIndex);
						}
					}
				}
			}
		}
	}

	private void PatchHardErrorsAndDynamicMemberAccess(TypeWrapper wrapper, MethodWrapper mw)
	{
		// Now we do another pass to find "hard error" instructions
		if(true)
		{
			ClassFile.Method.Instruction[] instructions = method.Instructions;
			for(int i = 0; i < instructions.Length; i++)
			{
				if(state[i] != null)
				{
					StackState stack = new StackState(state[i]);
					switch(instructions[i].NormalizedOpCode)
					{
						case NormalizedByteCode.__invokeinterface:
						case NormalizedByteCode.__invokespecial:
						case NormalizedByteCode.__invokestatic:
						case NormalizedByteCode.__invokevirtual:
							PatchInvoke(wrapper, ref instructions[i], stack);
							break;
						case NormalizedByteCode.__getfield:
						case NormalizedByteCode.__putfield:
						case NormalizedByteCode.__getstatic:
						case NormalizedByteCode.__putstatic:
							PatchFieldAccess(wrapper, mw, ref instructions[i], stack);
							break;
						case NormalizedByteCode.__ldc:
							switch(classFile.GetConstantPoolConstantType(instructions[i].Arg1))
							{
								case ClassFile.ConstantType.Class:
								{
									TypeWrapper tw = classFile.GetConstantPoolClassType(instructions[i].Arg1);
									if(tw.IsUnloadable)
									{
										ConditionalPatchNoClassDefFoundError(ref instructions[i], tw);
									}
									break;
								}
								case ClassFile.ConstantType.MethodType:
								{
									ClassFile.ConstantPoolItemMethodType cpi = classFile.GetConstantPoolConstantMethodType(instructions[i].Arg1);
									TypeWrapper[] args = cpi.GetArgTypes();
									TypeWrapper tw = cpi.GetRetType();
									for(int j = 0; !tw.IsUnloadable && j < args.Length; j++)
									{
										tw = args[j];
									}
									if(tw.IsUnloadable)
									{
										ConditionalPatchNoClassDefFoundError(ref instructions[i], tw);
									}
									break;
								}
								case ClassFile.ConstantType.MethodHandle:
									PatchLdcMethodHandle(ref instructions[i]);
									break;
							}
							break;
						case NormalizedByteCode.__new:
						{
							TypeWrapper tw = classFile.GetConstantPoolClassType(instructions[i].Arg1);
							if(tw.IsUnloadable)
							{
								ConditionalPatchNoClassDefFoundError(ref instructions[i], tw);
							}
							else if(!tw.IsAccessibleFrom(wrapper))
							{
								SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.IllegalAccessError, "Try to access class {0} from class {1}", tw.Name, wrapper.Name);
							}
							else if(tw.IsAbstract)
							{
								SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.InstantiationError, "{0}", tw.Name);
							}
							break;
						}
						case NormalizedByteCode.__multianewarray:
						case NormalizedByteCode.__anewarray:
						{
							TypeWrapper tw = classFile.GetConstantPoolClassType(instructions[i].Arg1);
							if(tw.IsUnloadable)
							{
								ConditionalPatchNoClassDefFoundError(ref instructions[i], tw);
							}
							else if(!tw.IsAccessibleFrom(wrapper))
							{
								SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.IllegalAccessError, "Try to access class {0} from class {1}", tw.Name, wrapper.Name);
							}
							break;
						}
						case NormalizedByteCode.__checkcast:
						case NormalizedByteCode.__instanceof:
						{
							TypeWrapper tw = classFile.GetConstantPoolClassType(instructions[i].Arg1);
							if(tw.IsUnloadable)
							{
								// If the type is unloadable, we always generate the dynamic code
								// (regardless of ClassLoaderWrapper.DisableDynamicBinding), because at runtime,
								// null references should always pass thru without attempting
								// to load the type (for Sun compatibility).
							}
							else if(!tw.IsAccessibleFrom(wrapper))
							{
								SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.IllegalAccessError, "Try to access class {0} from class {1}", tw.Name, wrapper.Name);
							}
							break;
						}
						case NormalizedByteCode.__aaload:
						{
							stack.PopInt();
							TypeWrapper tw = stack.PopArrayType();
							if(tw.IsUnloadable)
							{
								ConditionalPatchNoClassDefFoundError(ref instructions[i], tw);
							}
							break;
						}
						case NormalizedByteCode.__aastore:
						{
							stack.PopObjectType();
							stack.PopInt();
							TypeWrapper tw = stack.PopArrayType();
							if(tw.IsUnloadable)
							{
								ConditionalPatchNoClassDefFoundError(ref instructions[i], tw);
							}
							break;
						}
						default:
							break;
					}
				}
			}
		}
	}

	private void PatchLdcMethodHandle(ref ClassFile.Method.Instruction instr)
	{
		ClassFile.ConstantPoolItemMethodHandle cpi = classFile.GetConstantPoolConstantMethodHandle(instr.Arg1);
		if (cpi.GetClassType().IsUnloadable)
		{
			ConditionalPatchNoClassDefFoundError(ref instr, cpi.GetClassType());
		}
		else if (!cpi.GetClassType().IsAccessibleFrom(wrapper))
		{
			SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IllegalAccessError, "tried to access class {0} from class {1}", cpi.Class, wrapper.Name);
		}
		else if (cpi.Kind == ClassFile.RefKind.invokeVirtual
			&& cpi.GetClassType() == CoreClasses.java.lang.invoke.MethodHandle.Wrapper
			&& (cpi.Name == "invoke" || cpi.Name == "invokeExact"))
		{
			// it's allowed to use ldc to create a MethodHandle invoker
		}
		else if (cpi.Member == null
			|| cpi.Member.IsStatic != (cpi.Kind == ClassFile.RefKind.getStatic || cpi.Kind == ClassFile.RefKind.putStatic || cpi.Kind == ClassFile.RefKind.invokeStatic))
		{
			HardError err;
			string msg;
			switch (cpi.Kind)
			{
				case ClassFile.RefKind.getField:
				case ClassFile.RefKind.getStatic:
				case ClassFile.RefKind.putField:
				case ClassFile.RefKind.putStatic:
					err = HardError.NoSuchFieldError;
					msg = cpi.Name;
					break;
				default:
					err = HardError.NoSuchMethodError;
					msg = cpi.Class + "." + cpi.Name + cpi.Signature;
					break;
			}
			SetHardError(wrapper.GetClassLoader(), ref instr, err, msg, cpi.Class, cpi.Name, SigToString(cpi.Signature));
		}
		else if (!cpi.Member.IsAccessibleFrom(cpi.GetClassType(), wrapper, cpi.GetClassType()))
		{
			if (cpi.Member.IsProtected && wrapper.IsSubTypeOf(cpi.Member.DeclaringType))
			{
				// this is allowed, the receiver will be narrowed to current type
			}
			else
			{
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IllegalAccessException, "member is private: {0}.{1}/{2}/{3}, from {4}", cpi.Class, cpi.Name, SigToString(cpi.Signature), cpi.Kind, wrapper.Name);
			}
		}
	}

	private static string SigToString(string sig)
	{
		System.Text.StringBuilder sb = new System.Text.StringBuilder();
		string sep = "";
		int dims = 0;
		for (int i = 0; i < sig.Length; i++)
		{
			if (sig[i] == '(' || sig[i] == ')')
			{
				sb.Append(sig[i]);
				sep = "";
				continue;
			}
			else if (sig[i] == '[')
			{
				dims++;
				continue;
			}
			sb.Append(sep);
			sep = ",";
			switch (sig[i])
			{
				case 'V':
					sb.Append("void");
					break;
				case 'B':
					sb.Append("byte");
					break;
				case 'Z':
					sb.Append("boolean");
					break;
				case 'S':
					sb.Append("short");
					break;
				case 'C':
					sb.Append("char");
					break;
				case 'I':
					sb.Append("int");
					break;
				case 'J':
					sb.Append("long");
					break;
				case 'F':
					sb.Append("float");
					break;
				case 'D':
					sb.Append("double");
					break;
				case 'L':
					sb.Append(sig, i + 1, sig.IndexOf(';', i + 1) - (i + 1));
					i = sig.IndexOf(';', i + 1);
					break;
			}
			for (; dims != 0; dims--)
			{
				sb.Append("[]");
			}
		}
		return sb.ToString();
	}

	internal static InstructionFlags[] ComputePartialReachability(CodeInfo codeInfo, ClassFile.Method.Instruction[] instructions, UntangledExceptionTable exceptions, int initialInstructionIndex, bool skipFaultBlocks)
	{
		InstructionFlags[] flags = new InstructionFlags[instructions.Length];
		flags[initialInstructionIndex] |= InstructionFlags.Reachable;
		UpdatePartialReachability(flags, codeInfo, instructions, exceptions, skipFaultBlocks);
		return flags;
	}

	private static void UpdatePartialReachability(InstructionFlags[] flags, CodeInfo codeInfo, ClassFile.Method.Instruction[] instructions, UntangledExceptionTable exceptions, bool skipFaultBlocks)
	{
		bool done = false;
		while (!done)
		{
			done = true;
			for (int i = 0; i < instructions.Length; i++)
			{
				if ((flags[i] & (InstructionFlags.Reachable | InstructionFlags.Processed)) == InstructionFlags.Reachable)
				{
					done = false;
					flags[i] |= InstructionFlags.Processed;
					// mark the exception handlers reachable from this instruction
					for (int j = 0; j < exceptions.Length; j++)
					{
						if (exceptions[j].startIndex <= i && i < exceptions[j].endIndex)
						{
							int idx = exceptions[j].handlerIndex;
							if (!skipFaultBlocks || !VerifierTypeWrapper.IsFaultBlockException(codeInfo.GetRawStackTypeWrapper(idx, 0)))
							{
								flags[idx] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
							}
						}
					}
					MarkSuccessors(instructions, flags, i);
				}
			}
		}
	}

	private static void MarkSuccessors(ClassFile.Method.Instruction[] code, InstructionFlags[] flags, int index)
	{
		switch (ByteCodeMetaData.GetFlowControl(code[index].NormalizedOpCode))
		{
			case ByteCodeFlowControl.Switch:
				{
					for (int i = 0; i < code[index].SwitchEntryCount; i++)
					{
						flags[code[index].GetSwitchTargetIndex(i)] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
					}
					flags[code[index].DefaultTarget] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
					break;
				}
			case ByteCodeFlowControl.Branch:
				flags[code[index].TargetIndex] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
				break;
			case ByteCodeFlowControl.CondBranch:
				flags[code[index].TargetIndex] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
				flags[index + 1] |= InstructionFlags.Reachable;
				break;
			case ByteCodeFlowControl.Return:
			case ByteCodeFlowControl.Throw:
				break;
			case ByteCodeFlowControl.Next:
				flags[index + 1] |= InstructionFlags.Reachable;
				break;
			default:
				throw new InvalidOperationException();
		}
	}

	internal static UntangledExceptionTable UntangleExceptionBlocks(ClassFile classFile, ClassFile.Method method)
	{
		ClassFile.Method.Instruction[] instructions = method.Instructions;
		ExceptionTableEntry[] exceptionTable = method.ExceptionTable;
		List<ExceptionTableEntry> ar = new List<ExceptionTableEntry>(exceptionTable);

		// This optimization removes the recursive exception handlers that Java compiler place around
		// the exit of a synchronization block to be "safe" in the face of asynchronous exceptions.
		// (see http://weblog.ikvm.net/PermaLink.aspx?guid=3af9548e-4905-4557-8809-65a205ce2cd6)
		// We can safely remove them since the code we generate for this construct isn't async safe anyway,
		// but there is another reason why this optimization may be slightly controversial. In some
		// pathological cases it can cause observable differences, where the Sun JVM would spin in an
		// infinite loop, but we will throw an exception. However, the perf benefit is large enough to
		// warrant this "incompatibility".
		// Note that there is also code in the exception handler handling code that detects these bytecode
		// sequences to try to compile them into a fault block, instead of an exception handler.
		for (int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = ar[i];
			if (ei.startIndex == ei.handlerIndex && ei.catch_type == 0)
			{
				int index = ei.startIndex;
				if (index + 2 < instructions.Length
					&& ei.endIndex == index + 2
					&& instructions[index].NormalizedOpCode == NormalizedByteCode.__aload
					&& instructions[index + 1].NormalizedOpCode == NormalizedByteCode.__monitorexit
					&& instructions[index + 2].NormalizedOpCode == NormalizedByteCode.__athrow)
				{
					// this is the async exception guard that Jikes and the Eclipse Java Compiler produce
					ar.RemoveAt(i);
					i--;
				}
				else if (index + 4 < instructions.Length
					&& ei.endIndex == index + 3
					&& instructions[index].NormalizedOpCode == NormalizedByteCode.__astore
					&& instructions[index + 1].NormalizedOpCode == NormalizedByteCode.__aload
					&& instructions[index + 2].NormalizedOpCode == NormalizedByteCode.__monitorexit
					&& instructions[index + 3].NormalizedOpCode == NormalizedByteCode.__aload
					&& instructions[index + 4].NormalizedOpCode == NormalizedByteCode.__athrow
					&& instructions[index].NormalizedArg1 == instructions[index + 3].NormalizedArg1)
				{
					// this is the async exception guard that javac produces
					ar.RemoveAt(i);
					i--;
				}
				else if (index + 1 < instructions.Length
					&& ei.endIndex == index + 1
					&& instructions[index].NormalizedOpCode == NormalizedByteCode.__astore)
				{
					// this is the finally guard that javac produces
					ar.RemoveAt(i);
					i--;
				}
			}
		}

		// Modern versions of javac split try blocks when the try block contains a return statement.
		// Here we merge these exception blocks again, because it allows us to generate more efficient code.
		for (int i = 0; i < ar.Count - 1; i++)
		{
			if (ar[i].endIndex + 1 == ar[i + 1].startIndex
				&& ar[i].handlerIndex == ar[i + 1].handlerIndex
				&& ar[i].catch_type == ar[i + 1].catch_type
				&& IsReturn(instructions[ar[i].endIndex].NormalizedOpCode))
			{
				ar[i] = new ExceptionTableEntry(ar[i].startIndex, ar[i + 1].endIndex, ar[i].handlerIndex, ar[i].catch_type, ar[i].ordinal);
				ar.RemoveAt(i + 1);
				i--;
			}
		}

	restart:
		for (int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = ar[i];
			for (int j = 0; j < ar.Count; j++)
			{
				ExceptionTableEntry ej = ar[j];
				if (ei.startIndex <= ej.startIndex && ej.startIndex < ei.endIndex)
				{
					// 0006/test.j
					if (ej.endIndex > ei.endIndex)
					{
						ExceptionTableEntry emi = new ExceptionTableEntry(ej.startIndex, ei.endIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
						ExceptionTableEntry emj = new ExceptionTableEntry(ej.startIndex, ei.endIndex, ej.handlerIndex, ej.catch_type, ej.ordinal);
						ei = new ExceptionTableEntry(ei.startIndex, emi.startIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
						ej = new ExceptionTableEntry(emj.endIndex, ej.endIndex, ej.handlerIndex, ej.catch_type, ej.ordinal);
						ar[i] = ei;
						ar[j] = ej;
						ar.Insert(j, emj);
						ar.Insert(i + 1, emi);
						goto restart;
					}
					// 0007/test.j
					else if (j > i && ej.endIndex < ei.endIndex)
					{
						ExceptionTableEntry emi = new ExceptionTableEntry(ej.startIndex, ej.endIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
						ExceptionTableEntry eei = new ExceptionTableEntry(ej.endIndex, ei.endIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
						ei = new ExceptionTableEntry(ei.startIndex, emi.startIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
						ar[i] = ei;
						ar.Insert(i + 1, eei);
						ar.Insert(i + 1, emi);
						goto restart;
					}
				}
			}
		}
	// Split try blocks at branch targets (branches from outside the try block)
	restart_split:
		for (int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = ar[i];
			int start = ei.startIndex;
			int end = ei.endIndex;
			for (int j = 0; j < instructions.Length; j++)
			{
				if (j < start || j >= end)
				{
					switch (instructions[j].NormalizedOpCode)
					{
						case NormalizedByteCode.__tableswitch:
						case NormalizedByteCode.__lookupswitch:
							// start at -1 to have an opportunity to handle the default offset
							for (int k = -1; k < instructions[j].SwitchEntryCount; k++)
							{
								int targetIndex = (k == -1 ? instructions[j].DefaultTarget : instructions[j].GetSwitchTargetIndex(k));
								if (ei.startIndex < targetIndex && targetIndex < ei.endIndex)
								{
									ExceptionTableEntry en = new ExceptionTableEntry(targetIndex, ei.endIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
									ei = new ExceptionTableEntry(ei.startIndex, targetIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
									ar[i] = ei;
									ar.Insert(i + 1, en);
									goto restart_split;
								}
							}
							break;
						case NormalizedByteCode.__ifeq:
						case NormalizedByteCode.__ifne:
						case NormalizedByteCode.__iflt:
						case NormalizedByteCode.__ifge:
						case NormalizedByteCode.__ifgt:
						case NormalizedByteCode.__ifle:
						case NormalizedByteCode.__if_icmpeq:
						case NormalizedByteCode.__if_icmpne:
						case NormalizedByteCode.__if_icmplt:
						case NormalizedByteCode.__if_icmpge:
						case NormalizedByteCode.__if_icmpgt:
						case NormalizedByteCode.__if_icmple:
						case NormalizedByteCode.__if_acmpeq:
						case NormalizedByteCode.__if_acmpne:
						case NormalizedByteCode.__ifnull:
						case NormalizedByteCode.__ifnonnull:
						case NormalizedByteCode.__goto:
							{
								int targetIndex = instructions[j].Arg1;
								if (ei.startIndex < targetIndex && targetIndex < ei.endIndex)
								{
									ExceptionTableEntry en = new ExceptionTableEntry(targetIndex, ei.endIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
									ei = new ExceptionTableEntry(ei.startIndex, targetIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
									ar[i] = ei;
									ar.Insert(i + 1, en);
									goto restart_split;
								}
								break;
							}
					}
				}
			}
		}
		// exception handlers are also a kind of jump, so we need to split try blocks around handlers as well
		for (int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = ar[i];
			for (int j = 0; j < ar.Count; j++)
			{
				ExceptionTableEntry ej = ar[j];
				if (ei.startIndex < ej.handlerIndex && ej.handlerIndex < ei.endIndex)
				{
					ExceptionTableEntry en = new ExceptionTableEntry(ej.handlerIndex, ei.endIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
					ei = new ExceptionTableEntry(ei.startIndex, ej.handlerIndex, ei.handlerIndex, ei.catch_type, ei.ordinal);
					ar[i] = ei;
					ar.Insert(i + 1, en);
					goto restart_split;
				}
			}
		}
		// filter out zero length try blocks
		for (int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = ar[i];
			if (ei.startIndex == ei.endIndex)
			{
				ar.RemoveAt(i);
				i--;
			}
			else
			{
				// exception blocks that only contain harmless instructions (i.e. instructions that will *never* throw an exception)
				// are also filtered out (to improve the quality of the generated code)
				TypeWrapper exceptionType = ei.catch_type == 0 ? CoreClasses.java.lang.Throwable.Wrapper : classFile.GetConstantPoolClassType(ei.catch_type);
				if (exceptionType.IsUnloadable)
				{
					// we can't remove handlers for unloadable types
				}
				else if (java_lang_ThreadDeath.IsAssignableTo(exceptionType))
				{
					// We only remove exception handlers that could catch ThreadDeath in limited cases, because it can be thrown
					// asynchronously (and thus appear on any instruction). This is particularly important to ensure that
					// we run finally blocks when a thread is killed.
					// Note that even so, we aren't remotely async exception safe.
					int start = ei.startIndex;
					int end = ei.endIndex;
					for (int j = start; j < end; j++)
					{
						switch (instructions[j].NormalizedOpCode)
						{
							case NormalizedByteCode.__aload:
							case NormalizedByteCode.__iload:
							case NormalizedByteCode.__lload:
							case NormalizedByteCode.__fload:
							case NormalizedByteCode.__dload:
							case NormalizedByteCode.__astore:
							case NormalizedByteCode.__istore:
							case NormalizedByteCode.__lstore:
							case NormalizedByteCode.__fstore:
							case NormalizedByteCode.__dstore:
								break;
							case NormalizedByteCode.__dup:
							case NormalizedByteCode.__dup_x1:
							case NormalizedByteCode.__dup_x2:
							case NormalizedByteCode.__dup2:
							case NormalizedByteCode.__dup2_x1:
							case NormalizedByteCode.__dup2_x2:
							case NormalizedByteCode.__pop:
							case NormalizedByteCode.__pop2:
								break;
							case NormalizedByteCode.__return:
							case NormalizedByteCode.__areturn:
							case NormalizedByteCode.__ireturn:
							case NormalizedByteCode.__lreturn:
							case NormalizedByteCode.__freturn:
							case NormalizedByteCode.__dreturn:
								break;
							case NormalizedByteCode.__goto:
								// if there is a branch that stays inside the block, we should keep the block
								if (start <= instructions[j].TargetIndex && instructions[j].TargetIndex < end)
									goto next;
								break;
							default:
								goto next;
						}
					}
					ar.RemoveAt(i);
					i--;
				}
				else
				{
					int start = ei.startIndex;
					int end = ei.endIndex;
					for (int j = start; j < end; j++)
					{
						if (ByteCodeMetaData.CanThrowException(instructions[j].NormalizedOpCode))
						{
							goto next;
						}
					}
					ar.RemoveAt(i);
					i--;
				}
			}
		next: ;
		}

		ExceptionTableEntry[] exceptions = ar.ToArray();
		Array.Sort(exceptions, new ExceptionSorter());

		return new UntangledExceptionTable(exceptions);
	}

	private static bool IsReturn(NormalizedByteCode bc)
	{
		return bc == NormalizedByteCode.__return
			|| bc == NormalizedByteCode.__areturn
			|| bc == NormalizedByteCode.__dreturn
			|| bc == NormalizedByteCode.__ireturn
			|| bc == NormalizedByteCode.__freturn
			|| bc == NormalizedByteCode.__lreturn;
	}

	private static bool AnalyzePotentialFaultBlocks(CodeInfo codeInfo, ClassFile.Method method, UntangledExceptionTable exceptions)
	{
		ClassFile.Method.Instruction[] code = method.Instructions;
		bool changed = false;
		bool done = false;
		while (!done)
		{
			done = true;
			Stack<ExceptionTableEntry> stack = new Stack<ExceptionTableEntry>();
			ExceptionTableEntry current = new ExceptionTableEntry(0, code.Length, -1, ushort.MaxValue, -1);
			stack.Push(current);
			for (int i = 0; i < exceptions.Length; i++)
			{
				while (exceptions[i].startIndex >= current.endIndex)
				{
					current = stack.Pop();
				}
				Debug.Assert(exceptions[i].startIndex >= current.startIndex && exceptions[i].endIndex <= current.endIndex);
				if (exceptions[i].catch_type == 0
					&& codeInfo.HasState(exceptions[i].handlerIndex)
					&& VerifierTypeWrapper.IsFaultBlockException(codeInfo.GetRawStackTypeWrapper(exceptions[i].handlerIndex, 0)))
				{
					InstructionFlags[] flags = MethodAnalyzer.ComputePartialReachability(codeInfo, method.Instructions, exceptions, exceptions[i].handlerIndex, true);
					for (int j = 0; j < code.Length; j++)
					{
						if ((flags[j] & InstructionFlags.Reachable) != 0)
						{
							switch (code[j].NormalizedOpCode)
							{
								case NormalizedByteCode.__return:
								case NormalizedByteCode.__areturn:
								case NormalizedByteCode.__ireturn:
								case NormalizedByteCode.__lreturn:
								case NormalizedByteCode.__freturn:
								case NormalizedByteCode.__dreturn:
									goto not_fault_block;
								case NormalizedByteCode.__athrow:
									for (int k = i + 1; k < exceptions.Length; k++)
									{
										if (exceptions[k].startIndex <= j && j < exceptions[k].endIndex)
										{
											goto not_fault_block;
										}
									}
									if (VerifierTypeWrapper.IsFaultBlockException(codeInfo.GetRawStackTypeWrapper(j, 0))
										&& codeInfo.GetRawStackTypeWrapper(j, 0) != codeInfo.GetRawStackTypeWrapper(exceptions[i].handlerIndex, 0))
									{
										goto not_fault_block;
									}
									break;
							}
							if (j < current.startIndex || j >= current.endIndex)
							{
								goto not_fault_block;
							}
							else if (exceptions[i].startIndex <= j && j < exceptions[i].endIndex)
							{
								goto not_fault_block;
							}
							else
							{
								continue;
							}
						not_fault_block:
							VerifierTypeWrapper.ClearFaultBlockException(codeInfo.GetRawStackTypeWrapper(exceptions[i].handlerIndex, 0));
							done = false;
							changed = true;
							break;
						}
					}
				}
				stack.Push(current);
				current = exceptions[i];
			}
		}
		return changed;
	}

	private static void ConvertFinallyBlocks(CodeInfo codeInfo, ClassFile.Method method, UntangledExceptionTable exceptions)
	{
		ClassFile.Method.Instruction[] code = method.Instructions;
		InstructionFlags[] flags = ComputePartialReachability(codeInfo, code, exceptions, 0, false);
		for (int i = 0; i < exceptions.Length; i++)
		{
			if (exceptions[i].catch_type == 0
				&& codeInfo.HasState(exceptions[i].handlerIndex)
				&& VerifierTypeWrapper.IsFaultBlockException(codeInfo.GetRawStackTypeWrapper(exceptions[i].handlerIndex, 0)))
			{
				int exit;
				if (IsSynchronizedBlockHandler(code, exceptions[i].handlerIndex)
					&& exceptions[i].endIndex - 2 >= exceptions[i].startIndex
					&& TryFindSingleTryBlockExit(code, flags, exceptions, new ExceptionTableEntry(exceptions[i].startIndex, exceptions[i].endIndex - 2, exceptions[i].handlerIndex, 0, exceptions[i].ordinal), i, out exit)
					&& exit == exceptions[i].endIndex - 2
					&& (flags[exit + 1] & InstructionFlags.BranchTarget) == 0
					&& MatchInstructions(code, exit, exceptions[i].handlerIndex + 1)
					&& MatchInstructions(code, exit + 1, exceptions[i].handlerIndex + 2)
					&& MatchExceptionCoverage(exceptions, i, exceptions[i].handlerIndex + 1, exceptions[i].handlerIndex + 3, exit, exit + 2)
					&& exceptions[i].handlerIndex <= ushort.MaxValue)
				{
					code[exit].PatchOpCode(NormalizedByteCode.__goto_finally, exceptions[i].endIndex, (short)exceptions[i].handlerIndex);
					exceptions.SetFinally(i);
				}
				else if (TryFindSingleTryBlockExit(code, flags, exceptions, exceptions[i], i, out exit)
					// the stack must be empty
					&& codeInfo.GetStackHeight(exit) == 0
					// the exit code must not be reachable (except from within the try-block),
					// because we're going to patch it to jump around the exit code
					&& !IsReachableFromOutsideTryBlock(codeInfo, code, exceptions, exceptions[i], exit))
				{
					int exitHandlerEnd;
					int faultHandlerEnd;
					if (MatchFinallyBlock(codeInfo, code, exceptions, exceptions[i].handlerIndex, exit, out exitHandlerEnd, out faultHandlerEnd))
					{
						if (exit != exitHandlerEnd
							&& codeInfo.GetStackHeight(exitHandlerEnd) == 0
							&& MatchExceptionCoverage(exceptions, -1, exceptions[i].handlerIndex, faultHandlerEnd, exit, exitHandlerEnd))
						{
							// We use Arg2 (which is a short) to store the handler in the __goto_finally pseudo-opcode,
							// so we can only do that if handlerIndex fits in a short (note that we can use the sign bit too).
							if (exceptions[i].handlerIndex <= ushort.MaxValue)
							{
								code[exit].PatchOpCode(NormalizedByteCode.__goto_finally, exitHandlerEnd, (short)exceptions[i].handlerIndex);
								exceptions.SetFinally(i);
							}
						}
					}
				}
			}
		}
	}

	private static bool IsSynchronizedBlockHandler(ClassFile.Method.Instruction[] code, int index)
	{
		return code[index].NormalizedOpCode == NormalizedByteCode.__astore
			&& code[index + 1].NormalizedOpCode == NormalizedByteCode.__aload
			&& code[index + 2].NormalizedOpCode == NormalizedByteCode.__monitorexit
			&& code[index + 3].NormalizedOpCode == NormalizedByteCode.__aload && code[index + 3].Arg1 == code[index].Arg1
			&& code[index + 4].NormalizedOpCode == NormalizedByteCode.__athrow;
	}

	private static bool MatchExceptionCoverage(UntangledExceptionTable exceptions, int skipException, int startFault, int endFault, int startExit, int endExit)
	{
		for (int j = 0; j < exceptions.Length; j++)
		{
			if (j != skipException && ExceptionCovers(exceptions[j], startFault, endFault) != ExceptionCovers(exceptions[j], startExit, endExit))
			{
				return false;
			}
		}
		return true;
	}

	private static bool ExceptionCovers(ExceptionTableEntry exception, int start, int end)
	{
		return exception.startIndex < end && exception.endIndex > start;
	}

	private static bool MatchFinallyBlock(CodeInfo codeInfo, ClassFile.Method.Instruction[] code, UntangledExceptionTable exceptions, int faultHandler, int exitHandler, out int exitHandlerEnd, out int faultHandlerEnd)
	{
		exitHandlerEnd = -1;
		faultHandlerEnd = -1;
		if (code[faultHandler].NormalizedOpCode != NormalizedByteCode.__astore)
		{
			return false;
		}
		int startFault = faultHandler;
		int faultLocal = code[faultHandler++].NormalizedArg1;
		for (; ; )
		{
			if (code[faultHandler].NormalizedOpCode == NormalizedByteCode.__aload
				&& code[faultHandler].NormalizedArg1 == faultLocal
				&& code[faultHandler + 1].NormalizedOpCode == NormalizedByteCode.__athrow)
			{
				// make sure that instructions that we haven't covered aren't reachable
				InstructionFlags[] flags = ComputePartialReachability(codeInfo, code, exceptions, startFault, false);
				for (int i = 0; i < flags.Length; i++)
				{
					if ((i < startFault || i > faultHandler + 1) && (flags[i] & InstructionFlags.Reachable) != 0)
					{
						return false;
					}
				}
				exitHandlerEnd = exitHandler;
				faultHandlerEnd = faultHandler;
				return true;
			}
			if (!MatchInstructions(code, faultHandler, exitHandler))
			{
				return false;
			}
			faultHandler++;
			exitHandler++;
		}
	}

	private static bool MatchInstructions(ClassFile.Method.Instruction[] code, int i, int j)
	{
		if (code[i].NormalizedOpCode != code[j].NormalizedOpCode)
		{
			return false;
		}
		switch (ByteCodeMetaData.GetFlowControl(code[i].NormalizedOpCode))
		{
			case ByteCodeFlowControl.Branch:
			case ByteCodeFlowControl.CondBranch:
				if (code[i].Arg1 - i != code[j].Arg1 - j)
				{
					return false;
				}
				break;
			case ByteCodeFlowControl.Switch:
				if (code[i].SwitchEntryCount != code[j].SwitchEntryCount)
				{
					return false;
				}
				for (int k = 0; k < code[i].SwitchEntryCount; k++)
				{
					if (code[i].GetSwitchTargetIndex(k) != code[j].GetSwitchTargetIndex(k))
					{
						return false;
					}
				}
				if (code[i].DefaultTarget != code[j].DefaultTarget)
				{
					return false;
				}
				break;
			default:
				if (code[i].Arg1 != code[j].Arg1)
				{
					return false;
				}
				if (code[i].Arg2 != code[j].Arg2)
				{
					return false;
				}
				break;
		}
		return true;
	}

	private static bool IsReachableFromOutsideTryBlock(CodeInfo codeInfo, ClassFile.Method.Instruction[] code, UntangledExceptionTable exceptions, ExceptionTableEntry tryBlock, int instructionIndex)
	{
		InstructionFlags[] flags = new InstructionFlags[code.Length];
		flags[0] |= InstructionFlags.Reachable;
		// We mark the first instruction of the try-block as already processed, so that UpdatePartialReachability will skip the try-block.
		// Note that we can do this, because it is not possible to jump into the middle of a try-block (after the exceptions have been untangled).
		flags[tryBlock.startIndex] = InstructionFlags.Processed;
		// We mark the successor instructions of the instruction we're examinining as reachable,
		// to figure out if the code following the handler somehow branches back to it.
		MarkSuccessors(code, flags, instructionIndex);
		UpdatePartialReachability(flags, codeInfo, code, exceptions, false);
		return (flags[instructionIndex] & InstructionFlags.Reachable) != 0;
	}

	private static bool TryFindSingleTryBlockExit(ClassFile.Method.Instruction[] code, InstructionFlags[] flags, UntangledExceptionTable exceptions, ExceptionTableEntry exception, int exceptionIndex, out int exit)
	{
		exit = -1;
		bool fail = false;
		bool nextIsReachable = false;
		for (int i = exception.startIndex; !fail && i < exception.endIndex; i++)
		{
			if ((flags[i] & InstructionFlags.Reachable) != 0)
			{
				nextIsReachable = false;
				for (int j = 0; j < exceptions.Length; j++)
				{
					if (j != exceptionIndex && exceptions[j].startIndex >= exception.startIndex && exception.endIndex <= exceptions[j].endIndex)
					{
						UpdateTryBlockExit(exception, exceptions[j].handlerIndex, ref exit, ref fail);
					}
				}
				switch (ByteCodeMetaData.GetFlowControl(code[i].NormalizedOpCode))
				{
					case ByteCodeFlowControl.Switch:
						{
							for (int j = 0; j < code[i].SwitchEntryCount; j++)
							{
								UpdateTryBlockExit(exception, code[i].GetSwitchTargetIndex(j), ref exit, ref fail);
							}
							UpdateTryBlockExit(exception, code[i].DefaultTarget, ref exit, ref fail);
							break;
						}
					case ByteCodeFlowControl.Branch:
						UpdateTryBlockExit(exception, code[i].TargetIndex, ref exit, ref fail);
						break;
					case ByteCodeFlowControl.CondBranch:
						UpdateTryBlockExit(exception, code[i].TargetIndex, ref exit, ref fail);
						nextIsReachable = true;
						break;
					case ByteCodeFlowControl.Return:
						fail = true;
						break;
					case ByteCodeFlowControl.Throw:
						break;
					case ByteCodeFlowControl.Next:
						nextIsReachable = true;
						break;
					default:
						throw new InvalidOperationException();
				}
			}
		}
		if (nextIsReachable)
		{
			UpdateTryBlockExit(exception, exception.endIndex, ref exit, ref fail);
		}
		return !fail && exit != -1;
	}

	private static void UpdateTryBlockExit(ExceptionTableEntry exception, int targetIndex, ref int exitIndex, ref bool fail)
	{
		if (exception.startIndex <= targetIndex && targetIndex < exception.endIndex)
		{
			// branch stays inside try block
		}
		else if (exitIndex == -1)
		{
			exitIndex = targetIndex;
		}
		else if (exitIndex != targetIndex)
		{
			fail = true;
		}
	}

	private void ConditionalPatchNoClassDefFoundError(ref ClassFile.Method.Instruction instruction, TypeWrapper tw)
	{
		ClassLoaderWrapper loader = wrapper.GetClassLoader();
		if (loader.DisableDynamicBinding)
		{
			SetHardError(loader, ref instruction, HardError.NoClassDefFoundError, "{0}", tw.Name);
		}
	}

	private void SetHardError(ClassLoaderWrapper classLoader, ref ClassFile.Method.Instruction instruction, HardError hardError, string message, params object[] args)
	{
		string text = string.Format(message, args);
#if STATIC_COMPILER
		Message msg;
		switch (hardError)
		{
			case HardError.NoClassDefFoundError:
				msg = Message.EmittedNoClassDefFoundError;
				break;
			case HardError.IllegalAccessError:
				msg = Message.EmittedIllegalAccessError;
				break;
			case HardError.InstantiationError:
				msg = Message.EmittedIllegalAccessError;
				break;
			case HardError.IncompatibleClassChangeError:
			case HardError.IllegalAccessException:
				msg = Message.EmittedIncompatibleClassChangeError;
				break;
			case HardError.NoSuchFieldError:
				msg = Message.EmittedNoSuchFieldError;
				break;
			case HardError.AbstractMethodError:
				msg = Message.EmittedAbstractMethodError;
				break;
			case HardError.NoSuchMethodError:
				msg = Message.EmittedNoSuchMethodError;
				break;
			case HardError.LinkageError:
				msg = Message.EmittedLinkageError;
				break;
			default:
				throw new InvalidOperationException();
		}
		classLoader.IssueMessage(msg, classFile.Name + "." + method.Name + method.Signature, text);
#endif
		instruction.SetHardError(hardError, AllocErrorMessage(text));
	}

	private void PatchInvoke(TypeWrapper wrapper, ref ClassFile.Method.Instruction instr, StackState stack)
	{
		ClassFile.ConstantPoolItemMI cpi = GetMethodref(instr.Arg1);
		NormalizedByteCode invoke = instr.NormalizedOpCode;
		bool isnew = false;
		TypeWrapper thisType;
		if (invoke == NormalizedByteCode.__invokevirtual
			&& cpi.Class == "java.lang.invoke.MethodHandle"
			&& (cpi.Name == "invoke" || cpi.Name == "invokeExact" || cpi.Name == "invokeBasic"))
		{
			if (cpi.GetArgTypes().Length > 127 && MethodHandleUtil.SlotCount(cpi.GetArgTypes()) > 254)
			{
				instr.SetHardError(HardError.LinkageError, AllocErrorMessage("bad parameter count"));
				return;
			}
			instr.PatchOpCode(NormalizedByteCode.__methodhandle_invoke);
			return;
		}
		else if (invoke == NormalizedByteCode.__invokestatic
			&& cpi.Class == "java.lang.invoke.MethodHandle"
			&& (cpi.Name == "linkToVirtual" || cpi.Name == "linkToStatic" || cpi.Name == "linkToSpecial" || cpi.Name == "linkToInterface")
			&& CoreClasses.java.lang.invoke.MethodHandle.Wrapper.IsPackageAccessibleFrom(wrapper))
		{
			instr.PatchOpCode(NormalizedByteCode.__methodhandle_link);
			return;
		}
		else if (invoke == NormalizedByteCode.__invokestatic)
		{
			thisType = null;
		}
		else
		{
			TypeWrapper[] args = cpi.GetArgTypes();
			for (int j = args.Length - 1; j >= 0; j--)
			{
				stack.PopType(args[j]);
			}
			thisType = SigTypeToClassName(stack.PeekType(), cpi.GetClassType(), wrapper);
			if(ReferenceEquals(cpi.Name, StringConstants.INIT))
			{
				TypeWrapper type = stack.PopType();
				isnew = VerifierTypeWrapper.IsNew(type);
			}
		}

		if(cpi.GetClassType().IsUnloadable)
		{
			if(wrapper.GetClassLoader().DisableDynamicBinding)
			{
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.NoClassDefFoundError, "{0}", cpi.GetClassType().Name);
			}
			else
			{
				switch(invoke)
				{
					case NormalizedByteCode.__invokeinterface:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_invokeinterface);
						break;
					case NormalizedByteCode.__invokestatic:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_invokestatic);
						break;
					case NormalizedByteCode.__invokevirtual:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_invokevirtual);
						break;
					case NormalizedByteCode.__invokespecial:
						if(isnew)
						{
							instr.PatchOpCode(NormalizedByteCode.__dynamic_invokespecial);
						}
						else
						{
							throw new VerifyError("Invokespecial cannot call subclass methods");
						}
						break;
					default:
						throw new InvalidOperationException();
				}
			}
		}
		else if(invoke == NormalizedByteCode.__invokeinterface && !cpi.GetClassType().IsInterface)
		{
			SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IncompatibleClassChangeError, "invokeinterface on non-interface");
		}
		else if(cpi.GetClassType().IsInterface && invoke != NormalizedByteCode.__invokeinterface && ((invoke != NormalizedByteCode.__invokestatic && invoke != NormalizedByteCode.__invokespecial) || classFile.MajorVersion < 52))
		{
			SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IncompatibleClassChangeError,
				classFile.MajorVersion < 52
					? "interface method must be invoked using invokeinterface"
					: "interface method must be invoked using invokeinterface, invokespecial or invokestatic");
		}
		else
		{
			MethodWrapper targetMethod = invoke == NormalizedByteCode.__invokespecial ? cpi.GetMethodForInvokespecial() : cpi.GetMethod();
			if(targetMethod != null)
			{
				string errmsg = CheckLoaderConstraints(cpi, targetMethod);
				if(errmsg != null)
				{
					SetHardError(wrapper.GetClassLoader(), ref instr, HardError.LinkageError, "{0}", errmsg);
				}
				else if(targetMethod.IsStatic == (invoke == NormalizedByteCode.__invokestatic))
				{
					if(targetMethod.IsAbstract && invoke == NormalizedByteCode.__invokespecial && (targetMethod.GetMethod() == null || targetMethod.GetMethod().IsAbstract))
					{
						SetHardError(wrapper.GetClassLoader(), ref instr, HardError.AbstractMethodError, "{0}.{1}{2}", cpi.Class, cpi.Name, cpi.Signature);
					}
					else if(invoke == NormalizedByteCode.__invokeinterface && targetMethod.IsPrivate)
					{
						SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IncompatibleClassChangeError, "private interface method requires invokespecial, not invokeinterface: method {0}.{1}{2}", cpi.Class, cpi.Name, cpi.Signature);
					}
					else if(targetMethod.IsAccessibleFrom(cpi.GetClassType(), wrapper, thisType))
					{
						return;
					}
					else if(host != null && targetMethod.IsAccessibleFrom(cpi.GetClassType(), host, thisType))
					{
						switch (invoke)
						{
							case NormalizedByteCode.__invokespecial:
								instr.PatchOpCode(NormalizedByteCode.__privileged_invokespecial);
								break;
							case NormalizedByteCode.__invokestatic:
								instr.PatchOpCode(NormalizedByteCode.__privileged_invokestatic);
								break;
							case NormalizedByteCode.__invokevirtual:
								instr.PatchOpCode(NormalizedByteCode.__privileged_invokevirtual);
								break;
							default:
								throw new InvalidOperationException();
						}
						return;
					}
					else
					{
						// NOTE special case for incorrect invocation of Object.clone(), because this could mean
						// we're calling clone() on an array
						// (bug in javac, see http://developer.java.sun.com/developer/bugParade/bugs/4329886.html)
						if(cpi.GetClassType() == CoreClasses.java.lang.Object.Wrapper
							&& thisType.IsArray
							&& ReferenceEquals(cpi.Name, StringConstants.CLONE))
						{
							// Patch the instruction, so that the compiler doesn't need to do this test again.
							instr.PatchOpCode(NormalizedByteCode.__clone_array);
							return;
						}
						SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IllegalAccessError, "tried to access method {0}.{1}{2} from class {3}", ToSlash(targetMethod.DeclaringType.Name), cpi.Name, ToSlash(cpi.Signature), ToSlash(wrapper.Name));
					}
				}
				else
				{
					SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IncompatibleClassChangeError, "static call to non-static method (or v.v.)");
				}
			}
			else
			{
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.NoSuchMethodError, "{0}.{1}{2}", cpi.Class, cpi.Name, cpi.Signature);
			}
		}
	}

	private static string ToSlash(string str)
	{
		return str.Replace('.', '/');
	}

	private void PatchFieldAccess(TypeWrapper wrapper, MethodWrapper mw, ref ClassFile.Method.Instruction instr, StackState stack)
	{
		ClassFile.ConstantPoolItemFieldref cpi = classFile.GetFieldref(instr.Arg1);
		bool isStatic;
		bool write;
		TypeWrapper thisType;
		switch(instr.NormalizedOpCode)
		{
			case NormalizedByteCode.__getfield:
				isStatic = false;
				write = false;
				thisType = SigTypeToClassName(stack.PopObjectType(GetFieldref(instr.Arg1).GetClassType()), cpi.GetClassType(), wrapper);
				break;
			case NormalizedByteCode.__putfield:
				stack.PopType(GetFieldref(instr.Arg1).GetFieldType());
				isStatic = false;
				write = true;
				// putfield is allowed to access the unintialized this
				if(stack.PeekType() == VerifierTypeWrapper.UninitializedThis
					&& wrapper.IsAssignableTo(GetFieldref(instr.Arg1).GetClassType()))
				{
					thisType = wrapper;
				}
				else
				{
					thisType = SigTypeToClassName(stack.PopObjectType(GetFieldref(instr.Arg1).GetClassType()), cpi.GetClassType(), wrapper);
				}
				break;
			case NormalizedByteCode.__getstatic:
				isStatic = true;
				write = false;
				thisType = null;
				break;
			case NormalizedByteCode.__putstatic:
				// special support for when we're being called from IsSideEffectFreeStaticInitializer
				if(mw == null)
				{
					switch(GetFieldref(instr.Arg1).Signature[0])
					{
						case 'B':
						case 'Z':
						case 'C':
						case 'S':
						case 'I':
							stack.PopInt();
							break;
						case 'F':
							stack.PopFloat();
							break;
						case 'D':
							stack.PopDouble();
							break;
						case 'J':
							stack.PopLong();
							break;
						case 'L':
						case '[':
							if(stack.PopAnyType() != VerifierTypeWrapper.Null)
							{
								throw new VerifyError();
							}
							break;
						default:
							throw new InvalidOperationException();
					}
				}
				else
				{
					stack.PopType(GetFieldref(instr.Arg1).GetFieldType());
				}
				isStatic = true;
				write = true;
				thisType = null;
				break;
			default:
				throw new InvalidOperationException();
		}
		if(mw == null)
		{
			// We're being called from IsSideEffectFreeStaticInitializer,
			// no further checks are possible (nor needed).
		}
		else if(cpi.GetClassType().IsUnloadable)
		{
			if(wrapper.GetClassLoader().DisableDynamicBinding)
			{
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.NoClassDefFoundError, "{0}", cpi.GetClassType().Name);
			}
			else
			{
				switch(instr.NormalizedOpCode)
				{
					case NormalizedByteCode.__getstatic:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_getstatic);
						break;
					case NormalizedByteCode.__putstatic:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_putstatic);
						break;
					case NormalizedByteCode.__getfield:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_getfield);
						break;
					case NormalizedByteCode.__putfield:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_putfield);
						break;
					default:
						throw new InvalidOperationException();
				}
			}
			return;
		}
		else
		{
			FieldWrapper field = cpi.GetField();
			if(field == null)
			{
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.NoSuchFieldError, "{0}.{1}", cpi.Class, cpi.Name);
				return;
			}
			if(cpi.GetFieldType() != field.FieldTypeWrapper && !cpi.GetFieldType().IsUnloadable & !field.FieldTypeWrapper.IsUnloadable)
			{
#if STATIC_COMPILER
				StaticCompiler.LinkageError("Field \"{2}.{3}\" is of type \"{0}\" instead of type \"{1}\" as expected by \"{4}\"", field.FieldTypeWrapper, cpi.GetFieldType(), cpi.GetClassType().Name, cpi.Name, wrapper.Name);
#endif
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.LinkageError, "Loader constraints violated: {0}.{1}", field.DeclaringType.Name, field.Name);
				return;
			}
			if(field.IsStatic != isStatic)
			{
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IncompatibleClassChangeError, "Static field access to non-static field (or v.v.)");
				return;
			}
			if(!field.IsAccessibleFrom(cpi.GetClassType(), wrapper, thisType))
			{
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IllegalAccessError, "Try to access field {0}.{1} from class {2}", field.DeclaringType.Name, field.Name, wrapper.Name);
				return;
			}
			// are we trying to mutate a final field? (they are read-only from outside of the defining class)
			if(write && field.IsFinal
				&& ((isStatic ? wrapper != cpi.GetClassType() : wrapper != thisType) || (wrapper.GetClassLoader().StrictFinalFieldSemantics && (isStatic ? (mw != null && mw.Name != "<clinit>") : (mw == null || mw.Name != "<init>")))))
			{
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IllegalAccessError, "Field {0}.{1} is final", field.DeclaringType.Name, field.Name);
				return;
			}
		}
	}

	// TODO this method should have a better name
	private TypeWrapper SigTypeToClassName(TypeWrapper type, TypeWrapper nullType, TypeWrapper wrapper)
	{
		if(type == VerifierTypeWrapper.UninitializedThis)
		{
			return wrapper;
		}
		else if(VerifierTypeWrapper.IsNew(type))
		{
			return ((VerifierTypeWrapper)type).UnderlyingType;
		}
		else if(type == VerifierTypeWrapper.Null)
		{
			return nullType;
		}
		else
		{
			return type;
		}
	}

	private int AllocErrorMessage(string message)
	{
		if(errorMessages == null)
		{
			errorMessages = new List<string>();
		}
		int index = errorMessages.Count;
		errorMessages.Add(message);
		return index;
	}

	private string CheckLoaderConstraints(ClassFile.ConstantPoolItemMI cpi, MethodWrapper mw)
	{
		if(cpi.GetRetType() != mw.ReturnType && !cpi.GetRetType().IsUnloadable && !mw.ReturnType.IsUnloadable)
		{
#if STATIC_COMPILER
			StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has a return type \"{0}\" instead of type \"{1}\" as expected by \"{5}\"", mw.ReturnType, cpi.GetRetType(), cpi.GetClassType().Name, cpi.Name, cpi.Signature, classFile.Name);
#endif
			return "Loader constraints violated (return type): " + mw.DeclaringType.Name + "." + mw.Name + mw.Signature;
		}
		TypeWrapper[] here = cpi.GetArgTypes();
		TypeWrapper[] there = mw.GetParameters();
		for(int i = 0; i < here.Length; i++)
		{
			if(here[i] != there[i] && !here[i].IsUnloadable && !there[i].IsUnloadable)
			{
#if STATIC_COMPILER
				StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has a argument type \"{0}\" instead of type \"{1}\" as expected by \"{5}\"", there[i], here[i], cpi.GetClassType().Name, cpi.Name, cpi.Signature, classFile.Name);
#endif
				return "Loader constraints violated (arg " + i + "): " + mw.DeclaringType.Name + "." + mw.Name + mw.Signature;
			}
		}
		return null;
	}

	private ClassFile.ConstantPoolItemInvokeDynamic GetInvokeDynamic(int index)
	{
		try
		{
			ClassFile.ConstantPoolItemInvokeDynamic item = classFile.GetInvokeDynamic(index);
			if(item != null)
			{
				return item;
			}
		}
		catch(InvalidCastException)
		{
		}
		catch(IndexOutOfRangeException)
		{
		}
		throw new VerifyError("Illegal constant pool index");
	}

	private ClassFile.ConstantPoolItemMI GetMethodref(int index)
	{
		try
		{
			ClassFile.ConstantPoolItemMI item = classFile.GetMethodref(index);
			if(item != null)
			{
				return item;
			}
		}
		catch(InvalidCastException)
		{
		}
		catch(IndexOutOfRangeException)
		{
		}
		throw new VerifyError("Illegal constant pool index");
	}

	private ClassFile.ConstantPoolItemFieldref GetFieldref(int index)
	{
		try
		{
			ClassFile.ConstantPoolItemFieldref item = classFile.GetFieldref(index);
			if(item != null)
			{
				return item;
			}
		}
		catch(InvalidCastException)
		{
		}
		catch(IndexOutOfRangeException)
		{
		}
		throw new VerifyError("Illegal constant pool index");
	}

	private ClassFile.ConstantType GetConstantPoolConstantType(int index)
	{
		try
		{
			return classFile.GetConstantPoolConstantType(index);
		}
		catch(IndexOutOfRangeException)
		{
			// constant pool index out of range
		}
		catch(InvalidOperationException)
		{
			// specified constant pool entry doesn't contain a constant
		}
		catch(NullReferenceException)
		{
			// specified constant pool entry is empty (entry 0 or the filler following a wide entry)
		}
		throw new VerifyError("Illegal constant pool index");
	}

	private TypeWrapper GetConstantPoolClassType(int index)
	{
		try
		{
			return classFile.GetConstantPoolClassType(index);
		}
		catch(InvalidCastException)
		{
		}
		catch(IndexOutOfRangeException)
		{
		}
		catch(NullReferenceException)
		{
		}
		throw new VerifyError("Illegal constant pool index");
	}

	internal void ClearFaultBlockException(int instructionIndex)
	{
		Debug.Assert(state[instructionIndex].GetStackHeight() == 1);
		state[instructionIndex].ClearFaultBlockException();
	}

	private static void DumpMethod(CodeInfo codeInfo, ClassFile.Method method, UntangledExceptionTable exceptions)
	{
		ClassFile.Method.Instruction[] code = method.Instructions;
		InstructionFlags[] flags = ComputePartialReachability(codeInfo, code, exceptions, 0, false);
		for (int i = 0; i < code.Length; i++)
		{
			bool label = (flags[i] & InstructionFlags.BranchTarget) != 0;
			if (!label)
			{
				for (int j = 0; j < exceptions.Length; j++)
				{
					if (exceptions[j].startIndex == i
						|| exceptions[j].endIndex == i
						|| exceptions[j].handlerIndex == i)
					{
						label = true;
						break;
					}
				}
			}
			if (label)
			{
				Console.WriteLine("label{0}:", i);
			}
			if ((flags[i] & InstructionFlags.Reachable) != 0)
			{
				Console.Write("  {1}", i, code[i].NormalizedOpCode.ToString().Substring(2));
				switch (ByteCodeMetaData.GetFlowControl(code[i].NormalizedOpCode))
				{
					case ByteCodeFlowControl.Branch:
					case ByteCodeFlowControl.CondBranch:
						Console.Write(" label{0}", code[i].Arg1);
						break;
				}
				switch (code[i].NormalizedOpCode)
				{
					case NormalizedByteCode.__iload:
					case NormalizedByteCode.__lload:
					case NormalizedByteCode.__fload:
					case NormalizedByteCode.__dload:
					case NormalizedByteCode.__aload:
					case NormalizedByteCode.__istore:
					case NormalizedByteCode.__lstore:
					case NormalizedByteCode.__fstore:
					case NormalizedByteCode.__dstore:
					case NormalizedByteCode.__astore:
					case NormalizedByteCode.__iconst:
						Console.Write(" {0}", code[i].Arg1);
						break;
					case NormalizedByteCode.__ldc:
					case NormalizedByteCode.__ldc_nothrow:
					case NormalizedByteCode.__getfield:
					case NormalizedByteCode.__getstatic:
					case NormalizedByteCode.__putfield:
					case NormalizedByteCode.__putstatic:
					case NormalizedByteCode.__invokeinterface:
					case NormalizedByteCode.__invokespecial:
					case NormalizedByteCode.__invokestatic:
					case NormalizedByteCode.__invokevirtual:
					case NormalizedByteCode.__new:
						Console.Write(" #{0}", code[i].Arg1);
						break;
				}
				Console.WriteLine();
			}
		}
		for (int i = 0; i < exceptions.Length; i++)
		{
			Console.WriteLine(".catch #{0} from label{1} to label{2} using label{3}", exceptions[i].catch_type, exceptions[i].startIndex, exceptions[i].endIndex, exceptions[i].handlerIndex);
		}
	}
}
@


1.125
log
@Bug fix. Verifier would incorrectly report a loader constraints violated if a field type was not unloadable, but the field ref type was unloadable.
@
text
@d2575 3
a2577 13
			FieldWrapper assertionsDisabled = null;
			foreach (FieldWrapper fw in wrapper.GetFields())
			{
				// HACK we assume that all compilers use the same name for this field (ecj and javac do)
				if (fw.Name == "$assertionsDisabled" && fw.Signature == "Z"
					&& (fw.Modifiers & (IKVM.Attributes.Modifiers.AccessMask | IKVM.Attributes.Modifiers.Final | IKVM.Attributes.Modifiers.Static | IKVM.Attributes.Modifiers.Synthetic))
						== (IKVM.Attributes.Modifiers.Static | IKVM.Attributes.Modifiers.Final | IKVM.Attributes.Modifiers.Synthetic))
				{
					assertionsDisabled = fw;
					break;
				}
			}
			if (assertionsDisabled != null)
d2589 2
a2590 2
						ClassFile.ConstantPoolItemFieldref cpi = classFile.GetFieldref(instructions[i].Arg1);
						if (cpi.GetField() == assertionsDisabled)
d2592 1
a2592 3
							// We've found an assertion. We patch the instruction to branch around it so that
							// the assertion code will be unreachable (and hence optimized away).
							// Note that the goto will be optimized away later by the code generator (which removes unnecessary branches).
@


1.124
log
@Bug fix. Verifier should disallow using invokeinterface on private methods.
@
text
@d3876 1
a3876 1
			if(cpi.GetFieldType() != field.FieldTypeWrapper && !field.FieldTypeWrapper.IsUnloadable)
@


1.123
log
@Updated ldc <methodhandle> error behavior to match Java 8.
@
text
@d3699 4
@


1.122
log
@Changed IllegalAccessError message (for methods) to match JDK 8.
@
text
@d2775 2
a2776 2
					err = HardError.NoSuchFieldException;
					msg = "no such field: {0}.{1}{2}";
d2779 2
a2780 2
					err = HardError.NoSuchMethodException;
					msg = "no such method: {0}.{1}{2}";
d2793 1
a2793 1
				SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IllegalAccessException, "member is private: {0}.{1}/{2}, from {3}", cpi.Class, cpi.Name, SigToString(cpi.Signature), wrapper.Name);
a3569 1
			case HardError.NoSuchFieldException:
a3570 1
			case HardError.NoSuchMethodException:
@


1.121
log
@Allow classes defined by Unsafe.defineAnonymousClass() access to private methods of their host class.
@
text
@d3736 1
a3736 1
						SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IllegalAccessError, "Try to access method {0}.{1}{2} from class {3}", targetMethod.DeclaringType.Name, cpi.Name, cpi.Signature, wrapper.Name);
d3751 5
@


1.120
log
@invokespecial on interface method can only refer to directly implemented interfaces (or the interface itself).
@
text
@d1163 1
d1188 1
a1188 1
	internal MethodAnalyzer(TypeWrapper wrapper, MethodWrapper mw, ClassFile classFile, ClassFile.Method method, ClassLoaderWrapper classLoader)
d1195 1
d1678 3
d2424 5
a2428 1
				if (cpi.GetClassType() != wrapper && Array.IndexOf(wrapper.Interfaces, cpi.GetClassType()) == -1)
d2506 13
a2518 1
						if (!VerifierTypeWrapper.IsNullOrUnloadable(refType) && !refType.IsSubTypeOf(wrapper))
d2522 13
a2534 1
						if (!targetType.IsUnloadable && !wrapper.IsSubTypeOf(targetType))
d3705 18
@


1.119
log
@Allow invokespecial to be used to invoke (Java 8) interface instance methods.
@
text
@d2416 8
@


1.118
log
@Integrated OpenJDK 7u40 JSR-292 implementation (aka LambdaForms).
@
text
@d2413 1
a2413 1
		if (invoke == NormalizedByteCode.__invokestatic && classFile.MajorVersion >= 52)
d2415 1
a2415 1
			// invokestatic may be used to invoke interface methods in Java 8
d3637 1
a3637 1
		else if(cpi.GetClassType().IsInterface && invoke != NormalizedByteCode.__invokeinterface && (invoke != NormalizedByteCode.__invokestatic || classFile.MajorVersion < 52))
d3639 4
a3642 1
			SetHardError(wrapper.GetClassLoader(), ref instr, HardError.IncompatibleClassChangeError, "interface method must be invoked used invokeinterface or invokestatic");
@


1.117
log
@Use the same internal bytecode for MethodHandle.invoke() and invokeExact().
@
text
@d1677 1
d3560 3
a3562 1
		if(invoke == NormalizedByteCode.__invokestatic)
d3564 7
a3570 1
			thisType = null;
d3572 1
a3572 1
		else if (invoke == NormalizedByteCode.__invokevirtual
d3574 2
a3575 1
			&& (cpi.Name == "invoke" || cpi.Name == "invokeExact"))
d3577 1
a3577 1
			instr.PatchOpCode(NormalizedByteCode.__methodhandle_invoke);
d3580 4
@


1.116
log
@Added Unsafe.defineAnonymousClass().
@
text
@a1676 1
							case NormalizedByteCode.__methodhandle_invokeexact:
d3567 1
a3567 8
			if (cpi.Name == "invoke")
			{
				instr.PatchOpCode(NormalizedByteCode.__methodhandle_invoke);
			}
			else
			{
				instr.PatchOpCode(NormalizedByteCode.__methodhandle_invokeexact);
			}
@


1.115
log
@Bug fix. MethodHandle.invoke[Exact] does not require a version 51 class file.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
d1279 1
d1644 3
@


1.114
log
@Improved handling of missing types (from missing assemblies in ikvmc).
@
text
@a3560 1
			&& classFile.MajorVersion >= 51
@


1.113
log
@Improved handling of missing types (from missing assemblies in ikvmc).
@
text
@d776 1
a776 1
		else if(type.IsUnloadable || baseType.IsUnloadable)
d780 1
a780 1
		else if(type.IsAssignableTo(baseType))
d784 1
a784 1
		else if(baseType.IsInterfaceOrInterfaceArray)
d790 8
d801 15
@


1.112
log
@Rewrote InstructionState.PopTypeImpl() to be actually understandable.
@
text
@d392 5
a396 1
		TypeWrapper type = null;
d409 13
@


1.111
log
@Deduplicate code between InstructionState and StackState.
@
text
@d743 1
a743 3
		if(type != baseType &&
			!((type.IsUnloadable && !baseType.IsPrimitive) || (baseType.IsUnloadable && !type.IsPrimitive) ||
				type.IsAssignableTo(baseType)))
d745 25
a769 1
			// HACK because of the way interfaces references works, if baseType
d771 1
a771 13
			if((baseType.IsUnloadable || baseType.IsInterfaceOrInterfaceArray) && !type.IsPrimitive)
			{
				return type;
			}
			if(type == VerifierTypeWrapper.ExtendedDouble && baseType == PrimitiveTypeWrapper.DOUBLE)
			{
				return type;
			}
			if(type == VerifierTypeWrapper.ExtendedFloat && baseType == PrimitiveTypeWrapper.FLOAT)
			{
				return type;
			}
			throw new VerifyError("Unexpected type " + type.Name + " where " + baseType.Name + " was expected");
d773 1
a773 1
		return type;
@


1.110
log
@Fix for bug #282. A potential fault block can't throw an exception from another fault block.
@
text
@d565 6
a570 1
		if(PopAnyType() != PrimitiveTypeWrapper.INT)
d579 6
a588 1
		return tw == VerifierTypeWrapper.ExtendedFloat;
d594 6
a603 1
		return tw == VerifierTypeWrapper.ExtendedDouble;
d608 6
a613 1
		if(PopAnyType() != PrimitiveTypeWrapper.LONG)
d621 5
a625 1
		TypeWrapper type = PopAnyType();
d636 5
a640 1
		TypeWrapper type = PopType();
d651 5
a655 1
		TypeWrapper type = PopObjectType();
d713 5
a717 1
		TypeWrapper type = PopAnyType();
d730 5
a738 1
		TypeWrapper type = PopAnyType();
d932 1
a932 30
		if(baseType.IsIntOnStackPrimitive)
		{
			baseType = PrimitiveTypeWrapper.INT;
		}
		TypeWrapper type = PopAnyType();
		if(VerifierTypeWrapper.IsNew(type) || type == VerifierTypeWrapper.UninitializedThis)
		{
			throw new VerifyError("Expecting to find object/array on stack");
		}
		if(type != baseType &&
			!((type.IsUnloadable && !baseType.IsPrimitive) || (baseType.IsUnloadable && !type.IsPrimitive) ||
			type.IsAssignableTo(baseType)))
		{
			// HACK because of the way interfaces references works, if baseType
			// is an interface or array of interfaces, any reference will be accepted
			if((baseType.IsUnloadable || baseType.IsInterfaceOrInterfaceArray) && !type.IsPrimitive)
			{
				return type;
			}
			if(type == VerifierTypeWrapper.ExtendedDouble && baseType == PrimitiveTypeWrapper.DOUBLE)
			{
				return type;
			}
			if(type == VerifierTypeWrapper.ExtendedFloat && baseType == PrimitiveTypeWrapper.FLOAT)
			{
				return type;
			}
			throw new VerifyError("Unexpected type " + type.Name + " where " + baseType.Name + " was expected");
		}
		return type;
d938 1
a938 6
		TypeWrapper type = PopAnyType();
		if(type.IsWidePrimitive || type == VerifierTypeWrapper.ExtendedDouble)
		{
			throw new VerifyError("Attempt to split long or double on the stack");
		}
		return type;
d943 1
a943 4
		if(PopAnyType() != PrimitiveTypeWrapper.INT)
		{
			throw new VerifyError("Int expected on stack");
		}
d948 1
a948 5
		TypeWrapper tw = PopAnyType();
		if(tw != PrimitiveTypeWrapper.FLOAT && tw != VerifierTypeWrapper.ExtendedFloat)
		{
			throw new VerifyError("Float expected on stack");
		}
d953 1
a953 5
		TypeWrapper tw = PopAnyType();
		if(tw != PrimitiveTypeWrapper.DOUBLE && tw != VerifierTypeWrapper.ExtendedDouble)
		{
			throw new VerifyError("Double expected on stack");
		}
d958 1
a958 4
		if(PopAnyType() != PrimitiveTypeWrapper.LONG)
		{
			throw new VerifyError("Long expected on stack");
		}
d963 1
a963 6
		TypeWrapper type = PopAnyType();
		if(!VerifierTypeWrapper.IsNullOrUnloadable(type) && type.ArrayRank == 0)
		{
			throw new VerifyError("Array reference expected on stack");
		}
		return type;
d969 1
a969 6
		TypeWrapper type = PopAnyType();
		if(type.IsPrimitive || VerifierTypeWrapper.IsNew(type) || type == VerifierTypeWrapper.UninitializedThis)
		{
			throw new VerifyError("Expected object reference on stack");
		}
		return type;
d975 1
a975 8
		TypeWrapper type = PopObjectType();
		// HACK because of the way interfaces references works, if baseType
		// is an interface or array of interfaces, any reference will be accepted
		if(!baseType.IsUnloadable && !baseType.IsInterfaceOrInterfaceArray && !(type.IsUnloadable || type.IsAssignableTo(baseType)))
		{
			throw new VerifyError("Unexpected type " + type + " where " + baseType + " was expected");
		}
		return type;
@


1.109
log
@Implemented Java 8 default interface methods.
@
text
@d3192 5
@


1.108
log
@- Allow static methods in interfaces (for Java 8 class files).
- Allow default interfaces methods (for Java 8 class files), but no actual support for them yet.
@
text
@d3614 1
a3614 1
					if(targetMethod.IsAbstract && invoke == NormalizedByteCode.__invokespecial)
@


1.107
log
@There is no need to use dynamic binding if only the receiver type is unloadable.
@
text
@d2384 5
a2388 1
		if ((cpi is ClassFile.ConstantPoolItemInterfaceMethodref) != (invoke == NormalizedByteCode.__invokeinterface))
d3594 1
a3594 1
		else if(cpi.GetClassType().IsInterface != (invoke == NormalizedByteCode.__invokeinterface))
d3598 4
@


1.106
log
@There is no need to use dynamic binding if only the receiver type is unloadable.
@
text
@d3556 1
a3556 1
		if(cpi.GetClassType().IsUnloadable || (thisType != null && thisType.IsUnloadable))
@


1.105
log
@Added support for dynamic ldc MethodHandle.
@
text
@d3724 1
a3724 1
		else if(cpi.GetClassType().IsUnloadable || (thisType != null && thisType.IsUnloadable))
@


1.104
log
@Bug fix. A dynamic invokespecial (that isn't a new) should fail verification.
@
text
@a2672 28
	private static TypeWrapper FirstUnloadable(ClassFile.ConstantPoolItemMethodHandle cpi)
	{
		if (cpi.GetClassType().IsUnloadable)
		{
			return cpi.GetClassType();
		}
		ClassFile.ConstantPoolItemMI method = cpi.MemberConstantPoolItem as ClassFile.ConstantPoolItemMI;
		if (method != null)
		{
			if (method.GetRetType().IsUnloadable)
			{
				return method.GetRetType();
			}
			foreach (TypeWrapper tw in method.GetArgTypes())
			{
				if (tw.IsUnloadable)
				{
					return tw;
				}
			}
		}
		else if (((ClassFile.ConstantPoolItemFieldref)cpi.MemberConstantPoolItem).GetFieldType().IsUnloadable)
		{
			return ((ClassFile.ConstantPoolItemFieldref)cpi.MemberConstantPoolItem).GetFieldType();
		}
		return null;
	}

d2676 1
a2676 2
		TypeWrapper twUnloadable;
		if ((twUnloadable = FirstUnloadable(cpi)) != null)
d2678 1
a2678 1
			SetHardError(wrapper.GetClassLoader(), ref instr, HardError.NoClassDefFoundError, "{0}", twUnloadable.Name);
@


1.103
log
@Added CodeGenOptions.DisableDynamicBinding to disable dynamic binding, instead of conditional compilation.
@
text
@d3611 1
a3611 1
							SetHardError(wrapper.GetClassLoader(), ref instr, HardError.LinkageError, "Base class no longer loadable");
@


1.102
log
@Enable ldc <MethodType> to work for unloadable types in dynamic mode.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2012 Jeroen Frijters
a2566 1
#if STATIC_COMPILER
d2572 1
a2572 1
										SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
d2587 1
a2587 1
										SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
a2590 1
#endif
d2601 1
a2601 3
#if STATIC_COMPILER
								SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
#endif
d2619 1
a2619 3
#if STATIC_COMPILER
								SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
#endif
d2634 1
a2634 1
								// (regardless of JVM.DisableDynamicBinding), because at runtime,
d2650 1
a2650 3
#if STATIC_COMPILER
								SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
#endif
d2661 1
a2661 3
#if STATIC_COMPILER
								SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
#endif
d3494 9
d3587 5
a3591 4
#if STATIC_COMPILER
			SetHardError(wrapper.GetClassLoader(), ref instr, HardError.NoClassDefFoundError, "{0}", cpi.GetClassType().Name);
#else
			switch(invoke)
d3593 24
a3616 21
				case NormalizedByteCode.__invokeinterface:
					instr.PatchOpCode(NormalizedByteCode.__dynamic_invokeinterface);
					break;
				case NormalizedByteCode.__invokestatic:
					instr.PatchOpCode(NormalizedByteCode.__dynamic_invokestatic);
					break;
				case NormalizedByteCode.__invokevirtual:
					instr.PatchOpCode(NormalizedByteCode.__dynamic_invokevirtual);
					break;
				case NormalizedByteCode.__invokespecial:
					if(isnew)
					{
						instr.PatchOpCode(NormalizedByteCode.__dynamic_invokespecial);
					}
					else
					{
						SetHardError(wrapper.GetClassLoader(), ref instr, HardError.LinkageError, "Base class no longer loadable");
					}
					break;
				default:
					throw new InvalidOperationException();
a3617 1
#endif
d3755 5
a3759 4
#if STATIC_COMPILER
			SetHardError(wrapper.GetClassLoader(), ref instr, HardError.NoClassDefFoundError, "{0}", cpi.GetClassType().Name);
#else
			switch(instr.NormalizedOpCode)
d3761 17
a3777 14
				case NormalizedByteCode.__getstatic:
					instr.PatchOpCode(NormalizedByteCode.__dynamic_getstatic);
					break;
				case NormalizedByteCode.__putstatic:
					instr.PatchOpCode(NormalizedByteCode.__dynamic_putstatic);
					break;
				case NormalizedByteCode.__getfield:
					instr.PatchOpCode(NormalizedByteCode.__dynamic_getfield);
					break;
				case NormalizedByteCode.__putfield:
					instr.PatchOpCode(NormalizedByteCode.__dynamic_putfield);
					break;
				default:
					throw new InvalidOperationException();
a3778 1
#endif
@


1.101
log
@Bug fix. The local variable state at the end of an exception block (if the last instruction is a local variable store) needs to be merged into the exception handler state.
@
text
@a2576 1
#endif
d2592 1
@


1.100
log
@Rollback of incorrect fixes:
ikvm/runtime verifier.cs,1.93,1.94
ikvm/runtime JsrInliner.cs, 1.6,1.7
ikvm/runtime LocalVars.cs, 1.5,1.6
@
text
@d1299 1
a1299 20
								int idx = method.ExceptionTable[j].handlerIndex;
								InstructionState ex = state[i].CopyLocals();
								int catch_type = method.ExceptionTable[j].catch_type;
								if(catch_type == 0)
								{
									TypeWrapper tw;
									if (!faultTypes.TryGetValue(idx, out tw))
									{
										tw = VerifierTypeWrapper.MakeFaultBlockException(this, idx);
										faultTypes.Add(idx, tw);
									}
									ex.PushType(tw);
								}
								else
								{
									// TODO if the exception type is unloadable we should consider pushing
									// Throwable as the type and recording a loader constraint
									ex.PushType(GetConstantPoolClassType(catch_type));
								}
								state[idx] += ex;
d2259 7
d2318 24
@


1.99
log
@Added ClassFile.Method.IsConstructor helper property.
@
text
@d1297 1
a1297 9
							// if we're currently inside an exception block, we need to merge our current state with the exception handler
							// and if we right after the exception block (i == method.ExceptionTable[j].endIndex) and the block ends in
							// an instruction that simply falls through, we need to merge our current state with the exception handler as
							// well (because the last instruction may be a store to a local variable that affects the type of the local variable)
							// (note that we can legally access instructions[i - 1] because an empty exception block is illegal)
							if(method.ExceptionTable[j].startIndex <= i
								&& (i < method.ExceptionTable[j].endIndex
									|| (i == method.ExceptionTable[j].endIndex
										&& ByteCodeMetaData.GetFlowControl(instructions[i - 1].NormalizedOpCode) == ByteCodeFlowControl.Next)))
@


1.99.2.1
log
@- Changed version to 7.2.4630.4.
Backported fixes for new rc:
- Added (optional) support for building without System.Core.dll dependency.
- Bug fix. Abstract generic methods are not supported. Fix for #3579785.
- Bug fix. Interface mappings can be "incomplete". Fix for bug #3581564.
- Bug fix. Verifier should not merge state from instruction following exception block to handler. Fix for bug #3580611.
@
text
@d1297 30
a1326 3
							if(method.ExceptionTable[j].startIndex <= i && i < method.ExceptionTable[j].endIndex)
							{
								MergeExceptionHandler(j, state[i]);
a2285 7
						for(int j = 0; j < method.ExceptionTable.Length; j++)
						{
							if(method.ExceptionTable[j].endIndex == i + 1)
							{
								MergeExceptionHandler(j, s);
							}
						}
a2337 24
	private void MergeExceptionHandler(int exceptionIndex, InstructionState curr)
	{
		int idx = method.ExceptionTable[exceptionIndex].handlerIndex;
		InstructionState ex = curr.CopyLocals();
		int catch_type = method.ExceptionTable[exceptionIndex].catch_type;
		if (catch_type == 0)
		{
			TypeWrapper tw;
			if (!faultTypes.TryGetValue(idx, out tw))
			{
				tw = VerifierTypeWrapper.MakeFaultBlockException(this, idx);
				faultTypes.Add(idx, tw);
			}
			ex.PushType(tw);
		}
		else
		{
			// TODO if the exception type is unloadable we should consider pushing
			// Throwable as the type and recording a loader constraint
			ex.PushType(GetConstantPoolClassType(catch_type));
		}
		state[idx] += ex;
	}

@


1.98
log
@Bug fix. It is not valid to call TypeWrapper.IsInterfaceOrInterfaceArray on an UnloadableTypeWrapper.
@
text
@d1203 1
a1203 1
			if(ReferenceEquals(method.Name, StringConstants.INIT))
@


1.97
log
@Bug fix. If we encounter a jsr or ret instruction, we should throw a VerifyError (instead of NotImplementedException).
@
text
@d709 1
a709 1
			if(baseType.IsInterfaceOrInterfaceArray && !type.IsPrimitive)
d907 1
a907 1
			if(baseType.IsInterfaceOrInterfaceArray && !type.IsPrimitive)
@


1.96
log
@Added intrinsics for (some usages of) Unsafe methods: putObject, putOrderedObject, putObjectVolatile, getObjectVolatile, getObject, compareAndSwapObject.
@
text
@d2276 3
@


1.95
log
@Merge exception blocks that are split around return statements by javac.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d1678 12
a1717 1
								TypeWrapper retType = cpi.GetRetType();
@


1.94
log
@Bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
@
text
@d2932 15
d3155 10
@


1.93
log
@Unloadable types can't violate loader constraints.
@
text
@d1297 9
a1305 1
							if(method.ExceptionTable[j].startIndex <= i && i < method.ExceptionTable[j].endIndex)
@


1.93.2.1
log
@Backported bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
@
text
@d1297 1
a1297 9
							// if we're currently inside an exception block, we need to merge our current state with the exception handler
							// and if we right after the exception block (i == method.ExceptionTable[j].endIndex) and the block ends in
							// an instruction that simply falls through, we need to merge our current state with the exception handler as
							// well (because the last instruction may be a store to a local variable that affects the type of the local variable)
							// (note that we can legally access instructions[i - 1] because an empty exception block is illegal)
							if(method.ExceptionTable[j].startIndex <= i
								&& (i < method.ExceptionTable[j].endIndex
									|| (i == method.ExceptionTable[j].endIndex
										&& ByteCodeMetaData.GetFlowControl(instructions[i - 1].NormalizedOpCode) == ByteCodeFlowControl.Next)))
@


1.92
log
@Bug fix. Removed incorrect check for uninitialized objects on backward branch.
@
text
@d3795 1
a3795 1
		if(cpi.GetRetType() != mw.ReturnType && !mw.ReturnType.IsUnloadable)
d3806 1
a3806 1
			if(here[i] != there[i] && !there[i].IsUnloadable)
@


1.91
log
@Bug fix. Exception blocks inside potential try { } finally { } blocks were not handled correctly. Could result in finally blocks that run multiple times (when an exception occurs).
@
text
@a834 21
	// this method ensures that no uninitialized object are in the current state
	internal void CheckUninitializedObjRefs()
	{
		for(int i = 0; i < locals.Length; i++)
		{
			TypeWrapper type = locals[i];
			if(VerifierTypeWrapper.IsNew(type))
			{
				throw new VerifyError("uninitialized object ref in local (2)");
			}
		}
		for(int i = 0; i < stackSize; i++)
		{
			TypeWrapper type = stack[i];
			if(VerifierTypeWrapper.IsNew(type))
			{
				throw new VerifyError("uninitialized object ref on stack");
			}
		}
	}

a2337 29
					// verify backward branches
					switch (ByteCodeMetaData.GetFlowControl(instructions[i].NormalizedOpCode))
					{
						case ByteCodeFlowControl.Switch:
							{
								bool hasbackbranch = false;
								for (int j = 0; j < instructions[i].SwitchEntryCount; j++)
								{
									hasbackbranch |= instructions[i].GetSwitchTargetIndex(j) < i;
								}
								hasbackbranch |= instructions[i].DefaultTarget < i;
								if (hasbackbranch)
								{
									// backward branches cannot have uninitialized objects on
									// the stack or in local variables
									state[i].CheckUninitializedObjRefs();
								}
								break;
							}
						case ByteCodeFlowControl.Branch:
						case ByteCodeFlowControl.CondBranch:
							if (instructions[i].TargetIndex < i)
							{
								// backward branches cannot have uninitialized objects on
								// the stack or in local variables
								state[i].CheckUninitializedObjRefs();
							}
							break;
					}
@


1.91.2.1
log
@Backported fixes:
- FileStore for non-accessible drive should throw exception when trying to create the FileStore, not when accessing the name() or type() properties.
- Graphics2D.clip(null) should only throw NPE for a Component graphics.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Handle Main-Class manifest value that spans multiple lines. Fix for bug #3461012.
- Informational messages should not be treated as error when -warnaserror is specified. Fix for #3443377.
- Don't enforce pre-1.5 class name rules in ikvmc (since HotSpot doesn't enforce any naming rules for classes loaded by the system (and boot) class loader, by default). Fix for #3443373.
- Fix for #3441959.
- Throwable.addSuppressed() didn't have a proper parameter name.
- mark getSpace0 with SecuritySafeCritical to avoid getting an exception with .NET 4
- Bug fix. Removed incorrect check for uninitialized objects on backward branch.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Added AssemblyInformationalVersionAttribute to OpenJDK assemblies (to set the "Product Version"). Part of patch #3458997.
- Include copyright and metadata in IKVM.OpenJDK.Tools.dll. Part of patch #3458997.
- Bug fix. Don't call Finish on unloadable TypeWrapper.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
- Suppress annotation custom attributes when enumerating inner classes.
- IKVM.Reflection: Bug fix. Fixed copy/paste error. FieldInfo.IsAssembly should test for FieldAttributes.Assembly access, not FieldAttributes.Family.
@
text
@d835 21
d2359 29
@


1.90
log
@Implemented invokedynamic instruction.
@
text
@d3444 1
a3444 1
					if (j != exceptionIndex && exceptions[j].startIndex <= exception.startIndex && exception.endIndex <= exceptions[j].endIndex)
@


1.89
log
@Added support for MethodHandle constants (ldc <MethodHandle>).
@
text
@d1741 22
d2355 3
d2509 11
d3867 19
@


1.88
log
@Added support for MethodType constants (ldc <MethodType>).
@
text
@d1665 3
d2581 3
d2671 142
d3484 3
d3831 1
a3831 1
	internal ClassFile.ConstantPoolItemMI GetMethodref(int index)
@


1.87
log
@Bug fix. The "ldc <class>" bytecode can throw an exception, so we need to treat it as such (previously it wasn't marked as throwing an exception, so an exception handler surrounding it could be "optimized" away). The new scheme is to patch the safe versions of ldc opcode into a ldc_nothrow.
@
text
@d1665 3
d2550 1
a2550 1
							if(classFile.GetConstantPoolConstantType(instructions[i].Arg1) == ClassFile.ConstantType.Class)
d2552 2
a2553 2
								TypeWrapper tw = classFile.GetConstantPoolClassType(instructions[i].Arg1);
								if(tw.IsUnloadable)
d2555 7
a2561 2
#if STATIC_COMPILER
									SetHardError(wrapper.GetClassLoader(), ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
d2563 14
@


1.86
log
@Move MethodHandle.invoke[Exact] patching to the right place.
@
text
@d1255 27
d1638 1
d3791 1
@


1.85
log
@Merge in java.lang.invoke package and the beginnings of MethodHandle support.
@
text
@a2360 14
		if (classFile.MajorVersion >= 51
			&& cpi.Class == "java.lang.invoke.MethodHandle"
			&& (cpi.Name == "invoke" || cpi.Name == "invokeExact"))
		{
			if (cpi.Name == "invoke")
			{
				method.Instructions[index].PatchOpCode(NormalizedByteCode.__methodhandle_invoke);
			}
			else
			{
				method.Instructions[index].PatchOpCode(NormalizedByteCode.__methodhandle_invokeexact);
			}
			return;
		}
d3318 15
@


1.84
log
@Added (unused) debugging method to dump a method to the console.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2010 Jeroen Frijters
d1653 2
d2361 14
@


1.84.2.1
log
@Backport: Bug fix. Exception blocks inside potential try { } finally { } blocks were not handled correctly. Could result in finally blocks that run multiple times (when an exception occurs).
@
text
@d3208 1
a3208 1
					if (j != exceptionIndex && exceptions[j].startIndex >= exception.startIndex && exception.endIndex <= exceptions[j].endIndex)
@


1.84.2.2
log
@Backport: Bug fix. Removed incorrect check for uninitialized objects on backward branch.
@
text
@d835 21
d2298 29
@


1.84.2.3
log
@Backported fixes for 0.46.0.3:
- Bug fix. java.lang.Package was not populated from manifest for ikvmc compiled assemblies.
- Bug fix. When writing a direct ByteBuffer to a non-blocking socket and the write fails because there is no kernel buffer available, we should not advance the ByteBuffer position.
- Bug fix. When adding certificates to virtual cacerts file make sure that the aliases are unique.
- Bug fix. If a finally/fault handler contains reachable code before the handler's start index, the handler should branch to the handler start index.
- Bug fix. After emitting a finally/fault handler block, we should emit the block leave stubs (even though you can't leave the block, they also emit the backward branch stubs).
- Bug fix. If a Java class extends a remapped .NET type (cli.System.Object or cli.System.Exception), we should correctly report the base class.
- Bug fix. If we encounter a jsr or ret instruction, we should throw a VerifyError (instead of NotImplementedException).
- Bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
- Disable AppDomain.ProcessExit hook to run shutdown hooks when running on Mono to workaround https://bugzilla.xamarin.com/show_bug.cgi?id=5650
- Bug fix. Custom attribute properties that don't have a public getter and setter should not be exposed as annotation properties.
- Bug fix. Non-public property getter/setter methods should be ignored when we create properties to hide properties inherited from shadow types. This fixes a build break with .NET 4.5 beta which introduces a protected setter for Exception.HResult.
- Bug fix. The $Method inner class for delegates should also be loadable for generic delegates. Thanks to Michael Bayne for reporting this.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Replaced non-ascii character (micro) with ascii 'u' in Win32PrintService.java.
- IKVM.Reflection: Bug fix. Resource Directory Entries must be sorted and names are case-insensitive

Backported for 0.46.0.4:
- Fixed ikvmc to retain transient modifier on constant static final fields.
- Fixed Field.getModifiers() to only return the relevant modifiers.
- Fixed IKVM.Reflection to set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@d709 1
a709 1
			if((baseType.IsUnloadable || baseType.IsInterfaceOrInterfaceArray) && !type.IsPrimitive)
d907 1
a907 1
			if((baseType.IsUnloadable || baseType.IsInterfaceOrInterfaceArray) && !type.IsPrimitive)
d1270 1
a1270 9
							// if we're currently inside an exception block, we need to merge our current state with the exception handler
							// and if we right after the exception block (i == method.ExceptionTable[j].endIndex) and the block ends in
							// an instruction that simply falls through, we need to merge our current state with the exception handler as
							// well (because the last instruction may be a store to a local variable that affects the type of the local variable)
							// (note that we can legally access instructions[i - 1] because an empty exception block is illegal)
							if(method.ExceptionTable[j].startIndex <= i
								&& (i < method.ExceptionTable[j].endIndex
									|| (i == method.ExceptionTable[j].endIndex
										&& ByteCodeMetaData.GetFlowControl(instructions[i - 1].NormalizedOpCode) == ByteCodeFlowControl.Next)))
a2198 3
							case NormalizedByteCode.__jsr:
							case NormalizedByteCode.__ret:
								throw new VerifyError("Bad instruction");
@


1.84.2.4
log
@Updated version to 0.46.0.5 and backported bug fixes:
- IKVM.Reflection should ignore unknown metadata streams.
- Off-by-one error in local ref index reusing. Fix for bug #3575555.
- Interface mappings can be "incomplete". Fix for bug #3581564.
- The local variable state at the end of an exception block (if the last instruction is a local variable store) needs to be merged into the exception handler state.
- Local variable analysis for finally blocks was incorrect. Fixes bug #3600788.
- Don't implement interfaces that aren't accessible.
- Updated Mono workaround for Mono 3.0.x.
- Check for supported delegate signatures should detect pointers inside byref and array types and return type should be checked as well.
- Fake nested types should have Static modifier set in innerclasses attribute. Fixes scala compiler interop issue. Thanks to Michael Bayne for reporting this.
- ikvmstub -skiperror should also skip errors during WriteClass.
- An ITEMIDLIST should be freed using CoTaskMemFree.
- String.CaseInsensitiveComparator inner class should be acknowledged by String.
- Fixed the SHFILEINFO declaration. Thanks to Andras Kovacs for reporting this.
- Fixed race condition in MethodWrapper.ResolveMethod().
@
text
@d1270 30
a1299 3
							if(method.ExceptionTable[j].startIndex <= i && i < method.ExceptionTable[j].endIndex)
							{
								MergeExceptionHandler(j, state[i]);
a2216 7
						for(int j = 0; j < method.ExceptionTable.Length; j++)
						{
							if(method.ExceptionTable[j].endIndex == i + 1)
							{
								MergeExceptionHandler(j, s);
							}
						}
a2268 24
	private void MergeExceptionHandler(int exceptionIndex, InstructionState curr)
	{
		int idx = method.ExceptionTable[exceptionIndex].handlerIndex;
		InstructionState ex = curr.CopyLocals();
		int catch_type = method.ExceptionTable[exceptionIndex].catch_type;
		if (catch_type == 0)
		{
			TypeWrapper tw;
			if (!faultTypes.TryGetValue(idx, out tw))
			{
				tw = VerifierTypeWrapper.MakeFaultBlockException(this, idx);
				faultTypes.Add(idx, tw);
			}
			ex.PushType(tw);
		}
		else
		{
			// TODO if the exception type is unloadable we should consider pushing
			// Throwable as the type and recording a loader constraint
			ex.PushType(GetConstantPoolClassType(catch_type));
		}
		state[idx] += ex;
	}

@


1.83
log
@Convert javac synchronized block fault handlers into finally handlers.
@
text
@d3695 71
@


1.82
log
@Implemented first stab at converting suitable fault blocks into finally blocks.
@
text
@d3030 14
a3043 1
				if (TryFindSingleTryBlockExit(code, flags, exceptions, i, out exit)
d3056 1
a3056 1
							&& MatchExceptionCoverage(exceptions, exceptions[i].handlerIndex, faultHandlerEnd, exit, exitHandlerEnd))
d3072 10
a3081 1
	private static bool MatchExceptionCoverage(UntangledExceptionTable exceptions, int startFault, int endFault, int startExit, int endExit)
d3085 1
a3085 1
			if (ExceptionCovers(exceptions[j], startFault, endFault) != ExceptionCovers(exceptions[j], startExit, endExit))
d3196 1
a3196 1
	private static bool TryFindSingleTryBlockExit(ClassFile.Method.Instruction[] code, InstructionFlags[] flags, UntangledExceptionTable exceptions, int exceptionIndex, out int exit)
a3197 1
		ExceptionTableEntry exception = exceptions[exceptionIndex];
@


1.81
log
@Restructured method analyzer/verifier to make data flow more obvious and keep less data alive during compilation.
@
text
@d1096 5
d1267 1
d2616 7
a2623 1
		flags[initialInstructionIndex] |= InstructionFlags.Reachable;
d2645 13
a2657 2
					// mark the successor instructions
					switch (ByteCodeMetaData.GetFlowControl(instructions[i].NormalizedOpCode))
d2659 1
a2659 24
						case ByteCodeFlowControl.Switch:
							{
								for (int j = 0; j < instructions[i].SwitchEntryCount; j++)
								{
									flags[instructions[i].GetSwitchTargetIndex(j)] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
								}
								flags[instructions[i].DefaultTarget] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
								break;
							}
						case ByteCodeFlowControl.Branch:
							flags[instructions[i].TargetIndex] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
							break;
						case ByteCodeFlowControl.CondBranch:
							flags[instructions[i].TargetIndex] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
							flags[i + 1] |= InstructionFlags.Reachable;
							break;
						case ByteCodeFlowControl.Return:
						case ByteCodeFlowControl.Throw:
							break;
						case ByteCodeFlowControl.Next:
							flags[i + 1] |= InstructionFlags.Reachable;
							break;
						default:
							throw new InvalidOperationException();
d2661 2
d2664 15
a2678 1
			}
a2679 1
		return flags;
d3019 227
@


1.80
log
@Seal classes and make fields readonly.
@
text
@d745 5
d1056 87
d1154 2
d1158 2
d1162 2
a1163 1
	private readonly ExceptionTableEntry[] exceptions;
d1185 2
d1189 1
a1191 4
		// HACK because types have to have identity, the new types are cached here
		Dictionary<int, TypeWrapper> newTypes = new Dictionary<int,TypeWrapper>();
		Dictionary<int, TypeWrapper> faultTypes = new Dictionary<int, TypeWrapper>();

a1213 1
		TypeWrapper thisType;
d1248 11
a1258 5
		AnalyzeTypeFlow(wrapper, thisType, mw, newTypes, faultTypes);
		exceptions = UntangleExceptionBlocks(classFile, method.ExceptionTable);
		OptimizationPass(wrapper, classLoader);
		FinalCodePatchup(wrapper, mw);
		if (AnalyzePotentialFaultBlocks())
d1260 1
a1260 1
			AnalyzeTypeFlow(wrapper, thisType, mw, newTypes, faultTypes);
d1262 1
d1265 1
a1265 1
	private void AnalyzeTypeFlow(TypeWrapper wrapper, TypeWrapper thisType, MethodWrapper mw, Dictionary<int, TypeWrapper> newTypes, Dictionary<int, TypeWrapper> faultTypes)
a1444 1
							case NormalizedByteCode.__dastore_conv:
a1454 1
							case NormalizedByteCode.__fastore_conv:
d1594 1
a1594 1
								// putfield is allowed to access the unintialized this
a2071 1
							case NormalizedByteCode.__fstore_conv:
a2079 1
							case NormalizedByteCode.__dstore_conv:
d2273 170
a2442 1
	private void OptimizationPass(TypeWrapper wrapper, ClassLoaderWrapper classLoader)
d2462 1
a2462 1
				InstructionFlags[] flags = ComputePartialReachability(0, false);
d2485 1
a2485 1
	private void FinalCodePatchup(TypeWrapper wrapper, MethodWrapper mw)
d2487 1
a2487 1
		// Now we do another pass to find "hard error" instructions and verify backward branches
a2497 24
						case NormalizedByteCode.__fstore:
							if(stack.PeekType() == VerifierTypeWrapper.ExtendedFloat && !method.IsStrictfp)
							{
								instructions[i].PatchOpCode(NormalizedByteCode.__fstore_conv);
							}
							break;
						case NormalizedByteCode.__fastore:
							if(stack.PeekType() == VerifierTypeWrapper.ExtendedFloat && !method.IsStrictfp)
							{
								instructions[i].PatchOpCode(NormalizedByteCode.__fastore_conv);
							}
							break;
						case NormalizedByteCode.__dstore:
							if(stack.PeekType() == VerifierTypeWrapper.ExtendedDouble && !method.IsStrictfp)
							{
								instructions[i].PatchOpCode(NormalizedByteCode.__dstore_conv);
							}
							break;
						case NormalizedByteCode.__dastore:
							if(stack.PeekType() == VerifierTypeWrapper.ExtendedDouble && !method.IsStrictfp)
							{
								instructions[i].PatchOpCode(NormalizedByteCode.__dastore_conv);
							}
							break;
d2502 1
a2502 1
							VerifyInvoke(wrapper, ref instructions[i], stack);
d2508 1
a2508 1
							VerifyFieldAccess(wrapper, mw, ref instructions[i], stack);
d2578 1
a2578 4
							if(tw == VerifierTypeWrapper.Null)
							{
							}
							else if(tw.IsUnloadable)
a2583 8
							else
							{
								tw = tw.ElementTypeWrapper;
								if(tw.IsPrimitive)
								{
									throw new VerifyError("Object array expected");
								}
							}
a2596 4
							else
							{
								// TODO do we need any other tests?
							}
a2601 29
					// verify backward branches
					switch(ByteCodeMetaData.GetFlowControl(instructions[i].NormalizedOpCode))
					{
						case ByteCodeFlowControl.Switch:
						{
							bool hasbackbranch = false;
							for(int j = 0; j < instructions[i].SwitchEntryCount; j++)
							{
								hasbackbranch |= instructions[i].GetSwitchTargetIndex(j) < i;
							}
							hasbackbranch |= instructions[i].DefaultTarget < i;
							if(hasbackbranch)
							{
								// backward branches cannot have uninitialized objects on
								// the stack or in local variables
								state[i].CheckUninitializedObjRefs();
							}
							break;
						}
						case ByteCodeFlowControl.Branch:
						case ByteCodeFlowControl.CondBranch:
							if(instructions[i].TargetIndex < i)
							{
								// backward branches cannot have uninitialized objects on
								// the stack or in local variables
								state[i].CheckUninitializedObjRefs();
							}
							break;
					}
d2607 1
a2607 1
	internal InstructionFlags[] ComputePartialReachability(int initialInstructionIndex, bool skipFaultBlocks)
a2608 1
		ClassFile.Method.Instruction[] instructions = method.Instructions;
d2627 1
a2627 1
							if (!skipFaultBlocks || !VerifierTypeWrapper.IsFaultBlockException(state[idx].GetStackByIndex(0)))
d2667 1
a2667 1
	private ExceptionTableEntry[] UntangleExceptionBlocks(ClassFile classFile, ExceptionTableEntry[] exceptionTable)
d2670 1
d2928 1
a2928 24
		// TODO remove these checks, if the above exception untangling is correct, this shouldn't ever
		// be triggered
		for (int i = 0; i < exceptions.Length; i++)
		{
			for (int j = i + 1; j < exceptions.Length; j++)
			{
				// check for partially overlapping try blocks (which is legal for the JVM, but not the CLR)
				if (exceptions[i].startIndex < exceptions[j].startIndex &&
					exceptions[j].startIndex < exceptions[i].endIndex &&
					exceptions[i].endIndex < exceptions[j].endIndex)
				{
					throw new InvalidOperationException("Partially overlapping try blocks is broken");
				}
				// check that we didn't destroy the ordering, when sorting
				if (exceptions[i].startIndex <= exceptions[j].startIndex &&
					exceptions[i].endIndex >= exceptions[j].endIndex &&
					exceptions[i].ordinal < exceptions[j].ordinal)
				{
					throw new InvalidOperationException("Non recursive try blocks is broken");
				}
			}
		}

		return exceptions;
d2931 1
a2931 1
	private bool AnalyzePotentialFaultBlocks()
d2950 2
a2951 2
					&& state[exceptions[i].handlerIndex] != null
					&& VerifierTypeWrapper.IsFaultBlockException(GetRawStackTypeWrapper(exceptions[i].handlerIndex, 0)))
d2953 1
a2953 1
					InstructionFlags[] flags = ComputePartialReachability(exceptions[i].handlerIndex, true);
d2990 1
a2990 1
							VerifierTypeWrapper.ClearFaultBlockException(GetRawStackTypeWrapper(exceptions[i].handlerIndex, 0));
d3043 1
a3043 1
	private void VerifyInvoke(TypeWrapper wrapper, ref ClassFile.Method.Instruction instr, StackState stack)
a3045 12
		if((cpi is ClassFile.ConstantPoolItemInterfaceMethodref) != (instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface))
		{
			throw new VerifyError("Illegal constant pool index");
		}
		if(instr.NormalizedOpCode != NormalizedByteCode.__invokespecial && ReferenceEquals(cpi.Name, StringConstants.INIT))
		{
			throw new VerifyError("Must call initializers using invokespecial");
		}
		if(ReferenceEquals(cpi.Name, StringConstants.CLINIT))
		{
			throw new VerifyError("Illegal call to internal method");
		}
a3046 20
		TypeWrapper[] args = cpi.GetArgTypes();
		for(int j = args.Length - 1; j >= 0; j--)
		{
			stack.PopType(args[j]);
		}
		if(invoke == NormalizedByteCode.__invokeinterface)
		{
			int argcount = args.Length + 1;
			for(int j = 0; j < args.Length; j++)
			{
				if(args[j].IsWidePrimitive)
				{
					argcount++;
				}
			}
			if(instr.Arg2 != argcount)
			{
				throw new VerifyError("Inconsistent args size");
			}
		}
d3055 5
a3064 52
				if((isnew && ((VerifierTypeWrapper)type).UnderlyingType != cpi.GetClassType()) ||
					(type == VerifierTypeWrapper.UninitializedThis && cpi.GetClassType() != wrapper.BaseTypeWrapper && cpi.GetClassType() != wrapper) ||
					(!isnew && type != VerifierTypeWrapper.UninitializedThis))
				{
					// TODO oddly enough, Java fails verification for the class without
					// even running the constructor, so maybe constructors are always
					// verified...
					// NOTE when a constructor isn't verifiable, the static initializer
					// doesn't run either
					throw new VerifyError("Call to wrong initialization method");
				}
			}
			else
			{
				if(invoke != NormalizedByteCode.__invokeinterface)
				{
					TypeWrapper refType = stack.PopObjectType();
					TypeWrapper targetType = cpi.GetClassType();
					if(!VerifierTypeWrapper.IsNullOrUnloadable(refType) && 
						!targetType.IsUnloadable &&
						!refType.IsAssignableTo(targetType))
					{
						throw new VerifyError("Incompatible object argument for function call");
					}
					// for invokespecial we also need to make sure we're calling ourself or a base class
					if(invoke == NormalizedByteCode.__invokespecial)
					{
						if(!VerifierTypeWrapper.IsNullOrUnloadable(refType) && !refType.IsSubTypeOf(wrapper))
						{
							throw new VerifyError("Incompatible target object for invokespecial");
						}
						if(!targetType.IsUnloadable && !wrapper.IsSubTypeOf(targetType))
						{
							throw new VerifyError("Invokespecial cannot call subclass methods");
						}
					}
				}
				else /* __invokeinterface */
				{
					// NOTE unlike in the above case, we also allow *any* interface target type
					// regardless of whether it is compatible or not, because if it is not compatible
					// we want an IncompatibleClassChangeError at runtime
					TypeWrapper refType = stack.PopObjectType();
					TypeWrapper targetType = cpi.GetClassType();
					if(!VerifierTypeWrapper.IsNullOrUnloadable(refType) 
						&& !targetType.IsUnloadable
						&& !refType.IsAssignableTo(targetType)
						&& !targetType.IsInterface)
					{
						throw new VerifyError("Incompatible object argument for function call");
					}
				}
d3151 1
a3151 1
	private void VerifyFieldAccess(TypeWrapper wrapper, MethodWrapper mw, ref ClassFile.Method.Instruction instr, StackState stack)
a3325 5
	internal string GetErrorMessage(int messageId)
	{
		return errorMessages[messageId];
	}

a3426 25
	internal int GetStackHeight(int index)
	{
		return state[index].GetStackHeight();
	}

	internal TypeWrapper GetStackTypeWrapper(int index, int pos)
	{
		TypeWrapper type = state[index].GetStackSlot(pos);
		if(VerifierTypeWrapper.IsThis(type))
		{
			type = ((VerifierTypeWrapper)type).UnderlyingType;
		}
		return type;
	}

	internal TypeWrapper GetRawStackTypeWrapper(int index, int pos)
	{
		return state[index].GetStackSlot(pos);
	}

	internal TypeWrapper GetLocalTypeWrapper(int index, int local)
	{
		return state[index].GetLocalTypeEx(local);
	}

a3431 16

	internal ExceptionTableEntry[] GetExceptionTableFor(InstructionFlags[] flags)
	{
		List<ExceptionTableEntry> list = new List<ExceptionTableEntry>();
		// return only reachable exception handlers (because the code gen depends on that)
		for (int i = 0; i < exceptions.Length; i++)
		{
			// if the first instruction is unreachable, the entire block is unreachable,
			// because you can't jump into a block (we've just split the blocks to ensure that)
			if ((flags[exceptions[i].startIndex] & InstructionFlags.Reachable) != 0)
			{
				list.Add(exceptions[i]);
			}
		}
		return list.ToArray();
	}
@


1.79
log
@Moved local variable analysis from verifier.cs to new file LocalVars.cs.
@
text
@d32 1
a32 1
class InstructionState
d1051 1
a1051 1
class MethodAnalyzer
d1053 12
a1064 12
	private static TypeWrapper ByteArrayType;
	private static TypeWrapper BooleanArrayType;
	private static TypeWrapper ShortArrayType;
	private static TypeWrapper CharArrayType;
	private static TypeWrapper IntArrayType;
	private static TypeWrapper FloatArrayType;
	private static TypeWrapper DoubleArrayType;
	private static TypeWrapper LongArrayType;
	private static TypeWrapper java_lang_ThreadDeath;
	private ClassFile classFile;
	private ClassFile.Method method;
	private InstructionState[] state;
d1066 1
a1066 1
	private ExceptionTableEntry[] exceptions;
@


1.78
log
@Moved local variable analysis into a separate pass.
@
text
@a27 6
#if STATIC_COMPILER
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
#else
using System.Reflection.Emit;
#endif
a1019 36
class LocalVar
{
	internal bool isArg;
	internal int local;
	internal TypeWrapper type;
	internal LocalBuilder builder;
	// used to emit debugging info, only available if ClassLoaderWrapper.EmitDebugInfo is true
	internal string name;
	internal int start_pc;
	internal int end_pc;

	internal void FindLvtEntry(ClassFile.Method method, int instructionIndex)
	{
		ClassFile.Method.LocalVariableTableEntry[] lvt = method.LocalVariableTableAttribute;
		if(lvt != null)
		{
			int pc = method.Instructions[instructionIndex].PC;
			int nextPC = method.Instructions[instructionIndex + 1].PC;
			bool isStore = MethodAnalyzer.IsStoreLocal(method.Instructions[instructionIndex].NormalizedOpCode);
			foreach(ClassFile.Method.LocalVariableTableEntry e in lvt)
			{
				// TODO validate the contents of the LVT entry
				if(e.index == local &&
					(e.start_pc <= pc || (e.start_pc == nextPC && isStore)) && 
					e.start_pc + e.length > pc)
				{
					name = e.name;
					start_pc = e.start_pc;
					end_pc = e.start_pc + e.length;
					break;
				}
			}
		}
	}
}

a1064 3
	private LocalVar[/*instructionIndex*/] localVars;
	private LocalVar[/*instructionIndex*/][/*localIndex*/] invokespecialLocalVars;
	private LocalVar[/*index*/] allLocalVars;
a1160 4
		if (mw != null)
		{
			AnalyzeLocalVariables(mw, classLoader);
		}
a2468 358
	struct FindLocalVarState
	{
		internal bool changed;
		internal FindLocalVarStoreSite[] sites;

		internal void Store(int instructionIndex, int localIndex)
		{
			if (sites[localIndex].Count == 1 && sites[localIndex][0] == instructionIndex)
			{
				return;
			}
			sites = (FindLocalVarStoreSite[])sites.Clone();
			sites[localIndex] = new FindLocalVarStoreSite();
			sites[localIndex].Add(instructionIndex);
		}

		internal void Merge(FindLocalVarState state)
		{
			if (sites == null)
			{
				sites = state.sites;
				changed = true;
			}
			else
			{
				bool dirty = true;
				for (int i = 0; i < sites.Length; i++)
				{
					for (int j = 0; j < state.sites[i].Count; j++)
					{
						if (!sites[i].Contains(state.sites[i][j]))
						{
							if (dirty)
							{
								dirty = false;
								sites = (FindLocalVarStoreSite[])sites.Clone();
							}
							sites[i].Add(state.sites[i][j]);
							changed = true;
						}
					}
				}
			}
		}

		internal FindLocalVarState Copy()
		{
			FindLocalVarState copy = new FindLocalVarState();
			copy.sites = sites;
			return copy;
		}

		public override string ToString()
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			if (sites != null)
			{
				foreach (FindLocalVarStoreSite site in sites)
				{
					sb.Append('[');
					for (int i = 0; i < site.Count; i++)
					{
						sb.AppendFormat("{0}, ", site[i]);
					}
					sb.Append(']');
				}
			}
			return sb.ToString();
		}
	}

	struct FindLocalVarStoreSite
	{
		private int[] data;

		internal bool Contains(int instructionIndex)
		{
			if (data != null)
			{
				for (int i = 0; i < data.Length; i++)
				{
					if (data[i] == instructionIndex)
					{
						return true;
					}
				}
			}
			return false;
		}

		internal void Add(int instructionIndex)
		{
			if (data == null)
			{
				data = new int[] { instructionIndex };
			}
			else
			{
				Array.Resize(ref data, data.Length + 1);
				data[data.Length - 1] = instructionIndex;
			}
		}

		internal int this[int index]
		{
			get { return data[index]; }
		}

		internal int Count
		{
			get { return data == null ? 0 : data.Length; }
		}
	}

	private static Dictionary<int, string>[] FindLocalVariables(MethodAnalyzer ma, MethodWrapper mw, ClassFile.Method method)
	{
		ClassFile.Method.Instruction[] instructions = method.Instructions;
		ExceptionTableEntry[] exceptions = method.ExceptionTable;
		int maxLocals = method.MaxLocals;
		Dictionary<int, string>[] localStoreReaders = new Dictionary<int, string>[instructions.Length];
		FindLocalVarState[] state = new FindLocalVarState[instructions.Length];
		bool done = false;
		state[0].changed = true;
		state[0].sites = new FindLocalVarStoreSite[maxLocals];
		TypeWrapper[] parameters = mw.GetParameters();
		int argpos = 0;
		if (!mw.IsStatic)
		{
			state[0].sites[argpos++].Add(-1);
		}
		for (int i = 0; i < parameters.Length; i++)
		{
			state[0].sites[argpos++].Add(-1);
			if (parameters[i].IsWidePrimitive)
			{
				argpos++;
			}
		}

		while (!done)
		{
			done = true;
			for (int i = 0; i < instructions.Length; i++)
			{
				if (state[i].changed)
				{
					done = false;
					state[i].changed = false;

					FindLocalVarState curr = state[i].Copy();

					for (int j = 0; j < exceptions.Length; j++)
					{
						if (exceptions[j].startIndex <= i && i < exceptions[j].endIndex)
						{
							state[exceptions[j].handlerIndex].Merge(curr);
						}
					}

					if (IsLoadLocal(instructions[i].NormalizedOpCode))
					{
						if (localStoreReaders[i] == null)
						{
							localStoreReaders[i] = new Dictionary<int, string>();
						}
						for (int j = 0; j < curr.sites[instructions[i].NormalizedArg1].Count; j++)
						{
							localStoreReaders[i][curr.sites[instructions[i].NormalizedArg1][j]] = "";
						}
					}

					if (IsStoreLocal(instructions[i].NormalizedOpCode))
					{
						curr.Store(i, instructions[i].NormalizedArg1);
					}

					if (instructions[i].NormalizedOpCode == NormalizedByteCode.__invokespecial)
					{
						ClassFile.ConstantPoolItemMI cpi = ma.GetMethodref(instructions[i].Arg1);
						if (ReferenceEquals(cpi.Name, StringConstants.INIT))
						{
							TypeWrapper type = ma.GetRawStackTypeWrapper(i, cpi.GetArgTypes().Length);
							// after we've invoked the constructor, the uninitialized references
							// are now initialized
							if (type == VerifierTypeWrapper.UninitializedThis
								|| VerifierTypeWrapper.IsNew(type))
							{
								for (int j = 0; j < maxLocals; j++)
								{
									if (ma.GetLocalTypeWrapper(i, j) == type)
									{
										curr.Store(i, j);
									}
								}
							}
						}
					}

					switch (ByteCodeMetaData.GetFlowControl(instructions[i].NormalizedOpCode))
					{
						case ByteCodeFlowControl.Switch:
							{
								for (int j = 0; j < instructions[i].SwitchEntryCount; j++)
								{
									state[instructions[i].GetSwitchTargetIndex(j)].Merge(curr);
								}
								state[instructions[i].DefaultTarget].Merge(curr);
								break;
							}
						case ByteCodeFlowControl.Branch:
							state[instructions[i].TargetIndex].Merge(curr);
							break;
						case ByteCodeFlowControl.CondBranch:
							state[instructions[i].TargetIndex].Merge(curr);
							state[i + 1].Merge(curr);
							break;
						case ByteCodeFlowControl.Return:
						case ByteCodeFlowControl.Throw:
							break;
						case ByteCodeFlowControl.Next:
							state[i + 1].Merge(curr);
							break;
						default:
							throw new InvalidOperationException();
					}
				}
			}
		}
		return localStoreReaders;
	}

	private void AnalyzeLocalVariables(MethodWrapper mw, ClassLoaderWrapper classLoader)
	{
		Dictionary<int, string>[] localStoreReaders = FindLocalVariables(this, mw, method);

		// now that we've done the code flow analysis, we can do a liveness analysis on the local variables
		ClassFile.Method.Instruction[] instructions = method.Instructions;
		Dictionary<long, LocalVar> localByStoreSite = new Dictionary<long, LocalVar>();
		List<LocalVar> locals = new List<LocalVar>();
		for(int i = 0; i < localStoreReaders.Length; i++)
		{
			if(localStoreReaders[i] != null)
			{
				VisitLocalLoads(locals, localByStoreSite, localStoreReaders[i], i, classLoader.EmitDebugInfo);
			}
		}
		Dictionary<LocalVar, LocalVar> forwarders = new Dictionary<LocalVar,LocalVar>();
		if(classLoader.EmitDebugInfo)
		{
			InstructionFlags[] flags = ComputePartialReachability(0, false);
			// if we're emitting debug info, we need to keep dead stores as well...
			for(int i = 0; i < instructions.Length; i++)
			{
				if((flags[i] & InstructionFlags.Reachable) != 0
					&& IsStoreLocal(instructions[i].NormalizedOpCode))
				{
					if(!localByStoreSite.ContainsKey(MakeKey(i, instructions[i].NormalizedArg1)))
					{
						LocalVar v = new LocalVar();
						v.local = instructions[i].NormalizedArg1;
						v.type = GetStackTypeWrapper(i, 0);
						v.FindLvtEntry(method, i);
						locals.Add(v);
						localByStoreSite.Add(MakeKey(i, v.local), v);
					}
				}
			}
			// to make the debugging experience better, we have to trust the
			// LocalVariableTable (unless it's clearly bogus) and merge locals
			// together that are the same according to the LVT
			for(int i = 0; i < locals.Count - 1; i++)
			{
				for(int j = i + 1; j < locals.Count; j++)
				{
					LocalVar v1 = (LocalVar)locals[i];
					LocalVar v2 = (LocalVar)locals[j];
					if(v1.name != null && v1.name == v2.name && v1.start_pc == v2.start_pc && v1.end_pc == v2.end_pc)
					{
						// we can only merge if the resulting type is valid (this protects against incorrect
						// LVT data, but is also needed for constructors, where the uninitialized this is a different
						// type from the initialized this)
						TypeWrapper tw = InstructionState.FindCommonBaseType(v1.type, v2.type);
						if(tw != VerifierTypeWrapper.Invalid)
						{
							v1.isArg |= v2.isArg;
							v1.type = tw;
							forwarders.Add(v2, v1);
							locals.RemoveAt(j);
							j--;
						}
					}
				}
			}
		}
		else
		{
			for(int i = 0; i < locals.Count - 1; i++)
			{
				for(int j = i + 1; j < locals.Count; j++)
				{
					LocalVar v1 = (LocalVar)locals[i];
					LocalVar v2 = (LocalVar)locals[j];
					// if the two locals are the same, we merge them, this is a small
					// optimization, it should *not* be required for correctness.
					if(v1.local == v2.local && v1.type == v2.type)
					{
						v1.isArg |= v2.isArg;
						forwarders.Add(v2, v1);
						locals.RemoveAt(j);
						j--;
					}
				}
			}
		}
		invokespecialLocalVars = new LocalVar[instructions.Length][];
		localVars = new LocalVar[instructions.Length];
		for(int i = 0; i < localVars.Length; i++)
		{
			LocalVar v = null;
			if(localStoreReaders[i] != null)
			{
				Debug.Assert(IsLoadLocal(instructions[i].NormalizedOpCode));
				// lame way to look up the local variable for a load
				// (by indirecting through a corresponding store)
				foreach(int store in localStoreReaders[i].Keys)
				{
					v = localByStoreSite[MakeKey(store, instructions[i].NormalizedArg1)];
					break;
				}
			}
			else
			{
				if(instructions[i].NormalizedOpCode == NormalizedByteCode.__invokespecial)
				{
					invokespecialLocalVars[i] = new LocalVar[method.MaxLocals];
					for(int j = 0; j < invokespecialLocalVars[i].Length; j++)
					{
						localByStoreSite.TryGetValue(MakeKey(i, j), out invokespecialLocalVars[i][j]);
					}
				}
				else
				{
					localByStoreSite.TryGetValue(MakeKey(i, instructions[i].NormalizedArg1), out v);
				}
			}
			if(v != null)
			{
				LocalVar fwd;
				if(forwarders.TryGetValue(v, out fwd))
				{
					v = fwd;
				}
				localVars[i] = v;
			}
		}
		this.allLocalVars = locals.ToArray();
	}

d3258 1
a3258 148
	private static bool IsLoadLocal(NormalizedByteCode bc)
	{
		return bc == NormalizedByteCode.__aload ||
			bc == NormalizedByteCode.__iload ||
			bc == NormalizedByteCode.__lload ||
			bc == NormalizedByteCode.__fload ||
			bc == NormalizedByteCode.__dload ||
			bc == NormalizedByteCode.__iinc ||
			bc == NormalizedByteCode.__ret;
	}

	internal static bool IsStoreLocal(NormalizedByteCode bc)
	{
		return bc == NormalizedByteCode.__astore ||
			bc == NormalizedByteCode.__istore ||
			bc == NormalizedByteCode.__lstore ||
			bc == NormalizedByteCode.__fstore ||
			bc == NormalizedByteCode.__dstore ||
			bc == NormalizedByteCode.__fstore_conv ||
			bc == NormalizedByteCode.__dstore_conv;
	}

	private void VisitLocalLoads(List<LocalVar> locals, Dictionary<long, LocalVar> localByStoreSite, Dictionary<int, string> storeSites, int instructionIndex, bool debug)
	{
		Debug.Assert(IsLoadLocal(method.Instructions[instructionIndex].NormalizedOpCode));
		LocalVar local = null;
		TypeWrapper type = VerifierTypeWrapper.Null;
		int localIndex = method.Instructions[instructionIndex].NormalizedArg1;
		bool isArg = false;
		foreach(int store in storeSites.Keys)
		{
			if(store == -1)
			{
				// it's a method argument, it has no initial store, but the type is simply the parameter type
				type = InstructionState.FindCommonBaseType(type, state[0].GetLocalTypeEx(localIndex));
				isArg = true;
			}
			else
			{
				if(method.Instructions[store].NormalizedOpCode == NormalizedByteCode.__invokespecial)
				{
					type = InstructionState.FindCommonBaseType(type, GetLocalTypeWrapper(store + 1, localIndex));
				}
				else if(method.Instructions[store].NormalizedOpCode == NormalizedByteCode.__static_error)
				{
					// it's an __invokespecial that turned into a __static_error
					// (since a __static_error doesn't continue, we don't need to set type)
				}
				else
				{
					Debug.Assert(IsStoreLocal(method.Instructions[store].NormalizedOpCode));
					type = InstructionState.FindCommonBaseType(type, GetStackTypeWrapper(store, 0));
				}
			}
			// we can't have an invalid type, because that would have failed verification earlier
			Debug.Assert(type != VerifierTypeWrapper.Invalid);

			LocalVar l;
			if(localByStoreSite.TryGetValue(MakeKey(store, localIndex), out l))
			{
				if(local == null)
				{
					local = l;
				}
				else if(local != l)
				{
					// If we've already defined a LocalVar and we find another one, then we merge them
					// together.
					// This happens for the following code fragment:
					//
					// int i = -1;
					// try { i = 0; for(; ; ) System.out.println(i); } catch(Exception x) {}
					// try { i = 0; for(; ; ) System.out.println(i); } catch(Exception x) {}
					// System.out.println(i);
					//
					local = MergeLocals(locals, localByStoreSite, local, l);
				}
			}
		}
		if(local == null)
		{
			local = new LocalVar();
			local.local = localIndex;
			if(VerifierTypeWrapper.IsThis(type))
			{
				local.type = ((VerifierTypeWrapper)type).UnderlyingType;
			}
			else
			{
				local.type = type;
			}
			local.isArg = isArg;
			if(debug)
			{
				local.FindLvtEntry(method, instructionIndex);
			}
			locals.Add(local);
		}
		else
		{
			local.isArg |= isArg;
			local.type = InstructionState.FindCommonBaseType(local.type, type);
			Debug.Assert(local.type != VerifierTypeWrapper.Invalid);
		}
		foreach(int store in storeSites.Keys)
		{
			LocalVar v;
			if(!localByStoreSite.TryGetValue(MakeKey(store, localIndex), out v))
			{
				localByStoreSite[MakeKey(store, localIndex)] = local;
			}
			else if(v != local)
			{
				local = MergeLocals(locals, localByStoreSite, local, v);
			}
		}
	}

	private static long MakeKey(int i, int j)
	{
		return (((long)(uint)i) << 32) + (uint)j;
	}

	private static LocalVar MergeLocals(List<LocalVar> locals, Dictionary<long, LocalVar> localByStoreSite, LocalVar l1, LocalVar l2)
	{
		Debug.Assert(l1 != l2);
		Debug.Assert(l1.local == l2.local);
		for(int i = 0; i < locals.Count; i++)
		{
			if(locals[i] == l2)
			{
				locals.RemoveAt(i);
				i--;
			}
		}
		Dictionary<long, LocalVar> temp = new Dictionary<long,LocalVar>(localByStoreSite);
		localByStoreSite.Clear();
		foreach(KeyValuePair<long, LocalVar> kv in temp)
		{
			localByStoreSite[kv.Key] = kv.Value == l2 ? l1 : kv.Value;
		}
		l1.isArg |= l2.isArg;
		l1.type = InstructionState.FindCommonBaseType(l1.type, l2.type);
		Debug.Assert(l1.type != VerifierTypeWrapper.Invalid);
		return l1;
	}

	private ClassFile.ConstantPoolItemMI GetMethodref(int index)
a3359 17
	// NOTE for dead stores, this returns null
	internal LocalVar GetLocalVar(int instructionIndex)
	{
		return localVars[instructionIndex];
	}

	internal LocalVar[] GetLocalVarsForInvokeSpecial(int instructionIndex)
	{
		Debug.Assert(method.Instructions[instructionIndex].NormalizedOpCode == NormalizedByteCode.__invokespecial);
		return invokespecialLocalVars[instructionIndex];
	}

	internal LocalVar[] GetAllLocalVars()
	{
		return allLocalVars;
	}

@


1.77
log
@Consolidated all bytecode flow control properties.
@
text
@a113 1
	private LocalStoreSites[] localStoreSites;
d121 1
a121 2
		LocalStoreSites = 4,
		All = Stack | Locals | LocalStoreSites
d125 1
a125 1
	private InstructionState(TypeWrapper[] stack, int stackSize, int stackEnd, TypeWrapper[] locals, LocalStoreSites[] localStoreSites, bool unitializedThis)
a131 1
		this.localStoreSites = localStoreSites;
a140 1
		this.localStoreSites = new LocalStoreSites[maxLocals];
d145 1
a145 1
		return new InstructionState(stack, stackSize, stackEnd, locals, localStoreSites, unitializedThis);
a154 1
		target.localStoreSites = localStoreSites;
d161 1
a161 1
		InstructionState copy = new InstructionState(new TypeWrapper[stack.Length], 0, stack.Length, locals, localStoreSites, unitializedThis);
a230 2
			LocalStoreSites storeSites = s.localStoreSites[i];
			LocalStoreSites storeSites2 = s2.localStoreSites[i];
a237 7
			storeSites = MergeStoreSites(storeSites, storeSites2);
			if(storeSites.Count != s.localStoreSites[i].Count)
			{
				s.LocalStoreSitesCopyOnWrite();
				s.localStoreSites[i] = storeSites;
				s.changed = true;
			}
d446 1
a446 8
	private void SetLocalStoreSite(int localIndex, int instructionIndex)
	{
		LocalStoreSitesCopyOnWrite();
		localStoreSites[localIndex] = LocalStoreSites.Alloc();
		localStoreSites[localIndex].Add(instructionIndex);
	}

	internal void GetLocalInt(int index, ref Dictionary<int, string> readers)
d448 1
a448 1
		if(GetLocalType(index, ref readers) != PrimitiveTypeWrapper.INT)
a456 1
		SetLocalStoreSite(index, instructionIndex);
d459 1
a459 1
	internal void GetLocalLong(int index, ref Dictionary<int, string> readers)
d461 1
a461 1
		if(GetLocalType(index, ref readers) != PrimitiveTypeWrapper.LONG)
a469 1
		SetLocalStoreSite(index, instructionIndex);
d472 1
a472 1
	internal void GetLocalFloat(int index, ref Dictionary<int, string> readers)
d474 1
a474 1
		if(GetLocalType(index, ref readers) != PrimitiveTypeWrapper.FLOAT)
a482 1
		SetLocalStoreSite(index, instructionIndex);
d485 1
a485 1
	internal void GetLocalDouble(int index, ref Dictionary<int, string> readers)
d487 1
a487 1
		if(GetLocalType(index, ref readers) != PrimitiveTypeWrapper.DOUBLE)
a495 1
		SetLocalStoreSite(index, instructionIndex);
d498 1
a498 1
	internal TypeWrapper GetLocalType(int index, ref Dictionary<int, string> readers)
a501 8
			if(readers == null)
			{
				readers = new Dictionary<int,string>();
			}
			for(int i = 0; i < localStoreSites[index].Count; i++)
			{
				readers[localStoreSites[index][i]] = "";
			}
a527 1
		SetLocalStoreSite(index, instructionIndex);
a777 1
				SetLocalStoreSite(i, instructionIndex);
a809 10
	private void LocalStoreSitesCopyOnWrite()
	{
		if((flags & ShareFlags.LocalStoreSites) != 0)
		{
			flags &= ~ShareFlags.LocalStoreSites;
			LocalStoreSites.MarkShared(localStoreSites);
			localStoreSites = (LocalStoreSites[])localStoreSites.Clone();
		}
	}

a1136 2
		Dictionary<int,string>[] localStoreReaders = new Dictionary<int,string>[method.Instructions.Length];

d1198 1
a1198 1
		AnalyzeTypeFlow(wrapper, thisType, mw, localStoreReaders, newTypes, faultTypes);
d1204 5
a1208 1
			AnalyzeTypeFlow(wrapper, thisType, mw, localStoreReaders, newTypes, faultTypes);
a1209 1
		AnalyzeLocalVariables(localStoreReaders, classLoader);
d1212 1
a1212 1
	private void AnalyzeTypeFlow(TypeWrapper wrapper, TypeWrapper thisType, MethodWrapper mw, Dictionary<int, string>[] localStoreReaders, Dictionary<int, TypeWrapper> newTypes, Dictionary<int, TypeWrapper> faultTypes)
d1262 1
a1262 1
								TypeWrapper type = s.GetLocalType(instr.NormalizedArg1, ref localStoreReaders[i]);
d1655 1
a1655 1
								s.GetLocalInt(instr.NormalizedArg1, ref localStoreReaders[i]);
d2017 1
a2017 1
								s.GetLocalFloat(instr.NormalizedArg1, ref localStoreReaders[i]);
d2026 1
a2026 1
								s.GetLocalDouble(instr.NormalizedArg1, ref localStoreReaders[i]);
d2035 1
a2035 1
								s.GetLocalLong(instr.NormalizedArg1, ref localStoreReaders[i]);
d2081 1
a2081 1
								s.GetLocalInt(instr.Arg1, ref localStoreReaders[i]);
d2518 232
a2749 1
	private void AnalyzeLocalVariables(Dictionary<int, string>[] localStoreReaders, ClassLoaderWrapper classLoader)
d2751 2
@


1.76
log
@Remove unneeded call to ComputePartialReachability().
@
text
@d2218 1
a2218 2
							// another big switch to handle the opcode targets
							switch(instr.NormalizedOpCode)
d2220 1
a2220 2
								case NormalizedByteCode.__tableswitch:
								case NormalizedByteCode.__lookupswitch:
d2227 1
a2227 16
								case NormalizedByteCode.__ifeq:
								case NormalizedByteCode.__ifne:
								case NormalizedByteCode.__iflt:
								case NormalizedByteCode.__ifge:
								case NormalizedByteCode.__ifgt:
								case NormalizedByteCode.__ifle:
								case NormalizedByteCode.__if_icmpeq:
								case NormalizedByteCode.__if_icmpne:
								case NormalizedByteCode.__if_icmplt:
								case NormalizedByteCode.__if_icmpge:
								case NormalizedByteCode.__if_icmpgt:
								case NormalizedByteCode.__if_icmple:
								case NormalizedByteCode.__if_acmpeq:
								case NormalizedByteCode.__if_acmpne:
								case NormalizedByteCode.__ifnull:
								case NormalizedByteCode.__ifnonnull:
d2231 1
a2231 1
								case NormalizedByteCode.__goto:
d2234 2
a2235 8
								case NormalizedByteCode.__ireturn:
								case NormalizedByteCode.__lreturn:
								case NormalizedByteCode.__freturn:
								case NormalizedByteCode.__dreturn:
								case NormalizedByteCode.__areturn:
								case NormalizedByteCode.__return:
								case NormalizedByteCode.__athrow:
								case NormalizedByteCode.__static_error:
d2237 1
a2237 1
								default:
d2240 2
d2468 1
a2468 1
					switch(instructions[i].NormalizedOpCode)
d2470 1
a2470 2
						case NormalizedByteCode.__tableswitch:
						case NormalizedByteCode.__lookupswitch:
d2486 2
a2487 24
						case NormalizedByteCode.__goto:
							if(instructions[i].TargetIndex < i)
							{
								// backward branches cannot have uninitialized objects on
								// the stack or in local variables
								state[i].CheckUninitializedObjRefs();
							}
							break;
						case NormalizedByteCode.__ifeq:
						case NormalizedByteCode.__ifne:
						case NormalizedByteCode.__iflt:
						case NormalizedByteCode.__ifge:
						case NormalizedByteCode.__ifgt:
						case NormalizedByteCode.__ifle:
						case NormalizedByteCode.__if_icmpeq:
						case NormalizedByteCode.__if_icmpne:
						case NormalizedByteCode.__if_icmplt:
						case NormalizedByteCode.__if_icmpge:
						case NormalizedByteCode.__if_icmpgt:
						case NormalizedByteCode.__if_icmple:
						case NormalizedByteCode.__if_acmpeq:
						case NormalizedByteCode.__if_acmpne:
						case NormalizedByteCode.__ifnull:
						case NormalizedByteCode.__ifnonnull:
d2529 1
a2529 1
					switch (instructions[i].NormalizedOpCode)
d2531 1
a2531 2
						case NormalizedByteCode.__tableswitch:
						case NormalizedByteCode.__lookupswitch:
d2540 1
a2540 1
						case NormalizedByteCode.__goto:
d2543 1
a2543 16
						case NormalizedByteCode.__ifeq:
						case NormalizedByteCode.__ifne:
						case NormalizedByteCode.__iflt:
						case NormalizedByteCode.__ifge:
						case NormalizedByteCode.__ifgt:
						case NormalizedByteCode.__ifle:
						case NormalizedByteCode.__if_icmpeq:
						case NormalizedByteCode.__if_icmpne:
						case NormalizedByteCode.__if_icmplt:
						case NormalizedByteCode.__if_icmpge:
						case NormalizedByteCode.__if_icmpgt:
						case NormalizedByteCode.__if_icmple:
						case NormalizedByteCode.__if_acmpeq:
						case NormalizedByteCode.__if_acmpne:
						case NormalizedByteCode.__ifnull:
						case NormalizedByteCode.__ifnonnull:
d2547 2
a2548 9
						case NormalizedByteCode.__ireturn:
						case NormalizedByteCode.__lreturn:
						case NormalizedByteCode.__freturn:
						case NormalizedByteCode.__dreturn:
						case NormalizedByteCode.__areturn:
						case NormalizedByteCode.__return:
						case NormalizedByteCode.__athrow:
						case NormalizedByteCode.__athrow_no_unmap:
						case NormalizedByteCode.__static_error:
d2550 1
a2550 1
						default:
d2553 2
@


1.75
log
@Fixed another verifier regression introduced with try/fault handler changes.
@
text
@a1253 1
		ComputePartialReachability(0, true);
@


1.74
log
@Made most static compiler warnings local to the target that is being compiled (in multi target mode), to allow warnings to be suppressed (or turned into an error) for a specific target.
@
text
@d1489 1
d1532 1
d1571 1
d1586 1
d1637 4
d1644 2
a1645 1
								if(instr.NormalizedOpCode != NormalizedByteCode.__invokestatic)
@


1.73
log
@Fixed verifier regression introduced with try/fault handler changes. Thanks to Enrico Minack for reporting this.
@
text
@d2380 1
a2380 1
									SetHardError(ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
d2391 1
a2391 1
								SetHardError(ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
d2396 1
a2396 1
								SetHardError(ref instructions[i], HardError.IllegalAccessError, "Try to access class {0} from class {1}", tw.Name, wrapper.Name);
d2400 1
a2400 1
								SetHardError(ref instructions[i], HardError.InstantiationError, "{0}", tw.Name);
d2411 1
a2411 1
								SetHardError(ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
d2416 1
a2416 1
								SetHardError(ref instructions[i], HardError.IllegalAccessError, "Try to access class {0} from class {1}", tw.Name, wrapper.Name);
d2433 1
a2433 1
								SetHardError(ref instructions[i], HardError.IllegalAccessError, "Try to access class {0} from class {1}", tw.Name, wrapper.Name);
d2447 1
a2447 1
								SetHardError(ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
d2468 1
a2468 1
								SetHardError(ref instructions[i], HardError.NoClassDefFoundError, "{0}", tw.Name);
d3103 1
a3103 1
	private void SetHardError(ref ClassFile.Method.Instruction instruction, HardError hardError, string message, params object[] args)
d3137 1
a3137 1
		StaticCompiler.IssueMessage(msg, classFile.Name + "." + method.Name + method.Signature, text);
d3249 1
a3249 1
			SetHardError(ref instr, HardError.NoClassDefFoundError, "{0}", cpi.GetClassType().Name);
d3269 1
a3269 1
						SetHardError(ref instr, HardError.LinkageError, "Base class no longer loadable");
d3279 1
a3279 1
			SetHardError(ref instr, HardError.IncompatibleClassChangeError, "invokeinterface on non-interface");
d3289 1
a3289 1
					SetHardError(ref instr, HardError.LinkageError, "{0}", errmsg);
d3295 1
a3295 1
						SetHardError(ref instr, HardError.AbstractMethodError, "{0}.{1}{2}", cpi.Class, cpi.Name, cpi.Signature);
d3314 1
a3314 1
						SetHardError(ref instr, HardError.IllegalAccessError, "Try to access method {0}.{1}{2} from class {3}", targetMethod.DeclaringType.Name, cpi.Name, cpi.Signature, wrapper.Name);
d3319 1
a3319 1
					SetHardError(ref instr, HardError.IncompatibleClassChangeError, "static call to non-static method (or v.v.)");
d3324 1
a3324 1
				SetHardError(ref instr, HardError.NoSuchMethodError, "{0}.{1}{2}", cpi.Class, cpi.Name, cpi.Signature);
d3414 1
a3414 1
			SetHardError(ref instr, HardError.NoClassDefFoundError, "{0}", cpi.GetClassType().Name);
d3441 1
a3441 1
				SetHardError(ref instr, HardError.NoSuchFieldError, "{0}.{1}", cpi.Class, cpi.Name);
d3449 1
a3449 1
				SetHardError(ref instr, HardError.LinkageError, "Loader constraints violated: {0}.{1}", field.DeclaringType.Name, field.Name);
d3454 1
a3454 1
				SetHardError(ref instr, HardError.IncompatibleClassChangeError, "Static field access to non-static field (or v.v.)");
d3459 1
a3459 1
				SetHardError(ref instr, HardError.IllegalAccessError, "Try to access field {0}.{1} from class {2}", field.DeclaringType.Name, field.Name, wrapper.Name);
d3466 1
a3466 1
				SetHardError(ref instr, HardError.IllegalAccessError, "Field {0}.{1} is final", field.DeclaringType.Name, field.Name);
@


1.72
log
@Implemented codegen improvement to use CLR fault handlers for Java catch all handlers, whenever possible.
@
text
@d1437 1
d1448 1
d1628 1
d2057 1
d2066 1
d2199 2
d2250 1
@


1.72.2.1
log
@[backport] Fixed verifier regression introduced with try/fault handler changes. Thanks to Enrico Minack for reporting this.
@
text
@a1436 1
							case NormalizedByteCode.__dastore_conv:
a1446 1
							case NormalizedByteCode.__fastore_conv:
a1625 1
							case NormalizedByteCode.__clone_array:
a2053 1
							case NormalizedByteCode.__fstore_conv:
a2061 1
							case NormalizedByteCode.__dstore_conv:
a2193 2
							case NormalizedByteCode.__static_error:
								break;
a2242 1
								case NormalizedByteCode.__static_error:
@


1.72.2.2
log
@Fixed another verifier regression introduced with try/fault handler changes.
@
text
@a1488 1
							case NormalizedByteCode.__dynamic_getstatic:
a1530 1
							case NormalizedByteCode.__dynamic_putstatic:
a1568 1
							case NormalizedByteCode.__dynamic_getfield:
a1582 1
							case NormalizedByteCode.__dynamic_putfield:
a1632 4
							case NormalizedByteCode.__dynamic_invokevirtual:
							case NormalizedByteCode.__dynamic_invokespecial:
							case NormalizedByteCode.__dynamic_invokeinterface:
							case NormalizedByteCode.__dynamic_invokestatic:
d1636 1
a1636 2
								if(instr.NormalizedOpCode != NormalizedByteCode.__invokestatic
									&& instr.NormalizedOpCode != NormalizedByteCode.__dynamic_invokestatic)
@


1.71
log
@Since we're no longer modifying the instructions, there's no reason to pass it around instead of using it directly from the Method object.
@
text
@d310 10
d690 5
d710 5
d901 10
d949 5
d1156 1
d1186 1
d1245 2
a1246 1
		AnalyzeTypeFlow(wrapper, thisType, mw, localStoreReaders, newTypes);
d1249 4
d1254 1
d1257 1
a1257 1
	private void AnalyzeTypeFlow(TypeWrapper wrapper, TypeWrapper thisType, MethodWrapper mw, Dictionary<int, string>[] localStoreReaders, Dictionary<int, TypeWrapper> newTypes)
d1259 1
a1259 1
		InstructionState s = state[0].Copy();
d1279 1
d1284 7
a1290 1
									ex.PushType(CoreClasses.java.lang.Throwable.Wrapper);
a1297 1
								int idx = method.ExceptionTable[j].handlerIndex;
d1317 5
d2115 8
a2122 1
								s.PopObjectType(CoreClasses.java.lang.Throwable.Wrapper);
d2293 1
a2293 1
				InstructionFlags[] flags = ComputePartialReachability(0, method.ExceptionTable);
d2529 1
a2529 1
	internal InstructionFlags[] ComputePartialReachability(int initialInstructionIndex, ClassFile.Method.ExceptionTableEntry[] exceptionTable)
d2545 1
a2545 1
					for (int j = 0; j < exceptionTable.Length; j++)
d2547 1
a2547 1
						if (exceptionTable[j].startIndex <= i && i < exceptionTable[j].endIndex)
d2549 5
a2553 2
							int idx = exceptionTable[j].handlerIndex;
							flags[idx] |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2598 1
d2627 1
a2627 1
			InstructionFlags[] flags = ComputePartialReachability(0, method.ExceptionTable);
d2736 1
a2736 1
	internal static ExceptionTableEntry[] UntangleExceptionBlocks(ClassFile classFile, ClassFile.Method.Instruction[] instructions, InstructionFlags[] flags, ExceptionTableEntry[] exceptionTable)
d2738 1
d2780 8
a2992 12
		// remove unreachable exception handlers (because the code gen depends on that)
		for (int i = 0; i < ar.Count; i++)
		{
			// if the first instruction is unreachable, the entire block is unreachable,
			// because you can't jump into a block (we've just split the blocks to ensure that)
			if ((flags[ar[i].startIndex] & InstructionFlags.Reachable) == 0)
			{
				ar.RemoveAt(i);
				i--;
			}
		}

d3022 73
d3790 22
@


1.70
log
@Made ExceptionTableEntry completely immutable by making ordinal readonly as well.
@
text
@a1207 1
		ClassFile.Method.Instruction[] instructions = method.Instructions;
d1209 3
a1211 3
		OptimizationPass(wrapper, instructions, classLoader);
		FinalCodePatchup(wrapper, mw, instructions);
		AnalyzeLocalVariables(localStoreReaders, instructions, classLoader);
d2212 1
a2212 1
	private void OptimizationPass(TypeWrapper wrapper, ClassFile.Method.Instruction[] instructions, ClassLoaderWrapper classLoader)
d2232 2
a2233 1
				InstructionFlags[] flags = ComputePartialReachability(instructions, 0, method.ExceptionTable);
d2255 1
a2255 1
	private void FinalCodePatchup(TypeWrapper wrapper, MethodWrapper mw, ClassFile.Method.Instruction[] instructions)
d2260 1
d2468 1
a2468 1
	internal InstructionFlags[] ComputePartialReachability(ClassFile.Method.Instruction[] instructions, int initialInstructionIndex, ClassFile.Method.ExceptionTableEntry[] exceptionTable)
d2470 1
d2546 1
a2546 1
	private void AnalyzeLocalVariables(Dictionary<int, string>[] localStoreReaders, ClassFile.Method.Instruction[] instructions, ClassLoaderWrapper classLoader)
d2549 2
a2550 1
		Dictionary<long, LocalVar> localByStoreSite = new Dictionary<long,LocalVar>();
d2562 1
a2562 1
			InstructionFlags[] flags = ComputePartialReachability(instructions, 0, method.ExceptionTable);
@


1.69
log
@Made ExceptionTableEntry mostly immutable (ordinal will be next).
@
text
@a1089 3
					// This really shouldn't happen, but it is good practice to have a correct Compare
					// implementation and Mono's Array.Sort() (at one point at least) didn't partition
					// correctly, causing an array element to be compared against itself.
d2726 4
a2729 4
						ExceptionTableEntry emi = new ExceptionTableEntry(ej.startIndex, ei.endIndex, ei.handlerIndex, ei.catch_type);
						ExceptionTableEntry emj = new ExceptionTableEntry(ej.startIndex, ei.endIndex, ej.handlerIndex, ej.catch_type);
						ei = new ExceptionTableEntry(ei.startIndex, emi.startIndex, ei.handlerIndex, ei.catch_type);
						ej = new ExceptionTableEntry(emj.endIndex, ej.endIndex, ej.handlerIndex, ej.catch_type);
d2739 3
a2741 3
						ExceptionTableEntry emi = new ExceptionTableEntry(ej.startIndex, ej.endIndex, ei.handlerIndex, ei.catch_type);
						ExceptionTableEntry eei = new ExceptionTableEntry(ej.endIndex, ei.endIndex, ei.handlerIndex, ei.catch_type);
						ei = new ExceptionTableEntry(ei.startIndex, emi.startIndex, ei.handlerIndex, ei.catch_type);
d2771 2
a2772 2
									ExceptionTableEntry en = new ExceptionTableEntry(targetIndex, ei.endIndex, ei.handlerIndex, ei.catch_type);
									ei = new ExceptionTableEntry(ei.startIndex, targetIndex, ei.handlerIndex, ei.catch_type);
d2800 2
a2801 2
									ExceptionTableEntry en = new ExceptionTableEntry(targetIndex, ei.endIndex, ei.handlerIndex, ei.catch_type);
									ei = new ExceptionTableEntry(ei.startIndex, targetIndex, ei.handlerIndex, ei.catch_type);
d2821 2
a2822 2
					ExceptionTableEntry en = new ExceptionTableEntry(ej.handlerIndex, ei.endIndex, ei.handlerIndex, ei.catch_type);
					ei = new ExceptionTableEntry(ei.startIndex, ej.handlerIndex, ei.handlerIndex, ei.catch_type);
a2928 4
		for (int i = 0; i < exceptions.Length; i++)
		{
			exceptions[i].ordinal = i;
		}
@


1.68
log
@Removed mutable flags field from Instruction.
@
text
@a2672 4
		// NOTE we're going to be messing with ExceptionTableEntrys that are owned by the Method, this is very bad practice,
		// this code should probably be changed to use our own ETE class (which should also contain the ordinal, instead
		// of the one in ClassFile.cs)

d2729 6
a2734 12
						ExceptionTableEntry emi = new ExceptionTableEntry();
						emi.startIndex = ej.startIndex;
						emi.endIndex = ei.endIndex;
						emi.catch_type = ei.catch_type;
						emi.handlerIndex = ei.handlerIndex;
						ExceptionTableEntry emj = new ExceptionTableEntry();
						emj.startIndex = ej.startIndex;
						emj.endIndex = ei.endIndex;
						emj.catch_type = ej.catch_type;
						emj.handlerIndex = ej.handlerIndex;
						ei.endIndex = emi.startIndex;
						ej.startIndex = emj.endIndex;
d2742 4
a2745 11
						ExceptionTableEntry emi = new ExceptionTableEntry();
						emi.startIndex = ej.startIndex;
						emi.endIndex = ej.endIndex;
						emi.catch_type = ei.catch_type;
						emi.handlerIndex = ei.handlerIndex;
						ExceptionTableEntry eei = new ExceptionTableEntry();
						eei.startIndex = ej.endIndex;
						eei.endIndex = ei.endIndex;
						eei.catch_type = ei.catch_type;
						eei.handlerIndex = ei.handlerIndex;
						ei.endIndex = emi.startIndex;
d2774 3
a2776 6
									ExceptionTableEntry en = new ExceptionTableEntry();
									en.catch_type = ei.catch_type;
									en.handlerIndex = ei.handlerIndex;
									en.startIndex = targetIndex;
									en.endIndex = ei.endIndex;
									ei.endIndex = targetIndex;
d2803 3
a2805 6
									ExceptionTableEntry en = new ExceptionTableEntry();
									en.catch_type = ei.catch_type;
									en.handlerIndex = ei.handlerIndex;
									en.startIndex = targetIndex;
									en.endIndex = ei.endIndex;
									ei.endIndex = targetIndex;
d2824 3
a2826 6
					ExceptionTableEntry en = new ExceptionTableEntry();
					en.catch_type = ei.catch_type;
					en.handlerIndex = ei.handlerIndex;
					en.startIndex = ej.handlerIndex;
					en.endIndex = ei.endIndex;
					ei.endIndex = ej.handlerIndex;
@


1.67
log
@Moved type flow and optimization passes into separate methods.
@
text
@a1214 1
		ComputePartialReachability(instructions, 0, method.ExceptionTable);
d2235 2
a2236 2
				// compute reachability (and branch targets) so that we can use IsBranchTarget
				ComputePartialReachability(instructions, 0, method.ExceptionTable);
d2242 1
a2242 1
						&& !instructions[i + 1].IsBranchTarget)
d2470 1
a2470 1
	private void ComputePartialReachability(ClassFile.Method.Instruction[] instructions, int initialInstructionIndex, ClassFile.Method.ExceptionTableEntry[] exceptionTable)
d2472 1
a2472 5
		for (int i = 0; i < instructions.Length; i++)
		{
			instructions[i].flags = 0;
		}
		// Now we do another pass to find "hard error" instructions and compute final reachability
d2474 1
a2474 1
		instructions[initialInstructionIndex].flags |= InstructionFlags.Reachable;
d2480 1
a2480 1
				if ((instructions[i].flags & (InstructionFlags.Reachable | InstructionFlags.Processed)) == InstructionFlags.Reachable)
d2483 1
a2483 1
					instructions[i].flags |= InstructionFlags.Processed;
d2490 1
a2490 1
							instructions[idx].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2501 1
a2501 1
									instructions[instructions[i].GetSwitchTargetIndex(j)].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2503 1
a2503 1
								instructions[instructions[i].DefaultTarget].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2507 1
a2507 1
							instructions[instructions[i].TargetIndex].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2525 2
a2526 2
							instructions[instructions[i].TargetIndex].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
							instructions[i + 1].flags |= InstructionFlags.Reachable;
d2538 1
a2538 1
							instructions[i + 1].flags |= InstructionFlags.Reachable;
d2544 1
d2562 1
d2566 2
a2567 1
				if(instructions[i].IsReachable && IsStoreLocal(instructions[i].NormalizedOpCode))
d2671 1
a2671 1
	internal static ExceptionTableEntry[] UntangleExceptionBlocks(ClassFile classFile, ClassFile.Method.Instruction[] instructions, ExceptionTableEntry[] exceptionTable)
d2950 1
a2950 1
			if (!instructions[ar[i].startIndex].IsReachable)
@


1.66
log
@Fixed theoretical issue in RemoveAssertions optimization.
@
text
@d1211 10
d2215 1
d2217 2
a2256 4

		FinalCodePatchup(wrapper, mw, instructions);
		ComputePartialReachability(instructions, 0, method.ExceptionTable);
		AnalyzeLocalVariables(localStoreReaders, instructions, classLoader);
@


1.65
log
@Split analysis steps into separate methods.
@
text
@d2223 2
@


1.64
log
@Made the "unnecessary" exception handler removal a little less conservative.
@
text
@d2243 9
a2251 4
		// Now we do another pass to find "hard error" instructions and compute final reachability
		done = false;
		instructions[0].flags |= InstructionFlags.Reachable;
		while(!done)
a2252 1
			done = true;
d2255 1
a2255 1
				if((instructions[i].flags & (InstructionFlags.Reachable | InstructionFlags.Processed)) == InstructionFlags.Reachable)
a2256 2
					done = false;
					instructions[i].flags |= InstructionFlags.Processed;
d2403 1
a2403 9
					// mark the exception handlers reachable from this instruction
					for(int j = 0; j < method.ExceptionTable.Length; j++)
					{
						if(method.ExceptionTable[j].startIndex <= i && i < method.ExceptionTable[j].endIndex)
						{
							instructions[method.ExceptionTable[j].handlerIndex].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
						}
					}
					// mark the successor instructions
a2412 1
								instructions[instructions[i].GetSwitchTargetIndex(j)].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
a2414 1
							instructions[instructions[i].DefaultTarget].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
a2429 1
							instructions[instructions[i].TargetIndex].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2453 66
d2538 1
d2540 2
@


1.63
log
@Moved exception untangling code into MethodAnalyzer where it makes more sense.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
d2802 16
a2817 11
				// NOTE we don't remove exception handlers that could catch ThreadDeath, because that can be thrown
				// asynchronously (and thus appear on any instruction). This is particularly important to ensure that
				// we run finally blocks when a thread is killed.
				if (ei.catch_type != 0)
				{
					TypeWrapper exceptionType = classFile.GetConstantPoolClassType(ei.catch_type);
					if (!exceptionType.IsUnloadable && !java_lang_ThreadDeath.IsAssignableTo(exceptionType))
					{
						int start = ei.startIndex;
						int end = ei.endIndex;
						for (int j = start; j < end; j++)
d2819 33
a2851 2
							if (ByteCodeMetaData.CanThrowException(instructions[j].NormalizedOpCode))
							{
a2852 1
							}
a2853 2
						ar.RemoveAt(i);
						i--;
d2855 16
@


1.62
log
@Removed unused code.
@
text
@d36 1
d1072 34
d1116 1
d1135 1
d2602 270
@


1.61
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@a1173 5
		TypeWrapper[] argumentsByLocalIndex = new TypeWrapper[firstNonArgLocalIndex];
		for(int i = 0; i < argumentsByLocalIndex.Length; i++)
		{
			argumentsByLocalIndex[i] = state[0].GetLocalTypeEx(i);
		}
@


1.60
log
@Moved VerifierTypeWrapper from verifier.cs to TypeWrapper.cs, to avoid new stub generator (to be checked in later) to have to include verifier.cs
(also made VerifierTypeWrapper sealed)
@
text
@d28 1
a28 1
#if IKVM_REF_EMIT
@


1.59
log
@Integrated new IKVM.Reflection implementation.
@
text
@a1034 119
// this is a container for the special verifier TypeWrappers
class VerifierTypeWrapper : TypeWrapper
{
	internal static readonly TypeWrapper Invalid = null;
	internal static readonly TypeWrapper Null = new VerifierTypeWrapper("null", 0, null);
	internal static readonly TypeWrapper UninitializedThis = new VerifierTypeWrapper("uninitialized-this", 0, null);
	internal static readonly TypeWrapper Unloadable = new UnloadableTypeWrapper("<verifier>");
	internal static readonly TypeWrapper ExtendedFloat = new VerifierTypeWrapper("<extfloat>", 0, null);
	internal static readonly TypeWrapper ExtendedDouble = new VerifierTypeWrapper("<extdouble>", 0, null);

	private int index;
	private TypeWrapper underlyingType;

	public override string ToString()
	{
		return GetType().Name + "[" + Name + "," + index + "," + underlyingType + "]";
	}

	internal static TypeWrapper MakeNew(TypeWrapper type, int bytecodeIndex)
	{
		return new VerifierTypeWrapper("new", bytecodeIndex, type);
	}

	// NOTE the "this" type is special, it can only exist in local[0] and on the stack
	// as soon as the type on the stack is merged or popped it turns into its underlying type.
	// It exists to capture the verification rules for non-virtual base class method invocation in .NET 2.0,
	// which requires that the invocation is done on a "this" reference that was directly loaded onto the
	// stack (using ldarg_0).
	internal static TypeWrapper MakeThis(TypeWrapper type)
	{
		return new VerifierTypeWrapper("this", 0, type);
	}

	internal static bool IsNew(TypeWrapper w)
	{
		return w != null && w.IsVerifierType && ReferenceEquals(w.Name, "new");
	}

	internal static bool IsNullOrUnloadable(TypeWrapper w)
	{
		return w == Null || w.IsUnloadable;
	}

	internal static bool IsThis(TypeWrapper w)
	{
		return w != null && w.IsVerifierType && ReferenceEquals(w.Name, "this");
	}

	internal int Index
	{
		get
		{
			return index;
		}
	}

	internal TypeWrapper UnderlyingType
	{
		get
		{
			return underlyingType;
		}
	}

	private VerifierTypeWrapper(string name, int index, TypeWrapper underlyingType)
		: base(TypeWrapper.VerifierTypeModifiersHack, name, null)
	{
		this.index = index;
		this.underlyingType = underlyingType;
	}

	internal override ClassLoaderWrapper GetClassLoader()
	{
		return null;
	}

	protected override void LazyPublishMembers()
	{
		throw new InvalidOperationException("LazyPublishMembers called on " + this);
	}

	internal override Type TypeAsTBD
	{
		get
		{
			throw new InvalidOperationException("get_Type called on " + this);
		}
	}

	internal override TypeWrapper[] Interfaces
	{
		get
		{
			throw new InvalidOperationException("get_Interfaces called on " + this);
		}
	}

	internal override TypeWrapper[] InnerClasses
	{
		get
		{
			throw new InvalidOperationException("get_InnerClasses called on " + this);
		}
	}

	internal override TypeWrapper DeclaringTypeWrapper
	{
		get
		{
			throw new InvalidOperationException("get_DeclaringTypeWrapper called on " + this);
		}
	}

	internal override void Finish()
	{
		throw new InvalidOperationException("Finish called on " + this);
	}
}

@


1.58
log
@Removed vestigial compact framework support.
@
text
@d30 1
@


1.57
log
@Small code cleanup. Changed a couple of abstract methods in TypeWrapper to virtual and provided a default implementation and removed the implementation from a number of subclasses.
@
text
@a23 1
#if !COMPACT_FRAMEWORK
a3383 1
#endif
@


1.56
log
@When unsharing the localstoresite array, mark each individual entry as shared. I don't think this was actually a bug due to the specifics of how sharing work, but it definitely was a bug waiting to happen.
@
text
@a1151 20

	internal override string GetGenericSignature()
	{
		throw new InvalidOperationException("GetGenericSignature called on " + this);
	}

	internal override string GetGenericMethodSignature(MethodWrapper mw)
	{
		throw new InvalidOperationException("GetGenericMethodSignature called on " + this);
	}

	internal override string GetGenericFieldSignature(FieldWrapper fw)
	{
		throw new InvalidOperationException("GetGenericFieldSignature called on " + this);
	}

	internal override string[] GetEnclosingMethod()
	{
		throw new InvalidOperationException("GetEnclosingMethod called on " + this);
	}
@


1.55
log
@Removed code that is no longer used (because of the jsr/ret split off) from instruction state merging.
@
text
@d100 8
d829 1
@


1.54
log
@Fixed bug in local variable store site merging.
@
text
@a163 5
		return Merge(s1, s2, null, null);
	}

	internal static InstructionState Merge(InstructionState s1, InstructionState s2, bool[] locals_modified, InstructionState s3)
	{
d166 1
a166 15
			s2 = s2.Copy();
			if(locals_modified != null)
			{
				for(int i = 0; i < s2.locals.Length; i++)
				{
					if(!locals_modified[i])
					{
						s2.LocalsCopyOnWrite();
						s2.locals[i] = s3.locals[i];
						s2.LocalStoreSitesCopyOnWrite();
						s2.localStoreSites[i] = s3.localStoreSites[i].Copy();
					}
				}
			}
			return s2;
d226 1
a226 1
			TypeWrapper type2;
d228 1
a228 11
			LocalStoreSites storeSites2;
			if(locals_modified == null || locals_modified[i])
			{
				type2 = s2.locals[i];
				storeSites2 = s2.localStoreSites[i];
			}
			else
			{
				type2 = s3.locals[i];
				storeSites2 = s3.localStoreSites[i];
			}
@


1.53
log
@Removed unnecessary IsEmpty property from LocalStoreSites.
@
text
@d289 1
a289 1
			return h2.Copy();
@


1.52
log
@Removed jsr/ret support.
@
text
@a60 8
		internal bool IsEmpty
		{
			get
			{
				return data == null;
			}
		}

d266 1
a266 1
			if(!storeSites.IsEmpty && (s.localStoreSites[i].IsEmpty || storeSites.Count != s.localStoreSites[i].Count))
d283 1
a283 1
		if(h1.IsEmpty)
d287 1
a287 1
		if(h2.IsEmpty)
d541 1
a541 1
			if(!localStoreSites[index].IsEmpty)
d543 1
a543 4
				for(int i = 0; i < localStoreSites[index].Count; i++)
				{
					readers[localStoreSites[index][i]] = "";
				}
@


1.51
log
@Changed bytecode stream and exception tables to use instruction indexes instead of PC.
@
text
@a36 44
class Subroutine
{
	private int subroutineIndex;
	private bool[] localsModified;

	private Subroutine(int subroutineIndex, bool[] localsModified)
	{
		this.subroutineIndex = subroutineIndex;
		this.localsModified = localsModified;
	}

	internal Subroutine(int subroutineIndex, int maxLocals)
	{
		this.subroutineIndex = subroutineIndex;
		localsModified = new bool[maxLocals];
	}

	internal int SubroutineIndex
	{
		get
		{
			return subroutineIndex;
		}
	}

	internal bool[] LocalsModified
	{
		get
		{
			return localsModified;
		}
	}

	internal void SetLocalModified(int local)
	{
		localsModified[local] = true;
	}

	internal Subroutine Copy()
	{
		return new Subroutine(subroutineIndex, (bool[])localsModified.Clone());
	}
}

a113 2
	private List<Subroutine> subroutines;
	private int callsites;
d122 1
a122 2
		Subroutines = 8,
		All = Stack | Locals | LocalStoreSites | Subroutines
d126 1
a126 1
	private InstructionState(TypeWrapper[] stack, int stackSize, int stackEnd, TypeWrapper[] locals, LocalStoreSites[] localStoreSites, List<Subroutine> subroutines, int callsites, bool unitializedThis)
a133 2
		this.subroutines = subroutines;
		this.callsites = callsites;
d148 1
a148 1
		return new InstructionState(stack, stackSize, stackEnd, locals, localStoreSites, subroutines, callsites, unitializedThis);
a158 2
		target.subroutines = subroutines;
		target.callsites = callsites;
d163 1
a163 1
	internal InstructionState CopyLocalsAndSubroutines()
d165 1
a165 1
		InstructionState copy = new InstructionState(new TypeWrapper[stack.Length], 0, stack.Length, locals, localStoreSites, subroutines, callsites, unitializedThis);
a169 14
	private static List<Subroutine> CopySubroutines(List<Subroutine> l)
	{
		if(l == null)
		{
			return null;
		}
		List<Subroutine> n = new List<Subroutine>(l.Count);
		foreach(Subroutine s in l)
		{
			n.Add(s.Copy());
		}
		return n;
	}

a174 47
	private void MergeSubroutineHelper(InstructionState s2)
	{
		if(subroutines == null || s2.subroutines == null)
		{
			if(subroutines != null)
			{
				subroutines = null;
				changed = true;
			}
		}
		else
		{
			SubroutinesCopyOnWrite();
			List<Subroutine> ss1 = subroutines;
			subroutines = new List<Subroutine>();
			foreach(Subroutine ss2 in s2.subroutines)
			{
				foreach(Subroutine ss in ss1)
				{
					if(ss.SubroutineIndex == ss2.SubroutineIndex)
					{
						subroutines.Add(ss);
						for(int i = 0; i < ss.LocalsModified.Length; i++)
						{
							if(ss2.LocalsModified[i] && !ss.LocalsModified[i])
							{
								ss.LocalsModified[i] = true;
								changed = true;
							}
						}
					}
				}
			}
			if(ss1.Count != subroutines.Count)
			{
				changed = true;
			}
		}

		if(s2.callsites > callsites)
		{
			//Console.WriteLine("s2.callsites = {0}, callsites = {1}", s2.callsites, callsites);
			callsites = s2.callsites;
			changed = true;
		}
	}

a192 4
			if(s3 != null)
			{
				s2.MergeSubroutineHelper(s3);
			}
d236 1
a236 10
					// if we never return from a subroutine, it is legal to merge to subroutine flows
					// (this is from the Mauve test subr.pass.mergeok)
					if(VerifierTypeWrapper.IsRet(type) && VerifierTypeWrapper.IsRet(type2))
					{
						baseType = VerifierTypeWrapper.Invalid;
					}
					else
					{
						throw new VerifyError(string.Format("cannot merge {0} and {1}", type.Name, type2.Name));
					}
a285 5
		s.MergeSubroutineHelper(s2);
		if(s3 != null)
		{
			s.MergeSubroutineHelper(s3);
		}
a319 63
	internal void AddCallSite()
	{
		callsites++;
		changed = true;
	}

	internal void SetSubroutineId(int subroutineIndex)
	{
		SubroutinesCopyOnWrite();
		if(subroutines == null)
		{
			subroutines = new List<Subroutine>();
		}
		else
		{
			foreach(Subroutine s in subroutines)
			{
				if(s.SubroutineIndex == subroutineIndex)
				{
					// subroutines cannot recursivly call themselves
					throw new VerifyError("subroutines cannot recurse");
				}
			}
		}
		subroutines.Add(new Subroutine(subroutineIndex, locals.Length));
	}

	internal bool[] ClearSubroutineId(int subroutineIndex)
	{
		SubroutinesCopyOnWrite();
		if(subroutines != null)
		{
			foreach(Subroutine s in subroutines)
			{
				if(s.SubroutineIndex == subroutineIndex)
				{
					// TODO i'm not 100% sure about this, but I think we need to clear
					// the subroutines here (because when you return you can never "become" inside a subroutine)
					// UPDATE the above is incorrect, we only need to remove the subroutine we're actually
					// returning from
					subroutines.Remove(s);
					return s.LocalsModified;
				}
			}
		}
		throw new VerifyError("return from wrong subroutine");
	}

	internal void CheckSubroutineActive(int subroutineIndex)
	{
		if(subroutines != null)
		{
			foreach(Subroutine s in subroutines)
			{
				if(s.SubroutineIndex == subroutineIndex)
				{
					return;
				}
			}
		}
		throw new VerifyError("inactive subroutine");
	}

a349 4
		if(VerifierTypeWrapper.IsRet(type1) || VerifierTypeWrapper.IsRet(type2))
		{
			return VerifierTypeWrapper.Invalid;
		}
a447 1
			SubroutinesCopyOnWrite();
a450 7
				if(subroutines != null)
				{
					foreach(Subroutine s in subroutines)
					{
						s.SetLocalModified(index - 1);
					}
				}
a452 7
			if(subroutines != null)
			{
				foreach(Subroutine s in subroutines)
				{
					s.SetLocalModified(index);
				}
			}
a464 1
			SubroutinesCopyOnWrite();
a467 7
				if(subroutines != null)
				{
					foreach(Subroutine s in subroutines)
					{
						s.SetLocalModified(index - 1);
					}
				}
a470 8
			if(subroutines != null)
			{
				foreach(Subroutine s in subroutines)
				{
					s.SetLocalModified(index);
					s.SetLocalModified(index + 1);
				}
			}
a571 10
	internal int GetLocalRet(int index, ref Dictionary<int, string> readers)
	{
		TypeWrapper type = GetLocalType(index, ref readers);
		if(VerifierTypeWrapper.IsRet(type))
		{
			return ((VerifierTypeWrapper)type).Index;
		}
		throw new VerifyError("incorrect local type, not ret");
	}

d670 1
a670 1
	// null or an initialized object reference (or a subroutine return address)
a864 9
	private void SubroutinesCopyOnWrite()
	{
		if((flags & ShareFlags.Subroutines) != 0)
		{
			flags &= ~ShareFlags.Subroutines;
			subroutines = CopySubroutines(subroutines);
		}
	}

a890 16
	internal void DumpSubroutines()
	{
		Console.Write("// subs: ");
		string sep = "";
		if(subroutines != null)
		{
			for(int i = 0; i < subroutines.Count; i++)
			{
				Console.Write(sep);
				Console.Write(((Subroutine)subroutines[i]).SubroutineIndex);
				sep = ", ";
			}
		}
		Console.WriteLine();
	}

a1088 5
	internal static TypeWrapper MakeRet(int bytecodeIndex)
	{
		return new VerifierTypeWrapper("ret", bytecodeIndex, null);
	}

a1103 5
	internal static bool IsRet(TypeWrapper w)
	{
		return w != null && w.IsVerifierType && ReferenceEquals(w.Name, "ret");
	}

a1253 1
	private List<int>[] callsites;
a1280 1
		callsites = new List<int>[method.Instructions.Length];
d1284 1
a1284 2
		// HACK because types have to have identity, the subroutine return address and new types are cached here
		Dictionary<int, TypeWrapper> returnAddressTypes = new Dictionary<int,TypeWrapper>();
d1303 1
d1369 1
a1369 8
								// NOTE this used to be CopyLocalsAndSubroutines, but it doesn't (always) make
								// sense to copy the subroutine state
								// TODO figure out if there are circumstances under which it does make sense
								// to copy the active subroutine state
								// UPDATE subroutines must be copied as well, but I think I now have a better
								// understanding of subroutine merges, so the problems that triggered the previous
								// change here hopefully won't arise anymore
								InstructionState ex = state[i].CopyLocalsAndSubroutines();
a2259 11
							case NormalizedByteCode.__jsr:
								// TODO make sure we're not calling a subroutine we're already in
								break;
							case NormalizedByteCode.__ret:
							{
								// TODO if we're returning from a higher level subroutine, invalidate
								// all the intermediate return addresses
								int subroutineIndex = s.GetLocalRet(instr.Arg1, ref localStoreReaders[i]);
								s.CheckSubroutineActive(subroutineIndex);
								break;
							}
a2307 34
								case NormalizedByteCode.__jsr:
								{
									if((instr.flags & InstructionFlags.JsrHasRet) != 0)
									{
										state[i + 1] += s;
									}
									int index = instr.TargetIndex;
									s.SetSubroutineId(index);
									TypeWrapper retAddressType;
									if(!returnAddressTypes.TryGetValue(index, out retAddressType))
									{
										retAddressType = VerifierTypeWrapper.MakeRet(index);
										returnAddressTypes[index] = retAddressType;
									}
									s.PushType(retAddressType);
									state[index] += s;
									AddCallSite(index, i);
									break;
								}
								case NormalizedByteCode.__ret:
								{
									// HACK if the ret is processed before all of the jsr instructions to this subroutine
									// we wouldn't be able to properly merge, so that is why we track the number of callsites
									// for each subroutine instruction (see Instruction.AddCallSite())
									int subroutineIndex = s.GetLocalRet(instr.Arg1, ref localStoreReaders[i]);
									int[] cs = GetCallSites(subroutineIndex);
									bool[] locals_modified = s.ClearSubroutineId(subroutineIndex);
									for(int j = 0; j < cs.Length; j++)
									{
										state[cs[j] + 1] = InstructionState.Merge(state[cs[j] + 1], s, locals_modified, state[cs[j]]);
										instructions[cs[j]].flags |= InstructionFlags.JsrHasRet;
									}
									break;
								}
a2386 1
			bool didJsrOrRet = false;
a2602 15
						case NormalizedByteCode.__jsr:
							state[i].CheckUninitializedObjRefs();
							instructions[instructions[i].TargetIndex].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
							// Note that we don't mark the next instruction as reachable,
							// because that depends on the corresponding ret actually being
							// reachable. We handle this in the loop below.
							didJsrOrRet = true;
							break;
						case NormalizedByteCode.__ret:
							// Note that we can't handle ret here, because we might encounter the ret
							// before having seen all the corresponding jsr instructions, so we can't
							// update all the call sites.
							// We handle ret in the loop below.
							didJsrOrRet = true;
							break;
a2617 19
			if(didJsrOrRet)
			{
				for(int i = 0; i < instructions.Length; i++)
				{
					if(instructions[i].NormalizedOpCode == NormalizedByteCode.__ret
						&& instructions[i].IsReachable)
					{
						int subroutineIndex = state[i].GetLocalRet(instructions[i].Arg1, ref localStoreReaders[i]);
						int[] cs = GetCallSites(subroutineIndex);
						for(int j = 0; j < cs.Length; j++)
						{
							if(instructions[cs[j]].IsReachable)
							{
								instructions[cs[j] + 1].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
							}
						}
					}
				}
			}
a3393 19
	private void AddCallSite(int subroutineIndex, int callSiteIndex)
	{
		if(callsites[subroutineIndex] == null)
		{
			callsites[subroutineIndex] = new List<int>();
		}
		List<int> l = callsites[subroutineIndex];
		if(l.IndexOf(callSiteIndex) == -1)
		{
			l.Add(callSiteIndex);
			state[subroutineIndex].AddCallSite();
		}
	}

	internal int[] GetCallSites(int subroutineIndex)
	{
		return callsites[subroutineIndex].ToArray();
	}

@


1.50
log
@Handle invokespecials that have been turned into errors in local variable analysis.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
a1564 1
			int end_pc = method.Instructions[method.Instructions.Length - 1].PC;
d1568 4
a1571 6
				int start = method.PcIndexMap[method.ExceptionTable[i].start_pc];
				int end = method.PcIndexMap[method.ExceptionTable[i].end_pc];
				int handler = method.PcIndexMap[method.ExceptionTable[i].handler_pc];
				if((start >= end && end != -1) || start == -1 ||
					(end == -1 && method.ExceptionTable[i].end_pc != end_pc) ||
					handler <= 0)
d1642 1
a1642 1
							if(method.ExceptionTable[j].start_pc <= instructions[i].PC && method.ExceptionTable[j].end_pc > instructions[i].PC)
d1663 1
a1663 1
								int idx = method.PcIndexMap[method.ExceptionTable[j].handler_pc];
d2136 1
a2136 1
								if(!newTypes.TryGetValue(instr.PC, out type))
d2143 2
a2144 2
									type = VerifierTypeWrapper.MakeNew(type, instr.PC);
									newTypes[instr.PC] = type;
d2575 1
a2575 1
										state[method.PcIndexMap[instr.PC + instr.GetSwitchTargetOffset(j)]] += s;
d2577 1
a2577 1
									state[method.PcIndexMap[instr.PC + instr.DefaultOffset]] += s;
d2596 1
a2596 1
									state[method.PcIndexMap[instr.PC + instr.Arg1]] += s;
d2599 1
a2599 1
									state[method.PcIndexMap[instr.PC + instr.Arg1]] += s;
d2607 1
a2607 1
									int index = method.PcIndexMap[instr.PC + instr.Arg1];
d2692 1
a2692 1
						&& instructions[i + 1].Arg1 > 0
d2701 1
a2701 1
							instructions[i].PatchOpCode(NormalizedByteCode.__goto, instructions[i + 1].Arg1 + 3);
d2870 1
a2870 1
						if(method.ExceptionTable[j].start_pc <= instructions[i].PC && method.ExceptionTable[j].end_pc > instructions[i].PC)
d2872 1
a2872 1
							instructions[method.PcIndexMap[method.ExceptionTable[j].handler_pc]].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2884 2
a2885 2
								hasbackbranch |= instructions[i].GetSwitchTargetOffset(j) < 0;
								instructions[method.PcIndexMap[instructions[i].PC + instructions[i].GetSwitchTargetOffset(j)]].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2887 2
a2888 2
							hasbackbranch |= instructions[i].DefaultOffset < 0;
							instructions[method.PcIndexMap[instructions[i].PC + instructions[i].DefaultOffset]].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2898 1
a2898 1
							if(instructions[i].Arg1 < 0)
d2904 1
a2904 1
							instructions[method.PcIndexMap[instructions[i].PC + instructions[i].Arg1]].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2922 1
a2922 1
							if(instructions[i].Arg1 < 0)
d2928 1
a2928 1
							instructions[method.PcIndexMap[instructions[i].PC + instructions[i].Arg1]].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
d2933 1
a2933 1
							instructions[method.PcIndexMap[instructions[i].PC + instructions[i].Arg1]].flags |= InstructionFlags.Reachable | InstructionFlags.BranchTarget;
@


1.50.2.1
log
@- Changed version to 0.40.0.2
- Added rmic step to build to remove dependency on .class files
- Fixed verifier bug in merging of jsr/ret state
- Fixed verifier bugs that could cause potential LocalStoreSites corruption
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
a151 8

		internal static void MarkShared(LocalStoreSites[] localStoreSites)
		{
			for(int i = 0; i < localStoreSites.Length; i++)
			{
				localStoreSites[i].shared = true;
			}
		}
d235 5
d287 1
a287 1
	internal static InstructionState MergeSubroutineReturn(InstructionState jsrSuccessor, InstructionState jsr, InstructionState ret, bool[] locals_modified)
d289 1
a289 4
		InstructionState next = ret.Copy();
		next.LocalsCopyOnWrite();
		next.LocalStoreSitesCopyOnWrite();
		for (int i = 0; i < locals_modified.Length; i++)
d291 15
a305 1
			if (!locals_modified[i])
d307 1
a307 2
				next.locals[i] = jsr.locals[i];
				next.localStoreSites[i] = jsr.localStoreSites[i];
d309 1
a309 12
		}
		next.flags |= ShareFlags.Subroutines;
		next.subroutines = jsr.subroutines;
		next.callsites = jsr.callsites;
		return jsrSuccessor + next;
	}

	public static InstructionState operator+(InstructionState s1, InstructionState s2)
	{
		if(s1 == null)
		{
			return s2.Copy();
d378 1
a378 1
			TypeWrapper type2 = s2.locals[i];
d380 11
a390 1
			LocalStoreSites storeSites2 = s2.localStoreSites[i];
d412 4
d427 1
a427 1
			return h1.Copy();
d477 1
a477 1
	internal bool[] GetLocalsModified(int subroutineIndex)
d479 1
d486 5
a1098 1
			LocalStoreSites.MarkShared(localStoreSites);
a1527 1
	private List<int>[] returnsites;
a1555 1
		returnsites = new List<int>[method.Instructions.Length];
d2606 4
a2619 8
									List<int> returns = GetReturnSites(i);
									if(returns != null)
									{
										foreach(int returnIndex in returns)
										{
											state[i + 1] = InstructionState.MergeSubroutineReturn(state[i + 1], s, state[returnIndex], state[returnIndex].GetLocalsModified(index));
										}
									}
d2630 1
a2630 1
									bool[] locals_modified = s.GetLocalsModified(subroutineIndex);
d2633 2
a2634 2
										AddReturnSite(cs[j], i);
										state[cs[j] + 1] = InstructionState.MergeSubroutineReturn(state[cs[j] + 1], state[cs[j]], s, locals_modified);
a3758 19
	private void AddReturnSite(int callSiteIndex, int returnSiteIndex)
	{
		if(returnsites[callSiteIndex] == null)
		{
			returnsites[callSiteIndex] = new List<int>();
		}
		List<int> l = returnsites[callSiteIndex];
		if(l.IndexOf(returnSiteIndex) == -1)
		{
			state[callSiteIndex].changed = true;
			l.Add(returnSiteIndex);
		}
	}

	private List<int> GetReturnSites(int callSiteIndex)
	{
		return returnsites[callSiteIndex];
	}

@


1.49
log
@Make ikvmc emit a warning whenever it emits code that throws a hard error.
@
text
@d3578 5
@


1.48
log
@Fix bug in handling of jsr instruction.
@
text
@d2770 1
a2770 1
									instructions[i].SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(tw.Name));
d2781 1
a2781 1
								instructions[i].SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(tw.Name));
d2786 1
a2786 1
								instructions[i].SetHardError(HardError.IllegalAccessError, AllocErrorMessage("Try to access class " + tw.Name + " from class " + wrapper.Name));
d2790 1
a2790 1
								instructions[i].SetHardError(HardError.InstantiationError, AllocErrorMessage(tw.Name));
d2801 1
a2801 1
								instructions[i].SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(tw.Name));
d2806 1
a2806 1
								instructions[i].SetHardError(HardError.IllegalAccessError, AllocErrorMessage("Try to access class " + tw.Name + " from class " + wrapper.Name));
d2823 1
a2823 1
								instructions[i].SetHardError(HardError.IllegalAccessError, AllocErrorMessage("Try to access class " + tw.Name + " from class " + wrapper.Name));
d2837 1
a2837 1
								instructions[i].SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(tw.Name));
d2858 1
a2858 1
								instructions[i].SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(tw.Name));
d3105 39
d3251 1
a3251 1
			instr.SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(cpi.GetClassType().Name));
d3271 1
a3271 1
						instr.SetHardError(HardError.LinkageError, AllocErrorMessage("Base class no longer loadable"));
d3281 1
a3281 1
			instr.SetHardError(HardError.IncompatibleClassChangeError, AllocErrorMessage("invokeinterface on non-interface"));
d3291 1
a3291 1
					instr.SetHardError(HardError.LinkageError, AllocErrorMessage(errmsg));
d3297 1
a3297 1
						instr.SetHardError(HardError.AbstractMethodError, AllocErrorMessage(cpi.Class + "." + cpi.Name + cpi.Signature));
d3316 1
a3316 1
						instr.SetHardError(HardError.IllegalAccessError, AllocErrorMessage("Try to access method " + targetMethod.DeclaringType.Name + "." + cpi.Name + cpi.Signature + " from class " + wrapper.Name));
d3321 1
a3321 1
					instr.SetHardError(HardError.IncompatibleClassChangeError, AllocErrorMessage("static call to non-static method (or v.v.)"));
d3326 1
a3326 1
				instr.SetHardError(HardError.NoSuchMethodError, AllocErrorMessage(cpi.Class + "." + cpi.Name + cpi.Signature));
d3416 1
a3416 1
			instr.SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(cpi.GetClassType().Name));
d3443 1
a3443 1
				instr.SetHardError(HardError.NoSuchFieldError, AllocErrorMessage(cpi.Class + "." + cpi.Name));
d3451 1
a3451 1
				instr.SetHardError(HardError.LinkageError, AllocErrorMessage("Loader constraints violated: " + field.DeclaringType.Name + "." + field.Name));
d3456 1
a3456 1
				instr.SetHardError(HardError.IncompatibleClassChangeError, AllocErrorMessage("Static field access to non-static field (or v.v.)"));
d3461 1
a3461 1
				instr.SetHardError(HardError.IllegalAccessError, AllocErrorMessage("Try to access field " + field.DeclaringType.Name + "." + field.Name + " from class " + wrapper.Name));
d3468 1
a3468 1
				instr.SetHardError(HardError.IllegalAccessError, AllocErrorMessage("Field " + field.DeclaringType.Name + "." + field.Name + " is final"));
@


1.47
log
@Generified all collections.
@
text
@d29 3
d33 1
d2606 4
d2634 1
@


1.47.2.1
log
@- Changed version to 0.38.0.2
- Fixed openjdk.build BOM issue on Linux
- Fixed verifier bug in handling of jsr instruction
@
text
@a2601 4
									if((instr.flags & InstructionFlags.JsrHasRet) != 0)
									{
										state[i + 1] += s;
									}
a2625 1
										instructions[cs[j]].flags |= InstructionFlags.JsrHasRet;
@


1.46
log
@Replaced explicit usage of System.Reflection.Emit types with "using System.Reflection.Emit;" to make switching to Cecil easier.
@
text
@d27 1
a27 1
using System.Collections;
d154 1
a154 1
	private ArrayList subroutines;
d169 1
a169 1
	private InstructionState(TypeWrapper[] stack, int stackSize, int stackEnd, TypeWrapper[] locals, LocalStoreSites[] localStoreSites, ArrayList subroutines, int callsites, bool unitializedThis)
d217 1
a217 1
	private static ArrayList CopySubroutines(ArrayList l)
d223 1
a223 1
		ArrayList n = new ArrayList(l.Count);
d249 2
a250 2
			ArrayList ss1 = subroutines;
			subroutines = new ArrayList();
d457 1
a457 1
			subroutines = new ArrayList();
d611 2
a612 2
		Stack st1 = new Stack();
		Stack st2 = new Stack();
d626 2
a627 2
			t1 = st1.Count > 0 ? (TypeWrapper)st1.Pop() : null;
			t2 = st2.Count > 0 ? (TypeWrapper)st2.Pop() : null;
d709 1
a709 1
	internal void GetLocalInt(int index, ref Hashtable readers)
d723 1
a723 1
	internal void GetLocalLong(int index, ref Hashtable readers)
d737 1
a737 1
	internal void GetLocalFloat(int index, ref Hashtable readers)
d751 1
a751 1
	internal void GetLocalDouble(int index, ref Hashtable readers)
d765 1
a765 1
	internal TypeWrapper GetLocalType(int index, ref Hashtable readers)
d771 1
a771 1
				readers = new Hashtable();
d796 1
a796 1
	internal int GetLocalRet(int index, ref Hashtable readers)
d1523 1
a1523 1
	private ArrayList[] callsites;
d1527 1
a1527 1
	private ArrayList errorMessages;
d1551 1
a1551 1
		callsites = new ArrayList[method.Instructions.Length];
d1553 1
a1553 1
		Hashtable/*<int,ignored>*/[] localStoreReaders = new Hashtable[method.Instructions.Length];
d1556 2
a1557 2
		Hashtable returnAddressTypes = new Hashtable();
		Hashtable newTypes = new Hashtable();
d2134 2
a2135 2
								TypeWrapper type = (TypeWrapper)newTypes[instr.PC];
								if(type == null)
d2604 2
a2605 2
									TypeWrapper retAddressType = (TypeWrapper)returnAddressTypes[index];
									if(retAddressType == null)
d2977 2
a2978 2
		Hashtable/*<string,LocalVar>*/ localByStoreSite = new Hashtable();
		ArrayList/*<LocalVar>*/ locals = new ArrayList();
d2986 1
a2986 1
		Hashtable forwarders = new Hashtable();
d3064 1
a3064 1
					v = (LocalVar)localByStoreSite[MakeKey(store, instructions[i].NormalizedArg1)];
d3075 1
a3075 1
						invokespecialLocalVars[i][j] = (LocalVar)localByStoreSite[MakeKey(i, j)];
d3080 1
a3080 1
					v = (LocalVar)localByStoreSite[MakeKey(i, instructions[i].NormalizedArg1)];
d3085 2
a3086 2
				LocalVar fwd = (LocalVar)forwarders[v];
				if(fwd != null)
d3093 1
a3093 1
		this.allLocalVars = (LocalVar[])locals.ToArray(typeof(LocalVar));
d3451 1
a3451 1
			errorMessages = new ArrayList();
d3453 3
a3455 1
		return errorMessages.Add(message);
d3460 1
a3460 1
		return (string)errorMessages[messageId];
d3509 1
a3509 1
	private void VisitLocalLoads(ArrayList locals, Hashtable localByStoreSite, Hashtable storeSites, int instructionIndex, bool debug)
d3539 2
a3540 2
			LocalVar l = (LocalVar)localByStoreSite[MakeKey(store, localIndex)];
			if(l != null)
d3588 2
a3589 2
			LocalVar v = (LocalVar)localByStoreSite[MakeKey(store, localIndex)];
			if(v == null)
d3600 1
a3600 1
	private static object MakeKey(int i, int j)
d3605 1
a3605 1
	private static LocalVar MergeLocals(ArrayList locals, Hashtable localByStoreSite, LocalVar l1, LocalVar l2)
d3617 1
a3617 1
		Hashtable temp = (Hashtable)localByStoreSite.Clone();
d3619 1
a3619 1
		foreach(DictionaryEntry de in temp)
d3621 1
a3621 1
			localByStoreSite[de.Key] = de.Value == l2 ? l1 : de.Value;
d3710 1
a3710 1
			callsites[subroutineIndex] = new ArrayList();
d3712 1
a3712 1
		ArrayList l = (ArrayList)callsites[subroutineIndex];
d3722 1
a3722 1
		return (int[])((ArrayList)callsites[subroutineIndex]).ToArray(typeof(int));
@


1.45
log
@Restructured code to remove (mcs) compiler warnings.
@
text
@d29 1
d1479 1
a1479 1
	internal System.Reflection.Emit.LocalBuilder builder;
@


1.44
log
@- Added -removeassertions optimization option to ikvmc.
- Added -removeassertions to IKVM.OpenJDK.ClassLibrary.dll build.
- Don't look at unreachable instructions when determining if a method needs a line number table.
@
text
@a2756 1
#if STATIC_COMPILER
d2759 1
d2761 1
a2762 1
#endif
@


1.43
log
@Handle converting forms of fstore/dstore to prevent Debug.Assert from firing.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d2664 37
@


1.42
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d3464 3
a3466 1
			bc == NormalizedByteCode.__dstore;
@


1.41
log
@Implemented improved floating point compliance.
@
text
@a28 1
using IKVM.Runtime;
@


1.41.2.1
log
@- Added -removeassertions optimization option to ikvmc.
- Removed hack from map.xml to remove assertions from java.util.BitSet.checkInvariants().
- Added -removeassertions to IKVM.OpenJDK.ClassLibrary.dll build.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
d29 1
a2664 37
		// Optimization pass
		if (classLoader.RemoveAsserts)
		{
			FieldWrapper assertionsDisabled = null;
			foreach (FieldWrapper fw in wrapper.GetFields())
			{
				// HACK we assume that all compilers use the same name for this field (ecj and javac do)
				if (fw.Name == "$assertionsDisabled" && fw.Signature == "Z"
					&& (fw.Modifiers & (IKVM.Attributes.Modifiers.AccessMask | IKVM.Attributes.Modifiers.Final | IKVM.Attributes.Modifiers.Static | IKVM.Attributes.Modifiers.Synthetic))
						== (IKVM.Attributes.Modifiers.Static | IKVM.Attributes.Modifiers.Final | IKVM.Attributes.Modifiers.Synthetic))
				{
					assertionsDisabled = fw;
					break;
				}
			}
			if (assertionsDisabled != null)
			{
				for (int i = 0; i < instructions.Length; i++)
				{
					if (instructions[i].NormalizedOpCode == NormalizedByteCode.__getstatic
						&& instructions[i + 1].NormalizedOpCode == NormalizedByteCode.__ifne
						&& instructions[i + 1].Arg1 > 0
						&& !instructions[i + 1].IsBranchTarget)
					{
						ClassFile.ConstantPoolItemFieldref cpi = classFile.GetFieldref(instructions[i].Arg1);
						if (cpi.GetField() == assertionsDisabled)
						{
							// We've found an assertion. We patch the instruction to branch around it so that
							// the assertion code will be unreachable (and hence optimized away).
							// Note that the goto will be optimized away later by the code generator (which removes unnecessary branches).
							instructions[i].PatchOpCode(NormalizedByteCode.__goto, instructions[i + 1].Arg1 + 3);
						}
					}
				}
			}
		}

d3465 1
a3465 3
			bc == NormalizedByteCode.__dstore ||
			bc == NormalizedByteCode.__fstore_conv ||
			bc == NormalizedByteCode.__dstore_conv;
@


1.40
log
@Fixed verifier/compiler to support dup_x2 form 2. Found by Derby test suite. Thanks to Albert Strasheim.
@
text
@d318 2
a319 1
			if(type == s2.stack[i])
d323 20
d345 1
a345 1
				TypeWrapper baseType = InstructionState.FindCommonBaseType(type, s2.stack[i]);
d350 1
a350 1
					if(VerifierTypeWrapper.IsRet(type) && VerifierTypeWrapper.IsRet(s2.stack[i]))
d356 1
a356 1
						throw new VerifyError(string.Format("cannot merge {0} and {1}", type.Name, s2.stack[i].Name));
d368 1
a368 1
				throw new VerifyError(string.Format("cannot merge {0} and {1}", type.Name, s2.stack[i].Name));
d843 5
d853 5
d866 1
a866 1
	internal void PopFloat()
d868 2
a869 1
		if(PopAnyType() != PrimitiveTypeWrapper.FLOAT)
d873 1
d876 1
a876 1
	internal void PopDouble()
d878 2
a879 1
		if(PopAnyType() != PrimitiveTypeWrapper.DOUBLE)
d883 1
d952 1
a952 1
		if(type.IsWidePrimitive)
d967 1
a967 1
		if(type.IsWidePrimitive)
d998 8
d1018 10
a1027 1
		return stack[stackSize - 1 - pos];
d1037 1
a1037 1
		if(type.IsWidePrimitive)
d1232 8
d1249 1
a1249 1
		if(type.IsWidePrimitive)
d1266 2
a1267 1
		if(PopAnyType() != PrimitiveTypeWrapper.FLOAT)
d1275 2
a1276 1
		if(PopAnyType() != PrimitiveTypeWrapper.DOUBLE)
d1332 2
d2026 8
d2094 8
a2101 2
								s.PopFloat();
								s.PushFloat();
d2110 1
a2110 1
								s.PushFloat();
d2113 8
a2120 2
								s.PopDouble();
								s.PushDouble();
d2129 1
a2129 1
								s.PushDouble();
d2230 1
a2230 1
								if(t.IsWidePrimitive)
d2257 1
a2257 1
								if(value1.IsWidePrimitive)
d2280 1
a2280 1
								if(value2.IsWidePrimitive)
d2299 1
a2299 1
								if(value1.IsWidePrimitive)
d2302 1
a2302 1
									if(value2.IsWidePrimitive)
d2323 1
a2323 1
									if(value3.IsWidePrimitive)
d2352 1
a2352 1
								if(!type.IsWidePrimitive)
d2681 24
@


1.39
log
@- Changed ikvmc to fail with a Link Error when it detects a loader constraints violation (instead of emitting code that throws a LinkageError at runtime).
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d2195 15
a2209 6
								TypeWrapper value2 = s.PopType();
								TypeWrapper value3 = s.PopType();
								s.PushType(value1);
								s.PushType(value3);
								s.PushType(value2);
								s.PushType(value1);
@


1.39.2.1
log
@Back ported the dup_x2 fix.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d2195 6
a2200 15
								TypeWrapper value2 = s.PopAnyType();
								if(value2.IsWidePrimitive)
								{
									s.PushType(value1);
									s.PushType(value2);
									s.PushType(value1);
								}
								else
								{
									TypeWrapper value3 = s.PopType();
									s.PushType(value1);
									s.PushType(value3);
									s.PushType(value2);
									s.PushType(value1);
								}
@


1.38
log
@*** empty log message ***
@
text
@d3246 3
d3311 3
d3322 3
@


1.37
log
@*** empty log message ***
@
text
@a1273 8
	internal override System.Reflection.Assembly Assembly
	{
		get
		{
			return null;
		}
	}

@


1.36
log
@*** empty log message ***
@
text
@d1424 1
a1424 1
	// used to emit debugging info, only available if JVM.Debug is true
d2837 1
a2837 1
				VisitLocalLoads(locals, localByStoreSite, localStoreReaders[i], i);
d2841 1
a2841 1
		if(JVM.Debug)
d3269 1
a3269 1
				&& ((isStatic ? wrapper != cpi.GetClassType() : wrapper != thisType) || (JVM.StrictFinalFieldSemantics && (isStatic ? (mw != null && mw.Name != "<clinit>") : (mw == null || mw.Name != "<init>")))))
d3350 1
a3350 1
	private void VisitLocalLoads(ArrayList locals, Hashtable localByStoreSite, Hashtable storeSites, int instructionIndex)
d3415 1
a3415 1
			if(JVM.Debug)
@


1.35
log
@*** empty log message ***
@
text
@d1514 1
a1514 1
					handler == -1)
d1522 1
a1522 1
			throw new VerifyError(string.Format("Illegal exception table (class: {0}, method: {1}, signature: {2}", classFile.Name, method.Name, method.Signature));
d3007 1
a3007 1
					// doesn't run either (or so I believe)
d3038 12
a3049 4
					// NOTE previously we checked the type here, but it turns out that
					// the JVM throws an IncompatibleClassChangeError at runtime instead
					// of a VerifyError if this doesn't match
					stack.PopObjectType();
@


1.34
log
@*** empty log message ***
@
text
@d1533 1
a1533 1
			if(ReferenceEquals(method.Name, "<init>"))
d1940 1
a1940 1
									if(ReferenceEquals(cpi.Name, "<init>"))
d2957 1
a2957 1
		if(instr.NormalizedOpCode != NormalizedByteCode.__invokespecial && ReferenceEquals(cpi.Name, "<init>"))
d2961 1
a2961 1
		if(ReferenceEquals(cpi.Name, "<clinit>"))
d2995 1
a2995 1
			if(ReferenceEquals(cpi.Name, "<init>"))
d3108 1
a3108 1
							&& ReferenceEquals(cpi.Name, "clone"))
@


1.33
log
@*** empty log message ***
@
text
@d1309 1
a1309 1
		return w != null && w.IsVerifierType && w.Name == "new";
d1314 1
a1314 1
		return w != null && w.IsVerifierType && w.Name == "ret";
d1324 1
a1324 1
		return w != null && w.IsVerifierType && w.Name == "this";
d1533 1
a1533 1
			if(method.Name == "<init>")
d1940 1
a1940 1
									if(cpi.Name == "<init>")
d2848 1
a2848 1
					if(!localByStoreSite.ContainsKey(i + ":" + instructions[i].NormalizedArg1))
d2855 1
a2855 1
						localByStoreSite.Add(i + ":" + v.local, v);
d2918 1
a2918 1
					v = (LocalVar)localByStoreSite[store + ":" + instructions[i].NormalizedArg1];
d2929 1
a2929 1
						invokespecialLocalVars[i][j] = (LocalVar)localByStoreSite[i + ":" + j];
d2934 1
a2934 1
					v = (LocalVar)localByStoreSite[i + ":" + instructions[i].NormalizedArg1];
d2957 1
a2957 1
		if(instr.NormalizedOpCode != NormalizedByteCode.__invokespecial && cpi.Name == "<init>")
d2961 1
a2961 1
		if(cpi.Name == "<clinit>")
d2995 1
a2995 1
			if(cpi.Name == "<init>")
d3106 3
a3108 1
						if(cpi.GetClassType() == CoreClasses.java.lang.Object.Wrapper && thisType.IsArray && cpi.Name == "clone")
d3372 1
a3372 1
			LocalVar l = (LocalVar)localByStoreSite[store + ":" + localIndex];
d3421 1
a3421 1
			LocalVar v = (LocalVar)localByStoreSite[store + ":" + localIndex];
d3424 1
a3424 1
				localByStoreSite[store + ":" + localIndex] = local;
d3433 5
@


1.32
log
@*** empty log message ***
@
text
@d79 70
d153 1
a153 1
	private Hashtable[] localStoreSites;
d169 1
a169 1
	private InstructionState(TypeWrapper[] stack, int stackSize, int stackEnd, TypeWrapper[] locals, Hashtable[] localStoreSites, ArrayList subroutines, int callsites, bool unitializedThis)
d188 1
a188 1
		this.localStoreSites = new Hashtable[maxLocals];
d297 1
a297 1
						s2.localStoreSites[i] = s3.localStoreSites[i] != null ? (Hashtable)s3.localStoreSites[i].Clone() : null;
d354 2
a355 2
			Hashtable storeSites = s.localStoreSites[i];
			Hashtable storeSites2;
d374 1
a374 1
			if(storeSites != null && (s.localStoreSites[i] == null || storeSites.Count != s.localStoreSites[i].Count))
d394 1
a394 1
	private static Hashtable MergeStoreSites(Hashtable h1, Hashtable h2)
d396 1
a396 9
		if(h1 == null && h2 == null)
		{
			return null;
		}
		if(h1 == null)
		{
			return (Hashtable)h2.Clone();
		}
		if(h2 == null)
d398 1
a398 1
			return (Hashtable)h1.Clone();
d400 1
a400 2
		Hashtable h = new Hashtable();
		foreach(DictionaryEntry de in h1)
d402 1
a402 1
			h.Add(de.Key, de.Value);
d404 2
a405 1
		foreach(DictionaryEntry de in h2)
d407 1
a407 1
			h[de.Key] = de.Value;
d684 2
a685 2
		localStoreSites[localIndex] = new Hashtable();
		localStoreSites[localIndex].Add(instructionIndex, "");
d752 1
a752 1
			if(localStoreSites[index] != null)
d754 1
a754 1
				foreach(int store in localStoreSites[index].Keys)
d756 1
a756 1
					readers[store] = "";
d1043 1
a1043 1
			localStoreSites = (Hashtable[])localStoreSites.Clone();
@


1.31
log
@*** empty log message ***
@
text
@d88 10
d101 1
d114 1
d123 1
a123 1
		return new InstructionState((TypeWrapper[])stack.Clone(), stackSize, stackEnd, (TypeWrapper[])locals.Clone(), (Hashtable[])localStoreSites.Clone(), CopySubroutines(subroutines), callsites, unitializedThis);
d128 2
a129 1
		stack.CopyTo(target.stack, 0);
d132 3
a134 3
		locals.CopyTo(target.locals, 0);
		localStoreSites.CopyTo(target.localStoreSites, 0);
		target.subroutines = CopySubroutines(subroutines);
d142 3
a144 1
		return new InstructionState(new TypeWrapper[stack.Length], 0, stack.Length, (TypeWrapper[])locals.Clone(), (Hashtable[])localStoreSites.Clone(), CopySubroutines(subroutines), callsites, unitializedThis);
d147 1
a147 1
	private ArrayList CopySubroutines(ArrayList l)
d178 1
d224 1
d226 1
d270 1
d299 1
d306 1
d371 1
d392 1
d557 2
d589 2
d621 1
d931 1
d944 1
d952 1
d958 36
d2720 3
@


1.30
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
d2483 2
a2484 1
								if(tw.IsUnloadable && JVM.DisableDynamicBinding)
d2488 1
d2496 3
a2498 4
								if(JVM.DisableDynamicBinding)
								{
									instructions[i].SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(tw.Name));
								}
d2516 3
a2518 4
								if(JVM.DisableDynamicBinding)
								{
									instructions[i].SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(tw.Name));
								}
d2552 3
a2554 4
								if(JVM.DisableDynamicBinding)
								{
									instructions[i].SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(tw.Name));
								}
d2573 3
a2575 4
								if(JVM.DisableDynamicBinding)
								{
									instructions[i].SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(tw.Name));
								}
d2916 4
a2919 1
			if(JVM.DisableDynamicBinding)
d2921 21
a2941 28
				instr.SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(cpi.GetClassType().Name));
			}
			else
			{
				switch(invoke)
				{
					case NormalizedByteCode.__invokeinterface:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_invokeinterface);
						break;
					case NormalizedByteCode.__invokestatic:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_invokestatic);
						break;
					case NormalizedByteCode.__invokevirtual:
						instr.PatchOpCode(NormalizedByteCode.__dynamic_invokevirtual);
						break;
					case NormalizedByteCode.__invokespecial:
						if(isnew)
						{
							instr.PatchOpCode(NormalizedByteCode.__dynamic_invokespecial);
						}
						else
						{
							instr.SetHardError(HardError.LinkageError, AllocErrorMessage("Base class no longer loadable"));
						}
						break;
					default:
						throw new InvalidOperationException();
				}
d2943 1
d3079 3
a3081 5
			if(JVM.DisableDynamicBinding)
			{
				instr.SetHardError(HardError.NoClassDefFoundError, AllocErrorMessage(cpi.GetClassType().Name));
				return;
			}
d3099 1
@


1.29
log
@*** empty log message ***
@
text
@d1215 1
a1215 1
		: base(TypeWrapper.VerifierTypeModifiersHack, name, null, null, null)
d1221 5
@


1.28
log
@*** empty log message ***
@
text
@d2851 1
d2863 2
a2864 1
				if((VerifierTypeWrapper.IsNew(type) && ((VerifierTypeWrapper)type).UnderlyingType != cpi.GetClassType()) ||
d2866 1
a2866 1
					(!VerifierTypeWrapper.IsNew(type) && type != VerifierTypeWrapper.UninitializedThis))
d2931 8
a2938 2
						// TODO support dynamically instantiating an unloadable type
						instr.SetHardError(HardError.LinkageError, AllocErrorMessage("Base class no longer loadable"));
@


1.27
log
@*** empty log message ***
@
text
@d437 8
d831 4
d1008 6
a1013 1
		return state.GetStackByIndex(sp - 1);
d1022 6
a1027 1
		return state.GetStackByIndex(--sp);
d1139 1
a1139 1
	internal static readonly TypeWrapper UninitializedThis = new VerifierTypeWrapper("this", 0, null);
d1168 10
d1193 5
d1393 1
d1397 1
d1406 1
a1406 1
				state[0].SetLocalType(firstNonArgLocalIndex++, wrapper, -1);
d1409 4
d1812 4
d2717 1
a2717 1
						v.type = GetRawStackTypeWrapper(i, 0);
d2929 1
d3225 1
a3225 1
					type = InstructionState.FindCommonBaseType(type, GetRawStackTypeWrapper(store, 0));
d3257 8
a3264 1
			local.type = type;
d3417 10
@


1.26
log
@*** empty log message ***
@
text
@d24 1
d3389 1
@


1.25
log
@*** empty log message ***
@
text
@d2600 1
a2600 1
							// TODO should we check for unitialized objects?
@


1.24
log
@*** empty log message ***
@
text
@d1224 20
@


1.23
log
@*** empty log message ***
@
text
@d2384 1
a2384 1
			bool didjsr = false;
d2582 1
a2582 1
							didjsr = true;
d2589 1
d2606 1
a2606 1
			if(didjsr)
d2610 2
a2611 1
					if(instructions[i].NormalizedOpCode == NormalizedByteCode.__ret)
@


1.22
log
@*** empty log message ***
@
text
@d789 1
a789 1
			throw new VerifyError("Unexpected type " + type + " where " + baseType + " was expected");
@


1.21
log
@*** empty log message ***
@
text
@d1623 9
a1631 1
									s.PushType((GetFieldref(instr.Arg1)).GetFieldType());
d1673 1
d1675 9
a1683 1
								s.PushType(GetFieldref(instr.Arg1).GetFieldType());
d1685 1
d1764 8
a1771 1
									s.PushType(retType);
d2998 1
a2998 1
		else if(cpi.GetClassType().IsUnloadable)
d3005 18
@


1.20
log
@*** empty log message ***
@
text
@d803 8
d875 5
d978 133
d1220 1
a1220 1
	internal override void Finish(bool forDebugSave)
d1720 1
a1720 32
								if((cpi is ClassFile.ConstantPoolItemInterfaceMethodref) != (instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface))
								{
									throw new VerifyError("Illegal constant pool index");
								}
								if(instr.NormalizedOpCode != NormalizedByteCode.__invokespecial && cpi.Name == "<init>")
								{
									throw new VerifyError("Must call initializers using invokespecial");
								}
								if(cpi.Name == "<clinit>")
								{
									throw new VerifyError("Illegal call to internal method");
								}
								TypeWrapper[] args = cpi.GetArgTypes();
								for(int j = args.Length - 1; j >= 0; j--)
								{
									s.PopType(args[j]);
								}
								if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface)
								{
									int argcount = args.Length + 1;
									for(int j = 0; j < args.Length; j++)
									{
										if(args[j].IsWidePrimitive)
										{
											argcount++;
										}
									}
									if(instr.Arg2 != argcount)
									{
										throw new VerifyError("Inconsistent args size");
									}
								}
d1723 1
d1726 2
a1727 14
										TypeWrapper type = s.PopType();
										if((VerifierTypeWrapper.IsNew(type) && ((VerifierTypeWrapper)type).UnderlyingType != cpi.GetClassType()) ||
											(type == VerifierTypeWrapper.UninitializedThis && cpi.GetClassType() != wrapper.BaseTypeWrapper && cpi.GetClassType() != wrapper) ||
											(!VerifierTypeWrapper.IsNew(type) && type != VerifierTypeWrapper.UninitializedThis))
										{
											// TODO oddly enough, Java fails verification for the class without
											// even running the constructor, so maybe constructors are always
											// verified...
											// NOTE when a constructor isn't verifiable, the static initializer
											// doesn't run either (or so I believe)
											throw new VerifyError("Call to wrong initialization method");
										}
										// after the constructor invocation, the uninitialized reference, is now
										// suddenly initialized
d1733 1
a1733 1
										else
d1737 1
a1737 27
									}
									else
									{
										if(instr.NormalizedOpCode != NormalizedByteCode.__invokeinterface)
										{
											TypeWrapper refType = s.PopObjectType();
											TypeWrapper targetType = cpi.GetClassType();
											if(!VerifierTypeWrapper.IsNullOrUnloadable(refType) && 
												!targetType.IsUnloadable &&
												!refType.IsAssignableTo(targetType))
											{
												throw new VerifyError("Incompatible object argument for function call");
											}
											// for invokespecial we also need to make sure we're calling ourself or a base class
											if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
											{
												if(!VerifierTypeWrapper.IsNullOrUnloadable(refType) && !refType.IsSubTypeOf(wrapper))
												{
													throw new VerifyError("Incompatible target object for invokespecial");
												}
												if(!targetType.IsUnloadable && !wrapper.IsSubTypeOf(targetType))
												{
													throw new VerifyError("Invokespecial cannot call subclass methods");
												}
											}
										}
										else /* __invokeinterface */
d1739 1
a1739 4
											// NOTE previously we checked the type here, but it turns out that
											// the JVM throws an IncompatibleClassChangeError at runtime instead
											// of a VerifyError if this doesn't match
											s.PopObjectType();
a2281 6
									if(instr.Arg1 < 0)
									{
										// backward branches cannot have uninitialized objects on
										// the stack or in local variables
										s.CheckUninitializedObjRefs();
									}
a2285 6
									if(instr.Arg1 < 0)
									{
										// backward branches cannot have uninitialized objects on
										// the stack or in local variables
										s.CheckUninitializedObjRefs();
									}
d2366 1
d2373 19
d2393 2
a2394 2
							ClassFile.ConstantPoolItemMI cpi = GetMethodref(instructions[i].Arg1);
							if((cpi is ClassFile.ConstantPoolItemInterfaceMethodref) != (instructions[i].NormalizedOpCode == NormalizedByteCode.__invokeinterface))
d2396 4
a2399 1
								throw new VerifyError("Illegal constant pool index");
d2401 1
a2401 1
							if(instructions[i].NormalizedOpCode != NormalizedByteCode.__invokespecial && cpi.Name == "<init>")
d2403 1
a2403 1
								throw new VerifyError("Must call initializers using invokespecial");
d2405 1
a2405 1
							if(cpi.Name == "<clinit>")
d2407 1
a2407 1
								throw new VerifyError("Illegal call to internal method");
d2409 24
a2432 3
							NormalizedByteCode invoke = instructions[i].NormalizedOpCode;
							TypeWrapper thisType;
							if(invoke == NormalizedByteCode.__invokestatic)
d2434 4
a2437 1
								thisType = null;
d2439 11
a2449 1
							else
a2450 1
								thisType = SigTypeToClassName(GetRawStackTypeWrapper(i, cpi.GetArgTypes().Length), cpi.GetClassType(), wrapper);
d2452 1
a2452 2
							MethodWrapper targetMethod = invoke == NormalizedByteCode.__invokespecial ? cpi.GetMethodForInvokespecial() : cpi.GetMethod();
							if(targetMethod != null)
d2454 1
a2454 2
								string errmsg = CheckLoaderConstraints(cpi, targetMethod);
								if(errmsg != null)
d2456 1
a2456 1
									instructions[i].SetHardError(HardError.LinkageError, AllocErrorMessage(errmsg));
d2458 5
a2462 1
								else if(targetMethod.IsStatic == (invoke == NormalizedByteCode.__invokestatic))
d2464 1
a2464 24
									if(targetMethod.IsAbstract && invoke == NormalizedByteCode.__invokespecial)
									{
										instructions[i].SetHardError(HardError.AbstractMethodError, AllocErrorMessage(cpi.Class + "." + cpi.Name + cpi.Signature));
									}
									else if(targetMethod.IsAccessibleFrom(cpi.GetClassType(), wrapper, thisType))
									{
										break;
									}
									else
									{
										// NOTE special case for incorrect invocation of Object.clone(), because this could mean
										// we're calling clone() on an array
										// (bug in javac, see http://developer.java.sun.com/developer/bugParade/bugs/4329886.html)
										if(cpi.GetClassType() == CoreClasses.java.lang.Object.Wrapper && thisType.IsArray && cpi.Name == "clone")
										{
											// NOTE since thisType is an array, we can be sure that the method is already linked
											targetMethod = thisType.GetMethodWrapper(cpi.Name, cpi.Signature, false);
											if(targetMethod != null && targetMethod.IsPublic)
											{
												break;
											}
										}
										instructions[i].SetHardError(HardError.IllegalAccessError, AllocErrorMessage("Try to access method " + targetMethod.DeclaringType.Name + "." + cpi.Name + cpi.Signature + " from class " + wrapper.Name));
									}
d2466 11
a2476 1
								else
d2478 1
a2478 1
									instructions[i].SetHardError(HardError.IncompatibleClassChangeError, AllocErrorMessage("static call to non-static method (or v.v.)"));
d2483 1
a2483 1
								instructions[i].SetHardError(HardError.NoSuchMethodError, AllocErrorMessage(cpi.Class + "." + cpi.Name + cpi.Signature));
d2503 2
d2507 1
d2510 1
d2512 6
d2519 1
d2521 6
d2545 6
d2555 1
d2720 294
@


1.19
log
@*** empty log message ***
@
text
@d30 1
d1133 1
d2289 179
a2467 1
		
d2484 1
a2484 1
				if(IsReachable(i) && IsStoreLocal(instructions[i].NormalizedOpCode))
d2588 53
a2895 5

	internal bool IsReachable(int instructionIndex)
	{
		return state[instructionIndex] != null;
	}
@


1.18
log
@*** empty log message ***
@
text
@d1523 2
a1524 1
								if(s.PeekType() == VerifierTypeWrapper.UninitializedThis)
@


1.17
log
@*** empty log message ***
@
text
@d2087 1
d2180 1
d2275 1
a2275 1
						string opcode = instructions[i].OpCode.ToString();
@


1.16
log
@*** empty log message ***
@
text
@a1124 1
	private ClassLoaderWrapper classLoader;
a1151 1
		this.classLoader = classLoader;
@


1.15
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d1793 1
a1793 6
									string name = type.Name;
									if(name[0] != '[')
									{
										name = "L" + name + ";";
									}
									s.PushType(new UnloadableTypeWrapper(name));
@


1.14
log
@*** empty log message ***
@
text
@d79 1
d87 1
a87 1
	private InstructionState(TypeWrapper[] stack, int stackSize, TypeWrapper[] locals, Hashtable[] localStoreSites, ArrayList subroutines, int callsites, bool unitializedThis)
d91 1
d102 1
d109 1
a109 1
		return new InstructionState((TypeWrapper[])stack.Clone(), stackSize, (TypeWrapper[])locals.Clone(), (Hashtable[])localStoreSites.Clone(), CopySubroutines(subroutines), callsites, unitializedThis);
d116 1
d127 1
a127 1
		return new InstructionState(new TypeWrapper[stack.Length], 0, (TypeWrapper[])locals.Clone(), (Hashtable[])localStoreSites.Clone(), CopySubroutines(subroutines), callsites, unitializedThis);
d217 1
a217 1
		if(s1.stackSize != s2.stackSize)
d219 3
a221 1
			throw new VerifyError(string.Format("Inconsistent stack height: {0} != {1}", s1.stackSize, s2.stackSize));
d808 6
a813 1
		return stack[--stackSize];
d868 5
a872 1
		if(stackSize == stack.Length)
d1174 1
a1174 1
				if((start > end && end != -1) || start == -1 ||
@


1.13
log
@*** empty log message ***
@
text
@d955 1
a955 1
	internal static readonly TypeWrapper Unloadable = new UnloadableTypeWrapper("verifier");
@


1.12
log
@*** empty log message ***
@
text
@d1021 1
a1021 1
	protected override FieldWrapper GetFieldImpl(string fieldName, string fieldSig)
d1023 1
a1023 6
		throw new InvalidOperationException("GetFieldImpl called on " + this);
	}

	internal override MethodWrapper GetMethodWrapper(MethodDescriptor md, bool inherit)
	{
		throw new InvalidOperationException("GetMethodWrapper called on " + this);
@


1.11
log
@*** empty log message ***
@
text
@d1015 1
a1015 1
		: base(TypeWrapper.VerifierTypeModifiersHack, name, null, null)
@


1.10
log
@*** empty log message ***
@
text
@d83 1
d86 1
a86 1
	private InstructionState(TypeWrapper[] stack, int stackSize, TypeWrapper[] locals, Hashtable[] localStoreSites, ArrayList subroutines, int callsites)
d94 1
d106 1
a106 1
		return new InstructionState((TypeWrapper[])stack.Clone(), stackSize, (TypeWrapper[])locals.Clone(), (Hashtable[])localStoreSites.Clone(), CopySubroutines(subroutines), callsites);
d117 1
d123 1
a123 1
		return new InstructionState(new TypeWrapper[stack.Length], 0, (TypeWrapper[])locals.Clone(), (Hashtable[])localStoreSites.Clone(), CopySubroutines(subroutines), callsites);
d282 5
d321 13
d592 1
a593 1
		SetLocal1(index, PrimitiveTypeWrapper.INT);
d606 1
a607 1
		SetLocal2(index, PrimitiveTypeWrapper.LONG);
d620 1
a621 1
		SetLocal1(index, PrimitiveTypeWrapper.FLOAT);
d634 1
a635 1
		SetLocal2(index, PrimitiveTypeWrapper.DOUBLE);
a680 1
		SetLocalStoreSite(index, instructionIndex);
d689 1
d933 1
a933 1
			if(type == VerifierTypeWrapper.UninitializedThis || VerifierTypeWrapper.IsNew(type))
d941 1
a941 1
			if(type == VerifierTypeWrapper.UninitializedThis || VerifierTypeWrapper.IsNew(type))
d1138 5
d1155 21
a1175 1
		// TODO we should ensure that exception blocks and handlers start and end at instruction boundaries (note: wide prefix)
d1186 1
d1582 12
a1593 2
									// TODO check arg (should match signature)
									// error: "Inconsistent args size"
a1596 1
									// TODO we should verify that in a constructor, the base class constructor is actually called
d1616 1
d1973 1
a1973 1
								if(mw != null && mw.ReturnType != PrimitiveTypeWrapper.VOID)
d1975 6
a1980 1
									throw new VerifyError("Wrong return type in function");
d2589 1
a2589 1
	private string GetConstantPoolClass(int index)
d2593 1
a2593 1
			return classFile.GetConstantPoolClass(index);
d2601 1
a2601 13
		throw new VerifyError("Illegal constant pool index");
	}

	private TypeWrapper GetConstantPoolClassType(int index)
	{
		try
		{
			return classFile.GetConstantPoolClassType(index);
		}
		catch(InvalidCastException)
		{
		}
		catch(IndexOutOfRangeException)
@


1.9
log
@*** empty log message ***
@
text
@d2213 2
a2214 3
						x.SetInfo(instructions[i].PC, classFile.Name, method.Name, method.Signature, opcode);
						Tracer.Info(Tracer.Verifier, x.ToString());
						throw;
@


1.8
log
@*** empty log message ***
@
text
@d1691 6
a1696 1
									type = VerifierTypeWrapper.MakeNew(GetConstantPoolClassType(instr.Arg1), instr.PC);
d2237 1
a2237 1
				if(IsStoreLocal(instructions[i].NormalizedOpCode))
@


1.7
log
@*** empty log message ***
@
text
@d1000 1
a1000 1
	protected override FieldWrapper GetFieldImpl(string fieldName, TypeWrapper fieldType)
@


1.6
log
@*** empty log message ***
@
text
@d625 1
a625 1
			foreach(int store in localStoreSites[index].Keys)
d627 4
a630 1
				readers[store] = "";
d1146 2
a1147 1
		TypeWrapper[] argTypeWrappers = mw.GetParameters();
d1390 32
a1421 1
								s.PushType((GetFieldref(instr.Arg1)).GetFieldType());
d1424 36
a1459 1
								s.PopType(GetFieldref(instr.Arg1).GetFieldType());
d1910 2
a1911 1
								if(mw.ReturnType != PrimitiveTypeWrapper.VOID)
d2393 1
a2393 1
				else
a2430 1
				// TODO does this ever happen?
a2434 2
				// TODO does this ever happen?
				Console.WriteLine("merging...");
d2442 1
@


1.5
log
@*** empty log message ***
@
text
@d28 2
@


1.4
log
@*** empty log message ***
@
text
@d1054 1
a1054 1
	internal void FindLvtEntry(ClassFile.Method.Code method, int instructionIndex)
d1090 2
a1091 1
	private ClassFile.Method.Code method;
d1110 1
a1110 1
	internal MethodAnalyzer(TypeWrapper wrapper, ClassFile.Method.Code method, ClassLoaderWrapper classLoader)
d1113 1
d1129 1
a1129 1
		if(!method.Method.IsStatic)
d1132 1
a1132 1
			if(method.Method.Name == "<init>")
d1141 1
a1141 1
		TypeWrapper[] argTypeWrappers = method.Method.GetArgTypes(classLoader);
d1162 1
d1166 1
a1166 1
			for(int i = 0; i < method.Instructions.Length; i++)
d1178 1
a1178 1
							if(method.ExceptionTable[j].start_pc <= method.Instructions[i].PC && method.ExceptionTable[j].end_pc > method.Instructions[i].PC)
d1204 1
a1204 1
						ClassFile.Method.Instruction instr = method.Instructions[i];
d1384 1
a1384 1
								s.PushType((GetFieldref(instr.Arg1)).GetFieldType(classLoader));
d1387 1
a1387 1
								s.PopType(GetFieldref(instr.Arg1).GetFieldType(classLoader));
d1390 2
a1391 2
								s.PopObjectType(GetFieldref(instr.Arg1).GetClassType(classLoader));
								s.PushType(GetFieldref(instr.Arg1).GetFieldType(classLoader));
d1394 1
a1394 1
								s.PopType(GetFieldref(instr.Arg1).GetFieldType(classLoader));
d1402 1
a1402 1
									s.PopObjectType(GetFieldref(instr.Arg1).GetClassType(classLoader));
d1425 1
a1425 1
										if(method.Method.ClassFile.MajorVersion < 49)
d1456 1
a1456 1
								TypeWrapper[] args = cpi.GetArgTypes(classLoader);
d1472 2
a1473 2
										if((VerifierTypeWrapper.IsNew(type) && ((VerifierTypeWrapper)type).UnderlyingType != cpi.GetClassType(classLoader)) ||
											(type == VerifierTypeWrapper.UninitializedThis && cpi.GetClassType(classLoader) != wrapper.BaseTypeWrapper && cpi.GetClassType(classLoader) != wrapper) ||
d1499 1
a1499 1
											TypeWrapper targetType = cpi.GetClassType(classLoader);
d1528 1
a1528 1
								TypeWrapper retType = cpi.GetRetType(classLoader);
d1838 1
a1838 1
								if(method.Method.GetRetType(classLoader) != PrimitiveTypeWrapper.VOID)
d1844 1
a1844 1
								s.PopObjectType(method.Method.GetRetType(classLoader));
d1849 1
a1849 2
								TypeWrapper retType = method.Method.GetRetType(classLoader);
								if(!retType.IsIntOnStackPrimitive)
d1857 1
a1857 1
								if(method.Method.GetRetType(classLoader) != PrimitiveTypeWrapper.LONG)
d1864 1
a1864 1
								if(method.Method.GetRetType(classLoader) != PrimitiveTypeWrapper.FLOAT)
d1871 1
a1871 1
								if(method.Method.GetRetType(classLoader) != PrimitiveTypeWrapper.DOUBLE)
d2019 1
a2019 1
								if(i + 1 == method.Method.CodeAttribute.Instructions.Length)
d2037 1
a2037 1
									for(int j = 0; j < instr.Values.Length; j++)
d2039 1
a2039 1
										state[method.PcIndexMap[instr.PC + instr.TargetOffsets[j]]] += s;
d2130 1
a2130 1
						string opcode = method.Instructions[i].OpCode.ToString();
d2135 1
a2135 1
						x.SetInfo(method.Instructions[i].PC, method.Method.ClassFile.Name, method.Method.Name, method.Method.Signature, opcode);
d2157 1
a2157 1
			for(int i = 0; i < method.Instructions.Length; i++)
d2159 1
a2159 1
				if(IsStoreLocal(method.Instructions[i].NormalizedOpCode))
d2161 1
a2161 1
					if(!localByStoreSite.ContainsKey(i + ":" + method.Instructions[i].NormalizedArg1))
d2164 1
a2164 1
						v.local = method.Instructions[i].NormalizedArg1;
d2219 2
a2220 2
		invokespecialLocalVars = new LocalVar[method.Instructions.Length][];
		localVars = new LocalVar[method.Instructions.Length];
d2226 1
a2226 1
				Debug.Assert(IsLoadLocal(method.Instructions[i].NormalizedOpCode));
d2231 1
a2231 1
					v = (LocalVar)localByStoreSite[store + ":" + method.Instructions[i].NormalizedArg1];
d2237 1
a2237 1
				if(method.Instructions[i].NormalizedOpCode == NormalizedByteCode.__invokespecial)
d2247 1
a2247 1
					v = (LocalVar)localByStoreSite[i + ":" + method.Instructions[i].NormalizedArg1];
d2397 1
a2397 1
			ClassFile.ConstantPoolItemMI item = method.Method.ClassFile.GetMethodref(index);
d2416 1
a2416 1
			ClassFile.ConstantPoolItemFieldref item = method.Method.ClassFile.GetFieldref(index);
d2435 1
a2435 1
			return method.Method.ClassFile.GetConstantPoolConstantType(index);
d2456 1
a2456 1
			return method.Method.ClassFile.GetConstantPoolClass(index);
d2471 1
a2471 1
			return method.Method.ClassFile.GetConstantPoolClassType(index, classLoader);
@


1.3
log
@*** empty log message ***
@
text
@a28 17
class VerifyError : ApplicationException
{
	internal int ByteCodeOffset;
	internal string Class;
	internal string Method;
	internal string Signature;
	internal string Instruction;

	internal VerifyError()
	{
	}

	internal VerifyError(string msg) : base(msg)
	{
	}
}

d934 8
d1000 1
a1000 1
	protected override MethodWrapper GetMethodImpl(MethodDescriptor md)
d1002 1
a1002 1
		throw new InvalidOperationException("GetMethodImpl called on " + this);
d1037 1
a1037 1
	internal override void Finish()
d1440 1
a1440 1
								ClassFile.ConstantPoolItemFMI cpi = GetMethodref(instr.Arg1);
d1470 1
a1470 1
											(type == VerifierTypeWrapper.UninitializedThis && cpi.GetClassType(classLoader) != method.Method.ClassFile.GetSuperTypeWrapper(classLoader) && cpi.GetClassType(classLoader) != wrapper) ||
d1506 5
a1510 1
												if(!VerifierTypeWrapper.IsNullOrUnloadable(refType) && !wrapper.IsAssignableTo(refType))
d1512 1
a1512 1
													throw new VerifyError("Incompatible object argument for invokespecial");
a2127 4
						x.Class = method.Method.ClassFile.Name;
						x.Method = method.Method.Name;
						x.Signature = method.Method.Signature;
						x.ByteCodeOffset = method.Instructions[i].PC;
d2133 1
a2133 1
						x.Instruction = opcode;
a2134 12
						/*
						for(int j = 0; j < method.Instructions.Length; j++)
						{
							//state[j].DumpLocals();
							//state[j].DumpStack();
							if(state[j] != null)
							{
								state[j].DumpSubroutines();
								Console.WriteLine("{0}: {1}", method.Instructions[j].PC, method.Instructions[j].OpCode.ToString());
							}
						}
						*/
d2391 1
a2391 1
	private ClassFile.ConstantPoolItemFMI GetMethodref(int index)
d2395 2
a2396 2
			ClassFile.ConstantPoolItemFMI item = method.Method.ClassFile.GetMethodref(index);
			if(item != null && !(item is ClassFile.ConstantPoolItemFieldref))
@


1.2
log
@*** empty log message ***
@
text
@d251 1
a251 1
						System.Diagnostics.Debug.Fail("invalid merge");
d442 6
a447 2
			TypeWrapper baseType = FindCommonBaseTypeHelper(elem1, elem2);
			if(baseType == VerifierTypeWrapper.Invalid)
d456 4
a470 4
		if(t1.IsNonPrimitiveValueType || t2.IsNonPrimitiveValueType)
		{
			return VerifierTypeWrapper.Invalid;
		}
d473 1
a473 3
			// TODO I don't know how finding the common base for interfaces is defined, but
			// for now I'm just doing the naive thing
			// UPDATE according to a paper by Alessandro Coglio & Allen Goldberg titled
d479 2
a480 18
			// So strictly speaking, the code below isn't correct, but it works and it produces
			// more efficient code, so for now it stays in.
			if(t1.ImplementsInterface(t2))
			{
				return t2;
			}
			if(t2.ImplementsInterface(t1))
			{
				return t1;
			}
			foreach (TypeWrapper baseInterface in t1.Interfaces)
			{
				TypeWrapper commonBase = FindCommonBaseTypeHelper(baseInterface, t2);
				if (commonBase != CoreClasses.java.lang.Object.Wrapper)
				{
					return commonBase;
				}
			}
@


1.1
log
@*** empty log message ***
@
text
@d1519 4
a1522 1
											if(!VerifierTypeWrapper.IsNullOrUnloadable(refType) && !refType.IsAssignableTo(cpi.GetClassType(classLoader)))
@

