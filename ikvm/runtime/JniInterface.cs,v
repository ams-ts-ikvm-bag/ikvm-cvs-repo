head	1.107;
access;
symbols
	v8_1_5717_0:1.107
	v8_1:1.107.0.4
	v8_0_5449_1:1.107
	v8_0_5449_0:1.107
	v8_0:1.107.0.2
	v7_4_5196_0:1.104
	v7_4:1.104.0.2
	v7_3:1.92.0.2
	v7_2_4630_6:1.91.4.1
	v7_2_4630_5:1.91.4.1
	v7_2_4630_4:1.91.4.1
	v7_2_4630_3:1.91.4.1
	v7_2_4630_2:1.91
	v0_46_0_4:1.88
	v7_2_4630_1:1.91
	v7_2:1.91.0.4
	v7_1_4532_2:1.91
	v7_1_4532_1:1.91
	v7_1_4532_0:1.91
	v7_1:1.91.0.2
	v7_0_4335_3:1.89
	v7_0_4335_2:1.89
	v7_0_4335_1:1.89
	v0_46_0_2:1.88
	v7_0_4335_0:1.89
	v7_0:1.89.0.2
	v0_40_0_6:1.69.2.1
	v0_40_0_5:1.69.2.1
	v0_46_0_1:1.88
	v0_46_0_0:1.88
	v0_46:1.88.0.2
	v0_36_0_14:1.52.2.4
	v0_44_0_6:1.87
	v0_44_0_5:1.87
	v0_44_0_4:1.87
	v0_44_0_3:1.87
	v0_44_0_2:1.87
	v0_42_0_7:1.71.2.1
	v0_44_0_1:1.87
	v0_44_0_0:1.87
	v0_44:1.87.0.2
	v0_42_0_6:1.71.2.1
	v0_42_0_5:1.71.2.1
	v0_42_0_4:1.71.2.1
	v0_42_0_3:1.71.2.1
	v0_42_0_2:1.71
	v0_42_0_1:1.71
	v0_42_0_0:1.71
	v0_42:1.71.0.2
	v0_40_0_3:1.69.2.1
	v0_40_0_2:1.69
	v0_40_0_1:1.69
	v0_40_0_0:1.69
	v0_40:1.69.0.2
	v0_36_0_13:1.52.2.4
	v0_38_0_1:1.67
	v0_38_0_0:1.67
	v0_38:1.67.0.2
	v0_36_0_9:1.52.2.3
	v0_36_0_7:1.52.2.1
	v0_36_0_5:1.52.2.1
	v0_36_0_4:1.52.2.1
	v0_36_0_3:1.52.2.1
	v0_36_0_2:1.52.2.1
	v0_36_0_1:1.52.2.1
	v0_36_0_0:1.52.2.1
	v0_36:1.52.0.2
	v0_34_0_3:1.46
	v0_34_0_2:1.46
	v0_34_0_1:1.46
	v0_34_0_0:1.46
	v0_34:1.46.0.2
	v0_32:1.44.0.2
	v0_32_0_0:1.44
	v0_30:1.40.0.2
	v0_28_0_0:1.38
	v0_26_0_1:1.36
	v0_26_0_0:1.36
	v0_24_0_1:1.36
	v0_24_0_0:1.36
	v0_22_0_0:1.35
	v0_20_0_0:1.35
	v0_18_0_0:1.33
	v0_16_0_0:1.33
	v0_14_0_1:1.30
	v0_14_0_0:1.30
	v0_12_0_0:1.27
	v0_10_0_1:1.23
	v0_10_0_0:1.23
	v0_8_0_0:1.2;
locks; strict;
comment	@ * @;


1.107
date	2014.05.27.10.07.27;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2014.05.27.09.44.08;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2014.05.16.08.31.29;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2013.10.25.08.44.25;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2013.10.24.07.51.27;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2013.10.13.06.49.20;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2013.04.01.05.32.12;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2013.03.26.11.06.24;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2013.03.26.09.52.45;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2013.03.25.19.57.46;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2013.03.25.18.35.37;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2013.03.25.16.37.15;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2013.03.22.10.35.17;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2013.03.20.14.03.28;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2013.03.20.11.24.51;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2012.10.09.07.38.48;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2011.11.29.09.07.57;	author jfrijters;	state Exp;
branches
	1.91.4.1;
next	1.90;

1.90
date	2011.11.11.15.28.52;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2011.05.13.10.21.48;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2010.12.28.08.42.10;	author jfrijters;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2010.06.09.04.58.21;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2010.05.27.10.54.34;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2010.05.27.09.17.13;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2010.02.03.14.31.39;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2010.01.07.08.34.52;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.07.08.10.21;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2010.01.07.07.46.28;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2010.01.07.07.39.38;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2010.01.07.07.05.50;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.07.06.44.16;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.06.15.37.12;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2010.01.06.14.36.31;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2010.01.06.14.28.38;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.04.13.29.53;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.04.13.25.56;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.21.04.43.27;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2009.07.30.16.34.30;	author jfrijters;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2009.05.25.04.01.35;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2009.03.09.09.01.36;	author jfrijters;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2008.11.18.07.15.55;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2008.08.21.06.40.22;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2008.08.21.06.05.25;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2008.08.15.12.01.19;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2008.08.06.12.22.07;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2008.05.31.15.20.39;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2008.05.20.07.36.50;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2008.04.25.04.48.57;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2008.03.14.09.16.31;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2008.02.29.07.06.07;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2008.01.03.09.45.50;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.27.15.16.49;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.19.11.28.11;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.18.09.56.12;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.07.05.19.11;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.15.12.04.26;	author jfrijters;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2007.07.31.15.26.07;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.05.09.57.09;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.05.06.57.18;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.29.16.27.10;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.23.08.24.33;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.02.08.25.30;	author jfrijters;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2007.01.16.12.10.53;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2006.10.19.06.12.48;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2006.08.17.07.33.40;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2006.08.14.07.57.03;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.06.09.27.20;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.06.10.11.31;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.08.09.26.38;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.27.14.00.03;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.01.07.34.53;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.25.07.46.57;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.28.07.12.28;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.31.15.30.37;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.17.13.22.11;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.02.08.12.36;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.02.07.53.42;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.17.14.27.18;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.23.13.09.28;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.18.11.50.38;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.16.11.20.46;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.02.15.12.04;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.05.12.56.37;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.21.14.59.30;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.21.10.26.53;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.12.14.36.25;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.07.09.53.42;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.29.09.48.05;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.24.10.57.11;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.23.17.46.41;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.19.13.43.56;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.05.09.05.40;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.04.19.30.54;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.27.10.17.35;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.15.13.35.46;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.05.09.37.59;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.31.08.47.49;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.30.21.14.22;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.30.15.56.24;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.14.10.36.39;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;

1.46.2.1
date	2007.08.06.08.09.37;	author jfrijters;	state Exp;
branches;
next	;

1.52.2.1
date	2007.08.31.06.31.37;	author jfrijters;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2008.02.28.05.00.43;	author jfrijters;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2008.02.28.06.19.07;	author jfrijters;	state Exp;
branches;
next	1.52.2.4;

1.52.2.4
date	2008.03.14.06.17.39;	author jfrijters;	state Exp;
branches;
next	;

1.69.2.1
date	2009.07.31.06.30.40;	author jfrijters;	state Exp;
branches;
next	;

1.71.2.1
date	2009.11.30.05.49.53;	author jfrijters;	state Exp;
branches;
next	;

1.88.2.1
date	2013.09.10.15.16.04;	author jfrijters;	state Exp;
branches;
next	;

1.91.4.1
date	2012.10.23.08.15.53;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.107
log
@Replaced MethodWrapper.From[Method|Constructor|MethodOrConstructor] methods with MethodWrapper.FromExecutable().
@
text
@/*
  Copyright (C) 2002-2014 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Reflection;
using System.Runtime.InteropServices;
using IKVM.Internal;

// Java type JNI aliases
using jboolean = System.SByte;
using jbyte = System.SByte;
using jchar = System.UInt16;
using jshort = System.Int16;
using jint = System.Int32;
using jsize = System.Int32;
using jlong = System.Int64;
using jfloat = System.Single;
using jdouble = System.Double;
using jobject = System.IntPtr;
using jstring = System.IntPtr;
using jclass = System.IntPtr;
using jarray = System.IntPtr;
using jobjectArray = System.IntPtr;
using jbooleanArray = System.IntPtr;
using jbyteArray = System.IntPtr;
using jcharArray = System.IntPtr;
using jshortArray = System.IntPtr;
using jintArray = System.IntPtr;
using jlongArray = System.IntPtr;
using jfloatArray = System.IntPtr;
using jdoubleArray = System.IntPtr;
using jthrowable = System.IntPtr;
using jweak = System.IntPtr;
using jmethodID = System.IntPtr;
using jfieldID = System.IntPtr;

namespace IKVM.Runtime
{
	[StructLayout(LayoutKind.Sequential)]
	unsafe struct JavaVMOption
	{
		internal byte* optionString;
		internal void* extraInfo;
	}

	[StructLayout(LayoutKind.Sequential)]
	unsafe struct JavaVMInitArgs
	{
		internal jint version;
		internal jint nOptions;
		internal JavaVMOption* options;
		internal jboolean ignoreUnrecognized;
	}

	public unsafe sealed class JNI
	{
		internal static volatile bool jvmCreated;
		internal static volatile bool jvmDestroyed;
		internal const string METHOD_PTR_FIELD_PREFIX = "__<jniptr>";

		internal static bool IsSupportedJniVersion(jint version)
		{
			return version == JNIEnv.JNI_VERSION_1_1
				|| version == JNIEnv.JNI_VERSION_1_2
				|| version == JNIEnv.JNI_VERSION_1_4
				|| version == JNIEnv.JNI_VERSION_1_6
				|| version == JNIEnv.JNI_VERSION_1_8
				;
		}

		public static int CreateJavaVM(void* ppvm, void* ppenv, void* args)
		{
			JavaVMInitArgs* pInitArgs = (JavaVMInitArgs*)args;
			// we don't support the JDK 1.1 JavaVMInitArgs
			if(!IsSupportedJniVersion(pInitArgs->version) || pInitArgs->version == JNIEnv.JNI_VERSION_1_1)
			{
				return JNIEnv.JNI_EVERSION;
			}
			if(jvmCreated)
			{
				return JNIEnv.JNI_ERR;
			}
			System.Collections.Hashtable props = new System.Collections.Hashtable();
			for(int i = 0; i < pInitArgs->nOptions; i++)
			{
				string option = JNIEnv.StringFromOEM(pInitArgs->options[i].optionString);
				if(option.StartsWith("-D"))
				{
					int idx = option.IndexOf('=', 2);
					props[option.Substring(2, idx - 2)] = option.Substring(idx + 1);
				}
				else if(option.StartsWith("-verbose"))
				{
					// ignore
				}
				else if(option == "vfprintf" || option == "exit" || option == "abort")
				{
					// not supported
				}
				else if(pInitArgs->ignoreUnrecognized == JNIEnv.JNI_FALSE)
				{
					return JNIEnv.JNI_ERR;
				}
			}

			ikvm.runtime.Startup.setProperties(props);

			// initialize the class library
			java.lang.Thread.currentThread();

			*((void**)ppvm) = JavaVM.pJavaVM;
			return JavaVM.AttachCurrentThread(JavaVM.pJavaVM, (void**)ppenv, null);
		}

		public static int GetDefaultJavaVMInitArgs(void* vm_args)
		{
			// This is only used for JDK 1.1 JavaVMInitArgs, and we don't support those.
			return JNIEnv.JNI_ERR;
		}

		public static int GetCreatedJavaVMs(void* ppvmBuf, int bufLen, int* nVMs)
		{
			if(jvmCreated)
			{
				if(bufLen >= 1)
				{
					*((void**)ppvmBuf) = JavaVM.pJavaVM;
				}
				if(nVMs != null)
				{
					*nVMs = 1;
				}
			}
			else if(nVMs != null)
			{
				*nVMs = 0;
			}
			return JNIEnv.JNI_OK;
		}

		public struct Frame
		{
			private JNIEnv.ManagedJNIEnv env;
			private JNIEnv.ManagedJNIEnv.FrameState prevFrameState;

			internal ClassLoaderWrapper Enter(ClassLoaderWrapper loader)
			{
				Enter((ikvm.@@internal.CallerID)null);
				ClassLoaderWrapper prev = env.classLoader;
				env.classLoader = loader;
				return prev;
			}

			internal void Leave(ClassLoaderWrapper prev)
			{
				env.classLoader = prev;
				Leave();
			}

			public IntPtr Enter(ikvm.@@internal.CallerID callerID)
			{
				env = TlsHack.ManagedJNIEnv;
				if(env == null)
				{
					env = JNIEnv.CreateJNIEnv()->GetManagedJNIEnv();
				}
				prevFrameState = env.Enter(callerID);
				return (IntPtr)(void*)env.pJNIEnv;
			}

			public void Leave()
			{
				Exception x = env.Leave(prevFrameState);
				if(x != null)
				{
					throw x;
				}
			}

			public static IntPtr GetFuncPtr(ikvm.@@internal.CallerID callerID, string clazz, string name, string sig)
			{
				ClassLoaderWrapper loader = ClassLoaderWrapper.FromCallerID(callerID);
				int sp = 0;
				for(int i = 1; sig[i] != ')'; i++)
				{
					switch(sig[i])
					{
						case '[':
							sp += IntPtr.Size;
							while(sig[++i] == '[');
							if(sig[i] == 'L')
							{
								while(sig[++i] != ';');
							}
							break;
						case 'L':
							sp += IntPtr.Size;
							while(sig[++i] != ';');
							break;
						case 'J':
						case 'D':
							sp += 8;
							break;
						case 'F':
						case 'I':
						case 'C':
						case 'Z':
						case 'S':
						case 'B':
							sp += 4;
							break;
						default:
							Debug.Assert(false);
							break;
					}
				}
				string mangledClass = JniMangle(clazz);
				string mangledName = JniMangle(name);
				string mangledSig = JniMangle(sig.Substring(1, sig.IndexOf(')') - 1));
				string shortMethodName = String.Format("Java_{0}_{1}", mangledClass, mangledName);
				string longMethodName = String.Format("Java_{0}_{1}__{2}", mangledClass, mangledName, mangledSig);
				Tracer.Info(Tracer.Jni, "Linking native method: {0}.{1}{2}, class loader = {3}, short = {4}, long = {5}, args = {6}",
					clazz, name, sig, loader, shortMethodName, longMethodName, sp + 2 * IntPtr.Size);
				lock(JniHelper.JniLock)
				{
					foreach(IntPtr p in loader.GetNativeLibraries())
					{
						IntPtr pfunc = NativeLibrary.GetProcAddress(p, shortMethodName, sp + 2 * IntPtr.Size);
						if(pfunc != IntPtr.Zero)
						{
							Tracer.Info(Tracer.Jni, "Native method {0}.{1}{2} found in library 0x{3:X} (short)", clazz, name, sig, p.ToInt64());
							return pfunc;
						}
						pfunc = NativeLibrary.GetProcAddress(p, longMethodName, sp + 2 * IntPtr.Size);
						if(pfunc != IntPtr.Zero)
						{
							Tracer.Info(Tracer.Jni, "Native method {0}.{1}{2} found in library 0x{3:X} (long)", clazz, name, sig, p.ToInt64());
							return pfunc;
						}
					}
				}
				string msg = string.Format("{0}.{1}{2}", clazz, name, sig);
				Tracer.Error(Tracer.Jni, "UnsatisfiedLinkError: {0}", msg);
				throw new java.lang.UnsatisfiedLinkError(msg);
			}

			private static string JniMangle(string name)
			{
				StringBuilder sb = new StringBuilder();
				foreach(char c in name)
				{
					if(c == '/')
					{
						sb.Append('_');
					}
					else if(c == '_')
					{
						sb.Append("_1");
					}
					else if(c == ';')
					{
						sb.Append("_2");
					}
					else if(c == '[')
					{
						sb.Append("_3");
					}
					else if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
					{
						sb.Append(c);
					}
					else
					{
						sb.Append(String.Format("_0{0:x4}", (int)c));
					}
				}
				return sb.ToString();
			}

			public IntPtr MakeLocalRef(object obj)
			{
				return env.MakeLocalRef(obj);
			}

			// NOTE this method has the wrong name, it should unwrap *any* jobject reference type (local and global)
			public object UnwrapLocalRef(IntPtr p)
			{
				return JNIEnv.UnwrapRef(env, p);
			}
		}
	}

	abstract unsafe class NativeLibrary
	{
		private NativeLibrary() { }
		private static readonly NativeLibrary impl;

		static NativeLibrary()
		{
			try
			{
				if (Environment.OSVersion.Platform == PlatformID.Win32NT)
				{
					if (IntPtr.Size == 4)
					{
						impl = new Win32_x86();
					}
					else
					{
						impl = new Win32_x64();
					}
					// call a method to trigger the native library load
					// (if this fails, we fall back to the classic native library)
					impl._MarshalDelegate(null);
				}
				else
				{
					impl = new Classic();
				}
			}
			catch (DllNotFoundException)
			{
				impl = new Classic();
			}
			catch (BadImageFormatException)
			{
				impl = new Classic();
			}
		}

		private sealed class Win32_x86 : NativeLibrary
		{
			private const string library = "ikvm-native-win32-x86";

			[DllImport(library, SetLastError = true)]
			private static extern IntPtr ikvm_LoadLibrary(string filename);
			[DllImport(library)]
			private static extern void ikvm_FreeLibrary(IntPtr handle);
			[DllImport(library)]
			private static extern IntPtr ikvm_GetProcAddress(IntPtr handle, string name, int argc);
			[DllImport(library)]
			private static extern int ikvm_CallOnLoad(IntPtr method, void* jvm, void* reserved);
			[DllImport(library)]
			private static extern void** ikvm_GetJNIEnvVTable();
			[DllImport(library)]
			private static extern void* ikvm_MarshalDelegate(Delegate d);

			protected override IntPtr _LoadLibrary(string filename)
			{
				return ikvm_LoadLibrary(filename);
			}

			protected override void _FreeLibrary(IntPtr handle)
			{
				ikvm_FreeLibrary(handle);
			}

			protected override IntPtr _GetProcAddress(IntPtr handle, string name, int argc)
			{
				return ikvm_GetProcAddress(handle, name, argc);
			}

			protected override int _CallOnLoad(IntPtr method, void* jvm, void* reserved)
			{
				return ikvm_CallOnLoad(method, jvm, reserved);
			}

			protected override void** _GetJNIEnvVTable()
			{
				return ikvm_GetJNIEnvVTable();
			}

			protected override void* _MarshalDelegate(Delegate d)
			{
				return ikvm_MarshalDelegate(d);
			}
		}

		private sealed class Win32_x64 : NativeLibrary
		{
			private const string library = "ikvm-native-win32-x64";

			[DllImport(library, SetLastError = true)]
			private static extern IntPtr ikvm_LoadLibrary(string filename);
			[DllImport(library)]
			private static extern void ikvm_FreeLibrary(IntPtr handle);
			[DllImport(library)]
			private static extern IntPtr ikvm_GetProcAddress(IntPtr handle, string name, int argc);
			[DllImport(library)]
			private static extern int ikvm_CallOnLoad(IntPtr method, void* jvm, void* reserved);
			[DllImport(library)]
			private static extern void** ikvm_GetJNIEnvVTable();
			[DllImport(library)]
			private static extern void* ikvm_MarshalDelegate(Delegate d);

			protected override IntPtr _LoadLibrary(string filename)
			{
				return ikvm_LoadLibrary(filename);
			}

			protected override void _FreeLibrary(IntPtr handle)
			{
				ikvm_FreeLibrary(handle);
			}

			protected override IntPtr _GetProcAddress(IntPtr handle, string name, int argc)
			{
				return ikvm_GetProcAddress(handle, name, argc);
			}

			protected override int _CallOnLoad(IntPtr method, void* jvm, void* reserved)
			{
				return ikvm_CallOnLoad(method, jvm, reserved);
			}

			protected override void** _GetJNIEnvVTable()
			{
				return ikvm_GetJNIEnvVTable();
			}

			protected override void* _MarshalDelegate(Delegate d)
			{
				return ikvm_MarshalDelegate(d);
			}
		}

		private sealed class Classic : NativeLibrary
		{
			private const string library = "ikvm-native";

			[DllImport(library, SetLastError = true)]
			private static extern IntPtr ikvm_LoadLibrary(string filename);
			[DllImport(library)]
			private static extern void ikvm_FreeLibrary(IntPtr handle);
			[DllImport(library)]
			private static extern IntPtr ikvm_GetProcAddress(IntPtr handle, string name, int argc);
			[DllImport(library)]
			private static extern int ikvm_CallOnLoad(IntPtr method, void* jvm, void* reserved);
			[DllImport(library)]
			private static extern void** ikvm_GetJNIEnvVTable();
			[DllImport(library)]
			private static extern void* ikvm_MarshalDelegate(Delegate d);

			protected override IntPtr _LoadLibrary(string filename)
			{
				return ikvm_LoadLibrary(filename);
			}

			protected override void _FreeLibrary(IntPtr handle)
			{
				ikvm_FreeLibrary(handle);
			}

			protected override IntPtr _GetProcAddress(IntPtr handle, string name, int argc)
			{
				return ikvm_GetProcAddress(handle, name, argc);
			}

			protected override int _CallOnLoad(IntPtr method, void* jvm, void* reserved)
			{
				return ikvm_CallOnLoad(method, jvm, reserved);
			}

			protected override void** _GetJNIEnvVTable()
			{
				return ikvm_GetJNIEnvVTable();
			}

			protected override void* _MarshalDelegate(Delegate d)
			{
				return ikvm_MarshalDelegate(d);
			}
		}

		protected abstract IntPtr _LoadLibrary(string filename);
		protected abstract void _FreeLibrary(IntPtr handle);
		protected abstract IntPtr _GetProcAddress(IntPtr handle, string name, int argc);
		protected abstract int _CallOnLoad(IntPtr method, void* jvm, void* reserved);
		protected abstract void** _GetJNIEnvVTable();
		protected abstract void* _MarshalDelegate(Delegate d);

		internal static IntPtr LoadLibrary(string filename)
		{
			return impl._LoadLibrary(filename);
		}

		internal static void FreeLibrary(IntPtr handle)
		{
			impl._FreeLibrary(handle);
		}

		internal static IntPtr GetProcAddress(IntPtr handle, string name, int argc)
		{
			return impl._GetProcAddress(handle, name, argc);
		}

		internal static int CallOnLoad(IntPtr method, void* jvm, void* reserved)
		{
			return impl._CallOnLoad(method, jvm, reserved);
		}

		internal static void** GetJNIEnvVTable()
		{
			return impl._GetJNIEnvVTable();
		}

		internal static void* MarshalDelegate(Delegate d)
		{
			return impl._MarshalDelegate(d);
		}
	}

	sealed class JniHelper
	{
		private static List<IntPtr> nativeLibraries = new List<IntPtr>();
		internal static readonly object JniLock = new object();

		// MONOBUG with mcs we can't pass ClassLoaderWrapper from IKVM.Runtime.dll to IKVM.Runtime.JNI.dll
		internal unsafe static long LoadLibrary(string filename, object loader)
		{
			return LoadLibrary(filename, (ClassLoaderWrapper)loader);
		}

		// MONOBUG with mcs we can't pass ClassLoaderWrapper from IKVM.Runtime.dll to IKVM.Runtime.JNI.dll
		internal static void UnloadLibrary(long handle, object loader)
		{
			UnloadLibrary(handle, (ClassLoaderWrapper)loader);
		}

		private unsafe static long LoadLibrary(string filename, ClassLoaderWrapper loader)
		{
			Tracer.Info(Tracer.Jni, "loadLibrary: {0}, class loader: {1}", filename, loader);
			lock(JniLock)
			{
				IntPtr p = NativeLibrary.LoadLibrary(filename);
				if(p == IntPtr.Zero)
				{
					Tracer.Info(Tracer.Jni, "Failed to load library: path = '{0}', error = {1}, message = {2}", filename,
						Marshal.GetLastWin32Error(), new System.ComponentModel.Win32Exception().Message);
					return 0;
				}
				try
				{
					foreach(IntPtr tmp in loader.GetNativeLibraries())
					{
						if(tmp == p)
						{
							// the library was already loaded by the current class loader,
							// no need to do anything
							NativeLibrary.FreeLibrary(p);
							Tracer.Warning(Tracer.Jni, "Library was already loaded: {0}", filename);
							return p.ToInt64();
						}
					}
					if(nativeLibraries.Contains(p))
					{
						string msg = string.Format("Native library {0} already loaded in another classloader", filename);
						Tracer.Error(Tracer.Jni, "UnsatisfiedLinkError: {0}", msg);
						throw new java.lang.UnsatisfiedLinkError(msg);
					}
					Tracer.Info(Tracer.Jni, "Library loaded: {0}, handle = 0x{1:X}", filename, p.ToInt64());
					IntPtr onload = NativeLibrary.GetProcAddress(p, "JNI_OnLoad", IntPtr.Size * 2);
					if(onload != IntPtr.Zero)
					{
						Tracer.Info(Tracer.Jni, "Calling JNI_OnLoad on: {0}", filename);
						JNI.Frame f = new JNI.Frame();
						int version;
						ClassLoaderWrapper prevLoader = f.Enter(loader);
						try
						{
							// TODO on Whidbey we should be able to use Marshal.GetDelegateForFunctionPointer to call OnLoad
							version = NativeLibrary.CallOnLoad(onload, JavaVM.pJavaVM, null);
							Tracer.Info(Tracer.Jni, "JNI_OnLoad returned: 0x{0:X8}", version);
						}
						finally
						{
							f.Leave(prevLoader);
						}
						if(!JNI.IsSupportedJniVersion(version))
						{
							string msg = string.Format("Unsupported JNI version 0x{0:X} required by {1}", version, filename);
							Tracer.Error(Tracer.Jni, "UnsatisfiedLinkError: {0}", msg);
							throw new java.lang.UnsatisfiedLinkError(msg);
						}
					}
					nativeLibraries.Add(p);
					loader.RegisterNativeLibrary(p);
					return p.ToInt64();
				}
				catch
				{
					NativeLibrary.FreeLibrary(p);
					throw;
				}
			}
		}

		private unsafe static void UnloadLibrary(long handle, ClassLoaderWrapper loader)
		{
			lock (JniLock)
			{
				Tracer.Info(Tracer.Jni, "Unloading library: handle = 0x{0:X}, class loader = {1}", handle, loader);
				IntPtr p = (IntPtr)handle;
				IntPtr onunload = NativeLibrary.GetProcAddress(p, "JNI_OnUnload", IntPtr.Size * 2);
				if (onunload != IntPtr.Zero)
				{
					Tracer.Info(Tracer.Jni, "Calling JNI_OnUnload on: handle = 0x{0:X}", handle);
					JNI.Frame f = new JNI.Frame();
					ClassLoaderWrapper prevLoader = f.Enter(loader);
					try
					{
						// TODO on Whidbey we should be able to use Marshal.GetDelegateForFunctionPointer to call OnLoad
						NativeLibrary.CallOnLoad(onunload, JavaVM.pJavaVM, null);
					}
					finally
					{
						f.Leave(prevLoader);
					}
				}
				nativeLibraries.Remove(p);
				loader.UnregisterNativeLibrary(p);
				NativeLibrary.FreeLibrary((IntPtr)handle);
			}
		}
	}

	static class GlobalRefs
	{
		internal static System.Collections.ArrayList globalRefs = new System.Collections.ArrayList();
		internal static readonly object weakRefLock = new object();
		internal static GCHandle[] weakRefs = new GCHandle[16];

		internal static object Unwrap(int i)
		{
			i = -i;
			if ((i & (1 << 30)) != 0)
			{
				lock (GlobalRefs.weakRefLock)
				{
					return GlobalRefs.weakRefs[i - (1 << 30)].Target;
				}
			}
			else
			{
				lock (GlobalRefs.globalRefs)
				{
					return GlobalRefs.globalRefs[i - 1];
				}
			}
		}
	}

	unsafe class VtableBuilder
	{
		delegate int pf_int_IntPtr(JNIEnv* pEnv, IntPtr p);
		delegate IntPtr pf_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p);
		delegate void pf_void_IntPtr(JNIEnv* pEnv, IntPtr p);
		delegate IntPtr pf_IntPtr(JNIEnv* pEnv);
		delegate void pf_void(JNIEnv* pEnv);
		delegate sbyte pf_sbyte(JNIEnv* pEnv);
		delegate IntPtr pf_IntPtr_pbyte(JNIEnv* pEnv, byte* p);
		delegate int pf_int(JNIEnv* pEnv);
		delegate IntPtr pf_IntPtr_pbyte_IntPtr_psbyte_IntPtr(JNIEnv* pEnv, byte* p1, IntPtr p2, sbyte* p3, int p4);
		delegate IntPtr pf_IntPtr_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
		delegate jchar* pf_pjchar_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate void pf_void_IntPtr_pvoid_int(JNIEnv* pEnv, IntPtr p1, void* p2, int p3);
		delegate void* pf_pvoid_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate int pf_int_IntPtr_pbyte(JNIEnv* pEnv, IntPtr p1, byte* p2);
		delegate void pf_void_pbyte(JNIEnv* pEnv, byte* p1);
		delegate IntPtr pf_IntPtr_IntPtr_pbyte_pbyte(JNIEnv* pEnv, IntPtr p1, byte* p2, byte* p3);
		delegate int pf_int_IntPtr_pJNINativeMethod_int(JNIEnv* pEnv, IntPtr p1, JNIEnv.JNINativeMethod* p2, int p3);
		delegate int pf_int_ppJavaVM(JNIEnv* pEnv, JavaVM** ppJavaVM);
		delegate sbyte pf_sbyte_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
		delegate short pf_short_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
		delegate ushort pf_ushort_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
		delegate int pf_int_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
		delegate long pf_long_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
		delegate float pf_float_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
		delegate double pf_double_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
		delegate void pf_void_IntPtr_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3);
		delegate void pf_void_IntPtr_IntPtr_sbyte(JNIEnv* pEnv, IntPtr p1, IntPtr p2, sbyte p3);
		delegate void pf_void_IntPtr_IntPtr_short(JNIEnv* pEnv, IntPtr p1, IntPtr p2, short p3);
		delegate void pf_void_IntPtr_IntPtr_ushort(JNIEnv* pEnv, IntPtr p1, IntPtr p2, ushort p3);
		delegate void pf_void_IntPtr_IntPtr_int(JNIEnv* pEnv, IntPtr p1, IntPtr p2, int p3);
		delegate void pf_void_IntPtr_IntPtr_long(JNIEnv* pEnv, IntPtr p1, IntPtr p2, long p3);
		delegate void pf_void_IntPtr_IntPtr_float(JNIEnv* pEnv, IntPtr p1, IntPtr p2, float p3);
		delegate void pf_void_IntPtr_IntPtr_double(JNIEnv* pEnv, IntPtr p1, IntPtr p2, double p3);
		delegate IntPtr pf_IntPtr_pjchar_int(JNIEnv* pEnv, jchar* p1, int p2);
		delegate void pf_void_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
		delegate void pf_void_IntPtr_pjchar(JNIEnv* pEnv, IntPtr p1, jchar* p2);
		delegate IntPtr pf_IntPtr_int_IntPtr_IntPtr(JNIEnv* pEnv, int p1, IntPtr p2, IntPtr p3);
		delegate IntPtr pf_IntPtr_IntPtr_int(JNIEnv* pEnv, IntPtr p1, int p2);
		delegate void pf_void_IntPtr_int_IntPtr(JNIEnv* pEnv, IntPtr p1, int p2, IntPtr p3);
		delegate IntPtr pf_IntPtr_int(JNIEnv* pEnv, int p1);
		delegate void pf_void_IntPtr_int_int_IntPtr(JNIEnv* pEnv, IntPtr p1, int p2, int p3, IntPtr p4);
		delegate IntPtr pf_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
		delegate sbyte pf_sbyte_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
		delegate short pf_short_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
		delegate ushort pf_ushort_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
		delegate int pf_int_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
		delegate long pf_long_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
		delegate float pf_float_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
		delegate double pf_double_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
		delegate void pf_void_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
		delegate IntPtr pf_IntPtr_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
		delegate sbyte pf_sbyte_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
		delegate ushort pf_ushort_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
		delegate short pf_short_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
		delegate int pf_int_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
		delegate long pf_long_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
		delegate float pf_float_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
		delegate double pf_double_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
		delegate void pf_void_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
		delegate byte* pf_pbyte_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate void pf_void_IntPtr_pbyte(JNIEnv* pEnv, IntPtr p1, byte* p2);
		delegate jboolean* pf_pjboolean_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate jbyte* pf_pjbyte_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate jshort* pf_pjshort_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate jint* pf_pjint_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate jlong* pf_pjlong_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate jfloat* pf_pjfloat_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate jdouble* pf_pjdouble_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
		delegate void pf_void_IntPtr_pjboolean_int(JNIEnv* pEnv, IntPtr p1, jboolean* p2, int p3);
		delegate void pf_void_IntPtr_pjbyte_int(JNIEnv* pEnv, IntPtr p1, jbyte* p2, int p3);
		delegate void pf_void_IntPtr_pjchar_int(JNIEnv* pEnv, IntPtr p1, jchar* p2, int p3);
		delegate void pf_void_IntPtr_pjshort_int(JNIEnv* pEnv, IntPtr p1, jshort* p2, int p3);
		delegate void pf_void_IntPtr_pjint_int(JNIEnv* pEnv, IntPtr p1, jint* p2, int p3);
		delegate void pf_void_IntPtr_pjlong_int(JNIEnv* pEnv, IntPtr p1, jlong* p2, int p3);
		delegate void pf_void_IntPtr_pjfloat_int(JNIEnv* pEnv, IntPtr p1, jfloat* p2, int p3);
		delegate void pf_void_IntPtr_pjdouble_int(JNIEnv* pEnv, IntPtr p1, jdouble* p2, int p3);
		delegate int pf_int_int(JNIEnv* pEnv, int p1);
		delegate IntPtr pf_IntPtr_IntPtr_long(JNIEnv* pEnv, IntPtr p1, long p2);
		delegate long pf_long_IntPtr(JNIEnv* pEnv, IntPtr p1);
		delegate IntPtr pf_IntPtr_IntPtr_IntPtr_sbyte(JNIEnv* pEnv, IntPtr p1, IntPtr p2, sbyte p3);

		internal static void* vtable;

		static VtableBuilder()
		{
			JNI.jvmCreated = true;
			// JNIEnv
			void** pmcpp = NativeLibrary.GetJNIEnvVTable();
			void** p = (void**)JniMem.Alloc(IntPtr.Size * vtableDelegates.Length);
			for(int i = 0; i < vtableDelegates.Length; i++)
			{
				if(vtableDelegates[i] != null)
				{
					// TODO on Whidbey we can use Marshal.GetFunctionPointerForDelegate
					p[i] = NativeLibrary.MarshalDelegate(vtableDelegates[i]);
				}
				else
				{
					p[i] = pmcpp[i];
				}
			}
			vtable = p;
		}

		static Delegate[] vtableDelegates =
		{
			new pf_int_IntPtr_pbyte(JNIEnv.GetMethodArgs), //virtual void JNICALL reserved0();
			null, //virtual void JNICALL reserved1();
			null, //virtual void JNICALL reserved2();
			null, //virtual void JNICALL reserved3();

			new pf_int(JNIEnv.GetVersion), //virtual jint JNICALL GetVersion();

			new pf_IntPtr_pbyte_IntPtr_psbyte_IntPtr(JNIEnv.DefineClass), //virtual jclass JNICALL DefineClass(const char *name, jobject loader, const jbyte *buf, jsize len);
			new pf_IntPtr_pbyte(JNIEnv.FindClass), //virtual jclass JNICALL FindClass(const char *name);

			new pf_IntPtr_IntPtr(JNIEnv.FromReflectedMethod), //virtual jmethodID JNICALL FromReflectedMethod(jobject method);
			new pf_IntPtr_IntPtr(JNIEnv.FromReflectedField), //virtual jfieldID JNICALL FromReflectedField(jobject field);
			new pf_IntPtr_IntPtr_IntPtr_sbyte(JNIEnv.ToReflectedMethod), //virtual jobject JNICALL ToReflectedMethod(jclass clazz, jmethodID methodID, jboolean isStatic);

			new pf_IntPtr_IntPtr(JNIEnv.GetSuperclass), //virtual jclass JNICALL GetSuperclass(jclass sub);
			new pf_sbyte_IntPtr_IntPtr(JNIEnv.IsAssignableFrom), //virtual jboolean JNICALL IsAssignableFrom(jclass sub, jclass sup);

			new pf_IntPtr_IntPtr_IntPtr_sbyte(JNIEnv.ToReflectedField), //virtual jobject JNICALL ToReflectedField(jclass clazz, jfieldID fieldID, jboolean isStatic);

			new pf_int_IntPtr(JNIEnv.Throw), //virtual jint JNICALL Throw(jthrowable obj);
			new pf_int_IntPtr_pbyte(JNIEnv.ThrowNew), //virtual jint JNICALL ThrowNew(jclass clazz, const char *msg);
			new pf_IntPtr(JNIEnv.ExceptionOccurred), //virtual jthrowable JNICALL ExceptionOccurred();
			new pf_void(JNIEnv.ExceptionDescribe), //virtual void JNICALL ExceptionDescribe();
			new pf_void(JNIEnv.ExceptionClear), //virtual void JNICALL ExceptionClear();
			new pf_void_pbyte(JNIEnv.FatalError), //virtual void JNICALL FatalError(const char *msg);

			new pf_int_int(JNIEnv.PushLocalFrame), //virtual jint JNICALL PushLocalFrame(jint capacity); 
			new pf_IntPtr_IntPtr(JNIEnv.PopLocalFrame), //virtual jobject JNICALL PopLocalFrame(jobject result);

			new pf_IntPtr_IntPtr(JNIEnv.NewGlobalRef), //virtual jobject JNICALL NewGlobalRef(jobject lobj);
			new pf_void_IntPtr(JNIEnv.DeleteGlobalRef), //virtual void JNICALL DeleteGlobalRef(jobject gref);
			new pf_void_IntPtr(JNIEnv.DeleteLocalRef), //virtual void JNICALL DeleteLocalRef(jobject obj);
			new pf_sbyte_IntPtr_IntPtr(JNIEnv.IsSameObject), //virtual jboolean JNICALL IsSameObject(jobject obj1, jobject obj2);

			new pf_IntPtr_IntPtr(JNIEnv.NewLocalRef), //virtual jobject JNICALL NewLocalRef(jobject ref);
			new pf_int_int(JNIEnv.EnsureLocalCapacity), //virtual jint JNICALL EnsureLocalCapacity(jint capacity);

			new pf_IntPtr_IntPtr(JNIEnv.AllocObject), //virtual jobject JNICALL AllocObject(jclass clazz);
			null, //virtual jobject JNICALL NewObject(jclass clazz, jmethodID methodID, ...);
			null, //virtual jobject JNICALL NewObjectV(jclass clazz, jmethodID methodID, va_list args);
			new pf_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.NewObjectA), //virtual jobject JNICALL NewObjectA(jclass clazz, jmethodID methodID, jvalue *args);

			new pf_IntPtr_IntPtr(JNIEnv.GetObjectClass), //virtual jclass JNICALL GetObjectClass(jobject obj);
			new pf_sbyte_IntPtr_IntPtr(JNIEnv.IsInstanceOf), //virtual jboolean JNICALL IsInstanceOf(jobject obj, jclass clazz);

			new pf_IntPtr_IntPtr_pbyte_pbyte(JNIEnv.GetMethodID), //virtual jmethodID JNICALL GetMethodID(jclass clazz, const char *name, const char *sig);

			null, //virtual jobject JNICALL CallObjectMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual jobject JNICALL CallObjectMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallObjectMethodA), //virtual jobject JNICALL CallObjectMethodA(jobject obj, jmethodID methodID, jvalue * args);

			null, //virtual jboolean JNICALL CallBooleanMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual jboolean JNICALL CallBooleanMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_sbyte_IntPtr_IntPtr_pjvalue(JNIEnv.CallBooleanMethodA), //virtual jboolean JNICALL CallBooleanMethodA(jobject obj, jmethodID methodID, jvalue * args);

			null, //virtual jbyte JNICALL CallByteMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual jbyte JNICALL CallByteMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_sbyte_IntPtr_IntPtr_pjvalue(JNIEnv.CallByteMethodA), //virtual jbyte JNICALL CallByteMethodA(jobject obj, jmethodID methodID, jvalue *args);

			null, //virtual jchar JNICALL CallCharMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual jchar JNICALL CallCharMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_ushort_IntPtr_IntPtr_pjvalue(JNIEnv.CallCharMethodA), //virtual jchar JNICALL CallCharMethodA(jobject obj, jmethodID methodID, jvalue *args);

			null, //virtual jshort JNICALL CallShortMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual jshort JNICALL CallShortMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_short_IntPtr_IntPtr_pjvalue(JNIEnv.CallShortMethodA), //virtual jshort JNICALL CallShortMethodA(jobject obj, jmethodID methodID, jvalue *args);

			null, //virtual jint JNICALL CallIntMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual jint JNICALL CallIntMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_int_IntPtr_IntPtr_pjvalue(JNIEnv.CallIntMethodA), //virtual jint JNICALL CallIntMethodA(jobject obj, jmethodID methodID, jvalue *args);

			null, //virtual jlong JNICALL CallLongMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual jlong JNICALL CallLongMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_long_IntPtr_IntPtr_pjvalue(JNIEnv.CallLongMethodA), //virtual jlong JNICALL CallLongMethodA(jobject obj, jmethodID methodID, jvalue *args);

			null, //virtual jfloat JNICALL CallFloatMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual jfloat JNICALL CallFloatMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_float_IntPtr_IntPtr_pjvalue(JNIEnv.CallFloatMethodA), //virtual jfloat JNICALL CallFloatMethodA(jobject obj, jmethodID methodID, jvalue *args);

			null, //virtual jdouble JNICALL CallDoubleMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual jdouble JNICALL CallDoubleMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_double_IntPtr_IntPtr_pjvalue(JNIEnv.CallDoubleMethodA), //virtual jdouble JNICALL CallDoubleMethodA(jobject obj, jmethodID methodID, jvalue *args);

			null, //virtual void JNICALL CallVoidMethod(jobject obj, jmethodID methodID, ...);
			null, //virtual void JNICALL CallVoidMethodV(jobject obj, jmethodID methodID, va_list args);
			new pf_void_IntPtr_IntPtr_pjvalue(JNIEnv.CallVoidMethodA), //virtual void JNICALL CallVoidMethodA(jobject obj, jmethodID methodID, jvalue * args);

			null, //virtual jobject JNICALL CallNonvirtualObjectMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual jobject JNICALL CallNonvirtualObjectMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_IntPtr_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualObjectMethodA), //virtual jobject JNICALL CallNonvirtualObjectMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue * args);

			null, //virtual jboolean JNICALL CallNonvirtualBooleanMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual jboolean JNICALL CallNonvirtualBooleanMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_sbyte_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualBooleanMethodA), //virtual jboolean JNICALL CallNonvirtualBooleanMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue * args);

			null, //virtual jbyte JNICALL CallNonvirtualByteMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual jbyte JNICALL CallNonvirtualByteMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_sbyte_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualByteMethodA), //virtual jbyte JNICALL CallNonvirtualByteMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jchar JNICALL CallNonvirtualCharMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual jchar JNICALL CallNonvirtualCharMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_ushort_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualCharMethodA), //virtual jchar JNICALL CallNonvirtualCharMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jshort JNICALL CallNonvirtualShortMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual jshort JNICALL CallNonvirtualShortMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_short_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualShortMethodA), //virtual jshort JNICALL CallNonvirtualShortMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jint JNICALL CallNonvirtualIntMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual jint JNICALL CallNonvirtualIntMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_int_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualIntMethodA), //virtual jint JNICALL CallNonvirtualIntMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jlong JNICALL CallNonvirtualLongMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual jlong JNICALL CallNonvirtualLongMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_long_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualLongMethodA), //virtual jlong JNICALL CallNonvirtualLongMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jfloat JNICALL CallNonvirtualFloatMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual jfloat JNICALL CallNonvirtualFloatMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_float_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualFloatMethodA), //virtual jfloat JNICALL CallNonvirtualFloatMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jdouble JNICALL CallNonvirtualDoubleMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual jdouble JNICALL CallNonvirtualDoubleMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_double_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualDoubleMethodA), //virtual jdouble JNICALL CallNonvirtualDoubleMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual void JNICALL CallNonvirtualVoidMethod(jobject obj, jclass clazz, jmethodID methodID, ...);
			null, //virtual void JNICALL CallNonvirtualVoidMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args);
			new pf_void_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualVoidMethodA), //virtual void JNICALL CallNonvirtualVoidMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue * args);

			new pf_IntPtr_IntPtr_pbyte_pbyte(JNIEnv.GetFieldID), //virtual jfieldID JNICALL GetFieldID(jclass clazz, const char *name, const char *sig);

			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetObjectField), //virtual jobject JNICALL GetObjectField(jobject obj, jfieldID fieldID);
			new pf_sbyte_IntPtr_IntPtr(JNIEnv.GetBooleanField), //virtual jboolean JNICALL GetBooleanField(jobject obj, jfieldID fieldID);
			new pf_sbyte_IntPtr_IntPtr(JNIEnv.GetByteField), //virtual jbyte JNICALL GetByteField(jobject obj, jfieldID fieldID);
			new pf_ushort_IntPtr_IntPtr(JNIEnv.GetCharField), //virtual jchar JNICALL GetCharField(jobject obj, jfieldID fieldID);
			new pf_short_IntPtr_IntPtr(JNIEnv.GetShortField), //virtual jshort JNICALL GetShortField(jobject obj, jfieldID fieldID);
			new pf_int_IntPtr_IntPtr(JNIEnv.GetIntField), //virtual jint JNICALL GetIntField(jobject obj, jfieldID fieldID);
			new pf_long_IntPtr_IntPtr(JNIEnv.GetLongField), //virtual jlong JNICALL GetLongField(jobject obj, jfieldID fieldID);
			new pf_float_IntPtr_IntPtr(JNIEnv.GetFloatField), //virtual jfloat JNICALL GetFloatField(jobject obj, jfieldID fieldID);
			new pf_double_IntPtr_IntPtr(JNIEnv.GetDoubleField), //virtual jdouble JNICALL GetDoubleField(jobject obj, jfieldID fieldID);

			new pf_void_IntPtr_IntPtr_IntPtr(JNIEnv.SetObjectField), //virtual void JNICALL SetObjectField(jobject obj, jfieldID fieldID, jobject val);
			new pf_void_IntPtr_IntPtr_sbyte(JNIEnv.SetBooleanField), //virtual void JNICALL SetBooleanField(jobject obj, jfieldID fieldID, jboolean val);
			new pf_void_IntPtr_IntPtr_sbyte(JNIEnv.SetByteField), //virtual void JNICALL SetByteField(jobject obj, jfieldID fieldID, jbyte val);
			new pf_void_IntPtr_IntPtr_ushort(JNIEnv.SetCharField), //virtual void JNICALL SetCharField(jobject obj, jfieldID fieldID, jchar val);
			new pf_void_IntPtr_IntPtr_short(JNIEnv.SetShortField), //virtual void JNICALL SetShortField(jobject obj, jfieldID fieldID, jshort val);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.SetIntField), //virtual void JNICALL SetIntField(jobject obj, jfieldID fieldID, jint val);
			new pf_void_IntPtr_IntPtr_long(JNIEnv.SetLongField), //virtual void JNICALL SetLongField(jobject obj, jfieldID fieldID, jlong val);
			new pf_void_IntPtr_IntPtr_float(JNIEnv.SetFloatField), //virtual void JNICALL SetFloatField(jobject obj, jfieldID fieldID, jfloat val);
			new pf_void_IntPtr_IntPtr_double(JNIEnv.SetDoubleField), //virtual void JNICALL SetDoubleField(jobject obj, jfieldID fieldID, jdouble val);

			new pf_IntPtr_IntPtr_pbyte_pbyte(JNIEnv.GetStaticMethodID), //virtual jmethodID JNICALL GetStaticMethodID(jclass clazz, const char *name, const char *sig);

			null, //virtual jobject JNICALL CallStaticObjectMethod(jclass clazz, jmethodID methodID, ...);
			null, //virtual jobject JNICALL CallStaticObjectMethodV(jclass clazz, jmethodID methodID, va_list args);
			new pf_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticObjectMethodA), //virtual jobject JNICALL CallStaticObjectMethodA(jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jboolean JNICALL CallStaticBooleanMethod(jclass clazz, jmethodID methodID, ...);
			null, //virtual jboolean JNICALL CallStaticBooleanMethodV(jclass clazz, jmethodID methodID, va_list args);
			new pf_sbyte_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticBooleanMethodA), //virtual jboolean JNICALL CallStaticBooleanMethodA(jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jbyte JNICALL CallStaticByteMethod(jclass clazz, jmethodID methodID, ...);
			null, //virtual jbyte JNICALL CallStaticByteMethodV(jclass clazz, jmethodID methodID, va_list args);
			new pf_sbyte_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticByteMethodA), //virtual jbyte JNICALL CallStaticByteMethodA(jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jchar JNICALL CallStaticCharMethod(jclass clazz, jmethodID methodID, ...);
			null, //virtual jchar JNICALL CallStaticCharMethodV(jclass clazz, jmethodID methodID, va_list args);
			new pf_ushort_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticCharMethodA), //virtual jchar JNICALL CallStaticCharMethodA(jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jshort JNICALL CallStaticShortMethod(jclass clazz, jmethodID methodID, ...);
			null, //virtual jshort JNICALL CallStaticShortMethodV(jclass clazz, jmethodID methodID, va_list args);
			new pf_short_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticShortMethodA), //virtual jshort JNICALL CallStaticShortMethodA(jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jint JNICALL CallStaticIntMethod(jclass clazz, jmethodID methodID, ...);
			null, //virtual jint JNICALL CallStaticIntMethodV(jclass clazz, jmethodID methodID, va_list args);
			new pf_int_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticIntMethodA), //virtual jint JNICALL CallStaticIntMethodA(jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jlong JNICALL CallStaticLongMethod(jclass clazz, jmethodID methodID, ...);
			null, //virtual jlong JNICALL CallStaticLongMethodV(jclass clazz, jmethodID methodID, va_list args);
			new pf_long_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticLongMethodA), //virtual jlong JNICALL CallStaticLongMethodA(jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jfloat JNICALL CallStaticFloatMethod(jclass clazz, jmethodID methodID, ...);
			null, //virtual jfloat JNICALL CallStaticFloatMethodV(jclass clazz, jmethodID methodID, va_list args);
			new pf_float_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticFloatMethodA), //virtual jfloat JNICALL CallStaticFloatMethodA(jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual jdouble JNICALL CallStaticDoubleMethod(jclass clazz, jmethodID methodID, ...);
			null, //virtual jdouble JNICALL CallStaticDoubleMethodV(jclass clazz, jmethodID methodID, va_list args);
			new pf_double_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticDoubleMethodA), //virtual jdouble JNICALL CallStaticDoubleMethodA(jclass clazz, jmethodID methodID, jvalue *args);

			null, //virtual void JNICALL CallStaticVoidMethod(jclass cls, jmethodID methodID, ...);
			null, //virtual void JNICALL CallStaticVoidMethodV(jclass cls, jmethodID methodID, va_list args);
			new pf_void_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticVoidMethodA), //virtual void JNICALL CallStaticVoidMethodA(jclass cls, jmethodID methodID, jvalue * args);

			new pf_IntPtr_IntPtr_pbyte_pbyte(JNIEnv.GetStaticFieldID), //virtual jfieldID JNICALL GetStaticFieldID(jclass clazz, const char *name, const char *sig);

			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetStaticObjectField), //virtual jobject JNICALL GetObjectField(jobject obj, jfieldID fieldID);
			new pf_sbyte_IntPtr_IntPtr(JNIEnv.GetStaticBooleanField), //virtual jboolean JNICALL GetBooleanField(jobject obj, jfieldID fieldID);
			new pf_sbyte_IntPtr_IntPtr(JNIEnv.GetStaticByteField), //virtual jbyte JNICALL GetByteField(jobject obj, jfieldID fieldID);
			new pf_ushort_IntPtr_IntPtr(JNIEnv.GetStaticCharField), //virtual jchar JNICALL GetCharField(jobject obj, jfieldID fieldID);
			new pf_short_IntPtr_IntPtr(JNIEnv.GetStaticShortField), //virtual jshort JNICALL GetShortField(jobject obj, jfieldID fieldID);
			new pf_int_IntPtr_IntPtr(JNIEnv.GetStaticIntField), //virtual jint JNICALL GetIntField(jobject obj, jfieldID fieldID);
			new pf_long_IntPtr_IntPtr(JNIEnv.GetStaticLongField), //virtual jlong JNICALL GetLongField(jobject obj, jfieldID fieldID);
			new pf_float_IntPtr_IntPtr(JNIEnv.GetStaticFloatField), //virtual jfloat JNICALL GetFloatField(jobject obj, jfieldID fieldID);
			new pf_double_IntPtr_IntPtr(JNIEnv.GetStaticDoubleField), //virtual jdouble JNICALL GetDoubleField(jobject obj, jfieldID fieldID);

			new pf_void_IntPtr_IntPtr_IntPtr(JNIEnv.SetStaticObjectField), //virtual void JNICALL SetObjectField(jobject obj, jfieldID fieldID, jobject val);
			new pf_void_IntPtr_IntPtr_sbyte(JNIEnv.SetStaticBooleanField), //virtual void JNICALL SetBooleanField(jobject obj, jfieldID fieldID, jboolean val);
			new pf_void_IntPtr_IntPtr_sbyte(JNIEnv.SetStaticByteField), //virtual void JNICALL SetByteField(jobject obj, jfieldID fieldID, jbyte val);
			new pf_void_IntPtr_IntPtr_ushort(JNIEnv.SetStaticCharField), //virtual void JNICALL SetCharField(jobject obj, jfieldID fieldID, jchar val);
			new pf_void_IntPtr_IntPtr_short(JNIEnv.SetStaticShortField), //virtual void JNICALL SetShortField(jobject obj, jfieldID fieldID, jshort val);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.SetStaticIntField), //virtual void JNICALL SetIntField(jobject obj, jfieldID fieldID, jint val);
			new pf_void_IntPtr_IntPtr_long(JNIEnv.SetStaticLongField), //virtual void JNICALL SetLongField(jobject obj, jfieldID fieldID, jlong val);
			new pf_void_IntPtr_IntPtr_float(JNIEnv.SetStaticFloatField), //virtual void JNICALL SetFloatField(jobject obj, jfieldID fieldID, jfloat val);
			new pf_void_IntPtr_IntPtr_double(JNIEnv.SetStaticDoubleField), //virtual void JNICALL SetDoubleField(jobject obj, jfieldID fieldID, jdouble val);

			new pf_IntPtr_pjchar_int(JNIEnv.NewString), //virtual jstring JNICALL NewString(const jchar *unicode, jsize len);
			new pf_int_IntPtr(JNIEnv.GetStringLength), //virtual jsize JNICALL GetStringLength(jstring str);
			new pf_pjchar_IntPtr_pjboolean(JNIEnv.GetStringChars), //virtual const jchar *JNICALL GetStringChars(jstring str, jboolean *isCopy);
			new pf_void_IntPtr_pjchar(JNIEnv.ReleaseStringChars), //virtual void JNICALL ReleaseStringChars(jstring str, const jchar *chars);

			new pf_IntPtr_pbyte(JNIEnv.NewStringUTF), //virtual jstring JNICALL NewStringUTF(const char *utf);
			new pf_int_IntPtr(JNIEnv.GetStringUTFLength), //virtual jsize JNICALL GetStringUTFLength(jstring str);
			new pf_pbyte_IntPtr_pjboolean(JNIEnv.GetStringUTFChars), //virtual const char* JNICALL GetStringUTFChars(jstring str, jboolean *isCopy);
			new pf_void_IntPtr_pbyte(JNIEnv.ReleaseStringUTFChars), //virtual void JNICALL ReleaseStringUTFChars(jstring str, const char* chars);

			new pf_int_IntPtr(JNIEnv.GetArrayLength), //virtual jsize JNICALL GetArrayLength(jarray array);

			new pf_IntPtr_int_IntPtr_IntPtr(JNIEnv.NewObjectArray), //virtual jobjectArray JNICALL NewObjectArray(jsize len, jclass clazz, jobject init);
			new pf_IntPtr_IntPtr_int(JNIEnv.GetObjectArrayElement), //virtual jobject JNICALL GetObjectArrayElement(jobjectArray array, jsize index);
			new pf_void_IntPtr_int_IntPtr(JNIEnv.SetObjectArrayElement), //virtual void JNICALL SetObjectArrayElement(jobjectArray array, jsize index, jobject val);

			new pf_IntPtr_int(JNIEnv.NewBooleanArray), //virtual jbooleanArray JNICALL NewBooleanArray(jsize len);
			new pf_IntPtr_int(JNIEnv.NewByteArray), //virtual jbyteArray JNICALL NewByteArray(jsize len);
			new pf_IntPtr_int(JNIEnv.NewCharArray), //virtual jcharArray JNICALL NewCharArray(jsize len);
			new pf_IntPtr_int(JNIEnv.NewShortArray), //virtual jshortArray JNICALL NewShortArray(jsize len);
			new pf_IntPtr_int(JNIEnv.NewIntArray), //virtual jintArray JNICALL NewIntArray(jsize len);
			new pf_IntPtr_int(JNIEnv.NewLongArray), //virtual jlongArray JNICALL NewLongArray(jsize len);
			new pf_IntPtr_int(JNIEnv.NewFloatArray), //virtual jfloatArray JNICALL NewFloatArray(jsize len);
			new pf_IntPtr_int(JNIEnv.NewDoubleArray), //virtual jdoubleArray JNICALL NewDoubleArray(jsize len);

			new pf_pjboolean_IntPtr_pjboolean(JNIEnv.GetBooleanArrayElements), //virtual jboolean * JNICALL GetBooleanArrayElements(jbooleanArray array, jboolean *isCopy);
			new pf_pjbyte_IntPtr_pjboolean(JNIEnv.GetByteArrayElements), //virtual jbyte * JNICALL GetByteArrayElements(jbyteArray array, jboolean *isCopy);
			new pf_pjchar_IntPtr_pjboolean(JNIEnv.GetCharArrayElements), //virtual jchar * JNICALL GetCharArrayElements(jcharArray array, jboolean *isCopy);
			new pf_pjshort_IntPtr_pjboolean(JNIEnv.GetShortArrayElements), //virtual jshort * JNICALL GetShortArrayElements(jshortArray array, jboolean *isCopy);
			new pf_pjint_IntPtr_pjboolean(JNIEnv.GetIntArrayElements), //virtual jint * JNICALL GetIntArrayElements(jintArray array, jboolean *isCopy);
			new pf_pjlong_IntPtr_pjboolean(JNIEnv.GetLongArrayElements), //virtual jlong * JNICALL GetLongArrayElements(jlongArray array, jboolean *isCopy);
			new pf_pjfloat_IntPtr_pjboolean(JNIEnv.GetFloatArrayElements), //virtual jfloat * JNICALL GetFloatArrayElements(jfloatArray array, jboolean *isCopy);
			new pf_pjdouble_IntPtr_pjboolean(JNIEnv.GetDoubleArrayElements), //virtual jdouble * JNICALL GetDoubleArrayElements(jdoubleArray array, jboolean *isCopy);

			new pf_void_IntPtr_pjboolean_int(JNIEnv.ReleaseBooleanArrayElements), //virtual void JNICALL ReleaseBooleanArrayElements(jbooleanArray array, jboolean *elems, jint mode);
			new pf_void_IntPtr_pjbyte_int(JNIEnv.ReleaseByteArrayElements), //virtual void JNICALL ReleaseByteArrayElements(jbyteArray array, jbyte *elems, jint mode);
			new pf_void_IntPtr_pjchar_int(JNIEnv.ReleaseCharArrayElements), //virtual void JNICALL ReleaseCharArrayElements(jcharArray array, jchar *elems, jint mode);
			new pf_void_IntPtr_pjshort_int(JNIEnv.ReleaseShortArrayElements), //virtual void JNICALL ReleaseShortArrayElements(jshortArray array, jshort *elems, jint mode);
			new pf_void_IntPtr_pjint_int(JNIEnv.ReleaseIntArrayElements), //virtual void JNICALL ReleaseIntArrayElements(jintArray array, jint *elems, jint mode);
			new pf_void_IntPtr_pjlong_int(JNIEnv.ReleaseLongArrayElements), //virtual void JNICALL ReleaseLongArrayElements(jlongArray array, jlong *elems, jint mode);
			new pf_void_IntPtr_pjfloat_int(JNIEnv.ReleaseFloatArrayElements), //virtual void JNICALL ReleaseFloatArrayElements(jfloatArray array, jfloat *elems, jint mode);
			new pf_void_IntPtr_pjdouble_int(JNIEnv.ReleaseDoubleArrayElements), //virtual void JNICALL ReleaseDoubleArrayElements(jdoubleArray array, jdouble *elems, jint mode);

			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetBooleanArrayRegion), //virtual void JNICALL GetBooleanArrayRegion(jbooleanArray array, jsize start, jsize l, jboolean *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetByteArrayRegion), //virtual void JNICALL GetByteArrayRegion(jbyteArray array, jsize start, jsize len, jbyte *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetCharArrayRegion), //virtual void JNICALL GetCharArrayRegion(jcharArray array, jsize start, jsize len, jchar *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetShortArrayRegion), //virtual void JNICALL GetShortArrayRegion(jshortArray array, jsize start, jsize len, jshort *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetIntArrayRegion), //virtual void JNICALL GetIntArrayRegion(jintArray array, jsize start, jsize len, jint *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetLongArrayRegion), //virtual void JNICALL GetLongArrayRegion(jlongArray array, jsize start, jsize len, jlong *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetFloatArrayRegion), //virtual void JNICALL GetFloatArrayRegion(jfloatArray array, jsize start, jsize len, jfloat *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetDoubleArrayRegion), //virtual void JNICALL GetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, jdouble *buf);

			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.SetBooleanArrayRegion), //virtual void JNICALL SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize l, jboolean *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.SetByteArrayRegion), //virtual void JNICALL SetByteArrayRegion(jbyteArray array, jsize start, jsize len, jbyte *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.SetCharArrayRegion), //virtual void JNICALL SetCharArrayRegion(jcharArray array, jsize start, jsize len, jchar *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.SetShortArrayRegion), //virtual void JNICALL SetShortArrayRegion(jshortArray array, jsize start, jsize len, jshort *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.SetIntArrayRegion), //virtual void JNICALL SetIntArrayRegion(jintArray array, jsize start, jsize len, jint *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.SetLongArrayRegion), //virtual void JNICALL SetLongArrayRegion(jlongArray array, jsize start, jsize len, jlong *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.SetFloatArrayRegion), //virtual void JNICALL SetFloatArrayRegion(jfloatArray array, jsize start, jsize len, jfloat *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.SetDoubleArrayRegion), //virtual void JNICALL SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, jdouble *buf);

			new pf_int_IntPtr_pJNINativeMethod_int(JNIEnv.RegisterNatives), //virtual jint JNICALL RegisterNatives(jclass clazz, const JNINativeMethod *methods, jint nMethods);
			new pf_int_IntPtr(JNIEnv.UnregisterNatives), //virtual jint JNICALL UnregisterNatives(jclass clazz);

			new pf_int_IntPtr(JNIEnv.MonitorEnter), //virtual jint JNICALL MonitorEnter(jobject obj);
			new pf_int_IntPtr(JNIEnv.MonitorExit), //virtual jint JNICALL MonitorExit(jobject obj);

			new pf_int_ppJavaVM(JNIEnv.GetJavaVM), //virtual jint JNICALL GetJavaVM(JavaVM **vm);

			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetStringRegion), //virtual void JNICALL GetStringRegion(jstring str, jsize start, jsize len, jchar *buf);
			new pf_void_IntPtr_int_int_IntPtr(JNIEnv.GetStringUTFRegion), //virtual void JNICALL GetStringUTFRegion(jstring str, jsize start, jsize len, char *buf);

			new pf_pvoid_IntPtr_pjboolean(JNIEnv.GetPrimitiveArrayCritical), //virtual void* JNICALL GetPrimitiveArrayCritical(jarray array, jboolean *isCopy);
			new pf_void_IntPtr_pvoid_int(JNIEnv.ReleasePrimitiveArrayCritical), //virtual void JNICALL ReleasePrimitiveArrayCritical(jarray array, void *carray, jint mode);

			new pf_pjchar_IntPtr_pjboolean(JNIEnv.GetStringCritical), //virtual const jchar* JNICALL GetStringCritical(jstring string, jboolean *isCopy);
			new pf_void_IntPtr_pjchar(JNIEnv.ReleaseStringCritical), //virtual void JNICALL ReleaseStringCritical(jstring string, const jchar *cstring);

			new pf_IntPtr_IntPtr(JNIEnv.NewWeakGlobalRef), //virtual jweak JNICALL NewWeakGlobalRef(jobject obj);
			new pf_void_IntPtr(JNIEnv.DeleteWeakGlobalRef), //virtual void JNICALL DeleteWeakGlobalRef(jweak ref);

			new pf_sbyte(JNIEnv.ExceptionCheck), //virtual jboolean JNICALL ExceptionCheck();

			new pf_IntPtr_IntPtr_long(JNIEnv.NewDirectByteBuffer), //virtual jobject JNICALL NewDirectByteBuffer(void* address, jlong capacity);
			new pf_IntPtr_IntPtr(JNIEnv.GetDirectBufferAddress), //virtual void* JNICALL GetDirectBufferAddress(jobject buf);
			new pf_long_IntPtr(JNIEnv.GetDirectBufferCapacity), //virtual jlong JNICALL GetDirectBufferCapacity(jobject buf);

			new pf_int_IntPtr(JNIEnv.GetObjectRefType) // virtual jobjectRefType GetObjectRefType(jobject obj);
		};
	}

	[StructLayout(LayoutKind.Sequential)]
	unsafe struct JavaVMAttachArgs
	{
		internal jint version;
		internal byte* name;
		internal jobject group;
	}

	[StructLayout(LayoutKind.Sequential)]
	unsafe struct JavaVM
	{
		internal static JavaVM* pJavaVM;
		void** vtable;
		void* firstVtableEntry;
		delegate int pf_int(JavaVM* pJVM);
		delegate int pf_int_ppvoid_pvoid(JavaVM* pJVM, void** p1, void* p2);
		delegate int pf_int_ppvoid_int(JavaVM* pJVM, void** p1, int p2);

		static Delegate[] vtableDelegates =
		{
			null,
			null,
			null,
			new pf_int(DestroyJavaVM),
			new pf_int_ppvoid_pvoid(AttachCurrentThread),
			new pf_int(DetachCurrentThread),
			new pf_int_ppvoid_int(GetEnv),
			new pf_int_ppvoid_pvoid(AttachCurrentThreadAsDaemon)
		};

		static JavaVM()
		{
			JNI.jvmCreated = true;
			pJavaVM = (JavaVM*)(void*)JniMem.Alloc(IntPtr.Size * (1 + vtableDelegates.Length));
			pJavaVM->vtable = &pJavaVM->firstVtableEntry;
			for(int i = 0; i < vtableDelegates.Length; i++)
			{
				pJavaVM->vtable[i] = NativeLibrary.MarshalDelegate(vtableDelegates[i]);
			}
		}

		internal static jint DestroyJavaVM(JavaVM* pJVM)
		{
			if(JNI.jvmDestroyed)
			{
				return JNIEnv.JNI_ERR;
			}
			JNI.jvmDestroyed = true;
			Java_java_lang_Thread.WaitUntilLastJniThread();
			return JNIEnv.JNI_OK;
		}

		internal static jint AttachCurrentThread(JavaVM* pJVM, void **penv, void *args)
		{
			return AttachCurrentThreadImpl(pJVM, penv, (JavaVMAttachArgs*)args, false);
		}

		internal static jint AttachCurrentThreadImpl(JavaVM* pJVM, void** penv, JavaVMAttachArgs* pAttachArgs, bool asDaemon)
		{
			if(pAttachArgs != null)
			{
				if(!JNI.IsSupportedJniVersion(pAttachArgs->version) || pAttachArgs->version == JNIEnv.JNI_VERSION_1_1)
				{
					*penv = null;
					return JNIEnv.JNI_EVERSION;
				}
			}
			JNIEnv.ManagedJNIEnv env = TlsHack.ManagedJNIEnv;
			if(env != null)
			{
				*penv = env.pJNIEnv;
				return JNIEnv.JNI_OK;
			}
			// NOTE if we're here, it is *very* likely that the thread was created by native code and not by managed code,
			// but it's not impossible that the thread started life as a managed thread and if it did the changes to the
			// thread we're making are somewhat dubious.
			System.Threading.Thread.CurrentThread.IsBackground = asDaemon;
			if(pAttachArgs != null)
			{
				if(pAttachArgs->name != null && System.Threading.Thread.CurrentThread.Name == null)
				{
					try
					{
						System.Threading.Thread.CurrentThread.Name = JNIEnv.StringFromUTF8(pAttachArgs->name);
					}
					catch(InvalidOperationException)
					{
						// someone beat us to it...
					}
				}
				object threadGroup = GlobalRefs.Unwrap(pAttachArgs->group.ToInt32());
				if(threadGroup != null)
				{
					Java_java_lang_Thread.AttachThreadFromJni(threadGroup);
				}
			}
			*penv = JNIEnv.CreateJNIEnv();
			return JNIEnv.JNI_OK;
		}

		internal static jint DetachCurrentThread(JavaVM* pJVM)
		{
			if(TlsHack.ManagedJNIEnv == null)
			{
				// the JDK allows detaching from an already detached thread
				return JNIEnv.JNI_OK;
			}
			// TODO if we set Thread.IsBackground to false when we attached, now might be a good time to set it back to true.
			JNIEnv.FreeJNIEnv();
			Java_ikvm_runtime_Startup.jniDetach();
			return JNIEnv.JNI_OK;
		}

		internal static jint GetEnv(JavaVM* pJVM, void **penv, jint version)
		{
			if(JNI.IsSupportedJniVersion(version))
			{
				JNIEnv.ManagedJNIEnv env = TlsHack.ManagedJNIEnv;
				if(env != null)
				{
					*penv = env.pJNIEnv;
					return JNIEnv.JNI_OK;
				}
				*penv = null;
				return JNIEnv.JNI_EDETACHED;
			}
			*penv = null;
			return JNIEnv.JNI_EVERSION;
		}

		internal static jint AttachCurrentThreadAsDaemon(JavaVM* pJVM, void **penv, void *args)
		{
			return AttachCurrentThreadImpl(pJVM, penv, (JavaVMAttachArgs*)args, true);
		}
	}

	[StructLayout(LayoutKind.Sequential)]
	unsafe struct JNIEnv
	{
		internal const int JNI_OK = 0;
		internal const int JNI_ERR = -1;
		internal const int JNI_EDETACHED = -2;
		internal const int JNI_EVERSION = -3;
		internal const int JNI_COMMIT = 1;
		internal const int JNI_ABORT = 2;
		internal const int JNI_VERSION_1_1 = 0x00010001;
		internal const int JNI_VERSION_1_2 = 0x00010002;
		internal const int JNI_VERSION_1_4 = 0x00010004;
		internal const int JNI_VERSION_1_6 = 0x00010006;
		internal const int JNI_VERSION_1_8 = 0x00010008;
		internal const int JNIInvalidRefType = 0;
		internal const int JNILocalRefType = 1;
		internal const int JNIGlobalRefType = 2;
		internal const int JNIWeakGlobalRefType = 3;
		internal const sbyte JNI_TRUE = 1;
		internal const sbyte JNI_FALSE = 0;
		private void* vtable;
		private GCHandle managedJNIEnv;
		private GCHandle* pinHandles;
		private int pinHandleMaxCount;
		private int pinHandleInUseCount;

		static JNIEnv()
		{
			// we set the field here so that IKVM.Runtime.dll doesn't have to load us if we're not otherwise needed
			Java_java_lang_SecurityManager.jniAssembly = typeof(JNIEnv).Assembly;
		}

		internal ManagedJNIEnv GetManagedJNIEnv()
		{
			return (ManagedJNIEnv)managedJNIEnv.Target;
		}

		internal sealed class ManagedJNIEnv
		{
			// NOTE the initial bucket size must be a power of two < LOCAL_REF_MAX_BUCKET_SIZE,
			// because each time we grow it, we double the size and it must eventually reach
			// exactly LOCAL_REF_MAX_BUCKET_SIZE
			private const int LOCAL_REF_INITIAL_BUCKET_SIZE = 32;
			private const int LOCAL_REF_SHIFT = 10;
			private const int LOCAL_REF_MAX_BUCKET_SIZE = (1 << LOCAL_REF_SHIFT);
			private const int LOCAL_REF_MASK = (LOCAL_REF_MAX_BUCKET_SIZE - 1);
			internal readonly JNIEnv* pJNIEnv;
			internal ClassLoaderWrapper classLoader;
			internal ikvm.@@internal.CallerID callerID;
			private object[][] localRefs;
			private int localRefSlot;
			private int localRefIndex;
			private object[] active;
			internal Exception pendingException;

			internal ManagedJNIEnv()
			{
				pJNIEnv = (JNIEnv*)JniMem.Alloc(sizeof(JNIEnv));
				localRefs = new object[32][];
				active = localRefs[0] = new object[LOCAL_REF_INITIAL_BUCKET_SIZE];
				// stuff something in the first entry to make sure we don't hand out a zero handle
				// (a zero handle corresponds to a null reference)
				active[0] = "";
				localRefIndex = 1;
			}

			~ManagedJNIEnv()
			{
				// NOTE don't clean up when we're being unloaded (we'll get cleaned up anyway and because
				// of the unorderedness of the finalization process native code could still be run after
				// we run).
				// NOTE when we're not the default AppDomain and we're being unloaded,
				// we're leaking the JNIEnv (but since JNI outside of the default AppDomain isn't currently supported,
				// I can live with that).
				if(!Environment.HasShutdownStarted)
				{
					if(pJNIEnv->managedJNIEnv.IsAllocated)
					{
						pJNIEnv->managedJNIEnv.Free();
					}
					for(int i = 0; i < pJNIEnv->pinHandleMaxCount; i++)
					{
						if(pJNIEnv->pinHandles[i].IsAllocated)
						{
							pJNIEnv->pinHandles[i].Free();
						}
					}
					JniMem.Free((IntPtr)(void*)pJNIEnv);
				}
			}

			internal struct FrameState
			{
				internal readonly ikvm.@@internal.CallerID callerID;
				internal readonly int localRefSlot;
				internal readonly int localRefIndex;

				internal FrameState(ikvm.@@internal.CallerID callerID, int localRefSlot, int localRefIndex)
				{
					this.callerID = callerID;
					this.localRefSlot = localRefSlot;
					this.localRefIndex = localRefIndex;
				}
			}

			internal FrameState Enter(ikvm.@@internal.CallerID newCallerID)
			{
				FrameState prev = new FrameState(callerID, localRefSlot, localRefIndex);
				this.callerID = newCallerID;
				localRefSlot++;
				if (localRefSlot >= localRefs.Length)
				{
					object[][] tmp = new object[localRefs.Length * 2][];
					Array.Copy(localRefs, 0, tmp, 0, localRefs.Length);
					localRefs = tmp;
				}
				localRefIndex = 0;
				active = localRefs[localRefSlot];
				if (active == null)
				{
					active = localRefs[localRefSlot] = new object[LOCAL_REF_INITIAL_BUCKET_SIZE];
				}
				return prev;
			}

			internal Exception Leave(FrameState prev)
			{
				// on the current (.NET 2.0 SP2) x86 JIT an explicit for loop is faster than Array.Clear() up to about 100 elements
				for (int i = 0; i < localRefIndex; i++)
				{
					active[i] = null;
				}
				while (--localRefSlot != prev.localRefSlot)
				{
					if (localRefs[localRefSlot] != null)
					{
						if (localRefs[localRefSlot].Length == LOCAL_REF_MAX_BUCKET_SIZE)
						{
							// if the bucket is totally allocated, we're assuming a leaky method so we throw the bucket away
							localRefs[localRefSlot] = null;
						}
						else
						{
							Array.Clear(localRefs[localRefSlot], 0, localRefs[localRefSlot].Length);
						}
					}
				}
				active = localRefs[localRefSlot];
				this.localRefIndex = prev.localRefIndex;
				this.callerID = prev.callerID;
				Exception x = pendingException;
				pendingException = null;
				return x;
			}

			internal jobject MakeLocalRef(object obj)
			{
				if (obj == null)
				{
					return IntPtr.Zero;
				}

				int index;
				if (localRefIndex == active.Length)
				{
					index = FindFreeIndex();
				}
				else
				{
					index = localRefIndex++;
				}
				active[index] = obj;
				return (IntPtr)((localRefSlot << LOCAL_REF_SHIFT) + index);
			}

			private int FindFreeIndex()
			{
				for (int i = 0; i < active.Length; i++)
				{
					if (active[i] == null)
					{
						while (localRefIndex - 1 > i && active[localRefIndex - 1] == null)
						{
							localRefIndex--;
						}
						return i;
					}
				}
				GrowActiveSlot();
				return localRefIndex++;
			}

			private void GrowActiveSlot()
			{
				if (active.Length < LOCAL_REF_MAX_BUCKET_SIZE)
				{
					object[] tmp = new object[active.Length * 2];
					Array.Copy(active, tmp, active.Length);
					active = localRefs[localRefSlot] = tmp;
					return;
				}
				// if we get here, we're in a native method that most likely is leaking locals refs,
				// so we're going to allocate a new bucket and increment localRefSlot, this means that
				// any slots that become available in the previous bucket are not going to be reused,
				// but since we're assuming that the method is leaking anyway, that isn't a problem
				// (it's never a correctness issue, just a resource consumption issue)
				localRefSlot++;
				localRefIndex = 0;
				if (localRefSlot == localRefs.Length)
				{
					object[][] tmp = new object[localRefSlot * 2][];
					Array.Copy(localRefs, 0, tmp, 0, localRefSlot);
					localRefs = tmp;
				}
				active = localRefs[localRefSlot];
				if (active == null)
				{
					active = localRefs[localRefSlot] = new object[LOCAL_REF_MAX_BUCKET_SIZE];
				}
			}

			internal object UnwrapLocalRef(int i)
			{
				return localRefs[i >> LOCAL_REF_SHIFT][i & LOCAL_REF_MASK];
			}

			internal int PushLocalFrame(jint capacity)
			{
				localRefSlot += 2;
				if (localRefSlot >= localRefs.Length)
				{
					object[][] tmp = new object[localRefs.Length * 2][];
					Array.Copy(localRefs, 0, tmp, 0, localRefs.Length);
					localRefs = tmp;
				}
				// we use a null slot to mark the fact that we used PushLocalFrame
				localRefs[localRefSlot - 1] = null;
				if (localRefs[localRefSlot] == null)
				{
					// we can't use capacity directly, because the array length must be a power of two
					// and it can't be bigger than LOCAL_REF_MAX_BUCKET_SIZE
					int r = 1;
					capacity = Math.Min(capacity, LOCAL_REF_MAX_BUCKET_SIZE);
					while (r < capacity)
					{
						r *= 2;
					}
					localRefs[localRefSlot] = new object[r];
				}
				localRefIndex = 0;
				active = localRefs[localRefSlot];
				return JNI_OK;
			}

			internal jobject PopLocalFrame(object res)
			{
				while (localRefs[localRefSlot] != null)
				{
					localRefs[localRefSlot] = null;
					localRefSlot--;
				}
				localRefSlot--;
				localRefIndex = localRefs[localRefSlot].Length;
				active = localRefs[localRefSlot];
				return MakeLocalRef(res);
			}

			internal void DeleteLocalRef(jobject obj)
			{
				int i = obj.ToInt32();
				if (i > 0)
				{
					localRefs[i >> LOCAL_REF_SHIFT][i & LOCAL_REF_MASK] = null;
					return;
				}
				if (i < 0)
				{
					Debug.Assert(false, "bogus localref in DeleteLocalRef");
				}
			}
		}

		internal static JNIEnv* CreateJNIEnv()
		{
			ManagedJNIEnv env = new ManagedJNIEnv();
			TlsHack.ManagedJNIEnv = env;
			JNIEnv* pJNIEnv = env.pJNIEnv;
			pJNIEnv->vtable = VtableBuilder.vtable;
			pJNIEnv->managedJNIEnv = GCHandle.Alloc(env, GCHandleType.WeakTrackResurrection);
			pJNIEnv->pinHandles = null;
			pJNIEnv->pinHandleMaxCount = 0;
			pJNIEnv->pinHandleInUseCount = 0;
			return pJNIEnv;
		}

		internal static void FreeJNIEnv()
		{
			TlsHack.ManagedJNIEnv = null;
		}

		internal static string StringFromOEM(byte* psz)
		{
			for(int i = 0;; i++)
			{
				if(psz[i] == 0)
				{
					int oem = System.Globalization.CultureInfo.CurrentCulture.TextInfo.OEMCodePage;
					return new String((sbyte*)psz, 0, i, Encoding.GetEncoding(oem));
				}
			}
		}

		internal static string StringFromUTF8(byte* psz)
		{
			// Sun's modified UTF8 encoding is not compatible with System.Text.Encoding.UTF8,
			// so we need to roll our own
			int len = 0;
			bool hasNonAscii = false;
			while(psz[len] != 0)
			{
				hasNonAscii |= psz[len] >= 128;
				len++;
			}
			if(!hasNonAscii)
			{
				// optimize the common case of 7-bit ASCII
				return new String((sbyte*)psz);
			}
			StringBuilder sb = new StringBuilder(len);
			for(int i = 0; i < len; i++)
			{
				int c = *psz++;
				int char2, char3;
				switch(c >> 4)
				{
					case 12:
					case 13:
						char2 = *psz++;
						i++;
						c = (((c & 0x1F) << 6) | (char2 & 0x3F));
						break;
					case 14:
						char2 = *psz++;
						char3 = *psz++;
						i++;
						i++;
						c = ((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | (char3 & 0x3F);
						break;
				}
				sb.Append((char)c);
			}
			return sb.ToString();
		}

		private static int StringUTF8Length(string s)
		{
			int len = 0;
			for(int i = 0; i < s.Length; i++)
			{
				char ch = s[i];
				if((ch != 0) && (ch <= 0x7F))
				{
					len++;
				}
				else if(ch <= 0x7FF)
				{
					len += 2;
				}
				else
				{
					len += 3;
				}
			}
			return len;
		}

		internal static jint GetMethodArgs(JNIEnv* pEnv, IntPtr method, byte* sig)
		{
			TypeWrapper[] argTypes = MethodWrapper.FromCookie(method).GetParameters();
			for (int i = 0; i < argTypes.Length; i++)
			{
				TypeWrapper tw = argTypes[i];
				if (tw.IsPrimitive)
				{
					sig[i] = (byte)tw.SigName[0];
				}
				else
				{
					sig[i] = (byte)'L';
				}
			}
			return argTypes.Length;
		}

		internal static jint GetVersion(JNIEnv* pEnv)
		{
			return JNI_VERSION_1_8;
		}

		internal static jclass DefineClass(JNIEnv* pEnv, byte* name, jobject loader, jbyte* pbuf, jint length)
		{
			try
			{
				byte[] buf = new byte[length];
				Marshal.Copy((IntPtr)(void*)pbuf, buf, 0, length);
				// TODO what should the protection domain be?
				// NOTE I'm assuming name is platform encoded (as opposed to UTF-8), but the Sun JVM only seems to work for ASCII.
				global::java.lang.ClassLoader classLoader = (global::java.lang.ClassLoader)pEnv->UnwrapRef(loader);
				return pEnv->MakeLocalRef(Java_java_lang_ClassLoader.defineClass0(classLoader, name != null ? StringFromOEM(name) : null, buf, 0, buf.Length, null));
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		private static ClassLoaderWrapper FindNativeMethodClassLoader(JNIEnv* pEnv)
		{
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			if(env.callerID != null)
			{
				return ClassLoaderWrapper.FromCallerID(env.callerID);
			}
			if(env.classLoader != null)
			{
				return env.classLoader;
			}
			return ClassLoaderWrapper.GetClassLoaderWrapper(java.lang.ClassLoader.getSystemClassLoader());
		}

		internal static jclass FindClass(JNIEnv* pEnv, byte* pszName)
		{
			try
			{
				string name = StringFromOEM(pszName);
				// don't allow dotted names!
				if(name.IndexOf('.') >= 0)
				{
					SetPendingException(pEnv, new java.lang.NoClassDefFoundError(name));
					return IntPtr.Zero;
				}
				// spec doesn't say it, but Sun allows signature format class names (but not for primitives)
				if(name.StartsWith("L") && name.EndsWith(";"))
				{
					name = name.Substring(1, name.Length - 2);
				}
				TypeWrapper wrapper = FindNativeMethodClassLoader(pEnv).LoadClassByDottedNameFast(name.Replace('/', '.'));
				if(wrapper == null)
				{
					SetPendingException(pEnv, new java.lang.NoClassDefFoundError(name));
					return IntPtr.Zero;
				}
				wrapper.Finish();
				// spec doesn't say it, but Sun runs the static initializer
				wrapper.RunClassInit();
				return pEnv->MakeLocalRef(wrapper.ClassObject);
			}
			catch(Exception x)
			{
				if(x is RetargetableJavaException)
				{
					x = ((RetargetableJavaException)x).ToJava();
				}
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jmethodID FromReflectedMethod(JNIEnv* pEnv, jobject method)
		{
			return MethodWrapper.FromExecutable((java.lang.reflect.Executable)pEnv->UnwrapRef(method)).Cookie;
		}

		internal static jfieldID FromReflectedField(JNIEnv* pEnv, jobject field)
		{
			return FieldWrapper.FromField((java.lang.reflect.Field)pEnv->UnwrapRef(field)).Cookie;
		}

		internal static jobject ToReflectedMethod(JNIEnv* pEnv, jclass clazz_ignored, jmethodID method, jboolean isStatic)
		{
			return pEnv->MakeLocalRef(MethodWrapper.FromCookie(method).ToMethodOrConstructor(true));
		}

		internal static jclass GetSuperclass(JNIEnv* pEnv, jclass sub)
		{
			TypeWrapper wrapper = TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(sub)).BaseTypeWrapper;
			return pEnv->MakeLocalRef(wrapper == null ? null : wrapper.ClassObject);
		}

		internal static jboolean IsAssignableFrom(JNIEnv* pEnv, jclass sub, jclass super)
		{
			TypeWrapper w1 = TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(sub));
			TypeWrapper w2 = TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(super));
			return w1.IsAssignableTo(w2) ? JNI_TRUE : JNI_FALSE;
		}

		internal static jobject ToReflectedField(JNIEnv* pEnv, jclass clazz_ignored, jfieldID field, jboolean isStatic)
		{
			return pEnv->MakeLocalRef(FieldWrapper.FromCookie(field).ToField(true));
		}

		private static void SetPendingException(JNIEnv* pEnv, Exception x)
		{
			pEnv->GetManagedJNIEnv().pendingException = ikvm.runtime.Util.mapException(x);
		}

		internal static jint Throw(JNIEnv* pEnv, jthrowable throwable)
		{
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			Exception x = UnwrapRef(env, throwable) as Exception;
			if (x != null)
			{
				env.pendingException = x;
			}
			return JNI_OK;
		}

		internal static jint ThrowNew(JNIEnv* pEnv, jclass clazz, byte* msg)
		{
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			TypeWrapper wrapper = TypeWrapper.FromClass((java.lang.Class)UnwrapRef(env, clazz));
			MethodWrapper mw = wrapper.GetMethodWrapper("<init>", msg == null ? "()V" : "(Ljava.lang.String;)V", false);
			if(mw != null)
			{
				jint rc;
				Exception exception;
				try
				{
					wrapper.Finish();
					java.lang.reflect.Constructor cons = (java.lang.reflect.Constructor)mw.ToMethodOrConstructor(false);
					exception = (Exception)cons.newInstance(msg == null ? new object[0] : new object[] { StringFromOEM(msg) }, env.callerID);
					rc = JNI_OK;
				}
				catch(RetargetableJavaException x)
				{
					exception = x.ToJava();
					rc = JNI_ERR;
				}
				catch(Exception x)
				{
					exception = x;
					rc = JNI_ERR;
				}
				SetPendingException(pEnv, exception);
				return rc;
			}
			else
			{
				SetPendingException(pEnv, new java.lang.NoSuchMethodError("<init>(Ljava.lang.String;)V"));
				return JNI_ERR;
			}
		}

		internal static jthrowable ExceptionOccurred(JNIEnv* pEnv)
		{
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			return pEnv->MakeLocalRef(env.pendingException);
		}

		internal static void ExceptionDescribe(JNIEnv* pEnv)
		{
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			Exception x = env.pendingException;
			if(x != null)
			{
				env.pendingException = null;
				try
				{
					ikvm.extensions.ExtensionMethods.printStackTrace(x);
				}
				catch(Exception ex)
				{
					Debug.Assert(false, ex.ToString());
				}
			}
		}

		internal static void ExceptionClear(JNIEnv* pEnv)
		{
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			env.pendingException = null;
		}

		internal static void FatalError(JNIEnv* pEnv, byte* msg)
		{
			Console.Error.WriteLine("FATAL ERROR in native method: {0}", msg == null ? "(null)" : StringFromOEM(msg));
			Console.Error.WriteLine(new StackTrace(1, true));
			Environment.Exit(1);
		}

		internal static jint PushLocalFrame(JNIEnv* pEnv, jint capacity)
		{
			return pEnv->GetManagedJNIEnv().PushLocalFrame(capacity);
		}

		internal static jobject PopLocalFrame(JNIEnv* pEnv, jobject result)
		{
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			return env.PopLocalFrame(UnwrapRef(env, result));
		}

		internal static jobject NewGlobalRef(JNIEnv* pEnv, jobject obj)
		{
			object o = pEnv->UnwrapRef(obj);
			if(o == null)
			{
				return IntPtr.Zero;
			}
			lock(GlobalRefs.globalRefs)
			{
				int index = GlobalRefs.globalRefs.IndexOf(null);
				if(index >= 0)
				{
					GlobalRefs.globalRefs[index] = o;
				}
				else
				{
					index = GlobalRefs.globalRefs.Add(o);
				}
				return (IntPtr)(-(index + 1));
			}
		}

		internal static void DeleteGlobalRef(JNIEnv* pEnv, jobject obj)
		{
			int i = obj.ToInt32();
			if(i < 0)
			{
				lock(GlobalRefs.globalRefs)
				{
					GlobalRefs.globalRefs[(-i) - 1] = null;
				}
				return;
			}
			if(i > 0)
			{
				Debug.Assert(false, "Local ref passed to DeleteGlobalRef");
			}
		}

		internal static void DeleteLocalRef(JNIEnv* pEnv, jobject obj)
		{
			pEnv->GetManagedJNIEnv().DeleteLocalRef(obj);
		}

		internal static jboolean IsSameObject(JNIEnv* pEnv, jobject obj1, jobject obj2)
		{
			return pEnv->UnwrapRef(obj1) == pEnv->UnwrapRef(obj2) ? JNI_TRUE : JNI_FALSE;
		}

		internal static jobject NewLocalRef(JNIEnv* pEnv, jobject obj)
		{
			return pEnv->MakeLocalRef(pEnv->UnwrapRef(obj));
		}

		internal static jint EnsureLocalCapacity(JNIEnv* pEnv, jint capacity)
		{
			// since we can dynamically grow the local ref table, we'll just return success for any number
			return JNI_OK;
		}

		internal static jobject AllocObject(JNIEnv* pEnv, jclass clazz)
		{
			return AllocObjectImpl(pEnv, TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(clazz)));
		}

		private static jobject AllocObjectImpl(JNIEnv* pEnv, TypeWrapper wrapper)
		{
			try
			{
				if(wrapper.IsAbstract)
				{
					SetPendingException(pEnv, new java.lang.InstantiationException(wrapper.Name));
					return IntPtr.Zero;
				}
				wrapper.Finish();
				return pEnv->MakeLocalRef(System.Runtime.Serialization.FormatterServices.GetUninitializedObject(wrapper.TypeAsBaseType));
			}
			catch(RetargetableJavaException x)
			{
				SetPendingException(pEnv, x.ToJava());
				return IntPtr.Zero;
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		[StructLayout(LayoutKind.Explicit)]
			internal struct jvalue
		{
			[FieldOffset(0)]
			public jboolean z;
			[FieldOffset(0)]
			public jbyte b;
			[FieldOffset(0)]
			public jchar c;
			[FieldOffset(0)]
			public jshort s;
			[FieldOffset(0)]
			public jint i;
			[FieldOffset(0)]
			public jlong j;
			[FieldOffset(0)]
			public jfloat f;
			[FieldOffset(0)]
			public jdouble d;
			[FieldOffset(0)]
			public jobject l;
		}

		private static object InvokeHelper(JNIEnv* pEnv, jobject objHandle, jmethodID methodID, jvalue* pArgs, bool nonVirtual)
		{
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			object obj = UnwrapRef(env, objHandle);
			MethodWrapper mw = MethodWrapper.FromCookie(methodID);
			mw.Link();
			mw.ResolveMethod();
			TypeWrapper[] argTypes = mw.GetParameters();
			object[] args = new object[argTypes.Length + (mw.HasCallerID ? 1 : 0)];
			for (int i = 0; i < argTypes.Length; i++)
			{
				TypeWrapper type = argTypes[i];
				if (type == PrimitiveTypeWrapper.BOOLEAN)
					args[i] = pArgs[i].z != JNI_FALSE;
				else if (type == PrimitiveTypeWrapper.BYTE)
					args[i] = (byte)pArgs[i].b;
				else if (type == PrimitiveTypeWrapper.CHAR)
					args[i] = (char)pArgs[i].c;
				else if (type == PrimitiveTypeWrapper.SHORT)
					args[i] = pArgs[i].s;
				else if (type == PrimitiveTypeWrapper.INT)
					args[i] = pArgs[i].i;
				else if (type == PrimitiveTypeWrapper.LONG)
					args[i] = pArgs[i].j;
				else if (type == PrimitiveTypeWrapper.FLOAT)
					args[i] = pArgs[i].f;
				else if (type == PrimitiveTypeWrapper.DOUBLE)
					args[i] = pArgs[i].d;
				else
					args[i] = argTypes[i].GhostWrap(UnwrapRef(env, pArgs[i].l));
			}
			if (mw.HasCallerID)
			{
				args[args.Length - 1] = env.callerID;
			}
			try
			{
				if (nonVirtual && mw.RequiresNonVirtualDispatcher)
				{
					return InvokeNonVirtual(env, mw, obj, args);
				}
				if (mw.IsConstructor)
				{
					if (obj == null)
					{
						return mw.CreateInstance(args);
					}
					else
					{
						MethodBase mb = mw.GetMethod();
						if (mb.IsStatic)
						{
							// we're dealing with a constructor on a remapped type, if obj is supplied, it means
							// that we should call the constructor on an already existing instance, but that isn't
							// possible with remapped types
							throw new NotSupportedException(string.Format("Remapped type {0} doesn't support constructor invocation on an existing instance", mw.DeclaringType.Name));
						}
						else if (!mb.DeclaringType.IsInstanceOfType(obj))
						{
							// we're trying to initialize an existing instance of a remapped type
							throw new NotSupportedException("Unable to partially construct object of type " + obj.GetType().FullName + " to type " + mb.DeclaringType.FullName);
						}
					}
				}
				return mw.Invoke(obj, args);
			}
			catch (Exception x)
			{
				SetPendingException(pEnv, ikvm.runtime.Util.mapException(x));
				return null;
			}
		}

		private static object InvokeNonVirtual(ManagedJNIEnv env, MethodWrapper mw, object obj, object[] argarray)
		{
			if (mw.HasCallerID || mw.IsDynamicOnly)
			{
				throw new NotSupportedException();
			}
			if (mw.DeclaringType.IsRemapped && !mw.DeclaringType.TypeAsBaseType.IsInstanceOfType(obj))
			{
				return mw.InvokeNonvirtualRemapped(obj, argarray);
			}
			else
			{
				Delegate del = (Delegate)Activator.CreateInstance(mw.GetDelegateType(),
					new object[] { obj, mw.GetMethod().MethodHandle.GetFunctionPointer() });
				try
				{
					return del.DynamicInvoke(argarray);
				}
				catch (TargetInvocationException x)
				{
					throw ikvm.runtime.Util.mapException(x.InnerException);
				}
			}
		}

		internal static jobject NewObjectA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			TypeWrapper wrapper = TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(clazz));
			if(!wrapper.IsAbstract && wrapper.TypeAsBaseType.IsAbstract)
			{
				// static newinstance helper method
				return pEnv->MakeLocalRef(InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false));
			}
			jobject obj = AllocObjectImpl(pEnv, wrapper);
			if(obj != IntPtr.Zero)
			{
				InvokeHelper(pEnv, obj, methodID, args, false);
				if(ExceptionCheck(pEnv) == JNI_TRUE)
				{
					DeleteLocalRef(pEnv, obj);
					obj = IntPtr.Zero;
				}
			}
			return obj;
		}

		internal static jclass GetObjectClass(JNIEnv* pEnv, jobject obj)
		{
			return pEnv->MakeLocalRef(IKVM.NativeCode.ikvm.runtime.Util.getClassFromObject(pEnv->UnwrapRef(obj)));
		}

		internal static jboolean IsInstanceOf(JNIEnv* pEnv, jobject obj, jclass clazz)
		{
			// NOTE if clazz is an interface, this is still the right thing to do
			// (i.e. if the object implements the interface, we return true)
			java.lang.Class objClass = IKVM.NativeCode.ikvm.runtime.Util.getClassFromObject(pEnv->UnwrapRef(obj));
			TypeWrapper w1 = TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(clazz));
			TypeWrapper w2 = TypeWrapper.FromClass(objClass);
			return w2.IsAssignableTo(w1) ? JNI_TRUE : JNI_FALSE;
		}

		private static MethodWrapper GetMethodImpl(TypeWrapper tw, string name, string sig)
		{
			for(;;)
			{
				MethodWrapper mw = tw.GetMethodWrapper(name, sig, true);
				if(mw == null || !mw.IsHideFromReflection)
				{
					return mw;
				}
				tw = mw.DeclaringType.BaseTypeWrapper;
				if(tw == null)
				{
					return null;
				}
			}
		}

		private static void AppendInterfaces(List<TypeWrapper> list, IList<TypeWrapper> add)
		{
			foreach (TypeWrapper iface in add)
			{
				if (!list.Contains(iface))
				{
					list.Add(iface);
				}
			}
		}

		private static List<TypeWrapper> TransitiveInterfaces(TypeWrapper tw)
		{
			List<TypeWrapper> list = new List<TypeWrapper>();
			if (tw.BaseTypeWrapper != null)
			{
				AppendInterfaces(list, TransitiveInterfaces(tw.BaseTypeWrapper));
			}
			foreach (TypeWrapper iface in tw.Interfaces)
			{
				AppendInterfaces(list, TransitiveInterfaces(iface));
			}
			AppendInterfaces(list, tw.Interfaces);
			return list;
		}

		private static MethodWrapper GetInterfaceMethodImpl(TypeWrapper tw, string name, string sig)
		{
			foreach (TypeWrapper iface in TransitiveInterfaces(tw))
			{
				MethodWrapper mw = iface.GetMethodWrapper(name, sig, false);
				if (mw != null && !mw.IsHideFromReflection)
				{
					return mw;
				}
			}
			return null;
		}

		private static jmethodID FindMethodID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig, bool isstatic)
		{
			try
			{
				TypeWrapper wrapper = TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(clazz));
				wrapper.Finish();
				// if name == NULL, the JDK returns the constructor
				string methodname = (IntPtr)name == IntPtr.Zero ? "<init>" : StringFromUTF8(name);
				string methodsig = StringFromUTF8(sig);
				MethodWrapper mw = null;
				// don't allow dotted names!
				if(methodsig.IndexOf('.') < 0)
				{
					methodsig = methodsig.Replace('/', '.');
					if(methodname == "<init>" || methodname == "<clinit>")
					{
						mw = wrapper.GetMethodWrapper(methodname, methodsig, false);
					}
					else
					{
						mw = GetMethodImpl(wrapper, methodname, methodsig);
						if(mw == null)
						{
							mw = GetInterfaceMethodImpl(wrapper, methodname, methodsig);
						}
					}
				}
				if(mw != null && mw.IsStatic == isstatic)
				{
					mw.Link();
					return mw.Cookie;
				}
				SetPendingException(pEnv, new java.lang.NoSuchMethodError(string.Format("{0}{1}", methodname, methodsig)));
			}
			catch(RetargetableJavaException x)
			{
				SetPendingException(pEnv, x.ToJava());
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
			}
			return IntPtr.Zero;
		}

		internal static jmethodID GetMethodID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig)
		{
			return FindMethodID(pEnv, clazz, name, sig, false);
		}

		internal static jobject CallObjectMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
		{
			return pEnv->MakeLocalRef(InvokeHelper(pEnv, obj, methodID, args, false));
		}

		internal static jboolean CallBooleanMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, false);
			if(o != null)
			{
				return ((bool)o) ? JNI_TRUE : JNI_FALSE;
			}
			return JNI_FALSE;
		}

		internal static jbyte CallByteMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, false);
			if(o != null)
			{
				return (jbyte)(byte)o;
			}
			return 0;
		}

		internal static jchar CallCharMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, false);
			if(o != null)
			{
				return (jchar)(char)o;
			}
			return 0;
		}

		internal static jshort CallShortMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, false);
			if(o != null)
			{
				return (jshort)(short)o;
			}
			return 0;
		}

		internal static jint CallIntMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, false);
			if(o != null)
			{
				return (jint)(int)o;
			}
			return 0;
		}

		internal static jlong CallLongMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, false);
			if(o != null)
			{
				return (jlong)(long)o;
			}
			return 0;
		}

		internal static jfloat CallFloatMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, false);
			if(o != null)
			{
				return (jfloat)(float)o;
			}
			return 0;
		}

		internal static jdouble CallDoubleMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, false);
			if(o != null)
			{
				return (jdouble)(double)o;
			}
			return 0;
		}

		internal static void CallVoidMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue*  args)
		{
			InvokeHelper(pEnv, obj, methodID, args, false);
		}

		internal static jobject CallNonvirtualObjectMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue*  args)
		{
			return pEnv->MakeLocalRef(InvokeHelper(pEnv, obj, methodID, args, true));
		}

		internal static jboolean CallNonvirtualBooleanMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue*  args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, true);
			if(o != null)
			{
				return ((bool)o) ? JNI_TRUE : JNI_FALSE;
			}
			return JNI_FALSE;
		}

		internal static jbyte CallNonvirtualByteMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, true);
			if(o != null)
			{
				return (jbyte)(byte)o;
			}
			return 0;
		}

		internal static jchar CallNonvirtualCharMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, true);
			if(o != null)
			{
				return (jchar)(char)o;
			}
			return 0;
		}

		internal static jshort CallNonvirtualShortMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, true);
			if(o != null)
			{
				return (jshort)(short)o;
			}
			return 0;
		}

		internal static jint CallNonvirtualIntMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, true);
			if(o != null)
			{
				return (jint)(int)o;
			}
			return 0;
		}

		internal static jlong CallNonvirtualLongMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, true);
			if(o != null)
			{
				return (jlong)(long)o;
			}
			return 0;
		}

		internal static jfloat CallNonvirtualFloatMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, true);
			if(o != null)
			{
				return (jfloat)(float)o;
			}
			return 0;
		}

		internal static jdouble CallNonvirtualDoubleMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
		{
			object o = InvokeHelper(pEnv, obj, methodID, args, true);
			if(o != null)
			{
				return (jdouble)(double)o;
			}
			return 0;
		}

		internal static void CallNonvirtualVoidMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
		{
			InvokeHelper(pEnv, obj, methodID, args, true);
		}

		private static FieldWrapper GetFieldImpl(TypeWrapper tw, string name, string sig)
		{
			for(;;)
			{
				FieldWrapper fw = tw.GetFieldWrapper(name, sig);
				if(fw == null || !fw.IsHideFromReflection)
				{
					return fw;
				}
				tw = fw.DeclaringType.BaseTypeWrapper;
				if(tw == null)
				{
					return null;
				}
			}
		}

		private static jfieldID FindFieldID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig, bool isstatic)
		{
			try
			{
				TypeWrapper wrapper = TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(clazz));
				wrapper.Finish();
				string fieldsig = StringFromUTF8(sig);
				// don't allow dotted names!
				if(fieldsig.IndexOf('.') < 0)
				{
					FieldWrapper fw = GetFieldImpl(wrapper, StringFromUTF8(name), fieldsig.Replace('/', '.'));
					if(fw != null)
					{
						if(fw.IsStatic == isstatic)
						{
							return fw.Cookie;
						}
					}
				}
				SetPendingException(pEnv, new java.lang.NoSuchFieldError((isstatic ? "Static" : "Instance") + " field '" + StringFromUTF8(name) + "' with signature '" + fieldsig + "' not found in class '" + wrapper.Name + "'"));
			}
			catch(RetargetableJavaException x)
			{
				SetPendingException(pEnv, x.ToJava());
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
			}
			return IntPtr.Zero;
		}

		internal static jfieldID GetFieldID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig)
		{
			return FindFieldID(pEnv, clazz, name, sig, false);
		}

		private static sun.reflect.FieldAccessor GetFieldAccessor(jfieldID cookie)
		{
			return (sun.reflect.FieldAccessor)FieldWrapper.FromCookie(cookie).GetFieldAccessorJNI();
		}

		internal static jobject GetObjectField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
		{
			return pEnv->MakeLocalRef(GetFieldAccessor(fieldID).get(pEnv->UnwrapRef(obj)));
		}

		internal static jboolean GetBooleanField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
		{
			return GetFieldAccessor(fieldID).getBoolean(pEnv->UnwrapRef(obj)) ? JNI_TRUE : JNI_FALSE;
		}

		internal static jbyte GetByteField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
		{
			return (jbyte)GetFieldAccessor(fieldID).getByte(pEnv->UnwrapRef(obj));
		}

		internal static jchar GetCharField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
		{
			return (jchar)GetFieldAccessor(fieldID).getChar(pEnv->UnwrapRef(obj));
		}

		internal static jshort GetShortField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
		{
			return (jshort)GetFieldAccessor(fieldID).getShort(pEnv->UnwrapRef(obj));
		}

		internal static jint GetIntField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
		{
			return (jint)GetFieldAccessor(fieldID).getInt(pEnv->UnwrapRef(obj));
		}

		internal static jlong GetLongField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
		{
			return (jlong)GetFieldAccessor(fieldID).getLong(pEnv->UnwrapRef(obj));
		}

		internal static jfloat GetFloatField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
		{
			return (jfloat)GetFieldAccessor(fieldID).getFloat(pEnv->UnwrapRef(obj));
		}

		internal static jdouble GetDoubleField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
		{
			return (jdouble)GetFieldAccessor(fieldID).getDouble(pEnv->UnwrapRef(obj));
		}

		internal static void SetObjectField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jobject val)
		{
			GetFieldAccessor(fieldID).set(pEnv->UnwrapRef(obj), pEnv->UnwrapRef(val));
		}

		internal static void SetBooleanField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jboolean val)
		{
			GetFieldAccessor(fieldID).setBoolean(pEnv->UnwrapRef(obj), val != JNI_FALSE);
		}

		internal static void SetByteField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jbyte val)
		{
			GetFieldAccessor(fieldID).setByte(pEnv->UnwrapRef(obj), (byte)val);
		}

		internal static void SetCharField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jchar val)
		{
			GetFieldAccessor(fieldID).setChar(pEnv->UnwrapRef(obj), (char)val);
		}

		internal static void SetShortField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jshort val)
		{
			GetFieldAccessor(fieldID).setShort(pEnv->UnwrapRef(obj), (short)val);
		}

		internal static void SetIntField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jint val)
		{
			GetFieldAccessor(fieldID).setInt(pEnv->UnwrapRef(obj), (int)val);
		}

		internal static void SetLongField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jlong val)
		{
			GetFieldAccessor(fieldID).setLong(pEnv->UnwrapRef(obj), (long)val);
		}

		internal static void SetFloatField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jfloat val)
		{
			GetFieldAccessor(fieldID).setFloat(pEnv->UnwrapRef(obj), (float)val);
		}

		internal static void SetDoubleField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jdouble val)
		{
			GetFieldAccessor(fieldID).setDouble(pEnv->UnwrapRef(obj), (double)val);
		}

		internal static jmethodID GetStaticMethodID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig)
		{
			return FindMethodID(pEnv, clazz, name, sig, true);
		}

		internal static jobject CallStaticObjectMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			return pEnv->MakeLocalRef(InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false));
		}

		internal static jboolean CallStaticBooleanMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
			if(o != null)
			{
				return ((bool)o) ? JNI_TRUE : JNI_FALSE;
			}
			return JNI_FALSE;
		}

		internal static jbyte CallStaticByteMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
			if(o != null)
			{
				return (jbyte)(byte)o;
			}
			return 0;
		}

		internal static jchar CallStaticCharMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
			if(o != null)
			{
				return (jchar)(char)o;
			}
			return 0;
		}

		internal static jshort CallStaticShortMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
			if(o != null)
			{
				return (jshort)(short)o;
			}
			return 0;
		}

		internal static jint CallStaticIntMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
			if(o != null)
			{
				return (jint)(int)o;
			}
			return 0;
		}

		internal static jlong CallStaticLongMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
			if(o != null)
			{
				return (jlong)(long)o;
			}
			return 0;
		}

		internal static jfloat CallStaticFloatMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
			if(o != null)
			{
				return (jfloat)(float)o;
			}
			return 0;
		}

		internal static jdouble CallStaticDoubleMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
		{
			object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
			if(o != null)
			{
				return (jdouble)(double)o;
			}
			return 0;
		}

		internal static void CallStaticVoidMethodA(JNIEnv* pEnv, jclass cls, jmethodID methodID, jvalue * args)
		{
			InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
		}

		internal static jfieldID GetStaticFieldID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig)
		{
			return FindFieldID(pEnv, clazz, name, sig, true);
		}

		internal static jobject GetStaticObjectField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
		{
			return pEnv->MakeLocalRef(GetFieldAccessor(fieldID).get(null));
		}

		internal static jboolean GetStaticBooleanField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
		{
			return GetFieldAccessor(fieldID).getBoolean(null) ? JNI_TRUE : JNI_FALSE;
		}

		internal static jbyte GetStaticByteField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
		{
			return (jbyte)GetFieldAccessor(fieldID).getByte(null);
		}

		internal static jchar GetStaticCharField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
		{
			return (jchar)GetFieldAccessor(fieldID).getChar(null);
		}

		internal static jshort GetStaticShortField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
		{
			return (jshort)GetFieldAccessor(fieldID).getShort(null);
		}

		internal static jint GetStaticIntField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
		{
			return (jint)GetFieldAccessor(fieldID).getInt(null);
		}

		internal static jlong GetStaticLongField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
		{
			return (jlong)GetFieldAccessor(fieldID).getLong(null);
		}

		internal static jfloat GetStaticFloatField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
		{
			return (jfloat)GetFieldAccessor(fieldID).getFloat(null);
		}

		internal static jdouble GetStaticDoubleField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
		{
			return (jdouble)GetFieldAccessor(fieldID).getDouble(null);
		}

		internal static void SetStaticObjectField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jobject val)
		{
			GetFieldAccessor(fieldID).set(null, pEnv->UnwrapRef(val));
		}

		internal static void SetStaticBooleanField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jboolean val)
		{
			GetFieldAccessor(fieldID).setBoolean(null, val != JNI_FALSE);
		}

		internal static void SetStaticByteField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jbyte val)
		{
			GetFieldAccessor(fieldID).setByte(null, (byte)val);
		}

		internal static void SetStaticCharField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jchar val)
		{
			GetFieldAccessor(fieldID).setChar(null, (char)val);
		}

		internal static void SetStaticShortField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jshort val)
		{
			GetFieldAccessor(fieldID).setShort(null, (short)val);
		}

		internal static void SetStaticIntField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jint val)
		{
			GetFieldAccessor(fieldID).setInt(null, (int)val);
		}

		internal static void SetStaticLongField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jlong val)
		{
			GetFieldAccessor(fieldID).setLong(null, (long)val);
		}

		internal static void SetStaticFloatField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jfloat val)
		{
			GetFieldAccessor(fieldID).setFloat(null, (float)val);
		}

		internal static void SetStaticDoubleField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jdouble val)
		{
			GetFieldAccessor(fieldID).setDouble(null, (double)val);
		}

		internal static jstring NewString(JNIEnv* pEnv, jchar* unicode, int len)
		{
			return pEnv->MakeLocalRef(new String((char*)unicode, 0, len));
		}

		internal static jint GetStringLength(JNIEnv* pEnv, jstring str)
		{
			return ((string)pEnv->UnwrapRef(str)).Length;
		}

		internal static jchar* GetStringChars(JNIEnv* pEnv, jstring str, jboolean* isCopy)
		{
			string s = (string)pEnv->UnwrapRef(str);
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return (jchar*)(void*)Marshal.StringToHGlobalUni(s);
		}

		internal static void ReleaseStringChars(JNIEnv* pEnv, jstring str, jchar* chars)
		{
			Marshal.FreeHGlobal((IntPtr)(void*)chars);
		}

		internal static jobject NewStringUTF(JNIEnv* pEnv, byte* psz)
		{
			if (psz == null)
			{
				// The JNI spec does not explicitly allow a null pointer, but the JDK accepts it
				return IntPtr.Zero;
			}
			return pEnv->MakeLocalRef(StringFromUTF8(psz));
		}

		internal static jint GetStringUTFLength(JNIEnv* pEnv, jstring str)
		{
			return StringUTF8Length((string)pEnv->UnwrapRef(str));
		}

		internal static byte* GetStringUTFChars(JNIEnv* pEnv, jstring str, jboolean* isCopy)
		{
			string s = (string)pEnv->UnwrapRef(str);
			byte* buf = (byte*)JniMem.Alloc(StringUTF8Length(s) + 1);
			int j = 0;
			for(int i = 0; i < s.Length; i++)
			{
				char ch = s[i];
				if((ch != 0) && (ch <= 0x7F))
				{
					buf[j++] = (byte)ch;
				}
				else if(ch <= 0x7FF)
				{
					buf[j++] = (byte)((ch >> 6) | 0xC0);
					buf[j++] = (byte)((ch & 0x3F) | 0x80);
				}
				else
				{
					buf[j++] = (byte)((ch >> 12) | 0xE0);
					buf[j++] = (byte)(((ch >> 6) & 0x3F) | 0x80);
					buf[j++] = (byte)((ch & 0x3F) | 0x80);
				}
			}
			buf[j] = 0;
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return buf;
		}

		internal static void ReleaseStringUTFChars(JNIEnv* pEnv, jstring str, byte* chars)
		{
			JniMem.Free((IntPtr)(void*)chars);
		}

		internal static jsize GetArrayLength(JNIEnv* pEnv, jarray array)
		{
			return ((Array)pEnv->UnwrapRef(array)).Length;
		}

		internal static jobject NewObjectArray(JNIEnv* pEnv, jsize len, jclass clazz, jobject init)
		{
			try
			{
				// we want to support (non-primitive) value types so we can't cast to object[]
				Array array = Array.CreateInstance(TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(clazz)).TypeAsArrayType, len);
				object o = pEnv->UnwrapRef(init);
				if(o != null)
				{
					for(int i = 0; i < array.Length; i++)
					{
						array.SetValue(o, i);
					}
				}
				return pEnv->MakeLocalRef(array);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.NegativeArraySizeException());
				return IntPtr.Zero;
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jobject GetObjectArrayElement(JNIEnv* pEnv, jarray array, jsize index)
		{
			try
			{
				// we want to support (non-primitive) value types so we can't cast to object[]
				return pEnv->MakeLocalRef(((Array)pEnv->UnwrapRef(array)).GetValue(index));
			}
			catch(IndexOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
				return IntPtr.Zero;
			}
		}

		internal static void SetObjectArrayElement(JNIEnv* pEnv, jarray array, jsize index, jobject val)
		{
			try
			{
				// we want to support (non-primitive) value types so we can't cast to object[]
				((Array)pEnv->UnwrapRef(array)).SetValue(pEnv->UnwrapRef(val), index);
			}
			catch(IndexOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static jbooleanArray NewBooleanArray(JNIEnv* pEnv, jsize len)
		{
			try
			{
				return pEnv->MakeLocalRef(new bool[len]);
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jbyteArray NewByteArray(JNIEnv* pEnv, jsize len)
		{
			try
			{
				return pEnv->MakeLocalRef(new byte[len]);
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jcharArray NewCharArray(JNIEnv* pEnv, jsize len)
		{
			try
			{
				return pEnv->MakeLocalRef(new char[len]);
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jshortArray NewShortArray(JNIEnv* pEnv, jsize len)
		{
			try
			{
				return pEnv->MakeLocalRef(new short[len]);
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jintArray NewIntArray(JNIEnv* pEnv, jsize len)
		{
			try
			{
				return pEnv->MakeLocalRef(new int[len]);
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jlongArray NewLongArray(JNIEnv* pEnv, jsize len)
		{
			try
			{
				return pEnv->MakeLocalRef(new long[len]);
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jfloatArray NewFloatArray(JNIEnv* pEnv, jsize len)
		{
			try
			{
				return pEnv->MakeLocalRef(new float[len]);
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jdoubleArray NewDoubleArray(JNIEnv* pEnv, jsize len)
		{
			try
			{
				return pEnv->MakeLocalRef(new double[len]);
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return IntPtr.Zero;
			}
		}

		internal static jboolean* GetBooleanArrayElements(JNIEnv* pEnv, jbooleanArray array, jboolean* isCopy)
		{
			bool[] b = (bool[])pEnv->UnwrapRef(array);
			jboolean* p = (jboolean*)(void*)JniMem.Alloc(b.Length * 1);
			for(int i = 0; i < b.Length; i++)
			{
				p[i] = b[i] ? JNI_TRUE : JNI_FALSE;
			}
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return p;
		}

		internal static jbyte* GetByteArrayElements(JNIEnv* pEnv, jbyteArray array, jboolean* isCopy)
		{
			byte[] b = (byte[])pEnv->UnwrapRef(array);
			jbyte* p = (jbyte*)(void*)JniMem.Alloc(b.Length * 1);
			for(int i = 0; i < b.Length; i++)
			{
				p[i] = (jbyte)b[i];
			}
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return p;
		}

		internal static jchar* GetCharArrayElements(JNIEnv* pEnv, jcharArray array, jboolean* isCopy)
		{
			char[] b = (char[])pEnv->UnwrapRef(array);
			IntPtr buf = JniMem.Alloc(b.Length * 2);
			Marshal.Copy(b, 0, buf, b.Length);
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return (jchar*)(void*)buf;
		}

		internal static jshort* GetShortArrayElements(JNIEnv* pEnv, jshortArray array, jboolean* isCopy)
		{
			short[] b = (short[])pEnv->UnwrapRef(array);
			IntPtr buf = JniMem.Alloc(b.Length * 2);
			Marshal.Copy(b, 0, buf, b.Length);
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return (jshort*)(void*)buf;
		}

		internal static jint* GetIntArrayElements(JNIEnv* pEnv, jintArray array, jboolean* isCopy)
		{
			int[] b = (int[])pEnv->UnwrapRef(array);
			IntPtr buf = JniMem.Alloc(b.Length * 4);
			Marshal.Copy(b, 0, buf, b.Length);
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return (jint*)(void*)buf;
		}

		internal static jlong* GetLongArrayElements(JNIEnv* pEnv, jlongArray array, jboolean* isCopy)
		{
			long[] b = (long[])pEnv->UnwrapRef(array);
			IntPtr buf = JniMem.Alloc(b.Length * 8);
			Marshal.Copy(b, 0, buf, b.Length);
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return (jlong*)(void*)buf;
		}

		internal static jfloat* GetFloatArrayElements(JNIEnv* pEnv, jfloatArray array, jboolean* isCopy)
		{
			float[] b = (float[])pEnv->UnwrapRef(array);
			IntPtr buf = JniMem.Alloc(b.Length * 4);
			Marshal.Copy(b, 0, buf, b.Length);
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return (jfloat*)(void*)buf;
		}

		internal static jdouble* GetDoubleArrayElements(JNIEnv* pEnv, jdoubleArray array, jboolean* isCopy)
		{
			double[] b = (double[])pEnv->UnwrapRef(array);
			IntPtr buf = JniMem.Alloc(b.Length * 8);
			Marshal.Copy(b, 0, buf, b.Length);
			if(isCopy != null)
			{
				*isCopy = JNI_TRUE;
			}
			return (jdouble*)(void*)buf;
		}

		internal static void ReleaseBooleanArrayElements(JNIEnv* pEnv, jbooleanArray array, jboolean* elems, jint mode)
		{
			if(mode == 0 || mode == JNI_COMMIT)
			{
				bool[] b = (bool[])pEnv->UnwrapRef(array);
				for(int i = 0; i < b.Length; i++)
				{
					b[i] = elems[i] != JNI_FALSE;
				}
			}
			if(mode == 0 || mode == JNI_ABORT)
			{
				JniMem.Free((IntPtr)(void*)elems);
			}
		}

		internal static void ReleaseByteArrayElements(JNIEnv* pEnv, jbyteArray array, jbyte* elems, jint mode)
		{
			if(mode == 0 || mode == JNI_COMMIT)
			{
				byte[] b = (byte[])pEnv->UnwrapRef(array);
				for(int i = 0; i < b.Length; i++)
				{
					b[i] = (byte)elems[i];
				}
			}
			if(mode == 0 || mode == JNI_ABORT)
			{
				JniMem.Free((IntPtr)(void*)elems);
			}
		}

		internal static void ReleaseCharArrayElements(JNIEnv* pEnv, jcharArray array, jchar* elems, jint mode)
		{
			if(mode == 0 || mode == JNI_COMMIT)
			{
				char[] b = (char[])pEnv->UnwrapRef(array);
				Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
			}
			if(mode == 0 || mode == JNI_ABORT)
			{
				JniMem.Free((IntPtr)(void*)elems);
			}
		}

		internal static void ReleaseShortArrayElements(JNIEnv* pEnv, jshortArray array, jshort* elems, jint mode)
		{
			if(mode == 0 || mode == JNI_COMMIT)
			{
				short[] b = (short[])pEnv->UnwrapRef(array);
				Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
			}
			if(mode == 0 || mode == JNI_ABORT)
			{
				JniMem.Free((IntPtr)(void*)elems);
			}
		}

		internal static void ReleaseIntArrayElements(JNIEnv* pEnv, jintArray array, jint* elems, jint mode)
		{
			if(mode == 0 || mode == JNI_COMMIT)
			{
				int[] b = (int[])pEnv->UnwrapRef(array);
				Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
			}
			if(mode == 0 || mode == JNI_ABORT)
			{
				JniMem.Free((IntPtr)(void*)elems);
			}
		}

		internal static void ReleaseLongArrayElements(JNIEnv* pEnv, jlongArray array, jlong* elems, jint mode)
		{
			if(mode == 0 || mode == JNI_COMMIT)
			{
				long[] b = (long[])pEnv->UnwrapRef(array);
				Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
			}
			if(mode == 0 || mode == JNI_ABORT)
			{
				JniMem.Free((IntPtr)(void*)elems);
			}
		}

		internal static void ReleaseFloatArrayElements(JNIEnv* pEnv, jfloatArray array, jfloat* elems, jint mode)
		{
			if(mode == 0 || mode == JNI_COMMIT)
			{
				float[] b = (float[])pEnv->UnwrapRef(array);
				Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
			}
			if(mode == 0 || mode == JNI_ABORT)
			{
				JniMem.Free((IntPtr)(void*)elems);
			}
		}

		internal static void ReleaseDoubleArrayElements(JNIEnv* pEnv, jdoubleArray array, jdouble* elems, jint mode)
		{
			if(mode == 0 || mode == JNI_COMMIT)
			{
				double[] b = (double[])pEnv->UnwrapRef(array);
				Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
			}
			if(mode == 0 || mode == JNI_ABORT)
			{
				JniMem.Free((IntPtr)(void*)elems);
			}
		}

		internal static void GetBooleanArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				bool[] b = (bool[])pEnv->UnwrapRef(array);
				sbyte* p = (sbyte*)(void*)buf;
				for(int i = 0; i < len; i++)
				{
					*p++ = b[start + i] ? JNI_TRUE : JNI_FALSE;
				}
			}
			catch(IndexOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void GetByteArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				byte[] b = (byte[])pEnv->UnwrapRef(array);
				byte* p = (byte*)(void*)buf;
				for(int i = 0; i < len; i++)
				{
					*p++ = b[start + i];
				}
			}
			catch(IndexOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void GetCharArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				char[] b = (char[])pEnv->UnwrapRef(array);
				Marshal.Copy(b, start, buf, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void GetShortArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				short[] b = (short[])pEnv->UnwrapRef(array);
				Marshal.Copy(b, start, buf, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void GetIntArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				int[] b = (int[])pEnv->UnwrapRef(array);
				Marshal.Copy(b, start, buf, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void GetLongArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				long[] b = (long[])pEnv->UnwrapRef(array);
				Marshal.Copy(b, start, buf, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void GetFloatArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				float[] b = (float[])pEnv->UnwrapRef(array);
				Marshal.Copy(b, start, buf, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void GetDoubleArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				double[] b = (double[])pEnv->UnwrapRef(array);
				Marshal.Copy(b, start, buf, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void SetBooleanArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				bool[] b = (bool[])pEnv->UnwrapRef(array);
				sbyte* p = (sbyte*)(void*)buf;
				for(int i = 0; i < len; i++)
				{
					b[start + i] = *p++ != JNI_FALSE;
				}
			}
			catch(IndexOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void SetByteArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				byte[] b = (byte[])pEnv->UnwrapRef(array);
				byte* p = (byte*)(void*)buf;
				for(int i = 0; i < len; i++)
				{
					b[start + i] = *p++;
				}
			}
			catch(IndexOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void SetCharArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				char[] b = (char[])pEnv->UnwrapRef(array);
				Marshal.Copy(buf, b, start, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void SetShortArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				short[] b = (short[])pEnv->UnwrapRef(array);
				Marshal.Copy(buf, b, start, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void SetIntArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				int[] b = (int[])pEnv->UnwrapRef(array);
				Marshal.Copy(buf, b, start, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void SetLongArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				long[] b = (long[])pEnv->UnwrapRef(array);
				Marshal.Copy(buf, b, start, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void SetFloatArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				float[] b = (float[])pEnv->UnwrapRef(array);
				Marshal.Copy(buf, b, start, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		internal static void SetDoubleArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
		{
			try
			{
				double[] b = (double[])pEnv->UnwrapRef(array);
				Marshal.Copy(buf, b, start, len);
			}
			catch(ArgumentOutOfRangeException)
			{
				SetPendingException(pEnv, new java.lang.ArrayIndexOutOfBoundsException());
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		unsafe internal struct JNINativeMethod
		{
			public byte* name;
			public byte* signature;
			public void* fnPtr;
		}

		internal static int RegisterNatives(JNIEnv* pEnv, IntPtr clazz, JNINativeMethod* methods, int nMethods)
		{
			try
			{
				TypeWrapper wrapper = TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(clazz));
				wrapper.Finish();
				for(int i = 0; i < nMethods; i++)
				{
					string methodName = StringFromUTF8(methods[i].name);
					string methodSig = StringFromUTF8(methods[i].signature);
					Tracer.Info(Tracer.Jni, "Registering native method: {0}.{1}{2}, fnPtr = 0x{3:X}", wrapper.Name, methodName, methodSig, ((IntPtr)methods[i].fnPtr).ToInt64());
					FieldInfo fi = null;
					// don't allow dotted names!
					if(methodSig.IndexOf('.') < 0)
					{
						// TODO this won't work when we're putting the JNI methods in jniproxy.dll
						fi = wrapper.TypeAsTBD.GetField(JNI.METHOD_PTR_FIELD_PREFIX + methodName + methodSig, BindingFlags.Static | BindingFlags.NonPublic);
					}
					if(fi == null)
					{
						Tracer.Error(Tracer.Jni, "Failed to register native method: {0}.{1}{2}", wrapper.Name, methodName, methodSig);
						SetPendingException(pEnv, new java.lang.NoSuchMethodError(methodName));
						return JNI_ERR;
					}
					fi.SetValue(null, (IntPtr)methods[i].fnPtr);
				}
				return JNI_OK;
			}
			catch(RetargetableJavaException x)
			{
				SetPendingException(pEnv, x.ToJava());
				return JNI_ERR;
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return JNI_ERR;
			}
		}

		internal static int UnregisterNatives(JNIEnv* pEnv, IntPtr clazz)
		{
			try
			{
				TypeWrapper wrapper = TypeWrapper.FromClass((java.lang.Class)pEnv->UnwrapRef(clazz));
				wrapper.Finish();
				// TODO this won't work when we're putting the JNI methods in jniproxy.dll
				foreach(FieldInfo fi in wrapper.TypeAsTBD.GetFields(BindingFlags.Static | BindingFlags.NonPublic))
				{
					string name = fi.Name;
					if(name.StartsWith(JNI.METHOD_PTR_FIELD_PREFIX))
					{
						Tracer.Info(Tracer.Jni, "Unregistering native method: {0}.{1}", wrapper.Name, name.Substring(JNI.METHOD_PTR_FIELD_PREFIX.Length));
						fi.SetValue(null, IntPtr.Zero);
					}
				}
				return JNI_OK;
			}
			catch(RetargetableJavaException x)
			{
				SetPendingException(pEnv, x.ToJava());
				return JNI_ERR;
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return JNI_ERR;
			}
		}

		internal static int MonitorEnter(JNIEnv* pEnv, IntPtr obj)
		{
			try
			{
				// on .NET 4.0 Monitor.Enter has been marked obsolete,
				// but in this case the alternative adds no value
#pragma warning disable 618
				System.Threading.Monitor.Enter(pEnv->UnwrapRef(obj));
#pragma warning restore 618
				return JNI_OK;
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return JNI_ERR;
			}
		}

		internal static int MonitorExit(JNIEnv* pEnv, IntPtr obj)
		{
			try
			{
				System.Threading.Monitor.Exit(pEnv->UnwrapRef(obj));
				return JNI_OK;
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, x);
				return JNI_ERR;
			}
		}

		internal static int GetJavaVM(JNIEnv* pEnv, JavaVM **ppJavaVM)
		{
			*ppJavaVM = JavaVM.pJavaVM;
			return JNI_OK;
		}

		internal static void GetStringRegion(JNIEnv* pEnv, IntPtr str, int start, int len, IntPtr buf)
		{
			string s = (string)pEnv->UnwrapRef(str);
			if(s != null)
			{
				if(start < 0 || start > s.Length || s.Length - start < len)
				{
					SetPendingException(pEnv, new java.lang.StringIndexOutOfBoundsException());
					return;
				}
				else
				{
					char* p = (char*)(void*)buf;
					// TODO isn't there a managed memcpy?
					for(int i = 0; i < len; i++)
					{
						*p++ = s[start + i];
					}
					return;
				}
			}
			else
			{
				SetPendingException(pEnv, new java.lang.NullPointerException());
			}
		}

		internal static void GetStringUTFRegion(JNIEnv* pEnv, IntPtr str, int start, int len, IntPtr buf)
		{
			string s = (string)pEnv->UnwrapRef(str);
			if(s != null)
			{
				if(start < 0 || start > s.Length || s.Length - start < len)
				{
					SetPendingException(pEnv, new java.lang.StringIndexOutOfBoundsException());
					return;
				}
				else
				{
					byte* p = (byte*)(void*)buf;
					for(int i = 0; i < len; i++)
					{
						char ch = s[start + i];
						if((ch != 0) && (ch <= 0x7F))
						{
							*p++ = (byte)ch;
						}
						else if(ch <= 0x7FF)
						{
							*p++ = (byte)((ch >> 6) | 0xC0);
							*p++ = (byte)((ch & 0x3F) | 0x80);
						}
						else
						{
							*p++ = (byte)((ch >> 12) | 0xE0);
							*p++ = (byte)(((ch >> 6) & 0x3F) | 0x80);
							*p++ = (byte)((ch & 0x3F) | 0x80);
						}
					}
					return;
				}
			}
			else
			{
				SetPendingException(pEnv, new java.lang.NullPointerException());
			}
		}

		private void* PinObject(object obj)
		{
			if(pinHandleInUseCount == pinHandleMaxCount)
			{
				int newCount = pinHandleMaxCount + 32;
				GCHandle* pNew = (GCHandle*)JniMem.Alloc(sizeof(GCHandle) * newCount);
				for(int i = 0; i < pinHandleMaxCount; i++)
				{
					pNew[i] = pinHandles[i];
				}
				for(int i = pinHandleMaxCount; i < newCount; i++)
				{
					pNew[i] = new GCHandle();
				}
				JniMem.Free((IntPtr)pinHandles);
				pinHandles = pNew;
				pinHandleMaxCount = newCount;
			}
			int index = pinHandleInUseCount++;
			if(!pinHandles[index].IsAllocated)
			{
				pinHandles[index] = GCHandle.Alloc(null, GCHandleType.Pinned);
			}
			pinHandles[index].Target = obj;
			return (void*)pinHandles[index].AddrOfPinnedObject();
		}

		private void UnpinObject(object obj)
		{
			for(int i = 0; i < pinHandleInUseCount; i++)
			{
				if(pinHandles[i].Target == obj)
				{
					pinHandles[i].Target = pinHandles[--pinHandleInUseCount].Target;
					pinHandles[pinHandleInUseCount].Target = null;
					return;
				}
			}
		}

		internal static void* GetPrimitiveArrayCritical(JNIEnv* pEnv, jarray array, jboolean* isCopy)
		{
			if(isCopy != null)
			{
				*isCopy = JNI_FALSE;
			}
			return pEnv->PinObject(pEnv->UnwrapRef(array));
		}

		internal static void ReleasePrimitiveArrayCritical(JNIEnv* pEnv, jarray array, void* carray, jint mode)
		{
			pEnv->UnpinObject(pEnv->UnwrapRef(array));
		}

		internal static jchar* GetStringCritical(JNIEnv* pEnv, jstring str, jboolean* isCopy)
		{
			if(isCopy != null)
			{
				*isCopy = JNI_FALSE;
			}
			return (jchar*)pEnv->PinObject(pEnv->UnwrapRef(str));
		}

		internal static void ReleaseStringCritical(JNIEnv* pEnv, jstring str, jchar* cstring)
		{
			pEnv->UnpinObject(pEnv->UnwrapRef(str));
		}

		internal static jweak NewWeakGlobalRef(JNIEnv* pEnv, jobject obj)
		{
			object o = pEnv->UnwrapRef(obj);
			if(o == null)
			{
				return IntPtr.Zero;
			}
			lock(GlobalRefs.weakRefLock)
			{
				for(int i = 0; i < GlobalRefs.weakRefs.Length; i++)
				{
					if(!GlobalRefs.weakRefs[i].IsAllocated)
					{
						GlobalRefs.weakRefs[i] = GCHandle.Alloc(o, GCHandleType.WeakTrackResurrection);
						return (IntPtr)(- (i | (1 << 30)));
					}
				}
				int len = GlobalRefs.weakRefs.Length;
				GCHandle[] tmp = new GCHandle[len * 2];
				Array.Copy(GlobalRefs.weakRefs, 0, tmp, 0, len);
				tmp[len] = GCHandle.Alloc(o, GCHandleType.WeakTrackResurrection);
				GlobalRefs.weakRefs = tmp;
				return (IntPtr)(- (len | (1 << 30)));
			}
		}

		internal static void DeleteWeakGlobalRef(JNIEnv* pEnv, jweak obj)
		{
			int i = obj.ToInt32();
			if(i < 0)
			{
				i = -i;
				i -= (1 << 30);
				lock(GlobalRefs.weakRefLock)
				{
					GlobalRefs.weakRefs[i].Free();
				}
			}
			if(i > 0)
			{
				Debug.Assert(false, "local ref passed to DeleteWeakGlobalRef");
			}
		}

		internal static jboolean ExceptionCheck(JNIEnv* pEnv)
		{
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			return env.pendingException != null ? JNI_TRUE : JNI_FALSE;
		}

		internal static jobject NewDirectByteBuffer(JNIEnv* pEnv, IntPtr address, jlong capacity)
		{
			try
			{
				if(capacity < 0 || capacity > int.MaxValue)
				{
					SetPendingException(pEnv, new java.lang.IllegalArgumentException("capacity"));
					return IntPtr.Zero;
				}
				return pEnv->MakeLocalRef(JVM.NewDirectByteBuffer(address.ToInt64(), (int)capacity));
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, ikvm.runtime.Util.mapException(x));
				return IntPtr.Zero;
			}
		}

		internal static IntPtr GetDirectBufferAddress(JNIEnv* pEnv, jobject buf)
		{
			try
			{
				return (IntPtr)((sun.nio.ch.DirectBuffer)pEnv->UnwrapRef(buf)).address();
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, ikvm.runtime.Util.mapException(x));
				return IntPtr.Zero;
			}
		}
		
		internal static jlong GetDirectBufferCapacity(JNIEnv* pEnv, jobject buf)
		{
			try
			{
				return (jlong)(long)((java.nio.Buffer)pEnv->UnwrapRef(buf)).capacity();
			}
			catch(Exception x)
			{
				SetPendingException(pEnv, ikvm.runtime.Util.mapException(x));
				return 0;
			}
		}

		internal static int GetObjectRefType(JNIEnv* pEnv, jobject obj)
		{
			int i = obj.ToInt32();
			if(i >= 0)
			{
				return JNILocalRefType;
			}
			i = -i;
			if((i & (1 << 30)) != 0)
			{
				return JNIWeakGlobalRefType;
			}
			else
			{
				return JNIGlobalRefType;
			}
		}

		internal IntPtr MakeLocalRef(object obj)
		{
			return GetManagedJNIEnv().MakeLocalRef(obj);
		}

		internal object UnwrapRef(IntPtr o)
		{
			int i = o.ToInt32();
			if(i > 0)
			{
				return GetManagedJNIEnv().UnwrapLocalRef(i);
			}
			if(i < 0)
			{
				return GlobalRefs.Unwrap(i);
			}
			return null;
		}

		internal static object UnwrapRef(ManagedJNIEnv env, IntPtr o)
		{
			int i = o.ToInt32();
			if(i > 0)
			{
				return env.UnwrapLocalRef(i);
			}
			if(i < 0)
			{
				return GlobalRefs.Unwrap(i);
			}
			return null;
		}
	}

	static class JniMem
	{
		internal static IntPtr Alloc(int cb)
		{
			return Marshal.AllocHGlobal(cb);
		}

		internal static void Free(IntPtr p)
		{
			Marshal.FreeHGlobal(p);
		}
	}

	static class TlsHack
	{
		[ThreadStatic]
		internal static JNIEnv.ManagedJNIEnv ManagedJNIEnv;
	}
}
@


1.106
log
@Use java.lang.reflect.Executable instead of object as common base class of Method and Constructor.
@
text
@d1695 1
a1695 1
			return MethodWrapper.FromMethodOrConstructor((java.lang.reflect.Executable)pEnv->UnwrapRef(method)).Cookie;
@


1.105
log
@Updated JNI to Java 8.
@
text
@d1695 1
a1695 1
			return MethodWrapper.FromMethodOrConstructor(pEnv->UnwrapRef(method)).Cookie;
@


1.104
log
@JNI fixes:
- Throw(NULL) should not clear pending exception.
- ThrowNew(..., NULL) should use default constructor.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
d86 6
a91 1
			return version == JNIEnv.JNI_VERSION_1_1 || version == JNIEnv.JNI_VERSION_1_2 || version == JNIEnv.JNI_VERSION_1_4 || version == JNIEnv.JNI_VERSION_1_6;
d1237 1
d1620 1
a1620 1
			return JNI_VERSION_1_6;
@


1.103
log
@Bug fix. JNI NewStringUTF should accept null pointer.
@
text
@d1729 4
a1732 1
			env.pendingException = x;
d1740 1
a1740 1
			MethodWrapper mw = wrapper.GetMethodWrapper("<init>", "(Ljava.lang.String;)V", false);
d1749 1
a1749 1
					exception = (Exception)cons.newInstance(new object[] { StringFromOEM(msg) }, env.callerID);
@


1.102
log
@Improved trace message for JNI loadLibrary failure.
@
text
@d2715 5
@


1.101
log
@Delegate.DynamicInvoke() wraps any exceptions in a TargetInvocationException, so we need to unwrap.
@
text
@d353 1
a353 1
			[DllImport(library)]
d401 1
a401 1
			[DllImport(library)]
d449 1
a449 1
			[DllImport(library)]
d556 2
a557 1
					Tracer.Info(Tracer.Jni, "Library not found: {0}", filename);
@


1.100
log
@Moved JNI method invocation completely into JNI assembly and base it on MethodWrapper.Invoke() instead of Java reflection.
@
text
@d2015 8
a2022 1
				return del.DynamicInvoke(argarray);
@


1.99
log
@Moved JNI invocation of InvokeNonvirtualRemapped into JNI assembly.
@
text
@d1928 1
a1928 1
		private static object InvokeHelper(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue *args, bool nonVirtual)
d1931 1
d1933 2
a1934 12
			if (nonVirtual && mw.RequiresNonVirtualDispatcher)
			{
				try
				{
					return InvokeNonVirtual(env, mw, UnwrapRef(env, obj), args);
				}
				catch (Exception x)
				{
					SetPendingException(pEnv, ikvm.runtime.Util.mapException(x));
					return null;
				}
			}
d1936 2
a1937 2
			object[] argarray = new object[argTypes.Length];
			for (int i = 0; i < argarray.Length; i++)
d1941 1
a1941 1
					argarray[i] = java.lang.Boolean.valueOf(args[i].z != JNI_FALSE);
d1943 1
a1943 1
					argarray[i] = java.lang.Byte.valueOf((byte)args[i].b);
d1945 1
a1945 1
					argarray[i] = java.lang.Character.valueOf((char)args[i].c);
d1947 1
a1947 1
					argarray[i] = java.lang.Short.valueOf(args[i].s);
d1949 1
a1949 1
					argarray[i] = java.lang.Integer.valueOf(args[i].i);
d1951 1
a1951 1
					argarray[i] = java.lang.Long.valueOf(args[i].j);
d1953 1
a1953 1
					argarray[i] = java.lang.Float.valueOf(args[i].f);
d1955 1
a1955 1
					argarray[i] = java.lang.Double.valueOf(args[i].d);
d1957 1
a1957 1
					argarray[i] = UnwrapRef(env, args[i].l);
d1959 1
a1959 1
			try
d1961 1
a1961 1
				return mw.InvokeJNI(UnwrapRef(env, obj), argarray, nonVirtual, env.callerID);
d1963 1
a1963 1
			catch(java.lang.reflect.InvocationTargetException x)
d1965 28
a1992 2
				SetPendingException(pEnv, ikvm.runtime.Util.mapException(x.getCause()));
				return null;
d1994 1
a1994 1
			catch(Exception x)
d2001 1
a2001 1
		private static object InvokeNonVirtual(ManagedJNIEnv env, MethodWrapper mw, object obj, jvalue* args)
a2006 26
			mw.Link();
			mw.ResolveMethod();
			TypeWrapper[] argTypes = mw.GetParameters();
			object[] argarray = new object[argTypes.Length];
			for (int i = 0; i < argTypes.Length; i++)
			{
				TypeWrapper type = argTypes[i];
				if (type == PrimitiveTypeWrapper.BOOLEAN)
					argarray[i] = args[i].z != JNI_FALSE;
				else if (type == PrimitiveTypeWrapper.BYTE)
					argarray[i] = (byte)args[i].b;
				else if (type == PrimitiveTypeWrapper.CHAR)
					argarray[i] = (char)args[i].c;
				else if (type == PrimitiveTypeWrapper.SHORT)
					argarray[i] = args[i].s;
				else if (type == PrimitiveTypeWrapper.INT)
					argarray[i] = args[i].i;
				else if (type == PrimitiveTypeWrapper.LONG)
					argarray[i] = args[i].j;
				else if (type == PrimitiveTypeWrapper.FLOAT)
					argarray[i] = args[i].f;
				else if (type == PrimitiveTypeWrapper.DOUBLE)
					argarray[i] = args[i].d;
				else
					argarray[i] = argTypes[i].GhostWrap(UnwrapRef(env, args[i].l));
			}
@


1.98
log
@Added back support for JNI non-virtual method invocation for methods with more than 8 parameters.
@
text
@d1932 1
a1932 3
			if (nonVirtual
				&& mw.RequiresNonVirtualDispatcher
				&& !(mw.DeclaringType.IsRemapped && !mw.DeclaringType.TypeAsBaseType.IsInstanceOfType(UnwrapRef(env, obj))))
d1936 1
a1936 1
					return InvokeNonVirtual(env, mw, obj, args);
d1984 1
a1984 1
		private static object InvokeNonVirtual(ManagedJNIEnv env, MethodWrapper mw, jobject obj, jvalue* args)
d2016 10
a2025 3
			Delegate del = (Delegate)Activator.CreateInstance(mw.GetDelegateType(),
				new object[] { UnwrapRef(env, obj), mw.GetMethod().MethodHandle.GetFunctionPointer() });
			return del.DynamicInvoke(argarray);
@


1.97
log
@Moved JNI non-virtual invoke delegate type creation into runtime where it can reuse MethodHandle code.
@
text
@d1933 1
a1933 6
				&& !mw.IsConstructor
				&& !mw.IsStatic
				&& !mw.IsPrivate
				&& !mw.IsAbstract
				&& !mw.IsFinal
				&& !mw.DeclaringType.IsFinal
@


1.96
log
@Reimplemented JNI non-virtual method invocation based on delegates instead of DynamicMethod.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
a1999 6
			if (argTypes.Length > 8)
			{
				// TODO we should have ikvmc emit the required delegate when it compiles a method with more than 8 parameters
				throw new NotImplementedException("Methods with more than 8 parameters cannot be invoked non-virtually currently.");
			}
			Type[] types = new Type[argTypes.Length + (mw.ReturnType == PrimitiveTypeWrapper.VOID ? 0 : 1)];
a2003 1
				types[i] = type.TypeAsSignatureType;
d2023 2
a2024 13
			Type delegateType;
			if (mw.ReturnType == PrimitiveTypeWrapper.VOID)
			{
				delegateType = types.Length == 0
					? typeof(MHV)
					: typeof(MHV).Module.GetType("IKVM.Runtime.MHV`" + types.Length).MakeGenericType(types);
			}
			else
			{
				types[types.Length - 1] = mw.ReturnType.TypeAsSignatureType;
				delegateType = typeof(MHV).Module.GetType("IKVM.Runtime.MH`" + types.Length).MakeGenericType(types);
			}
			Delegate del = (Delegate)Activator.CreateInstance(delegateType, new object[] { UnwrapRef(env, obj), mw.GetMethod().MethodHandle.GetFunctionPointer() });
@


1.95
log
@More static typing.
@
text
@d1932 19
d1991 55
@


1.94
log
@Moved the remaining code from openjdk.cs to separate files.
@
text
@d1693 1
a1693 1
			return FieldWrapper.FromField(pEnv->UnwrapRef(field)).Cookie;
@


1.93
log
@Moved java.lang and java.lang.reflect native methods into separate files.
@
text
@d1191 1
a1191 1
			IKVM.NativeCode.ikvm.runtime.Startup.jniDetach();
@


1.92
log
@Bug fix. Off-by-one error in local ref index reusing. Fix for bug #3575555.
@
text
@d1130 1
a1130 1
			IKVM.NativeCode.java.lang.Thread.WaitUntilLastJniThread();
d1175 1
a1175 1
					IKVM.NativeCode.java.lang.Thread.AttachThreadFromJni(threadGroup);
d1246 1
a1246 1
			IKVM.NativeCode.java.lang.SecurityManager.jniAssembly = typeof(JNIEnv).Assembly;
d1625 1
a1625 1
				return pEnv->MakeLocalRef(IKVM.NativeCode.java.lang.ClassLoader.defineClass0(classLoader, name != null ? StringFromOEM(name) : null, buf, 0, buf.Length, null));
@


1.91
log
@Use extension methods (explicitly) instead of (now deprecated) instancehelper_ methods.
@
text
@d1398 1
a1398 1
						while (localRefIndex > i && active[localRefIndex - 1] == null)
@


1.91.4.1
log
@Backported fixes for rc 3.
- Bug fix. Off-by-one error in local ref index reusing. Fix for bug #3575555.
- Bug fix. Don't try to inject DynamicMethod in array types (applies to array.clone() method for MethodHandles).
- IKVM.Reflection: Bug fix. ModuleReader.ResolveMember() should support types. Thanks to Jb Evain for finding this.
- IKVM.Reflection: Bug fix. While reading the Cecil source I realized that array bounds are signed.
- IKVM.Reflection: Bug fix. LocalBuilder should extend LocalVariableInfo.
- IKVM.Reflection: Implemented LocalVariableInfo.ToString().
@
text
@d1398 1
a1398 1
						while (localRefIndex - 1 > i && active[localRefIndex - 1] == null)
@


1.90
log
@Implemented a different pinning scheme for GetPrimitiveArrayCritical() that tolerates broken code that passes back the wrong pointer to Release. Should also perform better in most cases. GetStringCritical() now also pins instead of copies. Note that we intentionally ignore the mode parameter in ReleasePrimitiveArrayCritical() as HotSpot does the same.
@
text
@d1783 1
a1783 1
					java.lang.Throwable.instancehelper_printStackTrace(x);
@


1.89
log
@Changed build and JNI code to use different names for the Windows x86 and x64 versions of the native dll.
@
text
@d1239 3
a1241 2
		private GCHandle criticalArrayHandle1;
		private GCHandle criticalArrayHandle2;
d1297 1
a1297 1
					if(pJNIEnv->criticalArrayHandle1.IsAllocated)
d1299 4
a1302 5
						pJNIEnv->criticalArrayHandle1.Free();
					}
					if(pJNIEnv->criticalArrayHandle2.IsAllocated)
					{
						pJNIEnv->criticalArrayHandle2.Free();
d1506 3
a1508 2
			pJNIEnv->criticalArrayHandle1 = GCHandle.Alloc(null, GCHandleType.Pinned);
			pJNIEnv->criticalArrayHandle2 = GCHandle.Alloc(null, GCHandleType.Pinned);
d3489 1
a3489 1
		private static int GetPrimitiveArrayElementSize(Array ar)
d3491 1
a3491 2
			Type type = ar.GetType().GetElementType();
			if(type == PrimitiveTypeWrapper.BYTE.TypeAsArrayType || type == PrimitiveTypeWrapper.BOOLEAN.TypeAsArrayType)
d3493 13
a3505 1
				return 1;
d3507 2
a3508 1
			else if(type == PrimitiveTypeWrapper.SHORT.TypeAsArrayType || type == PrimitiveTypeWrapper.CHAR.TypeAsArrayType)
d3510 1
a3510 14
				return 2;
			}
			else if(type == PrimitiveTypeWrapper.INT.TypeAsArrayType || type == PrimitiveTypeWrapper.FLOAT.TypeAsArrayType)
			{
				return 4;
			}
			else if(type == PrimitiveTypeWrapper.LONG.TypeAsArrayType || type == PrimitiveTypeWrapper.DOUBLE.TypeAsArrayType)
			{
				return 8;
			}
			else
			{
				JVM.CriticalFailure("invalid array type", null);
				return 0;
d3512 2
d3516 1
a3516 1
		internal static void* GetPrimitiveArrayCritical(JNIEnv* pEnv, jarray array, jboolean* isCopy)
d3518 1
a3518 2
			Array ar = (Array)pEnv->UnwrapRef(array);
			if(pEnv->criticalArrayHandle1.Target == null)
d3520 1
a3520 2
				pEnv->criticalArrayHandle1.Target = ar;
				if(isCopy != null)
d3522 3
a3524 1
					*isCopy = JNI_FALSE;
a3525 1
				return (void*)pEnv->criticalArrayHandle1.AddrOfPinnedObject();
d3527 5
a3531 13
			if(pEnv->criticalArrayHandle2.Target == null)
			{
				pEnv->criticalArrayHandle2.Target = ar;
				if(isCopy != null)
				{
					*isCopy = JNI_FALSE;
				}
				return (void*)pEnv->criticalArrayHandle2.AddrOfPinnedObject();
			}
			// TODO not 64-bit safe (len can overflow)
			int len = ar.Length * GetPrimitiveArrayElementSize(ar);
			GCHandle h = GCHandle.Alloc(ar, GCHandleType.Pinned);
			try
d3533 1
a3533 13
				IntPtr hglobal = JniMem.Alloc(len);
				byte* pdst = (byte*)(void*)hglobal;
				byte* psrc = (byte*)(void*)h.AddrOfPinnedObject();
				// TODO isn't there a managed memcpy?
				for(int i = 0; i < len; i++)
				{
					*pdst++ = *psrc++;
				}
				if(isCopy != null)
				{
					*isCopy = JNI_TRUE;
				}
				return (void*)hglobal;
d3535 1
a3535 4
			finally
			{
				h.Free();
			}		
d3540 1
a3540 43
			Array ar = (Array)pEnv->UnwrapRef(array);
			if(pEnv->criticalArrayHandle1.Target == ar
				&& (void*)pEnv->criticalArrayHandle1.AddrOfPinnedObject() == carray)
			{
				if(mode == 0 || mode == JNI_ABORT)
				{
					pEnv->criticalArrayHandle1.Target = null;
				}
				return;
			}
			if(pEnv->criticalArrayHandle2.Target == ar
				&& (void*)pEnv->criticalArrayHandle2.AddrOfPinnedObject() == carray)
			{
				if(mode == 0 || mode == JNI_ABORT)
				{
					pEnv->criticalArrayHandle2.Target = null;
				}
				return;
			}
			if(mode == 0 || mode == JNI_COMMIT)
			{
				// TODO not 64-bit safe (len can overflow)
				int len = ar.Length * GetPrimitiveArrayElementSize(ar);
				GCHandle h = GCHandle.Alloc(ar, GCHandleType.Pinned);
				try
				{
					byte* pdst = (byte*)(void*)h.AddrOfPinnedObject();
					byte* psrc = (byte*)(void*)carray;
					// TODO isn't there a managed memcpy?
					for(int i = 0; i < len; i++)
					{
						*pdst++ = *psrc++;
					}
				}
				finally
				{
					h.Free();
				}
			}
			if(mode == 0 || mode == JNI_ABORT)
			{
				JniMem.Free((IntPtr)carray);
			}
d3545 1
a3545 2
			string s = (string)pEnv->UnwrapRef(str);
			if(s != null)
d3547 1
a3547 5
				if(isCopy != null)
				{
					*isCopy = JNI_TRUE;
				}
				return (jchar*)(void*)Marshal.StringToHGlobalUni(s);		
d3549 1
a3549 2
			SetPendingException(pEnv, new java.lang.NullPointerException());
			return null;
d3554 1
a3554 1
			Marshal.FreeHGlobal((IntPtr)(void*)cstring);
@


1.88
log
@Removed VMThread class which only existed as a container for the jniDetach method.
@
text
@d246 1
a246 1
						IntPtr pfunc = JniHelper.ikvm_GetProcAddress(p, shortMethodName, sp + 2 * IntPtr.Size);
d252 1
a252 1
						pfunc = JniHelper.ikvm_GetProcAddress(p, longMethodName, sp + 2 * IntPtr.Size);
d311 220
a532 13
		[DllImport("ikvm-native")]
		private static extern IntPtr ikvm_LoadLibrary(string filename);
		[DllImport("ikvm-native")]
		private static extern void ikvm_FreeLibrary(IntPtr handle);
		[DllImport("ikvm-native")]
		internal static extern IntPtr ikvm_GetProcAddress(IntPtr handle, string name, int argc);
		[DllImport("ikvm-native")]
		private unsafe static extern int ikvm_CallOnLoad(IntPtr method, void* jvm, void* reserved);
		[DllImport("ikvm-native")]
		internal unsafe static extern void** ikvm_GetJNIEnvVTable();
		[DllImport("ikvm-native")]
		internal unsafe static extern void* ikvm_MarshalDelegate(Delegate d);

d553 1
a553 1
				IntPtr p = ikvm_LoadLibrary(filename);
d567 1
a567 1
							ikvm_FreeLibrary(p);
d579 1
a579 1
					IntPtr onload = ikvm_GetProcAddress(p, "JNI_OnLoad", IntPtr.Size * 2);
d589 1
a589 1
							version = ikvm_CallOnLoad(onload, JavaVM.pJavaVM, null);
d609 1
a609 1
					ikvm_FreeLibrary(p);
d621 1
a621 1
				IntPtr onunload = ikvm_GetProcAddress(p, "JNI_OnUnload", IntPtr.Size * 2);
d630 1
a630 1
						ikvm_CallOnLoad(onunload, JavaVM.pJavaVM, null);
d639 1
a639 1
				ikvm_FreeLibrary((IntPtr)handle);
d759 1
a759 1
			void** pmcpp = JniHelper.ikvm_GetJNIEnvVTable();
d766 1
a766 1
					p[i] = JniHelper.ikvm_MarshalDelegate(vtableDelegates[i]);
d1119 1
a1119 1
				pJavaVM->vtable[i] = JniHelper.ikvm_MarshalDelegate(vtableDelegates[i]);
@


1.88.2.1
log
@Updated version to 0.46.0.5 and backported bug fixes:
- IKVM.Reflection should ignore unknown metadata streams.
- Off-by-one error in local ref index reusing. Fix for bug #3575555.
- Interface mappings can be "incomplete". Fix for bug #3581564.
- The local variable state at the end of an exception block (if the last instruction is a local variable store) needs to be merged into the exception handler state.
- Local variable analysis for finally blocks was incorrect. Fixes bug #3600788.
- Don't implement interfaces that aren't accessible.
- Updated Mono workaround for Mono 3.0.x.
- Check for supported delegate signatures should detect pointers inside byref and array types and return type should be checked as well.
- Fake nested types should have Static modifier set in innerclasses attribute. Fixes scala compiler interop issue. Thanks to Michael Bayne for reporting this.
- ikvmstub -skiperror should also skip errors during WriteClass.
- An ITEMIDLIST should be freed using CoTaskMemFree.
- String.CaseInsensitiveComparator inner class should be acknowledged by String.
- Fixed the SHFILEINFO declaration. Thanks to Andras Kovacs for reporting this.
- Fixed race condition in MethodWrapper.ResolveMethod().
@
text
@d1191 1
a1191 1
						while (localRefIndex - 1 > i && active[localRefIndex - 1] == null)
@


1.87
log
@JNIEnv.DescribeException() was broken (NPE instead of printing the exception).
@
text
@d984 1
a984 1
			IKVM.NativeCode.java.lang.VMThread.jniDetach();
@


1.86
log
@More object -> java.lang.Class updates.
@
text
@d1572 1
a1572 1
				SetPendingException(pEnv, null);
@


1.85
log
@First stab at making the "native" method signatures more statically typed.
@
text
@d1495 1
a1495 1
			TypeWrapper wrapper = TypeWrapper.FromClass(pEnv->UnwrapRef(sub)).BaseTypeWrapper;
d1501 2
a1502 2
			TypeWrapper w1 = TypeWrapper.FromClass(pEnv->UnwrapRef(sub));
			TypeWrapper w2 = TypeWrapper.FromClass(pEnv->UnwrapRef(super));
d1527 1
a1527 1
			TypeWrapper wrapper = TypeWrapper.FromClass(UnwrapRef(env, clazz));
d1670 1
a1670 1
			return AllocObjectImpl(pEnv, TypeWrapper.FromClass(pEnv->UnwrapRef(clazz)));
d1766 1
a1766 1
			TypeWrapper wrapper = TypeWrapper.FromClass(pEnv->UnwrapRef(clazz));
d1794 2
a1795 2
			object objClass = IKVM.NativeCode.ikvm.runtime.Util.getClassFromObject(pEnv->UnwrapRef(obj));
			TypeWrapper w1 = TypeWrapper.FromClass(pEnv->UnwrapRef(clazz));
d1860 1
a1860 1
				TypeWrapper wrapper = TypeWrapper.FromClass(pEnv->UnwrapRef(clazz));
d2107 1
a2107 1
				TypeWrapper wrapper = TypeWrapper.FromClass(pEnv->UnwrapRef(clazz));
d2507 1
a2507 1
				Array array = Array.CreateInstance(TypeWrapper.FromClass(pEnv->UnwrapRef(clazz)).TypeAsArrayType, len);
d3109 1
a3109 1
				TypeWrapper wrapper = TypeWrapper.FromClass(pEnv->UnwrapRef(clazz));
d3149 1
a3149 1
				TypeWrapper wrapper = TypeWrapper.FromClass(pEnv->UnwrapRef(clazz));
@


1.84
log
@Frame doesn't need to be unsafe anymore.
@
text
@d1416 2
a1417 1
				return pEnv->MakeLocalRef(IKVM.NativeCode.java.lang.ClassLoader.defineClass0(pEnv->UnwrapRef(loader), name != null ? StringFromOEM(name) : null, buf, 0, buf.Length, null));
@


1.83
log
@Added comment and made loop count down simpler.
@
text
@d159 1
a159 1
		public unsafe struct Frame
@


1.82
log
@Added static UnwrapRef method that takes ManagedJNIEnv to avoid having to look it up when we already have it.
@
text
@d1137 1
a1137 1
				// an explicit for loop is faster than Array.Clear()
d1142 1
a1142 2
				localRefSlot--;
				while (localRefSlot != prev.localRefSlot)
a1155 1
					localRefSlot--;
@


1.81
log
@- Moved local ref constants.
- Made local ref fields private.
- Renamed LOCAL_REF_BUCKET_SIZE to LOCAL_REF_MAX_BUCKET_SIZE.
@
text
@d303 1
d306 1
a306 1
				return env.pJNIEnv->UnwrapRef(p);
d437 1
a437 1
	class GlobalRefs
d442 19
d965 1
a965 2
				// NOTE we're calling UnwrapRef on a null pointer, but that's OK because group is a global reference
				object threadGroup = ((JNIEnv*)null)->UnwrapRef(pAttachArgs->group);
d1520 2
a1521 2
			Exception x = pEnv->UnwrapRef(throwable) as Exception;
			env.pendingException = (Exception)x;
d1528 1
a1528 1
			TypeWrapper wrapper = TypeWrapper.FromClass(pEnv->UnwrapRef(clazz));
d1605 2
a1606 1
			return pEnv->GetManagedJNIEnv().PopLocalFrame(pEnv->UnwrapRef(result));
d1747 1
a1747 1
					argarray[i] = pEnv->UnwrapRef(args[i].l);
d1751 1
a1751 1
				return mw.InvokeJNI(pEnv->UnwrapRef(obj), argarray, nonVirtual, env.callerID);
d3547 15
a3561 15
				i = -i;
				if((i & (1 << 30)) != 0)
				{
					lock(GlobalRefs.weakRefLock)
					{
						return GlobalRefs.weakRefs[i - (1 << 30)].Target;
					}
				}
				else
				{
					lock(GlobalRefs.globalRefs)
					{
						return GlobalRefs.globalRefs[i - 1];
					}
				}
@


1.80
log
@Optimized local ref handling.
@
text
@a994 5
		// NOTE LOCAL_REF_BUCKET_SIZE must be at least 512 to allow all method arguments to fit
		// in a single slot, because Frame.MakeLocalRef() doesn't support spilling into a new bucket
		internal const int LOCAL_REF_SHIFT = 10;
		internal const int LOCAL_REF_BUCKET_SIZE = (1 << LOCAL_REF_SHIFT);
		internal const int LOCAL_REF_MASK = (LOCAL_REF_BUCKET_SIZE - 1);
d1029 3
d1033 3
d1039 2
a1040 2
			internal object[][] localRefs;
			internal int localRefSlot;
d1128 1
a1128 1
						if (localRefs[localRefSlot].Length == JNIEnv.LOCAL_REF_BUCKET_SIZE)
d1187 1
a1187 1
				if (active.Length < LOCAL_REF_BUCKET_SIZE)
d1210 1
a1210 1
					active = localRefs[localRefSlot] = new object[LOCAL_REF_BUCKET_SIZE];
d1233 1
a1233 1
					// and it can't be bigger than LOCAL_REF_BUCKET_SIZE
d1235 1
a1235 1
					capacity = Math.Min(capacity, LOCAL_REF_BUCKET_SIZE);
@


1.79
log
@- Moved local ref specific code from Frame.Enter/Leave to ManagedJNIEnv.Enter/Leave.
- Changed JNIEnv.DeleteLocalRef to forward to ManagedJNIEnv.DeleteLocalRef
@
text
@a162 2
			private object[] quickLocals;
			private int quickLocalIndex;
a185 2
				quickLocals = env.localRefs[env.localRefSlot];
				quickLocalIndex = (env.localRefSlot << JNIEnv.LOCAL_REF_SHIFT);
d300 1
a300 27
				if(obj == null)
				{
					return IntPtr.Zero;
				}
				int i = quickLocalIndex & JNIEnv.LOCAL_REF_MASK;
				if(i < quickLocals.Length)
				{
					quickLocals[i] = obj;
					return (IntPtr)quickLocalIndex++;
				}
				else if(i < JNIEnv.LOCAL_REF_BUCKET_SIZE)
				{
					object[] tmp = new object[quickLocals.Length * 2];
					Array.Copy(quickLocals, 0, tmp, 0, quickLocals.Length);
					quickLocals = tmp;
					object[][] localRefs = env.localRefs;
					localRefs[env.localRefSlot] = quickLocals;
					quickLocals[i] = obj;
					return (IntPtr)quickLocalIndex++;
				}
				else
				{
					// this can't happen, because LOCAL_REF_BUCKET_SIZE is larger than the maximum number of object
					// references that can be required by a native method call (256 arguments + a class reference)
					JVM.CriticalFailure("JNI.Frame.MakeLocalRef cannot spill into next slot", null);
					return IntPtr.Zero;
				}
d1040 2
d1048 1
a1048 1
				localRefs[0] = new object[LOCAL_REF_INITIAL_BUCKET_SIZE];
d1051 2
a1052 1
				localRefs[0][0] = "";
d1085 1
d1087 1
a1087 1
				internal FrameState(ikvm.@@internal.CallerID callerID, int localRefSlot)
d1091 1
d1097 1
a1097 1
				FrameState prev = new FrameState(callerID, localRefSlot);
d1104 1
a1104 1
					localRefs = localRefs = tmp;
d1106 3
a1108 1
				if (localRefs[localRefSlot] == null)
d1110 1
a1110 1
					localRefs[localRefSlot] = new object[LOCAL_REF_INITIAL_BUCKET_SIZE];
d1117 6
d1139 2
d1153 16
a1168 1
				object[] active = localRefs[localRefSlot];
d1173 5
a1177 2
						active[i] = obj;
						return (IntPtr)((localRefSlot << LOCAL_REF_SHIFT) + i);
d1180 6
d1188 2
a1189 3
					int i = active.Length;
					object[] tmp = new object[i * 2];
					Array.Copy(active, 0, tmp, 0, i);
d1191 1
a1191 2
					active[i] = obj;
					return (IntPtr)((localRefSlot << LOCAL_REF_SHIFT) + i);
d1199 1
d1206 2
a1207 1
				if (localRefs[localRefSlot] == null)
d1209 1
a1209 1
					localRefs[localRefSlot] = new object[LOCAL_REF_BUCKET_SIZE];
a1210 2
				localRefs[localRefSlot][0] = obj;
				return (IntPtr)(localRefSlot << LOCAL_REF_SHIFT);
d1241 2
d1254 2
@


1.78
log
@Moved local ref code into ManagedJNIEnv.
@
text
@d162 1
a162 1
			private ikvm.@@internal.CallerID prevCallerID;
a164 1
			private int prevLocalRefSlot;
d187 2
a188 16
				prevCallerID = env.callerID;
				env.callerID = callerID;
				object[][] localRefs = env.localRefs;
				prevLocalRefSlot = env.localRefSlot;
				env.localRefSlot++;
				if(env.localRefSlot >= localRefs.Length)
				{
					object[][] tmp = new object[localRefs.Length * 2][];
					Array.Copy(localRefs, 0, tmp, 0, localRefs.Length);
					env.localRefs = localRefs = tmp;
				}
				if(localRefs[env.localRefSlot] == null)
				{
					localRefs[env.localRefSlot] = new object[32];
				}
				quickLocals = localRefs[env.localRefSlot];
d195 1
a195 20
				env.callerID = prevCallerID;
				Exception x = env.pendingException;
				env.pendingException = null;
				object[][] localRefs = env.localRefs;
				while(env.localRefSlot != prevLocalRefSlot)
				{
					if(localRefs[env.localRefSlot] != null)
					{
						if(localRefs[env.localRefSlot].Length == JNIEnv.LOCAL_REF_BUCKET_SIZE)
						{
							// if the bucket is totally allocated, we're assuming a leaky method so we throw the bucket away
							localRefs[env.localRefSlot] = null;
						}
						else
						{
							Array.Clear(localRefs[env.localRefSlot], 0, localRefs[env.localRefSlot].Length);
						}
					}
					env.localRefSlot--;
				}
d1064 1
d1076 1
a1076 1
				localRefs[0] = new object[JNIEnv.LOCAL_REF_BUCKET_SIZE];
d1108 54
d1618 1
a1618 12
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			int i = obj.ToInt32();
			if(i > 0)
			{
				object[][] localRefs = env.localRefs;
				localRefs[i >> LOCAL_REF_SHIFT][i & LOCAL_REF_MASK] = null;
				return;
			}
			if(i < 0)
			{
				Debug.Assert(false, "bogus localref in DeleteLocalRef");
			}
@


1.77
log
@Made ManagedJNIEnv leading, instead of the unmanaged JNIEnv.
@
text
@d1140 100
d1548 1
a1548 24
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			object[][] localRefs = env.localRefs;
			env.localRefSlot += 2;
			if(env.localRefSlot >= localRefs.Length)
			{
				object[][] tmp = new object[localRefs.Length * 2][];
				Array.Copy(localRefs, 0, tmp, 0, localRefs.Length);
				env.localRefs = localRefs = tmp;
			}
			// we use a null slot to mark the fact that we used PushLocalFrame
			localRefs[env.localRefSlot - 1] = null;
			if(localRefs[env.localRefSlot] == null)
			{
				// we can't use capacity directly, because the array length must be a power of two
				// and it can't be bigger than LOCAL_REF_BUCKET_SIZE
				int r = 1;
				capacity = Math.Min(capacity, LOCAL_REF_BUCKET_SIZE);
				while(r < capacity)
				{
					r *= 2;
				}
				localRefs[env.localRefSlot] = new object[r];
			}
			return JNI_OK;
d1553 1
a1553 10
			ManagedJNIEnv env = pEnv->GetManagedJNIEnv();
			object res = pEnv->UnwrapRef(result);
			object[][] localRefs = env.localRefs;
			while(localRefs[env.localRefSlot] != null)
			{
				localRefs[env.localRefSlot] = null;
				env.localRefSlot--;
			}
			env.localRefSlot--;
			return pEnv->MakeLocalRef(res);
d3493 1
a3493 42
			if(obj == null)
			{
				return IntPtr.Zero;
			}
			ManagedJNIEnv env = GetManagedJNIEnv();
			object[][] localRefs = env.localRefs;
			object[] active = localRefs[env.localRefSlot];
			for(int i = 0; i < active.Length; i++)
			{
				if(active[i] == null)
				{
					active[i] = obj;
					return (IntPtr)((env.localRefSlot << LOCAL_REF_SHIFT) + i);
				}
			}
			if(active.Length < LOCAL_REF_BUCKET_SIZE)
			{
				int i = active.Length;
				object[] tmp = new object[i * 2];
				Array.Copy(active, 0, tmp, 0, i);
				active = localRefs[env.localRefSlot] = tmp;
				active[i] = obj;
				return (IntPtr)((env.localRefSlot << LOCAL_REF_SHIFT) + i);
			}
			// if we get here, we're in a native method that most likely is leaking locals refs,
			// so we're going to allocate a new bucket and increment localRefSlot, this means that
			// any slots that become available in the previous bucket are not going to be reused,
			// but since we're assuming that the method is leaking anyway, that isn't a problem
			// (it's never a correctness issue, just a resource consumption issue)
			env.localRefSlot++;
			if(env.localRefSlot == localRefs.Length)
			{
				object[][] tmp = new object[env.localRefSlot * 2][];
				Array.Copy(localRefs, 0, tmp, 0, env.localRefSlot);
				env.localRefs = localRefs = tmp;
			}
			if(localRefs[env.localRefSlot] == null)
			{
				localRefs[env.localRefSlot] = new object[LOCAL_REF_BUCKET_SIZE];
			}
			localRefs[env.localRefSlot][0] = obj;
			return (IntPtr)(env.localRefSlot << LOCAL_REF_SHIFT);
d3501 1
a3501 2
				object[][] localRefs = GetManagedJNIEnv().localRefs;
				return localRefs[i >> LOCAL_REF_SHIFT][i & LOCAL_REF_MASK];
@


1.76
log
@Optimized JNI argument list processing.
@
text
@a160 1
			private JNIEnv* pJNIEnv;
d183 2
a184 2
				pJNIEnv = TlsHack.pJNIEnv;
				if(pJNIEnv == null)
d186 1
a186 1
					pJNIEnv = JNIEnv.CreateJNIEnv();
a187 1
				env = pJNIEnv->GetManagedJNIEnv();
d205 1
a205 1
				return (IntPtr)(void*)pJNIEnv;
d369 1
a369 1
				return pJNIEnv->UnwrapRef(p);
d986 2
a987 2
			JNIEnv* p = TlsHack.pJNIEnv;
			if(p != null)
d989 1
a989 1
				*penv = p;
d1009 2
a1010 2
				// NOTE we're calling UnwrapRef on a null reference, but that's OK because group is a global reference
				object threadGroup = p->UnwrapRef(pAttachArgs->group);
d1022 1
a1022 1
			if(TlsHack.pJNIEnv == null)
d1037 2
a1038 2
				JNIEnv* p = TlsHack.pJNIEnv;
				if(p != null)
d1040 1
a1040 1
					*penv = p;
a1083 1
		private static LocalDataStoreSlot cleanupHelperDataSlot = System.Threading.Thread.AllocateDataSlot();
d1098 1
d1107 1
a1113 10
		}

		unsafe class JNIEnvCleanupHelper
		{
			private JNIEnv* pJNIEnv;

			internal JNIEnvCleanupHelper(JNIEnv* pJNIEnv)
			{
				this.pJNIEnv = pJNIEnv;
			}
d1115 1
a1115 1
			~JNIEnvCleanupHelper()
d1144 3
a1146 7
			JNIEnv* pJNIEnv = TlsHack.pJNIEnv = (JNIEnv*)JniMem.Alloc(sizeof(JNIEnv));
			// don't touch the LocalDataStore slot when we're being unloaded
			// (it may have been finalized already)
			if(!Environment.HasShutdownStarted)
			{
				System.Threading.Thread.SetData(cleanupHelperDataSlot, new JNIEnvCleanupHelper(pJNIEnv));
			}
d1148 1
a1148 1
			pJNIEnv->managedJNIEnv = GCHandle.Alloc(new ManagedJNIEnv());
d1156 1
a1156 8
			// don't touch the LocalDataStore slot when we're being unloaded
			// (it may have been finalized already)
			if(!Environment.HasShutdownStarted)
			{
				// the cleanup helper will eventually free the JNIEnv
				System.Threading.Thread.SetData(cleanupHelperDataSlot, null);
			}
			TlsHack.pJNIEnv = null;
d3499 1
a3499 1
	class JniMem
d3512 1
a3512 1
	unsafe class TlsHack
d3515 1
a3515 1
		internal static JNIEnv* pJNIEnv;
@


1.75
log
@Changed JNI to use standard caller ID mechanism.
@
text
@d1257 1
a1257 6
		// this method returns a simplified method argument descriptor.
		// some examples:
		// "()V" -> ""
		// "(ILjava.lang.String;)I" -> "IL"
		// "([Ljava.lang.String;)V" -> "L"
		private static string GetMethodArgList(IntPtr cookie)
d1259 2
a1260 1
			try
d1262 6
a1267 3
				StringBuilder sb = new StringBuilder();
				string s = MethodWrapper.FromCookie(cookie).Signature;
				for(int i = 1;; i++)
d1269 1
a1269 20
					switch(s[i])
					{
						case '[':
							while(s[i] == '[') i++;
							if(s[i] == 'L')
							{
								while(s[i] != ';') i++;
							}
							sb.Append('L');
							break;
						case 'L':
							while(s[i] != ';') i++;
							sb.Append('L');
							break;
						case ')':
							return sb.ToString();
						default:
							sb.Append(s[i]);
							break;
					}
d1272 1
a1272 15
			catch
			{
				Debug.Assert(false);
				throw;
			}
		}

		internal static jint GetMethodArgs(JNIEnv* pEnv, IntPtr method, byte* sig)
		{
			string s = GetMethodArgList(method);
			for(int i = 0; i < s.Length; i++)
			{
				sig[i] = (byte)s[i];
			}
			return s.Length;
d1636 24
a1659 34
			string sig = GetMethodArgList(methodID);
			object[] argarray = new object[sig.Length];
			for(int i = 0; i < sig.Length; i++)
			{
				switch(sig[i])
				{
					case 'Z':
						argarray[i] = java.lang.Boolean.valueOf(args[i].z != JNI_FALSE);
						break;
					case 'B':
						argarray[i] = java.lang.Byte.valueOf((byte)args[i].b);
						break;
					case 'C':
						argarray[i] = java.lang.Character.valueOf((char)args[i].c);
						break;
					case 'S':
						argarray[i] = java.lang.Short.valueOf(args[i].s);
						break;
					case 'I':
						argarray[i] = java.lang.Integer.valueOf(args[i].i);
						break;
					case 'J':
						argarray[i] = java.lang.Long.valueOf(args[i].j);
						break;
					case 'F':
						argarray[i] = java.lang.Float.valueOf(args[i].f);
						break;
					case 'D':
						argarray[i] = java.lang.Double.valueOf(args[i].d);
						break;
					case 'L':
						argarray[i] = pEnv->UnwrapRef(args[i].l);
						break;
				}
d1663 1
a1663 1
				return MethodWrapper.FromCookie(methodID).InvokeJNI(pEnv->UnwrapRef(obj), argarray, nonVirtual, env.callerID);
@


1.74
log
@When there is no Java code on the stack JNIEnv->FindClass() should use the system class loader instead of the boot class loader.
@
text
@d163 1
a163 1
			private RuntimeMethodHandle prevMethod;
d170 1
a170 1
				Enter(new RuntimeMethodHandle());
d182 1
a182 1
			public IntPtr Enter(RuntimeMethodHandle method)
d190 2
a191 2
				prevMethod = env.currentMethod;
				env.currentMethod = method;
d212 1
a212 1
				env.currentMethod = prevMethod;
d238 1
a238 1
			public static IntPtr GetFuncPtr(RuntimeMethodHandle method, string clazz, string name, string sig)
d240 1
a240 2
				MethodBase mb = MethodBase.GetMethodFromHandle(method);
				ClassLoaderWrapper loader =	ClassLoaderWrapper.GetWrapperFromType(mb.DeclaringType).GetClassLoader();
d1102 1
a1102 1
			internal RuntimeMethodHandle currentMethod;
d1334 1
a1334 1
			if(env.currentMethod.Value != IntPtr.Zero)
d1336 1
a1336 2
				MethodBase mb = MethodBase.GetMethodFromHandle(env.currentMethod);
				return ClassLoaderWrapper.GetWrapperFromType(mb.DeclaringType).GetClassLoader();
d1442 1
a1442 1
					exception = (Exception)cons.newInstance(new object[] { StringFromOEM(msg) }, (ikvm.@@internal.CallerID)JVM.CreateCallerID(env.currentMethod));
d1707 1
a1707 6
				MethodBase caller = null;
				if(env.currentMethod.Value != IntPtr.Zero)
				{
					caller = MethodBase.GetMethodFromHandle(env.currentMethod);
				}
				return MethodWrapper.FromCookie(methodID).InvokeJNI(pEnv->UnwrapRef(obj), argarray, nonVirtual, caller);
@


1.73
log
@Fixed interface method resolution (via JNI) and various other minor method resolution compatibility tweaks.
@
text
@d1344 1
a1344 1
			return ClassLoaderWrapper.GetBootstrapClassLoader();
@


1.72
log
@Removed .NET 4.0 beta 1 workarounds and did some minor updates for .NET 4.0 beta 2.
@
text
@a511 1
		// TODO on Whidbey we should use generics to cut down on the number of delegates needed
d1781 39
d1826 2
d1829 1
d1833 6
a1838 2
					MethodWrapper mw = GetMethodImpl(wrapper, StringFromUTF8(name), methodsig.Replace('/', '.'));
					if(mw != null)
d1840 2
a1841 1
						if(mw.IsStatic == isstatic)
d1843 1
a1843 2
							mw.Link();
							return mw.Cookie;
d1847 6
a1852 1
				SetPendingException(pEnv, new java.lang.NoSuchMethodError(string.Format("{0}{1}", StringFromUTF8(name), StringFromUTF8(sig).Replace('/', '.'))));
@


1.71
log
@Fix for #2829717. Constructing java.lang.String instances should redirect to static helper method.
@
text
@d3093 3
d3097 1
@


1.71.2.1
log
@Backported JNI method lookup algorithm fix and class loader fix.
@
text
@d512 1
d1345 1
a1345 1
			return ClassLoaderWrapper.GetClassLoaderWrapper(java.lang.ClassLoader.getSystemClassLoader());
a1781 39
		private static void AppendInterfaces(List<TypeWrapper> list, IList<TypeWrapper> add)
		{
			foreach (TypeWrapper iface in add)
			{
				if (!list.Contains(iface))
				{
					list.Add(iface);
				}
			}
		}

		private static List<TypeWrapper> TransitiveInterfaces(TypeWrapper tw)
		{
			List<TypeWrapper> list = new List<TypeWrapper>();
			if (tw.BaseTypeWrapper != null)
			{
				AppendInterfaces(list, TransitiveInterfaces(tw.BaseTypeWrapper));
			}
			foreach (TypeWrapper iface in tw.Interfaces)
			{
				AppendInterfaces(list, TransitiveInterfaces(iface));
			}
			AppendInterfaces(list, tw.Interfaces);
			return list;
		}

		private static MethodWrapper GetInterfaceMethodImpl(TypeWrapper tw, string name, string sig)
		{
			foreach (TypeWrapper iface in TransitiveInterfaces(tw))
			{
				MethodWrapper mw = iface.GetMethodWrapper(name, sig, false);
				if (mw != null && !mw.IsHideFromReflection)
				{
					return mw;
				}
			}
			return null;
		}

a1787 2
				// if name == NULL, the JDK returns the constructor
				string methodname = (IntPtr)name == IntPtr.Zero ? "<init>" : StringFromUTF8(name);
a1788 1
				MethodWrapper mw = null;
d1792 2
a1793 6
					methodsig = methodsig.Replace('/', '.');
					if(methodname == "<init>" || methodname == "<clinit>")
					{
						mw = wrapper.GetMethodWrapper(methodname, methodsig, false);
					}
					else
d1795 1
a1795 2
						mw = GetMethodImpl(wrapper, methodname, methodsig);
						if(mw == null)
d1797 2
a1798 1
							mw = GetInterfaceMethodImpl(wrapper, methodname, methodsig);
d1802 1
a1802 6
				if(mw != null && mw.IsStatic == isstatic)
				{
					mw.Link();
					return mw.Cookie;
				}
				SetPendingException(pEnv, new java.lang.NoSuchMethodError(string.Format("{0}{1}", methodname, methodsig)));
a3092 3
				// on .NET 4.0 Monitor.Enter has been marked obsolete,
				// but in this case the alternative adds no value
#pragma warning disable 618
a3093 1
#pragma warning restore 618
@


1.70
log
@Preparing for .NET 4.0:
- moved RuntimeMethodHandle from unmanaged to managed data.
- moved all managed data into a managed data holder, so that we only have to use a single GCHandle.
@
text
@d1620 5
a1626 1
				TypeWrapper wrapper = TypeWrapper.FromClass(pEnv->UnwrapRef(clazz));
d1731 7
a1737 1
			jobject obj = AllocObject(pEnv, clazz);
@


1.69
log
@Implemented native library unloading to support evil trick that com.sun.jna.Native$DeleteNativeLibrary uses (it uses reflection to call ClassLoader$NativeLibrary.finalize() to force the native library to be unloaded, even though the class loader isn't garbage collected.)
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
d162 1
d171 2
a172 2
				ClassLoaderWrapper prev = (ClassLoaderWrapper)pJNIEnv->classLoader.Target;
				pJNIEnv->classLoader.Target = loader;
d178 1
a178 1
				pJNIEnv->classLoader.Target = prev;
d189 7
a195 6
				prevMethod = pJNIEnv->currentMethod;
				pJNIEnv->currentMethod = method;
				object[][] localRefs = pJNIEnv->GetLocalRefs();
				prevLocalRefSlot = pJNIEnv->localRefSlot;
				pJNIEnv->localRefSlot++;
				if(pJNIEnv->localRefSlot >= localRefs.Length)
d199 1
a199 1
					pJNIEnv->localRefs.Target = localRefs = tmp;
d201 1
a201 1
				if(localRefs[pJNIEnv->localRefSlot] == null)
d203 1
a203 1
					localRefs[pJNIEnv->localRefSlot] = new object[32];
d205 2
a206 2
				quickLocals = localRefs[pJNIEnv->localRefSlot];
				quickLocalIndex = (pJNIEnv->localRefSlot << JNIEnv.LOCAL_REF_SHIFT);
d212 5
a216 5
				pJNIEnv->currentMethod = prevMethod;
				Exception x = (Exception)pJNIEnv->UnwrapRef(pJNIEnv->pendingException);
				pJNIEnv->pendingException = IntPtr.Zero;
				object[][] localRefs = pJNIEnv->GetLocalRefs();
				while(pJNIEnv->localRefSlot != prevLocalRefSlot)
d218 1
a218 1
					if(localRefs[pJNIEnv->localRefSlot] != null)
d220 1
a220 1
						if(localRefs[pJNIEnv->localRefSlot].Length == JNIEnv.LOCAL_REF_BUCKET_SIZE)
d223 1
a223 1
							localRefs[pJNIEnv->localRefSlot] = null;
d227 1
a227 1
							Array.Clear(localRefs[pJNIEnv->localRefSlot], 0, localRefs[pJNIEnv->localRefSlot].Length);
d230 1
a230 1
					pJNIEnv->localRefSlot--;
d356 2
a357 2
					object[][] localRefs = (object[][])pJNIEnv->localRefs.Target;
					localRefs[pJNIEnv->localRefSlot] = quickLocals;
d1084 4
a1087 8
		internal void* vtable;
		internal GCHandle localRefs;
		internal int localRefSlot;
		internal IntPtr pendingException;
		internal RuntimeMethodHandle currentMethod;
		internal GCHandle classLoader;
		internal GCHandle criticalArrayHandle1;
		internal GCHandle criticalArrayHandle2;
d1096 23
d1138 1
a1138 5
					if(pJNIEnv->localRefs.IsAllocated)
					{
						pJNIEnv->localRefs.Free();
					}
					if(pJNIEnv->classLoader.IsAllocated)
d1140 1
a1140 1
						pJNIEnv->classLoader.Free();
d1165 1
a1165 10
			object[][] localRefs = new object[32][];
			localRefs[0] = new object[JNIEnv.LOCAL_REF_BUCKET_SIZE];
			// stuff something in the first entry to make sure we don't hand out a zero handle
			// (a zero handle corresponds to a null reference)
			localRefs[0][0] = "";
			pJNIEnv->localRefs = GCHandle.Alloc(localRefs);
			pJNIEnv->localRefSlot = 0;
			pJNIEnv->pendingException = IntPtr.Zero;
			pJNIEnv->currentMethod = new RuntimeMethodHandle();
			pJNIEnv->classLoader = GCHandle.Alloc(null);
d1335 2
a1336 1
			if(pEnv->currentMethod.Value != IntPtr.Zero)
d1338 1
a1338 1
				MethodBase mb = MethodBase.GetMethodFromHandle(pEnv->currentMethod);
d1341 1
a1341 1
			if(pEnv->classLoader.Target != null)
d1343 1
a1343 1
				return (ClassLoaderWrapper)pEnv->classLoader.Target;
d1421 1
a1421 2
			DeleteLocalRef(pEnv, pEnv->pendingException);
			pEnv->pendingException = x == null ? IntPtr.Zero : pEnv->MakeLocalRef(ikvm.runtime.Util.mapException(x));
d1426 3
a1428 2
			DeleteLocalRef(pEnv, pEnv->pendingException);
			pEnv->pendingException = NewLocalRef(pEnv, throwable);
d1434 1
d1445 1
a1445 1
					exception = (Exception)cons.newInstance(new object[] { StringFromOEM(msg) }, (ikvm.@@internal.CallerID)JVM.CreateCallerID(pEnv->currentMethod));
d1470 2
a1471 1
			return NewLocalRef(pEnv, pEnv->pendingException);
d1476 2
a1477 1
			Exception x = (Exception)pEnv->UnwrapRef(pEnv->pendingException);
d1494 2
a1495 2
			DeleteLocalRef(pEnv, pEnv->pendingException);
			pEnv->pendingException = IntPtr.Zero;
d1507 4
a1510 3
			object[][] localRefs = pEnv->GetLocalRefs();
			pEnv->localRefSlot += 2;
			if(pEnv->localRefSlot >= localRefs.Length)
d1514 1
a1514 1
				pEnv->localRefs.Target = localRefs = tmp;
d1517 2
a1518 2
			localRefs[pEnv->localRefSlot - 1] = null;
			if(localRefs[pEnv->localRefSlot] == null)
d1528 1
a1528 1
				localRefs[pEnv->localRefSlot] = new object[r];
d1535 1
d1537 2
a1538 2
			object[][] localRefs = pEnv->GetLocalRefs();
			while(localRefs[pEnv->localRefSlot] != null)
d1540 2
a1541 2
				localRefs[pEnv->localRefSlot] = null;
				pEnv->localRefSlot--;
d1543 1
a1543 1
			pEnv->localRefSlot--;
a1585 5
		internal object[][] GetLocalRefs()
		{
			return (object[][])localRefs.Target;
		}

d1588 1
d1592 1
a1592 1
				object[][] localRefs = pEnv->GetLocalRefs();
d1668 1
d1707 1
a1707 1
				if(pEnv->currentMethod.Value != IntPtr.Zero)
d1709 1
a1709 1
					caller = MethodBase.GetMethodFromHandle(pEnv->currentMethod);
d3366 2
a3367 1
			return pEnv->UnwrapRef(pEnv->pendingException) != null ? JNI_TRUE : JNI_FALSE;
d3438 3
a3440 2
			object[][] localRefs = GetLocalRefs();
			object[] active = localRefs[localRefSlot];
d3446 1
a3446 1
					return (IntPtr)((localRefSlot << LOCAL_REF_SHIFT) + i);
d3454 1
a3454 1
				active = localRefs[localRefSlot] = tmp;
d3456 1
a3456 1
				return (IntPtr)((localRefSlot << LOCAL_REF_SHIFT) + i);
d3463 2
a3464 2
			localRefSlot++;
			if(localRefSlot == localRefs.Length)
d3466 3
a3468 3
				object[][] tmp = new object[localRefSlot * 2][];
				Array.Copy(localRefs, 0, tmp, 0, localRefSlot);
				this.localRefs.Target = localRefs = tmp;
d3470 1
a3470 1
			if(localRefs[localRefSlot] == null)
d3472 1
a3472 1
				localRefs[localRefSlot] = new object[LOCAL_REF_BUCKET_SIZE];
d3474 2
a3475 2
			localRefs[localRefSlot][0] = obj;
			return (IntPtr)(localRefSlot << LOCAL_REF_SHIFT);
d3483 1
a3483 1
				object[][] localRefs = GetLocalRefs();
@


1.69.2.1
log
@Backported fix for #2829717.
@
text
@a1609 5
			return AllocObjectImpl(pEnv, TypeWrapper.FromClass(pEnv->UnwrapRef(clazz)));
		}

		private static jobject AllocObjectImpl(JNIEnv* pEnv, TypeWrapper wrapper)
		{
d1612 1
d1716 1
a1716 7
			TypeWrapper wrapper = TypeWrapper.FromClass(pEnv->UnwrapRef(clazz));
			if(!wrapper.IsAbstract && wrapper.TypeAsBaseType.IsAbstract)
			{
				// static newinstance helper method
				return pEnv->MakeLocalRef(InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false));
			}
			jobject obj = AllocObjectImpl(pEnv, wrapper);
@


1.68
log
@Removed hard coded public key from JniInterface.cs.
@
text
@d394 1
a394 1
		internal unsafe static int LoadLibrary(string filename, object loader)
d399 7
a405 1
		private unsafe static int LoadLibrary(string filename, ClassLoaderWrapper loader)
d426 1
a426 1
							return 1;
d462 1
a462 1
					return 1;
d471 28
@


1.67
log
@Changed JNI reflection to be based on Java reflection (where possible).
@
text
@a59 8
[assembly: AssemblyTitle("IKVM.NET Runtime JNI Layer")]
[assembly: AssemblyDescription("JVM for Mono and .NET")]
#if SIGNCODE
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("IKVM.Runtime, PublicKey=0024000004800000940000000602000000240000525341310004000001000100DD6B140E5209CAE3D1C710030021EF589D0F00D05ACA8771101A7E99E10EE063E66040DF96E6F842F717BFC5B62D2EC2B62CEB0282E4649790DACB424DB29B68ADC7EAEAB0356FCE04702379F84400B8427EDBB33DAB8720B9F16A42E2CDB87F885EF413DBC4229F2BD157C9B8DC2CD14866DEC5F31C764BFB9394CC3C60E6C0")]
#else
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("IKVM.Runtime")]
#endif

@


1.66
log
@Added helper methods to no longer require reflection to instantiate DirectByteBuffer from JNI.
@
text
@d1408 2
a1409 1
					exception = (Exception)mw.InvokeJNI(null, new object[] { StringFromOEM(msg) }, false, null);
d1639 1
a1639 1
						argarray[i] = args[i].z != JNI_FALSE;
d1642 1
a1642 1
						argarray[i] = args[i].b;
d1645 1
a1645 1
						argarray[i] = (char)args[i].c;
d1648 1
a1648 1
						argarray[i] = args[i].s;
d1651 1
a1651 1
						argarray[i] = args[i].i;
d1654 1
a1654 1
						argarray[i] = args[i].j;
d1657 1
a1657 1
						argarray[i] = args[i].f;
d1660 1
a1660 1
						argarray[i] = args[i].d;
d2007 1
a2007 1
		private static void SetFieldValue(jfieldID cookie, object obj, object val)
d2009 1
a2009 22
			try
			{
				FieldWrapper.FromCookie(cookie).SetValue(obj, val);
			}
			catch
			{
				Debug.Assert(false);
				throw;
			}
		}

		private static object GetFieldValue(jfieldID cookie, object obj)
		{
			try
			{
				return FieldWrapper.FromCookie(cookie).GetValue(obj);
			}
			catch
			{
				Debug.Assert(false);
				throw;
			}
d2014 1
a2014 1
			return pEnv->MakeLocalRef(GetFieldValue(fieldID, pEnv->UnwrapRef(obj)));
d2019 1
a2019 1
			return ((bool)GetFieldValue(fieldID, pEnv->UnwrapRef(obj))) ? JNI_TRUE : JNI_FALSE;
d2024 1
a2024 1
			return (jbyte)(byte)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d2029 1
a2029 1
			return (jchar)(char)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d2034 1
a2034 1
			return (jshort)(short)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d2039 1
a2039 1
			return (jint)(int)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d2044 1
a2044 1
			return (jlong)(long)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d2049 1
a2049 1
			return (jfloat)(float)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d2054 1
a2054 1
			return (jdouble)(double)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d2059 1
a2059 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), pEnv->UnwrapRef(val));
d2064 1
a2064 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), val != JNI_FALSE);
d2069 1
a2069 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (byte)val);
d2074 1
a2074 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (char)val);
d2079 1
a2079 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (short)val);
d2084 1
a2084 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (int)val);
d2089 1
a2089 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (long)val);
d2094 1
a2094 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (float)val);
d2099 1
a2099 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (double)val);
d2204 1
a2204 1
			return pEnv->MakeLocalRef(GetFieldValue(fieldID, null));
d2209 1
a2209 1
			return ((bool)GetFieldValue(fieldID, null)) ? JNI_TRUE : JNI_FALSE;
d2214 1
a2214 1
			return (jbyte)(byte)GetFieldValue(fieldID, null);
d2219 1
a2219 1
			return (jchar)(char)GetFieldValue(fieldID, null);
d2224 1
a2224 1
			return (jshort)(short)GetFieldValue(fieldID, null);
d2229 1
a2229 1
			return (jint)(int)GetFieldValue(fieldID, null);
d2234 1
a2234 1
			return (jlong)(long)GetFieldValue(fieldID, null);
d2239 1
a2239 1
			return (jfloat)(float)GetFieldValue(fieldID, null);
d2244 1
a2244 1
			return (jdouble)(double)GetFieldValue(fieldID, null);
d2249 1
a2249 1
			SetFieldValue(fieldID, null, pEnv->UnwrapRef(val));
d2254 1
a2254 1
			SetFieldValue(fieldID, null, val != JNI_FALSE);
d2259 1
a2259 1
			SetFieldValue(fieldID, null, (byte)val);
d2264 1
a2264 1
			SetFieldValue(fieldID, null, (char)val);
d2269 1
a2269 1
			SetFieldValue(fieldID, null, (short)val);
d2274 1
a2274 1
			SetFieldValue(fieldID, null, (int)val);
d2279 1
a2279 1
			SetFieldValue(fieldID, null, (long)val);
d2284 1
a2284 1
			SetFieldValue(fieldID, null, (float)val);
d2289 1
a2289 1
			SetFieldValue(fieldID, null, (double)val);
@


1.65
log
@Generified all collections.
@
text
@d3361 1
a3361 3
				return pEnv->MakeLocalRef(JVM.CoreAssembly.GetType("java.nio.DirectByteBuffer")
					.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { typeof(long), typeof(int) }, null)
					.Invoke(new object[] { address.ToInt64(), (int)capacity }));
@


1.64
log
@Removed support for building with GNU Classpath class library.
@
text
@d25 1
a25 2
using System.Collections;
using System.Collections.Specialized;
d109 1
a109 1
			Hashtable props = new Hashtable();
d132 1
a132 1
			JVM.SetProperties(props);
d398 1
a398 1
		private static ArrayList nativeLibraries = new ArrayList();
@


1.63
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@a943 1
#if OPENJDK
a944 3
#else
			JVM.Library.jniWaitUntilLastThread();
#endif
a989 1
#if OPENJDK
a990 3
#else
					JVM.Library.setThreadGroup(threadGroup);
#endif
a1005 1
#if OPENJDK
a1006 3
#else
			JVM.Library.jniDetach();
#endif
a1290 1
#if OPENJDK
a1291 3
#else
				return pEnv->MakeLocalRef(IKVM.NativeCode.java.lang.VMClassLoader.defineClassImpl(pEnv->UnwrapRef(loader), name != null ? StringFromOEM(name) : null, buf, 0, buf.Length, null));
#endif
a3361 1
#if OPENJDK
a3364 3
#else
				return pEnv->MakeLocalRef(JVM.Library.newDirectByteBuffer(address, (int)capacity));
#endif
a3376 1
#if OPENJDK
a3377 3
#else
				return JVM.Library.getDirectBufferAddress(pEnv->UnwrapRef(buf));
#endif
@


1.62
log
@Added workarounds for mcs compiler bug (related to the mutual dependency of the runtime and class library assemblies).
@
text
@d1425 1
a1425 1
					exception = (Exception)mw.Invoke(null, new object[] { StringFromOEM(msg) }, false);
d1685 6
a1690 1
				return MethodWrapper.FromCookie(methodID).Invoke(pEnv->UnwrapRef(obj), argarray, nonVirtual);
@


1.61
log
@Moved java.lang.Thread "native" methods to Java.
@
text
@d402 7
a408 1
		internal unsafe static int LoadLibrary(string filename, ClassLoaderWrapper loader)
@


1.60
log
@Filter out HideFromReflection members.
@
text
@d1009 1
a1009 1
			IKVM.NativeCode.java.lang.Thread.DetachThread();
@


1.59
log
@Initialize class library in JVM_CreateJavaVM.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d1723 17
d1750 1
a1750 1
					MethodWrapper mw = wrapper.GetMethodWrapper(StringFromUTF8(name), methodsig.Replace('/', '.'), true);
d1958 17
d1985 1
a1985 1
					FieldWrapper fw = wrapper.GetFieldWrapper(StringFromUTF8(name), fieldsig.Replace('/', '.'));
@


1.58
log
@- Moved common assembly attributes to single file (CommonAssemblyInfo.cs).
- Added IKVM.Runtime.JNI project to Visual Studio solution.
- Added atomic.cs to Visual Studio projects.
- Added SecurityCritical and AllowPartiallyTrustedCallers attributes to IKVM.Runtime.dll.
@
text
@d135 3
@


1.57
log
@- Moved some calls to methods with a LinkDemand (that fails in partial trust) to a separate methods.
- Added stuff to map.xml to remove the need for reflection in VM / Library bootstrap.
- Inverted IKVM.Runtime.JNI dependency in stack walking code.
@
text
@a62 6
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("IKVM.NET")]
[assembly: AssemblyCopyright("Copyright (C) 2002-2007 Jeroen Frijters")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
a63 1
[assembly: AssemblyKeyName("ikvm-key")]
@


1.56
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@d1077 6
@


1.55
log
@Moved JNI implementation into a separate assembly (IKVM.Runtime.JNI.dll) to make IKVM.Runtime.dll verifiable.
@
text
@d140 1
a140 1
			JVM.Library.setProperties(props);
d1396 1
a1396 1
			pEnv->pendingException = x == null ? IntPtr.Zero : pEnv->MakeLocalRef(JVM.Library.mapException(x));
d1681 1
a1681 1
				SetPendingException(pEnv, JVM.Library.mapException(x.getCause()));
d1686 1
a1686 1
				SetPendingException(pEnv, JVM.Library.mapException(x));
d3341 1
a3341 1
				SetPendingException(pEnv, JVM.Library.mapException(x));
d3350 3
d3354 1
d3358 1
a3358 1
				SetPendingException(pEnv, JVM.Library.mapException(x));
d3367 1
a3367 1
				return (jlong)(long)JVM.Library.getDirectBufferCapacity(pEnv->UnwrapRef(buf));
d3371 1
a3371 1
				SetPendingException(pEnv, JVM.Library.mapException(x));
@


1.54
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@a23 1
#if !COMPACT_FRAMEWORK
d61 15
a311 3
#if FIRST_PASS
				return IntPtr.Zero;
#else
a314 1
#endif
a431 1
#if !FIRST_PASS
a434 1
#endif
a455 1
#if !FIRST_PASS
a458 1
#endif
a1329 1
#if !FIRST_PASS
a1330 1
#endif
a1340 1
#if !FIRST_PASS
a1341 1
#endif
a1434 1
#if !FIRST_PASS
a1435 1
#endif
a1452 1
#if !FIRST_PASS
a1453 1
#endif
a1596 1
#if !FIRST_PASS
a1597 1
#endif
a1678 1
#if !FIRST_PASS
a1683 1
#endif
a1740 1
#if !FIRST_PASS
a1741 1
#endif
a1957 1
#if !FIRST_PASS
a1958 1
#endif
a2376 1
#if !FIRST_PASS
a2377 1
#endif
a2395 1
#if !FIRST_PASS
a2396 1
#endif
a2409 1
#if !FIRST_PASS
a2410 1
#endif
a2742 1
#if !FIRST_PASS
a2743 1
#endif
a2759 1
#if !FIRST_PASS
a2760 1
#endif
a2772 1
#if !FIRST_PASS
a2773 1
#endif
a2785 1
#if !FIRST_PASS
a2786 1
#endif
a2798 1
#if !FIRST_PASS
a2799 1
#endif
a2811 1
#if !FIRST_PASS
a2812 1
#endif
a2824 1
#if !FIRST_PASS
a2825 1
#endif
a2837 1
#if !FIRST_PASS
a2838 1
#endif
a2854 1
#if !FIRST_PASS
a2855 1
#endif
a2871 1
#if !FIRST_PASS
a2872 1
#endif
a2884 1
#if !FIRST_PASS
a2885 1
#endif
a2897 1
#if !FIRST_PASS
a2898 1
#endif
a2910 1
#if !FIRST_PASS
a2911 1
#endif
a2923 1
#if !FIRST_PASS
a2924 1
#endif
a2936 1
#if !FIRST_PASS
a2937 1
#endif
a2949 1
#if !FIRST_PASS
a2950 1
#endif
a2982 1
#if !FIRST_PASS
a2983 1
#endif
a3072 1
#if !FIRST_PASS
a3073 1
#endif
a3088 1
#if !FIRST_PASS
a3089 1
#endif
a3099 1
#if !FIRST_PASS
a3100 1
#endif
a3129 1
#if !FIRST_PASS
a3130 1
#endif
a3263 1
#if !FIRST_PASS
a3264 1
#endif
a3327 1
#if !FIRST_PASS
a3328 1
#endif
a3483 1
#endif
@


1.53
log
@Implemented 1.6 JNI changes.
@
text
@d438 1
d477 1
d571 1
@


1.52
log
@Integrated OpenJDK java.nio package.
@
text
@d88 1
a88 1
			return version == JNIEnv.JNI_VERSION_1_1 || version == JNIEnv.JNI_VERSION_1_2 || version == JNIEnv.JNI_VERSION_1_4;
d879 3
a881 1
			new pf_long_IntPtr(JNIEnv.GetDirectBufferCapacity)  //virtual jlong JNICALL GetDirectBufferCapacity(jobject buf);
d1051 5
d1275 1
a1275 1
			return JNI_VERSION_1_4;
d3431 18
@


1.52.2.1
log
@Implemented 1.6 JNI changes.
@
text
@d88 1
a88 1
			return version == JNIEnv.JNI_VERSION_1_1 || version == JNIEnv.JNI_VERSION_1_2 || version == JNIEnv.JNI_VERSION_1_4 || version == JNIEnv.JNI_VERSION_1_6;
d879 1
a879 3
			new pf_long_IntPtr(JNIEnv.GetDirectBufferCapacity), //virtual jlong JNICALL GetDirectBufferCapacity(jobject buf);

			new pf_int_IntPtr(JNIEnv.GetObjectRefType) // virtual jobjectRefType GetObjectRefType(jobject obj);
a1048 5
		internal const int JNI_VERSION_1_6 = 0x00010006;
		internal const int JNIInvalidRefType = 0;
		internal const int JNILocalRefType = 1;
		internal const int JNIGlobalRefType = 2;
		internal const int JNIWeakGlobalRefType = 3;
d1268 1
a1268 1
			return JNI_VERSION_1_6;
a3423 18
		internal static int GetObjectRefType(JNIEnv* pEnv, jobject obj)
		{
			int i = obj.ToInt32();
			if(i >= 0)
			{
				return JNILocalRefType;
			}
			i = -i;
			if((i & (1 << 30)) != 0)
			{
				return JNIWeakGlobalRefType;
			}
			else
			{
				return JNIGlobalRefType;
			}
		}

@


1.52.2.2
log
@Fixed JVM_CreateJavaVM to initialize the class library.
@
text
@a127 3
			// initialize the class library
			java.lang.Thread.currentThread();

@


1.52.2.3
log
@Compile fix for first-pass compilation.
@
text
@a127 1
#if !FIRST_PASS
a129 1
#endif
@


1.52.2.4
log
@Filter out HideFromReflection members.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
a1728 17
		private static MethodWrapper GetMethodImpl(TypeWrapper tw, string name, string sig)
		{
			for(;;)
			{
				MethodWrapper mw = tw.GetMethodWrapper(name, sig, true);
				if(mw == null || !mw.IsHideFromReflection)
				{
					return mw;
				}
				tw = mw.DeclaringType.BaseTypeWrapper;
				if(tw == null)
				{
					return null;
				}
			}
		}

d1739 1
a1739 1
					MethodWrapper mw = GetMethodImpl(wrapper, StringFromUTF8(name), methodsig.Replace('/', '.'));
a1948 17
		private static FieldWrapper GetFieldImpl(TypeWrapper tw, string name, string sig)
		{
			for(;;)
			{
				FieldWrapper fw = tw.GetFieldWrapper(name, sig);
				if(fw == null || !fw.IsHideFromReflection)
				{
					return fw;
				}
				tw = fw.DeclaringType.BaseTypeWrapper;
				if(tw == null)
				{
					return null;
				}
			}
		}

d1959 1
a1959 1
					FieldWrapper fw = GetFieldImpl(wrapper, StringFromUTF8(name), fieldsig.Replace('/', '.'));
@


1.51
log
@Fixed NewObject to actually create an object of the requested class, instead of the class of the constructor.
@
text
@d3383 5
d3389 1
@


1.50
log
@Added clean up for attached threads.
@
text
@d1689 11
a1699 1
			return pEnv->MakeLocalRef(InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false));
@


1.49
log
@Integrated OpenJDK's java.lang.Thread
@
text
@d1002 1
a1002 1
			IKVM.NativeCode.java.lang.Thread.DetachThreadFromJni();
@


1.48
log
@Integrated OpenJDK's java.lang.reflect.* classes (except for Array).
@
text
@d931 3
d935 1
d981 3
d985 1
d1001 3
d1005 1
@


1.47
log
@Simplified VM -> Class Library interface by taking advantage of the fact that IKVM.Runtime.dll is now compiled in two passes with the second pass linking against the class library.
@
text
@d1267 3
d1271 1
d1338 1
a1338 1
			return ((MethodWrapper)JVM.Library.getWrapperFromMethodOrConstructor(pEnv->UnwrapRef(method))).Cookie;
d1343 1
a1343 1
			return ((FieldWrapper)JVM.Library.getWrapperFromField(pEnv->UnwrapRef(field))).Cookie;
d1348 1
a1348 10
			MethodWrapper mw = MethodWrapper.FromCookie(method);
			object clazz = mw.DeclaringType.ClassObject;
			if(mw.Name == "<init>")
			{
				return pEnv->MakeLocalRef(JVM.Library.newConstructor(clazz, mw));
			}
			else
			{
				return pEnv->MakeLocalRef(JVM.Library.newMethod(clazz, mw));
			}
d1366 1
a1366 3
			FieldWrapper fw = FieldWrapper.FromCookie(field);
			object clazz = fw.DeclaringType.ClassObject;
			return pEnv->MakeLocalRef(JVM.Library.newField(clazz, fw));
d1664 1
a1664 1
				SetPendingException(pEnv, JVM.Library.mapException(x.InnerException));
@


1.46
log
@Updated init args and thread attach string conversions to explicitly use UTF-8 or OEM encoding as specified in the JDK 6 JNI spec.
@
text
@d298 7
a304 1
				throw JavaException.UnsatisfiedLinkError("{0}.{1}{2}", clazz, name, sig);
d422 5
a426 1
						throw JavaException.UnsatisfiedLinkError("Native library {0} already loaded in another classloader", filename);
d447 5
a451 1
							throw JavaException.UnsatisfiedLinkError("Unsupported JNI version 0x{0:X} required by {1}", version, filename);
d1298 3
a1300 1
					SetPendingException(pEnv, JavaException.NoClassDefFoundError(name));
d1311 3
a1313 1
					SetPendingException(pEnv, JavaException.NoClassDefFoundError(name));
d1418 3
a1420 1
				SetPendingException(pEnv, JavaException.NoSuchMethodError("<init>(Ljava.lang.String;)V"));
d1438 3
a1440 1
					JVM.Library.printStackTrace(x);
d1584 3
a1586 1
					SetPendingException(pEnv, JavaException.InstantiationException(wrapper.Name));
d1668 7
a1676 4
				if(ClassLoaderWrapper.LoadClassCritical("java.lang.reflect.InvocationTargetException").TypeAsExceptionType.IsInstanceOfType(x))
				{
					x = x.InnerException;
				}
d1722 3
a1724 1
				SetPendingException(pEnv, JavaException.NoSuchMethodError("{0}{1}", StringFromUTF8(name), StringFromUTF8(sig).Replace('/', '.')));
d1941 3
a1943 1
				SetPendingException(pEnv, JavaException.NoSuchFieldError((isstatic ? "Static" : "Instance") + " field '" + StringFromUTF8(name) + "' with signature '" + fieldsig + "' not found in class '" + wrapper.Name + "'"));
d2362 3
a2364 1
				SetPendingException(pEnv, JavaException.NegativeArraySizeException());
d2383 3
a2385 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2399 3
a2401 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2734 3
a2736 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2753 3
a2755 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2768 3
a2770 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2783 3
a2785 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2798 3
a2800 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2813 3
a2815 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2828 3
a2830 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2843 3
a2845 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2862 3
a2864 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2881 3
a2883 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2896 3
a2898 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2911 3
a2913 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2926 3
a2928 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2941 3
a2943 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2956 3
a2958 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d2971 3
a2973 1
				SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
d3006 3
a3008 1
						SetPendingException(pEnv, JavaException.NoSuchMethodError(methodName));
d3098 3
a3100 1
					SetPendingException(pEnv, JavaException.StringIndexOutOfBoundsException());
d3116 3
a3118 1
				SetPendingException(pEnv, JavaException.NullPointerException());
d3129 3
a3131 1
					SetPendingException(pEnv, JavaException.StringIndexOutOfBoundsException());
d3161 3
a3163 1
				SetPendingException(pEnv, JavaException.NullPointerException());
d3297 3
a3299 1
			SetPendingException(pEnv, JavaException.NullPointerException());
d3363 3
a3365 1
					SetPendingException(pEnv, JavaException.IllegalArgumentException("capacity"));
@


1.46.2.1
log
@back ported the follwing fixes and incremented version to 0.34.0.4:
- magic assembly type for assembly attribute annotations (bug #1721688)
- LocalVariableTable robustness fix (bug #1765952)
- public interfaces extending non-public interfaces
- parameter annotations on redirected contructors
- casting ghost interface arrays (bug #1757889)
- JNI NewObject fix
- make sure all implemented interface methods on .NET types are public (so that ikvmstub generates jars that javac is happy with)
@
text
@d1657 1
a1657 11
			jobject obj = AllocObject(pEnv, clazz);
			if(obj != IntPtr.Zero)
			{
				InvokeHelper(pEnv, obj, methodID, args, false);
				if(ExceptionCheck(pEnv) == JNI_TRUE)
				{
					DeleteLocalRef(pEnv, obj);
					obj = IntPtr.Zero;
				}
			}
			return obj;
@


1.45
log
@- Made JNIEnv.FatalError more compatible with JDK and removed call to JVM.CriticalFailure (which is reserved for IKVM bugs).
- Centralised OEM string decoding.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d67 1
a67 1
		internal sbyte* optionString;
d106 1
a106 1
				string option = new String(pInitArgs->options[i].optionString);
d873 1
a873 1
		internal sbyte* name;
d952 1
a952 1
						System.Threading.Thread.CurrentThread.Name = new String(pAttachArgs->name);
d1112 1
a1112 1
		private static string StringFromOEM(byte* psz)
@


1.44
log
@*** empty log message ***
@
text
@d1112 12
d1253 1
a1253 1
				return pEnv->MakeLocalRef(IKVM.NativeCode.java.lang.VMClassLoader.defineClassImpl(pEnv->UnwrapRef(loader), name != null ? new String((sbyte*)name) : null, buf, 0, buf.Length, null));
d1280 1
a1280 1
				string name = new String((sbyte*)pszName);
d1382 1
a1382 1
					exception = (Exception)mw.Invoke(null, new object[] { new String((sbyte*)msg) }, false);
d1435 3
a1437 1
			JVM.CriticalFailure(new String((sbyte*)msg), null);
@


1.43
log
@*** empty log message ***
@
text
@d429 1
d1898 1
a1898 1
				SetPendingException(pEnv, JavaException.NoSuchFieldError(StringFromUTF8(name)));
@


1.42
log
@*** empty log message ***
@
text
@d126 1
a126 1
			Startup.SetProperties(props);
d1348 1
a1348 1
			pEnv->pendingException = x == null ? IntPtr.Zero : pEnv->MakeLocalRef(Util.MapException(x));
d1635 1
a1635 1
				SetPendingException(pEnv, Util.MapException(x));
d1647 1
a1647 1
			return pEnv->MakeLocalRef(IKVM.Runtime.Util.GetClassFromObject(pEnv->UnwrapRef(obj)));
d1654 1
a1654 1
			object objClass = IKVM.Runtime.Util.GetClassFromObject(pEnv->UnwrapRef(obj));
d3274 1
a3274 1
				SetPendingException(pEnv, Util.MapException(x));
d3287 1
a3287 1
				SetPendingException(pEnv, Util.MapException(x));
d3300 1
a3300 1
				SetPendingException(pEnv, Util.MapException(x));
@


1.41
log
@*** empty log message ***
@
text
@a238 6
				// HACK since we're returning the system class loader for statically compiled classes,
				// we have to use that here too
				if(loader.GetJavaClassLoader() == null)
				{
					loader = (ClassLoaderWrapper)JVM.Library.getWrapperFromClassLoader(JVM.Library.getSystemClassLoader());
				}
d1254 1
a1254 5
				ClassLoaderWrapper loader =	ClassLoaderWrapper.GetWrapperFromType(mb.DeclaringType).GetClassLoader();
				if(loader.GetJavaClassLoader() != null)
				{
					return loader;
				}
d1260 1
a1260 1
			return (ClassLoaderWrapper)JVM.Library.getWrapperFromClassLoader(JVM.Library.getSystemClassLoader());
@


1.40
log
@*** empty log message ***
@
text
@a379 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_LoadLibrary@@4")]
a381 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_FreeLibrary@@4")]
a383 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_GetProcAddress@@12")]
a385 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_CallOnLoad@@12")]
a387 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_GetJNIEnvVTable@@0")]
a389 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_MarshalDelegate@@4")]
a907 4
//#if __MonoCS__ 
//		// MONOBUG mcs requires this bogus fixed construct (and Microsoft doesn't allow it)
//		fixed(void** p = &pJavaVM->firstVtableEntry) { pJavaVM->vtable = p; }
//#else
a908 1
//#endif
a3393 6
			// MONOBUG Marshal.AllocHGlobal returns a null pointer if we try to allocate zero bytes
			// (as of Mono 1.0.2 this shouldn't be necessary anymore)
			if(cb == 0)
			{
				cb = 1;
			}
@


1.39
log
@*** empty log message ***
@
text
@d243 1
a243 1
					loader = ClassLoaderWrapper.GetSystemClassLoader();
d1281 1
a1281 1
			return ClassLoaderWrapper.GetSystemClassLoader();
@


1.38
log
@*** empty log message ***
@
text
@d239 6
@


1.37
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
@


1.36
log
@*** empty log message ***
@
text
@d1342 1
a1342 1
			TypeWrapper wrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(sub)).BaseTypeWrapper;
d1348 2
a1349 2
			TypeWrapper w1 = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(sub));
			TypeWrapper w2 = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(super));
d1375 1
a1375 1
			TypeWrapper wrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
d1559 1
a1559 1
				TypeWrapper wrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
d1670 2
a1671 2
			TypeWrapper w1 = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
			TypeWrapper w2 = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(objClass);
d1679 1
a1679 1
				TypeWrapper wrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
d1897 1
a1897 1
				TypeWrapper wrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
d2318 1
a2318 1
				Array array = Array.CreateInstance(IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz)).TypeAsArrayType, len);
d2920 1
a2920 1
				TypeWrapper wrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
d2960 1
a2960 1
				TypeWrapper wrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
@


1.35
log
@*** empty log message ***
@
text
@d24 1
d3420 1
@


1.34
log
@*** empty log message ***
@
text
@d477 2
d856 2
a857 2
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetPrimitiveArrayCritical), //virtual void* JNICALL GetPrimitiveArrayCritical(jarray array, jboolean *isCopy);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.ReleasePrimitiveArrayCritical), //virtual void JNICALL ReleasePrimitiveArrayCritical(jarray array, void *carray, jint mode);
d859 2
a860 2
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetStringCritical), //virtual const jchar* JNICALL GetStringCritical(jstring string, jboolean *isCopy);
			new pf_void_IntPtr_IntPtr(JNIEnv.ReleaseStringCritical), //virtual void JNICALL ReleaseStringCritical(jstring string, const jchar *cstring);
d1040 2
d1071 8
d1104 2
d3113 1
a3113 1
		internal static IntPtr GetPrimitiveArrayCritical(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
d3116 18
d3147 1
a3147 1
				if(isCopy != IntPtr.Zero)
d3149 1
a3149 1
					*((sbyte*)(void*)isCopy) = JNI_TRUE;
d3151 1
a3151 1
				return hglobal;
d3159 1
a3159 1
		internal static void ReleasePrimitiveArrayCritical(JNIEnv* pEnv, IntPtr array, IntPtr carray, int mode)
d3161 19
a3181 1
				Array ar = (Array)pEnv->UnwrapRef(array);
d3202 1
a3202 1
				JniMem.Free(carray);
d3206 1
a3206 1
		internal static IntPtr GetStringCritical(JNIEnv* pEnv, IntPtr str, IntPtr isCopy)
d3211 1
a3211 1
				if(isCopy != IntPtr.Zero)
d3213 1
a3213 1
					*((sbyte*)(void*)isCopy) = JNI_TRUE;
d3215 1
a3215 1
				return Marshal.StringToHGlobalUni(s);		
d3218 1
a3218 1
			return IntPtr.Zero;
d3221 1
a3221 1
		internal static void ReleaseStringCritical(JNIEnv* pEnv, IntPtr str, IntPtr cstring)
d3223 1
a3223 1
			Marshal.FreeHGlobal(cstring);
@


1.33
log
@*** empty log message ***
@
text
@d1279 6
a1284 1
				TypeWrapper wrapper = FindNativeMethodClassLoader(pEnv).LoadClassByDottedName(name.Replace('/', '.'));
a1295 4
				if(ClassLoaderWrapper.LoadClassCritical("java.lang.ClassNotFoundException").TypeAsTBD.IsInstanceOfType(x))
				{
					x = JavaException.NoClassDefFoundError(x.Message);
				}
@


1.32
log
@*** empty log message ***
@
text
@d145 4
a148 1
				*nVMs = 1;
d150 1
a150 1
			else
@


1.31
log
@*** empty log message ***
@
text
@d902 4
a905 4
#if __MonoCS__ 
		// MONOBUG mcs requires this bogus fixed construct (and Microsoft doesn't allow it)
		fixed(void** p = &pJavaVM->firstVtableEntry) { pJavaVM->vtable = p; }
#else
d907 1
a907 1
#endif
@


1.30
log
@*** empty log message ***
@
text
@a233 5
				// MONOBUG Mono 1.0 doesn't implement MethodBase.GetMethodFromHandle
				if(mb == null)
				{
					mb = new StackFrame(1).GetMethod();
				}
d540 1
d578 1
a578 1
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.ToReflectedMethod), //virtual jobject JNICALL ToReflectedMethod(jclass clazz, jmethodID methodID);
d583 1
a583 1
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.ToReflectedField), //virtual jobject JNICALL ToReflectedField(jclass clazz, jfieldID fieldID);
d1247 2
a1248 1
				if(mb != null)
d1250 1
a1250 24
					ClassLoaderWrapper loader =	ClassLoaderWrapper.GetWrapperFromType(mb.DeclaringType).GetClassLoader();
					if(loader.GetJavaClassLoader() != null)
					{
						return loader;
					}
				}
				else
				{
					// MONOBUG Mono 1.0 doesn't implement MethodBase.GetMethodFromHandle, so we do a stack walk
					// to try and find the caller
					StackTrace st = new StackTrace();
					for(int i = 0; i < st.FrameCount; i++)
					{
						StackFrame frame = st.GetFrame(i);
						Type type = frame.GetMethod().DeclaringType;
						if(type != null && frame.GetMethod().MethodHandle.Value == pEnv->currentMethod.Value)
						{
							ClassLoaderWrapper loader = ClassLoaderWrapper.GetWrapperFromType(type).GetClassLoader();
							if(loader.GetJavaClassLoader() != null)
							{
								return loader;
							}
						}
					}
d1307 1
a1307 1
		internal static jobject ToReflectedMethod(JNIEnv* pEnv, jclass clazz_ignored, jmethodID method)
d1334 1
a1334 1
		internal static jobject ToReflectedField(JNIEnv* pEnv, jclass clazz_ignored, jfieldID field)
d3183 1
a3183 2
					// MONOBUG GCHandle.IsAllocated is horribly broken, so we also check the value of the handle
					if(!GlobalRefs.weakRefs[i].IsAllocated || (IntPtr)GlobalRefs.weakRefs[i] == IntPtr.Zero)
@


1.29
log
@*** empty log message ***
@
text
@d1058 1
a1058 1
				if(!(AppDomain.CurrentDomain.IsFinalizingForUnload() || Environment.HasShutdownStarted))
d1076 6
a1081 1
			System.Threading.Thread.SetData(cleanupHelperDataSlot, new JNIEnvCleanupHelper(pJNIEnv));
d1100 1
a1100 1
			if(!(AppDomain.CurrentDomain.IsFinalizingForUnload() || Environment.HasShutdownStarted))
@


1.28
log
@*** empty log message ***
@
text
@d1052 18
a1069 3
				pJNIEnv->localRefs.Free();
				pJNIEnv->classLoader.Free();
				JniMem.Free((IntPtr)(void*)pJNIEnv);
d1076 1
a1076 1
			//System.Threading.Thread.SetData(cleanupHelperDataSlot, new JNIEnvCleanupHelper(pJNIEnv));
d1093 7
a1099 2
			// the cleanup helper will eventually free the JNIEnv
			System.Threading.Thread.SetData(cleanupHelperDataSlot, null);
@


1.27
log
@*** empty log message ***
@
text
@d173 1
d431 1
d433 8
a440 2
						int version = ikvm_CallOnLoad(onload, JavaVM.pJavaVM, null);
						f.Leave(prevLoader);
@


1.26
log
@*** empty log message ***
@
text
@d81 3
a83 3
		internal static bool jvmCreated;
		internal static bool jvmDestroyed;
		internal const string METHOD_PTR_FIELD_PREFIX = "__<jniptr/";
d278 2
d287 1
d293 1
d398 1
d404 1
d416 1
d424 1
d428 1
d542 1
d2898 3
a2900 1
					string methodsig = StringFromUTF8(methods[i].signature);
d2903 1
a2903 1
					if(methodsig.IndexOf('.') < 0)
d2906 1
a2906 1
						fi = wrapper.TypeAsTBD.GetField(JNI.METHOD_PTR_FIELD_PREFIX + StringFromUTF8(methods[i].name) + methodsig.Replace('/', '.') + ">", BindingFlags.Static | BindingFlags.NonPublic);
d2910 2
a2911 1
						SetPendingException(pEnv, JavaException.NoSuchMethodError(StringFromUTF8(methods[i].name)));
d2939 2
a2940 1
					if(fi.Name.StartsWith(JNI.METHOD_PTR_FIELD_PREFIX))
d2942 1
@


1.25
log
@*** empty log message ***
@
text
@a238 1
				StringBuilder mangledSig = new StringBuilder();
a244 1
							mangledSig.Append("_3");
d246 1
a246 5
							while(sig[++i] == '[')
							{
								mangledSig.Append("_3");
							}
							mangledSig.Append(sig[i]);
d249 1
a249 16
								while(sig[++i] != ';')
								{
									if(sig[i] == '/')
									{
										mangledSig.Append("_");
									}
									else if(sig[i] == '_')
									{
										mangledSig.Append("_1");
									}
									else
									{
										mangledSig.Append(sig[i]);
									}
								}
								mangledSig.Append("_2");
d254 1
a254 17
							mangledSig.Append("L");
							while(sig[++i] != ';')
							{
								if(sig[i] == '/')
								{
									mangledSig.Append("_");
								}
								else if(sig[i] == '_')
								{
									mangledSig.Append("_1");
								}
								else
								{
									mangledSig.Append(sig[i]);
								}
							}
							mangledSig.Append("_2");
a257 1
							mangledSig.Append(sig[i]);
a265 1
							mangledSig.Append(sig[i]);
d273 5
a279 2
					string shortMethodName = String.Format("Java_{0}_{1}", clazz.Replace("_", "_1").Replace('/', '_'), name.Replace("_", "_1"));
					string longMethodName = String.Format("Java_{0}_{1}__{2}", clazz.Replace("_", "_1").Replace('/', '_'), name.Replace("_", "_1"), mangledSig);
d297 33
@


1.24
log
@*** empty log message ***
@
text
@d373 1
d376 1
d379 1
d382 1
d385 1
d388 1
d1648 3
a1650 2
				MethodWrapper mw = wrapper.GetMethodWrapper(StringFromUTF8(name), StringFromUTF8(sig).Replace('/', '.'), true);
				if(mw != null)
d1652 2
a1653 1
					if(mw.IsStatic == isstatic)
d1655 5
a1659 2
						mw.Link();
						return mw.Cookie;
d1866 3
a1868 2
				FieldWrapper fw = wrapper.GetFieldWrapper(StringFromUTF8(name), StringFromUTF8(sig).Replace('/', '.'));
				if(fw != null)
d1870 2
a1871 1
					if(fw.IsStatic == isstatic)
d1873 4
a1876 1
						return fw.Cookie;
d2891 8
a2898 2
					// TODO this won't work when we're putting the JNI methods in jniproxy.dll
					FieldInfo fi = wrapper.TypeAsTBD.GetField(JNI.METHOD_PTR_FIELD_PREFIX + StringFromUTF8(methods[i].name) + StringFromUTF8(methods[i].signature).Replace('/', '.') + ">", BindingFlags.Static | BindingFlags.NonPublic);
d3164 2
a3165 1
					if(!GlobalRefs.weakRefs[i].IsAllocated)
@


1.23
log
@*** empty log message ***
@
text
@d82 1
d85 5
d94 1
a94 1
			if(pInitArgs->version != JNIEnv.JNI_VERSION_1_2)
a385 21
		private static MethodBase FindCaller()
		{
			StackTrace st = new StackTrace();
			for(int i = 0; i < st.FrameCount; i++)
			{
				StackFrame frame = st.GetFrame(i);
				Type type = frame.GetMethod().DeclaringType;
				if(type != null && type.Assembly != typeof(JniHelper).Assembly)
				{
					// TODO we need a more robust algorithm to find the "caller" (note that in addition to native methods,
					// System.loadLibrary can also trigger executing native code)
					ClassLoaderWrapper loader = ClassLoaderWrapper.GetWrapperFromType(type).GetClassLoader();
					if(loader.GetJavaClassLoader() != null)
					{
						return frame.GetMethod();
					}
				}
			}
			return null;
		}

d389 1
a389 1
		internal unsafe static int LoadLibrary(string filename)
a390 11
			MethodBase m = FindCaller();
			ClassLoaderWrapper loader;
			if(m != null)
			{
				loader = ClassLoaderWrapper.GetWrapperFromType(m.DeclaringType).GetClassLoader();
			}
			else
			{
				loader = ClassLoaderWrapper.GetBootstrapClassLoader();
				m = MethodBase.GetCurrentMethod();
			}
d421 1
a421 1
						if(!JavaVM.IsSupportedJniVersion(version))
d899 5
d905 1
a905 1
			return JNIEnv.JNI_ERR;
d917 1
a917 1
				if(pAttachArgs->version != JNIEnv.JNI_VERSION_1_2)
d932 1
d937 8
a944 1
					System.Threading.Thread.CurrentThread.Name = new String(pAttachArgs->name);
d950 1
a950 3
					// TODO instead of using a thread data slot to communicate the thread group, we should probably use
					// another mechanism, this is probably a security issue.
					System.Threading.Thread.SetData(System.Threading.Thread.GetNamedDataSlot("ikvm-thread-group"), threadGroup);
a952 1
			System.Threading.Thread.CurrentThread.IsBackground = asDaemon;
d961 2
a962 1
				return JNIEnv.JNI_EDETACHED;
a969 5
		internal static bool IsSupportedJniVersion(jint version)
		{
			return version == JNIEnv.JNI_VERSION_1_1 || version == JNIEnv.JNI_VERSION_1_2 || version == JNIEnv.JNI_VERSION_1_4;
		}

d972 1
a972 1
			if(IsSupportedJniVersion(version))
d996 2
d1240 1
a1240 1
		internal static jclass FindClass(JNIEnv* pEnv, byte* name)
d1244 13
a1256 1
				TypeWrapper wrapper = FindNativeMethodClassLoader(pEnv).LoadClassByDottedName(new String((sbyte*)name).Replace('/', '.'));
a1261 5
			catch(RetargetableJavaException x)
			{
				SetPendingException(pEnv, x.ToJava());
				return IntPtr.Zero;
			}
d1264 8
d1415 9
a1423 2
				// we can't use capacity, because the array length must be a power of two
				localRefs[pEnv->localRefSlot] = new object[LOCAL_REF_BUCKET_SIZE];
d1607 1
a1607 1
				if(x.GetType() == ClassLoaderWrapper.LoadClassCritical("java.lang.reflect.InvocationTargetException").TypeAsExceptionType)
d1628 2
d1689 1
a1689 1
				return (jbyte)(sbyte)o;
d1779 1
a1779 1
				return (jbyte)(sbyte)o;
a1859 1
						// TODO fw.Link()
d1919 1
a1919 1
			return (jbyte)(sbyte)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d1964 1
a1964 1
			SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (sbyte)val);
d2022 1
a2022 1
				return (jbyte)(sbyte)o;
d2109 1
a2109 1
			return (jbyte)(sbyte)GetFieldValue(fieldID, null);
d2154 1
a2154 1
			SetFieldValue(fieldID, null, (sbyte)val);
d2336 1
a2336 1
				return pEnv->MakeLocalRef(new sbyte[len]);
d2440 1
a2440 1
			sbyte[] b = (sbyte[])pEnv->UnwrapRef(array);
d2545 1
a2545 1
				sbyte[] b = (sbyte[])pEnv->UnwrapRef(array);
d2548 1
a2548 1
					b[i] = (sbyte)elems[i];
d2656 2
a2657 2
				sbyte[] b = (sbyte[])pEnv->UnwrapRef(array);
				sbyte* p = (sbyte*)(void*)buf;
d2768 2
a2769 2
				sbyte[] b = (sbyte[])pEnv->UnwrapRef(array);
				sbyte* p = (sbyte*)(void*)buf;
d3031 1
a3031 1
			if(type == typeof(sbyte) || type == typeof(bool))
d3035 1
a3035 1
			else if(type == typeof(short) || type == typeof(char))
d3039 1
a3039 1
			else if(type == typeof(int) || type == typeof(float))
d3043 1
a3043 1
			else if(type == typeof(long) || type == typeof(double))
d3057 1
d3087 1
d3175 1
a3175 1
		internal static sbyte ExceptionCheck(JNIEnv* pEnv)
@


1.22
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d156 13
d444 1
a444 1
						f.Enter(m.MethodHandle);
d446 1
a446 1
						f.Leave();
d1035 1
d1050 1
d1069 1
d1251 4
@


1.21
log
@*** empty log message ***
@
text
@d1320 1
a1320 1
			MethodWrapper mw = wrapper.GetMethodWrapper(new MethodDescriptor("<init>", "(Ljava.lang.String;)V"), false);
d1616 1
a1616 2
				MethodDescriptor md = new MethodDescriptor(StringFromUTF8(name), StringFromUTF8(sig).Replace('/', '.'));
				MethodWrapper mw = wrapper.GetMethodWrapper(md, true);
d1625 1
a1625 1
				SetPendingException(pEnv, JavaException.NoSuchMethodError("{0}{1}", md.Name, md.Signature));
d2905 1
a2905 1
				ByteCodeHelper.monitorenter(pEnv->UnwrapRef(obj));
@


1.20
log
@*** empty log message ***
@
text
@d1246 6
a1251 1
				return pEnv->MakeLocalRef(IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(wrapper));
d1273 1
a1273 1
			object clazz = IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(mw.DeclaringType);
d1287 1
a1287 1
			return pEnv->MakeLocalRef(wrapper == null ? null : IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(wrapper));
d1300 1
a1300 1
			object clazz = IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(fw.DeclaringType);
d1331 5
d1505 5
d1628 4
d1841 4
d2862 5
d2890 5
@


1.19
log
@*** empty log message ***
@
text
@d1193 1
a1193 1
				return pEnv->MakeLocalRef(IKVM.NativeCode.java.lang.VMClassLoader.defineClass(pEnv->UnwrapRef(loader), name != null ? new String((sbyte*)name) : null, buf, 0, buf.Length, null));
@


1.18
log
@*** empty log message ***
@
text
@a353 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_LoadLibrary@@4")]
a355 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_FreeLibrary@@4")]
a357 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_GetProcAddress@@12")]
a359 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_CallOnLoad@@12")]
a361 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_GetJNIEnvVTable@@0")]
a363 1
		//[DllImport("ikvm-native", EntryPoint="_ikvm_MarshalDelegate@@4")]
@


1.17
log
@*** empty log message ***
@
text
@a117 2
			// HACK make sure the Java library is loaded
			Assembly.Load("IKVM.GNU.Classpath");
@


1.16
log
@*** empty log message ***
@
text
@d920 1
a920 3
			// LIBREFLECT
			TypeWrapper vmthread = ClassLoaderWrapper.LoadClassCritical("java.lang.VMThread");
			vmthread.GetMethodWrapper(new MethodDescriptor("jniWaitUntilLastThread", "()V"), false).Invoke(null, new object[0], false);
d976 1
a976 3
			// LIBREFLECT
			TypeWrapper vmthread = ClassLoaderWrapper.LoadClassCritical("java.lang.VMThread");
			vmthread.GetMethodWrapper(new MethodDescriptor("jniDetach", "()V"), false).Invoke(null, new object[0], false);
d1265 1
a1265 3
			object methodObj = pEnv->UnwrapRef(method);
			MethodWrapper mw = (MethodWrapper)methodObj.GetType().GetField("methodCookie", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(methodObj);
			return mw.Cookie;
d1270 1
a1270 3
			object fieldObj = pEnv->UnwrapRef(field);
			FieldWrapper fw = (FieldWrapper)fieldObj.GetType().GetField("fieldCookie", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(fieldObj);
			return fw.Cookie;
d1276 1
a1276 1
			TypeWrapper tw;
d1279 1
a1279 2
				// LIBREFLECT
				tw = ClassLoaderWrapper.LoadClassCritical("java.lang.reflect.Constructor");
d1283 1
a1283 2
				// LIBREFLECT
				tw = ClassLoaderWrapper.LoadClassCritical("java.lang.reflect.Method");
a1284 2
			object clazz = IKVM.NativeCode.java.lang.VMClass.getClassFromWrapper(mw.DeclaringType);
			return pEnv->MakeLocalRef(Activator.CreateInstance(tw.TypeAsTBD, new object[] { clazz, mw }));
a1302 2
			// LIBREFLECT
			TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical("java.lang.reflect.Field");
d1304 1
a1304 1
			return pEnv->MakeLocalRef(Activator.CreateInstance(tw.TypeAsTBD, new object[] { clazz, fw }));
d1310 1
a1310 1
			pEnv->pendingException = x == null ? IntPtr.Zero : pEnv->MakeLocalRef(ExceptionHelper.MapExceptionFast(x));
d1362 1
a1362 1
					ExceptionHelper.printStackTrace(x);
d1580 1
a1580 1
				SetPendingException(pEnv, ExceptionHelper.MapExceptionFast(x));
d3138 1
a3138 4
				// LIBREFLECT
				TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical("java.nio.VMDirectByteBuffer");
				MethodWrapper mw = tw.GetMethodWrapper(new MethodDescriptor("NewDirectByteBuffer", "(Lcli.System.IntPtr;I)Ljava.nio.ByteBuffer;"), false);
				return pEnv->MakeLocalRef(mw.Invoke(null, new object[] { address, (int)capacity }, false));
d3142 1
a3142 1
				SetPendingException(pEnv, ExceptionHelper.MapExceptionFast(x));
d3151 1
a3151 4
				// LIBREFLECT
				TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical("java.nio.VMDirectByteBuffer");
				MethodWrapper mw = tw.GetMethodWrapper(new MethodDescriptor("GetDirectBufferAddress", "(Ljava.nio.ByteBuffer;)Lcli.System.IntPtr;"), false);
				return (IntPtr)mw.Invoke(null, new object[] { pEnv->UnwrapRef(buf) }, false);
d3155 1
a3155 1
				SetPendingException(pEnv, ExceptionHelper.MapExceptionFast(x));
d3164 1
a3164 4
				// LIBREFLECT
				TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical("java.nio.Buffer");
				MethodWrapper mw = tw.GetMethodWrapper(new MethodDescriptor("capacity", "()I"), false);
				return (jlong)(long)(int)mw.Invoke(pEnv->UnwrapRef(buf), new object[0], false);
d3168 1
a3168 1
				SetPendingException(pEnv, ExceptionHelper.MapExceptionFast(x));
@


1.15
log
@*** empty log message ***
@
text
@d920 1
d978 1
d1287 1
d1292 1
d1315 1
d1376 1
a1376 3
					MethodWrapper mw = ClassLoaderWrapper.LoadClassCritical("java.lang.Throwable").GetMethodWrapper(new MethodDescriptor("printStackTrace", "()V"), false);
					// Sun always prints 'Exception in thread "..." '
					mw.Invoke(x, new object[0], false);
d2932 1
a2932 1
					SetPendingException(pEnv, JavaException.StringIndexOutOfBoundsException(""));
d2959 1
a2959 1
					SetPendingException(pEnv, JavaException.StringIndexOutOfBoundsException(""));
d3152 1
d3168 1
d3184 1
@


1.14
log
@*** empty log message ***
@
text
@d2847 2
a2848 1
					FieldInfo fi = wrapper.TypeAsTBD.GetField("jniptr/" + StringFromUTF8(methods[i].name) + StringFromUTF8(methods[i].signature).Replace('/', '.'), BindingFlags.Static | BindingFlags.NonPublic);
d2871 1
@


1.13
log
@*** empty log message ***
@
text
@d82 1
d544 2
d866 3
a868 3
			new pf_void(JNIEnv.NotImplemented), //virtual jobject JNICALL NewDirectByteBuffer(void* address, jlong capacity);
			new pf_void(JNIEnv.NotImplemented), //virtual void* JNICALL GetDirectBufferAddress(jobject buf);
			new pf_void(JNIEnv.NotImplemented)  //virtual jlong JNICALL GetDirectBufferCapacity(jobject buf);
d2872 1
a2872 1
					if(fi.Name.StartsWith("jniptr/"))
d3138 1
a3138 1
		internal static void NotImplemented(JNIEnv* pEnv)
d3140 46
a3185 1
			JVM.CriticalFailure("Unimplemented JNIEnv function called", null);
@


1.12
log
@*** empty log message ***
@
text
@d95 1
a95 1
			StringDictionary props = new StringDictionary();
d1503 1
a1503 1
				if(wrapper.IsInterface || wrapper.IsAbstract)
d1600 1
a1600 1
			return pEnv->MakeLocalRef(IKVM.NativeCode.java.lang.VMClass.getClassFromType(pEnv->UnwrapRef(obj).GetType()));
d1605 1
a1605 1
			object objClass = IKVM.NativeCode.java.lang.VMClass.getClassFromType(pEnv->UnwrapRef(obj).GetType());
@


1.11
log
@*** empty log message ***
@
text
@d381 1
a381 1
				if(type != null)
@


1.10
log
@*** empty log message ***
@
text
@d1827 1
a1827 1
				FieldWrapper fw = wrapper.GetFieldWrapper(StringFromUTF8(name), wrapper.GetClassLoader().ExpressionTypeWrapper(StringFromUTF8(sig).Replace('/', '.')));
d3220 1
@


1.9
log
@*** empty log message ***
@
text
@d1584 4
d2887 1
a2887 1
				System.Threading.Monitor.Enter(pEnv->UnwrapRef(obj));
d2890 1
a2890 1
			catch(System.Threading.ThreadInterruptedException)
d2892 1
a2892 1
				SetPendingException(pEnv, JavaException.InterruptedException());
d2904 1
a2904 1
			catch(System.Threading.SynchronizationLockException)
d2906 1
a2906 1
				SetPendingException(pEnv, JavaException.IllegalMonitorStateException());
@


1.8
log
@*** empty log message ***
@
text
@d26 1
d95 1
a95 1
			Hashtable props = new Hashtable();
d118 1
a118 1
			Assembly javalib = Assembly.Load("IKVM.GNU.Classpath");
d120 1
a120 4
			// HACK poke the properties into a special field in VMRuntime, so that they are copied into the
			// defaultProperties collection.
			Type vmruntime = javalib.GetType("java.lang.VMRuntime");
			vmruntime.GetField("props", BindingFlags.NonPublic | BindingFlags.Static).SetValue(null, props);
d1050 1
a1050 1
			System.Threading.Thread.SetData(cleanupHelperDataSlot, new JNIEnvCleanupHelper(pJNIEnv));
@


1.7
log
@*** empty log message ***
@
text
@d30 1
d60 1
a60 1
sealed class JniHelper
d62 15
a76 18
	//[DllImport("ikvm-native", EntryPoint="_ikvm_LoadLibrary@@4")]
	[DllImport("ikvm-native")]
	private static extern IntPtr ikvm_LoadLibrary(string filename);
	//[DllImport("ikvm-native", EntryPoint="_ikvm_FreeLibrary@@4")]
	[DllImport("ikvm-native")]
	private static extern void ikvm_FreeLibrary(IntPtr handle);
	//[DllImport("ikvm-native", EntryPoint="_ikvm_GetProcAddress@@12")]
	[DllImport("ikvm-native")]
	internal static extern IntPtr ikvm_GetProcAddress(IntPtr handle, string name, int argc);
	//[DllImport("ikvm-native", EntryPoint="_ikvm_CallOnLoad@@12")]
	[DllImport("ikvm-native")]
	private unsafe static extern int ikvm_CallOnLoad(IntPtr method, void* jvm, void* reserved);
	//[DllImport("ikvm-native", EntryPoint="_ikvm_GetJNIEnvVTable@@0")]
	[DllImport("ikvm-native")]
	internal unsafe static extern void** ikvm_GetJNIEnvVTable();
	//[DllImport("ikvm-native", EntryPoint="_ikvm_MarshalDelegate@@4")]
	[DllImport("ikvm-native")]
	internal unsafe static extern void* ikvm_MarshalDelegate(Delegate d);
d78 1
a78 1
	private static MethodBase FindCaller()
d80 3
a82 2
		StackTrace st = new StackTrace();
		for(int i = 0; i < st.FrameCount; i++)
d84 3
a86 3
			StackFrame frame = st.GetFrame(i);
			Type type = frame.GetMethod().DeclaringType;
			if(type != null)
d88 20
a107 4
				// TODO we need a more robust algorithm to find the "caller" (note that in addition to native methods,
				// System.loadLibrary can also trigger executing native code)
				ClassLoaderWrapper loader = ClassLoaderWrapper.GetWrapperFromType(type).GetClassLoader();
				if(loader.GetJavaClassLoader() != null)
d109 5
a113 1
					return frame.GetMethod();
d116 10
a126 5
		return null;
	}

	private static ArrayList nativeLibraries = new ArrayList();
	internal static readonly object JniLock = new object();
d128 1
a128 5
	internal unsafe static int LoadLibrary(string filename)
	{
		MethodBase m = FindCaller();
		ClassLoaderWrapper loader;
		if(m != null)
d130 2
a131 1
			loader = ClassLoaderWrapper.GetWrapperFromType(m.DeclaringType).GetClassLoader();
d133 2
a134 1
		else
d136 13
a148 2
			loader = ClassLoaderWrapper.GetBootstrapClassLoader();
			m = MethodBase.GetCurrentMethod();
d150 2
a151 1
		lock(JniLock)
d153 7
a159 2
			IntPtr p = ikvm_LoadLibrary(filename);
			if(p == IntPtr.Zero)
d161 23
a183 1
				return 0;
d185 2
a186 1
			try
d188 5
a192 1
				foreach(IntPtr tmp in loader.GetNativeLibraries())
d194 1
a194 1
					if(tmp == p)
d196 9
a204 4
						// the library was already loaded by the current class loader,
						// no need to do anything
						ikvm_FreeLibrary(p);
						return 1;
d206 1
d208 1
a208 1
				if(nativeLibraries.Contains(p))
d210 1
a210 1
					throw JavaException.UnsatisfiedLinkError("Native library {0} already loaded in another classloader", filename);
d212 85
a296 2
				IntPtr onload = ikvm_GetProcAddress(p, "JNI_OnLoad", IntPtr.Size * 2);
				if(onload != IntPtr.Zero)
d298 3
a300 5
					JniFrame f = new JniFrame();
					f.Enter(m.MethodHandle);
					int version = ikvm_CallOnLoad(onload, JavaVM.pJavaVM, null);
					f.Leave();
					if(version != JNIEnv.JNI_VERSION_1_1 && version != JNIEnv.JNI_VERSION_1_2 && version != JNIEnv.JNI_VERSION_1_4)
d302 10
a311 1
						throw JavaException.UnsatisfiedLinkError("Unsupported JNI version 0x{0:X} required by {1}", version, filename);
d314 32
a345 3
				nativeLibraries.Add(p);
				loader.RegisterNativeLibrary(p);
				return 1;
d347 2
a348 1
			catch
d350 1
a350 2
				ikvm_FreeLibrary(p);
				throw;
a353 1
}
d355 20
a374 6
class GlobalRefs
{
	internal static System.Collections.ArrayList globalRefs = new System.Collections.ArrayList();
	internal static readonly object weakRefLock = new object();
	internal static GCHandle[] weakRefs = new GCHandle[16];
}
d376 20
a395 77
unsafe class VtableBuilder
{
	delegate int pf_int_IntPtr(JNIEnv* pEnv, IntPtr p);
	delegate IntPtr pf_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p);
	delegate void pf_void_IntPtr(JNIEnv* pEnv, IntPtr p);
	delegate IntPtr pf_IntPtr(JNIEnv* pEnv);
	delegate void pf_void(JNIEnv* pEnv);
	delegate sbyte pf_sbyte(JNIEnv* pEnv);
	delegate IntPtr pf_IntPtr_pbyte(JNIEnv* pEnv, byte* p);
	delegate int pf_int(JNIEnv* pEnv);
	delegate IntPtr pf_IntPtr_pbyte_IntPtr_psbyte_IntPtr(JNIEnv* pEnv, byte* p1, IntPtr p2, sbyte* p3, int p4);
	delegate IntPtr pf_IntPtr_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
	delegate jchar* pf_pjchar_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
	delegate int pf_int_IntPtr_pbyte(JNIEnv* pEnv, IntPtr p1, byte* p2);
	delegate void pf_void_pbyte(JNIEnv* pEnv, byte* p1);
	delegate IntPtr pf_IntPtr_IntPtr_pbyte_pbyte(JNIEnv* pEnv, IntPtr p1, byte* p2, byte* p3);
	delegate int pf_int_IntPtr_pJNINativeMethod_int(JNIEnv* pEnv, IntPtr p1, JNIEnv.JNINativeMethod* p2, int p3);
	delegate int pf_int_ppJavaVM(JNIEnv* pEnv, JavaVM** ppJavaVM);
	delegate sbyte pf_sbyte_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
	delegate short pf_short_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
	delegate ushort pf_ushort_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
	delegate int pf_int_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
	delegate long pf_long_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
	delegate float pf_float_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
	delegate double pf_double_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
	delegate void pf_void_IntPtr_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3);
	delegate void pf_void_IntPtr_IntPtr_sbyte(JNIEnv* pEnv, IntPtr p1, IntPtr p2, sbyte p3);
	delegate void pf_void_IntPtr_IntPtr_short(JNIEnv* pEnv, IntPtr p1, IntPtr p2, short p3);
	delegate void pf_void_IntPtr_IntPtr_ushort(JNIEnv* pEnv, IntPtr p1, IntPtr p2, ushort p3);
	delegate void pf_void_IntPtr_IntPtr_int(JNIEnv* pEnv, IntPtr p1, IntPtr p2, int p3);
	delegate void pf_void_IntPtr_IntPtr_long(JNIEnv* pEnv, IntPtr p1, IntPtr p2, long p3);
	delegate void pf_void_IntPtr_IntPtr_float(JNIEnv* pEnv, IntPtr p1, IntPtr p2, float p3);
	delegate void pf_void_IntPtr_IntPtr_double(JNIEnv* pEnv, IntPtr p1, IntPtr p2, double p3);
	delegate IntPtr pf_IntPtr_pjchar_int(JNIEnv* pEnv, jchar* p1, int p2);
	delegate void pf_void_IntPtr_IntPtr(JNIEnv* pEnv, IntPtr p1, IntPtr p2);
	delegate void pf_void_IntPtr_pjchar(JNIEnv* pEnv, IntPtr p1, jchar* p2);
	delegate IntPtr pf_IntPtr_int_IntPtr_IntPtr(JNIEnv* pEnv, int p1, IntPtr p2, IntPtr p3);
	delegate IntPtr pf_IntPtr_IntPtr_int(JNIEnv* pEnv, IntPtr p1, int p2);
	delegate void pf_void_IntPtr_int_IntPtr(JNIEnv* pEnv, IntPtr p1, int p2, IntPtr p3);
	delegate IntPtr pf_IntPtr_int(JNIEnv* pEnv, int p1);
	delegate void pf_void_IntPtr_int_int_IntPtr(JNIEnv* pEnv, IntPtr p1, int p2, int p3, IntPtr p4);
	delegate IntPtr pf_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
	delegate sbyte pf_sbyte_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
	delegate short pf_short_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
	delegate ushort pf_ushort_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
	delegate int pf_int_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
	delegate long pf_long_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
	delegate float pf_float_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
	delegate double pf_double_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
	delegate void pf_void_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, JNIEnv.jvalue* p3);
	delegate IntPtr pf_IntPtr_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
	delegate sbyte pf_sbyte_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
	delegate ushort pf_ushort_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
	delegate short pf_short_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
	delegate int pf_int_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
	delegate long pf_long_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
	delegate float pf_float_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
	delegate double pf_double_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
	delegate void pf_void_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv* pEnv, IntPtr p1, IntPtr p2, IntPtr p3, JNIEnv.jvalue* p4);
	delegate byte* pf_pbyte_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
	delegate void pf_void_IntPtr_pbyte(JNIEnv* pEnv, IntPtr p1, byte* p2);
	delegate jboolean* pf_pjboolean_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
	delegate jbyte* pf_pjbyte_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
	delegate jshort* pf_pjshort_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
	delegate jint* pf_pjint_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
	delegate jlong* pf_pjlong_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
	delegate jfloat* pf_pjfloat_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
	delegate jdouble* pf_pjdouble_IntPtr_pjboolean(JNIEnv* pEnv, IntPtr p1, jboolean* p2);
	delegate void pf_void_IntPtr_pjboolean_int(JNIEnv* pEnv, IntPtr p1, jboolean* p2, int p3);
	delegate void pf_void_IntPtr_pjbyte_int(JNIEnv* pEnv, IntPtr p1, jbyte* p2, int p3);
	delegate void pf_void_IntPtr_pjchar_int(JNIEnv* pEnv, IntPtr p1, jchar* p2, int p3);
	delegate void pf_void_IntPtr_pjshort_int(JNIEnv* pEnv, IntPtr p1, jshort* p2, int p3);
	delegate void pf_void_IntPtr_pjint_int(JNIEnv* pEnv, IntPtr p1, jint* p2, int p3);
	delegate void pf_void_IntPtr_pjlong_int(JNIEnv* pEnv, IntPtr p1, jlong* p2, int p3);
	delegate void pf_void_IntPtr_pjfloat_int(JNIEnv* pEnv, IntPtr p1, jfloat* p2, int p3);
	delegate void pf_void_IntPtr_pjdouble_int(JNIEnv* pEnv, IntPtr p1, jdouble* p2, int p3);
	delegate int pf_int_int(JNIEnv* pEnv, int p1);
d397 2
a398 1
	internal static void* vtable;
d400 1
a400 6
	static VtableBuilder()
	{
		// JNIEnv
		void** pmcpp = JniHelper.ikvm_GetJNIEnvVTable();
		void** p = (void**)JniMem.Alloc(IntPtr.Size * vtableDelegates.Length);
		for(int i = 0; i < vtableDelegates.Length; i++)
d402 3
a404 1
			if(vtableDelegates[i] != null)
d406 1
a406 1
				p[i] = JniHelper.ikvm_MarshalDelegate(vtableDelegates[i]);
d410 47
a456 1
				p[i] = pmcpp[i];
a458 1
		vtable = p;
d461 107
a567 1
	static Delegate[] vtableDelegates =
d869 9
a877 1
}
d879 9
a887 9
[StructLayout(LayoutKind.Sequential)]
unsafe struct JavaVM
{
	internal static JavaVM* pJavaVM;
	void** vtable;
	void* firstVtableEntry;
	delegate int pf_int(JavaVM* pJVM);
	delegate int pf_int_ppvoid_pvoid(JavaVM* pJVM, void** p1, void* p2);
	delegate int pf_int_ppvoid_int(JavaVM* pJVM, void** p1, int p2);
d889 1
a889 1
	static Delegate[] vtableDelegates =
d901 4
a904 3
	static JavaVM()
	{
		pJavaVM = (JavaVM*)(void*)JniMem.Alloc(IntPtr.Size * (1 + vtableDelegates.Length));
d909 1
a909 1
		pJavaVM->vtable = &pJavaVM->firstVtableEntry;
d911 4
a914 21
		for(int i = 0; i < vtableDelegates.Length; i++)
		{
			pJavaVM->vtable[i] = JniHelper.ikvm_MarshalDelegate(vtableDelegates[i]);
		}
	}

	internal static int DestroyJavaVM(JavaVM* pJVM)
	{
		return JNIEnv.JNI_ERR;
	}

	internal static int AttachCurrentThread(JavaVM* pJVM, void **penv, void *args)
	{
		// TODO do we need a new local ref frame?
		// TODO for now we only support attaching to an existing thread
		// TODO support args (JavaVMAttachArgs)
		JNIEnv* p = TlsHack.pJNIEnv;
		if(p != null)
		{
			*penv = p;
			return JNIEnv.JNI_OK;
a915 9
		JVM.CriticalFailure("AttachCurrentThread for non-Java threads not implemented", null);
		return JNIEnv.JNI_ERR;
	}

	internal static int DetachCurrentThread(JavaVM* pJVM)
	{
		JVM.CriticalFailure("DetachCurrentThread not implemented", null);
		return JNIEnv.JNI_ERR;
	}
d917 1
a917 5
	internal static int GetEnv(JavaVM* pJVM, void **penv, int version)
	{
		// TODO we should check the version
		JNIEnv* p = TlsHack.pJNIEnv;
		if(p != null)
d919 3
a921 2
			*penv = p;
			return JNIEnv.JNI_OK;
a922 2
		return JNIEnv.JNI_EDETACHED;
	}
d924 1
a924 7
	internal static int AttachCurrentThreadAsDaemon(JavaVM* pJVM, void **penv, void *args)
	{
		// TODO do we need a new local ref frame?
		// TODO for now we only support attaching to an existing thread
		// TODO support args (JavaVMAttachArgs)
		JNIEnv* p = TlsHack.pJNIEnv;
		if(p != null)
d926 1
a926 68
			*penv = p;
			return JNIEnv.JNI_OK;
		}
		JVM.CriticalFailure("AttachCurrentThreadAsDaemon not implemented", null);
		return JNIEnv.JNI_ERR;
	}
}

[StructLayout(LayoutKind.Sequential)]
unsafe struct JNIEnv
{
	internal const int LOCAL_REF_SHIFT = 10;
	internal const int LOCAL_REF_BUCKET_SIZE = (1 << LOCAL_REF_SHIFT);
	internal const int LOCAL_REF_MASK = (LOCAL_REF_BUCKET_SIZE - 1);
	internal const int JNI_OK = 0;
	internal const int JNI_ERR = -1;
	internal const int JNI_EDETACHED = -2;
	internal const int JNI_EVERSION = -3;
	internal const int JNI_COMMIT = 1;
	internal const int JNI_ABORT = 2;
	internal const int JNI_VERSION_1_1 = 0x00010001;
	internal const int JNI_VERSION_1_2 = 0x00010002;
	internal const int JNI_VERSION_1_4 = 0x00010004;
	internal const sbyte JNI_TRUE = 1;
	internal const sbyte JNI_FALSE = 0;
	internal void* vtable;
	internal GCHandle localRefs;
	internal int localRefSlot;
	internal IntPtr pendingException;

	private static string StringFromUTF8(byte* psz)
	{
		// Sun's modified UTF8 encoding is not compatible with System.Text.Encoding.UTF8,
		// so we need to roll our own
		int len = 0;
		bool hasNonAscii = false;
		while(psz[len] != 0)
		{
			hasNonAscii |= psz[len] >= 128;
			len++;
		}
		if(!hasNonAscii)
		{
			// optimize the common case of 7-bit ASCII
			return new String((sbyte*)psz);
		}
		StringBuilder sb = new StringBuilder(len);
		for(int i = 0; i < len; i++)
		{
			int c = *psz++;
			int char2, char3;
			switch(c >> 4)
			{
				case 12:
				case 13:
					char2 = *psz++;
					i++;
					c = (((c & 0x1F) << 6) | (char2 & 0x3F));
					break;
				case 14:
					char2 = *psz++;
					char3 = *psz++;
					i++;
					i++;
					c = ((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | (char3 & 0x3F);
					break;
			}
			sb.Append((char)c);
a927 2
		return sb.ToString();
	}
d929 1
a929 4
	private static int StringUTF8Length(string s)
	{
		int len = 0;
		for(int i = 0; i < s.Length; i++)
d931 1
a931 2
			char ch = s[i];
			if((ch != 0) && (ch <= 0x7F))
d933 5
a937 1
				len++;
d939 2
a940 1
			else if(ch <= 0x7FF)
d942 2
a943 1
				len += 2;
d945 4
a948 1
			else
d950 12
a961 1
				len += 3;
d963 3
a966 2
		return len;
	}
d968 1
a968 8
	// this method returns a simplified method argument descriptor.
	// some examples:
	// "()V" -> ""
	// "(ILjava.lang.String;)I" -> "IL"
	// "([Ljava.lang.String;)V" -> "L"
	private static string GetMethodArgList(IntPtr cookie)
	{
		try
d970 1
a970 3
			StringBuilder sb = new StringBuilder();
			string s = MethodWrapper.FromCookie(cookie).Signature;
			for(int i = 1;; i++)
d972 1
a972 20
				switch(s[i])
				{
					case '[':
						while(s[i] == '[') i++;
						if(s[i] == 'L')
						{
							while(s[i] != ';') i++;
						}
						sb.Append('L');
						break;
					case 'L':
						while(s[i] != ';') i++;
						sb.Append('L');
						break;
					case ')':
						return sb.ToString();
					default:
						sb.Append(s[i]);
						break;
				}
d974 5
a979 6
		catch
		{
			Debug.Assert(false);
			throw;
		}
	}
d981 1
a981 4
	internal static jint GetMethodArgs(JNIEnv* pEnv, IntPtr method, byte* sig)
	{
		string s = GetMethodArgList(method);
		for(int i = 0; i < s.Length; i++)
d983 1
a983 1
			sig[i] = (byte)s[i];
a984 15
		return s.Length;
	}

	internal static jint GetVersion(JNIEnv* pEnv)
	{
		return JNI_VERSION_1_4;
	}

	internal static jclass DefineClass(JNIEnv* pEnv, byte* name, jobject loader, jbyte* pbuf, jint length)
	{
		byte[] buf = new byte[length];
		Marshal.Copy((IntPtr)(void*)pbuf, buf, 0, length);
		// TODO what should the protection domain be?
		return pEnv->MakeLocalRef(NativeCode.java.lang.VMClassLoader.defineClass(pEnv->UnwrapRef(loader), StringFromUTF8(name), buf, 0, buf.Length, null));
	}
d986 1
a986 4
	private static ClassLoaderWrapper FindNativeMethodClassLoader()
	{
		StackTrace st = new StackTrace();
		for(int i = 0; i < st.FrameCount; i++)
d988 1
a988 3
			StackFrame frame = st.GetFrame(i);
			Type type = frame.GetMethod().DeclaringType;
			if(type != null)
d990 2
a991 4
				// TODO we need a more robust algorithm to find the "caller" (note that in addition to native methods,
				// System.loadLibrary can also trigger executing native code)
				ClassLoaderWrapper loader = ClassLoaderWrapper.GetWrapperFromType(type).GetClassLoader();
				if(loader.GetJavaClassLoader() != null)
d993 2
a994 1
					return loader;
d996 2
d999 2
a1001 3
		// TODO instead of using the bootstrap class loader, we need to use the system (aka application) class loader
		return ClassLoaderWrapper.GetBootstrapClassLoader();
	}
d1003 1
a1003 3
	internal static jclass FindClass(JNIEnv* pEnv, byte* name)
	{
		try
d1005 1
a1005 9
			TypeWrapper wrapper = FindNativeMethodClassLoader().LoadClassByDottedName(StringFromUTF8(name).Replace('/', '.'));
			// TODO is this needed?
			wrapper.Finish();
			return pEnv->MakeLocalRef(NativeCode.java.lang.VMClass.getClassFromWrapper(wrapper));
		}
		catch(Exception x)
		{
			SetPendingException(pEnv, x);
			return IntPtr.Zero;
d1009 2
a1010 1
	internal static jmethodID FromReflectedMethod(JNIEnv* pEnv, jobject method)
d1012 20
a1031 11
		object methodObj = pEnv->UnwrapRef(method);
		MethodWrapper mw = (MethodWrapper)methodObj.GetType().GetField("methodCookie", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(methodObj);
		return mw.Cookie;
	}

	internal static jfieldID FromReflectedField(JNIEnv* pEnv, jobject field)
	{
		object fieldObj = pEnv->UnwrapRef(field);
		FieldWrapper fw = (FieldWrapper)fieldObj.GetType().GetField("fieldCookie", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(fieldObj);
		return fw.Cookie;
	}
d1033 1
a1033 9
	internal static jobject ToReflectedMethod(JNIEnv* pEnv, jclass clazz_ignored, jmethodID method)
	{
		MethodWrapper mw = MethodWrapper.FromCookie(method);
		TypeWrapper tw;
		if(mw.Name == "<init>")
		{
			tw = ClassLoaderWrapper.LoadClassCritical("java.lang.reflect.Constructor");
		}
		else
d1035 1
a1035 11
			tw = ClassLoaderWrapper.LoadClassCritical("java.lang.reflect.Method");
		}
		object clazz = NativeCode.java.lang.VMClass.getClassFromWrapper(mw.DeclaringType);
		return pEnv->MakeLocalRef(Activator.CreateInstance(tw.TypeAsTBD, new object[] { clazz, mw }));
	}

	internal static jclass GetSuperclass(JNIEnv* pEnv, jclass sub)
	{
		TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(sub)).BaseTypeWrapper;
		return pEnv->MakeLocalRef(wrapper == null ? null : NativeCode.java.lang.VMClass.getClassFromWrapper(wrapper));
	}
d1037 1
a1037 37
	internal static jboolean IsAssignableFrom(JNIEnv* pEnv, jclass sub, jclass super)
	{
		TypeWrapper w1 = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(sub));
		TypeWrapper w2 = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(super));
		return w2.IsAssignableTo(w1) ? JNI_TRUE : JNI_FALSE;
	}

	internal static jobject ToReflectedField(JNIEnv* pEnv, jclass clazz_ignored, jfieldID field)
	{
		FieldWrapper fw = FieldWrapper.FromCookie(field);
		TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical("java.lang.reflect.Field");
		object clazz = NativeCode.java.lang.VMClass.getClassFromWrapper(fw.DeclaringType);
		return pEnv->MakeLocalRef(Activator.CreateInstance(tw.TypeAsTBD, new object[] { clazz, fw }));
	}

	private static void SetPendingException(JNIEnv* pEnv, Exception x)
	{
		DeleteLocalRef(pEnv, pEnv->pendingException);
		pEnv->pendingException = pEnv->MakeLocalRef(x);
	}

	internal static jint Throw(JNIEnv* pEnv, jthrowable throwable)
	{
		DeleteLocalRef(pEnv, pEnv->pendingException);
		pEnv->pendingException = NewLocalRef(pEnv, throwable);
		return JNI_OK;
	}

	internal static jint ThrowNew(JNIEnv* pEnv, jclass clazz, byte* msg)
	{
		TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
		MethodWrapper mw = wrapper.GetMethodWrapper(new MethodDescriptor("<init>", "(Ljava.lang.String;)V"), false);
		if(mw != null)
		{
			jint rc;
			Exception exception;
			try
d1039 1
a1039 3
				wrapper.Finish();
				exception = (Exception)mw.Invoke(null, new object[] { StringFromUTF8(msg) }, false);
				rc = JNI_OK;
d1041 2
a1042 1
			catch(Exception x)
d1044 2
a1045 2
				exception = x;
				rc = JNI_ERR;
a1046 2
			SetPendingException(pEnv, exception);
			return rc;
d1048 2
a1049 1
		else
d1051 13
a1063 2
			SetPendingException(pEnv, JavaException.NoSuchMethodError("<init>(Ljava.lang.String;)V"));
			return JNI_ERR;
a1064 1
	}
d1066 6
a1071 4
	internal static jthrowable ExceptionOccurred(JNIEnv* pEnv)
	{
		return NewLocalRef(pEnv, pEnv->pendingException);
	}
d1073 1
a1073 4
	internal static void ExceptionDescribe(JNIEnv* pEnv)
	{
		Exception x = (Exception)pEnv->UnwrapRef(pEnv->pendingException);
		if(x != null)
d1075 10
a1084 1
			try
d1086 2
a1087 2
				MethodWrapper mw = ClassLoaderWrapper.LoadClassCritical("java.lang.Throwable").GetMethodWrapper(new MethodDescriptor("printStackTrace", "()V"), false);
				mw.Invoke(x, null, false);
d1089 2
a1090 1
			catch(Exception ex)
d1092 19
a1110 1
				Debug.Assert(false, ex.ToString());
d1112 1
a1113 1
	}
d1115 21
a1135 10
	internal static void ExceptionClear(JNIEnv* pEnv)
	{
		DeleteLocalRef(pEnv, pEnv->pendingException);
		pEnv->pendingException = IntPtr.Zero;
	}

	internal static void FatalError(JNIEnv* pEnv, byte* msg)
	{
		JVM.CriticalFailure(StringFromUTF8(msg), null);
	}
d1137 6
a1142 13
	internal static jint PushLocalFrame(JNIEnv* pEnv, jint capacity)
	{
		object[][] localRefs = pEnv->GetLocalRefs();
		pEnv->localRefSlot += 2;
		if(pEnv->localRefSlot >= localRefs.Length)
		{
			object[][] tmp = new object[localRefs.Length * 2][];
			Array.Copy(localRefs, 0, tmp, 0, localRefs.Length);
			pEnv->localRefs.Target = localRefs = tmp;
		}
		// we use a null slot to mark the fact that we used PushLocalFrame
		localRefs[pEnv->localRefSlot - 1] = null;
		if(localRefs[pEnv->localRefSlot] == null)
d1144 33
a1176 2
			// we can't use capacity, because the array length must be a power of two
			localRefs[pEnv->localRefSlot] = new object[LOCAL_REF_BUCKET_SIZE];
a1177 2
		return JNI_OK;
	}
d1179 1
a1179 5
	internal static jobject PopLocalFrame(JNIEnv* pEnv, jobject result)
	{
		object res = pEnv->UnwrapRef(result);
		object[][] localRefs = pEnv->GetLocalRefs();
		while(localRefs[pEnv->localRefSlot] != null)
d1181 6
a1186 2
			localRefs[pEnv->localRefSlot] = null;
			pEnv->localRefSlot--;
a1187 3
		pEnv->localRefSlot--;
		return pEnv->MakeLocalRef(res);
	}
d1189 1
a1189 4
	internal static jobject NewGlobalRef(JNIEnv* pEnv, jobject obj)
	{
		object o = pEnv->UnwrapRef(obj);
		if(o == null)
d1191 1
a1191 1
			return IntPtr.Zero;
d1193 2
a1194 1
		lock(GlobalRefs.globalRefs)
d1196 1
a1196 2
			int index = GlobalRefs.globalRefs.IndexOf(null);
			if(index >= 0)
d1198 5
a1202 1
				GlobalRefs.globalRefs[index] = o;
d1204 1
a1204 1
			else
d1206 2
a1207 1
				index = GlobalRefs.globalRefs.Add(o);
a1208 1
			return (IntPtr)(-(index + 1));
a1209 1
	}
d1211 1
a1211 4
	internal static void DeleteGlobalRef(JNIEnv* pEnv, jobject obj)
	{
		int i = obj.ToInt32();
		if(i < 0)
d1213 1
a1213 1
			lock(GlobalRefs.globalRefs)
d1215 28
a1242 1
				GlobalRefs.globalRefs[(-i) - 1] = null;
d1244 1
a1244 1
			return;
d1246 2
a1247 1
		if(i > 0)
d1249 13
a1261 1
			Debug.Assert(false, "Local ref passed to DeleteGlobalRef");
a1262 1
	}
d1264 6
a1269 4
	internal object[][] GetLocalRefs()
	{
		return (object[][])localRefs.Target;
	}
d1271 1
a1271 4
	internal static void DeleteLocalRef(JNIEnv* pEnv, jobject obj)
	{
		int i = obj.ToInt32();
		if(i > 0)
d1273 3
a1275 3
			object[][] localRefs = pEnv->GetLocalRefs();
			localRefs[i >> LOCAL_REF_SHIFT][i & LOCAL_REF_MASK] = null;
			return;
d1277 2
a1278 1
		if(i < 0)
d1280 12
a1291 1
			Debug.Assert(false, "bogus localref in DeleteLocalRef");
a1292 1
	}
d1294 5
a1298 15
	internal static jboolean IsSameObject(JNIEnv* pEnv, jobject obj1, jobject obj2)
	{
		return pEnv->UnwrapRef(obj1) == pEnv->UnwrapRef(obj2) ? JNI_TRUE : JNI_FALSE;
	}

	internal static jobject NewLocalRef(JNIEnv* pEnv, jobject obj)
	{
		return pEnv->MakeLocalRef(pEnv->UnwrapRef(obj));
	}

	internal static jint EnsureLocalCapacity(JNIEnv* pEnv, jint capacity)
	{
		// since we can dynamically grow the local ref table, we'll just return success for any number
		return JNI_OK;
	}
d1300 1
a1300 3
	internal static jobject AllocObject(JNIEnv* pEnv, jclass clazz)
	{
		try
d1302 3
a1304 4
			TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
			wrapper.Finish();
			// TODO add error handling (e.g. when trying to instantiate an interface or abstract class)
			return pEnv->MakeLocalRef(System.Runtime.Serialization.FormatterServices.GetUninitializedObject(wrapper.TypeAsBaseType));
d1306 2
a1307 1
		catch(Exception x)
d1309 4
a1312 2
			SetPendingException(pEnv, x);
			return IntPtr.Zero;
a1313 1
	}
d1315 1
a1315 61
	[StructLayout(LayoutKind.Explicit)]
		internal struct jvalue
	{
		[FieldOffset(0)]
		public jboolean z;
		[FieldOffset(0)]
		public jbyte b;
		[FieldOffset(0)]
		public jchar c;
		[FieldOffset(0)]
		public jshort s;
		[FieldOffset(0)]
		public jint i;
		[FieldOffset(0)]
		public jlong j;
		[FieldOffset(0)]
		public jfloat f;
		[FieldOffset(0)]
		public jdouble d;
		[FieldOffset(0)]
		public jobject l;
	}

	private static object InvokeHelper(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue *args, bool nonVirtual)
	{
		string sig = GetMethodArgList(methodID);
		object[] argarray = new object[sig.Length];
		for(int i = 0; i < sig.Length; i++)
		{
			switch(sig[i])
			{
				case 'Z':
					argarray[i] = args[i].z != JNI_FALSE;
					break;
				case 'B':
					argarray[i] = args[i].b;
					break;
				case 'C':
					argarray[i] = (char)args[i].c;
					break;
				case 'S':
					argarray[i] = args[i].s;
					break;
				case 'I':
					argarray[i] = args[i].i;
					break;
				case 'J':
					argarray[i] = args[i].j;
					break;
				case 'F':
					argarray[i] = args[i].f;
					break;
				case 'D':
					argarray[i] = args[i].d;
					break;
				case 'L':
					argarray[i] = pEnv->UnwrapRef(args[i].l);
					break;
			}
		}
		try
d1317 2
a1318 1
			return MethodWrapper.FromCookie(methodID).Invoke(pEnv->UnwrapRef(obj), argarray, nonVirtual);
d1320 2
a1321 1
		catch(Exception x)
d1323 3
a1325 2
			SetPendingException(pEnv, ExceptionHelper.MapExceptionFast(x));
			return null;
a1326 11
	}

	internal static jobject NewObjectA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		return pEnv->MakeLocalRef(InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false));
	}

	internal static jclass GetObjectClass(JNIEnv* pEnv, jobject obj)
	{
		return pEnv->MakeLocalRef(NativeCode.java.lang.VMClass.getClassFromType(pEnv->UnwrapRef(obj).GetType()));
	}
d1328 1
a1328 11
	internal static jboolean IsInstanceOf(JNIEnv* pEnv, jobject obj, jclass clazz)
	{
		object objClass = NativeCode.java.lang.VMClass.getClassFromType(pEnv->UnwrapRef(obj).GetType());
		TypeWrapper w1 = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
		TypeWrapper w2 = NativeCode.java.lang.VMClass.getWrapperFromClass(objClass);
		return w2.IsAssignableTo(w1) ? JNI_TRUE : JNI_FALSE;
	}

	private static jmethodID FindMethodID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig, bool isstatic)
	{
		try
d1330 2
a1331 4
			TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
			wrapper.Finish();
			MethodDescriptor md = new MethodDescriptor(StringFromUTF8(name), StringFromUTF8(sig).Replace('/', '.'));
			MethodWrapper mw = wrapper.GetMethodWrapper(md, true);
d1334 3
a1336 1
				if(mw.IsStatic == isstatic)
d1338 3
a1340 2
					mw.Link();
					return mw.Cookie;
d1342 12
a1354 1
			SetPendingException(pEnv, JavaException.NoSuchMethodError("{0}{1}", md.Name, md.Signature));
d1356 2
a1357 1
		catch(Exception x)
d1359 1
a1359 1
			SetPendingException(pEnv, x);
a1360 2
		return IntPtr.Zero;
	}
d1362 18
a1379 9
	internal static jmethodID GetMethodID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig)
	{
		return FindMethodID(pEnv, clazz, name, sig, false);
	}

	internal static jobject CallObjectMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
	{
		return pEnv->MakeLocalRef(InvokeHelper(pEnv, obj, methodID, args, false));
	}
d1381 1
a1381 4
	internal static jboolean CallBooleanMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, false);
		if(o != null)
d1383 2
a1384 1
			return ((bool)o) ? JNI_TRUE : JNI_FALSE;
a1385 2
		return JNI_FALSE;
	}
d1387 1
a1387 4
	internal static jbyte CallByteMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, false);
		if(o != null)
d1389 1
a1389 1
			return (jbyte)(sbyte)o;
a1390 2
		return 0;
	}
d1392 1
a1392 4
	internal static jchar CallCharMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, false);
		if(o != null)
d1394 16
a1409 1
			return (jchar)(char)o;
a1410 2
		return 0;
	}
d1412 1
a1412 4
	internal static jshort CallShortMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, false);
		if(o != null)
d1414 9
a1422 1
			return (jshort)(short)o;
a1423 2
		return 0;
	}
d1425 1
a1425 4
	internal static jint CallIntMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, false);
		if(o != null)
d1427 18
a1444 1
			return (jint)(int)o;
a1445 2
		return 0;
	}
d1447 1
a1447 4
	internal static jlong CallLongMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, false);
		if(o != null)
d1449 13
a1461 1
			return (jlong)(long)o;
a1462 2
		return 0;
	}
d1464 1
a1464 4
	internal static jfloat CallFloatMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, false);
		if(o != null)
d1466 1
a1466 1
			return (jfloat)(float)o;
a1467 2
		return 0;
	}
d1469 1
a1469 4
	internal static jdouble CallDoubleMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, false);
		if(o != null)
d1471 11
a1481 1
			return (jdouble)(double)o;
a1482 12
		return 0;
	}

	internal static void CallVoidMethodA(JNIEnv* pEnv, jobject obj, jmethodID methodID, jvalue*  args)
	{
		InvokeHelper(pEnv, obj, methodID, args, false);
	}

	internal static jobject CallNonvirtualObjectMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue*  args)
	{
		return pEnv->MakeLocalRef(InvokeHelper(pEnv, obj, methodID, args, true));
	}
d1484 1
a1484 4
	internal static jboolean CallNonvirtualBooleanMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue*  args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, true);
		if(o != null)
d1486 1
a1486 1
			return ((bool)o) ? JNI_TRUE : JNI_FALSE;
a1487 2
		return JNI_FALSE;
	}
d1489 1
a1489 4
	internal static jbyte CallNonvirtualByteMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, true);
		if(o != null)
d1491 1
a1491 1
			return (jbyte)(sbyte)o;
a1492 2
		return 0;
	}
d1494 1
a1494 4
	internal static jchar CallNonvirtualCharMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, true);
		if(o != null)
d1496 2
a1497 1
			return (jchar)(char)o;
a1498 2
		return 0;
	}
d1500 1
a1500 4
	internal static jshort CallNonvirtualShortMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, true);
		if(o != null)
d1502 16
a1517 1
			return (jshort)(short)o;
a1518 2
		return 0;
	}
d1520 2
a1521 4
	internal static jint CallNonvirtualIntMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, true);
		if(o != null)
d1523 66
a1588 1
			return (jint)(int)o;
a1589 2
		return 0;
	}
d1591 1
a1591 4
	internal static jlong CallNonvirtualLongMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, true);
		if(o != null)
d1593 1
a1593 1
			return (jlong)(long)o;
a1594 2
		return 0;
	}
d1596 1
a1596 4
	internal static jfloat CallNonvirtualFloatMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, true);
		if(o != null)
d1598 1
a1598 1
			return (jfloat)(float)o;
a1599 2
		return 0;
	}
d1601 1
a1601 4
	internal static jdouble CallNonvirtualDoubleMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
	{
		object o = InvokeHelper(pEnv, obj, methodID, args, true);
		if(o != null)
d1603 4
a1606 1
			return (jdouble)(double)o;
a1607 7
		return 0;
	}

	internal static void CallNonvirtualVoidMethodA(JNIEnv* pEnv, jobject obj, jclass clazz, jmethodID methodID, jvalue* args)
	{
		InvokeHelper(pEnv, obj, methodID, args, true);
	}
d1609 1
a1609 3
	private static jfieldID FindFieldID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig, bool isstatic)
	{
		try
d1611 1
a1611 5
			TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
			wrapper.Finish();
			// TODO what about searching the base classes?
			FieldWrapper fw = wrapper.GetFieldWrapper(StringFromUTF8(name), wrapper.GetClassLoader().ExpressionTypeWrapper(StringFromUTF8(sig).Replace('/', '.')));
			if(fw != null)
d1613 5
a1617 1
				if(fw.IsStatic == isstatic)
d1619 5
a1623 2
					// TODO fw.Link()
					return fw.Cookie;
d1625 5
d1631 1
a1631 1
			SetPendingException(pEnv, JavaException.NoSuchFieldError(StringFromUTF8(name)));
d1633 2
a1634 1
		catch(Exception x)
d1636 1
a1636 1
			SetPendingException(pEnv, x);
a1637 7
		return IntPtr.Zero;
	}

	internal static jfieldID GetFieldID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig)
	{
		return FindFieldID(pEnv, clazz, name, sig, false);
	}
d1639 1
a1639 3
	private static void SetFieldValue(jfieldID cookie, object obj, object val)
	{
		try
d1641 1
a1641 1
			FieldWrapper.FromCookie(cookie).SetValue(obj, val);
d1643 2
a1644 1
		catch
d1646 6
a1651 2
			Debug.Assert(false);
			throw;
a1652 1
	}
d1654 1
a1654 3
	private static object GetFieldValue(jfieldID cookie, object obj)
	{
		try
d1656 6
a1661 1
			return FieldWrapper.FromCookie(cookie).GetValue(obj);
d1663 2
a1664 1
		catch
d1666 6
a1671 2
			Debug.Assert(false);
			throw;
a1672 1
	}
d1674 168
a1841 4
	internal static jobject GetObjectField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
	{
		return pEnv->MakeLocalRef(GetFieldValue(fieldID, pEnv->UnwrapRef(obj)));
	}
d1843 4
a1846 4
	internal static jboolean GetBooleanField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
	{
		return ((bool)GetFieldValue(fieldID, pEnv->UnwrapRef(obj))) ? JNI_TRUE : JNI_FALSE;
	}
d1848 12
a1859 4
	internal static jbyte GetByteField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
	{
		return (jbyte)(sbyte)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
	}
d1861 12
a1872 4
	internal static jchar GetCharField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
	{
		return (jchar)(char)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
	}
d1874 4
a1877 4
	internal static jshort GetShortField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
	{
		return (jshort)(short)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
	}
d1879 4
a1882 4
	internal static jint GetIntField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
	{
		return (jint)(int)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
	}
d1884 4
a1887 4
	internal static jlong GetLongField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
	{
		return (jlong)(long)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
	}
d1889 4
a1892 4
	internal static jfloat GetFloatField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
	{
		return (jfloat)(float)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
	}
d1894 4
a1897 4
	internal static jdouble GetDoubleField(JNIEnv* pEnv, jobject obj, jfieldID fieldID)
	{
		return (jdouble)(double)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
	}
d1899 4
a1902 4
	internal static void SetObjectField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jobject val)
	{
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), pEnv->UnwrapRef(val));
	}
d1904 4
a1907 4
	internal static void SetBooleanField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jboolean val)
	{
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), val != JNI_FALSE);
	}
d1909 4
a1912 4
	internal static void SetByteField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jbyte val)
	{
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (sbyte)val);
	}
d1914 4
a1917 4
	internal static void SetCharField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jchar val)
	{
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (char)val);
	}
d1919 4
a1922 4
	internal static void SetShortField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jshort val)
	{
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (short)val);
	}
d1924 4
a1927 4
	internal static void SetIntField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jint val)
	{
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (int)val);
	}
d1929 4
a1932 4
	internal static void SetLongField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jlong val)
	{
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (long)val);
	}
d1934 4
a1937 4
	internal static void SetFloatField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jfloat val)
	{
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (float)val);
	}
d1939 4
a1942 4
	internal static void SetDoubleField(JNIEnv* pEnv, jobject obj, jfieldID fieldID, jdouble val)
	{
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), (double)val);
	}
d1944 4
a1947 4
	internal static jmethodID GetStaticMethodID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig)
	{
		return FindMethodID(pEnv, clazz, name, sig, true);
	}
d1949 4
a1952 4
	internal static jobject CallStaticObjectMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		return pEnv->MakeLocalRef(InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false));
	}
d1954 1
a1954 4
	internal static jboolean CallStaticBooleanMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
		if(o != null)
d1956 1
a1956 1
			return ((bool)o) ? JNI_TRUE : JNI_FALSE;
a1957 2
		return JNI_FALSE;
	}
d1959 1
a1959 4
	internal static jbyte CallStaticByteMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
		if(o != null)
d1961 1
a1961 1
			return (jbyte)(sbyte)o;
a1962 2
		return 0;
	}
d1964 1
a1964 4
	internal static jchar CallStaticCharMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
		if(o != null)
d1966 1
a1966 1
			return (jchar)(char)o;
a1967 2
		return 0;
	}
d1969 1
a1969 4
	internal static jshort CallStaticShortMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
		if(o != null)
d1971 1
a1971 1
			return (jshort)(short)o;
a1972 2
		return 0;
	}
d1974 1
a1974 4
	internal static jint CallStaticIntMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
		if(o != null)
d1976 6
a1981 1
			return (jint)(int)o;
a1982 2
		return 0;
	}
d1984 1
a1984 4
	internal static jlong CallStaticLongMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
		if(o != null)
d1986 6
a1991 1
			return (jlong)(long)o;
a1992 2
		return 0;
	}
d1994 1
a1994 4
	internal static jfloat CallStaticFloatMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
		if(o != null)
d1996 6
a2001 1
			return (jfloat)(float)o;
a2002 2
		return 0;
	}
d2004 1
a2004 4
	internal static jdouble CallStaticDoubleMethodA(JNIEnv* pEnv, jclass clazz, jmethodID methodID, jvalue *args)
	{
		object o = InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
		if(o != null)
d2006 6
a2011 1
			return (jdouble)(double)o;
a2012 2
		return 0;
	}
d2014 9
a2022 4
	internal static void CallStaticVoidMethodA(JNIEnv* pEnv, jclass cls, jmethodID methodID, jvalue * args)
	{
		InvokeHelper(pEnv, IntPtr.Zero, methodID, args, false);
	}
d2024 9
a2032 4
	internal static jfieldID GetStaticFieldID(JNIEnv* pEnv, jclass clazz, byte* name, byte* sig)
	{
		return FindFieldID(pEnv, clazz, name, sig, true);
	}
d2034 9
a2042 4
	internal static jobject GetStaticObjectField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
	{
		return pEnv->MakeLocalRef(GetFieldValue(fieldID, null));
	}
d2044 9
a2052 4
	internal static jboolean GetStaticBooleanField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
	{
		return ((bool)GetFieldValue(fieldID, null)) ? JNI_TRUE : JNI_FALSE;
	}
d2054 4
a2057 4
	internal static jbyte GetStaticByteField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
	{
		return (jbyte)(sbyte)GetFieldValue(fieldID, null);
	}
d2059 4
a2062 4
	internal static jchar GetStaticCharField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
	{
		return (jchar)(char)GetFieldValue(fieldID, null);
	}
d2064 4
a2067 4
	internal static jshort GetStaticShortField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
	{
		return (jshort)(short)GetFieldValue(fieldID, null);
	}
d2069 4
a2072 4
	internal static jint GetStaticIntField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
	{
		return (jint)(int)GetFieldValue(fieldID, null);
	}
d2074 4
a2077 4
	internal static jlong GetStaticLongField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
	{
		return (jlong)(long)GetFieldValue(fieldID, null);
	}
d2079 4
a2082 4
	internal static jfloat GetStaticFloatField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
	{
		return (jfloat)(float)GetFieldValue(fieldID, null);
	}
d2084 4
a2087 4
	internal static jdouble GetStaticDoubleField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID)
	{
		return (jdouble)(double)GetFieldValue(fieldID, null);
	}
d2089 4
a2092 4
	internal static void SetStaticObjectField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jobject val)
	{
		SetFieldValue(fieldID, null, pEnv->UnwrapRef(val));
	}
d2094 4
a2097 4
	internal static void SetStaticBooleanField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jboolean val)
	{
		SetFieldValue(fieldID, null, val != JNI_FALSE);
	}
d2099 4
a2102 4
	internal static void SetStaticByteField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jbyte val)
	{
		SetFieldValue(fieldID, null, (sbyte)val);
	}
d2104 4
a2107 4
	internal static void SetStaticCharField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jchar val)
	{
		SetFieldValue(fieldID, null, (char)val);
	}
d2109 4
a2112 4
	internal static void SetStaticShortField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jshort val)
	{
		SetFieldValue(fieldID, null, (short)val);
	}
d2114 4
a2117 4
	internal static void SetStaticIntField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jint val)
	{
		SetFieldValue(fieldID, null, (int)val);
	}
d2119 4
a2122 4
	internal static void SetStaticLongField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jlong val)
	{
		SetFieldValue(fieldID, null, (long)val);
	}
d2124 4
a2127 4
	internal static void SetStaticFloatField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jfloat val)
	{
		SetFieldValue(fieldID, null, (float)val);
	}
d2129 4
a2132 4
	internal static void SetStaticDoubleField(JNIEnv* pEnv, jclass clazz, jfieldID fieldID, jdouble val)
	{
		SetFieldValue(fieldID, null, (double)val);
	}
d2134 4
a2137 4
	internal static jstring NewString(JNIEnv* pEnv, jchar* unicode, int len)
	{
		return pEnv->MakeLocalRef(new String((char*)unicode, 0, len));
	}
d2139 4
a2142 4
	internal static jint GetStringLength(JNIEnv* pEnv, jstring str)
	{
		return ((string)pEnv->UnwrapRef(str)).Length;
	}
d2144 1
a2144 4
	internal static jchar* GetStringChars(JNIEnv* pEnv, jstring str, jboolean* isCopy)
	{
		string s = (string)pEnv->UnwrapRef(str);
		if(isCopy != null)
d2146 1
a2146 1
			*isCopy = JNI_TRUE;
a2147 2
		return (jchar*)(void*)Marshal.StringToHGlobalUni(s);
	}
d2149 4
a2152 4
	internal static void ReleaseStringChars(JNIEnv* pEnv, jstring str, jchar* chars)
	{
		Marshal.FreeHGlobal((IntPtr)(void*)chars);
	}
d2154 4
a2157 4
	internal static jobject NewStringUTF(JNIEnv* pEnv, byte* psz)
	{
		return pEnv->MakeLocalRef(StringFromUTF8(psz));
	}
d2159 4
a2162 4
	internal static jint GetStringUTFLength(JNIEnv* pEnv, jstring str)
	{
		return StringUTF8Length((string)pEnv->UnwrapRef(str));
	}
d2164 1
a2164 6
	internal static byte* GetStringUTFChars(JNIEnv* pEnv, jstring str, jboolean* isCopy)
	{
		string s = (string)pEnv->UnwrapRef(str);
		byte* buf = (byte*)JniMem.Alloc(StringUTF8Length(s) + 1);
		int j = 0;
		for(int i = 0; i < s.Length; i++)
d2166 2
a2167 2
			char ch = s[i];
			if((ch != 0) && (ch <= 0x7F))
d2169 1
a2169 1
				buf[j++] = (byte)ch;
d2171 24
a2194 1
			else if(ch <= 0x7FF)
d2196 16
a2211 2
				buf[j++] = (byte)((ch >> 6) | 0xC0);
				buf[j++] = (byte)((ch & 0x3F) | 0x80);
d2213 2
a2214 1
			else
d2216 1
a2216 3
				buf[j++] = (byte)((ch >> 12) | 0xE0);
				buf[j++] = (byte)(((ch >> 6) & 0x3F) | 0x80);
				buf[j++] = (byte)((ch & 0x3F) | 0x80);
d2218 1
d2220 2
a2221 2
		buf[j] = 0;
		if(isCopy != null)
d2223 1
a2223 1
			*isCopy = JNI_TRUE;
a2224 2
		return buf;
	}
d2226 4
a2229 4
	internal static void ReleaseStringUTFChars(JNIEnv* pEnv, jstring str, byte* chars)
	{
		JniMem.Free((IntPtr)(void*)chars);
	}
d2231 27
a2257 4
	internal static jsize GetArrayLength(JNIEnv* pEnv, jarray array)
	{
		return ((Array)pEnv->UnwrapRef(array)).Length;
	}
d2259 1
a2259 6
	internal static jobject NewObjectArray(JNIEnv* pEnv, jsize len, jclass clazz, jobject init)
	{
		// TODO if we want to support (non-primitive) value types we can't use the object[] cast
		object[] array = (object[])Array.CreateInstance(NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz)).TypeAsArrayType, len);
		object o = pEnv->UnwrapRef(init);
		if(o != null)
d2261 1
a2261 1
			for(int i = 0; i < array.Length; i++)
d2263 7
a2269 1
				array[i] = o;
a2271 2
		return pEnv->MakeLocalRef(array);
	}
d2273 1
a2273 3
	internal static jobject GetObjectArrayElement(JNIEnv* pEnv, jarray array, jsize index)
	{
		try
d2275 9
a2283 2
			// TODO if we want to support (non-primitive) value types we can't use the object[] cast
			return pEnv->MakeLocalRef(((object[])pEnv->UnwrapRef(array))[index]);
d2285 2
a2286 1
		catch(IndexOutOfRangeException)
d2288 9
a2296 2
			SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
			return IntPtr.Zero;
a2297 1
	}
d2299 1
a2299 3
	internal static void SetObjectArrayElement(JNIEnv* pEnv, jarray array, jsize index, jobject val)
	{
		try
d2301 9
a2309 2
			// TODO if we want to support (non-primitive) value types we can't use the object[] cast
			((object[])pEnv->UnwrapRef(array))[index] = pEnv->UnwrapRef(val);
d2311 2
a2312 1
		catch(IndexOutOfRangeException)
d2314 9
a2322 1
			SetPendingException(pEnv, JavaException.ArrayIndexOutOfBoundsException());
a2323 1
	}
d2325 12
a2336 4
	internal static jbooleanArray NewBooleanArray(JNIEnv* pEnv, jsize len)
	{
		return pEnv->MakeLocalRef(new bool[len]);
	}
d2338 12
a2349 4
	internal static jbyteArray NewByteArray(JNIEnv* pEnv, jsize len)
	{
		return pEnv->MakeLocalRef(new sbyte[len]);
	}
d2351 12
a2362 4
	internal static jcharArray NewCharArray(JNIEnv* pEnv, jsize len)
	{
		return pEnv->MakeLocalRef(new char[len]);
	}
d2364 12
a2375 4
	internal static jshortArray NewShortArray(JNIEnv* pEnv, jsize len)
	{
		return pEnv->MakeLocalRef(new short[len]);
	}
d2377 12
a2388 4
	internal static jintArray NewIntArray(JNIEnv* pEnv, jsize len)
	{
		return pEnv->MakeLocalRef(new int[len]);
	}
d2390 14
a2403 9
	internal static jlongArray NewLongArray(JNIEnv* pEnv, jsize len)
	{
		return pEnv->MakeLocalRef(new long[len]);
	}

	internal static jfloatArray NewFloatArray(JNIEnv* pEnv, jsize len)
	{
		return pEnv->MakeLocalRef(new float[len]);
	}
d2405 14
a2418 4
	internal static jdoubleArray NewDoubleArray(JNIEnv* pEnv, jsize len)
	{
		return pEnv->MakeLocalRef(new double[len]);
	}
d2420 1
a2420 5
	internal static jboolean* GetBooleanArrayElements(JNIEnv* pEnv, jbooleanArray array, jboolean* isCopy)
	{
		bool[] b = (bool[])pEnv->UnwrapRef(array);
		jboolean* p = (jboolean*)(void*)JniMem.Alloc(b.Length * 1);
		for(int i = 0; i < b.Length; i++)
d2422 8
a2429 1
			p[i] = b[i] ? JNI_TRUE : JNI_FALSE;
d2431 2
a2432 1
		if(isCopy != null)
d2434 8
a2441 1
			*isCopy = JNI_TRUE;
a2442 2
		return p;
	}
d2444 1
a2444 5
	internal static jbyte* GetByteArrayElements(JNIEnv* pEnv, jbyteArray array, jboolean* isCopy)
	{
		sbyte[] b = (sbyte[])pEnv->UnwrapRef(array);
		jbyte* p = (jbyte*)(void*)JniMem.Alloc(b.Length * 1);
		for(int i = 0; i < b.Length; i++)
d2446 8
a2453 1
			p[i] = (jbyte)b[i];
d2455 2
a2456 1
		if(isCopy != null)
d2458 8
a2465 1
			*isCopy = JNI_TRUE;
a2466 2
		return p;
	}
d2468 1
a2468 6
	internal static jchar* GetCharArrayElements(JNIEnv* pEnv, jcharArray array, jboolean* isCopy)
	{
		char[] b = (char[])pEnv->UnwrapRef(array);
		IntPtr buf = JniMem.Alloc(b.Length * 2);
		Marshal.Copy(b, 0, buf, b.Length);
		if(isCopy != null)
d2470 8
a2477 1
			*isCopy = JNI_TRUE;
a2478 2
		return (jchar*)(void*)buf;
	}
d2480 1
a2480 6
	internal static jshort* GetShortArrayElements(JNIEnv* pEnv, jshortArray array, jboolean* isCopy)
	{
		short[] b = (short[])pEnv->UnwrapRef(array);
		IntPtr buf = JniMem.Alloc(b.Length * 2);
		Marshal.Copy(b, 0, buf, b.Length);
		if(isCopy != null)
d2482 8
a2489 1
			*isCopy = JNI_TRUE;
a2490 2
		return (jshort*)(void*)buf;
	}
d2492 1
a2492 6
	internal static jint* GetIntArrayElements(JNIEnv* pEnv, jintArray array, jboolean* isCopy)
	{
		int[] b = (int[])pEnv->UnwrapRef(array);
		IntPtr buf = JniMem.Alloc(b.Length * 4);
		Marshal.Copy(b, 0, buf, b.Length);
		if(isCopy != null)
d2494 12
a2505 1
			*isCopy = JNI_TRUE;
a2506 2
		return (jint*)(void*)buf;
	}
d2508 1
a2508 6
	internal static jlong* GetLongArrayElements(JNIEnv* pEnv, jlongArray array, jboolean* isCopy)
	{
		long[] b = (long[])pEnv->UnwrapRef(array);
		IntPtr buf = JniMem.Alloc(b.Length * 8);
		Marshal.Copy(b, 0, buf, b.Length);
		if(isCopy != null)
d2510 12
a2521 1
			*isCopy = JNI_TRUE;
a2522 2
		return (jlong*)(void*)buf;
	}
d2524 1
a2524 6
	internal static jfloat* GetFloatArrayElements(JNIEnv* pEnv, jfloatArray array, jboolean* isCopy)
	{
		float[] b = (float[])pEnv->UnwrapRef(array);
		IntPtr buf = JniMem.Alloc(b.Length * 4);
		Marshal.Copy(b, 0, buf, b.Length);
		if(isCopy != null)
d2526 9
a2534 1
			*isCopy = JNI_TRUE;
a2535 2
		return (jfloat*)(void*)buf;
	}
d2537 1
a2537 6
	internal static jdouble* GetDoubleArrayElements(JNIEnv* pEnv, jdoubleArray array, jboolean* isCopy)
	{
		double[] b = (double[])pEnv->UnwrapRef(array);
		IntPtr buf = JniMem.Alloc(b.Length * 8);
		Marshal.Copy(b, 0, buf, b.Length);
		if(isCopy != null)
d2539 9
a2547 1
			*isCopy = JNI_TRUE;
a2548 2
		return (jdouble*)(void*)buf;
	}
d2550 1
a2550 3
	internal static void ReleaseBooleanArrayElements(JNIEnv* pEnv, jbooleanArray array, jboolean* elems, jint mode)
	{
		if(mode == 0 || mode == JNI_COMMIT)
d2552 6
a2557 2
			bool[] b = (bool[])pEnv->UnwrapRef(array);
			for(int i = 0; i < b.Length; i++)
d2559 1
a2559 1
				b[i] = elems[i] != JNI_FALSE;
d2562 2
a2563 1
		if(mode == 0 || mode == JNI_ABORT)
d2565 9
a2573 1
			JniMem.Free((IntPtr)(void*)elems);
a2574 1
	}
d2576 1
a2576 3
	internal static void ReleaseByteArrayElements(JNIEnv* pEnv, jbyteArray array, jbyte* elems, jint mode)
	{
		if(mode == 0 || mode == JNI_COMMIT)
d2578 6
a2583 2
			sbyte[] b = (sbyte[])pEnv->UnwrapRef(array);
			for(int i = 0; i < b.Length; i++)
d2585 1
a2585 1
				b[i] = (sbyte)elems[i];
d2588 2
a2589 1
		if(mode == 0 || mode == JNI_ABORT)
d2591 9
a2599 1
			JniMem.Free((IntPtr)(void*)elems);
a2600 1
	}
d2602 1
a2602 3
	internal static void ReleaseCharArrayElements(JNIEnv* pEnv, jcharArray array, jchar* elems, jint mode)
	{
		if(mode == 0 || mode == JNI_COMMIT)
d2604 13
a2616 2
			char[] b = (char[])pEnv->UnwrapRef(array);
			Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
d2618 2
a2619 1
		if(mode == 0 || mode == JNI_ABORT)
d2621 13
a2633 1
			JniMem.Free((IntPtr)(void*)elems);
a2634 1
	}
d2636 1
a2636 3
	internal static void ReleaseShortArrayElements(JNIEnv* pEnv, jshortArray array, jshort* elems, jint mode)
	{
		if(mode == 0 || mode == JNI_COMMIT)
d2638 9
a2646 2
			short[] b = (short[])pEnv->UnwrapRef(array);
			Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
d2648 2
a2649 1
		if(mode == 0 || mode == JNI_ABORT)
d2651 9
a2659 1
			JniMem.Free((IntPtr)(void*)elems);
a2660 1
	}
d2662 1
a2662 3
	internal static void ReleaseIntArrayElements(JNIEnv* pEnv, jintArray array, jint* elems, jint mode)
	{
		if(mode == 0 || mode == JNI_COMMIT)
d2664 9
a2672 2
			int[] b = (int[])pEnv->UnwrapRef(array);
			Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
d2674 2
a2675 1
		if(mode == 0 || mode == JNI_ABORT)
d2677 9
a2685 1
			JniMem.Free((IntPtr)(void*)elems);
a2686 1
	}
d2688 1
a2688 3
	internal static void ReleaseLongArrayElements(JNIEnv* pEnv, jlongArray array, jlong* elems, jint mode)
	{
		if(mode == 0 || mode == JNI_COMMIT)
d2690 9
a2698 2
			long[] b = (long[])pEnv->UnwrapRef(array);
			Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
d2700 2
a2701 1
		if(mode == 0 || mode == JNI_ABORT)
d2703 9
a2711 1
			JniMem.Free((IntPtr)(void*)elems);
a2712 1
	}
d2714 1
a2714 3
	internal static void ReleaseFloatArrayElements(JNIEnv* pEnv, jfloatArray array, jfloat* elems, jint mode)
	{
		if(mode == 0 || mode == JNI_COMMIT)
d2716 13
a2728 2
			float[] b = (float[])pEnv->UnwrapRef(array);
			Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
d2730 2
a2731 1
		if(mode == 0 || mode == JNI_ABORT)
d2733 13
a2745 1
			JniMem.Free((IntPtr)(void*)elems);
a2746 1
	}
d2748 1
a2748 3
	internal static void ReleaseDoubleArrayElements(JNIEnv* pEnv, jdoubleArray array, jdouble* elems, jint mode)
	{
		if(mode == 0 || mode == JNI_COMMIT)
d2750 9
a2758 2
			double[] b = (double[])pEnv->UnwrapRef(array);
			Marshal.Copy((IntPtr)(void*)elems, b, 0, b.Length);
d2760 2
a2761 1
		if(mode == 0 || mode == JNI_ABORT)
d2763 9
a2771 1
			JniMem.Free((IntPtr)(void*)elems);
a2772 1
	}
d2774 1
a2774 5
	internal static void GetBooleanArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		bool[] b = (bool[])pEnv->UnwrapRef(array);
		sbyte* p = (sbyte*)(void*)buf;
		for(int i = 0; i < len; i++)
d2776 9
a2784 1
			*p++ = b[start + i] ? JNI_TRUE : JNI_FALSE;
a2785 1
	}
d2787 1
a2787 5
	internal static void GetByteArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		sbyte[] b = (sbyte[])pEnv->UnwrapRef(array);
		sbyte* p = (sbyte*)(void*)buf;
		for(int i = 0; i < len; i++)
d2789 9
a2797 1
			*p++ = b[start + i];
a2798 1
	}
d2800 12
a2811 35
	internal static void GetCharArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		char[] b = (char[])pEnv->UnwrapRef(array);
		Marshal.Copy(b, start, buf, len);
	}

	internal static void GetShortArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		short[] b = (short[])pEnv->UnwrapRef(array);
		Marshal.Copy(b, start, buf, len);
	}

	internal static void GetIntArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		int[] b = (int[])pEnv->UnwrapRef(array);
		Marshal.Copy(b, start, buf, len);
	}

	internal static void GetLongArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		long[] b = (long[])pEnv->UnwrapRef(array);
		Marshal.Copy(b, start, buf, len);
	}

	internal static void GetFloatArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		float[] b = (float[])pEnv->UnwrapRef(array);
		Marshal.Copy(b, start, buf, len);
	}

	internal static void GetDoubleArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		double[] b = (double[])pEnv->UnwrapRef(array);
		Marshal.Copy(b, start, buf, len);
	}
d2813 1
a2813 5
	internal static void SetBooleanArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		bool[] b = (bool[])pEnv->UnwrapRef(array);
		sbyte* p = (sbyte*)(void*)buf;
		for(int i = 0; i < len; i++)
d2815 9
a2823 1
			b[start + i] = *p++ != JNI_FALSE;
a2824 1
	}
d2826 2
a2827 5
	internal static void SetByteArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		sbyte[] b = (sbyte[])pEnv->UnwrapRef(array);
		sbyte* p = (sbyte*)(void*)buf;
		for(int i = 0; i < len; i++)
d2829 3
a2831 1
			b[start + i] = *p++;
a2832 31
	}

	internal static void SetCharArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		char[] b = (char[])pEnv->UnwrapRef(array);
		Marshal.Copy(buf, b, start, len);
	}

	internal static void SetShortArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		short[] b = (short[])pEnv->UnwrapRef(array);
		Marshal.Copy(buf, b, start, len);
	}

	internal static void SetIntArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		int[] b = (int[])pEnv->UnwrapRef(array);
		Marshal.Copy(buf, b, start, len);
	}

	internal static void SetLongArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		long[] b = (long[])pEnv->UnwrapRef(array);
		Marshal.Copy(buf, b, start, len);
	}

	internal static void SetFloatArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		float[] b = (float[])pEnv->UnwrapRef(array);
		Marshal.Copy(buf, b, start, len);
	}
d2834 1
a2834 17
	internal static void SetDoubleArrayRegion(JNIEnv* pEnv, IntPtr array, int start, int len, IntPtr buf)
	{
		double[] b = (double[])pEnv->UnwrapRef(array);
		Marshal.Copy(buf, b, start, len);
	}

	[StructLayout(LayoutKind.Sequential)]
		internal struct JNINativeMethod
	{
		public byte* name;
		public byte* signature;
		public void* fnPtr;
	}

	internal static int RegisterNatives(JNIEnv* pEnv, IntPtr clazz, JNINativeMethod* methods, int nMethods)
	{
		try
d2836 1
a2836 3
			TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
			wrapper.Finish();
			for(int i = 0; i < nMethods; i++)
d2838 3
a2840 2
				FieldInfo fi = wrapper.TypeAsTBD.GetField("jniptr/" + StringFromUTF8(methods[i].name) + StringFromUTF8(methods[i].signature).Replace('/', '.'), BindingFlags.Static | BindingFlags.NonPublic);
				if(fi == null)
d2842 7
a2848 2
					SetPendingException(pEnv, JavaException.NoSuchMethodError(StringFromUTF8(methods[i].name)));
					return JNI_ERR;
d2850 6
a2855 1
				fi.SetValue(null, (IntPtr)methods[i].fnPtr);
a2856 1
			return JNI_OK;
a2857 6
		catch(Exception x)
		{
			SetPendingException(pEnv, x);
			return JNI_ERR;
		}
	}
d2859 1
a2859 3
	internal static int UnregisterNatives(JNIEnv* pEnv, IntPtr clazz)
	{
		try
d2861 1
a2861 3
			TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(pEnv->UnwrapRef(clazz));
			wrapper.Finish();
			foreach(FieldInfo fi in wrapper.TypeAsTBD.GetFields(BindingFlags.Static | BindingFlags.NonPublic))
d2863 3
a2865 1
				if(fi.Name.StartsWith("jniptr/"))
d2867 4
a2870 1
					fi.SetValue(null, IntPtr.Zero);
d2872 6
a2878 1
			return JNI_OK;
d2880 2
a2881 1
		catch(Exception x)
d2883 10
a2892 2
			SetPendingException(pEnv, x);
			return JNI_ERR;
a2893 1
	}
d2895 1
a2895 3
	internal static int MonitorEnter(JNIEnv* pEnv, IntPtr obj)
	{
		try
d2897 10
a2906 7
			System.Threading.Monitor.Enter(pEnv->UnwrapRef(obj));
			return JNI_OK;
		}
		catch(System.Threading.ThreadInterruptedException)
		{
			SetPendingException(pEnv, JavaException.InterruptedException());
			return JNI_ERR;
a2907 1
	}
d2909 1
a2909 3
	internal static int MonitorExit(JNIEnv* pEnv, IntPtr obj)
	{
		try
d2911 1
a2911 1
			System.Threading.Monitor.Exit(pEnv->UnwrapRef(obj));
a2913 12
		catch(System.Threading.SynchronizationLockException)
		{
			SetPendingException(pEnv, JavaException.IllegalMonitorStateException());
			return JNI_ERR;
		}
	}

	internal static int GetJavaVM(JNIEnv* pEnv, JavaVM **ppJavaVM)
	{
		*ppJavaVM = JavaVM.pJavaVM;
		return JNI_OK;
	}
d2915 1
a2915 4
	internal static void GetStringRegion(JNIEnv* pEnv, IntPtr str, int start, int len, IntPtr buf)
	{
		string s = (string)pEnv->UnwrapRef(str);
		if(s != null)
d2917 2
a2918 1
			if(start < 0 || start > s.Length || s.Length - start < len)
d2920 15
a2934 2
				SetPendingException(pEnv, JavaException.StringIndexOutOfBoundsException(""));
				return;
d2938 1
a2938 7
				char* p = (char*)(void*)buf;
				// TODO isn't there a managed memcpy?
				for(int i = 0; i < len; i++)
				{
					*p++ = s[start + i];
				}
				return;
a2940 5
		else
		{
			SetPendingException(pEnv, JavaException.NullPointerException());
		}
	}
d2942 1
a2942 4
	internal static void GetStringUTFRegion(JNIEnv* pEnv, IntPtr str, int start, int len, IntPtr buf)
	{
		string s = (string)pEnv->UnwrapRef(str);
		if(s != null)
d2944 2
a2945 1
			if(start < 0 || start > s.Length || s.Length - start < len)
d2947 6
a2952 7
				SetPendingException(pEnv, JavaException.StringIndexOutOfBoundsException(""));
				return;
			}
			else
			{
				byte* p = (byte*)(void*)buf;
				for(int i = 0; i < len; i++)
d2954 2
a2955 2
					char ch = s[start + i];
					if((ch != 0) && (ch <= 0x7F))
d2957 16
a2972 12
						*p++ = (byte)ch;
					}
					else if(ch <= 0x7FF)
					{
						*p++ = (byte)((ch >> 6) | 0xC0);
						*p++ = (byte)((ch & 0x3F) | 0x80);
					}
					else
					{
						*p++ = (byte)((ch >> 12) | 0xE0);
						*p++ = (byte)(((ch >> 6) & 0x3F) | 0x80);
						*p++ = (byte)((ch & 0x3F) | 0x80);
d2974 1
d2976 4
a2979 1
				return;
a2981 5
		else
		{
			SetPendingException(pEnv, JavaException.NullPointerException());
		}
	}
d2983 1
a2983 4
	private static int GetPrimitiveArrayElementSize(Array ar)
	{
		Type type = ar.GetType().GetElementType();
		if(type == typeof(sbyte) || type == typeof(bool))
d2985 14
a2998 33
			return 1;
		}
		else if(type == typeof(short) || type == typeof(char))
		{
			return 2;
		}
		else if(type == typeof(int) || type == typeof(float))
		{
			return 4;
		}
		else if(type == typeof(long) || type == typeof(double))
		{
			return 8;
		}
		else
		{
			JVM.CriticalFailure("invalid array type", null);
			return 0;
		}
	}

	internal static IntPtr GetPrimitiveArrayCritical(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
	{
		Array ar = (Array)pEnv->UnwrapRef(array);
		int len = ar.Length * GetPrimitiveArrayElementSize(ar);
		GCHandle h = GCHandle.Alloc(ar, GCHandleType.Pinned);
		try
		{
			IntPtr hglobal = JniMem.Alloc(len);
			byte* pdst = (byte*)(void*)hglobal;
			byte* psrc = (byte*)(void*)h.AddrOfPinnedObject();
			// TODO isn't there a managed memcpy?
			for(int i = 0; i < len; i++)
d3000 1
a3000 1
				*pdst++ = *psrc++;
d3002 1
a3002 1
			if(isCopy != IntPtr.Zero)
d3004 2
a3005 1
				*((sbyte*)(void*)isCopy) = JNI_TRUE;
a3006 1
			return hglobal;
a3007 5
		finally
		{
			h.Free();
		}		
	}
d3009 1
a3009 3
	internal static void ReleasePrimitiveArrayCritical(JNIEnv* pEnv, IntPtr array, IntPtr carray, int mode)
	{
		if(mode == 0 || mode == JNI_COMMIT)
d3016 3
a3018 2
				byte* pdst = (byte*)(void*)h.AddrOfPinnedObject();
				byte* psrc = (byte*)(void*)carray;
d3024 5
d3033 1
a3033 5
			}
		}
		if(mode == 0 || mode == JNI_ABORT)
		{
			JniMem.Free(carray);
a3034 1
	}
d3036 1
a3036 4
	internal static IntPtr GetStringCritical(JNIEnv* pEnv, IntPtr str, IntPtr isCopy)
	{
		string s = (string)pEnv->UnwrapRef(str);
		if(s != null)
d3038 21
a3058 1
			if(isCopy != IntPtr.Zero)
d3060 1
a3060 1
				*((sbyte*)(void*)isCopy) = JNI_TRUE;
a3061 1
			return Marshal.StringToHGlobalUni(s);		
a3062 8
		SetPendingException(pEnv, JavaException.NullPointerException());
		return IntPtr.Zero;
	}

	internal static void ReleaseStringCritical(JNIEnv* pEnv, IntPtr str, IntPtr cstring)
	{
		Marshal.FreeHGlobal(cstring);
	}
d3064 1
a3064 8
	internal static jweak NewWeakGlobalRef(JNIEnv* pEnv, jobject obj)
	{
		object o = pEnv->UnwrapRef(obj);
		if(o == null)
		{
			return IntPtr.Zero;
		}
		lock(GlobalRefs.weakRefLock)
d3066 2
a3067 1
			for(int i = 0; i < GlobalRefs.weakRefs.Length; i++)
d3069 1
a3069 1
				if(!GlobalRefs.weakRefs[i].IsAllocated)
d3071 1
a3071 2
					GlobalRefs.weakRefs[i] = GCHandle.Alloc(o, GCHandleType.WeakTrackResurrection);
					return (IntPtr)(- (i | (1 << 30)));
d3073 1
d3075 2
a3076 6
			int len = GlobalRefs.weakRefs.Length;
			GCHandle[] tmp = new GCHandle[len * 2];
			Array.Copy(GlobalRefs.weakRefs, 0, tmp, 0, len);
			tmp[len] = GCHandle.Alloc(o, GCHandleType.WeakTrackResurrection);
			GlobalRefs.weakRefs = tmp;
			return (IntPtr)(- (len | (1 << 30)));
a3077 1
	}
d3079 1
a3079 13
	internal static void DeleteWeakGlobalRef(JNIEnv* pEnv, jweak obj)
	{
		int i = obj.ToInt32();
		if(i < 0)
		{
			i = -i;
			i -= (1 << 30);
			lock(GlobalRefs.weakRefLock)
			{
				GlobalRefs.weakRefs[i].Free();
			}
		}
		if(i > 0)
d3081 1
a3081 1
			Debug.Assert(false, "local ref passed to DeleteWeakGlobalRef");
a3082 11
	}

	internal static sbyte ExceptionCheck(JNIEnv* pEnv)
	{
		return pEnv->UnwrapRef(pEnv->pendingException) != null ? JNI_TRUE : JNI_FALSE;
	}

	internal static void NotImplemented(JNIEnv* pEnv)
	{
		JVM.CriticalFailure("Unimplemented JNIEnv function called", null);
	}
d3084 1
a3084 3
	internal IntPtr MakeLocalRef(object obj)
	{
		if(obj == null)
d3086 6
a3091 7
			return IntPtr.Zero;
		}
		object[][] localRefs = GetLocalRefs();
		object[] active = localRefs[localRefSlot];
		for(int i = 0; i < active.Length; i++)
		{
			if(active[i] == null)
d3093 14
a3106 2
				active[i] = obj;
				return (IntPtr)((localRefSlot << LOCAL_REF_SHIFT) + i);
a3108 14
		if(active.Length < LOCAL_REF_BUCKET_SIZE)
		{
			int i = active.Length;
			object[] tmp = new object[i * 2];
			Array.Copy(active, 0, tmp, 0, i);
			active = localRefs[localRefSlot] = tmp;
			active[i] = obj;
			return (IntPtr)((localRefSlot << LOCAL_REF_SHIFT) + i);
		}
		// TODO consider allocating a new slot (if we do this, the code in
		// PushLocalFrame/PopLocalFrame (and Leave) must be fixed to take this into account)
		JVM.CriticalFailure("Too many JNI local references", null);
		return IntPtr.Zero;
	}
d3110 1
a3110 9
	internal object UnwrapRef(IntPtr o)
	{
		int i = o.ToInt32();
		if(i > 0)
		{
			object[][] localRefs = GetLocalRefs();
			return localRefs[i >> LOCAL_REF_SHIFT][i & LOCAL_REF_MASK];
		}
		if(i < 0)
d3112 2
a3113 2
			i = -i;
			if((i & (1 << 30)) != 0)
d3115 2
d3119 1
a3119 1
					return GlobalRefs.weakRefs[i - (1 << 30)].Target;
d3122 1
a3122 1
			else
d3124 1
a3124 4
				lock(GlobalRefs.globalRefs)
				{
					return GlobalRefs.globalRefs[i - 1];
				}
a3126 3
		return null;
	}
}
d3128 1
a3128 6
class JniMem
{
	internal static IntPtr Alloc(int cb)
	{
		// MONOBUG Marshal.AllocHGlobal returns a null pointer if we try to allocate zero bytes
		if(cb == 0)
d3130 1
a3130 1
			cb = 1;
a3131 22
		return Marshal.AllocHGlobal(cb);
	}

	internal static void Free(IntPtr p)
	{
		Marshal.FreeHGlobal(p);
	}
}

unsafe class TlsHack
{
	[ThreadStatic]
	internal static JNIEnv* pJNIEnv;
}

public unsafe struct JniFrame
{
	private JNIEnv* pJNIEnv;
	private RuntimeMethodHandle method;
	private object[] quickLocals;
	private int quickLocalIndex;
	private int prevLocalRefSlot;
d3133 1
a3133 6
	public IntPtr Enter(RuntimeMethodHandle method)
	{
		this.method = method;
		pJNIEnv = TlsHack.pJNIEnv;
		object[][] localRefs;
		if(pJNIEnv == null)
d3135 1
a3135 11
			// TODO when the thread dies, we're leaking the JNIEnv and the GCHandle
			pJNIEnv = TlsHack.pJNIEnv = (JNIEnv*)JniMem.Alloc(sizeof(JNIEnv));
			pJNIEnv->vtable = VtableBuilder.vtable;
			localRefs = new object[32][];
			localRefs[0] = new object[JNIEnv.LOCAL_REF_BUCKET_SIZE];
			// stuff something in the first entry to make sure we don't hand out a zero handle
			// (a zero handle corresponds to a null reference)
			localRefs[0][0] = "";
			pJNIEnv->localRefs = GCHandle.Alloc(localRefs);
			pJNIEnv->localRefSlot = 0;
			pJNIEnv->pendingException = IntPtr.Zero;
a3136 20
		else
		{
			localRefs = pJNIEnv->GetLocalRefs();
		}
		prevLocalRefSlot = pJNIEnv->localRefSlot;
		pJNIEnv->localRefSlot++;
		if(pJNIEnv->localRefSlot >= localRefs.Length)
		{
			object[][] tmp = new object[localRefs.Length * 2][];
			Array.Copy(localRefs, 0, tmp, 0, localRefs.Length);
			pJNIEnv->localRefs.Target = localRefs = tmp;
		}
		if(localRefs[pJNIEnv->localRefSlot] == null)
		{
			localRefs[pJNIEnv->localRefSlot] = new object[32];
		}
		quickLocals = localRefs[pJNIEnv->localRefSlot];
		quickLocalIndex = (pJNIEnv->localRefSlot << JNIEnv.LOCAL_REF_SHIFT);
		return (IntPtr)(void*)pJNIEnv;
	}
d3138 1
a3138 6
	public void Leave()
	{
		Exception x = (Exception)pJNIEnv->UnwrapRef(pJNIEnv->pendingException);
		pJNIEnv->pendingException = IntPtr.Zero;
		object[][] localRefs = pJNIEnv->GetLocalRefs();
		while(pJNIEnv->localRefSlot != prevLocalRefSlot)
d3140 1
a3140 1
			if(localRefs[pJNIEnv->localRefSlot] != null)
d3142 1
a3142 1
				Array.Clear(localRefs[pJNIEnv->localRefSlot], 0, localRefs[pJNIEnv->localRefSlot].Length);
d3144 3
a3146 22
			pJNIEnv->localRefSlot--;
		}
		if(x != null)
		{
			throw x;
		}
	}

	public static IntPtr GetFuncPtr(RuntimeMethodHandle method, string clazz, string name, string sig)
	{
		MethodBase mb = MethodBase.GetMethodFromHandle(method);
		// MONOBUG Mono 1.0 doesn't implement MethodBase.GetMethodFromHandle
		if(mb == null)
		{
			mb = new StackFrame(1).GetMethod();
		}
		ClassLoaderWrapper loader =	ClassLoaderWrapper.GetWrapperFromType(mb.DeclaringType).GetClassLoader();
		StringBuilder mangledSig = new StringBuilder();
		int sp = 0;
		for(int i = 1; sig[i] != ')'; i++)
		{
			switch(sig[i])
d3148 1
a3148 4
			case '[':
				mangledSig.Append("_3");
				sp += IntPtr.Size;
				while(sig[++i] == '[')
d3150 2
a3151 1
					mangledSig.Append("_3");
a3152 58
				mangledSig.Append(sig[i]);
				if(sig[i] == 'L')
				{
					while(sig[++i] != ';')
					{
						if(sig[i] == '/')
						{
							mangledSig.Append("_");
						}
						else if(sig[i] == '_')
						{
							mangledSig.Append("_1");
						}
						else
						{
							mangledSig.Append(sig[i]);
						}
					}
					mangledSig.Append("_2");
				}
				break;
			case 'L':
				sp += IntPtr.Size;
				mangledSig.Append("L");
				while(sig[++i] != ';')
				{
					if(sig[i] == '/')
					{
						mangledSig.Append("_");
					}
					else if(sig[i] == '_')
					{
						mangledSig.Append("_1");
					}
					else
					{
						mangledSig.Append(sig[i]);
					}
				}
				mangledSig.Append("_2");
				break;
			case 'J':
			case 'D':
				mangledSig.Append(sig[i]);
				sp += 8;
				break;
			case 'F':
			case 'I':
			case 'C':
			case 'Z':
			case 'S':
			case 'B':
				mangledSig.Append(sig[i]);
				sp += 4;
				break;
			default:
				Debug.Assert(false);
				break;
d3154 27
d3182 2
a3183 1
		lock(JniHelper.JniLock)
d3185 2
a3186 2
			string methodName = String.Format("Java_{0}_{1}", clazz.Replace("_", "_1").Replace('/', '_'), name.Replace("_", "_1"));
			foreach(IntPtr p in loader.GetNativeLibraries())
d3188 7
a3194 2
				IntPtr pfunc = JniHelper.ikvm_GetProcAddress(p, methodName, sp + 2 * IntPtr.Size);
				if(pfunc != IntPtr.Zero)
d3196 4
a3199 1
					return pfunc;
d3201 1
a3201 6
			}
			methodName = String.Format("Java_{0}_{1}__{2}", clazz.Replace("_", "_1").Replace('/', '_'), name.Replace("_", "_1"), mangledSig);
			foreach(IntPtr p in loader.GetNativeLibraries())
			{
				IntPtr pfunc = JniHelper.ikvm_GetProcAddress(p, methodName, sp + 2 * IntPtr.Size);
				if(pfunc != IntPtr.Zero)
d3203 4
a3206 1
					return pfunc;
d3209 1
a3210 1
		throw JavaException.UnsatisfiedLinkError("{0}.{1}{2}", clazz, name, sig);
d3213 1
a3213 1
	public IntPtr MakeLocalRef(object obj)
d3215 1
a3215 1
		if(obj == null)
d3217 6
a3222 1
			return IntPtr.Zero;
d3224 2
a3225 7
		int i = quickLocalIndex & JNIEnv.LOCAL_REF_MASK;
		if(i < quickLocals.Length)
		{
			quickLocals[i] = obj;
			return (IntPtr)quickLocalIndex++;
		}
		else if(i < JNIEnv.LOCAL_REF_BUCKET_SIZE)
d3227 1
a3227 14
			object[] tmp = new object[quickLocals.Length * 2];
			Array.Copy(quickLocals, 0, tmp, 0, quickLocals.Length);
			quickLocals = tmp;
			object[][] localRefs = (object[][])pJNIEnv->localRefs.Target;
			localRefs[pJNIEnv->localRefSlot] = quickLocals;
			quickLocals[i] = obj;
			return (IntPtr)quickLocalIndex++;
		}
		else
		{
			// this can't happen, because LOCAL_REF_BUCKET_SIZE is larger than the maximum number of object
			// references that can be required by a native method call (256 arguments + a class reference)
			JVM.CriticalFailure("JniFrame.MakeLocalRef cannot spill into next slot", null);
			return IntPtr.Zero;
d3231 1
a3231 1
	public object UnwrapLocalRef(IntPtr p)
d3233 2
a3234 1
		return pJNIEnv->UnwrapRef(p);
@


1.6
log
@*** empty log message ***
@
text
@d31 28
a164 95
[StructLayout(LayoutKind.Sequential)]
struct LocalRefCache
{
	internal object loc1;
	object loc2;
	object loc3;
	object loc4;
	object loc5;
	object loc6;
	object loc7;
	object loc8;
	object loc9;
	object loc10;
}

unsafe struct LocalRefListEntry
{
	internal const int STATIC_LIST_SIZE = 10;
	internal const int LOCAL_REF_SHIFT = 10;
	internal const int BUCKET_SIZE = (1 << LOCAL_REF_SHIFT);
	internal const int LOCAL_REF_MASK = (BUCKET_SIZE - 1);

	[StructLayout(LayoutKind.Explicit)]
	internal struct Union
	{
		[FieldOffset(0)]
		internal Object* static_list;
		[FieldOffset(0)]
		internal void* pv;
	}
	internal Union u;
	internal object[] dynamic_list;

	internal int MakeLocalRef(object o)
	{
		if(u.static_list != null)
		{
			for(int i = 0; i < STATIC_LIST_SIZE; i++)
			{
				if(u.static_list[i] == null)
				{
					u.static_list[i] = o;
					return i;
				}
			}
		} 
		if(dynamic_list == null)
		{
			dynamic_list = new object[32 - STATIC_LIST_SIZE];
		}
		for(int i = 0; i < dynamic_list.Length; i++)
		{
			if(dynamic_list[i] == null)
			{
				dynamic_list[i] = o;
				return i + STATIC_LIST_SIZE;
			}
		}
		int newsize = (dynamic_list.Length + STATIC_LIST_SIZE) * 2 - STATIC_LIST_SIZE;
		if(newsize > BUCKET_SIZE)
		{
			return -1;
		}
		object[] tmp = dynamic_list;
		dynamic_list = new object[newsize];
		Array.Copy(tmp, 0, dynamic_list, 0, tmp.Length);
		dynamic_list[tmp.Length] = o;
		return tmp.Length + STATIC_LIST_SIZE;
	}

	internal void DeleteLocalRef(int i)
	{
		if(i < STATIC_LIST_SIZE)
		{
			u.static_list[i] = null;
		}
		else
		{
			dynamic_list[i - STATIC_LIST_SIZE] = null;
		}
	}

	internal object UnwrapLocalRef(int i)
	{
		if(i < STATIC_LIST_SIZE)
		{
			return u.static_list[i];
		}
		else
		{
			return dynamic_list[i - STATIC_LIST_SIZE];
		}
	}
}

d168 2
d182 1
a182 1
	delegate IntPtr pf_IntPtr_pbyte_IntPtr_pbyte_IntPtr(JNIEnv* pEnv, byte* p1, IntPtr p2, byte* p3, int p4);
d184 1
d192 1
d200 1
d205 1
a205 1
	delegate IntPtr pf_IntPtr_pchar_int(JNIEnv* pEnv, char* p1, int p2);
d207 1
d216 1
d224 1
d231 18
d256 1
a256 1
		void** p = (void**)Marshal.AllocHGlobal(IntPtr.Size * vtableDelegates.Length);
d280 1
a280 1
			new pf_IntPtr_pbyte_IntPtr_pbyte_IntPtr(JNIEnv.DefineClass), //virtual jclass JNICALL DefineClass(const char *name, jobject loader, const jbyte *buf, jsize len);
d299 2
a300 2
			new pf_void(JNIEnv.NotImplemented), //virtual jint JNICALL PushLocalFrame(jint capacity); 
			new pf_void(JNIEnv.NotImplemented), //virtual jobject JNICALL PopLocalFrame(jobject result);
d308 1
a308 1
			new pf_void(JNIEnv.NotImplemented), //virtual jint JNICALL EnsureLocalCapacity(jint capacity);
d334 1
a334 1
			new pf_short_IntPtr_IntPtr_pjvalue(JNIEnv.CallCharMethodA), //virtual jchar JNICALL CallCharMethodA(jobject obj, jmethodID methodID, jvalue *args);
d374 1
a374 1
			new pf_short_IntPtr_IntPtr_IntPtr_pjvalue(JNIEnv.CallNonvirtualCharMethodA), //virtual jchar JNICALL CallNonvirtualCharMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue *args);
d405 1
a405 1
			new pf_short_IntPtr_IntPtr(JNIEnv.GetCharField), //virtual jchar JNICALL GetCharField(jobject obj, jfieldID fieldID);
d415 1
a415 1
			new pf_void_IntPtr_IntPtr_short(JNIEnv.SetCharField), //virtual void JNICALL SetCharField(jobject obj, jfieldID fieldID, jchar val);
d438 1
a438 1
			new pf_short_IntPtr_IntPtr_pjvalue(JNIEnv.CallStaticCharMethodA), //virtual jchar JNICALL CallStaticCharMethodA(jclass clazz, jmethodID methodID, jvalue *args);
d469 1
a469 1
			new pf_short_IntPtr_IntPtr(JNIEnv.GetStaticCharField), //virtual jchar JNICALL GetCharField(jobject obj, jfieldID fieldID);
d479 1
a479 1
			new pf_void_IntPtr_IntPtr_short(JNIEnv.SetStaticCharField), //virtual void JNICALL SetCharField(jobject obj, jfieldID fieldID, jchar val);
d486 1
a486 1
			new pf_IntPtr_pchar_int(JNIEnv.NewString), //virtual jstring JNICALL NewString(const jchar *unicode, jsize len);
d488 2
a489 2
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetStringChars), //virtual const jchar *JNICALL GetStringChars(jstring str, jboolean *isCopy);
			new pf_void_IntPtr_IntPtr(JNIEnv.ReleaseStringChars), //virtual void JNICALL ReleaseStringChars(jstring str, const jchar *chars);
d491 1
a491 1
			new pf_IntPtr_IntPtr(JNIEnv.NewStringUTF), //virtual jstring JNICALL NewStringUTF(const char *utf);
d493 2
a494 2
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetStringUTFChars), //virtual const char* JNICALL GetStringUTFChars(jstring str, jboolean *isCopy);
			new pf_void_IntPtr_IntPtr(JNIEnv.ReleaseStringUTFChars), //virtual void JNICALL ReleaseStringUTFChars(jstring str, const char* chars);
d511 17
a527 17
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetBooleanArrayElements), //virtual jboolean * JNICALL GetBooleanArrayElements(jbooleanArray array, jboolean *isCopy);
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetByteArrayElements), //virtual jbyte * JNICALL GetByteArrayElements(jbyteArray array, jboolean *isCopy);
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetCharArrayElements), //virtual jchar * JNICALL GetCharArrayElements(jcharArray array, jboolean *isCopy);
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetShortArrayElements), //virtual jshort * JNICALL GetShortArrayElements(jshortArray array, jboolean *isCopy);
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetIntArrayElements), //virtual jint * JNICALL GetIntArrayElements(jintArray array, jboolean *isCopy);
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetLongArrayElements), //virtual jlong * JNICALL GetLongArrayElements(jlongArray array, jboolean *isCopy);
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetFloatArrayElements), //virtual jfloat * JNICALL GetFloatArrayElements(jfloatArray array, jboolean *isCopy);
			new pf_IntPtr_IntPtr_IntPtr(JNIEnv.GetDoubleArrayElements), //virtual jdouble * JNICALL GetDoubleArrayElements(jdoubleArray array, jboolean *isCopy);

			new pf_void_IntPtr_IntPtr_int(JNIEnv.ReleaseBooleanArrayElements), //virtual void JNICALL ReleaseBooleanArrayElements(jbooleanArray array, jboolean *elems, jint mode);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.ReleaseByteArrayElements), //virtual void JNICALL ReleaseByteArrayElements(jbyteArray array, jbyte *elems, jint mode);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.ReleaseCharArrayElements), //virtual void JNICALL ReleaseCharArrayElements(jcharArray array, jchar *elems, jint mode);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.ReleaseShortArrayElements), //virtual void JNICALL ReleaseShortArrayElements(jshortArray array, jshort *elems, jint mode);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.ReleaseIntArrayElements), //virtual void JNICALL ReleaseIntArrayElements(jintArray array, jint *elems, jint mode);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.ReleaseLongArrayElements), //virtual void JNICALL ReleaseLongArrayElements(jlongArray array, jlong *elems, jint mode);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.ReleaseFloatArrayElements), //virtual void JNICALL ReleaseFloatArrayElements(jfloatArray array, jfloat *elems, jint mode);
			new pf_void_IntPtr_IntPtr_int(JNIEnv.ReleaseDoubleArrayElements), //virtual void JNICALL ReleaseDoubleArrayElements(jdoubleArray array, jdouble *elems, jint mode);
d564 2
a565 2
			new pf_void(JNIEnv.NotImplemented), //virtual jweak JNICALL NewWeakGlobalRef(jobject obj);
			new pf_void(JNIEnv.NotImplemented), //virtual void JNICALL DeleteWeakGlobalRef(jweak ref);
d599 1
a599 1
		pJavaVM = (JavaVM*)(void*)Marshal.AllocHGlobal(IntPtr.Size * (1 + vtableDelegates.Length));
d669 3
a683 9
	[StructLayout(LayoutKind.Explicit)]
		internal unsafe struct Union
	{
		[FieldOffset(0)]
		internal JniFrame* activeFrame;
		[FieldOffset(0)]
		internal void* pFrame;
	}
	internal Union u;
d794 1
a794 1
	internal static int GetMethodArgs(JNIEnv* pEnv, IntPtr method, byte* sig)
d804 1
a804 1
	internal static int GetVersion(JNIEnv* pEnv)
d809 1
a809 1
	internal static IntPtr DefineClass(JNIEnv* pEnv, byte* name, IntPtr loader, byte* pbuf, int length)
d839 1
a839 1
	internal static IntPtr FindClass(JNIEnv* pEnv, byte* name)
d855 1
a855 1
	internal static IntPtr FromReflectedMethod(JNIEnv* pEnv, IntPtr method)
d862 1
a862 1
	internal static IntPtr FromReflectedField(JNIEnv* pEnv, IntPtr field)
d869 1
a869 1
	internal static IntPtr ToReflectedMethod(JNIEnv* pEnv, IntPtr clazz_ignored, IntPtr method)
d885 1
a885 1
	internal static IntPtr GetSuperclass(JNIEnv* pEnv, IntPtr sub)
d891 1
a891 1
	internal static sbyte IsAssignableFrom(JNIEnv* pEnv, IntPtr sub, IntPtr super)
d898 1
a898 1
	internal static IntPtr ToReflectedField(JNIEnv* pEnv, IntPtr clazz_ignored, IntPtr field)
d912 1
a912 1
	internal static int Throw(JNIEnv* pEnv, IntPtr throwable)
d919 1
a919 1
	internal static int ThrowNew(JNIEnv* pEnv, IntPtr clazz, byte* msg)
d925 1
a925 1
			int rc;
d948 1
a948 1
	internal static IntPtr ExceptionOccurred(JNIEnv* pEnv)
d981 21
a1001 1
	internal static IntPtr NewGlobalRef(JNIEnv* pEnv, IntPtr obj)
d1003 15
a1017 1
		if(obj == IntPtr.Zero)
d1021 13
a1033 2
		// TODO search for an empty slot before adding it to the end...
		return (IntPtr)(-(GlobalRefs.globalRefs.Add(pEnv->UnwrapRef(obj)) + 1));
d1036 1
a1036 1
	internal static void DeleteGlobalRef(JNIEnv* pEnv, IntPtr obj)
d1041 4
a1044 1
			GlobalRefs.globalRefs[(-i) - 1] = null;
d1053 1
a1053 1
	internal LocalRefListEntry[] GetLocalRefs()
d1055 1
a1055 9
		// dereferencing a GCHandle is slow, so this is a small optimization
		if(u.activeFrame != null)
		{
			return u.activeFrame->localRefs;
		}
		else
		{
			return (LocalRefListEntry[])localRefs.Target;
		}
d1058 1
a1058 1
	internal static void DeleteLocalRef(JNIEnv* pEnv, IntPtr obj)
d1063 2
a1064 2
			LocalRefListEntry[] localRefs = pEnv->GetLocalRefs();
			localRefs[i >> LocalRefListEntry.LOCAL_REF_SHIFT].DeleteLocalRef(i & LocalRefListEntry.LOCAL_REF_MASK);
d1073 1
a1073 1
	internal static sbyte IsSameObject(JNIEnv* pEnv, IntPtr obj1, IntPtr obj2)
d1078 1
a1078 1
	internal static IntPtr NewLocalRef(JNIEnv* pEnv, IntPtr obj)
d1083 7
a1089 1
	internal static IntPtr AllocObject(JNIEnv* pEnv, IntPtr clazz)
d1106 1
a1106 1
	internal struct jvalue
d1109 1
a1109 1
		public sbyte b;
d1111 1
a1111 1
		public short s;
d1113 1
a1113 1
		public int i;
d1115 1
a1115 1
		public long j;
d1117 1
a1117 1
		public float f;
d1119 1
a1119 1
		public double d;
d1121 5
a1125 1
		public IntPtr l;
d1128 1
a1128 1
	private static object InvokeHelper(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue *args, bool nonVirtual)
d1137 1
a1137 1
					argarray[i] = args[i].b != 0;
d1143 1
a1143 1
					argarray[i] = (char)args[i].s;
d1176 1
a1176 1
	internal static IntPtr NewObjectA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1181 1
a1181 1
	internal static IntPtr GetObjectClass(JNIEnv* pEnv, IntPtr obj)
d1186 1
a1186 1
	internal static sbyte IsInstanceOf(JNIEnv* pEnv, IntPtr obj, IntPtr clazz)
d1194 1
a1194 1
	private static IntPtr FindMethodID(JNIEnv* pEnv, IntPtr clazz, byte* name, byte* sig, bool isstatic)
d1219 1
a1219 1
	internal static IntPtr GetMethodID(JNIEnv* pEnv, IntPtr clazz, byte* name, byte* sig)
d1224 1
a1224 1
	internal static IntPtr CallObjectMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue* args)
d1229 1
a1229 1
	internal static sbyte CallBooleanMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue* args)
d1239 1
a1239 1
	internal static sbyte CallByteMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue* args)
d1244 1
a1244 1
			return (sbyte)o;
d1249 1
a1249 1
	internal static short CallCharMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue* args)
d1254 1
a1254 1
			return (short)(char)o;
d1259 1
a1259 1
	internal static short CallShortMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue* args)
d1264 1
a1264 1
			return (short)o;
d1269 1
a1269 1
	internal static int CallIntMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue* args)
d1274 1
a1274 1
			return (int)o;
d1279 1
a1279 1
	internal static long CallLongMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue* args)
d1284 1
a1284 1
			return (long)o;
d1289 1
a1289 1
	internal static float CallFloatMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue* args)
d1294 1
a1294 1
			return (float)o;
d1299 1
a1299 1
	internal static double CallDoubleMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue* args)
d1304 1
a1304 1
			return (double)o;
d1309 1
a1309 1
	internal static void CallVoidMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr methodID, jvalue*  args)
d1314 1
a1314 1
	internal static IntPtr CallNonvirtualObjectMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue*  args)
d1319 1
a1319 1
	internal static sbyte CallNonvirtualBooleanMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue*  args)
d1329 1
a1329 1
	internal static sbyte CallNonvirtualByteMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue* args)
d1334 1
a1334 1
			return (sbyte)o;
d1339 1
a1339 1
	internal static short CallNonvirtualCharMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue* args)
d1344 1
a1344 1
			return (short)(char)o;
d1349 1
a1349 1
	internal static short CallNonvirtualShortMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue* args)
d1354 1
a1354 1
			return (short)o;
d1359 1
a1359 1
	internal static int CallNonvirtualIntMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue* args)
d1364 1
a1364 1
			return (int)o;
d1369 1
a1369 1
	internal static long CallNonvirtualLongMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue* args)
d1374 1
a1374 1
			return (long)o;
d1379 1
a1379 1
	internal static float CallNonvirtualFloatMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue* args)
d1384 1
a1384 1
			return (float)o;
d1389 1
a1389 1
	internal static double CallNonvirtualDoubleMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue* args)
d1394 1
a1394 1
			return (double)o;
d1399 1
a1399 1
	internal static void CallNonvirtualVoidMethodA(JNIEnv* pEnv, IntPtr obj, IntPtr clazz, IntPtr methodID, jvalue*  args)
d1404 1
a1404 1
	private static IntPtr FindFieldID(JNIEnv* pEnv, IntPtr clazz, byte* name, byte* sig, bool isstatic)
d1429 1
a1429 1
	internal static IntPtr GetFieldID(JNIEnv* pEnv, IntPtr clazz, byte* name, byte* sig)
d1434 1
a1434 1
	private static void SetFieldValue(IntPtr cookie, object obj, object val)
d1447 1
a1447 1
	private static object GetFieldValue(IntPtr cookie, object obj)
d1460 1
a1460 1
	internal static IntPtr GetObjectField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID)
d1465 1
a1465 1
	internal static sbyte GetBooleanField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID)
d1470 1
a1470 1
	internal static sbyte GetByteField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID)
d1472 1
a1472 1
		return (sbyte)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d1475 1
a1475 1
	internal static short GetCharField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID)
d1477 1
a1477 1
		return (short)(char)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d1480 1
a1480 1
	internal static short GetShortField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID)
d1482 1
a1482 1
		return (short)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d1485 1
a1485 1
	internal static int GetIntField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID)
d1487 1
a1487 1
		return (int)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d1490 1
a1490 1
	internal static long GetLongField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID)
d1492 1
a1492 1
		return (long)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d1495 1
a1495 1
	internal static float GetFloatField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID)
d1497 1
a1497 1
		return (float)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d1500 1
a1500 1
	internal static double GetDoubleField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID)
d1502 1
a1502 1
		return (double)GetFieldValue(fieldID, pEnv->UnwrapRef(obj));
d1505 1
a1505 1
	internal static void SetObjectField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID, IntPtr val)
d1510 1
a1510 1
	internal static void SetBooleanField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID, sbyte val)
d1515 1
a1515 1
	internal static void SetByteField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID, sbyte val)
d1517 1
a1517 1
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), val);
d1520 1
a1520 1
	internal static void SetCharField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID, short val)
d1525 1
a1525 1
	internal static void SetShortField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID, short val)
d1527 1
a1527 1
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), val);
d1530 1
a1530 1
	internal static void SetIntField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID, int val)
d1532 1
a1532 1
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), val);
d1535 1
a1535 1
	internal static void SetLongField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID, long val)
d1537 1
a1537 1
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), val);
d1540 1
a1540 1
	internal static void SetFloatField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID, float val)
d1542 1
a1542 1
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), val);
d1545 1
a1545 1
	internal static void SetDoubleField(JNIEnv* pEnv, IntPtr obj, IntPtr fieldID, double val)
d1547 1
a1547 1
		SetFieldValue(fieldID, pEnv->UnwrapRef(obj), val);
d1550 1
a1550 1
	internal static IntPtr GetStaticMethodID(JNIEnv* pEnv, IntPtr clazz, byte* name, byte* sig)
d1555 1
a1555 1
	internal static IntPtr CallStaticObjectMethodA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1560 1
a1560 1
	internal static sbyte CallStaticBooleanMethodA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1570 1
a1570 1
	internal static sbyte CallStaticByteMethodA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1575 1
a1575 1
			return (sbyte)o;
d1580 1
a1580 1
	internal static short CallStaticCharMethodA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1585 1
a1585 1
			return (short)(char)o;
d1590 1
a1590 1
	internal static short CallStaticShortMethodA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1595 1
a1595 1
			return (short)o;
d1600 1
a1600 1
	internal static int CallStaticIntMethodA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1605 1
a1605 1
			return (int)o;
d1610 1
a1610 1
	internal static long CallStaticLongMethodA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1615 1
a1615 1
			return (long)o;
d1620 1
a1620 1
	internal static float CallStaticFloatMethodA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1625 1
a1625 1
			return (float)o;
d1630 1
a1630 1
	internal static double CallStaticDoubleMethodA(JNIEnv* pEnv, IntPtr clazz, IntPtr methodID, jvalue *args)
d1635 1
a1635 1
			return (double)o;
d1640 1
a1640 1
	internal static void CallStaticVoidMethodA(JNIEnv* pEnv, IntPtr cls, IntPtr methodID, jvalue * args)
d1645 1
a1645 1
	internal static IntPtr GetStaticFieldID(JNIEnv* pEnv, IntPtr clazz, byte* name, byte* sig)
d1650 1
a1650 1
	internal static IntPtr GetStaticObjectField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID)
d1655 1
a1655 1
	internal static sbyte GetStaticBooleanField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID)
d1660 1
a1660 1
	internal static sbyte GetStaticByteField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID)
d1662 1
a1662 1
		return (sbyte)GetFieldValue(fieldID, null);
d1665 1
a1665 1
	internal static short GetStaticCharField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID)
d1667 1
a1667 1
		return (short)(char)GetFieldValue(fieldID, null);
d1670 1
a1670 1
	internal static short GetStaticShortField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID)
d1672 1
a1672 1
		return (short)GetFieldValue(fieldID, null);
d1675 1
a1675 1
	internal static int GetStaticIntField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID)
d1677 1
a1677 1
		return (int)GetFieldValue(fieldID, null);
d1680 1
a1680 1
	internal static long GetStaticLongField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID)
d1682 1
a1682 1
		return (long)GetFieldValue(fieldID, null);
d1685 1
a1685 1
	internal static float GetStaticFloatField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID)
d1687 1
a1687 1
		return (float)GetFieldValue(fieldID, null);
d1690 1
a1690 1
	internal static double GetStaticDoubleField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID)
d1692 1
a1692 1
		return (double)GetFieldValue(fieldID, null);
d1695 1
a1695 1
	internal static void SetStaticObjectField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID, IntPtr val)
d1700 1
a1700 1
	internal static void SetStaticBooleanField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID, sbyte val)
d1705 1
a1705 1
	internal static void SetStaticByteField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID, sbyte val)
d1707 1
a1707 1
		SetFieldValue(fieldID, null, val);
d1710 1
a1710 1
	internal static void SetStaticCharField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID, short val)
d1715 1
a1715 1
	internal static void SetStaticShortField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID, short val)
d1717 1
a1717 1
		SetFieldValue(fieldID, null, val);
d1720 1
a1720 1
	internal static void SetStaticIntField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID, int val)
d1722 1
a1722 1
		SetFieldValue(fieldID, null, val);
d1725 1
a1725 1
	internal static void SetStaticLongField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID, long val)
d1727 1
a1727 1
		SetFieldValue(fieldID, null, val);
d1730 1
a1730 1
	internal static void SetStaticFloatField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID, float val)
d1732 1
a1732 1
		SetFieldValue(fieldID, null, val);
d1735 1
a1735 1
	internal static void SetStaticDoubleField(JNIEnv* pEnv, IntPtr clazz, IntPtr fieldID, double val)
d1737 1
a1737 1
		SetFieldValue(fieldID, null, val);
d1740 1
a1740 1
	internal static IntPtr NewString(JNIEnv* pEnv, char* unicode, int len)
d1742 1
a1742 1
		return pEnv->MakeLocalRef(new String(unicode, 0, len));
d1745 1
a1745 1
	internal static int GetStringLength(JNIEnv* pEnv, IntPtr str)
d1750 1
a1750 1
	internal static IntPtr GetStringChars(JNIEnv* pEnv, IntPtr str, IntPtr isCopy)
d1753 1
a1753 1
		if(isCopy != IntPtr.Zero)
d1755 1
a1755 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1757 1
a1757 1
		return Marshal.StringToHGlobalUni(s);
d1760 1
a1760 1
	internal static void ReleaseStringChars(JNIEnv* pEnv, IntPtr str, IntPtr chars)
d1762 1
a1762 1
		Marshal.FreeHGlobal(chars);
d1765 1
a1765 1
	internal static IntPtr NewStringUTF(JNIEnv* pEnv, IntPtr psz)
d1767 1
a1767 1
		return pEnv->MakeLocalRef(StringFromUTF8((byte*)(void*)psz));
d1770 1
a1770 1
	internal static int GetStringUTFLength(JNIEnv* pEnv, IntPtr str)
d1775 1
a1775 1
	internal static IntPtr GetStringUTFChars(JNIEnv* pEnv, IntPtr str, IntPtr isCopy)
d1778 1
a1778 1
		byte* buf = (byte*)Marshal.AllocHGlobal(StringUTF8Length(s) + 1);
d1800 1
a1800 1
		if(isCopy != IntPtr.Zero)
d1802 1
a1802 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1804 1
a1804 1
		return (IntPtr)(void*)buf;
d1807 1
a1807 1
	internal static void ReleaseStringUTFChars(JNIEnv* pEnv, IntPtr str, IntPtr chars)
d1809 1
a1809 1
		Marshal.FreeHGlobal(chars);
d1812 1
a1812 1
	internal static int GetArrayLength(JNIEnv* pEnv, IntPtr array)
d1817 1
a1817 1
	internal static IntPtr NewObjectArray(JNIEnv* pEnv, int len, IntPtr clazz, IntPtr init)
d1832 1
a1832 1
	internal static IntPtr GetObjectArrayElement(JNIEnv* pEnv, IntPtr array, int index)
d1846 1
a1846 1
	internal static void SetObjectArrayElement(JNIEnv* pEnv, IntPtr array, int index, IntPtr val)
d1859 1
a1859 1
	internal static IntPtr NewBooleanArray(JNIEnv* pEnv, int len)
d1864 1
a1864 1
	internal static IntPtr NewByteArray(JNIEnv* pEnv, int len)
d1869 1
a1869 1
	internal static IntPtr NewCharArray(JNIEnv* pEnv, int len)
d1874 1
a1874 1
	internal static IntPtr NewShortArray(JNIEnv* pEnv, int len)
d1879 1
a1879 1
	internal static IntPtr NewIntArray(JNIEnv* pEnv, int len)
d1884 1
a1884 1
	internal static IntPtr NewLongArray(JNIEnv* pEnv, int len)
d1889 1
a1889 1
	internal static IntPtr NewFloatArray(JNIEnv* pEnv, int len)
d1894 1
a1894 1
	internal static IntPtr NewDoubleArray(JNIEnv* pEnv, int len)
d1899 1
a1899 1
	internal static IntPtr GetBooleanArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
d1902 1
a1902 2
		IntPtr buf = Marshal.AllocHGlobal(b.Length * 1);
		sbyte* p = (sbyte*)(void*)buf;
d1905 1
a1905 1
			*p++ = b[i] ? JNI_TRUE : JNI_FALSE;
d1907 1
a1907 1
		if(isCopy != IntPtr.Zero)
d1909 1
a1909 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1911 1
a1911 1
		return buf;
d1914 1
a1914 1
	internal static IntPtr GetByteArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
d1917 1
a1917 2
		IntPtr buf = Marshal.AllocHGlobal(b.Length * 1);
		sbyte* p = (sbyte*)(void*)buf;
d1920 1
a1920 1
			*p++ = b[i];
d1922 1
a1922 1
		if(isCopy != IntPtr.Zero)
d1924 1
a1924 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1926 1
a1926 1
		return buf;
d1929 1
a1929 1
	internal static IntPtr GetCharArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
d1932 1
a1932 1
		IntPtr buf = Marshal.AllocHGlobal(b.Length * 2);
d1934 1
a1934 1
		if(isCopy != IntPtr.Zero)
d1936 1
a1936 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1938 1
a1938 1
		return buf;
d1941 1
a1941 1
	internal static IntPtr GetShortArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
d1944 1
a1944 1
		IntPtr buf = Marshal.AllocHGlobal(b.Length * 2);
d1946 1
a1946 1
		if(isCopy != IntPtr.Zero)
d1948 1
a1948 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1950 1
a1950 1
		return buf;
d1953 1
a1953 1
	internal static IntPtr GetIntArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
d1956 1
a1956 1
		IntPtr buf = Marshal.AllocHGlobal(b.Length * 4);
d1958 1
a1958 1
		if(isCopy != IntPtr.Zero)
d1960 1
a1960 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1962 1
a1962 1
		return buf;
d1965 1
a1965 1
	internal static IntPtr GetLongArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
d1968 1
a1968 1
		IntPtr buf = Marshal.AllocHGlobal(b.Length * 8);
d1970 1
a1970 1
		if(isCopy != IntPtr.Zero)
d1972 1
a1972 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1974 1
a1974 1
		return buf;
d1977 1
a1977 1
	internal static IntPtr GetFloatArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
d1980 1
a1980 1
		IntPtr buf = Marshal.AllocHGlobal(b.Length * 4);
d1982 1
a1982 1
		if(isCopy != IntPtr.Zero)
d1984 1
a1984 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1986 1
a1986 1
		return buf;
d1989 1
a1989 1
	internal static IntPtr GetDoubleArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr isCopy)
d1992 1
a1992 1
		IntPtr buf = Marshal.AllocHGlobal(b.Length * 8);
d1994 1
a1994 1
		if(isCopy != IntPtr.Zero)
d1996 1
a1996 1
			*((sbyte*)(void*)isCopy) = JNI_TRUE;
d1998 1
a1998 1
		return buf;
d2001 1
a2001 1
	internal static void ReleaseBooleanArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr elems, int mode)
a2005 1
			sbyte* p = (sbyte*)(void*)elems;
d2008 1
a2008 1
				b[i] = *p++ != JNI_FALSE;
d2013 1
a2013 1
			Marshal.FreeHGlobal(elems);
d2017 1
a2017 1
	internal static void ReleaseByteArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr elems, int mode)
a2021 1
			sbyte* p = (sbyte*)(void*)elems;
d2024 1
a2024 1
				b[i] = *p++;
d2029 1
a2029 1
			Marshal.FreeHGlobal(elems);
d2033 1
a2033 1
	internal static void ReleaseCharArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr elems, int mode)
d2038 1
a2038 1
			Marshal.Copy(elems, b, 0, b.Length);
d2042 1
a2042 1
			Marshal.FreeHGlobal(elems);
d2046 1
a2046 1
	internal static void ReleaseShortArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr elems, int mode)
d2051 1
a2051 1
			Marshal.Copy(elems, b, 0, b.Length);
d2055 1
a2055 1
			Marshal.FreeHGlobal(elems);
d2059 1
a2059 1
	internal static void ReleaseIntArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr elems, int mode)
d2064 1
a2064 1
			Marshal.Copy(elems, b, 0, b.Length);
d2068 1
a2068 1
			Marshal.FreeHGlobal(elems);
d2072 1
a2072 1
	internal static void ReleaseLongArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr elems, int mode)
d2077 1
a2077 1
			Marshal.Copy(elems, b, 0, b.Length);
d2081 1
a2081 1
			Marshal.FreeHGlobal(elems);
d2085 1
a2085 1
	internal static void ReleaseFloatArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr elems, int mode)
d2090 1
a2090 1
			Marshal.Copy(elems, b, 0, b.Length);
d2094 1
a2094 1
			Marshal.FreeHGlobal(elems);
d2098 1
a2098 1
	internal static void ReleaseDoubleArrayElements(JNIEnv* pEnv, IntPtr array, IntPtr elems, int mode)
d2103 1
a2103 1
			Marshal.Copy(elems, b, 0, b.Length);
d2107 1
a2107 1
			Marshal.FreeHGlobal(elems);
d2224 1
a2224 1
	internal struct JNINativeMethod
d2413 1
a2413 1
			IntPtr hglobal = Marshal.AllocHGlobal(len);
d2457 1
a2457 1
			Marshal.FreeHGlobal(carray);
d2481 44
d2541 11
a2551 3
		LocalRefListEntry[] localRefs = GetLocalRefs();
		int i = localRefs[localRefSlot].MakeLocalRef(obj);
		if(i >= 0)
d2553 6
a2558 1
			return (IntPtr)((localRefSlot << LocalRefListEntry.LOCAL_REF_SHIFT) + i);
d2571 2
a2572 2
			LocalRefListEntry[] localRefs = GetLocalRefs();
			return localRefs[i >> LocalRefListEntry.LOCAL_REF_SHIFT].UnwrapLocalRef(i & LocalRefListEntry.LOCAL_REF_MASK);
d2576 15
a2590 1
			return GlobalRefs.globalRefs[(-i) - 1];
d2596 18
a2619 1
[StructLayout(LayoutKind.Sequential)]
a2622 3
	private JniFrame* pPrevFrame;
	private LocalRefCache fastlocalrefs;
	internal LocalRefListEntry[] localRefs;
d2624 3
a2626 12
	// HACK since this isn't a blittable type and C# doesn't allow us to turn the this pointer into a JniFrame*, we need
	// this hack to turn the address of a field into a pointer to the struct (it turns out that on the 1.1 CLR the address
	// of the first field is not equal to the this pointer [for this particular struct])
	private static readonly int jniFramePointerAdjustment = (int)new JNIEnv.Union().activeFrame->GetAddress();

	private byte* GetAddress()
	{
		fixed(void* p = &pJNIEnv)
		{
			return (byte*)p;
		}
	}
d2632 1
d2636 1
a2636 1
			pJNIEnv = TlsHack.pJNIEnv = (JNIEnv*)Marshal.AllocHGlobal(sizeof(JNIEnv));
d2638 5
a2642 2
			pJNIEnv->u.activeFrame = null;
			localRefs = new LocalRefListEntry[32];
d2649 1
a2649 1
			localRefs = (LocalRefListEntry[])pJNIEnv->localRefs.Target;
d2651 1
a2651 2
		pPrevFrame = pJNIEnv->u.activeFrame;
		pJNIEnv->u.pFrame = GetAddress() - jniFramePointerAdjustment;
d2655 3
a2657 2
			// TODO instead of bailing out, we should grow the array
			JVM.CriticalFailure("JNI nesting too deep", null);
d2659 1
a2659 1
		fixed(void* p = &pPrevFrame)
d2661 1
a2661 2
			// HACK we assume that the fastlocalrefs struct starts at &pPrevFrame + IntPtr.Size
			localRefs[pJNIEnv->localRefSlot].u.pv = ((byte*)p) + IntPtr.Size;
d2663 2
d2672 9
a2680 5
		pJNIEnv->u.activeFrame = pPrevFrame;
		localRefs[pJNIEnv->localRefSlot].dynamic_list = null;
		// TODO figure out if it is legal to Leave a JNI method while PushLocalFrame is active
		// (i.e. without the corresponding PopLocalFrame)
		pJNIEnv->localRefSlot--;
d2795 27
a2821 1
		return pJNIEnv->MakeLocalRef(obj);
@


1.5
log
@*** empty log message ***
@
text
@d33 1
d36 1
d39 1
d42 1
d45 1
d48 1
d172 1
a172 1
		for(int i = 0; i < STATIC_LIST_SIZE; i++)
d174 1
a174 1
			if(u.static_list[i] == null)
d176 5
a180 2
				u.static_list[i] = o;
				return i;
d182 1
a182 1
		}
d1052 13
d1070 2
a1071 1
			pEnv->u.activeFrame->localRefs[i >> LocalRefListEntry.LOCAL_REF_SHIFT].DeleteLocalRef(i & LocalRefListEntry.LOCAL_REF_MASK);
d2494 14
a2507 1
		return u.activeFrame->MakeLocalRef(obj);
d2515 2
a2516 1
			return u.activeFrame->UnwrapLocalRef(o);
d2711 1
a2711 13
		if(obj == null)
		{
			return IntPtr.Zero;
		}
		int i = localRefs[pJNIEnv->localRefSlot].MakeLocalRef(obj);
		if(i >= 0)
		{
			return (IntPtr)((pJNIEnv->localRefSlot << LocalRefListEntry.LOCAL_REF_SHIFT) + i);
		}
		// TODO consider allocating a new slot (if we do this, the code in
		// PushLocalFrame/PopLocalFrame (and Leave) must be fixed to take this into account)
		JVM.CriticalFailure("Too many JNI local references", null);
		return IntPtr.Zero;
d2716 1
a2716 2
		int i = p.ToInt32();
		return localRefs[i >> LocalRefListEntry.LOCAL_REF_SHIFT].UnwrapLocalRef(i & LocalRefListEntry.LOCAL_REF_MASK);
@


1.4
log
@*** empty log message ***
@
text
@d81 1
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002 Jeroen Frijters
d25 1
d31 1
a31 1
public sealed class JniHelper
d33 2056
a2088 2
	// NOTE sig contains slashed class names
	public static IntPtr GetMethodCookie(object clazz, string name, string sig, bool isStatic)
d2090 3
a2092 1
		try
d2094 1
a2094 11
			TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(clazz);
			MethodWrapper mw = wrapper.GetMethodWrapper(new MethodDescriptor(name, sig.Replace('/', '.')), true);
			if(mw != null)
			{
				if(mw.IsStatic == isStatic)
				{
					mw.Link();
					return mw.Cookie;
				}
			}
			return (IntPtr)0;
d2096 7
a2102 1
		catch
d2104 1
a2104 2
			Debug.Assert(false);
			throw;
d2108 37
a2144 6
	// this method returns a simplified method argument descriptor.
	// some examples:
	// "()V" -> ""
	// "(ILjava.lang.String;)I" -> "IL"
	// "([Ljava.lang.String;)V" -> "L"
	public static string GetMethodArgList(IntPtr cookie)
d2146 3
a2148 1
		try
d2150 1
a2150 25
			StringBuilder sb = new StringBuilder();
			string s = MethodWrapper.FromCookie(cookie).Signature;
			for(int i = 1;; i++)
			{
				switch(s[i])
				{
					case '[':
						while(s[i] == '[') i++;
						if(s[i] == 'L')
						{
							while(s[i] != ';') i++;
						}
						sb.Append('L');
						break;
					case 'L':
						while(s[i] != ';') i++;
						sb.Append('L');
						break;
					case ')':
						return sb.ToString();
					default:
						sb.Append(s[i]);
						break;
				}
			}
d2152 7
a2158 1
		catch
d2160 1
a2160 2
			Debug.Assert(false);
			throw;
d2164 45
a2208 1
	public static object InvokeMethod(IntPtr cookie, object obj, object[] args, bool nonVirtual)
d2212 13
a2224 1
			return MethodWrapper.FromCookie(cookie).Invoke(obj, args, nonVirtual);
d2228 2
a2229 1
			throw ExceptionHelper.MapExceptionFast(x);
d2233 1
a2233 2
	// NOTE sig contains slashed class names
	public static IntPtr GetFieldCookie(object clazz, string name, string sig, bool isStatic)
d2237 1
a2237 1
			TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(clazz);
d2239 1
a2239 3
			// TODO what about searching the base classes?
			FieldWrapper fw = wrapper.GetFieldWrapper(name, wrapper.GetClassLoader().ExpressionTypeWrapper(sig.Replace('/', '.')));
			if(fw != null)
d2241 1
a2241 1
				if(fw.IsStatic == isStatic)
d2243 1
a2243 1
					return fw.Cookie;
d2246 1
a2246 1
			return (IntPtr)0;
d2248 1
a2248 1
		catch
d2250 2
a2251 2
			Debug.Assert(false);
			throw;
d2255 1
a2255 1
	public static void SetFieldValue(IntPtr cookie, object obj, object val)
d2259 2
a2260 1
			FieldWrapper.FromCookie(cookie).SetValue(obj, val);
d2262 1
a2262 1
		catch
d2264 2
a2265 2
			Debug.Assert(false);
			throw;
d2269 1
a2269 1
	public static object GetFieldValue(IntPtr cookie, object obj)
d2273 2
a2274 1
			return FieldWrapper.FromCookie(cookie).GetValue(obj);
d2276 1
a2276 1
		catch
d2278 2
a2279 2
			Debug.Assert(false);
			throw;
d2283 7
a2289 1
	public static object FindClass(string javaName)
d2291 2
a2292 1
		try
d2294 15
a2308 4
			// TODO instead of using the bootstrap class loader, we need to use the system (aka application) class loader
			TypeWrapper wrapper = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(javaName.Replace('/', '.'));
			wrapper.Finish();
			return NativeCode.java.lang.VMClass.getClassFromWrapper(wrapper);
d2310 1
a2310 1
		catch
d2312 1
a2312 2
			Debug.Assert(false);
			throw;
d2316 1
a2316 1
	public static Exception UnsatisfiedLinkError(string msg)
d2318 2
a2319 1
		try
d2321 29
a2349 1
			return JavaException.UnsatisfiedLinkError(msg);
d2351 1
a2351 1
		catch
d2353 1
a2353 2
			Debug.Assert(false);
			throw;
d2357 1
a2357 2
	[Obsolete]
	public static object GetClassFromType(Type type)
d2359 14
a2372 1
		try
d2374 1
a2374 1
			return NativeCode.java.lang.VMClass.getClassFromType(type);
d2376 1
a2376 1
		catch
d2378 2
a2379 2
			Debug.Assert(false);
			throw;
d2383 1
a2383 1
	public static object GetObjectClass(object o)
d2385 3
d2390 13
a2402 1
			return NativeCode.java.lang.VMClass.getClassFromType(o.GetType());
d2404 1
a2404 1
		catch
d2406 2
a2407 3
			Debug.Assert(false);
			throw;
		}
d2410 1
a2410 1
	public static bool IsInstanceOf(object o, object clazz)
d2412 1
a2412 1
		try
d2414 17
a2430 1
			return IsAssignableFrom(clazz, GetObjectClass(o));
d2432 1
a2432 1
		catch
d2434 1
a2434 2
			Debug.Assert(false);
			throw;
d2438 1
a2438 1
	public static bool IsAssignableFrom(object sub, object sup)
d2440 2
a2441 1
		try
d2443 5
a2447 8
			TypeWrapper w1 = NativeCode.java.lang.VMClass.getWrapperFromClass(sub);
			TypeWrapper w2 = NativeCode.java.lang.VMClass.getWrapperFromClass(sup);
			return w2.IsAssignableTo(w1);
		}
		catch
		{
			Debug.Assert(false);
			throw;
d2449 22
d2472 2
a2473 2
	
	public static object GetSuperclass(object clazz)
d2475 2
a2476 1
		try
d2478 1
a2478 2
			TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(clazz).BaseTypeWrapper;
			return wrapper == null ? null : NativeCode.java.lang.VMClass.getClassFromWrapper(wrapper);
d2480 1
a2480 1
		catch
d2482 1
a2482 2
			Debug.Assert(false);
			throw;
d2484 1
d2486 20
d2507 1
a2507 1
	public static object AllocObject(object clazz)
d2509 1
a2509 8
		try
		{
			TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(clazz);
			wrapper.Finish();
			// TODO add error handling (e.g. when trying to instantiate an interface or abstract class)
			return System.Runtime.Serialization.FormatterServices.GetUninitializedObject(wrapper.TypeAsBaseType);
		}
		catch
d2511 1
a2511 2
			Debug.Assert(false);
			throw;
d2515 1
a2515 1
	public static IntPtr MethodToCookie(object method)
d2517 21
a2537 1
		try
d2539 2
a2540 2
			MethodWrapper mw = (MethodWrapper)method.GetType().GetField("methodCookie", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(method);
			return mw.Cookie;
d2542 1
a2542 1
		catch
d2544 2
a2545 2
			Debug.Assert(false);
			throw;
d2547 1
d2550 1
a2550 1
	public static IntPtr FieldToCookie(object field)
d2552 8
a2559 6
		try
		{
			FieldWrapper fw = (FieldWrapper)field.GetType().GetField("fieldCookie", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(field);
			return fw.Cookie;
		}
		catch
d2561 1
a2561 2
			Debug.Assert(false);
			throw;
d2565 1
a2565 1
	public static object CookieToMethod(IntPtr method)
d2567 81
a2647 1
		try
d2649 2
a2650 3
			MethodWrapper mw = MethodWrapper.FromCookie(method);
			TypeWrapper tw;
			if(mw.Name == "<init>")
d2652 5
a2656 1
				tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.reflect.Constructor");
d2658 2
a2659 1
			else
d2661 5
a2665 1
				tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.reflect.Method");
a2666 7
			object clazz = NativeCode.java.lang.VMClass.getClassFromWrapper(mw.DeclaringType);
			return Activator.CreateInstance(tw.TypeAsTBD, new object[] { clazz, mw });
		}
		catch
		{
			Debug.Assert(false);
			throw;
d2668 1
d2671 1
a2671 1
	public static object CookieToField(IntPtr field)
d2673 1
a2673 1
		try
d2675 1
a2675 4
			FieldWrapper fw = FieldWrapper.FromCookie(field);
			TypeWrapper tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName("java.lang.reflect.Field");
			object clazz = NativeCode.java.lang.VMClass.getClassFromWrapper(fw.DeclaringType);
			return Activator.CreateInstance(tw.TypeAsTBD, new object[] { clazz, fw });
d2677 2
a2678 1
		catch
d2680 1
a2680 2
			Debug.Assert(false);
			throw;
d2682 4
d2688 1
a2688 6
	public static void FatalError(string msg)
	{
		JVM.CriticalFailure(msg, null);
	}

	public static object DefineClass(string name, object classLoader, byte[] buf)
d2690 2
a2691 2
		// TODO what should the protection domain be?
		return NativeCode.java.lang.VMClassLoader.defineClass(classLoader, name, buf, 0, buf.Length, null);
a2693 10

public interface IJniProvider
{
	int LoadNativeLibrary(string filename);
	Type GetLocalRefStructType();
	// NOTE the signature of the GetJniFuncPtr method is:
	//  IntPtr GetJniFuncPtr(String method, String sig, String clazz)
	// sig & clazz are contain slashed class names
	MethodInfo GetJniFuncPtrMethod();
}
@


1.2
log
@*** empty log message ***
@
text
@d25 1
d35 1
a35 4
		TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(clazz);
		wrapper.Finish();
		MethodWrapper mw = wrapper.GetMethodWrapper(MethodDescriptor.FromNameSig(wrapper.GetClassLoader(), name, sig.Replace('/', '.')), true);
		if(mw != null)
d37 3
a39 1
			if(mw.IsStatic == isStatic)
d41 5
a45 1
				return mw.Cookie;
d47 6
a53 1
		return (IntPtr)0;
d63 1
a63 3
		StringBuilder sb = new StringBuilder();
		string s = MethodWrapper.FromCookie(cookie).Descriptor.Signature;
		for(int i = 1;; i++)
d65 3
a67 1
			switch(s[i])
d69 11
a79 4
				case '[':
					while(s[i] == '[') i++;
					if(s[i] == 'L')
					{
d81 8
a88 12
					}
					sb.Append('L');
					break;
				case 'L':
					while(s[i] != ';') i++;
					sb.Append('L');
					break;
				case ')':
					return sb.ToString();
				default:
					sb.Append(s[i]);
					break;
d91 5
d100 8
a107 1
		return MethodWrapper.FromCookie(cookie).Invoke(obj, args, nonVirtual);
d113 1
a113 5
		TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(clazz);
		wrapper.Finish();
		// TODO what about searching the base classes?
		FieldWrapper fw = wrapper.GetFieldWrapper(name, wrapper.GetClassLoader().ExpressionTypeWrapper(sig.Replace('/', '.')));
		if(fw != null)
d115 5
a119 1
			if(fw.IsStatic == isStatic)
d121 4
a124 1
				return fw.Cookie;
d126 6
a132 1
		return (IntPtr)0;
d137 9
a145 1
		FieldWrapper.FromCookie(cookie).SetValue(obj, val);
d150 9
a158 1
		return FieldWrapper.FromCookie(cookie).GetValue(obj);
d163 12
a174 4
		// TODO instead of using the bootstrap class loader, we need to use the system (aka application) class loader
		TypeWrapper wrapper = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(javaName.Replace('/', '.'));
		wrapper.Finish();
		return NativeCode.java.lang.VMClass.getClassFromWrapper(wrapper);
d179 9
a187 1
		return JavaException.UnsatisfiedLinkError(msg);
d190 1
d193 64
a256 1
		return NativeCode.java.lang.VMClass.getClassFromType(type);
d261 91
a351 4
		TypeWrapper wrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(clazz);
		wrapper.Finish();
		// TODO add error handling (e.g. when trying to instantiate an interface or abstract class)
		return System.Runtime.Serialization.FormatterServices.GetUninitializedObject(wrapper.TypeAsBaseType);
@


1.1
log
@*** empty log message ***
@
text
@d135 2
a136 2
		// TODO if we're instantiating a remapping type, we need to use TypeAsBaseType (except for String)
		return System.Runtime.Serialization.FormatterServices.GetUninitializedObject(wrapper.TypeAsTBD);
@

