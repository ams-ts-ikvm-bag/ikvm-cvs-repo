head	1.280;
access;
symbols
	v8_1_5717_0:1.280
	v8_1:1.280.0.2
	v8_0_5449_1:1.259
	v8_0_5449_0:1.259
	v8_0:1.259.0.2
	v7_4_5196_0:1.222
	v7_4:1.222.0.2
	v7_3:1.188.0.2
	v7_2_4630_6:1.140.2.4
	v7_2_4630_5:1.140.2.3
	v7_2_4630_4:1.140.2.2
	v7_2_4630_3:1.140.2.1
	v7_2_4630_2:1.140.2.1
	v0_46_0_4:1.40.2.8
	v7_2_4630_1:1.140
	v7_2:1.140.0.2
	v7_1_4532_2:1.127
	v7_1_4532_1:1.127
	v7_1_4532_0:1.127
	v7_1:1.127.0.2
	v7_0_4335_3:1.58
	v7_0_4335_2:1.58
	v7_0_4335_1:1.58
	v0_46_0_2:1.40.2.7
	v7_0_4335_0:1.58
	v7_0:1.58.0.2
	v0_46_0_1:1.40
	v0_46_0_0:1.40
	v0_46:1.40.0.2
	v0_44_0_6:1.27.2.2
	v0_44_0_5:1.27.2.1
	v0_44_0_4:1.27
	v0_44_0_3:1.27
	v0_44_0_2:1.27
	v0_42_0_7:1.5.2.3
	v0_44_0_1:1.27
	v0_44_0_0:1.27
	v0_44:1.27.0.2
	v0_42_0_6:1.5.2.3
	v0_42_0_5:1.5.2.3
	v0_42_0_4:1.5.2.2
	v0_42_0_3:1.5.2.1
	v0_42_0_2:1.5.2.1
	v0_42_0_1:1.5.2.1
	v0_42_0_0:1.5
	v0_42:1.5.0.2;
locks; strict;
comment	@ * @;


1.280
date	2015.07.02.07.21.18;	author jfrijters;	state Exp;
branches;
next	1.279;

1.279
date	2015.06.30.10.18.05;	author jfrijters;	state Exp;
branches;
next	1.278;

1.278
date	2015.06.29.10.15.15;	author jfrijters;	state Exp;
branches;
next	1.277;

1.277
date	2015.06.29.10.12.11;	author jfrijters;	state Exp;
branches;
next	1.276;

1.276
date	2015.06.26.11.26.44;	author jfrijters;	state Exp;
branches;
next	1.275;

1.275
date	2015.06.26.11.22.19;	author jfrijters;	state Exp;
branches;
next	1.274;

1.274
date	2015.06.22.10.55.23;	author jfrijters;	state Exp;
branches;
next	1.273;

1.273
date	2015.03.24.09.39.11;	author jfrijters;	state Exp;
branches;
next	1.272;

1.272
date	2015.03.24.09.37.25;	author jfrijters;	state Exp;
branches;
next	1.271;

1.271
date	2015.03.24.09.31.46;	author jfrijters;	state Exp;
branches;
next	1.270;

1.270
date	2015.03.22.07.48.10;	author jfrijters;	state Exp;
branches;
next	1.269;

1.269
date	2015.03.21.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.268;

1.268
date	2015.03.18.08.36.26;	author jfrijters;	state Exp;
branches;
next	1.267;

1.267
date	2015.03.18.08.34.17;	author jfrijters;	state Exp;
branches;
next	1.266;

1.266
date	2015.03.12.14.46.14;	author jfrijters;	state Exp;
branches;
next	1.265;

1.265
date	2015.03.11.11.25.19;	author jfrijters;	state Exp;
branches;
next	1.264;

1.264
date	2015.03.11.08.39.03;	author jfrijters;	state Exp;
branches;
next	1.263;

1.263
date	2015.03.09.13.54.34;	author jfrijters;	state Exp;
branches;
next	1.262;

1.262
date	2015.03.09.13.35.34;	author jfrijters;	state Exp;
branches;
next	1.261;

1.261
date	2015.03.09.12.35.40;	author jfrijters;	state Exp;
branches;
next	1.260;

1.260
date	2015.02.16.11.09.00;	author jfrijters;	state Exp;
branches;
next	1.259;

1.259
date	2014.11.18.11.33.36;	author jfrijters;	state Exp;
branches;
next	1.258;

1.258
date	2014.11.11.15.37.09;	author jfrijters;	state Exp;
branches;
next	1.257;

1.257
date	2014.11.11.15.28.48;	author jfrijters;	state Exp;
branches;
next	1.256;

1.256
date	2014.11.11.15.27.34;	author jfrijters;	state Exp;
branches;
next	1.255;

1.255
date	2014.11.11.15.03.18;	author jfrijters;	state Exp;
branches;
next	1.254;

1.254
date	2014.07.08.08.23.41;	author jfrijters;	state Exp;
branches;
next	1.253;

1.253
date	2014.07.04.11.06.06;	author jfrijters;	state Exp;
branches;
next	1.252;

1.252
date	2014.07.01.15.12.34;	author jfrijters;	state Exp;
branches;
next	1.251;

1.251
date	2014.06.24.08.26.13;	author jfrijters;	state Exp;
branches;
next	1.250;

1.250
date	2014.06.13.06.54.06;	author jfrijters;	state Exp;
branches;
next	1.249;

1.249
date	2014.06.10.11.13.50;	author jfrijters;	state Exp;
branches;
next	1.248;

1.248
date	2014.06.05.12.38.09;	author jfrijters;	state Exp;
branches;
next	1.247;

1.247
date	2014.06.05.11.08.57;	author jfrijters;	state Exp;
branches;
next	1.246;

1.246
date	2014.06.03.14.28.37;	author jfrijters;	state Exp;
branches;
next	1.245;

1.245
date	2014.06.03.12.42.19;	author jfrijters;	state Exp;
branches;
next	1.244;

1.244
date	2014.06.03.12.04.42;	author jfrijters;	state Exp;
branches;
next	1.243;

1.243
date	2014.06.03.09.13.56;	author jfrijters;	state Exp;
branches;
next	1.242;

1.242
date	2014.06.03.07.15.52;	author jfrijters;	state Exp;
branches;
next	1.241;

1.241
date	2014.05.27.12.32.26;	author jfrijters;	state Exp;
branches;
next	1.240;

1.240
date	2014.05.21.07.21.21;	author jfrijters;	state Exp;
branches;
next	1.239;

1.239
date	2014.05.19.12.43.42;	author jfrijters;	state Exp;
branches;
next	1.238;

1.238
date	2014.05.14.07.39.32;	author jfrijters;	state Exp;
branches;
next	1.237;

1.237
date	2014.04.30.09.09.08;	author jfrijters;	state Exp;
branches;
next	1.236;

1.236
date	2014.04.30.09.04.41;	author jfrijters;	state Exp;
branches;
next	1.235;

1.235
date	2014.04.30.08.54.47;	author jfrijters;	state Exp;
branches;
next	1.234;

1.234
date	2014.04.29.13.36.29;	author jfrijters;	state Exp;
branches;
next	1.233;

1.233
date	2014.04.29.13.20.37;	author jfrijters;	state Exp;
branches;
next	1.232;

1.232
date	2014.04.28.14.26.38;	author jfrijters;	state Exp;
branches;
next	1.231;

1.231
date	2014.04.24.16.06.05;	author jfrijters;	state Exp;
branches;
next	1.230;

1.230
date	2014.04.17.11.31.45;	author jfrijters;	state Exp;
branches;
next	1.229;

1.229
date	2014.04.17.11.29.39;	author jfrijters;	state Exp;
branches;
next	1.228;

1.228
date	2014.04.17.11.02.33;	author jfrijters;	state Exp;
branches;
next	1.227;

1.227
date	2014.04.17.10.18.38;	author jfrijters;	state Exp;
branches;
next	1.226;

1.226
date	2014.04.17.09.41.07;	author jfrijters;	state Exp;
branches;
next	1.225;

1.225
date	2014.04.17.08.02.23;	author jfrijters;	state Exp;
branches;
next	1.224;

1.224
date	2014.04.11.13.03.37;	author jfrijters;	state Exp;
branches;
next	1.223;

1.223
date	2014.04.10.13.14.50;	author jfrijters;	state Exp;
branches;
next	1.222;

1.222
date	2014.03.05.11.12.47;	author jfrijters;	state Exp;
branches;
next	1.221;

1.221
date	2014.03.04.08.38.31;	author jfrijters;	state Exp;
branches;
next	1.220;

1.220
date	2014.02.24.17.05.25;	author jfrijters;	state Exp;
branches;
next	1.219;

1.219
date	2014.02.21.08.35.07;	author jfrijters;	state Exp;
branches;
next	1.218;

1.218
date	2014.02.21.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.217;

1.217
date	2014.02.20.16.51.25;	author jfrijters;	state Exp;
branches;
next	1.216;

1.216
date	2014.02.20.15.51.03;	author jfrijters;	state Exp;
branches;
next	1.215;

1.215
date	2014.02.07.14.14.13;	author jfrijters;	state Exp;
branches;
next	1.214;

1.214
date	2014.02.06.08.56.11;	author jfrijters;	state Exp;
branches;
next	1.213;

1.213
date	2014.02.04.09.38.08;	author jfrijters;	state Exp;
branches;
next	1.212;

1.212
date	2013.09.02.12.53.04;	author jfrijters;	state Exp;
branches;
next	1.211;

1.211
date	2013.09.02.12.47.57;	author jfrijters;	state Exp;
branches;
next	1.210;

1.210
date	2013.09.02.12.44.15;	author jfrijters;	state Exp;
branches;
next	1.209;

1.209
date	2013.08.13.11.27.03;	author jfrijters;	state Exp;
branches;
next	1.208;

1.208
date	2013.08.12.07.55.58;	author jfrijters;	state Exp;
branches;
next	1.207;

1.207
date	2013.08.08.06.15.47;	author jfrijters;	state Exp;
branches;
next	1.206;

1.206
date	2013.08.07.12.15.19;	author jfrijters;	state Exp;
branches;
next	1.205;

1.205
date	2013.08.07.09.26.23;	author jfrijters;	state Exp;
branches;
next	1.204;

1.204
date	2013.08.07.06.46.28;	author jfrijters;	state Exp;
branches;
next	1.203;

1.203
date	2013.08.07.06.16.48;	author jfrijters;	state Exp;
branches;
next	1.202;

1.202
date	2013.08.06.14.52.26;	author jfrijters;	state Exp;
branches;
next	1.201;

1.201
date	2013.08.06.12.45.10;	author jfrijters;	state Exp;
branches;
next	1.200;

1.200
date	2013.08.06.12.11.27;	author jfrijters;	state Exp;
branches;
next	1.199;

1.199
date	2013.07.30.21.54.58;	author jfrijters;	state Exp;
branches;
next	1.198;

1.198
date	2013.07.30.20.15.48;	author jfrijters;	state Exp;
branches;
next	1.197;

1.197
date	2013.07.30.19.55.27;	author jfrijters;	state Exp;
branches;
next	1.196;

1.196
date	2013.07.30.18.04.59;	author jfrijters;	state Exp;
branches;
next	1.195;

1.195
date	2013.07.30.17.38.33;	author jfrijters;	state Exp;
branches;
next	1.194;

1.194
date	2013.03.29.10.02.30;	author jfrijters;	state Exp;
branches;
next	1.193;

1.193
date	2013.03.27.11.36.20;	author jfrijters;	state Exp;
branches;
next	1.192;

1.192
date	2013.03.26.11.20.21;	author jfrijters;	state Exp;
branches;
next	1.191;

1.191
date	2013.03.25.19.57.46;	author jfrijters;	state Exp;
branches;
next	1.190;

1.190
date	2013.03.24.12.40.33;	author jfrijters;	state Exp;
branches;
next	1.189;

1.189
date	2013.03.20.11.15.42;	author jfrijters;	state Exp;
branches;
next	1.188;

1.188
date	2013.03.11.17.30.41;	author jfrijters;	state Exp;
branches;
next	1.187;

1.187
date	2013.03.11.17.16.10;	author jfrijters;	state Exp;
branches;
next	1.186;

1.186
date	2013.03.11.17.12.17;	author jfrijters;	state Exp;
branches;
next	1.185;

1.185
date	2013.03.11.16.58.16;	author jfrijters;	state Exp;
branches;
next	1.184;

1.184
date	2013.03.11.15.18.47;	author jfrijters;	state Exp;
branches;
next	1.183;

1.183
date	2013.03.11.14.44.55;	author jfrijters;	state Exp;
branches;
next	1.182;

1.182
date	2013.03.11.14.14.55;	author jfrijters;	state Exp;
branches;
next	1.181;

1.181
date	2013.03.07.09.39.53;	author jfrijters;	state Exp;
branches;
next	1.180;

1.180
date	2013.03.07.09.38.18;	author jfrijters;	state Exp;
branches;
next	1.179;

1.179
date	2013.03.06.15.26.04;	author jfrijters;	state Exp;
branches;
next	1.178;

1.178
date	2013.03.05.15.59.58;	author jfrijters;	state Exp;
branches;
next	1.177;

1.177
date	2013.03.05.13.29.09;	author jfrijters;	state Exp;
branches;
next	1.176;

1.176
date	2013.03.04.12.47.40;	author jfrijters;	state Exp;
branches;
next	1.175;

1.175
date	2013.02.27.07.28.30;	author jfrijters;	state Exp;
branches;
next	1.174;

1.174
date	2013.02.26.13.34.00;	author jfrijters;	state Exp;
branches;
next	1.173;

1.173
date	2013.02.26.12.00.49;	author jfrijters;	state Exp;
branches;
next	1.172;

1.172
date	2013.02.18.10.16.43;	author jfrijters;	state Exp;
branches;
next	1.171;

1.171
date	2013.02.14.16.09.04;	author jfrijters;	state Exp;
branches;
next	1.170;

1.170
date	2013.02.14.14.32.21;	author jfrijters;	state Exp;
branches;
next	1.169;

1.169
date	2013.02.14.13.33.04;	author jfrijters;	state Exp;
branches;
next	1.168;

1.168
date	2013.02.14.11.12.41;	author jfrijters;	state Exp;
branches;
next	1.167;

1.167
date	2013.02.13.19.52.09;	author jfrijters;	state Exp;
branches;
next	1.166;

1.166
date	2013.02.13.17.09.01;	author jfrijters;	state Exp;
branches;
next	1.165;

1.165
date	2013.02.11.06.57.04;	author jfrijters;	state Exp;
branches;
next	1.164;

1.164
date	2013.02.09.10.12.11;	author jfrijters;	state Exp;
branches;
next	1.163;

1.163
date	2013.02.09.10.04.13;	author jfrijters;	state Exp;
branches;
next	1.162;

1.162
date	2013.02.07.08.45.41;	author jfrijters;	state Exp;
branches;
next	1.161;

1.161
date	2013.02.07.08.31.25;	author jfrijters;	state Exp;
branches;
next	1.160;

1.160
date	2013.02.06.19.54.34;	author jfrijters;	state Exp;
branches;
next	1.159;

1.159
date	2013.02.06.19.31.10;	author jfrijters;	state Exp;
branches;
next	1.158;

1.158
date	2013.02.05.18.54.49;	author jfrijters;	state Exp;
branches;
next	1.157;

1.157
date	2013.02.05.16.06.13;	author jfrijters;	state Exp;
branches;
next	1.156;

1.156
date	2013.01.31.09.12.20;	author jfrijters;	state Exp;
branches;
next	1.155;

1.155
date	2013.01.30.17.39.46;	author jfrijters;	state Exp;
branches;
next	1.154;

1.154
date	2013.01.24.14.29.03;	author jfrijters;	state Exp;
branches;
next	1.153;

1.153
date	2013.01.15.15.33.50;	author jfrijters;	state Exp;
branches;
next	1.152;

1.152
date	2013.01.15.14.20.38;	author jfrijters;	state Exp;
branches;
next	1.151;

1.151
date	2013.01.15.14.17.42;	author jfrijters;	state Exp;
branches;
next	1.150;

1.150
date	2013.01.08.07.58.38;	author jfrijters;	state Exp;
branches;
next	1.149;

1.149
date	2013.01.08.07.07.07;	author jfrijters;	state Exp;
branches;
next	1.148;

1.148
date	2013.01.04.15.59.19;	author jfrijters;	state Exp;
branches;
next	1.147;

1.147
date	2012.11.01.11.23.33;	author jfrijters;	state Exp;
branches;
next	1.146;

1.146
date	2012.10.25.10.58.32;	author jfrijters;	state Exp;
branches;
next	1.145;

1.145
date	2012.09.21.11.23.09;	author jfrijters;	state Exp;
branches;
next	1.144;

1.144
date	2012.09.20.07.40.16;	author jfrijters;	state Exp;
branches;
next	1.143;

1.143
date	2012.09.13.15.19.35;	author jfrijters;	state Exp;
branches;
next	1.142;

1.142
date	2012.09.13.13.21.35;	author jfrijters;	state Exp;
branches;
next	1.141;

1.141
date	2012.09.11.10.25.11;	author jfrijters;	state Exp;
branches;
next	1.140;

1.140
date	2012.08.15.11.52.55;	author jfrijters;	state Exp;
branches
	1.140.2.1;
next	1.139;

1.139
date	2012.08.15.08.45.39;	author jfrijters;	state Exp;
branches;
next	1.138;

1.138
date	2012.08.06.15.40.12;	author jfrijters;	state Exp;
branches;
next	1.137;

1.137
date	2012.08.06.14.52.11;	author jfrijters;	state Exp;
branches;
next	1.136;

1.136
date	2012.08.06.14.33.54;	author jfrijters;	state Exp;
branches;
next	1.135;

1.135
date	2012.07.20.11.42.07;	author jfrijters;	state Exp;
branches;
next	1.134;

1.134
date	2012.07.09.06.07.40;	author jfrijters;	state Exp;
branches;
next	1.133;

1.133
date	2012.07.03.14.45.51;	author jfrijters;	state Exp;
branches;
next	1.132;

1.132
date	2012.06.25.14.32.07;	author jfrijters;	state Exp;
branches;
next	1.131;

1.131
date	2012.06.20.12.01.15;	author jfrijters;	state Exp;
branches;
next	1.130;

1.130
date	2012.06.20.09.49.51;	author jfrijters;	state Exp;
branches;
next	1.129;

1.129
date	2012.06.13.11.34.37;	author jfrijters;	state Exp;
branches;
next	1.128;

1.128
date	2012.06.13.09.50.56;	author jfrijters;	state Exp;
branches;
next	1.127;

1.127
date	2012.04.13.11.47.48;	author jfrijters;	state Exp;
branches;
next	1.126;

1.126
date	2012.04.12.10.09.09;	author jfrijters;	state Exp;
branches;
next	1.125;

1.125
date	2012.03.29.09.11.13;	author jfrijters;	state Exp;
branches;
next	1.124;

1.124
date	2012.03.25.09.10.29;	author jfrijters;	state Exp;
branches;
next	1.123;

1.123
date	2012.01.20.14.02.23;	author jfrijters;	state Exp;
branches;
next	1.122;

1.122
date	2012.01.20.10.55.45;	author jfrijters;	state Exp;
branches;
next	1.121;

1.121
date	2012.01.20.10.23.59;	author jfrijters;	state Exp;
branches;
next	1.120;

1.120
date	2012.01.20.10.13.26;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2012.01.20.09.01.07;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2012.01.05.09.03.52;	author jfrijters;	state Exp;
branches;
next	1.117;

1.117
date	2012.01.04.12.32.53;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2012.01.04.10.45.56;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2012.01.04.10.23.47;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2012.01.03.14.26.36;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2011.12.15.14.39.43;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2011.12.15.11.53.33;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2011.12.15.08.56.10;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2011.12.14.12.10.00;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2011.12.14.12.06.53;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2011.12.14.11.52.02;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2011.12.14.11.18.12;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2011.12.14.11.12.50;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2011.12.14.09.46.56;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2011.12.13.10.39.46;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2011.12.13.08.43.28;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2011.12.13.07.34.50;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2011.12.12.14.38.38;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2011.12.12.13.43.11;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2011.12.12.13.29.02;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2011.12.12.12.43.23;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2011.12.12.11.21.29;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2011.12.12.11.13.33;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2011.12.12.11.02.24;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2011.12.12.10.59.00;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2011.12.12.10.49.42;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2011.12.12.09.57.23;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2011.12.11.10.43.18;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2011.12.11.08.16.25;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2011.12.09.16.32.34;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2011.12.09.15.59.35;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2011.12.09.15.26.57;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2011.12.09.15.05.54;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2011.12.09.14.53.16;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2011.12.08.13.47.07;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2011.12.08.13.13.44;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2011.12.08.11.10.11;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2011.12.07.11.28.17;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2011.11.29.13.00.26;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2011.11.29.10.51.16;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2011.11.29.10.39.23;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2011.11.29.09.50.23;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2011.11.26.07.45.03;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2011.11.25.12.47.17;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2011.11.25.12.03.57;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2011.11.24.15.14.03;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2011.11.24.12.31.38;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2011.11.24.09.08.04;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2011.11.23.07.09.29;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2011.11.23.06.53.53;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2011.11.23.06.20.34;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2011.11.18.15.22.46;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2011.11.18.10.33.08;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2011.11.18.08.43.17;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2011.11.18.08.33.55;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2011.11.17.17.32.54;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2011.11.17.15.45.29;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2011.11.17.13.53.02;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2011.11.14.06.17.13;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2011.11.11.15.35.14;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2011.11.07.06.25.43;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2011.11.03.09.07.33;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2011.11.02.14.37.06;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2011.09.07.05.06.39;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2011.09.06.07.37.30;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2011.09.06.06.15.51;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2011.08.16.13.40.05;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2011.08.12.13.06.46;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2011.08.10.09.06.27;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2011.08.08.16.21.29;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2011.07.25.22.44.03;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.01.14.04.40;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.27.15.15.32;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2011.05.25.09.23.37;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2011.05.17.07.46.01;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2011.05.17.06.49.38;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2011.05.12.10.15.53;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2011.05.12.08.08.09;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2011.02.17.13.14.40;	author jfrijters;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2010.10.05.06.14.16;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2010.10.05.06.09.49;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.05.04.54.09;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2010.10.01.08.11.49;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.30.04.03.33;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.29.07.21.51;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.28.08.02.07;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.21.14.09.54;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.20.15.08.46;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.14.12.29.22;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.10.07.59.39;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.18.07.18.11;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.09.04.55.52;	author jfrijters;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2010.05.27.11.22.18;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.27.08.31.46;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.21.04.23.40;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2010.05.20.05.36.37;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.16.06.31.21;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.13.12.51.26;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.12.13.49.10;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.12.07.06.58;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2010.02.19.08.07.38;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.28.08.44.57;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.25.07.52.58;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.06.14.28.38;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.10.08.43.45;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.07.07.12.23;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.01.07.08.52;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.13.15.08.22;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.09.05.32.29;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.21.04.54.39;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.14.14.58.41;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.14.09.50.33;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.31.06.05.15;	author jfrijters;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2009.08.31.05.58.53;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.31.05.49.19;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.31.05.46.20;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.31.05.10.11;	author jfrijters;	state Exp;
branches;
next	;

1.5.2.1
date	2009.10.19.04.50.08;	author jfrijters;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2010.01.12.16.57.38;	author jfrijters;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2010.02.19.08.14.27;	author jfrijters;	state Exp;
branches;
next	;

1.27.2.1
date	2010.08.23.04.37.00;	author jfrijters;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2010.10.22.07.02.43;	author jfrijters;	state Exp;
branches;
next	;

1.40.2.1
date	2011.12.20.08.48.57;	author jfrijters;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2011.12.20.08.53.39;	author jfrijters;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2011.12.20.11.25.29;	author jfrijters;	state Exp;
branches;
next	1.40.2.4;

1.40.2.4
date	2011.12.20.12.02.15;	author jfrijters;	state Exp;
branches;
next	1.40.2.5;

1.40.2.5
date	2011.12.20.13.22.38;	author jfrijters;	state Exp;
branches;
next	1.40.2.6;

1.40.2.6
date	2011.12.20.13.34.10;	author jfrijters;	state Exp;
branches;
next	1.40.2.7;

1.40.2.7
date	2011.12.20.13.53.10;	author jfrijters;	state Exp;
branches;
next	1.40.2.8;

1.40.2.8
date	2012.10.03.06.18.57;	author jfrijters;	state Exp;
branches;
next	1.40.2.9;

1.40.2.9
date	2013.09.10.15.16.03;	author jfrijters;	state Exp;
branches;
next	;

1.140.2.1
date	2012.10.08.07.43.48;	author jfrijters;	state Exp;
branches;
next	1.140.2.2;

1.140.2.2
date	2012.10.31.12.35.37;	author jfrijters;	state Exp;
branches;
next	1.140.2.3;

1.140.2.3
date	2012.12.06.08.56.47;	author jfrijters;	state Exp;
branches;
next	1.140.2.4;

1.140.2.4
date	2013.01.15.10.28.01;	author jfrijters;	state Exp;
branches;
next	1.140.2.5;

1.140.2.5
date	2013.02.14.08.18.42;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.280
log
@Improved -removeassertions ikvmc optimization to remove more code (esp. allow otherwise empty <clinit> methods to be optimized away).
@
text
@/*
  Copyright (C) 2002-2015 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
#if STATIC_COMPILER
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
using DynamicOrAotTypeWrapper = IKVM.Internal.AotTypeWrapper;
using ProtectionDomain = System.Object;
#else
using System.Reflection;
using System.Reflection.Emit;
using DynamicOrAotTypeWrapper = IKVM.Internal.DynamicTypeWrapper;
using ProtectionDomain = java.security.ProtectionDomain;
#endif
using System.Diagnostics;
using System.Security;
using System.Security.Permissions;
using IKVM.Attributes;

namespace IKVM.Internal
{
#if STATIC_COMPILER
	abstract class DynamicTypeWrapper : TypeWrapper
#else
#pragma warning disable 628 // don't complain about protected members in sealed type
	sealed class DynamicTypeWrapper : TypeWrapper
#endif
	{
#if STATIC_COMPILER
		protected readonly CompilerClassLoader classLoader;
#else
		protected readonly ClassLoaderWrapper classLoader;
#endif
		private volatile DynamicImpl impl;
		private readonly TypeWrapper baseTypeWrapper;
		private readonly TypeWrapper[] interfaces;
		private readonly string sourceFileName;
#if !STATIC_COMPILER
		private byte[][] lineNumberTables;
#endif
		private MethodBase automagicSerializationCtor;

		private TypeWrapper LoadTypeWrapper(ClassLoaderWrapper classLoader, ProtectionDomain pd, ClassFile.ConstantPoolItemClass clazz)
		{
			// check for patched constant pool items
			TypeWrapper tw = clazz.GetClassType();
			if (tw == null || tw == VerifierTypeWrapper.Null)
			{
				tw = classLoader.LoadClassByDottedNameFast(clazz.Name);
			}
			if (tw == null)
			{
				throw new NoClassDefFoundError(clazz.Name);
			}
			CheckMissing(this, tw);
			classLoader.CheckPackageAccess(tw, pd);
			return tw;
		}

		private static void CheckMissing(TypeWrapper prev, TypeWrapper tw)
		{
#if STATIC_COMPILER
			do
			{
				UnloadableTypeWrapper missing = tw as UnloadableTypeWrapper;
				if (missing != null)
				{
					Type mt = ReflectUtil.GetMissingType(missing.MissingType);
					if (mt.Assembly.__IsMissing)
					{
						throw new FatalCompilerErrorException(Message.MissingBaseTypeReference, mt.FullName, mt.Assembly.FullName);
					}
					throw new FatalCompilerErrorException(Message.MissingBaseType, mt.FullName, mt.Assembly.FullName,
						prev.TypeAsBaseType.FullName, prev.TypeAsBaseType.Module.Name);
				}
				foreach (TypeWrapper iface in tw.Interfaces)
				{
					CheckMissing(tw, iface);
				}
				prev = tw;
				tw = tw.BaseTypeWrapper;
			}
			while (tw != null);
#endif
		}

#if STATIC_COMPILER
		internal DynamicTypeWrapper(TypeWrapper host, ClassFile f, CompilerClassLoader classLoader, ProtectionDomain pd)
#else
		internal DynamicTypeWrapper(TypeWrapper host, ClassFile f, ClassLoaderWrapper classLoader, ProtectionDomain pd)
#endif
			: base(f.IsInternal ? TypeFlags.InternalAccess : host != null ? TypeFlags.Anonymous : TypeFlags.None, f.Modifiers, f.Name)
		{
			Profiler.Count("DynamicTypeWrapper");
			this.classLoader = classLoader;
			this.sourceFileName = f.SourceFileAttribute;
			if (f.IsInterface)
			{
				// interfaces can't "override" final methods in object
				foreach (ClassFile.Method method in f.Methods)
				{
					MethodWrapper mw;
					if (method.IsVirtual
						&& (mw = CoreClasses.java.lang.Object.Wrapper.GetMethodWrapper(method.Name, method.Signature, false)) != null
						&& mw.IsVirtual
						&& mw.IsFinal)
					{
						throw new VerifyError("class " + f.Name + " overrides final method " + method.Name + "." + method.Signature);
					}
				}
			}
			else
			{
				this.baseTypeWrapper = LoadTypeWrapper(classLoader, pd, f.SuperClass);
				if (!BaseTypeWrapper.IsAccessibleFrom(this))
				{
					throw new IllegalAccessError("Class " + f.Name + " cannot access its superclass " + BaseTypeWrapper.Name);
				}
				if (BaseTypeWrapper.IsFinal)
				{
					throw new VerifyError("Class " + f.Name + " extends final class " + BaseTypeWrapper.Name);
				}
				if (BaseTypeWrapper.IsInterface)
				{
					throw new IncompatibleClassChangeError("Class " + f.Name + " has interface " + BaseTypeWrapper.Name + " as superclass");
				}
				if (BaseTypeWrapper.TypeAsTBD == Types.Delegate)
				{
					throw new VerifyError(BaseTypeWrapper.Name + " cannot be used as a base class");
				}
				// NOTE defining value types, enums is not supported in IKVM v1
				if (BaseTypeWrapper.TypeAsTBD == Types.ValueType || BaseTypeWrapper.TypeAsTBD == Types.Enum)
				{
					throw new VerifyError("Defining value types in Java is not implemented in IKVM v1");
				}
				if (IsDelegate)
				{
					VerifyDelegate(f);
				}
#if CLASSGC
				if (JVM.classUnloading && BaseTypeWrapper.TypeAsBaseType == typeof(ContextBoundObject))
				{
					throw new VerifyError("Extending ContextBoundObject is not supported in dynamic mode with class GC enabled.");
				}
#endif
			}

#if CLASSGC
			if (JVM.classUnloading)
			{
				VerifyRunAndCollect(f);
			}
#endif

			ClassFile.ConstantPoolItemClass[] interfaces = f.Interfaces;
			this.interfaces = new TypeWrapper[interfaces.Length];
			for (int i = 0; i < interfaces.Length; i++)
			{
				TypeWrapper iface = LoadTypeWrapper(classLoader, pd, interfaces[i]);
				if (!iface.IsAccessibleFrom(this))
				{
					throw new IllegalAccessError("Class " + f.Name + " cannot access its superinterface " + iface.Name);
				}
				if (!iface.IsInterface)
				{
					throw new IncompatibleClassChangeError("Implementing class");
				}
				this.interfaces[i] = iface;
			}

			impl = new JavaTypeImpl(host, f, this);
		}

#if CLASSGC
		private static void VerifyRunAndCollect(ClassFile f)
		{
			if (f.Annotations != null)
			{
				foreach (object[] ann in f.Annotations)
				{
					if (ann[1].Equals("Lcli/System/Runtime/InteropServices/ComImportAttribute$Annotation;"))
					{
						throw new VerifyError("ComImportAttribute is not supported in dynamic mode with class GC enabled.");
					}
				}
			}
			foreach (ClassFile.Field field in f.Fields)
			{
				if (field.Annotations != null)
				{
					foreach (object[] ann in field.Annotations)
					{
						if (ann[1].Equals("Lcli/System/ThreadStaticAttribute$Annotation;"))
						{
							throw new VerifyError("ThreadStaticAttribute is not supported in dynamic mode with class GC enabled.");
						}
						if (ann[1].Equals("Lcli/System/ContextStaticAttribute$Annotation;"))
						{
							throw new VerifyError("ContextStaticAttribute is not supported in dynamic mode with class GC enabled.");
						}
					}
				}
			}
			foreach (ClassFile.Method method in f.Methods)
			{
				if (method.Annotations != null)
				{
					foreach (object[] ann in method.Annotations)
					{
						if (ann[1].Equals("Lcli/System/Runtime/InteropServices/DllImportAttribute$Annotation;"))
						{
							throw new VerifyError("DllImportAttribute is not supported in dynamic mode with class GC enabled.");
						}
					}
				}
			}
		}
#endif

		private void VerifyDelegate(ClassFile f)
		{
			if (!f.IsFinal)
			{
				throw new VerifyError("Delegate must be final");
			}
			ClassFile.Method invoke = null;
			ClassFile.Method beginInvoke = null;
			ClassFile.Method endInvoke = null;
			ClassFile.Method constructor = null;
			foreach (ClassFile.Method m in f.Methods)
			{
				if (m.Name == "Invoke")
				{
					if (invoke != null)
					{
						throw new VerifyError("Delegate may only have a single Invoke method");
					}
					invoke = m;
				}
				else if (m.Name == "BeginInvoke")
				{
					if (beginInvoke != null)
					{
						throw new VerifyError("Delegate may only have a single BeginInvoke method");
					}
					beginInvoke = m;
				}
				else if (m.Name == "EndInvoke")
				{
					if (endInvoke != null)
					{
						throw new VerifyError("Delegate may only have a single EndInvoke method");
					}
					endInvoke = m;
				}
				else if (m.Name == "<init>")
				{
					if (constructor != null)
					{
						throw new VerifyError("Delegate may only have a single constructor");
					}
					constructor = m;
				}
				else if (m.IsNative)
				{
					throw new VerifyError("Delegate may not have any native methods besides Invoke, BeginInvoke and EndInvoke");
				}
			}
			if (invoke == null || constructor == null)
			{
				throw new VerifyError("Delegate must have a constructor and an Invoke method");
			}
			if (!invoke.IsPublic || !invoke.IsNative || invoke.IsFinal || invoke.IsStatic)
			{
				throw new VerifyError("Delegate Invoke method must be a public native non-final instance method");
			}
			if ((beginInvoke != null && endInvoke == null) || (beginInvoke == null && endInvoke != null))
			{
				throw new VerifyError("Delegate must have both BeginInvoke and EndInvoke or neither");
			}
			if (!constructor.IsPublic)
			{
				throw new VerifyError("Delegate constructor must be public");
			}
			if (constructor.Instructions.Length < 3
				|| constructor.Instructions[0].NormalizedOpCode != NormalizedByteCode.__aload
				|| constructor.Instructions[0].NormalizedArg1 != 0
				|| constructor.Instructions[1].NormalizedOpCode != NormalizedByteCode.__invokespecial
				|| constructor.Instructions[2].NormalizedOpCode != NormalizedByteCode.__return)
			{
				throw new VerifyError("Delegate constructor must be empty");
			}
			if (f.Fields.Length != 0)
			{
				throw new VerifyError("Delegate may not declare any fields");
			}
			TypeWrapper iface = classLoader.LoadClassByDottedNameFast(f.Name + DotNetTypeWrapper.DelegateInterfaceSuffix);
			DelegateInnerClassCheck(iface != null);
			DelegateInnerClassCheck(iface.IsInterface);
			DelegateInnerClassCheck(iface.IsPublic);
			DelegateInnerClassCheck(iface.GetClassLoader() == classLoader);
			MethodWrapper[] methods = iface.GetMethods();
			DelegateInnerClassCheck(methods.Length == 1 && methods[0].Name == "Invoke");
			if (methods[0].Signature != invoke.Signature)
			{
				throw new VerifyError("Delegate Invoke method signature must be identical to inner interface Invoke method signature");
			}
			if (iface.Interfaces.Length != 0)
			{
				throw new VerifyError("Delegate inner interface may not extend any interfaces");
			}
			if (constructor.Signature != "(" + iface.SigName + ")V")
			{
				throw new VerifyError("Delegate constructor must take a single argument of type inner Method interface");
			}
			if (beginInvoke != null && beginInvoke.Signature != invoke.Signature.Substring(0, invoke.Signature.IndexOf(')')) + "Lcli.System.AsyncCallback;Ljava.lang.Object;)Lcli.System.IAsyncResult;")
			{
				throw new VerifyError("Delegate BeginInvoke method has incorrect signature");
			}
			if (endInvoke != null && endInvoke.Signature != "(Lcli.System.IAsyncResult;)" + invoke.Signature.Substring(invoke.Signature.IndexOf(')') + 1))
			{
				throw new VerifyError("Delegate EndInvoke method has incorrect signature");
			}
		}

		private static void DelegateInnerClassCheck(bool cond)
		{
			if (!cond)
			{
				throw new VerifyError("Delegate must have a public inner interface named Method with a single method named Invoke");
			}
		}

		private bool IsDelegate
		{
			get
			{
				TypeWrapper baseTypeWrapper = BaseTypeWrapper;
				return baseTypeWrapper != null && baseTypeWrapper.TypeAsTBD == Types.MulticastDelegate;
			}
		}

		internal sealed override TypeWrapper BaseTypeWrapper
		{
			get { return baseTypeWrapper; }
		}

		internal override ClassLoaderWrapper GetClassLoader()
		{
			return classLoader;
		}

		internal override Modifiers ReflectiveModifiers
		{
			get
			{
				return impl.ReflectiveModifiers;
			}
		}

		internal override TypeWrapper[] Interfaces
		{
			get
			{
				return interfaces;
			}
		}

		internal override TypeWrapper[] InnerClasses
		{
			get
			{
				return impl.InnerClasses;
			}
		}

		internal override TypeWrapper DeclaringTypeWrapper
		{
			get
			{
				return impl.DeclaringTypeWrapper;
			}
		}

		internal override Type TypeAsTBD
		{
			get
			{
				return impl.Type;
			}
		}

		internal override void Finish()
		{
			// we don't need locking, because Finish is Thread safe
			impl = impl.Finish();
		}

		internal void CreateStep1()
		{
			((JavaTypeImpl)impl).CreateStep1();
		}

		internal void CreateStep2()
		{
			((JavaTypeImpl)impl).CreateStep2();
		}

		private bool IsSerializable
		{
			get
			{
				return this.IsSubTypeOf(CoreClasses.java.io.Serializable.Wrapper);
			}
		}

		private abstract class DynamicImpl
		{
			internal abstract Type Type { get; }
			internal abstract TypeWrapper[] InnerClasses { get; }
			internal abstract TypeWrapper DeclaringTypeWrapper { get; }
			internal abstract Modifiers ReflectiveModifiers { get; }
			internal abstract DynamicImpl Finish();
			internal abstract MethodBase LinkMethod(MethodWrapper mw);
			internal abstract FieldInfo LinkField(FieldWrapper fw);
			internal abstract void EmitRunClassConstructor(CodeEmitter ilgen);
			internal abstract string GetGenericSignature();
			internal abstract string[] GetEnclosingMethod();
			internal abstract string GetGenericMethodSignature(int index);
			internal abstract string GetGenericFieldSignature(int index);
			internal abstract object[] GetDeclaredAnnotations();
			internal abstract object GetMethodDefaultValue(int index);
			internal abstract object[] GetMethodAnnotations(int index);
			internal abstract object[][] GetParameterAnnotations(int index);
			internal abstract MethodParametersEntry[] GetMethodParameters(int index);
			internal abstract object[] GetFieldAnnotations(int index);
			internal abstract MethodInfo GetFinalizeMethod();
			internal abstract object[] GetConstantPool();
			internal abstract byte[] GetRawTypeAnnotations();
			internal abstract byte[] GetMethodRawTypeAnnotations(int index);
			internal abstract byte[] GetFieldRawTypeAnnotations(int index);
			internal abstract TypeWrapper Host { get; }
		}

		private sealed class JavaTypeImpl : DynamicImpl
		{
			private readonly TypeWrapper host;
			private readonly ClassFile classFile;
			private readonly DynamicOrAotTypeWrapper wrapper;
			private TypeBuilder typeBuilder;
			private MethodWrapper[] methods;
			private MethodWrapper[][] baseMethods;
			private FieldWrapper[] fields;
			private FinishedTypeImpl finishedType;
			private bool finishInProgress;
			private MethodBuilder clinitMethod;
			private MethodBuilder finalizeMethod;
			private int recursionCount;
#if STATIC_COMPILER
			private DynamicTypeWrapper enclosingClassWrapper;
			private AnnotationBuilder annotationBuilder;
			private TypeBuilder enumBuilder;
			private TypeBuilder privateInterfaceMethods;
			private Dictionary<string, TypeWrapper> nestedTypeNames;	// only keys are used, values are always null
#endif

			internal JavaTypeImpl(TypeWrapper host, ClassFile f, DynamicTypeWrapper wrapper)
			{
				Tracer.Info(Tracer.Compiler, "constructing JavaTypeImpl for " + f.Name);
				this.host = host;
				this.classFile = f;
				this.wrapper = (DynamicOrAotTypeWrapper)wrapper;
			}

			internal void CreateStep1()
			{
				// process all methods (needs to be done first, because property fields depend on being able to lookup the accessor methods)
				bool hasclinit = wrapper.BaseTypeWrapper == null ? false : wrapper.BaseTypeWrapper.HasStaticInitializer;
				methods = new MethodWrapper[classFile.Methods.Length];
				baseMethods = new MethodWrapper[classFile.Methods.Length][];
				for (int i = 0; i < methods.Length; i++)
				{
					MemberFlags flags = MemberFlags.None;
					ClassFile.Method m = classFile.Methods[i];
					if (m.IsClassInitializer)
					{
#if STATIC_COMPILER
						bool noop;
						if (IsSideEffectFreeStaticInitializerOrNoop(m, out noop))
						{
							if (noop)
							{
								flags |= MemberFlags.NoOp;
							}
						}
						else
						{
							hasclinit = true;
						}
#else
						hasclinit = true;
#endif
					}
					if (m.IsInternal)
					{
						flags |= MemberFlags.InternalAccess;
					}
#if STATIC_COMPILER
					if (m.IsCallerSensitive && SupportsCallerID(m))
					{
						flags |= MemberFlags.CallerID;
					}
#endif
					if (wrapper.IsGhost && m.IsVirtual)
					{
						// note that a GhostMethodWrapper can also represent a default interface method
						methods[i] = new GhostMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, null, m.Modifiers, flags);
					}
					else if (m.IsConstructor && wrapper.IsDelegate)
					{
						methods[i] = new DelegateConstructorMethodWrapper(wrapper, m);
					}
					else if (classFile.IsInterface && !m.IsStatic && !m.IsPublic)
					{
						// we can't use callvirt to call interface private instance methods (because we have to compile them as static methods,
						// since the CLR doesn't support interface instance methods), so need a special MethodWrapper
						methods[i] = new PrivateInterfaceMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, flags);
					}
					else if (classFile.IsInterface && m.IsVirtual && !m.IsAbstract)
					{
						// note that a GhostMethodWrapper can also represent a default interface method
						methods[i] = new DefaultInterfaceMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, null, m.Modifiers, flags);
					}
					else
					{
						if (!classFile.IsInterface && m.IsVirtual)
						{
							bool explicitOverride;
							baseMethods[i] = FindBaseMethods(m, out explicitOverride);
							if (explicitOverride)
							{
								flags |= MemberFlags.ExplicitOverride;
							}
						}
						methods[i] = new TypicalMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, flags);
					}
				}
				if (hasclinit)
				{
					wrapper.SetHasStaticInitializer();
				}
				if (!wrapper.IsInterface || wrapper.IsPublic)
				{
					List<MethodWrapper> methodsArray = new List<MethodWrapper>(methods);
					List<MethodWrapper[]> baseMethodsArray = new List<MethodWrapper[]>(baseMethods);
					AddMirandaMethods(methodsArray, baseMethodsArray, wrapper);
					methods = methodsArray.ToArray();
					baseMethods = baseMethodsArray.ToArray();
				}
				if (!wrapper.IsInterface)
				{
					AddDelegateInvokeStubs(wrapper, ref methods);
				}
				wrapper.SetMethods(methods);

				fields = new FieldWrapper[classFile.Fields.Length];
				for (int i = 0; i < fields.Length; i++)
				{
					ClassFile.Field fld = classFile.Fields[i];
					if (fld.IsStaticFinalConstant)
					{
						TypeWrapper fieldType = null;
#if !STATIC_COMPILER
						fieldType = ClassLoaderWrapper.GetBootstrapClassLoader().FieldTypeWrapperFromSig(fld.Signature, LoadMode.LoadOrThrow);
#endif
						fields[i] = new ConstantFieldWrapper(wrapper, fieldType, fld.Name, fld.Signature, fld.Modifiers, null, fld.ConstantValue, MemberFlags.None);
					}
					else if (fld.IsProperty)
					{
						fields[i] = new DynamicPropertyFieldWrapper(wrapper, fld);
					}
					else
					{
						fields[i] = FieldWrapper.Create(wrapper, null, null, fld.Name, fld.Signature, new ExModifiers(fld.Modifiers, fld.IsInternal));
					}
				}
#if STATIC_COMPILER
				wrapper.AddMapXmlFields(ref fields);
#endif
				wrapper.SetFields(fields);
			}

#if STATIC_COMPILER
			private bool SupportsCallerID(ClassFile.Method method)
			{
				if ((classFile.Name == "sun.reflect.Reflection" && method.Name == "getCallerClass")
					|| (classFile.Name == "java.lang.SecurityManager" && method.Name == "checkMemberAccess"))
				{
					// ignore CallerSensitive on methods that don't need CallerID parameter
					return false;
				}
				else if (method.IsStatic)
				{
					return true;
				}
				else if ((classFile.IsFinal || classFile.Name == "java.lang.Runtime" || classFile.Name == "java.io.ObjectStreamClass")
					&& wrapper.BaseTypeWrapper.GetMethodWrapper(method.Name, method.Signature, true) == null
					&& !HasInterfaceMethod(wrapper, method.Name, method.Signature))
				{
					// We only support CallerID instance methods on final or effectively final types,
					// because we don't support interface stubs with CallerID.
					// We also don't support a CallerID method overriding a method or implementing an interface.
					return true;
				}
				else if (RequiresDynamicReflectionCallerClass(classFile.Name, method.Name, method.Signature))
				{
					// We don't support CallerID for virtual methods that can be overridden or implement an interface,
					// so these methods will do a dynamic stack walk if when Reflection.getCallerClass() is used.
					return false;
				}
				else
				{
					// If we end up here, we either have to add support or add them to the white-list in the above clause
					// to allow them to fall back to dynamic stack walking.
					StaticCompiler.IssueMessage(Message.CallerSensitiveOnUnsupportedMethod, classFile.Name, method.Name, method.Signature);
					return false;
				}
			}

			private static bool HasInterfaceMethod(TypeWrapper tw, string name, string signature)
			{
				for (; tw != null; tw = tw.BaseTypeWrapper)
				{
					foreach (TypeWrapper iface in tw.Interfaces)
					{
						if (iface.GetMethodWrapper(name, signature, false) != null)
						{
							return true;
						}
						if (HasInterfaceMethod(iface, name, signature))
						{
							return true;
						}
					}
				}
				return false;
			}
#endif

			internal void CreateStep2()
			{
#if STATIC_COMPILER
				if (typeBuilder != null)
				{
					// in the static compiler we need to create the TypeBuilder from outer to inner
					// and to avoid having to sort the classes this way, we instead call CreateStep2
					// on demand for outer wrappers and this necessitates us to keep track of
					// whether we've already been called
					return;
				}
#endif
				// this method is not allowed to throw exceptions (if it does, the runtime will abort)
				bool hasclinit = wrapper.HasStaticInitializer;
				string mangledTypeName = wrapper.classLoader.GetTypeWrapperFactory().AllocMangledName(wrapper);
				ClassFile f = classFile;
				try
				{
					TypeAttributes typeAttribs = 0;
					if (f.IsAbstract)
					{
						typeAttribs |= TypeAttributes.Abstract;
					}
					if (f.IsFinal)
					{
						typeAttribs |= TypeAttributes.Sealed;
					}
					if (!hasclinit)
					{
						typeAttribs |= TypeAttributes.BeforeFieldInit;
					}
#if STATIC_COMPILER
					bool cantNest = false;
					bool setModifiers = false;
					TypeBuilder enclosing = null;
					string enclosingClassName = null;
					// we only compile inner classes as nested types in the static compiler, because it has a higher cost
					// and doesn't buy us anything in dynamic mode (and if fact, due to an FXBUG it would make handling
					// the TypeResolve event very hard)
					ClassFile.InnerClass outerClass = getOuterClass();
					if (outerClass.outerClass != 0)
					{
						enclosingClassName = classFile.GetConstantPoolClass(outerClass.outerClass);
					}
					else if (f.EnclosingMethod != null)
					{
						enclosingClassName = f.EnclosingMethod[0];
					}
					if (enclosingClassName != null)
					{
						if (!CheckInnerOuterNames(f.Name, enclosingClassName))
						{
							Tracer.Warning(Tracer.Compiler, "Incorrect {0} attribute on {1}", outerClass.outerClass != 0 ? "InnerClasses" : "EnclosingMethod", f.Name);
						}
						else
						{
							try
							{
								enclosingClassWrapper = wrapper.classLoader.LoadClassByDottedNameFast(enclosingClassName) as DynamicTypeWrapper;
							}
							catch (RetargetableJavaException x)
							{
								Tracer.Warning(Tracer.Compiler, "Unable to load outer class {0} for inner class {1} ({2}: {3})", enclosingClassName, f.Name, x.GetType().Name, x.Message);
							}
							if (enclosingClassWrapper != null)
							{
								// make sure the relationship is reciprocal (otherwise we run the risk of
								// baking the outer type before the inner type) and that the inner and outer
								// class live in the same class loader (when doing a multi target compilation,
								// it is possible to split the two classes across assemblies)
								JavaTypeImpl oimpl = enclosingClassWrapper.impl as JavaTypeImpl;
								if (oimpl != null && enclosingClassWrapper.GetClassLoader() == wrapper.GetClassLoader())
								{
									ClassFile outerClassFile = oimpl.classFile;
									ClassFile.InnerClass[] outerInnerClasses = outerClassFile.InnerClasses;
									if (outerInnerClasses == null)
									{
										enclosingClassWrapper = null;
									}
									else
									{
										bool ok = false;
										for (int i = 0; i < outerInnerClasses.Length; i++)
										{
											if (((outerInnerClasses[i].outerClass != 0 && outerClassFile.GetConstantPoolClass(outerInnerClasses[i].outerClass) == outerClassFile.Name)
													|| (outerInnerClasses[i].outerClass == 0 && outerClass.outerClass == 0))
												&& outerInnerClasses[i].innerClass != 0
												&& outerClassFile.GetConstantPoolClass(outerInnerClasses[i].innerClass) == f.Name)
											{
												ok = true;
												break;
											}
										}
										if (!ok)
										{
											enclosingClassWrapper = null;
										}
									}
								}
								else
								{
									enclosingClassWrapper = null;
								}
								if (enclosingClassWrapper != null)
								{
									enclosingClassWrapper.CreateStep2();
									enclosing = oimpl.typeBuilder;
									if (outerClass.outerClass == 0)
									{
										// we need to record that we're not an inner classes, but an enclosed class
										typeAttribs |= TypeAttributes.SpecialName;
									}
								}
								else
								{
									Tracer.Warning(Tracer.Compiler, "Non-reciprocal inner class {0}", f.Name);
								}
							}
						}
					}
					if (f.IsPublic)
					{
						if (enclosing != null)
						{
							if (enclosingClassWrapper.IsPublic)
							{
								typeAttribs |= TypeAttributes.NestedPublic;
							}
							else
							{
								// We're a public type nested inside a non-public type, this means that we can't compile this type as a nested type,
								// because that would mean it wouldn't be visible outside the assembly.
								cantNest = true;
								typeAttribs |= TypeAttributes.Public;
							}
						}
						else
						{
							typeAttribs |= TypeAttributes.Public;
						}
					}
					else if (enclosing != null)
					{
						typeAttribs |= TypeAttributes.NestedAssembly;
					}
#else // STATIC_COMPILER
					if (f.IsPublic)
					{
						typeAttribs |= TypeAttributes.Public;
					}
#endif // STATIC_COMPILER
					if (f.IsInterface)
					{
						typeAttribs |= TypeAttributes.Interface | TypeAttributes.Abstract;
#if STATIC_COMPILER
						// if any "meaningless" bits are set, preserve them
						setModifiers |= (f.Modifiers & (Modifiers)0x99CE) != 0;
						// by default we assume interfaces are abstract, so in the exceptional case we need a ModifiersAttribute
						setModifiers |= (f.Modifiers & Modifiers.Abstract) == 0;
						if (enclosing != null && !cantNest)
						{
							if (wrapper.IsGhost)
							{
								// TODO this is low priority, since the current Java class library doesn't define any ghost interfaces
								// as inner classes
								throw new NotImplementedException();
							}
							// LAMESPEC the CLI spec says interfaces cannot contain nested types (Part.II, 9.6), but that rule isn't enforced
							// (and broken by J# as well), so we'll just ignore it too.
							typeBuilder = enclosing.DefineNestedType(AllocNestedTypeName(enclosingClassWrapper.Name, f.Name), typeAttribs);
						}
						else
						{
							if (wrapper.IsGhost)
							{
								typeBuilder = wrapper.DefineGhostType(mangledTypeName, typeAttribs);
							}
							else
							{
								typeBuilder = wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs);
							}
						}
#else // STATIC_COMPILER
						typeBuilder = wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs);
#endif // STATIC_COMPILER
					}
					else
					{
						typeAttribs |= TypeAttributes.Class;
#if STATIC_COMPILER
						// if any "meaningless" bits are set, preserve them
						setModifiers |= (f.Modifiers & (Modifiers)0x99CE) != 0;
						// by default we assume ACC_SUPER for classes, so in the exceptional case we need a ModifiersAttribute
						setModifiers |= !f.IsSuper;
						if (enclosing != null && !cantNest)
						{
							// LAMESPEC the CLI spec says interfaces cannot contain nested types (Part.II, 9.6), but that rule isn't enforced
							// (and broken by J# as well), so we'll just ignore it too.
							typeBuilder = enclosing.DefineNestedType(AllocNestedTypeName(enclosingClassWrapper.Name, f.Name), typeAttribs);
						}
						else
#endif // STATIC_COMPILER
						{
							typeBuilder = wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs);
						}
					}
#if STATIC_COMPILER
					// When we're statically compiling, we associate the typeBuilder with the wrapper. This enables types in referenced assemblies to refer back to
					// types that we're currently compiling (i.e. a cyclic dependency between the currently assembly we're compiling and a referenced assembly).
					wrapper.GetClassLoader().SetWrapperForType(typeBuilder, wrapper);
					if (outerClass.outerClass != 0)
					{
						if (enclosing != null && cantNest)
						{
							AttributeHelper.SetNonNestedInnerClass(enclosing, f.Name);
						}
						if (enclosing == null || cantNest)
						{
							AttributeHelper.SetNonNestedOuterClass(typeBuilder, enclosingClassName);
						}
					}
					if (classFile.InnerClasses != null)
					{
						foreach (ClassFile.InnerClass inner in classFile.InnerClasses)
						{
							string name = classFile.GetConstantPoolClass(inner.innerClass);
							bool exists = false;
							try
							{
								exists = wrapper.GetClassLoader().LoadClassByDottedNameFast(name) != null;
							}
							catch (RetargetableJavaException) { }
							if (!exists)
							{
								AttributeHelper.SetNonNestedInnerClass(typeBuilder, name);
							}
						}
					}
					if (typeBuilder.FullName != wrapper.Name
						&& wrapper.Name.Replace('$', '+') != typeBuilder.FullName)
					{
						wrapper.classLoader.AddNameMapping(wrapper.Name, typeBuilder.FullName);
					}
					if (f.IsAnnotation && Annotation.HasRetentionPolicyRuntime(f.Annotations))
					{
						annotationBuilder = new AnnotationBuilder(this, enclosing);
						wrapper.SetAnnotation(annotationBuilder);
					}
					// For Java 5 Enum types, we generate a nested .NET enum.
					// This is primarily to support annotations that take enum parameters.
					if (f.IsEnum && f.IsPublic)
					{
						AddCliEnum();
					}
					AddInnerClassAttribute(enclosing != null, outerClass.innerClass != 0, mangledTypeName, outerClass.accessFlags);
					if (classFile.DeprecatedAttribute && !Annotation.HasObsoleteAttribute(classFile.Annotations))
					{
						AttributeHelper.SetDeprecatedAttribute(typeBuilder);
					}
					if (classFile.GenericSignature != null)
					{
						AttributeHelper.SetSignatureAttribute(typeBuilder, classFile.GenericSignature);
					}
					if (classFile.EnclosingMethod != null)
					{
						if (outerClass.outerClass == 0 && enclosing != null && !cantNest)
						{
							// we don't need to record the enclosing type, if we're compiling the current type as a nested type because of the EnclosingMethod attribute
							AttributeHelper.SetEnclosingMethodAttribute(typeBuilder, null, classFile.EnclosingMethod[1], classFile.EnclosingMethod[2]);
						}
						else
						{
							AttributeHelper.SetEnclosingMethodAttribute(typeBuilder, classFile.EnclosingMethod[0], classFile.EnclosingMethod[1], classFile.EnclosingMethod[2]);
						}
					}
					if (classFile.RuntimeVisibleTypeAnnotations != null)
					{
						AttributeHelper.SetRuntimeVisibleTypeAnnotationsAttribute(typeBuilder, classFile.RuntimeVisibleTypeAnnotations);
					}
					if (wrapper.classLoader.EmitStackTraceInfo)
					{
						if (f.SourceFileAttribute != null)
						{
							if ((enclosingClassWrapper == null && f.SourceFileAttribute == typeBuilder.Name + ".java")
								|| (enclosingClassWrapper != null && f.SourceFileAttribute == enclosingClassWrapper.sourceFileName))
							{
								// we don't need to record the name because it matches our heuristic
							}
							else
							{
								AttributeHelper.SetSourceFile(typeBuilder, f.SourceFileAttribute);
							}
						}
						else
						{
							AttributeHelper.SetSourceFile(typeBuilder, null);
						}
					}
					// NOTE in Whidbey we can (and should) use CompilerGeneratedAttribute to mark Synthetic types
					if (setModifiers || classFile.IsInternal || (classFile.Modifiers & (Modifiers.Synthetic | Modifiers.Annotation | Modifiers.Enum)) != 0)
					{
						AttributeHelper.SetModifiers(typeBuilder, classFile.Modifiers, classFile.IsInternal);
					}
#endif // STATIC_COMPILER
					if (hasclinit)
					{
						AddClinitTrigger();
					}
					if (HasStructLayoutAttributeAnnotation(classFile))
					{
						// when we have a StructLayoutAttribute, field order is significant,
						// so we link all fields here to make sure they are created in class file order.
						foreach (FieldWrapper fw in fields)
						{
							fw.Link();
						}
					}
				}
#if STATIC_COMPILER
				finally { }
#else
				catch (Exception x)
				{
					JVM.CriticalFailure("Exception during JavaTypeImpl.CreateStep2", x);
				}
#endif
			}

#if STATIC_COMPILER
			private void AddInnerClassAttribute(bool isNestedType, bool isInnerClass, string mangledTypeName, Modifiers innerClassFlags)
			{
				string name = classFile.Name;

				if (isNestedType)
				{
					if (name == enclosingClassWrapper.Name + "$" + typeBuilder.Name)
					{
						name = null;
					}
				}
				else if (name == mangledTypeName)
				{
					name = null;
				}

				if ((isInnerClass && CompiledTypeWrapper.PredictReflectiveModifiers(wrapper) != innerClassFlags) || name != null)
				{
					// HACK we abuse the InnerClassAttribute to record to real name for non-inner classes as well
					AttributeHelper.SetInnerClass(typeBuilder, name, isInnerClass ? innerClassFlags : wrapper.Modifiers);
				}
			}

			private void AddCliEnum()
			{
				CompilerClassLoader ccl = wrapper.classLoader;
				string name = "__Enum";
				while (!ccl.ReserveName(classFile.Name + "$" + name))
				{
					name += "_";
				}
				enumBuilder = typeBuilder.DefineNestedType(name, TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.NestedPublic | TypeAttributes.Serializable, Types.Enum);
				AttributeHelper.HideFromJava(enumBuilder);
				enumBuilder.DefineField("value__", Types.Int32, FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
				for (int i = 0; i < classFile.Fields.Length; i++)
				{
					if (classFile.Fields[i].IsEnum)
					{
						FieldBuilder fieldBuilder = enumBuilder.DefineField(classFile.Fields[i].Name, enumBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
						fieldBuilder.SetConstant(i);
					}
				}
				wrapper.SetEnumType(enumBuilder);
			}
#endif

			private void AddClinitTrigger()
			{
				// We create a empty method that we can use to trigger our .cctor
				// (previously we used RuntimeHelpers.RunClassConstructor, but that is slow and requires additional privileges)
				MethodAttributes attribs = MethodAttributes.Static | MethodAttributes.SpecialName;
				if (classFile.IsAbstract)
				{
					bool hasfields = false;
					// If we have any public static fields, the cctor trigger must (and may) be public as well
					foreach (ClassFile.Field fld in classFile.Fields)
					{
						if (fld.IsPublic && fld.IsStatic)
						{
							hasfields = true;
							break;
						}
					}
					attribs |= hasfields ? MethodAttributes.Public : MethodAttributes.FamORAssem;
				}
				else
				{
					attribs |= MethodAttributes.Public;
				}
				clinitMethod = typeBuilder.DefineMethod("__<clinit>", attribs, null, null);
				clinitMethod.GetILGenerator().Emit(OpCodes.Ret);
				// FXBUG on .NET 2.0 RTM x64 the JIT sometimes throws an InvalidProgramException while trying to inline this method,
				// so we prevent inlining for now (it also turns out that on x86 not inlining this method actually has a positive perf impact in some cases...)
				// http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=285772
				clinitMethod.SetImplementationFlags(clinitMethod.GetMethodImplementationFlags() | MethodImplAttributes.NoInlining);
			}

			private sealed class DelegateConstructorMethodWrapper : MethodWrapper
			{
				private MethodBuilder constructor;
				private MethodInfo invoke;

				internal DelegateConstructorMethodWrapper(DynamicTypeWrapper tw, ClassFile.Method m)
					: base(tw, m.Name, m.Signature, null, null, null, m.Modifiers, MemberFlags.None)
				{
				}

				internal void DoLink(TypeBuilder typeBuilder)
				{
					MethodAttributes attribs = MethodAttributes.HideBySig | MethodAttributes.Public;
					constructor = ReflectUtil.DefineConstructor(typeBuilder, attribs, new Type[] { Types.Object, Types.IntPtr });
					constructor.SetImplementationFlags(MethodImplAttributes.Runtime);
					MethodWrapper mw = GetParameters()[0].GetMethods()[0];
					mw.Link();
					invoke = (MethodInfo)mw.GetMethod();
				}

				internal override void EmitNewobj(CodeEmitter ilgen)
				{
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Ldvirtftn, invoke);
					ilgen.Emit(OpCodes.Newobj, constructor);
				}
			}

			private static bool HasStructLayoutAttributeAnnotation(ClassFile c)
			{
				if (c.Annotations != null)
				{
					foreach (object[] annot in c.Annotations)
					{
						if ("Lcli/System/Runtime/InteropServices/StructLayoutAttribute$Annotation;".Equals(annot[1]))
						{
							return true;
						}
					}
				}
				return false;
			}

#if STATIC_COMPILER
			private ClassFile.InnerClass getOuterClass()
			{
				ClassFile.InnerClass[] innerClasses = classFile.InnerClasses;
				if (innerClasses != null)
				{
					for (int j = 0; j < innerClasses.Length; j++)
					{
						if (innerClasses[j].innerClass != 0
							&& classFile.GetConstantPoolClass(innerClasses[j].innerClass) == classFile.Name)
						{
							return innerClasses[j];
						}
					}
				}
				return new ClassFile.InnerClass();
			}

			private bool IsSideEffectFreeStaticInitializerOrNoop(ClassFile.Method m, out bool noop)
			{
				if (m.ExceptionTable.Length != 0)
				{
					noop = false;
					return false;
				}
				noop = true;
				for (int i = 0; i < m.Instructions.Length; i++)
				{
					NormalizedByteCode bc;
					while ((bc = m.Instructions[i].NormalizedOpCode) == NormalizedByteCode.__goto)
					{
						int target = m.Instructions[i].TargetIndex;
						if (target <= i)
						{
							// backward branch means we can't do anything
							noop = false;
							return false;
						}
						// we must skip the unused instructions because the "remove assertions" optimization
						// uses a goto to remove the (now unused) code
						i = target;
					}
					if (bc == NormalizedByteCode.__getstatic || bc == NormalizedByteCode.__putstatic)
					{
						ClassFile.ConstantPoolItemFieldref fld = classFile.SafeGetFieldref(m.Instructions[i].Arg1);
						if (fld == null || fld.Class != classFile.Name)
						{
							noop = false;
							return false;
						}
						// don't allow getstatic to load non-primitive fields, because that would
						// cause the verifier to try to load the type
						if (bc == NormalizedByteCode.__getstatic && "L[".IndexOf(fld.Signature[0]) != -1)
						{
							noop = false;
							return false;
						}
						ClassFile.Field field = classFile.GetField(fld.Name, fld.Signature);
						if (field == null)
						{
							noop = false;
							return false;
						}
						if (bc == NormalizedByteCode.__putstatic)
						{
							if (field.IsProperty && field.PropertySetter != null)
							{
								noop = false;
								return false;
							}
						}
						else if (field.IsProperty && field.PropertyGetter != null)
						{
							noop = false;
							return false;
						}
					}
					else if (ByteCodeMetaData.CanThrowException(bc))
					{
						noop = false;
						return false;
					}
					else if (bc == NormalizedByteCode.__aconst_null
						|| (bc == NormalizedByteCode.__iconst && m.Instructions[i].Arg1 == 0)
						|| bc == NormalizedByteCode.__return
						|| bc == NormalizedByteCode.__nop)
					{
						// valid instructions in a potential noop <clinit>
					}
					else
					{
						noop = false;
					}
				}
				// the method needs to be verifiable to be side effect free, since we already analysed it,
				// we know that the verifier won't try to load any types (which isn't allowed at this time)
				try
				{
					new MethodAnalyzer(null, wrapper, null, classFile, m, wrapper.classLoader);
					return true;
				}
				catch (VerifyError)
				{
					return false;
				}
			}
#endif // STATIC_COMPILER

			private MethodWrapper GetMethodWrapperDuringCtor(TypeWrapper lookup, IList<MethodWrapper> methods, string name, string sig)
			{
				if (lookup == wrapper)
				{
					foreach (MethodWrapper mw in methods)
					{
						if (mw.Name == name && mw.Signature == sig)
						{
							return mw;
						}
					}
					if (lookup.BaseTypeWrapper == null)
					{
						return null;
					}
					else
					{
						return lookup.BaseTypeWrapper.GetMethodWrapper(name, sig, true);
					}
				}
				else
				{
					return lookup.GetMethodWrapper(name, sig, true);
				}
			}

			private void AddMirandaMethods(List<MethodWrapper> methods, List<MethodWrapper[]> baseMethods, TypeWrapper tw)
			{
				foreach (TypeWrapper iface in tw.Interfaces)
				{
					if (iface.IsPublic && this.wrapper.IsInterface)
					{
						// for interfaces, we only need miranda methods for non-public interfaces that we extend
						continue;
					}
					AddMirandaMethods(methods, baseMethods, iface);
					foreach (MethodWrapper ifmethod in iface.GetMethods())
					{
						// skip <clinit> and non-virtual interface methods introduced in Java 8
						if (ifmethod.IsVirtual)
						{
							TypeWrapper lookup = wrapper;
							while (lookup != null)
							{
								MethodWrapper mw = GetMethodWrapperDuringCtor(lookup, methods, ifmethod.Name, ifmethod.Signature);
								if (mw == null || (mw.IsMirandaMethod && mw.DeclaringType != wrapper))
								{
									mw = MirandaMethodWrapper.Create(wrapper, ifmethod);
									methods.Add(mw);
									baseMethods.Add(new MethodWrapper[] { ifmethod });
									break;
								}
								if (mw.IsMirandaMethod && mw.DeclaringType == wrapper)
								{
									methods[methods.IndexOf(mw)] = ((MirandaMethodWrapper)mw).Update(ifmethod);
									break;
								}
								if (!mw.IsStatic || mw.DeclaringType == wrapper)
								{
									break;
								}
								lookup = mw.DeclaringType.BaseTypeWrapper;
							}
						}
					}
				}
			}

			private void AddDelegateInvokeStubs(TypeWrapper tw, ref MethodWrapper[] methods)
			{
				foreach (TypeWrapper iface in tw.Interfaces)
				{
					if (iface.IsFakeNestedType
						&& iface.GetMethods().Length == 1
						&& iface.GetMethods()[0].IsDelegateInvokeWithByRefParameter)
					{
						MethodWrapper mw = new DelegateInvokeStubMethodWrapper(wrapper, iface.DeclaringTypeWrapper.TypeAsBaseType, iface.GetMethods()[0].Signature);
						if (GetMethodWrapperDuringCtor(wrapper, methods, mw.Name, mw.Signature) == null)
						{
							methods = ArrayUtil.Concat(methods, mw);
						}
					}
					AddDelegateInvokeStubs(iface, ref methods);
				}
			}

			private sealed class DelegateInvokeStubMethodWrapper : MethodWrapper
			{
				private readonly Type delegateType;

				internal DelegateInvokeStubMethodWrapper(TypeWrapper declaringType, Type delegateType, string sig)
					: base(declaringType, DotNetTypeWrapper.GetDelegateInvokeStubName(delegateType), sig, null, null, null, Modifiers.Public | Modifiers.Final, MemberFlags.HideFromReflection)
				{
					this.delegateType = delegateType;
				}

				internal MethodInfo DoLink(TypeBuilder tb)
				{
					MethodWrapper mw = this.DeclaringType.GetMethodWrapper("Invoke", this.Signature, true);

					MethodInfo invoke = delegateType.GetMethod("Invoke");
					ParameterInfo[] parameters = invoke.GetParameters();
					Type[] parameterTypes = new Type[parameters.Length];
					for (int i = 0; i < parameterTypes.Length; i++)
					{
						parameterTypes[i] = parameters[i].ParameterType;
					}
					MethodBuilder mb = tb.DefineMethod(this.Name, MethodAttributes.Public, invoke.ReturnType, parameterTypes);
					AttributeHelper.HideFromReflection(mb);
					CodeEmitter ilgen = CodeEmitter.Create(mb);
					if (mw == null || mw.IsStatic || !mw.IsPublic)
					{
						ilgen.EmitThrow(mw == null || mw.IsStatic ? "java.lang.AbstractMethodError" : "java.lang.IllegalAccessError", DeclaringType.Name + ".Invoke" + Signature);
						ilgen.DoEmit();
						return mb;
					}
					CodeEmitterLocal[] byrefs = new CodeEmitterLocal[parameters.Length];
					for (int i = 0; i < parameters.Length; i++)
					{
						if (parameters[i].ParameterType.IsByRef)
						{
							Type elemType = parameters[i].ParameterType.GetElementType();
							CodeEmitterLocal local = ilgen.DeclareLocal(ArrayTypeWrapper.MakeArrayType(elemType, 1));
							byrefs[i] = local;
							ilgen.Emit(OpCodes.Ldc_I4_1);
							ilgen.Emit(OpCodes.Newarr, elemType);
							ilgen.Emit(OpCodes.Stloc, local);
							ilgen.Emit(OpCodes.Ldloc, local);
							ilgen.Emit(OpCodes.Ldc_I4_0);
							ilgen.EmitLdarg(i + 1);
							ilgen.Emit(OpCodes.Ldobj, elemType);
							ilgen.Emit(OpCodes.Stelem, elemType);
						}
					}
					ilgen.BeginExceptionBlock();
					ilgen.Emit(OpCodes.Ldarg_0);
					for (int i = 0; i < parameters.Length; i++)
					{
						if (byrefs[i] != null)
						{
							ilgen.Emit(OpCodes.Ldloc, byrefs[i]);
						}
						else
						{
							ilgen.EmitLdarg(i + 1);
						}
					}
					mw.Link();
					mw.EmitCallvirt(ilgen);
					CodeEmitterLocal returnValue = null;
					if (mw.ReturnType != PrimitiveTypeWrapper.VOID)
					{
						returnValue = ilgen.DeclareLocal(mw.ReturnType.TypeAsSignatureType);
						ilgen.Emit(OpCodes.Stloc, returnValue);
					}
					CodeEmitterLabel exit = ilgen.DefineLabel();
					ilgen.EmitLeave(exit);
					ilgen.BeginFinallyBlock();
					for (int i = 0; i < parameters.Length; i++)
					{
						if (byrefs[i] != null)
						{
							Type elemType = byrefs[i].LocalType.GetElementType();
							ilgen.EmitLdarg(i + 1);
							ilgen.Emit(OpCodes.Ldloc, byrefs[i]);
							ilgen.Emit(OpCodes.Ldc_I4_0);
							ilgen.Emit(OpCodes.Ldelem, elemType);
							ilgen.Emit(OpCodes.Stobj, elemType);
						}
					}
					ilgen.Emit(OpCodes.Endfinally);
					ilgen.EndExceptionBlock();
					ilgen.MarkLabel(exit);
					if (returnValue != null)
					{
						ilgen.Emit(OpCodes.Ldloc, returnValue);
					}
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();
					return mb;
				}
			}

#if STATIC_COMPILER
			private static bool CheckInnerOuterNames(string inner, string outer)
			{
				// do some sanity checks on the inner/outer class names
				return inner.Length > outer.Length + 1 && inner[outer.Length] == '$' && inner.StartsWith(outer, StringComparison.Ordinal);
			}

			private string AllocNestedTypeName(string outer, string inner)
			{
				Debug.Assert(CheckInnerOuterNames(inner, outer));
				if (nestedTypeNames == null)
				{
					nestedTypeNames = new Dictionary<string, TypeWrapper>();
				}
				return DynamicClassLoader.TypeNameMangleImpl(nestedTypeNames, inner.Substring(outer.Length + 1), null);
			}
#endif // STATIC_COMPILER

			private int GetMethodIndex(MethodWrapper mw)
			{
				for (int i = 0; i < methods.Length; i++)
				{
					if (methods[i] == mw)
					{
						return i;
					}
				}
				throw new InvalidOperationException();
			}

			private static void CheckLoaderConstraints(MethodWrapper mw, MethodWrapper baseMethod)
			{
				if (mw.ReturnType != baseMethod.ReturnType)
				{
					if (mw.ReturnType.IsUnloadable || baseMethod.ReturnType.IsUnloadable)
					{
						// unloadable types can never cause a loader constraint violation
						if (mw.ReturnType.IsUnloadable && baseMethod.ReturnType.IsUnloadable)
						{
							((UnloadableTypeWrapper)mw.ReturnType).SetCustomModifier(((UnloadableTypeWrapper)baseMethod.ReturnType).CustomModifier);
						}
					}
					else
					{
#if STATIC_COMPILER
						StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has a return type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has a return type \"{1}\"", mw.ReturnType, baseMethod.ReturnType, mw.DeclaringType.Name, mw.Name, mw.Signature, baseMethod.DeclaringType.Name);
#else
						// when we're finishing types to save a debug image (in dynamic mode) we don't care about loader constraints anymore
						// (and we can't throw a LinkageError, because that would prevent the debug image from being saved)
						if (!JVM.FinishingForDebugSave)
						{
							throw new LinkageError("Loader constraints violated");
						}
#endif
					}
				}
				TypeWrapper[] here = mw.GetParameters();
				TypeWrapper[] there = baseMethod.GetParameters();
				for (int i = 0; i < here.Length; i++)
				{
					if (here[i] != there[i])
					{
						if (here[i].IsUnloadable || there[i].IsUnloadable)
						{
							// unloadable types can never cause a loader constraint violation
							if (here[i].IsUnloadable && there[i].IsUnloadable)
							{
								((UnloadableTypeWrapper)here[i]).SetCustomModifier(((UnloadableTypeWrapper)there[i]).CustomModifier);
							}
						}
						else
						{
#if STATIC_COMPILER
							StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has an argument type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has an argument type \"{1}\"", here[i], there[i], mw.DeclaringType.Name, mw.Name, mw.Signature, baseMethod.DeclaringType.Name);
#else
							// when we're finishing types to save a debug image (in dynamic mode) we don't care about loader constraints anymore
							// (and we can't throw a LinkageError, because that would prevent the debug image from being saved)
							if (!JVM.FinishingForDebugSave)
							{
								throw new LinkageError("Loader constraints violated");
							}
#endif
						}
					}
				}
			}

			private int GetFieldIndex(FieldWrapper fw)
			{
				for (int i = 0; i < fields.Length; i++)
				{
					if (fields[i] == fw)
					{
						return i;
					}
				}
				throw new InvalidOperationException();
			}

			internal override FieldInfo LinkField(FieldWrapper fw)
			{
				if (fw is DynamicPropertyFieldWrapper)
				{
					((DynamicPropertyFieldWrapper)fw).DoLink(typeBuilder);
					return null;
				}
				int fieldIndex = GetFieldIndex(fw);
#if STATIC_COMPILER
				if (wrapper.GetClassLoader().RemoveUnusedFields
					&& fw.IsPrivate
					&& fw.IsStatic
					&& fw.IsFinal
					&& !fw.IsSerialVersionUID
					&& classFile.Fields[fieldIndex].Annotations == null
					&& !classFile.IsReferenced(classFile.Fields[fieldIndex]))
				{
					// unused, so we skip it
					Tracer.Info(Tracer.Compiler, "Unused field {0}::{1}", wrapper.Name, fw.Name);
					return null;
				}
				// for compatibility with broken Java code that assumes that reflection returns the fields in class declaration
				// order, we emit the fields in class declaration order in the .NET metadata (and then when we retrieve them
				// using .NET reflection, we sort on metadata token.)
				if (fieldIndex > 0)
				{
					if (!fields[fieldIndex - 1].IsLinked)
					{
						for (int i = 0; i < fieldIndex; i++)
						{
							fields[i].Link();
						}
					}
				}
				if (fieldIndex >= classFile.Fields.Length)
				{
					// this must be a field defined in map.xml
					FieldAttributes fieldAttribs = 0;
					if (fw.IsPublic)
					{
						fieldAttribs |= FieldAttributes.Public;
					}
					else if (fw.IsProtected)
					{
						fieldAttribs |= FieldAttributes.FamORAssem;
					}
					else if (fw.IsPrivate)
					{
						fieldAttribs |= FieldAttributes.Private;
					}
					else
					{
						fieldAttribs |= FieldAttributes.Assembly;
					}
					if (fw.IsStatic)
					{
						fieldAttribs |= FieldAttributes.Static;
					}
					if (fw.IsFinal)
					{
						fieldAttribs |= FieldAttributes.InitOnly;
					}
					return DefineField(fw.Name, fw.FieldTypeWrapper, fieldAttribs, fw.IsVolatile);
				}
#endif // STATIC_COMPILER
				FieldBuilder field;
				ClassFile.Field fld = classFile.Fields[fieldIndex];
				FieldAttributes attribs = 0;
				string realFieldName = UnicodeUtil.EscapeInvalidSurrogates(fld.Name);
				if (!ReferenceEquals(realFieldName, fld.Name))
				{
					attribs |= FieldAttributes.SpecialName;
				}
				MethodAttributes methodAttribs = MethodAttributes.HideBySig;
#if STATIC_COMPILER
				bool setModifiers = fld.IsInternal || (fld.Modifiers & (Modifiers.Synthetic | Modifiers.Enum)) != 0;
#endif
				if (fld.IsPrivate)
				{
					attribs |= FieldAttributes.Private;
				}
				else if (fld.IsProtected)
				{
					attribs |= FieldAttributes.FamORAssem;
					methodAttribs |= MethodAttributes.FamORAssem;
				}
				else if (fld.IsPublic)
				{
					attribs |= FieldAttributes.Public;
					methodAttribs |= MethodAttributes.Public;
				}
				else
				{
					attribs |= FieldAttributes.Assembly;
					methodAttribs |= MethodAttributes.Assembly;
				}

				if (fld.IsStatic)
				{
					attribs |= FieldAttributes.Static;
					methodAttribs |= MethodAttributes.Static;
				}
				// NOTE "constant" static finals are converted into literals
				// TODO it would be possible for Java code to change the value of a non-blank static final, but I don't
				// know if we want to support this (since the Java JITs don't really support it either)
				if (fld.IsStaticFinalConstant)
				{
					Profiler.Count("Static Final Constant");
					attribs |= FieldAttributes.Literal;
					field = DefineField(realFieldName, fw.FieldTypeWrapper, attribs, false);
					field.SetConstant(fld.ConstantValue);
				}
				else
				{
#if STATIC_COMPILER
					if (wrapper.IsPublic && wrapper.NeedsType2AccessStub(fw))
					{
						// this field is going to get a type 2 access stub, so we hide the actual field
						attribs &= ~FieldAttributes.FieldAccessMask;
						attribs |= FieldAttributes.Assembly;
						// instead of adding HideFromJava we rename the field to avoid confusing broken compilers
						// see https://sourceforge.net/tracker/?func=detail&atid=525264&aid=3056721&group_id=69637
						// additional note: now that we maintain the ordering of the fields, we need to recognize
						// these fields so that we know where to insert the corresponding accessor property FieldWrapper.
						realFieldName = NamePrefix.Type2AccessStubBackingField + realFieldName;
					}
					else if (fld.IsFinal)
					{
						if (wrapper.IsInterface || wrapper.classLoader.StrictFinalFieldSemantics)
						{
							attribs |= FieldAttributes.InitOnly;
						}
						else
						{
							setModifiers = true;
						}
					}
#else
					if (fld.IsFinal && wrapper.IsInterface)
					{
						attribs |= FieldAttributes.InitOnly;
					}
#endif

					field = DefineField(realFieldName, fw.FieldTypeWrapper, attribs, fld.IsVolatile);
				}
				if (fld.IsTransient)
				{
					CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(JVM.Import(typeof(NonSerializedAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
					field.SetCustomAttribute(transientAttrib);
				}
#if STATIC_COMPILER
				{
					// if the Java modifiers cannot be expressed in .NET, we emit the Modifiers attribute to store
					// the Java modifiers
					if (setModifiers)
					{
						AttributeHelper.SetModifiers(field, fld.Modifiers, fld.IsInternal);
					}
					if (fld.DeprecatedAttribute && !Annotation.HasObsoleteAttribute(fld.Annotations))
					{
						AttributeHelper.SetDeprecatedAttribute(field);
					}
					if (fld.GenericSignature != null)
					{
						AttributeHelper.SetSignatureAttribute(field, fld.GenericSignature);
					}
					if (fld.RuntimeVisibleTypeAnnotations != null)
					{
						AttributeHelper.SetRuntimeVisibleTypeAnnotationsAttribute(field, fld.RuntimeVisibleTypeAnnotations);
					}
				}
#endif // STATIC_COMPILER
				return field;
			}

			private FieldBuilder DefineField(string name, TypeWrapper tw, FieldAttributes attribs, bool isVolatile)
			{
				Type[] modreq = isVolatile ? new Type[] { Types.IsVolatile } : Type.EmptyTypes;
				return typeBuilder.DefineField(name, tw.TypeAsSignatureType, modreq, wrapper.GetModOpt(tw, false), attribs);
			}

			internal override void EmitRunClassConstructor(CodeEmitter ilgen)
			{
				if (clinitMethod != null)
				{
					ilgen.Emit(OpCodes.Call, clinitMethod);
				}
			}

			internal override DynamicImpl Finish()
			{
				TypeWrapper baseTypeWrapper = wrapper.BaseTypeWrapper;
				if (baseTypeWrapper != null)
				{
					baseTypeWrapper.Finish();
					baseTypeWrapper.LinkAll();
				}
				// NOTE there is a bug in the CLR (.NET 1.0 & 1.1 [1.2 is not yet available]) that
				// causes the AppDomain.TypeResolve event to receive the incorrect type name for nested types.
				// The Name in the ResolveEventArgs contains only the nested type name, not the full type name,
				// for example, if the type being resolved is "MyOuterType+MyInnerType", then the event only
				// receives "MyInnerType" as the name. Since we only compile inner classes as nested types
				// when we're statically compiling, we can only run into this bug when we're statically compiling.
				// NOTE To work around this bug, we have to make sure that all types that are going to be
				// required in finished form, are finished explicitly here. It isn't clear what other types are
				// required to be finished. I instrumented a static compilation of classpath.dll and this
				// turned up no other cases of the TypeResolve event firing.
				foreach (TypeWrapper iface in wrapper.interfaces)
				{
					iface.Finish();
					iface.LinkAll();
				}
				// make sure all classes are loaded, before we start finishing the type. During finishing, we
				// may not run any Java code, because that might result in a request to finish the type that we
				// are in the process of finishing, and this would be a problem.
				// Prevent infinity recursion for broken class loaders by keeping a recursion count and falling
				// back to late binding if we recurse more than twice.
				LoadMode mode = System.Threading.Interlocked.Increment(ref recursionCount) > 2 || (JVM.DisableEagerClassLoading && wrapper.Name != "sun.reflect.misc.Trampoline")
					? LoadMode.ReturnUnloadable
					: LoadMode.Link;
				try
				{
					classFile.Link(wrapper, mode);
					for (int i = 0; i < fields.Length; i++)
					{
						fields[i].Link(mode);
					}
					for (int i = 0; i < methods.Length; i++)
					{
						methods[i].Link(mode);
					}
				}
				finally
				{
					System.Threading.Interlocked.Decrement(ref recursionCount);
				}
				// this is the correct lock, FinishCore doesn't call any user code and mutates global state,
				// so it needs to be protected by a lock.
				lock (this)
				{
					FinishedTypeImpl impl;
					try
					{
						// call FinishCore in the finally to avoid Thread.Abort interrupting the thread
					}
					finally
					{
						impl = FinishCore();
					}
					return impl;
				}
			}

			private FinishedTypeImpl FinishCore()
			{
				// it is possible that the loading of the referenced classes triggered a finish of us,
				// if that happens, we just return
				if (finishedType != null)
				{
					return finishedType;
				}
				if (finishInProgress)
				{
					throw new InvalidOperationException("Recursive finish attempt for " + wrapper.Name);
				}
				finishInProgress = true;
				Tracer.Info(Tracer.Compiler, "Finishing: {0}", wrapper.Name);
				Profiler.Enter("JavaTypeImpl.Finish.Core");
				try
				{
					TypeWrapper declaringTypeWrapper = null;
					TypeWrapper[] innerClassesTypeWrappers = TypeWrapper.EmptyArray;
					// if we're an inner class, we need to attach an InnerClass attribute
					ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
					if (innerclasses != null)
					{
						// TODO consider not pre-computing innerClassesTypeWrappers and declaringTypeWrapper here
						List<TypeWrapper> wrappers = new List<TypeWrapper>();
						for (int i = 0; i < innerclasses.Length; i++)
						{
							if (innerclasses[i].innerClass != 0 && innerclasses[i].outerClass != 0)
							{
								if (classFile.GetConstantPoolClassType(innerclasses[i].outerClass) == wrapper)
								{
									wrappers.Add(classFile.GetConstantPoolClassType(innerclasses[i].innerClass));
								}
								if (classFile.GetConstantPoolClassType(innerclasses[i].innerClass) == wrapper)
								{
									declaringTypeWrapper = classFile.GetConstantPoolClassType(innerclasses[i].outerClass);
								}
							}
						}
						innerClassesTypeWrappers = wrappers.ToArray();
#if STATIC_COMPILER
						// before we bake our type, we need to link any inner annotations to allow them to create their attribute type (as a nested type)
						foreach (TypeWrapper tw in innerClassesTypeWrappers)
						{
							DynamicTypeWrapper dtw = tw as DynamicTypeWrapper;
							if (dtw != null)
							{
								JavaTypeImpl impl = dtw.impl as JavaTypeImpl;
								if (impl != null)
								{
									if (impl.annotationBuilder != null)
									{
										impl.annotationBuilder.Link();
									}
								}
							}
						}
#endif //STATIC_COMPILER
					}
#if STATIC_COMPILER
					if (annotationBuilder != null)
					{
						CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(AnnotationAttributeAttribute)).GetConstructor(new Type[] { Types.String }),
							new object[] { UnicodeUtil.EscapeInvalidSurrogates(annotationBuilder.AttributeTypeName) });
						typeBuilder.SetCustomAttribute(cab);
					}
					if (!wrapper.IsInterface && wrapper.IsMapUnsafeException)
					{
						// mark all exceptions that are unsafe for mapping with a custom attribute,
						// so that at runtime we can quickly assertain if an exception type can be
						// caught without filtering
						AttributeHelper.SetExceptionIsUnsafeForMapping(typeBuilder);
					}
#endif

					FinishContext context = new FinishContext(host, classFile, wrapper, typeBuilder);
					Type type = context.FinishImpl();
#if STATIC_COMPILER
					if (annotationBuilder != null)
					{
						annotationBuilder.Finish(this);
					}
					if (enumBuilder != null)
					{
						enumBuilder.CreateType();
					}
					if (privateInterfaceMethods != null)
					{
						privateInterfaceMethods.CreateType();
					}
#endif
					MethodInfo finishedClinitMethod = clinitMethod;
#if !STATIC_COMPILER
					if (finishedClinitMethod != null)
					{
						// In dynamic mode, we may need to emit a call to this method from a DynamicMethod which doesn't support calling unfinished methods,
						// so we must resolve to the real method here.
						finishedClinitMethod = type.GetMethod("__<clinit>", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
					}
#endif
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, wrapper.ReflectiveModifiers, Metadata.Create(classFile), finishedClinitMethod, finalizeMethod, host);
					return finishedType;
				}
#if !STATIC_COMPILER
				catch (Exception x)
				{
					JVM.CriticalFailure("Exception during finishing of: " + wrapper.Name, x);
					return null;
				}
#endif
				finally
				{
					Profiler.Leave("JavaTypeImpl.Finish.Core");
				}
			}

#if STATIC_COMPILER
			private bool IsValidAnnotationElementType(string type)
			{
				if (type[0] == '[')
				{
					type = type.Substring(1);
				}
				switch (type)
				{
					case "Z":
					case "B":
					case "S":
					case "C":
					case "I":
					case "J":
					case "F":
					case "D":
					case "Ljava.lang.String;":
					case "Ljava.lang.Class;":
						return true;
				}
				if (type.StartsWith("L") && type.EndsWith(";"))
				{
					try
					{
						TypeWrapper tw = wrapper.GetClassLoader().LoadClassByDottedNameFast(type.Substring(1, type.Length - 2));
						if (tw != null)
						{
							if ((tw.Modifiers & Modifiers.Annotation) != 0)
							{
								return true;
							}
							if ((tw.Modifiers & Modifiers.Enum) != 0)
							{
								TypeWrapper enumType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast("java.lang.Enum");
								if (enumType != null && tw.IsSubTypeOf(enumType))
								{
									return true;
								}
							}
						}
					}
					catch
					{
					}
				}
				return false;
			}

			sealed class AnnotationBuilder : Annotation
			{
				private JavaTypeImpl impl;
				private TypeBuilder outer;
				private TypeBuilder annotationTypeBuilder;
				private TypeBuilder attributeTypeBuilder;
				private MethodBuilder defineConstructor;

				internal AnnotationBuilder(JavaTypeImpl o, TypeBuilder outer)
				{
					this.impl = o;
					this.outer = outer;
				}

				internal void Link()
				{
					if (impl == null)
					{
						return;
					}
					JavaTypeImpl o = impl;
					impl = null;

					// Make sure the annotation type only has valid methods
					for (int i = 0; i < o.methods.Length; i++)
					{
						if (!o.methods[i].IsStatic)
						{
							if (!o.methods[i].Signature.StartsWith("()"))
							{
								return;
							}
							if (!o.IsValidAnnotationElementType(o.methods[i].Signature.Substring(2)))
							{
								return;
							}
						}
					}

					// we only set annotationTypeBuilder if we're valid
					annotationTypeBuilder = o.typeBuilder;

					TypeWrapper annotationAttributeBaseType = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.AnnotationAttributeBase");

					// make sure we don't clash with another class name
					CompilerClassLoader ccl = o.wrapper.classLoader;
					string name = UnicodeUtil.EscapeInvalidSurrogates(o.classFile.Name);
					while (!ccl.ReserveName(name + "Attribute"))
					{
						name += "_";
					}

					TypeAttributes typeAttributes = TypeAttributes.Class | TypeAttributes.Sealed;
					if (o.enclosingClassWrapper != null)
					{
						if (o.wrapper.IsPublic)
						{
							typeAttributes |= TypeAttributes.NestedPublic;
						}
						else
						{
							typeAttributes |= TypeAttributes.NestedAssembly;
						}
						attributeTypeBuilder = outer.DefineNestedType(o.AllocNestedTypeName(o.enclosingClassWrapper.Name, name + "Attribute"), typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
					}
					else
					{
						if (o.wrapper.IsPublic)
						{
							typeAttributes |= TypeAttributes.Public;
						}
						else
						{
							typeAttributes |= TypeAttributes.NotPublic;
						}
						attributeTypeBuilder = o.wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(name + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
					}
					if (o.wrapper.IsPublic)
					{
						// In the Java world, the class appears as a non-public proxy class
						AttributeHelper.SetModifiers(attributeTypeBuilder, Modifiers.Final, false);
					}
					// NOTE we "abuse" the InnerClassAttribute to add a custom attribute to name the class "$Proxy[Annotation]" in the Java world
					int dotindex = o.classFile.Name.LastIndexOf('.') + 1;
					AttributeHelper.SetInnerClass(attributeTypeBuilder, o.classFile.Name.Substring(0, dotindex) + "$Proxy" + o.classFile.Name.Substring(dotindex), Modifiers.Final);
					attributeTypeBuilder.AddInterfaceImplementation(o.typeBuilder);
					AttributeHelper.SetImplementsAttribute(attributeTypeBuilder, new TypeWrapper[] { o.wrapper });

					if (o.classFile.Annotations != null)
					{
						CustomAttributeBuilder attributeUsageAttribute = null;
						bool hasAttributeUsageAttribute = false;
						foreach (object[] def in o.classFile.Annotations)
						{
							if (def[1].Equals("Ljava/lang/annotation/Target;") && !hasAttributeUsageAttribute)
							{
								for (int i = 2; i < def.Length; i += 2)
								{
									if (def[i].Equals("value"))
									{
										object[] val = def[i + 1] as object[];
										if (val != null
											&& val.Length > 0
											&& val[0].Equals(AnnotationDefaultAttribute.TAG_ARRAY))
										{
											AttributeTargets targets = 0;
											for (int j = 1; j < val.Length; j++)
											{
												object[] eval = val[j] as object[];
												if (eval != null
													&& eval.Length == 3
													&& eval[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)
													&& eval[1].Equals("Ljava/lang/annotation/ElementType;"))
												{
													switch ((string)eval[2])
													{
														case "ANNOTATION_TYPE":
															targets |= AttributeTargets.Interface;
															break;
														case "CONSTRUCTOR":
															targets |= AttributeTargets.Constructor;
															break;
														case "FIELD":
															targets |= AttributeTargets.Field;
															break;
														case "LOCAL_VARIABLE":
															break;
														case "METHOD":
															targets |= AttributeTargets.Method;
															break;
														case "PACKAGE":
															targets |= AttributeTargets.Interface;
															break;
														case "PARAMETER":
															targets |= AttributeTargets.Parameter;
															break;
														case "TYPE":
															targets |= AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Delegate | AttributeTargets.Enum;
															break;
													}
												}
											}
											attributeUsageAttribute = new CustomAttributeBuilder(JVM.Import(typeof(AttributeUsageAttribute)).GetConstructor(new Type[] { JVM.Import(typeof(AttributeTargets)) }), new object[] { targets });
										}
									}
								}
							}
							else
							{
								// apply any .NET custom attributes that are on the annotation to the custom attribute we synthesize
								// (for example, to allow AttributeUsageAttribute to be overridden)
								Annotation annotation = Annotation.Load(o.wrapper, def);
								if (annotation != null && annotation.IsCustomAttribute)
								{
									annotation.Apply(o.wrapper.GetClassLoader(), attributeTypeBuilder, def);
								}
								if (def[1].Equals("Lcli/System/AttributeUsageAttribute$Annotation;"))
								{
									hasAttributeUsageAttribute = true;
								}
							}
						}
						if (attributeUsageAttribute != null && !hasAttributeUsageAttribute)
						{
							attributeTypeBuilder.SetCustomAttribute(attributeUsageAttribute);
						}
					}

					defineConstructor = ReflectUtil.DefineConstructor(attributeTypeBuilder, MethodAttributes.Public, new Type[] { JVM.Import(typeof(object[])) });
					AttributeHelper.SetEditorBrowsableNever(defineConstructor);
				}

				private static Type TypeWrapperToAnnotationParameterType(TypeWrapper tw)
				{
					bool isArray = false;
					if (tw.IsArray)
					{
						isArray = true;
						tw = tw.ElementTypeWrapper;
					}
					if (tw.Annotation != null)
					{
						// we don't support Annotation args
						return null;
					}
					else
					{
						Type argType;
						if (tw == CoreClasses.java.lang.Class.Wrapper)
						{
							argType = Types.Type;
						}
						else if (tw.EnumType != null)	// is it a Java enum?
						{
							argType = tw.EnumType;
						}
						else if (IsDotNetEnum(tw))
						{
							argType = tw.DeclaringTypeWrapper.TypeAsSignatureType;
						}
						else
						{
							argType = tw.TypeAsSignatureType;
						}
						if (isArray)
						{
							argType = ArrayTypeWrapper.MakeArrayType(argType, 1);
						}
						return argType;
					}
				}

				private static bool IsDotNetEnum(TypeWrapper tw)
				{
					return tw.IsFakeNestedType && (tw.Modifiers & Modifiers.Enum) != 0;
				}

				internal string AttributeTypeName
				{
					get
					{
						Link();
						if (attributeTypeBuilder != null)
						{
							return attributeTypeBuilder.FullName;
						}
						return null;
					}
				}

				private static void EmitSetValueCall(TypeWrapper annotationAttributeBaseType, CodeEmitter ilgen, string name, TypeWrapper tw, int argIndex)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldstr, name);
					ilgen.EmitLdarg(argIndex);
					if (tw.TypeAsSignatureType.IsValueType)
					{
						ilgen.Emit(OpCodes.Box, tw.TypeAsSignatureType);
					}
					else if (tw.EnumType != null)	// is it a Java enum?
					{
						ilgen.Emit(OpCodes.Box, tw.EnumType);
					}
					else if (IsDotNetEnum(tw))
					{
						ilgen.Emit(OpCodes.Box, tw.DeclaringTypeWrapper.TypeAsSignatureType);
					}
					MethodWrapper setValueMethod = annotationAttributeBaseType.GetMethodWrapper("setValue", "(Ljava.lang.String;Ljava.lang.Object;)V", false);
					setValueMethod.Link();
					setValueMethod.EmitCall(ilgen);
				}

				internal void Finish(JavaTypeImpl o)
				{
					Link();
					if (annotationTypeBuilder == null)
					{
						// not a valid annotation type
						return;
					}
					TypeWrapper annotationAttributeBaseType = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.AnnotationAttributeBase");
					annotationAttributeBaseType.Finish();

					int requiredArgCount = 0;
					int valueArg = -1;
					bool unsupported = false;
					for (int i = 0; i < o.methods.Length; i++)
					{
						if (!o.methods[i].IsStatic)
						{
							if (valueArg == -1 && o.methods[i].Name == "value")
							{
								valueArg = i;
							}
							if (o.classFile.Methods[i].AnnotationDefault == null)
							{
								if (TypeWrapperToAnnotationParameterType(o.methods[i].ReturnType) == null)
								{
									unsupported = true;
									break;
								}
								requiredArgCount++;
							}
						}
					}

					MethodBuilder defaultConstructor = ReflectUtil.DefineConstructor(attributeTypeBuilder, unsupported || requiredArgCount > 0 ? MethodAttributes.Private : MethodAttributes.Public, Type.EmptyTypes);
					CodeEmitter ilgen;

					if (!unsupported)
					{
						if (requiredArgCount > 0)
						{
							Type[] args = new Type[requiredArgCount];
							for (int i = 0, j = 0; i < o.methods.Length; i++)
							{
								if (!o.methods[i].IsStatic)
								{
									if (o.classFile.Methods[i].AnnotationDefault == null)
									{
										args[j++] = TypeWrapperToAnnotationParameterType(o.methods[i].ReturnType);
									}
								}
							}
							MethodBuilder reqArgConstructor = ReflectUtil.DefineConstructor(attributeTypeBuilder, MethodAttributes.Public, args);
							AttributeHelper.HideFromJava(reqArgConstructor);
							ilgen = CodeEmitter.Create(reqArgConstructor);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Call, defaultConstructor);
							for (int i = 0, j = 0; i < o.methods.Length; i++)
							{
								if (!o.methods[i].IsStatic)
								{
									if (o.classFile.Methods[i].AnnotationDefault == null)
									{
										reqArgConstructor.DefineParameter(++j, ParameterAttributes.None, o.methods[i].Name);
										EmitSetValueCall(annotationAttributeBaseType, ilgen, o.methods[i].Name, o.methods[i].ReturnType, j);
									}
								}
							}
							ilgen.Emit(OpCodes.Ret);
							ilgen.DoEmit();
						}
						else if (valueArg != -1)
						{
							// We don't have any required parameters, but we do have an optional "value" parameter,
							// so we create an additional constructor (the default constructor will be public in this case)
							// that accepts the value parameter.
							Type argType = TypeWrapperToAnnotationParameterType(o.methods[valueArg].ReturnType);
							if (argType != null)
							{
								MethodBuilder cb = ReflectUtil.DefineConstructor(attributeTypeBuilder, MethodAttributes.Public, new Type[] { argType });
								AttributeHelper.HideFromJava(cb);
								cb.DefineParameter(1, ParameterAttributes.None, "value");
								ilgen = CodeEmitter.Create(cb);
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Call, defaultConstructor);
								EmitSetValueCall(annotationAttributeBaseType, ilgen, "value", o.methods[valueArg].ReturnType, 1);
								ilgen.Emit(OpCodes.Ret);
								ilgen.DoEmit();
							}
						}
					}

					ilgen = CodeEmitter.Create(defaultConstructor);
					ilgen.Emit(OpCodes.Ldarg_0);
					o.wrapper.EmitClassLiteral(ilgen);
					annotationAttributeBaseType.GetMethodWrapper("<init>", "(Ljava.lang.Class;)V", false).EmitCall(ilgen);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();

					ilgen = CodeEmitter.Create(defineConstructor);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Call, defaultConstructor);
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldarg_1);
					annotationAttributeBaseType.GetMethodWrapper("setDefinition", "([Ljava.lang.Object;)V", false).EmitCall(ilgen);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();

					MethodWrapper getValueMethod = annotationAttributeBaseType.GetMethodWrapper("getValue", "(Ljava.lang.String;)Ljava.lang.Object;", false);
					MethodWrapper getByteValueMethod = annotationAttributeBaseType.GetMethodWrapper("getByteValue", "(Ljava.lang.String;)B", false);
					MethodWrapper getBooleanValueMethod = annotationAttributeBaseType.GetMethodWrapper("getBooleanValue", "(Ljava.lang.String;)Z", false);
					MethodWrapper getCharValueMethod = annotationAttributeBaseType.GetMethodWrapper("getCharValue", "(Ljava.lang.String;)C", false);
					MethodWrapper getShortValueMethod = annotationAttributeBaseType.GetMethodWrapper("getShortValue", "(Ljava.lang.String;)S", false);
					MethodWrapper getIntValueMethod = annotationAttributeBaseType.GetMethodWrapper("getIntValue", "(Ljava.lang.String;)I", false);
					MethodWrapper getFloatValueMethod = annotationAttributeBaseType.GetMethodWrapper("getFloatValue", "(Ljava.lang.String;)F", false);
					MethodWrapper getLongValueMethod = annotationAttributeBaseType.GetMethodWrapper("getLongValue", "(Ljava.lang.String;)J", false);
					MethodWrapper getDoubleValueMethod = annotationAttributeBaseType.GetMethodWrapper("getDoubleValue", "(Ljava.lang.String;)D", false);
					for (int i = 0; i < o.methods.Length; i++)
					{
						// skip <clinit> and non-virtual interface methods introduced in Java 8
						if (o.methods[i].IsVirtual)
						{
							MethodBuilder mb = o.methods[i].GetDefineMethodHelper().DefineMethod(o.wrapper, attributeTypeBuilder, o.methods[i].Name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot);
							attributeTypeBuilder.DefineMethodOverride(mb, (MethodInfo)o.methods[i].GetMethod());
							ilgen = CodeEmitter.Create(mb);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldstr, o.methods[i].Name);
							if (o.methods[i].ReturnType.IsPrimitive)
							{
								if (o.methods[i].ReturnType == PrimitiveTypeWrapper.BYTE)
								{
									getByteValueMethod.EmitCall(ilgen);
								}
								else if (o.methods[i].ReturnType == PrimitiveTypeWrapper.BOOLEAN)
								{
									getBooleanValueMethod.EmitCall(ilgen);
								}
								else if (o.methods[i].ReturnType == PrimitiveTypeWrapper.CHAR)
								{
									getCharValueMethod.EmitCall(ilgen);
								}
								else if (o.methods[i].ReturnType == PrimitiveTypeWrapper.SHORT)
								{
									getShortValueMethod.EmitCall(ilgen);
								}
								else if (o.methods[i].ReturnType == PrimitiveTypeWrapper.INT)
								{
									getIntValueMethod.EmitCall(ilgen);
								}
								else if (o.methods[i].ReturnType == PrimitiveTypeWrapper.FLOAT)
								{
									getFloatValueMethod.EmitCall(ilgen);
								}
								else if (o.methods[i].ReturnType == PrimitiveTypeWrapper.LONG)
								{
									getLongValueMethod.EmitCall(ilgen);
								}
								else if (o.methods[i].ReturnType == PrimitiveTypeWrapper.DOUBLE)
								{
									getDoubleValueMethod.EmitCall(ilgen);
								}
								else
								{
									throw new InvalidOperationException();
								}
							}
							else
							{
								getValueMethod.EmitCall(ilgen);
								o.methods[i].ReturnType.EmitCheckcast(ilgen);
							}
							ilgen.Emit(OpCodes.Ret);
							ilgen.DoEmit();

							if (o.classFile.Methods[i].AnnotationDefault != null
								&& !(o.methods[i].Name == "value" && requiredArgCount == 0))
							{
								// now add a .NET property for this annotation optional parameter
								Type argType = TypeWrapperToAnnotationParameterType(o.methods[i].ReturnType);
								if (argType != null)
								{
									PropertyBuilder pb = attributeTypeBuilder.DefineProperty(o.methods[i].Name, PropertyAttributes.None, argType, Type.EmptyTypes);
									AttributeHelper.HideFromJava(pb);
									MethodBuilder setter = attributeTypeBuilder.DefineMethod("set_" + o.methods[i].Name, MethodAttributes.Public, Types.Void, new Type[] { argType });
									AttributeHelper.HideFromJava(setter);
									pb.SetSetMethod(setter);
									ilgen = CodeEmitter.Create(setter);
									EmitSetValueCall(annotationAttributeBaseType, ilgen, o.methods[i].Name, o.methods[i].ReturnType, 1);
									ilgen.Emit(OpCodes.Ret);
									ilgen.DoEmit();
									MethodBuilder getter = attributeTypeBuilder.DefineMethod("get_" + o.methods[i].Name, MethodAttributes.Public, argType, Type.EmptyTypes);
									AttributeHelper.HideFromJava(getter);
									pb.SetGetMethod(getter);
									// TODO implement the getter method
									ilgen = CodeEmitter.Create(getter);
									ilgen.ThrowException(JVM.Import(typeof(NotImplementedException)));
									ilgen.DoEmit();
								}
							}
						}
					}
					attributeTypeBuilder.CreateType();
				}

				private CustomAttributeBuilder MakeCustomAttributeBuilder(ClassLoaderWrapper loader, object annotation)
				{
					Link();
					ConstructorInfo ctor = defineConstructor != null
						? defineConstructor.__AsConstructorInfo()
						: StaticCompiler.GetRuntimeType("IKVM.Attributes.DynamicAnnotationAttribute").GetConstructor(new Type[] { Types.Object.MakeArrayType() });
					return new CustomAttributeBuilder(ctor, new object[] { AnnotationDefaultAttribute.Escape(QualifyClassNames(loader, annotation)) });
				}

				internal override void Apply(ClassLoaderWrapper loader, TypeBuilder tb, object annotation)
				{
					tb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
				}

				internal override void Apply(ClassLoaderWrapper loader, MethodBuilder mb, object annotation)
				{
					mb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
				}

				internal override void Apply(ClassLoaderWrapper loader, FieldBuilder fb, object annotation)
				{
					fb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
				}

				internal override void Apply(ClassLoaderWrapper loader, ParameterBuilder pb, object annotation)
				{
					pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
				}

				internal override void Apply(ClassLoaderWrapper loader, AssemblyBuilder ab, object annotation)
				{
					ab.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
				}

				internal override void Apply(ClassLoaderWrapper loader, PropertyBuilder pb, object annotation)
				{
					pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
				}

				internal override bool IsCustomAttribute
				{
					get { return false; }
				}
			}
#endif // STATIC_COMPILER

			internal override TypeWrapper[] InnerClasses
			{
				get
				{
					throw new InvalidOperationException("InnerClasses is only available for finished types");
				}
			}

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
				{
					throw new InvalidOperationException("DeclaringTypeWrapper is only available for finished types");
				}
			}

			internal override Modifiers ReflectiveModifiers
			{
				get
				{
					Modifiers mods;
					ClassFile.InnerClass[] innerclasses = classFile.InnerClasses;
					if (innerclasses != null)
					{
						for (int i = 0; i < innerclasses.Length; i++)
						{
							if (innerclasses[i].innerClass != 0)
							{
								if (classFile.GetConstantPoolClass(innerclasses[i].innerClass) == wrapper.Name)
								{
									// the mask comes from RECOGNIZED_INNER_CLASS_MODIFIERS in src/hotspot/share/vm/classfile/classFileParser.cpp
									// (minus ACC_SUPER)
									mods = innerclasses[i].accessFlags & (Modifiers)0x761F;
									if (classFile.IsInterface)
									{
										mods |= Modifiers.Abstract;
									}
									return mods;
								}
							}
						}
					}
					// the mask comes from JVM_RECOGNIZED_CLASS_MODIFIERS in src/hotspot/share/vm/prims/jvm.h
					// (minus ACC_SUPER)
					mods = classFile.Modifiers & (Modifiers)0x7611;
					if (classFile.IsInterface)
					{
						mods |= Modifiers.Abstract;
					}
					return mods;
				}
			}

			// this finds all methods that the specified name/sig is going to be overriding
			private MethodWrapper[] FindBaseMethods(ClassFile.Method m, out bool explicitOverride)
			{
				Debug.Assert(!classFile.IsInterface);
				Debug.Assert(m.Name != "<init>");

				// starting with Java 7 the algorithm changed
				return classFile.MajorVersion >= 51
					? FindBaseMethods7(m.Name, m.Signature, m.IsFinal && !m.IsPublic && !m.IsProtected, out explicitOverride)
					: FindBaseMethodsLegacy(m.Name, m.Signature, out explicitOverride);
			}

			private MethodWrapper[] FindBaseMethods7(string name, string sig, bool packageFinal, out bool explicitOverride)
			{
				// NOTE this implements the (completely broken) OpenJDK 7 b147 HotSpot behavior,
				// not the algorithm specified in section 5.4.5 of the JavaSE7 JVM spec
				// see http://weblog.ikvm.net/PermaLink.aspx?guid=bde44d8b-7ba9-4e0e-b3a6-b735627118ff and subsequent posts
				// UPDATE as of JDK 7u65 and JDK 8u11, the algorithm changed again to handle package private methods differently
				// this code has not been updated to reflect these changes (we're still at JDK 8 GA level)
				explicitOverride = false;
				MethodWrapper topPublicOrProtectedMethod = null;
				TypeWrapper tw = wrapper.BaseTypeWrapper;
				while (tw != null)
				{
					MethodWrapper baseMethod = tw.GetMethodWrapper(name, sig, true);
					if (baseMethod == null)
					{
						break;
					}
					else if (baseMethod.IsAccessStub)
					{
						// ignore
					}
					else if (!baseMethod.IsStatic && (baseMethod.IsPublic || baseMethod.IsProtected))
					{
						topPublicOrProtectedMethod = baseMethod;
					}
					tw = baseMethod.DeclaringType.BaseTypeWrapper;
				}
				tw = wrapper.BaseTypeWrapper; 
				while (tw != null)
				{
					MethodWrapper baseMethod = tw.GetMethodWrapper(name, sig, true);
					if (baseMethod == null)
					{
						break;
					}
					else if (baseMethod.IsAccessStub)
					{
						// ignore
					}
					else if (baseMethod.IsPrivate)
					{
						// skip
					}
					else if (baseMethod.IsFinal && (baseMethod.IsPublic || baseMethod.IsProtected || IsAccessibleInternal(baseMethod) || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)))
					{
						throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + baseMethod.DeclaringType.Name + " is overridden in " + wrapper.Name);
					}
					else if (baseMethod.IsStatic)
					{
						// skip
					}
					else if (topPublicOrProtectedMethod == null && !baseMethod.IsPublic && !baseMethod.IsProtected && !IsAccessibleInternal(baseMethod) && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
					{
						// this is a package private method that we're not overriding (unless its vtable stream interleaves ours, which is a case we handle below)
						explicitOverride = true;
					}
					else if (topPublicOrProtectedMethod != null && baseMethod.IsFinal && !baseMethod.IsPublic && !baseMethod.IsProtected && !IsAccessibleInternal(baseMethod) && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
					{
						// this is package private final method that we would override had it not been final, but which is ignored by HotSpot (instead of throwing a VerifyError)
						explicitOverride = true;
					}
					else if (topPublicOrProtectedMethod == null)
					{
						if (explicitOverride)
						{
							List<MethodWrapper> list = new List<MethodWrapper>();
							list.Add(baseMethod);
							// we might still have to override package methods from another package if the vtable streams are interleaved with ours
							tw = wrapper.BaseTypeWrapper;
							while (tw != null)
							{
								MethodWrapper baseMethod2 = tw.GetMethodWrapper(name, sig, true);
								if (baseMethod2 == null || baseMethod2 == baseMethod)
								{
									break;
								}
								MethodWrapper baseMethod3 = GetPackageBaseMethod(baseMethod.DeclaringType.BaseTypeWrapper, name, sig, baseMethod2.DeclaringType);
								if (baseMethod3 != null)
								{
									if (baseMethod2.IsFinal)
									{
										baseMethod2 = baseMethod3;
									}
									bool found = false;
									foreach (MethodWrapper mw in list)
									{
										if (mw.DeclaringType.IsPackageAccessibleFrom(baseMethod2.DeclaringType))
										{
											// we should only add each package once
											found = true;
											break;
										}
									}
									if (!found)
									{
										list.Add(baseMethod2);
									}
								}
								tw = baseMethod2.DeclaringType.BaseTypeWrapper;
							}
							return list.ToArray();
						}
						else
						{
							return new MethodWrapper[] { baseMethod };
						}
					}
					else
					{
						if (packageFinal)
						{
							// when a package final method overrides a public or protected method, HotSpot does not mark that vtable slot as final,
							// so we need an explicit override to force the MethodAttributes.NewSlot flag, otherwise the CLR won't allow us
							// to override the original method in subsequent derived types
							explicitOverride = true;
						}

						int majorVersion = 0;
						if (!baseMethod.IsPublic && !baseMethod.IsProtected &&
							((TryGetClassFileVersion(baseMethod.DeclaringType, ref majorVersion) && majorVersion < 51)
							// if TryGetClassFileVersion fails, we know that it is safe to call GetMethod() so we look at the actual method attributes here,
							// because access widing ensures that if the method had overridden the top level method it would also be public or protected
							|| (majorVersion == 0 && (LinkAndGetMethod(baseMethod).Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Assembly)))
						{
							// the method we're overriding is not public or protected, but there is a public or protected top level method,
							// this means that baseMethod is part of a class with a major version < 51, so we have to explicitly override the top level method as well
							// (we don't need to look for another package method to override, because by necessity baseMethod is already in our package)
							return new MethodWrapper[] { baseMethod, topPublicOrProtectedMethod };
						}
						else if (!topPublicOrProtectedMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
						{
							// check if there is another method (in the same package) that we should override
							tw = topPublicOrProtectedMethod.DeclaringType.BaseTypeWrapper;
							while (tw != null)
							{
								MethodWrapper baseMethod2 = tw.GetMethodWrapper(name, sig, true);
								if (baseMethod2 == null)
								{
									break;
								}
								if (baseMethod2.IsAccessStub)
								{
									// ignore
								}
								else if (baseMethod2.DeclaringType.IsPackageAccessibleFrom(wrapper) && !baseMethod2.IsPrivate)
								{
									if (baseMethod2.IsFinal)
									{
										throw new VerifyError("final method " + baseMethod2.Name + baseMethod2.Signature + " in " + baseMethod2.DeclaringType.Name + " is overridden in " + wrapper.Name);
									}
									if (!baseMethod2.IsStatic)
									{
										if (baseMethod2.IsPublic || baseMethod2.IsProtected)
										{
											break;
										}
										return new MethodWrapper[] { baseMethod, baseMethod2 };
									}
								}
								tw = baseMethod2.DeclaringType.BaseTypeWrapper;
							}
						}
						return new MethodWrapper[] { baseMethod };
					}
					tw = baseMethod.DeclaringType.BaseTypeWrapper;
				}
				return null;
			}

			private bool IsAccessibleInternal(MethodWrapper mw)
			{
				return mw.IsInternal && mw.DeclaringType.InternalsVisibleTo(wrapper);
			}

			private static MethodBase LinkAndGetMethod(MethodWrapper mw)
			{
				mw.Link();
				return mw.GetMethod();
			}

			private static bool TryGetClassFileVersion(TypeWrapper tw, ref int majorVersion)
			{
				DynamicTypeWrapper dtw = tw as DynamicTypeWrapper;
				if (dtw != null)
				{
					JavaTypeImpl impl = dtw.impl as JavaTypeImpl;
					if (impl != null)
					{
						majorVersion = impl.classFile.MajorVersion;
						return true;
					}
				}
				return false;
			}

			private static MethodWrapper GetPackageBaseMethod(TypeWrapper tw, string name, string sig, TypeWrapper package)
			{
				while (tw != null)
				{
					MethodWrapper mw = tw.GetMethodWrapper(name, sig, true);
					if (mw == null)
					{
						break;
					}
					if (mw.DeclaringType.IsPackageAccessibleFrom(package))
					{
						return mw.IsFinal ? null : mw;
					}
					tw = mw.DeclaringType.BaseTypeWrapper;
				}
				return null;
			}

			private MethodWrapper[] FindBaseMethodsLegacy(string name, string sig, out bool explicitOverride)
			{
				explicitOverride = false;
				TypeWrapper tw = wrapper.BaseTypeWrapper;
				while (tw != null)
				{
					MethodWrapper baseMethod = tw.GetMethodWrapper(name, sig, true);
					if (baseMethod == null)
					{
						return null;
					}
					else if (baseMethod.IsAccessStub)
					{
						// ignore
					}
					// here are the complex rules for determining whether this method overrides the method we found
					// RULE 1: final methods may not be overridden
					// (note that we intentionally not check IsStatic here!)
					else if (baseMethod.IsFinal
						&& !baseMethod.IsPrivate
						&& (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)))
					{
						throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + baseMethod.DeclaringType.Name + " is overridden in " + wrapper.Name);
					}
					// RULE 1a: static methods are ignored (other than the RULE 1 check)
					else if (baseMethod.IsStatic)
					{
					}
					// RULE 2: public & protected methods can be overridden (package methods are handled by RULE 4)
					// (by public, protected & *package* methods [even if they are in a different package])
					else if (baseMethod.IsPublic || baseMethod.IsProtected)
					{
						// if we already encountered a package method, we cannot override the base method of
						// that package method
						if (explicitOverride)
						{
							explicitOverride = false;
							return null;
						}
						if (!baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
						{
							// check if there is another method (in the same package) that we should override
							tw = baseMethod.DeclaringType.BaseTypeWrapper;
							while (tw != null)
							{
								MethodWrapper baseMethod2 = tw.GetMethodWrapper(name, sig, true);
								if (baseMethod2 == null)
								{
									break;
								}
								if (baseMethod2.IsAccessStub)
								{
									// ignore
								}
								else if (baseMethod2.DeclaringType.IsPackageAccessibleFrom(wrapper) && !baseMethod2.IsPrivate)
								{
									if (baseMethod2.IsFinal)
									{
										throw new VerifyError("final method " + baseMethod2.Name + baseMethod2.Signature + " in " + baseMethod2.DeclaringType.Name + " is overridden in " + wrapper.Name);
									}
									if (!baseMethod2.IsStatic)
									{
										if (baseMethod2.IsPublic || baseMethod2.IsProtected)
										{
											break;
										}
										return new MethodWrapper[] { baseMethod, baseMethod2 };
									}
								}
								tw = baseMethod2.DeclaringType.BaseTypeWrapper;
							}
						}
						return new MethodWrapper[] { baseMethod };
					}
					// RULE 3: private and static methods are ignored
					else if (!baseMethod.IsPrivate)
					{
						// RULE 4: package methods can only be overridden in the same package
						if (baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)
							|| (baseMethod.IsInternal && baseMethod.DeclaringType.InternalsVisibleTo(wrapper)))
						{
							return new MethodWrapper[] { baseMethod };
						}
						// since we encountered a method with the same name/signature that we aren't overriding,
						// we need to specify an explicit override
						// NOTE we only do this if baseMethod isn't private, because if it is, Reflection.Emit
						// will complain about the explicit MethodOverride (possibly a bug)
						explicitOverride = true;
					}
					tw = baseMethod.DeclaringType.BaseTypeWrapper;
				}
				return null;
			}

			private static MethodInfo GetBaseFinalizeMethod(TypeWrapper wrapper)
			{
				for (; ; )
				{
					// HACK we get called during method linking (which is probably a bad idea) and
					// it is possible for the base type not to be finished yet, so we look at the
					// private state of the unfinished base types to find the finalize method.
					DynamicTypeWrapper dtw = wrapper as DynamicTypeWrapper;
					if (dtw == null)
					{
						break;
					}
					MethodWrapper mw = dtw.GetMethodWrapper(StringConstants.FINALIZE, StringConstants.SIG_VOID, false);
					if (mw != null)
					{
						mw.Link();
					}
					MethodInfo finalizeImpl = dtw.impl.GetFinalizeMethod();
					if (finalizeImpl != null)
					{
						return finalizeImpl;
					}
					wrapper = wrapper.BaseTypeWrapper;
				}
				if (wrapper == CoreClasses.java.lang.Object.Wrapper || wrapper == CoreClasses.java.lang.Throwable.Wrapper)
				{
					return Types.Object.GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Instance);
				}
				Type type = wrapper.TypeAsBaseType;
				MethodInfo baseFinalize = type.GetMethod("__<Finalize>", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
				if (baseFinalize != null)
				{
					return baseFinalize;
				}
				while (type != null)
				{
					foreach (MethodInfo m in type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
					{
						if (m.Name == "Finalize"
							&& m.ReturnType == Types.Void
							&& m.GetParameters().Length == 0)
						{
							if (m.GetBaseDefinition().DeclaringType == Types.Object)
							{
								return m;
							}
						}
					}
					type = type.BaseType;
				}
				return null;
			}

			private MethodAttributes GetPropertyAccess(MethodWrapper mw)
			{
				string sig = mw.ReturnType.SigName;
				if (sig == "V")
				{
					sig = mw.GetParameters()[0].SigName;
				}
				int access = -1;
				foreach (ClassFile.Field field in classFile.Fields)
				{
					if (field.IsProperty
						&& field.IsStatic == mw.IsStatic
						&& field.Signature == sig
						&& (field.PropertyGetter == mw.Name || field.PropertySetter == mw.Name))
					{
						int nacc;
						if (field.IsPublic)
						{
							nacc = 3;
						}
						else if (field.IsProtected)
						{
							nacc = 2;
						}
						else if (field.IsPrivate)
						{
							nacc = 0;
						}
						else
						{
							nacc = 1;
						}
						if (nacc > access)
						{
							access = nacc;
						}
					}
				}
				switch (access)
				{
					case 0:
						return MethodAttributes.Private;
					case 1:
						return MethodAttributes.Assembly;
					case 2:
						return MethodAttributes.FamORAssem;
					case 3:
						return MethodAttributes.Public;
					default:
						throw new InvalidOperationException();
				}
			}

			internal override MethodBase LinkMethod(MethodWrapper mw)
			{
				Debug.Assert(mw != null);
				if (mw is DelegateConstructorMethodWrapper)
				{
					((DelegateConstructorMethodWrapper)mw).DoLink(typeBuilder);
					return null;
				}
				if (mw is DelegateInvokeStubMethodWrapper)
				{
					return ((DelegateInvokeStubMethodWrapper)mw).DoLink(typeBuilder);
				}
				if (mw.IsClassInitializer && mw.IsNoOp && (!wrapper.IsSerializable || HasSerialVersionUID))
				{
					// we don't need to emit the <clinit>, because it is empty and we're not serializable or have an explicit serialVersionUID
					// (because we cannot affect serialVersionUID computation (which is the only way the presence of a <clinit> can surface)
					// we cannot do this optimization if the class is serializable but doesn't have a serialVersionUID)
					return null;
				}
				int index = GetMethodIndex(mw);
				if (baseMethods[index] != null)
				{
					foreach (MethodWrapper baseMethod in baseMethods[index])
					{
						baseMethod.Link();
						CheckLoaderConstraints(mw, baseMethod);
					}
				}
				Debug.Assert(mw.GetMethod() == null);
				methods[index].AssertLinked();
				Profiler.Enter("JavaTypeImpl.GenerateMethod");
				try
				{
					if (index >= classFile.Methods.Length)
					{
						if (methods[index].IsMirandaMethod)
						{
							// We're a Miranda method or we're an inherited default interface method
							Debug.Assert(baseMethods[index].Length == 1 && baseMethods[index][0].DeclaringType.IsInterface);
							MirandaMethodWrapper mmw = (MirandaMethodWrapper)methods[index];
							MethodAttributes attr = MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.CheckAccessOnOverride;
							MethodWrapper baseMiranda = null;
							bool baseMirandaOverrideStub = false;
							if (wrapper.BaseTypeWrapper == null || (baseMiranda = wrapper.BaseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true)) == null || !baseMiranda.IsMirandaMethod)
							{
								// we're not overriding a miranda method in a base class, so can we set the newslot flag
								attr |= MethodAttributes.NewSlot;
							}
							else
							{
								baseMiranda.Link();
								if (CheckRequireOverrideStub(methods[index], baseMiranda))
								{
									baseMirandaOverrideStub = true;
									attr |= MethodAttributes.NewSlot;
								}
							}
							if (wrapper.IsInterface || (wrapper.IsAbstract && mmw.BaseMethod.IsAbstract && mmw.Error == null))
							{
								attr |= MethodAttributes.Abstract;
							}
							MethodBuilder mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper, typeBuilder, methods[index].Name, attr);
							AttributeHelper.HideFromReflection(mb);
							if (baseMirandaOverrideStub)
							{
								wrapper.GenerateOverrideStub(typeBuilder, baseMiranda, mb, methods[index]);
							}
							if ((!wrapper.IsAbstract && mmw.BaseMethod.IsAbstract) || (!wrapper.IsInterface && mmw.Error != null))
							{
								string message = mmw.Error ?? (wrapper.Name + "." + methods[index].Name + methods[index].Signature);
								CodeEmitter ilgen = CodeEmitter.Create(mb);
								ilgen.EmitThrow(mmw.IsConflictError ? "java.lang.IncompatibleClassChangeError" : "java.lang.AbstractMethodError", message);
								ilgen.DoEmit();
								wrapper.EmitLevel4Warning(mmw.IsConflictError ? HardError.IncompatibleClassChangeError : HardError.AbstractMethodError, message);
							}
#if STATIC_COMPILER
							if (wrapper.IsInterface && !mmw.IsAbstract)
							{
								// even though we're not visible to reflection., we need to record the fact that we have a default implementation
								AttributeHelper.SetModifiers(mb, mmw.Modifiers, false);
							}
#endif
							return mb;
						}
						else
						{
							throw new InvalidOperationException();
						}
					}
					ClassFile.Method m = classFile.Methods[index];
					MethodBuilder method;
					bool setModifiers = false;
					if (methods[index].HasCallerID && (m.Modifiers & Modifiers.VarArgs) != 0)
					{
						// the implicit callerID parameter was added at the end so that means we shouldn't use ParamArrayAttribute,
						// so we need to explicitly record that the method is varargs
						setModifiers = true;
					}
					if (m.IsConstructor)
					{
						method = GenerateConstructor(methods[index]);
						// strictfp is the only modifier that a constructor can have
						if (m.IsStrictfp)
						{
							setModifiers = true;
						}
					}
					else if (m.IsClassInitializer)
					{
						method = ReflectUtil.DefineTypeInitializer(typeBuilder, wrapper.classLoader);
					}
					else
					{
						method = GenerateMethod(index, m, ref setModifiers);
					}
					string[] exceptions = m.ExceptionsAttribute;
					methods[index].SetDeclaredExceptions(exceptions);
#if STATIC_COMPILER
					AttributeHelper.SetThrowsAttribute(method, exceptions);
					if (setModifiers || m.IsInternal || (m.Modifiers & (Modifiers.Synthetic | Modifiers.Bridge)) != 0)
					{
						AttributeHelper.SetModifiers(method, m.Modifiers, m.IsInternal);
					}
					if ((m.Modifiers & (Modifiers.Synthetic | Modifiers.Bridge)) != 0
						&& (m.IsPublic || m.IsProtected)
						&& wrapper.IsPublic
						&& !IsAccessBridge(classFile, m))
					{
						AttributeHelper.SetEditorBrowsableNever(method);
						// TODO on WHIDBEY apply CompilerGeneratedAttribute
					}
					if (m.DeprecatedAttribute && !Annotation.HasObsoleteAttribute(m.Annotations))
					{
						AttributeHelper.SetDeprecatedAttribute(method);
					}
					if (m.GenericSignature != null)
					{
						AttributeHelper.SetSignatureAttribute(method, m.GenericSignature);
					}
					if (wrapper.GetClassLoader().NoParameterReflection)
					{
						// ignore MethodParameters (except to extract parameter names)
					}
					else if (m.MalformedMethodParameters)
					{
						AttributeHelper.SetMethodParametersAttribute(method, null);
					}
					else if (m.MethodParameters != null)
					{
						Modifiers[] modifiers = new Modifiers[m.MethodParameters.Length];
						for (int i = 0; i < modifiers.Length; i++)
						{
							modifiers[i] = (Modifiers)m.MethodParameters[i].flags;
						}
						AttributeHelper.SetMethodParametersAttribute(method, modifiers);
					}
					if (m.RuntimeVisibleTypeAnnotations != null)
					{
						AttributeHelper.SetRuntimeVisibleTypeAnnotationsAttribute(method, m.RuntimeVisibleTypeAnnotations);
					}
#else // STATIC_COMPILER
					if (setModifiers)
					{
						// shut up the compiler
					}
#endif // STATIC_COMPILER
					return method;
				}
				finally
				{
					Profiler.Leave("JavaTypeImpl.GenerateMethod");
				}
			}

			private bool HasSerialVersionUID
			{
				get
				{
					foreach (FieldWrapper field in fields)
					{
						if (field.IsSerialVersionUID)
						{
							return true;
						}
					}
					return false;
				}
			}

			private MethodBuilder GenerateConstructor(MethodWrapper mw)
			{
				MethodBuilder cb = mw.GetDefineMethodHelper().DefineConstructor(wrapper, typeBuilder, GetMethodAccess(mw) | MethodAttributes.HideBySig);
				cb.SetImplementationFlags(MethodImplAttributes.NoInlining);
				return cb;
			}

			private MethodBuilder GenerateMethod(int index, ClassFile.Method m, ref bool setModifiers)
			{
				MethodAttributes attribs = MethodAttributes.HideBySig;
				if (m.IsNative)
				{
					if (wrapper.IsPInvokeMethod(m))
					{
						// this doesn't appear to be necessary, but we use the flag in Finish to know
						// that we shouldn't emit a method body
						attribs |= MethodAttributes.PinvokeImpl;
					}
					else
					{
						setModifiers = true;
					}
				}
				if (methods[index].IsPropertyAccessor)
				{
					attribs |= GetPropertyAccess(methods[index]);
					attribs |= MethodAttributes.SpecialName;
					setModifiers = true;
				}
				else
				{
					attribs |= GetMethodAccess(methods[index]);
				}
				if (m.IsAbstract || (!m.IsStatic && m.IsPublic && classFile.IsInterface))
				{
					// only if the classfile is abstract, we make the CLR method abstract, otherwise,
					// we have to generate a method that throws an AbstractMethodError (because the JVM
					// allows abstract methods in non-abstract classes)
					if (classFile.IsAbstract)
					{
						if (classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected))
						{
							setModifiers = true;
						}
						else
						{
							if (!m.IsAbstract)
							{
								setModifiers = true;
							}
							attribs |= MethodAttributes.Abstract;
						}
					}
					else
					{
						setModifiers = true;
					}
				}
				if (m.IsFinal)
				{
					if (m.IsVirtual)
					{
						attribs |= MethodAttributes.Final;
					}
					else
					{
						setModifiers = true;
					}
				}
				if (m.IsStatic)
				{
					attribs |= MethodAttributes.Static;
					if (m.IsSynchronized)
					{
						setModifiers = true;
					}
				}
				else if (!m.IsPrivate)
				{
					attribs |= MethodAttributes.Virtual | MethodAttributes.CheckAccessOnOverride;
				}
				string name = UnicodeUtil.EscapeInvalidSurrogates(m.Name);
				if (!ReferenceEquals(name, m.Name))
				{
					// mark as specialname to remind us to unescape the name
					attribs |= MethodAttributes.SpecialName;
				}
#if STATIC_COMPILER
				if ((m.Modifiers & Modifiers.Bridge) != 0 && (m.IsPublic || m.IsProtected) && wrapper.IsPublic)
				{
					string sigbase = m.Signature.Substring(0, m.Signature.LastIndexOf(')') + 1);
					foreach (MethodWrapper mw in methods)
					{
						if (mw.Name == m.Name && mw.Signature.StartsWith(sigbase) && mw.Signature != m.Signature)
						{
							// To prevent bridge methods with covariant return types from confusing
							// other .NET compilers (like C#), we rename the bridge method.
							name = NamePrefix.Bridge + name;
							break;
						}
					}
				}
#endif
				if ((attribs & MethodAttributes.Virtual) != 0 && !classFile.IsInterface)
				{
					if (baseMethods[index] == null || (baseMethods[index].Length == 1 && baseMethods[index][0].DeclaringType.IsInterface))
					{
						// we need to set NewSlot here, to prevent accidentally overriding methods
						// (for example, if a Java class has a method "boolean Equals(object)", we don't want that method
						// to override System.Object.Equals)
						attribs |= MethodAttributes.NewSlot;
					}
					else
					{
						// if we have a method overriding a more accessible method (the JVM allows this), we need to make the
						// method more accessible, because otherwise the CLR will complain that we're reducing access
						bool hasPublicBaseMethod = false;
						foreach (MethodWrapper baseMethodWrapper in baseMethods[index])
						{
							MethodBase baseMethod = baseMethodWrapper.GetMethod();
							if ((baseMethod.IsPublic && !m.IsPublic) ||
								((baseMethod.IsFamily || baseMethod.IsFamilyOrAssembly) && !m.IsPublic && !m.IsProtected) ||
								(!m.IsPublic && !m.IsProtected && !baseMethodWrapper.DeclaringType.IsPackageAccessibleFrom(wrapper)))
							{
								hasPublicBaseMethod |= baseMethod.IsPublic;
								attribs &= ~MethodAttributes.MemberAccessMask;
								attribs |= hasPublicBaseMethod ? MethodAttributes.Public : MethodAttributes.FamORAssem;
								setModifiers = true;
							}
						}
					}
				}
				MethodBuilder mb = null;
#if STATIC_COMPILER
				mb = wrapper.DefineGhostMethod(typeBuilder, name, attribs, methods[index]);
#endif
				if (mb == null)
				{
					bool needFinalize = false;
					bool needDispatch = false;
					MethodInfo baseFinalize = null;
					if (baseMethods[index] != null && ReferenceEquals(m.Name, StringConstants.FINALIZE) && ReferenceEquals(m.Signature, StringConstants.SIG_VOID))
					{
						baseFinalize = GetBaseFinalizeMethod(wrapper.BaseTypeWrapper);
						if (baseMethods[index][0].DeclaringType == CoreClasses.java.lang.Object.Wrapper)
						{
							// This type is the first type in the hierarchy to introduce a finalize method
							// (other than the one in java.lang.Object obviously), so we need to override
							// the real Finalize method and emit a dispatch call to our finalize method.
							needFinalize = true;
							needDispatch = true;
						}
						else if (m.IsFinal)
						{
							// One of our base classes already has a  finalize method, so we already are
							// hooked into the real Finalize, but we need to override it again, to make it
							// final (so that non-Java types cannot override it either).
							needFinalize = true;
							needDispatch = false;
							// If the base class finalize was optimized away, we need a dispatch call after all.
							if (baseFinalize.DeclaringType == Types.Object)
							{
								needDispatch = true;
							}
						}
						else
						{
							// One of our base classes already has a finalize method, but it may have been an empty
							// method so that the hookup to the real Finalize was optimized away, we need to check
							// for that.
							if (baseFinalize.DeclaringType == Types.Object)
							{
								needFinalize = true;
								needDispatch = true;
							}
						}
						if (needFinalize &&
							!m.IsAbstract && !m.IsNative &&
							(!m.IsFinal || classFile.IsFinal) &&
							m.Instructions.Length > 0 &&
							m.Instructions[0].NormalizedOpCode == NormalizedByteCode.__return)
						{
							// we've got an empty finalize method, so we don't need to override the real finalizer
							// (not having a finalizer makes a huge perf difference)
							needFinalize = false;
						}
					}
					bool newslot = baseMethods[index] != null
						&& (methods[index].IsExplicitOverride || baseMethods[index][0].RealName != name || CheckRequireOverrideStub(methods[index], baseMethods[index][0]))
						&& !needFinalize;
					if (newslot)
					{
						attribs |= MethodAttributes.NewSlot;
					}
					if (classFile.IsInterface && !m.IsPublic && !wrapper.IsGhost)
					{
						TypeBuilder tb = typeBuilder;
#if STATIC_COMPILER
						if (wrapper.IsPublic && wrapper.classLoader.WorkaroundInterfacePrivateMethods)
						{
							// FXBUG csc.exe doesn't like non-public methods in interfaces, so we put them in a nested type
							if (privateInterfaceMethods == null)
							{
								privateInterfaceMethods = typeBuilder.DefineNestedType(NestedTypeName.PrivateInterfaceMethods,
									TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit);
							}
							tb = privateInterfaceMethods;
							attribs &= ~MethodAttributes.MemberAccessMask;
							attribs |= MethodAttributes.Assembly;
						}
#endif
						if (m.IsStatic)
						{
							mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper, tb, name, attribs);
						}
						else
						{
							// the CLR doesn't allow (non-virtual) instance methods in interfaces,
							// so we need to turn it into a static method
							mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(),
								tb, NamePrefix.PrivateInterfaceInstanceMethod + name, attribs | MethodAttributes.Static | MethodAttributes.SpecialName,
								typeBuilder, false);
#if STATIC_COMPILER
							AttributeHelper.SetNameSig(mb, m.Name, m.Signature);
#endif
						}
						setModifiers = true;
					}
					else
					{
						mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper, typeBuilder, name, attribs);
					}
					if (baseMethods[index] != null && !needFinalize)
					{
						bool subsequent = false;
						foreach (MethodWrapper baseMethod in baseMethods[index])
						{
							if (CheckRequireOverrideStub(methods[index], baseMethod))
							{
								wrapper.GenerateOverrideStub(typeBuilder, baseMethod, mb, methods[index]);
							}
							else if (subsequent || methods[index].IsExplicitOverride || baseMethod.RealName != name)
							{
								typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethod.GetMethod());
							}
							// the non-primary base methods always need an explicit method override
							subsequent = true;
						}
					}
					// if we're overriding java.lang.Object.finalize we need to emit a stub to override System.Object.Finalize,
					// or if we're subclassing a non-Java class that has a Finalize method, we need a new Finalize override
					if (needFinalize)
					{
						string finalizeName = baseFinalize.Name;
						MethodWrapper mwClash = wrapper.GetMethodWrapper(finalizeName, StringConstants.SIG_VOID, true);
						if (mwClash != null && mwClash.GetMethod() != baseFinalize)
						{
							finalizeName = "__<Finalize>";
						}
						MethodAttributes attr = MethodAttributes.HideBySig | MethodAttributes.Virtual;
						// make sure we don't reduce accessibility
						attr |= baseFinalize.IsPublic ? MethodAttributes.Public : MethodAttributes.Family;
						if (m.IsFinal)
						{
							attr |= MethodAttributes.Final;
						}
						finalizeMethod = typeBuilder.DefineMethod(finalizeName, attr, CallingConventions.Standard, Types.Void, Type.EmptyTypes);
						if (finalizeName != baseFinalize.Name)
						{
							typeBuilder.DefineMethodOverride(finalizeMethod, baseFinalize);
						}
						AttributeHelper.HideFromJava(finalizeMethod);
						CodeEmitter ilgen = CodeEmitter.Create(finalizeMethod);
						ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.SkipFinalizer);
						CodeEmitterLabel skip = ilgen.DefineLabel();
						ilgen.EmitBrtrue(skip);
						if (needDispatch)
						{
							ilgen.BeginExceptionBlock();
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Callvirt, mb);
							ilgen.EmitLeave(skip);
							ilgen.BeginCatchBlock(Types.Object);
							ilgen.EmitLeave(skip);
							ilgen.EndExceptionBlock();
						}
						else
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Call, baseFinalize);
						}
						ilgen.MarkLabel(skip);
						ilgen.Emit(OpCodes.Ret);
						ilgen.DoEmit();
					}
#if STATIC_COMPILER
					if (classFile.Methods[index].AnnotationDefault != null)
					{
						CustomAttributeBuilder cab = new CustomAttributeBuilder(StaticCompiler.GetRuntimeType("IKVM.Attributes.AnnotationDefaultAttribute").GetConstructor(new Type[] { Types.Object }),
							new object[] { AnnotationDefaultAttribute.Escape(classFile.Methods[index].AnnotationDefault) });
						mb.SetCustomAttribute(cab);
					}
#endif // STATIC_COMPILER
				}

				if ((methods[index].Modifiers & (Modifiers.Synchronized | Modifiers.Static)) == Modifiers.Synchronized)
				{
					mb.SetImplementationFlags(mb.GetMethodImplementationFlags() | MethodImplAttributes.Synchronized);
				}

				if (classFile.Methods[index].IsForceInline)
				{
					const MethodImplAttributes AggressiveInlining = (MethodImplAttributes)256;
					mb.SetImplementationFlags(mb.GetMethodImplementationFlags() | AggressiveInlining);
				}

				if (classFile.Methods[index].IsLambdaFormCompiled || classFile.Methods[index].IsLambdaFormHidden)
				{
					HideFromJavaFlags flags = HideFromJavaFlags.None;
					if (classFile.Methods[index].IsLambdaFormCompiled)
					{
						flags |= HideFromJavaFlags.StackWalk;
					}
					if (classFile.Methods[index].IsLambdaFormHidden)
					{
						flags |= HideFromJavaFlags.StackTrace;
					}
					AttributeHelper.HideFromJava(mb, flags);
				}

				if (classFile.IsInterface && methods[index].IsVirtual && !methods[index].IsAbstract)
				{
					if (wrapper.IsGhost)
					{
						DefaultInterfaceMethodWrapper.SetImpl(methods[index], methods[index].GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(),
							typeBuilder, NamePrefix.DefaultMethod + mb.Name, MethodAttributes.Public | MethodAttributes.SpecialName,
							null, false));
					}
					else
					{
						DefaultInterfaceMethodWrapper.SetImpl(methods[index], methods[index].GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(),
							typeBuilder, NamePrefix.DefaultMethod + mb.Name, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName,
							typeBuilder, false));
					}
				}

				return mb;
			}

			private static MethodAttributes GetMethodAccess(MethodWrapper mw)
			{
				switch (mw.Modifiers & Modifiers.AccessMask)
				{
					case Modifiers.Private:
						return MethodAttributes.Private;
					case Modifiers.Protected:
						return MethodAttributes.FamORAssem;
					case Modifiers.Public:
						return MethodAttributes.Public;
					default:
						return MethodAttributes.Assembly;
				}
			}

#if STATIC_COMPILER
			// The classic example of an access bridge is StringBuilder.length(), the JDK 6 compiler
			// generates this to work around a reflection problem (which otherwise wouldn't surface the
			// length() method, because it is defined in the non-public base class AbstractStringBuilder.)
			private static bool IsAccessBridge(ClassFile classFile, ClassFile.Method m)
			{
				// HACK this is a pretty gross hack
				// We look at the method body to figure out if the bridge method calls another method with the exact
				// same name/signature and if that is the case, we assume that it is an access bridge.
				// This code is based on the javac algorithm in addBridgeIfNeeded(...) in com/sun/tools/javac/comp/TransTypes.java.
				if ((m.Modifiers & (Modifiers.Abstract | Modifiers.Native | Modifiers.Public | Modifiers.Bridge)) == (Modifiers.Public | Modifiers.Bridge))
				{
					foreach (ClassFile.Method.Instruction instr in m.Instructions)
					{
						if (instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
						{
							ClassFile.ConstantPoolItemMI cpi = classFile.SafeGetMethodref(instr.Arg1);
							return cpi != null && cpi.Name == m.Name && cpi.Signature == m.Signature;
						}
					}
				}
				return false;
			}
#endif // STATIC_COMPILER

			internal override Type Type
			{
				get
				{
					return typeBuilder;
				}
			}

			internal override string GetGenericSignature()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override string[] GetEnclosingMethod()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override string GetGenericMethodSignature(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override string GetGenericFieldSignature(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[] GetDeclaredAnnotations()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object GetMethodDefaultValue(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[] GetMethodAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[][] GetParameterAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override MethodParametersEntry[] GetMethodParameters(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override object[] GetFieldAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override MethodInfo GetFinalizeMethod()
			{
				return finalizeMethod;
			}

			internal override object[] GetConstantPool()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override byte[] GetRawTypeAnnotations()
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override byte[] GetMethodRawTypeAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override byte[] GetFieldRawTypeAnnotations(int index)
			{
				Debug.Fail("Unreachable code");
				return null;
			}

			internal override TypeWrapper Host
			{
				get { return host; }
			}
		}

		private sealed class Metadata
		{
			private readonly string[][] genericMetaData;
			private readonly object[][] annotations;
			private readonly MethodParametersEntry[][] methodParameters;
			private readonly byte[][][] runtimeVisibleTypeAnnotations;
			private readonly object[] constantPool;

			private Metadata(string[][] genericMetaData, object[][] annotations, MethodParametersEntry[][] methodParameters,
				byte[][][] runtimeVisibleTypeAnnotations, object[] constantPool)
			{
				this.genericMetaData = genericMetaData;
				this.annotations = annotations;
				this.methodParameters = methodParameters;
				this.runtimeVisibleTypeAnnotations = runtimeVisibleTypeAnnotations;
				this.constantPool = constantPool;
			}

			internal static Metadata Create(ClassFile classFile)
			{
				if (classFile.MajorVersion < 49)
				{
					return null;
				}
				string[][] genericMetaData = null;
				object[][] annotations = null;
				MethodParametersEntry[][] methodParameters = null;
				byte[][][] runtimeVisibleTypeAnnotations = null;
				for (int i = 0; i < classFile.Methods.Length; i++)
				{
					if (classFile.Methods[i].GenericSignature != null)
					{
						if (genericMetaData == null)
						{
							genericMetaData = new string[4][];
						}
						if (genericMetaData[0] == null)
						{
							genericMetaData[0] = new string[classFile.Methods.Length];
						}
						genericMetaData[0][i] = classFile.Methods[i].GenericSignature;
					}
					if (classFile.Methods[i].Annotations != null)
					{
						if (annotations == null)
						{
							annotations = new object[5][];
						}
						if (annotations[1] == null)
						{
							annotations[1] = new object[classFile.Methods.Length];
						}
						annotations[1][i] = classFile.Methods[i].Annotations;
					}
					if (classFile.Methods[i].ParameterAnnotations != null)
					{
						if (annotations == null)
						{
							annotations = new object[5][];
						}
						if (annotations[2] == null)
						{
							annotations[2] = new object[classFile.Methods.Length];
						}
						annotations[2][i] = classFile.Methods[i].ParameterAnnotations;
					}
					if (classFile.Methods[i].AnnotationDefault != null)
					{
						if (annotations == null)
						{
							annotations = new object[5][];
						}
						if (annotations[3] == null)
						{
							annotations[3] = new object[classFile.Methods.Length];
						}
						annotations[3][i] = classFile.Methods[i].AnnotationDefault;
					}
					if (classFile.Methods[i].MethodParameters != null)
					{
						if (methodParameters == null)
						{
							methodParameters = new MethodParametersEntry[classFile.Methods.Length][];
						}
						methodParameters[i] = classFile.Methods[i].MethodParameters;
					}
					if (classFile.Methods[i].RuntimeVisibleTypeAnnotations != null)
					{
						if (runtimeVisibleTypeAnnotations == null)
						{
							runtimeVisibleTypeAnnotations = new byte[3][][];
						}
						if (runtimeVisibleTypeAnnotations[1] == null)
						{
							runtimeVisibleTypeAnnotations[1] = new byte[classFile.Methods.Length][];
						}
						runtimeVisibleTypeAnnotations[1][i] = classFile.Methods[i].RuntimeVisibleTypeAnnotations;
					}
				}
				for (int i = 0; i < classFile.Fields.Length; i++)
				{
					if (classFile.Fields[i].GenericSignature != null)
					{
						if (genericMetaData == null)
						{
							genericMetaData = new string[4][];
						}
						if (genericMetaData[1] == null)
						{
							genericMetaData[1] = new string[classFile.Fields.Length];
						}
						genericMetaData[1][i] = classFile.Fields[i].GenericSignature;
					}
					if (classFile.Fields[i].Annotations != null)
					{
						if (annotations == null)
						{
							annotations = new object[5][];
						}
						if (annotations[4] == null)
						{
							annotations[4] = new object[classFile.Fields.Length][];
						}
						annotations[4][i] = classFile.Fields[i].Annotations;
					}
					if (classFile.Fields[i].RuntimeVisibleTypeAnnotations != null)
					{
						if (runtimeVisibleTypeAnnotations == null)
						{
							runtimeVisibleTypeAnnotations = new byte[3][][];
						}
						if (runtimeVisibleTypeAnnotations[2] == null)
						{
							runtimeVisibleTypeAnnotations[2] = new byte[classFile.Fields.Length][];
						}
						runtimeVisibleTypeAnnotations[2][i] = classFile.Fields[i].RuntimeVisibleTypeAnnotations;
					}
				}
				if (classFile.EnclosingMethod != null)
				{
					if (genericMetaData == null)
					{
						genericMetaData = new string[4][];
					}
					genericMetaData[2] = classFile.EnclosingMethod;
				}
				if (classFile.GenericSignature != null)
				{
					if (genericMetaData == null)
					{
						genericMetaData = new string[4][];
					}
					genericMetaData[3] = new string[] { classFile.GenericSignature };
				}
				if (classFile.Annotations != null)
				{
					if (annotations == null)
					{
						annotations = new object[5][];
					}
					annotations[0] = classFile.Annotations;
				}
				if (classFile.RuntimeVisibleTypeAnnotations != null)
				{
					if (runtimeVisibleTypeAnnotations == null)
					{
						runtimeVisibleTypeAnnotations = new byte[3][][];
					}
					runtimeVisibleTypeAnnotations[0] = new byte[1][] { classFile.RuntimeVisibleTypeAnnotations };
				}
				if (genericMetaData != null || annotations != null || methodParameters != null || runtimeVisibleTypeAnnotations != null)
				{
					object[] constantPool = runtimeVisibleTypeAnnotations == null ? null : classFile.GetConstantPool();
					return new Metadata(genericMetaData, annotations, methodParameters, runtimeVisibleTypeAnnotations, constantPool);
				}
				return null;
			}

			internal static string GetGenericSignature(Metadata m)
			{
				if (m != null && m.genericMetaData != null && m.genericMetaData[3] != null)
				{
					return m.genericMetaData[3][0];
				}
				return null;
			}

			internal static string[] GetEnclosingMethod(Metadata m)
			{
				if (m != null && m.genericMetaData != null)
				{
					return m.genericMetaData[2];
				}
				return null;
			}

			internal static string GetGenericMethodSignature(Metadata m, int index)
			{
				if (m != null && m.genericMetaData != null && m.genericMetaData[0] != null)
				{
					return m.genericMetaData[0][index];
				}
				return null;
			}

			internal static string GetGenericFieldSignature(Metadata m, int index)
			{
				if (m != null && m.genericMetaData != null && m.genericMetaData[1] != null)
				{
					return m.genericMetaData[1][index];
				}
				return null;
			}

			internal static object[] GetAnnotations(Metadata m)
			{
				if (m != null && m.annotations != null)
				{
					return m.annotations[0];
				}
				return null;
			}

			internal static object[] GetMethodAnnotations(Metadata m, int index)
			{
				if (m != null && m.annotations != null && m.annotations[1] != null)
				{
					return (object[])m.annotations[1][index];
				}
				return null;
			}

			internal static object[][] GetMethodParameterAnnotations(Metadata m, int index)
			{
				if (m != null && m.annotations != null && m.annotations[2] != null)
				{
					return (object[][])m.annotations[2][index];
				}
				return null;
			}

			internal static MethodParametersEntry[] GetMethodParameters(Metadata m, int index)
			{
				if (m != null && m.methodParameters != null)
				{
					return m.methodParameters[index];
				}
				return null;
			}

			internal static object GetMethodDefaultValue(Metadata m, int index)
			{
				if (m != null && m.annotations != null && m.annotations[3] != null)
				{
					return m.annotations[3][index];
				}
				return null;
			}

			// note that unlike GetGenericFieldSignature, the index is simply the field index 
			internal static object[] GetFieldAnnotations(Metadata m, int index)
			{
				if (m != null && m.annotations != null && m.annotations[4] != null)
				{
					return (object[])m.annotations[4][index];
				}
				return null;
			}

			internal static object[] GetConstantPool(Metadata m)
			{
				return m.constantPool;
			}

			internal static byte[] GetRawTypeAnnotations(Metadata m)
			{
				if (m != null && m.runtimeVisibleTypeAnnotations != null && m.runtimeVisibleTypeAnnotations[0] != null)
				{
					return m.runtimeVisibleTypeAnnotations[0][0];
				}
				return null;
			}

			internal static byte[] GetMethodRawTypeAnnotations(Metadata m, int index)
			{
				if (m != null && m.runtimeVisibleTypeAnnotations != null && m.runtimeVisibleTypeAnnotations[1] != null)
				{
					return m.runtimeVisibleTypeAnnotations[1][index];
				}
				return null;
			}

			internal static byte[] GetFieldRawTypeAnnotations(Metadata m, int index)
			{
				if (m != null && m.runtimeVisibleTypeAnnotations != null && m.runtimeVisibleTypeAnnotations[2] != null)
				{
					return m.runtimeVisibleTypeAnnotations[2][index];
				}
				return null;
			}
		}

		private sealed class FinishedTypeImpl : DynamicImpl
		{
			private readonly Type type;
			private readonly TypeWrapper[] innerclasses;
			private readonly TypeWrapper declaringTypeWrapper;
			private readonly Modifiers reflectiveModifiers;
			private readonly MethodInfo clinitMethod;
			private readonly MethodInfo finalizeMethod;
			private readonly Metadata metadata;
			private readonly TypeWrapper host;

			internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers, Metadata metadata, MethodInfo clinitMethod, MethodInfo finalizeMethod, TypeWrapper host)
			{
				this.type = type;
				this.innerclasses = innerclasses;
				this.declaringTypeWrapper = declaringTypeWrapper;
				this.reflectiveModifiers = reflectiveModifiers;
				this.clinitMethod = clinitMethod;
				this.finalizeMethod = finalizeMethod;
				this.metadata = metadata;
				this.host = host;
			}

			internal override TypeWrapper[] InnerClasses
			{
				get
				{
					// TODO compute the innerclasses lazily (and fix JavaTypeImpl to not always compute them)
					return innerclasses;
				}
			}

			internal override TypeWrapper DeclaringTypeWrapper
			{
				get
				{
					// TODO compute lazily (and fix JavaTypeImpl to not always compute it)
					return declaringTypeWrapper;
				}
			}

			internal override Modifiers ReflectiveModifiers
			{
				get
				{
					return reflectiveModifiers;
				}
			}

			internal override Type Type
			{
				get
				{
					return type;
				}
			}

			internal override void EmitRunClassConstructor(CodeEmitter ilgen)
			{
				if (clinitMethod != null)
				{
					ilgen.Emit(OpCodes.Call, clinitMethod);
				}
			}

			internal override DynamicImpl Finish()
			{
				return this;
			}

			internal override MethodBase LinkMethod(MethodWrapper mw)
			{
				// we should never be called, because all methods on a finished type are already linked
				Debug.Assert(false);
				return mw.GetMethod();
			}

			internal override FieldInfo LinkField(FieldWrapper fw)
			{
				// we should never be called, because all fields on a finished type are already linked
				Debug.Assert(false);
				return fw.GetField();
			}

			internal override string GetGenericSignature()
			{
				return Metadata.GetGenericSignature(metadata);
			}

			internal override string[] GetEnclosingMethod()
			{
				return Metadata.GetEnclosingMethod(metadata);
			}

			internal override string GetGenericMethodSignature(int index)
			{
				return Metadata.GetGenericMethodSignature(metadata, index);
			}

			internal override string GetGenericFieldSignature(int index)
			{
				return Metadata.GetGenericFieldSignature(metadata, index);
			}

			internal override object[] GetDeclaredAnnotations()
			{
				return Metadata.GetAnnotations(metadata);
			}

			internal override object GetMethodDefaultValue(int index)
			{
				return Metadata.GetMethodDefaultValue(metadata, index);
			}

			internal override object[] GetMethodAnnotations(int index)
			{
				return Metadata.GetMethodAnnotations(metadata, index);
			}

			internal override object[][] GetParameterAnnotations(int index)
			{
				return Metadata.GetMethodParameterAnnotations(metadata, index);
			}

			internal override MethodParametersEntry[] GetMethodParameters(int index)
			{
				return Metadata.GetMethodParameters(metadata, index);
			}

			internal override object[] GetFieldAnnotations(int index)
			{
				return Metadata.GetFieldAnnotations(metadata, index);
			}

			internal override MethodInfo GetFinalizeMethod()
			{
				return finalizeMethod;
			}

			internal override object[] GetConstantPool()
			{
				return Metadata.GetConstantPool(metadata);
			}

			internal override byte[] GetRawTypeAnnotations()
			{
				return Metadata.GetRawTypeAnnotations(metadata);
			}

			internal override byte[] GetMethodRawTypeAnnotations(int index)
			{
				return Metadata.GetMethodRawTypeAnnotations(metadata, index);
			}

			internal override byte[] GetFieldRawTypeAnnotations(int index)
			{
				return Metadata.GetFieldRawTypeAnnotations(metadata, index);
			}

			internal override TypeWrapper Host
			{
				get { return host; }
			}
		}

		internal sealed class FinishContext
		{
			private readonly TypeWrapper host;
			private readonly ClassFile classFile;
			private readonly DynamicOrAotTypeWrapper wrapper;
			private readonly TypeBuilder typeBuilder;
			private List<TypeBuilder> nestedTypeBuilders;
			private MethodInfo callerIDMethod;
			private List<Item> items;
			private Dictionary<FieldWrapper, MethodBuilder> arfuMap;
			private Dictionary<MethodKey, MethodInfo> invokespecialstubcache;
			private Dictionary<string, MethodInfo> dynamicClassLiteral;
#if STATIC_COMPILER
			private TypeBuilder interfaceHelperMethodsTypeBuilder;
#else
			private List<object> liveObjects;
#endif

			private struct Item
			{
				internal int key;
				internal object value;
			}

			internal FinishContext(TypeWrapper host, ClassFile classFile, DynamicOrAotTypeWrapper wrapper, TypeBuilder typeBuilder)
			{
				this.host = host;
				this.classFile = classFile;
				this.wrapper = wrapper;
				this.typeBuilder = typeBuilder;
			}

			internal DynamicTypeWrapper TypeWrapper
			{
				get { return wrapper; }
			}

			internal T GetValue<T>(int key)
				where T : class, new()
			{
				if (items == null)
				{
					items = new List<Item>();
				}
				for (int i = 0; i < items.Count; i++)
				{
					T value;
					if (items[i].key == key && (value = items[i].value as T) != null)
					{
						return value;
					}
				}
				Item item;
				item.key = key;
				T val = new T();
				item.value = val;
				items.Add(item);
				return val;
			}

			internal void EmitDynamicClassLiteral(CodeEmitter ilgen, TypeWrapper tw, bool dynamicCallerID)
			{
				Debug.Assert(tw.IsUnloadable);
				if (dynamicClassLiteral == null)
				{
					dynamicClassLiteral = new Dictionary<string, MethodInfo>();
				}
				string cacheKey = tw.Name;
				if (dynamicCallerID)
				{
					cacheKey += ";dynamic";
				}
				MethodInfo method;
				if (!dynamicClassLiteral.TryGetValue(cacheKey, out method))
				{
					FieldBuilder fb = typeBuilder.DefineField("__<>class", CoreClasses.java.lang.Class.Wrapper.TypeAsSignatureType, FieldAttributes.PrivateScope | FieldAttributes.Static);
					MethodBuilder mb = DefineHelperMethod("__<>class", CoreClasses.java.lang.Class.Wrapper.TypeAsSignatureType, Type.EmptyTypes);
					CodeEmitter ilgen2 = CodeEmitter.Create(mb);
					ilgen2.Emit(OpCodes.Ldsfld, fb);
					CodeEmitterLabel label = ilgen2.DefineLabel();
					ilgen2.EmitBrtrue(label);
					ilgen2.Emit(OpCodes.Ldstr, tw.Name);
					EmitCallerID(ilgen2, dynamicCallerID);
					ilgen2.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicClassLiteral);
					ilgen2.Emit(OpCodes.Stsfld, fb);
					ilgen2.MarkLabel(label);
					ilgen2.Emit(OpCodes.Ldsfld, fb);
					ilgen2.Emit(OpCodes.Ret);
					ilgen2.DoEmit();
					method = mb;
					dynamicClassLiteral.Add(cacheKey, method);
				}
				ilgen.Emit(OpCodes.Call, method);
			}

			internal void EmitHostCallerID(CodeEmitter ilgen)
			{
#if STATIC_COMPILER || FIRST_PASS
				throw new InvalidOperationException();
#else
				EmitLiveObjectLoad(ilgen, DynamicCallerIDProvider.CreateCallerID(host));
				CoreClasses.ikvm.@@internal.CallerID.Wrapper.EmitCheckcast(ilgen);
#endif
			}

			internal void EmitCallerID(CodeEmitter ilgen, bool dynamic)
			{
#if !FIRST_PASS && !STATIC_COMPILER
				if (dynamic)
				{
					EmitLiveObjectLoad(ilgen, DynamicCallerIDProvider.Instance);
					ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicCallerID);
					return;
				}
#endif
				if (callerIDMethod == null)
				{
					CreateGetCallerID();
				}
				ilgen.Emit(OpCodes.Call, callerIDMethod);
			}

			private void CreateGetCallerID()
			{
				TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
				FieldBuilder callerIDField = typeBuilder.DefineField("__<callerID>", tw.TypeAsSignatureType, FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.SpecialName);
				MethodBuilder mb = DefineHelperMethod("__<GetCallerID>", tw.TypeAsSignatureType, Type.EmptyTypes);
				callerIDMethod = mb;
				CodeEmitter ilgen = CodeEmitter.Create(mb);
				ilgen.Emit(OpCodes.Ldsfld, callerIDField);
				CodeEmitterLabel done = ilgen.DefineLabel();
				ilgen.EmitBrtrue(done);
				EmitCallerIDInitialization(ilgen, callerIDField);
				ilgen.MarkLabel(done);
				ilgen.Emit(OpCodes.Ldsfld, callerIDField);
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
			}

			private void RegisterNestedTypeBuilder(TypeBuilder tb)
			{
				if (nestedTypeBuilders == null)
				{
					nestedTypeBuilders = new List<TypeBuilder>();
				}
				nestedTypeBuilders.Add(tb);
			}

			internal Type FinishImpl()
			{
				MethodWrapper[] methods = wrapper.GetMethods();
				FieldWrapper[] fields = wrapper.GetFields();
#if STATIC_COMPILER
				wrapper.FinishGhost(typeBuilder, methods);
#endif // STATIC_COMPILER

				if (!classFile.IsInterface)
				{
					// set the base type (this needs to be done before we emit any methods, because in the static compiler
					// GetBaseTypeForDefineType() has the side effect of inserting the __WorkaroundBaseClass__ when necessary)
					typeBuilder.SetParent(wrapper.GetBaseTypeForDefineType());
				}

				// if we're not abstract make sure we don't inherit any abstract methods
				if (!wrapper.IsAbstract)
				{
					TypeWrapper parent = wrapper.BaseTypeWrapper;
					// if parent is not abstract, the .NET implementation will never have abstract methods (only
					// stubs that throw AbstractMethodError)
					// NOTE interfaces are supposed to be abstract, but the VM doesn't enforce this, so
					// we have to check for a null parent (interfaces have no parent).
					while (parent != null && parent.IsAbstract)
					{
						foreach (MethodWrapper mw in parent.GetMethods())
						{
							MethodInfo mi = mw.GetMethod() as MethodInfo;
							if (mi != null && mi.IsAbstract && !mi.DeclaringType.IsInterface)
							{
								bool needStub = false;
								bool needRename = false;
								if (mw.IsPublic || mw.IsProtected)
								{
									MethodWrapper fmw = wrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
									while (fmw != mw && (fmw.IsStatic || fmw.IsPrivate))
									{
										needRename = true;
										fmw = fmw.DeclaringType.BaseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
									}
									if (fmw == mw && fmw.DeclaringType != wrapper)
									{
										needStub = true;
									}
								}
								else
								{
									MethodWrapper fmw = wrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
									while (fmw != mw && (fmw.IsStatic || fmw.IsPrivate || !(mw.DeclaringType.IsPackageAccessibleFrom(fmw.DeclaringType) || (mw.IsInternal && mw.DeclaringType.InternalsVisibleTo(fmw.DeclaringType)))))
									{
										needRename = true;
										fmw = fmw.DeclaringType.BaseTypeWrapper.GetMethodWrapper(mw.Name, mw.Signature, true);
									}
									if (fmw == mw && fmw.DeclaringType != wrapper)
									{
										needStub = true;
									}
								}
								if (needStub)
								{
									// NOTE in Sun's JRE 1.4.1 this method cannot be overridden by subclasses,
									// but I think this is a bug, so we'll support it anyway.
									string name = mi.Name;
									MethodAttributes attr = mi.Attributes & ~(MethodAttributes.Abstract | MethodAttributes.NewSlot);
									if (needRename)
									{
										name = "__<>" + name + "/" + mi.DeclaringType.FullName;
										attr = MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot;
									}
									MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(wrapper, typeBuilder, name, attr);
									if (needRename)
									{
										typeBuilder.DefineMethodOverride(mb, mi);
									}
									AttributeHelper.HideFromJava(mb);
									CodeEmitter ilgen = CodeEmitter.Create(mb);
									ilgen.EmitThrow("java.lang.AbstractMethodError", mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
									ilgen.DoEmit();
									wrapper.EmitLevel4Warning(HardError.AbstractMethodError, mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
								}
							}
						}
						parent = parent.BaseTypeWrapper;
					}
				}
#if STATIC_COMPILER
				TypeBuilder tbDefaultMethods = null;
#endif
				bool basehasclinit = wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasStaticInitializer;
				int clinitIndex = -1;
				bool hasConstructor = false;
				for (int i = 0; i < classFile.Methods.Length; i++)
				{
					ClassFile.Method m = classFile.Methods[i];
					MethodBuilder mb = (MethodBuilder)methods[i].GetMethod();
					if (mb == null)
					{
						// method doesn't really exist (e.g. delegate constructor or <clinit> that is optimized away)
						if (m.IsConstructor)
						{
							hasConstructor = true;
						}
					}
					else if (m.IsClassInitializer)
					{
						// we handle the <clinit> after we've done the other methods,
						// to make it easier to inject code needed by the other methods
						clinitIndex = i;
						continue;
					}
					else if (m.IsConstructor)
					{
						hasConstructor = true;
						CodeEmitter ilGenerator = CodeEmitter.Create(mb);
						CompileConstructorBody(this, ilGenerator, i);
					}
					else
					{
#if STATIC_COMPILER
						if (methods[i].GetParameters().Length > MethodHandleUtil.MaxArity && methods[i].RequiresNonVirtualDispatcher && wrapper.GetClassLoader().EmitNoRefEmitHelpers)
						{
							wrapper.GetClassLoader().GetTypeWrapperFactory().DefineDelegate(methods[i].GetParameters().Length, methods[i].ReturnType == PrimitiveTypeWrapper.VOID);
						}
#endif
						if (m.IsAbstract)
						{
							bool stub = false;
							if (!classFile.IsAbstract)
							{
								// NOTE in the JVM it is apparently legal for a non-abstract class to have abstract methods, but
								// the CLR doens't allow this, so we have to emit a method that throws an AbstractMethodError
								stub = true;
								wrapper.EmitLevel4Warning(HardError.AbstractMethodError, classFile.Name + "." + m.Name + m.Signature);
							}
							else if (classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected))
							{
								// We have an abstract package accessible method in our public class. To allow a class in another
								// assembly to subclass this class, we must fake the abstractness of this method.
								stub = true;
							}
							if (stub)
							{
								CodeEmitter ilGenerator = CodeEmitter.Create(mb);
								TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
								ilGenerator.EmitThrow("java.lang.AbstractMethodError", classFile.Name + "." + m.Name + m.Signature);
								ilGenerator.DoEmit();
							}
						}
						else if (m.IsNative)
						{
							if ((mb.Attributes & MethodAttributes.PinvokeImpl) != 0)
							{
								continue;
							}
							if (wrapper.IsDelegate)
							{
								mb.SetImplementationFlags(mb.GetMethodImplementationFlags() | MethodImplAttributes.Runtime);
								continue;
							}
							Profiler.Enter("JavaTypeImpl.Finish.Native");
							try
							{
								CodeEmitter ilGenerator = CodeEmitter.Create(mb);
								TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
#if STATIC_COMPILER
								// do we have an implementation in map.xml?
								if (wrapper.EmitMapXmlMethodPrologueAndOrBody(ilGenerator, classFile, m))
								{
									ilGenerator.DoEmit();
									continue;
								}
								if (m.InterlockedCompareAndSetField != null && EmitInterlockedCompareAndSet(methods[i], m.InterlockedCompareAndSetField, ilGenerator))
								{
									ilGenerator.DoEmit();
									continue;
								}
#endif
								// see if there exists a "managed JNI" class for this type
								Type nativeCodeType = null;
#if STATIC_COMPILER
								nativeCodeType = StaticCompiler.GetType(wrapper.GetClassLoader(), "IKVM.NativeCode." + classFile.Name.Replace('$', '+'));
								if (nativeCodeType == null)
								{
									// simple JNI like class name mangling
									nativeCodeType = StaticCompiler.GetType(wrapper.GetClassLoader(), "Java_" + classFile.Name.Replace('.', '_').Replace("$", "_00024"));
								}
#endif
								MethodInfo nativeMethod = null;
								TypeWrapper[] args = methods[i].GetParameters();
								TypeWrapper[] nargs = args;
								if (nativeCodeType != null)
								{
									if (!m.IsStatic)
									{
										nargs = ArrayUtil.Concat(wrapper, args);
									}
									if (methods[i].HasCallerID)
									{
										nargs = ArrayUtil.Concat(nargs, CoreClasses.ikvm.@@internal.CallerID.Wrapper);
									}
									MethodInfo[] nativeCodeTypeMethods = nativeCodeType.GetMethods(BindingFlags.Static | BindingFlags.Public);
									foreach (MethodInfo method in nativeCodeTypeMethods)
									{
										ParameterInfo[] param = method.GetParameters();
										int paramLength = param.Length;
										while (paramLength != 0 && (param[paramLength - 1].IsIn || param[paramLength - 1].ParameterType.IsByRef))
										{
											paramLength--;
										}
										TypeWrapper[] match = new TypeWrapper[paramLength];
										for (int j = 0; j < paramLength; j++)
										{
											match[j] = ClassLoaderWrapper.GetWrapperFromType(param[j].ParameterType);
										}
										if (m.Name == method.Name && IsCompatibleArgList(nargs, match))
										{
											// TODO instead of taking the first matching method, we should find the best one
											nativeMethod = method;
											break;
										}
									}
								}
								if (nativeMethod != null)
								{
#if STATIC_COMPILER
									for (int j = 0; j < nargs.Length; j++)
									{
										ilGenerator.EmitLdarg(j);
									}
									ParameterInfo[] param = nativeMethod.GetParameters();
									for (int j = nargs.Length; j < param.Length; j++)
									{
										Type paramType = param[j].ParameterType;
										TypeWrapper fieldTypeWrapper = ClassLoaderWrapper.GetWrapperFromType(paramType.IsByRef ? paramType.GetElementType() : paramType);
										FieldWrapper field = wrapper.GetFieldWrapper(param[j].Name, fieldTypeWrapper.SigName);
										if (field == null)
										{
											Console.Error.WriteLine("Error: Native method field binding not found: {0}.{1}{2}", classFile.Name, param[j].Name, fieldTypeWrapper.SigName);
											StaticCompiler.errorCount++;
											continue;
										}
										if (m.IsStatic && !field.IsStatic)
										{
											Console.Error.WriteLine("Error: Native method field binding cannot access instance field from static method: {0}.{1}{2}", classFile.Name, param[j].Name, fieldTypeWrapper.SigName);
											StaticCompiler.errorCount++;
											continue;
										}
										if (!field.IsAccessibleFrom(wrapper, wrapper, wrapper))
										{
											Console.Error.WriteLine("Error: Native method field binding not accessible: {0}.{1}{2}", classFile.Name, param[j].Name, fieldTypeWrapper.SigName);
											StaticCompiler.errorCount++;
											continue;
										}
										if (paramType.IsByRef && field.IsFinal)
										{
											Console.Error.WriteLine("Error: Native method field binding cannot use ByRef for final field: {0}.{1}{2}", classFile.Name, param[j].Name, fieldTypeWrapper.SigName);
											StaticCompiler.errorCount++;
											continue;
										}
										field.Link();
										if (paramType.IsByRef && field.GetField() == null)
										{
											Console.Error.WriteLine("Error: Native method field binding cannot use ByRef on field without backing field: {0}.{1}{2}", classFile.Name, param[j].Name, fieldTypeWrapper.SigName);
											StaticCompiler.errorCount++;
											continue;
										}
										if (!field.IsStatic)
										{
											ilGenerator.EmitLdarg(0);
										}
										if (paramType.IsByRef)
										{
											ilGenerator.Emit(field.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldflda, field.GetField());
										}
										else
										{
											field.EmitGet(ilGenerator);
										}
									}
									ilGenerator.Emit(OpCodes.Call, nativeMethod);
									TypeWrapper retTypeWrapper = methods[i].ReturnType;
									if (!retTypeWrapper.TypeAsTBD.Equals(nativeMethod.ReturnType) && !retTypeWrapper.IsGhost)
									{
										ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
									}
									ilGenerator.Emit(OpCodes.Ret);
#endif
								}
								else
								{
									if (wrapper.classLoader.NoJNI)
									{
										// since NoJniStubs can only be set when we're statically compiling, it is safe to use the "compiler" trace switch
										Tracer.Warning(Tracer.Compiler, "Native method not implemented: {0}.{1}.{2}", classFile.Name, m.Name, m.Signature);
										ilGenerator.EmitThrow("java.lang.UnsatisfiedLinkError", "Native method not implemented (compiled with -nojni): " + classFile.Name + "." + m.Name + m.Signature);
									}
#if STATIC_COMPILER
									else if (StaticCompiler.runtimeJniAssembly == null)
									{
										Console.Error.WriteLine("Error: Native method not implemented: {0}.{1}{2}", classFile.Name, m.Name, m.Signature);
										StaticCompiler.errorCount++;
									}
#endif
									else
									{
										if (JVM.IsSaveDebugImage)
										{
#if !STATIC_COMPILER
											JniProxyBuilder.Generate(this, ilGenerator, wrapper, methods[i], typeBuilder, classFile, m, args);
#endif // !STATIC_COMPILER
										}
										else
										{
											JniBuilder.Generate(this, ilGenerator, wrapper, methods[i], typeBuilder, classFile, m, args, false);
										}
									}
								}
								ilGenerator.DoEmit();
							}
							finally
							{
								Profiler.Leave("JavaTypeImpl.Finish.Native");
							}
						}
						else
						{
							if (m.IsVirtual && classFile.IsInterface)
							{
								mb = (MethodBuilder)DefaultInterfaceMethodWrapper.GetImpl(methods[i]);
#if STATIC_COMPILER
								CreateDefaultMethodInterop(ref tbDefaultMethods, mb, methods[i]);
#endif
							}
							CodeEmitter ilGenerator = CodeEmitter.Create(mb);
							if (!m.IsStatic && !m.IsPublic && classFile.IsInterface)
							{
								// Java 8 non-virtual interface method that we compile as a static method,
								// we need to make sure the passed in this reference isn't null
								ilGenerator.EmitLdarg(0);
								if (wrapper.IsGhost)
								{
									ilGenerator.Emit(OpCodes.Ldfld, wrapper.GhostRefField);
								}
								ilGenerator.EmitNullCheck();
							}
							TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
#if STATIC_COMPILER
							// do we have an implementation in map.xml?
							if (wrapper.EmitMapXmlMethodPrologueAndOrBody(ilGenerator, classFile, m))
							{
								ilGenerator.DoEmit();
								continue;
							}
#endif // STATIC_COMPILER
							bool nonleaf = false;
							Compiler.Compile(this, host, wrapper, methods[i], classFile, m, ilGenerator, ref nonleaf);
							ilGenerator.CheckLabels();
							ilGenerator.DoEmit();
							if (nonleaf && !m.IsForceInline)
							{
								mb.SetImplementationFlags(mb.GetMethodImplementationFlags() | MethodImplAttributes.NoInlining);
							}
#if STATIC_COMPILER
							ilGenerator.EmitLineNumberTable(mb);
#else // STATIC_COMPILER
							byte[] linenumbers = ilGenerator.GetLineNumberTable();
							if (linenumbers != null)
							{
								if (wrapper.lineNumberTables == null)
								{
									wrapper.lineNumberTables = new byte[methods.Length][];
								}
								wrapper.lineNumberTables[i] = linenumbers;
							}
#endif // STATIC_COMPILER
						}
					}
				}

				AddInheritedDefaultInterfaceMethods(methods);

				if (clinitIndex != -1 || (basehasclinit && !classFile.IsInterface) || classFile.HasInitializedFields)
				{
					MethodBuilder cb;
					if (clinitIndex != -1)
					{
						cb = (MethodBuilder)methods[clinitIndex].GetMethod();
					}
					else
					{
						cb = ReflectUtil.DefineTypeInitializer(typeBuilder, wrapper.classLoader);
						AttributeHelper.HideFromJava(cb);
					}
					CodeEmitter ilGenerator = CodeEmitter.Create(cb);
					// before we call the base class initializer, we need to set the non-final static ConstantValue fields
					EmitConstantValueInitialization(fields, ilGenerator);
					if (basehasclinit)
					{
						wrapper.BaseTypeWrapper.EmitRunClassConstructor(ilGenerator);
					}
					if (clinitIndex != -1)
					{
						CompileConstructorBody(this, ilGenerator, clinitIndex);
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ret);
						ilGenerator.DoEmit();
					}
					ilGenerator.CheckLabels();
				}

				// add all interfaces that we implement (including the magic ones) and handle ghost conversions
				ImplementInterfaces(wrapper.Interfaces, new List<TypeWrapper>());

				// NOTE non-final fields aren't allowed in interfaces so we don't have to initialize constant fields
				if (!classFile.IsInterface)
				{
					// if a class has no constructor, we generate one otherwise Ref.Emit will create a default ctor
					// and that has several problems:
					// - base type may not have an accessible default constructor
					// - Ref.Emit uses BaseType.GetConstructors() which may trigger a TypeResolve event
					// - we don't want the synthesized constructor to show up in Java
					if (!hasConstructor)
					{
						CodeEmitter ilgen = CodeEmitter.Create(ReflectUtil.DefineConstructor(typeBuilder, MethodAttributes.PrivateScope, Type.EmptyTypes));
						ilgen.Emit(OpCodes.Ldnull);
						ilgen.Emit(OpCodes.Throw);
						ilgen.DoEmit();
					}

					// here we loop thru all the interfaces to explicitly implement any methods that we inherit from
					// base types that may have a different name from the name in the interface
					// (e.g. interface that has an equals() method that should override System.Object.Equals())
					// also deals with interface methods that aren't implemented (generate a stub that throws AbstractMethodError)
					// and with methods that aren't public (generate a stub that throws IllegalAccessError)
					Dictionary<TypeWrapper, TypeWrapper> doneSet = new Dictionary<TypeWrapper, TypeWrapper>();
					TypeWrapper[] interfaces = wrapper.Interfaces;
					for (int i = 0; i < interfaces.Length; i++)
					{
						ImplementInterfaceMethodStubs(doneSet, interfaces[i], false);
					}
					// if any of our base classes has an incomplete interface implementation we need to look through all
					// the base class interfaces to see if we've got an implementation now
					TypeWrapper baseTypeWrapper = wrapper.BaseTypeWrapper;
					while (baseTypeWrapper.HasIncompleteInterfaceImplementation)
					{
						for (int i = 0; i < baseTypeWrapper.Interfaces.Length; i++)
						{
							ImplementInterfaceMethodStubs(doneSet, baseTypeWrapper.Interfaces[i], true);
						}
						baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
					}
					if (!wrapper.IsAbstract && wrapper.HasUnsupportedAbstractMethods)
					{
						AddUnsupportedAbstractMethods();
					}
					if (!wrapper.GetClassLoader().NoAutomagicSerialization)
					{
						wrapper.automagicSerializationCtor = Serialization.AddAutomagicSerialization(wrapper, typeBuilder);
					}
				}

#if STATIC_COMPILER
				// If we're an interface that has public/protected fields, we create an inner class
				// to expose these fields to C# (which stubbornly refuses to see fields in interfaces).
				AddInterfaceFieldsInterop(fields);

				// If we're a Java 8 interface with static methods, we create an inner class
				// to expose these methods to C#.
				AddInterfaceMethodsInterop(methods);

				// See if there is any additional metadata
				wrapper.EmitMapXmlMetadata(typeBuilder, classFile, fields, methods);

				// if we inherit public members from non-public base classes or have public members with non-public types in their signature, we need access stubs
				if (wrapper.IsPublic)
				{
					AddAccessStubs();
				}

				AddConstantPoolAttributeIfNecessary(classFile, typeBuilder);
#endif // STATIC_COMPILER

				for (int i = 0; i < classFile.Methods.Length; i++)
				{
					ClassFile.Method m = classFile.Methods[i];
					MethodBuilder mb = (MethodBuilder)methods[i].GetMethod();
					if (mb == null)
					{
						continue;
					}
					if (m.Annotations != null)
					{
						ParameterBuilder returnParameter = null;
						foreach (object[] def in m.Annotations)
						{
							Annotation annotation = Annotation.Load(wrapper, def);
							if (annotation != null)
							{
								annotation.Apply(wrapper.GetClassLoader(), mb, def);
								annotation.ApplyReturnValue(wrapper.GetClassLoader(), mb, ref returnParameter, def);
							}
						}
					}
					string[] parameterNames;
					AddMethodParameterInfo(m, methods[i], mb, out parameterNames);
#if STATIC_COMPILER
					if (methods[i].HasCallerID)
					{
						AttributeHelper.SetEditorBrowsableNever(mb);
						EmitCallerIDStub(methods[i], parameterNames);
					}
					if (m.DllExportName != null && wrapper.classLoader.TryEnableUnmanagedExports())
					{
						mb.__AddUnmanagedExport(m.DllExportName, m.DllExportOrdinal);
					}
#endif // STATIC_COMPILER
				}

				for (int i = 0; i < classFile.Fields.Length; i++)
				{
					if (classFile.Fields[i].Annotations != null)
					{
						foreach (object[] def in classFile.Fields[i].Annotations)
						{
							Annotation annotation = Annotation.Load(wrapper, def);
							if (annotation != null)
							{
								{
									DynamicPropertyFieldWrapper prop = fields[i] as DynamicPropertyFieldWrapper;
									if (prop != null)
									{
										annotation.Apply(wrapper.GetClassLoader(), prop.GetPropertyBuilder(), def);
									}
									else
									{
										annotation.Apply(wrapper.GetClassLoader(), (FieldBuilder)fields[i].GetField(), def);
									}
								}
							}
						}
					}
				}

				if (classFile.Annotations != null)
				{
					foreach (object[] def in classFile.Annotations)
					{
						Annotation annotation = Annotation.Load(wrapper, def);
						if (annotation != null)
						{
							annotation.Apply(wrapper.GetClassLoader(), typeBuilder, def);
						}
					}
				}

#if STATIC_COMPILER
				AddImplementsAttribute();
#endif

				Type type;
				Profiler.Enter("TypeBuilder.CreateType");
				try
				{
					type = typeBuilder.CreateType();
					if (nestedTypeBuilders != null)
					{
						ClassLoaderWrapper.LoadClassCritical("ikvm.internal.IntrinsicAtomicReferenceFieldUpdater").Finish();
						ClassLoaderWrapper.LoadClassCritical("ikvm.internal.IntrinsicThreadLocal").Finish();
						foreach (TypeBuilder tb in nestedTypeBuilders)
						{
							tb.CreateType();
						}
					}
#if !STATIC_COMPILER
					if (liveObjects != null)
					{
						typeof(IKVM.Runtime.LiveObjectHolder<>).MakeGenericType(type).GetField("values", BindingFlags.Static | BindingFlags.Public).SetValue(null, liveObjects.ToArray());
					}
#endif
				}
				finally
				{
					Profiler.Leave("TypeBuilder.CreateType");
				}
#if !STATIC_COMPILER
				// When we're statically compiling we don't need to set the wrapper here, because we've already done so for the typeBuilder earlier.
				wrapper.GetClassLoader().SetWrapperForType(type, wrapper);
#endif
#if STATIC_COMPILER
				wrapper.FinishGhostStep2();
#endif
				BakedTypeCleanupHack.Process(wrapper);
				return type;
			}

#if STATIC_COMPILER
			private static void AddConstantPoolAttributeIfNecessary(ClassFile classFile, TypeBuilder typeBuilder)
			{
				object[] constantPool = null;
				bool[] inUse = null;
				MarkConstantPoolUsage(classFile, classFile.RuntimeVisibleTypeAnnotations, ref constantPool, ref inUse);
				foreach (ClassFile.Method method in classFile.Methods)
				{
					MarkConstantPoolUsage(classFile, method.RuntimeVisibleTypeAnnotations, ref constantPool, ref inUse);
				}
				foreach (ClassFile.Field field in classFile.Fields)
				{
					MarkConstantPoolUsage(classFile, field.RuntimeVisibleTypeAnnotations, ref constantPool, ref inUse);
				}
				if (constantPool != null)
				{
					// to save space, we clear out the items that aren't used by the RuntimeVisibleTypeAnnotations and
					// use an RLE for the empty slots
					AttributeHelper.SetConstantPoolAttribute(typeBuilder, ConstantPoolAttribute.Compress(constantPool, inUse));
				}
			}

			private static void MarkConstantPoolUsage(ClassFile classFile, byte[] runtimeVisibleTypeAnnotations, ref object[] constantPool, ref bool[] inUse)
			{
				if (runtimeVisibleTypeAnnotations != null)
				{
					if (constantPool == null)
					{
						constantPool = classFile.GetConstantPool();
						inUse = new bool[constantPool.Length];
					}
					try
					{
						BigEndianBinaryReader br = new BigEndianBinaryReader(runtimeVisibleTypeAnnotations, 0, runtimeVisibleTypeAnnotations.Length);
						ushort num_annotations = br.ReadUInt16();
						for (int i = 0; i < num_annotations; i++)
						{
							MarkConstantPoolUsageForTypeAnnotation(br, inUse);
						}
						return;
					}
					catch (ClassFormatError)
					{
					}
					catch (IndexOutOfRangeException)
					{
					}
					// if we fail to parse the annotations (e.g. due to a malformed attribute), we simply keep all the constant pool entries
					for (int i = 0; i < inUse.Length; i++)
					{
						inUse[i] = true;
					}
				}
			}

			private static void MarkConstantPoolUsageForTypeAnnotation(BigEndianBinaryReader br, bool[] inUse)
			{
				switch (br.ReadByte())		// target_type
				{
					case 0x00:
					case 0x01:
						br.ReadByte();		// type_parameter_index
						break;
					case 0x10:
						br.ReadUInt16();	// supertype_index
						break;
					case 0x11:
					case 0x12:
						br.ReadByte();		// type_parameter_index
						br.ReadByte();		// bound_index
						break;
					case 0x13:
					case 0x14:
					case 0x15:
						// empty_target
						break;
					case 0x16:
						br.ReadByte();		// formal_parameter_index
						break;
					case 0x17:
						br.ReadUInt16();	// throws_type_index
						break;
					default:
						throw new ClassFormatError("");
				}
				byte path_length = br.ReadByte();
				for (int i = 0; i < path_length; i++)
				{
					br.ReadByte();			// type_path_kind
					br.ReadByte();			// type_argument_index
				}
				MarkConstantPoolUsageForAnnotation(br, inUse);
			}

			private static void MarkConstantPoolUsageForAnnotation(BigEndianBinaryReader br, bool[] inUse)
			{
				ushort type_index = br.ReadUInt16();
				inUse[type_index] = true;
				ushort num_components = br.ReadUInt16();
				for (int i = 0; i < num_components; i++)
				{
					ushort component_name_index = br.ReadUInt16();
					inUse[component_name_index] = true;
					MarkConstantPoolUsageForAnnotationComponentValue(br, inUse);
				}
			}

			private static void MarkConstantPoolUsageForAnnotationComponentValue(BigEndianBinaryReader br, bool[] inUse)
			{
				switch ((char)br.ReadByte())	// tag
				{
					case 'B':
					case 'C':
					case 'D':
					case 'F':
					case 'I':
					case 'J':
					case 'S':
					case 'Z':
					case 's':
					case 'c':
						inUse[br.ReadUInt16()] = true;
						break;
					case 'e':
						inUse[br.ReadUInt16()] = true;
						inUse[br.ReadUInt16()] = true;
						break;
					case '@@':
						MarkConstantPoolUsageForAnnotation(br, inUse);
						break;
					case '[':
						ushort num_values = br.ReadUInt16();
						for (int i = 0; i < num_values; i++)
						{
							MarkConstantPoolUsageForAnnotationComponentValue(br, inUse);
						}
						break;
					default:
						throw new ClassFormatError("");
				}
			}

			private bool EmitInterlockedCompareAndSet(MethodWrapper method, string fieldName, CodeEmitter ilGenerator)
			{
				if (method.ReturnType != PrimitiveTypeWrapper.BOOLEAN)
				{
					return false;
				}
				TypeWrapper[] parameters = method.GetParameters();
				TypeWrapper target;
				int firstValueIndex;
				if (method.IsStatic)
				{
					if (parameters.Length != 3)
					{
						return false;
					}
					target = parameters[0];
					firstValueIndex = 1;
				}
				else
				{
					if (parameters.Length != 2)
					{
						return false;
					}
					target = method.DeclaringType;
					firstValueIndex = 0;
				}
				if (target.IsUnloadable || target.IsPrimitive || target.IsNonPrimitiveValueType || target.IsGhost)
				{
					return false;
				}
				TypeWrapper fieldType = parameters[firstValueIndex];
				if (fieldType != parameters[firstValueIndex + 1])
				{
					return false;
				}
				if (fieldType.IsUnloadable || fieldType.IsNonPrimitiveValueType || fieldType.IsGhost)
				{
					return false;
				}
				if (fieldType.IsPrimitive && fieldType != PrimitiveTypeWrapper.LONG && fieldType != PrimitiveTypeWrapper.INT)
				{
					return false;
				}
				FieldWrapper casField = null;
				foreach (FieldWrapper fw in target.GetFields())
				{
					if (fw.Name == fieldName)
					{
						if (casField != null)
						{
							return false;
						}
						casField = fw;
					}
				}
				if (casField == null)
				{
					return false;
				}
				if (casField.IsStatic)
				{
					return false;
				}
				if (casField.FieldTypeWrapper != fieldType)
				{
					return false;
				}
				if (casField.IsPropertyAccessor)
				{
					return false;
				}
				if (casField.DeclaringType.TypeAsBaseType == typeBuilder.DeclaringType)
				{
					// allow access to fields in outer class
				}
				else if (!casField.IsAccessibleFrom(casField.DeclaringType, wrapper, casField.DeclaringType))
				{
					return false;
				}
				casField.Link();
				FieldInfo fi = casField.GetField();
				if (fi == null)
				{
					return false;
				}
				ilGenerator.EmitLdarg(0);
				ilGenerator.Emit(OpCodes.Ldflda, fi);
				ilGenerator.EmitLdarg(2);
				ilGenerator.EmitLdarg(1);
				if (fieldType == PrimitiveTypeWrapper.LONG)
				{
					ilGenerator.Emit(OpCodes.Call, InterlockedMethods.CompareExchangeInt64);
				}
				else if (fieldType == PrimitiveTypeWrapper.INT)
				{
					ilGenerator.Emit(OpCodes.Call, InterlockedMethods.CompareExchangeInt32);
				}
				else
				{
					ilGenerator.Emit(OpCodes.Call, AtomicReferenceFieldUpdaterEmitter.MakeCompareExchange(casField.FieldTypeWrapper.TypeAsSignatureType));
				}
				ilGenerator.EmitLdarg(1);
				ilGenerator.Emit(OpCodes.Ceq);
				ilGenerator.Emit(OpCodes.Ret);
				return true;
			}
#endif

			private void AddMethodParameterInfo(ClassFile.Method m, MethodWrapper mw, MethodBuilder mb, out string[] parameterNames)
			{
				parameterNames = null;
				ParameterBuilder[] parameterBuilders = null;
				if (wrapper.GetClassLoader().EmitDebugInfo
#if STATIC_COMPILER
					|| (classFile.IsPublic && (m.IsPublic || m.IsProtected))
					|| (m.MethodParameters != null && !wrapper.GetClassLoader().NoParameterReflection)
#endif
					)
				{
					parameterNames = new string[mw.GetParameters().Length];
					GetParameterNamesFromMP(m, parameterNames);
#if STATIC_COMPILER
					if (m.MethodParameters == null)
#endif
					{
						GetParameterNamesFromLVT(m, parameterNames);
						GetParameterNamesFromSig(m.Signature, parameterNames);
					}
#if STATIC_COMPILER
					wrapper.GetParameterNamesFromXml(m.Name, m.Signature, parameterNames);
#endif
					parameterBuilders = GetParameterBuilders(mb, parameterNames.Length, parameterNames);
				}
#if STATIC_COMPILER
				if ((m.Modifiers & Modifiers.VarArgs) != 0 && !mw.HasCallerID)
				{
					if (parameterBuilders == null)
					{
						parameterBuilders = GetParameterBuilders(mb, mw.GetParameters().Length, null);
					}
					if (parameterBuilders.Length > 0)
					{
						AttributeHelper.SetParamArrayAttribute(parameterBuilders[parameterBuilders.Length - 1]);
					}
				}
				wrapper.AddXmlMapParameterAttributes(mb, classFile.Name, m.Name, m.Signature, ref parameterBuilders);
#endif
				if (m.ParameterAnnotations != null)
				{
					if (parameterBuilders == null)
					{
						parameterBuilders = GetParameterBuilders(mb, mw.GetParameters().Length, null);
					}
					object[][] defs = m.ParameterAnnotations;
					for (int j = 0; j < defs.Length; j++)
					{
						foreach (object[] def in defs[j])
						{
							Annotation annotation = Annotation.Load(wrapper, def);
							if (annotation != null)
							{
								annotation.Apply(wrapper.GetClassLoader(), parameterBuilders[j], def);
							}
						}
					}
				}
			}

#if STATIC_COMPILER
			private void AddImplementsAttribute()
			{
				TypeWrapper[] interfaces = wrapper.Interfaces;
				if (wrapper.BaseTypeWrapper == CoreClasses.java.lang.Object.Wrapper)
				{
					// We special case classes extending java.lang.Object to optimize the metadata encoding
					// for anonymous classes that implement an interface.
					Type[] actualInterfaces = typeBuilder.GetInterfaces();
					if (actualInterfaces.Length == 0)
					{
						return;
					}
					else if (actualInterfaces.Length == 1
						&& interfaces.Length == 1
						&& !interfaces[0].IsRemapped
						&& interfaces[0].TypeAsBaseType == actualInterfaces[0])
					{
						// We extend java.lang.Object and implement only a single (non-remapped) interface,
						// in this case we can omit the ImplementAttribute since the runtime will be able
						// to reliable reproduce the "list" of implemented interfaces.
						return;
					}
				}
				else if (interfaces.Length == 0)
				{
					return;
				}
				AttributeHelper.SetImplementsAttribute(typeBuilder, interfaces);
			}

			private TypeBuilder DefineNestedInteropType(string name)
			{
				CompilerClassLoader ccl = wrapper.classLoader;
				while (!ccl.ReserveName(classFile.Name + "$" + name))
				{
					name += "_";
				}
				TypeBuilder tb = typeBuilder.DefineNestedType(name, TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract);
				RegisterNestedTypeBuilder(tb);
				AttributeHelper.HideFromJava(tb);
				return tb;
			}
	
			private void AddInterfaceFieldsInterop(FieldWrapper[] fields)
			{
				if (classFile.IsInterface && classFile.IsPublic && !wrapper.IsGhost && classFile.Fields.Length > 0 && wrapper.classLoader.WorkaroundInterfaceFields)
				{
					TypeBuilder tbFields = DefineNestedInteropType(NestedTypeName.Fields);
					CodeEmitter ilgenClinit = null;
					for (int i = 0; i < classFile.Fields.Length; i++)
					{
						ClassFile.Field f = classFile.Fields[i];
						if (f.ConstantValue != null)
						{
							FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal;
							FieldBuilder fb = tbFields.DefineField(f.Name, fields[i].FieldTypeWrapper.TypeAsSignatureType, attribs);
							fb.SetConstant(f.ConstantValue);
						}
						else
						{
							FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.InitOnly;
							FieldBuilder fb = tbFields.DefineField(f.Name, fields[i].FieldTypeWrapper.TypeAsPublicSignatureType, attribs);
							if (ilgenClinit == null)
							{
								ilgenClinit = CodeEmitter.Create(ReflectUtil.DefineTypeInitializer(tbFields, wrapper.classLoader));
							}
							wrapper.GetFieldWrapper(f.Name, f.Signature).EmitGet(ilgenClinit);
							ilgenClinit.Emit(OpCodes.Stsfld, fb);
						}
					}
					if (ilgenClinit != null)
					{
						ilgenClinit.Emit(OpCodes.Ret);
						ilgenClinit.DoEmit();
					}
				}
			}

			private void AddInterfaceMethodsInterop(MethodWrapper[] methods)
			{
				if (classFile.IsInterface && classFile.IsPublic && classFile.MajorVersion >= 52 && !wrapper.IsGhost && methods.Length > 0 && wrapper.classLoader.WorkaroundInterfaceStaticMethods)
				{
					TypeBuilder tbMethods = null;
					foreach (MethodWrapper mw in methods)
					{
						if (mw.IsStatic && mw.IsPublic && mw.Name != StringConstants.CLINIT && ParametersAreAccessible(mw))
						{
							if (tbMethods == null)
							{
								tbMethods = DefineNestedInteropType(NestedTypeName.Methods);
							}
							MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(), tbMethods, mw.Name, MethodAttributes.Public | MethodAttributes.Static, null, true);
							CodeEmitter ilgen = CodeEmitter.Create(mb);
							TypeWrapper[] parameters = mw.GetParameters();
							for (int i = 0; i < parameters.Length; i++)
							{
								ilgen.EmitLdarg(i);
								if (!parameters[i].IsUnloadable && !parameters[i].IsPublic)
								{
									parameters[i].EmitCheckcast(ilgen);
								}
							}
							mw.EmitCall(ilgen);
							ilgen.Emit(OpCodes.Ret);
							ilgen.DoEmit();
						}
					}
				}
			}

			private void CreateDefaultMethodInterop(ref TypeBuilder tbDefaultMethods, MethodBuilder defaultMethod, MethodWrapper mw)
			{
				if (!ParametersAreAccessible(mw))
				{
					return;
				}
				if (tbDefaultMethods == null)
				{
					tbDefaultMethods = DefineNestedInteropType(NestedTypeName.DefaultMethods);
				}
				MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(), tbDefaultMethods, mw.Name, MethodAttributes.Public | MethodAttributes.Static, wrapper.TypeAsSignatureType, true);
				CodeEmitter ilgen = CodeEmitter.Create(mb);
				if (wrapper.IsGhost)
				{
					ilgen.EmitLdarga(0);
					ilgen.Emit(OpCodes.Ldfld, wrapper.GhostRefField);
					ilgen.EmitNullCheck();
					ilgen.EmitLdarga(0);
				}
				else
				{
					ilgen.EmitLdarg(0);
					ilgen.Emit(OpCodes.Dup);
					ilgen.EmitNullCheck();
				}
				TypeWrapper[] parameters = mw.GetParameters();
				for (int i = 0; i < parameters.Length; i++)
				{
					ilgen.EmitLdarg(i + 1);
					if (!parameters[i].IsUnloadable && !parameters[i].IsPublic)
					{
						parameters[i].EmitCheckcast(ilgen);
					}
				}
				ilgen.Emit(OpCodes.Call, defaultMethod);
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
			}
#endif

			private void AddInheritedDefaultInterfaceMethods(MethodWrapper[] methods)
			{
				// look at the miranda methods to see if we inherit any default interface methods
				for (int i = classFile.Methods.Length; i < methods.Length; i++)
				{
					if (methods[i].IsMirandaMethod)
					{
						MirandaMethodWrapper mmw = (MirandaMethodWrapper)methods[i];
						if (mmw.Error == null && !mmw.BaseMethod.IsAbstract)
						{
							// we inherited a default interface method, so we need to forward the miranda method to the default method
							MethodBuilder mb = (MethodBuilder)mmw.GetMethod();
							if (classFile.IsInterface)
							{
								// if we're an interface with a default miranda method, we need to create a new default method that forwards to the original
								mb = methods[i].GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(),
									typeBuilder, NamePrefix.DefaultMethod + mb.Name, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, typeBuilder, false);
							}
							EmitCallDefaultInterfaceMethod(mb, mmw.BaseMethod);
						}
					}
				}
			}

			internal static void EmitCallDefaultInterfaceMethod(MethodBuilder mb, MethodWrapper defaultMethod)
			{
				CodeEmitter ilgen = CodeEmitter.Create(mb);
				if (defaultMethod.DeclaringType.IsGhost)
				{
					CodeEmitterLocal local = ilgen.DeclareLocal(defaultMethod.DeclaringType.TypeAsSignatureType);
					ilgen.Emit(OpCodes.Ldloca, local);
					ilgen.EmitLdarg(0);
					ilgen.Emit(OpCodes.Stfld, defaultMethod.DeclaringType.GhostRefField);
					ilgen.Emit(OpCodes.Ldloca, local);
				}
				else
				{
					ilgen.EmitLdarg(0);
				}
				for (int j = 0, count = defaultMethod.GetParameters().Length; j < count; j++)
				{
					ilgen.EmitLdarg(j + 1);
				}
				ilgen.Emit(OpCodes.Call, DefaultInterfaceMethodWrapper.GetImpl(defaultMethod));
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
			}

#if STATIC_COMPILER
			private void AddAccessStubs()
			{
				/*
				 * There are two types of access stubs:
				 * 
				 * Type 1   These are required when a public class extends a non-public class.
				 *			In that case we need access stubs for all public and protected members
				 *			of the non-public base classes.
				 *
				 * Type 2	When a public class exposes a member that contains a non-public type in
				 *			its signature, we need an access stub for that member (where we convert
				 *			the non-public type in the signature to the first public base type).
				 *			Additionally, when a public or protected final field is compiled
				 *			without -strictfinalfieldsemantics, a the field will be wrapper with a
				 *			read-only property.
				 *
				 * Note that type 1 access stubs may also need the type 2 signature type widening
				 * if the signature contains non-public types.
				 * 
				 * Type 1 access stubs are always required, because the JVM allow access to these
				 * members via the derived class while the CLR doesn't. Historically, we've exposed
				 * these access stubs in such a way that they are also consumable from other .NET
				 * languages (when feasible), so we'll continue to do that for back compat.
				 * 
				 * Type 2 access stubs are only required by the CLR when running on CLR v4 and the
				 * caller assembly is security transparent code (level 2). We also want the access
				 * stubs to allow other .NET languages (e.g. C#) to consume broken APIs that
				 * (accidentally) expose these members.
				 */
				AddType2FieldAccessStubs();
				AddType1FieldAccessStubs(wrapper);
				if (!wrapper.IsInterface)
				{
					int id = 0;
					AddType2MethodAccessStubs(ref id);
					AddType1MethodAccessStubs(ref id);
				}
			}

			private void AddType1FieldAccessStubs(TypeWrapper tw)
			{
				do
				{
					if (!tw.IsPublic)
					{
						foreach (FieldWrapper fw in tw.GetFields())
						{
							if ((fw.IsPublic || (fw.IsProtected && !wrapper.IsFinal))
								&& wrapper.GetFieldWrapper(fw.Name, fw.Signature) == fw)
							{
								GenerateAccessStub(fw, true);
							}
						}
					}
					foreach (TypeWrapper iface in tw.Interfaces)
					{
						AddType1FieldAccessStubs(iface);
					}
					tw = tw.BaseTypeWrapper;
				} while (tw != null && !tw.IsPublic);
			}

			private void AddType2FieldAccessStubs()
			{
				foreach (FieldWrapper fw in wrapper.GetFields())
				{
					if (wrapper.NeedsType2AccessStub(fw))
					{
						GenerateAccessStub(fw, false);
					}
				}
			}

			private void GenerateAccessStub(FieldWrapper fw, bool type1)
			{
				if (fw is ConstantFieldWrapper)
				{
					// constants cannot have a type 2 access stub, because constant types are always public
					Debug.Assert(type1);

					FieldAttributes attribs = fw.IsPublic ? FieldAttributes.Public : FieldAttributes.FamORAssem;
					attribs |= FieldAttributes.Static | FieldAttributes.Literal;
					// we attach the AccessStub custom modifier because the C# compiler prefers fields without custom modifiers
					// so if this class defines a field with the same name, that will be preferred over this one by the C# compiler
					FieldBuilder fb = typeBuilder.DefineField(fw.Name, fw.FieldTypeWrapper.TypeAsSignatureType, null, new Type[] { JVM.LoadType(typeof(IKVM.Attributes.AccessStub)) }, attribs);
					AttributeHelper.HideFromReflection(fb);
					fb.SetConstant(((ConstantFieldWrapper)fw).GetConstantValue());
				}
				else
				{
					Type propType = fw.FieldTypeWrapper.TypeAsPublicSignatureType;
					Type[] modopt = wrapper.GetModOpt(fw.FieldTypeWrapper, true);
					PropertyBuilder pb = typeBuilder.DefineProperty(fw.Name, PropertyAttributes.None, propType, null, modopt, Type.EmptyTypes, null, null);
					if (type1)
					{
						AttributeHelper.HideFromReflection(pb);
					}
					else
					{
						AttributeHelper.SetModifiers(pb, fw.Modifiers, fw.IsInternal);
					}
					MethodAttributes attribs = fw.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
					attribs |= MethodAttributes.HideBySig | MethodAttributes.SpecialName;
					if (fw.IsStatic)
					{
						attribs |= MethodAttributes.Static;
					}
					// we append the IKVM.Attributes.AccessStub type to the modopt array for use in the property accessor method signature
					// to make sure they never conflict with any user defined methhods
					Type[] modopt2 = ArrayUtil.Concat(modopt, JVM.LoadType(typeof(IKVM.Attributes.AccessStub)));
					MethodBuilder getter = typeBuilder.DefineMethod("get_" + fw.Name, attribs, CallingConventions.Standard, propType, null, modopt2, Type.EmptyTypes, null, null);
					AttributeHelper.HideFromJava(getter);
					pb.SetGetMethod(getter);
					CodeEmitter ilgen = CodeEmitter.Create(getter);
					if (!fw.IsStatic)
					{
						ilgen.Emit(OpCodes.Ldarg_0);
					}
					fw.EmitGet(ilgen);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();
					if (!fw.IsFinal || (!fw.IsStatic && !type1))
					{
						if (fw.IsFinal)
						{
							// we need to generate a (private) setter for final fields for reflection and serialization
							attribs &= ~MethodAttributes.MemberAccessMask;
							attribs |= MethodAttributes.Private;
						}
						MethodBuilder setter = typeBuilder.DefineMethod("set_" + fw.Name, attribs, CallingConventions.Standard, null, null, null, new Type[] { propType }, null, new Type[][] { modopt2 });
						AttributeHelper.HideFromJava(setter);
						pb.SetSetMethod(setter);
						ilgen = CodeEmitter.Create(setter);
						ilgen.Emit(OpCodes.Ldarg_0);
						if (!fw.IsStatic)
						{
							ilgen.Emit(OpCodes.Ldarg_1);
						}
						// we don't do a DynamicCast if fw.FieldTypeWrapper is unloadable, because for normal unloadable fields we don't enfore the type either
						if (propType != fw.FieldTypeWrapper.TypeAsSignatureType)
						{
							ilgen.Emit(OpCodes.Castclass, fw.FieldTypeWrapper.TypeAsSignatureType);
						}
						fw.EmitSet(ilgen);
						ilgen.Emit(OpCodes.Ret);
						ilgen.DoEmit();
					}
				}
			}

			private void AddType1MethodAccessStubs(ref int id)
			{
				for (TypeWrapper tw = wrapper.BaseTypeWrapper; tw != null && !tw.IsPublic; tw = tw.BaseTypeWrapper)
				{
					foreach (MethodWrapper mw in tw.GetMethods())
					{
						if ((mw.IsPublic || (mw.IsProtected && !wrapper.IsFinal))
							&& (!mw.IsAbstract || wrapper.IsAbstract)
							&& mw.Name != StringConstants.INIT
							&& wrapper.GetMethodWrapper(mw.Name, mw.Signature, true) == mw
							&& ParametersAreAccessible(mw))
						{
							GenerateAccessStub(id, mw, true, true);
							if (!mw.IsStatic && !mw.IsFinal && !mw.IsAbstract && !wrapper.IsFinal)
							{
								GenerateAccessStub(id, mw, false, true);
							}
							id++;
						}
					}
				}
			}

			private void AddType2MethodAccessStubs(ref int id)
			{
				foreach (MethodWrapper mw in wrapper.GetMethods())
				{
					if (mw.HasNonPublicTypeInSignature
						&& (mw.IsPublic || (mw.IsProtected && !wrapper.IsFinal))
						&& ParametersAreAccessible(mw))
					{
						GenerateAccessStub(id, mw, true, false);
						if (!mw.IsStatic && !mw.IsFinal && !mw.IsAbstract && mw.Name != StringConstants.INIT && !wrapper.IsFinal)
						{
							GenerateAccessStub(id, mw, false, false);
						}
						id++;
					}
				}
			}

			private void GenerateAccessStub(int id, MethodWrapper mw, bool virt, bool type1)
			{
				Debug.Assert(!mw.HasCallerID);
				MethodAttributes stubattribs = mw.IsPublic && virt ? MethodAttributes.Public : MethodAttributes.FamORAssem;
				stubattribs |= MethodAttributes.HideBySig;
				if (mw.IsStatic)
				{
					stubattribs |= MethodAttributes.Static;
				}
				TypeWrapper[] parameters = mw.GetParameters();
				Type[] realParameterTypes = new Type[parameters.Length];
				Type[] parameterTypes = new Type[parameters.Length];
				Type[][] modopt = new Type[parameters.Length][];
				for (int i = 0; i < parameters.Length; i++)
				{
					realParameterTypes[i] = parameters[i].TypeAsSignatureType;
					parameterTypes[i] = parameters[i].TypeAsPublicSignatureType;
					modopt[i] = wrapper.GetModOpt(parameters[i], true);
				}
				Type returnType = mw.ReturnType.TypeAsPublicSignatureType;
				Type[] modoptReturnType = ArrayUtil.Concat(wrapper.GetModOpt(mw.ReturnType, true), JVM.LoadType(typeof(IKVM.Attributes.AccessStub)));
				string name;
				if (mw.Name == StringConstants.INIT)
				{
					name = ConstructorInfo.ConstructorName;
					stubattribs |= MethodAttributes.SpecialName | MethodAttributes.RTSpecialName;
				}
				else
				{
					name = virt
						? (mw.Modifiers & Modifiers.Bridge) == 0 ? mw.Name : NamePrefix.Bridge + mw.Name
						: NamePrefix.NonVirtual + id;
				}
				MethodBuilder mb = typeBuilder.DefineMethod(name, stubattribs, CallingConventions.Standard, returnType, null, modoptReturnType, parameterTypes, null, modopt);
				if (virt && type1)
				{
					AttributeHelper.HideFromReflection(mb);
					AttributeHelper.SetNameSig(mb, NamePrefix.AccessStub + id + "|" + mw.Name, mw.Signature);
				}
				else
				{
					AttributeHelper.HideFromJava(mb);
					if (!type1)
					{
						AttributeHelper.SetNameSig(mb, mw.Name, mw.Signature);
					}
				}
				CodeEmitter ilgen = CodeEmitter.Create(mb);
				int argpos = 0;
				if (!mw.IsStatic)
				{
					ilgen.EmitLdarg(argpos++);
				}
				for (int i = 0; i < parameterTypes.Length; i++)
				{
					ilgen.EmitLdarg(argpos++);
					// we don't need to do a DynamicCast if for unloadables, because the method itself will already do that
					if (parameterTypes[i] != realParameterTypes[i])
					{
						ilgen.Emit(OpCodes.Castclass, realParameterTypes[i]);
					}
				}
				if (mw.IsStatic || !virt || mw.Name == StringConstants.INIT)
				{
					mw.EmitCall(ilgen);
				}
				else
				{
					mw.EmitCallvirt(ilgen);
				}
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
			}

			private bool ParametersAreAccessible(MethodWrapper mw)
			{
				foreach (TypeWrapper tw in mw.GetParameters())
				{
					if (!tw.IsAccessibleFrom(wrapper))
					{
						return false;
					}
				}
				return true;
			}
#endif // STATIC_COMPILER

			private void ImplementInterfaceMethodStubs(Dictionary<TypeWrapper, TypeWrapper> doneSet, TypeWrapper interfaceTypeWrapper, bool baseClassInterface)
			{
				Debug.Assert(interfaceTypeWrapper.IsInterface);

				// make sure we don't do the same method twice
				if (doneSet.ContainsKey(interfaceTypeWrapper))
				{
					return;
				}
				doneSet.Add(interfaceTypeWrapper, interfaceTypeWrapper);
				foreach (MethodWrapper method in interfaceTypeWrapper.GetMethods())
				{
					if (!method.IsStatic && method.IsPublic && !method.IsDynamicOnly)
					{
						ImplementInterfaceMethodStubImpl(method, baseClassInterface);
					}
				}
				TypeWrapper[] interfaces = interfaceTypeWrapper.Interfaces;
				for (int i = 0; i < interfaces.Length; i++)
				{
					ImplementInterfaceMethodStubs(doneSet, interfaces[i], baseClassInterface);
				}
			}

			private void ImplementInterfaceMethodStubImpl(MethodWrapper ifmethod, bool baseClassInterface)
			{
				// we're mangling the name to prevent subclasses from accidentally overriding this method and to
				// prevent clashes with overloaded method stubs that are erased to the same signature (e.g. unloadable types and ghost arrays)
				// HACK the signature and name are the wrong way around to work around a C++/CLI bug (apparantely it looks looks at the last n
				// characters of the method name, or something bizarre like that)
				// https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=234167
				string mangledName = ifmethod.DeclaringType.Name + "/" + ifmethod.Signature + ifmethod.Name;
				MethodWrapper mce = null;
				TypeWrapper lookup = wrapper;
				while (lookup != null)
				{
					mce = lookup.GetMethodWrapper(ifmethod.Name, ifmethod.Signature, true);
					if (mce == null || !mce.IsStatic)
					{
						break;
					}
					lookup = mce.DeclaringType.BaseTypeWrapper;
				}
				if (mce != null)
				{
					Debug.Assert(!mce.HasCallerID);
					if (mce.DeclaringType != wrapper)
					{
						// check the loader constraints
						bool error = false;
						if (mce.ReturnType != ifmethod.ReturnType && !mce.ReturnType.IsUnloadable && !ifmethod.ReturnType.IsUnloadable)
						{
							error = true;
						}
						TypeWrapper[] mceparams = mce.GetParameters();
						TypeWrapper[] ifparams = ifmethod.GetParameters();
						for (int i = 0; i < mceparams.Length; i++)
						{
							if (mceparams[i] != ifparams[i] && !mceparams[i].IsUnloadable && !ifparams[i].IsUnloadable)
							{
								error = true;
								break;
							}
						}
						if (error)
						{
							MethodBuilder mb = DefineInterfaceStubMethod(mangledName, ifmethod);
							AttributeHelper.HideFromJava(mb);
							CodeEmitter ilgen = CodeEmitter.Create(mb);
							ilgen.EmitThrow("java.lang.LinkageError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
							ilgen.DoEmit();
							typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
							return;
						}
					}
					if (!mce.IsPublic && !mce.IsInternal)
					{
						// NOTE according to the ECMA spec it isn't legal for a privatescope method to be virtual, but this works and
						// it makes sense, so I hope the spec is wrong
						// UPDATE unfortunately, according to Serge Lidin the spec is correct, and it is not allowed to have virtual privatescope
						// methods. Sigh! So I have to use private methods and mangle the name
						MethodBuilder mb = DefineInterfaceStubMethod(NamePrefix.Incomplete + mangledName, ifmethod);
						AttributeHelper.HideFromJava(mb);
						CodeEmitter ilgen = CodeEmitter.Create(mb);
						ilgen.EmitThrow("java.lang.IllegalAccessError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
						ilgen.DoEmit();
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
						wrapper.SetHasIncompleteInterfaceImplementation();
					}
					else if (mce.GetMethod() == null || mce.RealName != ifmethod.RealName || mce.IsInternal || !ReflectUtil.IsSameAssembly(mce.DeclaringType.TypeAsTBD, typeBuilder) || CheckRequireOverrideStub(mce, ifmethod))
					{
						// NOTE methods inherited from base classes in a different assembly do *not* automatically implement
						// interface methods, so we have to generate a stub here that doesn't do anything but call the base
						// implementation
						wrapper.GenerateOverrideStub(typeBuilder, ifmethod, null, mce);
					}
					else if (baseClassInterface && mce.DeclaringType == wrapper)
					{
						typeBuilder.DefineMethodOverride((MethodInfo)mce.GetMethod(), (MethodInfo)ifmethod.GetMethod());
					}
				}
				else
				{
					if (!wrapper.IsAbstract || (!baseClassInterface && wrapper.GetMethodWrapper(ifmethod.Name, ifmethod.Signature, false) != null))
					{
						// the type doesn't implement the interface method and isn't abstract either. The JVM allows this, but the CLR doesn't,
						// so we have to create a stub method that throws an AbstractMethodError
						MethodBuilder mb = DefineInterfaceStubMethod(NamePrefix.Incomplete + mangledName, ifmethod);
						AttributeHelper.HideFromJava(mb);
						CodeEmitter ilgen = CodeEmitter.Create(mb);
						ilgen.EmitThrow("java.lang.AbstractMethodError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
						ilgen.DoEmit();
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
						wrapper.SetHasIncompleteInterfaceImplementation();
						wrapper.EmitLevel4Warning(HardError.AbstractMethodError, wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
					}
				}
			}

			private MethodBuilder DefineInterfaceStubMethod(string name, MethodWrapper mw)
			{
				return mw.GetDefineMethodHelper().DefineMethod(wrapper, typeBuilder, name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final);
			}

			private static class BakedTypeCleanupHack
			{
#if NET_4_0 || STATIC_COMPILER
				internal static void Process(DynamicTypeWrapper wrapper) { }
#else
				private static readonly FieldInfo m_methodBuilder = typeof(ConstructorBuilder).GetField("m_methodBuilder", BindingFlags.Instance | BindingFlags.NonPublic);
				private static readonly FieldInfo[] methodBuilderFields = GetFieldList(typeof(MethodBuilder), new string[]
					{
						"m_ilGenerator",
						"m_ubBody",
						"m_RVAFixups",
						"m_mdMethodFixups",
						"m_localSignature",
						"m_localSymInfo",
						"m_exceptions",
						"m_parameterTypes",
						"m_retParam",
						"m_returnType",
						"m_signature"
					});
				private static readonly FieldInfo[] fieldBuilderFields = GetFieldList(typeof(FieldBuilder), new string[]
					{
						"m_data",
						"m_fieldType",
					});

				private static bool IsSupportedVersion
				{
					get
					{
						return Environment.Version.Major == 2 && Environment.Version.Minor == 0 && Environment.Version.Build == 50727 && Environment.Version.Revision == 4016;
					}
				}

				[SecurityCritical]
				[SecurityTreatAsSafe]
				private static FieldInfo[] GetFieldList(Type type, string[] list)
				{
					if (JVM.SafeGetEnvironmentVariable("IKVM_DISABLE_TYPEBUILDER_HACK") != null || !IsSupportedVersion)
					{
						return null;
					}
					if (!SecurityManager.IsGranted(new SecurityPermission(SecurityPermissionFlag.Assertion)) ||
						!SecurityManager.IsGranted(new ReflectionPermission(ReflectionPermissionFlag.MemberAccess)))
					{
						return null;
					}
					FieldInfo[] fields = new FieldInfo[list.Length];
					for (int i = 0; i < list.Length; i++)
					{
						fields[i] = type.GetField(list[i], BindingFlags.Instance | BindingFlags.NonPublic);
						if (fields[i] == null)
						{
							return null;
						}
					}
					return fields;
				}

				[SecurityCritical]
				[SecurityTreatAsSafe]
				internal static void Process(DynamicTypeWrapper wrapper)
				{
					if (m_methodBuilder != null && methodBuilderFields != null && fieldBuilderFields != null)
					{
						foreach (MethodWrapper mw in wrapper.GetMethods())
						{
							MethodBuilder mb = mw.GetMethod() as MethodBuilder;
							if (mb == null)
							{
								ConstructorBuilder cb = mw.GetMethod() as ConstructorBuilder;
								if (cb != null)
								{
									new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
									mb = (MethodBuilder)m_methodBuilder.GetValue(cb);
									CodeAccessPermission.RevertAssert();
								}
							}
							if (mb != null)
							{
								new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
								foreach (FieldInfo fi in methodBuilderFields)
								{
									fi.SetValue(mb, null);
								}
								CodeAccessPermission.RevertAssert();
							}
						}
						foreach (FieldWrapper fw in wrapper.GetFields())
						{
							FieldBuilder fb = fw.GetField() as FieldBuilder;
							if (fb != null)
							{
								new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
								foreach (FieldInfo fi in fieldBuilderFields)
								{
									fi.SetValue(fb, null);
								}
								CodeAccessPermission.RevertAssert();
							}
						}
					}
				}
#endif // NET_4_0
			}

#if !STATIC_COMPILER
			internal static class JniProxyBuilder
			{
				private readonly static ModuleBuilder mod;
				private static int count;

				static JniProxyBuilder()
				{
					mod = DynamicClassLoader.CreateJniProxyModuleBuilder();
					CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(JavaModuleAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
					mod.SetCustomAttribute(cab);
				}

				internal static void Generate(DynamicTypeWrapper.FinishContext context, CodeEmitter ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args)
				{
					TypeBuilder tb = mod.DefineType("__<jni>" + System.Threading.Interlocked.Increment(ref count), TypeAttributes.Public | TypeAttributes.Class);
					int instance = m.IsStatic ? 0 : 1;
					Type[] argTypes = new Type[args.Length + instance + 1];
					if (instance != 0)
					{
						argTypes[0] = typeof(object);
					}
					for (int i = 0; i < args.Length; i++)
					{
						// NOTE we take a shortcut here by assuming that all "special" types (i.e. ghost or value types)
						// are public and so we can get away with replacing all other types with object.
						argTypes[i + instance] = !args[i].IsUnloadable && (args[i].IsPrimitive || args[i].IsGhost || args[i].IsNonPrimitiveValueType) ? args[i].TypeAsSignatureType : typeof(object);
					}
					argTypes[argTypes.Length - 1] = CoreClasses.ikvm.@@internal.CallerID.Wrapper.TypeAsSignatureType;
					Type retType = !mw.ReturnType.IsUnloadable && (mw.ReturnType.IsPrimitive || mw.ReturnType.IsGhost || mw.ReturnType.IsNonPrimitiveValueType) ? mw.ReturnType.TypeAsSignatureType : typeof(object);
					MethodBuilder mb = tb.DefineMethod("method", MethodAttributes.Public | MethodAttributes.Static, retType, argTypes);
					AttributeHelper.HideFromJava(mb);
					CodeEmitter ilgen = CodeEmitter.Create(mb);
					JniBuilder.Generate(context, ilgen, wrapper, mw, tb, classFile, m, args, true);
					ilgen.DoEmit();
					tb.CreateType();
					for (int i = 0; i < argTypes.Length - 1; i++)
					{
						ilGenerator.EmitLdarg(i);
					}
					context.EmitCallerID(ilGenerator, m.IsLambdaFormCompiled);
					ilGenerator.Emit(OpCodes.Call, mb);
					if (!mw.ReturnType.IsUnloadable && !mw.ReturnType.IsPrimitive && !mw.ReturnType.IsGhost && !mw.ReturnType.IsNonPrimitiveValueType)
					{
						ilGenerator.Emit(OpCodes.Castclass, mw.ReturnType.TypeAsSignatureType);
					}
					ilGenerator.Emit(OpCodes.Ret);
				}
			}
#endif // !STATIC_COMPILER

			private static class JniBuilder
			{
#if STATIC_COMPILER
				private static readonly Type localRefStructType = StaticCompiler.GetRuntimeType("IKVM.Runtime.JNI+Frame");
#elif FIRST_PASS
				private static readonly Type localRefStructType = null;
#else
				private static readonly Type localRefStructType = JVM.LoadType(typeof(IKVM.Runtime.JNI.Frame));
#endif
				private static readonly MethodInfo jniFuncPtrMethod = localRefStructType.GetMethod("GetFuncPtr");
				private static readonly MethodInfo enterLocalRefStruct = localRefStructType.GetMethod("Enter");
				private static readonly MethodInfo leaveLocalRefStruct = localRefStructType.GetMethod("Leave");
				private static readonly MethodInfo makeLocalRef = localRefStructType.GetMethod("MakeLocalRef");
				private static readonly MethodInfo unwrapLocalRef = localRefStructType.GetMethod("UnwrapLocalRef");
				private static readonly MethodInfo writeLine = JVM.Import(typeof(Console)).GetMethod("WriteLine", new Type[] { Types.Object });
				private static readonly MethodInfo monitorEnter = JVM.Import(typeof(System.Threading.Monitor)).GetMethod("Enter", new Type[] { Types.Object });
				private static readonly MethodInfo monitorExit = JVM.Import(typeof(System.Threading.Monitor)).GetMethod("Exit", new Type[] { Types.Object });

				internal static void Generate(DynamicTypeWrapper.FinishContext context, CodeEmitter ilGenerator, DynamicTypeWrapper wrapper, MethodWrapper mw, TypeBuilder typeBuilder, ClassFile classFile, ClassFile.Method m, TypeWrapper[] args, bool thruProxy)
				{
					CodeEmitterLocal syncObject = null;
					if (m.IsSynchronized && m.IsStatic)
					{
						wrapper.EmitClassLiteral(ilGenerator);
						ilGenerator.Emit(OpCodes.Dup);
						syncObject = ilGenerator.DeclareLocal(Types.Object);
						ilGenerator.Emit(OpCodes.Stloc, syncObject);
						ilGenerator.Emit(OpCodes.Call, monitorEnter);
						ilGenerator.BeginExceptionBlock();
					}
					string sig = m.Signature.Replace('.', '/');
					// TODO use/unify JNI.METHOD_PTR_FIELD_PREFIX
					FieldBuilder methodPtr = typeBuilder.DefineField("__<jniptr>" + m.Name + sig, Types.IntPtr, FieldAttributes.Static | FieldAttributes.PrivateScope);
					CodeEmitterLocal localRefStruct = ilGenerator.DeclareLocal(localRefStructType);
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					ilGenerator.Emit(OpCodes.Initobj, localRefStructType);
					ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
					CodeEmitterLabel oklabel = ilGenerator.DefineLabel();
					ilGenerator.EmitBrtrue(oklabel);
					if (thruProxy)
					{
						ilGenerator.EmitLdarg(args.Length + (mw.IsStatic ? 0 : 1));
					}
					else
					{
						context.EmitCallerID(ilGenerator, m.IsLambdaFormCompiled);
					}
					ilGenerator.Emit(OpCodes.Ldstr, classFile.Name.Replace('.', '/'));
					ilGenerator.Emit(OpCodes.Ldstr, m.Name);
					ilGenerator.Emit(OpCodes.Ldstr, sig);
					ilGenerator.Emit(OpCodes.Call, jniFuncPtrMethod);
					ilGenerator.Emit(OpCodes.Stsfld, methodPtr);
					ilGenerator.MarkLabel(oklabel);
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					if (thruProxy)
					{
						ilGenerator.EmitLdarg(args.Length + (mw.IsStatic ? 0 : 1));
					}
					else
					{
						context.EmitCallerID(ilGenerator, m.IsLambdaFormCompiled);
					}
					ilGenerator.Emit(OpCodes.Call, enterLocalRefStruct);
					CodeEmitterLocal jnienv = ilGenerator.DeclareLocal(Types.IntPtr);
					ilGenerator.Emit(OpCodes.Stloc, jnienv);
					ilGenerator.BeginExceptionBlock();
					TypeWrapper retTypeWrapper = mw.ReturnType;
					if (retTypeWrapper.IsUnloadable || !retTypeWrapper.IsPrimitive)
					{
						// this one is for use after we return from "calli"
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					}
					ilGenerator.Emit(OpCodes.Ldloc, jnienv);
					Type[] modargs = new Type[args.Length + 2];
					modargs[0] = Types.IntPtr;
					modargs[1] = Types.IntPtr;
					for (int i = 0; i < args.Length; i++)
					{
						modargs[i + 2] = args[i].TypeAsSignatureType;
					}
					int add = 0;
					if (!m.IsStatic)
					{
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						ilGenerator.Emit(OpCodes.Ldarg_0);
						ilGenerator.Emit(OpCodes.Call, makeLocalRef);
						add = 1;
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
						wrapper.EmitClassLiteral(ilGenerator);
						ilGenerator.Emit(OpCodes.Call, makeLocalRef);
					}
					for (int j = 0; j < args.Length; j++)
					{
						if (args[j].IsUnloadable || !args[j].IsPrimitive)
						{
							ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
							if (!args[j].IsUnloadable && args[j].IsNonPrimitiveValueType)
							{
								ilGenerator.EmitLdarg(j + add);
								args[j].EmitBox(ilGenerator);
							}
							else if (!args[j].IsUnloadable && args[j].IsGhost)
							{
								ilGenerator.EmitLdarga(j + add);
								ilGenerator.Emit(OpCodes.Ldfld, args[j].GhostRefField);
							}
							else
							{
								ilGenerator.EmitLdarg(j + add);
							}
							ilGenerator.Emit(OpCodes.Call, makeLocalRef);
							modargs[j + 2] = Types.IntPtr;
						}
						else
						{
							ilGenerator.EmitLdarg(j + add);
						}
					}
					ilGenerator.Emit(OpCodes.Ldsfld, methodPtr);
					Type realRetType;
					if (retTypeWrapper == PrimitiveTypeWrapper.BOOLEAN)
					{
						realRetType = Types.Byte;
					}
					else if (retTypeWrapper.IsPrimitive)
					{
						realRetType = retTypeWrapper.TypeAsSignatureType;
					}
					else
					{
						realRetType = Types.IntPtr;
					}
					ilGenerator.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.StdCall, realRetType, modargs);
					CodeEmitterLocal retValue = null;
					if (retTypeWrapper != PrimitiveTypeWrapper.VOID)
					{
						if (retTypeWrapper.IsUnloadable)
						{
							ilGenerator.Emit(OpCodes.Call, unwrapLocalRef);
						}
						else if (!retTypeWrapper.IsPrimitive)
						{
							ilGenerator.Emit(OpCodes.Call, unwrapLocalRef);
							if (retTypeWrapper.IsNonPrimitiveValueType)
							{
								retTypeWrapper.EmitUnbox(ilGenerator);
							}
							else if (retTypeWrapper.IsGhost)
							{
								CodeEmitterLocal ghost = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
								CodeEmitterLocal obj = ilGenerator.DeclareLocal(Types.Object);
								ilGenerator.Emit(OpCodes.Stloc, obj);
								ilGenerator.Emit(OpCodes.Ldloca, ghost);
								ilGenerator.Emit(OpCodes.Ldloc, obj);
								ilGenerator.Emit(OpCodes.Stfld, retTypeWrapper.GhostRefField);
								ilGenerator.Emit(OpCodes.Ldloc, ghost);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsTBD);
							}
						}
						retValue = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
						ilGenerator.Emit(OpCodes.Stloc, retValue);
					}
					CodeEmitterLabel retLabel = ilGenerator.DefineLabel();
					ilGenerator.EmitLeave(retLabel);
					ilGenerator.BeginCatchBlock(Types.Object);
					ilGenerator.Emit(OpCodes.Ldstr, "*** exception in native code ***");
					ilGenerator.Emit(OpCodes.Call, writeLine);
					ilGenerator.Emit(OpCodes.Call, writeLine);
					ilGenerator.Emit(OpCodes.Rethrow);
					ilGenerator.BeginFinallyBlock();
					ilGenerator.Emit(OpCodes.Ldloca, localRefStruct);
					ilGenerator.Emit(OpCodes.Call, leaveLocalRefStruct);
					ilGenerator.Emit(OpCodes.Endfinally);
					ilGenerator.EndExceptionBlock();
					if (m.IsSynchronized && m.IsStatic)
					{
						ilGenerator.BeginFinallyBlock();
						ilGenerator.Emit(OpCodes.Ldloc, syncObject);
						ilGenerator.Emit(OpCodes.Call, monitorExit);
						ilGenerator.Emit(OpCodes.Endfinally);
						ilGenerator.EndExceptionBlock();
					}
					ilGenerator.MarkLabel(retLabel);
					if (retTypeWrapper != PrimitiveTypeWrapper.VOID)
					{
						ilGenerator.Emit(OpCodes.Ldloc, retValue);
					}
					ilGenerator.Emit(OpCodes.Ret);
				}
			}

			private static class TraceHelper
			{
#if STATIC_COMPILER
				private readonly static MethodInfo methodIsTracedMethod = JVM.LoadType(typeof(Tracer)).GetMethod("IsTracedMethod");
#endif
				private readonly static MethodInfo methodMethodInfo = JVM.LoadType(typeof(Tracer)).GetMethod("MethodInfo");

				internal static void EmitMethodTrace(CodeEmitter ilgen, string tracemessage)
				{
					if (Tracer.IsTracedMethod(tracemessage))
					{
						CodeEmitterLabel label = ilgen.DefineLabel();
#if STATIC_COMPILER
						// TODO this should be a boolean field test instead of a call to Tracer.IsTracedMessage
						ilgen.Emit(OpCodes.Ldstr, tracemessage);
						ilgen.Emit(OpCodes.Call, methodIsTracedMethod);
						ilgen.EmitBrfalse(label);
#endif
						ilgen.Emit(OpCodes.Ldstr, tracemessage);
						ilgen.Emit(OpCodes.Call, methodMethodInfo);
						ilgen.MarkLabel(label);
					}
				}
			}

#if STATIC_COMPILER
			private void EmitCallerIDStub(MethodWrapper mw, string[] parameterNames)
			{
				// we don't need to support custom modifiers, because there aren't any callerid methods that have parameter types that require a custom modifier
				TypeWrapper[] parameters = mw.GetParameters();
				Type[] parameterTypes = new Type[parameters.Length];
				for (int i = 0; i < parameterTypes.Length; i++)
				{
					parameterTypes[i] = parameters[i].TypeAsSignatureType;
				}
				MethodAttributes attribs = MethodAttributes.HideBySig;
				int argcount = parameterTypes.Length;
				if (mw.IsStatic)
				{
					attribs |= MethodAttributes.Static;
				}
				else
				{
					argcount++;
				}
				if (mw.IsPublic)
				{
					attribs |= MethodAttributes.Public;
				}
				else if (mw.IsProtected)
				{
					attribs |= MethodAttributes.FamORAssem;
				}
				else if (mw.IsPrivate)
				{
					attribs |= MethodAttributes.Private;
				}
				else
				{
					attribs |= MethodAttributes.Assembly;
				}
				MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, attribs, mw.ReturnType.TypeAsSignatureType, parameterTypes);
				AttributeHelper.HideFromJava(mb);
				mb.SetImplementationFlags(MethodImplAttributes.NoInlining);
				CodeEmitter ilgen = CodeEmitter.Create(mb);
				for (int i = 0; i < argcount; i++)
				{
					if (parameterNames != null && (mw.IsStatic || i > 0))
					{
						ParameterBuilder pb = mb.DefineParameter(mw.IsStatic ? i + 1 : i, ParameterAttributes.None, parameterNames[mw.IsStatic ? i : i - 1]);
						if (i == argcount - 1 && (mw.Modifiers & Modifiers.VarArgs) != 0)
						{
							AttributeHelper.SetParamArrayAttribute(pb);
						}
					}
					ilgen.EmitLdarg(i);
				}
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Ldc_I4_0);
				ilgen.Emit(OpCodes.Newobj, JVM.Import(typeof(StackFrame)).GetConstructor(new Type[] { Types.Int32, Types.Boolean }));
				MethodWrapper callerID = CoreClasses.ikvm.@@internal.CallerID.Wrapper.GetMethodWrapper("create", "(Lcli.System.Diagnostics.StackFrame;)Likvm.internal.CallerID;", false);
				callerID.Link();
				callerID.EmitCall(ilgen);
				if (mw.IsStatic)
				{
					mw.EmitCall(ilgen);
				}
				else
				{
					mw.EmitCallvirt(ilgen);
				}
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
			}
#endif // STATIC_COMPILER

			private void ImplementInterfaces(TypeWrapper[] interfaces, List<TypeWrapper> interfaceList)
			{
				foreach (TypeWrapper iface in interfaces)
				{
					if (!interfaceList.Contains(iface))
					{
						interfaceList.Add(iface);
						if (!iface.IsAccessibleFrom(wrapper))
						{
							continue;
						}
						// NOTE we're using TypeAsBaseType for the interfaces!
						typeBuilder.AddInterfaceImplementation(iface.TypeAsBaseType);
#if STATIC_COMPILER
						if (!wrapper.IsInterface)
						{
							// look for "magic" interfaces that imply a .NET interface
							if (iface.GetClassLoader() == CoreClasses.java.lang.Object.Wrapper.GetClassLoader())
							{
								if (iface.Name == "java.lang.Iterable"
									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(JVM.Import(typeof(System.Collections.IEnumerable)))))
								{
									TypeWrapper enumeratorType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast("ikvm.lang.IterableEnumerator");
									if (enumeratorType != null)
									{
										typeBuilder.AddInterfaceImplementation(JVM.Import(typeof(System.Collections.IEnumerable)));
										// FXBUG we're using the same method name as the C# compiler here because both the .NET and Mono implementations of Xml serialization depend on this method name
										MethodBuilder mb = typeBuilder.DefineMethod("System.Collections.IEnumerable.GetEnumerator", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, JVM.Import(typeof(System.Collections.IEnumerator)), Type.EmptyTypes);
										AttributeHelper.HideFromJava(mb);
										typeBuilder.DefineMethodOverride(mb, JVM.Import(typeof(System.Collections.IEnumerable)).GetMethod("GetEnumerator"));
										CodeEmitter ilgen = CodeEmitter.Create(mb);
										ilgen.Emit(OpCodes.Ldarg_0);
										MethodWrapper mw = enumeratorType.GetMethodWrapper("<init>", "(Ljava.lang.Iterable;)V", false);
										mw.Link();
										mw.EmitNewobj(ilgen);
										ilgen.Emit(OpCodes.Ret);
										ilgen.DoEmit();
									}
								}
							}
							// if we implement a ghost interface, add an implicit conversion to the ghost reference value type
							if (iface.IsGhost && wrapper.IsPublic)
							{
								MethodBuilder mb = typeBuilder.DefineMethod("op_Implicit", MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, iface.TypeAsSignatureType, new Type[] { wrapper.TypeAsSignatureType });
								AttributeHelper.HideFromJava(mb);
								CodeEmitter ilgen = CodeEmitter.Create(mb);
								CodeEmitterLocal local = ilgen.DeclareLocal(iface.TypeAsSignatureType);
								ilgen.Emit(OpCodes.Ldloca, local);
								ilgen.Emit(OpCodes.Ldarg_0);
								ilgen.Emit(OpCodes.Stfld, iface.GhostRefField);
								ilgen.Emit(OpCodes.Ldloca, local);
								ilgen.Emit(OpCodes.Ldobj, iface.TypeAsSignatureType);
								ilgen.Emit(OpCodes.Ret);
								ilgen.DoEmit();
							}
						}
#endif // STATIC_COMPILER
						// NOTE we're recursively "implementing" all interfaces that we inherit from the interfaces we implement.
						// The C# compiler also does this and the Compact Framework requires it.
						ImplementInterfaces(iface.Interfaces, interfaceList);
					}
				}
			}

			private void AddUnsupportedAbstractMethods()
			{
				foreach (MethodBase mb in wrapper.BaseTypeWrapper.TypeAsBaseType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
				{
					if (DotNetTypeWrapper.IsUnsupportedAbstractMethod(mb))
					{
						GenerateUnsupportedAbstractMethodStub(mb);
					}
				}
				Dictionary<MethodBase, MethodBase> h = new Dictionary<MethodBase, MethodBase>();
				TypeWrapper tw = wrapper;
				while (tw != null)
				{
					foreach (TypeWrapper iface in tw.Interfaces)
					{
						foreach (MethodBase mb in iface.TypeAsBaseType.GetMethods(BindingFlags.Public | BindingFlags.Instance))
						{
							if (!h.ContainsKey(mb))
							{
								h.Add(mb, mb);
								if (DotNetTypeWrapper.IsUnsupportedAbstractMethod(mb))
								{
									GenerateUnsupportedAbstractMethodStub(mb);
								}
							}
						}
					}
					tw = tw.BaseTypeWrapper;
				}
			}

			private void GenerateUnsupportedAbstractMethodStub(MethodBase mb)
			{
				ParameterInfo[] parameters = mb.GetParameters();
				Type[] parameterTypes = new Type[parameters.Length];
				for (int i = 0; i < parameters.Length; i++)
				{
					parameterTypes[i] = parameters[i].ParameterType;
				}
				MethodAttributes attr = MethodAttributes.NewSlot | MethodAttributes.Virtual | MethodAttributes.Private;
				MethodBuilder m = typeBuilder.DefineMethod("__<unsupported>" + mb.DeclaringType.FullName + "/" + mb.Name, attr, ((MethodInfo)mb).ReturnType, parameterTypes);
				if (mb.IsGenericMethodDefinition)
				{
					CopyGenericArguments(mb, m);
				}
				CodeEmitter ilgen = CodeEmitter.Create(m);
				ilgen.EmitThrow("java.lang.AbstractMethodError", "Method " + mb.DeclaringType.FullName + "." + mb.Name + " is unsupported by IKVM.");
				ilgen.DoEmit();
				typeBuilder.DefineMethodOverride(m, (MethodInfo)mb);
			}

			private static void CopyGenericArguments(MethodBase mi, MethodBuilder mb)
			{
				Type[] genericParameters = mi.GetGenericArguments();
				string[] genParamNames = new string[genericParameters.Length];
				for (int i = 0; i < genParamNames.Length; i++)
				{
					genParamNames[i] = genericParameters[i].Name;
				}
				GenericTypeParameterBuilder[] genParamBuilders = mb.DefineGenericParameters(genParamNames);
				for (int i = 0; i < genParamBuilders.Length; i++)
				{
					// NOTE apparently we don't need to set the interface constraints
					// (and if we do, it fails for some reason)
					if (genericParameters[i].BaseType != Types.Object)
					{
						genParamBuilders[i].SetBaseTypeConstraint(genericParameters[i].BaseType);
					}
					genParamBuilders[i].SetGenericParameterAttributes(genericParameters[i].GenericParameterAttributes);
				}
			}

			private void CompileConstructorBody(FinishContext context, CodeEmitter ilGenerator, int methodIndex)
			{
				MethodWrapper[] methods = wrapper.GetMethods();
				ClassFile.Method m = classFile.Methods[methodIndex];
				TraceHelper.EmitMethodTrace(ilGenerator, classFile.Name + "." + m.Name + m.Signature);
#if STATIC_COMPILER
				// do we have an implementation in map.xml?
				if (wrapper.EmitMapXmlMethodPrologueAndOrBody(ilGenerator, classFile, m))
				{
					ilGenerator.DoEmit();
					return;
				}
#endif
				bool nonLeaf = false;
				Compiler.Compile(context, host, wrapper, methods[methodIndex], classFile, m, ilGenerator, ref nonLeaf);
				ilGenerator.DoEmit();
#if STATIC_COMPILER
				ilGenerator.EmitLineNumberTable((MethodBuilder)methods[methodIndex].GetMethod());
#else // STATIC_COMPILER
				byte[] linenumbers = ilGenerator.GetLineNumberTable();
				if (linenumbers != null)
				{
					if (wrapper.lineNumberTables == null)
					{
						wrapper.lineNumberTables = new byte[methods.Length][];
					}
					wrapper.lineNumberTables[methodIndex] = linenumbers;
				}
#endif // STATIC_COMPILER
			}

			private static bool IsCompatibleArgList(TypeWrapper[] caller, TypeWrapper[] callee)
			{
				if (caller.Length == callee.Length)
				{
					for (int i = 0; i < caller.Length; i++)
					{
						if (caller[i].IsUnloadable || callee[i].IsUnloadable)
						{
							return false;
						}
						if (!caller[i].IsAssignableTo(callee[i]))
						{
							return false;
						}
					}
					return true;
				}
				return false;
			}

			private void EmitCallerIDInitialization(CodeEmitter ilGenerator, FieldInfo callerIDField)
			{
				TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
				if (tw.InternalsVisibleTo(wrapper))
				{
					MethodWrapper create = tw.GetMethodWrapper("create", "(Lcli.System.RuntimeTypeHandle;)Likvm.internal.CallerID;", false);
					ilGenerator.Emit(OpCodes.Ldtoken, this.typeBuilder);
					create.Link();
					create.EmitCall(ilGenerator);
				}
				else
				{
					RegisterNestedTypeBuilder(EmitCreateCallerID(typeBuilder, ilGenerator));
				}
				ilGenerator.Emit(OpCodes.Stsfld, callerIDField);
			}

			internal static TypeBuilder EmitCreateCallerID(TypeBuilder typeBuilder, CodeEmitter ilGenerator)
			{
				TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
				TypeBuilder typeCallerID = typeBuilder.DefineNestedType(NestedTypeName.CallerID, TypeAttributes.Sealed | TypeAttributes.NestedPrivate, tw.TypeAsBaseType);
				MethodBuilder cb = ReflectUtil.DefineConstructor(typeCallerID, MethodAttributes.Assembly, null);
				CodeEmitter ctorIlgen = CodeEmitter.Create(cb);
				ctorIlgen.Emit(OpCodes.Ldarg_0);
				MethodWrapper mw = tw.GetMethodWrapper("<init>", "()V", false);
				mw.Link();
				mw.EmitCall(ctorIlgen);
				ctorIlgen.Emit(OpCodes.Ret);
				ctorIlgen.DoEmit();
				ilGenerator.Emit(OpCodes.Newobj, cb);
				return typeCallerID;
			}

			private void EmitConstantValueInitialization(FieldWrapper[] fields, CodeEmitter ilGenerator)
			{
				ClassFile.Field[] flds = classFile.Fields;
				for (int i = 0; i < flds.Length; i++)
				{
					ClassFile.Field f = flds[i];
					if (f.IsStatic && !f.IsFinal)
					{
						object constant = f.ConstantValue;
						if (constant != null)
						{
							if (constant is int)
							{
								ilGenerator.EmitLdc_I4((int)constant);
							}
							else if (constant is bool)
							{
								ilGenerator.EmitLdc_I4((bool)constant ? 1 : 0);
							}
							else if (constant is byte)
							{
								ilGenerator.EmitLdc_I4((byte)constant);
							}
							else if (constant is char)
							{
								ilGenerator.EmitLdc_I4((char)constant);
							}
							else if (constant is short)
							{
								ilGenerator.EmitLdc_I4((short)constant);
							}
							else if (constant is long)
							{
								ilGenerator.EmitLdc_I8((long)constant);
							}
							else if (constant is double)
							{
								ilGenerator.EmitLdc_R8((double)constant);
							}
							else if (constant is float)
							{
								ilGenerator.EmitLdc_R4((float)constant);
							}
							else if (constant is string)
							{
								ilGenerator.Emit(OpCodes.Ldstr, (string)constant);
							}
							else
							{
								throw new InvalidOperationException();
							}
							fields[i].EmitSet(ilGenerator);
						}
					}
				}
			}

			internal MethodBuilder DefineThreadLocalType()
			{
				TypeWrapper threadLocal = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.IntrinsicThreadLocal");
				int id = nestedTypeBuilders == null ? 0 : nestedTypeBuilders.Count;
				TypeBuilder tb = typeBuilder.DefineNestedType(NestedTypeName.ThreadLocal + id, TypeAttributes.NestedPrivate | TypeAttributes.Sealed, threadLocal.TypeAsBaseType);
				FieldBuilder fb = tb.DefineField("field", Types.Object, FieldAttributes.Private | FieldAttributes.Static);
				fb.SetCustomAttribute(new CustomAttributeBuilder(JVM.Import(typeof(ThreadStaticAttribute)).GetConstructor(Type.EmptyTypes), new object[0]));
				MethodBuilder mbGet = tb.DefineMethod("get", MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final, Types.Object, Type.EmptyTypes);
				ILGenerator ilgen = mbGet.GetILGenerator();
				ilgen.Emit(OpCodes.Ldsfld, fb);
				ilgen.Emit(OpCodes.Ret);
				MethodBuilder mbSet = tb.DefineMethod("set", MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final, null, new Type[] { Types.Object });
				ilgen = mbSet.GetILGenerator();
				ilgen.Emit(OpCodes.Ldarg_1);
				ilgen.Emit(OpCodes.Stsfld, fb);
				ilgen.Emit(OpCodes.Ret);
				MethodBuilder cb = ReflectUtil.DefineConstructor(tb, MethodAttributes.Assembly, Type.EmptyTypes);
				CodeEmitter ctorilgen = CodeEmitter.Create(cb);
				ctorilgen.Emit(OpCodes.Ldarg_0);
				MethodWrapper basector = threadLocal.GetMethodWrapper("<init>", "()V", false);
				basector.Link();
				basector.EmitCall(ctorilgen);
				ctorilgen.Emit(OpCodes.Ret);
				ctorilgen.DoEmit();
				RegisterNestedTypeBuilder(tb);
				return cb;
			}

			internal MethodBuilder GetAtomicReferenceFieldUpdater(FieldWrapper field)
			{
				if (arfuMap == null)
				{
					arfuMap = new Dictionary<FieldWrapper, MethodBuilder>();
				}
				MethodBuilder cb;
				if (!arfuMap.TryGetValue(field, out cb))
				{
					TypeWrapper arfuTypeWrapper = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.IntrinsicAtomicReferenceFieldUpdater");
					TypeBuilder tb = typeBuilder.DefineNestedType(NestedTypeName.AtomicReferenceFieldUpdater + arfuMap.Count, TypeAttributes.NestedPrivate | TypeAttributes.Sealed, arfuTypeWrapper.TypeAsBaseType);
					AtomicReferenceFieldUpdaterEmitter.EmitImpl(tb, field.GetField());
					cb = ReflectUtil.DefineConstructor(tb, MethodAttributes.Assembly, Type.EmptyTypes);
					arfuMap.Add(field, cb);
					CodeEmitter ctorilgen = CodeEmitter.Create(cb);
					ctorilgen.Emit(OpCodes.Ldarg_0);
					MethodWrapper basector = arfuTypeWrapper.GetMethodWrapper("<init>", "()V", false);
					basector.Link();
					basector.EmitCall(ctorilgen);
					ctorilgen.Emit(OpCodes.Ret);
					ctorilgen.DoEmit();
					RegisterNestedTypeBuilder(tb);
				}
				return cb;
			}

			internal TypeBuilder DefineIndyCallSiteType()
			{
				int id = nestedTypeBuilders == null ? 0 : nestedTypeBuilders.Count;
				TypeBuilder tb = typeBuilder.DefineNestedType(NestedTypeName.IndyCallSite + id, TypeAttributes.NestedPrivate | TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit);
				RegisterNestedTypeBuilder(tb);
				return tb;
			}

			internal TypeBuilder DefineMethodHandleConstantType(int index)
			{
				TypeBuilder tb = typeBuilder.DefineNestedType(NestedTypeName.MethodHandleConstant + index, TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit); ;
				RegisterNestedTypeBuilder(tb);
				return tb;
			}

			internal TypeBuilder DefineMethodTypeConstantType(int index)
			{
				TypeBuilder tb = typeBuilder.DefineNestedType(NestedTypeName.MethodTypeConstant + index, TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit);
				RegisterNestedTypeBuilder(tb);
				return tb;
			}

			// this is used to define intrinsified anonymous classes (in the Unsafe.defineAnonymousClass() sense)
			internal TypeBuilder DefineAnonymousClass()
			{
				int id = nestedTypeBuilders == null ? 0 : nestedTypeBuilders.Count;
				TypeBuilder tb = typeBuilder.DefineNestedType(NestedTypeName.IntrinsifiedAnonymousClass + id, TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.SpecialName | TypeAttributes.BeforeFieldInit);
				RegisterNestedTypeBuilder(tb);
				return tb;
			}

			private MethodBuilder DefineHelperMethod(string name, Type returnType, Type[] parameterTypes)
			{
#if STATIC_COMPILER
				// FXBUG csc.exe doesn't like non-public methods in interfaces, so for public interfaces we move
				// the helper methods into a nested type.
				if (wrapper.IsPublic && wrapper.IsInterface && wrapper.classLoader.WorkaroundInterfacePrivateMethods)
				{
					if (interfaceHelperMethodsTypeBuilder == null)
					{
						interfaceHelperMethodsTypeBuilder = typeBuilder.DefineNestedType(NestedTypeName.InterfaceHelperMethods, TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit);
						RegisterNestedTypeBuilder(interfaceHelperMethodsTypeBuilder);
					}
					return interfaceHelperMethodsTypeBuilder.DefineMethod(name, MethodAttributes.PrivateScope | MethodAttributes.Static, returnType, parameterTypes);
				}
#endif
				return typeBuilder.DefineMethod(name, MethodAttributes.PrivateScope | MethodAttributes.Static, returnType, parameterTypes);
			}

			internal MethodBuilder DefineMethodHandleDispatchStub(Type returnType, Type[] parameterTypes)
			{
				return DefineHelperMethod("__<>MHC", returnType, parameterTypes);
			}

			internal FieldBuilder DefineMethodHandleInvokeCacheField(Type fieldType)
			{
				return typeBuilder.DefineField("__<>invokeCache", fieldType, FieldAttributes.Static | FieldAttributes.PrivateScope);
			}

			internal FieldBuilder DefineDynamicMethodHandleCacheField()
			{
				return typeBuilder.DefineField("__<>dynamicMethodHandleCache", CoreClasses.java.lang.invoke.MethodHandle.Wrapper.TypeAsSignatureType, FieldAttributes.Static | FieldAttributes.PrivateScope);
			}

			internal FieldBuilder DefineDynamicMethodTypeCacheField()
			{
				return typeBuilder.DefineField("__<>dynamicMethodTypeCache", CoreClasses.java.lang.invoke.MethodType.Wrapper.TypeAsSignatureType, FieldAttributes.Static | FieldAttributes.PrivateScope);
			}

			internal MethodBuilder DefineDelegateInvokeErrorStub(Type returnType, Type[] parameterTypes)
			{
				return DefineHelperMethod("__<>", returnType, parameterTypes);
			}

			internal MethodInfo GetInvokeSpecialStub(MethodWrapper method)
			{
				if (invokespecialstubcache == null)
				{
					invokespecialstubcache = new Dictionary<MethodKey, MethodInfo>();
				}
				MethodKey key = new MethodKey(method.DeclaringType.Name, method.Name, method.Signature);
				MethodInfo mi;
				if (!invokespecialstubcache.TryGetValue(key, out mi))
				{
					DefineMethodHelper dmh = method.GetDefineMethodHelper();
					MethodBuilder stub = dmh.DefineMethod(wrapper, typeBuilder, "__<>", MethodAttributes.PrivateScope);
					CodeEmitter ilgen = CodeEmitter.Create(stub);
					ilgen.Emit(OpCodes.Ldarg_0);
					for (int i = 1; i <= dmh.ParameterCount; i++)
					{
						ilgen.EmitLdarg(i);
					}
					method.EmitCall(ilgen);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();
					invokespecialstubcache[key] = stub;
					mi = stub;
				}
				return mi;
			}

#if !STATIC_COMPILER
			internal void EmitLiveObjectLoad(CodeEmitter ilgen, object value)
			{
				if (liveObjects == null)
				{
					liveObjects = new List<object>();
				}
				FieldInfo fi = TypeBuilder.GetField(typeof(IKVM.Runtime.LiveObjectHolder<>).MakeGenericType(typeBuilder), typeof(IKVM.Runtime.LiveObjectHolder<>).GetField("values", BindingFlags.Static | BindingFlags.Public));
				ilgen.Emit(OpCodes.Ldsfld, fi);
				ilgen.EmitLdc_I4(liveObjects.Count);
				ilgen.Emit(OpCodes.Ldelem_Ref);
				liveObjects.Add(value);
			}
#endif
		}

		private static bool CheckRequireOverrideStub(MethodWrapper mw1, MethodWrapper mw2)
		{
			// TODO this is too late to generate LinkageErrors so we need to figure this out earlier
			if (!TypesMatchForOverride(mw1.ReturnType, mw2.ReturnType))
			{
				return true;
			}
			TypeWrapper[] args1 = mw1.GetParameters();
			TypeWrapper[] args2 = mw2.GetParameters();
			for (int i = 0; i < args1.Length; i++)
			{
				if (!TypesMatchForOverride(args1[i], args2[i]))
				{
					return true;
				}
			}
			return false;
		}

		private static bool TypesMatchForOverride(TypeWrapper tw1, TypeWrapper tw2)
		{
			if (tw1 == tw2)
			{
				return true;
			}
			else if (tw1.IsUnloadable && tw2.IsUnloadable)
			{
				return ((UnloadableTypeWrapper)tw1).CustomModifier == ((UnloadableTypeWrapper)tw2).CustomModifier;
			}
			else
			{
				return false;
			}
		}

		private void GenerateOverrideStub(TypeBuilder typeBuilder, MethodWrapper baseMethod, MethodInfo target, MethodWrapper targetMethod)
		{
			Debug.Assert(!baseMethod.HasCallerID);

			MethodBuilder overrideStub = baseMethod.GetDefineMethodHelper().DefineMethod(this, typeBuilder, "__<overridestub>" + baseMethod.DeclaringType.Name + "::" + baseMethod.Name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final);
			typeBuilder.DefineMethodOverride(overrideStub, (MethodInfo)baseMethod.GetMethod());

			TypeWrapper[] stubargs = baseMethod.GetParameters();
			TypeWrapper[] targetArgs = targetMethod.GetParameters();
			CodeEmitter ilgen = CodeEmitter.Create(overrideStub);
			ilgen.Emit(OpCodes.Ldarg_0);
			for (int i = 0; i < targetArgs.Length; i++)
			{
				ilgen.EmitLdarg(i + 1);
				ConvertStubArg(stubargs[i], targetArgs[i], ilgen);
			}
			if (target != null)
			{
				ilgen.Emit(OpCodes.Callvirt, target);
			}
			else
			{
				targetMethod.EmitCallvirt(ilgen);
			}
			ConvertStubArg(targetMethod.ReturnType, baseMethod.ReturnType, ilgen);
			ilgen.Emit(OpCodes.Ret);
			ilgen.DoEmit();
		}

		private static void ConvertStubArg(TypeWrapper src, TypeWrapper dst, CodeEmitter ilgen)
		{
			if (src != dst)
			{
				if (dst.IsUnloadable)
				{
					if (!src.IsUnloadable && (src.IsGhost || src.IsNonPrimitiveValueType))
					{
						src.EmitConvSignatureTypeToStackType(ilgen);
					}
				}
				else if (dst.IsGhost || dst.IsNonPrimitiveValueType)
				{
					dst.EmitConvStackTypeToSignatureType(ilgen, null);
				}
				else
				{
					dst.EmitCheckcast(ilgen);
				}
			}
		}

		private static void GetParameterNamesFromMP(ClassFile.Method m, string[] parameterNames)
		{
			MethodParametersEntry[] methodParameters = m.MethodParameters;
			if (methodParameters != null)
			{
				for (int i = 0, count = Math.Min(parameterNames.Length, methodParameters.Length); i < count; i++)
				{
					if (parameterNames[i] == null)
					{
						parameterNames[i] = methodParameters[i].name;
					}
				}
			}
		}

		protected static void GetParameterNamesFromLVT(ClassFile.Method m, string[] parameterNames)
		{
			ClassFile.Method.LocalVariableTableEntry[] localVars = m.LocalVariableTableAttribute;
			if (localVars != null)
			{
				for (int i = m.IsStatic ? 0 : 1, pos = 0; i < m.ArgMap.Length; i++)
				{
					// skip double & long fillers
					if (m.ArgMap[i] != -1)
					{
						if (parameterNames[pos] == null)
						{
							for (int j = 0; j < localVars.Length; j++)
							{
								if (localVars[j].index == i)
								{
									parameterNames[pos] = localVars[j].name;
									break;
								}
							}
						}
						pos++;
					}
				}
			}
		}

		protected static void GetParameterNamesFromSig(string sig, string[] parameterNames)
		{
			List<string> names = new List<string>();
			for (int i = 1; sig[i] != ')'; i++)
			{
				if (sig[i] == 'L')
				{
					i++;
					int end = sig.IndexOf(';', i);
					names.Add(GetParameterName(sig.Substring(i, end - i)));
					i = end;
				}
				else if (sig[i] == '[')
				{
					while (sig[++i] == '[') ;
					if (sig[i] == 'L')
					{
						i++;
						int end = sig.IndexOf(';', i);
						names.Add(GetParameterName(sig.Substring(i, end - i)) + "arr");
						i = end;
					}
					else
					{
						switch (sig[i])
						{
							case 'B':
							case 'Z':
								names.Add("barr");
								break;
							case 'C':
								names.Add("charr");
								break;
							case 'S':
								names.Add("sarr");
								break;
							case 'I':
								names.Add("iarr");
								break;
							case 'J':
								names.Add("larr");
								break;
							case 'F':
								names.Add("farr");
								break;
							case 'D':
								names.Add("darr");
								break;
						}
					}
				}
				else
				{
					switch (sig[i])
					{
						case 'B':
						case 'Z':
							names.Add("b");
							break;
						case 'C':
							names.Add("ch");
							break;
						case 'S':
							names.Add("s");
							break;
						case 'I':
							names.Add("i");
							break;
						case 'J':
							names.Add("l");
							break;
						case 'F':
							names.Add("f");
							break;
						case 'D':
							names.Add("d");
							break;
					}
				}
			}
			for (int i = 0; i < parameterNames.Length; i++)
			{
				if (parameterNames[i] == null)
				{
					parameterNames[i] = names[i];
				}
			}
		}

		protected static ParameterBuilder[] GetParameterBuilders(MethodBuilder mb, int parameterCount, string[] parameterNames)
		{
			ParameterBuilder[] parameterBuilders = new ParameterBuilder[parameterCount];
			Dictionary<string, int> clashes = null;
			for (int i = 0; i < parameterBuilders.Length; i++)
			{
				string name = null;
				if (parameterNames != null && parameterNames[i] != null)
				{
					name = parameterNames[i];
					if (Array.IndexOf(parameterNames, name, i + 1) >= 0 || (clashes != null && clashes.ContainsKey(name)))
					{
						if (clashes == null)
						{
							clashes = new Dictionary<string, int>();
						}
						int clash = 1;
						if (clashes.ContainsKey(name))
						{
							clash = clashes[name] + 1;
						}
						clashes[name] = clash;
						name += clash;
					}
				}
				parameterBuilders[i] = mb.DefineParameter(i + 1, ParameterAttributes.None, name);
			}
			return parameterBuilders;
		}

		private static string GetParameterName(string type)
		{
			if (type == "java.lang.String")
			{
				return "str";
			}
			else if (type == "java.lang.Object")
			{
				return "obj";
			}
			else
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder();
				for (int i = type.LastIndexOf('.') + 1; i < type.Length; i++)
				{
					if (char.IsUpper(type, i))
					{
						sb.Append(char.ToLower(type[i]));
					}
				}
				return sb.ToString();
			}
		}

#if STATIC_COMPILER
		protected abstract void AddMapXmlFields(ref FieldWrapper[] fields);
		protected abstract bool EmitMapXmlMethodPrologueAndOrBody(CodeEmitter ilgen, ClassFile f, ClassFile.Method m);
		protected abstract void EmitMapXmlMetadata(TypeBuilder typeBuilder, ClassFile classFile, FieldWrapper[] fields, MethodWrapper[] methods);
		protected abstract MethodBuilder DefineGhostMethod(TypeBuilder typeBuilder, string name, MethodAttributes attribs, MethodWrapper mw);
		protected abstract void FinishGhost(TypeBuilder typeBuilder, MethodWrapper[] methods);
		protected abstract void FinishGhostStep2();
		protected abstract TypeBuilder DefineGhostType(string mangledTypeName, TypeAttributes typeAttribs);
#endif // STATIC_COMPILER

		private bool IsPInvokeMethod(ClassFile.Method m)
		{
#if STATIC_COMPILER
			Dictionary<string, IKVM.Internal.MapXml.Class> mapxml = classLoader.GetMapXmlClasses();
			if (mapxml != null)
			{
				IKVM.Internal.MapXml.Class clazz;
				if (mapxml.TryGetValue(this.Name, out clazz) && clazz.Methods != null)
				{
					foreach (IKVM.Internal.MapXml.Method method in clazz.Methods)
					{
						if (method.Name == m.Name && method.Sig == m.Signature)
						{
							if (method.Attributes != null)
							{
								foreach (IKVM.Internal.MapXml.Attribute attr in method.Attributes)
								{
									if (StaticCompiler.GetType(classLoader, attr.Type) == JVM.Import(typeof(System.Runtime.InteropServices.DllImportAttribute)))
									{
										return true;
									}
								}
							}
							break;
						}
					}
				}
			}
#elif CLASSGC
			// TODO PInvoke is not supported in RunAndCollect assemblies,
			if (JVM.classUnloading)
			{
				return false;
			}
#endif
			if (m.Annotations != null)
			{
				foreach (object[] annot in m.Annotations)
				{
					if ("Lcli/System/Runtime/InteropServices/DllImportAttribute$Annotation;".Equals(annot[1]))
					{
						return true;
					}
				}
			}
			return false;
		}

		internal override MethodBase LinkMethod(MethodWrapper mw)
		{
			mw.AssertLinked();
			return impl.LinkMethod(mw);
		}

		internal override FieldInfo LinkField(FieldWrapper fw)
		{
			fw.AssertLinked();
			return impl.LinkField(fw);
		}

		internal override void EmitRunClassConstructor(CodeEmitter ilgen)
		{
			impl.EmitRunClassConstructor(ilgen);
		}

		internal override string GetGenericSignature()
		{
			return impl.GetGenericSignature();
		}

		internal override string GetGenericMethodSignature(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for (int i = 0; i < methods.Length; i++)
			{
				if (methods[i] == mw)
				{
					return impl.GetGenericMethodSignature(i);
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override string GetGenericFieldSignature(FieldWrapper fw)
		{
			FieldWrapper[] fields = GetFields();
			for (int i = 0; i < fields.Length; i++)
			{
				if (fields[i] == fw)
				{
					return impl.GetGenericFieldSignature(i);
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override MethodParametersEntry[] GetMethodParameters(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for (int i = 0; i < methods.Length; i++)
			{
				if (methods[i] == mw)
				{
					return impl.GetMethodParameters(i);
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

#if !STATIC_COMPILER
		internal override string[] GetEnclosingMethod()
		{
			return impl.GetEnclosingMethod();
		}

		internal override string GetSourceFileName()
		{
			return sourceFileName;
		}

		private int GetMethodBaseToken(MethodBase mb)
		{
			MethodBuilder mbld = mb as MethodBuilder;
			if (mbld != null)
			{
				return mbld.GetToken().Token;
			}
			return mb.MetadataToken;
		}

		internal override int GetSourceLineNumber(MethodBase mb, int ilOffset)
		{
			if (lineNumberTables != null)
			{
				int token = GetMethodBaseToken(mb);
				MethodWrapper[] methods = GetMethods();
				for (int i = 0; i < methods.Length; i++)
				{
					if (GetMethodBaseToken(methods[i].GetMethod()) == token)
					{
						if (lineNumberTables[i] != null)
						{
							return new LineNumberTableAttribute(lineNumberTables[i]).GetLineNumber(ilOffset);
						}
						break;
					}
				}
			}
			return -1;
		}

		private object[] DecodeAnnotations(object[] definitions)
		{
			if (definitions == null)
			{
				return null;
			}
			java.lang.ClassLoader loader = GetClassLoader().GetJavaClassLoader();
			List<object> annotations = new List<object>();
			for (int i = 0; i < definitions.Length; i++)
			{
				object obj = JVM.NewAnnotation(loader, definitions[i]);
				if (obj != null)
				{
					annotations.Add(obj);
				}
			}
			return annotations.ToArray();
		}

		internal override object[] GetDeclaredAnnotations()
		{
			return DecodeAnnotations(impl.GetDeclaredAnnotations());
		}

		internal override object[] GetMethodAnnotations(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for (int i = 0; i < methods.Length; i++)
			{
				if (methods[i] == mw)
				{
					return DecodeAnnotations(impl.GetMethodAnnotations(i));
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override object[][] GetParameterAnnotations(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for (int i = 0; i < methods.Length; i++)
			{
				if (methods[i] == mw)
				{
					object[][] annotations = impl.GetParameterAnnotations(i);
					if (annotations != null)
					{
						object[][] objs = new object[annotations.Length][];
						for (int j = 0; j < annotations.Length; j++)
						{
							objs[j] = DecodeAnnotations(annotations[j]);
						}
						return objs;
					}
					return null;
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override object[] GetFieldAnnotations(FieldWrapper fw)
		{
			FieldWrapper[] fields = GetFields();
			for (int i = 0; i < fields.Length; i++)
			{
				if (fields[i] == fw)
				{
					return DecodeAnnotations(impl.GetFieldAnnotations(i));
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

		internal override object GetAnnotationDefault(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for (int i = 0; i < methods.Length; i++)
			{
				if (methods[i] == mw)
				{
					object defVal = impl.GetMethodDefaultValue(i);
					if (defVal != null)
					{
						return JVM.NewAnnotationElementValue(mw.DeclaringType.GetClassLoader().GetJavaClassLoader(), mw.ReturnType.ClassObject, defVal);
					}
					return null;
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}
		private Type GetBaseTypeForDefineType()
		{
			return BaseTypeWrapper.TypeAsBaseType;
		}
#endif

#if STATIC_COMPILER
		protected virtual Type GetBaseTypeForDefineType()
		{
			return BaseTypeWrapper.TypeAsBaseType;
		}

		internal virtual MethodWrapper[] GetReplacedMethodsFor(MethodWrapper mw)
		{
			return null;
		}
#endif // STATIC_COMPILER

		internal override MethodBase GetSerializationConstructor()
		{
			return automagicSerializationCtor;
		}

		private Type[] GetModOpt(TypeWrapper tw, bool mustBePublic)
		{
			return GetModOpt(GetClassLoader().GetTypeWrapperFactory(), tw, mustBePublic);
		}

		internal static Type[] GetModOpt(TypeWrapperFactory context, TypeWrapper tw, bool mustBePublic)
		{
			Type[] modopt = Type.EmptyTypes;
			if (tw.IsUnloadable)
			{
				if (((UnloadableTypeWrapper)tw).MissingType == null)
				{
					modopt = new Type[] { ((UnloadableTypeWrapper)tw).GetCustomModifier(context) };
				}
			}
			else
			{
				TypeWrapper tw1 = tw.IsArray ? tw.GetUltimateElementTypeWrapper() : tw;
				if (tw1.IsErasedOrBoxedPrimitiveOrRemapped || tw.IsGhostArray || (mustBePublic && !tw1.IsPublic))
				{
					// FXBUG Ref.Emit refuses arrays in custom modifiers, so we add an array type for each dimension
					modopt = new Type[tw.ArrayRank + 1];
					modopt[0] = GetModOptHelper(tw1);
					for (int i = 1; i < modopt.Length; i++)
					{
						modopt[i] = Types.Array;
					}
				}
			}
			return modopt;
		}

		private static Type GetModOptHelper(TypeWrapper tw)
		{
			Debug.Assert(!tw.IsUnloadable);
			if (tw.IsArray)
			{
				return ArrayTypeWrapper.MakeArrayType(GetModOptHelper(tw.GetUltimateElementTypeWrapper()), tw.ArrayRank);
			}
			else if (tw.IsGhost)
			{
				return tw.TypeAsTBD;
			}
			else
			{
				return tw.TypeAsBaseType;
			}
		}

#if STATIC_COMPILER
		private bool NeedsType2AccessStub(FieldWrapper fw)
		{
			Debug.Assert(this.IsPublic && fw.DeclaringType == this);
			return fw.IsType2FinalField
				|| (fw.HasNonPublicTypeInSignature
					&& (fw.IsPublic || (fw.IsProtected && !this.IsFinal))
					&& (fw.FieldTypeWrapper.IsUnloadable || fw.FieldTypeWrapper.IsAccessibleFrom(this) || fw.FieldTypeWrapper.InternalsVisibleTo(this)));
		}
#endif

		internal static bool RequiresDynamicReflectionCallerClass(string classFile, string method, string signature)
		{
			return (classFile == "java.lang.ClassLoader" && method == "getParent" && signature == "()Ljava.lang.ClassLoader;")
				|| (classFile == "java.lang.Thread" && method == "getContextClassLoader" && signature == "()Ljava.lang.ClassLoader;")
				|| (classFile == "java.io.ObjectStreamField" && method == "getType" && signature == "()Ljava.lang.Class;")
				|| (classFile == "javax.sql.rowset.serial.SerialJavaObject" && method == "getFields" && signature == "()[Ljava.lang.reflect.Field;")
				;
		}


		internal override object[] GetConstantPool()
		{
			return impl.GetConstantPool();
		}

		internal override byte[] GetRawTypeAnnotations()
		{
			return impl.GetRawTypeAnnotations();
		}

		internal override byte[] GetMethodRawTypeAnnotations(MethodWrapper mw)
		{
			return impl.GetMethodRawTypeAnnotations(Array.IndexOf(GetMethods(), mw));
		}

		internal override byte[] GetFieldRawTypeAnnotations(FieldWrapper fw)
		{
			return impl.GetFieldRawTypeAnnotations(Array.IndexOf(GetFields(), fw));
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal override TypeWrapper Host
		{
			get { return impl.Host; }
		}
#endif

		[Conditional("STATIC_COMPILER")]
		internal void EmitLevel4Warning(HardError error, string message)
		{
#if STATIC_COMPILER
			if (GetClassLoader().WarningLevelHigh)
			{
				switch (error)
				{
					case HardError.AbstractMethodError:
						GetClassLoader().IssueMessage(Message.EmittedAbstractMethodError, this.Name, message);
						break;
					case HardError.IncompatibleClassChangeError:
						GetClassLoader().IssueMessage(Message.EmittedIncompatibleClassChangeError, this.Name, message);
						break;
					default:
						throw new InvalidOperationException();
				}
			}
#endif
		}
	}

	sealed class DefineMethodHelper
	{
		private readonly MethodWrapper mw;

		internal DefineMethodHelper(MethodWrapper mw)
		{
			this.mw = mw;
		}

		internal int ParameterCount
		{
			get { return mw.GetParameters().Length + (mw.HasCallerID ? 1 : 0); }
		}

		internal MethodBuilder DefineMethod(DynamicTypeWrapper context, TypeBuilder tb, string name, MethodAttributes attribs)
		{
			return DefineMethod(context.GetClassLoader().GetTypeWrapperFactory(), tb, name, attribs, null, false);
		}

		internal MethodBuilder DefineMethod(TypeWrapperFactory context, TypeBuilder tb, string name, MethodAttributes attribs)
		{
			return DefineMethod(context, tb, name, attribs, null, false);
		}

		internal MethodBuilder DefineMethod(TypeWrapperFactory context, TypeBuilder tb, string name, MethodAttributes attribs, Type firstParameter, bool mustBePublic)
		{
			// we add optional modifiers to make the signature unique
			int firstParam = firstParameter == null ? 0 : 1;
			TypeWrapper[] parameters = mw.GetParameters();
			Type[] parameterTypes = new Type[parameters.Length + (mw.HasCallerID ? 1 : 0) + firstParam];
			Type[][] modopt = new Type[parameterTypes.Length][];
			if (firstParameter != null)
			{
				parameterTypes[0] = firstParameter;
				modopt[0] = Type.EmptyTypes;
			}
			for (int i = 0; i < parameters.Length; i++)
			{
				parameterTypes[i + firstParam] = mustBePublic
					? parameters[i].TypeAsPublicSignatureType
					: parameters[i].TypeAsSignatureType;
				modopt[i + firstParam] = DynamicTypeWrapper.GetModOpt(context, parameters[i], mustBePublic);
			}
			if (mw.HasCallerID)
			{
				parameterTypes[parameterTypes.Length - 1] = CoreClasses.ikvm.@@internal.CallerID.Wrapper.TypeAsSignatureType;
			}
			Type returnType = mustBePublic
				? mw.ReturnType.TypeAsPublicSignatureType
				: mw.ReturnType.TypeAsSignatureType;
			Type[] modoptReturnType = DynamicTypeWrapper.GetModOpt(context, mw.ReturnType, mustBePublic);
			return tb.DefineMethod(name, attribs, CallingConventions.Standard, returnType, null, modoptReturnType, parameterTypes, null, modopt);
		}

		internal MethodBuilder DefineConstructor(DynamicTypeWrapper context, TypeBuilder tb, MethodAttributes attribs)
		{
			return DefineConstructor(context.GetClassLoader().GetTypeWrapperFactory(), tb, attribs);
		}

		internal MethodBuilder DefineConstructor(TypeWrapperFactory context, TypeBuilder tb, MethodAttributes attribs)
		{
			return DefineMethod(context, tb, ConstructorInfo.ConstructorName, attribs | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName);
		}
	}

#if !STATIC_COMPILER
	sealed class DynamicCallerIDProvider
	{
		// this object acts as a capability that is passed to trusted code to allow the DynamicCallerID()
		// method to be public without giving untrusted code the ability to forge a CallerID token
		internal static readonly DynamicCallerIDProvider Instance = new DynamicCallerIDProvider();

		private DynamicCallerIDProvider() { }

		internal ikvm.@@internal.CallerID GetCallerID()
		{
			for (int i = 0; ; )
			{
				MethodBase method = new StackFrame(i++, false).GetMethod();
				if (method == null)
				{
#if !FIRST_PASS
					return ikvm.@@internal.CallerID.create(null, null);
#endif
				}
				if (Java_sun_reflect_Reflection.IsHideFromStackWalk(method))
				{
					continue;
				}
				TypeWrapper caller = ClassLoaderWrapper.GetWrapperFromType(method.DeclaringType);
				return CreateCallerID(caller.Host ?? caller);
			}
		}

		internal static ikvm.@@internal.CallerID CreateCallerID(TypeWrapper tw)
		{
#if FIRST_PASS
			return null;
#else
			return ikvm.@@internal.CallerID.create(tw.ClassObject, tw.GetClassLoader().GetJavaClassLoader());
#endif
		}
	}
#endif
}
@


1.279
log
@Improved IsSideEffectFreeStaticInitializerOrNoop() to handle needless zero/null initialization of static fields. Removed bogus handling of incorrect return statements.
@
text
@d1150 14
a1163 1
					NormalizedByteCode bc = m.Instructions[i].NormalizedOpCode;
@


1.278
log
@Cleaned up static initializer optimization to use FieldWrapper.IsSerialVersionUID.
@
text
@a1178 4
							if (!field.IsFinal || !field.IsStatic)
							{
								noop = false;
							}
a1185 9
					else if (bc == NormalizedByteCode.__areturn ||
						bc == NormalizedByteCode.__ireturn ||
						bc == NormalizedByteCode.__lreturn ||
						bc == NormalizedByteCode.__freturn ||
						bc == NormalizedByteCode.__dreturn)
					{
						noop = false;
						return false;
					}
d1192 1
@


1.277
log
@Added FieldWrapper.IsSerialVersionUID property to properly (and consistently) detect serialVersionUID fields.
@
text
@d500 1
a500 1
				// process all methods
d506 1
d514 1
a514 3
							// because we cannot affect serialVersionUID computation (which is the only way the presence of a <clinit> can surface)
							// we cannot do this optimization if the class is serializable but doesn't have a serialVersionUID
							if (noop && (!wrapper.IsSerializable || classFile.HasSerialVersionUID))
d516 1
a516 2
								methods[i] = new DummyMethodWrapper(wrapper);
								continue;
a526 1
					MemberFlags flags = MemberFlags.None;
d2912 1
d2922 7
a2928 1
				Debug.Assert(mw != null);
d3084 15
@


1.276
log
@Added support for automatically passing in fields to "native" methods.
@
text
@d1527 1
a1527 1
					&& fw.Name != "serialVersionUID"
@


1.275
log
@Moved unused field removal optimization to a later stage in the compilation. Also made the check more strict to only remove final fields and not remove fields that have annotations.
@
text
@d4391 7
a4397 2
										TypeWrapper[] match = new TypeWrapper[param.Length];
										for (int j = 0; j < param.Length; j++)
d4411 1
d4416 50
d4473 1
@


1.274
log
@Fixed regression introduced in previous change. Untangled TypeWrapper finishing from linking.
@
text
@d1523 12
@


1.273
log
@Removed sig decoding methods with implicit LoadMode.
@
text
@d1694 2
a1695 1
				if (wrapper.BaseTypeWrapper != null)
d1697 2
a1698 1
					wrapper.BaseTypeWrapper.Finish();
d1710 1
a1710 1
				for (int i = 0; i < wrapper.Interfaces.Length; i++)
d1712 2
a1713 1
					wrapper.Interfaces[i].Finish();
@


1.272
log
@Added environment switch IKVM_DISABLE_EAGER_CLASS_LOADING to enable testing late binding.
@
text
@d600 1
a600 1
						fieldType = ClassLoaderWrapper.GetBootstrapClassLoader().FieldTypeWrapperFromSig(fld.Signature);
@


1.271
log
@Avoid infinite recursion if (broken) class loader triggers a load of a class currently being finished.
@
text
@d1717 1
a1717 1
				LoadMode mode = System.Threading.Interlocked.Increment(ref recursionCount) > 2
@


1.270
log
@Bug fix. Dynamica caller id should return host class for anonymous classes injected into host class.
@
text
@d481 1
d1715 6
a1720 2
				classFile.Link(wrapper);
				for (int i = 0; i < fields.Length; i++)
d1722 9
a1730 1
					fields[i].Link();
d1732 1
a1732 1
				for (int i = 0; i < methods.Length; i++)
d1734 1
a1734 1
					methods[i].Link();
@


1.269
log
@Bug fix. Handle ghost and value types in override stub signatures.
@
text
@d465 1
d1840 1
a1840 1
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, wrapper.ReflectiveModifiers, Metadata.Create(classFile), finishedClinitMethod, finalizeMethod);
d3537 5
d3855 1
d3857 1
a3857 1
			internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers, Metadata metadata, MethodInfo clinitMethod, MethodInfo finalizeMethod)
d3866 1
d4004 5
d7152 7
d7271 1
a7271 1
				return CreateCallerID(caller);
@


1.268
log
@Bug fix Handle unloadable types in native method signature in JniProxyBuilder (used when -Xsave is used).
@
text
@d6539 2
a6540 4
			Type stubret = baseMethod.ReturnTypeForDefineMethod;
			Type[] stubargs = baseMethod.GetParametersForDefineMethod();
			Type targetRet = targetMethod.ReturnTypeForDefineMethod;
			Type[] targetArgs = targetMethod.GetParametersForDefineMethod();
d6546 1
a6546 4
				if (targetArgs[i] != stubargs[i])
				{
					ilgen.Emit(OpCodes.Castclass, targetArgs[i]);
				}
d6556 8
a6563 1
			if (targetRet != stubret)
d6565 15
a6579 1
				ilgen.Emit(OpCodes.Castclass, stubret);
a6580 2
			ilgen.Emit(OpCodes.Ret);
			ilgen.DoEmit();
@


1.267
log
@Bug fix. Handle unloadable return type in native method signature.
@
text
@d5731 1
a5731 1
						argTypes[i + instance] = (args[i].IsPrimitive || args[i].IsGhost || args[i].IsNonPrimitiveValueType) ? args[i].TypeAsSignatureType : typeof(object);
d5734 1
a5734 1
					Type retType = (mw.ReturnType.IsPrimitive || mw.ReturnType.IsGhost || mw.ReturnType.IsNonPrimitiveValueType) ? mw.ReturnType.TypeAsSignatureType : typeof(object);
d5747 1
a5747 1
					if (!mw.ReturnType.IsPrimitive && !mw.ReturnType.IsGhost && !mw.ReturnType.IsNonPrimitiveValueType)
@


1.266
log
@Changed dynamic CallerID implementation to use only immutable CallerID objects. If a CallerID is passed along downstream, it should not start returning a different caller. Also simplified host caller id.
@
text
@d5823 1
a5823 1
					if (!retTypeWrapper.IsUnloadable && !retTypeWrapper.IsPrimitive)
d5895 5
a5899 1
						if (!retTypeWrapper.IsUnloadable && !retTypeWrapper.IsPrimitive)
@


1.265
log
@Bug fix. If a miranda method signature differs from its base class miranda method (due to unloadable types), we need to emit an override stub.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2014 Jeroen Frijters
a4092 24
#if !STATIC_COMPILER && !FIRST_PASS
			internal sealed class HostCallerID : ikvm.@@internal.CallerID
			{
				internal readonly TypeWrapper host;
				private readonly TypeWrapper wrapper;

				internal HostCallerID(TypeWrapper host, TypeWrapper wrapper)
				{
					this.host = host;
					this.wrapper = wrapper;
				}

				internal override java.lang.Class getAndCacheClass()
				{
					return wrapper.ClassObject;
				}

				internal override java.lang.ClassLoader getAndCacheClassLoader()
				{
					return wrapper.GetClassLoader().GetJavaClassLoader();
				}
			}
#endif

d4098 1
a4098 1
				EmitLiveObjectLoad(ilgen, new HostCallerID(host, wrapper));
d4108 2
a4109 2
					EmitLiveObjectLoad(ilgen, MethodHandleUtil.DynamicMethodBuilder.DynamicCallerID.Instance);
					ilgen.Emit(OpCodes.Castclass, CoreClasses.ikvm.@@internal.CallerID.Wrapper.TypeAsBaseType);
d7207 40
@


1.264
log
@Fix regression introduced with previous change. Now that we use GenerateOverrideStub() for more stub types, it should include the base type name in the method name to avoid duplicate method names.
@
text
@d2918 2
a2919 1
							MethodWrapper baseMiranda;
d2925 9
d2940 4
@


1.263
log
@Bug fix. Handle unloadable types in interface stub signatures.
@
text
@d6542 1
a6542 1
			MethodBuilder overrideStub = baseMethod.GetDefineMethodHelper().DefineMethod(this, typeBuilder, "__<overridestub>" + baseMethod.Name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final);
@


1.262
log
@Merged another if branch.
@
text
@d5535 1
a5535 1
						if (mce.ReturnType != ifmethod.ReturnType)
a5536 1
							// TODO handle unloadable
d5543 1
a5543 1
							if (mceparams[i] != ifparams[i])
a5544 1
								// TODO handle unloadable
@


1.261
log
@Merged to if branches that contained the same code.
@
text
@d5576 1
a5576 1
					else if (mce.GetMethod() == null || mce.RealName != ifmethod.RealName || mce.IsInternal || !ReflectUtil.IsSameAssembly(mce.DeclaringType.TypeAsTBD, typeBuilder))
d5581 1
a5581 17
						MethodBuilder mb = DefineInterfaceStubMethod(mangledName, ifmethod);
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
						AttributeHelper.HideFromJava(mb);
						CodeEmitter ilGenerator = CodeEmitter.Create(mb);
						ilGenerator.Emit(OpCodes.Ldarg_0);
						int argc = mce.GetParameters().Length;
						for (int n = 0; n < argc; n++)
						{
							ilGenerator.EmitLdarg(n + 1);
						}
						mce.EmitCallvirt(ilGenerator);
						ilGenerator.Emit(OpCodes.Ret);
						ilGenerator.DoEmit();
					}
					else if (CheckRequireOverrideStub(mce, ifmethod))
					{
						wrapper.GenerateOverrideStub(typeBuilder, ifmethod, (MethodInfo)mce.GetMethod(), mce);
d6561 8
a6568 1
			ilgen.Emit(OpCodes.Callvirt, target);
@


1.260
log
@Bug fix. When -Xsave is used the modopt types should be attached to unloadable types in inherited method signatures.
@
text
@d5576 1
a5576 17
					else if (mce.GetMethod() == null || mce.RealName != ifmethod.RealName || mce.IsInternal)
					{
						MethodBuilder mb = DefineInterfaceStubMethod(mangledName, ifmethod);
						AttributeHelper.HideFromJava(mb);
						CodeEmitter ilGenerator = CodeEmitter.Create(mb);
						ilGenerator.Emit(OpCodes.Ldarg_0);
						int argc = mce.GetParameters().Length;
						for (int n = 0; n < argc; n++)
						{
							ilGenerator.EmitLdarg(n + 1);
						}
						mce.EmitCallvirt(ilGenerator);
						ilGenerator.Emit(OpCodes.Ret);
						ilGenerator.DoEmit();
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)ifmethod.GetMethod());
					}
					else if (!ReflectUtil.IsSameAssembly(mce.DeclaringType.TypeAsTBD, typeBuilder))
@


1.259
log
@Added cache for methodinfos of interlocked methods.
@
text
@a1444 8
#if !STATIC_COMPILER
				if (JVM.FinishingForDebugSave)
				{
					// when we're finishing types to save a debug image (in dynamic mode) we don't care about loader constraints anymore
					// (and we can't throw a LinkageError, because that would prevent the debug image from being saved)
					return;
				}
#endif
d1459 7
a1466 1
						throw new LinkageError("Loader constraints violated");
d1487 7
a1494 1
							throw new LinkageError("Loader constraints violated");
@


1.258
log
@Bug fix. Conflicting default interface methods should throw IncompatibleClassChangeError instead of AbstractMethodError.
@
text
@d4926 1
a4926 1
					ilGenerator.Emit(OpCodes.Call, JVM.Import(typeof(System.Threading.Interlocked)).GetMethod("CompareExchange", new Type[] { Types.Int64.MakeByRefType(), Types.Int64, Types.Int64 }));
d4930 1
a4930 1
					ilGenerator.Emit(OpCodes.Call, JVM.Import(typeof(System.Threading.Interlocked)).GetMethod("CompareExchange", new Type[] { Types.Int32.MakeByRefType(), Types.Int32, Types.Int32 }));
@


1.257
log
@Added comment about changed method overriding semantics in JDK 8u11.
@
text
@d2930 1
a2930 1
								ilgen.EmitThrow("java.lang.AbstractMethodError", message);
d2932 1
a2932 1
								wrapper.EmitLevel4Warning(HardError.AbstractMethodError, message);
d7165 3
@


1.256
log
@Add some (level 4) warnings for abstract method errors that can be caused by bugs in default interface method handling.
@
text
@d2472 2
@


1.255
log
@Bug fix. Miranda method in base class should not interfere with default interface methods.
@
text
@d2926 1
d2928 1
a2928 1
								ilgen.EmitThrow("java.lang.AbstractMethodError", mmw.Error ?? (wrapper.Name + "." + methods[index].Name + methods[index].Signature));
d2930 1
d4228 1
d4282 1
d5627 1
d7151 18
@


1.254
log
@Added support for intrinsifying serializable lambdas.
@
text
@d1275 1
a1275 1
								if (mw == null)
d2911 7
a2917 1
							MethodAttributes attr = MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.CheckAccessOnOverride;
@


1.253
log
@Include full class name of anonymous classes in stack trace (i.e. including the "/<identityHashCode>" suffix.)
@
text
@d4002 1
a4002 1
			internal TypeWrapper TypeWrapper
@


1.252
log
@Added intrinsic for LambdaMetafactory.metafactory().
@
text
@d115 1
a115 1
			: base(f.IsInternal ? TypeFlags.InternalAccess : TypeFlags.None, f.Modifiers, f.Name)
@


1.251
log
@Bug fix. Interfaces can't "override" final methods in Object.
@
text
@d4002 5
d5160 1
a5160 20
							CodeEmitter ilgen = CodeEmitter.Create(mb);
							if (mmw.BaseMethod.DeclaringType.IsGhost)
							{
								CodeEmitterLocal local = ilgen.DeclareLocal(mmw.BaseMethod.DeclaringType.TypeAsSignatureType);
								ilgen.Emit(OpCodes.Ldloca, local);
								ilgen.EmitLdarg(0);
								ilgen.Emit(OpCodes.Stfld, mmw.BaseMethod.DeclaringType.GhostRefField);
								ilgen.Emit(OpCodes.Ldloca, local);
							}
							else
							{
								ilgen.EmitLdarg(0);
							}
							for (int j = 0, count = mmw.GetParameters().Length; j < count; j++)
							{
								ilgen.EmitLdarg(j + 1);
							}
							ilgen.Emit(OpCodes.Call, DefaultInterfaceMethodWrapper.GetImpl(mmw.BaseMethod));
							ilgen.Emit(OpCodes.Ret);
							ilgen.DoEmit();
d5166 24
d6425 9
@


1.250
log
@Bug fix. Handle malformed UTF-16 (invalid surrogates) in type/member names and annotations.
@
text
@d120 1
a120 2
			this.baseTypeWrapper = f.IsInterface ? null : LoadTypeWrapper(classLoader, pd, f.SuperClass);
			if (BaseTypeWrapper != null)
d122 16
@


1.249
log
@@@InterlockedCompareAndSet:
- Added support for instance methods.
- Added support for int and long fields.
@
text
@a1547 1
				string realFieldName = fld.Name;
d1549 5
d1590 1
a1590 1
					field = DefineField(fld.Name, fw.FieldTypeWrapper, attribs, false);
d1605 1
a1605 1
						realFieldName = NamePrefix.Type2AccessStubBackingField + fld.Name;
d1782 2
a1783 1
						CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(AnnotationAttributeAttribute)).GetConstructor(new Type[] { Types.String }), new object[] { annotationBuilder.AttributeTypeName });
d1931 1
a1931 1
					string name = o.classFile.Name;
d2347 1
a2347 1
					return new CustomAttributeBuilder(ctor, new object[] { QualifyClassNames(loader, annotation) });
d3089 6
a3094 1
				string name = m.Name;
d3306 2
a3307 1
						CustomAttributeBuilder cab = new CustomAttributeBuilder(StaticCompiler.GetRuntimeType("IKVM.Attributes.AnnotationDefaultAttribute").GetConstructor(new Type[] { Types.Object }), new object[] { classFile.Methods[index].AnnotationDefault });
@


1.248
log
@Implemented type annotation reflection for statically compiled classes.
@
text
@d4793 4
d4798 21
a4818 1
				if (!method.IsStatic || parameters.Length != 3 || method.ReturnType != PrimitiveTypeWrapper.BOOLEAN)
d4822 2
a4823 1
				if (parameters[0].IsUnloadable || parameters[0].IsPrimitive || parameters[0].IsNonPrimitiveValueType || parameters[0].IsGhost)
d4827 1
a4827 1
				if (parameters[1] != parameters[2])
d4831 1
a4831 1
				if (parameters[1].IsUnloadable || parameters[1].IsPrimitive || parameters[1].IsNonPrimitiveValueType || parameters[1].IsGhost)
d4836 1
a4836 1
				foreach (FieldWrapper fw in parameters[0].GetFields())
d4855 4
d4881 12
a4892 1
				ilGenerator.Emit(OpCodes.Call, AtomicReferenceFieldUpdaterEmitter.MakeCompareExchange(casField.FieldTypeWrapper.TypeAsSignatureType));
@


1.247
log
@Implemented type annotation reflection for dynamically loaded classes.
@
text
@d934 4
d1644 4
d2985 4
d4532 2
d4650 141
@


1.246
log
@Match OpenJDK handling of invalid MethodParameters attribute.
@
text
@d446 4
d3446 24
d3477 2
d3480 2
a3481 1
			private Metadata(string[][] genericMetaData, object[][] annotations, MethodParametersEntry[][] methodParameters)
d3486 2
d3499 1
d3558 12
d3597 12
d3634 1
a3634 1
				if (genericMetaData != null || annotations != null || methodParameters != null)
d3636 10
a3645 1
					return new Metadata(genericMetaData, annotations, methodParameters);
d3740 32
d3910 20
a6787 1

d6879 21
@


1.245
log
@Added (undocumented) -noparameterreflection option ikvmc to disable emitting method parameter reflection metadata, because we want to javac compile core class library with the -parameters option (to get the parameter names of native and abstract methods), but we don't want the reflection info (because the JDK doesn't include it either).
@
text
@d6364 1
a6364 1
				if (parameterNames != null)
@


1.244
log
@- Enabled MethodParameter rendering in runtime stub generator.
- Support round tripping malformed MethodParameter attribute in stub generator.
- Use new general method parameter interface in ikvmstub.
- Added support for method parameter reflection on .NET types.
@
text
@d2956 5
a2960 1
					if (m.MalformedMethodParameters)
d4593 1
a4593 1
					|| m.MethodParameters != null
@


1.243
log
@Added support for MethodParameters in statically compiled classes.
@
text
@d443 1
a443 1
			internal abstract ClassFile.Method.MethodParametersEntry[] GetMethodParameters(int index);
d3422 1
a3422 1
			internal override ClassFile.Method.MethodParametersEntry[] GetMethodParameters(int index)
d3444 1
a3444 1
			private readonly ClassFile.Method.MethodParametersEntry[][] methodParameters;
d3446 1
a3446 1
			private Metadata(string[][] genericMetaData, object[][] annotations, ClassFile.Method.MethodParametersEntry[][] methodParameters)
d3461 1
a3461 1
				ClassFile.Method.MethodParametersEntry[][] methodParameters = null;
d3516 1
a3516 1
							methodParameters = new ClassFile.Method.MethodParametersEntry[classFile.Methods.Length][];
d3642 1
a3642 1
			internal static ClassFile.Method.MethodParametersEntry[] GetMethodParameters(Metadata m, int index)
d3793 1
a3793 1
			internal override ClassFile.Method.MethodParametersEntry[] GetMethodParameters(int index)
d6224 1
a6224 1
			ClassFile.Method.MethodParametersEntry[] methodParameters = m.MethodParameters;
d6515 14
a6632 14
		internal override ClassFile.Method.MethodParametersEntry[] GetMethodParameters(MethodWrapper mw)
		{
			MethodWrapper[] methods = GetMethods();
			for (int i = 0; i < methods.Length; i++)
			{
				if (methods[i] == mw)
				{
					return impl.GetMethodParameters(i);
				}
			}
			Debug.Fail("Unreachable code");
			return null;
		}

@


1.242
log
@Implemented method parameter reflection for dynamically loaded classes.
@
text
@d2956 13
d4589 1
d4595 7
a4601 2
					GetParameterNamesFromLVT(m, parameterNames);
					GetParameterNamesFromSig(m.Signature, parameterNames);
@


1.241
log
@Replaced Unsafe cas operations in Class with Interlocked.CompareExchange().
@
text
@d443 1
d3409 6
d3431 1
d3433 1
a3433 1
			private Metadata(string[][] genericMetaData, object[][] annotations)
d3437 1
d3448 1
d3499 8
d3559 1
a3559 1
				if (genericMetaData != null || annotations != null)
d3561 1
a3561 1
					return new Metadata(genericMetaData, annotations);
d3629 9
d3780 5
d6600 14
@


1.240
log
@Rewrote GetMethodBaseToken() to workaround .NET 2.0 bug. Nashorn exposed a bug in ModuleBuilder.GetMethodToken(). New implementation is simpler and should be faster too.
@
text
@d4100 5
d4467 70
@


1.239
log
@First part of OpenJDK 8 integration.
@
text
@d6402 2
a6403 2
			ConstructorInfo ci = mb as ConstructorInfo;
			if (ci != null)
d6405 1
a6405 5
				return classLoader.GetTypeWrapperFactory().ModuleBuilder.GetConstructorToken(ci).Token;
			}
			else
			{
				return classLoader.GetTypeWrapperFactory().ModuleBuilder.GetMethodToken((MethodInfo)mb).Token;
d6407 1
@


1.238
log
@Compiled lambda form methods must use a dynamic caller id.
@
text
@d601 1
a601 1
					|| (classFile.Name == "java.util.logging.Logger" && method.Name == "findResourceBundleFromStack"))
d6610 1
a6619 1
#endif
@


1.237
log
@Complete support for default and instance methods in ghost interfaces.
@
text
@d3819 1
a3819 1
			internal void EmitDynamicClassLiteral(CodeEmitter ilgen, TypeWrapper tw)
d3826 5
d3832 1
a3832 1
				if (!dynamicClassLiteral.TryGetValue(tw.Name, out method))
d3841 1
a3841 1
					EmitCallerID(ilgen2);
d3849 1
a3849 1
					dynamicClassLiteral.Add(tw.Name, method);
d3888 1
a3888 1
			internal void EmitCallerID(CodeEmitter ilgen)
d3890 8
d5292 1
a5292 1
					context.EmitCallerID(ilGenerator);
d5348 1
a5348 1
						context.EmitCallerID(ilGenerator);
d5363 1
a5363 1
						context.EmitCallerID(ilGenerator);
@


1.236
log
@GhostMethodWrapper can also be a default method.
@
text
@d4193 4
d4626 13
a4638 3
				ilgen.EmitLdarg(0);
				ilgen.Emit(OpCodes.Dup);
				ilgen.EmitNullCheck();
d4673 12
a4684 1
							ilgen.EmitLdarg(0);
@


1.235
log
@Ghost interface private methods can be put in the wrapper value type.
@
text
@d520 1
d535 1
d3293 1
a3293 2
				DefaultInterfaceMethodWrapper dimw = methods[index] as DefaultInterfaceMethodWrapper;
				if (dimw != null)
d3295 12
a3306 2
					dimw.SetImpl(dimw.GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(),
						typeBuilder, NamePrefix.DefaultMethod + mb.Name, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, typeBuilder, false));
d4182 1
a4182 1
								mb = (MethodBuilder)((DefaultInterfaceMethodWrapper)methods[i]).GetImpl();
d4648 1
a4648 2
						DefaultInterfaceMethodWrapper dimw;
						if (mmw.Error == null && (dimw = mmw.BaseMethod as DefaultInterfaceMethodWrapper) != null)
d4664 1
a4664 1
							ilgen.Emit(OpCodes.Call, dimw.GetImpl());
@


1.234
log
@Generate both versions of a ghost interface method during method linking.
@
text
@d3156 1
a3156 1
					if (classFile.IsInterface && !m.IsPublic)
@


1.233
log
@Only create GhostMethodWrapper for virtual methods in ghost interfaces.
@
text
@d3096 1
a3096 1
				mb = wrapper.DefineGhostMethod(name, attribs, methods[index]);
d6237 1
a6237 1
		protected abstract MethodBuilder DefineGhostMethod(string name, MethodAttributes attribs, MethodWrapper mw);
@


1.232
log
@Allow classes defined by Unsafe.defineAnonymousClass() access to private methods of their host class.
@
text
@d518 1
a518 1
					if (wrapper.IsGhost)
@


1.231
log
@- Added IsVirtual property to ClassFile.Method and MethodWrapper to make the code a bit easier to read.
- Fixed Java 8 interface method handling for annotations and ghost interfaces.
@
text
@d111 1
a111 1
		internal DynamicTypeWrapper(ClassFile f, CompilerClassLoader classLoader, ProtectionDomain pd)
d113 1
a113 1
		internal DynamicTypeWrapper(ClassFile f, ClassLoaderWrapper classLoader, ProtectionDomain pd)
d179 1
a179 1
			impl = new JavaTypeImpl(f, this);
d449 1
d468 1
a468 1
			internal JavaTypeImpl(ClassFile f, DynamicTypeWrapper wrapper)
d471 1
d1194 1
a1194 1
					new MethodAnalyzer(wrapper, null, classFile, m, wrapper.classLoader);
d1775 1
a1775 1
					FinishContext context = new FinishContext(classFile, wrapper, typeBuilder);
d3755 1
d3777 1
a3777 1
			internal FinishContext(ClassFile classFile, DynamicOrAotTypeWrapper wrapper, TypeBuilder typeBuilder)
d3779 1
d3838 34
d4194 1
a4194 1
							Compiler.Compile(this, wrapper, methods[i], classFile, m, ilGenerator, ref nonleaf);
d5694 1
a5694 1
				Compiler.Compile(context, wrapper, methods[methodIndex], classFile, m, ilGenerator, ref nonLeaf);
@


1.230
log
@Fixed Java 8 default interface method handling.
@
text
@d526 2
d530 1
a530 1
					else if (classFile.IsInterface && !m.IsStatic && m.IsPublic && !m.IsAbstract)
d536 1
a536 1
						if (!classFile.IsInterface && !m.IsStatic && !m.IsPrivate && !m.IsConstructor)
d538 1
a538 1
							bool explicitOverride = false;
d1241 1
a1241 1
						if (!ifmethod.IsStatic && ifmethod.IsPublic)
d2234 2
a2235 2
						// skip <clinit>
						if (!o.methods[i].IsStatic)
d3025 1
a3025 1
					if (!m.IsStatic && !m.IsPrivate)
d4131 1
a4131 2
							DefaultInterfaceMethodWrapper dimw = methods[i] as DefaultInterfaceMethodWrapper;
							if (!m.IsStatic && m.IsPublic && classFile.IsInterface)
d4133 1
a4133 1
								mb = (MethodBuilder)dimw.GetImpl();
d4141 1
a4141 1
								// Java 8 non-virtual interface methods that we compiled as a static method,
@


1.229
log
@Move private interface methods into a nested type when C# compiler workarounds are enabled.
@
text
@d528 4
d3287 7
d4129 1
d4132 1
a4132 2
								mb = methods[i].GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(),
									typeBuilder, NamePrefix.DefaultMethod + mb.Name, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, typeBuilder, false);
d4598 2
a4599 1
						if (mmw.Error == null && !mmw.BaseMethod.IsAbstract)
d4615 1
a4615 1
							ilgen.Emit(OpCodes.Call, GetDefaultInterfaceMethod(mmw.BaseMethod));
a4622 35
			private static MethodInfo GetDefaultInterfaceMethod(MethodWrapper mw)
			{
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
				mw.ResolveMethod();
#endif
				MethodInfo mi = (MethodInfo)mw.GetMethod();
				ParameterInfo[] parameters = mi.GetParameters();
				foreach (MethodInfo candidate in mi.DeclaringType.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly))
				{
					if (candidate.Name.StartsWith(NamePrefix.DefaultMethod, StringComparison.Ordinal)
						&& candidate.Name.Length == mi.Name.Length + NamePrefix.DefaultMethod.Length
						&& candidate.Name.EndsWith(mi.Name, StringComparison.Ordinal))
					{
						ParameterInfo[] candidateParameters = candidate.GetParameters();
						if (parameters.Length + 1 == candidateParameters.Length)
						{
							bool match = true;
							for (int i = 0; i < parameters.Length; i++)
							{
								if (ReflectUtil.MatchParameterInfos(parameters[i], candidateParameters[i + 1]))
								{
									match = false;
									break;
								}
							}
							if (match)
							{
								return candidate;
							}
						}
					}
				}
				throw new InvalidOperationException();
			}

@


1.228
log
@Support private instance methods in (Java 8) interfaces.
@
text
@d463 1
d1778 4
d3151 14
d3167 1
a3167 1
							mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper, typeBuilder, name, attribs);
@


1.227
log
@Moved nested type names to a central location.
@
text
@d523 4
d3143 24
a3166 1
					mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper, typeBuilder, name, attribs);
d4108 7
@


1.226
log
@Java 8 interfaces can have private methods.
@
text
@d4433 1
a4433 1
					TypeBuilder tbFields = DefineNestedInteropType("__Fields");
d4475 1
a4475 1
								tbMethods = DefineNestedInteropType("__Methods");
d4504 1
a4504 1
					tbDefaultMethods = DefineNestedInteropType("__DefaultMethods");
d5682 1
a5682 1
				TypeBuilder typeCallerID = typeBuilder.DefineNestedType("__<CallerID>", TypeAttributes.Sealed | TypeAttributes.NestedPrivate, tw.TypeAsBaseType);
d5756 1
a5756 1
				TypeBuilder tb = typeBuilder.DefineNestedType("__<tls>_" + id, TypeAttributes.NestedPrivate | TypeAttributes.Sealed, threadLocal.TypeAsBaseType);
d5790 1
a5790 1
					TypeBuilder tb = typeBuilder.DefineNestedType("__<ARFU>_" + arfuMap.Count, TypeAttributes.NestedPrivate | TypeAttributes.Sealed, arfuTypeWrapper.TypeAsBaseType);
d5809 1
a5809 1
				TypeBuilder tb = typeBuilder.DefineNestedType("__<>IndyCS" + id, TypeAttributes.NestedPrivate | TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit);
d5816 1
a5816 1
				TypeBuilder tb = typeBuilder.DefineNestedType("__<>MHC" + index, TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit); ;
d5823 1
a5823 1
				TypeBuilder tb = typeBuilder.DefineNestedType("__<>MTC" + index, TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit);
d5837 1
a5837 1
						interfaceHelperMethodsTypeBuilder = typeBuilder.DefineNestedType("__<>IHM", TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit);
@


1.225
log
@Bug fix. Miranda method override stubs should be handled by the normal code, because a Miranda method can implement multiple interface methods.
@
text
@d1229 2
a1230 2
						// skip <clinit>
						if (!ifmethod.IsStatic)
d2983 1
a2983 1
				if (m.IsAbstract || (!m.IsStatic && classFile.IsInterface))
d4072 1
a4072 1
							if (!m.IsStatic && classFile.IsInterface)
d4471 1
a4471 1
						if (mw.IsStatic && mw.Name != StringConstants.CLINIT && ParametersAreAccessible(mw))
d4884 1
a4884 1
					if (!method.IsStatic && !method.IsDynamicOnly)
@


1.224
log
@Centralized switches to control C# interop workarounds.
@
text
@a2865 9
							if (CheckRequireOverrideStub(methods[index], baseMethods[index][0]))
							{
								wrapper.GenerateOverrideStub(typeBuilder, baseMethods[index][0], mb, methods[index]);
							}
							// if we changed the name or if the interface method name is remapped, we need to add an explicit methodoverride.
							else if (!baseMethods[index][0].IsDynamicOnly && methods[index].Name != baseMethods[index][0].RealName)
							{
								typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethods[index][0].GetMethod());
							}
d4949 1
a4949 5
					if (mce.IsMirandaMethod && mce.DeclaringType == wrapper)
					{
						// Miranda methods already have a methodimpl (if needed) to implement the correct interface method
					}
					else if (!mce.IsPublic && !mce.IsInternal)
@


1.223
log
@Don't publish class initializer in __Methods interop nested type for static interface methods (Java 8).
@
text
@d2915 1
a2915 1
						method = ReflectUtil.DefineTypeInitializer(typeBuilder);
d4135 1
a4135 1
						cb = ReflectUtil.DefineTypeInitializer(typeBuilder);
d4440 1
a4440 1
				if (classFile.IsInterface && classFile.IsPublic && !wrapper.IsGhost && classFile.Fields.Length > 0)
d4459 1
a4459 1
								ilgenClinit = CodeEmitter.Create(ReflectUtil.DefineTypeInitializer(tbFields));
d4475 1
a4475 1
				if (classFile.IsInterface && classFile.IsPublic && classFile.MajorVersion >= 52 && !wrapper.IsGhost && methods.Length > 0)
d5846 1
a5846 1
				if (wrapper.IsPublic && wrapper.IsInterface)
@


1.222
log
@Bug fix. Non-public annotations can be used used in code that doesn't have access to them. Implemented that by switching to DynamicAnnotationAttribute when the annotation isn't accessible.
@
text
@d4480 1
a4480 1
						if (mw.IsStatic && ParametersAreAccessible(mw))
@


1.221
log
@Don't inject private helper methods in public interfaces, because csc.exe doesn't like interfaces with non-public methods.
@
text
@d1999 1
a1999 1
								Annotation annotation = Annotation.Load(o.wrapper.GetClassLoader(), def);
d4240 1
a4240 1
							Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
d4269 1
a4269 1
							Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
d4292 1
a4292 1
						Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
d4384 1
a4384 1
							Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
@


1.220
log
@Added support for (implementation specific) LambdaForm annotations.
@
text
@d3712 3
a3714 1
#if !STATIC_COMPILER
d3765 1
a3765 1
					MethodBuilder mb = typeBuilder.DefineMethod("__<>class", MethodAttributes.PrivateScope | MethodAttributes.Static, CoreClasses.java.lang.Class.Wrapper.TypeAsSignatureType, Type.EmptyTypes);
d3797 1
a3797 1
				MethodBuilder mb = typeBuilder.DefineMethod("__<GetCallerID>", MethodAttributes.Private | MethodAttributes.Static | MethodAttributes.SpecialName, tw.TypeAsSignatureType, Type.EmptyTypes);
d5841 18
d5861 1
a5861 1
				return typeBuilder.DefineMethod("__<>MHC", MethodAttributes.Static | MethodAttributes.PrivateScope, returnType, parameterTypes);
d5881 1
a5881 1
				return typeBuilder.DefineMethod("__<>", MethodAttributes.PrivateScope | MethodAttributes.Static, returnType, parameterTypes);
@


1.219
log
@Added support for CallerID in pseudo-native methods.
@
text
@d3226 20
d4101 1
a4101 1
							if (nonleaf)
@


1.218
log
@Added a ClassFileParseOptions to enable trusted annotations to prepare for more of them.
@
text
@d3979 1
a3981 1
									TypeWrapper[] nargs = args;
d3986 4
d4009 1
a4009 7
									int add = 0;
									if (!m.IsStatic)
									{
										ilGenerator.Emit(OpCodes.Ldarg_0);
										add = 1;
									}
									for (int j = 0; j < args.Length; j++)
d4011 1
a4011 1
										ilGenerator.EmitLdarg(j + add);
@


1.217
log
@Added Unsafe.defineAnonymousClass().
@
text
@d510 1
a510 3
					if (m.IsCallerSensitive
						&& CoreClasses.ikvm.@@internal.CallerID.Wrapper.InternalsVisibleTo(wrapper)	// we only look at CallerSensitive when we're compiling the core class library
						&& SupportsCallerID(m))
@


1.216
log
@Minor refactoring to prepare for class file constant pool patching.
@
text
@d68 6
a73 1
			TypeWrapper tw = classLoader.LoadClassByDottedNameFast(clazz.Name);
d3694 3
d4300 6
d5874 15
@


1.215
log
@Merged OpenJDK 7u40 b34, except for java.lang.invoke and sun.invoke packages.
@
text
@d66 1
a66 1
		private TypeWrapper LoadTypeWrapper(ClassLoaderWrapper classLoader, ProtectionDomain pd, string name)
d68 1
a68 1
			TypeWrapper tw = classLoader.LoadClassByDottedNameFast(name);
d71 1
a71 1
				throw new NoClassDefFoundError(name);
d162 1
a162 1
				TypeWrapper iface = LoadTypeWrapper(classLoader, pd, interfaces[i].Name);
@


1.214
log
@Don't crash ikvmc if a native method has a missing type.
@
text
@d6447 1
@


1.213
log
@Bug fix. If a property getter/setter is accessed in a static initializer, it is not side-effect free.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
d5629 4
@


1.212
log
@Bug fixes.
- If an annotation's type does not exist, the annotation should be ignored instead of throwing an exception.
- If an annotation is (no longer) RetentionPolicy.RUNTIME it should not be returned.
@
text
@d1125 6
d1133 1
a1133 2
							ClassFile.Field field = classFile.GetField(fld.Name, fld.Signature);
							if (field == null)
d1138 1
a1138 1
							if (!field.IsFinal || !field.IsStatic || !field.IsProperty || field.PropertySetter != null)
d1143 5
@


1.211
log
@Moved annotation decoding loop into method.
@
text
@d6261 5
a6265 1
				annotations.Add(JVM.NewAnnotation(loader, definitions[i]));
@


1.210
log
@If an annotation is inconsistent with the annotation type, we should still record it as a dynamic annotation.
@
text
@d6251 1
a6251 1
		internal override object[] GetDeclaredAnnotations()
d6253 7
a6259 2
			object[] annotations = impl.GetDeclaredAnnotations();
			if (annotations != null)
d6261 1
a6261 6
				object[] objs = new object[annotations.Length];
				for (int i = 0; i < annotations.Length; i++)
				{
					objs[i] = JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[i]);
				}
				return objs;
d6263 6
a6268 1
			return null;
d6278 1
a6278 11
					object[] annotations = impl.GetMethodAnnotations(i);
					if (annotations != null)
					{
						object[] objs = new object[annotations.Length];
						for (int j = 0; j < annotations.Length; j++)
						{
							objs[j] = JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[j]);
						}
						return objs;
					}
					return null;
d6298 1
a6298 5
							objs[j] = new object[annotations[j].Length];
							for (int k = 0; k < annotations[j].Length; k++)
							{
								objs[j][k] = JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[j][k]);
							}
d6316 1
a6316 11
					object[] annotations = impl.GetFieldAnnotations(i);
					if (annotations != null)
					{
						object[] objs = new object[annotations.Length];
						for (int j = 0; j < annotations.Length; j++)
						{
							objs[j] = JVM.NewAnnotation(GetClassLoader().GetJavaClassLoader(), annotations[j]);
						}
						return objs;
					}
					return null;
@


1.209
log
@Merged in OpenJDK changes.
@
text
@d2293 5
a2297 1
					return new CustomAttributeBuilder(defineConstructor.__AsConstructorInfo(), new object[] { QualifyClassNames(loader, annotation) });
d2302 1
a2302 5
					Link();
					if (annotationTypeBuilder != null)
					{
						tb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
d2307 1
a2307 5
					Link();
					if (annotationTypeBuilder != null)
					{
						mb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
d2312 1
a2312 5
					Link();
					if (annotationTypeBuilder != null)
					{
						fb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
d2317 1
a2317 5
					Link();
					if (annotationTypeBuilder != null)
					{
						pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
d2322 1
a2322 5
					Link();
					if (annotationTypeBuilder != null)
					{
						ab.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
d2327 1
a2327 5
					Link();
					if (annotationTypeBuilder != null)
					{
						pb.SetCustomAttribute(MakeCustomAttributeBuilder(loader, annotation));
					}
@


1.208
log
@Switched from @@HasCallerID to @@CallerSensitive and merged CallerSenstive related 7u40 changes.
@
text
@d6466 3
a6468 1
				|| (classFile == "java.lang.Thread" && method == "getContextClassLoader" && signature == "()Ljava.lang.ClassLoader;");
@


1.207
log
@Moved parameter name and annotation handling into a separate method.
@
text
@d504 4
a507 4
					// we only support HasCallerID instance methods on final types, because we don't support interface stubs with CallerID
					if (m.HasCallerIDAnnotation
						&& (m.IsStatic || classFile.IsFinal)
						&& CoreClasses.java.lang.Object.Wrapper.InternalsVisibleTo(wrapper))
d511 1
d579 57
d6462 6
@


1.206
log
@Added optimization to omit InnerClassesAttribute to record reflective modifiers when we can predict them.
@
text
@a4160 32
					ParameterBuilder returnParameter = null;
					ParameterBuilder[] parameterBuilders = null;
					string[] parameterNames = null;
					if (wrapper.GetClassLoader().EmitDebugInfo
#if STATIC_COMPILER
 || (classFile.IsPublic && (m.IsPublic || m.IsProtected))
#endif
)
					{
						parameterNames = new string[methods[i].GetParameters().Length];
						GetParameterNamesFromMP(m, parameterNames);
						GetParameterNamesFromLVT(m, parameterNames);
						GetParameterNamesFromSig(m.Signature, parameterNames);
#if STATIC_COMPILER
						wrapper.GetParameterNamesFromXml(m.Name, m.Signature, parameterNames);
#endif
						parameterBuilders = GetParameterBuilders(mb, parameterNames.Length, parameterNames);
					}
#if STATIC_COMPILER
					if ((m.Modifiers & Modifiers.VarArgs) != 0 && !methods[i].HasCallerID)
					{
						if (parameterBuilders == null)
						{
							parameterBuilders = GetParameterBuilders(mb, methods[i].GetParameters().Length, null);
						}
						if (parameterBuilders.Length > 0)
						{
							AttributeHelper.SetParamArrayAttribute(parameterBuilders[parameterBuilders.Length - 1]);
						}
					}
					wrapper.AddXmlMapParameterAttributes(mb, classFile.Name, m.Name, m.Signature, ref parameterBuilders);
#endif
d4163 1
d4174 2
a4175 19
					if (m.ParameterAnnotations != null)
					{
						if (parameterBuilders == null)
						{
							parameterBuilders = GetParameterBuilders(mb, methods[i].GetParameters().Length, null);
						}
						object[][] defs = m.ParameterAnnotations;
						for (int j = 0; j < defs.Length; j++)
						{
							foreach (object[] def in defs[j])
							{
								Annotation annotation = Annotation.Load(wrapper.GetClassLoader(), def);
								if (annotation != null)
								{
									annotation.Apply(wrapper.GetClassLoader(), parameterBuilders[j], def);
								}
							}
						}
					}
d4260 54
@


1.205
log
@Added optimization to omit ImplementAttribute in some cases.
@
text
@d919 1
a919 1
				if (isInnerClass || name != null)
@


1.204
log
@Don't store class name in EnclosingMethodAttribute if we can use the DeclaringType.
@
text
@a831 1
					AddImplementsAttribute();
a902 11
			private void AddImplementsAttribute()
			{
				TypeWrapper[] interfaces = wrapper.Interfaces;
				string[] implements = new string[interfaces.Length];
				for (int i = 0; i < implements.Length; i++)
				{
					implements[i] = interfaces[i].Name;
				}
				AttributeHelper.SetImplementsAttribute(typeBuilder, interfaces);
			}

d4274 4
d4309 30
@


1.203
log
@Compile anonymous and local classes as nested types.
@
text
@d844 9
a852 1
						AttributeHelper.SetEnclosingMethodAttribute(typeBuilder, classFile.EnclosingMethod[0], classFile.EnclosingMethod[1], classFile.EnclosingMethod[2]);
@


1.202
log
@Renamed field and two locals to prepare for patch to compile enclosed classes as nested types.
@
text
@d613 1
d620 8
a627 1
						string enclosingClassName = classFile.GetConstantPoolClass(outerClass.outerClass);
d630 1
a630 1
							Tracer.Warning(Tracer.Compiler, "Incorrect InnerClasses attribute on {0}", f.Name);
d647 1
a647 1
								// it is possible to split the two classes acros assemblies)
d662 2
a663 2
											if (outerInnerClasses[i].outerClass != 0
												&& outerClassFile.GetConstantPoolClass(outerInnerClasses[i].outerClass) == outerClassFile.Name
d685 5
d788 1
a788 1
					if (enclosing != null && cantNest)
d790 8
a797 6
						AttributeHelper.SetNonNestedOuterClass(typeBuilder, enclosingClassWrapper.Name);
						AttributeHelper.SetNonNestedInnerClass(enclosing, f.Name);
					}
					if (outerClass.outerClass != 0 && enclosing == null)
					{
						AttributeHelper.SetNonNestedOuterClass(typeBuilder, classFile.GetConstantPoolClass(outerClass.outerClass));
@


1.201
log
@- Renamed GetInnerClassName() to AllocNestedTypeName().
- Use StringComparison.Ordinal when checking inner vs outer class names.
@
text
@d455 1
a455 1
			private DynamicTypeWrapper outerClassWrapper;
d612 1
a612 1
					TypeBuilder outer = null;
d619 2
a620 2
						string outerClassName = classFile.GetConstantPoolClass(outerClass.outerClass);
						if (!CheckInnerOuterNames(f.Name, outerClassName))
d628 1
a628 1
								outerClassWrapper = wrapper.classLoader.LoadClassByDottedNameFast(outerClassName) as DynamicTypeWrapper;
d632 1
a632 1
								Tracer.Warning(Tracer.Compiler, "Unable to load outer class {0} for inner class {1} ({2}: {3})", outerClassName, f.Name, x.GetType().Name, x.Message);
d634 1
a634 1
							if (outerClassWrapper != null)
d640 2
a641 2
								JavaTypeImpl oimpl = outerClassWrapper.impl as JavaTypeImpl;
								if (oimpl != null && outerClassWrapper.GetClassLoader() == wrapper.GetClassLoader())
d647 1
a647 1
										outerClassWrapper = null;
d665 1
a665 1
											outerClassWrapper = null;
d671 1
a671 1
									outerClassWrapper = null;
d673 1
a673 1
								if (outerClassWrapper != null)
d675 2
a676 2
									outerClassWrapper.CreateStep2();
									outer = oimpl.typeBuilder;
d687 1
a687 1
						if (outer != null)
d689 1
a689 1
							if (outerClassWrapper.IsPublic)
d706 1
a706 1
					else if (outer != null)
d724 1
a724 1
						if (outer != null && !cantNest)
d734 1
a734 1
							typeBuilder = outer.DefineNestedType(AllocNestedTypeName(outerClassWrapper.Name, f.Name), typeAttribs);
d759 1
a759 1
						if (outer != null && !cantNest)
d763 1
a763 1
							typeBuilder = outer.DefineNestedType(AllocNestedTypeName(outerClassWrapper.Name, f.Name), typeAttribs);
d775 1
a775 1
					if (outer != null && cantNest)
d777 2
a778 2
						AttributeHelper.SetNonNestedOuterClass(typeBuilder, outerClassWrapper.Name);
						AttributeHelper.SetNonNestedInnerClass(outer, f.Name);
d780 1
a780 1
					if (outerClass.outerClass != 0 && outer == null)
d808 1
a808 1
						annotationBuilder = new AnnotationBuilder(this, outer);
d818 1
a818 1
					AddInnerClassAttribute(outer != null, outerClass.innerClass != 0, mangledTypeName, outerClass.accessFlags);
d835 2
a836 2
							if ((outerClassWrapper == null && f.SourceFileAttribute == typeBuilder.Name + ".java")
								|| (outerClassWrapper != null && f.SourceFileAttribute == outerClassWrapper.sourceFileName))
d898 1
a898 1
					if (name == outerClassWrapper.Name + "$" + typeBuilder.Name)
d1819 1
a1819 1
					if (o.outerClassWrapper != null)
d1829 1
a1829 1
						attributeTypeBuilder = outer.DefineNestedType(o.AllocNestedTypeName(o.outerClassWrapper.Name, name + "Attribute"), typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
@


1.200
log
@Don't add SourceFileAttribute for inner classes if the name matches the outer class.
@
text
@d734 1
a734 1
							typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs);
d763 1
a763 1
							typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs);
d1296 1
a1296 1
				return inner.Length > outer.Length + 1 && inner[outer.Length] == '$' && inner.StartsWith(outer);
d1299 1
a1299 1
			private string GetInnerClassName(string outer, string inner)
d1829 1
a1829 1
						attributeTypeBuilder = outer.DefineNestedType(o.GetInnerClassName(o.outerClassWrapper.Name, name + "Attribute"), typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
@


1.199
log
@Moved adding InnerClassAttribute to separate method.
@
text
@d835 6
a840 1
							if (f.SourceFileAttribute != typeBuilder.Name + ".java")
@


1.198
log
@Tiny clean up.
@
text
@a800 5
					if (outer == null && mangledTypeName != wrapper.Name)
					{
						// HACK we abuse the InnerClassAttribute to record to real name
						AttributeHelper.SetInnerClass(typeBuilder, wrapper.Name, wrapper.Modifiers);
					}
d818 1
a818 13
					if (outer != null)
					{
						string innerClassName = classFile.Name;
						if (innerClassName == outerClassWrapper.Name + "$" + typeBuilder.Name)
						{
							innerClassName = null;
						}
						AttributeHelper.SetInnerClass(typeBuilder, innerClassName, outerClass.accessFlags);
					}
					else if (outerClass.innerClass != 0)
					{
						AttributeHelper.SetInnerClass(typeBuilder, null, outerClass.accessFlags);
					}
d887 23
@


1.197
log
@Moved adding ImplementsAttribute to separate method.
@
text
@d825 2
a826 3
						Modifiers innerClassModifiers = outerClass.accessFlags;
						string innerClassName = classFile.GetConstantPoolClass(outerClass.innerClass);
						if (innerClassName == classFile.Name && innerClassName == outerClassWrapper.Name + "$" + typeBuilder.Name)
d830 1
a830 1
						AttributeHelper.SetInnerClass(typeBuilder, innerClassName, innerClassModifiers);
@


1.196
log
@Moved CLI enum creation to separate method.
@
text
@d822 1
a822 6
					TypeWrapper[] interfaces = wrapper.Interfaces;
					string[] implements = new string[interfaces.Length];
					for (int i = 0; i < implements.Length; i++)
					{
						implements[i] = interfaces[i].Name;
					}
a836 1
					AttributeHelper.SetImplementsAttribute(typeBuilder, interfaces);
d894 11
@


1.195
log
@Moved __<clinit> method creation to separate method.
@
text
@d820 1
a820 18
						CompilerClassLoader ccl = wrapper.classLoader;
						string name = "__Enum";
						while (!ccl.ReserveName(f.Name + "$" + name))
						{
							name += "_";
						}
						enumBuilder = typeBuilder.DefineNestedType(name, TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.NestedPublic | TypeAttributes.Serializable, Types.Enum);
						AttributeHelper.HideFromJava(enumBuilder);
						enumBuilder.DefineField("value__", Types.Int32, FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
						for (int i = 0; i < f.Fields.Length; i++)
						{
							if (f.Fields[i].IsEnum)
							{
								FieldBuilder fieldBuilder = enumBuilder.DefineField(f.Fields[i].Name, enumBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
								fieldBuilder.SetConstant(i);
							}
						}
						wrapper.SetEnumType(enumBuilder);
d899 24
@


1.194
log
@sealed DynamicTypeWrapper in runtime.
@
text
@d894 1
a894 27
						// We create a empty method that we can use to trigger our .cctor
						// (previously we used RuntimeHelpers.RunClassConstructor, but that is slow and requires additional privileges)
						MethodAttributes attribs = MethodAttributes.Static | MethodAttributes.SpecialName;
						if (classFile.IsAbstract)
						{
							bool hasfields = false;
							// If we have any public static fields, the cctor trigger must (and may) be public as well
							foreach (ClassFile.Field fld in classFile.Fields)
							{
								if (fld.IsPublic && fld.IsStatic)
								{
									hasfields = true;
									break;
								}
							}
							attribs |= hasfields ? MethodAttributes.Public : MethodAttributes.FamORAssem;
						}
						else
						{
							attribs |= MethodAttributes.Public;
						}
						clinitMethod = typeBuilder.DefineMethod("__<clinit>", attribs, null, null);
						clinitMethod.GetILGenerator().Emit(OpCodes.Ret);
						// FXBUG on .NET 2.0 RTM x64 the JIT sometimes throws an InvalidProgramException while trying to inline this method,
						// so we prevent inlining for now (it also turns out that on x86 not inlining this method actually has a positive perf impact in some cases...)
						// http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=285772
						clinitMethod.SetImplementationFlags(clinitMethod.GetMethodImplementationFlags() | MethodImplAttributes.NoInlining);
d916 31
@


1.193
log
@Added (partial) support for Java 8 MethodParameters attribute.
@
text
@d48 2
a49 1
	class DynamicTypeWrapper : TypeWrapper
d5992 1
a5992 1
		protected virtual bool IsPInvokeMethod(ClassFile.Method m)
d5994 27
a6020 1
#if CLASSGC
d6244 5
d6251 1
a6256 1
#if STATIC_COMPILER
@


1.192
log
@Only emit the non-virtual invocation delegate types when compiling with the -static option.
@
text
@d4132 1
d5796 15
@


1.191
log
@Added back support for JNI non-virtual method invocation for methods with more than 8 parameters.
@
text
@d3822 1
a3822 1
						if (methods[i].GetParameters().Length > MethodHandleUtil.MaxArity && methods[i].RequiresNonVirtualDispatcher)
@


1.190
log
@Introduced ArrayUtil.Concat() methods.
@
text
@d3821 6
@


1.189
log
@Support inner classes in "new style" native methods.
@
text
@d1160 1
a1160 2
							Array.Resize(ref methods, methods.Length + 1);
							methods[methods.Length - 1] = mw;
d3885 1
a3885 3
										nargs = new TypeWrapper[args.Length + 1];
										args.CopyTo(nargs, 1);
										nargs[0] = this.wrapper;
d4546 1
a4546 3
					Type[] modopt2 = modopt;
					Array.Resize(ref modopt2, modopt2.Length + 1);
					modopt2[modopt2.Length - 1] = JVM.LoadType(typeof(IKVM.Attributes.AccessStub));
d4648 1
a4648 3
				Type[] modoptReturnType = wrapper.GetModOpt(mw.ReturnType, true);
				Array.Resize(ref modoptReturnType, modoptReturnType.Length + 1);
				modoptReturnType[modoptReturnType.Length - 1] = JVM.LoadType(typeof(IKVM.Attributes.AccessStub));
@


1.188
log
@Don't generate interop methods if we don't even have access to the parameter types.
@
text
@d3876 1
a3876 1
									nativeCodeType = StaticCompiler.GetType(wrapper.GetClassLoader(), "Java_" + classFile.Name.Replace('.', '_'));
@


1.187
log
@Check the "this" parameter for null in the default method interop method.
@
text
@d4317 1
a4317 1
						if (mw.IsStatic)
d4344 4
@


1.186
log
@Make sure the interop methods don't use non-public types in their signatures.
@
text
@d4351 2
@


1.185
log
@Promoted ToPublicSignatureType() method to a TypeWrapper property TypeAsPublicSignatureType.
@
text
@d3968 1
a3968 1
									typeBuilder, NamePrefix.DefaultMethod + mb.Name, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, typeBuilder);
d4323 1
a4323 1
							MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(wrapper, tbMethods, mw.Name, MethodAttributes.Public | MethodAttributes.Static);
d4325 2
a4326 1
							for (int i = 0, count = mw.GetParameters().Length; i < count; i++)
d4329 4
d4348 1
a4348 1
				MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(wrapper.GetClassLoader().GetTypeWrapperFactory(), tbDefaultMethods, mw.Name, MethodAttributes.Public | MethodAttributes.Static, wrapper.TypeAsSignatureType);
d4350 3
a4352 1
				for (int i = 0, count = mw.GetParameters().Length; i <= count; i++)
d4354 5
a4358 1
					ilgen.EmitLdarg(i);
d4382 1
a4382 1
									typeBuilder, NamePrefix.DefaultMethod + mb.Name, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName, typeBuilder);
d6292 1
a6292 1
			return DefineMethod(context.GetClassLoader().GetTypeWrapperFactory(), tb, name, attribs, null);
d6297 1
a6297 1
			return DefineMethod(context, tb, name, attribs, null);
d6300 1
a6300 1
		internal MethodBuilder DefineMethod(TypeWrapperFactory context, TypeBuilder tb, string name, MethodAttributes attribs, Type firstParameter)
d6314 4
a6317 2
				parameterTypes[i + firstParam] = parameters[i].TypeAsSignatureType;
				modopt[i + firstParam] = DynamicTypeWrapper.GetModOpt(context, parameters[i], false);
d6323 5
a6327 2
			Type[] modoptReturnType = DynamicTypeWrapper.GetModOpt(context, mw.ReturnType, false);
			return tb.DefineMethod(name, attribs, CallingConventions.Standard, mw.ReturnType.TypeAsSignatureType, null, modoptReturnType, parameterTypes, null, modopt);
@


1.184
log
@Expose Java 8 default interface methods as static methods via nested __DefaultMethods type.
@
text
@d4293 1
a4293 1
							FieldBuilder fb = tbFields.DefineField(f.Name, ToPublicSignatureType(fields[i].FieldTypeWrapper), attribs);
d4513 1
a4513 1
					Type propType = ToPublicSignatureType(fw.FieldTypeWrapper);
d4632 1
a4632 1
					parameterTypes[i] = ToPublicSignatureType(parameters[i]);
d4635 1
a4635 1
				Type returnType = ToPublicSignatureType(mw.ReturnType);
a4691 5
			private static Type ToPublicSignatureType(TypeWrapper tw)
			{
				return (tw.IsPublic ? tw : tw.GetPublicBaseTypeWrapper()).TypeAsSignatureType;
			}

@


1.183
log
@Add interop support for static interface methods.
@
text
@d3789 3
d3969 3
d4262 1
a4262 1
			private string ReserveNestedTypeName(string name)
d4269 4
a4272 1
				return name;
d4279 1
a4279 3
					TypeBuilder tbFields = typeBuilder.DefineNestedType(ReserveNestedTypeName("__Fields"), TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract);
					RegisterNestedTypeBuilder(tbFields);
					AttributeHelper.HideFromJava(tbFields);
d4321 1
a4321 3
								tbMethods = typeBuilder.DefineNestedType(ReserveNestedTypeName("__Methods"), TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract);
								RegisterNestedTypeBuilder(tbMethods);
								AttributeHelper.HideFromJava(tbMethods);
d4336 17
@


1.182
log
@Moved interface field interop nested type creation into a separate method.
@
text
@d4091 4
d4256 10
d4270 1
a4270 7
					CompilerClassLoader ccl = wrapper.classLoader;
					string name = "__Fields";
					while (!ccl.ReserveName(classFile.Name + "$" + name))
					{
						name += "_";
					}
					TypeBuilder tbFields = typeBuilder.DefineNestedType(name, TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract);
d4302 29
@


1.181
log
@More default interface method fixes.
@
text
@d4089 1
a4089 39
				TypeBuilder tbFields = null;
				if (classFile.IsInterface && classFile.IsPublic && !wrapper.IsGhost && classFile.Fields.Length > 0)
				{
					CompilerClassLoader ccl = wrapper.classLoader;
					string name = "__Fields";
					while (!ccl.ReserveName(classFile.Name + "$" + name))
					{
						name += "_";
					}
					tbFields = typeBuilder.DefineNestedType(name, TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract);
					AttributeHelper.HideFromJava(tbFields);
					CodeEmitter ilgenClinit = null;
					for (int i = 0; i < classFile.Fields.Length; i++)
					{
						ClassFile.Field f = classFile.Fields[i];
						if (f.ConstantValue != null)
						{
							FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal;
							FieldBuilder fb = tbFields.DefineField(f.Name, fields[i].FieldTypeWrapper.TypeAsSignatureType, attribs);
							fb.SetConstant(f.ConstantValue);
						}
						else
						{
							FieldAttributes attribs = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.InitOnly;
							FieldBuilder fb = tbFields.DefineField(f.Name, ToPublicSignatureType(fields[i].FieldTypeWrapper), attribs);
							if (ilgenClinit == null)
							{
								ilgenClinit = CodeEmitter.Create(ReflectUtil.DefineTypeInitializer(tbFields));
							}
							wrapper.GetFieldWrapper(f.Name, f.Signature).EmitGet(ilgenClinit);
							ilgenClinit.Emit(OpCodes.Stsfld, fb);
						}
					}
					if (ilgenClinit != null)
					{
						ilgenClinit.Emit(OpCodes.Ret);
						ilgenClinit.DoEmit();
					}
				}
a4234 6
#if STATIC_COMPILER
					if (tbFields != null)
					{
						tbFields.CreateType();
					}
#endif
d4251 45
@


1.180
log
@Bug fix. Don't implement interfaces that aren't accessible.
@
text
@d1128 1
a1128 1
									mw = new MirandaMethodWrapper(wrapper, ifmethod);
d1135 1
a1135 1
									((MirandaMethodWrapper)mw).AddBaseMethod(ifmethod);
d2771 1
a2771 1
							if (wrapper.IsAbstract && mmw.BaseMethod.IsAbstract && mmw.Error == null)
d2786 1
a2786 1
							if ((!wrapper.IsAbstract && mmw.BaseMethod.IsAbstract) || mmw.Error != null)
d2792 7
d4002 1
a4002 4
				if (!classFile.IsInterface)
				{
					AddInheritedDefaultInterfaceMethods(methods);
				}
d4307 6
@


1.179
log
@Implemented Java 8 default interface methods.
@
text
@d5254 4
@


1.178
log
@- Allow static methods in interfaces (for Java 8 class files).
- Allow default interfaces methods (for Java 8 class files), but no actual support for them yet.
@
text
@d1128 1
a1128 1
									mw = new TypicalMethodWrapper(wrapper, ifmethod.Name, ifmethod.Signature, null, null, null, Modifiers.Public | Modifiers.Abstract, MemberFlags.HideFromReflection | MemberFlags.MirandaMethod);
d1133 5
d2767 1
a2767 1
							// We're a Miranda method
d2769 1
d2771 1
a2771 1
							if (wrapper.IsAbstract)
d2786 1
a2786 1
							if (!wrapper.IsAbstract)
d2789 1
a2789 1
								ilgen.EmitThrow("java.lang.AbstractMethodError", wrapper.Name + "." + methods[index].Name + methods[index].Signature);
d2909 4
a3952 4
						else if (!m.IsStatic && classFile.IsInterface)
						{
							// TODO Java 8 default interface method
						}
d3955 5
d3979 1
a3979 1
							ilGenerator.EmitLineNumberTable((MethodBuilder)methods[i].GetMethod());
d3995 5
d4291 61
d6212 1
a6212 1
			return DefineMethod(context.GetClassLoader().GetTypeWrapperFactory(), tb, name, attribs);
d6217 5
d6223 1
d6225 1
a6225 1
			Type[] parameterTypes = new Type[parameters.Length + (mw.HasCallerID ? 1 : 0)];
d6227 5
d6234 2
a6235 2
				parameterTypes[i] = parameters[i].TypeAsSignatureType;
				modopt[i] = DynamicTypeWrapper.GetModOpt(context, parameters[i], false);
@


1.177
log
@Removed "effectively final" optimization because it breaks the ability to dynamically load subclasses.
@
text
@d2890 1
a2890 1
				if (m.IsAbstract)
d3943 4
@


1.176
log
@Cache dynamic class literals.
@
text
@a757 6
						if (f.IsEffectivelyFinal)
						{
							setModifiers = true;
							typeAttribs |= TypeAttributes.Sealed;
							Tracer.Info(Tracer.Compiler, "Sealing type {0}", f.Name);
						}
@


1.175
log
@Bug fix. .NET enums used in Java annotations were not usable from .NET custom attribute.
@
text
@d3591 1
d3629 30
@


1.174
log
@Minor cleanup.
@
text
@d1932 1
a1932 1
						else if (tw.EnumType != null)
d1936 4
d1952 5
d1979 1
a1979 1
					else if (tw.EnumType != null)
d1983 4
@


1.173
log
@Don't add ObsoleteAttribute to deprecated types/members that already have an explicit ObsoleteAttribute annotation.
@
text
@d2183 5
d2193 1
a2193 2
						annotation = QualifyClassNames(loader, annotation);
						tb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor.__AsConstructorInfo(), new object[] { annotation }));
d2202 1
a2202 2
						annotation = QualifyClassNames(loader, annotation);
						mb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor.__AsConstructorInfo(), new object[] { annotation }));
d2211 1
a2211 2
						annotation = QualifyClassNames(loader, annotation);
						fb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor.__AsConstructorInfo(), new object[] { annotation }));
d2220 1
a2220 2
						annotation = QualifyClassNames(loader, annotation);
						pb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor.__AsConstructorInfo(), new object[] { annotation }));
d2229 1
a2229 2
						annotation = QualifyClassNames(loader, annotation);
						ab.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor.__AsConstructorInfo(), new object[] { annotation }));
d2238 1
a2238 2
						annotation = QualifyClassNames(loader, annotation);
						pb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor.__AsConstructorInfo(), new object[] { annotation }));
@


1.172
log
@Removed CallerID optimization special casing since we can now call internal members from dynamic assemblies.
@
text
@d865 1
a865 1
					if (classFile.DeprecatedAttribute)
d1504 1
a1504 1
					if (fld.DeprecatedAttribute)
d2829 1
a2829 1
					if (m.DeprecatedAttribute)
@


1.171
log
@- Added java.io.Serializable and java.lang.Cloneable to the core classes.
- Replaced LoadClassCritical("ikvm.internal.CallerID") with a core class reference.
@
text
@d5310 9
d5320 1
a5320 17
					// we need to prohibit this optimization at runtime, because proxy classes may be injected into the boot class loader,
					// but they don't actually have access to core library internals
#if STATIC_COMPILER
					TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
					if (tw.GetClassLoader() == wrapper.GetClassLoader())
					{
						MethodWrapper create = tw.GetMethodWrapper("create", "(Lcli.System.RuntimeTypeHandle;)Likvm.internal.CallerID;", false);
						ilGenerator.Emit(OpCodes.Ldtoken, this.typeBuilder);
						create.Link();
						create.EmitCall(ilGenerator);
					}
					else
#endif
					{
						RegisterNestedTypeBuilder(EmitCreateCallerID(typeBuilder, ilGenerator));
					}
					ilGenerator.Emit(OpCodes.Stsfld, callerIDField);
d5322 1
@


1.170
log
@Marked some fields readonly and removed a redundant cast.
@
text
@d415 1
a415 1
				return this.IsSubTypeOf(ClassLoaderWrapper.LoadClassCritical("java.io.Serializable"));
d4817 1
a4817 1
					argTypes[argTypes.Length - 1] = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.CallerID").TypeAsSignatureType;
@


1.169
log
@Simplified jniproxy assembly debug dump.
@
text
@d58 1
a58 1
		private TypeWrapper[] interfaces;
d3227 2
a3228 2
			private string[][] genericMetaData;
			private object[][] annotations;
d3438 7
a3444 7
			private Type type;
			private TypeWrapper[] innerclasses;
			private TypeWrapper declaringTypeWrapper;
			private Modifiers reflectiveModifiers;
			private MethodInfo clinitMethod;
			private MethodInfo finalizeMethod;
			private Metadata metadata;
d5709 1
a5709 1
					parameterNames[i] = (string)names[i];
@


1.168
log
@Moved invokespecial stub cache into FinishContext.
@
text
@d4792 1
a4792 1
				private static ModuleBuilder mod;
d4797 1
a4797 5
					AssemblyName name = new AssemblyName();
					name.Name = "jniproxy";
					AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, JVM.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
					DynamicClassLoader.RegisterForSaveDebug(ab);
					mod = ab.DefineDynamicModule("jniproxy.dll", "jniproxy.dll");
d4804 1
a4804 1
					TypeBuilder tb = mod.DefineType("__<jni>" + (count++), TypeAttributes.Public | TypeAttributes.Class);
@


1.167
log
@Improve previous commit to handle internal access method overriding.
@
text
@d3578 1
a3734 1
				Dictionary<MethodKey, MethodInfo> invokespecialstubcache = new Dictionary<MethodKey, MethodInfo>();
d3761 1
a3761 1
						CompileConstructorBody(this, ilGenerator, i, invokespecialstubcache);
d3919 1
a3919 1
							Compiler.Compile(this, wrapper, methods[i], classFile, m, ilGenerator, ref nonleaf, invokespecialstubcache);
d3964 1
a3964 1
						CompileConstructorBody(this, ilGenerator, clinitIndex, invokespecialstubcache);
d5265 1
a5265 1
			private void CompileConstructorBody(FinishContext context, CodeEmitter ilGenerator, int methodIndex, Dictionary<MethodKey, MethodInfo> invokespecialstubcache)
d5279 1
a5279 1
				Compiler.Compile(context, wrapper, methods[methodIndex], classFile, m, ilGenerator, ref nonLeaf, invokespecialstubcache);
d5504 1
a5504 1
			internal MethodBuilder DefineInvokeSpecialStub(DefineMethodHelper sig)
d5506 1
a5506 1
				return sig.DefineMethod(wrapper, typeBuilder, "__<>", MethodAttributes.PrivateScope);
d5509 1
a5509 1
			internal MethodBuilder DefineDelegateInvokeErrorStub(Type returnType, Type[] parameterTypes)
d5511 23
a5533 1
				return typeBuilder.DefineMethod("__<>", MethodAttributes.PrivateScope | MethodAttributes.Static, returnType, parameterTypes);
@


1.166
log
@Bug fix. When looking for a method to override we should handle internal access methods.
@
text
@d2334 1
a2334 1
					else if (!baseMethod.IsStatic && (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.IsInternal))
d2356 1
a2356 1
					else if (baseMethod.IsFinal && (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.IsInternal || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)))
d2364 1
a2364 1
					else if (topPublicOrProtectedMethod == null && !baseMethod.IsPublic && !baseMethod.IsProtected && !baseMethod.IsInternal && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
d2369 1
a2369 1
					else if (topPublicOrProtectedMethod != null && baseMethod.IsFinal && !baseMethod.IsPublic && !baseMethod.IsProtected && !baseMethod.IsInternal && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
d2431 1
a2431 1
						if (!baseMethod.IsPublic && !baseMethod.IsProtected && !baseMethod.IsInternal &&
d2465 1
a2465 1
										if (baseMethod2.IsPublic || baseMethod2.IsProtected || baseMethod2.IsInternal)
d2482 5
@


1.165
log
@MethodHandle and MethodType are core classes.
@
text
@d2334 1
a2334 1
					else if (!baseMethod.IsStatic && (baseMethod.IsPublic || baseMethod.IsProtected))
d2356 1
a2356 1
					else if (baseMethod.IsFinal && (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)))
d2364 1
a2364 1
					else if (topPublicOrProtectedMethod == null && !baseMethod.IsPublic && !baseMethod.IsProtected && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
d2369 1
a2369 1
					else if (topPublicOrProtectedMethod != null && baseMethod.IsFinal && !baseMethod.IsPublic && !baseMethod.IsProtected && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
d2431 1
a2431 1
						if (!baseMethod.IsPublic && !baseMethod.IsProtected &&
d2465 1
a2465 1
										if (baseMethod2.IsPublic || baseMethod2.IsProtected)
@


1.164
log
@Added support for dynamic ldc MethodHandle.
@
text
@d5491 1
a5491 1
				return typeBuilder.DefineField("__<>dynamicMethodHandleCache", ClassLoaderWrapper.LoadClassCritical("java.lang.invoke.MethodHandle").TypeAsSignatureType, FieldAttributes.Static | FieldAttributes.PrivateScope);
d5496 1
a5496 1
				return typeBuilder.DefineField("__<>dynamicMethodTypeCache", ClassLoaderWrapper.LoadClassCritical("java.lang.invoke.MethodType").TypeAsSignatureType, FieldAttributes.Static | FieldAttributes.PrivateScope);
@


1.163
log
@Improved ldc MethodType:
- use nested type with class constructor to create values with statically know signatures (like ldc MethodHandle).
- use caching for dynamicallly constructed MethodType values but retry on failure.
@
text
@d5489 5
@


1.162
log
@Bug fix. Mark "missing" interface methods so that subclasses (that are compiled separately) know that the base class is incomplete.
@
text
@d5472 7
d5489 5
@


1.161
log
@Bug fix. We should emit miranda methods for non-abstract classes too.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2012 Jeroen Frijters
d4604 1
a4604 1
						MethodBuilder mb = DefineInterfaceStubMethod(mangledName, ifmethod);
d4662 1
a4662 1
						MethodBuilder mb = DefineInterfaceStubMethod(mangledName, ifmethod);
@


1.160
log
@Changed all type flag accessors to readonly and added set methods that can set (but not clear) the flags. Added locking around modifying the flags fields.
@
text
@d536 1
a536 1
				if (wrapper.IsAbstract && (!wrapper.IsInterface || wrapper.IsPublic))
d2753 6
a2758 1
							MethodBuilder mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper, typeBuilder, methods[index].Name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride);
d2769 6
@


1.159
log
@Made TypeWrapper.IsInternal a readonly property.
@
text
@d532 4
a535 1
				wrapper.HasStaticInitializer = hasclinit;
d4599 1
a4599 1
						wrapper.HasIncompleteInterfaceImplementation = true;
d4657 1
a4657 1
						wrapper.HasIncompleteInterfaceImplementation = true;
@


1.158
log
@Have ikvmc record the outer class even if it is not loadable.
@
text
@d109 1
a109 1
			: base(f.Modifiers, f.Name)
a112 1
			this.IsInternal = f.IsInternal;
@


1.157
log
@Have ikvmc record inner classes even if they can't be loaded.
@
text
@d783 4
@


1.156
log
@Removed unused (and bogus) parameter from TypeWrapper.EmitCheckcast() and EmitInstanceOf().
@
text
@d783 17
@


1.155
log
@Implemented package access checks (dynamic mode only).
@
text
@d2125 1
a2125 1
								o.methods[i].ReturnType.EmitCheckcast(null, ilgen);
@


1.154
log
@Now that dynamically loaded classes in an assembly class loader have access to the internals of the assembly, we no longer need proxy helper interfaces and we can allow extending non-public base classes and implementing non-public interfaces.
@
text
@d31 1
d36 1
d65 1
a65 1
		private TypeWrapper LoadTypeWrapper(ClassLoaderWrapper classLoader, string name)
d73 1
d105 1
a105 1
		internal DynamicTypeWrapper(ClassFile f, CompilerClassLoader classLoader)
d107 1
a107 1
		internal DynamicTypeWrapper(ClassFile f, ClassLoaderWrapper classLoader)
d115 1
a115 1
			this.baseTypeWrapper = f.IsInterface ? null : LoadTypeWrapper(classLoader, f.SuperClass);
d162 1
a162 1
				TypeWrapper iface = LoadTypeWrapper(classLoader, interfaces[i].Name);
@


1.153
log
@Disabled automatic assembly loading for ikvmc. All dependencies must now be explicitly referenced (except for the stub jar loophole and secondary assemblies in a shared class loader group).
@
text
@a118 7
#if !STATIC_COMPILER
				if (!BaseTypeWrapper.IsPublic && !ReflectUtil.IsFromAssembly(BaseTypeWrapper.TypeAsBaseType, classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly))
				{
					// NOTE this can only happen if evil code calls ClassLoader.defineClass() on an assembly class loader (which we allow for compatibility with other slightly less evil code)
					throw new IllegalAccessError("Class " + f.Name + " cannot access its non-public superclass " + BaseTypeWrapper.Name + " from another assembly");
				}
#endif
a163 17
#if !STATIC_COMPILER
				if (!iface.IsPublic && !ReflectUtil.IsFromAssembly(iface.TypeAsBaseType, classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly))
				{
					string proxyName = DynamicClassLoader.GetProxyHelperName(iface.TypeAsTBD);
					Type proxyType = ReflectUtil.GetAssembly(iface.TypeAsBaseType).GetType(proxyName);
					// FXBUG we need to check if the type returned is actually correct, because .NET 2.0 has a bug that
					// causes it to return typeof(IFoo) for GetType("__<Proxy>+IFoo")
					if (proxyType == null || proxyType.FullName != proxyName)
					{
						// NOTE this happens when you call Proxy.newProxyInstance() on a non-public .NET interface
						// (for ikvmc compiled Java types, ikvmc generates public proxy stubs).
						// NOTE we don't currently check interfaces inherited from other interfaces because mainstream .NET languages
						// don't allow public interfaces extending non-public interfaces.
						throw new IllegalAccessError("Class " + f.Name + " cannot access its non-public superinterface " + iface.Name + " from another assembly");
					}
				}
#endif
a4174 4
					if (classFile.IsInterface && !classFile.IsPublic)
					{
						((DynamicClassLoader)wrapper.classLoader.GetTypeWrapperFactory()).DefineProxyHelper(type);
					}
d5099 1
a5099 8
						Type ifaceType = iface.TypeAsBaseType;
#if !STATIC_COMPILER
						if (!iface.IsPublic && !ReflectUtil.IsSameAssembly(ifaceType, typeBuilder))
						{
							ifaceType = ReflectUtil.GetAssembly(ifaceType).GetType(DynamicClassLoader.GetProxyHelperName(ifaceType));
						}
#endif
						typeBuilder.AddInterfaceImplementation(ifaceType);
@


1.152
log
@If the missing type is a constructed type, extract the real missing type from it.
@
text
@d83 4
@


1.151
log
@Fixed the base type check (if the immediate parent failed we didn't have a valid prev).
@
text
@d82 2
a83 2
					throw new FatalCompilerErrorException(Message.MissingBaseType,
						missing.MissingType.FullName, missing.MissingType.Assembly.FullName,
@


1.150
log
@When generating a signature with a missing unloadable type, use the missing type instead of object with a custom modifier.
@
text
@d63 1
a63 1
		private static TypeWrapper LoadTypeWrapper(ClassLoaderWrapper classLoader, string name)
d70 1
a70 1
			CheckMissing(tw);
d74 1
a74 1
		private static void CheckMissing(TypeWrapper tw)
a76 1
			TypeWrapper prev = tw;
d88 1
a88 1
					CheckMissing(iface);
@


1.149
log
@Give the appropriate error messages if trying to extend or implement a missing type.
@
text
@d5988 4
a5991 1
				modopt = new Type[] { ((UnloadableTypeWrapper)tw).GetCustomModifier(context) };
@


1.148
log
@Bug fix. Static compiler should not use proxy stubs to implement non-public interfaces in another assembly (because this situation can only arise when compiling the assemblies together and the InternalsVisibileToAttribute will be used and proxy stubs are not understood by CompiledTypeWrapper, so they can only be used in dynamic mode).
@
text
@d70 1
d74 24
@


1.147
log
@Bug fix. The static compiler cannot use a different way to encode erased array types than the runtime compiler (because otherwise the runtime can't override statically compiled methods).
@
text
@d5100 1
d5105 1
@


1.146
log
@Bug fix. Abstract generic methods are not supported. Fix for #3579785.
@
text
@a5967 3
#if STATIC_COMPILER
					modopt = new Type[] { GetModOptHelper(tw) };
#else
a5968 1
					// (note that in this case we only add the custom modifiers to make the signature unique, we never read back this information)
d5973 1
a5973 1
						modopt[i] = typeof(Array);
a5974 1
#endif
@


1.145
log
@Removed some O(n^2) operations to improve handling of class files with a large number of fields.
@
text
@d5197 4
d5207 21
@


1.144
log
@Bug fix. Transient field modifier should also be retained on literal fields.
@
text
@d1343 1
a1343 1
				for (int i = 0; i < fieldIndex; i++)
d1345 7
a1351 1
					fields[i].Link();
@


1.143
log
@Removed unnecessary MethodBuilder casts.
@
text
@d1454 5
a1458 5
					if (fld.IsTransient)
					{
						CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(JVM.Import(typeof(NonSerializedAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
						field.SetCustomAttribute(transientAttrib);
					}
@


1.142
log
@Removed remaining ConstructorBuilder usages.
@
text
@d3689 1
a3689 1
					MethodBase mb = methods[i].GetMethod();
d3708 1
a3708 1
						CodeEmitter ilGenerator = CodeEmitter.Create((MethodBuilder)mb);
d3730 1
a3730 1
								CodeEmitter ilGenerator = CodeEmitter.Create((MethodBuilder)mb);
d3744 1
a3744 1
								((MethodBuilder)mb).SetImplementationFlags(mb.GetMethodImplementationFlags() | MethodImplAttributes.Runtime);
d3750 1
a3750 1
								CodeEmitter ilGenerator = CodeEmitter.Create((MethodBuilder)mb);
d3856 1
a3856 2
							MethodBuilder mbld = (MethodBuilder)mb;
							CodeEmitter ilGenerator = CodeEmitter.Create(mbld);
d3872 1
a3872 1
								mbld.SetImplementationFlags(mbld.GetMethodImplementationFlags() | MethodImplAttributes.NoInlining);
a4064 1
					MethodBuilder mBuilder = mb as MethodBuilder;
d4072 2
a4073 5
								if (mBuilder != null)
								{
									annotation.Apply(wrapper.GetClassLoader(), mBuilder, def);
									annotation.ApplyReturnValue(wrapper.GetClassLoader(), mBuilder, ref returnParameter, def);
								}
d4099 1
a4099 1
						AttributeHelper.SetEditorBrowsableNever((MethodBuilder)mb);
d4104 1
a4104 1
						mBuilder.__AddUnmanagedExport(m.DllExportName, m.DllExportOrdinal);
@


1.141
log
@Do the "no serialization" check before calling Serialization.AddAutomagicSerialization() to avoid triggering the class initializer (which will try to load SerializableAttribute, which is not available everywhere).
@
text
@d61 1
a61 1
		private ConstructorInfo automagicSerializationCtor;
d919 1
a919 1
				private ConstructorBuilder constructor;
d930 1
a930 1
					constructor = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, new Type[] { Types.Object, Types.IntPtr }, null, null);
d1710 1
a1710 1
				private ConstructorBuilder defineConstructor;
d1872 1
a1872 1
					defineConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { JVM.Import(typeof(object[])) });
d1977 1
a1977 1
					ConstructorBuilder defaultConstructor = attributeTypeBuilder.DefineConstructor(unsupported || requiredArgCount > 0 ? MethodAttributes.Private : MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
d1995 1
a1995 1
							ConstructorBuilder reqArgConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, args);
d2022 1
a2022 1
								ConstructorBuilder cb = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { argType });
d2153 1
a2153 1
						tb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
d2163 1
a2163 11
						mb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
					}
				}

				internal override void Apply(ClassLoaderWrapper loader, ConstructorBuilder cb, object annotation)
				{
					Link();
					if (annotationTypeBuilder != null)
					{
						annotation = QualifyClassNames(loader, annotation);
						cb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
d2173 1
a2173 1
						fb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
d2183 1
a2183 1
						pb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
d2193 1
a2193 1
						ab.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
d2203 1
a2203 1
						pb.SetCustomAttribute(new CustomAttributeBuilder(defineConstructor, new object[] { annotation }));
d2736 1
a2736 1
					MethodBase method;
d2767 1
a2767 8
						if (method is ConstructorBuilder)
						{
							AttributeHelper.SetModifiers((ConstructorBuilder)method, m.Modifiers, m.IsInternal);
						}
						else
						{
							AttributeHelper.SetModifiers((MethodBuilder)method, m.Modifiers, m.IsInternal);
						}
d2774 1
a2774 8
						if (method is ConstructorBuilder)
						{
							AttributeHelper.SetEditorBrowsableNever((ConstructorBuilder)method);
						}
						else
						{
							AttributeHelper.SetEditorBrowsableNever((MethodBuilder)method);
						}
d2799 1
a2799 1
			private MethodBase GenerateConstructor(MethodWrapper mw)
d2806 1
a2806 1
			private MethodBase GenerateMethod(int index, ClassFile.Method m, ref bool setModifiers)
d3525 1
a3525 1
			private Dictionary<FieldWrapper, ConstructorBuilder> arfuMap;
d3876 1
a3876 1
							ilGenerator.EmitLineNumberTable(methods[i].GetMethod());
d3936 1
a3936 2
						ConstructorBuilder cb = typeBuilder.DefineConstructor(MethodAttributes.PrivateScope, CallingConventions.Standard, Type.EmptyTypes);
						CodeEmitter ilgen = CodeEmitter.Create(cb);
d4004 1
a4004 1
								ilgenClinit = CodeEmitter.Create(tbFields.DefineTypeInitializer());
d4030 1
a4030 1
					MethodBase mb = methods[i].GetMethod();
a4065 1
					ConstructorBuilder cb = mb as ConstructorBuilder;
a4073 4
								if (cb != null)
								{
									annotation.Apply(wrapper.GetClassLoader(), cb, def);
								}
d5219 1
a5219 1
				ilGenerator.EmitLineNumberTable(methods[methodIndex].GetMethod());
d5276 1
a5276 1
				ConstructorBuilder cb = typeCallerID.DefineConstructor(MethodAttributes.Assembly, CallingConventions.Standard, null);
d5345 1
a5345 1
			internal ConstructorBuilder DefineThreadLocalType()
d5361 1
a5361 1
				ConstructorBuilder cb = tb.DefineConstructor(MethodAttributes.Assembly, CallingConventions.Standard, Type.EmptyTypes);
d5373 1
a5373 1
			internal ConstructorBuilder GetAtomicReferenceFieldUpdater(FieldWrapper field)
d5377 1
a5377 1
					arfuMap = new Dictionary<FieldWrapper, ConstructorBuilder>();
d5379 1
a5379 1
				ConstructorBuilder cb;
d5385 1
a5385 1
					cb = tb.DefineConstructor(MethodAttributes.Assembly, CallingConventions.Standard, Type.EmptyTypes);
d5616 1
a5616 1
		protected static ParameterBuilder[] GetParameterBuilders(MethodBase mb, int parameterCount, string[] parameterNames)
d5641 1
a5641 9
				MethodBuilder mBuilder = mb as MethodBuilder;
				if (mBuilder != null)
				{
					parameterBuilders[i] = mBuilder.DefineParameter(i + 1, ParameterAttributes.None, name);
				}
				else
				{
					parameterBuilders[i] = ((ConstructorBuilder)mb).DefineParameter(i + 1, ParameterAttributes.None, name);
				}
d5920 1
a5920 1
		internal override ConstructorInfo GetSerializationConstructor()
@


1.140
log
@Apply custom attribute annotations on annotation types to the corresponding custom attribute that is generated (and allow AttributeUsageAttribute to override the default AttributeUsageAttribute generated from the @@Target annotation).
@
text
@d3993 4
a3996 1
					wrapper.automagicSerializationCtor = Serialization.AddAutomagicSerialization(wrapper, typeBuilder);
@


1.140.2.1
log
@Changes:
- Set version to 7.2.4630.2.
- Bug fix. Class.forName("") should not throw System.ArgumentException.
- Bug fix. Transient field modifier should be retained on literal fields.
- Bug fix. Field.getModifiers() should only return the relevant modifiers.
- IKVM.Reflection: Bug fix. Ignore unknown metadata streams.
- IKVM.Reflection: Bug fix. Set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@d1454 5
a1458 5
				}
				if (fld.IsTransient)
				{
					CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(JVM.Import(typeof(NonSerializedAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
					field.SetCustomAttribute(transientAttrib);
@


1.140.2.2
log
@- Changed version to 7.2.4630.4.
Backported fixes for new rc:
- Added (optional) support for building without System.Core.dll dependency.
- Bug fix. Abstract generic methods are not supported. Fix for #3579785.
- Bug fix. Interface mappings can be "incomplete". Fix for bug #3581564.
- Bug fix. Verifier should not merge state from instruction following exception block to handler. Fix for bug #3580611.
@
text
@a5222 4
				if (mb.IsGenericMethodDefinition)
				{
					CopyGenericArguments(mb, m);
				}
a5228 21
			private static void CopyGenericArguments(MethodBase mi, MethodBuilder mb)
			{
				Type[] genericParameters = mi.GetGenericArguments();
				string[] genParamNames = new string[genericParameters.Length];
				for (int i = 0; i < genParamNames.Length; i++)
				{
					genParamNames[i] = genericParameters[i].Name;
				}
				GenericTypeParameterBuilder[] genParamBuilders = mb.DefineGenericParameters(genParamNames);
				for (int i = 0; i < genParamBuilders.Length; i++)
				{
					// NOTE apparently we don't need to set the interface constraints
					// (and if we do, it fails for some reason)
					if (genericParameters[i].BaseType != Types.Object)
					{
						genParamBuilders[i].SetBaseTypeConstraint(genericParameters[i].BaseType);
					}
					genParamBuilders[i].SetGenericParameterAttributes(genericParameters[i].GenericParameterAttributes);
				}
			}

@


1.140.2.3
log
@Backported: Bug fix. The static compiler cannot use a different way to encode erased array types than the runtime compiler (because otherwise the runtime can't override statically compiled methods).
@
text
@d6002 3
d6006 1
d6011 1
a6011 1
						modopt[i] = Types.Array;
d6013 1
@


1.140.2.4
log
@Updated version to 7.2.4630.6 and changed copyright year to 2013.
Backported bug fixes:
- Don't deadlock AppDomain.ProcessExit event handler when the event gets called from another thread than the one initiating exit.
- Static compiler should not use proxy stubs to implement non-public interfaces in another assembly (because this situation can only arise when compiling the assemblies together and the InternalsVisibileToAttribute will be used and proxy stubs are not understood by CompiledTypeWrapper, so they can only be used in dynamic mode).
- Don't add duplicate methods to attribute annotation interfaces. The primary cause of this was attributes with virtual properties where we would add the base class property as well as the derived class overridden property.
- Local variable analysis for finally blocks was incorrect. Fixes bug #3600788.
@
text
@a5125 1
#if !STATIC_COMPILER
a5129 1
#endif
@


1.140.2.5
log
@Backported: Fixed regression in overriding internal access methods.
@
text
@d2330 1
a2330 1
					else if (baseMethod.IsFinal && (baseMethod.IsPublic || baseMethod.IsProtected || IsAccessibleInternal(baseMethod) || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)))
d2338 1
a2338 1
					else if (topPublicOrProtectedMethod == null && !baseMethod.IsPublic && !baseMethod.IsProtected && !IsAccessibleInternal(baseMethod) && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
d2343 1
a2343 1
					else if (topPublicOrProtectedMethod != null && baseMethod.IsFinal && !baseMethod.IsPublic && !baseMethod.IsProtected && !IsAccessibleInternal(baseMethod) && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
a2455 5
			private bool IsAccessibleInternal(MethodWrapper mw)
			{
				return mw.IsInternal && mw.DeclaringType.InternalsVisibleTo(wrapper);
			}

@


1.139
log
@Stop using ConstructorBuilder (always use MethodBuilder).
@
text
@d1794 2
d1798 1
a1798 1
							if (def[1].Equals("Ljava/lang/annotation/Target;"))
d1846 1
a1846 2
											CustomAttributeBuilder cab2 = new CustomAttributeBuilder(JVM.Import(typeof(AttributeUsageAttribute)).GetConstructor(new Type[] { JVM.Import(typeof(AttributeTargets)) }), new object[] { targets });
											attributeTypeBuilder.SetCustomAttribute(cab2);
d1851 18
d2216 5
@


1.138
log
@Moved GhostMethodWrapper out of MethodWrapper and removed MethodWrapper.Create() as it was used in only one place.
@
text
@d2801 1
a2801 1
				ConstructorBuilder cb = mw.GetDefineMethodHelper().DefineConstructor(wrapper, typeBuilder, GetMethodAccess(mw) | MethodAttributes.HideBySig);
d3698 1
a3698 1
					else if (mb is ConstructorBuilder)
d3700 9
a3708 12
						if (m.IsClassInitializer)
						{
							// we handle the <clinit> after we've done the other methods,
							// to make it easier to inject code needed by the other methods
							clinitIndex = i;
							continue;
						}
						else
						{
							hasConstructor = true;
						}
						CodeEmitter ilGenerator = CodeEmitter.Create((ConstructorBuilder)mb);
d3894 1
a3894 1
					ConstructorBuilder cb;
d3897 1
a3897 1
						cb = (ConstructorBuilder)methods[clinitIndex].GetMethod();
d6037 1
a6037 1
		internal ConstructorBuilder DefineConstructor(DynamicTypeWrapper context, TypeBuilder tb, MethodAttributes attribs)
d6042 1
a6042 1
		internal ConstructorBuilder DefineConstructor(TypeWrapperFactory context, TypeBuilder tb, MethodAttributes attribs)
d6044 1
a6044 11
			// we add optional modifiers to make the signature unique
			// (note that constructors do not support callerid)
			TypeWrapper[] parameters = mw.GetParameters();
			Type[] parameterTypes = new Type[parameters.Length];
			Type[][] modopt = new Type[parameterTypes.Length][];
			for (int i = 0; i < parameters.Length; i++)
			{
				parameterTypes[i] = parameters[i].TypeAsSignatureType;
				modopt[i] = DynamicTypeWrapper.GetModOpt(context, parameters[i], false);
			}
			return tb.DefineConstructor(attribs, CallingConventions.Standard, parameterTypes, null, modopt);
@


1.137
log
@Added ClassFile.Method.IsConstructor helper property.
@
text
@d506 1
a506 1
						methods[i] = new MethodWrapper.GhostMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, flags);
@


1.136
log
@Merged SmartCallMethodWrapper and SmartConstructorMethodWrapper into TypicalMethodWrapper.
@
text
@d508 1
a508 1
					else if (ReferenceEquals(m.Name, StringConstants.INIT) && wrapper.IsDelegate)
a511 4
					else if (ReferenceEquals(m.Name, StringConstants.INIT) || m.IsClassInitializer)
					{
						methods[i] = new TypicalMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, flags);
					}
d514 1
a514 1
						if (!classFile.IsInterface && !m.IsStatic && !m.IsPrivate)
d2730 1
a2730 1
					if (ReferenceEquals(m.Name, StringConstants.INIT))
d3693 1
a3693 1
						if (m.Name == StringConstants.INIT)
@


1.135
log
@Bug fix. There was a logic error in FindBaseMethods7() that caused LinkAndGetMethod() to be called if TryGetClassFileVersion() succeeded and the class version was greater than 51.
@
text
@d514 1
a514 1
						methods[i] = new SmartConstructorMethodWrapper(wrapper, m.Name, m.Signature, null, null, m.Modifiers, flags);
d527 1
a527 1
						methods[i] = new SmartCallMethodWrapper(wrapper, m.Name, m.Signature, null, null, null, m.Modifiers, flags, SimpleOpCode.Call, SimpleOpCode.Callvirt);
d1108 1
a1108 1
									mw = new SmartCallMethodWrapper(wrapper, ifmethod.Name, ifmethod.Signature, null, null, null, Modifiers.Public | Modifiers.Abstract, MemberFlags.HideFromReflection | MemberFlags.MirandaMethod, SimpleOpCode.Call, SimpleOpCode.Callvirt);
@


1.134
log
@Fixed some minor class modifiers issues:
- stub generator now reproduces exact class modifier bits
- unused bits are now properly masked and returned
- non-abstract interfaces now properly return ACC_ABSTRACT
@
text
@d2384 1
a2384 1
						int majorVersion;
d2386 1
a2386 1
							((TryGetClassFileVersion(baseMethod.DeclaringType, out majorVersion) && majorVersion < 51)
d2389 1
a2389 1
							|| (LinkAndGetMethod(baseMethod).Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Assembly))
d2442 1
a2442 1
			private static bool TryGetClassFileVersion(TypeWrapper tw, out int majorVersion)
a2453 1
				majorVersion = -1;
@


1.133
log
@- Made CodeEmitter more "type safe" by adding specific EmitXxx methods instead of following the more general ILGenerator pattern.
- Added some new optimizations to CodeEmitter (disabled unless experimental optimizations are enabled).
- Added some invariant checks to CodeEmitter to help debug optimizations (and document the invariants).
@
text
@d714 4
d749 4
d755 1
a755 9
							if (outer == null)
							{
								setModifiers = true;
							}
							else
							{
								// we don't need a ModifiersAttribute, because the InnerClassAttribute already records
								// the modifiers
							}
d2224 1
d2234 8
a2241 1
									return innerclasses[i].accessFlags;
d2246 8
a2253 1
					return classFile.Modifiers;
@


1.132
log
@Moved TypeBuilder.DefineTypeInitializer() workaround to ReflectUtil.
@
text
@d1186 1
a1186 1
							ilgen.Emit(OpCodes.Ldarg_S, (byte)(i + 1));
d1201 1
a1201 1
							ilgen.Emit(OpCodes.Ldarg_S, (byte)(i + 1));
d1213 1
a1213 1
					ilgen.Emit(OpCodes.Leave_S, exit);
d1220 1
a1220 1
							ilgen.Emit(OpCodes.Ldarg_S, (byte)(i + 1));
d1914 1
a1914 1
					ilgen.Emit(OpCodes.Ldarg_S, (byte)argIndex);
d3018 1
a3018 1
						ilgen.Emit(OpCodes.Brtrue_S, skip);
d3024 1
a3024 1
							ilgen.Emit(OpCodes.Leave, skip);
d3026 1
a3026 1
							ilgen.Emit(OpCodes.Leave, skip);
d3571 1
a3571 1
				ilgen.Emit(OpCodes.Brtrue_S, done);
d3801 1
a3801 1
										ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
d4434 1
a4434 1
					ilgen.Emit(OpCodes.Ldarg_S, (byte)argpos++);
d4438 1
a4438 1
					ilgen.Emit(OpCodes.Ldarg_S, (byte)argpos++);
d4579 1
a4579 1
							ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
d4599 1
a4599 1
							ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(n + 1));
d4784 1
a4784 1
						ilGenerator.Emit(OpCodes.Ldarg, (short)i);
d4835 1
a4835 1
					ilGenerator.Emit(OpCodes.Brtrue, oklabel);
d4838 1
a4838 1
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(args.Length + (mw.IsStatic ? 0 : 1)));
d4853 1
a4853 1
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(args.Length + (mw.IsStatic ? 0 : 1)));
d4898 1
a4898 1
								ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
d4903 1
a4903 1
								ilGenerator.Emit(OpCodes.Ldarga_S, (byte)(j + add));
d4908 1
a4908 1
								ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
d4915 1
a4915 1
							ilGenerator.Emit(OpCodes.Ldarg_S, (byte)(j + add));
d4962 1
a4962 1
					ilGenerator.Emit(OpCodes.Leave, retLabel);
d5006 1
a5006 1
						ilgen.Emit(OpCodes.Brfalse_S, label);
d5065 1
a5065 1
					ilgen.Emit(OpCodes.Ldarg, (short)i);
d5297 1
a5297 1
								ilGenerator.Emit_Ldc_I4((int)constant);
d5301 1
a5301 1
								ilGenerator.Emit_Ldc_I4((bool)constant ? 1 : 0);
d5305 1
a5305 1
								ilGenerator.Emit_Ldc_I4((byte)constant);
d5309 1
a5309 1
								ilGenerator.Emit_Ldc_I4((char)constant);
d5313 1
a5313 1
								ilGenerator.Emit_Ldc_I4((short)constant);
d5317 1
a5317 1
								ilGenerator.Emit(OpCodes.Ldc_I8, (long)constant);
d5321 1
a5321 1
								ilGenerator.Emit(OpCodes.Ldc_R8, (double)constant);
d5325 1
a5325 1
								ilGenerator.Emit(OpCodes.Ldc_R4, (float)constant);
d5481 1
a5481 1
				ilgen.Emit(OpCodes.Ldarg_S, (byte)(i + 1));
@


1.131
log
@Improved the handling of final fields that need to be wrapped by a property.
@
text
@a2241 15
			internal static ConstructorBuilder DefineClassInitializer(TypeBuilder typeBuilder)
			{
				if (typeBuilder.IsInterface)
				{
					// LAMESPEC the ECMA spec says (part. I, sect. 8.5.3.2) that all interface members must be public, so we make
					// the class constructor public.
					// NOTE it turns out that on .NET 2.0 this isn't necessary anymore (neither Ref.Emit nor the CLR verifier complain about it),
					// but the C# compiler still considers interfaces with non-public methods to be invalid, so to keep interop with C# we have
					// to keep making the .cctor method public.
					return typeBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
				}
				// NOTE we don't need to record the modifiers here, because they aren't visible from Java reflection
				return typeBuilder.DefineTypeInitializer();
			}

d2731 1
a2731 1
						method = DefineClassInitializer(typeBuilder);
d3894 1
a3894 1
						cb = JavaTypeImpl.DefineClassInitializer(typeBuilder);
@


1.130
log
@Added ClassFile.Field.IsStaticFinalConstant property to avoid duplicating the check.
@
text
@d5999 4
a6002 3
			return (fw.HasNonPublicTypeInSignature || (fw.IsFinal && !this.IsInterface && !classLoader.StrictFinalFieldSemantics && !(fw is ConstantFieldWrapper) && !(fw is DynamicPropertyFieldWrapper)))
				&& (fw.IsPublic || (fw.IsProtected && !this.IsFinal))
				&& (fw.FieldTypeWrapper.IsUnloadable || fw.FieldTypeWrapper.IsAccessibleFrom(this) || fw.FieldTypeWrapper.InternalsVisibleTo(this));
@


1.129
log
@Interface fields can always be marked as initonly and don't need final access stubs.
@
text
@d549 1
a549 1
					if (fld.IsStatic && fld.IsFinal && fld.ConstantValue != null)
d1418 1
a1418 2
				object constantValue = fld.ConstantValue;
				if (fld.IsStatic && fld.IsFinal && constantValue != null)
d1423 1
a1423 1
					field.SetConstant(constantValue);
@


1.128
log
@Bug fix. The interface fields exposed in the __Fields nested type should have a public field type.
@
text
@d6000 1
a6000 1
			return (fw.HasNonPublicTypeInSignature || (fw.IsFinal && !classLoader.StrictFinalFieldSemantics && !(fw is ConstantFieldWrapper) && !(fw is DynamicPropertyFieldWrapper)))
@


1.127
log
@Bug fix. When an unloadable type is used in a method signature that overrides a method (or implements an interface method), the custom modifier must be the same as the base class or an override stub must be generated.
@
text
@d4008 1
a4008 1
							FieldBuilder fb = tbFields.DefineField(f.Name, fields[i].FieldTypeWrapper.TypeAsSignatureType, attribs);
@


1.126
log
@Added support for type 2 access stubs for constructors.
@
text
@d1285 4
d1307 4
d5450 1
a5450 1
			if (mw1.ReturnType != mw2.ReturnType && !(mw1.ReturnType.IsUnloadable && mw2.ReturnType.IsUnloadable))
d5458 1
a5458 1
				if (args1[i] != args2[i] && !(args1[i].IsUnloadable && args2[i].IsUnloadable))
d5466 16
d5955 1
a5955 1
				modopt = new Type[] { context.DefineUnloadable(tw.Name) };
@


1.125
log
@Fix for recently introduced bug (with access stub rewrite). Bug #3512589.
@
text
@a4376 1
						&& mw.Name != StringConstants.INIT	// TODO we don't currently support constructors
d4380 1
a4380 1
						if (!mw.IsStatic && !mw.IsFinal && !mw.IsAbstract && !wrapper.IsFinal)
d4412 12
a4423 3
				string name = virt
					? (mw.Modifiers & Modifiers.Bridge) == 0 ? mw.Name : NamePrefix.Bridge + mw.Name
					: NamePrefix.NonVirtual + id;
d4453 1
a4453 1
				if (mw.IsStatic || !virt)
@


1.124
log
@More ikvmc error handling clean up.
@
text
@d5970 1
a5970 1
				&& (fw.FieldTypeWrapper.IsAccessibleFrom(this) || fw.FieldTypeWrapper.InternalsVisibleTo(this));
@


1.123
log
@When instantiating a delegate and the object passed in does not properly implement the delegate's Method interface, bind the delegate to an error stub that throws the appropriate error.
@
text
@d911 3
d918 1
d1639 1
a1639 6
#if STATIC_COMPILER
				catch (FileFormatLimitationExceededException)
				{
					throw;
				}
#endif
d1645 1
@


1.122
log
@The Invoke method can also be completely missing.
@
text
@d5424 5
@


1.121
log
@Must throw AbstractMethodError when the method is static, regardless of accessibility.
@
text
@a1151 1
					mw.Link();
d1163 1
a1163 1
					if (mw.IsStatic || !mw.IsPublic)
d1165 1
a1165 1
						ilgen.EmitThrow(mw.IsStatic ? "java.lang.AbstractMethodError" : "java.lang.IllegalAccessError", mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
d1200 1
@


1.120
log
@If the delegate invoke stub would end up calling the wrong method, it should throw the appropriate exception instead.
@
text
@d1166 1
a1166 1
						ilgen.EmitThrow(!mw.IsPublic ? "java.lang.IllegalAccessError" : "java.lang.AbstractMethodError", mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
@


1.119
log
@Add support for delegates with ByRef parameters.
@
text
@d1151 3
d1164 6
a1200 2
					MethodWrapper mw = this.DeclaringType.GetMethodWrapper("Invoke", this.Signature, true);
					mw.Link();
@


1.118
log
@Removed method name mangling and depend on custom modifiers instead.
@
text
@d539 4
d1057 1
a1057 1
			private MethodWrapper GetMethodWrapperDuringCtor(TypeWrapper lookup, List<MethodWrapper> methods, string name, string sig)
d1120 109
d2669 4
@


1.117
log
@Add modopt custom modifiers for methods (that need it).
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
a394 12
		// NOTE can only be used if the type hasn't been finished yet!
		protected string GenerateUniqueMethodName(string basename, MethodWrapper mw)
		{
			return ((JavaTypeImpl)impl).GenerateUniqueMethodName(basename, mw);
		}

		// NOTE can only be used if the type hasn't been finished yet!
		internal string GenerateUniqueMethodName(string basename, Type returnType, Type[] parameterTypes)
		{
			return ((JavaTypeImpl)impl).GenerateUniqueMethodName(basename, returnType, parameterTypes);
		}

a444 1
			private Dictionary<string, string> memberclashtable;
a2114 35
			private void UpdateClashTable()
			{
				lock (this)
				{
					if (memberclashtable == null)
					{
						memberclashtable = new Dictionary<string, string>();
						for (int i = 0; i < methods.Length; i++)
						{
							// TODO at the moment we don't support constructor signature clash resolving, so we better
							// not put them in the clash table
							if (methods[i].IsLinked && methods[i].GetMethod() != null && methods[i].Name != "<init>")
							{
								string key = GenerateClashKey("method", methods[i].RealName, methods[i].ReturnTypeForDefineMethod, methods[i].GetParametersForDefineMethod());
								memberclashtable.Add(key, key);
							}
						}
					}
				}
			}

			private static string GenerateClashKey(string type, string name, Type retOrFieldType, Type[] args)
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder(type);
				sb.Append(':').Append(name).Append(':').Append(retOrFieldType.FullName);
				if (args != null)
				{
					foreach (Type t in args)
					{
						sb.Append(':').Append(t.FullName);
					}
				}
				return sb.ToString();
			}

a2442 22
			internal string GenerateUniqueMethodName(string basename, MethodWrapper mw)
			{
				return GenerateUniqueMethodName(basename, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
			}

			internal string GenerateUniqueMethodName(string basename, Type returnType, Type[] parameterTypes)
			{
				string name = basename;
				string key = GenerateClashKey("method", name, returnType, parameterTypes);
				UpdateClashTable();
				lock (memberclashtable)
				{
					for (int clashcount = 0; memberclashtable.ContainsKey(key); clashcount++)
					{
						name = basename + "_" + clashcount;
						key = GenerateClashKey("method", name, returnType, parameterTypes);
					}
					memberclashtable.Add(key, key);
				}
				return name;
			}

d2577 1
a2577 2
							string name = GenerateUniqueMethodName(methods[index].Name, baseMethods[index][0]);
							MethodBuilder mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper, typeBuilder, name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride);
d2579 1
a2579 10
							bool overridestub = CheckRequireOverrideStub(methods[index], baseMethods[index][0]);
#if STATIC_COMPILER
							if (overridestub || name != methods[index].Name)
							{
								// instead of creating an override stub, we created the Miranda method with the proper signature and
								// decorate it with a NameSigAttribute that contains the real signature
								AttributeHelper.SetNameSig(mb, methods[index].Name, methods[index].Signature);
							}
#endif // STATIC_COMPILER
							if (overridestub)
d2584 1
a2584 1
							else if (!baseMethods[index][0].IsDynamicOnly && name != baseMethods[index][0].RealName)
a2681 5
				bool setNameSig = methods[index].ReturnType.IsErasedOrBoxedPrimitiveOrRemapped;
				foreach (TypeWrapper tw in methods[index].GetParameters())
				{
					setNameSig |= tw.IsErasedOrBoxedPrimitiveOrRemapped;
				}
a2761 1
							setNameSig = true;
a2850 10
					if (setNameSig || memberclashtable != null)
					{
						// TODO we really should make sure that the name we generate doesn't already exist in a
						// base class (not in the Java method namespace, but in the CLR method namespace)
						name = GenerateUniqueMethodName(name, methods[index]);
						if (name != m.Name)
						{
							setNameSig = true;
						}
					}
d2852 1
a2852 1
						&& (setNameSig || methods[index].IsExplicitOverride || baseMethods[index][0].RealName != name || CheckRequireOverrideStub(methods[index], baseMethods[index][0]))
d2868 1
a2868 1
							else if (subsequent || setNameSig || methods[index].IsExplicitOverride || baseMethod.RealName != name)
a2935 6
#if STATIC_COMPILER
				if (setNameSig)
				{
					AttributeHelper.SetNameSig(mb, m.Name, m.Signature);
				}
#endif
d4278 1
d4283 1
d4286 3
d4290 1
a4290 1
					? wrapper.GenerateUniqueMethodName((mw.Modifiers & Modifiers.Bridge) == 0 ? mw.Name : NamePrefix.Bridge + mw.Name, returnType, parameterTypes)
d4292 1
a4292 1
				MethodBuilder mb = typeBuilder.DefineMethod(name, stubattribs, returnType, parameterTypes);
d5325 3
a5329 4
			string name = GenerateUniqueMethodName("__<overridestub>" + baseMethod.Name, stubret, stubargs);
			MethodBuilder overrideStub = baseMethod.GetDefineMethodHelper().DefineMethod(this, typeBuilder, name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final);
			typeBuilder.DefineMethodOverride(overrideStub, (MethodInfo)baseMethod.GetMethod());

@


1.116
log
@EmitCallerIDStub doesn't need support for handling "special" parameter types.
@
text
@a5946 1
		private readonly Type[] parameterTypes;
a5950 1
			this.parameterTypes = mw.GetParametersForDefineMethod();
d5955 1
a5955 1
			get { return parameterTypes.Length; }
d5965 15
a5979 1
			return tb.DefineMethod(name, attribs, mw.ReturnTypeForDefineMethod, parameterTypes);
d5990 1
d5992 1
d5996 1
@


1.115
log
@GenerateOverrideStub should use GetDefineMethodHelper().
@
text
@d4991 3
a4993 2
				Type[] p = mw.GetParametersForDefineMethod();
				Type[] parameterTypes = new Type[p.Length - 1];
d4996 1
a4996 1
					parameterTypes[i] = p[i];
d5024 1
a5024 1
				MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, attribs, mw.ReturnTypeForDefineMethod, parameterTypes);
@


1.114
log
@Made base TypeWrapper resolution lazy for compiled and .NET TypeWrappers. This is not just a perf improvement, but also avoid infinite recursion for generic type instantiations that use sub types as type parameters.
@
text
@d5420 1
d5423 4
a5428 4
			string name = GenerateUniqueMethodName(baseMethod.RealName + "/unloadablestub", baseMethod);
			MethodBuilder overrideStub = typeBuilder.DefineMethod(name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final, stubret, stubargs);
			AttributeHelper.HideFromJava(overrideStub);
			typeBuilder.DefineMethodOverride(overrideStub, (MethodInfo)baseMethod.GetMethod());
@


1.113
log
@It turns out there's really no good reason why custom attributes should be serializable (and for example many in mscorlib aren't).
@
text
@d55 1
d78 1
a78 1
			: base(f.Modifiers, f.Name, f.IsInterface ? null : LoadTypeWrapper(classLoader, f.SuperClass))
d84 1
d339 5
@


1.112
log
@Fix name length for inner classes.
@
text
@a1638 1
					// TODO attribute should be .NET serializable
@


1.111
log
@Removed class name length limitation.
@
text
@d457 1
d1129 1
a1129 1
			private static string GetInnerClassName(string outer, string inner)
d1132 5
a1136 1
				return TypeNameUtil.ReplaceIllegalCharacters(inner.Substring(outer.Length + 1));
d1651 1
a1651 1
						attributeTypeBuilder = outer.DefineNestedType(GetInnerClassName(o.outerClassWrapper.Name, name) + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
@


1.110
log
@Removed circular dependency hack for delegate types that isn't required anymore with the new CreateStep2 compilation pass.
@
text
@d1131 1
a1131 1
				return TypeNameUtil.EscapeName(inner.Substring(outer.Length + 1));
@


1.109
log
@Introduced an intermediate compilation pass for CreateStep2 to enable a class to extend a class nested inside itself.
@
text
@d291 1
a291 6
			TypeWrapper iface;
#if STATIC_COMPILER
			iface = classLoader.LoadCircularDependencyHack(this, f.Name + DotNetTypeWrapper.DelegateInterfaceSuffix);
#else
			iface = classLoader.LoadClassByDottedNameFast(f.Name + DotNetTypeWrapper.DelegateInterfaceSuffix);
#endif
d623 1
a623 1
								outerClassWrapper = wrapper.GetClassLoader().LoadCircularDependencyHack(wrapper, outerClassName) as DynamicTypeWrapper;
@


1.108
log
@Delay setting the TypeBuilder parent until Finish stage.
@
text
@d580 10
d675 1
a1379 6
#if STATIC_COMPILER
				if (outerClassWrapper != null)
				{
					outerClassWrapper.Finish();
				}
#endif // STATIC_COMPILER
@


1.107
log
@Renamed CreateStep2NoFail to CreateStep2, because while it shouldn't fail, CreateStep1 also shouldn't fail. Removed unused return value from CreateStep2().
@
text
@d758 1
a758 1
							typeBuilder = outer.DefineNestedType(GetInnerClassName(outerClassWrapper.Name, f.Name), typeAttribs, wrapper.GetBaseTypeForDefineType());
d763 1
a763 1
							typeBuilder = wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName, typeAttribs, wrapper.GetBaseTypeForDefineType());
d3570 8
@


1.106
log
@Make AllocMangledName register the wrapper directly, because there is no reason to do that later.
@
text
@d410 1
a410 1
		internal string CreateStep2NoFail()
d412 1
a412 1
			return ((JavaTypeImpl)impl).CreateStep2NoFail();
d578 1
a578 1
			internal string CreateStep2NoFail()
d908 1
a908 1
					JVM.CriticalFailure("Exception during JavaTypeImpl.CreateStep2NoFail", x);
a909 1
				return mangledTypeName;
@


1.105
log
@- Removed BaseTypeWrapper.Finish() call from DotNetTypeWrapper.LazyPublishMembers(), because it is the wrong place to call Finish.
- Added explicit Link() calls where necessary.
@
text
@d582 1
a582 1
				string mangledTypeName = wrapper.classLoader.GetTypeWrapperFactory().AllocMangledName(classFile.Name);
@


1.104
log
@Removed parameters from CreateStep1 and CreateStep2NoFail.
@
text
@d2300 1
a2300 1
							|| (baseMethod.GetMethod().Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Assembly))
d2347 6
@


1.103
log
@Removed some unnecessary downcasts.
@
text
@d405 1
a405 1
		internal void CreateStep1(out bool hasclinit)
d407 1
a407 1
			((JavaTypeImpl)impl).CreateStep1(out hasclinit);
d410 1
a410 1
		internal void CreateStep2NoFail(bool hasclinit, string mangledTypeName)
d412 1
a412 1
			((JavaTypeImpl)impl).CreateStep2NoFail(hasclinit, mangledTypeName);
d471 1
a471 1
			internal void CreateStep1(out bool hasclinit)
d474 1
a474 1
				hasclinit = wrapper.BaseTypeWrapper == null ? false : wrapper.BaseTypeWrapper.HasStaticInitializer;
d578 1
a578 1
			internal void CreateStep2NoFail(bool hasclinit, string mangledTypeName)
d581 2
d910 1
@


1.102
log
@Removed last remaining TypeAsBuilder usage.
@
text
@d30 1
d34 1
d448 1
a448 1
			private readonly DynamicTypeWrapper wrapper;
d468 1
a468 1
				this.wrapper = wrapper;
d573 1
a573 1
				((AotTypeWrapper)wrapper).AddMapXmlFields(ref fields);
d781 1
a781 1
						((CompilerClassLoader)wrapper.GetClassLoader()).AddNameMapping(wrapper.Name, typeBuilder.FullName);
d786 1
a786 1
						((AotTypeWrapper)wrapper).SetAnnotation(annotationBuilder);
d792 1
a792 1
						CompilerClassLoader ccl = (CompilerClassLoader)wrapper.GetClassLoader();
d809 1
a809 1
						((AotTypeWrapper)wrapper).SetEnumType(enumBuilder);
d1625 1
a1625 1
					CompilerClassLoader ccl = (CompilerClassLoader)o.wrapper.GetClassLoader();
d3477 1
a3477 1
			private readonly DynamicTypeWrapper wrapper;
d3490 1
a3490 1
			internal FinishContext(ClassFile classFile, DynamicTypeWrapper wrapper, TypeBuilder typeBuilder)
d3930 1
a3930 1
					CompilerClassLoader ccl = (CompilerClassLoader)wrapper.GetClassLoader();
d3998 1
a3998 1
						((AotTypeWrapper)wrapper).GetParameterNamesFromXml(m.Name, m.Signature, parameterNames);
d4014 1
a4014 1
					((AotTypeWrapper)wrapper).AddXmlMapParameterAttributes(mb, classFile.Name, m.Name, m.Signature, ref parameterBuilders);
d4062 1
a4062 1
					if (m.DllExportName != null && ((CompilerClassLoader)wrapper.GetClassLoader()).TryEnableUnmanagedExports())
@


1.101
log
@Removed unneeded TypeAsBuilder.
@
text
@d626 2
a627 1
								if (outerClassWrapper.impl is JavaTypeImpl && outerClassWrapper.GetClassLoader() == wrapper.GetClassLoader())
d629 1
a629 1
									ClassFile outerClassFile = ((JavaTypeImpl)outerClassWrapper.impl).classFile;
d661 1
a661 1
									outer = outerClassWrapper.TypeAsBuilder;
d783 1
a783 1
						annotationBuilder = new AnnotationBuilder(this);
d1581 1
d1586 1
a1586 1
				internal AnnotationBuilder(JavaTypeImpl o)
d1589 1
d1642 1
a1642 1
						attributeTypeBuilder = o.outerClassWrapper.TypeAsBuilder.DefineNestedType(GetInnerClassName(o.outerClassWrapper.Name, name) + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
@


1.100
log
@Removed another TypeAsBuilder usage.
@
text
@d795 1
a795 1
						enumBuilder = wrapper.TypeAsBuilder.DefineNestedType(name, TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.NestedPublic | TypeAttributes.Serializable, Types.Enum);
@


1.99
log
@We should not call SetCustomAttribute after the type has been created (even though it works with IKVM.Reflection).
@
text
@d1478 7
@


1.98
log
@More TypeAsBuiler usage removed.
@
text
@d1472 8
a1484 2
						CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(AnnotationAttributeAttribute)).GetConstructor(new Type[] { Types.String }), new object[] { annotationBuilder.AttributeTypeName });
						typeBuilder.SetCustomAttribute(cab);
@


1.97
log
@Removed TypeAsBuilder usage from method handle code.
@
text
@d1905 1
a1905 1
							MethodBuilder mb = o.methods[i].GetDefineMethodHelper().DefineMethod(o.wrapper.GetClassLoader().GetTypeWrapperFactory(), attributeTypeBuilder, o.methods[i].Name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot);
d2611 1
a2611 1
							MethodBuilder mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper, name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride);
d2624 1
a2624 1
								wrapper.GenerateOverrideStub(baseMethods[index][0], mb, methods[index]);
d2718 1
a2718 1
				ConstructorBuilder cb = mw.GetDefineMethodHelper().DefineConstructor(wrapper, GetMethodAccess(mw) | MethodAttributes.HideBySig);
d2917 1
a2917 1
					mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper, name, attribs);
d2925 1
a2925 1
								wrapper.GenerateOverrideStub(baseMethod, mb, methods[index]);
d3598 1
a3598 1
									MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(wrapper, name, attr);
d4535 1
a4535 1
						wrapper.GenerateOverrideStub(ifmethod, (MethodInfo)mce.GetMethod(), mce);
d4561 1
a4561 1
				return mw.GetDefineMethodHelper().DefineMethod(wrapper, name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final);
d5346 5
d5372 1
a5372 1
		private void GenerateOverrideStub(MethodWrapper baseMethod, MethodInfo target, MethodWrapper targetMethod)
a5374 1
			TypeBuilder typeBuilder = this.TypeAsBuilder;
d5913 1
a5913 1
		internal MethodBuilder DefineMethod(DynamicTypeWrapper tw, string name, MethodAttributes attribs)
d5915 1
a5915 1
			return DefineMethod(tw.GetClassLoader().GetTypeWrapperFactory(), tw.TypeAsBuilder, name, attribs);
d5923 1
a5923 1
		internal ConstructorBuilder DefineConstructor(DynamicTypeWrapper tw, MethodAttributes attribs)
d5925 1
a5925 1
			return DefineConstructor(tw.GetClassLoader().GetTypeWrapperFactory(), tw.TypeAsBuilder, attribs);
@


1.96
log
@Removed usage of TypeAsBuilder from automagic serialization generation code.
@
text
@d5329 17
@


1.95
log
@Merge GenerateMethod() into LinkMethod().
@
text
@d3903 1
a3903 1
					wrapper.automagicSerializationCtor = Serialization.AddAutomagicSerialization(wrapper);
@


1.94
log
@Moved synchronized handling to more appropriate place.
@
text
@a1180 21
			internal override MethodBase LinkMethod(MethodWrapper mw)
			{
				if (mw is DelegateConstructorMethodWrapper)
				{
					((DelegateConstructorMethodWrapper)mw).DoLink(typeBuilder);
					return null;
				}
				Debug.Assert(mw != null);
				int index = GetMethodIndex(mw);
				if (baseMethods[index] != null)
				{
					foreach (MethodWrapper baseMethod in baseMethods[index])
					{
						baseMethod.Link();
						CheckLoaderConstraints(mw, baseMethod);
					}
				}
				Debug.Assert(mw.GetMethod() == null);
				return GenerateMethod(index);
			}

d2582 1
a2582 1
			private MethodBase GenerateMethod(int index)
d2584 16
@


1.93
log
@Special case DelegateConstructorMethodWrapper in LinkMethod instead of overriding DoLinkMethod.
@
text
@d1199 1
a1199 8
				MethodBase mb = GenerateMethod(index);
				if ((mw.Modifiers & (Modifiers.Synchronized | Modifiers.Static)) == Modifiers.Synchronized)
				{
					// note that constructors cannot be synchronized in Java
					MethodBuilder mbld = (MethodBuilder)mb;
					mbld.SetImplementationFlags(mbld.GetMethodImplementationFlags() | MethodImplAttributes.Synchronized);
				}
				return mb;
d2995 5
@


1.92
log
@Moved indy call site state into FinishContext.
@
text
@d917 1
a917 1
				protected override void DoLinkMethod()
d920 1
a920 1
					constructor = this.DeclaringType.TypeAsBuilder.DefineConstructor(attribs, CallingConventions.Standard, new Type[] { Types.Object, Types.IntPtr }, null, null);
d1183 5
@


1.91
log
@Removed duplication of keeping track of AnnotationBuilder and moved enum nested type to AotTypeWrapper as well.
@
text
@d5323 8
@


1.90
log
@Removed RegisterPostFinishProc from FinishContext.
@
text
@a384 18
#if STATIC_COMPILER
		internal override Annotation Annotation
		{
			get
			{
				return impl.Annotation;
			}
		}

		internal override Type EnumType
		{
			get
			{
				return impl.EnumType;
			}
		}
#endif // STATIC_COMPILER

a426 4
#if STATIC_COMPILER
			internal abstract Annotation Annotation { get; }
			internal abstract Type EnumType { get; }
#endif
d806 1
d1518 1
a1518 5
					finishedType = new FinishedTypeImpl(type, innerClassesTypeWrappers, declaringTypeWrapper, wrapper.ReflectiveModifiers, Metadata.Create(classFile), finishedClinitMethod, finalizeMethod
#if STATIC_COMPILER
, annotationBuilder, enumBuilder
#endif
);
a3111 18

#if STATIC_COMPILER
			internal override Annotation Annotation
			{
				get
				{
					return annotationBuilder;
				}
			}

			internal override Type EnumType
			{
				get
				{
					return enumBuilder;
				}
			}
#endif // STATIC_COMPILER
a3333 4
#if STATIC_COMPILER
			private Annotation annotationBuilder;
			private TypeBuilder enumBuilder;
#endif
d3335 1
a3335 6
			internal FinishedTypeImpl(Type type, TypeWrapper[] innerclasses, TypeWrapper declaringTypeWrapper, Modifiers reflectiveModifiers, Metadata metadata, MethodInfo clinitMethod, MethodInfo finalizeMethod
#if STATIC_COMPILER
, Annotation annotationBuilder
				, TypeBuilder enumBuilder
#endif
)
a3343 4
#if STATIC_COMPILER
				this.annotationBuilder = annotationBuilder;
				this.enumBuilder = enumBuilder;
#endif
a3455 18

#if STATIC_COMPILER
			internal override Annotation Annotation
			{
				get
				{
					return annotationBuilder;
				}
			}

			internal override Type EnumType
			{
				get
				{
					return enumBuilder;
				}
			}
#endif // STATIC_COMPILER
@


1.89
log
@Removed all but one users of RegisterPostFinishProc hack.
@
text
@d1517 1
d1523 1
a1523 4
						context.RegisterPostFinishProc(delegate
						{
							annotationBuilder.Finish(this);
						});
d1527 1
a1527 1
						context.RegisterNestedTypeBuilder(enumBuilder);
a1529 1
					Type type = context.FinishImpl();
a3538 1
			private List<System.Threading.ThreadStart> postFinishProcs;
d3604 1
a3604 10
			internal void RegisterPostFinishProc(System.Threading.ThreadStart proc)
			{
				if (postFinishProcs == null)
				{
					postFinishProcs = new List<System.Threading.ThreadStart>();
				}
				postFinishProcs.Add(proc);
			}

			internal void RegisterNestedTypeBuilder(TypeBuilder tb)
a4177 7
					if (postFinishProcs != null)
					{
						foreach (System.Threading.ThreadStart proc in postFinishProcs)
						{
							proc();
						}
					}
@


1.88
log
@Moved AtomicReferenceFieldUpdater creation into FinishContext, to be able to better keep track of the types and avoid the global dictionary.
@
text
@d1522 4
d1527 1
a1527 1
					context.RegisterPostFinishProc(delegate
d1529 2
a1530 9
						if (enumBuilder != null)
						{
							enumBuilder.CreateType();
						}
						if (annotationBuilder != null)
						{
							annotationBuilder.Finish(this);
						}
					});
d3540 1
a3540 1
			private TypeBuilder typeCallerID;
a3543 1
			private int uniqueId;
d3617 9
d4182 1
a4182 1
					if (typeCallerID != null)
d4184 6
a4189 1
						typeCallerID.CreateType();
d5285 1
a5285 1
						typeCallerID = EmitCreateCallerID(typeBuilder, ilGenerator);
d5367 2
a5368 1
				TypeBuilder tb = typeBuilder.DefineNestedType("__<tls>_" + (uniqueId++), TypeAttributes.NestedPrivate | TypeAttributes.Sealed, threadLocal.TypeAsBaseType);
d5388 1
a5388 5
				RegisterPostFinishProc(delegate
				{
					threadLocal.Finish();
					tb.CreateType();
				});
d5402 1
a5402 1
					TypeBuilder tb = typeBuilder.DefineNestedType("__<ARFU>_" + (uniqueId++), TypeAttributes.NestedPrivate | TypeAttributes.Sealed, arfuTypeWrapper.TypeAsBaseType);
d5413 1
a5413 5
					RegisterPostFinishProc(delegate
					{
						arfuTypeWrapper.Finish();
						tb.CreateType();
					});
@


1.87
log
@Moved DefineThreadLocalType() into FinishContext because that way it better encapsulates the behavior.
@
text
@d3548 1
d5384 30
@


1.86
log
@Simplified GenerateOverrideStub parameters.
@
text
@d3547 1
d5352 31
@


1.85
log
@Renamed GenerateUnloadableOverrideStub to GenerateOverrideStub and moved it to a more sensible position.
@
text
@d2662 1
a2662 1
								GenerateOverrideStub(wrapper, typeBuilder, baseMethods[index][0], mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
d2963 1
a2963 1
								GenerateOverrideStub(wrapper, typeBuilder, baseMethod, mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
d4619 1
a4619 1
						GenerateOverrideStub(wrapper, typeBuilder, ifmethod, (MethodInfo)mce.GetMethod(), mce.ReturnTypeForDefineMethod, mce.GetParametersForDefineMethod());
d5372 1
a5372 1
		private static void GenerateOverrideStub(DynamicTypeWrapper wrapper, TypeBuilder typeBuilder, MethodWrapper baseMethod, MethodInfo target, Type targetRet, Type[] targetArgs)
d5375 1
a5375 1

d5378 3
a5380 1
			string name = wrapper.GenerateUniqueMethodName(baseMethod.RealName + "/unloadablestub", baseMethod);
@


1.84
log
@Generate override stub for miranda method, when necessary.
@
text
@d2662 1
a2662 1
								GenerateUnloadableOverrideStub(wrapper, typeBuilder, baseMethods[index][0], mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
d2963 1
a2963 1
								GenerateUnloadableOverrideStub(wrapper, typeBuilder, baseMethod, mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
a3076 29
			internal static void GenerateUnloadableOverrideStub(DynamicTypeWrapper wrapper, TypeBuilder typeBuilder, MethodWrapper baseMethod, MethodInfo target, Type targetRet, Type[] targetArgs)
			{
				Debug.Assert(!baseMethod.HasCallerID);

				Type stubret = baseMethod.ReturnTypeForDefineMethod;
				Type[] stubargs = baseMethod.GetParametersForDefineMethod();
				string name = wrapper.GenerateUniqueMethodName(baseMethod.RealName + "/unloadablestub", baseMethod);
				MethodBuilder overrideStub = typeBuilder.DefineMethod(name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final, stubret, stubargs);
				AttributeHelper.HideFromJava(overrideStub);
				typeBuilder.DefineMethodOverride(overrideStub, (MethodInfo)baseMethod.GetMethod());
				CodeEmitter ilgen = CodeEmitter.Create(overrideStub);
				ilgen.Emit(OpCodes.Ldarg_0);
				for (int i = 0; i < targetArgs.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldarg_S, (byte)(i + 1));
					if (targetArgs[i] != stubargs[i])
					{
						ilgen.Emit(OpCodes.Castclass, targetArgs[i]);
					}
				}
				ilgen.Emit(OpCodes.Callvirt, target);
				if (targetRet != stubret)
				{
					ilgen.Emit(OpCodes.Castclass, stubret);
				}
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
			}

d4619 1
a4619 1
						JavaTypeImpl.GenerateUnloadableOverrideStub(wrapper, typeBuilder, ifmethod, (MethodInfo)mce.GetMethod(), mce.ReturnTypeForDefineMethod, mce.GetParametersForDefineMethod());
d5372 29
@


1.83
log
@Made override stub generation more consistent.
@
text
@d2651 1
d2653 1
a2653 1
							if (CheckRequireOverrideStub(methods[index], baseMethods[index][0]) || name != methods[index].Name)
d2660 4
d2665 1
a2665 1
							if (!baseMethods[index][0].IsDynamicOnly && name != baseMethods[index][0].RealName)
@


1.82
log
@Fixed unloadable corner case (that only only be generated by playing weird class loader tricks).
@
text
@d1157 1
a1157 1
			private static bool CheckLoaderConstraints(MethodWrapper mw, MethodWrapper baseMethod)
d1159 8
a1166 1
				bool unloadableOverrideStub = false;
d1169 1
a1169 1
					if (mw.ReturnType.IsUnloadable || baseMethod.ReturnType.IsUnloadable || JVM.FinishingForDebugSave)
d1171 1
a1171 4
						if (mw.ReturnType.IsUnloadable != baseMethod.ReturnType.IsUnloadable || JVM.FinishingForDebugSave)
						{
							unloadableOverrideStub = true;
						}
d1187 1
a1187 1
						if (here[i].IsUnloadable || there[i].IsUnloadable || JVM.FinishingForDebugSave)
d1189 1
a1189 4
							if (here[i].IsUnloadable != there[i].IsUnloadable || JVM.FinishingForDebugSave)
							{
								unloadableOverrideStub = true;
							}
a1199 1
				return unloadableOverrideStub;
a1204 1
				bool unloadableOverrideStub = false;
d1211 1
a1211 1
						unloadableOverrideStub |= CheckLoaderConstraints(mw, baseMethod);
d1215 1
a1215 1
				MethodBase mb = GenerateMethod(index, unloadableOverrideStub);
d2636 1
a2636 1
			private MethodBase GenerateMethod(int index, bool unloadableOverrideStub)
d2652 1
a2652 1
							if (unloadableOverrideStub || name != methods[index].Name)
d2695 1
a2695 1
						method = GenerateMethod(index, m, unloadableOverrideStub, ref setModifiers);
d2756 1
a2756 1
			private MethodBase GenerateMethod(int index, ClassFile.Method m, bool unloadableOverrideStub, ref bool setModifiers)
d2943 4
a2946 2
					bool newslot = baseMethods[index] != null && (setNameSig || methods[index].IsExplicitOverride || baseMethods[index][0].RealName != name) && !needFinalize;
					if (unloadableOverrideStub || newslot)
d2951 1
a2951 9
					if (unloadableOverrideStub)
					{
						foreach (MethodWrapper baseMethod in baseMethods[index])
						{
							// TODO if there are multiple base methods, we're creating an unloadable override stub for all of them, but in theory it's possible that not all of them need it
							GenerateUnloadableOverrideStub(wrapper, typeBuilder, baseMethod, mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
						}
					}
					else if (baseMethods[index] != null && !needFinalize)
d2956 5
a2960 1
							if (subsequent || setNameSig || methods[index].IsExplicitOverride || baseMethod.RealName != name)
a5120 19
			private static bool CheckRequireOverrideStub(MethodWrapper mw1, MethodWrapper mw2)
			{
				// TODO this is too late to generate LinkageErrors so we need to figure this out earlier
				if (mw1.ReturnType != mw2.ReturnType && !(mw1.ReturnType.IsUnloadable && mw2.ReturnType.IsUnloadable))
				{
					return true;
				}
				TypeWrapper[] args1 = mw1.GetParameters();
				TypeWrapper[] args2 = mw2.GetParameters();
				for (int i = 0; i < args1.Length; i++)
				{
					if (args1[i] != args2[i] && !(args1[i].IsUnloadable && args2[i].IsUnloadable))
					{
						return true;
					}
				}
				return false;
			}

d5377 19
@


1.81
log
@Introduced DefineMethodHelper class as an abstraction over method signatures (the parameter/return types) to make it easier to start using modopt for methods.
@
text
@d1162 1
a1162 1
					if (baseMethod.ReturnType.IsUnloadable || JVM.FinishingForDebugSave)
d1164 1
a1164 1
						if (!mw.ReturnType.IsUnloadable || (!baseMethod.ReturnType.IsUnloadable && JVM.FinishingForDebugSave))
d1183 1
a1183 1
						if (there[i].IsUnloadable || JVM.FinishingForDebugSave)
d1185 1
a1185 1
							if (!here[i].IsUnloadable || (!there[i].IsUnloadable && JVM.FinishingForDebugSave))
@


1.80
log
@- Use custom modifiers (instead of NameSigAttribute) for constructors with mangled types.
- Fixed GetModOpt() to handle ghost arrays.
- Moved namesig handling for methods into GenerateMethod().
@
text
@d1960 1
a1960 1
							MethodBuilder mb = attributeTypeBuilder.DefineMethod(o.methods[i].Name, MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot, o.methods[i].ReturnTypeForDefineMethod, o.methods[i].GetParametersForDefineMethod());
d2650 1
a2650 1
							MethodBuilder mb = typeBuilder.DefineMethod(name, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
d2752 1
a2752 8
				// we add optional modifiers to make the signature unique
				TypeWrapper[] parameters = mw.GetParameters();
				Type[][] modopt = new Type[parameters.Length][];
				for (int i = 0; i < parameters.Length; i++)
				{
					modopt[i] = wrapper.GetModOpt(parameters[i], false);
				}
				ConstructorBuilder cb = typeBuilder.DefineConstructor(GetMethodAccess(mw) | MethodAttributes.HideBySig, CallingConventions.Standard, mw.GetParametersForDefineMethod(), null, modopt);
d2949 1
a2949 1
					mb = typeBuilder.DefineMethod(name, attribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
d3707 1
a3707 1
									MethodBuilder mb = typeBuilder.DefineMethod(name, attr, CallingConventions.Standard, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
d4582 1
a4582 1
							MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d4601 1
a4601 1
						MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d4611 1
a4611 1
						MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d4630 1
a4630 1
						MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d4659 1
a4659 1
						MethodBuilder mb = typeBuilder.DefineMethod(mangledName, MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final, ifmethod.ReturnTypeForDefineMethod, ifmethod.GetParametersForDefineMethod());
d4670 5
d5834 5
d5842 1
a5842 1
				modopt = new Type[] { GetClassLoader().GetTypeWrapperFactory().DefineUnloadable(tw.Name) };
d5893 44
@


1.79
log
@Moved (method specific) MethodAttributes computation into GenerateMethod().
@
text
@a2673 5
					bool setNameSig = methods[index].ReturnType.IsErasedOrBoxedPrimitiveOrRemapped;
					foreach (TypeWrapper tw in methods[index].GetParameters())
					{
						setNameSig |= tw.IsErasedOrBoxedPrimitiveOrRemapped;
					}
d2696 1
a2696 1
						method = GenerateMethod(index, m, unloadableOverrideStub, ref setModifiers, ref setNameSig);
a2731 4
					if (setNameSig)
					{
						AttributeHelper.SetNameSig(method, m.Name, m.Signature);
					}
d2752 4
a2755 7
				bool setNameSig = mw.ReturnType.IsErasedOrBoxedPrimitiveOrRemapped;
				foreach (TypeWrapper tw in mw.GetParameters())
				{
					setNameSig |= tw.IsErasedOrBoxedPrimitiveOrRemapped;
				}
				Type[][] modopt = null;
				if (setNameSig)
d2757 1
a2757 27
					// we add optional modifiers to make the signature unique
					TypeWrapper[] parameters = mw.GetParameters();
					modopt = new Type[parameters.Length][];
					for (int i = 0; i < parameters.Length; i++)
					{
						if (parameters[i].IsGhostArray)
						{
							TypeWrapper elemTypeWrapper = parameters[i];
							while (elemTypeWrapper.IsArray)
							{
								elemTypeWrapper = elemTypeWrapper.ElementTypeWrapper;
							}
							modopt[i] = new Type[] { elemTypeWrapper.TypeAsTBD };
						}
						else if (parameters[i].IsBoxedPrimitive)
						{
							modopt[i] = new Type[] { Types.Object };
						}
						else if (parameters[i].IsRemapped && parameters[i] is DotNetTypeWrapper)
						{
							modopt[i] = new Type[] { parameters[i].TypeAsSignatureType };
						}
						else if (parameters[i].IsUnloadable)
						{
							modopt[i] = new Type[] { wrapper.classLoader.GetTypeWrapperFactory().DefineUnloadable(parameters[i].Name) };
						}
					}
d2764 1
a2764 1
			private MethodBase GenerateMethod(int index, ClassFile.Method m, bool unloadableOverrideStub, ref bool setModifiers, ref bool setNameSig)
d2766 5
d3032 7
d5844 1
a5844 1
				if (tw1.IsErasedOrBoxedPrimitiveOrRemapped || (mustBePublic && !tw1.IsPublic))
d5849 8
a5856 8
						// FXBUG Ref.Emit refuses arrays in custom modifiers, so we add an array type for each dimension
						// (note that in this case we only add the custom modifiers to make the signature unique, we never read back this information)
						modopt = new Type[tw.ArrayRank + 1];
						modopt[0] = GetModOptHelper(tw1);
						for (int i = 1; i < modopt.Length; i++)
						{
							modopt[i] = typeof(Array);
						}
@


1.78
log
@Code restructuring. Moved method generation (as in non-constructor methods) into separate method.
@
text
@a2685 39
					MethodAttributes attribs = MethodAttributes.HideBySig;
					if (m.IsNative)
					{
						if (wrapper.IsPInvokeMethod(m))
						{
							// this doesn't appear to be necessary, but we use the flag in Finish to know
							// that we shouldn't emit a method body
							attribs |= MethodAttributes.PinvokeImpl;
						}
						else
						{
							setModifiers = true;
						}
					}
					if (methods[index].IsPropertyAccessor)
					{
						attribs |= GetPropertyAccess(methods[index]);
						attribs |= MethodAttributes.SpecialName;
						setModifiers = true;
					}
					else
					{
						if (m.IsPrivate)
						{
							attribs |= MethodAttributes.Private;
						}
						else if (m.IsProtected)
						{
							attribs |= MethodAttributes.FamORAssem;
						}
						else if (m.IsPublic)
						{
							attribs |= MethodAttributes.Public;
						}
						else
						{
							attribs |= MethodAttributes.Assembly;
						}
					}
d2701 1
a2701 1
						method = GenerateMethod(index, m, attribs, unloadableOverrideStub, ref setModifiers, ref setNameSig);
d2802 1
a2802 1
			private MethodBase GenerateMethod(int index, ClassFile.Method m, MethodAttributes attribs, bool unloadableOverrideStub, ref bool setModifiers, ref bool setNameSig)
d2804 24
@


1.77
log
@Code restructuring. Moved constructor generation into a separate method.
@
text
@d2740 1
a2740 238
						if (m.IsAbstract)
						{
							// only if the classfile is abstract, we make the CLR method abstract, otherwise,
							// we have to generate a method that throws an AbstractMethodError (because the JVM
							// allows abstract methods in non-abstract classes)
							if (classFile.IsAbstract)
							{
								if (classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected))
								{
									setModifiers = true;
								}
								else
								{
									attribs |= MethodAttributes.Abstract;
								}
							}
							else
							{
								setModifiers = true;
							}
						}
						if (m.IsFinal)
						{
							if (!m.IsStatic && !m.IsPrivate)
							{
								attribs |= MethodAttributes.Final;
							}
							else
							{
								setModifiers = true;
							}
						}
						if (m.IsStatic)
						{
							attribs |= MethodAttributes.Static;
							if (m.IsSynchronized)
							{
								setModifiers = true;
							}
						}
						else if (!m.IsPrivate)
						{
							attribs |= MethodAttributes.Virtual | MethodAttributes.CheckAccessOnOverride;
						}
						string name = m.Name;
#if STATIC_COMPILER
						if ((m.Modifiers & Modifiers.Bridge) != 0 && (m.IsPublic || m.IsProtected) && wrapper.IsPublic)
						{
							string sigbase = m.Signature.Substring(0, m.Signature.LastIndexOf(')') + 1);
							foreach (MethodWrapper mw in methods)
							{
								if (mw.Name == m.Name && mw.Signature.StartsWith(sigbase) && mw.Signature != m.Signature)
								{
									// To prevent bridge methods with covariant return types from confusing
									// other .NET compilers (like C#), we rename the bridge method.
									name = NamePrefix.Bridge + name;
									setNameSig = true;
									break;
								}
							}
						}
#endif
						if ((attribs & MethodAttributes.Virtual) != 0 && !classFile.IsInterface)
						{
							if (baseMethods[index] == null || (baseMethods[index].Length == 1 && baseMethods[index][0].DeclaringType.IsInterface))
							{
								// we need to set NewSlot here, to prevent accidentally overriding methods
								// (for example, if a Java class has a method "boolean Equals(object)", we don't want that method
								// to override System.Object.Equals)
								attribs |= MethodAttributes.NewSlot;
							}
							else
							{
								// if we have a method overriding a more accessible method (the JVM allows this), we need to make the
								// method more accessible, because otherwise the CLR will complain that we're reducing access
								bool hasPublicBaseMethod = false;
								foreach (MethodWrapper baseMethodWrapper in baseMethods[index])
								{
									MethodBase baseMethod = baseMethodWrapper.GetMethod();
									if ((baseMethod.IsPublic && !m.IsPublic) ||
										((baseMethod.IsFamily || baseMethod.IsFamilyOrAssembly) && !m.IsPublic && !m.IsProtected) ||
										(!m.IsPublic && !m.IsProtected && !baseMethodWrapper.DeclaringType.IsPackageAccessibleFrom(wrapper)))
									{
										hasPublicBaseMethod |= baseMethod.IsPublic;
										attribs &= ~MethodAttributes.MemberAccessMask;
										attribs |= hasPublicBaseMethod ? MethodAttributes.Public : MethodAttributes.FamORAssem;
										setModifiers = true;
									}
								}
							}
						}
						MethodBuilder mb = null;
#if STATIC_COMPILER
						mb = wrapper.DefineGhostMethod(name, attribs, methods[index]);
#endif
						if (mb == null)
						{
							bool needFinalize = false;
							bool needDispatch = false;
							MethodInfo baseFinalize = null;
							if (baseMethods[index] != null && ReferenceEquals(m.Name, StringConstants.FINALIZE) && ReferenceEquals(m.Signature, StringConstants.SIG_VOID))
							{
								baseFinalize = GetBaseFinalizeMethod(wrapper.BaseTypeWrapper);
								if (baseMethods[index][0].DeclaringType == CoreClasses.java.lang.Object.Wrapper)
								{
									// This type is the first type in the hierarchy to introduce a finalize method
									// (other than the one in java.lang.Object obviously), so we need to override
									// the real Finalize method and emit a dispatch call to our finalize method.
									needFinalize = true;
									needDispatch = true;
								}
								else if (m.IsFinal)
								{
									// One of our base classes already has a  finalize method, so we already are
									// hooked into the real Finalize, but we need to override it again, to make it
									// final (so that non-Java types cannot override it either).
									needFinalize = true;
									needDispatch = false;
									// If the base class finalize was optimized away, we need a dispatch call after all.
									if (baseFinalize.DeclaringType == Types.Object)
									{
										needDispatch = true;
									}
								}
								else
								{
									// One of our base classes already has a finalize method, but it may have been an empty
									// method so that the hookup to the real Finalize was optimized away, we need to check
									// for that.
									if (baseFinalize.DeclaringType == Types.Object)
									{
										needFinalize = true;
										needDispatch = true;
									}
								}
								if (needFinalize &&
									!m.IsAbstract && !m.IsNative &&
									(!m.IsFinal || classFile.IsFinal) &&
									m.Instructions.Length > 0 &&
									m.Instructions[0].NormalizedOpCode == NormalizedByteCode.__return)
								{
									// we've got an empty finalize method, so we don't need to override the real finalizer
									// (not having a finalizer makes a huge perf difference)
									needFinalize = false;
								}
							}
							if (setNameSig || memberclashtable != null)
							{
								// TODO we really should make sure that the name we generate doesn't already exist in a
								// base class (not in the Java method namespace, but in the CLR method namespace)
								name = GenerateUniqueMethodName(name, methods[index]);
								if (name != m.Name)
								{
									setNameSig = true;
								}
							}
							bool newslot = baseMethods[index] != null && (setNameSig || methods[index].IsExplicitOverride || baseMethods[index][0].RealName != name) && !needFinalize;
							if (unloadableOverrideStub || newslot)
							{
								attribs |= MethodAttributes.NewSlot;
							}
							mb = typeBuilder.DefineMethod(name, attribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							if (unloadableOverrideStub)
							{
								foreach (MethodWrapper baseMethod in baseMethods[index])
								{
									// TODO if there are multiple base methods, we're creating an unloadable override stub for all of them, but in theory it's possible that not all of them need it
									GenerateUnloadableOverrideStub(wrapper, typeBuilder, baseMethod, mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
								}
							}
							else if (baseMethods[index] != null && !needFinalize)
							{
								bool subsequent = false;
								foreach (MethodWrapper baseMethod in baseMethods[index])
								{
									if (subsequent || setNameSig || methods[index].IsExplicitOverride || baseMethod.RealName != name)
									{
										typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethod.GetMethod());
									}
									// the non-primary base methods always need an explicit method override
									subsequent = true;
								}
							}
							// if we're overriding java.lang.Object.finalize we need to emit a stub to override System.Object.Finalize,
							// or if we're subclassing a non-Java class that has a Finalize method, we need a new Finalize override
							if (needFinalize)
							{
								string finalizeName = baseFinalize.Name;
								MethodWrapper mwClash = wrapper.GetMethodWrapper(finalizeName, StringConstants.SIG_VOID, true);
								if (mwClash != null && mwClash.GetMethod() != baseFinalize)
								{
									finalizeName = "__<Finalize>";
								}
								MethodAttributes attr = MethodAttributes.HideBySig | MethodAttributes.Virtual;
								// make sure we don't reduce accessibility
								attr |= baseFinalize.IsPublic ? MethodAttributes.Public : MethodAttributes.Family;
								if (m.IsFinal)
								{
									attr |= MethodAttributes.Final;
								}
								finalizeMethod = typeBuilder.DefineMethod(finalizeName, attr, CallingConventions.Standard, Types.Void, Type.EmptyTypes);
								if (finalizeName != baseFinalize.Name)
								{
									typeBuilder.DefineMethodOverride(finalizeMethod, baseFinalize);
								}
								AttributeHelper.HideFromJava(finalizeMethod);
								CodeEmitter ilgen = CodeEmitter.Create(finalizeMethod);
								ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.SkipFinalizer);
								CodeEmitterLabel skip = ilgen.DefineLabel();
								ilgen.Emit(OpCodes.Brtrue_S, skip);
								if (needDispatch)
								{
									ilgen.BeginExceptionBlock();
									ilgen.Emit(OpCodes.Ldarg_0);
									ilgen.Emit(OpCodes.Callvirt, mb);
									ilgen.Emit(OpCodes.Leave, skip);
									ilgen.BeginCatchBlock(Types.Object);
									ilgen.Emit(OpCodes.Leave, skip);
									ilgen.EndExceptionBlock();
								}
								else
								{
									ilgen.Emit(OpCodes.Ldarg_0);
									ilgen.Emit(OpCodes.Call, baseFinalize);
								}
								ilgen.MarkLabel(skip);
								ilgen.Emit(OpCodes.Ret);
								ilgen.DoEmit();
							}
#if STATIC_COMPILER
							if (classFile.Methods[index].AnnotationDefault != null)
							{
								CustomAttributeBuilder cab = new CustomAttributeBuilder(StaticCompiler.GetRuntimeType("IKVM.Attributes.AnnotationDefaultAttribute").GetConstructor(new Type[] { Types.Object }), new object[] { classFile.Methods[index].AnnotationDefault });
								mb.SetCustomAttribute(cab);
							}
#endif // STATIC_COMPILER
						}
						method = mb;
d2841 242
@


1.76
log
@Also generate type 2 access stubs for final fields (when -strictfinalfieldsemantics isn't specified, and hence we don't mark the fields as initonly).
@
text
@d2727 1
a2727 31
						Type[][] modopt = null;
						if (setNameSig)
						{
							// we add optional modifiers to make the signature unique
							TypeWrapper[] parameters = methods[index].GetParameters();
							modopt = new Type[parameters.Length][];
							for (int i = 0; i < parameters.Length; i++)
							{
								if (parameters[i].IsGhostArray)
								{
									TypeWrapper elemTypeWrapper = parameters[i];
									while (elemTypeWrapper.IsArray)
									{
										elemTypeWrapper = elemTypeWrapper.ElementTypeWrapper;
									}
									modopt[i] = new Type[] { elemTypeWrapper.TypeAsTBD };
								}
								else if (parameters[i].IsBoxedPrimitive)
								{
									modopt[i] = new Type[] { Types.Object };
								}
								else if (parameters[i].IsRemapped && parameters[i] is DotNetTypeWrapper)
								{
									modopt[i] = new Type[] { parameters[i].TypeAsSignatureType };
								}
								else if (parameters[i].IsUnloadable)
								{
									modopt[i] = new Type[] { wrapper.classLoader.GetTypeWrapperFactory().DefineUnloadable(parameters[i].Name) };
								}
							}
						}
a2732 2
						method = typeBuilder.DefineConstructor(attribs, CallingConventions.Standard, methods[index].GetParametersForDefineMethod(), null, modopt);
						((ConstructorBuilder)method).SetImplementationFlags(MethodImplAttributes.NoInlining);
d3035 58
@


1.75
log
@Don't mangle property accessor method names, but use a custom modifier instead.
@
text
@d1331 13
a1343 1
					if (fld.IsFinal)
a1350 1
#if STATIC_COMPILER
a1351 1
#endif
d1354 2
a1355 3

#if STATIC_COMPILER
					if (wrapper.IsPublic && fw.HasNonPublicTypeInSignature)
d1357 1
a1357 13
						// this field is going to get a type 2 access stub, so we hide the actual field
						attribs &= ~FieldAttributes.FieldAccessMask;
						attribs |= FieldAttributes.Assembly;
						if (!fw.IsStatic)
						{
							// we need to have a setter for reflection and serialization
							attribs &= ~FieldAttributes.InitOnly;
						}
						// instead of adding HideFromJava we rename the field to avoid confusing broken compilers
						// see https://sourceforge.net/tracker/?func=detail&atid=525264&aid=3056721&group_id=69637
						// additional note: now that we maintain the ordering of the fields, we need to recognize
						// these fields so that we know where to insert the corresponding accessor property FieldWrapper.
						realFieldName = NamePrefix.Type2AccessStubBackingField + fld.Name;
d4269 3
d4323 1
a4323 3
					if (fw.HasNonPublicTypeInSignature
						&& (fw.IsPublic || (fw.IsProtected && !wrapper.IsFinal))
						&& fw.FieldTypeWrapper.IsAccessibleFrom(wrapper))
d5889 10
@


1.74
log
@Stop mangling property names for access stubs (instead we rely on custom modifiers to make them unique).
@
text
@d4341 1
a4341 1
					// we attach the (arbitrary) IsConst custom modifier because the C# compiler prefers fields without custom modifiers
d4343 1
a4343 1
					FieldBuilder fb = typeBuilder.DefineField(fw.Name, fw.FieldTypeWrapper.TypeAsSignatureType, null, new Type[] { JVM.Import(typeof(System.Runtime.CompilerServices.IsConst)) }, attribs);
d4361 1
a4361 1
					attribs |= MethodAttributes.HideBySig;
d4366 6
a4371 1
					MethodBuilder getter = typeBuilder.DefineMethod(wrapper.GenerateUniqueMethodName("get_" + fw.Name, propType, Type.EmptyTypes), attribs, propType, Type.EmptyTypes);
d4390 1
a4390 1
						MethodBuilder setter = typeBuilder.DefineMethod(wrapper.GenerateUniqueMethodName("set_" + fw.Name, Types.Void, new Type[] { propType }), attribs, null, new Type[] { propType });
@


1.73
log
@Use modopt to reliably correlate type 2 access stub properties with the underlying field. This fixes a bug where annotations applied to fields with type 2 access stubs would not be visible at runtime (via reflection).
@
text
@d4286 2
a4287 3
				List<string> propertyNames = null;
				AddType2FieldAccessStubs(ref propertyNames);
				AddType1FieldAccessStubs(wrapper, ref propertyNames);
d4296 1
a4296 1
			private void AddType1FieldAccessStubs(TypeWrapper tw, ref List<string> propertyNames)
d4307 1
a4307 1
								GenerateAccessStub(fw, ref propertyNames, true);
d4313 1
a4313 1
						AddType1FieldAccessStubs(iface, ref propertyNames);
d4319 1
a4319 1
			private void AddType2FieldAccessStubs(ref List<string> propertyNames)
d4327 1
a4327 1
						GenerateAccessStub(fw, ref propertyNames, false);
d4332 1
a4332 1
			private void GenerateAccessStub(FieldWrapper fw, ref List<string> propertyNames, bool type1)
a4333 21
				string name = fw.Name;
				if (propertyNames == null)
				{
					propertyNames = new List<string>();
					// add all the fields, to avoid clashing with real fields (which can happen for type 2 or type 1 if field type is non-public or unloadable)
					foreach (FieldWrapper fw1 in wrapper.GetFields())
					{
						if (!fw1.HasNonPublicTypeInSignature)
						{
							propertyNames.Add(fw1.Name);
						}
					}
				}
				int uniq = 0;
				while (propertyNames.Contains(name))
				{
					// when we clash, we don't want the access stub property to be visible from (e.g.) C# so we mangle the name
					name = "<>" + fw.Name + "_" + uniq++;
				}
				propertyNames.Add(name);

a4338 7
					if (uniq != 0)
					{
						// we only add access stubs for constant fields for consumption by other languages,
						// so when the field is hidden by another field, we don't need to bother
						return;
					}

d4341 3
a4343 1
					FieldBuilder fb = typeBuilder.DefineField(fw.Name, fw.FieldTypeWrapper.TypeAsSignatureType, attribs);
d4351 1
a4351 1
					PropertyBuilder pb = typeBuilder.DefineProperty(name, PropertyAttributes.None, propType, null, modopt, Type.EmptyTypes, null, null);
a4354 4
						if (fw.HasNonPublicTypeInSignature || fw.FieldTypeWrapper.IsUnloadable)
						{
							AttributeHelper.SetNameSig(pb, fw.Name, fw.Signature);
						}
a4357 1
						AttributeHelper.SetNameSig(pb, fw.Name, fw.Signature);
@


1.72
log
@Removed legacy remap feature that allowed final fields as properties to be defined (long time ago this was used for the System.in/out/err fields).
@
text
@d1395 1
a1395 47
				return typeBuilder.DefineField(name, tw.TypeAsSignatureType, modreq, GetModOpt(tw), attribs);
			}

			private Type[] GetModOpt(TypeWrapper tw)
			{
				Type[] modopt = Type.EmptyTypes;
				if (tw.IsUnloadable)
				{
					modopt = new Type[] { wrapper.GetClassLoader().GetTypeWrapperFactory().DefineUnloadable(tw.Name) };
				}
				else
				{
					TypeWrapper tw1 = tw.IsArray ? tw.GetUltimateElementTypeWrapper() : tw;
					if (tw1.IsErasedOrBoxedPrimitiveOrRemapped)
					{
#if STATIC_COMPILER
						modopt = new Type[] { GetModOptHelper(tw) };
#else
						// FXBUG Ref.Emit refuses arrays in custom modifiers, so we add an array type for each dimension
						// (note that in this case we only add the custom modifiers to make the signature unique, we never read back this information)
						modopt = new Type[tw.ArrayRank + 1];
						modopt[0] = GetModOptHelper(tw1);
						for (int i = 1; i < modopt.Length; i++)
						{
							modopt[i] = typeof(Array);
						}
#endif
					}
				}
				return modopt;
			}

			private Type GetModOptHelper(TypeWrapper tw)
			{
				Debug.Assert(!tw.IsUnloadable);
				if (tw.IsArray)
				{
					return ArrayTypeWrapper.MakeArrayType(GetModOptHelper(tw.GetUltimateElementTypeWrapper()), tw.ArrayRank);
				}
				else if (tw.IsGhost)
				{
					return tw.TypeAsTBD;
				}
				else
				{
					return tw.TypeAsBaseType;
				}
d4377 2
a4378 1
					PropertyBuilder pb = typeBuilder.DefineProperty(name, PropertyAttributes.None, propType, Type.EmptyTypes);
d5872 46
@


1.71
log
@Instead of mangling field names and using NameSigAttribute, we now use modopt to modify the signature and record the real type.
@
text
@a1292 1
				bool isWrappedFinal = false;
d1333 1
a1333 9
						isWrappedFinal = fw is GetterFieldWrapper;
						if (isWrappedFinal)
						{
							// NOTE public/protected blank final fields get converted into a read-only property with a private field
							// backing store
							attribs &= ~FieldAttributes.FieldAccessMask;
							attribs |= FieldAttributes.PrivateScope;
						}
						else if (wrapper.IsInterface || wrapper.classLoader.StrictFinalFieldSemantics)
a1369 54
					if (isWrappedFinal)
					{
						methodAttribs |= MethodAttributes.SpecialName;
						MethodBuilder getter = typeBuilder.DefineMethod(GenerateUniqueMethodName("get_" + fld.Name, fw.FieldTypeWrapper.TypeAsSignatureType, Type.EmptyTypes), methodAttribs, CallingConventions.Standard, fw.FieldTypeWrapper.TypeAsSignatureType, Type.EmptyTypes);
						AttributeHelper.HideFromJava(getter);
						CodeEmitter ilgen = CodeEmitter.Create(getter);
						if (fld.IsStatic)
						{
							ilgen.Emit(OpCodes.Ldsfld, field);
						}
						else
						{
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldfld, field);
						}
						ilgen.Emit(OpCodes.Ret);
						ilgen.DoEmit();

						PropertyBuilder pb = typeBuilder.DefineProperty(fld.Name, PropertyAttributes.None, fw.FieldTypeWrapper.TypeAsSignatureType, Type.EmptyTypes);
						pb.SetGetMethod(getter);
						if (!fld.IsStatic)
						{
							// this method exist for use by reflection only
							// (that's why it only exists for instance fields, final static fields are not settable by reflection)
							MethodBuilder setter = typeBuilder.DefineMethod("__<set>", MethodAttributes.PrivateScope, CallingConventions.Standard, Types.Void, new Type[] { fw.FieldTypeWrapper.TypeAsSignatureType });
							ilgen = CodeEmitter.Create(setter);
							ilgen.Emit(OpCodes.Ldarg_0);
							ilgen.Emit(OpCodes.Ldarg_1);
							ilgen.Emit(OpCodes.Stfld, field);
							ilgen.Emit(OpCodes.Ret);
							pb.SetSetMethod(setter);
							ilgen.DoEmit();
						}
						((GetterFieldWrapper)fw).SetGetter(getter);
#if STATIC_COMPILER
						if (fw.FieldTypeWrapper.IsErasedOrBoxedPrimitiveOrRemapped)
						{
							AttributeHelper.SetNameSig(getter, fld.Name, fld.Signature);
						}
						if (setModifiers || fld.IsTransient)
						{
							AttributeHelper.SetModifiers(getter, fld.Modifiers, fld.IsInternal);
						}
						if (fld.DeprecatedAttribute)
						{
							// NOTE for better interop with other languages, we set the ObsoleteAttribute on the property itself
							AttributeHelper.SetDeprecatedAttribute(pb);
						}
						if (fld.GenericSignature != null)
						{
							AttributeHelper.SetSignatureAttribute(getter, fld.GenericSignature);
						}
#endif // STATIC_COMPILER
					}
a1371 1
				if (!isWrappedFinal)
a4234 6
								GetterFieldWrapper getter = fields[i] as GetterFieldWrapper;
								if (getter != null)
								{
									annotation.Apply(wrapper.GetClassLoader(), (MethodBuilder)getter.GetGetter(), def);
								}
								else
@


1.70
log
@When generating an access stub for a bridge method, prefix the access stub with <bridge> as well (to avoid confusing any other compilers).
@
text
@d1141 1
a1141 1
				return DynamicClassLoader.EscapeName(inner.Substring(outer.Length + 1));
d1282 1
a1282 1
					return typeBuilder.DefineField(fw.Name, fw.FieldTypeWrapper.TypeAsSignatureType, fieldAttribs);
d1287 1
a1287 13
				string fieldName = fld.Name;
				TypeWrapper typeWrapper = fw.FieldTypeWrapper;
				Type type = typeWrapper.TypeAsSignatureType;
				bool setNameSig = typeWrapper.IsErasedOrBoxedPrimitiveOrRemapped;
				if (setNameSig)
				{
					// TODO use clashtable
					// the field name is mangled here, because otherwise it can (theoretically)
					// conflict with another unloadable or object or ghost array field
					// (fields can be overloaded on type)
					fieldName += "/" + typeWrapper.Name;
				}
				string realFieldName = fieldName;
d1327 1
a1327 1
					field = typeBuilder.DefineField(fieldName, type, attribs);
d1369 1
a1369 1
						realFieldName = NamePrefix.Type2AccessStubBackingField + fieldName;
d1373 1
a1373 6
					Type[] modreq = Type.EmptyTypes;
					if (fld.IsVolatile)
					{
						modreq = new Type[] { Types.IsVolatile };
					}
					field = typeBuilder.DefineField(realFieldName, type, modreq, Type.EmptyTypes, attribs);
d1382 1
a1382 1
						MethodBuilder getter = typeBuilder.DefineMethod(GenerateUniqueMethodName("get_" + fieldName, type, Type.EmptyTypes), methodAttribs, CallingConventions.Standard, type, Type.EmptyTypes);
d1397 1
a1397 1
						PropertyBuilder pb = typeBuilder.DefineProperty(fieldName, PropertyAttributes.None, type, Type.EmptyTypes);
d1403 1
a1403 1
							MethodBuilder setter = typeBuilder.DefineMethod("__<set>", MethodAttributes.PrivateScope, CallingConventions.Standard, Types.Void, new Type[] { type });
d1414 1
a1414 1
						if (setNameSig)
a1442 4
					if (setNameSig)
					{
						AttributeHelper.SetNameSig(field, fld.Name, fld.Signature);
					}
d1456 52
@


1.69
log
@- Don't generate access stubs for protected members in final classes.
- Don't generate non-virtual access stubs in final classes.
@
text
@d2909 1
a2909 1
									name = "<bridge>" + name;
d4582 3
a4584 1
				string name = virt ? wrapper.GenerateUniqueMethodName(mw.Name, returnType, parameterTypes) : NamePrefix.NonVirtual + id;
@


1.68
log
@Implemented type 2 access stubs for methods (not constructors) and rewrote how type 1 access stubs are handled.
@
text
@d4390 1
a4390 1
							if ((fw.IsPublic || fw.IsProtected)
d4409 3
a4411 1
					if (fw.HasNonPublicTypeInSignature && fw.FieldTypeWrapper.IsAccessibleFrom(wrapper))
d4528 1
a4528 1
						if ((mw.IsPublic || mw.IsProtected)
d4535 1
a4535 1
							if (!mw.IsStatic && !mw.IsFinal && !mw.IsAbstract)
d4550 1
d4555 1
a4555 1
						if (!mw.IsStatic && !mw.IsFinal && !mw.IsAbstract)
@


1.67
log
@Fixed several type 1 method access stub issues.
@
text
@d2434 5
a2438 1
								if (baseMethod2.DeclaringType.IsPackageAccessibleFrom(wrapper) && !baseMethod2.IsPrivate)
d2547 5
a2551 1
								if (baseMethod2.DeclaringType.IsPackageAccessibleFrom(wrapper) && !baseMethod2.IsPrivate)
d4160 1
a4160 1
				// if we have public fields that have non-public field types, we need access stubs
d4163 1
a4163 3
					AddType1FieldAccessStubs(wrapper);
					AddType2FieldAccessStubs();
					AddType1MethodAccessStubs();
d4345 38
a4382 1
			private void AddType1FieldAccessStubs(TypeWrapper tw)
d4393 1
a4393 1
								GenerateAccessStub(fw, true);
d4399 1
a4399 1
						AddType1FieldAccessStubs(iface);
d4405 1
a4405 1
			private void AddType2FieldAccessStubs()
d4409 1
a4409 1
					if (fw.HasNonPublicTypeInSignature)
d4411 1
a4411 1
						GenerateAccessStub(fw, false);
d4416 1
a4416 1
			private void GenerateAccessStub(FieldWrapper fw, bool type1)
d4418 21
d4444 7
d4459 1
a4459 14
					string name = fw.Name;
					// If there is a potential for property name clashes (e.g. we have multiple fields with the same name in this class,
					// or the current class hides a field in the base class) we will mangle the name as a precaution. We could use a more
					// complicated scheme which would result in less mangling, but it is exceedingly unlikely to encounter a class with
					// these field name clashes, because Java cannot handle them either.
					foreach (FieldWrapper field in wrapper.GetFields())
					{
						if (field != fw && !field.IsPrivate && field.Name == name)
						{
							name = "<>" + fw.Name + fw.Signature;
							break;
						}
					}
					Type propType = fw.FieldTypeWrapper.GetPublicBaseTypeWrapper().TypeAsSignatureType;
d4464 1
a4464 1
						if (fw.HasNonPublicTypeInSignature)
d4508 1
d4520 1
a4520 1
			private void AddType1MethodAccessStubs()
d4522 1
a4522 1
				for (int pass = 0; pass < 2; pass++)
d4524 1
a4524 1
					for (TypeWrapper tw = wrapper.BaseTypeWrapper; tw != null && !tw.IsPublic; tw = tw.BaseTypeWrapper)
d4526 5
a4530 1
						foreach (MethodWrapper mw in tw.GetMethods())
d4532 2
a4533 4
							if ((mw.IsPublic || mw.IsProtected)
								&& (!mw.IsAbstract || wrapper.IsAbstract)
								&& mw.Name != StringConstants.INIT
								&& wrapper.GetMethodWrapper(mw.Name, mw.Signature, true) == mw)
d4535 1
a4535 19
								// we generate type 1a in the first pass, because it can't deal with name collisions
								if (pass == 0)
								{
									if (!mw.HasNonPublicTypeInSignature)
									{
										GenerateType1aAccessStub(mw);
									}
								}
								else
								{
									if (mw.HasNonPublicTypeInSignature)
									{
										GenerateType1bAccessStub(mw, true);
										if (!wrapper.IsFinal && !mw.IsStatic)
										{
											GenerateType1bAccessStub(mw, false);
										}
									}
								}
d4537 18
d4556 1
d4561 1
a4561 1
			private void GenerateType1aAccessStub(MethodWrapper mw)
d4564 1
a4564 1
				MethodAttributes stubattribs = mw.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
d4570 4
a4573 1
				else
d4575 2
a4576 11
					stubattribs |= MethodAttributes.CheckAccessOnOverride | MethodAttributes.Virtual;
					if (mw.IsAbstract)
					{
						stubattribs |= MethodAttributes.Abstract;
					}
					if (mw.IsFinal)
					{
						// NOTE final methods still need to be virtual, because a subclass may need this method to
						// implement an interface method
						stubattribs |= MethodAttributes.Final | MethodAttributes.NewSlot;
					}
d4578 4
a4581 4
				Type[] parameterTypes = mw.GetParametersForDefineMethod();
				Type returnType = mw.ReturnTypeForDefineMethod;
				// register the name where about to use up (it can't exist already)
				if (mw.Name != wrapper.GenerateUniqueMethodName(mw.Name, returnType, parameterTypes))
d4583 2
a4584 1
					throw new InvalidOperationException();
d4586 1
a4586 3
				MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, stubattribs, returnType, parameterTypes);
				AttributeHelper.HideFromReflection(mb, HideFromReflectionAttribute.Type1aAccessStub);
				if (!mw.IsAbstract)
d4588 2
a4589 8
					CodeEmitter ilgen = CodeEmitter.Create(mb);
					Type[] realParamTypes = mw.GetParametersForDefineMethod();
					int argpos = 0;
					if (!mw.IsStatic)
					{
						ilgen.Emit(OpCodes.Ldarg_S, (byte)argpos++);
					}
					for (int i = 0; i < realParamTypes.Length; i++)
d4591 1
a4591 1
						ilgen.Emit(OpCodes.Ldarg_S, (byte)argpos++);
a4592 3
					mw.EmitCall(ilgen);
					ilgen.Emit(OpCodes.Ret);
					ilgen.DoEmit();
a4593 22
			}

			private void GenerateType1bAccessStub(MethodWrapper mw, bool virt)
			{
				Debug.Assert(!mw.HasCallerID);
				MethodAttributes stubattribs = mw.IsPublic && virt ? MethodAttributes.Public : MethodAttributes.FamORAssem;
				stubattribs |= MethodAttributes.HideBySig;
				if (mw.IsStatic)
				{
					stubattribs |= MethodAttributes.Static;
				}
				TypeWrapper[] realParameterTypes = mw.GetParameters();
				Type[] parameterTypes = new Type[realParameterTypes.Length];
				for (int i = 0; i < realParameterTypes.Length; i++)
				{
					parameterTypes[i] = realParameterTypes[i].GetPublicBaseTypeWrapper().TypeAsSignatureType;
				}
				Type returnType = mw.ReturnType.GetPublicBaseTypeWrapper().TypeAsSignatureType;
				string realName = wrapper.GenerateUniqueMethodName(virt ? mw.Name : NamePrefix.Type1bNonVirtualAccessStub + mw.Name, returnType, parameterTypes);
				MethodBuilder mb = typeBuilder.DefineMethod(realName, stubattribs, returnType, parameterTypes);
				AttributeHelper.HideFromReflection(mb, mw.IsStatic ? HideFromReflectionAttribute.Type1bAccessStubStatic : virt ? HideFromReflectionAttribute.Type1bAccessStubVirtual : HideFromReflectionAttribute.Type1bAccessStubNonVirtual);
				AttributeHelper.SetNameSig(mb, mw.Name, mw.Signature);
a4594 1
				Type[] realParamTypes = mw.GetParametersForDefineMethod();
d4600 1
a4600 1
				for (int i = 0; i < realParamTypes.Length; i++)
d4603 2
a4604 1
					if (realParamTypes[i] != parameterTypes[i])
d4606 1
a4606 1
						ilgen.Emit(OpCodes.Castclass, realParamTypes[i]);
d4620 17
@


1.66
log
@Simplified and renamed type 1 method access stub method.
@
text
@d4463 1
a4463 1
				for (TypeWrapper tw = wrapper.BaseTypeWrapper; tw != null && !tw.IsPublic; tw = tw.BaseTypeWrapper)
d4465 1
a4465 1
					foreach (MethodWrapper mw in tw.GetMethods())
d4467 1
a4467 3
						if ((mw.IsPublic || mw.IsProtected)
							&& mw.Name != StringConstants.INIT
							&& wrapper.GetMethodWrapper(mw.Name, mw.Signature, true) == mw)
d4469 25
a4493 1
							GenerateType1AccessStub(mw);
d4499 1
a4499 1
			private void GenerateType1AccessStub(MethodWrapper mw)
d4511 1
a4511 1
					if (mw.IsAbstract && wrapper.IsAbstract)
a4520 5
					if (mw.HasNonPublicTypeInSignature)
					{
						// we're changing the signature, so we need NewSlot
						stubattribs |= MethodAttributes.NewSlot | MethodAttributes.Final;
					}
d4522 4
a4525 3
				Type[] parameterTypes;
				Type returnType;
				if (mw.HasNonPublicTypeInSignature)
d4527 1
a4527 27
					TypeWrapper[] realParameterTypes = mw.GetParameters();
					parameterTypes = new Type[realParameterTypes.Length];
					for (int i = 0; i < realParameterTypes.Length; i++)
					{
						parameterTypes[i] = realParameterTypes[i].GetPublicBaseTypeWrapper().TypeAsSignatureType;
					}
					returnType = mw.ReturnType.GetPublicBaseTypeWrapper().TypeAsSignatureType;
				}
				else
				{
					parameterTypes = mw.GetParametersForDefineMethod();
					returnType = mw.ReturnTypeForDefineMethod;
				}
				string realName = wrapper.GenerateUniqueMethodName(mw.Name, returnType, parameterTypes);
				if (realName != mw.Name && (stubattribs & MethodAttributes.Virtual) != 0)
				{
					stubattribs |= MethodAttributes.NewSlot;
				}
				MethodBuilder mb = typeBuilder.DefineMethod(realName, stubattribs, returnType, parameterTypes);
				if (realName != mw.Name && (stubattribs & (MethodAttributes.Virtual | MethodAttributes.Final)) == MethodAttributes.Virtual)
				{
					typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
				}
				AttributeHelper.HideFromReflection(mb);
				if (mw.HasNonPublicTypeInSignature || realName != mw.Name)
				{
					AttributeHelper.SetNameSig(mb, mw.Name, mw.Signature);
d4529 2
a4542 4
						if (realParamTypes[i] != parameterTypes[i])
						{
							ilgen.Emit(OpCodes.Castclass, realParamTypes[i]);
						}
d4548 30
a4577 1
				else if (!wrapper.IsAbstract)
d4579 13
a4591 3
					CodeEmitter ilgen = CodeEmitter.Create(mb);
					ilgen.EmitThrow("java.lang.AbstractMethodError", wrapper.Name + "." + mw.Name + mw.Signature);
					ilgen.DoEmit();
d4593 2
@


1.65
log
@Fixed bug in type 1 field access stub. When field type is non-public the property needs a NameSigAttribute.
@
text
@d4471 1
a4471 1
							GenerateAccessStub(mw);
d4477 1
a4477 1
			private void GenerateAccessStub(MethodWrapper mw)
d4513 1
a4513 16
						if (!realParameterTypes[i].IsPublic)
						{
							parameterTypes[i] = realParameterTypes[i].GetPublicBaseTypeWrapper().TypeAsSignatureType;
						}
						else
						{
							parameterTypes[i] = realParameterTypes[i].TypeAsSignatureType;
						}
					}
					if (!mw.ReturnType.IsPublic)
					{
						returnType = mw.ReturnType.GetPublicBaseTypeWrapper().TypeAsSignatureType;
					}
					else
					{
						returnType = mw.ReturnType.TypeAsSignatureType;
d4515 1
@


1.64
log
@Added support for type 1 access stub methods with non-public parameter/return types.
@
text
@d4406 4
@


1.63
log
@Added a property to decide if we need a type 2 access stub to make sure the check is consistent (and this also fixes a bug where we needlessly create an access stub for field where the field type is unloadable).
@
text
@d2311 4
d2329 4
d2504 4
d2511 1
a2511 1
					if (baseMethod.IsFinal
d2518 1
a2518 1
					if (baseMethod.IsStatic)
d4495 46
a4541 1
				MethodBuilder mb = typeBuilder.DefineMethod(mw.Name, stubattribs, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod());
d4543 4
d4550 3
a4552 2
					int argc = mw.GetParametersForDefineMethod().Length + (mw.IsStatic ? 0 : 1);
					for (int i = 0; i < argc; i++)
d4554 9
a4562 1
						ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
@


1.62
log
@Made method access stub generation more consistent with field access stubs (although we currently only have type 1 access stubs for methods, type 2 still needs to be added).
@
text
@d1367 1
a1367 1
					if (wrapper.IsPublic && (fw.IsPublic || fw.IsProtected) && !fw.FieldTypeWrapper.IsPublic)
d4354 1
a4354 1
					if ((fw.IsPublic || fw.IsProtected) && !fw.FieldTypeWrapper.IsPublic)
@


1.61
log
@Removed the need for access stubs in dynamic mode with CLASSGC enabled by dynamically adding InternalsVisibleToAttribute to the dynamic assemblies.
@
text
@d561 1
a561 1
				if (!wrapper.IsInterface || wrapper.IsPublic)
d563 5
a567 29
					List<MethodWrapper> methodsArray = null;
					List<MethodWrapper[]> baseMethodsArray = null;
					if (wrapper.IsAbstract)
					{
						methodsArray = new List<MethodWrapper>(methods);
						baseMethodsArray = new List<MethodWrapper[]>(baseMethods);
						AddMirandaMethods(methodsArray, baseMethodsArray, wrapper);
					}
#if STATIC_COMPILER
					if (!wrapper.IsInterface && wrapper.IsPublic)
					{
						TypeWrapper baseTypeWrapper = wrapper.BaseTypeWrapper;
						while (baseTypeWrapper != null && !baseTypeWrapper.IsPublic)
						{
							if (methodsArray == null)
							{
								methodsArray = new List<MethodWrapper>(methods);
								baseMethodsArray = new List<MethodWrapper[]>(baseMethods);
							}
							AddAccessStubMethods(methodsArray, baseMethodsArray, baseTypeWrapper);
							baseTypeWrapper = baseTypeWrapper.BaseTypeWrapper;
						}
					}
#endif
					if (methodsArray != null)
					{
						this.methods = methodsArray.ToArray();
						this.baseMethods = baseMethodsArray.ToArray();
					}
a1067 26
#if STATIC_COMPILER || NET_4_0
			private static bool ContainsMemberWrapper(List<FieldWrapper> members, string name, string sig)
			{
				foreach (MemberWrapper mw in members)
				{
					if (mw.Name == name && mw.Signature == sig)
					{
						return true;
					}
				}
				return false;
			}

			private static bool ContainsMemberWrapper(List<MethodWrapper> members, string name, string sig)
			{
				foreach (MemberWrapper mw in members)
				{
					if (mw.Name == name && mw.Signature == sig)
					{
						return true;
					}
				}
				return false;
			}
#endif // STATIC_COMPILER || NET_4_0

a1131 17
			private void AddAccessStubMethods(List<MethodWrapper> methods, List<MethodWrapper[]> baseMethods, TypeWrapper tw)
			{
				foreach (MethodWrapper mw in tw.GetMethods())
				{
					if ((mw.IsPublic || mw.IsProtected)
						&& mw.Name != "<init>"
						&& !ContainsMemberWrapper(methods, mw.Name, mw.Signature))
					{
						MethodWrapper stub = new SmartCallMethodWrapper(wrapper, mw.Name, mw.Signature, null, null, null, mw.Modifiers, MemberFlags.HideFromReflection | MemberFlags.AccessStub, SimpleOpCode.Call, SimpleOpCode.Callvirt);
						methods.Add(stub);
						baseMethods.Add(new MethodWrapper[] { mw });
					}
				}
			}
#endif // STATIC_COMPILER

#if STATIC_COMPILER
a2728 45
						else if (methods[index].IsAccessStub)
						{
							Debug.Assert(baseMethods[index].Length == 1 && !baseMethods[index][0].HasCallerID);
							MethodAttributes stubattribs = baseMethods[index][0].IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
							stubattribs |= MethodAttributes.HideBySig;
							if (baseMethods[index][0].IsStatic)
							{
								stubattribs |= MethodAttributes.Static;
							}
							else
							{
								stubattribs |= MethodAttributes.CheckAccessOnOverride | MethodAttributes.Virtual;
								if (baseMethods[index][0].IsAbstract && wrapper.IsAbstract)
								{
									stubattribs |= MethodAttributes.Abstract;
								}
								if (baseMethods[index][0].IsFinal)
								{
									// NOTE final methods still need to be virtual, because a subclass may need this method to
									// implement an interface method
									stubattribs |= MethodAttributes.Final | MethodAttributes.NewSlot;
								}
							}
							MethodBuilder mb = typeBuilder.DefineMethod(methods[index].Name, stubattribs, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							AttributeHelper.HideFromReflection(mb);
							if (!baseMethods[index][0].IsAbstract)
							{
								CodeEmitter ilgen = CodeEmitter.Create(mb);
								int argc = methods[index].GetParametersForDefineMethod().Length + (methods[index].IsStatic ? 0 : 1);
								for (int i = 0; i < argc; i++)
								{
									ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
								}
								baseMethods[index][0].EmitCall(ilgen);
								ilgen.Emit(OpCodes.Ret);
								ilgen.DoEmit();
							}
							else if (!wrapper.IsAbstract)
							{
								CodeEmitter ilgen = CodeEmitter.Create(mb);
								ilgen.EmitThrow("java.lang.AbstractMethodError", wrapper.Name + "." + methods[index].Name + methods[index].Signature);
								ilgen.DoEmit();
							}
							return mb;
						}
d4145 1
d4444 61
@


1.60
log
@Only support ikvm.lang.DllExport when -platform:x86 or -platform:x64 is explicitly specified.
@
text
@d571 1
a571 1
#if STATIC_COMPILER || NET_4_0
d1181 1
a1181 1
#if STATIC_COMPILER || NET_4_0
d1196 1
a1196 1
#endif // STATIC_COMPILER || NET_4_0
@


1.59
log
@Added ikvm.lang.DllExport annotation to export static methods as unmanaged exports.
@
text
@d4345 1
a4345 1
					if (m.DllExportName != null)
a4347 2
						// when you add unmanaged exports, the ILOnly flag MUST NOT be set or the DLL will fail to load
						((CompilerClassLoader)wrapper.GetClassLoader()).ClearILOnlyFlag();
@


1.58
log
@Implemented JDK 7 method overriding behavior.
@
text
@d4345 6
@


1.57
log
@Restructured method overriding to prepare for Java 7 behavior (not yet implemented).
@
text
@d551 1
a551 1
							baseMethods[i] = FindBaseMethods(m.Name, m.Signature, out explicitOverride);
d2352 1
a2352 1
			private MethodWrapper[] FindBaseMethods(string name, string sig, out bool explicitOverride)
d2355 1
a2355 1
				Debug.Assert(name != "<init>");
d2357 197
@


1.56
log
@Moved loader constraint checking into a separate method.
@
text
@d471 1
a471 1
			private MethodWrapper[] baseMethods;
d496 1
a496 1
				baseMethods = new MethodWrapper[classFile.Methods.Length];
d551 1
a551 1
							baseMethods[i] = FindBaseMethod(m.Name, m.Signature, out explicitOverride);
d564 1
a564 1
					List<MethodWrapper> baseMethodsArray = null;
d568 1
a568 1
						baseMethodsArray = new List<MethodWrapper>(baseMethods);
d580 1
a580 1
								baseMethodsArray = new List<MethodWrapper>(baseMethods);
d1144 1
a1144 1
			private void AddMirandaMethods(List<MethodWrapper> methods, List<MethodWrapper> baseMethods, TypeWrapper tw)
d1167 1
a1167 1
									baseMethods.Add(ifmethod);
d1182 1
a1182 1
			private void AddAccessStubMethods(List<MethodWrapper> methods, List<MethodWrapper> baseMethods, TypeWrapper tw)
d1192 1
a1192 1
						baseMethods.Add(mw);
d1274 1
a1274 2
				MethodWrapper baseMethod = baseMethods[index];
				if (baseMethod != null)
d1276 5
a1280 2
					baseMethod.Link();
					unloadableOverrideStub = CheckLoaderConstraints(mw, baseMethod);
d2351 2
a2352 2
			// this finds the method that md is going to be overriding
			private MethodWrapper FindBaseMethod(string name, string sig, out bool explicitOverride)
d2373 1
a2373 1
						throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + baseMethod.DeclaringType.Name + " is overriden in " + wrapper.Name);
d2390 30
a2419 1
						return baseMethod;
d2428 1
a2428 1
							return baseMethod;
d2580 2
a2581 2
							Debug.Assert(baseMethods[index].DeclaringType.IsInterface);
							string name = GenerateUniqueMethodName(methods[index].Name, baseMethods[index]);
d2593 1
a2593 1
							if (!baseMethods[index].IsDynamicOnly && name != baseMethods[index].RealName)
d2595 1
a2595 1
								typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethods[index].GetMethod());
d2601 2
a2602 2
							Debug.Assert(!baseMethods[index].HasCallerID);
							MethodAttributes stubattribs = baseMethods[index].IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
d2604 1
a2604 1
							if (baseMethods[index].IsStatic)
d2611 1
a2611 1
								if (baseMethods[index].IsAbstract && wrapper.IsAbstract)
d2615 1
a2615 1
								if (baseMethods[index].IsFinal)
d2624 1
a2624 1
							if (!baseMethods[index].IsAbstract)
d2632 1
a2632 1
								baseMethods[index].EmitCall(ilgen);
a2810 7
						// if a method is virtual, we need to find the method it overrides (if any), for several reasons:
						// - if we're overriding a method that has a different name (e.g. some of the virtual methods
						//   in System.Object [Equals <-> equals]) we need to add an explicit MethodOverride
						// - if one of the base classes has a similar method that is private (or package) that we aren't
						//   overriding, we need to specify an explicit MethodOverride
						MethodWrapper baseMce = baseMethods[index];
						bool explicitOverride = methods[index].IsExplicitOverride;
d2813 1
a2813 3
							// make sure the base method is already defined
							Debug.Assert(baseMce == null || baseMce.GetMethod() != null);
							if (baseMce == null || baseMce.DeclaringType.IsInterface)
d2824 2
a2825 4
								MethodBase baseMethod = baseMce.GetMethod();
								if ((baseMethod.IsPublic && !m.IsPublic) ||
									((baseMethod.IsFamily || baseMethod.IsFamilyOrAssembly) && !m.IsPublic && !m.IsProtected) ||
									(!m.IsPublic && !m.IsProtected && !baseMce.DeclaringType.IsPackageAccessibleFrom(wrapper)))
d2827 10
a2836 3
									attribs &= ~MethodAttributes.MemberAccessMask;
									attribs |= baseMethod.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
									setModifiers = true;
d2849 1
a2849 1
							if (baseMce != null && ReferenceEquals(m.Name, StringConstants.FINALIZE) && ReferenceEquals(m.Signature, StringConstants.SIG_VOID))
d2852 1
a2852 1
								if (baseMce.DeclaringType == CoreClasses.java.lang.Object.Wrapper)
d2905 2
a2906 2
							bool needMethodImpl = baseMce != null && (setNameSig || explicitOverride || baseMce.RealName != name) && !needFinalize;
							if (unloadableOverrideStub || needMethodImpl)
d2913 5
a2917 7
								GenerateUnloadableOverrideStub(wrapper, typeBuilder, baseMce, mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
							}
							else if (needMethodImpl)
							{
								// assert that the method we're overriding is in fact virtual and not final!
								Debug.Assert(baseMce.GetMethod().IsVirtual && !baseMce.GetMethod().IsFinal);
								typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMce.GetMethod());
d2919 1
a2919 1
							if (!m.IsStatic && !m.IsAbstract && !m.IsPrivate && baseMce != null && !baseMce.DeclaringType.IsPackageAccessibleFrom(wrapper))
d2921 2
a2922 3
								// we may have to explicitly override another package accessible abstract method
								TypeWrapper btw = baseMce.DeclaringType.BaseTypeWrapper;
								while (btw != null)
d2924 1
a2924 2
									MethodWrapper bmw = btw.GetMethodWrapper(m.Name, m.Signature, true);
									if (bmw == null)
d2926 1
a2926 9
										break;
									}
									if (bmw.DeclaringType.IsPackageAccessibleFrom(wrapper) && bmw.IsAbstract && !(bmw.IsPublic || bmw.IsProtected))
									{
										if (bmw != baseMce)
										{
											typeBuilder.DefineMethodOverride(mb, (MethodInfo)bmw.GetMethod());
										}
										break;
d2928 2
a2929 1
									btw = bmw.DeclaringType.BaseTypeWrapper;
@


1.55
log
@Bug fix. Final instance fields that have a type 2 access property should also have a (private) setter for reflection and serialization.
@
text
@d1224 1
a1224 1
			internal override MethodBase LinkMethod(MethodWrapper mw)
a1225 1
				Debug.Assert(mw != null);
d1227 1
a1227 3
				int index = GetMethodIndex(mw);
				MethodWrapper baseMethod = baseMethods[index];
				if (baseMethod != null)
d1229 1
a1229 3
					baseMethod.Link();
					// check the loader constraints
					if (mw.ReturnType != baseMethod.ReturnType)
d1231 1
a1231 1
						if (baseMethod.ReturnType.IsUnloadable || JVM.FinishingForDebugSave)
d1233 1
a1233 4
							if (!mw.ReturnType.IsUnloadable || (!baseMethod.ReturnType.IsUnloadable && JVM.FinishingForDebugSave))
							{
								unloadableOverrideStub = true;
							}
d1235 3
a1237 2
						else
						{
d1239 1
a1239 1
							StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has a return type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has a return type \"{1}\"", mw.ReturnType, baseMethod.ReturnType, mw.DeclaringType.Name, mw.Name, mw.Signature, baseMethod.DeclaringType.Name);
d1241 1
a1241 2
							throw new LinkageError("Loader constraints violated");
						}
d1243 6
a1248 3
					TypeWrapper[] here = mw.GetParameters();
					TypeWrapper[] there = baseMethod.GetParameters();
					for (int i = 0; i < here.Length; i++)
d1250 1
a1250 1
						if (here[i] != there[i])
d1252 1
a1252 1
							if (there[i].IsUnloadable || JVM.FinishingForDebugSave)
d1254 1
a1254 4
								if (!here[i].IsUnloadable || (!there[i].IsUnloadable && JVM.FinishingForDebugSave))
								{
									unloadableOverrideStub = true;
								}
d1256 3
a1258 2
							else
							{
d1260 1
a1260 1
								StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has an argument type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has an argument type \"{1}\"", here[i], there[i], mw.DeclaringType.Name, mw.Name, mw.Signature, baseMethod.DeclaringType.Name);
d1262 1
a1262 2
								throw new LinkageError("Loader constraints violated");
							}
d1266 14
@


1.54
log
@Bug fix. Don't create a miranda method if the class already has a static method with the same signature.
@
text
@a1384 14
#if STATIC_COMPILER
				if (wrapper.IsPublic && (fw.IsPublic || fw.IsProtected) && !fw.FieldTypeWrapper.IsPublic)
				{
					// this field is going to get a type 2 access stub, so we hide the actual field
					attribs &= ~FieldAttributes.FieldAccessMask;
					attribs |= FieldAttributes.Assembly;
					// instead of adding HideFromJava we rename the field to avoid confusing broken compilers
					// see https://sourceforge.net/tracker/?func=detail&atid=525264&aid=3056721&group_id=69637
					// additional note: now that we maintain the ordering of the fields, we need to recognize
					// these fields so that we know where to insert the corresponding accessor property FieldWrapper.
					realFieldName = NamePrefix.Type2AccessStubBackingField + fieldName;
				}
#endif

d1424 20
d4305 1
a4305 1
					if (!fw.IsFinal)
d4307 6
@


1.53
log
@Fix for #3404229.
@
text
@d1170 1
a1170 1
								if (!mw.IsStatic)
d4463 1
a4463 1
					if (!wrapper.IsAbstract)
@


1.52
log
@Hardened runtime against asynchronous Thread.Abort() during critical operations. Fix for bug #3385353.
@
text
@d3961 1
a3961 1
						ImplementInterfaceMethodStubs(doneSet, interfaces[i]);
d3970 1
a3970 1
							ImplementInterfaceMethodStubs(doneSet, baseTypeWrapper.Interfaces[i]);
a3977 27
					foreach (MethodWrapper mw in methods)
					{
						if (mw.Name != "<init>" && !mw.IsStatic && mw.IsPublic)
						{
							if (wrapper.BaseTypeWrapper != null && wrapper.BaseTypeWrapper.HasIncompleteInterfaceImplementation)
							{
								Dictionary<TypeWrapper, TypeWrapper> hashtable = null;
								TypeWrapper tw = wrapper.BaseTypeWrapper;
								while (tw.HasIncompleteInterfaceImplementation)
								{
									foreach (TypeWrapper iface in tw.Interfaces)
									{
										AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Name, mw.Signature, ref hashtable, false);
									}
									tw = tw.BaseTypeWrapper;
								}
							}
							if (true)
							{
								Dictionary<TypeWrapper, TypeWrapper> hashtable = null;
								foreach (TypeWrapper iface in wrapper.Interfaces)
								{
									AddMethodOverride(mw, (MethodBuilder)mw.GetMethod(), iface, mw.Name, mw.Signature, ref hashtable, true);
								}
							}
						}
					}
d4322 1
a4322 1
			private void ImplementInterfaceMethodStubs(Dictionary<TypeWrapper, TypeWrapper> doneSet, TypeWrapper interfaceTypeWrapper)
d4336 1
a4336 1
						ImplementInterfaceMethodStubImpl(method);
d4342 1
a4342 1
					ImplementInterfaceMethodStubs(doneSet, interfaces[i]);
d4346 1
a4346 1
			private void ImplementInterfaceMethodStubImpl(MethodWrapper ifmethod)
d4452 8
a4926 29
			private void AddMethodOverride(MethodWrapper method, MethodBuilder mb, TypeWrapper iface, string name, string sig, ref Dictionary<TypeWrapper, TypeWrapper> hashtable, bool unloadableOnly)
			{
				if (hashtable != null && hashtable.ContainsKey(iface))
				{
					return;
				}
				MethodWrapper mw = iface.GetMethodWrapper(name, sig, false);
				if (mw != null)
				{
					if (hashtable == null)
					{
						hashtable = new Dictionary<TypeWrapper, TypeWrapper>();
					}
					hashtable.Add(iface, iface);
					if (CheckRequireOverrideStub(method, mw))
					{
						JavaTypeImpl.GenerateUnloadableOverrideStub(wrapper, typeBuilder, mw, mb, method.ReturnTypeForDefineMethod, method.GetParametersForDefineMethod());
					}
					else if (!unloadableOnly)
					{
						typeBuilder.DefineMethodOverride(mb, (MethodInfo)mw.GetMethod());
					}
				}
				foreach (TypeWrapper iface2 in iface.Interfaces)
				{
					AddMethodOverride(method, mb, iface2, name, sig, ref hashtable, unloadableOnly);
				}
			}

@


1.51
log
@Added support for MethodHandle constants (ldc <MethodHandle>).
@
text
@d1580 10
a1589 1
					return FinishCore();
@


1.50
log
@Bug fix. The "ldc <class>" bytecode can throw an exception, so we need to treat it as such (previously it wasn't marked as throwing an exception, so an exception handler surrounding it could be "optimized" away). The new scheme is to patch the safe versions of ldc opcode into a ldc_nothrow.
@
text
@d3530 7
d3545 23
@


1.49
log
@Workaround .NET 2.0 bug in GetType().
@
text
@a1066 6
					else if (bc == NormalizedByteCode.__ldc
						&& classFile.SafeIsConstantPoolClass(m.Instructions[i].Arg1))
					{
						noop = false;
						return false;
					}
@


1.48
log
@Support a new (additional) naming scheme for "managed JNI" method container classes that avoids all the name collisions.
@
text
@d140 14
a153 9
				if (!iface.IsPublic
					&& !ReflectUtil.IsFromAssembly(iface.TypeAsBaseType, classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly)
					&& ReflectUtil.GetAssembly(iface.TypeAsBaseType).GetType(DynamicClassLoader.GetProxyHelperName(iface.TypeAsTBD)) == null)
				{
					// NOTE this happens when you call Proxy.newProxyInstance() on a non-public .NET interface
					// (for ikvmc compiled Java types, ikvmc generates public proxy stubs).
					// NOTE we don't currently check interfaces inherited from other interfaces because mainstream .NET languages
					// don't allow public interfaces extending non-public interfaces.
					throw new IllegalAccessError("Class " + f.Name + " cannot access its non-public superinterface " + iface.Name + " from another assembly");
@


1.47
log
@Instead of bailing out immediately when encountering a non-implemented native method (while compiling the core libraries), continue and fail later.
@
text
@d3731 1
a3731 1
								// see if there exists an IKVM.NativeCode class for this type
d3735 5
@


1.46
log
@Include OpenJDK 7 java.lang.AutoCloseable interface and make it shadow System.IDisposable. Removed java.io.Closeable special casing to support IDisposable (now automatic because Closeable extends AutoCloseable).
@
text
@d3796 1
a3796 1
										Environment.Exit(1);
@


1.45
log
@Unified Method/Constructor/Clinit remapper types to allow method patching to work more consistently.
@
text
@a4990 14
								else if (iface.Name == "java.io.Closeable"
									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(JVM.Import(typeof(IDisposable)))))
								{
									typeBuilder.AddInterfaceImplementation(JVM.Import(typeof(IDisposable)));
									MethodBuilder mb = typeBuilder.DefineMethod("__<>Dispose", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, Types.Void, Type.EmptyTypes);
									typeBuilder.DefineMethodOverride(mb, JVM.Import(typeof(IDisposable)).GetMethod("Dispose"));
									CodeEmitter ilgen = CodeEmitter.Create(mb);
									ilgen.Emit(OpCodes.Ldarg_0);
									MethodWrapper mw = iface.GetMethodWrapper("close", "()V", false);
									mw.Link();
									mw.EmitCallvirt(ilgen);
									ilgen.Emit(OpCodes.Ret);
									ilgen.DoEmit();
								}
@


1.44
log
@Retain reflection field ordering for ikvmc compiled code (not required by spec, but to improve compatibility with broken code).
@
text
@d3724 1
a3724 1
								// do we have a native implementation in map.xml?
d3826 1
d5083 1
a5083 1
				// do we have a native implementation in map.xml?
@


1.43
log
@Simplified renaming of fields with type 2 access stubs.
@
text
@d1307 7
d1394 3
a1396 1
					realFieldName = "__<>" + fieldName;
@


1.42
log
@Added method prologue support to remap file.
@
text
@d1352 1
a1356 1
				bool hideFromJava = false;
d1385 3
a1387 1
					hideFromJava = true;
a1434 9
					string realFieldName = fieldName;
#if STATIC_COMPILER
					if (hideFromJava)
					{
						// instead of adding HideFromJava we rename the field to avoid confusing broken compilers
						// see https://sourceforge.net/tracker/?func=detail&atid=525264&aid=3056721&group_id=69637
						realFieldName = "__<>" + fieldName;
					}
#endif // STATIC_COMPILER
@


1.41
log
@Added experimental (and for the time being undocumented) support for having ikvmc pre-generate proxy classes.
@
text
@d3723 1
a3723 1
								if (wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
d3824 1
a3824 1
							if (wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
d5081 1
a5081 1
				if (wrapper.EmitMapXmlMethodBody(ilGenerator, classFile, m))
d5398 1
a5398 1
		protected abstract bool EmitMapXmlMethodBody(CodeEmitter ilgen, ClassFile f, ClassFile.Method m);
@


1.40
log
@Allow @@ikvm.lang.Internal methods to implement an interface method.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2010 Jeroen Frijters
a5123 1
					TypeWrapper tw = CoreClasses.ikvm.@@internal.CallerID.Wrapper;
d5127 1
d5138 1
a5138 10
						typeCallerID = typeBuilder.DefineNestedType("__<CallerID>", TypeAttributes.Sealed | TypeAttributes.NestedPrivate, tw.TypeAsBaseType);
						ConstructorBuilder cb = typeCallerID.DefineConstructor(MethodAttributes.Assembly, CallingConventions.Standard, null);
						CodeEmitter ctorIlgen = CodeEmitter.Create(cb);
						ctorIlgen.Emit(OpCodes.Ldarg_0);
						MethodWrapper mw = tw.GetMethodWrapper("<init>", "()V", false);
						mw.Link();
						mw.EmitCall(ctorIlgen);
						ctorIlgen.Emit(OpCodes.Ret);
						ctorIlgen.DoEmit();
						ilGenerator.Emit(OpCodes.Newobj, cb);
d5144 16
@


1.40.2.1
log
@Backport: Fix for #3404229.
@
text
@d3915 1
a3915 1
						ImplementInterfaceMethodStubs(doneSet, interfaces[i], false);
d3924 1
a3924 1
							ImplementInterfaceMethodStubs(doneSet, baseTypeWrapper.Interfaces[i], true);
d3932 27
d4303 1
a4303 1
			private void ImplementInterfaceMethodStubs(Dictionary<TypeWrapper, TypeWrapper> doneSet, TypeWrapper interfaceTypeWrapper, bool baseClassInterface)
d4317 1
a4317 1
						ImplementInterfaceMethodStubImpl(method, baseClassInterface);
d4323 1
a4323 1
					ImplementInterfaceMethodStubs(doneSet, interfaces[i], baseClassInterface);
d4327 1
a4327 1
			private void ImplementInterfaceMethodStubImpl(MethodWrapper ifmethod, bool baseClassInterface)
a4432 8
 					else if (CheckRequireOverrideStub(mce, ifmethod))
 					{
 						JavaTypeImpl.GenerateUnloadableOverrideStub(wrapper, typeBuilder, ifmethod, (MethodInfo)mce.GetMethod(), mce.ReturnTypeForDefineMethod, mce.GetParametersForDefineMethod());
 					}
 					else if (baseClassInterface && mce.DeclaringType == wrapper)
 					{
 						typeBuilder.DefineMethodOverride((MethodInfo)mce.GetMethod(), (MethodInfo)ifmethod.GetMethod());
 					}
d4900 29
@


1.40.2.2
log
@Backport: Bug fix. Don't create a miranda method if the class already has a static method with the same signature.
@
text
@d1171 1
a1171 1
								if (!mw.IsStatic || mw.DeclaringType == wrapper)
d4417 1
a4417 1
					if (!wrapper.IsAbstract || (!baseClassInterface && wrapper.GetMethodWrapper(ifmethod.Name, ifmethod.Signature, false) != null))
@


1.40.2.3
log
@Backport: Workaround .NET 2.0 bug in GetType().
@
text
@d140 9
a148 14
				if (!iface.IsPublic && !ReflectUtil.IsFromAssembly(iface.TypeAsBaseType, classLoader.GetTypeWrapperFactory().ModuleBuilder.Assembly))
				{
					string proxyName = DynamicClassLoader.GetProxyHelperName(iface.TypeAsTBD);
					Type proxyType = ReflectUtil.GetAssembly(iface.TypeAsBaseType).GetType(proxyName);
					// FXBUG we need to check if the type returned is actually correct, because .NET 2.0 has a bug that
					// causes it to return typeof(IFoo) for GetType("__<Proxy>+IFoo")
					if (proxyType == null || proxyType.FullName != proxyName)
					{
						// NOTE this happens when you call Proxy.newProxyInstance() on a non-public .NET interface
						// (for ikvmc compiled Java types, ikvmc generates public proxy stubs).
						// NOTE we don't currently check interfaces inherited from other interfaces because mainstream .NET languages
						// don't allow public interfaces extending non-public interfaces.
						throw new IllegalAccessError("Class " + f.Name + " cannot access its non-public superinterface " + iface.Name + " from another assembly");
					}
@


1.40.2.4
log
@Backport: Bug fix. Final instance fields that have a type 2 access property should also have a (private) setter for reflection and serialization.
@
text
@a1356 1
				string realFieldName = fieldName;
d1361 1
d1384 10
d1433 6
a1438 1

d1440 1
a1440 1
					if (wrapper.IsPublic && (fw.IsPublic || fw.IsProtected) && !fw.FieldTypeWrapper.IsPublic)
a1441 8
						// this field is going to get a type 2 access stub, so we hide the actual field
						attribs &= ~FieldAttributes.FieldAccessMask;
						attribs |= FieldAttributes.Assembly;
						if (!fw.IsStatic)
						{
							// we need to have a setter for reflection and serialization
							attribs &= ~FieldAttributes.InitOnly;
						}
a1443 2
						// additional note: now that we maintain the ordering of the fields, we need to recognize
						// these fields so that we know where to insert the corresponding accessor property FieldWrapper.
d1446 1
a1446 7
#endif

					Type[] modreq = Type.EmptyTypes;
					if (fld.IsVolatile)
					{
						modreq = new Type[] { Types.IsVolatile };
					}
d4258 1
a4258 1
					if (!fw.IsFinal || (!fw.IsStatic && !type1))
a4259 6
						if (fw.IsFinal)
						{
							// we need to generate a (private) setter for final fields for reflection and serialization
							attribs &= ~MethodAttributes.MemberAccessMask;
							attribs |= MethodAttributes.Private;
						}
@


1.40.2.5
log
@Backport: Retain reflection field ordering for ikvmc compiled code (not required by spec, but to improve compatibility with broken code).
@
text
@a1311 7
				// for compatibility with broken Java code that assumes that reflection returns the fields in class declaration
				// order, we emit the fields in class declaration order in the .NET metadata (and then when we retrieve them
				// using .NET reflection, we sort on metadata token.)
				for (int i = 0; i < fieldIndex; i++)
				{
					fields[i].Link();
				}
d1439 1
a1439 1
						realFieldName = NamePrefix.Type2AccessStubBackingField + fieldName;
@


1.40.2.6
log
@Fix whitespace.
@
text
@d4425 8
a4432 8
					else if (CheckRequireOverrideStub(mce, ifmethod))
					{
						JavaTypeImpl.GenerateUnloadableOverrideStub(wrapper, typeBuilder, ifmethod, (MethodInfo)mce.GetMethod(), mce.ReturnTypeForDefineMethod, mce.GetParametersForDefineMethod());
					}
					else if (baseClassInterface && mce.DeclaringType == wrapper)
					{
						typeBuilder.DefineMethodOverride((MethodInfo)mce.GetMethod(), (MethodInfo)ifmethod.GetMethod());
					}
@


1.40.2.7
log
@Backport: The new method override resolution code.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d471 1
a471 1
			private MethodWrapper[][] baseMethods;
d496 1
a496 1
				baseMethods = new MethodWrapper[classFile.Methods.Length][];
d551 1
a551 1
							baseMethods[i] = FindBaseMethods(m.Name, m.Signature, out explicitOverride);
d564 1
a564 1
					List<MethodWrapper[]> baseMethodsArray = null;
d568 1
a568 1
						baseMethodsArray = new List<MethodWrapper[]>(baseMethods);
d580 1
a580 1
								baseMethodsArray = new List<MethodWrapper[]>(baseMethods);
d1150 1
a1150 1
			private void AddMirandaMethods(List<MethodWrapper> methods, List<MethodWrapper[]> baseMethods, TypeWrapper tw)
d1173 1
a1173 1
									baseMethods.Add(new MethodWrapper[] { ifmethod });
d1188 1
a1188 1
			private void AddAccessStubMethods(List<MethodWrapper> methods, List<MethodWrapper[]> baseMethods, TypeWrapper tw)
d1198 1
a1198 1
						baseMethods.Add(new MethodWrapper[] { mw });
d1230 1
a1230 1
			private static bool CheckLoaderConstraints(MethodWrapper mw, MethodWrapper baseMethod)
d1232 1
d1234 3
a1236 20
				if (mw.ReturnType != baseMethod.ReturnType)
				{
					if (baseMethod.ReturnType.IsUnloadable || JVM.FinishingForDebugSave)
					{
						if (!mw.ReturnType.IsUnloadable || (!baseMethod.ReturnType.IsUnloadable && JVM.FinishingForDebugSave))
						{
							unloadableOverrideStub = true;
						}
					}
					else
					{
#if STATIC_COMPILER
						StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has a return type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has a return type \"{1}\"", mw.ReturnType, baseMethod.ReturnType, mw.DeclaringType.Name, mw.Name, mw.Signature, baseMethod.DeclaringType.Name);
#endif
						throw new LinkageError("Loader constraints violated");
					}
				}
				TypeWrapper[] here = mw.GetParameters();
				TypeWrapper[] there = baseMethod.GetParameters();
				for (int i = 0; i < here.Length; i++)
d1238 3
a1240 1
					if (here[i] != there[i])
d1242 1
a1242 1
						if (there[i].IsUnloadable || JVM.FinishingForDebugSave)
d1244 1
a1244 1
							if (!here[i].IsUnloadable || (!there[i].IsUnloadable && JVM.FinishingForDebugSave))
d1252 1
a1252 1
							StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has an argument type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has an argument type \"{1}\"", here[i], there[i], mw.DeclaringType.Name, mw.Name, mw.Signature, baseMethod.DeclaringType.Name);
d1257 3
a1259 12
				}
				return unloadableOverrideStub;
			}

			internal override MethodBase LinkMethod(MethodWrapper mw)
			{
				Debug.Assert(mw != null);
				bool unloadableOverrideStub = false;
				int index = GetMethodIndex(mw);
				if (baseMethods[index] != null)
				{
					foreach (MethodWrapper baseMethod in baseMethods[index])
d1261 17
a1277 2
						baseMethod.Link();
						unloadableOverrideStub |= CheckLoaderConstraints(mw, baseMethod);
d2340 2
a2341 2
			// this finds all methods that the specified name/sig is going to be overriding
			private MethodWrapper[] FindBaseMethods(string name, string sig, out bool explicitOverride)
d2362 1
a2362 1
						throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + baseMethod.DeclaringType.Name + " is overridden in " + wrapper.Name);
d2379 1
a2379 30
						if (!baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))
						{
							// check if there is another method (in the same package) that we should override
							tw = baseMethod.DeclaringType.BaseTypeWrapper;
							while (tw != null)
							{
								MethodWrapper baseMethod2 = tw.GetMethodWrapper(name, sig, true);
								if (baseMethod2 == null)
								{
									break;
								}
								if (baseMethod2.DeclaringType.IsPackageAccessibleFrom(wrapper) && !baseMethod2.IsPrivate)
								{
									if (baseMethod2.IsFinal)
									{
										throw new VerifyError("final method " + baseMethod2.Name + baseMethod2.Signature + " in " + baseMethod2.DeclaringType.Name + " is overridden in " + wrapper.Name);
									}
									if (!baseMethod2.IsStatic)
									{
										if (baseMethod2.IsPublic || baseMethod2.IsProtected)
										{
											break;
										}
										return new MethodWrapper[] { baseMethod, baseMethod2 };
									}
								}
								tw = baseMethod2.DeclaringType.BaseTypeWrapper;
							}
						}
						return new MethodWrapper[] { baseMethod };
d2388 1
a2388 1
							return new MethodWrapper[] { baseMethod };
d2540 2
a2541 2
							Debug.Assert(baseMethods[index].Length == 1 && baseMethods[index][0].DeclaringType.IsInterface);
							string name = GenerateUniqueMethodName(methods[index].Name, baseMethods[index][0]);
d2553 1
a2553 1
							if (!baseMethods[index][0].IsDynamicOnly && name != baseMethods[index][0].RealName)
d2555 1
a2555 1
								typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethods[index][0].GetMethod());
d2561 2
a2562 2
							Debug.Assert(baseMethods[index].Length == 1 && !baseMethods[index][0].HasCallerID);
							MethodAttributes stubattribs = baseMethods[index][0].IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
d2564 1
a2564 1
							if (baseMethods[index][0].IsStatic)
d2571 1
a2571 1
								if (baseMethods[index][0].IsAbstract && wrapper.IsAbstract)
d2575 1
a2575 1
								if (baseMethods[index][0].IsFinal)
d2584 1
a2584 1
							if (!baseMethods[index][0].IsAbstract)
d2592 1
a2592 1
								baseMethods[index][0].EmitCall(ilgen);
d2771 7
d2780 3
a2782 1
							if (baseMethods[index] == null || (baseMethods[index].Length == 1 && baseMethods[index][0].DeclaringType.IsInterface))
d2793 4
a2796 2
								bool hasPublicBaseMethod = false;
								foreach (MethodWrapper baseMethodWrapper in baseMethods[index])
d2798 3
a2800 10
									MethodBase baseMethod = baseMethodWrapper.GetMethod();
									if ((baseMethod.IsPublic && !m.IsPublic) ||
										((baseMethod.IsFamily || baseMethod.IsFamilyOrAssembly) && !m.IsPublic && !m.IsProtected) ||
										(!m.IsPublic && !m.IsProtected && !baseMethodWrapper.DeclaringType.IsPackageAccessibleFrom(wrapper)))
									{
										hasPublicBaseMethod |= baseMethod.IsPublic;
										attribs &= ~MethodAttributes.MemberAccessMask;
										attribs |= hasPublicBaseMethod ? MethodAttributes.Public : MethodAttributes.FamORAssem;
										setModifiers = true;
									}
d2813 1
a2813 1
							if (baseMethods[index] != null && ReferenceEquals(m.Name, StringConstants.FINALIZE) && ReferenceEquals(m.Signature, StringConstants.SIG_VOID))
d2816 1
a2816 1
								if (baseMethods[index][0].DeclaringType == CoreClasses.java.lang.Object.Wrapper)
d2869 2
a2870 2
							bool newslot = baseMethods[index] != null && (setNameSig || methods[index].IsExplicitOverride || baseMethods[index][0].RealName != name) && !needFinalize;
							if (unloadableOverrideStub || newslot)
d2877 7
a2883 5
								foreach (MethodWrapper baseMethod in baseMethods[index])
								{
									// TODO if there are multiple base methods, we're creating an unloadable override stub for all of them, but in theory it's possible that not all of them need it
									GenerateUnloadableOverrideStub(wrapper, typeBuilder, baseMethod, mb, methods[index].ReturnTypeForDefineMethod, methods[index].GetParametersForDefineMethod());
								}
d2885 1
a2885 1
							else if (baseMethods[index] != null && !needFinalize)
d2887 3
a2889 2
								bool subsequent = false;
								foreach (MethodWrapper baseMethod in baseMethods[index])
d2891 2
a2892 1
									if (subsequent || setNameSig || methods[index].IsExplicitOverride || baseMethod.RealName != name)
d2894 9
a2902 1
										typeBuilder.DefineMethodOverride(mb, (MethodInfo)baseMethod.GetMethod());
d2904 1
a2904 2
									// the non-primary base methods always need an explicit method override
									subsequent = true;
@


1.40.2.8
log
@Backported fixes for 0.46.0.3:
- Bug fix. java.lang.Package was not populated from manifest for ikvmc compiled assemblies.
- Bug fix. When writing a direct ByteBuffer to a non-blocking socket and the write fails because there is no kernel buffer available, we should not advance the ByteBuffer position.
- Bug fix. When adding certificates to virtual cacerts file make sure that the aliases are unique.
- Bug fix. If a finally/fault handler contains reachable code before the handler's start index, the handler should branch to the handler start index.
- Bug fix. After emitting a finally/fault handler block, we should emit the block leave stubs (even though you can't leave the block, they also emit the backward branch stubs).
- Bug fix. If a Java class extends a remapped .NET type (cli.System.Object or cli.System.Exception), we should correctly report the base class.
- Bug fix. If we encounter a jsr or ret instruction, we should throw a VerifyError (instead of NotImplementedException).
- Bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
- Disable AppDomain.ProcessExit hook to run shutdown hooks when running on Mono to workaround https://bugzilla.xamarin.com/show_bug.cgi?id=5650
- Bug fix. Custom attribute properties that don't have a public getter and setter should not be exposed as annotation properties.
- Bug fix. Non-public property getter/setter methods should be ignored when we create properties to hide properties inherited from shadow types. This fixes a build break with .NET 4.5 beta which introduces a protected setter for Exception.HResult.
- Bug fix. The $Method inner class for delegates should also be loadable for generic delegates. Thanks to Michael Bayne for reporting this.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Replaced non-ascii character (micro) with ascii 'u' in Win32PrintService.java.
- IKVM.Reflection: Bug fix. Resource Directory Entries must be sorted and names are case-insensitive

Backported for 0.46.0.4:
- Fixed ikvmc to retain transient modifier on constant static final fields.
- Fixed Field.getModifiers() to only return the relevant modifiers.
- Fixed IKVM.Reflection to set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@d1464 5
a1523 5
				if (fld.IsTransient)
				{
					CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(JVM.Import(typeof(NonSerializedAttribute)).GetConstructor(Type.EmptyTypes), new object[0]);
					field.SetCustomAttribute(transientAttrib);
				}
@


1.40.2.9
log
@Updated version to 0.46.0.5 and backported bug fixes:
- IKVM.Reflection should ignore unknown metadata streams.
- Off-by-one error in local ref index reusing. Fix for bug #3575555.
- Interface mappings can be "incomplete". Fix for bug #3581564.
- The local variable state at the end of an exception block (if the last instruction is a local variable store) needs to be merged into the exception handler state.
- Local variable analysis for finally blocks was incorrect. Fixes bug #3600788.
- Don't implement interfaces that aren't accessible.
- Updated Mono workaround for Mono 3.0.x.
- Check for supported delegate signatures should detect pointers inside byref and array types and return type should be checked as well.
- Fake nested types should have Static modifier set in innerclasses attribute. Fixes scala compiler interop issue. Thanks to Michael Bayne for reporting this.
- ikvmstub -skiperror should also skip errors during WriteClass.
- An ITEMIDLIST should be freed using CoTaskMemFree.
- String.CaseInsensitiveComparator inner class should be acknowledged by String.
- Fixed the SHFILEINFO declaration. Thanks to Andras Kovacs for reporting this.
- Fixed race condition in MethodWrapper.ResolveMethod().
@
text
@a4947 4
						if (!iface.IsAccessibleFrom(wrapper))
						{
							continue;
						}
@


1.39
log
@Forgot DoEmit() call for constructors defined in xml mapping file.
@
text
@d4384 1
a4384 1
					else if (!mce.IsPublic)
d4398 1
a4398 1
					else if (mce.GetMethod() == null || mce.RealName != ifmethod.RealName)
@


1.38
log
@Fixed regression. The line number table was not emitted for constructors.
@
text
@d5083 1
@


1.37
log
@Don't depend on leave/endfinally instructions being inserted automatically by ILGenerator.
@
text
@a3678 1
						ilGenerator.DoEmit();
d3881 1
a3882 1
					ilGenerator.DoEmit();
d5088 1
@


1.36
log
@- Removed unnecessary methods from CodeEmitter.
- Removed "Lazy" prefixes in CodeEmitter.
@
text
@d2926 1
d2928 1
d4777 2
d4780 2
a4781 1
					ilGenerator.EmitWriteLine("*** exception in native code ***");
d4787 1
d4794 1
d4797 1
@


1.35
log
@Build intermediate store of MSIL code in CodeEmitter to allow post-processing optimization steps.
@
text
@d2057 1
a2057 1
					ilgen.LazyEmitLoadClass(o.wrapper);
d5157 1
a5157 1
								ilGenerator.LazyEmitLdc_I4((int)constant);
d5161 1
a5161 1
								ilGenerator.LazyEmitLdc_I4((bool)constant ? 1 : 0);
d5165 1
a5165 1
								ilGenerator.LazyEmitLdc_I4((byte)constant);
d5169 1
a5169 1
								ilGenerator.LazyEmitLdc_I4((char)constant);
d5173 1
a5173 1
								ilGenerator.LazyEmitLdc_I4((short)constant);
@


1.34
log
@Wrapped LocalBuilder in new CodeEmitterLocal class to allow CodeEmitter to encapsulate the ILGenerator fully.
@
text
@d1464 1
d1479 1
d2032 1
d2050 1
d2060 1
d2069 1
d2135 1
d2152 1
d2157 3
a2159 1
									CodeEmitter.Create(getter).ThrowException(JVM.Import(typeof(NotImplementedException)));
d2581 1
d2585 3
a2587 1
								CodeEmitter.Create(mb).EmitThrow("java.lang.AbstractMethodError", wrapper.Name + "." + methods[index].Name + methods[index].Signature);
d2936 1
d3055 1
d3558 1
d3637 3
a3639 1
									CodeEmitter.Create(mb).EmitThrow("java.lang.AbstractMethodError", mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
d3677 1
d3701 1
d3724 1
d3810 1
d3825 1
d3832 1
d3881 1
d3902 1
d4000 1
d4278 1
d4296 1
d4372 3
a4374 1
							CodeEmitter.Create(mb).EmitThrow("java.lang.LinkageError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
d4391 3
a4393 1
						CodeEmitter.Create(mb).EmitThrow("java.lang.IllegalAccessError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
d4410 1
d4430 1
d4441 3
a4443 1
						CodeEmitter.Create(mb).EmitThrow("java.lang.AbstractMethodError", wrapper.Name + "." + ifmethod.Name + ifmethod.Signature);
d4592 3
a4594 1
					JniBuilder.Generate(context, CodeEmitter.Create(mb), wrapper, mw, tb, classFile, m, args, true);
d4889 1
d4978 1
d4993 1
d5009 1
d5061 3
a5063 1
				CodeEmitter.Create(m).EmitThrow("java.lang.AbstractMethodError", "Method " + mb.DeclaringType.FullName + "." + mb.Name + " is unsupported by IKVM.");
d5137 1
@


1.33
log
@Moved line number / sequence point handling into CodeEmitter and made things more consistent.
@
text
@d4592 1
a4592 1
					LocalBuilder syncObject = null;
d4605 1
a4605 1
					LocalBuilder localRefStruct = ilGenerator.DeclareLocal(localRefStructType);
d4635 1
a4635 1
					LocalBuilder jnienv = ilGenerator.DeclareLocal(Types.IntPtr);
d4708 1
a4708 1
					LocalBuilder retValue = null;
d4720 2
a4721 2
								LocalBuilder ghost = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
								LocalBuilder obj = ilGenerator.DeclareLocal(Types.Object);
d4960 1
a4960 1
								LocalBuilder local = ilgen.DeclareLocal(iface.TypeAsSignatureType);
@


1.32
log
@Added support for boolean, byte, char and short non-final static field constant attributes.
@
text
@a3805 1
							LineNumberTableAttribute.LineNumberWriter lineNumberTable = null;
d3807 1
a3807 1
							Compiler.Compile(this, wrapper, methods[i], classFile, m, ilGenerator, ref nonleaf, invokespecialstubcache, ref lineNumberTable);
a3812 2
							if (lineNumberTable != null)
							{
d3814 1
a3814 1
								AttributeHelper.SetLineNumberTable(methods[i].GetMethod(), lineNumberTable);
d3816 3
d3823 2
a3824 1
								wrapper.lineNumberTables[i] = lineNumberTable.ToArray();
a3825 1
							}
a5033 1
				LineNumberTableAttribute.LineNumberWriter lineNumberTable = null;
d5035 1
a5035 3
				Compiler.Compile(context, wrapper, methods[methodIndex], classFile, m, ilGenerator, ref nonLeaf, invokespecialstubcache, ref lineNumberTable);
				if (lineNumberTable != null)
				{
d5037 1
a5037 1
					AttributeHelper.SetLineNumberTable(methods[methodIndex].GetMethod(), lineNumberTable);
d5039 3
d5046 2
a5047 1
					wrapper.lineNumberTables[methodIndex] = lineNumberTable.ToArray();
a5048 1
				}
@


1.31
log
@Renamed StaticCompiler.GetType() that is used exclusively by map.xml processing to make it more obvious and added error message (and abort the compile). The remaining StaticCompiler.GetType() now behaves more like Type.GetType() in that it returns null if the type isn't found.
@
text
@d5111 17
a5127 1
								ilGenerator.Emit(OpCodes.Ldc_I4, (int)constant);
@


1.30
log
@Added extra indirection thru MethodWrapper for intrinsic method call emitting to allow .NET delegate constructor optimization to use instrinsic infrastructure instead of requiring EmitNewobj to pass a MethodAnalyzer and opcode index.
@
text
@d3710 1
a3710 1
								nativeCodeType = StaticCompiler.GetType(wrapper.GetClassLoader(), "IKVM.NativeCode." + classFile.Name.Replace('$', '+'), false);
@


1.29
log
@Fix for bug #3056721.
@
text
@d967 1
a967 1
				internal override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
@


1.28
log
@Fix for #3046925.
@
text
@d1433 10
a1442 1
					field = typeBuilder.DefineField(fieldName, type, modreq, Type.EmptyTypes, attribs);
a1447 6
#if STATIC_COMPILER
					if (hideFromJava)
					{
						AttributeHelper.HideFromJava(field);
					}
#endif // STATIC_COMPILER
@


1.27
log
@Report FileFormatLimitationExceededException as a simple compiler error, not as a critical failure.
@
text
@d3591 1
a3591 1
									while (fmw != mw && (fmw.IsStatic || fmw.IsPrivate || !fmw.DeclaringType.IsPackageAccessibleFrom(mw.DeclaringType)))
@


1.27.2.1
log
@Fix for #3046925.
@
text
@d3591 1
a3591 1
									while (fmw != mw && (fmw.IsStatic || fmw.IsPrivate || !(mw.DeclaringType.IsPackageAccessibleFrom(fmw.DeclaringType) || (mw.IsInternal && mw.DeclaringType.InternalsVisibleTo(fmw.DeclaringType)))))
@


1.27.2.2
log
@Backported: Added support for boolean, byte, char and short non-final static field constant attributes.
@
text
@d5108 1
a5108 17
 								ilGenerator.LazyEmitLdc_I4((int)constant);
 							}
 							else if (constant is bool)
 							{
 								ilGenerator.LazyEmitLdc_I4((bool)constant ? 1 : 0);
 							}
 							else if (constant is byte)
 							{
 								ilGenerator.LazyEmitLdc_I4((byte)constant);
 							}
 							else if (constant is char)
 							{
 								ilGenerator.LazyEmitLdc_I4((char)constant);
 							}
 							else if (constant is short)
 							{
 								ilGenerator.LazyEmitLdc_I4((short)constant);
@


1.26
log
@Added error message (instead of simply crashing) for the case when a native method is not found in managed code and there is no JNI assembly available (as is the case during the core library build).
@
text
@d1673 6
@


1.25
log
@When we're statically compiling, register the TypeBuilder -> TypeWrapper early on, to support cyclic dependency compilation.
@
text
@d3759 7
@


1.24
log
@Store the generic metadata in a more robust format. The previous format was broken as it created a dependency between the number of methods in class file and in our internal representation (which doesn't alway match, because we add a.o. miranda methods). This fixes several Guice 2.0 test failures as reported by bug #3004682.
@
text
@d803 3
d4134 2
d4137 1
@


1.23
log
@Use Types.IsVolatile instead of re-importing.
@
text
@d3119 1
a3119 1
			private string[] genericMetaData;
d3122 1
a3122 1
			private Metadata(string[] genericMetaData, object[][] annotations)
d3134 1
a3134 1
				string[] genericMetaData = null;
d3142 1
a3142 1
							genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
d3144 5
a3148 1
						genericMetaData[i + 4] = classFile.Methods[i].GenericSignature;
d3193 1
a3193 1
							genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
d3195 5
a3199 1
						genericMetaData[i + 4 + classFile.Methods.Length] = classFile.Fields[i].GenericSignature;
d3218 1
a3218 1
						genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
d3220 1
a3220 3
					genericMetaData[0] = classFile.EnclosingMethod[0];
					genericMetaData[1] = classFile.EnclosingMethod[1];
					genericMetaData[2] = classFile.EnclosingMethod[2];
d3226 1
a3226 1
						genericMetaData = new string[classFile.Methods.Length + classFile.Fields.Length + 4];
d3228 1
a3228 1
					genericMetaData[3] = classFile.GenericSignature;
d3247 1
a3247 1
				if (m != null && m.genericMetaData != null)
d3249 1
a3249 1
					return m.genericMetaData[3];
d3256 1
a3256 1
				if (m != null && m.genericMetaData != null && m.genericMetaData[0] != null)
d3258 1
a3258 1
					return new string[] { m.genericMetaData[0], m.genericMetaData[1], m.genericMetaData[2] };
d3265 1
a3265 1
				if (m != null && m.genericMetaData != null)
d3267 1
a3267 1
					return m.genericMetaData[index + 4];
a3271 1
			// note that the caller is responsible for computing the correct index (field index + method count)
d3274 1
a3274 1
				if (m != null && m.genericMetaData != null)
d3276 1
a3276 1
					return m.genericMetaData[index + 4];
a3437 1
			// note that the caller is responsible for computing the correct index (field index + method count)
d5371 1
a5371 1
					return impl.GetGenericFieldSignature(i + GetMethods().Length);
@


1.22
log
@Changed StaticCompiler.GetType() to be multi-target aware. Instead of looking thru all assemblies currently loaded, only the relevant referenced assemblies are searched.

Note that this is a (minor) breaking change. Types referenced in -remap:map.xml file are now only resolved against directly referenced assemblies.
@
text
@d1428 1
a1428 1
						modreq = new Type[] { JVM.Import(typeof(System.Runtime.CompilerServices.IsVolatile)) };
@


1.21
log
@Added null checks.
@
text
@d3694 1
a3694 1
								nativeCodeType = StaticCompiler.GetType("IKVM.NativeCode." + classFile.Name.Replace('$', '+'), false);
@


1.20
log
@When class GC is enabled (on .NET 4.0), certain CLR features are not available and cause Ref.Emit to throw. Check for these features and throw a VerifyError instead of dying with an unexpected Ref.Emit exception.
Removed previous "handling" of DllImportAttribute (which was to simply ignore it).
@
text
@d164 1
d176 1
a176 1
				foreach (object[] ann in field.Annotations)
d178 1
a178 1
					if (ann[1].Equals("Lcli/System/ThreadStaticAttribute$Annotation;"))
d180 8
a187 5
						throw new VerifyError("ThreadStaticAttribute is not supported in dynamic mode with class GC enabled.");
					}
					if (ann[1].Equals("Lcli/System/ContextStaticAttribute$Annotation;"))
					{
						throw new VerifyError("ContextStaticAttribute is not supported in dynamic mode with class GC enabled.");
d193 1
a193 1
				foreach (object[] ann in method.Annotations)
d195 1
a195 1
					if (ann[1].Equals("Lcli/System/Runtime/InteropServices/DllImportAttribute$Annotation;"))
d197 4
a200 1
						throw new VerifyError("DllImportAttribute is not supported in dynamic mode with class GC enabled.");
@


1.19
log
@When compiled for .NET 4.0, we use an assembly per class loader, so we need access stubs in dynamic mode as well.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
d115 12
d128 1
d161 39
@


1.18
log
@Fix for bug #2946842.
@
text
@d507 1
a507 1
#if STATIC_COMPILER
d1029 1
d1031 1
d1055 1
a1055 1
#endif // STATIC_COMPILER
d1120 1
a1120 1
#if STATIC_COMPILER
d1135 1
d1137 1
@


1.17
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@d58 1
d3846 1
a3846 1
					Serialization.AddAutomagicSerialization(wrapper);
d5478 5
@


1.16
log
@Removed "constant" instance field support (which was only used by ikvmstub and doesn't make any sense anyway).
@
text
@d26 1
a26 1
#if IKVM_REF_EMIT
d4325 1
a4325 1
#if NET_4_0 || IKVM_REF_EMIT
@


1.15
log
@Integrated new IKVM.Reflection implementation.
@
text
@a1372 6
					// Instance fields can also have a ConstantValue attribute (and are inlined by the compiler),
					// and ikvmstub has to export them, so we have to add a custom attribute.
					if (constantValue != null)
					{
						AttributeHelper.SetConstantValue(field, constantValue);
					}
@


1.14
log
@Changed JNI to use standard caller ID mechanism.
@
text
@a25 1
using System.Reflection;
d27 1
d29 1
d31 1
@


1.13
log
@More changes to make future merge of IKVM.Reflection easier:
- added #if conditionals to remove runtime only methods from compiler
- added two missing JVM.Import()s.
@
text
@d4465 1
a4465 1
					argTypes[argTypes.Length - 1] = typeof(RuntimeMethodHandle);
d4475 1
a4475 1
					ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
d4531 1
a4531 1
						ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
d4546 1
a4546 1
						ilGenerator.Emit(OpCodes.Ldtoken, (MethodInfo)mw.GetMethod());
@


1.12
log
@Don't automatically hide "op_Implicit" methods. Instead mark the ones we automatically generate with HideFromJavaAttribute.
@
text
@d5314 1
a5324 1
#if !STATIC_COMPILER
@


1.11
log
@Mangle all artificial type names if they clash with Java type names in the same assembly.
@
text
@d4872 1
@


1.10
log
@- Fixed IsPackageAccessibleFrom to consider class loaders, instead of InternalsVisibleToAttribute
- Added automatic access to internal accessibility members across assemblies in multi target compilation (previously this was only done for -sharedclassloader scenarios)
- Cleaned up existing field access stubs (now known as "type 1") and added type 2 access stubs to make public fields that have a non-public field type accessible.
@
text
@d765 7
a771 2
						// TODO make sure there isn't already a nested type with the __Enum name
						enumBuilder = wrapper.TypeAsBuilder.DefineNestedType("__Enum", TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.NestedPublic | TypeAttributes.Serializable, Types.Enum);
d1712 8
d1732 1
a1732 1
						attributeTypeBuilder = o.outerClassWrapper.TypeAsBuilder.DefineNestedType(GetInnerClassName(o.outerClassWrapper.Name, o.classFile.Name) + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
d1744 1
a1744 1
						attributeTypeBuilder = o.wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(o.classFile.Name + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
d3858 7
a3864 2
					// TODO handle name clash
					tbFields = typeBuilder.DefineNestedType("__Fields", TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract);
@


1.9
log
@Baked type clean up makes no sense for IKVM.Reflection.Emit.
@
text
@a549 6
				if (wrapper.IsPublic)
				{
					List<FieldWrapper> fieldsArray = new List<FieldWrapper>(fields);
					AddAccessStubFields(fieldsArray, wrapper);
					fields = fieldsArray.ToArray();
				}
a1125 23
			private void AddAccessStubFields(List<FieldWrapper> fields, TypeWrapper tw)
			{
				do
				{
					if (!tw.IsPublic)
					{
						foreach (FieldWrapper fw in tw.GetFields())
						{
							if ((fw.IsPublic || fw.IsProtected)
								&& !ContainsMemberWrapper(fields, fw.Name, fw.Signature))
							{
								fields.Add(new AotAccessStubFieldWrapper(wrapper, fw));
							}
						}
					}
					foreach (TypeWrapper iface in tw.Interfaces)
					{
						AddAccessStubFields(fields, iface);
					}
					tw = tw.BaseTypeWrapper;
				} while (tw != null && !tw.IsPublic);
			}

a1225 5
				if (fw.IsAccessStub)
				{
					((AotAccessStubFieldWrapper)fw).DoLink(typeBuilder);
					return null;
				}
d1282 1
d1304 11
d1372 4
a1495 8
#if STATIC_COMPILER
					if (fields[i] is AotAccessStubFieldWrapper)
					{
						// HACK we skip access stubs, because we want to do the methods first
						// (to prevent the stub method from taking the name of a real method)
						continue;
					}
#endif
a1501 10
#if STATIC_COMPILER
				// HACK second pass for the access stubs (see above)
				for (int i = 0; i < fields.Length; i++)
				{
					if (fields[i] is AotAccessStubFieldWrapper)
					{
						fields[i].Link();
					}
				}
#endif
d3878 7
d4057 112
@


1.8
log
@More ikvmc assembly/type refactoring.
@
text
@d4228 1
a4228 1
#if NET_4_0
@


1.7
log
@Replaced most type literals with static field access (in Types class) or warpped JVM.Import() around them.
@
text
@d2878 1
a2878 1
								CustomAttributeBuilder cab = new CustomAttributeBuilder(StaticCompiler.GetType("IKVM.Attributes.AnnotationDefaultAttribute").GetConstructor(new Type[] { Types.Object }), new object[] { classFile.Methods[index].AnnotationDefault });
d3654 1
a3654 1
								// see if there exists a IKVM.NativeCode class for this type
d4388 1
a4388 1
				private static readonly Type localRefStructType = StaticCompiler.GetType("IKVM.Runtime.JNI+Frame");
@


1.6
log
@Don't use Type.Assembly property directly (because it isn't implemented on IKVM.Reflection.Emit types).
@
text
@d99 1
a99 1
				if (BaseTypeWrapper.TypeAsTBD == typeof(Delegate))
d104 1
a104 1
				if (BaseTypeWrapper.TypeAsTBD == typeof(ValueType) || BaseTypeWrapper.TypeAsTBD == typeof(Enum))
d269 1
a269 1
				return baseTypeWrapper != null && baseTypeWrapper.TypeAsTBD == typeof(MulticastDelegate);
d772 1
a772 1
						enumBuilder = wrapper.TypeAsBuilder.DefineNestedType("__Enum", TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.NestedPublic | TypeAttributes.Serializable, typeof(Enum));
d774 1
a774 1
						enumBuilder.DefineField("value__", typeof(int), FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
d896 1
a896 1
					constructor = this.DeclaringType.TypeAsBuilder.DefineConstructor(attribs, CallingConventions.Standard, new Type[] { typeof(object), typeof(IntPtr) }, null, null);
d1379 1
a1379 1
						modreq = new Type[] { typeof(System.Runtime.CompilerServices.IsVolatile) };
d1384 1
a1384 1
						CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(typeof(NonSerializedAttribute).GetConstructor(Type.EmptyTypes), new object[0]);
d1418 1
a1418 1
							MethodBuilder setter = typeBuilder.DefineMethod("__<set>", MethodAttributes.PrivateScope, CallingConventions.Standard, typeof(void), new Type[] { type });
d1609 1
a1609 1
						CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(AnnotationAttributeAttribute)).GetConstructor(new Type[] { typeof(string) }), new object[] { annotationBuilder.AttributeTypeName });
d1832 1
a1832 1
											CustomAttributeBuilder cab2 = new CustomAttributeBuilder(typeof(AttributeUsageAttribute).GetConstructor(new Type[] { typeof(AttributeTargets) }), new object[] { targets });
d1841 1
a1841 1
					defineConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { typeof(object[]) });
d1863 1
a1863 1
							argType = typeof(Type);
d2090 1
a2090 1
									MethodBuilder setter = attributeTypeBuilder.DefineMethod("set_" + o.methods[i].Name, MethodAttributes.Public, typeof(void), new Type[] { argType });
d2100 1
a2100 1
									CodeEmitter.Create(getter).ThrowException(typeof(NotImplementedException));
d2377 1
a2377 1
					return typeof(object).GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Instance);
d2390 1
a2390 1
							&& m.ReturnType == typeof(void)
d2393 1
a2393 1
							if (m.GetBaseDefinition().DeclaringType == typeof(object))
d2608 1
a2608 1
									modopt[i] = new Type[] { typeof(object) };
d2757 1
a2757 1
									if (baseFinalize.DeclaringType == typeof(object))
d2767 1
a2767 1
									if (baseFinalize.DeclaringType == typeof(object))
d2849 1
a2849 1
								finalizeMethod = typeBuilder.DefineMethod(finalizeName, attr, CallingConventions.Standard, typeof(void), Type.EmptyTypes);
d2864 1
a2864 1
									ilgen.BeginCatchBlock(typeof(object));
d2878 1
a2878 1
								CustomAttributeBuilder cab = new CustomAttributeBuilder(StaticCompiler.GetType("IKVM.Attributes.AnnotationDefaultAttribute").GetConstructor(new Type[] { typeof(object) }), new object[] { classFile.Methods[index].AnnotationDefault });
d4399 3
a4401 3
				private static readonly MethodInfo writeLine = typeof(Console).GetMethod("WriteLine", new Type[] { typeof(object) }, null);
				private static readonly MethodInfo monitorEnter = typeof(System.Threading.Monitor).GetMethod("Enter", new Type[] { typeof(object) });
				private static readonly MethodInfo monitorExit = typeof(System.Threading.Monitor).GetMethod("Exit", new Type[] { typeof(object) });
d4410 1
a4410 1
						syncObject = ilGenerator.DeclareLocal(typeof(object));
d4417 1
a4417 1
					FieldBuilder methodPtr = typeBuilder.DefineField("__<jniptr>" + m.Name + sig, typeof(IntPtr), FieldAttributes.Static | FieldAttributes.PrivateScope);
d4448 1
a4448 1
					LocalBuilder jnienv = ilGenerator.DeclareLocal(typeof(IntPtr));
d4459 2
a4460 2
					modargs[0] = typeof(IntPtr);
					modargs[1] = typeof(IntPtr);
d4499 1
a4499 1
							modargs[j + 2] = typeof(IntPtr);
d4510 1
a4510 1
						realRetType = typeof(byte);
d4518 1
a4518 1
						realRetType = typeof(IntPtr);
d4534 1
a4534 1
								LocalBuilder obj = ilGenerator.DeclareLocal(typeof(object));
d4549 1
a4549 1
					ilGenerator.BeginCatchBlock(typeof(object));
d4575 1
a4575 1
				private readonly static MethodInfo methodIsTracedMethod = typeof(Tracer).GetMethod("IsTracedMethod");
d4577 1
a4577 1
				private readonly static MethodInfo methodMethodInfo = typeof(Tracer).GetMethod("MethodInfo");
d4650 1
a4650 1
				ilgen.Emit(OpCodes.Newobj, typeof(StackFrame).GetConstructor(new Type[] { typeof(int), typeof(bool) }));
d4735 1
a4735 1
									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(typeof(System.Collections.IEnumerable))))
d4740 1
a4740 1
										typeBuilder.AddInterfaceImplementation(typeof(System.Collections.IEnumerable));
d4742 1
a4742 1
										MethodBuilder mb = typeBuilder.DefineMethod("System.Collections.IEnumerable.GetEnumerator", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, typeof(System.Collections.IEnumerator), Type.EmptyTypes);
d4744 1
a4744 1
										typeBuilder.DefineMethodOverride(mb, typeof(System.Collections.IEnumerable).GetMethod("GetEnumerator"));
d4754 1
a4754 1
									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(typeof(IDisposable))))
d4756 3
a4758 3
									typeBuilder.AddInterfaceImplementation(typeof(IDisposable));
									MethodBuilder mb = typeBuilder.DefineMethod("__<>Dispose", MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName, typeof(void), Type.EmptyTypes);
									typeBuilder.DefineMethodOverride(mb, typeof(IDisposable).GetMethod("Dispose"));
@


1.5
log
@Moved BakedTypeCleanupHack to DynamicTypeWrapper.
@
text
@d4725 1
a4725 1
							ifaceType = ifaceType.Assembly.GetType(DynamicClassLoader.GetProxyHelperName(ifaceType));
@


1.5.2.1
log
@Don't use Type.Assembly property directly (because it isn't implemented on IKVM.Reflection.Emit types).
@
text
@d4725 1
a4725 1
							ifaceType = ReflectUtil.GetAssembly(ifaceType).GetType(DynamicClassLoader.GetProxyHelperName(ifaceType));
@


1.5.2.2
log
@- Update version to 0.42.0.4
Backported:
- Mangle all artificial type names if they clash with Java type names in the same assembly.
- Fix for http://gcc.gnu.org/bugzilla/show_bug.cgi?id=41696
- Fixed exception sorter to be correct when invoked with two references to the same object.
@
text
@d771 2
a772 7
						CompilerClassLoader ccl = (CompilerClassLoader)wrapper.GetClassLoader();
						string name = "__Enum";
						while (!ccl.ReserveName(f.Name + "$" + name))
						{
							name += "_";
						}
						enumBuilder = wrapper.TypeAsBuilder.DefineNestedType(name, TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.NestedPublic | TypeAttributes.Serializable, typeof(Enum));
a1742 8
					// make sure we don't clash with another class name
					CompilerClassLoader ccl = (CompilerClassLoader)o.wrapper.GetClassLoader();
					string name = o.classFile.Name;
					while (!ccl.ReserveName(name + "Attribute"))
					{
						name += "_";
					}

d1755 1
a1755 1
						attributeTypeBuilder = o.outerClassWrapper.TypeAsBuilder.DefineNestedType(GetInnerClassName(o.outerClassWrapper.Name, name) + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
d1767 1
a1767 1
						attributeTypeBuilder = o.wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(name + "Attribute", typeAttributes, annotationAttributeBaseType.TypeAsBaseType);
d3881 2
a3882 7
					CompilerClassLoader ccl = (CompilerClassLoader)wrapper.GetClassLoader();
					string name = "__Fields";
					while (!ccl.ReserveName(classFile.Name + "$" + name))
					{
						name += "_";
					}
					tbFields = typeBuilder.DefineNestedType(name, TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract);
@


1.5.2.3
log
@Back port of fix for #2946842.
@
text
@a55 1
		private ConstructorInfo automagicSerializationCtor;
d3885 1
a3885 1
					wrapper.automagicSerializationCtor = Serialization.AddAutomagicSerialization(wrapper);
a5396 5

		internal override ConstructorInfo GetSerializationConstructor()
		{
			return automagicSerializationCtor;
		}
@


1.4
log
@Turned ImplementInterfaceMethodStubs and ImplementInterfaceMethodStubsImpl into instance methods.
@
text
@d33 2
d4226 106
@


1.3
log
@Moved ImplementInterfaceMethodStubs and ImplementInterfaceMethodStubsImpl to DynamicTypeWrapper.
@
text
@d3826 1
a3826 1
						ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet, interfaces[i]);
d3835 1
a3835 1
							ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet, baseTypeWrapper.Interfaces[i]);
d4084 1
a4084 1
			private static void ImplementInterfaceMethodStubs(TypeBuilder typeBuilder, DynamicTypeWrapper wrapper, Dictionary<TypeWrapper, TypeWrapper> doneSet, TypeWrapper interfaceTypeWrapper)
d4098 1
a4098 1
						ImplementInterfaceMethodStubImpl(method, typeBuilder, wrapper);
d4104 1
a4104 1
					ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet, interfaces[i]);
d4108 1
a4108 1
			private static void ImplementInterfaceMethodStubImpl(MethodWrapper ifmethod, TypeBuilder typeBuilder, DynamicTypeWrapper wrapper)
@


1.2
log
@Made ImplementInterfaceMethodStubs and ImplementInterfaceMethodStubsImpl static in preparation of moving them to DynamicTypeWrapper.
@
text
@d4084 140
@


1.1
log
@Moved DynamicTypeWrapper class into its own source file.
@
text
@a32 2
using System.Security;
using System.Security.Permissions;
d3826 1
a3826 1
						interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
d3835 1
a3835 1
							baseTypeWrapper.Interfaces[i].ImplementInterfaceMethodStubs(typeBuilder, wrapper, doneSet);
@

