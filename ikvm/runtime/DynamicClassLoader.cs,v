head	1.85;
access;
symbols
	v8_1_5717_0:1.85
	v8_1:1.85.0.4
	v8_0_5449_1:1.85
	v8_0_5449_0:1.85
	v8_0:1.85.0.2
	v7_4_5196_0:1.82
	v7_4:1.82.0.2
	v7_3:1.79.0.2
	v7_2_4630_6:1.66
	v7_2_4630_5:1.66
	v7_2_4630_4:1.66
	v7_2_4630_3:1.66
	v7_2_4630_2:1.66
	v0_46_0_4:1.57
	v7_2_4630_1:1.66
	v7_2:1.66.0.4
	v7_1_4532_2:1.66
	v7_1_4532_1:1.66
	v7_1_4532_0:1.66
	v7_1:1.66.0.2
	v7_0_4335_3:1.58
	v7_0_4335_2:1.58
	v7_0_4335_1:1.58
	v0_46_0_2:1.57
	v7_0_4335_0:1.58
	v7_0:1.58.0.2
	v0_40_0_6:1.37
	v0_40_0_5:1.37
	v0_46_0_1:1.57
	v0_46_0_0:1.57
	v0_46:1.57.0.2
	v0_36_0_14:1.25.2.2
	v0_44_0_6:1.56.2.1
	v0_44_0_5:1.56
	v0_44_0_4:1.56
	v0_44_0_3:1.56
	v0_44_0_2:1.56
	v0_42_0_7:1.49
	v0_44_0_1:1.56
	v0_44_0_0:1.56
	v0_44:1.56.0.2
	v0_42_0_6:1.49
	v0_42_0_5:1.49
	v0_42_0_4:1.49
	v0_42_0_3:1.49
	v0_42_0_2:1.49
	v0_42_0_1:1.49
	v0_42_0_0:1.49
	v0_42:1.49.0.2
	v0_40_0_3:1.37
	v0_40_0_2:1.37
	v0_40_0_1:1.37
	v0_40_0_0:1.37
	v0_40:1.37.0.2
	v0_36_0_13:1.25.2.2
	v0_38_0_1:1.34
	v0_38_0_0:1.34
	v0_38:1.34.0.2
	v0_36_0_9:1.25.2.2
	v0_36_0_7:1.25.2.1
	v0_36_0_5:1.25.2.1
	v0_36_0_4:1.25.2.1
	v0_36_0_3:1.25.2.1
	v0_36_0_2:1.25.2.1
	v0_36_0_1:1.25.2.1
	v0_36_0_0:1.25
	v0_36:1.25.0.2
	v0_34_0_3:1.24
	v0_34_0_2:1.24
	v0_34_0_1:1.24
	v0_34_0_0:1.24
	v0_34:1.24.0.4
	v0_32:1.24.0.2
	v0_32_0_0:1.24
	v0_30:1.16.0.2
	v0_28_0_0:1.8
	v0_26_0_1:1.1
	v0_26_0_0:1.1;
locks; strict;
comment	@ * @;


1.85
date	2014.07.07.07.40.35;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2014.05.15.06.13.34;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2014.04.28.14.26.38;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2014.02.20.16.51.25;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2013.03.29.10.50.17;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2013.03.25.19.57.46;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2013.03.10.09.00.44;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2013.02.16.16.38.24;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2013.02.14.13.53.13;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2013.02.14.13.33.04;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2013.02.07.09.10.10;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2013.02.07.09.06.42;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2013.02.07.08.49.42;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2013.01.30.17.39.46;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2013.01.24.17.48.38;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.24.14.29.03;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2013.01.24.13.59.10;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2013.01.24.13.54.19;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2013.01.07.12.21.52;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2011.12.15.11.53.33;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2011.12.15.08.56.10;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2011.12.14.12.06.53;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2011.12.14.11.18.12;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2011.12.14.11.12.50;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2011.12.13.10.39.46;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2011.11.24.09.08.04;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2011.11.17.13.53.02;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2011.05.12.08.08.09;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.21.05.45.48;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.08.12.47.51;	author jfrijters;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2010.06.08.12.45.58;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2010.06.08.12.45.06;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.28.06.06.37;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2010.01.25.07.52.58;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.21.04.43.27;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2009.07.27.08.06.41;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.14.06.27.41;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2009.07.13.08.00.18;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2009.06.18.06.14.55;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.18.05.55.47;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.02.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2009.05.29.07.47.20;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2009.05.28.05.58.35;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2009.05.26.10.17.57;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.26.05.00.38;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2009.05.24.06.54.24;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.02.06.30.13;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.17.07.17.31;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.14.08.42.07;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.15.12.01.19;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.06.12.22.07;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.20.07.36.50;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2008.03.04.07.25.36;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2008.02.27.09.04.21;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2007.12.19.11.28.11;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.12.06.47.48;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.11.12.12.35;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.12.09.45.30;	author jfrijters;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2006.09.14.12.55.25;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2006.09.12.09.57.36;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2006.09.01.07.53.36;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.31.09.22.10;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.23.06.01.45;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.15.08.50.43;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.12.07.43.34;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.27.11.57.33;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.26.14.16.52;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.26.07.57.18;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.24.08.21.11;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.06.13.53.52;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.05.12.53.26;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.05.08.46.56;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.04.10.13.33;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.15.09.08.01;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.05.11.21.15;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.04.08.09.56;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.27.13.59.59;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.25.10.25.20;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.23.11.57.44;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.22.14.44.07;	author jfrijters;	state Exp;
branches;
next	;

1.25.2.1
date	2007.09.13.07.30.09;	author jfrijters;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2008.02.27.07.09.47;	author jfrijters;	state Exp;
branches;
next	;

1.56.2.1
date	2010.10.22.06.57.08;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.85
log
@Simplified the anonymous class name mangling.
@
text
@/*
  Copyright (C) 2002-2014 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Security.Cryptography;
#if STATIC_COMPILER
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
using ProtectionDomain = System.Object;
#else
using System.Reflection;
using System.Reflection.Emit;
using ProtectionDomain = java.security.ProtectionDomain;
#endif

namespace IKVM.Internal
{
	sealed class DynamicClassLoader : TypeWrapperFactory
	{
		// this PublicKey must be the same as the byte array in ForgedKeyPair
		internal const string DynamicAssemblySuffixAndPublicKey = "-ikvm-runtime-injected, PublicKey=00240000048000009400000006020000002400005253413100040000010001009D674F3D63B8D7A4C428BD7388341B025C71AA61C6224CD53A12C21330A3159D300051FE2EED154FE30D70673A079E4529D0FD78113DCA771DA8B0C1EF2F77B73651D55645B0A4294F0AF9BF7078432E13D0F46F951D712C2FCF02EB15552C0FE7817FC0AED58E0984F86661BF64D882F29B619899DD264041E7D4992548EB9E";
#if !STATIC_COMPILER
		private static AssemblyBuilder jniProxyAssemblyBuilder;
		private static List<DynamicClassLoader> saveClassLoaders;
		private static int dumpCounter;
#endif // !STATIC_COMPILER
#if STATIC_COMPILER || CLASSGC
		private readonly Dictionary<string, TypeWrapper> dynamicTypes = new Dictionary<string, TypeWrapper>();
#else
		private static readonly Dictionary<string, TypeWrapper> dynamicTypes = new Dictionary<string, TypeWrapper>();
#endif
		private readonly ModuleBuilder moduleBuilder;
		private readonly bool hasInternalAccess;
#if STATIC_COMPILER
		private TypeBuilder proxiesContainer;
		private List<TypeBuilder> proxies;
#endif // STATIC_COMPILER
		private Dictionary<string, TypeBuilder> unloadables;
		private TypeBuilder unloadableContainer;
		private Type[] delegates;
#if !STATIC_COMPILER && !CLASSGC
		private static DynamicClassLoader instance = new DynamicClassLoader(CreateModuleBuilder(), false);
#endif
#if CLASSGC
		private List<string> friends = new List<string>();
#endif

		[System.Security.SecuritySafeCritical]
		static DynamicClassLoader()
		{
#if !STATIC_COMPILER
			// TODO AppDomain.TypeResolve requires ControlAppDomain permission, but if we don't have that,
			// we should handle that by disabling dynamic class loading
			AppDomain.CurrentDomain.TypeResolve += new ResolveEventHandler(OnTypeResolve);
#if !CLASSGC
			// Ref.Emit doesn't like the "<Module>" name for types
			// (since it already defines a pseudo-type named <Module> for global methods and fields)
			dynamicTypes.Add("<Module>", null);
#endif // !CLASSGC
#endif // !STATIC_COMPILER
		}

		internal DynamicClassLoader(ModuleBuilder moduleBuilder, bool hasInternalAccess)
		{
			this.moduleBuilder = moduleBuilder;
			this.hasInternalAccess = hasInternalAccess;

#if !STATIC_COMPILER
			if (JVM.IsSaveDebugImage)
			{
				if (saveClassLoaders == null)
				{
					System.Threading.Interlocked.CompareExchange(ref saveClassLoaders, new List<DynamicClassLoader>(), null);
				}
				lock (saveClassLoaders)
				{
					saveClassLoaders.Add(this);
				}
			}
#endif

#if STATIC_COMPILER || CLASSGC
			// Ref.Emit doesn't like the "<Module>" name for types
			// (since it already defines a pseudo-type named <Module> for global methods and fields)
			dynamicTypes.Add("<Module>", null);
#endif
		}

#if CLASSGC
		internal override void AddInternalsVisibleTo(Assembly friend)
		{
			string name = friend.GetName().Name;
			lock (friends)
			{
				if (!friends.Contains(name))
				{
					friends.Add(name);
					AttributeHelper.SetInternalsVisibleToAttribute((AssemblyBuilder)moduleBuilder.Assembly, name);
				}
			}
		}
#endif // CLASSGC

#if !STATIC_COMPILER
		private static Assembly OnTypeResolve(object sender, ResolveEventArgs args)
		{
#if CLASSGC
			ClassLoaderWrapper loader = ClassLoaderWrapper.GetClassLoaderForDynamicJavaAssembly(args.RequestingAssembly);
			if (loader == null)
			{
				return null;
			}
			DynamicClassLoader instance = (DynamicClassLoader)loader.GetTypeWrapperFactory();
			return Resolve(instance.dynamicTypes, args.Name);
#else
			return Resolve(dynamicTypes, args.Name);
#endif
		}

		private static Assembly Resolve(Dictionary<string, TypeWrapper> dict, string name)
		{
			TypeWrapper type;
			lock (dict)
			{
				dict.TryGetValue(name, out type);
			}
			if (type == null)
			{
				return null;
			}
			try
			{
				type.Finish();
			}
			catch(RetargetableJavaException x)
			{
				throw x.ToJava();
			}
			// NOTE We used to remove the type from the hashtable here, but that creates a race condition if
			// another thread also fires the OnTypeResolve event while we're baking the type.
			// I really would like to remove the type from the hashtable, but at the moment I don't see
			// any way of doing that that wouldn't cause this race condition.
			// UPDATE since we now also use the dynamicTypes hashtable to keep track of type names that
			// have been used already, we cannot remove the keys.
			return type.TypeAsTBD.Assembly;
		}
#endif // !STATIC_COMPILER

		internal override bool ReserveName(string name)
		{
			lock(dynamicTypes)
			{
				if(dynamicTypes.ContainsKey(name))
				{
					return false;
				}
				dynamicTypes.Add(name, null);
				return true;
			}
		}

		internal override string AllocMangledName(DynamicTypeWrapper tw)
		{
			lock(dynamicTypes)
			{
				return TypeNameMangleImpl(dynamicTypes, tw.Name, tw);
			}
		}

		internal static string TypeNameMangleImpl(Dictionary<string, TypeWrapper> dict, string name, TypeWrapper tw)
		{
			// the CLR maximum type name length is 1023 characters,
			// but we need to leave some room for the suffix that we
			// may need to append to make the name unique
			const int MaxLength = 1000;
			if (name.Length > MaxLength)
			{
				name = name.Substring(0, MaxLength) + "/truncated";
			}
			string mangledTypeName = TypeNameUtil.ReplaceIllegalCharacters(name);
			// FXBUG the CLR (both 1.1 and 2.0) doesn't like type names that end with a single period,
			// it loses the trailing period in the name that gets passed in the TypeResolve event.
			if (dict.ContainsKey(mangledTypeName) || mangledTypeName.EndsWith("."))
			{
#if STATIC_COMPILER
				Tracer.Warning(Tracer.Compiler, "Class name clash: {0}", mangledTypeName);
#endif
				// Java class names cannot contain slashes (since they are converted into periods),
				// so we take advantage of that fact to create a unique name.
				string baseName = mangledTypeName;
				int instanceId = 0;
				do
				{
					mangledTypeName = baseName + "/" + (++instanceId);
				} while (dict.ContainsKey(mangledTypeName));
			}
			dict.Add(mangledTypeName, tw);
			return mangledTypeName;
		}

		internal sealed override TypeWrapper DefineClassImpl(Dictionary<string, TypeWrapper> types, TypeWrapper host, ClassFile f, ClassLoaderWrapper classLoader, ProtectionDomain protectionDomain)
		{
#if STATIC_COMPILER
			AotTypeWrapper type = new AotTypeWrapper(f, (CompilerClassLoader)classLoader);
			type.CreateStep1();
			types[f.Name] = type;
			return type;
#elif FIRST_PASS
			return null;
#else
			// this step can throw a retargettable exception, if the class is incorrect
			DynamicTypeWrapper type = new DynamicTypeWrapper(host, f, classLoader, protectionDomain);
			// This step actually creates the TypeBuilder. It is not allowed to throw any exceptions,
			// if an exception does occur, it is due to a programming error in the IKVM or CLR runtime
			// and will cause a CriticalFailure and exit the process.
			type.CreateStep1();
			type.CreateStep2();
			if(types == null)
			{
				// we're defining an anonymous class, so we don't need any locking
				TieClassAndWrapper(type, protectionDomain);
				return type;
			}
			lock(types)
			{
				// in very extreme conditions another thread may have beaten us to it
				// and loaded (not defined) a class with the same name, in that case
				// we'll leak the the Reflection.Emit defined type. Also see the comment
				// in ClassLoaderWrapper.RegisterInitiatingLoader().
				TypeWrapper race;
				types.TryGetValue(f.Name, out race);
				if(race == null)
				{
					types[f.Name] = type;
					TieClassAndWrapper(type, protectionDomain);
				}
				else
				{
					throw new LinkageError("duplicate class definition: " + f.Name);
				}
			}
			return type;
#endif // STATIC_COMPILER
		}

#if !STATIC_COMPILER && !FIRST_PASS
		private static java.lang.Class TieClassAndWrapper(TypeWrapper type, ProtectionDomain protectionDomain)
		{
			java.lang.Class clazz = new java.lang.Class(null);
#if __MonoCS__
			TypeWrapper.SetTypeWrapperHack(clazz, type);
#else
			clazz.typeWrapper = type;
#endif
			clazz.pd = protectionDomain;
			type.SetClassObject(clazz);
			return clazz;
		}
#endif

#if STATIC_COMPILER
		internal TypeBuilder DefineProxy(string name, TypeAttributes typeAttributes, Type parent, Type[] interfaces)
		{
			if (proxiesContainer == null)
			{
				proxiesContainer = moduleBuilder.DefineType(TypeNameUtil.ProxiesContainer, TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.Abstract);
				AttributeHelper.HideFromJava(proxiesContainer);
				AttributeHelper.SetEditorBrowsableNever(proxiesContainer);
				proxies = new List<TypeBuilder>();
			}
			TypeBuilder tb = proxiesContainer.DefineNestedType(name, typeAttributes, parent, interfaces);
			proxies.Add(tb);
			return tb;
		}
#endif

		internal override Type DefineUnloadable(string name)
		{
			lock(this)
			{
				if(unloadables == null)
				{
					unloadables = new Dictionary<string, TypeBuilder>();
				}
				TypeBuilder type;
				if(unloadables.TryGetValue(name, out type))
				{
					return type;
				}
				if(unloadableContainer == null)
				{
					unloadableContainer = moduleBuilder.DefineType(UnloadableTypeWrapper.ContainerTypeName, TypeAttributes.Interface | TypeAttributes.Abstract);
					AttributeHelper.HideFromJava(unloadableContainer);
				}
				type = unloadableContainer.DefineNestedType(TypeNameUtil.MangleNestedTypeName(name), TypeAttributes.NestedPrivate | TypeAttributes.Interface | TypeAttributes.Abstract);
				unloadables.Add(name, type);
				return type;
			}
		}

		internal override Type DefineDelegate(int parameterCount, bool returnVoid)
		{
			lock (this)
			{
				if (delegates == null)
				{
					delegates = new Type[512];
				}
				int index = parameterCount + (returnVoid ? 256 : 0);
				Type type = delegates[index];
				if (type != null)
				{
					return type;
				}
				TypeBuilder tb = moduleBuilder.DefineType(returnVoid ? "__<>NVIV`" + parameterCount : "__<>NVI`" + (parameterCount + 1), TypeAttributes.NotPublic | TypeAttributes.Sealed, Types.MulticastDelegate);
				string[] names = new string[parameterCount + (returnVoid ? 0 : 1)];
				for (int i = 0; i < names.Length; i++)
				{
					names[i] = "P" + i;
				}
				if (!returnVoid)
				{
					names[names.Length - 1] = "R";
				}
				Type[] genericParameters = tb.DefineGenericParameters(names);
				Type[] parameterTypes = genericParameters;
				if (!returnVoid)
				{
					parameterTypes = new Type[genericParameters.Length - 1];
					Array.Copy(genericParameters, parameterTypes, parameterTypes.Length);
				}
				tb.DefineMethod(ConstructorInfo.ConstructorName, MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName, Types.Void, new Type[] { Types.Object, Types.IntPtr })
					.SetImplementationFlags(MethodImplAttributes.Runtime);
				MethodBuilder mb = tb.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.NewSlot | MethodAttributes.Virtual, returnVoid ? Types.Void : genericParameters[genericParameters.Length - 1], parameterTypes);
				mb.SetImplementationFlags(MethodImplAttributes.Runtime);
				type = tb.CreateType();
				delegates[index] = type;
				return type;
			}
		}

		internal override bool HasInternalAccess
		{
			get { return hasInternalAccess; }
		}

		internal void FinishAll()
		{
			Dictionary<TypeWrapper, TypeWrapper> done = new Dictionary<TypeWrapper, TypeWrapper>();
			bool more = true;
			while(more)
			{
				more = false;
				List<TypeWrapper> l = new List<TypeWrapper>(dynamicTypes.Values);
				foreach(TypeWrapper tw in l)
				{
					if(tw != null && !done.ContainsKey(tw))
					{
						more = true;
						done.Add(tw, tw);
						Tracer.Info(Tracer.Runtime, "Finishing {0}", tw.TypeAsTBD.FullName);
						tw.Finish();
					}
				}
			}
			if(unloadableContainer != null)
			{
				unloadableContainer.CreateType();
				foreach(TypeBuilder tb in unloadables.Values)
				{
					tb.CreateType();
				}
			}
#if STATIC_COMPILER
			if(proxiesContainer != null)
			{
				proxiesContainer.CreateType();
				foreach(TypeBuilder tb in proxies)
				{
					tb.CreateType();
				}
			}
#endif // STATIC_COMPILER
		}

#if !STATIC_COMPILER
		internal static void SaveDebugImages()
		{
			Console.Error.WriteLine("Saving dynamic assemblies...");
			JVM.FinishingForDebugSave = true;
			if (saveClassLoaders != null)
			{
				foreach (DynamicClassLoader instance in saveClassLoaders)
				{
					instance.FinishAll();
					AssemblyBuilder ab = (AssemblyBuilder)instance.ModuleBuilder.Assembly;
					SaveDebugAssembly(ab);
				}
			}
			if (jniProxyAssemblyBuilder != null)
			{
				SaveDebugAssembly(jniProxyAssemblyBuilder);
			}
			Console.Error.WriteLine("Saving done.");
		}

		private static void SaveDebugAssembly(AssemblyBuilder ab)
		{
			Console.Error.WriteLine("Saving '{0}'", ab.GetName().Name + ".dll");
			ab.Save(ab.GetName().Name + ".dll");
		}

		internal static ModuleBuilder CreateJniProxyModuleBuilder()
		{
			AssemblyName name = new AssemblyName();
			name.Name = "jniproxy";
			jniProxyAssemblyBuilder = DefineDynamicAssembly(name, AssemblyBuilderAccess.RunAndSave, null);
			return jniProxyAssemblyBuilder.DefineDynamicModule("jniproxy.dll", "jniproxy.dll");
		}
#endif

		internal sealed override ModuleBuilder ModuleBuilder
		{
			get
			{
				return moduleBuilder;
			}
		}

		[System.Security.SecuritySafeCritical]
		internal static DynamicClassLoader Get(ClassLoaderWrapper loader)
		{
#if STATIC_COMPILER
			return new DynamicClassLoader(((CompilerClassLoader)loader).CreateModuleBuilder(), false);
#else
			AssemblyClassLoader acl = loader as AssemblyClassLoader;
			if (acl != null && ForgedKeyPair.Instance != null)
			{
				string name = acl.MainAssembly.GetName().Name + DynamicAssemblySuffixAndPublicKey;
				foreach (InternalsVisibleToAttribute attr in acl.MainAssembly.GetCustomAttributes(typeof(InternalsVisibleToAttribute), false))
				{
					if (attr.AssemblyName == name)
					{
						AssemblyName n = new AssemblyName(name);
						n.KeyPair = ForgedKeyPair.Instance;
						return new DynamicClassLoader(CreateModuleBuilder(n), true);
					}
				}
			}
#if CLASSGC
			DynamicClassLoader instance = new DynamicClassLoader(CreateModuleBuilder(), false);
#endif
			return instance;
#endif
		}

#if !STATIC_COMPILER
		sealed class ForgedKeyPair : StrongNameKeyPair
		{
			internal static readonly StrongNameKeyPair Instance;

			static ForgedKeyPair()
			{
				try
				{
					// this public key byte array must be the same as the public key in DynamicAssemblySuffixAndPublicKey
					Instance = new ForgedKeyPair(new byte[] {
						0x00, 0x24, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x94, 0x00, 0x00,
						0x00, 0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x52, 0x53,
						0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x9D,
						0x67, 0x4F, 0x3D, 0x63, 0xB8, 0xD7, 0xA4, 0xC4, 0x28, 0xBD, 0x73,
						0x88, 0x34, 0x1B, 0x02, 0x5C, 0x71, 0xAA, 0x61, 0xC6, 0x22, 0x4C,
						0xD5, 0x3A, 0x12, 0xC2, 0x13, 0x30, 0xA3, 0x15, 0x9D, 0x30, 0x00,
						0x51, 0xFE, 0x2E, 0xED, 0x15, 0x4F, 0xE3, 0x0D, 0x70, 0x67, 0x3A,
						0x07, 0x9E, 0x45, 0x29, 0xD0, 0xFD, 0x78, 0x11, 0x3D, 0xCA, 0x77,
						0x1D, 0xA8, 0xB0, 0xC1, 0xEF, 0x2F, 0x77, 0xB7, 0x36, 0x51, 0xD5,
						0x56, 0x45, 0xB0, 0xA4, 0x29, 0x4F, 0x0A, 0xF9, 0xBF, 0x70, 0x78,
						0x43, 0x2E, 0x13, 0xD0, 0xF4, 0x6F, 0x95, 0x1D, 0x71, 0x2C, 0x2F,
						0xCF, 0x02, 0xEB, 0x15, 0x55, 0x2C, 0x0F, 0xE7, 0x81, 0x7F, 0xC0,
						0xAE, 0xD5, 0x8E, 0x09, 0x84, 0xF8, 0x66, 0x61, 0xBF, 0x64, 0xD8,
						0x82, 0xF2, 0x9B, 0x61, 0x98, 0x99, 0xDD, 0x26, 0x40, 0x41, 0xE7,
						0xD4, 0x99, 0x25, 0x48, 0xEB, 0x9E
					});
				}
				catch
				{
				}
			}

			private ForgedKeyPair(byte[] publicKey)
				: base(ToInfo(publicKey), new StreamingContext())
			{
			}

			private static SerializationInfo ToInfo(byte[] publicKey)
			{
				byte[] privateKey = publicKey;
				if (JVM.IsSaveDebugImage)
				{
					CspParameters cspParams = new CspParameters();
					cspParams.KeyContainerName = null;
					cspParams.Flags = CspProviderFlags.UseArchivableKey;
					cspParams.KeyNumber = 2;
					RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(1024, cspParams);
					privateKey = rsa.ExportCspBlob(true);
				}
				SerializationInfo info = new SerializationInfo(typeof(StrongNameKeyPair), new FormatterConverter());
				info.AddValue("_keyPairExported", true);
				info.AddValue("_keyPairArray", privateKey);
				info.AddValue("_keyPairContainer", null);
				info.AddValue("_publicKey", publicKey);
				return info;
			}
		}

		private static ModuleBuilder CreateModuleBuilder()
		{
			AssemblyName name = new AssemblyName();
			if(JVM.IsSaveDebugImage)
			{
				name.Name = "ikvmdump-" + System.Threading.Interlocked.Increment(ref dumpCounter);
			}
			else
			{
				name.Name = "ikvm_dynamic_assembly__" + (uint)Environment.TickCount;
			}
			return CreateModuleBuilder(name);
		}

		private static ModuleBuilder CreateModuleBuilder(AssemblyName name)
		{
			DateTime now = DateTime.Now;
			name.Version = new Version(now.Year, (now.Month * 100) + now.Day, (now.Hour * 100) + now.Minute, (now.Second * 1000) + now.Millisecond);
			List<CustomAttributeBuilder> attribs = new List<CustomAttributeBuilder>();
			AssemblyBuilderAccess access;
			if(JVM.IsSaveDebugImage)
			{
				access = AssemblyBuilderAccess.RunAndSave;
			}
#if CLASSGC
			else if(JVM.classUnloading
				// DefineDynamicAssembly(..., RunAndCollect, ...) does a demand for PermissionSet(Unrestricted), so we want to avoid that in partial trust scenarios
				&& AppDomain.CurrentDomain.IsFullyTrusted)
			{
				access = AssemblyBuilderAccess.RunAndCollect;
			}
#endif
			else
			{
				access = AssemblyBuilderAccess.Run;
			}
#if NET_4_0
			if(!AppDomain.CurrentDomain.IsFullyTrusted)
			{
				attribs.Add(new CustomAttributeBuilder(typeof(System.Security.SecurityTransparentAttribute).GetConstructor(Type.EmptyTypes), new object[0]));
			}
#endif
			AssemblyBuilder assemblyBuilder = DefineDynamicAssembly(name, access, attribs);
			AttributeHelper.SetRuntimeCompatibilityAttribute(assemblyBuilder);
			bool debug = JVM.EmitSymbols;
			CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, debug });
			assemblyBuilder.SetCustomAttribute(debugAttr);
			ModuleBuilder moduleBuilder = JVM.IsSaveDebugImage ? assemblyBuilder.DefineDynamicModule(name.Name, name.Name + ".dll", debug) : assemblyBuilder.DefineDynamicModule(name.Name, debug);
			moduleBuilder.SetCustomAttribute(new CustomAttributeBuilder(typeof(IKVM.Attributes.JavaModuleAttribute).GetConstructor(Type.EmptyTypes), new object[0]));
			return moduleBuilder;
		}

		private static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder> assemblyAttributes)
		{
#if NET_4_0
			return AppDomain.CurrentDomain.DefineDynamicAssembly(name, access, null, true, assemblyAttributes);
#else
			return AppDomain.CurrentDomain.DefineDynamicAssembly(name, access, null, null, null, null, null, true, assemblyAttributes);
#endif
		}
#endif // !STATIC_COMPILER
	}
}
@


1.84
log
@- (unsupported) statically generated proxy classes should only be public if all interfaces are public.
- (unsupported) statically generated proxy classes should not be static.
@
text
@d246 1
a246 4
				java.lang.Class clazz = TieClassAndWrapper(type, protectionDomain);
				// for OpenJDK compatibility and debugging convenience we modify the class name to
				// include the identity hashcode of the class object
				clazz.name = f.Name + "/" + java.lang.System.identityHashCode(clazz);
@


1.83
log
@Allow classes defined by Unsafe.defineAnonymousClass() access to private methods of their host class.
@
text
@d290 1
a290 1
		internal TypeBuilder DefineProxy(TypeWrapper proxyClass, TypeWrapper[] interfaces)
d299 1
a299 6
			Type[] ifaces = new Type[interfaces.Length];
			for (int i = 0; i < ifaces.Length; i++)
			{
				ifaces[i] = interfaces[i].TypeAsBaseType;
			}
			TypeBuilder tb = proxiesContainer.DefineNestedType(TypeNameUtil.GetProxyNestedName(interfaces), TypeAttributes.NestedPublic | TypeAttributes.Class | TypeAttributes.Sealed, proxyClass.TypeAsBaseType, ifaces);
@


1.82
log
@Added Unsafe.defineAnonymousClass().
@
text
@d226 1
a226 1
		internal sealed override TypeWrapper DefineClassImpl(Dictionary<string, TypeWrapper> types, ClassFile f, ClassLoaderWrapper classLoader, ProtectionDomain protectionDomain)
d237 1
a237 1
			DynamicTypeWrapper type = new DynamicTypeWrapper(f, classLoader, protectionDomain);
@


1.81
log
@Moved pre-compiled proxy type name generation to TypeNameUtil.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
d233 2
d243 9
d263 1
a263 10
#if !FIRST_PASS
					java.lang.Class clazz = new java.lang.Class(null);
#if __MonoCS__
					TypeWrapper.SetTypeWrapperHack(clazz, type);
#else
					clazz.typeWrapper = type;
#endif
					clazz.pd = protectionDomain;
					type.SetClassObject(clazz);
#endif
d274 15
@


1.80
log
@Added back support for JNI non-virtual method invocation for methods with more than 8 parameters.
@
text
@d277 1
a277 1
				proxiesContainer = moduleBuilder.DefineType("__<Proxies>", TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.Abstract);
d287 1
a287 1
			TypeBuilder tb = proxiesContainer.DefineNestedType(GetProxyNestedName(interfaces), TypeAttributes.NestedPublic | TypeAttributes.Class | TypeAttributes.Sealed, proxyClass.TypeAsBaseType, ifaces);
a292 15
		private static string GetProxyNestedName(TypeWrapper[] interfaces)
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			foreach (TypeWrapper tw in interfaces)
			{
				sb.Append(tw.Name.Length).Append('|').Append(tw.Name);
			}
			return TypeNameUtil.MangleNestedTypeName(sb.ToString());
		}

		internal static string GetProxyName(TypeWrapper[] interfaces)
		{
			return "__<Proxies>+" + GetProxyNestedName(interfaces);
		}

@


1.79
log
@Avoid obsolete version of DefineDynamicAssembly when building for .NET 4.0.
@
text
@d65 1
d332 41
@


1.78
log
@Fix build break. Forgot to update .NET 4.0 build specific code.
@
text
@d406 1
a406 1
			jniProxyAssemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.RunAndSave, null, null, null, null, null, true);
d547 1
a547 6
			AssemblyBuilder assemblyBuilder =
#if NET_4_0
				AppDomain.CurrentDomain.DefineDynamicAssembly(name, access, null, true, attribs);
#else
				AppDomain.CurrentDomain.DefineDynamicAssembly(name, access, null, null, null, null, null, true, attribs);
#endif
d556 9
@


1.77
log
@Lock the dynamicTypes dictionary when accessing it in the TypeResolve event handler.
@
text
@d440 1
a440 1
			DynamicClassLoader instance = new DynamicClassLoader(CreateModuleBuilder());
@


1.76
log
@Simplified jniproxy assembly debug dump.
@
text
@a130 1
			TypeWrapper type;
a131 1
			DynamicClassLoader instance;
d133 1
a133 1
			if(loader == null)
d137 2
a138 2
			instance = (DynamicClassLoader)loader.GetTypeWrapperFactory();
			instance.dynamicTypes.TryGetValue(args.Name, out type);
d140 1
a140 1
			dynamicTypes.TryGetValue(args.Name, out type);
d142 9
d210 1
a210 1
					Tracer.Warning(Tracer.Compiler, "Class name clash: {0}", mangledTypeName);
@


1.75
log
@Allow dynamic assemblies injected into assembly class loaders to be (debug dump) saved.
@
text
@d48 1
a48 1
		private static List<AssemblyBuilder> saveDebugAssemblies;
d382 1
a382 1
			if (saveDebugAssemblies != null)
d384 1
a384 4
				foreach (AssemblyBuilder ab in saveDebugAssemblies)
				{
					SaveDebugAssembly(ab);
				}
d395 1
a395 1
		internal static void RegisterForSaveDebug(AssemblyBuilder ab)
d397 4
a400 5
			if(saveDebugAssemblies == null)
			{
				saveDebugAssemblies = new List<AssemblyBuilder>();
			}
			saveDebugAssemblies.Add(ab);
@


1.74
log
@Moved progress reporting of saving dynamic assemblies dump into DynamicClassLoader.cs.
@
text
@d29 1
a75 6
			if(JVM.IsSaveDebugImage)
			{
#if !CLASSGC
				saveClassLoaders.Add(instance);
#endif
			}
d92 14
a437 4
			if(saveClassLoaders != null)
			{
				saveClassLoaders.Add(instance);
			}
d483 10
d495 1
a495 1
				info.AddValue("_keyPairArray", publicKey);
a506 4
				if(saveClassLoaders == null)
				{
					System.Threading.Interlocked.CompareExchange(ref saveClassLoaders, new List<DynamicClassLoader>(), null);
				}
@


1.73
log
@Use a proper counter to generate unique ids for dump assemblies.
@
text
@d362 1
d370 1
a370 1
					ab.Save(ab.GetName().Name + ".dll");
d377 1
a377 1
					ab.Save(ab.GetName().Name + ".dll");
d380 7
@


1.72
log
@Implemented package access checks (dynamic mode only).
@
text
@d49 1
d488 1
a488 3
				// we ignore the race condition (we could end up with multiple assemblies with the same name),
				// because it is pretty harmless (you'll miss one of the ikvmdump-xx.dll files)
				name.Name = "ikvmdump-" + saveClassLoaders.Count;
@


1.71
log
@Updated accessibility checks to handle the fact that we can now inject dynamic classes in all assemblies.
@
text
@d33 1
d37 1
d208 1
a208 1
		internal sealed override TypeWrapper DefineClassImpl(Dictionary<string, TypeWrapper> types, ClassFile f, ClassLoaderWrapper classLoader, object protectionDomain)
d217 1
a217 1
			DynamicTypeWrapper type = new DynamicTypeWrapper(f, classLoader);
d241 1
a241 1
					clazz.pd = (java.security.ProtectionDomain)protectionDomain;
@


1.70
log
@Now that dynamically loaded classes in an assembly class loader have access to the internals of the assembly, we no longer need proxy helper interfaces and we can allow extending non-public base classes and implementing non-public interfaces.
@
text
@d53 2
a54 1
		private ModuleBuilder moduleBuilder;
d62 1
a62 1
		private static DynamicClassLoader instance = new DynamicClassLoader(CreateModuleBuilder());
d89 1
a89 1
		internal DynamicClassLoader(ModuleBuilder moduleBuilder)
d92 1
d312 5
d400 1
a400 1
			return new DynamicClassLoader(((CompilerClassLoader)loader).CreateModuleBuilder());
d412 1
a412 1
						return new DynamicClassLoader(CreateModuleBuilder(n));
@


1.69
log
@(Ab)use InternalsVisibleToAttribute to allow the runtime to dynamically inject classes into statically compiled assemblies.
@
text
@a54 2
		private TypeBuilder proxyHelperContainer;
		private List<TypeBuilder> proxyHelpers;
a250 12
		internal void DefineProxyHelper(Type type)
		{
			if(proxyHelperContainer == null)
			{
				proxyHelperContainer = moduleBuilder.DefineType("__<Proxy>", TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract);
				AttributeHelper.HideFromJava(proxyHelperContainer);
				AttributeHelper.SetEditorBrowsableNever(proxyHelperContainer);
				proxyHelpers = new List<TypeBuilder>();
			}
			proxyHelpers.Add(proxyHelperContainer.DefineNestedType(TypeNameUtil.MangleNestedTypeName(type.FullName), TypeAttributes.NestedPublic | TypeAttributes.Interface | TypeAttributes.Abstract, null, new Type[] { type }));
		}

a285 5
		internal static string GetProxyHelperName(Type type)
		{
			return "__<Proxy>+" + TypeNameUtil.MangleNestedTypeName(type.FullName);
		}

a337 8
			if(proxyHelperContainer != null)
			{
				proxyHelperContainer.CreateType();
				foreach(TypeBuilder tb in proxyHelpers)
				{
					tb.CreateType();
				}
			}
@


1.68
log
@Added AttributeHelper.SetInternalsVisibleToAttribute().
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d27 2
d42 2
d48 1
d50 3
d82 5
d94 1
d98 1
d128 3
d132 1
a132 2
			instance.dynamicTypes.TryGetValue(args.Name, out type);
			if(type == null)
d420 17
a436 2
			DynamicClassLoader instance = new DynamicClassLoader(((CompilerClassLoader)loader).CreateModuleBuilder());
#elif CLASSGC
d444 1
d448 48
d513 5
@


1.67
log
@Made handling of __<Unloadable> type modifiers more explicit to avoid creating an unloadable in the wrong circumstances and to support missing unloadable modifier types.
@
text
@d95 1
a95 1
					((AssemblyBuilder)moduleBuilder.Assembly).SetCustomAttribute(new CustomAttributeBuilder(typeof(System.Runtime.CompilerServices.InternalsVisibleToAttribute).GetConstructor(new Type[] { typeof(string) }), new object[] { name }));
@


1.66
log
@Fix name length for inner classes.
@
text
@d303 1
a303 1
					unloadableContainer = moduleBuilder.DefineType("__<Unloadable>", TypeAttributes.Interface | TypeAttributes.Abstract);
@


1.65
log
@Removed class name length limitation.
@
text
@a151 1
			string mangledTypeName;
d154 19
a172 14
				// the CLR maximum type name length is 1023 characters,
				// but we need to leave some room for the suffix that we
				// may need to append to make the name unique
				const int MaxLength = 1000;
				string name = tw.Name;
				if (name.Length > MaxLength)
				{
					name = name.Substring(0, MaxLength) + "/truncated";
				}
				mangledTypeName = TypeNameUtil.ReplaceIllegalCharacters(name);
				// FXBUG the CLR (both 1.1 and 2.0) doesn't like type names that end with a single period,
				// it loses the trailing period in the name that gets passed in the TypeResolve event.
				if(dynamicTypes.ContainsKey(mangledTypeName) || mangledTypeName.EndsWith("."))
				{
d176 8
a183 10
					// Java class names cannot contain slashes (since they are converted into periods),
					// so we take advantage of that fact to create a unique name.
					string baseName = mangledTypeName;
					int instanceId = 0;
					do
					{
						mangledTypeName = baseName + "/" + (++instanceId);
					} while(dynamicTypes.ContainsKey(mangledTypeName));
				}
				dynamicTypes.Add(mangledTypeName, tw);
d185 1
@


1.64
log
@Introduced an intermediate compilation pass for CreateStep2 to enable a class to extend a class nested inside itself.
@
text
@d155 10
a164 1
				mangledTypeName = TypeNameUtil.EscapeName(tw.Name);
@


1.63
log
@Renamed CreateStep2NoFail to CreateStep2, because while it shouldn't fail, CreateStep1 also shouldn't fail. Removed unused return value from CreateStep2().
@
text
@a178 1
			DynamicTypeWrapper type;
d180 4
a183 1
			type = new AotTypeWrapper(f, (CompilerClassLoader)classLoader);
d186 1
a186 2
			type = new DynamicTypeWrapper(f, classLoader);
#endif
d203 1
a203 1
#if !STATIC_COMPILER && !FIRST_PASS
d220 1
@


1.62
log
@Make AllocMangledName register the wrapper directly, because there is no reason to do that later.
@
text
@d190 1
a190 1
			type.CreateStep2NoFail();
@


1.61
log
@Removed parameters from CreateStep1 and CreateStep2NoFail.
@
text
@d150 1
a150 1
		internal override string AllocMangledName(string mangledTypeName)
d152 1
d155 1
a155 1
				mangledTypeName = TypeNameUtil.EscapeName(mangledTypeName);
d172 1
a172 1
				dynamicTypes.Add(mangledTypeName, null);
d183 1
a185 2
			// this step can throw a retargettable exception, if the class is incorrect
			type.CreateStep1();
d189 2
a190 1
			string mangledTypeName = type.CreateStep2NoFail();
a200 5
					lock(dynamicTypes)
					{
						Debug.Assert(dynamicTypes.ContainsKey(mangledTypeName) && dynamicTypes[mangledTypeName] == null);
						dynamicTypes[mangledTypeName] = type;
					}
@


1.60
log
@Instead of mangling field names and using NameSigAttribute, we now use modopt to modify the signature and record the real type.
@
text
@d150 1
a150 1
		private string AllocMangledName(string mangledTypeName)
d185 1
a185 4
			bool hasclinit;
			type.CreateStep1(out hasclinit);
			// now we can allocate the mangledTypeName, because the next step cannot fail
			string mangledTypeName = AllocMangledName(f.Name);
d189 1
a189 1
			type.CreateStep2NoFail(hasclinit, mangledTypeName);
@


1.59
log
@Removed the need for access stubs in dynamic mode with CLASSGC enabled by dynamically adding InternalsVisibleToAttribute to the dynamic assemblies.
@
text
@a39 3
		// note that MangleNestedTypeName() assumes that there are less than 16 special characters
		private static readonly char[] specialCharacters = { '\\', '+', ',', '[', ']', '*', '&', '\u0000' };
		private static readonly string specialCharactersString = new String(specialCharacters);
a136 30
		internal static string EscapeName(string name)
		{
			// TODO the escaping of special characters is not required on .NET 2.0
			// (but it doesn't really hurt that much either, the only overhead is the
			// extra InnerClassAttribute to record the real name of the class)
			// Note that even though .NET 2.0 automatically escapes the special characters,
			// the name that gets passed in ResolveEventArgs.Name of the TypeResolve event
			// contains the unescaped type name.
			if(name.IndexOfAny(specialCharacters) >= 0)
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder();
				foreach(char c in name)
				{
					if(specialCharactersString.IndexOf(c) >= 0)
					{
						if(c == 0)
						{
							// we can't escape the NUL character, so we replace it with a space.
							sb.Append(' ');
							continue;
						}
						sb.Append('\\');
					}
					sb.Append(c);
				}
				name = sb.ToString();
			}
			return name;
		}

d154 1
a154 1
				mangledTypeName = EscapeName(mangledTypeName);
d238 1
a238 1
			proxyHelpers.Add(proxyHelperContainer.DefineNestedType(MangleNestedTypeName(type.FullName), TypeAttributes.NestedPublic | TypeAttributes.Interface | TypeAttributes.Abstract, null, new Type[] { type }));
d268 1
a268 1
			return MangleNestedTypeName(sb.ToString());
d278 1
a278 31
			return "__<Proxy>+" + MangleNestedTypeName(type.FullName);
		}

		private static string MangleNestedTypeName(string name)
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			foreach (char c in name)
			{
				int index = specialCharactersString.IndexOf(c);
				if(c == '.')
				{
					sb.Append("_");
				}
				else if(c == '_')
				{
					sb.Append("^-");
				}
				else if(index == -1)
				{
					sb.Append(c);
					if(c == '^')
					{
						sb.Append(c);
					}
				}
				else
				{
					sb.Append('^').AppendFormat("{0:X1}", index);
				}
			}
			return sb.ToString();
d299 1
a299 1
				type = unloadableContainer.DefineNestedType(MangleNestedTypeName(name), TypeAttributes.NestedPrivate | TypeAttributes.Interface | TypeAttributes.Abstract);
@


1.58
log
@Added experimental (and for the time being undocumented) support for having ikvmc pre-generate proxy classes.
@
text
@d60 3
d89 15
@


1.57
log
@Changed workaround for gmcs inability to properly deal with two-pass compilation of mutually dependant assemblies to use reflection, because the previous workaround now also fails on Mono 2.8.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2010 Jeroen Frijters
d52 2
d255 19
d276 15
d386 8
@


1.56
log
@More .NET 4.0 security model attributes.
@
text
@d225 1
a225 1
					TypeWrapper.SetTypeWrapperHack(ref clazz.typeWrapper, type);
@


1.56.2.1
log
@Backported Mono 2.8 mcs build workarounds.
@
text
@d225 1
a225 1
					TypeWrapper.SetTypeWrapperHack(clazz, type);
@


1.55
log
@When running on .NET 4.0, make the emitted assembly security transparent when running in partial trust.
@
text
@d59 1
d393 1
@


1.54
log
@Disable RunAndCollect when running in partial trust.
@
text
@d444 6
@


1.53
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2006, 2008, 2009 Jeroen Frijters
d433 3
a435 1
			else if(JVM.classUnloading)
@


1.52
log
@Moved CodeGenOptions from DynamicClassLoader.cs to ClassLoaderWrapper.cs, to avoid new stub generator (to be checked in later) to have to include DynamicClassLoader.cs
@
text
@d27 1
a27 1
#if IKVM_REF_EMIT
@


1.51
log
@Integrated new IKVM.Reflection implementation.
@
text
@a37 11
	[Flags]
	enum CodeGenOptions
	{
		None = 0,
		Debug = 1,
		NoStackTraceInfo = 2,
		StrictFinalFieldSemantics = 4,
		NoJNI = 8,
		RemoveAsserts = 16,
	}

@


1.50
log
@Removed .NET 4.0 beta 1 workarounds and did some minor updates for .NET 4.0 beta 2.
@
text
@a26 1
using System.Reflection;
d28 1
d30 1
d32 1
@


1.49
log
@Removed vestigial compact framework support.
@
text
@a435 8
			if(Environment.Version.Major == 4 && Environment.Version.Minor == 0 && Environment.Version.Build == 20506)
			{
				// FXBUG workaround for MethodImpl bug in .NET 4.0 beta 1
				attribs.Add(
					new CustomAttributeBuilder(
						Type.GetType("System.Security.SecurityRulesAttribute").GetConstructor(new Type[] { Type.GetType("System.Security.SecurityRuleSet") }),
						new object[] { Type.GetType("System.Security.SecurityRuleSet").GetField("Level1").GetValue(null) }));
			}
@


1.48
log
@Added App.config setting (ikvm-emit-symbols) to force emitting debug symbols on or off.
@
text
@a23 1
#if !COMPACT_FRAMEWORK
a475 1
#endif //COMPACT_FRAMEWORK
@


1.47
log
@Moved responsibility for creating java.lang.Class instances for "fast literal" enable types into ClassLiteral<T>, this allows class literals to be really cheap, because non of the underlying reflection is needed, the class will cache the Type and lazily resolve it to its TypeWrapper.
@
text
@d467 1
a467 1
			bool debug = System.Diagnostics.Debugger.IsAttached;
@


1.46
log
@Fixed dynamic assembly saving (debug option).
@
text
@d232 1
a232 1
					java.lang.Class clazz = java.lang.Class.newClass();
@


1.45
log
@Added "RuntimeCompatibilityAttribute(WrapNonExceptionThrows = true)" to generated assemblies.
@
text
@d74 3
a76 1
				saveClassLoaders = new List<DynamicClassLoader>();
d420 1
a420 1
			if(saveClassLoaders != null)
d422 4
@


1.44
log
@Fixed jsr/ret handling bug.
@
text
@a28 1
using System.Runtime.CompilerServices;
d460 1
a460 4
			assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(
				typeof(RuntimeCompatibilityAttribute).GetConstructor(Type.EmptyTypes), new object[0],
				new PropertyInfo[] { typeof(RuntimeCompatibilityAttribute).GetProperty("WrapNonExceptionThrows") }, new object[] { true },
				new FieldInfo[0], new object[0]));
@


1.43
log
@Implemented class gc (available only when compiling on .NET 4.0).
@
text
@d29 1
d461 4
@


1.42
log
@Added JavaModuleAttribute to dynamic module to make detection of Java types more straightforward.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2008 Jeroen Frijters
d55 1
d65 3
d72 4
a91 2
		private static DynamicClassLoader Instance = new DynamicClassLoader(CreateModuleBuilder());

d95 4
a98 1
			lock(Instance.dynamicTypes)
d100 1
a100 1
				Instance.dynamicTypes.TryGetValue(args.Name, out type);
d102 3
a362 5
			Instance.SaveDebugImage();
		}

		private void SaveDebugImage()
		{
d364 10
a373 4
			FinishAll();
			AssemblyBuilder asm = ((AssemblyBuilder)moduleBuilder.Assembly);
			asm.Save("ikvmdump.dll");
			if(saveDebugAssemblies != null)
d375 1
a375 1
				foreach(AssemblyBuilder ab in saveDebugAssemblies)
d403 7
a409 3
			return new DynamicClassLoader(((CompilerClassLoader)loader).CreateModuleBuilder());
#else
			return Instance;
d411 1
d418 1
a418 1
			if(JVM.IsSaveDebugImage)
d420 3
a422 1
				name.Name = "ikvmdump";
d439 15
d456 1
a456 1
				AppDomain.CurrentDomain.DefineDynamicAssembly(name, JVM.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run, null, true, attribs);
d458 1
a458 1
				AppDomain.CurrentDomain.DefineDynamicAssembly(name, JVM.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run, null, null, null, null, null, true, attribs);
@


1.41
log
@Made dynamic assembly detection more reliable and moved the utility method to ReflectUtil.
@
text
@d428 3
a430 1
			return JVM.IsSaveDebugImage ? assemblyBuilder.DefineDynamicModule("ikvmdump.dll", "ikvmdump.dll", debug) : assemblyBuilder.DefineDynamicModule(name.Name, debug);
@


1.40
log
@Changed DynamicClassLoader API to make it easier to move from global AssemblyBuilder to per ClassLoader.
@
text
@a429 18

		internal static bool IsDynamicAssembly(Assembly asm)
		{
#if NET_4_0
			return asm.IsDynamic();
#else
			if (asm is System.Reflection.Emit.AssemblyBuilder)
			{
				return true;
			}
			if (asm.Equals(Instance.ModuleBuilder.Assembly))
			{
				// this can happen on Orcas, where an AssemblyBuilder has a corresponding Assembly
				return true;
			}
			return false;
#endif
		}
@


1.39
log
@- When building for .NET 4.0, don't use DefineDynamicAssembly() overload that takes assembly permission sets, because .NET 4.0 ignores them anyway.
- Fixed BakedTypeCleanupHack to work for .NET 2.0 SP2.
- Changes to remove warnings when building on .NET 4.0
@
text
@d84 1
a84 1
		internal static DynamicClassLoader Instance = new DynamicClassLoader(CreateModuleBuilder());
d349 6
a354 1
		internal void SaveDebugImage()
d387 9
d430 18
@


1.38
log
@Preparing for .NET 4.0:
- Added SecurityRules(Level1) attribute to IKVM.Runtime.dll to (temporarily) opt out of new .NET 4.0 security model.
- Changed compiler/runtime to automatically add SecurityRules(Level1) attribute when running on .NET 4.0 beta 1 to work around bug in the handling of MethodImpls in beta 1.
@
text
@d405 6
a410 1
			AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, JVM.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run, null, null, null, null, null, true, attribs);
@


1.37
log
@Made Mono compilation workarounds conditional on __MonoCS__.
@
text
@d396 10
a405 1
			AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, JVM.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run, null, null, null, null, null, true);
@


1.36
log
@Changed proxy stub name mangling to work around ildasm bug.
@
text
@d219 1
d221 3
@


1.35
log
@Integrated IKVM.Reflection.Emit in ikvmc.
@
text
@d50 1
d259 5
a263 1
					sb.Append("%-");
d268 1
a268 1
					if(c == '%')
d275 1
a275 1
					sb.Append('%').AppendFormat("{0:X2}", index);
@


1.34
log
@Generified all collections.
@
text
@d29 3
d33 1
@


1.33
log
@Removed support for building with GNU Classpath class library.
@
text
@a25 1
using System.Collections;
d49 1
a49 1
		private static ArrayList saveDebugAssemblies;
d51 1
a51 1
		private readonly Hashtable dynamicTypes = Hashtable.Synchronized(new Hashtable());
d55 1
a55 1
		private ArrayList proxyHelpers;
d83 5
a87 1
			TypeWrapper type = (TypeWrapper)Instance.dynamicTypes[args.Name];
d142 1
a142 1
			lock(dynamicTypes.SyncRoot)
d155 1
a155 1
			lock(dynamicTypes.SyncRoot)
d179 1
a179 1
		internal sealed override TypeWrapper DefineClassImpl(Hashtable types, ClassFile f, ClassLoaderWrapper classLoader, object protectionDomain)
d196 1
a196 1
			lock(types.SyncRoot)
d202 2
a203 1
				TypeWrapper race = (TypeWrapper)types[f.Name];
d206 5
a210 2
					Debug.Assert(dynamicTypes.ContainsKey(mangledTypeName) && dynamicTypes[mangledTypeName] == null);
					dynamicTypes[mangledTypeName] = type;
d235 1
a235 1
				proxyHelpers = new ArrayList();
d298 1
a298 1
			Hashtable done = new Hashtable();
d303 1
a303 1
				ArrayList l = new ArrayList(dynamicTypes.Values);
d355 1
a355 1
				saveDebugAssemblies = new ArrayList();
@


1.32
log
@Added workarounds for mcs compiler bug (related to the mutual dependency of the runtime and class library assemblies).
@
text
@d205 1
a205 2
#if STATIC_COMPILER || FIRST_PASS
#elif OPENJDK
a209 2
#else
					type.SetClassObject(JVM.Library.newClass(type, protectionDomain, null));
@


1.31
log
@Added support for defining unloadable (i.e. missing) types to use as custom modifiers in signatures.
@
text
@d208 1
a208 1
					clazz.typeWrapper = type;
@


1.30
log
@- Added -removeassertions optimization option to ikvmc.
- Added -removeassertions to IKVM.OpenJDK.ClassLibrary.dll build.
- Don't look at unreachable instructions when determining if a method needs a line number table.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d27 1
d58 2
d233 1
a233 1
			proxyHelpers.Add(proxyHelperContainer.DefineNestedType(GetProxyHelperName(type).Substring(10), TypeAttributes.NestedPublic | TypeAttributes.Interface | TypeAttributes.Abstract, null, new Type[] { type }));
d239 7
a245 2
			System.Text.StringBuilder sb = new System.Text.StringBuilder("__<Proxy>+");
			foreach (char c in type.FullName)
d268 24
d311 8
@


1.29
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@d41 1
@


1.28
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d201 7
a207 1
#if !STATIC_COMPILER
@


1.27
log
@Don't include unused code in runtime build, to avoid warnings.
@
text
@a44 4
#if !WHIDBEY
		internal static bool arrayConstructionHack;
		internal static readonly object arrayConstructionLock = new object();
#endif // !WHIDBEY
a79 10
#if !WHIDBEY
			lock(arrayConstructionLock)
			{
				Tracer.Info(Tracer.ClassLoading, "OnTypeResolve: {0} (arrayConstructionHack = {1})", args.Name, arrayConstructionHack);
				if(arrayConstructionHack)
				{
					return null;
				}
			}
#endif // !WHIDBEY
@


1.26
log
@Implemented support for creating proxies for non-public interfaces from ikvmc compiled assemblies.
@
text
@d56 1
d59 1
d286 1
d295 1
@


1.25
log
@Added ReserveName() method to try to claim a type name in the module. For use by other runtime code that needs to create a type with a particular name.
@
text
@d56 2
d225 40
d284 8
@


1.25.2.1
log
@Ported fixes from trunk. Changed version to 0.36.0.1.
@
text
@a55 4
#if STATIC_COMPILER
		private TypeBuilder proxyHelperContainer;
		private ArrayList proxyHelpers;
#endif // STATIC_COMPILER
a222 40
#if STATIC_COMPILER
		internal void DefineProxyHelper(Type type)
		{
			if(proxyHelperContainer == null)
			{
				proxyHelperContainer = moduleBuilder.DefineType("__<Proxy>", TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract);
				AttributeHelper.HideFromJava(proxyHelperContainer);
				AttributeHelper.SetEditorBrowsableNever(proxyHelperContainer);
				proxyHelpers = new ArrayList();
			}
			proxyHelpers.Add(proxyHelperContainer.DefineNestedType(GetProxyHelperName(type).Substring(10), TypeAttributes.NestedPublic | TypeAttributes.Interface | TypeAttributes.Abstract, null, new Type[] { type }));
		}
#endif

		internal static string GetProxyHelperName(Type type)
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder("__<Proxy>+");
			foreach (char c in type.FullName)
			{
				int index = specialCharactersString.IndexOf(c);
				if(c == '.')
				{
					sb.Append("%-");
				}
				else if(index == -1)
				{
					sb.Append(c);
					if(c == '%')
					{
						sb.Append(c);
					}
				}
				else
				{
					sb.Append('%').AppendFormat("{0:X2}", index);
				}
			}
			return sb.ToString();
		}

a241 10
#if STATIC_COMPILER
			if(proxyHelperContainer != null)
			{
				proxyHelperContainer.CreateType();
				foreach(TypeBuilder tb in proxyHelpers)
				{
					tb.CreateType();
				}
			}
#endif // STATIC_COMPILER
@


1.25.2.2
log
@- Added -removeassertions optimization option to ikvmc.
- Removed hack from map.xml to remove assertions from java.util.BitSet.checkInvariants().
- Added -removeassertions to IKVM.OpenJDK.ClassLibrary.dll build.
@
text
@a40 1
		RemoveAsserts = 16,
@


1.24
log
@*** empty log message ***
@
text
@d143 13
@


1.23
log
@*** empty log message ***
@
text
@d232 1
a232 1
		internal void SaveDebugImage(object mainClass)
a235 4
			TypeWrapper mainTypeWrapper = TypeWrapper.FromClass(mainClass);
			mainTypeWrapper.Finish();
			Type mainType = mainTypeWrapper.TypeAsTBD;
			MethodInfo main = mainType.GetMethod("main", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { typeof(string[]) }, null);
d237 1
a237 2
			asm.SetEntryPoint(main, PEFileKinds.ConsoleApplication);
			asm.Save("ikvmdump.exe");
d283 1
a283 1
			return JVM.IsSaveDebugImage ? assemblyBuilder.DefineDynamicModule("ikvmdump.exe", "ikvmdump.exe", debug) : assemblyBuilder.DefineDynamicModule(name.Name, debug);
@


1.22
log
@*** empty log message ***
@
text
@d43 1
a43 1
	class DynamicClassLoader : TypeWrapperFactory
d66 1
a66 1
		protected DynamicClassLoader(ModuleBuilder moduleBuilder)
d171 6
a176 1
			DynamicTypeWrapper type = CreateDynamicTypeWrapper(f, classLoader);
a209 5
		protected virtual DynamicTypeWrapper CreateDynamicTypeWrapper(ClassFile f, ClassLoaderWrapper classLoader)
		{
			return new DynamicTypeWrapper(f, classLoader);
		}

@


1.21
log
@*** empty log message ***
@
text
@a48 1
		private static readonly Hashtable dynamicTypes = Hashtable.Synchronized(new Hashtable());
d51 1
a51 4
		// FXBUG moduleBuilder is static, because multiple dynamic assemblies is broken (TypeResolve doesn't fire)
		// so for the time being, we share one dynamic assembly among all classloaders
		private static ModuleBuilder moduleBuilder;
		private static bool saveDebugImage;
d53 3
a55 4
		private static int instanceCounter = 0;
		private int instanceId = System.Threading.Interlocked.Increment(ref instanceCounter);
		private ClassLoaderWrapper classLoader;
		private CodeGenOptions codegenoptions;
d59 1
d63 6
d75 2
a76 5
		internal DynamicClassLoader(ClassLoaderWrapper classLoader, CodeGenOptions codegenoptions)
		{
			this.classLoader = classLoader;
			this.codegenoptions = codegenoptions;
		}
d90 1
a90 1
			TypeWrapper type = (TypeWrapper)dynamicTypes[args.Name];
a94 4
			// During static compilation, a TypeResolve event should never trigger a finish.
#if STATIC_COMPILER
			JVM.CriticalFailure("Finish triggered during static compilation. Type = " + args.Name, null);
#else // STATIC_COMPILER
a102 1
#endif // STATIC_COMPILER
d111 1
d143 1
a143 1
		internal override string AllocMangledName(string mangledTypeName)
d157 6
a162 1
					mangledTypeName += "/" + instanceId;
d169 1
a169 1
		internal override TypeWrapper DefineClassImpl(Hashtable types, ClassFile f, object protectionDomain)
d171 1
a171 1
			DynamicTypeWrapper type = CreateDynamicTypeWrapper(f);
d205 1
a205 1
		protected virtual DynamicTypeWrapper CreateDynamicTypeWrapper(ClassFile f)
d210 1
a210 1
		internal static void PrepareForSaveDebugImage()
a211 50
			Debug.Assert(moduleBuilder == null);
			saveDebugImage = true;
		}

		internal static bool IsSaveDebugImage
		{
			get
			{
				return saveDebugImage;
			}
		}

		internal override bool EmitDebugInfo
		{
			get
			{
				return (codegenoptions & CodeGenOptions.Debug) != 0;
			}
		}

		internal override bool EmitStackTraceInfo
		{
			get
			{
				// NOTE we're negating the flag here!
				return (codegenoptions & CodeGenOptions.NoStackTraceInfo) == 0;
			}
		}

		internal override bool StrictFinalFieldSemantics
		{
			get
			{
				return (codegenoptions & CodeGenOptions.StrictFinalFieldSemantics) != 0;
			}
		}

		internal override bool NoJNI
		{
			get
			{
				return (codegenoptions & CodeGenOptions.NoJNI) != 0;
			}
		}

		internal static void FinishAll(bool forDebug)
		{
#if !STATIC_COMPILER
			JVM.FinishingForDebugSave = forDebug;
#endif // !STATIC_COMPILER
d232 1
a232 1
		internal static void SaveDebugImage(object mainClass)
d234 2
a235 1
			FinishAll(true);
a250 1
#endif
d260 1
d262 1
a262 1
		internal override ModuleBuilder ModuleBuilder
d266 1
a266 8
				lock(typeof(DynamicClassLoader))
				{
					if(moduleBuilder == null)
					{
						moduleBuilder = CreateModuleBuilder();
					}
					return moduleBuilder;
				}
d270 2
a271 1
		protected virtual ModuleBuilder CreateModuleBuilder()
a272 3
#if STATIC_COMPILER
			throw new InvalidOperationException();
#else // STATIC_COMPILER
d274 1
a274 1
			if(saveDebugImage)
d280 1
a280 1
				name.Name = "ikvm_dynamic_assembly__" + instanceId + "__" + (uint)Environment.TickCount;
d284 3
a286 2
			AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, saveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run, null, null, null, null, null, true);
			CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, this.EmitDebugInfo });
d288 1
a288 2
			return saveDebugImage ? assemblyBuilder.DefineDynamicModule("ikvmdump.exe", "ikvmdump.exe", this.EmitDebugInfo) : assemblyBuilder.DefineDynamicModule(name.Name, this.EmitDebugInfo);
#endif // STATIC_COMPILER
d290 1
@


1.20
log
@*** empty log message ***
@
text
@a325 8
		internal override AssemblyBuilder AssemblyBuilder
		{
			get
			{
				return (AssemblyBuilder)this.ModuleBuilder.Assembly;
			}
		}

d329 1
a329 4
			// HACK this is required because DelegateInnerClassTypeWrapper currently uses the ModuleBuilder
			// property to get a ModuleBuilder on the class loader that defined the delegate,
			// instead of the class loader that is using the delegate (as it probably should)
			return ClassLoaderWrapper.GetBootstrapClassLoader().GetTypeWrapperFactory().ModuleBuilder;
@


1.19
log
@*** empty log message ***
@
text
@d33 10
d60 1
d73 1
a73 1
		internal DynamicClassLoader(ClassLoaderWrapper classLoader)
d76 1
d224 33
d259 1
d261 1
d354 1
a354 1
			CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, JVM.Debug });
d356 1
a356 1
			return saveDebugImage ? assemblyBuilder.DefineDynamicModule("ikvmdump.exe", "ikvmdump.exe", JVM.Debug) : assemblyBuilder.DefineDynamicModule(name.Name, JVM.Debug);
@


1.18
log
@*** empty log message ***
@
text
@d85 3
a87 5
			if(JVM.IsStaticCompilerPhase1)
			{
				JVM.CriticalFailure("Finish triggered during phase 1 of compilation.", null);
				return null;
			}
a91 1
#if !STATIC_COMPILER
d96 1
a96 4
#endif // !STATIC_COMPILER
			finally
			{
			}
@


1.17
log
@*** empty log message ***
@
text
@d188 1
a188 1
					type.SetClassObject(JVM.Library.newClass(type, protectionDomain));
@


1.16
log
@*** empty log message ***
@
text
@d112 1
a112 1
		internal override string AllocMangledName(string mangledTypeName)
d114 7
a120 1
			lock(dynamicTypes.SyncRoot)
d122 2
a123 7
				// TODO the escaping of special characters is not required on .NET 2.0
				// (but it doesn't really hurt that much either, the only overhead is the
				// extra InnerClassAttribute to record the real name of the class)
				// Note that even though .NET 2.0 automatically escapes the special characters,
				// the name that gets passed in ResolveEventArgs.Name of the TypeResolve event
				// contains the unescaped type name.
				if(mangledTypeName.IndexOfAny(specialCharacters) >= 0)
d125 1
a125 2
					System.Text.StringBuilder sb = new System.Text.StringBuilder();
					foreach(char c in mangledTypeName)
d127 1
a127 1
						if(specialCharactersString.IndexOf(c) >= 0)
d129 3
a131 7
							if(c == 0)
							{
								// we can't escape the NUL character, so we replace it with a space.
								sb.Append(' ');
								continue;
							}
							sb.Append('\\');
d133 1
a133 1
						sb.Append(c);
d135 1
a135 1
					mangledTypeName = sb.ToString();
d137 10
@


1.15
log
@*** empty log message ***
@
text
@d40 1
a40 1
		private static readonly char[] specialCharacters = { '\\', '+', ',', '[', ']' };
d56 4
a115 6
				// Ref.Emit doesn't like the "<Module>" name for types
				// (since it already defines a pseudo-type named <Module> for global methods and fields)
				if(mangledTypeName == "<Module>")
				{
					mangledTypeName = "_Module_";
				}
d129 6
@


1.14
log
@*** empty log message ***
@
text
@d108 1
a108 1
		internal override TypeWrapper DefineClassImpl(Hashtable types, ClassFile f, object protectionDomain)
a109 6
			DynamicTypeWrapper type = CreateDynamicTypeWrapper(f);
			// this step can throw a retargettable exception, if the class is incorrect
			bool hasclinit;
			type.CreateStep1(out hasclinit);
			// now we can allocate the mangledTypeName, because the next step cannot fail
			string mangledTypeName = f.Name;
d150 11
d219 1
a219 1
					if(!done.ContainsKey(tw))
d275 8
d289 1
a289 1
			return ClassLoaderWrapper.GetBootstrapClassLoader().ModuleBuilder;
@


1.13
log
@*** empty log message ***
@
text
@d124 6
d143 2
a144 1
				// FXBUG the 1.1 CLR doesn't like type names that end with a period.
d150 2
@


1.12
log
@*** empty log message ***
@
text
@d40 2
d118 19
@


1.11
log
@*** empty log message ***
@
text
@d33 1
a33 1
	class DynamicClassLoader : ClassLoaderWrapper
d47 1
d56 1
a56 2
		internal DynamicClassLoader(object javaClassLoader)
			: base(javaClassLoader)
d58 1
d106 1
a106 1
		internal override TypeWrapper DefineClass(ClassFile f, object protectionDomain)
d108 7
a114 2
			string dotnetAssembly = f.IKVMAssemblyAttribute;
			if(dotnetAssembly != null)
d116 2
a117 4
				// The sole purpose of the stub class is to let us load the assembly that the class lives in,
				// once we've done that, all types in it become visible.
				Assembly asm;
				try
d119 2
a120 4
#if WHIDBEY && STATIC_COMPILER
					asm = Assembly.ReflectionOnlyLoad(dotnetAssembly);
#else
					asm = Assembly.Load(dotnetAssembly);
d122 1
d124 1
a124 14
				catch(Exception x)
				{
					throw new NoClassDefFoundError(f.Name + " (" + x.Message + ")");
				}
				TypeWrapper tw = ClassLoaderWrapper.GetAssemblyClassLoader(asm).LoadClassByDottedNameFast(f.Name);
				if(tw == null)
				{
					throw new NoClassDefFoundError(f.Name + " (type not found in " + asm.FullName + ")");
				}
				if(tw.Assembly != asm)
				{
					throw new NoClassDefFoundError(f.Name + " (assembly mismatch)");
				}
				return RegisterInitiatingLoader(tw);
d126 4
d132 10
a141 43
				if(types.ContainsKey(f.Name))
				{
					throw new LinkageError("duplicate class definition: " + f.Name);
				}
				// mark the type as "loading in progress", so that we can detect circular dependencies.
				types.Add(f.Name, null);
			}
			try
			{
				DynamicTypeWrapper type = CreateDynamicTypeWrapper(f);
				// this step can throw a retargettable exception, if the class is incorrect
				bool hasclinit;
				type.CreateStep1(out hasclinit);
				// now we can allocate the mangledTypeName, because the next step cannot fail
				string mangledTypeName = f.Name;
				lock(dynamicTypes.SyncRoot)
				{
					// FXBUG the 1.1 CLR doesn't like type names that end with a period.
					if(dynamicTypes.ContainsKey(mangledTypeName) || mangledTypeName.EndsWith("."))
					{
#if STATIC_COMPILER
						Tracer.Warning(Tracer.Compiler, "Class name clash: {0}", mangledTypeName);
#endif
						mangledTypeName += "/" + instanceId;
					}
					dynamicTypes.Add(mangledTypeName, null);
				}
				// This step actually creates the TypeBuilder. It is not allowed to throw any exceptions,
				// if an exception does occur, it is due to a programming error in the IKVM or CLR runtime
				// and will cause a CriticalFailure and exit the process.
				type.CreateStep2NoFail(hasclinit, mangledTypeName);
				lock(types.SyncRoot)
				{
					// in very extreme conditions another thread may have beaten us to it
					// and loaded (not defined) a class with the same name, in that case
					// we'll leak the the Reflection.Emit defined type. Also see the comment
					// in ClassLoaderWrapper.RegisterInitiatingLoader().
					TypeWrapper race = (TypeWrapper)types[f.Name];
					if(race == null)
					{
						Debug.Assert(dynamicTypes.ContainsKey(mangledTypeName) && dynamicTypes[mangledTypeName] == null);
						dynamicTypes[mangledTypeName] = type;
						types[f.Name] = type;
d143 1
a143 1
						type.SetClassObject(JVM.Library.newClass(type, protectionDomain));
a144 5
					}
					else
					{
						throw new LinkageError("duplicate class definition: " + f.Name);
					}
d146 1
a146 5
				return type;
			}
			catch
			{
				lock(types.SyncRoot)
d148 1
a148 6
					if(types[f.Name] == null)
					{
						// if loading the class fails, we remove the indicator that we're busy loading the class,
						// because otherwise we get a ClassCircularityError if we try to load the class again.
						types.Remove(f.Name);
					}
a149 1
				throw;
d151 1
d156 1
a156 1
			return new DynamicTypeWrapper(f, this);
d225 1
a225 1
		internal ModuleBuilder ModuleBuilder
d229 1
a229 1
				lock(this)
d246 1
a246 1
			return ((DynamicClassLoader)GetBootstrapClassLoader()).ModuleBuilder;
@


1.10
log
@*** empty log message ***
@
text
@d125 5
a129 1
				TypeWrapper tw = ClassLoaderWrapper.GetAssemblyClassLoader(asm).LoadClassByDottedName(f.Name);
@


1.9
log
@*** empty log message ***
@
text
@d35 4
d62 1
d71 1
@


1.8
log
@*** empty log message ***
@
text
@d104 21
a124 4
				// HACK only the bootstrap classloader can define .NET types (but for convenience, we do
				// allow other class loaders to call DefineClass for them)
				// TODO reconsider this, it might be a better idea to only allow netexp generated jars on the bootclasspath
				return GetBootstrapClassLoader().DefineNetExpType(f.Name, dotnetAssembly);
d285 6
d305 1
a305 6
			ModuleBuilder moduleBuilder = saveDebugImage ? assemblyBuilder.DefineDynamicModule("ikvmdump.exe", "ikvmdump.exe", JVM.Debug) : assemblyBuilder.DefineDynamicModule(name.Name, JVM.Debug);
#if STATIC_COMPILER
			if(!JVM.NoStackTraceInfo)
			{
				AttributeHelper.SetSourceFile(moduleBuilder, null);
			}
a306 1
			return moduleBuilder;
@


1.7
log
@*** empty log message ***
@
text
@d279 1
a279 9
			AssemblyBuilder assemblyBuilder;
#if WHIDBEY
			if(JVM.IsIkvmStub)
			{
				assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.ReflectionOnly, null, null, null, null, null, true);
			}
			else
#endif
			assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, saveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run, null, null, null, null, null, true);
@


1.6
log
@*** empty log message ***
@
text
@a39 1
		private static Hashtable nameClashHash = new Hashtable();
d94 2
a95 1
			//dynamicTypes.Remove(args.Name);
d120 22
a141 1
				TypeWrapper type = CreateDynamicTypeWrapper(f);
d145 3
a147 3
					// and loaded a class with the same name, in that case we'll leak
					// the defined DynamicTypeWrapper (or rather the Reflection.Emit
					// defined type).
d151 2
a152 2
						Debug.Assert(!dynamicTypes.ContainsKey(type.TypeAsTBD.FullName));
						dynamicTypes.Add(type.TypeAsTBD.FullName, type);
d180 1
a180 1
		protected virtual TypeWrapper CreateDynamicTypeWrapper(ClassFile f)
d202 3
a204 1
			while(dynamicTypes.Count > 0)
d206 1
d210 7
a216 4
					string name = tw.TypeAsTBD.FullName;
					Tracer.Info(Tracer.Runtime, "Finishing {0}", name);
					tw.Finish();
					dynamicTypes.Remove(name);
a298 23

		// FXBUG This mangles type names, to enable different class loaders loading classes with the same names.
		// We used to support this by using an assembly per class loader instance, but because
		// of the CLR TypeResolve bug, we put all types in a single assembly for now.
		internal string MangleTypeName(string name)
		{
			lock(nameClashHash.SyncRoot)
			{
				// FXBUG the 1.1 CLR doesn't like type names that end with a period.
				if(nameClashHash.ContainsKey(name) || name.EndsWith("."))
				{
#if STATIC_COMPILER
					Tracer.Warning(Tracer.Compiler, "Class name clash: {0}", name);
#endif
					return name + "/" + instanceId;
				}
				else
				{
					nameClashHash.Add(name, name);
					return name;
				}
			}
		}
@


1.5
log
@*** empty log message ***
@
text
@d264 1
d269 1
@


1.4
log
@*** empty log message ***
@
text
@d82 1
d87 4
d133 3
a135 4
						if (!JVM.IsStaticCompiler)
						{
							type.SetClassObject(JVM.Library.newClass(type, protectionDomain));
						}
d178 1
a178 1
		internal static void FinishAll()
d180 1
a180 1
			JVM.FinishingForDebugSave = true;
d194 1
d197 1
a197 1
			FinishAll();
d213 1
d281 3
a283 4
					if(JVM.IsStaticCompiler)
					{
						Tracer.Warning(Tracer.Compiler, "Class name clash: {0}", name);
					}
@


1.3
log
@*** empty log message ***
@
text
@d193 1
a193 1
			TypeWrapper mainTypeWrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(mainClass);
@


1.2
log
@*** empty log message ***
@
text
@d128 4
a131 1
						type.SetClassObject(JVM.Library.newClass(type, protectionDomain));
@


1.1
log
@*** empty log message ***
@
text
@d115 1
a115 1
				TypeWrapper type = CreateDynamicTypeWrapper(f, this, protectionDomain);
d128 1
d152 1
a152 1
		protected virtual TypeWrapper CreateDynamicTypeWrapper(ClassFile f, ClassLoaderWrapper loader, object protectionDomain)
d154 1
a154 1
			return new DynamicTypeWrapper(f, loader, protectionDomain);
@

