head	1.264;
access;
symbols
	v8_1_5717_0:1.264
	v8_1:1.264.0.2
	v8_0_5449_1:1.252
	v8_0_5449_0:1.252
	v8_0:1.252.0.2
	v7_4_5196_0:1.233
	v7_4:1.233.0.2
	v7_3:1.222.0.2
	v7_2_4630_6:1.194
	v7_2_4630_5:1.194
	v7_2_4630_4:1.194
	v7_2_4630_3:1.194
	v7_2_4630_2:1.194
	v0_46_0_4:1.170.2.2
	v7_2_4630_1:1.194
	v7_2:1.194.0.2
	v7_1_4532_2:1.188
	v7_1_4532_1:1.188
	v7_1_4532_0:1.188
	v7_1:1.188.0.2
	v7_0_4335_3:1.180
	v7_0_4335_2:1.180
	v7_0_4335_1:1.180
	v0_46_0_2:1.170.2.1
	v7_0_4335_0:1.180
	v7_0:1.180.0.2
	v0_40_0_6:1.113
	v0_40_0_5:1.113
	v0_46_0_1:1.170
	v0_46_0_0:1.170
	v0_46:1.170.0.2
	v0_36_0_14:1.80.2.6
	v0_44_0_6:1.153.2.1
	v0_44_0_5:1.153
	v0_44_0_4:1.153
	v0_44_0_3:1.153
	v0_44_0_2:1.153
	v0_42_0_7:1.132.2.2
	v0_44_0_1:1.153
	v0_44_0_0:1.153
	v0_44:1.153.0.2
	v0_42_0_6:1.132.2.2
	v0_42_0_5:1.132.2.2
	v0_42_0_4:1.132.2.2
	v0_42_0_3:1.132.2.1
	v0_42_0_2:1.132.2.1
	v0_42_0_1:1.132
	v0_42_0_0:1.132
	v0_42:1.132.0.2
	v0_40_0_3:1.113
	v0_40_0_2:1.113
	v0_40_0_1:1.113
	v0_40_0_0:1.113
	v0_40:1.113.0.2
	v0_36_0_13:1.80.2.6
	v0_38_0_1:1.101
	v0_38_0_0:1.101
	v0_38:1.101.0.2
	v0_36_0_9:1.80.2.4
	v0_36_0_7:1.80.2.2
	v0_36_0_5:1.80.2.2
	v0_36_0_4:1.80.2.1
	v0_36_0_3:1.80.2.1
	v0_36_0_2:1.80
	v0_36_0_1:1.80
	v0_36_0_0:1.80
	v0_36:1.80.0.2
	v0_34_0_3:1.70.2.1
	v0_34_0_2:1.70
	v0_34_0_1:1.70
	v0_34_0_0:1.70
	v0_34:1.70.0.2
	v0_32:1.69.0.2
	v0_32_0_0:1.69
	v0_30:1.61.0.2
	v0_28_0_0:1.57
	v0_26_0_1:1.49
	v0_26_0_0:1.49
	v0_24_0_1:1.47
	v0_24_0_0:1.47
	v0_22_0_0:1.41
	v0_20_0_0:1.41
	v0_18_0_0:1.32
	v0_16_0_0:1.31
	v0_14_0_1:1.25
	v0_14_0_0:1.25
	v0_12_0_0:1.23
	v0_10_0_1:1.18
	v0_10_0_0:1.18
	v0_8_0_0:1.4;
locks; strict;
comment	@ * @;


1.264
date	2015.06.24.14.10.40;	author jfrijters;	state Exp;
branches;
next	1.263;

1.263
date	2015.05.31.12.10.51;	author jfrijters;	state Exp;
branches;
next	1.262;

1.262
date	2015.03.21.06.40.47;	author jfrijters;	state Exp;
branches;
next	1.261;

1.261
date	2015.03.20.14.44.55;	author jfrijters;	state Exp;
branches;
next	1.260;

1.260
date	2015.03.19.09.20.39;	author jfrijters;	state Exp;
branches;
next	1.259;

1.259
date	2015.03.12.14.46.14;	author jfrijters;	state Exp;
branches;
next	1.258;

1.258
date	2015.03.11.13.18.58;	author jfrijters;	state Exp;
branches;
next	1.257;

1.257
date	2015.03.11.12.57.37;	author jfrijters;	state Exp;
branches;
next	1.256;

1.256
date	2015.03.06.09.27.22;	author jfrijters;	state Exp;
branches;
next	1.255;

1.255
date	2015.03.06.09.21.33;	author jfrijters;	state Exp;
branches;
next	1.254;

1.254
date	2015.03.06.07.52.18;	author jfrijters;	state Exp;
branches;
next	1.253;

1.253
date	2015.02.16.11.29.26;	author jfrijters;	state Exp;
branches;
next	1.252;

1.252
date	2014.07.08.08.44.08;	author jfrijters;	state Exp;
branches;
next	1.251;

1.251
date	2014.07.01.15.12.34;	author jfrijters;	state Exp;
branches;
next	1.250;

1.250
date	2014.07.01.15.04.06;	author jfrijters;	state Exp;
branches;
next	1.249;

1.249
date	2014.07.01.15.00.54;	author jfrijters;	state Exp;
branches;
next	1.248;

1.248
date	2014.06.24.12.06.44;	author jfrijters;	state Exp;
branches;
next	1.247;

1.247
date	2014.06.16.13.07.11;	author jfrijters;	state Exp;
branches;
next	1.246;

1.246
date	2014.06.16.11.36.14;	author jfrijters;	state Exp;
branches;
next	1.245;

1.245
date	2014.05.22.12.11.23;	author jfrijters;	state Exp;
branches;
next	1.244;

1.244
date	2014.05.14.10.09.43;	author jfrijters;	state Exp;
branches;
next	1.243;

1.243
date	2014.05.14.07.39.32;	author jfrijters;	state Exp;
branches;
next	1.242;

1.242
date	2014.05.14.07.08.03;	author jfrijters;	state Exp;
branches;
next	1.241;

1.241
date	2014.05.14.06.51.01;	author jfrijters;	state Exp;
branches;
next	1.240;

1.240
date	2014.04.30.08.07.29;	author jfrijters;	state Exp;
branches;
next	1.239;

1.239
date	2014.04.30.08.06.01;	author jfrijters;	state Exp;
branches;
next	1.238;

1.238
date	2014.04.30.06.23.43;	author jfrijters;	state Exp;
branches;
next	1.237;

1.237
date	2014.04.30.06.18.08;	author jfrijters;	state Exp;
branches;
next	1.236;

1.236
date	2014.04.29.13.41.10;	author jfrijters;	state Exp;
branches;
next	1.235;

1.235
date	2014.04.28.14.26.38;	author jfrijters;	state Exp;
branches;
next	1.234;

1.234
date	2014.04.11.13.03.37;	author jfrijters;	state Exp;
branches;
next	1.233;

1.233
date	2014.02.27.06.57.36;	author jfrijters;	state Exp;
branches;
next	1.232;

1.232
date	2014.02.25.07.37.52;	author jfrijters;	state Exp;
branches;
next	1.231;

1.231
date	2014.02.21.10.44.35;	author jfrijters;	state Exp;
branches;
next	1.230;

1.230
date	2014.02.20.16.51.25;	author jfrijters;	state Exp;
branches;
next	1.229;

1.229
date	2014.02.20.15.41.22;	author jfrijters;	state Exp;
branches;
next	1.228;

1.228
date	2014.02.10.07.59.31;	author jfrijters;	state Exp;
branches;
next	1.227;

1.227
date	2014.02.06.08.46.11;	author jfrijters;	state Exp;
branches;
next	1.226;

1.226
date	2013.03.29.12.49.29;	author jfrijters;	state Exp;
branches;
next	1.225;

1.225
date	2013.03.29.12.28.34;	author jfrijters;	state Exp;
branches;
next	1.224;

1.224
date	2013.03.29.11.28.24;	author jfrijters;	state Exp;
branches;
next	1.223;

1.223
date	2013.03.24.12.40.33;	author jfrijters;	state Exp;
branches;
next	1.222;

1.222
date	2013.03.05.12.32.51;	author jfrijters;	state Exp;
branches;
next	1.221;

1.221
date	2013.03.05.10.34.49;	author jfrijters;	state Exp;
branches;
next	1.220;

1.220
date	2013.03.05.10.33.25;	author jfrijters;	state Exp;
branches;
next	1.219;

1.219
date	2013.03.05.10.29.27;	author jfrijters;	state Exp;
branches;
next	1.218;

1.218
date	2013.03.05.10.24.51;	author jfrijters;	state Exp;
branches;
next	1.217;

1.217
date	2013.03.04.13.52.49;	author jfrijters;	state Exp;
branches;
next	1.216;

1.216
date	2013.03.04.13.30.25;	author jfrijters;	state Exp;
branches;
next	1.215;

1.215
date	2013.03.04.12.47.40;	author jfrijters;	state Exp;
branches;
next	1.214;

1.214
date	2013.02.24.15.29.06;	author jfrijters;	state Exp;
branches;
next	1.213;

1.213
date	2013.02.24.07.56.51;	author jfrijters;	state Exp;
branches;
next	1.212;

1.212
date	2013.02.24.07.48.15;	author jfrijters;	state Exp;
branches;
next	1.211;

1.211
date	2013.02.24.07.01.21;	author jfrijters;	state Exp;
branches;
next	1.210;

1.210
date	2013.02.24.06.38.46;	author jfrijters;	state Exp;
branches;
next	1.209;

1.209
date	2013.02.14.12.11.43;	author jfrijters;	state Exp;
branches;
next	1.208;

1.208
date	2013.02.14.11.12.41;	author jfrijters;	state Exp;
branches;
next	1.207;

1.207
date	2013.02.11.08.50.08;	author jfrijters;	state Exp;
branches;
next	1.206;

1.206
date	2013.02.11.06.59.46;	author jfrijters;	state Exp;
branches;
next	1.205;

1.205
date	2013.02.09.10.12.11;	author jfrijters;	state Exp;
branches;
next	1.204;

1.204
date	2013.02.09.10.04.13;	author jfrijters;	state Exp;
branches;
next	1.203;

1.203
date	2013.02.06.19.54.34;	author jfrijters;	state Exp;
branches;
next	1.202;

1.202
date	2013.01.31.20.38.52;	author jfrijters;	state Exp;
branches;
next	1.201;

1.201
date	2013.01.31.09.20.30;	author jfrijters;	state Exp;
branches;
next	1.200;

1.200
date	2013.01.31.09.14.28;	author jfrijters;	state Exp;
branches;
next	1.199;

1.199
date	2013.01.31.09.12.20;	author jfrijters;	state Exp;
branches;
next	1.198;

1.198
date	2013.01.30.12.20.07;	author jfrijters;	state Exp;
branches;
next	1.197;

1.197
date	2013.01.30.12.08.01;	author jfrijters;	state Exp;
branches;
next	1.196;

1.196
date	2013.01.29.16.43.52;	author jfrijters;	state Exp;
branches;
next	1.195;

1.195
date	2012.09.13.13.21.35;	author jfrijters;	state Exp;
branches;
next	1.194;

1.194
date	2012.08.06.12.12.03;	author jfrijters;	state Exp;
branches;
next	1.193;

1.193
date	2012.07.23.07.50.00;	author jfrijters;	state Exp;
branches;
next	1.192;

1.192
date	2012.07.08.07.53.27;	author jfrijters;	state Exp;
branches;
next	1.191;

1.191
date	2012.07.04.09.36.06;	author jfrijters;	state Exp;
branches;
next	1.190;

1.190
date	2012.07.03.14.45.51;	author jfrijters;	state Exp;
branches;
next	1.189;

1.189
date	2012.06.29.13.54.48;	author jfrijters;	state Exp;
branches;
next	1.188;

1.188
date	2012.03.24.08.54.13;	author jfrijters;	state Exp;
branches;
next	1.187;

1.187
date	2012.01.20.14.02.23;	author jfrijters;	state Exp;
branches;
next	1.186;

1.186
date	2011.12.12.12.43.23;	author jfrijters;	state Exp;
branches;
next	1.185;

1.185
date	2011.12.12.11.21.29;	author jfrijters;	state Exp;
branches;
next	1.184;

1.184
date	2011.12.12.09.57.23;	author jfrijters;	state Exp;
branches;
next	1.183;

1.183
date	2011.12.08.14.59.16;	author jfrijters;	state Exp;
branches;
next	1.182;

1.182
date	2011.12.07.11.28.17;	author jfrijters;	state Exp;
branches;
next	1.181;

1.181
date	2011.11.24.08.35.47;	author jfrijters;	state Exp;
branches;
next	1.180;

1.180
date	2011.10.24.14.14.16;	author jfrijters;	state Exp;
branches;
next	1.179;

1.179
date	2011.08.15.16.11.00;	author jfrijters;	state Exp;
branches;
next	1.178;

1.178
date	2011.08.12.13.06.46;	author jfrijters;	state Exp;
branches;
next	1.177;

1.177
date	2011.08.10.10.12.10;	author jfrijters;	state Exp;
branches;
next	1.176;

1.176
date	2011.08.10.09.06.27;	author jfrijters;	state Exp;
branches;
next	1.175;

1.175
date	2011.08.08.05.50.27;	author jfrijters;	state Exp;
branches;
next	1.174;

1.174
date	2011.08.08.04.56.16;	author jfrijters;	state Exp;
branches;
next	1.173;

1.173
date	2011.08.06.19.51.17;	author jfrijters;	state Exp;
branches;
next	1.172;

1.172
date	2011.08.06.11.00.10;	author jfrijters;	state Exp;
branches;
next	1.171;

1.171
date	2011.07.25.23.11.10;	author jfrijters;	state Exp;
branches;
next	1.170;

1.170
date	2010.10.13.05.24.33;	author jfrijters;	state Exp;
branches
	1.170.2.1;
next	1.169;

1.169
date	2010.10.11.05.46.28;	author jfrijters;	state Exp;
branches;
next	1.168;

1.168
date	2010.10.05.04.54.09;	author jfrijters;	state Exp;
branches;
next	1.167;

1.167
date	2010.10.01.08.11.50;	author jfrijters;	state Exp;
branches;
next	1.166;

1.166
date	2010.09.30.04.03.33;	author jfrijters;	state Exp;
branches;
next	1.165;

1.165
date	2010.09.29.07.21.51;	author jfrijters;	state Exp;
branches;
next	1.164;

1.164
date	2010.09.28.08.02.07;	author jfrijters;	state Exp;
branches;
next	1.163;

1.163
date	2010.09.27.04.42.56;	author jfrijters;	state Exp;
branches;
next	1.162;

1.162
date	2010.09.22.04.01.36;	author jfrijters;	state Exp;
branches;
next	1.161;

1.161
date	2010.09.14.14.15.07;	author jfrijters;	state Exp;
branches;
next	1.160;

1.160
date	2010.09.14.13.19.11;	author jfrijters;	state Exp;
branches;
next	1.159;

1.159
date	2010.09.14.12.29.22;	author jfrijters;	state Exp;
branches;
next	1.158;

1.158
date	2010.09.14.07.38.42;	author jfrijters;	state Exp;
branches;
next	1.157;

1.157
date	2010.09.13.06.53.16;	author jfrijters;	state Exp;
branches;
next	1.156;

1.156
date	2010.09.13.06.16.23;	author jfrijters;	state Exp;
branches;
next	1.155;

1.155
date	2010.08.26.06.40.32;	author jfrijters;	state Exp;
branches;
next	1.154;

1.154
date	2010.07.16.08.50.40;	author jfrijters;	state Exp;
branches;
next	1.153;

1.153
date	2010.06.08.12.08.30;	author jfrijters;	state Exp;
branches
	1.153.2.1;
next	1.152;

1.152
date	2010.06.08.05.25.14;	author jfrijters;	state Exp;
branches;
next	1.151;

1.151
date	2010.06.08.04.15.39;	author jfrijters;	state Exp;
branches;
next	1.150;

1.150
date	2010.06.07.06.13.05;	author jfrijters;	state Exp;
branches;
next	1.149;

1.149
date	2010.06.07.04.30.20;	author jfrijters;	state Exp;
branches;
next	1.148;

1.148
date	2010.06.02.06.37.35;	author jfrijters;	state Exp;
branches;
next	1.147;

1.147
date	2010.05.31.05.08.57;	author jfrijters;	state Exp;
branches;
next	1.146;

1.146
date	2010.05.30.06.53.49;	author jfrijters;	state Exp;
branches;
next	1.145;

1.145
date	2010.05.29.13.53.32;	author jfrijters;	state Exp;
branches;
next	1.144;

1.144
date	2010.05.28.11.05.18;	author jfrijters;	state Exp;
branches;
next	1.143;

1.143
date	2010.02.03.15.28.06;	author jfrijters;	state Exp;
branches;
next	1.142;

1.142
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches;
next	1.141;

1.141
date	2010.01.25.07.53.28;	author jfrijters;	state Exp;
branches;
next	1.140;

1.140
date	2010.01.11.14.32.13;	author jfrijters;	state Exp;
branches;
next	1.139;

1.139
date	2009.12.09.05.49.30;	author jfrijters;	state Exp;
branches;
next	1.138;

1.138
date	2009.11.13.15.08.24;	author jfrijters;	state Exp;
branches;
next	1.137;

1.137
date	2009.11.06.07.48.06;	author jfrijters;	state Exp;
branches;
next	1.136;

1.136
date	2009.10.23.05.58.41;	author jfrijters;	state Exp;
branches;
next	1.135;

1.135
date	2009.10.23.05.48.19;	author jfrijters;	state Exp;
branches;
next	1.134;

1.134
date	2009.10.21.04.47.26;	author jfrijters;	state Exp;
branches;
next	1.133;

1.133
date	2009.10.14.14.58.41;	author jfrijters;	state Exp;
branches;
next	1.132;

1.132
date	2009.08.31.05.02.36;	author jfrijters;	state Exp;
branches
	1.132.2.1;
next	1.131;

1.131
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.130;

1.130
date	2009.08.24.16.06.58;	author jfrijters;	state Exp;
branches;
next	1.129;

1.129
date	2009.08.14.13.36.53;	author jfrijters;	state Exp;
branches;
next	1.128;

1.128
date	2009.07.14.08.25.04;	author jfrijters;	state Exp;
branches;
next	1.127;

1.127
date	2009.07.14.07.25.46;	author jfrijters;	state Exp;
branches;
next	1.126;

1.126
date	2009.07.14.06.20.23;	author jfrijters;	state Exp;
branches;
next	1.125;

1.125
date	2009.07.13.08.34.37;	author jfrijters;	state Exp;
branches;
next	1.124;

1.124
date	2009.07.07.07.44.31;	author jfrijters;	state Exp;
branches;
next	1.123;

1.123
date	2009.06.18.06.13.21;	author jfrijters;	state Exp;
branches;
next	1.122;

1.122
date	2009.05.24.05.05.34;	author jfrijters;	state Exp;
branches;
next	1.121;

1.121
date	2009.05.12.04.00.01;	author jfrijters;	state Exp;
branches;
next	1.120;

1.120
date	2009.04.16.05.44.48;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2009.04.16.05.37.53;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2009.04.16.05.34.21;	author jfrijters;	state Exp;
branches;
next	1.117;

1.117
date	2009.04.07.04.53.56;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2009.04.06.10.26.37;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2009.04.06.10.19.51;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2009.04.06.10.10.18;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2009.03.16.05.50.59;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2009.03.04.05.47.19;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2009.03.02.06.31.55;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2009.02.27.06.17.06;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2009.02.23.05.18.44;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2009.02.22.08.19.30;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2009.02.16.06.02.02;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2009.02.16.05.59.48;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2009.02.12.07.59.17;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2008.12.01.05.18.30;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2008.12.01.05.16.30;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2008.11.14.08.42.07;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2008.08.21.06.09.33;	author jfrijters;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2008.08.21.06.06.17;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2008.08.15.12.01.22;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2008.08.14.05.42.43;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2008.08.06.05.25.20;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2008.06.24.14.47.45;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2008.06.03.12.10.34;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2008.06.03.09.17.33;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2008.06.03.07.13.50;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2008.06.03.06.52.33;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2008.06.02.06.28.29;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2008.05.31.15.20.42;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2008.05.31.10.22.37;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.09.05.58.03;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2008.03.03.07.05.20;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2008.02.27.09.04.21;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2008.02.15.15.32.51;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2007.12.28.10.23.46;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.06.08.51.08;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.24.11.57.01;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2007.08.29.06.23.47;	author jfrijters;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2007.08.22.11.48.20;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2007.08.08.13.51.55;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.21.12.04.27;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.12.11.45.23;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.12.09.48.36;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.25.05.56.24;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.11.13.42.47;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.04.12.41.45;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.04.06.41.46;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.04.12.54.10;	author jfrijters;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2006.11.27.07.39.32;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.20.09.33.16;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2006.08.26.13.00.50;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2006.08.21.06.21.27;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2006.08.21.05.15.53;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2006.08.12.07.57.04;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2006.08.06.09.27.20;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.28.11.04.22;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2006.07.26.14.16.53;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2006.07.18.07.38.25;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2006.07.06.13.53.52;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.04.08.09.56;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.03.08.52.53;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2006.04.20.13.20.58;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2006.04.17.08.33.49;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.11.14.59.44;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2006.04.11.12.05.25;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.05.08.19.00;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.27.07.59.35;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.22.14.44.07;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.31.10.13.32;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.16.08.22.11;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.29.15.48.33;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.29.09.57.41;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.20.12.44.29;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.19.15.12.50;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.24.08.14.23;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2005.08.22.12.50.42;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2005.08.05.12.18.36;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.05.08.40.55;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.02.07.24.54;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.27.15.57.59;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.22.12.26.15;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.20.10.48.04;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.20.07.26.10;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.07.13.10.12;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.29.19.21.56;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.19.10.44.53;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.01.09.49.31;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.31.15.30.39;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.31.05.44.31;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.23.08.24.09;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.07.09.37.02;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.03.08.20.13;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.01.08.24.54;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.23.13.20.07;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.16.11.20.47;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.11.14.47.05;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.02.15.12.20;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.21.10.26.55;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.13.15.30.03;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.12.14.36.26;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.23.17.46.43;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.04.12.50.34;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.19.13.43.57;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.04.19.30.55;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.27.10.17.35;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.17.09.32.08;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.30.15.56.25;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.10.07.19.57;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.28.08.24.07;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.25.09.38.07;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.07.08.28.57;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;

1.70.2.1
date	2007.05.30.10.30.37;	author jfrijters;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2007.08.06.08.09.38;	author jfrijters;	state Exp;
branches;
next	;

1.80.2.1
date	2007.10.01.13.02.44;	author jfrijters;	state Exp;
branches;
next	1.80.2.2;

1.80.2.2
date	2007.12.04.06.04.33;	author jfrijters;	state Exp;
branches;
next	1.80.2.3;

1.80.2.3
date	2008.02.20.14.24.40;	author jfrijters;	state Exp;
branches;
next	1.80.2.4;

1.80.2.4
date	2008.02.27.07.05.12;	author jfrijters;	state Exp;
branches;
next	1.80.2.5;

1.80.2.5
date	2008.11.05.07.52.02;	author jfrijters;	state Exp;
branches;
next	1.80.2.6;

1.80.2.6
date	2008.11.05.09.07.05;	author jfrijters;	state Exp;
branches;
next	;

1.101.2.1
date	2009.02.02.05.58.20;	author jfrijters;	state Exp;
branches;
next	;

1.132.2.1
date	2009.10.26.04.50.15;	author jfrijters;	state Exp;
branches;
next	1.132.2.2;

1.132.2.2
date	2010.01.12.16.57.38;	author jfrijters;	state Exp;
branches;
next	;

1.153.2.1
date	2010.10.22.07.20.33;	author jfrijters;	state Exp;
branches;
next	;

1.170.2.1
date	2011.12.20.08.58.16;	author jfrijters;	state Exp;
branches;
next	1.170.2.2;

1.170.2.2
date	2012.10.03.06.18.57;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.264
log
@Optimized LambdaForm compiler.
@
text
@/*
  Copyright (C) 2002-2015 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
#if STATIC_COMPILER
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
#else
using System.Reflection;
using System.Reflection.Emit;
#endif
using System.Diagnostics;
using System.Diagnostics.SymbolStore;
using IKVM.Attributes;
using IKVM.Internal;

using ExceptionTableEntry = IKVM.Internal.ClassFile.Method.ExceptionTableEntry;
using LocalVariableTableEntry = IKVM.Internal.ClassFile.Method.LocalVariableTableEntry;
using Instruction = IKVM.Internal.ClassFile.Method.Instruction;
using InstructionFlags = IKVM.Internal.ClassFile.Method.InstructionFlags;

static class ByteCodeHelperMethods
{
	internal static readonly MethodInfo multianewarray;
	internal static readonly MethodInfo multianewarray_ghost;
	internal static readonly MethodInfo anewarray_ghost;
	internal static readonly MethodInfo f2i;
	internal static readonly MethodInfo d2i;
	internal static readonly MethodInfo f2l;
	internal static readonly MethodInfo d2l;
	internal static readonly MethodInfo arraycopy_fast;
	internal static readonly MethodInfo arraycopy_primitive_8;
	internal static readonly MethodInfo arraycopy_primitive_4;
	internal static readonly MethodInfo arraycopy_primitive_2;
	internal static readonly MethodInfo arraycopy_primitive_1;
	internal static readonly MethodInfo arraycopy;
	internal static readonly MethodInfo DynamicCast;
	internal static readonly MethodInfo DynamicAaload;
	internal static readonly MethodInfo DynamicAastore;
	internal static readonly MethodInfo DynamicClassLiteral;
	internal static readonly MethodInfo DynamicMultianewarray;
	internal static readonly MethodInfo DynamicNewarray;
	internal static readonly MethodInfo DynamicNewCheckOnly;
	internal static readonly MethodInfo DynamicCreateDelegate;
	internal static readonly MethodInfo DynamicLoadMethodType;
	internal static readonly MethodInfo DynamicLoadMethodHandle;
	internal static readonly MethodInfo DynamicBinderMemberLookup;
	internal static readonly MethodInfo DynamicMapException;
	internal static readonly MethodInfo DynamicCallerID;
	internal static readonly MethodInfo DynamicLinkIndyCallSite;
	internal static readonly MethodInfo DynamicEraseInvokeExact;
	internal static readonly MethodInfo VerboseCastFailure;
	internal static readonly MethodInfo SkipFinalizer;
	internal static readonly MethodInfo DynamicInstanceOf;
	internal static readonly MethodInfo volatileReadDouble;
	internal static readonly MethodInfo volatileReadLong;
	internal static readonly MethodInfo volatileWriteDouble;
	internal static readonly MethodInfo volatileWriteLong;
	internal static readonly MethodInfo mapException;
	internal static readonly MethodInfo GetDelegateForInvokeExact;
	internal static readonly MethodInfo GetDelegateForInvoke;
	internal static readonly MethodInfo GetDelegateForInvokeBasic;
	internal static readonly MethodInfo LoadMethodType;
	internal static readonly MethodInfo LinkIndyCallSite;

	static ByteCodeHelperMethods()
	{
#if STATIC_COMPILER
		Type typeofByteCodeHelper = StaticCompiler.GetRuntimeType("IKVM.Runtime.ByteCodeHelper");
#else
		Type typeofByteCodeHelper = typeof(IKVM.Runtime.ByteCodeHelper);
#endif
		multianewarray = GetHelper(typeofByteCodeHelper, "multianewarray");
		multianewarray_ghost = GetHelper(typeofByteCodeHelper, "multianewarray_ghost");
		anewarray_ghost = GetHelper(typeofByteCodeHelper, "anewarray_ghost");
		f2i = GetHelper(typeofByteCodeHelper, "f2i");
		d2i = GetHelper(typeofByteCodeHelper, "d2i");
		f2l = GetHelper(typeofByteCodeHelper, "f2l");
		d2l = GetHelper(typeofByteCodeHelper, "d2l");
		arraycopy_fast = GetHelper(typeofByteCodeHelper, "arraycopy_fast");
		arraycopy_primitive_8 = GetHelper(typeofByteCodeHelper, "arraycopy_primitive_8");
		arraycopy_primitive_4 = GetHelper(typeofByteCodeHelper, "arraycopy_primitive_4");
		arraycopy_primitive_2 = GetHelper(typeofByteCodeHelper, "arraycopy_primitive_2");
		arraycopy_primitive_1 = GetHelper(typeofByteCodeHelper, "arraycopy_primitive_1");
		arraycopy = GetHelper(typeofByteCodeHelper, "arraycopy");
		DynamicCast = GetHelper(typeofByteCodeHelper, "DynamicCast");
		DynamicAaload = GetHelper(typeofByteCodeHelper, "DynamicAaload");
		DynamicAastore = GetHelper(typeofByteCodeHelper, "DynamicAastore");
		DynamicClassLiteral = GetHelper(typeofByteCodeHelper, "DynamicClassLiteral");
		DynamicMultianewarray = GetHelper(typeofByteCodeHelper, "DynamicMultianewarray");
		DynamicNewarray = GetHelper(typeofByteCodeHelper, "DynamicNewarray");
		DynamicNewCheckOnly = GetHelper(typeofByteCodeHelper, "DynamicNewCheckOnly");
		DynamicCreateDelegate = GetHelper(typeofByteCodeHelper, "DynamicCreateDelegate");
		DynamicLoadMethodType = GetHelper(typeofByteCodeHelper, "DynamicLoadMethodType");
		DynamicLoadMethodHandle = GetHelper(typeofByteCodeHelper, "DynamicLoadMethodHandle");
		DynamicBinderMemberLookup = GetHelper(typeofByteCodeHelper, "DynamicBinderMemberLookup");
		DynamicMapException = GetHelper(typeofByteCodeHelper, "DynamicMapException");
		DynamicCallerID = GetHelper(typeofByteCodeHelper, "DynamicCallerID");
		DynamicLinkIndyCallSite = GetHelper(typeofByteCodeHelper, "DynamicLinkIndyCallSite");
		DynamicEraseInvokeExact = GetHelper(typeofByteCodeHelper, "DynamicEraseInvokeExact");
		VerboseCastFailure = GetHelper(typeofByteCodeHelper, "VerboseCastFailure");
		SkipFinalizer = GetHelper(typeofByteCodeHelper, "SkipFinalizer");
		DynamicInstanceOf = GetHelper(typeofByteCodeHelper, "DynamicInstanceOf");
		volatileReadDouble = GetHelper(typeofByteCodeHelper, "VolatileRead", new Type[] { Types.Double.MakeByRefType() });
		volatileReadLong = GetHelper(typeofByteCodeHelper, "VolatileRead", new Type[] { Types.Int64.MakeByRefType() });
		volatileWriteDouble = GetHelper(typeofByteCodeHelper, "VolatileWrite", new Type[] { Types.Double.MakeByRefType(), Types.Double });
		volatileWriteLong = GetHelper(typeofByteCodeHelper, "VolatileWrite", new Type[] { Types.Int64.MakeByRefType(), Types.Int64 });
		mapException = GetHelper(typeofByteCodeHelper, "MapException");
		GetDelegateForInvokeExact = GetHelper(typeofByteCodeHelper, "GetDelegateForInvokeExact");
		GetDelegateForInvoke = GetHelper(typeofByteCodeHelper, "GetDelegateForInvoke");
		GetDelegateForInvokeBasic = GetHelper(typeofByteCodeHelper, "GetDelegateForInvokeBasic");
		LoadMethodType = GetHelper(typeofByteCodeHelper, "LoadMethodType");
		LinkIndyCallSite = GetHelper(typeofByteCodeHelper, "LinkIndyCallSite");
	}

	private static MethodInfo GetHelper(Type type, string method)
	{
		return GetHelper(type, method, null);
	}

	private static MethodInfo GetHelper(Type type, string method, Type[] parameters)
	{
		MethodInfo mi = parameters == null ? type.GetMethod(method) : type.GetMethod(method, parameters);
#if STATIC_COMPILER
		if (mi == null)
		{
			throw new FatalCompilerErrorException(Message.RuntimeMethodMissing, method);
		}
#endif
		return mi;
	}
}

struct MethodKey : IEquatable<MethodKey>
{
	private readonly string className;
	private readonly string methodName;
	private readonly string methodSig;

	internal MethodKey(string className, string methodName, string methodSig)
	{
		this.className = className;
		this.methodName = methodName;
		this.methodSig = methodSig;
	}

	public bool Equals(MethodKey other)
	{
		return className == other.className && methodName == other.methodName && methodSig == other.methodSig;
	}

	public override int GetHashCode()
	{
		return className.GetHashCode() ^ methodName.GetHashCode() ^ methodSig.GetHashCode();
	}
}

static partial class MethodHandleUtil
{
	internal static void EmitCallDelegateInvokeMethod(CodeEmitter ilgen, Type delegateType)
	{
		if (delegateType.IsGenericType)
		{
			// MONOBUG we don't look at the invoke method directly here, because Mono doesn't support GetParameters() on a builder instantiation
			Type[] typeArgs = delegateType.GetGenericArguments();
			if (IsPackedArgsContainer(typeArgs[typeArgs.Length - 1]))
			{
				WrapArgs(ilgen, typeArgs[typeArgs.Length - 1]);
			}
			else if (typeArgs.Length > 2 && IsPackedArgsContainer(typeArgs[typeArgs.Length - 2]))
			{
				WrapArgs(ilgen, typeArgs[typeArgs.Length - 2]);
			}
		}
		ilgen.Emit(OpCodes.Callvirt, GetDelegateInvokeMethod(delegateType));
	}

	private static void WrapArgs(CodeEmitter ilgen, Type type)
	{
		Type last = type.GetGenericArguments()[MaxArity - 1];
		if (IsPackedArgsContainer(last))
		{
			WrapArgs(ilgen, last);
		}
		ilgen.Emit(OpCodes.Newobj, GetDelegateOrPackedArgsConstructor(type));
	}

	internal static MethodInfo GetDelegateInvokeMethod(Type delegateType)
	{
		if (ReflectUtil.ContainsTypeBuilder(delegateType))
		{
			return TypeBuilder.GetMethod(delegateType, delegateType.GetGenericTypeDefinition().GetMethod("Invoke"));
		}
		else
		{
			return delegateType.GetMethod("Invoke");
		}
	}

	internal static ConstructorInfo GetDelegateConstructor(Type delegateType)
	{
		return GetDelegateOrPackedArgsConstructor(delegateType);
	}

	private static ConstructorInfo GetDelegateOrPackedArgsConstructor(Type type)
	{
		if (ReflectUtil.ContainsTypeBuilder(type))
		{
			return TypeBuilder.GetConstructor(type, type.GetGenericTypeDefinition().GetConstructors()[0]);
		}
		else
		{
			return type.GetConstructors()[0];
		}
	}

	// for delegate types used for "ldc <MethodType>" we don't want ghost arrays to be erased
	internal static Type CreateDelegateTypeForLoadConstant(TypeWrapper[] args, TypeWrapper ret)
	{
		Type[] typeArgs = new Type[args.Length];
		for (int i = 0; i < args.Length; i++)
		{
			typeArgs[i] = TypeWrapperToTypeForLoadConstant(args[i]);
		}
		return CreateDelegateType(typeArgs, TypeWrapperToTypeForLoadConstant(ret));
	}

	private static Type TypeWrapperToTypeForLoadConstant(TypeWrapper tw)
	{
		if (tw.IsGhostArray)
		{
			int dims = tw.ArrayRank;
			while (tw.IsArray)
			{
				tw = tw.ElementTypeWrapper;
			}
			return ArrayTypeWrapper.MakeArrayType(tw.TypeAsSignatureType, dims);
		}
		else
		{
			return tw.TypeAsSignatureType;
		}
	}
}

sealed class Compiler
{
	internal static readonly MethodInfo unmapExceptionMethod;
	private static readonly MethodInfo fixateExceptionMethod;
	private static readonly MethodInfo suppressFillInStackTraceMethod;
	internal static readonly MethodInfo getTypeFromHandleMethod;
	internal static readonly MethodInfo getTypeMethod;
	private static readonly MethodInfo keepAliveMethod;
	internal static readonly MethodWrapper getClassFromTypeHandle;
	internal static readonly MethodWrapper getClassFromTypeHandle2;
	private readonly DynamicTypeWrapper.FinishContext context;
	private readonly DynamicTypeWrapper clazz;
	private readonly MethodWrapper mw;
	private readonly ClassFile classFile;
	private readonly ClassFile.Method m;
	private readonly CodeEmitter ilGenerator;
	private readonly CodeInfo ma;
	private readonly UntangledExceptionTable exceptions;
	private readonly List<string> harderrors;
	private readonly LocalVarInfo localVars;
	private bool nonleaf;
	private readonly bool debug;
	private readonly bool keepAlive;
	private readonly bool strictfp;
	private readonly bool emitLineNumbers;
	private int[] scopeBegin;
	private int[] scopeClose;
#if STATIC_COMPILER
	private readonly MethodWrapper[] replacedMethodWrappers;
#endif

	static Compiler()
	{
		getTypeFromHandleMethod = Types.Type.GetMethod("GetTypeFromHandle", BindingFlags.Static | BindingFlags.Public, null, new Type[] { Types.RuntimeTypeHandle }, null);
		getTypeMethod = Types.Object.GetMethod("GetType", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
		keepAliveMethod = JVM.Import(typeof(System.GC)).GetMethod("KeepAlive", BindingFlags.Static | BindingFlags.Public, null, new Type[] { Types.Object }, null);
		// HACK we need to special case core compilation, because the __<map> methods are HideFromJava
		if(CoreClasses.java.lang.Throwable.Wrapper.TypeAsBaseType is TypeBuilder)
		{
			MethodWrapper mw;
			mw = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("__<suppressFillInStackTrace>", "()V", false);
			mw.Link();
			suppressFillInStackTraceMethod = (MethodInfo)mw.GetMethod();
			mw = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("__<unmap>", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false);
			mw.Link();
			unmapExceptionMethod = (MethodInfo)mw.GetMethod();
			mw = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("__<fixate>", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false);
			mw.Link();
			fixateExceptionMethod = (MethodInfo)mw.GetMethod();
		}
		else
		{
			suppressFillInStackTraceMethod = CoreClasses.java.lang.Throwable.Wrapper.TypeAsBaseType.GetMethod("__<suppressFillInStackTrace>", Type.EmptyTypes);
			unmapExceptionMethod = CoreClasses.java.lang.Throwable.Wrapper.TypeAsBaseType.GetMethod("__<unmap>", new Type[] { Types.Exception });
			fixateExceptionMethod = CoreClasses.java.lang.Throwable.Wrapper.TypeAsBaseType.GetMethod("__<fixate>", new Type[] { Types.Exception });
		}
		getClassFromTypeHandle = ClassLoaderWrapper.LoadClassCritical("ikvm.runtime.Util").GetMethodWrapper("getClassFromTypeHandle", "(Lcli.System.RuntimeTypeHandle;)Ljava.lang.Class;", false);
		getClassFromTypeHandle.Link();
		getClassFromTypeHandle2 = ClassLoaderWrapper.LoadClassCritical("ikvm.runtime.Util").GetMethodWrapper("getClassFromTypeHandle", "(Lcli.System.RuntimeTypeHandle;I)Ljava.lang.Class;", false);
		getClassFromTypeHandle2.Link();
	}

	private Compiler(DynamicTypeWrapper.FinishContext context, TypeWrapper host, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ClassLoaderWrapper classLoader)
	{
		this.context = context;
		this.clazz = clazz;
		this.mw = mw;
		this.classFile = classFile;
		this.m = m;
		this.ilGenerator = ilGenerator;
		this.debug = classLoader.EmitDebugInfo;
		this.strictfp = m.IsStrictfp;
		if(mw.IsConstructor)
		{
			MethodWrapper finalize = clazz.GetMethodWrapper(StringConstants.FINALIZE, StringConstants.SIG_VOID, true);
			keepAlive = finalize != null && finalize.DeclaringType != CoreClasses.java.lang.Object.Wrapper && finalize.DeclaringType != CoreClasses.cli.System.Object.Wrapper && finalize.DeclaringType != CoreClasses.java.lang.Throwable.Wrapper && finalize.DeclaringType != CoreClasses.cli.System.Exception.Wrapper;
		}
#if STATIC_COMPILER
		replacedMethodWrappers = clazz.GetReplacedMethodsFor(mw);
#endif

		TypeWrapper[] args = mw.GetParameters();
		for(int i = 0; i < args.Length; i++)
		{
			if(args[i].IsUnloadable)
			{
				ilGenerator.EmitLdarg(i + (m.IsStatic ? 0 : 1));
				EmitDynamicCast(args[i]);
				ilGenerator.Emit(OpCodes.Pop);
			}
		}

		Profiler.Enter("MethodAnalyzer");
		try
		{
			if(classFile.MajorVersion < 51 && m.HasJsr)
			{
				JsrInliner.InlineJsrs(classLoader, mw, classFile, m);
			}
			MethodAnalyzer verifier = new MethodAnalyzer(host, clazz, mw, classFile, m, classLoader);
			exceptions = MethodAnalyzer.UntangleExceptionBlocks(classFile, m);
			ma = verifier.GetCodeInfoAndErrors(exceptions, out harderrors);
			localVars = new LocalVarInfo(ma, classFile, m, exceptions, mw, classLoader);
		}
		finally
		{
			Profiler.Leave("MethodAnalyzer");
		}

		if (m.LineNumberTableAttribute != null)
		{
			if (classLoader.EmitDebugInfo)
			{
				emitLineNumbers = true;
			}
			else if (classLoader.EmitStackTraceInfo)
			{
				InstructionFlags[] flags = ComputePartialReachability(0, false);
				for (int i = 0; i < m.Instructions.Length; i++)
				{
					if ((flags[i] & InstructionFlags.Reachable) == 0)
					{
						// skip unreachable instructions
					}
					else if (m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__getfield
						&& VerifierTypeWrapper.IsThis(ma.GetRawStackTypeWrapper(i, 0)))
					{
						// loading a field from the current object cannot throw
					}
					else if (m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__putfield
						&& VerifierTypeWrapper.IsThis(ma.GetRawStackTypeWrapper(i, 1)))
					{
						// storing a field in the current object cannot throw
					}
					else if (m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__getstatic
						&& classFile.GetFieldref(m.Instructions[i].Arg1).GetClassType() == clazz)
					{
						// loading a field from the current class cannot throw
					}
					else if (m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__putstatic
						&& classFile.GetFieldref(m.Instructions[i].Arg1).GetClassType() == clazz)
					{
						// storing a field to the current class cannot throw
					}
					else if (ByteCodeMetaData.CanThrowException(m.Instructions[i].NormalizedOpCode))
					{
						emitLineNumbers = true;
						break;
					}
				}
			}
		}

		LocalVar[] locals = localVars.GetAllLocalVars();
		foreach(LocalVar v in locals)
		{
			if(v.isArg)
			{
				int arg = m.ArgMap[v.local];
				TypeWrapper tw;
				if(m.IsStatic)
				{
					tw = args[arg];
				}
				else if(arg == 0)
				{
					continue;
				}
				else
				{
					tw = args[arg - 1];
				}
				if(!tw.IsUnloadable &&
					(v.type != tw || tw.TypeAsLocalOrStackType != tw.TypeAsSignatureType))
				{
					v.builder = ilGenerator.DeclareLocal(GetLocalBuilderType(v.type));
					if(debug && v.name != null)
					{
						v.builder.SetLocalSymInfo(v.name);
					}
					v.isArg = false;
					ilGenerator.EmitLdarg(arg);
					tw.EmitConvSignatureTypeToStackType(ilGenerator);
					ilGenerator.Emit(OpCodes.Stloc, v.builder);
				}
			}
		}

		// if we're emitting debugging information, we need to use scopes for local variables
		if(debug)
		{
			SetupLocalVariableScopes();
		}

		Workaroundx64JitBug(args);
	}

	// workaround for x64 JIT bug
	// https://connect.microsoft.com/VisualStudio/feedback/details/636466/variable-is-not-incrementing-in-c-release-x64#details
	// (see also https://sourceforge.net/mailarchive/message.php?msg_id=28250469)
	private void Workaroundx64JitBug(TypeWrapper[] args)
	{
		if(args.Length > (m.IsStatic ? 4 : 3) && m.ExceptionTable.Length != 0)
		{
			bool[] workarounds = null;
			InstructionFlags[] flags = ComputePartialReachability(0, false);
			for(int i = 0; i < m.Instructions.Length; i++)
			{
				if((flags[i] & InstructionFlags.Reachable) == 0)
				{
					// skip unreachable instructions
				}
				else
				{
					switch(m.Instructions[i].NormalizedOpCode)
					{
						case NormalizedByteCode.__iinc:
						case NormalizedByteCode.__astore:
						case NormalizedByteCode.__istore:
						case NormalizedByteCode.__lstore:
						case NormalizedByteCode.__fstore:
						case NormalizedByteCode.__dstore:
							int arg = m.IsStatic ? m.Instructions[i].Arg1 : m.Instructions[i].Arg1 - 1;
							if(arg >= 3 && arg < args.Length)
							{
								if(workarounds == null)
								{
									workarounds = new bool[args.Length + 1];
								}
								workarounds[m.Instructions[i].Arg1] = true;
							}
							break;
					}
				}
			}
			if(workarounds != null)
			{
				for(int i = 0; i < workarounds.Length; i++)
				{
					if(workarounds[i])
					{
						// TODO prevent this from getting optimized away
						ilGenerator.EmitLdarga(i);
						ilGenerator.Emit(OpCodes.Pop);
					}
				}
			}
		}
	}

	private void SetupLocalVariableScopes()
	{
		LocalVariableTableEntry[] lvt = m.LocalVariableTableAttribute;
		if(lvt != null)
		{
			scopeBegin = new int[m.Instructions.Length];
			scopeClose = new int[m.Instructions.Length];

			// FXBUG make sure we always have an outer scope
			// (otherwise LocalBuilder.SetLocalSymInfo() might throw an IndexOutOfRangeException)
			// fix for bug 2881954.
			scopeBegin[0]++;
			scopeClose[m.Instructions.Length - 1]++;

			for (int i = 0; i < lvt.Length; i++)
			{
				int startIndex = SafeFindPcIndex(lvt[i].start_pc);
				int endIndex = SafeFindPcIndex(lvt[i].start_pc + lvt[i].length);
				if(startIndex != -1 && endIndex != -1 && startIndex < endIndex)
				{
					if(startIndex > 0)
					{
						// NOTE javac (correctly) sets start_pc of the LVT entry to the instruction
						// following the store that first initializes the local, so we have to
						// detect that case and adjust our local scope (because we'll be creating
						// the local when we encounter the first store).
						LocalVar v = localVars.GetLocalVar(startIndex - 1);
						if(v != null && v.local == lvt[i].index)
						{
							startIndex--;
						}
					}
					scopeBegin[startIndex]++;
					scopeClose[endIndex]++;
				}
			}
		}
	}

	private int SafeFindPcIndex(int pc)
	{
		for(int i = 0; i < m.Instructions.Length; i++)
		{
			if(m.Instructions[i].PC >= pc)
			{
				return i;
			}
		}
		return -1;
	}

	private sealed class ReturnCookie
	{
		private readonly CodeEmitterLabel stub;
		private readonly CodeEmitterLocal local;

		internal ReturnCookie(CodeEmitterLabel stub, CodeEmitterLocal local)
		{
			this.stub = stub;
			this.local = local;
		}

		internal void EmitRet(CodeEmitter ilgen)
		{
			ilgen.MarkLabel(stub);
			if(local != null)
			{
				ilgen.Emit(OpCodes.Ldloc, local);
			}
			ilgen.Emit(OpCodes.Ret);
		}
	}

	private sealed class BranchCookie
	{
		// NOTE Stub gets used for both the push stub (inside the exception block) as well as the pop stub (outside the block)
		internal CodeEmitterLabel Stub;
		internal CodeEmitterLabel TargetLabel;
		internal bool ContentOnStack;
		internal readonly int TargetIndex;
		internal DupHelper dh;

		internal BranchCookie(Compiler compiler, int stackHeight, int targetIndex)
		{
			this.Stub = compiler.ilGenerator.DefineLabel();
			this.TargetIndex = targetIndex;
			this.dh = new DupHelper(compiler, stackHeight);
		}

		internal BranchCookie(CodeEmitterLabel label, int targetIndex)
		{
			this.Stub = label;
			this.TargetIndex = targetIndex;
		}
	}

	private struct DupHelper
	{
		private enum StackType : byte
		{
			Null,
			New,
			This,
			UnitializedThis,
			FaultBlockException,
			Other
		}
		private readonly Compiler compiler;
		private readonly StackType[] types;
		private readonly CodeEmitterLocal[] locals;

		internal DupHelper(Compiler compiler, int count)
		{
			this.compiler = compiler;
			types = new StackType[count];
			locals = new CodeEmitterLocal[count];
		}

		internal void Release()
		{
			foreach (CodeEmitterLocal lb in locals)
			{
				if(lb != null)
				{
					compiler.ilGenerator.ReleaseTempLocal(lb);
				}
			}
		}

		internal int Count
		{
			get
			{
				return types.Length;
			}
		}

		internal void SetType(int i, TypeWrapper type)
		{
			if(type == VerifierTypeWrapper.Null)
			{
				types[i] = StackType.Null;
			}
			else if(VerifierTypeWrapper.IsNew(type))
			{
				// new objects aren't really there on the stack
				types[i] = StackType.New;
			}
			else if(VerifierTypeWrapper.IsThis(type))
			{
				types[i] = StackType.This;
			}
			else if(type == VerifierTypeWrapper.UninitializedThis)
			{
				// uninitialized references cannot be stored in a local, but we can reload them
				types[i] = StackType.UnitializedThis;
			}
			else if (VerifierTypeWrapper.IsFaultBlockException(type))
			{
				types[i] = StackType.FaultBlockException;
			}
			else
			{
				types[i] = StackType.Other;
				locals[i] = compiler.ilGenerator.AllocTempLocal(compiler.GetLocalBuilderType(type));
			}
		}

		internal void Load(int i)
		{
			switch(types[i])
			{
				case StackType.Null:
					compiler.ilGenerator.Emit(OpCodes.Ldnull);
					break;
				case StackType.New:
				case StackType.FaultBlockException:
					// objects aren't really there on the stack
					break;
				case StackType.This:
				case StackType.UnitializedThis:
					compiler.ilGenerator.Emit(OpCodes.Ldarg_0);
					break;
				case StackType.Other:
					compiler.ilGenerator.Emit(OpCodes.Ldloc, locals[i]);
					break;
				default:
					throw new InvalidOperationException();
			}
		}

		internal void Store(int i)
		{
			switch(types[i])
			{
				case StackType.Null:
				case StackType.This:
				case StackType.UnitializedThis:
					compiler.ilGenerator.Emit(OpCodes.Pop);
					break;
				case StackType.New:
				case StackType.FaultBlockException:
					// objects aren't really there on the stack
					break;
				case StackType.Other:
					compiler.ilGenerator.Emit(OpCodes.Stloc, locals[i]);
					break;
				default:
					throw new InvalidOperationException();
			}
		}
	}

	internal static void Compile(DynamicTypeWrapper.FinishContext context, TypeWrapper host, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ref bool nonleaf)
	{
		ClassLoaderWrapper classLoader = clazz.GetClassLoader();
		if(classLoader.EmitDebugInfo)
		{
			if(classFile.SourcePath != null)
			{
				ilGenerator.DefineSymbolDocument(classLoader.GetTypeWrapperFactory().ModuleBuilder, classFile.SourcePath, SymLanguageType.Java, Guid.Empty, SymDocumentType.Text);
				// the very first instruction in the method must have an associated line number, to be able
				// to step into the method in Visual Studio .NET
				ClassFile.Method.LineNumberTableEntry[] table = m.LineNumberTableAttribute;
				if(table != null)
				{
					int firstPC = int.MaxValue;
					int firstLine = -1;
					for(int i = 0; i < table.Length; i++)
					{
						if(table[i].start_pc < firstPC && table[i].line_number != 0)
						{
							firstLine = table[i].line_number;
							firstPC = table[i].start_pc;
						}
					}
					if(firstLine > 0)
					{
						ilGenerator.SetLineNumber((ushort)firstLine);
					}
				}
			}
		}
		Compiler c;
		try
		{
			Profiler.Enter("new Compiler");
			try
			{
				c = new Compiler(context, host, clazz, mw, classFile, m, ilGenerator, classLoader);
			}
			finally
			{
				Profiler.Leave("new Compiler");
			}
		}
		catch(VerifyError x)
		{
#if STATIC_COMPILER
			classLoader.IssueMessage(Message.EmittedVerificationError, classFile.Name + "." + m.Name + m.Signature, x.Message);
#endif
			Tracer.Error(Tracer.Verifier, x.ToString());
			clazz.SetHasVerifyError();
			// because in Java the method is only verified if it is actually called,
			// we generate code here to throw the VerificationError
			ilGenerator.EmitThrow("java.lang.VerifyError", x.Message);
			return;
		}
		catch(ClassFormatError x)
		{
#if STATIC_COMPILER
			classLoader.IssueMessage(Message.EmittedClassFormatError, classFile.Name + "." + m.Name + m.Signature, x.Message);
#endif
			Tracer.Error(Tracer.Verifier, x.ToString());
			clazz.SetHasClassFormatError();
			ilGenerator.EmitThrow("java.lang.ClassFormatError", x.Message);
			return;
		}
		Profiler.Enter("Compile");
		try
		{
			if(m.IsSynchronized && m.IsStatic)
			{
				clazz.EmitClassLiteral(ilGenerator);
				ilGenerator.Emit(OpCodes.Dup);
				CodeEmitterLocal monitor = ilGenerator.DeclareLocal(Types.Object);
				ilGenerator.Emit(OpCodes.Stloc, monitor);
				ilGenerator.EmitMonitorEnter();
				ilGenerator.BeginExceptionBlock();
				Block b = new Block(c, 0, int.MaxValue, -1, new List<object>(), true);
				c.Compile(b, 0);
				b.Leave();
				ilGenerator.BeginFinallyBlock();
				ilGenerator.Emit(OpCodes.Ldloc, monitor);
				ilGenerator.EmitMonitorExit();
				ilGenerator.Emit(OpCodes.Endfinally);
				ilGenerator.EndExceptionBlock();
				b.LeaveStubs(new Block(c, 0, int.MaxValue, -1, null, false));
			}
			else
			{
				Block b = new Block(c, 0, int.MaxValue, -1, null, false);
				c.Compile(b, 0);
				b.Leave();
			}
			nonleaf = c.nonleaf;
		}
		finally
		{
			Profiler.Leave("Compile");
		}
	}

	private sealed class Block
	{
		private readonly Compiler compiler;
		private readonly CodeEmitter ilgen;
		private readonly int beginIndex;
		private readonly int endIndex;
		private readonly int exceptionIndex;
		private List<object> exits;
		private readonly bool nested;
		private readonly object[] labels;

		internal Block(Compiler compiler, int beginIndex, int endIndex, int exceptionIndex, List<object> exits, bool nested)
		{
			this.compiler = compiler;
			this.ilgen = compiler.ilGenerator;
			this.beginIndex = beginIndex;
			this.endIndex = endIndex;
			this.exceptionIndex = exceptionIndex;
			this.exits = exits;
			this.nested = nested;
			labels = new object[compiler.m.Instructions.Length];
		}

		internal int EndIndex
		{
			get
			{
				return endIndex;
			}
		}

		internal int ExceptionIndex
		{
			get
			{
				return exceptionIndex;
			}
		}

		internal void SetBackwardBranchLabel(int instructionIndex, BranchCookie bc)
		{
			// NOTE we're overwriting the label that is already there
			labels[instructionIndex] = bc.Stub;
			if(exits == null)
			{
				exits = new List<object>();
			}
			exits.Add(bc);
		}

		internal CodeEmitterLabel GetLabel(int targetIndex)
		{
			if(IsInRange(targetIndex))
			{
				CodeEmitterLabel l = (CodeEmitterLabel)labels[targetIndex];
				if(l == null)
				{
					l = ilgen.DefineLabel();
					labels[targetIndex] = l;
				}
				return l;
			}
			else
			{
				BranchCookie l = (BranchCookie)labels[targetIndex];
				if(l == null)
				{
					// if we're branching out of the current exception block, we need to indirect this thru a stub
					// that saves the stack and uses leave to leave the exception block (to another stub that recovers
					// the stack)
					int stackHeight = compiler.ma.GetStackHeight(targetIndex);
					BranchCookie bc = new BranchCookie(compiler, stackHeight, targetIndex);
					bc.ContentOnStack = true;
					for(int i = 0; i < stackHeight; i++)
					{
						bc.dh.SetType(i, compiler.ma.GetRawStackTypeWrapper(targetIndex, i));
					}
					exits.Add(bc);
					l = bc;
					labels[targetIndex] = l;
				}
				return l.Stub;
			}
		}

		internal bool HasLabel(int instructionIndex)
		{
			return labels[instructionIndex] != null;
		}

		internal void MarkLabel(int instructionIndex)
		{
			object label = labels[instructionIndex];
			if(label == null)
			{
				CodeEmitterLabel l = ilgen.DefineLabel();
				ilgen.MarkLabel(l);
				labels[instructionIndex] = l;
			}
			else
			{
				ilgen.MarkLabel((CodeEmitterLabel)label);
			}
		}

		internal bool IsInRange(int index)
		{
			return beginIndex <= index && index < endIndex;
		}

		internal void Leave()
		{
			if(exits != null)
			{
				for(int i = 0; i < exits.Count; i++)
				{
					object exit = exits[i];
					BranchCookie bc = exit as BranchCookie;
					if(bc != null && bc.ContentOnStack)
					{
						bc.ContentOnStack = false;
						int stack = bc.dh.Count;
						// HACK this is unreachable code, but we make sure that
						// forward pass verification always yields a valid stack
						// (this is required for unreachable leave stubs that are
						// generated for unreachable code that follows an
						// embedded exception emitted by the compiler for invalid
						// code (e.g. NoSuchFieldError))
						for(int n = stack - 1; n >= 0; n--)
						{
							bc.dh.Load(n);
						}
						ilgen.MarkLabel(bc.Stub);
						for(int n = 0; n < stack; n++)
						{
							bc.dh.Store(n);
						}
						if(bc.TargetIndex == -1)
						{
							ilgen.EmitBr(bc.TargetLabel);
						}
						else
						{
							bc.Stub = ilgen.DefineLabel();
							ilgen.EmitLeave(bc.Stub);
						}
					}
				}
			}
		}

		internal void LeaveStubs(Block newBlock)
		{
			if(exits != null)
			{
				for(int i = 0; i < exits.Count; i++)
				{
					object exit = exits[i];
					ReturnCookie rc = exit as ReturnCookie;
					if(rc != null)
					{
						if(newBlock.IsNested)
						{
							newBlock.exits.Add(rc);
						}
						else
						{
							rc.EmitRet(ilgen);
						}
					}
					else
					{
						BranchCookie bc = exit as BranchCookie;
						if(bc != null && bc.TargetIndex != -1)
						{
							Debug.Assert(!bc.ContentOnStack);
							// if the target is within the new block, we handle it, otherwise we
							// defer the cookie to our caller
							if(newBlock.IsInRange(bc.TargetIndex))
							{
								bc.ContentOnStack = true;
								ilgen.MarkLabel(bc.Stub);
								int stack = bc.dh.Count;
								for(int n = stack - 1; n >= 0; n--)
								{
									bc.dh.Load(n);
								}
								ilgen.EmitBr(newBlock.GetLabel(bc.TargetIndex));
							}
							else
							{
								newBlock.exits.Add(bc);
							}
						}
					}
				}
			}
		}

		internal void AddExitHack(object bc)
		{
			exits.Add(bc);
		}

		internal bool IsNested
		{
			get
			{
				return nested;
			}
		}
	}

	private void Compile(Block block, int startIndex)
	{
		InstructionFlags[] flags = ComputePartialReachability(startIndex, true);
		ExceptionTableEntry[] exceptions = GetExceptionTableFor(flags);
		int exceptionIndex = 0;
		Instruction[] code = m.Instructions;
		Stack<Block> blockStack = new Stack<Block>();
		bool instructionIsForwardReachable = true;
		if(startIndex != 0)
		{
			for(int i = 0; i < flags.Length; i++)
			{
				if((flags[i] & InstructionFlags.Reachable) != 0)
				{
					if(i < startIndex)
					{
						instructionIsForwardReachable = false;
						ilGenerator.EmitBr(block.GetLabel(startIndex));
					}
					break;
				}
			}
		}
		for(int i = 0; i < code.Length; i++)
		{
			Instruction instr = code[i];

			if (scopeBegin != null)
			{
				for(int j = scopeClose[i]; j > 0; j--)
				{
					ilGenerator.EndScope();
				}
				for(int j = scopeBegin[i]; j > 0; j--)
				{
					ilGenerator.BeginScope();
				}
			}

			// if we've left the current exception block, do the exit processing
			while(block.EndIndex == i)
			{
				block.Leave();

				ExceptionTableEntry exc = exceptions[block.ExceptionIndex];

				Block prevBlock = block;
				block = blockStack.Pop();

				exceptionIndex = block.ExceptionIndex + 1;
				// skip over exception handlers that are no longer relevant
				for(; exceptionIndex < exceptions.Length && exceptions[exceptionIndex].endIndex <= i; exceptionIndex++)
				{
				}

				int handlerIndex = exc.handlerIndex;

				if(exc.catch_type == 0 && VerifierTypeWrapper.IsFaultBlockException(ma.GetRawStackTypeWrapper(handlerIndex, 0)))
				{
					if(exc.isFinally)
					{
						ilGenerator.BeginFinallyBlock();
					}
					else
					{
						ilGenerator.BeginFaultBlock();
					}
					Block b = new Block(this, 0, block.EndIndex, -1, null, false);
					Compile(b, handlerIndex);
					b.Leave();
					ilGenerator.EndExceptionBlock();
				}
				else
				{
					TypeWrapper exceptionTypeWrapper;
					bool remap;
					if(exc.catch_type == 0)
					{
						exceptionTypeWrapper = CoreClasses.java.lang.Throwable.Wrapper;
						remap = true;
					}
					else
					{
						exceptionTypeWrapper = classFile.GetConstantPoolClassType(exc.catch_type);
						remap = exceptionTypeWrapper.IsUnloadable || !exceptionTypeWrapper.IsSubTypeOf(CoreClasses.cli.System.Exception.Wrapper);
					}
					Type excType = exceptionTypeWrapper.TypeAsExceptionType;
					bool mapSafe = !exceptionTypeWrapper.IsUnloadable && !exceptionTypeWrapper.IsMapUnsafeException && !exceptionTypeWrapper.IsRemapped;
					if(mapSafe)
					{
						ilGenerator.BeginCatchBlock(excType);
					}
					else
					{
						ilGenerator.BeginCatchBlock(Types.Exception);
					}
					BranchCookie bc = new BranchCookie(this, 1, exc.handlerIndex);
					prevBlock.AddExitHack(bc);
					Instruction handlerInstr = code[handlerIndex];
					bool unusedException = (handlerInstr.NormalizedOpCode == NormalizedByteCode.__pop ||
						(handlerInstr.NormalizedOpCode == NormalizedByteCode.__astore &&
						localVars.GetLocalVar(handlerIndex) == null));
					int mapFlags = unusedException ? 2 : 0;
					if(mapSafe && unusedException)
					{
						// we don't need to do anything with the exception
					}
					else if(mapSafe)
					{
						ilGenerator.EmitLdc_I4(mapFlags | 1);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.mapException.MakeGenericMethod(excType));
					}
					else if(exceptionTypeWrapper == CoreClasses.java.lang.Throwable.Wrapper)
					{
						ilGenerator.EmitLdc_I4(mapFlags);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.mapException.MakeGenericMethod(Types.Exception));
					}
					else
					{
						ilGenerator.EmitLdc_I4(mapFlags | (remap ? 0 : 1));
						if(exceptionTypeWrapper.IsUnloadable)
						{
							Profiler.Count("EmitDynamicExceptionHandler");
							EmitDynamicClassLiteral(exceptionTypeWrapper);
							ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicMapException);
						}
						else
						{
							ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.mapException.MakeGenericMethod(excType));
						}
						if(!unusedException)
						{
							ilGenerator.Emit(OpCodes.Dup);
						}
						CodeEmitterLabel leave = ilGenerator.DefineLabel();
						ilGenerator.EmitBrtrue(leave);
						ilGenerator.Emit(OpCodes.Rethrow);
						ilGenerator.MarkLabel(leave);
					}
					if(unusedException)
					{
						// we must still have an item on the stack, even though it isn't used!
						bc.dh.SetType(0, VerifierTypeWrapper.Null);
					}
					else
					{
						bc.dh.SetType(0, exceptionTypeWrapper);
						bc.dh.Store(0);
					}
					ilGenerator.EmitLeave(bc.Stub);
					ilGenerator.EndExceptionBlock();
				}
				prevBlock.LeaveStubs(block);
			}

			if((flags[i] & InstructionFlags.Reachable) == 0)
			{
				// skip any unreachable instructions
				continue;
			}

			// if there was a forward branch to this instruction, it is forward reachable
			instructionIsForwardReachable |= block.HasLabel(i);

			if(block.HasLabel(i) || (flags[i] & InstructionFlags.BranchTarget) != 0)
			{
				block.MarkLabel(i);
			}

			// if the instruction is only backward reachable, ECMA says it must have an empty stack,
			// so we move the stack to locals
			if(!instructionIsForwardReachable)
			{
				int stackHeight = ma.GetStackHeight(i);
				if(stackHeight != 0)
				{
					BranchCookie bc = new BranchCookie(this, stackHeight, -1);
					bc.ContentOnStack = true;
					bc.TargetLabel = ilGenerator.DefineLabel();
					ilGenerator.MarkLabel(bc.TargetLabel);
					for(int j = 0; j < stackHeight; j++)
					{
						bc.dh.SetType(j, ma.GetRawStackTypeWrapper(i, j));
					}
					for(int j = stackHeight - 1; j >= 0; j--)
					{
						bc.dh.Load(j);
					}
					block.SetBackwardBranchLabel(i, bc);
				}
			}

			// if we're entering an exception block, we need to setup the exception block and
			// transfer the stack into it
			// Note that an exception block that *starts* at an unreachable instruction,
			// is completely unreachable, because it is impossible to branch into an exception block.
			for(; exceptionIndex < exceptions.Length && exceptions[exceptionIndex].startIndex == i; exceptionIndex++)
			{
				int stackHeight = ma.GetStackHeight(i);
				if(stackHeight != 0)
				{
					DupHelper dh = new DupHelper(this, stackHeight);
					for(int k = 0; k < stackHeight; k++)
					{
						dh.SetType(k, ma.GetRawStackTypeWrapper(i, k));
						dh.Store(k);
					}
					ilGenerator.BeginExceptionBlock();
					for(int k = stackHeight - 1; k >= 0; k--)
					{
						dh.Load(k);
					}
					dh.Release();
				}
				else
				{
					ilGenerator.BeginExceptionBlock();
				}
				blockStack.Push(block);
				block = new Block(this, exceptions[exceptionIndex].startIndex, exceptions[exceptionIndex].endIndex, exceptionIndex, new List<object>(), true);
				block.MarkLabel(i);
			}

			if(emitLineNumbers)
			{
				ClassFile.Method.LineNumberTableEntry[] table = m.LineNumberTableAttribute;
				for (int j = 0; j < table.Length; j++)
				{
					if(table[j].start_pc == code[i].PC && table[j].line_number != 0)
					{
						ilGenerator.SetLineNumber(table[j].line_number);
						break;
					}
				}
			}

			if(keepAlive)
			{
				// JSR 133 specifies that a finalizer cannot run while the constructor is still in progress.
				// This code attempts to implement that by adding calls to GC.KeepAlive(this) before return,
				// backward branches and throw instructions. I don't think it is perfect, you may be able to
				// fool it by calling a trivial method that loops forever which the CLR JIT will then inline
				// and see that control flow doesn't continue and hence the lifetime of "this" will be
				// shorter than the constructor.
				switch(ByteCodeMetaData.GetFlowControl(instr.NormalizedOpCode))
				{
					case ByteCodeFlowControl.Return:
						ilGenerator.Emit(OpCodes.Ldarg_0);
						ilGenerator.Emit(OpCodes.Call, keepAliveMethod);
						break;
					case ByteCodeFlowControl.Branch:
					case ByteCodeFlowControl.CondBranch:
						if(instr.TargetIndex <= i)
						{
							ilGenerator.Emit(OpCodes.Ldarg_0);
							ilGenerator.Emit(OpCodes.Call, keepAliveMethod);
						}
						break;
					case ByteCodeFlowControl.Throw:
					case ByteCodeFlowControl.Switch:
						if(ma.GetLocalTypeWrapper(i, 0) != VerifierTypeWrapper.UninitializedThis)
						{
							ilGenerator.Emit(OpCodes.Ldarg_0);
							ilGenerator.Emit(OpCodes.Call, keepAliveMethod);
						}
						break;
				}
			}

			switch(instr.NormalizedOpCode)
			{
				case NormalizedByteCode.__getstatic:
				{
					ClassFile.ConstantPoolItemFieldref cpi = classFile.GetFieldref(instr.Arg1);
					if(cpi.GetClassType() != clazz)
					{
						// we may trigger a static initializer, which is equivalent to a call
						nonleaf = true;
					}
					FieldWrapper field = cpi.GetField();
					field.EmitGet(ilGenerator);
					field.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilGenerator);
					break;
				}
				case NormalizedByteCode.__getfield:
				{
					ClassFile.ConstantPoolItemFieldref cpi = classFile.GetFieldref(instr.Arg1);
					FieldWrapper field = cpi.GetField();
					if (ma.GetStackTypeWrapper(i, 0).IsUnloadable)
					{
						if (field.IsProtected)
						{
							// downcast receiver to our type
							clazz.EmitCheckcast(ilGenerator);
						}
						else
						{
							// downcast receiver to field declaring type
							field.DeclaringType.EmitCheckcast(ilGenerator);
						}
					}
					field.EmitGet(ilGenerator);
					field.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilGenerator);
					break;
				}
				case NormalizedByteCode.__putstatic:
				{
					ClassFile.ConstantPoolItemFieldref cpi = classFile.GetFieldref(instr.Arg1);
					if(cpi.GetClassType() != clazz)
					{
						// we may trigger a static initializer, which is equivalent to a call
						nonleaf = true;
					}
					FieldWrapper field = cpi.GetField();
					TypeWrapper tw = field.FieldTypeWrapper;
					tw.EmitConvStackTypeToSignatureType(ilGenerator, ma.GetStackTypeWrapper(i, 0));
					if(strictfp)
					{
						// no need to convert
					}
					else if(tw == PrimitiveTypeWrapper.DOUBLE)
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					field.EmitSet(ilGenerator);
					break;
				}
				case NormalizedByteCode.__putfield:
				{
					ClassFile.ConstantPoolItemFieldref cpi = classFile.GetFieldref(instr.Arg1);
					FieldWrapper field = cpi.GetField();
					TypeWrapper tw = field.FieldTypeWrapper;
					if (ma.GetStackTypeWrapper(i, 1).IsUnloadable)
					{
						CodeEmitterLocal temp = ilGenerator.UnsafeAllocTempLocal(tw.TypeAsLocalOrStackType);
						ilGenerator.Emit(OpCodes.Stloc, temp);
						if (field.IsProtected)
						{
							// downcast receiver to our type
							clazz.EmitCheckcast(ilGenerator);
						}
						else
						{
							// downcast receiver to field declaring type
							field.DeclaringType.EmitCheckcast(ilGenerator);
						}
						ilGenerator.Emit(OpCodes.Ldloc, temp);
					}
					tw.EmitConvStackTypeToSignatureType(ilGenerator, ma.GetStackTypeWrapper(i, 0));
					if(strictfp)
					{
						// no need to convert
					}
					else if(tw == PrimitiveTypeWrapper.DOUBLE)
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					field.EmitSet(ilGenerator);
					break;
				}
				case NormalizedByteCode.__dynamic_getstatic:
				case NormalizedByteCode.__dynamic_putstatic:
				case NormalizedByteCode.__dynamic_getfield:
				case NormalizedByteCode.__dynamic_putfield:
					nonleaf = true;
					DynamicGetPutField(instr, i);
					break;
				case NormalizedByteCode.__aconst_null:
					ilGenerator.Emit(OpCodes.Ldnull);
					break;
				case NormalizedByteCode.__iconst:
					ilGenerator.EmitLdc_I4(instr.NormalizedArg1);
					break;
				case NormalizedByteCode.__lconst_0:
					ilGenerator.EmitLdc_I8(0L);
					break;
				case NormalizedByteCode.__lconst_1:
					ilGenerator.EmitLdc_I8(1L);
					break;
				case NormalizedByteCode.__fconst_0:
				case NormalizedByteCode.__dconst_0:
					// floats are stored as native size on the stack, so both R4 and R8 are the same
					ilGenerator.EmitLdc_R4(0.0f);
					break;
				case NormalizedByteCode.__fconst_1:
				case NormalizedByteCode.__dconst_1:
					// floats are stored as native size on the stack, so both R4 and R8 are the same
					ilGenerator.EmitLdc_R4(1.0f);
					break;
				case NormalizedByteCode.__fconst_2:
					ilGenerator.EmitLdc_R4(2.0f);
					break;
				case NormalizedByteCode.__ldc_nothrow:
				case NormalizedByteCode.__ldc:
					EmitLoadConstant(ilGenerator, instr.Arg1);
					break;
				case NormalizedByteCode.__invokedynamic:
				{
					ClassFile.ConstantPoolItemInvokeDynamic cpi = classFile.GetInvokeDynamic(instr.Arg1);
					CastInterfaceArgs(null, cpi.GetArgTypes(), i, false);
					if (!LambdaMetafactory.Emit(context, classFile, instr.Arg1, cpi, ilGenerator))
					{
						EmitInvokeDynamic(cpi);
						EmitReturnTypeConversion(cpi.GetRetType());
					}
					nonleaf = true;
					break;
				}
				case NormalizedByteCode.__dynamic_invokestatic:
				case NormalizedByteCode.__privileged_invokestatic:
				case NormalizedByteCode.__invokestatic:
				case NormalizedByteCode.__methodhandle_link:
				{
					MethodWrapper method = GetMethodCallEmitter(instr.NormalizedOpCode, instr.Arg1);
					if(method.IsIntrinsic && method.EmitIntrinsic(new EmitIntrinsicContext(method, context, ilGenerator, ma, i, mw, classFile, code, flags)))
					{
						break;
					}
					// if the stack values don't match the argument types (for interface argument types)
					// we must emit code to cast the stack value to the interface type
					CastInterfaceArgs(method.DeclaringType, method.GetParameters(), i, false);
					if(method.HasCallerID)
					{
						context.EmitCallerID(ilGenerator, m.IsLambdaFormCompiled);
					}
					method.EmitCall(ilGenerator);
					EmitReturnTypeConversion(method.ReturnType);
					nonleaf = true;
					break;
				}
				case NormalizedByteCode.__dynamic_invokeinterface:
				case NormalizedByteCode.__dynamic_invokevirtual:
				case NormalizedByteCode.__dynamic_invokespecial:
				case NormalizedByteCode.__privileged_invokevirtual:
				case NormalizedByteCode.__privileged_invokespecial:
				case NormalizedByteCode.__invokevirtual:
				case NormalizedByteCode.__invokeinterface:
				case NormalizedByteCode.__invokespecial:
				case NormalizedByteCode.__methodhandle_invoke:
				{
					bool isinvokespecial = instr.NormalizedOpCode == NormalizedByteCode.__invokespecial
						|| instr.NormalizedOpCode == NormalizedByteCode.__dynamic_invokespecial
						|| instr.NormalizedOpCode == NormalizedByteCode.__privileged_invokespecial;
					MethodWrapper method = GetMethodCallEmitter(instr.NormalizedOpCode, instr.Arg1);
					int argcount = method.GetParameters().Length;
					TypeWrapper type = ma.GetRawStackTypeWrapper(i, argcount);
					TypeWrapper thisType = ComputeThisType(type, method, instr.NormalizedOpCode);

					EmitIntrinsicContext eic = new EmitIntrinsicContext(method, context, ilGenerator, ma, i, mw, classFile, code, flags);
					if(method.IsIntrinsic && method.EmitIntrinsic(eic))
					{
						nonleaf |= eic.NonLeaf;
						break;
					}

					nonleaf = true;

					// HACK this code is duplicated in java.lang.invoke.cs
					if(method.IsFinalizeOrClone)
					{
						// HACK we may need to redirect finalize or clone from java.lang.Object/Throwable
						// to a more specific base type.
						if(thisType.IsAssignableTo(CoreClasses.cli.System.Object.Wrapper))
						{
							method = CoreClasses.cli.System.Object.Wrapper.GetMethodWrapper(method.Name, method.Signature, true);
						}
						else if(thisType.IsAssignableTo(CoreClasses.cli.System.Exception.Wrapper))
						{
							method = CoreClasses.cli.System.Exception.Wrapper.GetMethodWrapper(method.Name, method.Signature, true);
						}
						else if(thisType.IsAssignableTo(CoreClasses.java.lang.Throwable.Wrapper))
						{
							method = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper(method.Name, method.Signature, true);
						}
					}

					// if the stack values don't match the argument types (for interface argument types)
					// we must emit code to cast the stack value to the interface type
					if(isinvokespecial && method.IsConstructor && VerifierTypeWrapper.IsNew(type))
					{
						CastInterfaceArgs(method.DeclaringType, method.GetParameters(), i, false);
					}
					else
					{
						// the this reference is included in the argument list because it may also need to be cast
						TypeWrapper[] methodArgs = method.GetParameters();
						TypeWrapper[] args = new TypeWrapper[methodArgs.Length + 1];
						methodArgs.CopyTo(args, 1);
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface)
						{
							args[0] = method.DeclaringType;
						}
						else
						{
							args[0] = thisType;
						}
						CastInterfaceArgs(method.DeclaringType, args, i, true);
					}

					if(isinvokespecial && method.IsConstructor)
					{
						if(VerifierTypeWrapper.IsNew(type))
						{
							// we have to construct a list of all the unitialized references to the object
							// we're about to create on the stack, so that we can reconstruct the stack after
							// the "newobj" instruction
							int trivcount = 0;
							bool nontrivial = false;
							bool[] stackfix = new bool[ma.GetStackHeight(i) - (argcount + 1)];
							for(int j = 0; j < stackfix.Length; j++)
							{
								if(ma.GetRawStackTypeWrapper(i, argcount + 1 + j) == type)
								{
									stackfix[j] = true;
									if(trivcount == j)
									{
										trivcount++;
									}
									else
									{
										// if there is other stuff on the stack between the new object
										// references, we need to do more work to construct the proper stack
										// layout after the newobj instruction
										nontrivial = true;
									}
								}
							}
							for(int j = 0; !nontrivial && j < m.MaxLocals; j++)
							{
								if(ma.GetLocalTypeWrapper(i, j) == type)
								{
									nontrivial = true;
								}
							}
							if(!thisType.IsUnloadable && thisType.IsSubTypeOf(CoreClasses.java.lang.Throwable.Wrapper))
							{
								// if the next instruction is an athrow and the exception type
								// doesn't override fillInStackTrace, we can suppress the call
								// to fillInStackTrace from the constructor (and this is
								// a huge perf win)
								// NOTE we also can't call suppressFillInStackTrace for non-Java
								// exceptions (because then the suppress flag won't be cleared),
								// but this case is handled by the "is fillInStackTrace overridden?"
								// test, because cli.System.Exception overrides fillInStackTrace.
								if(code[i + 1].NormalizedOpCode == NormalizedByteCode.__athrow)
								{
									if(thisType.GetMethodWrapper("fillInStackTrace", "()Ljava.lang.Throwable;", true).DeclaringType == CoreClasses.java.lang.Throwable.Wrapper)
									{
										ilGenerator.Emit(OpCodes.Call, suppressFillInStackTraceMethod);
									}
									if((flags[i + 1] & InstructionFlags.BranchTarget) == 0)
									{
										code[i + 1].PatchOpCode(NormalizedByteCode.__athrow_no_unmap);
									}
								}
							}
							method.EmitNewobj(ilGenerator);
							if(!thisType.IsUnloadable && thisType.IsSubTypeOf(CoreClasses.cli.System.Exception.Wrapper))
							{
								// we call Throwable.__<fixate>() to disable remapping the exception
								ilGenerator.Emit(OpCodes.Call, fixateExceptionMethod);
							}
							if(nontrivial)
							{
								// this could be done a little more efficiently, but since in practice this
								// code never runs (for code compiled from Java source) it doesn't
								// really matter
								CodeEmitterLocal newobj = ilGenerator.DeclareLocal(GetLocalBuilderType(thisType));
								ilGenerator.Emit(OpCodes.Stloc, newobj);
								CodeEmitterLocal[] tempstack = new CodeEmitterLocal[stackfix.Length];
								for(int j = 0; j < stackfix.Length; j++)
								{
									if(!stackfix[j])
									{
										TypeWrapper stacktype = ma.GetStackTypeWrapper(i, argcount + 1 + j);
										// it could be another new object reference (not from current invokespecial <init>
										// instruction)
										if(stacktype == VerifierTypeWrapper.Null)
										{
											// NOTE we abuse the newobj local as a cookie to signal null!
											tempstack[j] = newobj;
											ilGenerator.Emit(OpCodes.Pop);
										}
										else if(!VerifierTypeWrapper.IsNotPresentOnStack(stacktype))
										{
											CodeEmitterLocal lb = ilGenerator.DeclareLocal(GetLocalBuilderType(stacktype));
											ilGenerator.Emit(OpCodes.Stloc, lb);
											tempstack[j] = lb;
										}
									}
								}
								for(int j = stackfix.Length - 1; j >= 0; j--)
								{
									if(stackfix[j])
									{
										ilGenerator.Emit(OpCodes.Ldloc, newobj);
									}
									else if(tempstack[j] != null)
									{
										// NOTE we abuse the newobj local as a cookie to signal null!
										if(tempstack[j] == newobj)
										{
											ilGenerator.Emit(OpCodes.Ldnull);
										}
										else
										{
											ilGenerator.Emit(OpCodes.Ldloc, tempstack[j]);
										}
									}
								}
								LocalVar[] locals = localVars.GetLocalVarsForInvokeSpecial(i);
								for(int j = 0; j < locals.Length; j++)
								{
									if(locals[j] != null)
									{
										if(locals[j].builder == null)
										{
											// for invokespecial the resulting type can never be null
											locals[j].builder = ilGenerator.DeclareLocal(GetLocalBuilderType(locals[j].type));
										}
										ilGenerator.Emit(OpCodes.Ldloc, newobj);
										ilGenerator.Emit(OpCodes.Stloc, locals[j].builder);
									}
								}
							}
							else
							{
								if(trivcount == 0)
								{
									ilGenerator.Emit(OpCodes.Pop);
								}
								else
								{
									for(int j = 1; j < trivcount; j++)
									{
										ilGenerator.Emit(OpCodes.Dup);
									}
								}
							}
						}
						else
						{
							Debug.Assert(type == VerifierTypeWrapper.UninitializedThis);
							method.EmitCall(ilGenerator);
							LocalVar[] locals = localVars.GetLocalVarsForInvokeSpecial(i);
							for(int j = 0; j < locals.Length; j++)
							{
								if(locals[j] != null)
								{
									if(locals[j].builder == null)
									{
										// for invokespecial the resulting type can never be null
										locals[j].builder = ilGenerator.DeclareLocal(GetLocalBuilderType(locals[j].type));
									}
									ilGenerator.Emit(OpCodes.Ldarg_0);
									ilGenerator.Emit(OpCodes.Stloc, locals[j].builder);
								}
							}
						}
					}
					else
					{
						if(method.HasCallerID)
						{
							context.EmitCallerID(ilGenerator, m.IsLambdaFormCompiled);
						}

						if(isinvokespecial)
						{
							if(VerifierTypeWrapper.IsThis(type))
							{
								method.EmitCall(ilGenerator);
							}
							else if(method.IsPrivate)
							{
								// if the method is private, we can get away with a callvirt (and not generate the stub)
								method.EmitCallvirt(ilGenerator);
							}
							else if(instr.NormalizedOpCode == NormalizedByteCode.__privileged_invokespecial)
							{
								method.EmitCall(ilGenerator);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Callvirt, context.GetInvokeSpecialStub(method));
							}
						}
						else
						{
							// NOTE this check is written somewhat pessimistically, because we need to
							// take remapped types into account. For example, Throwable.getClass() "overrides"
							// the final Object.getClass() method and we don't want to call Object.getClass()
							// on a Throwable instance, because that would yield unverifiable code (java.lang.Throwable
							// extends System.Exception instead of java.lang.Object in the .NET type system).
							if(VerifierTypeWrapper.IsThis(type)
								&& (method.IsFinal || clazz.IsFinal)
								&& clazz.GetMethodWrapper(method.Name, method.Signature, true) == method)
							{
								// we're calling a method on our own instance that can't possibly be overriden,
								// so we don't need to use callvirt
								method.EmitCall(ilGenerator);
							}
							else
							{
								method.EmitCallvirt(ilGenerator);
							}
						}
						EmitReturnTypeConversion(method.ReturnType);
					}
					break;
				}
				case NormalizedByteCode.__clone_array:
					ilGenerator.Emit(OpCodes.Callvirt, ArrayTypeWrapper.CloneMethod);
					break;
				case NormalizedByteCode.__return:
				case NormalizedByteCode.__areturn:
				case NormalizedByteCode.__ireturn:
				case NormalizedByteCode.__lreturn:
				case NormalizedByteCode.__freturn:
				case NormalizedByteCode.__dreturn:
				{
					if(block.IsNested)
					{
						// if we're inside an exception block, copy TOS to local, emit "leave" and push item onto our "todo" list
						CodeEmitterLocal local = null;
						if(instr.NormalizedOpCode != NormalizedByteCode.__return)
						{
							TypeWrapper retTypeWrapper = mw.ReturnType;
							retTypeWrapper.EmitConvStackTypeToSignatureType(ilGenerator, ma.GetStackTypeWrapper(i, 0));
							local = ilGenerator.UnsafeAllocTempLocal(retTypeWrapper.TypeAsSignatureType);
							ilGenerator.Emit(OpCodes.Stloc, local);
						}
						CodeEmitterLabel label = ilGenerator.DefineLabel();
						// NOTE leave automatically discards any junk that may be on the stack
						ilGenerator.EmitLeave(label);
						block.AddExitHack(new ReturnCookie(label, local));
					}
					else
					{
						// HACK the x64 JIT is lame and optimizes calls before ret into a tail call
						// and this makes the method disappear from the call stack, so we try to thwart that
						// by inserting some bogus instructions between the call and the return.
						// Note that this optimization doesn't appear to happen if the method has exception handlers,
						// so in that case we don't do anything.
						bool x64hack = false;
#if !NET_4_0
						if(exceptions.Length == 0 && i > 0)
						{
							int k = i - 1;
							while(k > 0 && code[k].NormalizedOpCode == NormalizedByteCode.__nop)
							{
								k--;
							}
							switch(code[k].NormalizedOpCode)
							{
								case NormalizedByteCode.__invokeinterface:
								case NormalizedByteCode.__invokespecial:
								case NormalizedByteCode.__invokestatic:
								case NormalizedByteCode.__invokevirtual:
									x64hack = true;
									break;
							}
						}
#endif
						// if there is junk on the stack (other than the return value), we must pop it off
						// because in .NET this is invalid (unlike in Java)
						int stackHeight = ma.GetStackHeight(i);
						if(instr.NormalizedOpCode == NormalizedByteCode.__return)
						{
							if(stackHeight != 0 || x64hack)
							{
								ilGenerator.EmitClearStack();
							}
							ilGenerator.Emit(OpCodes.Ret);
						}
						else
						{
							TypeWrapper retTypeWrapper = mw.ReturnType;
							retTypeWrapper.EmitConvStackTypeToSignatureType(ilGenerator, ma.GetStackTypeWrapper(i, 0));
							if(stackHeight != 1)
							{
								CodeEmitterLocal local = ilGenerator.AllocTempLocal(retTypeWrapper.TypeAsSignatureType);
								ilGenerator.Emit(OpCodes.Stloc, local);
								ilGenerator.EmitClearStack();
								ilGenerator.Emit(OpCodes.Ldloc, local);
								ilGenerator.ReleaseTempLocal(local);
							}
							else if(x64hack)
							{
								ilGenerator.EmitTailCallPrevention();
							}
							ilGenerator.Emit(OpCodes.Ret);
						}
					}
					break;
				}
				case NormalizedByteCode.__aload:
				{
					TypeWrapper type = ma.GetLocalTypeWrapper(i, instr.NormalizedArg1);
					if(type == VerifierTypeWrapper.Null)
					{
						// if the local is known to be null, we just emit a null
						ilGenerator.Emit(OpCodes.Ldnull);
					}
					else if(VerifierTypeWrapper.IsNotPresentOnStack(type))
					{
						// since object isn't represented on the stack, we don't need to do anything here
					}
					else if(VerifierTypeWrapper.IsThis(type))
					{
						ilGenerator.Emit(OpCodes.Ldarg_0);
					}
					else if(type == VerifierTypeWrapper.UninitializedThis)
					{
						// any unitialized this reference has to be loaded from arg 0
						// NOTE if the method overwrites the this references, it will always end up in
						// a different local (due to the way the local variable liveness analysis works),
						// so we don't have to worry about that.
						ilGenerator.Emit(OpCodes.Ldarg_0);
					}
					else
					{
						LocalVar v = LoadLocal(i);
						if(!type.IsUnloadable && (v.type.IsUnloadable || !v.type.IsAssignableTo(type)))
						{
							type.EmitCheckcast(ilGenerator);
						}
					}
					break;
				}
				case NormalizedByteCode.__astore:
				{
					TypeWrapper type = ma.GetRawStackTypeWrapper(i, 0);
					if(VerifierTypeWrapper.IsNotPresentOnStack(type))
					{
						// object isn't really on the stack, so we can't copy it into the local
						// (and the local doesn't exist anyway)
					}
					else if(type == VerifierTypeWrapper.UninitializedThis)
					{
						// any unitialized reference is always the this reference, we don't store anything
						// here (because CLR won't allow unitialized references in locals) and then when
						// the unitialized ref is loaded we redirect to the this reference
						ilGenerator.Emit(OpCodes.Pop);
					}
					else
					{
						StoreLocal(i);
					}
					break;
				}
				case NormalizedByteCode.__iload:
				case NormalizedByteCode.__lload:
				case NormalizedByteCode.__fload:
				case NormalizedByteCode.__dload:
					LoadLocal(i);
					break;
				case NormalizedByteCode.__istore:
				case NormalizedByteCode.__lstore:
					StoreLocal(i);
					break;
				case NormalizedByteCode.__fstore:
					StoreLocal(i);
					break;
				case NormalizedByteCode.__dstore:
					if(ma.IsStackTypeExtendedDouble(i, 0))
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					StoreLocal(i);
					break;
				case NormalizedByteCode.__new:
				{
					TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
					if(wrapper.IsUnloadable)
					{
						Profiler.Count("EmitDynamicNewCheckOnly");
						// this is here to make sure we throw the exception in the right location (before
						// evaluating the constructor arguments)
						EmitDynamicClassLiteral(wrapper);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicNewCheckOnly);
					}
					else if(wrapper != clazz && RequiresExplicitClassInit(wrapper, i + 1, flags))
					{
						// trigger cctor (as the spec requires)
						wrapper.EmitRunClassConstructor(ilGenerator);
					}
					// we don't actually allocate the object here, the call to <init> will be converted into a newobj instruction
					break;
				}
				case NormalizedByteCode.__multianewarray:
				{
					CodeEmitterLocal localArray = ilGenerator.UnsafeAllocTempLocal(JVM.Import(typeof(int[])));
					CodeEmitterLocal localInt = ilGenerator.UnsafeAllocTempLocal(Types.Int32);
					ilGenerator.EmitLdc_I4(instr.Arg2);
					ilGenerator.Emit(OpCodes.Newarr, Types.Int32);
					ilGenerator.Emit(OpCodes.Stloc, localArray);
					for(int j = 1; j <= instr.Arg2; j++)
					{
						ilGenerator.Emit(OpCodes.Stloc, localInt);
						ilGenerator.Emit(OpCodes.Ldloc, localArray);
						ilGenerator.EmitLdc_I4(instr.Arg2 - j);
						ilGenerator.Emit(OpCodes.Ldloc, localInt);
						ilGenerator.Emit(OpCodes.Stelem_I4);
					}
					TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
					if(wrapper.IsUnloadable)
					{
						Profiler.Count("EmitDynamicMultianewarray");
						ilGenerator.Emit(OpCodes.Ldloc, localArray);
						EmitDynamicClassLiteral(wrapper);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicMultianewarray);
					}
					else if(wrapper.IsGhost || wrapper.IsGhostArray)
					{
						TypeWrapper tw = wrapper;
						while(tw.IsArray)
						{
							tw = tw.ElementTypeWrapper;
						}
						ilGenerator.Emit(OpCodes.Ldtoken, ArrayTypeWrapper.MakeArrayType(tw.TypeAsTBD, wrapper.ArrayRank));
						ilGenerator.Emit(OpCodes.Ldloc, localArray);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.multianewarray_ghost);
						ilGenerator.Emit(OpCodes.Castclass, wrapper.TypeAsArrayType);
					}
					else
					{
						Type type = wrapper.TypeAsArrayType;
						ilGenerator.Emit(OpCodes.Ldtoken, type);
						ilGenerator.Emit(OpCodes.Ldloc, localArray);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.multianewarray);
						ilGenerator.Emit(OpCodes.Castclass, type);
					}
					break;
				}
				case NormalizedByteCode.__anewarray:
				{
					TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
					if(wrapper.IsUnloadable)
					{
						Profiler.Count("EmitDynamicNewarray");
						EmitDynamicClassLiteral(wrapper);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicNewarray);
					}
					else if(wrapper.IsGhost || wrapper.IsGhostArray)
					{
						// NOTE for ghost types we create object arrays to make sure that Ghost implementers can be
						// stored in ghost arrays, but this has the unintended consequence that ghost arrays can
						// contain *any* reference type (because they are compiled as Object arrays). We could
						// modify aastore to emit code to check for this, but this would have an huge performance
						// cost for all object arrays.
						// Oddly, while the JVM accepts any reference for any other interface typed references, in the
						// case of aastore it does check that the object actually implements the interface. This
						// is unfortunate, but I think we can live with this minor incompatibility.
						// Note that this does not break type safety, because when the incorrect object is eventually
						// used as the ghost interface type it will generate a ClassCastException.
						TypeWrapper tw = wrapper;
						while(tw.IsArray)
						{
							tw = tw.ElementTypeWrapper;
						}
						ilGenerator.Emit(OpCodes.Ldtoken, ArrayTypeWrapper.MakeArrayType(tw.TypeAsTBD, wrapper.ArrayRank + 1));
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.anewarray_ghost.MakeGenericMethod(wrapper.TypeAsArrayType));
					}
					else
					{
						ilGenerator.Emit(OpCodes.Newarr, wrapper.TypeAsArrayType);
					}
					break;
				}
				case NormalizedByteCode.__newarray:
				switch(instr.Arg1)
				{
					case 4:
						ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.BOOLEAN.TypeAsArrayType);
						break;
					case 5:
						ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.CHAR.TypeAsArrayType);
						break;
					case 6:
						ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.FLOAT.TypeAsArrayType);
						break;
					case 7:
						ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.DOUBLE.TypeAsArrayType);
						break;
					case 8:
						ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.BYTE.TypeAsArrayType);
						break;
					case 9:
						ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.SHORT.TypeAsArrayType);
						break;
					case 10:
						ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.INT.TypeAsArrayType);
						break;
					case 11:
						ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.LONG.TypeAsArrayType);
						break;
					default:
						// this can't happen, the verifier would have caught it
						throw new InvalidOperationException();
				}
					break;
				case NormalizedByteCode.__checkcast:
				{
					TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
					if(wrapper.IsUnloadable)
					{
						EmitDynamicCast(wrapper);
					}
					else
					{
						wrapper.EmitCheckcast(ilGenerator);
					}
					break;
				}
				case NormalizedByteCode.__instanceof:
				{
					TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
					if(wrapper.IsUnloadable)
					{
						EmitDynamicInstanceOf(wrapper);
					}
					else
					{
						wrapper.EmitInstanceOf(ilGenerator);
					}
					break;
				}
				case NormalizedByteCode.__aaload:
				{
					TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 1);
					if(tw.IsUnloadable)
					{
						Profiler.Count("EmitDynamicAaload");
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicAaload);
					}
					else
					{
						TypeWrapper elem = tw.ElementTypeWrapper;
						if(elem.IsNonPrimitiveValueType)
						{
							Type t = elem.TypeAsTBD;
							ilGenerator.Emit(OpCodes.Ldelema, t);
							ilGenerator.Emit(OpCodes.Ldobj, t);
							elem.EmitBox(ilGenerator);
						}
						else
						{
							ilGenerator.Emit(OpCodes.Ldelem_Ref);
						}
					}
					break;
				}
				case NormalizedByteCode.__baload:
					// NOTE both the JVM and the CLR use signed bytes for boolean arrays (how convenient!)
					ilGenerator.Emit(OpCodes.Ldelem_I1);
					break;
				case NormalizedByteCode.__bastore:
					ilGenerator.Emit(OpCodes.Stelem_I1);
					break;
				case NormalizedByteCode.__caload:
					ilGenerator.Emit(OpCodes.Ldelem_U2);
					break;
				case NormalizedByteCode.__castore:
					ilGenerator.Emit(OpCodes.Stelem_I2);
					break;
				case NormalizedByteCode.__saload:
					ilGenerator.Emit(OpCodes.Ldelem_I2);
					break;
				case NormalizedByteCode.__sastore:
					ilGenerator.Emit(OpCodes.Stelem_I2);
					break;
				case NormalizedByteCode.__iaload:
					ilGenerator.Emit(OpCodes.Ldelem_I4);
					break;
				case NormalizedByteCode.__iastore:
					ilGenerator.Emit(OpCodes.Stelem_I4);
					break;
				case NormalizedByteCode.__laload:
					ilGenerator.Emit(OpCodes.Ldelem_I8);
					break;
				case NormalizedByteCode.__lastore:
					ilGenerator.Emit(OpCodes.Stelem_I8);
					break;
				case NormalizedByteCode.__faload:
					ilGenerator.Emit(OpCodes.Ldelem_R4);
					break;
				case NormalizedByteCode.__fastore:
					ilGenerator.Emit(OpCodes.Stelem_R4);
					break;
				case NormalizedByteCode.__daload:
					ilGenerator.Emit(OpCodes.Ldelem_R8);
					break;
				case NormalizedByteCode.__dastore:
					if(ma.IsStackTypeExtendedDouble(i, 0))
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					ilGenerator.Emit(OpCodes.Stelem_R8);
					break;
				case NormalizedByteCode.__aastore:
				{
					TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 2);
					if(tw.IsUnloadable)
					{
						Profiler.Count("EmitDynamicAastore");
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicAastore);
					}
					else
					{
						TypeWrapper elem = tw.ElementTypeWrapper;
						if(elem.IsNonPrimitiveValueType)
						{
							Type t = elem.TypeAsTBD;
							CodeEmitterLocal local = ilGenerator.UnsafeAllocTempLocal(Types.Object);
							ilGenerator.Emit(OpCodes.Stloc, local);
							ilGenerator.Emit(OpCodes.Ldelema, t);
							ilGenerator.Emit(OpCodes.Ldloc, local);
							elem.EmitUnbox(ilGenerator);
							ilGenerator.Emit(OpCodes.Stobj, t);
						}
						else
						{
							// NOTE for verifiability it is expressly *not* required that the
							// value matches the array type, so we don't need to handle interface
							// references here.
							ilGenerator.Emit(OpCodes.Stelem_Ref);
						}
					}
					break;
				}
				case NormalizedByteCode.__arraylength:
					if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
					{
						ilGenerator.Emit(OpCodes.Castclass, Types.Array);
						ilGenerator.Emit(OpCodes.Callvirt, Types.Array.GetMethod("get_Length"));
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldlen);
					}
					break;
				case NormalizedByteCode.__lcmp:
					ilGenerator.Emit_lcmp();
					break;
				case NormalizedByteCode.__fcmpl:
					ilGenerator.Emit_fcmpl();
					break;
				case NormalizedByteCode.__fcmpg:
					ilGenerator.Emit_fcmpg();
					break;
				case NormalizedByteCode.__dcmpl:
					ilGenerator.Emit_dcmpl();
					break;
				case NormalizedByteCode.__dcmpg:
					ilGenerator.Emit_dcmpg();
					break;
				case NormalizedByteCode.__if_icmpeq:
					ilGenerator.EmitBeq(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__if_icmpne:
					ilGenerator.EmitBne_Un(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__if_icmple:
					ilGenerator.EmitBle(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__if_icmplt:
					ilGenerator.EmitBlt(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__if_icmpge:
					ilGenerator.EmitBge(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__if_icmpgt:
					ilGenerator.EmitBgt(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__ifle:
					ilGenerator.Emit_if_le_lt_ge_gt(CodeEmitter.Comparison.LessOrEqual, block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__iflt:
					ilGenerator.Emit_if_le_lt_ge_gt(CodeEmitter.Comparison.LessThan, block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__ifge:
					ilGenerator.Emit_if_le_lt_ge_gt(CodeEmitter.Comparison.GreaterOrEqual, block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__ifgt:
					ilGenerator.Emit_if_le_lt_ge_gt(CodeEmitter.Comparison.GreaterThan, block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__ifne:
				case NormalizedByteCode.__ifnonnull:
					ilGenerator.EmitBrtrue(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__ifeq:
				case NormalizedByteCode.__ifnull:
					ilGenerator.EmitBrfalse(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__if_acmpeq:
					ilGenerator.EmitBeq(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__if_acmpne:
					ilGenerator.EmitBne_Un(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__goto:
				case NormalizedByteCode.__goto_finally:
					ilGenerator.EmitBr(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__ineg:
				case NormalizedByteCode.__lneg:
				case NormalizedByteCode.__fneg:
				case NormalizedByteCode.__dneg:
					ilGenerator.Emit(OpCodes.Neg);
					break;
				case NormalizedByteCode.__iadd:
				case NormalizedByteCode.__ladd:
					ilGenerator.Emit(OpCodes.Add);
					break;
				case NormalizedByteCode.__fadd:
					ilGenerator.Emit(OpCodes.Add);
					ilGenerator.Emit(OpCodes.Conv_R4);
					break;
				case NormalizedByteCode.__dadd:
					ilGenerator.Emit(OpCodes.Add);
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					break;
				case NormalizedByteCode.__isub:
				case NormalizedByteCode.__lsub:
					ilGenerator.Emit(OpCodes.Sub);
					break;
				case NormalizedByteCode.__fsub:
					ilGenerator.Emit(OpCodes.Sub);
					ilGenerator.Emit(OpCodes.Conv_R4);
					break;
				case NormalizedByteCode.__dsub:
					ilGenerator.Emit(OpCodes.Sub);
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					break;
				case NormalizedByteCode.__ixor:
				case NormalizedByteCode.__lxor:
					ilGenerator.Emit(OpCodes.Xor);
					break;
				case NormalizedByteCode.__ior:
				case NormalizedByteCode.__lor:
					ilGenerator.Emit(OpCodes.Or);
					break;
				case NormalizedByteCode.__iand:
				case NormalizedByteCode.__land:
					ilGenerator.Emit(OpCodes.And);
					break;
				case NormalizedByteCode.__imul:
				case NormalizedByteCode.__lmul:
					ilGenerator.Emit(OpCodes.Mul);
					break;
				case NormalizedByteCode.__fmul:
					ilGenerator.Emit(OpCodes.Mul);
					ilGenerator.Emit(OpCodes.Conv_R4);
					break;
				case NormalizedByteCode.__dmul:
					ilGenerator.Emit(OpCodes.Mul);
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					break;
				case NormalizedByteCode.__idiv:
					ilGenerator.Emit_idiv();
					break;
				case NormalizedByteCode.__ldiv:
					ilGenerator.Emit_ldiv();
					break;
				case NormalizedByteCode.__fdiv:
					ilGenerator.Emit(OpCodes.Div);
					ilGenerator.Emit(OpCodes.Conv_R4);
					break;
				case NormalizedByteCode.__ddiv:
					ilGenerator.Emit(OpCodes.Div);
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					break;
				case NormalizedByteCode.__irem:
				case NormalizedByteCode.__lrem:
				{
					// we need to special case taking the remainder of dividing by -1,
					// because the CLR rem instruction throws an OverflowException when
					// taking the remainder of dividing Int32.MinValue by -1, and
					// Java just silently overflows
					ilGenerator.Emit(OpCodes.Dup);
					ilGenerator.Emit(OpCodes.Ldc_I4_M1);
					if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
					{
						ilGenerator.Emit(OpCodes.Conv_I8);
					}
					CodeEmitterLabel label = ilGenerator.DefineLabel();
					ilGenerator.EmitBne_Un(label);
					ilGenerator.Emit(OpCodes.Pop);
					ilGenerator.Emit(OpCodes.Pop);
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
					{
						ilGenerator.Emit(OpCodes.Conv_I8);
					}
					CodeEmitterLabel label2 = ilGenerator.DefineLabel();
					ilGenerator.EmitBr(label2);
					ilGenerator.MarkLabel(label);
					ilGenerator.Emit(OpCodes.Rem);
					ilGenerator.MarkLabel(label2);
					break;
				}
				case NormalizedByteCode.__frem:
					ilGenerator.Emit(OpCodes.Rem);
					ilGenerator.Emit(OpCodes.Conv_R4);
					break;
				case NormalizedByteCode.__drem:
					ilGenerator.Emit(OpCodes.Rem);
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					break;
				case NormalizedByteCode.__ishl:
					ilGenerator.Emit_And_I4(31);
					ilGenerator.Emit(OpCodes.Shl);
					break;
				case NormalizedByteCode.__lshl:
					ilGenerator.Emit_And_I4(63);
					ilGenerator.Emit(OpCodes.Shl);
					break;
				case NormalizedByteCode.__iushr:
					ilGenerator.Emit_And_I4(31);
					ilGenerator.Emit(OpCodes.Shr_Un);
					break;
				case NormalizedByteCode.__lushr:
					ilGenerator.Emit_And_I4(63);
					ilGenerator.Emit(OpCodes.Shr_Un);
					break;
				case NormalizedByteCode.__ishr:
					ilGenerator.Emit_And_I4(31);
					ilGenerator.Emit(OpCodes.Shr);
					break;
				case NormalizedByteCode.__lshr:
					ilGenerator.Emit_And_I4(63);
					ilGenerator.Emit(OpCodes.Shr);
					break;
				case NormalizedByteCode.__swap:
				{
					DupHelper dh = new DupHelper(this, 2);
					dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
					dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
					dh.Store(0);
					dh.Store(1);
					dh.Load(0);
					dh.Load(1);
					dh.Release();
					break;
				}
				case NormalizedByteCode.__dup:
					// if the TOS contains a "new" object or a fault block exception, it isn't really there, so we don't dup it
					if(!VerifierTypeWrapper.IsNotPresentOnStack(ma.GetRawStackTypeWrapper(i, 0)))
					{
						ilGenerator.Emit(OpCodes.Dup);
					}
					break;
				case NormalizedByteCode.__dup2:
				{
					TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
					if(type1.IsWidePrimitive)
					{
						ilGenerator.Emit(OpCodes.Dup);
					}
					else
					{
						DupHelper dh = new DupHelper(this, 2);
						dh.SetType(0, type1);
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.Store(0);
						dh.Store(1);
						dh.Load(1);
						dh.Load(0);
						dh.Load(1);
						dh.Load(0);
						dh.Release();
					}
					break;
				}
				case NormalizedByteCode.__dup_x1:
				{
					DupHelper dh = new DupHelper(this, 2);
					dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
					dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
					dh.Store(0);
					dh.Store(1);
					dh.Load(0);
					dh.Load(1);
					dh.Load(0);
					dh.Release();
					break;
				}
				case NormalizedByteCode.__dup2_x1:
				{
					TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
					if(type1.IsWidePrimitive)
					{
						DupHelper dh = new DupHelper(this, 2);
						dh.SetType(0, type1);
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.Store(0);
						dh.Store(1);
						dh.Load(0);
						dh.Load(1);
						dh.Load(0);
						dh.Release();
					}
					else
					{
						DupHelper dh = new DupHelper(this, 3);
						dh.SetType(0, type1);
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
						dh.Store(0);
						dh.Store(1);
						dh.Store(2);
						dh.Load(1);
						dh.Load(0);
						dh.Load(2);
						dh.Load(1);
						dh.Load(0);
						dh.Release();
					}
					break;
				}
				case NormalizedByteCode.__dup2_x2:
				{
					TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
					TypeWrapper type2 = ma.GetRawStackTypeWrapper(i, 1);
					if(type1.IsWidePrimitive)
					{
						if(type2.IsWidePrimitive)
						{
							// Form 4
							DupHelper dh = new DupHelper(this, 2);
							dh.SetType(0, type1);
							dh.SetType(1, type2);
							dh.Store(0);
							dh.Store(1);
							dh.Load(0);
							dh.Load(1);
							dh.Load(0);
							dh.Release();
						}
						else
						{
							// Form 2
							DupHelper dh = new DupHelper(this, 3);
							dh.SetType(0, type1);
							dh.SetType(1, type2);
							dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
							dh.Store(0);
							dh.Store(1);
							dh.Store(2);
							dh.Load(0);
							dh.Load(2);
							dh.Load(1);
							dh.Load(0);
							dh.Release();
						}
					}
					else
					{
						TypeWrapper type3 = ma.GetRawStackTypeWrapper(i, 2);
						if(type3.IsWidePrimitive)
						{
							// Form 3
							DupHelper dh = new DupHelper(this, 3);
							dh.SetType(0, type1);
							dh.SetType(1, type2);
							dh.SetType(2, type3);
							dh.Store(0);
							dh.Store(1);
							dh.Store(2);
							dh.Load(1);
							dh.Load(0);
							dh.Load(2);
							dh.Load(1);
							dh.Load(0);
							dh.Release();
						}
						else
						{
							// Form 1
							DupHelper dh = new DupHelper(this, 4);
							dh.SetType(0, type1);
							dh.SetType(1, type2);
							dh.SetType(2, type3);
							dh.SetType(3, ma.GetRawStackTypeWrapper(i, 3));
							dh.Store(0);
							dh.Store(1);
							dh.Store(2);
							dh.Store(3);
							dh.Load(1);
							dh.Load(0);
							dh.Load(3);
							dh.Load(2);
							dh.Load(1);
							dh.Load(0);
							dh.Release();
						}
					}
					break;
				}
				case NormalizedByteCode.__dup_x2:
				{
					TypeWrapper type2 = ma.GetRawStackTypeWrapper(i, 1);
					if(type2.IsWidePrimitive)
					{
						// Form 2
						DupHelper dh = new DupHelper(this, 2);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, type2);
						dh.Store(0);
						dh.Store(1);
						dh.Load(0);
						dh.Load(1);
						dh.Load(0);
						dh.Release();
					}
					else
					{
						// Form 1
						DupHelper dh = new DupHelper(this, 3);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, type2);
						dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
						dh.Store(0);
						dh.Store(1);
						dh.Store(2);
						dh.Load(0);
						dh.Load(2);
						dh.Load(1);
						dh.Load(0);
						dh.Release();
					}
					break;
				}
				case NormalizedByteCode.__pop2:
				{
					TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
					if(type1.IsWidePrimitive)
					{
						ilGenerator.Emit(OpCodes.Pop);
					}
					else
					{
						if (!VerifierTypeWrapper.IsNotPresentOnStack(type1))
						{
							ilGenerator.Emit(OpCodes.Pop);
						}
						if (!VerifierTypeWrapper.IsNotPresentOnStack(ma.GetRawStackTypeWrapper(i, 1)))
						{
							ilGenerator.Emit(OpCodes.Pop);
						}
					}
					break;
				}
				case NormalizedByteCode.__pop:
					// if the TOS is a new object or a fault block exception, it isn't really there, so we don't need to pop it
					if(!VerifierTypeWrapper.IsNotPresentOnStack(ma.GetRawStackTypeWrapper(i, 0)))
					{
						ilGenerator.Emit(OpCodes.Pop);
					}
					break;
				case NormalizedByteCode.__monitorenter:
					ilGenerator.EmitMonitorEnter();
					break;
				case NormalizedByteCode.__monitorexit:
					ilGenerator.EmitMonitorExit();
					break;
				case NormalizedByteCode.__athrow_no_unmap:
					if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
					{
						ilGenerator.Emit(OpCodes.Castclass, Types.Exception);
					}
					ilGenerator.Emit(OpCodes.Throw);
					break;
				case NormalizedByteCode.__athrow:
					if (VerifierTypeWrapper.IsFaultBlockException(ma.GetRawStackTypeWrapper(i, 0)))
					{
						ilGenerator.Emit(OpCodes.Endfinally);
					}
					else
					{
						if (ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
						{
							ilGenerator.Emit(OpCodes.Castclass, Types.Exception);
						}
						ilGenerator.Emit(OpCodes.Call, unmapExceptionMethod);
						ilGenerator.Emit(OpCodes.Throw);
					}
					break;
				case NormalizedByteCode.__tableswitch:
				{
					// note that a tableswitch always has at least one entry
					// (otherwise it would have failed verification)
					CodeEmitterLabel[] labels = new CodeEmitterLabel[instr.SwitchEntryCount];
					for(int j = 0; j < labels.Length; j++)
					{
						labels[j] = block.GetLabel(instr.GetSwitchTargetIndex(j));
					}
					if(instr.GetSwitchValue(0) != 0)
					{
						ilGenerator.EmitLdc_I4(instr.GetSwitchValue(0));
						ilGenerator.Emit(OpCodes.Sub);
					}
					ilGenerator.EmitSwitch(labels);
					ilGenerator.EmitBr(block.GetLabel(instr.DefaultTarget));
					break;
				}
				case NormalizedByteCode.__lookupswitch:
					for(int j = 0; j < instr.SwitchEntryCount; j++)
					{
						ilGenerator.Emit(OpCodes.Dup);
						ilGenerator.EmitLdc_I4(instr.GetSwitchValue(j));
						CodeEmitterLabel label = ilGenerator.DefineLabel();
						ilGenerator.EmitBne_Un(label);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.EmitBr(block.GetLabel(instr.GetSwitchTargetIndex(j)));
						ilGenerator.MarkLabel(label);
					}
					ilGenerator.Emit(OpCodes.Pop);
					ilGenerator.EmitBr(block.GetLabel(instr.DefaultTarget));
					break;
				case NormalizedByteCode.__iinc:
					LoadLocal(i);
					ilGenerator.EmitLdc_I4(instr.Arg2);
					ilGenerator.Emit(OpCodes.Add);
					StoreLocal(i);
					break;
				case NormalizedByteCode.__i2b:
					ilGenerator.Emit(OpCodes.Conv_I1);
					break;
				case NormalizedByteCode.__i2c:
					ilGenerator.Emit(OpCodes.Conv_U2);
					break;
				case NormalizedByteCode.__i2s:
					ilGenerator.Emit(OpCodes.Conv_I2);
					break;
				case NormalizedByteCode.__l2i:
					ilGenerator.Emit(OpCodes.Conv_I4);
					break;
				case NormalizedByteCode.__f2i:
					ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.f2i);
					break;
				case NormalizedByteCode.__d2i:
					ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.d2i);
					break;
				case NormalizedByteCode.__f2l:
					ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.f2l);
					break;
				case NormalizedByteCode.__d2l:
					ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.d2l);
					break;
				case NormalizedByteCode.__i2l:
					ilGenerator.Emit(OpCodes.Conv_I8);
					break;
				case NormalizedByteCode.__i2f:
				case NormalizedByteCode.__l2f:
				case NormalizedByteCode.__d2f:
					ilGenerator.Emit(OpCodes.Conv_R4);
					break;
				case NormalizedByteCode.__i2d:
				case NormalizedByteCode.__l2d:
				case NormalizedByteCode.__f2d:
					ilGenerator.Emit(OpCodes.Conv_R8);
					break;
				case NormalizedByteCode.__nop:
					ilGenerator.Emit(OpCodes.Nop);
					break;
				case NormalizedByteCode.__intrinsic_gettype:
					ilGenerator.Emit(OpCodes.Callvirt, getTypeMethod);
					break;
				case NormalizedByteCode.__static_error:
				{
					bool wrapIncompatibleClassChangeError = false;
					TypeWrapper exceptionType;
					switch(instr.HardError)
					{
						case HardError.AbstractMethodError:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.AbstractMethodError");
							break;
						case HardError.IllegalAccessError:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.IllegalAccessError");
							break;
						case HardError.IncompatibleClassChangeError:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.IncompatibleClassChangeError");
							break;
						case HardError.InstantiationError:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.InstantiationError");
							break;
						case HardError.LinkageError:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.LinkageError");
							break;
						case HardError.NoClassDefFoundError:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.NoClassDefFoundError");
							break;
						case HardError.NoSuchFieldError:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchFieldError");
							break;
						case HardError.NoSuchMethodError:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchMethodError");
							break;
						case HardError.IllegalAccessException:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.IllegalAccessException");
							wrapIncompatibleClassChangeError = true;
							break;
						default:
							throw new InvalidOperationException();
					}
					if(wrapIncompatibleClassChangeError)
					{
						ClassLoaderWrapper.LoadClassCritical("java.lang.IncompatibleClassChangeError").GetMethodWrapper("<init>", "()V", false).EmitNewobj(ilGenerator);
					}
					string message = harderrors[instr.HardErrorMessageId];
					Tracer.Error(Tracer.Compiler, "{0}: {1}\n\tat {2}.{3}{4}", exceptionType.Name, message, classFile.Name, m.Name, m.Signature);
					ilGenerator.Emit(OpCodes.Ldstr, message);
					MethodWrapper method = exceptionType.GetMethodWrapper("<init>", "(Ljava.lang.String;)V", false);
					method.Link();
					method.EmitNewobj(ilGenerator);
					if(wrapIncompatibleClassChangeError)
					{
						CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("initCause", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false).EmitCallvirt(ilGenerator);
					}
					ilGenerator.Emit(OpCodes.Throw);
					break;
				}
				default:
					throw new NotImplementedException(instr.NormalizedOpCode.ToString());
			}
			// mark next instruction as inuse
			switch(ByteCodeMetaData.GetFlowControl(instr.NormalizedOpCode))
			{
				case ByteCodeFlowControl.Switch:
				case ByteCodeFlowControl.Branch:
				case ByteCodeFlowControl.Return:
				case ByteCodeFlowControl.Throw:
					instructionIsForwardReachable = false;
					break;
				case ByteCodeFlowControl.CondBranch:
				case ByteCodeFlowControl.Next:
					instructionIsForwardReachable = true;
					Debug.Assert((flags[i + 1] & InstructionFlags.Reachable) != 0);
					// don't fall through end of try block
					if(block.EndIndex == i + 1)
					{
						// TODO instead of emitting a branch to the leave stub, it would be more efficient to put the leave stub here
						ilGenerator.EmitBr(block.GetLabel(i + 1));
					}
					break;
				default:
					throw new InvalidOperationException();
			}
		}
	}

	private void EmitReturnTypeConversion(TypeWrapper returnType)
	{
		returnType.EmitConvSignatureTypeToStackType(ilGenerator);
		if (!strictfp)
		{
			// no need to convert
		}
		else if (returnType == PrimitiveTypeWrapper.DOUBLE)
		{
			ilGenerator.Emit(OpCodes.Conv_R8);
		}
		else if (returnType == PrimitiveTypeWrapper.FLOAT)
		{
			ilGenerator.Emit(OpCodes.Conv_R4);
		}
	}

	private void EmitLoadConstant(CodeEmitter ilgen, int constant)
	{
		switch (classFile.GetConstantPoolConstantType(constant))
		{
			case ClassFile.ConstantType.Double:
				ilgen.EmitLdc_R8(classFile.GetConstantPoolConstantDouble(constant));
				break;
			case ClassFile.ConstantType.Float:
				ilgen.EmitLdc_R4(classFile.GetConstantPoolConstantFloat(constant));
				break;
			case ClassFile.ConstantType.Integer:
				ilgen.EmitLdc_I4(classFile.GetConstantPoolConstantInteger(constant));
				break;
			case ClassFile.ConstantType.Long:
				ilgen.EmitLdc_I8(classFile.GetConstantPoolConstantLong(constant));
				break;
			case ClassFile.ConstantType.String:
				ilgen.Emit(OpCodes.Ldstr, classFile.GetConstantPoolConstantString(constant));
				break;
			case ClassFile.ConstantType.Class:
				EmitLoadClass(ilgen, classFile.GetConstantPoolClassType(constant));
				break;
			case ClassFile.ConstantType.MethodHandle:
				context.GetValue<MethodHandleConstant>(constant).Emit(this, ilgen, constant);
				break;
			case ClassFile.ConstantType.MethodType:
				context.GetValue<MethodTypeConstant>(constant).Emit(this, ilgen, constant);
				break;
#if !STATIC_COMPILER
			case ClassFile.ConstantType.LiveObject:
				context.EmitLiveObjectLoad(ilgen, classFile.GetConstantPoolConstantLiveObject(constant));
				break;
#endif
			default:
				throw new InvalidOperationException();
		}
	}

	private void EmitDynamicCast(TypeWrapper tw)
	{
		Debug.Assert(tw.IsUnloadable);
		Profiler.Count("EmitDynamicCast");
		// NOTE it's important that we don't try to load the class if obj == null
		CodeEmitterLabel ok = ilGenerator.DefineLabel();
		ilGenerator.Emit(OpCodes.Dup);
		ilGenerator.EmitBrfalse(ok);
		EmitDynamicClassLiteral(tw);
		ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicCast);
		ilGenerator.MarkLabel(ok);
	}

	private void EmitDynamicInstanceOf(TypeWrapper tw)
	{
		// NOTE it's important that we don't try to load the class if obj == null
		CodeEmitterLabel notnull = ilGenerator.DefineLabel();
		CodeEmitterLabel end = ilGenerator.DefineLabel();
		ilGenerator.Emit(OpCodes.Dup);
		ilGenerator.EmitBrtrue(notnull);
		ilGenerator.Emit(OpCodes.Pop);
		ilGenerator.EmitLdc_I4(0);
		ilGenerator.EmitBr(end);
		ilGenerator.MarkLabel(notnull);
		EmitDynamicClassLiteral(tw);
		ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicInstanceOf);
		ilGenerator.MarkLabel(end);
	}

	private void EmitDynamicClassLiteral(TypeWrapper tw)
	{
		context.EmitDynamicClassLiteral(ilGenerator, tw, m.IsLambdaFormCompiled);
	}

	private void EmitLoadClass(CodeEmitter ilgen, TypeWrapper tw)
	{
		if (tw.IsUnloadable)
		{
			Profiler.Count("EmitDynamicClassLiteral");
			context.EmitDynamicClassLiteral(ilgen, tw, m.IsLambdaFormCompiled);
		}
		else
		{
			tw.EmitClassLiteral(ilgen);
		}
	}

	internal static bool HasUnloadable(TypeWrapper[] args, TypeWrapper ret)
	{
		TypeWrapper tw = ret;
		for (int i = 0; !tw.IsUnloadable && i < args.Length; i++)
		{
			tw = args[i];
		}
		return tw.IsUnloadable;
	}

	private static class InvokeDynamicBuilder
	{
		private static readonly Type typeofOpenIndyCallSite;
		private static readonly Type typeofCallSite;
		private static readonly MethodWrapper methodLookup;

		static InvokeDynamicBuilder()
		{
#if STATIC_COMPILER
			typeofOpenIndyCallSite = StaticCompiler.GetRuntimeType("IKVM.Runtime.IndyCallSite`1");
			typeofCallSite = ClassLoaderWrapper.LoadClassCritical("java.lang.invoke.CallSite").TypeAsSignatureType;
#elif !FIRST_PASS
			typeofOpenIndyCallSite = typeof(IKVM.Runtime.IndyCallSite<>);
			typeofCallSite = typeof(java.lang.invoke.CallSite);
#endif
			methodLookup = ClassLoaderWrapper.LoadClassCritical("java.lang.invoke.MethodHandles")
				.GetMethodWrapper("lookup", "()Ljava.lang.invoke.MethodHandles$Lookup;", false);
			methodLookup.Link();
		}

		internal static void Emit(Compiler compiler, ClassFile.ConstantPoolItemInvokeDynamic cpi, Type delegateType)
		{
			Type typeofIndyCallSite = typeofOpenIndyCallSite.MakeGenericType(delegateType);
			MethodInfo methodCreateBootStrap;
			MethodInfo methodGetTarget;
			if (ReflectUtil.ContainsTypeBuilder(typeofIndyCallSite))
			{
				methodCreateBootStrap = TypeBuilder.GetMethod(typeofIndyCallSite, typeofOpenIndyCallSite.GetMethod("CreateBootstrap"));
				methodGetTarget = TypeBuilder.GetMethod(typeofIndyCallSite, typeofOpenIndyCallSite.GetMethod("GetTarget"));
			}
			else
			{
				methodCreateBootStrap = typeofIndyCallSite.GetMethod("CreateBootstrap");
				methodGetTarget = typeofIndyCallSite.GetMethod("GetTarget");
			}
			TypeBuilder tb = compiler.context.DefineIndyCallSiteType();
			FieldBuilder fb = tb.DefineField("value", typeofIndyCallSite, FieldAttributes.Static | FieldAttributes.Assembly);
			CodeEmitter ilgen = CodeEmitter.Create(ReflectUtil.DefineTypeInitializer(tb, compiler.clazz.GetClassLoader()));
			ilgen.Emit(OpCodes.Ldnull);
			ilgen.Emit(OpCodes.Ldftn, CreateBootstrapStub(compiler, cpi, delegateType, tb, fb, methodGetTarget));
			ilgen.Emit(OpCodes.Newobj, MethodHandleUtil.GetDelegateConstructor(delegateType));
			ilgen.Emit(OpCodes.Call, methodCreateBootStrap);
			ilgen.Emit(OpCodes.Stsfld, fb);
			ilgen.Emit(OpCodes.Ret);
			ilgen.DoEmit();

			compiler.ilGenerator.Emit(OpCodes.Ldsfld, fb);
			compiler.ilGenerator.Emit(OpCodes.Call, methodGetTarget);
		}

		private static MethodBuilder CreateBootstrapStub(Compiler compiler, ClassFile.ConstantPoolItemInvokeDynamic cpi, Type delegateType, TypeBuilder tb, FieldBuilder fb, MethodInfo methodGetTarget)
		{
			Type[] args = Type.EmptyTypes;
			if (delegateType.IsGenericType)
			{
				// MONOBUG we don't look at the invoke method directly here, because Mono doesn't support GetParameters() on a builder instantiation
				args = delegateType.GetGenericArguments();
				if (cpi.GetRetType() != PrimitiveTypeWrapper.VOID)
				{
					Array.Resize(ref args, args.Length - 1);
				}
			}
			MethodBuilder mb = tb.DefineMethod("BootstrapStub", MethodAttributes.Static | MethodAttributes.PrivateScope, cpi.GetRetType().TypeAsSignatureType, args);
			CodeEmitter ilgen = CodeEmitter.Create(mb);
			CodeEmitterLocal cs = ilgen.DeclareLocal(typeofCallSite);
			CodeEmitterLocal ex = ilgen.DeclareLocal(Types.Exception);
			CodeEmitterLocal ok = ilgen.DeclareLocal(Types.Boolean);
			CodeEmitterLabel label = ilgen.DefineLabel();
			ilgen.BeginExceptionBlock();
			if (EmitCallBootstrapMethod(compiler, cpi, ilgen, ok))
			{
				ilgen.Emit(OpCodes.Isinst, typeofCallSite);
				ilgen.Emit(OpCodes.Stloc, cs);
			}
			ilgen.EmitLeave(label);
			ilgen.BeginCatchBlock(Types.Exception);
			ilgen.Emit(OpCodes.Stloc, ex);
			ilgen.Emit(OpCodes.Ldloc, ok);
			CodeEmitterLabel label2 = ilgen.DefineLabel();
			ilgen.EmitBrtrue(label2);
			ilgen.Emit(OpCodes.Rethrow);
			ilgen.MarkLabel(label2);
			ilgen.EmitLeave(label);
			ilgen.EndExceptionBlock();
			ilgen.MarkLabel(label);
			ilgen.Emit(OpCodes.Ldsflda, fb);
			ilgen.Emit(OpCodes.Ldloc, cs);
			ilgen.Emit(OpCodes.Ldloc, ex);
			if (HasUnloadable(cpi.GetArgTypes(), cpi.GetRetType()))
			{
				ilgen.Emit(OpCodes.Ldstr, cpi.Signature);
				compiler.context.EmitCallerID(ilgen, compiler.m.IsLambdaFormHidden);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicLinkIndyCallSite.MakeGenericMethod(delegateType));
			}
			else
			{
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LinkIndyCallSite.MakeGenericMethod(delegateType));
			}
			ilgen.Emit(OpCodes.Ldsfld, fb);
			ilgen.Emit(OpCodes.Call, methodGetTarget);
			for (int i = 0; i < args.Length; i++)
			{
				ilgen.EmitLdarg(i);
			}
			ilgen.Emit(OpCodes.Callvirt, MethodHandleUtil.GetDelegateInvokeMethod(delegateType));
			ilgen.Emit(OpCodes.Ret);
			ilgen.DoEmit();
			return mb;
		}

		private static bool EmitCallBootstrapMethod(Compiler compiler, ClassFile.ConstantPoolItemInvokeDynamic cpi, CodeEmitter ilgen, CodeEmitterLocal ok)
		{
			ClassFile.BootstrapMethod bsm = compiler.classFile.GetBootstrapMethod(cpi.BootstrapMethod);
			if (3 + bsm.ArgumentCount > 255)
			{
				ilgen.EmitThrow("java.lang.BootstrapMethodError", "too many bootstrap method arguments");
				return false;
			}
			ClassFile.ConstantPoolItemMethodHandle mh = compiler.classFile.GetConstantPoolConstantMethodHandle(bsm.BootstrapMethodIndex);
			MethodWrapper mw = mh.Member as MethodWrapper;
			switch (mh.Kind)
			{
				case ClassFile.RefKind.invokeStatic:
					if (mw != null && !mw.IsStatic)
						goto default;
					break;
				case ClassFile.RefKind.newInvokeSpecial:
					if (mw != null && !mw.IsConstructor)
						goto default;
					break;
				default:
					// to throw the right exception, we have to resolve the MH constant here
					compiler.context.GetValue<MethodHandleConstant>(bsm.BootstrapMethodIndex).Emit(compiler, ilgen, bsm.BootstrapMethodIndex);
					ilgen.Emit(OpCodes.Pop);
					ilgen.EmitLdc_I4(1);
					ilgen.Emit(OpCodes.Stloc, ok);
					ilgen.EmitThrow("java.lang.invoke.WrongMethodTypeException");
					return false;
			}
			if (mw == null)
			{
				// to throw the right exception (i.e. without wrapping it in a BootstrapMethodError), we have to resolve the MH constant here
				compiler.context.GetValue<MethodHandleConstant>(bsm.BootstrapMethodIndex).Emit(compiler, ilgen, bsm.BootstrapMethodIndex);
				ilgen.Emit(OpCodes.Pop);
				ClassFile.ConstantPoolItemMI cpiMI;
				if ((cpiMI = mh.MemberConstantPoolItem as ClassFile.ConstantPoolItemMI) != null)
				{
					mw = new DynamicBinder().Get(compiler, mh.Kind, cpiMI, false);
				}
				else
				{
					ilgen.EmitLdc_I4(1);
					ilgen.Emit(OpCodes.Stloc, ok);
					ilgen.EmitThrow("java.lang.invoke.WrongMethodTypeException");
					return false;
				}
			}
			TypeWrapper[] parameters = mw.GetParameters();
			int extraArgs = parameters.Length - 3;
			int fixedArgs;
			int varArgs;
			if (extraArgs == 1 && parameters[3].IsArray && parameters[3].ElementTypeWrapper == CoreClasses.java.lang.Object.Wrapper)
			{
				fixedArgs = 0;
				varArgs = bsm.ArgumentCount - fixedArgs;
			}
			else if (extraArgs != bsm.ArgumentCount)
			{
				ilgen.EmitLdc_I4(1);
				ilgen.Emit(OpCodes.Stloc, ok);
				ilgen.EmitThrow("java.lang.invoke.WrongMethodTypeException");
				return false;
			}
			else
			{
				fixedArgs = extraArgs;
				varArgs = -1;
			}
			compiler.context.EmitCallerID(ilgen, compiler.m.IsLambdaFormCompiled);
			methodLookup.EmitCall(ilgen);
			ilgen.Emit(OpCodes.Ldstr, cpi.Name);
			parameters[1].EmitConvStackTypeToSignatureType(ilgen, CoreClasses.java.lang.String.Wrapper);
			if (HasUnloadable(cpi.GetArgTypes(), cpi.GetRetType()))
			{
				// the cache is useless since we only run once, so we use a local
				ilgen.Emit(OpCodes.Ldloca, ilgen.DeclareLocal(CoreClasses.java.lang.invoke.MethodType.Wrapper.TypeAsSignatureType));
				ilgen.Emit(OpCodes.Ldstr, cpi.Signature);
				compiler.context.EmitCallerID(ilgen, compiler.m.IsLambdaFormCompiled);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicLoadMethodType);
			}
			else
			{
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LoadMethodType.MakeGenericMethod(MethodHandleUtil.CreateDelegateTypeForLoadConstant(cpi.GetArgTypes(), cpi.GetRetType())));
			}
			parameters[2].EmitConvStackTypeToSignatureType(ilgen, CoreClasses.java.lang.invoke.MethodType.Wrapper);
			for (int i = 0; i < fixedArgs; i++)
			{
				EmitExtraArg(compiler, ilgen, bsm, i, parameters[i + 3], ok);
			}
			if (varArgs >= 0)
			{
				ilgen.EmitLdc_I4(varArgs);
				TypeWrapper elemType = parameters[parameters.Length - 1].ElementTypeWrapper;
				ilgen.Emit(OpCodes.Newarr, elemType.TypeAsArrayType);
				for (int i = 0; i < varArgs; i++)
				{
					ilgen.Emit(OpCodes.Dup);
					ilgen.EmitLdc_I4(i);
					EmitExtraArg(compiler, ilgen, bsm, i + fixedArgs, elemType, ok);
					ilgen.Emit(OpCodes.Stelem_Ref);
				}
			}
			ilgen.EmitLdc_I4(1);
			ilgen.Emit(OpCodes.Stloc, ok);
			if (mw.IsConstructor)
			{
				mw.EmitNewobj(ilgen);
			}
			else
			{
				mw.EmitCall(ilgen);
			}
			return true;
		}

		private static void EmitExtraArg(Compiler compiler, CodeEmitter ilgen, ClassFile.BootstrapMethod bsm, int index, TypeWrapper targetType, CodeEmitterLocal wrapException)
		{
			int constant = bsm.GetArgument(index);
			compiler.EmitLoadConstant(ilgen, constant);
			TypeWrapper constType;
			switch (compiler.classFile.GetConstantPoolConstantType(constant))
			{
				case ClassFile.ConstantType.Integer:
					constType = PrimitiveTypeWrapper.INT;
					break;
				case ClassFile.ConstantType.Long:
					constType = PrimitiveTypeWrapper.LONG;
					break;
				case ClassFile.ConstantType.Float:
					constType = PrimitiveTypeWrapper.FLOAT;
					break;
				case ClassFile.ConstantType.Double:
					constType = PrimitiveTypeWrapper.DOUBLE;
					break;
				case ClassFile.ConstantType.Class:
					constType = CoreClasses.java.lang.Class.Wrapper;
					break;
				case ClassFile.ConstantType.String:
					constType = CoreClasses.java.lang.String.Wrapper;
					break;
				case ClassFile.ConstantType.MethodHandle:
					constType = CoreClasses.java.lang.invoke.MethodHandle.Wrapper;
					break;
				case ClassFile.ConstantType.MethodType:
					constType = CoreClasses.java.lang.invoke.MethodType.Wrapper;
					break;
				default:
					throw new InvalidOperationException();
			}
			if (constType != targetType)
			{
				ilgen.EmitLdc_I4(1);
				ilgen.Emit(OpCodes.Stloc, wrapException);
				if (constType.IsPrimitive)
				{
					string dummy;
					TypeWrapper wrapper = GetWrapperType(constType, out dummy);
					wrapper.GetMethodWrapper("valueOf", "(" + constType.SigName + ")" + wrapper.SigName, false).EmitCall(ilgen);
				}
				if (targetType.IsUnloadable)
				{
					// do nothing
				}
				else if (targetType.IsPrimitive)
				{
					string unbox;
					TypeWrapper wrapper = GetWrapperType(targetType, out unbox);
					ilgen.Emit(OpCodes.Castclass, wrapper.TypeAsBaseType);
					wrapper.GetMethodWrapper(unbox, "()" + targetType.SigName, false).EmitCallvirt(ilgen);
				}
				else if (!constType.IsAssignableTo(targetType))
				{
					ilgen.Emit(OpCodes.Castclass, targetType.TypeAsBaseType);
				}
				targetType.EmitConvStackTypeToSignatureType(ilgen, targetType);
				ilgen.EmitLdc_I4(0);
				ilgen.Emit(OpCodes.Stloc, wrapException);
			}
		}

		private static TypeWrapper GetWrapperType(TypeWrapper tw, out string unbox)
		{
			if (tw == PrimitiveTypeWrapper.INT)
			{
				unbox = "intValue";
				return ClassLoaderWrapper.LoadClassCritical("java.lang.Integer");
			}
			else if (tw == PrimitiveTypeWrapper.LONG)
			{
				unbox = "longValue";
				return ClassLoaderWrapper.LoadClassCritical("java.lang.Long");
			}
			else if (tw == PrimitiveTypeWrapper.FLOAT)
			{
				unbox = "floatValue";
				return ClassLoaderWrapper.LoadClassCritical("java.lang.Float");
			}
			else if (tw == PrimitiveTypeWrapper.DOUBLE)
			{
				unbox = "doubleValue";
				return ClassLoaderWrapper.LoadClassCritical("java.lang.Double");
			}
			else
			{
				throw new InvalidOperationException();
			}
		}
	}

	private void EmitInvokeDynamic(ClassFile.ConstantPoolItemInvokeDynamic cpi)
	{
		CodeEmitter ilgen = ilGenerator;
		TypeWrapper[] args = cpi.GetArgTypes();
		CodeEmitterLocal[] temps = new CodeEmitterLocal[args.Length];
		for (int i = args.Length - 1; i >= 0; i--)
		{
			temps[i] = ilgen.DeclareLocal(args[i].TypeAsSignatureType);
			ilgen.Emit(OpCodes.Stloc, temps[i]);
		}
		Type delegateType = MethodHandleUtil.CreateMethodHandleDelegateType(args, cpi.GetRetType());
		InvokeDynamicBuilder.Emit(this, cpi, delegateType);
		for (int i = 0; i < args.Length; i++)
		{
			ilgen.Emit(OpCodes.Ldloc, temps[i]);
		}
		MethodHandleUtil.EmitCallDelegateInvokeMethod(ilgen, delegateType);
	}

	private sealed class MethodHandleConstant
	{
		private FieldBuilder field;

		internal void Emit(Compiler compiler, CodeEmitter ilgen, int index)
		{
			if (field == null)
			{
				field = compiler.context.DefineDynamicMethodHandleCacheField();
			}
			ClassFile.ConstantPoolItemMethodHandle mh = compiler.classFile.GetConstantPoolConstantMethodHandle(index);
			ilgen.Emit(OpCodes.Ldsflda, field);
			ilgen.EmitLdc_I4((int)mh.Kind);
			ilgen.Emit(OpCodes.Ldstr, mh.Class);
			ilgen.Emit(OpCodes.Ldstr, mh.Name);
			ilgen.Emit(OpCodes.Ldstr, mh.Signature);
			compiler.context.EmitCallerID(ilgen, compiler.m.IsLambdaFormCompiled);
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicLoadMethodHandle);
		}
	}

	private sealed class MethodTypeConstant
	{
		private FieldBuilder field;
		private bool dynamic;

		internal void Emit(Compiler compiler, CodeEmitter ilgen, int index)
		{
			if (field == null)
			{
				field = CreateField(compiler, index, ref dynamic);
			}
			if (dynamic)
			{
				ilgen.Emit(OpCodes.Ldsflda, field);
				ilgen.Emit(OpCodes.Ldstr, compiler.classFile.GetConstantPoolConstantMethodType(index).Signature);
				compiler.context.EmitCallerID(ilgen, compiler.m.IsLambdaFormCompiled);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicLoadMethodType);
			}
			else
			{
				ilgen.Emit(OpCodes.Ldsfld, field);
			}
		}

		private static FieldBuilder CreateField(Compiler compiler, int index, ref bool dynamic)
		{
			ClassFile.ConstantPoolItemMethodType cpi = compiler.classFile.GetConstantPoolConstantMethodType(index);
			TypeWrapper[] args = cpi.GetArgTypes();
			TypeWrapper ret = cpi.GetRetType();

			if (HasUnloadable(args, ret))
			{
				dynamic = true;
				return compiler.context.DefineDynamicMethodTypeCacheField();
			}
			else
			{
				TypeBuilder tb = compiler.context.DefineMethodTypeConstantType(index);
				FieldBuilder field = tb.DefineField("value", CoreClasses.java.lang.invoke.MethodType.Wrapper.TypeAsSignatureType, FieldAttributes.Assembly | FieldAttributes.Static | FieldAttributes.InitOnly);
				CodeEmitter ilgen = CodeEmitter.Create(ReflectUtil.DefineTypeInitializer(tb, compiler.clazz.GetClassLoader()));
				Type delegateType = MethodHandleUtil.CreateDelegateTypeForLoadConstant(args, ret);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LoadMethodType.MakeGenericMethod(delegateType));
				ilgen.Emit(OpCodes.Stsfld, field);
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
				return field;
			}
		}
	}

	private bool RequiresExplicitClassInit(TypeWrapper tw, int index, InstructionFlags[] flags)
	{
		ClassFile.Method.Instruction[] code = m.Instructions;
		for (; index < code.Length; index++)
		{
			if (code[index].NormalizedOpCode == NormalizedByteCode.__invokespecial)
			{
				ClassFile.ConstantPoolItemMI cpi = classFile.GetMethodref(code[index].Arg1);
				MethodWrapper mw = cpi.GetMethodForInvokespecial();
				return !mw.IsConstructor || mw.DeclaringType != tw;
			}
			if ((flags[index] & InstructionFlags.BranchTarget) != 0
				|| ByteCodeMetaData.IsBranch(code[index].NormalizedOpCode)
				|| ByteCodeMetaData.CanThrowException(code[index].NormalizedOpCode))
			{
				break;
			}
		}
		return true;
	}

	// NOTE despite its name this also handles value type args
	private void CastInterfaceArgs(TypeWrapper declaringType, TypeWrapper[] args, int instructionIndex, bool instanceMethod)
	{
		bool needsCast = false;
		int firstCastArg = -1;

		if(!needsCast)
		{
			for(int i = 0; i < args.Length; i++)
			{
				if(args[i].IsUnloadable)
				{
					// nothing to do, callee will (eventually) do the cast
				}
				else if(args[i].IsGhost)
				{
					needsCast = true;
					firstCastArg = i;
					break;
				}
				else if(args[i].IsInterfaceOrInterfaceArray)
				{
					TypeWrapper tw = ma.GetStackTypeWrapper(instructionIndex, args.Length - 1 - i);
					if(tw.IsUnloadable || NeedsInterfaceDownCast(tw, args[i]))
					{
						needsCast = true;
						firstCastArg = i;
						break;
					}
				}
				else if(args[i].IsNonPrimitiveValueType)
				{
					if(i == 0 && instanceMethod && declaringType != args[i])
					{
						// no cast needed because we're calling an inherited method
					}
					else
					{
						needsCast = true;
						firstCastArg = i;
						break;
					}
				}
				// if the stack contains an unloadable, we might need to cast it
				// (e.g. if the argument type is a base class that is loadable)
				if(ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i).IsUnloadable)
				{
					needsCast = true;
					firstCastArg = i;
					break;
				}
			}
		}

		if(needsCast)
		{
			DupHelper dh = new DupHelper(this, args.Length);
			for(int i = firstCastArg + 1; i < args.Length; i++)
			{
				TypeWrapper tw = ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i);
				if(tw != VerifierTypeWrapper.UninitializedThis
					&& !VerifierTypeWrapper.IsThis(tw))
				{
					tw = args[i];
				}
				dh.SetType(i, tw);
			}
			for(int i = args.Length - 1; i >= firstCastArg; i--)
			{
				if(!args[i].IsUnloadable && !args[i].IsGhost)
				{
					TypeWrapper tw = ma.GetStackTypeWrapper(instructionIndex, args.Length - 1 - i);
					if(tw.IsUnloadable || (args[i].IsInterfaceOrInterfaceArray && NeedsInterfaceDownCast(tw, args[i])))
					{
						ilGenerator.EmitAssertType(args[i].TypeAsTBD);
						Profiler.Count("InterfaceDownCast");
					}
				}
				if(i != firstCastArg)
				{
					dh.Store(i);
				}
			}
			if(instanceMethod && args[0].IsUnloadable && !declaringType.IsUnloadable)
			{
				if(declaringType.IsInterface)
				{
					ilGenerator.EmitAssertType(declaringType.TypeAsTBD);
				}
				else if(declaringType.IsNonPrimitiveValueType)
				{
					ilGenerator.Emit(OpCodes.Unbox, declaringType.TypeAsTBD);
				}
				else
				{
					ilGenerator.Emit(OpCodes.Castclass, declaringType.TypeAsSignatureType);
				}
			}
			for(int i = firstCastArg; i < args.Length; i++)
			{
				if(i != firstCastArg)
				{
					dh.Load(i);
				}
				if(!args[i].IsUnloadable && args[i].IsGhost)
				{
					if(i == 0 && instanceMethod && !declaringType.IsInterface)
					{
						// we're calling a java.lang.Object method through a ghost interface reference,
						// no ghost handling is needed
					}
					else if(VerifierTypeWrapper.IsThis(ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i)))
					{
						// we're an instance method in a ghost interface, so the this pointer is a managed pointer to the
						// wrapper value and if we're not calling another instance method on ourself, we need to load
						// the wrapper value onto the stack
						if(!instanceMethod || i != 0)
						{
							ilGenerator.Emit(OpCodes.Ldobj, args[i].TypeAsSignatureType);
						}
					}
					else
					{
						CodeEmitterLocal ghost = ilGenerator.AllocTempLocal(Types.Object);
						ilGenerator.Emit(OpCodes.Stloc, ghost);
						CodeEmitterLocal local = ilGenerator.AllocTempLocal(args[i].TypeAsSignatureType);
						ilGenerator.Emit(OpCodes.Ldloca, local);
						ilGenerator.Emit(OpCodes.Ldloc, ghost);
						ilGenerator.Emit(OpCodes.Stfld, args[i].GhostRefField);
						ilGenerator.Emit(OpCodes.Ldloca, local);
						ilGenerator.ReleaseTempLocal(local);
						ilGenerator.ReleaseTempLocal(ghost);
						// NOTE when the this argument is a value type, we need the address on the stack instead of the value
						if(i != 0 || !instanceMethod)
						{
							ilGenerator.Emit(OpCodes.Ldobj, args[i].TypeAsSignatureType);
						}
					}
				}
				else
				{
					if(!args[i].IsUnloadable)
					{
						if(args[i].IsNonPrimitiveValueType)
						{
							if(i == 0 && instanceMethod)
							{
								// we only need to unbox if the method was actually declared on the value type
								if(declaringType == args[i])
								{
									ilGenerator.Emit(OpCodes.Unbox, args[i].TypeAsTBD);
								}
							}
							else
							{
								args[i].EmitUnbox(ilGenerator);
							}
						}
						else if(ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i).IsUnloadable)
						{
							ilGenerator.Emit(OpCodes.Castclass, args[i].TypeAsSignatureType);
						}
					}
				}
			}
			dh.Release();
		}
	}

	private bool NeedsInterfaceDownCast(TypeWrapper tw, TypeWrapper arg)
	{
		if (tw == VerifierTypeWrapper.Null)
		{
			return false;
		}
		if (!tw.IsAccessibleFrom(clazz))
		{
			tw = tw.GetPublicBaseTypeWrapper();
		}
		return !tw.IsAssignableTo(arg);
	}

	private void DynamicGetPutField(Instruction instr, int i)
	{
		ClassFile.RefKind kind;
		switch (instr.NormalizedOpCode)
		{
			case NormalizedByteCode.__dynamic_getfield:
				Profiler.Count("EmitDynamicGetfield");
				kind = ClassFile.RefKind.getField;
				break;
			case NormalizedByteCode.__dynamic_putfield:
				Profiler.Count("EmitDynamicPutfield");
				kind = ClassFile.RefKind.putField;
				break;
			case NormalizedByteCode.__dynamic_getstatic:
				Profiler.Count("EmitDynamicGetstatic");
				kind = ClassFile.RefKind.getStatic;
				break;
			case NormalizedByteCode.__dynamic_putstatic:
				Profiler.Count("EmitDynamicPutstatic");
				kind = ClassFile.RefKind.putStatic;
				break;
			default:
				throw new InvalidOperationException();
		}
		ClassFile.ConstantPoolItemFieldref cpi = classFile.GetFieldref(instr.Arg1);
		TypeWrapper fieldType = cpi.GetFieldType();
		if (kind == ClassFile.RefKind.putField || kind == ClassFile.RefKind.putStatic)
		{
			fieldType.EmitConvStackTypeToSignatureType(ilGenerator, ma.GetStackTypeWrapper(i, 0));
			if (strictfp)
			{
				// no need to convert
			}
			else if (fieldType == PrimitiveTypeWrapper.DOUBLE)
			{
				ilGenerator.Emit(OpCodes.Conv_R8);
			}
		}
		context.GetValue<DynamicFieldBinder>(instr.Arg1 | ((byte)kind << 24)).Emit(this, cpi, kind);
		if (kind == ClassFile.RefKind.getField || kind == ClassFile.RefKind.getStatic)
		{
			fieldType.EmitConvSignatureTypeToStackType(ilGenerator);
		}
	}

	private static void EmitReturnTypeConversion(CodeEmitter ilgen, TypeWrapper typeWrapper)
	{
		if(typeWrapper.IsUnloadable)
		{
			// nothing to do for unloadables
		}
		else if(typeWrapper == PrimitiveTypeWrapper.VOID)
		{
			ilgen.Emit(OpCodes.Pop);
		}
		else if(typeWrapper.IsPrimitive)
		{
			// NOTE we don't need to use TypeWrapper.EmitUnbox, because the return value cannot be null
			ilgen.Emit(OpCodes.Unbox, typeWrapper.TypeAsTBD);
			ilgen.Emit(OpCodes.Ldobj, typeWrapper.TypeAsTBD);
			if(typeWrapper == PrimitiveTypeWrapper.BYTE)
			{
				ilgen.Emit(OpCodes.Conv_I1);
			}
		}
		else
		{
			typeWrapper.EmitCheckcast(ilgen);
		}
	}

	internal sealed class MethodHandleMethodWrapper : MethodWrapper
	{
		private readonly Compiler compiler;
		private readonly TypeWrapper wrapper;
		private readonly ClassFile.ConstantPoolItemMI cpi;

		internal MethodHandleMethodWrapper(Compiler compiler, TypeWrapper wrapper, ClassFile.ConstantPoolItemMI cpi)
			: base(CoreClasses.java.lang.invoke.MethodHandle.Wrapper, cpi.Name, cpi.Signature, null, cpi.GetRetType(), cpi.GetArgTypes(), Modifiers.Public, MemberFlags.None)
		{
			this.compiler = compiler;
			this.wrapper = wrapper;
			this.cpi = cpi;
		}

		private static void ToBasic(TypeWrapper tw, CodeEmitter ilgen)
		{
			if (tw.IsNonPrimitiveValueType)
			{
				tw.EmitBox(ilgen);
			}
			else if (tw.IsGhost)
			{
				tw.EmitConvSignatureTypeToStackType(ilgen);
			}
		}

		private static void FromBasic(TypeWrapper tw, CodeEmitter ilgen)
		{
			if (tw.IsNonPrimitiveValueType)
			{
				tw.EmitUnbox(ilgen);
			}
			else if (tw.IsGhost)
			{
				tw.EmitConvStackTypeToSignatureType(ilgen, null);
			}
			else if (!tw.IsPrimitive && tw != CoreClasses.java.lang.Object.Wrapper)
			{
				tw.EmitCheckcast(ilgen);
			}
		}

		internal override void EmitCall(CodeEmitter ilgen)
		{
			Debug.Assert(cpi.Name == "linkToVirtual" || cpi.Name == "linkToStatic" || cpi.Name == "linkToSpecial" || cpi.Name == "linkToInterface");
			EmitLinkToCall(ilgen, cpi.GetArgTypes(), cpi.GetRetType());
		}

		internal static void EmitLinkToCall(CodeEmitter ilgen, TypeWrapper[] args, TypeWrapper retType)
		{
#if !FIRST_PASS && !STATIC_COMPILER
			CodeEmitterLocal[] temps = new CodeEmitterLocal[args.Length];
			for (int i = args.Length - 1; i > 0; i--)
			{
				temps[i] = ilgen.DeclareLocal(MethodHandleUtil.AsBasicType(args[i]));
				ToBasic(args[i], ilgen);
				ilgen.Emit(OpCodes.Stloc, temps[i]);
			}
			temps[0] = ilgen.DeclareLocal(args[0].TypeAsSignatureType);
			ilgen.Emit(OpCodes.Stloc, temps[0]);
			Array.Resize(ref args, args.Length - 1);
			Type delegateType = MethodHandleUtil.CreateMemberWrapperDelegateType(args, retType);
			ilgen.Emit(OpCodes.Ldloc, temps[args.Length]);
			ilgen.Emit(OpCodes.Ldfld, typeof(java.lang.invoke.MemberName).GetField("vmtarget", BindingFlags.Instance | BindingFlags.NonPublic));
			ilgen.Emit(OpCodes.Castclass, delegateType);
			for (int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldloc, temps[i]);
			}
			MethodHandleUtil.EmitCallDelegateInvokeMethod(ilgen, delegateType);
			FromBasic(retType, ilgen);
#else
			throw new InvalidOperationException();
#endif
		}

		private void EmitInvokeExact(CodeEmitter ilgen)
		{
			TypeWrapper[] args = cpi.GetArgTypes();
			CodeEmitterLocal[] temps = new CodeEmitterLocal[args.Length];
			for (int i = args.Length - 1; i >= 0; i--)
			{
				temps[i] = ilgen.DeclareLocal(args[i].TypeAsSignatureType);
				ilgen.Emit(OpCodes.Stloc, temps[i]);
			}
			Type delegateType = MethodHandleUtil.CreateMethodHandleDelegateType(args, cpi.GetRetType());
			if (HasUnloadable(cpi.GetArgTypes(), cpi.GetRetType()))
			{
				// TODO consider sharing the cache for the same signatures
				ilgen.Emit(OpCodes.Ldsflda, compiler.context.DefineDynamicMethodTypeCacheField());
				ilgen.Emit(OpCodes.Ldstr, cpi.Signature);
				compiler.context.EmitCallerID(ilgen, compiler.m.IsLambdaFormCompiled);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicLoadMethodType);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LoadMethodType.MakeGenericMethod(delegateType));
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicEraseInvokeExact);
			}
			MethodInfo mi = ByteCodeHelperMethods.GetDelegateForInvokeExact.MakeGenericMethod(delegateType);
			ilgen.Emit(OpCodes.Call, mi);
			for (int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldloc, temps[i]);
			}
			MethodHandleUtil.EmitCallDelegateInvokeMethod(ilgen, delegateType);
		}

		private void EmitInvokeMaxArity(CodeEmitter ilgen)
		{
			TypeWrapper[] args = cpi.GetArgTypes();
			CodeEmitterLocal[] temps = new CodeEmitterLocal[args.Length];
			for (int i = args.Length - 1; i >= 0; i--)
			{
				temps[i] = ilgen.DeclareLocal(args[i].TypeAsSignatureType);
				ilgen.Emit(OpCodes.Stloc, temps[i]);
			}
			Type delegateType = MethodHandleUtil.CreateMethodHandleDelegateType(args, cpi.GetRetType());
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LoadMethodType.MakeGenericMethod(delegateType));
			CoreClasses.java.lang.invoke.MethodHandle.Wrapper.GetMethodWrapper("asType", "(Ljava.lang.invoke.MethodType;)Ljava.lang.invoke.MethodHandle;", false).EmitCallvirt(ilgen);
			MethodInfo mi = ByteCodeHelperMethods.GetDelegateForInvokeExact.MakeGenericMethod(delegateType);
			ilgen.Emit(OpCodes.Call, mi);
			for (int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldloc, temps[i]);
			}
			MethodHandleUtil.EmitCallDelegateInvokeMethod(ilgen, delegateType);
		}

		private void EmitInvoke(CodeEmitter ilgen)
		{
			if (cpi.GetArgTypes().Length >= 127 && MethodHandleUtil.SlotCount(cpi.GetArgTypes()) >= 254)
			{
				EmitInvokeMaxArity(ilgen);
				return;
			}
			TypeWrapper[] args = ArrayUtil.Concat(CoreClasses.java.lang.invoke.MethodHandle.Wrapper, cpi.GetArgTypes());
			CodeEmitterLocal[] temps = new CodeEmitterLocal[args.Length];
			for (int i = args.Length - 1; i >= 0; i--)
			{
				temps[i] = ilgen.DeclareLocal(args[i].TypeAsSignatureType);
				ilgen.Emit(OpCodes.Stloc, temps[i]);
			}
			Type delegateType = MethodHandleUtil.CreateMethodHandleDelegateType(args, cpi.GetRetType());
			MethodInfo mi = ByteCodeHelperMethods.GetDelegateForInvoke.MakeGenericMethod(delegateType);
			Type typeofInvokeCache;
#if STATIC_COMPILER
			typeofInvokeCache = StaticCompiler.GetRuntimeType("IKVM.Runtime.InvokeCache`1");
#else
			typeofInvokeCache = typeof(IKVM.Runtime.InvokeCache<>);
#endif
			FieldBuilder fb = compiler.context.DefineMethodHandleInvokeCacheField(typeofInvokeCache.MakeGenericType(delegateType));
			ilgen.Emit(OpCodes.Ldloc, temps[0]);
			if (HasUnloadable(cpi.GetArgTypes(), cpi.GetRetType()))
			{
				// TODO consider sharing the cache for the same signatures
				ilgen.Emit(OpCodes.Ldsflda, compiler.context.DefineDynamicMethodTypeCacheField());
				ilgen.Emit(OpCodes.Ldstr, cpi.Signature);
				compiler.context.EmitCallerID(ilgen, compiler.m.IsLambdaFormCompiled);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicLoadMethodType);
			}
			else
			{
				ilgen.Emit(OpCodes.Ldnull);
			}
			ilgen.Emit(OpCodes.Ldsflda, fb);
			ilgen.Emit(OpCodes.Call, mi);
			for (int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldloc, temps[i]);
			}
			MethodHandleUtil.EmitCallDelegateInvokeMethod(ilgen, delegateType);
		}

		private void EmitInvokeBasic(CodeEmitter ilgen)
		{
			TypeWrapper retType = cpi.GetRetType();
			EmitInvokeBasic(ilgen, cpi.GetArgTypes(), retType, true);
			FromBasic(retType, ilgen);
		}

		internal static void EmitInvokeBasic(CodeEmitter ilgen, TypeWrapper[] args, TypeWrapper retType, bool toBasic)
		{
			args = ArrayUtil.Concat(CoreClasses.java.lang.invoke.MethodHandle.Wrapper, args);
			CodeEmitterLocal[] temps = new CodeEmitterLocal[args.Length];
			for (int i = args.Length - 1; i > 0; i--)
			{
				temps[i] = ilgen.DeclareLocal(MethodHandleUtil.AsBasicType(args[i]));
				if (toBasic)
				{
					ToBasic(args[i], ilgen);
				}
				ilgen.Emit(OpCodes.Stloc, temps[i]);
			}
			temps[0] = ilgen.DeclareLocal(args[0].TypeAsSignatureType);
			ilgen.Emit(OpCodes.Stloc, temps[0]);
			Type delegateType = MethodHandleUtil.CreateMemberWrapperDelegateType(args, retType);
			MethodInfo mi = ByteCodeHelperMethods.GetDelegateForInvokeBasic.MakeGenericMethod(delegateType);
			ilgen.Emit(OpCodes.Ldloc, temps[0]);
			ilgen.Emit(OpCodes.Call, mi);
			for (int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldloc, temps[i]);
			}
			MethodHandleUtil.EmitCallDelegateInvokeMethod(ilgen, delegateType);
		}

		internal override void EmitCallvirt(CodeEmitter ilgen)
		{
			switch (cpi.Name)
			{
				case "invokeExact":
					EmitInvokeExact(ilgen);
					break;
				case "invoke":
					EmitInvoke(ilgen);
					break;
				case "invokeBasic":
					EmitInvokeBasic(ilgen);
					break;
				default:
					throw new InvalidOperationException();
			}
		}

		internal override void EmitNewobj(CodeEmitter ilgen)
		{
			throw new InvalidOperationException();
		}
	}

	private sealed class DynamicFieldBinder
	{
		private MethodInfo method;

		internal void Emit(Compiler compiler, ClassFile.ConstantPoolItemFieldref cpi, ClassFile.RefKind kind)
		{
			if (method == null)
			{
				method = CreateMethod(compiler, cpi, kind);
			}
			compiler.ilGenerator.Emit(OpCodes.Call, method);
		}

		private static MethodInfo CreateMethod(Compiler compiler, ClassFile.ConstantPoolItemFieldref cpi, ClassFile.RefKind kind)
		{
			TypeWrapper ret;
			TypeWrapper[] args;
			switch (kind)
			{
				case ClassFile.RefKind.getField:
					ret = cpi.GetFieldType();
					args = new TypeWrapper[] { cpi.GetClassType() };
					break;
				case ClassFile.RefKind.getStatic:
					ret = cpi.GetFieldType();
					args = TypeWrapper.EmptyArray;
					break;
				case ClassFile.RefKind.putField:
					ret = PrimitiveTypeWrapper.VOID;
					args = new TypeWrapper[] { cpi.GetClassType(), cpi.GetFieldType() };
					break;
				case ClassFile.RefKind.putStatic:
					ret = PrimitiveTypeWrapper.VOID;
					args = new TypeWrapper[] { cpi.GetFieldType() };
					break;
				default:
					throw new InvalidOperationException();
			}
			return DynamicBinder.Emit(compiler, kind, cpi, ret, args, false);
		}
	}

	private sealed class DynamicBinder
	{
		private MethodWrapper mw;

		internal MethodWrapper Get(Compiler compiler, ClassFile.RefKind kind, ClassFile.ConstantPoolItemMI cpi, bool privileged)
		{
			return mw ?? (mw = new DynamicBinderMethodWrapper(cpi, Emit(compiler, kind, cpi, privileged), kind));
		}

		private static MethodInfo Emit(Compiler compiler, ClassFile.RefKind kind, ClassFile.ConstantPoolItemMI cpi, bool privileged)
		{
			TypeWrapper ret;
			TypeWrapper[] args;
			if (kind == ClassFile.RefKind.invokeStatic)
			{
				ret = cpi.GetRetType();
				args = cpi.GetArgTypes();
			}
			else if (kind == ClassFile.RefKind.newInvokeSpecial)
			{
				ret = cpi.GetClassType();
				args = cpi.GetArgTypes();
			}
			else
			{
				ret = cpi.GetRetType();
				args = ArrayUtil.Concat(cpi.GetClassType(), cpi.GetArgTypes());
			}
			return Emit(compiler, kind, cpi, ret, args, privileged);
		}

		internal static MethodInfo Emit(Compiler compiler, ClassFile.RefKind kind, ClassFile.ConstantPoolItemFMI cpi, TypeWrapper ret, TypeWrapper[] args, bool privileged)
		{
			bool ghostTarget = (kind == ClassFile.RefKind.invokeSpecial || kind == ClassFile.RefKind.invokeVirtual || kind == ClassFile.RefKind.invokeInterface) && args[0].IsGhost;
			Type delegateType = MethodHandleUtil.CreateMethodHandleDelegateType(args, ret);
			FieldBuilder fb = compiler.context.DefineMethodHandleInvokeCacheField(delegateType);
			Type[] types = new Type[args.Length];
			for (int i = 0; i < types.Length; i++)
			{
				types[i] = args[i].TypeAsSignatureType;
			}
			if (ghostTarget)
			{
				types[0] = types[0].MakeByRefType();
			}
			MethodBuilder mb = compiler.context.DefineMethodHandleDispatchStub(ret.TypeAsSignatureType, types);
			CodeEmitter ilgen = CodeEmitter.Create(mb);
			ilgen.Emit(OpCodes.Ldsfld, fb);
			CodeEmitterLabel label = ilgen.DefineLabel();
			ilgen.EmitBrtrue(label);
			ilgen.EmitLdc_I4((int)kind);
			ilgen.Emit(OpCodes.Ldstr, cpi.Class);
			ilgen.Emit(OpCodes.Ldstr, cpi.Name);
			ilgen.Emit(OpCodes.Ldstr, cpi.Signature);
			if (privileged)
			{
				compiler.context.EmitHostCallerID(ilgen);
			}
			else
			{
				compiler.context.EmitCallerID(ilgen, compiler.m.IsLambdaFormCompiled);
			}
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicBinderMemberLookup.MakeGenericMethod(delegateType));
			ilgen.Emit(OpCodes.Volatile);
			ilgen.Emit(OpCodes.Stsfld, fb);
			ilgen.MarkLabel(label);
			ilgen.Emit(OpCodes.Ldsfld, fb);
			for (int i = 0; i < args.Length; i++)
			{
				ilgen.EmitLdarg(i);
				if (i == 0 && ghostTarget)
				{
					ilgen.Emit(OpCodes.Ldobj, args[0].TypeAsSignatureType);
				}
			}
			MethodHandleUtil.EmitCallDelegateInvokeMethod(ilgen, delegateType);
			ilgen.Emit(OpCodes.Ret);
			ilgen.DoEmit();
			return mb;
		}

		private sealed class DynamicBinderMethodWrapper : MethodWrapper
		{
			private readonly MethodInfo method;

			internal DynamicBinderMethodWrapper(ClassFile.ConstantPoolItemMI cpi, MethodInfo method, ClassFile.RefKind kind)
				: base(cpi.GetClassType(), cpi.Name, cpi.Signature, null, cpi.GetRetType(), cpi.GetArgTypes(), kind == ClassFile.RefKind.invokeStatic ? Modifiers.Public | Modifiers.Static : Modifiers.Public, MemberFlags.None)
			{
				this.method = method;
			}

			internal override void EmitCall(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Call, method);
			}

			internal override void EmitCallvirt(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Call, method);
			}

			internal override void EmitNewobj(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Call, method);
			}
		}
	}

	private MethodWrapper GetMethodCallEmitter(NormalizedByteCode invoke, int constantPoolIndex)
	{
		ClassFile.ConstantPoolItemMI cpi = classFile.GetMethodref(constantPoolIndex);
#if STATIC_COMPILER
		if(replacedMethodWrappers != null)
		{
			for(int i = 0; i < replacedMethodWrappers.Length; i++)
			{
				if(replacedMethodWrappers[i].DeclaringType == cpi.GetClassType()
					&& replacedMethodWrappers[i].Name == cpi.Name
					&& replacedMethodWrappers[i].Signature == cpi.Signature)
				{
					MethodWrapper rmw = replacedMethodWrappers[i];
					rmw.Link();
					return rmw;
				}
			}
		}
#endif
		MethodWrapper mw = null;
		switch (invoke)
		{
			case NormalizedByteCode.__invokespecial:
				mw = cpi.GetMethodForInvokespecial();
				break;
			case NormalizedByteCode.__invokeinterface:
				mw = cpi.GetMethod();
				break;
			case NormalizedByteCode.__invokestatic:
			case NormalizedByteCode.__invokevirtual:
				mw = cpi.GetMethod();
				break;
			case NormalizedByteCode.__dynamic_invokeinterface:
			case NormalizedByteCode.__dynamic_invokestatic:
			case NormalizedByteCode.__dynamic_invokevirtual:
			case NormalizedByteCode.__dynamic_invokespecial:
			case NormalizedByteCode.__privileged_invokestatic:
			case NormalizedByteCode.__privileged_invokevirtual:
			case NormalizedByteCode.__privileged_invokespecial:
				return GetDynamicMethodWrapper(constantPoolIndex, invoke, cpi);
			case NormalizedByteCode.__methodhandle_invoke:
			case NormalizedByteCode.__methodhandle_link:
				return new MethodHandleMethodWrapper(this, clazz, cpi);
			default:
				throw new InvalidOperationException();
		}
		if(mw.IsDynamicOnly)
		{
			return GetDynamicMethodWrapper(constantPoolIndex, invoke, cpi);
		}
		return mw;
	}

	private MethodWrapper GetDynamicMethodWrapper(int index, NormalizedByteCode invoke, ClassFile.ConstantPoolItemMI cpi)
	{
		ClassFile.RefKind kind;
		switch (invoke)
		{
			case NormalizedByteCode.__invokeinterface:
			case NormalizedByteCode.__dynamic_invokeinterface:
				kind = ClassFile.RefKind.invokeInterface;
				break;
			case NormalizedByteCode.__invokestatic:
			case NormalizedByteCode.__dynamic_invokestatic:
			case NormalizedByteCode.__privileged_invokestatic:
				kind = ClassFile.RefKind.invokeStatic;
				break;
			case NormalizedByteCode.__invokevirtual:
			case NormalizedByteCode.__dynamic_invokevirtual:
			case NormalizedByteCode.__privileged_invokevirtual:
				kind = ClassFile.RefKind.invokeVirtual;
				break;
			case NormalizedByteCode.__invokespecial:
			case NormalizedByteCode.__dynamic_invokespecial:
				kind = ClassFile.RefKind.newInvokeSpecial;
				break;
			case NormalizedByteCode.__privileged_invokespecial:
				// we don't support calling a base class constructor
				kind = cpi.GetMethod().IsConstructor
					? ClassFile.RefKind.newInvokeSpecial
					: ClassFile.RefKind.invokeSpecial;
				break;
			default:
				throw new InvalidOperationException();
		}
		bool privileged;
		switch (invoke)
		{
			case NormalizedByteCode.__privileged_invokestatic:
			case NormalizedByteCode.__privileged_invokevirtual:
			case NormalizedByteCode.__privileged_invokespecial:
				privileged = true;
				break;
			default:
				privileged = false;
				break;
		}
		return context.GetValue<DynamicBinder>(index | ((byte)kind << 24)).Get(this, kind, cpi, privileged);
	}

	private TypeWrapper ComputeThisType(TypeWrapper type, MethodWrapper method, NormalizedByteCode invoke)
	{
		if(type == VerifierTypeWrapper.UninitializedThis
			|| VerifierTypeWrapper.IsThis(type))
		{
			return clazz;
		}
		else if(VerifierTypeWrapper.IsNew(type))
		{
			return ((VerifierTypeWrapper)type).UnderlyingType;
		}
		else if(type == VerifierTypeWrapper.Null)
		{
			return method.DeclaringType;
		}
		else if(invoke == NormalizedByteCode.__invokevirtual && method.IsProtected && type.IsUnloadable)
		{
			return clazz;
		}
		else
		{
			return type;
		}
	}

	private LocalVar LoadLocal(int instructionIndex)
	{
		LocalVar v = localVars.GetLocalVar(instructionIndex);
		if(v.isArg)
		{
			ClassFile.Method.Instruction instr = m.Instructions[instructionIndex];
			int i = m.ArgMap[instr.NormalizedArg1];
			ilGenerator.EmitLdarg(i);
			if(v.type == PrimitiveTypeWrapper.DOUBLE)
			{
				ilGenerator.Emit(OpCodes.Conv_R8);
			}
			if(v.type == PrimitiveTypeWrapper.FLOAT)
			{
				ilGenerator.Emit(OpCodes.Conv_R4);
			}
		}
		else if(v.type == VerifierTypeWrapper.Null)
		{
			ilGenerator.Emit(OpCodes.Ldnull);
		}
		else
		{
			if(v.builder == null)
			{
				v.builder = ilGenerator.DeclareLocal(GetLocalBuilderType(v.type));
				if(debug && v.name != null)
				{
					v.builder.SetLocalSymInfo(v.name);
				}
			}
			ilGenerator.Emit(OpCodes.Ldloc, v.builder);
		}
		return v;
	}

	private LocalVar StoreLocal(int instructionIndex)
	{
		LocalVar v = localVars.GetLocalVar(instructionIndex);
		if(v == null)
		{
			// dead store
			ilGenerator.Emit(OpCodes.Pop);
		}
		else if(v.isArg)
		{
			ClassFile.Method.Instruction instr = m.Instructions[instructionIndex];
			int i = m.ArgMap[instr.NormalizedArg1];
			ilGenerator.EmitStarg(i);
		}
		else if(v.type == VerifierTypeWrapper.Null)
		{
			ilGenerator.Emit(OpCodes.Pop);
		}
		else
		{
			if(v.builder == null)
			{
				v.builder = ilGenerator.DeclareLocal(GetLocalBuilderType(v.type));
				if(debug && v.name != null)
				{
					v.builder.SetLocalSymInfo(v.name);
				}
			}
			ilGenerator.Emit(OpCodes.Stloc, v.builder);
		}
		return v;
	}

	private Type GetLocalBuilderType(TypeWrapper tw)
	{
		if (tw.IsUnloadable)
		{
			return Types.Object;
		}
		else if (tw.IsAccessibleFrom(clazz))
		{
			return tw.TypeAsLocalOrStackType;
		}
		else
		{
			return tw.GetPublicBaseTypeWrapper().TypeAsLocalOrStackType;
		}
	}

	private ExceptionTableEntry[] GetExceptionTableFor(InstructionFlags[] flags)
	{
		List<ExceptionTableEntry> list = new List<ExceptionTableEntry>();
		// return only reachable exception handlers (because the code gen depends on that)
		for (int i = 0; i < exceptions.Length; i++)
		{
			// if the first instruction is unreachable, the entire block is unreachable,
			// because you can't jump into a block (we've just split the blocks to ensure that)
			if ((flags[exceptions[i].startIndex] & InstructionFlags.Reachable) != 0)
			{
				list.Add(exceptions[i]);
			}
		}
		return list.ToArray();
	}

	private InstructionFlags[] ComputePartialReachability(int initialInstructionIndex, bool skipFaultBlocks)
	{
		return MethodAnalyzer.ComputePartialReachability(ma, m.Instructions, exceptions, initialInstructionIndex, skipFaultBlocks);
	}
}
@


1.263
log
@Added MethodWrapper.IsFinalizeOrClone property to centralize the logic to detect these two special cased methods.
@
text
@d270 1
a270 1
	private static readonly MethodInfo unmapExceptionMethod;
d3607 1
a3607 1
	private sealed class MethodHandleMethodWrapper : MethodWrapper
a3650 1
#if !FIRST_PASS && !STATIC_COMPILER
d3652 2
d3655 3
a3657 1
			TypeWrapper[] args = cpi.GetArgTypes();
d3668 1
a3668 1
			Type delegateType = MethodHandleUtil.CreateMemberWrapperDelegateType(args, cpi.GetRetType());
d3677 1
a3677 1
			FromBasic(ReturnType, ilgen);
d3780 8
a3787 1
			TypeWrapper[] args = ArrayUtil.Concat(CoreClasses.java.lang.invoke.MethodHandle.Wrapper, cpi.GetArgTypes());
d3792 4
a3795 1
				ToBasic(args[i], ilgen);
d3800 1
a3800 1
			Type delegateType = MethodHandleUtil.CreateMemberWrapperDelegateType(args, cpi.GetRetType());
a3808 1
			FromBasic(ReturnType, ilgen);
@


1.262
log
@Bug fix. Handle invocation of method on unloadable value type.
@
text
@d1502 1
a1502 1
					if(method.IsProtected && (method.DeclaringType == CoreClasses.java.lang.Object.Wrapper || method.DeclaringType == CoreClasses.java.lang.Throwable.Wrapper))
@


1.261
log
@Bug fix. Handle unloadable type in MH.invoke() signature.
@
text
@d3443 4
@


1.260
log
@Bug fix. Handle unloadable type in BSM extra arguments.
@
text
@d3750 12
@


1.259
log
@Changed dynamic CallerID implementation to use only immutable CallerID objects. If a CallerID is passed along downstream, it should not start returning a different caller. Also simplified host caller id.
@
text
@d3193 5
a3197 1
				if (targetType.IsPrimitive)
@


1.258
log
@Bug fix. Handle late-bound MethodHandle.invokeExact() with unloadable type in signature.
@
text
@d71 1
d120 1
@


1.257
log
@Bug fix. Allow invokedynamic with unloadable type in signature.
@
text
@d72 1
d120 1
d3599 1
a3599 1
		private readonly DynamicTypeWrapper.FinishContext context;
d3603 1
a3603 1
		internal MethodHandleMethodWrapper(DynamicTypeWrapper.FinishContext context, TypeWrapper wrapper, ClassFile.ConstantPoolItemMI cpi)
d3606 1
a3606 1
			this.context = context;
d3680 10
d3742 1
a3742 1
			FieldBuilder fb = context.DefineMethodHandleInvokeCacheField(typeofInvokeCache.MakeGenericType(delegateType));
d3993 1
a3993 1
				return new MethodHandleMethodWrapper(context, clazz, cpi);
@


1.256
log
@Bug fix. When catching a dynamically loaded .NET exception type the exception should not be remapped.
@
text
@d71 1
d118 1
d3008 10
a3017 1
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LinkIndyCallSite.MakeGenericMethod(delegateType));
d3102 12
a3113 1
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LoadMethodType.MakeGenericMethod(MethodHandleUtil.CreateDelegateTypeForLoadConstant(cpi.GetArgTypes(), cpi.GetRetType())));
@


1.255
log
@Clean up. Moved special TypeWrapper caching to CoreClasses.
@
text
@d70 1
d116 1
d1158 10
a1167 1
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.mapException.MakeGenericMethod(excType));
a1171 5
						if(exceptionTypeWrapper.IsUnloadable)
						{
							Profiler.Count("EmitDynamicExceptionHandler");
							EmitDynamicInstanceOf(exceptionTypeWrapper);
						}
@


1.254
log
@Bug fix. MethodHandle should be the declaring type of the special MethodHandle methods.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2014 Jeroen Frijters
a269 5
	private static readonly TypeWrapper java_lang_Object;
	private static readonly TypeWrapper java_lang_Class;
	private static readonly TypeWrapper java_lang_Throwable;
	private static readonly TypeWrapper cli_System_Object;
	private static readonly TypeWrapper cli_System_Exception;
a295 5
		java_lang_Object = CoreClasses.java.lang.Object.Wrapper;
		java_lang_Throwable = CoreClasses.java.lang.Throwable.Wrapper;
		cli_System_Object = DotNetTypeWrapper.GetWrapperFromDotNetType(Types.Object);
		cli_System_Exception = DotNetTypeWrapper.GetWrapperFromDotNetType(Types.Exception);
		java_lang_Class = CoreClasses.java.lang.Class.Wrapper;
d297 1
a297 1
		if(java_lang_Throwable.TypeAsBaseType is TypeBuilder)
d300 1
a300 1
			mw = java_lang_Throwable.GetMethodWrapper("__<suppressFillInStackTrace>", "()V", false);
d303 1
a303 1
			mw = java_lang_Throwable.GetMethodWrapper("__<unmap>", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false);
d306 1
a306 1
			mw = java_lang_Throwable.GetMethodWrapper("__<fixate>", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false);
d312 3
a314 3
			suppressFillInStackTraceMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<suppressFillInStackTrace>", Type.EmptyTypes);
			unmapExceptionMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<unmap>", new Type[] { Types.Exception });
			fixateExceptionMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<fixate>", new Type[] { Types.Exception });
d335 1
a335 1
			keepAlive = finalize != null && finalize.DeclaringType != java_lang_Object && finalize.DeclaringType != cli_System_Object && finalize.DeclaringType != java_lang_Throwable && finalize.DeclaringType != cli_System_Exception;
d1114 1
a1114 1
						exceptionTypeWrapper = java_lang_Throwable;
d1120 1
a1120 1
						remap = exceptionTypeWrapper.IsUnloadable || !exceptionTypeWrapper.IsSubTypeOf(cli_System_Exception);
d1148 1
a1148 1
					else if(exceptionTypeWrapper == java_lang_Throwable)
d1490 1
a1490 1
					if(method.IsProtected && (method.DeclaringType == java_lang_Object || method.DeclaringType == java_lang_Throwable))
d1494 1
a1494 1
						if(thisType.IsAssignableTo(cli_System_Object))
d1496 1
a1496 1
							method = cli_System_Object.GetMethodWrapper(method.Name, method.Signature, true);
d1498 1
a1498 1
						else if(thisType.IsAssignableTo(cli_System_Exception))
d1500 1
a1500 1
							method = cli_System_Exception.GetMethodWrapper(method.Name, method.Signature, true);
d1502 1
a1502 1
						else if(thisType.IsAssignableTo(java_lang_Throwable))
d1504 1
a1504 1
							method = java_lang_Throwable.GetMethodWrapper(method.Name, method.Signature, true);
d1566 1
a1566 1
							if(!thisType.IsUnloadable && thisType.IsSubTypeOf(java_lang_Throwable))
d1578 1
a1578 1
									if(thisType.GetMethodWrapper("fillInStackTrace", "()Ljava.lang.Throwable;", true).DeclaringType == java_lang_Throwable)
d1589 1
a1589 1
							if(!thisType.IsUnloadable && thisType.IsSubTypeOf(cli_System_Exception))
@


1.253
log
@Bug fix. Don't try to get constructor on generic instantiation containing a TypeBuilder generic parameter.
@
text
@d3584 1
a3584 1
			: base(wrapper, cpi.Name, cpi.Signature, null, cpi.GetRetType(), cpi.GetArgTypes(), Modifiers.Public, MemberFlags.None)
@


1.252
log
@Use the same nested type for lambdas that are created with an invokedynamic to the same constant pool item (so that deserialization uses the same class as the original).
@
text
@d199 1
a199 1
		ilgen.Emit(OpCodes.Newobj, type.GetConstructors()[0]);
d216 6
a221 1
		if (ReflectUtil.ContainsTypeBuilder(delegateType))
d223 1
a223 1
			return TypeBuilder.GetConstructor(delegateType, delegateType.GetGenericTypeDefinition().GetConstructors()[0]);
d227 1
a227 1
			return delegateType.GetConstructors()[0];
@


1.251
log
@Added intrinsic for LambdaMetafactory.metafactory().
@
text
@d1437 5
a1441 2
					EmitInvokeDynamic(cpi);
					EmitReturnTypeConversion(cpi.GetRetType());
a3213 5
		if (LambdaMetafactory.Emit(context, classFile, cpi, ilGenerator))
		{
			// we intrinsified the lambda factory
			return;
		}
@


1.250
log
@Bug fix. If an invokedynamic bootstrap argument conversion fails, the exception should not be wrapped in BootstrapMethodError.
@
text
@d3211 5
@


1.249
log
@Privileged invokespecial (from anonymous class to host class) should not go through invokespecial stub.
@
text
@d3091 1
a3091 1
				EmitExtraArg(compiler, ilgen, bsm, i, parameters[i + 3]);
d3102 1
a3102 1
					EmitExtraArg(compiler, ilgen, bsm, i + fixedArgs, elemType);
d3119 1
a3119 1
		private static void EmitExtraArg(Compiler compiler, CodeEmitter ilgen, ClassFile.BootstrapMethod bsm, int index, TypeWrapper targetType)
d3155 2
d3175 2
@


1.248
log
@Updated ldc <methodhandle> error behavior to match Java 8.
@
text
@d1712 4
@


1.247
log
@Improved handling of incorrect bootstrap methods.
@
text
@a2744 8
						case HardError.NoSuchFieldException:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchFieldException");
							wrapIncompatibleClassChangeError = true;
							break;
						case HardError.NoSuchMethodException:
							exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchMethodException");
							wrapIncompatibleClassChangeError = true;
							break;
@


1.246
log
@Bug fix. Invokedynamic bootstrap method can also be a constructor.
@
text
@d3029 1
a3029 2
			ClassFile.ConstantPoolItemMI cpiMI;
			if (mw == null && (cpiMI = mh.MemberConstantPoolItem as ClassFile.ConstantPoolItemMI) != null)
d3031 34
a3064 8
				mw = new DynamicBinder().Get(compiler, mh.Kind, cpiMI, false);
			}
			if (mw == null || (!mw.IsStatic && !mw.IsConstructor))
			{
				ilgen.EmitLdc_I4(1);
				ilgen.Emit(OpCodes.Stloc, ok);
				ilgen.EmitThrow("java.lang.invoke.WrongMethodTypeException");
				return false;
@


1.245
log
@Bug fix. Handle >8 parameters in invokedynamic.
@
text
@d3032 1
a3032 1
				mw = new DynamicBinder().Get(compiler, ClassFile.RefKind.invokeStatic, cpiMI, false);
d3034 1
a3034 1
			if (mw == null || !mw.IsStatic)
d3087 8
a3094 1
			mw.EmitCall(ilgen);
@


1.244
log
@Bug fix. Exceptions in bootstrap method arguments should not be wrapped in BootstrapMethodError.
@
text
@d2970 2
a2971 3
			TypeWrapper[] args = cpi.GetArgTypes();
			Type[] argTypes = new Type[args.Length];
			for (int i = 0; i < args.Length; i++)
d2973 6
a2978 1
				argTypes[i] = args[i].TypeAsSignatureType;
d2980 1
a2980 1
			MethodBuilder mb = tb.DefineMethod("BootstrapStub", MethodAttributes.Static | MethodAttributes.PrivateScope, cpi.GetRetType().TypeAsSignatureType, argTypes);
d3013 1
a3013 1
			MethodHandleUtil.EmitCallDelegateInvokeMethod(ilgen, delegateType);
@


1.243
log
@Compiled lambda form methods must use a dynamic caller id.
@
text
@d2980 1
d2983 1
a2983 1
			if (EmitCallBootstrapMethod(compiler, cpi, ilgen))
d2991 5
d2997 2
a2998 1
			ilgen.BeginFinallyBlock();
a3002 3
			ilgen.Emit(OpCodes.Endfinally);
			ilgen.EndExceptionBlock();
			ilgen.MarkLabel(label);
d3015 1
a3015 1
		private static bool EmitCallBootstrapMethod(Compiler compiler, ClassFile.ConstantPoolItemInvokeDynamic cpi, CodeEmitter ilgen)
d3032 2
d3048 2
d3081 2
@


1.242
log
@Fixed regression in previous commit.
@
text
@d1457 1
a1457 1
						context.EmitCallerID(ilGenerator);
d1698 1
a1698 1
							context.EmitCallerID(ilGenerator);
d2892 1
a2892 1
		context.EmitDynamicClassLiteral(ilGenerator, tw);
d2900 1
a2900 1
			context.EmitDynamicClassLiteral(ilgen, tw);
d3024 1
a3024 1
				mw = new DynamicBinder().Get(compiler.context, ClassFile.RefKind.invokeStatic, cpiMI, false);
d3050 1
a3050 1
			compiler.context.EmitCallerID(ilgen);
d3198 1
a3198 1
			compiler.context.EmitCallerID(ilgen);
d3218 1
a3218 1
				compiler.context.EmitCallerID(ilgen);
d3725 1
a3725 1
				method = CreateMethod(compiler.context, cpi, kind);
d3730 1
a3730 1
		private static MethodInfo CreateMethod(DynamicTypeWrapper.FinishContext context, ClassFile.ConstantPoolItemFieldref cpi, ClassFile.RefKind kind)
d3755 1
a3755 1
			return DynamicBinder.Emit(context, kind, cpi, ret, args, false);
d3763 1
a3763 1
		internal MethodWrapper Get(DynamicTypeWrapper.FinishContext context, ClassFile.RefKind kind, ClassFile.ConstantPoolItemMI cpi, bool privileged)
d3765 1
a3765 1
			return mw ?? (mw = new DynamicBinderMethodWrapper(cpi, Emit(context, kind, cpi, privileged), kind));
d3768 1
a3768 1
		private static MethodInfo Emit(DynamicTypeWrapper.FinishContext context, ClassFile.RefKind kind, ClassFile.ConstantPoolItemMI cpi, bool privileged)
d3787 1
a3787 1
			return Emit(context, kind, cpi, ret, args, privileged);
d3790 1
a3790 1
		internal static MethodInfo Emit(DynamicTypeWrapper.FinishContext context, ClassFile.RefKind kind, ClassFile.ConstantPoolItemFMI cpi, TypeWrapper ret, TypeWrapper[] args, bool privileged)
d3794 1
a3794 1
			FieldBuilder fb = context.DefineMethodHandleInvokeCacheField(delegateType);
d3804 1
a3804 1
			MethodBuilder mb = context.DefineMethodHandleDispatchStub(ret.TypeAsSignatureType, types);
d3815 1
a3815 1
				context.EmitHostCallerID(ilgen);
d3819 1
a3819 1
				context.EmitCallerID(ilgen);
d3964 1
a3964 1
		return context.GetValue<DynamicBinder>(index | ((byte)kind << 24)).Get(context, kind, cpi, privileged);
@


1.241
log
@Added EmitDynamicClassLiteral() helper to Compiler.
@
text
@d2900 1
a2900 1
			EmitDynamicClassLiteral(tw);
@


1.240
log
@Handle the this pointer for ghost value type instance methods.
@
text
@d346 11
a417 1
		TypeWrapper[] args = mw.GetParameters();
a757 10
		TypeWrapper[] args = mw.GetParameters();
		for(int i = 0; i < args.Length; i++)
		{
			if(args[i].IsUnloadable)
			{
				ilGenerator.EmitLdarg(i + (m.IsStatic ? 0 : 1));
				EmitDynamicCast(context, ilGenerator, args[i]);
				ilGenerator.Emit(OpCodes.Pop);
			}
		}
d1909 1
a1909 1
						context.EmitDynamicClassLiteral(ilGenerator, wrapper);
d1940 1
a1940 1
						context.EmitDynamicClassLiteral(ilGenerator, wrapper);
d1971 1
a1971 1
						context.EmitDynamicClassLiteral(ilGenerator, wrapper);
d2037 1
a2037 1
						EmitDynamicCast(context, ilGenerator, wrapper);
d2861 1
a2861 1
	private static void EmitDynamicCast(DynamicTypeWrapper.FinishContext context, CodeEmitter ilGenerator, TypeWrapper tw)
d2869 1
a2869 1
		context.EmitDynamicClassLiteral(ilGenerator, tw);
d2885 1
a2885 1
		context.EmitDynamicClassLiteral(ilGenerator, tw);
d2890 5
d2900 1
a2900 1
			context.EmitDynamicClassLiteral(ilgen, tw);
@


1.239
log
@Don't meddle with the this parameter when type converting the parameters.
@
text
@d3376 10
@


1.238
log
@Support calling ghost interface methods using privileged invoke.
@
text
@d421 1
a421 1
					tw = clazz;
a427 1
					v.type != VerifierTypeWrapper.UninitializedThis &&
@


1.237
log
@We don't support privileged access to host fields, so there's no need to carry around the privileged flag for fields.
@
text
@d3778 1
d3786 4
d3815 4
@


1.236
log
@OpenJDK 8 uses invokedynamic in the class library, so we need to support it during core class library compilation.
@
text
@d3476 1
a3476 1
		context.GetValue<DynamicFieldBinder>(instr.Arg1 | ((byte)kind << 24)).Emit(this, cpi, kind, false);
d3707 1
a3707 1
		internal void Emit(Compiler compiler, ClassFile.ConstantPoolItemFieldref cpi, ClassFile.RefKind kind, bool privileged)
d3711 1
a3711 1
				method = CreateMethod(compiler.context, cpi, kind, privileged);
d3716 1
a3716 1
		private static MethodInfo CreateMethod(DynamicTypeWrapper.FinishContext context, ClassFile.ConstantPoolItemFieldref cpi, ClassFile.RefKind kind, bool privileged)
d3741 1
a3741 1
			return DynamicBinder.Emit(context, kind, cpi, ret, args, privileged);
@


1.235
log
@Allow classes defined by Unsafe.defineAnonymousClass() access to private methods of their host class.
@
text
@d2918 1
a2918 1
		private static readonly MethodInfo methodLookup;
a2921 1
			Type typeofMethodHandles;
d2925 1
a2925 4
			typeofMethodHandles = ClassLoaderWrapper.LoadClassCritical("java.lang.invoke.MethodHandles").TypeAsBaseType;
#elif FIRST_PASS
			typeofMethodHandles = null;
#else
a2927 1
			typeofMethodHandles = typeof(java.lang.invoke.MethodHandles);
d2929 3
a2931 1
			methodLookup = typeofMethodHandles.GetMethod("lookup", new Type[] { CoreClasses.ikvm.@@internal.CallerID.Wrapper.TypeAsSignatureType });
d3047 1
a3047 1
			ilgen.Emit(OpCodes.Call, methodLookup);
@


1.234
log
@Centralized switches to control C# interop workarounds.
@
text
@d327 1
a327 1
	private Compiler(DynamicTypeWrapper.FinishContext context, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ClassLoaderWrapper classLoader)
d353 1
a353 1
			MethodAnalyzer verifier = new MethodAnalyzer(clazz, mw, classFile, m, classLoader);
d719 1
a719 1
	internal static void Compile(DynamicTypeWrapper.FinishContext context, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ref bool nonleaf)
d765 1
a765 1
				c = new Compiler(context, clazz, mw, classFile, m, ilGenerator, classLoader);
d1444 1
d1468 2
d1475 3
a1477 1
					bool isinvokespecial = instr.NormalizedOpCode == NormalizedByteCode.__invokespecial || instr.NormalizedOpCode == NormalizedByteCode.__dynamic_invokespecial;
d3023 1
a3023 1
				mw = new DynamicBinder().Get(compiler.context, ClassFile.RefKind.invokeStatic, cpiMI);
d3479 1
a3479 1
		context.GetValue<DynamicFieldBinder>(instr.Arg1 | ((byte)kind << 24)).Emit(this, cpi, kind);
d3710 1
a3710 1
		internal void Emit(Compiler compiler, ClassFile.ConstantPoolItemFieldref cpi, ClassFile.RefKind kind)
d3714 1
a3714 1
				method = CreateMethod(compiler.context, cpi, kind);
d3719 1
a3719 1
		private static MethodInfo CreateMethod(DynamicTypeWrapper.FinishContext context, ClassFile.ConstantPoolItemFieldref cpi, ClassFile.RefKind kind)
d3744 1
a3744 1
			return DynamicBinder.Emit(context, kind, cpi, ret, args);
d3752 1
a3752 1
		internal MethodWrapper Get(DynamicTypeWrapper.FinishContext context, ClassFile.RefKind kind, ClassFile.ConstantPoolItemMI cpi)
d3754 1
a3754 1
			return mw ?? (mw = new DynamicBinderMethodWrapper(cpi, Emit(context, kind, cpi), kind));
d3757 1
a3757 1
		private static MethodInfo Emit(DynamicTypeWrapper.FinishContext context, ClassFile.RefKind kind, ClassFile.ConstantPoolItemMI cpi)
d3776 1
a3776 1
			return Emit(context, kind, cpi, ret, args);
d3779 1
a3779 1
		internal static MethodInfo Emit(DynamicTypeWrapper.FinishContext context, ClassFile.RefKind kind, ClassFile.ConstantPoolItemFMI cpi, TypeWrapper ret, TypeWrapper[] args)
d3797 8
a3804 1
			context.EmitCallerID(ilgen);
d3883 3
d3911 1
d3916 1
d3923 6
d3932 13
a3944 1
		return context.GetValue<DynamicBinder>(index | ((byte)kind << 24)).Get(context, kind, cpi);
@


1.233
log
@Integrated OpenJDK 7u40 JSR-292 implementation (aka LambdaForms).
@
text
@d2949 1
a2949 1
			CodeEmitter ilgen = CodeEmitter.Create(ReflectUtil.DefineTypeInitializer(tb));
d3236 1
a3236 1
				CodeEmitter ilgen = CodeEmitter.Create(ReflectUtil.DefineTypeInitializer(tb));
@


1.232
log
@Removed constant MethodHandle optimization to make it easier to integrate LambdaForm.
@
text
@d80 1
d125 1
d1445 1
d3167 1
a3167 1
		Type delegateType = MethodHandleUtil.CreateDelegateType(args, cpi.GetRetType());
d3521 28
d3551 25
d3577 20
d3599 22
a3620 1
		internal override void EmitCallvirt(CodeEmitter ilgen)
d3622 1
a3622 4
			TypeWrapper[] args;
			CodeEmitterLocal[] temps;
			Type delegateType;
			if (cpi.Name == "invokeExact")
d3624 2
a3625 10
				args = cpi.GetArgTypes();
				temps = new CodeEmitterLocal[args.Length];
				for (int i = args.Length - 1; i >= 0; i--)
				{
					temps[i] = ilgen.DeclareLocal(args[i].TypeAsSignatureType);
					ilgen.Emit(OpCodes.Stloc, temps[i]);
				}
				delegateType = MethodHandleUtil.CreateDelegateType(args, cpi.GetRetType());
				MethodInfo mi = ByteCodeHelperMethods.GetDelegateForInvokeExact.MakeGenericMethod(delegateType);
				ilgen.Emit(OpCodes.Call, mi);
d3627 3
a3629 1
			else
d3631 6
a3636 10
				args = ArrayUtil.Concat(CoreClasses.java.lang.invoke.MethodHandle.Wrapper, cpi.GetArgTypes());
				temps = new CodeEmitterLocal[args.Length];
				for (int i = args.Length - 1; i >= 0; i--)
				{
					temps[i] = ilgen.DeclareLocal(args[i].TypeAsSignatureType);
					ilgen.Emit(OpCodes.Stloc, temps[i]);
				}
				delegateType = MethodHandleUtil.CreateDelegateType(args, cpi.GetRetType());
				MethodInfo mi = ByteCodeHelperMethods.GetDelegateForInvoke.MakeGenericMethod(delegateType);
				Type typeofInvokeCache;
d3638 1
a3638 1
				typeofInvokeCache = StaticCompiler.GetRuntimeType("IKVM.Runtime.InvokeCache`1");
d3640 1
a3640 1
				typeofInvokeCache = typeof(IKVM.Runtime.InvokeCache<>);
d3642 7
a3648 4
				FieldBuilder fb = context.DefineMethodHandleInvokeCacheField(typeofInvokeCache.MakeGenericType(delegateType));
				ilgen.Emit(OpCodes.Ldloc, temps[0]);
				ilgen.Emit(OpCodes.Ldsflda, fb);
				ilgen.Emit(OpCodes.Call, mi);
d3650 19
d3674 19
d3776 1
a3776 1
			Type delegateType = MethodHandleUtil.CreateDelegateType(args, ret);
d3873 1
@


1.231
log
@Use the same internal bytecode for MethodHandle.invoke() and invokeExact().
@
text
@a80 1
	internal static readonly MethodInfo MethodHandleFromDelegate;
a124 1
		MethodHandleFromDelegate = GetHelper(typeofByteCodeHelper, "MethodHandleFromDelegate");
a3175 1
		private bool dynamic;
d3181 1
a3181 12
				field = CreateField(compiler, index, ref dynamic);
			}
			if (dynamic)
			{
				ClassFile.ConstantPoolItemMethodHandle mh = compiler.classFile.GetConstantPoolConstantMethodHandle(index);
				ilgen.Emit(OpCodes.Ldsflda, field);
				ilgen.EmitLdc_I4((int)mh.Kind);
				ilgen.Emit(OpCodes.Ldstr, mh.Class);
				ilgen.Emit(OpCodes.Ldstr, mh.Name);
				ilgen.Emit(OpCodes.Ldstr, mh.Signature);
				compiler.context.EmitCallerID(ilgen);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicLoadMethodHandle);
a3182 8
			else
			{
				ilgen.Emit(OpCodes.Ldsfld, field);
			}
		}

		private static FieldBuilder CreateField(Compiler compiler, int index, ref bool dynamic)
		{
d3184 7
a3190 188
			if (mh.GetClassType().IsUnloadable)
			{
				dynamic = true;
				return compiler.context.DefineDynamicMethodHandleCacheField();
			}
			TypeWrapper[] args;
			TypeWrapper arg0 = null;
			TypeWrapper ret;
			switch (mh.Kind)
			{
				case ClassFile.RefKind.getField:
					args = new TypeWrapper[] { mh.Member.DeclaringType };
					ret = ((FieldWrapper)mh.Member).FieldTypeWrapper;
					break;
				case ClassFile.RefKind.putField:
					args = new TypeWrapper[] { mh.Member.DeclaringType, ((FieldWrapper)mh.Member).FieldTypeWrapper };
					ret = PrimitiveTypeWrapper.VOID;
					break;
				case ClassFile.RefKind.getStatic:
					args = TypeWrapper.EmptyArray;
					ret = ((FieldWrapper)mh.Member).FieldTypeWrapper;
					break;
				case ClassFile.RefKind.putStatic:
					args = new TypeWrapper[] { ((FieldWrapper)mh.Member).FieldTypeWrapper };
					ret = PrimitiveTypeWrapper.VOID;
					break;
				case ClassFile.RefKind.invokeInterface:
				case ClassFile.RefKind.invokeSpecial:
				case ClassFile.RefKind.invokeVirtual:
				case ClassFile.RefKind.invokeStatic:
					if (mh.Member == null)
					{
						// it's MethodHandle.invoke[Exact]
						ClassFile.ConstantPoolItemMI cpi = (ClassFile.ConstantPoolItemMI)mh.MemberConstantPoolItem;
						args = cpi.GetArgTypes();
						arg0 = mh.GetClassType();
						ret = cpi.GetRetType();
					}
					else
					{
						MethodWrapper mw = (MethodWrapper)mh.Member;
						args = mw.GetParameters();
						ret = mw.ReturnType;
						if (mw.IsStatic)
						{
							// no receiver type
						}
						else if (mw.IsProtected && !mw.IsAccessibleFrom(mh.GetClassType(), compiler.clazz, mh.GetClassType()))
						{
							arg0 = compiler.clazz;
						}
						else
						{
							arg0 = mh.GetClassType();
						}
					}
					break;
				case ClassFile.RefKind.newInvokeSpecial:
					args = ((MethodWrapper)mh.Member).GetParameters();
					ret = mh.Member.DeclaringType;
					break;
				default:
					throw new InvalidOperationException();
			}
			if (arg0 != null)
			{
				args = ArrayUtil.Concat(arg0, args);
			}
			if (HasUnloadable(args, ret))
			{
				dynamic = true;
				return compiler.context.DefineDynamicMethodHandleCacheField();
			}

			Type delegateType = MethodHandleUtil.CreateDelegateType(args, ret);
			MethodInfo method;
			if (mh.Kind == ClassFile.RefKind.invokeStatic
				&& (method = (MethodInfo)((MethodWrapper)mh.Member).GetMethod()) != null
				&& ((MethodWrapper)mh.Member).GetParameters().Length <= MethodHandleUtil.MaxArity)
			{
				// we can create a delegate that directly points to the target method
			}
			else
			{
				method = CreateDispatchStub(compiler, mh, delegateType);
			}
			TypeBuilder tb = compiler.context.DefineMethodHandleConstantType(index);
			FieldBuilder field = tb.DefineField("value", CoreClasses.java.lang.invoke.MethodHandle.Wrapper.TypeAsSignatureType, FieldAttributes.Assembly | FieldAttributes.Static | FieldAttributes.InitOnly);
			CodeEmitter ilgen = CodeEmitter.Create(ReflectUtil.DefineTypeInitializer(tb));
			ilgen.Emit(OpCodes.Ldnull);
			ilgen.Emit(OpCodes.Ldftn, method);
			ilgen.Emit(OpCodes.Newobj, MethodHandleUtil.GetDelegateConstructor(delegateType));
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.MethodHandleFromDelegate);
			ilgen.Emit(OpCodes.Stsfld, field);
			ilgen.Emit(OpCodes.Ret);
			ilgen.DoEmit();
			return field;
		}

		private static MethodInfo CreateDispatchStub(Compiler compiler, ClassFile.ConstantPoolItemMethodHandle mh, Type delegateType)
		{
			// the dispatch stub lives in the actual type (not the nested type that caches the value) to make sure
			// we have access to everything that the actual type has access to
			Type[] args = delegateType.GetGenericArguments();
			Type ret = Types.Void;
			// NOTE we can't use the method returned by GetDelegateInvokeMethod to determine the parameter types, due to Mono and CLR bugs
			if (MethodHandleUtil.GetDelegateInvokeMethod(delegateType).ReturnType != Types.Void)
			{
				ret = args[args.Length - 1];
				Array.Resize(ref args, args.Length - 1);
			}
			MethodBuilder mb = compiler.context.DefineMethodHandleDispatchStub(ret, args);
			CodeEmitter ilgen = CodeEmitter.Create(mb);
			if (args.Length > 0 && MethodHandleUtil.IsPackedArgsContainer(args[args.Length - 1]))
			{
				int packedArgPos = args.Length - 1;
				Type packedArgType = args[packedArgPos];
				for (int i = 0; i < packedArgPos; i++)
				{
					ilgen.EmitLdarg(i);
				}
				List<FieldInfo> fields = new List<FieldInfo>();
			next:
				args = args[args.Length - 1].GetGenericArguments();
				for (int i = 0; i < MethodHandleUtil.MaxArity; i++)
				{
					if (i == MethodHandleUtil.MaxArity - 1 && MethodHandleUtil.IsPackedArgsContainer(args[i]))
					{
						FieldInfo field = packedArgType.GetField("t" + (i + 1));
						packedArgType = field.FieldType;
						fields.Add(field);
						goto next;
					}
					else
					{
						ilgen.EmitLdarga(packedArgPos);
						foreach (FieldInfo field in fields)
						{
							ilgen.Emit(OpCodes.Ldflda, field);
						}
						ilgen.Emit(OpCodes.Ldfld, packedArgType.GetField("t" + (i + 1)));
					}
				}
			}
			else
			{
				for (int i = 0; i < args.Length; i++)
				{
					ilgen.EmitLdarg(i);
				}
			}
			switch (mh.Kind)
			{
				case ClassFile.RefKind.getField:
				case ClassFile.RefKind.getStatic:
					((FieldWrapper)mh.Member).EmitGet(ilgen);
					break;
				case ClassFile.RefKind.putField:
				case ClassFile.RefKind.putStatic:
					((FieldWrapper)mh.Member).EmitSet(ilgen);
					break;
				case ClassFile.RefKind.invokeInterface:
				case ClassFile.RefKind.invokeVirtual:
					if (mh.Member == null)
					{
						// it's a MethodHandle.invoke[Exact] constant MethodHandle
						new MethodHandleMethodWrapper(compiler.context, compiler.clazz, (ClassFile.ConstantPoolItemMI)mh.MemberConstantPoolItem).EmitCallvirt(ilgen);
					}
					else
					{
						((MethodWrapper)mh.Member).EmitCallvirt(ilgen);
					}
					break;
				case ClassFile.RefKind.invokeStatic:
					((MethodWrapper)mh.Member).EmitCall(ilgen);
					break;
				case ClassFile.RefKind.invokeSpecial:
					ilgen.Emit(OpCodes.Callvirt, compiler.context.GetInvokeSpecialStub((MethodWrapper)mh.Member));
					break;
				case ClassFile.RefKind.newInvokeSpecial:
					((MethodWrapper)mh.Member).EmitNewobj(ilgen);
					break;
				default:
					throw new InvalidOperationException();
			}
			ilgen.Emit(OpCodes.Ret);
			ilgen.DoEmit();
			return mb;
@


1.230
log
@Added Unsafe.defineAnonymousClass().
@
text
@a1469 1
				case NormalizedByteCode.__methodhandle_invokeexact:
d3372 1
a3372 1
						new MethodHandleMethodWrapper(compiler.context, compiler.clazz, (ClassFile.ConstantPoolItemMI)mh.MemberConstantPoolItem, mh.Name == "invokeExact").EmitCallvirt(ilgen);
a3711 1
		private readonly bool exact;
d3713 1
a3713 1
		internal MethodHandleMethodWrapper(DynamicTypeWrapper.FinishContext context, TypeWrapper wrapper, ClassFile.ConstantPoolItemMI cpi, bool exact)
a3718 1
			this.exact = exact;
d3731 1
a3731 1
			if (exact)
d3951 1
a3951 3
				return new MethodHandleMethodWrapper(context, clazz, cpi, false);
			case NormalizedByteCode.__methodhandle_invokeexact:
				return new MethodHandleMethodWrapper(context, clazz, cpi, true);
@


1.229
log
@Bug fix. If a ghost array is used in an invokedynamic signature, we should not use the erased method type.
@
text
@d2847 5
@


1.228
log
@Guard against bogus LVT entries. Fix for bug #284.
@
text
@d2971 1
a2971 1
			if (EmitCallBootstrapMethod(compiler, cpi, delegateType, ilgen))
d3000 1
a3000 1
		private static bool EmitCallBootstrapMethod(Compiler compiler, ClassFile.ConstantPoolItemInvokeDynamic cpi, Type delegateType, CodeEmitter ilgen)
d3043 1
a3043 1
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LoadMethodType.MakeGenericMethod(delegateType));
@


1.227
log
@Make all byte code helper methods available during in first-pass version of IKVM.Runtime.dll and changed compiler to check that all methods are available.
@
text
@d524 1
a524 1
				if(startIndex != -1 && endIndex != -1)
@


1.226
log
@Moved another MethodHandleUtil method.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
d91 54
a144 37
		multianewarray = typeofByteCodeHelper.GetMethod("multianewarray");
		multianewarray_ghost = typeofByteCodeHelper.GetMethod("multianewarray_ghost");
		anewarray_ghost = typeofByteCodeHelper.GetMethod("anewarray_ghost");
		f2i = typeofByteCodeHelper.GetMethod("f2i");
		d2i = typeofByteCodeHelper.GetMethod("d2i");
		f2l = typeofByteCodeHelper.GetMethod("f2l");
		d2l = typeofByteCodeHelper.GetMethod("d2l");
		arraycopy_fast = typeofByteCodeHelper.GetMethod("arraycopy_fast");
		arraycopy_primitive_8 = typeofByteCodeHelper.GetMethod("arraycopy_primitive_8");
		arraycopy_primitive_4 = typeofByteCodeHelper.GetMethod("arraycopy_primitive_4");
		arraycopy_primitive_2 = typeofByteCodeHelper.GetMethod("arraycopy_primitive_2");
		arraycopy_primitive_1 = typeofByteCodeHelper.GetMethod("arraycopy_primitive_1");
		arraycopy = typeofByteCodeHelper.GetMethod("arraycopy");
		DynamicCast = typeofByteCodeHelper.GetMethod("DynamicCast");
		DynamicAaload = typeofByteCodeHelper.GetMethod("DynamicAaload");
		DynamicAastore = typeofByteCodeHelper.GetMethod("DynamicAastore");
		DynamicClassLiteral = typeofByteCodeHelper.GetMethod("DynamicClassLiteral");
		DynamicMultianewarray = typeofByteCodeHelper.GetMethod("DynamicMultianewarray");
		DynamicNewarray = typeofByteCodeHelper.GetMethod("DynamicNewarray");
		DynamicNewCheckOnly = typeofByteCodeHelper.GetMethod("DynamicNewCheckOnly");
		DynamicCreateDelegate = typeofByteCodeHelper.GetMethod("DynamicCreateDelegate");
		DynamicLoadMethodType = typeofByteCodeHelper.GetMethod("DynamicLoadMethodType");
		DynamicLoadMethodHandle = typeofByteCodeHelper.GetMethod("DynamicLoadMethodHandle");
		DynamicBinderMemberLookup = typeofByteCodeHelper.GetMethod("DynamicBinderMemberLookup");
		VerboseCastFailure = typeofByteCodeHelper.GetMethod("VerboseCastFailure");
		SkipFinalizer = typeofByteCodeHelper.GetMethod("SkipFinalizer");
		DynamicInstanceOf = typeofByteCodeHelper.GetMethod("DynamicInstanceOf");
		volatileReadDouble = typeofByteCodeHelper.GetMethod("VolatileRead", new Type[] { Types.Double.MakeByRefType() });
		volatileReadLong = typeofByteCodeHelper.GetMethod("VolatileRead", new Type[] { Types.Int64.MakeByRefType() });
		volatileWriteDouble = typeofByteCodeHelper.GetMethod("VolatileWrite", new Type[] { Types.Double.MakeByRefType(), Types.Double });
		volatileWriteLong = typeofByteCodeHelper.GetMethod("VolatileWrite", new Type[] { Types.Int64.MakeByRefType(), Types.Int64 });
		mapException = typeofByteCodeHelper.GetMethod("MapException");
		GetDelegateForInvokeExact = typeofByteCodeHelper.GetMethod("GetDelegateForInvokeExact");
		GetDelegateForInvoke = typeofByteCodeHelper.GetMethod("GetDelegateForInvoke");
		LoadMethodType = typeofByteCodeHelper.GetMethod("LoadMethodType");
		MethodHandleFromDelegate = typeofByteCodeHelper.GetMethod("MethodHandleFromDelegate");
		LinkIndyCallSite = typeofByteCodeHelper.GetMethod("LinkIndyCallSite");
@


1.225
log
@Moved another MethodHandleUtil method from compiler.cs to MethodHandleUtil.cs.
@
text
@d178 1
a178 1
		if (MethodHandleUtil.IsPackedArgsContainer(last))
a235 6

	internal static bool IsPackedArgsContainer(Type type)
	{
		return type.IsGenericType
			&& type.GetGenericTypeDefinition() == typeofMHA;
	}
@


1.224
log
@Moved part of MethodHandleUtil that is used by the runtime for JNI non-virtual invocation into a separate file.
@
text
@a208 10
	internal static Type CreateDelegateType(TypeWrapper tw, MethodWrapper mw)
	{
		TypeWrapper[] args = mw.GetParameters();
		if (!mw.IsStatic)
		{
			args = ArrayUtil.Concat(tw, args);
		}
		return CreateDelegateType(args, mw.ReturnType);
	}

@


1.223
log
@Introduced ArrayUtil.Concat() methods.
@
text
@a156 60
	internal const int MaxArity = 8;
	private static readonly Type typeofMHA;
	private static readonly Type[] typeofMHV;
	private static readonly Type[] typeofMH;

	static MethodHandleUtil()
	{
#if STATIC_COMPILER
		typeofMHA = StaticCompiler.GetRuntimeType("IKVM.Runtime.MHA`8");
		typeofMHV = new Type[] {
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MHV"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MHV`1"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MHV`2"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MHV`3"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MHV`4"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MHV`5"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MHV`6"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MHV`7"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MHV`8"),
		};
		typeofMH = new Type[] {
			null,
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MH`1"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MH`2"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MH`3"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MH`4"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MH`5"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MH`6"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MH`7"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MH`8"),
			StaticCompiler.GetRuntimeType("IKVM.Runtime.MH`9"),
		};
#else
		typeofMHA = typeof(IKVM.Runtime.MHA<,,,,,,,>);
		typeofMHV = new Type[] {
			typeof(IKVM.Runtime.MHV),
			typeof(IKVM.Runtime.MHV<>),
			typeof(IKVM.Runtime.MHV<,>),
			typeof(IKVM.Runtime.MHV<,,>),
			typeof(IKVM.Runtime.MHV<,,,>),
			typeof(IKVM.Runtime.MHV<,,,,>),
			typeof(IKVM.Runtime.MHV<,,,,,>),
			typeof(IKVM.Runtime.MHV<,,,,,,>),
			typeof(IKVM.Runtime.MHV<,,,,,,,>),
		};
		typeofMH = new Type[] {
			null,
			typeof(IKVM.Runtime.MH<>),
			typeof(IKVM.Runtime.MH<,>),
			typeof(IKVM.Runtime.MH<,,>),
			typeof(IKVM.Runtime.MH<,,,>),
			typeof(IKVM.Runtime.MH<,,,,>),
			typeof(IKVM.Runtime.MH<,,,,,>),
			typeof(IKVM.Runtime.MH<,,,,,,>),
			typeof(IKVM.Runtime.MH<,,,,,,,>),
			typeof(IKVM.Runtime.MH<,,,,,,,,>),
		};
#endif
	}

a218 10
	internal static Type CreateDelegateType(TypeWrapper[] args, TypeWrapper ret)
	{
		Type[] typeArgs = new Type[args.Length];
		for (int i = 0; i < args.Length; i++)
		{
			typeArgs[i] = args[i].TypeAsSignatureType;
		}
		return CreateDelegateType(typeArgs, ret.TypeAsSignatureType);
	}

a246 44
	private static Type CreateDelegateType(Type[] types, Type retType)
	{
		if (types.Length == 0 && retType == Types.Void)
		{
			return typeofMHV[0];
		}
		else if (types.Length > MaxArity)
		{
			int arity = types.Length;
			int remainder = (arity - 8) % 7;
			int count = (arity - 8) / 7;
			if (remainder == 0)
			{
				remainder = 7;
				count--;
			}
			Type last = typeofMHA.MakeGenericType(SubArray(types, types.Length - 8, 8));
			for (int i = 0; i < count; i++)
			{
				Type[] temp = SubArray(types, types.Length - 8 - 7 * (i + 1), 8);
				temp[7] = last;
				last = typeofMHA.MakeGenericType(temp);
			}
			types = SubArray(types, 0, remainder + 1);
			types[remainder] = last;
		}
		if (retType == Types.Void)
		{
			return typeofMHV[types.Length].MakeGenericType(types);
		}
		else
		{
			types = ArrayUtil.Concat(types, retType);
			return typeofMH[types.Length].MakeGenericType(types);
		}
	}

	private static Type[] SubArray(Type[] inArray, int start, int length)
	{
		Type[] outArray = new Type[length];
		Array.Copy(inArray, start, outArray, 0, length);
		return outArray;
	}

@


1.222
log
@There is no need to use dynamic binding if only the receiver type is unloadable.
@
text
@d274 1
a274 3
			Array.Resize(ref args, args.Length + 1);
			Array.Copy(args, 0, args, 1, args.Length - 1);
			args[0] = tw;
d349 1
a349 2
			Array.Resize(ref types, types.Length + 1);
			types[types.Length - 1] = retType;
d3381 1
a3381 4
				TypeWrapper[] newArgs = new TypeWrapper[args.Length + 1];
				newArgs[0] = arg0;
				Array.Copy(args, 0, newArgs, 1, args.Length);
				args = newArgs;
d3857 1
a3857 3
				args = new TypeWrapper[cpi.GetArgTypes().Length + 1];
				Array.Copy(cpi.GetArgTypes(), 0, args, 1, args.Length - 1);
				args[0] = CoreClasses.java.lang.invoke.MethodHandle.Wrapper;
d3958 1
a3958 3
				args = new TypeWrapper[cpi.GetArgTypes().Length + 1];
				Array.Copy(cpi.GetArgTypes(), 0, args, 1, args.Length - 1);
				args[0] = cpi.GetClassType();
@


1.221
log
@Switched dynamic field binding to method handles.
@
text
@d1592 1
a1592 1
					TypeWrapper thisType = SigTypeToClassName(type, method.DeclaringType);
d4112 1
a4112 2
	// TODO this method should have a better name
	private TypeWrapper SigTypeToClassName(TypeWrapper type, TypeWrapper nullType)
d4125 5
a4129 1
			return nullType;
@


1.220
log
@Regression fix. We need to encode the refKind in the GetValue key to make sure that different bytecodes result in different binders (to give the proper error when the wrong bytecode is used to invoke the method).
@
text
@a62 2
	internal static readonly MethodInfo DynamicGetfield;
	internal static readonly MethodInfo DynamicGetstatic;
a65 2
	internal static readonly MethodInfo DynamicPutfield;
	internal static readonly MethodInfo DynamicPutstatic;
a107 2
		DynamicGetfield = typeofByteCodeHelper.GetMethod("DynamicGetfield");
		DynamicGetstatic = typeofByteCodeHelper.GetMethod("DynamicGetstatic");
a110 2
		DynamicPutfield = typeofByteCodeHelper.GetMethod("DynamicPutfield");
		DynamicPutstatic = typeofByteCodeHelper.GetMethod("DynamicPutstatic");
d3753 2
a3754 14
		NormalizedByteCode bytecode = instr.NormalizedOpCode;
		ClassFile.ConstantPoolItemFieldref cpi = classFile.GetFieldref(instr.Arg1);
		bool write = (bytecode == NormalizedByteCode.__dynamic_putfield || bytecode == NormalizedByteCode.__dynamic_putstatic);
		TypeWrapper wrapper = cpi.GetClassType();
		TypeWrapper fieldTypeWrapper = cpi.GetFieldType();
		if(write && !fieldTypeWrapper.IsUnloadable && fieldTypeWrapper.IsPrimitive)
		{
			ilGenerator.Emit(OpCodes.Box, fieldTypeWrapper.TypeAsTBD);
		}
		ilGenerator.Emit(OpCodes.Ldstr, cpi.Name);
		ilGenerator.Emit(OpCodes.Ldstr, cpi.Signature);
		ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
		context.EmitCallerID(ilGenerator);
		switch(bytecode)
d3758 1
a3758 2
				ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicGetfield);
				EmitReturnTypeConversion(ilGenerator, fieldTypeWrapper);
d3762 1
a3762 1
				ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicPutfield);
d3766 1
a3766 2
				ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicGetstatic);
				EmitReturnTypeConversion(ilGenerator, fieldTypeWrapper);
d3770 1
a3770 1
				ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicPutstatic);
d3775 19
d3898 42
d3970 5
@


1.219
log
@There is no need to use dynamic binding if only the receiver type is unloadable.
@
text
@a4022 1
				return context.GetValue<DynamicBinder>(constantPoolIndex).Get(context, ClassFile.RefKind.invokeInterface, cpi);
a4023 1
				return context.GetValue<DynamicBinder>(constantPoolIndex).Get(context, ClassFile.RefKind.invokeStatic, cpi);
a4024 1
				return context.GetValue<DynamicBinder>(constantPoolIndex).Get(context, ClassFile.RefKind.invokeVirtual, cpi);
d4026 1
a4026 1
				return context.GetValue<DynamicBinder>(constantPoolIndex).Get(context, ClassFile.RefKind.newInvokeSpecial, cpi);
d4036 1
a4036 13
			switch (invoke)
			{
				case NormalizedByteCode.__invokespecial:
					return context.GetValue<DynamicBinder>(constantPoolIndex).Get(context, ClassFile.RefKind.invokeSpecial, cpi);
				case NormalizedByteCode.__invokeinterface:
					return context.GetValue<DynamicBinder>(constantPoolIndex).Get(context, ClassFile.RefKind.invokeInterface, cpi);
				case NormalizedByteCode.__invokestatic:
					return context.GetValue<DynamicBinder>(constantPoolIndex).Get(context, ClassFile.RefKind.invokeStatic, cpi);
				case NormalizedByteCode.__invokevirtual:
					return context.GetValue<DynamicBinder>(constantPoolIndex).Get(context, ClassFile.RefKind.invokeVirtual, cpi);
				default:
					throw new InvalidOperationException();
			}
d4041 27
@


1.218
log
@Forgot to update other occurrences of DynamicCast and DynamicInstanceOf.
@
text
@d1450 13
d1494 16
@


1.217
log
@Removed unnecessary parameters from dynamic array load/store.
@
text
@a877 1
				Profiler.Count("EmitDynamicCast");
d879 1
a879 3
				ilGenerator.Emit(OpCodes.Ldstr, args[i].Name);
				context.EmitCallerID(ilGenerator);
				ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicCast);
d1294 1
a1294 3
							ilGenerator.Emit(OpCodes.Ldstr, exceptionTypeWrapper.Name);
							context.EmitCallerID(ilGenerator);
							ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicInstanceOf);
d2128 1
a2128 7
						// NOTE it's important that we don't try to load the class if obj == null
						CodeEmitterLabel ok = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Dup);
						ilGenerator.EmitBrfalse(ok);
						context.EmitDynamicClassLiteral(ilGenerator, wrapper);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicCast);
						ilGenerator.MarkLabel(ok);
d2141 1
a2141 12
						// NOTE it's important that we don't try to load the class if obj == null
						CodeEmitterLabel notnull = ilGenerator.DefineLabel();
						CodeEmitterLabel end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Dup);
						ilGenerator.EmitBrtrue(notnull);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.EmitLdc_I4(0);
						ilGenerator.EmitBr(end);
						ilGenerator.MarkLabel(notnull);
						context.EmitDynamicClassLiteral(ilGenerator, wrapper);
						ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicInstanceOf);
						ilGenerator.MarkLabel(end);
d2947 29
@


1.216
log
@Optimized DynamicMultianewarray, DynamicNewarray, DynamicNewCheckOnly, DynamicCast and DynamicInstanceOf by reusing (cached) dynamic class literal.
@
text
@a2176 2
						ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
						ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
a2248 2
						ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
						ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
@


1.215
log
@Cache dynamic class literals.
@
text
@d2005 1
a2005 2
						ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
						context.EmitCallerID(ilGenerator);
a2034 1
						ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
d2036 1
a2036 1
						context.EmitCallerID(ilGenerator);
d2067 1
a2067 2
						ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
						context.EmitCallerID(ilGenerator);
d2133 5
a2137 2
						ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
						context.EmitCallerID(ilGenerator);
d2139 1
d2152 10
a2161 2
						ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
						context.EmitCallerID(ilGenerator);
d2163 1
@


1.214
log
@Reimplemented dynamic binding on top of MethodHandles. This avoids having to instantiate a java.lang.reflect.Method which might fail if it declares a checked exception that is not loadable. It also has the potential of being faster, but no perf work has been done yet.
@
text
@d2968 1
a2968 3
			ilgen.Emit(OpCodes.Ldstr, tw.Name);
			context.EmitCallerID(ilgen);
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicClassLiteral);
@


1.213
log
@Use MethodWrapper instead of ConstantPoolItemMI to make it easier to move constant pool entry lookup to GetMethodCallEmitter.
@
text
@a64 3
	internal static readonly MethodInfo DynamicInvokeSpecialNew;
	internal static readonly MethodInfo DynamicInvokestatic;
	internal static readonly MethodInfo DynamicInvokevirtual;
d73 1
a113 3
		DynamicInvokeSpecialNew = typeofByteCodeHelper.GetMethod("DynamicInvokeSpecialNew");
		DynamicInvokestatic = typeofByteCodeHelper.GetMethod("DynamicInvokestatic");
		DynamicInvokevirtual = typeofByteCodeHelper.GetMethod("DynamicInvokevirtual");
d122 1
d1546 1
a1546 2
					ClassFile.ConstantPoolItemMI cpi = classFile.GetMethodref(instr.Arg1);
					MethodWrapper method = GetMethodCallEmitter(cpi, instr.NormalizedOpCode);
d1573 1
a1573 1
					MethodWrapper method = GetMethodCallEmitter(classFile.GetMethodref(instr.Arg1), instr.NormalizedOpCode);
d1587 1
d3097 1
a3097 1
				mw = new DynamicMethodWrapper(compiler.context, cpiMI, Modifiers.Public | Modifiers.Static);
a3554 13
		bool dynamic;
		switch(m.Instructions[instructionIndex].NormalizedOpCode)
		{
			case NormalizedByteCode.__dynamic_invokeinterface:
			case NormalizedByteCode.__dynamic_invokestatic:
			case NormalizedByteCode.__dynamic_invokevirtual:
				dynamic = true;
				break;
			default:
				dynamic = false;
				break;
		}

d3634 11
d3651 1
a3651 1
				if(!args[i].IsUnloadable && args[i].IsGhost && !dynamic)
d3678 1
a3678 1
					if(!args[i].IsUnloadable && !dynamic)
d3861 1
a3861 1
	private sealed class DynamicMethodWrapper : MethodWrapper
d3863 1
a3863 2
		private readonly DynamicTypeWrapper.FinishContext context;
		private readonly ClassFile.ConstantPoolItemMI cpi;
d3865 1
a3865 2
		internal DynamicMethodWrapper(DynamicTypeWrapper.FinishContext context, ClassFile.ConstantPoolItemMI cpi, Modifiers modifiers)
			: base(cpi.GetClassType(), cpi.Name, cpi.Signature, null, cpi.GetRetType(), cpi.GetArgTypes(), modifiers, MemberFlags.None)
d3867 1
a3867 2
			this.context = context;
			this.cpi = cpi;
d3870 1
a3870 1
		internal override void EmitCall(CodeEmitter ilgen)
d3872 49
a3920 1
			Emit(ByteCodeHelperMethods.DynamicInvokestatic, ilgen, cpi.GetRetType());
d3923 1
a3923 1
		internal override void EmitCallvirt(CodeEmitter ilgen)
d3925 12
a3936 2
			Emit(ByteCodeHelperMethods.DynamicInvokevirtual, ilgen, cpi.GetRetType());
		}
d3938 4
a3941 4
		internal override void EmitNewobj(CodeEmitter ilgen)
		{
			Emit(ByteCodeHelperMethods.DynamicInvokeSpecialNew, ilgen, cpi.GetClassType());
		}
d3943 4
a3946 28
		private void Emit(MethodInfo helperMethod, CodeEmitter ilGenerator, TypeWrapper retTypeWrapper)
		{
			Profiler.Count("EmitDynamicInvokeEmitter");
			TypeWrapper[] args = cpi.GetArgTypes();
			CodeEmitterLocal argarray = ilGenerator.DeclareLocal(JVM.Import(typeof(object[])));
			CodeEmitterLocal val = ilGenerator.DeclareLocal(Types.Object);
			ilGenerator.EmitLdc_I4(args.Length);
			ilGenerator.Emit(OpCodes.Newarr, Types.Object);
			ilGenerator.Emit(OpCodes.Stloc, argarray);
			for(int i = args.Length - 1; i >= 0; i--)
			{
				if(args[i].IsPrimitive)
				{
					ilGenerator.Emit(OpCodes.Box, args[i].TypeAsTBD);
				}
				ilGenerator.Emit(OpCodes.Stloc, val);
				ilGenerator.Emit(OpCodes.Ldloc, argarray);
				ilGenerator.EmitLdc_I4(i);
				ilGenerator.Emit(OpCodes.Ldloc, val);
				ilGenerator.Emit(OpCodes.Stelem_Ref);
			}
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Class);
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Name);
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Signature);
			ilGenerator.Emit(OpCodes.Ldloc, argarray);
			context.EmitCallerID(ilGenerator);
			ilGenerator.Emit(OpCodes.Call, helperMethod);
			EmitReturnTypeConversion(ilGenerator, retTypeWrapper);
d3950 1
a3950 1
	private MethodWrapper GetMethodCallEmitter(ClassFile.ConstantPoolItemMI cpi, NormalizedByteCode invoke)
d3952 1
d3983 1
d3985 1
d3987 1
d3989 1
a3989 1
				return new DynamicMethodWrapper(context, cpi, Modifiers.Public);
d3999 13
a4011 1
			return new DynamicMethodWrapper(context, cpi, mw.Modifiers);
@


1.212
log
@Removed unnecessary special casing of non-ghost interface method calling.
@
text
@d1578 2
a1579 2
					ClassFile.ConstantPoolItemMI cpi = classFile.GetMethodref(instr.Arg1);
					int argcount = cpi.GetArgTypes().Length;
d1581 1
a1581 3
					TypeWrapper thisType = SigTypeToClassName(type, cpi.GetClassType());

					MethodWrapper method = GetMethodCallEmitter(cpi, instr.NormalizedOpCode);
d1598 1
a1598 1
							method = cli_System_Object.GetMethodWrapper(cpi.Name, cpi.Signature, true);
d1602 1
a1602 1
							method = cli_System_Exception.GetMethodWrapper(cpi.Name, cpi.Signature, true);
d1606 1
a1606 1
							method = java_lang_Throwable.GetMethodWrapper(cpi.Name, cpi.Signature, true);
@


1.211
log
@Added MethodWrapper.IsConstructor property.
@
text
@d1626 1
a1626 10
							if(method.DeclaringType.IsGhost)
							{
								// if we're calling a ghost interface method, we need to make sure that CastInterfaceArgs knows
								// (cpi.GetClassType() could be an interface that extends the ghost interface)
								args[0] = method.DeclaringType;
							}
							else
							{
								args[0] = cpi.GetClassType();
							}
@


1.210
log
@Removed unnecessary parameter.
@
text
@d465 1
a465 1
		if(ReferenceEquals(mw.Name, StringConstants.INIT))
d1614 1
a1614 1
					if(isinvokespecial && ReferenceEquals(cpi.Name, StringConstants.INIT) && VerifierTypeWrapper.IsNew(type))
d1644 1
a1644 1
					if(isinvokespecial && ReferenceEquals(cpi.Name, StringConstants.INIT))
d3554 1
a3554 1
				return mw.Name != StringConstants.INIT || mw.DeclaringType != tw;
@


1.209
log
@Marked some fields as readonly.
@
text
@d3112 1
a3112 1
				mw = new DynamicMethodWrapper(compiler.context, compiler.clazz, cpiMI, Modifiers.Public | Modifiers.Static);
a3880 1
		private readonly TypeWrapper wrapper;
d3883 2
a3884 2
		internal DynamicMethodWrapper(DynamicTypeWrapper.FinishContext context, TypeWrapper wrapper, ClassFile.ConstantPoolItemMI cpi, Modifiers modifiers)
			: base(wrapper, cpi.Name, cpi.Signature, null, cpi.GetRetType(), cpi.GetArgTypes(), modifiers, MemberFlags.None)
a3886 1
			this.wrapper = wrapper;
d3971 1
a3971 1
				return new DynamicMethodWrapper(context, clazz, cpi, Modifiers.Public);
d3981 1
a3981 1
			return new DynamicMethodWrapper(context, clazz, cpi, mw.Modifiers);
@


1.208
log
@Moved invokespecial stub cache into FinishContext.
@
text
@d687 2
a688 2
		private CodeEmitterLabel stub;
		private CodeEmitterLocal local;
d741 3
a743 3
		private Compiler compiler;
		private StackType[] types;
		private CodeEmitterLocal[] locals;
d962 5
a966 5
		private Compiler compiler;
		private CodeEmitter ilgen;
		private int beginIndex;
		private int endIndex;
		private int exceptionIndex;
d968 2
a969 2
		private bool nested;
		private object[] labels;
d1014 1
a1014 1
				object l = labels[targetIndex];
d1020 1
a1020 1
				return (CodeEmitterLabel)l;
d1024 1
a1024 1
				object l = labels[targetIndex];
d1041 1
a1041 1
				return ((BranchCookie)l).Stub;
d3804 4
a3807 4
		private DynamicTypeWrapper.FinishContext context;
		private TypeWrapper wrapper;
		private ClassFile.ConstantPoolItemMI cpi;
		private bool exact;
d3880 3
a3882 3
		private DynamicTypeWrapper.FinishContext context;
		private TypeWrapper wrapper;
		private ClassFile.ConstantPoolItemMI cpi;
@


1.207
log
@Added support for dynamically linking the boostrap method of an invokedynamic.
@
text
@a408 1
	private Dictionary<MethodKey, MethodInfo> invokespecialstubcache;
d455 1
a455 1
	private Compiler(DynamicTypeWrapper.FinishContext context, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ClassLoaderWrapper classLoader, Dictionary<MethodKey, MethodInfo> invokespecialstubcache)
a462 1
		this.invokespecialstubcache = invokespecialstubcache;
d847 1
a847 1
	internal static void Compile(DynamicTypeWrapper.FinishContext context, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ref bool nonleaf, Dictionary<MethodKey, MethodInfo> invokespecialstubcache)
d896 1
a896 1
				c = new Compiler(context, clazz, mw, classFile, m, ilGenerator, classLoader, invokespecialstubcache);
d1825 1
a1825 1
								ilGenerator.Emit(OpCodes.Callvirt, GetInvokeSpecialStub(method));
d3481 1
a3481 1
					ilgen.Emit(OpCodes.Callvirt, compiler.GetInvokeSpecialStub((MethodWrapper)mh.Member));
a3565 23
	private MethodInfo GetInvokeSpecialStub(MethodWrapper method)
	{
		MethodKey key = new MethodKey(method.DeclaringType.Name, method.Name, method.Signature);
		MethodInfo mi;
		if(!invokespecialstubcache.TryGetValue(key, out mi))
		{
			DefineMethodHelper dmh = method.GetDefineMethodHelper();
			MethodBuilder stub = context.DefineInvokeSpecialStub(dmh);
			CodeEmitter ilgen = CodeEmitter.Create(stub);
			ilgen.Emit(OpCodes.Ldarg_0);
			for(int i = 1; i <= dmh.ParameterCount; i++)
			{
				ilgen.EmitLdarg(i);
			}
			method.EmitCall(ilgen);
			ilgen.Emit(OpCodes.Ret);
			ilgen.DoEmit();
			invokespecialstubcache[key] = stub;
			mi = stub;
		}
		return mi;
	}

@


1.206
log
@Copy/paste bug. The type of the MethodType constant field should be MethodType, not MethodHandle.
@
text
@d3111 5
d3909 2
a3910 2
		internal DynamicMethodWrapper(DynamicTypeWrapper.FinishContext context, TypeWrapper wrapper, ClassFile.ConstantPoolItemMI cpi)
			: base(wrapper, cpi.Name, cpi.Signature, null, cpi.GetRetType(), cpi.GetArgTypes(), Modifiers.Public, MemberFlags.None)
d3998 1
a3998 1
				return new DynamicMethodWrapper(context, clazz, cpi);
d4008 1
a4008 1
			return new DynamicMethodWrapper(context, clazz, cpi);
@


1.205
log
@Added support for dynamic ldc MethodHandle.
@
text
@d3530 1
a3530 1
				FieldBuilder field = tb.DefineField("value", CoreClasses.java.lang.invoke.MethodHandle.Wrapper.TypeAsSignatureType, FieldAttributes.Assembly | FieldAttributes.Static | FieldAttributes.InitOnly);
@


1.204
log
@Improved ldc MethodType:
- use nested type with class constructor to create values with statically know signatures (like ldc MethodHandle).
- use caching for dynamicallly constructed MethodType values but retry on failure.
@
text
@d75 1
d126 1
d3270 1
d3276 16
a3291 1
				field = CreateField(compiler, index);
a3292 1
			ilgen.Emit(OpCodes.Ldsfld, field);
d3295 1
a3295 1
		private static FieldBuilder CreateField(Compiler compiler, int index)
a3296 3
			TypeBuilder tb = compiler.context.DefineMethodHandleConstantType(index);
			FieldBuilder field = tb.DefineField("value", CoreClasses.java.lang.invoke.MethodHandle.Wrapper.TypeAsSignatureType, FieldAttributes.Assembly | FieldAttributes.Static | FieldAttributes.InitOnly);
			ILGenerator ilgen = ReflectUtil.DefineTypeInitializer(tb).GetILGenerator();
d3298 8
a3305 1
			Type delegateType;
d3309 2
a3310 1
					delegateType = MethodHandleUtil.CreateDelegateType(new TypeWrapper[] { mh.Member.DeclaringType }, ((FieldWrapper)mh.Member).FieldTypeWrapper);
d3313 2
a3314 1
					delegateType = MethodHandleUtil.CreateDelegateType(new TypeWrapper[] { mh.Member.DeclaringType, ((FieldWrapper)mh.Member).FieldTypeWrapper }, PrimitiveTypeWrapper.VOID);
d3317 2
a3318 1
					delegateType = MethodHandleUtil.CreateDelegateType(TypeWrapper.EmptyArray, ((FieldWrapper)mh.Member).FieldTypeWrapper);
d3321 2
a3322 1
					delegateType = MethodHandleUtil.CreateDelegateType(new TypeWrapper[] { ((FieldWrapper)mh.Member).FieldTypeWrapper }, PrimitiveTypeWrapper.VOID);
d3330 1
a3330 1
						// it MethodHandle.invoke[Exact]
d3332 3
a3334 8
						TypeWrapper[] args = new TypeWrapper[cpi.GetArgTypes().Length + 1];
						args[0] = mh.GetClassType();
						Array.Copy(cpi.GetArgTypes(), 0, args, 1, args.Length - 1);
						delegateType = MethodHandleUtil.CreateDelegateType(args, cpi.GetRetType());
					}
					else if (mh.Member.IsProtected && !mh.Member.IsAccessibleFrom(mh.GetClassType(), compiler.clazz, mh.GetClassType()))
					{
						delegateType = MethodHandleUtil.CreateDelegateType(compiler.clazz, (MethodWrapper)mh.Member);
d3338 15
a3352 1
						delegateType = MethodHandleUtil.CreateDelegateType(mh.GetClassType(), (MethodWrapper)mh.Member);
d3356 2
a3357 1
					delegateType = MethodHandleUtil.CreateDelegateType(((MethodWrapper)mh.Member).GetParameters(), mh.Member.DeclaringType);
d3362 14
d3387 3
d3396 1
@


1.203
log
@Changed all type flag accessors to readonly and added set methods that can set (but not clear) the flags. Added locking around modifying the flags fields.
@
text
@d74 1
d124 1
d2971 1
a2971 1
				EmitLoadMethodType(ilgen, classFile.GetConstantPoolConstantMethodType(constant));
d2993 1
a2993 1
	private void EmitLoadMethodType(CodeEmitter ilgen, ClassFile.ConstantPoolItemMethodType cpi)
a2994 2
		TypeWrapper ret = cpi.GetRetType();
		TypeWrapper[] args = cpi.GetArgTypes();
d3000 1
a3000 22
		if (tw.IsUnloadable)
		{
			EmitLoadClass(ilgen, ret);
			ilgen.EmitLdc_I4(args.Length);
			ilgen.Emit(OpCodes.Newarr, CoreClasses.java.lang.Class.Wrapper.TypeAsArrayType);
			for (int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Dup);
				ilgen.EmitLdc_I4(i);
				EmitLoadClass(ilgen, args[i]);
				ilgen.Emit(OpCodes.Stelem_Ref);
			}
			MethodWrapper methodType = ClassLoaderWrapper.LoadClassCritical("java.lang.invoke.MethodType")
				.GetMethodWrapper("methodType", "(Ljava.lang.Class;[Ljava.lang.Class;)Ljava.lang.invoke.MethodType;", false);
			methodType.Link();
			methodType.EmitCall(ilgen);
		}
		else
		{
			Type delegateType = MethodHandleUtil.CreateDelegateTypeForLoadConstant(cpi.GetArgTypes(), cpi.GetRetType());
			ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LoadMethodType.MakeGenericMethod(delegateType));
		}
d3439 50
@


1.202
log
@Moved some duplicated code into a method.
@
text
@d907 1
a907 1
			clazz.HasVerifyError = true;
d919 1
a919 1
			clazz.HasClassFormatError = true;
@


1.201
log
@Explicitly handle unloadable types in checkcast and instanceof bytecode compilation.
@
text
@d1541 1
a1541 13
					cpi.GetRetType().EmitConvSignatureTypeToStackType(ilGenerator);
					if(!strictfp)
					{
						// no need to convert
					}
					else if(cpi.GetRetType() == PrimitiveTypeWrapper.DOUBLE)
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					else if(cpi.GetRetType() == PrimitiveTypeWrapper.FLOAT)
					{
						ilGenerator.Emit(OpCodes.Conv_R4);
					}
d1562 1
a1562 13
					method.ReturnType.EmitConvSignatureTypeToStackType(ilGenerator);
					if(!strictfp)
					{
						// no need to convert
					}
					else if(method.ReturnType == PrimitiveTypeWrapper.DOUBLE)
					{
						ilGenerator.Emit(OpCodes.Conv_R8);
					}
					else if(method.ReturnType == PrimitiveTypeWrapper.FLOAT)
					{
						ilGenerator.Emit(OpCodes.Conv_R4);
					}
d1846 1
a1846 13
						method.ReturnType.EmitConvSignatureTypeToStackType(ilGenerator);
						if(!strictfp)
						{
							// no need to convert
						}
						else if(method.ReturnType == PrimitiveTypeWrapper.DOUBLE)
						{
							ilGenerator.Emit(OpCodes.Conv_R8);
						}
						else if(method.ReturnType == PrimitiveTypeWrapper.FLOAT)
						{
							ilGenerator.Emit(OpCodes.Conv_R4);
						}
d2926 17
@


1.200
log
@Changed DynamicClassLiteral return type to java.lang.Class.
@
text
@d2183 10
a2192 1
					wrapper.EmitCheckcast(ilGenerator);
d2198 10
a2207 1
					wrapper.EmitInstanceOf(ilGenerator);
@


1.199
log
@Removed unused (and bogus) parameter from TypeWrapper.EmitCheckcast() and EmitInstanceOf().
@
text
@a2984 1
			java_lang_Class.EmitCheckcast(ilgen);
@


1.198
log
@Changed dynamic bytecode helper methods to be CallerID based instead of trusting the caller to provide the right context type handle. Also, use Java class loader to load classes, instead of directly going to the runtime. Currently this makes no difference, but if we are to allow dynamic code in statically compiled code this is necessary to respect custom assembly class loaders.
@
text
@d2000 1
a2000 1
							type.EmitCheckcast(type, ilGenerator);
d2183 1
a2183 1
					wrapper.EmitCheckcast(clazz, ilGenerator);
d2189 1
a2189 1
					wrapper.EmitInstanceOf(clazz, ilGenerator);
d2985 1
a2985 1
			java_lang_Class.EmitCheckcast(clazz, ilgen);
d3738 1
a3738 1
			typeWrapper.EmitCheckcast(null, ilgen);
@


1.197
log
@Removed unused method.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2012 Jeroen Frijters
a881 1
				ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
d883 1
a1298 1
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
d1300 1
a2053 1
						ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
d2055 1
a2084 1
						ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
d2087 1
a2117 1
						ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
d2119 1
a2981 1
			ilgen.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
d2983 1
a3688 1
		ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
a3867 1
			ilGenerator.Emit(OpCodes.Ldtoken, wrapper.TypeAsTBD);
@


1.196
log
@Enable ldc <MethodType> to work for unloadable types in dynamic mode.
@
text
@a59 1
	internal static readonly MethodInfo DynamicGetTypeAsExceptionType;
a108 1
		DynamicGetTypeAsExceptionType = typeofByteCodeHelper.GetMethod("DynamicGetTypeAsExceptionType");
@


1.195
log
@Removed remaining ConstructorBuilder usages.
@
text
@d2966 1
a2966 14
			{
				TypeWrapper tw = classFile.GetConstantPoolClassType(constant);
				if (tw.IsUnloadable)
				{
					Profiler.Count("EmitDynamicClassLiteral");
					ilgen.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
					ilgen.Emit(OpCodes.Ldstr, tw.Name);
					ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicClassLiteral);
					java_lang_Class.EmitCheckcast(clazz, ilgen);
				}
				else
				{
					tw.EmitClassLiteral(ilgen);
				}
a2967 1
			}
d2972 1
a2972 4
			{
				ClassFile.ConstantPoolItemMethodType cpi = classFile.GetConstantPoolConstantMethodType(constant);
				Type delegateType = MethodHandleUtil.CreateDelegateTypeForLoadConstant(cpi.GetArgTypes(), cpi.GetRetType());
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.LoadMethodType.MakeGenericMethod(delegateType));
a2973 1
			}
d2979 49
@


1.194
log
@- Marked MemberWrapper class abstract.
- Marked all classes that don't (and shouldn't) have subclasses sealed.
@
text
@d3037 1
a3037 2
			ConstructorBuilder cb = tb.DefineConstructor(MethodAttributes.Static, CallingConventions.Standard, Type.EmptyTypes);
			CodeEmitter ilgen = CodeEmitter.Create(cb);
d3276 1
a3276 2
			ConstructorBuilder cb = tb.DefineConstructor(MethodAttributes.Static, CallingConventions.Standard, Type.EmptyTypes);
			ILGenerator ilgen = cb.GetILGenerator();
@


1.193
log
@Bug fixes:
- if a finally/fault handler contains reachable code before the handler's start index, the handler should branch to the handler start index.
- after emitting a finally/fault handler block, we should emit the block leave stubs (even though you can't leave the block, they also emit the backward branch stubs).
@
text
@d960 1
a960 1
	private class Block
d3792 1
a3792 1
	private class DynamicMethodWrapper : MethodWrapper
@


1.192
log
@Allow intrinsic methods to bypass the setting of nonleaf (which makes a method non-inlinable) for the intrinsic method call.
@
text
@d937 1
a937 1
				c.Compile(b, c.ComputePartialReachability(0, true));
d949 1
a949 1
				c.Compile(b, c.ComputePartialReachability(0, true));
d1173 1
a1173 1
	private void Compile(Block block, InstructionFlags[] flags)
d1175 1
d1181 15
d1240 3
a1242 1
					Compile(new Block(this, 0, block.EndIndex, -1, null, false), ComputePartialReachability(handlerIndex, true));
@


1.191
log
@Added another optimization to convert synchronized blocks into try {} finally {} (instead of try {} fault {}).
@
text
@a1583 1
					nonleaf = true;
d1591 2
a1592 1
					if(method.IsIntrinsic && method.EmitIntrinsic(new EmitIntrinsicContext(method, context, ilGenerator, ma, i, mw, classFile, code, flags)))
d1594 1
d1598 2
@


1.190
log
@- Made CodeEmitter more "type safe" by adding specific EmitXxx methods instead of following the more general ILGenerator pattern.
- Added some new optimizations to CodeEmitter (disabled unless experimental optimizations are enabled).
- Added some invariant checks to CodeEmitter to help debug optimizations (and document the invariants).
@
text
@a387 2
	private static readonly MethodInfo monitorEnterMethod;
	private static readonly MethodInfo monitorExitMethod;
a421 2
		monitorEnterMethod = JVM.Import(typeof(System.Threading.Monitor)).GetMethod("Enter", BindingFlags.Static | BindingFlags.Public, null, new Type[] { Types.Object }, null);
		monitorExitMethod = JVM.Import(typeof(System.Threading.Monitor)).GetMethod("Exit", BindingFlags.Static | BindingFlags.Public, null, new Type[] { Types.Object }, null);
d934 1
a934 1
				ilGenerator.Emit(OpCodes.Call, monitorEnterMethod);
d941 1
a941 1
				ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
d2726 1
a2726 1
					ilGenerator.Emit(OpCodes.Call, monitorEnterMethod);
d2729 1
a2729 1
					ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
@


1.189
log
@Prevent the tail call elimination opcode sequence (ldnull/pop) from being optimized out.
@
text
@d569 1
a569 1
					ilGenerator.Emit(OpCodes.Ldarg_S, (byte)arg);
d629 2
a630 1
						ilGenerator.Emit(OpCodes.Ldarga, (short)i);
d887 1
a887 1
				ilGenerator.Emit(OpCodes.Ldarg, (short)(i + (m.IsStatic ? 0 : 1)));
d1103 1
a1103 1
							ilgen.Emit(OpCodes.Br, bc.TargetLabel);
d1108 1
a1108 1
							ilgen.Emit(OpCodes.Leave, bc.Stub);
d1151 1
a1151 1
								ilgen.Emit(OpCodes.Br, newBlock.GetLabel(bc.TargetIndex));
d1268 1
a1268 1
						ilGenerator.Emit_Ldc_I4(mapFlags | 1);
d1273 1
a1273 1
						ilGenerator.Emit_Ldc_I4(mapFlags);
d1278 1
a1278 1
						ilGenerator.Emit_Ldc_I4(mapFlags | (remap ? 0 : 1));
d1292 1
a1292 1
						ilGenerator.Emit(OpCodes.Brtrue_S, leave);
d1306 1
a1306 1
					ilGenerator.Emit(OpCodes.Leave, bc.Stub);
d1499 1
a1499 1
					ilGenerator.Emit_Ldc_I4(instr.NormalizedArg1);
d1502 1
a1502 1
					ilGenerator.Emit(OpCodes.Ldc_I8, 0L);
d1505 1
a1505 1
					ilGenerator.Emit(OpCodes.Ldc_I8, 1L);
d1510 1
a1510 1
					ilGenerator.Emit(OpCodes.Ldc_R4, 0.0f);
d1515 1
a1515 1
					ilGenerator.Emit(OpCodes.Ldc_R4, 1.0f);
d1518 1
a1518 1
					ilGenerator.Emit(OpCodes.Ldc_R4, 2.0f);
d1894 1
a1894 1
						ilGenerator.Emit(OpCodes.Leave, label);
d1931 1
a1931 1
								ilGenerator.Emit(OpCodes.Leave_S, (byte)0);
d1943 1
a1943 1
								ilGenerator.Emit(OpCodes.Leave_S, (byte)0);
d2055 1
a2055 1
					ilGenerator.Emit_Ldc_I4(instr.Arg2);
d2062 1
a2062 1
						ilGenerator.Emit_Ldc_I4(instr.Arg2 - j);
d2311 1
a2311 1
					ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.TargetIndex));
d2314 1
a2314 1
					ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.TargetIndex));
d2317 1
a2317 1
					ilGenerator.Emit(OpCodes.Ble, block.GetLabel(instr.TargetIndex));
d2320 1
a2320 1
					ilGenerator.Emit(OpCodes.Blt, block.GetLabel(instr.TargetIndex));
d2323 1
a2323 1
					ilGenerator.Emit(OpCodes.Bge, block.GetLabel(instr.TargetIndex));
d2326 1
a2326 1
					ilGenerator.Emit(OpCodes.Bgt, block.GetLabel(instr.TargetIndex));
d2342 1
a2342 1
					ilGenerator.Emit(OpCodes.Brtrue, block.GetLabel(instr.TargetIndex));
d2346 1
a2346 1
					ilGenerator.Emit(OpCodes.Brfalse, block.GetLabel(instr.TargetIndex));
d2349 1
a2349 1
					ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.TargetIndex));
d2352 1
a2352 1
					ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.TargetIndex));
d2356 1
a2356 1
					ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.TargetIndex));
d2452 1
a2452 1
					ilGenerator.Emit(OpCodes.Bne_Un_S, label);
d2461 1
a2461 1
					ilGenerator.Emit(OpCodes.Br_S, label2);
d2768 1
a2768 1
						ilGenerator.Emit_Ldc_I4(instr.GetSwitchValue(0));
d2771 2
a2772 2
					ilGenerator.Emit(OpCodes.Switch, labels);
					ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.DefaultTarget));
d2779 1
a2779 1
						ilGenerator.Emit_Ldc_I4(instr.GetSwitchValue(j));
d2781 1
a2781 1
						ilGenerator.Emit(OpCodes.Bne_Un_S, label);
d2783 1
a2783 1
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.GetSwitchTargetIndex(j)));
d2787 1
a2787 1
					ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.DefaultTarget));
d2791 1
a2791 1
					ilGenerator.Emit_Ldc_I4(instr.Arg2);
d2920 1
a2920 1
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(i + 1));
d2934 1
a2934 1
				ilgen.Emit(OpCodes.Ldc_R8, classFile.GetConstantPoolConstantDouble(constant));
d2937 1
a2937 1
				ilgen.Emit(OpCodes.Ldc_R4, classFile.GetConstantPoolConstantFloat(constant));
d2940 1
a2940 1
				ilgen.Emit(OpCodes.Ldc_I4, classFile.GetConstantPoolConstantInteger(constant));
d2943 1
a2943 1
				ilgen.Emit(OpCodes.Ldc_I8, classFile.GetConstantPoolConstantLong(constant));
d3053 1
a3053 1
			ilgen.Emit(OpCodes.Leave_S, label);
d3056 1
a3056 1
			ilgen.Emit(OpCodes.Leave_S, label);
d3069 1
a3069 1
				ilgen.Emit(OpCodes.Ldarg, (short)i);
d3123 1
a3123 1
				ilgen.Emit(OpCodes.Ldc_I4, varArgs);
d3129 1
a3129 1
					ilgen.Emit(OpCodes.Ldc_I4, i);
d3346 1
a3346 1
					ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
d3362 1
a3362 1
						ilgen.Emit(OpCodes.Ldarga_S, (byte)packedArgPos);
d3375 1
a3375 1
					ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
d3451 1
a3451 1
				ilgen.Emit(OpCodes.Ldarg_S, (byte)i);
d3810 1
a3810 1
			ilGenerator.Emit(OpCodes.Ldc_I4, args.Length);
d3821 1
a3821 1
				ilGenerator.Emit(OpCodes.Ldc_I4, i);
d3915 1
a3915 25
			switch(i)
			{
				case 0:
					ilGenerator.Emit(OpCodes.Ldarg_0);
					break;
				case 1:
					ilGenerator.Emit(OpCodes.Ldarg_1);
					break;
				case 2:
					ilGenerator.Emit(OpCodes.Ldarg_2);
					break;
				case 3:
					ilGenerator.Emit(OpCodes.Ldarg_3);
					break;
				default:
					if(i < 256)
					{
						ilGenerator.Emit(OpCodes.Ldarg_S, (byte)i);
					}
					else
					{
						ilGenerator.Emit(OpCodes.Ldarg, (short)i);
					}
					break;
			}
d3956 1
a3956 8
			if(i < 256)
			{
				ilGenerator.Emit(OpCodes.Starg_S, (byte)i);
			}
			else
			{
				ilGenerator.Emit(OpCodes.Starg, (short)i);
			}
@


1.188
log
@Added support to ikvmc to automatically set the full source path in the debugging info if the source file lives next to the .class file.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d1948 1
a1948 2
								ilGenerator.Emit(OpCodes.Ldnull);
								ilGenerator.Emit(OpCodes.Pop);
@


1.187
log
@When instantiating a delegate and the object passed in does not properly implement the delegate's Method interface, bind the delegate to an error stub that throws the appropriate error.
@
text
@d855 1
a855 2
			string sourcefile = classFile.SourceFileAttribute;
			if(sourcefile != null)
d857 1
a857 8
				if(classLoader.SourcePath != null)
				{
					string package = clazz.Name;
					int index = package.LastIndexOf('.');
					package = index == -1 ? "" : package.Substring(0, index).Replace('.', '/');
					sourcefile = new System.IO.FileInfo(classLoader.SourcePath + "/" + package + "/" + sourcefile).FullName;
				}
				ilGenerator.DefineSymbolDocument(classLoader.GetTypeWrapperFactory().ModuleBuilder, sourcefile, SymLanguageType.Java, Guid.Empty, SymDocumentType.Text);
@


1.186
log
@More TypeAsBuiler usage removed.
@
text
@d74 1
d124 1
@


1.185
log
@Removed TypeAsBuilder usage from method handle code.
@
text
@d3452 1
a3452 1
			MethodBuilder stub = dmh.DefineMethod(clazz, "__<>", MethodAttributes.PrivateScope);
@


1.184
log
@Moved indy call site state into FinishContext.
@
text
@d3264 1
a3264 1
			TypeBuilder tb = compiler.clazz.TypeAsBuilder.DefineNestedType("__<>MHC" + index, TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit);
a3328 1
			tb.CreateType();
d3344 1
a3344 1
			MethodBuilder mb = compiler.clazz.TypeAsBuilder.DefineMethod("__<>MHC", MethodAttributes.Static | MethodAttributes.PrivateScope, ret, args);
d3763 1
a3763 1
				FieldBuilder fb = wrapper.TypeAsBuilder.DefineField("__<>invokeCache", typeofInvokeCache.MakeGenericType(delegateType), FieldAttributes.Static | FieldAttributes.PrivateScope);
@


1.183
log
@When casting arguments we should use the actual method parameter types, instead of the call site types (which can differ in the case of unloadable types (with crazy class loader trickery)).
@
text
@d2986 1
a2986 1
	private sealed class InvokeDynamicBuilder
a2990 1
		private int count;
d3009 1
a3009 1
		internal void Emit(Compiler compiler, ClassFile.ConstantPoolItemInvokeDynamic cpi, Type delegateType)
d3024 1
a3024 1
			TypeBuilder tb = compiler.clazz.TypeAsBuilder.DefineNestedType("__<>IndyCS" + (count++), TypeAttributes.NestedPrivate | TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit);
a3034 1
			tb.CreateType();
d3241 1
a3241 1
		context.GetValue<InvokeDynamicBuilder>(0).Emit(this, cpi, delegateType);
@


1.182
log
@Introduced DefineMethodHelper class as an abstraction over method signatures (the parameter/return types) to make it easier to start using modopt for methods.
@
text
@d1561 1
a1561 1
					CastInterfaceArgs(method.DeclaringType, cpi.GetArgTypes(), i, false);
d1628 1
a1628 2
						TypeWrapper[] args = cpi.GetArgTypes();
						CastInterfaceArgs(method.DeclaringType, args, i, false);
d1633 1
a1633 1
						TypeWrapper[] methodArgs = cpi.GetArgTypes();
@


1.181
log
@Added support for classes that represent arrays of remapped .NET types and .NET primitives.
@
text
@d3455 2
a3456 1
			MethodBuilder stub = clazz.TypeAsBuilder.DefineMethod("__<>", MethodAttributes.PrivateScope, method.ReturnTypeForDefineMethod, method.GetParametersForDefineMethod());
d3459 1
a3459 2
			int argc = method.GetParametersForDefineMethod().Length;
			for(int i = 1; i <= argc; i++)
@


1.180
log
@Added workaround for another x64 JIT bug.
See https://sourceforge.net/mailarchive/message.php?msg_id=28250469
@
text
@d390 1
d452 2
@


1.179
log
@Implemented invokedynamic instruction.
@
text
@d576 54
@


1.178
log
@Added support for MethodHandle constants (ldc <MethodHandle>).
@
text
@d86 1
d135 1
d1470 3
d1474 5
a1478 2
					int constant = instr.Arg1;
					switch(classFile.GetConstantPoolConstantType(constant))
d1480 9
a1488 44
						case ClassFile.ConstantType.Double:
							ilGenerator.Emit(OpCodes.Ldc_R8, classFile.GetConstantPoolConstantDouble(constant));
							break;
						case ClassFile.ConstantType.Float:
							ilGenerator.Emit(OpCodes.Ldc_R4, classFile.GetConstantPoolConstantFloat(constant));
							break;
						case ClassFile.ConstantType.Integer:
							ilGenerator.Emit(OpCodes.Ldc_I4, classFile.GetConstantPoolConstantInteger(constant));
							break;
						case ClassFile.ConstantType.Long:
							ilGenerator.Emit(OpCodes.Ldc_I8, classFile.GetConstantPoolConstantLong(constant));
							break;
						case ClassFile.ConstantType.String:
							ilGenerator.Emit(OpCodes.Ldstr, classFile.GetConstantPoolConstantString(constant));
							break;
						case ClassFile.ConstantType.Class:
						{
							TypeWrapper tw = classFile.GetConstantPoolClassType(constant);
							if(tw.IsUnloadable)
							{
								Profiler.Count("EmitDynamicClassLiteral");
								ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
								ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
								ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicClassLiteral);
								java_lang_Class.EmitCheckcast(clazz, ilGenerator);
							}
							else
							{
								tw.EmitClassLiteral(ilGenerator);
							}
							break;
						}
						case ClassFile.ConstantType.MethodHandle:
							context.GetValue<MethodHandleConstant>(instr.Arg1).Emit(this, instr.Arg1);
							break;
						case ClassFile.ConstantType.MethodType:
						{
							ClassFile.ConstantPoolItemMethodType cpi = classFile.GetConstantPoolConstantMethodType(instr.Arg1);
							Type delegateType = MethodHandleUtil.CreateDelegateTypeForLoadConstant(cpi.GetArgTypes(), cpi.GetRetType());
							ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.LoadMethodType.MakeGenericMethod(delegateType));
							break;
						}
						default:
							throw new InvalidOperationException();
d1490 1
d1504 1
a1504 1
					CastInterfaceArgs(method, cpi.GetArgTypes(), i, false);
d1572 1
a1572 1
						CastInterfaceArgs(method, args, i, false);
d1597 1
a1597 1
						CastInterfaceArgs(method, args, i, true);
d2879 52
a2930 1
	private sealed class MethodHandleConstant
d2932 157
a3088 1
		private FieldBuilder field;
d3090 1
a3090 1
		internal void Emit(Compiler compiler, int index)
d3092 33
a3124 1
			if (field == null)
d3126 1
a3126 7
				TypeBuilder tb = compiler.clazz.TypeAsBuilder.DefineNestedType("__<>MHC" + index, TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit);
				field = tb.DefineField("value", CoreClasses.java.lang.invoke.MethodHandle.Wrapper.TypeAsSignatureType, FieldAttributes.Assembly | FieldAttributes.Static | FieldAttributes.InitOnly);
				ConstructorBuilder cb = tb.DefineConstructor(MethodAttributes.Static, CallingConventions.Standard, Type.EmptyTypes);
				ILGenerator ilgen = cb.GetILGenerator();
				ClassFile.ConstantPoolItemMethodHandle mh = compiler.classFile.GetConstantPoolConstantMethodHandle(index);
				Type delegateType;
				switch (mh.Kind)
d3128 3
a3130 39
					case ClassFile.RefKind.getField:
						delegateType = MethodHandleUtil.CreateDelegateType(new TypeWrapper[] { mh.Member.DeclaringType }, ((FieldWrapper)mh.Member).FieldTypeWrapper);
						break;
					case ClassFile.RefKind.putField:
						delegateType = MethodHandleUtil.CreateDelegateType(new TypeWrapper[] { mh.Member.DeclaringType, ((FieldWrapper)mh.Member).FieldTypeWrapper }, PrimitiveTypeWrapper.VOID);
						break;
					case ClassFile.RefKind.getStatic:
						delegateType = MethodHandleUtil.CreateDelegateType(TypeWrapper.EmptyArray, ((FieldWrapper)mh.Member).FieldTypeWrapper);
						break;
					case ClassFile.RefKind.putStatic:
						delegateType = MethodHandleUtil.CreateDelegateType(new TypeWrapper[] { ((FieldWrapper)mh.Member).FieldTypeWrapper }, PrimitiveTypeWrapper.VOID);
						break;
					case ClassFile.RefKind.invokeInterface:
					case ClassFile.RefKind.invokeSpecial:
					case ClassFile.RefKind.invokeVirtual:
					case ClassFile.RefKind.invokeStatic:
						if (mh.Member == null)
						{
							// it MethodHandle.invoke[Exact]
							ClassFile.ConstantPoolItemMI cpi = (ClassFile.ConstantPoolItemMI)mh.MemberConstantPoolItem;
							TypeWrapper[] args = new TypeWrapper[cpi.GetArgTypes().Length + 1];
							args[0] = mh.GetClassType();
							Array.Copy(cpi.GetArgTypes(), 0, args, 1, args.Length - 1);
							delegateType = MethodHandleUtil.CreateDelegateType(args, cpi.GetRetType());
						}
						else if (mh.Member.IsProtected && !mh.Member.IsAccessibleFrom(mh.GetClassType(), compiler.clazz, mh.GetClassType()))
						{
							delegateType = MethodHandleUtil.CreateDelegateType(compiler.clazz, (MethodWrapper)mh.Member);
						}
						else
						{
							delegateType = MethodHandleUtil.CreateDelegateType(mh.GetClassType(), (MethodWrapper)mh.Member);
						}
						break;
					case ClassFile.RefKind.newInvokeSpecial:
						delegateType = MethodHandleUtil.CreateDelegateType(((MethodWrapper)mh.Member).GetParameters(), mh.Member.DeclaringType);
						break;
					default:
						throw new InvalidOperationException();
d3132 1
a3132 4
				MethodInfo method;
				if (mh.Kind == ClassFile.RefKind.invokeStatic
					&& (method = (MethodInfo)((MethodWrapper)mh.Member).GetMethod()) != null
					&& ((MethodWrapper)mh.Member).GetParameters().Length <= MethodHandleUtil.MaxArity)
d3134 4
a3137 1
					// we can create a delegate that directly points to the target method
d3139 1
a3139 1
				else
d3141 1
a3141 1
					method = CreateDispatchStub(compiler, mh, delegateType);
d3143 29
a3171 7
				ilgen.Emit(OpCodes.Ldnull);
				ilgen.Emit(OpCodes.Ldftn, method);
				ilgen.Emit(OpCodes.Newobj, MethodHandleUtil.GetDelegateConstructor(delegateType));
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.MethodHandleFromDelegate);
				ilgen.Emit(OpCodes.Stsfld, field);
				ilgen.Emit(OpCodes.Ret);
				tb.CreateType();
d3173 104
a3276 1
			compiler.ilGenerator.Emit(OpCodes.Ldsfld, field);
d3416 1
a3416 1
	private void CastInterfaceArgs(MethodWrapper method, TypeWrapper[] args, int instructionIndex, bool instanceMethod)
d3460 1
a3460 1
					if(i == 0 && instanceMethod && method.DeclaringType != args[i])
d3519 1
a3519 1
					if(i == 0 && instanceMethod && !method.DeclaringType.IsInterface)
d3551 1
a3551 1
								if(method.DeclaringType == args[i])
@


1.177
log
@Added support for MethodType constants (ldc <MethodType>).
@
text
@d85 1
d133 1
d263 12
d1504 3
d2816 1
d2844 12
d2859 4
d2869 4
d2905 170
@


1.176
log
@Bug fix. The "ldc <class>" bytecode can throw an exception, so we need to treat it as such (previously it wasn't marked as throwing an exception, so an exception handler surrounding it could be "optimized" away). The new scheme is to patch the safe versions of ldc opcode into a ldc_nothrow.
@
text
@d84 1
d131 1
d283 28
d1490 7
@


1.175
log
@Workaround Mono bug.
@
text
@d1422 1
@


1.174
log
@Implemented full arity support for MethodHandle.
@
text
@d221 1
a221 3
		MethodInfo invokeMethod = GetDelegateInvokeMethod(delegateType);
		ParameterInfo[] pi = invokeMethod.GetParameters();
		if (pi.Length > 0 && IsPackedArgsContainer(pi[pi.Length - 1].ParameterType))
d223 10
a232 1
			WrapArgs(ilgen, pi[pi.Length - 1].ParameterType);
d234 1
a234 1
		ilgen.Emit(OpCodes.Callvirt, invokeMethod);
@


1.173
log
@Fixed MethodHandle.invoke() caching. We were caching the instance, instead of just the type.
@
text
@d159 81
d266 11
a276 3
		string typeName;
		Type[] typeArgs;
		if (ret == PrimitiveTypeWrapper.VOID)
d278 14
a291 2
			typeName = "IKVM.Runtime.MHV";
			if (args.Length != 0)
d293 3
a295 1
				typeName += "`" + args.Length;
d297 2
a298 1
			typeArgs = new Type[args.Length];
d300 1
a300 1
		else
d302 1
a302 3
			typeName = "IKVM.Runtime.MH`" + (args.Length + 1);
			typeArgs = new Type[args.Length + 1];
			typeArgs[args.Length] = ret.TypeAsSignatureType;
d304 1
a304 1
		for (int i = 0; i < args.Length; i++)
d306 3
a308 1
			typeArgs[i] = args[i].TypeAsSignatureType;
d310 13
a322 13
		Type type;
#if STATIC_COMPILER
		type = StaticCompiler.GetRuntimeType(typeName);
#else
		type = Type.GetType(typeName);
#endif
		if (type == null)
		{
			throw new NotImplementedException(typeName);
		}
		return typeArgs.Length == 0
			? type
			: type.MakeGenericType(typeArgs);
d3126 3
d3131 2
a3132 2
				TypeWrapper[] args = cpi.GetArgTypes();
				CodeEmitterLocal[] temps = new CodeEmitterLocal[args.Length];
d3138 1
a3138 1
				Type delegateType = MethodHandleUtil.CreateDelegateType(args, cpi.GetRetType());
a3140 5
				for (int i = 0; i < args.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldloc, temps[i]);
				}
				ilgen.Emit(OpCodes.Callvirt, MethodHandleUtil.GetDelegateInvokeMethod(delegateType));
d3144 1
a3144 1
				TypeWrapper[] args = new TypeWrapper[cpi.GetArgTypes().Length + 1];
d3147 1
a3147 1
				CodeEmitterLocal[] temps = new CodeEmitterLocal[args.Length];
d3153 1
a3153 1
				Type delegateType = MethodHandleUtil.CreateDelegateType(args, cpi.GetRetType());
a3164 5
				for (int i = 0; i < args.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldloc, temps[i]);
				}
				ilgen.Emit(OpCodes.Callvirt, MethodHandleUtil.GetDelegateInvokeMethod(delegateType));
d3166 5
@


1.172
log
@Implemented a large chunk of MethodHandle support.
@
text
@a3021 8
			TypeWrapper[] args = cpi.GetArgTypes();
			CodeEmitterLocal[] temps = new CodeEmitterLocal[args.Length];
			for (int i = args.Length - 1; i >= 0; i--)
			{
				temps[i] = ilgen.DeclareLocal(args[i].TypeAsSignatureType);
				ilgen.Emit(OpCodes.Stloc, temps[i]);
			}
			Type delegateType = MethodHandleUtil.CreateDelegateType(args, cpi.GetRetType());
d3024 8
d3034 5
d3042 10
d3060 1
d3063 5
a3068 5
			for (int i = 0; i < args.Length; i++)
			{
				ilgen.Emit(OpCodes.Ldloc, temps[i]);
			}
			ilgen.Emit(OpCodes.Callvirt, MethodHandleUtil.GetDelegateInvokeMethod(delegateType));
@


1.171
log
@Merge in java.lang.invoke package and the beginnings of MethodHandle support.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2010 Jeroen Frijters
d82 2
a83 1
	internal static readonly MethodInfo getDelegate;
d128 2
a129 1
		getDelegate = typeofByteCodeHelper.GetMethod("GetDelegate");
d157 65
d3004 1
d3006 1
a3006 1
		internal MethodHandleMethodWrapper(DynamicTypeWrapper.FinishContext context, TypeWrapper wrapper, ClassFile.ConstantPoolItemMI cpi)
d3012 1
d3026 1
a3026 1
				temps[i] = ilgen.DeclareLocal(args[i].TypeAsLocalOrStackType);
d3029 2
a3030 4
			Type delegateType = CreateDelegateType(args, cpi.GetRetType());
			MethodInfo mi = ByteCodeHelperMethods.getDelegate.MakeGenericMethod(delegateType);
			ilgen.Emit(OpCodes.Call, mi);
			for (int i = 0; i < args.Length; i++)
d3032 2
a3033 1
				ilgen.Emit(OpCodes.Ldloc, temps[i]);
d3035 1
a3035 1
			if (ReflectUtil.ContainsTypeBuilder(delegateType))
d3037 10
a3046 1
				ilgen.Emit(OpCodes.Callvirt, TypeBuilder.GetMethod(delegateType, delegateType.GetGenericTypeDefinition().GetMethod("Invoke")));
d3048 1
a3048 1
			else
d3050 1
a3050 1
				ilgen.Emit(OpCodes.Callvirt, delegateType.GetMethod("Invoke"));
d3052 1
a3060 38
	internal static Type CreateDelegateType(TypeWrapper[] args, TypeWrapper ret)
	{
		string typeName;
		Type[] typeArgs;
		if (ret == PrimitiveTypeWrapper.VOID)
		{
			typeName = "IKVM.Runtime.MHV";
			if (args.Length != 0)
			{
				typeName += "`" + args.Length;
			}
			typeArgs = new Type[args.Length];
		}
		else
		{
			typeName = "IKVM.Runtime.MH`" + (args.Length + 1);
			typeArgs = new Type[args.Length + 1];
			typeArgs[args.Length] = ret.TypeAsSignatureType;
		}
		for (int i = 0; i < args.Length; i++)
		{
			typeArgs[i] = args[i].TypeAsSignatureType;
		}
		Type type;
#if STATIC_COMPILER
		type = StaticCompiler.GetRuntimeType(typeName);
#else
		type = Type.GetType(typeName);
#endif
		if (type == null)
		{
			throw new NotImplementedException();
		}
		return typeArgs.Length == 0
			? type
			: type.MakeGenericType(typeArgs);
	}

d3159 1
d3161 1
a3161 1
				return new MethodHandleMethodWrapper(context, clazz, cpi);
@


1.170
log
@Fixed regression introduced with fault handlers. Exception handlers inside fault handlers could be ignored.
@
text
@d82 1
d127 1
d1325 2
d2932 89
d3118 3
@


1.170.2.1
log
@Backport: Added workaround for another x64 JIT bug.
See https://sourceforge.net/mailarchive/message.php?msg_id=28250469
@
text
@a349 54

		Workaroundx64JitBug(args);
	}

	// workaround for x64 JIT bug
	// https://connect.microsoft.com/VisualStudio/feedback/details/636466/variable-is-not-incrementing-in-c-release-x64#details
	// (see also https://sourceforge.net/mailarchive/message.php?msg_id=28250469)
	private void Workaroundx64JitBug(TypeWrapper[] args)
	{
		if(args.Length > (m.IsStatic ? 4 : 3) && m.ExceptionTable.Length != 0)
		{
			bool[] workarounds = null;
			InstructionFlags[] flags = ComputePartialReachability(0, false);
			for(int i = 0; i < m.Instructions.Length; i++)
			{
				if((flags[i] & InstructionFlags.Reachable) == 0)
				{
					// skip unreachable instructions
				}
				else
				{
					switch(m.Instructions[i].NormalizedOpCode)
					{
						case NormalizedByteCode.__iinc:
						case NormalizedByteCode.__astore:
						case NormalizedByteCode.__istore:
						case NormalizedByteCode.__lstore:
						case NormalizedByteCode.__fstore:
						case NormalizedByteCode.__dstore:
							int arg = m.IsStatic ? m.Instructions[i].Arg1 : m.Instructions[i].Arg1 - 1;
							if(arg >= 3 && arg < args.Length)
							{
								if(workarounds == null)
								{
									workarounds = new bool[args.Length + 1];
								}
								workarounds[m.Instructions[i].Arg1] = true;
							}
							break;
					}
				}
			}
			if(workarounds != null)
			{
				for(int i = 0; i < workarounds.Length; i++)
				{
					if(workarounds[i])
					{
						ilGenerator.Emit(OpCodes.Ldarga, (short)i);
						ilGenerator.Emit(OpCodes.Pop);
					}
				}
			}
		}
@


1.170.2.2
log
@Backported fixes for 0.46.0.3:
- Bug fix. java.lang.Package was not populated from manifest for ikvmc compiled assemblies.
- Bug fix. When writing a direct ByteBuffer to a non-blocking socket and the write fails because there is no kernel buffer available, we should not advance the ByteBuffer position.
- Bug fix. When adding certificates to virtual cacerts file make sure that the aliases are unique.
- Bug fix. If a finally/fault handler contains reachable code before the handler's start index, the handler should branch to the handler start index.
- Bug fix. After emitting a finally/fault handler block, we should emit the block leave stubs (even though you can't leave the block, they also emit the backward branch stubs).
- Bug fix. If a Java class extends a remapped .NET type (cli.System.Object or cli.System.Exception), we should correctly report the base class.
- Bug fix. If we encounter a jsr or ret instruction, we should throw a VerifyError (instead of NotImplementedException).
- Bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
- Disable AppDomain.ProcessExit hook to run shutdown hooks when running on Mono to workaround https://bugzilla.xamarin.com/show_bug.cgi?id=5650
- Bug fix. Custom attribute properties that don't have a public getter and setter should not be exposed as annotation properties.
- Bug fix. Non-public property getter/setter methods should be ignored when we create properties to hide properties inherited from shadow types. This fixes a build break with .NET 4.5 beta which introduces a protected setter for Exception.HResult.
- Bug fix. The $Method inner class for delegates should also be loadable for generic delegates. Thanks to Michael Bayne for reporting this.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Replaced non-ascii character (micro) with ascii 'u' in Win32PrintService.java.
- IKVM.Reflection: Bug fix. Resource Directory Entries must be sorted and names are case-insensitive

Backported for 0.46.0.4:
- Fixed ikvmc to retain transient modifier on constant static final fields.
- Fixed Field.getModifiers() to only return the relevant modifiers.
- Fixed IKVM.Reflection to set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@d717 1
a717 1
				c.Compile(b, 0);
d729 1
a729 1
				c.Compile(b, 0);
d953 1
a953 1
	private void Compile(Block block, int startIndex)
a954 1
		InstructionFlags[] flags = ComputePartialReachability(startIndex, true);
a959 15
 		if(startIndex != 0)
 		{
 			for(int i = 0; i < flags.Length; i++)
 			{
 				if((flags[i] & InstructionFlags.Reachable) != 0)
 				{
 					if(i < startIndex)
 					{
 						instructionIsForwardReachable = false;
 						ilGenerator.Emit(OpCodes.Br, block.GetLabel(startIndex));
 					}
 					break;
 				}
 			}
 		}
d1004 1
a1004 3
 					Block b = new Block(this, 0, block.EndIndex, -1, null, false);
 					Compile(b, handlerIndex);
 					b.Leave();
@


1.169
log
@- Removed EndExceptionBlockFinally and folded the behaviour into EndExceptionBlock (runtime compiler only).
- Removed EndExceptionBlockNoFallThrough() and added "leave guard" branch after every EndExceptionBlock (runtime compiler only).
- Fixed remaining dependencies on exception fall through behavior of ILGenerator.
@
text
@d950 1
a950 1
					Compile(new Block(this, 0, block.EndIndex, exceptionIndex, null, false), ComputePartialReachability(handlerIndex, true));
@


1.168
log
@Don't depend on leave/endfinally instructions being inserted automatically by ILGenerator.
@
text
@d669 1
a669 1
				ilGenerator.EndExceptionBlockNoFallThrough();
d951 1
a951 1
					ilGenerator.EndExceptionBlockNoFallThrough();
d1029 1
a1029 1
					ilGenerator.EndExceptionBlockNoFallThrough();
@


1.167
log
@- Removed unnecessary methods from CodeEmitter.
- Removed "Lazy" prefixes in CodeEmitter.
@
text
@d668 1
@


1.166
log
@Build intermediate store of MSIL code in CodeEmitter to allow post-processing optimization steps.
@
text
@d550 1
a550 1
					compiler.ilGenerator.LazyEmitPop();
d989 1
a989 1
						ilGenerator.LazyEmitLdc_I4(mapFlags | 1);
d994 1
a994 1
						ilGenerator.LazyEmitLdc_I4(mapFlags);
d999 1
a999 1
						ilGenerator.LazyEmitLdc_I4(mapFlags | (remap ? 0 : 1));
d1217 1
a1217 1
					ilGenerator.LazyEmitLdnull();
d1220 1
a1220 1
					ilGenerator.LazyEmitLdc_I4(instr.NormalizedArg1);
d1223 1
a1223 1
					ilGenerator.LazyEmitLdc_I8(0);
d1226 1
a1226 1
					ilGenerator.LazyEmitLdc_I8(1);
d1253 1
a1253 1
							ilGenerator.LazyEmitLdc_I4(classFile.GetConstantPoolConstantInteger(constant));
d1256 1
a1256 1
							ilGenerator.LazyEmitLdc_I8(classFile.GetConstantPoolConstantLong(constant));
d1259 1
a1259 1
							ilGenerator.LazyEmitLdstr(classFile.GetConstantPoolConstantString(constant));
d1274 1
a1274 1
								ilGenerator.LazyEmitLoadClass(tw);
d1741 1
a1741 1
						ilGenerator.LazyEmitPop();
d1793 1
a1793 1
					ilGenerator.LazyEmitLdc_I4(instr.Arg2);
d1800 1
a1800 1
						ilGenerator.LazyEmitLdc_I4(instr.Arg2 - j);
d1944 1
a1944 1
					ilGenerator.LazyEmit_baload();
d2034 1
a2034 1
					ilGenerator.LazyEmit_lcmp();
d2037 1
a2037 1
					ilGenerator.LazyEmit_fcmpl();
d2040 1
a2040 1
					ilGenerator.LazyEmit_fcmpg();
d2043 1
a2043 1
					ilGenerator.LazyEmit_dcmpl();
d2046 1
a2046 1
					ilGenerator.LazyEmit_dcmpg();
d2067 1
a2067 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CodeEmitter.Comparison.LessOrEqual, block.GetLabel(instr.TargetIndex));
d2070 1
a2070 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CodeEmitter.Comparison.LessThan, block.GetLabel(instr.TargetIndex));
d2073 1
a2073 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CodeEmitter.Comparison.GreaterOrEqual, block.GetLabel(instr.TargetIndex));
d2076 1
a2076 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CodeEmitter.Comparison.GreaterThan, block.GetLabel(instr.TargetIndex));
a2078 5
					ilGenerator.LazyEmit_ifne(block.GetLabel(instr.TargetIndex));
					break;
				case NormalizedByteCode.__ifeq:
					ilGenerator.LazyEmit_ifeq(block.GetLabel(instr.TargetIndex));
					break;
d2082 1
a2140 2
					ilGenerator.LazyEmit_iand();
					break;
d2142 1
a2142 1
					ilGenerator.LazyEmit_land();
d2160 1
a2160 1
					ilGenerator.LazyEmit_idiv();
d2163 1
a2163 1
					ilGenerator.LazyEmit_ldiv();
d2217 1
a2217 1
					ilGenerator.LazyEmitAnd_I4(31);
d2221 1
a2221 1
					ilGenerator.LazyEmitAnd_I4(63);
d2225 1
a2225 1
					ilGenerator.LazyEmitAnd_I4(31);
d2229 1
a2229 1
					ilGenerator.LazyEmitAnd_I4(63);
d2233 1
a2233 1
					ilGenerator.LazyEmitAnd_I4(31);
d2237 1
a2237 1
					ilGenerator.LazyEmitAnd_I4(63);
d2445 1
a2445 1
						ilGenerator.LazyEmitPop();
d2451 1
a2451 1
							ilGenerator.LazyEmitPop();
d2455 1
a2455 1
							ilGenerator.LazyEmitPop();
d2464 1
a2464 1
						ilGenerator.LazyEmitPop();
d2506 1
a2506 1
						ilGenerator.LazyEmitLdc_I4(instr.GetSwitchValue(0));
d2517 1
a2517 1
						ilGenerator.LazyEmitLdc_I4(instr.GetSwitchValue(j));
d2529 1
a2529 1
					ilGenerator.LazyEmitLdc_I4(instr.Arg2);
d2558 1
a2558 1
					ilGenerator.LazyEmit_i2l();
d2828 1
a2828 1
									ilGenerator.LazyEmitUnbox(args[i].TypeAsTBD);
d3122 1
a3122 1
			ilGenerator.LazyEmitPop();
d3139 1
a3139 1
			ilGenerator.LazyEmitPop();
@


1.165
log
@Wrapped LocalBuilder in new CodeEmitterLocal class to allow CodeEmitter to encapsulate the ILGenerator fully.
@
text
@d2689 1
@


1.164
log
@Moved line number / sequence point handling into CodeEmitter and made things more consistent.
@
text
@d406 1
a406 1
		private LocalBuilder local;
d408 1
a408 1
		internal ReturnCookie(CodeEmitterLabel stub, LocalBuilder local)
d461 1
a461 1
		private LocalBuilder[] locals;
d467 1
a467 1
			locals = new LocalBuilder[count];
d472 1
a472 1
			foreach(LocalBuilder lb in locals)
d658 1
a658 1
				LocalBuilder monitor = ilGenerator.DeclareLocal(Types.Object);
d1456 1
a1456 1
								LocalBuilder newobj = ilGenerator.DeclareLocal(GetLocalBuilderType(thisType));
d1458 1
a1458 1
								LocalBuilder[] tempstack = new LocalBuilder[stackfix.Length];
d1474 1
a1474 1
											LocalBuilder lb = ilGenerator.DeclareLocal(GetLocalBuilderType(stacktype));
d1621 1
a1621 1
						LocalBuilder local = null;
d1678 1
a1678 1
								LocalBuilder local = ilGenerator.AllocTempLocal(retTypeWrapper.TypeAsSignatureType);
d1791 2
a1792 2
					LocalBuilder localArray = ilGenerator.UnsafeAllocTempLocal(JVM.Import(typeof(int[])));
					LocalBuilder localInt = ilGenerator.UnsafeAllocTempLocal(Types.Int32);
d2005 1
a2005 1
							LocalBuilder local = ilGenerator.UnsafeAllocTempLocal(Types.Object);
d2806 1
a2806 1
						LocalBuilder ghost = ilGenerator.AllocTempLocal(Types.Object);
d2808 1
a2808 1
						LocalBuilder local = ilGenerator.AllocTempLocal(args[i].TypeAsSignatureType);
d2965 2
a2966 2
			LocalBuilder argarray = ilGenerator.DeclareLocal(JVM.Import(typeof(object[])));
			LocalBuilder val = ilGenerator.DeclareLocal(Types.Object);
@


1.163
log
@Implemented first stab at converting suitable fault blocks into finally blocks.
@
text
@a178 2
	private readonly ISymbolDocumentWriter symboldocument;
	private readonly LineNumberTableAttribute.LineNumberWriter lineNumbers;
d184 1
d227 1
a227 1
	private Compiler(DynamicTypeWrapper.FinishContext context, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ClassLoaderWrapper classLoader, ISymbolDocumentWriter symboldocument, Dictionary<MethodKey, MethodInfo> invokespecialstubcache)
a234 1
		this.symboldocument = symboldocument;
a237 4
		if(m.LineNumberTableAttribute != null && classLoader.EmitStackTraceInfo)
		{
			this.lineNumbers = new LineNumberTableAttribute.LineNumberWriter(m.LineNumberTableAttribute.Length);
		}
d264 44
d565 1
a565 1
	internal static void Compile(DynamicTypeWrapper.FinishContext context, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ref bool nonleaf, Dictionary<MethodKey, MethodInfo> invokespecialstubcache, ref LineNumberTableAttribute.LineNumberWriter lineNumberTable)
a567 1
		ISymbolDocumentWriter symboldocument = null;
d580 1
a580 1
				symboldocument = classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineDocument(sourcefile, SymLanguageType.Java, Guid.Empty, SymDocumentType.Text);
d598 1
a598 1
						ilGenerator.MarkSequencePoint(symboldocument, firstLine, 0, firstLine + 1, 0);
d622 1
a622 1
				c = new Compiler(context, clazz, mw, classFile, m, ilGenerator, classLoader, symboldocument, invokespecialstubcache);
a676 36
			if(c.lineNumbers != null)
			{
				InstructionFlags[] flags = c.ComputePartialReachability(0, false);
				for(int i = 0; i < m.Instructions.Length; i++)
				{
					if((flags[i] & InstructionFlags.Reachable) == 0)
					{
						// skip unreachable instructions
					}
					else if(m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__getfield
						&& VerifierTypeWrapper.IsThis(c.ma.GetRawStackTypeWrapper(i, 0)))
					{
						// loading a field from the current object cannot throw
					}
					else if(m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__putfield
						&& VerifierTypeWrapper.IsThis(c.ma.GetRawStackTypeWrapper(i, 1)))
					{
						// storing a field in the current object cannot throw
					}
					else if(m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__getstatic
						&& classFile.GetFieldref(m.Instructions[i].Arg1).GetClassType() == clazz)
					{
						// loading a field from the current class cannot throw
					}
					else if(m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__putstatic
						&& classFile.GetFieldref(m.Instructions[i].Arg1).GetClassType() == clazz)
					{
						// storing a field to the current class cannot throw
					}
					else if(ByteCodeMetaData.CanThrowException(m.Instructions[i].NormalizedOpCode))
					{
						lineNumberTable = c.lineNumbers;
						break;
					}
				}
			}
d1101 1
a1101 2
			ClassFile.Method.LineNumberTableEntry[] table = m.LineNumberTableAttribute;
			if(table != null && (symboldocument != null || lineNumbers != null))
d1103 2
a1104 1
				for(int j = 0; j < table.Length; j++)
d1108 1
a1108 13
						if(symboldocument != null)
						{
							ilGenerator.MarkSequencePoint(symboldocument, table[j].line_number, 0, table[j].line_number + 1, 0);
							// we emit a nop to make sure we always have an instruction associated with the sequence point
							ilGenerator.Emit(OpCodes.Nop);
						}
						// we only add a line number mapping if the stack is empty for two reasons:
						// 1) the CLR JIT only generates native to IL mappings for locations where the stack is empty
						// 2) GetILOffset() flushes the lazy emit stack, so if we don't do this check we miss some optimization opportunities
						if(lineNumbers != null && ilGenerator.IsStackEmpty)
						{
							lineNumbers.AddMapping(ilGenerator.GetILOffset(), table[j].line_number);
						}
@


1.162
log
@Restructured method analyzer/verifier to make data flow more obvious and keep less data alive during compilation.
@
text
@d940 8
a947 1
					ilGenerator.BeginFaultBlock();
d2108 1
@


1.161
log
@Move construction of EmitIntrinsicContext to compiler.
@
text
@d175 3
a177 1
	private readonly MethodAnalyzer ma;
d260 4
a263 2
			ma = new MethodAnalyzer(clazz, mw, classFile, m, classLoader);
			localVars = new LocalVarInfo(ma, m, mw, classLoader);
d626 1
a626 1
				c.Compile(b, c.ma.ComputePartialReachability(0, true));
d637 1
a637 1
				c.Compile(b, c.ma.ComputePartialReachability(0, true));
d642 1
a642 1
				InstructionFlags[] flags = c.ma.ComputePartialReachability(0, false);
d899 1
a899 1
		ExceptionTableEntry[] exceptions = ma.GetExceptionTableFor(flags);
d941 1
a941 1
					Compile(new Block(this, 0, block.EndIndex, exceptionIndex, null, false), ma.ComputePartialReachability(handlerIndex, true));
a1762 1
				case NormalizedByteCode.__fstore_conv:	// since we convert after every FP-operation, we don't need this convert anymore
a1765 4
				case NormalizedByteCode.__dstore_conv:
					ilGenerator.Emit(OpCodes.Conv_R8);
					StoreLocal(i);
					break;
d1767 4
a1979 1
				case NormalizedByteCode.__fastore_conv:	// since we convert after every FP-operation, we don't need this convert anymore
a1985 4
				case NormalizedByteCode.__dastore_conv:
					ilGenerator.Emit(OpCodes.Conv_R8);
					ilGenerator.Emit(OpCodes.Stelem_R8);
					break;
d1987 4
d2617 1
a2617 1
					string message = ma.GetErrorMessage(instr.HardErrorMessageId);
d3179 21
@


1.160
log
@Added extra indirection thru MethodWrapper for intrinsic method call emitting to allow .NET delegate constructor optimization to use instrinsic infrastructure instead of requiring EmitNewobj to pass a MethodAnalyzer and opcode index.
@
text
@d1288 1
a1288 1
					if(method.IsIntrinsic && method.EmitIntrinsic(context, ilGenerator, method, ma, i, mw, classFile, code, flags))
d1332 1
a1332 1
					if(method.IsIntrinsic && method.EmitIntrinsic(context, ilGenerator, method, ma, i, mw, classFile, code, flags))
@


1.159
log
@Added extra indirection thru MethodWrapper for intrinsic method call emitting to allow .NET delegate constructor optimization to use instrinsic infrastructure instead of requiring EmitNewobj to pass a MethodAnalyzer and opcode index.
@
text
@d1288 1
a1288 1
					if(method.IsIntrinsic && Intrinsics.Emit(context, ilGenerator, method, ma, i, mw, classFile, code, flags))
d1332 1
a1332 1
					if(method.IsIntrinsic && Intrinsics.Emit(context, ilGenerator, method, ma, i, mw, classFile, code, flags))
@


1.158
log
@Moved local variable analysis from verifier.cs to new file LocalVars.cs.
@
text
@d1445 1
a1445 1
							method.EmitNewobj(ilGenerator, ma, i);
d2957 1
a2957 1
		internal override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
@


1.157
log
@Consolidated all bytecode flow control properties.
@
text
@d176 1
d259 1
d267 1
a267 1
		LocalVar[] locals = ma.GetAllLocalVars();
d336 1
a336 1
						LocalVar v = ma.GetLocalVar(startIndex - 1);
d969 1
a969 1
						ma.GetLocalVar(handlerIndex) == null));
d1499 1
a1499 1
								LocalVar[] locals = ma.GetLocalVarsForInvokeSpecial(i);
d1533 1
a1533 1
							LocalVar[] locals = ma.GetLocalVarsForInvokeSpecial(i);
d3064 1
a3064 1
		LocalVar v = ma.GetLocalVar(instructionIndex);
d3124 1
a3124 1
		LocalVar v = ma.GetLocalVar(instructionIndex);
@


1.156
log
@Added VerifierTypeWrapper.IsNotPresentOnStack() to encapsulate the notion of types that aren't represented on the .NET stack.
Note that while this may look like a bug fix (because we're handling fault block exception types in more places), it isn't. Fault block exceptions can not actually occur on the stack, because the verifier will only allow them in very limited places.
@
text
@d1120 1
a1120 1
				switch(instr.NormalizedOpCode)
d1122 1
a1122 6
					case NormalizedByteCode.__return:
					case NormalizedByteCode.__areturn:
					case NormalizedByteCode.__ireturn:
					case NormalizedByteCode.__lreturn:
					case NormalizedByteCode.__freturn:
					case NormalizedByteCode.__dreturn:
d1126 2
a1127 17
					case NormalizedByteCode.__if_icmpeq:
					case NormalizedByteCode.__if_icmpne:
					case NormalizedByteCode.__if_icmple:
					case NormalizedByteCode.__if_icmplt:
					case NormalizedByteCode.__if_icmpge:
					case NormalizedByteCode.__if_icmpgt:
					case NormalizedByteCode.__ifle:
					case NormalizedByteCode.__iflt:
					case NormalizedByteCode.__ifge:
					case NormalizedByteCode.__ifgt:
					case NormalizedByteCode.__ifne:
					case NormalizedByteCode.__ifeq:
					case NormalizedByteCode.__ifnonnull:
					case NormalizedByteCode.__ifnull:
					case NormalizedByteCode.__if_acmpeq:
					case NormalizedByteCode.__if_acmpne:
					case NormalizedByteCode.__goto:
d1134 2
a1135 4
					case NormalizedByteCode.__athrow:
					case NormalizedByteCode.__athrow_no_unmap:
					case NormalizedByteCode.__lookupswitch:
					case NormalizedByteCode.__tableswitch:
d2626 1
a2626 1
			switch(instr.NormalizedOpCode)
d2628 4
a2631 13
				case NormalizedByteCode.__tableswitch:
				case NormalizedByteCode.__lookupswitch:
				case NormalizedByteCode.__goto:
				case NormalizedByteCode.__ret:
				case NormalizedByteCode.__ireturn:
				case NormalizedByteCode.__lreturn:
				case NormalizedByteCode.__freturn:
				case NormalizedByteCode.__dreturn:
				case NormalizedByteCode.__areturn:
				case NormalizedByteCode.__return:
				case NormalizedByteCode.__athrow:
				case NormalizedByteCode.__athrow_no_unmap:
				case NormalizedByteCode.__static_error:
d2634 2
a2635 1
				default:
d2645 2
@


1.155
log
@Removed x64 JIT bug workaround that is no longer required (and caused another issue: http://connect.microsoft.com/VisualStudio/feedback/details/578948/x64-jit-stack-overflow).
@
text
@d1492 1
a1492 1
										else if(!VerifierTypeWrapper.IsNew(stacktype))
d1722 1
a1722 1
					else if(VerifierTypeWrapper.IsNew(type))
d1724 1
a1724 1
						// since new objects aren't represented on the stack, we don't need to do anything here
a1737 4
					else if (VerifierTypeWrapper.IsFaultBlockException(type))
					{
						// not really there
					}
d1751 1
a1751 1
					if(VerifierTypeWrapper.IsNew(type))
d1753 1
a1753 1
						// new objects aren't really on the stack, so we can't copy them into the local
a1762 4
					else if(VerifierTypeWrapper.IsFaultBlockException(type))
					{
						// not really there
					}
d2280 2
a2281 2
					// if the TOS contains a "new" object, it isn't really there, so we don't dup it
					if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
d2476 1
a2476 1
						if(!VerifierTypeWrapper.IsNew(type1))
d2480 1
a2480 1
						if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 1)))
d2488 2
a2489 2
					// if the TOS is a new object, it isn't really there, so we don't need to pop it
					if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
@


1.154
log
@Made most static compiler warnings local to the target that is being compiled (in multi target mode), to allow warnings to be suppressed (or turned into an error) for a specific target.
@
text
@d1267 1
a1267 14
						{
							double v = classFile.GetConstantPoolConstantDouble(constant);
							if(v == 0.0 && BitConverter.DoubleToInt64Bits(v) < 0)
							{
								// FXBUG the x64 CLR JIT has a bug [1] that causes "cond ? -0:0 : 0.0" to be optimized to 0.0
								// This bug causes problems for the sun.misc.FloatingDecimal code, so as a workaround we obfuscate the -0.0 constant.
								// [1] https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=276714
								ilGenerator.Emit(OpCodes.Ldc_I8, Int64.MinValue);
								ilGenerator.Emit(OpCodes.Call, JVM.Import(typeof(BitConverter)).GetMethod("Int64BitsToDouble"));
							}
							else
							{
								ilGenerator.Emit(OpCodes.Ldc_R8, v);
							}
a1268 1
						}
d1270 1
a1270 14
						{
							float v = classFile.GetConstantPoolConstantFloat(constant);
							if(v == 0.0 && BitConverter.DoubleToInt64Bits(v) < 0)
							{
								// FXBUG the x64 CLR JIT has a bug [1] that causes "cond ? -0:0 : 0.0" to be optimized to 0.0
								// This bug causes problems for the sun.misc.FloatingDecimal code, so as a workaround we obfuscate the -0.0 constant.
								// [1] https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=276714
								ilGenerator.Emit(OpCodes.Ldc_I8, Int64.MinValue);
								ilGenerator.Emit(OpCodes.Call, JVM.Import(typeof(BitConverter)).GetMethod("Int64BitsToDouble"));
							}
							else
							{
								ilGenerator.Emit(OpCodes.Ldc_R4, v);
							}
a1271 1
						}
@


1.153
log
@On .NET 4.0 the NoInlining flag also prevents tail calls, so we don't need tail call thwarting there.
@
text
@d589 1
a589 1
			StaticCompiler.IssueMessage(Message.EmittedVerificationError, classFile.Name + "." + m.Name + m.Signature, x.Message);
d601 1
a601 1
			StaticCompiler.IssueMessage(Message.EmittedClassFormatError, classFile.Name + "." + m.Name + m.Signature, x.Message);
@


1.153.2.1
log
@Backport: Fixed regression introduced with fault handlers. Exception handlers inside fault handlers could be ignored.
@
text
@d935 1
a935 1
					Compile(new Block(this, 0, block.EndIndex, -1, null, false), ma.ComputePartialReachability(handlerIndex, true));
@


1.152
log
@Implemented codegen improvement to use CLR fault handlers for Java catch all handlers, whenever possible.
@
text
@d1690 1
d1708 1
@


1.151
log
@Since we're no longer modifying the instructions, there's no reason to pass it around instead of using it directly from the Method object.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
a175 2
	private readonly ClassFile.Method.InstructionFlags[] flags;
	private readonly ExceptionTableEntry[] exceptions;
a300 3
		flags = ma.ComputePartialReachability(0, m.ExceptionTable);
		exceptions = MethodAnalyzer.UntangleExceptionBlocks(classFile, m.Instructions, flags, m.ExceptionTable);

d412 1
d465 4
d484 2
a485 1
					// new objects aren't really there on the stack
d509 2
a510 1
					// new objects aren't really there on the stack
d620 1
a620 1
				c.Compile(b);
d631 1
a631 1
				c.Compile(b);
d636 1
d639 1
a639 1
					if((c.flags[i] & InstructionFlags.Reachable) == 0)
d891 1
a891 24
	private bool IsGuardedBlock(Stack<Block> blockStack, int instructionIndex, int instructionCount)
	{
		int start = instructionIndex;
		int end = instructionIndex + instructionCount;
		for(int i = 0; i < exceptions.Length; i++)
		{
			ExceptionTableEntry e = exceptions[i];
			if(e.endIndex > start && e.startIndex < end)
			{
				foreach(Block block in blockStack)
				{
					if(block.ExceptionIndex == i)
					{
						goto next;
					}
				}
				return true;
			}
		next:;
		}
		return false;
	}

	private void Compile(Block block)
d893 1
d932 1
a932 21
				if(exc.catch_type == 0
					&& handlerIndex + 2 < m.Instructions.Length
					&& m.Instructions[handlerIndex].NormalizedOpCode == NormalizedByteCode.__aload
					&& m.Instructions[handlerIndex + 1].NormalizedOpCode == NormalizedByteCode.__monitorexit
					&& m.Instructions[handlerIndex + 2].NormalizedOpCode == NormalizedByteCode.__athrow
					&& !IsGuardedBlock(blockStack, handlerIndex, 3))
				{
					// this is the Jikes & Eclipse Java Compiler synchronization block exit
					ilGenerator.BeginFaultBlock();
					LoadLocal(handlerIndex);
					ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
					ilGenerator.EndExceptionBlockNoFallThrough();
				}
				else if(exc.catch_type == 0
					&& handlerIndex + 3 < m.Instructions.Length
					&& m.Instructions[handlerIndex].NormalizedOpCode == NormalizedByteCode.__astore
					&& m.Instructions[handlerIndex + 1].NormalizedOpCode == NormalizedByteCode.__aload
					&& m.Instructions[handlerIndex + 2].NormalizedOpCode == NormalizedByteCode.__monitorexit
					&& m.Instructions[handlerIndex + 3].NormalizedOpCode == NormalizedByteCode.__aload
					&& m.Instructions[handlerIndex + 4].NormalizedOpCode == NormalizedByteCode.__athrow
					&& !IsGuardedBlock(blockStack, handlerIndex, 5))
a933 1
					// this is the javac synchronization block exit
d935 1
a935 2
					LoadLocal(handlerIndex + 1);
					ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
d1764 4
d1793 4
d1836 1
a1836 1
					else if(wrapper != clazz && RequiresExplicitClassInit(wrapper, i + 1))
d2542 5
a2546 1
					if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
d2548 6
a2553 1
						ilGenerator.Emit(OpCodes.Castclass, Types.Exception);
a2554 2
					ilGenerator.Emit(OpCodes.Call, unmapExceptionMethod);
					ilGenerator.Emit(OpCodes.Throw);
d2713 1
a2713 1
	private bool RequiresExplicitClassInit(TypeWrapper tw, int index)
@


1.150
log
@Removed mutable flags field from Instruction.
@
text
@d303 1
a303 1
		flags = ma.ComputePartialReachability(m.Instructions, 0, m.ExceptionTable);
@


1.149
log
@Use local variable 'code' instead of m.Instructions.
@
text
@d42 1
d176 1
d303 2
a304 1
		exceptions = MethodAnalyzer.UntangleExceptionBlocks(classFile, m.Instructions, m.ExceptionTable);
d636 1
a636 1
					if(!m.Instructions[i].IsReachable)
d1009 1
a1009 1
					int flags = unusedException ? 2 : 0;
d1016 1
a1016 1
						ilGenerator.LazyEmitLdc_I4(flags | 1);
d1021 1
a1021 1
						ilGenerator.LazyEmitLdc_I4(flags);
d1026 1
a1026 1
						ilGenerator.LazyEmitLdc_I4(flags | (remap ? 0 : 1));
d1060 1
a1060 1
			if(!instr.IsReachable)
d1069 1
a1069 1
			if(block.HasLabel(i) || instr.IsBranchTarget)
d1377 1
a1377 1
					if(method.IsIntrinsic && Intrinsics.Emit(context, ilGenerator, method, ma, i, mw, classFile, code))
d1421 1
a1421 1
					if(method.IsIntrinsic && Intrinsics.Emit(context, ilGenerator, method, ma, i, mw, classFile, code))
d1528 1
a1528 1
									if(!code[i + 1].IsBranchTarget)
d2727 1
a2727 1
					Debug.Assert(code[i + 1].IsReachable);
d2750 1
a2750 1
			if (code[index].IsBranchTarget
@


1.148
log
@Moved exception untangling code into MethodAnalyzer where it makes more sense.
@
text
@d1130 1
a1130 1
					if(table[j].start_pc == m.Instructions[i].PC && table[j].line_number != 0)
d1731 1
a1731 1
							while(k > 0 && m.Instructions[k].NormalizedOpCode == NormalizedByteCode.__nop)
d1735 1
a1735 1
							switch(m.Instructions[k].NormalizedOpCode)
d2724 1
a2724 1
					Debug.Assert(m.Instructions[i + 1].IsReachable);
@


1.147
log
@Fixed regression in dynamic exception handling and made it simpler.
@
text
@a165 1
	private static readonly TypeWrapper java_lang_ThreadDeath;
a200 1
		java_lang_ThreadDeath = ClassLoaderWrapper.LoadClassCritical("java.lang.ThreadDeath");
a224 34
	private class ExceptionSorter : IComparer<ExceptionTableEntry>
	{
		public int Compare(ExceptionTableEntry e1, ExceptionTableEntry e2)
		{
			if(e1.startIndex < e2.startIndex)
			{
				return -1;
			}
			if(e1.startIndex == e2.startIndex)
			{
				if(e1.endIndex == e2.endIndex)
				{
					if(e1.ordinal > e2.ordinal)
					{
						return -1;
					}
					if(e1.ordinal == e2.ordinal)
					{
						// This really shouldn't happen, but it is good practice to have a correct Compare
						// implementation and Mono's Array.Sort() (at one point at least) didn't partition
						// correctly, causing an array element to be compared against itself.
						return 0;
					}
					return 1;
				}
				if(e1.endIndex > e2.endIndex)
				{
					return -1;
				}
			}
			return 1;
		}
	}

d301 1
a301 264
		// NOTE we're going to be messing with ExceptionTableEntrys that are owned by the Method, this is very bad practice,
		// this code should probably be changed to use our own ETE class (which should also contain the ordinal, instead
		// of the one in ClassFile.cs)

		List<ExceptionTableEntry> ar = new List<ExceptionTableEntry>(m.ExceptionTable);

		// This optimization removes the recursive exception handlers that Java compiler place around
		// the exit of a synchronization block to be "safe" in the face of asynchronous exceptions.
		// (see http://weblog.ikvm.net/PermaLink.aspx?guid=3af9548e-4905-4557-8809-65a205ce2cd6)
		// We can safely remove them since the code we generate for this construct isn't async safe anyway,
		// but there is another reason why this optimization may be slightly controversial. In some
		// pathological cases it can cause observable differences, where the Sun JVM would spin in an
		// infinite loop, but we will throw an exception. However, the perf benefit is large enough to
		// warrant this "incompatibility".
		// Note that there is also code in the exception handler handling code that detects these bytecode
		// sequences to try to compile them into a fault block, instead of an exception handler.
		for(int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = ar[i];
			if(ei.startIndex == ei.handlerIndex && ei.catch_type == 0)
			{
				int index = ei.startIndex;
				if(index + 2 < m.Instructions.Length
					&& ei.endIndex == index + 2
					&& m.Instructions[index].NormalizedOpCode == NormalizedByteCode.__aload
					&& m.Instructions[index + 1].NormalizedOpCode == NormalizedByteCode.__monitorexit
					&& m.Instructions[index + 2].NormalizedOpCode == NormalizedByteCode.__athrow)
				{
					// this is the async exception guard that Jikes and the Eclipse Java Compiler produce
					ar.RemoveAt(i);
					i--;
				}
				else if(index + 4 < m.Instructions.Length
					&& ei.endIndex == index + 3
					&& m.Instructions[index].NormalizedOpCode == NormalizedByteCode.__astore
					&& m.Instructions[index + 1].NormalizedOpCode == NormalizedByteCode.__aload
					&& m.Instructions[index + 2].NormalizedOpCode == NormalizedByteCode.__monitorexit
					&& m.Instructions[index + 3].NormalizedOpCode == NormalizedByteCode.__aload
					&& m.Instructions[index + 4].NormalizedOpCode == NormalizedByteCode.__athrow
					&& m.Instructions[index].NormalizedArg1 == m.Instructions[index + 3].NormalizedArg1)
				{
					// this is the async exception guard that javac produces
					ar.RemoveAt(i);
					i--;
				}
			}
		}

		restart:
			for(int i = 0; i < ar.Count; i++)
			{
				ExceptionTableEntry ei = ar[i];
				for(int j = 0; j < ar.Count; j++)
				{
					ExceptionTableEntry ej = ar[j];
					if(ei.startIndex <= ej.startIndex && ej.startIndex < ei.endIndex)
					{
						// 0006/test.j
						if(ej.endIndex > ei.endIndex)
						{
							ExceptionTableEntry emi = new ExceptionTableEntry();
							emi.startIndex = ej.startIndex;
							emi.endIndex = ei.endIndex;
							emi.catch_type = ei.catch_type;
							emi.handlerIndex = ei.handlerIndex;
							ExceptionTableEntry emj = new ExceptionTableEntry();
							emj.startIndex = ej.startIndex;
							emj.endIndex = ei.endIndex;
							emj.catch_type = ej.catch_type;
							emj.handlerIndex = ej.handlerIndex;
							ei.endIndex = emi.startIndex;
							ej.startIndex = emj.endIndex;
							ar.Insert(j, emj);
							ar.Insert(i + 1, emi);
							goto restart;
						}
						// 0007/test.j
						else if(j > i && ej.endIndex < ei.endIndex)
						{
							ExceptionTableEntry emi = new ExceptionTableEntry();
							emi.startIndex = ej.startIndex;
							emi.endIndex = ej.endIndex;
							emi.catch_type = ei.catch_type;
							emi.handlerIndex = ei.handlerIndex;
							ExceptionTableEntry eei = new ExceptionTableEntry();
							eei.startIndex = ej.endIndex;
							eei.endIndex = ei.endIndex;
							eei.catch_type = ei.catch_type;
							eei.handlerIndex = ei.handlerIndex;
							ei.endIndex = emi.startIndex;
							ar.Insert(i + 1, eei);
							ar.Insert(i + 1, emi);
							goto restart;
						}
					}
				}
			}
		// Split try blocks at branch targets (branches from outside the try block)
	restart_split:
		for(int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = ar[i];
			int start = ei.startIndex;
			int end = ei.endIndex;
			for(int j = 0; j < m.Instructions.Length; j++)
			{
				if(j < start || j >= end)
				{
					switch(m.Instructions[j].NormalizedOpCode)
					{
						case NormalizedByteCode.__tableswitch:
						case NormalizedByteCode.__lookupswitch:
							// start at -1 to have an opportunity to handle the default offset
							for(int k = -1; k < m.Instructions[j].SwitchEntryCount; k++)
							{
								int targetIndex = (k == -1 ? m.Instructions[j].DefaultTarget : m.Instructions[j].GetSwitchTargetIndex(k));
								if(ei.startIndex < targetIndex && targetIndex < ei.endIndex)
								{
									ExceptionTableEntry en = new ExceptionTableEntry();
									en.catch_type = ei.catch_type;
									en.handlerIndex = ei.handlerIndex;
									en.startIndex = targetIndex;
									en.endIndex = ei.endIndex;
									ei.endIndex = targetIndex;
									ar.Insert(i + 1, en);
									goto restart_split;
								}
							}
							break;
						case NormalizedByteCode.__ifeq:
						case NormalizedByteCode.__ifne:
						case NormalizedByteCode.__iflt:
						case NormalizedByteCode.__ifge:
						case NormalizedByteCode.__ifgt:
						case NormalizedByteCode.__ifle:
						case NormalizedByteCode.__if_icmpeq:
						case NormalizedByteCode.__if_icmpne:
						case NormalizedByteCode.__if_icmplt:
						case NormalizedByteCode.__if_icmpge:
						case NormalizedByteCode.__if_icmpgt:
						case NormalizedByteCode.__if_icmple:
						case NormalizedByteCode.__if_acmpeq:
						case NormalizedByteCode.__if_acmpne:
						case NormalizedByteCode.__ifnull:
						case NormalizedByteCode.__ifnonnull:
						case NormalizedByteCode.__goto:
						{
							int targetIndex = m.Instructions[j].Arg1;
							if(ei.startIndex < targetIndex && targetIndex < ei.endIndex)
							{
								ExceptionTableEntry en = new ExceptionTableEntry();
								en.catch_type = ei.catch_type;
								en.handlerIndex = ei.handlerIndex;
								en.startIndex = targetIndex;
								en.endIndex = ei.endIndex;
								ei.endIndex = targetIndex;
								ar.Insert(i + 1, en);
								goto restart_split;
							}
							break;
						}
					}
				}
			}
		}
		// exception handlers are also a kind of jump, so we need to split try blocks around handlers as well
		for(int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = ar[i];
			for(int j = 0; j < ar.Count; j++)
			{
				ExceptionTableEntry ej = ar[j];
				if(ei.startIndex < ej.handlerIndex && ej.handlerIndex < ei.endIndex)
				{
					ExceptionTableEntry en = new ExceptionTableEntry();
					en.catch_type = ei.catch_type;
					en.handlerIndex = ei.handlerIndex;
					en.startIndex = ej.handlerIndex;
					en.endIndex = ei.endIndex;
					ei.endIndex = ej.handlerIndex;
					ar.Insert(i + 1, en);
					goto restart_split;
				}
			}
		}
		// filter out zero length try blocks
		for(int i = 0; i < ar.Count; i++)
		{
			ExceptionTableEntry ei = ar[i];
			if(ei.startIndex == ei.endIndex)
			{
				ar.RemoveAt(i);
				i--;
			}
			else
			{
				// exception blocks that only contain harmless instructions (i.e. instructions that will *never* throw an exception)
				// are also filtered out (to improve the quality of the generated code)
				// NOTE we don't remove exception handlers that could catch ThreadDeath, because that can be thrown
				// asynchronously (and thus appear on any instruction). This is particularly important to ensure that
				// we run finally blocks when a thread is killed.
				if(ei.catch_type != 0)
				{
					TypeWrapper exceptionType = classFile.GetConstantPoolClassType(ei.catch_type);
					if(!exceptionType.IsUnloadable && !java_lang_ThreadDeath.IsAssignableTo(exceptionType))
					{
						int start = ei.startIndex;
						int end = ei.endIndex;
						for(int j = start; j < end; j++)
						{
							if(ByteCodeMetaData.CanThrowException(m.Instructions[j].NormalizedOpCode))
							{
								goto next;
							}
						}
						ar.RemoveAt(i);
						i--;
					}
				}
			}
		next:;
		}

		// remove unreachable exception handlers (because the code gen depends on that)
		for(int i = 0; i < ar.Count; i++)
		{
			// if the first instruction is unreachable, the entire block is unreachable,
			// because you can't jump into a block (we've just split the blocks to ensure that)
			if(!m.Instructions[ar[i].startIndex].IsReachable)
			{
				ar.RemoveAt(i);
				i--;
			}
		}

		exceptions = ar.ToArray();
		for(int i = 0; i < exceptions.Length; i++)
		{
			exceptions[i].ordinal = i;
		}
		Array.Sort(exceptions, new ExceptionSorter());

		// TODO remove these checks, if the above exception untangling is correct, this shouldn't ever
		// be triggered
		for(int i = 0; i < exceptions.Length; i++)
		{
			for(int j = i + 1; j < exceptions.Length; j++)
			{
				// check for partially overlapping try blocks (which is legal for the JVM, but not the CLR)
				if(exceptions[i].startIndex < exceptions[j].startIndex && 
					exceptions[j].startIndex < exceptions[i].endIndex &&
					exceptions[i].endIndex < exceptions[j].endIndex)
				{
					throw new InvalidOperationException("Partially overlapping try blocks is broken");
				}
				// check that we didn't destroy the ordering, when sorting
				if(exceptions[i].startIndex <= exceptions[j].startIndex &&
					exceptions[i].endIndex >= exceptions[j].endIndex &&
					exceptions[i].ordinal < exceptions[j].ordinal)
				{
					throw new InvalidOperationException("Non recursive try blocks is broken");
				}
			}
		}
@


1.146
log
@Removed exception mapping methods from Throwable and consolidated into a single method (actually, two methods, but the dynamic one should not be necessary and should be removed later).
@
text
@a80 1
	internal static readonly MethodInfo mapExceptionDynamic;
a124 1
		mapExceptionDynamic = typeofByteCodeHelper.GetMethod("MapExceptionDynamic");
d1322 6
d1330 1
a1330 1
							Profiler.Count("EmitDynamicGetTypeAsExceptionType");
d1333 1
a1333 13
							ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.DynamicGetTypeAsExceptionType);
							ilGenerator.Emit(remap ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
							ilGenerator.LazyEmitLdc_I4(flags | (remap ? 0 : 1));
							ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.mapExceptionDynamic);
						}
						else
						{
							ilGenerator.LazyEmitLdc_I4(flags | (remap ? 0 : 1));
							ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.mapException.MakeGenericMethod(excType));
						}
						if(!unusedException)
						{
							ilGenerator.Emit(OpCodes.Dup);
@


1.145
log
@Disable stack trace collection for remapped exceptions that are discarded in their handler.
@
text
@d81 1
d126 1
a155 2
	private static readonly MethodInfo mapExceptionMethod;
	internal static readonly MethodInfo mapExceptionFastMethod;
d208 1
a208 6
			MethodWrapper mw = java_lang_Throwable.GetMethodWrapper("__<map>", "(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;", false);
			mw.Link();
			mapExceptionMethod = (MethodInfo)mw.GetMethod();
			mw = java_lang_Throwable.GetMethodWrapper("__<map>", "(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;", false);
			mw.Link();
			mapExceptionFastMethod = (MethodInfo)mw.GetMethod();
a220 2
			mapExceptionMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<map>", new Type[] { Types.Exception, Types.Type, Types.Boolean });
			mapExceptionFastMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<map>", new Type[] { Types.Exception, Types.Boolean });
d1331 2
a1332 1
							ilGenerator.Emit(OpCodes.Call, mapExceptionMethod);
@


1.144
log
@Implemented a more efficient (in terms of the MSIL size) MapException API.
@
text
@d1314 1
d1321 1
a1321 1
						ilGenerator.LazyEmitLdc_I4(1);
d1326 1
a1326 1
						ilGenerator.LazyEmitLdc_I4(0);
d1342 1
a1342 1
							ilGenerator.LazyEmitLdc_I4(remap ? 0 : 1);
@


1.143
log
@Added optimization to avoid explicit <clinit> trigger when it isn't necessary.
@
text
@d80 1
d124 1
d1311 1
a1311 1
					bool unusedException = mapSafe && (handlerInstr.NormalizedOpCode == NormalizedByteCode.__pop ||
d1314 1
a1314 3
					// special case for catch(Throwable) (and finally), that produces less code and
					// should be faster
					if(mapSafe || exceptionTypeWrapper == java_lang_Throwable)
d1316 11
a1326 21
						if(unusedException)
						{
							// we must still have an item on the stack, even though it isn't used!
							bc.dh.SetType(0, VerifierTypeWrapper.Null);
						}
						else
						{
							if(mapSafe)
							{
								ilGenerator.Emit(OpCodes.Dup);
							}
							ilGenerator.Emit(remap ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Call, mapExceptionFastMethod);
							if(mapSafe)
							{
								ilGenerator.Emit(OpCodes.Pop);
							}
							bc.dh.SetType(0, exceptionTypeWrapper);
							bc.dh.Store(0);
						}
						ilGenerator.Emit(OpCodes.Leave, bc.Stub);
d1341 2
a1342 10
							ilGenerator.Emit(OpCodes.Ldtoken, excType);
							ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
							ilGenerator.Emit(remap ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
							ilGenerator.Emit(OpCodes.Call, mapExceptionMethod);
							ilGenerator.Emit(OpCodes.Castclass, excType);
						}
						if(unusedException)
						{
							// we must still have an item on the stack, even though it isn't used!
							bc.dh.SetType(0, VerifierTypeWrapper.Null);
d1344 1
a1344 1
						else
a1345 1
							bc.dh.SetType(0, exceptionTypeWrapper);
a1346 1
							bc.dh.Store(0);
d1348 2
a1349 4
						CodeEmitterLabel rethrow = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Brfalse, rethrow);
						ilGenerator.Emit(OpCodes.Leave, bc.Stub);
						ilGenerator.MarkLabel(rethrow);
d1351 11
d1363 1
@


1.142
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@d2188 1
a2188 1
					else if(wrapper != clazz)
d3058 21
@


1.141
log
@Integrated new IKVM.Reflection implementation.
@
text
@d26 1
a26 1
#if IKVM_REF_EMIT
@


1.140
log
@Fixed exception sorter to be correct when invoked with two references to the same object.
@
text
@a25 1
using System.Reflection;
d27 1
d29 1
d31 1
@


1.139
log
@Fixed regression introduced with "type 2" field accessor fix. Null type doesn't need downcast and needs to be explicitly handled, because you aren't allowed to call GetPublicBaseTypeWrapper() on it.
@
text
@d248 7
@


1.138
log
@- Fixed IsPackageAccessibleFrom to consider class loaders, instead of InternalsVisibleToAttribute
- Added automatic access to internal accessibility members across assemblies in multi target compilation (previously this was only done for -sharedclassloader scenarios)
- Cleaned up existing field access stubs (now known as "type 1") and added type 2 access stubs to make public fields that have a non-public field type accessible.
@
text
@d3230 4
@


1.137
log
@Use StaticCompiler.GetRuntimeType() to get type from the runtime assembly.
@
text
@d322 1
a322 1
					v.builder = ilGenerator.DeclareLocal(v.type.TypeAsLocalOrStackType);
d766 1
a766 1
				locals[i] = compiler.ilGenerator.AllocTempLocal(type.TypeAsLocalOrStackType);
d1855 1
a1855 1
								LocalBuilder newobj = ilGenerator.DeclareLocal(thisType.TypeAsLocalOrStackType);
d1873 1
a1873 1
											LocalBuilder lb = ilGenerator.DeclareLocal(stacktype.TypeAsLocalOrStackType);
d1906 1
a1906 1
											locals[j].builder = ilGenerator.DeclareLocal(locals[j].type.TypeAsLocalOrStackType);
d1940 1
a1940 1
										locals[j].builder = ilGenerator.DeclareLocal(locals[j].type.TypeAsLocalOrStackType);
d3107 1
a3107 1
					if(!tw.IsUnloadable && !tw.IsAssignableTo(args[i]))
d3156 1
a3156 1
					if(tw.IsUnloadable || (args[i].IsInterfaceOrInterfaceArray && !tw.IsAssignableTo(args[i])))
d3228 9
d3482 1
a3482 1
				v.builder = ilGenerator.DeclareLocal(v.type.TypeAsLocalOrStackType);
d3522 1
a3522 1
				v.builder = ilGenerator.DeclareLocal(v.type.TypeAsLocalOrStackType);
d3532 16
@


1.136
log
@Simplified the obj1.getClass() == obj2.getClass() intrinsic to avoid RuntimeTypeHandle. It turns out that on .NET 4.0 RuntimeTypeHandle.Value requires full trust and using RuntimeTypeHandle.Equals is actually slower than simply comparing the types (on .NET 4.0 beta 2, on .NET 2.0 this new approach is actually a bit slower, but the fact that the code is simpler and smaller is also worth something).
@
text
@d82 1
a82 1
		Type typeofByteCodeHelper = StaticCompiler.GetType("IKVM.Runtime.ByteCodeHelper");
@


1.135
log
@Make Compiler class sealed and made most fields readonly.
@
text
@d156 1
d191 1
d2970 2
a2971 4
				case NormalizedByteCode.__intrinsic_gettypehandlevalue:
					ilGenerator.Emit(OpCodes.Dup);
					ilGenerator.EmitNullCheck();
					ilGenerator.EmitGetTypeHandleValue();
@


1.134
log
@Fix for bug #2881954.
@
text
@d148 1
a148 1
class Compiler
d150 16
a165 16
	private static MethodInfo mapExceptionMethod;
	internal static MethodInfo mapExceptionFastMethod;
	private static MethodInfo unmapExceptionMethod;
	private static MethodInfo fixateExceptionMethod;
	private static MethodInfo suppressFillInStackTraceMethod;
	internal static MethodInfo getTypeFromHandleMethod;
	private static MethodInfo monitorEnterMethod;
	private static MethodInfo monitorExitMethod;
	private static MethodInfo keepAliveMethod;
	internal static MethodWrapper getClassFromTypeHandle;
	private static TypeWrapper java_lang_Object;
	private static TypeWrapper java_lang_Class;
	private static TypeWrapper java_lang_Throwable;
	private static TypeWrapper java_lang_ThreadDeath;
	private static TypeWrapper cli_System_Object;
	private static TypeWrapper cli_System_Exception;
d167 9
a175 9
	private DynamicTypeWrapper clazz;
	private MethodWrapper mw;
	private ClassFile classFile;
	private ClassFile.Method m;
	private CodeEmitter ilGenerator;
	private MethodAnalyzer ma;
	private ExceptionTableEntry[] exceptions;
	private ISymbolDocumentWriter symboldocument;
	private LineNumberTableAttribute.LineNumberWriter lineNumbers;
d178 3
a180 3
	private bool debug;
	private bool keepAlive;
	private bool strictfp;
d184 1
a184 1
	private MethodWrapper[] replacedMethodWrappers;
@


1.133
log
@Replaced most type literals with static field access (in Types class) or warpped JVM.Import() around them.
@
text
@d612 7
a620 1
				// TODO validate the contents of the LVT entry
@


1.132
log
@Removed EmitHelper class and moved its methods into CodeEmitter.
@
text
@d117 4
a120 4
		volatileReadDouble = typeofByteCodeHelper.GetMethod("VolatileRead", new Type[] { Type.GetType("System.Double&") });
		volatileReadLong = typeofByteCodeHelper.GetMethod("VolatileRead", new Type[] { Type.GetType("System.Int64&") });
		volatileWriteDouble = typeofByteCodeHelper.GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Double&"), typeof(double) });
		volatileWriteLong = typeofByteCodeHelper.GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Int64&"), typeof(long) });
d189 4
a192 4
		getTypeFromHandleMethod = typeof(Type).GetMethod("GetTypeFromHandle", BindingFlags.Static | BindingFlags.Public, null, new Type[] { typeof(RuntimeTypeHandle) }, null);
		monitorEnterMethod = typeof(System.Threading.Monitor).GetMethod("Enter", BindingFlags.Static | BindingFlags.Public, null, new Type[] { typeof(object) }, null);
		monitorExitMethod = typeof(System.Threading.Monitor).GetMethod("Exit", BindingFlags.Static | BindingFlags.Public, null, new Type[] { typeof(object) }, null);
		keepAliveMethod = typeof(System.GC).GetMethod("KeepAlive", BindingFlags.Static | BindingFlags.Public, null, new Type[] { typeof(object) }, null);
d195 2
a196 2
		cli_System_Object = DotNetTypeWrapper.GetWrapperFromDotNetType(typeof(System.Object));
		cli_System_Exception = DotNetTypeWrapper.GetWrapperFromDotNetType(typeof(System.Exception));
d220 2
a221 2
			mapExceptionMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<map>", new Type[] { typeof(Exception), typeof(Type), typeof(bool) });
			mapExceptionFastMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<map>", new Type[] { typeof(Exception), typeof(bool) });
d223 2
a224 2
			unmapExceptionMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<unmap>", new Type[] { typeof(Exception) });
			fixateExceptionMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<fixate>", new Type[] { typeof(Exception) });
d899 1
a899 1
				LocalBuilder monitor = ilGenerator.DeclareLocal(typeof(object));
d1287 1
a1287 1
						ilGenerator.BeginCatchBlock(typeof(Exception));
d1618 1
a1618 1
								ilGenerator.Emit(OpCodes.Call, typeof(BitConverter).GetMethod("Int64BitsToDouble"));
d1635 1
a1635 1
								ilGenerator.Emit(OpCodes.Call, typeof(BitConverter).GetMethod("Int64BitsToDouble"));
d2181 2
a2182 2
					LocalBuilder localArray = ilGenerator.UnsafeAllocTempLocal(typeof(int[]));
					LocalBuilder localInt = ilGenerator.UnsafeAllocTempLocal(typeof(int));
d2184 1
a2184 1
					ilGenerator.Emit(OpCodes.Newarr, typeof(int));
d2396 1
a2396 1
							LocalBuilder local = ilGenerator.UnsafeAllocTempLocal(typeof(object));
d2416 2
a2417 2
						ilGenerator.Emit(OpCodes.Castclass, typeof(Array));
						ilGenerator.Emit(OpCodes.Callvirt, typeof(Array).GetMethod("get_Length"));
d2872 1
a2872 1
						ilGenerator.Emit(OpCodes.Castclass, typeof(Exception));
d2879 1
a2879 1
						ilGenerator.Emit(OpCodes.Castclass, typeof(Exception));
d3176 1
a3176 1
						LocalBuilder ghost = ilGenerator.AllocTempLocal(typeof(object));
d3322 2
a3323 2
			LocalBuilder argarray = ilGenerator.DeclareLocal(typeof(object[]));
			LocalBuilder val = ilGenerator.DeclareLocal(typeof(object));
d3325 1
a3325 1
			ilGenerator.Emit(OpCodes.Newarr, typeof(object));
@


1.132.2.1
log
@Fix for bug #2881954.
@
text
@a611 7

			// FXBUG make sure we always have an outer scope
			// (otherwise LocalBuilder.SetLocalSymInfo() might throw an IndexOutOfRangeException)
			// fix for bug 2881954.
			scopeBegin[0]++;
			scopeClose[m.Instructions.Length - 1]++;

d614 1
@


1.132.2.2
log
@- Update version to 0.42.0.4
Backported:
- Mangle all artificial type names if they clash with Java type names in the same assembly.
- Fix for http://gcc.gnu.org/bugzilla/show_bug.cgi?id=41696
- Fixed exception sorter to be correct when invoked with two references to the same object.
@
text
@a245 7
					if(e1.ordinal == e2.ordinal)
					{
						// This really shouldn't happen, but it is good practice to have a correct Compare
						// implementation and Mono's Array.Sort() (at one point at least) didn't partition
						// correctly, causing an array element to be compared against itself.
						return 0;
					}
@


1.131
log
@Removed vestigial compact framework support.
@
text
@d879 1
a879 1
			EmitHelper.Throw(ilGenerator, "java.lang.VerifyError", x.Message);
d889 1
a889 1
			EmitHelper.Throw(ilGenerator, "java.lang.ClassFormatError", x.Message);
d2964 2
a2965 2
					EmitHelper.NullCheck(ilGenerator);
					EmitHelper.GetTypeHandleValue(ilGenerator);
d3152 1
a3152 1
						EmitHelper.EmitAssertType(ilGenerator, args[i].TypeAsTBD);
@


1.130
log
@Reintroduced local variable scopes in debugging information.
@
text
@a23 2
#if !COMPACT_FRAMEWORK

a3517 2

#endif
@


1.129
log
@Use ILGenerator's new "clever" mode in CodeEmitter to produce smaller code.
@
text
@d40 1
d183 2
d599 51
d1209 12
@


1.128
log
@Made callerID initialization lazy.
@
text
@d857 1
a857 1
				ilGenerator.EndExceptionBlock();
a900 7
			if((m.IsSynchronized && m.IsStatic) || c.exceptions.Length > 0)
			{
				// HACK because of the bogus Leave instruction that Reflection.Emit generates, this location
				// sometimes appears reachable (it isn't), so we emit a bogus branch to keep the verifier happy.
				//ilGenerator.Emit(OpCodes.Br, - (ilGenerator.GetILOffset() + 5));
				ilGenerator.Emit(OpCodes.Br_S, (sbyte)-2);
			}
d1184 1
a1184 4
					ilGenerator.EndExceptionBlock();
					// HACK to keep the verifier happy we need this bogus jump
					// (because of the bogus Leave that Ref.Emit ends the try block with)
					ilGenerator.Emit(OpCodes.Br_S, (sbyte)-2);
d1199 1
a1199 4
					ilGenerator.EndExceptionBlock();
					// HACK to keep the verifier happy we need this bogus jump
					// (because of the bogus Leave that Ref.Emit ends the try block with)
					ilGenerator.Emit(OpCodes.Br_S, (sbyte)-2);
d1293 1
a1293 1
					ilGenerator.EndExceptionBlock();
@


1.127
log
@Optimized the reading of unsigned bytes from a byte array (buf[i] & 0xFF or buf[i] 0x0FFL).
@
text
@d1637 1
a1637 1
						ilGenerator.Emit(OpCodes.Ldsfld, context.CallerIDField);
d1893 1
a1893 1
							ilGenerator.Emit(OpCodes.Ldsfld, context.CallerIDField);
d3186 1
a3186 1
		ilGenerator.Emit(OpCodes.Ldsfld, context.CallerIDField);
d3293 1
a3293 1
			ilGenerator.Emit(OpCodes.Ldsfld, context.CallerIDField);
@


1.126
log
@Made ikvm.runtime.Util.getInstanceTypeFromClass() into an instrinsic, when used with a class literal.
@
text
@d2283 1
a2283 1
					ilGenerator.Emit(OpCodes.Ldelem_I1);
d2484 2
d2487 1
a2487 1
					ilGenerator.Emit(OpCodes.And);
d2896 1
a2896 1
					ilGenerator.Emit(OpCodes.Conv_I8);
@


1.125
log
@Moved class literal emit code to TypeWrapper and added checks to prevent types that are illegal in type instantations from being used with ClassLiteral<T>.
@
text
@d156 1
a156 1
	private static MethodInfo getTypeFromHandleMethod;
@


1.124
log
@Replaced last usage of ByteCodeHelperMethods.GetClassFromTypeHandle in runtime with LazyEmitLoadClass.
@
text
@d845 1
a845 1
				ilGenerator.Emit(OpCodes.Ldsfld, context.ClassObjectField);
@


1.123
log
@Added ikvmc warnings for VerificationError and ClassFormatError.
@
text
@a43 1
	internal static readonly MethodInfo GetClassFromTypeHandle;
a86 1
		GetClassFromTypeHandle = typeofByteCodeHelper.GetMethod("GetClassFromTypeHandle");
@


1.122
log
@ClassFile versions 51 and up don't allow the jsr instruction.
@
text
@d822 3
d834 3
@


1.121
log
@Refactored method call replacement to allow it to be used by others than xml mapping stuff.
@
text
@d286 1
a286 1
			if(m.HasJsr)
@


1.120
log
@Removed jsr/ret support.
@
text
@d170 1
a170 1
	private TypeWrapper clazz;
a184 1
	private IKVM.Internal.MapXml.ReplaceMethodCall[] replacedMethods;
d258 1
a258 1
	private Compiler(DynamicTypeWrapper.FinishContext context, TypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ClassLoaderWrapper classLoader, ISymbolDocumentWriter symboldocument, Dictionary<MethodKey, MethodInfo> invokespecialstubcache)
d280 1
a280 5
		replacedMethods = ((CompilerClassLoader)clazz.GetClassLoader()).GetReplacedMethodsFor(mw);
		if(replacedMethods != null)
		{
			replacedMethodWrappers = new MethodWrapper[replacedMethods.Length];
		}
a3292 28
#if STATIC_COMPILER
	private class ReplacedMethodWrapper : MethodWrapper
	{
		private IKVM.Internal.MapXml.InstructionList code;

		internal ReplacedMethodWrapper(ClassFile.ConstantPoolItemMI cpi, IKVM.Internal.MapXml.InstructionList code)
			: base(cpi.GetClassType(), cpi.Name, cpi.Signature, null, cpi.GetRetType(), cpi.GetArgTypes(), Modifiers.Public, MemberFlags.None)
		{
			this.code = code;
		}

		internal override void EmitCall(CodeEmitter ilgen)
		{
			code.Emit(DeclaringType.GetClassLoader(), ilgen);
		}

		internal override void EmitCallvirt(CodeEmitter ilgen)
		{
			code.Emit(DeclaringType.GetClassLoader(), ilgen);
		}

		internal override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
		{
			code.Emit(DeclaringType.GetClassLoader(), ilgen);
		}
	}
#endif

d3296 1
a3296 1
		if(replacedMethods != null)
d3298 1
a3298 1
			for(int i = 0; i < replacedMethods.Length; i++)
d3300 3
a3302 3
				if(replacedMethods[i].Class == cpi.Class
					&& replacedMethods[i].Name == cpi.Name
					&& replacedMethods[i].Sig == cpi.Signature)
d3304 3
a3306 5
					if(replacedMethodWrappers[i] == null)
					{
						replacedMethodWrappers[i] = new ReplacedMethodWrapper(cpi, replacedMethods[i].code);
					}
					return replacedMethodWrappers[i];
@


1.119
log
@Subroutine inlining exposed a pre-existing codegen bug that caused exception handlers to be dropped after an unreachable exception block was encountered.
@
text
@a435 43
		// __jsr inside a try block (to a PC outside the try block) causes the try
		// block to be broken into two blocks surrounding the __jsr
		// This is actually pretty common. Take, for example, the following code:
		//	class hello
		//	{
		//		public static void main(String[] args)
		//		{
		//			try
		//			{
		//				for(;;)
		//				{
		//					if(args.length == 0) return;
		//				}
		//			}
		//			finally
		//			{
		//				System.out.println("Hello, world!");
		//			}
		//		}
		//	}
		restart_jsr:
			for(int i = 0; i < ar.Count; i++)
			{
				ExceptionTableEntry ei = ar[i];
				for(int j = ei.startIndex, e = ei.endIndex; j < e; j++)
				{
					if(m.Instructions[j].NormalizedOpCode == NormalizedByteCode.__jsr)
					{
						int targetIndex = m.Instructions[j].TargetIndex;
						if(targetIndex < ei.startIndex || targetIndex >= ei.endIndex)
						{
							ExceptionTableEntry en = new ExceptionTableEntry();
							en.catch_type = ei.catch_type;
							en.handlerIndex = ei.handlerIndex;
							en.startIndex = j + 1;
							en.endIndex = ei.endIndex;
							ei.endIndex = j;
							ar.Insert(i + 1, en);
							goto restart_jsr;
						}
					}
				}
			}
d437 1
d464 1
a464 1
									goto restart_jsr;
a484 1
						case NormalizedByteCode.__jsr:
d496 1
a496 1
								goto restart_jsr;
d520 1
a520 1
					goto restart_jsr;
d561 1
a561 5
		//		Console.WriteLine("after processing:");
		//		foreach(ExceptionTableEntry e in ar)
		//		{
		//			Console.WriteLine("{0} to {1} handler {2}", e.start_pc, e.end_pc, e.handler_pc);
		//		}
d563 1
a563 1
		for (int i = 0; i < ar.Count; i++)
d567 1
a567 1
			if (!m.Instructions[ar[i].startIndex].IsReachable)
a601 12
			// make sure __jsr doesn't jump out of try block
			for(int j = exceptions[i].startIndex, e = exceptions[i].endIndex; j < e; j++)
			{
				if(m.Instructions[j].NormalizedOpCode == NormalizedByteCode.__jsr)
				{
					int targetIndex = m.Instructions[j].TargetIndex;
					if(targetIndex < exceptions[i].startIndex || targetIndex >= exceptions[i].endIndex)
					{
						throw new InvalidOperationException("Try block splitting around __jsr is broken");
					}
				}
			}
d2070 1
a2070 6
					// NOTE we use "int" to track the return address of a jsr
					if(VerifierTypeWrapper.IsRet(type))
					{
						StoreLocal(i);
					}
					else if(VerifierTypeWrapper.IsNew(type))
a2906 43
				case NormalizedByteCode.__jsr:
				{
					int index = instr.TargetIndex;
					int[] callsites = ma.GetCallSites(index);
					for(int j = 0; j < callsites.Length; j++)
					{
						if(callsites[j] == i)
						{
							ilGenerator.LazyEmitLdc_I4(j);
							break;
						}
					}
					ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.TargetIndex));
					break;
				}
				case NormalizedByteCode.__ret:
				{
					// NOTE using a OpCodes.Switch here is not efficient, because 99 out of a 100 cases
					// there are either one or two call sites.
					int subid = ((VerifierTypeWrapper)ma.GetLocalTypeWrapper(i, instr.Arg1)).Index;
					int[] callsites = ma.GetCallSites(subid);
					for(int j = 0; j < callsites.Length - 1; j++)
					{
						if(m.Instructions[callsites[j]].IsReachable)
						{
							LoadLocal(i);
							ilGenerator.LazyEmitLdc_I4(j);
							ilGenerator.Emit(OpCodes.Beq, block.GetLabel(callsites[j] + 1));
						}
					}
					if(m.Instructions[callsites[callsites.Length - 1]].IsReachable)
					{
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(callsites[callsites.Length - 1] + 1));
					}
					else
					{
						// this code location is unreachable, but the verifier doesn't know that, so we emit a branch to keep it happy
						// (it would be a little nicer to rewrite the above for loop to dynamically find the last reachable callsite,
						// but since this only happens with unreachable code, it's not a big deal).
						ilGenerator.Emit(OpCodes.Br_S, (sbyte)-2);
					}
					break;
				}
a2964 1
				case NormalizedByteCode.__jsr:
@


1.118
log
@Added support for inlining subroutines (jsr/ret) to allow the verifier and compiler to be simplified and to hopefully pave the way for future codegen optimizations.
@
text
@d609 11
@


1.117
log
@Changed bytecode stream and exception tables to use instruction indexes instead of PC.
@
text
@d291 4
@


1.116
log
@Changed LoadLocal/StoreLocal to take an instruction index, instead of an instruction.
@
text
@a39 1
using LocalVariableTableEntry = IKVM.Internal.ClassFile.Method.LocalVariableTableEntry;
d236 1
a236 1
			if(e1.start_pc < e2.start_pc)
d240 1
a240 1
			if(e1.start_pc == e2.start_pc)
d242 1
a242 1
				if(e1.end_pc == e2.end_pc)
d250 1
a250 1
				if(e1.end_pc > e2.end_pc)
d354 1
a354 1
			if(ei.start_pc == ei.handler_pc && ei.catch_type == 0)
d356 1
a356 1
				int index = FindPcIndex(ei.start_pc);
d358 1
a358 1
					&& FindPcIndex(ei.end_pc) == index + 2
d368 1
a368 1
					&& FindPcIndex(ei.end_pc) == index + 3
d390 1
a390 1
					if(ei.start_pc <= ej.start_pc && ej.start_pc < ei.end_pc)
d393 1
a393 1
						if(ej.end_pc > ei.end_pc)
d396 2
a397 2
							emi.start_pc = ej.start_pc;
							emi.end_pc = ei.end_pc;
d399 1
a399 1
							emi.handler_pc = ei.handler_pc;
d401 2
a402 2
							emj.start_pc = ej.start_pc;
							emj.end_pc = ei.end_pc;
d404 3
a406 3
							emj.handler_pc = ej.handler_pc;
							ei.end_pc = emi.start_pc;
							ej.start_pc = emj.end_pc;
d412 1
a412 1
						else if(j > i && ej.end_pc < ei.end_pc)
d415 2
a416 2
							emi.start_pc = ej.start_pc;
							emi.end_pc = ej.end_pc;
d418 1
a418 1
							emi.handler_pc = ei.handler_pc;
d420 2
a421 2
							eei.start_pc = ej.end_pc;
							eei.end_pc = ei.end_pc;
d423 2
a424 2
							eei.handler_pc = ei.handler_pc;
							ei.end_pc = emi.start_pc;
d456 1
a456 1
				for(int j = FindPcIndex(ei.start_pc), e = FindPcIndex(ei.end_pc); j < e; j++)
d460 2
a461 2
						int targetPC = m.Instructions[j].NormalizedArg1 + m.Instructions[j].PC;
						if(targetPC < ei.start_pc || targetPC >= ei.end_pc)
d465 4
a468 4
							en.handler_pc = ei.handler_pc;
							en.start_pc = (ushort)m.Instructions[j + 1].PC;
							en.end_pc = ei.end_pc;
							ei.end_pc = (ushort)m.Instructions[j].PC;
d479 2
a480 2
			int start = FindPcIndex(ei.start_pc);
			int end = FindPcIndex(ei.end_pc);
d492 2
a493 2
								int targetPC = m.Instructions[j].PC + (k == -1 ? m.Instructions[j].DefaultOffset : m.Instructions[j].GetSwitchTargetOffset(k));
								if(ei.start_pc < targetPC && targetPC < ei.end_pc)
d497 4
a500 4
									en.handler_pc = ei.handler_pc;
									en.start_pc = (ushort)targetPC;
									en.end_pc = ei.end_pc;
									ei.end_pc = (ushort)targetPC;
d525 2
a526 2
							int targetPC = m.Instructions[j].PC + m.Instructions[j].Arg1;
							if(ei.start_pc < targetPC && targetPC < ei.end_pc)
d530 4
a533 4
								en.handler_pc = ei.handler_pc;
								en.start_pc = (ushort)targetPC;
								en.end_pc = ei.end_pc;
								ei.end_pc = (ushort)targetPC;
d550 1
a550 1
				if(ei.start_pc < ej.handler_pc && ej.handler_pc < ei.end_pc)
d554 4
a557 4
					en.handler_pc = ei.handler_pc;
					en.start_pc = ej.handler_pc;
					en.end_pc = ei.end_pc;
					ei.end_pc = ej.handler_pc;
d567 1
a567 1
			if(ei.start_pc == ei.end_pc)
d584 2
a585 2
						int start = FindPcIndex(ei.start_pc);
						int end = FindPcIndex(ei.end_pc);
d620 3
a622 3
				if(exceptions[i].start_pc < exceptions[j].start_pc && 
					exceptions[j].start_pc < exceptions[i].end_pc &&
					exceptions[i].end_pc < exceptions[j].end_pc)
d627 2
a628 2
				if(exceptions[i].start_pc <= exceptions[j].start_pc &&
					exceptions[i].end_pc >= exceptions[j].end_pc &&
d635 1
a635 1
			for(int j = FindPcIndex(exceptions[i].start_pc), e = FindPcIndex(exceptions[i].end_pc); j < e; j++)
d639 2
a640 2
					int targetPC = m.Instructions[j].NormalizedArg1 + m.Instructions[j].PC;
					if(targetPC < exceptions[i].start_pc || targetPC >= exceptions[i].end_pc)
d677 1
a677 1
		internal readonly int TargetPC;
d680 1
a680 1
		internal BranchCookie(Compiler compiler, int stackHeight, int targetPC)
d683 1
a683 1
			this.TargetPC = targetPC;
d687 1
a687 1
		internal BranchCookie(CodeEmitterLabel label, int targetPC)
d690 1
a690 1
			this.TargetPC = targetPC;
d965 2
a966 2
		private int begin;
		private int end;
d972 1
a972 1
		internal Block(Compiler compiler, int beginPC, int endPC, int exceptionIndex, List<object> exits, bool nested)
d976 2
a977 2
			this.begin = beginPC;
			this.end = endPC;
d984 1
a984 1
		internal int End
d988 1
a988 1
				return end;
d1011 1
a1011 1
		internal CodeEmitterLabel GetLabel(int targetPC)
d1013 1
a1013 2
			int targetIndex = compiler.FindPcIndex(targetPC);
			if(IsInRange(targetPC))
d1032 1
a1032 1
					BranchCookie bc = new BranchCookie(compiler, stackHeight, targetPC);
d1066 1
a1066 1
		internal bool IsInRange(int pc)
d1068 1
a1068 1
			return begin <= pc && pc < end;
d1098 1
a1098 1
						if(bc.TargetPC == -1)
d1134 1
a1134 1
						if(bc != null && bc.TargetPC != -1)
d1139 1
a1139 1
							if(newBlock.IsInRange(bc.TargetPC))
d1148 1
a1148 1
								ilgen.Emit(OpCodes.Br, newBlock.GetLabel(bc.TargetPC));
d1176 2
a1177 2
		int start_pc = m.Instructions[instructionIndex].PC;
		int end_pc = m.Instructions[instructionIndex + instructionCount].PC;
d1181 1
a1181 1
			if(e.end_pc > start_pc && e.start_pc < end_pc)
d1208 1
a1208 1
			while(block.End == instr.PC)
d1219 1
a1219 1
				for(; exceptionIndex < exceptions.Length && exceptions[exceptionIndex].end_pc <= instr.PC; exceptionIndex++)
d1223 1
a1223 1
				int handlerIndex = FindPcIndex(exc.handler_pc);
d1283 1
a1283 1
					BranchCookie bc = new BranchCookie(this, 1, exc.handler_pc);
d1397 1
a1397 1
			for(; exceptionIndex < exceptions.Length && exceptions[exceptionIndex].start_pc == instr.PC; exceptionIndex++)
d1420 1
a1420 1
				block = new Block(this, exceptions[exceptionIndex].start_pc, exceptions[exceptionIndex].end_pc, exceptionIndex, new List<object>(), true);
d1429 1
a1429 1
					if(table[j].start_pc == instr.PC && table[j].line_number != 0)
d1485 1
a1485 1
						if(instr.Arg1 <= 0)
d2439 1
a2439 1
					ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.PC + instr.Arg1));
d2442 1
a2442 1
					ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.PC + instr.Arg1));
d2445 1
a2445 1
					ilGenerator.Emit(OpCodes.Ble, block.GetLabel(instr.PC + instr.Arg1));
d2448 1
a2448 1
					ilGenerator.Emit(OpCodes.Blt, block.GetLabel(instr.PC + instr.Arg1));
d2451 1
a2451 1
					ilGenerator.Emit(OpCodes.Bge, block.GetLabel(instr.PC + instr.Arg1));
d2454 1
a2454 1
					ilGenerator.Emit(OpCodes.Bgt, block.GetLabel(instr.PC + instr.Arg1));
d2457 1
a2457 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CodeEmitter.Comparison.LessOrEqual, block.GetLabel(instr.PC + instr.Arg1));
d2460 1
a2460 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CodeEmitter.Comparison.LessThan, block.GetLabel(instr.PC + instr.Arg1));
d2463 1
a2463 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CodeEmitter.Comparison.GreaterOrEqual, block.GetLabel(instr.PC + instr.Arg1));
d2466 1
a2466 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CodeEmitter.Comparison.GreaterThan, block.GetLabel(instr.PC + instr.Arg1));
d2469 1
a2469 1
					ilGenerator.LazyEmit_ifne(block.GetLabel(instr.PC + instr.Arg1));
d2472 1
a2472 1
					ilGenerator.LazyEmit_ifeq(block.GetLabel(instr.PC + instr.Arg1));
d2475 1
a2475 1
					ilGenerator.Emit(OpCodes.Brtrue, block.GetLabel(instr.PC + instr.Arg1));
d2478 1
a2478 1
					ilGenerator.Emit(OpCodes.Brfalse, block.GetLabel(instr.PC + instr.Arg1));
d2481 1
a2481 1
					ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.PC + instr.Arg1));
d2484 1
a2484 1
					ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.PC + instr.Arg1));
d2487 1
a2487 1
					ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.Arg1));
d2888 1
a2888 1
						labels[j] = block.GetLabel(instr.PC + instr.GetSwitchTargetOffset(j));
d2896 1
a2896 1
					ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.DefaultOffset));
d2907 1
a2907 1
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.GetSwitchTargetOffset(j)));
d2911 1
a2911 1
					ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.DefaultOffset));
d2958 1
a2958 1
					int index = FindPcIndex(instr.PC + instr.Arg1);
d2968 1
a2968 1
					ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.Arg1));
d2983 1
a2983 1
							ilGenerator.Emit(OpCodes.Beq, block.GetLabel(m.Instructions[callsites[j] + 1].PC));
d2988 1
a2988 1
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(m.Instructions[callsites[callsites.Length - 1] + 1].PC));
d3074 1
a3074 1
					if(m.Instructions[i + 1].PC == block.End)
d3077 1
a3077 1
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(m.Instructions[i + 1].PC));
a3488 14
	private int FindPcIndex(int target)
	{
		return m.PcIndexMap[target];
	}

	private int SafeFindPcIndex(int target)
	{
		if(target < 0 || target >= m.PcIndexMap.Length)
		{
			return -1;
		}
		return m.PcIndexMap[target];
	}

@


1.115
log
@Removed local variable scoping (from debug info) because it doesn't add much value and conflicts with future optimizations.
@
text
@d1236 1
a1236 1
					LoadLocal(m.Instructions[handlerIndex]);
d1254 1
a1254 1
					LoadLocal(m.Instructions[handlerIndex + 1]);
d2105 1
a2105 1
						LocalVar v = LoadLocal(instr);
d2119 1
a2119 1
						StoreLocal(instr);
d2135 1
a2135 1
						StoreLocal(instr);
d2143 1
a2143 1
					LoadLocal(instr);
d2147 1
a2147 1
					StoreLocal(instr);
d2151 1
a2151 1
					StoreLocal(instr);
d2155 1
a2155 1
					StoreLocal(instr);
d2158 1
a2158 1
					StoreLocal(instr);
d2916 1
a2916 1
					LoadLocal(instr);
d2919 1
a2919 1
					StoreLocal(instr);
d2983 1
a2983 1
							LoadLocal(instr);
d3505 1
a3505 1
	private LocalVar LoadLocal(ClassFile.Method.Instruction instr)
d3507 1
a3507 1
		LocalVar v = ma.GetLocalVar(FindPcIndex(instr.PC));
d3510 1
d3565 1
a3565 1
	private LocalVar StoreLocal(ClassFile.Method.Instruction instr)
d3567 1
a3567 1
		LocalVar v = ma.GetLocalVar(FindPcIndex(instr.PC));
d3575 1
@


1.114
log
@Renamed CodeEmitter.Finish() to CheckLabels() and moved invocation to the right place.
@
text
@a1200 49
		int[] scope = null;
		// if we're emitting debugging information, we need to use scopes for local variables
		if(debug)
		{
			scope = new int[m.Instructions.Length];
			LocalVariableTableEntry[] lvt = m.LocalVariableTableAttribute;
			if(lvt != null)
			{
				for(int i = 0; i < lvt.Length; i++)
				{
					// TODO validate the contents of the LVT entry
					int startIndex = SafeFindPcIndex(lvt[i].start_pc);
					if(startIndex > 0)
					{
						// NOTE javac (correctly) sets start_pc of the LVT entry to the instruction
						// following the store that first initializes the local, so we have to
						// detect that case and adjust our local scope (because we'll be creating
						// the local when we encounter the first store).
						LocalVar v = ma.GetLocalVar(startIndex - 1);
						if(v != null && v.local == lvt[i].index)
						{
							startIndex--;
						}
					}
					int end = lvt[i].start_pc + lvt[i].length;
					int endIndex;
					if(end == m.Instructions[m.Instructions.Length - 1].PC)
					{
						endIndex = m.Instructions.Length - 1;
					}
					else
					{
						endIndex = SafeFindPcIndex(end);
					}
					if(startIndex != -1 && endIndex != -1)
					{
						scope[startIndex]++;
						scope[endIndex]--;
					}
					else
					{
						// the LVT range is invalid, but we need to have a scope for the variable,
						// so we create an artificial scope that spans the method
						scope[0]++;
						scope[m.Instructions.Length - 1]--;
					}
				}
			}
		}
a1208 12
			if(scope != null)
			{
				for(int j = scope[i]; j < 0; j++)
				{
					ilGenerator.EndScope();
				}
				for(int j = scope[i]; j > 0; j--)
				{
					ilGenerator.BeginScope();
				}
			}

@


1.113
log
@Rewrote exception handling to store Java exception state in our java.lang.Throwable class, instead of an additional object in a weak keyed map.
@
text
@a953 1
			ilGenerator.Finish();
@


1.112
log
@Implemented ikvm.internal.ClassLiteral<T> to allow for more efficient class literals.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
d157 1
a157 1
	private static MethodWrapper initCauseMethod;
d217 3
d227 1
a228 1
		initCauseMethod = java_lang_Throwable.GetMethodWrapper("initCause", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false);
d1882 1
a1882 2
								if(code[i + 1].NormalizedOpCode == NormalizedByteCode.__athrow
									&& thisType.GetMethodWrapper("fillInStackTrace", "()Ljava.lang.Throwable;", true).DeclaringType == java_lang_Throwable)
d1884 4
a1887 1
									ilGenerator.Emit(OpCodes.Call, suppressFillInStackTraceMethod);
d1897 2
a1898 7
								// HACK we call Throwable.initCause(null) to force creation of an ExceptionInfoHelper
								// (which disables future remapping of the exception) and to prevent others from
								// setting the cause.
								ilGenerator.Emit(OpCodes.Dup);
								ilGenerator.Emit(OpCodes.Ldnull);
								initCauseMethod.EmitCallvirt(ilGenerator);
								ilGenerator.Emit(OpCodes.Pop);
@


1.111
log
@- Moved class literal TypeWrapper -> Type step into expression emitter.
- Fixed Class.desiredAssertionStatus() instrinsic to use the RemoveAsserts flag from the right class loader.
@
text
@a888 7
				CodeEmitterLabel label = ilGenerator.DefineLabel();
				ilGenerator.Emit(OpCodes.Brtrue_S, label);
				ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
				getClassFromTypeHandle.EmitCall(ilGenerator);
				ilGenerator.Emit(OpCodes.Stsfld, context.ClassObjectField);
				ilGenerator.MarkLabel(label);
				ilGenerator.Emit(OpCodes.Ldsfld, context.ClassObjectField);
@


1.110
log
@- Added support for multi level stack tracking to CodeEmitter.
- Made most Pop emitting lazy to enable optimizing them away (together with corresponding push).
- Made loading class literal lazy, to enable optimizing them away when they aren't used (e.g. because an atomic intrinsic).
- Made Class.desiredAssertionStatus() into an intrinsic, to be able to optimize it away when -removeassertions is used.
@
text
@a1724 9
							else if(tw.IsGhostArray)
							{
								int rank = tw.ArrayRank;
								while(tw.IsArray)
								{
									tw = tw.ElementTypeWrapper;
								}
								ilGenerator.LazyEmitLoadClass(ArrayTypeWrapper.MakeArrayType(tw.TypeAsTBD, rank));
							}
d1727 1
a1727 1
								ilGenerator.LazyEmitLoadClass(tw.IsRemapped ? tw.TypeAsBaseType : tw.TypeAsTBD);
@


1.109
log
@Added explicit null check (to avoid Type.GetTypeHandle form showing up in the stack trace) and don't do the optimization if we can't prove that either object isn't a ghost array.
@
text
@d163 1
a163 1
	private static MethodWrapper getClassFromTypeHandle;
d788 1
a788 1
					compiler.ilGenerator.Emit(OpCodes.Pop);
d1642 1
a1642 1
					ilGenerator.Emit(OpCodes.Ldnull);
d1732 1
a1732 2
								ilGenerator.Emit(OpCodes.Ldtoken, ArrayTypeWrapper.MakeArrayType(tw.TypeAsTBD, rank));
								getClassFromTypeHandle.EmitCall(ilGenerator);
d1736 1
a1736 2
								ilGenerator.Emit(OpCodes.Ldtoken, tw.IsRemapped ? tw.TypeAsBaseType : tw.TypeAsTBD);
								getClassFromTypeHandle.EmitCall(ilGenerator);
d2209 1
a2209 1
						ilGenerator.Emit(OpCodes.Pop);
d2918 1
a2918 1
						ilGenerator.Emit(OpCodes.Pop);
d2924 1
a2924 1
							ilGenerator.Emit(OpCodes.Pop);
d2928 1
a2928 1
							ilGenerator.Emit(OpCodes.Pop);
d2937 1
a2937 1
						ilGenerator.Emit(OpCodes.Pop);
d3648 1
a3648 1
			ilGenerator.Emit(OpCodes.Pop);
d3664 1
a3664 1
			ilGenerator.Emit(OpCodes.Pop);
@


1.108
log
@Intrisified two uses of Object.getClass().
@
text
@d3085 2
@


1.107
log
@Removed JIT perf workaround that is no longer necessary as of .NET 2.0 SP2 (aka .NET 3.5 SP1).
@
text
@d3084 3
@


1.106
log
@Made 32 bit floating point math more compatible by rounding to 32 bit after every operation.
@
text
@a2454 12
				{
					// HACK the intermediate local is to work around a CLR JIT flaw,
					// without the intermediate local it will actually do an explicit
					// fstp/fld for the conv.r8, but with intermediate it notices
					// that the explicit conversion isn't needed since the array store
					// will already result in the conversion. Note that we still need
					// do the conv.r8, because otherwise it would be legal
					// (per ECMA CLI spec) for the JIT to reuse the unconverted value
					// on the FPU stack.
					LocalBuilder local = ilGenerator.UnsafeAllocTempLocal(typeof(double));
					ilGenerator.Emit(OpCodes.Stloc, local);
					ilGenerator.Emit(OpCodes.Ldloc, local);
a2457 1
				}
@


1.105
log
@As of .NET 2.0 SP2 (aka .NET 3.5 SP1) the x86 JIT now properly aligns the stack  when doing a conv.r8, so we can now use that instead of using our hack.
@
text
@a1613 4
					else if(tw == PrimitiveTypeWrapper.FLOAT)
					{
						ilGenerator.Emit(OpCodes.Conv_R4);
					}
a1630 4
					else if(tw == PrimitiveTypeWrapper.FLOAT)
					{
						ilGenerator.Emit(OpCodes.Conv_R4);
					}
d2229 1
a2229 4
				case NormalizedByteCode.__fstore_conv:
					ilGenerator.Emit(OpCodes.Conv_R4);
					StoreLocal(instr);
					break;
d2447 1
a2450 10
				case NormalizedByteCode.__fastore_conv:
				{
					// see dastore_conv comment
					LocalBuilder local = ilGenerator.UnsafeAllocTempLocal(typeof(float));
					ilGenerator.Emit(OpCodes.Stloc, local);
					ilGenerator.Emit(OpCodes.Ldloc, local);
					ilGenerator.Emit(OpCodes.Conv_R4);
					ilGenerator.Emit(OpCodes.Stelem_R4);
					break;
				}
d2596 1
a2596 4
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R4);
					}
d2611 1
a2611 4
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R4);
					}
d2638 1
a2638 4
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R4);
					}
d2655 1
a2655 4
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R4);
					}
d2695 1
a2695 4
					if(strictfp)
					{
						ilGenerator.Emit(OpCodes.Conv_R4);
					}
@


1.104
log
@If the last call site of a subroutine wasn't reachable, the return switch would fall through potentially causing the code to be unverifiable.
@
text
@d2245 2
a2246 18
				{
					LocalVar v = StoreLocal(instr);
					if(v != null && !v.isArg)
					{
						// HACK this appears to be the fastest way to do the equivalent of
						// an explicit conv.r8. Simply doing a conv.r8 can result in the
						// CLR JIT using an unaligned stack address for the conversion
						// and that is ridiculously expensive. Doing this indirect load
						// triggers the stack alignment and according to my reading
						// of the ECMA CLI spec is guaranteed to result in a converted
						// value (and in practice it actually works and seems to
						// perform reasonably well). The downside is that it affects
						// performance negatively on x64 where a conv.r8 is free.
						ilGenerator.Emit(OpCodes.Ldloca, v.builder);
						ilGenerator.Emit(OpCodes.Volatile);
						ilGenerator.Emit(OpCodes.Ldind_R8);
						ilGenerator.Emit(OpCodes.Pop);
					}
a2247 1
				}
a3633 14
			if(v.type == PrimitiveTypeWrapper.DOUBLE)
			{
				ilGenerator.Emit(OpCodes.Ldarga, (short)i);
				ilGenerator.Emit(OpCodes.Volatile);
				ilGenerator.Emit(OpCodes.Ldind_R8);
				return v;
			}
			if(v.type == PrimitiveTypeWrapper.FLOAT)
			{
				ilGenerator.Emit(OpCodes.Ldarga, (short)i);
				ilGenerator.Emit(OpCodes.Volatile);
				ilGenerator.Emit(OpCodes.Ldind_R4);
				return v;
			}
d3659 8
@


1.103
log
@The check for unloadable types on the stack indexed the stack in the wrong order.
@
text
@d3137 7
@


1.102
log
@Integrated IKVM.Reflection.Emit in ikvmc.
@
text
@d3299 1
a3299 1
				if(ma.GetRawStackTypeWrapper(instructionIndex, i).IsUnloadable)
@


1.101
log
@Changed dynamic (for unloadable classes) bytecode handling to use Java reflection.
@
text
@d29 3
d33 1
@


1.101.2.1
log
@Changed version to 0.38.0.3 and backported these fixes:
- Fixed the stack trace when an unwrapped java.lang.Error (or subclass) escapes from a static initializer.
- It turns out that we really should create an MBeanServer in sun.management.ManagementFactory.createPlatformMBeanServer(), even if we don't populate it with anything useful, applications might still want to register their own MBeans. This fix allows Derby 10.4.2.0 to work.
- Added helpful message to ClassCastException generated for ghost array casts.
- Added check for constructor with missing body in map.xml.
- Removed over eager state checking from java.util.zip.Deflater. Fixes Lucene issue.
- Fixed enclosing method discovery to work for ReflectionOnly assemblies. This allows ikvmstub to work with ikvmc generated assemblies.
- Always emit an explicit method override if we've mangled the name/sig, because we can't predict whether it will be needed or not (without keeping track of the mangling in the base classes) and the cost is minimal since this doesn't happen all that often.
- Miranda method should use mangled name (if the name is mangled).
- Fixed pointer detection to work for types with multiple indirection levels.
- If the last call site of a subroutine wasn't reachable, the return switch would fall through potentially causing the code to be unverifiable.
- The check for unloadable types on the stack indexed the stack in the wrong order.
- Fixed exception wrapping for java.security.AccessController.doPrivileged().
- Fixed tracer to only add a trace listener in executables.
@
text
@a3132 7
					else
					{
						// this code location is unreachable, but the verifier doesn't know that, so we emit a branch to keep it happy
						// (it would be a little nicer to rewrite the above for loop to dynamically find the last reachable callsite,
						// but since this only happens with unreachable code, it's not a big deal).
						ilGenerator.Emit(OpCodes.Br_S, (sbyte)-2);
					}
d3295 1
a3295 1
				if(ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i).IsUnloadable)
@


1.100
log
@Bug fix: dynamic (for unloadable classes) getfield/getstatic/invoke* bytecode compilation couldn't handle ghost types.
@
text
@d3409 1
d3463 1
d3467 1
a3467 1
		internal DynamicMethodWrapper(TypeWrapper wrapper, ClassFile.ConstantPoolItemMI cpi)
d3470 1
d3516 1
d3587 1
a3587 1
				return new DynamicMethodWrapper(clazz, cpi);
d3593 1
a3593 1
			return new DynamicMethodWrapper(clazz, cpi);
@


1.99
log
@Generified all collections.
@
text
@d3456 1
a3456 1
			ilgen.Emit(OpCodes.Castclass, typeWrapper.TypeAsTBD);
@


1.98
log
@Replaced usage of BootstrapClassLoader with actual class loader in static compiler.
@
text
@d27 1
a27 1
using System.Collections;
d124 24
d177 1
a177 1
	private Hashtable invokespecialstubcache;
d226 1
a226 1
	private class ExceptionSorter : IComparer
d228 1
a228 1
		public int Compare(object x, object y)
a229 2
			ExceptionTableEntry e1 = (ExceptionTableEntry)x;
			ExceptionTableEntry e2 = (ExceptionTableEntry)y;
d253 1
a253 1
	private Compiler(DynamicTypeWrapper.FinishContext context, TypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ClassLoaderWrapper classLoader, ISymbolDocumentWriter symboldocument, Hashtable invokespecialstubcache)
d333 1
a333 1
		ArrayList ar = new ArrayList(m.ExceptionTable);
d347 1
a347 1
			ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
d380 1
a380 1
				ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
d383 1
a383 1
					ExceptionTableEntry ej = (ExceptionTableEntry)ar[j];
d449 1
a449 1
				ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
d472 1
a472 1
			ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
d540 1
a540 1
			ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
d543 1
a543 1
				ExceptionTableEntry ej = (ExceptionTableEntry)ar[j];
d560 1
a560 1
			ExceptionTableEntry ei = (ExceptionTableEntry)ar[i];
d600 1
a600 2
		exceptions = new ExceptionTableEntry[ar.Count];
		ar.CopyTo(exceptions, 0);
d798 1
a798 1
	internal static void Compile(DynamicTypeWrapper.FinishContext context, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, CodeEmitter ilGenerator, ref bool nonleaf, Hashtable invokespecialstubcache, ref LineNumberTableAttribute.LineNumberWriter lineNumberTable)
d897 1
a897 1
				Block b = new Block(c, 0, int.MaxValue, -1, new ArrayList(), true);
d970 1
a970 1
		private ArrayList exits;
d974 1
a974 1
		internal Block(Compiler compiler, int beginPC, int endPC, int exceptionIndex, ArrayList exits, bool nested)
d1008 1
a1008 1
				exits = new ArrayList();
d1177 1
a1177 1
	private bool IsGuardedBlock(Stack blockStack, int instructionIndex, int instructionCount)
d1253 1
a1253 1
		Stack blockStack = new Stack();
d1279 1
a1279 1
				block = (Block)blockStack.Pop();
d1484 1
a1484 1
				block = new Block(this, exceptions[exceptionIndex].start_pc, exceptions[exceptionIndex].end_pc, exceptionIndex, new ArrayList(), true);
d3217 3
a3219 3
		string key = method.DeclaringType.Name + ":" + method.Name + method.Signature;
		MethodInfo mi = (MethodInfo)invokespecialstubcache[key];
		if(mi == null)
@


1.97
log
@- Added ghost array tagging to be able to report the instantiated class (instead of object[] which is allocated instead).
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
@
text
@d3510 1
a3510 1
			code.Emit(ilgen);
d3515 1
a3515 1
			code.Emit(ilgen);
d3520 1
a3520 1
			code.Emit(ilgen);
@


1.96
log
@Don't generate unneeded GC.KeepAlive() in constructor for Exception types that don't have a finalize() method.
@
text
@d43 2
d87 2
d1708 10
d2287 12
d2319 1
a2319 1
					else
d2331 10
@


1.95
log
@- Renamed CountingILGenerator to CodeEmitter.
- Renamed CountingLabel to CodeEmitterLabel.
@
text
@d246 1
a246 1
			keepAlive = finalize != null && finalize.DeclaringType != java_lang_Object && finalize.DeclaringType != cli_System_Object;
@


1.94
log
@Removed CodeEmitter abstract base class.
@
text
@a34 3
using ILGenerator = IKVM.Internal.CountingILGenerator;
using Label = IKVM.Internal.CountingLabel;

d143 1
a143 1
	private ILGenerator ilGenerator;
d227 1
a227 1
	private Compiler(DynamicTypeWrapper.FinishContext context, TypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, ClassLoaderWrapper classLoader, ISymbolDocumentWriter symboldocument, Hashtable invokespecialstubcache)
d620 1
a620 1
		private Label stub;
d623 1
a623 1
		internal ReturnCookie(Label stub, LocalBuilder local)
d629 1
a629 1
		internal void EmitRet(ILGenerator ilgen)
d643 2
a644 2
		internal Label Stub;
		internal Label TargetLabel;
d656 1
a656 1
		internal BranchCookie(Label label, int targetPC)
d773 1
a773 1
	internal static void Compile(DynamicTypeWrapper.FinishContext context, DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, ref bool nonleaf, Hashtable invokespecialstubcache, ref LineNumberTableAttribute.LineNumberWriter lineNumberTable)
d860 1
a860 1
				Label label = ilGenerator.DefineLabel();
d941 1
a941 1
		private ILGenerator ilgen;
d988 1
a988 1
		internal Label GetLabel(int targetPC)
d999 1
a999 1
				return (Label)l;
d1034 1
a1034 1
				Label l = ilgen.DefineLabel();
d1040 1
a1040 1
				ilgen.MarkLabel((Label)label);
d1384 1
a1384 1
						Label rethrow = ilGenerator.DefineLabel();
d2065 1
a2065 1
						Label label = ilGenerator.DefineLabel();
d2528 1
a2528 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CountingILGenerator.Comparison.LessOrEqual, block.GetLabel(instr.PC + instr.Arg1));
d2531 1
a2531 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CountingILGenerator.Comparison.LessThan, block.GetLabel(instr.PC + instr.Arg1));
d2534 1
a2534 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CountingILGenerator.Comparison.GreaterOrEqual, block.GetLabel(instr.PC + instr.Arg1));
d2537 1
a2537 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CountingILGenerator.Comparison.GreaterThan, block.GetLabel(instr.PC + instr.Arg1));
d2665 1
a2665 1
					Label label = ilGenerator.DefineLabel();
d2674 1
a2674 1
					Label label2 = ilGenerator.DefineLabel();
d2971 1
a2971 1
					Label[] labels = new Label[instr.SwitchEntryCount];
d2990 1
a2990 1
						Label label = ilGenerator.DefineLabel();
d3165 1
a3165 1
			ILGenerator ilgen = stub.GetILGenerator();
d3377 1
a3377 1
	private static void EmitReturnTypeConversion(ILGenerator ilgen, TypeWrapper typeWrapper)
d3415 1
a3415 1
		internal override void EmitCall(ILGenerator ilgen)
d3420 1
a3420 1
		internal override void EmitCallvirt(ILGenerator ilgen)
d3425 1
a3425 1
		internal override void EmitNewobj(ILGenerator ilgen, MethodAnalyzer ma, int opcodeIndex)
d3430 1
a3430 1
		private void Emit(MethodInfo helperMethod, ILGenerator ilGenerator, TypeWrapper retTypeWrapper)
d3472 1
a3472 1
		internal override void EmitCall(ILGenerator ilgen)
d3477 1
a3477 1
		internal override void EmitCallvirt(ILGenerator ilgen)
d3482 1
a3482 1
		internal override void EmitNewobj(ILGenerator ilgen, MethodAnalyzer ma, int opcodeIndex)
@


1.93
log
@Marked all static classes as static.
@
text
@d3467 1
a3467 1
		private CodeEmitter code;
d3469 1
a3469 1
		internal ReplacedMethodWrapper(ClassFile.ConstantPoolItemMI cpi, CodeEmitter code)
@


1.92
log
@Refactored finish state/methods from JavaTypeImpl into FinishContext.
@
text
@d42 1
a42 1
class ByteCodeHelperMethods
@


1.91
log
@Renamed invokespecial stub to follow the common convention for not-visible-from-java members.
@
text
@d141 1
d230 1
a230 1
	private Compiler(TypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, ClassLoaderWrapper classLoader, ISymbolDocumentWriter symboldocument, Hashtable invokespecialstubcache)
d232 1
d776 1
a776 1
	internal static void Compile(DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, ref bool nonleaf, Hashtable invokespecialstubcache, ref LineNumberTableAttribute.LineNumberWriter lineNumberTable)
d834 1
a834 1
				c = new Compiler(clazz, mw, classFile, m, ilGenerator, classLoader, symboldocument, invokespecialstubcache);
d862 1
a862 1
				ilGenerator.Emit(OpCodes.Ldsfld, clazz.ClassObjectField);
d867 1
a867 1
				ilGenerator.Emit(OpCodes.Stsfld, clazz.ClassObjectField);
d869 1
a869 1
				ilGenerator.Emit(OpCodes.Ldsfld, clazz.ClassObjectField);
d1724 1
a1724 1
					if(method.IsIntrinsic && Intrinsics.Emit(ilGenerator, method, ma, i, mw, classFile, code))
d1733 1
a1733 1
						ilGenerator.Emit(OpCodes.Ldsfld, ((DynamicTypeWrapper)clazz).CallerIDField);
d1768 1
a1768 1
					if(method.IsIntrinsic && Intrinsics.Emit(ilGenerator, method, ma, i, mw, classFile, code))
d1992 1
a1992 1
							ilGenerator.Emit(OpCodes.Ldsfld, ((DynamicTypeWrapper)clazz).CallerIDField);
@


1.90
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@d3165 1
a3165 1
			MethodBuilder stub = clazz.TypeAsBuilder.DefineMethod("<>", MethodAttributes.PrivateScope, method.ReturnTypeForDefineMethod, method.GetParametersForDefineMethod());
@


1.89
log
@Pass caller method instead of type to intrinsic infrastructure.
@
text
@d1729 4
d1988 5
@


1.88
log
@- added more efficient float/double to/from int/long bits converters
- made Double.doubleToRawLongBits/longBitsToDouble and Float.floatToRawIntBits/intBitsToFloat intrinsics
- generalized the intrinsics support
@
text
@d1722 1
a1722 1
					if(method.IsIntrinsic && Intrinsics.Emit(ilGenerator, method, ma, i, clazz, classFile, code))
d1762 1
a1762 1
					if(method.IsIntrinsic && Intrinsics.Emit(ilGenerator, method, ma, i, clazz, classFile, code))
@


1.87
log
@Replaced notion of DynamicOnly types with Fake types. Fake types are implemented as generic type instances and can have DynamicOnly methods.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d1721 2
a1722 53
					// HACK special case for calls to System.arraycopy, if the array arguments on the stack
					// are of a known array type, we can redirect to an optimized version of arraycopy.
					// Note that we also have to handle VMSystem.arraycopy, because StringBuffer directly calls
					// this method to avoid prematurely initialising System.
					if((ReferenceEquals(cpi.Class, StringConstants.JAVA_LANG_SYSTEM) || ReferenceEquals(cpi.Class, StringConstants.JAVA_LANG_VMSYSTEM))
						&& ReferenceEquals(cpi.Name, StringConstants.ARRAYCOPY)
						&& ReferenceEquals(cpi.Signature, StringConstants.SIG_ARRAYCOPY)
						&& cpi.GetClassType().GetClassLoader() == java_lang_Class.GetClassLoader())
					{
						TypeWrapper dst_type = ma.GetStackTypeWrapper(i, 2);
						TypeWrapper src_type = ma.GetStackTypeWrapper(i, 4);
						if(!dst_type.IsUnloadable && dst_type.IsArray && dst_type == src_type)
						{
							switch(dst_type.Name[1])
							{
								case 'J':
								case 'D':
									ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.arraycopy_primitive_8);
									break;
								case 'I':
								case 'F':
									ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.arraycopy_primitive_4);
									break;
								case 'S':
								case 'C':
									ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.arraycopy_primitive_2);
									break;
								case 'B':
								case 'Z':
									ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.arraycopy_primitive_1);
									break;
								default:
									// TODO once the verifier tracks actual types (i.e. it knows that
									// a particular reference is the result of a "new" opcode) we can
									// use the fast version if the exact destination type is known
									// (in that case the "dst_type == src_type" above should
									// be changed to "src_type.IsAssignableTo(dst_type)".
									TypeWrapper elemtw = dst_type.ElementTypeWrapper;
									// note that IsFinal returns true for array types, so we have to be careful!
									if(!elemtw.IsArray && elemtw.IsFinal)
									{
										ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.arraycopy_fast);
									}
									else
									{
										ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.arraycopy);
									}
									break;
							}
							break;
						}
					}
					if(AtomicReferenceFieldUpdaterEmitter.Emit(clazz, ilGenerator, classFile, cpi, i, code))
a1725 1
					MethodWrapper method = GetMethodCallEmitter(cpi, instr.NormalizedOpCode);
d1762 1
a1762 4
#if STATIC_COMPILER
					if(method.DeclaringType == CoreClasses.java.lang.String.Wrapper
						&& ReferenceEquals(method.Name, StringConstants.TOCHARARRAY)
						&& ReferenceEquals(method.Signature, StringConstants.SIG_TOCHARARRAY))
d1764 1
a1764 11
						string str = ilGenerator.PopLazyLdstr();
						if(str != null)
						{
							// arbitrary length for "big" strings
							if(str.Length > 128)
							{
								EmitLoadCharArrayLiteral(ilGenerator, str, mw.DeclaringType);
								break;
							}
							ilGenerator.Emit(OpCodes.Ldstr, str);
						}
a1765 1
#endif
a3149 52
	private static void EmitLoadCharArrayLiteral(ILGenerator ilgen, string str, TypeWrapper tw)
	{
		ModuleBuilder mod = tw.GetClassLoader().GetTypeWrapperFactory().ModuleBuilder;
		// FXBUG on .NET 1.1 & 2.0 the value type that Ref.Emit automatically generates is public,
		// so we pre-create a non-public type with the right name here and it will "magically" use
		// that instead.
		// If we're running on Mono this isn't necessary, but for simplicitly we'll simply create
		// the type as well (it is useless, but all it does is waste a little space).
		int length = str.Length * 2;
		string typename = "$ArrayType$" + length;
		Type type = mod.GetType(typename, false, false);
		if(type == null)
		{
			if(tw.GetClassLoader().GetTypeWrapperFactory().ReserveName(typename))
			{
				TypeBuilder tb = mod.DefineType(typename, TypeAttributes.Sealed | TypeAttributes.Class | TypeAttributes.ExplicitLayout | TypeAttributes.NotPublic, typeof(ValueType), PackingSize.Size1, length);
				AttributeHelper.HideFromJava(tb);
				type = tb.CreateType();
			}
		}
		if(type == null
			|| !type.IsValueType
			|| type.StructLayoutAttribute.Pack != 1 || type.StructLayoutAttribute.Size != length)
		{
			// the type that we found doesn't match (must mean we've compiled a Java type with that name),
			// so we fall back to the string approach
			ilgen.Emit(OpCodes.Ldstr, str);
			ilgen.Emit(OpCodes.Call, typeof(string).GetMethod("ToCharArray", Type.EmptyTypes));
			return;
		}
		ilgen.Emit(OpCodes.Ldc_I4, str.Length);
		ilgen.Emit(OpCodes.Newarr, typeof(char));
		ilgen.Emit(OpCodes.Dup);
		byte[] data = new byte[length];
		for (int j = 0; j < str.Length; j++)
		{
			data[j * 2 + 0] = (byte)(str[j] >> 0);
			data[j * 2 + 1] = (byte)(str[j] >> 8);
		}
		// NOTE we define a module field, because type fields on Mono don't use the global $ArrayType$<n> type.
		// NOTE this also means that this will only work during static compilation, because ModuleBuilder.CreateGlobalFunctions() must
		// be called before the field can be used.
		FieldBuilder fb = mod.DefineInitializedData("__<str>", data, FieldAttributes.Static | FieldAttributes.PrivateScope);
		if(!fb.FieldType.Equals(type))
		{
			// this is actually relatively harmless, but I would like to know about it, so we abort and hope that users report this when they encounter it
			JVM.CriticalFailure("Unsupported runtime: ModuleBuilder.DefineInitializedData() field type mispredicted", null);
		}
		ilgen.Emit(OpCodes.Ldtoken, fb);
		ilgen.Emit(OpCodes.Call, typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("InitializeArray", new Type[] { typeof(Array), typeof(RuntimeFieldHandle) }));
	}

@


1.86
log
@- Added -removeassertions optimization option to ikvmc.
- Added -removeassertions to IKVM.OpenJDK.ClassLibrary.dll build.
- Don't look at unreachable instructions when determining if a method needs a line number table.
@
text
@d3640 1
a3640 1
		if(mw.DeclaringType.IsDynamicOnly)
@


1.85
log
@- Optimized codegen for lcmp, fcmp<x>, dcmp<x> and shift opcodes.
- Moved temp local handling to CodeEmitter.
@
text
@d892 5
a896 1
					if(m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__getfield
@


1.84
log
@Intrinsified AtomicReferenceFieldUpdater.newUpdater().
@
text
@a150 1
	private LocalBuilder[] tempLocals = new LocalBuilder[32];
a618 52
	private LocalBuilder UnsafeAllocTempLocal(Type type)
	{
		int free = -1;
		for(int i = 0; i < tempLocals.Length; i++)
		{
			LocalBuilder lb = tempLocals[i];
			if(lb == null)
			{
				if(free == -1)
				{
					free = i;
				}
			}
			else if(lb.LocalType == type)
			{
				return lb;
			}
		}
		LocalBuilder lb1 = ilGenerator.DeclareLocal(type);
		if(free != -1)
		{
			tempLocals[free] = lb1;
		}
		return lb1;
	}

	private LocalBuilder AllocTempLocal(Type type)
	{
		for(int i = 0; i < tempLocals.Length; i++)
		{
			LocalBuilder lb = tempLocals[i];
			if(lb != null && lb.LocalType == type)
			{
				tempLocals[i] = null;
				return lb;
			}
		}
		return ilGenerator.DeclareLocal(type);
	}

	private void ReleaseTempLocal(LocalBuilder lb)
	{
		for(int i = 0; i < tempLocals.Length; i++)
		{
			if(tempLocals[i] == null)
			{
				tempLocals[i] = lb;
				break;
			}
		}
	}

d691 1
a691 1
					compiler.ReleaseTempLocal(lb);
d727 1
a727 1
				locals[i] = compiler.AllocTempLocal(type.TypeAsLocalOrStackType);
d2116 1
a2116 1
							local = UnsafeAllocTempLocal(retTypeWrapper.TypeAsSignatureType);
d2166 1
a2166 1
								LocalBuilder local = AllocTempLocal(retTypeWrapper.TypeAsSignatureType);
d2170 1
a2170 1
								ReleaseTempLocal(local);
d2305 2
a2306 2
					LocalBuilder localArray = UnsafeAllocTempLocal(typeof(int[]));
					LocalBuilder localInt = UnsafeAllocTempLocal(typeof(int));
d2474 1
a2474 1
					LocalBuilder local = UnsafeAllocTempLocal(typeof(float));
d2494 1
a2494 1
					LocalBuilder local = UnsafeAllocTempLocal(typeof(double));
d2520 1
a2520 1
							LocalBuilder local = UnsafeAllocTempLocal(typeof(object));
d2549 1
a2549 14
				{
					LocalBuilder value1 = AllocTempLocal(typeof(long));
					LocalBuilder value2 = AllocTempLocal(typeof(long));
					ilGenerator.Emit(OpCodes.Stloc, value2);
					ilGenerator.Emit(OpCodes.Stloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Cgt);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Clt);
					ilGenerator.Emit(OpCodes.Sub);
					ReleaseTempLocal(value1);
					ReleaseTempLocal(value2);
a2550 1
				}
d2552 1
a2552 14
				{
					LocalBuilder value1 = AllocTempLocal(typeof(float));
					LocalBuilder value2 = AllocTempLocal(typeof(float));
					ilGenerator.Emit(OpCodes.Stloc, value2);
					ilGenerator.Emit(OpCodes.Stloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Cgt);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Clt_Un);
					ilGenerator.Emit(OpCodes.Sub);
					ReleaseTempLocal(value1);
					ReleaseTempLocal(value2);
a2553 1
				}
d2555 1
a2555 14
				{
					LocalBuilder value1 = AllocTempLocal(typeof(float));
					LocalBuilder value2 = AllocTempLocal(typeof(float));
					ilGenerator.Emit(OpCodes.Stloc, value2);
					ilGenerator.Emit(OpCodes.Stloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Cgt_Un);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Clt);
					ilGenerator.Emit(OpCodes.Sub);
					ReleaseTempLocal(value1);
					ReleaseTempLocal(value2);
a2556 1
				}
d2558 1
a2558 14
				{
					LocalBuilder value1 = AllocTempLocal(typeof(double));
					LocalBuilder value2 = AllocTempLocal(typeof(double));
					ilGenerator.Emit(OpCodes.Stloc, value2);
					ilGenerator.Emit(OpCodes.Stloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Cgt);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Clt_Un);
					ilGenerator.Emit(OpCodes.Sub);
					ReleaseTempLocal(value1);
					ReleaseTempLocal(value2);
a2559 1
				}
d2561 1
a2561 14
				{
					LocalBuilder value1 = AllocTempLocal(typeof(double));
					LocalBuilder value2 = AllocTempLocal(typeof(double));
					ilGenerator.Emit(OpCodes.Stloc, value2);
					ilGenerator.Emit(OpCodes.Stloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Cgt_Un);
					ilGenerator.Emit(OpCodes.Ldloc, value1);
					ilGenerator.Emit(OpCodes.Ldloc, value2);
					ilGenerator.Emit(OpCodes.Clt);
					ilGenerator.Emit(OpCodes.Sub);
					ReleaseTempLocal(value1);
					ReleaseTempLocal(value2);
a2562 1
				}
d2582 1
a2582 2
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.Emit(OpCodes.Ble, block.GetLabel(instr.PC + instr.Arg1));
d2585 1
a2585 2
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.Emit(OpCodes.Blt, block.GetLabel(instr.PC + instr.Arg1));
d2588 1
a2588 2
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.Emit(OpCodes.Bge, block.GetLabel(instr.PC + instr.Arg1));
d2591 1
a2591 2
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.Emit(OpCodes.Bgt, block.GetLabel(instr.PC + instr.Arg1));
d2750 1
a2750 2
					ilGenerator.LazyEmitLdc_I4(31);
					ilGenerator.Emit(OpCodes.And);
d2754 1
a2754 2
					ilGenerator.LazyEmitLdc_I4(63);
					ilGenerator.Emit(OpCodes.And);
d2758 1
a2758 2
					ilGenerator.LazyEmitLdc_I4(31);
					ilGenerator.Emit(OpCodes.And);
d2762 1
a2762 2
					ilGenerator.LazyEmitLdc_I4(63);
					ilGenerator.Emit(OpCodes.And);
d2766 1
a2766 2
					ilGenerator.LazyEmitLdc_I4(31);
					ilGenerator.Emit(OpCodes.And);
d2770 1
a2770 2
					ilGenerator.LazyEmitLdc_I4(63);
					ilGenerator.Emit(OpCodes.And);
d3397 1
a3397 1
						LocalBuilder ghost = AllocTempLocal(typeof(object));
d3399 1
a3399 1
						LocalBuilder local = AllocTempLocal(args[i].TypeAsSignatureType);
d3404 2
a3405 1
						ReleaseTempLocal(local);
@


1.83
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d1822 4
@


1.82
log
@Fix to make sure that a ghost interface method call always goes thru the target reference wrapping path.
@
text
@a31 1
using IKVM.Runtime;
d84 1
a84 1
		Type typeofByteCodeHelper = typeof(ByteCodeHelper);
d3363 1
a3363 4
#if WHIDBEY
			|| type.StructLayoutAttribute.Pack != 1 || type.StructLayoutAttribute.Size != length
#endif
			)
@


1.81
log
@Implemented optimized reflection/serialization when running on .NET 2.0 (by generating DynamicMethods instead of using .NET reflection).
@
text
@d1912 10
a1921 1
							args[0] = cpi.GetClassType();
@


1.80
log
@Enabled workaround for x64 tail call optimization in .NET 1.1 builds.
@
text
@d127 1
a127 1
	private static MethodInfo mapExceptionFastMethod;
@


1.80.2.1
log
@Backported fixes from trunk. Changed version to 0.36.0.3.
@
text
@d127 1
a127 1
	internal static MethodInfo mapExceptionFastMethod;
@


1.80.2.2
log
@Backported fixes and changed version to 0.36.0.5
@
text
@d1912 1
a1912 10
							if(method.DeclaringType.IsGhost)
							{
								// if we're calling a ghost interface method, we need to make sure that CastInterfaceArgs knows
								// (cpi.GetClassType() could be an interface that extends the ghost interface)
								args[0] = method.DeclaringType;
							}
							else
							{
								args[0] = cpi.GetClassType();
							}
@


1.80.2.3
log
@- Changed version to 0.36.0.9
- Added java.util.BitSet perf hack to map.xml
- Back ported codegen optimizations from 0.37.2970
@
text
@d32 1
d85 1
a85 1
		Type typeofByteCodeHelper = typeof(IKVM.Runtime.ByteCodeHelper);
d152 1
d621 52
d745 1
a745 1
					compiler.ilGenerator.ReleaseTempLocal(lb);
d781 1
a781 1
				locals[i] = compiler.ilGenerator.AllocTempLocal(type.TypeAsLocalOrStackType);
d2166 1
a2166 1
							local = ilGenerator.UnsafeAllocTempLocal(retTypeWrapper.TypeAsSignatureType);
d2216 1
a2216 1
								LocalBuilder local = ilGenerator.AllocTempLocal(retTypeWrapper.TypeAsSignatureType);
d2220 1
a2220 1
								ilGenerator.ReleaseTempLocal(local);
d2355 2
a2356 2
					LocalBuilder localArray = ilGenerator.UnsafeAllocTempLocal(typeof(int[]));
					LocalBuilder localInt = ilGenerator.UnsafeAllocTempLocal(typeof(int));
d2524 1
a2524 1
					LocalBuilder local = ilGenerator.UnsafeAllocTempLocal(typeof(float));
d2544 1
a2544 1
					LocalBuilder local = ilGenerator.UnsafeAllocTempLocal(typeof(double));
d2570 1
a2570 1
							LocalBuilder local = ilGenerator.UnsafeAllocTempLocal(typeof(object));
d2599 14
a2612 1
					ilGenerator.LazyEmit_lcmp();
d2614 1
d2616 14
a2629 1
					ilGenerator.LazyEmit_fcmpl();
d2631 1
d2633 14
a2646 1
					ilGenerator.LazyEmit_fcmpg();
d2648 1
d2650 14
a2663 1
					ilGenerator.LazyEmit_dcmpl();
d2665 1
d2667 14
a2680 1
					ilGenerator.LazyEmit_dcmpg();
d2682 1
d2702 2
a2703 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CountingILGenerator.Comparison.LessOrEqual, block.GetLabel(instr.PC + instr.Arg1));
d2706 2
a2707 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CountingILGenerator.Comparison.LessThan, block.GetLabel(instr.PC + instr.Arg1));
d2710 2
a2711 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CountingILGenerator.Comparison.GreaterOrEqual, block.GetLabel(instr.PC + instr.Arg1));
d2714 2
a2715 1
					ilGenerator.LazyEmit_if_le_lt_ge_gt(CountingILGenerator.Comparison.GreaterThan, block.GetLabel(instr.PC + instr.Arg1));
d2874 2
a2875 1
					ilGenerator.LazyEmitAnd_I4(31);
d2879 2
a2880 1
					ilGenerator.LazyEmitAnd_I4(63);
d2884 2
a2885 1
					ilGenerator.LazyEmitAnd_I4(31);
d2889 2
a2890 1
					ilGenerator.LazyEmitAnd_I4(63);
d2894 2
a2895 1
					ilGenerator.LazyEmitAnd_I4(31);
d2899 2
a2900 1
					ilGenerator.LazyEmitAnd_I4(63);
d3530 1
a3530 1
						LocalBuilder ghost = ilGenerator.AllocTempLocal(typeof(object));
d3532 1
a3532 1
						LocalBuilder local = ilGenerator.AllocTempLocal(args[i].TypeAsSignatureType);
d3537 1
a3537 2
						ilGenerator.ReleaseTempLocal(local);
						ilGenerator.ReleaseTempLocal(ghost);
@


1.80.2.4
log
@Don't look at unreachable instructions when determining if a method needs a line number table.
@
text
@d892 1
a892 5
					if(!m.Instructions[i].IsReachable)
					{
						// skip unreachable instructions
					}
					else if(m.Instructions[i].NormalizedOpCode == NormalizedByteCode.__getfield
@


1.80.2.5
log
@Back ported various fixes:
- Changed version to 0.36.0.13.
- Fixed ikvmc not to open the key file for write access.
- Added more efficient float/double to/from int/long bits converters.
- Fixed libikvm-native.so build to include reference to gmodule-2.0 library.
- Fixed ikvmc not to open the key file for write access.
- Fixed Graphics2D.rotate() to convert rotation angle from radians (Java) to degrees (.NET).
- Applied awt patch #1979656 by Daniel Wilson.
- Fixed three String bugs found by OpenJDK string tests.
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
- Removed incorrect DataFormatException thrown in java.util.zip.InflaterHuffmanTree.
- Fixed #2001802 contributed by Andy Malakov.
- Fixed #2001799.
- Fixed #2006953.
- Made finalize() and clone() methods in cli.System.Object and cli.System.Exception final.
@
text
@a1704 10
							else if(tw.IsGhostArray)
							{
								int rank = tw.ArrayRank;
								while(tw.IsArray)
								{
									tw = tw.ElementTypeWrapper;
								}
								ilGenerator.Emit(OpCodes.Ldtoken, ArrayTypeWrapper.MakeArrayType(tw.TypeAsTBD, rank));
								getClassFromTypeHandle.EmitCall(ilGenerator);
							}
d3508 1
a3508 1
			typeWrapper.EmitCheckcast(null, ilgen);
@


1.80.2.6
log
@Fixed regression introduced in previous check in.
@
text
@d3476 1
a3476 1
				EmitReturnTypeConversion(clazz, ilGenerator, fieldTypeWrapper);
d3485 1
a3485 1
				EmitReturnTypeConversion(clazz, ilGenerator, fieldTypeWrapper);
d3496 1
a3496 1
	private static void EmitReturnTypeConversion(TypeWrapper context, ILGenerator ilgen, TypeWrapper typeWrapper)
d3518 1
a3518 1
			typeWrapper.EmitCheckcast(context, ilgen);
d3576 1
a3576 1
			EmitReturnTypeConversion(wrapper, ilGenerator, retTypeWrapper);
@


1.79
log
@Don't add KeepAlive to constructors of objects that don't have finalizers and extend cli.System.Object.
@
text
@a2172 1
#if WHIDBEY
a2189 1
#endif // WHIDBEY
@


1.78
log
@Implemented improved floating point compliance.
@
text
@d249 1
a249 1
			keepAlive = finalize != null && finalize.DeclaringType != java_lang_Object;
@


1.77
log
@Made LVT handling more robust against bogus entries.
@
text
@d156 1
d241 1
d1628 12
d1649 12
d1829 12
d2124 12
d2293 6
d2300 23
d2514 10
d2527 17
d2739 2
d2742 6
d2750 4
d2757 2
d2760 6
d2768 4
d2787 2
d2790 6
d2798 4
d2810 6
d2818 4
d2853 6
d2861 4
d3810 14
d3869 1
a3869 1
	private void StoreLocal(ClassFile.Method.Instruction instr)
d3905 1
@


1.76
log
@Added support for locally (i.e. per method) replacing method calls with a custom CIL sequence.
@
text
@d1237 2
a1238 2
					int index = FindPcIndex(lvt[i].start_pc);
					if(index > 0)
d1244 1
a1244 1
						LocalVar v = ma.GetLocalVar(index - 1);
d1247 1
a1247 1
							index--;
a1249 1
					scope[index]++;
d1251 1
d1254 10
a1263 1
						scope[m.Instructions.Length - 1]--;
d1267 4
a1270 1
						scope[FindPcIndex(end)]--;
d3633 9
@


1.75
log
@Implemented ikvmc optimization for string literals that are only used to call toCharArray() on.
@
text
@d156 4
d249 7
d3518 28
d3548 18
d3567 1
a3567 1
		switch(invoke)
@


1.74
log
@Optimized lcmp, fcmpl, fcmpg, dcmpl and dcmpg by Dennis Ushakov.
@
text
@d1502 4
a1505 1
						if(lineNumbers != null)
d1693 1
a1693 1
							ilGenerator.Emit(OpCodes.Ldstr, classFile.GetConstantPoolConstantString(constant));
d1799 19
d3150 55
@


1.73
log
@Removed workaround for x64 CLR JIT bug from sun.misc.FloatingDecimal and added generic workaround to the compiler.
@
text
@d2448 1
a2448 2
					Label res1 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Bgt_S, res1);
d2451 2
a2452 11
					Label res0 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Beq_S, res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_M1);
					Label end = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(res1);
					ilGenerator.Emit(OpCodes.Ldc_I4_1);
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.MarkLabel(end);
d2465 1
a2465 2
					Label res1 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Bgt_S, res1);
d2468 2
a2469 11
					Label res0 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Beq_S, res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_M1);
					Label end = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(res1);
					ilGenerator.Emit(OpCodes.Ldc_I4_1);
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.MarkLabel(end);
d2482 1
a2482 2
					Label resm1 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Blt_S, resm1);
d2485 2
a2486 11
					Label res0 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Beq_S, res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_1);
					Label end = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(resm1);
					ilGenerator.Emit(OpCodes.Ldc_I4_M1);
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.MarkLabel(end);
d2499 1
a2499 2
					Label res1 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Bgt_S, res1);
d2502 2
a2503 11
					Label res0 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Beq_S, res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_M1);
					Label end = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(res1);
					ilGenerator.Emit(OpCodes.Ldc_I4_1);
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.MarkLabel(end);
d2516 1
a2516 2
					Label resm1 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Blt_S, resm1);
d2519 2
a2520 11
					Label res0 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Beq_S, res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_1);
					Label end = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(resm1);
					ilGenerator.Emit(OpCodes.Ldc_I4_M1);
					ilGenerator.Emit(OpCodes.Br_S, end);
					ilGenerator.MarkLabel(res0);
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.MarkLabel(end);
@


1.72
log
@Implemented JSR 133 rule that says that finalize cannot run before constructor is finished.
@
text
@d1650 14
a1663 1
							ilGenerator.Emit(OpCodes.Ldc_R8, classFile.GetConstantPoolConstantDouble(constant));
d1665 1
d1667 14
a1680 1
							ilGenerator.Emit(OpCodes.Ldc_R4, classFile.GetConstantPoolConstantFloat(constant));
d1682 1
@


1.71
log
@Fixed verifier/compiler to support dup_x2 form 2. Found by Derby test suite. Thanks to Albert Strasheim.
@
text
@d134 1
d155 1
d162 1
d240 5
d1511 55
@


1.70
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d2816 30
a2845 12
					DupHelper dh = new DupHelper(this, 3);
					dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
					dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
					dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
					dh.Store(0);
					dh.Store(1);
					dh.Store(2);
					dh.Load(0);
					dh.Load(2);
					dh.Load(1);
					dh.Load(0);
					dh.Release();
@


1.70.2.1
log
@Back ported the dup_x2 fix.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d2816 12
a2827 30
					TypeWrapper type2 = ma.GetRawStackTypeWrapper(i, 1);
					if(type2.IsWidePrimitive)
					{
						// Form 2
						DupHelper dh = new DupHelper(this, 2);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, type2);
						dh.Store(0);
						dh.Store(1);
						dh.Load(0);
						dh.Load(1);
						dh.Load(0);
						dh.Release();
					}
					else
					{
						// Form 1
						DupHelper dh = new DupHelper(this, 3);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, type2);
						dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
						dh.Store(0);
						dh.Store(1);
						dh.Store(2);
						dh.Load(0);
						dh.Load(2);
						dh.Load(1);
						dh.Load(0);
						dh.Release();
					}
@


1.70.2.2
log
@back ported the follwing fixes and incremented version to 0.34.0.4:
- magic assembly type for assembly attribute annotations (bug #1721688)
- LocalVariableTable robustness fix (bug #1765952)
- public interfaces extending non-public interfaces
- parameter annotations on redirected contructors
- casting ghost interface arrays (bug #1757889)
- JNI NewObject fix
- make sure all implemented interface methods on .NET types are public (so that ikvmstub generates jars that javac is happy with)
@
text
@d1218 2
a1219 2
					int startIndex = SafeFindPcIndex(lvt[i].start_pc);
					if(startIndex > 0)
d1225 1
a1225 1
						LocalVar v = ma.GetLocalVar(startIndex - 1);
d1228 1
a1228 1
							startIndex--;
d1231 1
a1232 1
					int endIndex;
d1235 1
a1235 1
						endIndex = m.Instructions.Length - 1;
d1239 1
a1239 13
						endIndex = SafeFindPcIndex(end);
					}
					if(startIndex != -1 && endIndex != -1)
					{
						scope[startIndex]++;
						scope[endIndex]--;
					}
					else
					{
						// the LVT range is invalid, but we need to have a scope for the variable,
						// so we create an artificial scope that spans the method
						scope[0]++;
						scope[m.Instructions.Length - 1]--;
a3445 9
	private int SafeFindPcIndex(int target)
	{
		if(target < 0 || target >= m.PcIndexMap.Length)
		{
			return -1;
		}
		return m.PcIndexMap[target];
	}

@


1.69
log
@*** empty log message ***
@
text
@d3373 1
d3377 2
a3378 1
				return cpi.GetMethodForInvokespecial();
d3380 2
a3381 5
				if(cpi.GetClassType().IsDynamicOnly)
				{
					return new DynamicMethodWrapper(clazz, cpi);
				}
				return cpi.GetMethod();
d3384 2
a3385 1
				return cpi.GetMethod();
d3394 5
@


1.68
log
@*** empty log message ***
@
text
@d1560 1
a1560 1
					EmitLdc_I4(instr.NormalizedArg1);
d1563 1
a1563 2
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.Emit(OpCodes.Conv_I8);
d1566 1
a1566 2
					ilGenerator.Emit(OpCodes.Ldc_I4_1);
					ilGenerator.Emit(OpCodes.Conv_I8);
d1593 1
a1593 1
							EmitLdc_I4(classFile.GetConstantPoolConstantInteger(constant));
d1596 1
a1596 1
							ilGenerator.Emit(OpCodes.Ldc_I8, classFile.GetConstantPoolConstantLong(constant));
d2135 1
a2135 1
					EmitLdc_I4(instr.Arg2);
d2142 1
a2142 1
						EmitLdc_I4(instr.Arg2 - j);
d2519 1
a2519 2
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.PC + instr.Arg1));
d2522 1
a2522 2
					ilGenerator.Emit(OpCodes.Ldc_I4_0);
					ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.PC + instr.Arg1));
d2576 2
d2579 1
a2579 19
				{
					// we need to special case dividing by -1, because the CLR div instruction
					// throws an OverflowException when dividing Int32.MinValue by -1, and
					// Java just silently overflows
					ilGenerator.Emit(OpCodes.Dup);
					ilGenerator.Emit(OpCodes.Ldc_I4_M1);
					if(instr.NormalizedOpCode == NormalizedByteCode.__ldiv)
					{
						ilGenerator.Emit(OpCodes.Conv_I8);
					}
					Label label = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Bne_Un_S, label);
					ilGenerator.Emit(OpCodes.Pop);
					ilGenerator.Emit(OpCodes.Neg);
					Label label2 = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Br_S, label2);
					ilGenerator.MarkLabel(label);
					ilGenerator.Emit(OpCodes.Div);
					ilGenerator.MarkLabel(label2);
a2580 1
				}
d2619 1
a2619 1
					EmitLdc_I4(31);
d2624 1
a2624 1
					EmitLdc_I4(63);
d2629 1
a2629 1
					EmitLdc_I4(31);
d2634 1
a2634 1
					EmitLdc_I4(63);
d2639 1
a2639 1
					EmitLdc_I4(31);
d2644 1
a2644 1
					EmitLdc_I4(63);
d2889 1
a2889 1
						EmitLdc_I4(instr.GetSwitchValue(0));
d2900 1
a2900 1
						EmitLdc_I4(instr.GetSwitchValue(j));
d2912 1
a2912 1
					EmitLdc_I4(instr.Arg2);
d2961 1
a2961 1
							EmitLdc_I4(j);
d2979 1
a2979 1
							EmitLdc_I4(j);
a3090 47
	private void EmitLdc_I4(int v)
	{
		switch(v)
		{
			case -1:
				ilGenerator.Emit(OpCodes.Ldc_I4_M1);
				break;
			case 0:
				ilGenerator.Emit(OpCodes.Ldc_I4_0);
				break;
			case 1:
				ilGenerator.Emit(OpCodes.Ldc_I4_1);
				break;
			case 2:
				ilGenerator.Emit(OpCodes.Ldc_I4_2);
				break;
			case 3:
				ilGenerator.Emit(OpCodes.Ldc_I4_3);
				break;
			case 4:
				ilGenerator.Emit(OpCodes.Ldc_I4_4);
				break;
			case 5:
				ilGenerator.Emit(OpCodes.Ldc_I4_5);
				break;
			case 6:
				ilGenerator.Emit(OpCodes.Ldc_I4_6);
				break;
			case 7:
				ilGenerator.Emit(OpCodes.Ldc_I4_7);
				break;
			case 8:
				ilGenerator.Emit(OpCodes.Ldc_I4_8);
				break;
			default:
				if(v >= -128 && v <= 127)
				{
					ilGenerator.Emit(OpCodes.Ldc_I4_S, (sbyte)v);
				}
				else
				{
					ilGenerator.Emit(OpCodes.Ldc_I4, v);
				}
				break;
		}
	}

@


1.67
log
@*** empty log message ***
@
text
@d135 1
d139 1
d160 1
d162 1
d1707 18
@


1.66
log
@*** empty log message ***
@
text
@d151 1
d228 2
a229 1
		if(m.LineNumberTableAttribute != null && !JVM.NoStackTraceInfo)
d269 1
a269 1
					if(JVM.Debug && v.name != null)
d807 1
a807 1
		if(JVM.Debug)
d812 1
a812 1
				if(JVM.SourcePath != null)
d817 1
a817 1
					sourcefile = new System.IO.FileInfo(JVM.SourcePath + "/" + package + "/" + sourcefile).FullName;
d1205 1
a1205 1
		if(JVM.Debug)
d3510 1
a3510 1
				if(JVM.Debug && v.name != null)
d3549 1
a3549 1
				if(JVM.Debug && v.name != null)
@


1.65
log
@*** empty log message ***
@
text
@d134 1
d185 2
d891 1
a891 1
				ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.GetClassFromTypeHandle);
d1606 1
d1611 1
a1611 1
								ilGenerator.Emit(OpCodes.Call, ByteCodeHelperMethods.GetClassFromTypeHandle);
a1612 1
							java_lang_Class.EmitCheckcast(clazz, ilGenerator);
d1780 1
a1780 1
							method.EmitNewobj(ilGenerator);
d3379 1
a3379 1
		internal override void EmitNewobj(ILGenerator ilgen)
d3422 5
@


1.64
log
@*** empty log message ***
@
text
@d1628 1
a1628 1
						&& cpi.GetClassType().GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader())
@


1.63
log
@*** empty log message ***
@
text
@d866 1
d872 7
@


1.62
log
@*** empty log message ***
@
text
@d157 1
a157 1
		cli_System_Exception = ClassLoaderWrapper.LoadClassCritical("cli.System.Exception");
@


1.61
log
@*** empty log message ***
@
text
@d1617 3
a1619 3
					if((ReferenceEquals(cpi.Class, "java.lang.System") || ReferenceEquals(cpi.Class, "java.lang.VMSystem"))
						&& ReferenceEquals(cpi.Name, "arraycopy")
						&& ReferenceEquals(cpi.Signature, "(Ljava.lang.Object;ILjava.lang.Object;II)V")
d1692 1
a1692 1
					if(isinvokespecial && ReferenceEquals(cpi.Name, "<init>") && VerifierTypeWrapper.IsNew(type))
d1714 1
a1714 1
					if(isinvokespecial && ReferenceEquals(cpi.Name, "<init>"))
@


1.60
log
@*** empty log message ***
@
text
@d908 21
a928 1
					if(ByteCodeMetaData.CanThrowException(m.Instructions[i].NormalizedOpCode))
d1489 12
d1510 13
d1536 1
@


1.59
log
@*** empty log message ***
@
text
@d75 4
d117 4
d814 1
a814 1
				symboldocument = classLoader.ModuleBuilder.DefineDocument(sourcefile, SymLanguageType.Java, Guid.Empty, SymDocumentType.Text);
@


1.58
log
@*** empty log message ***
@
text
@d1894 25
d1924 1
a1924 1
							if(stackHeight != 0)
d1942 5
@


1.57
log
@*** empty log message ***
@
text
@d792 1
a792 1
		DynamicClassLoader classLoader = (DynamicClassLoader)clazz.GetClassLoader();
@


1.56
log
@*** empty log message ***
@
text
@d790 1
a790 7
	internal static void Compile(DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, Hashtable invokespecialstubcache)
	{
		bool nonleaf = false;
		Compile(clazz, mw, classFile, m, ilGenerator, ref nonleaf, invokespecialstubcache);
	}

	internal static void Compile(DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, ref bool nonleaf, Hashtable invokespecialstubcache)
a824 2
						// FXBUG emit an extra nop to workaround Whidbey June CTP dynamic debugging bug
						ilGenerator.Emit(OpCodes.Nop);
d902 1
a902 1
						AttributeHelper.SetLineNumberTable(mw.GetMethod(), c.lineNumbers);
@


1.55
log
@*** empty log message ***
@
text
@d1571 4
a1574 4
					if((cpi.Class == "java.lang.System" || cpi.Class == "java.lang.VMSystem")&&
						cpi.Name == "arraycopy" &&
						cpi.Signature == "(Ljava.lang.Object;ILjava.lang.Object;II)V" &&
						cpi.GetClassType().GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader())
d1646 1
a1646 1
					if(isinvokespecial && cpi.Name == "<init>" && VerifierTypeWrapper.IsNew(type))
d1668 1
a1668 1
					if(isinvokespecial && cpi.Name == "<init>")
@


1.54
log
@*** empty log message ***
@
text
@d1385 1
a1385 1
			if(block.HasLabel(i) || (instr.flags & ClassFile.Method.InstructionFlags.BranchTarget) != 0)
d1717 4
d2773 7
a2780 1
					// TODO we shouldn't call unmap when we know it isn't needed
d2961 1
@


1.53
log
@*** empty log message ***
@
text
@d906 8
a913 1
				AttributeHelper.SetLineNumberTable(mw.GetMethod(), c.lineNumbers);
@


1.52
log
@*** empty log message ***
@
text
@d78 5
a82 1
		Type typeofByteCodeHelper = JVM.LoadType(typeof(ByteCodeHelper));
@


1.51
log
@*** empty log message ***
@
text
@d43 69
a119 2
	private static MethodInfo getClassFromTypeHandleMethod;
	private static MethodInfo multiANewArrayMethod;
a121 10
	private static MethodInfo f2iMethod;
	private static MethodInfo d2iMethod;
	private static MethodInfo f2lMethod;
	private static MethodInfo d2lMethod;
	private static MethodInfo arraycopy_fastMethod;
	private static MethodInfo arraycopy_primitive_8Method;
	private static MethodInfo arraycopy_primitive_4Method;
	private static MethodInfo arraycopy_primitive_2Method;
	private static MethodInfo arraycopy_primitive_1Method;
	private static MethodInfo arraycopyMethod;
a125 1
	private static Type typeofByteCodeHelper;
a140 1
		typeofByteCodeHelper = JVM.LoadType(typeof(ByteCodeHelper));
a141 2
		getClassFromTypeHandleMethod = typeofByteCodeHelper.GetMethod("GetClassFromTypeHandle");
		multiANewArrayMethod = typeofByteCodeHelper.GetMethod("multianewarray");
a143 10
		f2iMethod = typeofByteCodeHelper.GetMethod("f2i");
		d2iMethod = typeofByteCodeHelper.GetMethod("d2i");
		f2lMethod = typeofByteCodeHelper.GetMethod("f2l");
		d2lMethod = typeofByteCodeHelper.GetMethod("d2l");
		arraycopy_fastMethod = typeofByteCodeHelper.GetMethod("arraycopy_fast");
		arraycopy_primitive_8Method = typeofByteCodeHelper.GetMethod("arraycopy_primitive_8");
		arraycopy_primitive_4Method = typeofByteCodeHelper.GetMethod("arraycopy_primitive_4");
		arraycopy_primitive_2Method = typeofByteCodeHelper.GetMethod("arraycopy_primitive_2");
		arraycopy_primitive_1Method = typeofByteCodeHelper.GetMethod("arraycopy_primitive_1");
		arraycopyMethod = typeofByteCodeHelper.GetMethod("arraycopy");
d842 1
a842 1
				ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicCast"));
d876 1
a876 1
				ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandleMethod);
d1331 1
a1331 1
							ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicGetTypeAsExceptionType"));
d1537 1
a1537 1
								ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicClassLiteral"));
d1542 1
a1542 1
								ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandleMethod);
d1573 1
a1573 1
									ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_8Method);
d1577 1
a1577 1
									ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_4Method);
d1581 1
a1581 1
									ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_2Method);
d1585 1
a1585 1
									ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_1Method);
d1597 1
a1597 1
										ilGenerator.Emit(OpCodes.Call, arraycopy_fastMethod);
d1601 1
a1601 1
										ilGenerator.Emit(OpCodes.Call, arraycopyMethod);
d1997 1
a1997 1
						ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicNewCheckOnly"));
d2029 1
a2029 1
						ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicMultianewarray"));
d2036 1
a2036 1
						ilGenerator.Emit(OpCodes.Call, multiANewArrayMethod);
d2049 1
a2049 1
						ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicNewarray"));
d2119 1
a2119 1
						ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicAaload"));
d2189 1
a2189 1
						ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicAastore"));
d2818 1
a2818 1
					ilGenerator.Emit(OpCodes.Call, f2iMethod);
d2821 1
a2821 1
					ilGenerator.Emit(OpCodes.Call, d2iMethod);
d2824 1
a2824 1
					ilGenerator.Emit(OpCodes.Call, f2lMethod);
d2827 1
a2827 1
					ilGenerator.Emit(OpCodes.Call, d2lMethod);
d3201 1
a3201 1
				ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicGetfield"));
d3206 1
a3206 1
				ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicPutfield"));
d3210 1
a3210 1
				ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicGetstatic"));
d3215 1
a3215 1
				ilGenerator.Emit(OpCodes.Call, typeofByteCodeHelper.GetMethod("DynamicPutstatic"));
a3249 3
		private static readonly MethodInfo dynamicInvokestatic = typeofByteCodeHelper.GetMethod("DynamicInvokestatic");
		private static readonly MethodInfo dynamicInvokevirtual = typeofByteCodeHelper.GetMethod("DynamicInvokevirtual");
		private static readonly MethodInfo dynamicInvokeSpecialNew = typeofByteCodeHelper.GetMethod("DynamicInvokeSpecialNew");
d3262 1
a3262 1
			Emit(dynamicInvokestatic, ilgen, cpi.GetRetType());
d3267 1
a3267 1
			Emit(dynamicInvokevirtual, ilgen, cpi.GetRetType());
d3272 1
a3272 1
			Emit(dynamicInvokeSpecialNew, ilgen, cpi.GetClassType());
@


1.50
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
d1794 17
a1810 1
							method.EmitCallvirt(ilGenerator);
@


1.49
log
@*** empty log message ***
@
text
@a64 1
	private static TypeWrapper java_lang_Object;
a102 1
		java_lang_Object = CoreClasses.java.lang.Object.Wrapper;
@


1.48
log
@*** empty log message ***
@
text
@d753 1
a753 1
		ClassLoaderWrapper classLoader = clazz.GetClassLoader();
@


1.47
log
@*** empty log message ***
@
text
@d1578 1
d1583 1
d1594 1
a1594 1
					if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>" && VerifierTypeWrapper.IsNew(type))
d1616 1
a1616 1
					if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>")
d1778 1
a1778 1
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
d3265 1
@


1.46
log
@*** empty log message ***
@
text
@d2283 1
a2283 1
					ilGenerator.Emit(OpCodes.Blt, resm1);
d2287 1
a2287 1
					ilGenerator.Emit(OpCodes.Beq, res0);
d2290 1
a2290 1
					ilGenerator.Emit(OpCodes.Br, end);
d2293 1
a2293 1
					ilGenerator.Emit(OpCodes.Br, end);
@


1.45
log
@*** empty log message ***
@
text
@d37 1
d863 7
a869 4
			// HACK because of the bogus Leave instruction that Reflection.Emit generates, this location
			// sometimes appears reachable (it isn't), so we emit a bogus branch to keep the verifier happy.
			ilGenerator.Emit(OpCodes.Br, - (ilGenerator.GetILOffset() + 5));
			//ilGenerator.Emit(OpCodes.Br_S, (sbyte)-2);
@


1.44
log
@*** empty log message ***
@
text
@d640 1
d685 4
d711 1
d728 1
d1427 1
a1427 2
					TypeWrapper val = ma.GetRawStackTypeWrapper(i, 0);
					tw.EmitConvStackTypeToSignatureType(ilGenerator, val);
d1520 2
a1521 2
						TypeWrapper dst_type = ma.GetRawStackTypeWrapper(i, 2);
						TypeWrapper src_type = ma.GetRawStackTypeWrapper(i, 4);
d1684 1
a1684 1
										TypeWrapper stacktype = ma.GetRawStackTypeWrapper(i, argcount + 1 + j);
d1772 1
a1772 2
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial
							&& !method.IsPrivate) // if the method is private, we can get away with a callvirt (and not generate the stub)
d1774 13
a1786 1
							ilGenerator.Emit(OpCodes.Callvirt, GetInvokeSpecialStub(method));
d1813 1
a1813 5
							retTypeWrapper.EmitConvStackTypeToSignatureType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
							if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
							{
								ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsSignatureType);
							}
d1838 1
a1838 5
							retTypeWrapper.EmitConvStackTypeToSignatureType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
							if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
							{
								ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsSignatureType);
							}
d1864 4
d2998 1
a2998 1
					TypeWrapper tw = ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i);
d3036 2
a3037 1
				if(tw != VerifierTypeWrapper.UninitializedThis)
d3047 1
a3047 1
					TypeWrapper tw = ma.GetRawStackTypeWrapper(instructionIndex, args.Length - 1 - i);
d3268 2
a3269 1
		if(type == VerifierTypeWrapper.UninitializedThis)
@


1.43
log
@*** empty log message ***
@
text
@d3086 1
a3086 1
									ilGenerator.Emit(OpCodes.Unbox, args[i].TypeAsTBD);
@


1.42
log
@*** empty log message ***
@
text
@d1322 4
a1325 3
			// TODO for now, every instruction has an associated label, I'm not sure it's worthwhile,
			// but it could be optimized
			block.MarkLabel(i);
d2967 2
d2980 1
d2989 1
d3002 2
a3004 1
					break;
d3011 1
a3018 1
			// OPTIMIZE if the first n arguments don't need a cast, they can be left on the stack
d3020 1
a3020 1
			for(int i = 0; i < args.Length; i++)
d3029 1
a3029 1
			for(int i = args.Length - 1; i >= 0; i--)
d3040 4
a3043 1
				dh.Store(i);
d3045 1
a3045 1
			for(int i = 0; i < args.Length; i++)
d3047 4
a3056 1
						dh.Load(i);
d3060 2
d3064 1
a3064 1
						dh.Load(i);
a3076 1
					dh.Load(i);
@


1.41
log
@*** empty log message ***
@
text
@d24 2
d69 1
d81 1
d85 1
d87 2
a88 2
		getClassFromTypeHandleMethod = typeof(ByteCodeHelper).GetMethod("GetClassFromTypeHandle");
		multiANewArrayMethod = typeof(ByteCodeHelper).GetMethod("multianewarray");
d91 10
a100 10
		f2iMethod = typeof(ByteCodeHelper).GetMethod("f2i");
		d2iMethod = typeof(ByteCodeHelper).GetMethod("d2i");
		f2lMethod = typeof(ByteCodeHelper).GetMethod("f2l");
		d2lMethod = typeof(ByteCodeHelper).GetMethod("d2l");
		arraycopy_fastMethod = typeof(ByteCodeHelper).GetMethod("arraycopy_fast");
		arraycopy_primitive_8Method = typeof(ByteCodeHelper).GetMethod("arraycopy_primitive_8");
		arraycopy_primitive_4Method = typeof(ByteCodeHelper).GetMethod("arraycopy_primitive_4");
		arraycopy_primitive_2Method = typeof(ByteCodeHelper).GetMethod("arraycopy_primitive_2");
		arraycopy_primitive_1Method = typeof(ByteCodeHelper).GetMethod("arraycopy_primitive_1");
		arraycopyMethod = typeof(ByteCodeHelper).GetMethod("arraycopy");
d161 1
a161 1
	private Compiler(TypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, ClassLoaderWrapper classLoader, ISymbolDocumentWriter symboldocument)
d169 1
d737 1
a737 1
	internal static void Compile(DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator)
d740 1
a740 1
		Compile(clazz, mw, classFile, m, ilGenerator, ref nonleaf);
d743 1
a743 1
	internal static void Compile(DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, ref bool nonleaf)
d793 1
a793 1
				ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicCast"));
d803 1
a803 1
				c = new Compiler(clazz, mw, classFile, m, ilGenerator, classLoader, symboldocument);
d1279 1
a1279 1
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetTypeAsExceptionType"));
d1485 1
a1485 1
								ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicClassLiteral"));
d1559 1
a1559 1
					CastInterfaceArgs(method, cpi.GetArgTypes(), i, false, false);
d1584 1
a1584 1
						CastInterfaceArgs(method, args, i, false, false);
d1600 1
a1600 1
						CastInterfaceArgs(method, args, i, true, instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && type != VerifierTypeWrapper.UninitializedThis);
d1765 2
a1766 1
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
d1768 1
a1768 1
							method.EmitCall(ilGenerator);
d1920 1
a1920 1
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicNewCheckOnly"));
d1952 1
a1952 1
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicMultianewarray"));
d1972 1
a1972 1
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicNewarray"));
d2042 1
a2042 1
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAaload"));
d2112 1
a2112 1
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAastore"));
d2880 22
d2950 1
a2950 1
	private void CastInterfaceArgs(MethodWrapper method, TypeWrapper[] args, int instructionIndex, bool instanceMethod, bool checkThisForNull)
d2952 1
a2952 1
		bool needsCast = checkThisForNull;
a3035 5
			if(checkThisForNull)
			{
				dh.Load(0);
				EmitHelper.NullCheck(ilGenerator);
			}
d3111 1
a3111 1
				ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetfield"));
d3116 1
a3116 1
				ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicPutfield"));
d3120 1
a3120 1
				ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetstatic"));
d3125 1
a3125 1
				ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicPutstatic"));
d3160 3
a3162 3
		private static readonly MethodInfo dynamicInvokestatic = typeof(ByteCodeHelper).GetMethod("DynamicInvokestatic");
		private static readonly MethodInfo dynamicInvokevirtual = typeof(ByteCodeHelper).GetMethod("DynamicInvokevirtual");
		private static readonly MethodInfo dynamicInvokeSpecialNew = typeof(ByteCodeHelper).GetMethod("DynamicInvokeSpecialNew");
d3353 2
@


1.40
log
@*** empty log message ***
@
text
@d1915 6
a1920 1
					// we don't do anything here, the call to <init> will be converted into a newobj instruction
@


1.39
log
@*** empty log message ***
@
text
@d847 1
a847 1
				AttributeHelper.SetLineNumberTable(mw.GetMethod(), c.lineNumbers.ToArray());
@


1.38
log
@*** empty log message ***
@
text
@d1399 8
a1407 1
				case NormalizedByteCode.__getfield:
d1409 14
a1422 1
					GetPutField(instr, i);
d1858 1
a1858 1
						if(!type.IsUnloadable && !v.type.IsUnloadable && !v.type.IsAssignableTo(type))
d2919 12
d3009 1
a3009 1
				if(!args[i].IsUnloadable && args[i].IsGhost)
d3035 1
a3035 1
					if(!args[i].IsUnloadable)
d3063 1
a3063 1
	private void GetPutField(Instruction instr, int i)
d3067 1
a3067 1
		bool write = (bytecode == NormalizedByteCode.__putfield || bytecode == NormalizedByteCode.__putstatic);
d3069 2
a3070 1
		if(wrapper.IsUnloadable)
d3072 1
a3072 31
			TypeWrapper fieldTypeWrapper = cpi.GetFieldType();
			if(write && !fieldTypeWrapper.IsUnloadable && fieldTypeWrapper.IsPrimitive)
			{
				ilGenerator.Emit(OpCodes.Box, fieldTypeWrapper.TypeAsTBD);
			}
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Name);
			ilGenerator.Emit(OpCodes.Ldstr, cpi.Signature);
			ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
			ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
			switch(bytecode)
			{
				case NormalizedByteCode.__getfield:
					Profiler.Count("EmitDynamicGetfield");
					ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetfield"));
					EmitReturnTypeConversion(ilGenerator, fieldTypeWrapper);
					break;
				case NormalizedByteCode.__putfield:
					Profiler.Count("EmitDynamicPutfield");
					ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicPutfield"));
					break;
				case NormalizedByteCode.__getstatic:
					Profiler.Count("EmitDynamicGetstatic");
					ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetstatic"));
					EmitReturnTypeConversion(ilGenerator, fieldTypeWrapper);
					break;
				case NormalizedByteCode.__putstatic:
					Profiler.Count("EmitDynamicPutstatic");
					ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicPutstatic"));
					break;
			}
			return;
d3074 26
a3099 17
		else
		{
			FieldWrapper field = cpi.GetField();
			if(write)
			{
				TypeWrapper tw = field.FieldTypeWrapper;
				TypeWrapper val = ma.GetRawStackTypeWrapper(i, 0);
				tw.EmitConvStackTypeToSignatureType(ilGenerator, val);
				field.EmitSet(ilGenerator);
				return;
			}
			else
			{
				field.EmitGet(ilGenerator);
				field.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilGenerator);
				return;
			}
@


1.37
log
@*** empty log message ***
@
text
@a582 85
	private class EmitException : ApplicationException
	{
		private TypeWrapper type;

		internal EmitException(string message, TypeWrapper type)
			: base(message)
		{
			this.type = type;
		}

		internal void Emit(ILGenerator ilgen, ClassFile classFile, ClassFile.Method m)
		{
			Tracer.Error(Tracer.Compiler, "{0}: {1}\n\tat {2}.{3}{4}", type.Name, Message, classFile.Name, m.Name, m.Signature);
			ilgen.Emit(OpCodes.Ldstr, Message);
			MethodWrapper method = type.GetMethodWrapper("<init>", "(Ljava.lang.String;)V", false);
			method.Link();
			method.EmitNewobj(ilgen);
			ilgen.Emit(OpCodes.Throw);
		}
	}

	private sealed class NoClassDefFoundError : EmitException
	{
		internal NoClassDefFoundError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.NoClassDefFoundError"))
		{
		}
	}

	private sealed class IllegalAccessError : EmitException
	{
		internal IllegalAccessError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.IllegalAccessError"))
		{
		}
	}

	private sealed class InstantiationError : EmitException
	{
		internal InstantiationError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.InstantiationError"))
		{
		}
	}

	private sealed class IncompatibleClassChangeError : EmitException
	{
		internal IncompatibleClassChangeError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.IncompatibleClassChangeError"))
		{
		}
	}

	private sealed class NoSuchFieldError : EmitException
	{
		internal NoSuchFieldError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchFieldError"))
		{
		}
	}

	private sealed class AbstractMethodError : EmitException
	{
		internal AbstractMethodError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.AbstractMethodError"))
		{
		}
	}
	
	private sealed class NoSuchMethodError : EmitException
	{
		internal NoSuchMethodError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchMethodError"))
		{
		}
	}

	private sealed class LinkageError : EmitException
	{
		internal LinkageError(string message)
			: base(message, ClassLoaderWrapper.LoadClassCritical("java.lang.LinkageError"))
		{
		}
	}

a1075 25
	private void CheckLoaderConstraints(ClassFile.ConstantPoolItemFieldref cpi, FieldWrapper fw)
	{
		if(cpi.GetFieldType() != fw.FieldTypeWrapper && !fw.FieldTypeWrapper.IsUnloadable)
		{
			throw new LinkageError("Loader constraints violated: " + fw.DeclaringType.Name + "." + fw.Name);
		}
	}

	private void CheckLoaderConstraints(ClassFile.ConstantPoolItemMI cpi, MethodWrapper mw)
	{
		if(cpi.GetRetType() != mw.ReturnType && !mw.ReturnType.IsUnloadable)
		{
			throw new LinkageError("Loader constraints violated (return type): " + mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
		}
		TypeWrapper[] here = cpi.GetArgTypes();
		TypeWrapper[] there = mw.GetParameters();
		for(int i = 0; i < here.Length; i++)
		{
			if(here[i] != there[i] && !there[i].IsUnloadable)
			{
				throw new LinkageError("Loader constraints violated (arg " + i + "): " + mw.DeclaringType.Name + "." + mw.Name + mw.Signature);
			}
		}
	}

d1222 1
a1222 1
						remap = !exceptionTypeWrapper.IsSubTypeOf(cli_System_Exception);
d1396 1
a1396 1
			try
d1398 34
a1431 1
				switch(instr.NormalizedOpCode)
d1433 2
a1434 34
					case NormalizedByteCode.__getstatic:
					case NormalizedByteCode.__putstatic:
					case NormalizedByteCode.__getfield:
					case NormalizedByteCode.__putfield:
						GetPutField(instr, i);
						break;
					case NormalizedByteCode.__aconst_null:
						ilGenerator.Emit(OpCodes.Ldnull);
						break;
					case NormalizedByteCode.__iconst:
						EmitLdc_I4(instr.NormalizedArg1);
						break;
					case NormalizedByteCode.__lconst_0:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Conv_I8);
						break;
					case NormalizedByteCode.__lconst_1:
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Conv_I8);
						break;
					case NormalizedByteCode.__fconst_0:
					case NormalizedByteCode.__dconst_0:
						// floats are stored as native size on the stack, so both R4 and R8 are the same
						ilGenerator.Emit(OpCodes.Ldc_R4, 0.0f);
						break;
					case NormalizedByteCode.__fconst_1:
					case NormalizedByteCode.__dconst_1:
						// floats are stored as native size on the stack, so both R4 and R8 are the same
						ilGenerator.Emit(OpCodes.Ldc_R4, 1.0f);
						break;
					case NormalizedByteCode.__fconst_2:
						ilGenerator.Emit(OpCodes.Ldc_R4, 2.0f);
						break;
					case NormalizedByteCode.__ldc:
d1436 16
a1451 2
						int constant = instr.Arg1;
						switch(classFile.GetConstantPoolConstantType(constant))
d1453 9
a1461 16
							case ClassFile.ConstantType.Double:
								ilGenerator.Emit(OpCodes.Ldc_R8, classFile.GetConstantPoolConstantDouble(constant));
								break;
							case ClassFile.ConstantType.Float:
								ilGenerator.Emit(OpCodes.Ldc_R4, classFile.GetConstantPoolConstantFloat(constant));
								break;
							case ClassFile.ConstantType.Integer:
								EmitLdc_I4(classFile.GetConstantPoolConstantInteger(constant));
								break;
							case ClassFile.ConstantType.Long:
								ilGenerator.Emit(OpCodes.Ldc_I8, classFile.GetConstantPoolConstantLong(constant));
								break;
							case ClassFile.ConstantType.String:
								ilGenerator.Emit(OpCodes.Ldstr, classFile.GetConstantPoolConstantString(constant));
								break;
							case ClassFile.ConstantType.Class:
d1463 59
a1521 4
								TypeWrapper tw = classFile.GetConstantPoolClassType(constant);
								if(tw.IsUnloadable)
								{
									if(JVM.DisableDynamicBinding)
d1523 1
a1523 1
										throw new NoClassDefFoundError(tw.Name);
d1525 1
a1525 12
									Profiler.Count("EmitDynamicClassLiteral");
									ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
									ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
									ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicClassLiteral"));
								}
								else
								{
									ilGenerator.Emit(OpCodes.Ldtoken, tw.IsRemapped ? tw.TypeAsBaseType : tw.TypeAsTBD);
									ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandleMethod);
								}
								java_lang_Class.EmitCheckcast(clazz, ilGenerator);
								break;
d1527 1
a1527 2
							default:
								throw new InvalidOperationException();
a1528 1
						break;
d1530 26
a1555 1
					case NormalizedByteCode.__invokestatic:
d1557 2
a1558 61
						ClassFile.ConstantPoolItemMI cpi = classFile.GetMethodref(instr.Arg1);
						// HACK special case for calls to System.arraycopy, if the array arguments on the stack
						// are of a known array type, we can redirect to an optimized version of arraycopy.
						// Note that we also have to handle VMSystem.arraycopy, because StringBuffer directly calls
						// this method to avoid prematurely initialising System.
						if((cpi.Class == "java.lang.System" || cpi.Class == "java.lang.VMSystem")&&
							cpi.Name == "arraycopy" &&
							cpi.Signature == "(Ljava.lang.Object;ILjava.lang.Object;II)V" &&
							cpi.GetClassType().GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader())
						{
							TypeWrapper dst_type = ma.GetRawStackTypeWrapper(i, 2);
							TypeWrapper src_type = ma.GetRawStackTypeWrapper(i, 4);
							if(dst_type.IsArray && dst_type == src_type)
							{
								switch(dst_type.Name[1])
								{
									case 'J':
									case 'D':
										ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_8Method);
										break;
									case 'I':
									case 'F':
										ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_4Method);
										break;
									case 'S':
									case 'C':
										ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_2Method);
										break;
									case 'B':
									case 'Z':
										ilGenerator.Emit(OpCodes.Call, arraycopy_primitive_1Method);
										break;
									default:
										// TODO once the verifier tracks actual types (i.e. it knows that
										// a particular reference is the result of a "new" opcode) we can
										// use the fast version if the exact destination type is known
										// (in that case the "dst_type == src_type" above should
										// be changed to "src_type.IsAssignableTo(dst_type)".
										TypeWrapper elemtw = dst_type.ElementTypeWrapper;
										// note that IsFinal returns true for array types, so we have to be careful!
										if(!elemtw.IsArray && elemtw.IsFinal)
										{
											ilGenerator.Emit(OpCodes.Call, arraycopy_fastMethod);
										}
										else
										{
											ilGenerator.Emit(OpCodes.Call, arraycopyMethod);
										}
										break;
								}
								break;
							}
						}
						MethodWrapper method = GetMethodCallEmitter(cpi, null, NormalizedByteCode.__invokestatic);
						// if the stack values don't match the argument types (for interface argument types)
						// we must emit code to cast the stack value to the interface type
						CastInterfaceArgs(method, cpi.GetArgTypes(), i, false, false);
						method.EmitCall(ilGenerator);
						method.ReturnType.EmitConvSignatureTypeToStackType(ilGenerator);
						nonleaf = true;
						break;
d1560 7
a1566 15
					case NormalizedByteCode.__invokevirtual:
					case NormalizedByteCode.__invokeinterface:
					case NormalizedByteCode.__invokespecial:
					{
						nonleaf = true;
						ClassFile.ConstantPoolItemMI cpi = classFile.GetMethodref(instr.Arg1);
						int argcount = cpi.GetArgTypes().Length;
						TypeWrapper type = ma.GetRawStackTypeWrapper(i, argcount);
						TypeWrapper thisType = SigTypeToClassName(type, cpi.GetClassType());

						MethodWrapper method = GetMethodCallEmitter(cpi, thisType, instr.NormalizedOpCode);

						// if the stack values don't match the argument types (for interface argument types)
						// we must emit code to cast the stack value to the interface type
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>" && VerifierTypeWrapper.IsNew(type))
d1568 1
a1568 2
							TypeWrapper[] args = cpi.GetArgTypes();
							CastInterfaceArgs(method, args, i, false, false);
d1572 1
a1572 13
							// the this reference is included in the argument list because it may also need to be cast
							TypeWrapper[] methodArgs = cpi.GetArgTypes();
							TypeWrapper[] args = new TypeWrapper[methodArgs.Length + 1];
							methodArgs.CopyTo(args, 1);
							if(instr.NormalizedOpCode == NormalizedByteCode.__invokeinterface)
							{
								args[0] = cpi.GetClassType();
							}
							else
							{
								args[0] = thisType;
							}
							CastInterfaceArgs(method, args, i, true, instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && type != VerifierTypeWrapper.UninitializedThis);
d1574 2
d1577 3
a1579 1
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && cpi.Name == "<init>")
d1581 7
a1587 1
							if(VerifierTypeWrapper.IsNew(type))
d1589 1
a1589 7
								// we have to construct a list of all the unitialized references to the object
								// we're about to create on the stack, so that we can reconstruct the stack after
								// the "newobj" instruction
								int trivcount = 0;
								bool nontrivial = false;
								bool[] stackfix = new bool[ma.GetStackHeight(i) - (argcount + 1)];
								for(int j = 0; j < stackfix.Length; j++)
d1591 2
a1592 1
									if(ma.GetRawStackTypeWrapper(i, argcount + 1 + j) == type)
d1594 1
a1594 12
										stackfix[j] = true;
										if(trivcount == j)
										{
											trivcount++;
										}
										else
										{
											// if there is other stuff on the stack between the new object
											// references, we need to do more work to construct the proper stack
											// layout after the newobj instruction
											nontrivial = true;
										}
d1596 1
a1596 4
								}
								for(int j = 0; !nontrivial && j < m.MaxLocals; j++)
								{
									if(ma.GetLocalTypeWrapper(i, j) == type)
d1598 3
d1604 4
a1607 1
								if(!thisType.IsUnloadable && thisType.IsSubTypeOf(java_lang_Throwable))
d1609 1
a1609 13
									// if the next instruction is an athrow and the exception type
									// doesn't override fillInStackTrace, we can suppress the call
									// to fillInStackTrace from the constructor (and this is
									// a huge perf win)
									// NOTE we also can't call suppressFillInStackTrace for non-Java
									// exceptions (because then the suppress flag won't be cleared),
									// but this case is handled by the "is fillInStackTrace overridden?"
									// test, because cli.System.Exception overrides fillInStackTrace.
									if(code[i + 1].NormalizedOpCode == NormalizedByteCode.__athrow
										&& thisType.GetMethodWrapper("fillInStackTrace", "()Ljava.lang.Throwable;", true).DeclaringType == java_lang_Throwable)
									{
										ilGenerator.Emit(OpCodes.Call, suppressFillInStackTraceMethod);
									}
d1611 13
a1623 2
								method.EmitNewobj(ilGenerator);
								if(!thisType.IsUnloadable && thisType.IsSubTypeOf(cli_System_Exception))
d1625 1
a1625 7
									// HACK we call Throwable.initCause(null) to force creation of an ExceptionInfoHelper
									// (which disables future remapping of the exception) and to prevent others from
									// setting the cause.
									ilGenerator.Emit(OpCodes.Dup);
									ilGenerator.Emit(OpCodes.Ldnull);
									initCauseMethod.EmitCallvirt(ilGenerator);
									ilGenerator.Emit(OpCodes.Pop);
d1627 21
a1647 1
								if(nontrivial)
d1649 1
a1649 28
									// this could be done a little more efficiently, but since in practice this
									// code never runs (for code compiled from Java source) it doesn't
									// really matter
									LocalBuilder newobj = ilGenerator.DeclareLocal(thisType.TypeAsLocalOrStackType);
									ilGenerator.Emit(OpCodes.Stloc, newobj);
									LocalBuilder[] tempstack = new LocalBuilder[stackfix.Length];
									for(int j = 0; j < stackfix.Length; j++)
									{
										if(!stackfix[j])
										{
											TypeWrapper stacktype = ma.GetRawStackTypeWrapper(i, argcount + 1 + j);
											// it could be another new object reference (not from current invokespecial <init>
											// instruction)
											if(stacktype == VerifierTypeWrapper.Null)
											{
												// NOTE we abuse the newobj local as a cookie to signal null!
												tempstack[j] = newobj;
												ilGenerator.Emit(OpCodes.Pop);
											}
											else if(!VerifierTypeWrapper.IsNew(stacktype))
											{
												LocalBuilder lb = ilGenerator.DeclareLocal(stacktype.TypeAsLocalOrStackType);
												ilGenerator.Emit(OpCodes.Stloc, lb);
												tempstack[j] = lb;
											}
										}
									}
									for(int j = stackfix.Length - 1; j >= 0; j--)
d1651 4
a1654 5
										if(stackfix[j])
										{
											ilGenerator.Emit(OpCodes.Ldloc, newobj);
										}
										else if(tempstack[j] != null)
d1657 2
a1658 8
											if(tempstack[j] == newobj)
											{
												ilGenerator.Emit(OpCodes.Ldnull);
											}
											else
											{
												ilGenerator.Emit(OpCodes.Ldloc, tempstack[j]);
											}
d1660 1
a1660 5
									}
									LocalVar[] locals = ma.GetLocalVarsForInvokeSpecial(i);
									for(int j = 0; j < locals.Length; j++)
									{
										if(locals[j] != null)
d1662 3
a1664 7
											if(locals[j].builder == null)
											{
												// for invokespecial the resulting type can never be null
												locals[j].builder = ilGenerator.DeclareLocal(locals[j].type.TypeAsLocalOrStackType);
											}
											ilGenerator.Emit(OpCodes.Ldloc, newobj);
											ilGenerator.Emit(OpCodes.Stloc, locals[j].builder);
d1668 1
a1668 1
								else
d1670 1
a1670 1
									if(trivcount == 0)
d1672 1
a1672 1
										ilGenerator.Emit(OpCodes.Pop);
d1674 1
a1674 1
									else
d1676 6
a1681 1
										for(int j = 1; j < trivcount; j++)
d1683 1
a1683 1
											ilGenerator.Emit(OpCodes.Dup);
a1686 5
							}
							else
							{
								Debug.Assert(type == VerifierTypeWrapper.UninitializedThis);
								method.EmitCall(ilGenerator);
d1697 1
a1697 1
										ilGenerator.Emit(OpCodes.Ldarg_0);
a1701 7
						}
						else
						{
							if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
							{
								method.EmitCall(ilGenerator);
							}
d1704 5
a1708 22
								method.EmitCallvirt(ilGenerator);
							}
							method.ReturnType.EmitConvSignatureTypeToStackType(ilGenerator);
						}
						break;
					}
					case NormalizedByteCode.__return:
					case NormalizedByteCode.__areturn:
					case NormalizedByteCode.__ireturn:
					case NormalizedByteCode.__lreturn:
					case NormalizedByteCode.__freturn:
					case NormalizedByteCode.__dreturn:
					{
						if(block.IsNested)
						{
							// if we're inside an exception block, copy TOS to local, emit "leave" and push item onto our "todo" list
							LocalBuilder local = null;
							if(instr.NormalizedOpCode != NormalizedByteCode.__return)
							{
								TypeWrapper retTypeWrapper = mw.ReturnType;
								retTypeWrapper.EmitConvStackTypeToSignatureType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
								if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
d1710 4
a1713 1
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsSignatureType);
a1714 2
								local = UnsafeAllocTempLocal(retTypeWrapper.TypeAsSignatureType);
								ilGenerator.Emit(OpCodes.Stloc, local);
a1715 4
							Label label = ilGenerator.DefineLabel();
							// NOTE leave automatically discards any junk that may be on the stack
							ilGenerator.Emit(OpCodes.Leave, label);
							block.AddExitHack(new ReturnCookie(label, local));
d1719 4
a1722 4
							// if there is junk on the stack (other than the return value), we must pop it off
							// because in .NET this is invalid (unlike in Java)
							int stackHeight = ma.GetStackHeight(i);
							if(instr.NormalizedOpCode == NormalizedByteCode.__return)
d1724 1
a1724 1
								if(stackHeight != 0)
d1726 7
a1732 19
									ilGenerator.Emit(OpCodes.Leave_S, (byte)0);
								}
								ilGenerator.Emit(OpCodes.Ret);
							}
							else
							{
								TypeWrapper retTypeWrapper = mw.ReturnType;
								retTypeWrapper.EmitConvStackTypeToSignatureType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
								if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
								{
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsSignatureType);
								}
								if(stackHeight != 1)
								{
									LocalBuilder local = AllocTempLocal(retTypeWrapper.TypeAsSignatureType);
									ilGenerator.Emit(OpCodes.Stloc, local);
									ilGenerator.Emit(OpCodes.Leave_S, (byte)0);
									ilGenerator.Emit(OpCodes.Ldloc, local);
									ReleaseTempLocal(local);
a1733 1
								ilGenerator.Emit(OpCodes.Ret);
a1735 1
						break;
d1737 1
a1737 1
					case NormalizedByteCode.__aload:
d1739 1
a1739 11
						TypeWrapper type = ma.GetLocalTypeWrapper(i, instr.NormalizedArg1);
						if(type == VerifierTypeWrapper.Null)
						{
							// if the local is known to be null, we just emit a null
							ilGenerator.Emit(OpCodes.Ldnull);
						}
						else if(VerifierTypeWrapper.IsNew(type))
						{
							// since new objects aren't represented on the stack, we don't need to do anything here
						}
						else if(type == VerifierTypeWrapper.UninitializedThis)
d1741 1
a1741 5
							// any unitialized this reference has to be loaded from arg 0
							// NOTE if the method overwrites the this references, it will always end up in
							// a different local (due to the way the local variable liveness analysis works),
							// so we don't have to worry about that.
							ilGenerator.Emit(OpCodes.Ldarg_0);
d1745 1
a1745 5
							LocalVar v = LoadLocal(instr);
							if(!type.IsUnloadable && !v.type.IsUnloadable && !v.type.IsAssignableTo(type))
							{
								type.EmitCheckcast(type, ilGenerator);
							}
d1747 1
a1747 1
						break;
d1749 21
a1769 44
					case NormalizedByteCode.__astore:
					{
						TypeWrapper type = ma.GetRawStackTypeWrapper(i, 0);
						// NOTE we use "int" to track the return address of a jsr
						if(VerifierTypeWrapper.IsRet(type))
						{
							StoreLocal(instr);
						}
						else if(VerifierTypeWrapper.IsNew(type))
						{
							// new objects aren't really on the stack, so we can't copy them into the local
							// (and the local doesn't exist anyway)
						}
						else if(type == VerifierTypeWrapper.UninitializedThis)
						{
							// any unitialized reference is always the this reference, we don't store anything
							// here (because CLR won't allow unitialized references in locals) and then when
							// the unitialized ref is loaded we redirect to the this reference
							ilGenerator.Emit(OpCodes.Pop);
						}
						else
						{
							StoreLocal(instr);
						}
						break;
					}
					case NormalizedByteCode.__iload:
					case NormalizedByteCode.__lload:
					case NormalizedByteCode.__fload:
					case NormalizedByteCode.__dload:
						LoadLocal(instr);
						break;
					case NormalizedByteCode.__istore:
					case NormalizedByteCode.__lstore:
					case NormalizedByteCode.__fstore:
					case NormalizedByteCode.__dstore:
						StoreLocal(instr);
						break;
					case NormalizedByteCode.__new:
					{
						TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
						if(wrapper.IsUnloadable)
						{
							if(JVM.DisableDynamicBinding)
d1771 1
a1771 1
								throw new NoClassDefFoundError(wrapper.Name);
d1773 2
a1774 6
							Profiler.Count("EmitDynamicNewCheckOnly");
							// this is here to make sure we throw the exception in the right location (before
							// evaluating the constructor arguments)
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicNewCheckOnly"));
d1776 4
a1779 10
						else if(!wrapper.IsAccessibleFrom(clazz))
						{
							throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
						}
						else if(wrapper.IsAbstract)
						{
							throw new InstantiationError(wrapper.Name);
						}
						// we don't do anything here, the call to <init> will be converted into a newobj instruction
						break;
d1781 1
a1781 1
					case NormalizedByteCode.__multianewarray:
d1783 4
a1786 15
						LocalBuilder localArray = UnsafeAllocTempLocal(typeof(int[]));
						LocalBuilder localInt = UnsafeAllocTempLocal(typeof(int));
						EmitLdc_I4(instr.Arg2);
						ilGenerator.Emit(OpCodes.Newarr, typeof(int));
						ilGenerator.Emit(OpCodes.Stloc, localArray);
						for(int j = 1; j <= instr.Arg2; j++)
						{
							ilGenerator.Emit(OpCodes.Stloc, localInt);
							ilGenerator.Emit(OpCodes.Ldloc, localArray);
							EmitLdc_I4(instr.Arg2 - j);
							ilGenerator.Emit(OpCodes.Ldloc, localInt);
							ilGenerator.Emit(OpCodes.Stelem_I4);
						}
						TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
						if(wrapper.IsUnloadable)
d1788 1
a1788 1
							if(JVM.DisableDynamicBinding)
d1790 1
a1790 1
								throw new NoClassDefFoundError(wrapper.Name);
d1792 1
a1792 5
							Profiler.Count("EmitDynamicMultianewarray");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Ldloc, localArray);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicMultianewarray"));
d1796 3
a1798 1
							if(!wrapper.IsAccessibleFrom(clazz))
d1800 1
a1800 1
								throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
d1802 1
a1802 14
							Type type = wrapper.TypeAsArrayType;
							ilGenerator.Emit(OpCodes.Ldtoken, type);
							ilGenerator.Emit(OpCodes.Ldloc, localArray);
							ilGenerator.Emit(OpCodes.Call, multiANewArrayMethod);
							ilGenerator.Emit(OpCodes.Castclass, type);
						}
						break;
					}
					case NormalizedByteCode.__anewarray:
					{
						TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
						if(wrapper.IsUnloadable)
						{
							if(JVM.DisableDynamicBinding)
d1804 5
a1808 12
								throw new NoClassDefFoundError(wrapper.Name);
							}
							Profiler.Count("EmitDynamicNewarray");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, wrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicNewarray"));
						}
						else
						{
							if(!wrapper.IsAccessibleFrom(clazz))
							{
								throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
d1810 1
a1810 11
							// NOTE for ghost types we create object arrays to make sure that Ghost implementers can be
							// stored in ghost arrays, but this has the unintended consequence that ghost arrays can
							// contain *any* reference type (because they are compiled as Object arrays). We could
							// modify aastore to emit code to check for this, but this would have an huge performance
							// cost for all object arrays.
							// Oddly, while the JVM accepts any reference for any other interface typed references, in the
							// case of aastore it does check that the object actually implements the interface. This
							// is unfortunate, but I think we can live with this minor incompatibility.
							// Note that this does not break type safety, because when the incorrect object is eventually
							// used as the ghost interface type it will generate a ClassCastException.
							ilGenerator.Emit(OpCodes.Newarr, wrapper.TypeAsArrayType);
a1811 1
						break;
d1813 6
a1818 2
					case NormalizedByteCode.__newarray:
					switch(instr.Arg1)
d1820 14
a1833 27
						case 4:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.BOOLEAN.TypeAsArrayType);
							break;
						case 5:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.CHAR.TypeAsArrayType);
							break;
						case 6:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.FLOAT.TypeAsArrayType);
							break;
						case 7:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.DOUBLE.TypeAsArrayType);
							break;
						case 8:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.BYTE.TypeAsArrayType);
							break;
						case 9:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.SHORT.TypeAsArrayType);
							break;
						case 10:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.INT.TypeAsArrayType);
							break;
						case 11:
							ilGenerator.Emit(OpCodes.Newarr, PrimitiveTypeWrapper.LONG.TypeAsArrayType);
							break;
						default:
							// this can't happen, the verifier would have caught it
							throw new InvalidOperationException();
d1835 1
a1835 2
						break;
					case NormalizedByteCode.__checkcast:
d1837 2
a1838 2
						TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
						if(!wrapper.IsUnloadable && !wrapper.IsAccessibleFrom(clazz))
d1840 1
a1840 1
							throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
a1841 2
						wrapper.EmitCheckcast(clazz, ilGenerator);
						break;
d1843 72
a1914 1
					case NormalizedByteCode.__instanceof:
d1916 25
a1940 7
						TypeWrapper wrapper = classFile.GetConstantPoolClassType(instr.Arg1);
						if(!wrapper.IsUnloadable && !wrapper.IsAccessibleFrom(clazz))
						{
							throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
						}
						wrapper.EmitInstanceOf(clazz, ilGenerator);
						break;
d1942 1
a1942 1
					case NormalizedByteCode.__aaload:
d1944 11
a1954 28
						TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 1);
						if(tw.IsUnloadable)
						{
							if(JVM.DisableDynamicBinding)
							{
								throw new NoClassDefFoundError(tw.Name);
							}
							Profiler.Count("EmitDynamicAaload");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAaload"));
						}
						else
						{
							TypeWrapper elem = tw.ElementTypeWrapper;
							if(elem.IsNonPrimitiveValueType)
							{
								Type t = elem.TypeAsTBD;
								ilGenerator.Emit(OpCodes.Ldelema, t);
								ilGenerator.Emit(OpCodes.Ldobj, t);
								elem.EmitBox(ilGenerator);
							}
							else
							{
								ilGenerator.Emit(OpCodes.Ldelem_Ref);
							}
						}
						break;
d1956 7
a1962 3
					case NormalizedByteCode.__baload:
						// NOTE both the JVM and the CLR use signed bytes for boolean arrays (how convenient!)
						ilGenerator.Emit(OpCodes.Ldelem_I1);
d1964 2
a1965 2
					case NormalizedByteCode.__bastore:
						ilGenerator.Emit(OpCodes.Stelem_I1);
d1967 2
a1968 2
					case NormalizedByteCode.__caload:
						ilGenerator.Emit(OpCodes.Ldelem_U2);
d1970 2
a1971 2
					case NormalizedByteCode.__castore:
						ilGenerator.Emit(OpCodes.Stelem_I2);
d1973 2
a1974 2
					case NormalizedByteCode.__saload:
						ilGenerator.Emit(OpCodes.Ldelem_I2);
d1976 2
a1977 2
					case NormalizedByteCode.__sastore:
						ilGenerator.Emit(OpCodes.Stelem_I2);
d1979 2
a1980 2
					case NormalizedByteCode.__iaload:
						ilGenerator.Emit(OpCodes.Ldelem_I4);
d1982 2
a1983 2
					case NormalizedByteCode.__iastore:
						ilGenerator.Emit(OpCodes.Stelem_I4);
d1985 28
a2012 19
					case NormalizedByteCode.__laload:
						ilGenerator.Emit(OpCodes.Ldelem_I8);
						break;
					case NormalizedByteCode.__lastore:
						ilGenerator.Emit(OpCodes.Stelem_I8);
						break;
					case NormalizedByteCode.__faload:
						ilGenerator.Emit(OpCodes.Ldelem_R4);
						break;
					case NormalizedByteCode.__fastore:
						ilGenerator.Emit(OpCodes.Stelem_R4);
						break;
					case NormalizedByteCode.__daload:
						ilGenerator.Emit(OpCodes.Ldelem_R8);
						break;
					case NormalizedByteCode.__dastore:
						ilGenerator.Emit(OpCodes.Stelem_R8);
						break;
					case NormalizedByteCode.__aastore:
d2014 2
a2015 2
						TypeWrapper tw = ma.GetRawStackTypeWrapper(i, 2);
						if(tw.IsUnloadable)
d2017 4
a2020 8
							if(JVM.DisableDynamicBinding)
							{
								throw new NoClassDefFoundError(tw.Name);
							}
							Profiler.Count("EmitDynamicAastore");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, tw.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicAastore"));
d2024 1
a2024 18
							TypeWrapper elem = tw.ElementTypeWrapper;
							if(elem.IsNonPrimitiveValueType)
							{
								Type t = elem.TypeAsTBD;
								LocalBuilder local = UnsafeAllocTempLocal(typeof(object));
								ilGenerator.Emit(OpCodes.Stloc, local);
								ilGenerator.Emit(OpCodes.Ldelema, t);
								ilGenerator.Emit(OpCodes.Ldloc, local);
								elem.EmitUnbox(ilGenerator);
								ilGenerator.Emit(OpCodes.Stobj, t);
							}
							else
							{
								// NOTE for verifiability it is expressly *not* required that the
								// value matches the array type, so we don't need to handle interface
								// references here.
								ilGenerator.Emit(OpCodes.Stelem_Ref);
							}
a2025 1
						break;
d2027 59
a2085 2
					case NormalizedByteCode.__arraylength:
						if(ma.GetRawStackTypeWrapper(i, 0).IsUnloadable)
d2087 7
a2093 2
							ilGenerator.Emit(OpCodes.Castclass, typeof(Array));
							ilGenerator.Emit(OpCodes.Callvirt, typeof(Array).GetMethod("get_Length"));
d2097 4
a2100 1
							ilGenerator.Emit(OpCodes.Ldlen);
d2102 5
a2106 2
						break;
					case NormalizedByteCode.__lcmp:
d2108 2
a2109 24
						LocalBuilder value1 = AllocTempLocal(typeof(long));
						LocalBuilder value2 = AllocTempLocal(typeof(long));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bgt_S, res1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res1);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						ReleaseTempLocal(value1);
						ReleaseTempLocal(value2);
						break;
d2111 1
a2111 1
					case NormalizedByteCode.__fcmpl:
d2113 1
a2113 24
						LocalBuilder value1 = AllocTempLocal(typeof(float));
						LocalBuilder value2 = AllocTempLocal(typeof(float));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bgt_S, res1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res1);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						ReleaseTempLocal(value1);
						ReleaseTempLocal(value2);
						break;
d2115 238
a2352 1
					case NormalizedByteCode.__fcmpg:
d2354 1
a2354 24
						LocalBuilder value1 = AllocTempLocal(typeof(float));
						LocalBuilder value2 = AllocTempLocal(typeof(float));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label resm1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Blt_S, resm1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(resm1);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						ReleaseTempLocal(value1);
						ReleaseTempLocal(value2);
						break;
d2356 25
a2380 1
					case NormalizedByteCode.__dcmpl:
d2382 1
a2382 24
						LocalBuilder value1 = AllocTempLocal(typeof(double));
						LocalBuilder value2 = AllocTempLocal(typeof(double));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bgt_S, res1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq_S, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res1);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						ilGenerator.Emit(OpCodes.Br_S, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						ReleaseTempLocal(value1);
						ReleaseTempLocal(value2);
						break;
d2384 6
a2389 1
					case NormalizedByteCode.__dcmpg:
d2391 1
a2391 24
						LocalBuilder value1 = AllocTempLocal(typeof(double));
						LocalBuilder value2 = AllocTempLocal(typeof(double));
						ilGenerator.Emit(OpCodes.Stloc, value2);
						ilGenerator.Emit(OpCodes.Stloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label resm1 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Blt, resm1);
						ilGenerator.Emit(OpCodes.Ldloc, value1);
						ilGenerator.Emit(OpCodes.Ldloc, value2);
						Label res0 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Beq, res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_1);
						Label end = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br, end);
						ilGenerator.MarkLabel(resm1);
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						ilGenerator.Emit(OpCodes.Br, end);
						ilGenerator.MarkLabel(res0);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.MarkLabel(end);
						ReleaseTempLocal(value1);
						ReleaseTempLocal(value2);
						break;
d2393 56
a2448 95
					case NormalizedByteCode.__if_icmpeq:
						ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmpne:
						ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmple:
						ilGenerator.Emit(OpCodes.Ble, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmplt:
						ilGenerator.Emit(OpCodes.Blt, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmpge:
						ilGenerator.Emit(OpCodes.Bge, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_icmpgt:
						ilGenerator.Emit(OpCodes.Bgt, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifle:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Ble, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__iflt:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Blt, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifge:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Bge, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifgt:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Bgt, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifne:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifeq:
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifnonnull:
						ilGenerator.Emit(OpCodes.Brtrue, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ifnull:
						ilGenerator.Emit(OpCodes.Brfalse, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_acmpeq:
						ilGenerator.Emit(OpCodes.Beq, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__if_acmpne:
						ilGenerator.Emit(OpCodes.Bne_Un, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__goto:
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.Arg1));
						break;
					case NormalizedByteCode.__ineg:
					case NormalizedByteCode.__lneg:
					case NormalizedByteCode.__fneg:
					case NormalizedByteCode.__dneg:
						ilGenerator.Emit(OpCodes.Neg);
						break;
					case NormalizedByteCode.__iadd:
					case NormalizedByteCode.__ladd:
					case NormalizedByteCode.__fadd:
					case NormalizedByteCode.__dadd:
						ilGenerator.Emit(OpCodes.Add);
						break;
					case NormalizedByteCode.__isub:
					case NormalizedByteCode.__lsub:
					case NormalizedByteCode.__fsub:
					case NormalizedByteCode.__dsub:
						ilGenerator.Emit(OpCodes.Sub);
						break;
					case NormalizedByteCode.__ixor:
					case NormalizedByteCode.__lxor:
						ilGenerator.Emit(OpCodes.Xor);
						break;
					case NormalizedByteCode.__ior:
					case NormalizedByteCode.__lor:
						ilGenerator.Emit(OpCodes.Or);
						break;
					case NormalizedByteCode.__iand:
					case NormalizedByteCode.__land:
						ilGenerator.Emit(OpCodes.And);
						break;
					case NormalizedByteCode.__imul:
					case NormalizedByteCode.__lmul:
					case NormalizedByteCode.__fmul:
					case NormalizedByteCode.__dmul:
						ilGenerator.Emit(OpCodes.Mul);
						break;
					case NormalizedByteCode.__idiv:
					case NormalizedByteCode.__ldiv:
a2449 3
						// we need to special case dividing by -1, because the CLR div instruction
						// throws an OverflowException when dividing Int32.MinValue by -1, and
						// Java just silently overflows
a2450 15
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						if(instr.NormalizedOpCode == NormalizedByteCode.__ldiv)
						{
							ilGenerator.Emit(OpCodes.Conv_I8);
						}
						Label label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bne_Un_S, label);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Neg);
						Label label2 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, label2);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Div);
						ilGenerator.MarkLabel(label2);
						break;
d2452 5
a2456 6
					case NormalizedByteCode.__fdiv:
					case NormalizedByteCode.__ddiv:
						ilGenerator.Emit(OpCodes.Div);
						break;
					case NormalizedByteCode.__irem:
					case NormalizedByteCode.__lrem:
a2457 4
						// we need to special case taking the remainder of dividing by -1,
						// because the CLR rem instruction throws an OverflowException when
						// taking the remainder of dividing Int32.MinValue by -1, and
						// Java just silently overflows
a2458 20
						ilGenerator.Emit(OpCodes.Ldc_I4_M1);
						if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
						{
							ilGenerator.Emit(OpCodes.Conv_I8);
						}
						Label label = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Bne_Un_S, label);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Ldc_I4_0);
						if(instr.NormalizedOpCode == NormalizedByteCode.__lrem)
						{
							ilGenerator.Emit(OpCodes.Conv_I8);
						}
						Label label2 = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Br_S, label2);
						ilGenerator.MarkLabel(label);
						ilGenerator.Emit(OpCodes.Rem);
						ilGenerator.MarkLabel(label2);
						break;
d2460 1
a2460 35
					case NormalizedByteCode.__frem:
					case NormalizedByteCode.__drem:
						ilGenerator.Emit(OpCodes.Rem);
						break;
					case NormalizedByteCode.__ishl:
						EmitLdc_I4(31);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shl);
						break;
					case NormalizedByteCode.__lshl:
						EmitLdc_I4(63);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shl);
						break;
					case NormalizedByteCode.__iushr:
						EmitLdc_I4(31);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shr_Un);
						break;
					case NormalizedByteCode.__lushr:
						EmitLdc_I4(63);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shr_Un);
						break;
					case NormalizedByteCode.__ishr:
						EmitLdc_I4(31);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shr);
						break;
					case NormalizedByteCode.__lshr:
						EmitLdc_I4(63);
						ilGenerator.Emit(OpCodes.And);
						ilGenerator.Emit(OpCodes.Shr);
						break;
					case NormalizedByteCode.__swap:
d2463 1
a2463 1
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
d2467 1
d2470 1
a2471 1
						break;
d2473 19
a2491 8
					case NormalizedByteCode.__dup:
						// if the TOS contains a "new" object, it isn't really there, so we don't dup it
						if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
						{
							ilGenerator.Emit(OpCodes.Dup);
						}
						break;
					case NormalizedByteCode.__dup2:
d2493 9
a2501 19
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						if(type1.IsWidePrimitive)
						{
							ilGenerator.Emit(OpCodes.Dup);
						}
						else
						{
							DupHelper dh = new DupHelper(this, 2);
							dh.SetType(0, type1);
							dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
							dh.Store(0);
							dh.Store(1);
							dh.Load(1);
							dh.Load(0);
							dh.Load(1);
							dh.Load(0);
							dh.Release();
						}
						break;
d2503 1
a2503 1
					case NormalizedByteCode.__dup_x1:
d2505 2
a2506 2
						DupHelper dh = new DupHelper(this, 2);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
d2508 1
d2511 2
d2514 1
a2517 1
						break;
d2519 7
a2525 1
					case NormalizedByteCode.__dup2_x1:
d2527 1
a2527 2
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						if(type1.IsWidePrimitive)
d2529 1
d2532 1
a2532 1
							dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
d2542 1
d2545 1
a2545 1
							dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
a2549 1
							dh.Load(1);
a2555 1
						break;
d2557 1
a2557 1
					case NormalizedByteCode.__dup2_x2:
d2559 2
a2560 3
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						TypeWrapper type2 = ma.GetRawStackTypeWrapper(i, 1);
						if(type1.IsWidePrimitive)
d2562 14
a2575 29
							if(type2.IsWidePrimitive)
							{
								// Form 4
								DupHelper dh = new DupHelper(this, 2);
								dh.SetType(0, type1);
								dh.SetType(1, type2);
								dh.Store(0);
								dh.Store(1);
								dh.Load(0);
								dh.Load(1);
								dh.Load(0);
								dh.Release();
							}
							else
							{
								// Form 2
								DupHelper dh = new DupHelper(this, 3);
								dh.SetType(0, type1);
								dh.SetType(1, type2);
								dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
								dh.Store(0);
								dh.Store(1);
								dh.Store(2);
								dh.Load(0);
								dh.Load(2);
								dh.Load(1);
								dh.Load(0);
								dh.Release();
							}
d2579 17
a2595 38
							TypeWrapper type3 = ma.GetRawStackTypeWrapper(i, 2);
							if(type3.IsWidePrimitive)
							{
								// Form 3
								DupHelper dh = new DupHelper(this, 3);
								dh.SetType(0, type1);
								dh.SetType(1, type2);
								dh.SetType(2, type3);
								dh.Store(0);
								dh.Store(1);
								dh.Store(2);
								dh.Load(1);
								dh.Load(0);
								dh.Load(2);
								dh.Load(1);
								dh.Load(0);
								dh.Release();
							}
							else
							{
								// Form 1
								DupHelper dh = new DupHelper(this, 4);
								dh.SetType(0, type1);
								dh.SetType(1, type2);
								dh.SetType(2, type3);
								dh.SetType(3, ma.GetRawStackTypeWrapper(i, 3));
								dh.Store(0);
								dh.Store(1);
								dh.Store(2);
								dh.Store(3);
								dh.Load(1);
								dh.Load(0);
								dh.Load(3);
								dh.Load(2);
								dh.Load(1);
								dh.Load(0);
								dh.Release();
							}
a2596 1
						break;
d2598 22
a2619 1
					case NormalizedByteCode.__dup_x2:
d2621 1
a2621 13
						DupHelper dh = new DupHelper(this, 3);
						dh.SetType(0, ma.GetRawStackTypeWrapper(i, 0));
						dh.SetType(1, ma.GetRawStackTypeWrapper(i, 1));
						dh.SetType(2, ma.GetRawStackTypeWrapper(i, 2));
						dh.Store(0);
						dh.Store(1);
						dh.Store(2);
						dh.Load(0);
						dh.Load(2);
						dh.Load(1);
						dh.Load(0);
						dh.Release();
						break;
d2623 1
a2623 1
					case NormalizedByteCode.__pop2:
d2625 1
a2625 2
						TypeWrapper type1 = ma.GetRawStackTypeWrapper(i, 0);
						if(type1.IsWidePrimitive)
d2629 1
a2629 1
						else
d2631 1
a2631 8
							if(!VerifierTypeWrapper.IsNew(type1))
							{
								ilGenerator.Emit(OpCodes.Pop);
							}
							if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 1)))
							{
								ilGenerator.Emit(OpCodes.Pop);
							}
a2632 1
						break;
d2634 34
a2667 19
					case NormalizedByteCode.__pop:
						// if the TOS is a new object, it isn't really there, so we don't need to pop it
						if(!VerifierTypeWrapper.IsNew(ma.GetRawStackTypeWrapper(i, 0)))
						{
							ilGenerator.Emit(OpCodes.Pop);
						}
						break;
					case NormalizedByteCode.__monitorenter:
						ilGenerator.Emit(OpCodes.Call, monitorEnterMethod);
						break;
					case NormalizedByteCode.__monitorexit:
						ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
						break;
					case NormalizedByteCode.__athrow:
						// TODO we shouldn't call unmap when we know it isn't needed
						ilGenerator.Emit(OpCodes.Call, unmapExceptionMethod);
						ilGenerator.Emit(OpCodes.Throw);
						break;
					case NormalizedByteCode.__tableswitch:
d2669 2
a2670 15
						// note that a tableswitch always has at least one entry
						// (otherwise it would have failed verification)
						Label[] labels = new Label[instr.SwitchEntryCount];
						for(int j = 0; j < labels.Length; j++)
						{
							labels[j] = block.GetLabel(instr.PC + instr.GetSwitchTargetOffset(j));
						}
						if(instr.GetSwitchValue(0) != 0)
						{
							EmitLdc_I4(instr.GetSwitchValue(0));
							ilGenerator.Emit(OpCodes.Sub);
						}
						ilGenerator.Emit(OpCodes.Switch, labels);
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.DefaultOffset));
						break;
d2672 11
a2682 11
					case NormalizedByteCode.__lookupswitch:
						for(int j = 0; j < instr.SwitchEntryCount; j++)
						{
							ilGenerator.Emit(OpCodes.Dup);
							EmitLdc_I4(instr.GetSwitchValue(j));
							Label label = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Bne_Un_S, label);
							ilGenerator.Emit(OpCodes.Pop);
							ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.GetSwitchTargetOffset(j)));
							ilGenerator.MarkLabel(label);
						}
d2684 54
a2737 46
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.DefaultOffset));
						break;
					case NormalizedByteCode.__iinc:
						LoadLocal(instr);
						EmitLdc_I4(instr.Arg2);
						ilGenerator.Emit(OpCodes.Add);
						StoreLocal(instr);
						break;
					case NormalizedByteCode.__i2b:
						ilGenerator.Emit(OpCodes.Conv_I1);
						break;
					case NormalizedByteCode.__i2c:
						ilGenerator.Emit(OpCodes.Conv_U2);
						break;
					case NormalizedByteCode.__i2s:
						ilGenerator.Emit(OpCodes.Conv_I2);
						break;
					case NormalizedByteCode.__l2i:
						ilGenerator.Emit(OpCodes.Conv_I4);
						break;
					case NormalizedByteCode.__f2i:
						ilGenerator.Emit(OpCodes.Call, f2iMethod);
						break;
					case NormalizedByteCode.__d2i:
						ilGenerator.Emit(OpCodes.Call, d2iMethod);
						break;
					case NormalizedByteCode.__f2l:
						ilGenerator.Emit(OpCodes.Call, f2lMethod);
						break;
					case NormalizedByteCode.__d2l:
						ilGenerator.Emit(OpCodes.Call, d2lMethod);
						break;
					case NormalizedByteCode.__i2l:
						ilGenerator.Emit(OpCodes.Conv_I8);
						break;
					case NormalizedByteCode.__i2f:
					case NormalizedByteCode.__l2f:
					case NormalizedByteCode.__d2f:
						ilGenerator.Emit(OpCodes.Conv_R4);
						break;
					case NormalizedByteCode.__i2d:
					case NormalizedByteCode.__l2d:
					case NormalizedByteCode.__f2d:
						ilGenerator.Emit(OpCodes.Conv_R8);
						break;
					case NormalizedByteCode.__jsr:
d2739 1
a2739 3
						int index = FindPcIndex(instr.PC + instr.Arg1);
						int[] callsites = ma.GetCallSites(index);
						for(int j = 0; j < callsites.Length; j++)
d2741 2
a2742 5
							if(callsites[j] == i)
							{
								EmitLdc_I4(j);
								break;
							}
a2743 2
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.Arg1));
						break;
d2745 10
a2754 1
					case NormalizedByteCode.__ret:
d2756 1
a2756 14
						// NOTE using a OpCodes.Switch here is not efficient, because 99 out of a 100 cases
						// there are either one or two call sites.
						int subid = ((VerifierTypeWrapper)ma.GetLocalTypeWrapper(i, instr.Arg1)).Index;
						int[] callsites = ma.GetCallSites(subid);
						for(int j = 0; j < callsites.Length - 1; j++)
						{
							if(m.Instructions[callsites[j]].IsReachable)
							{
								LoadLocal(instr);
								EmitLdc_I4(j);
								ilGenerator.Emit(OpCodes.Beq, block.GetLabel(m.Instructions[callsites[j] + 1].PC));
							}
						}
						if(m.Instructions[callsites[callsites.Length - 1]].IsReachable)
d2758 3
a2760 1
							ilGenerator.Emit(OpCodes.Br, block.GetLabel(m.Instructions[callsites[callsites.Length - 1] + 1].PC));
a2761 1
						break;
d2763 1
a2763 4
					case NormalizedByteCode.__nop:
						ilGenerator.Emit(OpCodes.Nop);
						break;
					case NormalizedByteCode.__static_error:
d2765 1
a2765 38
						TypeWrapper exceptionType;
						switch(instr.HardError)
						{
							case HardError.AbstractMethodError:
								exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.AbstractMethodError");
								break;
							case HardError.IllegalAccessError:
								exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.IllegalAccessError");
								break;
							case HardError.IncompatibleClassChangeError:
								exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.IncompatibleClassChangeError");
								break;
							case HardError.InstantiationError:
								exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.InstantiationError");
								break;
							case HardError.LinkageError:
								exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.LinkageError");
								break;
							case HardError.NoClassDefFoundError:
								exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.NoClassDefFoundError");
								break;
							case HardError.NoSuchFieldError:
								exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchFieldError");
								break;
							case HardError.NoSuchMethodError:
								exceptionType = ClassLoaderWrapper.LoadClassCritical("java.lang.NoSuchMethodError");
								break;
							default:
								throw new InvalidOperationException();
						}
						string message = ma.GetErrorMessage(instr.HardErrorMessageId);
						Tracer.Error(Tracer.Compiler, "{0}: {1}\n\tat {2}.{3}{4}", exceptionType.Name, message, classFile.Name, m.Name, m.Signature);
						ilGenerator.Emit(OpCodes.Ldstr, message);
						MethodWrapper method = exceptionType.GetMethodWrapper("<init>", "(Ljava.lang.String;)V", false);
						method.Link();
						method.EmitNewobj(ilGenerator);
						ilGenerator.Emit(OpCodes.Throw);
						break;
d2767 1
a2767 2
					default:
						throw new NotImplementedException(instr.NormalizedOpCode.ToString());
d2769 4
a2772 2
				// mark next instruction as inuse
				switch(instr.NormalizedOpCode)
d2774 38
a2811 25
					case NormalizedByteCode.__tableswitch:
					case NormalizedByteCode.__lookupswitch:
					case NormalizedByteCode.__goto:
					case NormalizedByteCode.__jsr:
					case NormalizedByteCode.__ret:
					case NormalizedByteCode.__ireturn:
					case NormalizedByteCode.__lreturn:
					case NormalizedByteCode.__freturn:
					case NormalizedByteCode.__dreturn:
					case NormalizedByteCode.__areturn:
					case NormalizedByteCode.__return:
					case NormalizedByteCode.__athrow:
					case NormalizedByteCode.__static_error:
						instructionIsForwardReachable = false;
						break;
					default:
						instructionIsForwardReachable = true;
						Debug.Assert(m.Instructions[i + 1].IsReachable);
						// don't fall through end of try block
						if(m.Instructions[i + 1].PC == block.End)
						{
							// TODO instead of emitting a branch to the leave stub, it would be more efficient to put the leave stub here
							ilGenerator.Emit(OpCodes.Br, block.GetLabel(m.Instructions[i + 1].PC));
						}
						break;
d2813 2
d2816 2
a2817 1
			catch(EmitException x)
d2819 25
a2843 5
				x.Emit(ilGenerator, classFile, m);
				// mark the next instruction as not forward reachable,
				// this will cause the stack to be loaded from locals
				// (which is needed for the code to be verifiable)
				instructionIsForwardReachable = false;
a3038 4
			if(JVM.DisableDynamicBinding)
			{
				throw new NoClassDefFoundError(wrapper.Name);
			}
a3072 10
			TypeWrapper thisType = null;
			if(bytecode == NormalizedByteCode.__getfield)
			{
				thisType = SigTypeToClassName(ma.GetRawStackTypeWrapper(i, 0), cpi.GetClassType());
			}
			else if(bytecode == NormalizedByteCode.__putfield)
			{
				thisType = SigTypeToClassName(ma.GetRawStackTypeWrapper(i, 1), cpi.GetClassType());
			}
			bool isStatic = (bytecode == NormalizedByteCode.__putstatic || bytecode == NormalizedByteCode.__getstatic);
d3074 1
a3074 1
			if(field != null)
d3076 5
a3080 38
				CheckLoaderConstraints(cpi, field);
				if(field.IsStatic == isStatic)
				{
					if(field.IsAccessibleFrom(cpi.GetClassType(), clazz, thisType))
					{
						// are we trying to mutate a final field? (they are read-only from outside of the defining class)
						if(write && field.IsFinal
							&& ((isStatic ? clazz != wrapper : clazz != thisType) || (JVM.StrictFinalFieldSemantics && (isStatic ? m.Name != "<clinit>" : m.Name != "<init>"))))
						{
							throw new IllegalAccessError("Field " + field.DeclaringType.Name + "." + field.Name + " is final");
						}
						else
						{
							if(!write)
							{
								field.EmitGet(ilGenerator);
								field.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilGenerator);
								return;
							}
							else
							{
								TypeWrapper tw = field.FieldTypeWrapper;
								TypeWrapper val = ma.GetRawStackTypeWrapper(i, 0);
								tw.EmitConvStackTypeToSignatureType(ilGenerator, val);
								field.EmitSet(ilGenerator);
								return;
							}
						}
					}
					else
					{
						throw new IllegalAccessError("Try to access field " + field.DeclaringType.Name + "." + field.Name + " from class " + clazz.Name);
					}
				}
				else
				{
					throw new IncompatibleClassChangeError("Static field access to non-static field (or v.v.)");
				}
d3084 3
a3086 1
				throw new NoSuchFieldError(cpi.Class + "." + cpi.Name);
d3178 1
a3178 1
	private MethodWrapper GetMethodCallEmitter(ClassFile.ConstantPoolItemMI cpi, TypeWrapper thisType, NormalizedByteCode invoke)
d3180 1
a3180 2
		TypeWrapper wrapper = cpi.GetClassType();
		if(wrapper.IsUnloadable || (thisType != null && thisType.IsUnloadable))
d3182 12
a3193 55
			if(JVM.DisableDynamicBinding)
			{
				throw new NoClassDefFoundError(wrapper.Name);
			}
			return new DynamicMethodWrapper(clazz, cpi);
		}
		else
		{
			if(wrapper.IsInterface != (invoke == NormalizedByteCode.__invokeinterface))
			{
				throw new IncompatibleClassChangeError("invokeinterface on non-interface");
			}
			else
			{
				MethodWrapper method = invoke == NormalizedByteCode.__invokespecial ? cpi.GetMethodForInvokespecial() : cpi.GetMethod();
				if(method != null)
				{
					CheckLoaderConstraints(cpi, method);
					if(method.IsStatic == (invoke == NormalizedByteCode.__invokestatic))
					{
						if(method.IsAbstract && invoke == NormalizedByteCode.__invokespecial)
						{
							throw new AbstractMethodError(cpi.Class + "." + cpi.Name + cpi.Signature);
						}
						else if(method.IsAccessibleFrom(cpi.GetClassType(), clazz, thisType))
						{
							return method;
						}
						else
						{
							// NOTE special case for incorrect invocation of Object.clone(), because this could mean
							// we're calling clone() on an array
							// (bug in javac, see http://developer.java.sun.com/developer/bugParade/bugs/4329886.html)
							if(wrapper == java_lang_Object && thisType.IsArray && cpi.Name == "clone")
							{
								// NOTE since thisType is an array, we can be sure that the method is already linked
								method = thisType.GetMethodWrapper(cpi.Name, cpi.Signature, false);
								if(method != null && method.IsPublic)
								{
									return method;
								}
							}
							throw new IllegalAccessError("Try to access method " + method.DeclaringType.Name + "." + cpi.Name + cpi.Signature + " from class " + clazz.Name);
						}
					}
					else
					{
						throw new IncompatibleClassChangeError("static call to non-static method (or v.v.)");
					}
				}
				else
				{
					throw new NoSuchMethodError(cpi.Class + "." + cpi.Name + cpi.Signature);
				}
			}
@


1.36
log
@*** empty log message ***
@
text
@d1417 1
a1417 1
			if(!ma.IsReachable(i))
d2906 10
a2915 3
							LoadLocal(instr);
							EmitLdc_I4(j);
							ilGenerator.Emit(OpCodes.Beq, block.GetLabel(m.Instructions[callsites[j] + 1].PC));
a2916 1
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(m.Instructions[callsites[callsites.Length - 1] + 1].PC));
d2922 41
d2981 1
d2986 1
a2986 1
						Debug.Assert(ma.IsReachable(i + 1));
@


1.35
log
@*** empty log message ***
@
text
@d816 1
a816 1
	internal static void Compile(DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, ref string verifyError)
d819 1
a819 1
		Compile(clazz, mw, classFile, m, ilGenerator, ref verifyError, ref nonleaf);
d822 1
a822 1
	internal static void Compile(DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator, ref string verifyError, ref bool nonleaf)
a894 4
			if(verifyError == null)
			{
				verifyError = x.Message;
			}
d1165 1
a1165 1
			throw new LinkageError("Loader constraints violated: " + fw.Name);
d1173 1
a1173 1
			throw new LinkageError("Loader constraints violated: " + mw.Name + mw.Signature);
d1181 1
a1181 1
				throw new LinkageError("Loader constraints violated: " + mw.Name + mw.Signature);
@


1.34
log
@*** empty log message ***
@
text
@d1351 1
a1351 1
					bool unusedException = handlerInstr.NormalizedOpCode == NormalizedByteCode.__pop ||
d1353 1
a1353 1
						ma.GetLocalVar(handlerIndex) == null);
@


1.33
log
@*** empty log message ***
@
text
@d368 1
d469 1
a469 1
							if(ByteCodeMetaData.CanThrowException(m.Instructions[j].OpCode))
d2812 10
a2821 4
					case NormalizedByteCode.__lookupswitch:
						// for tableswitch we can use the CIL switch opcode, which is more
						// compact (and could theoretically be faster)
						if(instr.OpCode == ByteCode.__tableswitch)
d2823 2
a2824 14
							// note that a tableswitch always has at least one entry
							// (otherwise it would have failed verification)
							Label[] labels = new Label[instr.SwitchEntryCount];
							for(int j = 0; j < labels.Length; j++)
							{
								labels[j] = block.GetLabel(instr.PC + instr.GetSwitchTargetOffset(j));
							}
							if(instr.GetSwitchValue(0) != 0)
							{
								EmitLdc_I4(instr.GetSwitchValue(0));
								ilGenerator.Emit(OpCodes.Sub);
							}
							ilGenerator.Emit(OpCodes.Switch, labels);
							ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.DefaultOffset));
d2826 6
a2831 1
						else
d2833 4
a2836 10
							for(int j = 0; j < instr.SwitchEntryCount; j++)
							{
								ilGenerator.Emit(OpCodes.Dup);
								EmitLdc_I4(instr.GetSwitchValue(j));
								Label label = ilGenerator.DefineLabel();
								ilGenerator.Emit(OpCodes.Bne_Un_S, label);
								ilGenerator.Emit(OpCodes.Pop);
								ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.GetSwitchTargetOffset(j)));
								ilGenerator.MarkLabel(label);
							}
d2838 2
a2839 1
							ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.DefaultOffset));
d2841 2
d2926 1
@


1.32
log
@*** empty log message ***
@
text
@d77 1
d221 43
d530 52
d698 1
a698 1
		internal BranchCookie(ILGenerator ilgen, int stackHeight, int targetPC)
d700 1
a700 1
			this.Stub = ilgen.DefineLabel();
d702 1
a702 1
			this.dh = new DupHelper(ilgen, stackHeight);
d721 1
a721 1
		private ILGenerator ilgen;
d725 1
a725 1
		internal DupHelper(ILGenerator ilgen, int count)
d727 1
a727 1
			this.ilgen = ilgen;
d732 11
d770 1
a770 1
				locals[i] = ilgen.DeclareLocal(type.TypeAsLocalOrStackType);
d779 1
a779 1
					ilgen.Emit(OpCodes.Ldnull);
d785 1
a785 1
					ilgen.Emit(OpCodes.Ldarg_0);
d788 1
a788 1
					ilgen.Emit(OpCodes.Ldloc, locals[i]);
d801 1
a801 1
					ilgen.Emit(OpCodes.Pop);
d807 1
a807 1
					ilgen.Emit(OpCodes.Stloc, locals[i]);
d1022 1
a1022 1
					BranchCookie bc = new BranchCookie(ilgen, stackHeight, targetPC);
d1189 23
d1287 35
a1321 17
				TypeWrapper exceptionTypeWrapper;
				bool remap;
				if(exc.catch_type == 0)
				{
					exceptionTypeWrapper = java_lang_Throwable;
					remap = true;
				}
				else
				{
					exceptionTypeWrapper = classFile.GetConstantPoolClassType(exc.catch_type);
					remap = !exceptionTypeWrapper.IsSubTypeOf(cli_System_Exception);
				}
				Type excType = exceptionTypeWrapper.TypeAsExceptionType;
				bool mapSafe = !exceptionTypeWrapper.IsUnloadable && !exceptionTypeWrapper.IsMapUnsafeException && !exceptionTypeWrapper.IsRemapped;
				if(mapSafe)
				{
					ilGenerator.BeginCatchBlock(excType);
d1325 3
a1327 14
					ilGenerator.BeginCatchBlock(typeof(Exception));
				}
				BranchCookie bc = new BranchCookie(ilGenerator, 1, exc.handler_pc);
				prevBlock.AddExitHack(bc);
				int handlerIndex = FindPcIndex(exc.handler_pc);
				Instruction handlerInstr = code[handlerIndex];
				bool unusedException = handlerInstr.NormalizedOpCode == NormalizedByteCode.__pop ||
					(handlerInstr.NormalizedOpCode == NormalizedByteCode.__astore &&
					ma.GetLocalVar(handlerIndex) == null);
				// special case for catch(Throwable) (and finally), that produces less code and
				// should be faster
				if(mapSafe || exceptionTypeWrapper == java_lang_Throwable)
				{
					if(unusedException)
d1329 2
a1330 2
						// we must still have an item on the stack, even though it isn't used!
						bc.dh.SetType(0, VerifierTypeWrapper.Null);
d1334 2
a1335 12
						if(mapSafe)
						{
							ilGenerator.Emit(OpCodes.Dup);
						}
						ilGenerator.Emit(remap ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Call, mapExceptionFastMethod);
						if(mapSafe)
						{
							ilGenerator.Emit(OpCodes.Pop);
						}
						bc.dh.SetType(0, exceptionTypeWrapper);
						bc.dh.Store(0);
d1337 3
a1339 5
					ilGenerator.Emit(OpCodes.Leave, bc.Stub);
				}
				else
				{
					if(exceptionTypeWrapper.IsUnloadable)
d1341 1
a1341 6
						Profiler.Count("EmitDynamicGetTypeAsExceptionType");
						ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
						ilGenerator.Emit(OpCodes.Ldstr, exceptionTypeWrapper.Name);
						ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetTypeAsExceptionType"));
						ilGenerator.Emit(remap ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Call, mapExceptionMethod);
d1345 1
a1345 5
						ilGenerator.Emit(OpCodes.Ldtoken, excType);
						ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
						ilGenerator.Emit(remap ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
						ilGenerator.Emit(OpCodes.Call, mapExceptionMethod);
						ilGenerator.Emit(OpCodes.Castclass, excType);
d1347 9
a1355 1
					if(unusedException)
d1357 21
a1377 2
						// we must still have an item on the stack, even though it isn't used!
						bc.dh.SetType(0, VerifierTypeWrapper.Null);
d1381 33
a1413 3
						bc.dh.SetType(0, exceptionTypeWrapper);
						ilGenerator.Emit(OpCodes.Dup);
						bc.dh.Store(0);
d1415 1
a1415 5
					Label rethrow = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Brfalse, rethrow);
					ilGenerator.Emit(OpCodes.Leave, bc.Stub);
					ilGenerator.MarkLabel(rethrow);
					ilGenerator.Emit(OpCodes.Rethrow);
a1416 1
				ilGenerator.EndExceptionBlock();
d1440 1
a1440 1
					BranchCookie bc = new BranchCookie(ilGenerator, stackHeight, -1);
d1465 1
a1465 1
					DupHelper dh = new DupHelper(ilGenerator, stackHeight);
d1476 1
d1886 1
a1886 1
								local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
d1917 1
a1917 1
									LocalBuilder local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsSignatureType);
d1921 1
d2025 2
a2026 2
						LocalBuilder localArray = ilGenerator.DeclareLocal(typeof(int[]));
						LocalBuilder localInt = ilGenerator.DeclareLocal(typeof(int));
d2245 1
a2245 1
								LocalBuilder local = ilGenerator.DeclareLocal(typeof(object));
d2275 2
a2276 2
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(long));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(long));
d2296 2
d2302 2
a2303 2
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(float));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(float));
d2323 2
d2329 2
a2330 2
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(float));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(float));
d2350 2
d2356 2
a2357 2
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(double));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(double));
d2377 2
d2383 2
a2384 2
						LocalBuilder value1 = ilGenerator.DeclareLocal(typeof(double));
						LocalBuilder value2 = ilGenerator.DeclareLocal(typeof(double));
d2404 2
d2593 1
a2593 1
						DupHelper dh = new DupHelper(ilGenerator, 2);
d2600 1
d2619 1
a2619 1
							DupHelper dh = new DupHelper(ilGenerator, 2);
d2628 1
d2634 1
a2634 1
						DupHelper dh = new DupHelper(ilGenerator, 2);
d2642 1
d2650 1
a2650 1
							DupHelper dh = new DupHelper(ilGenerator, 2);
d2658 1
d2662 1
a2662 1
							DupHelper dh = new DupHelper(ilGenerator, 3);
d2674 1
d2687 1
a2687 1
								DupHelper dh = new DupHelper(ilGenerator, 2);
d2695 1
d2700 1
a2700 1
								DupHelper dh = new DupHelper(ilGenerator, 3);
d2711 1
d2720 1
a2720 1
								DupHelper dh = new DupHelper(ilGenerator, 3);
d2732 1
d2737 1
a2737 1
								DupHelper dh = new DupHelper(ilGenerator, 4);
d2752 1
d2759 1
a2759 1
						DupHelper dh = new DupHelper(ilGenerator, 3);
d2770 1
d3064 1
a3064 1
			DupHelper dh = new DupHelper(ilGenerator, args.Length);
d3104 1
a3104 1
						LocalBuilder local = ilGenerator.DeclareLocal(args[i].TypeAsSignatureType);
d3109 1
d3144 1
@


1.31
log
@*** empty log message ***
@
text
@d3021 2
a3022 1
						if(write && field.IsFinal && (isStatic ? clazz != wrapper : clazz != thisType))
@


1.30
log
@*** empty log message ***
@
text
@d749 2
@


1.29
log
@*** empty log message ***
@
text
@d75 1
a75 1
	private System.IO.MemoryStream lineNumbers;
d165 1
a165 1
			this.lineNumbers = new System.IO.MemoryStream(m.LineNumberTableAttribute.Length * 2);
d1331 1
a1331 2
							LineNumberTableAttribute.WritePackedInteger(lineNumbers, (uint)ilGenerator.GetILOffset());
							LineNumberTableAttribute.WritePackedInteger(lineNumbers, table[j].line_number);
@


1.28
log
@*** empty log message ***
@
text
@d34 1
a34 1
using ILGenerator = CountingILGenerator;
d36 3
a38 3
using ExceptionTableEntry = ClassFile.Method.ExceptionTableEntry;
using LocalVariableTableEntry = ClassFile.Method.LocalVariableTableEntry;
using Instruction = ClassFile.Method.Instruction;
@


1.27
log
@*** empty log message ***
@
text
@a51 2
	private static MethodInfo objectToStringMethod;
	private static MethodInfo keepAliveMethod;
a71 1
	private ClassLoaderWrapper classLoader;
a84 2
		objectToStringMethod = typeof(object).GetMethod("ToString");
		keepAliveMethod = typeof(GC).GetMethod("KeepAlive", BindingFlags.Static | BindingFlags.Public, null, new Type[] { typeof(object) }, null);
a161 1
		this.classLoader = classLoader;
a3089 1
		private ClassLoaderWrapper classLoader;
d3093 1
a3093 1
		internal DynamicMethodWrapper(ClassLoaderWrapper classLoader, TypeWrapper wrapper, ClassFile.ConstantPoolItemMI cpi)
a3095 1
			this.classLoader = classLoader;
d3155 1
a3155 1
			return new DynamicMethodWrapper(classLoader, clazz, cpi);
a3322 17

	private bool IsUnloadable(ClassFile.ConstantPoolItemMI cpi)
	{
		if(cpi.GetClassType().IsUnloadable || cpi.GetRetType().IsUnloadable)
		{
			return true;
		}
		TypeWrapper[] args = cpi.GetArgTypes();
		for(int i = 0; i < args.Length; i++)
		{
			if(args[i].IsUnloadable)
			{
				return true;
			}
		}
		return false;
	}
@


1.26
log
@*** empty log message ***
@
text
@d3023 1
a3023 1
					if(field.IsAccessibleFrom(clazz, thisType))
d3183 1
a3183 1
						else if(method.IsAccessibleFrom(clazz, thisType))
@


1.25
log
@*** empty log message ***
@
text
@d44 3
a46 1
	private static MethodWrapper fillInStackTraceMethod;
d108 1
a108 1
			MethodWrapper mw = java_lang_Throwable.GetMethodWrapper("__<map>", "(Ljava.lang.Throwable;Lcli.System.Type;)Ljava.lang.Throwable;", false);
d111 1
a111 1
			mw = java_lang_Throwable.GetMethodWrapper("__<map>", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false);
d114 6
d123 4
a126 2
			mapExceptionMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<map>", new Type[] { typeof(Exception), typeof(Type) });
			mapExceptionFastMethod = java_lang_Throwable.TypeAsBaseType.GetMethod("__<map>", new Type[] { typeof(Exception) });
d128 1
a128 2
		fillInStackTraceMethod = java_lang_Throwable.GetMethodWrapper("fillInStackTrace", "()Ljava.lang.Throwable;", false);
		fillInStackTraceMethod.Link();
d1162 1
d1166 1
d1171 1
d1174 1
a1174 1
				bool mapSafe = !exceptionTypeWrapper.IsUnloadable && !exceptionTypeWrapper.IsMapUnsafeException;
d1192 1
a1192 1
				if(mapSafe || excType == typeof(Exception))
d1205 1
d1224 1
d1231 1
a1563 1
								method.EmitNewobj(ilGenerator);
d1566 10
a1575 4
									// if the next instruction isn't an athrow, we need to
									// call fillInStackTrace, because the object might be used
									// to print out a stack trace without ever being thrown
									if(code[i + 1].NormalizedOpCode != NormalizedByteCode.__athrow)
d1577 1
a1577 10
										ilGenerator.Emit(OpCodes.Dup);
										if(thisType.IsSubTypeOf(cli_System_Exception))
										{
											fillInStackTraceMethod.EmitCallvirt(ilGenerator);
										}
										else
										{
											fillInStackTraceMethod.EmitCall(ilGenerator);
										}
										ilGenerator.Emit(OpCodes.Pop);
d1580 11
d2622 2
@


1.24
log
@*** empty log message ***
@
text
@a2982 4
			if(!wrapper.IsAccessibleFrom(clazz))
			{
				throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
			}
d3143 1
a3143 5
			if(!wrapper.IsAccessibleFrom(clazz))
			{
				throw new IllegalAccessError("Try to access class " + wrapper.Name + " from class " + clazz.Name);
			}
			else if(wrapper.IsInterface != (invoke == NormalizedByteCode.__invokeinterface))
@


1.23
log
@*** empty log message ***
@
text
@d56 1
d92 1
d1426 3
a1428 3
							TypeWrapper t1 = ma.GetRawStackTypeWrapper(i, 2);
							TypeWrapper t2 = ma.GetRawStackTypeWrapper(i, 4);
							if(t1.IsArray && t1 == t2)
d1430 1
a1430 1
								switch(t1.Name[1])
d1449 15
a1463 1
										ilGenerator.Emit(OpCodes.Call, arraycopyMethod);
@


1.22
log
@*** empty log message ***
@
text
@d76 1
d705 6
d828 1
d1459 1
d1466 1
@


1.21
log
@*** empty log message ***
@
text
@d42 2
a43 2
	private static MethodWrapper mapExceptionMethod;
	private static MethodWrapper mapExceptionFastMethod;
d65 1
a94 7
		TypeWrapper exceptionHelper = ClassLoaderWrapper.LoadClassCritical("java.lang.ExceptionHelper");
		mapExceptionMethod = exceptionHelper.GetMethodWrapper("MapException", "(Ljava.lang.Throwable;Lcli.System.Type;)Ljava.lang.Throwable;", false);
		mapExceptionMethod.Link();
		mapExceptionFastMethod = exceptionHelper.GetMethodWrapper("MapExceptionFast", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false);
		mapExceptionFastMethod.Link();
		fillInStackTraceMethod = exceptionHelper.GetMethodWrapper("fillInStackTrace", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;", false);
		fillInStackTraceMethod.Link();
d96 1
d100 17
d501 8
d1183 1
a1183 1
						mapExceptionFastMethod.EmitCall(ilGenerator);
d1201 1
a1201 1
						mapExceptionMethod.EmitCall(ilGenerator);
d1207 1
a1207 1
						mapExceptionMethod.EmitCall(ilGenerator);
d1382 4
d1532 8
a1539 1
										fillInStackTraceMethod.EmitCall(ilGenerator);
d1788 4
d1828 4
d1857 4
d1943 4
d2017 4
d2919 4
d3113 4
@


1.20
log
@*** empty log message ***
@
text
@d1990 3
d2795 1
a2795 2
						// TODO ideally, instead of an InvalidCastException, the castclass should throw a IncompatibleClassChangeError
						ilGenerator.Emit(OpCodes.Castclass, args[i].TypeAsTBD);
@


1.19
log
@*** empty log message ***
@
text
@d51 1
d84 1
a763 1
				ArrayList exits = new ArrayList();
d777 1
a777 1
				Block b = new Block(c, 0, int.MaxValue, -1, exits, true);
@


1.18
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d178 3
a180 2
				if(v.type != VerifierTypeWrapper.UninitializedThis &&
					(v.type != tw || tw.TypeAsLocalOrStackType != tw.TypeAsParameterType))
d189 1
a189 1
					v.type.EmitConvParameterToStackType(ilGenerator);
d1425 1
d1619 1
d1637 1
a1637 1
								retTypeWrapper.EmitConvStackToParameterType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
d1640 1
a1640 1
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsParameterType);
d1642 1
a1642 1
								local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
d1666 1
a1666 1
								retTypeWrapper.EmitConvStackToParameterType(ilGenerator, ma.GetRawStackTypeWrapper(i, 0));
d1669 1
a1669 1
									ilGenerator.Emit(OpCodes.Castclass, retTypeWrapper.TypeAsParameterType);
d1673 1
a1673 1
									LocalBuilder local = ilGenerator.DeclareLocal(retTypeWrapper.TypeAsParameterType);
d2815 1
a2815 1
						LocalBuilder local = ilGenerator.DeclareLocal(args[i].TypeAsParameterType);
d2823 1
a2823 1
							ilGenerator.Emit(OpCodes.Ldobj, args[i].TypeAsParameterType);
d2849 1
a2849 1
							ilGenerator.Emit(OpCodes.Castclass, args[i].TypeAsParameterType);
d2931 1
d2938 1
a2938 4
								if(!tw.IsUnloadable && (val.IsUnloadable || (tw.IsInterfaceOrInterfaceArray && !tw.IsGhost && !val.IsAssignableTo(tw))))
								{
									ilGenerator.Emit(OpCodes.Castclass, tw.TypeAsTBD);
								}
d2976 4
d2997 1
a2997 1
			: base(wrapper, null, null, null, null, null, Modifiers.Public, MemberFlags.None)
@


1.17
log
@*** empty log message ***
@
text
@d77 1
a77 1
		getTypeFromHandleMethod = typeof(Type).GetMethod("GetTypeFromHandle");
d80 2
a81 2
		monitorEnterMethod = typeof(ByteCodeHelper).GetMethod("monitorenter");
		monitorExitMethod = typeof(System.Threading.Monitor).GetMethod("Exit");
d93 1
a93 1
		mapExceptionMethod = exceptionHelper.GetMethodWrapper(new MethodDescriptor("MapException", "(Ljava.lang.Throwable;Lcli.System.Type;)Ljava.lang.Throwable;"), false);
d95 1
a95 1
		mapExceptionFastMethod = exceptionHelper.GetMethodWrapper(new MethodDescriptor("MapExceptionFast", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"), false);
d97 1
a97 1
		fillInStackTraceMethod = exceptionHelper.GetMethodWrapper(new MethodDescriptor("fillInStackTrace", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"), false);
d479 1
a479 1
			MethodWrapper method = type.GetMethodWrapper(new MethodDescriptor("<init>", "(Ljava.lang.String;)V"), false);
d759 1
a759 1
			if(m.IsSynchronized)
d762 8
a769 15
				if(m.IsStatic)
				{
					ilGenerator.Emit(OpCodes.Ldsfld, clazz.ClassObjectField);
					Label label = ilGenerator.DefineLabel();
					ilGenerator.Emit(OpCodes.Brtrue_S, label);
					ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
					ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandleMethod);
					ilGenerator.Emit(OpCodes.Stsfld, clazz.ClassObjectField);
					ilGenerator.MarkLabel(label);
					ilGenerator.Emit(OpCodes.Ldsfld, clazz.ClassObjectField);
				}
				else
				{
					ilGenerator.Emit(OpCodes.Ldarg_0);
				}
d1499 1
a1499 1
									// HACK if the next instruction isn't an athrow, we need to
d1526 3
a1528 2
												// TODO handle null stack entries
												throw new NotImplementedException();
d1546 9
a1554 1
											ilGenerator.Emit(OpCodes.Ldloc, tempstack[j]);
d2519 3
a2521 2
						// TODO use OpCodes.Switch
						for(int j = 0; j < instr.SwitchEntryCount; j++)
d2523 27
a2549 4
							ilGenerator.Emit(OpCodes.Dup);
							EmitLdc_I4(instr.GetSwitchValue(j));
							Label label = ilGenerator.DefineLabel();
							ilGenerator.Emit(OpCodes.Bne_Un_S, label);
d2551 1
a2551 2
							ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.GetSwitchTargetOffset(j)));
							ilGenerator.MarkLabel(label);
a2552 2
						ilGenerator.Emit(OpCodes.Pop);
						ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.DefaultOffset));
d2992 1
a2992 1
			: base(wrapper, null, null, null, null, Modifiers.Public, MemberFlags.None)
d3080 1
a3080 1
							// HACK special case for incorrect invocation of Object.clone(), because this could mean
d3086 1
a3086 1
								method = thisType.GetMethodWrapper(new MethodDescriptor(cpi.Name, cpi.Signature), false);
@


1.16
log
@*** empty log message ***
@
text
@d679 1
a679 1
	internal static void Compile(DynamicTypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator)
d750 4
d1711 1
a1711 1
						// HACK we use "int" to track the return address of a jsr
d1718 2
a1719 5
							// NOTE new objects aren't really on the stack, so we can't copy them into the local.
							// We do store a null in the local, to prevent it from retaining an unintentional reference
							// to whatever object reference happens to be there
							ilGenerator.Emit(OpCodes.Ldnull);
							StoreLocal(instr);
@


1.15
log
@*** empty log message ***
@
text
@d971 1
a971 1
						if(newBlock.exits == null)
d973 1
a973 1
							rc.EmitRet(ilgen);
d977 1
a977 1
							newBlock.exits.Add(rc);
@


1.14
log
@*** empty log message ***
@
text
@d477 1
a477 1
			Tracer.Warning(Tracer.Compiler, "{0}: {1}\n\tat {2}.{3}{4}", type.Name, Message, classFile.Name, m.Name, m.Signature);
d746 1
d1386 3
a1388 1
						if(cpi.Class == "java.lang.System" &&
@


1.13
log
@*** empty log message ***
@
text
@d73 1
a73 2
	private ushort[] lineNumbers;
	private byte[] wideLineNumbers;
d145 1
a145 5
			this.lineNumbers = new ushort[m.LineNumberTableAttribute.Length * 2];
			for(int i = 0; i < m.LineNumberTableAttribute.Length; i++)
			{
				this.lineNumbers[i * 2 + 1] = m.LineNumberTableAttribute[i].line_number;
			}
d794 1
a794 5
				AttributeHelper.SetLineNumberTable(mw.GetMethod(), c.lineNumbers);
			}
			if(c.wideLineNumbers != null)
			{
				AttributeHelper.SetLineNumberTable(mw.GetMethod(), c.wideLineNumbers);
d1278 1
a1278 1
			if(table != null && (symboldocument != null || lineNumbers != null || wideLineNumbers != null))
d1292 2
a1293 25
							int iloffset = ilGenerator.GetILOffset();
							if(iloffset > 65535)
							{
								wideLineNumbers = new byte[lineNumbers.Length * 3];
								for(int k = 0; k < lineNumbers.Length / 2; k++)
								{
									wideLineNumbers[k * 6 + 0] = (byte)(lineNumbers[k * 2 + 0] >> 0);
									wideLineNumbers[k * 6 + 1] = (byte)(lineNumbers[k * 2 + 0] >> 8);
									wideLineNumbers[k * 6 + 4] = (byte)(lineNumbers[k * 2 + 1] >> 0);
									wideLineNumbers[k * 6 + 5] = (byte)(lineNumbers[k * 2 + 1] >> 8);
								}
								lineNumbers = null;
							}
							else
							{
								lineNumbers[j * 2 + 0] = (ushort)iloffset;
							}
						}
						if(wideLineNumbers != null)
						{
							int iloffset = ilGenerator.GetILOffset();
							wideLineNumbers[j * 6 + 0] = (byte)(iloffset >>  0);
							wideLineNumbers[j * 6 + 1] = (byte)(iloffset >>  8);
							wideLineNumbers[j * 6 + 2] = (byte)(iloffset >> 16);
							wideLineNumbers[j * 6 + 3] = (byte)(iloffset >> 24);
@


1.12
log
@*** empty log message ***
@
text
@d809 1
@


1.11
log
@*** empty log message ***
@
text
@d34 2
d73 2
d144 8
d695 4
a698 1
					sourcefile = new System.IO.FileInfo(JVM.SourcePath + "/" + clazz.PackageName.Replace('.', '/') + "/" + sourcefile).FullName;
d797 8
d807 2
a808 1
			ilGenerator.Emit(OpCodes.Br_S, (sbyte)-2);
d1285 2
a1286 1
			if(symboldocument != null)
d1288 1
a1288 2
				ClassFile.Method.LineNumberTableEntry[] table = m.LineNumberTableAttribute;
				if(table != null)
d1290 1
a1290 1
					for(int j = 0; j < table.Length; j++)
d1292 1
a1292 1
						if(table[j].start_pc == instr.PC && table[j].line_number != 0)
a1296 1
							break;
d1298 29
d1789 1
a1789 1
						else if(wrapper.IsAbstract || wrapper.IsInterface)
@


1.10
log
@*** empty log message ***
@
text
@d2862 1
a2862 1
			FieldWrapper field = cpi.GetField(); //wrapper.GetFieldWrapper(cpi.Name, cpi.GetFieldType(classLoader));
@


1.9
log
@*** empty log message ***
@
text
@d803 1
a803 1
		internal Block(Compiler compiler, int begin, int end, int exceptionIndex, ArrayList exits, bool nested)
d807 2
a808 2
			this.begin = begin;
			this.end = end;
d1117 1
a1117 1
				if(true)
d1119 18
a1136 1
					if(mapSafe)
d1138 2
a1139 1
						ilGenerator.BeginCatchBlock(excType);
d1143 1
a1143 14
						ilGenerator.BeginCatchBlock(typeof(Exception));
					}
					BranchCookie bc = new BranchCookie(ilGenerator, 1, exc.handler_pc);
					prevBlock.AddExitHack(bc);
					int handlerIndex = FindPcIndex(exc.handler_pc);
					Instruction handlerInstr = code[handlerIndex];
					bool unusedException = handlerInstr.NormalizedOpCode == NormalizedByteCode.__pop ||
						(handlerInstr.NormalizedOpCode == NormalizedByteCode.__astore &&
						ma.GetLocalVar(handlerIndex) == null);
					// special case for catch(Throwable) (and finally), that produces less code and
					// should be faster
					if(mapSafe || excType == typeof(Exception))
					{
						if(unusedException)
d1145 1
a1145 2
							// we must still have an item on the stack, even though it isn't used!
							bc.dh.SetType(0, VerifierTypeWrapper.Null);
d1147 2
a1148 1
						else
d1150 1
a1150 11
							if(mapSafe)
							{
								ilGenerator.Emit(OpCodes.Dup);
							}
							mapExceptionFastMethod.EmitCall(ilGenerator);
							if(mapSafe)
							{
								ilGenerator.Emit(OpCodes.Pop);
							}
							bc.dh.SetType(0, exceptionTypeWrapper);
							bc.dh.Store(0);
d1152 26
a1177 1
						ilGenerator.Emit(OpCodes.Leave, bc.Stub);
d1181 3
a1183 31
						if(exceptionTypeWrapper.IsUnloadable)
						{
							Profiler.Count("EmitDynamicGetTypeAsExceptionType");
							ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
							ilGenerator.Emit(OpCodes.Ldstr, exceptionTypeWrapper.Name);
							ilGenerator.Emit(OpCodes.Call, typeof(ByteCodeHelper).GetMethod("DynamicGetTypeAsExceptionType"));
							mapExceptionMethod.EmitCall(ilGenerator);
						}
						else
						{
							ilGenerator.Emit(OpCodes.Ldtoken, excType);
							ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
							mapExceptionMethod.EmitCall(ilGenerator);
							ilGenerator.Emit(OpCodes.Castclass, excType);
						}
						if(unusedException)
						{
							// we must still have an item on the stack, even though it isn't used!
							bc.dh.SetType(0, VerifierTypeWrapper.Null);
						}
						else
						{
							bc.dh.SetType(0, exceptionTypeWrapper);
							ilGenerator.Emit(OpCodes.Dup);
							bc.dh.Store(0);
						}
						Label rethrow = ilGenerator.DefineLabel();
						ilGenerator.Emit(OpCodes.Brfalse, rethrow);
						ilGenerator.Emit(OpCodes.Leave, bc.Stub);
						ilGenerator.MarkLabel(rethrow);
						ilGenerator.Emit(OpCodes.Rethrow);
d1185 5
a1189 1
					ilGenerator.EndExceptionBlock();
d1191 1
d2735 1
a2735 1
				if(!args[i].IsUnloadable)
@


1.8
log
@*** empty log message ***
@
text
@d77 1
a77 1
		monitorEnterMethod = typeof(System.Threading.Monitor).GetMethod("Enter");
d672 1
a672 1
	internal static void Compile(TypeWrapper clazz, MethodWrapper mw, ClassFile classFile, ClassFile.Method m, ILGenerator ilGenerator)
d744 1
a744 1
			if(m.IsStatic && m.IsSynchronized)
d747 15
a761 3
				// TODO consider caching the Class object in a static field
				ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
				ilGenerator.Emit(OpCodes.Call, getClassFromTypeHandleMethod);
@


1.7
log
@*** empty log message ***
@
text
@d30 4
d44 1
a44 1
	private static MethodInfo getClassFromTypeMethod;
d75 1
a75 1
		getClassFromTypeMethod = typeof(NativeCode.java.lang.VMClass).GetMethod("getClassFromType");
d84 5
a88 5
		arraycopy_primitive_8Method = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_8");
		arraycopy_primitive_4Method = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_4");
		arraycopy_primitive_2Method = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_2");
		arraycopy_primitive_1Method = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy_primitive_1");
		arraycopyMethod = typeof(NativeCode.java.lang.VMSystem).GetMethod("arraycopy");
d749 1
a749 2
				ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
				ilGenerator.Emit(OpCodes.Call, getClassFromTypeMethod);
d1340 1
a1340 2
									ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
									ilGenerator.Emit(OpCodes.Call, getClassFromTypeMethod);
d2691 8
a2698 1
					needsCast = true;
d2774 1
a2774 1
							if(i != 0 || !instanceMethod)
d2776 5
a2780 1
								args[i].EmitUnbox(ilGenerator);
d2784 1
a2784 1
								ilGenerator.Emit(OpCodes.Unbox, args[i].TypeAsTBD);
@


1.6
log
@*** empty log message ***
@
text
@d59 3
a61 1
	private ClassFile.Method.Code m;
d127 1
a127 1
	private Compiler(TypeWrapper clazz, ClassFile.Method.Code m, ILGenerator ilGenerator, ClassLoaderWrapper classLoader, ISymbolDocumentWriter symboldocument)
d130 2
d140 1
a140 1
			ma = new MethodAnalyzer(clazz, m, classLoader);
d147 1
a147 1
		TypeWrapper[] args = m.Method.GetArgTypes(classLoader);
d155 1
a155 1
				if(m.Method.IsStatic)
d294 1
a294 1
							for(int k = -1; k < m.Instructions[j].Values.Length; k++)
d296 1
a296 1
								int targetPC = m.Instructions[j].PC + (k == -1 ? m.Instructions[j].DefaultOffset : m.Instructions[j].TargetOffsets[k]);
d385 1
a385 1
					TypeWrapper exceptionType = m.Method.ClassFile.GetConstantPoolClassType(ei.catch_type, classLoader);
d464 1
a464 1
		internal void Emit(ILGenerator ilgen, ClassFile.Method m)
d466 1
a466 1
			Tracer.Warning(Tracer.Compiler, "{0}: {1}\n\tat {2}.{3}{4}", type.Name, Message, m.ClassFile.Name, m.Name, m.Signature);
d668 1
a668 1
	internal static void Compile(TypeWrapper clazz, ClassFile.Method m, ILGenerator ilGenerator)
d674 1
a674 1
			string sourcefile = m.ClassFile.SourceFileAttribute;
d684 1
a684 1
				ClassFile.Method.LineNumberTableEntry[] table = m.CodeAttribute.LineNumberTableAttribute;
d704 1
a704 1
		TypeWrapper[] args= m.GetArgTypes(classLoader);
d723 1
a723 1
				c = new Compiler(clazz, m.CodeAttribute, ilGenerator, classLoader, symboldocument);
d993 1
a993 1
		if(cpi.GetFieldType(classLoader) != fw.FieldTypeWrapper && !fw.FieldTypeWrapper.IsUnloadable)
d1001 1
a1001 1
		if(cpi.GetRetType(classLoader) != mw.ReturnType && !mw.ReturnType.IsUnloadable)
d1005 1
a1005 1
		TypeWrapper[] here = cpi.GetArgTypes(classLoader);
d1098 1
a1098 1
					exceptionTypeWrapper = m.Method.ClassFile.GetConstantPoolClassType(exc.catch_type, classLoader);
a1305 1
						ClassFile cf = instr.MethodCode.Method.ClassFile;
d1307 1
a1307 1
						switch(cf.GetConstantPoolConstantType(constant))
d1310 1
a1310 1
								ilGenerator.Emit(OpCodes.Ldc_R8, cf.GetConstantPoolConstantDouble(constant));
d1313 1
a1313 1
								ilGenerator.Emit(OpCodes.Ldc_R4, cf.GetConstantPoolConstantFloat(constant));
d1316 1
a1316 1
								EmitLdc_I4(cf.GetConstantPoolConstantInteger(constant));
d1319 1
a1319 1
								ilGenerator.Emit(OpCodes.Ldc_I8, cf.GetConstantPoolConstantLong(constant));
d1322 1
a1322 1
								ilGenerator.Emit(OpCodes.Ldstr, cf.GetConstantPoolConstantString(constant));
d1326 1
a1326 1
								TypeWrapper tw = cf.GetConstantPoolClassType(constant, classLoader);
d1350 1
a1350 1
						ClassFile.ConstantPoolItemMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
d1356 1
a1356 1
							cpi.GetClassType(classLoader).GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader())
d1390 1
a1390 1
						CastInterfaceArgs(method, cpi.GetArgTypes(classLoader), i, false, false);
d1398 2
a1399 2
						ClassFile.ConstantPoolItemMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
						int argcount = cpi.GetArgTypes(classLoader).Length;
d1401 1
a1401 1
						TypeWrapper thisType = SigTypeToClassName(type, cpi.GetClassType(classLoader));
d1409 1
a1409 1
							TypeWrapper[] args = cpi.GetArgTypes(classLoader);
d1415 1
a1415 1
							TypeWrapper[] methodArgs = cpi.GetArgTypes(classLoader);
d1420 1
a1420 1
								args[0] = cpi.GetClassType(classLoader);
d1592 1
a1592 1
								TypeWrapper retTypeWrapper = m.Method.GetRetType(classLoader);
d1621 1
a1621 1
								TypeWrapper retTypeWrapper = m.Method.GetRetType(classLoader);
d1712 1
a1712 1
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
d1748 1
a1748 1
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
d1773 1
a1773 1
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
d1835 1
a1835 1
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
d1845 1
a1845 1
						TypeWrapper wrapper = instr.MethodCode.Method.ClassFile.GetConstantPoolClassType(instr.Arg1, classLoader);
d2482 1
a2482 1
						for(int j = 0; j < instr.Values.Length; j++)
d2485 1
a2485 1
							EmitLdc_I4(instr.Values[j]);
d2489 1
a2489 1
							ilGenerator.Emit(OpCodes.Br, block.GetLabel(instr.PC + instr.TargetOffsets[j]));
d2604 1
a2604 1
				x.Emit(ilGenerator, m.Method);
d2787 1
a2787 1
		ClassFile.ConstantPoolItemFieldref cpi = m.Method.ClassFile.GetFieldref(instr.Arg1);
d2789 1
a2789 1
		TypeWrapper wrapper = cpi.GetClassType(classLoader);
d2792 1
a2792 1
			TypeWrapper fieldTypeWrapper = cpi.GetFieldType(classLoader);
d2833 1
a2833 1
				thisType = SigTypeToClassName(ma.GetRawStackTypeWrapper(i, 0), cpi.GetClassType(classLoader));
d2837 1
a2837 1
				thisType = SigTypeToClassName(ma.GetRawStackTypeWrapper(i, 1), cpi.GetClassType(classLoader));
d2931 1
a2931 1
			Emit(dynamicInvokestatic, ilgen, cpi.GetRetType(classLoader));
d2936 1
a2936 1
			Emit(dynamicInvokevirtual, ilgen, cpi.GetRetType(classLoader));
d2941 1
a2941 1
			Emit(dynamicInvokeSpecialNew, ilgen, cpi.GetClassType(classLoader));
d2947 1
a2947 1
			TypeWrapper[] args = cpi.GetArgTypes(classLoader);
d2977 1
a2977 1
		TypeWrapper wrapper = cpi.GetClassType(classLoader);
d3155 1
a3155 1
		if(cpi.GetClassType(classLoader).IsUnloadable || cpi.GetRetType(classLoader).IsUnloadable)
d3159 1
a3159 1
		TypeWrapper[] args = cpi.GetArgTypes(classLoader);
@


1.5
log
@*** empty log message ***
@
text
@d36 3
a38 3
	private static CodeEmitter mapExceptionMethod;
	private static CodeEmitter mapExceptionFastMethod;
	private static CodeEmitter fillInStackTraceMethod;
d84 6
a89 3
		mapExceptionMethod = exceptionHelper.GetMethodWrapper(MethodDescriptor.FromNameSig(exceptionHelper.GetClassLoader(), "MapException", "(Ljava.lang.Throwable;Lcli.System.Type;)Ljava.lang.Throwable;"), false).EmitCall;
		mapExceptionFastMethod = exceptionHelper.GetMethodWrapper(MethodDescriptor.FromNameSig(exceptionHelper.GetClassLoader(), "MapExceptionFast", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"), false).EmitCall;
		fillInStackTraceMethod = exceptionHelper.GetMethodWrapper(MethodDescriptor.FromNameSig(exceptionHelper.GetClassLoader(), "fillInStackTrace", "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"), false).EmitCall;
d464 3
a466 2
			MethodWrapper method = type.GetMethodWrapper(MethodDescriptor.FromNameSig(type.GetClassLoader(), "<init>", "(Ljava.lang.String;)V"), false);
			method.EmitNewobj.Emit(ilgen);
d519 8
d730 1
a730 2
			string msg = string.Format("(class: {0}, method: {1}, signature: {2}, offset: {3}, instruction: {4}) {5}", x.Class, x.Method, x.Signature, x.ByteCodeOffset, x.Instruction, x.Message);
			EmitHelper.Throw(ilGenerator, "java.lang.VerifyError", msg);
d987 25
d1130 1
a1130 1
							mapExceptionFastMethod.Emit(ilGenerator);
d1148 1
a1148 1
							mapExceptionMethod.Emit(ilGenerator);
d1154 1
a1154 1
							mapExceptionMethod.Emit(ilGenerator);
d1347 1
a1347 1
						ClassFile.ConstantPoolItemFMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
d1384 1
a1384 4
						CodeEmitter emitNewobj;
						CodeEmitter emitCall;
						CodeEmitter emitCallvirt;
						MethodWrapper method = GetMethodCallEmitter(cpi, null, NormalizedByteCode.__invokestatic, out emitNewobj, out emitCall, out emitCallvirt);
d1388 1
a1388 1
						emitCall.Emit(ilGenerator);
d1395 1
a1395 1
						ClassFile.ConstantPoolItemFMI cpi = m.Method.ClassFile.GetMethodref(instr.Arg1);
d1400 1
a1400 5
						CodeEmitter emitNewobj = null;
						CodeEmitter emitCall = null;
						CodeEmitter emitCallvirt = null;
						CodeEmitter emit = null;
						MethodWrapper method = GetMethodCallEmitter(cpi, thisType, instr.NormalizedOpCode, out emitNewobj, out emitCall, out emitCallvirt);
a1425 8
						if(instr.NormalizedOpCode == NormalizedByteCode.__invokespecial)
						{
							emit = emitCall;
						}
						else
						{
							emit = emitCallvirt;
						}
d1461 1
a1461 1
								emitNewobj.Emit(ilGenerator);
d1470 1
a1470 1
										fillInStackTraceMethod.Emit(ilGenerator);
d1546 1
a1546 1
								emitCall.Emit(ilGenerator);
d1565 8
a1572 1
							emit.Emit(ilGenerator);
d2837 1
a2837 1
			FieldWrapper field = wrapper.GetFieldWrapper(cpi.Name, cpi.GetFieldType(classLoader));
d2840 1
d2843 1
a2843 5
					// NOTE this access check is duplicated in ByteCodeHelper.GetFieldWrapper
					if(field.IsPublic ||
						(field.IsProtected && (isStatic ? clazz.IsSubTypeOf(field.DeclaringType) : thisType.IsSubTypeOf(clazz))) ||
						(field.IsPrivate && clazz == field.DeclaringType) ||
						(!(field.IsPublic || field.IsPrivate) && clazz.IsInSamePackageAs(field.DeclaringType)))
d2854 1
a2854 1
								field.EmitGet.Emit(ilGenerator);
d2865 1
a2865 1
								field.EmitSet.Emit(ilGenerator);
d2887 1
a2887 1
	private static MethodWrapper GetInterfaceMethod(TypeWrapper wrapper, MethodDescriptor md)
d2889 1
a2889 2
		MethodWrapper method = wrapper.GetMethodWrapper(md, false);
		if(method != null)
d2891 1
a2891 1
			return method;
d2893 1
a2893 2
		TypeWrapper[] interfaces = wrapper.Interfaces;
		for(int i = 0; i < interfaces.Length; i++)
d2895 11
a2905 5
			method = GetInterfaceMethod(interfaces[i], md);
			if(method != null)
			{
				return method;
			}
a2906 1
		return null;
d2909 1
a2909 1
	private class DynamicInvokeEmitter : CodeEmitter
d2911 3
d2916 1
a2916 3
		private ClassFile.ConstantPoolItemFMI cpi;
		private MethodInfo helperMethod;
		private TypeWrapper retTypeWrapper;
d2918 2
a2919 1
		internal DynamicInvokeEmitter(ClassLoaderWrapper classLoader, TypeWrapper wrapper, ClassFile.ConstantPoolItemFMI cpi, TypeWrapper retTypeWrapper, MethodInfo helperMethod)
a2923 2
			this.retTypeWrapper = retTypeWrapper;
			this.helperMethod = helperMethod;
d2926 16
a2941 1
		internal override void Emit(ILGenerator ilGenerator)
d2946 1
a2946 1
				LocalBuilder val = ilGenerator.DeclareLocal(typeof(object));
d2972 1
a2972 23
	private static void EmitReturnTypeConversion(ILGenerator ilgen, TypeWrapper typeWrapper)
	{
		if(typeWrapper.IsUnloadable)
		{
			// nothing to do for unloadables
		}
		else if(typeWrapper == PrimitiveTypeWrapper.VOID)
		{
			ilgen.Emit(OpCodes.Pop);
		}
		else if(typeWrapper.IsPrimitive)
		{
			// NOTE we don't need to use TypeWrapper.EmitUnbox, because the return value cannot be null
			ilgen.Emit(OpCodes.Unbox, typeWrapper.TypeAsTBD);
			ilgen.Emit(OpCodes.Ldobj, typeWrapper.TypeAsTBD);
		}
		else
		{
			ilgen.Emit(OpCodes.Castclass, typeWrapper.TypeAsTBD);
		}
	}

	private MethodWrapper GetMethodCallEmitter(ClassFile.ConstantPoolItemFMI cpi, TypeWrapper thisType, NormalizedByteCode invoke, out CodeEmitter emitNewobj, out CodeEmitter emitCall, out CodeEmitter emitCallvirt)
d2977 1
a2977 13
			emitNewobj = new DynamicInvokeEmitter(classLoader, clazz, cpi, cpi.GetClassType(classLoader), typeof(ByteCodeHelper).GetMethod("DynamicInvokeSpecialNew"));
			if(invoke == NormalizedByteCode.__invokestatic)
			{
				emitCall = new DynamicInvokeEmitter(classLoader, clazz, cpi, cpi.GetRetType(classLoader), typeof(ByteCodeHelper).GetMethod("DynamicInvokestatic"));
			}
			else
			{
				// NOTE this shouldn't happen, because invokespecial is only used to call
				// methods in this class or its base classes and those are obviously always loadable.
				emitCall = CodeEmitter.InternalError;
			}
			emitCallvirt = new DynamicInvokeEmitter(classLoader, clazz, cpi, cpi.GetRetType(classLoader), typeof(ByteCodeHelper).GetMethod("DynamicInvokevirtual"));
			return null;
d2991 1
a2991 24
				if(invoke == NormalizedByteCode.__invokespecial && m.Method.ClassFile.IsSuper && thisType != wrapper && thisType.IsSubTypeOf(wrapper))
				{
					wrapper = thisType.BaseTypeWrapper;
				}
				MethodDescriptor md = new MethodDescriptor(classLoader, cpi);
				MethodWrapper method = null;
				if(invoke == NormalizedByteCode.__invokeinterface)
				{
					method = GetInterfaceMethod(wrapper, md);
					// NOTE vmspec 5.4.3.4 clearly states that an interfacemethod may also refer to a method in Object
					if(method == null)
					{
						method = java_lang_Object.GetMethodWrapper(md, false);
					}
				}
				else
				{
					method = wrapper.GetMethodWrapper(md, md.Name != "<init>");
					// if the method is not found, we might have to simulate a Miranda method
					if(method == null && invoke == NormalizedByteCode.__invokevirtual)
					{
						method = GetInterfaceMethod(wrapper, md);
					}
				}
d2994 1
d3001 2
a3002 8
						else if(method.IsPublic ||
							(method.IsProtected && (method.IsStatic ? clazz.IsSubTypeOf(method.DeclaringType) : thisType.IsSubTypeOf(clazz))) ||
							(method.IsPrivate && clazz == method.DeclaringType) ||
							(!(method.IsPublic || method.IsPrivate) && clazz.IsInSamePackageAs(method.DeclaringType)))
						{
							emitNewobj = method.EmitNewobj;
							emitCall = method.EmitCall;
							emitCallvirt = method.EmitCallvirt;
d3012 2
a3013 1
								method = thisType.GetMethodWrapper(new MethodDescriptor(classLoader, cpi), false);
a3015 3
									emitNewobj = method.EmitNewobj;
									emitCall = method.EmitCall;
									emitCallvirt = method.EmitCallvirt;
d3150 1
a3150 1
	private bool IsUnloadable(ClassFile.ConstantPoolItemFMI cpi)
@


1.4
log
@*** empty log message ***
@
text
@d694 1
a694 1
				ilGenerator.Emit(OpCodes.Ldarg, (ushort)(i + (m.IsStatic ? 0 : 1)));
d3109 1
a3109 1
						ilGenerator.Emit(OpCodes.Ldarg, (ushort)i);
d3150 1
a3150 1
				ilGenerator.Emit(OpCodes.Starg, (ushort)i);
@


1.3
log
@*** empty log message ***
@
text
@d1351 1
a1351 1
						GetMethodCallEmitter(cpi, null, NormalizedByteCode.__invokestatic, out emitNewobj, out emitCall, out emitCallvirt);
d1354 1
a1354 1
						CastInterfaceArgs(cpi.GetArgTypes(classLoader), i, false, false);
d1367 6
d1378 1
a1378 1
							CastInterfaceArgs(args, i, false, false);
d1394 1
a1394 1
							CastInterfaceArgs(args, i, true, instr.NormalizedOpCode == NormalizedByteCode.__invokespecial && type != VerifierTypeWrapper.UninitializedThis);
a1396 5
						CodeEmitter emitNewobj = null;
						CodeEmitter emitCall = null;
						CodeEmitter emitCallvirt = null;
						CodeEmitter emit = null;
						GetMethodCallEmitter(cpi, thisType, instr.NormalizedOpCode, out emitNewobj, out emitCall, out emitCallvirt);
d2630 1
a2630 1
	private void CastInterfaceArgs(TypeWrapper[] args, int instructionIndex, bool instanceMethod, bool checkThisForNull)
d2707 7
a2713 7
					LocalBuilder local = ilGenerator.DeclareLocal(args[i].TypeAsParameterType);
					ilGenerator.Emit(OpCodes.Ldloca, local);
					dh.Load(i);
					ilGenerator.Emit(OpCodes.Stfld, args[i].GhostRefField);
					ilGenerator.Emit(OpCodes.Ldloca, local);
					// NOTE when the this argument is a value type, we need the address on the stack instead of the value
					if(i != 0 || !instanceMethod)
d2715 10
a2724 1
						ilGenerator.Emit(OpCodes.Ldobj, args[i].TypeAsParameterType);
d2951 1
a2951 1
	private void GetMethodCallEmitter(ClassFile.ConstantPoolItemFMI cpi, TypeWrapper thisType, NormalizedByteCode invoke, out CodeEmitter emitNewobj, out CodeEmitter emitCall, out CodeEmitter emitCallvirt)
d2968 1
a2968 1
			return;
d3022 1
a3022 1
							return;
d3037 1
a3037 1
									return;
@


1.2
log
@*** empty log message ***
@
text
@d131 8
a138 2
		ma = new MethodAnalyzer(clazz, m, classLoader);
		Profiler.Leave("MethodAnalyzer");
d705 8
a712 2
			c = new Compiler(clazz, m.CodeAttribute, ilGenerator, classLoader, symboldocument);
			Profiler.Leave("new Compiler");
d723 1
a723 1
		if(m.IsStatic && m.IsSynchronized)
d725 30
a754 18
			ArrayList exits = new ArrayList();
			// TODO consider caching the Class object in a static field
			ilGenerator.Emit(OpCodes.Ldtoken, clazz.TypeAsTBD);
			ilGenerator.Emit(OpCodes.Call, getTypeFromHandleMethod);
			ilGenerator.Emit(OpCodes.Call, getClassFromTypeMethod);
			ilGenerator.Emit(OpCodes.Dup);
			LocalBuilder monitor = ilGenerator.DeclareLocal(typeof(object));
			ilGenerator.Emit(OpCodes.Stloc, monitor);
			ilGenerator.Emit(OpCodes.Call, monitorEnterMethod);
			ilGenerator.BeginExceptionBlock();
			Block b = new Block(c, 0, int.MaxValue, -1, exits, true);
			c.Compile(b);
			b.Leave();
			ilGenerator.BeginFinallyBlock();
			ilGenerator.Emit(OpCodes.Ldloc, monitor);
			ilGenerator.Emit(OpCodes.Call, monitorExitMethod);
			ilGenerator.EndExceptionBlock();
			b.LeaveStubs(new Block(c, 0, int.MaxValue, -1, null, false));
d756 1
a756 1
		else
d758 2
a759 8
			Block b = new Block(c, 0, int.MaxValue, -1, null, false);
			c.Compile(b);
			b.Leave();
		}
		// HACK because of the bogus Leave instruction that Reflection.Emit generates, this location
		// sometimes appears reachable (it isn't), so we emit a bogus branch to keep the verifier happy.
		ilGenerator.Emit(OpCodes.Br_S, (sbyte)-2);
		Profiler.Leave("Compile");
d2692 1
@


1.1
log
@*** empty log message ***
@
text
@d866 11
a877 1
						int stack = bc.dh.Count;
d2555 4
@

