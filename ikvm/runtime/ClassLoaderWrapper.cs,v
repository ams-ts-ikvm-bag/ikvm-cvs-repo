head	1.237;
access;
symbols
	v8_1_5717_0:1.237
	v8_1:1.237.0.2
	v8_0_5449_1:1.231
	v8_0_5449_0:1.231
	v8_0:1.231.0.2
	v7_4_5196_0:1.221
	v7_4:1.221.0.2
	v7_3:1.213.0.2
	v7_2_4630_6:1.195
	v7_2_4630_5:1.195
	v7_2_4630_4:1.195
	v7_2_4630_3:1.195
	v7_2_4630_2:1.195
	v0_46_0_4:1.179.2.2
	v7_2_4630_1:1.195
	v7_2:1.195.0.2
	v7_1_4532_2:1.194
	v7_1_4532_1:1.194
	v7_1_4532_0:1.194
	v7_1:1.194.0.2
	v7_0_4335_3:1.180.2.1
	v7_0_4335_2:1.180.2.1
	v7_0_4335_1:1.180.2.1
	v0_46_0_2:1.179.2.1
	v7_0_4335_0:1.180
	v7_0:1.180.0.2
	v0_40_0_6:1.143
	v0_40_0_5:1.143
	v0_46_0_1:1.179
	v0_46_0_0:1.179
	v0_46:1.179.0.2
	v0_36_0_14:1.95.2.4
	v0_44_0_6:1.172.2.1
	v0_44_0_5:1.172
	v0_44_0_4:1.172
	v0_44_0_3:1.172
	v0_44_0_2:1.172
	v0_42_0_7:1.155.2.1
	v0_44_0_1:1.172
	v0_44_0_0:1.172
	v0_44:1.172.0.2
	v0_42_0_6:1.155.2.1
	v0_42_0_5:1.155.2.1
	v0_42_0_4:1.155.2.1
	v0_42_0_3:1.155.2.1
	v0_42_0_2:1.155.2.1
	v0_42_0_1:1.155
	v0_42_0_0:1.155
	v0_42:1.155.0.2
	v0_40_0_3:1.143
	v0_40_0_2:1.143
	v0_40_0_1:1.143
	v0_40_0_0:1.143
	v0_40:1.143.0.2
	v0_36_0_13:1.95.2.4
	v0_38_0_1:1.121
	v0_38_0_0:1.121
	v0_38:1.121.0.2
	v0_36_0_9:1.95.2.3
	v0_36_0_7:1.95.2.1
	v0_36_0_5:1.95.2.1
	v0_36_0_4:1.95
	v0_36_0_3:1.95
	v0_36_0_2:1.95
	v0_36_0_1:1.95
	v0_36_0_0:1.95
	v0_36:1.95.0.2
	v0_34_0_3:1.89.2.1
	v0_34_0_2:1.89
	v0_34_0_1:1.89
	v0_34_0_0:1.89
	v0_34:1.89.0.2
	v0_32:1.85.0.2
	v0_32_0_0:1.85
	v0_30:1.71.0.2
	v0_28_0_0:1.51
	v0_26_0_1:1.48
	v0_26_0_0:1.47
	v0_24_0_1:1.46
	v0_24_0_0:1.45
	v0_22_0_0:1.42
	v0_20_0_0:1.41
	v0_18_0_0:1.30
	v0_16_0_0:1.30
	v0_14_0_1:1.24
	v0_14_0_0:1.24
	v0_12_0_0:1.23
	v0_10_0_1:1.19
	v0_10_0_0:1.19
	v0_8_0_0:1.2;
locks; strict;
comment	@ * @;


1.237
date	2015.07.02.07.21.18;	author jfrijters;	state Exp;
branches;
next	1.236;

1.236
date	2015.06.26.11.22.19;	author jfrijters;	state Exp;
branches;
next	1.235;

1.235
date	2015.03.24.09.39.11;	author jfrijters;	state Exp;
branches;
next	1.234;

1.234
date	2015.03.24.09.15.03;	author jfrijters;	state Exp;
branches;
next	1.233;

1.233
date	2015.03.22.11.19.37;	author jfrijters;	state Exp;
branches;
next	1.232;

1.232
date	2015.03.05.12.43.14;	author jfrijters;	state Exp;
branches;
next	1.231;

1.231
date	2014.07.10.08.35.32;	author jfrijters;	state Exp;
branches;
next	1.230;

1.230
date	2014.07.10.08.18.10;	author jfrijters;	state Exp;
branches;
next	1.229;

1.229
date	2014.07.09.12.52.19;	author jfrijters;	state Exp;
branches;
next	1.228;

1.228
date	2014.07.01.15.12.34;	author jfrijters;	state Exp;
branches;
next	1.227;

1.227
date	2014.06.24.10.32.16;	author jfrijters;	state Exp;
branches;
next	1.226;

1.226
date	2014.06.24.09.44.37;	author jfrijters;	state Exp;
branches;
next	1.225;

1.225
date	2014.06.03.12.42.19;	author jfrijters;	state Exp;
branches;
next	1.224;

1.224
date	2014.05.01.11.56.28;	author jfrijters;	state Exp;
branches;
next	1.223;

1.223
date	2014.04.28.14.26.37;	author jfrijters;	state Exp;
branches;
next	1.222;

1.222
date	2014.04.11.13.03.36;	author jfrijters;	state Exp;
branches;
next	1.221;

1.221
date	2014.02.24.17.05.25;	author jfrijters;	state Exp;
branches;
next	1.220;

1.220
date	2014.02.21.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.219;

1.219
date	2014.02.20.16.13.29;	author jfrijters;	state Exp;
branches;
next	1.218;

1.218
date	2013.04.01.05.35.31;	author jfrijters;	state Exp;
branches;
next	1.217;

1.217
date	2013.04.01.05.30.43;	author jfrijters;	state Exp;
branches;
next	1.216;

1.216
date	2013.03.29.10.37.02;	author jfrijters;	state Exp;
branches;
next	1.215;

1.215
date	2013.03.26.11.20.21;	author jfrijters;	state Exp;
branches;
next	1.214;

1.214
date	2013.03.25.19.57.46;	author jfrijters;	state Exp;
branches;
next	1.213;

1.213
date	2013.02.23.08.50.01;	author jfrijters;	state Exp;
branches;
next	1.212;

1.212
date	2013.02.21.12.32.10;	author jfrijters;	state Exp;
branches;
next	1.211;

1.211
date	2013.02.21.07.00.37;	author jfrijters;	state Exp;
branches;
next	1.210;

1.210
date	2013.02.19.20.00.32;	author jfrijters;	state Exp;
branches;
next	1.209;

1.209
date	2013.02.19.19.42.32;	author jfrijters;	state Exp;
branches;
next	1.208;

1.208
date	2013.02.19.16.24.09;	author jfrijters;	state Exp;
branches;
next	1.207;

1.207
date	2013.02.19.11.22.38;	author jfrijters;	state Exp;
branches;
next	1.206;

1.206
date	2013.02.19.09.51.58;	author jfrijters;	state Exp;
branches;
next	1.205;

1.205
date	2013.02.19.07.17.50;	author jfrijters;	state Exp;
branches;
next	1.204;

1.204
date	2013.02.14.10.56.54;	author jfrijters;	state Exp;
branches;
next	1.203;

1.203
date	2013.02.14.10.40.51;	author jfrijters;	state Exp;
branches;
next	1.202;

1.202
date	2013.02.14.10.03.34;	author jfrijters;	state Exp;
branches;
next	1.201;

1.201
date	2013.02.12.11.06.48;	author jfrijters;	state Exp;
branches;
next	1.200;

1.200
date	2013.01.31.15.45.23;	author jfrijters;	state Exp;
branches;
next	1.199;

1.199
date	2013.01.30.17.39.46;	author jfrijters;	state Exp;
branches;
next	1.198;

1.198
date	2013.01.24.17.48.38;	author jfrijters;	state Exp;
branches;
next	1.197;

1.197
date	2013.01.15.14.40.03;	author jfrijters;	state Exp;
branches;
next	1.196;

1.196
date	2013.01.08.07.07.07;	author jfrijters;	state Exp;
branches;
next	1.195;

1.195
date	2012.08.06.12.12.03;	author jfrijters;	state Exp;
branches;
next	1.194;

1.194
date	2012.03.25.09.10.29;	author jfrijters;	state Exp;
branches;
next	1.193;

1.193
date	2012.03.24.08.54.13;	author jfrijters;	state Exp;
branches;
next	1.192;

1.192
date	2012.03.22.09.27.51;	author jfrijters;	state Exp;
branches;
next	1.191;

1.191
date	2012.01.26.06.44.39;	author jfrijters;	state Exp;
branches;
next	1.190;

1.190
date	2012.01.03.14.27.39;	author jfrijters;	state Exp;
branches;
next	1.189;

1.189
date	2012.01.02.15.11.09;	author jfrijters;	state Exp;
branches;
next	1.188;

1.188
date	2011.12.15.08.56.10;	author jfrijters;	state Exp;
branches;
next	1.187;

1.187
date	2011.12.14.12.10.00;	author jfrijters;	state Exp;
branches;
next	1.186;

1.186
date	2011.12.14.11.12.50;	author jfrijters;	state Exp;
branches;
next	1.185;

1.185
date	2011.12.13.10.39.46;	author jfrijters;	state Exp;
branches;
next	1.184;

1.184
date	2011.11.29.07.03.22;	author jfrijters;	state Exp;
branches;
next	1.183;

1.183
date	2011.11.28.08.14.13;	author jfrijters;	state Exp;
branches;
next	1.182;

1.182
date	2011.11.21.11.51.31;	author jfrijters;	state Exp;
branches;
next	1.181;

1.181
date	2011.11.17.13.53.02;	author jfrijters;	state Exp;
branches;
next	1.180;

1.180
date	2011.08.16.13.40.05;	author jfrijters;	state Exp;
branches
	1.180.2.1;
next	1.179;

1.179
date	2010.12.24.08.34.05;	author jfrijters;	state Exp;
branches
	1.179.2.1;
next	1.178;

1.178
date	2010.12.08.08.09.11;	author jfrijters;	state Exp;
branches;
next	1.177;

1.177
date	2010.11.25.08.50.49;	author jfrijters;	state Exp;
branches;
next	1.176;

1.176
date	2010.11.23.05.33.42;	author jfrijters;	state Exp;
branches;
next	1.175;

1.175
date	2010.11.23.04.46.07;	author jfrijters;	state Exp;
branches;
next	1.174;

1.174
date	2010.09.21.05.45.48;	author jfrijters;	state Exp;
branches;
next	1.173;

1.173
date	2010.07.16.08.50.40;	author jfrijters;	state Exp;
branches;
next	1.172;

1.172
date	2010.06.08.12.48.36;	author jfrijters;	state Exp;
branches
	1.172.2.1;
next	1.171;

1.171
date	2010.06.07.04.21.35;	author jfrijters;	state Exp;
branches;
next	1.170;

1.170
date	2010.05.19.15.46.27;	author jfrijters;	state Exp;
branches;
next	1.169;

1.169
date	2010.05.19.15.45.25;	author jfrijters;	state Exp;
branches;
next	1.168;

1.168
date	2010.05.19.15.20.36;	author jfrijters;	state Exp;
branches;
next	1.167;

1.167
date	2010.05.03.07.58.01;	author jfrijters;	state Exp;
branches;
next	1.166;

1.166
date	2010.04.09.04.50.25;	author jfrijters;	state Exp;
branches;
next	1.165;

1.165
date	2010.01.29.07.08.56;	author jfrijters;	state Exp;
branches;
next	1.164;

1.164
date	2010.01.29.06.58.10;	author jfrijters;	state Exp;
branches;
next	1.163;

1.163
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches;
next	1.162;

1.162
date	2010.01.28.07.14.37;	author jfrijters;	state Exp;
branches;
next	1.161;

1.161
date	2010.01.28.06.37.48;	author jfrijters;	state Exp;
branches;
next	1.160;

1.160
date	2010.01.28.06.06.37;	author jfrijters;	state Exp;
branches;
next	1.159;

1.159
date	2010.01.25.07.52.51;	author jfrijters;	state Exp;
branches;
next	1.158;

1.158
date	2010.01.06.14.28.38;	author jfrijters;	state Exp;
branches;
next	1.157;

1.157
date	2009.10.21.04.54.39;	author jfrijters;	state Exp;
branches;
next	1.156;

1.156
date	2009.10.21.04.43.27;	author jfrijters;	state Exp;
branches;
next	1.155;

1.155
date	2009.09.09.05.17.04;	author jfrijters;	state Exp;
branches
	1.155.2.1;
next	1.154;

1.154
date	2009.09.07.04.46.01;	author jfrijters;	state Exp;
branches;
next	1.153;

1.153
date	2009.09.07.04.19.05;	author jfrijters;	state Exp;
branches;
next	1.152;

1.152
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.151;

1.151
date	2009.08.27.14.40.42;	author jfrijters;	state Exp;
branches;
next	1.150;

1.150
date	2009.07.29.07.02.50;	author jfrijters;	state Exp;
branches;
next	1.149;

1.149
date	2009.07.27.08.06.41;	author jfrijters;	state Exp;
branches;
next	1.148;

1.148
date	2009.06.02.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.147;

1.147
date	2009.05.29.07.47.20;	author jfrijters;	state Exp;
branches;
next	1.146;

1.146
date	2009.05.28.06.11.09;	author jfrijters;	state Exp;
branches;
next	1.145;

1.145
date	2009.05.28.05.58.35;	author jfrijters;	state Exp;
branches;
next	1.144;

1.144
date	2009.05.26.10.17.57;	author jfrijters;	state Exp;
branches;
next	1.143;

1.143
date	2009.03.09.09.01.36;	author jfrijters;	state Exp;
branches;
next	1.142;

1.142
date	2009.03.07.08.33.33;	author jfrijters;	state Exp;
branches;
next	1.141;

1.141
date	2009.03.07.08.11.28;	author jfrijters;	state Exp;
branches;
next	1.140;

1.140
date	2009.03.02.06.30.13;	author jfrijters;	state Exp;
branches;
next	1.139;

1.139
date	2009.03.02.04.51.05;	author jfrijters;	state Exp;
branches;
next	1.138;

1.138
date	2009.02.27.06.43.00;	author jfrijters;	state Exp;
branches;
next	1.137;

1.137
date	2009.02.27.06.33.19;	author jfrijters;	state Exp;
branches;
next	1.136;

1.136
date	2009.02.27.06.28.50;	author jfrijters;	state Exp;
branches;
next	1.135;

1.135
date	2009.02.27.06.05.22;	author jfrijters;	state Exp;
branches;
next	1.134;

1.134
date	2009.02.19.08.12.05;	author jfrijters;	state Exp;
branches;
next	1.133;

1.133
date	2009.02.10.07.27.25;	author jfrijters;	state Exp;
branches;
next	1.132;

1.132
date	2009.02.10.07.24.30;	author jfrijters;	state Exp;
branches;
next	1.131;

1.131
date	2009.02.05.07.00.59;	author jfrijters;	state Exp;
branches;
next	1.130;

1.130
date	2009.02.05.06.44.30;	author jfrijters;	state Exp;
branches;
next	1.129;

1.129
date	2009.02.04.08.10.24;	author jfrijters;	state Exp;
branches;
next	1.128;

1.128
date	2009.02.04.07.24.44;	author jfrijters;	state Exp;
branches;
next	1.127;

1.127
date	2009.02.04.07.10.59;	author jfrijters;	state Exp;
branches;
next	1.126;

1.126
date	2009.01.17.11.05.28;	author jfrijters;	state Exp;
branches;
next	1.125;

1.125
date	2008.12.24.05.11.48;	author jfrijters;	state Exp;
branches;
next	1.124;

1.124
date	2008.12.23.07.11.29;	author jfrijters;	state Exp;
branches;
next	1.123;

1.123
date	2008.11.18.05.25.06;	author jfrijters;	state Exp;
branches;
next	1.122;

1.122
date	2008.11.14.08.42.07;	author jfrijters;	state Exp;
branches;
next	1.121;

1.121
date	2008.08.28.06.50.16;	author jfrijters;	state Exp;
branches;
next	1.120;

1.120
date	2008.08.15.12.01.18;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2008.08.06.12.22.06;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2008.05.20.07.43.42;	author jfrijters;	state Exp;
branches;
next	1.117;

1.117
date	2008.05.20.07.36.50;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2008.04.22.06.24.55;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2008.03.14.09.15.08;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2008.03.04.07.25.36;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2008.03.03.07.05.20;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2008.02.27.09.04.21;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2008.02.10.09.05.53;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2007.12.27.15.16.49;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2007.12.19.11.28.11;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2007.12.17.10.59.02;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2007.11.26.09.01.35;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2007.11.26.05.50.58;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2007.10.26.07.11.17;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2007.10.26.05.14.36;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2007.10.25.12.57.41;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.25.06.28.26;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2007.10.22.09.25.10;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2007.10.22.05.20.42;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2007.10.21.07.14.53;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2007.10.18.13.57.05;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2007.10.18.13.54.11;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2007.08.14.12.08.39;	author jfrijters;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2007.08.08.12.50.48;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.12.09.46.53;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.27.08.16.58;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2007.04.23.08.24.33;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2007.04.15.08.01.19;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2007.03.29.09.17.20;	author jfrijters;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2007.02.16.07.42.33;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2007.01.16.10.14.47;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2007.01.04.07.46.40;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2006.12.05.07.52.27;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2006.11.30.14.29.43;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2006.11.27.07.39.31;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2006.10.10.16.31.34;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2006.10.09.08.29.42;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2006.10.06.06.53.34;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2006.09.12.09.57.36;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2006.09.01.07.53.36;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2006.08.31.09.22.10;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2006.08.21.05.15.52;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2006.08.17.07.33.40;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2006.08.14.07.57.03;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2006.08.06.09.27.20;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.31.12.46.44;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.27.14.44.51;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2006.07.27.11.57.33;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.26.14.16.52;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.26.10.33.52;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.26.09.03.44;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.26.07.57.18;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2006.07.21.10.18.15;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2006.07.11.11.34.44;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.11.07.29.32;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.10.14.40.31;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2006.07.10.09.37.07;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2006.07.06.13.53.52;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2006.07.06.10.11.31;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2006.07.05.13.41.46;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2006.07.05.08.46.56;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.04.10.13.33;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.28.08.07.29;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.26.09.04.03;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.23.12.49.18;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.15.09.08.01;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.23.11.57.44;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.11.18.35.30;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2006.02.22.14.44.07;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.23.10.18.44;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.02.08.15.43;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.19.15.12.50;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.01.14.01.43;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.06.08.06.04;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2005.08.25.13.15.42;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2005.08.25.09.36.36;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.25.07.46.57;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.24.11.35.00;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.05.08.40.54;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.03.12.59.17;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.02.08.44.55;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.01.10.27.06;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.27.15.57.56;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.25.14.34.22;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.27.09.06.57;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.24.07.00.43;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2005.06.16.07.42.58;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.01.09.49.30;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.30.15.30.13;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.23.08.24.08;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.23.09.33.41;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.23.12.56.15;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.11.14.47.04;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.04.10.48.36;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.02.15.12.03;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.22.08.04.10;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.21.14.59.30;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.21.10.26.53;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.03.07.57.15;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.29.09.48.05;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.23.17.46.40;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.16.11.11.54;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.08.10.01.47;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.19.13.43.56;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.04.19.30.54;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.05.09.37.59;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.30.15.56.24;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.10.07.19.57;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.25.13.35.36;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;

1.89.2.1
date	2007.05.30.12.04.54;	author jfrijters;	state Exp;
branches;
next	;

1.95.2.1
date	2007.12.04.06.04.33;	author jfrijters;	state Exp;
branches;
next	1.95.2.2;

1.95.2.2
date	2008.02.03.07.56.15;	author jfrijters;	state Exp;
branches;
next	1.95.2.3;

1.95.2.3
date	2008.02.27.07.09.46;	author jfrijters;	state Exp;
branches;
next	1.95.2.4;

1.95.2.4
date	2008.03.14.06.16.38;	author jfrijters;	state Exp;
branches;
next	;

1.155.2.1
date	2009.10.26.04.49.21;	author jfrijters;	state Exp;
branches;
next	;

1.172.2.1
date	2010.10.22.06.57.08;	author jfrijters;	state Exp;
branches;
next	;

1.179.2.1
date	2011.12.20.12.33.46;	author jfrijters;	state Exp;
branches;
next	1.179.2.2;

1.179.2.2
date	2012.10.03.06.18.57;	author jfrijters;	state Exp;
branches;
next	;

1.180.2.1
date	2012.01.03.12.16.37;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.237
log
@Improved -removeassertions ikvmc optimization to remove more code (esp. allow otherwise empty <clinit> methods to be optimized away).
@
text
@/*
  Copyright (C) 2002-2015 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
#if STATIC_COMPILER || STUB_GENERATOR
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
using ProtectionDomain = System.Object;
#else
using System.Reflection;
using System.Reflection.Emit;
using ProtectionDomain = java.security.ProtectionDomain;
#endif
using System.IO;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Runtime.CompilerServices;
using IKVM.Attributes;

namespace IKVM.Internal
{
	[Flags]
	enum CodeGenOptions
	{
		None = 0,
		Debug = 1,
		NoStackTraceInfo = 2,
		StrictFinalFieldSemantics = 4,
		NoJNI = 8,
		RemoveAsserts = 16,
		NoAutomagicSerialization = 32,
		DisableDynamicBinding = 64,
		NoRefEmitHelpers = 128,
		RemoveUnusedFields = 256,
	}

	[Flags]
	enum LoadMode
	{
		// These are the modes that should be used
		Find					= ReturnNull,
		LoadOrNull				= Load | ReturnNull,
		LoadOrThrow				= Load | ThrowClassNotFound,
		Link					= Load | ReturnUnloadable | SuppressExceptions,

		// call into Java class loader
		Load					= 0x0001,

		// return value
		DontReturnUnloadable	= 0x0002,	// This is used with a bitwise OR to disable returning unloadable
		ReturnUnloadable		= 0x0004,
		ReturnNull				= 0x0004 | DontReturnUnloadable,
		ThrowClassNotFound		= 0x0008 | DontReturnUnloadable,
		MaskReturn				= ReturnUnloadable | ReturnNull | ThrowClassNotFound,

		// exceptions (not ClassNotFoundException)
		SuppressExceptions		= 0x0010,

		// warnings
		WarnClassNotFound		= 0x0020,
	}

#if !STUB_GENERATOR
	abstract class TypeWrapperFactory
	{
		internal abstract ModuleBuilder ModuleBuilder { get; }
		internal abstract TypeWrapper DefineClassImpl(Dictionary<string, TypeWrapper> types, TypeWrapper host, ClassFile f, ClassLoaderWrapper classLoader, ProtectionDomain protectionDomain);
		internal abstract bool ReserveName(string name);
		internal abstract string AllocMangledName(DynamicTypeWrapper tw);
		internal abstract Type DefineUnloadable(string name);
		internal abstract Type DefineDelegate(int parameterCount, bool returnVoid);
		internal abstract bool HasInternalAccess { get; }
#if CLASSGC
		internal abstract void AddInternalsVisibleTo(Assembly friend);
#endif
	}
#endif // !STUB_GENERATOR

	class ClassLoaderWrapper
	{
		private static readonly object wrapperLock = new object();
		private static readonly Dictionary<Type, TypeWrapper> globalTypeToTypeWrapper = new Dictionary<Type, TypeWrapper>();
#if STATIC_COMPILER || STUB_GENERATOR
		private static ClassLoaderWrapper bootstrapClassLoader;
#else
		private static AssemblyClassLoader bootstrapClassLoader;
#endif
		private static List<GenericClassLoaderWrapper> genericClassLoaders;
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
		protected java.lang.ClassLoader javaClassLoader;
#endif
#if !STUB_GENERATOR
		private TypeWrapperFactory factory;
#endif // !STUB_GENERATOR
		private readonly Dictionary<string, TypeWrapper> types = new Dictionary<string, TypeWrapper>();
		private readonly Dictionary<string, Thread> defineClassInProgress = new Dictionary<string, Thread>();
		private List<IntPtr> nativeLibraries;
		private readonly CodeGenOptions codegenoptions;
#if CLASSGC
		private Dictionary<Type, TypeWrapper> typeToTypeWrapper;
		private static ConditionalWeakTable<Assembly, ClassLoaderWrapper> dynamicAssemblies;
#endif
		private static readonly Dictionary<Type, string> remappedTypes = new Dictionary<Type, string>();

#if STATIC_COMPILER || STUB_GENERATOR
		// HACK this is used by the ahead-of-time compiler to overrule the bootstrap classloader
		// when we're compiling the core class libraries and by ikvmstub with the -bootstrap option
		internal static void SetBootstrapClassLoader(ClassLoaderWrapper bootstrapClassLoader)
		{
			Debug.Assert(ClassLoaderWrapper.bootstrapClassLoader == null);

			ClassLoaderWrapper.bootstrapClassLoader = bootstrapClassLoader;
		}
#endif

		static ClassLoaderWrapper()
		{
			globalTypeToTypeWrapper[PrimitiveTypeWrapper.BOOLEAN.TypeAsTBD] = PrimitiveTypeWrapper.BOOLEAN;
			globalTypeToTypeWrapper[PrimitiveTypeWrapper.BYTE.TypeAsTBD] = PrimitiveTypeWrapper.BYTE;
			globalTypeToTypeWrapper[PrimitiveTypeWrapper.CHAR.TypeAsTBD] = PrimitiveTypeWrapper.CHAR;
			globalTypeToTypeWrapper[PrimitiveTypeWrapper.DOUBLE.TypeAsTBD] = PrimitiveTypeWrapper.DOUBLE;
			globalTypeToTypeWrapper[PrimitiveTypeWrapper.FLOAT.TypeAsTBD] = PrimitiveTypeWrapper.FLOAT;
			globalTypeToTypeWrapper[PrimitiveTypeWrapper.INT.TypeAsTBD] = PrimitiveTypeWrapper.INT;
			globalTypeToTypeWrapper[PrimitiveTypeWrapper.LONG.TypeAsTBD] = PrimitiveTypeWrapper.LONG;
			globalTypeToTypeWrapper[PrimitiveTypeWrapper.SHORT.TypeAsTBD] = PrimitiveTypeWrapper.SHORT;
			globalTypeToTypeWrapper[PrimitiveTypeWrapper.VOID.TypeAsTBD] = PrimitiveTypeWrapper.VOID;
			LoadRemappedTypes();
		}

		internal static void LoadRemappedTypes()
		{
			// if we're compiling the core, coreAssembly will be null
			Assembly coreAssembly = JVM.CoreAssembly;
			if(coreAssembly != null && remappedTypes.Count ==0)
			{
				RemappedClassAttribute[] remapped = AttributeHelper.GetRemappedClasses(coreAssembly);
				if(remapped.Length > 0)
				{
					foreach(RemappedClassAttribute r in remapped)
					{
						remappedTypes.Add(r.RemappedType, r.Name);
					}
				}
				else
				{
#if STATIC_COMPILER
					throw new FatalCompilerErrorException(Message.CoreClassesMissing);
#else
					JVM.CriticalFailure("Failed to find core classes in core library", null);
#endif
				}
			}
		}

		internal ClassLoaderWrapper(CodeGenOptions codegenoptions, object javaClassLoader)
		{
			this.codegenoptions = codegenoptions;
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
			this.javaClassLoader = (java.lang.ClassLoader)javaClassLoader;
#endif
		}

		internal static bool IsRemappedType(Type type)
		{
			return remappedTypes.ContainsKey(type);
		}

#if STATIC_COMPILER || STUB_GENERATOR
		internal void SetRemappedType(Type type, TypeWrapper tw)
		{
			lock(types)
			{
				types.Add(tw.Name, tw);
			}
			lock(globalTypeToTypeWrapper)
			{
				globalTypeToTypeWrapper.Add(type, tw);
			}
			remappedTypes.Add(type, tw.Name);
		}
#endif

		// return the TypeWrapper if it is already loaded, this exists for DynamicTypeWrapper.SetupGhosts
		// and implements ClassLoader.findLoadedClass()
		internal TypeWrapper FindLoadedClass(string name)
		{
			if (name.Length > 1 && name[0] == '[')
			{
				return FindOrLoadArrayClass(name, LoadMode.Find);
			}
			TypeWrapper tw;
			lock (types)
			{
				types.TryGetValue(name, out tw);
			}
			return tw ?? FindLoadedClassLazy(name);
		}

		protected virtual TypeWrapper FindLoadedClassLazy(string name)
		{
			return null;
		}

		internal TypeWrapper RegisterInitiatingLoader(TypeWrapper tw)
		{
			Debug.Assert(tw != null);
			Debug.Assert(!tw.IsUnloadable);
			Debug.Assert(!tw.IsPrimitive);

			try
			{
				// critical code in the finally block to avoid Thread.Abort interrupting the thread
			}
			finally
			{
				tw = RegisterInitiatingLoaderCritical(tw);
			}
			return tw;
		}

		private TypeWrapper RegisterInitiatingLoaderCritical(TypeWrapper tw)
		{
			lock(types)
			{
				TypeWrapper existing;
				types.TryGetValue(tw.Name, out existing);
				if(existing != tw)
				{
					if(existing != null)
					{
						// another thread beat us to it, discard the new TypeWrapper and
						// return the previous one
						return existing;
					}
					// NOTE if types.ContainsKey(tw.Name) is true (i.e. the value is null),
					// we currently have a DefineClass in progress on another thread and we've
					// beaten that thread to the punch by loading the class from a parent class
					// loader instead. This is ok as DefineClass will throw a LinkageError when
					// it is done.
					types[tw.Name] = tw;
				}
			}
			return tw;
		}

		internal bool EmitDebugInfo
		{
			get
			{
				return (codegenoptions & CodeGenOptions.Debug) != 0;
			}
		}

		internal bool EmitStackTraceInfo
		{
			get
			{
				// NOTE we're negating the flag here!
				return (codegenoptions & CodeGenOptions.NoStackTraceInfo) == 0;
			}
		}

		internal bool StrictFinalFieldSemantics
		{
			get
			{
				return (codegenoptions & CodeGenOptions.StrictFinalFieldSemantics) != 0;
			}
		}

		internal bool NoJNI
		{
			get
			{
				return (codegenoptions & CodeGenOptions.NoJNI) != 0;
			}
		}

		internal bool RemoveAsserts
		{
			get
			{
				return (codegenoptions & CodeGenOptions.RemoveAsserts) != 0;
			}
		}

		internal bool NoAutomagicSerialization
		{
			get
			{
				return (codegenoptions & CodeGenOptions.NoAutomagicSerialization) != 0;
			}
		}

		internal bool DisableDynamicBinding
		{
			get
			{
				return (codegenoptions & CodeGenOptions.DisableDynamicBinding) != 0;
			}
		}

		internal bool EmitNoRefEmitHelpers
		{
			get
			{
				return (codegenoptions & CodeGenOptions.NoRefEmitHelpers) != 0;
			}
		}

		internal bool RemoveUnusedFields
		{
			get
			{
				return (codegenoptions & CodeGenOptions.RemoveUnusedFields) != 0;
			}
		}

		internal bool WorkaroundAbstractMethodWidening
		{
			get
			{
				// pre-Roslyn C# compiler doesn't like widening access to abstract methods
				return true;
			}
		}

		internal bool WorkaroundInterfaceFields
		{
			get
			{
				// pre-Roslyn C# compiler doesn't allow access to interface fields
				return true;
			}
		}

		internal bool WorkaroundInterfacePrivateMethods
		{
			get
			{
				// pre-Roslyn C# compiler doesn't like interfaces that have non-public methods
				return true;
			}
		}

		internal bool WorkaroundInterfaceStaticMethods
		{
			get
			{
				// pre-Roslyn C# compiler doesn't allow access to interface static methods
				return true;
			}
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal bool RelaxedClassNameValidation
		{
			get
			{
#if FIRST_PASS
				return true;
#else
				return JVM.relaxedVerification && (javaClassLoader == null || java.lang.ClassLoader.isTrustedLoader(javaClassLoader));
#endif
			}
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR

		protected virtual void CheckProhibitedPackage(string className)
		{
			if (className.StartsWith("java.", StringComparison.Ordinal))
			{
				throw new JavaSecurityException("Prohibited package name: " + className.Substring(0, className.LastIndexOf('.')));
			}
		}

#if !STUB_GENERATOR
		internal TypeWrapper DefineClass(ClassFile f, ProtectionDomain protectionDomain)
		{
#if !STATIC_COMPILER
			string dotnetAssembly = f.IKVMAssemblyAttribute;
			if(dotnetAssembly != null)
			{
				// It's a stub class generated by ikvmstub (or generated by the runtime when getResource was
				// called on a statically compiled class).
				ClassLoaderWrapper loader;
				try
				{
					loader = ClassLoaderWrapper.GetAssemblyClassLoaderByName(dotnetAssembly);
				}
				catch(Exception x)
				{
					// TODO don't catch all exceptions here
					throw new NoClassDefFoundError(f.Name + " (" + x.Message + ")");
				}
				TypeWrapper tw = loader.LoadClassByDottedNameFast(f.Name);
				if(tw == null)
				{
					throw new NoClassDefFoundError(f.Name + " (type not found in " + dotnetAssembly + ")");
				}
				return RegisterInitiatingLoader(tw);
			}
#endif
			CheckProhibitedPackage(f.Name);
			// check if the class already exists if we're an AssemblyClassLoader
			if(FindLoadedClassLazy(f.Name) != null)
			{
				throw new LinkageError("duplicate class definition: " + f.Name);
			}
			TypeWrapper def;
			try
			{
				// critical code in the finally block to avoid Thread.Abort interrupting the thread
			}
			finally
			{
				def = DefineClassCritical(f, protectionDomain);
			}
			return def;
		}

		private TypeWrapper DefineClassCritical(ClassFile f, ProtectionDomain protectionDomain)
		{
			lock(types)
			{
				if(types.ContainsKey(f.Name))
				{
					throw new LinkageError("duplicate class definition: " + f.Name);
				}
				// mark the type as "loading in progress", so that we can detect circular dependencies.
				types.Add(f.Name, null);
				defineClassInProgress.Add(f.Name, Thread.CurrentThread);
			}
			try
			{
				return GetTypeWrapperFactory().DefineClassImpl(types, null, f, this, protectionDomain);
			}
			finally
			{
				lock(types)
				{
					if(types[f.Name] == null)
					{
						// if loading the class fails, we remove the indicator that we're busy loading the class,
						// because otherwise we get a ClassCircularityError if we try to load the class again.
						types.Remove(f.Name);
					}
					defineClassInProgress.Remove(f.Name);
					Monitor.PulseAll(types);
				}
			}
		}

		internal TypeWrapperFactory GetTypeWrapperFactory()
		{
			if(factory == null)
			{
				lock(this)
				{
					try
					{
						// critical code in the finally block to avoid Thread.Abort interrupting the thread
					}
					finally
					{
						if(factory == null)
						{
#if CLASSGC
							if(dynamicAssemblies == null)
							{
								Interlocked.CompareExchange(ref dynamicAssemblies, new ConditionalWeakTable<Assembly, ClassLoaderWrapper>(), null);
							}
							typeToTypeWrapper = new Dictionary<Type, TypeWrapper>();
							DynamicClassLoader instance = DynamicClassLoader.Get(this);
							dynamicAssemblies.Add(instance.ModuleBuilder.Assembly.ManifestModule.Assembly, this);
							this.factory = instance;
#else
							factory = DynamicClassLoader.Get(this);
#endif
						}
					}
				}
			}
			return factory;
		}
#endif // !STUB_GENERATOR

		internal TypeWrapper LoadClassByDottedName(string name)
		{
			return LoadClass(name, LoadMode.LoadOrThrow);
		}

		internal TypeWrapper LoadClassByDottedNameFast(string name)
		{
			return LoadClass(name, LoadMode.LoadOrNull);
		}

		internal TypeWrapper LoadClass(string name, LoadMode mode)
		{
			Profiler.Enter("LoadClass");
			try
			{
				TypeWrapper tw = LoadRegisteredOrPendingClass(name);
				if (tw != null)
				{
					return tw;
				}
				if (name.Length > 1 && name[0] == '[')
				{
					tw = FindOrLoadArrayClass(name, mode);
				}
				else
				{
					tw = LoadClassImpl(name, mode);
				}
				if (tw != null)
				{
					return RegisterInitiatingLoader(tw);
				}
#if STATIC_COMPILER
				if (!(name.Length > 1 && name[0] == '[') && ((mode & LoadMode.WarnClassNotFound) != 0) || WarningLevelHigh)
				{
					IssueMessage(Message.ClassNotFound, name);
				}
#else
				if (!(name.Length > 1 && name[0] == '['))
				{
					Tracer.Error(Tracer.ClassLoading, "Class not found: {0}", name);
				}
#endif
				switch (mode & LoadMode.MaskReturn)
				{
					case LoadMode.ReturnNull:
						return null;
					case LoadMode.ReturnUnloadable:
						return new UnloadableTypeWrapper(name);
					case LoadMode.ThrowClassNotFound:
						throw new ClassNotFoundException(name);
					default:
						throw new InvalidOperationException();
				}
			}
			finally
			{
				Profiler.Leave("LoadClass");
			}
		}

		private TypeWrapper LoadRegisteredOrPendingClass(string name)
		{
			TypeWrapper tw;
			lock (types)
			{
				if (types.TryGetValue(name, out tw) && tw == null)
				{
					Thread defineThread;
					if (defineClassInProgress.TryGetValue(name, out defineThread))
					{
						if (Thread.CurrentThread == defineThread)
						{
							throw new ClassCircularityError(name);
						}
						// the requested class is currently being defined by another thread,
						// so we have to wait on that
						while (defineClassInProgress.ContainsKey(name))
						{
							Monitor.Wait(types);
						}
						// the defineClass may have failed, so we need to use TryGetValue
						types.TryGetValue(name, out tw);
					}
				}
			}
			return tw;
		}

		private TypeWrapper FindOrLoadArrayClass(string name, LoadMode mode)
		{
			int dims = 1;
			while(name[dims] == '[')
			{
				dims++;
				if(dims == name.Length)
				{
					// malformed class name
					return null;
				}
			}
			if(name[dims] == 'L')
			{
				if(!name.EndsWith(";") || name.Length <= dims + 2 || name[dims + 1] == '[')
				{
					// malformed class name
					return null;
				}
				string elemClass = name.Substring(dims + 1, name.Length - dims - 2);
				// NOTE it's important that we're registered as the initiating loader
				// for the element type here
				TypeWrapper type = LoadClass(elemClass, mode | LoadMode.DontReturnUnloadable);
				if(type != null)
				{
					type = CreateArrayType(name, type, dims);
				}
				return type;
			}
			if(name.Length != dims + 1)
			{
				// malformed class name
				return null;
			}
			switch(name[dims])
			{
				case 'B':
					return CreateArrayType(name, PrimitiveTypeWrapper.BYTE, dims);
				case 'C':
					return CreateArrayType(name, PrimitiveTypeWrapper.CHAR, dims);
				case 'D':
					return CreateArrayType(name, PrimitiveTypeWrapper.DOUBLE, dims);
				case 'F':
					return CreateArrayType(name, PrimitiveTypeWrapper.FLOAT, dims);
				case 'I':
					return CreateArrayType(name, PrimitiveTypeWrapper.INT, dims);
				case 'J':
					return CreateArrayType(name, PrimitiveTypeWrapper.LONG, dims);
				case 'S':
					return CreateArrayType(name, PrimitiveTypeWrapper.SHORT, dims);
				case 'Z':
					return CreateArrayType(name, PrimitiveTypeWrapper.BOOLEAN, dims);
				default:
					return null;
			}
		}

		internal TypeWrapper FindOrLoadGenericClass(string name, LoadMode mode)
		{
			// we don't want to expose any failures to load any of the component types
			mode = (mode & LoadMode.MaskReturn) | LoadMode.ReturnNull;

			// we need to handle delegate methods here (for generic delegates)
			// (note that other types with manufactured inner classes such as Attribute and Enum can't be generic)
			if (name.EndsWith(DotNetTypeWrapper.DelegateInterfaceSuffix))
			{
				TypeWrapper outer = FindOrLoadGenericClass(name.Substring(0, name.Length - DotNetTypeWrapper.DelegateInterfaceSuffix.Length), mode);
				if (outer != null && outer.IsFakeTypeContainer)
				{
					foreach (TypeWrapper tw in outer.InnerClasses)
					{
						if (tw.Name == name)
						{
							return tw;
						}
					}
				}
			}
			// generic class name grammar:
			//
			// mangled(open_generic_type_name) "_$$$_" M(parameter_class_name) ( "_$$_" M(parameter_class_name) )* "_$$$$_"
			//
			// mangled() is the normal name mangling algorithm
			// M() is a replacement of "__" with "$$005F$$005F" followed by a replace of "." with "__"
			//
			int pos = name.IndexOf("_$$$_");
			if(pos <= 0 || !name.EndsWith("_$$$$_"))
			{
				return null;
			}
			TypeWrapper def = LoadClass(name.Substring(0, pos), mode);
			if (def == null || !def.TypeAsTBD.IsGenericTypeDefinition)
			{
				return null;
			}
			Type type = def.TypeAsTBD;
			List<string> typeParamNames = new List<string>();
			pos += 5;
			int start = pos;
			int nest = 0;
			for(;;)
			{
				pos = name.IndexOf("_$$", pos);
				if(pos == -1)
				{
					return null;
				}
				if(name.IndexOf("_$$_", pos, 4) == pos)
				{
					if(nest == 0)
					{
						typeParamNames.Add(name.Substring(start, pos - start));
						start = pos + 4;
					}
					pos += 4;
				}
				else if(name.IndexOf("_$$$_", pos, 5) == pos)
				{
					nest++;
					pos += 5;
				}
				else if(name.IndexOf("_$$$$_", pos, 6) == pos)
				{
					if(nest == 0)
					{
						if(pos + 6 != name.Length)
						{
							return null;
						}
						typeParamNames.Add(name.Substring(start, pos - start));
						break;
					}
					nest--;
					pos += 6;
				}
				else
				{
					pos += 3;
				}
			}
			Type[] typeArguments = new Type[typeParamNames.Count];
			for(int i = 0; i < typeArguments.Length; i++)
			{
				string s = (string)typeParamNames[i];
				// only do the unmangling for non-generic types (because we don't want to convert
				// the double underscores in two adjacent _$$$_ or _$$$$_ markers)
				if(s.IndexOf("_$$$_") == -1)
				{
					s = s.Replace("__", ".");
					s = s.Replace("$$005F$$005F", "__");
				}
				int dims = 0;
				while(s.Length > dims && s[dims] == 'A')
				{
					dims++;
				}
				if(s.Length == dims)
				{
					return null;
				}
				TypeWrapper tw;
				switch(s[dims])
				{
					case 'L':
						tw = LoadClass(s.Substring(dims + 1), mode);
						if(tw == null)
						{
							return null;
						}
						tw.Finish();
						break;
					case 'Z':
						tw = PrimitiveTypeWrapper.BOOLEAN;
						break;
					case 'B':
						tw = PrimitiveTypeWrapper.BYTE;
						break;
					case 'S':
						tw = PrimitiveTypeWrapper.SHORT;
						break;
					case 'C':
						tw = PrimitiveTypeWrapper.CHAR;
						break;
					case 'I':
						tw = PrimitiveTypeWrapper.INT;
						break;
					case 'F':
						tw = PrimitiveTypeWrapper.FLOAT;
						break;
					case 'J':
						tw = PrimitiveTypeWrapper.LONG;
						break;
					case 'D':
						tw = PrimitiveTypeWrapper.DOUBLE;
						break;
					default:
						return null;
				}
				if(dims > 0)
				{
					tw = tw.MakeArrayType(dims);
				}
				typeArguments[i] = tw.TypeAsSignatureType;
			}
			try
			{
				type = type.MakeGenericType(typeArguments);
			}
			catch(ArgumentException)
			{
				// one of the typeArguments failed to meet the constraints
				return null;
			}
			TypeWrapper wrapper = GetWrapperFromType(type);
			if(wrapper != null && wrapper.Name != name)
			{
				// the name specified was not in canonical form
				return null;
			}
			return wrapper;
		}

		protected virtual TypeWrapper LoadClassImpl(string name, LoadMode mode)
		{
			TypeWrapper tw = FindOrLoadGenericClass(name, mode);
			if(tw != null)
			{
				return tw;
			}
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
			if((mode & LoadMode.Load) == 0)
			{
				return null;
			}
			Profiler.Enter("ClassLoader.loadClass");
			try
			{
				java.lang.Class c = GetJavaClassLoader().loadClassInternal(name);
				if(c == null)
				{
					return null;
				}
				TypeWrapper type = TypeWrapper.FromClass(c);
				if(type.Name != name)
				{
					// the class loader is trying to trick us
					return null;
				}
				return type;
			}
			catch(java.lang.ClassNotFoundException x)
			{
				if((mode & LoadMode.MaskReturn) == LoadMode.ThrowClassNotFound)
				{
					throw new ClassLoadingException(ikvm.runtime.Util.mapException(x), name);
				}
				return null;
			}
			catch(java.lang.ThreadDeath)
			{
				throw;
			}
			catch(Exception x)
			{
				if((mode & LoadMode.SuppressExceptions) == 0)
				{
					throw new ClassLoadingException(ikvm.runtime.Util.mapException(x), name);
				}
				if(Tracer.ClassLoading.TraceError)
				{
					java.lang.ClassLoader cl = GetJavaClassLoader();
					if(cl != null)
					{
						System.Text.StringBuilder sb = new System.Text.StringBuilder();
						string sep = "";
						while(cl != null)
						{
							sb.Append(sep).Append(cl);
							sep = " -> ";
							cl = cl.getParent();
						}
						Tracer.Error(Tracer.ClassLoading, "ClassLoader chain: {0}", sb);
					}
					Exception m = ikvm.runtime.Util.mapException(x);
					Tracer.Error(Tracer.ClassLoading, m.ToString() + Environment.NewLine + m.StackTrace);
				}
				return null;
			}
			finally
			{
				Profiler.Leave("ClassLoader.loadClass");
			}
#else
			return null;
#endif
		}

		private static TypeWrapper CreateArrayType(string name, TypeWrapper elementTypeWrapper, int dims)
		{
			Debug.Assert(new String('[', dims) + elementTypeWrapper.SigName == name);
			Debug.Assert(!elementTypeWrapper.IsUnloadable && !elementTypeWrapper.IsVerifierType && !elementTypeWrapper.IsArray);
			Debug.Assert(dims >= 1);
			return elementTypeWrapper.GetClassLoader().RegisterInitiatingLoader(new ArrayTypeWrapper(elementTypeWrapper, name));
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal virtual java.lang.ClassLoader GetJavaClassLoader()
		{
#if FIRST_PASS
			return null;
#else
			return javaClassLoader;
#endif
		}
#endif

		// NOTE this exposes potentially unfinished types
		internal Type[] ArgTypeListFromSig(string sig)
		{
			if(sig[1] == ')')
			{
				return Type.EmptyTypes;
			}
			TypeWrapper[] wrappers = ArgTypeWrapperListFromSig(sig, LoadMode.LoadOrThrow);
			Type[] types = new Type[wrappers.Length];
			for(int i = 0; i < wrappers.Length; i++)
			{
				types[i] = wrappers[i].TypeAsSignatureType;
			}
			return types;
		}

		// NOTE: this will ignore anything following the sig marker (so that it can be used to decode method signatures)
		private TypeWrapper SigDecoderWrapper(ref int index, string sig, LoadMode mode)
		{
			switch(sig[index++])
			{
				case 'B':
					return PrimitiveTypeWrapper.BYTE;
				case 'C':
					return PrimitiveTypeWrapper.CHAR;
				case 'D':
					return PrimitiveTypeWrapper.DOUBLE;
				case 'F':
					return PrimitiveTypeWrapper.FLOAT;
				case 'I':
					return PrimitiveTypeWrapper.INT;
				case 'J':
					return PrimitiveTypeWrapper.LONG;
				case 'L':
				{
					int pos = index;
					index = sig.IndexOf(';', index) + 1;
					return LoadClass(sig.Substring(pos, index - pos - 1), mode);
				}
				case 'S':
					return PrimitiveTypeWrapper.SHORT;
				case 'Z':
					return PrimitiveTypeWrapper.BOOLEAN;
				case 'V':
					return PrimitiveTypeWrapper.VOID;
				case '[':
				{
					// TODO this can be optimized
					string array = "[";
					while(sig[index] == '[')
					{
						index++;
						array += "[";
					}
					switch(sig[index])
					{
						case 'L':
						{
							int pos = index;
							index = sig.IndexOf(';', index) + 1;
							return LoadClass(array + sig.Substring(pos, index - pos), mode);
						}
						case 'B':
						case 'C':
						case 'D':
						case 'F':
						case 'I':
						case 'J':
						case 'S':
						case 'Z':
							return LoadClass(array + sig[index++], mode);
						default:
							throw new InvalidOperationException(sig.Substring(index));
					}
				}
				default:
					throw new InvalidOperationException(sig.Substring(index));
			}
		}

		internal TypeWrapper FieldTypeWrapperFromSig(string sig, LoadMode mode)
		{
			int index = 0;
			return SigDecoderWrapper(ref index, sig, mode);
		}

		internal TypeWrapper RetTypeWrapperFromSig(string sig, LoadMode mode)
		{
			int index = sig.IndexOf(')') + 1;
			return SigDecoderWrapper(ref index, sig, mode);
		}

		internal TypeWrapper[] ArgTypeWrapperListFromSig(string sig, LoadMode mode)
		{
			if(sig[1] == ')')
			{
				return TypeWrapper.EmptyArray;
			}
			List<TypeWrapper> list = new List<TypeWrapper>();
			for(int i = 1; sig[i] != ')';)
			{
				list.Add(SigDecoderWrapper(ref i, sig, mode));
			}
			return list.ToArray();
		}

#if STATIC_COMPILER || STUB_GENERATOR
		internal static ClassLoaderWrapper GetBootstrapClassLoader()
#else
		internal static AssemblyClassLoader GetBootstrapClassLoader()
#endif
		{
			lock(wrapperLock)
			{
				if(bootstrapClassLoader == null)
				{
					bootstrapClassLoader = new BootstrapClassLoader();
				}
				return bootstrapClassLoader;
			}
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal static ClassLoaderWrapper GetClassLoaderWrapper(java.lang.ClassLoader javaClassLoader)
		{
			if(javaClassLoader == null)
			{
				return GetBootstrapClassLoader();
			}
			lock(wrapperLock)
			{
#if FIRST_PASS
				ClassLoaderWrapper wrapper = null;
#else
				ClassLoaderWrapper wrapper = 
#if __MonoCS__
					// MONOBUG the redundant cast to ClassLoaderWrapper is to workaround an mcs bug
					(ClassLoaderWrapper)(object)
#endif
					javaClassLoader.wrapper;
#endif
				if(wrapper == null)
				{
					CodeGenOptions opt = CodeGenOptions.None;
					if(JVM.EmitSymbols)
					{
						opt |= CodeGenOptions.Debug;
					}
#if NET_4_0
					if (!AppDomain.CurrentDomain.IsFullyTrusted)
					{
						opt |= CodeGenOptions.NoAutomagicSerialization;
					}
#endif
					wrapper = new ClassLoaderWrapper(opt, javaClassLoader);
					SetWrapperForClassLoader(javaClassLoader, wrapper);
				}
				return wrapper;
			}
		}
#endif

#if CLASSGC
		internal static ClassLoaderWrapper GetClassLoaderForDynamicJavaAssembly(Assembly asm)
		{
			ClassLoaderWrapper loader;
			dynamicAssemblies.TryGetValue(asm, out loader);
			return loader;
		}
#endif // CLASSGC

		internal static TypeWrapper GetWrapperFromType(Type type)
		{
#if STATIC_COMPILER
			if (type.__ContainsMissingType)
			{
				return new UnloadableTypeWrapper(type);
			}
#endif
			//Tracer.Info(Tracer.Runtime, "GetWrapperFromType: {0}", type.AssemblyQualifiedName);
#if !STATIC_COMPILER
			TypeWrapper.AssertFinished(type);
#endif
			Debug.Assert(!type.IsPointer);
			Debug.Assert(!type.IsByRef);
			TypeWrapper wrapper;
			lock(globalTypeToTypeWrapper)
			{
				globalTypeToTypeWrapper.TryGetValue(type, out wrapper);
			}
			if(wrapper != null)
			{
				return wrapper;
			}
#if STUB_GENERATOR
			if(type.__IsMissing || type.__ContainsMissingType)
			{
				wrapper = new UnloadableTypeWrapper("Missing/" + type.Assembly.FullName);
				globalTypeToTypeWrapper.Add(type, wrapper);
				return wrapper;
			}
#endif
			string remapped;
			if(remappedTypes.TryGetValue(type, out remapped))
			{
				wrapper = LoadClassCritical(remapped);
			}
			else if(ReflectUtil.IsVector(type))
			{
				// it might be an array of a dynamically compiled Java type
				int rank = 1;
				Type elem = type.GetElementType();
				while(ReflectUtil.IsVector(elem))
				{
					rank++;
					elem = elem.GetElementType();
				}
				wrapper = GetWrapperFromType(elem).MakeArrayType(rank);
			}
			else
			{
				Assembly asm = type.Assembly;
#if CLASSGC
				ClassLoaderWrapper loader = null;
				if(dynamicAssemblies != null && dynamicAssemblies.TryGetValue(asm, out loader))
				{
					lock(loader.typeToTypeWrapper)
					{
						TypeWrapper tw;
						if(loader.typeToTypeWrapper.TryGetValue(type, out tw))
						{
							return tw;
						}
						// it must be an anonymous type then
						Debug.Assert(AnonymousTypeWrapper.IsAnonymous(type));
					}
				}
#endif
#if !STATIC_COMPILER && !STUB_GENERATOR
				if(AnonymousTypeWrapper.IsAnonymous(type))
				{
					Dictionary<Type, TypeWrapper> typeToTypeWrapper;
#if CLASSGC
					typeToTypeWrapper = loader != null ? loader.typeToTypeWrapper : globalTypeToTypeWrapper;
#else
					typeToTypeWrapper = globalTypeToTypeWrapper;
#endif
					TypeWrapper tw = new AnonymousTypeWrapper(type);
					lock(typeToTypeWrapper)
					{
						if(!typeToTypeWrapper.TryGetValue(type, out wrapper))
						{
							typeToTypeWrapper.Add(type, wrapper = tw);
						}
					}
					return wrapper;
				}
				if(ReflectUtil.IsReflectionOnly(type))
				{
					// historically we've always returned null for types that don't have a corresponding TypeWrapper (or java.lang.Class)
					return null;
				}
#endif
				// if the wrapper doesn't already exist, that must mean that the type
				// is a .NET type (or a pre-compiled Java class), which means that it
				// was "loaded" by an assembly classloader
				wrapper = AssemblyClassLoader.FromAssembly(asm).GetWrapperFromAssemblyType(type);
			}
#if CLASSGC
			if(type.Assembly.IsDynamic)
			{
				// don't cache types in dynamic assemblies, because they might live in a RunAndCollect assembly
				// TODO we also shouldn't cache generic type instances that have a GCable type parameter
				return wrapper;
			}
#endif
			lock(globalTypeToTypeWrapper)
			{
				try
				{
					// critical code in the finally block to avoid Thread.Abort interrupting the thread
				}
				finally
				{
					globalTypeToTypeWrapper[type] = wrapper;
				}
			}
			return wrapper;
		}

		internal static ClassLoaderWrapper GetGenericClassLoader(TypeWrapper wrapper)
		{
			Type type = wrapper.TypeAsTBD;
			Debug.Assert(type.IsGenericType);
			Debug.Assert(!type.ContainsGenericParameters);

			List<ClassLoaderWrapper> list = new List<ClassLoaderWrapper>();
			list.Add(AssemblyClassLoader.FromAssembly(type.Assembly));
			foreach(Type arg in type.GetGenericArguments())
			{
				ClassLoaderWrapper loader = GetWrapperFromType(arg).GetClassLoader();
				if(!list.Contains(loader) && loader != bootstrapClassLoader)
				{
					list.Add(loader);
				}
			}
			ClassLoaderWrapper[] key = list.ToArray();
			ClassLoaderWrapper matchingLoader = GetGenericClassLoaderByKey(key);
			matchingLoader.RegisterInitiatingLoader(wrapper);
			return matchingLoader;
		}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
		internal static object DoPrivileged(java.security.PrivilegedAction action)
		{
			return java.security.AccessController.doPrivileged(action, ikvm.@@internal.CallerID.create(typeof(java.lang.ClassLoader).TypeHandle));
		}
#endif

		private static ClassLoaderWrapper GetGenericClassLoaderByKey(ClassLoaderWrapper[] key)
		{
			lock(wrapperLock)
			{
				if(genericClassLoaders == null)
				{
					genericClassLoaders = new List<GenericClassLoaderWrapper>();
				}
				foreach(GenericClassLoaderWrapper loader in genericClassLoaders)
				{
					if(loader.Matches(key))
					{
						return loader;
					}
				}
#if STATIC_COMPILER || STUB_GENERATOR || FIRST_PASS
				GenericClassLoaderWrapper newLoader = new GenericClassLoaderWrapper(key, null);
#else
				java.lang.ClassLoader javaClassLoader = new ikvm.runtime.GenericClassLoader();
				GenericClassLoaderWrapper newLoader = new GenericClassLoaderWrapper(key, javaClassLoader);
				SetWrapperForClassLoader(javaClassLoader, newLoader);
#endif
				genericClassLoaders.Add(newLoader);
				return newLoader;
			}
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		protected internal static void SetWrapperForClassLoader(java.lang.ClassLoader javaClassLoader, ClassLoaderWrapper wrapper)
		{
#if __MonoCS__ || FIRST_PASS
			typeof(java.lang.ClassLoader).GetField("wrapper", BindingFlags.NonPublic | BindingFlags.Instance).SetValue(javaClassLoader, wrapper);
#else
			javaClassLoader.wrapper = wrapper;
#endif
		}
#endif

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal static ClassLoaderWrapper GetGenericClassLoaderByName(string name)
		{
			Debug.Assert(name.StartsWith("[[") && name.EndsWith("]]"));
			Stack<List<ClassLoaderWrapper>> stack = new Stack<List<ClassLoaderWrapper>>();
			List<ClassLoaderWrapper> list = null;
			for(int i = 0; i < name.Length; i++)
			{
				if(name[i] == '[')
				{
					if(name[i + 1] == '[')
					{
						stack.Push(list);
						list = new List<ClassLoaderWrapper>();
						if(name[i + 2] == '[')
						{
							i++;
						}
					}
					else
					{
						int start = i + 1;
						i = name.IndexOf(']', i);
						list.Add(ClassLoaderWrapper.GetAssemblyClassLoaderByName(name.Substring(start, i - start)));
					}
				}
				else if(name[i] == ']')
				{
					ClassLoaderWrapper loader = GetGenericClassLoaderByKey(list.ToArray());
					list = stack.Pop();
					if(list == null)
					{
						return loader;
					}
					list.Add(loader);
				}
				else
				{
					throw new InvalidOperationException();
				}
			}
			throw new InvalidOperationException();
		}

		internal static ClassLoaderWrapper GetAssemblyClassLoaderByName(string name)
		{
			if(name.StartsWith("[["))
			{
				return GetGenericClassLoaderByName(name);
			}
			return AssemblyClassLoader.FromAssembly(Assembly.Load(name));
		}
#endif

		internal static int GetGenericClassLoaderId(ClassLoaderWrapper wrapper)
		{
			lock(wrapperLock)
			{
				return genericClassLoaders.IndexOf(wrapper as GenericClassLoaderWrapper);
			}
		}

		internal static ClassLoaderWrapper GetGenericClassLoaderById(int id)
		{
			lock(wrapperLock)
			{
				return genericClassLoaders[id];
			}
		}

		internal void SetWrapperForType(Type type, TypeWrapper wrapper)
		{
#if !STATIC_COMPILER
			TypeWrapper.AssertFinished(type);
#endif
			Dictionary<Type, TypeWrapper> dict;
#if CLASSGC
			dict = typeToTypeWrapper ?? globalTypeToTypeWrapper;
#else
			dict = globalTypeToTypeWrapper;
#endif
			lock (dict)
			{
				try
				{
					// critical code in the finally block to avoid Thread.Abort interrupting the thread
				}
				finally
				{
					dict.Add(type, wrapper);
				}
			}
		}

		internal static TypeWrapper LoadClassCritical(string name)
		{
#if STATIC_COMPILER
			TypeWrapper wrapper = GetBootstrapClassLoader().LoadClassByDottedNameFast(name);
			if (wrapper == null)
			{
				throw new FatalCompilerErrorException(Message.CriticalClassNotFound, name);
			}
			return wrapper;
#else
			try
			{
				return GetBootstrapClassLoader().LoadClassByDottedName(name);
			}
			catch(Exception x)
			{
				JVM.CriticalFailure("Loading of critical class failed", x);
				return null;
			}
#endif
		}

		internal void RegisterNativeLibrary(IntPtr p)
		{
			lock(this)
			{
				try
				{
					// critical code in the finally block to avoid Thread.Abort interrupting the thread
				}
				finally
				{
					if(nativeLibraries == null)
					{
						nativeLibraries = new List<IntPtr>();
					}
					nativeLibraries.Add(p);
				}
			}
		}

		internal void UnregisterNativeLibrary(IntPtr p)
		{
			lock(this)
			{
				try
				{
					// critical code in the finally block to avoid Thread.Abort interrupting the thread
				}
				finally
				{
					nativeLibraries.Remove(p);
				}
			}
		}

		internal IntPtr[] GetNativeLibraries()
		{
			lock(this)
			{
				if(nativeLibraries ==  null)
				{
					return new IntPtr[0];
				}
				return nativeLibraries.ToArray();
			}
		}

#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
		public override string ToString()
		{
			object javaClassLoader = GetJavaClassLoader();
			if(javaClassLoader == null)
			{
				return "null";
			}
			return String.Format("{0}@@{1:X}", GetWrapperFromType(javaClassLoader.GetType()).Name, javaClassLoader.GetHashCode());
		}
#endif

		internal virtual bool InternalsVisibleToImpl(TypeWrapper wrapper, TypeWrapper friend)
		{
			Debug.Assert(wrapper.GetClassLoader() == this);
			return this == friend.GetClassLoader();
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		// this method is used by IKVM.Runtime.JNI
		internal static ClassLoaderWrapper FromCallerID(ikvm.@@internal.CallerID callerID)
		{
#if FIRST_PASS
			return null;
#else
			return GetClassLoaderWrapper(callerID.getCallerClassLoader());
#endif
		}
#endif

#if STATIC_COMPILER
		internal virtual void IssueMessage(Message msgId, params string[] values)
		{
			// it's not ideal when we end up here (because it means we're emitting a warning that is not associated with a specific output target),
			// but it happens when we're decoding something in a referenced assembly that either doesn't make sense or contains an unloadable type
			StaticCompiler.IssueMessage(msgId, values);
		}
#endif

		internal void CheckPackageAccess(TypeWrapper tw, ProtectionDomain pd)
		{
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
			if (javaClassLoader != null)
			{
				javaClassLoader.checkPackageAccess(tw.ClassObject, pd);
			}
#endif
		}

#if !STUB_GENERATOR
		internal ClassFileParseOptions ClassFileParseOptions
		{
			get
			{
#if STATIC_COMPILER
				ClassFileParseOptions cfp = ClassFileParseOptions.LocalVariableTable;
				if (EmitStackTraceInfo)
				{
					cfp |= ClassFileParseOptions.LineNumberTable;
				}
				if (bootstrapClassLoader is CompilerClassLoader)
				{
					cfp |= ClassFileParseOptions.TrustedAnnotations;
				}
				if (RemoveAsserts)
				{
					cfp |= ClassFileParseOptions.RemoveAssertions;
				}
				return cfp;
#else
				ClassFileParseOptions cfp = ClassFileParseOptions.LineNumberTable;
				if (EmitDebugInfo)
				{
					cfp |= ClassFileParseOptions.LocalVariableTable;
				}
				if (RelaxedClassNameValidation)
				{
					cfp |= ClassFileParseOptions.RelaxedClassNameValidation;
				}
				if (this == bootstrapClassLoader)
				{
					cfp |= ClassFileParseOptions.TrustedAnnotations;
				}
				return cfp;
#endif
			}
		}
#endif

#if STATIC_COMPILER
		internal virtual bool WarningLevelHigh
		{
			get { return false; }
		}

		internal virtual bool NoParameterReflection
		{
			get { return false; }
		}
#endif
	}

	sealed class GenericClassLoaderWrapper : ClassLoaderWrapper
	{
		private readonly ClassLoaderWrapper[] delegates;

		internal GenericClassLoaderWrapper(ClassLoaderWrapper[] delegates, object javaClassLoader)
			: base(CodeGenOptions.None, javaClassLoader)
		{
			this.delegates = delegates;
		}

		internal bool Matches(ClassLoaderWrapper[] key)
		{
			if(key.Length == delegates.Length)
			{
				for(int i = 0; i < key.Length; i++)
				{
					if(key[i] != delegates[i])
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		protected override TypeWrapper FindLoadedClassLazy(string name)
		{
			TypeWrapper tw1 = FindOrLoadGenericClass(name, LoadMode.Find);
			if (tw1 != null)
			{
				return tw1;
			}
			foreach (ClassLoaderWrapper loader in delegates)
			{
				TypeWrapper tw = loader.FindLoadedClass(name);
				if (tw != null && tw.GetClassLoader() == loader)
				{
					return tw;
				}
			}
			return null;
		}

		internal string GetName()
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			sb.Append('[');
			foreach(ClassLoaderWrapper loader in delegates)
			{
				sb.Append('[');
				GenericClassLoaderWrapper gcl = loader as GenericClassLoaderWrapper;
				if(gcl != null)
				{
					sb.Append(gcl.GetName());
				}
				else
				{
					sb.Append(((AssemblyClassLoader)loader).MainAssembly.FullName);
				}
				sb.Append(']');
			}
			sb.Append(']');
			return sb.ToString();
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal java.util.Enumeration GetResources(string name)
		{
#if FIRST_PASS
			return null;
#else
			java.util.Vector v = new java.util.Vector();
			foreach (java.net.URL url in GetBootstrapClassLoader().GetResources(name))
			{
				v.add(url);
			}
			if (name.EndsWith(".class", StringComparison.Ordinal) && name.IndexOf('.') == name.Length - 6)
			{
				TypeWrapper tw = FindLoadedClass(name.Substring(0, name.Length - 6).Replace('/', '.'));
				if (tw != null && !tw.IsArray && !tw.IsDynamic)
				{
					ClassLoaderWrapper loader = tw.GetClassLoader();
					if (loader is GenericClassLoaderWrapper)
					{
						v.add(new java.net.URL("ikvmres", "gen", ClassLoaderWrapper.GetGenericClassLoaderId(loader), "/" + name));
					}
					else if (loader is AssemblyClassLoader)
					{
						foreach (java.net.URL url in ((AssemblyClassLoader)loader).FindResources(name))
						{
							v.add(url);
						}
					}
				}
			}
			return v.elements();
#endif
		}

		internal java.net.URL FindResource(string name)
		{
#if !FIRST_PASS
			if (name.EndsWith(".class", StringComparison.Ordinal) && name.IndexOf('.') == name.Length - 6)
			{
				TypeWrapper tw = FindLoadedClass(name.Substring(0, name.Length - 6).Replace('/', '.'));
				if (tw != null && tw.GetClassLoader() == this && !tw.IsArray && !tw.IsDynamic)
				{
					return new java.net.URL("ikvmres", "gen", ClassLoaderWrapper.GetGenericClassLoaderId(this), "/" + name);
				}
			}
#endif
			return null;
		}
#endif
	}
}
@


1.236
log
@Moved unused field removal optimization to a later stage in the compilation. Also made the check more strict to only remove final fields and not remove fields that have annotations.
@
text
@d1498 4
@


1.235
log
@Removed sig decoding methods with implicit LoadMode.
@
text
@d56 1
d333 8
@


1.234
log
@Minor class loading refactoring.
@
text
@d913 1
a913 1
			TypeWrapper[] wrappers = ArgTypeWrapperListFromSig(sig);
a985 10
		internal TypeWrapper FieldTypeWrapperFromSig(string sig)
		{
			return FieldTypeWrapperFromSig(sig, LoadMode.LoadOrThrow);
		}

		internal TypeWrapper FieldTypeWrapperFromSigNoThrow(string sig)
		{
			return FieldTypeWrapperFromSig(sig, LoadMode.Link);
		}

a991 10
		internal TypeWrapper RetTypeWrapperFromSig(string sig)
		{
			return RetTypeWrapperFromSig(sig, LoadMode.LoadOrThrow);
		}

		internal TypeWrapper RetTypeWrapperFromSigNoThrow(string sig)
		{
			return RetTypeWrapperFromSig(sig, LoadMode.Link);
		}

a997 10
		internal TypeWrapper[] ArgTypeWrapperListFromSig(string sig)
		{
			return ArgTypeWrapperListFromSig(sig, LoadMode.LoadOrThrow);
		}

		internal TypeWrapper[] ArgTypeWrapperListFromSigNoThrow(string sig)
		{
			return ArgTypeWrapperListFromSig(sig, LoadMode.Link);
		}

@


1.233
log
@CreateArrayType should be a static method.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2014 Jeroen Frijters
d58 26
d210 1
a210 1
				return FindOrLoadArrayClass(name, true);
d503 1
a503 6
			TypeWrapper type = LoadClassByDottedNameFastImpl(name, true);
			if(type != null)
			{
				return RegisterInitiatingLoader(type);
			}
			throw new ClassNotFoundException(name);
d508 1
a508 6
			TypeWrapper type = LoadClassByDottedNameFastImpl(name, false);
			if(type != null)
			{
				return RegisterInitiatingLoader(type);
			}
			return null;
d511 1
a511 1
		private TypeWrapper LoadClassByDottedNameFastImpl(string name, bool throwClassNotFoundException)
d513 1
a513 1
			Profiler.Enter("LoadClassByDottedName");
d516 24
a539 2
				TypeWrapper type = LoadRegisteredOrPendingClass(name);
				if(type != null)
d541 1
a541 1
					return type;
d543 2
a544 1
				if(name.Length > 1 && name[0] == '[')
d546 8
a553 1
					return FindOrLoadArrayClass(name, false);
a554 1
				return LoadClassImpl(name, throwClassNotFoundException);
d558 1
a558 1
				Profiler.Leave("LoadClassByDottedName");
d590 1
a590 6
		private TypeWrapper FindOrLoadClass(string name, bool find)
		{
			return find ? FindLoadedClass(name) : LoadClassByDottedNameFast(name);
		}

		private TypeWrapper FindOrLoadArrayClass(string name, bool find)
d612 1
a612 1
				TypeWrapper type = FindOrLoadClass(elemClass, find);
d647 1
a647 1
		internal TypeWrapper FindOrLoadGenericClass(string name, bool find)
d649 3
d656 1
a656 1
				TypeWrapper outer = FindOrLoadGenericClass(name.Substring(0, name.Length - DotNetTypeWrapper.DelegateInterfaceSuffix.Length), find);
d680 1
a680 1
			TypeWrapper def = FindOrLoadClass(name.Substring(0, pos), find);
d754 1
a754 1
						tw = FindOrLoadClass(s.Substring(dims + 1), find);
d812 1
a812 1
		protected virtual TypeWrapper LoadClassImpl(string name, bool throwClassNotFoundException)
d814 1
a814 1
			TypeWrapper tw = FindOrLoadGenericClass(name, false);
d820 4
d842 1
a842 1
				if(throwClassNotFoundException)
d848 4
d854 23
a876 1
				throw new ClassLoadingException(ikvm.runtime.Util.mapException(x), name);
a921 5
		private TypeWrapper SigDecoderLoadClass(string name, bool nothrow)
		{
			return nothrow ? LoadClassNoThrow(this, name, false) : LoadClassByDottedName(name);
		}

d923 1
a923 1
		private TypeWrapper SigDecoderWrapper(ref int index, string sig, bool nothrow)
d943 1
a943 1
					return SigDecoderLoadClass(sig.Substring(pos, index - pos - 1), nothrow);
d966 1
a966 1
							return SigDecoderLoadClass(array + sig.Substring(pos, index - pos), nothrow);
d976 1
a976 1
							return SigDecoderLoadClass(array + sig[index++], nothrow);
d988 1
a988 2
			int index = 0;
			return SigDecoderWrapper(ref index, sig, false);
d993 5
d999 1
a999 1
			return SigDecoderWrapper(ref index, sig, true);
d1004 1
a1004 2
			int index = sig.IndexOf(')') + 1;
			return SigDecoderWrapper(ref index, sig, false);
d1009 5
d1015 1
a1015 1
			return SigDecoderWrapper(ref index, sig, true);
d1020 1
a1020 10
			if(sig[1] == ')')
			{
				return TypeWrapper.EmptyArray;
			}
			List<TypeWrapper> list = new List<TypeWrapper>();
			for(int i = 1; sig[i] != ')';)
			{
				list.Add(SigDecoderWrapper(ref i, sig, false));
			}
			return list.ToArray();
d1025 6
a1030 1
			if (sig[1] == ')')
d1035 1
a1035 1
			for (int i = 1; sig[i] != ')'; )
d1037 1
a1037 1
				list.Add(SigDecoderWrapper(ref i, sig, true));
a1484 58
		internal static TypeWrapper LoadClassNoThrow(ClassLoaderWrapper classLoader, string name, bool issueWarning)
		{
			try
			{
				TypeWrapper wrapper = classLoader.LoadClassByDottedNameFast(name);
				if (wrapper == null)
				{
					string elementTypeName = name;
					if (elementTypeName.StartsWith("["))
					{
						int skip = 1;
						while (elementTypeName[skip++] == '[') ;
						elementTypeName = elementTypeName.Substring(skip, elementTypeName.Length - skip - 1);
					}
#if STATIC_COMPILER
					if (issueWarning || classLoader.WarningLevelHigh)
					{
						classLoader.IssueMessage(Message.ClassNotFound, elementTypeName);
					}
#else
					Tracer.Error(Tracer.ClassLoading, "Class not found: {0}", elementTypeName);
#endif
					wrapper = new UnloadableTypeWrapper(name);
				}
				return wrapper;
			}
			catch (RetargetableJavaException x)
			{
				// HACK keep the compiler from warning about unused local
				GC.KeepAlive(x);
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
				if(x.ToJava() is java.lang.ThreadDeath)
				{
					throw x.ToJava();
				}
				if(Tracer.ClassLoading.TraceError)
				{
					java.lang.ClassLoader cl = classLoader.GetJavaClassLoader();
					if(cl != null)
					{
						System.Text.StringBuilder sb = new System.Text.StringBuilder();
						string sep = "";
						while(cl != null)
						{
							sb.Append(sep).Append(cl);
							sep = " -> ";
							cl = cl.getParent();
						}
						Tracer.Error(Tracer.ClassLoading, "ClassLoader chain: {0}", sb);
					}
					Exception m = ikvm.runtime.Util.mapException(x.ToJava());
					Tracer.Error(Tracer.ClassLoading, m.ToString() + Environment.NewLine + m.StackTrace);
				}
#endif // !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
				return new UnloadableTypeWrapper(name);
			}
		}

d1581 1
a1581 1
			TypeWrapper tw1 = FindOrLoadGenericClass(name, true);
@


1.232
log
@The message of a VM generated java.lang.NoClassDefFoundError exception should be the class name, not the message of the underlying exception.
@
text
@d575 1
a575 1
					type = type.GetClassLoader().CreateArrayType(name, type, dims);
d587 1
a587 1
					return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BYTE, dims);
d589 1
a589 1
					return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.CHAR, dims);
d591 1
a591 1
					return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.DOUBLE, dims);
d593 1
a593 1
					return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.FLOAT, dims);
d595 1
a595 1
					return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.INT, dims);
d597 1
a597 1
					return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.LONG, dims);
d599 1
a599 1
					return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.SHORT, dims);
d601 1
a601 1
					return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BOOLEAN, dims);
d814 1
a814 1
		private TypeWrapper CreateArrayType(string name, TypeWrapper elementTypeWrapper, int dims)
d819 1
a819 1
			return RegisterInitiatingLoader(new ArrayTypeWrapper(elementTypeWrapper, name));
@


1.231
log
@Fixed anonymous type lookup in CLASSGC mode.
@
text
@d797 1
a797 1
					throw new ClassLoadingException(ikvm.runtime.Util.mapException(x));
d803 1
a803 1
				throw new ClassLoadingException(ikvm.runtime.Util.mapException(x));
@


1.230
log
@Fixed CLASSGC build break.
@
text
@d1092 7
a1098 1
						return loader.typeToTypeWrapper[type];
@


1.229
log
@Remove AnonymousTypeWrapper from ikvmstub and ikvmc.
@
text
@d1087 1
a1087 1
				ClassLoaderWrapper loader;
@


1.228
log
@Added intrinsic for LambdaMetafactory.metafactory().
@
text
@d1096 1
a1114 1
#if !STATIC_COMPILER && !STUB_GENERATOR
@


1.227
log
@Fixed regression introduced by previous commit. We should not introduce SecurityException, because it conflicts with System.Security.SecurityException.
@
text
@d1096 18
@


1.226
log
@Bug fix. Only the bootstrap class loader is allowed to define classes in the java package.
@
text
@d360 1
a360 1
				throw new SecurityException("Prohibited package name: " + className.Substring(0, className.LastIndexOf('.')));
@


1.225
log
@Added (undocumented) -noparameterreflection option ikvmc to disable emitting method parameter reflection metadata, because we want to javac compile core class library with the -parameters option (to get the parameter names of native and abstract methods), but we don't want the reflection info (because the JDK doesn't include it either).
@
text
@d356 8
d391 1
@


1.224
log
@Added (undocumented) -w4 option to ikvmc to always warn about missing classes.
@
text
@d1498 5
@


1.223
log
@Allow classes defined by Unsafe.defineAnonymousClass() access to private methods of their host class.
@
text
@d1395 1
a1395 1
					if (issueWarning)
d1492 7
@


1.222
log
@Centralized switches to control C# interop workarounds.
@
text
@d62 1
a62 1
		internal abstract TypeWrapper DefineClassImpl(Dictionary<string, TypeWrapper> types, ClassFile f, ClassLoaderWrapper classLoader, ProtectionDomain protectionDomain);
d414 1
a414 1
				return GetTypeWrapperFactory().DefineClassImpl(types, f, this, protectionDomain);
@


1.221
log
@Added support for (implementation specific) LambdaForm annotations.
@
text
@d306 36
@


1.220
log
@Added a ClassFileParseOptions to enable trusted annotations to prepare for more of them.
@
text
@d1447 4
@


1.219
log
@Moved ClassFileParseOptions into ClassLoaderWrapper.
@
text
@d1432 4
@


1.218
log
@Don't issue "warning IKVMC0100: Class "{0}" not found" for types that are only used in signatures.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
d1420 28
@


1.217
log
@Removed unused method.
@
text
@d806 1
a806 1
			return nothrow ? LoadClassNoThrow(this, name) : LoadClassByDottedName(name);
d1344 1
a1344 1
		internal static TypeWrapper LoadClassNoThrow(ClassLoaderWrapper classLoader, string name)
d1359 4
a1362 1
					classLoader.IssueMessage(Message.ClassNotFound, elementTypeName);
@


1.216
log
@Introduced TypeWrapper.IsDynamic property.
@
text
@a787 9
		internal TypeWrapper ExpressionTypeWrapper(string type)
		{
			Debug.Assert(!type.StartsWith("Lret;"));
			Debug.Assert(type != "Lnull");

			int index = 0;
			return SigDecoderWrapper(ref index, type, false);
		}

@


1.215
log
@Only emit the non-virtual invocation delegate types when compiling with the -static option.
@
text
@d1508 1
a1508 1
				if (tw != null && !tw.IsArray && !(tw is DynamicTypeWrapper))
d1534 1
a1534 1
				if (tw != null && tw.GetClassLoader() == this && !tw.IsArray && !(tw is DynamicTypeWrapper))
@


1.214
log
@Added back support for JNI non-virtual method invocation for methods with more than 8 parameters.
@
text
@d55 1
d298 8
@


1.213
log
@Remove Assembly field from AssemblyClassLoader, instead associate the ikvm.runtime.AssemblyClassLoader with the runtime AssemblyClassLoader.
@
text
@d65 1
@


1.212
log
@Untangled generic class loader resource loading.
@
text
@d1141 1
a1141 1
		protected static void SetWrapperForClassLoader(java.lang.ClassLoader javaClassLoader, ClassLoaderWrapper wrapper)
@


1.211
log
@Stop abusing ikvm.runtime.AssemblyClassLoader as a class loader for generic types.
@
text
@d1483 50
@


1.210
log
@Replace CheckDefineClassAllowed() with a call to FindLoadedClassLazy().
@
text
@d81 1
a81 1
		private static List<GenericClassLoader> genericClassLoaders;
d1119 1
a1119 1
					genericClassLoaders = new List<GenericClassLoader>();
d1121 1
a1121 1
				foreach(GenericClassLoader loader in genericClassLoaders)
d1129 1
a1129 1
				GenericClassLoader newLoader = new GenericClassLoader(key, null);
d1131 2
a1132 2
				java.lang.ClassLoader javaClassLoader = (java.lang.ClassLoader)DoPrivileged(new AssemblyClassLoader.CreateAssemblyClassLoader(null));
				GenericClassLoader newLoader = new GenericClassLoader(key, javaClassLoader);
d1209 1
a1209 1
				return genericClassLoaders.IndexOf(wrapper as GenericClassLoader);
d1418 1
a1418 1
	sealed class GenericClassLoader : ClassLoaderWrapper
d1420 1
a1420 1
		private ClassLoaderWrapper[] delegates;
d1422 1
a1422 1
		internal GenericClassLoader(ClassLoaderWrapper[] delegates, object javaClassLoader)
d1444 1
a1444 1
		protected override TypeWrapper LoadClassImpl(string name, bool throwClassNotFoundException)
d1446 2
a1447 2
			TypeWrapper tw = FindOrLoadGenericClass(name, false);
			if(tw != null)
d1449 1
a1449 1
				return tw;
d1451 1
a1451 1
			foreach(ClassLoaderWrapper loader in delegates)
d1453 2
a1454 2
				tw = loader.LoadClassByDottedNameFast(name);
				if(tw != null)
d1469 1
a1469 1
				GenericClassLoader gcl = loader as GenericClassLoader;
@


1.209
log
@Changed AssemblyClassLoader.FindLoadedClassImpl() to return generic types.
@
text
@d184 6
a189 1
			return FindLoadedClassImpl(name);
d192 1
a192 1
		protected virtual TypeWrapper FindLoadedClassImpl(string name)
d194 1
a194 6
			lock(types)
			{
				TypeWrapper tw;
				types.TryGetValue(name, out tw);
				return tw;
			}
a309 5
		protected virtual void CheckDefineClassAllowed(string className)
		{
			// this hook exists so that AssemblyClassLoader can prevent DefineClass when the name is already present in the assembly
		}

d337 5
a341 1
			CheckDefineClassAllowed(f.Name);
@


1.208
log
@Removed the special casing of generic type definition loading as we've since exposed the generic type definitions to Java.
@
text
@d491 5
d518 1
a518 1
				TypeWrapper type = find ? FindLoadedClassImpl(elemClass) : LoadClassByDottedNameFast(elemClass);
d553 1
a553 1
		internal TypeWrapper LoadGenericClass(string name)
d559 1
a559 1
				TypeWrapper outer = LoadGenericClass(name.Substring(0, name.Length - DotNetTypeWrapper.DelegateInterfaceSuffix.Length));
d583 1
a583 1
			TypeWrapper def = LoadClassByDottedNameFast(name.Substring(0, pos));
d657 1
a657 1
						tw = LoadClassByDottedNameFast(s.Substring(dims + 1));
d717 1
a717 1
			TypeWrapper tw = LoadGenericClass(name);
d1447 1
a1447 1
			TypeWrapper tw = LoadGenericClass(name);
@


1.207
log
@Factored out some code.
@
text
@d578 2
a579 2
			Type type = GetGenericTypeDefinition(DotNetTypeWrapper.DemangleTypeName(name.Substring(0, pos)));
			if(type == null)
d583 1
a1079 5
		internal virtual Type GetGenericTypeDefinition(string name)
		{
			return null;
		}

a1439 13
		internal override Type GetGenericTypeDefinition(string name)
		{
			foreach(ClassLoaderWrapper loader in delegates)
			{
				Type t = loader.GetGenericTypeDefinition(name);
				if(t != null)
				{
					return t;
				}
			}
			return null;
		}

@


1.206
log
@FindLoadedClass should also return arrays.
@
text
@d446 1
a446 23
				TypeWrapper type;
				lock(types)
				{
					if(types.TryGetValue(name, out type) && type == null)
					{
						Thread defineThread;
						if(defineClassInProgress.TryGetValue(name, out defineThread))
						{
							if(Thread.CurrentThread == defineThread)
							{
								throw new ClassCircularityError(name);
							}
							// the requested class is currently being defined by another thread,
							// so we have to wait on that
							while(defineClassInProgress.ContainsKey(name))
							{
								Monitor.Wait(types);
							}
							// the defineClass may have failed, so we need to use TryGetValue
							types.TryGetValue(name, out type);
						}
					}
				}
d463 28
@


1.205
log
@Renamed ClassLoaderWrapper.GetLoadedClass() to FindLoadedClass().
@
text
@d178 10
a187 1
		internal virtual TypeWrapper FindLoadedClass(string name)
d475 1
a475 1
					return LoadArrayClass(name);
d485 1
a485 1
		private TypeWrapper LoadArrayClass(string name)
d507 1
a507 1
				TypeWrapper type = LoadClassByDottedNameFast(elemClass);
@


1.204
log
@Changed another object to java.lang.ClassLoader.
@
text
@d177 2
a178 2
		// and ClassLoader.findLoadedClass()
		internal virtual TypeWrapper GetLoadedClass(string name)
@


1.203
log
@Changed object to java.lang.ClassLoader in some signatures.
@
text
@d1113 4
a1116 4
				object javaClassLoader = null;
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
				javaClassLoader = DoPrivileged(new AssemblyClassLoader.CreateAssemblyClassLoader(null));
#endif
d1119 1
d1125 2
a1126 1
		protected static void SetWrapperForClassLoader(object javaClassLoader, ClassLoaderWrapper wrapper)
d1128 1
a1128 2
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
#if __MonoCS__
d1131 1
a1131 1
			((java.lang.ClassLoader)javaClassLoader).wrapper = wrapper;
d1133 1
a1134 1
		}
@


1.202
log
@Made some fields readonly.
@
text
@d921 1
a921 1
		internal static ClassLoaderWrapper GetClassLoaderWrapper(object javaClassLoader)
d937 1
a937 1
					((java.lang.ClassLoader)javaClassLoader).wrapper;
@


1.201
log
@Changed GetJavaClassLoader() to return java.lang.ClassLoader instead of object.
@
text
@d88 1
a88 1
		private Dictionary<string, TypeWrapper> types = new Dictionary<string, TypeWrapper>();
d91 1
a91 1
		private CodeGenOptions codegenoptions;
d96 1
a96 1
		private static Dictionary<Type, string> remappedTypes = new Dictionary<Type, string>();
@


1.200
log
@Added CodeGenOptions.DisableDynamicBinding to disable dynamic binding, instead of conditional compilation.
@
text
@d705 1
a705 1
				java.lang.Class c = ((java.lang.ClassLoader)GetJavaClassLoader()).loadClassInternal(name);
d747 2
a748 1
		internal virtual object GetJavaClassLoader()
d750 1
a750 1
#if FIRST_PASS || STATIC_COMPILER || STUB_GENERATOR
d756 1
d1361 1
a1361 1
					java.lang.ClassLoader cl = (java.lang.ClassLoader)classLoader.GetJavaClassLoader();
@


1.199
log
@Implemented package access checks (dynamic mode only).
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d54 1
d279 8
@


1.198
log
@Updated accessibility checks to handle the fact that we can now inject dynamic classes in all assemblies.
@
text
@d29 1
d33 1
d60 1
a60 1
		internal abstract TypeWrapper DefineClassImpl(Dictionary<string, TypeWrapper> types, ClassFile f, ClassLoaderWrapper classLoader, object protectionDomain);
d298 1
a298 1
		internal TypeWrapper DefineClass(ClassFile f, object protectionDomain)
d337 1
a337 1
		private TypeWrapper DefineClassCritical(ClassFile f, object protectionDomain)
d1379 10
@


1.197
log
@Moved (legacy) stub class parsing from the guts of the class loader to an explicit upfront step.
@
text
@d62 1
@


1.196
log
@Give the appropriate error messages if trying to extend or implement a missing type.
@
text
@d297 1
d320 1
d1121 1
a1170 3
#if STATIC_COMPILER || STUB_GENERATOR
			return AssemblyClassLoader.FromAssembly(StaticCompiler.Load(name));
#else
d1172 1
a1173 1
		}
@


1.195
log
@- Marked MemberWrapper class abstract.
- Marked all classes that don't (and shouldn't) have subclasses sealed.
@
text
@d955 6
@


1.194
log
@More ikvmc error handling clean up.
@
text
@d1372 1
a1372 1
	class GenericClassLoader : ClassLoaderWrapper
@


1.193
log
@Added support to ikvmc to automatically set the full source path in the debugging info if the source file lives next to the .class file.
@
text
@d135 3
d139 1
d1211 8
d1228 1
@


1.192
log
@Changed ikvmstub to use missing assemblies when a dependency is not found and only complain about it when it is actually needed.
@
text
@a284 8
		internal virtual string SourcePath
		{
			get
			{
				return null;
			}
		}

@


1.191
log
@Bug fix. The $Method inner class for delegates should also be loadable for generic delegates. Thanks to Michael Bayne for reporting this.
@
text
@d974 8
@


1.190
log
@Removed hack that fixed infinite recursion for generic types that use sub type as type parameter. Now that we lazily resolve the base TypeWrapper it is no longer needed.
@
text
@d525 16
@


1.189
log
@Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
@
text
@a1021 33
		private static ClassLoaderWrapper GetLoaderFromType(Type type)
		{
			Debug.Assert(!ReflectUtil.IsReflectionOnly(type));
			if(remappedTypes.ContainsKey(type))
			{
				return bootstrapClassLoader;
			}
			else if(ReflectUtil.IsVector(type))
			{
				// it might be an array of a dynamically compiled Java type
				int rank = 1;
				Type elem = type.GetElementType();
				while(ReflectUtil.IsVector(elem))
				{
					rank++;
					elem = elem.GetElementType();
				}
				return GetLoaderFromType(elem);
			}
			else
			{
				Assembly asm = type.Assembly;
#if CLASSGC
				ClassLoaderWrapper loader;
				if(dynamicAssemblies != null && dynamicAssemblies.TryGetValue(asm, out loader))
				{
					return loader;
				}
#endif
				return AssemblyClassLoader.FromAssembly(asm);
			}
		}

d1037 1
a1037 1
				ClassLoaderWrapper loader = GetLoaderFromType(arg);
@


1.188
log
@Removed class name length limitation.
@
text
@d1022 33
d1070 1
a1070 1
				ClassLoaderWrapper loader = GetWrapperFromType(arg).GetClassLoader();
@


1.187
log
@Removed circular dependency hack for delegate types that isn't required anymore with the new CreateStep2 compilation pass.
@
text
@a423 5
			// .NET 1.1 has a limit of 1024 characters for type names
			if(name.Length >= 1024 || name.Length == 0)
			{
				return null;
			}
@


1.186
log
@Make AllocMangledName register the wrapper directly, because there is no reason to do that later.
@
text
@a71 3
#if STATIC_COMPILER
		private TypeWrapper circularDependencyHack;
#endif
a292 26
#if STATIC_COMPILER
		internal TypeWrapper LoadCircularDependencyHack(TypeWrapper tw, string name)
		{
			if (circularDependencyHack == null)
			{
				circularDependencyHack = tw;
				try
				{
					return LoadClassByDottedNameFast(name);
				}
				finally
				{
					circularDependencyHack = null;
				}
			}
			else if (circularDependencyHack.Name == name)
			{
				return circularDependencyHack;
			}
			else
			{
				return LoadClassByDottedNameFast(name);
			}
		}
#endif

@


1.185
log
@Removed parameters from CreateStep1 and CreateStep2NoFail.
@
text
@d60 1
a60 1
		internal abstract string AllocMangledName(string typeName);
@


1.184
log
@Added -Xverify option to ikvm.exe.
@
text
@d60 1
@


1.183
log
@Relax class name validation for trusted class loaders.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2010 Jeroen Frijters
d281 1
a281 1
				return javaClassLoader == null || java.lang.ClassLoader.isTrustedLoader(javaClassLoader);
@


1.182
log
@Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
@
text
@d273 14
@


1.181
log
@Removed the need for access stubs in dynamic mode with CLASSGC enabled by dynamically adding InternalsVisibleToAttribute to the dynamic assemblies.
@
text
@d1355 3
a1357 3
			// only code that is compiled (by the static compiler) can generate warnings
			// (so that must mean an instance of CompilerClassLoader, which overrides this method.)
			throw new InvalidOperationException();
@


1.180
log
@Hardened runtime against asynchronous Thread.Abort() during critical operations. Fix for bug #3385353.
@
text
@d61 3
@


1.180.2.1
log
@Backported fixes:
- FileStore for non-accessible drive should throw exception when trying to create the FileStore, not when accessing the name() or type() properties.
- Graphics2D.clip(null) should only throw NPE for a Component graphics.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Handle Main-Class manifest value that spans multiple lines. Fix for bug #3461012.
- Informational messages should not be treated as error when -warnaserror is specified. Fix for #3443377.
- Don't enforce pre-1.5 class name rules in ikvmc (since HotSpot doesn't enforce any naming rules for classes loaded by the system (and boot) class loader, by default). Fix for #3443373.
- Fix for #3441959.
- Throwable.addSuppressed() didn't have a proper parameter name.
- mark getSpace0 with SecuritySafeCritical to avoid getting an exception with .NET 4
- Bug fix. Removed incorrect check for uninitialized objects on backward branch.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Added AssemblyInformationalVersionAttribute to OpenJDK assemblies (to set the "Product Version"). Part of patch #3458997.
- Include copyright and metadata in IKVM.OpenJDK.Tools.dll. Part of patch #3458997.
- Bug fix. Don't call Finish on unloadable TypeWrapper.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
- Suppress annotation custom attributes when enumerating inner classes.
- IKVM.Reflection: Bug fix. Fixed copy/paste error. FieldInfo.IsAssembly should test for FieldAttributes.Assembly access, not FieldAttributes.Family.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
a1037 33
		private static ClassLoaderWrapper GetLoaderFromType(Type type)
		{
			Debug.Assert(!ReflectUtil.IsReflectionOnly(type));
			if(remappedTypes.ContainsKey(type))
			{
				return bootstrapClassLoader;
			}
			else if(ReflectUtil.IsVector(type))
			{
				// it might be an array of a dynamically compiled Java type
				int rank = 1;
				Type elem = type.GetElementType();
				while(ReflectUtil.IsVector(elem))
				{
					rank++;
					elem = elem.GetElementType();
				}
				return GetLoaderFromType(elem);
			}
			else
			{
				Assembly asm = type.Assembly;
#if CLASSGC
				ClassLoaderWrapper loader;
				if(dynamicAssemblies != null && dynamicAssemblies.TryGetValue(asm, out loader))
				{
					return loader;
				}
#endif
				return AssemblyClassLoader.FromAssembly(asm);
			}
		}

d1053 1
a1053 1
				ClassLoaderWrapper loader = GetLoaderFromType(arg);
d1352 3
a1354 3
			// it's not ideal when we end up here (because it means we're emitting a warning that is not associated with a specific output target),
			// but it happens when we're decoding something in a referenced assembly that either doesn't make sense or contains an unloadable type
			StaticCompiler.IssueMessage(msgId, values);
@


1.179
log
@Fix for NPE if type parameter type cannot be loaded.
@
text
@d152 1
d165 1
d185 13
d335 14
d385 1
a385 1
					if(factory == null)
d387 6
d394 8
a401 8
						if(dynamicAssemblies == null)
						{
							Interlocked.CompareExchange(ref dynamicAssemblies, new ConditionalWeakTable<Assembly, ClassLoaderWrapper>(), null);
						}
						typeToTypeWrapper = new Dictionary<Type, TypeWrapper>();
						DynamicClassLoader instance = DynamicClassLoader.Get(this);
						dynamicAssemblies.Add(instance.ModuleBuilder.Assembly.ManifestModule.Assembly, this);
						this.factory = instance;
d403 1
a403 1
						factory = DynamicClassLoader.Get(this);
d405 1
d1026 8
a1033 1
				globalTypeToTypeWrapper[type] = wrapper;
d1194 8
a1201 1
				dict.Add(type, wrapper);
d1222 1
a1222 1
				if(nativeLibraries == null)
d1224 9
a1232 1
					nativeLibraries = new List<IntPtr>();
a1233 1
				nativeLibraries.Add(p);
d1241 8
a1248 1
				nativeLibraries.Remove(p);
d1322 4
@


1.179.2.1
log
@Backport: Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
@
text
@d1284 3
a1286 3
			// it's not ideal when we end up here (because it means we're emitting a warning that is not associated with a specific output target),
			// but it happens when we're decoding something in a referenced assembly that either doesn't make sense or contains an unloadable type
			StaticCompiler.IssueMessage(msgId, values);
@


1.179.2.2
log
@Backported fixes for 0.46.0.3:
- Bug fix. java.lang.Package was not populated from manifest for ikvmc compiled assemblies.
- Bug fix. When writing a direct ByteBuffer to a non-blocking socket and the write fails because there is no kernel buffer available, we should not advance the ByteBuffer position.
- Bug fix. When adding certificates to virtual cacerts file make sure that the aliases are unique.
- Bug fix. If a finally/fault handler contains reachable code before the handler's start index, the handler should branch to the handler start index.
- Bug fix. After emitting a finally/fault handler block, we should emit the block leave stubs (even though you can't leave the block, they also emit the backward branch stubs).
- Bug fix. If a Java class extends a remapped .NET type (cli.System.Object or cli.System.Exception), we should correctly report the base class.
- Bug fix. If we encounter a jsr or ret instruction, we should throw a VerifyError (instead of NotImplementedException).
- Bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
- Disable AppDomain.ProcessExit hook to run shutdown hooks when running on Mono to workaround https://bugzilla.xamarin.com/show_bug.cgi?id=5650
- Bug fix. Custom attribute properties that don't have a public getter and setter should not be exposed as annotation properties.
- Bug fix. Non-public property getter/setter methods should be ignored when we create properties to hide properties inherited from shadow types. This fixes a build break with .NET 4.5 beta which introduces a protected setter for Exception.HResult.
- Bug fix. The $Method inner class for delegates should also be loadable for generic delegates. Thanks to Michael Bayne for reporting this.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Replaced non-ascii character (micro) with ascii 'u' in Win32PrintService.java.
- IKVM.Reflection: Bug fix. Resource Directory Entries must be sorted and names are case-insensitive

Backported for 0.46.0.4:
- Fixed ikvmc to retain transient modifier on constant static final fields.
- Fixed Field.getModifiers() to only return the relevant modifiers.
- Fixed IKVM.Reflection to set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@a504 16
			// we need to handle delegate methods here (for generic delegates)
			// (note that other types with manufactured inner classes such as Attribute and Enum can't be generic)
			if (name.EndsWith(DotNetTypeWrapper.DelegateInterfaceSuffix))
			{
				TypeWrapper outer = LoadGenericClass(name.Substring(0, name.Length - DotNetTypeWrapper.DelegateInterfaceSuffix.Length));
				if (outer != null && outer.IsFakeTypeContainer)
				{
					foreach (TypeWrapper tw in outer.InnerClasses)
					{
						if (tw.Name == name)
						{
							return tw;
						}
					}
				}
			}
a994 33
		private static ClassLoaderWrapper GetLoaderFromType(Type type)
		{
			Debug.Assert(!ReflectUtil.IsReflectionOnly(type));
			if(remappedTypes.ContainsKey(type))
			{
				return bootstrapClassLoader;
			}
			else if(ReflectUtil.IsVector(type))
			{
				// it might be an array of a dynamically compiled Java type
				int rank = 1;
				Type elem = type.GetElementType();
				while(ReflectUtil.IsVector(elem))
				{
					rank++;
					elem = elem.GetElementType();
				}
				return GetLoaderFromType(elem);
			}
			else
			{
				Assembly asm = type.Assembly;
#if CLASSGC
				ClassLoaderWrapper loader;
				if(dynamicAssemblies != null && dynamicAssemblies.TryGetValue(asm, out loader))
				{
					return loader;
				}
#endif
				return AssemblyClassLoader.FromAssembly(asm);
			}
		}

d1010 1
a1010 1
				ClassLoaderWrapper loader = GetLoaderFromType(arg);
@


1.178
log
@Ignore LoadRemappedTypes() if it is called redundantly.
@
text
@d586 1
a586 1
				TypeWrapper tw = null;
d591 4
d621 2
a622 4
				}
				if(tw == null)
				{
					return null;
@


1.177
log
@Made FromCallerID method signature typed.
@
text
@d122 1
a122 1
			if(coreAssembly != null)
@


1.176
log
@Made assembly class loader construction lazy.
@
text
@d1217 2
a1218 1
		internal static ClassLoaderWrapper FromCallerID(object callerID)
d1223 1
a1223 1
			return GetClassLoaderWrapper(((ikvm.@@internal.CallerID)callerID).getCallerClassLoader());
@


1.175
log
@Removed trace messages that don't add much value but do cause the tracer to needlessly read configuration data early in initialization.
@
text
@d657 1
a657 1
				java.lang.Class c = javaClassLoader.loadClassInternal(name);
d699 1
a699 1
		internal object GetJavaClassLoader()
d1201 1
@


1.174
log
@Changed workaround for gmcs inability to properly deal with two-pass compilation of mutually dependant assemblies to use reflection, because the previous workaround now also fails on Mono 2.8.
@
text
@a123 7
				try
				{
					Tracer.Info(Tracer.Runtime, "Core assembly: {0}", coreAssembly.Location);
				}
				catch(System.Security.SecurityException)
				{
				}
a128 1
						Tracer.Info(Tracer.Runtime, "Remapping type {0} to {1}", r.RemappedType, r.Name);
@


1.173
log
@Made most static compiler warnings local to the target that is being compiled (in multi target mode), to allow warnings to be suppressed (or turned into an error) for a specific target.
@
text
@a1060 8
#if !STATIC_COMPILER && !STUB_GENERATOR && __MonoCS__
		// MONOBUG this weird hack is to work around an mcs bug
		private static void SetClassLoadWrapperHack<T>(ref T field, ClassLoaderWrapper wrapper)
		{
			field = (T)(object)wrapper;
		}
#endif

d1065 1
a1065 1
			SetClassLoadWrapperHack(ref ((java.lang.ClassLoader)javaClassLoader).wrapper, wrapper);
@


1.172
log
@Disable automagic serialization when running on .NET 4.0 in partial trust.
@
text
@d1249 12
a1260 1
					Tracer.Error(Tracer.ClassLoading, "Class not found: {0}", name);
d1292 9
@


1.172.2.1
log
@Backported Mono 2.8 mcs build workarounds.
@
text
@d1061 8
d1073 1
a1073 1
			typeof(java.lang.ClassLoader).GetField("wrapper", BindingFlags.NonPublic | BindingFlags.Instance).SetValue(javaClassLoader, wrapper);
@


1.171
log
@TypeWrapper.AssertFinished() doesn't make sense for the static compiler anymore.
@
text
@d904 6
@


1.170
log
@Allow ikvmstub to explicitly set the bootstrap class loader.
@
text
@d924 1
d926 1
d1148 1
d1150 1
@


1.169
log
@It's not necessary to add the bootstrap class loader to the generic class loader key.
@
text
@d69 3
a72 1
		private TypeWrapper circularDependencyHack;
d93 1
a93 1
#if STATIC_COMPILER
d95 1
a95 1
		// when we're compiling the core class libraries
d862 1
a862 1
#if STATIC_COMPILER
@


1.168
log
@Removed .NET 1.1 restriction workaround.
@
text
@d1007 1
a1007 1
				if(!list.Contains(loader))
@


1.167
log
@Added ikvmc option to disable automagic serialization.
@
text
@a696 2
		// NOTE this method can actually return null if the resulting array type name would be too long
		// for .NET to handle.
a701 6
			Type elementType = elementTypeWrapper.TypeAsArrayType;
			// .NET 1.1 has a limit of 1024 characters for type names
			if(elementType.FullName.Length >= 1024 - dims * 2)
			{
				return null;
			}
@


1.166
log
@Removed workaround that is no longer needed.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
d51 1
d253 8
@


1.165
log
@Removed ReflectionOnly support from runtime. Now that ikvmstub no longer requires it, there's no good reason to allow Java code to see ReflectionOnly types.
@
text
@a664 15
#if CLASSGC
				// FXBUG because the AppDomain.TypeResolve event still doesn't work across assemblies
				// (at least as of .NET 4.0 beta 1), we eagerly finish types loaded by another class loader
				if(type.GetClassLoader() != this)
				{
					try
					{
						type.Finish();
					}
					catch(RetargetableJavaException x)
					{
						throw x.ToJava();
					}
				}
#endif
@


1.164
log
@- Moved ClassLoaderWrapper.IsVector() and TypeWrapper.IsReflectionOnly() to ReflectUtil.
- Fixed IsReflectionOnly() to handle more complicated constructed types.
- Optimized IsDynamic() to use a delegate to call get_IsDynamic when running on .NET 4.0
- Optimized IsVector() to use __IsVector when IKVM.Reflection is used.
@
text
@d978 7
@


1.163
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@d953 1
a953 1
			else if(IsVector(type))
d958 1
a958 1
				while(IsVector(elem))
a997 8
		internal static bool IsVector(Type type)
		{
			// NOTE it looks like there's no API to distinguish an array of rank 1 from a vector,
			// so we check if the type name ends in [], which indicates it's a vector
			// (non-vectors will have [*] or [,]).
			return type.IsArray && type.Name.EndsWith("[]");
		}

@


1.162
log
@Last set of changes preparing for new stub generator. A massive amount of conditional compilation changes, to skip irrelevant code when building ikvmstub.
@
text
@d25 1
a25 1
#if IKVM_REF_EMIT
@


1.161
log
@Moved non-throwing signature parsing from ClassFile.cs to ClassLoaderWrapper.cs (and merged it with the throwing variant). This avoids new stub generator having to include ClassFile.cs.
@
text
@d53 1
d61 1
d74 1
a74 1
#if !STATIC_COMPILER && !FIRST_PASS
d77 1
d79 1
d147 1
a147 1
#if !STATIC_COMPILER && !FIRST_PASS
d291 1
d372 1
d650 1
a650 1
#if !STATIC_COMPILER && !FIRST_PASS
d721 1
a721 1
#if FIRST_PASS || STATIC_COMPILER
d890 1
a890 1
#if !STATIC_COMPILER
d1033 1
a1033 1
#if !STATIC_COMPILER && !FIRST_PASS
d1056 1
a1056 1
#if !STATIC_COMPILER && !FIRST_PASS
d1066 1
a1066 1
#if !STATIC_COMPILER && __MonoCS__
d1076 1
a1076 1
#if !STATIC_COMPILER && !FIRST_PASS
d1134 1
a1134 1
#if STATIC_COMPILER
d1217 1
a1217 1
#if !STATIC_COMPILER && !FIRST_PASS
d1234 1
a1234 1
#if !STATIC_COMPILER
@


1.160
log
@Moved CodeGenOptions from DynamicClassLoader.cs to ClassLoaderWrapper.cs, to avoid new stub generator (to be checked in later) to have to include DynamicClassLoader.cs
@
text
@d728 1
a728 1
			return SigDecoderWrapper(ref index, type);
d747 5
d753 1
a753 1
		private TypeWrapper SigDecoderWrapper(ref int index, string sig)
d773 1
a773 1
					return LoadClassByDottedName(sig.Substring(pos, index - pos - 1));
d796 1
a796 1
							return LoadClassByDottedName(array + sig.Substring(pos, index - pos));
d806 1
a806 1
							return LoadClassByDottedName(array + sig[index++]);
d819 7
a825 1
			return SigDecoderWrapper(ref index, sig);
d831 7
a837 1
			return SigDecoderWrapper(ref index, sig);
d849 15
a863 1
				list.Add(SigDecoderWrapper(ref i, sig));
d1238 40
@


1.159
log
@Integrated new IKVM.Reflection implementation.
@
text
@d42 11
@


1.158
log
@Changed JNI to use standard caller ID mechanism.
@
text
@a24 1
using System.Reflection;
d26 1
d28 1
d30 1
@


1.157
log
@More ikvmc assembly/type refactoring.
@
text
@d1183 11
@


1.156
log
@Removed .NET 4.0 beta 1 workarounds and did some minor updates for .NET 4.0 beta 2.
@
text
@d1085 1
a1085 1
			return AssemblyClassLoader.FromAssembly(Assembly.ReflectionOnlyLoad(name));
@


1.155
log
@Rewrote custom assembly class loader initialization to avoid running user code (static initializer) while holding a lock and to better handle invocation of getClassLoader() during the class loader constructor (or static initializer).
@
text
@d934 1
a934 1
			if(type.Assembly.IsDynamic())
@


1.155.2.1
log
@Update for .NET 4.0 beta 2.
@
text
@d934 1
a934 1
			if(type.Assembly.IsDynamic)
@


1.154
log
@Moved GetAssemblyClassLoader() (and related stuff) from ClassLoaderWrapper to AssemblyClassLoader and renamed it to FromAssembly().
@
text
@d50 1
a50 1
		protected static readonly object wrapperLock = new object();
d60 1
a60 1
		private readonly java.lang.ClassLoader javaClassLoader;
@


1.153
log
@Moved AssemblyClassLoader and BootstrapClassLoader into AssemblyClassLoader.cs.
@
text
@d50 1
a50 1
		private static readonly object wrapperLock = new object();
a57 1
		private static readonly Dictionary<Assembly, AssemblyClassLoader> assemblyClassLoaders = new Dictionary<Assembly, AssemblyClassLoader>();
a60 2
		private static bool customClassLoaderRedirectsLoaded;
		private static Dictionary<string, string> customClassLoaderRedirects;
d931 1
a931 1
				wrapper = GetAssemblyClassLoader(asm).GetWrapperFromAssemblyType(type);
d968 1
a968 1
			list.Add(GetAssemblyClassLoader(type.Assembly));
d1007 1
a1007 1
				javaClassLoader = DoPrivileged(new CreateAssemblyClassLoader(null));
d1024 1
a1024 1
		private static void SetWrapperForClassLoader(object javaClassLoader, ClassLoaderWrapper wrapper)
d1085 1
a1085 1
			return ClassLoaderWrapper.GetAssemblyClassLoader(Assembly.ReflectionOnlyLoad(name));
d1087 1
a1087 1
			return ClassLoaderWrapper.GetAssemblyClassLoader(Assembly.Load(name));
a1106 211
		// this method only supports .NET or pre-compiled Java assemblies
		internal static AssemblyClassLoader GetAssemblyClassLoader(Assembly assembly)
		{
#if !IKVM_REF_EMIT
			Debug.Assert(!(assembly is AssemblyBuilder));
#endif // !IKVM_REF_EMIT

			ConstructorInfo customClassLoaderCtor = null;
			AssemblyClassLoader loader;
			object javaClassLoader = null;
			lock(wrapperLock)
			{
				if(!assemblyClassLoaders.TryGetValue(assembly, out loader))
				{
					// If the assembly is a part of a multi-assembly shared class loader,
					// it will export the __<MainAssembly> type from the main assembly in the group.
					Type forwarder = assembly.GetType("__<MainAssembly>");
					if(forwarder != null)
					{
						Assembly mainAssembly = forwarder.Assembly;
						if(mainAssembly != assembly)
						{
							loader = GetAssemblyClassLoader(mainAssembly);
							assemblyClassLoaders[assembly] = loader;
							return loader;
						}
					}
					if(assembly == JVM.CoreAssembly)
					{
						// This cast is necessary for ikvmc and a no-op for the runtime.
						// Note that the cast cannot fail, because ikvmc will only return a non AssemblyClassLoader
						// from GetBootstrapClassLoader() when compiling the core assembly and in that case JVM.CoreAssembly
						// will be null.
						return (AssemblyClassLoader)GetBootstrapClassLoader();
					}
#if !STATIC_COMPILER && !FIRST_PASS
					if(!assembly.ReflectionOnly)
					{
						Type customClassLoaderClass = null;
						LoadCustomClassLoaderRedirects();
						if(customClassLoaderRedirects != null)
						{
							string assemblyName = assembly.FullName;
							foreach(KeyValuePair<string, string> kv in customClassLoaderRedirects)
							{
								string asm = kv.Key;
								// we only support matching on the assembly's simple name,
								// because there appears to be no viable alternative.
								// On .NET 2.0 there is AssemblyName.ReferenceMatchesDefinition()
								// but it is broken (and .NET 2.0 specific).
								if(assemblyName.StartsWith(asm + ","))
								{
									try
									{
										customClassLoaderClass = Type.GetType(kv.Value, true);
									}
									catch(Exception x)
									{
										Tracer.Error(Tracer.Runtime, "Unable to load custom class loader {0} specified in app.config for assembly {1}: {2}", kv.Value, assembly, x);
									}
									break;
								}
							}
						}
						if(customClassLoaderClass == null)
						{
							object[] attribs = assembly.GetCustomAttributes(typeof(CustomAssemblyClassLoaderAttribute), false);
							if(attribs.Length == 1)
							{
								customClassLoaderClass = ((CustomAssemblyClassLoaderAttribute)attribs[0]).Type;
							}
						}
						if(customClassLoaderClass != null)
						{
							try
							{
								if(!customClassLoaderClass.IsPublic && !customClassLoaderClass.Assembly.Equals(assembly))
								{
									throw new Exception("Type not accessible");
								}
								// NOTE we're creating an uninitialized instance of the custom class loader here, so that getClassLoader will return the proper object
								// when it is called during the construction of the custom class loader later on. This still doesn't make it safe to use the custom
								// class loader before it is constructed, but at least the object instance is valid and should anyone cache it, they will get the
								// right object to use later on.
								// Note also that we're not running the constructor here, because we don't want to run user code while holding a global lock.
								javaClassLoader = (java.lang.ClassLoader)CreateUnitializedCustomClassLoader(customClassLoaderClass);
								customClassLoaderCtor = customClassLoaderClass.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { typeof(Assembly) }, null);
								if(customClassLoaderCtor == null)
								{
									javaClassLoader = null;
									throw new Exception("No constructor");
								}
								if(!customClassLoaderCtor.IsPublic && !customClassLoaderClass.Assembly.Equals(assembly))
								{
									javaClassLoader = null;
									throw new Exception("Constructor not accessible");
								}
								Tracer.Info(Tracer.Runtime, "Created custom assembly class loader {0} for assembly {1}", customClassLoaderClass.FullName, assembly);
							}
							catch(Exception x)
							{
								Tracer.Error(Tracer.Runtime, "Unable to create custom assembly class loader {0} for {1}: {2}", customClassLoaderClass.FullName, assembly, x);
							}
						}
					}
					if(javaClassLoader == null)
					{
						javaClassLoader = DoPrivileged(new CreateAssemblyClassLoader(assembly));
					}
#endif
					loader = new AssemblyClassLoader(assembly, javaClassLoader, customClassLoaderCtor != null);
					assemblyClassLoaders[assembly] = loader;
#if !STATIC_COMPILER
					if(customClassLoaderCtor != null)
					{
						loader.SetInitInProgress();
					}
					if(javaClassLoader != null)
					{
						SetWrapperForClassLoader(javaClassLoader, loader);
					}
#endif
				}
			}
#if !STATIC_COMPILER && !FIRST_PASS
			if(customClassLoaderCtor != null)
			{
				try
				{
					DoPrivileged(new CustomClassLoaderCtorCaller(customClassLoaderCtor, javaClassLoader, assembly));
				}
				finally
				{
					loader.SetInitDone();
				}
			}
			loader.WaitInitDone();
#endif
			return loader;
		}

#if !STATIC_COMPILER && !FIRST_PASS
		private static object CreateUnitializedCustomClassLoader(Type customClassLoaderClass)
		{
			return System.Runtime.Serialization.FormatterServices.GetUninitializedObject(customClassLoaderClass);
		}

		private static void LoadCustomClassLoaderRedirects()
		{
			// this method assumes that we hold a global lock
			if(!customClassLoaderRedirectsLoaded)
			{
				customClassLoaderRedirectsLoaded = true;
				try
				{
					foreach(string key in System.Configuration.ConfigurationManager.AppSettings.AllKeys)
					{
						const string prefix = "ikvm-classloader:";
						if(key.StartsWith(prefix))
						{
							if(customClassLoaderRedirects == null)
							{
								customClassLoaderRedirects = new Dictionary<string, string>();
							}
							customClassLoaderRedirects[key.Substring(prefix.Length)] = System.Configuration.ConfigurationManager.AppSettings.Get(key);
						}
					}
				}
				catch(Exception x)
				{
					Tracer.Error(Tracer.Runtime, "Error while reading custom class loader redirects: {0}", x);
				}
			}
		}

		sealed class CreateAssemblyClassLoader : java.security.PrivilegedAction
		{
			private Assembly assembly;

			internal CreateAssemblyClassLoader(Assembly assembly)
			{
				this.assembly = assembly;
			}

			public object run()
			{
				return new ikvm.runtime.AssemblyClassLoader(assembly);
			}
		}

		sealed class CustomClassLoaderCtorCaller : java.security.PrivilegedAction
		{
			private ConstructorInfo ctor;
			private object classLoader;
			private Assembly assembly;

			internal CustomClassLoaderCtorCaller(ConstructorInfo ctor, object classLoader, Assembly assembly)
			{
				this.ctor = ctor;
				this.classLoader = classLoader;
				this.assembly = assembly;
			}

			public object run()
			{
				ctor.Invoke(classLoader, new object[] { assembly });
				return null;
			}
		}
#endif

@


1.152
log
@Removed vestigial compact framework support.
@
text
@a1477 853

	class AssemblyClassLoader : ClassLoaderWrapper
	{
		private AssemblyLoader assemblyLoader;
		private string[] references;
		private AssemblyClassLoader[] delegates;
		private bool isReflectionOnly;
#if !STATIC_COMPILER
		private Thread initializerThread;
		private volatile object protectionDomain;
#endif
		private bool hasCustomClassLoader;
		private Dictionary<int, List<int>> exports;
		private string[] exportedAssemblyNames;
		private AssemblyLoader[] exportedAssemblies;
		private Dictionary<Assembly, AssemblyLoader> exportedLoaders;

		private sealed class AssemblyLoader
		{
			private readonly Assembly assembly;
			private bool[] isJavaModule;
			private Module[] modules;
			private Dictionary<string, string> nameMap;
			private bool hasDotNetModule;
			private AssemblyName[] internalsVisibleTo;

			internal AssemblyLoader(Assembly assembly)
			{
				this.assembly = assembly;
				modules = assembly.GetModules(false);
				isJavaModule = new bool[modules.Length];
				for (int i = 0; i < modules.Length; i++)
				{
					object[] attr;
					try
					{
						attr = AttributeHelper.GetJavaModuleAttributes(modules[i]);
					}
					catch (Exception x)
					{
						// HACK we handle exceptions here, because there is at least one obfuscator that produces
						// invalid assemblies that cause Module.GetCustomAttributes() to throw an exception
						JVM.CriticalFailure("Unexpected exception", x);
						throw null;
					}
					if (attr.Length > 0)
					{
						isJavaModule[i] = true;
						foreach (JavaModuleAttribute jma in attr)
						{
							string[] map = jma.GetClassMap();
							if (map != null)
							{
								if (nameMap == null)
								{
									nameMap = new Dictionary<string, string>();
								}
								for (int j = 0; j < map.Length; j += 2)
								{
									string key = map[j];
									string val = map[j + 1];
									// TODO if there is a name clash between modules, this will throw.
									// Figure out how to handle that.
									nameMap.Add(key, val);
								}
							}
						}
					}
					else
					{
						hasDotNetModule = true;
					}
				}
			}

			internal bool HasJavaModule
			{
				get
				{
					for (int i = 0; i < isJavaModule.Length; i++)
					{
						if (isJavaModule[i])
						{
							return true;
						}
					}
					return false;
				}
			}

			internal Assembly Assembly
			{
				get { return assembly; }
			}

			private Type GetType(string name)
			{
				try
				{
					return assembly.GetType(name);
				}
				catch (FileLoadException x)
				{
					// this can only happen if the assembly was loaded in the ReflectionOnly
					// context and the requested type references a type in another assembly
					// that cannot be found in the ReflectionOnly context
					// TODO figure out what other exceptions Assembly.GetType() can throw
					Tracer.Info(Tracer.Runtime, x.Message);
				}
				return null;
			}

			private Type GetType(Module mod, string name)
			{
				try
				{
					return mod.GetType(name);
				}
				catch (FileLoadException x)
				{
					// this can only happen if the assembly was loaded in the ReflectionOnly
					// context and the requested type references a type in another assembly
					// that cannot be found in the ReflectionOnly context
					// TODO figure out what other exceptions Assembly.GetType() can throw
					Tracer.Info(Tracer.Runtime, x.Message);
				}
				return null;
			}

			private Type GetJavaType(Module mod, string name)
			{
				try
				{
					string n = null;
					if (nameMap != null)
					{
						nameMap.TryGetValue(name, out n);
					}
					Type t = GetType(mod, n != null ? n : name);
					if (t == null)
					{
						n = name.Replace('$', '+');
						if (!ReferenceEquals(n, name))
						{
							t = GetType(n);
						}
					}
					if (t != null
						&& !AttributeHelper.IsHideFromJava(t)
						&& !t.IsArray
						&& !t.IsPointer
						&& !t.IsByRef)
					{
						return t;
					}
				}
				catch (ArgumentException x)
				{
					// we can end up here because we replace the $ with a plus sign
					// (or client code did a Class.forName() on an invalid name)
					Tracer.Info(Tracer.Runtime, x.Message);
				}
				return null;
			}

			internal TypeWrapper DoLoad(string name)
			{
				for (int i = 0; i < modules.Length; i++)
				{
					if (isJavaModule[i])
					{
						Type type = GetJavaType(modules[i], name);
						if (type != null)
						{
							// check the name to make sure that the canonical name was used
							if (CompiledTypeWrapper.GetName(type) == name)
							{
								return CompiledTypeWrapper.newInstance(name, type);
							}
						}
					}
					else
					{
						// TODO should we catch ArgumentException and prohibit array, pointer and byref here?
						Type type = GetType(modules[i], DotNetTypeWrapper.DemangleTypeName(name));
						if (type != null && DotNetTypeWrapper.IsAllowedOutside(type))
						{
							// check the name to make sure that the canonical name was used
							if (DotNetTypeWrapper.GetName(type) == name)
							{
								return DotNetTypeWrapper.Create(type, name);
							}
						}
					}
				}
				if (hasDotNetModule)
				{
					// for fake types, we load the declaring outer type (the real one) and
					// let that generated the manufactured nested classes
					TypeWrapper outer = null;
					if (name.EndsWith(DotNetTypeWrapper.DelegateInterfaceSuffix))
					{
						outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.DelegateInterfaceSuffix.Length));
					}
					else if (name.EndsWith(DotNetTypeWrapper.AttributeAnnotationSuffix))
					{
						outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationSuffix.Length));
					}
					else if (name.EndsWith(DotNetTypeWrapper.AttributeAnnotationReturnValueSuffix))
					{
						outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationReturnValueSuffix.Length));
					}
					else if (name.EndsWith(DotNetTypeWrapper.AttributeAnnotationMultipleSuffix))
					{
						outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationMultipleSuffix.Length));
					}
					else if (name.EndsWith(DotNetTypeWrapper.EnumEnumSuffix))
					{
						outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.EnumEnumSuffix.Length));
					}
					if (outer != null && outer.IsFakeTypeContainer)
					{
						foreach (TypeWrapper tw in outer.InnerClasses)
						{
							if (tw.Name == name)
							{
								return tw;
							}
						}
					}
				}
				return null;
			}

			internal TypeWrapper CreateWrapperForAssemblyType(Type type)
			{
				Module mod = type.Module;
				int moduleIndex = -1;
				for (int i = 0; i < modules.Length; i++)
				{
					if (modules[i] == mod)
					{
						moduleIndex = i;
						break;
					}
				}
				string name;
				if (isJavaModule[moduleIndex])
				{
					name = CompiledTypeWrapper.GetName(type);
				}
				else
				{
					name = DotNetTypeWrapper.GetName(type);
					if (name == null)
					{
						return null;
					}
				}
				if (isJavaModule[moduleIndex])
				{
					if (AttributeHelper.IsHideFromJava(type))
					{
						return null;
					}
					// since this type was compiled from Java source, we have to look for our
					// attributes
					return CompiledTypeWrapper.newInstance(name, type);
				}
				else
				{
					if (!DotNetTypeWrapper.IsAllowedOutside(type))
					{
						return null;
					}
					// since this type was not compiled from Java source, we don't need to
					// look for our attributes, but we do need to filter unrepresentable
					// stuff (and transform some other stuff)
					return DotNetTypeWrapper.Create(type, name);
				}
			}

			internal bool InternalsVisibleTo(AssemblyName otherName)
			{
				if (internalsVisibleTo == null)
				{
					internalsVisibleTo = AttributeHelper.GetInternalsVisibleToAttributes(assembly);
				}
				foreach (AssemblyName name in internalsVisibleTo)
				{
					if (AssemblyName.ReferenceMatchesDefinition(name, otherName))
					{
						return true;
					}
				}
				return false;
			}
		}

		internal AssemblyClassLoader(Assembly assembly, object javaClassLoader, bool hasCustomClassLoader)
			: this(assembly, null, javaClassLoader, hasCustomClassLoader)
		{
		}

		internal AssemblyClassLoader(Assembly assembly, string[] fixedReferences, object javaClassLoader, bool hasCustomClassLoader)
			: base(CodeGenOptions.None, javaClassLoader)
		{
			this.assemblyLoader = new AssemblyLoader(assembly);
			this.references = fixedReferences;
			this.isReflectionOnly = assembly.ReflectionOnly;
			this.hasCustomClassLoader = hasCustomClassLoader;
		}

		private void DoInitializeExports()
		{
			lock (this)
			{
				if (delegates == null)
				{
					if (!(ReflectUtil.IsDynamicAssembly(assemblyLoader.Assembly)) && assemblyLoader.Assembly.GetManifestResourceInfo("ikvm.exports") != null)
					{
						List<string> wildcardExports = new List<string>();
						using (Stream stream = assemblyLoader.Assembly.GetManifestResourceStream("ikvm.exports"))
						{
							BinaryReader rdr = new BinaryReader(stream);
							int assemblyCount = rdr.ReadInt32();
							exports = new Dictionary<int, List<int>>();
							exportedAssemblies = new AssemblyLoader[assemblyCount];
							exportedAssemblyNames = new string[assemblyCount];
							exportedLoaders = new Dictionary<Assembly, AssemblyLoader>();
							for (int i = 0; i < assemblyCount; i++)
							{
								exportedAssemblyNames[i] = rdr.ReadString();
								int typeCount = rdr.ReadInt32();
								if (typeCount == 0 && references == null)
								{
									wildcardExports.Add(exportedAssemblyNames[i]);
								}
								for (int j = 0; j < typeCount; j++)
								{
									int hash = rdr.ReadInt32();
									List<int> assemblies;
									if (!exports.TryGetValue(hash, out assemblies))
									{
										assemblies = new List<int>();
										exports.Add(hash, assemblies);
									}
									assemblies.Add(i);
								}
							}
						}
						if (references == null)
						{
							references = wildcardExports.ToArray();
						}
					}
					else
					{
						AssemblyName[] refNames = assemblyLoader.Assembly.GetReferencedAssemblies();
						references = new string[refNames.Length];
						for (int i = 0; i < references.Length; i++)
						{
							references[i] = refNames[i].FullName;
						}
					}
					delegates = new AssemblyClassLoader[references.Length];
				}
			}
		}

		private void LazyInitExports()
		{
			if (delegates == null)
			{
				DoInitializeExports();
			}
		}

		internal Assembly MainAssembly
		{
			get
			{
				return assemblyLoader.Assembly;
			}
		}

		internal Assembly GetAssembly(TypeWrapper wrapper)
		{
			Debug.Assert(wrapper.GetClassLoader() == this);
			while (wrapper.IsFakeNestedType)
			{
				wrapper = wrapper.DeclaringTypeWrapper;
			}
			return wrapper.TypeAsBaseType.Assembly;
		}

		internal override Type GetGenericTypeDefinition(string name)
		{
			try
			{
				// we only have to look in the main assembly, because only a .NET assembly can contain generic type definitions
				// and it cannot be part of a multi assembly sharedclassloader group
				Type type = assemblyLoader.Assembly.GetType(name);
				if (type != null && type.IsGenericTypeDefinition)
				{
					return type;
				}
			}
			catch (FileLoadException x)
			{
				// this can only happen if the assembly was loaded in the ReflectionOnly
				// context and the requested type references a type in another assembly
				// that cannot be found in the ReflectionOnly context
				// TODO figure out what other exceptions Assembly.GetType() can throw
				Tracer.Info(Tracer.Runtime, x.Message);
			}
			return null;
		}

		private Assembly LoadAssemblyOrClearName(ref string name)
		{
			if (name == null)
			{
				// previous load attemp failed
				return null;
			}
			try
			{
				if (isReflectionOnly)
				{
					return Assembly.ReflectionOnlyLoad(name);
				}
				else
				{
					return Assembly.Load(name);
				}
			}
			catch
			{
				// cache failure by clearing out the name the caller uses
				name = null;
				// should we issue a warning error (in ikvmc)?
				return null;
			}
		}

		internal TypeWrapper DoLoad(string name)
		{
			TypeWrapper tw = assemblyLoader.DoLoad(name);
			if (tw != null)
			{
				return RegisterInitiatingLoader(tw);
			}
			LazyInitExports();
			if (exports != null)
			{
				List<int> assemblies;
				if (exports.TryGetValue(JVM.PersistableHash(name), out assemblies))
				{
					foreach (int index in assemblies)
					{
						AssemblyLoader loader = exportedAssemblies[index];
						if (loader == null)
						{
							Assembly asm = LoadAssemblyOrClearName(ref exportedAssemblyNames[index]);
							if (asm == null)
							{
								continue;
							}
							loader = exportedAssemblies[index] = GetLoaderForExportedAssembly(asm);
						}
						tw = loader.DoLoad(name);
						if (tw != null)
						{
							return RegisterInitiatingLoader(tw);
						}
					}
				}
			}
			return null;
		}

		private AssemblyLoader GetLoader(Assembly assembly)
		{
			if (assemblyLoader.Assembly == assembly)
			{
				return assemblyLoader;
			}
			return GetLoaderForExportedAssembly(assembly);
		}

		private AssemblyLoader GetLoaderForExportedAssembly(Assembly assembly)
		{
			LazyInitExports();
			AssemblyLoader loader;
			lock (exportedLoaders)
			{
				exportedLoaders.TryGetValue(assembly, out loader);
			}
			if (loader == null)
			{
				loader = new AssemblyLoader(assembly);
				lock (exportedLoaders)
				{
					AssemblyLoader existing;
					if (exportedLoaders.TryGetValue(assembly, out existing))
					{
						// another thread beat us to it
						loader = existing;
					}
					else
					{
						exportedLoaders.Add(assembly, loader);
					}
				}
			}
			return loader;
		}

		internal virtual TypeWrapper GetWrapperFromAssemblyType(Type type)
		{
			//Tracer.Info(Tracer.Runtime, "GetWrapperFromAssemblyType: {0}", type.FullName);
			Debug.Assert(!type.Name.EndsWith("[]"), "!type.IsArray", type.FullName);
			Debug.Assert(ClassLoaderWrapper.GetAssemblyClassLoader(type.Assembly) == this);
#if !IKVM_REF_EMIT
			Debug.Assert(!(type.Assembly is AssemblyBuilder), "!(type.Assembly is AssemblyBuilder)", type.FullName);
#endif
			TypeWrapper wrapper = GetLoader(type.Assembly).CreateWrapperForAssemblyType(type);
			if(wrapper != null)
			{
				wrapper = RegisterInitiatingLoader(wrapper);
				if(wrapper.TypeAsTBD != type && (!wrapper.IsRemapped || wrapper.TypeAsBaseType != type))
				{
					// this really shouldn't happen, it means that we have two different types in our assembly that both
					// have the same Java name
					string msg = String.Format("\nType \"{0}\" and \"{1}\" both map to the same name \"{2}\".\n", type.FullName, wrapper.TypeAsTBD.FullName, wrapper.Name);
					JVM.CriticalFailure(msg, null);
				}
				return wrapper;
			}
			return null;
		}

		protected override TypeWrapper LoadClassImpl(string name, bool throwClassNotFoundException)
		{
			TypeWrapper tw = DoLoad(name);
			if(tw != null)
			{
				return tw;
			}
			if(hasCustomClassLoader)
			{
				return base.LoadClassImpl(name, throwClassNotFoundException);
			}
			else
			{
				tw = LoadGenericClass(name);
				if(tw != null)
				{
					return tw;
				}
				return LoadReferenced(name);
			}
		}

		internal TypeWrapper LoadReferenced(string name)
		{
			LazyInitExports();
			for(int i = 0; i < delegates.Length; i++)
			{
				if(delegates[i] == null)
				{
					Assembly asm = LoadAssemblyOrClearName(ref references[i]);
					if(asm != null)
					{
						delegates[i] = ClassLoaderWrapper.GetAssemblyClassLoader(asm);
					}
				}
				if(delegates[i] != null)
				{
					TypeWrapper tw = delegates[i].DoLoad(name);
					if(tw != null)
					{
						return tw;
					}
				}
			}
			if(!assemblyLoader.HasJavaModule)
			{
				return GetBootstrapClassLoader().LoadClassByDottedNameFast(name);
			}
			return null;
		}

#if !STATIC_COMPILER
		internal Assembly FindResourceAssembliesImpl(string unmangledName, string name, bool firstOnly, ref List<Assembly> list)
		{
			if(ReflectUtil.IsDynamicAssembly(assemblyLoader.Assembly))
			{
				return null;
			}
			if(assemblyLoader.Assembly.GetManifestResourceInfo(name) != null)
			{
				if(firstOnly)
				{
					return assemblyLoader.Assembly;
				}
				list = new List<Assembly>();
				list.Add(assemblyLoader.Assembly);
			}
			LazyInitExports();
			if(exports != null)
			{
				List<int> assemblies;
				if(exports.TryGetValue(JVM.PersistableHash(unmangledName), out assemblies))
				{
					foreach(int index in assemblies)
					{
						AssemblyLoader loader = exportedAssemblies[index];
						if(loader == null)
						{
							Assembly asm = LoadAssemblyOrClearName(ref exportedAssemblyNames[index]);
							if(asm == null)
							{
								continue;
							}
							loader = exportedAssemblies[index] = GetLoaderForExportedAssembly(asm);
						}
						if(loader.Assembly.GetManifestResourceInfo(name) != null)
						{
							if(firstOnly)
							{
								return loader.Assembly;
							}
							if(list == null)
							{
								list = new List<Assembly>();
							}
							list.Add(loader.Assembly);
						}
					}
				}
			}
			return null;
		}

		internal Assembly[] FindResourceAssemblies(string unmangledName, bool firstOnly)
		{
			List<Assembly> list = null;
			string name = JVM.MangleResourceName(unmangledName);
			Assembly first = FindResourceAssembliesImpl(unmangledName, name, firstOnly, ref list);
			if(first != null)
			{
				return new Assembly[] { first };
			}
			LazyInitExports();
			for(int i = 0; i < delegates.Length; i++)
			{
				if(delegates[i] == null)
				{
					Assembly asm = LoadAssemblyOrClearName(ref references[i]);
					if(asm != null)
					{
						delegates[i] = ClassLoaderWrapper.GetAssemblyClassLoader(asm);
					}
				}
				if(delegates[i] != null)
				{
					first = delegates[i].FindResourceAssembliesImpl(unmangledName, name, firstOnly, ref list);
					if(first != null)
					{
						return new Assembly[] { first };
					}
				}
			}
			if(!assemblyLoader.HasJavaModule)
			{
				if(firstOnly)
				{
					return GetBootstrapClassLoader().FindResourceAssemblies(unmangledName, firstOnly);
				}
				else
				{
					Assembly[] assemblies = GetBootstrapClassLoader().FindResourceAssemblies(unmangledName, firstOnly);
					if(assemblies != null)
					{
						foreach(Assembly asm in assemblies)
						{
							if(list == null)
							{
								list = new List<Assembly>();
							}
							if(!list.Contains(asm))
							{
								list.Add(asm);
							}
						}
					}
				}
			}
			if(list == null)
			{
				return null;
			}
			return list.ToArray();
		}

		internal void SetInitInProgress()
		{
			initializerThread = Thread.CurrentThread;
		}

		internal void SetInitDone()
		{
			lock(this)
			{
				initializerThread = null;
				Monitor.PulseAll(this);
			}
		}

		internal void WaitInitDone()
		{
			lock(this)
			{
				if(initializerThread != Thread.CurrentThread)
				{
					while(initializerThread != null)
					{
						Monitor.Wait(this);
					}
				}
			}
		}
#endif // !STATIC_COMPILER

		internal virtual object GetProtectionDomain()
		{
#if STATIC_COMPILER || FIRST_PASS
			return null;
#else
			if(protectionDomain == null)
			{
				java.net.URL codebase;
				try
				{
					codebase = new java.net.URL(assemblyLoader.Assembly.CodeBase);
				}
				catch(NotSupportedException)
				{
					// dynamic assemblies don't have a codebase
					codebase = null;
				}
				catch(java.net.MalformedURLException)
				{
					codebase = null;
				}
				java.security.Permissions permissions = new java.security.Permissions();
				permissions.add(new java.security.AllPermission());
				object pd = new java.security.ProtectionDomain(new java.security.CodeSource(codebase, (java.security.cert.Certificate[])null), permissions, (java.lang.ClassLoader)GetJavaClassLoader(), null);
				lock(this)
				{
					if(protectionDomain == null)
					{
						protectionDomain = pd;
					}
				}
			}
			return protectionDomain;
#endif
		}

		protected override void CheckDefineClassAllowed(string className)
		{
			if(DoLoad(className) != null)
			{
				throw new LinkageError("duplicate class definition: " + className);
			}
		}

		internal override TypeWrapper GetLoadedClass(string name)
		{
			TypeWrapper tw = base.GetLoadedClass(name);
			return tw != null ? tw : DoLoad(name);
		}

		internal override bool InternalsVisibleToImpl(TypeWrapper wrapper, TypeWrapper friend)
		{
			ClassLoaderWrapper other = friend.GetClassLoader();
			if(this == other)
			{
				return true;
			}
			AssemblyName otherName;
#if STATIC_COMPILER
			CompilerClassLoader ccl = other as CompilerClassLoader;
			if(ccl == null)
			{
				return false;
			}
			otherName = ccl.GetAssemblyName();
#else
			AssemblyClassLoader acl = other as AssemblyClassLoader;
			if(acl == null)
			{
				return false;
			}
			otherName = acl.GetAssembly(friend).GetName();
#endif
			return GetLoaderForExportedAssembly(GetAssembly(wrapper)).InternalsVisibleTo(otherName);
		}
	}

	class BootstrapClassLoader : AssemblyClassLoader
	{
		internal BootstrapClassLoader()
			: base(JVM.CoreAssembly, new string[] {
				typeof(object).Assembly.FullName,		// mscorlib
				typeof(System.Uri).Assembly.FullName	// System
			}, null, false)
		{
		}

		internal override TypeWrapper GetWrapperFromAssemblyType(Type type)
		{
			// we have to special case the fake types here
			if(type.IsGenericType)
			{
				TypeWrapper outer = ClassLoaderWrapper.GetWrapperFromType(type.GetGenericArguments()[0]);
				foreach(TypeWrapper inner in outer.InnerClasses)
				{
					if(inner.TypeAsTBD == type)
					{
						return inner;
					}
					foreach(TypeWrapper inner2 in inner.InnerClasses)
					{
						if(inner2.TypeAsTBD == type)
						{
							return inner2;
						}
					}
				}
				return null;
			}
			return base.GetWrapperFromAssemblyType(type);
		}

		internal override object GetProtectionDomain()
		{
			return null;
		}
	}
@


1.151
log
@Added support for exposing open generic types as Java classes (special "handle" classes that can only be used for stack walking).
@
text
@d28 1
a28 1
#elif !COMPACT_FRAMEWORK
a41 1
#if !COMPACT_FRAMEWORK
a42 1
#endif
a333 3
#if COMPACT_FRAMEWORK
			throw new NoClassDefFoundError("Class loading is not supported on the Compact Framework");
#else
a355 1
#endif
a725 3
#if COMPACT_FRAMEWORK
				return new Type[0];
#else
a726 1
#endif
d1113 1
a1113 1
#if !COMPACT_FRAMEWORK && !IKVM_REF_EMIT
d1115 1
a1115 1
#endif // !COMPACT_FRAMEWORK
d2002 1
a2002 1
#if !COMPACT_FRAMEWORK && !IKVM_REF_EMIT
@


1.150
log
@Handle Annotation.__ReturnValue and Annotation.__Multiple fake types.
@
text
@a899 1
			Debug.Assert(!type.ContainsGenericParameters);
d1678 1
a1678 1
								return new DotNetTypeWrapper(type, name);
d1766 1
a1766 1
					return new DotNetTypeWrapper(type, name);
@


1.149
log
@Added App.config setting (ikvm-emit-symbols) to force emitting debug symbols on or off.
@
text
@d2324 7
@


1.148
log
@Implemented class gc (available only when compiling on .NET 4.0).
@
text
@d875 1
a875 1
					if(System.Diagnostics.Debugger.IsAttached)
@


1.147
log
@Added JavaModuleAttribute to dynamic module to make detection of Java types more straightforward.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
d35 1
d53 1
a53 1
		private static readonly Dictionary<Type, TypeWrapper> typeToTypeWrapper = new Dictionary<Type, TypeWrapper>();
d72 4
d91 9
a99 9
			typeToTypeWrapper[PrimitiveTypeWrapper.BOOLEAN.TypeAsTBD] = PrimitiveTypeWrapper.BOOLEAN;
			typeToTypeWrapper[PrimitiveTypeWrapper.BYTE.TypeAsTBD] = PrimitiveTypeWrapper.BYTE;
			typeToTypeWrapper[PrimitiveTypeWrapper.CHAR.TypeAsTBD] = PrimitiveTypeWrapper.CHAR;
			typeToTypeWrapper[PrimitiveTypeWrapper.DOUBLE.TypeAsTBD] = PrimitiveTypeWrapper.DOUBLE;
			typeToTypeWrapper[PrimitiveTypeWrapper.FLOAT.TypeAsTBD] = PrimitiveTypeWrapper.FLOAT;
			typeToTypeWrapper[PrimitiveTypeWrapper.INT.TypeAsTBD] = PrimitiveTypeWrapper.INT;
			typeToTypeWrapper[PrimitiveTypeWrapper.LONG.TypeAsTBD] = PrimitiveTypeWrapper.LONG;
			typeToTypeWrapper[PrimitiveTypeWrapper.SHORT.TypeAsTBD] = PrimitiveTypeWrapper.SHORT;
			typeToTypeWrapper[PrimitiveTypeWrapper.VOID.TypeAsTBD] = PrimitiveTypeWrapper.VOID;
d151 1
a151 1
			lock(typeToTypeWrapper)
d153 1
a153 1
				typeToTypeWrapper.Add(type, tw);
d341 18
a358 1
				factory = DynamicClassLoader.Get(this);
d655 15
d887 9
d904 1
a904 1
			lock(typeToTypeWrapper)
d906 1
a906 1
				typeToTypeWrapper.TryGetValue(type, out wrapper);
d931 11
d945 8
a952 1
				wrapper = GetAssemblyClassLoader(type.Assembly).GetWrapperFromAssemblyType(type);
d954 2
a955 1
			lock(typeToTypeWrapper)
d957 1
a957 1
				typeToTypeWrapper[type] = wrapper;
d1332 1
a1332 1
		internal static void SetWrapperForType(Type type, TypeWrapper wrapper)
d1335 7
a1341 10
			lock(typeToTypeWrapper)
			{
				typeToTypeWrapper.Add(type, wrapper);
			}
		}

		internal static void ResetWrapperForType(Type type, TypeWrapper wrapper)
		{
			TypeWrapper.AssertFinished(type);
			lock(typeToTypeWrapper)
d1343 1
a1343 1
				typeToTypeWrapper[type] = wrapper;
@


1.146
log
@Removed unused method.
@
text
@a134 10
		internal static bool IsDynamicType(Type type)
		{
			lock(typeToTypeWrapper)
			{
				TypeWrapper tw;
				typeToTypeWrapper.TryGetValue(type, out tw);
				return tw is DynamicTypeWrapper;
			}
		}

@


1.145
log
@Made dynamic assembly detection more reliable and moved the utility method to ReflectUtil.
@
text
@a126 8
		internal static int GetLoadedClassCount()
		{
			lock(typeToTypeWrapper)
			{
				return typeToTypeWrapper.Count;
			}
		}

@


1.144
log
@Changed DynamicClassLoader API to make it easier to move from global AssemblyBuilder to per ClassLoader.
@
text
@d1764 1
a1764 4
#pragma warning disable 184
					// during ikvmc build: warning CS0184: The given expression is never of the provided ('IKVM.Reflection.Emit.AssemblyBuilder') type
					if (!(assemblyLoader.Assembly is AssemblyBuilder) && assemblyLoader.Assembly.GetManifestResourceInfo("ikvm.exports") != null)
#pragma warning restore 184
d2042 4
d2100 1
@


1.143
log
@Implemented native library unloading to support evil trick that com.sun.jna.Native$DeleteNativeLibrary uses (it uses reflection to call ClassLoader$NativeLibrary.finalize() to force the native library to be unloaded, even though the class loader isn't garbage collected.)
@
text
@a54 1
		private TypeWrapperFactory factory;
d66 1
d351 1
a351 1
#elif STATIC_COMPILER
d354 1
a354 1
				factory = new DynamicClassLoader(((CompilerClassLoader)this).CreateModuleBuilder());
a356 2
#else
			return DynamicClassLoader.Instance;
@


1.142
log
@Delegate fixes.
@
text
@d1330 8
@


1.141
log
@Fixed regression introduced in 0.38 that caused LinkageError to be thrown instead of ClassCircularyError.
@
text
@d56 1
d261 26
@


1.140
log
@Made Mono compilation workarounds conditional on __MonoCS__.
@
text
@d368 1
a368 1
					if(!types.TryGetValue(name, out type))
@


1.139
log
@Added hack to fail fast if we encounter (a particular kind of) corrupt assembly generated by some obfuscator.
@
text
@d821 6
a826 2
				// MONOBUG the redundant cast to ClassLoaderWrapper is to workaround an mcs bug
				ClassLoaderWrapper wrapper = (ClassLoaderWrapper)(object)((java.lang.ClassLoader)javaClassLoader).wrapper;
d958 1
a958 1
#if !STATIC_COMPILER
d969 1
d971 3
@


1.138
log
@Disable compiler warning.
@
text
@d1437 12
a1448 1
					object[] attr = AttributeHelper.GetJavaModuleAttributes(modules[i]);
@


1.137
log
@Made the reading of the ikvm.exports resource lazy.
@
text
@d1712 2
d1715 1
@


1.136
log
@It turns out that constructing an AssemblyName is very expensive, so we simply use the string names.
@
text
@d1704 5
a1708 1
			if(assembly.GetManifestResourceInfo("ikvm.exports") != null)
d1710 1
a1710 2
				List<string> wildcardExports = new List<string>();
				using(Stream stream = assembly.GetManifestResourceStream("ikvm.exports"))
d1712 4
a1715 11
					BinaryReader rdr = new BinaryReader(stream);
					int assemblyCount = rdr.ReadInt32();
					exports = new Dictionary<int, List<int>>();
					exportedAssemblies = new AssemblyLoader[assemblyCount];
					exportedAssemblyNames = new string[assemblyCount];
					exportedLoaders = new Dictionary<Assembly, AssemblyLoader>();
					for (int i = 0; i < assemblyCount; i++)
					{
						exportedAssemblyNames[i] = rdr.ReadString();
						int typeCount = rdr.ReadInt32();
						if(typeCount == 0 && references == null)
d1717 26
a1742 1
							wildcardExports.Add(exportedAssemblyNames[i]);
d1744 10
a1753 1
						for(int j = 0; j < typeCount; j++)
d1755 1
a1755 8
							int hash = rdr.ReadInt32();
							List<int> assemblies;
							if(!exports.TryGetValue(hash, out assemblies))
							{
								assemblies = new List<int>();
								exports.Add(hash, assemblies);
							}
							assemblies.Add(i);
d1758 1
a1758 4
				}
				if(references == null)
				{
					references = wildcardExports.ToArray();
d1761 5
a1765 1
			else
d1767 1
a1767 6
				AssemblyName[] refNames = assemblyLoader.Assembly.GetReferencedAssemblies();
				references = new string[refNames.Length];
				for (int i = 0; i < references.Length; i++)
				{
					references[i] = refNames[i].FullName;
				}
a1768 1
			delegates = new AssemblyClassLoader[references.Length];
d1846 1
d1886 1
d1960 1
d1999 1
@


1.135
log
@Added a helper method to invoke AccessController.doPrivileged() and pass in explicit CallerID.
@
text
@d1408 1
a1408 1
		private AssemblyName[] references;
d1417 1
a1417 1
		private AssemblyName[] exportedAssemblyNames;
d1697 1
a1697 1
		internal AssemblyClassLoader(Assembly assembly, AssemblyName[] fixedReferences, object javaClassLoader, bool hasCustomClassLoader)
d1706 1
a1706 1
				List<AssemblyName> wildcardExports = new List<AssemblyName>();
d1713 1
a1713 1
					exportedAssemblyNames = new AssemblyName[assemblyCount];
d1717 1
a1717 1
						exportedAssemblyNames[i] = new AssemblyName(rdr.ReadString());
d1743 6
a1748 1
				references = assembly.GetReferencedAssemblies();
d1794 1
a1794 1
		private Assembly LoadAssemblyOrClearName(ref AssemblyName nameRef)
a1795 1
			AssemblyName name = nameRef;
d1805 1
a1805 1
					return Assembly.ReflectionOnlyLoad(name.FullName);
d1815 1
a1815 1
				nameRef = null;
d2182 3
a2184 3
			: base(JVM.CoreAssembly, new AssemblyName[] {
				typeof(object).Assembly.GetName(),		// mscorlib
				typeof(System.Uri).Assembly.GetName()	// System
@


1.134
log
@Use "ikvm.exports" map for "wildcard exports" (i.e. assemblies that are referenced and whose types are available thru the assembly class loader).
@
text
@d921 7
d945 1
a945 1
				javaClassLoader = java.security.AccessController.doPrivileged(new CreateAssemblyClassLoader(null));
d1148 1
a1148 1
						javaClassLoader = java.security.AccessController.doPrivileged(new CreateAssemblyClassLoader(assembly));
d1170 1
a1170 1
					java.security.AccessController.doPrivileged(new CustomClassLoaderCtorCaller(customClassLoaderCtor, javaClassLoader, assembly));
@


1.133
log
@Renamed AssemblyClassLoader.Assembly to MainAssembly.
@
text
@d74 1
a1060 1
#if !STATIC_COMPILER && !FIRST_PASS
d1063 5
a1067 1
						return GetBootstrapClassLoader();
d1069 1
d1686 1
a1686 1
			: this(assembly, assembly.GetReferencedAssemblies(), javaClassLoader, hasCustomClassLoader)
d1690 1
a1690 1
		internal AssemblyClassLoader(Assembly assembly, AssemblyName[] references, object javaClassLoader, bool hasCustomClassLoader)
d1694 1
a1694 1
			this.references = references;
d1697 1
a1697 2
			delegates = new AssemblyClassLoader[references.Length];
			if(assembly.GetType("__<MainAssembly>") != null)
d1699 1
d1712 4
d1729 4
d1734 5
@


1.132
log
@Changed "InternalsVisibleTo" handling to be based on Assembly instead of class loader.
@
text
@d1384 1
a1384 1
					sb.Append(((AssemblyClassLoader)loader).Assembly.FullName);
d1723 1
a1723 1
		internal Assembly Assembly
@


1.131
log
@Refactored assembly resource loading and added support for delegating to sharedclassloader assembly groups.
@
text
@d1306 1
a1306 1
		internal virtual bool InternalsVisibleTo(ClassLoaderWrapper other)
d1308 2
a1309 1
			return this == other;
a1397 1
		private AssemblyName[] internalsVisibleTo;
d1416 1
d1662 16
a1692 1
			internalsVisibleTo = AttributeHelper.GetInternalsVisibleToAttributes(assembly);
d2123 1
a2123 1
		internal override bool InternalsVisibleTo(ClassLoaderWrapper other)
d2125 1
d2144 1
a2144 1
			otherName = acl.Assembly.GetName();
d2146 1
a2146 8
			foreach(AssemblyName name in internalsVisibleTo)
			{
				if(AssemblyName.ReferenceMatchesDefinition(name, otherName))
				{
					return true;
				}
			}
			return false;
@


1.130
log
@Cache assembly load failures (because the CLR binder also caches failures).
@
text
@d1922 1
a1922 1
		internal Assembly[] FindResourceAssemblies(string unmangledName, bool firstOnly)
a1923 2
			List<Assembly> list = null;
			string name = JVM.MangleResourceName(unmangledName);
d1928 1
a1928 1
					return new Assembly[] { assemblyLoader.Assembly };
d1954 1
a1954 1
								return new Assembly[] { loader.Assembly };
d1965 12
d1989 2
a1990 3
					// TODO should delegates that are part of a shared class loader group be treated as such?
					// well, obviously we must do this for the boot class loader
					if(delegates[i].Assembly.GetManifestResourceInfo(name) != null)
d1992 1
a1992 9
						if(firstOnly)
						{
							return new Assembly[] { delegates[i].Assembly };
						}
						if(list == null)
						{
							list = new List<Assembly>();
						}
						list.Add(delegates[i].Assembly);
@


1.129
log
@Fixed AssemblyClassLoader.GetAssembly() to handle fake types.
@
text
@d1748 1
a1748 1
		private Assembly LoadAssembly(AssemblyName name)
d1750 6
d1769 3
d1793 1
a1793 2
							// TODO consider throttling the Load attempts (or caching failure)
							Assembly asm = LoadAssembly(exportedAssemblyNames[index]);
d1899 1
a1899 2
					// TODO consider throttling the Load attempts (or caching failure)
					Assembly asm = LoadAssembly(references[i]);
d1945 1
a1945 2
							// TODO consider throttling the Load attempts (or caching failure)
							Assembly asm = LoadAssembly(exportedAssemblyNames[index]);
d1971 1
a1971 2
					// TODO consider throttling the Load attempts (or caching failure)
					Assembly asm = LoadAssembly(references[i]);
@


1.128
log
@Added AssemblyClassLoader.GetAssembly(TypeWrapper) and changed most code that assumed that an AssemblyClassLoader represented a single assembly to use it.
@
text
@d1718 4
@


1.127
log
@Renamed ClassLoadWrapper.GetType(string) to GetGenericTypeDefinition() to make clear what it is used for.
@
text
@d1715 6
@


1.126
log
@Removed method that is no longer used.
@
text
@d474 2
a475 2
			Type type = GetType(DotNetTypeWrapper.DemangleTypeName(name.Substring(0, pos)));
			if(type == null || !type.IsGenericTypeDefinition)
d893 1
a893 1
		internal virtual Type GetType(string name)
d1338 1
a1338 1
		internal override Type GetType(string name)
d1342 1
a1342 1
				Type t = loader.GetType(name);
d1715 1
a1715 1
		internal override Type GetType(string name)
d1719 7
a1725 2
				// TODO do we want to support this for multi assembly shared class loaders?
				return assemblyLoader.Assembly.GetType(name);
d1727 1
a1727 1
			catch(FileLoadException x)
@


1.125
log
@Assemblies part of a shared class loader group should be supported by ikvmc as well.
@
text
@a132 5
		internal static bool IsCoreAssemblyType(Type type)
		{
			return type.Assembly == JVM.CoreAssembly;
		}

@


1.124
log
@Implemented shared class loader support.
@
text
@a1051 5
#if !STATIC_COMPILER && !FIRST_PASS
					if(assembly == JVM.CoreAssembly)
					{
						return GetBootstrapClassLoader();
					}
d1065 5
@


1.123
log
@- Made java.lang.ClassLoader.loadClassInternal() accessible.
- Call ClassLoader.loadClassInternal() instead of ClassLoader.loadClass() to lock class loader object.
@
text
@d1057 13
d1399 1
a1399 1
		private Assembly assembly;
a1403 3
		private bool[] isJavaModule;
		private Module[] modules;
		private Dictionary<string, string> nameMap;
a1407 1
		private bool hasDotNetModule;
d1409 65
d1475 76
a1550 9
		internal AssemblyClassLoader(Assembly assembly, object javaClassLoader, bool hasCustomClassLoader)
			: base(CodeGenOptions.None, javaClassLoader)
		{
			this.assembly = assembly;
			modules = assembly.GetModules(false);
			isJavaModule = new bool[modules.Length];
			this.hasCustomClassLoader = hasCustomClassLoader;
			isReflectionOnly = assembly.ReflectionOnly;
			for(int i = 0; i < modules.Length; i++)
d1552 1
a1552 2
				object[] attr = AttributeHelper.GetJavaModuleAttributes(modules[i]);
				if(attr.Length > 0)
d1554 1
a1554 2
					isJavaModule[i] = true;
					foreach(JavaModuleAttribute jma in attr)
d1556 2
a1557 2
						string[] map = jma.GetClassMap();
						if(map != null)
d1559 2
a1560 1
							if(nameMap == null)
d1562 1
a1562 1
								nameMap = new Dictionary<string, string>();
d1564 10
a1573 1
							for(int j = 0; j < map.Length; j += 2)
d1575 1
a1575 5
								string key = map[j];
								string val = map[j + 1];
								// TODO if there is a name clash between modules, this will throw.
								// Figure out how to handle that.
								nameMap.Add(key, val);
d1580 74
d1656 8
a1663 1
					hasDotNetModule = true;
d1666 14
a1679 1
			references = assembly.GetReferencedAssemblies();
d1682 28
d1716 1
a1716 1
				return assembly;
d1724 2
a1725 18
				return assembly.GetType(name);
			}
			catch(FileLoadException x)
			{
				// this can only happen if the assembly was loaded in the ReflectionOnly
				// context and the requested type references a type in another assembly
				// that cannot be found in the ReflectionOnly context
				// TODO figure out what other exceptions Assembly.GetType() can throw
				Tracer.Info(Tracer.Runtime, x.Message);
			}
			return null;
		}

		private Type GetType(Module mod, string name)
		{
			try
			{
				return mod.GetType(name);
d1738 1
a1738 1
		private Type GetJavaType(Module mod, string name)
d1742 1
a1742 2
				string n = null;
				if(nameMap != null)
d1744 1
a1744 1
					nameMap.TryGetValue(name, out n);
d1746 1
a1746 2
				Type t = GetType(mod, n != null ? n : name);
				if(t == null)
d1748 1
a1748 13
					n = name.Replace('$', '+');
					if(!ReferenceEquals(n, name))
					{
						t = GetType(n);
					}
				}
				if(t != null
					&& !AttributeHelper.IsHideFromJava(t)
					&& !t.IsArray
					&& !t.IsPointer
					&& !t.IsByRef)
				{
					return t;
d1751 1
a1751 1
			catch(ArgumentException x)
d1753 1
a1753 3
				// we can end up here because we replace the $ with a plus sign
				// (or client code did a Class.forName() on an invalid name)
				Tracer.Info(Tracer.Runtime, x.Message);
a1754 1
			return null;
d1759 6
a1764 1
			for(int i = 0; i < modules.Length; i++)
d1766 2
a1767 1
				if(isJavaModule[i])
d1769 1
a1769 2
					Type type = GetJavaType(modules[i], name);
					if(type != null)
d1771 2
a1772 2
						// check the name to make sure that the canonical name was used
						if(CompiledTypeWrapper.GetName(type) == name)
d1774 7
a1780 1
							return RegisterInitiatingLoader(CompiledTypeWrapper.newInstance(name, type));
d1782 2
a1783 10
					}
				}
				else
				{
					// TODO should we catch ArgumentException and prohibit array, pointer and byref here?
					Type type = GetType(modules[i], DotNetTypeWrapper.DemangleTypeName(name));
					if(type != null && DotNetTypeWrapper.IsAllowedOutside(type))
					{
						// check the name to make sure that the canonical name was used
						if(DotNetTypeWrapper.GetName(type) == name)
d1785 1
a1785 1
							return RegisterInitiatingLoader(new DotNetTypeWrapper(type, name));
d1790 16
a1805 1
			if(hasDotNetModule)
d1807 6
a1812 4
				// for fake types, we load the declaring outer type (the real one) and
				// let that generated the manufactured nested classes
				TypeWrapper outer = null;
				if(name.EndsWith(DotNetTypeWrapper.DelegateInterfaceSuffix))
d1814 7
a1820 21
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.DelegateInterfaceSuffix.Length));
				}
				else if(name.EndsWith(DotNetTypeWrapper.AttributeAnnotationSuffix))
				{
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationSuffix.Length));
				}
				else if(name.EndsWith(DotNetTypeWrapper.AttributeAnnotationReturnValueSuffix))
				{
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationReturnValueSuffix.Length));
				}
				else if(name.EndsWith(DotNetTypeWrapper.AttributeAnnotationMultipleSuffix))
				{
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationMultipleSuffix.Length));
				}
				else if(name.EndsWith(DotNetTypeWrapper.EnumEnumSuffix))
				{
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.EnumEnumSuffix.Length));
				}
				if(outer != null && outer.IsFakeTypeContainer)
				{
					foreach(TypeWrapper tw in outer.InnerClasses)
d1822 1
a1822 4
						if(tw.Name == name)
						{
							return RegisterInitiatingLoader(tw);
						}
d1826 1
a1826 1
			return null;
d1833 1
a1833 1
			Debug.Assert(type.Assembly == assembly);
d1837 1
a1837 24
			Module mod = type.Module;
			int moduleIndex = -1;
			for(int i = 0; i < modules.Length; i++)
			{
				if(modules[i] == mod)
				{
					moduleIndex = i;
					break;
				}
			}
			string name;
			if(isJavaModule[moduleIndex])
			{
				name = CompiledTypeWrapper.GetName(type);
			}
			else
			{
				name = DotNetTypeWrapper.GetName(type);
				if(name == null)
				{
					return null;
				}
			}
			TypeWrapper wrapper = base.GetLoadedClass(name);
d1840 1
d1845 1
a1845 1
					string msg = String.Format("\nType \"{0}\" and \"{1}\" both map to the same name \"{2}\".\n", type.FullName, wrapper.TypeAsTBD.FullName, name);
d1850 1
a1850 24
			else
			{
				if(isJavaModule[moduleIndex])
				{
					if(AttributeHelper.IsHideFromJava(type))
					{
						return null;
					}
					// since this type was compiled from Java source, we have to look for our
					// attributes
					return RegisterInitiatingLoader(CompiledTypeWrapper.newInstance(name, type));
				}
				else
				{
					if(!DotNetTypeWrapper.IsAllowedOutside(type))
					{
						return null;
					}
					// since this type was not compiled from Java source, we don't need to
					// look for our attributes, but we do need to filter unrepresentable
					// stuff (and transform some other stuff)
					return RegisterInitiatingLoader(new DotNetTypeWrapper(type, name));
				}
			}
d1881 2
a1882 16
					Assembly asm = null;
					try
					{
						// TODO consider throttling the Load attempts (or caching failure)
						if(isReflectionOnly)
						{
							asm = Assembly.ReflectionOnlyLoad(references[i].FullName);
						}
						else
						{
							asm = Assembly.Load(references[i]);
						}
					}
					catch
					{
					}
d1897 1
a1897 10
			bool isJava = false;
			for(int i = 0; i < isJavaModule.Length; i++)
			{
				if(isJavaModule[i])
				{
					isJava = true;
					break;
				}
			}
			if(!isJava)
d1905 1
a1905 1
		internal Assembly[] FindResourceAssemblies(string name, bool firstOnly)
d1908 2
a1909 2
			name = JVM.MangleResourceName(name);
			if(assembly.GetManifestResourceInfo(name) != null)
d1913 1
a1913 1
					return new Assembly[] { assembly };
d1916 1
a1916 1
				list.Add(assembly);
d1918 1
a1918 1
			for(int i = 0; i < delegates.Length; i++)
d1920 2
a1921 1
				if(delegates[i] == null)
d1923 1
a1923 2
					Assembly asm = null;
					try
d1925 2
a1926 2
						// TODO consider throttling the Load attempts (or caching failure)
						if(isReflectionOnly)
d1928 19
a1946 1
							asm = Assembly.ReflectionOnlyLoad(references[i].FullName);
a1947 7
						else
					{
						asm = Assembly.Load(references[i]);
					}
					}
					catch
					{
d1949 8
d1964 2
d1980 1
a1980 2
			bool isJava = false;
			for(int i = 0; i < isJavaModule.Length; i++)
d1982 1
a1982 1
				if(isJavaModule[i])
d1984 1
a1984 2
					isJava = true;
					break;
d1986 1
a1986 5
			}
			if(!isJava)
			{
				Assembly asm = GetBootstrapClassLoader().Assembly;
				if(asm.GetManifestResourceInfo(name) != null)
d1988 2
a1989 1
					if(firstOnly)
d1991 11
a2001 9
						return new Assembly[] { asm };
					}
					if(list == null)
					{
						list = new List<Assembly>();
					}
					if(!list.Contains(asm))
					{
						list.Add(asm);
d2051 1
a2051 1
					codebase = new java.net.URL(assembly.CodeBase);
d2127 4
a2130 1
			: base(JVM.CoreAssembly, null, false)
@


1.122
log
@Integrated IKVM.Reflection.Emit in ikvmc.
@
text
@d619 1
a619 1
				java.lang.Class c = javaClassLoader.loadClass(name);
@


1.121
log
@Switched from obsolete ConfigurationSettings.AppSettings to new ConfigurationManager.AppSettings.
@
text
@d26 3
a28 1
#if !COMPACT_FRAMEWORK
d1041 1
a1041 1
#if !COMPACT_FRAMEWORK
d1597 1
a1597 1
#if !COMPACT_FRAMEWORK
@


1.120
log
@Generified all collections.
@
text
@d1174 1
a1174 1
					foreach(string key in System.Configuration.ConfigurationSettings.AppSettings.AllKeys)
@


1.119
log
@Removed support for building with GNU Classpath class library.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d30 1
a30 1
using System.Collections;
d42 1
a42 1
		internal abstract TypeWrapper DefineClassImpl(Hashtable types, ClassFile f, ClassLoaderWrapper classLoader, object protectionDomain);
d50 1
a50 1
		private static readonly Hashtable typeToTypeWrapper = Hashtable.Synchronized(new Hashtable());
d57 2
a58 2
		private static readonly Hashtable assemblyClassLoaders = new Hashtable();
		private static ArrayList genericClassLoaders;
d62 1
a62 1
		private static Hashtable customClassLoaderRedirects;
d64 3
a66 3
		protected Hashtable types = new Hashtable();
		private readonly Hashtable defineClassInProgress = new Hashtable();
		private ArrayList nativeLibraries;
d68 1
a68 1
		private static Hashtable remappedTypes = new Hashtable();
d125 4
a128 1
			return typeToTypeWrapper.Count;
d146 6
a151 1
			return typeToTypeWrapper[type] is DynamicTypeWrapper;
d161 9
a169 5
			Debug.Assert(!types.ContainsKey(tw.Name));
			types.Add(tw.Name, tw);
			Debug.Assert(!typeToTypeWrapper.ContainsKey(type));
			typeToTypeWrapper.Add(type, tw);
			remappedTypes.Add(type, type);
d176 1
a176 1
			lock(types.SyncRoot)
d178 3
a180 1
				return (TypeWrapper)types[name];
d190 1
a190 1
			lock(types.SyncRoot)
d192 2
a193 1
				object existing = types[tw.Name];
d200 1
a200 1
						return (TypeWrapper)existing;
d292 1
a292 1
			lock(types.SyncRoot)
d308 1
a308 1
				lock(types.SyncRoot)
d317 1
a317 1
					Monitor.PulseAll(types.SyncRoot);
d368 1
a368 1
				lock(types.SyncRoot)
d370 1
a370 2
					type = (TypeWrapper)types[name];
					if(type == null)
d372 2
a373 2
						object defineThread = defineClassInProgress[name];
						if(defineThread != null)
d383 1
a383 1
								Monitor.Wait(types.SyncRoot);
d385 2
a386 1
							type = (TypeWrapper)types[name];
d482 1
a482 1
			ArrayList typeParamNames = new ArrayList();
d787 1
a787 1
			ArrayList list = new ArrayList();
d792 1
a792 3
			TypeWrapper[] types = new TypeWrapper[list.Count];
			list.CopyTo(types);
			return types;
d848 5
a852 1
			TypeWrapper wrapper = (TypeWrapper)typeToTypeWrapper[type];
d857 2
a858 2
			string remapped = (string)remappedTypes[type];
			if(remapped != null)
d881 4
a884 1
			typeToTypeWrapper[type] = wrapper;
d907 1
a907 1
			ArrayList list = new ArrayList();
d917 1
a917 1
			ClassLoaderWrapper[] key = (ClassLoaderWrapper[])list.ToArray(typeof(ClassLoaderWrapper));
d929 1
a929 1
					genericClassLoaders = new ArrayList();
d967 2
a968 2
			Stack stack = new Stack();
			ArrayList list = null;
d976 1
a976 1
						list = new ArrayList();
d991 2
a992 2
					ClassLoaderWrapper loader = GetGenericClassLoaderByKey((ClassLoaderWrapper[])list.ToArray(typeof(ClassLoaderWrapper)));
					list = (ArrayList)stack.Pop();
d1024 1
a1024 1
				return genericClassLoaders.IndexOf(wrapper);
d1032 1
a1032 1
				return (ClassLoaderWrapper)genericClassLoaders[id];
d1048 1
a1048 2
				loader = (AssemblyClassLoader)assemblyClassLoaders[assembly];
				if(loader == null)
d1062 1
a1062 1
							foreach(DictionaryEntry de in customClassLoaderRedirects)
d1064 1
a1064 1
								string asm = (string)de.Key;
d1073 1
a1073 1
										customClassLoaderClass = Type.GetType((string)de.Value, true);
d1077 1
a1077 1
										Tracer.Error(Tracer.Runtime, "Unable to load custom class loader {0} specified in app.config for assembly {1}: {2}", de.Value, assembly, x);
d1181 1
a1181 1
								customClassLoaderRedirects = new Hashtable();
d1233 4
a1236 2
			Debug.Assert(!typeToTypeWrapper.ContainsKey(type));
			typeToTypeWrapper.Add(type, wrapper);
d1242 4
a1245 1
			typeToTypeWrapper[type] = wrapper;
d1267 1
a1267 1
					nativeLibraries = new ArrayList();
d1281 1
a1281 1
				return (IntPtr[])nativeLibraries.ToArray(typeof(IntPtr));
d1391 1
a1391 1
		private Hashtable nameMap;
d1420 1
a1420 1
								nameMap = new Hashtable();
d1492 1
a1492 1
					n = (string)nameMap[name];
d1621 1
a1621 5
			TypeWrapper wrapper;
			lock(types.SyncRoot)
			{
				wrapper = (TypeWrapper)types[name];
			}
d1736 1
a1736 1
			ArrayList list = null;
d1744 1
a1744 1
				list = new ArrayList();
d1782 1
a1782 1
							list = new ArrayList();
d1808 1
a1808 1
						list = new ArrayList();
d1820 1
a1820 1
			return (Assembly[])list.ToArray(typeof(Assembly));
@


1.118
log
@Restructured code to remove (mcs) compiler warnings.
@
text
@d809 1
a809 1
#elif OPENJDK
a811 2
#else
				ClassLoaderWrapper wrapper = (ClassLoaderWrapper)JVM.Library.getWrapperFromClassLoader(javaClassLoader);
d939 1
a939 2
#if FIRST_PASS || STATIC_COMPILER
#elif OPENJDK
a940 2
#else
			JVM.Library.setWrapperForClassLoader(javaClassLoader, wrapper);
@


1.117
log
@Added workarounds for mcs compiler bug (related to the mutual dependency of the runtime and class library assemblies).
@
text
@d1146 1
a1151 1
#if !STATIC_COMPILER && !FIRST_PASS
@


1.116
log
@Moved "fake" type handling to the proper place.
@
text
@d810 2
a811 1
				ClassLoaderWrapper wrapper = ((java.lang.ClassLoader)javaClassLoader).wrapper;
d931 8
d943 1
a943 1
			((java.lang.ClassLoader)javaClassLoader).wrapper = wrapper;
@


1.115
log
@Ignore codebase for dynamic assemblies.
@
text
@d1562 1
a1562 1
		internal TypeWrapper GetWrapperFromAssemblyType(Type type)
d1918 18
@


1.114
log
@Added support for defining unloadable (i.e. missing) types to use as custom modifiers in signatures.
@
text
@d1840 5
@


1.113
log
@Replaced notion of DynamicOnly types with Fake types. Fake types are implemented as generic type instances and can have DynamicOnly methods.
@
text
@d44 1
@


1.112
log
@- Added -removeassertions optimization option to ikvmc.
- Added -removeassertions to IKVM.OpenJDK.ClassLibrary.dll build.
- Don't look at unreachable instructions when determining if a method needs a line number table.
@
text
@d1524 1
a1524 1
				// for manufactured types, we load the declaring outer type (the real one) and
d1547 1
a1547 1
				if(outer != null && (outer is DotNetTypeWrapper || outer.IsDynamicOnly))
@


1.111
log
@- Don't instantiate DotNetTypeWrapper before knowing it's the right one.
- Reuse name instead of recomputing it in the DotNetTypeWrapper constructor.
@
text
@d230 8
@


1.110
log
@- Moved some calls to methods with a LinkDemand (that fails in partial trust) to a separate methods.
- Added stuff to map.xml to remove the need for reflection in VM / Library bootstrap.
- Inverted IKVM.Runtime.JNI dependency in stack walking code.
@
text
@a1505 1
						TypeWrapper tw = new DotNetTypeWrapper(type);
d1507 1
a1507 1
						if(tw.Name == name)
d1509 1
a1509 1
							return RegisterInitiatingLoader(tw);
d1621 1
a1621 1
					return RegisterInitiatingLoader(new DotNetTypeWrapper(type));
@


1.109
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@d99 7
a105 1
				Tracer.Info(Tracer.Runtime, "Core assembly: {0}", coreAssembly.Location);
d1072 1
a1072 1
								javaClassLoader = (java.lang.ClassLoader)System.Runtime.Serialization.FormatterServices.GetUninitializedObject(customClassLoaderClass);
d1128 5
@


1.108
log
@Implemented support for InternalsVisibleToAttribute.
@
text
@d792 5
d798 1
d807 1
a807 1
					JVM.Library.setWrapperForClassLoader(javaClassLoader, wrapper);
d905 2
a906 2
#if !STATIC_COMPILER
				javaClassLoader = JVM.Library.newAssemblyClassLoader(null);
d909 1
a909 3
#if !STATIC_COMPILER
				JVM.Library.setWrapperForClassLoader(javaClassLoader, newLoader);
#endif
d915 10
d1088 1
a1088 1
						javaClassLoader = JVM.Library.newAssemblyClassLoader(assembly);
d1100 1
a1100 1
						JVM.Library.setWrapperForClassLoader(javaClassLoader, loader);
d1151 15
@


1.107
log
@More .NET 1.1 -> 2.0 work.
@
text
@d1218 5
d1310 1
d1363 1
d1824 32
@


1.106
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d448 1
a448 1
			if(type == null || !Whidbey.IsGenericTypeDefinition(type))
d560 1
a560 1
				type = Whidbey.MakeGenericType(type, typeArguments);
d812 1
a812 1
			Debug.Assert(!Whidbey.ContainsGenericParameters(type));
d864 2
a865 2
			Debug.Assert(Whidbey.IsGenericType(type));
			Debug.Assert(!Whidbey.ContainsGenericParameters(type));
d869 1
a869 1
			foreach(Type arg in Whidbey.GetGenericArguments(type))
d1003 1
a1003 1
					if(!Whidbey.ReflectionOnly(assembly))
@


1.105
log
@- .NET 1.1 is no longer supported
- Removed .NET 2.0 warnings (except for the "unreachable code" ones)
@
text
@a33 1
using IKVM.Runtime;
d960 1
a960 1
#if WHIDBEY && STATIC_COMPILER
a1304 1
#if WHIDBEY
a1305 1
#endif // WHIDBEY
a1322 1
#if WHIDBEY
a1323 1
#endif // WHIDBEY
a1611 1
#if WHIDBEY
a1616 1
#endif
a1675 1
#if WHIDBEY
a1680 1
#endif
@


1.104
log
@- Did more work to keep up the pretense that an AssemblyClassLoader has already loaded all classes in the assembly.
- Restructured AssemblyClassLoader.GetProtectionDomain() to avoid calling any code while holding the lock.
@
text
@d1127 1
a1127 1
							customClassLoaderRedirects[key.Substring(prefix.Length)] = System.Configuration.ConfigurationSettings.AppSettings.Get(key);
d1312 1
d1314 2
a1316 1
		private volatile object protectionDomain;
d1784 3
a1788 1
#if !STATIC_COMPILER && !FIRST_PASS
a1807 1
#endif
d1810 1
@


1.103
log
@Enforce custom assembly class loader accessibility at runtime.
@
text
@d154 3
a156 3
		// HACK return the TypeWrapper if it is already loaded
		// (this exists solely for DynamicTypeWrapper.SetupGhosts and VMClassLoader.findLoadedClass)
		internal TypeWrapper GetLoadedClass(string name)
a368 8
				if(name.EndsWith("_$$$$_") && name.IndexOf("_$$$_") > 0)
				{
					TypeWrapper tw = LoadGenericClass(name);
					if(tw != null)
					{
						return tw;
					}
				}
d444 1
a444 1
			if(pos <= 0)
d579 5
d1262 5
d1269 1
a1269 1
				TypeWrapper tw = loader.LoadClassByDottedNameFast(name);
d1314 1
a1314 1
		private object protectionDomain;
d1585 5
a1589 3
#if STATIC_COMPILER
			return LoadClass(name);
#else
d1592 5
a1596 4
				// before calling the custom class loader, we have to look inside our assembly,
				// to prevent the custom class loader from registering us as the initiating
				// loader for an external type with the same name as a type that we define
				TypeWrapper tw = DoLoad(name);
d1601 1
a1601 1
				return base.LoadClassImpl(name, throwClassNotFoundException);
a1602 5
			else
			{
				return LoadClass(name);
			}
#endif
d1605 1
a1605 1
		internal TypeWrapper LoadClass(string name)
a1606 5
			TypeWrapper tw = DoLoad(name);
			if(tw != null)
			{
				return tw;
			}
d1636 1
a1636 1
					tw = delegates[i].DoLoad(name);
d1782 1
a1782 1
			lock(this)
d1784 14
a1797 1
				if(protectionDomain == null)
d1799 1
a1799 3
#if !STATIC_COMPILER && !FIRST_PASS
					java.net.URL codebase;
					try
d1801 1
a1801 1
						codebase = new java.net.URL(assembly.CodeBase);
d1803 1
a1803 7
					catch(java.net.MalformedURLException)
					{
						codebase = null;
					}
					java.security.Permissions permissions = new java.security.Permissions();
					permissions.add(new java.security.AllPermission());
					protectionDomain = new java.security.ProtectionDomain(new java.security.CodeSource(codebase, (java.security.cert.Certificate[])null), permissions, (java.lang.ClassLoader)GetJavaClassLoader(), null);
a1804 2
				}
				return protectionDomain;
d1806 1
d1816 6
a1830 5
		protected override TypeWrapper LoadClassImpl(string name, bool throwClassNotFoundException)
		{
			return LoadClass(name);
		}

@


1.102
log
@Allow non-public custom assembly class loaders.
@
text
@d1047 4
d1063 5
@


1.101
log
@Don't call custom assembly class loader for types that are defined in the assembly itself.
@
text
@d1053 1
a1053 1
								customClassLoaderCtor = customClassLoaderClass.GetConstructor(new Type[] { typeof(Assembly) });
@


1.100
log
@Added support for the fact that .NET generic type instances can now refer to dynamically loaded Java types.
@
text
@d1072 1
a1072 1
					loader = new AssemblyClassLoader(assembly, javaClassLoader);
d1304 1
d1306 1
a1306 1
		internal AssemblyClassLoader(Assembly assembly, object javaClassLoader)
d1312 1
a1571 1
#if STATIC_COMPILER
d1574 1
d1576 18
a1594 1
#endif
d1813 1
a1813 1
			: base(JVM.CoreAssembly, null)
@


1.99
log
@Added check to prevent defineClass() on an assembly class loader from defining a class that already exists in the assembly.
@
text
@d135 5
d530 1
@


1.98
log
@Added support for custom assembly class loaders.
@
text
@d228 5
d257 1
d1775 8
@


1.97
log
@Don't add resources in core assembly twice (happened if a .NET assembly explicitly referenced the core assembly).
@
text
@d61 2
d982 3
d987 1
a987 1
				AssemblyClassLoader loader = (AssemblyClassLoader)assemblyClassLoaders[assembly];
a989 1
					object javaClassLoader = null;
d995 61
a1055 1
					else
d1063 4
d1073 44
a1116 1
				return loader;
d1120 21
d1289 1
d1291 1
d1715 28
d1744 25
d1782 5
@


1.96
log
@Refactored assembly class loading to be more like regular class loading and prepare for future custom assembly class loaders.
@
text
@d1569 4
a1572 1
					list.Add(asm);
@


1.95
log
@Don't create TypeWrapper instances for HideFromJava types.
@
text
@a363 35
				// for manufactured types, we load the declaring outer type (the real one) and
				// let that generated the manufactured nested classes
				TypeWrapper outer = null;
				if(name.EndsWith(DotNetTypeWrapper.DelegateInterfaceSuffix))
				{
					outer = LoadClassByDottedNameFastImpl(name.Substring(0, name.Length - DotNetTypeWrapper.DelegateInterfaceSuffix.Length), false);
				}
				else if(name.EndsWith(DotNetTypeWrapper.AttributeAnnotationSuffix))
				{
					outer = LoadClassByDottedNameFastImpl(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationSuffix.Length), false);
				}
				else if(name.EndsWith(DotNetTypeWrapper.AttributeAnnotationReturnValueSuffix))
				{
					outer = LoadClassByDottedNameFastImpl(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationReturnValueSuffix.Length), false);
				}
				else if(name.EndsWith(DotNetTypeWrapper.AttributeAnnotationMultipleSuffix))
				{
					outer = LoadClassByDottedNameFastImpl(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationMultipleSuffix.Length), false);
				}
				else if(name.EndsWith(DotNetTypeWrapper.EnumEnumSuffix))
				{
					outer = LoadClassByDottedNameFastImpl(name.Substring(0, name.Length - DotNetTypeWrapper.EnumEnumSuffix.Length), false);
				}
				// NOTE we cannot use the InnerClasses property on unfinished dynamic types,
				// so we restrict ourself to DotNetTypeWrapper and DynamicOnly instances.
				if(outer != null && (outer is DotNetTypeWrapper || outer.IsDynamicOnly))
				{
					foreach(TypeWrapper tw in outer.InnerClasses)
					{
						if(tw.Name == name)
						{
							return tw;
						}
					}
				}
d429 1
a429 1
		private TypeWrapper LoadGenericClass(string name)
d767 1
a767 1
					bootstrapClassLoader = GetAssemblyClassLoader(JVM.CoreAssembly);
a975 2
			// TODO this assertion fires when compiling the core library (at least on Whidbey)
			// I need to find out why...
d985 2
a986 1
					object javaClassLoader;
d989 1
a989 1
						javaClassLoader = null;
a992 3
#if STATIC_COMPILER
						javaClassLoader = null;
#else
d994 1
a995 1
					}
d1157 1
d1194 4
d1312 36
d1424 1
d1427 6
d1580 13
@


1.95.2.1
log
@Backported fixes and changed version to 0.36.0.5
@
text
@a60 2
		private static bool customClassLoaderRedirectsLoaded;
		private static Hashtable customClassLoaderRedirects;
a132 5
		internal static bool IsDynamicType(Type type)
		{
			return typeToTypeWrapper[type] is DynamicTypeWrapper;
		}

d147 3
a149 3
		// return the TypeWrapper if it is already loaded, this exists for DynamicTypeWrapper.SetupGhosts
		// and ClassLoader.findLoadedClass()
		internal virtual TypeWrapper GetLoadedClass(string name)
a225 5
		protected virtual void CheckDefineClassAllowed(string className)
		{
			// this hook exists so that AssemblyClassLoader can prevent DefineClass when the name is already present in the assembly
		}

a249 1
			CheckDefineClassAllowed(f.Name);
d356 43
d464 1
a464 1
		internal TypeWrapper LoadGenericClass(string name)
d474 1
a474 1
			if(pos <= 0 || !name.EndsWith("_$$$$_"))
a551 1
						tw.Finish();
a607 5
			TypeWrapper tw = LoadGenericClass(name);
			if(tw != null)
			{
				return tw;
			}
d802 1
a802 1
					bootstrapClassLoader = new BootstrapClassLoader();
d1011 2
a1016 3
			ConstructorInfo customClassLoaderCtor = null;
			AssemblyClassLoader loader;
			object javaClassLoader = null;
d1019 1
a1019 1
				loader = (AssemblyClassLoader)assemblyClassLoaders[assembly];
d1022 1
a1022 1
#if !STATIC_COMPILER && !FIRST_PASS
d1025 1
a1025 1
						return GetBootstrapClassLoader();
d1027 1
a1027 70
					if(!Whidbey.ReflectionOnly(assembly))
					{
						Type customClassLoaderClass = null;
						LoadCustomClassLoaderRedirects();
						if(customClassLoaderRedirects != null)
						{
							string assemblyName = assembly.FullName;
							foreach(DictionaryEntry de in customClassLoaderRedirects)
							{
								string asm = (string)de.Key;
								// we only support matching on the assembly's simple name,
								// because there appears to be no viable alternative.
								// On .NET 2.0 there is AssemblyName.ReferenceMatchesDefinition()
								// but it is broken (and .NET 2.0 specific).
								if(assemblyName.StartsWith(asm + ","))
								{
									try
									{
										customClassLoaderClass = Type.GetType((string)de.Value, true);
									}
									catch(Exception x)
									{
										Tracer.Error(Tracer.Runtime, "Unable to load custom class loader {0} specified in app.config for assembly {1}: {2}", de.Value, assembly, x);
									}
									break;
								}
							}
						}
						if(customClassLoaderClass == null)
						{
							object[] attribs = assembly.GetCustomAttributes(typeof(CustomAssemblyClassLoaderAttribute), false);
							if(attribs.Length == 1)
							{
								customClassLoaderClass = ((CustomAssemblyClassLoaderAttribute)attribs[0]).Type;
							}
						}
						if(customClassLoaderClass != null)
						{
							try
							{
								if(!customClassLoaderClass.IsPublic && !customClassLoaderClass.Assembly.Equals(assembly))
								{
									throw new Exception("Type not accessible");
								}
								// NOTE we're creating an uninitialized instance of the custom class loader here, so that getClassLoader will return the proper object
								// when it is called during the construction of the custom class loader later on. This still doesn't make it safe to use the custom
								// class loader before it is constructed, but at least the object instance is valid and should anyone cache it, they will get the
								// right object to use later on.
								// Note also that we're not running the constructor here, because we don't want to run user code while holding a global lock.
								javaClassLoader = (java.lang.ClassLoader)System.Runtime.Serialization.FormatterServices.GetUninitializedObject(customClassLoaderClass);
								customClassLoaderCtor = customClassLoaderClass.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { typeof(Assembly) }, null);
								if(customClassLoaderCtor == null)
								{
									javaClassLoader = null;
									throw new Exception("No constructor");
								}
								if(!customClassLoaderCtor.IsPublic && !customClassLoaderClass.Assembly.Equals(assembly))
								{
									javaClassLoader = null;
									throw new Exception("Constructor not accessible");
								}
								Tracer.Info(Tracer.Runtime, "Created custom assembly class loader {0} for assembly {1}", customClassLoaderClass.FullName, assembly);
							}
							catch(Exception x)
							{
								Tracer.Error(Tracer.Runtime, "Unable to create custom assembly class loader {0} for {1}: {2}", customClassLoaderClass.FullName, assembly, x);
							}
						}
					}
					if(javaClassLoader == null)
d1029 3
d1033 1
d1035 1
a1035 2
#endif
					loader = new AssemblyClassLoader(assembly, javaClassLoader, customClassLoaderCtor != null);
a1037 4
					if(customClassLoaderCtor != null)
					{
						loader.SetInitInProgress();
					}
d1044 1
a1044 64
			}
#if !STATIC_COMPILER && !FIRST_PASS
			if(customClassLoaderCtor != null)
			{
				try
				{
					java.security.AccessController.doPrivileged(new CustomClassLoaderCtorCaller(customClassLoaderCtor, javaClassLoader, assembly));
				}
				finally
				{
					loader.SetInitDone();
				}
			}
			loader.WaitInitDone();
#endif
			return loader;
		}

#if !STATIC_COMPILER && !FIRST_PASS
		private static void LoadCustomClassLoaderRedirects()
		{
			// this method assumes that we hold a global lock
			if(!customClassLoaderRedirectsLoaded)
			{
				customClassLoaderRedirectsLoaded = true;
				try
				{
					foreach(string key in System.Configuration.ConfigurationSettings.AppSettings.AllKeys)
					{
						const string prefix = "ikvm-classloader:";
						if(key.StartsWith(prefix))
						{
							if(customClassLoaderRedirects == null)
							{
								customClassLoaderRedirects = new Hashtable();
							}
							customClassLoaderRedirects[key.Substring(prefix.Length)] = System.Configuration.ConfigurationSettings.AppSettings.Get(key);
						}
					}
				}
				catch(Exception x)
				{
					Tracer.Error(Tracer.Runtime, "Error while reading custom class loader redirects: {0}", x);
				}
			}
		}

		sealed class CustomClassLoaderCtorCaller : java.security.PrivilegedAction
		{
			private ConstructorInfo ctor;
			private object classLoader;
			private Assembly assembly;

			internal CustomClassLoaderCtorCaller(ConstructorInfo ctor, object classLoader, Assembly assembly)
			{
				this.ctor = ctor;
				this.classLoader = classLoader;
				this.assembly = assembly;
			}

			public object run()
			{
				ctor.Invoke(classLoader, new object[] { assembly });
				return null;
a1046 1
#endif
a1150 5
			TypeWrapper tw = LoadGenericClass(name);
			if(tw != null)
			{
				return tw;
			}
d1153 1
a1153 1
				tw = loader.LoadClassByDottedNameFast(name);
a1195 4
		private Thread initializerThread;
		private bool hasDotNetModule;
		private volatile object protectionDomain;
		private bool hasCustomClassLoader;
d1197 1
a1197 1
		internal AssemblyClassLoader(Assembly assembly, object javaClassLoader, bool hasCustomClassLoader)
a1202 1
			this.hasCustomClassLoader = hasCustomClassLoader;
a1231 4
				else
				{
					hasDotNetModule = true;
				}
a1345 36
			if(hasDotNetModule)
			{
				// for manufactured types, we load the declaring outer type (the real one) and
				// let that generated the manufactured nested classes
				TypeWrapper outer = null;
				if(name.EndsWith(DotNetTypeWrapper.DelegateInterfaceSuffix))
				{
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.DelegateInterfaceSuffix.Length));
				}
				else if(name.EndsWith(DotNetTypeWrapper.AttributeAnnotationSuffix))
				{
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationSuffix.Length));
				}
				else if(name.EndsWith(DotNetTypeWrapper.AttributeAnnotationReturnValueSuffix))
				{
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationReturnValueSuffix.Length));
				}
				else if(name.EndsWith(DotNetTypeWrapper.AttributeAnnotationMultipleSuffix))
				{
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.AttributeAnnotationMultipleSuffix.Length));
				}
				else if(name.EndsWith(DotNetTypeWrapper.EnumEnumSuffix))
				{
					outer = DoLoad(name.Substring(0, name.Length - DotNetTypeWrapper.EnumEnumSuffix.Length));
				}
				if(outer != null && (outer is DotNetTypeWrapper || outer.IsDynamicOnly))
				{
					foreach(TypeWrapper tw in outer.InnerClasses)
					{
						if(tw.Name == name)
						{
							return RegisterInitiatingLoader(tw);
						}
					}
				}
			}
a1428 17
			if(hasCustomClassLoader)
			{
				return base.LoadClassImpl(name, throwClassNotFoundException);
			}
			else
			{
				tw = LoadGenericClass(name);
				if(tw != null)
				{
					return tw;
				}
				return LoadReferenced(name);
			}
		}

		internal TypeWrapper LoadReferenced(string name)
		{
d1458 1
a1458 1
					TypeWrapper tw = delegates[i].DoLoad(name);
d1560 1
a1560 4
					if(!list.Contains(asm))
					{
						list.Add(asm);
					}
a1568 28

		internal void SetInitInProgress()
		{
			initializerThread = Thread.CurrentThread;
		}

		internal void SetInitDone()
		{
			lock(this)
			{
				initializerThread = null;
				Monitor.PulseAll(this);
			}
		}

		internal void WaitInitDone()
		{
			lock(this)
			{
				if(initializerThread != Thread.CurrentThread)
				{
					while(initializerThread != null)
					{
						Monitor.Wait(this);
					}
				}
			}
		}
a1569 56

		internal virtual object GetProtectionDomain()
		{
			if(protectionDomain == null)
			{
#if !STATIC_COMPILER && !FIRST_PASS
				java.net.URL codebase;
				try
				{
					codebase = new java.net.URL(assembly.CodeBase);
				}
				catch(java.net.MalformedURLException)
				{
					codebase = null;
				}
				java.security.Permissions permissions = new java.security.Permissions();
				permissions.add(new java.security.AllPermission());
				object pd = new java.security.ProtectionDomain(new java.security.CodeSource(codebase, (java.security.cert.Certificate[])null), permissions, (java.lang.ClassLoader)GetJavaClassLoader(), null);
				lock(this)
				{
					if(protectionDomain == null)
					{
						protectionDomain = pd;
					}
				}
#endif
			}
			return protectionDomain;
		}

		protected override void CheckDefineClassAllowed(string className)
		{
			if(DoLoad(className) != null)
			{
				throw new LinkageError("duplicate class definition: " + className);
			}
		}

		internal override TypeWrapper GetLoadedClass(string name)
		{
			TypeWrapper tw = base.GetLoadedClass(name);
			return tw != null ? tw : DoLoad(name);
		}
	}

	class BootstrapClassLoader : AssemblyClassLoader
	{
		internal BootstrapClassLoader()
			: base(JVM.CoreAssembly, null, false)
		{
		}

		internal override object GetProtectionDomain()
		{
			return null;
		}
@


1.95.2.2
log
@- Don't instantiate a DotNetTypeWrapper unless the name is actually the canonical name (this fixes a problem with ikvmc when referencing a .NET assembly that contains a type named java.lang.Object).
- As an optimization going from a Type to a TypeWrapper now also reuses the name it already computed.
@
text
@d1462 1
d1464 1
a1464 1
						if (DotNetTypeWrapper.GetName(type) == name)
d1466 1
a1466 1
							return RegisterInitiatingLoader(new DotNetTypeWrapper(type, name));
d1578 1
a1578 1
					return RegisterInitiatingLoader(new DotNetTypeWrapper(type, name));
@


1.95.2.3
log
@- Added -removeassertions optimization option to ikvmc.
- Removed hack from map.xml to remove assertions from java.util.BitSet.checkInvariants().
- Added -removeassertions to IKVM.OpenJDK.ClassLibrary.dll build.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
a224 8
		internal bool RemoveAsserts
		{
			get
			{
				return (codegenoptions & CodeGenOptions.RemoveAsserts) != 0;
			}
		}

@


1.95.2.4
log
@Ignore codebase for dynamic assemblies.
@
text
@a1796 5
				catch(NotSupportedException)
				{
					// dynamic assemblies don't have a codebase
					codebase = null;
				}
@


1.94
log
@Fixed ArrayTypeWrapper.Finish().
@
text
@d1400 4
@


1.93
log
@Added ReserveName() method.
@
text
@d1055 6
@


1.92
log
@Fixed infnite recursion bug when DotNetTypeWrapper.GetName() was used on DerivedType where DerivedType extends BaseType<DerivedType>.
@
text
@d44 1
@


1.91
log
@Simplified VM -> Class Library interface by taking advantage of the fact that IKVM.Runtime.dll is now compiled in two passes with the second pass linking against the class library.
@
text
@d872 1
a872 1
		private static bool IsVector(Type type)
@


1.90
log
@- Added support for applying custom attributes to return values.
- Added support for applying AllowMultiple custom attributes multiple times to the same element.
- Restructured ParameterBuilder handling.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d58 3
a60 1
		private readonly object javaClassLoader;
d127 3
a129 1
			this.javaClassLoader = javaClassLoader;
d607 1
a607 1
#if !STATIC_COMPILER
a608 1
			TypeWrapper type;
d611 7
a617 2
				type = (TypeWrapper)JVM.Library.loadClass(javaClassLoader, name);
				if(type != null && type.Name != name)
d622 1
d624 1
a624 1
			catch(Exception x)
d626 1
a626 2
				if(!throwClassNotFoundException
					&& LoadClassCritical("java.lang.ClassNotFoundException").TypeAsBaseType.IsInstanceOfType(x))
d628 1
a628 1
					return null;
d630 5
a634 1
				throw new ClassLoadingException(JVM.Library.mapException(x));
a639 1
			return type;
d663 3
d667 1
d1091 1
d1100 1
@


1.89
log
@- .NET "generic class loaders" now return something sensible when toString() is called on them.
- Ikvmc no longer warns about generic stubs.
- Ikvmstub now has WHIDBEY conditional code to properly determine if a class is a generic type instance (instead of the name based hack).
- Fixed .NET generic type name mangling bug (nested generic types were double encoded).
- Added support for loading .NET generic type stubs.
- Fixed several .NET generic type loading bugs.
- Fixed ikvm.runtime.Util.getInstanceTypeFromClass() to return null instead of throw an exception when it is called on a "dynamic only" class.
@
text
@d370 8
d383 2
a384 2
				// so we restrict ourself to DotNetTypeWrapper instances.
				if(outer != null && outer is DotNetTypeWrapper)
@


1.89.2.1
log
@Made IsVector internal to allow DotNetTypeWrapper.GetName() to access it.
@
text
@d849 1
a849 1
		internal static bool IsVector(Type type)
@


1.88
log
@Restructured mutual dependency of IKVM.Runtime and IKVM.GNU.Classpath to work around Mono C# compiler limitation.
@
text
@d226 3
a228 3
				// The sole purpose of the stub class is to let us load the assembly that the class lives in,
				// once we've done that, all types in it become visible.
				Assembly asm;
d231 1
a231 5
#if WHIDBEY && STATIC_COMPILER
					asm = Assembly.ReflectionOnlyLoad(dotnetAssembly);
#else
					asm = Assembly.Load(dotnetAssembly);
#endif
d235 1
d238 1
a238 1
				TypeWrapper tw = ClassLoaderWrapper.GetAssemblyClassLoader(asm).LoadClassByDottedNameFast(f.Name);
d241 1
a241 1
					throw new NoClassDefFoundError(f.Name + " (type not found in " + asm.FullName + ")");
d465 1
a465 1
			Type type = GetBootstrapClassLoader().GetType(DotNetTypeWrapper.DemangleTypeName(name.Substring(0, pos)));
d518 7
a524 2
				s = s.Replace("__", ".");
				s = s.Replace("$$005F$$005F", "__");
d879 7
a885 1
			ClassLoaderWrapper matchingLoader = null;
d896 1
a896 2
						matchingLoader = loader;
						break;
d899 1
a899 3
				if(matchingLoader == null)
				{
					object javaClassLoader = null;
d901 1
a901 1
					javaClassLoader = JVM.Library.newAssemblyClassLoader(null);
d903 1
a903 1
					matchingLoader = new GenericClassLoader(key, javaClassLoader);
d905 1
a905 1
					JVM.Library.setWrapperForClassLoader(javaClassLoader, matchingLoader);
d907 43
a949 1
					genericClassLoaders.Add(matchingLoader);
d952 14
a965 2
			matchingLoader.RegisterInitiatingLoader(wrapper);
			return matchingLoader;
d1129 22
@


1.87
log
@Fixed handling of non-vector arrays.
@
text
@a971 9
#if STATIC_COMPILER
		internal static void PublishLibraryImplementationHelperType(Type type)
		{
			CompiledTypeWrapper typeWrapper = CompiledTypeWrapper.newInstance(type.FullName, type);
			SetWrapperForType(type, typeWrapper);
			GetBootstrapClassLoader().types[type.FullName] = typeWrapper;
		}
#endif // STATIC_COMPILER

@


1.86
log
@*** empty log message ***
@
text
@d824 1
a824 1
			else if(type.IsArray)
d829 1
a829 1
				while(elem.IsArray)
d847 8
d1248 1
a1248 1
			Debug.Assert(!type.IsArray, "!type.IsArray", type.FullName);
@


1.85
log
@*** empty log message ***
@
text
@d373 4
@


1.84
log
@*** empty log message ***
@
text
@d897 16
@


1.83
log
@*** empty log message ***
@
text
@d1344 90
@


1.82
log
@*** empty log message ***
@
text
@d884 1
a884 1
					javaClassLoader = JVM.Library.newAssemblyClassLoader();
d921 1
a921 1
						javaClassLoader = JVM.Library.newAssemblyClassLoader();
@


1.81
log
@*** empty log message ***
@
text
@d32 1
d60 1
d248 1
a248 3
			// this will create the factory as a side effect
			TypeWrapperFactory factory = GetTypeWrapperFactory();
			lock(factory)
d250 1
a250 1
				lock(types.SyncRoot)
d252 1
a252 6
					if(types.ContainsKey(f.Name))
					{
						throw new LinkageError("duplicate class definition: " + f.Name);
					}
					// mark the type as "loading in progress", so that we can detect circular dependencies.
					types.Add(f.Name, null);
d254 11
a264 5
				try
				{
					return factory.DefineClassImpl(types, f, this, protectionDomain);
				}
				catch
d266 1
a266 1
					lock(types.SyncRoot)
d268 3
a270 6
						if(types[f.Name] == null)
						{
							// if loading the class fails, we remove the indicator that we're busy loading the class,
							// because otherwise we get a ClassCircularityError if we try to load the class again.
							types.Remove(f.Name);
						}
d272 2
a273 1
					throw;
a322 1
				bool defineInProgress;
d327 1
a327 15
					defineInProgress = (type == null && types.ContainsKey(name));
				}
				if(type != null)
				{
					return type;
				}
				if(defineInProgress)
				{
					// DefineClass synchronizes on factory, so if we can obtain that
					// lock it either means that the DefineClass has finished or
					// that we're on the same thread. To distinguish between
					// the two, we check the types hashtable again and if it still
					// contains the null entry we're on the same thread and should throw
					// the ClassCircularityError.
					lock(GetTypeWrapperFactory())
d329 2
a330 1
						lock(types.SyncRoot)
d332 1
a332 1
							if(types[name] == null && types.ContainsKey(name))
a333 3
								// NOTE this can also happen if we (incorrectly) trigger a load of this class during
								// the loading of the base class, so we print a trace message here.
								Tracer.Error(Tracer.ClassLoading, "**** ClassCircularityError: {0} ****", name);
d336 7
d346 4
@


1.80
log
@*** empty log message ***
@
text
@d1068 2
a1069 1
		private bool isJava;
d1076 2
a1077 1
			isJava = AttributeHelper.IsJavaModule(assembly.GetModules()[0]);
d1081 1
a1081 1
			if(isJava)
d1083 2
a1084 1
				using(Stream s = assembly.GetManifestResourceStream("class.map"))
d1086 2
a1087 1
					if(s != null)
d1089 2
a1090 2
						nameMap = new Hashtable();
						using(System.Resources.ResourceReader rdr = new System.Resources.ResourceReader(s))
d1092 1
a1092 1
							foreach(DictionaryEntry de in rdr)
d1094 9
a1102 11
								if(de.Key.Equals("m"))
								{
									BinaryReader br = new BinaryReader(new MemoryStream((byte[])de.Value), System.Text.Encoding.UTF8);
									int count = br.ReadInt32();
									for(int i = 0; i < count; i++)
									{
										string key = br.ReadString();
										string val = br.ReadString();
										nameMap.Add(key, val);
									}
								}
d1137 18
a1154 1
		private Type GetJavaType(string name)
d1163 1
a1163 1
				Type t = GetType(n != null ? n : name);
d1192 1
a1192 1
			if(isJava)
d1194 1
a1194 2
				Type type = GetJavaType(name);
				if(type != null)
d1196 2
a1197 2
					// check the name to make sure that the canonical name was used
					if(CompiledTypeWrapper.GetName(type) == name)
d1199 5
a1203 1
						return RegisterInitiatingLoader(CompiledTypeWrapper.newInstance(name, type));
d1206 1
a1206 7
				return null;
			}
			else
			{
				// TODO should we catch ArgumentException and prohibit array, pointer and byref here?
				Type type = GetType(DotNetTypeWrapper.DemangleTypeName(name));
				if(type != null && DotNetTypeWrapper.IsAllowedOutside(type))
d1208 3
a1210 3
					TypeWrapper tw = new DotNetTypeWrapper(type);
					// check the name to make sure that the canonical name was used
					if(tw.Name == name)
d1212 6
a1217 1
						return RegisterInitiatingLoader(tw);
a1219 1
				return null;
d1221 1
d1232 10
d1243 1
a1243 1
			if(isJava)
d1273 1
a1273 1
				if(isJava)
d1336 9
@


1.79
log
@*** empty log message ***
@
text
@d1296 1
a1296 2
				tw = delegates[i].DoLoad(name);
				if(tw != null)
d1298 5
a1302 1
					return tw;
@


1.78
log
@*** empty log message ***
@
text
@d51 1
a59 1
		private TypeWrapperFactory factory;
d247 1
a247 1
			GetTypeWrapperFactory();
d281 4
a284 1
			lock(this)
d286 1
a286 4
				if(factory == null)
				{
					factory = CreateTypeWrapperFactory();
				}
a288 8
		}

		protected virtual TypeWrapperFactory CreateTypeWrapperFactory()
		{
#if COMPACT_FRAMEWORK
			throw new NoClassDefFoundError("Class loading is not supported on the Compact Framework");
#elif STATIC_COMPILER
			throw new InvalidOperationException();
d335 1
a335 1
				if(defineInProgress && factory != null)
d343 1
a343 1
					lock(factory)
@


1.77
log
@*** empty log message ***
@
text
@d42 1
a42 6
		internal abstract TypeWrapper DefineClassImpl(Hashtable types, ClassFile f, object protectionDomain);
		internal abstract string AllocMangledName(string name);
		internal abstract bool EmitDebugInfo { get; }
		internal abstract bool EmitStackTraceInfo { get; }
		internal abstract bool StrictFinalFieldSemantics { get; }
		internal abstract bool NoJNI { get; }
d60 1
d120 1
a120 1
		internal ClassLoaderWrapper(object javaClassLoader)
d122 1
d182 1
a182 1
				return factory != null && factory.EmitDebugInfo;
d190 2
a191 1
				return factory != null && factory.EmitStackTraceInfo;
d199 1
a199 1
				return factory != null && factory.StrictFinalFieldSemantics;
d207 1
a207 1
				return factory != null && factory.NoJNI;
d261 1
a261 1
					return factory.DefineClassImpl(types, f, protectionDomain);
d295 2
d298 1
a298 6
			CodeGenOptions opt = CodeGenOptions.None;
			if(System.Diagnostics.Debugger.IsAttached)
			{
				opt |= CodeGenOptions.Debug;
			}
			return new DynamicClassLoader(this, opt);
d805 6
a810 1
					wrapper = new ClassLoaderWrapper(javaClassLoader);
d1020 1
a1020 1
			: base(javaClassLoader)
d1080 1
a1080 1
			: base(javaClassLoader)
@


1.76
log
@*** empty log message ***
@
text
@a40 1
		internal abstract AssemblyBuilder AssemblyBuilder { get; }
a245 4
				if(tw.Assembly != asm)
				{
					throw new NoClassDefFoundError(f.Name + " (assembly mismatch)");
				}
@


1.75
log
@*** empty log message ***
@
text
@d45 4
d182 40
d303 6
a308 1
			return new DynamicClassLoader(this);
@


1.74
log
@*** empty log message ***
@
text
@d571 5
@


1.73
log
@*** empty log message ***
@
text
@d579 1
a579 1
				throw new ClassLoadingException(IKVM.Runtime.Util.MapException(x));
@


1.72
log
@*** empty log message ***
@
text
@d51 1
d53 2
a54 2
#if WHIDBEY && !STATIC_COMPILER
		private static readonly Hashtable reflectionOnlyClassLoaders = new Hashtable();
d56 1
d64 1
d72 1
a590 59
		internal TypeWrapper GetWrapperFromBootstrapType(Type type)
		{
			//Tracer.Info(Tracer.Runtime, "GetWrapperFromBootstrapType: {0}", type.FullName);
			Debug.Assert(!type.IsArray, "!type.IsArray", type.FullName);
#if !COMPACT_FRAMEWORK
			Debug.Assert(!(type.Assembly is AssemblyBuilder), "!(type.Assembly is AssemblyBuilder)", type.FullName);
#endif
			// only the bootstrap classloader can own compiled types
			Debug.Assert(this == GetBootstrapClassLoader(), "this == GetBootstrapClassLoader()", type.FullName);
			bool javaType = AttributeHelper.IsJavaModule(type.Module);
			string name;
			if(javaType)
			{
				name = CompiledTypeWrapper.GetName(type);
			}
			else
			{
				name = DotNetTypeWrapper.GetName(type);
				if(name == null)
				{
					return null;
				}
			}
			TypeWrapper wrapper;
			lock(types.SyncRoot)
			{
				wrapper = (TypeWrapper)types[name];
			}
			if(wrapper != null)
			{
				if(wrapper.TypeAsTBD != type && (!wrapper.IsRemapped || wrapper.TypeAsBaseType != type))
				{
					string msg = String.Format("\nTypename \"{0}\" is imported from multiple assemblies:\n{1}\n{2}\n", type.FullName, wrapper.TypeAsTBD.Assembly.FullName, type.Assembly.FullName);
					JVM.CriticalFailure(msg, null);
				}
				return wrapper;
			}
			else
			{
				if(javaType)
				{
					// since this type was compiled from Java source, we have to look for our
					// attributes
					return RegisterInitiatingLoader(CompiledTypeWrapper.newInstance(name, type));
				}
				else
				{
					if(!DotNetTypeWrapper.IsAllowedOutside(type))
					{
						return null;
					}
					// since this type was not compiled from Java source, we don't need to
					// look for our attributes, but we do need to filter unrepresentable
					// stuff (and transform some other stuff)
					return RegisterInitiatingLoader(new DotNetTypeWrapper(type));
				}
			}
		}

d733 1
d735 3
d743 1
a743 1
					bootstrapClassLoader = new BootstrapClassLoader();
d803 1
a803 1
				wrapper = GetAssemblyClassLoader(type.Assembly).GetWrapperFromBootstrapType(type);
d848 8
a855 1
					matchingLoader = new GenericClassLoader(key);
d864 1
a864 1
		internal static ClassLoaderWrapper GetAssemblyClassLoader(Assembly assembly)
d872 1
a872 2
#if WHIDBEY && !STATIC_COMPILER
			if(assembly.ReflectionOnly)
d874 2
a875 1
				lock(wrapperLock)
d877 2
a878 2
					ClassLoaderWrapper loader = (ClassLoaderWrapper)reflectionOnlyClassLoaders[assembly];
					if(loader == null)
d880 1
a880 3
						loader = new ReflectionOnlyClassLoader(assembly);
						reflectionOnlyClassLoaders[assembly] = loader;
						JVM.Library.setWrapperForClassLoader(loader.javaClassLoader, loader);
d882 16
a897 1
					return loader;
d899 1
a900 2
#endif
			return GetBootstrapClassLoader();
d966 1
a966 1
	class BootstrapClassLoader : ClassLoaderWrapper
d968 4
a971 2
		internal BootstrapClassLoader()
			: base(null)
d973 1
d976 1
a976 1
		protected override TypeWrapper LoadClassImpl(string name, bool throwClassNotFoundException)
d978 1
a978 2
			Type t = GetBootstrapTypeRaw(name);
			if(t != null)
d980 8
a987 1
				return GetWrapperFromBootstrapType(t);
d989 1
a989 1
			return DotNetTypeWrapper.CreateDotNetTypeWrapper(this, name);
d992 1
a992 2
		// NOTE this method only sees pre-compiled Java classes
		private Type GetBootstrapTypeRaw(string name)
d994 1
a994 7
#if COMPACT_FRAMEWORK
			// TODO figure this out
			return GetJavaTypeFromAssembly(JVM.CoreAssembly, name);
#else
			Assembly[] assemblies;
#if WHIDBEY
			if(JVM.IsStaticCompiler)
d996 5
a1000 1
				assemblies = AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies();
d1002 6
a1007 1
			else
d1009 5
a1013 1
				assemblies = AppDomain.CurrentDomain.GetAssemblies();
d1015 24
a1038 4
#else
			assemblies = AppDomain.CurrentDomain.GetAssemblies();
#endif
			foreach(Assembly a in assemblies)
d1040 1
a1040 1
				if(!(a is AssemblyBuilder))
d1042 1
a1042 2
					Type t = GetJavaTypeFromAssembly(a, name);
					if(t != null)
d1044 18
a1061 1
						return t;
d1065 26
a1091 1
#endif
d1094 1
a1094 1
		internal static Type GetJavaTypeFromAssembly(Assembly a, string name)
d1098 6
a1103 1
				Type t = a.GetType(name);
d1106 2
a1107 3
					// we might be looking for an inner classes
					string cname = name.Replace('$', '+');
					if(!ReferenceEquals(cname, name))
d1109 1
a1109 1
						t = a.GetType(cname);
a1112 1
					&& AttributeHelper.IsJavaModule(t.Module)
a1126 8
			catch(FileLoadException x)
			{
				// this can only happen if the assembly was loaded in the ReflectionOnly
				// context and the requested type references a type in another assembly
				// that cannot be found in the ReflectionOnly context
				// TODO figure out what other exceptions Assembly.GetType() can throw
				Tracer.Info(Tracer.Runtime, x.Message);
			}
d1130 1
a1130 1
		internal override Type GetType(string name)
d1132 1
a1132 6
			Assembly[] assemblies;
#if WHIDBEY && STATIC_COMPILER
			// mscorlib cannot be loaded in the ReflectionOnly context,
			// so we have to search that separately
			Type trycorlib = typeof(object).Assembly.GetType(name);
			if(trycorlib != null)
d1134 10
a1143 1
				return trycorlib;
d1145 1
a1145 5
			assemblies = AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies();
#else
			assemblies = AppDomain.CurrentDomain.GetAssemblies();
#endif
			foreach(Assembly a in assemblies)
d1147 7
a1153 4
				if(!(a is AssemblyBuilder))
				{
					Type t = a.GetType(name);
					if(t != null)
d1155 1
a1155 1
						return t;
d1158 1
a1159 1
			return null;
a1160 1
	}
d1162 7
a1168 10
	class GenericClassLoader : ClassLoaderWrapper
	{
		private ClassLoaderWrapper[] delegates;

		// HACK we use a ReflectionOnlyClassLoader Java peer for the time being
		internal GenericClassLoader(ClassLoaderWrapper[] delegates)
#if STATIC_COMPILER
			: base(null)
#else
			: base(JVM.Library.newReflectionOnlyClassLoader())
d1170 6
a1175 7
		{
			this.delegates = delegates;
		}

		internal bool Matches(ClassLoaderWrapper[] key)
		{
			if(key.Length == delegates.Length)
d1177 2
a1178 1
				for(int i = 0; i < key.Length; i++)
d1180 1
a1180 4
					if(key[i] != delegates[i])
					{
						return false;
					}
a1181 1
				return true;
d1183 6
a1188 6
			return false;
		}

		internal override Type GetType(string name)
		{
			foreach(ClassLoaderWrapper loader in delegates)
d1190 1
a1190 2
				Type t = loader.GetType(name);
				if(t != null)
d1192 4
a1195 1
					return t;
d1197 1
d1199 1
a1199 6
			return null;
		}

		protected override TypeWrapper LoadClassImpl(string name, bool throwClassNotFoundException)
		{
			foreach(ClassLoaderWrapper loader in delegates)
d1201 7
a1207 2
				TypeWrapper tw = loader.LoadClassByDottedNameFast(name);
				if(tw != null)
d1209 8
a1216 1
					return tw;
a1218 20
			return null;
		}
	}

#if !STATIC_COMPILER
	class ReflectionOnlyClassLoader : ClassLoaderWrapper
	{
		private Assembly assembly;
		private bool isCoreAssembly;

		internal ReflectionOnlyClassLoader(Assembly assembly)
			: base(JVM.Library.newReflectionOnlyClassLoader())
		{
			this.assembly = assembly;
			isCoreAssembly = AttributeHelper.GetRemappedClasses(assembly).Length > 0;
		}

		internal override Type GetType(string name)
		{
			return assembly.GetType(name);
d1223 6
a1228 1
			if(isCoreAssembly)
d1230 27
a1256 2
				Type t = BootstrapClassLoader.GetJavaTypeFromAssembly(assembly, name);
				if(t != null)
d1258 1
a1258 1
					return GetWrapperFromBootstrapType(t);
d1261 1
a1261 2
			TypeWrapper tw = DotNetTypeWrapper.CreateDotNetTypeWrapper(this, name);
			if(tw != null)
d1263 1
a1263 1
				return tw;
d1265 1
a1265 1
			return GetBootstrapClassLoader().LoadClassByDottedNameFast(name);
a1267 1
#endif
@


1.71
log
@*** empty log message ***
@
text
@d562 7
a568 2
			// NOTE just like Java does (I think), we take the classloader lock before calling the loadClass method
			lock(javaClassLoader)
d570 2
a571 3
				Profiler.Enter("ClassLoader.loadClass");
				TypeWrapper type;
				try
d573 1
a573 1
					type = (TypeWrapper)JVM.Library.loadClass(javaClassLoader, name);
d575 5
a579 14
				catch(Exception x)
				{
					if(!throwClassNotFoundException
						&& LoadClassCritical("java.lang.ClassNotFoundException").TypeAsBaseType.IsInstanceOfType(x))
					{
						return null;
					}
					throw new ClassLoadingException(IKVM.Runtime.Util.MapException(x));
				}
				finally
				{
					Profiler.Leave("ClassLoader.loadClass");
				}
				return type;
d581 1
@


1.70
log
@*** empty log message ***
@
text
@d345 3
a347 1
				if(outer != null)
@


1.69
log
@*** empty log message ***
@
text
@d539 16
a554 2
			// TODO consider catching the ArgumentException that MakeGenericType can throw
			return GetWrapperFromType(Whidbey.MakeGenericType(type, typeArguments));
d661 1
a661 6
			Type array = ArrayTypeWrapper.MakeArrayType(elementType, dims);
			Modifiers modifiers = Modifiers.Final | Modifiers.Abstract;
			Modifiers reflectiveModifiers = modifiers;
			modifiers |= elementTypeWrapper.Modifiers & Modifiers.Public;
			reflectiveModifiers |= elementTypeWrapper.ReflectiveModifiers & Modifiers.AccessMask;
			return RegisterInitiatingLoader(new ArrayTypeWrapper(array, modifiers, reflectiveModifiers, name, this));
@


1.68
log
@*** empty log message ***
@
text
@d1048 1
a1048 6
				if(t != null
					&& AttributeHelper.IsJavaModule(t.Module)
					&& !AttributeHelper.IsHideFromJava(t)
					&& !t.IsArray
					&& !t.IsPointer
					&& !t.IsByRef)
d1050 6
a1055 1
					return t;
a1056 2
				// HACK we might be looking for an inner classes
				t = a.GetType(name.Replace('$', '+'));
@


1.67
log
@*** empty log message ***
@
text
@d41 1
d44 1
d205 2
a206 7
			lock(this)
			{
				if(factory == null)
				{
					factory = CreateTypeWrapperFactory();
				}
			}
d238 12
a258 17
#if !COMPACT_FRAMEWORK
		internal virtual ModuleBuilder ModuleBuilder
		{
			get
			{
				lock(this)
				{
					if(factory == null)
					{
						factory = CreateTypeWrapperFactory();
					}
				}
				return factory.ModuleBuilder;
			}
		}
#endif

d1122 3
d1126 1
@


1.66
log
@*** empty log message ***
@
text
@d53 1
d866 42
d1124 54
@


1.65
log
@*** empty log message ***
@
text
@d143 1
a143 1
		private TypeWrapper RegisterInitiatingLoader(TypeWrapper tw)
d341 21
@


1.64
log
@*** empty log message ***
@
text
@d333 8
a340 10
//#if WHIDBEY
//				if(name.EndsWith("_$$$$_") && name.IndexOf("_$$$_") > 0)
//				{
//					TypeWrapper tw = LoadGenericClass(name);
//					if(tw != null)
//					{
//						return tw;
//					}
//				}
//#endif // WHIDBEY
a405 1
#if WHIDBEY
d410 5
a414 1
			// mangled(open_generic_type_name) "_$$$_" parameter_class_name ( "_$$_" parameter_class_name )* "_$$$$_"
d421 1
a421 1
			if(type == null || !type.IsGenericTypeDefinition)
d472 43
a514 1
				TypeWrapper tw = LoadClassByDottedNameFast((string)typeParamNames[i]);
d519 4
d526 1
a526 1
			return GetWrapperFromType(type.MakeGenericType(typeArguments));
a527 1
#endif // WHIDBEY
d579 4
d949 1
a949 1
			return DotNetTypeWrapper.CreateDotNetTypeWrapper(name);
d1034 7
d1073 5
d1088 5
@


1.63
log
@*** empty log message ***
@
text
@d333 10
d408 75
d789 5
d806 1
a806 1
				lock(reflectionOnlyClassLoaders)
d811 1
a811 1
						loader = new ReflectionOnlyClassLoader();
d813 1
d937 1
a937 1
		private static Type GetJavaTypeFromAssembly(Assembly a, string name)
d979 22
d1003 1
d1006 5
a1010 2
		internal ReflectionOnlyClassLoader()
			: base(null)
d1012 2
d1018 8
d1029 1
@


1.62
log
@*** empty log message ***
@
text
@d145 3
a147 2
			if(tw == null || tw.IsUnloadable || tw.IsPrimitive)
				return tw;
a159 16
					if(tw.IsArray)
					{
						TypeWrapper elem = tw;
						// TODO there should be a way to get the ultimate element type
						// without creating all the intermediate types
						while(elem.IsArray)
						{
							elem = elem.ElementTypeWrapper;
						}
						// HACK elem.ElementTypeWrapper as an evil side effect registers the initiating loader
						// so if we're the same loader, don't do it again
						if(!elem.IsPrimitive && !types.ContainsKey(elem.Name))
						{
							RegisterInitiatingLoader(elem);
						}
					}
d202 1
a202 1
			lock(types.SyncRoot)
d204 1
a204 1
				if(types.ContainsKey(f.Name))
d206 1
a206 1
					throw new LinkageError("duplicate class definition: " + f.Name);
a207 2
				// mark the type as "loading in progress", so that we can detect circular dependencies.
				types.Add(f.Name, null);
d209 1
a209 1
			try
d211 1
a211 1
				lock(this)
d213 1
a213 1
					if(factory == null)
d215 1
a215 1
						factory = CreateTypeWrapperFactory();
d217 6
d224 1
a224 5
				return factory.DefineClassImpl(types, f, protectionDomain);
			}
			catch
			{
				lock(types.SyncRoot)
d226 1
a226 1
					if(types[f.Name] == null)
d228 6
a233 3
						// if loading the class fails, we remove the indicator that we're busy loading the class,
						// because otherwise we get a ClassCircularityError if we try to load the class again.
						types.Remove(f.Name);
d235 1
a236 1
				throw;
d268 1
a268 1
			TypeWrapper type = RegisterInitiatingLoader(LoadClassByDottedNameFastImpl(name, true));
d271 1
a271 1
				return type;
d278 6
a283 1
			return RegisterInitiatingLoader(LoadClassByDottedNameFastImpl(name, false));
d296 1
d301 1
a301 10
					if(type == null && types.ContainsKey(name))
					{
						// NOTE this can also happen if we (incorrectly) trigger a load of this class during
						// the loading of the base class, so we print a trace message here.
						Tracer.Error(Tracer.ClassLoading, "**** ClassCircularityError: {0} ****", name);
						// TODO if another thread is currently defining the class we're trying to load,
						// we shouldn't throw a ClassCircularityError, but instead we should wait for the
						// other thread to finish loading the type and return that.
						throw new ClassCircularityError(name);
					}
d307 1
a307 1
				if(name.Length > 1 && name[0] == '[')
d309 7
a315 2
					int dims = 1;
					while(name[dims] == '[')
d317 1
a317 2
						dims++;
						if(dims == name.Length)
d319 7
a325 2
							// malformed class name
							return null;
d328 4
a331 41
					if(name[dims] == 'L')
					{
						if(!name.EndsWith(";") || name.Length <= dims + 2 || name[dims + 1] == '[')
						{
							// malformed class name
							return null;
						}
						string elemClass = name.Substring(dims + 1, name.Length - dims - 2);
						type = LoadClassByDottedNameFast(elemClass);
						if(type != null)
						{
							type = type.GetClassLoader().CreateArrayType(name, type, dims);
						}
						return type;
					}
					if(name.Length != dims + 1)
					{
						// malformed class name
						return null;
					}
					switch(name[dims])
					{
						case 'B':
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BYTE, dims);
						case 'C':
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.CHAR, dims);
						case 'D':
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.DOUBLE, dims);
						case 'F':
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.FLOAT, dims);
						case 'I':
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.INT, dims);
						case 'J':
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.LONG, dims);
						case 'S':
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.SHORT, dims);
						case 'Z':
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BOOLEAN, dims);
						default:
							return null;
					}
d341 57
a492 9
			TypeWrapper wrapper;
			lock(types.SyncRoot)
			{
				wrapper = (TypeWrapper)types[name];
			}
			if(wrapper != null)
			{
				return wrapper;
			}
@


1.61
log
@*** empty log message ***
@
text
@d442 1
a442 1
				if(wrapper.TypeAsTBD != type)
d447 1
d455 1
a455 1
					wrapper = CompiledTypeWrapper.newInstance(name, type);
d466 1
a466 17
					wrapper = new DotNetTypeWrapper(type);
				}
				Debug.Assert(wrapper.Name == name, "wrapper.Name == name", type.FullName);
				lock(types.SyncRoot)
				{
					// another thread may have beaten us to it and in that
					// case we don't want to overwrite the previous one
					TypeWrapper race = (TypeWrapper)types[name];
					if(race == null)
					{
						types.Add(name, wrapper);
						typeToTypeWrapper.Add(type, wrapper);
					}
					else
					{
						wrapper = race;
					}
a468 1
			return wrapper;
d484 6
a489 1
			if(wrapper == null)
d491 1
a491 38
				// .NET 1.1 has a limit of 1024 characters for type names
				if(elementType.FullName.Length >= 1024 - dims * 2)
				{
					return null;
				}
				Type array = ArrayTypeWrapper.MakeArrayType(elementType, dims);
				Modifiers modifiers = Modifiers.Final | Modifiers.Abstract;
				Modifiers reflectiveModifiers = modifiers;
				modifiers |= elementTypeWrapper.Modifiers & Modifiers.Public;
				reflectiveModifiers |= elementTypeWrapper.ReflectiveModifiers & Modifiers.AccessMask;
				wrapper = new ArrayTypeWrapper(array, modifiers, reflectiveModifiers, name, this);
				lock(types.SyncRoot)
				{
					// another thread may have beaten us to it and in that
					// case we don't want to overwrite the previous one
					TypeWrapper race = (TypeWrapper)types[name];
					if(race == null)
					{
						types.Add(name, wrapper);
#if COMPACT_FRAMEWORK
						if(!wrapper.IsGhostArray)
						{
							Debug.Assert(!typeToTypeWrapper.ContainsKey(array), name);
							typeToTypeWrapper.Add(array, wrapper);
						}
#else
						if(!(elementType is TypeBuilder) && !wrapper.IsGhostArray)
						{
							Debug.Assert(!typeToTypeWrapper.ContainsKey(array), name);
							typeToTypeWrapper.Add(array, wrapper);
						}
#endif
					}
					else
					{
						wrapper = race;
					}
				}
d493 6
a498 1
			return wrapper;
d659 1
a659 4
		// This only returns the wrapper for a Type if that wrapper has already been created, otherwise
		// it returns null
		// If the wrapper doesn't exist, that means that the type is either a .NET type or a pre-compiled Java class
		private static TypeWrapper GetWrapperFromTypeFast(Type type)
d661 1
d664 2
d667 10
a676 1
			if(wrapper == null)
d678 4
a681 2
				string name = (string)remappedTypes[type];
				if(name != null)
d683 2
a684 1
					return LoadClassCritical(name);
d686 1
d688 1
a688 10
			return wrapper;
		}

		internal static TypeWrapper GetWrapperFromType(Type type)
		{
			//Tracer.Info(Tracer.Runtime, "GetWrapperFromType: {0}", type.AssemblyQualifiedName);
			TypeWrapper.AssertFinished(type);
			Debug.Assert(!Whidbey.ContainsGenericParameters(type));
			TypeWrapper wrapper = GetWrapperFromTypeFast(type);
			if(wrapper == null)
a689 14
				Debug.Assert(type != typeof(object) && type != typeof(string));
				if(type.IsArray)
				{
					// it might be an array of a dynamically compiled Java type
					int rank = 1;
					Type elem = type.GetElementType();
					while(elem.IsArray)
					{
						rank++;
						elem = elem.GetElementType();
					}
					wrapper = GetWrapperFromType(elem);
					return wrapper.MakeArrayType(rank);
				}
d693 1
a693 1
				return GetAssemblyClassLoader(type.Assembly).GetWrapperFromBootstrapType(type);
d695 1
@


1.60
log
@*** empty log message ***
@
text
@d155 3
a157 1
						throw new LinkageError("duplicate class definition: " + tw.Name);
d280 1
a280 1
			TypeWrapper type = LoadClassByDottedNameFast(name, true);
d290 1
a290 1
			return LoadClassByDottedNameFast(name, false);
d293 1
a293 1
		internal TypeWrapper LoadClassByDottedNameFast(string name, bool throwClassNotFoundException)
d312 3
d347 1
a347 1
						return RegisterInitiatingLoader(type);
d357 1
a357 1
							return RegisterInitiatingLoader(GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BYTE, dims));
d359 1
a359 1
							return RegisterInitiatingLoader(GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.CHAR, dims));
d361 1
a361 1
							return RegisterInitiatingLoader(GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.DOUBLE, dims));
d363 1
a363 1
							return RegisterInitiatingLoader(GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.FLOAT, dims));
d365 1
a365 1
							return RegisterInitiatingLoader(GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.INT, dims));
d367 1
a367 1
							return RegisterInitiatingLoader(GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.LONG, dims));
d369 1
a369 1
							return RegisterInitiatingLoader(GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.SHORT, dims));
d371 1
a371 1
							return RegisterInitiatingLoader(GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BOOLEAN, dims));
d376 1
a376 1
				return RegisterInitiatingLoader(LoadClassImpl(name, throwClassNotFoundException));
d409 1
a409 3
				// NOTE to be safe, we register the initiating loader,
				// while we're holding the lock on the class loader object
				return RegisterInitiatingLoader(type);
d855 1
a855 21
			TypeWrapper type = DotNetTypeWrapper.CreateDotNetTypeWrapper(name);
			if(type != null)
			{
				Debug.Assert(type.Name == name, type.Name + " != " + name);
				lock(types.SyncRoot)
				{
					// another thread may have beaten us to it and in that
					// case we don't want to overwrite the previous one
					TypeWrapper race = (TypeWrapper)types[name];
					if(race == null)
					{
						types[name] = type;
					}
					else
					{
						type = race;
					}
				}
				return type;
			}
			return null;
d946 1
a946 1
			return GetBootstrapClassLoader().LoadClassByDottedNameFast(name, throwClassNotFoundException);
@


1.59
log
@*** empty log message ***
@
text
@d291 1
a291 1
		private TypeWrapper LoadClassByDottedNameFast(string name, bool throwClassNotFoundException)
d323 5
d371 21
a391 1
				if(this == GetBootstrapClassLoader())
d393 2
a394 36
					Type t = GetBootstrapTypeRaw(name);
					if(t != null)
					{
						return RegisterInitiatingLoader(GetWrapperFromBootstrapType(t));
					}
					type = DotNetTypeWrapper.CreateDotNetTypeWrapper(name);
					if(type != null)
					{
						Debug.Assert(type.Name == name, type.Name + " != " + name);
						lock(types.SyncRoot)
						{
							// another thread may have beaten us to it and in that
							// case we don't want to overwrite the previous one
							TypeWrapper race = (TypeWrapper)types[name];
							if(race == null)
							{
								types[name] = type;
							}
							else
							{
								type = race;
							}
						}
						return type;
					}
#if STATIC_COMPILER
					// NOTE it is important that this is done last, because otherwise we will
					// load the netexp generated fake types (e.g. delegate inner interface) instead
					// of having DotNetTypeWrapper generating it.
					type = GetTypeWrapperCompilerHook(name);
					if(type != null)
					{
						return type;
					}
#endif // STATIC_COMPILER
					if(javaClassLoader == null)
d398 1
d400 1
a400 5
#if !COMPACT_FRAMEWORK
				// if we're here, we're not the bootstrap class loader and don't have a java class loader,
				// that must mean that we're a ReflectionOnly class loader and we should delegate to the
				// bootstrap class loader
				if(javaClassLoader == null)
d402 1
a402 28
					return GetBootstrapClassLoader().LoadClassByDottedNameFast(name, throwClassNotFoundException);
				}
#endif
#if !STATIC_COMPILER
				// NOTE just like Java does (I think), we take the classloader lock before calling the loadClass method
				lock(javaClassLoader)
				{
					Profiler.Enter("ClassLoader.loadClass");
					try
					{
						type = (TypeWrapper)JVM.Library.loadClass(javaClassLoader, name);
					}
					catch(Exception x)
					{
						if(!throwClassNotFoundException
							&& LoadClassCritical("java.lang.ClassNotFoundException").TypeAsBaseType.IsInstanceOfType(x))
						{
							return null;
						}
						throw new ClassLoadingException(IKVM.Runtime.Util.MapException(x));
					}
					finally
					{
						Profiler.Leave("ClassLoader.loadClass");
					}
					// NOTE to be safe, we register the initiating loader,
					// while we're holding the lock on the class loader object
					return RegisterInitiatingLoader(type);
d404 4
d409 1
a409 1
				return null;
a410 5
			}
			finally
			{
				Profiler.Leave("LoadClassByDottedName");
			}
d413 1
a413 1
		private TypeWrapper GetWrapperFromBootstrapType(Type type)
a483 85
		// NOTE this method only sees pre-compiled Java classes
		private Type GetBootstrapTypeRaw(string name)
		{
#if COMPACT_FRAMEWORK
			// TODO figure this out
			return GetJavaTypeFromAssembly(JVM.CoreAssembly, name);
#else
			Assembly[] assemblies;
#if WHIDBEY
			if(JVM.IsStaticCompiler)
			{
				assemblies = AppDomain.CurrentDomain.ReflectionOnlyGetAssemblies();
			}
			else
			{
				assemblies = AppDomain.CurrentDomain.GetAssemblies();
			}
#else
			assemblies = AppDomain.CurrentDomain.GetAssemblies();
#endif
			foreach(Assembly a in assemblies)
			{
				if(!(a is AssemblyBuilder))
				{
					Type t = GetJavaTypeFromAssembly(a, name);
					if(t != null)
					{
						return t;
					}
				}
			}
			return null;
#endif
		}

		private static Type GetJavaTypeFromAssembly(Assembly a, string name)
		{
			try
			{
				Type t = a.GetType(name);
				if(t != null
					&& AttributeHelper.IsJavaModule(t.Module)
					&& !AttributeHelper.IsHideFromJava(t)
					&& !t.IsArray
					&& !t.IsPointer
					&& !t.IsByRef)
				{
					return t;
				}
				// HACK we might be looking for an inner classes
				t = a.GetType(name.Replace('$', '+'));
				if(t != null
					&& AttributeHelper.IsJavaModule(t.Module)
					&& !AttributeHelper.IsHideFromJava(t)
					&& !t.IsArray
					&& !t.IsPointer
					&& !t.IsByRef)
				{
					return t;
				}
			}
			catch(ArgumentException x)
			{
				// we can end up here because we replace the $ with a plus sign
				// (or client code did a Class.forName() on an invalid name)
				Tracer.Info(Tracer.Runtime, x.Message);
			}
			catch(FileLoadException x)
			{
				// this can only happen if the assembly was loaded in the ReflectionOnly
				// context and the requested type references a type in another assembly
				// that cannot be found in the ReflectionOnly context
				// TODO figure out what other exceptions Assembly.GetType() can throw
				Tracer.Info(Tracer.Runtime, x.Message);
			}
			return null;
		}

#if STATIC_COMPILER
		internal virtual TypeWrapper GetTypeWrapperCompilerHook(string name)
		{
			return null;
		}
#endif // STATIC_COMPILER

d844 108
d960 5
@


1.58
log
@*** empty log message ***
@
text
@d37 9
a45 1
	abstract class ClassLoaderWrapper
d56 1
d143 1
a143 1
		protected TypeWrapper RegisterInitiatingLoader(TypeWrapper tw)
d184 75
d260 1
a260 5
		// HACK the proxyClassLoader is used to dynamically load classes in the boot class loader
		// (e.g. when a Proxy is defined a boot class)
		private static DynamicClassLoader proxyClassLoader;

		internal virtual TypeWrapper DefineClass(ClassFile f, object protectionDomain)
d262 1
a262 1
			lock(wrapperLock)
d264 1
a264 1
				if(proxyClassLoader == null)
d266 4
a269 1
					proxyClassLoader = new DynamicClassLoader(null);
d271 1
a272 1
			return proxyClassLoader.DefineClass(f, protectionDomain);
d410 2
a411 2
				// that must mean that we're either the proxyClassLoader or a ReflectionOnly class loader
				// and we should delegate to the bootstrap class loader
d816 1
a816 1
					wrapper = new DynamicClassLoader(javaClassLoader);
d878 1
d880 1
@


1.57
log
@*** empty log message ***
@
text
@a44 3
#if !STATIC_COMPILER
		private static ClassLoaderWrapper systemClassLoader;
#endif
d252 1
a252 14
#if !COMPACT_FRAMEWORK
							// HACK make sure we don't go through a user class loader when creating
							// an array for a precompiled or .NET type
							// (this is to compensate for the hack that returns the system class loader
							// for precompiled classes or .NET types)
							if (type is DynamicTypeWrapper)
							{
								type = type.GetClassLoader().CreateArrayType(name, type, dims);
							}
							else
#endif
							{
								type = GetBootstrapClassLoader().CreateArrayType(name, type, dims);
							}
a720 14
		internal static ClassLoaderWrapper GetSystemClassLoader()
		{
#if STATIC_COMPILER
			// during static compilation, we don't have a system class loader
			return GetBootstrapClassLoader();
#else
			if(systemClassLoader == null)
			{
				systemClassLoader = GetClassLoaderWrapper(JVM.Library.getSystemClassLoader());
			}
			return systemClassLoader;
#endif
		}

@


1.56
log
@*** empty log message ***
@
text
@d562 1
a562 1
				Type array= ArrayTypeWrapper.MakeArrayType(elementType, dims);
@


1.55
log
@*** empty log message ***
@
text
@a39 4
#if !COMPACT_FRAMEWORK
		protected static bool arrayConstructionHack;
		protected static readonly object arrayConstructionLock = new object();
#endif
a556 5
				String netname = elementType.FullName + "[]";
				for(int i = 1; i < dims; i++)
				{
					netname += "[]";
				}
d558 1
a558 1
				if(netname.Length >= 1024)
d562 1
a562 26
				Type array;
#if !COMPACT_FRAMEWORK
				if(elementType.Module is ModuleBuilder)
				{
					// FXBUG ModuleBuilder.GetType() is broken (I think), it fires a TypeResolveEvent when
					// you try to construct an array type from an unfinished type. I don't think it should
					// do that. We have to work around that by setting a global flag (yuck) to prevent us
					// from responding to the TypeResolveEvent.
					lock(arrayConstructionLock)
					{
						arrayConstructionHack = true;
						try
						{
							array = ((ModuleBuilder)elementType.Module).GetType(netname);
						}
						finally
						{
							arrayConstructionHack = false;
						}
					}
				}
				else
#endif
				{
					array = elementType.Assembly.GetType(netname, true);
				}
@


1.54
log
@*** empty log message ***
@
text
@d141 1
a141 1
		private TypeWrapper RegisterInitiatingLoader(TypeWrapper tw)
a197 54

		internal TypeWrapper DefineNetExpType(string name, string assemblyName)
		{
			Debug.Assert(this == GetBootstrapClassLoader());
			TypeWrapper type;
			lock(types.SyncRoot)
			{
				// we need to check if we've already got it, because other classloaders than the bootstrap classloader may
				// "define" NetExp types, there is a potential race condition if multiple classloaders try to define the
				// same type simultaneously.
				type = (TypeWrapper)types[name];
				if(type != null)
				{
					return type;
				}
			}
			// The sole purpose of the netexp class is to let us load the assembly that the class lives in,
			// once we've done that, all types in it become visible.
			Assembly asm;
			try
			{
				asm = Assembly.Load(assemblyName);
			}
			catch(Exception x)
			{
				throw new NoClassDefFoundError(name + " (" + x.Message + ")");
			}
			// pre-compiled Java types can also live in a netexp referenced assembly,
			// so we have to explicitly check for those
			// (DotNetTypeWrapper.CreateDotNetTypeWrapper will refuse to return Java types).
			Type t = GetJavaTypeFromAssembly(asm, name);
			if(t != null)
			{
				return GetWrapperFromBootstrapType(t);
			}
			type = DotNetTypeWrapper.CreateDotNetTypeWrapper(name);
			if(type == null)
			{
				throw new NoClassDefFoundError(name + " not found in " + assemblyName);
			}
			lock(types.SyncRoot)
			{
				TypeWrapper race = (TypeWrapper)types[name];
				if(race == null)
				{
					types.Add(name, type);
				}
				else
				{
					type = race;
				}
			}
			return type;
		}
@


1.53
log
@*** empty log message ***
@
text
@d52 1
a52 1
		private object javaClassLoader;
a113 5
			SetJavaClassLoader(javaClassLoader);
		}

		internal void SetJavaClassLoader(object javaClassLoader)
		{
d689 1
a689 9
			return (this == GetBootstrapClassLoader()) ? null : javaClassLoader;
		}

		// When -Xbootclasspath is specified, we use a URLClassLoader as an
		// additional bootstrap class loader (this is not visible to the Java code).
		// We need to access this to be able to load resources.
		internal static object GetJavaBootstrapClassLoader()
		{
			return GetBootstrapClassLoader().javaClassLoader;
d842 1
a842 1
			if(javaClassLoader == null || GetBootstrapClassLoader().javaClassLoader == javaClassLoader)
@


1.52
log
@*** empty log message ***
@
text
@d102 5
@


1.51
log
@*** empty log message ***
@
text
@a446 1
			Debug.Assert(GetWrapperFromTypeFast(type) == null, "GetWrapperFromTypeFast(type) == null", type.FullName);
d582 8
d870 1
a870 1
		internal static TypeWrapper GetWrapperFromTypeFast(Type type)
@


1.50
log
@*** empty log message ***
@
text
@d46 3
d141 1
a141 1
		internal TypeWrapper RegisterInitiatingLoader(TypeWrapper tw)
d164 6
a169 1
						RegisterInitiatingLoader(elem);
d272 1
a272 1
			if(name.Length >= 1024)
d359 7
a365 2
					// HACK if the name contains a comma, we assume it is an assembly qualified name
					if(name.IndexOf(',') != -1)
d367 2
a368 21
						// NOTE even though we search all loaded assemblies below, we still need to do this,
						// because this call might actually trigger the load of an assembly.
						Type t = Type.GetType(name);
						if(t == null)
						{
#if !COMPACT_FRAMEWORK
							// HACK we explicitly try all loaded assemblies, to support assemblies
							// that aren't loaded in the "Load" context.
							string typeName = name.Substring(0, name.IndexOf(','));
							foreach(Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
							{
								t = asm.GetType(typeName);
								if(t != null && t.AssemblyQualifiedName == name)
								{
									break;
								}
								t = null;
							}
#endif
						}
						if(t != null)
d370 4
a373 1
							if(AttributeHelper.IsJavaModule(t.Module))
d375 1
a375 1
								return RegisterInitiatingLoader(GetWrapperFromType(t));
d379 1
a379 11
								// HACK weird way to load the .NET type wrapper that always works
								// (for remapped types as well, because netexp uses this way of
								// loading types, we need the remapped types to appear in their
								// .NET "warped" form).
								string javaName = DotNetTypeWrapper.GetName(t);
								if(javaName == null)
								{
									// some type (e.g. open generic types) are not visible from Java
									return null;
								}
								return LoadClassByDottedNameFast(javaName, throwClassNotFoundException);
d382 1
d384 6
a389 2
					// TODO why is this check here and not at the top of the method?
					if(name != "")
d391 1
a391 33
						Type t = GetBootstrapTypeRaw(name);
						if(t != null)
						{
							return RegisterInitiatingLoader(GetWrapperFromBootstrapType(t));
						}
						type = DotNetTypeWrapper.CreateDotNetTypeWrapper(name);
						if(type != null)
						{
							Debug.Assert(type.Name == name, type.Name + " != " + name);
							lock(types.SyncRoot)
							{
								// another thread may have beaten us to it and in that
								// case we don't want to overwrite the previous one
								TypeWrapper race = (TypeWrapper)types[name];
								if(race == null)
								{
									types[name] = type;
								}
								else
								{
									type = race;
								}
							}
							return type;
						}
						// NOTE it is important that this is done last, because otherwise we will
						// load the netexp generated fake types (e.g. delegate inner interface) instead
						// of having DotNetTypeWrapper generating it.
						type = GetTypeWrapperCompilerHook(name);
						if(type != null)
						{
							return type;
						}
d393 1
d400 4
a403 1
				if(this == proxyClassLoader)
d473 1
a473 1
					string msg = String.Format("\nTypename \"{0}\" is imported from multiple assemblies:\n{1}\n{2}\n", type.FullName, wrapper.Assembly.FullName, type.Assembly.FullName);
d487 4
d517 1
a517 1
		internal Type GetBootstrapTypeRaw(string name)
d525 1
a525 1
			if(JVM.IsStaticCompiler || JVM.IsIkvmStub)
d558 4
a561 1
					&& !AttributeHelper.IsHideFromJava(t))
d569 4
a572 1
					&& !AttributeHelper.IsHideFromJava(t))
d586 1
d591 1
d903 2
a904 4
				// was "loaded" by the bootstrap classloader
				// TODO think up a scheme to deal with .NET types that have the same name. Since all .NET types
				// appear in the boostrap classloader, we need to devise a scheme to mangle the class name
				return GetBootstrapClassLoader().GetWrapperFromBootstrapType(type);
d909 25
d1004 8
@


1.49
log
@*** empty log message ***
@
text
@a30 1
using System.Xml;
d46 1
d48 1
d444 1
d470 3
d852 1
d854 2
a855 4
			if(JVM.IsStaticCompiler)
			{
				return GetBootstrapClassLoader();
			}
d861 1
d863 2
a864 1
	
d882 1
d942 1
d949 1
@


1.48
log
@*** empty log message ***
@
text
@d307 2
d835 1
a835 1
			lock(typeof(ClassLoaderWrapper))
@


1.47
log
@*** empty log message ***
@
text
@d174 4
d180 8
a187 1
			throw JavaException.NoClassDefFoundError("Dynamic class loading is not supported by this class loader");			
d435 6
@


1.46
log
@*** empty log message ***
@
text
@d38 1
a38 1
	class ClassLoaderWrapper
d42 2
a43 9
		private static bool arrayConstructionHack;
		private static readonly object arrayConstructionLock = new object();
		private static readonly Hashtable dynamicTypes = Hashtable.Synchronized(new Hashtable());
		// FXBUG moduleBuilder is static, because multiple dynamic assemblies is broken (TypeResolve doesn't fire)
		// so for the time being, we share one dynamic assembly among all classloaders
		private static ModuleBuilder moduleBuilder;
		private static bool saveDebugImage;
		private static Hashtable nameClashHash = new Hashtable();
		private static ArrayList saveDebugAssemblies;
d49 1
a49 1
		private Hashtable types = new Hashtable();
a51 2
		private static int instanceCounter = 0;
		private int instanceId = System.Threading.Interlocked.Increment(ref instanceCounter);
a62 5
#if !COMPACT_FRAMEWORK
			// TODO AppDomain.TypeResolve requires ControlAppDomain permission, but if we don't have that,
			// we should handle that by disabling dynamic class loading
			AppDomain.CurrentDomain.TypeResolve += new ResolveEventHandler(OnTypeResolve);
#endif
a102 39
#if !COMPACT_FRAMEWORK
		private static Assembly OnTypeResolve(object sender, ResolveEventArgs args)
		{
			lock(arrayConstructionLock)
			{
				Tracer.Info(Tracer.ClassLoading, "OnTypeResolve: {0} (arrayConstructionHack = {1})", args.Name, arrayConstructionHack);
				if(arrayConstructionHack)
				{
					return null;
				}
			}
			TypeWrapper type = (TypeWrapper)dynamicTypes[args.Name];
			if(type == null)
			{
				return null;
			}
			// During static compilation, a TypeResolve event should never trigger a finish.
			if(JVM.IsStaticCompilerPhase1)
			{
				JVM.CriticalFailure("Finish triggered during phase 1 of compilation.", null);
				return null;
			}
			try
			{
				type.Finish();
			}
			catch(RetargetableJavaException x)
			{
				throw x.ToJava();
			}
			// NOTE We used to remove the type from the hashtable here, but that creates a race condition if
			// another thread also fires the OnTypeResolve event while we're baking the type.
			// I really would like to remove the type from the hashtable, but at the moment I don't see
			// any way of doing that that wouldn't cause this race condition.
			//dynamicTypes.Remove(args.Name);
			return type.TypeAsTBD.Assembly;
		}
#endif

d174 1
a174 4
		// FXBUG This mangles type names, to enable different class loaders loading classes with the same names.
		// We used to support this by using an assembly per class loader instance, but because
		// of the CLR TypeResolve bug, we put all types in a single assembly for now.
		internal string MangleTypeName(string name)
d176 8
a183 1
			lock(nameClashHash.SyncRoot)
d185 5
a189 2
				// FXBUG the 1.1 CLR doesn't like type names that end with a period.
				if(nameClashHash.ContainsKey(name) || name.EndsWith("."))
d191 33
a223 5
					if(JVM.IsStaticCompiler)
					{
						Tracer.Warning(Tracer.Compiler, "Class name clash: {0}", name);
					}
					return name + "/" + instanceId;
d227 1
a227 2
					nameClashHash.Add(name, name);
					return name;
d230 1
a679 118
#if !COMPACT_FRAMEWORK
		internal TypeWrapper DefineClass(ClassFile f, object protectionDomain)
		{
			string dotnetAssembly = f.IKVMAssemblyAttribute;
			if(dotnetAssembly != null)
			{
				// HACK only the bootstrap classloader can define .NET types (but for convenience, we do
				// allow other class loaders to call DefineClass for them)
				// TODO reconsider this, it might be a better idea to only allow netexp generated jars on the bootclasspath
				return GetBootstrapClassLoader().DefineNetExpType(f.Name, dotnetAssembly);
			}
			lock(types.SyncRoot)
			{
				if(types.ContainsKey(f.Name))
				{
					throw new LinkageError("duplicate class definition: " + f.Name);
				}
				// mark the type as "loading in progress", so that we can detect circular dependencies.
				types.Add(f.Name, null);
			}
			try
			{
				TypeWrapper type = CreateDynamicTypeWrapper(f, this, protectionDomain);
				lock(types.SyncRoot)
				{
					// in very extreme conditions another thread may have beaten us to it
					// and loaded a class with the same name, in that case we'll leak
					// the defined DynamicTypeWrapper (or rather the Reflection.Emit
					// defined type).
					TypeWrapper race = (TypeWrapper)types[f.Name];
					if(race == null)
					{
						Debug.Assert(!dynamicTypes.ContainsKey(type.TypeAsTBD.FullName));
						dynamicTypes.Add(type.TypeAsTBD.FullName, type);
						types[f.Name] = type;
					}
					else
					{
						throw new LinkageError("duplicate class definition: " + f.Name);
					}
				}
				return type;
			}
			catch
			{
				lock(types.SyncRoot)
				{
					if(types[f.Name] == null)
					{
						// if loading the class fails, we remove the indicator that we're busy loading the class,
						// because otherwise we get a ClassCircularityError if we try to load the class again.
						types.Remove(f.Name);
					}
				}
				throw;
			}
		}

		protected virtual TypeWrapper CreateDynamicTypeWrapper(ClassFile f, ClassLoaderWrapper loader, object protectionDomain)
		{
			return new DynamicTypeWrapper(f, loader, protectionDomain);
		}

		private TypeWrapper DefineNetExpType(string name, string assemblyName)
		{
			Debug.Assert(this == GetBootstrapClassLoader());
			TypeWrapper type;
			lock(types.SyncRoot)
			{
				// we need to check if we've already got it, because other classloaders than the bootstrap classloader may
				// "define" NetExp types, there is a potential race condition if multiple classloaders try to define the
				// same type simultaneously.
				type = (TypeWrapper)types[name];
				if(type != null)
				{
					return type;
				}
			}
			// The sole purpose of the netexp class is to let us load the assembly that the class lives in,
			// once we've done that, all types in it become visible.
			Assembly asm;
			try
			{
				asm = Assembly.Load(assemblyName);
			}
			catch(Exception x)
			{
				throw new NoClassDefFoundError(name + " (" + x.Message + ")");
			}
			// pre-compiled Java types can also live in a netexp referenced assembly,
			// so we have to explicitly check for those
			// (DotNetTypeWrapper.CreateDotNetTypeWrapper will refuse to return Java types).
			Type t = GetJavaTypeFromAssembly(asm, name);
			if(t != null)
			{
				return GetWrapperFromBootstrapType(t);
			}
			type = DotNetTypeWrapper.CreateDotNetTypeWrapper(name);
			if(type == null)
			{
				throw new NoClassDefFoundError(name + " not found in " + assemblyName);
			}
			lock(types.SyncRoot)
			{
				TypeWrapper race = (TypeWrapper)types[name];
				if(race == null)
				{
					types.Add(name, type);
				}
				else
				{
					type = race;
				}
			}
			return type;
		}
#endif

a692 108
#if !COMPACT_FRAMEWORK
		internal static void PrepareForSaveDebugImage()
		{
			Debug.Assert(moduleBuilder == null);
			saveDebugImage = true;
		}

		internal static bool IsSaveDebugImage
		{
			get
			{
				return saveDebugImage;
			}
		}

		internal static void FinishAll()
		{
			JVM.FinishingForDebugSave = true;
			while(dynamicTypes.Count > 0)
			{
				ArrayList l = new ArrayList(dynamicTypes.Values);
				foreach(TypeWrapper tw in l)
				{
					string name = tw.TypeAsTBD.FullName;
					Tracer.Info(Tracer.Runtime, "Finishing {0}", name);
					tw.Finish();
					dynamicTypes.Remove(name);
				}
			}
		}

		internal static void SaveDebugImage(object mainClass)
		{
			FinishAll();
			// HACK use reflection to get the type from the class
			TypeWrapper mainTypeWrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(mainClass);
			mainTypeWrapper.Finish();
			Type mainType = mainTypeWrapper.TypeAsTBD;
			MethodInfo main = mainType.GetMethod("main", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { typeof(string[]) }, null);
			AssemblyBuilder asm = ((AssemblyBuilder)moduleBuilder.Assembly);
			asm.SetEntryPoint(main, PEFileKinds.ConsoleApplication);
			asm.Save("ikvmdump.exe");
			if(saveDebugAssemblies != null)
			{
				foreach(AssemblyBuilder ab in saveDebugAssemblies)
				{
					ab.Save(ab.GetName().Name + ".dll");
				}
			}
		}

		internal static void RegisterForSaveDebug(AssemblyBuilder ab)
		{
			if(saveDebugAssemblies == null)
			{
				saveDebugAssemblies = new ArrayList();
			}
			saveDebugAssemblies.Add(ab);
		}

		internal ModuleBuilder ModuleBuilder
		{
			get
			{
				lock(this)
				{
					if(moduleBuilder == null)
					{
						moduleBuilder = CreateModuleBuilder();
					}
					return moduleBuilder;
				}
			}
		}

		protected virtual ModuleBuilder CreateModuleBuilder()
		{
			AssemblyName name = new AssemblyName();
			if(saveDebugImage)
			{
				name.Name = "ikvmdump";
			}
			else
			{
				name.Name = "ikvm_dynamic_assembly__" + instanceId + "__" + (uint)Environment.TickCount;
			}
			DateTime now = DateTime.Now;
			name.Version = new Version(now.Year, (now.Month * 100) + now.Day, (now.Hour * 100) + now.Minute, (now.Second * 1000) + now.Millisecond);
			AssemblyBuilder assemblyBuilder;
#if WHIDBEY
			if(JVM.IsIkvmStub)
			{
				assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.ReflectionOnly, null, null, null, null, null, true);
			}
			else
#endif
			assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, saveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run, null, null, null, null, null, true);
			CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, JVM.Debug });
			assemblyBuilder.SetCustomAttribute(debugAttr);
			ModuleBuilder moduleBuilder = saveDebugImage ? assemblyBuilder.DefineDynamicModule("ikvmdump.exe", "ikvmdump.exe", JVM.Debug) : assemblyBuilder.DefineDynamicModule(name.Name, JVM.Debug);
			if(!JVM.NoStackTraceInfo)
			{
				AttributeHelper.SetSourceFile(moduleBuilder, null);
			}
			return moduleBuilder;
		}
#endif

d820 1
a820 1
					bootstrapClassLoader = new ClassLoaderWrapper(null);
d851 1
a851 1
					wrapper = new ClassLoaderWrapper(javaClassLoader);
d969 8
@


1.45
log
@*** empty log message ***
@
text
@d390 7
a396 1
								return LoadClassByDottedNameFast(DotNetTypeWrapper.GetName(t), throwClassNotFoundException);
d1108 1
d1125 1
@


1.44
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
d922 6
a927 1
			return saveDebugImage ? assemblyBuilder.DefineDynamicModule("ikvmdump.exe", "ikvmdump.exe", JVM.Debug) : assemblyBuilder.DefineDynamicModule(name.Name, JVM.Debug);
@


1.43
log
@*** empty log message ***
@
text
@d95 1
d545 1
a545 1
			if(JVM.IsStaticCompiler)
d911 9
a919 1
			AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, saveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run, null, null, null, null, null, true);
@


1.42
log
@*** empty log message ***
@
text
@d25 2
d28 1
a28 1
using System.Reflection;
d40 2
a43 1
		private static readonly object wrapperLock = new object();
d45 7
a57 6
		// FXBUG moduleBuilder is static, because multiple dynamic assemblies is broken (TypeResolve doesn't fire)
		// so for the time being, we share one dynamic assembly among all classloaders
		private static ModuleBuilder moduleBuilder;
		private static bool saveDebugImage;
		private static Hashtable nameClashHash = new Hashtable();
		private static Assembly coreAssembly;	// this is the assembly that contains the remapped and core classes
a59 1
		private static ArrayList saveDebugAssemblies;
d72 1
d76 1
d91 3
a93 6
			Debug.Assert(coreAssembly == null);

			// if we're compiling the core, impl will be null
			object impl = JVM.Library;

			if(impl != null)
d95 1
a95 3
				coreAssembly = impl.GetType().Assembly;

				object[] remapped = coreAssembly.GetCustomAttributes(typeof(RemappedClassAttribute), false);
d113 1
a113 1
			return type.Assembly == coreAssembly;
d116 1
d153 1
d225 1
d249 1
d310 1
d318 1
d362 1
d375 1
d379 1
a379 1
							if(t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d472 1
d474 1
d477 1
a477 1
			bool javaType = type.Module.IsDefined(typeof(JavaModuleAttribute), false);
d538 18
a555 1
			foreach(Assembly a in AppDomain.CurrentDomain.GetAssemblies())
d567 1
d576 1
a576 1
					&& t.Module.IsDefined(typeof(JavaModuleAttribute), false)
d584 1
a584 1
					&& t.Module.IsDefined(typeof(JavaModuleAttribute), false)
d630 1
d651 1
d668 7
d680 1
d691 1
d807 1
d822 1
d915 1
d931 3
d935 1
@


1.41
log
@*** empty log message ***
@
text
@d306 10
a315 1
							type = type.GetClassLoader().CreateArrayType(name, type, dims);
@


1.40
log
@*** empty log message ***
@
text
@a35 13
	class IdentityProvider : IHashCodeProvider, IComparer
	{
		public int GetHashCode(object obj)
		{
			return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(obj);
		}

		public int Compare(object x, object y)
		{
			return x == y ? 0 : 1;
		}
	}

d40 1
a40 2
		private static readonly IdentityProvider identityProvider = new IdentityProvider();
		private static readonly Hashtable javaClassLoaderToClassLoaderWrapper = new Hashtable(identityProvider, identityProvider);
d42 1
a42 1
		private static readonly Hashtable typeToTypeWrapper = Hashtable.Synchronized(new Hashtable(identityProvider, identityProvider));
d1015 1
a1015 1
			lock(javaClassLoaderToClassLoaderWrapper.SyncRoot)
d1017 1
a1017 1
				ClassLoaderWrapper wrapper = (ClassLoaderWrapper)javaClassLoaderToClassLoaderWrapper[javaClassLoader];
d1021 1
a1021 1
					javaClassLoaderToClassLoaderWrapper[javaClassLoader] = wrapper;
@


1.39
log
@*** empty log message ***
@
text
@d203 1
a203 1
			if(tw.IsUnloadable || tw.IsPrimitive)
@


1.38
log
@*** empty log message ***
@
text
@d552 3
a554 1
				if(t != null && t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d560 3
a562 1
				if(t != null && t.Module.IsDefined(typeof(JavaModuleAttribute), false))
@


1.37
log
@*** empty log message ***
@
text
@d263 1
a263 1
			TypeWrapper type = LoadClassByDottedNameFast(name);
d273 5
d386 1
a386 1
								return LoadClassByDottedName(DotNetTypeWrapper.GetName(t));
d442 5
@


1.36
log
@*** empty log message ***
@
text
@a272 4
			if(name == null)
			{
				throw new NullReferenceException();
			}
d435 4
@


1.35
log
@*** empty log message ***
@
text
@d789 1
d797 1
a797 1
					tw.Finish(true);
@


1.34
log
@*** empty log message ***
@
text
@d145 6
@


1.33
log
@*** empty log message ***
@
text
@d471 9
a479 1
			if(wrapper == null)
@


1.32
log
@*** empty log message ***
@
text
@d437 3
a440 1
				return RegisterInitiatingLoader(type);
@


1.31
log
@*** empty log message ***
@
text
@d195 36
d315 1
a315 1
						return type;
d325 1
a325 1
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BYTE, dims);
d327 1
a327 1
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.CHAR, dims);
d329 1
a329 1
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.DOUBLE, dims);
d331 1
a331 1
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.FLOAT, dims);
d333 1
a333 1
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.INT, dims);
d335 1
a335 1
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.LONG, dims);
d337 1
a337 1
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.SHORT, dims);
d339 1
a339 1
							return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BOOLEAN, dims);
d371 1
a371 1
								return GetWrapperFromType(t);
d389 1
a389 1
							return GetWrapperFromBootstrapType(t);
d438 1
a438 1
				return type;
d665 1
a665 1
						type = race;
@


1.30
log
@*** empty log message ***
@
text
@d36 13
d52 5
a56 5
		private static object arrayConstructionLock = new object();
		private static Hashtable javaClassLoaderToClassLoaderWrapper = new Hashtable();
		private static Hashtable dynamicTypes = Hashtable.Synchronized(new Hashtable());
		// TODO typeToTypeWrapper should be an identity hashtable
		private static Hashtable typeToTypeWrapper = Hashtable.Synchronized(new Hashtable());
d186 1
a186 1
		// (this exists solely for DynamicTypeWrapper.SetupGhosts)
a401 13
				// NOTE we're caching types loaded by parent classloaders as well!
				// TODO this isn't correct, but it gives us a huge perf gain,
				// if we don't do this, Eclipse startup time goes from 52 seconds to 1 minute 30 seconds!
				if(type.GetClassLoader() != this)
				{
					lock(types.SyncRoot)
					{
						if(!types.ContainsKey(name))
						{
							types.Add(name, type);
						}
					}
				}
@


1.29
log
@*** empty log message ***
@
text
@d487 1
a487 2
			Type t = a.GetType(name);
			if(t != null && t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d489 11
a499 1
				return t;
d501 1
a501 3
			// HACK we might be looking for an inner classes
			t = a.GetType(name.Replace('$', '+'));
			if(t != null && t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d503 3
a505 1
				return t;
@


1.28
log
@*** empty log message ***
@
text
@a798 1
			ModuleBuilder moduleBuilder = saveDebugImage ? assemblyBuilder.DefineDynamicModule("ikvmdump.exe", "ikvmdump.exe", JVM.Debug) : assemblyBuilder.DefineDynamicModule(name.Name, JVM.Debug);
d801 1
a801 1
			return moduleBuilder;
@


1.27
log
@*** empty log message ***
@
text
@d733 2
a734 1
					Tracer.Info(Tracer.Runtime, "Finishing {0} for debug image", tw.TypeAsTBD.FullName);
d736 1
a736 1
					dynamicTypes.Remove(tw.TypeAsTBD.FullName);
@


1.26
log
@*** empty log message ***
@
text
@a32 1
using IKVM.Internal;
d34 1
a34 1
class ClassLoaderWrapper
d36 1
a36 24
	private static bool arrayConstructionHack;
	private static object arrayConstructionLock = new object();
	private static Hashtable javaClassLoaderToClassLoaderWrapper = new Hashtable();
	private static Hashtable dynamicTypes = Hashtable.Synchronized(new Hashtable());
	// TODO typeToTypeWrapper should be an identity hashtable
	private static Hashtable typeToTypeWrapper = Hashtable.Synchronized(new Hashtable());
	private static ClassLoaderWrapper bootstrapClassLoader;
	private static ClassLoaderWrapper systemClassLoader;
	private object javaClassLoader;
	private Hashtable types = new Hashtable();
	private ArrayList nativeLibraries;
	// FXBUG moduleBuilder is static, because multiple dynamic assemblies is broken (TypeResolve doesn't fire)
	// so for the time being, we share one dynamic assembly among all classloaders
	private static ModuleBuilder moduleBuilder;
	private static bool saveDebugImage;
	private static Hashtable nameClashHash = new Hashtable();
	private static Assembly coreAssembly;	// this is the assembly that contains the remapped and core classes
	private static Hashtable remappedTypes = new Hashtable();
	private static int instanceCounter = 0;
	private static ArrayList saveDebugAssemblies;
	private int instanceId = System.Threading.Interlocked.Increment(ref instanceCounter);

	// HACK this is used by the ahead-of-time compiler to overrule the bootstrap classloader
	internal static void SetBootstrapClassLoader(ClassLoaderWrapper bootstrapClassLoader)
d38 53
a90 1
		Debug.Assert(ClassLoaderWrapper.bootstrapClassLoader == null);
d92 3
a94 2
		ClassLoaderWrapper.bootstrapClassLoader = bootstrapClassLoader;
	}
d96 15
a110 16
	static ClassLoaderWrapper()
	{
		// TODO AppDomain.TypeResolve requires ControlAppDomain permission, but if we don't have that,
		// we should handle that by disabling dynamic class loading
		AppDomain.CurrentDomain.TypeResolve += new ResolveEventHandler(OnTypeResolve);
		typeToTypeWrapper[PrimitiveTypeWrapper.BOOLEAN.TypeAsTBD] = PrimitiveTypeWrapper.BOOLEAN;
		typeToTypeWrapper[PrimitiveTypeWrapper.BYTE.TypeAsTBD] = PrimitiveTypeWrapper.BYTE;
		typeToTypeWrapper[PrimitiveTypeWrapper.CHAR.TypeAsTBD] = PrimitiveTypeWrapper.CHAR;
		typeToTypeWrapper[PrimitiveTypeWrapper.DOUBLE.TypeAsTBD] = PrimitiveTypeWrapper.DOUBLE;
		typeToTypeWrapper[PrimitiveTypeWrapper.FLOAT.TypeAsTBD] = PrimitiveTypeWrapper.FLOAT;
		typeToTypeWrapper[PrimitiveTypeWrapper.INT.TypeAsTBD] = PrimitiveTypeWrapper.INT;
		typeToTypeWrapper[PrimitiveTypeWrapper.LONG.TypeAsTBD] = PrimitiveTypeWrapper.LONG;
		typeToTypeWrapper[PrimitiveTypeWrapper.SHORT.TypeAsTBD] = PrimitiveTypeWrapper.SHORT;
		typeToTypeWrapper[PrimitiveTypeWrapper.VOID.TypeAsTBD] = PrimitiveTypeWrapper.VOID;
		LoadRemappedTypes();
	}
d112 4
a115 6
	internal static void LoadRemappedTypes()
	{
		Debug.Assert(coreAssembly == null);

		// if we're compiling the core, impl will be null
		object impl = JVM.Library;
d117 1
a117 1
		if(impl != null)
d119 1
a119 4
			coreAssembly = impl.GetType().Assembly;

			object[] remapped = coreAssembly.GetCustomAttributes(typeof(RemappedClassAttribute), false);
			if(remapped.Length > 0)
d121 2
a122 1
				foreach(RemappedClassAttribute r in remapped)
d124 1
a124 2
					Tracer.Info(Tracer.Runtime, "Remapping type {0} to {1}", r.RemappedType, r.Name);
					remappedTypes.Add(r.RemappedType, r.Name);
d127 10
a136 1
			else
d138 1
a138 1
				JVM.CriticalFailure("Failed to find core classes in core library", null);
d140 6
a146 1
	}
d148 1
a148 8
	internal static bool IsCoreAssemblyType(Type type)
	{
		return type.Assembly == coreAssembly;
	}

	private static Assembly OnTypeResolve(object sender, ResolveEventArgs args)
	{
		lock(arrayConstructionLock)
d150 1
a150 5
			Tracer.Info(Tracer.ClassLoading, "OnTypeResolve: {0} (arrayConstructionHack = {1})", args.Name, arrayConstructionHack);
			if(arrayConstructionHack)
			{
				return null;
			}
d152 2
a153 2
		TypeWrapper type = (TypeWrapper)dynamicTypes[args.Name];
		if(type == null)
d155 1
a155 1
			return null;
d157 2
a158 1
		try
d160 1
a160 1
			type.Finish();
d162 2
a163 1
		catch(RetargetableJavaException x)
d165 5
a169 1
			throw x.ToJava();
a170 12
		// NOTE We used to remove the type from the hashtable here, but that creates a race condition if
		// another thread also fires the OnTypeResolve event while we're baking the type.
		// I really would like to remove the type from the hashtable, but at the moment I don't see
		// any way of doing that that wouldn't cause this race condition.
		//dynamicTypes.Remove(args.Name);
		return type.TypeAsTBD.Assembly;
	}

	internal ClassLoaderWrapper(object javaClassLoader)
	{
		SetJavaClassLoader(javaClassLoader);
	}
d172 3
a174 24
	internal void SetJavaClassLoader(object javaClassLoader)
	{
		this.javaClassLoader = javaClassLoader;
	}

	internal static bool IsRemappedType(Type type)
	{
		return remappedTypes.ContainsKey(type);
	}

	internal void SetRemappedType(Type type, TypeWrapper tw)
	{
		Debug.Assert(!types.ContainsKey(tw.Name));
		types.Add(tw.Name, tw);
		Debug.Assert(!typeToTypeWrapper.ContainsKey(type));
		typeToTypeWrapper.Add(type, tw);
		remappedTypes.Add(type, type);
	}

	// HACK return the TypeWrapper if it is already loaded
	// (this exists solely for DynamicTypeWrapper.SetupGhosts)
	internal TypeWrapper GetLoadedClass(string name)
	{
		lock(types.SyncRoot)
d176 4
a179 1
			return (TypeWrapper)types[name];
a180 1
	}
d182 4
a185 6
	// FXBUG This mangles type names, to enable different class loaders loading classes with the same names.
	// We used to support this by using an assembly per class loader instance, but because
	// of the CLR TypeResolve bug, we put all types in a single assembly for now.
	internal string MangleTypeName(string name)
	{
		lock(nameClashHash.SyncRoot)
d187 1
a187 2
			// FXBUG the 1.1 CLR doesn't like type names that end with a period.
			if(nameClashHash.ContainsKey(name) || name.EndsWith("."))
d189 10
a198 1
				if(JVM.IsStaticCompiler)
d200 2
a201 1
					Tracer.Warning(Tracer.Compiler, "Class name clash: {0}", name);
a202 6
				return name + "/" + instanceId;
			}
			else
			{
				nameClashHash.Add(name, name);
				return name;
a204 1
	}
d206 1
a206 4
	internal TypeWrapper LoadClassByDottedName(string name)
	{
		TypeWrapper type = LoadClassByDottedNameFast(name);
		if(type != null)
d208 6
a213 1
			return type;
a214 2
		throw new ClassNotFoundException(name);
	}
d216 1
a216 8
	internal TypeWrapper LoadClassByDottedNameFast(string name)
	{
		if(name == null)
		{
			throw new NullReferenceException();
		}
		// .NET 1.1 has a limit of 1024 characters for type names
		if(name.Length >= 1024)
d218 1
a218 7
			return null;
		}
		Profiler.Enter("LoadClassByDottedName");
		try
		{
			TypeWrapper type;
			lock(types.SyncRoot)
d220 1
a220 8
				type = (TypeWrapper)types[name];
				if(type == null && types.ContainsKey(name))
				{
					// NOTE this can also happen if we (incorrectly) trigger a load of this class during
					// the loading of the base class, so we print a trace message here.
					Tracer.Error(Tracer.ClassLoading, "**** ClassCircularityError: {0} ****", name);
					throw new ClassCircularityError(name);
				}
d222 2
a223 1
			if(type != null)
d225 1
a225 1
				return type;
d227 2
a228 1
			if(name.Length > 1 && name[0] == '[')
d230 2
a231 2
				int dims = 1;
				while(name[dims] == '[')
d233 2
a234 5
					dims++;
				}
				if(name[dims] == 'L')
				{
					if(!name.EndsWith(";") || name.Length <= dims + 2 || name[dims + 1] == '[')
d236 4
a239 2
						// malformed class name
						return null;
a240 7
					string elemClass = name.Substring(dims + 1, name.Length - dims - 2);
					type = LoadClassByDottedNameFast(elemClass);
					if(type != null)
					{
						type = type.GetClassLoader().CreateArrayType(name, type, dims);
					}
					return type;
d242 1
a242 1
				if(name.Length != dims + 1)
d244 1
a244 2
					// malformed class name
					return null;
d246 1
a246 1
				switch(name[dims])
d248 4
a251 42
					case 'B':
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BYTE, dims);
					case 'C':
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.CHAR, dims);
					case 'D':
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.DOUBLE, dims);
					case 'F':
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.FLOAT, dims);
					case 'I':
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.INT, dims);
					case 'J':
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.LONG, dims);
					case 'S':
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.SHORT, dims);
					case 'Z':
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BOOLEAN, dims);
					default:
						return null;
				}
			}
			if(this == GetBootstrapClassLoader())
			{
				// HACK if the name contains a comma, we assume it is an assembly qualified name
				if(name.IndexOf(',') != -1)
				{
					// NOTE even though we search all loaded assemblies below, we still need to do this,
					// because this call might actually trigger the load of an assembly.
					Type t = Type.GetType(name);
					if(t == null)
					{
						// HACK we explicitly try all loaded assemblies, to support assemblies
						// that aren't loaded in the "Load" context.
						string typeName = name.Substring(0, name.IndexOf(','));
						foreach(Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
						{
							t = asm.GetType(typeName);
							if(t != null && t.AssemblyQualifiedName == name)
							{
								break;
							}
							t = null;
						}
d253 1
a253 1
					if(t != null)
d255 1
a255 1
						if(t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d257 2
a258 1
							return GetWrapperFromType(t);
d260 3
a262 1
						else
d264 1
a264 5
							// HACK weird way to load the .NET type wrapper that always works
							// (for remapped types as well, because netexp uses this way of
							// loading types, we need the remapped types to appear in their
							// .NET "warped" form).
							return LoadClassByDottedName(DotNetTypeWrapper.GetName(t));
d266 27
d295 1
a295 2
				// TODO why is this check here and not at the top of the method?
				if(name != "")
d297 2
a298 2
					Type t = GetBootstrapTypeRaw(name);
					if(t != null)
d300 19
a318 7
						return GetWrapperFromBootstrapType(t);
					}
					type = DotNetTypeWrapper.CreateDotNetTypeWrapper(name);
					if(type != null)
					{
						Debug.Assert(type.Name == name, type.Name + " != " + name);
						lock(types.SyncRoot)
d320 1
a320 4
							// another thread may have beaten us to it and in that
							// case we don't want to overwrite the previous one
							TypeWrapper race = (TypeWrapper)types[name];
							if(race == null)
d322 1
a322 1
								types[name] = type;
d326 5
a330 1
								type = race;
a332 1
						return type;
d334 38
a371 5
					// NOTE it is important that this is done last, because otherwise we will
					// load the netexp generated fake types (e.g. delegate inner interface) instead
					// of having DotNetTypeWrapper generating it.
					type = GetTypeWrapperCompilerHook(name);
					if(type != null)
d373 1
a373 1
						return type;
d376 2
a377 1
				if(javaClassLoader == null)
d379 9
a387 1
					return null;
d389 4
a392 6
			}
			// NOTE just like Java does (I think), we take the classloader lock before calling the loadClass method
			lock(javaClassLoader)
			{
				Profiler.Enter("ClassLoader.loadClass");
				try
d394 7
a400 5
					type = (TypeWrapper)JVM.Library.loadClass(javaClassLoader, name);
				}
				finally
				{
					Profiler.Leave("ClassLoader.loadClass");
d402 1
d404 1
a404 4
			// NOTE we're caching types loaded by parent classloaders as well!
			// TODO this isn't correct, but it gives us a huge perf gain,
			// if we don't do this, Eclipse startup time goes from 52 seconds to 1 minute 30 seconds!
			if(type.GetClassLoader() != this)
d406 1
a406 7
				lock(types.SyncRoot)
				{
					if(!types.ContainsKey(name))
					{
						types.Add(name, type);
					}
				}
a407 1
			return type;
a408 5
		finally
		{
			Profiler.Leave("LoadClassByDottedName");
		}
	}
d410 1
a410 24
	private TypeWrapper GetWrapperFromBootstrapType(Type type)
	{
		//Tracer.Info(Tracer.Runtime, "GetWrapperFromBootstrapType: {0}", type.FullName);
		Debug.Assert(GetWrapperFromTypeFast(type) == null, "GetWrapperFromTypeFast(type) == null", type.FullName);
		Debug.Assert(!type.IsArray, "!type.IsArray", type.FullName);
		Debug.Assert(!(type.Assembly is AssemblyBuilder), "!(type.Assembly is AssemblyBuilder)", type.FullName);
		// only the bootstrap classloader can own compiled types
		Debug.Assert(this == GetBootstrapClassLoader(), "this == GetBootstrapClassLoader()", type.FullName);
		bool javaType = type.Module.IsDefined(typeof(JavaModuleAttribute), false);
		string name;
		if(javaType)
		{
			name = CompiledTypeWrapper.GetName(type);
		}
		else
		{
			name = DotNetTypeWrapper.GetName(type);
		}
		TypeWrapper wrapper;
		lock(types.SyncRoot)
		{
			wrapper = (TypeWrapper)types[name];
		}
		if(wrapper == null)
d412 8
d422 1
a422 3
				// since this type was compiled from Java source, we have to look for our
				// attributes
				wrapper = CompiledTypeWrapper.newInstance(name, type);
d426 1
a426 4
				// since this type was not compiled from Java source, we don't need to
				// look for our attributes, but we do need to filter unrepresentable
				// stuff (and transform some other stuff)
				wrapper = new DotNetTypeWrapper(type);
d428 1
a428 1
			Debug.Assert(wrapper.Name == name, "wrapper.Name == name", type.FullName);
d431 5
a435 4
				// another thread may have beaten us to it and in that
				// case we don't want to overwrite the previous one
				TypeWrapper race = (TypeWrapper)types[name];
				if(race == null)
d437 3
a439 2
					types.Add(name, wrapper);
					typeToTypeWrapper.Add(type, wrapper);
d443 20
a462 1
					wrapper = race;
d465 1
a466 2
		return wrapper;
	}
d468 2
a469 4
	// NOTE this method only sees pre-compiled Java classes
	internal Type GetBootstrapTypeRaw(string name)
	{
		foreach(Assembly a in AppDomain.CurrentDomain.GetAssemblies())
d471 1
a471 1
			if(!(a is AssemblyBuilder))
d473 1
a473 2
				Type t = GetJavaTypeFromAssembly(a, name);
				if(t != null)
d475 5
a479 1
					return t;
d482 1
a483 2
		return null;
	}
d485 1
a485 4
	private static Type GetJavaTypeFromAssembly(Assembly a, string name)
	{
		Type t = a.GetType(name);
		if(t != null && t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d487 12
a498 1
			return t;
d500 2
a501 3
		// HACK we might be looking for an inner classes
		t = a.GetType(name.Replace('$', '+'));
		if(t != null && t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d503 1
a503 1
			return t;
a504 2
		return null;
	}
d506 10
a515 22
	internal virtual TypeWrapper GetTypeWrapperCompilerHook(string name)
	{
		return null;
	}

	// NOTE this method can actually return null if the resulting array type name would be too long
	// for .NET to handle.
	private TypeWrapper CreateArrayType(string name, TypeWrapper elementTypeWrapper, int dims)
	{
		Debug.Assert(new String('[', dims) + elementTypeWrapper.SigName == name);
		Debug.Assert(!elementTypeWrapper.IsUnloadable && !elementTypeWrapper.IsVerifierType && !elementTypeWrapper.IsArray);
		Debug.Assert(dims >= 1);
		Type elementType = elementTypeWrapper.TypeAsArrayType;
		TypeWrapper wrapper;
		lock(types.SyncRoot)
		{
			wrapper = (TypeWrapper)types[name];
		}
		if(wrapper == null)
		{
			String netname = elementType.FullName + "[]";
			for(int i = 1; i < dims; i++)
d517 1
a517 1
				netname += "[]";
d519 1
a519 2
			// .NET 1.1 has a limit of 1024 characters for type names
			if(netname.Length >= 1024)
d521 40
a560 10
				return null;
			}
			Type array;
			if(elementType.Module is ModuleBuilder)
			{
				// FXBUG ModuleBuilder.GetType() is broken (I think), it fires a TypeResolveEvent when
				// you try to construct an array type from an unfinished type. I don't think it should
				// do that. We have to work around that by setting a global flag (yuck) to prevent us
				// from responding to the TypeResolveEvent.
				lock(arrayConstructionLock)
d562 4
a565 2
					arrayConstructionHack = true;
					try
d567 6
a572 1
						array = ((ModuleBuilder)elementType.Module).GetType(netname);
d574 1
a574 1
					finally
d576 1
a576 1
						arrayConstructionHack = false;
d580 7
a586 1
			else
d588 4
a591 1
				array = elementType.Assembly.GetType(netname, true);
a592 5
			Modifiers modifiers = Modifiers.Final | Modifiers.Abstract;
			Modifiers reflectiveModifiers = modifiers;
			modifiers |= elementTypeWrapper.Modifiers & Modifiers.Public;
			reflectiveModifiers |= elementTypeWrapper.ReflectiveModifiers & Modifiers.AccessMask;
			wrapper = new ArrayTypeWrapper(array, modifiers, reflectiveModifiers, name, this);
d595 11
a605 4
				// another thread may have beaten us to it and in that
				// case we don't want to overwrite the previous one
				TypeWrapper race = (TypeWrapper)types[name];
				if(race == null)
d607 6
a612 2
					types.Add(name, wrapper);
					if(!(elementType is TypeBuilder) && !wrapper.IsGhostArray)
d614 7
a620 2
						Debug.Assert(!typeToTypeWrapper.ContainsKey(array), name);
						typeToTypeWrapper.Add(array, wrapper);
d623 5
a627 1
				else
d629 6
a634 1
					wrapper = race;
d636 1
a638 2
		return wrapper;
	}
d640 1
a640 4
	internal TypeWrapper DefineClass(ClassFile f, object protectionDomain)
	{
		string dotnetAssembly = f.IKVMAssemblyAttribute;
		if(dotnetAssembly != null)
d642 1
a642 4
			// HACK only the bootstrap classloader can define .NET types (but for convenience, we do
			// allow other class loaders to call DefineClass for them)
			// TODO reconsider this, it might be a better idea to only allow netexp generated jars on the bootclasspath
			return GetBootstrapClassLoader().DefineNetExpType(f.Name, dotnetAssembly);
d644 2
a645 1
		lock(types.SyncRoot)
d647 3
a649 1
			if(types.ContainsKey(f.Name))
d651 32
a682 1
				throw new LinkageError("duplicate class definition: " + f.Name);
a683 6
			// mark the type as "loading in progress", so that we can detect circular dependencies.
			types.Add(f.Name, null);
		}
		try
		{
			TypeWrapper type = CreateDynamicTypeWrapper(f, this, protectionDomain);
d686 1
a686 5
				// in very extreme conditions another thread may have beaten us to it
				// and loaded a class with the same name, in that case we'll leak
				// the defined DynamicTypeWrapper (or rather the Reflection.Emit
				// defined type).
				TypeWrapper race = (TypeWrapper)types[f.Name];
d689 1
a689 3
					Debug.Assert(!dynamicTypes.ContainsKey(type.TypeAsTBD.FullName));
					dynamicTypes.Add(type.TypeAsTBD.FullName, type);
					types[f.Name] = type;
d698 2
a699 1
		catch
d701 1
a701 10
			lock(types.SyncRoot)
			{
				if(types[f.Name] == null)
				{
					// if loading the class fails, we remove the indicator that we're busy loading the class,
					// because otherwise we get a ClassCircularityError if we try to load the class again.
					types.Remove(f.Name);
				}
			}
			throw;
a702 6
	}

	protected virtual TypeWrapper CreateDynamicTypeWrapper(ClassFile f, ClassLoaderWrapper loader, object protectionDomain)
	{
		return new DynamicTypeWrapper(f, loader, protectionDomain);
	}
d704 4
a707 19
	private TypeWrapper DefineNetExpType(string name, string assemblyName)
	{
		Debug.Assert(this == GetBootstrapClassLoader());
		TypeWrapper type;
		lock(types.SyncRoot)
		{
			// we need to check if we've already got it, because other classloaders than the bootstrap classloader may
			// "define" NetExp types, there is a potential race condition if multiple classloaders try to define the
			// same type simultaneously.
			type = (TypeWrapper)types[name];
			if(type != null)
			{
				return type;
			}
		}
		// The sole purpose of the netexp class is to let us load the assembly that the class lives in,
		// once we've done that, all types in it become visible.
		Assembly asm;
		try
d709 1
a709 1
			asm = Assembly.Load(assemblyName);
d711 2
a712 1
		catch(Exception x)
d714 2
a715 1
			throw new NoClassDefFoundError(name + " (" + x.Message + ")");
d717 2
a718 14
		// pre-compiled Java types can also live in a netexp referenced assembly,
		// so we have to explicitly check for those
		// (DotNetTypeWrapper.CreateDotNetTypeWrapper will refuse to return Java types).
		Type t = GetJavaTypeFromAssembly(asm, name);
		if(t != null)
		{
			return GetWrapperFromBootstrapType(t);
		}
		type = DotNetTypeWrapper.CreateDotNetTypeWrapper(name);
		if(type == null)
		{
			throw new NoClassDefFoundError(name + " not found in " + assemblyName);
		}
		lock(types.SyncRoot)
d720 1
a720 2
			TypeWrapper race = (TypeWrapper)types[name];
			if(race == null)
d722 1
a722 1
				types.Add(name, type);
a723 32
			else
			{
				type = race;
			}
		}
		return type;
	}

	internal object GetJavaClassLoader()
	{
		return (this == GetBootstrapClassLoader()) ? null : javaClassLoader;
	}

	// When -Xbootclasspath is specified, we use a URLClassLoader as an
	// additional bootstrap class loader (this is not visible to the Java code).
	// We need to access this to be able to load resources.
	internal static object GetJavaBootstrapClassLoader()
	{
		return GetBootstrapClassLoader().javaClassLoader;
	}

	internal static void PrepareForSaveDebugImage()
	{
		Debug.Assert(moduleBuilder == null);
		saveDebugImage = true;
	}

	internal static bool IsSaveDebugImage
	{
		get
		{
			return saveDebugImage;
a724 1
	}
d726 1
a726 3
	internal static void FinishAll()
	{
		while(dynamicTypes.Count > 0)
d728 1
a728 2
			ArrayList l = new ArrayList(dynamicTypes.Values);
			foreach(TypeWrapper tw in l)
d730 7
a736 3
				Tracer.Info(Tracer.Runtime, "Finishing {0} for debug image", tw.TypeAsTBD.FullName);
				tw.Finish(true);
				dynamicTypes.Remove(tw.TypeAsTBD.FullName);
a738 1
	}
d740 1
a740 12
	internal static void SaveDebugImage(object mainClass)
	{
		FinishAll();
		// HACK use reflection to get the type from the class
		TypeWrapper mainTypeWrapper = IKVM.NativeCode.java.lang.VMClass.getWrapperFromClass(mainClass);
		mainTypeWrapper.Finish();
		Type mainType = mainTypeWrapper.TypeAsTBD;
		MethodInfo main = mainType.GetMethod("main", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { typeof(string[]) }, null);
		AssemblyBuilder asm = ((AssemblyBuilder)moduleBuilder.Assembly);
		asm.SetEntryPoint(main, PEFileKinds.ConsoleApplication);
		asm.Save("ikvmdump.exe");
		if(saveDebugAssemblies != null)
d742 10
a751 1
			foreach(AssemblyBuilder ab in saveDebugAssemblies)
d753 4
a756 1
				ab.Save(ab.GetName().Name + ".dll");
a758 1
	}
d760 1
a760 3
	internal static void RegisterForSaveDebug(AssemblyBuilder ab)
	{
		if(saveDebugAssemblies == null)
d762 5
a766 1
			saveDebugAssemblies = new ArrayList();
a767 2
		saveDebugAssemblies.Add(ab);
	}
d769 1
a769 3
	internal ModuleBuilder ModuleBuilder
	{
		get
d771 1
a771 1
			lock(this)
d773 1
a773 1
				if(moduleBuilder == null)
d775 5
a779 1
					moduleBuilder = CreateModuleBuilder();
a780 1
				return moduleBuilder;
a782 1
	}
d784 1
a784 4
	protected virtual ModuleBuilder CreateModuleBuilder()
	{
		AssemblyName name = new AssemblyName();
		if(saveDebugImage)
d786 16
a801 1
			name.Name = "ikvmdump";
d803 2
a804 1
		else
d806 5
a810 1
			name.Name = "ikvm_dynamic_assembly__" + instanceId + "__" + (uint)Environment.TickCount;
a811 17
		DateTime now = DateTime.Now;
		name.Version = new Version(now.Year, (now.Month * 100) + now.Day, (now.Hour * 100) + now.Minute, (now.Second * 1000) + now.Millisecond);
		AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, saveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run, null, null, null, null, null, true);
		ModuleBuilder moduleBuilder = saveDebugImage ? assemblyBuilder.DefineDynamicModule("ikvmdump.exe", "ikvmdump.exe", JVM.Debug) : assemblyBuilder.DefineDynamicModule(name.Name, JVM.Debug);
		CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, JVM.Debug });
		assemblyBuilder.SetCustomAttribute(debugAttr);
		return moduleBuilder;
	}

	internal TypeWrapper ExpressionTypeWrapper(string type)
	{
		Debug.Assert(!type.StartsWith("Lret;"));
		Debug.Assert(type != "Lnull");

		int index = 0;
		return SigDecoderWrapper(ref index, type);
	}
d813 2
a814 4
	// NOTE this exposes potentially unfinished types
	internal Type[] ArgTypeListFromSig(string sig)
	{
		if(sig[1] == ')')
d816 11
a826 7
			return Type.EmptyTypes;
		}
		TypeWrapper[] wrappers = ArgTypeWrapperListFromSig(sig);
		Type[] types = new Type[wrappers.Length];
		for(int i = 0; i < wrappers.Length; i++)
		{
			types[i] = wrappers[i].TypeAsSignatureType;
a827 2
		return types;
	}
d829 2
a830 4
	// NOTE: this will ignore anything following the sig marker (so that it can be used to decode method signatures)
	private TypeWrapper SigDecoderWrapper(ref int index, string sig)
	{
		switch(sig[index++])
d832 19
a850 52
			case 'B':
				return PrimitiveTypeWrapper.BYTE;
			case 'C':
				return PrimitiveTypeWrapper.CHAR;
			case 'D':
				return PrimitiveTypeWrapper.DOUBLE;
			case 'F':
				return PrimitiveTypeWrapper.FLOAT;
			case 'I':
				return PrimitiveTypeWrapper.INT;
			case 'J':
				return PrimitiveTypeWrapper.LONG;
			case 'L':
			{
				int pos = index;
				index = sig.IndexOf(';', index) + 1;
				return LoadClassByDottedName(sig.Substring(pos, index - pos - 1));
			}
			case 'S':
				return PrimitiveTypeWrapper.SHORT;
			case 'Z':
				return PrimitiveTypeWrapper.BOOLEAN;
			case 'V':
				return PrimitiveTypeWrapper.VOID;
			case '[':
			{
				// TODO this can be optimized
				string array = "[";
				while(sig[index] == '[')
				{
					index++;
					array += "[";
				}
				switch(sig[index])
				{
					case 'L':
					{
						int pos = index;
						index = sig.IndexOf(';', index) + 1;
						return LoadClassByDottedName(array + sig.Substring(pos, index - pos));
					}
					case 'B':
					case 'C':
					case 'D':
					case 'F':
					case 'I':
					case 'J':
					case 'S':
					case 'Z':
						return LoadClassByDottedName(array + sig[index++]);
					default:
						throw new InvalidOperationException(sig.Substring(index));
d852 38
a890 2
			default:
				throw new InvalidOperationException(sig.Substring(index));
a891 1
	}
d893 1
a893 15
	internal TypeWrapper FieldTypeWrapperFromSig(string sig)
	{
		int index = 0;
		return SigDecoderWrapper(ref index, sig);
	}

	internal TypeWrapper RetTypeWrapperFromSig(string sig)
	{
		int index = sig.IndexOf(')') + 1;
		return SigDecoderWrapper(ref index, sig);
	}

	internal TypeWrapper[] ArgTypeWrapperListFromSig(string sig)
	{
		if(sig[1] == ')')
d895 2
a896 1
			return TypeWrapper.EmptyArray;
d898 2
a899 2
		ArrayList list = new ArrayList();
		for(int i = 1; sig[i] != ')';)
d901 2
a902 1
			list.Add(SigDecoderWrapper(ref i, sig));
a903 4
		TypeWrapper[] types = new TypeWrapper[list.Count];
		list.CopyTo(types);
		return types;
	}
d905 1
a905 3
	internal static ClassLoaderWrapper GetBootstrapClassLoader()
	{
		lock(typeof(ClassLoaderWrapper))
d907 1
a907 1
			if(bootstrapClassLoader == null)
d909 1
a909 1
				bootstrapClassLoader = new ClassLoaderWrapper(null);
d911 8
a918 1
			return bootstrapClassLoader;
a919 1
	}
d921 1
a921 4
	internal static ClassLoaderWrapper GetSystemClassLoader()
	{
		// during static compilation, we don't have a system class loader
		if(JVM.IsStaticCompiler)
d923 8
a930 1
			return GetBootstrapClassLoader();
d932 2
a933 1
		if(systemClassLoader == null)
d935 10
a944 1
			systemClassLoader = GetClassLoaderWrapper(JVM.Library.getSystemClassLoader());
a945 2
		return systemClassLoader;
	}
d947 1
a947 3
	internal static ClassLoaderWrapper GetClassLoaderWrapper(object javaClassLoader)
	{
		if(javaClassLoader == null || GetBootstrapClassLoader().javaClassLoader == javaClassLoader)
d949 14
a962 1
			return GetBootstrapClassLoader();
d964 5
a968 1
		lock(javaClassLoaderToClassLoaderWrapper.SyncRoot)
d970 2
a971 1
			ClassLoaderWrapper wrapper = (ClassLoaderWrapper)javaClassLoaderToClassLoaderWrapper[javaClassLoader];
d974 5
a978 2
				wrapper = new ClassLoaderWrapper(javaClassLoader);
				javaClassLoaderToClassLoaderWrapper[javaClassLoader] = wrapper;
a981 1
	}
d983 1
a983 8
	// This only returns the wrapper for a Type if that wrapper has already been created, otherwise
	// it returns null
	// If the wrapper doesn't exist, that means that the type is either a .NET type or a pre-compiled Java class
	internal static TypeWrapper GetWrapperFromTypeFast(Type type)
	{
		TypeWrapper.AssertFinished(type);
		TypeWrapper wrapper = (TypeWrapper)typeToTypeWrapper[type];
		if(wrapper == null)
d985 4
a988 2
			string name = (string)remappedTypes[type];
			if(name != null)
d990 20
a1009 1
				return LoadClassCritical(name);
d1011 1
a1012 2
		return wrapper;
	}
d1014 5
a1018 27
	internal static TypeWrapper GetWrapperFromType(Type type)
	{
		//Tracer.Info(Tracer.Runtime, "GetWrapperFromType: {0}", type.AssemblyQualifiedName);
		TypeWrapper.AssertFinished(type);
		TypeWrapper wrapper = GetWrapperFromTypeFast(type);
		if(wrapper == null)
		{
			Debug.Assert(type != typeof(object) && type != typeof(string));
			if(type.IsArray)
			{
				// it might be an array of a dynamically compiled Java type
				int rank = 1;
				Type elem = type.GetElementType();
				while(elem.IsArray)
				{
					rank++;
					elem = elem.GetElementType();
				}
				wrapper = GetWrapperFromType(elem);
				return wrapper.MakeArrayType(rank);
			}
			// if the wrapper doesn't already exist, that must mean that the type
			// is a .NET type (or a pre-compiled Java class), which means that it
			// was "loaded" by the bootstrap classloader
			// TODO think up a scheme to deal with .NET types that have the same name. Since all .NET types
			// appear in the boostrap classloader, we need to devise a scheme to mangle the class name
			return GetBootstrapClassLoader().GetWrapperFromBootstrapType(type);
a1019 9
		return wrapper;
	}

	internal static void SetWrapperForType(Type type, TypeWrapper wrapper)
	{
		TypeWrapper.AssertFinished(type);
		Debug.Assert(!typeToTypeWrapper.ContainsKey(type));
		typeToTypeWrapper.Add(type, wrapper);
	}
d1021 1
a1021 10
	internal static void PublishLibraryImplementationHelperType(Type type)
	{
		CompiledTypeWrapper typeWrapper = CompiledTypeWrapper.newInstance(type.FullName, type);
		SetWrapperForType(type, typeWrapper);
		GetBootstrapClassLoader().types[type.FullName] = typeWrapper;
	}

	internal static TypeWrapper LoadClassCritical(string name)
	{
		try
d1023 3
a1025 1
			return GetBootstrapClassLoader().LoadClassByDottedName(name);
d1027 2
a1028 1
		catch(Exception x)
d1030 9
a1038 2
			JVM.CriticalFailure("Loading of critical class failed", x);
			return null;
a1039 1
	}
d1041 1
a1041 3
	internal void RegisterNativeLibrary(IntPtr p)
	{
		lock(this)
d1043 1
a1043 1
			if(nativeLibraries == null)
d1045 5
a1049 1
				nativeLibraries = new ArrayList();
a1050 1
			nativeLibraries.Add(p);
a1051 1
	}
d1053 1
a1053 3
	internal IntPtr[] GetNativeLibraries()
	{
		lock(this)
d1055 1
a1055 1
			if(nativeLibraries ==  null)
d1057 5
a1061 1
				return new IntPtr[0];
a1062 1
			return (IntPtr[])nativeLibraries.ToArray(typeof(IntPtr));
a1063 1
	}
d1065 1
a1065 3
	public override string ToString()
	{
		if(javaClassLoader == null)
d1067 5
a1071 1
			return "null";
a1072 1
		return String.Format("{0}@@{1:X}", GetWrapperFromType(javaClassLoader.GetType()).Name, javaClassLoader.GetHashCode());
@


1.25
log
@*** empty log message ***
@
text
@d603 1
a603 1
			TypeWrapper type = new DynamicTypeWrapper(f, this, protectionDomain);
d639 5
@


1.24
log
@*** empty log message ***
@
text
@d69 2
@


1.23
log
@*** empty log message ***
@
text
@d436 1
a436 1
				wrapper = new CompiledTypeWrapper(name, type);
d1015 1
a1015 1
		CompiledTypeWrapper typeWrapper = new CompiledTypeWrapper(type.FullName, type);
@


1.22
log
@*** empty log message ***
@
text
@d1056 9
@


1.21
log
@*** empty log message ***
@
text
@d785 1
a785 1
			name.Name = "ikvm_dynamic_assembly__" + instanceId;
d787 2
@


1.20
log
@*** empty log message ***
@
text
@d785 1
a785 1
			name.Name = "ikvm_dynamic_assembly__" + (this == GetBootstrapClassLoader() ? "bootstrap" : javaClassLoader);
@


1.19
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d507 3
a510 1
		Debug.Assert(!elementType.IsArray);
d814 1
a814 1
			types[i] = wrappers[i].TypeAsParameterType;
a990 5
				// HACK BYTE[]
				//if(elem == typeof(byte))
				//{
				//	elem = typeof(sbyte);
				//}
@


1.18
log
@*** empty log message ***
@
text
@d219 5
d415 3
a417 2
		TypeWrapper wrapper = null;
		if(type.Module.IsDefined(typeof(JavaModuleAttribute), false))
d419 1
a419 16
			lock(types.SyncRoot)
			{
				string name = CompiledTypeWrapper.GetName(type);
				wrapper = (TypeWrapper)types[name];
				if(wrapper == null)
				{
					// since this type was compiled from Java source, we have to look for our
					// attributes
					wrapper = new CompiledTypeWrapper(name, type);
					Debug.Assert(wrapper.Name == name, "wrapper.Name == name", type.FullName);
					Debug.Assert(!types.ContainsKey(wrapper.Name), wrapper.Name, type.FullName);
					types.Add(wrapper.Name, wrapper);
					Debug.Assert(!typeToTypeWrapper.ContainsKey(type), "!typeToTypeWrapper.ContainsKey(type)", type.FullName);
					typeToTypeWrapper.Add(type, wrapper);
				}
			}
d423 23
d448 6
a453 12
				string name = DotNetTypeWrapper.GetName(type);
				wrapper = (TypeWrapper)types[name];
				if(wrapper == null)
				{
					// since this type was not compiled from Java source, we don't need to
					// look for our attributes, but we do need to filter unrepresentable
					// stuff (and transform some other stuff)
					wrapper = new DotNetTypeWrapper(type);
					Debug.Assert(wrapper.Name == name, "wrapper.Name == name", type.FullName);
					Debug.Assert(!types.ContainsKey(wrapper.Name), wrapper.Name, type.FullName);
					types.Add(wrapper.Name, wrapper);
					Debug.Assert(!typeToTypeWrapper.ContainsKey(type), "!typeToTypeWrapper.ContainsKey(type)", type.FullName);
d456 4
d503 2
d509 1
d512 16
a527 2
			TypeWrapper wrapper = (TypeWrapper)types[name];
			if(wrapper == null)
d529 5
a533 2
				String netname = "[]";
				for(int i = 1; i < dims; i++)
d535 9
a543 1
					netname += "[]";
d545 16
a560 2
				Type array;
				if(elementType.Module is ModuleBuilder)
d562 2
a563 5
					// FXBUG ModuleBuilder.GetType() is broken (I think), it fires a TypeResolveEvent when
					// you try to construct an array type from an unfinished type. I don't think it should
					// do that. We have to work around that by setting a global flag (yuck) to prevent us
					// from responding to the TypeResolveEvent.
					lock(arrayConstructionLock)
d565 2
a566 9
						arrayConstructionHack = true;
						try
						{
							array = ((ModuleBuilder)elementType.Module).GetType(elementType.FullName + netname);
						}
						finally
						{
							arrayConstructionHack = false;
						}
d571 1
a571 13
					array = elementType.Assembly.GetType(elementType.FullName + netname, true);
				}
				Modifiers modifiers = Modifiers.Final | Modifiers.Abstract;
				Modifiers reflectiveModifiers = modifiers;
				modifiers |= elementTypeWrapper.Modifiers & Modifiers.Public;
				reflectiveModifiers |= elementTypeWrapper.ReflectiveModifiers & Modifiers.AccessMask;
				wrapper = new ArrayTypeWrapper(array, modifiers, reflectiveModifiers, name, this);
				Debug.Assert(!types.ContainsKey(name));
				types.Add(name, wrapper);
				if(!(elementType is TypeBuilder) && !wrapper.IsGhostArray)
				{
					Debug.Assert(!typeToTypeWrapper.ContainsKey(array), name);
					typeToTypeWrapper.Add(array, wrapper);
a573 1
			return wrapper;
d575 1
d596 5
a600 1
			try
d602 15
a616 6
				TypeWrapper type = new DynamicTypeWrapper(f, this, protectionDomain);
				Debug.Assert(!dynamicTypes.ContainsKey(type.TypeAsTBD.FullName));
				dynamicTypes.Add(type.TypeAsTBD.FullName, type);
				Debug.Assert(types[f.Name] == null);
				types[f.Name] = type;
				return type;
d618 5
a622 1
			catch
a629 1
				throw;
d631 1
d638 1
d644 1
a644 1
			TypeWrapper type = (TypeWrapper)types[name];
d649 29
a677 4
			// The sole purpose of the netexp class is to let us load the assembly that the class lives in,
			// once we've done that, all types in it become visible.
			Assembly asm;
			try
d679 1
a679 1
				asm = Assembly.Load(assemblyName);
d681 1
a681 1
			catch(Exception x)
d683 1
a683 1
				throw new NoClassDefFoundError(name + " (" + x.Message + ")");
a684 15
			// pre-compiled Java types can also live in a netexp referenced assembly,
			// so we have to explicitly check for those
			// (DotNetTypeWrapper.CreateDotNetTypeWrapper will refuse to return Java types).
			Type t = GetJavaTypeFromAssembly(asm, name);
			if(t != null)
			{
				return GetWrapperFromBootstrapType(t);
			}
			type = DotNetTypeWrapper.CreateDotNetTypeWrapper(name);
			if(type == null)
			{
				throw new NoClassDefFoundError(name + " not found in " + assemblyName);
			}
			types.Add(name, type);
			return type;
d686 1
@


1.17
log
@*** empty log message ***
@
text
@d256 1
a256 1
						type = type.GetClassLoader().CreateArrayType(name, type.TypeAsArrayType, dims);
d268 1
a268 1
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BYTE.TypeAsArrayType, dims);
d270 1
a270 1
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.CHAR.TypeAsArrayType, dims);
d272 1
a272 1
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.DOUBLE.TypeAsArrayType, dims);
d274 1
a274 1
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.FLOAT.TypeAsArrayType, dims);
d276 1
a276 1
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.INT.TypeAsArrayType, dims);
d278 1
a278 1
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.LONG.TypeAsArrayType, dims);
d280 1
a280 1
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.SHORT.TypeAsArrayType, dims);
d282 1
a282 1
						return GetBootstrapClassLoader().CreateArrayType(name, PrimitiveTypeWrapper.BOOLEAN.TypeAsArrayType, dims);
d491 1
a491 1
	private TypeWrapper CreateArrayType(string name, Type elementType, int dims)
d493 1
d530 4
a533 6
				// TODO taking the visibility from the .NET isn't 100% correct, we really should look at the wrapper
				if(DotNetTypeWrapper.IsVisible(elementType))
				{
					modifiers |= Modifiers.Public;
				}
				wrapper = new ArrayTypeWrapper(array, modifiers, name, this);
@


1.16
log
@*** empty log message ***
@
text
@d86 4
a89 4
		// HACK we need to find the "core" library, to figure out the remapped types
		// TODO this approach fails if the core library was compiled as a module (ikvmc always generates an assembly
		// and the assembly attributes end up on the assemblies main module that is deleted when ikvmc finishes)
		foreach(Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
d91 3
a93 1
			object[] remapped = asm.GetCustomAttributes(typeof(RemappedClassAttribute), false);
a95 1
				coreAssembly = asm;
a100 1
				break;
d102 1
a102 5
		}
		if(coreAssembly == null)
		{
			Tracer.Info(Tracer.Compiler, "Unable to find core library");
			if(!JVM.IsStaticCompiler)
d104 1
a104 1
				JVM.CriticalFailure("Unable to find core library", null);
d547 1
a547 1
	internal TypeWrapper DefineClass(ClassFile f)
d567 1
a567 1
				TypeWrapper type = new DynamicTypeWrapper(f, this);
@


1.15
log
@*** empty log message ***
@
text
@d190 2
a191 1
			if(nameClashHash.ContainsKey(name))
d230 7
a564 7
				if(types[f.Name] == null)
				{
					// NOTE this can also happen if we (incorrectly) trigger a load of this class during
					// the loading of the base class, so we print a warning here.
					Tracer.Warning(Tracer.ClassLoading, "**** ClassCircularityError: {0} ****", f.Name);
					throw new ClassCircularityError(f.Name);
				}
@


1.14
log
@*** empty log message ***
@
text
@d241 1
a241 1
				switch(name[dims])
d243 8
a250 1
					case 'L':
d252 1
a252 6
						type = LoadClassByDottedNameFast(name.Substring(dims + 1, name.IndexOf(';', dims) - dims - 1));
						if(type != null)
						{
							type = type.GetClassLoader().CreateArrayType(name, type.TypeAsArrayType, dims);
						}
						return type;
d254 9
@


1.13
log
@*** empty log message ***
@
text
@a36 2
	private delegate object LoadClassDelegate(object classLoader, string className);
	private static LoadClassDelegate loadClassDelegate;
a156 10
		if(javaClassLoader != null)
		{
			if(loadClassDelegate == null)
			{
				// LIBREFLECT
				TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical("java.lang.VMClass");
				tw.Finish();
				loadClassDelegate = (LoadClassDelegate)Delegate.CreateDelegate(typeof(LoadClassDelegate), tw.TypeAsTBD, "loadClassHelper");
			}
		}
d359 1
a359 1
					type = (TypeWrapper)loadClassDelegate(javaClassLoader, name);
d860 1
a860 1
		lock(typeof(ClassLoaderWrapper))
d862 1
a862 10
			if(systemClassLoader == null)
			{
				// LIBREFLECT
				TypeWrapper tw = LoadClassCritical("java.lang.System");
				// We directly access the systemClassLoader field, because calling ClassLoader.getSystemClassLoader
				// would cause a security check (and would require to be wrapped in a AccessController.doPriviledged()).
				FieldWrapper fw = tw.GetFieldWrapper("systemClassLoader", "Ljava.lang.ClassLoader;");
				systemClassLoader = GetClassLoaderWrapper(fw.GetValue(null));
			}
			return systemClassLoader;
d864 1
@


1.12
log
@*** empty log message ***
@
text
@d163 1
d876 1
@


1.11
log
@*** empty log message ***
@
text
@d964 7
@


1.10
log
@*** empty log message ***
@
text
@d456 2
a457 8
				Type t = a.GetType(name);
				if(t != null && t.Module.IsDefined(typeof(JavaModuleAttribute), false))
				{
					return t;
				}
				// HACK we might be looking for an inner classes
				t = a.GetType(name.Replace('$', '+'));
				if(t != null && t.Module.IsDefined(typeof(JavaModuleAttribute), false))
d466 16
d590 1
a590 1
	private TypeWrapper DefineNetExpType(string name, string assembly)
d605 1
d608 1
a608 1
				Assembly.Load(assembly);
d614 8
d625 1
a625 1
				throw new NoClassDefFoundError(name + " not found in " + assembly);
d729 1
a729 1
		ModuleBuilder moduleBuilder = saveDebugImage ? assemblyBuilder.DefineDynamicModule(name.Name, "ikvmdump.exe", JVM.Debug) : assemblyBuilder.DefineDynamicModule(name.Name, JVM.Debug);
@


1.9
log
@*** empty log message ***
@
text
@d856 5
a860 3
				TypeWrapper tw = LoadClassCritical("java.lang.ClassLoader");
				MethodWrapper mw = tw.GetMethodWrapper(new MethodDescriptor("getSystemClassLoader", "()Ljava.lang.ClassLoader;"), false);
				systemClassLoader = GetClassLoaderWrapper(mw.Invoke(null, new object[0], false));
@


1.8
log
@*** empty log message ***
@
text
@d711 2
a712 5
		if(JVM.Debug)
		{
			CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(typeof(DebuggableAttribute).GetConstructor(new Type[] { typeof(bool), typeof(bool) }), new object[] { true, true });
			assemblyBuilder.SetCustomAttribute(debugAttr);
		}
@


1.7
log
@*** empty log message ***
@
text
@d115 5
d850 5
@


1.6
log
@*** empty log message ***
@
text
@d31 3
d46 1
d653 1
a653 1
		TypeWrapper mainTypeWrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(mainClass);
d842 14
@


1.5
log
@*** empty log message ***
@
text
@d54 1
d656 16
d692 8
a699 1
		name.Name = "ikvm_dynamic_assembly__" + (this == GetBootstrapClassLoader() ? "bootstrap" : javaClassLoader);
@


1.4
log
@*** empty log message ***
@
text
@d45 1
d197 1
a197 1
				return name + "\\\\" + instanceId;
d906 24
@


1.3
log
@*** empty log message ***
@
text
@d37 1
a37 1
	private static Hashtable assemblyToClassLoaderWrapper = new Hashtable();
d39 1
a39 2
	private static ArrayList classLoaders = new ArrayList();
	private static Hashtable dynamicTypes = new Hashtable();
d41 1
a41 1
	private static Hashtable typeToTypeWrapper = new Hashtable();
d45 1
a45 1
	// HACK moduleBuilder is static, because multiple dynamic assemblies is broken (TypeResolve doesn't fire)
d66 9
d111 1
a111 2
		Tracer.Info(Tracer.ClassLoading, "OnTypeResolve: {0} (arrayConstructionHack = {1})", args.Name, arrayConstructionHack);
		if(arrayConstructionHack)
d113 5
a117 1
			return null;
d124 13
a136 1
		type.Finish();
a142 1
		classLoaders.Add(this);
d148 1
a148 1
		if(javaClassLoader != null && loadClassDelegate == null)
d150 6
a155 3
			TypeWrapper tw = ClassLoaderWrapper.LoadClassCritical("java.lang.VMClass");
			tw.Finish();
			loadClassDelegate = (LoadClassDelegate)Delegate.CreateDelegate(typeof(LoadClassDelegate), tw.TypeAsTBD, "loadClassHelper");
d177 4
a180 1
		return (TypeWrapper)types[name];
d188 1
a188 1
		lock(nameClashHash)
d213 1
a213 1
		throw JavaException.ClassNotFoundException(name);
a215 1
	// TODO implement vmspec 5.3.4 Loading Constraints
d220 1
a220 1
			throw JavaException.NullPointerException();
d225 5
a229 1
			TypeWrapper type = (TypeWrapper)types[name];
d245 5
a249 2
						type = LoadClassByDottedName(name.Substring(dims + 1, name.IndexOf(';', dims) - dims - 1));
						type = type.GetClassLoader().CreateArrayType(name, type.TypeAsTBD, dims);
d253 1
a253 1
						return GetBootstrapClassLoader().CreateArrayType(name, typeof(sbyte), dims);
d255 1
a255 1
						return GetBootstrapClassLoader().CreateArrayType(name, typeof(char), dims);
d257 1
a257 1
						return GetBootstrapClassLoader().CreateArrayType(name, typeof(double), dims);
d259 1
a259 1
						return GetBootstrapClassLoader().CreateArrayType(name, typeof(float), dims);
d261 1
a261 1
						return GetBootstrapClassLoader().CreateArrayType(name, typeof(int), dims);
d263 1
a263 1
						return GetBootstrapClassLoader().CreateArrayType(name, typeof(long), dims);
d265 1
a265 1
						return GetBootstrapClassLoader().CreateArrayType(name, typeof(short), dims);
d267 1
a267 1
						return GetBootstrapClassLoader().CreateArrayType(name, typeof(bool), dims);
d319 1
a319 1
					type = DotNetTypeWrapper.LoadDotNetTypeWrapper(name);
d323 14
a336 2
						Debug.Assert(!types.ContainsKey(name), name);
						types.Add(name, type);
d367 2
a368 1
			// TODO not sure if this is correct
d371 1
a371 1
				if(types[name] != type)
d373 4
a376 1
					types.Add(name, type);
d390 3
a392 3
		Debug.Assert(GetWrapperFromTypeFast(type) == null);
		Debug.Assert(!type.IsArray);
		Debug.Assert(!(type.Assembly is AssemblyBuilder));
d394 1
a394 1
		Debug.Assert(this == GetBootstrapClassLoader());
d398 1
a398 3
			string name = CompiledTypeWrapper.GetName(type);
			wrapper = (TypeWrapper)types[name];
			if(wrapper == null)
d400 13
a412 8
				// since this type was compiled from Java source, we have to look for our
				// attributes
				wrapper = new CompiledTypeWrapper(name, type);
				Debug.Assert(wrapper.Name == name);
				Debug.Assert(!types.ContainsKey(wrapper.Name), wrapper.Name);
				types.Add(wrapper.Name, wrapper);
				Debug.Assert(!typeToTypeWrapper.ContainsKey(type));
				typeToTypeWrapper.Add(type, wrapper);
d417 1
a417 3
			string name = DotNetTypeWrapper.GetName(type);
			wrapper = (TypeWrapper)types[name];
			if(wrapper == null)
d419 14
a432 9
				// since this type was not compiled from Java source, we don't need to
				// look for our attributes, but we do need to filter unrepresentable
				// stuff (and transform some other stuff)
				wrapper = new DotNetTypeWrapper(type);
				Debug.Assert(wrapper.Name == name);
				Debug.Assert(!types.ContainsKey(wrapper.Name), wrapper.Name);
				types.Add(wrapper.Name, wrapper);
				Debug.Assert(!typeToTypeWrapper.ContainsKey(type));
				typeToTypeWrapper.Add(type, wrapper);
d469 1
a469 4
		// TODO array accessibility should be the same as the elementType's accessibility
		// (and this should be enforced)
		TypeWrapper wrapper = (TypeWrapper)types[name];
		if(wrapper == null)
d471 2
a472 2
			String netname = "[]";
			for(int i = 1; i < dims; i++)
d474 32
a505 11
				netname += "[]";
			}
			Type array;
			if(elementType.Module is ModuleBuilder)
			{
				// HACK ModuleBuilder.GetType() is broken (I think), it fires a TypeResolveEvent when
				// you try to construct an array type from an unfinished type. I don't think it should
				// do that. We have to work around that by setting a global flag (yuck) to prevent us
				// from responding to the TypeResolveEvent.
				arrayConstructionHack = true;
				try
d507 1
a507 1
					array = ((ModuleBuilder)elementType.Module).GetType(elementType.FullName + netname);
d509 4
a512 1
				finally
d514 2
a515 1
					arrayConstructionHack = false;
d518 1
a518 18
			else
			{
				array = elementType.Assembly.GetType(elementType.FullName + netname, true);
			}
			Modifiers modifiers = Modifiers.Final | Modifiers.Abstract;
			// TODO taking the publicness from the .NET isn't 100% correct, we really should look at the wrapper
			if(DotNetTypeWrapper.IsVisible(elementType))
			{
				modifiers |= Modifiers.Public;
			}
			wrapper = new ArrayTypeWrapper(array, modifiers, name, this);
			Debug.Assert(!types.ContainsKey(name));
			types.Add(name, wrapper);
			if(!(elementType is TypeBuilder))
			{
				Debug.Assert(!typeToTypeWrapper.ContainsKey(array));
				typeToTypeWrapper.Add(array, wrapper);
			}
a519 1
		return wrapper;
a521 1
	// TODO disallow anyone other than the bootstrap classloader defining classes in the "java." package
d524 1
a524 17
		// TODO shouldn't this check be in ClassFile.cs?
		if(f.Name.Length == 0 || f.Name[0] == '[')
		{
			throw JavaException.ClassFormatError("Bad name");
		}
		if(types.ContainsKey(f.Name))
		{
			if(types[f.Name] == null)
			{
				// NOTE this can also happen if we (incorrectly) trigger a load of this class during
				// the loading of the base class, so we print a warning here.
				Tracer.Warning(Tracer.ClassLoading, "**** ClassCircularityError: {0} ****", f.Name);
				throw JavaException.ClassCircularityError("{0}", f.Name);
			}
			throw JavaException.LinkageError("duplicate class definition: {0}", f.Name);
		}
		string dotnetAssembly = f.NetExpAssemblyAttribute;
d532 1
a532 3
		// mark the type as "loading in progress", so that we can detect circular dependencies.
		types.Add(f.Name, null);
		try
d534 1
a534 5
			TypeWrapper type;
			// TODO also figure out what should happen if LoadClassByDottedNameFast throws an exception (custom class loaders
			// can throw whatever exception they want)
			TypeWrapper baseType = LoadClassByDottedNameFast(f.SuperClass);
			if(baseType == null)
d536 1
a536 6
				throw JavaException.NoClassDefFoundError(f.SuperClass);
			}
			// if the base type isn't public, it must be in the same package
			if(!baseType.IsPublic)
			{
				if(baseType.GetClassLoader() != this || f.PackageName != baseType.PackageName)
d538 4
a541 1
					throw JavaException.IllegalAccessError("Class {0} cannot access its superclass {1}", f.Name, baseType.Name);
d543 1
d545 3
a547 1
			if(baseType.IsFinal)
d549 6
a554 1
				throw JavaException.VerifyError("Cannot inherit from final class");
d556 1
a556 1
			if(baseType.IsInterface)
d558 7
a564 1
				throw JavaException.IncompatibleClassChangeError("Class {0} has interface {1} as superclass", f.Name, baseType.Name);
a565 16
			type = new DynamicTypeWrapper(f, this);
			Debug.Assert(!dynamicTypes.ContainsKey(type.TypeAsTBD.FullName));
			dynamicTypes.Add(type.TypeAsTBD.FullName, type);
			Debug.Assert(types[f.Name] == null);
			types[f.Name] = type;
			return type;
		}
		catch
		{
			if(types[f.Name] == null)
			{
				// if loading the class fails, we remove the indicator that we're busy loading the class,
				// because otherwise we get a ClassCircularityError if we try to load the class again.
				types.Remove(f.Name);
			}
			throw;
d572 1
a572 5
		// we need to check if we've already got it, because other classloaders than the bootstrap classloader may
		// "define" NetExp types, there is a potential race condition if multiple classloaders try to define the
		// same type simultaneously.
		TypeWrapper type = (TypeWrapper)types[name];
		if(type != null)
d574 24
a599 17
		// The sole purpose of the netexp class is to let us load the assembly that the class lives in,
		// once we've done that, all types in it become visible.
		try
		{
			Assembly.Load(assembly);
		}
		catch(Exception x)
		{
			throw JavaException.NoClassDefFoundError("{0} ({1})", name, x.Message);
		}
		type = DotNetTypeWrapper.LoadDotNetTypeWrapper(name);
		if(type == null)
		{
			throw JavaException.NoClassDefFoundError("{0} not found in {1}", name, assembly);
		}
		types.Add(name, type);
		return type;
d621 9
a629 1
	internal static void SaveDebugImage(object mainClass)
d631 1
a631 3
		// HACK we iterate 3 times, in the hopes that that will be enough. We really should let FinishAll return a boolean whether
		// anything was done, and continue iterating until all FinishAlls return false.
		for(int i = 0; i < 3; i++)
d633 2
a634 1
			for(int j = 0; j < classLoaders.Count; j++)
d636 3
a638 1
				((ClassLoaderWrapper)classLoaders[j]).FinishAll();
d641 5
a655 57
	// FXBUG this version isn't used at the moment, because multi assembly type references are broken in the CLR
	internal static void SaveDebugImage__MultiAssemblyVersion(object mainClass)
	{
		// HACK we iterate 3 times, in the hopes that that will be enough. We really should let FinishAll return a boolean whether
		// anything was done, and continue iterating until all FinishAlls return false.
		for(int i = 0; i < 3; i++)
		{
			foreach(DictionaryEntry entry in assemblyToClassLoaderWrapper)
			{
				AssemblyBuilder asm = (AssemblyBuilder)entry.Key;
				ClassLoaderWrapper loader = (ClassLoaderWrapper)entry.Value;
				loader.FinishAll();
			}
		}
		// HACK use reflection to get the type from the class
		TypeWrapper mainTypeWrapper = NativeCode.java.lang.VMClass.getWrapperFromClass(mainClass);
		mainTypeWrapper.Finish();
		Type mainType = mainTypeWrapper.TypeAsTBD;
		MethodInfo main = mainType.GetMethod("main", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { typeof(string[]) }, null);
		foreach(DictionaryEntry entry in ClassLoaderWrapper.assemblyToClassLoaderWrapper)
		{
			AssemblyBuilder asm = (AssemblyBuilder)entry.Key;
			ClassLoaderWrapper loader = (ClassLoaderWrapper)entry.Value;
			if(mainType.Assembly.Equals(asm))
			{
				asm.SetEntryPoint(main, PEFileKinds.ConsoleApplication);
			}
			asm.Save(asm.GetName().Name);
		}
	}

	internal void FinishAll()
	{
		int prevCount = -1;
		while(prevCount != types.Count)
		{
			prevCount = types.Count;
			ArrayList l = new ArrayList();
			foreach(TypeWrapper t in types.Values)
			{
				l.Add(t);
			}
			foreach(TypeWrapper t in l)
			{
				try
				{
					t.Finish();
				}
				catch(Exception x)
				{
					Console.Error.WriteLine(x);
					Console.Error.WriteLine(new StackTrace(x, true));
				}
			}
		}
	}

a664 4
					lock(assemblyToClassLoaderWrapper.SyncRoot)
					{
						assemblyToClassLoaderWrapper[moduleBuilder.Assembly] = this;
					}
d675 1
a675 1
		AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, saveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
d804 1
a804 1
		if(bootstrapClassLoader == null)
d806 5
a810 1
			bootstrapClassLoader = new ClassLoaderWrapper(null);
a811 1
		return bootstrapClassLoader;
d820 1
a820 2
		ClassLoaderWrapper wrapper = (ClassLoaderWrapper)javaClassLoaderToClassLoaderWrapper[javaClassLoader];
		if(wrapper == null)
d822 7
a828 2
			wrapper = new ClassLoaderWrapper(javaClassLoader);
			javaClassLoaderToClassLoaderWrapper[javaClassLoader] = wrapper;
a829 18
		return wrapper;
	}

	internal static ClassLoaderWrapper GetClassLoader(Type type)
	{
		TypeWrapper.AssertFinished(type);
		TypeWrapper wrapper = GetWrapperFromTypeFast(type);
		if(wrapper != null)
		{
			return wrapper.GetClassLoader();
		}
		return GetBootstrapClassLoader();
//		ClassLoaderWrapper loader = (ClassLoaderWrapper)assemblyToClassLoaderWrapper[type.Assembly];
//		if(loader == null)
//		{
//			loader = GetBootstrapClassLoader();
//		}
//		return loader;
d841 2
a842 49
			if(type.IsPrimitive)
			{
				if(type == typeof(sbyte))
				{
					wrapper = PrimitiveTypeWrapper.BYTE;
				}
				else if(type == typeof(char))
				{
					wrapper = PrimitiveTypeWrapper.CHAR;
				}
				else if(type == typeof(double))
				{
					wrapper = PrimitiveTypeWrapper.DOUBLE;
				}
				else if(type == typeof(float))
				{
					wrapper = PrimitiveTypeWrapper.FLOAT;
				}
				else if(type == typeof(int))
				{
					wrapper = PrimitiveTypeWrapper.INT;
				}
				else if(type == typeof(long))
				{
					wrapper = PrimitiveTypeWrapper.LONG;
				}
				else if(type == typeof(short))
				{
					wrapper = PrimitiveTypeWrapper.SHORT;
				}
				else if(type == typeof(bool))
				{
					wrapper = PrimitiveTypeWrapper.BOOLEAN;
				}
			}
			else if(type == typeof(void))
			{
				wrapper = PrimitiveTypeWrapper.VOID;
			}
			else // maybe it's a remapped type
			{
				string name = (string)remappedTypes[type];
				if(name != null)
				{
					return LoadClassCritical(name);
				}
			}
			// if we found it, store it in the map
			if(wrapper != null)
d844 1
a844 2
				Debug.Assert(!typeToTypeWrapper.ContainsKey(type));
				typeToTypeWrapper.Add(type, wrapper);
d868 5
@


1.2
log
@*** empty log message ***
@
text
@d446 1
a446 1
			if(elementType.IsPublic || elementType.IsNestedPublic)
@


1.1
log
@*** empty log message ***
@
text
@d446 1
a446 1
			if(elementType.IsPublic)
@

