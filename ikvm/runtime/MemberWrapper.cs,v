head	1.210;
access;
symbols
	v8_1_5717_0:1.210
	v8_1:1.210.0.2
	v8_0_5449_1:1.204
	v8_0_5449_0:1.204
	v8_0:1.204.0.2
	v7_4_5196_0:1.194
	v7_4:1.194.0.2
	v7_3:1.174.0.2
	v7_2_4630_6:1.163.2.1
	v7_2_4630_5:1.163.2.1
	v7_2_4630_4:1.163.2.1
	v7_2_4630_3:1.163.2.1
	v7_2_4630_2:1.163.2.1
	v0_46_0_4:1.137.2.1
	v7_2_4630_1:1.163
	v7_2:1.163.0.2
	v7_1_4532_2:1.155.2.1
	v7_1_4532_1:1.155.2.1
	v7_1_4532_0:1.155
	v7_1:1.155.0.2
	v7_0_4335_3:1.139
	v7_0_4335_2:1.139
	v7_0_4335_1:1.139
	v0_46_0_2:1.137
	v7_0_4335_0:1.139
	v7_0:1.139.0.2
	v0_40_0_6:1.104.2.1
	v0_40_0_5:1.104.2.1
	v0_46_0_1:1.137
	v0_46_0_0:1.137
	v0_46:1.137.0.2
	v0_36_0_14:1.71.2.5
	v0_44_0_6:1.130.2.3
	v0_44_0_5:1.130.2.2
	v0_44_0_4:1.130.2.2
	v0_44_0_3:1.130.2.2
	v0_44_0_2:1.130.2.2
	v0_42_0_7:1.109
	v0_44_0_1:1.130.2.1
	v0_44_0_0:1.130
	v0_44:1.130.0.2
	v0_42_0_6:1.109
	v0_42_0_5:1.109
	v0_42_0_4:1.109
	v0_42_0_3:1.109
	v0_42_0_2:1.109
	v0_42_0_1:1.109
	v0_42_0_0:1.109
	v0_42:1.109.0.2
	v0_40_0_3:1.104
	v0_40_0_2:1.104
	v0_40_0_1:1.104
	v0_40_0_0:1.104
	v0_40:1.104.0.2
	v0_36_0_13:1.71.2.4
	v0_38_0_1:1.97
	v0_38_0_0:1.97
	v0_38:1.97.0.2
	v0_36_0_9:1.71.2.4
	v0_36_0_7:1.71.2.4
	v0_36_0_5:1.71.2.4
	v0_36_0_4:1.71.2.3
	v0_36_0_3:1.71.2.2
	v0_36_0_2:1.71.2.1
	v0_36_0_1:1.71.2.1
	v0_36_0_0:1.71
	v0_36:1.71.0.2
	v0_34_0_3:1.67
	v0_34_0_2:1.67
	v0_34_0_1:1.67
	v0_34_0_0:1.67
	v0_34:1.67.0.2
	v0_32:1.64.0.2
	v0_32_0_0:1.64
	v0_30:1.53.0.2
	v0_28_0_0:1.48
	v0_26_0_1:1.43
	v0_26_0_0:1.43
	v0_24_0_1:1.41
	v0_24_0_0:1.41
	v0_22_0_0:1.39
	v0_20_0_0:1.39
	v0_18_0_0:1.33
	v0_16_0_0:1.33
	v0_14_0_1:1.27
	v0_14_0_0:1.26
	v0_12_0_0:1.22
	v0_10_0_1:1.19
	v0_10_0_0:1.19
	v0_8_0_0:1.6;
locks; strict;
comment	@ * @;


1.210
date	2015.06.29.10.15.15;	author jfrijters;	state Exp;
branches;
next	1.209;

1.209
date	2015.06.29.10.12.11;	author jfrijters;	state Exp;
branches;
next	1.208;

1.208
date	2015.06.29.10.06.14;	author jfrijters;	state Exp;
branches;
next	1.207;

1.207
date	2015.06.29.09.56.13;	author jfrijters;	state Exp;
branches;
next	1.206;

1.206
date	2015.05.31.12.10.51;	author jfrijters;	state Exp;
branches;
next	1.205;

1.205
date	2015.03.24.09.31.46;	author jfrijters;	state Exp;
branches;
next	1.204;

1.204
date	2014.11.11.15.37.09;	author jfrijters;	state Exp;
branches;
next	1.203;

1.203
date	2014.11.11.14.59.05;	author jfrijters;	state Exp;
branches;
next	1.202;

1.202
date	2014.05.27.10.07.27;	author jfrijters;	state Exp;
branches;
next	1.201;

1.201
date	2014.05.27.09.44.09;	author jfrijters;	state Exp;
branches;
next	1.200;

1.200
date	2014.04.30.09.04.41;	author jfrijters;	state Exp;
branches;
next	1.199;

1.199
date	2014.04.29.13.36.29;	author jfrijters;	state Exp;
branches;
next	1.198;

1.198
date	2014.04.24.16.06.06;	author jfrijters;	state Exp;
branches;
next	1.197;

1.197
date	2014.04.17.11.56.03;	author jfrijters;	state Exp;
branches;
next	1.196;

1.196
date	2014.04.17.11.31.45;	author jfrijters;	state Exp;
branches;
next	1.195;

1.195
date	2014.04.17.11.02.33;	author jfrijters;	state Exp;
branches;
next	1.194;

1.194
date	2014.02.27.06.57.35;	author jfrijters;	state Exp;
branches;
next	1.193;

1.193
date	2013.09.13.12.11.36;	author jfrijters;	state Exp;
branches;
next	1.192;

1.192
date	2013.03.29.10.37.02;	author jfrijters;	state Exp;
branches;
next	1.191;

1.191
date	2013.03.29.08.28.17;	author jfrijters;	state Exp;
branches;
next	1.190;

1.190
date	2013.03.26.11.19.04;	author jfrijters;	state Exp;
branches;
next	1.189;

1.189
date	2013.03.26.11.06.24;	author jfrijters;	state Exp;
branches;
next	1.188;

1.188
date	2013.03.26.09.52.45;	author jfrijters;	state Exp;
branches;
next	1.187;

1.187
date	2013.03.25.19.57.46;	author jfrijters;	state Exp;
branches;
next	1.186;

1.186
date	2013.03.25.18.35.37;	author jfrijters;	state Exp;
branches;
next	1.185;

1.185
date	2013.03.25.16.37.15;	author jfrijters;	state Exp;
branches;
next	1.184;

1.184
date	2013.03.25.14.57.28;	author jfrijters;	state Exp;
branches;
next	1.183;

1.183
date	2013.03.25.12.32.51;	author jfrijters;	state Exp;
branches;
next	1.182;

1.182
date	2013.03.25.07.34.03;	author jfrijters;	state Exp;
branches;
next	1.181;

1.181
date	2013.03.24.14.14.33;	author jfrijters;	state Exp;
branches;
next	1.180;

1.180
date	2013.03.24.12.40.33;	author jfrijters;	state Exp;
branches;
next	1.179;

1.179
date	2013.03.22.11.13.58;	author jfrijters;	state Exp;
branches;
next	1.178;

1.178
date	2013.03.22.10.41.20;	author jfrijters;	state Exp;
branches;
next	1.177;

1.177
date	2013.03.22.10.35.17;	author jfrijters;	state Exp;
branches;
next	1.176;

1.176
date	2013.03.21.15.02.12;	author jfrijters;	state Exp;
branches;
next	1.175;

1.175
date	2013.03.20.14.03.28;	author jfrijters;	state Exp;
branches;
next	1.174;

1.174
date	2013.03.07.09.39.53;	author jfrijters;	state Exp;
branches;
next	1.173;

1.173
date	2013.03.06.15.54.24;	author jfrijters;	state Exp;
branches;
next	1.172;

1.172
date	2013.03.06.15.26.04;	author jfrijters;	state Exp;
branches;
next	1.171;

1.171
date	2013.03.05.15.58.26;	author jfrijters;	state Exp;
branches;
next	1.170;

1.170
date	2013.03.05.10.29.27;	author jfrijters;	state Exp;
branches;
next	1.169;

1.169
date	2013.02.24.13.03.59;	author jfrijters;	state Exp;
branches;
next	1.168;

1.168
date	2013.02.24.07.01.21;	author jfrijters;	state Exp;
branches;
next	1.167;

1.167
date	2013.02.14.14.57.57;	author jfrijters;	state Exp;
branches;
next	1.166;

1.166
date	2012.09.21.11.23.09;	author jfrijters;	state Exp;
branches;
next	1.165;

1.165
date	2012.09.20.07.41.13;	author jfrijters;	state Exp;
branches;
next	1.164;

1.164
date	2012.09.13.13.21.35;	author jfrijters;	state Exp;
branches;
next	1.163;

1.163
date	2012.08.29.07.05.37;	author jfrijters;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2012.08.06.15.40.12;	author jfrijters;	state Exp;
branches;
next	1.161;

1.161
date	2012.08.06.14.33.54;	author jfrijters;	state Exp;
branches;
next	1.160;

1.160
date	2012.08.06.13.01.41;	author jfrijters;	state Exp;
branches;
next	1.159;

1.159
date	2012.08.06.12.12.03;	author jfrijters;	state Exp;
branches;
next	1.158;

1.158
date	2012.08.06.11.10.47;	author jfrijters;	state Exp;
branches;
next	1.157;

1.157
date	2012.07.03.14.45.51;	author jfrijters;	state Exp;
branches;
next	1.156;

1.156
date	2012.06.20.12.01.15;	author jfrijters;	state Exp;
branches;
next	1.155;

1.155
date	2012.04.12.10.09.09;	author jfrijters;	state Exp;
branches
	1.155.2.1;
next	1.154;

1.154
date	2012.02.23.11.51.07;	author jfrijters;	state Exp;
branches;
next	1.153;

1.153
date	2012.01.20.09.01.07;	author jfrijters;	state Exp;
branches;
next	1.152;

1.152
date	2011.12.15.14.51.15;	author jfrijters;	state Exp;
branches;
next	1.151;

1.151
date	2011.12.14.09.46.56;	author jfrijters;	state Exp;
branches;
next	1.150;

1.150
date	2011.12.08.07.56.09;	author jfrijters;	state Exp;
branches;
next	1.149;

1.149
date	2011.12.07.11.28.17;	author jfrijters;	state Exp;
branches;
next	1.148;

1.148
date	2011.11.29.13.01.09;	author jfrijters;	state Exp;
branches;
next	1.147;

1.147
date	2011.11.25.12.03.57;	author jfrijters;	state Exp;
branches;
next	1.146;

1.146
date	2011.11.24.15.14.03;	author jfrijters;	state Exp;
branches;
next	1.145;

1.145
date	2011.11.24.12.31.39;	author jfrijters;	state Exp;
branches;
next	1.144;

1.144
date	2011.11.23.06.20.34;	author jfrijters;	state Exp;
branches;
next	1.143;

1.143
date	2011.11.18.15.22.46;	author jfrijters;	state Exp;
branches;
next	1.142;

1.142
date	2011.11.17.17.32.54;	author jfrijters;	state Exp;
branches;
next	1.141;

1.141
date	2011.11.17.17.09.10;	author jfrijters;	state Exp;
branches;
next	1.140;

1.140
date	2011.11.17.13.53.02;	author jfrijters;	state Exp;
branches;
next	1.139;

1.139
date	2011.08.16.13.40.05;	author jfrijters;	state Exp;
branches;
next	1.138;

1.138
date	2011.05.12.08.08.09;	author jfrijters;	state Exp;
branches;
next	1.137;

1.137
date	2010.10.21.12.20.13;	author jfrijters;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2010.10.01.08.11.49;	author jfrijters;	state Exp;
branches;
next	1.135;

1.135
date	2010.09.29.07.21.51;	author jfrijters;	state Exp;
branches;
next	1.134;

1.134
date	2010.09.14.14.15.07;	author jfrijters;	state Exp;
branches;
next	1.133;

1.133
date	2010.09.14.12.29.22;	author jfrijters;	state Exp;
branches;
next	1.132;

1.132
date	2010.07.15.12.36.58;	author jfrijters;	state Exp;
branches;
next	1.131;

1.131
date	2010.07.12.06.58.48;	author jfrijters;	state Exp;
branches;
next	1.130;

1.130
date	2010.06.08.12.47.51;	author jfrijters;	state Exp;
branches
	1.130.2.1;
next	1.129;

1.129
date	2010.05.29.13.59.27;	author jfrijters;	state Exp;
branches;
next	1.128;

1.128
date	2010.05.27.09.25.15;	author jfrijters;	state Exp;
branches;
next	1.127;

1.127
date	2010.04.28.14.22.51;	author jfrijters;	state Exp;
branches;
next	1.126;

1.126
date	2010.04.12.06.38.46;	author jfrijters;	state Exp;
branches;
next	1.125;

1.125
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches;
next	1.124;

1.124
date	2010.01.28.08.44.57;	author jfrijters;	state Exp;
branches;
next	1.123;

1.123
date	2010.01.28.07.14.37;	author jfrijters;	state Exp;
branches;
next	1.122;

1.122
date	2010.01.28.06.52.51;	author jfrijters;	state Exp;
branches;
next	1.121;

1.121
date	2010.01.28.06.37.48;	author jfrijters;	state Exp;
branches;
next	1.120;

1.120
date	2010.01.25.07.53.00;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2010.01.06.14.28.38;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2009.12.29.11.24.57;	author smallsql;	state Exp;
branches;
next	1.117;

1.117
date	2009.12.07.05.49.36;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2009.12.07.05.38.18;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2009.12.02.07.49.36;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2009.12.02.05.48.50;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2009.11.13.15.08.22;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2009.11.09.08.52.17;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2009.11.09.05.33.09;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2009.10.14.14.58.41;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2009.08.31.05.02.35;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2009.07.16.06.26.47;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2009.07.14.07.59.42;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2009.06.02.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2009.03.08.06.21.14;	author jfrijters;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2009.03.06.06.43.40;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2009.02.27.06.05.22;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2009.02.10.07.24.30;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2009.02.04.06.50.22;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2008.12.22.05.52.49;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2008.11.14.08.42.07;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2008.08.25.04.16.59;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2008.08.21.06.53.48;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2008.08.21.06.40.23;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2008.08.15.12.01.20;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2008.08.15.06.27.13;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2008.08.12.14.51.14;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2008.08.06.12.22.07;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.03.12.10.30;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2008.06.03.07.13.50;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.31.15.20.39;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2008.05.09.05.58.01;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2008.04.14.05.13.42;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2008.03.03.08.28.23;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2008.03.03.07.05.20;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2007.12.28.14.55.33;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2007.12.19.11.28.11;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2007.12.17.10.59.03;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2007.12.17.07.43.07;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2007.12.04.08.10.53;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2007.11.26.16.00.15;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.26.11.01.29;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.02.05.47.34;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2007.10.10.06.54.22;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2007.09.24.11.57.01;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2007.09.10.06.16.50;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2007.07.31.15.27.22;	author jfrijters;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2007.05.29.16.27.10;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.23.12.47.26;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2007.04.23.08.24.34;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2007.03.13.07.44.23;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2007.02.03.14.16.58;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.06.07.13.11;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2006.12.05.07.52.27;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2006.10.10.16.31.35;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2006.10.04.09.18.35;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2006.10.04.09.03.18;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2006.09.01.07.53.36;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2006.08.31.09.22.10;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2006.08.29.07.20.53;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2006.08.26.13.00.50;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2006.08.17.07.33.40;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2006.08.15.08.50.43;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2006.08.06.09.27.20;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2006.08.02.13.45.54;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2006.07.26.14.16.52;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2006.07.21.10.18.15;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2006.07.06.13.53.52;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.08.09.26.39;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.15.09.08.01;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.06.10.46.52;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.03.08.52.53;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.05.08.19.00;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2006.02.22.14.44.07;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.31.10.13.32;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.19.15.12.50;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.01.07.34.53;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.24.08.14.23;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.16.08.30.15;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.14.15.49.50;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.03.12.59.17;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.20.09.42.11;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.01.09.49.31;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.31.15.30.38;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.31.05.44.30;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.30.11.25.47;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.23.08.24.08;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.17.13.23.45;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.09.07.23.03;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.02.08.12.36;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.02.07.53.47;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.07.09.33.09;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.23.09.33.42;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.16.11.20.46;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.11.14.47.05;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.02.15.12.04;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.21.10.26.54;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.29.09.48.06;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.16.11.11.54;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.04.12.50.33;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.19.13.43.56;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.05.14.02.44;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.04.19.30.54;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.05.09.37.59;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.30.15.56.25;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.25.09.38.07;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.20.08.01.27;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.17.12.01.54;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.17.09.14.51;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.14.10.36.39;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;

1.71.2.1
date	2007.09.13.07.30.10;	author jfrijters;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2007.10.01.13.02.43;	author jfrijters;	state Exp;
branches;
next	1.71.2.3;

1.71.2.3
date	2007.10.12.16.18.41;	author jfrijters;	state Exp;
branches;
next	1.71.2.4;

1.71.2.4
date	2007.12.04.06.04.33;	author jfrijters;	state Exp;
branches;
next	1.71.2.5;

1.71.2.5
date	2010.11.11.05.59.58;	author jfrijters;	state Exp;
branches;
next	;

1.104.2.1
date	2011.05.16.06.54.23;	author jfrijters;	state Exp;
branches;
next	;

1.130.2.1
date	2010.07.12.07.05.00;	author jfrijters;	state Exp;
branches;
next	1.130.2.2;

1.130.2.2
date	2010.07.27.07.15.20;	author jfrijters;	state Exp;
branches;
next	1.130.2.3;

1.130.2.3
date	2010.10.22.07.30.32;	author jfrijters;	state Exp;
branches;
next	;

1.137.2.1
date	2012.10.03.06.18.57;	author jfrijters;	state Exp;
branches;
next	1.137.2.2;

1.137.2.2
date	2013.09.10.15.16.04;	author jfrijters;	state Exp;
branches;
next	;

1.155.2.1
date	2012.06.12.10.27.05;	author jfrijters;	state Exp;
branches;
next	;

1.163.2.1
date	2012.10.08.07.43.48;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.210
log
@Cleaned up static initializer optimization to use FieldWrapper.IsSerialVersionUID.
@
text
@/*
  Copyright (C) 2002-2014 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
#if STATIC_COMPILER || STUB_GENERATOR
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
#else
using System.Reflection;
using System.Reflection.Emit;
#endif
using System.Diagnostics;
using IKVM.Attributes;
using System.Threading;
using System.Runtime.InteropServices;

namespace IKVM.Internal
{
	[Flags]
	enum MemberFlags : short
	{
		None = 0,
		HideFromReflection = 1,
		ExplicitOverride = 2,
		MirandaMethod = 8,
		AccessStub = 16,
		InternalAccess = 32,  // member has "internal" access (@@ikvm.lang.Internal)
		PropertyAccessor = 64,
		Intrinsic = 128,
		CallerID = 256,
		NonPublicTypeInSignature = 512,	// this flag is only available after linking and is not set for access stubs
		DelegateInvokeWithByRefParameter = 1024,
		Type2FinalField = 2048,
		NoOp = 4096, // empty static initializer
	}

	abstract class MemberWrapper
	{
		private HandleWrapper handle;
		private readonly TypeWrapper declaringType;
		protected readonly Modifiers modifiers;
		private MemberFlags flags;
		private readonly string name;
		private readonly string sig;

		private sealed class HandleWrapper
		{
			internal readonly IntPtr Value;

			[System.Security.SecurityCritical]
			internal HandleWrapper(MemberWrapper obj)
			{
				Value = (IntPtr)GCHandle.Alloc(obj, GCHandleType.WeakTrackResurrection);
			}

#if CLASSGC
			[System.Security.SecuritySafeCritical]
			~HandleWrapper()
			{
				if (!Environment.HasShutdownStarted)
				{
					GCHandle h = (GCHandle)Value;
					if (h.Target == null)
					{
						h.Free();
					}
					else
					{
						GC.ReRegisterForFinalize(this);
					}
				}
			}
#endif
		}

		protected MemberWrapper(TypeWrapper declaringType, string name, string sig, Modifiers modifiers, MemberFlags flags)
		{
			Debug.Assert(declaringType != null);
			this.declaringType = declaringType;
			this.name = String.Intern(name);
			this.sig = String.Intern(sig);
			this.modifiers = modifiers;
			this.flags = flags;
		}

		internal IntPtr Cookie
		{
			[System.Security.SecurityCritical]
			get
			{
				lock(this)
				{
					if(handle == null)
					{
						handle = new HandleWrapper(this);
					}
				}
				return handle.Value;
			}
		}

		[System.Security.SecurityCritical]
		internal static MemberWrapper FromCookieImpl(IntPtr cookie)
		{
			return (MemberWrapper)GCHandle.FromIntPtr(cookie).Target;
		}

		internal TypeWrapper DeclaringType
		{
			get
			{
				return declaringType;
			}
		}

		internal string Name
		{
			get
			{
				return name;
			}
		}

		internal string Signature
		{
			get
			{
				return sig;
			}
		}

		internal bool IsAccessibleFrom(TypeWrapper referencedType, TypeWrapper caller, TypeWrapper instance)
		{
			if(referencedType.IsAccessibleFrom(caller))
			{
				return (
					caller == DeclaringType ||
					IsPublicOrProtectedMemberAccessible(caller, instance) ||
					(IsInternal && DeclaringType.InternalsVisibleTo(caller)) ||
					(!IsPrivate && DeclaringType.IsPackageAccessibleFrom(caller)))
					// The JVM supports accessing members that have non-public types in their signature from another package,
					// but the CLI doesn't. It would be nice if we worked around that by emitting extra accessors, but for now
					// we'll simply disallow such access across assemblies (unless the appropriate InternalsVisibleToAttribute exists).
					&& (!(HasNonPublicTypeInSignature || IsType2FinalField) || InPracticeInternalsVisibleTo(caller));
			}
			return false;
		}

		private bool IsPublicOrProtectedMemberAccessible(TypeWrapper caller, TypeWrapper instance)
		{
			if (IsPublic || (IsProtected && caller.IsSubTypeOf(DeclaringType) && (IsStatic || instance.IsUnloadable || instance.IsSubTypeOf(caller))))
			{
				return DeclaringType.IsPublic || InPracticeInternalsVisibleTo(caller);
			}
			return false;
		}

		private bool InPracticeInternalsVisibleTo(TypeWrapper caller)
		{
#if !STATIC_COMPILER
			if (DeclaringType.TypeAsTBD.Assembly.Equals(caller.TypeAsTBD.Assembly))
			{
				// both the caller and the declaring type are in the same assembly
				// so we know that the internals are visible
				// (this handles the case where we're running in dynamic mode)
				return true;
			}
#endif
#if CLASSGC
			if (DeclaringType.IsDynamic)
			{
				// if we are dynamic, we can just become friends with the caller
				DeclaringType.GetClassLoader().GetTypeWrapperFactory().AddInternalsVisibleTo(caller.TypeAsTBD.Assembly);
				return true;
			}
#endif
			return DeclaringType.InternalsVisibleTo(caller);
		}

		internal bool IsHideFromReflection
		{
			get
			{
				return (flags & MemberFlags.HideFromReflection) != 0;
			}
		}

		internal bool IsExplicitOverride
		{
			get
			{
				return (flags & MemberFlags.ExplicitOverride) != 0;
			}
		}

		internal bool IsMirandaMethod
		{
			get
			{
				return (flags & MemberFlags.MirandaMethod) != 0;
			}
		}

		internal bool IsAccessStub
		{
			get
			{
				return (flags & MemberFlags.AccessStub) != 0;
			}
		}

		internal bool IsPropertyAccessor
		{
			get
			{
				return (flags & MemberFlags.PropertyAccessor) != 0;
			}
			set
			{
				// this is unsynchronized, so it may only be called during the JavaTypeImpl constructor
				if(value)
				{
					flags |= MemberFlags.PropertyAccessor;
				}
				else
				{
					flags &= ~MemberFlags.PropertyAccessor;
				}
			}
		}

		internal bool IsIntrinsic
		{
			get
			{
				return (flags & MemberFlags.Intrinsic) != 0;
			}
		}

		protected void SetIntrinsicFlag()
		{
			flags |= MemberFlags.Intrinsic;
		}

		protected void SetNonPublicTypeInSignatureFlag()
		{
			flags |= MemberFlags.NonPublicTypeInSignature;
		}

		internal bool HasNonPublicTypeInSignature
		{
			get { return (flags & MemberFlags.NonPublicTypeInSignature) != 0; }
		}

		protected void SetType2FinalField()
		{
			flags |= MemberFlags.Type2FinalField;
		}
	
		internal bool IsType2FinalField
		{
			get { return (flags & MemberFlags.Type2FinalField) != 0; }
		}

		internal bool HasCallerID
		{
			get
			{
				return (flags & MemberFlags.CallerID) != 0;
			}
		}

		internal bool IsDelegateInvokeWithByRefParameter
		{
			get { return (flags & MemberFlags.DelegateInvokeWithByRefParameter) != 0; }
		}

		internal bool IsNoOp
		{
			get { return (flags & MemberFlags.NoOp) != 0; }
		}

		internal Modifiers Modifiers
		{
			get
			{
				return modifiers;
			}
		}

		internal bool IsStatic
		{
			get
			{
				return (modifiers & Modifiers.Static) != 0;
			}
		}

		internal bool IsInternal
		{
			get
			{
				return (flags & MemberFlags.InternalAccess) != 0;
			}
		}

		internal bool IsPublic
		{
			get
			{
				return (modifiers & Modifiers.Public) != 0;
			}
		}

		internal bool IsPrivate
		{
			get
			{
				return (modifiers & Modifiers.Private) != 0;
			}
		}

		internal bool IsProtected
		{
			get
			{
				return (modifiers & Modifiers.Protected) != 0;
			}
		}

		internal bool IsFinal
		{
			get
			{
				return (modifiers & Modifiers.Final) != 0;
			}
		}
	}

	abstract class MethodWrapper : MemberWrapper
	{
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
		private volatile java.lang.reflect.Executable reflectionMethod;
#endif
		internal static readonly MethodWrapper[] EmptyArray  = new MethodWrapper[0];
		private MethodBase method;
		private string[] declaredExceptions;
		private TypeWrapper returnTypeWrapper;
		private TypeWrapper[] parameterTypeWrappers;

#if EMITTERS
		internal virtual void EmitCall(CodeEmitter ilgen)
		{
			throw new InvalidOperationException();
		}

		internal virtual void EmitCallvirt(CodeEmitter ilgen)
		{
			throw new InvalidOperationException();
		}

		internal virtual void EmitCallvirtReflect(CodeEmitter ilgen)
		{
			EmitCallvirt(ilgen);
		}

		internal virtual void EmitNewobj(CodeEmitter ilgen)
		{
			throw new InvalidOperationException();
		}

		internal virtual bool EmitIntrinsic(EmitIntrinsicContext context)
		{
			return Intrinsics.Emit(context);
		}
#endif // EMITTERS

		internal virtual bool IsDynamicOnly
		{
			get
			{
				return false;
			}
		}

		internal MethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, modifiers, flags)
		{
			Profiler.Count("MethodWrapper");
			this.method = method;
			Debug.Assert(((returnType == null) == (parameterTypes == null)) || (returnType == PrimitiveTypeWrapper.VOID));
			this.returnTypeWrapper = returnType;
			this.parameterTypeWrappers = parameterTypes;
			if (Intrinsics.IsIntrinsic(this))
			{
				SetIntrinsicFlag();
			}
			UpdateNonPublicTypeInSignatureFlag();
		}

		private void UpdateNonPublicTypeInSignatureFlag()
		{
			if ((IsPublic || IsProtected) && (returnTypeWrapper != null && parameterTypeWrappers != null) && !(this is AccessStubMethodWrapper) && !(this is AccessStubConstructorMethodWrapper))
			{
				if (!returnTypeWrapper.IsPublic && !returnTypeWrapper.IsUnloadable)
				{
					SetNonPublicTypeInSignatureFlag();
				}
				else
				{
					foreach (TypeWrapper tw in parameterTypeWrappers)
					{
						if (!tw.IsPublic && !tw.IsUnloadable)
						{
							SetNonPublicTypeInSignatureFlag();
							break;
						}
					}
				}
			}
		}

		internal void SetDeclaredExceptions(string[] exceptions)
		{
			if(exceptions == null)
			{
				exceptions = new string[0];
			}
			this.declaredExceptions = (string[])exceptions.Clone();
		}

		internal string[] GetDeclaredExceptions()
		{
			return declaredExceptions;
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal java.lang.reflect.Executable ToMethodOrConstructor(bool copy)
		{
#if FIRST_PASS
			return null;
#else
			java.lang.reflect.Executable method = reflectionMethod;
			if (method == null)
			{
				Link();
				ClassLoaderWrapper loader = this.DeclaringType.GetClassLoader();
				TypeWrapper[] argTypes = GetParameters();
				java.lang.Class[] parameterTypes = new java.lang.Class[argTypes.Length];
				for (int i = 0; i < argTypes.Length; i++)
				{
					parameterTypes[i] = argTypes[i].EnsureLoadable(loader).ClassObject;
				}
				java.lang.Class[] checkedExceptions = GetExceptions();
				if (this.IsConstructor)
				{
					method = new java.lang.reflect.Constructor(
						this.DeclaringType.ClassObject,
						parameterTypes,
						checkedExceptions,
						(int)this.Modifiers | (this.IsInternal ? 0x40000000 : 0),
						Array.IndexOf(this.DeclaringType.GetMethods(), this),
						this.DeclaringType.GetGenericMethodSignature(this),
						null,
						null
					);
				}
				else
				{
					method = new java.lang.reflect.Method(
						this.DeclaringType.ClassObject,
						this.Name,
						parameterTypes,
						this.ReturnType.EnsureLoadable(loader).ClassObject,
						checkedExceptions,
						(int)this.Modifiers | (this.IsInternal ? 0x40000000 : 0),
						Array.IndexOf(this.DeclaringType.GetMethods(), this),
						this.DeclaringType.GetGenericMethodSignature(this),
						null,
						null,
						null
					);
				}
				lock (this)
				{
					if (reflectionMethod == null)
					{
						reflectionMethod = method;
					}
					else
					{
						method = reflectionMethod;
					}
				}
			}
			if (copy)
			{
				java.lang.reflect.Constructor ctor = method as java.lang.reflect.Constructor;
				if (ctor != null)
				{
					return ctor.copy();
				}
				return ((java.lang.reflect.Method)method).copy();
			}
			return method;
#endif
		}

#if !FIRST_PASS
		private java.lang.Class[] GetExceptions()
		{
			string[] classes = declaredExceptions;
			Type[] types = Type.EmptyTypes;
			if (classes == null)
			{
				// NOTE if method is a MethodBuilder, GetCustomAttributes doesn't work (and if
				// the method had any declared exceptions, the declaredExceptions field would have
				// been set)
				if (method != null && !(method is MethodBuilder))
				{
					ThrowsAttribute attr = AttributeHelper.GetThrows(method);
					if (attr != null)
					{
						classes = attr.classes;
						types = attr.types;
					}
				}
			}
			if (classes != null)
			{
				java.lang.Class[] array = new java.lang.Class[classes.Length];
				for (int i = 0; i < classes.Length; i++)
				{
					array[i] = this.DeclaringType.GetClassLoader().LoadClassByDottedName(classes[i]).ClassObject;
				}
				return array;
			}
			else
			{
				java.lang.Class[] array = new java.lang.Class[types.Length];
				for (int i = 0; i < types.Length; i++)
				{
					array[i] = types[i];
				}
				return array;
			}
		}
#endif // !FIRST_PASS

		internal static MethodWrapper FromExecutable(java.lang.reflect.Executable executable)
		{
#if FIRST_PASS
			return null;
#else
			return TypeWrapper.FromClass(executable.getDeclaringClass()).GetMethods()[executable._slot()];
#endif
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR

		[System.Security.SecurityCritical]
		internal static MethodWrapper FromCookie(IntPtr cookie)
		{
			return (MethodWrapper)FromCookieImpl(cookie);
		}

		internal bool IsLinked
		{
			get
			{
				return parameterTypeWrappers != null;
			}
		}

		internal void Link()
		{
			Link(LoadMode.Link);
		}

		internal void Link(LoadMode mode)
		{
			lock(this)
			{
				if(parameterTypeWrappers != null)
				{
					return;
				}
			}
			ClassLoaderWrapper loader = this.DeclaringType.GetClassLoader();
			TypeWrapper ret = loader.RetTypeWrapperFromSig(Signature, mode);
			TypeWrapper[] parameters = loader.ArgTypeWrapperListFromSig(Signature, mode);
			lock(this)
			{
				try
				{
					// critical code in the finally block to avoid Thread.Abort interrupting the thread
				}
				finally
				{
					if(parameterTypeWrappers == null)
					{
						Debug.Assert(returnTypeWrapper == null || returnTypeWrapper == PrimitiveTypeWrapper.VOID);
						returnTypeWrapper = ret;
						parameterTypeWrappers = parameters;
						UpdateNonPublicTypeInSignatureFlag();
						if(method == null)
						{
							try
							{
								DoLinkMethod();
							}
							catch
							{
								// HACK if linking fails, we unlink to make sure
								// that the next link attempt will fail again
								returnTypeWrapper = null;
								parameterTypeWrappers = null;
								throw;
							}
						}
					}
				}
			}
		}

		protected virtual void DoLinkMethod()
		{
			method = this.DeclaringType.LinkMethod(this);
		}

		[Conditional("DEBUG")]
		internal void AssertLinked()
		{
			if(!(parameterTypeWrappers != null && returnTypeWrapper != null))
			{
				Tracer.Error(Tracer.Runtime, "AssertLinked failed: " + this.DeclaringType.Name + "::" + this.Name + this.Signature);
			}
			Debug.Assert(parameterTypeWrappers != null && returnTypeWrapper != null, this.DeclaringType.Name + "::" + this.Name + this.Signature);
		}

		internal TypeWrapper ReturnType
		{
			get
			{
				AssertLinked();
				return returnTypeWrapper;
			}
		}

		internal TypeWrapper[] GetParameters()
		{
			AssertLinked();
			return parameterTypeWrappers;
		}

#if !STUB_GENERATOR
		internal DefineMethodHelper GetDefineMethodHelper()
		{
			return new DefineMethodHelper(this);
		}
#endif

		internal Type ReturnTypeForDefineMethod
		{
			get
			{
				return ReturnType.TypeAsSignatureType;
			}
		}

		internal Type[] GetParametersForDefineMethod()
		{
			TypeWrapper[] wrappers = GetParameters();
			int len = wrappers.Length;
			if(HasCallerID)
			{
				len++;
			}
			Type[] temp = new Type[len];
			for(int i = 0; i < wrappers.Length; i++)
			{
				temp[i] = wrappers[i].TypeAsSignatureType;
			}
			if(HasCallerID)
			{
				temp[len - 1] = CoreClasses.ikvm.@@internal.CallerID.Wrapper.TypeAsSignatureType;
			}
			return temp;
		}

		// we expose the underlying MethodBase object,
		// for Java types, this is the method that contains the compiled Java bytecode
		// for remapped types, this is the mbCore method (not the helper)
		// Note that for some artificial methods (notably wrap() in enums), method is null
		internal MethodBase GetMethod()
		{
			AssertLinked();
			return method;
		}

		internal string RealName
		{
			get
			{
				AssertLinked();
				return method.Name;
			}
		}

		internal bool IsAbstract
		{
			get
			{
				return (Modifiers & Modifiers.Abstract) != 0;
			}
		}

		internal bool RequiresNonVirtualDispatcher
		{
			get
			{
				return !IsConstructor
					&& !IsStatic
					&& !IsPrivate
					&& !IsAbstract
					&& !IsFinal
					&& !DeclaringType.IsFinal;
			}
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal Type GetDelegateType()
		{
			TypeWrapper[] paramTypes = GetParameters();
			if (paramTypes.Length > MethodHandleUtil.MaxArity)
			{
				Type type = DeclaringType.TypeAsBaseType.Assembly.GetType(
					ReturnType == PrimitiveTypeWrapper.VOID ? "__<>NVIV`" + paramTypes.Length : "__<>NVI`" + (paramTypes.Length + 1));
				if (type == null)
				{
					type = DeclaringType.GetClassLoader().GetTypeWrapperFactory().DefineDelegate(paramTypes.Length, ReturnType == PrimitiveTypeWrapper.VOID);
				}
				Type[] types = new Type[paramTypes.Length + (ReturnType == PrimitiveTypeWrapper.VOID ? 0 : 1)];
				for (int i = 0; i < paramTypes.Length; i++)
				{
					types[i] = paramTypes[i].TypeAsSignatureType;
				}
				if (ReturnType != PrimitiveTypeWrapper.VOID)
				{
					types[types.Length - 1] = ReturnType.TypeAsSignatureType;
				}
				return type.MakeGenericType(types);
			}
			return MethodHandleUtil.CreateMemberWrapperDelegateType(paramTypes, ReturnType);
		}

		internal void ResolveMethod()
		{
#if !FIRST_PASS
			// if we've still got the builder object, we need to replace it with the real thing before we can call it
			MethodBuilder mb = method as MethodBuilder;
			if (mb != null)
			{
				method = mb.Module.ResolveMethod(mb.GetToken().Token);
			}
#endif
		}

		[HideFromJava]
		internal virtual object InvokeNonvirtualRemapped(object obj, object[] args)
		{
			throw new InvalidOperationException();
		}

		[HideFromJava]
		protected static object InvokeAndUnwrapException(MethodBase mb, object obj, object[] args)
		{
#if FIRST_PASS
			return null;
#else
			try
			{
				return mb.Invoke(obj, args);
			}
			catch (TargetInvocationException x)
			{
				throw ikvm.runtime.Util.mapException(x.InnerException);
			}
#endif
		}

		[HideFromJava]
		internal virtual object Invoke(object obj, object[] args)
		{
			return InvokeAndUnwrapException(method, obj, args);
		}

		[HideFromJava]
		internal virtual object CreateInstance(object[] args)
		{
#if FIRST_PASS
			return null;
#else
			try
			{
				return ((ConstructorInfo)method).Invoke(args);
			}
			catch (TargetInvocationException x)
			{
				throw ikvm.runtime.Util.mapException(x.InnerException);
			}
#endif
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR

		internal static OpCode SimpleOpCodeToOpCode(SimpleOpCode opc)
		{
			switch(opc)
			{
				case SimpleOpCode.Call:
					return OpCodes.Call;
				case SimpleOpCode.Callvirt:
					return OpCodes.Callvirt;
				case SimpleOpCode.Newobj:
					return OpCodes.Newobj;
				default:
					throw new InvalidOperationException();
			}
		}

		internal virtual bool IsOptionalAttributeAnnotationValue
		{
			get { return false; }
		}

		internal bool IsConstructor
		{
			get { return (object)Name == (object)StringConstants.INIT; }
		}

		internal bool IsClassInitializer
		{
			get { return (object)Name == (object)StringConstants.CLINIT; }
		}

		internal bool IsVirtual
		{
			get
			{
				return (modifiers & (Modifiers.Static | Modifiers.Private)) == 0
					&& !IsConstructor;
			}
		}

		internal bool IsFinalizeOrClone
		{
			get
			{
				return IsProtected
					&& (DeclaringType == CoreClasses.java.lang.Object.Wrapper || DeclaringType == CoreClasses.java.lang.Throwable.Wrapper)
					&& (Name == StringConstants.CLONE || Name == StringConstants.FINALIZE);
			}
		}
	}

	abstract class SmartMethodWrapper : MethodWrapper
	{
		internal SmartMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
		{
		}

#if EMITTERS
		internal sealed override void EmitCall(CodeEmitter ilgen)
		{
			AssertLinked();
			CallImpl(ilgen);
		}

		protected virtual void CallImpl(CodeEmitter ilgen)
		{
			throw new InvalidOperationException();
		}

		internal sealed override void EmitCallvirt(CodeEmitter ilgen)
		{
			AssertLinked();
			if(DeclaringType.IsNonPrimitiveValueType)
			{
				// callvirt isn't allowed on a value type
				// (we don't need to check for a null reference, because we're always dealing with an unboxed value)
				CallImpl(ilgen);
			}
			else
			{
				CallvirtImpl(ilgen);
			}
		}

		protected virtual void CallvirtImpl(CodeEmitter ilgen)
		{
			throw new InvalidOperationException();
		}

		internal sealed override void EmitNewobj(CodeEmitter ilgen)
		{
			AssertLinked();
			NewobjImpl(ilgen);
			if(DeclaringType.IsNonPrimitiveValueType)
			{
				DeclaringType.EmitBox(ilgen);
			}
		}

		protected virtual void NewobjImpl(CodeEmitter ilgen)
		{
			throw new InvalidOperationException();
		}
#endif // EMITTERS
	}

	enum SimpleOpCode : byte
	{
		Call,
		Callvirt,
		Newobj
	}

	sealed class SimpleCallMethodWrapper : MethodWrapper
	{
		private readonly SimpleOpCode call;
		private readonly SimpleOpCode callvirt;

		internal SimpleCallMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags, SimpleOpCode call, SimpleOpCode callvirt)
			: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
		{
			this.call = call;
			this.callvirt = callvirt;
		}

#if EMITTERS
		internal override void EmitCall(CodeEmitter ilgen)
		{
			ilgen.Emit(SimpleOpCodeToOpCode(call), GetMethod());
		}

		internal override void EmitCallvirt(CodeEmitter ilgen)
		{
			ilgen.Emit(SimpleOpCodeToOpCode(callvirt), GetMethod());
		}
#endif // EMITTERS
	}

	sealed class TypicalMethodWrapper : SmartMethodWrapper
	{
		internal TypicalMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
		{
		}

#if EMITTERS
		protected override void CallImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, GetMethod());
		}

		protected override void CallvirtImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Callvirt, GetMethod());
		}

		protected override void NewobjImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Newobj, GetMethod());
		}
#endif // EMITTERS
	}

	abstract class MirandaMethodWrapper : SmartMethodWrapper
	{
		private readonly MethodWrapper ifmethod;

		private MirandaMethodWrapper(TypeWrapper declaringType, MethodWrapper ifmethod, Modifiers modifiers)
			: base(declaringType, ifmethod.Name, ifmethod.Signature, null, null, null, modifiers, MemberFlags.HideFromReflection | MemberFlags.MirandaMethod)
		{
			this.ifmethod = ifmethod;
		}

		private sealed class AbstractMirandaMethodWrapper : MirandaMethodWrapper
		{
			internal AbstractMirandaMethodWrapper(TypeWrapper declaringType, MethodWrapper ifmethod)
				: base(declaringType, ifmethod, Modifiers.Public | Modifiers.Abstract)
			{
			}
		}

		private sealed class DefaultMirandaMethodWrapper : MirandaMethodWrapper
		{
			internal DefaultMirandaMethodWrapper(TypeWrapper declaringType, MethodWrapper ifmethod)
				: base(declaringType, ifmethod, Modifiers.Public)
			{
			}
		}

		private sealed class ErrorMirandaMethodWrapper : MirandaMethodWrapper
		{
			private string error;

			internal ErrorMirandaMethodWrapper(TypeWrapper declaringType, MethodWrapper ifmethod, string error)
				: base(declaringType, ifmethod, Modifiers.Public)
			{
				this.error = error;
			}

			protected override MirandaMethodWrapper AddConflictError(MethodWrapper mw)
			{
				error += " " + mw.DeclaringType.Name + "." + mw.Name;
				return this;
			}

			internal override string Error
			{
				get { return error; }
			}
		}

		internal static MirandaMethodWrapper Create(TypeWrapper declaringType, MethodWrapper ifmethod)
		{
			DefaultMirandaMethodWrapper dmmw = ifmethod as DefaultMirandaMethodWrapper;
			if (dmmw != null)
			{
				return new DefaultMirandaMethodWrapper(declaringType, dmmw.BaseMethod);
			}
			return ifmethod.IsAbstract
				? (MirandaMethodWrapper)new AbstractMirandaMethodWrapper(declaringType, ifmethod)
				: (MirandaMethodWrapper)new DefaultMirandaMethodWrapper(declaringType, ifmethod);
		}

		internal MirandaMethodWrapper Update(MethodWrapper mw)
		{
			if (ifmethod == mw)
			{
				// an interface can be implemented multiple times
				return this;
			}
			else if (ifmethod.DeclaringType.ImplementsInterface(mw.DeclaringType))
			{
				// we can override a base interface without problems
				return this;
			}
			else if (mw.DeclaringType.ImplementsInterface(ifmethod.DeclaringType))
			{
				return Create(DeclaringType, mw);
			}
			else if (!ifmethod.IsAbstract && !mw.IsAbstract)
			{
				return AddConflictError(mw);
			}
			else if (!ifmethod.IsAbstract && mw.IsAbstract)
			{
				return new ErrorMirandaMethodWrapper(DeclaringType, mw, DeclaringType.Name + "." + Name + Signature);
			}
			else
			{
				return this;
			}
		}

		protected virtual MirandaMethodWrapper AddConflictError(MethodWrapper mw)
		{
			return new ErrorMirandaMethodWrapper(DeclaringType, ifmethod, "Conflicting default methods:")
				.AddConflictError(ifmethod)
				.AddConflictError(mw);
		}

		internal bool IsConflictError
		{
			get { return Error != null && Error.StartsWith("Conflicting default methods:"); }
		}

		internal MethodWrapper BaseMethod
		{
			get { return ifmethod; }
		}

		internal virtual string Error
		{
			get { return null; }
		}

#if EMITTERS
		protected override void CallImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, GetMethod());
		}

		protected override void CallvirtImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Callvirt, GetMethod());
		}
#endif // EMITTERS
	}

	sealed class GhostMethodWrapper : SmartMethodWrapper
	{
		private MethodInfo ghostMethod;
		private MethodInfo defaultImpl;

		internal GhostMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, MethodInfo ghostMethod, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
		{
			// make sure we weren't handed the ghostMethod in the wrapper value type
			Debug.Assert(method == null || method.DeclaringType.IsInterface);
			this.ghostMethod = ghostMethod;
		}

#if EMITTERS
		protected override void CallImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, defaultImpl);
		}

		protected override void CallvirtImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, ghostMethod);
		}
#endif

#if !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
		[HideFromJava]
		internal override object Invoke(object obj, object[] args)
		{
			return InvokeAndUnwrapException(ghostMethod, DeclaringType.GhostWrap(obj), args);
		}
#endif

		internal void SetDefaultImpl(MethodInfo impl)
		{
			this.defaultImpl = impl;
		}

		internal MethodInfo GetDefaultImpl()
		{
			return defaultImpl;
		}

#if STATIC_COMPILER
		internal void SetGhostMethod(MethodBuilder mb)
		{
			this.ghostMethod = mb;
		}

		internal MethodBuilder GetGhostMethod()
		{
			return (MethodBuilder)ghostMethod;
		}
#endif
	}

	sealed class AccessStubMethodWrapper : SmartMethodWrapper
	{
		private readonly MethodInfo stubVirtual;
		private readonly MethodInfo stubNonVirtual;

		internal AccessStubMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodInfo core, MethodInfo stubVirtual, MethodInfo stubNonVirtual, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, core, returnType, parameterTypes, modifiers, flags)
		{
			this.stubVirtual = stubVirtual;
			this.stubNonVirtual = stubNonVirtual;
		}

#if EMITTERS
		protected override void CallImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, stubNonVirtual);
		}

		protected override void CallvirtImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Callvirt, stubVirtual);
		}
#endif // EMITTERS
	}

	sealed class AccessStubConstructorMethodWrapper : SmartMethodWrapper
	{
		private readonly ConstructorInfo stub;

		internal AccessStubConstructorMethodWrapper(TypeWrapper declaringType, string sig, ConstructorInfo core, ConstructorInfo stub, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, StringConstants.INIT, sig, core, PrimitiveTypeWrapper.VOID, parameterTypes, modifiers, flags)
		{
			this.stub = stub;
		}

#if EMITTERS
		protected override void CallImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, stub);
		}

		protected override void NewobjImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Newobj, stub);
		}
#endif // EMITTERS
	}

	sealed class DefaultInterfaceMethodWrapper : SmartMethodWrapper
	{
		private MethodInfo impl;

		internal DefaultInterfaceMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodInfo ifmethod, MethodInfo impl, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, ifmethod, returnType, parameterTypes, modifiers, flags)
		{
			this.impl = impl;
		}

		internal static MethodInfo GetImpl(MethodWrapper mw)
		{
			DefaultInterfaceMethodWrapper dimw = mw as DefaultInterfaceMethodWrapper;
			if (dimw != null)
			{
				return dimw.impl;
			}
			else
			{
				return ((GhostMethodWrapper)mw).GetDefaultImpl();
			}
		}

		internal static void SetImpl(MethodWrapper mw, MethodInfo impl)
		{
			DefaultInterfaceMethodWrapper dimw = mw as DefaultInterfaceMethodWrapper;
			if (dimw != null)
			{
				dimw.impl = impl;
			}
			else
			{
				((GhostMethodWrapper)mw).SetDefaultImpl(impl);
			}
		}

#if EMITTERS
		protected override void CallImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, impl);
		}

		protected override void CallvirtImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Callvirt, GetMethod());
		}
#endif // EMITTERS
	}

	sealed class PrivateInterfaceMethodWrapper : SmartMethodWrapper
	{
		internal PrivateInterfaceMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
		{
		}

#if EMITTERS
		protected override void CallImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, GetMethod());
		}

		protected override void CallvirtImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, GetMethod());
		}
#endif // EMITTERS
	}

	abstract class FieldWrapper : MemberWrapper
	{
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
		private volatile java.lang.reflect.Field reflectionField;
		private sun.reflect.FieldAccessor jniAccessor;
#endif
		internal static readonly FieldWrapper[] EmptyArray  = new FieldWrapper[0];
		private FieldInfo field;
		private TypeWrapper fieldType;

		internal FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, MemberFlags flags)
			: base(declaringType, name, sig, modifiers, flags)
		{
			Debug.Assert(name != null);
			Debug.Assert(sig != null);
			this.fieldType = fieldType;
			this.field = field;
			UpdateNonPublicTypeInSignatureFlag();
#if STATIC_COMPILER
			if (IsFinal
				&& DeclaringType.IsPublic
				&& !DeclaringType.IsInterface
				&& (IsPublic || (IsProtected && !DeclaringType.IsFinal))
				&& !DeclaringType.GetClassLoader().StrictFinalFieldSemantics
				&& DeclaringType.IsDynamic
				&& !(this is ConstantFieldWrapper)
				&& !(this is DynamicPropertyFieldWrapper))
			{
				SetType2FinalField();
			}
#endif
		}

		internal FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, ExModifiers modifiers, FieldInfo field)
			: this(declaringType, fieldType, name, sig, modifiers.Modifiers, field,
					(modifiers.IsInternal ? MemberFlags.InternalAccess : MemberFlags.None))
		{
		}

		private void UpdateNonPublicTypeInSignatureFlag()
		{
			if ((IsPublic || IsProtected) && fieldType != null && !IsAccessStub)
			{
				if (!fieldType.IsPublic && !fieldType.IsUnloadable)
				{
					SetNonPublicTypeInSignatureFlag();
				}
			}
		}

		internal FieldInfo GetField()
		{
			AssertLinked();
			return field;
		}

		[Conditional("DEBUG")]
		internal void AssertLinked()
		{
			if(fieldType == null)
			{
				Tracer.Error(Tracer.Runtime, "AssertLinked failed: " + this.DeclaringType.Name + "::" + this.Name + " (" + this.Signature + ")");
			}
			Debug.Assert(fieldType != null, this.DeclaringType.Name + "::" + this.Name + " (" + this.Signature+ ")");
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal static FieldWrapper FromField(java.lang.reflect.Field field)
		{
#if FIRST_PASS
			return null;
#else
			int slot = field._slot();
			if (slot == -1)
			{
				// it's a Field created by Unsafe.objectFieldOffset(Class,String) so we must resolve based on the name
				foreach (FieldWrapper fw in TypeWrapper.FromClass(field.getDeclaringClass()).GetFields())
				{
					if (fw.Name == field.getName())
					{
						return fw;
					}
				}
			}
			return TypeWrapper.FromClass(field.getDeclaringClass()).GetFields()[slot];
#endif
		}

		internal object ToField(bool copy)
		{
			return ToField(copy, null);
		}

		internal object ToField(bool copy, int? fieldIndex)
		{
#if FIRST_PASS
			return null;
#else
			java.lang.reflect.Field field = reflectionField;
			if (field == null)
			{
				const Modifiers ReflectionFieldModifiersMask = Modifiers.Public | Modifiers.Private | Modifiers.Protected | Modifiers.Static
					| Modifiers.Final | Modifiers.Volatile | Modifiers.Transient | Modifiers.Synthetic | Modifiers.Enum;
				Link();
				field = new java.lang.reflect.Field(
					this.DeclaringType.ClassObject,
					this.Name,
					this.FieldTypeWrapper.EnsureLoadable(this.DeclaringType.GetClassLoader()).ClassObject,
					(int)(this.Modifiers & ReflectionFieldModifiersMask) | (this.IsInternal ? 0x40000000 : 0),
					fieldIndex ?? Array.IndexOf(this.DeclaringType.GetFields(), this),
					this.DeclaringType.GetGenericFieldSignature(this),
					null
				);
			}
			lock (this)
			{
				if (reflectionField == null)
				{
					reflectionField = field;
				}
				else
				{
					field = reflectionField;
				}
			}
			if (copy)
			{
				field = field.copy();
			}
			return field;
#endif // FIRST_PASS
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR

		[System.Security.SecurityCritical]
		internal static FieldWrapper FromCookie(IntPtr cookie)
		{
			return (FieldWrapper)FromCookieImpl(cookie);
		}

		internal TypeWrapper FieldTypeWrapper
		{
			get
			{
				AssertLinked();
				return fieldType;
			}
		}

#if EMITTERS
		internal void EmitGet(CodeEmitter ilgen)
		{
			AssertLinked();
			EmitGetImpl(ilgen);
		}

		protected abstract void EmitGetImpl(CodeEmitter ilgen);

		internal void EmitSet(CodeEmitter ilgen)
		{
			AssertLinked();
			EmitSetImpl(ilgen);
		}

		protected abstract void EmitSetImpl(CodeEmitter ilgen);
#endif // EMITTERS


#if STATIC_COMPILER
		internal bool IsLinked
		{
			get { return fieldType != null; }
		}
#endif

		internal void Link()
		{
			Link(LoadMode.Link);
		}

		internal void Link(LoadMode mode)
		{
			lock(this)
			{
				if(fieldType != null)
				{
					return;
				}
			}
			TypeWrapper fld = this.DeclaringType.GetClassLoader().FieldTypeWrapperFromSig(Signature, mode);
			lock(this)
			{
				try
				{
					// critical code in the finally block to avoid Thread.Abort interrupting the thread
				}
				finally
				{
					if(fieldType == null)
					{
						fieldType = fld;
						UpdateNonPublicTypeInSignatureFlag();
						try
						{
							field = this.DeclaringType.LinkField(this);
						}
						catch
						{
							// HACK if linking fails, we unlink to make sure
							// that the next link attempt will fail again
							fieldType = null;
							throw;
						}
					}
				}
			}
		}

		internal bool IsVolatile
		{
			get
			{
				return (Modifiers & Modifiers.Volatile) != 0;
			}
		}

		internal bool IsSerialVersionUID
		{
			get
			{
				// a serialVersionUID field must be static and final to be recognized (see ObjectStreamClass.getDeclaredSUID())
				return (Modifiers & (Modifiers.Static | Modifiers.Final)) == (Modifiers.Static | Modifiers.Final)
					&& Name == "serialVersionUID"
					&& (FieldTypeWrapper == PrimitiveTypeWrapper.LONG
						|| FieldTypeWrapper == PrimitiveTypeWrapper.INT
						|| FieldTypeWrapper == PrimitiveTypeWrapper.CHAR
						|| FieldTypeWrapper == PrimitiveTypeWrapper.SHORT
						|| FieldTypeWrapper == PrimitiveTypeWrapper.BYTE);
			}
		}

		internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, ExModifiers modifiers)
		{
			// volatile long & double field accesses must be made atomic
			if((modifiers.Modifiers & Modifiers.Volatile) != 0 && (sig == "J" || sig == "D"))
			{
				return new VolatileLongDoubleFieldWrapper(declaringType, fieldType, fi, name, sig, modifiers);
			}
			return new SimpleFieldWrapper(declaringType, fieldType, fi, name, sig, modifiers);
		}

#if !STATIC_COMPILER && !STUB_GENERATOR
		internal virtual void ResolveField()
		{
			FieldBuilder fb = field as FieldBuilder;
			if(fb != null)
			{
				field = fb.Module.ResolveField(fb.GetToken().Token);
			}
		}

		internal object GetFieldAccessorJNI()
		{
#if FIRST_PASS
			return null;
#else
			if (jniAccessor == null)
			{
				Interlocked.CompareExchange(ref jniAccessor, Java_sun_reflect_ReflectionFactory.NewFieldAccessorJNI(this), null);
			}
			return jniAccessor;
#endif
		}

#if !FIRST_PASS
		internal abstract object GetValue(object obj);
		internal abstract void SetValue(object obj, object value);
#endif
#endif // !STATIC_COMPILER && !STUB_GENERATOR
	}

	sealed class SimpleFieldWrapper : FieldWrapper
	{
		internal SimpleFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, ExModifiers modifiers)
			: base(declaringType, fieldType, name, sig, modifiers, fi)
		{
			Debug.Assert(!(fieldType == PrimitiveTypeWrapper.DOUBLE || fieldType == PrimitiveTypeWrapper.LONG) || !IsVolatile);
		}

#if EMITTERS
		protected override void EmitGetImpl(CodeEmitter ilgen)
		{
			if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
			{
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
			}
			if(IsVolatile)
			{
				ilgen.Emit(OpCodes.Volatile);
			}
			ilgen.Emit(IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, GetField());
		}

		protected override void EmitSetImpl(CodeEmitter ilgen)
		{
			FieldInfo fi = GetField();
			if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
			{
				CodeEmitterLocal temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsSignatureType);
				ilgen.Emit(OpCodes.Stloc, temp);
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				ilgen.Emit(OpCodes.Ldloc, temp);
			}
			if(IsVolatile)
			{
				ilgen.Emit(OpCodes.Volatile);
			}
			ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
			if(IsVolatile)
			{
				ilgen.EmitMemoryBarrier();
			}
		}
#endif // EMITTERS

#if !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
		internal override object GetValue(object obj)
		{
			return GetField().GetValue(obj);
		}

		internal override void SetValue(object obj, object value)
		{
			GetField().SetValue(obj, value);
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
	}

	sealed class VolatileLongDoubleFieldWrapper : FieldWrapper
	{
		internal VolatileLongDoubleFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, ExModifiers modifiers)
			: base(declaringType, fieldType, name, sig, modifiers, fi)
		{
			Debug.Assert(IsVolatile);
			Debug.Assert(sig == "J" || sig == "D");
		}

#if EMITTERS
		protected override void EmitGetImpl(CodeEmitter ilgen)
		{
			FieldInfo fi = GetField();
			if(fi.IsStatic)
			{
				ilgen.Emit(OpCodes.Ldsflda, fi);
			}
			else
			{
				if(DeclaringType.IsNonPrimitiveValueType)
				{
					ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				}
				ilgen.Emit(OpCodes.Ldflda, fi);
			}
			if(FieldTypeWrapper == PrimitiveTypeWrapper.DOUBLE)
			{
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.volatileReadDouble);
			}
			else
			{
				Debug.Assert(FieldTypeWrapper == PrimitiveTypeWrapper.LONG);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.volatileReadLong);
			}
		}

		protected override void EmitSetImpl(CodeEmitter ilgen)
		{
			FieldInfo fi = GetField();
			CodeEmitterLocal temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsSignatureType);
			ilgen.Emit(OpCodes.Stloc, temp);
			if(fi.IsStatic)
			{
				ilgen.Emit(OpCodes.Ldsflda, fi);
			}
			else
			{
				if(DeclaringType.IsNonPrimitiveValueType)
				{
					ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				}
				ilgen.Emit(OpCodes.Ldflda, fi);
			}
			ilgen.Emit(OpCodes.Ldloc, temp);
			if(FieldTypeWrapper == PrimitiveTypeWrapper.DOUBLE)
			{
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.volatileWriteDouble);
			}
			else
			{
				Debug.Assert(FieldTypeWrapper == PrimitiveTypeWrapper.LONG);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.volatileWriteLong);
			}
		}
#endif // EMITTERS

#if !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
#if NO_REF_EMIT
		internal static readonly object lockObject = new object();
#endif

		internal override object GetValue(object obj)
		{
#if NO_REF_EMIT
			lock (lockObject)
			{
				return GetField().GetValue(obj);
			}
#else
			throw new InvalidOperationException();
#endif
		}

		internal override void SetValue(object obj, object value)
		{
#if NO_REF_EMIT
			lock (lockObject)
			{
				GetField().SetValue(obj, value);
			}
#else
			throw new InvalidOperationException();
#endif
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
	}

#if !STUB_GENERATOR
	// this class represents a .NET property defined in Java with the ikvm.lang.Property annotation
	sealed class DynamicPropertyFieldWrapper : FieldWrapper
	{
		private readonly MethodWrapper getter;
		private readonly MethodWrapper setter;
		private PropertyBuilder pb;

		private MethodWrapper GetMethod(string name, string sig, bool isstatic)
		{
			if(name != null)
			{
				MethodWrapper mw = this.DeclaringType.GetMethodWrapper(name, sig, false);
				if(mw != null && mw.IsStatic == isstatic)
				{
					mw.IsPropertyAccessor = true;
					return mw;
				}
				Tracer.Error(Tracer.Compiler, "Property '{0}' accessor '{1}' not found in class '{2}'", this.Name, name, this.DeclaringType.Name);
			}
			return null;
		}

		internal DynamicPropertyFieldWrapper(TypeWrapper declaringType, ClassFile.Field fld)
			: base(declaringType, null, fld.Name, fld.Signature, new ExModifiers(fld.Modifiers, fld.IsInternal), null)
		{
			getter = GetMethod(fld.PropertyGetter, "()" + fld.Signature, fld.IsStatic);
			setter = GetMethod(fld.PropertySetter, "(" + fld.Signature + ")V", fld.IsStatic);
		}

#if !STATIC_COMPILER && !FIRST_PASS
		internal override void ResolveField()
		{
			if (getter != null)
			{
				getter.ResolveMethod();
			}
			if (setter != null)
			{
				setter.ResolveMethod();
			}
		}
#endif

		internal PropertyBuilder GetPropertyBuilder()
		{
			AssertLinked();
			return pb;
		}

		internal void DoLink(TypeBuilder tb)
		{
			if(getter != null)
			{
				getter.Link();
			}
			if(setter != null)
			{
				setter.Link();
			}
			pb = tb.DefineProperty(this.Name, PropertyAttributes.None, this.FieldTypeWrapper.TypeAsSignatureType, Type.EmptyTypes);
			if(getter != null)
			{
				pb.SetGetMethod((MethodBuilder)getter.GetMethod());
			}
			if(setter != null)
			{
				pb.SetSetMethod((MethodBuilder)setter.GetMethod());
			}
#if STATIC_COMPILER
			AttributeHelper.SetModifiers(pb, this.Modifiers, this.IsInternal);
#endif
		}

#if EMITTERS
		protected override void EmitGetImpl(CodeEmitter ilgen)
		{
			if(getter == null)
			{
				EmitThrowNoSuchMethodErrorForGetter(ilgen, this.FieldTypeWrapper, this);
			}
			else if(getter.IsStatic)
			{
				getter.EmitCall(ilgen);
			}
			else
			{
				getter.EmitCallvirt(ilgen);
			}
		}

		internal static void EmitThrowNoSuchMethodErrorForGetter(CodeEmitter ilgen, TypeWrapper type, MemberWrapper member)
		{
#if STATIC_COMPILER
			StaticCompiler.IssueMessage(Message.EmittedNoSuchMethodError, "<unknown>", member.DeclaringType.Name + "." + member.Name + member.Signature);
#endif
			// HACK the branch around the throw is to keep the verifier happy
			CodeEmitterLabel label = ilgen.DefineLabel();
			ilgen.Emit(OpCodes.Ldc_I4_0);
			ilgen.EmitBrtrue(label);
			ilgen.EmitThrow("java.lang.NoSuchMethodError");
			ilgen.MarkLabel(label);
			if (!member.IsStatic)
			{
				ilgen.Emit(OpCodes.Pop);
			}
			ilgen.Emit(OpCodes.Ldloc, ilgen.DeclareLocal(type.TypeAsLocalOrStackType));
		}

		protected override void EmitSetImpl(CodeEmitter ilgen)
		{
			if(setter == null)
			{
				if(this.IsFinal)
				{
					ilgen.Emit(OpCodes.Pop);
					if(!this.IsStatic)
					{
						ilgen.Emit(OpCodes.Pop);
					}
				}
				else
				{
					EmitThrowNoSuchMethodErrorForSetter(ilgen, this);
				}
			}
			else if(setter.IsStatic)
			{
				setter.EmitCall(ilgen);
			}
			else
			{
				setter.EmitCallvirt(ilgen);
			}
		}

		internal static void EmitThrowNoSuchMethodErrorForSetter(CodeEmitter ilgen, MemberWrapper member)
		{
#if STATIC_COMPILER
			StaticCompiler.IssueMessage(Message.EmittedNoSuchMethodError, "<unknown>", member.DeclaringType.Name + "." + member.Name + member.Signature);
#endif
			// HACK the branch around the throw is to keep the verifier happy
			CodeEmitterLabel label = ilgen.DefineLabel();
			ilgen.Emit(OpCodes.Ldc_I4_0);
			ilgen.EmitBrtrue(label);
			ilgen.EmitThrow("java.lang.NoSuchMethodError");
			ilgen.MarkLabel(label);
			ilgen.Emit(OpCodes.Pop);
			if (!member.IsStatic)
			{
				ilgen.Emit(OpCodes.Pop);
			}
		}
#endif // EMITTERS

#if !STATIC_COMPILER && !FIRST_PASS
		internal override object GetValue(object obj)
		{
			if (getter == null)
			{
				throw new java.lang.NoSuchMethodError();
			}
			return getter.Invoke(obj, new object[0]);
		}

		internal override void SetValue(object obj, object value)
		{
			if (setter == null)
			{
				throw new java.lang.NoSuchMethodError();
			}
			setter.Invoke(obj, new object[] { value });
		}
#endif
	}
#endif // !STUB_GENERATOR

	// this class represents a .NET property defined in Java with the ikvm.lang.Property annotation
	sealed class CompiledPropertyFieldWrapper : FieldWrapper
	{
		private readonly PropertyInfo property;

		internal CompiledPropertyFieldWrapper(TypeWrapper declaringType, PropertyInfo property, ExModifiers modifiers)
			: base(declaringType, ClassLoaderWrapper.GetWrapperFromType(property.PropertyType), property.Name, ClassLoaderWrapper.GetWrapperFromType(property.PropertyType).SigName, modifiers, null)
		{
			this.property = property;
		}

#if EMITTERS
		protected override void EmitGetImpl(CodeEmitter ilgen)
		{
			MethodInfo getter = property.GetGetMethod(true);
			if(getter == null)
			{
				DynamicPropertyFieldWrapper.EmitThrowNoSuchMethodErrorForGetter(ilgen, this.FieldTypeWrapper, this);
			}
			else if(getter.IsStatic)
			{
				ilgen.Emit(OpCodes.Call, getter);
			}
			else
			{
				ilgen.Emit(OpCodes.Callvirt, getter);
			}
		}

		protected override void EmitSetImpl(CodeEmitter ilgen)
		{
			MethodInfo setter = property.GetSetMethod(true);
			if (setter == null)
			{
				if(this.IsFinal)
				{
					ilgen.Emit(OpCodes.Pop);
					if(!this.IsStatic)
					{
						ilgen.Emit(OpCodes.Pop);
					}
				}
				else
				{
					DynamicPropertyFieldWrapper.EmitThrowNoSuchMethodErrorForSetter(ilgen, this);
				}
			}
			else if(setter.IsStatic)
			{
				ilgen.Emit(OpCodes.Call, setter);
			}
			else
			{
				ilgen.Emit(OpCodes.Callvirt, setter);
			}
		}
#endif // EMITTERS

#if !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
		internal override object GetValue(object obj)
		{
			MethodInfo getter = property.GetGetMethod(true);
			if (getter == null)
			{
				throw new java.lang.NoSuchMethodError();
			}
			return getter.Invoke(obj, new object[0]);
		}

		internal override void SetValue(object obj, object value)
		{
			MethodInfo setter = property.GetSetMethod(true);
			if (setter == null)
			{
				throw new java.lang.NoSuchMethodError();
			}
			setter.Invoke(obj, new object[] { value });
		}
#endif

		internal PropertyInfo GetProperty()
		{
			return property;
		}
	}

	sealed class ConstantFieldWrapper : FieldWrapper
	{
		// NOTE this field wrapper can resprent a .NET enum, but in that case "constant" contains the raw constant value (i.e. the boxed underlying primitive value, not a boxed enum)
		private object constant;

		internal ConstantFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, object constant, MemberFlags flags)
			: base(declaringType, fieldType, name, sig, modifiers, field, flags)
		{
			Debug.Assert(IsStatic);
            Debug.Assert(constant == null || constant.GetType().IsPrimitive || constant is string);
			this.constant = constant;
		}

#if EMITTERS
		protected override void EmitGetImpl(CodeEmitter ilgen)
		{
			// Reading a field should trigger the cctor, but since we're inlining the value
			// we have to trigger it explicitly
			DeclaringType.EmitRunClassConstructor(ilgen);

			// NOTE even though you're not supposed to access a constant static final (the compiler is supposed
			// to inline them), we have to support it (because it does happen, e.g. if the field becomes final
			// after the referencing class was compiled, or when we're accessing an unsigned primitive .NET field)
			object v = GetConstantValue();
			if(v == null)
			{
				ilgen.Emit(OpCodes.Ldnull);
			}
			else if(constant is int || 
				constant is short ||
				constant is ushort ||
				constant is byte ||
				constant is sbyte ||
				constant is char ||
				constant is bool)
			{
				ilgen.EmitLdc_I4(((IConvertible)constant).ToInt32(null));
			}
			else if(constant is string)
			{
				ilgen.Emit(OpCodes.Ldstr, (string)constant);
			}
			else if(constant is float)
			{
				ilgen.EmitLdc_R4((float)constant);
			}
			else if(constant is double)
			{
				ilgen.EmitLdc_R8((double)constant);
			}
			else if(constant is long)
			{
				ilgen.EmitLdc_I8((long)constant);
			}
			else if(constant is uint)
			{
				ilgen.EmitLdc_I4(unchecked((int)((IConvertible)constant).ToUInt32(null)));
			}
			else if(constant is ulong)
			{
				ilgen.EmitLdc_I8(unchecked((long)(ulong)constant));
			}
			else
			{
				throw new InvalidOperationException(constant.GetType().FullName);
			}
		}

		protected override void EmitSetImpl(CodeEmitter ilgen)
		{
			// when constant static final fields are updated, the JIT normally doesn't see that (because the
			// constant value is inlined), so we emulate that behavior by emitting a Pop
			ilgen.Emit(OpCodes.Pop);
		}
#endif // EMITTERS

		internal object GetConstantValue()
		{
			if(constant == null)
			{
				FieldInfo field = GetField();
				constant = field.GetRawConstantValue();
			}
			return constant;
		}

#if !STUB_GENERATOR && !STATIC_COMPILER && !FIRST_PASS
		internal override object GetValue(object obj)
		{
			FieldInfo field = GetField();
			return FieldTypeWrapper.IsPrimitive || field == null
				? GetConstantValue()
				: field.GetValue(null);
		}

		internal override void SetValue(object obj, object value)
		{
		}
#endif
	}

	sealed class CompiledAccessStubFieldWrapper : FieldWrapper
	{
		private readonly MethodInfo getter;
		private readonly MethodInfo setter;

		private static Modifiers GetModifiers(PropertyInfo property)
		{
			// NOTE we only support the subset of modifiers that is expected for "access stub" properties
			MethodInfo getter = property.GetGetMethod(true);
			Modifiers modifiers = getter.IsPublic ? Modifiers.Public : Modifiers.Protected;
			if(!property.CanWrite)
			{
				modifiers |= Modifiers.Final;
			}
			if(getter.IsStatic)
			{
				modifiers |= Modifiers.Static;
			}
			return modifiers;
		}

		// constructor for type 1 access stubs
		internal CompiledAccessStubFieldWrapper(TypeWrapper wrapper, PropertyInfo property, TypeWrapper propertyType)
			: this(wrapper, property, null, propertyType, GetModifiers(property), MemberFlags.HideFromReflection | MemberFlags.AccessStub)
		{
		}

		// constructor for type 2 access stubs
		internal CompiledAccessStubFieldWrapper(TypeWrapper wrapper, PropertyInfo property, FieldInfo field, TypeWrapper propertyType)
			: this(wrapper, property, field, propertyType, AttributeHelper.GetModifiersAttribute(property).Modifiers, MemberFlags.AccessStub)
		{
		}

		private CompiledAccessStubFieldWrapper(TypeWrapper wrapper, PropertyInfo property, FieldInfo field, TypeWrapper propertyType, Modifiers modifiers, MemberFlags flags)
			: base(wrapper, propertyType, property.Name, propertyType.SigName, modifiers, field, flags)
		{
			this.getter = property.GetGetMethod(true);
			this.setter = property.GetSetMethod(true);
		}

#if EMITTERS
		protected override void EmitGetImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, getter);
		}

		protected override void EmitSetImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, setter);
		}
#endif // EMITTERS

#if !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
		internal override object GetValue(object obj)
		{
			// we can only be invoked on type 2 access stubs (because type 1 access stubs are HideFromReflection), so we know we have a field
			return GetField().GetValue(obj);
		}

		internal override void SetValue(object obj, object value)
		{
			// we can only be invoked on type 2 access stubs (because type 1 access stubs are HideFromReflection), so we know we have a field
			GetField().SetValue(obj, value);
		}
#endif // !STATIC_COMPILER && !STUB_GENERATOR && !FIRST_PASS
	}
}
@


1.209
log
@Added FieldWrapper.IsSerialVersionUID property to properly (and consistently) detect serialVersionUID fields.
@
text
@d56 1
d300 5
a886 16
	// placeholder for <clinit> method that exist in ClassFile but not in TypeWrapper
	// (because it is optimized away)
	sealed class DummyMethodWrapper : MethodWrapper
	{
		internal DummyMethodWrapper(TypeWrapper tw)
			: base(tw, StringConstants.CLINIT, StringConstants.SIG_VOID, null, PrimitiveTypeWrapper.VOID, TypeWrapper.EmptyArray, Modifiers.Static, MemberFlags.None)
		{
		}

		protected override void DoLinkMethod()
		{
			// we're pre-linked (because we pass the signature types to the base constructor)
			throw new InvalidOperationException();
		}
	}

@


1.208
log
@Emit warning if property getter/setter is missing.
@
text
@d1534 15
@


1.207
log
@Added MethodWrapper.IsClassInitializer and use it and IsConstructor instead of name comparisons.
@
text
@d1807 1
a1807 1
				EmitThrowNoSuchMethodErrorForGetter(ilgen, this.FieldTypeWrapper, this.IsStatic);
d1819 1
a1819 1
		internal static void EmitThrowNoSuchMethodErrorForGetter(CodeEmitter ilgen, TypeWrapper type, bool isStatic)
d1821 3
d1830 1
a1830 1
			if (!isStatic)
d1851 1
a1851 1
					EmitThrowNoSuchMethodErrorForSetter(ilgen, this.IsStatic);
d1864 1
a1864 1
		internal static void EmitThrowNoSuchMethodErrorForSetter(CodeEmitter ilgen, bool isStatic)
d1866 3
d1876 1
a1876 1
			if (!isStatic)
d1922 1
a1922 1
				DynamicPropertyFieldWrapper.EmitThrowNoSuchMethodErrorForGetter(ilgen, this.FieldTypeWrapper, this.IsStatic);
d1949 1
a1949 1
					DynamicPropertyFieldWrapper.EmitThrowNoSuchMethodErrorForSetter(ilgen, this.IsStatic);
@


1.206
log
@Added MethodWrapper.IsFinalizeOrClone property to centralize the logic to detect these two special cased methods.
@
text
@d856 5
@


1.205
log
@Avoid infinite recursion if (broken) class loader triggers a load of a class currently being finished.
@
text
@d864 10
@


1.204
log
@Bug fix. Conflicting default interface methods should throw IncompatibleClassChangeError instead of AbstractMethodError.
@
text
@d592 5
d605 2
a606 2
			TypeWrapper ret = loader.RetTypeWrapperFromSigNoThrow(Signature);
			TypeWrapper[] parameters = loader.ArgTypeWrapperListFromSigNoThrow(Signature);
d1470 5
d1482 1
a1482 1
			TypeWrapper fld = this.DeclaringType.GetClassLoader().FieldTypeWrapperFromSigNoThrow(Signature);
@


1.203
log
@Bug fix. Default interface methods should not conflict with their own base interfaces.
@
text
@d1087 5
@


1.202
log
@Replaced MethodWrapper.From[Method|Constructor|MethodOrConstructor] methods with MethodWrapper.FromExecutable().
@
text
@d1057 5
@


1.201
log
@Use java.lang.reflect.Executable instead of object as common base class of Method and Constructor.
@
text
@d566 1
a566 1
		internal static MethodWrapper FromMethod(java.lang.reflect.Method method)
d571 1
a571 1
			return TypeWrapper.FromClass(method.getDeclaringClass()).GetMethods()[method._slot()];
a573 17

		internal static MethodWrapper FromConstructor(java.lang.reflect.Constructor constructor)
		{
#if FIRST_PASS
			return null;
#else
			return TypeWrapper.FromClass(constructor.getDeclaringClass()).GetMethods()[constructor._slot()];
#endif
		}
		
		internal static MethodWrapper FromMethodOrConstructor(java.lang.reflect.Executable methodOrConstructor)
		{
			java.lang.reflect.Method method = methodOrConstructor as java.lang.reflect.Method;
			return method != null
				? FromMethod(method)
				: FromConstructor((java.lang.reflect.Constructor)methodOrConstructor);
		}
@


1.200
log
@GhostMethodWrapper can also be a default method.
@
text
@d359 1
a359 1
		private volatile object reflectionMethod;
d454 1
a454 1
		internal object ToMethodOrConstructor(bool copy)
d459 1
a459 1
			object method = reflectionMethod;
d584 1
a584 1
		internal static MethodWrapper FromMethodOrConstructor(object methodOrConstructor)
@


1.199
log
@Generate both versions of a ghost interface method during method linking.
@
text
@d1125 1
d1136 5
d1155 10
d1236 1
a1236 1
		internal MethodInfo GetImpl()
d1238 9
a1246 1
			return impl;
d1249 1
a1249 1
		internal void SetImpl(MethodInfo impl)
d1251 9
a1259 1
			this.impl = impl;
@


1.198
log
@- Added IsVirtual property to ClassFile.Method and MethodWrapper to make the code a bit easier to read.
- Fixed Java 8 interface method handling for annotations and ghost interfaces.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2013 Jeroen Frijters
a1133 12
		private void ResolveGhostMethod()
		{
			if (ghostMethod == null)
			{
				ghostMethod = DeclaringType.TypeAsSignatureType.GetMethod(this.Name, this.GetParametersForDefineMethod());
				if (ghostMethod == null)
				{
					throw new InvalidOperationException("Unable to resolve ghost method");
				}
			}
		}

a1136 1
			ResolveGhostMethod();
a1144 1
			ResolveGhostMethod();
d1148 12
@


1.197
log
@Default interface methods should use callvirt to invoke the interface method.
@
text
@d62 1
a62 1
		private readonly Modifiers modifiers;
d867 9
@


1.196
log
@Fixed Java 8 default interface method handling.
@
text
@d1231 1
a1231 1
			ilgen.Emit(OpCodes.Call, GetMethod());
@


1.195
log
@Support private instance methods in (Java 8) interfaces.
@
text
@d1048 5
d1203 33
@


1.194
log
@Integrated OpenJDK 7u40 JSR-292 implementation (aka LambdaForms).
@
text
@d1198 20
@


1.193
log
@Fixed race condition in MethodWrapper.ResolveMethod().
@
text
@d781 1
a781 1
			return MethodHandleUtil.CreateDelegateType(paramTypes, ReturnType);
@


1.192
log
@Introduced TypeWrapper.IsDynamic property.
@
text
@d788 2
a789 1
			if(method is MethodBuilder)
d791 1
a791 1
				method = method.Module.ResolveMethod(((MethodBuilder)method).GetToken().Token);
d1435 1
a1435 1
				field = field.Module.ResolveField(fb.GetToken().Token);
@


1.191
log
@Introduced EMITTERS conditional compilation constant.
@
text
@d191 1
a191 1
			if (DeclaringType is DynamicTypeWrapper)
d1221 1
a1221 1
				&& DeclaringType is DynamicTypeWrapper
@


1.190
log
@Enable dynamic non-virtual invoke delegate creation if NO_REF_EMIT is defined. We should have a different conditional compilation symbol to disable dynamic loading/type generation.
@
text
@d367 1
a367 1
#if !STUB_GENERATOR
d392 1
a392 1
#endif // STUB_GENERATOR
d891 1
a891 1
#if !STUB_GENERATOR
d937 1
a937 1
#endif // STUB_GENERATOR
d959 1
a959 1
#if !STUB_GENERATOR
d969 1
a969 1
#endif // !STUB_GENERATOR
d979 1
a979 1
#if !STUB_GENERATOR
d994 1
a994 1
#endif // !STUB_GENERATOR
d1094 1
a1094 1
#if !STUB_GENERATOR
d1104 1
a1104 1
#endif // !STUB_GENERATOR
d1131 1
a1131 1
#if !STUB_GENERATOR
d1161 1
a1161 1
#if !STUB_GENERATOR
d1171 1
a1171 1
#endif // !STUB_GENERATOR
d1184 1
a1184 1
#if !STUB_GENERATOR
d1194 1
a1194 1
#endif // !STUB_GENERATOR
d1346 1
a1346 1
#if !STUB_GENERATOR
d1362 1
a1362 1
#endif // !STUB_GENERATOR
d1371 1
a1371 1
		
d1466 1
a1466 1
#if !STUB_GENERATOR
d1500 1
d1502 1
a1502 1
#if !STATIC_COMPILER && !FIRST_PASS
d1512 1
a1512 2
#endif // !STATIC_COMPILER && !FIRST_PASS
#endif // !STUB_GENERATOR
d1524 1
a1524 1
#if !STUB_GENERATOR
d1579 1
d1581 1
a1581 1
#if !STATIC_COMPILER && !FIRST_PASS
d1609 1
a1609 2
#endif // !STATIC_COMPILER && !FIRST_PASS
#endif // !STUB_GENERATOR
d1686 1
d1759 1
d1794 1
a1794 1
#if !STUB_GENERATOR
d1839 1
d1841 1
a1841 1
#if !STATIC_COMPILER && !FIRST_PASS
a1862 2
#endif // !STUB_GENERATOR

d1882 1
a1882 1
#if !STUB_GENERATOR
d1943 1
a1943 1
#endif // !STUB_GENERATOR
d2010 1
a2010 1
#if !STUB_GENERATOR
d2020 1
d2022 1
a2022 1
#if !STATIC_COMPILER && !FIRST_PASS
d2034 1
a2034 2
#endif // !STATIC_COMPILER && !FIRST_PASS
#endif // !STUB_GENERATOR
@


1.189
log
@Moved JNI method invocation completely into JNI assembly and base it on MethodWrapper.Invoke() instead of Java reflection.
@
text
@a767 3
#if NO_REF_EMIT
					throw new InvalidOperationException();
#else
a768 1
#endif
@


1.188
log
@Moved JNI invocation of InvokeNonvirtualRemapped into JNI assembly.
@
text
@a758 89
		[HideFromJava]
		internal object InvokeJNI(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
		{
#if FIRST_PASS
			return null;
#else
			if (IsConstructor)
			{
				if (obj == null)
				{
					java.lang.reflect.Constructor cons = (java.lang.reflect.Constructor)ToMethodOrConstructor(false);
					sun.reflect.ConstructorAccessor acc = cons.getConstructorAccessor();
					if (acc == null)
					{
						acc = Java_sun_reflect_ReflectionFactory.newConstructorAccessor0(null, cons);
						cons.setConstructorAccessor(acc);
					}
					return acc.newInstance(args);
				}
				else if (!ReflectUtil.IsConstructor(method))
				{
					Debug.Assert(method.IsStatic);
					// we're dealing with a constructor on a remapped type, if obj is supplied, it means
					// that we should call the constructor on an already existing instance, but that isn't
					// possible with remapped types
					// the type of this exception is a bit random (note that this can only happen through JNI reflection)
					throw new java.lang.IncompatibleClassChangeError(string.Format("Remapped type {0} doesn't support constructor invocation on an existing instance", DeclaringType.Name));
				}
				else if (!method.DeclaringType.IsInstanceOfType(obj))
				{
					// we're trying to initialize an existing instance of a remapped type
					throw new NotSupportedException("Unable to partially construct object of type " + obj.GetType().FullName + " to type " + method.DeclaringType.FullName);
				}
				else
				{
					try
					{
						ResolveMethod();
						InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, obj, UnboxArgs(args), callerID);
						object o = method.Invoke(proc.GetObj(), proc.GetArgs());
						TypeWrapper retType = this.ReturnType;
						if (!retType.IsUnloadable && retType.IsGhost)
						{
							o = retType.GhostRefField.GetValue(o);
						}
						return o;
					}
					catch (ArgumentException x1)
					{
						throw new java.lang.IllegalArgumentException(x1.Message);
					}
					catch (TargetInvocationException x)
					{
						throw new java.lang.reflect.InvocationTargetException(ikvm.runtime.Util.mapException(x.InnerException));
					}
				}
			}
			else
			{
				java.lang.reflect.Method method = (java.lang.reflect.Method)ToMethodOrConstructor(false);
				sun.reflect.MethodAccessor acc = method.getMethodAccessor();
				if (acc == null)
				{
					acc = Java_sun_reflect_ReflectionFactory.newMethodAccessor(null, method);
					method.setMethodAccessor(acc);
				}
				object val = acc.invoke(obj, args, callerID);
				if (this.ReturnType.IsPrimitive && this.ReturnType != PrimitiveTypeWrapper.VOID)
				{
					val = JVM.Unbox(val);
				}
				return val;
			}
#endif
		}

		private object[] UnboxArgs(object[] args)
		{
			TypeWrapper[] paramTypes = GetParameters();
			for (int i = 0; i < paramTypes.Length; i++)
			{
				if (paramTypes[i].IsPrimitive)
				{
					args[i] = JVM.Unbox(args[i]);
				}
			}
			return args;
		}

a804 1
#if !FIRST_PASS
d808 3
d819 1
d831 3
d842 1
a843 61

		private struct InvokeArgsProcessor
		{
			private object obj;
			private object[] args;

			internal InvokeArgsProcessor(MethodWrapper mw, MethodBase method, object original_obj, object[] original_args, ikvm.@@internal.CallerID callerID)
			{
				TypeWrapper[] argTypes = mw.GetParameters();

				if(!mw.IsStatic && method.IsStatic && mw.Name != "<init>")
				{
					// we've been redirected to a static method, so we have to copy the 'obj' into the args
					this.obj = null;
					this.args = ArrayUtil.Concat(original_obj, original_args);
					for(int i = 0; i < argTypes.Length; i++)
					{
						if(!argTypes[i].IsUnloadable && argTypes[i].IsGhost)
						{
							object v = Activator.CreateInstance(argTypes[i].TypeAsSignatureType);
							argTypes[i].GhostRefField.SetValue(v, args[i + 1]);
							args[i + 1] = v;
						}
					}
				}
				else
				{
					this.obj = original_obj;
					this.args = original_args;
					for(int i = 0; i < argTypes.Length; i++)
					{
						if(!argTypes[i].IsUnloadable && argTypes[i].IsGhost)
						{
							if(this.args == original_args)
							{
								this.args = (object[])args.Clone();
							}
							object v = Activator.CreateInstance(argTypes[i].TypeAsSignatureType);
							argTypes[i].GhostRefField.SetValue(v, args[i]);
							this.args[i] = v;
						}
					}
				}

				if(mw.HasCallerID)
				{
					args = ArrayUtil.Concat(args, callerID);
				}
			}

			internal object GetObj()
			{
				return obj;
			}

			internal object[] GetArgs()
			{
				return args;
			}
		}
#endif // !FIRST_PASS
@


1.187
log
@Added back support for JNI non-virtual method invocation for methods with more than 8 parameters.
@
text
@a766 1
				java.lang.reflect.Constructor cons = (java.lang.reflect.Constructor)ToMethodOrConstructor(false);
d769 1
d773 1
a773 1
						acc = (sun.reflect.ConstructorAccessor)Java_sun_reflect_ReflectionFactory.newConstructorAccessor0(null, cons);
a815 18
			else if (nonVirtual
				&& !this.IsStatic
				&& !this.IsPrivate
				&& !this.IsAbstract
				&& !this.IsFinal
				&& !this.DeclaringType.IsFinal)
			{
				if (this.DeclaringType.IsRemapped && !this.DeclaringType.TypeAsBaseType.IsInstanceOfType(obj))
				{
					ResolveMethod();
					return InvokeNonvirtualRemapped(obj, UnboxArgs(args));
				}
				else
				{
					// this can't happen, because the JNI side already handles this case
					throw new InvalidOperationException();
				}
			}
d822 1
a822 1
					acc = (sun.reflect.MethodAccessor)Java_sun_reflect_ReflectionFactory.newMethodAccessor(null, method);
d888 6
a926 6
		[HideFromJava]
		protected virtual object InvokeNonvirtualRemapped(object obj, object[] args)
		{
			throw new InvalidOperationException();
		}

@


1.186
log
@Moved JNI non-virtual invoke delegate type creation into runtime where it can reuse MethodHandle code.
@
text
@d745 13
d871 20
a890 1
				throw new NotImplementedException();
@


1.185
log
@Reimplemented JNI non-virtual method invocation based on delegates instead of DynamicMethod.
@
text
@d853 10
@


1.184
log
@Use CallerID in signature.
@
text
@a358 1
		private static Dictionary<MethodWrapper, sun.reflect.MethodAccessor> invokenonvirtualCache;
d817 2
a818 23
#if NO_REF_EMIT
					throw new NotSupportedException();
#else
					if (invokenonvirtualCache == null)
					{
						Interlocked.CompareExchange(ref invokenonvirtualCache, new Dictionary<MethodWrapper, sun.reflect.MethodAccessor>(), null);
					}
					sun.reflect.MethodAccessor acc;
					lock (invokenonvirtualCache)
					{
						if (!invokenonvirtualCache.TryGetValue(this, out acc))
						{
							acc = new Java_sun_reflect_ReflectionFactory.FastMethodAccessorImpl(this, true);
							invokenonvirtualCache.Add(this, acc);
						}
					}
					object val = acc.invoke(obj, args, callerID);
					if (this.ReturnType.IsPrimitive && this.ReturnType != PrimitiveTypeWrapper.VOID)
					{
						val = JVM.Unbox(val);
					}
					return val;
#endif
a851 1
#endif // !STATIC_COMPILER && !STUB_GENERATOR
a852 1
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
d855 1
d861 1
d864 1
d962 2
a963 1
#endif // !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
@


1.183
log
@Removed unnecessary Method <-> MethodWrapper conversions.
@
text
@d748 1
a748 1
		internal object InvokeJNI(object obj, object[] args, bool nonVirtual, object callerID)
d785 1
a785 1
						InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, obj, UnboxArgs(args), (ikvm.@@internal.CallerID)callerID);
d834 1
a834 1
					object val = acc.invoke(obj, args, (ikvm.@@internal.CallerID)callerID);
d852 1
a852 1
				object val = acc.invoke(obj, args, (ikvm.@@internal.CallerID)callerID);
@


1.182
log
@Added NO_REF_EMIT conditional compilation support for reflection.
@
text
@d830 1
a830 1
							acc = new Java_sun_reflect_ReflectionFactory.FastMethodAccessorImpl((java.lang.reflect.Method)ToMethodOrConstructor(false), true);
@


1.181
log
@Unified the MethodWrapper.Invoke() semantics.
@
text
@d818 3
d840 1
d906 13
d1281 9
d1724 4
d1730 6
d1737 1
d1742 6
d1749 1
@


1.180
log
@Introduced ArrayUtil.Concat() methods.
@
text
@d882 2
a883 1
		internal virtual object Invoke(object obj, object[] args)
d885 1
a885 1
			if (method == null)
d887 1
a887 1
				throw new NotImplementedException(GetType().FullName + " has no method and doesn't override Invoke");
d889 10
a898 1
			return method.Invoke(obj, args);
@


1.179
log
@Removed ICustomInvoke.
@
text
@a908 3
					object[] nargs = new object[original_args.Length + 1];
					nargs[0] = original_obj;
					original_args.CopyTo(nargs, 1);
d910 1
a910 1
					this.args = nargs;
d942 1
a942 4
					object[] nargs = new object[args.Length + 1];
					Array.Copy(args, nargs, args.Length);
					nargs[args.Length] = callerID;
					args = nargs;
@


1.178
log
@Removed unused code.
@
text
@a355 7
	interface ICustomInvoke
	{
#if !STATIC_COMPILER && !FIRST_PASS && !STUB_GENERATOR
		object Invoke(object obj, object[] args);
#endif
	}

@


1.177
log
@More static typing.
@
text
@a1383 23
		// NOTE used (thru IKVM.Runtime.Util.GetFieldConstantValue) by ikvmstub to find out if the
		// field is a constant (and if it is, to get its value)
		internal object GetConstant()
		{
			AssertLinked();
			// only primitives and string can be literals in Java (because the other "primitives" (like uint),
			// are treated as NonPrimitiveValueTypes)
			if(field != null && field.IsLiteral && (fieldType.IsPrimitive || fieldType == CoreClasses.java.lang.String.Wrapper))
			{
				object val = field.GetRawConstantValue();
				if(field.FieldType.IsEnum)
				{
					val = EnumHelper.GetPrimitiveValue(EnumHelper.GetUnderlyingType(field.FieldType), val);
				}
				if(fieldType.IsPrimitive)
				{
					return JVM.Box(val);
				}
				return val;
			}
			return null;
		}

@


1.176
log
@Reduced the number of cases where slow-path field reflection can't be used.
@
text
@d574 10
a583 1
		internal static MethodWrapper FromMethodOrConstructor(object methodOrConstructor)
a587 6
			java.lang.reflect.Method method = methodOrConstructor as java.lang.reflect.Method;
			if (method != null)
			{
				return TypeWrapper.FromClass(method.getDeclaringClass()).GetMethods()[method._slot()];
			}
			java.lang.reflect.Constructor constructor = (java.lang.reflect.Constructor)methodOrConstructor;
d591 8
d1407 1
a1407 1
		internal static FieldWrapper FromField(object field)
d1412 1
a1412 2
			java.lang.reflect.Field f = (java.lang.reflect.Field)field;
			int slot = f._slot();
d1416 1
a1416 1
				foreach (FieldWrapper fw in TypeWrapper.FromClass(f.getDeclaringClass()).GetFields())
d1418 1
a1418 1
					if (fw.Name == f.getName())
d1424 1
a1424 1
			return TypeWrapper.FromClass(f.getDeclaringClass()).GetFields()[slot];
@


1.175
log
@Moved the remaining code from openjdk.cs to separate files.
@
text
@d878 9
d1583 5
d1633 12
d1712 12
d1873 20
d1952 23
d2068 14
d2134 14
@


1.174
log
@More default interface method fixes.
@
text
@d757 1
a757 1
						acc = (sun.reflect.ConstructorAccessor)IKVM.NativeCode.sun.reflect.ReflectionFactory.newConstructorAccessor0(null, cons);
d823 1
a823 1
							acc = new IKVM.NativeCode.sun.reflect.ReflectionFactory.FastMethodAccessorImpl((java.lang.reflect.Method)ToMethodOrConstructor(false), true);
d841 1
a841 1
					acc = (sun.reflect.MethodAccessor)IKVM.NativeCode.sun.reflect.ReflectionFactory.newMethodAccessor(null, method);
d1569 1
a1569 1
				Interlocked.CompareExchange(ref jniAccessor, IKVM.NativeCode.sun.reflect.ReflectionFactory.NewFieldAccessorJNI(this), null);
@


1.173
log
@Fixed some corner cases for default methods:
- If the same method is inherited multiple times, it's OK.
- If an interface extends another interface, it can override a default method.
@
text
@d1106 1
a1106 1
	sealed class MirandaMethodWrapper : SmartMethodWrapper
d1108 1
a1108 2
		private MethodWrapper ifmethod;
		private string error;
d1110 2
a1111 2
		internal MirandaMethodWrapper(TypeWrapper declaringType, MethodWrapper ifmethod)
			: base(declaringType, ifmethod.Name, ifmethod.Signature, null, null, null, Modifiers.Public | Modifiers.Abstract, MemberFlags.HideFromReflection | MemberFlags.MirandaMethod)
d1116 46
a1161 1
		internal void AddBaseMethod(MethodWrapper mw)
d1166 1
d1170 1
a1170 1
				ifmethod = mw;
d1174 1
a1174 5
				if (error == null)
				{
					error = "Conflicting default methods: " + ifmethod.DeclaringType.Name + "." + ifmethod.Name;
				}
				error += " " + mw.DeclaringType.Name + "." + mw.Name;
d1178 5
a1182 2
				ifmethod = mw;
				error = DeclaringType.Name + "." + Name + Signature;
d1186 7
d1198 1
a1198 1
		internal string Error
d1200 1
a1200 1
			get { return error; }
@


1.172
log
@Implemented Java 8 default interface methods.
@
text
@d1119 9
a1127 1
			if (!ifmethod.IsAbstract && !mw.IsAbstract)
@


1.171
log
@Removed unused method.
@
text
@d1106 51
@


1.170
log
@There is no need to use dynamic binding if only the receiver type is unloadable.
@
text
@a733 40
		// this returns the Java method's attributes in .NET terms (e.g. used to create stubs for this method)
		internal MethodAttributes GetMethodAttributes()
		{
			MethodAttributes attribs = MethodAttributes.HideBySig;
			if(IsStatic)
			{
				attribs |= MethodAttributes.Static;
			}
			if(IsPublic)
			{
				attribs |= MethodAttributes.Public;
			}
			else if(IsPrivate)
			{
				attribs |= MethodAttributes.Private;
			}
			else if(IsProtected)
			{
				attribs |= MethodAttributes.FamORAssem;
			}
			else
			{
				attribs |= MethodAttributes.Family;
			}
			// constructors aren't virtual
			if(!IsStatic && !IsPrivate && Name != "<init>")
			{
				attribs |= MethodAttributes.Virtual;
			}
			if(IsFinal)
			{
				attribs |= MethodAttributes.Final;
			}
			if(IsAbstract)
			{
				attribs |= MethodAttributes.Abstract;
			}
			return attribs;
		}

@


1.169
log
@- Removed CallerID from ICustomInvoke.
- Removed ICustomInvoke constructor invocation path, because there aren't any dynamic only constructors.
@
text
@d172 1
a172 1
			if (IsPublic || (IsProtected && caller.IsSubTypeOf(DeclaringType) && (IsStatic || instance.IsSubTypeOf(caller))))
@


1.168
log
@Added MethodWrapper.IsConstructor property.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2012 Jeroen Frijters
d359 1
a359 1
		object Invoke(object obj, object[] args, ikvm.@@internal.CallerID callerID);
@


1.167
log
@- Marked some field readonly.
- Fixed a memory model issue.
@
text
@d479 1
a479 1
				if (this.Name == StringConstants.INIT)
d789 1
a789 1
			if (ReferenceEquals(Name, StringConstants.INIT))
d1010 5
@


1.166
log
@Removed some O(n^2) operations to improve handling of class files with a large number of fields.
@
text
@d61 2
a62 2
		private TypeWrapper declaringType;
		private Modifiers modifiers;
d64 2
a65 2
		private string name;
		private string sig;
d1093 2
a1094 2
		private SimpleOpCode call;
		private SimpleOpCode callvirt;
d1494 1
a1494 1
				jniAccessor = IKVM.NativeCode.sun.reflect.ReflectionFactory.NewFieldAccessorJNI(this);
d1916 2
a1917 2
		private MethodInfo getter;
		private MethodInfo setter;
@


1.165
log
@Bug fix. Field.getModifiers() should only return the relevant modifiers.
@
text
@d1336 5
d1355 1
a1355 1
					Array.IndexOf(this.DeclaringType.GetFields(), this),
d1413 8
@


1.164
log
@Removed remaining ConstructorBuilder usages.
@
text
@d1342 2
d1349 1
a1349 1
					(int)this.Modifiers | (this.IsInternal ? 0x40000000 : 0),
@


1.163
log
@Fixed regression caused by ConstructorBuilder removal. We can no longer test for MethodInfo or ConstructorInfo to distinguish the two.
@
text
@a915 4
			if(method is ConstructorBuilder)
			{
				method = method.Module.ResolveMethod(((ConstructorBuilder)method).GetToken().Token);
			}
@


1.163.2.1
log
@Changes:
- Set version to 7.2.4630.2.
- Bug fix. Class.forName("") should not throw System.ArgumentException.
- Bug fix. Transient field modifier should be retained on literal fields.
- Bug fix. Field.getModifiers() should only return the relevant modifiers.
- IKVM.Reflection: Bug fix. Ignore unknown metadata streams.
- IKVM.Reflection: Bug fix. Set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@a1345 2
				const Modifiers ReflectionFieldModifiersMask = Modifiers.Public | Modifiers.Private | Modifiers.Protected | Modifiers.Static
					| Modifiers.Final | Modifiers.Volatile | Modifiers.Transient | Modifiers.Synthetic | Modifiers.Enum;
d1351 1
a1351 1
					(int)(this.Modifiers & ReflectionFieldModifiersMask) | (this.IsInternal ? 0x40000000 : 0),
@


1.162
log
@Moved GhostMethodWrapper out of MethodWrapper and removed MethodWrapper.Create() as it was used in only one place.
@
text
@d802 1
a802 1
				else if (method is MethodInfo)
@


1.161
log
@Merged SmartCallMethodWrapper and SmartConstructorMethodWrapper into TypicalMethodWrapper.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
a409 56
		internal sealed class GhostMethodWrapper : SmartMethodWrapper
		{
			private MethodInfo ghostMethod;

			internal GhostMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
				: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
			{
				// make sure we weren't handed the ghostMethod in the wrapper value type
				Debug.Assert(method == null || method.DeclaringType.IsInterface);
			}

			private void ResolveGhostMethod()
			{
				if(ghostMethod == null)
				{
					ghostMethod = DeclaringType.TypeAsSignatureType.GetMethod(this.Name, this.GetParametersForDefineMethod());
					if(ghostMethod == null)
					{
						throw new InvalidOperationException("Unable to resolve ghost method");
					}
				}
			}

#if !STUB_GENERATOR
			protected override void CallvirtImpl(CodeEmitter ilgen)
			{
				ResolveGhostMethod();
				ilgen.Emit(OpCodes.Call, ghostMethod);
			}
#endif
		}

		internal static MethodWrapper Create(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
		{
			Debug.Assert(declaringType != null && name!= null && sig != null && method != null);

			if(declaringType.IsGhost)
			{
				// HACK since our caller isn't aware of the ghost issues, we'll handle the method swapping
				if(method.DeclaringType.IsValueType)
				{
					Type[] types = new Type[parameterTypes.Length];
					for(int i = 0; i < types.Length; i++)
					{
						types[i] = parameterTypes[i].TypeAsSignatureType;
					}
					method = declaringType.TypeAsBaseType.GetMethod(method.Name, types);
				}
				return new GhostMethodWrapper(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags);
			}
			else
			{
				return new TypicalMethodWrapper(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags);
			}
		}

d1145 33
@


1.160
log
@Merged CodeEmitter.Emit(OpCode, MethodInfo) and CodeEmitter.Emit(OpCode, ConstructorInfo) into CodeEmitter.Emit(OpCode, MethodBase) and removed unnecessary downcasting.
@
text
@a459 4
			else if(method is ConstructorInfo)
			{
				return new SmartConstructorMethodWrapper(declaringType, name, sig, (ConstructorInfo)method, parameterTypes, modifiers, flags);
			}
d462 1
a462 1
				return new SmartCallMethodWrapper(declaringType, name, sig, (MethodInfo)method, returnType, parameterTypes, modifiers, flags, SimpleOpCode.Call, method.IsStatic ? SimpleOpCode.Call : SimpleOpCode.Callvirt);
d1176 1
a1176 1
	sealed class SmartCallMethodWrapper : SmartMethodWrapper
d1178 1
a1178 4
		private SimpleOpCode call;
		private SimpleOpCode callvirt;

		internal SmartCallMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags, SimpleOpCode call, SimpleOpCode callvirt)
a1180 2
			this.call = call;
			this.callvirt = callvirt;
d1186 1
a1186 1
			ilgen.Emit(SimpleOpCodeToOpCode(call), GetMethod());
d1191 1
a1191 16
			ilgen.Emit(SimpleOpCodeToOpCode(callvirt), GetMethod());
		}
#endif // !STUB_GENERATOR
	}

	sealed class SmartConstructorMethodWrapper : SmartMethodWrapper
	{
		internal SmartConstructorMethodWrapper(TypeWrapper declaringType, string name, string sig, ConstructorInfo method, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, method, PrimitiveTypeWrapper.VOID, parameterTypes, modifiers, flags)
		{
		}

#if !STUB_GENERATOR
		protected override void CallImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, GetMethod());
@


1.159
log
@- Marked MemberWrapper class abstract.
- Marked all classes that don't (and shouldn't) have subclasses sealed.
@
text
@d1170 1
a1170 1
			ilgen.Emit(SimpleOpCodeToOpCode(call), (MethodInfo)GetMethod());
d1175 1
a1175 1
			ilgen.Emit(SimpleOpCodeToOpCode(callvirt), (MethodInfo)GetMethod());
d1195 1
a1195 1
			ilgen.Emit(SimpleOpCodeToOpCode(call), (MethodInfo)GetMethod());
d1200 1
a1200 1
			ilgen.Emit(SimpleOpCodeToOpCode(callvirt), (MethodInfo)GetMethod());
d1215 1
a1215 1
			ilgen.Emit(OpCodes.Call, (ConstructorInfo)GetMethod());
d1220 1
a1220 1
			ilgen.Emit(OpCodes.Newobj, (ConstructorInfo)GetMethod());
@


1.158
log
@Remove SmartMethodWrapper.PreEmit() because it was only used in one place.
@
text
@d58 1
a58 1
	class MemberWrapper
d410 1
a410 1
		internal class GhostMethodWrapper : SmartMethodWrapper
d1092 1
a1092 1
	class SmartMethodWrapper : MethodWrapper
@


1.157
log
@- Made CodeEmitter more "type safe" by adding specific EmitXxx methods instead of following the more general ILGenerator pattern.
- Added some new optimizations to CodeEmitter (disabled unless experimental optimizations are enabled).
- Added some invariant checks to CodeEmitter to help debug optimizations (and document the invariants).
@
text
@a1099 4
		protected virtual void PreEmit(CodeEmitter ilgen)
		{
		}

a1102 1
			PreEmit(ilgen);
a1113 1
			PreEmit(ilgen);
a1133 1
			PreEmit(ilgen);
@


1.156
log
@Improved the handling of final fields that need to be wrapped by a property.
@
text
@d1752 1
a1752 1
			ilgen.Emit(OpCodes.Brtrue_S, label);
d1794 1
a1794 1
			ilgen.Emit(OpCodes.Brtrue_S, label);
d1906 1
a1906 1
				ilgen.Emit(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
d1914 1
a1914 1
				ilgen.Emit(OpCodes.Ldc_R4, (float)constant);
d1918 1
a1918 1
				ilgen.Emit(OpCodes.Ldc_R8, (double)constant);
d1922 1
a1922 1
				ilgen.Emit(OpCodes.Ldc_I8, (long)constant);
d1926 1
a1926 1
				ilgen.Emit(OpCodes.Ldc_I4, unchecked((int)((IConvertible)constant).ToUInt32(null)));
d1930 1
a1930 1
				ilgen.Emit(OpCodes.Ldc_I8, unchecked((long)(ulong)constant));
@


1.155
log
@Added support for type 2 access stubs for constructors.
@
text
@d55 1
d165 1
a165 1
					&& (!HasNonPublicTypeInSignature || InPracticeInternalsVisibleTo(caller));
d276 10
d1298 13
@


1.155.2.1
log
@Bug fix (not a backport, HEAD will get a different fix). When a final field is wrapped in a property, any assemblies that are concurrently compiled with the declaring assembly will access the backing field directly and hence the declaring assembly will need an InternalsVisibleToAttribute to allow them access. This fix makes sure that this attribute is applied when the field is accessed from another (concurrently compiled) assembly.
@
text
@a54 1
		Type2FinalField = 2048,
d164 1
a164 1
					&& (!(HasNonPublicTypeInSignature || IsType2FinalField) || InPracticeInternalsVisibleTo(caller));
a274 10
		protected void SetType2FinalField()
		{
			flags |= MemberFlags.Type2FinalField;
		}
	
		private bool IsType2FinalField
		{
			get { return (flags & MemberFlags.Type2FinalField) != 0; }
		}

a1286 12
#if !STUB_GENERATOR
			if (IsFinal
				&& DeclaringType.IsPublic
				&& (IsPublic || (IsProtected && !DeclaringType.IsFinal))
				&& !DeclaringType.GetClassLoader().StrictFinalFieldSemantics
				&& DeclaringType is DynamicTypeWrapper
				&& !(this is ConstantFieldWrapper)
				&& !(this is DynamicPropertyFieldWrapper))
			{
				SetType2FinalField();
			}
#endif
@


1.154
log
@Intrinsified the unsafe.objectFieldOffset(XXX.class.getDeclaredField("xxx")) pattern to avoid expensive reflection field lookup in static initializers of common OpenJDK classes.
@
text
@d476 1
a476 1
			if ((IsPublic || IsProtected) && (returnTypeWrapper != null && parameterTypeWrappers != null) && !(this is AccessStubMethodWrapper))
d1246 23
@


1.153
log
@Add support for delegates with ByRef parameters.
@
text
@d1329 13
a1341 1
			return TypeWrapper.FromClass(f.getDeclaringClass()).GetFields()[f._slot()];
@


1.152
log
@Corrected comment.
@
text
@d54 1
d283 5
@


1.151
log
@- Removed BaseTypeWrapper.Finish() call from DotNetTypeWrapper.LazyPublishMembers(), because it is the wrong place to call Finish.
- Added explicit Link() calls where necessary.
@
text
@d1106 1
a1106 1
				// TODO we need to check for a null reference
@


1.150
log
@It turns out that it isn't a good idea to mutate the member types (and lose the fact that they are unloadable), so now we only do the conversion when generating the Java reflection wrapper for the member.
@
text
@d513 1
d1335 1
@


1.149
log
@Introduced DefineMethodHelper class as an abstraction over method signatures (the parameter/return types) to make it easier to start using modopt for methods.
@
text
@a357 10
		internal void EnsureLoadable()
		{
			ClassLoaderWrapper loader = DeclaringType.GetClassLoader();
			returnTypeWrapper = returnTypeWrapper.EnsureLoadable(loader);
			for (int i = 0; i < parameterTypeWrappers.Length; i++)
			{
				parameterTypeWrappers[i] = parameterTypeWrappers[i].EnsureLoadable(loader);
			}
		}

d513 1
d518 1
a518 1
					parameterTypes[i] = argTypes[i].ClassObject;
d540 1
a540 1
						this.ReturnType.ClassObject,
a1275 5
		internal void EnsureLoadable()
		{
			fieldType = fieldType.EnsureLoadable(DeclaringType.GetClassLoader());
		}

d1337 1
a1337 1
					this.FieldTypeWrapper.ClassObject,
@


1.148
log
@When a member with unloadable types in its signature is exposed via reflection, the unloadable types should be resolved to actual types.
@
text
@d731 7
@


1.147
log
@Stop mangling property names for access stubs (instead we rely on custom modifiers to make them unique).
@
text
@d358 10
d1278 5
@


1.146
log
@Use modopt to reliably correlate type 2 access stub properties with the underlying field. This fixes a bug where annotations applied to fields with type 2 access stubs would not be visible at runtime (via reflection).
@
text
@d1903 14
a1916 2
		private CompiledAccessStubFieldWrapper(TypeWrapper wrapper, PropertyInfo property, FieldInfo field, TypeWrapper propertyType, string name, string signature, Modifiers modifiers, MemberFlags flags)
			: base(wrapper, propertyType, name, signature, modifiers, field, flags)
a1932 50

		internal static bool TryGet(TypeWrapper wrapper, PropertyInfo property, FieldInfo field, out FieldWrapper accessStub)
		{
			NameSigAttribute nameSig = AttributeHelper.GetNameSig(property);
			bool hideFromReflection = AttributeHelper.IsHideFromReflection(property);

			if (nameSig != null || hideFromReflection)
			{
				TypeWrapper type;
				string name;
				string sig;
				if (nameSig == null)
				{
					type = ClassLoaderWrapper.GetWrapperFromType(property.PropertyType);
					name = property.Name;
					sig = type.SigName;
				}
				else
				{
					type = wrapper.GetClassLoader().FieldTypeWrapperFromSigNoThrow(nameSig.Sig);
					name = nameSig.Name;
					sig = nameSig.Sig;
				}
				Modifiers modifiers;
				MemberFlags flags = MemberFlags.AccessStub;
				if (hideFromReflection)
				{
					// it's a Type 1 access stub (to make inherited fields visible)
					flags |= MemberFlags.HideFromReflection;
					modifiers = GetModifiers(property);
				}
				else
				{
					// it's a Type 2 access stub (to make fields that have a non-public field type visible)
					ModifiersAttribute attr = AttributeHelper.GetModifiersAttribute(property);
					modifiers = attr.Modifiers;
					if (attr.IsInternal)
					{
						flags |= MemberFlags.InternalAccess;
					}
				}
				accessStub = new CompiledAccessStubFieldWrapper(wrapper, property, field, type, name, sig, modifiers, flags);
				return true;
			}
			else
			{
				accessStub = null;
				return false;
			}
		}
@


1.145
log
@Removed legacy remap feature that allowed final fields as properties to be defined (long time ago this was used for the System.in/out/err fields).
@
text
@d1903 2
a1904 2
		private CompiledAccessStubFieldWrapper(TypeWrapper wrapper, PropertyInfo property, TypeWrapper propertyType, string name, string signature, Modifiers modifiers, MemberFlags flags)
			: base(wrapper, propertyType, name, signature, modifiers, null, flags)
d1922 1
a1922 1
		internal static bool TryGet(TypeWrapper wrapper, PropertyInfo property, out FieldWrapper accessStub)
d1962 1
a1962 1
				accessStub = new CompiledAccessStubFieldWrapper(wrapper, property, type, name, sig, modifiers, flags);
@


1.144
log
@Implemented type 2 access stubs for methods (not constructors) and rewrote how type 1 access stubs are handled.
@
text
@a1581 72
	sealed class GetterFieldWrapper : FieldWrapper
	{
		private MethodInfo getter;
		private PropertyInfo prop;

		// NOTE fi may be null!
		internal GetterFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, ExModifiers modifiers, MethodInfo getter, PropertyInfo prop)
			: base(declaringType, fieldType, name, sig, modifiers, fi)
		{
			Debug.Assert(!IsVolatile);

			this.getter = getter;
			this.prop = prop;
		}

		internal void SetGetter(MethodInfo getter)
		{
			this.getter = getter;
		}

		internal MethodInfo GetGetter()
		{
			return getter;
		}

		internal PropertyInfo GetProperty()
		{
			return prop;
		}

#if !STUB_GENERATOR
		protected override void EmitGetImpl(CodeEmitter ilgen)
		{
			if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
			{
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				ilgen.Emit(OpCodes.Call, getter);
			}
			else
			{
				// NOTE we look at the static-ness of the getter method and not our own,
				// because for instance fields we can still have a static getter method
				ilgen.Emit(getter.IsStatic ? OpCodes.Call : OpCodes.Callvirt, getter);
			}
		}

		protected override void EmitSetImpl(CodeEmitter ilgen)
		{
			if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
			{
				CodeEmitterLocal temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsSignatureType);
				ilgen.Emit(OpCodes.Stloc, temp);
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				ilgen.Emit(OpCodes.Ldloc, temp);
			}
			FieldInfo fi = GetField();
			if(fi != null)
			{
				// common case (we're in a DynamicTypeWrapper and the caller is too)
				ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
			}
			else
			{
				// this means that we are an instance on a CompiledTypeWrapper and we're being called
				// from DynamicMethod based reflection, so we can safely emit a call to the private
				// setter, because the DynamicMethod is allowed to access our private members.
				ilgen.Emit(OpCodes.Call, prop.GetSetMethod(true));
			}
		}
#endif // !STUB_GENERATOR
	}

@


1.143
log
@Fixed several type 1 method access stub issues.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2009 Jeroen Frijters
d470 1
a470 1
			if ((IsPublic || IsProtected) && (returnTypeWrapper != null && parameterTypeWrappers != null))
d1208 1
d1211 2
a1212 2
		internal AccessStubMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodInfo stubVirtual, MethodInfo stubNonVirtual, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, stubVirtual, returnType, parameterTypes, modifiers, flags)
d1214 1
d1226 1
a1226 1
			ilgen.Emit(OpCodes.Callvirt, (MethodInfo)GetMethod());
@


1.142
log
@Added a property to decide if we need a type 2 access stub to make sure the check is consistent (and this also fixes a bug where we needlessly create an access stub for field where the field type is unloadable).
@
text
@d1206 23
@


1.141
log
@Clarified that the NonPublicTypeInSignature does not get set for access stubs (because they've replaced the non-public types with their public base class).
@
text
@d163 1
a163 1
					&& ((flags & MemberFlags.NonPublicTypeInSignature) == 0 || InPracticeInternalsVisibleTo(caller));
d269 5
@


1.140
log
@Removed the need for access stubs in dynamic mode with CLASSGC enabled by dynamically adding InternalsVisibleToAttribute to the dynamic assemblies.
@
text
@d53 1
a53 1
		NonPublicTypeInSignature = 512,	// this flag is only available after linking
@


1.139
log
@Hardened runtime against asynchronous Thread.Abort() during critical operations. Fix for bug #3385353.
@
text
@d188 8
@


1.138
log
@Added experimental (and for the time being undocumented) support for having ikvmc pre-generate proxy classes.
@
text
@d646 1
a646 1
				if(parameterTypeWrappers == null)
d648 5
a652 5
					Debug.Assert(returnTypeWrapper == null || returnTypeWrapper == PrimitiveTypeWrapper.VOID);
					returnTypeWrapper = ret;
					parameterTypeWrappers = parameters;
					UpdateNonPublicTypeInSignatureFlag();
					if(method == null)
d654 5
a658 1
						try
d660 12
a671 9
							DoLinkMethod();
						}
						catch
						{
							// HACK if linking fails, we unlink to make sure
							// that the next link attempt will fail again
							returnTypeWrapper = null;
							parameterTypeWrappers = null;
							throw;
d1363 1
a1363 1
				if(fieldType == null)
d1365 5
a1369 3
					fieldType = fld;
					UpdateNonPublicTypeInSignatureFlag();
					try
d1371 13
a1383 8
						field = this.DeclaringType.LinkField(this);
					}
					catch
					{
						// HACK if linking fails, we unlink to make sure
						// that the next link attempt will fail again
						fieldType = null;
						throw;
@


1.137
log
@Volatile stores require a memory barrier. Fix for #3086040.
@
text
@d486 5
@


1.137.2.1
log
@Backported fixes for 0.46.0.3:
- Bug fix. java.lang.Package was not populated from manifest for ikvmc compiled assemblies.
- Bug fix. When writing a direct ByteBuffer to a non-blocking socket and the write fails because there is no kernel buffer available, we should not advance the ByteBuffer position.
- Bug fix. When adding certificates to virtual cacerts file make sure that the aliases are unique.
- Bug fix. If a finally/fault handler contains reachable code before the handler's start index, the handler should branch to the handler start index.
- Bug fix. After emitting a finally/fault handler block, we should emit the block leave stubs (even though you can't leave the block, they also emit the backward branch stubs).
- Bug fix. If a Java class extends a remapped .NET type (cli.System.Object or cli.System.Exception), we should correctly report the base class.
- Bug fix. If we encounter a jsr or ret instruction, we should throw a VerifyError (instead of NotImplementedException).
- Bug fix. If an exception block ends with an astore, we need to propagate the local variable type after the astore to the exception handler.
- Disable AppDomain.ProcessExit hook to run shutdown hooks when running on Mono to workaround https://bugzilla.xamarin.com/show_bug.cgi?id=5650
- Bug fix. Custom attribute properties that don't have a public getter and setter should not be exposed as annotation properties.
- Bug fix. Non-public property getter/setter methods should be ignored when we create properties to hide properties inherited from shadow types. This fixes a build break with .NET 4.5 beta which introduces a protected setter for Exception.HResult.
- Bug fix. The $Method inner class for delegates should also be loadable for generic delegates. Thanks to Michael Bayne for reporting this.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Replaced non-ascii character (micro) with ascii 'u' in Win32PrintService.java.
- IKVM.Reflection: Bug fix. Resource Directory Entries must be sorted and names are case-insensitive

Backported for 0.46.0.4:
- Fixed ikvmc to retain transient modifier on constant static final fields.
- Fixed Field.getModifiers() to only return the relevant modifiers.
- Fixed IKVM.Reflection to set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@a1275 2
				const Modifiers ReflectionFieldModifiersMask = Modifiers.Public | Modifiers.Private | Modifiers.Protected | Modifiers.Static
					| Modifiers.Final | Modifiers.Volatile | Modifiers.Transient | Modifiers.Synthetic | Modifiers.Enum;
d1280 1
a1280 1
					(int)(this.Modifiers & ReflectionFieldModifiersMask) | (this.IsInternal ? 0x40000000 : 0),
@


1.137.2.2
log
@Updated version to 0.46.0.5 and backported bug fixes:
- IKVM.Reflection should ignore unknown metadata streams.
- Off-by-one error in local ref index reusing. Fix for bug #3575555.
- Interface mappings can be "incomplete". Fix for bug #3581564.
- The local variable state at the end of an exception block (if the last instruction is a local variable store) needs to be merged into the exception handler state.
- Local variable analysis for finally blocks was incorrect. Fixes bug #3600788.
- Don't implement interfaces that aren't accessible.
- Updated Mono workaround for Mono 3.0.x.
- Check for supported delegate signatures should detect pointers inside byref and array types and return type should be checked as well.
- Fake nested types should have Static modifier set in innerclasses attribute. Fixes scala compiler interop issue. Thanks to Michael Bayne for reporting this.
- ikvmstub -skiperror should also skip errors during WriteClass.
- An ITEMIDLIST should be freed using CoTaskMemFree.
- String.CaseInsensitiveComparator inner class should be acknowledged by String.
- Fixed the SHFILEINFO declaration. Thanks to Andras Kovacs for reporting this.
- Fixed race condition in MethodWrapper.ResolveMethod().
@
text
@d921 1
a921 2
			MethodBuilder mb = method as MethodBuilder;
			if(mb != null)
d923 1
a923 1
				method = mb.Module.ResolveMethod(mb.GetToken().Token);
d925 1
a925 2
			ConstructorBuilder cb = method as ConstructorBuilder;
			if(cb != null)
d927 1
a927 1
				method = cb.Module.ResolveMethod(cb.GetToken().Token);
d1396 1
a1396 1
				field = fb.Module.ResolveField(fb.GetToken().Token);
@


1.136
log
@- Removed unnecessary methods from CodeEmitter.
- Removed "Lazy" prefixes in CodeEmitter.
@
text
@d1450 4
@


1.135
log
@Wrapped LocalBuilder in new CodeEmitterLocal class to allow CodeEmitter to encapsulate the ILGenerator fully.
@
text
@d1704 1
a1704 1
					ilgen.LazyEmitPop();
d1707 1
a1707 1
						ilgen.LazyEmitPop();
d1778 1
a1778 1
					ilgen.LazyEmitPop();
d1781 1
a1781 1
						ilgen.LazyEmitPop();
d1878 1
a1878 1
			ilgen.LazyEmitPop();
@


1.134
log
@Move construction of EmitIntrinsicContext to compiler.
@
text
@d1440 1
a1440 1
				LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsSignatureType);
d1493 1
a1493 1
			LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsSignatureType);
d1571 1
a1571 1
				LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsSignatureType);
@


1.133
log
@Added extra indirection thru MethodWrapper for intrinsic method call emitting to allow .NET delegate constructor optimization to use instrinsic infrastructure instead of requiring EmitNewobj to pass a MethodAnalyzer and opcode index.
@
text
@d366 1
a366 1
		internal virtual bool EmitIntrinsic(DynamicTypeWrapper.FinishContext context, CodeEmitter ilgen, MethodWrapper method, MethodAnalyzer ma, int opcodeIndex, MethodWrapper caller, ClassFile classFile, ClassFile.Method.Instruction[] code, ClassFile.Method.InstructionFlags[] flags)
d368 1
a368 1
			return Intrinsics.Emit(context, ilgen, method, ma, opcodeIndex, caller, classFile, code, flags);
@


1.132
log
@Renamed IsProtectedFieldAccessible to IsPublicOrProtectedMemberAccessible, because it is for methods as well as fields and should also be applied to public members.
@
text
@d361 1
a361 1
		internal void EmitNewobj(CodeEmitter ilgen)
d363 1
a363 1
			EmitNewobj(ilgen, null, 0);
d366 1
a366 1
		internal virtual void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
d368 1
a368 1
			throw new InvalidOperationException();
d1086 1
a1086 1
		internal sealed override void EmitNewobj(CodeEmitter ilgen, MethodAnalyzer ma, int opcodeIndex)
@


1.131
log
@When a protected field is accessed in a non-public base class in another assembly that is simultaneously compiled, we need to add an InternalsVisibleTo to the callee assembly for the caller assembly.
@
text
@d155 1
a155 1
				return (IsPublic ||
d157 1
a157 1
					IsProtectedFieldAccessible(caller, instance) ||
d168 1
a168 1
		private bool IsProtectedFieldAccessible(TypeWrapper caller, TypeWrapper instance)
d170 1
a170 1
			if (IsProtected && caller.IsSubTypeOf(DeclaringType) && (IsStatic || instance.IsSubTypeOf(caller)))
d172 1
a172 1
				return DeclaringType.IsPublic || DeclaringType.InternalsVisibleTo(caller);
@


1.130
log
@More .NET 4.0 security model attributes.
@
text
@d157 1
a157 1
					(IsProtected && caller.IsSubTypeOf(DeclaringType) && (IsStatic || instance.IsSubTypeOf(caller))) ||
d168 9
@


1.130.2.1
log
@[backport] When a protected field is accessed in a non-public base class in another assembly that is simultaneously compiled, we need to add an InternalsVisibleTo to the callee assembly for the caller assembly.
@
text
@d157 1
a157 1
					IsProtectedFieldAccessible(caller, instance) ||
a167 9
		private bool IsProtectedFieldAccessible(TypeWrapper caller, TypeWrapper instance)
		{
			if (IsProtected && caller.IsSubTypeOf(DeclaringType) && (IsStatic || instance.IsSubTypeOf(caller)))
			{
				return DeclaringType.IsPublic || DeclaringType.InternalsVisibleTo(caller);
			}
			return false;
		}

@


1.130.2.2
log
@New rc version.
- Fix for bug #3033769.
- Improved handling of protected/public member access that requires InternalsVisibleTo in multiple target mode.
@
text
@d155 1
a155 1
				return (
d157 1
a157 1
					IsPublicOrProtectedMemberAccessible(caller, instance) ||
d168 1
a168 1
		private bool IsPublicOrProtectedMemberAccessible(TypeWrapper caller, TypeWrapper instance)
d170 1
a170 1
			if (IsPublic || (IsProtected && caller.IsSubTypeOf(DeclaringType) && (IsStatic || instance.IsSubTypeOf(caller))))
d172 1
a172 1
				return DeclaringType.IsPublic || InPracticeInternalsVisibleTo(caller);
@


1.130.2.3
log
@Backport: Volatile stores require a memory barrier. Fix for #3086040.
@
text
@a1449 4
			if(IsVolatile)
			{
				ilgen.EmitMemoryBarrier();
			}
@


1.129
log
@Made constructor security critical, instead of the type to avoid problem with .NET 4.0 verifier complaining about IKVM.Runtime.dll built for .NET 2.0
@
text
@d76 1
@


1.128
log
@More type safety. TypeWrapper.ClassObject is now typed as java.lang.Class.
@
text
@a64 1
		[System.Security.SecurityCritical]
d69 1
@


1.127
log
@Remove use of reflection for getting the slot of a java.lang.reflect.Field.
@
text
@d489 1
a489 1
					parameterTypes[i] = (java.lang.Class)argTypes[i].ClassObject;
d495 1
a495 1
						(java.lang.Class)this.DeclaringType.ClassObject,
d508 1
a508 1
						(java.lang.Class)this.DeclaringType.ClassObject,
d511 1
a511 1
						(java.lang.Class)this.ReturnType.ClassObject,
d571 1
a571 1
					array[i] = (java.lang.Class)this.DeclaringType.GetClassLoader().LoadClassByDottedName(classes[i]).ClassObject;
d1267 1
a1267 1
					(java.lang.Class)this.DeclaringType.ClassObject,
d1269 1
a1269 1
					(java.lang.Class)this.FieldTypeWrapper.ClassObject,
@


1.126
log
@Prep for .NET 4.0 security model:
- added more SecurityCritical attributes
- added SecuritySafeCritical/TreatAsSafe attributes to Direct-X-Buffer classes
@
text
@a1173 1
		private static readonly FieldInfo slotField = typeof(java.lang.reflect.Field).GetField("slot", BindingFlags.Instance | BindingFlags.NonPublic);
d1254 1
a1254 1
			return TypeWrapper.FromClass(f.getDeclaringClass()).GetFields()[(int)slotField.GetValue(f)];
@


1.125
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@d65 1
d106 1
d120 1
d603 1
d1297 1
@


1.124
log
@Removed "constant" instance field support (which was only used by ikvmstub and doesn't make any sense anyway).
@
text
@d26 1
a26 1
#if IKVM_REF_EMIT
@


1.123
log
@Last set of changes preparing for new stub generator. A massive amount of conditional compilation changes, to skip irrelevant code when building ikvmstub.
@
text
@d1227 1
a1227 1
			// only pritimives and string can be literals in Java (because the other "primitives" (like uint),
d1229 1
a1229 1
			if(field != null && (fieldType.IsPrimitive || fieldType == CoreClasses.java.lang.String.Wrapper))
d1231 2
a1232 2
				object val = null;
				if(field.IsLiteral)
d1234 1
a1234 13
					val = field.GetRawConstantValue();
					if(field.FieldType.IsEnum)
					{
						val = EnumHelper.GetPrimitiveValue(EnumHelper.GetUnderlyingType(field.FieldType), val);
					}
				}
				else
				{
					// NOTE instance fields can also be "constant" and we round trip this information to make the Japi results look
					// nice (but otherwise this has no practical value), but note that this only works when the code is compiled
					// with -strictfieldfieldsemantics (because the ConstantValueAttribute is on the field and when we're a GetterFieldWrapper
					// we don't have access to the corresponding field).
					val = AttributeHelper.GetConstantValue(field);
d1236 1
a1236 1
				if(val != null && !(val is string))
@


1.122
log
@Expose custom attribute annotation properties for use by new stub generator.
@
text
@d315 1
a315 1
#if !STATIC_COMPILER && !FIRST_PASS
d322 1
a322 1
#if !STATIC_COMPILER && !FIRST_PASS
d332 1
d357 1
d390 1
d396 1
d473 1
a473 1
#if !STATIC_COMPILER
d598 1
a598 1
#endif // !STATIC_COMPILER
d777 1
a777 1
#if !STATIC_COMPILER
d901 1
a901 1
#endif // !STATIC_COMPILER
d903 1
a903 1
#if !STATIC_COMPILER && !FIRST_PASS
d988 1
a988 1
#endif // !STATIC_COMPILER && !FIRST_PASS
d1034 1
d1087 1
d1109 1
d1119 1
d1134 1
d1144 1
d1154 1
d1164 1
d1169 1
a1169 1
#if !STATIC_COMPILER && !FIRST_PASS
d1221 1
a1221 1
#if !STATIC_COMPILER
d1303 1
a1303 1
#endif // !STATIC_COMPILER
d1319 1
d1335 1
d1386 1
a1386 1
#if !STATIC_COMPILER
d1408 1
a1408 1
#endif // !STATIC_COMPILER
d1419 1
d1449 1
d1461 1
d1516 1
d1549 1
d1588 1
d1591 1
d1738 1
d1751 1
d1796 1
d1817 1
d1878 1
d1919 1
d1929 1
@


1.121
log
@Moved non-throwing signature parsing from ClassFile.cs to ClassLoaderWrapper.cs (and merged it with the throwing variant). This avoids new stub generator having to include ClassFile.cs.
@
text
@d1000 5
@


1.120
log
@Integrated new IKVM.Reflection implementation.
@
text
@d619 2
a620 2
			TypeWrapper ret = ClassFile.RetTypeWrapperFromSig(loader, Signature);
			TypeWrapper[] parameters = ClassFile.ArgTypeWrapperListFromSig(loader, Signature);
d1327 1
a1327 1
			TypeWrapper fld = ClassFile.FieldTypeWrapperFromSig(this.DeclaringType.GetClassLoader(), Signature);
d1916 1
a1916 1
					type = ClassFile.FieldTypeWrapperFromSig(wrapper.GetClassLoader(), nameSig.Sig);
@


1.119
log
@Changed JNI to use standard caller ID mechanism.
@
text
@a25 1
using System.Reflection;
d27 1
d29 1
d31 1
@


1.118
log
@Accept also string constant in Assert
@
text
@d118 1
a118 1
			return (MemberWrapper)((GCHandle)cookie).Target;
d773 1
a773 1
		internal object InvokeJNI(object obj, object[] args, bool nonVirtual, MethodBase callerID)
d810 1
a810 1
						InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, obj, UnboxArgs(args), ikvm.@@internal.CallerID.create(callerID));
d856 1
a856 1
					object val = acc.invoke(obj, args, ikvm.@@internal.CallerID.create(callerID));
d873 1
a873 1
				object val = acc.invoke(obj, args, ikvm.@@internal.CallerID.create(callerID));
@


1.117
log
@There's no reason for reflectionField not to be statically typed.
@
text
@d1782 1
a1782 1
			Debug.Assert(constant == null || constant.GetType().IsPrimitive);
@


1.116
log
@Removed unnecessary usage of ReflectionFactory.
@
text
@d1152 1
a1152 1
		private volatile object reflectionField;
d1253 1
a1253 1
			object field = reflectionField;
d1279 1
a1279 1
				field = ((java.lang.reflect.Field)field).copy();
@


1.115
log
@Removed unnecessary usage of Java types in field reflection guts.
@
text
@a55 3
#if !STATIC_COMPILER && !FIRST_PASS
		protected static readonly sun.reflect.ReflectionFactory reflectionFactory = (sun.reflect.ReflectionFactory)ClassLoaderWrapper.DoPrivileged(new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());
#endif
d485 1
a485 1
					method = reflectionFactory.newConstructor(
d498 1
a498 1
					method = reflectionFactory.newMethod(
d529 1
a529 1
					return reflectionFactory.copyConstructor(ctor);
d531 1
a531 1
				return reflectionFactory.copyMethod((java.lang.reflect.Method)method);
d786 1
a786 1
						acc = reflectionFactory.newConstructorAccessor(cons);
d870 1
a870 1
					acc = reflectionFactory.newMethodAccessor(method);
d1256 1
a1256 1
				field = reflectionFactory.newField(
d1279 1
a1279 1
				field = reflectionFactory.copyField((java.lang.reflect.Field)field);
@


1.114
log
@Added two constructors to ThowsAttribute that take a Type and a Type[] for greater convenience when applying the attribute to user code and for compatibility with Grasshopper's ThrowsAttribute.
@
text
@d1385 1
a1385 1
				jniAccessor = reflectionFactory.newFieldAccessor((java.lang.reflect.Field)ToField(false), true);
@


1.113
log
@- Fixed IsPackageAccessibleFrom to consider class loaders, instead of InternalsVisibleToAttribute
- Added automatic access to internal accessibility members across assemblies in multi target compilation (previously this was only done for -sharedclassloader scenarios)
- Cleaned up existing field access stubs (now known as "type 1") and added type 2 access stubs to make public fields that have a non-public field type accessible.
@
text
@d485 1
a485 6
				string[] exceptions = GetExceptions();
				java.lang.Class[] checkedExceptions = new java.lang.Class[exceptions.Length];
				for (int i = 0; i < exceptions.Length; i++)
				{
					checkedExceptions[i] = (java.lang.Class)this.DeclaringType.GetClassLoader().LoadClassByDottedName(exceptions[i]).ClassObject;
				}
d540 41
a706 21
		internal string[] GetExceptions()
		{
			// remapped types and dynamically compiled types have declaredExceptions set
			if(declaredExceptions != null)
			{
				return (string[])declaredExceptions.Clone();
			}
			// NOTE if method is a MethodBuilder, GetCustomAttributes doesn't work (and if
			// the method had any declared exceptions, the declaredExceptions field would have
			// been set)
			if(method != null && !(method is MethodBuilder))
			{
				ThrowsAttribute attr = AttributeHelper.GetThrows(method);
				if(attr != null)
				{
					return attr.Classes;
				}
			}
			return new string[0];
		}

@


1.112
log
@- Moved enum helper methods into new EnumHelper class.
- Changed .NET EnumEnum field to call ByteCodeHelper method, instead of emitting code in place.
@
text
@d1165 1
a1165 1
			if ((IsPublic || IsProtected) && fieldType != null)
a1845 85
	// This type is used during AOT compilation only!
	sealed class AotAccessStubFieldWrapper : FieldWrapper
	{
		private FieldWrapper basefield;
		private MethodBuilder getter;
		private MethodBuilder setter;

		internal AotAccessStubFieldWrapper(TypeWrapper wrapper, FieldWrapper basefield)
			: base(wrapper, null, basefield.Name, basefield.Signature, basefield.Modifiers, null, MemberFlags.AccessStub | MemberFlags.HideFromReflection)
		{
			this.basefield = basefield;
		}

		private string GenerateUniqueMethodName(string basename, Type returnType, Type[] parameterTypes)
		{
			return ((DynamicTypeWrapper)this.DeclaringType).GenerateUniqueMethodName(basename, returnType, parameterTypes);
		}

		internal void DoLink(TypeBuilder typeBuilder)
		{
			basefield.Link();
			if(basefield is ConstantFieldWrapper)
			{
				FieldAttributes attribs = basefield.IsPublic ? FieldAttributes.Public : FieldAttributes.FamORAssem;
				attribs |= FieldAttributes.Static | FieldAttributes.Literal;
				FieldBuilder fb = typeBuilder.DefineField(Name, basefield.FieldTypeWrapper.TypeAsSignatureType, attribs);
				AttributeHelper.HideFromReflection(fb);
				fb.SetConstant(((ConstantFieldWrapper)basefield).GetConstantValue());
			}
			else
			{
				Type propType = basefield.FieldTypeWrapper.TypeAsSignatureType;
				PropertyBuilder pb = typeBuilder.DefineProperty(Name, PropertyAttributes.None, propType, Type.EmptyTypes);
				AttributeHelper.HideFromReflection(pb);
				MethodAttributes attribs = basefield.IsPublic ? MethodAttributes.Public : MethodAttributes.FamORAssem;
				attribs |= MethodAttributes.HideBySig;
				if(basefield.IsStatic)
				{
					attribs |= MethodAttributes.Static;
				}
				getter = typeBuilder.DefineMethod(GenerateUniqueMethodName("get_" + Name, propType, Type.EmptyTypes), attribs, propType, Type.EmptyTypes);
				AttributeHelper.HideFromJava(getter);
				pb.SetGetMethod(getter);
				CodeEmitter ilgen = CodeEmitter.Create(getter);
				if(!basefield.IsStatic)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
				}
				basefield.EmitGet(ilgen);
				ilgen.Emit(OpCodes.Ret);
				if(!basefield.IsFinal)
				{
					setter = typeBuilder.DefineMethod(GenerateUniqueMethodName("set_" + Name, Types.Void, new Type[] { propType }), attribs, null, new Type[] { propType });
					AttributeHelper.HideFromJava(setter);
					pb.SetSetMethod(setter);
					ilgen = CodeEmitter.Create(setter);
					ilgen.Emit(OpCodes.Ldarg_0);
					if(!basefield.IsStatic)
					{
						ilgen.Emit(OpCodes.Ldarg_1);
					}
					basefield.EmitSet(ilgen);
					ilgen.Emit(OpCodes.Ret);
				}
			}
		}

		protected override void EmitGetImpl(CodeEmitter ilgen)
		{
			if(basefield is ConstantFieldWrapper)
			{
				basefield.EmitGet(ilgen);
			}
			else
			{
				ilgen.Emit(OpCodes.Call, getter);
			}
		}

		protected override void EmitSetImpl(CodeEmitter ilgen)
		{
			ilgen.Emit(OpCodes.Call, setter);
		}
	}

d1867 2
a1868 2
		internal CompiledAccessStubFieldWrapper(TypeWrapper wrapper, PropertyInfo property)
			: base(wrapper, ClassLoaderWrapper.GetWrapperFromType(property.PropertyType), property.Name, ClassLoaderWrapper.GetWrapperFromType(property.PropertyType).SigName, GetModifiers(property), null, MemberFlags.AccessStub | MemberFlags.HideFromReflection)
d1883 50
@


1.111
log
@Removed unnecessary complexity in enum handling.
@
text
@d1206 1
a1206 1
						val = DotNetTypeWrapper.EnumValueFieldWrapper.GetEnumPrimitiveValue(Enum.GetUnderlyingType(field.FieldType), val);
@


1.110
log
@Replaced most type literals with static field access (in Types class) or warpped JVM.Import() around them.
@
text
@d1763 1
d1770 1
a1821 12
			else if(constant is Enum)
			{
				object val = DotNetTypeWrapper.EnumValueFieldWrapper.GetEnumPrimitiveValue(constant);
				if(val is long)
				{
					ilgen.Emit(OpCodes.Ldc_I8, (long)constant);
				}
				else
				{
					ilgen.Emit(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
				}
			}
d1840 1
a1840 14
#if !STATIC_COMPILER
				if(field.FieldType.IsEnum && !field.DeclaringType.IsEnum)
				{
					if(field.DeclaringType.Assembly.ReflectionOnly)
					{
						return null;
					}
					constant = field.GetValue(null);
				}
				else
#endif // !STATIC_COMPILER
				{
					constant = field.GetRawConstantValue();
				}
@


1.109
log
@Removed EmitHelper class and moved its methods into CodeEmitter.
@
text
@d1921 1
a1921 1
					setter = typeBuilder.DefineMethod(GenerateUniqueMethodName("set_" + Name, typeof(void), new Type[] { propType }), attribs, null, new Type[] { propType });
@


1.108
log
@Removed vestigial compact framework support.
@
text
@d1647 1
a1647 1
			EmitHelper.Throw(ilgen, "java.lang.NoSuchMethodError");
d1689 1
a1689 1
			EmitHelper.Throw(ilgen, "java.lang.NoSuchMethodError");
@


1.107
log
@Implemented optimization to remove .cctor when it is empty (and the class isn't serializable or has a serialVersionUID).
@
text
@d29 1
a29 1
#elif !COMPACT_FRAMEWORK
a332 1
#if !COMPACT_FRAMEWORK
d357 1
a357 1
#endif
a388 1
#if !COMPACT_FRAMEWORK
a393 1
#endif
a680 3
#if COMPACT_FRAMEWORK
			if(method != null)
#else
a681 1
#endif
a887 1
#if !COMPACT_FRAMEWORK
a896 1
#endif // !COMPACT_FRAMEWORK
a971 1
#if !COMPACT_FRAMEWORK
a985 1
#endif
a1010 1
#if !COMPACT_FRAMEWORK
a1062 1
#endif
a1083 1
#if !COMPACT_FRAMEWORK
a1092 1
#endif
a1106 1
#if !COMPACT_FRAMEWORK
a1115 1
#endif
a1124 1
#if !COMPACT_FRAMEWORK
a1133 1
#endif
a1287 1
#if !COMPACT_FRAMEWORK
a1302 1
#endif
a1385 1
#if !COMPACT_FRAMEWORK
a1414 1
#endif
a1425 1
#if !COMPACT_FRAMEWORK
a1479 1
#endif
a1511 1
#if !COMPACT_FRAMEWORK
a1549 1
#endif
a1771 1
#if !COMPACT_FRAMEWORK
d1844 1
a1844 1
#endif
a1868 1
#if !COMPACT_FRAMEWORK
a1952 1
#endif
a1981 1
#if !COMPACT_FRAMEWORK
a1990 1
#endif
@


1.106
log
@Use LazyEmitPop() to annihilate constants.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2008 Jeroen Frijters
d999 16
@


1.105
log
@Implemented class gc (available only when compiling on .NET 4.0).
@
text
@d1673 1
a1673 1
					ilgen.Emit(OpCodes.Pop);
d1676 1
a1676 1
						ilgen.Emit(OpCodes.Pop);
d1745 1
a1745 1
					ilgen.Emit(OpCodes.Pop);
d1748 1
a1748 1
						ilgen.Emit(OpCodes.Pop);
d1854 1
a1854 1
			ilgen.Emit(OpCodes.Pop);
@


1.104
log
@Resolve ConstructorBuilder before invoking.
@
text
@d35 1
d59 1
a59 1
		private System.Runtime.InteropServices.GCHandle handle;
d66 28
a103 20
		// NOTE since we don't support unloading code, there is no need to have a finalizer
#if CLASS_GC
	~MemberWrapper()
	{
		// NOTE when the AppDomain is being unloaded, we shouldn't clean up the handle, because
		// JNI code running in a finalize can use this handle later on (since finalization is
		// unordered). Note that this isn't a leak since the AppDomain is going away anyway.
		if(!Environment.HasShutdownStarted && handle.IsAllocated)
		{
			FreeHandle();
		}
	}

	private void FreeHandle()
	{
		// this has a LinkDemand, so it has to be in a separate method
		handle.Free();
	}
#endif

d110 1
a110 1
					if(!handle.IsAllocated)
d112 1
a112 1
						handle = System.Runtime.InteropServices.GCHandle.Alloc(this, System.Runtime.InteropServices.GCHandleType.Weak);
d115 1
a115 1
				return (IntPtr)handle;
d121 1
a121 1
			return (MemberWrapper)((System.Runtime.InteropServices.GCHandle)cookie).Target;
@


1.104.2.1
log
@Backport: Volatile stores require a memory barrier. Fix for #3086040.
@
text
@a1410 4
 			if(IsVolatile)
 			{
 				ilgen.Emit(OpCodes.Call, typeof(System.Threading.Thread).GetMethod("MemoryBarrier"));
 			}
@


1.103
log
@- Added virtual method to MethodWrapper to do custom linking (i.e. defining the method).
- Added the notion of Java methods that don't have a corresponding CLR method (currently only for delegate constructors).
@
text
@d795 1
@


1.102
log
@Added a helper method to invoke AccessController.doPrivileged() and pass in explicit CallerID.
@
text
@d592 1
a592 1
							method = this.DeclaringType.LinkMethod(this);
d607 5
@


1.101
log
@Changed "InternalsVisibleTo" handling to be based on Assembly instead of class loader.
@
text
@d56 1
a56 1
		protected static readonly sun.reflect.ReflectionFactory reflectionFactory = (sun.reflect.ReflectionFactory)java.security.AccessController.doPrivileged(new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());
@


1.100
log
@Unloadable types in signatures are represented by Object, so they don't need to cause the member to be treated as inaccessible.
@
text
@d146 1
a146 1
					(IsInternal && DeclaringType.GetClassLoader().InternalsVisibleTo(caller.GetClassLoader())) ||
d167 1
a167 1
			return DeclaringType.GetClassLoader().InternalsVisibleTo(caller.GetClassLoader());
@


1.99
log
@Java allows public/protected members to expose package private classes, but when the caller isn't in the same assembly (or the assembly grants InternalsVisibleTo access to the caller) the CLR will disallow, so we have to support this scenario (currently by simply disallow the access at the Java level).
@
text
@d437 1
a437 1
				if (!returnTypeWrapper.IsPublic)
d445 1
a445 1
						if (!tw.IsPublic)
d1155 1
a1155 1
				if (!fieldType.IsPublic)
@


1.98
log
@Integrated IKVM.Reflection.Emit in ikvmc.
@
text
@d50 1
d143 1
a143 1
				return IsPublic ||
d147 5
a151 1
					(!IsPrivate && DeclaringType.IsPackageAccessibleFrom(caller));
d156 14
d235 5
d430 23
d587 1
d1142 1
d1151 11
d1309 1
@


1.97
log
@Removed last parts of old-style reflection.
@
text
@d27 3
a29 1
#if !COMPACT_FRAMEWORK
@


1.96
log
@- Removed "slow" reflection.
- Removed MethodWrapper.Invoke().
- Removed FieldWrapper.GetValue()/SetValue().
- Added ICustomInvoke for the few MethodWrappers that still require custom reflection invocation.
@
text
@d282 1
a282 1
		object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID);
d309 5
d766 1
a766 1
				if (this.DeclaringType.IsRemapped)
d769 1
a769 1
					return InvokeImpl(method, obj, UnboxArgs(args), true, ikvm.@@internal.CallerID.create(callerID));
a842 2
		private delegate object Invoker(IntPtr pFunc, object obj, object[] args, ikvm.@@internal.CallerID callerID);

d844 1
a844 1
		internal object InvokeImpl(MethodBase method, object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
d846 1
a846 115
#if !FIRST_PASS
#if !COMPACT_FRAMEWORK
			Debug.Assert(!(method is MethodBuilder || method is ConstructorBuilder));
#endif // !COMPACT_FRAMEWORK

			if(IsStatic)
			{
				// Java allows bogus 'obj' to be specified for static methods
				obj = null;
			}
			else
			{
				if(ReferenceEquals(Name, StringConstants.INIT))
				{
					if(method is MethodInfo)
					{
						Debug.Assert(method.IsStatic);
						// we're dealing with a constructor on a remapped type, if obj is supplied, it means
						// that we should call the constructor on an already existing instance, but that isn't
						// possible with remapped types
						if(obj != null)
						{
							// the type of this exception is a bit random (note that this can only happen through JNI reflection or
							// if there is a bug in serialization [which uses the ObjectInputStream.callConstructor() in classpath.cs)
							throw new java.lang.IncompatibleClassChangeError(string.Format("Remapped type {0} doesn't support constructor invocation on an existing instance", DeclaringType.Name));
						}
					}
					else if(obj == null)
					{
						// calling <init> without an instance means that we're constructing a new instance
						// NOTE this means that we cannot detect a NullPointerException when calling <init> (does JNI require this?)
						try
						{
							InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, null, args, callerID);
							object o = ((ConstructorInfo)method).Invoke(proc.GetArgs());
							// since we just constructed an instance, it can't possibly be a ghost
							return o;
						}
						catch(ArgumentException x1)
						{
							throw new java.lang.IllegalArgumentException(x1.Message);
						}
						catch(TargetInvocationException x)
						{
							throw new java.lang.reflect.InvocationTargetException(ikvm.runtime.Util.mapException(x.InnerException));
						}
					}
					else if(!method.DeclaringType.IsInstanceOfType(obj))
					{
						// we're trying to initialize an existing instance of a remapped type
						if(obj is System.Exception && (args == null || args.Length == 0))
						{
							// HACK special case for deserialization of java.lang.Throwable subclasses
							// we don't call the constructor here, it will be called by Throwable.readObject()
							return null;
						}
						else
						{
							// NOTE this will also happen if you try to deserialize a .NET object
							// (i.e. a type that doesn't derive from our java.lang.Object).
							// We might want to support that in the future (it's fairly easy, because
							// the call to Object.<init> can just be ignored)
							throw new NotSupportedException("Unable to partially construct object of type " + obj.GetType().FullName + " to type " + method.DeclaringType.FullName);
						}
					}
				}
				else if(nonVirtual &&
					method.IsVirtual &&	// if the method isn't virtual, normal reflection will work
					!method.IsFinal &&	// if the method is final, normal reflection will work
					!method.DeclaringType.IsSealed && // if the type is sealed, normal reflection will work
					!method.IsAbstract)	// if the method is abstract, it doesn't make sense, so we'll do a virtual call
					// (Sun does a virtual call for interface methods and crashes for abstract methods)
				{
#if COMPACT_FRAMEWORK
					throw new NotSupportedException("Reflective non-virtual method invocation is not supported on the Compact Framework");
#else
					Invoker invoker = NonvirtualInvokeHelper.GetInvoker(this);
					try
					{
						InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, obj, args, null);
						return invoker(method.MethodHandle.GetFunctionPointer(), proc.GetObj(), proc.GetArgs(), callerID);
					}
					catch(ArgumentException x1)
					{
						throw new java.lang.IllegalArgumentException(x1.Message);
					}
					catch(TargetInvocationException x)
					{
						throw new java.lang.reflect.InvocationTargetException(ikvm.runtime.Util.mapException(x.InnerException));
					}
#endif
				}
			}
			try
			{
				InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, obj, args, callerID);
				object o = method.Invoke(proc.GetObj(), proc.GetArgs());
				TypeWrapper retType = this.ReturnType;
				if(!retType.IsUnloadable && retType.IsGhost)
				{
					o = retType.GhostRefField.GetValue(o);
				}
				return o;
			}
			catch(ArgumentException x1)
			{
				throw new java.lang.IllegalArgumentException(x1.Message);
			}
			catch(TargetInvocationException x)
			{
				throw new java.lang.reflect.InvocationTargetException(ikvm.runtime.Util.mapException(x.InnerException));
			}
#else // !FIRST_PASS
			return null;
#endif
a848 98
#if !COMPACT_FRAMEWORK
		private static class NonvirtualInvokeHelper
		{
			private static Dictionary<MethodKey, Invoker> cache;
			private static ModuleBuilder module;

			static NonvirtualInvokeHelper()
			{
				cache = new Dictionary<MethodKey, Invoker>();
				AssemblyName name = new AssemblyName();
				name.Name = "NonvirtualInvoker";
				AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, JVM.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
				if(JVM.IsSaveDebugImage)
				{
					module = ab.DefineDynamicModule("NonvirtualInvoker", "NonvirtualInvoker.dll");
					DynamicClassLoader.RegisterForSaveDebug(ab);
				}
				else
				{
					module = ab.DefineDynamicModule("NonvirtualInvoker");
				}
			}

			internal static Invoker GetInvoker(MethodWrapper mw)
			{
				lock(cache)
				{
					MethodKey key = new MethodKey(mw.DeclaringType.Name, mw.Name, mw.Signature);
					Invoker inv;
					if(!cache.TryGetValue(key, out inv))
					{
						inv = CreateInvoker(mw);
						cache[key] = inv;
					}
					return inv;
				}
			}

			private static Invoker CreateInvoker(MethodWrapper mw)
			{
				// TODO we need to support byref arguments...
				TypeBuilder typeBuilder = module.DefineType("class" + cache.Count);
				MethodBuilder methodBuilder = typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Static, typeof(object), new Type[] { typeof(IntPtr), typeof(object), typeof(object[]), typeof(ikvm.@@internal.CallerID) });
				AttributeHelper.HideFromJava(methodBuilder);
				CodeEmitter ilgen = CodeEmitter.Create(methodBuilder);
				ilgen.Emit(OpCodes.Ldarg_1);
				TypeWrapper[] paramTypes = mw.GetParameters();
				for(int i = 0; i < paramTypes.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldarg_2);
					ilgen.Emit(OpCodes.Ldc_I4, i);
					ilgen.Emit(OpCodes.Ldelem_Ref);
					if(paramTypes[i].IsUnloadable)
					{
						// no need to do anything
					}
					else if(paramTypes[i].IsPrimitive)
					{
						ilgen.Emit(OpCodes.Unbox, paramTypes[i].TypeAsTBD);
						ilgen.Emit(OpCodes.Ldobj, paramTypes[i].TypeAsTBD);
					}
					else if(paramTypes[i].IsNonPrimitiveValueType)
					{
						paramTypes[i].EmitUnbox(ilgen);
					}
				}
				if(mw.HasCallerID)
				{
					ilgen.Emit(OpCodes.Ldarg_3);
				}
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.EmitCalli(OpCodes.Calli, CallingConventions.HasThis, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod(), null);
				if(mw.ReturnType.IsUnloadable)
				{
					// no need to do anything
				}
				else if(mw.ReturnType == PrimitiveTypeWrapper.VOID)
				{
					ilgen.Emit(OpCodes.Ldnull);
				}
				else if(mw.ReturnType.IsGhost)
				{
					LocalBuilder local = ilgen.DeclareLocal(mw.ReturnType.TypeAsSignatureType);
					ilgen.Emit(OpCodes.Stloc, local);
					ilgen.Emit(OpCodes.Ldloca, local);
					ilgen.Emit(OpCodes.Ldfld, mw.ReturnType.GhostRefField);
				}
				else if(mw.ReturnType.IsPrimitive)
				{
					ilgen.Emit(OpCodes.Box, mw.ReturnType.TypeAsTBD);
				}
				ilgen.Emit(OpCodes.Ret);
				Type type = typeBuilder.CreateType();
				return (Invoker)Delegate.CreateDelegate(typeof(Invoker), type.GetMethod("Invoke"));
			}
		}
#endif

@


1.95
log
@Changed JNI reflection to be based on Java reflection (where possible).
@
text
@d279 7
a356 12

#if !STATIC_COMPILER && !FIRST_PASS
			[HideFromJava]
			internal override object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
			{
				object wrapper = Activator.CreateInstance(DeclaringType.TypeAsSignatureType);
				DeclaringType.GhostRefField.SetValue(wrapper, obj);

				ResolveGhostMethod();
				return InvokeImpl(ghostMethod, wrapper, args, nonVirtual, callerID);
			}
#endif // !STATIC_COMPILER
a822 8
		[HideFromJava]
		internal virtual object Invoke(object obj, object[] args, bool nonVirtual, ikvm.@@internal.CallerID callerID)
		{
			AssertLinked();
			ResolveMethod();
			return InvokeImpl(method, obj, args, nonVirtual, callerID);
		}

a1498 22
		internal virtual void SetValue(object obj, object val)
		{
			AssertLinked();
			ResolveField();
			if(fieldType.IsGhost)
			{
				object temp = field.GetValue(obj);
				fieldType.GhostRefField.SetValue(temp, val);
				val = temp;
			}
			try
			{
				field.SetValue(obj, val);
			}
			catch(FieldAccessException x)
			{
#if !FIRST_PASS
				throw new java.lang.IllegalAccessException(x.Message);
#endif
			}
		}

a1511 16

		internal virtual object GetValue(object obj)
		{
			AssertLinked();
#if STATIC_COMPILER
			return field.GetValue(null);
#else
			ResolveField();
			object val = field.GetValue(obj);
			if(fieldType.IsGhost)
			{
				val = fieldType.GhostRefField.GetValue(val);
			}
			return val;
#endif // STATIC_COMPILER
		}
a1651 18
#if !STATIC_COMPILER
		internal override object GetValue(object obj)
		{
			return prop.GetValue(obj, null);
		}

		internal override void SetValue(object obj, object val)
		{
			if(FieldTypeWrapper.IsGhost)
			{
				object temp = GetValue(obj);
				FieldTypeWrapper.GhostRefField.SetValue(temp, val);
				val = temp;
			}
			prop.SetValue(obj, val, null);
		}
#endif

a1766 20
#if !STATIC_COMPILER && !FIRST_PASS
		internal override object GetValue(object obj)
		{
			if(getter == null)
			{
				throw new global::java.lang.NoSuchMethodError();
			}
			return getter.Invoke(obj, new object[0], false, null);
		}

		internal override void SetValue(object obj, object val)
		{
			if(setter == null)
			{
				throw new global::java.lang.NoSuchMethodError();
			}
			setter.Invoke(obj, new object[] { val }, false, null);
		}
#endif

a1851 20
#if !STATIC_COMPILER && !FIRST_PASS
		internal override object GetValue(object obj)
		{
			if (!property.CanRead)
			{
				throw new global::java.lang.NoSuchMethodError();
			}
			return property.GetValue(obj, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetProperty, null, null, null);
		}

		internal override void SetValue(object obj, object val)
		{
			if(!property.CanWrite)
			{
				throw new global::java.lang.NoSuchMethodError();
			}
			property.SetValue(obj, val, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.SetProperty, null, null, null);
		}
#endif

a2009 7

		internal override object GetValue(object obj)
		{
			// on a non-broken CLR GetValue on a literal will not trigger type initialization, but on Java it should
			DeclaringType.RunClassInit();
			return GetConstantValue();
		}
a2095 14

#if !STATIC_COMPILER
		internal override object GetValue(object obj)
		{
			// We're MemberFlags.HideFromReflection, so we should never be called
			throw new InvalidOperationException();
		}

		internal override void SetValue(object obj, object val)
		{
			// We're MemberFlags.HideFromReflection, so we should never be called
			throw new InvalidOperationException();
		}
#endif // !STATIC_COMPILER
a2137 14

#if !STATIC_COMPILER
		internal override object GetValue(object obj)
		{
			// We're MemberFlags.HideFromReflection, so we should never be called
			throw new InvalidOperationException();
		}

		internal override void SetValue(object obj, object val)
		{
			// We're MemberFlags.HideFromReflection, so we should never be called
			throw new InvalidOperationException();
		}
#endif // !STATIC_COMPILER
@


1.94
log
@Generified all collections.
@
text
@d32 1
d282 1
d709 101
a809 1
			return Invoke(obj, args, nonVirtual, ikvm.@@internal.CallerID.create(callerID));
d812 13
d1301 1
d1533 13
@


1.93
log
@Removed unused per-type class caching.
@
text
@d25 1
a25 1
using System.Collections;
d861 1
a861 1
			private static Hashtable cache;
a863 37
			private class KeyGen : IEqualityComparer
			{
				public int GetHashCode(object o)
				{
					MethodWrapper mw = (MethodWrapper)o;
					return mw.Signature.GetHashCode();
				}

				public new bool Equals(object x, object y)
				{
					return Compare(x, y) == 0;
				}

				public int Compare(object x, object y)
				{
					MethodWrapper mw1 = (MethodWrapper)x;
					MethodWrapper mw2 = (MethodWrapper)y;
					if(mw1.ReturnType == mw2.ReturnType)
					{
						TypeWrapper[] p1 = mw1.GetParameters();
						TypeWrapper[] p2 = mw2.GetParameters();
						if(p1.Length == p2.Length)
						{
							for(int i = 0; i < p1.Length; i++)
							{
								if(p1[i] != p2[i])
								{
									return 1;
								}
							}
							return 0;
						}
					}
					return 1;
				}
			}

d866 1
a866 2
				KeyGen keygen = new KeyGen();
				cache = new Hashtable(keygen);
d883 1
a883 1
				lock(cache.SyncRoot)
d885 3
a887 2
					Invoker inv = (Invoker)cache[mw];
					if(inv == null)
d890 1
a890 1
						cache[mw] = inv;
@


1.92
log
@ResolveField() is not needed in ikvmc.
@
text
@d527 2
a528 4
			// TODO we need to use the actual classCache here
			System.Collections.Hashtable classCache = new System.Collections.Hashtable();
			TypeWrapper ret = ClassFile.RetTypeWrapperFromSig(loader, classCache, Signature);
			TypeWrapper[] parameters = ClassFile.ArgTypeWrapperListFromSig(loader, classCache, Signature);
d1384 1
a1384 3
			// TODO we need to use the actual classCache here
			System.Collections.Hashtable classCache = new System.Collections.Hashtable();
			TypeWrapper fld = ClassFile.FieldTypeWrapperFromSig(this.DeclaringType.GetClassLoader(), classCache, Signature);
@


1.91
log
@Removed support for building with GNU Classpath class library.
@
text
@d1427 1
a1436 1
#if !STATIC_COMPILER
a1462 1
			ResolveField();
d1466 1
@


1.90
log
@- Renamed CountingILGenerator to CodeEmitter.
- Renamed CountingLabel to CodeEmitterLabel.
@
text
@d51 1
a51 1
#if OPENJDK && !FIRST_PASS
d280 1
a280 1
#if OPENJDK && !FIRST_PASS
d418 1
a418 1
#elif OPENJDK
a484 6
#else
			if (this.Name == StringConstants.INIT)
			{
				return JVM.Library.newConstructor(this.DeclaringType.ClassObject, this);
			}
			return JVM.Library.newMethod(this.DeclaringType.ClassObject, this);
d492 1
a492 1
#elif OPENJDK
a499 2
#else
			return (MethodWrapper)JVM.Library.getWrapperFromMethodOrConstructor(methodOrConstructor);
d1222 1
a1222 1
#if OPENJDK && !FIRST_PASS
d1301 1
a1301 1
#elif OPENJDK
a1303 2
#else
			return (FieldWrapper)JVM.Library.getWrapperFromField(field);
d1311 1
a1311 1
#elif OPENJDK
a1340 2
#else
			return JVM.Library.newField(this.DeclaringType.ClassObject, this);
@


1.89
log
@Marked all static classes as static.
@
text
@a28 1
using ILGenerator = IKVM.Internal.CountingILGenerator;
d290 1
a290 1
		internal virtual void EmitCall(ILGenerator ilgen)
d295 1
a295 1
		internal virtual void EmitCallvirt(ILGenerator ilgen)
d300 1
a300 1
		internal void EmitNewobj(ILGenerator ilgen)
d305 1
a305 1
		internal virtual void EmitNewobj(ILGenerator ilgen, MethodAnalyzer ma, int opcodeIndex)
d342 1
a342 1
			protected override void CallvirtImpl(ILGenerator ilgen)
d949 1
a949 1
				ILGenerator ilgen = methodBuilder.GetILGenerator();
d1096 1
a1096 1
		protected virtual void PreEmit(ILGenerator ilgen)
d1099 2
a1100 2
	
		internal sealed override void EmitCall(ILGenerator ilgen)
d1107 1
a1107 1
		protected virtual void CallImpl(ILGenerator ilgen)
d1112 1
a1112 1
		internal sealed override void EmitCallvirt(ILGenerator ilgen)
d1128 1
a1128 1
		protected virtual void CallvirtImpl(ILGenerator ilgen)
d1133 1
a1133 1
		internal sealed override void EmitNewobj(ILGenerator ilgen, MethodAnalyzer ma, int opcodeIndex)
d1144 1
a1144 1
		protected virtual void NewobjImpl(ILGenerator ilgen)
d1171 1
a1171 1
		internal override void EmitCall(ILGenerator ilgen)
d1176 1
a1176 1
		internal override void EmitCallvirt(ILGenerator ilgen)
d1196 1
a1196 1
		protected override void CallImpl(ILGenerator ilgen)
d1201 1
a1201 1
		protected override void CallvirtImpl(ILGenerator ilgen)
d1216 1
a1216 1
		protected override void CallImpl(ILGenerator ilgen)
d1221 1
a1221 1
		protected override void NewobjImpl(ILGenerator ilgen)
d1372 1
a1372 1
		internal void EmitGet(ILGenerator ilgen)
d1378 1
a1378 1
		protected abstract void EmitGetImpl(ILGenerator ilgen);
d1380 1
a1380 1
		internal void EmitSet(ILGenerator ilgen)
d1386 1
a1386 1
		protected abstract void EmitSetImpl(ILGenerator ilgen);
d1498 1
a1498 1
		protected override void EmitGetImpl(ILGenerator ilgen)
d1511 1
a1511 1
		protected override void EmitSetImpl(ILGenerator ilgen)
d1540 1
a1540 1
		protected override void EmitGetImpl(ILGenerator ilgen)
d1566 1
a1566 1
		protected override void EmitSetImpl(ILGenerator ilgen)
d1646 1
a1646 1
		protected override void EmitGetImpl(ILGenerator ilgen)
d1661 1
a1661 1
		protected override void EmitSetImpl(ILGenerator ilgen)
d1780 1
a1780 1
		protected override void EmitGetImpl(CountingILGenerator ilgen)
d1796 1
a1796 1
		internal static void EmitThrowNoSuchMethodErrorForGetter(CountingILGenerator ilgen, TypeWrapper type, bool isStatic)
d1799 1
a1799 1
			CountingLabel label = ilgen.DefineLabel();
d1811 1
a1811 1
		protected override void EmitSetImpl(CountingILGenerator ilgen)
d1838 1
a1838 1
		internal static void EmitThrowNoSuchMethodErrorForSetter(CountingILGenerator ilgen, bool isStatic)
d1841 1
a1841 1
			CountingLabel label = ilgen.DefineLabel();
d1885 1
a1885 1
		protected override void EmitGetImpl(CountingILGenerator ilgen)
d1902 1
a1902 1
		protected override void EmitSetImpl(CountingILGenerator ilgen)
d1948 1
a1948 1
		protected override void EmitGetImpl(ILGenerator ilgen)
d2014 1
a2014 1
		protected override void EmitSetImpl(ILGenerator ilgen)
d2096 1
a2096 1
				ILGenerator ilgen = getter.GetILGenerator();
d2108 1
a2108 1
					ilgen = setter.GetILGenerator();
d2120 1
a2120 1
		protected override void EmitGetImpl(CountingILGenerator ilgen)
d2132 1
a2132 1
		protected override void EmitSetImpl(CountingILGenerator ilgen)
d2182 1
a2182 1
		protected override void EmitGetImpl(CountingILGenerator ilgen)
d2187 1
a2187 1
		protected override void EmitSetImpl(CountingILGenerator ilgen)
@


1.88
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@d870 1
a870 1
		private class NonvirtualInvokeHelper
@


1.87
log
@- added more efficient float/double to/from int/long bits converters
- made Double.doubleToRawLongBits/longBitsToDouble and Float.floatToRawIntBits/intBitsToFloat intrinsics
- generalized the intrinsics support
@
text
@d47 1
d214 8
d350 1
a350 1
#if !STATIC_COMPILER
d352 1
a352 1
			internal override object Invoke(object obj, object[] args, bool nonVirtual)
d358 1
a358 1
				return InvokeImpl(ghostMethod, wrapper, args, nonVirtual);
d602 6
a607 1
			Type[] temp = new Type[wrappers.Length];
d612 4
d713 13
a725 1
		internal virtual object Invoke(object obj, object[] args, bool nonVirtual)
d729 1
a729 1
			return InvokeImpl(method, obj, args, nonVirtual);
d747 1
a747 1
		private delegate object Invoker(IntPtr pFunc, object obj, object[] args);
d750 1
a750 1
		internal object InvokeImpl(MethodBase method, object obj, object[] args, bool nonVirtual)
d785 1
a785 1
							InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, null, args);
d831 2
a832 2
						InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, obj, args);
						return invoker(method.MethodHandle.GetFunctionPointer(), proc.GetObj(), proc.GetArgs());
d847 1
a847 1
				InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, obj, args);
d948 1
a948 1
				MethodBuilder methodBuilder = typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Static, typeof(object), new Type[] { typeof(IntPtr), typeof(object), typeof(object[]) });
d972 4
d1009 1
a1009 1
			internal InvokeArgsProcessor(MethodWrapper mw, MethodBase method, object original_obj, object[] original_args)
d1049 8
d1069 1
a1069 1
#endif // !STATIC_COMPILER
d1717 1
a1717 1
#if !STATIC_COMPILER
d1768 1
a1768 1
			return getter.Invoke(obj, new object[0], false);
d1777 1
a1777 1
			setter.Invoke(obj, new object[] { val }, false);
@


1.86
log
@Added support for turning Java fields into .NET properties with an annotation.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d46 1
d200 13
d390 4
@


1.85
log
@Ripped out annotation/constant pool support that is no longer needed.
@
text
@d44 2
a45 1
		InternalAccess = 32  // member has "internal" access (@@ikvm.lang.Internal)
d179 20
d1380 1
a1380 1
		internal void ResolveField()
d1628 249
@


1.84
log
@Replaced notion of DynamicOnly types with Fake types. Fake types are implemented as generic type instances and can have DynamicOnly methods.
@
text
@a366 76
#if OPENJDK
#if FIRST_PASS
		internal byte[] GetRawAnnotations()
		{
			return null;
		}

		internal byte[] GetRawParameterAnnotations()
		{
			return null;
		}

		internal byte[] GetRawAnnotationDefault()
		{
			return null;
		}
#else
		internal byte[] GetRawAnnotations()
		{
			object[] objAnn = this.DeclaringType.GetMethodAnnotations(this);
			byte[] annotations = null;
			if (objAnn != null)
			{
				ArrayList ann = new ArrayList();
				foreach (object obj in objAnn)
				{
					if (obj is java.lang.annotation.Annotation)
					{
						ann.Add(obj);
					}
				}
				ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
				annotations = ikvm.@@internal.stubgen.StubGenerator.writeAnnotations(cp, (java.lang.annotation.Annotation[])ann.ToArray(typeof(java.lang.annotation.Annotation)));
			}
			return annotations;
		}

		internal byte[] GetRawParameterAnnotations()
		{
			object[][] objParamAnn = this.DeclaringType.GetParameterAnnotations(this);
			byte[] parameterAnnotations = null;
			if (objParamAnn != null)
			{
				java.lang.annotation.Annotation[][] ann = new java.lang.annotation.Annotation[objParamAnn.Length][];
				for (int i = 0; i < objParamAnn.Length; i++)
				{
					ArrayList list = new ArrayList();
					foreach (object obj in objParamAnn[i])
					{
						if (obj is java.lang.annotation.Annotation)
						{
							list.Add(obj);
						}
					}
					ann[i] = (java.lang.annotation.Annotation[])list.ToArray(typeof(java.lang.annotation.Annotation));
				}
				ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
				parameterAnnotations = ikvm.@@internal.stubgen.StubGenerator.writeParameterAnnotations(cp, ann);
			}
			return parameterAnnotations;
		}

		internal byte[] GetRawAnnotationDefault()
		{
			byte[] annotationDefault = null;
			object objAnnDef = this.DeclaringType.GetAnnotationDefault(this);
			if (objAnnDef != null)
			{
				ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
				annotationDefault = ikvm.@@internal.stubgen.StubGenerator.writeAnnotationDefault(cp, objAnnDef);
			}
			return annotationDefault;
		}
#endif // !FIRST_PASS
#endif // OPENJDK

d396 2
a397 2
						GetRawAnnotations(),
						GetRawParameterAnnotations()
a1244 15
				object[] objAnn = this.DeclaringType.GetFieldAnnotations(this);
				byte[] annotations = null;
				if (objAnn != null)
				{
					ArrayList ann = new ArrayList();
					foreach (object obj in objAnn)
					{
						if (obj is java.lang.annotation.Annotation)
						{
							ann.Add(obj);
						}
					}
					ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
					annotations = ikvm.@@internal.stubgen.StubGenerator.writeAnnotations(cp, (java.lang.annotation.Annotation[])ann.ToArray(typeof(java.lang.annotation.Annotation)));
				}
d1252 1
a1252 1
					annotations
@


1.83
log
@Partial Trust fixes:
- Added accessor methods for "slot" to Method & Constructor.
- Implemented System.setIn0, setOut0, setErr0 in map.xml.
- Hacked sun.misc.SharedSecrets to replace Unsafe.ensureClassInitialize() with direct calls.
- Replaced java.nio.Bits.byteOrder() with simple System.BitConver.IsLittleEndian based implementation.
- Disabled DynamicMethodSupport when running in partial trust.
- Ignore SecurityException in CanonicalizePath.
- Don't trigger load of JNI assembly when "loading" a fake system library.
@
text
@d267 7
@


1.82
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@a237 2
		private static readonly FieldInfo methodSlotField = typeof(java.lang.reflect.Method).GetField("slot", BindingFlags.NonPublic | BindingFlags.Instance);
		private static readonly FieldInfo constructorSlotField = typeof(java.lang.reflect.Constructor).GetField("slot", BindingFlags.NonPublic | BindingFlags.Instance);
d524 1
a524 1
				return TypeWrapper.FromClass(method.getDeclaringClass()).GetMethods()[(int)methodSlotField.GetValue(method)];
d526 2
a527 1
			return TypeWrapper.FromClass(((java.lang.reflect.Constructor)methodOrConstructor).getDeclaringClass()).GetMethods()[(int)constructorSlotField.GetValue(methodOrConstructor)];
@


1.81
log
@Implemented support for InternalsVisibleToAttribute.
@
text
@d797 1
a797 1
							throw new java.lang.reflect.InvocationTargetException(JVM.Library.mapException(x.InnerException));
d841 1
a841 1
						throw new java.lang.reflect.InvocationTargetException(JVM.Library.mapException(x.InnerException));
d863 1
a863 1
				throw new java.lang.reflect.InvocationTargetException(JVM.Library.mapException(x.InnerException));
d1288 1
a1288 1
					return JVM.Library.box(val);
@


1.80
log
@Removed mono workarounds.
@
text
@d140 2
a141 2
					(IsInternal && caller.GetClassLoader() == DeclaringType.GetClassLoader()) ||
					(!IsPrivate && caller.IsInSamePackageAs(DeclaringType));
@


1.79
log
@Workaround the fact that Mono doesn't currently implement FieldInfo.GetRawConstantValue().
@
text
@d739 1
a739 16
				bool found = false;
				int token = ((MethodBuilder)method).GetToken().Token;
				ModuleBuilder module = (ModuleBuilder)((MethodBuilder)method).GetModule();
				foreach(MethodInfo mi in this.DeclaringType.TypeAsTBD.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance))
				{
					if(module.GetMethodToken(mi).Token == token)
					{
						found = true;
						method = mi;
						break;
					}
				}
				if(!found)
				{
					throw new InvalidOperationException("Failed to fixate method: " + this.DeclaringType.Name + "." + this.Name + this.Signature);
				}
d743 1
a743 16
				bool found = false;
				int token = ((ConstructorBuilder)method).GetToken().Token;
				ModuleBuilder module = (ModuleBuilder)((ConstructorBuilder)method).GetModule();
				foreach(ConstructorInfo ci in this.DeclaringType.TypeAsTBD.GetConstructors(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
				{
					if(module.GetConstructorToken(ci).Token == token)
					{
						found = true;
						method = ci;
						break;
					}
				}
				if(!found)
				{
					throw new InvalidOperationException("Failed to fixate constructor: " + this.DeclaringType.Name + "." + this.Name + this.Signature);
				}
d1272 1
a1272 9
					try
					{
						val = field.GetRawConstantValue();
					}
					catch(NotSupportedException)
					{
						// MONOBUG GetRawConstantValue() is not implemented on Mono 1.2.6
						val = field.GetValue(null);
					}
a1443 26
		private FieldInfo TokenBasedLookup(BindingFlags bindings, int token)
		{
			ModuleBuilder module = DeclaringType.GetClassLoader().GetTypeWrapperFactory().ModuleBuilder;
			foreach(FieldInfo f in DeclaringType.TypeAsTBD.GetFields(bindings))
			{
				if(module.GetFieldToken(f).Token == token)
				{
					return f;
				}
			}
			if(Type.GetType("Mono.Runtime") != null)
			{
				// MONOBUG token based lookup doesn't work on Mono 1.1.17,
				// so we'll try again but now do a name/type based comparison
				// (note that this is not water tight, because of erased types)
				foreach(FieldInfo f in DeclaringType.TypeAsTBD.GetFields(bindings))
				{
					if(f.Name == field.Name && f.FieldType.Equals(field.FieldType))
					{
						return f;
					}
				}
			}
			throw new InvalidOperationException();
		}

d1449 1
a1449 1
				field = DeclaringType.TypeAsTBD.Module.ResolveField(fb.GetToken().Token);
d1794 1
a1794 9
					try
					{
						constant = field.GetRawConstantValue();
					}
					catch(NotSupportedException)
					{
						// MONOBUG GetRawConstantValue() is not implemented on Mono 1.2.6
						constant = field.GetValue(null);
					}
@


1.78
log
@Removed more .NET 1.1 workarounds.
@
text
@d1302 9
a1310 1
					val = field.GetRawConstantValue();
d1858 9
a1866 1
					constant = field.GetRawConstantValue();
@


1.77
log
@More .NET 1.1 -> 2.0 work.
@
text
@a1247 56
	// This class tests if reflection on a constant field triggers the class constructor to run
	// (it shouldn't run, but on .NET 1.0 & 1.1 it does)
	sealed class ReflectionOnConstant
	{
		private static bool isBroken;
		private static System.Collections.Hashtable warnOnce;

		static ReflectionOnConstant()
		{
			typeof(Helper).GetField("foo", BindingFlags.NonPublic | BindingFlags.Static).GetValue(null);
		}

		internal static bool IsBroken
		{
			get
			{
				return isBroken;
			}
		}

		internal static void IssueWarning(FieldInfo field)
		{
#if !COMPACT_FRAMEWORK
			// FXBUG .NET (1.0 & 1.1)
			// FieldInfo.GetValue() on a literal causes the type initializer to run and
			// we don't want that.
			// TODO may need to find a workaround, for now we just spit out a warning
			if(ReflectionOnConstant.IsBroken && field.DeclaringType.TypeInitializer != null)
			{
				if(Tracer.FxBug.TraceWarning)
				{
					if(warnOnce == null)
					{
						warnOnce = new System.Collections.Hashtable();
					}
					if(!warnOnce.ContainsKey(field.DeclaringType.FullName))
					{
						warnOnce.Add(field.DeclaringType.FullName, null);
						Tracer.Warning(Tracer.FxBug, "Running type initializer for {0} due to CLR bug", field.DeclaringType.FullName);
					}
				}
			}
#endif // !COMPACT_FRAMEWORK
		}

		private class Helper
		{
			internal const int foo = 1;

			static Helper()
			{
				isBroken = true;
			}
		}
	}

a1301 1
					ReflectionOnConstant.IssueWarning(field);
@


1.76
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d1821 1
a1821 15
			if(DeclaringType.IsInterface)
			{
				if(DeclaringType.HasStaticInitializer)
				{
					// NOTE since Everett doesn't support adding static methods to interfaces,
					// EmitRunClassConstructor doesn't work for interface, so we do it manually.
					// TODO once we're on Whidbey, this won't be necessary anymore.
					ilgen.Emit(OpCodes.Ldtoken, DeclaringType.TypeAsBaseType);
					ilgen.Emit(OpCodes.Call, typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("RunClassConstructor"));
				}
			}
			else
			{
				DeclaringType.EmitRunClassConstructor(ilgen);
			}
@


1.75
log
@Fixed GetterFieldWrapper to support the DynamicMethod based fast reflection on CompiledTypeWrapper fields that don't have a FieldInfo object.
@
text
@a32 1
using IKVM.Runtime;
d906 1
a906 6
			private class KeyGen :
#if WHIDBEY
				IEqualityComparer
#else
				IHashCodeProvider, IComparer
#endif
a945 1
#if WHIDBEY
a946 3
#else
				cache = new Hashtable(keygen, keygen);
#endif
a1358 1
#if WHIDBEY
a1359 10
#else
					try
					{
						val = field.GetValue(null);
					}
					catch(TargetInvocationException x)
					{
						throw x.InnerException;
					}
#endif
a1561 1
#if WHIDBEY
a1562 29
#else
				// first do a name based lookup as that is much faster than doing a token based lookup
				BindingFlags bindings = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly;
				if(this.IsStatic)
				{
					bindings |= BindingFlags.Static;
				}
				else
				{
					bindings |= BindingFlags.Instance;
				}
				try
				{
					FieldInfo fi = DeclaringType.TypeAsTBD.GetField(field.Name, bindings);
					// now check that we've got the right field by comparing the tokens
					ModuleBuilder module = DeclaringType.GetClassLoader().GetTypeWrapperFactory().ModuleBuilder;
					if(module.GetFieldToken(fi).Token != fb.GetToken().Token)
					{
						fi = TokenBasedLookup(bindings, fb.GetToken().Token);
					}
					field = fi;
				}
				catch(AmbiguousMatchException)
				{
					// .NET 2.0 will throw this exception if there are multiple fields
					// with the same name (.NET 1.1 will simply return one of them)
					field = TokenBasedLookup(bindings, fb.GetToken().Token);
				}
#endif
a1907 1
#if WHIDBEY
a1922 3
#else // WHIDBEY
				constant = GetField().GetValue(null);
#endif // WHIDBEY
@


1.74
log
@Fix for bug #1802125.
@
text
@a1831 1
			FieldInfo fi = GetField();
d1839 13
a1851 1
			ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
@


1.73
log
@Implemented optimized reflection/serialization when running on .NET 2.0 (by generating DynamicMethods instead of using .NET reflection).
@
text
@d1554 1
a1554 1
			ModuleBuilder module = (ModuleBuilder)DeclaringType.TypeAsTBD.Module;
d1600 1
a1600 1
					ModuleBuilder module = (ModuleBuilder)DeclaringType.TypeAsTBD.Module;
@


1.72
log
@Made method annotation resolution lazy to support annotations that annotate themselves.
@
text
@d730 6
a776 1
			return InvokeImpl(method, obj, args, nonVirtual);
d1578 1
a1578 1
		private void LookupField()
d1621 1
a1621 1
			LookupField();
d1644 1
a1644 1
			LookupField();
@


1.71
log
@Added method name clash handling for AOT access stub methods.
@
text
@d363 76
a458 35
				object[] objAnn = this.DeclaringType.GetMethodAnnotations(this);
				byte[] annotations = null;
				if (objAnn != null)
				{
					ArrayList ann = new ArrayList();
					foreach (object obj in objAnn)
					{
						if (obj is java.lang.annotation.Annotation)
						{
							ann.Add(obj);
						}
					}
					ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
					annotations = ikvm.@@internal.stubgen.StubGenerator.writeAnnotations(cp, (java.lang.annotation.Annotation[])ann.ToArray(typeof(java.lang.annotation.Annotation)));
				}
				object[][] objParamAnn = this.DeclaringType.GetParameterAnnotations(this);
				byte[] parameterAnnotations = null;
				if (objParamAnn != null)
				{
					java.lang.annotation.Annotation[][] ann = new java.lang.annotation.Annotation[objParamAnn.Length][];
					for (int i = 0; i < objParamAnn.Length; i++)
					{
						ArrayList list = new ArrayList();
						foreach (object obj in objParamAnn[i])
						{
							if (obj is java.lang.annotation.Annotation)
							{
								list.Add(obj);
							}
						}
						ann[i] = (java.lang.annotation.Annotation[])list.ToArray(typeof(java.lang.annotation.Annotation));
					}
					ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
					parameterAnnotations = ikvm.@@internal.stubgen.StubGenerator.writeParameterAnnotations(cp, ann);
				}
d468 2
a469 2
						annotations,
						parameterAnnotations
a473 7
					byte[] annotationDefault = null;
					object objAnnDef = this.DeclaringType.GetAnnotationDefault(this);
					if (objAnnDef != null)
					{
						ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
						annotationDefault = ikvm.@@internal.stubgen.StubGenerator.writeAnnotationDefault(cp, objAnnDef);
					}
d483 3
a485 3
						annotations,
						parameterAnnotations,
						annotationDefault
@


1.71.2.1
log
@Ported fixes from trunk. Changed version to 0.36.0.1.
@
text
@a362 76
#if OPENJDK
#if FIRST_PASS
		internal byte[] GetRawAnnotations()
		{
			return null;
		}

		internal byte[] GetRawParameterAnnotations()
		{
			return null;
		}

		internal byte[] GetRawAnnotationDefault()
		{
			return null;
		}
#else
		internal byte[] GetRawAnnotations()
		{
			object[] objAnn = this.DeclaringType.GetMethodAnnotations(this);
			byte[] annotations = null;
			if (objAnn != null)
			{
				ArrayList ann = new ArrayList();
				foreach (object obj in objAnn)
				{
					if (obj is java.lang.annotation.Annotation)
					{
						ann.Add(obj);
					}
				}
				ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
				annotations = ikvm.@@internal.stubgen.StubGenerator.writeAnnotations(cp, (java.lang.annotation.Annotation[])ann.ToArray(typeof(java.lang.annotation.Annotation)));
			}
			return annotations;
		}

		internal byte[] GetRawParameterAnnotations()
		{
			object[][] objParamAnn = this.DeclaringType.GetParameterAnnotations(this);
			byte[] parameterAnnotations = null;
			if (objParamAnn != null)
			{
				java.lang.annotation.Annotation[][] ann = new java.lang.annotation.Annotation[objParamAnn.Length][];
				for (int i = 0; i < objParamAnn.Length; i++)
				{
					ArrayList list = new ArrayList();
					foreach (object obj in objParamAnn[i])
					{
						if (obj is java.lang.annotation.Annotation)
						{
							list.Add(obj);
						}
					}
					ann[i] = (java.lang.annotation.Annotation[])list.ToArray(typeof(java.lang.annotation.Annotation));
				}
				ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
				parameterAnnotations = ikvm.@@internal.stubgen.StubGenerator.writeParameterAnnotations(cp, ann);
			}
			return parameterAnnotations;
		}

		internal byte[] GetRawAnnotationDefault()
		{
			byte[] annotationDefault = null;
			object objAnnDef = this.DeclaringType.GetAnnotationDefault(this);
			if (objAnnDef != null)
			{
				ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter cp = IKVM.NativeCode.java.lang.Class.GetConstantPoolWriter(this.DeclaringType);
				annotationDefault = ikvm.@@internal.stubgen.StubGenerator.writeAnnotationDefault(cp, objAnnDef);
			}
			return annotationDefault;
		}
#endif // !FIRST_PASS
#endif // OPENJDK

d383 35
d427 2
a428 2
						GetRawAnnotations(),
						GetRawParameterAnnotations()
d433 7
d449 3
a451 3
						null,
						null,
						null
@


1.71.2.2
log
@Backported fixes from trunk. Changed version to 0.36.0.3.
@
text
@a729 6
			ResolveMethod();
			return InvokeImpl(method, obj, args, nonVirtual);
		}

		internal void ResolveMethod()
		{
d771 1
d1573 1
a1573 1
		internal void ResolveField()
d1616 1
a1616 1
			ResolveField();
d1639 1
a1639 1
			ResolveField();
@


1.71.2.3
log
@Backported fixes. Changed version to 0.36.0.4.
@
text
@d1554 1
a1554 1
			ModuleBuilder module = DeclaringType.GetClassLoader().GetTypeWrapperFactory().ModuleBuilder;
d1600 1
a1600 1
					ModuleBuilder module = DeclaringType.GetClassLoader().GetTypeWrapperFactory().ModuleBuilder;
@


1.71.2.4
log
@Backported fixes and changed version to 0.36.0.5
@
text
@d1832 1
d1840 1
a1840 13
			FieldInfo fi = GetField();
			if(fi != null)
			{
				// common case (we're in a DynamicTypeWrapper and the caller is too)
				ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
			}
			else
			{
				// this means that we are an instance on a CompiledTypeWrapper and we're being called
				// from DynamicMethod based reflection, so we can safely emit a call to the private
				// setter, because the DynamicMethod is allowed to access our private members.
				ilgen.Emit(OpCodes.Call, prop.GetSetMethod(true));
			}
@


1.71.2.5
log
@Backport: Volatile stores require a memory barrier. Fix for #3086040.
@
text
@a1694 4
			if(IsVolatile)
			{
				ilgen.Emit(OpCodes.Call, typeof(System.Threading.Thread).GetMethod("MemoryBarrier"));
			}
@


1.70
log
@Integrated OpenJDK's java.lang.reflect.* classes (except for Array).
@
text
@d1954 5
d1972 2
a1973 1
				PropertyBuilder pb = typeBuilder.DefineProperty(Name, PropertyAttributes.None, basefield.FieldTypeWrapper.TypeAsSignatureType, Type.EmptyTypes);
d1981 1
a1981 1
				getter = typeBuilder.DefineMethod("get_" + Name, attribs, basefield.FieldTypeWrapper.TypeAsSignatureType, Type.EmptyTypes);
d1993 1
a1993 1
					setter = typeBuilder.DefineMethod("set_" + Name, attribs, null, new Type[] { basefield.FieldTypeWrapper.TypeAsSignatureType });
@


1.69
log
@Changed to avoid warnings when compiled on .NET 2.0
@
text
@d50 3
d238 5
d362 140
d1277 4
d1363 66
@


1.68
log
@Simplified VM -> Class Library interface by taking advantage of the fact that IKVM.Runtime.dll is now compiled in two passes with the second pass linking against the class library.
@
text
@d720 6
a725 1
			private class KeyGen : IHashCodeProvider, IComparer
d733 5
d765 3
d769 1
@


1.67
log
@Fixed several .NET 2.0 "ReflectionOnly" bugs.
@
text
@d597 1
d621 1
a621 1
							throw JavaException.IncompatibleClassChangeError("Remapped type {0} doesn't support constructor invocation on an existing instance", DeclaringType.Name);
d637 1
a637 1
							throw JavaException.IllegalArgumentException(x1.Message);
d641 1
a641 1
							throw JavaException.InvocationTargetException(JVM.Library.mapException(x.InnerException));
d681 1
a681 1
						throw JavaException.IllegalArgumentException(x1.Message);
d685 1
a685 1
						throw JavaException.InvocationTargetException(JVM.Library.mapException(x.InnerException));
d703 1
a703 1
				throw JavaException.IllegalArgumentException(x1.Message);
d707 1
a707 1
				throw JavaException.InvocationTargetException(JVM.Library.mapException(x.InnerException));
d709 3
d1363 3
a1365 1
				throw JavaException.IllegalAccessException(x.Message);
@


1.66
log
@Fixed workaround for Mono bug (lack of proper token support in reflection emit api)
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d1171 2
a1172 1
					if(val is Enum)
d1174 1
a1174 1
						val = DotNetTypeWrapper.EnumValueFieldWrapper.GetEnumPrimitiveValue(val);
a1175 1
#endif
d1179 5
a1183 11
#if WHIDBEY
					// TODO
#else
					// In Java, instance fields can also have a ConstantValue attribute so we emulate that
					// with ConstantValueAttribute (for consumption by ikvmstub only)
					object[] attrib = field.GetCustomAttributes(typeof(ConstantValueAttribute), false);
					if(attrib.Length == 1)
					{
						val = ((ConstantValueAttribute)attrib[0]).GetConstantValue();
					}
#endif
d1671 17
d1689 1
@


1.65
log
@Fixed AmbiguousMatchException on .NET 2.0 when looking up field that has sibling field with same name but different type.
@
text
@d1300 1
a1300 1
					if(f.Name == field.Name && f.FieldType == field.FieldType)
@


1.64
log
@*** empty log message ***
@
text
@d1314 4
a1317 1
				// first do a name based lookup
d1327 12
a1338 4
				FieldInfo fi = DeclaringType.TypeAsTBD.GetField(field.Name, bindings);
				// now check that we've got the right field by comparing the tokens
				ModuleBuilder module = (ModuleBuilder)DeclaringType.TypeAsTBD.Module;
				if(module.GetFieldToken(fi).Token != fb.GetToken().Token)
d1340 3
a1342 1
					fi = TokenBasedLookup(bindings, fb.GetToken().Token);
d1344 1
a1344 1
				field = fi;
@


1.63
log
@*** empty log message ***
@
text
@d363 1
a363 1
				return method != null;
@


1.62
log
@*** empty log message ***
@
text
@a42 1
		LiteralField = 4,
a159 13
		internal bool IsLiteralField
		{
			get
			{
				return (flags & MemberFlags.LiteralField) != 0;
			}
			set
			{
				flags &= ~MemberFlags.LiteralField;
				flags |= value ? MemberFlags.LiteralField : MemberFlags.None;
			}
		}

d1126 1
a1126 1
					(modifiers.IsInternal ? MemberFlags.InternalAccess : MemberFlags.None) | (field != null && field.IsLiteral ? MemberFlags.LiteralField : MemberFlags.None))
a1331 2
				// HACK this is racy, but we need to get rid of it anyway
				this.IsLiteralField = field.IsLiteral;
a1363 8
			// FieldInfo.IsLiteral is expensive, so we have our own flag
			// TODO we might be able to ensure that we always use ConstantFieldWrapper for literal fields,
			// in that case the we could simply remove the check altogether.
			if(IsLiteralField)
			{
				// on a non-broken CLR GetValue on a literal will not trigger type initialization, but on Java it should
				DeclaringType.RunClassInit();
			}
d1596 1
a1596 1
			object v = GetValue(null);
d1660 1
a1660 2

		internal override object GetValue(object obj)
d1668 7
d1694 1
a1694 1
			if(basefield.IsLiteralField)
d1700 1
a1700 1
				fb.SetConstant(basefield.GetValue(null));
d1741 1
a1741 1
			if(basefield.IsLiteralField)
@


1.61
log
@*** empty log message ***
@
text
@d1297 1
a1297 1
		private FieldInfo TokenBasedLookup(int token)
d1299 1
d1343 1
a1343 1
					fi = TokenBasedLookup(fb.GetToken().Token);
@


1.60
log
@*** empty log message ***
@
text
@d1297 1
a1297 1
		private void LookupField()
d1299 8
a1306 2
			BindingFlags bindings = BindingFlags.Public | BindingFlags.NonPublic;
			if(IsStatic)
d1308 10
a1317 1
				bindings |= BindingFlags.Static;
d1319 7
a1325 1
			else
d1327 20
a1346 1
				bindings |= BindingFlags.Instance;
a1347 4
			// TODO instead of looking up the field by name, we should use the Token to find it.
			field = DeclaringType.TypeAsTBD.GetField(Name, bindings);
			this.IsLiteralField = field.IsLiteral;
			Debug.Assert(field != null);
d1354 1
a1354 5
			// TODO this is a broken implementation (for one thing, it needs to support redirection)
			if(field == null || field is FieldBuilder)
			{
				LookupField();
			}
d1375 1
a1375 5
			// TODO this is a broken implementation (for one thing, it needs to support redirection)
			if(field == null || field is FieldBuilder)
			{
				LookupField();
			}
d1525 10
@


1.59
log
@*** empty log message ***
@
text
@d768 2
a769 2
				AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, DynamicClassLoader.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
				if(DynamicClassLoader.IsSaveDebugImage)
@


1.58
log
@*** empty log message ***
@
text
@d139 1
a139 1
					(IsInternal && caller.Assembly == DeclaringType.Assembly) ||
@


1.57
log
@*** empty log message ***
@
text
@d475 4
a478 3
			if(method != null
#if !COMPACT_FRAMEWORK
				&& !(method is MethodBuilder)
a479 1
				)
@


1.56
log
@*** empty log message ***
@
text
@d266 6
a271 1
		internal virtual void EmitNewobj(ILGenerator ilgen)
d972 1
a972 1
		internal sealed override void EmitNewobj(ILGenerator ilgen)
@


1.55
log
@*** empty log message ***
@
text
@d649 1
a649 1
							throw JavaException.InvocationTargetException(IKVM.Runtime.Util.MapException(x.InnerException));
d693 1
a693 1
						throw JavaException.InvocationTargetException(IKVM.Runtime.Util.MapException(x.InnerException));
d715 1
a715 1
				throw JavaException.InvocationTargetException(IKVM.Runtime.Util.MapException(x.InnerException));
@


1.54
log
@*** empty log message ***
@
text
@d1475 1
d1478 1
a1478 1
		internal GetterFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, ExModifiers modifiers, MethodInfo getter)
d1484 1
d1492 18
@


1.53
log
@*** empty log message ***
@
text
@d617 1
a617 1
				if(ReferenceEquals(Name, "<init>"))
@


1.52
log
@*** empty log message ***
@
text
@d1172 8
a1179 1
					val = field.GetValue(null);
@


1.51
log
@*** empty log message ***
@
text
@a1399 5
		private static MethodInfo volatileReadDouble = typeof(IKVM.Runtime.ByteCodeHelper).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Double&") });
		private static MethodInfo volatileReadLong = typeof(IKVM.Runtime.ByteCodeHelper).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Int64&") });
		private static MethodInfo volatileWriteDouble = typeof(IKVM.Runtime.ByteCodeHelper).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Double&"), typeof(double) });
		private static MethodInfo volatileWriteLong = typeof(IKVM.Runtime.ByteCodeHelper).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Int64&"), typeof(long) });

d1425 1
a1425 1
				ilgen.Emit(OpCodes.Call, volatileReadDouble);
d1430 1
a1430 1
				ilgen.Emit(OpCodes.Call, volatileReadLong);
d1454 1
a1454 1
				ilgen.Emit(OpCodes.Call, volatileWriteDouble);
d1459 1
a1459 1
				ilgen.Emit(OpCodes.Call, volatileWriteLong);
@


1.50
log
@*** empty log message ***
@
text
@d476 2
a477 2
				object[] attributes = method.GetCustomAttributes(typeof(ThrowsAttribute), false);
				if(attributes.Length == 1)
d479 1
a479 1
					return ((ThrowsAttribute)attributes[0]).Classes;
@


1.49
log
@*** empty log message ***
@
text
@d470 5
a474 1
			if(method != null && !(method is MethodBuilder))
d557 1
d597 1
d606 1
d608 1
d1084 1
d1104 1
@


1.48
log
@*** empty log message ***
@
text
@d1390 4
a1393 4
		private static MethodInfo volatileReadDouble = typeof(System.Threading.Thread).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Double&") });
		private static MethodInfo volatileReadLong = typeof(System.Threading.Thread).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Int64&") });
		private static MethodInfo volatileWriteDouble = typeof(System.Threading.Thread).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Double&"), typeof(double) });
		private static MethodInfo volatileWriteLong = typeof(System.Threading.Thread).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Int64&"), typeof(long) });
@


1.47
log
@*** empty log message ***
@
text
@a471 13
#if WHIDBEY && !COMPACT_FRAMEWORK
				if(JVM.IsIkvmStub)
				{
					foreach(CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(method))
					{
						if(cad.Constructor.DeclaringType == StaticCompiler.GetType(typeof(ThrowsAttribute).FullName))
						{
							return AttributeHelper.DecodeArray<string>(cad.ConstructorArguments[0]);
						}
					}
					return new string[0];
				}
#endif
@


1.46
log
@*** empty log message ***
@
text
@d380 12
d395 2
a396 5
					ClassLoaderWrapper loader = this.DeclaringType.GetClassLoader();
					// TODO we need to use the actual classCache here
					System.Collections.Hashtable classCache = new System.Collections.Hashtable();
					returnTypeWrapper = ClassFile.RetTypeWrapperFromSig(loader, classCache, Signature);
					parameterTypeWrappers = ClassFile.ArgTypeWrapperListFromSig(loader, classCache, Signature);
d1242 10
d1254 1
a1254 3
					// TODO we need to use the actual classCache here
					System.Collections.Hashtable classCache = new System.Collections.Hashtable();
					fieldType = ClassFile.FieldTypeWrapperFromSig(this.DeclaringType.GetClassLoader(), classCache, Signature);
@


1.45
log
@*** empty log message ***
@
text
@d613 1
a613 1
				if(Name == "<init>")
@


1.44
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
d303 1
d313 1
d552 1
d898 1
d1149 1
d1195 1
d1288 1
d1312 1
d1322 3
d1339 1
d1694 1
d1706 1
d1750 1
d1762 1
@


1.43
log
@*** empty log message ***
@
text
@d45 2
a46 1
		AccessStub = 16
d139 1
d206 8
d1123 3
a1125 2
		internal FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field)
			: this(declaringType, fieldType, name, sig, modifiers, field, field != null && field.IsLiteral ? MemberFlags.LiteralField : MemberFlags.None)
d1255 1
a1255 1
		internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers)
d1258 1
a1258 1
			if((modifiers & Modifiers.Volatile) != 0 && (sig == "J" || sig == "D"))
d1333 1
a1333 1
		internal SimpleFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers)
d1379 1
a1379 1
		internal VolatileLongDoubleFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers)
d1449 1
a1449 1
		internal GetterFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers, MethodInfo getter)
@


1.42
log
@*** empty log message ***
@
text
@d746 2
a747 2
				AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, ClassLoaderWrapper.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
				if(ClassLoaderWrapper.IsSaveDebugImage)
d750 1
a750 1
					ClassLoaderWrapper.RegisterForSaveDebug(ab);
@


1.41
log
@*** empty log message ***
@
text
@d1498 15
a1512 1
			DeclaringType.EmitRunClassConstructor(ilgen);
@


1.40
log
@*** empty log message ***
@
text
@d451 13
d1147 3
d1155 1
d1159 3
d1169 1
@


1.39
log
@*** empty log message ***
@
text
@d27 1
d29 2
a34 2
using ILGenerator = IKVM.Internal.CountingILGenerator;

d245 1
d260 1
d285 1
d291 1
d648 3
d665 1
d689 1
d813 1
d873 1
d888 1
d898 1
d951 1
d973 1
d983 1
d998 1
d1008 1
d1018 1
d1028 1
d1173 1
d1189 1
d1307 1
d1337 1
d1354 1
d1409 1
d1430 1
d1458 1
d1472 1
d1545 1
d1557 1
d1648 1
d1678 1
d1688 1
@


1.38
log
@*** empty log message ***
@
text
@d477 1
a477 1
			MethodAttributes attribs = 0;
d1555 1
@


1.37
log
@*** empty log message ***
@
text
@d1445 4
@


1.36
log
@Fixed bug 1257044.
@
text
@d1537 1
@


1.35
log
@*** empty log message ***
@
text
@d43 2
a44 1
		MirandaMethod = 8
d53 2
d56 1
a56 1
		protected MemberWrapper(TypeWrapper declaringType, Modifiers modifiers, MemberFlags flags)
d60 2
d114 16
d179 8
a238 2
		private string name;
		private string sig;
d328 1
a328 1
			: base(declaringType, modifiers, flags)
a330 2
			this.name = String.Intern(name);
			this.sig = String.Intern(sig);
a350 16
		internal string Name
		{
			get
			{
				return name;
			}
		}

		internal string Signature
		{
			get
			{
				return sig;
			}
		}

d369 2
a370 2
					returnTypeWrapper = ClassFile.RetTypeWrapperFromSig(loader, classCache, sig);
					parameterTypeWrappers = ClassFile.ArgTypeWrapperListFromSig(loader, classCache, sig);
d499 1
a499 1
			if(!IsStatic && !IsPrivate && name != "<init>")
d582 1
a582 1
				if(name == "<init>")
a723 2
				// the stack walker needs access to this assembly to be able to quickly check for non-virtual invoke frames
				IKVM.NativeCode.gnu.classpath.VMStackWalker.nonVirtualInvokeAssembly = ab;
d754 1
a1066 2
		private string name;
		private string sig;
d1070 2
a1071 2
		internal FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field)
			: base(declaringType, modifiers, field != null && field.IsLiteral ? MemberFlags.LiteralField : MemberFlags.None)
a1074 2
			this.name = String.Intern(name);
			this.sig = String.Intern(sig);
d1079 5
d1095 1
a1095 1
				Tracer.Error(Tracer.Runtime, "AssertLinked failed: " + this.DeclaringType.Name + "::" + this.name + " (" + this.sig + ")");
d1097 1
a1097 1
			Debug.Assert(fieldType != null, this.DeclaringType.Name + "::" + this.name + " (" + this.sig+ ")");
a1142 16
		internal string Name
		{
			get
			{
				return name;
			}
		}

		internal string Signature
		{
			get
			{
				return sig;
			}
		}

d1176 1
a1176 1
					fieldType = ClassFile.FieldTypeWrapperFromSig(this.DeclaringType.GetClassLoader(), classCache, sig);
d1222 1
a1222 1
			field = DeclaringType.TypeAsTBD.GetField(name, bindings);
d1436 2
a1437 2
		internal ConstantFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, object constant)
			: base(declaringType, fieldType, name, sig, modifiers, field)
d1521 140
@


1.34
log
@*** empty log message ***
@
text
@d1309 1
a1309 1
				LocalBuilder temp = ilgen.DeclareLocal(fi.FieldType);
d1351 1
a1351 1
			if(fi.FieldType == typeof(double))
d1357 1
a1357 1
				Debug.Assert(fi.FieldType == typeof(long));
d1365 1
a1365 1
			LocalBuilder temp = ilgen.DeclareLocal(fi.FieldType);
d1380 1
a1380 1
			if(fi.FieldType == typeof(double))
d1386 1
a1386 1
				Debug.Assert(fi.FieldType == typeof(long));
d1430 1
a1430 1
				LocalBuilder temp = ilgen.DeclareLocal(fi.FieldType);
@


1.33
log
@*** empty log message ***
@
text
@d304 2
a305 2
			this.name = name;
			this.sig = sig;
d1069 2
a1070 2
			this.name = name;
			this.sig = sig;
@


1.32
log
@*** empty log message ***
@
text
@a29 1
using IKVM.Internal;
d32 1
a32 1
using ILGenerator = CountingILGenerator;
d34 1
a34 2
[Flags]
enum MemberFlags : short
d36 9
a44 6
	None = 0,
	HideFromReflection = 1,
	ExplicitOverride = 2,
	LiteralField = 4,
	MirandaMethod = 8
}
d46 6
a51 6
class MemberWrapper
{
	private System.Runtime.InteropServices.GCHandle handle;
	private TypeWrapper declaringType;
	private Modifiers modifiers;
	private MemberFlags flags;
d53 7
a59 7
	protected MemberWrapper(TypeWrapper declaringType, Modifiers modifiers, MemberFlags flags)
	{
		Debug.Assert(declaringType != null);
		this.declaringType = declaringType;
		this.modifiers = modifiers;
		this.flags = flags;
	}
d61 1
a61 1
	// NOTE since we don't support unloading code, there is no need to have a finalizer
d81 1
a81 3
	internal IntPtr Cookie
	{
		get
d83 1
a83 1
			lock(this)
d85 1
a85 1
				if(!handle.IsAllocated)
d87 4
a90 1
					handle = System.Runtime.InteropServices.GCHandle.Alloc(this, System.Runtime.InteropServices.GCHandleType.Weak);
d92 1
a93 1
			return (IntPtr)handle;
a94 6
	}

	internal static MemberWrapper FromCookieImpl(IntPtr cookie)
	{
		return (MemberWrapper)((System.Runtime.InteropServices.GCHandle)cookie).Target;
	}
d96 1
a96 3
	internal TypeWrapper DeclaringType
	{
		get
d98 1
a98 1
			return declaringType;
a99 1
	}
d101 1
a101 3
	internal bool IsAccessibleFrom(TypeWrapper referencedType, TypeWrapper caller, TypeWrapper instance)
	{
		if(referencedType.IsAccessibleFrom(caller))
d103 4
a106 4
			return IsPublic ||
				caller == DeclaringType ||
				(IsProtected && caller.IsSubTypeOf(DeclaringType) && (IsStatic || instance.IsSubTypeOf(caller))) ||
				(!IsPrivate && caller.IsInSamePackageAs(DeclaringType));
a107 2
		return false;
	}
d109 1
a109 3
	internal bool IsHideFromReflection
	{
		get
d111 8
a118 1
			return (flags & MemberFlags.HideFromReflection) != 0;
a119 1
	}
d121 1
a121 3
	internal bool IsExplicitOverride
	{
		get
d123 4
a126 1
			return (flags & MemberFlags.ExplicitOverride) != 0;
a127 1
	}
d129 1
a129 3
	internal bool IsLiteralField
	{
		get
d131 4
a134 1
			return (flags & MemberFlags.LiteralField) != 0;
d136 2
a137 1
		set
d139 9
a147 2
			flags &= ~MemberFlags.LiteralField;
			flags |= value ? MemberFlags.LiteralField : MemberFlags.None;
a148 1
	}
d150 1
a150 3
	internal bool IsMirandaMethod
	{
		get
d152 4
a155 1
			return (flags & MemberFlags.MirandaMethod) != 0;
a156 1
	}
d158 1
a158 3
	internal Modifiers Modifiers
	{
		get
d160 4
a163 1
			return modifiers;
a164 1
	}
d166 1
a166 3
	internal bool IsStatic
	{
		get
d168 4
a171 1
			return (modifiers & Modifiers.Static) != 0;
a172 1
	}
d174 1
a174 3
	internal bool IsPublic
	{
		get
d176 4
a179 1
			return (modifiers & Modifiers.Public) != 0;
a180 1
	}
d182 1
a182 3
	internal bool IsPrivate
	{
		get
d184 4
a187 1
			return (modifiers & Modifiers.Private) != 0;
a188 1
	}
d190 1
a190 3
	internal bool IsProtected
	{
		get
d192 4
a195 1
			return (modifiers & Modifiers.Protected) != 0;
a196 1
	}
d198 1
a198 3
	internal bool IsFinal
	{
		get
d200 4
a203 1
			return (modifiers & Modifiers.Final) != 0;
a205 1
}
d207 1
a207 11
abstract class MethodWrapper : MemberWrapper
{
	internal static readonly MethodWrapper[] EmptyArray  = new MethodWrapper[0];
	private string name;
	private string sig;
	private MethodBase method;
	private string[] declaredExceptions;
	private TypeWrapper returnTypeWrapper;
	private TypeWrapper[] parameterTypeWrappers;

	internal virtual void EmitCall(ILGenerator ilgen)
d209 7
a215 2
		throw new InvalidOperationException();
	}
d217 4
a220 4
	internal virtual void EmitCallvirt(ILGenerator ilgen)
	{
		throw new InvalidOperationException();
	}
d222 4
a225 8
	internal virtual void EmitNewobj(ILGenerator ilgen)
	{
		throw new InvalidOperationException();
	}

	internal class GhostMethodWrapper : SmartMethodWrapper
	{
		private MethodInfo ghostMethod;
d227 1
a227 2
		internal GhostMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
d229 1
a229 2
			// make sure we weren't handed the ghostMethod in the wrapper value type
			Debug.Assert(method == null || method.DeclaringType.IsInterface);
d232 1
a232 1
		private void ResolveGhostMethod()
d234 10
a243 1
			if(ghostMethod == null)
a244 1
				ghostMethod = DeclaringType.TypeAsSignatureType.GetMethod(this.Name, this.GetParametersForDefineMethod());
d247 5
a251 1
					throw new InvalidOperationException("Unable to resolve ghost method");
a253 1
		}
d255 5
a259 5
		protected override void CallvirtImpl(ILGenerator ilgen)
		{
			ResolveGhostMethod();
			ilgen.Emit(OpCodes.Call, ghostMethod);
		}
d261 5
a265 5
		[HideFromJava]
		internal override object Invoke(object obj, object[] args, bool nonVirtual)
		{
			object wrapper = Activator.CreateInstance(DeclaringType.TypeAsSignatureType);
			DeclaringType.GhostRefField.SetValue(wrapper, obj);
d267 3
a269 2
			ResolveGhostMethod();
			return InvokeImpl(ghostMethod, wrapper, args, nonVirtual);
a270 1
	}
d272 3
a274 3
	internal static MethodWrapper Create(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
	{
		Debug.Assert(declaringType != null && name!= null && sig != null && method != null);
d276 1
a276 4
		if(declaringType.IsGhost)
		{
			// HACK since our caller isn't aware of the ghost issues, we'll handle the method swapping
			if(method.DeclaringType.IsValueType)
d278 2
a279 2
				Type[] types = new Type[parameterTypes.Length];
				for(int i = 0; i < types.Length; i++)
d281 6
a286 1
					types[i] = parameterTypes[i].TypeAsSignatureType;
d288 9
a296 1
				method = declaringType.TypeAsBaseType.GetMethod(method.Name, types);
a297 1
			return new GhostMethodWrapper(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags);
d299 3
a301 1
		else if(method is ConstructorInfo)
d303 7
a309 1
			return new SmartConstructorMethodWrapper(declaringType, name, sig, (ConstructorInfo)method, parameterTypes, modifiers, flags);
d311 2
a312 1
		else
d314 5
a318 1
			return new SmartCallMethodWrapper(declaringType, name, sig, (MethodInfo)method, returnType, parameterTypes, modifiers, flags, SimpleOpCode.Call, method.IsStatic ? SimpleOpCode.Call : SimpleOpCode.Callvirt);
a319 13
	}

	internal MethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
		: base(declaringType, modifiers, flags)
	{
		Profiler.Count("MethodWrapper");
		this.name = name;
		this.sig = sig;
		this.method = method;
		Debug.Assert(((returnType == null) == (parameterTypes == null)) || (returnType == PrimitiveTypeWrapper.VOID));
		this.returnTypeWrapper = returnType;
		this.parameterTypeWrappers = parameterTypes;
	}
d321 1
a321 3
	internal void SetDeclaredExceptions(string[] exceptions)
	{
		if(exceptions == null)
d323 1
a323 1
			exceptions = new string[0];
a324 7
		this.declaredExceptions = (string[])exceptions.Clone();
	}

	internal static MethodWrapper FromCookie(IntPtr cookie)
	{
		return (MethodWrapper)FromCookieImpl(cookie);
	}
d326 1
a326 3
	internal string Name
	{
		get
d328 4
a331 1
			return name;
a332 1
	}
d334 1
a334 3
	internal string Signature
	{
		get
d336 4
a339 1
			return sig;
a340 1
	}
d342 1
a342 3
	internal bool IsLinked
	{
		get
d344 4
a347 1
			return method != null;
a348 1
	}
d350 1
a350 3
	internal void Link()
	{
		lock(this)
d352 1
a352 1
			if(parameterTypeWrappers == null)
d354 1
a354 7
				Debug.Assert(returnTypeWrapper == null || returnTypeWrapper == PrimitiveTypeWrapper.VOID);
				ClassLoaderWrapper loader = this.DeclaringType.GetClassLoader();
				// TODO we need to use the actual classCache here
				System.Collections.Hashtable classCache = new System.Collections.Hashtable();
				returnTypeWrapper = ClassFile.RetTypeWrapperFromSig(loader, classCache, sig);
				parameterTypeWrappers = ClassFile.ArgTypeWrapperListFromSig(loader, classCache, sig);
				if(method == null)
d356 7
a362 1
					try
d364 12
a375 9
						method = this.DeclaringType.LinkMethod(this);
					}
					catch
					{
						// HACK if linking fails, we unlink to make sure
						// that the next link attempt will fail again
						returnTypeWrapper = null;
						parameterTypeWrappers = null;
						throw;
a379 1
	}
d381 2
a382 4
	[Conditional("DEBUG")]
	internal void AssertLinked()
	{
		if(!(parameterTypeWrappers != null && returnTypeWrapper != null))
d384 5
a388 1
			Tracer.Error(Tracer.Runtime, "AssertLinked failed: " + this.DeclaringType.Name + "::" + this.Name + this.Signature);
a389 2
		Debug.Assert(parameterTypeWrappers != null && returnTypeWrapper != null, this.DeclaringType.Name + "::" + this.Name + this.Signature);
	}
d391 1
a391 3
	internal TypeWrapper ReturnType
	{
		get
d393 5
a397 2
			AssertLinked();
			return returnTypeWrapper;
a398 7
	}

	internal TypeWrapper[] GetParameters()
	{
		AssertLinked();
		return parameterTypeWrappers;
	}
d400 1
a400 3
	internal Type ReturnTypeForDefineMethod
	{
		get
d402 2
a403 1
			return ReturnType.TypeAsSignatureType;
a404 1
	}
d406 1
a406 5
	internal Type[] GetParametersForDefineMethod()
	{
		TypeWrapper[] wrappers = GetParameters();
		Type[] temp = new Type[wrappers.Length];
		for(int i = 0; i < wrappers.Length; i++)
d408 4
a411 1
			temp[i] = wrappers[i].TypeAsSignatureType;
a412 2
		return temp;
	}
d414 1
a414 4
	internal string[] GetExceptions()
	{
		// remapped types and dynamically compiled types have declaredExceptions set
		if(declaredExceptions != null)
d416 7
a422 1
			return (string[])declaredExceptions.Clone();
d424 2
a425 4
		// NOTE if method is a MethodBuilder, GetCustomAttributes doesn't work (and if
		// the method had any declared exceptions, the declaredExceptions field would have
		// been set)
		if(method != null && !(method is MethodBuilder))
d427 9
a435 2
			object[] attributes = method.GetCustomAttributes(typeof(ThrowsAttribute), false);
			if(attributes.Length == 1)
d437 5
a441 1
				return ((ThrowsAttribute)attributes[0]).Classes;
d443 1
a444 2
		return new string[0];
	}
d446 5
a450 13
	// we expose the underlying MethodBase object,
	// for Java types, this is the method that contains the compiled Java bytecode
	// for remapped types, this is the mbCore method (not the helper)
	// Note that for some artificial methods (notably wrap() in enums), method is null
	internal MethodBase GetMethod()
	{
		AssertLinked();
		return method;
	}

	internal string RealName
	{
		get
d453 1
a453 1
			return method.Name;
a454 1
	}
d456 1
a456 5
	// this returns the Java method's attributes in .NET terms (e.g. used to create stubs for this method)
	internal MethodAttributes GetMethodAttributes()
	{
		MethodAttributes attribs = 0;
		if(IsStatic)
d458 5
a462 17
			attribs |= MethodAttributes.Static;
		}
		if(IsPublic)
		{
			attribs |= MethodAttributes.Public;
		}
		else if(IsPrivate)
		{
			attribs |= MethodAttributes.Private;
		}
		else if(IsProtected)
		{
			attribs |= MethodAttributes.FamORAssem;
		}
		else
		{
			attribs |= MethodAttributes.Family;
a463 15
		// constructors aren't virtual
		if(!IsStatic && !IsPrivate && name != "<init>")
		{
			attribs |= MethodAttributes.Virtual;
		}
		if(IsFinal)
		{
			attribs |= MethodAttributes.Final;
		}
		if(IsAbstract)
		{
			attribs |= MethodAttributes.Abstract;
		}
		return attribs;
	}
d465 2
a466 3
	internal bool IsAbstract
	{
		get
d468 18
a485 15
			return (Modifiers & Modifiers.Abstract) != 0;
		}
	}

	[HideFromJava]
	internal virtual object Invoke(object obj, object[] args, bool nonVirtual)
	{
		AssertLinked();
		// if we've still got the builder object, we need to replace it with the real thing before we can call it
		if(method is MethodBuilder)
		{
			bool found = false;
			int token = ((MethodBuilder)method).GetToken().Token;
			ModuleBuilder module = (ModuleBuilder)((MethodBuilder)method).GetModule();
			foreach(MethodInfo mi in this.DeclaringType.TypeAsTBD.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance))
d487 1
a487 6
				if(module.GetMethodToken(mi).Token == token)
				{
					found = true;
					method = mi;
					break;
				}
d489 2
a490 1
			if(!found)
d492 1
a492 1
				throw new InvalidOperationException("Failed to fixate method: " + this.DeclaringType.Name + "." + this.Name + this.Signature);
d494 1
a494 7
		}
		if(method is ConstructorBuilder)
		{
			bool found = false;
			int token = ((ConstructorBuilder)method).GetToken().Token;
			ModuleBuilder module = (ModuleBuilder)((ConstructorBuilder)method).GetModule();
			foreach(ConstructorInfo ci in this.DeclaringType.TypeAsTBD.GetConstructors(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
d496 1
a496 6
				if(module.GetConstructorToken(ci).Token == token)
				{
					found = true;
					method = ci;
					break;
				}
d498 1
a498 1
			if(!found)
d500 1
a500 1
				throw new InvalidOperationException("Failed to fixate constructor: " + this.DeclaringType.Name + "." + this.Name + this.Signature);
d502 1
a503 9
		return InvokeImpl(method, obj, args, nonVirtual);
	}

	private delegate object Invoker(IntPtr pFunc, object obj, object[] args);

	[HideFromJava]
	internal object InvokeImpl(MethodBase method, object obj, object[] args, bool nonVirtual)
	{
		Debug.Assert(!(method is MethodBuilder || method is ConstructorBuilder));
d505 1
a505 1
		if(IsStatic)
d507 4
a510 2
			// Java allows bogus 'obj' to be specified for static methods
			obj = null;
d512 3
a514 1
		else
d516 3
a518 1
			if(name == "<init>")
d520 4
a523 14
				if(method is MethodInfo)
				{
					Debug.Assert(method.IsStatic);
					// we're dealing with a constructor on a remapped type, if obj is supplied, it means
					// that we should call the constructor on an already existing instance, but that isn't
					// possible with remapped types
					if(obj != null)
					{
						// the type of this exception is a bit random (note that this can only happen through JNI reflection or
						// if there is a bug in serialization [which uses the ObjectInputStream.callConstructor() in classpath.cs)
						throw JavaException.IncompatibleClassChangeError("Remapped type {0} doesn't support constructor invocation on an existing instance", DeclaringType.Name);
					}
				}
				else if(obj == null)
d525 1
a525 14
					// calling <init> without an instance means that we're constructing a new instance
					// NOTE this means that we cannot detect a NullPointerException when calling <init> (does JNI require this?)
					try
					{
						InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, null, args);
						object o = ((ConstructorInfo)method).Invoke(proc.GetArgs());
						// since we just constructed an instance, it can't possibly be a ghost
						return o;
					}
					catch(ArgumentException x1)
					{
						throw JavaException.IllegalArgumentException(x1.Message);
					}
					catch(TargetInvocationException x)
d527 3
a529 1
						throw JavaException.InvocationTargetException(IKVM.Runtime.Util.MapException(x.InnerException));
d532 1
a532 1
				else if(!method.DeclaringType.IsInstanceOfType(obj))
d534 1
a534 15
					// we're trying to initialize an existing instance of a remapped type
					if(obj is System.Exception && (args == null || args.Length == 0))
					{
						// HACK special case for deserialization of java.lang.Throwable subclasses
						// we don't call the constructor here, it will be called by Throwable.readObject()
						return null;
					}
					else
					{
						// NOTE this will also happen if you try to deserialize a .NET object
						// (i.e. a type that doesn't derive from our java.lang.Object).
						// We might want to support that in the future (it's fairly easy, because
						// the call to Object.<init> can just be ignored)
						throw new NotSupportedException("Unable to partially construct object of type " + obj.GetType().FullName + " to type " + method.DeclaringType.FullName);
					}
d537 1
a537 6
			else if(nonVirtual &&
				method.IsVirtual &&	// if the method isn't virtual, normal reflection will work
				!method.IsFinal &&	// if the method is final, normal reflection will work
				!method.DeclaringType.IsSealed && // if the type is sealed, normal reflection will work
				!method.IsAbstract)	// if the method is abstract, it doesn't make sense, so we'll do a virtual call
									// (Sun does a virtual call for interface methods and crashes for abstract methods)
d539 4
a542 2
				Invoker invoker = NonvirtualInvokeHelper.GetInvoker(this);
				try
d544 6
a549 2
					InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, obj, args);
					return invoker(method.MethodHandle.GetFunctionPointer(), proc.GetObj(), proc.GetArgs());
d551 1
a551 1
				catch(ArgumentException x1)
d553 1
a553 5
					throw JavaException.IllegalArgumentException(x1.Message);
				}
				catch(TargetInvocationException x)
				{
					throw JavaException.InvocationTargetException(IKVM.Runtime.Util.MapException(x.InnerException));
d556 1
d558 5
a562 1
		try
d564 3
a566 4
			InvokeArgsProcessor proc = new InvokeArgsProcessor(this, method, obj, args);
			object o = method.Invoke(proc.GetObj(), proc.GetArgs());
			TypeWrapper retType = this.ReturnType;
			if(!retType.IsUnloadable && retType.IsGhost)
d568 100
a667 1
				o = retType.GhostRefField.GetValue(o);
a668 1
			return o;
d670 2
a671 5
		catch(ArgumentException x1)
		{
			throw JavaException.IllegalArgumentException(x1.Message);
		}
		catch(TargetInvocationException x)
d673 2
a674 8
			throw JavaException.InvocationTargetException(IKVM.Runtime.Util.MapException(x.InnerException));
		}
	}

	private class NonvirtualInvokeHelper
	{
		private static Hashtable cache;
		private static ModuleBuilder module;
d676 1
a676 3
		private class KeyGen : IHashCodeProvider, IComparer
		{
			public int GetHashCode(object o)
d678 5
a682 3
				MethodWrapper mw = (MethodWrapper)o;
				return mw.Signature.GetHashCode();
			}
d684 1
a684 5
			public int Compare(object x, object y)
			{
				MethodWrapper mw1 = (MethodWrapper)x;
				MethodWrapper mw2 = (MethodWrapper)y;
				if(mw1.ReturnType == mw2.ReturnType)
d686 3
a688 3
					TypeWrapper[] p1 = mw1.GetParameters();
					TypeWrapper[] p2 = mw2.GetParameters();
					if(p1.Length == p2.Length)
d690 3
a692 1
						for(int i = 0; i < p1.Length; i++)
d694 1
a694 1
							if(p1[i] != p2[i])
d696 4
a699 1
								return 1;
d701 1
a702 1
						return 0;
d704 1
a705 1
				return 1;
a706 1
		}
d708 1
a708 10
		static NonvirtualInvokeHelper()
		{
			KeyGen keygen = new KeyGen();
			cache = new Hashtable(keygen, keygen);
			AssemblyName name = new AssemblyName();
			name.Name = "NonvirtualInvoker";
			AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, ClassLoaderWrapper.IsSaveDebugImage ? AssemblyBuilderAccess.RunAndSave : AssemblyBuilderAccess.Run);
			// the stack walker needs access to this assembly to be able to quickly check for non-virtual invoke frames
			IKVM.NativeCode.gnu.classpath.VMStackWalker.nonVirtualInvokeAssembly = ab;
			if(ClassLoaderWrapper.IsSaveDebugImage)
d710 16
a725 6
				module = ab.DefineDynamicModule("NonvirtualInvoker", "NonvirtualInvoker.dll");
				ClassLoaderWrapper.RegisterForSaveDebug(ab);
			}
			else
			{
				module = ab.DefineDynamicModule("NonvirtualInvoker");
a726 1
		}
d728 1
a728 3
		internal static Invoker GetInvoker(MethodWrapper mw)
		{
			lock(cache.SyncRoot)
d730 1
a730 2
				Invoker inv = (Invoker)cache[mw];
				if(inv == null)
d732 7
a738 2
					inv = CreateInvoker(mw);
					cache[mw] = inv;
a739 1
				return inv;
a740 1
		}
d742 1
a742 9
		private static Invoker CreateInvoker(MethodWrapper mw)
		{
			// TODO we need to support byref arguments...
			TypeBuilder typeBuilder = module.DefineType("class" + cache.Count);
			MethodBuilder methodBuilder = typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Static, typeof(object), new Type[] { typeof(IntPtr), typeof(object), typeof(object[]) });
			ILGenerator ilgen = methodBuilder.GetILGenerator();
			ilgen.Emit(OpCodes.Ldarg_1);
			TypeWrapper[] paramTypes = mw.GetParameters();
			for(int i = 0; i < paramTypes.Length; i++)
d744 28
a771 4
				ilgen.Emit(OpCodes.Ldarg_2);
				ilgen.Emit(OpCodes.Ldc_I4, i);
				ilgen.Emit(OpCodes.Ldelem_Ref);
				if(paramTypes[i].IsUnloadable)
d775 1
a775 1
				else if(paramTypes[i].IsPrimitive)
d777 1
a777 2
					ilgen.Emit(OpCodes.Unbox, paramTypes[i].TypeAsTBD);
					ilgen.Emit(OpCodes.Ldobj, paramTypes[i].TypeAsTBD);
d779 1
a779 1
				else if(paramTypes[i].IsNonPrimitiveValueType)
d781 4
a784 1
					paramTypes[i].EmitUnbox(ilgen);
d786 7
a793 24
			ilgen.Emit(OpCodes.Ldarg_0);
			ilgen.EmitCalli(OpCodes.Calli, CallingConventions.HasThis, mw.ReturnTypeForDefineMethod, mw.GetParametersForDefineMethod(), null);
			if(mw.ReturnType.IsUnloadable)
			{
				// no need to do anything
			}
			else if(mw.ReturnType == PrimitiveTypeWrapper.VOID)
			{
				ilgen.Emit(OpCodes.Ldnull);
			}
			else if(mw.ReturnType.IsGhost)
			{
				LocalBuilder local = ilgen.DeclareLocal(mw.ReturnType.TypeAsSignatureType);
				ilgen.Emit(OpCodes.Stloc, local);
				ilgen.Emit(OpCodes.Ldloca, local);
				ilgen.Emit(OpCodes.Ldfld, mw.ReturnType.GhostRefField);
			}
			else if(mw.ReturnType.IsPrimitive)
			{
				ilgen.Emit(OpCodes.Box, mw.ReturnType.TypeAsTBD);
			}
			ilgen.Emit(OpCodes.Ret);
			Type type = typeBuilder.CreateType();
			return (Invoker)Delegate.CreateDelegate(typeof(Invoker), type.GetMethod("Invoke"));
a794 6
	}

	private struct InvokeArgsProcessor
	{
		private object obj;
		private object[] args;
d796 1
a796 1
		internal InvokeArgsProcessor(MethodWrapper mw, MethodBase method, object original_obj, object[] original_args)
d798 2
a799 1
			TypeWrapper[] argTypes = mw.GetParameters();
d801 1
a801 1
			if(!mw.IsStatic && method.IsStatic && mw.Name != "<init>")
d803 3
a805 7
				// we've been redirected to a static method, so we have to copy the 'obj' into the args
				object[] nargs = new object[original_args.Length + 1];
				nargs[0] = original_obj;
				original_args.CopyTo(nargs, 1);
				this.obj = null;
				this.args = nargs;
				for(int i = 0; i < argTypes.Length; i++)
d807 7
a813 1
					if(!argTypes[i].IsUnloadable && argTypes[i].IsGhost)
d815 6
a820 3
						object v = Activator.CreateInstance(argTypes[i].TypeAsSignatureType);
						argTypes[i].GhostRefField.SetValue(v, args[i + 1]);
						args[i + 1] = v;
d823 1
a823 6
			}
			else
			{
				this.obj = original_obj;
				this.args = original_args;
				for(int i = 0; i < argTypes.Length; i++)
d825 3
a827 1
					if(!argTypes[i].IsUnloadable && argTypes[i].IsGhost)
d829 1
a829 1
						if(this.args == original_args)
d831 7
a837 1
							this.args = (object[])args.Clone();
a838 3
						object v = Activator.CreateInstance(argTypes[i].TypeAsSignatureType);
						argTypes[i].GhostRefField.SetValue(v, args[i]);
						this.args[i] = v;
a841 1
		}
d843 9
a851 3
		internal object GetObj()
		{
			return obj;
d854 1
a854 1
		internal object[] GetArgs()
d856 11
a866 1
			return args;
d870 1
a870 1
	internal static OpCode SimpleOpCodeToOpCode(SimpleOpCode opc)
d872 2
a873 1
		switch(opc)
a874 8
			case SimpleOpCode.Call:
				return OpCodes.Call;
			case SimpleOpCode.Callvirt:
				return OpCodes.Callvirt;
			case SimpleOpCode.Newobj:
				return OpCodes.Newobj;
			default:
				throw new InvalidOperationException();
a875 2
	}
}
d877 3
a879 10
class SmartMethodWrapper : MethodWrapper
{
	internal SmartMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
		: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
	{
	}

	protected virtual void PreEmit(ILGenerator ilgen)
	{
	}
d881 1
a881 17
	internal sealed override void EmitCall(ILGenerator ilgen)
	{
		AssertLinked();
		PreEmit(ilgen);
		CallImpl(ilgen);
	}

	protected virtual void CallImpl(ILGenerator ilgen)
	{
		throw new InvalidOperationException();
	}

	internal sealed override void EmitCallvirt(ILGenerator ilgen)
	{
		AssertLinked();
		PreEmit(ilgen);
		if(DeclaringType.IsNonPrimitiveValueType)
d883 2
a884 2
			// callvirt isn't allowed on a value type
			// TODO we need to check for a null reference
d887 2
a888 1
		else
d890 1
a890 1
			CallvirtImpl(ilgen);
a891 1
	}
d893 15
a907 4
	protected virtual void CallvirtImpl(ILGenerator ilgen)
	{
		throw new InvalidOperationException();
	}
d909 1
a909 6
	internal sealed override void EmitNewobj(ILGenerator ilgen)
	{
		AssertLinked();
		PreEmit(ilgen);
		NewobjImpl(ilgen);
		if(DeclaringType.IsNonPrimitiveValueType)
d911 1
a911 1
			DeclaringType.EmitBox(ilgen);
a912 1
	}
d914 10
a923 5
	protected virtual void NewobjImpl(ILGenerator ilgen)
	{
		throw new InvalidOperationException();
	}
}
d925 4
a928 17
enum SimpleOpCode : byte
{
	Call,
	Callvirt,
	Newobj
}

sealed class SimpleCallMethodWrapper : MethodWrapper
{
	private SimpleOpCode call;
	private SimpleOpCode callvirt;

	internal SimpleCallMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags, SimpleOpCode call, SimpleOpCode callvirt)
		: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
	{
		this.call = call;
		this.callvirt = callvirt;
d931 1
a931 1
	internal override void EmitCall(ILGenerator ilgen)
d933 3
a935 1
		ilgen.Emit(SimpleOpCodeToOpCode(call), (MethodInfo)GetMethod());
d938 1
a938 1
	internal override void EmitCallvirt(ILGenerator ilgen)
d940 2
a941 3
		ilgen.Emit(SimpleOpCodeToOpCode(callvirt), (MethodInfo)GetMethod());
	}
}
d943 6
a948 4
sealed class SmartCallMethodWrapper : SmartMethodWrapper
{
	private SimpleOpCode call;
	private SimpleOpCode callvirt;
d950 4
a953 6
	internal SmartCallMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags, SimpleOpCode call, SimpleOpCode callvirt)
		: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, flags)
	{
		this.call = call;
		this.callvirt = callvirt;
	}
d955 4
a958 3
	protected override void CallImpl(ILGenerator ilgen)
	{
		ilgen.Emit(SimpleOpCodeToOpCode(call), (MethodInfo)GetMethod());
d961 1
a961 1
	protected override void CallvirtImpl(ILGenerator ilgen)
d963 2
a964 3
		ilgen.Emit(SimpleOpCodeToOpCode(callvirt), (MethodInfo)GetMethod());
	}
}
d966 6
a971 6
sealed class SmartConstructorMethodWrapper : SmartMethodWrapper
{
	internal SmartConstructorMethodWrapper(TypeWrapper declaringType, string name, string sig, ConstructorInfo method, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
		: base(declaringType, name, sig, method, PrimitiveTypeWrapper.VOID, parameterTypes, modifiers, flags)
	{
	}
d973 4
a976 4
	protected override void CallImpl(ILGenerator ilgen)
	{
		ilgen.Emit(OpCodes.Call, (ConstructorInfo)GetMethod());
	}
d978 4
a981 3
	protected override void NewobjImpl(ILGenerator ilgen)
	{
		ilgen.Emit(OpCodes.Newobj, (ConstructorInfo)GetMethod());
a982 1
}
d984 1
a984 8
// This class tests if reflection on a constant field triggers the class constructor to run
// (it shouldn't run, but on .NET 1.0 & 1.1 it does)
sealed class ReflectionOnConstant
{
	private static bool isBroken;
	private static System.Collections.Hashtable warnOnce;

	static ReflectionOnConstant()
d986 4
a989 2
		typeof(Helper).GetField("foo", BindingFlags.NonPublic | BindingFlags.Static).GetValue(null);
	}
d991 1
a991 3
	internal static bool IsBroken
	{
		get
d993 1
a993 1
			return isBroken;
a994 1
	}
d996 1
a996 7
	internal static void IssueWarning(FieldInfo field)
	{
		// FXBUG .NET (1.0 & 1.1)
		// FieldInfo.GetValue() on a literal causes the type initializer to run and
		// we don't want that.
		// TODO may need to find a workaround, for now we just spit out a warning
		if(ReflectionOnConstant.IsBroken && field.DeclaringType.TypeInitializer != null)
d998 1
a998 12
			if(Tracer.FxBug.TraceWarning)
			{
				if(warnOnce == null)
				{
					warnOnce = new System.Collections.Hashtable();
				}
				if(!warnOnce.ContainsKey(field.DeclaringType.FullName))
				{
					warnOnce.Add(field.DeclaringType.FullName, null);
					Tracer.Warning(Tracer.FxBug, "Running type initializer for {0} due to CLR bug", field.DeclaringType.FullName);
				}
			}
d1002 3
a1004 1
	private class Helper
d1006 2
a1007 1
		internal const int foo = 1;
d1009 1
a1009 1
		static Helper()
d1011 1
a1011 1
			isBroken = true;
a1012 21
	}
}

abstract class FieldWrapper : MemberWrapper
{
	internal static readonly FieldWrapper[] EmptyArray  = new FieldWrapper[0];
	private string name;
	private string sig;
	private FieldInfo field;
	private TypeWrapper fieldType;

	internal FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field)
		: base(declaringType, modifiers, field != null && field.IsLiteral ? MemberFlags.LiteralField : MemberFlags.None)
	{
		Debug.Assert(name != null);
		Debug.Assert(sig != null);
		this.name = name;
		this.sig = sig;
		this.fieldType = fieldType;
		this.field = field;
	}
d1014 1
a1014 10
	internal FieldInfo GetField()
	{
		AssertLinked();
		return field;
	}

	[Conditional("DEBUG")]
	internal void AssertLinked()
	{
		if(fieldType == null)
d1016 4
a1019 1
			Tracer.Error(Tracer.Runtime, "AssertLinked failed: " + this.DeclaringType.Name + "::" + this.name + " (" + this.sig + ")");
a1020 2
		Debug.Assert(fieldType != null, this.DeclaringType.Name + "::" + this.name + " (" + this.sig+ ")");
	}
d1022 7
a1028 20
	// NOTE used (thru IKVM.Runtime.Util.GetFieldConstantValue) by ikvmstub to find out if the
	// field is a constant (and if it is, to get its value)
	internal object GetConstant()
	{
		AssertLinked();
		// only pritimives and string can be literals in Java (because the other "primitives" (like uint),
		// are treated as NonPrimitiveValueTypes)
		if(field != null && (fieldType.IsPrimitive || fieldType == CoreClasses.java.lang.String.Wrapper))
		{
			object val = null;
			if(field.IsLiteral)
			{
				ReflectionOnConstant.IssueWarning(field);
				val = field.GetValue(null);
				if(val is Enum)
				{
					val = DotNetTypeWrapper.EnumValueFieldWrapper.GetEnumPrimitiveValue(val);
				}
			}
			else
d1030 1
a1030 4
				// In Java, instance fields can also have a ConstantValue attribute so we emulate that
				// with ConstantValueAttribute (for consumption by ikvmstub only)
				object[] attrib = field.GetCustomAttributes(typeof(ConstantValueAttribute), false);
				if(attrib.Length == 1)
d1032 9
a1040 1
					val = ((ConstantValueAttribute)attrib[0]).GetConstantValue();
d1043 7
a1049 1
			if(val != null && !(val is string))
d1051 1
a1051 1
				return JVM.Library.box(val);
a1052 1
			return val;
a1053 6
		return null;
	}

	internal static FieldWrapper FromCookie(IntPtr cookie)
	{
		return (FieldWrapper)FromCookieImpl(cookie);
d1056 1
a1056 1
	internal string Name
d1058 5
a1062 5
		get
		{
			return name;
		}
	}
d1064 2
a1065 3
	internal string Signature
	{
		get
d1067 6
a1072 1
			return sig;
a1073 1
	}
d1075 1
a1075 3
	internal TypeWrapper FieldTypeWrapper
	{
		get
d1078 1
a1078 1
			return fieldType;
a1079 17
	}

	internal void EmitGet(ILGenerator ilgen)
	{
		AssertLinked();
		EmitGetImpl(ilgen);
	}

	protected abstract void EmitGetImpl(ILGenerator ilgen);

	internal void EmitSet(ILGenerator ilgen)
	{
		AssertLinked();
		EmitSetImpl(ilgen);
	}

	protected abstract void EmitSetImpl(ILGenerator ilgen);
d1081 2
a1082 3
	internal void Link()
	{
		lock(this)
d1086 1
a1086 14
				// TODO we need to use the actual classCache here
				System.Collections.Hashtable classCache = new System.Collections.Hashtable();
				fieldType = ClassFile.FieldTypeWrapperFromSig(this.DeclaringType.GetClassLoader(), classCache, sig);
				try
				{
					field = this.DeclaringType.LinkField(this);
				}
				catch
				{
					// HACK if linking fails, we unlink to make sure
					// that the next link attempt will fail again
					fieldType = null;
					throw;
				}
d1088 1
a1089 1
	}
d1091 3
a1093 3
	internal bool IsVolatile
	{
		get
d1095 32
a1126 1
			return (Modifiers & Modifiers.Volatile) != 0;
a1127 1
	}
d1129 1
a1129 4
	internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers)
	{
		// volatile long & double field accesses must be made atomic
		if((modifiers & Modifiers.Volatile) != 0 && (sig == "J" || sig == "D"))
d1131 1
a1131 1
			return new VolatileLongDoubleFieldWrapper(declaringType, fieldType, fi, name, sig, modifiers);
a1132 2
		return new SimpleFieldWrapper(declaringType, fieldType, fi, name, sig, modifiers);
	}
d1134 1
a1134 4
	private void LookupField()
	{
		BindingFlags bindings = BindingFlags.Public | BindingFlags.NonPublic;
		if(IsStatic)
d1136 4
a1139 1
			bindings |= BindingFlags.Static;
d1141 2
a1142 1
		else
d1144 4
a1147 1
			bindings |= BindingFlags.Instance;
a1148 5
		// TODO instead of looking up the field by name, we should use the Token to find it.
		field = DeclaringType.TypeAsTBD.GetField(name, bindings);
		this.IsLiteralField = field.IsLiteral;
		Debug.Assert(field != null);
	}
d1150 1
a1150 5
	internal virtual void SetValue(object obj, object val)
	{
		AssertLinked();
		// TODO this is a broken implementation (for one thing, it needs to support redirection)
		if(field == null || field is FieldBuilder)
d1152 5
a1156 1
			LookupField();
d1158 2
a1159 1
		if(fieldType.IsGhost)
d1161 2
a1162 3
			object temp = field.GetValue(obj);
			fieldType.GhostRefField.SetValue(temp, val);
			val = temp;
d1164 4
a1167 1
		try
d1169 2
a1170 1
			field.SetValue(obj, val);
d1172 4
a1175 1
		catch(FieldAccessException x)
d1177 20
a1196 1
			throw JavaException.IllegalAccessException(x.Message);
a1197 1
	}
d1199 1
a1199 5
	internal virtual object GetValue(object obj)
	{
		AssertLinked();
		// TODO this is a broken implementation (for one thing, it needs to support redirection)
		if(field == null || field is FieldBuilder)
d1201 4
a1204 1
			LookupField();
d1206 2
a1207 4
		// FieldInfo.IsLiteral is expensive, so we have our own flag
		// TODO we might be able to ensure that we always use ConstantFieldWrapper for literal fields,
		// in that case the we could simply remove the check altogether.
		if(IsLiteralField)
d1209 6
a1214 2
			// on a non-broken CLR GetValue on a literal will not trigger type initialization, but on Java it should
			DeclaringType.RunClassInit();
d1216 2
a1217 2
		object val = field.GetValue(obj);
		if(fieldType.IsGhost)
d1219 13
a1231 1
			val = fieldType.GhostRefField.GetValue(val);
a1232 3
		return val;
	}
}
d1234 1
a1234 11
sealed class SimpleFieldWrapper : FieldWrapper
{
	internal SimpleFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers)
		: base(declaringType, fieldType, name, sig, modifiers, fi)
	{
		Debug.Assert(!(fieldType == PrimitiveTypeWrapper.DOUBLE || fieldType == PrimitiveTypeWrapper.LONG) || !IsVolatile);
	}

	protected override void EmitGetImpl(ILGenerator ilgen)
	{
		if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
d1236 20
a1255 1
			ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
d1257 2
a1258 1
		if(IsVolatile)
d1260 20
a1279 1
			ilgen.Emit(OpCodes.Volatile);
a1280 1
		ilgen.Emit(IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, GetField());
d1283 1
a1283 1
	protected override void EmitSetImpl(ILGenerator ilgen)
d1285 2
a1286 2
		FieldInfo fi = GetField();
		if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
d1288 1
a1288 4
			LocalBuilder temp = ilgen.DeclareLocal(fi.FieldType);
			ilgen.Emit(OpCodes.Stloc, temp);
			ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
			ilgen.Emit(OpCodes.Ldloc, temp);
a1289 14
		if(IsVolatile)
		{
			ilgen.Emit(OpCodes.Volatile);
		}
		ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
	}
}

sealed class VolatileLongDoubleFieldWrapper : FieldWrapper
{
	private static MethodInfo volatileReadDouble = typeof(System.Threading.Thread).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Double&") });
	private static MethodInfo volatileReadLong = typeof(System.Threading.Thread).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Int64&") });
	private static MethodInfo volatileWriteDouble = typeof(System.Threading.Thread).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Double&"), typeof(double) });
	private static MethodInfo volatileWriteLong = typeof(System.Threading.Thread).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Int64&"), typeof(long) });
d1291 1
a1291 11
	internal VolatileLongDoubleFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers)
		: base(declaringType, fieldType, name, sig, modifiers, fi)
	{
		Debug.Assert(IsVolatile);
		Debug.Assert(sig == "J" || sig == "D");
	}

	protected override void EmitGetImpl(ILGenerator ilgen)
	{
		FieldInfo fi = GetField();
		if(fi.IsStatic)
d1293 1
a1293 5
			ilgen.Emit(OpCodes.Ldsflda, fi);
		}
		else
		{
			if(DeclaringType.IsNonPrimitiveValueType)
d1297 5
a1301 5
			ilgen.Emit(OpCodes.Ldflda, fi);
		}
		if(fi.FieldType == typeof(double))
		{
			ilgen.Emit(OpCodes.Call, volatileReadDouble);
a1302 6
		else
		{
			Debug.Assert(fi.FieldType == typeof(long));
			ilgen.Emit(OpCodes.Call, volatileReadLong);
		}
	}
d1304 1
a1304 6
	protected override void EmitSetImpl(ILGenerator ilgen)
	{
		FieldInfo fi = GetField();
		LocalBuilder temp = ilgen.DeclareLocal(fi.FieldType);
		ilgen.Emit(OpCodes.Stloc, temp);
		if(fi.IsStatic)
d1306 2
a1307 5
			ilgen.Emit(OpCodes.Ldsflda, fi);
		}
		else
		{
			if(DeclaringType.IsNonPrimitiveValueType)
d1309 2
d1312 1
d1314 5
a1318 6
			ilgen.Emit(OpCodes.Ldflda, fi);
		}
		ilgen.Emit(OpCodes.Ldloc, temp);
		if(fi.FieldType == typeof(double))
		{
			ilgen.Emit(OpCodes.Call, volatileWriteDouble);
a1319 19
		else
		{
			Debug.Assert(fi.FieldType == typeof(long));
			ilgen.Emit(OpCodes.Call, volatileWriteLong);
		}
	}
}

sealed class GetterFieldWrapper : FieldWrapper
{
	private MethodInfo getter;

	// NOTE fi may be null!
	internal GetterFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers, MethodInfo getter)
		: base(declaringType, fieldType, name, sig, modifiers, fi)
	{
		Debug.Assert(!IsVolatile);

		this.getter = getter;
d1322 1
a1322 1
	internal void SetGetter(MethodInfo getter)
d1324 4
a1327 2
		this.getter = getter;
	}
d1329 2
a1330 3
	protected override void EmitGetImpl(ILGenerator ilgen)
	{
		if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
d1332 2
a1333 2
			ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
			ilgen.Emit(OpCodes.Call, getter);
d1335 2
a1336 1
		else
d1338 22
a1359 3
			// NOTE we look at the static-ness of the getter method and not our own,
			// because for instance fields we can still have a static getter method
			ilgen.Emit(getter.IsStatic ? OpCodes.Call : OpCodes.Callvirt, getter);
a1360 1
	}
d1362 1
a1362 4
	protected override void EmitSetImpl(ILGenerator ilgen)
	{
		FieldInfo fi = GetField();
		if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
d1364 1
d1367 12
a1378 1
			ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
d1380 9
a1389 1
		ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
a1390 5
}

sealed class ConstantFieldWrapper : FieldWrapper
{
	private object constant;
d1392 1
a1392 2
	internal ConstantFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, object constant)
		: base(declaringType, fieldType, name, sig, modifiers, field)
d1394 1
a1394 3
		Debug.Assert(IsStatic);
		this.constant = constant;
	}
d1396 3
a1398 7
	protected override void EmitGetImpl(ILGenerator ilgen)
	{
		// NOTE even though you're not supposed to access a constant static final (the compiler is supposed
		// to inline them), we have to support it (because it does happen, e.g. if the field becomes final
		// after the referencing class was compiled, or when we're accessing an unsigned primitive .NET field)
		object v = GetValue(null);
		if(v == null)
d1400 3
a1402 1
			ilgen.Emit(OpCodes.Ldnull);
d1404 2
a1405 7
		else if(constant is int || 
			constant is short ||
			constant is ushort ||
			constant is byte ||
			constant is sbyte ||
			constant is char ||
			constant is bool)
d1407 1
a1407 1
			ilgen.Emit(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
d1409 2
a1410 1
		else if(constant is string)
d1412 11
a1422 1
			ilgen.Emit(OpCodes.Ldstr, (string)constant);
d1424 2
a1425 1
		else if(constant is float)
d1427 9
a1435 1
			ilgen.Emit(OpCodes.Ldc_R4, (float)constant);
d1437 8
a1444 1
		else if(constant is double)
d1446 2
a1447 1
			ilgen.Emit(OpCodes.Ldc_R8, (double)constant);
d1449 2
a1450 1
		else if(constant is long)
d1452 31
a1482 14
			ilgen.Emit(OpCodes.Ldc_I8, (long)constant);
		}
		else if(constant is uint)
		{
			ilgen.Emit(OpCodes.Ldc_I4, unchecked((int)((IConvertible)constant).ToUInt32(null)));
		}
		else if(constant is ulong)
		{
			ilgen.Emit(OpCodes.Ldc_I8, unchecked((long)(ulong)constant));
		}
		else if(constant is Enum)
		{
			object val = DotNetTypeWrapper.EnumValueFieldWrapper.GetEnumPrimitiveValue(constant);
			if(val is long)
d1486 20
d1508 1
a1508 1
				ilgen.Emit(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
d1511 2
a1512 1
		else
d1514 3
a1516 1
			throw new InvalidOperationException(constant.GetType().FullName);
a1517 8
	}

	protected override void EmitSetImpl(ILGenerator ilgen)
	{
		// when constant static final fields are updated, the JIT normally doesn't see that (because the
		// constant value is inlined), so we emulate that behavior by emitting a Pop
		ilgen.Emit(OpCodes.Pop);
	}
d1519 1
a1519 3
	internal override object GetValue(object obj)
	{
		if(constant == null)
d1521 5
a1525 1
			constant = GetField().GetValue(null);
a1526 1
		return constant;
@


1.31
log
@*** empty log message ***
@
text
@d807 3
a809 3
				args = new object[original_args.Length + 1];
				args[0] = original_obj;
				original_args.CopyTo(args, 1);
d811 1
a811 1
				this.args = args;
@


1.30
log
@*** empty log message ***
@
text
@d108 1
a108 1
	internal bool IsAccessibleFrom(TypeWrapper caller, TypeWrapper instance)
d110 8
a117 4
		return (DeclaringType.IsPublic && IsPublic) ||
			caller == DeclaringType ||
			((IsPublic || IsProtected) && (IsStatic ? caller.IsSubTypeOf(DeclaringType) : instance.IsSubTypeOf(caller))) ||
			(!IsPrivate && caller.IsInSamePackageAs(DeclaringType));
@


1.29
log
@*** empty log message ***
@
text
@a315 12
	internal void SetDeclaredExceptions(IKVM.Internal.MapXml.Throws[] throws)
	{
		if(throws != null)
		{
			declaredExceptions = new string[throws.Length];
			for(int i = 0; i < throws.Length; i++)
			{
				declaredExceptions[i] = throws[i].Class;
			}
		}
	}

@


1.28
log
@*** empty log message ***
@
text
@d256 1
@


1.27
log
@*** empty log message ***
@
text
@d41 2
a42 1
	LiteralField = 4
d60 2
d64 2
a65 2
		// NOTE when we're being unloaded, we shouldn't clean up the handle, because JNI
		// code running in a finalize can use this handle later on (since finalization is
d69 1
a69 1
			handle.Free();
d73 7
d86 1
a86 2
				// MONOBUG GCHandle.IsAllocated is horribly broken, so we also check the value of the handle
				if(!handle.IsAllocated || (IntPtr)handle == IntPtr.Zero)
d145 8
d266 1
a266 1
	internal static MethodWrapper Create(TypeWrapper declaringType, string name, string sig, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection)
d282 1
a282 1
			return new GhostMethodWrapper(declaringType, name, sig, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None);
d286 1
a286 1
			return new SmartConstructorMethodWrapper(declaringType, name, sig, (ConstructorInfo)method, parameterTypes, modifiers, hideFromReflection);
d290 1
a290 1
			return new SmartCallMethodWrapper(declaringType, name, sig, (MethodInfo)method, returnType, parameterTypes, modifiers, hideFromReflection, SimpleOpCode.Call, method.IsStatic ? SimpleOpCode.Call : SimpleOpCode.Callvirt);
d949 2
a950 2
	internal SimpleCallMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection, SimpleOpCode call, SimpleOpCode callvirt)
		: base(declaringType, name, sig, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
a971 5
	internal SmartCallMethodWrapper(TypeWrapper declaringType, string name, string sig, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection, SimpleOpCode call, SimpleOpCode callvirt)
		: this(declaringType, name, sig, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None, call, callvirt)
	{
	}

a996 5
	internal SmartConstructorMethodWrapper(TypeWrapper declaringType, string name, string sig, ConstructorInfo method, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection)
		: base(declaringType, name, sig, method, PrimitiveTypeWrapper.VOID, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
	{
	}

@


1.26
log
@*** empty log message ***
@
text
@d103 1
a103 1
			(IsProtected && (IsStatic ? caller.IsSubTypeOf(DeclaringType) : instance.IsSubTypeOf(caller))) ||
@


1.25
log
@*** empty log message ***
@
text
@d64 1
a64 2
		if(!(AppDomain.CurrentDomain.IsFinalizingForUnload() || Environment.HasShutdownStarted)
			&& handle.IsAllocated)
@


1.24
log
@*** empty log message ***
@
text
@d61 5
a65 1
		if(handle.IsAllocated)
@


1.23
log
@*** empty log message ***
@
text
@d98 1
a98 1
		return IsPublic ||
@


1.22
log
@*** empty log message ***
@
text
@d40 2
a41 1
	ExplicitOverride = 2
a50 5
	protected MemberWrapper(TypeWrapper declaringType, Modifiers modifiers, bool hideFromReflection)
		: this(declaringType, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
	{
	}

d120 13
d1061 1
a1061 1
		: base(declaringType, modifiers, false)
d1226 1
d1262 4
a1265 1
		if(field.IsLiteral)
d1268 1
a1268 1
			System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(field.DeclaringType.TypeHandle);
@


1.21
log
@*** empty log message ***
@
text
@d77 2
a78 1
				if(!handle.IsAllocated)
@


1.20
log
@*** empty log message ***
@
text
@a1420 2
// NOTE this type is only used for remapped fields, dynamically compiled classes are always finished before we
// allow reflection (so we can look at the underlying field in that case)
d1428 1
a1497 1
		// TODO can we have a constant instance field?
@


1.19
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d212 1
a212 1
				ghostMethod = DeclaringType.TypeAsParameterType.GetMethod(this.Name, this.GetParametersForDefineMethod());
d228 1
a228 1
			object wrapper = Activator.CreateInstance(DeclaringType.TypeAsParameterType);
d248 1
a248 1
					types[i] = parameterTypes[i].TypeAsParameterType;
d386 1
a386 1
			return ReturnType.TypeAsParameterType;
d396 1
a396 1
			temp[i] = wrappers[i].TypeAsParameterType;
d603 6
a608 1
			else if(nonVirtual && !method.IsStatic)
d691 2
d757 4
a760 1
				mw.ReturnType.EmitConvParameterToStackType(ilgen);
d793 1
a793 1
						object v = Activator.CreateInstance(argTypes[i].TypeAsParameterType);
d811 1
a811 1
						object v = Activator.CreateInstance(argTypes[i].TypeAsParameterType);
a856 19
	protected void PostEmit(ILGenerator ilgen)
	{
		TypeWrapper retType = this.ReturnType;
		if(!retType.IsUnloadable)
		{
			if(retType.IsNonPrimitiveValueType)
			{
				retType.EmitBox(ilgen);
			}
			else if(retType.IsGhost)
			{
				LocalBuilder local = ilgen.DeclareLocal(retType.TypeAsParameterType);
				ilgen.Emit(OpCodes.Stloc, local);
				ilgen.Emit(OpCodes.Ldloca, local);
				ilgen.Emit(OpCodes.Ldfld, retType.GhostRefField);
			}
		}
	}

a861 1
		PostEmit(ilgen);
d876 1
a882 1
		PostEmit(ilgen);
d1275 1
a1275 1
		if(FieldTypeWrapper.IsGhost)
d1277 1
a1277 18
			FieldInfo fi = GetField();
			if(fi.IsStatic)
			{
				ilgen.Emit(OpCodes.Ldsflda, fi);
			}
			else
			{
				if(DeclaringType.IsNonPrimitiveValueType)
				{
					ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				}
				ilgen.Emit(OpCodes.Ldflda, fi);
			}
			if(IsVolatile)
			{
				ilgen.Emit(OpCodes.Volatile);
			}
			ilgen.Emit(OpCodes.Ldfld, FieldTypeWrapper.GhostRefField);
d1279 1
a1279 1
		else
d1281 1
a1281 13
			if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
			{
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
			}
			if(IsVolatile)
			{
				ilgen.Emit(OpCodes.Volatile);
			}
			ilgen.Emit(IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, GetField());
			if(!FieldTypeWrapper.IsUnloadable && FieldTypeWrapper.IsNonPrimitiveValueType)
			{
				FieldTypeWrapper.EmitBox(ilgen);
			}
d1283 1
d1288 2
a1289 1
		if(FieldTypeWrapper.IsGhost)
d1291 1
a1291 2
			FieldInfo fi = GetField();
			LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsLocalOrStackType);
d1293 1
a1293 12
			if(fi.IsStatic)
			{
				ilgen.Emit(OpCodes.Ldsflda, fi);
			}
			else
			{
				if(DeclaringType.IsNonPrimitiveValueType)
				{
					ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				}
				ilgen.Emit(OpCodes.Ldflda, fi);
			}
a1294 5
			if(IsVolatile)
			{
				ilgen.Emit(OpCodes.Volatile);
			}
			ilgen.Emit(OpCodes.Stfld, FieldTypeWrapper.GhostRefField);
d1296 1
a1296 1
		else
d1298 1
a1298 17
			if(!IsStatic && DeclaringType.IsNonPrimitiveValueType)
			{
				FieldInfo fi = GetField();
				LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsLocalOrStackType);
				ilgen.Emit(OpCodes.Stloc, temp);
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				ilgen.Emit(OpCodes.Ldloc, temp);
			}
			if(!FieldTypeWrapper.IsUnloadable && FieldTypeWrapper.IsNonPrimitiveValueType)
			{
				FieldTypeWrapper.EmitUnbox(ilgen);
			}
			if(IsVolatile)
			{
				ilgen.Emit(OpCodes.Volatile);
			}
			ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, GetField());
d1300 1
d1315 1
a1315 1
		Debug.Assert(fieldType == PrimitiveTypeWrapper.DOUBLE || fieldType == PrimitiveTypeWrapper.LONG);
d1394 1
a1394 1
		if(IsStatic)
d1396 1
d1401 3
a1403 24
			if(DeclaringType.IsNonPrimitiveValueType)
			{
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				ilgen.Emit(OpCodes.Call, getter);
			}
			else
			{
				ilgen.Emit(getter.IsStatic ? OpCodes.Call : OpCodes.Callvirt, getter);
			}
		}
		if(FieldTypeWrapper.IsUnloadable)
		{
			// no need to do anything
		}
		else if(FieldTypeWrapper.IsGhost)
		{
			LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsFieldType);
			ilgen.Emit(OpCodes.Stloc, temp);
			ilgen.Emit(OpCodes.Ldloca, temp);
			ilgen.Emit(OpCodes.Ldfld, FieldTypeWrapper.GhostRefField);
		}
		else if(FieldTypeWrapper.IsNonPrimitiveValueType)
		{
			FieldTypeWrapper.EmitBox(ilgen);
d1410 1
a1410 1
		if(FieldTypeWrapper.IsUnloadable)
d1412 1
a1412 1
			LocalBuilder temp = ilgen.DeclareLocal(typeof(object));
d1414 1
a1414 4
			if(DeclaringType.IsNonPrimitiveValueType)
			{
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
			}
a1415 36
			ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
		}
		else
		{
			LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsLocalOrStackType);
			ilgen.Emit(OpCodes.Stloc, temp);
			if(FieldTypeWrapper.IsGhost)
			{
				if(fi.IsStatic)
				{
					ilgen.Emit(OpCodes.Ldsflda, fi);
				}
				else
				{
					if(DeclaringType.IsNonPrimitiveValueType)
					{
						ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
					}
					ilgen.Emit(OpCodes.Ldflda, fi);
				}
				ilgen.Emit(OpCodes.Ldloc, temp);
				ilgen.Emit(OpCodes.Stfld, FieldTypeWrapper.GhostRefField);
			}
			else
			{
				if(DeclaringType.IsNonPrimitiveValueType)
				{
					ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				}
				ilgen.Emit(OpCodes.Ldloc, temp);
				if(FieldTypeWrapper.IsNonPrimitiveValueType)
				{
					FieldTypeWrapper.EmitUnbox(ilgen);
				}
				ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
			}
d1417 1
d1445 2
a1468 10
		else if(constant is byte)
		{
			ilgen.Emit(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
			ilgen.Emit(OpCodes.Box, typeof(byte));
		}
		else if(constant is ushort)
		{
			ilgen.Emit(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
			ilgen.Emit(OpCodes.Box, typeof(ushort));
		}
a1471 1
			ilgen.Emit(OpCodes.Box, typeof(uint));
a1475 1
			ilgen.Emit(OpCodes.Box, typeof(ulong));
a1482 1
				ilgen.Emit(OpCodes.Box, constant.GetType());
a1486 1
				ilgen.Emit(OpCodes.Box, constant.GetType());
d1499 1
@


1.18
log
@*** empty log message ***
@
text
@d174 3
a176 1
	private MethodDescriptor md;
d201 2
a202 2
		internal GhostMethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
			: base(declaringType, md, method, returnType, parameterTypes, modifiers, flags)
d236 1
a236 1
	internal static MethodWrapper Create(TypeWrapper declaringType, MethodDescriptor md, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection)
d238 1
a238 1
		Debug.Assert(declaringType != null && md != null && method != null);
d252 1
a252 1
			return new GhostMethodWrapper(declaringType, md, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None);
d256 1
a256 1
			return new SmartConstructorMethodWrapper(declaringType, md, (ConstructorInfo)method, parameterTypes, modifiers, hideFromReflection);
d260 1
a260 1
			return new SmartCallMethodWrapper(declaringType, md, (MethodInfo)method, returnType, parameterTypes, modifiers, hideFromReflection, OpCodes.Call, method.IsStatic ? OpCodes.Call : OpCodes.Callvirt);
d264 1
a264 1
	internal MethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
d268 2
a269 1
		this.md = md;
a301 8
	internal MethodDescriptor Descriptor
	{
		get
		{
			return md;
		}
	}

d306 1
a306 1
			return md.Name;
d314 1
a314 1
			return md.Signature;
a333 1
				string sig = md.Signature;
d466 1
a466 1
		if(!IsStatic && !IsPrivate && md.Name != "<init>")
d549 1
a549 1
			if(md.Name == "<init>")
d771 1
a771 1
			if(!mw.IsStatic && method.IsStatic && mw.md.Name != "<init>")
d819 15
d838 2
a839 2
	internal SmartMethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
		: base(declaringType, md, method, returnType, parameterTypes, modifiers, flags)
d907 1
a907 3
			// HACK after constructing a new object, we don't want the custom boxing rule to run
			// (because that would turn "new IntPtr" into a null reference)
			ilgen.Emit(OpCodes.Box, DeclaringType.TypeAsTBD);
d917 7
d926 2
a927 2
	private OpCode call;
	private OpCode callvirt;
d929 2
a930 2
	internal SimpleCallMethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection, OpCode call, OpCode callvirt)
		: base(declaringType, md, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
d938 1
a938 1
		ilgen.Emit(call, (MethodInfo)GetMethod());
d943 1
a943 1
		ilgen.Emit(callvirt, (MethodInfo)GetMethod());
d949 2
a950 2
	private OpCode call;
	private OpCode callvirt;
d952 2
a953 2
	internal SmartCallMethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection, OpCode call, OpCode callvirt)
		: this(declaringType, md, method, returnType, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None, call, callvirt)
d957 2
a958 2
	internal SmartCallMethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodInfo method, TypeWrapper returnType, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags, OpCode call, OpCode callvirt)
		: base(declaringType, md, method, returnType, parameterTypes, modifiers, flags)
d966 1
a966 1
		ilgen.Emit(call, (MethodInfo)GetMethod());
d971 1
a971 1
		ilgen.Emit(callvirt, (MethodInfo)GetMethod());
d977 2
a978 2
	internal SmartConstructorMethodWrapper(TypeWrapper declaringType, MethodDescriptor md, ConstructorInfo method, TypeWrapper[] parameterTypes, Modifiers modifiers, MemberFlags flags)
		: base(declaringType, md, method, PrimitiveTypeWrapper.VOID, parameterTypes, modifiers, flags)
d982 2
a983 2
	internal SmartConstructorMethodWrapper(TypeWrapper declaringType, MethodDescriptor md, ConstructorInfo method, TypeWrapper[] parameterTypes, Modifiers modifiers, bool hideFromReflection)
		: base(declaringType, md, method, PrimitiveTypeWrapper.VOID, parameterTypes, modifiers, hideFromReflection ? MemberFlags.HideFromReflection : MemberFlags.None)
d1054 1
a1062 1
		Debug.Assert(fieldType != null);
d1087 1
a1087 1
	// HACK used (thru IKVM.Runtime.Util.GetFieldConstantValue) by ikvmstub to find out if the
d1092 1
a1092 1
		// NOTE only pritimives and string can be literals in Java (because the other "primitives" (like uint),
d1138 8
d1182 1
a1182 1
					this.DeclaringType.LinkField(this);
d1205 2
a1206 1
		if(fieldType.IsUnloadable)
d1208 1
a1208 26
			// TODO we might need to emit code to check the type dynamically
			// TODO the fact that the type is unloadable now, doesn't mean it will be unloadable when a method
			// that accesses this field is compiled, that means that that method may need to emit a cast
		}
		else
		{
			if(fieldType.IsGhost)
			{
				return new GhostFieldWrapper(declaringType, fieldType, fi, name, sig, modifiers);
			}
			if((modifiers & Modifiers.Volatile) != 0)
			{
				// long & double field accesses must be made atomic
				if(fi.FieldType == typeof(long) || fi.FieldType == typeof(double))
				{
					return new VolatileLongDoubleFieldWrapper(declaringType, fieldType, fi, name, sig, modifiers);
				}
			}
		}
		if(declaringType.IsNonPrimitiveValueType)
		{
			return new NonPrimitiveValueTypeFieldWrapper(declaringType, fieldType, fi, name, sig, modifiers);
		}
		else
		{
			return new SimpleFieldWrapper(declaringType, fieldType, fi, name, sig, modifiers);
d1210 1
d1280 1
a1280 3
		Debug.Assert(!declaringType.IsNonPrimitiveValueType);
		Debug.Assert(!fieldType.IsGhost);
		Debug.Assert(fieldType != PrimitiveTypeWrapper.DOUBLE || fieldType != PrimitiveTypeWrapper.LONG || !IsVolatile);
d1285 1
a1285 1
		if(IsVolatile)
d1287 18
a1304 1
			ilgen.Emit(OpCodes.Volatile);
d1306 1
a1306 2
		ilgen.Emit(IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, GetField());
		if(!FieldTypeWrapper.IsUnloadable && FieldTypeWrapper.IsNonPrimitiveValueType)
d1308 13
a1320 1
			FieldTypeWrapper.EmitBox(ilgen);
d1326 1
a1326 1
		if(!FieldTypeWrapper.IsUnloadable && FieldTypeWrapper.IsNonPrimitiveValueType)
d1328 21
a1348 1
			FieldTypeWrapper.EmitUnbox(ilgen);
d1350 1
a1350 1
		if(IsVolatile)
d1352 17
a1368 1
			ilgen.Emit(OpCodes.Volatile);
a1369 1
		ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, GetField());
a1442 105
sealed class GhostFieldWrapper : FieldWrapper
{
	internal GhostFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers)
		: base(declaringType, fieldType, name, sig, modifiers, fi)
	{
		Debug.Assert(fieldType.IsGhost);
	}

	protected override void EmitGetImpl(ILGenerator ilgen)
	{
		FieldInfo fi = GetField();
		if(fi.IsStatic)
		{
			ilgen.Emit(OpCodes.Ldsflda, fi);
		}
		else
		{
			if(DeclaringType.IsNonPrimitiveValueType)
			{
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
			}
			ilgen.Emit(OpCodes.Ldflda, fi);
		}
		if(IsVolatile)
		{
			ilgen.Emit(OpCodes.Volatile);
		}
		ilgen.Emit(OpCodes.Ldfld, FieldTypeWrapper.GhostRefField);
	}

	protected override void EmitSetImpl(ILGenerator ilgen)
	{
		FieldInfo fi = GetField();
		LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsLocalOrStackType);
		ilgen.Emit(OpCodes.Stloc, temp);
		if(fi.IsStatic)
		{
			ilgen.Emit(OpCodes.Ldsflda, fi);
		}
		else
		{
			if(DeclaringType.IsNonPrimitiveValueType)
			{
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
			}
			ilgen.Emit(OpCodes.Ldflda, fi);
		}
		ilgen.Emit(OpCodes.Ldloc, temp);
		if(IsVolatile)
		{
			ilgen.Emit(OpCodes.Volatile);
		}
		ilgen.Emit(OpCodes.Stfld, FieldTypeWrapper.GhostRefField);
	}
}

sealed class NonPrimitiveValueTypeFieldWrapper : FieldWrapper
{
	internal NonPrimitiveValueTypeFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string name, string sig, Modifiers modifiers)
		: base(declaringType, fieldType, name, sig, modifiers, fi)
	{
		Debug.Assert(declaringType.IsNonPrimitiveValueType);
		Debug.Assert(!fieldType.IsGhost);
		Debug.Assert(fieldType != PrimitiveTypeWrapper.DOUBLE || fieldType != PrimitiveTypeWrapper.LONG || !IsVolatile);
	}

	protected override void EmitGetImpl(ILGenerator ilgen)
	{
		if(!IsStatic)
		{
			ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
		}
		if(IsVolatile)
		{
			ilgen.Emit(OpCodes.Volatile);
		}
		ilgen.Emit(IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, GetField());
		if(!FieldTypeWrapper.IsUnloadable && FieldTypeWrapper.IsNonPrimitiveValueType)
		{
			FieldTypeWrapper.EmitBox(ilgen);
		}
	}

	protected override void EmitSetImpl(ILGenerator ilgen)
	{
		if(!IsStatic)
		{
			FieldInfo fi = GetField();
			LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsLocalOrStackType);
			ilgen.Emit(OpCodes.Stloc, temp);
			ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
			ilgen.Emit(OpCodes.Ldloc, temp);
		}
		if(!FieldTypeWrapper.IsUnloadable && FieldTypeWrapper.IsNonPrimitiveValueType)
		{
			FieldTypeWrapper.EmitUnbox(ilgen);
		}
		if(IsVolatile)
		{
			ilgen.Emit(OpCodes.Volatile);
		}
		ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, GetField());
	}
}

d1456 5
@


1.17
log
@*** empty log message ***
@
text
@d1087 4
d1604 1
a1604 1
		// after the referencing class was compiled)
d1611 2
a1612 2
			constant is short || constant is ushort ||
			constant is byte || constant is sbyte ||
a1617 4
		else if(constant is uint)
		{
			ilgen.Emit(OpCodes.Ldc_I4, unchecked((int)((IConvertible)constant).ToUInt32(null)));
		}
d1634 15
d1652 15
@


1.16
log
@*** empty log message ***
@
text
@d587 1
a587 1
						throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
d623 1
a623 1
					throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
d644 1
a644 1
			throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
d1100 1
a1100 1
				return IKVM.NativeCode.java.lang.reflect.JavaWrapper.Box(val);
@


1.15
log
@*** empty log message ***
@
text
@d495 1
d543 1
a1637 20
		else if(constant is Enum)
		{
			Type underlying = Enum.GetUnderlyingType(constant.GetType());
			if(underlying == typeof(long))
			{
				ilgen.Emit(OpCodes.Ldc_I8, ((IConvertible)constant).ToInt64(null));
			}
			if(underlying == typeof(ulong))
			{
				ilgen.Emit(OpCodes.Ldc_I8, unchecked((long)((IConvertible)constant).ToUInt64(null)));
			}
			else if(underlying == typeof(uint))
			{
				ilgen.Emit(OpCodes.Ldc_I4, unchecked((int)((IConvertible)constant).ToUInt32(null)));
			}
			else
			{
				ilgen.Emit(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
			}
		}
d1640 1
a1640 1
			throw new NotImplementedException(constant.GetType().FullName);
@


1.14
log
@*** empty log message ***
@
text
@d1071 1
a1071 1
	// HACK used (indirectly thru IKVM.NativeCode.java.lang.Field.getConstant) by netexp to find out if the
d1078 1
a1078 1
		if(field != null && (fieldType.IsPrimitive || fieldType == CoreClasses.java.lang.String.Wrapper) && field.IsLiteral)
d1080 16
a1095 2
			ReflectionOnConstant.IssueWarning(field);
			object val = field.GetValue(null);
@


1.13
log
@*** empty log message ***
@
text
@d1499 5
a1503 1
		if(FieldTypeWrapper.IsGhost)
d1519 1
a1519 3
		LocalBuilder temp = ilgen.DeclareLocal(FieldTypeWrapper.TypeAsLocalOrStackType);
		ilgen.Emit(OpCodes.Stloc, temp);
		if(FieldTypeWrapper.IsGhost)
d1521 3
a1523 1
			if(fi.IsStatic)
d1525 1
a1525 9
				ilgen.Emit(OpCodes.Ldsflda, fi);
			}
			else
			{
				if(DeclaringType.IsNonPrimitiveValueType)
				{
					ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
				}
				ilgen.Emit(OpCodes.Ldflda, fi);
d1528 1
a1528 1
			ilgen.Emit(OpCodes.Stfld, FieldTypeWrapper.GhostRefField);
d1532 3
a1534 1
			if(DeclaringType.IsNonPrimitiveValueType)
d1536 14
a1549 1
				ilgen.Emit(OpCodes.Unbox, DeclaringType.TypeAsTBD);
d1551 1
a1551 2
			ilgen.Emit(OpCodes.Ldloc, temp);
			if(FieldTypeWrapper.IsNonPrimitiveValueType)
d1553 10
a1562 1
				FieldTypeWrapper.EmitUnbox(ilgen);
a1563 1
			ilgen.Emit(IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
@


1.12
log
@*** empty log message ***
@
text
@d33 2
@


1.11
log
@*** empty log message ***
@
text
@d1271 1
a1271 1
		if(FieldTypeWrapper.IsNonPrimitiveValueType)
d1279 1
a1279 1
		if(FieldTypeWrapper.IsNonPrimitiveValueType)
d1438 1
a1438 1
		if(FieldTypeWrapper.IsNonPrimitiveValueType)
d1454 1
a1454 1
		if(FieldTypeWrapper.IsNonPrimitiveValueType)
@


1.10
log
@*** empty log message ***
@
text
@d1034 1
a1034 1
class FieldWrapper : MemberWrapper
a1037 2
	private readonly CodeEmitter __EmitGet;
	private readonly CodeEmitter __EmitSet;
d1041 1
a1041 1
	internal FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, CodeEmitter emitGet, CodeEmitter emitSet)
d1051 6
a1056 2
		this.__EmitGet = emitGet;
		this.__EmitSet = emitSet;
d1117 1
a1117 4
	protected virtual void EmitGetImpl(ILGenerator ilgen)
	{
		__EmitGet.Emit(ilgen);
	}
d1125 1
a1125 4
	protected virtual void EmitSetImpl(ILGenerator ilgen)
	{
		__EmitSet.Emit(ilgen);
	}
d1159 1
a1159 1
	private class VolatileLongDoubleGetter : CodeEmitter
d1161 1
a1161 5
		private static MethodInfo volatileReadDouble = typeof(System.Threading.Thread).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Double&") });
		private static MethodInfo volatileReadLong = typeof(System.Threading.Thread).GetMethod("VolatileRead", new Type[] { Type.GetType("System.Int64&") });
		private FieldInfo fi;

		internal VolatileLongDoubleGetter(FieldInfo fi)
d1163 3
a1165 1
			this.fi = fi;
d1167 1
a1167 2

		internal override void Emit(ILGenerator ilgen)
d1169 1
a1169 2
			ilgen.Emit(fi.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldflda, fi);
			if(fi.FieldType == typeof(double))
d1171 1
a1171 1
				ilgen.Emit(OpCodes.Call, volatileReadDouble);
d1173 1
a1173 1
			else
d1175 5
a1179 2
				Debug.Assert(fi.FieldType == typeof(long));
				ilgen.Emit(OpCodes.Call, volatileReadLong);
d1182 8
d1192 1
a1192 1
	private class VolatileLongDoubleSetter : CodeEmitter
d1194 13
a1206 3
		private static MethodInfo volatileWriteDouble = typeof(System.Threading.Thread).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Double&"), typeof(double) });
		private static MethodInfo volatileWriteLong = typeof(System.Threading.Thread).GetMethod("VolatileWrite", new Type[] { Type.GetType("System.Int64&"), typeof(long) });
		private FieldInfo fi;
d1208 19
a1226 1
		internal VolatileLongDoubleSetter(FieldInfo fi)
d1228 1
a1228 1
			this.fi = fi;
d1230 1
d1232 5
a1236 1
		internal override void Emit(ILGenerator ilgen)
d1238 11
a1248 13
			LocalBuilder temp = ilgen.DeclareLocal(fi.FieldType);
			ilgen.Emit(OpCodes.Stloc, temp);
			ilgen.Emit(fi.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldflda, fi);
			ilgen.Emit(OpCodes.Ldloc, temp);
			if(fi.FieldType == typeof(double))
			{
				ilgen.Emit(OpCodes.Call, volatileWriteDouble);
			}
			else
			{
				Debug.Assert(fi.FieldType == typeof(long));
				ilgen.Emit(OpCodes.Call, volatileWriteLong);
			}
d1250 1
d1252 1
d1254 4
a1257 1
	private class ValueTypeFieldSetter : CodeEmitter
d1259 4
a1262 2
		private Type declaringType;
		private Type fieldType;
d1264 3
a1266 1
		internal ValueTypeFieldSetter(Type declaringType, Type fieldType)
d1268 1
a1268 2
			this.declaringType = declaringType;
			this.fieldType = fieldType;
d1270 2
a1271 2

		internal override void Emit(ILGenerator ilgen)
d1273 1
a1273 4
			LocalBuilder local = ilgen.DeclareLocal(fieldType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(OpCodes.Unbox, declaringType);
			ilgen.Emit(OpCodes.Ldloc, local);
d1277 1
a1277 1
	private class GhostFieldSetter : CodeEmitter
d1279 1
a1279 5
		private OpCode ldflda;
		private FieldInfo field;
		private TypeWrapper type;

		internal GhostFieldSetter(FieldInfo field, TypeWrapper type, OpCode ldflda)
d1281 1
a1281 3
			this.field = field;
			this.type = type;
			this.ldflda = ldflda;
d1283 1
a1283 2

		internal override void Emit(ILGenerator ilgen)
d1285 1
a1285 5
			LocalBuilder local = ilgen.DeclareLocal(type.TypeAsLocalOrStackType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(ldflda, field);
			ilgen.Emit(OpCodes.Ldloc, local);
			ilgen.Emit(OpCodes.Stfld, type.GhostRefField);
d1287 1
d1289 8
d1298 2
a1299 1
	internal static FieldWrapper Create1(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo fi, CodeEmitter getter, CodeEmitter setter)
d1301 2
a1302 1
		return new FieldWrapper(declaringType, fieldType, name, sig, modifiers, fi, getter, setter);
d1305 1
a1305 1
	internal static FieldWrapper Create3(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string sig, Modifiers modifiers)
d1307 2
a1308 3
		CodeEmitter emitGet = null;
		CodeEmitter emitSet = null;
		if(declaringType.IsNonPrimitiveValueType)
d1310 1
a1310 3
			// NOTE all that ValueTypeFieldSetter does, is unbox the boxed value type that contains the field that we are setting
			emitSet = new ValueTypeFieldSetter(declaringType.TypeAsTBD, fieldType.TypeAsTBD);
			emitGet = CodeEmitter.Create(OpCodes.Unbox, declaringType.TypeAsTBD);
d1312 1
a1312 1
		if(fieldType.IsUnloadable)
d1314 1
a1314 4
			// TODO we might need to emit code to check the type dynamically
			// TODO the fact that the type is unloadable now, doesn't mean it will be unloadable when a method
			// that accesses this field is compiled, that means that that method (may) need to emit a cast
			if((modifiers & Modifiers.Static) != 0)
d1316 1
a1316 2
				emitGet += CodeEmitter.Create(OpCodes.Ldsfld, fi);
				emitSet += CodeEmitter.Create(OpCodes.Stsfld, fi);
d1318 25
a1342 1
			else
d1344 1
a1344 2
				emitGet += CodeEmitter.Create(OpCodes.Ldfld, fi);
				emitSet += CodeEmitter.Create(OpCodes.Stfld, fi);
d1346 1
a1346 1
			return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, fi, emitGet, emitSet);
d1348 29
a1376 1
		if(fieldType.IsGhost)
d1378 1
a1378 1
			if((modifiers & Modifiers.Static) != 0)
d1380 1
a1380 2
				emitGet += CodeEmitter.Create(OpCodes.Ldsflda, fi) + CodeEmitter.Create(OpCodes.Ldfld, fieldType.GhostRefField);
				emitSet += new GhostFieldSetter(fi, fieldType, OpCodes.Ldsflda);
d1382 5
a1386 6
			else
			{
				emitGet += CodeEmitter.Create(OpCodes.Ldflda, fi) + CodeEmitter.Create(OpCodes.Ldfld, fieldType.GhostRefField);
				emitSet += new GhostFieldSetter(fi, fieldType, OpCodes.Ldflda);
			}
			return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, fi, emitGet, emitSet);
d1388 9
a1396 1
		if(fieldType.IsNonPrimitiveValueType)
d1398 1
a1398 1
			emitSet += CodeEmitter.CreateEmitUnboxCall(fieldType);
d1400 1
a1400 1
		if((modifiers & Modifiers.Volatile) != 0)
d1402 1
a1402 2
			// long & double field accesses must be made atomic
			if(fi.FieldType == typeof(long) || fi.FieldType == typeof(double))
d1404 1
a1404 4
				// TODO shouldn't we use += here (for volatile fields inside of value types)?
				emitGet = new VolatileLongDoubleGetter(fi);
				emitSet = new VolatileLongDoubleSetter(fi);
				return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, fi, emitGet, emitSet);
d1406 6
a1411 2
			emitGet += CodeEmitter.Volatile;
			emitSet += CodeEmitter.Volatile;
d1413 17
a1429 1
		if((modifiers & Modifiers.Static) != 0)
d1431 1
a1431 2
			emitGet += CodeEmitter.Create(OpCodes.Ldsfld, fi);
			emitSet += CodeEmitter.Create(OpCodes.Stsfld, fi);
d1433 1
a1433 1
		else
d1435 1
a1435 2
			emitGet += CodeEmitter.Create(OpCodes.Ldfld, fi);
			emitSet += CodeEmitter.Create(OpCodes.Stfld, fi);
d1437 2
a1438 1
		if(fieldType.IsNonPrimitiveValueType)
d1440 1
a1440 1
			emitGet += CodeEmitter.CreateEmitBoxCall(fieldType);
a1441 1
		return new FieldWrapper(declaringType, fieldType, fi.Name, sig, modifiers, fi, emitGet, emitSet);
d1444 1
a1444 1
	private void LookupField()
d1446 9
a1454 2
		BindingFlags bindings = BindingFlags.Public | BindingFlags.NonPublic;
		if(IsStatic)
d1456 1
a1456 1
			bindings |= BindingFlags.Static;
d1458 1
a1458 1
		else
d1460 1
a1460 1
			bindings |= BindingFlags.Instance;
d1462 15
a1476 3
		// TODO instead of looking up the field by name, we should use the Token to find it.
		field = DeclaringType.TypeAsTBD.GetField(name, bindings);
		Debug.Assert(field != null);
d1479 1
a1479 1
	internal virtual void SetValue(object obj, object val)
d1481 1
a1481 3
		AssertLinked();
		// TODO this is a broken implementation (for one thing, it needs to support redirection)
		if(field == null || field is FieldBuilder)
d1483 1
a1483 1
			LookupField();
d1485 1
a1485 1
		if(fieldType.IsGhost)
d1487 9
a1495 3
			object temp = field.GetValue(obj);
			fieldType.GhostRefField.SetValue(temp, val);
			val = temp;
d1497 1
a1497 1
		try
d1499 4
a1502 1
			field.SetValue(obj, val);
d1504 1
a1504 1
		catch(FieldAccessException x)
d1506 1
a1506 1
			throw JavaException.IllegalAccessException(x.Message);
d1510 1
a1510 1
	internal virtual object GetValue(object obj)
d1512 4
a1515 3
		AssertLinked();
		// TODO this is a broken implementation (for one thing, it needs to support redirection)
		if(field == null || field is FieldBuilder)
d1517 14
a1530 1
			LookupField();
d1532 1
a1532 1
		if(field.IsLiteral)
d1534 10
a1543 7
			// on a non-broken CLR GetValue on a literal will not trigger type initialization, but on Java it should
			System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(field.DeclaringType.TypeHandle);
		}
		object val = field.GetValue(obj);
		if(fieldType.IsGhost)
		{
			val = fieldType.GhostRefField.GetValue(val);
a1544 1
		return val;
d1546 1
d1548 8
a1555 3
	// NOTE this type is only used for remapped fields, dynamically compiled classes are always finished before we
	// allow reflection (so we can look at the underlying field in that case)
	internal sealed class ConstantFieldWrapper : FieldWrapper
d1557 2
a1558 2
		private object constant;
		private CodeEmitter emitGet;
d1560 7
a1566 2
		internal ConstantFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, object constant)
			: base(declaringType, fieldType, name, sig, modifiers, field, null, null)
d1568 1
a1568 2
			this.constant = constant;
			emitGet = CodeEmitter.CreateLoadConstant(constant);
d1570 29
a1598 2

		protected override void EmitGetImpl(ILGenerator ilgen)
d1600 1
a1600 4
			// NOTE even though you're not supposed to access a constant static final (the compiler is supposed
			// to inline them), we have to support it (because it does happen, e.g. if the field becomes final
			// after the referencing class was compiled)
			emitGet.Emit(ilgen);
d1602 21
a1622 2

		protected override void EmitSetImpl(ILGenerator ilgen)
d1624 1
a1624 3
			// when constant static final fields are updated, the JIT normally doesn't see that (because the
			// constant value is inlined), so we emulate that behavior by emitting a Pop
			ilgen.Emit(OpCodes.Pop);
d1626 1
d1628 10
a1637 1
		internal override object GetValue(object obj)
d1639 1
a1639 1
			return constant;
d1641 1
@


1.9
log
@*** empty log message ***
@
text
@d29 3
d280 1
a280 1
	internal void SetDeclaredExceptions(MapXml.Throws[] throws)
d1067 1
a1067 1
	// HACK used (indirectly thru NativeCode.java.lang.Field.getConstant) by netexp to find out if the
d1080 1
a1080 1
				return NativeCode.java.lang.reflect.JavaWrapper.Box(val);
@


1.8
log
@*** empty log message ***
@
text
@d198 1
a198 1
			Debug.Assert(method.DeclaringType.IsInterface);
d684 10
a693 2
			AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
			module = ab.DefineDynamicModule("NonvirtualInvoker");
@


1.7
log
@*** empty log message ***
@
text
@d1138 1
@


1.6
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002 Jeroen Frijters
d25 1
d30 8
d43 1
a43 1
	private bool hideFromReflection;
d46 5
d55 1
a55 1
		this.hideFromReflection = hideFromReflection;
d94 8
d106 9
a114 1
			return hideFromReflection;
d167 1
a167 1
class MethodWrapper : MemberWrapper
d172 2
a173 3
	internal CodeEmitter EmitCall;
	internal CodeEmitter EmitCallvirt;
	internal CodeEmitter EmitNewobj;
d175 1
a175 1
	internal class GhostUnwrapper : CodeEmitter
d177 2
a178 1
		private TypeWrapper type;
d180 4
a183 4
		internal GhostUnwrapper(TypeWrapper type)
		{
			this.type = type;
		}
d185 3
a187 7
		internal override void Emit(ILGenerator ilgen)
		{
			LocalBuilder local = ilgen.DeclareLocal(type.TypeAsParameterType);
			ilgen.Emit(OpCodes.Stloc, local);
			ilgen.Emit(OpCodes.Ldloca, local);
			ilgen.Emit(OpCodes.Ldfld, type.GhostRefField);
		}
d190 1
a190 1
	internal static MethodWrapper Create(TypeWrapper declaringType, MethodDescriptor md, MethodBase method, Modifiers modifiers, bool hideFromReflection)
d192 1
a192 1
		Debug.Assert(declaringType != null && md != null && method != null);
d194 2
a195 2
		MethodWrapper wrapper = new MethodWrapper(declaringType, md, method, modifiers, hideFromReflection);
		if(declaringType.IsGhost)
d197 2
a198 3
			wrapper.EmitCall = CodeEmitter.InternalError;
			wrapper.EmitCallvirt = new GhostCallEmitter(declaringType, md, method);
			wrapper.EmitNewobj = CodeEmitter.InternalError;
d200 2
a201 1
		else
d203 1
a203 1
			if(method is ConstructorInfo)
d205 2
a206 16
				wrapper.EmitCall = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)method);
				wrapper.EmitCallvirt = CodeEmitter.InternalError;
				wrapper.EmitNewobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)method);
			}
			else
			{
				if(md.Name == "<init>")
				{
					// we're a redirected constructor (which means that the class is final),
					// so EmitCall isn't available. This also means that we won't be able to invoke
					// the constructor using reflection (on an existing instance).
					wrapper.EmitCall = CodeEmitter.InternalError;
					wrapper.EmitCallvirt = CodeEmitter.InternalError;
					wrapper.EmitNewobj = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
				}
				else
d208 1
a208 19
					wrapper.EmitCall = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
					if(method.IsStatic)
					{
						// because of redirection, it can be legal to call a static method with invokevirtual
						if(!wrapper.IsStatic)
						{
							// we don't do a null pointer check on "this", the callee is responsible for that
							wrapper.EmitCallvirt = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
						}
						else
						{
							wrapper.EmitCallvirt = CodeEmitter.InternalError;
						}
					}
					else
					{
						wrapper.EmitCallvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)method);
					}
					wrapper.EmitNewobj = CodeEmitter.InternalError;
d212 2
a213 2
		TypeWrapper retType = md.RetTypeWrapper;
		if(!retType.IsUnloadable)
d215 2
a216 10
			if(retType.IsNonPrimitiveValueType)
			{
				wrapper.EmitCall += CodeEmitter.CreateEmitBoxCall(retType);
				wrapper.EmitCallvirt += CodeEmitter.CreateEmitBoxCall(retType);
			}
			else if(retType.IsGhost)
			{
				wrapper.EmitCall += new GhostUnwrapper(retType);
				wrapper.EmitCallvirt += new GhostUnwrapper(retType);
			}
d218 2
a219 1
		if(declaringType.IsNonPrimitiveValueType)
d221 5
a225 11
			if(method is ConstructorInfo)
			{
				// HACK after constructing a new object, we don't want the custom boxing rule to run
				// (because that would turn "new IntPtr" into a null reference)
				wrapper.EmitNewobj += CodeEmitter.Create(OpCodes.Box, declaringType.TypeAsTBD);
			}
			else
			{
				// callvirt isn't allowed on a value type
				wrapper.EmitCallvirt = wrapper.EmitCall;
			}
a226 1
		return wrapper;
d229 1
a229 1
	internal class GhostCallEmitter : CodeEmitter
d231 1
a231 3
		private MethodDescriptor md;
		private TypeWrapper type;
		private MethodInfo method;
d233 15
a247 1
		internal GhostCallEmitter(TypeWrapper type, MethodDescriptor md, MethodBase __method)
d249 1
a249 2
			this.type = type;
			this.md = md;
d251 1
a251 2

		internal override void Emit(ILGenerator ilgen)
d253 1
a253 5
			if(method == null)
			{
				method = type.TypeAsParameterType.GetMethod(md.Name, md.ArgTypesForDefineMethod);
			}
			ilgen.Emit(OpCodes.Call, method);
d257 2
a258 2
	internal MethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase method, Modifiers modifiers, bool hideFromReflection)
		: base(declaringType, modifiers, hideFromReflection)
d263 3
d310 9
a318 1
	internal bool HasUnloadableArgsOrRet
d322 9
a330 5
			if(ReturnType.IsUnloadable)
			{
				return true;
			}
			foreach(TypeWrapper tw in GetParameters())
d332 8
a339 1
				if(tw.IsUnloadable)
d341 12
a352 1
					return true;
a354 1
			return false;
d358 10
d372 2
a373 1
			return md.RetTypeWrapper;
d379 21
a399 1
		return md.ArgTypeWrappers;
d429 1
d437 1
d492 1
d510 1
a510 1
				throw new InvalidOperationException("Failed to fixate method: " + this.DeclaringType.Name + "." + this.Name + this.Descriptor.Signature);
d529 1
a529 1
				throw new InvalidOperationException("Failed to fixate constructor: " + this.DeclaringType.Name + "." + this.Name + this.Descriptor.Signature);
d535 2
d604 14
a617 2
				// TODO figure out how to implement this (one way would be to generate some code on the fly)
				throw new NotImplementedException("non-virtual reflective method invocation not implemented");
d624 1
a624 1
			TypeWrapper retType = md.RetTypeWrapper;
d627 1
a627 1
				o = md.RetTypeWrapper.GhostRefField.GetValue(o);
d641 112
d760 1
a760 8
			TypeWrapper[] argTypes = mw.md.ArgTypeWrappers;

			if(!mw.IsStatic && mw.DeclaringType.IsGhost)
			{
				object o = Activator.CreateInstance(mw.DeclaringType.TypeAsParameterType);
				mw.DeclaringType.GhostRefField.SetValue(o, original_obj);
				original_obj = o;
			}
d812 157
d971 1
a971 1
class ReflectionOnConstant
d1027 2
a1028 2
	internal readonly CodeEmitter EmitGet;
	internal readonly CodeEmitter EmitSet;
a1037 2
		Debug.Assert(emitGet != null);
		Debug.Assert(emitSet != null);
d1042 12
a1053 2
		this.EmitGet = emitGet;
		this.EmitSet = emitSet;
d1060 1
d1093 1
d1098 45
d1249 1
a1249 1
	internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo fi, CodeEmitter getter, CodeEmitter setter)
d1254 1
a1254 13
	internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo fi, CodeEmitter getter, CodeEmitter setter, object constant)
	{
		if(constant != null)
		{
			return new ConstantFieldWrapper(declaringType, fieldType, name, sig, modifiers, fi, getter, setter, constant);
		}
		else
		{
			return new FieldWrapper(declaringType, fieldType, name, sig, modifiers, fi, getter, setter);
		}
	}

	internal static FieldWrapper Create(TypeWrapper declaringType, TypeWrapper fieldType, FieldInfo fi, string sig, Modifiers modifiers)
d1347 1
d1371 1
d1392 1
a1392 1
	private class ConstantFieldWrapper : FieldWrapper
d1395 1
d1397 2
a1398 2
		internal ConstantFieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, CodeEmitter emitGet, CodeEmitter emitSet, object constant)
			: base(declaringType, fieldType, name, sig, modifiers, field, emitGet, emitSet)
d1401 16
@


1.5
log
@*** empty log message ***
@
text
@d146 1
a146 1
	private class GhostUnwrapper : CodeEmitter
d377 1
d704 1
a704 1
	private FieldWrapper(TypeWrapper declaringType, TypeWrapper fieldType, string name, string sig, Modifiers modifiers, FieldInfo field, CodeEmitter emitGet, CodeEmitter emitSet)
d974 1
a974 1
	internal void SetValue(object obj, object val)
@


1.4
log
@*** empty log message ***
@
text
@d363 1
a363 1
		if(!(method is MethodBuilder))
@


1.3
log
@*** empty log message ***
@
text
@a530 1
					// HACK special case for deserialization of java.lang.Throwable subclasses
d533 3
a535 2
						// TODO this isn't the right constructor. We should be calling Exception(ExceptionHelper.get_NullString()).
						method = typeof(System.Exception).GetConstructor(Type.EmptyTypes);
@


1.2
log
@*** empty log message ***
@
text
@d528 18
d968 1
@


1.1
log
@*** empty log message ***
@
text
@d140 1
a140 2
	private MethodBase originalMethod;
	private MethodBase redirMethod;
d164 1
a164 2
	// TODO creation of MethodWrappers should be cleaned up (and every instance should support Invoke())
	internal static MethodWrapper Create(TypeWrapper declaringType, MethodDescriptor md, MethodBase originalMethod, MethodBase method, Modifiers modifiers, bool hideFromReflection)
d166 1
a166 1
		Debug.Assert(method != null);
d168 1
a168 1
		MethodWrapper wrapper = new MethodWrapper(declaringType, md, originalMethod, method, modifiers, hideFromReflection);
d171 3
a173 1
			wrapper.EmitCallvirt = new GhostCallEmitter(declaringType, md, originalMethod);
d177 40
a216 1
			CreateEmitters(originalMethod, method, ref wrapper.EmitCall, ref wrapper.EmitCallvirt, ref wrapper.EmitNewobj);
d271 1
a271 31
	internal static void CreateEmitters(MethodBase originalMethod, MethodBase method, ref CodeEmitter call, ref CodeEmitter callvirt, ref CodeEmitter newobj)
	{
		if(method is ConstructorInfo)
		{
			call = CodeEmitter.Create(OpCodes.Call, (ConstructorInfo)method);
			callvirt = null;
			newobj = CodeEmitter.Create(OpCodes.Newobj, (ConstructorInfo)method);
		}
		else
		{
			call = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
			if(originalMethod != null && originalMethod != method)
			{
				// if we're calling a virtual method that is redirected, that overrides an already
				// existing method, we have to call it virtually, instead of redirecting
				callvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)originalMethod);
			}
			else if(method.IsStatic)
			{
				// because of redirection, it can be legal to call a static method with invokevirtual
				callvirt = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
			}
			else
			{
				callvirt = CodeEmitter.Create(OpCodes.Callvirt, (MethodInfo)method);
			}
			newobj = CodeEmitter.Create(OpCodes.Call, (MethodInfo)method);
		}
	}

	internal MethodWrapper(TypeWrapper declaringType, MethodDescriptor md, MethodBase originalMethod, MethodBase method, Modifiers modifiers, bool hideFromReflection)
a274 5
		if(method != originalMethod)
		{
			redirMethod = method;
			Debug.Assert(!(method is MethodBuilder));
		}
d276 1
a276 2
		// NOTE originalMethod may be null
		this.originalMethod = originalMethod;
d360 4
a363 2
		// NOTE if originalMethod is a MethodBuilder, GetCustomAttributes doesn't work
		if(originalMethod != null && !(originalMethod is MethodBuilder))
d365 1
a365 1
			object[] attributes = originalMethod.GetCustomAttributes(typeof(ThrowsAttribute), false);
d376 1
a376 1
	// for remapped types, this is the method that underlies the remapped method
d379 1
a379 1
		return originalMethod;
d386 1
a386 1
			return originalMethod.Name;
d440 2
a441 4
		// TODO if any of the parameters is a ghost, convert the passed in reference to a ghost value type
		// TODO instead of looking up the method using reflection, we should use the method object passed into the
		// constructor
		if(IsStatic)
d443 13
a455 2
			MethodInfo method = this.originalMethod != null && !(this.originalMethod is MethodBuilder) ? (MethodInfo)this.originalMethod : DeclaringType.TypeAsTBD.GetMethod(md.Name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypesDontUse, null);
			try
d457 1
a457 1
				return method.Invoke(null, args);
d459 7
a465 1
			catch(ArgumentException x1)
d467 6
a472 1
				throw JavaException.IllegalArgumentException(x1.Message);
d474 1
a474 1
			catch(TargetInvocationException x)
d476 1
a476 1
				throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
d479 12
a492 2
			// calling <init> without an instance means that we're constructing a new instance
			// NOTE this means that we cannot detect a NullPointerException when calling <init>
d495 1
a495 2
				ConstructorInfo constructor = this.originalMethod != null && !(this.originalMethod is ConstructorBuilder) ? (ConstructorInfo)this.originalMethod : DeclaringType.TypeAsTBD.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, CallingConventions.Standard, md.ArgTypesDontUse, null);
				try
d497 4
d503 3
a505 1
						return constructor.Invoke(obj, args);
d507 17
a523 1
					else
d525 1
a525 1
						return constructor.Invoke(args);
a527 8
				catch(ArgumentException x1)
				{
					throw JavaException.IllegalArgumentException(x1.Message);
				}
				catch(TargetInvocationException x)
				{
					throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
				}
d529 1
a529 1
			if(nonVirtual)
d531 1
d534 39
a572 2
			MethodInfo method = (MethodInfo)this.originalMethod;
			if(redirMethod != null)
d574 7
a580 2
				method = (MethodInfo)redirMethod;
				if(method.IsStatic)
d582 6
a587 6
					// we've been redirected to a static method, so we have to copy the this into the args
					object[] oldargs = args;
					args = new object[args.Length + 1];
					args[0] = obj;
					oldargs.CopyTo(args, 1);
					obj = null;
d592 3
a594 1
				if(method is MethodBuilder || method == null)
d596 10
a605 5
					method = DeclaringType.TypeAsTBD.GetMethod(md.Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, md.ArgTypesDontUse, null);
				}
				if(method == null)
				{
					throw new NotImplementedException("method not found: " + this.DeclaringType.Name + "." + md.Name + md.Signature);
d608 10
a617 12
			try
			{
				return method.Invoke(obj, args);
			}
			catch(ArgumentException x1)
			{
				throw JavaException.IllegalArgumentException(x1.Message);
			}
			catch(TargetInvocationException x)
			{
				throw JavaException.InvocationTargetException(ExceptionHelper.MapExceptionFast(x.InnerException));
			}
@

