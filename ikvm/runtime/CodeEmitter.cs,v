head	1.95;
access;
symbols
	v8_1_5717_0:1.94
	v8_1:1.94.0.2
	v8_0_5449_1:1.93
	v8_0_5449_0:1.93
	v8_0:1.93.0.2
	v7_4_5196_0:1.92
	v7_4:1.92.0.2
	v7_3:1.90.0.2
	v7_2_4630_6:1.89
	v7_2_4630_5:1.89
	v7_2_4630_4:1.89
	v7_2_4630_3:1.89
	v7_2_4630_2:1.89
	v0_46_0_4:1.81
	v7_2_4630_1:1.89
	v7_2:1.89.0.2
	v7_1_4532_2:1.82
	v7_1_4532_1:1.82
	v7_1_4532_0:1.82
	v7_1:1.82.0.4
	v7_0_4335_3:1.82
	v7_0_4335_2:1.82
	v7_0_4335_1:1.82
	v0_46_0_2:1.81
	v7_0_4335_0:1.82
	v7_0:1.82.0.2
	v0_40_0_6:1.33
	v0_40_0_5:1.33
	v0_46_0_1:1.81
	v0_46_0_0:1.81
	v0_46:1.81.0.2
	v0_36_0_14:1.23.2.2
	v0_44_0_6:1.47.2.1
	v0_44_0_5:1.47
	v0_44_0_4:1.47
	v0_44_0_3:1.47
	v0_44_0_2:1.47
	v0_42_0_7:1.41
	v0_44_0_1:1.47
	v0_44_0_0:1.47
	v0_44:1.47.0.2
	v0_42_0_6:1.41
	v0_42_0_5:1.41
	v0_42_0_4:1.41
	v0_42_0_3:1.41
	v0_42_0_2:1.41
	v0_42_0_1:1.41
	v0_42_0_0:1.41
	v0_42:1.41.0.2
	v0_40_0_3:1.33
	v0_40_0_2:1.33
	v0_40_0_1:1.33
	v0_40_0_0:1.33
	v0_40:1.33.0.2
	v0_36_0_13:1.23.2.2
	v0_38_0_1:1.28
	v0_38_0_0:1.28
	v0_38:1.28.0.2
	v0_36_0_9:1.23.2.1
	v0_36_0_7:1.23
	v0_36_0_5:1.23
	v0_36_0_4:1.23
	v0_36_0_3:1.23
	v0_36_0_2:1.23
	v0_36_0_1:1.23
	v0_36_0_0:1.23
	v0_36:1.23.0.2
	v0_34_0_3:1.22
	v0_34_0_2:1.22
	v0_34_0_1:1.22
	v0_34_0_0:1.22
	v0_34:1.22.0.4
	v0_32:1.22.0.2
	v0_32_0_0:1.22
	v0_30:1.20.0.2
	v0_28_0_0:1.20
	v0_26_0_1:1.17
	v0_26_0_0:1.17
	v0_24_0_1:1.17
	v0_24_0_0:1.17
	v0_22_0_0:1.12
	v0_20_0_0:1.12
	v0_18_0_0:1.10
	v0_16_0_0:1.10
	v0_14_0_1:1.8
	v0_14_0_0:1.8
	v0_12_0_0:1.8
	v0_10_0_1:1.8
	v0_10_0_0:1.8
	v0_8_0_0:1.1;
locks; strict;
comment	@ * @;


1.95
date	2015.10.15.11.35.33;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2015.06.19.15.09.45;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2014.05.22.12.08.07;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2014.03.03.16.39.40;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2014.02.21.07.45.10;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2012.09.13.13.21.35;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2012.08.06.13.01.41;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2012.07.08.07.57.16;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2012.07.04.09.36.06;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2012.07.03.14.45.51;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2012.06.29.15.08.56;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2012.06.29.13.54.48;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2012.06.20.09.49.02;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2011.08.15.16.28.08;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2011.02.14.06.04.14;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2011.02.14.05.58.49;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2010.11.20.07.35.26;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2010.11.19.08.13.57;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2010.10.22.11.47.15;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2010.10.21.12.20.13;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2010.10.13.06.36.48;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2010.10.11.05.46.28;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2010.10.11.05.41.22;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2010.10.11.05.39.27;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2010.10.11.04.58.10;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2010.10.08.14.15.13;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2010.10.08.12.14.43;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2010.10.08.08.06.54;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2010.10.07.07.12.35;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2010.10.07.07.09.58;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2010.10.07.06.30.26;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2010.10.07.06.11.18;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2010.10.07.06.07.19;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2010.10.07.06.04.35;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2010.10.01.09.22.47;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2010.10.01.08.11.49;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2010.10.01.06.40.49;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2010.10.01.04.41.06;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.30.15.15.34;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2010.09.30.10.04.54;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.30.08.56.59;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.30.08.05.30;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2010.09.30.07.31.27;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.30.06.00.40;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2010.09.30.04.03.33;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.29.07.21.51;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2010.09.29.05.38.12;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.28.08.02.07;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2010.01.28.09.18.34;	author jfrijters;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2010.01.25.07.52.58;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2009.11.06.07.46.39;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.06.05.13.37;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.23.05.58.41;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.14.14.58.41;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2009.08.31.05.02.35;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.14.13.36.53;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2009.08.13.07.16.19;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.14.07.25.46;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.13.08.34.37;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2009.04.06.10.14.47;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2009.04.06.10.10.17;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.04.05.47.19;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.02.06.31.55;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.02.04.52.05;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.27.06.17.06;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2008.11.14.08.42.07;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2008.08.15.12.01.19;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2008.08.13.13.05.43;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.12.14.57.04;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.03.12.10.26;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2008.02.15.15.32.51;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.12.09.47.40;	author jfrijters;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2006.11.27.07.39.31;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.29.06.28.34;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.04.08.09.56;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.10.10.18.49;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.02.10.59.51;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.29.15.48.32;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.20.12.44.29;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.19.15.12.50;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.22.12.50.42;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.20.07.26.10;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.19.10.44.53;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.01.09.49.30;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.23.17.46.41;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.04.12.50.33;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.19.13.43.56;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.04.19.30.54;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.27.07.12.12;	author jfrijters;	state Exp;
branches;
next	;

1.23.2.1
date	2008.02.20.14.24.40;	author jfrijters;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2008.03.14.07.43.17;	author jfrijters;	state Exp;
branches;
next	;

1.47.2.1
date	2010.10.22.07.30.32;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.95
log
@Simplified and optimized OptimizeLdcI8.
@
text
@/*
  Copyright (C) 2002-2012 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
//#define LABELCHECK
#define CHECK_INVARIANTS
using System;
using System.Collections.Generic;
#if STATIC_COMPILER
using IKVM.Reflection;
using IKVM.Reflection.Emit;
using Type = IKVM.Reflection.Type;
#else
using System.Reflection;
using System.Reflection.Emit;
#endif
using System.Runtime.InteropServices;
using System.Diagnostics.SymbolStore;
using System.Diagnostics;

namespace IKVM.Internal
{
	sealed class CodeEmitterLabel
	{
		internal readonly Label Label;
		internal int Temp;

		internal CodeEmitterLabel(Label label)
		{
			this.Label = label;
		}
	}

	sealed class CodeEmitterLocal
	{
		private Type type;
		private string name;
		private LocalBuilder local;

		internal CodeEmitterLocal(Type type)
		{
			this.type = type;
		}

		internal Type LocalType
		{
			get { return type; }
		}

		internal void SetLocalSymInfo(string name)
		{
			this.name = name;
		}

		internal int __LocalIndex
		{
			get { return local == null ? 0xFFFF : local.LocalIndex; }
		}

		internal void Emit(ILGenerator ilgen, OpCode opcode)
		{
			if (local == null)
			{
				// it's a temporary local that is only allocated on-demand
				local = ilgen.DeclareLocal(type);
			}
			ilgen.Emit(opcode, local);
		}

		internal void Declare(ILGenerator ilgen)
		{
			local = ilgen.DeclareLocal(type);
			if (name != null)
			{
				local.SetLocalSymInfo(name);
			}
		}
	}

	sealed class CodeEmitter
	{
		private static readonly MethodInfo objectToString = Types.Object.GetMethod("ToString", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
		private static readonly MethodInfo verboseCastFailure = JVM.SafeGetEnvironmentVariable("IKVM_VERBOSE_CAST") == null ? null : ByteCodeHelperMethods.VerboseCastFailure;
		private static readonly MethodInfo monitorEnter = JVM.Import(typeof(System.Threading.Monitor)).GetMethod("Enter", BindingFlags.Public | BindingFlags.Static, null, new Type[] { Types.Object }, null);
		private static readonly MethodInfo monitorExit = JVM.Import(typeof(System.Threading.Monitor)).GetMethod("Exit", BindingFlags.Public | BindingFlags.Static, null, new Type[] { Types.Object }, null);
		private static readonly bool experimentalOptimizations = JVM.SafeGetEnvironmentVariable("IKVM_EXPERIMENTAL_OPTIMIZATIONS") != null;
		private static MethodInfo memoryBarrier;
		private ILGenerator ilgen_real;
#if !STATIC_COMPILER
		private bool inFinally;
		private Stack<bool> exceptionStack = new Stack<bool>();
#endif
		private IKVM.Attributes.LineNumberTableAttribute.LineNumberWriter linenums;
		private CodeEmitterLocal[] tempLocals = new CodeEmitterLocal[32];
		private ISymbolDocumentWriter symbols;
		private List<OpCodeWrapper> code = new List<OpCodeWrapper>(10);
		private readonly Type declaringType;
#if LABELCHECK
		private Dictionary<CodeEmitterLabel, System.Diagnostics.StackFrame> labels = new Dictionary<CodeEmitterLabel, System.Diagnostics.StackFrame>();
#endif

		static CodeEmitter()
		{
			if (experimentalOptimizations)
			{
				Console.Error.WriteLine("IKVM.NET experimental optimizations enabled.");
			}
		}

		enum CodeType : short
		{
			Unreachable,
			OpCode,
			BeginScope,
			EndScope,
			DeclareLocal,
			ReleaseTempLocal,
			SequencePoint,
			LineNumber,
			Label,
			BeginExceptionBlock,
			BeginCatchBlock,
			BeginFaultBlock,
			BeginFinallyBlock,
			EndExceptionBlock,
			MemoryBarrier,
			TailCallPrevention,
			ClearStack,
			MonitorEnter,
			MonitorExit,
		}

		enum CodeTypeFlags : short
		{
			None = 0,
			EndFaultOrFinally = 1,
		}

		struct OpCodeWrapper
		{
			internal readonly CodeType pseudo;
			private readonly CodeTypeFlags flags;
			internal readonly OpCode opcode;
			private readonly object data;

			internal OpCodeWrapper(CodeType pseudo, object data)
			{
				this.pseudo = pseudo;
				this.flags = CodeTypeFlags.None;
				this.opcode = OpCodes.Nop;
				this.data = data;
			}

			internal OpCodeWrapper(CodeType pseudo, CodeTypeFlags flags)
			{
				this.pseudo = pseudo;
				this.flags = flags;
				this.opcode = OpCodes.Nop;
				this.data = null;
			}

			internal OpCodeWrapper(OpCode opcode, object data)
			{
				this.pseudo = CodeType.OpCode;
				this.flags = CodeTypeFlags.None;
				this.opcode = opcode;
				this.data = data;
			}

			internal bool Match(OpCodeWrapper other)
			{
				return other.pseudo == pseudo
					&& other.opcode == opcode
					&& (other.data == data || (data != null && data.Equals(other.data)));
			}

			internal bool HasLabel
			{
				get { return data is CodeEmitterLabel; }
			}

			internal CodeEmitterLabel Label
			{
				get { return (CodeEmitterLabel)data; }
			}

			internal bool MatchLabel(OpCodeWrapper other)
			{
				return data == other.data;
			}

			internal CodeEmitterLabel[] Labels
			{
				get { return (CodeEmitterLabel[])data; }
			}

			internal bool HasLocal
			{
				get { return data is CodeEmitterLocal; }
			}

			internal CodeEmitterLocal Local
			{
				get { return (CodeEmitterLocal)data; }
			}

			internal bool MatchLocal(OpCodeWrapper other)
			{
				return data == other.data;
			}

			internal bool HasValueByte
			{
				get { return data is byte; }
			}

			internal byte ValueByte
			{
				get { return (byte)data; }
			}

			internal short ValueInt16
			{
				get { return (short)data; }
			}

			internal int ValueInt32
			{
				get { return (int)data; }
			}

			internal long ValueInt64
			{
				get { return (long)data; }
			}

			internal Type Type
			{
				get { return (Type)data; }
			}

			internal FieldInfo FieldInfo
			{
				get { return (FieldInfo)data; }
			}

			internal MethodBase MethodBase
			{
				get { return (MethodBase)data; }
			}

			internal int Size
			{
				get
				{
					switch (pseudo)
					{
						case CodeType.Unreachable:
						case CodeType.BeginScope:
						case CodeType.EndScope:
						case CodeType.DeclareLocal:
						case CodeType.ReleaseTempLocal:
						case CodeType.LineNumber:
						case CodeType.Label:
						case CodeType.BeginExceptionBlock:
							return 0;
						case CodeType.SequencePoint:
							return 1;
						case CodeType.BeginCatchBlock:
						case CodeType.BeginFaultBlock:
						case CodeType.BeginFinallyBlock:
						case CodeType.EndExceptionBlock:
#if STATIC_COMPILER
							return 0;
#else
							if ((flags & CodeTypeFlags.EndFaultOrFinally) != 0)
							{
								return 1 + 2;
							}
							return 5 + 2;
#endif
						case CodeType.MemoryBarrier:
						case CodeType.MonitorEnter:
						case CodeType.MonitorExit:
							return 5;
						case CodeType.TailCallPrevention:
							return 2;
						case CodeType.ClearStack:
							return 2;
						case CodeType.OpCode:
							if (data == null)
							{
								return opcode.Size;
							}
							else if (data is int)
							{
								return opcode.Size + 4;;
							}
							else if (data is long)
							{
								return opcode.Size + 8;
							}
							else if (data is MethodInfo)
							{
								return opcode.Size + 4;
							}
							else if (data is ConstructorInfo)
							{
								return opcode.Size + 4;
							}
							else if (data is FieldInfo)
							{
								return opcode.Size + 4;
							}
							else if (data is sbyte)
							{
								return opcode.Size + 1;
							}
							else if (data is byte)
							{
								return opcode.Size + 1;
							}
							else if (data is short)
							{
								return opcode.Size + 2;
							}
							else if (data is float)
							{
								return opcode.Size + 4;
							}
							else if (data is double)
							{
								return opcode.Size + 8;
							}
							else if (data is string)
							{
								return opcode.Size + 4;
							}
							else if (data is Type)
							{
								return opcode.Size + 4;
							}
							else if (data is CodeEmitterLocal)
							{
								int index = ((CodeEmitterLocal)data).__LocalIndex;
								if(index < 4 && opcode.Value != OpCodes.Ldloca.Value && opcode.Value != OpCodes.Ldloca_S.Value)
								{
									return 1;
								}
								else if(index < 256)
								{
									return 2;
								}
								else
								{
									return 4;
								}
							}
							else if (data is CodeEmitterLabel)
							{
								switch(opcode.OperandType)
								{
									case OperandType.InlineBrTarget:
										return opcode.Size + 4;
									case OperandType.ShortInlineBrTarget:
										return opcode.Size + 1;
									default:
										throw new InvalidOperationException();
								}
							}
							else if (data is CodeEmitterLabel[])
							{
								return 5 + ((CodeEmitterLabel[])data).Length * 4;
							}
							else if (data is CalliWrapper)
							{
								return 5;
							}
							else
							{
								throw new InvalidOperationException();
							}
						default:
							throw new InvalidOperationException();
					}
				}
			}

			internal void RealEmit(int ilOffset, CodeEmitter codeEmitter, ref int lineNumber)
			{
				if (pseudo == CodeType.OpCode)
				{
					if (lineNumber != -1)
					{
						if (codeEmitter.linenums == null)
						{
							codeEmitter.linenums = new IKVM.Attributes.LineNumberTableAttribute.LineNumberWriter(32);
						}
						codeEmitter.linenums.AddMapping(ilOffset, lineNumber);
						lineNumber = -1;
					}
					codeEmitter.RealEmitOpCode(opcode, data);
				}
				else if (pseudo == CodeType.LineNumber)
				{
					lineNumber = (int)data;
				}
				else
				{
					codeEmitter.RealEmitPseudoOpCode(ilOffset, pseudo, data);
				}
			}

			public override string ToString()
			{
				return pseudo.ToString() + " " + data;
			}
		}

		sealed class CalliWrapper
		{
			internal readonly CallingConvention unmanagedCallConv;
			internal readonly Type returnType;
			internal readonly Type[] parameterTypes;

			internal CalliWrapper(CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
			{
				this.unmanagedCallConv = unmanagedCallConv;
				this.returnType = returnType;
				this.parameterTypes = parameterTypes == null ? null : (Type[])parameterTypes.Clone();
			}
		}

		internal static CodeEmitter Create(MethodBuilder mb)
		{
			return new CodeEmitter(mb.GetILGenerator(), mb.DeclaringType);
		}

#if !STATIC_COMPILER
		internal static CodeEmitter Create(DynamicMethod dm)
		{
			return new CodeEmitter(dm.GetILGenerator(), null);
		}
#endif

		private CodeEmitter(ILGenerator ilgen, Type declaringType)
		{
#if STATIC_COMPILER
			ilgen.__DisableExceptionBlockAssistance();
#endif
			this.ilgen_real = ilgen;
			this.declaringType = declaringType;
		}

		private void EmitPseudoOpCode(CodeType type, object data)
		{
			code.Add(new OpCodeWrapper(type, data));
		}

		private void EmitOpCode(OpCode opcode, object arg)
		{
			code.Add(new OpCodeWrapper(opcode, arg));
		}

		private void RealEmitPseudoOpCode(int ilOffset, CodeType type, object data)
		{
			switch (type)
			{
				case CodeType.Unreachable:
					break;
				case CodeType.BeginScope:
					ilgen_real.BeginScope();
					break;
				case CodeType.EndScope:
					ilgen_real.EndScope();
					break;
				case CodeType.DeclareLocal:
					((CodeEmitterLocal)data).Declare(ilgen_real);
					break;
				case CodeType.ReleaseTempLocal:
					break;
				case CodeType.SequencePoint:
					ilgen_real.MarkSequencePoint(symbols, (int)data, 0, (int)data + 1, 0);
					// we emit a nop to make sure we always have an instruction associated with the sequence point
					ilgen_real.Emit(OpCodes.Nop);
					break;
				case CodeType.Label:
					ilgen_real.MarkLabel(((CodeEmitterLabel)data).Label);
					break;
				case CodeType.BeginExceptionBlock:
					ilgen_real.BeginExceptionBlock();
					break;
				case CodeType.BeginCatchBlock:
					ilgen_real.BeginCatchBlock((Type)data);
					break;
				case CodeType.BeginFaultBlock:
					ilgen_real.BeginFaultBlock();
					break;
				case CodeType.BeginFinallyBlock:
					ilgen_real.BeginFinallyBlock();
					break;
				case CodeType.EndExceptionBlock:
					ilgen_real.EndExceptionBlock();
#if !STATIC_COMPILER
					// HACK to keep the verifier happy we need this bogus jump
					// (because of the bogus Leave that Ref.Emit ends the try block with)
					ilgen_real.Emit(OpCodes.Br_S, (sbyte)-2);
#endif
					break;
				case CodeType.MemoryBarrier:
					if (memoryBarrier == null)
					{
						memoryBarrier = JVM.Import(typeof(System.Threading.Thread)).GetMethod("MemoryBarrier", Type.EmptyTypes);
					}
					ilgen_real.Emit(OpCodes.Call, memoryBarrier);
					break;
				case CodeType.MonitorEnter:
					ilgen_real.Emit(OpCodes.Call, monitorEnter);
					break;
				case CodeType.MonitorExit:
					ilgen_real.Emit(OpCodes.Call, monitorExit);
					break;
				case CodeType.TailCallPrevention:
					ilgen_real.Emit(OpCodes.Ldnull);
					ilgen_real.Emit(OpCodes.Pop);
					break;
				case CodeType.ClearStack:
					ilgen_real.Emit(OpCodes.Leave_S, (byte)0);
					break;
				default:
					throw new InvalidOperationException();
			}
		}

		private void RealEmitOpCode(OpCode opcode, object arg)
		{
			if (arg == null)
			{
				ilgen_real.Emit(opcode);
			}
			else if (arg is int)
			{
				ilgen_real.Emit(opcode, (int)arg);
			}
			else if (arg is long)
			{
				ilgen_real.Emit(opcode, (long)arg);
			}
			else if (arg is MethodInfo)
			{
				ilgen_real.Emit(opcode, (MethodInfo)arg);
			}
			else if (arg is ConstructorInfo)
			{
				ilgen_real.Emit(opcode, (ConstructorInfo)arg);
			}
			else if (arg is FieldInfo)
			{
				ilgen_real.Emit(opcode, (FieldInfo)arg);
			}
			else if (arg is sbyte)
			{
				ilgen_real.Emit(opcode, (sbyte)arg);
			}
			else if (arg is byte)
			{
				ilgen_real.Emit(opcode, (byte)arg);
			}
			else if (arg is short)
			{
				ilgen_real.Emit(opcode, (short)arg);
			}
			else if (arg is float)
			{
				ilgen_real.Emit(opcode, (float)arg);
			}
			else if (arg is double)
			{
				ilgen_real.Emit(opcode, (double)arg);
			}
			else if (arg is string)
			{
				ilgen_real.Emit(opcode, (string)arg);
			}
			else if (arg is Type)
			{
				ilgen_real.Emit(opcode, (Type)arg);
			}
			else if (arg is CodeEmitterLocal)
			{
				CodeEmitterLocal local = (CodeEmitterLocal)arg;
				local.Emit(ilgen_real, opcode);
			}
			else if (arg is CodeEmitterLabel)
			{
				CodeEmitterLabel label = (CodeEmitterLabel)arg;
				ilgen_real.Emit(opcode, label.Label);
			}
			else if (arg is CodeEmitterLabel[])
			{
				CodeEmitterLabel[] labels = (CodeEmitterLabel[])arg;
				Label[] real = new Label[labels.Length];
				for (int i = 0; i < labels.Length; i++)
				{
					real[i] = labels[i].Label;
				}
				ilgen_real.Emit(opcode, real);
			}
			else if (arg is CalliWrapper)
			{
				CalliWrapper args = (CalliWrapper)arg;
				ilgen_real.EmitCalli(opcode, args.unmanagedCallConv, args.returnType, args.parameterTypes);
			}
			else
			{
				throw new InvalidOperationException();
			}
		}

		private void RemoveJumpNext()
		{
			for (int i = 1; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label)
				{
					if (code[i - 1].opcode == OpCodes.Br
						&& code[i - 1].MatchLabel(code[i]))
					{
						code.RemoveAt(i - 1);
						i--;
					}
					else if (i >= 2
						&& code[i - 1].pseudo == CodeType.LineNumber
						&& code[i - 2].opcode == OpCodes.Br
						&& code[i - 2].MatchLabel(code[i]))
					{
						code.RemoveAt(i - 2);
						i--;
					}
				}
			}
		}

		private void AnnihilateStoreReleaseTempLocals()
		{
			for (int i = 1; i < code.Count; i++)
			{
				if (code[i].opcode == OpCodes.Stloc)
				{
					if (code[i + 1].pseudo == CodeType.ReleaseTempLocal
						&& code[i].Local == code[i + 1].Local)
					{
						code[i] = new OpCodeWrapper(OpCodes.Pop, null);
					}
					else if (code[i + 1].opcode == OpCodes.Ldloc
						&& code[i + 1].Local == code[i].Local
						&& code[i + 2].pseudo == CodeType.ReleaseTempLocal
						&& code[i + 2].Local == code[i].Local)
					{
						code.RemoveRange(i, 2);
					}
				}
			}
		}

		private void AnnihilatePops()
		{
			for (int i = 1; i < code.Count; i++)
			{
				if (code[i].opcode == OpCodes.Pop)
				{
					// search backwards for a candidate push to annihilate
					int stack = 0;
					for (int j = i - 1; j >= 0; j--)
					{
						if (IsSideEffectFreePush(j))
						{
							if (stack == 0)
							{
								code.RemoveAt(i);
								code.RemoveAt(j);
								i -= 2;
								break;
							}
							stack++;
						}
						else if (code[j].opcode == OpCodes.Stloc)
						{
							stack--;
						}
						else if (code[j].opcode == OpCodes.Shl
							|| code[j].opcode == OpCodes.And
							|| code[j].opcode == OpCodes.Add
							|| code[j].opcode == OpCodes.Sub)
						{
							if (stack == 0)
							{
								break;
							}
							stack--;
						}
						else if (code[j].opcode == OpCodes.Conv_Ovf_I4
							|| code[j].opcode == OpCodes.Conv_I8
							|| code[j].opcode == OpCodes.Ldlen)
						{
							if (stack == 0)
							{
								break;
							}
							// no stack effect
						}
						else
						{
							break;
						}
					}
				}
			}
		}

		private bool IsSideEffectFreePush(int index)
		{
			if (code[index].opcode == OpCodes.Ldstr)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldnull)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldsfld)
			{
				FieldInfo field = code[index].FieldInfo;
				if (field != null)
				{
					// Here we are considering BeforeFieldInit to mean that we really don't care about
					// when the type is initialized (which is what we mean in the rest of the IKVM code as well)
					// but it is good to point it out here because strictly speaking we're violating the
					// BeforeFieldInit contract here by considering dummy loads not to be field accesses.
					if ((field.DeclaringType.Attributes & TypeAttributes.BeforeFieldInit) != 0)
					{
						return true;
					}
					// If we're accessing a field in the current type, it can't trigger the static initializer
					// (unless beforefieldinit is set, but see above for that scenario)
					if (field.DeclaringType == declaringType)
					{
						return true;
					}
				}
				return false;
			}
			else if (code[index].opcode == OpCodes.Ldc_I4)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldc_I8)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldc_R4)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldc_R8)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldloc)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldarg)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldarg_S)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldarg_0)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldarg_1)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldarg_2)
			{
				return true;
			}
			else if (code[index].opcode == OpCodes.Ldarg_3)
			{
				return true;
			}
			else
			{
				return false;
			}
		}

		private void OptimizeBranchSizes()
		{
			int offset = 0;
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label)
				{
					code[i].Label.Temp = offset;
				}
				offset += code[i].Size;
			}
			offset = 0;
			for (int i = 0; i < code.Count; i++)
			{
				int prevOffset = offset;
				offset += code[i].Size;
				if (code[i].HasLabel && code[i].opcode.OperandType == OperandType.InlineBrTarget)
				{
					CodeEmitterLabel label = code[i].Label;
					int diff = label.Temp - (prevOffset + code[i].opcode.Size + 1);
					if (-128 <= diff && diff <= 127)
					{
						OpCode opcode = code[i].opcode;
						if (opcode == OpCodes.Brtrue)
						{
							opcode = OpCodes.Brtrue_S;
						}
						else if (opcode == OpCodes.Brfalse)
						{
							opcode = OpCodes.Brfalse_S;
						}
						else if (opcode == OpCodes.Br)
						{
							opcode = OpCodes.Br_S;
						}
						else if (opcode == OpCodes.Beq)
						{
							opcode = OpCodes.Beq_S;
						}
						else if (opcode == OpCodes.Bne_Un)
						{
							opcode = OpCodes.Bne_Un_S;
						}
						else if (opcode == OpCodes.Ble)
						{
							opcode = OpCodes.Ble_S;
						}
						else if (opcode == OpCodes.Ble_Un)
						{
							opcode = OpCodes.Ble_Un_S;
						}
						else if (opcode == OpCodes.Blt)
						{
							opcode = OpCodes.Blt_S;
						}
						else if (opcode == OpCodes.Blt_Un)
						{
							opcode = OpCodes.Blt_Un_S;
						}
						else if (opcode == OpCodes.Bge)
						{
							opcode = OpCodes.Bge_S;
						}
						else if (opcode == OpCodes.Bge_Un)
						{
							opcode = OpCodes.Bge_Un_S;
						}
						else if (opcode == OpCodes.Bgt)
						{
							opcode = OpCodes.Bgt_S;
						}
						else if (opcode == OpCodes.Bgt_Un)
						{
							opcode = OpCodes.Bgt_Un_S;
						}
						else if (opcode == OpCodes.Leave)
						{
							opcode = OpCodes.Leave_S;
						}
						code[i] = new OpCodeWrapper(opcode, label);
					}
				}
			}
		}

		private void OptimizePatterns()
		{
			SetLabelRefCounts();
			for (int i = 1; i < code.Count; i++)
			{
				if (code[i].opcode == OpCodes.Isinst
					&& code[i + 1].opcode == OpCodes.Ldnull
					&& code[i + 2].opcode == OpCodes.Cgt_Un
					&& (code[i + 3].opcode == OpCodes.Brfalse || code[i + 3].opcode == OpCodes.Brtrue))
				{
					code.RemoveRange(i + 1, 2);
				}
				else if (code[i].opcode == OpCodes.Ldelem_I1
					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 255
					&& code[i + 2].opcode == OpCodes.And)
				{
					code[i] = new OpCodeWrapper(OpCodes.Ldelem_U1, null);
					code.RemoveRange(i + 1, 2);
				}
				else if (code[i].opcode == OpCodes.Ldelem_I1
					&& code[i + 1].opcode == OpCodes.Conv_I8
					&& code[i + 2].opcode == OpCodes.Ldc_I8 && code[i + 2].ValueInt64 == 255
					&& code[i + 3].opcode == OpCodes.And)
				{
					code[i] = new OpCodeWrapper(OpCodes.Ldelem_U1, null);
					code.RemoveRange(i + 2, 2);
				}
				else if (code[i].opcode == OpCodes.Ldc_I4
					&& code[i + 1].opcode == OpCodes.Ldc_I4
					&& code[i + 2].opcode == OpCodes.And)
				{
					code[i] = new OpCodeWrapper(OpCodes.Ldc_I4, code[i].ValueInt32 & code[i + 1].ValueInt32);
					code.RemoveRange(i + 1, 2);
				}
				else if (MatchCompare(i, OpCodes.Cgt, OpCodes.Clt_Un, Types.Double)		// dcmpl
					|| MatchCompare(i, OpCodes.Cgt, OpCodes.Clt_Un, Types.Single))		// fcmpl
				{
					PatchCompare(i, OpCodes.Ble_Un, OpCodes.Blt_Un, OpCodes.Bge, OpCodes.Bgt);
				}
				else if (MatchCompare(i, OpCodes.Cgt_Un, OpCodes.Clt, Types.Double)		// dcmpg
					|| MatchCompare(i, OpCodes.Cgt_Un, OpCodes.Clt, Types.Single))		// fcmpg
				{
					PatchCompare(i, OpCodes.Ble, OpCodes.Blt, OpCodes.Bge_Un, OpCodes.Bgt_Un);
				}
				else if (MatchCompare(i, OpCodes.Cgt, OpCodes.Clt, Types.Int64))		// lcmp
				{
					PatchCompare(i, OpCodes.Ble, OpCodes.Blt, OpCodes.Bge, OpCodes.Bgt);
				}
				else if (i < code.Count - 10
					&& code[i].opcode == OpCodes.Ldc_I4
					&& code[i + 1].opcode == OpCodes.Dup
					&& code[i + 2].opcode == OpCodes.Ldc_I4_M1
					&& code[i + 3].opcode == OpCodes.Bne_Un
					&& code[i + 4].opcode == OpCodes.Pop
					&& code[i + 5].opcode == OpCodes.Neg
					&& code[i + 6].opcode == OpCodes.Br
					&& code[i + 7].pseudo == CodeType.Label && code[i + 7].MatchLabel(code[i + 3]) && code[i + 7].Label.Temp == 1
					&& code[i + 8].opcode == OpCodes.Div
					&& code[i + 9].pseudo == CodeType.Label && code[i + 9].Label == code[i + 6].Label && code[i + 9].Label.Temp == 1)
				{
					int divisor = code[i].ValueInt32;
					if (divisor == -1)
					{
						code[i] = code[i + 5];
						code.RemoveRange(i + 1, 9);
					}
					else
					{
						code[i + 1] = code[i + 8];
						code.RemoveRange(i + 2, 8);
					}
				}
				else if (i < code.Count - 11
					&& code[i].opcode == OpCodes.Ldc_I8
					&& code[i + 1].opcode == OpCodes.Dup
					&& code[i + 2].opcode == OpCodes.Ldc_I4_M1
					&& code[i + 3].opcode == OpCodes.Conv_I8
					&& code[i + 4].opcode == OpCodes.Bne_Un
					&& code[i + 5].opcode == OpCodes.Pop
					&& code[i + 6].opcode == OpCodes.Neg
					&& code[i + 7].opcode == OpCodes.Br
					&& code[i + 8].pseudo == CodeType.Label && code[i + 8].MatchLabel(code[i + 4]) && code[i + 8].Label.Temp == 1
					&& code[i + 9].opcode == OpCodes.Div
					&& code[i + 10].pseudo == CodeType.Label && code[i + 10].MatchLabel(code[i + 7]) && code[i + 10].Label.Temp == 1)
				{
					long divisor = code[i].ValueInt64;
					if (divisor == -1)
					{
						code[i] = code[i + 6];
						code.RemoveRange(i + 1, 10);
					}
					else
					{
						code[i + 1] = code[i + 9];
						code.RemoveRange(i + 2, 9);
					}
				}
				else if (code[i].opcode == OpCodes.Box
					&& code[i + 1].opcode == OpCodes.Unbox && code[i + 1].Type == code[i].Type)
				{
					CodeEmitterLocal local = new CodeEmitterLocal(code[i].Type);
					code[i] = new OpCodeWrapper(OpCodes.Stloc, local);
					code[i + 1] = new OpCodeWrapper(OpCodes.Ldloca, local);
				}
				else if (i < code.Count - 13
					&& code[i + 0].opcode == OpCodes.Box
					&& code[i + 1].opcode == OpCodes.Dup
					&& code[i + 2].opcode == OpCodes.Brtrue
					&& code[i + 3].opcode == OpCodes.Pop
					&& code[i + 4].opcode == OpCodes.Ldloca && code[i + 4].Local.LocalType == code[i + 0].Type
					&& code[i + 5].opcode == OpCodes.Initobj && code[i + 5].Type == code[i + 0].Type
					&& code[i + 6].opcode == OpCodes.Ldloc && code[i + 6].Local == code[i + 4].Local
					&& code[i + 7].pseudo == CodeType.ReleaseTempLocal && code[i + 7].Local == code[i + 6].Local
					&& code[i + 8].opcode == OpCodes.Br
					&& code[i + 9].pseudo == CodeType.Label && code[i + 9].MatchLabel(code[i + 2]) && code[i + 9].Label.Temp == 1
					&& code[i + 10].opcode == OpCodes.Unbox && code[i + 10].Type == code[i + 0].Type
					&& code[i + 11].opcode == OpCodes.Ldobj && code[i + 11].Type == code[i + 0].Type
					&& code[i + 12].pseudo == CodeType.Label && code[i + 12].MatchLabel(code[i + 8]) && code[i + 12].Label.Temp == 1)
				{
					code.RemoveRange(i, 13);
				}

				// NOTE intentionally not an else, because we want to optimize the code generated by the earlier compare optimization
				if (i < code.Count - 6
					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch
					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1
					&& code[i + 2].opcode == OpCodes.Br
					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1
					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0
					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1)
				{
					if (code[i].opcode == OpCodes.Bne_Un)
					{
						code[i] = new OpCodeWrapper(OpCodes.Ceq, null);
						code.RemoveRange(i + 1, 5);
					}
					else if (code[i].opcode == OpCodes.Beq)
					{
						code[i + 0] = new OpCodeWrapper(OpCodes.Ceq, null);
						code[i + 1] = new OpCodeWrapper(OpCodes.Ldc_I4, 0);
						code[i + 2] = new OpCodeWrapper(OpCodes.Ceq, null);
						code.RemoveRange(i + 3, 3);
					}
					else if (code[i].opcode == OpCodes.Ble || code[i].opcode == OpCodes.Ble_Un)
					{
						code[i] = new OpCodeWrapper(OpCodes.Cgt, null);
						code.RemoveRange(i + 1, 5);
					}
					else if (code[i].opcode == OpCodes.Blt)
					{
						code[i] = new OpCodeWrapper(OpCodes.Clt, null);
						code[i + 1] = new OpCodeWrapper(OpCodes.Ldc_I4, 0);
						code[i + 2] = new OpCodeWrapper(OpCodes.Ceq, null);
						code.RemoveRange(i + 3, 3);
					}
					else if (code[i].opcode == OpCodes.Blt_Un)
					{
						code[i] = new OpCodeWrapper(OpCodes.Clt_Un, null);
						code[i + 1] = new OpCodeWrapper(OpCodes.Ldc_I4, 0);
						code[i + 2] = new OpCodeWrapper(OpCodes.Ceq, null);
						code.RemoveRange(i + 3, 3);
					}
					else if (code[i].opcode == OpCodes.Bge || code[i].opcode == OpCodes.Bge_Un)
					{
						code[i] = new OpCodeWrapper(OpCodes.Clt, null);
						code.RemoveRange(i + 1, 5);
					}
					else if (code[i].opcode == OpCodes.Bgt)
					{
						code[i] = new OpCodeWrapper(OpCodes.Cgt, null);
						code[i + 1] = new OpCodeWrapper(OpCodes.Ldc_I4, 0);
						code[i + 2] = new OpCodeWrapper(OpCodes.Ceq, null);
						code.RemoveRange(i + 3, 3);
					}
					else if (code[i].opcode == OpCodes.Bgt_Un)
					{
						code[i] = new OpCodeWrapper(OpCodes.Cgt_Un, null);
						code[i + 1] = new OpCodeWrapper(OpCodes.Ldc_I4, 0);
						code[i + 2] = new OpCodeWrapper(OpCodes.Ceq, null);
						code.RemoveRange(i + 3, 3);
					}
				}
			}
		}

		private bool MatchCompare(int index, OpCode cmp1, OpCode cmp2, Type type)
		{
			return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type
				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type
				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])
				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])
				&& code[index + 4].opcode == cmp1
				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])
				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])
				&& code[index + 7].opcode == cmp2
				&& code[index + 8].opcode == OpCodes.Sub
				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local
				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local
				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||
					(code[index + 11].opcode == OpCodes.Ldc_I4_0
					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
		}

		private void PatchCompare(int index, OpCode ble, OpCode blt, OpCode bge, OpCode bgt)
		{
			if (code[index + 11].opcode == OpCodes.Brtrue)
			{
				code[index] = new OpCodeWrapper(OpCodes.Bne_Un, code[index + 11].Label);
				code.RemoveRange(index + 1, 11);
			}
			else if (code[index + 11].opcode == OpCodes.Brfalse)
			{
				code[index] = new OpCodeWrapper(OpCodes.Beq, code[index + 11].Label);
				code.RemoveRange(index + 1, 11);
			}
			else if (code[index + 11].opcode == OpCodes.Ldc_I4_0)
			{
				if (code[index + 12].opcode == OpCodes.Ble)
				{
					code[index] = new OpCodeWrapper(ble, code[index + 12].Label);
					code.RemoveRange(index + 1, 12);
				}
				else if (code[index + 12].opcode == OpCodes.Blt)
				{
					code[index] = new OpCodeWrapper(blt, code[index + 12].Label);
					code.RemoveRange(index + 1, 12);
				}
				else if (code[index + 12].opcode == OpCodes.Bge)
				{
					code[index] = new OpCodeWrapper(bge, code[index + 12].Label);
					code.RemoveRange(index + 1, 12);
				}
				else if (code[index + 12].opcode == OpCodes.Bgt)
				{
					code[index] = new OpCodeWrapper(bgt, code[index + 12].Label);
					code.RemoveRange(index + 1, 12);
				}
			}
		}

		private void OptimizeEncodings()
		{
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].opcode == OpCodes.Ldc_I4)
				{
					code[i] = OptimizeLdcI4(code[i].ValueInt32);
				}
				else if (code[i].opcode == OpCodes.Ldc_I8)
				{
					OptimizeLdcI8(i);
				}
			}
		}

		private OpCodeWrapper OptimizeLdcI4(int value)
		{
			switch (value)
			{
				case -1:
					return new OpCodeWrapper(OpCodes.Ldc_I4_M1, null);
				case 0:
					return new OpCodeWrapper(OpCodes.Ldc_I4_0, null);
				case 1:
					return new OpCodeWrapper(OpCodes.Ldc_I4_1, null);
				case 2:
					return new OpCodeWrapper(OpCodes.Ldc_I4_2, null);
				case 3:
					return new OpCodeWrapper(OpCodes.Ldc_I4_3, null);
				case 4:
					return new OpCodeWrapper(OpCodes.Ldc_I4_4, null);
				case 5:
					return new OpCodeWrapper(OpCodes.Ldc_I4_5, null);
				case 6:
					return new OpCodeWrapper(OpCodes.Ldc_I4_6, null);
				case 7:
					return new OpCodeWrapper(OpCodes.Ldc_I4_7, null);
				case 8:
					return new OpCodeWrapper(OpCodes.Ldc_I4_8, null);
				default:
					if (value >= -128 && value <= 127)
					{
						return new OpCodeWrapper(OpCodes.Ldc_I4_S, (sbyte)value);
					}
					else
					{
						return new OpCodeWrapper(OpCodes.Ldc_I4, value);
					}
			}
		}

		private void OptimizeLdcI8(int index)
		{
			long value = code[index].ValueInt64;
			if (value >= int.MinValue && value <= uint.MaxValue)
			{
				code[index] = OptimizeLdcI4((int)value);
				code.Insert(index + 1, new OpCodeWrapper(value < 0 ? OpCodes.Conv_I8 : OpCodes.Conv_U8, null));
			}
		}

		private void ChaseBranches()
		{
			/*
			 * Here we do a couple of different optimizations to unconditional branches:
			 *  - a branch to a ret or endfinally will be replaced
			 *    by the ret or endfinally instruction (because that is always at least as efficient)
			 *  - a branch to a branch will remove the indirection
			 *  - a leave to a branch or leave will remove the indirection
			 */
			SetLabelIndexes();
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].opcode == OpCodes.Br)
				{
					int target = code[i].Label.Temp + 1;
					if (code[target].pseudo == CodeType.LineNumber)
					{
						// line number info on endfinally or ret is probably useless anyway
						target++;
					}
					if (code[target].opcode == OpCodes.Endfinally || code[target].opcode == OpCodes.Ret)
					{
						code[i] = code[target];
					}
					else
					{
						CodeEmitterLabel label = null;
						while (code[target].opcode == OpCodes.Br && target != i)
						{
							label = code[target].Label;
							target = code[target].Label.Temp + 1;
						}
						if (label != null)
						{
							code[i] = new OpCodeWrapper(OpCodes.Br, label);
						}
					}
				}
				else if (code[i].opcode == OpCodes.Leave)
				{
					int target = code[i].Label.Temp + 1;
					CodeEmitterLabel label = null;
					while ((code[target].opcode == OpCodes.Br || code[target].opcode == OpCodes.Leave) && target != i)
					{
						label = code[target].Label;
						target = code[target].Label.Temp + 1;
					}
					if (label != null)
					{
						code[i] = new OpCodeWrapper(OpCodes.Leave, label);
					}
				}
			}
		}

		private void RemoveSingletonBranches()
		{
			/*
			 * Here we try to remove unconditional branches that jump to a label with ref count of one
			 * and where the code is not otherwise used.
			 */
			SetLabelRefCounts();
			// now increment label refcounts for labels that are also reachable via the preceding instruction
			bool reachable = true;
			for (int i = 0; i < code.Count; i++)
			{
				if (reachable)
				{
					switch (code[i].pseudo)
					{
						case CodeType.Label:
							code[i].Label.Temp++;
							break;
						case CodeType.BeginCatchBlock:
						case CodeType.BeginFaultBlock:
						case CodeType.BeginFinallyBlock:
						case CodeType.EndExceptionBlock:
							throw new InvalidOperationException();
						case CodeType.OpCode:
							switch (code[i].opcode.FlowControl)
							{
								case FlowControl.Branch:
								case FlowControl.Return:
								case FlowControl.Throw:
									reachable = false;
									break;
							}
							break;
					}
				}
				else
				{
					switch (code[i].pseudo)
					{
						case CodeType.Label:
							reachable = code[i].Label.Temp > 0;
							break;
						case CodeType.BeginCatchBlock:
						case CodeType.BeginFaultBlock:
						case CodeType.BeginFinallyBlock:
							reachable = true;
							break;
					}
				}
			}

			// now remove the unconditional branches to labels with a refcount of one
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].opcode == OpCodes.Br && code[i].Label.Temp == 1)
				{
					int target = FindLabel(code[i].Label) + 1;
					for (int j = target; j < code.Count; j++)
					{
						switch (code[j].pseudo)
						{
							case CodeType.OpCode:
								if (code[j].HasLocal && FindLocal(code[j].Local) > i)
								{
									// we cannot local variable usage before the declaration
									goto breakOuter;
								}
								switch (code[j].opcode.FlowControl)
								{
									case FlowControl.Branch:
									case FlowControl.Return:
									case FlowControl.Throw:
										// we've found a viable sequence of opcode to move to the branch location
										List<OpCodeWrapper> range = code.GetRange(target, j - target + 1);
										if (target < i)
										{
											code.RemoveAt(i);
											code.InsertRange(i, range);
											code.RemoveRange(target - 1, range.Count + 1);
											i -= range.Count + 1;
										}
										else
										{
											code.RemoveRange(target - 1, range.Count + 1);
											code.RemoveAt(i);
											code.InsertRange(i, range);
										}
										goto breakOuter;
								}
								break;
							case CodeType.Label:
							case CodeType.BeginExceptionBlock:
							case CodeType.DeclareLocal:
								goto breakOuter;
						}
					}
				breakOuter: ;
				}
			}
		}

		private int FindLabel(CodeEmitterLabel label)
		{
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label && code[i].Label == label)
				{
					return i;
				}
			}
			throw new InvalidOperationException();
		}

		private int FindLocal(CodeEmitterLocal local)
		{
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.DeclareLocal && code[i].Local == local)
				{
					return i;
				}
			}
			// if the local variable isn't declared, it is a temporary that is allocated on demand
			// (so we can move their usage freely)
			return 0;
		}

		private void SortPseudoOpCodes()
		{
			for (int i = 0; i < code.Count - 1; i++)
			{
				switch (code[i].pseudo)
				{
					case CodeType.ReleaseTempLocal:
						for (int j = i - 1; ; j--)
						{
							if (j == -1)
							{
								code.RemoveAt(i);
								break;
							}
							if (code[j].HasLocal && code[j].Local == code[i].Local)
							{
								MoveInstruction(i, j + 1);
								break;
							}
						}
						break;
				}
			}
		}

		private void MoveInstruction(int i, int j)
		{
			if (i == j - 1 || i == j + 1)
			{
				OpCodeWrapper temp = code[i];
				code[i] = code[j];
				code[j] = temp;
			}
			else if (i < j)
			{
				code.Insert(j, code[i]);
				code.RemoveAt(i);
			}
			else if (i > j)
			{
				OpCodeWrapper temp = code[i];
				code.RemoveAt(i);
				code.Insert(j, temp);
			}
		}

		private void ClearLabelTemp()
		{
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label)
				{
					code[i].Label.Temp = 0;
				}
			}
		}

		private void SetLabelIndexes()
		{
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label)
				{
					code[i].Label.Temp = i;
				}
			}
		}

		private void SetLabelRefCounts()
		{
			ClearLabelTemp();
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.OpCode)
				{
					if (code[i].HasLabel)
					{
						code[i].Label.Temp++;
					}
					else if (code[i].opcode == OpCodes.Switch)
					{
						foreach (CodeEmitterLabel label in code[i].Labels)
						{
							label.Temp++;
						}
					}
				}
			}
		}

		private void RemoveUnusedLabels()
		{
			SetLabelRefCounts();
			for (int i = 0; i < code.Count; i++)
			{
				while (code[i].pseudo == CodeType.Label && code[i].Label.Temp == 0)
				{
					code.RemoveAt(i);
				}
			}
		}

		private void RemoveDeadCode()
		{
			ClearLabelTemp();
			const int ReachableFlag = 1;
			const int ProcessedFlag = 2;
			bool reachable = true;
			bool done = false;
			while (!done)
			{
				done = true;
				for (int i = 0; i < code.Count; i++)
				{
					if (reachable)
					{
						if (code[i].pseudo == CodeType.Label)
						{
							if (code[i].Label.Temp == ProcessedFlag)
							{
								done = false;
							}
							code[i].Label.Temp |= ReachableFlag;
						}
						else if (code[i].pseudo == CodeType.OpCode)
						{
							if (code[i].HasLabel)
							{
								if (code[i].Label.Temp == ProcessedFlag)
								{
									done = false;
								}
								code[i].Label.Temp |= ReachableFlag;
							}
							else if (code[i].opcode == OpCodes.Switch)
							{
								foreach (CodeEmitterLabel label in code[i].Labels)
								{
									if (label.Temp == ProcessedFlag)
									{
										done = false;
									}
									label.Temp |= ReachableFlag;
								}
							}
							switch (code[i].opcode.FlowControl)
							{
								case FlowControl.Cond_Branch:
									if (!code[i].HasLabel && code[i].opcode != OpCodes.Switch)
									{
										throw new NotSupportedException();
									}
									break;
								case FlowControl.Branch:
								case FlowControl.Return:
								case FlowControl.Throw:
									reachable = false;
									break;
							}
						}
					}
					else if (code[i].pseudo == CodeType.BeginCatchBlock)
					{
						reachable = true;
					}
					else if (code[i].pseudo == CodeType.BeginFaultBlock)
					{
						reachable = true;
					}
					else if (code[i].pseudo == CodeType.BeginFinallyBlock)
					{
						reachable = true;
					}
					else if (code[i].pseudo == CodeType.Label && (code[i].Label.Temp & ReachableFlag) != 0)
					{
						reachable = true;
					}
					if (code[i].pseudo == CodeType.Label)
					{
						code[i].Label.Temp |= ProcessedFlag;
					}
				}
			}
			reachable = true;
			int firstUnreachable = -1;
			for (int i = 0; i < code.Count; i++)
			{
				if (reachable)
				{
					if (code[i].pseudo == CodeType.OpCode)
					{
						switch (code[i].opcode.FlowControl)
						{
							case FlowControl.Branch:
							case FlowControl.Return:
							case FlowControl.Throw:
								reachable = false;
								firstUnreachable = i + 1;
								break;
						}
					}
				}
				else
				{
					switch (code[i].pseudo)
					{
						case CodeType.OpCode:
							break;
						case CodeType.Label:
							if ((code[i].Label.Temp & ReachableFlag) != 0)
							{
								goto case CodeType.BeginCatchBlock;
							}
							break;
						case CodeType.BeginCatchBlock:
						case CodeType.BeginFaultBlock:
						case CodeType.BeginFinallyBlock:
							code.RemoveRange(firstUnreachable, i - firstUnreachable);
							i = firstUnreachable;
							firstUnreachable = -1;
							reachable = true;
							break;
						default:
							code.RemoveRange(firstUnreachable, i - firstUnreachable);
							i = firstUnreachable;
							firstUnreachable++;
							break;
					}
				}
			}
			if (!reachable)
			{
				code.RemoveRange(firstUnreachable, code.Count - firstUnreachable);
			}

			// TODO can't we incorporate this in the above code?
			// remove exception blocks with empty try blocks
			// (which can happen if the try block is unreachable)
			for (int i = 0; i < code.Count; i++)
			{
			restart:
				if (code[i].pseudo == CodeType.BeginExceptionBlock)
				{
					for (int k = 0; ; k++)
					{
						switch (code[i + k].pseudo)
						{
							case CodeType.BeginCatchBlock:
							case CodeType.BeginFaultBlock:
							case CodeType.BeginFinallyBlock:
								int depth = 0;
								for (int j = i + 1; ; j++)
								{
									switch (code[j].pseudo)
									{
										case CodeType.BeginExceptionBlock:
											depth++;
											break;
										case CodeType.EndExceptionBlock:
											if (depth == 0)
											{
												code.RemoveRange(i, (j - i) + 1);
												goto restart;
											}
											depth--;
											break;
									}
								}
							case CodeType.OpCode:
								goto next;
						}
					}
				}
			next: ;
			}
		}

		private void DeduplicateBranchSourceTargetCode()
		{
			SetLabelIndexes();
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].opcode == OpCodes.Br && code[i].HasLabel)
				{
					int source = i - 1;
					int target = code[i].Label.Temp - 1;
					while (source >= 0 && target >= 0)
					{
						switch (code[source].pseudo)
						{
							case CodeType.LineNumber:
							case CodeType.OpCode:
								break;
							default:
								goto break_while;
						}
						if (!code[source].Match(code[target]))
						{
							break;
						}
						switch (code[source].opcode.FlowControl)
						{
							case FlowControl.Branch:
							case FlowControl.Cond_Branch:
								goto break_while;
						}
						source--;
						target--;
					}
				break_while: ;
					source++;
					target++;
					if (source != i && target > 0 && source != target - 1)
					{
						// TODO for now we only do this optimization if there happens to be an appriopriate label
						if (code[target - 1].pseudo == CodeType.Label)
						{
							code[source] = new OpCodeWrapper(OpCodes.Br, code[target - 1].Label);
							for (int j = source + 1; j <= i; j++)
							{
								// We can't depend on DCE for code correctness (we have to maintain all MSIL invariants at all times),
								// so we patch out the unused code.
								code[j] = new OpCodeWrapper(CodeType.Unreachable, null);
							}
						}
					}
				}
			}
		}

		private void OptimizeStackTransfer()
		{
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].opcode == OpCodes.Ldloc
					&& code[i + 1].opcode == OpCodes.Stloc
					&& code[i + 2].pseudo == CodeType.BeginExceptionBlock
					&& code[i + 3].opcode == OpCodes.Ldloc && code[i + 3].MatchLocal(code[i + 1])
					&& code[i + 4].pseudo == CodeType.ReleaseTempLocal && code[i + 4].MatchLocal(code[i + 3]))
				{
					code[i + 1] = code[i];
					code[i] = code[i + 2];
					code.RemoveRange(i + 2, 3);
				}
			}
		}

		private void MergeExceptionBlocks()
		{
			// The first loop will convert all Begin[Exception|Catch|Fault|Finally]Block and EndExceptionBlock
			// pseudo opcodes into a cyclic linked list (EndExceptionBlock links back to BeginExceptionBlock)
			// to allow for easy traversal in the next loop.
			int[] extra = new int[code.Count];
			Stack<int> stack = new Stack<int>();
			int currentBeginExceptionBlock = -1;
			int currentLast = -1;
			for (int i = 0; i < code.Count; i++)
			{
				switch (code[i].pseudo)
				{
					case CodeType.BeginExceptionBlock:
						stack.Push(currentBeginExceptionBlock);
						currentBeginExceptionBlock = i;
						currentLast = i;
						break;
					case CodeType.EndExceptionBlock:
						extra[currentLast] = i;
						extra[i] = currentBeginExceptionBlock;
						currentBeginExceptionBlock = stack.Pop();
						currentLast = currentBeginExceptionBlock;
						if (currentLast != -1)
						{
							while (extra[currentLast] != 0)
							{
								currentLast = extra[currentLast];
							}
						}
						break;
					case CodeType.BeginCatchBlock:
					case CodeType.BeginFaultBlock:
					case CodeType.BeginFinallyBlock:
						extra[currentLast] = i;
						currentLast = i;
						break;
				}
			}

			// Now we look for consecutive exception blocks that have the same fault handler
			for (int i = 0; i < code.Count - 1; i++)
			{
				if (code[i].pseudo == CodeType.EndExceptionBlock
					&& code[i + 1].pseudo == CodeType.BeginExceptionBlock)
				{
					if (IsFaultOnlyBlock(extra, extra[i]) && IsFaultOnlyBlock(extra, i + 1))
					{
						int beginFault1 = extra[extra[i]];
						int beginFault2 = extra[i + 1];
						int length1 = extra[beginFault1] - beginFault1;
						int length2 = extra[beginFault2] - beginFault2;
						if (length1 == length2 && MatchHandlers(beginFault1, beginFault2, length1))
						{
							// Check if the labels at the start of the handler are reachable from outside
							// of the new combined block.
							for (int j = i + 2; j < beginFault2; j++)
							{
								if (code[j].pseudo == CodeType.OpCode)
								{
									break;
								}
								else if (code[j].pseudo == CodeType.Label)
								{
									if (HasBranchTo(0, extra[i], code[j].Label)
										|| HasBranchTo(beginFault2 + length2, code.Count, code[j].Label))
									{
										goto no_merge;
									}
								}
							}
							// Merge the two blocks by overwritting the first fault block and
							// the BeginExceptionBlock of the second block.
							for (int j = beginFault1; j < i + 2; j++)
							{
								code[j] = new OpCodeWrapper(OpCodes.Nop, null);
							}
							// Repair the linking structure.
							extra[extra[i]] = beginFault2;
							extra[extra[beginFault2]] = extra[i];
						}
					}
				no_merge: ;
				}
			}
		}

		private bool HasBranchTo(int start, int end, CodeEmitterLabel label)
		{
			for (int i = start; i < end; i++)
			{
				if (code[i].HasLabel)
				{
					if (code[i].Label == label)
					{
						return true;
					}
				}
				else if (code[i].opcode == OpCodes.Switch)
				{
					foreach (CodeEmitterLabel swlbl in code[i].Labels)
					{
						if (swlbl == label)
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		private bool MatchHandlers(int beginFault1, int beginFault2, int length)
		{
			for (int i = 0; i < length; i++)
			{
				if (!code[beginFault1 + i].Match(code[beginFault2 + i]))
				{
					return false;
				}
			}
			return true;
		}

		private bool IsFaultOnlyBlock(int[] extra, int begin)
		{
			return code[extra[begin]].pseudo == CodeType.BeginFaultBlock
				&& code[extra[extra[begin]]].pseudo == CodeType.EndExceptionBlock;
		}

		private void ConvertSynchronizedFaultToFinally()
		{
			bool labelIndexSet = false;
			int start = -1;
			int nest = 0;
			int next = -1;
			for (int i = 0; i < code.Count; i++)
			{
				switch (code[i].pseudo)
				{
					case CodeType.BeginExceptionBlock:
						if (nest == 0)
						{
							start = i;
						}
						else if (nest == 1 && next <= start)
						{
							next = i;
						}
						nest++;
						break;
					case CodeType.BeginCatchBlock:
					case CodeType.BeginFinallyBlock:
						if (nest == 1)
						{
							nest = 0;
							if (next > start)
							{
								// while we were processing the outer block, we encountered a nested BeginExceptionBlock
								// so now that we've failed the outer, restart at the first nested block
								i = start = next;
								nest = 1;
							}
						}
						else
						{
							next = -1;
						}
						break;
					case CodeType.BeginFaultBlock:
						if (nest == 1)
						{
							int beginFault = i;
							if (code[i + 1].pseudo == CodeType.LineNumber)
							{
								i++;
							}
							// check if the fault handler is the synchronized block exit pattern
							if (code[i + 1].opcode == OpCodes.Ldloc
								&& code[i + 2].pseudo == CodeType.MonitorExit
								&& code[i + 3].opcode == OpCodes.Endfinally)
							{
								if (!labelIndexSet)
								{
									labelIndexSet = true;
									SetLabelIndexes();
								}
								// now make two passes through the try block to 1) see if all leave
								// opcodes that leave the try block do a synchronized block exit
								// and 2) patch out the synchronized block exit
								for (int pass = 0; pass < 2; pass++)
								{
									for (int j = start; j < i; j++)
									{
										if (code[j].opcode == OpCodes.Leave)
										{
											int target = code[j].Label.Temp;
											if (target < start || target > i)
											{
												// check if the code preceding the leave matches the fault block
												if ((code[j - 1].opcode == OpCodes.Pop || code[j - 1].opcode == OpCodes.Stloc)
													&& code[j - 2].pseudo == CodeType.MonitorExit
													&& code[j - 3].Match(code[i + 1]))
												{
													if (pass == 1)
													{
														// move the leave to the top of the sequence we're removing
														code[j - 3] = code[j - 1];
														code[j - 2] = code[j - 0];
														code[j - 1] = new OpCodeWrapper(CodeType.Unreachable, CodeTypeFlags.None);
														code[j - 0] = new OpCodeWrapper(CodeType.Unreachable, CodeTypeFlags.None);
													}
												}
												else if (code[j - 1].pseudo == CodeType.MonitorExit
													&& code[j - 2].Match(code[i + 1]))
												{
													if (pass == 1)
													{
														// move the leave to the top of the sequence we're removing
														code[j - 2] = code[j];
														code[j - 1] = new OpCodeWrapper(CodeType.Unreachable, CodeTypeFlags.None);
														code[j - 0] = new OpCodeWrapper(CodeType.Unreachable, CodeTypeFlags.None);
													}
												}
												else
												{
													goto fail;
												}
											}
										}
									}
								}
								// if we end up here, all leaves have been successfully patched,
								// so now we turn the BeginFaultBlock into a BeginFinallyBlock
								code[beginFault] = new OpCodeWrapper(CodeType.BeginFinallyBlock, CodeTypeFlags.None);
							fail: ;
							}
							goto case CodeType.BeginFinallyBlock;
						}
						break;
					case CodeType.EndExceptionBlock:
						nest--;
						break;
				}
			}
		}

		private void RemoveRedundantMemoryBarriers()
		{
			int lastMemoryBarrier = -1;
			for (int i = 0; i < code.Count; i++)
			{
				switch (code[i].pseudo)
				{
					case CodeType.MemoryBarrier:
						if (lastMemoryBarrier != -1)
						{
							code.RemoveAt(lastMemoryBarrier);
							i--;
						}
						lastMemoryBarrier = i;
						break;
					case CodeType.OpCode:
						if (code[i].opcode == OpCodes.Volatile)
						{
							if (code[i + 1].opcode != OpCodes.Stfld && code[i + 1].opcode != OpCodes.Stsfld)
							{
								lastMemoryBarrier = -1;
							}
						}
						else if (code[i].opcode.FlowControl != FlowControl.Next)
						{
							lastMemoryBarrier = -1;
						}
						break;
				}
			}
		}

		private static bool MatchLdarg(OpCodeWrapper opc, out short arg)
		{
			if (opc.opcode == OpCodes.Ldarg)
			{
				arg = opc.ValueInt16;
				return true;
			}
			else if (opc.opcode == OpCodes.Ldarg_S)
			{
				arg = opc.ValueByte;
				return true;
			}
			else if (opc.opcode == OpCodes.Ldarg_0)
			{
				arg = 0;
				return true;
			}
			else if (opc.opcode == OpCodes.Ldarg_1)
			{
				arg = 1;
				return true;
			}
			else if (opc.opcode == OpCodes.Ldarg_2)
			{
				arg = 2;
				return true;
			}
			else if (opc.opcode == OpCodes.Ldarg_3)
			{
				arg = 3;
				return true;
			}
			else
			{
				arg = -1;
				return false;
			}
		}

		private bool IsBranchEqNe(OpCode opcode)
		{
			return opcode == OpCodes.Beq
				|| opcode == OpCodes.Bne_Un;
		}

		private void CLRv4_x64_JIT_Workaround()
		{
			for (int i = 0; i < code.Count - 2; i++)
			{
				// This is a workaround for https://connect.microsoft.com/VisualStudio/feedback/details/566946/x64-jit-optimization-bug
				// 
				// Testing shows that the bug appears to be very specific and requires a comparison of a method argument with zero.
				// For example, the problem goes away when the method argument is first assigned to a local variable and then
				// the comparison (and subsequent use) is done against the local variable.
				//
				// This means we only have to detect these specific patterns:
				//
				//   ldc.i8 0x0        ldarg
				//   ldarg             ldc.i8 0x0
				//   beq/bne           beq/bne
				//
				// The workaround is to replace ldarg with ldarga/ldind.i8. Looking at the generated code by the x86 and x64 JITs
				// this appears to be as efficient as the ldarg and it avoids the x64 bug.
				if (code[i].opcode == OpCodes.Ldc_I8 && code[i].ValueInt64 == 0)
				{
					short arg;
					int m;
					if (i > 0 && MatchLdarg(code[i - 1], out arg) && IsBranchEqNe(code[i + 1].opcode))
					{
						m = i - 1;
					}
					else if (MatchLdarg(code[i + 1], out arg) && IsBranchEqNe(code[i + 2].opcode))
					{
						m = i + 1;
					}
					else
					{
						continue;
					}
					code[m] = new OpCodeWrapper(OpCodes.Ldarga, arg);
					code.Insert(m + 1, new OpCodeWrapper(OpCodes.Ldind_I8, null));
				}
			}
		}

		[Conditional("CHECK_INVARIANTS")]
		private void CheckInvariants()
		{
			CheckInvariantBranchInOrOutOfBlocks();
			CheckInvariantOpCodeUsage();
			CheckInvariantLocalVariables();
		}

		private void CheckInvariantBranchInOrOutOfBlocks()
		{
			/*
			 * We maintain an invariant that a branch (other than an explicit leave)
			 * can never branch out or into an exception block (try or handler).
			 * This is a stronger invariant than requirement by MSIL, because
			 * we also disallow the following sequence:
			 * 
			 *    Br Label0
			 *    ...
			 *    BeginExceptionBlock
			 *    Label0:
			 *    ...
			 *    Br Label0
			 *    
			 * This should be rewritten as:
			 * 
			 *    Br Label0
			 *    ...
			 *    Label0:
			 *    BeginExceptionBlock
			 *    Label1:
			 *    ...
			 *    Br Label1
			 */
			int blockId = 0;
			int nextBlockId = 1;
			Stack<int> blocks = new Stack<int>();
			for (int i = 0; i < code.Count; i++)
			{
				switch (code[i].pseudo)
				{
					case CodeType.Label:
						code[i].Label.Temp = blockId;
						break;
					case CodeType.BeginExceptionBlock:
						blocks.Push(blockId);
						goto case CodeType.BeginFinallyBlock;
					case CodeType.BeginFinallyBlock:
					case CodeType.BeginFaultBlock:
					case CodeType.BeginCatchBlock:
						blockId = nextBlockId++;
						break;
					case CodeType.EndExceptionBlock:
						blockId = blocks.Pop();
						break;
				}
			}
			if (blocks.Count != 0)
			{
				throw new InvalidOperationException("Unbalanced exception blocks");
			}
			blockId = 0;
			nextBlockId = 1;
			for (int i = 0; i < code.Count; i++)
			{
				switch (code[i].pseudo)
				{
					case CodeType.OpCode:
						if (code[i].HasLabel
							&& code[i].opcode != OpCodes.Leave
							&& code[i].Label.Temp != blockId)
						{
							DumpMethod();
							throw new InvalidOperationException("Invalid branch " + code[i].opcode.Name + " at offset " + i + " from block " + blockId + " to " + code[i].Label.Temp);
						}
						break;
					case CodeType.BeginExceptionBlock:
						blocks.Push(blockId);
						goto case CodeType.BeginFinallyBlock;
					case CodeType.BeginFinallyBlock:
					case CodeType.BeginFaultBlock:
					case CodeType.BeginCatchBlock:
						blockId = nextBlockId++;
						break;
					case CodeType.EndExceptionBlock:
						blockId = blocks.Pop();
						break;
				}
			}
		}

		private void CheckInvariantOpCodeUsage()
		{
			for (int i = 0; i < code.Count; i++)
			{
				switch (code[i].opcode.FlowControl)
				{
					case FlowControl.Branch:
					case FlowControl.Cond_Branch:
						if (!code[i].HasLabel && code[i].opcode != OpCodes.Switch)
						{
							throw new InvalidOperationException();
						}
						break;
				}
			}
		}

		private void CheckInvariantLocalVariables()
		{
			List<CodeEmitterLocal> locals = new List<CodeEmitterLocal>();
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.DeclareLocal)
				{
					if (locals.Contains(code[i].Local))
					{
						throw new InvalidOperationException("Local variable used before declaration");
					}
				}
				else if (code[i].HasLocal)
				{
					locals.Add(code[i].Local);
				}
			}
		}

		private void MoveLocalDeclarationToBeginScope()
		{
			int pos = 0;
			for (int i = 0; i < code.Count; i++)
			{
				switch (code[i].pseudo)
				{
					case CodeType.BeginScope:
						pos = i + 1;
						break;
					case CodeType.DeclareLocal:
						OpCodeWrapper decl = code[i];
						code.RemoveAt(i);
						code.Insert(pos++, decl);
						break;
				}
			}
		}

		internal void DoEmit()
		{
			OptimizePatterns();
			CLRv4_x64_JIT_Workaround();
			RemoveRedundantMemoryBarriers();

			if (experimentalOptimizations)
			{
				CheckInvariants();
				MoveLocalDeclarationToBeginScope();

				for (int i = 0; i < 4; i++)
				{
					RemoveJumpNext();
					CheckInvariants();
					ChaseBranches();
					CheckInvariants();
					RemoveSingletonBranches();
					CheckInvariants();
					RemoveUnusedLabels();
					CheckInvariants();
					SortPseudoOpCodes();
					CheckInvariants();
					AnnihilatePops();
					CheckInvariants();
					AnnihilateStoreReleaseTempLocals();
					CheckInvariants();
					DeduplicateBranchSourceTargetCode();
					CheckInvariants();
					OptimizeStackTransfer();
					CheckInvariants();
					MergeExceptionBlocks();
					CheckInvariants();
					ConvertSynchronizedFaultToFinally();
					CheckInvariants();
					RemoveDeadCode();
					CheckInvariants();
				}
			}

#if STATIC_COMPILER
			OptimizeEncodings();
			OptimizeBranchSizes();
#endif

			int ilOffset = 0;
			int lineNumber = -1;
			for (int i = 0; i < code.Count; i++)
			{
				code[i].RealEmit(ilOffset, this, ref lineNumber);
#if STATIC_COMPILER || NET_4_0
				ilOffset = ilgen_real.ILOffset;
#else
				ilOffset += code[i].Size;
#endif
			}
		}

		internal void DumpMethod()
		{
			Dictionary<CodeEmitterLabel, int> labelIndexes = new Dictionary<CodeEmitterLabel, int>();
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label)
				{
					labelIndexes.Add(code[i].Label, i);
				}
			}
			Console.WriteLine("======================");
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.OpCode)
				{
					Console.Write("  " + code[i].opcode.Name);
					if (code[i].HasLabel)
					{
						Console.Write(" label" + labelIndexes[code[i].Label]);
					}
					else if (code[i].opcode == OpCodes.Ldarg_S || code[i].opcode == OpCodes.Ldarga_S)
					{
						Console.Write(" " + code[i].ValueByte);
					}
					else if (code[i].opcode == OpCodes.Ldarg || code[i].opcode == OpCodes.Ldarga)
					{
						Console.Write(" " + code[i].ValueInt16);
					}
					else if (code[i].opcode == OpCodes.Isinst || code[i].opcode == OpCodes.Castclass || code[i].opcode == OpCodes.Box || code[i].opcode == OpCodes.Unbox || code[i].opcode == OpCodes.Ldobj || code[i].opcode == OpCodes.Newarr)
					{
						Console.Write(" " + code[i].Type);
					}
					else if (code[i].opcode == OpCodes.Call || code[i].opcode == OpCodes.Callvirt)
					{
						Console.Write(" " + code[i].MethodBase);
					}
					else if (code[i].opcode == OpCodes.Ldfld || code[i].opcode == OpCodes.Ldsfld || code[i].opcode == OpCodes.Stfld || code[i].opcode == OpCodes.Stsfld)
					{
						Console.Write(" " + code[i].FieldInfo);
					}
					else if (code[i].opcode == OpCodes.Ldc_I4)
					{
						Console.Write(" " + code[i].ValueInt32);
					}
					else if (code[i].opcode == OpCodes.Ldloc || code[i].opcode == OpCodes.Stloc)
					{
						Console.Write(" " + code[i].Local.__LocalIndex);
					}
					Console.WriteLine();
				}
				else if (code[i].pseudo == CodeType.Label)
				{
					Console.WriteLine("label{0}:  // temp = {1}", i, code[i].Label.Temp);
				}
				else if (code[i].pseudo == CodeType.DeclareLocal)
				{
					Console.WriteLine("local #{0} = {1}", code[i].Local.__LocalIndex, code[i].Local.LocalType);
				}
				else
				{
					Console.WriteLine(code[i]);
				}
			}
		}

		internal void DefineSymbolDocument(ModuleBuilder module, string url, Guid language, Guid languageVendor, Guid documentType)
		{
			symbols = module.DefineDocument(url, language, languageVendor, documentType);
		}

		internal CodeEmitterLocal UnsafeAllocTempLocal(Type type)
		{
			int free = -1;
			for (int i = 0; i < tempLocals.Length; i++)
			{
				CodeEmitterLocal lb = tempLocals[i];
				if (lb == null)
				{
					if (free == -1)
					{
						free = i;
					}
				}
				else if (lb.LocalType == type)
				{
					return lb;
				}
			}
			CodeEmitterLocal lb1 = DeclareLocal(type);
			if (free != -1)
			{
				tempLocals[free] = lb1;
			}
			return lb1;
		}

		internal CodeEmitterLocal AllocTempLocal(Type type)
		{
			for (int i = 0; i < tempLocals.Length; i++)
			{
				CodeEmitterLocal lb = tempLocals[i];
				if (lb != null && lb.LocalType == type)
				{
					tempLocals[i] = null;
					return lb;
				}
			}
			return new CodeEmitterLocal(type);
		}

		internal void ReleaseTempLocal(CodeEmitterLocal lb)
		{
			EmitPseudoOpCode(CodeType.ReleaseTempLocal, lb);
			for (int i = 0; i < tempLocals.Length; i++)
			{
				if (tempLocals[i] == null)
				{
					tempLocals[i] = lb;
					break;
				}
			}
		}

		internal void BeginCatchBlock(Type exceptionType)
		{
			EmitPseudoOpCode(CodeType.BeginCatchBlock, exceptionType);
		}

		internal void BeginExceptionBlock()
		{
#if !STATIC_COMPILER
			exceptionStack.Push(inFinally);
			inFinally = false;
#endif
			EmitPseudoOpCode(CodeType.BeginExceptionBlock, null);
		}

		internal void BeginFaultBlock()
		{
#if !STATIC_COMPILER
			inFinally = true;
#endif
			EmitPseudoOpCode(CodeType.BeginFaultBlock, null);
		}

		internal void BeginFinallyBlock()
		{
#if !STATIC_COMPILER
			inFinally = true;
#endif
			EmitPseudoOpCode(CodeType.BeginFinallyBlock, null);
		}

		internal void BeginScope()
		{
			EmitPseudoOpCode(CodeType.BeginScope, null);
		}

		internal CodeEmitterLocal DeclareLocal(Type localType)
		{
			CodeEmitterLocal local = new CodeEmitterLocal(localType);
			EmitPseudoOpCode(CodeType.DeclareLocal, local);
			return local;
		}

		internal CodeEmitterLabel DefineLabel()
		{
			CodeEmitterLabel label = new CodeEmitterLabel(ilgen_real.DefineLabel());
#if LABELCHECK
			labels.Add(label, new System.Diagnostics.StackFrame(1, true));
#endif
			return label;
		}

		internal void Emit(OpCode opcode)
		{
			EmitOpCode(opcode, null);
		}

		internal void EmitUnaligned(byte alignment)
		{
			EmitOpCode(OpCodes.Unaligned, alignment);
		}

		internal void Emit(OpCode opcode, MethodBase mb)
		{
			EmitOpCode(opcode, mb);
		}

		internal void EmitLdc_R8(double arg)
		{
			EmitOpCode(OpCodes.Ldc_R8, arg);
		}

		internal void Emit(OpCode opcode, FieldInfo field)
		{
			EmitOpCode(opcode, field);
		}

		internal void EmitLdarg(int arg)
		{
			Debug.Assert(0 <= arg && arg < 65536);
			switch (arg)
			{
				case 0:
					EmitOpCode(OpCodes.Ldarg_0, null);
					break;
				case 1:
					EmitOpCode(OpCodes.Ldarg_1, null);
					break;
				case 2:
					EmitOpCode(OpCodes.Ldarg_2, null);
					break;
				case 3:
					EmitOpCode(OpCodes.Ldarg_3, null);
					break;
				default:
					if (arg < 256)
					{
						EmitOpCode(OpCodes.Ldarg_S, (byte)arg);
					}
					else
					{
						EmitOpCode(OpCodes.Ldarg, (short)arg);
					}
					break;
			}
		}

		internal void EmitLdarga(int arg)
		{
			Debug.Assert(0 <= arg && arg < 65536);
			if (arg < 256)
			{
				EmitOpCode(OpCodes.Ldarga_S, (byte)arg);
			}
			else
			{
				EmitOpCode(OpCodes.Ldarga, (short)arg);
			}
		}

		internal void EmitStarg(int arg)
		{
			Debug.Assert(0 <= arg && arg < 65536);
			if (arg < 256)
			{
				EmitOpCode(OpCodes.Starg_S, (byte)arg);
			}
			else
			{
				EmitOpCode(OpCodes.Starg, (short)arg);
			}
		}

		internal void EmitLdc_I8(long arg)
		{
			EmitOpCode(OpCodes.Ldc_I8, arg);
		}

		internal void EmitBr(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Br, label);
		}

		internal void EmitBeq(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Beq, label);
		}

		internal void EmitBne_Un(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Bne_Un, label);
		}

		internal void EmitBle_Un(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Ble_Un, label);
		}

		internal void EmitBlt_Un(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Blt_Un, label);
		}

		internal void EmitBge_Un(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Bge_Un, label);
		}

		internal void EmitBle(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Ble, label);
		}

		internal void EmitBlt(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Blt, label);
		}

		internal void EmitBge(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Bge, label);
		}

		internal void EmitBgt(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Bgt, label);
		}

		internal void EmitBrtrue(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Brtrue, label);
		}

		internal void EmitBrfalse(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Brfalse, label);
		}

		internal void EmitLeave(CodeEmitterLabel label)
		{
			EmitOpCode(OpCodes.Leave, label);
		}

		internal void EmitSwitch(CodeEmitterLabel[] labels)
		{
			EmitOpCode(OpCodes.Switch, labels);
		}

		internal void Emit(OpCode opcode, CodeEmitterLocal local)
		{
			EmitOpCode(opcode, local);
		}

		internal void EmitLdc_R4(float arg)
		{
			EmitOpCode(OpCodes.Ldc_R4, arg);
		}

		internal void Emit(OpCode opcode, string arg)
		{
			EmitOpCode(opcode, arg);
		}

		internal void Emit(OpCode opcode, Type cls)
		{
			EmitOpCode(opcode, cls);
		}

		internal void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
		{
			EmitOpCode(opcode, new CalliWrapper(unmanagedCallConv, returnType, parameterTypes));
		}

		internal void EndExceptionBlock()
		{
#if STATIC_COMPILER
			EmitPseudoOpCode(CodeType.EndExceptionBlock, null);
#else
			EmitPseudoOpCode(CodeType.EndExceptionBlock, inFinally ? CodeTypeFlags.EndFaultOrFinally : CodeTypeFlags.None);
			inFinally = exceptionStack.Pop();
#endif
		}

		internal void EndScope()
		{
			EmitPseudoOpCode(CodeType.EndScope, null);
		}

		internal void MarkLabel(CodeEmitterLabel loc)
		{
#if LABELCHECK
			labels.Remove(loc);
#endif
			EmitPseudoOpCode(CodeType.Label, loc);
		}

		internal void ThrowException(Type excType)
		{
			Emit(OpCodes.Newobj, excType.GetConstructor(Type.EmptyTypes));
			Emit(OpCodes.Throw);
		}

		internal void SetLineNumber(ushort line)
		{
			if (symbols != null)
			{
				EmitPseudoOpCode(CodeType.SequencePoint, (int)line);
			}
			EmitPseudoOpCode(CodeType.LineNumber, (int)line);
		}

		internal byte[] GetLineNumberTable()
		{
			return linenums == null ? null : linenums.ToArray();
		}

#if STATIC_COMPILER
		internal void EmitLineNumberTable(MethodBuilder mb)
		{
			if(linenums != null)
			{
				AttributeHelper.SetLineNumberTable(mb, linenums);
			}
		}
#endif // STATIC_COMPILER

		internal void EmitThrow(string dottedClassName)
		{
			TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dottedClassName);
			MethodWrapper mw = exception.GetMethodWrapper("<init>", "()V", false);
			mw.Link();
			mw.EmitNewobj(this);
			Emit(OpCodes.Throw);
		}

		internal void EmitThrow(string dottedClassName, string message)
		{
			TypeWrapper exception = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedName(dottedClassName);
			Emit(OpCodes.Ldstr, message);
			MethodWrapper mw = exception.GetMethodWrapper("<init>", "(Ljava.lang.String;)V", false);
			mw.Link();
			mw.EmitNewobj(this);
			Emit(OpCodes.Throw);
		}

		internal void EmitNullCheck()
		{
			// I think this is the most efficient way to generate a NullReferenceException if the reference is null
			Emit(OpCodes.Ldvirtftn, objectToString);
			Emit(OpCodes.Pop);
		}

		internal void EmitCastclass(Type type)
		{
			if (verboseCastFailure != null)
			{
				CodeEmitterLocal lb = DeclareLocal(Types.Object);
				Emit(OpCodes.Stloc, lb);
				Emit(OpCodes.Ldloc, lb);
				Emit(OpCodes.Isinst, type);
				Emit(OpCodes.Dup);
				CodeEmitterLabel ok = DefineLabel();
				EmitBrtrue(ok);
				Emit(OpCodes.Ldloc, lb);
				EmitBrfalse(ok);	// handle null
				Emit(OpCodes.Ldtoken, type);
				Emit(OpCodes.Ldloc, lb);
				Emit(OpCodes.Call, verboseCastFailure);
				MarkLabel(ok);
			}
			else
			{
				Emit(OpCodes.Castclass, type);
			}
		}

		// This is basically the same as Castclass, except that it
		// throws an IncompatibleClassChangeError on failure.
		internal void EmitAssertType(Type type)
		{
			CodeEmitterLabel isnull = DefineLabel();
			Emit(OpCodes.Dup);
			EmitBrfalse(isnull);
			Emit(OpCodes.Isinst, type);
			Emit(OpCodes.Dup);
			CodeEmitterLabel ok = DefineLabel();
			EmitBrtrue(ok);
			EmitThrow("java.lang.IncompatibleClassChangeError");
			MarkLabel(isnull);
			Emit(OpCodes.Pop);
			Emit(OpCodes.Ldnull);
			MarkLabel(ok);
		}

		internal void EmitUnboxSpecial(Type type)
		{
			// NOTE if the reference is null, we treat it as a default instance of the value type.
			Emit(OpCodes.Dup);
			CodeEmitterLabel label1 = DefineLabel();
			EmitBrtrue(label1);
			Emit(OpCodes.Pop);
			CodeEmitterLocal local = AllocTempLocal(type);
			Emit(OpCodes.Ldloca, local);
			Emit(OpCodes.Initobj, type);
			Emit(OpCodes.Ldloc, local);
			ReleaseTempLocal(local);
			CodeEmitterLabel label2 = DefineLabel();
			EmitBr(label2);
			MarkLabel(label1);
			Emit(OpCodes.Unbox, type);
			Emit(OpCodes.Ldobj, type);
			MarkLabel(label2);
		}

		internal void EmitLdc_I4(int i)
		{
			EmitOpCode(OpCodes.Ldc_I4, i);
		}

		internal void Emit_idiv()
		{
			// we need to special case dividing by -1, because the CLR div instruction
			// throws an OverflowException when dividing Int32.MinValue by -1, and
			// Java just silently overflows
			Emit(OpCodes.Dup);
			Emit(OpCodes.Ldc_I4_M1);
			CodeEmitterLabel label = DefineLabel();
			EmitBne_Un(label);
			Emit(OpCodes.Pop);
			Emit(OpCodes.Neg);
			CodeEmitterLabel label2 = DefineLabel();
			EmitBr(label2);
			MarkLabel(label);
			Emit(OpCodes.Div);
			MarkLabel(label2);
		}

		internal void Emit_ldiv()
		{
			// we need to special case dividing by -1, because the CLR div instruction
			// throws an OverflowException when dividing Int32.MinValue by -1, and
			// Java just silently overflows
			Emit(OpCodes.Dup);
			Emit(OpCodes.Ldc_I4_M1);
			Emit(OpCodes.Conv_I8);
			CodeEmitterLabel label = DefineLabel();
			EmitBne_Un(label);
			Emit(OpCodes.Pop);
			Emit(OpCodes.Neg);
			CodeEmitterLabel label2 = DefineLabel();
			EmitBr(label2);
			MarkLabel(label);
			Emit(OpCodes.Div);
			MarkLabel(label2);
		}

		internal void Emit_instanceof(Type type)
		{
			Emit(OpCodes.Isinst, type);
			Emit(OpCodes.Ldnull);
			Emit(OpCodes.Cgt_Un);
		}

		internal enum Comparison
		{
			LessOrEqual,
			LessThan,
			GreaterOrEqual,
			GreaterThan
		}

		internal void Emit_if_le_lt_ge_gt(Comparison comp, CodeEmitterLabel label)
		{
			// don't change this Ldc_I4_0 to Ldc_I4(0) because the optimizer recognizes
			// only this specific pattern
			Emit(OpCodes.Ldc_I4_0);
			switch (comp)
			{
				case Comparison.LessOrEqual:
					EmitBle(label);
					break;
				case Comparison.LessThan:
					EmitBlt(label);
					break;
				case Comparison.GreaterOrEqual:
					EmitBge(label);
					break;
				case Comparison.GreaterThan:
					EmitBgt(label);
					break;
			}
		}

		private void EmitCmp(Type type, OpCode cmp1, OpCode cmp2)
		{
			CodeEmitterLocal value1 = AllocTempLocal(type);
			CodeEmitterLocal value2 = AllocTempLocal(type);
			Emit(OpCodes.Stloc, value2);
			Emit(OpCodes.Stloc, value1);
			Emit(OpCodes.Ldloc, value1);
			Emit(OpCodes.Ldloc, value2);
			Emit(cmp1);
			Emit(OpCodes.Ldloc, value1);
			Emit(OpCodes.Ldloc, value2);
			Emit(cmp2);
			Emit(OpCodes.Sub);
			ReleaseTempLocal(value2);
			ReleaseTempLocal(value1);
		}

		internal void Emit_lcmp()
		{
			EmitCmp(Types.Int64, OpCodes.Cgt, OpCodes.Clt);
		}

		internal void Emit_fcmpl()
		{
			EmitCmp(Types.Single, OpCodes.Cgt, OpCodes.Clt_Un);
		}

		internal void Emit_fcmpg()
		{
			EmitCmp(Types.Single, OpCodes.Cgt_Un, OpCodes.Clt);
		}

		internal void Emit_dcmpl()
		{
			EmitCmp(Types.Double, OpCodes.Cgt, OpCodes.Clt_Un);
		}

		internal void Emit_dcmpg()
		{
			EmitCmp(Types.Double, OpCodes.Cgt_Un, OpCodes.Clt);
		}

		internal void Emit_And_I4(int v)
		{
			EmitLdc_I4(v);
			Emit(OpCodes.And);
		}

		internal void CheckLabels()
		{
#if LABELCHECK
			foreach(System.Diagnostics.StackFrame frame in labels.Values)
			{
				string name = frame.GetFileName() + ":" + frame.GetFileLineNumber();
				IKVM.Internal.JVM.CriticalFailure("Label failure: " + name, null);
			}
#endif
		}

		internal void EmitMemoryBarrier()
		{
			EmitPseudoOpCode(CodeType.MemoryBarrier, null);
		}

		internal void EmitTailCallPrevention()
		{
			EmitPseudoOpCode(CodeType.TailCallPrevention, null);
		}

		internal void EmitClearStack()
		{
			EmitPseudoOpCode(CodeType.ClearStack, null);
		}

		internal void EmitMonitorEnter()
		{
			EmitPseudoOpCode(CodeType.MonitorEnter, null);
		}

		internal void EmitMonitorExit()
		{
			EmitPseudoOpCode(CodeType.MonitorExit, null);
		}
	}
}
@


1.94
log
@Dump more info for locals.
@
text
@d1201 1
a1201 2
			OpCode opc = OpCodes.Nop;
			switch (value)
d1203 2
a1204 56
				case -1:
					opc = OpCodes.Ldc_I4_M1;
					break;
				case 0:
					opc = OpCodes.Ldc_I4_0;
					break;
				case 1:
					opc = OpCodes.Ldc_I4_1;
					break;
				case 2:
					opc = OpCodes.Ldc_I4_2;
					break;
				case 3:
					opc = OpCodes.Ldc_I4_3;
					break;
				case 4:
					opc = OpCodes.Ldc_I4_4;
					break;
				case 5:
					opc = OpCodes.Ldc_I4_5;
					break;
				case 6:
					opc = OpCodes.Ldc_I4_6;
					break;
				case 7:
					opc = OpCodes.Ldc_I4_7;
					break;
				case 8:
					opc = OpCodes.Ldc_I4_8;
					break;
				default:
					if (value >= -2147483648L && value <= 4294967295L)
					{
						if (value >= -128 && value <= 127)
						{
							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S, (sbyte)value);
						}
						else
						{
							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4, (int)value);
						}
						if (value < 0)
						{
							code.Insert(index + 1, new OpCodeWrapper(OpCodes.Conv_I8, null));
						}
						else
						{
							code.Insert(index + 1, new OpCodeWrapper(OpCodes.Conv_U8, null));
						}
					}
					break;
			}
			if (opc != OpCodes.Nop)
			{
				code[index] = new OpCodeWrapper(opc, null);
				code.Insert(index + 1, new OpCodeWrapper(OpCodes.Conv_I8, null));
@


1.93
log
@Improved DumpMethod().
@
text
@d2403 4
d2413 4
@


1.92
log
@Added stfld and stsfld support to DumpMethod().
@
text
@d2379 5
a2383 1
					else if (code[i].opcode == OpCodes.Ldarg)
@


1.91
log
@Some minor DumpMethod improvements.
@
text
@d2391 1
a2391 1
					else if (code[i].opcode == OpCodes.Ldfld || code[i].opcode == OpCodes.Ldsfld)
@


1.90
log
@Removed remaining ConstructorBuilder usages.
@
text
@d2383 1
a2383 1
					else if (code[i].opcode == OpCodes.Isinst)
d2391 8
@


1.89
log
@Merged CodeEmitter.Emit(OpCode, MethodInfo) and CodeEmitter.Emit(OpCode, ConstructorInfo) into CodeEmitter.Emit(OpCode, MethodBase) and removed unnecessary downcasting.
@
text
@a457 5
		internal static CodeEmitter Create(ConstructorBuilder cb)
		{
			return new CodeEmitter(cb.GetILGenerator(), cb.DeclaringType);
		}

d2738 1
a2738 1
		internal void EmitLineNumberTable(MethodBase mb)
@


1.88
log
@Improved (disabled) optimizations.
- IsSideEffectFreePush() now knows the current type so it knows that static field loads from the current type are side effect free.
- Added Ldarg_S, Ldarg_<n> to IsSideEffectFreePush().
- Improved temporary local removal.
- Improved pop annihilation.
@
text
@d2528 1
a2528 1
		internal void Emit(OpCode opcode, ConstructorInfo con)
d2530 1
a2530 1
			EmitOpCode(opcode, con);
a2678 5
		internal void Emit(OpCode opcode, MethodInfo meth)
		{
			EmitOpCode(opcode, meth);
		}

@


1.87
log
@Added another optimization to convert synchronized blocks into try {} finally {} (instead of try {} fault {}).
@
text
@d116 1
d455 1
a455 1
			return new CodeEmitter(mb.GetILGenerator());
d460 1
a460 1
			return new CodeEmitter(cb.GetILGenerator());
d466 1
a466 1
			return new CodeEmitter(dm.GetILGenerator());
d470 1
a470 1
		private CodeEmitter(ILGenerator ilgen)
d476 1
d672 1
a672 3
				if (code[i].opcode == OpCodes.Stloc
					&& code[i + 1].pseudo == CodeType.ReleaseTempLocal
					&& code[i].Local == code[i + 1].Local)
d674 12
a685 2
					code.RemoveRange(i, 1);
					code[i] = new OpCodeWrapper(OpCodes.Pop, null);
d694 1
a694 2
				if (code[i].opcode == OpCodes.Pop
					&& IsSideEffectFreePush(i - 1))
d696 45
a740 2
					code.RemoveRange(i - 1, 2);
					i -= 2;
a756 4
				// Here we are considering BeforeFieldInit to mean that we really don't care about
				// when the type is initialized (which is what we mean in the rest of the IKVM code as well)
				// but it is good to point it out here because strictly speaking we're violating the
				// BeforeFieldInit contract here by considering dummy loads not to be field accesses.
d758 1
a758 1
				if (field != null && (field.DeclaringType.Attributes & TypeAttributes.BeforeFieldInit) != 0)
d760 14
a773 5
					return true;
				}
				else
				{
					return false;
d775 1
d801 20
a1455 1
					case CodeType.LineNumber:
d1457 1
a1457 1
						if (code[i + 1].opcode == OpCodes.Pop)
d1459 10
a1468 13
							OpCodeWrapper temp = code[i];
							code[i] = code[i + 1];
							code[i + 1] = temp;
							i--;
						}
						break;
					case CodeType.BeginExceptionBlock:
						if (code[i + 1].pseudo == CodeType.ReleaseTempLocal)
						{
							OpCodeWrapper temp = code[i];
							code[i] = code[i + 1];
							code[i + 1] = temp;
							i--;
d1475 21
@


1.86
log
@- Made CodeEmitter more "type safe" by adding specific EmitXxx methods instead of following the more general ILGenerator pattern.
- Added some new optimizations to CodeEmitter (disabled unless experimental optimizations are enabled).
- Added some invariant checks to CodeEmitter to help debug optimizations (and document the invariants).
@
text
@d103 2
d147 2
d301 2
d539 6
d1832 117
d2244 2
d2902 10
@


1.85
log
@Added a simple optimization (disabled unless the IKVM_EXPERIMENTAL_OPTIMIZATIONS environment variable is set) to replace unconditional branches to ret or endfinally with the target instruction.
@
text
@d25 1
d144 1
d211 5
d300 2
d537 3
d824 1
a824 1
			UpdateLabelRefCounts();
d874 1
a874 1
					&& code[i + 3].opcode == OpCodes.Bne_Un_S
d877 1
a877 1
					&& code[i + 6].opcode == OpCodes.Br_S
d899 1
a899 1
					&& code[i + 4].opcode == OpCodes.Bne_Un_S
d902 1
a902 1
					&& code[i + 7].opcode == OpCodes.Br_S
d929 1
a929 1
					&& code[i + 2].opcode == OpCodes.Brtrue_S
d935 1
a935 1
					&& code[i + 8].opcode == OpCodes.Br_S
d1181 5
a1185 3
			 * Previous implementation was broken. We need to take try-blocks into account,
			 * because it is possible to jump into a try block (not from an opcode point of view,
			 * but from a pseudo opcode point of view).
d1187 1
a1187 12

			// TODO implement branch -> branch optimization

			// now replace branches to endfinally or ret with the direct instruction
			// (this is always more or at least as efficient, because they are smaller or the same size)
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label)
				{
					code[i].Label.Temp = i;
				}
			}
d1195 1
a1195 1
						// line number info an endfinally or ret is probably useless anyway
d1202 139
d1343 15
a1384 9
					case CodeType.Label:
						if (code[i + 1].pseudo == CodeType.BeginExceptionBlock)
						{
							OpCodeWrapper temp = code[i];
							code[i] = code[i + 1];
							code[i + 1] = temp;
							i--;
						}
						break;
d1389 1
a1389 1
		private void UpdateLabelRefCounts()
d1398 16
d1435 1
a1435 1
			UpdateLabelRefCounts();
d1447 1
a1447 7
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label)
				{
					code[i].Label.Temp = 0;
				}
			}
a1496 13
									if (code[i].HasLabel)
									{
										reachable = false;
									}
									else if (code[i].HasValueByte && code[i].ValueByte == 0)
									{
										// it's a "leave_s 0", so the next instruction is reachable
									}
									else
									{
										throw new NotSupportedException();
									}
									break;
a1536 9
								if (code[i].HasValueByte && code[i].ValueByte == 0)
								{
									// it's a "leave_s 0", so the next instruction is reachable
								}
								else
								{
									goto case FlowControl.Return;
								}
								break;
d1622 1
a1622 7
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label)
				{
					code[i].Label.Temp = i;
				}
			}
d1894 1
a1894 3
				|| opcode == OpCodes.Beq_S
				|| opcode == OpCodes.Bne_Un
				|| opcode == OpCodes.Bne_Un_S;
d1937 145
d2090 3
d2096 1
d2098 3
d2102 1
d2104 1
d2106 1
d2108 1
d2110 1
d2112 1
d2114 1
d2116 1
d2174 1
a2174 1
					Console.WriteLine("label{0}:", i);
d2297 1
a2297 1
		internal void Emit(OpCode opcode, byte arg)
d2299 1
a2299 1
			EmitOpCode(opcode, arg);
d2307 1
a2307 1
		internal void Emit(OpCode opcode, double arg)
d2309 1
a2309 1
			EmitOpCode(opcode, arg);
d2317 1
a2317 1
		internal void Emit(OpCode opcode, short arg)
d2319 107
a2425 1
			EmitOpCode(opcode, arg);
d2428 1
a2428 1
		internal void Emit(OpCode opcode, int arg)
d2430 1
a2430 1
			EmitOpCode(opcode, arg);
d2433 1
a2433 1
		internal void Emit(OpCode opcode, long arg)
d2435 1
a2435 1
			EmitOpCode(opcode, arg);
d2438 1
a2438 1
		internal void Emit(OpCode opcode, CodeEmitterLabel label)
d2440 1
a2440 1
			EmitOpCode(opcode, label);
d2443 1
a2443 1
		internal void Emit(OpCode opcode, CodeEmitterLabel[] labels)
d2445 1
a2445 1
			EmitOpCode(opcode, labels);
d2458 1
a2458 1
		internal void Emit(OpCode opcode, sbyte arg)
d2460 1
a2460 6
			EmitOpCode(opcode, arg);
		}

		internal void Emit(OpCode opcode, float arg)
		{
			EmitOpCode(opcode, arg);
d2567 1
a2567 1
				Emit(OpCodes.Brtrue_S, ok);
d2569 1
a2569 1
				Emit(OpCodes.Brfalse_S, ok);	// handle null
d2587 1
a2587 1
			Emit(OpCodes.Brfalse_S, isnull);
d2591 1
a2591 1
			Emit(OpCodes.Brtrue_S, ok);
d2604 1
a2604 1
			Emit(OpCodes.Brtrue_S, label1);
d2612 1
a2612 1
			Emit(OpCodes.Br_S, label2);
d2619 1
a2619 3
		// the purpose of this method is to avoid calling a wrong overload of Emit()
		// (e.g. when passing a byte or short)
		internal void Emit_Ldc_I4(int i)
d2621 1
a2621 1
			Emit(OpCodes.Ldc_I4, i);
d2632 1
a2632 1
			Emit(OpCodes.Bne_Un_S, label);
d2636 1
a2636 1
			Emit(OpCodes.Br_S, label2);
d2651 1
a2651 1
			Emit(OpCodes.Bne_Un_S, label);
d2655 1
a2655 1
			Emit(OpCodes.Br_S, label2);
d2684 1
a2684 1
					Emit(OpCodes.Ble, label);
d2687 1
a2687 1
					Emit(OpCodes.Blt, label);
d2690 1
a2690 1
					Emit(OpCodes.Bge, label);
d2693 1
a2693 1
					Emit(OpCodes.Bgt, label);
d2742 1
a2742 1
			Emit(OpCodes.Ldc_I4, v);
d2766 5
@


1.84
log
@Prevent the tail call elimination opcode sequence (ldnull/pop) from being optimized out.
@
text
@d1173 28
@


1.83
log
@Slightly more efficient encoding of EmitAssertType().
@
text
@d2 1
a2 1
  Copyright (C) 2002-2010 Jeroen Frijters
d142 1
d291 2
d524 4
d2346 5
@


1.82
log
@Improved DumpMethod and made it internal.
@
text
@d2161 3
a2163 3
			CodeEmitterLocal lb = DeclareLocal(Types.Object);
			Emit(OpCodes.Stloc, lb);
			Emit(OpCodes.Ldloc, lb);
a2167 2
			Emit(OpCodes.Ldloc, lb);
			Emit(OpCodes.Brfalse_S, ok);	// handle null
d2169 3
@


1.81
log
@Undo accidental commit.
@
text
@d253 5
d1815 1
a1815 1
		private void DumpMethod()
d1835 12
@


1.80
log
@Optimized the Type == operator.
@
text
@a1413 1
								// TODO this is wrong when we encounter a try block in the try block
@


1.79
log
@Fixed regression introduced by x64 v4 JIT bug workaround. Only (in)equality comparison branches should match the pattern.
@
text
@d1414 1
@


1.78
log
@Added workaround for https://connect.microsoft.com/VisualStudio/feedback/details/566946/x64-jit-optimization-bug
@
text
@d1721 8
d1743 1
a1743 1
				//   bcc               bcc
d1751 1
a1751 1
					if (i > 0 && MatchLdarg(code[i - 1], out arg) && code[i + 1].opcode.FlowControl == FlowControl.Cond_Branch)
d1755 1
a1755 1
					else if (MatchLdarg(code[i + 1], out arg) && code[i + 2].opcode.FlowControl == FlowControl.Cond_Branch)
@


1.77
log
@Added optimization to remove redundant memory barriers.
@
text
@d228 5
d1682 79
d1764 1
@


1.76
log
@Volatile stores require a memory barrier. Fix for #3086040.
@
text
@d141 1
d278 2
d504 7
d1645 32
d1680 1
d2226 1
a2226 5
			if (memoryBarrier == null)
			{
				memoryBarrier = JVM.Import(typeof(System.Threading.Thread)).GetMethod("MemoryBarrier", Type.EmptyTypes);
			}
			Emit(OpCodes.Call, memoryBarrier);
@


1.75
log
@Disabled the new (complicated and possibly broken) optimizations unless IKVM_EXPERIMENTAL_OPTIMIZATIONS environment variable is set.
@
text
@d103 1
d2180 9
@


1.74
log
@- Removed EndExceptionBlockFinally and folded the behaviour into EndExceptionBlock (runtime compiler only).
- Removed EndExceptionBlockNoFallThrough() and added "leave guard" branch after every EndExceptionBlock (runtime compiler only).
- Fixed remaining dependencies on exception fall through behavior of ILGenerator.
@
text
@d24 1
d102 1
d116 8
d1638 1
a1638 2
#if STATIC_COMPILER || true
			for (int i = 0; i < 4; i++)
d1640 13
a1652 10
				RemoveJumpNext();
				ChaseBranches();
				RemoveUnusedLabels();
				SortPseudoOpCodes();
				AnnihilatePops();
				AnnihilateStoreReleaseTempLocals();
				DeduplicateBranchSourceTargetCode();
				OptimizeStackTransfer();
				MergeExceptionBlocks();
				RemoveDeadCode();
a1653 1
			//DumpMethod();
d1655 1
@


1.73
log
@Fixed RemoveDeadCode() bug and re-enabled it.
@
text
@d114 1
a114 1
		enum CodeType
d130 6
a135 3
#if !STATIC_COMPILER
			EndExceptionBlockFinally,
#endif
d141 1
d148 1
d153 8
d164 1
d260 5
a264 3
							return 5;
						case CodeType.EndExceptionBlockFinally:
							return 1;
d482 2
d485 3
a487 3
				case CodeType.EndExceptionBlockFinally:
					ilgen_real.EndExceptionBlock();
					break;
a488 2
				case CodeType.EndExceptionBlock:
					ilgen_real.EndExceptionBlock();
d1628 1
a1628 1
#if STATIC_COMPILER
a1887 10
		internal void EndExceptionBlockNoFallThrough()
		{
			EndExceptionBlock();
#if !STATIC_COMPILER
			// HACK to keep the verifier happy we need this bogus jump
			// (because of the bogus Leave that Ref.Emit ends the try block with)
			Emit(OpCodes.Br_S, (sbyte)-2);
#endif
		}

d1893 1
a1893 8
			if(inFinally)
			{
				EmitPseudoOpCode(CodeType.EndExceptionBlockFinally, null);
			}
			else
			{
				EmitPseudoOpCode(CodeType.EndExceptionBlock, null);
			}
@


1.72
log
@Improved DumpMethod() a bit.
@
text
@d1355 4
d1624 1
a1624 1
				//RemoveDeadCode();	// <-- broken
@


1.71
log
@Removed broken ChaseBranches() implementation.
@
text
@d1643 8
d1656 10
a1665 1
					Console.WriteLine("  " + code[i].opcode.Name);
@


1.70
log
@Commented out dead code elimination optimization, as it is currently broken (or exposes another bug). Also fixed a dependency on DCE.
@
text
@d1114 5
a1118 28
			Dictionary<CodeEmitterLabel, int> indexes = new Dictionary<CodeEmitterLabel, int>();
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].pseudo == CodeType.Label)
				{
					int target = i + 1;
					while (code[target].pseudo == CodeType.LineNumber || code[target].pseudo == CodeType.Label)
					{
						target++;
					}
					indexes[code[i].Label] = target;
				}
			}
			for (int i = 0; i < code.Count; i++)
			{
				if (code[i].opcode == OpCodes.Leave
					&& code[i].HasLabel)
				{
					int target = indexes[code[i].Label];
					if ((code[target].opcode == OpCodes.Br || code[target].opcode == OpCodes.Leave)
						&& code[target].HasLabel
						&& target != i)
					{
						code[i] = new OpCodeWrapper(OpCodes.Leave, code[target].Label);
						i--;
					}
				}
			}
@


1.69
log
@More optimizations.
@
text
@d116 1
d228 1
d433 2
d1468 1
a1468 1
							for (int j = source + 1; j < i; j++)
d1470 3
a1472 3
								// This is to make sure that any line numbers here are removed by DCE.
								// It may be better to fix DCE to remove unreachable line numbers.
								code[j] = new OpCodeWrapper(OpCodes.Nop, null);
d1643 1
a1643 1
				RemoveDeadCode();
@


1.68
log
@More optimizations.
@
text
@d754 1
d808 1
a808 1
					&& code[i + 7].pseudo == CodeType.Label && code[i + 7].Label == code[i + 3].Label
d810 1
a810 1
					&& code[i + 9].pseudo == CodeType.Label && code[i + 9].Label == code[i + 6].Label)
d833 1
a833 1
					&& code[i + 8].pseudo == CodeType.Label && code[i + 8].Label == code[i + 4].Label
d835 1
a835 1
					&& code[i + 10].pseudo == CodeType.Label && code[i + 10].Label == code[i + 7].Label)
d866 1
a866 1
					&& code[i + 9].pseudo == CodeType.Label && code[i + 9].Label == code[i + 2].Label
d869 1
a869 1
					&& code[i + 12].pseudo == CodeType.Label && code[i + 12].Label == code[i + 8].Label)
d873 61
d1178 1
a1178 1
		private void RemoveUnusedLabels()
d1204 5
@


1.67
log
@Added more peephole optimizations.
@
text
@d154 7
d371 5
d564 1
a564 3
				if (code[i].pseudo == CodeType.Label
					&& code[i - 1].opcode == OpCodes.Br
					&& code[i - 1].MatchLabel(code[i]))
d566 14
a579 2
					code.RemoveAt(i - 1);
					i--;
d1078 1
a1078 1
		private void BubblePopsAndReleaseTempLocals()
d1091 1
a1091 1
							i -= 2;
d1100 10
a1109 1
							i -= 2;
d1307 247
d1561 1
a1561 1
			for (int i = 0; i < 2; i++)
d1566 1
a1566 1
				BubblePopsAndReleaseTempLocals();
d1569 3
d1574 1
d1600 1
a1600 1
					Console.WriteLine(code[i].opcode.Name);
d1604 1
a1604 1
					Console.WriteLine(code[i].pseudo);
@


1.66
log
@During static compilation we can disable exception block "assistance", so we don't need to track finally blocks.
@
text
@d42 2
a43 2
		private Label label;
		private int offset = -1;
d47 1
a47 26
			this.label = label;
		}

		internal Label Label
		{
			get
			{
				return label;
			}
		}

		internal int Offset
		{
			get
			{
				return offset;
			}
			set
			{
				offset = value;
			}
		}

		internal void Mark(ILGenerator ilgen)
		{
			ilgen.MarkLabel(label);
d109 1
a109 1
		private List<OpCodeWrapper> code = new List<OpCodeWrapper>();
d169 5
d184 10
d436 1
a436 1
					((CodeEmitterLabel)data).Mark(ilgen_real);
d562 14
d652 1
a652 1
					code[i].Label.Offset = offset;
d664 1
a664 1
					int diff = label.Offset - (prevOffset + code[i].opcode.Size + 1);
d1024 254
a1279 2
			RemoveJumpNext();
			AnnihilatePops();
d1281 13
d1296 2
d1311 16
@


1.65
log
@Made line number emitting just-in-time to avoid duplicate entries.
@
text
@d127 1
d130 1
d154 1
d156 1
d244 3
d250 1
d410 1
a410 1
			ilgen.__CleverExceptionBlockAssistance();
d460 1
d464 1
d1105 1
d1108 1
d1114 1
d1116 1
d1122 1
d1124 1
d1246 3
d1258 1
@


1.64
log
@Removed unused pseudo nop.
@
text
@d342 1
a342 1
			internal void RealEmit(int ilOffset, CodeEmitter codeEmitter)
d346 9
d357 4
a436 7
				case CodeType.LineNumber:
					if (linenums == null)
					{
						linenums = new IKVM.Attributes.LineNumberTableAttribute.LineNumberWriter(32);
					}
					linenums.AddMapping(ilOffset, (int)data);
					break;
d1018 1
d1021 1
a1021 1
				code[i].RealEmit(ilOffset, this);
@


1.63
log
@Implemented ThrowException here, instead of forwarding it to ILGenerator.
@
text
@a139 1
			Nop,
a225 1
						case CodeType.Nop:
a407 2
				case CodeType.Nop:
					break;
@


1.62
log
@EmitWriteLine isn't used anymore.
@
text
@a147 1
			ThrowException,
a237 2
						case CodeType.ThrowException:
							return 6;
a437 3
				case CodeType.ThrowException:
					ilgen_real.ThrowException((Type)data);
					break;
d1253 2
a1254 1
			EmitPseudoOpCode(CodeType.ThrowException, excType);
@


1.61
log
@Made OpCodeWrapper data member private and added type safe accessors.
@
text
@a147 1
			WriteLine,
a238 2
						case CodeType.WriteLine:
							return 10;
a440 3
				case CodeType.WriteLine:
					ilgen_real.EmitWriteLine((string)data);
					break;
a1220 5
		internal void EmitWriteLine(string value)
		{
			EmitPseudoOpCode(CodeType.WriteLine, value);
		}

@


1.60
log
@- Removed unnecessary methods from CodeEmitter.
- Removed "Lazy" prefixes in CodeEmitter.
@
text
@d162 1
a162 1
			internal readonly object data;
d178 5
d188 5
d198 5
d218 5
d349 12
a562 1
					&& code[i - 1].pseudo == CodeType.OpCode
d564 1
a564 1
					&& code[i - 1].data == code[i].data)
d601 1
a601 1
				FieldInfo field = code[index].data as FieldInfo;
d648 1
a648 1
					((CodeEmitterLabel)code[i].data).Offset = offset;
d657 1
a657 2
				CodeEmitterLabel label = code[i].data as CodeEmitterLabel;
				if (label != null && code[i].opcode.OperandType == OperandType.InlineBrTarget)
d659 1
d720 1
a720 1
						code[i] = new OpCodeWrapper(opcode, code[i].data);
d738 1
a738 1
					&& code[i + 1].opcode == OpCodes.Ldc_I4 && (int)code[i + 1].data == 255
d746 1
a746 1
					&& code[i + 2].opcode == OpCodes.Ldc_I8 && (long)code[i + 2].data == 255
d756 1
a756 1
					code[i] = new OpCodeWrapper(OpCodes.Ldc_I4, (int)code[i].data & (int)code[i + 1].data);
d851 4
a854 4
			return code[index].opcode == OpCodes.Stloc && ((CodeEmitterLocal)code[index].data).LocalType == type
				&& code[index + 1].opcode == OpCodes.Stloc && ((CodeEmitterLocal)code[index + 1].data).LocalType == type
				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].data == code[index + 1].data
				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].data == code[index].data
d856 2
a857 2
				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].data == code[index + 1].data
				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].data == code[index].data
d862 1
a862 1
				&& (code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch ||
d864 1
a864 1
					&& code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch));
d871 1
a871 1
				code[index] = new OpCodeWrapper(OpCodes.Bne_Un, code[index + 11].data);
d876 1
a876 1
				code[index] = new OpCodeWrapper(OpCodes.Beq, code[index + 11].data);
d883 1
a883 1
					code[index] = new OpCodeWrapper(ble, code[index + 12].data);
d888 1
a888 1
					code[index] = new OpCodeWrapper(blt, code[index + 12].data);
d893 1
a893 1
					code[index] = new OpCodeWrapper(bge, code[index + 12].data);
d898 1
a898 1
					code[index] = new OpCodeWrapper(bgt, code[index + 12].data);
d910 1
a910 1
					code[i] = OptimizeLdcI4((int)code[i].data);
d957 1
a957 1
			long value = (long)code[index].data;
d1030 1
a1030 8
				if (code[i].pseudo == CodeType.OpCode)
				{
					RealEmitOpCode(code[i].opcode, code[i].data);
				}
				else
				{
					RealEmitPseudoOpCode(ilOffset, code[i].pseudo, code[i].data);
				}
@


1.59
log
@- Moved boxing/unboxing optimizationn to new model.
- Removed stack tracking / LazyGen remnants.
- Fixed comparison optimization to require the release of temporary local variables.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004, 2005, 2006, 2008, 2009 Jeroen Frijters
d1340 1
a1340 26
		internal void LazyEmitPop()
		{
			Emit(OpCodes.Pop);
		}

		internal void LazyEmitLoadClass(TypeWrapper type)
		{
			type.EmitClassLiteral(this);
		}

		internal void LazyEmitBox(Type type)
		{
			Emit(OpCodes.Box, type);
		}

		internal void LazyEmitUnbox(Type type)
		{
			Emit(OpCodes.Unbox, type);
		}

		internal void LazyEmitLdobj(Type type)
		{
			Emit(OpCodes.Ldobj, type);
		}

		internal void LazyEmitUnboxSpecial(Type type)
d1360 3
a1362 6
		internal void LazyEmitLdnull()
		{
			Emit(OpCodes.Ldnull);
		}

		internal void LazyEmitLdc_I4(int i)
d1367 1
a1367 11
		internal void LazyEmitLdc_I8(long l)
		{
			Emit(OpCodes.Ldc_I8, l);
		}

		internal void LazyEmitLdstr(string str)
		{
			Emit(OpCodes.Ldstr, str);
		}

		internal void LazyEmit_idiv()
d1385 1
a1385 1
		internal void LazyEmit_ldiv()
d1404 1
a1404 1
		internal void LazyEmit_instanceof(Type type)
a1410 10
		internal void LazyEmit_ifeq(CodeEmitterLabel label)
		{
			Emit(OpCodes.Brfalse, label);
		}

		internal void LazyEmit_ifne(CodeEmitterLabel label)
		{
			Emit(OpCodes.Brtrue, label);
		}

d1419 1
a1419 1
		internal void LazyEmit_if_le_lt_ge_gt(Comparison comp, CodeEmitterLabel label)
d1458 1
a1458 1
		internal void LazyEmit_lcmp()
d1463 1
a1463 1
		internal void LazyEmit_fcmpl()
d1468 1
a1468 1
		internal void LazyEmit_fcmpg()
d1473 1
a1473 1
		internal void LazyEmit_dcmpl()
d1478 1
a1478 1
		internal void LazyEmit_dcmpg()
d1483 1
a1483 17
		internal void LazyEmitAnd_I4(int v2)
		{
			Emit(OpCodes.Ldc_I4, v2);
			Emit(OpCodes.And);
		}

		internal void LazyEmit_baload()
		{
			Emit(OpCodes.Ldelem_I1);
		}

		internal void LazyEmit_iand()
		{
			Emit(OpCodes.And);
		}

		internal void LazyEmit_land()
d1485 1
a1488 5
		internal void LazyEmit_i2l()
		{
			Emit(OpCodes.Conv_I8);
		}

@


1.58
log
@Moved ldiv/idiv optimization to new model.
@
text
@a129 2
		private Expr[] stackArray = new Expr[8];
		private int topOfStack;
d144 1
d160 1
a160 1
			internal readonly CodeType type;
d164 1
a164 1
			internal OpCodeWrapper(CodeType type, object data)
d166 1
a166 1
				this.type = type;
d173 1
a173 1
				this.type = CodeType.OpCode;
d183 5
d198 5
d207 1
a207 1
					switch (type)
d213 1
d395 2
a525 36
		private void PushStack(Expr expr)
		{
			Debug.Assert(expr != null);
			if (topOfStack == stackArray.Length)
			{
				Array.Resize(ref stackArray, stackArray.Length * 2);
			}
			stackArray[topOfStack++] = expr;
		}

		private void PushStackMayBeNull(Expr expr)
		{
			if (expr != null)
			{
				PushStack(expr);
			}
		}

		private Expr PopStack()
		{
			if (topOfStack == 0)
			{
				return null;
			}
			return stackArray[--topOfStack];
		}

		private Expr PeekStack()
		{
			if (topOfStack == 0)
			{
				return null;
			}
			return stackArray[topOfStack - 1];
		}

d530 2
a531 2
				if (code[i].type == CodeType.Label
					&& code[i - 1].type == CodeType.OpCode
d615 1
a615 1
				if (code[i].type == CodeType.Label)
d750 1
a750 1
					&& code[i + 7].type == CodeType.Label && code[i + 7].Label == code[i + 3].Label
d752 1
a752 1
					&& code[i + 9].type == CodeType.Label && code[i + 9].Label == code[i + 6].Label)
d775 1
a775 1
					&& code[i + 8].type == CodeType.Label && code[i + 8].Label == code[i + 4].Label
d777 1
a777 1
					&& code[i + 10].type == CodeType.Label && code[i + 10].Label == code[i + 7].Label)
d791 24
d829 5
a833 3
				&& (code[index + 9].opcode.FlowControl == FlowControl.Cond_Branch ||
					(code[index + 9].opcode == OpCodes.Ldc_I4_0
					&& code[index + 10].opcode.FlowControl == FlowControl.Cond_Branch));
d838 1
a838 1
			if (code[index + 9].opcode == OpCodes.Brtrue)
d840 2
a841 2
				code[index] = new OpCodeWrapper(OpCodes.Bne_Un, code[index + 9].data);
				code.RemoveRange(index + 1, 9);
d843 1
a843 1
			else if (code[index + 9].opcode == OpCodes.Brfalse)
d845 2
a846 2
				code[index] = new OpCodeWrapper(OpCodes.Beq, code[index + 9].data);
				code.RemoveRange(index + 1, 9);
d848 1
a848 1
			else if (code[index + 9].opcode == OpCodes.Ldc_I4_0)
d850 1
a850 1
				if (code[index + 10].opcode == OpCodes.Ble)
d852 2
a853 2
					code[index] = new OpCodeWrapper(ble, code[index + 10].data);
					code.RemoveRange(index + 1, 10);
d855 1
a855 1
				else if (code[index + 10].opcode == OpCodes.Blt)
d857 2
a858 2
					code[index] = new OpCodeWrapper(blt, code[index + 10].data);
					code.RemoveRange(index + 1, 10);
d860 1
a860 1
				else if (code[index + 10].opcode == OpCodes.Bge)
d862 2
a863 2
					code[index] = new OpCodeWrapper(bge, code[index + 10].data);
					code.RemoveRange(index + 1, 10);
d865 1
a865 1
				else if (code[index + 10].opcode == OpCodes.Bgt)
d867 2
a868 2
					code[index] = new OpCodeWrapper(bgt, code[index + 10].data);
					code.RemoveRange(index + 1, 10);
d999 1
a999 1
				if (code[i].type == CodeType.OpCode)
d1005 1
a1005 1
					RealEmitPseudoOpCode(ilOffset, code[i].type, code[i].data);
d1062 1
a1074 1
			LazyGen();
a1079 1
			LazyGen();
a1086 1
			LazyGen();
a1092 1
			LazyGen();
a1098 1
			LazyGen();
a1119 1
			LazyGen();
a1124 1
			LazyGen();
a1129 1
			LazyGen();
a1134 1
			LazyGen();
a1139 1
			LazyGen();
a1144 1
			LazyGen();
a1149 1
			LazyGen();
a1154 1
			LazyGen();
a1159 1
			LazyGen();
a1164 1
			LazyGen();
a1169 1
			LazyGen();
a1174 1
			LazyGen();
a1179 1
			LazyGen();
a1184 1
			LazyGen();
a1189 1
			LazyGen();
a1194 1
			LazyGen();
a1199 1
			LazyGen();
a1204 1
			LazyGen();
a1219 1
			LazyGen();
a1232 1
			LazyGen();
a1237 1
			LazyGen();
a1245 1
			LazyGen();
a1252 1
				LazyGen();
d1255 1
a1255 6
			// we only add a line number mapping if the stack is empty because the CLR JIT only generates native to IL mappings
			// for locations where the stack is empty and we don't want to needlessly flush the stack
			if (topOfStack == 0)
			{
				EmitPseudoOpCode(CodeType.LineNumber, (int)line);
			}
d1352 1
a1352 1
			PushStack(new BoxExpr(PopStack(), type));
d1357 1
a1357 10
			BoxExpr box = PeekStack() as BoxExpr;
			if(box != null)
			{
				PopStack();
				PushStack(new BoxUnboxExpr(box.Expr, type));
			}
			else
			{
				PushStack(new UnboxExpr(PopStack(), type));
			}
d1362 1
a1362 11
			BoxUnboxExpr boxunbox = PeekStack() as BoxUnboxExpr;
			if(boxunbox != null)
			{
				PopStack();
				// box/unbox+ldobj annihilate each other
				PushStackMayBeNull(boxunbox.Expr);
			}
			else
			{
				PushStack(new LdobjExpr(PopStack(), type));
			}
d1367 16
a1382 22
			BoxExpr box = PeekStack() as BoxExpr;
			if(box != null)
			{
				PopStack();
				// the unbox and lazy box cancel each other out
				PushStackMayBeNull(box.Expr);
			}
			else
			{
				// NOTE if the reference is null, we treat it as a default instance of the value type.
				Emit(OpCodes.Dup);
				CodeEmitterLabel label1 = DefineLabel();
				Emit(OpCodes.Brtrue_S, label1);
				Emit(OpCodes.Pop);
				Emit(OpCodes.Ldloc, DeclareLocal(type));
				CodeEmitterLabel label2 = DefineLabel();
				Emit(OpCodes.Br_S, label2);
				MarkLabel(label1);
				Emit(OpCodes.Unbox, type);
				Emit(OpCodes.Ldobj, type);
				MarkLabel(label2);
			}
a1556 10
		private void LazyGen()
		{
			int len = topOfStack;
			topOfStack = 0;
			for(int i = 0; i < len; i++)
			{
				stackArray[i].Emit(this);
			}
		}

a1566 109

		abstract class Expr
		{
			internal virtual bool HasSideEffect { get { return false; } }

			internal virtual bool IsIncomplete { get { return false; } }

			internal abstract void Emit(CodeEmitter ilgen);
		}

		abstract class UnaryExpr : Expr
		{
			internal readonly Expr Expr;

			protected UnaryExpr(Expr expr)
			{
				this.Expr = expr;
			}

			internal sealed override bool IsIncomplete
			{
				get { return Expr == null; }
			}

			internal override bool HasSideEffect
			{
				get { return Expr != null && Expr.HasSideEffect; }
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				if (Expr != null)
				{
					Expr.Emit(ilgen);
				}
			}
		}

		abstract class ExprWithExprAndType : UnaryExpr
		{
			internal readonly Type Type;

			protected ExprWithExprAndType(Expr expr, Type type)
				: base(expr)
			{
				this.Type = type;
			}
		}

		sealed class BoxExpr : ExprWithExprAndType
		{
			internal BoxExpr(Expr expr, Type type)
				: base(expr, type)
			{
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				base.Emit(ilgen);
				ilgen.Emit(OpCodes.Box, Type);
			}
		}

		sealed class UnboxExpr : ExprWithExprAndType
		{
			internal UnboxExpr(Expr expr, Type type)
				: base(expr, type)
			{
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				base.Emit(ilgen);
				ilgen.Emit(OpCodes.Unbox, Type);
			}
		}

		sealed class BoxUnboxExpr : ExprWithExprAndType
		{
			internal BoxUnboxExpr(Expr expr, Type type)
				: base(expr, type)
			{
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				base.Emit(ilgen);
				// unbox leaves a pointer to the value of the stack (instead of the value)
				// so we have to copy the value into a local variable and load the address
				// of the local onto the stack
				CodeEmitterLocal local = ilgen.DeclareLocal(Type);
				ilgen.Emit(OpCodes.Stloc, local);
				ilgen.Emit(OpCodes.Ldloca, local);
			}
		}

		sealed class LdobjExpr : ExprWithExprAndType
		{
			internal LdobjExpr(Expr expr, Type type)
				: base(expr, type)
			{
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				base.Emit(ilgen);
				ilgen.Emit(OpCodes.Ldobj, Type);
			}
		}
@


1.57
log
@Moved long/float/double comparison optimization to new model.
@
text
@d179 15
d766 49
d1447 1
a1447 1
			PushStack(new ConstIntExpr(i));
d1452 1
a1452 1
			PushStack(new ConstLongExpr(l));
d1465 11
a1475 27
			ConstIntExpr v = PeekStack() as ConstIntExpr;
			if(v != null)
			{
				if(v.i == -1)
				{
					PopStack();
					Emit(OpCodes.Neg);
				}
				else
				{
					Emit(OpCodes.Div);
				}
			}
			else
			{
				Emit(OpCodes.Dup);
				Emit(OpCodes.Ldc_I4_M1);
				CodeEmitterLabel label = DefineLabel();
				Emit(OpCodes.Bne_Un_S, label);
				Emit(OpCodes.Pop);
				Emit(OpCodes.Neg);
				CodeEmitterLabel label2 = DefineLabel();
				Emit(OpCodes.Br_S, label2);
				MarkLabel(label);
				Emit(OpCodes.Div);
				MarkLabel(label2);
			}
d1483 12
a1494 28
			ConstLongExpr v = PeekStack() as ConstLongExpr;
			if(v != null)
			{
				if(v.l == -1)
				{
					PopStack();
					Emit(OpCodes.Neg);
				}
				else
				{
					Emit(OpCodes.Div);
				}
			}
			else
			{
				Emit(OpCodes.Dup);
				Emit(OpCodes.Ldc_I4_M1);
				Emit(OpCodes.Conv_I8);
				CodeEmitterLabel label = DefineLabel();
				Emit(OpCodes.Bne_Un_S, label);
				Emit(OpCodes.Pop);
				Emit(OpCodes.Neg);
				CodeEmitterLabel label2 = DefineLabel();
				Emit(OpCodes.Br_S, label2);
				MarkLabel(label);
				Emit(OpCodes.Div);
				MarkLabel(label2);
			}
a1740 30

		sealed class ConstIntExpr : Expr
		{
			internal readonly int i;

			internal ConstIntExpr(int i)
			{
				this.i = i;
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Ldc_I4, i);
			}
		}

		sealed class ConstLongExpr : Expr
		{
			internal readonly long l;

			internal ConstLongExpr(long l)
			{
				this.l = l;
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Ldc_I8, l);
			}
		}
@


1.56
log
@- Moved ldc_i4 and ldc_i8 encoding optimizations to the end of the pipeline.
- Added more side effect free load operations.
@
text
@d104 5
d737 67
d991 1
a991 1
			return DeclareLocal(type);
d1474 1
a1474 1
			LazyEmit_if_ne_eq(label, false);
d1479 1
a1479 13
			LazyEmit_if_ne_eq(label, true);
		}

		private void LazyEmit_if_ne_eq(CodeEmitterLabel label, bool brtrue)
		{
			CmpExpr cmp = PeekStack() as CmpExpr;
			if (cmp != null)
			{
				PopStack();
				Emit(brtrue ? OpCodes.Bne_Un : OpCodes.Beq, label);
				return;
			}
			Emit(brtrue ? OpCodes.Brtrue : OpCodes.Brfalse, label);
d1490 1
a1490 1
		private void EmitBcc(Comparison comp, CodeEmitterLabel label)
d1492 3
d1512 1
a1512 1
		internal void LazyEmit_if_le_lt_ge_gt(Comparison comp, CodeEmitterLabel label)
d1514 13
a1526 11
			CmpExpr cmp = PeekStack() as CmpExpr;
			if (cmp != null)
			{
				PopStack();
				cmp.EmitBcc(this, comp, label);
			}
			else
			{
				Emit(OpCodes.Ldc_I4_0);
				EmitBcc(comp, label);
			}
d1531 1
a1531 1
			PushStack(new LCmpExpr());
d1536 1
a1536 1
			PushStack(new FCmplExpr());
d1541 1
a1541 1
			PushStack(new FCmpgExpr());
d1546 1
a1546 1
			PushStack(new DCmplExpr());
d1551 1
a1551 1
			PushStack(new DCmpgExpr());
a1738 150

		abstract class CmpExpr : Expr
		{
			internal CmpExpr()
			{
			}

			internal override bool IsIncomplete
			{
				get
				{
					return true;
				}
			}

			internal abstract void EmitBcc(CodeEmitter ilgen, Comparison comp, CodeEmitterLabel label);
		}

		sealed class LCmpExpr : CmpExpr
		{
			internal LCmpExpr()
			{
			}

			internal sealed override void Emit(CodeEmitter ilgen)
			{
				CodeEmitterLocal value1 = ilgen.AllocTempLocal(Types.Int64);
				CodeEmitterLocal value2 = ilgen.AllocTempLocal(Types.Int64);
				ilgen.Emit(OpCodes.Stloc, value2);
				ilgen.Emit(OpCodes.Stloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Cgt);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Clt);
				ilgen.Emit(OpCodes.Sub);
				ilgen.ReleaseTempLocal(value2);
				ilgen.ReleaseTempLocal(value1);
			}

			internal sealed override void EmitBcc(CodeEmitter ilgen, Comparison comp, CodeEmitterLabel label)
			{
				ilgen.EmitBcc(comp, label);
			}
		}

		class FCmplExpr : CmpExpr
		{
			protected virtual Type FloatOrDouble()
			{
				return Types.Single;
			}

			internal sealed override void Emit(CodeEmitter ilgen)
			{
				CodeEmitterLocal value1 = ilgen.AllocTempLocal(FloatOrDouble());
				CodeEmitterLocal value2 = ilgen.AllocTempLocal(FloatOrDouble());
				ilgen.Emit(OpCodes.Stloc, value2);
				ilgen.Emit(OpCodes.Stloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Cgt);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Clt_Un);
				ilgen.Emit(OpCodes.Sub);
				ilgen.ReleaseTempLocal(value1);
				ilgen.ReleaseTempLocal(value2);
			}

			internal sealed override void EmitBcc(CodeEmitter ilgen, Comparison comp, CodeEmitterLabel label)
			{
				switch (comp)
				{
					case Comparison.LessOrEqual:
						ilgen.Emit(OpCodes.Ble_Un, label);
						break;
					case Comparison.LessThan:
						ilgen.Emit(OpCodes.Blt_Un, label);
						break;
					case Comparison.GreaterOrEqual:
						ilgen.Emit(OpCodes.Bge, label);
						break;
					case Comparison.GreaterThan:
						ilgen.Emit(OpCodes.Bgt, label);
						break;
				}
			}
		}

		class FCmpgExpr : CmpExpr
		{
			protected virtual Type FloatOrDouble()
			{
				return Types.Single;
			}

			internal sealed override void Emit(CodeEmitter ilgen)
			{
				CodeEmitterLocal value1 = ilgen.AllocTempLocal(FloatOrDouble());
				CodeEmitterLocal value2 = ilgen.AllocTempLocal(FloatOrDouble());
				ilgen.Emit(OpCodes.Stloc, value2);
				ilgen.Emit(OpCodes.Stloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Cgt_Un);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Clt);
				ilgen.Emit(OpCodes.Sub);
				ilgen.ReleaseTempLocal(value1);
				ilgen.ReleaseTempLocal(value2);
			}

			internal sealed override void EmitBcc(CodeEmitter ilgen, Comparison comp, CodeEmitterLabel label)
			{
				switch (comp)
				{
					case Comparison.LessOrEqual:
						ilgen.Emit(OpCodes.Ble, label);
						break;
					case Comparison.LessThan:
						ilgen.Emit(OpCodes.Blt, label);
						break;
					case Comparison.GreaterOrEqual:
						ilgen.Emit(OpCodes.Bge_Un, label);
						break;
					case Comparison.GreaterThan:
						ilgen.Emit(OpCodes.Bgt_Un, label);
						break;
				}
			}
		}

		sealed class DCmplExpr : FCmplExpr
		{
			protected override Type FloatOrDouble()
			{
				return Types.Double;
			}
		}

		sealed class DCmpgExpr : FCmpgExpr
		{
			protected override Type FloatOrDouble()
			{
				return Types.Double;
			}
		}
@


1.55
log
@Moved over instanceof/byte array load to new optimization.
@
text
@d584 24
d719 2
a720 3
					&& code[i + 2].opcode == OpCodes.Ldc_I4 && (int)code[i + 2].data == 255
					&& code[i + 3].opcode == OpCodes.Conv_U8
					&& code[i + 4].opcode == OpCodes.And)
d723 1
a723 1
					code.RemoveRange(i + 2, 3);
d725 123
d856 1
d1491 2
a1492 11
			ConstIntExpr v1 = PeekStack() as ConstIntExpr;
			if (v1 != null)
			{
				PopStack();
				LazyEmitLdc_I4(v1.i & v2);
			}
			else
			{
				LazyEmitLdc_I4(v2);
				Emit(OpCodes.And);
			}
d1656 1
a1656 43
				switch(i)
				{
					case -1:
						ilgen.Emit(OpCodes.Ldc_I4_M1);
						break;
					case 0:
						ilgen.Emit(OpCodes.Ldc_I4_0);
						break;
					case 1:
						ilgen.Emit(OpCodes.Ldc_I4_1);
						break;
					case 2:
						ilgen.Emit(OpCodes.Ldc_I4_2);
						break;
					case 3:
						ilgen.Emit(OpCodes.Ldc_I4_3);
						break;
					case 4:
						ilgen.Emit(OpCodes.Ldc_I4_4);
						break;
					case 5:
						ilgen.Emit(OpCodes.Ldc_I4_5);
						break;
					case 6:
						ilgen.Emit(OpCodes.Ldc_I4_6);
						break;
					case 7:
						ilgen.Emit(OpCodes.Ldc_I4_7);
						break;
					case 8:
						ilgen.Emit(OpCodes.Ldc_I4_8);
						break;
					default:
						if(i >= -128 && i <= 127)
						{
							ilgen.Emit(OpCodes.Ldc_I4_S, (sbyte)i);
						}
						else
						{
							ilgen.Emit(OpCodes.Ldc_I4, i);
						}
						break;
				}
d1671 1
a1671 68
				switch (l)
				{
					case -1:
						ilgen.Emit(OpCodes.Ldc_I4_M1);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					case 0:
						ilgen.Emit(OpCodes.Ldc_I4_0);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					case 1:
						ilgen.Emit(OpCodes.Ldc_I4_1);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					case 2:
						ilgen.Emit(OpCodes.Ldc_I4_2);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					case 3:
						ilgen.Emit(OpCodes.Ldc_I4_3);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					case 4:
						ilgen.Emit(OpCodes.Ldc_I4_4);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					case 5:
						ilgen.Emit(OpCodes.Ldc_I4_5);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					case 6:
						ilgen.Emit(OpCodes.Ldc_I4_6);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					case 7:
						ilgen.Emit(OpCodes.Ldc_I4_7);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					case 8:
						ilgen.Emit(OpCodes.Ldc_I4_8);
						ilgen.Emit(OpCodes.Conv_I8);
						break;
					default:
						if (l >= -2147483648L && l <= 4294967295L)
						{
							if (l >= -128 && l <= 127)
							{
								ilgen.Emit(OpCodes.Ldc_I4_S, (sbyte)l);
							}
							else
							{
								ilgen.Emit(OpCodes.Ldc_I4, (int)l);
							}
							if (l < 0)
							{
								ilgen.Emit(OpCodes.Conv_I8);
							}
							else
							{
								ilgen.Emit(OpCodes.Conv_U8);
							}
						}
						else
						{
							ilgen.Emit(OpCodes.Ldc_I8, l);
						}
						break;
				}
@


1.54
log
@Remove PopLazyLdstr and PeekLazyClassLiteral.
@
text
@d675 30
d709 1
d1248 3
a1250 1
			PushStack(new InstanceOfExpr(type));
d1265 2
a1266 2
			InstanceOfExpr instanceof = PeekStack() as InstanceOfExpr;
			if (instanceof != null)
d1269 2
a1270 11
				Emit(OpCodes.Isinst, instanceof.Type);
			}
			else
			{
				CmpExpr cmp = PeekStack() as CmpExpr;
				if (cmp != null)
				{
					PopStack();
					Emit(brtrue ? OpCodes.Bne_Un : OpCodes.Beq, label);
					return;
				}
d1359 1
a1359 16
			PushStack(new ByteArrayLoadExpr());
		}

		private bool Match<T1, T2>(out T1 t1, out T2 t2)
			where T1 : Expr
			where T2 : Expr
		{
			if (topOfStack < 2)
			{
				t1 = null;
				t2 = null;
				return false;
			}
			t1 = stackArray[topOfStack - 1] as T1;
			t2 = stackArray[topOfStack - 2] as T2;
			return t1 != null && t2 != null;
d1364 1
a1364 12
			ConstIntExpr v1;
			ByteArrayLoadExpr v2;
			if (Match(out v1, out v2) && v1.i == 0xFF)
			{
				PopStack();
				PopStack();
				Emit(OpCodes.Ldelem_U1);
			}
			else
			{
				Emit(OpCodes.And);
			}
d1369 1
a1369 13
			ConstLongExpr v1;
			ConvertLong v2;
			if (Match(out v1, out v2) && v1.l == 0xFF && v2.Expr is ByteArrayLoadExpr)
			{
				PopStack();
				PopStack();
				Emit(OpCodes.Ldelem_U1);
				Emit(OpCodes.Conv_I8);
			}
			else
			{
				Emit(OpCodes.And);
			}
d1374 1
a1374 1
			PushStack(new ConvertLong(PopStack()));
a1645 25
		sealed class InstanceOfExpr : Expr
		{
			internal readonly Type Type;

			internal InstanceOfExpr(Type type)
			{
				this.Type = type;
			}

			internal override bool IsIncomplete
			{
				get
				{
					return true;
				}
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Isinst, this.Type);
				ilgen.Emit(OpCodes.Ldnull);
				ilgen.Emit(OpCodes.Cgt_Un);
			}
		}

a1794 32

		sealed class ByteArrayLoadExpr : Expr
		{
			internal override void Emit(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Ldelem_I1);
			}

			internal override bool HasSideEffect
			{
				get { return true; }
			}

			internal override bool IsIncomplete
			{
				get { return true; }
			}
		}

		sealed class ConvertLong : UnaryExpr
		{
			internal ConvertLong(Expr expr)
				: base(expr)
			{
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				base.Emit(ilgen);
				ilgen.Emit(OpCodes.Conv_I8);
			}
		}
@


1.53
log
@Annihilate some common push/pop combinations.
@
text
@d1063 1
a1063 1
			PushStack(new ClassLiteralExpr(type));
d1128 1
a1128 1
			PushStack(new NullExpr());
d1143 1
a1143 1
			PushStack(new ConstStringExpr(str));
a1390 21
		internal string PopLazyLdstr()
		{
			ConstStringExpr str = PeekStack() as ConstStringExpr;
			if(str != null)
			{
				PopStack();
				return str.str;
			}
			return null;
		}

		internal TypeWrapper PeekLazyClassLiteral()
		{
			ClassLiteralExpr lit = PeekStack() as ClassLiteralExpr;
			if (lit != null)
			{
				return lit.Type;
			}
			return null;
		}

a1520 8
		sealed class NullExpr : Expr
		{
			internal override void Emit(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Ldnull);
			}
		}

a1659 15
		sealed class ConstStringExpr : Expr
		{
			internal readonly string str;

			internal ConstStringExpr(string str)
			{
				this.str = str;
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				ilgen.Emit(OpCodes.Ldstr, str);
			}
		}

a1834 15
		sealed class ClassLiteralExpr : Expr
		{
			internal readonly TypeWrapper Type;

			internal ClassLiteralExpr(TypeWrapper type)
			{
				this.Type = type;
			}

			internal override void Emit(CodeEmitter ilgen)
			{
				Type.EmitClassLiteral(ilgen);
			}
		}

@


1.52
log
@Implemented branch optimization.
@
text
@d160 1
a160 1
			internal OpCodeWrapper(CodeType type, OpCode opcode, object data)
d163 7
d342 1
a342 1
			code.Add(new OpCodeWrapper(type, OpCodes.Nop, data));
d347 1
a347 1
			code.Add(new OpCodeWrapper(CodeType.OpCode, opcode, arg));
d409 1
a409 1
		private void RealEmitOpCode(int ilOffset, OpCode opcode, object arg)
d539 15
a553 1
					code[i - 1] = new OpCodeWrapper(CodeType.Nop, OpCodes.Nop, null);
d558 32
d669 1
a669 1
						code[i] = new OpCodeWrapper(code[i].type, opcode, code[i].data);
d678 1
d685 1
a685 1
					RealEmitOpCode(ilOffset, code[i].opcode, code[i].data);
d1058 1
a1058 9
			Expr exp = PeekStack();
			if (exp == null || exp.HasSideEffect || exp.IsIncomplete)
			{
				Emit(OpCodes.Pop);
			}
			else
			{
				PopStack();
			}
@


1.51
log
@Build intermediate store of MSIL code in CodeEmitter to allow post-processing optimization steps.
@
text
@d64 4
d70 1
a70 1
		internal void Mark(ILGenerator ilgen, int offset)
a72 1
			this.offset = offset;
a96 1
#if !STATIC_COMPILER
d99 1
a99 1
			get { return local.LocalIndex; }
a100 1
#endif
a121 2
#if !STATIC_COMPILER
		private int offset;
a123 1
#endif
a150 1
#if !STATIC_COMPILER
a151 1
#endif
d166 126
d343 1
a343 1
		private void RealEmitPseudoOpCode(CodeType type, object data)
d368 1
a368 1
					linenums.AddMapping(GetILOffset(), (int)data);
d371 1
a371 1
					((CodeEmitterLabel)data).Mark(ilgen_real, GetILOffset());
a373 3
#if !STATIC_COMPILER
					offset += 10;
#endif
a376 3
#if !STATIC_COMPILER
					offset += 6;
#endif
a382 3
#if !STATIC_COMPILER
					offset += 5;
#endif
a385 3
#if !STATIC_COMPILER
					offset += 5;
#endif
a388 3
#if !STATIC_COMPILER
					offset += 5;
#endif
a390 1
#if !STATIC_COMPILER
a391 1
					offset += 1;
a393 1
#endif
a394 3
#if !STATIC_COMPILER
					offset += 5;
#endif
d402 1
a402 1
		private void RealEmitOpCode(OpCode opcode, object arg)
a405 3
#if !STATIC_COMPILER
				offset += opcode.Size;
#endif
a409 3
#if !STATIC_COMPILER
				offset += opcode.Size + 4;
#endif
a413 3
#if !STATIC_COMPILER
				offset += opcode.Size + 8;
#endif
a417 3
#if !STATIC_COMPILER
				offset += opcode.Size + 4;
#endif
a421 3
#if !STATIC_COMPILER
				offset += opcode.Size + 4;
#endif
a425 3
#if !STATIC_COMPILER
				offset += opcode.Size + 4;
#endif
a429 3
#if !STATIC_COMPILER
				offset += opcode.Size + 1;
#endif
a433 3
#if !STATIC_COMPILER
				offset += opcode.Size + 1;
#endif
a437 3
#if !STATIC_COMPILER
				offset += opcode.Size + 2;
#endif
a441 3
#if !STATIC_COMPILER
				offset += opcode.Size + 4;
#endif
a445 3
#if !STATIC_COMPILER
				offset += opcode.Size + 8;
#endif
a449 3
#if !STATIC_COMPILER
				offset += opcode.Size + 4;
#endif
a453 3
#if !STATIC_COMPILER
				offset += opcode.Size + 4;
#endif
a458 15
#if !STATIC_COMPILER
				int index = local.__LocalIndex;
				if(index < 4 && opcode.Value != OpCodes.Ldloca.Value && opcode.Value != OpCodes.Ldloca_S.Value)
				{
					offset += 1;
				}
				else if(index < 256)
				{
					offset += 2;
				}
				else
				{
					offset += 4;
				}
#endif
a463 56
				int currOffset = GetILOffset();
				if (label.Offset == -1)
				{
				}
				else if (currOffset - label.Offset < 126)
				{
					if (opcode.Value == OpCodes.Brtrue.Value)
					{
						opcode = OpCodes.Brtrue_S;
					}
					else if (opcode.Value == OpCodes.Brfalse.Value)
					{
						opcode = OpCodes.Brfalse_S;
					}
					else if (opcode.Value == OpCodes.Br.Value)
					{
						opcode = OpCodes.Br_S;
					}
					else if (opcode.Value == OpCodes.Beq.Value)
					{
						opcode = OpCodes.Beq_S;
					}
					else if (opcode.Value == OpCodes.Bne_Un.Value)
					{
						opcode = OpCodes.Bne_Un_S;
					}
					else if (opcode.Value == OpCodes.Ble.Value)
					{
						opcode = OpCodes.Ble_S;
					}
					else if (opcode.Value == OpCodes.Blt.Value)
					{
						opcode = OpCodes.Blt_S;
					}
					else if (opcode.Value == OpCodes.Bge.Value)
					{
						opcode = OpCodes.Bge_S;
					}
					else if (opcode.Value == OpCodes.Bgt.Value)
					{
						opcode = OpCodes.Bgt_S;
					}
				}
#if !STATIC_COMPILER
				switch(opcode.OperandType)
				{
					case OperandType.InlineBrTarget:
						offset += opcode.Size + 4;
						break;
					case OperandType.ShortInlineBrTarget:
						offset += opcode.Size + 1;
						break;
					default:
						throw new NotImplementedException();
				}
#endif
a468 3
#if !STATIC_COMPILER
				offset += 5 + labels.Length * 4;
#endif
a479 3
#if !STATIC_COMPILER
				offset += 5;
#endif
d537 85
d625 2
d631 1
a631 1
					RealEmitOpCode(code[i].opcode, code[i].data);
d635 1
a635 1
					RealEmitPseudoOpCode(code[i].type, code[i].data);
d637 5
a701 10
		private int GetILOffset()
		{
			LazyGen();
#if STATIC_COMPILER
			return ilgen_real.ILOffset;
#else
			return offset;
#endif
		}

a710 1
#if !STATIC_COMPILER
a712 1
#endif
a718 1
#if !STATIC_COMPILER
a719 1
#endif
a725 1
#if !STATIC_COMPILER
a726 1
#endif
a872 3
#if STATIC_COMPILER
			EmitPseudoOpCode(CodeType.EndExceptionBlock, null);
#else
a881 1
#endif
@


1.50
log
@Wrapped LocalBuilder in new CodeEmitterLocal class to allow CodeEmitter to encapsulate the ILGenerator fully.
@
text
@d40 1
a40 1
	class CodeEmitterLabel
d64 6
a69 4
			set
			{
				offset = value;
			}
d75 3
a77 1
		private readonly LocalBuilder local;
d79 1
a79 1
		internal CodeEmitterLocal(LocalBuilder local)
d81 1
a81 1
			this.local = local;
d86 1
a86 1
			get { return local.LocalType; }
d91 13
a103 1
			local.SetLocalSymInfo(name);
d106 1
a106 1
		internal LocalBuilder __LocalBuilder
d108 5
a112 1
			get { return local; }
d123 2
a125 2
		private Stack<bool> exceptionStack = new Stack<bool>();
		private bool inFinally;
a128 1
		private CodeEmitterLabel lazyBranch;
d131 1
d136 50
d211 291
d538 30
d638 1
a638 4
#if !STATIC_COMPILER
			offset += 5;
#endif
			ilgen_real.BeginCatchBlock(exceptionType);
d641 1
a641 1
		internal Label BeginExceptionBlock()
d644 1
d647 2
a648 1
			return ilgen_real.BeginExceptionBlock();
d654 1
a655 2
#if !STATIC_COMPILER
			offset += 5;
d657 1
a657 1
			ilgen_real.BeginFaultBlock();
d663 1
a664 2
#if !STATIC_COMPILER
			offset += 5;
d666 1
a666 1
			ilgen_real.BeginFinallyBlock();
d672 1
a672 1
			ilgen_real.BeginScope();
d677 3
a679 1
			return new CodeEmitterLocal(ilgen_real.DeclareLocal(localType));
d694 1
a694 4
#if !STATIC_COMPILER
			offset += opcode.Size;
#endif
			ilgen_real.Emit(opcode);
d700 1
a700 4
#if !STATIC_COMPILER
			offset += opcode.Size + 1;
#endif
			ilgen_real.Emit(opcode, arg);
d706 1
a706 4
#if !STATIC_COMPILER
			offset += opcode.Size + 4;
#endif
			ilgen_real.Emit(opcode, con);
d712 1
a712 4
#if !STATIC_COMPILER
			offset += opcode.Size + 8;
#endif
			ilgen_real.Emit(opcode, arg);
d718 1
a718 4
#if !STATIC_COMPILER
			offset += opcode.Size + 4;
#endif
			ilgen_real.Emit(opcode, field);
d724 1
a724 4
#if !STATIC_COMPILER
			offset += opcode.Size + 2;
#endif
			ilgen_real.Emit(opcode, arg);
d730 1
a730 4
#if !STATIC_COMPILER
			offset += opcode.Size + 4;
#endif
			ilgen_real.Emit(opcode, arg);
d736 1
a736 4
#if !STATIC_COMPILER
			offset += opcode.Size + 8;
#endif
			ilgen_real.Emit(opcode, arg);
d741 2
a742 62
			int currOffset = GetILOffset();
			if(label.Offset == -1)
			{
				if(opcode.Value == OpCodes.Br.Value)
				{
					lazyBranch = label;
					return;
				}
			}
			else if(currOffset - label.Offset < 126)
			{
				if(opcode.Value == OpCodes.Brtrue.Value)
				{
					opcode = OpCodes.Brtrue_S;
				}
				else if(opcode.Value == OpCodes.Brfalse.Value)
				{
					opcode = OpCodes.Brfalse_S;
				}
				else if(opcode.Value == OpCodes.Br.Value)
				{
					opcode = OpCodes.Br_S;
				}
				else if(opcode.Value == OpCodes.Beq.Value)
				{
					opcode = OpCodes.Beq_S;
				}
				else if(opcode.Value == OpCodes.Bne_Un.Value)
				{
					opcode = OpCodes.Bne_Un_S;
				}
				else if(opcode.Value == OpCodes.Ble.Value)
				{
					opcode = OpCodes.Ble_S;
				}
				else if(opcode.Value == OpCodes.Blt.Value)
				{
					opcode = OpCodes.Blt_S;
				}
				else if(opcode.Value == OpCodes.Bge.Value)
				{
					opcode = OpCodes.Bge_S;
				}
				else if(opcode.Value == OpCodes.Bgt.Value)
				{
					opcode = OpCodes.Bgt_S;
				}
			}
#if !STATIC_COMPILER
			switch(opcode.OperandType)
			{
				case OperandType.InlineBrTarget:
					offset += opcode.Size + 4;
					break;
				case OperandType.ShortInlineBrTarget:
					offset += opcode.Size + 1;
					break;
				default:
					throw new NotImplementedException();
			}
#endif
			ilgen_real.Emit(opcode, label.Label);
d748 1
a748 9
#if !STATIC_COMPILER
			offset += 5 + labels.Length * 4;
#endif
			Label[] real = new Label[labels.Length];
			for(int i = 0; i < labels.Length; i++)
			{
				real[i] = labels[i].Label;
			}
			ilgen_real.Emit(opcode, real);
d754 1
a754 16
#if !STATIC_COMPILER
			int index = local.__LocalBuilder.LocalIndex;
			if(index < 4 && opcode.Value != OpCodes.Ldloca.Value && opcode.Value != OpCodes.Ldloca_S.Value)
			{
				offset += 1;
			}
			else if(index < 256)
			{
				offset += 2;
			}
			else
			{
				offset += 4;
			}
#endif
			ilgen_real.Emit(opcode, local.__LocalBuilder);
d760 1
a760 4
#if !STATIC_COMPILER
			offset += opcode.Size + 4;
#endif
			ilgen_real.Emit(opcode, meth);
d766 1
a766 4
#if !STATIC_COMPILER
			offset += opcode.Size + 1;
#endif
			ilgen_real.Emit(opcode, arg);
d772 1
a772 4
#if !STATIC_COMPILER
			offset += opcode.Size + 4;
#endif
			ilgen_real.Emit(opcode, arg);
d778 1
a778 4
#if !STATIC_COMPILER
			offset += opcode.Size + 4;
#endif
			ilgen_real.Emit(opcode, arg);
d784 1
a784 4
#if !STATIC_COMPILER
			offset += opcode.Size + 4;
#endif
			ilgen_real.Emit(opcode, cls);
d790 1
a790 4
#if !STATIC_COMPILER
			offset += 5;
#endif
			ilgen_real.EmitCalli(opcode, unmanagedCallConv, returnType, parameterTypes);
d796 1
a796 4
#if !STATIC_COMPILER
			offset += 10;
#endif
			ilgen_real.EmitWriteLine(value);
d812 3
a814 1
#if !STATIC_COMPILER
d817 1
a817 1
				offset += 1;
d821 1
a821 1
				offset += 5;
d823 1
a824 2
			inFinally = exceptionStack.Pop();
			ilgen_real.EndExceptionBlock();
d830 1
a830 1
			ilgen_real.EndScope();
a834 4
			if(lazyBranch == loc)
			{
				lazyBranch = null;
			}
d839 1
a839 2
			ilgen_real.MarkLabel(loc.Label);
			loc.Offset = GetILOffset();
d845 1
a845 4
#if !STATIC_COMPILER
			offset += 6;
#endif
			ilgen_real.ThrowException(excType);
d853 1
a853 3
				ilgen_real.MarkSequencePoint(symbols, line, 0, line + 1, 0);
				// we emit a nop to make sure we always have an instruction associated with the sequence point
				Emit(OpCodes.Nop);
d859 1
a859 5
				if (linenums == null)
				{
					linenums = new IKVM.Attributes.LineNumberTableAttribute.LineNumberWriter(32);
				}
				linenums.AddMapping(GetILOffset(), line);
a1310 8
			if(lazyBranch != null)
			{
#if !STATIC_COMPILER
				offset += OpCodes.Br.Size + 4;
#endif
				ilgen_real.Emit(OpCodes.Br, lazyBranch.Label);
				lazyBranch = null;
			}
@


1.49
log
@Remove unused property.
@
text
@d71 25
d110 1
a110 1
		private LocalBuilder[] tempLocals = new LocalBuilder[32];
d182 1
a182 1
		internal LocalBuilder UnsafeAllocTempLocal(Type type)
d187 1
a187 1
				LocalBuilder lb = tempLocals[i];
d200 1
a200 1
			LocalBuilder lb1 = DeclareLocal(type);
d208 1
a208 1
		internal LocalBuilder AllocTempLocal(Type type)
d212 1
a212 1
				LocalBuilder lb = tempLocals[i];
d222 1
a222 1
		internal void ReleaseTempLocal(LocalBuilder lb)
d287 1
a287 1
		internal LocalBuilder DeclareLocal(Type localType)
d289 1
a289 1
			return ilgen_real.DeclareLocal(localType);
d453 1
a453 1
		internal void Emit(OpCode opcode, LocalBuilder local)
d457 1
a457 1
			int index = local.LocalIndex;
d471 1
a471 1
			ilgen_real.Emit(opcode, local);
d659 1
a659 1
				LocalBuilder lb = DeclareLocal(Types.Object);
d683 1
a683 1
			LocalBuilder lb = DeclareLocal(Types.Object);
d1178 1
a1178 1
				LocalBuilder local = ilgen.DeclareLocal(Type);
d1410 2
a1411 2
				LocalBuilder value1 = ilgen.AllocTempLocal(Types.Int64);
				LocalBuilder value2 = ilgen.AllocTempLocal(Types.Int64);
d1440 2
a1441 2
				LocalBuilder value1 = ilgen.AllocTempLocal(FloatOrDouble());
				LocalBuilder value2 = ilgen.AllocTempLocal(FloatOrDouble());
d1484 2
a1485 2
				LocalBuilder value1 = ilgen.AllocTempLocal(FloatOrDouble());
				LocalBuilder value2 = ilgen.AllocTempLocal(FloatOrDouble());
@


1.48
log
@Moved line number / sequence point handling into CodeEmitter and made things more consistent.
@
text
@a208 8
		internal bool IsStackEmpty
		{
			get
			{
				return topOfStack == 0;
			}
		}

@


1.47
log
@Removed IKVM_REF_EMIT, as STATIC_COMPILER or STUB_GENERATOR now always implies IKVM.Reflection.
@
text
@a80 1
#if STATIC_COMPILER
a81 1
#endif // STATIC_COMPILER
d86 1
d152 5
d217 1
a217 1
		internal int GetILOffset()
a566 6
		internal void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn)
		{
			LazyGen();
			ilgen_real.MarkSequencePoint(document, startLine, startColumn, endLine, endColumn);
		}

a575 1
#if STATIC_COMPILER
d578 1
a578 1
			if(linenums == null)
d580 14
a593 1
				linenums = new IKVM.Attributes.LineNumberTableAttribute.LineNumberWriter(32);
a594 1
			linenums.AddMapping(GetILOffset(), line);
d597 6
@


1.47.2.1
log
@Backport: Volatile stores require a memory barrier. Fix for #3086040.
@
text
@a74 1
		private static MethodInfo memoryBarrier;
a1056 9
		internal void EmitMemoryBarrier()
		{
			if (memoryBarrier == null)
			{
				memoryBarrier = JVM.Import(typeof(System.Threading.Thread)).GetMethod("MemoryBarrier", Type.EmptyTypes);
			}
			Emit(OpCodes.Call, memoryBarrier);
		}

@


1.46
log
@Integrated new IKVM.Reflection implementation.
@
text
@d26 1
a26 1
#if IKVM_REF_EMIT
d76 1
a76 1
#if !IKVM_REF_EMIT
d111 1
a111 1
#if IKVM_REF_EMIT
d216 1
a216 1
#if IKVM_REF_EMIT
d226 1
a226 1
#if !IKVM_REF_EMIT
d244 1
a244 1
#if !IKVM_REF_EMIT
d254 1
a254 1
#if !IKVM_REF_EMIT
d283 1
a283 1
#if !IKVM_REF_EMIT
d292 1
a292 1
#if !IKVM_REF_EMIT
d301 1
a301 1
#if !IKVM_REF_EMIT
d310 1
a310 1
#if !IKVM_REF_EMIT
d319 1
a319 1
#if !IKVM_REF_EMIT
d328 1
a328 1
#if !IKVM_REF_EMIT
d337 1
a337 1
#if !IKVM_REF_EMIT
d346 1
a346 1
#if !IKVM_REF_EMIT
d402 1
a402 1
#if !IKVM_REF_EMIT
d421 1
a421 1
#if !IKVM_REF_EMIT
d435 1
a435 1
#if !IKVM_REF_EMIT
d456 1
a456 1
#if !IKVM_REF_EMIT
d465 1
a465 1
#if !IKVM_REF_EMIT
d474 1
a474 1
#if !IKVM_REF_EMIT
d483 1
a483 1
#if !IKVM_REF_EMIT
d492 1
a492 1
#if !IKVM_REF_EMIT
d501 1
a501 1
#if !IKVM_REF_EMIT
d510 1
a510 1
#if !IKVM_REF_EMIT
d519 1
a519 1
#if !IKVM_REF_EMIT
d529 1
a529 1
#if !IKVM_REF_EMIT
d572 1
a572 1
#if !IKVM_REF_EMIT
d1032 1
a1032 1
#if !IKVM_REF_EMIT
@


1.45
log
@Removed unused methods.
@
text
@a25 1
using System.Reflection;
d27 1
d29 1
d31 1
@


1.44
log
@Renamed ILGenerator.__GetILOffset() to ILGenerator.ILOffset to match with .NET 4.0.
@
text
@a229 9
		internal void BeginExceptFilterBlock()
		{
			LazyGen();
#if !IKVM_REF_EMIT
			offset += 5;
#endif
			ilgen_real.BeginExceptFilterBlock();
		}

a468 10
		internal void Emit(OpCode opcode, SignatureHelper signature)
		{
			LazyGen();
#if !IKVM_REF_EMIT
			offset += opcode.Size;
#endif
			ilgen_real.Emit(opcode, signature);
			throw new NotImplementedException();
		}

a495 10
		internal void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)
		{
			LazyGen();
#if !IKVM_REF_EMIT
			offset += opcode.Size;
#endif
			ilgen_real.EmitCall(opcode, methodInfo, optionalParameterTypes);
			throw new NotImplementedException();
		}

a504 23
		internal void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
		{
			LazyGen();
#if !IKVM_REF_EMIT
			offset += 5;
#endif
			ilgen_real.EmitCalli(opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes);
		}

		internal void EmitWriteLine(FieldInfo fld)
		{
			LazyGen();
			ilgen_real.EmitWriteLine(fld);
			throw new NotImplementedException();
		}

		internal void EmitWriteLine(LocalBuilder localBuilder)
		{
			LazyGen();
			ilgen_real.EmitWriteLine(localBuilder);
			throw new NotImplementedException();
		}

a575 6
		internal void UsingNamespace(string usingNamespace)
		{
			LazyGen();
			ilgen_real.UsingNamespace(usingNamespace);
		}

@


1.43
log
@Simplified the obj1.getClass() == obj2.getClass() intrinsic to avoid RuntimeTypeHandle. It turns out that on .NET 4.0 RuntimeTypeHandle.Value requires full trust and using RuntimeTypeHandle.Equals is actually slower than simply comparing the types (on .NET 4.0 beta 2, on .NET 2.0 this new approach is actually a bit slower, but the fact that the code is simpler and smaller is also worth something).
@
text
@d215 1
a215 1
			return ilgen_real.__GetILOffset();
@


1.42
log
@Replaced most type literals with static field access (in Types class) or warpped JVM.Import() around them.
@
text
@a72 2
		private static readonly MethodInfo getTypeHandle = Types.Type.GetMethod("GetTypeHandle", BindingFlags.Public | BindingFlags.Static, null, new Type[] { Types.Object }, null);
		private static readonly MethodInfo get_Value = Types.RuntimeTypeHandle.GetMethod("get_Value", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
a719 9
		internal void EmitGetTypeHandleValue()
		{
			Emit(OpCodes.Call, getTypeHandle);
			LocalBuilder local = DeclareLocal(Types.RuntimeTypeHandle);
			Emit(OpCodes.Stloc, local);
			Emit(OpCodes.Ldloca, local);
			Emit(OpCodes.Call, get_Value);
		}

@


1.41
log
@Removed EmitHelper class and moved its methods into CodeEmitter.
@
text
@d71 1
a71 1
		private static readonly MethodInfo objectToString = typeof(object).GetMethod("ToString", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
d73 2
a74 2
		private static readonly MethodInfo getTypeHandle = typeof(Type).GetMethod("GetTypeHandle", BindingFlags.Public | BindingFlags.Static, null, new Type[] { typeof(object) }, null);
		private static readonly MethodInfo get_Value = typeof(RuntimeTypeHandle).GetMethod("get_Value", BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null);
d685 1
a685 1
				LocalBuilder lb = DeclareLocal(typeof(object));
d709 1
a709 1
			LocalBuilder lb = DeclareLocal(typeof(object));
d725 1
a725 1
			LocalBuilder local = DeclareLocal(typeof(RuntimeTypeHandle));
d1445 2
a1446 2
				LocalBuilder value1 = ilgen.AllocTempLocal(typeof(long));
				LocalBuilder value2 = ilgen.AllocTempLocal(typeof(long));
d1470 1
a1470 1
				return typeof(float);
d1514 1
a1514 1
				return typeof(float);
d1558 1
a1558 1
				return typeof(double);
d1566 1
a1566 1
				return typeof(double);
@


1.40
log
@Removed vestigial compact framework support.
@
text
@d69 1
a69 1
	class CodeEmitter
d71 4
d655 76
@


1.39
log
@Use ILGenerator's new "clever" mode in CodeEmitter to produce smaller code.
@
text
@a23 1
#if !COMPACT_FRAMEWORK
a1537 1
#endif
@


1.38
log
@If IKVM_REF_EMIT is defined, we don't need to track the IL offset, we can use ILGenerator.__GetILOffset() instead.
@
text
@d108 3
d565 10
@


1.37
log
@Optimized the reading of unsigned bytes from a byte array (buf[i] & 0xFF or buf[i] 0x0FFL).
@
text
@d73 1
d75 1
d210 3
d214 1
d220 1
d222 1
d229 1
d231 1
d247 1
d249 1
d257 1
d259 1
d286 1
d288 1
d295 1
d297 1
d304 1
d306 1
d313 1
d315 1
d322 1
d324 1
d331 1
d333 1
d340 1
d342 1
d349 1
d351 1
d357 1
a357 1
			LazyGen();
d366 1
a366 1
			else if(offset - label.Offset < 126)
d405 1
a405 2
			offset += opcode.Size;
			ilgen_real.Emit(opcode, label.Label);
d409 1
a409 1
					offset += 4;
d412 1
a412 1
					offset += 1;
d417 2
d424 1
d426 1
d438 1
a438 1
			ilgen_real.Emit(opcode, local);
d452 2
d459 1
d461 1
d468 1
d470 1
d477 1
d479 1
d487 1
d489 1
d496 1
d498 1
d505 1
d507 1
d514 1
d516 1
d524 1
d526 1
d533 1
d535 1
d556 1
d558 1
d565 1
d574 1
d596 1
a596 1
			loc.Offset = offset;
d608 1
d610 1
a622 1
			LazyGen();
d627 1
a627 1
			linenums.AddMapping(offset, line);
d1007 1
d1009 1
@


1.36
log
@Moved class literal emit code to TypeWrapper and added checks to prevent types that are illegal in type instantations from being used with ClassLiteral<T>.
@
text
@d866 58
d974 1
a974 1
			internal bool HasSideEffect { get { return false; } }	// for now we only have side-effect free expressions
d981 1
a981 1
		abstract class ExprWithExprAndType : Expr
a983 1
			internal readonly Type Type;
d985 1
a985 1
			protected ExprWithExprAndType(Expr expr, Type type)
a987 1
				this.Type = type;
d990 1
a990 1
			internal override bool IsIncomplete
d995 5
d1009 12
a1020 1
		class BoxExpr : ExprWithExprAndType
d1034 1
a1034 1
		class UnboxExpr : ExprWithExprAndType
d1048 1
a1048 1
		class BoxUnboxExpr : ExprWithExprAndType
d1067 1
a1067 1
		class LdobjExpr : ExprWithExprAndType
d1081 1
a1081 1
		class NullExpr : Expr
d1089 1
a1089 1
		class ConstIntExpr : Expr
d1402 1
a1402 1
		class DCmplExpr : FCmplExpr
d1410 1
a1410 1
		class DCmpgExpr : FCmpgExpr
d1418 1
a1418 1
		class ClassLiteralExpr : Expr
d1432 32
@


1.35
log
@Store our CodeEmitterLabel object in label check dictionary, instead of the underlying Label.
@
text
@d1357 1
a1357 24
				TypeWrapper tw = Type;
				if (tw.IsGhostArray)
				{
					int rank = tw.ArrayRank;
					while (tw.IsArray)
					{
						tw = tw.ElementTypeWrapper;
					}
					ilgen.Emit(OpCodes.Ldsfld, RuntimeHelperTypes.GetClassLiteralField(ArrayTypeWrapper.MakeArrayType(tw.TypeAsTBD, rank)));
				}
				else
				{
					Type type = tw.IsRemapped ? tw.TypeAsBaseType : tw.TypeAsTBD;
					if (type == typeof(void))
					{
						// the CLR doesn't allow System.Void to be used as a type parameter, so we have to special case it
						ilgen.Emit(OpCodes.Ldtoken, type);
						Compiler.getClassFromTypeHandle.EmitCall(ilgen);
					}
					else
					{
						ilgen.Emit(OpCodes.Ldsfld, RuntimeHelperTypes.GetClassLiteralField(type));
					}
				}
@


1.34
log
@Renamed CodeEmitter.Finish() to CheckLabels() and moved invocation to the right place.
@
text
@d84 1
a84 1
		private Dictionary<Label, System.Diagnostics.StackFrame> labels = new Dictionary<Label, System.Diagnostics.StackFrame>();
d262 1
a262 1
			Label label = ilgen_real.DefineLabel();
d266 1
a266 1
			return new CodeEmitterLabel(label);
d536 1
a536 1
			labels.Remove(loc.Label);
@


1.33
log
@Implemented ikvm.internal.ClassLiteral<T> to allow for more efficient class literals.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004, 2005, 2006, 2008 Jeroen Frijters
d903 1
a903 1
		internal void Finish()
@


1.32
log
@- Moved class literal TypeWrapper -> Type step into expression emitter.
- Fixed Class.desiredAssertionStatus() instrinsic to use the RemoveAsserts flag from the right class loader.
@
text
@d1365 1
a1365 1
					ilgen.Emit(OpCodes.Ldtoken, ArrayTypeWrapper.MakeArrayType(tw.TypeAsTBD, rank));
d1369 11
a1379 1
					ilgen.Emit(OpCodes.Ldtoken, tw.IsRemapped ? tw.TypeAsBaseType : tw.TypeAsTBD);
a1380 1
				Compiler.getClassFromTypeHandle.EmitCall(ilgen);
@


1.31
log
@Fixed bug introduced in recent changes. When the first entry on the stack contains a partial expression, it cannot be popped.
@
text
@d594 1
a594 1
		internal void LazyEmitLoadClass(Type type)
d877 10
d1348 1
a1348 1
			private readonly Type type;
d1350 1
a1350 1
			internal ClassLiteralExpr(Type type)
d1352 1
a1352 1
				this.type = type;
d1357 14
a1370 1
				ilgen.Emit(OpCodes.Ldtoken, type);
@


1.30
log
@- Added support for multi level stack tracking to CodeEmitter.
- Made most Pop emitting lazy to enable optimizing them away (together with corresponding push).
- Made loading class literal lazy, to enable optimizing them away when they aren't used (e.g. because an atomic intrinsic).
- Made Class.desiredAssertionStatus() into an intrinsic, to be able to optimize it away when -removeassertions is used.
@
text
@d584 1
a584 1
			if (exp == null || exp.HasSideEffect)
d908 2
d924 5
d1170 8
d1192 8
@


1.29
log
@Integrated IKVM.Reflection.Emit in ikvmc.
@
text
@d35 1
d79 2
a80 1
		private Expr stack;
d109 36
d201 1
a201 1
				return stack == null;
d581 18
d601 1
a601 1
			stack = new BoxExpr(stack, type);
d606 1
a606 1
			BoxExpr box = stack as BoxExpr;
d609 2
a610 1
				stack = new BoxUnboxExpr(box.Expr, type);
d614 1
a614 1
				stack = new UnboxExpr(stack, type);
d620 1
a620 1
			BoxUnboxExpr boxunbox = stack as BoxUnboxExpr;
d623 1
d625 1
a625 1
				stack = boxunbox.Expr;
d629 1
a629 1
				stack = new LdobjExpr(stack, type);
d635 1
a635 1
			BoxExpr box = stack as BoxExpr;
d638 1
d640 1
a640 1
				stack = box.Expr;
d659 5
d666 1
a666 2
			LazyGen();
			stack = new ConstIntExpr(i);
d671 1
a671 2
			LazyGen();
			stack = new ConstLongExpr(l);
d676 1
a676 2
			LazyGen();
			stack = new ConstStringExpr(str);
d684 1
a684 1
			ConstIntExpr v = stack as ConstIntExpr;
d689 1
a689 1
					stack = null;
d718 1
a718 1
			ConstLongExpr v = stack as ConstLongExpr;
d723 1
a723 1
					stack = null;
d750 1
a750 2
			LazyGen();
			stack = new InstanceOfExpr(type);
d765 1
a765 1
			InstanceOfExpr instanceof = stack as InstanceOfExpr;
d768 1
a768 1
				stack = null;
d773 1
a773 1
				CmpExpr cmp = stack as CmpExpr;
d776 1
a776 1
					stack = null;
d813 1
a813 1
			CmpExpr cmp = stack as CmpExpr;
d816 1
a816 1
				stack = null;
d828 1
a828 2
			LazyGen();
			stack = new LCmpExpr();
d833 1
a833 2
			LazyGen();
			stack = new FCmplExpr();
d838 1
a838 2
			LazyGen();
			stack = new FCmpgExpr();
d843 1
a843 2
			LazyGen();
			stack = new DCmplExpr();
d848 1
a848 2
			LazyGen();
			stack = new DCmpgExpr();
d853 1
a853 1
			ConstIntExpr v1 = stack as ConstIntExpr;
d856 1
a856 1
				stack = null;
d868 1
a868 1
			ConstStringExpr str = stack as ConstStringExpr;
d871 1
a871 1
				stack = null;
a878 6
			if(stack != null)
			{
				Expr exp = stack;
				stack = null;
				exp.Emit(this);
			}
d885 6
d906 1
a906 6
			internal readonly Type Type;

			protected Expr(Type type)
			{
				this.Type = type;
			}
d911 1
a911 1
		abstract class UnaryExpr : Expr
d914 1
d916 1
a916 2
			protected UnaryExpr(Expr expr, Type type)
				: base(type)
d919 1
d931 1
a931 1
		class BoxExpr : UnaryExpr
d945 1
a945 1
		class UnboxExpr : UnaryExpr
d959 1
a959 1
		class BoxUnboxExpr : UnaryExpr
d978 1
a978 1
		class LdobjExpr : UnaryExpr
d992 8
a1004 1
				: base(typeof(int))
a1061 1
				: base(typeof(long))
a1143 1
				: base(typeof(string))
d1156 2
a1158 1
				: base(type)
d1160 1
a1173 1
				: base(typeof(int))
d1312 16
@


1.28
log
@Generified all collections.
@
text
@d28 3
d32 1
@


1.27
log
@Removed our own tracking of LocalBuilders, because on .NET 2.0 LocalBuilder has a LocalIndex property.
@
text
@d26 1
a26 1
using System.Collections;
d69 1
a69 1
		private Stack exceptionStack = new Stack();
d78 1
a78 1
		private Hashtable labels = new Hashtable();
d476 1
a476 1
			inFinally = (bool)exceptionStack.Pop();
@


1.26
log
@DynamicMethod support isn't needed in ikvmc.
@
text
@a68 1
		private ArrayList locals = new ArrayList();
d215 1
a215 3
			LocalBuilder loc = ilgen_real.DeclareLocal(localType);
			locals.Add(loc);
			return loc;
d364 1
a364 1
			int index = locals.IndexOf(local);
@


1.25
log
@- Renamed CountingILGenerator to CodeEmitter.
- Renamed CountingLabel to CodeEmitterLabel.
@
text
@d92 1
d97 1
@


1.24
log
@- Optimized codegen for lcmp, fcmp<x>, dcmp<x> and shift opcodes.
- Moved temp local handling to CodeEmitter.
@
text
@d34 1
a34 1
	class CountingLabel
d39 1
a39 1
		internal CountingLabel(Label label)
d65 1
a65 1
	class CountingILGenerator
d76 1
a76 1
		private CountingLabel lazyBranch;
d82 1
a82 1
		public static implicit operator CountingILGenerator(ILGenerator ilgen)
d84 1
a84 1
			return new CountingILGenerator(ilgen);
d87 11
a97 1
		internal CountingILGenerator(ILGenerator ilgen)
d219 1
a219 1
		internal CountingLabel DefineLabel()
d225 1
a225 1
			return new CountingLabel(label);
d284 1
a284 1
		internal void Emit(OpCode opcode, CountingLabel label)
d349 1
a349 1
		internal void Emit(OpCode opcode, CountingLabel[] labels)
d487 1
a487 1
		internal void MarkLabel(CountingLabel loc)
d584 1
a584 1
				CountingLabel label1 = DefineLabel();
d588 1
a588 1
				CountingLabel label2 = DefineLabel();
d637 1
a637 1
				CountingLabel label = DefineLabel();
d641 1
a641 1
				CountingLabel label2 = DefineLabel();
d672 1
a672 1
				CountingLabel label = DefineLabel();
d676 1
a676 1
				CountingLabel label2 = DefineLabel();
d690 1
a690 1
		internal void LazyEmit_ifeq(CountingLabel label)
d695 1
a695 1
		internal void LazyEmit_ifne(CountingLabel label)
d700 1
a700 1
		private void LazyEmit_if_ne_eq(CountingLabel label, bool brtrue)
d729 1
a729 1
		private void EmitBcc(Comparison comp, CountingLabel label)
d748 1
a748 1
		internal void LazyEmit_if_le_lt_ge_gt(Comparison comp, CountingLabel label)
d855 1
a855 1
			internal abstract void Emit(CountingILGenerator ilgen);
d868 1
a868 1
			internal override void Emit(CountingILGenerator ilgen)
d884 1
a884 1
			internal override void Emit(CountingILGenerator ilgen)
d898 1
a898 1
			internal override void Emit(CountingILGenerator ilgen)
d912 1
a912 1
			internal override void Emit(CountingILGenerator ilgen)
d931 1
a931 1
			internal override void Emit(CountingILGenerator ilgen)
d948 1
a948 1
			internal override void Emit(CountingILGenerator ilgen)
d1006 1
a1006 1
			internal override void Emit(CountingILGenerator ilgen)
d1089 1
a1089 1
			internal override void Emit(CountingILGenerator ilgen)
d1102 1
a1102 1
			internal override void Emit(CountingILGenerator ilgen)
d1117 1
a1117 1
			internal abstract void EmitBcc(CountingILGenerator ilgen, Comparison comp, CountingLabel label);
d1126 1
a1126 1
			internal sealed override void Emit(CountingILGenerator ilgen)
d1143 1
a1143 1
			internal sealed override void EmitBcc(CountingILGenerator ilgen, Comparison comp, CountingLabel label)
d1156 1
a1156 1
			internal sealed override void Emit(CountingILGenerator ilgen)
d1173 1
a1173 1
			internal sealed override void EmitBcc(CountingILGenerator ilgen, Comparison comp, CountingLabel label)
d1200 1
a1200 1
			internal sealed override void Emit(CountingILGenerator ilgen)
d1217 1
a1217 1
			internal sealed override void EmitBcc(CountingILGenerator ilgen, Comparison comp, CountingLabel label)
@


1.23
log
@Added support for lazy string literals.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004, 2005, 2006 Jeroen Frijters
d67 1
a67 1
		private ILGenerator ilgen;
d77 1
d89 53
a141 1
			this.ilgen = ilgen;
d162 1
a162 1
			ilgen.BeginCatchBlock(exceptionType);
d169 1
a169 1
			ilgen.BeginExceptFilterBlock();
d177 1
a177 1
			return ilgen.BeginExceptionBlock();
d185 1
a185 1
			ilgen.BeginFaultBlock();
d193 1
a193 1
			ilgen.BeginFinallyBlock();
d199 1
a199 1
			ilgen.BeginScope();
d204 1
a204 1
			LocalBuilder loc = ilgen.DeclareLocal(localType);
d211 1
a211 1
			Label label = ilgen.DefineLabel();
d222 1
a222 1
			ilgen.Emit(opcode);
d229 1
a229 1
			ilgen.Emit(opcode, arg);
d236 1
a236 1
			ilgen.Emit(opcode, con);
d243 1
a243 1
			ilgen.Emit(opcode, arg);
d250 1
a250 1
			ilgen.Emit(opcode, field);
d257 1
a257 1
			ilgen.Emit(opcode, arg);
d264 1
a264 1
			ilgen.Emit(opcode, arg);
d271 1
a271 1
			ilgen.Emit(opcode, arg);
d325 1
a325 1
			ilgen.Emit(opcode, label.Label);
d348 1
a348 1
			ilgen.Emit(opcode, real);
d354 1
a354 1
			ilgen.Emit(opcode, local);
d374 1
a374 1
			ilgen.Emit(opcode, meth);
d381 1
a381 1
			ilgen.Emit(opcode, arg);
d388 1
a388 1
			ilgen.Emit(opcode, signature);
d396 1
a396 1
			ilgen.Emit(opcode, arg);
d403 1
a403 1
			ilgen.Emit(opcode, arg);
d410 1
a410 1
			ilgen.Emit(opcode, cls);
d417 1
a417 1
			ilgen.EmitCall(opcode, methodInfo, optionalParameterTypes);
d425 1
a425 1
			ilgen.EmitCalli(opcode, unmanagedCallConv, returnType, parameterTypes);
d432 1
a432 1
			ilgen.EmitCalli(opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes);
d438 1
a438 1
			ilgen.EmitWriteLine(fld);
d445 1
a445 1
			ilgen.EmitWriteLine(localBuilder);
d453 1
a453 1
			ilgen.EmitWriteLine(value);
d468 1
a468 1
			ilgen.EndExceptionBlock();
d474 1
a474 1
			ilgen.EndScope();
d487 1
a487 1
			ilgen.MarkLabel(loc.Label);
d494 1
a494 1
			ilgen.MarkSequencePoint(document, startLine, startColumn, endLine, endColumn);
d501 1
a501 1
			ilgen.ThrowException(excType);
d507 1
a507 1
			ilgen.UsingNamespace(usingNamespace);
d682 10
d693 1
a693 1
			if(instanceof != null)
d698 83
a780 1
			Emit(OpCodes.Brfalse, label);
d783 1
a783 1
		internal void LazyEmit_ifne(CountingLabel label)
d785 2
a786 2
			InstanceOfExpr instanceof = stack as InstanceOfExpr;
			if(instanceof != null)
d789 6
a794 1
				Emit(OpCodes.Isinst, instanceof.Type);
a795 1
			Emit(OpCodes.Brtrue, label);
d820 1
a820 1
				ilgen.Emit(OpCodes.Br, lazyBranch.Label);
d986 1
a986 1
		class ConstLongExpr : Expr
d998 1
a998 1
				switch(l)
d1041 1
a1041 1
						if(l >= -2147483648L && l <= 4294967295L)
d1043 1
a1043 1
							if(l >= -128 && l <= 127)
d1051 1
a1051 1
							if(l < 0)
d1069 1
a1069 1
		class ConstStringExpr : Expr
d1085 1
a1085 1
		class InstanceOfExpr : Expr
d1099 143
@


1.23.2.1
log
@- Changed version to 0.36.0.9
- Added java.util.BitSet perf hack to map.xml
- Back ported codegen optimizations from 0.37.2970
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004, 2005, 2006, 2008 Jeroen Frijters
d67 1
a67 1
		private ILGenerator ilgen_real;
a76 1
		private LocalBuilder[] tempLocals = new LocalBuilder[32];
d88 1
a88 53
			this.ilgen_real = ilgen;
		}

		internal LocalBuilder UnsafeAllocTempLocal(Type type)
		{
			int free = -1;
			for (int i = 0; i < tempLocals.Length; i++)
			{
				LocalBuilder lb = tempLocals[i];
				if (lb == null)
				{
					if (free == -1)
					{
						free = i;
					}
				}
				else if (lb.LocalType == type)
				{
					return lb;
				}
			}
			LocalBuilder lb1 = DeclareLocal(type);
			if (free != -1)
			{
				tempLocals[free] = lb1;
			}
			return lb1;
		}

		internal LocalBuilder AllocTempLocal(Type type)
		{
			for (int i = 0; i < tempLocals.Length; i++)
			{
				LocalBuilder lb = tempLocals[i];
				if (lb != null && lb.LocalType == type)
				{
					tempLocals[i] = null;
					return lb;
				}
			}
			return DeclareLocal(type);
		}

		internal void ReleaseTempLocal(LocalBuilder lb)
		{
			for (int i = 0; i < tempLocals.Length; i++)
			{
				if (tempLocals[i] == null)
				{
					tempLocals[i] = lb;
					break;
				}
			}
d109 1
a109 1
			ilgen_real.BeginCatchBlock(exceptionType);
d116 1
a116 1
			ilgen_real.BeginExceptFilterBlock();
d124 1
a124 1
			return ilgen_real.BeginExceptionBlock();
d132 1
a132 1
			ilgen_real.BeginFaultBlock();
d140 1
a140 1
			ilgen_real.BeginFinallyBlock();
d146 1
a146 1
			ilgen_real.BeginScope();
d151 1
a151 1
			LocalBuilder loc = ilgen_real.DeclareLocal(localType);
d158 1
a158 1
			Label label = ilgen_real.DefineLabel();
d169 1
a169 1
			ilgen_real.Emit(opcode);
d176 1
a176 1
			ilgen_real.Emit(opcode, arg);
d183 1
a183 1
			ilgen_real.Emit(opcode, con);
d190 1
a190 1
			ilgen_real.Emit(opcode, arg);
d197 1
a197 1
			ilgen_real.Emit(opcode, field);
d204 1
a204 1
			ilgen_real.Emit(opcode, arg);
d211 1
a211 1
			ilgen_real.Emit(opcode, arg);
d218 1
a218 1
			ilgen_real.Emit(opcode, arg);
d272 1
a272 1
			ilgen_real.Emit(opcode, label.Label);
d295 1
a295 1
			ilgen_real.Emit(opcode, real);
d301 1
a301 1
			ilgen_real.Emit(opcode, local);
d321 1
a321 1
			ilgen_real.Emit(opcode, meth);
d328 1
a328 1
			ilgen_real.Emit(opcode, arg);
d335 1
a335 1
			ilgen_real.Emit(opcode, signature);
d343 1
a343 1
			ilgen_real.Emit(opcode, arg);
d350 1
a350 1
			ilgen_real.Emit(opcode, arg);
d357 1
a357 1
			ilgen_real.Emit(opcode, cls);
d364 1
a364 1
			ilgen_real.EmitCall(opcode, methodInfo, optionalParameterTypes);
d372 1
a372 1
			ilgen_real.EmitCalli(opcode, unmanagedCallConv, returnType, parameterTypes);
d379 1
a379 1
			ilgen_real.EmitCalli(opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes);
d385 1
a385 1
			ilgen_real.EmitWriteLine(fld);
d392 1
a392 1
			ilgen_real.EmitWriteLine(localBuilder);
d400 1
a400 1
			ilgen_real.EmitWriteLine(value);
d415 1
a415 1
			ilgen_real.EndExceptionBlock();
d421 1
a421 1
			ilgen_real.EndScope();
d434 1
a434 1
			ilgen_real.MarkLabel(loc.Label);
d441 1
a441 1
			ilgen_real.MarkSequencePoint(document, startLine, startColumn, endLine, endColumn);
d448 1
a448 1
			ilgen_real.ThrowException(excType);
d454 1
a454 1
			ilgen_real.UsingNamespace(usingNamespace);
a628 10
			LazyEmit_if_ne_eq(label, false);
		}

		internal void LazyEmit_ifne(CountingLabel label)
		{
			LazyEmit_if_ne_eq(label, true);
		}

		private void LazyEmit_if_ne_eq(CountingLabel label, bool brtrue)
		{
d630 1
a630 1
			if (instanceof != null)
d635 1
a635 11
			else
			{
				CmpExpr cmp = stack as CmpExpr;
				if (cmp != null)
				{
					stack = null;
					Emit(brtrue ? OpCodes.Bne_Un : OpCodes.Beq, label);
					return;
				}
			}
			Emit(brtrue ? OpCodes.Brtrue : OpCodes.Brfalse, label);
d638 1
a638 1
		internal enum Comparison
d640 2
a641 29
			LessOrEqual,
			LessThan,
			GreaterOrEqual,
			GreaterThan
		}

		private void EmitBcc(Comparison comp, CountingLabel label)
		{
			switch (comp)
			{
				case Comparison.LessOrEqual:
					Emit(OpCodes.Ble, label);
					break;
				case Comparison.LessThan:
					Emit(OpCodes.Blt, label);
					break;
				case Comparison.GreaterOrEqual:
					Emit(OpCodes.Bge, label);
					break;
				case Comparison.GreaterThan:
					Emit(OpCodes.Bgt, label);
					break;
			}
		}

		internal void LazyEmit_if_le_lt_ge_gt(Comparison comp, CountingLabel label)
		{
			CmpExpr cmp = stack as CmpExpr;
			if (cmp != null)
d644 1
a644 51
				cmp.EmitBcc(this, comp, label);
			}
			else
			{
				Emit(OpCodes.Ldc_I4_0);
				EmitBcc(comp, label);
			}
		}

		internal void LazyEmit_lcmp()
		{
			LazyGen();
			stack = new LCmpExpr();
		}

		internal void LazyEmit_fcmpl()
		{
			LazyGen();
			stack = new FCmplExpr();
		}

		internal void LazyEmit_fcmpg()
		{
			LazyGen();
			stack = new FCmpgExpr();
		}

		internal void LazyEmit_dcmpl()
		{
			LazyGen();
			stack = new DCmplExpr();
		}

		internal void LazyEmit_dcmpg()
		{
			LazyGen();
			stack = new DCmpgExpr();
		}

		internal void LazyEmitAnd_I4(int v2)
		{
			ConstIntExpr v1 = stack as ConstIntExpr;
			if (v1 != null)
			{
				stack = null;
				LazyEmitLdc_I4(v1.i & v2);
			}
			else
			{
				LazyEmitLdc_I4(v2);
				Emit(OpCodes.And);
d646 1
d671 1
a671 1
				ilgen_real.Emit(OpCodes.Br, lazyBranch.Label);
d837 1
a837 1
		sealed class ConstLongExpr : Expr
d849 1
a849 1
				switch (l)
d892 1
a892 1
						if (l >= -2147483648L && l <= 4294967295L)
d894 1
a894 1
							if (l >= -128 && l <= 127)
d902 1
a902 1
							if (l < 0)
d920 1
a920 1
		sealed class ConstStringExpr : Expr
d936 1
a936 1
		sealed class InstanceOfExpr : Expr
a949 167

		abstract class CmpExpr : Expr
		{
			internal CmpExpr()
				: base(typeof(int))
			{
			}

			internal abstract void EmitBcc(CountingILGenerator ilgen, Comparison comp, CountingLabel label);
		}

		sealed class LCmpExpr : CmpExpr
		{
			internal LCmpExpr()
			{
			}

			internal sealed override void Emit(CountingILGenerator ilgen)
			{
				LocalBuilder value1 = ilgen.AllocTempLocal(typeof(long));
				LocalBuilder value2 = ilgen.AllocTempLocal(typeof(long));
				ilgen.Emit(OpCodes.Stloc, value2);
				ilgen.Emit(OpCodes.Stloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Cgt);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Clt);
				ilgen.Emit(OpCodes.Sub);
				ilgen.ReleaseTempLocal(value2);
				ilgen.ReleaseTempLocal(value1);
			}

			internal sealed override void EmitBcc(CountingILGenerator ilgen, Comparison comp, CountingLabel label)
			{
				ilgen.EmitBcc(comp, label);
			}
		}

		class FCmplExpr : CmpExpr
		{
			protected virtual Type FloatOrDouble()
			{
				return typeof(float);
			}

			internal sealed override void Emit(CountingILGenerator ilgen)
			{
				LocalBuilder value1 = ilgen.AllocTempLocal(FloatOrDouble());
				LocalBuilder value2 = ilgen.AllocTempLocal(FloatOrDouble());
				ilgen.Emit(OpCodes.Stloc, value2);
				ilgen.Emit(OpCodes.Stloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Cgt);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Clt_Un);
				ilgen.Emit(OpCodes.Sub);
				ilgen.ReleaseTempLocal(value1);
				ilgen.ReleaseTempLocal(value2);
			}

			internal sealed override void EmitBcc(CountingILGenerator ilgen, Comparison comp, CountingLabel label)
			{
				switch (comp)
				{
					case Comparison.LessOrEqual:
					{
						// FXBUG we invert the test to workaround a bug in the .NET 1.1 JIT (fixed in .NET 2.0)
						CountingLabel label2 = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Bgt_S, label2);
						ilgen.Emit(OpCodes.Br, label);
						ilgen.MarkLabel(label2);
						break;
					}
					case Comparison.LessThan:
					{
						// FXBUG we invert the test to workaround a bug in the .NET 1.1 JIT (fixed in .NET 2.0)
						CountingLabel label2 = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Bge_S, label2);
						ilgen.Emit(OpCodes.Br, label);
						ilgen.MarkLabel(label2);
						break;
					}
					case Comparison.GreaterOrEqual:
						ilgen.Emit(OpCodes.Bge, label);
						break;
					case Comparison.GreaterThan:
						ilgen.Emit(OpCodes.Bgt, label);
						break;
				}
			}
		}

		class FCmpgExpr : CmpExpr
		{
			protected virtual Type FloatOrDouble()
			{
				return typeof(float);
			}

			internal sealed override void Emit(CountingILGenerator ilgen)
			{
				LocalBuilder value1 = ilgen.AllocTempLocal(FloatOrDouble());
				LocalBuilder value2 = ilgen.AllocTempLocal(FloatOrDouble());
				ilgen.Emit(OpCodes.Stloc, value2);
				ilgen.Emit(OpCodes.Stloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Cgt_Un);
				ilgen.Emit(OpCodes.Ldloc, value1);
				ilgen.Emit(OpCodes.Ldloc, value2);
				ilgen.Emit(OpCodes.Clt);
				ilgen.Emit(OpCodes.Sub);
				ilgen.ReleaseTempLocal(value1);
				ilgen.ReleaseTempLocal(value2);
			}

			internal sealed override void EmitBcc(CountingILGenerator ilgen, Comparison comp, CountingLabel label)
			{
				switch (comp)
				{
					case Comparison.LessOrEqual:
						ilgen.Emit(OpCodes.Ble, label);
						break;
					case Comparison.LessThan:
						ilgen.Emit(OpCodes.Blt, label);
						break;
					case Comparison.GreaterOrEqual:
					{
						// FXBUG we invert the test to workaround a bug in the .NET 1.1 JIT (fixed in .NET 2.0)
						CountingLabel label2 = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Blt_S, label2);
						ilgen.Emit(OpCodes.Br, label);
						ilgen.MarkLabel(label2);
						break;
					}
					case Comparison.GreaterThan:
					{
						// FXBUG we invert the test to workaround a bug in the .NET 1.1 JIT (fixed in .NET 2.0)
						CountingLabel label2 = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Ble_S, label2);
						ilgen.Emit(OpCodes.Br, label);
						ilgen.MarkLabel(label2);
						break;
					}
				}
			}
		}

		class DCmplExpr : FCmplExpr
		{
			protected override Type FloatOrDouble()
			{
				return typeof(double);
			}
		}

		class DCmpgExpr : FCmpgExpr
		{
			protected override Type FloatOrDouble()
			{
				return typeof(double);
			}
		}
@


1.23.2.2
log
@Added workaround for .NET 1.1 JIT bug.
@
text
@a703 10
					if (cmp is FCmpgExpr || cmp is FCmplExpr)
					{
						// FXBUG we would like to use Bne_Un/Beq here, but the .NET 1.1 JIT generates incorrect code
						// that returns the wrong result when comparing NaN to itself
						Emit(OpCodes.Ceq);
						// this Neg is to thwart the (broken) optimizer
						Emit(OpCodes.Neg);
						Emit(brtrue ? OpCodes.Brfalse : OpCodes.Brtrue, label);
						return;
					}
@


1.22
log
@*** empty log message ***
@
text
@d91 8
d546 6
d649 11
d920 16
@


1.21
log
@*** empty log message ***
@
text
@d75 1
a75 1
		private Type boxType;
d471 1
a471 2
			LazyGen();
			boxType = type;
d474 1
a474 1
		internal bool IsBoxPending(Type type)
d476 9
a484 6
			return boxType == type;
		}

		internal void ClearPendingBox()
		{
			boxType = null;
d487 1
a487 1
		internal void LazyEmitUnbox(Type type)
d489 2
a490 1
			if(boxType != null && boxType == type)
d492 2
a493 8
				// the unbox and lazy box cancel each other out
				boxType = null;
				// unbox leaves a pointer to the value of the stack (instead of the value)
				// so we have to copy the value into a local variable and load the address
				// of the local onto the stack
				LocalBuilder local = DeclareLocal(type);
				Emit(OpCodes.Stloc, local);
				Emit(OpCodes.Ldloca, local);
d497 1
a497 1
				Emit(OpCodes.Unbox, type);
d503 2
a504 1
			if(boxType != null && boxType == type)
d507 1
a507 1
				boxType = null;
d526 109
d637 1
a637 1
			if(boxType != null)
d639 3
a641 3
				Type t = boxType;
				boxType = null;
				Emit(OpCodes.Box, t);
d661 248
@


1.20
log
@*** empty log message ***
@
text
@d462 1
a462 1
			if(!IKVM.Internal.JVM.NoStackTraceInfo && linenums != null)
@


1.19
log
@*** empty log message ***
@
text
@d72 1
d74 1
d449 1
d467 1
@


1.18
log
@*** empty log message ***
@
text
@a550 7

#if STATIC_COMPILER
	public abstract class CodeEmitter
	{
		internal abstract void Emit(CountingILGenerator ilgen);
	}
#endif
@


1.17
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004, 2005 Jeroen Frijters
d552 1
d557 1
@


1.16
log
@*** empty log message ***
@
text
@d74 1
d214 9
a222 1
			if(label.Offset != -1 && offset - label.Offset < 126)
d416 4
d532 6
@


1.15
log
@*** empty log message ***
@
text
@d34 31
d145 1
a145 1
		internal Label DefineLabel()
d151 1
a151 1
			return label;
d210 1
a210 1
		internal void Emit(OpCode opcode, Label label)
d213 39
d253 1
a253 1
			ilgen.Emit(opcode, label);
d267 1
a267 1
		internal void Emit(OpCode opcode, Label[] labels)
d271 6
a276 1
			ilgen.Emit(opcode, labels);
d405 1
a405 1
		internal void MarkLabel(Label loc)
d409 1
a409 1
		labels.Remove(loc);
d411 2
a412 1
			ilgen.MarkLabel(loc);
d498 1
a498 1
				Label label1 = DefineLabel();
d502 1
a502 1
				Label label2 = DefineLabel();
@


1.14
log
@*** empty log message ***
@
text
@d382 29
@


1.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004 Jeroen Frijters
d42 1
d44 1
a44 1
	private Hashtable labels = new Hashtable();
d59 1
d65 1
d72 1
d79 1
d87 1
d95 1
d103 1
d118 1
a118 1
		labels.Add(label, new System.Diagnostics.StackFrame(1, true));
d125 1
d132 1
d139 1
d146 1
d153 1
d160 1
d167 1
d174 1
d181 1
d199 1
d206 1
d225 1
d232 1
d239 1
d247 1
d254 1
d261 1
d268 1
d276 1
d283 1
d290 1
d297 1
d304 1
d311 1
d326 1
d332 1
d341 1
d347 1
d354 1
d360 1
d376 40
d419 5
a423 5
		foreach(System.Diagnostics.StackFrame frame in labels.Values)
		{
			string name = frame.GetFileName() + ":" + frame.GetFileLineNumber();
			IKVM.Internal.JVM.CriticalFailure("Label failure: " + name, null);
		}
@


1.12
log
@*** empty log message ***
@
text
@d24 1
d355 1
@


1.11
log
@*** empty log message ***
@
text
@d333 1
a333 1
				AttributeHelper.SetLineNumberTable(mb, linenums.ToArray());
@


1.10
log
@*** empty log message ***
@
text
@d81 1
@


1.9
log
@*** empty log message ***
@
text
@d40 1
a40 1
		private System.IO.MemoryStream linenums;
d323 1
a323 1
				linenums = new System.IO.MemoryStream();
d325 1
a325 2
			IKVM.Attributes.LineNumberTableAttribute.WritePackedInteger(linenums, (uint)offset);
			IKVM.Attributes.LineNumberTableAttribute.WritePackedInteger(linenums, line);
@


1.8
log
@*** empty log message ***
@
text
@d31 1
a31 1
class CountingILGenerator
d33 8
a40 6
	private ILGenerator ilgen;
	private int offset;
	private ArrayList locals = new ArrayList();
	private Stack exceptionStack = new Stack();
	private bool inFinally;
	private System.IO.MemoryStream linenums;
d45 4
a48 4
	public static implicit operator CountingILGenerator(ILGenerator ilgen)
	{
		return new CountingILGenerator(ilgen);
	}
d50 4
a53 4
	internal CountingILGenerator(ILGenerator ilgen)
	{
		this.ilgen = ilgen;
	}
d55 4
a58 4
	internal int GetILOffset()
	{
		return offset;
	}
d60 5
a64 5
	internal void BeginCatchBlock(Type exceptionType)
	{
		offset += 5;
		ilgen.BeginCatchBlock(exceptionType);
	}
d66 5
a70 5
	internal void BeginExceptFilterBlock()
	{
		offset += 5;
		ilgen.BeginExceptFilterBlock();
	}
d72 6
a77 6
	internal Label BeginExceptionBlock()
	{
		exceptionStack.Push(inFinally);
		inFinally = false;
		return ilgen.BeginExceptionBlock();
	}
d79 5
a83 5
	internal void BeginFaultBlock()
	{
		offset += 5;
		ilgen.BeginFaultBlock();
	}
d85 6
a90 6
	internal void BeginFinallyBlock()
	{
		inFinally = true;
		offset += 5;
		ilgen.BeginFinallyBlock();
	}
d92 4
a95 4
	internal void BeginScope()
	{
		ilgen.BeginScope();
	}
d97 6
a102 6
	internal LocalBuilder DeclareLocal(Type localType)
	{
		LocalBuilder loc = ilgen.DeclareLocal(localType);
		locals.Add(loc);
		return loc;
	}
d104 3
a106 3
	internal Label DefineLabel()
	{
		Label label = ilgen.DefineLabel();
d110 2
a111 2
		return label;
	}
d113 5
a117 5
	internal void Emit(OpCode opcode)
	{
		offset += opcode.Size;
		ilgen.Emit(opcode);
	}
d119 5
a123 5
	internal void Emit(OpCode opcode, byte arg)
	{
		offset += opcode.Size + 1;
		ilgen.Emit(opcode, arg);
	}
d125 5
a129 5
	internal void Emit(OpCode opcode, ConstructorInfo con)
	{
		offset += opcode.Size + 4;
		ilgen.Emit(opcode, con);
	}
d131 5
a135 5
	internal void Emit(OpCode opcode, double arg)
	{
		offset += opcode.Size + 8;
		ilgen.Emit(opcode, arg);
	}
d137 5
a141 5
	internal void Emit(OpCode opcode, FieldInfo field)
	{
		offset += opcode.Size + 4;
		ilgen.Emit(opcode, field);
	}
d143 5
a147 5
	internal void Emit(OpCode opcode, short arg)
	{
		offset += opcode.Size + 2;
		ilgen.Emit(opcode, arg);
	}
d149 5
a153 5
	internal void Emit(OpCode opcode, int arg)
	{
		offset += opcode.Size + 4;
		ilgen.Emit(opcode, arg);
	}
d155 5
a159 5
	internal void Emit(OpCode opcode, long arg)
	{
		offset += opcode.Size + 8;
		ilgen.Emit(opcode, arg);
	}
d161 1
a161 5
	internal void Emit(OpCode opcode, Label label)
	{
		offset += opcode.Size;
		ilgen.Emit(opcode, label);
		switch(opcode.OperandType)
d163 13
a175 8
			case OperandType.InlineBrTarget:
				offset += 4;
				break;
			case OperandType.ShortInlineBrTarget:
				offset += 1;
				break;
			default:
				throw new NotImplementedException();
a176 1
	}
d178 5
a182 5
	internal void Emit(OpCode opcode, Label[] labels)
	{
		offset += 5 + labels.Length * 4;
		ilgen.Emit(opcode, labels);
	}
d184 1
a184 5
	internal void Emit(OpCode opcode, LocalBuilder local)
	{
		ilgen.Emit(opcode, local);
		int index = locals.IndexOf(local);
		if(index < 4 && opcode.Value != OpCodes.Ldloca.Value && opcode.Value != OpCodes.Ldloca_S.Value)
d186 14
a199 1
			offset += 1;
d201 2
a202 1
		else if(index < 256)
d204 2
a205 1
			offset += 2;
d207 2
a208 1
		else
d210 2
a211 1
			offset += 4;
a212 1
	}
d214 6
a219 5
	internal void Emit(OpCode opcode, MethodInfo meth)
	{
		offset += opcode.Size + 4;
		ilgen.Emit(opcode, meth);
	}
d221 5
a225 5
	internal void Emit(OpCode opcode, sbyte arg)
	{
		offset += opcode.Size + 1;
		ilgen.Emit(opcode, arg);
	}
d227 5
a231 6
	internal void Emit(OpCode opcode, SignatureHelper signature)
	{
		offset += opcode.Size;
		ilgen.Emit(opcode, signature);
		throw new NotImplementedException();
	}
d233 5
a237 5
	internal void Emit(OpCode opcode, float arg)
	{
		offset += opcode.Size + 4;
		ilgen.Emit(opcode, arg);
	}
d239 6
a244 5
	internal void Emit(OpCode opcode, string arg)
	{
		offset += opcode.Size + 4;
		ilgen.Emit(opcode, arg);
	}
d246 5
a250 5
	internal void Emit(OpCode opcode, Type cls)
	{
		offset += opcode.Size + 4;
		ilgen.Emit(opcode, cls);
	}
d252 5
a256 6
	internal void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)
	{
		offset += opcode.Size;
		ilgen.EmitCall(opcode, methodInfo, optionalParameterTypes);
		throw new NotImplementedException();
	}
d258 5
a262 5
	internal void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
	{
		offset += 5;
		ilgen.EmitCalli(opcode, unmanagedCallConv, returnType, parameterTypes);
	}
d264 5
a268 5
	internal void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
	{
		offset += 5;
		ilgen.EmitCalli(opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes);
	}
d270 5
a274 5
	internal void EmitWriteLine(FieldInfo fld)
	{
		ilgen.EmitWriteLine(fld);
		throw new NotImplementedException();
	}
d276 1
a276 15
	internal void EmitWriteLine(LocalBuilder localBuilder)
	{
		ilgen.EmitWriteLine(localBuilder);
		throw new NotImplementedException();
	}

	internal void EmitWriteLine(string value)
	{
		offset += 10;
		ilgen.EmitWriteLine(value);
	}

	internal void EndExceptionBlock()
	{
		if(inFinally)
d278 10
a287 1
			offset += 1;
d289 2
a290 1
		else
d292 1
a292 1
			offset += 5;
a293 3
		inFinally = (bool)exceptionStack.Pop();
		ilgen.EndExceptionBlock();
	}
d295 2
a296 7
	internal void EndScope()
	{
		ilgen.EndScope();
	}

	internal void MarkLabel(Label loc)
	{
d300 2
a301 2
		ilgen.MarkLabel(loc);
	}
d303 4
a306 4
	internal void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn)
	{
		ilgen.MarkSequencePoint(document, startLine, startColumn, endLine, endColumn);
	}
d308 5
a312 5
	internal void ThrowException(Type excType)
	{
		offset += 6;
		ilgen.ThrowException(excType);
	}
d314 4
a317 4
	internal void UsingNamespace(string usingNamespace)
	{
		ilgen.UsingNamespace(usingNamespace);
	}
d319 1
a319 3
	internal void SetLineNumber(ushort line)
	{
		if(linenums == null)
d321 6
a326 1
			linenums = new System.IO.MemoryStream();
a327 3
		IKVM.Attributes.LineNumberTableAttribute.WritePackedInteger(linenums, (uint)offset);
		IKVM.Attributes.LineNumberTableAttribute.WritePackedInteger(linenums, line);
	}
d329 1
a329 3
	internal void EmitLineNumberTable(MethodBase mb)
	{
		if(!IKVM.Internal.JVM.NoStackTraceInfo && linenums != null)
d331 4
a334 1
			AttributeHelper.SetLineNumberTable(mb, linenums.ToArray());
a335 1
	}
d337 2
a338 2
	internal void Finish()
	{
d346 1
a347 1
}
a348 2
namespace IKVM.Internal
{
@


1.7
log
@*** empty log message ***
@
text
@d178 1
a178 1
		offset += opcode.Size;
a179 1
		throw new NotImplementedException();
@


1.6
log
@*** empty log message ***
@
text
@d38 1
a38 1
	private ArrayList linenums;
d322 1
a322 1
			linenums = new ArrayList();
d324 2
a325 2
		linenums.Add((ushort)offset);
		linenums.Add(line);
d332 1
a332 1
			AttributeHelper.SetLineNumberTable(mb, (ushort[])linenums.ToArray(typeof(ushort)));
@


1.5
log
@*** empty log message ***
@
text
@d39 3
d104 5
a108 1
		return ilgen.DefineLabel();
d296 3
d335 11
@


1.4
log
@*** empty log message ***
@
text
@d25 1
d28 298
d331 1
a331 1
		internal abstract void Emit(ILGenerator ilgen);
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002 Jeroen Frijters
a26 2
using System.Diagnostics;
using IKVM.Runtime;
a31 37
		public static readonly CodeEmitter Nop = new OpCodeEmitter(OpCodes.Nop);
		public static readonly CodeEmitter Pop = new OpCodeEmitter(OpCodes.Pop);
		public static readonly CodeEmitter Volatile = new OpCodeEmitter(OpCodes.Volatile);
		public static readonly CodeEmitter InternalError = new InternalErrorEmitter();

		private delegate void CodeEmitterDelegate(ILGenerator ilgen);

		private class DelegateCodeEmitter : CodeEmitter
		{
			private CodeEmitterDelegate del;

			internal DelegateCodeEmitter(CodeEmitterDelegate del)
			{
				this.del = del;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				del(ilgen);
			}
		}

		internal static CodeEmitter WrapCall(MethodWrapper wrapper)
		{
			return new DelegateCodeEmitter(new CodeEmitterDelegate(wrapper.EmitCall));
		}

		internal static CodeEmitter WrapCallvirt(MethodWrapper wrapper)
		{
			return new DelegateCodeEmitter(new CodeEmitterDelegate(wrapper.EmitCallvirt));
		}

		internal static CodeEmitter WrapNewobj(MethodWrapper wrapper)
		{
			return new DelegateCodeEmitter(new CodeEmitterDelegate(wrapper.EmitNewobj));
		}

a32 415

		private class InternalErrorEmitter : CodeEmitter
		{
			internal InternalErrorEmitter()
			{
			}

			internal override void Emit(ILGenerator ilgen)
			{
				throw new InvalidOperationException();
			}
		}

		private class ChainCodeEmitter : CodeEmitter
		{
			private CodeEmitter left;
			private CodeEmitter right;

			internal ChainCodeEmitter(CodeEmitter left, CodeEmitter right)
			{
				this.left = left;
				this.right = right;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				left.Emit(ilgen);
				right.Emit(ilgen);
			}
		}

		public static CodeEmitter operator+(CodeEmitter left, CodeEmitter right)
		{
			if(left == null)
			{
				return right;
			}
			return new ChainCodeEmitter(left, right);
		}

		private class MethodInfoCodeEmitter : CodeEmitter
		{
			private OpCode opcode;
			private MethodInfo mi;

			internal MethodInfoCodeEmitter(OpCode opcode, MethodInfo mi)
			{
				this.opcode = opcode;
				this.mi = mi;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode, mi);
			}
		}

		internal static CodeEmitter Create(OpCode opcode, MethodInfo mi)
		{
			Debug.Assert(mi != null);
			return new MethodInfoCodeEmitter(opcode, mi);
		}

		internal static CodeEmitter Create(OpCode opcode, MethodBase mb)
		{
			Debug.Assert(mb != null);
			if(mb is MethodInfo)
			{
				return new MethodInfoCodeEmitter(opcode, (MethodInfo)mb);
			}
			else
			{
				return new ConstructorInfoCodeEmitter(opcode, (ConstructorInfo)mb);
			}
		}

		private class ConstructorInfoCodeEmitter : CodeEmitter
		{
			private OpCode opcode;
			private ConstructorInfo ci;

			internal ConstructorInfoCodeEmitter(OpCode opcode, ConstructorInfo ci)
			{
				this.opcode = opcode;
				this.ci = ci;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode, ci);
			}
		}

		internal static CodeEmitter Create(OpCode opcode, ConstructorInfo ci)
		{
			Debug.Assert(ci != null);
			return new ConstructorInfoCodeEmitter(opcode, ci);
		}

		private class FieldInfoCodeEmitter : CodeEmitter
		{
			private OpCode opcode;
			private FieldInfo fi;

			internal FieldInfoCodeEmitter(OpCode opcode, FieldInfo fi)
			{
				this.opcode = opcode;
				this.fi = fi;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode, fi);
			}
		}

		internal static CodeEmitter Create(OpCode opcode, FieldInfo fi)
		{
			Debug.Assert(fi != null);
			Debug.Assert(!fi.IsLiteral);
			return new FieldInfoCodeEmitter(opcode, fi);
		}

		internal static CodeEmitter CreateLoadConstantField(FieldInfo field)
		{
			// NOTE the ReflectionOnConstant bug is also a problem when we're not
			// statically compiling, but the warnings are too intrusive
			// TODO if we ever get a pedantic mode, we should enable this warning at
			// runtime as well
			if(JVM.IsStaticCompiler)
			{
				ReflectionOnConstant.IssueWarning(field);
			}
			return CreateLoadConstant(field.GetValue(null));
		}

		internal static CodeEmitter CreateLoadConstant(object constant)
		{
			if(constant == null)
			{
				return new CodeEmitter.OpCodeEmitter(OpCodes.Ldnull);
			}
			else if(constant is int || 
				constant is short || constant is ushort ||
				constant is byte || constant is sbyte ||
				constant is char ||
				constant is bool)
			{
				return CodeEmitter.Create(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
			}
			else if(constant is uint)
			{
				return CodeEmitter.Create(OpCodes.Ldc_I4, unchecked((int)((IConvertible)constant).ToUInt32(null)));
			}
			else if(constant is string)
			{
				return CodeEmitter.Create(OpCodes.Ldstr, (string)constant);
			}
			else if(constant is float)
			{
				return CodeEmitter.Create(OpCodes.Ldc_R4, (float)constant);
			}
			else if(constant is double)
			{
				return CodeEmitter.Create(OpCodes.Ldc_R8, (double)constant);
			}
			else if(constant is long)
			{
				return CodeEmitter.Create(OpCodes.Ldc_I8, (long)constant);
			}
			else if(constant is ulong)
			{
				return CodeEmitter.Create(OpCodes.Ldc_I8, unchecked((long)(ulong)constant));
			}
			else if(constant is Enum)
			{
				Type underlying = Enum.GetUnderlyingType(constant.GetType());
				if(underlying == typeof(long))
				{
					return CodeEmitter.Create(OpCodes.Ldc_I8, ((IConvertible)constant).ToInt64(null));
				}
				if(underlying == typeof(ulong))
				{
					return CodeEmitter.Create(OpCodes.Ldc_I8, unchecked((long)((IConvertible)constant).ToUInt64(null)));
				}
				else if(underlying == typeof(uint))
				{
					return CodeEmitter.Create(OpCodes.Ldc_I4, unchecked((int)((IConvertible)constant).ToUInt32(null)));
				}
				else
				{
					return CodeEmitter.Create(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
				}
			}
			else
			{
				throw new NotImplementedException(constant.GetType().FullName);
			}
		}

		private class EmitUnboxCallCodeEmitter : CodeEmitter
		{
			private TypeWrapper wrapper;

			internal EmitUnboxCallCodeEmitter(TypeWrapper wrapper)
			{
				this.wrapper = wrapper;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				wrapper.EmitUnbox(ilgen);
			}
		}

		internal static CodeEmitter CreateEmitUnboxCall(TypeWrapper wrapper)
		{
			return new EmitUnboxCallCodeEmitter(wrapper);
		}

		private class EmitBoxCallCodeEmitter : CodeEmitter
		{
			private TypeWrapper wrapper;

			internal EmitBoxCallCodeEmitter(TypeWrapper wrapper)
			{
				this.wrapper = wrapper;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				wrapper.EmitBox(ilgen);
			}
		}

		internal static CodeEmitter CreateEmitBoxCall(TypeWrapper wrapper)
		{
			return new EmitBoxCallCodeEmitter(wrapper);
		}

		private class OpCodeEmitter : CodeEmitter
		{
			private OpCode opcode;

			internal OpCodeEmitter(OpCode opcode)
			{
				this.opcode = opcode;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode);
			}
		}

		private class TypeCodeEmitter : CodeEmitter
		{
			private OpCode opcode;
			private Type type;

			internal TypeCodeEmitter(OpCode opcode, Type type)
			{
				this.opcode = opcode;
				this.type = type;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode, type);
			}
		}

		internal static CodeEmitter Create(OpCode opcode, Type type)
		{
			return new TypeCodeEmitter(opcode, type);
		}

		private class IntCodeEmitter : CodeEmitter
		{
			private OpCode opcode;
			private int i;

			internal IntCodeEmitter(OpCode opcode, int i)
			{
				this.opcode = opcode;
				this.i = i;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode, i);
			}
		}

		internal static CodeEmitter Create(OpCode opcode, int i)
		{
			return new IntCodeEmitter(opcode, i);
		}

		private class FloatCodeEmitter : CodeEmitter
		{
			private OpCode opcode;
			private float f;

			internal FloatCodeEmitter(OpCode opcode, float f)
			{
				this.opcode = opcode;
				this.f = f;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode, f);
			}
		}

		internal static CodeEmitter Create(OpCode opcode, float f)
		{
			return new FloatCodeEmitter(opcode, f);
		}

		private class DoubleCodeEmitter : CodeEmitter
		{
			private OpCode opcode;
			private double d;

			internal DoubleCodeEmitter(OpCode opcode, double d)
			{
				this.opcode = opcode;
				this.d = d;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode, d);
			}
		}

		internal static CodeEmitter Create(OpCode opcode, double d)
		{
			return new DoubleCodeEmitter(opcode, d);
		}

		private class StringCodeEmitter : CodeEmitter
		{
			private OpCode opcode;
			private string s;

			internal StringCodeEmitter(OpCode opcode, string s)
			{
				this.opcode = opcode;
				this.s = s;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode, s);
			}
		}

		internal static CodeEmitter Create(OpCode opcode, string s)
		{
			return new StringCodeEmitter(opcode, s);
		}

		private class LongCodeEmitter : CodeEmitter
		{
			private OpCode opcode;
			private long l;

			internal LongCodeEmitter(OpCode opcode, long l)
			{
				this.opcode = opcode;
				this.l = l;
			}

			internal override void Emit(ILGenerator ilgen)
			{
				ilgen.Emit(opcode, l);
			}
		}

		internal static CodeEmitter Create(OpCode opcode, long l)
		{
			return new LongCodeEmitter(opcode, l);
		}
	}

	class ReturnCastEmitter : CodeEmitter
	{
		private TypeWrapper type;

		internal ReturnCastEmitter(TypeWrapper type)
		{
			this.type = type;
		}

		internal override void Emit(ILGenerator ilgen)
		{
			if(type.IsGhost)
			{
				LocalBuilder local1 = ilgen.DeclareLocal(type.TypeAsLocalOrStackType);
				ilgen.Emit(OpCodes.Stloc, local1);
				LocalBuilder local2 = ilgen.DeclareLocal(type.TypeAsParameterType);
				ilgen.Emit(OpCodes.Ldloca, local2);
				ilgen.Emit(OpCodes.Ldloc, local1);
				ilgen.Emit(OpCodes.Stfld, type.GhostRefField);
				ilgen.Emit(OpCodes.Ldloca, local2);
				ilgen.Emit(OpCodes.Ldobj, type.TypeAsParameterType);
			}
			else if(type.TypeAsParameterType != typeof(object))
			{
				ilgen.Emit(OpCodes.Castclass, type.TypeAsParameterType);
			}
		}
@


1.2
log
@*** empty log message ***
@
text
@d28 1
d30 1
a30 1
public abstract class CodeEmitter
d32 8
a39 4
	public static readonly CodeEmitter Nop = new OpCodeEmitter(OpCodes.Nop);
	public static readonly CodeEmitter Pop = new OpCodeEmitter(OpCodes.Pop);
	public static readonly CodeEmitter Volatile = new OpCodeEmitter(OpCodes.Volatile);
	public static readonly CodeEmitter InternalError = new InternalErrorEmitter();
d41 3
a43 1
	private delegate void CodeEmitterDelegate(ILGenerator ilgen);
d45 4
a48 3
	private class DelegateCodeEmitter : CodeEmitter
	{
		private CodeEmitterDelegate del;
d50 4
a53 3
		internal DelegateCodeEmitter(CodeEmitterDelegate del)
		{
			this.del = del;
d56 1
a56 1
		internal override void Emit(ILGenerator ilgen)
d58 1
a58 1
			del(ilgen);
a59 1
	}
d61 1
a61 20
	internal static CodeEmitter WrapCall(MethodWrapper wrapper)
	{
		return new DelegateCodeEmitter(new CodeEmitterDelegate(wrapper.EmitCall));
	}

	internal static CodeEmitter WrapCallvirt(MethodWrapper wrapper)
	{
		return new DelegateCodeEmitter(new CodeEmitterDelegate(wrapper.EmitCallvirt));
	}

	internal static CodeEmitter WrapNewobj(MethodWrapper wrapper)
	{
		return new DelegateCodeEmitter(new CodeEmitterDelegate(wrapper.EmitNewobj));
	}

	internal abstract void Emit(ILGenerator ilgen);

	private class InternalErrorEmitter : CodeEmitter
	{
		internal InternalErrorEmitter()
d63 1
d66 1
a66 1
		internal override void Emit(ILGenerator ilgen)
d68 1
a68 1
			throw new InvalidOperationException();
a69 1
	}
d71 1
a71 4
	private class ChainCodeEmitter : CodeEmitter
	{
		private CodeEmitter left;
		private CodeEmitter right;
d73 1
a73 1
		internal ChainCodeEmitter(CodeEmitter left, CodeEmitter right)
d75 8
a82 2
			this.left = left;
			this.right = right;
d85 1
a85 1
		internal override void Emit(ILGenerator ilgen)
d87 8
a94 4
			left.Emit(ilgen);
			right.Emit(ilgen);
		}
	}
d96 5
a100 5
	public static CodeEmitter operator+(CodeEmitter left, CodeEmitter right)
	{
		if(left == null)
		{
			return right;
a101 2
		return new ChainCodeEmitter(left, right);
	}
d103 1
a103 6
	private class MethodInfoCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private MethodInfo mi;

		internal MethodInfoCodeEmitter(OpCode opcode, MethodInfo mi)
d105 5
a109 2
			this.opcode = opcode;
			this.mi = mi;
d112 1
a112 1
		internal override void Emit(ILGenerator ilgen)
d114 2
a115 3
			ilgen.Emit(opcode, mi);
		}
	}
d117 5
a121 5
	internal static CodeEmitter Create(OpCode opcode, MethodInfo mi)
	{
		Debug.Assert(mi != null);
		return new MethodInfoCodeEmitter(opcode, mi);
	}
d123 4
a126 6
	internal static CodeEmitter Create(OpCode opcode, MethodBase mb)
	{
		Debug.Assert(mb != null);
		if(mb is MethodInfo)
		{
			return new MethodInfoCodeEmitter(opcode, (MethodInfo)mb);
d128 2
a129 1
		else
d131 2
a132 1
			return new ConstructorInfoCodeEmitter(opcode, (ConstructorInfo)mb);
a133 1
	}
d135 1
a135 6
	private class ConstructorInfoCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private ConstructorInfo ci;

		internal ConstructorInfoCodeEmitter(OpCode opcode, ConstructorInfo ci)
d137 9
a145 2
			this.opcode = opcode;
			this.ci = ci;
d148 1
a148 1
		internal override void Emit(ILGenerator ilgen)
d150 2
a151 3
			ilgen.Emit(opcode, ci);
		}
	}
d153 5
a157 5
	internal static CodeEmitter Create(OpCode opcode, ConstructorInfo ci)
	{
		Debug.Assert(ci != null);
		return new ConstructorInfoCodeEmitter(opcode, ci);
	}
d159 5
a163 4
	private class FieldInfoCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private FieldInfo fi;
d165 1
a165 1
		internal FieldInfoCodeEmitter(OpCode opcode, FieldInfo fi)
d167 2
a168 2
			this.opcode = opcode;
			this.fi = fi;
d171 1
a171 1
		internal override void Emit(ILGenerator ilgen)
d173 2
a174 3
			ilgen.Emit(opcode, fi);
		}
	}
d176 5
a180 6
	internal static CodeEmitter Create(OpCode opcode, FieldInfo fi)
	{
		Debug.Assert(fi != null);
		Debug.Assert(!fi.IsLiteral);
		return new FieldInfoCodeEmitter(opcode, fi);
	}
d182 4
a185 9
	internal static CodeEmitter CreateLoadConstantField(FieldInfo field)
	{
		// NOTE the ReflectionOnConstant bug is also a problem when we're not
		// statically compiling, but the warnings are too intrusive
		// TODO if we ever get a pedantic mode, we should enable this warning at
		// runtime as well
		if(JVM.IsStaticCompiler)
		{
			ReflectionOnConstant.IssueWarning(field);
a186 2
		return CreateLoadConstant(field.GetValue(null));
	}
d188 1
a188 3
	internal static CodeEmitter CreateLoadConstant(object constant)
	{
		if(constant == null)
d190 3
a192 1
			return new CodeEmitter.OpCodeEmitter(OpCodes.Ldnull);
d194 2
a195 5
		else if(constant is int || 
			constant is short || constant is ushort ||
			constant is byte || constant is sbyte ||
			constant is char ||
			constant is bool)
d197 9
a205 1
			return CodeEmitter.Create(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
d207 2
a208 5
		else if(constant is uint)
		{
			return CodeEmitter.Create(OpCodes.Ldc_I4, unchecked((int)((IConvertible)constant).ToUInt32(null)));
		}
		else if(constant is string)
d210 1
a210 22
			return CodeEmitter.Create(OpCodes.Ldstr, (string)constant);
		}
		else if(constant is float)
		{
			return CodeEmitter.Create(OpCodes.Ldc_R4, (float)constant);
		}
		else if(constant is double)
		{
			return CodeEmitter.Create(OpCodes.Ldc_R8, (double)constant);
		}
		else if(constant is long)
		{
			return CodeEmitter.Create(OpCodes.Ldc_I8, (long)constant);
		}
		else if(constant is ulong)
		{
			return CodeEmitter.Create(OpCodes.Ldc_I8, unchecked((long)(ulong)constant));
		}
		else if(constant is Enum)
		{
			Type underlying = Enum.GetUnderlyingType(constant.GetType());
			if(underlying == typeof(long))
d212 1
a212 1
				return CodeEmitter.Create(OpCodes.Ldc_I8, ((IConvertible)constant).ToInt64(null));
d214 5
a218 1
			if(underlying == typeof(ulong))
d220 1
a220 1
				return CodeEmitter.Create(OpCodes.Ldc_I8, unchecked((long)((IConvertible)constant).ToUInt64(null)));
d222 1
a222 1
			else if(underlying == typeof(uint))
d226 40
d268 1
a268 1
				return CodeEmitter.Create(OpCodes.Ldc_I4, ((IConvertible)constant).ToInt32(null));
d271 2
a272 1
		else
d274 1
a274 3
			throw new NotImplementedException(constant.GetType().FullName);
		}
	}
d276 4
a279 3
	private class EmitUnboxCallCodeEmitter : CodeEmitter
	{
		private TypeWrapper wrapper;
d281 4
a284 3
		internal EmitUnboxCallCodeEmitter(TypeWrapper wrapper)
		{
			this.wrapper = wrapper;
d287 1
a287 1
		internal override void Emit(ILGenerator ilgen)
d289 1
a289 1
			wrapper.EmitUnbox(ilgen);
a290 1
	}
d292 3
a294 4
	internal static CodeEmitter CreateEmitUnboxCall(TypeWrapper wrapper)
	{
		return new EmitUnboxCallCodeEmitter(wrapper);
	}
d296 4
a299 3
	private class EmitBoxCallCodeEmitter : CodeEmitter
	{
		private TypeWrapper wrapper;
d301 4
a304 3
		internal EmitBoxCallCodeEmitter(TypeWrapper wrapper)
		{
			this.wrapper = wrapper;
d307 1
a307 1
		internal override void Emit(ILGenerator ilgen)
d309 1
a309 1
			wrapper.EmitBox(ilgen);
a310 1
	}
d312 3
a314 4
	internal static CodeEmitter CreateEmitBoxCall(TypeWrapper wrapper)
	{
		return new EmitBoxCallCodeEmitter(wrapper);
	}
d316 4
a319 3
	private class OpCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
d321 4
a324 3
		internal OpCodeEmitter(OpCode opcode)
		{
			this.opcode = opcode;
d327 1
a327 1
		internal override void Emit(ILGenerator ilgen)
d329 2
a330 3
			ilgen.Emit(opcode);
		}
	}
d332 5
a336 4
	private class TypeCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private Type type;
d338 4
a341 4
		internal TypeCodeEmitter(OpCode opcode, Type type)
		{
			this.opcode = opcode;
			this.type = type;
d344 1
a344 1
		internal override void Emit(ILGenerator ilgen)
d346 1
a346 1
			ilgen.Emit(opcode, type);
a347 1
	}
d349 4
a352 4
	internal static CodeEmitter Create(OpCode opcode, Type type)
	{
		return new TypeCodeEmitter(opcode, type);
	}
d354 5
a358 4
	private class IntCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private int i;
d360 4
a363 4
		internal IntCodeEmitter(OpCode opcode, int i)
		{
			this.opcode = opcode;
			this.i = i;
d366 1
a366 1
		internal override void Emit(ILGenerator ilgen)
d368 1
a368 1
			ilgen.Emit(opcode, i);
a369 1
	}
d371 4
a374 4
	internal static CodeEmitter Create(OpCode opcode, int i)
	{
		return new IntCodeEmitter(opcode, i);
	}
d376 5
a380 4
	private class FloatCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private float f;
d382 4
a385 4
		internal FloatCodeEmitter(OpCode opcode, float f)
		{
			this.opcode = opcode;
			this.f = f;
d388 1
a388 1
		internal override void Emit(ILGenerator ilgen)
d390 1
a390 1
			ilgen.Emit(opcode, f);
a391 1
	}
d393 4
a396 4
	internal static CodeEmitter Create(OpCode opcode, float f)
	{
		return new FloatCodeEmitter(opcode, f);
	}
d398 5
a402 4
	private class DoubleCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private double d;
d404 4
a407 4
		internal DoubleCodeEmitter(OpCode opcode, double d)
		{
			this.opcode = opcode;
			this.d = d;
d410 1
a410 1
		internal override void Emit(ILGenerator ilgen)
d412 1
a412 1
			ilgen.Emit(opcode, d);
a413 1
	}
d415 4
a418 4
	internal static CodeEmitter Create(OpCode opcode, double d)
	{
		return new DoubleCodeEmitter(opcode, d);
	}
d420 5
a424 4
	private class StringCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private string s;
d426 4
a429 4
		internal StringCodeEmitter(OpCode opcode, string s)
		{
			this.opcode = opcode;
			this.s = s;
d432 1
a432 1
		internal override void Emit(ILGenerator ilgen)
d434 1
a434 1
			ilgen.Emit(opcode, s);
a435 1
	}
d437 4
a440 4
	internal static CodeEmitter Create(OpCode opcode, string s)
	{
		return new StringCodeEmitter(opcode, s);
	}
d442 5
a446 4
	private class LongCodeEmitter : CodeEmitter
	{
		private OpCode opcode;
		private long l;
d448 4
a451 4
		internal LongCodeEmitter(OpCode opcode, long l)
		{
			this.opcode = opcode;
			this.l = l;
d454 1
a454 1
		internal override void Emit(ILGenerator ilgen)
d456 1
a456 1
			ilgen.Emit(opcode, l);
d460 1
a460 11
	internal static CodeEmitter Create(OpCode opcode, long l)
	{
		return new LongCodeEmitter(opcode, l);
	}
}

class ReturnCastEmitter : CodeEmitter
{
	private TypeWrapper type;

	internal ReturnCastEmitter(TypeWrapper type)
d462 1
a462 2
		this.type = type;
	}
d464 1
a464 3
	internal override void Emit(ILGenerator ilgen)
	{
		if(type.IsGhost)
d466 1
a466 8
			LocalBuilder local1 = ilgen.DeclareLocal(type.TypeAsLocalOrStackType);
			ilgen.Emit(OpCodes.Stloc, local1);
			LocalBuilder local2 = ilgen.DeclareLocal(type.TypeAsParameterType);
			ilgen.Emit(OpCodes.Ldloca, local2);
			ilgen.Emit(OpCodes.Ldloc, local1);
			ilgen.Emit(OpCodes.Stfld, type.GhostRefField);
			ilgen.Emit(OpCodes.Ldloca, local2);
			ilgen.Emit(OpCodes.Ldobj, type.TypeAsParameterType);
d468 2
a469 1
		else if(type.TypeAsParameterType != typeof(object))
d471 15
a485 1
			ilgen.Emit(OpCodes.Castclass, type.TypeAsParameterType);
@


1.1
log
@*** empty log message ***
@
text
@d36 32
@

