head	1.310;
access;
symbols
	v7_3:1.307.0.2
	v7_2_4630_6:1.285.2.1
	v7_2_4630_5:1.285.2.1
	v7_2_4630_4:1.285
	v7_2_4630_3:1.285
	v7_2_4630_2:1.285
	v0_46_0_4:1.252.2.5
	v7_2_4630_1:1.285
	v7_2:1.285.0.2
	v7_1_4532_2:1.282
	v7_1_4532_1:1.282
	v7_1_4532_0:1.282
	v7_1:1.282.0.2
	v7_0_4335_3:1.275.2.1
	v7_0_4335_2:1.275.2.1
	v7_0_4335_1:1.275.2.1
	v0_46_0_2:1.252.2.5
	v7_0_4335_0:1.275
	v7_0:1.275.0.2
	v0_40_0_6:1.136.2.2
	v0_40_0_5:1.136.2.1
	v0_46_0_1:1.252
	v0_46_0_0:1.252
	v0_46:1.252.0.2
	v0_36_0_14:1.53.2.10
	v0_44_0_6:1.209.2.4
	v0_44_0_5:1.209.2.4
	v0_44_0_4:1.209.2.4
	v0_44_0_3:1.209.2.4
	v0_44_0_2:1.209.2.1
	v0_42_0_7:1.167.2.6
	v0_44_0_1:1.209
	v0_44_0_0:1.209
	v0_44:1.209.0.2
	v0_42_0_6:1.167.2.5
	v0_42_0_5:1.167.2.2
	v0_42_0_4:1.167.2.2
	v0_42_0_3:1.167.2.2
	v0_42_0_2:1.167.2.1
	v0_42_0_1:1.167.2.1
	v0_42_0_0:1.167.2.1
	v0_42:1.167.0.2
	v0_40_0_3:1.136
	v0_40_0_2:1.136
	v0_40_0_1:1.136
	v0_40_0_0:1.136
	v0_40:1.136.0.2
	v0_36_0_13:1.53.2.10
	v0_38_0_1:1.113.2.2
	v0_38_0_0:1.113.2.1
	v0_38:1.113.0.2
	v0_36_0_9:1.53.2.7
	v0_36_0_7:1.53.2.5
	v0_36_0_5:1.53.2.4
	v0_36_0_4:1.53.2.3
	v0_36_0_3:1.53.2.2
	v0_36_0_2:1.53.2.1
	v0_36_0_1:1.53.2.1
	v0_36_0_0:1.53
	v0_36:1.53.0.2;
locks; strict;
comment	@ * @;


1.310
date	2013.03.20.14.03.28;	author jfrijters;	state dead;
branches;
next	1.309;

1.309
date	2013.03.20.11.24.51;	author jfrijters;	state Exp;
branches;
next	1.308;

1.308
date	2013.03.20.09.11.21;	author jfrijters;	state Exp;
branches;
next	1.307;

1.307
date	2013.02.28.07.43.17;	author jfrijters;	state Exp;
branches
	1.307.2.1;
next	1.306;

1.306
date	2013.02.26.12.02.05;	author jfrijters;	state Exp;
branches;
next	1.305;

1.305
date	2013.02.24.13.03.59;	author jfrijters;	state Exp;
branches;
next	1.304;

1.304
date	2013.02.23.12.41.02;	author jfrijters;	state Exp;
branches;
next	1.303;

1.303
date	2013.02.23.12.19.30;	author jfrijters;	state Exp;
branches;
next	1.302;

1.302
date	2013.02.23.08.27.18;	author jfrijters;	state Exp;
branches;
next	1.301;

1.301
date	2013.02.21.16.56.09;	author jfrijters;	state Exp;
branches;
next	1.300;

1.300
date	2013.02.21.15.20.10;	author jfrijters;	state Exp;
branches;
next	1.299;

1.299
date	2013.02.21.13.49.03;	author jfrijters;	state Exp;
branches;
next	1.298;

1.298
date	2013.02.19.07.17.50;	author jfrijters;	state Exp;
branches;
next	1.297;

1.297
date	2013.02.17.09.35.26;	author jfrijters;	state Exp;
branches;
next	1.296;

1.296
date	2013.02.12.11.22.27;	author jfrijters;	state Exp;
branches;
next	1.295;

1.295
date	2013.02.12.11.09.16;	author jfrijters;	state Exp;
branches;
next	1.294;

1.294
date	2013.02.12.10.42.07;	author jfrijters;	state Exp;
branches;
next	1.293;

1.293
date	2013.02.05.14.54.20;	author jfrijters;	state Exp;
branches;
next	1.292;

1.292
date	2013.01.31.12.03.11;	author jfrijters;	state Exp;
branches;
next	1.291;

1.291
date	2013.01.31.10.59.10;	author jfrijters;	state Exp;
branches;
next	1.290;

1.290
date	2013.01.31.09.12.20;	author jfrijters;	state Exp;
branches;
next	1.289;

1.289
date	2013.01.30.17.39.46;	author jfrijters;	state Exp;
branches;
next	1.288;

1.288
date	2012.11.19.09.59.24;	author jfrijters;	state Exp;
branches;
next	1.287;

1.287
date	2012.10.19.19.25.33;	author jfrijters;	state Exp;
branches;
next	1.286;

1.286
date	2012.09.21.11.23.09;	author jfrijters;	state Exp;
branches;
next	1.285;

1.285
date	2012.08.06.12.12.03;	author jfrijters;	state Exp;
branches
	1.285.2.1;
next	1.284;

1.284
date	2012.07.09.06.07.40;	author jfrijters;	state Exp;
branches;
next	1.283;

1.283
date	2012.07.03.14.45.51;	author jfrijters;	state Exp;
branches;
next	1.282;

1.282
date	2012.05.23.10.00.03;	author jfrijters;	state Exp;
branches;
next	1.281;

1.281
date	2012.04.15.14.43.25;	author smallsql;	state Exp;
branches;
next	1.280;

1.280
date	2011.12.15.09.20.18;	author jfrijters;	state Exp;
branches;
next	1.279;

1.279
date	2011.12.08.07.56.10;	author jfrijters;	state Exp;
branches;
next	1.278;

1.278
date	2011.11.30.10.43.46;	author natl;	state Exp;
branches;
next	1.277;

1.277
date	2011.11.29.13.01.11;	author jfrijters;	state Exp;
branches;
next	1.276;

1.276
date	2011.11.28.08.14.13;	author jfrijters;	state Exp;
branches;
next	1.275;

1.275
date	2011.10.13.11.01.41;	author jfrijters;	state Exp;
branches
	1.275.2.1;
next	1.274;

1.274
date	2011.09.29.09.42.21;	author jfrijters;	state Exp;
branches;
next	1.273;

1.273
date	2011.09.29.05.54.00;	author jfrijters;	state Exp;
branches;
next	1.272;

1.272
date	2011.09.15.10.23.45;	author jfrijters;	state Exp;
branches;
next	1.271;

1.271
date	2011.09.02.08.16.21;	author jfrijters;	state Exp;
branches;
next	1.270;

1.270
date	2011.09.02.06.07.30;	author jfrijters;	state Exp;
branches;
next	1.269;

1.269
date	2011.09.01.07.53.58;	author jfrijters;	state Exp;
branches;
next	1.268;

1.268
date	2011.08.30.10.29.29;	author jfrijters;	state Exp;
branches;
next	1.267;

1.267
date	2011.08.25.14.31.55;	author jfrijters;	state Exp;
branches;
next	1.266;

1.266
date	2011.08.11.11.34.55;	author jfrijters;	state Exp;
branches;
next	1.265;

1.265
date	2011.07.25.23.11.10;	author jfrijters;	state Exp;
branches;
next	1.264;

1.264
date	2011.07.16.19.44.20;	author smallsql;	state Exp;
branches;
next	1.263;

1.263
date	2011.07.15.09.05.27;	author jfrijters;	state Exp;
branches;
next	1.262;

1.262
date	2011.07.12.05.58.28;	author jfrijters;	state Exp;
branches;
next	1.261;

1.261
date	2011.07.07.11.32.18;	author jfrijters;	state Exp;
branches;
next	1.260;

1.260
date	2011.07.07.10.03.36;	author jfrijters;	state Exp;
branches;
next	1.259;

1.259
date	2011.07.01.14.03.41;	author jfrijters;	state Exp;
branches;
next	1.258;

1.258
date	2011.07.01.06.02.19;	author jfrijters;	state Exp;
branches;
next	1.257;

1.257
date	2011.06.29.09.14.50;	author jfrijters;	state Exp;
branches;
next	1.256;

1.256
date	2011.06.19.10.49.01;	author jfrijters;	state Exp;
branches;
next	1.255;

1.255
date	2011.06.17.11.33.06;	author jfrijters;	state Exp;
branches;
next	1.254;

1.254
date	2011.05.12.08.08.09;	author jfrijters;	state Exp;
branches;
next	1.253;

1.253
date	2011.03.29.12.57.48;	author jfrijters;	state Exp;
branches;
next	1.252;

1.252
date	2010.12.28.09.03.38;	author jfrijters;	state Exp;
branches
	1.252.2.1;
next	1.251;

1.251
date	2010.12.28.08.42.10;	author jfrijters;	state Exp;
branches;
next	1.250;

1.250
date	2010.12.10.06.31.08;	author jfrijters;	state Exp;
branches;
next	1.249;

1.249
date	2010.12.10.05.27.07;	author jfrijters;	state Exp;
branches;
next	1.248;

1.248
date	2010.12.10.05.19.00;	author jfrijters;	state Exp;
branches;
next	1.247;

1.247
date	2010.12.10.05.09.46;	author jfrijters;	state Exp;
branches;
next	1.246;

1.246
date	2010.12.09.14.15.25;	author jfrijters;	state Exp;
branches;
next	1.245;

1.245
date	2010.12.09.13.53.50;	author jfrijters;	state Exp;
branches;
next	1.244;

1.244
date	2010.12.08.08.04.34;	author jfrijters;	state Exp;
branches;
next	1.243;

1.243
date	2010.12.06.08.00.22;	author jfrijters;	state Exp;
branches;
next	1.242;

1.242
date	2010.12.03.15.14.20;	author smallsql;	state Exp;
branches;
next	1.241;

1.241
date	2010.11.25.08.52.11;	author jfrijters;	state Exp;
branches;
next	1.240;

1.240
date	2010.11.24.15.26.47;	author jfrijters;	state Exp;
branches;
next	1.239;

1.239
date	2010.11.24.12.58.11;	author jfrijters;	state Exp;
branches;
next	1.238;

1.238
date	2010.11.24.07.06.02;	author jfrijters;	state Exp;
branches;
next	1.237;

1.237
date	2010.11.24.06.41.25;	author jfrijters;	state Exp;
branches;
next	1.236;

1.236
date	2010.11.24.06.38.14;	author jfrijters;	state Exp;
branches;
next	1.235;

1.235
date	2010.11.23.09.39.49;	author jfrijters;	state Exp;
branches;
next	1.234;

1.234
date	2010.11.23.08.08.16;	author jfrijters;	state Exp;
branches;
next	1.233;

1.233
date	2010.11.23.07.30.30;	author jfrijters;	state Exp;
branches;
next	1.232;

1.232
date	2010.11.18.11.12.20;	author jfrijters;	state Exp;
branches;
next	1.231;

1.231
date	2010.10.11.05.46.28;	author jfrijters;	state Exp;
branches;
next	1.230;

1.230
date	2010.09.30.04.03.33;	author jfrijters;	state Exp;
branches;
next	1.229;

1.229
date	2010.09.29.07.21.51;	author jfrijters;	state Exp;
branches;
next	1.228;

1.228
date	2010.09.21.07.17.29;	author jfrijters;	state Exp;
branches;
next	1.227;

1.227
date	2010.09.09.06.55.31;	author jfrijters;	state Exp;
branches;
next	1.226;

1.226
date	2010.09.09.06.31.30;	author jfrijters;	state Exp;
branches;
next	1.225;

1.225
date	2010.09.09.06.30.08;	author jfrijters;	state Exp;
branches;
next	1.224;

1.224
date	2010.09.09.06.27.14;	author jfrijters;	state Exp;
branches;
next	1.223;

1.223
date	2010.09.09.06.24.13;	author jfrijters;	state Exp;
branches;
next	1.222;

1.222
date	2010.09.09.06.21.23;	author jfrijters;	state Exp;
branches;
next	1.221;

1.221
date	2010.09.09.06.19.51;	author jfrijters;	state Exp;
branches;
next	1.220;

1.220
date	2010.09.09.06.18.32;	author jfrijters;	state Exp;
branches;
next	1.219;

1.219
date	2010.09.01.06.45.58;	author jfrijters;	state Exp;
branches;
next	1.218;

1.218
date	2010.09.01.06.40.28;	author jfrijters;	state Exp;
branches;
next	1.217;

1.217
date	2010.09.01.06.18.37;	author jfrijters;	state Exp;
branches;
next	1.216;

1.216
date	2010.09.01.06.10.45;	author jfrijters;	state Exp;
branches;
next	1.215;

1.215
date	2010.08.30.10.31.59;	author jfrijters;	state Exp;
branches;
next	1.214;

1.214
date	2010.08.23.13.02.26;	author jfrijters;	state Exp;
branches;
next	1.213;

1.213
date	2010.08.03.14.23.11;	author jfrijters;	state Exp;
branches;
next	1.212;

1.212
date	2010.08.03.14.10.46;	author jfrijters;	state Exp;
branches;
next	1.211;

1.211
date	2010.08.03.12.54.40;	author jfrijters;	state Exp;
branches;
next	1.210;

1.210
date	2010.07.28.12.30.35;	author jfrijters;	state Exp;
branches;
next	1.209;

1.209
date	2010.06.09.12.26.28;	author jfrijters;	state Exp;
branches
	1.209.2.1;
next	1.208;

1.208
date	2010.06.08.12.26.56;	author jfrijters;	state Exp;
branches;
next	1.207;

1.207
date	2010.06.08.12.25.23;	author jfrijters;	state Exp;
branches;
next	1.206;

1.206
date	2010.06.08.12.23.22;	author jfrijters;	state Exp;
branches;
next	1.205;

1.205
date	2010.06.04.13.38.45;	author jfrijters;	state Exp;
branches;
next	1.204;

1.204
date	2010.05.30.06.53.49;	author jfrijters;	state Exp;
branches;
next	1.203;

1.203
date	2010.05.27.16.07.57;	author jfrijters;	state Exp;
branches;
next	1.202;

1.202
date	2010.05.27.15.24.29;	author jfrijters;	state Exp;
branches;
next	1.201;

1.201
date	2010.05.27.11.47.42;	author jfrijters;	state Exp;
branches;
next	1.200;

1.200
date	2010.05.27.10.54.34;	author jfrijters;	state Exp;
branches;
next	1.199;

1.199
date	2010.05.27.09.25.15;	author jfrijters;	state Exp;
branches;
next	1.198;

1.198
date	2010.05.27.09.17.13;	author jfrijters;	state Exp;
branches;
next	1.197;

1.197
date	2010.05.26.13.09.55;	author jfrijters;	state Exp;
branches;
next	1.196;

1.196
date	2010.05.26.10.12.13;	author jfrijters;	state Exp;
branches;
next	1.195;

1.195
date	2010.05.26.10.07.07;	author jfrijters;	state Exp;
branches;
next	1.194;

1.194
date	2010.05.26.09.50.48;	author jfrijters;	state Exp;
branches;
next	1.193;

1.193
date	2010.05.26.05.42.56;	author jfrijters;	state Exp;
branches;
next	1.192;

1.192
date	2010.05.21.04.21.55;	author jfrijters;	state Exp;
branches;
next	1.191;

1.191
date	2010.04.20.05.18.41;	author jfrijters;	state Exp;
branches;
next	1.190;

1.190
date	2010.04.12.07.07.52;	author jfrijters;	state Exp;
branches;
next	1.189;

1.189
date	2010.04.12.06.38.46;	author jfrijters;	state Exp;
branches;
next	1.188;

1.188
date	2010.04.08.13.06.36;	author jfrijters;	state Exp;
branches;
next	1.187;

1.187
date	2010.03.25.07.11.58;	author jfrijters;	state Exp;
branches;
next	1.186;

1.186
date	2010.03.18.13.52.14;	author jfrijters;	state Exp;
branches;
next	1.185;

1.185
date	2010.03.18.13.49.34;	author jfrijters;	state Exp;
branches;
next	1.184;

1.184
date	2010.02.26.13.31.39;	author jfrijters;	state Exp;
branches;
next	1.183;

1.183
date	2010.02.11.09.50.26;	author jfrijters;	state Exp;
branches;
next	1.182;

1.182
date	2010.02.04.05.08.56;	author jfrijters;	state Exp;
branches;
next	1.181;

1.181
date	2010.02.01.19.48.00;	author smallsql;	state Exp;
branches;
next	1.180;

1.180
date	2010.01.30.15.54.38;	author smallsql;	state Exp;
branches;
next	1.179;

1.179
date	2010.01.28.08.05.34;	author jfrijters;	state Exp;
branches;
next	1.178;

1.178
date	2009.12.07.05.27.23;	author jfrijters;	state Exp;
branches;
next	1.177;

1.177
date	2009.12.02.07.49.37;	author jfrijters;	state Exp;
branches;
next	1.176;

1.176
date	2009.11.28.18.51.49;	author smallsql;	state Exp;
branches;
next	1.175;

1.175
date	2009.11.04.05.17.51;	author jfrijters;	state Exp;
branches;
next	1.174;

1.174
date	2009.10.28.11.11.59;	author jfrijters;	state Exp;
branches;
next	1.173;

1.173
date	2009.10.28.05.54.05;	author jfrijters;	state Exp;
branches;
next	1.172;

1.172
date	2009.10.26.05.22.02;	author jfrijters;	state Exp;
branches;
next	1.171;

1.171
date	2009.10.26.05.20.46;	author jfrijters;	state Exp;
branches;
next	1.170;

1.170
date	2009.10.14.15.31.48;	author natl;	state Exp;
branches;
next	1.169;

1.169
date	2009.10.14.13.44.27;	author natl;	state Exp;
branches;
next	1.168;

1.168
date	2009.10.12.04.22.46;	author jfrijters;	state Exp;
branches;
next	1.167;

1.167
date	2009.09.07.04.46.01;	author jfrijters;	state Exp;
branches
	1.167.2.1;
next	1.166;

1.166
date	2009.08.31.05.02.36;	author jfrijters;	state Exp;
branches;
next	1.165;

1.165
date	2009.08.27.14.40.43;	author jfrijters;	state Exp;
branches;
next	1.164;

1.164
date	2009.08.25.04.36.44;	author jfrijters;	state Exp;
branches;
next	1.163;

1.163
date	2009.08.22.00.53.41;	author natl;	state Exp;
branches;
next	1.162;

1.162
date	2009.08.19.13.13.59;	author jfrijters;	state Exp;
branches;
next	1.161;

1.161
date	2009.08.13.07.16.48;	author jfrijters;	state Exp;
branches;
next	1.160;

1.160
date	2009.08.12.18.36.49;	author smallsql;	state Exp;
branches;
next	1.159;

1.159
date	2009.08.11.05.58.46;	author jfrijters;	state Exp;
branches;
next	1.158;

1.158
date	2009.07.29.07.04.44;	author jfrijters;	state Exp;
branches;
next	1.157;

1.157
date	2009.07.16.06.29.32;	author jfrijters;	state Exp;
branches;
next	1.156;

1.156
date	2009.07.03.06.40.52;	author jfrijters;	state Exp;
branches;
next	1.155;

1.155
date	2009.06.27.20.43.42;	author smallsql;	state Exp;
branches;
next	1.154;

1.154
date	2009.06.27.15.42.17;	author smallsql;	state Exp;
branches;
next	1.153;

1.153
date	2009.06.25.09.18.45;	author jfrijters;	state Exp;
branches;
next	1.152;

1.152
date	2009.06.10.04.40.00;	author jfrijters;	state Exp;
branches;
next	1.151;

1.151
date	2009.06.06.12.32.47;	author smallsql;	state Exp;
branches;
next	1.150;

1.150
date	2009.06.02.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.149;

1.149
date	2009.06.02.06.26.42;	author jfrijters;	state Exp;
branches;
next	1.148;

1.148
date	2009.05.31.07.54.26;	author jfrijters;	state Exp;
branches;
next	1.147;

1.147
date	2009.05.31.05.41.14;	author jfrijters;	state Exp;
branches;
next	1.146;

1.146
date	2009.05.29.08.57.33;	author jfrijters;	state Exp;
branches;
next	1.145;

1.145
date	2009.05.24.05.42.20;	author jfrijters;	state Exp;
branches;
next	1.144;

1.144
date	2009.05.22.19.59.24;	author smallsql;	state Exp;
branches;
next	1.143;

1.143
date	2009.05.17.06.16.34;	author jfrijters;	state Exp;
branches;
next	1.142;

1.142
date	2009.05.12.05.54.07;	author jfrijters;	state Exp;
branches;
next	1.141;

1.141
date	2009.05.12.04.30.10;	author jfrijters;	state Exp;
branches;
next	1.140;

1.140
date	2009.05.11.08.31.59;	author jfrijters;	state Exp;
branches;
next	1.139;

1.139
date	2009.05.03.18.44.22;	author smallsql;	state Exp;
branches;
next	1.138;

1.138
date	2009.04.30.19.52.44;	author smallsql;	state Exp;
branches;
next	1.137;

1.137
date	2009.04.17.06.36.01;	author jfrijters;	state Exp;
branches;
next	1.136;

1.136
date	2009.04.06.05.23.04;	author jfrijters;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2009.03.16.05.28.11;	author jfrijters;	state Exp;
branches;
next	1.134;

1.134
date	2009.03.09.09.01.36;	author jfrijters;	state Exp;
branches;
next	1.133;

1.133
date	2009.03.04.13.52.05;	author jfrijters;	state Exp;
branches;
next	1.132;

1.132
date	2009.03.04.10.57.42;	author jfrijters;	state Exp;
branches;
next	1.131;

1.131
date	2009.03.04.08.18.38;	author jfrijters;	state Exp;
branches;
next	1.130;

1.130
date	2009.03.04.06.49.16;	author jfrijters;	state Exp;
branches;
next	1.129;

1.129
date	2009.02.27.05.56.22;	author jfrijters;	state Exp;
branches;
next	1.128;

1.128
date	2009.02.27.05.53.27;	author jfrijters;	state Exp;
branches;
next	1.127;

1.127
date	2009.02.25.05.02.35;	author jfrijters;	state Exp;
branches;
next	1.126;

1.126
date	2009.02.16.05.13.50;	author jfrijters;	state Exp;
branches;
next	1.125;

1.125
date	2009.02.12.06.25.07;	author jfrijters;	state Exp;
branches;
next	1.124;

1.124
date	2009.02.11.05.27.55;	author jfrijters;	state Exp;
branches;
next	1.123;

1.123
date	2009.02.10.15.21.43;	author jfrijters;	state Exp;
branches;
next	1.122;

1.122
date	2009.02.10.07.24.30;	author jfrijters;	state Exp;
branches;
next	1.121;

1.121
date	2009.02.04.07.24.44;	author jfrijters;	state Exp;
branches;
next	1.120;

1.120
date	2009.01.05.06.30.46;	author jfrijters;	state Exp;
branches;
next	1.119;

1.119
date	2009.01.02.10.44.05;	author jfrijters;	state Exp;
branches;
next	1.118;

1.118
date	2009.01.02.08.49.19;	author jfrijters;	state Exp;
branches;
next	1.117;

1.117
date	2008.12.23.05.33.40;	author jfrijters;	state Exp;
branches;
next	1.116;

1.116
date	2008.12.22.07.34.37;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2008.11.03.06.59.59;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2008.09.25.05.17.21;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2008.09.21.09.45.00;	author jfrijters;	state Exp;
branches
	1.113.2.1;
next	1.112;

1.112
date	2008.09.02.04.56.19;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2008.09.01.05.19.05;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2008.09.01.04.01.36;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2008.08.28.06.51.31;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2008.08.25.04.51.06;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2008.08.25.04.16.59;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2008.08.21.06.53.48;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2008.08.21.06.40.24;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2008.08.15.12.01.22;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2008.08.06.05.48.53;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2008.08.06.05.25.21;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2008.07.04.05.40.54;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2008.06.04.05.13.07;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.03.12.10.36;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2008.06.03.07.13.51;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2008.05.31.15.20.47;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2008.05.20.07.43.42;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2008.05.09.05.59.59;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2008.05.03.19.00.32;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2008.04.25.04.48.57;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2008.04.24.06.22.56;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2008.04.23.05.24.35;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2008.04.23.05.22.31;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2008.04.23.04.25.22;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2008.04.14.05.09.38;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2008.04.07.04.30.04;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2008.03.14.09.17.09;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2008.03.03.08.28.23;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2008.03.03.07.27.38;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2008.03.03.07.05.20;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2008.02.29.08.03.10;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2008.02.19.16.52.54;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2008.02.09.17.34.50;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2007.12.28.14.55.33;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2007.12.27.15.16.49;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2007.12.19.11.28.11;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2007.12.18.11.05.31;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2007.12.18.09.56.12;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2007.12.17.10.59.05;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2007.12.17.07.44.59;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2007.12.04.08.08.33;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2007.11.26.16.00.16;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2007.11.26.15.20.10;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.26.15.19.08;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2007.11.26.12.51.40;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2007.11.26.11.01.29;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.26.09.01.35;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.26.08.38.39;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.26.05.50.58;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.25.16.49.30;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.22.10.25.54;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.21.07.14.53;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.10.05.30.04;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.25.12.27.21;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.25.06.12.59;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.25.04.44.28;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.24.11.57.01;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.12.06.51.37;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.10.06.16.50;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.23.09.30.40;	author jfrijters;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2007.08.22.11.49.58;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.21.07.16.36;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.17.13.35.51;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.17.09.58.37;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2007.08.17.09.12.52;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2007.08.16.14.05.02;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2007.08.15.12.04.26;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2007.08.14.12.09.04;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2007.08.10.13.04.21;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2007.08.08.12.52.33;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2007.08.07.07.44.42;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2007.07.31.06.14.32;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2007.07.25.08.17.53;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2007.07.25.05.33.49;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2007.07.24.14.33.59;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2007.07.24.07.52.24;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.18.08.37.42;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.18.07.30.38;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.12.14.09.51;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.12.08.46.25;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.12.08.40.32;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2007.07.11.07.11.35;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2007.07.05.11.53.06;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.04.09.18.19;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.02.07.11.48;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.29.11.57.55;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.29.08.59.51;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.28.14.00.11;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.27.06.14.55;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.22.09.51.42;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.22.05.53.48;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.21.10.32.52;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.21.04.42.14;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.20.14.15.27;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.19.16.30.09;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.19.06.09.13;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.19.04.50.45;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.18.09.14.59;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.17.13.28.41;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.15.13.53.42;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.13.11.46.24;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.12.12.54.20;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.12.11.47.11;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.11.09.17.29;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.09.08.33.09;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.05.09.57.09;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.05.06.57.18;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.01.12.47.51;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.01.11.50.46;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.31.07.13.46;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.29.16.27.10;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.28.10.15.23;	author jfrijters;	state Exp;
branches;
next	;

1.53.2.1
date	2007.09.13.07.30.16;	author jfrijters;	state Exp;
branches;
next	1.53.2.2;

1.53.2.2
date	2007.10.01.13.02.44;	author jfrijters;	state Exp;
branches;
next	1.53.2.3;

1.53.2.3
date	2007.10.12.16.18.41;	author jfrijters;	state Exp;
branches;
next	1.53.2.4;

1.53.2.4
date	2007.12.04.06.04.33;	author jfrijters;	state Exp;
branches;
next	1.53.2.5;

1.53.2.5
date	2008.01.25.07.12.21;	author jfrijters;	state Exp;
branches;
next	1.53.2.6;

1.53.2.6
date	2008.02.26.07.51.32;	author jfrijters;	state Exp;
branches;
next	1.53.2.7;

1.53.2.7
date	2008.02.27.07.08.07;	author jfrijters;	state Exp;
branches;
next	1.53.2.8;

1.53.2.8
date	2008.03.14.06.20.05;	author jfrijters;	state Exp;
branches;
next	1.53.2.9;

1.53.2.9
date	2008.05.04.08.29.06;	author jfrijters;	state Exp;
branches;
next	1.53.2.10;

1.53.2.10
date	2008.11.05.07.52.02;	author jfrijters;	state Exp;
branches;
next	;

1.113.2.1
date	2008.09.24.06.02.53;	author jfrijters;	state Exp;
branches;
next	1.113.2.2;

1.113.2.2
date	2008.11.04.05.29.20;	author jfrijters;	state Exp;
branches;
next	1.113.2.3;

1.113.2.3
date	2009.02.02.05.58.21;	author jfrijters;	state Exp;
branches;
next	;

1.136.2.1
date	2009.08.27.04.43.45;	author jfrijters;	state Exp;
branches;
next	1.136.2.2;

1.136.2.2
date	2011.10.14.11.25.23;	author jfrijters;	state Exp;
branches;
next	;

1.167.2.1
date	2009.10.12.04.21.58;	author jfrijters;	state Exp;
branches;
next	1.167.2.2;

1.167.2.2
date	2009.11.30.05.50.24;	author jfrijters;	state Exp;
branches;
next	1.167.2.3;

1.167.2.3
date	2010.04.06.05.10.26;	author jfrijters;	state Exp;
branches;
next	1.167.2.4;

1.167.2.4
date	2010.04.06.05.11.56;	author jfrijters;	state Exp;
branches;
next	1.167.2.5;

1.167.2.5
date	2010.04.06.05.23.10;	author jfrijters;	state Exp;
branches;
next	1.167.2.6;

1.167.2.6
date	2010.07.27.06.49.16;	author jfrijters;	state Exp;
branches;
next	;

1.209.2.1
date	2010.07.27.07.15.20;	author jfrijters;	state Exp;
branches;
next	1.209.2.2;

1.209.2.2
date	2010.08.03.13.26.43;	author jfrijters;	state Exp;
branches;
next	1.209.2.3;

1.209.2.3
date	2010.08.03.14.12.34;	author jfrijters;	state Exp;
branches;
next	1.209.2.4;

1.209.2.4
date	2010.08.03.14.59.51;	author jfrijters;	state Exp;
branches;
next	;

1.252.2.1
date	2011.12.20.09.35.59;	author jfrijters;	state Exp;
branches;
next	1.252.2.2;

1.252.2.2
date	2011.12.20.11.29.51;	author jfrijters;	state Exp;
branches;
next	1.252.2.3;

1.252.2.3
date	2011.12.20.12.15.15;	author jfrijters;	state Exp;
branches;
next	1.252.2.4;

1.252.2.4
date	2011.12.20.12.26.44;	author jfrijters;	state Exp;
branches;
next	1.252.2.5;

1.252.2.5
date	2011.12.20.13.35.42;	author jfrijters;	state Exp;
branches;
next	1.252.2.6;

1.252.2.6
date	2013.09.10.15.16.05;	author jfrijters;	state Exp;
branches;
next	;

1.275.2.1
date	2012.01.03.12.16.37;	author jfrijters;	state Exp;
branches;
next	;

1.285.2.1
date	2012.12.06.08.38.34;	author jfrijters;	state Exp;
branches;
next	;

1.307.2.1
date	2013.03.27.16.12.18;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.310
log
@Moved the remaining code from openjdk.cs to separate files.
@
text
@/*
  Copyright (C) 2007-2013 Jeroen Frijters
  Copyright (C) 2009 Volker Berlin (i-net software)

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Runtime.InteropServices;
using StackFrame = System.Diagnostics.StackFrame;
using StackTrace = System.Diagnostics.StackTrace;
using SystemArray = System.Array;
using SystemDouble = System.Double;
using SystemTimeZone = System.TimeZone;
using SystemThreadingThread = System.Threading.Thread;
using SystemThreadingThreadInterruptedException = System.Threading.ThreadInterruptedException;
using SystemThreadingThreadPriority = System.Threading.ThreadPriority;
using IKVM.Internal;
using jiFile = java.io.File;
using jiObjectStreamField = java.io.ObjectStreamField;
using jlClass = java.lang.Class;
using jlClassLoader = java.lang.ClassLoader;
using jlrConstructor = java.lang.reflect.Constructor;
using jlStackTraceElement = java.lang.StackTraceElement;
using jnByteBuffer = java.nio.ByteBuffer;
using ProtectionDomain = java.security.ProtectionDomain;
#if !FIRST_PASS
using jlArrayIndexOutOfBoundsException = java.lang.ArrayIndexOutOfBoundsException;
using jlClassNotFoundException = java.lang.ClassNotFoundException;
using jlException = java.lang.Exception;
using jlIllegalAccessException = java.lang.IllegalAccessException;
using jlIllegalArgumentException = java.lang.IllegalArgumentException;
using jlInterruptedException = java.lang.InterruptedException;
using jlInternalError = java.lang.InternalError;
using jlNegativeArraySizeException = java.lang.NegativeArraySizeException;
using jlNoClassDefFoundError = java.lang.NoClassDefFoundError;
using jlNullPointerException = java.lang.NullPointerException;
using jlRunnable = java.lang.Runnable;
using jlRuntimeException = java.lang.RuntimeException;
using jlSecurityManager = java.lang.SecurityManager;
using jlSystem = java.lang.System;
using jlThread = java.lang.Thread;
using jlThreadDeath = java.lang.ThreadDeath;
using jlThreadGroup = java.lang.ThreadGroup;
using jlRuntimePermission = java.lang.RuntimePermission;
using jlBoolean = java.lang.Boolean;
using jlByte = java.lang.Byte;
using jlShort = java.lang.Short;
using jlCharacter = java.lang.Character;
using jlInteger = java.lang.Integer;
using jlFloat = java.lang.Float;
using jlLong = java.lang.Long;
using jlDouble = java.lang.Double;
using jlVoid = java.lang.Void;
using jlNumber = java.lang.Number;
using jlrMethod = java.lang.reflect.Method;
using jlrField = java.lang.reflect.Field;
using jlrModifier = java.lang.reflect.Modifier;
using jlrAccessibleObject = java.lang.reflect.AccessibleObject;
using jlrInvocationTargetException = java.lang.reflect.InvocationTargetException;
using srMethodAccessor = sun.reflect.MethodAccessor;
using srConstructorAccessor = sun.reflect.ConstructorAccessor;
using srFieldAccessor = sun.reflect.FieldAccessor;
using srLangReflectAccess = sun.reflect.LangReflectAccess;
using srReflection = sun.reflect.Reflection;
using srReflectionFactory = sun.reflect.ReflectionFactory;
using Annotation = java.lang.annotation.Annotation;
using smJavaIOAccess = sun.misc.JavaIOAccess;
using smLauncher = sun.misc.Launcher;
using smSharedSecrets = sun.misc.SharedSecrets;
using smVM = sun.misc.VM;
using jiConsole = java.io.Console;
using jiIOException = java.io.IOException;
using jnCharset = java.nio.charset.Charset;
using juProperties = java.util.Properties;
using irUtil = ikvm.runtime.Util;
using iiFieldReflectorBase = ikvm.@@internal.FieldReflectorBase;
using juzZipFile = java.util.zip.ZipFile;
using juzZipEntry = java.util.zip.ZipEntry;
using juEnumeration = java.util.Enumeration;
using jiInputStream = java.io.InputStream;
using jsAccessController = java.security.AccessController;
using jsAccessControlContext = java.security.AccessControlContext;
using jsPrivilegedAction = java.security.PrivilegedAction;
using jsPrivilegedExceptionAction = java.security.PrivilegedExceptionAction;
using jsPrivilegedActionException = java.security.PrivilegedActionException;
using jnUnknownHostException = java.net.UnknownHostException;
using jnInetAddress = java.net.InetAddress;
using jnInet4Address = java.net.Inet4Address;
using jnInet6Address = java.net.Inet6Address;
using jnNetworkInterface = java.net.NetworkInterface;
using jnInterfaceAddress = java.net.InterfaceAddress;
using ssaGetPropertyAction = sun.security.action.GetPropertyAction;
#endif

namespace IKVM.Runtime
{
	public static class Assertions
	{
		private static bool sysAsserts;
		private static bool userAsserts;
		private static OptionNode classes;
		private static OptionNode packages;

		private sealed class OptionNode
		{
			internal readonly string name;
			internal readonly bool enabled;
			internal readonly OptionNode next;

			internal OptionNode(string name, bool enabled, OptionNode next)
			{
				this.name = name;
				this.enabled = enabled;
				this.next = next;
			}
		}

		private static void AddOption(string classOrPackage, bool enabled)
		{
			if (classOrPackage == null)
			{
				throw new ArgumentNullException("classOrPackage");
			}

			if (classOrPackage.EndsWith("..."))
			{
				packages = new OptionNode(classOrPackage.Substring(0, classOrPackage.Length - 3), enabled, packages);
			}
			else
			{
				classes = new OptionNode(classOrPackage, enabled, classes);
			}
		}

		public static void EnableAssertions(string classOrPackage)
		{
			AddOption(classOrPackage, true);
		}

		public static void DisableAssertions(string classOrPackage)
		{
			AddOption(classOrPackage, false);
		}

		public static void EnableAssertions()
		{
			userAsserts = true;
		}

		public static void DisableAssertions()
		{
			userAsserts = false;
		}

		public static void EnableSystemAssertions()
		{
			sysAsserts = true;
		}

		public static void DisableSystemAssertions()
		{
			sysAsserts = false;
		}

		internal static bool IsEnabled(TypeWrapper tw)
		{
			string className = tw.Name;

			// match class name
			for (OptionNode n = classes; n != null; n = n.next)
			{
				if (n.name == className)
				{
					return n.enabled;
				}
			}

			// match package name
			if (packages != null)
			{
				int len = className.Length;
				while (len > 0 && className[--len] != '.') ;

				do
				{
					for (OptionNode n = packages; n != null; n = n.next)
					{
						if (String.Compare(n.name, 0, className, 0, len, false, System.Globalization.CultureInfo.InvariantCulture) == 0 && len == n.name.Length)
						{
							return n.enabled;
						}
					}
					while (len > 0 && className[--len] != '.') ;
				} while (len > 0);
			}

			return tw.GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader() ? sysAsserts : userAsserts;
		}

		private static int Count(OptionNode n)
		{
			int count = 0;
			while (n != null)
			{
				count++;
				n = n.next;
			}
			return count;
		}

		internal static object RetrieveDirectives()
		{
#if FIRST_PASS
			return null;
#else

			java.lang.AssertionStatusDirectives asd = new java.lang.AssertionStatusDirectives();
			string[] arrStrings = new string[Count(classes)];
			bool[] arrBools = new bool[arrStrings.Length];
			OptionNode n = classes;
			for (int i = 0; i < arrStrings.Length; i++)
			{
				arrStrings[i] = n.name;
				arrBools[i] = n.enabled;
				n = n.next;
			}
			asd.classes = arrStrings;
			asd.classEnabled = arrBools;
			arrStrings = new string[Count(packages)];
			arrBools = new bool[arrStrings.Length];
			n = packages;
			for (int i = 0; i < arrStrings.Length; i++)
			{
				arrStrings[i] = n.name;
				arrBools[i] = n.enabled;
				n = n.next;
			}
			asd.packages = arrStrings;
			asd.packageEnabled = arrBools;
			asd.deflt = userAsserts;
			return asd;
#endif
		}
	}
}

static class DynamicMethodUtils
{
#if NET_4_0
	private static Module dynamicModule;
#endif

	[System.Security.SecuritySafeCritical]
	internal static DynamicMethod Create(string name, Type owner, bool nonPublic, Type returnType, Type[] paramTypes)
	{
		try
		{
#if NET_4_0
			if (dynamicModule == null)
			{
				// we have to create a module that is security critical to hold the dynamic method, if we want to be able to emit unverifiable code
				AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName("<DynamicMethodHolder>"), AssemblyBuilderAccess.RunAndCollect);
				Interlocked.CompareExchange(ref dynamicModule, ab.DefineDynamicModule("<DynamicMethodHolder>"), null);
			}
			return new DynamicMethod(name, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, returnType, paramTypes, dynamicModule, true);
#else
			if (!ReflectUtil.CanOwnDynamicMethod(owner))
			{
				// interfaces and arrays aren't allowed as owners of dynamic methods
				return new DynamicMethod(name, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, returnType, paramTypes, owner.Module, true);
			}
			else
			{
				return new DynamicMethod(name, returnType, paramTypes, owner);
			}
#endif
		}
		catch (System.Security.SecurityException)
		{
			if (nonPublic && !RestrictedMemberAccess)
			{
				// we don't have RestrictedMemberAccess, so we stick the dynamic method in our module and hope for the best
				// (i.e. that we're trying to access something with assembly access in an assembly that lets us)
				return new DynamicMethod(name, returnType, paramTypes, typeof(DynamicMethodUtils).Module);
			}
			// apparently we don't have full trust, so we try again with .NET 2.0 SP1 method
			// and we only request restrictSkipVisibility if it is required
			return new DynamicMethod(name, returnType, paramTypes, nonPublic);
		}
	}

	private static bool RestrictedMemberAccess
	{
		get
		{
			try
			{
				new System.Security.Permissions.ReflectionPermission(System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess).Demand();
				return true;
			}
			catch (System.Security.SecurityException)
			{
				return false;
			}
		}
	}
}

namespace IKVM.NativeCode.ikvm.runtime
{
	static class Startup
	{
		// this method is called from ikvm.runtime.Startup.exitMainThread() and from JNI's DetachCurrentThread
		public static void jniDetach()
		{
#if !FIRST_PASS
			jlThread.currentThread().die();
#endif
		}

		public static void addBootClassPathAssembly(Assembly asm)
		{
			ClassLoaderWrapper.GetBootstrapClassLoader().AddDelegate(global::IKVM.Internal.AssemblyClassLoader.FromAssembly(asm));
		}
	}
}

namespace IKVM.NativeCode.java
{
	namespace lang
	{
		namespace @@ref
		{
			static class Reference
			{
				public static bool noclassgc()
				{
#if CLASSGC
					return !JVM.classUnloading;
#else
					return true;
#endif
				}
			}
		}
	}

	namespace net
	{
		static class DatagramPacket
		{
			public static void init()
			{
			}
		}

		static class InetAddress
		{
			public static void init()
			{
			}

#if !FIRST_PASS
			internal static jnInetAddress ConvertIPAddress(System.Net.IPAddress address, string hostname)
			{
				if (address.IsIPv6LinkLocal || address.IsIPv6SiteLocal)
				{
					return jnInet6Address.getByAddress(hostname, address.GetAddressBytes(), (int)address.ScopeId);
				}
				else
				{
					return jnInetAddress.getByAddress(hostname, address.GetAddressBytes());
				}
			}
#endif
		}

		static class InetAddressImplFactory
		{
			private static readonly bool ipv6supported = Init();

			private static bool Init()
			{
				string env = IKVM.Internal.JVM.SafeGetEnvironmentVariable("IKVM_IPV6");
				int val;
				if (env != null && Int32.TryParse(env, out val))
				{
					return (val & 1) != 0;
				}
				// On Linux we can't bind both an IPv4 and IPv6 to the same port, so we have to disable IPv6 until we have a dual-stack implementation.
				// Mono on Windows doesn't appear to support IPv6 either (Mono on Linux does).
				return Type.GetType("Mono.Runtime") == null
					&& Environment.OSVersion.Platform == PlatformID.Win32NT
					&& System.Net.Sockets.Socket.OSSupportsIPv6;
			}

			public static bool isIPv6Supported()
			{
				return ipv6supported;
			}
		}

		static class Inet4Address
		{
			public static void init()
			{
			}
		}

		static class Inet4AddressImpl
		{
			public static string getLocalHostName(object thisInet4AddressImpl)
			{
#if FIRST_PASS
				return null;
#else
				try
				{
					return System.Net.Dns.GetHostName();
				}
				catch (System.Net.Sockets.SocketException)
				{
				}
				catch (System.Security.SecurityException)
				{
				}
				return "localhost";
#endif
			}

			public static object lookupAllHostAddr(object thisInet4AddressImpl, string hostname)
			{
#if FIRST_PASS
				return null;
#else
				try
				{
					System.Net.IPAddress[] addr = System.Net.Dns.GetHostAddresses(hostname);
					List<jnInetAddress> addresses = new List<jnInetAddress>();
					for (int i = 0; i < addr.Length; i++)
					{
						byte[] b = addr[i].GetAddressBytes();
						if (b.Length == 4)
						{
							addresses.Add(jnInetAddress.getByAddress(hostname, b));
						}
					}
					if (addresses.Count == 0)
					{
						throw new jnUnknownHostException(hostname);
					}
					return addresses.ToArray();
				}
				catch (System.ArgumentException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
				catch (System.Net.Sockets.SocketException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
#endif
			}

			public static string getHostByAddr(object thisInet4AddressImpl, byte[] addr)
			{
#if FIRST_PASS
				return null;
#else
				try
				{
					return System.Net.Dns.GetHostEntry(new System.Net.IPAddress(addr)).HostName;
				}
				catch (System.ArgumentException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
				catch (System.Net.Sockets.SocketException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
#endif
			}

			public static bool isReachable0(object thisInet4AddressImpl, byte[] addr, int timeout, byte[] ifaddr, int ttl)
			{
				// like the JDK, we don't use Ping, but we try a TCP connection to the echo port
				// (.NET 2.0 has a System.Net.NetworkInformation.Ping class, but that doesn't provide the option of binding to a specific interface)
				try
				{
					using (System.Net.Sockets.Socket sock = new System.Net.Sockets.Socket(System.Net.Sockets.AddressFamily.InterNetwork, System.Net.Sockets.SocketType.Stream, System.Net.Sockets.ProtocolType.Tcp))
					{
						if (ifaddr != null)
						{
							sock.Bind(new System.Net.IPEndPoint(((ifaddr[3] << 24) + (ifaddr[2] << 16) + (ifaddr[1] << 8) + ifaddr[0]) & 0xFFFFFFFFL, 0));
						}
						if (ttl > 0)
						{
							sock.SetSocketOption(System.Net.Sockets.SocketOptionLevel.IP, System.Net.Sockets.SocketOptionName.IpTimeToLive, ttl);
						}
						System.Net.IPEndPoint ep = new System.Net.IPEndPoint(((addr[3] << 24) + (addr[2] << 16) + (addr[1] << 8) + addr[0]) & 0xFFFFFFFFL, 7);
						IAsyncResult res = sock.BeginConnect(ep, null, null);
						if (res.AsyncWaitHandle.WaitOne(timeout, false))
						{
							try
							{
								sock.EndConnect(res);
								return true;
							}
							catch (System.Net.Sockets.SocketException x)
							{
								const int WSAECONNREFUSED = 10061;
								if (x.ErrorCode == WSAECONNREFUSED)
								{
									// we got back an explicit "connection refused", that means the host was reachable.
									return true;
								}
							}
						}
					}
				}
				catch (System.Net.Sockets.SocketException)
				{
				}
				return false;
			}
		}

		static class Inet6Address
		{
			public static void init()
			{
			}
		}

		static class Inet6AddressImpl
		{
			public static string getLocalHostName(object thisInet6AddressImpl)
			{
#if FIRST_PASS
				return null;
#else
				try
				{
					return System.Net.Dns.GetHostName();
				}
				catch (System.Net.Sockets.SocketException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
#endif
			}

			public static object lookupAllHostAddr(object thisInet6AddressImpl, string hostname)
			{
#if FIRST_PASS
				return null;
#else
				try
				{
					System.Net.IPAddress[] addr = System.Net.Dns.GetHostAddresses(hostname);
					jnInetAddress[] addresses = new jnInetAddress[addr.Length];
					int pos = 0;
					for (int i = 0; i < addr.Length; i++)
					{
						if (addr[i].AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6 == jnInetAddress.preferIPv6Address)
						{
							addresses[pos++] = InetAddress.ConvertIPAddress(addr[i], hostname);
						}
					}
					for (int i = 0; i < addr.Length; i++)
					{
						if (addr[i].AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6 != jnInetAddress.preferIPv6Address)
						{
							addresses[pos++] = InetAddress.ConvertIPAddress(addr[i], hostname);
						}
					}
					if (addresses.Length == 0)
					{
						throw new jnUnknownHostException(hostname);
					}
					return addresses;
				}
				catch (System.ArgumentException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
				catch (System.Net.Sockets.SocketException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
#endif
			}

			public static string getHostByAddr(object thisInet6AddressImpl, byte[] addr)
			{
#if FIRST_PASS
				return null;
#else
				try
				{
					return System.Net.Dns.GetHostEntry(new System.Net.IPAddress(addr)).HostName;
				}
				catch (System.ArgumentException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
				catch (System.Net.Sockets.SocketException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
#endif
			}

			public static bool isReachable0(object thisInet6AddressImpl, byte[] addr, int scope, int timeout, byte[] inf, int ttl, int if_scope)
			{
				if (addr.Length == 4)
				{
					return Inet4AddressImpl.isReachable0(null, addr, timeout, inf, ttl);
				}
				// like the JDK, we don't use Ping, but we try a TCP connection to the echo port
				// (.NET 2.0 has a System.Net.NetworkInformation.Ping class, but that doesn't provide the option of binding to a specific interface)
				try
				{
					using (System.Net.Sockets.Socket sock = new System.Net.Sockets.Socket(System.Net.Sockets.AddressFamily.InterNetworkV6, System.Net.Sockets.SocketType.Stream, System.Net.Sockets.ProtocolType.Tcp))
					{
						if (inf != null)
						{
							sock.Bind(new System.Net.IPEndPoint(new System.Net.IPAddress(inf, (uint)if_scope), 0));
						}
						if (ttl > 0)
						{
							sock.SetSocketOption(System.Net.Sockets.SocketOptionLevel.IPv6, System.Net.Sockets.SocketOptionName.HopLimit, ttl);
						}
						System.Net.IPEndPoint ep = new System.Net.IPEndPoint(new System.Net.IPAddress(addr, (uint)scope), 7);
						IAsyncResult res = sock.BeginConnect(ep, null, null);
						if (res.AsyncWaitHandle.WaitOne(timeout, false))
						{
							try
							{
								sock.EndConnect(res);
								return true;
							}
							catch (System.Net.Sockets.SocketException x)
							{
								const int WSAECONNREFUSED = 10061;
								if (x.ErrorCode == WSAECONNREFUSED)
								{
									// we got back an explicit "connection refused", that means the host was reachable.
									return true;
								}
							}
						}
					}
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.Net.Sockets.SocketException)
				{
				}
				return false;
			}
		}

		static class NetworkInterface
		{
#if !FIRST_PASS
			private static NetworkInterfaceInfo cache;
			private static DateTime cachedSince;
#endif

			public static void init()
			{
			}

#if !FIRST_PASS
			private sealed class NetworkInterfaceInfo
			{
				internal System.Net.NetworkInformation.NetworkInterface[] dotnetInterfaces;
				internal jnNetworkInterface[] javaInterfaces;
			}

			private static int Compare(System.Net.NetworkInformation.NetworkInterface ni1, System.Net.NetworkInformation.NetworkInterface ni2)
			{
				int index1 = GetIndex(ni1);
				int index2 = GetIndex(ni2);
				return index1.CompareTo(index2);
			}

			private static System.Net.NetworkInformation.IPv4InterfaceProperties GetIPv4Properties(System.Net.NetworkInformation.IPInterfaceProperties props)
			{
				try
				{
					return props.GetIPv4Properties();
				}
				catch (System.Net.NetworkInformation.NetworkInformationException)
				{
					return null;
				}
			}

			private static System.Net.NetworkInformation.IPv6InterfaceProperties GetIPv6Properties(System.Net.NetworkInformation.IPInterfaceProperties props)
			{
				try
				{
					return props.GetIPv6Properties();
				}
				catch (System.Net.NetworkInformation.NetworkInformationException)
				{
					return null;
				}
			}

			private static int GetIndex(System.Net.NetworkInformation.NetworkInterface ni)
			{
				System.Net.NetworkInformation.IPInterfaceProperties ipprops = ni.GetIPProperties();
				System.Net.NetworkInformation.IPv4InterfaceProperties ipv4props = GetIPv4Properties(ipprops);
				if (ipv4props != null)
				{
					return ipv4props.Index;
				}
				else if (InetAddressImplFactory.isIPv6Supported())
				{
					System.Net.NetworkInformation.IPv6InterfaceProperties ipv6props = GetIPv6Properties(ipprops);
					if (ipv6props != null)
					{
						return ipv6props.Index;
					}
				}
				return -1;
			}

			private static bool IsValid(System.Net.NetworkInformation.NetworkInterface ni)
			{
				return GetIndex(ni) != -1;
			}

			private static NetworkInterfaceInfo GetInterfaces()
			{
				// Since many of the methods in java.net.NetworkInterface end up calling this method and the underlying stuff this is
				// based on isn't very quick either, we cache the array for a couple of seconds.
				if (cache != null && DateTime.UtcNow - cachedSince < new TimeSpan(0, 0, 5))
				{
					return cache;
				}
				System.Net.NetworkInformation.NetworkInterface[] ifaces = System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces();
				// on Mono (on Windows) we need to filter out the network interfaces that don't have any IP properties
				ifaces = Array.FindAll(ifaces, IsValid);
				Array.Sort(ifaces, Compare);
				jnNetworkInterface[] ret = new jnNetworkInterface[ifaces.Length];
				int eth = 0;
				int tr = 0;
				int fddi = 0;
				int lo = 0;
				int ppp = 0;
				int sl = 0;
				int net = 0;
				for (int i = 0; i < ifaces.Length; i++)
				{
					string name;
					switch (ifaces[i].NetworkInterfaceType)
					{
						case System.Net.NetworkInformation.NetworkInterfaceType.Ethernet:
							name = "eth" + eth++;
							break;
						case System.Net.NetworkInformation.NetworkInterfaceType.TokenRing:
							name = "tr" + tr++;
							break;
						case System.Net.NetworkInformation.NetworkInterfaceType.Fddi:
							name = "fddi" + fddi++;
							break;
						case System.Net.NetworkInformation.NetworkInterfaceType.Loopback:
							if (lo > 0)
							{
								continue;
							}
							name = "lo";
							lo++;
							break;
						case System.Net.NetworkInformation.NetworkInterfaceType.Ppp:
							name = "ppp" + ppp++;
							break;
						case System.Net.NetworkInformation.NetworkInterfaceType.Slip:
							name = "sl" + sl++;
							break;
						default:
							name = "net" + net++;
							break;
					}
					jnNetworkInterface netif = new jnNetworkInterface();
					ret[i] = netif;
					netif._set1(name, ifaces[i].Description, GetIndex(ifaces[i]));
					System.Net.NetworkInformation.UnicastIPAddressInformationCollection uipaic = ifaces[i].GetIPProperties().UnicastAddresses;
					List<jnInetAddress> addresses = new List<jnInetAddress>();
					List<jnInterfaceAddress> bindings = new List<jnInterfaceAddress>();
					for (int j = 0; j < uipaic.Count; j++)
					{
						System.Net.IPAddress addr = uipaic[j].Address;
						if (addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
						{
							jnInet4Address address = new jnInet4Address(null, addr.GetAddressBytes());
							jnInterfaceAddress binding = new jnInterfaceAddress();
							short mask = 32;
							jnInet4Address broadcast = null;
							System.Net.IPAddress v4mask;
							try
							{
								v4mask = uipaic[j].IPv4Mask;
							}
							catch (NotImplementedException)
							{
								// Mono (as of 2.6.7) doesn't implement the IPv4Mask property
								v4mask = null;
							}
							if (v4mask != null && !v4mask.Equals(System.Net.IPAddress.Any))
							{
								broadcast = new jnInet4Address(null, -1);
								mask = 0;
								foreach (byte b in v4mask.GetAddressBytes())
								{
									mask += (short)global::java.lang.Integer.bitCount(b);
								}
							}
							else if ((address.address & ~0xffffff) == 0x7f000000)
							{
								mask = 8;
								broadcast = new jnInet4Address(null, 0xffffff);
							}
							binding._set(address, broadcast, mask);
							addresses.Add(address);
							bindings.Add(binding);
						}
						else if (InetAddressImplFactory.isIPv6Supported())
						{
							int scope = 0;
							if (addr.IsIPv6LinkLocal || addr.IsIPv6SiteLocal)
							{
								scope = (int)addr.ScopeId;
							}
							jnInet6Address ia6 = new jnInet6Address();
							ia6.ipaddress = addr.GetAddressBytes();
							if (scope != 0)
							{
								ia6._set(scope, netif);
							}
							jnInterfaceAddress binding = new jnInterfaceAddress();
							// TODO where do we get the IPv6 subnet prefix length?
							short mask = 128;
							binding._set(ia6, null, mask);
							addresses.Add(ia6);
							bindings.Add(binding);
						}
					}
					netif._set2(addresses.ToArray(), bindings.ToArray(), new jnNetworkInterface[0]);
				}
				NetworkInterfaceInfo nii = new NetworkInterfaceInfo();
				nii.dotnetInterfaces = ifaces;
				nii.javaInterfaces = ret;
				cache = nii;
				cachedSince = DateTime.UtcNow;
				return nii;
			}
#endif

			private static System.Net.NetworkInformation.NetworkInterface GetDotNetNetworkInterfaceByIndex(int index)
			{
#if FIRST_PASS
				return null;
#else
				NetworkInterfaceInfo nii = GetInterfaces();
				for (int i = 0; i < nii.javaInterfaces.Length; i++)
				{
					if (nii.javaInterfaces[i].getIndex() == index)
					{
						return nii.dotnetInterfaces[i];
					}
				}
				throw new global::java.net.SocketException("interface index not found");
#endif
			}

			public static object getByIndex(int index)
			{
#if FIRST_PASS
				return null;
#else
				foreach (jnNetworkInterface iface in GetInterfaces().javaInterfaces)
				{
					if (iface.getIndex() == index)
					{
						return iface;
					}
				}
				return null;
#endif
			}

			public static object getAll()
			{
#if FIRST_PASS
				return null;
#else
				return GetInterfaces().javaInterfaces;
#endif
			}

			public static object getByName0(string name)
			{
#if FIRST_PASS
				return null;
#else
				foreach (jnNetworkInterface iface in GetInterfaces().javaInterfaces)
				{
					if (iface.getName() == name)
					{
						return iface;
					}
				}
				return null;
#endif
			}

			public static object getByIndex0(int index)
			{
#if FIRST_PASS
				return null;
#else
				foreach (jnNetworkInterface iface in GetInterfaces().javaInterfaces)
				{
					if (iface.getIndex() == index)
					{
						return iface;
					}
				}
				return null;
#endif
			}

			public static object getByInetAddress0(object addr)
			{
#if FIRST_PASS
				return null;
#else
				foreach (jnNetworkInterface iface in GetInterfaces().javaInterfaces)
				{
					juEnumeration addresses = iface.getInetAddresses();
					while (addresses.hasMoreElements())
					{
						if (addresses.nextElement().Equals(addr))
						{
							return iface;
						}
					}
				}
				return null;
#endif
			}

			public static long getSubnet0(string name, int ind)
			{
				// this method is not used by the java code (!)
				return 0;
			}

			public static object getBroadcast0(string name, int ind)
			{
				// this method is not used by the java code (!)
				return null;
			}

			public static bool isUp0(string name, int ind)
			{
#if FIRST_PASS
				return false;
#else
				return GetDotNetNetworkInterfaceByIndex(ind).OperationalStatus == System.Net.NetworkInformation.OperationalStatus.Up;
#endif
			}

			public static bool isLoopback0(string name, int ind)
			{
#if FIRST_PASS
				return false;
#else
				return GetDotNetNetworkInterfaceByIndex(ind).NetworkInterfaceType == System.Net.NetworkInformation.NetworkInterfaceType.Loopback;
#endif
			}

			public static bool supportsMulticast0(string name, int ind)
			{
#if FIRST_PASS
				return false;
#else
				return GetDotNetNetworkInterfaceByIndex(ind).SupportsMulticast;
#endif
			}

			public static bool isP2P0(string name, int ind)
			{
#if FIRST_PASS
				return false;
#else
				switch (GetDotNetNetworkInterfaceByIndex(ind).NetworkInterfaceType)
				{
					case System.Net.NetworkInformation.NetworkInterfaceType.Ppp:
					case System.Net.NetworkInformation.NetworkInterfaceType.Slip:
						return true;
					default:
						return false;
				}
#endif
			}

			public static byte[] getMacAddr0(byte[] inAddr, string name, int ind)
			{
#if FIRST_PASS
				return null;
#else
				return GetDotNetNetworkInterfaceByIndex(ind).GetPhysicalAddress().GetAddressBytes();
#endif
			}

			public static int getMTU0(string name, int ind)
			{
#if FIRST_PASS
				return 0;
#else
				System.Net.NetworkInformation.IPInterfaceProperties ipprops = GetDotNetNetworkInterfaceByIndex(ind).GetIPProperties();
				System.Net.NetworkInformation.IPv4InterfaceProperties v4props = GetIPv4Properties(ipprops);
				if (v4props != null)
				{
					return v4props.Mtu;
				}
				if (InetAddressImplFactory.isIPv6Supported())
				{
					System.Net.NetworkInformation.IPv6InterfaceProperties v6props = GetIPv6Properties(ipprops);
					if (v6props != null)
					{
						return v6props.Mtu;
					}
				}
				return -1;
#endif
			}
		}
	}

	namespace nio
	{
		[System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.LinkDemand, UnmanagedCode = true)]
		[System.Security.SecurityCritical]
		static class Bits
		{
			public static void copyFromByteArray(object src, long srcPos, long dstAddr, long length)
			{
				byte[] byteArray = src as byte[];
				if (byteArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy(byteArray, (int)srcPos, (IntPtr)dstAddr, (int)length);
					return;
				}
				char[] charArray = src as char[];
				if (charArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy(charArray, ((int)srcPos) >> 1, (IntPtr)dstAddr, ((int)length) >> 1);
					return;
				}
				short[] shortArray = src as short[];
				if (shortArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy(shortArray, ((int)srcPos) >> 1, (IntPtr)dstAddr, ((int)length) >> 1);
					return;
				}
				int[] intArray = src as int[];
				if (intArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy(intArray, ((int)srcPos) >> 2, (IntPtr)dstAddr, ((int)length) >> 2);
					return;
				}
				float[] floatArray = src as float[];
				if (floatArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy(floatArray, ((int)srcPos) >> 2, (IntPtr)dstAddr, ((int)length) >> 2);
					return;
				}
				long[] longArray = src as long[];
				if (longArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy(longArray, ((int)srcPos) >> 3, (IntPtr)dstAddr, ((int)length) >> 3);
					return;
				}
				double[] doubleArray = src as double[];
				if (doubleArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy(doubleArray, ((int)srcPos) >> 3, (IntPtr)dstAddr, ((int)length) >> 3);
					return;
				}
			}

			public static void copyToByteArray(long srcAddr, object dst, long dstPos, long length)
			{
				byte[] byteArray = dst as byte[];
				if (byteArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy((IntPtr)srcAddr, byteArray, (int)dstPos, (int)length);
					return;
				}
				char[] charArray = dst as char[];
				if (charArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy((IntPtr)srcAddr, charArray, ((int)dstPos) >> 1, ((int)length) >> 1);
					return;
				}
				short[] shortArray = dst as short[];
				if (shortArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy((IntPtr)srcAddr, shortArray, ((int)dstPos) >> 1, ((int)length) >> 1);
					return;
				}
				int[] intArray = dst as int[];
				if (intArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy((IntPtr)srcAddr, intArray, ((int)dstPos) >> 2, ((int)length) >> 2);
					return;
				}
				float[] floatArray = dst as float[];
				if (floatArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy((IntPtr)srcAddr, floatArray, ((int)dstPos) >> 2, ((int)length) >> 2);
					return;
				}
				long[] longArray = dst as long[];
				if (longArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy((IntPtr)srcAddr, longArray, ((int)dstPos) >> 3, ((int)length) >> 3);
					return;
				}
				double[] doubleArray = dst as double[];
				if (doubleArray != null)
				{
					System.Runtime.InteropServices.Marshal.Copy((IntPtr)srcAddr, doubleArray, ((int)dstPos) >> 3, ((int)length) >> 3);
					return;
				}
			}

			public static void copyFromShortArray(object src, long srcPos, long dstAddr, long length)
			{
#if !FIRST_PASS
				short[] shortArray = src as short[];
				if (shortArray != null)
				{
					int index = ((int)srcPos) >> 1;
					while (length > 0)
					{
						short v = jlShort.reverseBytes(shortArray[index++]);
						System.Runtime.InteropServices.Marshal.WriteInt16((IntPtr)dstAddr, v);
						dstAddr += 2;
						length -= 2;
					}
				}
				else
				{
					char[] charArray = (char[])src;
					int index = ((int)srcPos) >> 1;
					while (length > 0)
					{
						short v = jlShort.reverseBytes((short)charArray[index++]);
						System.Runtime.InteropServices.Marshal.WriteInt16((IntPtr)dstAddr, v);
						dstAddr += 2;
						length -= 2;
					}
				}
#endif
			}

			public static void copyToShortArray(long srcAddr, object dst, long dstPos, long length)
			{
#if !FIRST_PASS
				short[] shortArray = dst as short[];
				if (shortArray != null)
				{
					int index = ((int)dstPos) >> 1;
					while (length > 0)
					{
						short v = System.Runtime.InteropServices.Marshal.ReadInt16((IntPtr)srcAddr);
						shortArray[index++] = jlShort.reverseBytes(v);
						srcAddr += 2;
						length -= 2;
					}
				}
				else
				{
					char[] charArray = (char[])dst;
					int index = ((int)dstPos) >> 1;
					while (length > 0)
					{
						short v = System.Runtime.InteropServices.Marshal.ReadInt16((IntPtr)srcAddr);
						charArray[index++] = (char)jlShort.reverseBytes(v);
						srcAddr += 2;
						length -= 2;
					}
				}
#endif
			}

			public static void copyFromIntArray(object src, long srcPos, long dstAddr, long length)
			{
#if !FIRST_PASS
				int[] intArray = src as int[];
				if (intArray != null)
				{
					int index = ((int)srcPos) >> 2;
					while (length > 0)
					{
						int v = jlInteger.reverseBytes(intArray[index++]);
						System.Runtime.InteropServices.Marshal.WriteInt32((IntPtr)dstAddr, v);
						dstAddr += 4;
						length -= 4;
					}
				}
				else
				{
					float[] floatArray = (float[])src;
					int index = ((int)srcPos) >> 2;
					while (length > 0)
					{
						int v = jlInteger.reverseBytes(jlFloat.floatToRawIntBits(floatArray[index++]));
						System.Runtime.InteropServices.Marshal.WriteInt32((IntPtr)dstAddr, v);
						dstAddr += 4;
						length -= 4;
					}
				}
#endif
			}

			public static void copyToIntArray(long srcAddr, object dst, long dstPos, long length)
			{
#if !FIRST_PASS
				int[] intArray = dst as int[];
				if (intArray != null)
				{
					int index = ((int)dstPos) >> 2;
					while (length > 0)
					{
						int v = System.Runtime.InteropServices.Marshal.ReadInt32((IntPtr)srcAddr);
						intArray[index++] = jlInteger.reverseBytes(v);
						srcAddr += 4;
						length -= 4;
					}
				}
				else
				{
					float[] floatArray = (float[])dst;
					int index = ((int)dstPos) >> 2;
					while (length > 0)
					{
						int v = System.Runtime.InteropServices.Marshal.ReadInt32((IntPtr)srcAddr);
						floatArray[index++] = jlFloat.intBitsToFloat(jlInteger.reverseBytes(v));
						srcAddr += 4;
						length -= 4;
					}
				}
#endif
			}

			public static void copyFromLongArray(object src, long srcPos, long dstAddr, long length)
			{
#if !FIRST_PASS
				long[] longArray = src as long[];
				if (longArray != null)
				{
					int index = ((int)srcPos) >> 3;
					while (length > 0)
					{
						long v = jlLong.reverseBytes(longArray[index++]);
						System.Runtime.InteropServices.Marshal.WriteInt64((IntPtr)dstAddr, v);
						dstAddr += 8;
						length -= 8;
					}
				}
				else
				{
					double[] doubleArray = (double[])src;
					int index = ((int)srcPos) >> 3;
					while (length > 0)
					{
						long v = jlLong.reverseBytes(BitConverter.DoubleToInt64Bits(doubleArray[index++]));
						System.Runtime.InteropServices.Marshal.WriteInt64((IntPtr)dstAddr, v);
						dstAddr += 8;
						length -= 8;
					}
				}
#endif
			}

			public static void copyToLongArray(long srcAddr, object dst, long dstPos, long length)
			{
#if !FIRST_PASS
				long[] longArray = dst as long[];
				if (longArray != null)
				{
					int index = ((int)dstPos) >> 3;
					while (length > 0)
					{
						long v = System.Runtime.InteropServices.Marshal.ReadInt64((IntPtr)srcAddr);
						longArray[index++] = jlLong.reverseBytes(v);
						srcAddr += 8;
						length -= 8;
					}
				}
				else
				{
					double[] doubleArray = (double[])dst;
					int index = ((int)dstPos) >> 3;
					while (length > 0)
					{
						long v = System.Runtime.InteropServices.Marshal.ReadInt64((IntPtr)srcAddr);
						doubleArray[index++] = BitConverter.Int64BitsToDouble(jlLong.reverseBytes(v));
						srcAddr += 8;
						length -= 8;
					}
				}
#endif
			}
		}

		static class MappedByteBuffer
		{
			private static volatile int bogusField;

			public static bool isLoaded0(object thisMappedByteBuffer, long address, long length, int pageCount)
			{
				// on Windows, JDK simply returns false, so we can get away with that too.
				return false;
			}

			[System.Security.SecuritySafeCritical]
			public static void load0(object thisMappedByteBuffer, long address, long length)
			{
				int bogus = bogusField;
				while (length > 0)
				{
					// touch a byte in every page
					bogus += System.Runtime.InteropServices.Marshal.ReadByte((IntPtr)address);
					length -= 4096;
					address += 4096;
				}
				// do a volatile store of the sum of the bytes to make sure the reads don't get optimized out
				bogusField = bogus;
				GC.KeepAlive(thisMappedByteBuffer);
			}

			[System.Security.SecuritySafeCritical]
			public static void force0(object thisMappedByteBuffer, object fd, long address, long length)
			{
				if (JVM.IsUnix)
				{
					ikvm_msync((IntPtr)address, (int)length);
					GC.KeepAlive(thisMappedByteBuffer);
				}
				else
				{
					// according to the JDK sources, FlushViewOfFile can fail with an ERROR_LOCK_VIOLATION error,
					// so like the JDK, we retry up to three times if that happens.
					for (int i = 0; i < 3; i++)
					{
						if (FlushViewOfFile((IntPtr)address, (IntPtr)length) != 0)
						{
							GC.KeepAlive(thisMappedByteBuffer);
							return;
						}
						const int ERROR_LOCK_VIOLATION = 33;
						if (System.Runtime.InteropServices.Marshal.GetLastWin32Error() != ERROR_LOCK_VIOLATION)
						{
							break;
						}
					}
#if !FIRST_PASS
					throw new jiIOException("Flush failed");
#endif
				}
			}

			[System.Runtime.InteropServices.DllImport("kernel32", SetLastError = true)]
			private static extern int FlushViewOfFile(IntPtr lpBaseAddress, IntPtr dwNumberOfBytesToFlush);

			[System.Runtime.InteropServices.DllImport("ikvm-native")]
		    private static extern int ikvm_msync(IntPtr address, int size);
		}
	}

	namespace security
	{
		static class AccessController
		{
			public static object getStackAccessControlContext(global::java.security.AccessControlContext context, global::ikvm.@@internal.CallerID callerID)
			{
#if FIRST_PASS
				return null;
#else
				List<ProtectionDomain> array = new List<ProtectionDomain>();
				bool is_privileged = GetProtectionDomains(array, callerID, new StackTrace(1));
				if (array.Count == 0)
				{
					if (is_privileged && context == null)
					{
						return null;
					}
				}
				return CreateAccessControlContext(array, is_privileged, context);
#endif
			}

#if !FIRST_PASS
			private static bool GetProtectionDomains(List<ProtectionDomain> array, global::ikvm.@@internal.CallerID callerID, StackTrace stack)
			{
				ProtectionDomain previous_protection_domain = null;
				for (int i = 0; i < stack.FrameCount; i++)
				{
					bool is_privileged = false;
					ProtectionDomain protection_domain;
					MethodBase method = stack.GetFrame(i).GetMethod();
					if (method.DeclaringType == typeof(global::java.security.AccessController)
						&& method.Name == "doPrivileged")
					{
						is_privileged = true;
						global::java.lang.Class caller = callerID.getCallerClass();
						protection_domain = caller == null ? null : Java_java_lang_Class.getProtectionDomain0(caller);
					}
					else
					{
						protection_domain = GetProtectionDomainFromType(method.DeclaringType);
					}

					if (previous_protection_domain != protection_domain && protection_domain != null)
					{
						previous_protection_domain = protection_domain;
						array.Add(protection_domain);
					}

					if (is_privileged)
					{
						return true;
					}
				}
				return false;
			}

			private static object CreateAccessControlContext(List<ProtectionDomain> context, bool is_privileged, jsAccessControlContext privileged_context)
			{
				jsAccessControlContext acc = new jsAccessControlContext(context == null || context.Count == 0 ? null : context.ToArray(), is_privileged);
				acc._privilegedContext(privileged_context);
				return acc;
			}

			private static ProtectionDomain GetProtectionDomainFromType(Type type)
			{
				if (type == null
					|| type.Assembly == typeof(object).Assembly
					|| type.Assembly == typeof(AccessController).Assembly
					|| type.Assembly == Java_java_lang_SecurityManager.jniAssembly
					|| type.Assembly == typeof(jlThread).Assembly)
				{
					return null;
				}
				TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(type);
				if (tw != null)
				{
					return Java_java_lang_Class.getProtectionDomain0(tw.ClassObject);
				}
				return null;
			}
#endif

			public static object getInheritedAccessControlContext()
			{
#if FIRST_PASS
				return null;
#else
				global::java.security.AccessController.LazyContext lc = jlThread.currentThread().lazyInheritedAccessControlContext;
				if (lc == null)
				{
					return null;
				}
				List<ProtectionDomain> list = new List<ProtectionDomain>();
				while (lc != null)
				{
					if (GetProtectionDomains(list, lc.callerID, lc.stackTrace))
					{
						return CreateAccessControlContext(list, true, lc.context);
					}
					lc = lc.parent;
				}
				return CreateAccessControlContext(list, false, null);
#endif
			}
		}
	}

	namespace util
	{
		namespace logging
		{
			static class FileHandler
			{
				public static bool isSetUID()
				{
					// TODO
					return false;
				}
			}
		}

		namespace prefs
		{
			static class FileSystemPreferences
			{
				public static int chmod(string filename, int permission)
				{
					// TODO
					return 0;
				}

				public static int[] lockFile0(string filename, int permission, bool shared)
				{
					// TODO
					return new int[] { 1, 0 };
				}

				public static int unlockFile0(int fd)
				{
					// TODO
					return 0;
				}
			}

			static class WindowsPreferences
			{
				// HACK we currently support only 16 handles at a time
				private static readonly Microsoft.Win32.RegistryKey[] keys = new Microsoft.Win32.RegistryKey[16];

				private static Microsoft.Win32.RegistryKey MapKey(int hKey)
				{
					switch (hKey)
					{
						case unchecked((int)0x80000001):
							return Microsoft.Win32.Registry.CurrentUser;
						case unchecked((int)0x80000002):
							return Microsoft.Win32.Registry.LocalMachine;
						default:
							return keys[hKey - 1];
					}
				}

				private static int AllocHandle(Microsoft.Win32.RegistryKey key)
				{
					lock (keys)
					{
						if (key != null)
						{
							for (int i = 0; i < keys.Length; i++)
							{
								if (keys[i] == null)
								{
									keys[i] = key;
									return i + 1;
								}
							}
						}
						return 0;
					}
				}

				private static string BytesToString(byte[] bytes)
				{
					int len = bytes.Length;
					if (bytes[len - 1] == 0)
					{
						len--;
					}
					return Encoding.ASCII.GetString(bytes, 0, len);
				}

				private static byte[] StringToBytes(string str)
				{
					if (str.Length == 0 || str[str.Length - 1] != 0)
					{
						str += '\u0000';
					}
					return Encoding.ASCII.GetBytes(str);
				}

				public static int[] WindowsRegOpenKey(int hKey, byte[] subKey, int securityMask)
				{
                    // writeable = DELETE == 0x10000 || KEY_SET_VALUE == 2 || KEY_CREATE_SUB_KEY == 4 || KEY_WRITE = 0x20006;
                    // !writeable : KEY_ENUMERATE_SUB_KEYS == 8 || KEY_READ == 0x20019 || KEY_QUERY_VALUE == 1
					bool writable = (securityMask & 0x10006) != 0;
					Microsoft.Win32.RegistryKey resultKey = null;
					int error = 0;
					try
					{
                        Microsoft.Win32.RegistryKey parent = MapKey(hKey);
						// HACK we check if we can write in the system preferences 
						// we want not user registry virtualization for compatibility
						if (writable && parent.Name.StartsWith("HKEY_LOCAL_MACHINE", StringComparison.Ordinal) && UACVirtualization.Enabled)
						{
                            resultKey = parent.OpenSubKey(BytesToString(subKey), false);
                            if (resultKey != null) {
                                // error only if key exists
                                resultKey.Close();
                                error = 5;
                                resultKey = null;
                            }
                        } else
                        {
                            resultKey = parent.OpenSubKey(BytesToString(subKey), writable);
                        }
					}
					catch (System.Security.SecurityException)
					{
						error = 5;
					}
					catch (UnauthorizedAccessException)
					{
						error = 5;
					}
					return new int[] { AllocHandle(resultKey), error };
				}

				public static int WindowsRegCloseKey(int hKey)
				{
					keys[hKey - 1].Close();
					lock (keys)
					{
						keys[hKey - 1] = null;
					}
					return 0;
				}

				public static int[] WindowsRegCreateKeyEx(int hKey, byte[] subKey)
				{
					Microsoft.Win32.RegistryKey resultKey = null;
					int error = 0;
					int disposition = -1;
					try
					{
						Microsoft.Win32.RegistryKey key = MapKey(hKey);
						string name = BytesToString(subKey);
						resultKey = key.OpenSubKey(name);
						disposition = 2;
						if (resultKey == null)
						{
							resultKey = key.CreateSubKey(name);
							disposition = 1;
						}
					}
					catch (System.Security.SecurityException)
					{
						error = 5;
					}
					catch (UnauthorizedAccessException)
					{
						error = 5;
					}
					return new int[] { AllocHandle(resultKey), error, disposition };
				}

				public static int WindowsRegDeleteKey(int hKey, byte[] subKey)
				{
					try
					{
						MapKey(hKey).DeleteSubKey(BytesToString(subKey), false);
						return 0;
					}
					catch (System.Security.SecurityException)
					{
						return 5;
					}
				}

				public static int WindowsRegFlushKey(int hKey)
				{
					MapKey(hKey).Flush();
					return 0;
				}

				public static byte[] WindowsRegQueryValueEx(int hKey, byte[] valueName)
				{
					try
					{
						string value = MapKey(hKey).GetValue(BytesToString(valueName)) as string;
						if (value == null)
						{
							return null;
						}
						return StringToBytes(value);
					}
					catch (System.Security.SecurityException)
					{
						return null;
					}
					catch (UnauthorizedAccessException)
					{
						return null;
					}
				}

				public static int WindowsRegSetValueEx(int hKey, byte[] valueName, byte[] data)
				{
					if (valueName == null || data == null)
					{
						return -1;
					}
					try
					{
						MapKey(hKey).SetValue(BytesToString(valueName), BytesToString(data));
						return 0;
					}
					catch (System.Security.SecurityException)
					{
						return 5;
					}
					catch (UnauthorizedAccessException)
					{
						return 5;
					}
				}

                public static int WindowsRegDeleteValue(int hKey, byte[] valueName)
                {
                    try
                    {
                        MapKey(hKey).DeleteValue(BytesToString(valueName));
                        return 0;
                    }
                    catch (System.ArgumentException)
                    {
                        return 2; //ERROR_FILE_NOT_FOUND
                    }
                    catch (System.Security.SecurityException)
                    {
                        return 5; //ERROR_ACCESS_DENIED
                    }
                    catch (UnauthorizedAccessException)
                    {
                        return 5; //ERROR_ACCESS_DENIED
                    }
                }

				public static int[] WindowsRegQueryInfoKey(int hKey)
				{
					int[] result = new int[5] { -1, -1, -1, -1, -1 };
					try
					{
						Microsoft.Win32.RegistryKey key = MapKey(hKey);
						result[0] = key.SubKeyCount;
						result[1] = 0;
						result[2] = key.ValueCount;
						foreach (string s in key.GetSubKeyNames())
						{
							result[3] = Math.Max(result[3], s.Length);
						}
						foreach (string s in key.GetValueNames())
						{
							result[4] = Math.Max(result[4], s.Length);
						}
					}
					catch (System.Security.SecurityException)
					{
						result[1] = 5;
					}
					catch (UnauthorizedAccessException)
					{
						result[1] = 5;
					}
					return result;
				}

				public static byte[] WindowsRegEnumKeyEx(int hKey, int subKeyIndex, int maxKeyLength)
				{
					try
					{
						return StringToBytes(MapKey(hKey).GetSubKeyNames()[subKeyIndex]);
					}
					catch (System.Security.SecurityException)
					{
						return null;
					}
					catch (UnauthorizedAccessException)
					{
						return null;
					}
				}

				public static byte[] WindowsRegEnumValue(int hKey, int valueIndex, int maxValueNameLength)
				{
					try
					{
						return StringToBytes(MapKey(hKey).GetValueNames()[valueIndex]);
					}
					catch (System.Security.SecurityException)
					{
						return null;
					}
					catch (UnauthorizedAccessException)
					{
						return null;
					}
				}
			}

            internal static class UACVirtualization {
                private enum TOKEN_INFORMATION_CLASS {
                    TokenVirtualizationEnabled = 24
                }

                [DllImport("advapi32.dll", SetLastError = true)]
                private static extern bool GetTokenInformation(
                    IntPtr TokenHandle,
                    TOKEN_INFORMATION_CLASS TokenInformationClass,
                    out uint TokenInformation,
                    uint TokenInformationLength,
                    out uint ReturnLength);

                internal static bool Enabled {
                    [System.Security.SecuritySafeCritical]
                    get {
						OperatingSystem os = Environment.OSVersion;
						if (os.Platform != PlatformID.Win32NT || os.Version.Major < 6) {
							return false;
						}
                        uint enabled, length;
                        GetTokenInformation(System.Security.Principal.WindowsIdentity.GetCurrent().Token, TOKEN_INFORMATION_CLASS.TokenVirtualizationEnabled, out enabled, 4, out length);
                        return enabled != 0;
                    }
                }
            }
        }

		namespace jar
		{
			static class JarFile
			{
				public static string[] getMetaInfEntryNames(object thisJarFile)
				{
#if FIRST_PASS
					return null;
#else
					juzZipFile zf = (juzZipFile)thisJarFile;
					juEnumeration entries = zf.entries();
					List<string> list = null;
					while (entries.hasMoreElements())
					{
						juzZipEntry entry = (juzZipEntry)entries.nextElement();
						if (entry.getName().StartsWith("META-INF/", StringComparison.OrdinalIgnoreCase))
						{
							if (list == null)
							{
								list = new List<string>();
							}
							list.Add(entry.getName());
						}
					}
					return list == null ? null : list.ToArray();
#endif
				}
			}
		}

		namespace zip
		{
			static class ClassStubZipEntry
			{
				public static void expandIkvmClasses(object _zipFile, object _entries)
				{
#if !FIRST_PASS
					juzZipFile zipFile = (juzZipFile)_zipFile;
					global::java.util.LinkedHashMap entries = (global::java.util.LinkedHashMap)_entries;

					try
					{
						string path = zipFile.getName();
						juzZipEntry entry = (juzZipEntry)entries.get(JVM.JarClassList);
						if (entry != null && VirtualFileSystem.IsVirtualFS(path))
						{
							using (VirtualFileSystem.ZipEntryStream stream = new VirtualFileSystem.ZipEntryStream(zipFile, entry))
							{
								entries.remove(entry.name);
								System.IO.BinaryReader br = new System.IO.BinaryReader(stream);
								int count = br.ReadInt32();
								for (int i = 0; i < count; i++)
								{
									global::java.util.zip.ClassStubZipEntry classEntry = new global::java.util.zip.ClassStubZipEntry(path, br.ReadString());
									classEntry.setMethod(global::java.util.zip.ClassStubZipEntry.STORED);
									classEntry.setTime(entry.getTime());
									entries.put(classEntry.name, classEntry);
								}
							}
						}
					}
					catch (global::java.io.IOException)
					{
					}
					catch (System.IO.IOException)
					{
					}
#endif
				}
			}
		}

		static class TimeZone
		{
			private static string GetCurrentTimeZoneID()
			{
#if NET_4_0
				return TimeZoneInfo.Local.Id;
#else
				// we don't want a static dependency on System.Core (to be able to run on .NET 2.0)
				Type typeofTimeZoneInfo = Type.GetType("System.TimeZoneInfo, System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
				if (typeofTimeZoneInfo != null)
				{
					try
					{
						return (string)typeofTimeZoneInfo.GetProperty("Id").GetValue(typeofTimeZoneInfo.GetProperty("Local").GetValue(null, null), null);
					}
					catch (Exception x)
					{
						if (typeofTimeZoneInfo.Assembly.GetType("System.TimeZoneNotFoundException").IsInstanceOfType(x))
						{
							// MONOBUG Mono's TimeZoneInfo.Local property throws a TimeZoneNotFoundException on Windows
							// (https://bugzilla.novell.com/show_bug.cgi?id=622524)
							return SystemTimeZone.CurrentTimeZone.StandardName;
						}
						else
						{
							throw;
						}
					}
				}
				else
				{
					// HACK this is very lame and probably won't work on localized windows versions
					return SystemTimeZone.CurrentTimeZone.StandardName;
				}
#endif
			}

			public static string getSystemTimeZoneID(string javaHome, string country)
			{
				// (the switch was generated from the contents of $JAVA_HOME/lib/tzmappings)
				switch (GetCurrentTimeZoneID())
				{
					case "Romance":
					case "Romance Standard Time":
						return "Europe/Paris";
					case "Warsaw":
						return "Europe/Warsaw";
					case "Central Europe":
					case "Central Europe Standard Time":
					case "Prague Bratislava":
						return "Europe/Prague";
					case "W. Central Africa Standard Time":
						return "Africa/Luanda";
					case "FLE":
					case "FLE Standard Time":
						return "Europe/Helsinki";
					case "GFT":
					case "GFT Standard Time":
					case "GTB":
					case "GTB Standard Time":
						return "Europe/Athens";
					case "Israel":
					case "Israel Standard Time":
						return "Asia/Jerusalem";
					case "Arab":
					case "Arab Standard Time":
						return "Asia/Riyadh";
					case "Arabic Standard Time":
						return "Asia/Baghdad";
					case "E. Africa":
					case "E. Africa Standard Time":
						return "Africa/Nairobi";
					case "Saudi Arabia":
					case "Saudi Arabia Standard Time":
						return "Asia/Riyadh";
					case "Iran":
					case "Iran Standard Time":
						return "Asia/Tehran";
					case "Afghanistan":
					case "Afghanistan Standard Time":
						return "Asia/Kabul";
					case "India":
					case "India Standard Time":
						return "Asia/Calcutta";
					case "Myanmar Standard Time":
						return "Asia/Rangoon";
					case "Nepal Standard Time":
						return "Asia/Katmandu";
					case "Sri Lanka":
					case "Sri Lanka Standard Time":
						return "Asia/Colombo";
					case "Beijing":
					case "China":
					case "China Standard Time":
						return "Asia/Shanghai";
					case "AUS Central":
					case "AUS Central Standard Time":
						return "Australia/Darwin";
					case "Cen. Australia":
					case "Cen. Australia Standard Time":
						return "Australia/Adelaide";
					case "Vladivostok":
					case "Vladivostok Standard Time":
						return "Asia/Vladivostok";
					case "West Pacific":
					case "West Pacific Standard Time":
						return "Pacific/Guam";
					case "E. South America":
					case "E. South America Standard Time":
						return "America/Sao_Paulo";
					case "Greenland Standard Time":
						return "America/Godthab";
					case "Newfoundland":
					case "Newfoundland Standard Time":
						return "America/St_Johns";
					case "Pacific SA":
					case "Pacific SA Standard Time":
						return "America/Santiago";
					case "SA Western":
					case "SA Western Standard Time":
						return "America/Caracas";
					case "SA Pacific":
					case "SA Pacific Standard Time":
						return "America/Bogota";
					case "US Eastern":
					case "US Eastern Standard Time":
						return "America/Indianapolis";
					case "Central America Standard Time":
						return "America/Regina";
					case "Mexico":
					case "Mexico Standard Time":
						return "America/Mexico_City";
					case "Canada Central":
					case "Canada Central Standard Time":
						return "America/Regina";
					case "US Mountain":
					case "US Mountain Standard Time":
						return "America/Phoenix";
					case "GMT":
					case "GMT Standard Time":
						return "Europe/London";
					case "Ekaterinburg":
					case "Ekaterinburg Standard Time":
						return "Asia/Yekaterinburg";
					case "West Asia":
					case "West Asia Standard Time":
						return "Asia/Karachi";
					case "Central Asia":
					case "Central Asia Standard Time":
						return "Asia/Dhaka";
					case "N. Central Asia Standard Time":
						return "Asia/Novosibirsk";
					case "Bangkok":
					case "Bangkok Standard Time":
						return "Asia/Bangkok";
					case "North Asia Standard Time":
						return "Asia/Krasnoyarsk";
					case "SE Asia":
					case "SE Asia Standard Time":
						return "Asia/Bangkok";
					case "North Asia East Standard Time":
						return "Asia/Ulaanbaatar";
					case "Singapore":
					case "Singapore Standard Time":
						return "Asia/Singapore";
					case "Taipei":
					case "Taipei Standard Time":
						return "Asia/Taipei";
					case "W. Australia":
					case "W. Australia Standard Time":
						return "Australia/Perth";
					case "Korea":
					case "Korea Standard Time":
						return "Asia/Seoul";
					case "Tokyo":
					case "Tokyo Standard Time":
						return "Asia/Tokyo";
					case "Yakutsk":
					case "Yakutsk Standard Time":
						return "Asia/Yakutsk";
					case "Central European":
					case "Central European Standard Time":
						return "Europe/Belgrade";
					case "W. Europe":
					case "W. Europe Standard Time":
						return "Europe/Berlin";
					case "Tasmania":
					case "Tasmania Standard Time":
						return "Australia/Hobart";
					case "AUS Eastern":
					case "AUS Eastern Standard Time":
						return "Australia/Sydney";
					case "E. Australia":
					case "E. Australia Standard Time":
						return "Australia/Brisbane";
					case "Sydney Standard Time":
						return "Australia/Sydney";
					case "Central Pacific":
					case "Central Pacific Standard Time":
						return "Pacific/Guadalcanal";
					case "Dateline":
					case "Dateline Standard Time":
						return "GMT-1200";
					case "Fiji":
					case "Fiji Standard Time":
						return "Pacific/Fiji";
					case "Samoa":
					case "Samoa Standard Time":
						return "Pacific/Apia";
					case "Hawaiian":
					case "Hawaiian Standard Time":
						return "Pacific/Honolulu";
					case "Alaskan":
					case "Alaskan Standard Time":
						return "America/Anchorage";
					case "Pacific":
					case "Pacific Standard Time":
						return "America/Los_Angeles";
					case "Mexico Standard Time 2":
						return "America/Chihuahua";
					case "Mountain":
					case "Mountain Standard Time":
						return "America/Denver";
					case "Central":
					case "Central Standard Time":
						return "America/Chicago";
					case "Eastern":
					case "Eastern Standard Time":
						return "America/New_York";
					case "E. Europe":
					case "E. Europe Standard Time":
						return "Europe/Minsk";
					case "Egypt":
					case "Egypt Standard Time":
						return "Africa/Cairo";
					case "South Africa":
					case "South Africa Standard Time":
						return "Africa/Harare";
					case "Atlantic":
					case "Atlantic Standard Time":
						return "America/Halifax";
					case "SA Eastern":
					case "SA Eastern Standard Time":
						return "America/Buenos_Aires";
					case "Mid-Atlantic":
					case "Mid-Atlantic Standard Time":
						return "Atlantic/South_Georgia";
					case "Azores":
					case "Azores Standard Time":
						return "Atlantic/Azores";
					case "Cape Verde Standard Time":
						return "Atlantic/Cape_Verde";
					case "Russian":
					case "Russian Standard Time":
						return "Europe/Moscow";
					case "New Zealand":
					case "New Zealand Standard Time":
						return "Pacific/Auckland";
					case "Tonga Standard Time":
						return "Pacific/Tongatapu";
					case "Arabian":
					case "Arabian Standard Time":
						return "Asia/Muscat";
					case "Caucasus":
					case "Caucasus Standard Time":
						return "Asia/Yerevan";
					case "Greenwich":
					case "Greenwich Standard Time":
						return "GMT";
					case "Central Brazilian Standard Time":
						return "America/Manaus";
					case "Central Standard Time (Mexico)":
						return "America/Mexico_City";
					case "Georgian Standard Time":
						return "Asia/Tbilisi";
					case "Mountain Standard Time (Mexico)":
						return "America/Chihuahua";
					case "Namibia Standard Time":
						return "Africa/Windhoek";
					case "Pacific Standard Time (Mexico)":
						return "America/Tijuana";
					case "Western Brazilian Standard Time":
						return "America/Rio_Branco";
					case "Azerbaijan Standard Time":
						return "Asia/Baku";
					case "Jordan Standard Time":
						return "Asia/Amman";
					case "Middle East Standard Time":
						return "Asia/Beirut";
					default:
						// this means fall back to GMT offset
						return getSystemGMTOffsetID();
				}
			}

			public static string getSystemGMTOffsetID()
			{
				TimeSpan sp = SystemTimeZone.CurrentTimeZone.GetUtcOffset(DateTime.Now);
				int hours = sp.Hours;
				int mins = sp.Minutes;
				if (hours >= 0 && mins >= 0)
				{
					return String.Format("GMT+{0:D2}:{1:D2}", hours, mins);
				}
				else
				{
					return String.Format("GMT-{0:D2}:{1:D2}", -hours, -mins);
				}
			}
		}
	}
}

namespace IKVM.NativeCode.sun.awt
{
	static class FontDescriptor
	{
		public static void initIDs()
		{
		}
	}
}

namespace IKVM.NativeCode.sun.invoke.anon
{
	static class AnonymousClassLoader
	{
		public static jlClass loadClassInternal(jlClass hostClass, byte[] classFile, object[] patchArray)
		{
			throw new NotImplementedException();
		}
	}
}

namespace IKVM.NativeCode.sun.misc
{
	static class GC
	{
		public static long maxObjectInspectionAge()
		{
			return 0;
		}
	}

	static class MessageUtils
	{
		public static void toStderr(string msg)
		{
			Console.Error.Write(msg);
		}

		public static void toStdout(string msg)
		{
			Console.Out.Write(msg);
		}
	}

	static class MiscHelper
	{
		public static object getAssemblyClassLoader(Assembly asm, object extcl)
		{
			if (extcl == null || asm.IsDefined(typeof(IKVM.Attributes.CustomAssemblyClassLoaderAttribute), false))
			{
				return AssemblyClassLoader.FromAssembly(asm).GetJavaClassLoader();
			}
			return null;
		}
	}

    static class Signal
    {
        /* derived from version 6.0 VC98/include/signal.h */
        private const int SIGINT = 2;       /* interrupt */
        private const int SIGILL = 4;       /* illegal instruction - invalid function image */
        private const int SIGFPE = 8;       /* floating point exception */
        private const int SIGSEGV = 11;     /* segment violation */
        private const int SIGTERM = 15;     /* Software termination signal from kill */
        private const int SIGBREAK = 21;    /* Ctrl-Break sequence */
        private const int SIGABRT = 22;     /* abnormal termination triggered by abort call */

        private static Dictionary<int, long> handler = new Dictionary<int, long>();

        // Delegate type to be used as the Handler Routine for SetConsoleCtrlHandler
        private delegate Boolean ConsoleCtrlDelegate(CtrlTypes CtrlType);

        // Enumerated type for the control messages sent to the handler routine
        private enum CtrlTypes : uint
        {
            CTRL_C_EVENT = 0,
            CTRL_BREAK_EVENT,
            CTRL_CLOSE_EVENT,
            CTRL_LOGOFF_EVENT = 5,
            CTRL_SHUTDOWN_EVENT
        }

        [System.Security.SecurityCritical]
        private sealed class CriticalCtrlHandler : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
        {
            private ConsoleCtrlDelegate consoleCtrlDelegate;
            private bool ok;

            [DllImport("kernel32.dll")]
            private static extern bool SetConsoleCtrlHandler(ConsoleCtrlDelegate e, bool add);

            internal CriticalCtrlHandler()
            {
                consoleCtrlDelegate = new ConsoleCtrlDelegate(ConsoleCtrlCheck);
                ok = SetConsoleCtrlHandler(consoleCtrlDelegate, true);
            }

            [System.Security.SecuritySafeCritical]
            ~CriticalCtrlHandler()
            {
                if (ok)
                {
                    SetConsoleCtrlHandler(consoleCtrlDelegate, false);
                }
            }
        }

        private static object defaultConsoleCtrlDelegate;

        private static bool ConsoleCtrlCheck(CtrlTypes ctrlType)
        {
#if !FIRST_PASS
            switch (ctrlType)
            {
                case CtrlTypes.CTRL_BREAK_EVENT:
                    DumpAllJavaThreads();
                    return true;

            }
#endif
            return false;
        }

#if !FIRST_PASS
		private static void DumpAllJavaThreads()
		{
			Console.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
			global::java.util.Map traces = global::java.lang.Thread.getAllStackTraces();
			Console.WriteLine("Full thread dump IKVM.NET {0} ({1} bit):", JVM.SafeGetAssemblyVersion(Assembly.GetExecutingAssembly()), IntPtr.Size * 8);
			global::java.util.Iterator entries = traces.entrySet().iterator();
			while (entries.hasNext())
			{
				global::java.util.Map.Entry entry = (global::java.util.Map.Entry)entries.next();
				global::java.lang.Thread thread = (global::java.lang.Thread)entry.getKey();
				Console.WriteLine("\n\"{0}\"{1} prio={2} tid=0x{3:X8}", thread.getName(), thread.isDaemon() ? " daemon" : "", thread.getPriority(), thread.getId());
				Console.WriteLine("   java.lang.Thread.State: " + thread.getState());
				global::java.lang.StackTraceElement[] trace = (global::java.lang.StackTraceElement[])entry.getValue();
				for (int i = 0; i < trace.Length; i++)
				{
					Console.WriteLine("\tat {0}", trace[i]);
				}
			}
			Console.WriteLine();
		}
#endif

        public static int findSignal(string sigName)
        {
            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
            {
                switch (sigName)
                {
                    case "ABRT": /* abnormal termination triggered by abort cl */
                        return SIGABRT;
                    case "FPE": /* floating point exception */
                        return SIGFPE;
                    case "SEGV": /* segment violation */
                        return SIGSEGV;
                    case "INT": /* interrupt */
                        return SIGINT;
                    case "TERM": /* software term signal from kill */
                        return SIGTERM;
                    case "BREAK": /* Ctrl-Break sequence */
                        return SIGBREAK;
                    case "ILL": /* illegal instruction */
                        return SIGILL;
                }
            }
            return -1;
        }

		// this is a separate method to be able to catch the SecurityException (for the LinkDemand)
		[System.Security.SecuritySafeCritical]
		private static void RegisterCriticalCtrlHandler()
		{
			defaultConsoleCtrlDelegate = new CriticalCtrlHandler();
		}

        // Register a signal handler
        public static long handle0(int sig, long nativeH)
        {
            long oldHandler;
            handler.TryGetValue(sig, out oldHandler);
            switch (nativeH)
            {
                case 0: // Default Signal Handler
                    if (defaultConsoleCtrlDelegate == null && Environment.OSVersion.Platform == PlatformID.Win32NT)
                    {
						try
						{
							RegisterCriticalCtrlHandler();
						}
						catch (System.Security.SecurityException)
						{
						}
                    }
                    break;
                case 1: // Ignore Signal
                    break;
                case 2: // Custom Signal Handler
                    switch(sig){
                        case SIGBREAK:
                        case SIGFPE:
                            return -1;
                    }
                    break;
            }
            handler[sig] = nativeH;
            return oldHandler;
        }

        public static void raise0(int sig)
        {
#if !FIRST_PASS
            global::java.security.AccessController.doPrivileged(global::ikvm.runtime.Delegates.toPrivilegedAction(delegate
            {
                global::java.lang.Class clazz = typeof(global::sun.misc.Signal);
                global::java.lang.reflect.Method dispatch = clazz.getDeclaredMethod("dispatch", global::java.lang.Integer.TYPE);
                dispatch.setAccessible(true);
                dispatch.invoke(null, global::java.lang.Integer.valueOf(sig));
                return null;
            }));
#endif
        }
    }

	static class NativeSignalHandler
	{
		public static void handle0(int number, long handler)
		{
			throw new NotImplementedException();
		}
	}

	static class Perf
	{
		public static object attach(object thisPerf, string user, int lvmid, int mode)
		{
			throw new NotImplementedException();
		}

		public static void detach(object thisPerf, object bb)
		{
			throw new NotImplementedException();
		}

		public static object createLong(object thisPerf, string name, int variability, int units, long value)
		{
#if FIRST_PASS
			return null;
#else
			return global::java.nio.ByteBuffer.allocate(8);
#endif
		}

		public static object createByteArray(object thisPerf, string name, int variability, int units, byte[] value, int maxLength)
		{
#if FIRST_PASS
			return null;
#else
			return global::java.nio.ByteBuffer.allocate(maxLength).put(value);
#endif
		}

		public static long highResCounter(object thisPerf)
		{
			throw new NotImplementedException();
		}

		public static long highResFrequency(object thisPerf)
		{
			throw new NotImplementedException();
		}

		public static void registerNatives()
		{
		}
	}

	static class Unsafe
	{
		public static void throwException(object thisUnsafe, Exception x)
		{
			throw x;
		}

		public static void ensureClassInitialized(object thisUnsafe, jlClass clazz)
		{
			TypeWrapper tw = TypeWrapper.FromClass(clazz);
			if (!tw.IsArray)
			{
				try
				{
					tw.Finish();
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				tw.RunClassInit();
			}
		}

		[System.Security.SecurityCritical]
		public static object allocateInstance(object thisUnsafe, jlClass clazz)
		{
			TypeWrapper wrapper = TypeWrapper.FromClass(clazz);
			try
			{
				wrapper.Finish();
			}
			catch (RetargetableJavaException x)
			{
				throw x.ToJava();
			}
			return FormatterServices.GetUninitializedObject(wrapper.TypeAsBaseType);
		}

		public static jlClass defineClass(object thisUnsafe, string name, byte[] buf, int offset, int length, jlClassLoader cl, ProtectionDomain pd)
		{
#if FIRST_PASS
			return null;
#else
			return cl.defineClass(name, buf, offset, length, pd);
#endif
		}
	}

	static class Version
	{
		public static string getJvmSpecialVersion()
		{
			throw new NotImplementedException();
		}

		public static string getJdkSpecialVersion()
		{
			throw new NotImplementedException();
		}

		public static bool getJvmVersionInfo()
		{
			throw new NotImplementedException();
		}

		public static void getJdkVersionInfo()
		{
			throw new NotImplementedException();
		}
	}

	static class VM
	{
		public static void initialize()
		{
		}
	}

	static class VMSupport
	{
		public static object initAgentProperties(object props)
		{
			return props;
		}
	}
}

namespace IKVM.NativeCode.sun.net.spi
{
	static class DefaultProxySelector
	{
		public static bool init()
		{
			return true;
		}

		public static object getSystemProxy(object thisDefaultProxySelector, string protocol, string host)
		{
			// TODO on Whidbey we might be able to use System.Net.Configuration.DefaultProxySection.Proxy
			return null;
		}
	}
}

namespace IKVM.NativeCode.sun.nio.fs
{
	static class NetPath
	{
		public static string toRealPathImpl(string path)
		{
#if FIRST_PASS
			return null;
#else
			path = global::java.io.FileSystem.getFileSystem().canonicalize(path);
			if (VirtualFileSystem.IsVirtualFS(path))
			{
				if (VirtualFileSystem.CheckAccess(path, Java_java_io_Win32FileSystem.ACCESS_READ))
				{
					return path;
				}
				throw new global::java.nio.file.NoSuchFileException(path);
			}
			try
			{
				System.IO.File.GetAttributes(path);
				return path;
			}
			catch (System.IO.FileNotFoundException)
			{
				throw new global::java.nio.file.NoSuchFileException(path);
			}
			catch (System.IO.DirectoryNotFoundException)
			{
				throw new global::java.nio.file.NoSuchFileException(path);
			}
			catch (System.UnauthorizedAccessException)
			{
				throw new global::java.nio.file.AccessDeniedException(path);
			}
			catch (System.Security.SecurityException)
			{
				throw new global::java.nio.file.AccessDeniedException(path);
			}
			catch (System.ArgumentException x)
			{
				throw new global::java.nio.file.FileSystemException(path, null, x.Message);
			}
			catch (System.NotSupportedException x)
			{
				throw new global::java.nio.file.FileSystemException(path, null, x.Message);
			}
			catch (System.IO.IOException x)
			{
				throw new global::java.nio.file.FileSystemException(path, null, x.Message);
			}
#endif
		}
	}
}

namespace IKVM.NativeCode.sun.reflect
{
#if !FIRST_PASS
	public interface IReflectionException
	{
		jlIllegalArgumentException GetIllegalArgumentException(object obj);
		jlIllegalArgumentException SetIllegalArgumentException(object obj);
	}
#endif

	// this must be public (due to .NET 4.0 security model)
	public sealed class State
	{
		internal int Value;
	}

	static class Reflection
	{
#if CLASSGC
		private static readonly ConditionalWeakTable<MethodBase, State> isHideFromJavaCache = new ConditionalWeakTable<MethodBase, State>();

		internal static bool IsHideFromJava(MethodBase mb)
		{
			State state = isHideFromJavaCache.GetOrCreateValue(mb);
			if (state.Value == 0)
			{
				state.Value = IsHideFromJavaImpl(mb);
			}
			return state.Value == 1;
		}

		private static int IsHideFromJavaImpl(MethodBase mb)
		{
			if (mb.Name.StartsWith("__<", StringComparison.Ordinal))
			{
				return 1;
			}
			if (mb.IsDefined(typeof(IKVM.Attributes.HideFromJavaAttribute), false) || mb.IsDefined(typeof(IKVM.Attributes.HideFromReflectionAttribute), false))
			{
				return 1;
			}
			return 2;
		}
#else
		private static readonly Dictionary<RuntimeMethodHandle, bool> isHideFromJavaCache = new Dictionary<RuntimeMethodHandle, bool>();

		internal static bool IsHideFromJava(MethodBase mb)
		{
			if (mb.Name.StartsWith("__<", StringComparison.Ordinal))
			{
				return true;
			}
			RuntimeMethodHandle handle;
			try
			{
				handle = mb.MethodHandle;
			}
			catch (InvalidOperationException)
			{
				// DynamicMethods don't have a RuntimeMethodHandle and we always want to hide them anyway
				return true;
			}
			catch (NotSupportedException)
			{
				// DynamicMethods don't have a RuntimeMethodHandle and we always want to hide them anyway
				return true;
			}
			lock (isHideFromJavaCache)
			{
				bool cached;
				if (isHideFromJavaCache.TryGetValue(handle, out cached))
				{
					return cached;
				}
			}
			bool isHide = mb.IsDefined(typeof(IKVM.Attributes.HideFromJavaAttribute), false) || mb.IsDefined(typeof(IKVM.Attributes.HideFromReflectionAttribute), false);
			lock (isHideFromJavaCache)
			{
				isHideFromJavaCache[handle] = isHide;
			}
			return isHide;
		}
#endif

		// NOTE this method is hooked up explicitly through map.xml to prevent inlining of the native stub
		// and tail-call optimization in the native stub.
		public static object getCallerClass(int realFramesToSkip)
		{
#if FIRST_PASS
			return null;
#else
			int i = 3;
			if (realFramesToSkip <= 1)
			{
				i = 1;
				realFramesToSkip = Math.Max(realFramesToSkip + 2, 2);
			}
			realFramesToSkip--;
			for (; ; )
			{
				MethodBase method = new StackFrame(i++, false).GetMethod();
				if (method == null)
				{
					return null;
				}
				Type type = method.DeclaringType;
				// NOTE these checks should be the same as the ones in SecurityManager.getClassContext
				if (IsHideFromJava(method)
					|| type == null
					|| type.Assembly == typeof(object).Assembly
					|| type.Assembly == typeof(Reflection).Assembly
					|| type.Assembly == Java_java_lang_SecurityManager.jniAssembly
					|| type == typeof(jlrMethod)
					|| type == typeof(jlrConstructor))
				{
					continue;
				}
				if (--realFramesToSkip == 0)
				{
					return ClassLoaderWrapper.GetWrapperFromType(type).ClassObject;
				}
			}
#endif
		}

		public static int getClassAccessFlags(jlClass clazz)
		{
			// the mask comes from JVM_RECOGNIZED_CLASS_MODIFIERS in src/hotspot/share/vm/prims/jvm.h
			int mods = (int)TypeWrapper.FromClass(clazz).Modifiers & 0x7631;
			// interface implies abstract
			mods |= (mods & 0x0200) << 1;
			return mods;
		}

		public static bool checkInternalAccess(jlClass currentClass, jlClass memberClass)
		{
			TypeWrapper current = TypeWrapper.FromClass(currentClass);
			TypeWrapper member = TypeWrapper.FromClass(memberClass);
			return member.IsInternal && member.InternalsVisibleTo(current);
		}
	}

	static class ReflectionFactory
	{
#if !FIRST_PASS
		private static object[] ConvertArgs(ClassLoaderWrapper loader, TypeWrapper[] argumentTypes, object[] args)
		{
			object[] nargs = new object[args == null ? 0 : args.Length];
			if (nargs.Length != argumentTypes.Length)
			{
				throw new jlIllegalArgumentException("wrong number of arguments");
			}
			for (int i = 0; i < nargs.Length; i++)
			{
				if (argumentTypes[i].IsPrimitive)
				{
					if (args[i] == null)
					{
						throw new jlIllegalArgumentException("primitive wrapper null");
					}
					nargs[i] = JVM.Unbox(args[i]);
					// NOTE we depend on the fact that the .NET reflection parameter type
					// widening rules are the same as in Java, but to have this work for byte
					// we need to convert byte to sbyte.
					if (nargs[i] is byte && argumentTypes[i] != PrimitiveTypeWrapper.BYTE)
					{
						nargs[i] = (sbyte)(byte)nargs[i];
					}
				}
				else
				{
					if (args[i] != null && !argumentTypes[i].EnsureLoadable(loader).IsInstance(args[i]))
					{
						throw new jlIllegalArgumentException();
					}
					nargs[i] = args[i];
				}
			}
			return nargs;
		}

		private sealed class MethodAccessorImpl : srMethodAccessor
		{
			private readonly MethodWrapper mw;

			internal MethodAccessorImpl(jlrMethod method)
			{
				mw = MethodWrapper.FromMethodOrConstructor(method);
			}

			[IKVM.Attributes.HideFromJava]
			public object invoke(object obj, object[] args, global::ikvm.@@internal.CallerID callerID)
			{
				if (!mw.IsStatic && !mw.DeclaringType.IsInstance(obj))
				{
					if (obj == null)
					{
						throw new jlNullPointerException();
					}
					throw new jlIllegalArgumentException("object is not an instance of declaring class");
				}
				args = ConvertArgs(mw.DeclaringType.GetClassLoader(), mw.GetParameters(), args);
				// if the method is an interface method, we must explicitly run <clinit>,
				// because .NET reflection doesn't
				if (mw.DeclaringType.IsInterface)
				{
					mw.DeclaringType.RunClassInit();
				}
				object retval;
				try
				{
					retval = ((ICustomInvoke)mw).Invoke(obj, args);
				}
				catch (MethodAccessException x)
				{
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
				}
				if (mw.ReturnType.IsPrimitive && mw.ReturnType != PrimitiveTypeWrapper.VOID)
				{
					retval = JVM.Box(retval);
				}
				return retval;
			}
		}

		internal sealed class FastMethodAccessorImpl : srMethodAccessor
		{
			private static readonly MethodInfo valueOfByte;
			private static readonly MethodInfo valueOfBoolean;
			private static readonly MethodInfo valueOfChar;
			private static readonly MethodInfo valueOfShort;
			private static readonly MethodInfo valueOfInt;
			private static readonly MethodInfo valueOfFloat;
			private static readonly MethodInfo valueOfLong;
			private static readonly MethodInfo valueOfDouble;
			private static readonly MethodInfo byteValue;
			private static readonly MethodInfo booleanValue;
			private static readonly MethodInfo charValue;
			private static readonly MethodInfo shortValue;
			private static readonly MethodInfo intValue;
			private static readonly MethodInfo floatValue;
			private static readonly MethodInfo longValue;
			private static readonly MethodInfo doubleValue;
			internal static readonly ConstructorInfo invocationTargetExceptionCtor;
			internal static readonly ConstructorInfo illegalArgumentExceptionCtor;
			internal static readonly MethodInfo get_TargetSite;
			internal static readonly MethodInfo GetCurrentMethod;

			private delegate object Invoker(object obj, object[] args, global::ikvm.@@internal.CallerID callerID);
			private Invoker invoker;

			static FastMethodAccessorImpl()
			{
				valueOfByte = typeof(jlByte).GetMethod("valueOf", new Type[] { typeof(byte) });
				valueOfBoolean = typeof(jlBoolean).GetMethod("valueOf", new Type[] { typeof(bool) });
				valueOfChar = typeof(jlCharacter).GetMethod("valueOf", new Type[] { typeof(char) });
				valueOfShort = typeof(jlShort).GetMethod("valueOf", new Type[] { typeof(short) });
				valueOfInt = typeof(jlInteger).GetMethod("valueOf", new Type[] { typeof(int) });
				valueOfFloat = typeof(jlFloat).GetMethod("valueOf", new Type[] { typeof(float) });
				valueOfLong = typeof(jlLong).GetMethod("valueOf", new Type[] { typeof(long) });
				valueOfDouble = typeof(jlDouble).GetMethod("valueOf", new Type[] { typeof(double) });

				byteValue = typeof(jlByte).GetMethod("byteValue", Type.EmptyTypes);
				booleanValue = typeof(jlBoolean).GetMethod("booleanValue", Type.EmptyTypes);
				charValue = typeof(jlCharacter).GetMethod("charValue", Type.EmptyTypes);
				shortValue = typeof(jlShort).GetMethod("shortValue", Type.EmptyTypes);
				intValue = typeof(jlInteger).GetMethod("intValue", Type.EmptyTypes);
				floatValue = typeof(jlFloat).GetMethod("floatValue", Type.EmptyTypes);
				longValue = typeof(jlLong).GetMethod("longValue", Type.EmptyTypes);
				doubleValue = typeof(jlDouble).GetMethod("doubleValue", Type.EmptyTypes);

				invocationTargetExceptionCtor = typeof(jlrInvocationTargetException).GetConstructor(new Type[] { typeof(Exception) });
				illegalArgumentExceptionCtor = typeof(jlIllegalArgumentException).GetConstructor(Type.EmptyTypes);
				get_TargetSite = typeof(Exception).GetMethod("get_TargetSite");
				GetCurrentMethod = typeof(MethodBase).GetMethod("GetCurrentMethod");
			}

			private sealed class RunClassInit
			{
				private FastMethodAccessorImpl outer;
				private TypeWrapper tw;
				private Invoker invoker;

				internal RunClassInit(FastMethodAccessorImpl outer, TypeWrapper tw, Invoker invoker)
				{
					this.outer = outer;
					this.tw = tw;
					this.invoker = invoker;
				}

				[IKVM.Attributes.HideFromJava]
				internal object invoke(object obj, object[] args, global::ikvm.@@internal.CallerID callerID)
				{
					// FXBUG pre-SP1 a DynamicMethod that calls a static method doesn't trigger the cctor, so we do that explicitly.
					// even on .NET 2.0 SP2, interface method invocations don't run the interface cctor
					// NOTE when testing, please test both the x86 and x64 CLR JIT, because they have different bugs (even on .NET 2.0 SP2)
					tw.RunClassInit();
					outer.invoker = invoker;
					return invoker(obj, args, callerID);
				}
			}

			internal FastMethodAccessorImpl(jlrMethod method, bool nonvirtual)
			{
				MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(method);
				TypeWrapper[] parameters;
				try
				{
					mw.DeclaringType.Finish();
					parameters = mw.GetParameters();
					for (int i = 0; i < parameters.Length; i++)
					{
						// the EnsureLoadable shouldn't fail, because we don't allow a java.lang.reflect.Method
						// to "escape" if it has an unloadable type in the signature
						parameters[i] = parameters[i].EnsureLoadable(mw.DeclaringType.GetClassLoader());
						parameters[i].Finish();
					}
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				mw.ResolveMethod();
				DynamicMethod dm = DynamicMethodUtils.Create("__<Invoker>", mw.DeclaringType.TypeAsBaseType, !mw.IsPublic || !mw.DeclaringType.IsPublic || nonvirtual, typeof(object), new Type[] { typeof(object), typeof(object[]), typeof(global::ikvm.@@internal.CallerID) });
				CodeEmitter ilgen = CodeEmitter.Create(dm);
				CodeEmitterLocal ret = ilgen.DeclareLocal(typeof(object));
				if (!mw.IsStatic)
				{
					// check target for null
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.EmitNullCheck();
				}

				// check args length
				CodeEmitterLabel argsLengthOK = ilgen.DefineLabel();
				if (parameters.Length == 0)
				{
					// zero length array may be null
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.EmitBrfalse(argsLengthOK);
				}
				ilgen.Emit(OpCodes.Ldarg_1);
				ilgen.Emit(OpCodes.Ldlen);
				ilgen.EmitLdc_I4(parameters.Length);
				ilgen.EmitBeq(argsLengthOK);
				ilgen.Emit(OpCodes.Newobj, illegalArgumentExceptionCtor);
				ilgen.Emit(OpCodes.Throw);
				ilgen.MarkLabel(argsLengthOK);

				int thisCount = mw.IsStatic ? 0 : 1;
				CodeEmitterLocal[] args = new CodeEmitterLocal[parameters.Length + thisCount];
				if (!mw.IsStatic)
				{
					args[0] = ilgen.DeclareLocal(mw.DeclaringType.TypeAsSignatureType);
				}
				for (int i = thisCount; i < args.Length; i++)
				{
					args[i] = ilgen.DeclareLocal(parameters[i - thisCount].TypeAsSignatureType);
				}
				ilgen.BeginExceptionBlock();
				if (!mw.IsStatic)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					mw.DeclaringType.EmitCheckcast(ilgen);
					mw.DeclaringType.EmitConvStackTypeToSignatureType(ilgen, null);
					ilgen.Emit(OpCodes.Stloc, args[0]);
				}
				for (int i = thisCount; i < args.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.EmitLdc_I4(i - thisCount);
					ilgen.Emit(OpCodes.Ldelem_Ref);
					TypeWrapper tw = parameters[i - thisCount];
					EmitUnboxArg(ilgen, tw);
					tw.EmitConvStackTypeToSignatureType(ilgen, null);
					ilgen.Emit(OpCodes.Stloc, args[i]);
				}
				CodeEmitterLabel label1 = ilgen.DefineLabel();
				ilgen.EmitLeave(label1);
				ilgen.BeginCatchBlock(typeof(InvalidCastException));
				ilgen.Emit(OpCodes.Newobj, illegalArgumentExceptionCtor);
				ilgen.Emit(OpCodes.Throw);
				ilgen.BeginCatchBlock(typeof(NullReferenceException));
				ilgen.Emit(OpCodes.Newobj, illegalArgumentExceptionCtor);
				ilgen.Emit(OpCodes.Throw);
				ilgen.EndExceptionBlock();

				// this is the actual call
				ilgen.MarkLabel(label1);
				ilgen.BeginExceptionBlock();
				for (int i = 0; i < args.Length; i++)
				{
					if (i == 0 && !mw.IsStatic && (mw.DeclaringType.IsNonPrimitiveValueType || mw.DeclaringType.IsGhost))
					{
						ilgen.Emit(OpCodes.Ldloca, args[i]);
					}
					else
					{
						ilgen.Emit(OpCodes.Ldloc, args[i]);
					}
				}
				if (mw.HasCallerID)
				{
					ilgen.Emit(OpCodes.Ldarg_2);
				}
				if (mw.IsStatic || nonvirtual)
				{
					mw.EmitCall(ilgen);
				}
				else
				{
					mw.EmitCallvirtReflect(ilgen);
				}
				mw.ReturnType.EmitConvSignatureTypeToStackType(ilgen);
				BoxReturnValue(ilgen, mw.ReturnType);
				ilgen.Emit(OpCodes.Stloc, ret);
				CodeEmitterLabel label2 = ilgen.DefineLabel();
				ilgen.EmitLeave(label2);
				ilgen.BeginCatchBlock(typeof(Exception));
				CodeEmitterLabel label = ilgen.DefineLabel();
				CodeEmitterLabel labelWrap = ilgen.DefineLabel();
				if (IntPtr.Size == 8 && nonvirtual)
				{
					// This is a workaround for the x64 JIT, which is completely broken as usual.
					// When MethodBase.GetCurrentMethod() is used in a dynamic method that isn't verifiable,
					// we get an access violation at JIT time. When we're doing a nonvirtual call,
					// the method is not verifiable, so we disable this check (which, at worst, results
					// in any exceptions thrown at the call site being incorrectly wrapped in an InvocationTargetException).
				}
				else
				{
					// If the exception we caught is a jlrInvocationTargetException, we know it must be
					// wrapped, because .NET won't throw that exception and we also cannot check the target site,
					// because it may be the same as us if a method is recursively invoking itself.
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Isinst, typeof(jlrInvocationTargetException));
					ilgen.EmitBrtrue(labelWrap);
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Callvirt, get_TargetSite);
					ilgen.Emit(OpCodes.Call, GetCurrentMethod);
					ilgen.Emit(OpCodes.Ceq);
					ilgen.EmitBrtrue(label);
				}
				ilgen.MarkLabel(labelWrap);
				ilgen.Emit(OpCodes.Ldc_I4_0);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.mapException.MakeGenericMethod(Types.Exception));
				ilgen.Emit(OpCodes.Newobj, invocationTargetExceptionCtor);
				ilgen.MarkLabel(label);
				ilgen.Emit(OpCodes.Throw);
				ilgen.EndExceptionBlock();

				ilgen.MarkLabel(label2);
				ilgen.Emit(OpCodes.Ldloc, ret);
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
				invoker = (Invoker)dm.CreateDelegate(typeof(Invoker));
				if ((mw.IsStatic || mw.DeclaringType.IsInterface) && mw.DeclaringType.HasStaticInitializer)
				{
					invoker = new Invoker(new RunClassInit(this, mw.DeclaringType, invoker).invoke);
				}
			}

			private static void Expand(CodeEmitter ilgen, TypeWrapper type)
			{
				if (type == PrimitiveTypeWrapper.FLOAT)
				{
					ilgen.Emit(OpCodes.Conv_R4);
				}
				else if (type == PrimitiveTypeWrapper.LONG)
				{
					ilgen.Emit(OpCodes.Conv_I8);
				}
				else if (type == PrimitiveTypeWrapper.DOUBLE)
				{
					ilgen.Emit(OpCodes.Conv_R8);
				}
			}

			internal static void EmitUnboxArg(CodeEmitter ilgen, TypeWrapper type)
			{
				if (type == PrimitiveTypeWrapper.BYTE)
				{
					ilgen.Emit(OpCodes.Castclass, typeof(jlByte));
					ilgen.Emit(OpCodes.Call, byteValue);
				}
				else if (type == PrimitiveTypeWrapper.BOOLEAN)
				{
					ilgen.Emit(OpCodes.Castclass, typeof(jlBoolean));
					ilgen.Emit(OpCodes.Call, booleanValue);
				}
				else if (type == PrimitiveTypeWrapper.CHAR)
				{
					ilgen.Emit(OpCodes.Castclass, typeof(jlCharacter));
					ilgen.Emit(OpCodes.Call, charValue);
				}
				else if (type == PrimitiveTypeWrapper.SHORT
					|| type == PrimitiveTypeWrapper.INT
					|| type == PrimitiveTypeWrapper.FLOAT
					|| type == PrimitiveTypeWrapper.LONG
					|| type == PrimitiveTypeWrapper.DOUBLE)
				{
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Isinst, typeof(jlByte));
					CodeEmitterLabel next = ilgen.DefineLabel();
					ilgen.EmitBrfalse(next);
					ilgen.Emit(OpCodes.Castclass, typeof(jlByte));
					ilgen.Emit(OpCodes.Call, byteValue);
					ilgen.Emit(OpCodes.Conv_I1);
					Expand(ilgen, type);
					CodeEmitterLabel done = ilgen.DefineLabel();
					ilgen.EmitBr(done);
					ilgen.MarkLabel(next);
					if (type == PrimitiveTypeWrapper.SHORT)
					{
						ilgen.Emit(OpCodes.Castclass, typeof(jlShort));
						ilgen.Emit(OpCodes.Call, shortValue);
					}
					else
					{
						ilgen.Emit(OpCodes.Dup);
						ilgen.Emit(OpCodes.Isinst, typeof(jlShort));
						next = ilgen.DefineLabel();
						ilgen.EmitBrfalse(next);
						ilgen.Emit(OpCodes.Castclass, typeof(jlShort));
						ilgen.Emit(OpCodes.Call, shortValue);
						Expand(ilgen, type);
						ilgen.EmitBr(done);
						ilgen.MarkLabel(next);
						ilgen.Emit(OpCodes.Dup);
						ilgen.Emit(OpCodes.Isinst, typeof(jlCharacter));
						next = ilgen.DefineLabel();
						ilgen.EmitBrfalse(next);
						ilgen.Emit(OpCodes.Castclass, typeof(jlCharacter));
						ilgen.Emit(OpCodes.Call, charValue);
						Expand(ilgen, type);
						ilgen.EmitBr(done);
						ilgen.MarkLabel(next);
						if (type == PrimitiveTypeWrapper.INT)
						{
							ilgen.Emit(OpCodes.Castclass, typeof(jlInteger));
							ilgen.Emit(OpCodes.Call, intValue);
						}
						else
						{
							ilgen.Emit(OpCodes.Dup);
							ilgen.Emit(OpCodes.Isinst, typeof(jlInteger));
							next = ilgen.DefineLabel();
							ilgen.EmitBrfalse(next);
							ilgen.Emit(OpCodes.Castclass, typeof(jlInteger));
							ilgen.Emit(OpCodes.Call, intValue);
							Expand(ilgen, type);
							ilgen.EmitBr(done);
							ilgen.MarkLabel(next);
							if (type == PrimitiveTypeWrapper.LONG)
							{
								ilgen.Emit(OpCodes.Castclass, typeof(jlLong));
								ilgen.Emit(OpCodes.Call, longValue);
							}
							else
							{
								ilgen.Emit(OpCodes.Dup);
								ilgen.Emit(OpCodes.Isinst, typeof(jlLong));
								next = ilgen.DefineLabel();
								ilgen.EmitBrfalse(next);
								ilgen.Emit(OpCodes.Castclass, typeof(jlLong));
								ilgen.Emit(OpCodes.Call, longValue);
								Expand(ilgen, type);
								ilgen.EmitBr(done);
								ilgen.MarkLabel(next);
								if (type == PrimitiveTypeWrapper.FLOAT)
								{
									ilgen.Emit(OpCodes.Castclass, typeof(jlFloat));
									ilgen.Emit(OpCodes.Call, floatValue);
								}
								else if (type == PrimitiveTypeWrapper.DOUBLE)
								{
									ilgen.Emit(OpCodes.Dup);
									ilgen.Emit(OpCodes.Isinst, typeof(jlFloat));
									next = ilgen.DefineLabel();
									ilgen.EmitBrfalse(next);
									ilgen.Emit(OpCodes.Castclass, typeof(jlFloat));
									ilgen.Emit(OpCodes.Call, floatValue);
									ilgen.EmitBr(done);
									ilgen.MarkLabel(next);
									ilgen.Emit(OpCodes.Castclass, typeof(jlDouble));
									ilgen.Emit(OpCodes.Call, doubleValue);
								}
								else
								{
									throw new InvalidOperationException();
								}
							}
						}
					}
					ilgen.MarkLabel(done);
				}
				else
				{
					type.EmitCheckcast(ilgen);
				}
			}

			private static void BoxReturnValue(CodeEmitter ilgen, TypeWrapper type)
			{
				if (type == PrimitiveTypeWrapper.VOID)
				{
					ilgen.Emit(OpCodes.Ldnull);
				}
				else if (type == PrimitiveTypeWrapper.BYTE)
				{
					ilgen.Emit(OpCodes.Call, valueOfByte);
				}
				else if (type == PrimitiveTypeWrapper.BOOLEAN)
				{
					ilgen.Emit(OpCodes.Call, valueOfBoolean);
				}
				else if (type == PrimitiveTypeWrapper.CHAR)
				{
					ilgen.Emit(OpCodes.Call, valueOfChar);
				}
				else if (type == PrimitiveTypeWrapper.SHORT)
				{
					ilgen.Emit(OpCodes.Call, valueOfShort);
				}
				else if (type == PrimitiveTypeWrapper.INT)
				{
					ilgen.Emit(OpCodes.Call, valueOfInt);
				}
				else if (type == PrimitiveTypeWrapper.FLOAT)
				{
					ilgen.Emit(OpCodes.Call, valueOfFloat);
				}
				else if (type == PrimitiveTypeWrapper.LONG)
				{
					ilgen.Emit(OpCodes.Call, valueOfLong);
				}
				else if (type == PrimitiveTypeWrapper.DOUBLE)
				{
					ilgen.Emit(OpCodes.Call, valueOfDouble);
				}
			}

			[IKVM.Attributes.HideFromJava]
			public object invoke(object obj, object[] args, global::ikvm.@@internal.CallerID callerID)
			{
				try
				{
					return invoker(obj, args, callerID);
				}
				catch (MethodAccessException x)
				{
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
				}
			}
		}

		private sealed class FastConstructorAccessorImpl : srConstructorAccessor
		{
			private delegate object Invoker(object[] args);
			private Invoker invoker;

			internal FastConstructorAccessorImpl(jlrConstructor constructor)
			{
				MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(constructor);
				TypeWrapper[] parameters;
				try
				{
					mw.DeclaringType.Finish();
					parameters = mw.GetParameters();
					for (int i = 0; i < parameters.Length; i++)
					{
						// the EnsureLoadable shouldn't fail, because we don't allow a java.lang.reflect.Method
						// to "escape" if it has an unloadable type in the signature
						parameters[i] = parameters[i].EnsureLoadable(mw.DeclaringType.GetClassLoader());
						parameters[i].Finish();
					}
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				mw.ResolveMethod();
				DynamicMethod dm = DynamicMethodUtils.Create("__<Invoker>", mw.DeclaringType.TypeAsTBD, !mw.IsPublic || !mw.DeclaringType.IsPublic, typeof(object), new Type[] { typeof(object[]) });
				CodeEmitter ilgen = CodeEmitter.Create(dm);
				CodeEmitterLocal ret = ilgen.DeclareLocal(typeof(object));

				// check args length
				CodeEmitterLabel argsLengthOK = ilgen.DefineLabel();
				if (parameters.Length == 0)
				{
					// zero length array may be null
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.EmitBrfalse(argsLengthOK);
				}
				ilgen.Emit(OpCodes.Ldarg_0);
				ilgen.Emit(OpCodes.Ldlen);
				ilgen.EmitLdc_I4(parameters.Length);
				ilgen.EmitBeq(argsLengthOK);
				ilgen.Emit(OpCodes.Newobj, FastMethodAccessorImpl.illegalArgumentExceptionCtor);
				ilgen.Emit(OpCodes.Throw);
				ilgen.MarkLabel(argsLengthOK);

				CodeEmitterLocal[] args = new CodeEmitterLocal[parameters.Length];
				for (int i = 0; i < args.Length; i++)
				{
					args[i] = ilgen.DeclareLocal(parameters[i].TypeAsSignatureType);
				}
				ilgen.BeginExceptionBlock();
				for (int i = 0; i < args.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.EmitLdc_I4(i);
					ilgen.Emit(OpCodes.Ldelem_Ref);
					TypeWrapper tw = parameters[i];
					FastMethodAccessorImpl.EmitUnboxArg(ilgen, tw);
					tw.EmitConvStackTypeToSignatureType(ilgen, null);
					ilgen.Emit(OpCodes.Stloc, args[i]);
				}
				CodeEmitterLabel label1 = ilgen.DefineLabel();
				ilgen.EmitLeave(label1);
				ilgen.BeginCatchBlock(typeof(InvalidCastException));
				ilgen.Emit(OpCodes.Newobj, FastMethodAccessorImpl.illegalArgumentExceptionCtor);
				ilgen.Emit(OpCodes.Throw);
				ilgen.BeginCatchBlock(typeof(NullReferenceException));
				ilgen.Emit(OpCodes.Newobj, FastMethodAccessorImpl.illegalArgumentExceptionCtor);
				ilgen.Emit(OpCodes.Throw);
				ilgen.EndExceptionBlock();

				// this is the actual call
				ilgen.MarkLabel(label1);
				ilgen.BeginExceptionBlock();
				for (int i = 0; i < args.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldloc, args[i]);
				}
				mw.EmitNewobj(ilgen);
				ilgen.Emit(OpCodes.Stloc, ret);
				CodeEmitterLabel label2 = ilgen.DefineLabel();
				ilgen.EmitLeave(label2);
				ilgen.BeginCatchBlock(typeof(Exception));
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Callvirt, FastMethodAccessorImpl.get_TargetSite);
				ilgen.Emit(OpCodes.Call, FastMethodAccessorImpl.GetCurrentMethod);
				ilgen.Emit(OpCodes.Ceq);
				CodeEmitterLabel label = ilgen.DefineLabel();
				ilgen.EmitBrtrue(label);
				ilgen.Emit(OpCodes.Ldc_I4_0);
				ilgen.Emit(OpCodes.Call, ByteCodeHelperMethods.mapException.MakeGenericMethod(Types.Exception));
				ilgen.Emit(OpCodes.Newobj, FastMethodAccessorImpl.invocationTargetExceptionCtor);
				ilgen.MarkLabel(label);
				ilgen.Emit(OpCodes.Throw);
				ilgen.EndExceptionBlock();

				ilgen.MarkLabel(label2);
				ilgen.Emit(OpCodes.Ldloc, ret);
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
				invoker = (Invoker)dm.CreateDelegate(typeof(Invoker));
			}

			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
			{
				try
				{
					return invoker(args);
				}
				catch (MethodAccessException x)
				{
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
				}
			}
		}

		private sealed class FastSerializationConstructorAccessorImpl : srConstructorAccessor
		{
			private static readonly MethodInfo GetTypeFromHandleMethod = typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) });
			private static readonly MethodInfo GetUninitializedObjectMethod = typeof(FormatterServices).GetMethod("GetUninitializedObject", new Type[] { typeof(Type) });
			private delegate object InvokeCtor();
			private InvokeCtor invoker;

			internal FastSerializationConstructorAccessorImpl(jlrConstructor constructorToCall, jlClass classToInstantiate)
			{
				MethodWrapper constructor = MethodWrapper.FromMethodOrConstructor(constructorToCall);
				if (constructor.GetParameters().Length != 0)
				{
					throw new NotImplementedException("Serialization constructor cannot have parameters");
				}
				constructor.Link();
				constructor.ResolveMethod();
				Type type;
				try
				{
					TypeWrapper wrapper = TypeWrapper.FromClass(classToInstantiate);
					wrapper.Finish();
					type = wrapper.TypeAsBaseType;
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				DynamicMethod dm = DynamicMethodUtils.Create("__<SerializationCtor>", constructor.DeclaringType.TypeAsBaseType, true, typeof(object), null);
				CodeEmitter ilgen = CodeEmitter.Create(dm);
				ilgen.Emit(OpCodes.Ldtoken, type);
				ilgen.Emit(OpCodes.Call, GetTypeFromHandleMethod);
				ilgen.Emit(OpCodes.Call, GetUninitializedObjectMethod);
				ilgen.Emit(OpCodes.Dup);
				constructor.EmitCall(ilgen);
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
				invoker = (InvokeCtor)dm.CreateDelegate(typeof(InvokeCtor));
			}

			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
			{
				try
				{
					return invoker();
				}
				catch (MethodAccessException x)
				{
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
				}
			}
		}

		sealed class ActivatorConstructorAccessor : srConstructorAccessor
		{
			private readonly Type type;

			internal ActivatorConstructorAccessor(MethodWrapper mw)
			{
				this.type = mw.DeclaringType.TypeAsBaseType;
			}

			public object newInstance(object[] objarr)
			{
#if FIRST_PASS
				return null;
#else
				if (objarr != null && objarr.Length != 0)
				{
					throw new global::java.lang.IllegalArgumentException();
				}
				try
				{
					return Activator.CreateInstance(type);
				}
				catch (TargetInvocationException x)
				{
					throw new global::java.lang.reflect.InvocationTargetException(global::ikvm.runtime.Util.mapException(x.InnerException));
				}
#endif
			}

			internal static bool IsSuitable(MethodWrapper mw)
			{
				MethodBase mb = mw.GetMethod();
				return mb != null
					&& mb.IsConstructor
					&& mb.IsPublic
					&& mb.DeclaringType.IsPublic
					&& mb.DeclaringType == mw.DeclaringType.TypeAsBaseType
					&& mb.GetParameters().Length == 0;
			}
		}

		private abstract class FieldAccessorImplBase : srFieldAccessor, IReflectionException
		{
			protected static readonly ushort inflationThreshold = 15;
			protected readonly FieldWrapper fw;
			protected readonly bool isFinal;
			protected ushort numInvocations;

			static FieldAccessorImplBase()
			{
				string str = jlSystem.getProperty("ikvm.reflect.field.inflationThreshold");
				int value;
				if (str != null && int.TryParse(str, out value))
				{
					if (value >= ushort.MinValue && value <= ushort.MaxValue)
					{
						inflationThreshold = (ushort)value;
					}
				}
			}

			private FieldAccessorImplBase(FieldWrapper fw, bool overrideAccessCheck)
			{
				this.fw = fw;
				isFinal = (!overrideAccessCheck || fw.IsStatic) && fw.IsFinal;
			}

			private string GetQualifiedFieldName()
			{
				return fw.DeclaringType.Name + "." + fw.Name;
			}

			private string GetFieldTypeName()
			{
				return fw.FieldTypeWrapper.ClassObject.getName();
			}

			public jlIllegalArgumentException GetIllegalArgumentException(object obj)
			{
				// LAME like JDK 6 we return the wrong exception message (talking about setting the field, instead of getting)
				return SetIllegalArgumentException(obj);
			}

			public jlIllegalArgumentException SetIllegalArgumentException(object obj)
			{
				// LAME like JDK 6 we return the wrong exception message (when obj is the object, instead of the value)
				return SetIllegalArgumentException(obj != null ? irUtil.getClassFromObject(obj).getName() : "", "");
			}

			private jlIllegalArgumentException SetIllegalArgumentException(string attemptedType, string attemptedValue)
			{
				return new jlIllegalArgumentException(GetSetMessage(attemptedType, attemptedValue));
			}

			protected jlIllegalAccessException FinalFieldIllegalAccessException(object obj)
			{
				return FinalFieldIllegalAccessException(obj != null ? irUtil.getClassFromObject(obj).getName() : "", "");
			}

			private jlIllegalAccessException FinalFieldIllegalAccessException(string attemptedType, string attemptedValue)
			{
				return new jlIllegalAccessException(GetSetMessage(attemptedType, attemptedValue));
			}

			private jlIllegalArgumentException GetIllegalArgumentException(string type)
			{
				return new jlIllegalArgumentException("Attempt to get " + GetFieldTypeName() + " field \"" + GetQualifiedFieldName() + "\" with illegal data type conversion to " + type);
			}

			// this message comes from sun.reflect.UnsafeFieldAccessorImpl
			private string GetSetMessage(String attemptedType, String attemptedValue)
			{
				String err = "Can not set";
				if (fw.IsStatic)
					err += " static";
				if (isFinal)
					err += " final";
				err += " " + GetFieldTypeName() + " field " + GetQualifiedFieldName() + " to ";
				if (attemptedValue.Length > 0)
				{
					err += "(" + attemptedType + ")" + attemptedValue;
				}
				else
				{
					if (attemptedType.Length > 0)
						err += attemptedType;
					else
						err += "null value";
				}
				return err;
			}

			public virtual bool getBoolean(object obj)
			{
				throw GetIllegalArgumentException("boolean");
			}

			public virtual byte getByte(object obj)
			{
				throw GetIllegalArgumentException("byte");
			}

			public virtual char getChar(object obj)
			{
				throw GetIllegalArgumentException("char");
			}

			public virtual short getShort(object obj)
			{
				throw GetIllegalArgumentException("short");
			}

			public virtual int getInt(object obj)
			{
				throw GetIllegalArgumentException("int");
			}

			public virtual long getLong(object obj)
			{
				throw GetIllegalArgumentException("long");
			}

			public virtual float getFloat(object obj)
			{
				throw GetIllegalArgumentException("float");
			}

			public virtual double getDouble(object obj)
			{
				throw GetIllegalArgumentException("double");
			}

			public virtual void setBoolean(object obj, bool z)
			{
				throw SetIllegalArgumentException("boolean", jlBoolean.toString(z));
			}

			public virtual void setByte(object obj, byte b)
			{
				throw SetIllegalArgumentException("byte", jlByte.toString(b));
			}

			public virtual void setChar(object obj, char c)
			{
				throw SetIllegalArgumentException("char", jlCharacter.toString(c));
			}

			public virtual void setShort(object obj, short s)
			{
				throw SetIllegalArgumentException("short", jlShort.toString(s));
			}

			public virtual void setInt(object obj, int i)
			{
				throw SetIllegalArgumentException("int", jlInteger.toString(i));
			}

			public virtual void setLong(object obj, long l)
			{
				throw SetIllegalArgumentException("long", jlLong.toString(l));
			}

			public virtual void setFloat(object obj, float f)
			{
				throw SetIllegalArgumentException("float", jlFloat.toString(f));
			}

			public virtual void setDouble(object obj, double d)
			{
				throw SetIllegalArgumentException("double", jlDouble.toString(d));
			}

			public abstract object get(object obj);
			public abstract void set(object obj, object value);

			private abstract class FieldAccessor<T> : FieldAccessorImplBase
			{
				protected delegate void Setter(object obj, T value, FieldAccessor<T> acc);
				protected delegate T Getter(object obj, FieldAccessor<T> acc);
				private static readonly Setter initialSetter = lazySet;
				private static readonly Getter initialGetter = lazyGet;
				protected Setter setter = initialSetter;
				protected Getter getter = initialGetter;

				internal FieldAccessor(FieldWrapper fw, bool overrideAccessCheck)
					: base(fw, overrideAccessCheck)
				{
					if (!IsSlowPathCompatible(fw))
					{
						// prevent slow path
						numInvocations = inflationThreshold;
					}
				}

				private bool IsSpecialType(TypeWrapper tw)
				{
					return tw.IsUnloadable
						|| tw.IsNonPrimitiveValueType
						|| tw.IsGhost
						|| tw.IsFakeNestedType;
				}

				private bool IsSlowPathCompatible(FieldWrapper fw)
				{
					if (IsSpecialType(fw.DeclaringType) || IsSpecialType(fw.FieldTypeWrapper) || fw.DeclaringType.IsRemapped)
					{
						return false;
					}
					fw.Link();
					return fw.GetField() != null;
				}

				private static T lazyGet(object obj, FieldAccessor<T> acc)
				{
					return acc.lazyGet(obj);
				}

				private static void lazySet(object obj, T value, FieldAccessor<T> acc)
				{
					acc.lazySet(obj, value);
				}

				private T lazyGet(object obj)
				{
					if (numInvocations < inflationThreshold)
					{
						if (fw.IsStatic)
						{
							obj = null;
						}
						else if (obj == null)
						{
#if !FIRST_PASS
							throw new global::java.lang.NullPointerException();
#endif
						}
						else if (!fw.DeclaringType.IsInstance(obj))
						{
							throw GetIllegalArgumentException(obj);
						}
						if (numInvocations == 0)
						{
							fw.DeclaringType.RunClassInit();
							fw.DeclaringType.Finish();
							fw.ResolveField();
						}
						numInvocations++;
						return (T)fw.GetField().GetValue(obj);
					}
					else
					{
						// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
						// and if we didn't use the slow path, we haven't yet initialized the class
						fw.DeclaringType.RunClassInit();
						getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(T), fw);
						return getter(obj, this);
					}
				}

				private void lazySet(object obj, T value)
				{
					if (isFinal)
					{
						// for some reason Java runs class initialization before checking if the field is final
						fw.DeclaringType.RunClassInit();
						throw FinalFieldIllegalAccessException(JavaBox(value));
					}
					if (numInvocations < inflationThreshold)
					{
						if (fw.IsStatic)
						{
							obj = null;
						}
						else if (obj == null)
						{
#if !FIRST_PASS
							throw new global::java.lang.NullPointerException();
#endif
						}
						else if (!fw.DeclaringType.IsInstance(obj))
						{
							throw SetIllegalArgumentException(obj);
						}
						CheckValue(value);
						if (numInvocations == 0)
						{
							fw.DeclaringType.RunClassInit();
							fw.DeclaringType.Finish();
							fw.ResolveField();
						}
						numInvocations++;
						fw.GetField().SetValue(obj, value);
					}
					else
					{
						// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
						// and if we didn't use the slow path, we haven't yet initialized the class
						fw.DeclaringType.RunClassInit();
						setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(T), fw);
						setter(obj, value, this);
					}
				}

				protected virtual void CheckValue(T value)
				{
				}

				protected abstract object JavaBox(T value);
			}

			private sealed class ByteField : FieldAccessor<byte>
			{
				internal ByteField(FieldWrapper field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
				}

				public sealed override short getShort(object obj)
				{
					return (sbyte)getByte(obj);
				}

				public sealed override int getInt(object obj)
				{
					return (sbyte)getByte(obj);
				}

				public sealed override long getLong(object obj)
				{
					return (sbyte)getByte(obj);
				}

				public sealed override float getFloat(object obj)
				{
					return (sbyte)getByte(obj);
				}

				public sealed override double getDouble(object obj)
				{
					return (sbyte)getByte(obj);
				}

				public sealed override object get(object obj)
				{
					return jlByte.valueOf(getByte(obj));
				}

				public sealed override void set(object obj, object val)
				{
					if (!(val is jlByte))
					{
						throw SetIllegalArgumentException(val);
					}
					setByte(obj, ((jlByte)val).byteValue());
				}

				public sealed override byte getByte(object obj)
				{
					try
					{
						return getter(obj, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				public sealed override void setByte(object obj, byte value)
				{
					try
					{
						setter(obj, value, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				protected sealed override object JavaBox(byte value)
				{
					return jlByte.valueOf(value);
				}
			}

			private sealed class BooleanField : FieldAccessor<bool>
			{
				internal BooleanField(FieldWrapper field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
				}

				public sealed override object get(object obj)
				{
					return jlBoolean.valueOf(getBoolean(obj));
				}

				public sealed override void set(object obj, object val)
				{
					if (!(val is jlBoolean))
					{
						throw SetIllegalArgumentException(val);
					}
					setBoolean(obj, ((jlBoolean)val).booleanValue());
				}

				public sealed override bool getBoolean(object obj)
				{
					try
					{
						return getter(obj, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				public sealed override void setBoolean(object obj, bool value)
				{
					try
					{
						setter(obj, value, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				protected sealed override object JavaBox(bool value)
				{
					return jlBoolean.valueOf(value);
				}
			}

			private sealed class CharField : FieldAccessor<char>
			{
				internal CharField(FieldWrapper field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
				}

				public sealed override int getInt(object obj)
				{
					return getChar(obj);
				}

				public sealed override long getLong(object obj)
				{
					return getChar(obj);
				}

				public sealed override float getFloat(object obj)
				{
					return getChar(obj);
				}

				public sealed override double getDouble(object obj)
				{
					return getChar(obj);
				}

				public sealed override object get(object obj)
				{
					return jlCharacter.valueOf(getChar(obj));
				}

				public sealed override void set(object obj, object val)
				{
					if (val is jlCharacter)
						setChar(obj, ((jlCharacter)val).charValue());
					else
						throw SetIllegalArgumentException(val);
				}

				public sealed override char getChar(object obj)
				{
					try
					{
						return getter(obj, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				public sealed override void setChar(object obj, char value)
				{
					try
					{
						setter(obj, value, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				protected sealed override object JavaBox(char value)
				{
					return jlCharacter.valueOf(value);
				}
			}

			private sealed class ShortField : FieldAccessor<short>
			{
				internal ShortField(FieldWrapper field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
				}

				public sealed override int getInt(object obj)
				{
					return getShort(obj);
				}

				public sealed override long getLong(object obj)
				{
					return getShort(obj);
				}

				public sealed override float getFloat(object obj)
				{
					return getShort(obj);
				}

				public sealed override double getDouble(object obj)
				{
					return getShort(obj);
				}

				public sealed override object get(object obj)
				{
					return jlShort.valueOf(getShort(obj));
				}

				public sealed override void set(object obj, object val)
				{
					if (val is jlByte
						|| val is jlShort)
						setShort(obj, ((jlNumber)val).shortValue());
					else
						throw SetIllegalArgumentException(val);
				}

				public sealed override void setByte(object obj, byte b)
				{
					setShort(obj, (sbyte)b);
				}

				public sealed override short getShort(object obj)
				{
					try
					{
						return getter(obj, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				public sealed override void setShort(object obj, short value)
				{
					try
					{
						setter(obj, value, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				protected sealed override object JavaBox(short value)
				{
					return jlShort.valueOf(value);
				}
			}

			private sealed class IntField : FieldAccessor<int>
			{
				internal IntField(FieldWrapper field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
				}

				public sealed override long getLong(object obj)
				{
					return getInt(obj);
				}

				public sealed override float getFloat(object obj)
				{
					return getInt(obj);
				}

				public sealed override double getDouble(object obj)
				{
					return getInt(obj);
				}

				public sealed override object get(object obj)
				{
					return jlInteger.valueOf(getInt(obj));
				}

				public sealed override void set(object obj, object val)
				{
					if (val is jlByte
						|| val is jlShort
						|| val is jlInteger)
						setInt(obj, ((jlNumber)val).intValue());
					else if (val is jlCharacter)
						setInt(obj, ((jlCharacter)val).charValue());
					else
						throw SetIllegalArgumentException(val);
				}

				public sealed override void setByte(object obj, byte b)
				{
					setInt(obj, (sbyte)b);
				}

				public sealed override void setChar(object obj, char c)
				{
					setInt(obj, c);
				}

				public sealed override void setShort(object obj, short s)
				{
					setInt(obj, s);
				}

				public sealed override int getInt(object obj)
				{
					try
					{
						return getter(obj, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				public sealed override void setInt(object obj, int value)
				{
					try
					{
						setter(obj, value, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				protected sealed override object JavaBox(int value)
				{
					return jlInteger.valueOf(value);
				}
			}

			private sealed class FloatField : FieldAccessor<float>
			{
				internal FloatField(FieldWrapper field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
				}

				public sealed override double getDouble(object obj)
				{
					return getFloat(obj);
				}

				public sealed override object get(object obj)
				{
					return jlFloat.valueOf(getFloat(obj));
				}

				public sealed override void set(object obj, object val)
				{
					if (val is jlFloat
						|| val is jlByte
						|| val is jlShort
						|| val is jlInteger
						|| val is jlLong)
						setFloat(obj, ((jlNumber)val).floatValue());
					else if (val is jlCharacter)
						setFloat(obj, ((jlCharacter)val).charValue());
					else
						throw SetIllegalArgumentException(val);
				}

				public sealed override void setByte(object obj, byte b)
				{
					setFloat(obj, (sbyte)b);
				}

				public sealed override void setChar(object obj, char c)
				{
					setFloat(obj, c);
				}

				public sealed override void setShort(object obj, short s)
				{
					setFloat(obj, s);
				}

				public sealed override void setInt(object obj, int i)
				{
					setFloat(obj, i);
				}

				public sealed override void setLong(object obj, long l)
				{
					setFloat(obj, l);
				}

				public sealed override float getFloat(object obj)
				{
					try
					{
						return getter(obj, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				public sealed override void setFloat(object obj, float value)
				{
					try
					{
						setter(obj, value, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				protected sealed override object JavaBox(float value)
				{
					return jlFloat.valueOf(value);
				}
			}

			private sealed class LongField : FieldAccessor<long>
			{
				internal LongField(FieldWrapper field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
				}

				public sealed override float getFloat(object obj)
				{
					return getLong(obj);
				}

				public sealed override double getDouble(object obj)
				{
					return getLong(obj);
				}

				public sealed override object get(object obj)
				{
					return jlLong.valueOf(getLong(obj));
				}

				public sealed override void set(object obj, object val)
				{
					if (val is jlLong
						|| val is jlByte
						|| val is jlShort
						|| val is jlInteger)
						setLong(obj, ((jlNumber)val).longValue());
					else if (val is jlCharacter)
						setLong(obj, ((jlCharacter)val).charValue());
					else
						throw SetIllegalArgumentException(val);
				}

				public sealed override void setByte(object obj, byte b)
				{
					setLong(obj, (sbyte)b);
				}

				public sealed override void setChar(object obj, char c)
				{
					setLong(obj, c);
				}

				public sealed override void setShort(object obj, short s)
				{
					setLong(obj, s);
				}

				public sealed override void setInt(object obj, int i)
				{
					setLong(obj, i);
				}

				public sealed override long getLong(object obj)
				{
					try
					{
						return getter(obj, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				public sealed override void setLong(object obj, long value)
				{
					try
					{
						setter(obj, value, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				protected sealed override object JavaBox(long value)
				{
					return jlLong.valueOf(value);
				}
			}

			private sealed class DoubleField : FieldAccessor<double>
			{
				internal DoubleField(FieldWrapper field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
				}

				public sealed override object get(object obj)
				{
					return jlDouble.valueOf(getDouble(obj));
				}

				public sealed override void set(object obj, object val)
				{
					if (val is jlDouble
						|| val is jlFloat
						|| val is jlByte
						|| val is jlShort
						|| val is jlInteger
						|| val is jlLong)
						setDouble(obj, ((jlNumber)val).doubleValue());
					else if (val is jlCharacter)
						setDouble(obj, ((jlCharacter)val).charValue());
					else
						throw SetIllegalArgumentException(val);
				}

				public sealed override void setByte(object obj, byte b)
				{
					setDouble(obj, (sbyte)b);
				}

				public sealed override void setChar(object obj, char c)
				{
					setDouble(obj, c);
				}

				public sealed override void setShort(object obj, short s)
				{
					setDouble(obj, s);
				}

				public sealed override void setInt(object obj, int i)
				{
					setDouble(obj, i);
				}

				public sealed override void setLong(object obj, long l)
				{
					setDouble(obj, l);
				}

				public sealed override void setFloat(object obj, float f)
				{
					setDouble(obj, f);
				}

				public sealed override double getDouble(object obj)
				{
					try
					{
						return getter(obj, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				public sealed override void setDouble(object obj, double value)
				{
					try
					{
						setter(obj, value, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				protected sealed override object JavaBox(double value)
				{
					return jlDouble.valueOf(value);
				}
			}

			private sealed class ObjectField : FieldAccessor<object>
			{
				internal ObjectField(FieldWrapper field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
				}

				protected sealed override void CheckValue(object value)
				{
					if (value != null && !fw.FieldTypeWrapper.IsInstance(value))
					{
						throw SetIllegalArgumentException(value);
					}
				}

				public sealed override object get(object obj)
				{
					try
					{
						return getter(obj, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				public sealed override void set(object obj, object value)
				{
					try
					{
						setter(obj, value, this);
					}
					catch (FieldAccessException x)
					{
						throw new jlIllegalAccessException().initCause(x);
					}
				}

				protected sealed override object JavaBox(object value)
				{
					return value;
				}
			}

			private Delegate GenerateFastGetter(Type delegateType, Type fieldType, FieldWrapper fw)
			{
				TypeWrapper fieldTypeWrapper;
				try
				{
					fieldTypeWrapper = fw.FieldTypeWrapper.EnsureLoadable(fw.DeclaringType.GetClassLoader());
					fieldTypeWrapper.Finish();
					fw.DeclaringType.Finish();
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				fw.ResolveField();
				DynamicMethod dm = DynamicMethodUtils.Create("__<Getter>", fw.DeclaringType.TypeAsBaseType, !fw.IsPublic || !fw.DeclaringType.IsPublic, fieldType, new Type[] { typeof(IReflectionException), typeof(object), typeof(object) });
				CodeEmitter ilgen = CodeEmitter.Create(dm);
				if (fw.IsStatic)
				{
					fw.EmitGet(ilgen);
					fieldTypeWrapper.EmitConvSignatureTypeToStackType(ilgen);
				}
				else
				{
					ilgen.BeginExceptionBlock();
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Castclass, fw.DeclaringType.TypeAsBaseType);
					fw.EmitGet(ilgen);
					fieldTypeWrapper.EmitConvSignatureTypeToStackType(ilgen);
					CodeEmitterLocal local = ilgen.DeclareLocal(fieldType);
					ilgen.Emit(OpCodes.Stloc, local);
					CodeEmitterLabel label = ilgen.DefineLabel();
					ilgen.EmitLeave(label);
					ilgen.BeginCatchBlock(typeof(InvalidCastException));
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Callvirt, typeof(IReflectionException).GetMethod("GetIllegalArgumentException"));
					ilgen.Emit(OpCodes.Throw);
					ilgen.EndExceptionBlock();
					ilgen.MarkLabel(label);
					ilgen.Emit(OpCodes.Ldloc, local);
				}
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
				return dm.CreateDelegate(delegateType, this);
			}

			private Delegate GenerateFastSetter(Type delegateType, Type fieldType, FieldWrapper fw)
			{
				TypeWrapper fieldTypeWrapper;
				try
				{
					fieldTypeWrapper = fw.FieldTypeWrapper.EnsureLoadable(fw.DeclaringType.GetClassLoader());
					fieldTypeWrapper.Finish();
					fw.DeclaringType.Finish();
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				fw.ResolveField();
				DynamicMethod dm = DynamicMethodUtils.Create("__<Setter>", fw.DeclaringType.TypeAsBaseType, !fw.IsPublic || !fw.DeclaringType.IsPublic, null, new Type[] { typeof(IReflectionException), typeof(object), fieldType, typeof(object) });
				CodeEmitter ilgen = CodeEmitter.Create(dm);
				if (fw.IsStatic)
				{
					if (fieldType == typeof(object))
					{
						ilgen.BeginExceptionBlock();
						ilgen.Emit(OpCodes.Ldarg_2);
						fieldTypeWrapper.EmitCheckcast(ilgen);
						fieldTypeWrapper.EmitConvStackTypeToSignatureType(ilgen, null);
						fw.EmitSet(ilgen);
						CodeEmitterLabel label = ilgen.DefineLabel();
						ilgen.EmitLeave(label);
						ilgen.BeginCatchBlock(typeof(InvalidCastException));
						ilgen.Emit(OpCodes.Ldarg_0);
						ilgen.Emit(OpCodes.Ldarg_1);
						ilgen.Emit(OpCodes.Callvirt, typeof(IReflectionException).GetMethod("SetIllegalArgumentException"));
						ilgen.Emit(OpCodes.Throw);
						ilgen.EndExceptionBlock();
						ilgen.MarkLabel(label);
					}
					else
					{
						ilgen.Emit(OpCodes.Ldarg_2);
						fw.EmitSet(ilgen);
					}
				}
				else
				{
					ilgen.BeginExceptionBlock();
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Castclass, fw.DeclaringType.TypeAsBaseType);
					ilgen.Emit(OpCodes.Ldarg_2);
					if (fieldType == typeof(object))
					{
						fieldTypeWrapper.EmitCheckcast(ilgen);
					}
					fieldTypeWrapper.EmitConvStackTypeToSignatureType(ilgen, null);
					fw.EmitSet(ilgen);
					CodeEmitterLabel label = ilgen.DefineLabel();
					ilgen.EmitLeave(label);
					ilgen.BeginCatchBlock(typeof(InvalidCastException));
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Callvirt, typeof(IReflectionException).GetMethod("SetIllegalArgumentException"));
					ilgen.Emit(OpCodes.Throw);
					ilgen.EndExceptionBlock();
					ilgen.MarkLabel(label);
				}
				ilgen.Emit(OpCodes.Ret);
				ilgen.DoEmit();
				return dm.CreateDelegate(delegateType, this);
			}

			internal static FieldAccessorImplBase Create(FieldWrapper field, bool overrideAccessCheck)
			{
				TypeWrapper type = field.FieldTypeWrapper;
				if (type.IsPrimitive)
				{
					if (type == PrimitiveTypeWrapper.BYTE)
					{
						return new ByteField(field, overrideAccessCheck);
					}
					if (type == PrimitiveTypeWrapper.BOOLEAN)
					{
						return new BooleanField(field, overrideAccessCheck);
					}
					if (type == PrimitiveTypeWrapper.CHAR)
					{
						return new CharField(field, overrideAccessCheck);
					}
					if (type == PrimitiveTypeWrapper.SHORT)
					{
						return new ShortField(field, overrideAccessCheck);
					}
					if (type == PrimitiveTypeWrapper.INT)
					{
						return new IntField(field, overrideAccessCheck);
					}
					if (type == PrimitiveTypeWrapper.FLOAT)
					{
						return new FloatField(field, overrideAccessCheck);
					}
					if (type == PrimitiveTypeWrapper.LONG)
					{
						return new LongField(field, overrideAccessCheck);
					}
					if (type == PrimitiveTypeWrapper.DOUBLE)
					{
						return new DoubleField(field, overrideAccessCheck);
					}
					throw new InvalidOperationException("field type: " + type);
				}
				else
				{
					return new ObjectField(field, overrideAccessCheck);
				}
			}
		}
#endif

		public static object newFieldAccessor(object thisFactory, object field, bool overrideAccessCheck)
		{
#if FIRST_PASS
			return null;
#else
			return FieldAccessorImplBase.Create(FieldWrapper.FromField(field), overrideAccessCheck);
#endif
		}

#if !FIRST_PASS
		internal static global::sun.reflect.FieldAccessor NewFieldAccessorJNI(FieldWrapper field)
		{
			return FieldAccessorImplBase.Create(field, true);
		}
#endif

		public static object newMethodAccessor(object thisFactory, object method)
		{
#if FIRST_PASS
			return null;
#else
			jlrMethod m = (jlrMethod)method;
			MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(method);
			if (mw is ICustomInvoke)
			{
				return new MethodAccessorImpl(m);
			}
			else
			{
				return new FastMethodAccessorImpl(m, false);
			}
#endif
		}

		public static object newConstructorAccessor0(object thisFactory, object constructor)
		{
#if FIRST_PASS
			return null;
#else
			jlrConstructor cons = (jlrConstructor)constructor;
			MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(constructor);
			if (ActivatorConstructorAccessor.IsSuitable(mw))
			{
				// we special case public default constructors, because in that case using Activator.CreateInstance()
				// is almost as fast as FastConstructorAccessorImpl, but it saves us significantly in working set and
				// startup time (because often during startup a sun.nio.cs.* encoder is instantiated using reflection)
				return new ActivatorConstructorAccessor(mw);
			}
			else
			{
				return new FastConstructorAccessorImpl(cons);
			}
#endif
		}

		public static object newConstructorAccessorForSerialization(jlClass classToInstantiate, jlrConstructor constructorToCall)
		{
#if FIRST_PASS
			return null;
#else
			try
			{
				return new FastSerializationConstructorAccessorImpl(constructorToCall, classToInstantiate);
			}
			catch (System.Security.SecurityException x)
			{
				throw new global::java.lang.SecurityException(x.Message, irUtil.mapException(x));
			}
#endif
		}
	}

	static class ConstantPool
	{
		public static int getSize0(object thisConstantPool, object constantPoolOop)
		{
			throw new NotImplementedException();
		}

		public static object getClassAt0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static object getClassAtIfLoaded0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static object getMethodAt0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static object getMethodAtIfLoaded0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static object getFieldAt0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static object getFieldAtIfLoaded0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static string[] getMemberRefInfoAt0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static int getIntAt0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static long getLongAt0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static float getFloatAt0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static double getDoubleAt0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static string getStringAt0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}

		public static string getUTF8At0(object thisConstantPool, object constantPoolOop, int index)
		{
			throw new NotImplementedException();
		}
	}
}

namespace IKVM.NativeCode.sun.rmi.server
{
	static class MarshalInputStream
	{
		public static object latestUserDefinedLoader()
		{
			return Java_java_io_ObjectInputStream.latestUserDefinedLoader();
		}
	}
}

namespace IKVM.NativeCode.sun.security.provider
{
	static class NativeSeedGenerator
	{
		public static bool nativeGenerateSeed(byte[] result)
		{
			try
			{
				System.Security.Cryptography.RNGCryptoServiceProvider csp = new System.Security.Cryptography.RNGCryptoServiceProvider();
				csp.GetBytes(result);
				return true;
			}
			catch (System.Security.Cryptography.CryptographicException)
			{
				return false;
			}
		}
	}
}

namespace IKVM.NativeCode.com.sun.java.util.jar.pack
{
	static class NativeUnpack
	{
		public static void initIDs()
		{
		}

		public static long start(object thisNativeUnpack, object buf, long offset)
		{
			throw new NotImplementedException();
		}

		public static bool getNextFile(object thisNativeUnpack, object[] parts)
		{
			throw new NotImplementedException();
		}

		public static object getUnusedInput(object thisNativeUnpack)
		{
			throw new NotImplementedException();
		}

		public static long finish(object thisNativeUnpack)
		{
			throw new NotImplementedException();
		}

		public static bool setOption(object thisNativeUnpack, string opt, string value)
		{
			throw new NotImplementedException();
		}

		public static string getOption(object thisNativeUnpack, string opt)
		{
			throw new NotImplementedException();
		}
	}
}

namespace IKVM.NativeCode.com.sun.security.auth.module
{
	using System.Security.Principal;

	static class NTSystem
	{
		public static void getCurrent(object thisObj, bool debug)
		{
			WindowsIdentity id = WindowsIdentity.GetCurrent();
			string[] name = id.Name.Split('\\');
			SetField(thisObj, "userName", name[1]);
			SetField(thisObj, "domain", name[0]);
			SetField(thisObj, "domainSID", id.User.AccountDomainSid.Value);
			SetField(thisObj, "userSID", id.User.Value);
			string[] groups = new string[id.Groups.Count];
			for (int i = 0; i < groups.Length; i++)
			{
				groups[i] = id.Groups[i].Value;
			}
			SetField(thisObj, "groupIDs", groups);
			// HACK it turns out that Groups[0] is the primary group, but AFAIK this is not documented anywhere
			SetField(thisObj, "primaryGroupID", groups[0]);
		}

		private static void SetField(object thisObj, string field, object value)
		{
			thisObj.GetType().GetField(field, BindingFlags.NonPublic | BindingFlags.Instance).SetValue(thisObj, value);
		}

		public static long getImpersonationToken0(object thisObj)
		{
			return WindowsIdentity.GetCurrent().Token.ToInt64();
		}
	}

	static class SolarisSystem
	{
		public static void getSolarisInfo(object thisObj)
		{
			throw new NotImplementedException();
		}
	}

	static class UnixSystem
	{
		public static void getUnixInfo(object thisObj)
		{
			throw new NotImplementedException();
		}
	}
}

namespace IKVM.NativeCode.com.sun.media.sound
{
	static class JDK13Services
	{
		public static string getDefaultProviderClassName(object deviceClass)
		{
			return null;
		}

		public static string getDefaultInstanceName(object deviceClass)
		{
			return null;
		}

		public static object getProviders(object providerClass)
		{
#if FIRST_PASS
			return null;
#else
			return new global::java.util.ArrayList();
#endif
		}
	}
}

namespace IKVM.NativeCode.java.awt
{
	static class AWTEvent
	{
		public static void initIDs() { }
		public static void nativeSetSource(object thisObj, object peer){ }
	}
	
	static class Button
	{
		public static void initIDs() { }
	}
	
	static class Checkbox
	{
		public static void initIDs() { }
	}
	
	static class CheckboxMenuItem
	{
		public static void initIDs() { }
	}
	
	static class Color
	{
		public static void initIDs() { }
	}
	
	static class Component
	{
		public static void initIDs() { }
	}
	
	static class Container
	{
		public static void initIDs() { }
	}
	
	static class Cursor
	{
		public static void initIDs() { }
		public static void finalizeImpl(Int64 pData){ }
	}
	
	static class Dialog
	{
		public static void initIDs() { }
	}
	
	static class Dimension
	{
		public static void initIDs() { }
	}
	
	static class Event
	{
		public static void initIDs() { }
	}
	
	static class FileDialog
	{
		public static void initIDs() { }
	}
	
	static class Frame
	{
		public static void initIDs() { }
	}
	
	static class FontMetrics
	{
		public static void initIDs() { }
	}
	
	static class Insets
	{
		public static void initIDs() { }
	}
	
	static class KeyboardFocusManager
	{
		public static void initIDs() { }
	}
	
	static class Label
	{
		public static void initIDs() { }
	}
	
	static class Menu
	{
		public static void initIDs() { }
	}
	
	static class MenuBar
	{
		public static void initIDs() { }
	}
	
	static class MenuComponent
	{
		public static void initIDs() { }
	}
	
	static class MenuItem
	{
		public static void initIDs() { }
	}
	
	static class Rectangle
	{
		public static void initIDs() { }
	}
	
	static class Scrollbar
	{
		public static void initIDs() { }
	}
	
	static class ScrollPane
	{
		public static void initIDs() { }
	}
	
	static class ScrollPaneAdjustable
	{
		public static void initIDs() { }
	}
	
	static class SplashScreen
	{
	    public static void _update(long splashPtr, int[] data, int x, int y, int width, int height, int scanlineStride){}
		public static bool _isVisible(long splashPtr){return false;}
		public static object _getBounds(long splashPtr){return null;}
		public static long _getInstance(){return 0;}
		public static void _close(long splashPtr){}
		public static String _getImageFileName(long splashPtr){return null;}
		public static String _getImageJarName(long splashPtr){return null;}
		public static bool _setImageData(long splashPtr, byte[] data){return false;}
	}
	
	static class TextArea
	{
		public static void initIDs() { }
	}
	
	static class TextField
	{
		public static void initIDs() { }
	}
	
	static class Toolkit
	{
		public static void initIDs() { }
	}
	
	static class TrayIcon
	{
		public static void initIDs() { }
	}
	
	static class Window
	{
		public static void initIDs() { }
	}
}

namespace IKVM.NativeCode.java.awt.@@event
{
	static class InputEvent
	{
		public static void initIDs() { }
	}

	static class MouseEvent
	{
		public static void initIDs() { }
	}

	static class KeyEvent
	{
		public static void initIDs() { }
	}
}

namespace IKVM.NativeCode.java.awt.image
{
	static class ColorModel
	{
		public static void initIDs() { }
	}

	static class ComponentSampleModel
	{
		public static void initIDs() { }
	}

	static class Kernel
	{
		public static void initIDs() { }
	}

	static class Raster
	{
		public static void initIDs() { }
	}

	static class SinglePixelPackedSampleModel
	{
		public static void initIDs() { }
	}

	static class SampleModel
	{
		public static void initIDs() { }
	}
}@


1.309
log
@Moved java.lang and java.lang.reflect native methods into separate files.
@
text
@@


1.308
log
@Moved java.io native methods to separate source file and use "new style" native methods.
@
text
@a371 2038

		namespace reflect
		{
			static class Array
			{
#if FIRST_PASS
			public static int getLength(object arrayObj)
			{
				return 0;
			}

			public static object get(object arrayObj, int index)
			{
				return null;
			}

			public static bool getBoolean(object arrayObj, int index)
			{
				return false;
			}

			public static byte getByte(object arrayObj, int index)
			{
				return 0;
			}

			public static char getChar(object arrayObj, int index)
			{
				return '\u0000';
			}

			public static short getShort(object arrayObj, int index)
			{
				return 0;
			}

			public static int getInt(object arrayObj, int index)
			{
				return 0;
			}

			public static float getFloat(object arrayObj, int index)
			{
				return 0;
			}

			public static long getLong(object arrayObj, int index)
			{
				return 0;
			}

			public static double getDouble(object arrayObj, int index)
			{
				return 0;
			}

			public static void set(object arrayObj, int index, object value)
			{
			}

			public static void setBoolean(object arrayObj, int index, bool value)
			{
			}

			public static void setByte(object arrayObj, int index, byte value)
			{
			}

			public static void setChar(object arrayObj, int index, char value)
			{
			}

			public static void setShort(object arrayObj, int index, short value)
			{
			}

			public static void setInt(object arrayObj, int index, int value)
			{
			}

			public static void setFloat(object arrayObj, int index, float value)
			{
			}

			public static void setLong(object arrayObj, int index, long value)
			{
			}

			public static void setDouble(object arrayObj, int index, double value)
			{
			}

			public static object newArray(jlClass componentType, int length)
			{
				return null;
			}

			public static object multiNewArray(jlClass componentType, int[] dimensions)
			{
				return null;
			}
#else
				private static SystemArray CheckArray(object arrayObj)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					SystemArray arr = arrayObj as SystemArray;
					if (arr != null)
					{
						return arr;
					}
					throw new jlIllegalArgumentException("Argument is not an array");
				}

				public static int getLength(object arrayObj)
				{
					return CheckArray(arrayObj).Length;
				}

				public static object get(object arrayObj, int index)
				{
					SystemArray arr = CheckArray(arrayObj);
					if (index < 0 || index >= arr.Length)
					{
						throw new jlArrayIndexOutOfBoundsException();
					}
					// We need to look at the actual type here, because "is" or "as"
					// will convert enums to their underlying type and unsigned integral types
					// to their signed counter parts.
					Type type = arrayObj.GetType();
					if (type == typeof(bool[]))
					{
						return jlBoolean.valueOf(((bool[])arr)[index]);
					}
					if (type == typeof(byte[]))
					{
						return jlByte.valueOf(((byte[])arr)[index]);
					}
					if (type == typeof(short[]))
					{
						return jlShort.valueOf(((short[])arr)[index]);
					}
					if (type == typeof(char[]))
					{
						return jlCharacter.valueOf(((char[])arr)[index]);
					}
					if (type == typeof(int[]))
					{
						return jlInteger.valueOf(((int[])arr)[index]);
					}
					if (type == typeof(float[]))
					{
						return jlFloat.valueOf(((float[])arr)[index]);
					}
					if (type == typeof(long[]))
					{
						return jlLong.valueOf(((long[])arr)[index]);
					}
					if (type == typeof(double[]))
					{
						return jlDouble.valueOf(((double[])arr)[index]);
					}
					return arr.GetValue(index);
				}

				public static bool getBoolean(object arrayObj, int index)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					bool[] arr = arrayObj as bool[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						return arr[index];
					}
					throw new jlIllegalArgumentException("argument type mismatch");
				}

				public static byte getByte(object arrayObj, int index)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					byte[] arr = arrayObj as byte[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						return arr[index];
					}
					throw new jlIllegalArgumentException("argument type mismatch");
				}

				public static char getChar(object arrayObj, int index)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					char[] arr = arrayObj as char[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						return arr[index];
					}
					throw new jlIllegalArgumentException("argument type mismatch");
				}

				public static short getShort(object arrayObj, int index)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					short[] arr = arrayObj as short[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						return arr[index];
					}
					return (sbyte)getByte(arrayObj, index);
				}

				public static int getInt(object arrayObj, int index)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					int[] arr1 = arrayObj as int[];
					if (arr1 != null)
					{
						if (index < 0 || index >= arr1.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						return arr1[index];
					}
					char[] arr2 = arrayObj as char[];
					if (arr2 != null)
					{
						if (index < 0 || index >= arr2.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						return arr2[index];
					}
					return getShort(arrayObj, index);
				}

				public static float getFloat(object arrayObj, int index)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					float[] arr = arrayObj as float[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						return arr[index];
					}
					return getLong(arrayObj, index);
				}

				public static long getLong(object arrayObj, int index)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					long[] arr = arrayObj as long[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						return arr[index];
					}
					return getInt(arrayObj, index);
				}

				public static double getDouble(object arrayObj, int index)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					double[] arr = arrayObj as double[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						return arr[index];
					}
					return getFloat(arrayObj, index);
				}

				public static void set(object arrayObj, int index, object value)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					Type type = arrayObj.GetType();
					if (ReflectUtil.IsVector(type) && ClassLoaderWrapper.GetWrapperFromType(type.GetElementType()).IsPrimitive)
					{
						jlBoolean booleanValue = value as jlBoolean;
						if (booleanValue != null)
						{
							setBoolean(arrayObj, index, booleanValue.booleanValue());
							return;
						}
						jlByte byteValue = value as jlByte;
						if (byteValue != null)
						{
							setByte(arrayObj, index, byteValue.byteValue());
							return;
						}
						jlCharacter charValue = value as jlCharacter;
						if (charValue != null)
						{
							setChar(arrayObj, index, charValue.charValue());
							return;
						}
						jlShort shortValue = value as jlShort;
						if (shortValue != null)
						{
							setShort(arrayObj, index, shortValue.shortValue());
							return;
						}
						jlInteger intValue = value as jlInteger;
						if (intValue != null)
						{
							setInt(arrayObj, index, intValue.intValue());
							return;
						}
						jlFloat floatValue = value as jlFloat;
						if (floatValue != null)
						{
							setFloat(arrayObj, index, floatValue.floatValue());
							return;
						}
						jlLong longValue = value as jlLong;
						if (longValue != null)
						{
							setLong(arrayObj, index, longValue.longValue());
							return;
						}
						jlDouble doubleValue = value as jlDouble;
						if (doubleValue != null)
						{
							setDouble(arrayObj, index, doubleValue.doubleValue());
							return;
						}
					}
					try
					{
						CheckArray(arrayObj).SetValue(value, index);
					}
					catch (InvalidCastException)
					{
						throw new jlIllegalArgumentException("argument type mismatch");
					}
					catch (IndexOutOfRangeException)
					{
						throw new jlArrayIndexOutOfBoundsException();
					}
				}

				public static void setBoolean(object arrayObj, int index, bool value)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					bool[] arr = arrayObj as bool[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						arr[index] = value;
					}
					else
					{
						throw new jlIllegalArgumentException("argument type mismatch");
					}
				}

				public static void setByte(object arrayObj, int index, byte value)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					byte[] arr = arrayObj as byte[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						arr[index] = value;
					}
					else
					{
						setShort(arrayObj, index, (sbyte)value);
					}
				}

				public static void setChar(object arrayObj, int index, char value)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					char[] arr = arrayObj as char[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						arr[index] = value;
					}
					else
					{
						setInt(arrayObj, index, value);
					}
				}

				public static void setShort(object arrayObj, int index, short value)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					short[] arr = arrayObj as short[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						arr[index] = value;
					}
					else
					{
						setInt(arrayObj, index, value);
					}
				}

				public static void setInt(object arrayObj, int index, int value)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					int[] arr = arrayObj as int[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						arr[index] = value;
					}
					else
					{
						setLong(arrayObj, index, value);
					}
				}

				public static void setFloat(object arrayObj, int index, float value)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					float[] arr = arrayObj as float[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						arr[index] = value;
					}
					else
					{
						setDouble(arrayObj, index, value);
					}
				}

				public static void setLong(object arrayObj, int index, long value)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					long[] arr = arrayObj as long[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						arr[index] = value;
					}
					else
					{
						setFloat(arrayObj, index, value);
					}
				}

				public static void setDouble(object arrayObj, int index, double value)
				{
					if (arrayObj == null)
					{
						throw new jlNullPointerException();
					}
					double[] arr = arrayObj as double[];
					if (arr != null)
					{
						if (index < 0 || index >= arr.Length)
						{
							throw new jlArrayIndexOutOfBoundsException();
						}
						arr[index] = value;
					}
					else
					{
						throw new jlIllegalArgumentException("argument type mismatch");
					}
				}

				public static object newArray(jlClass componentType, int length)
				{
					if (componentType == null)
					{
						throw new jlNullPointerException();
					}
					if (componentType == jlVoid.TYPE)
					{
						throw new jlIllegalArgumentException();
					}
					if (length < 0)
					{
						throw new jlNegativeArraySizeException();
					}
					try
					{
						TypeWrapper wrapper = TypeWrapper.FromClass(componentType);
						wrapper.Finish();
						object obj = SystemArray.CreateInstance(wrapper.TypeAsArrayType, length);
						if (wrapper.IsGhost || wrapper.IsGhostArray)
						{
							IKVM.Runtime.GhostTag.SetTag(obj, wrapper.MakeArrayType(1));
						}
						return obj;
					}
					catch (RetargetableJavaException x)
					{
						throw x.ToJava();
					}
					catch (NotSupportedException x)
					{
						// This happens when you try to create an array from TypedReference, ArgIterator, ByRef,
						// RuntimeArgumentHandle or an open generic type.
						throw new jlIllegalArgumentException(x.Message);
					}
				}

				public static object multiNewArray(jlClass componentType, int[] dimensions)
				{
					if (componentType == null || dimensions == null)
					{
						throw new jlNullPointerException();
					}
					if (componentType == jlVoid.TYPE)
					{
						throw new jlIllegalArgumentException();
					}
					if (dimensions.Length == 0 || dimensions.Length > 255)
					{
						throw new jlIllegalArgumentException();
					}
					try
					{
						TypeWrapper wrapper = TypeWrapper.FromClass(componentType).MakeArrayType(dimensions.Length);
						wrapper.Finish();
						object obj = IKVM.Runtime.ByteCodeHelper.multianewarray(wrapper.TypeAsArrayType.TypeHandle, dimensions);
						if (wrapper.IsGhostArray)
						{
							IKVM.Runtime.GhostTag.SetTag(obj, wrapper);
						}
						return obj;
					}
					catch (RetargetableJavaException x)
					{
						throw x.ToJava();
					}
					catch (NotSupportedException x)
					{
						// This happens when you try to create an array from TypedReference, ArgIterator, ByRef,
						// RuntimeArgumentHandle or an open generic type.
						throw new jlIllegalArgumentException(x.Message);
					}
				}
#endif // FIRST_PASS
			}
		}

		static class Class
		{
			public static jlClass forName0(string name, bool initialize, jlClassLoader loader)
			{
#if FIRST_PASS
				return null;
#else
				//Console.WriteLine("forName: " + name + ", loader = " + loader);
				TypeWrapper tw = null;
				if (name.IndexOf(',') > 0)
				{
					// we essentially require full trust before allowing arbitrary types to be loaded,
					// hence we do the "createClassLoader" permission check
					jlSecurityManager sm = jlSystem.getSecurityManager();
					if (sm != null)
						sm.checkPermission(new jlRuntimePermission("createClassLoader"));
					Type type = Type.GetType(name);
					if (type != null)
					{
						tw = ClassLoaderWrapper.GetWrapperFromType(type);
					}
					if (tw == null)
					{
						throw new jlClassNotFoundException(name);
					}
				}
				else
				{
					try
					{
						ClassLoaderWrapper classLoaderWrapper = ClassLoaderWrapper.GetClassLoaderWrapper(loader);
						tw = classLoaderWrapper.LoadClassByDottedName(name);
					}
					catch (ClassNotFoundException x)
					{
						throw new global::java.lang.ClassNotFoundException(x.Message);
					}
					catch (ClassLoadingException x)
					{
						throw x.InnerException;
					}
					catch (RetargetableJavaException x)
					{
						throw x.ToJava();
					}
				}
				if (initialize && !tw.IsArray)
				{
					try
					{
						tw.Finish();
					}
					catch (RetargetableJavaException x)
					{
						throw x.ToJava();
					}
					tw.RunClassInit();
				}
				return tw.ClassObject;
#endif
			}

			public static bool isInstance(jlClass thisClass, object obj)
			{
				return TypeWrapper.FromClass(thisClass).IsInstance(obj);
			}

			public static bool isAssignableFrom(jlClass thisClass, jlClass otherClass)
			{
#if !FIRST_PASS
				if (otherClass == null)
				{
					throw new jlNullPointerException();
				}
#endif
				return TypeWrapper.FromClass(otherClass).IsAssignableTo(TypeWrapper.FromClass(thisClass));
			}

			public static bool isInterface(jlClass thisClass)
			{
				return TypeWrapper.FromClass(thisClass).IsInterface;
			}

			public static bool isArray(jlClass thisClass)
			{
				return TypeWrapper.FromClass(thisClass).IsArray;
			}

			public static bool isPrimitive(jlClass thisClass)
			{
				return TypeWrapper.FromClass(thisClass).IsPrimitive;
			}

			public static string getName0(jlClass thisClass)
			{
				TypeWrapper tw = TypeWrapper.FromClass(thisClass);
				if (tw.IsPrimitive)
				{
					if (tw == PrimitiveTypeWrapper.BYTE)
					{
						return "byte";
					}
					else if (tw == PrimitiveTypeWrapper.CHAR)
					{
						return "char";
					}
					else if (tw == PrimitiveTypeWrapper.DOUBLE)
					{
						return "double";
					}
					else if (tw == PrimitiveTypeWrapper.FLOAT)
					{
						return "float";
					}
					else if (tw == PrimitiveTypeWrapper.INT)
					{
						return "int";
					}
					else if (tw == PrimitiveTypeWrapper.LONG)
					{
						return "long";
					}
					else if (tw == PrimitiveTypeWrapper.SHORT)
					{
						return "short";
					}
					else if (tw == PrimitiveTypeWrapper.BOOLEAN)
					{
						return "boolean";
					}
					else if (tw == PrimitiveTypeWrapper.VOID)
					{
						return "void";
					}
				}
				return tw.Name;
			}

			public static string getSigName(jlClass thisClass)
			{
				return TypeWrapper.FromClass(thisClass).SigName;
			}

			public static global::java.lang.ClassLoader getClassLoader0(jlClass thisClass)
			{
				return TypeWrapper.FromClass(thisClass).GetClassLoader().GetJavaClassLoader();
			}

			public static jlClass getSuperclass(jlClass thisClass)
			{
				TypeWrapper super = TypeWrapper.FromClass(thisClass).BaseTypeWrapper;
				return super != null ? super.ClassObject : null;
			}

			public static jlClass[] getInterfaces(jlClass thisClass)
			{
#if FIRST_PASS
				return null;
#else
				TypeWrapper[] ifaces = TypeWrapper.FromClass(thisClass).Interfaces;
				jlClass[] interfaces = new jlClass[ifaces.Length];
				for (int i = 0; i < ifaces.Length; i++)
				{
					interfaces[i] = ifaces[i].ClassObject;
				}
				return interfaces;
#endif
			}

			public static jlClass getComponentType(jlClass thisClass)
			{
				TypeWrapper tw = TypeWrapper.FromClass(thisClass);
				return tw.IsArray ? tw.ElementTypeWrapper.ClassObject : null;
			}

			public static int getModifiers(jlClass thisClass)
			{
				// the 0x7FFF mask comes from JVM_ACC_WRITTEN_FLAGS in hotspot\src\share\vm\utilities\accessFlags.hpp
				// masking out ACC_SUPER comes from instanceKlass::compute_modifier_flags() in hotspot\src\share\vm\oops\instanceKlass.cpp
				const int mask = 0x7FFF & (int)~IKVM.Attributes.Modifiers.Super;
				return (int)TypeWrapper.FromClass(thisClass).ReflectiveModifiers & mask;
			}

			public static object[] getSigners(jlClass thisClass)
			{
#if FIRST_PASS
				return null;
#else
				return thisClass.signers;
#endif
			}

			public static void setSigners(jlClass thisClass, object[] signers)
			{
#if !FIRST_PASS
				thisClass.signers = signers;
#endif
			}

			public static object[] getEnclosingMethod0(jlClass thisClass)
			{
				try
				{
					TypeWrapper tw = TypeWrapper.FromClass(thisClass);
					tw.Finish();
					string[] enc = tw.GetEnclosingMethod();
					if (enc == null)
					{
						return null;
					}
					return new object[] { tw.GetClassLoader().LoadClassByDottedName(enc[0]).ClassObject, enc[1], enc[2] == null ? null : enc[2].Replace('.', '/') };
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
			}

			public static jlClass getDeclaringClass(jlClass thisClass)
			{
				try
				{
					TypeWrapper wrapper = TypeWrapper.FromClass(thisClass);
					wrapper.Finish();
					TypeWrapper decl = wrapper.DeclaringTypeWrapper;
					if (decl == null)
					{
						return null;
					}
					if (!decl.IsAccessibleFrom(wrapper))
					{
						throw new IllegalAccessError(string.Format("tried to access class {0} from class {1}", decl.Name, wrapper.Name));
					}
					decl.Finish();
					if (SystemArray.IndexOf(decl.InnerClasses, wrapper) == -1)
					{
						throw new IncompatibleClassChangeError(string.Format("{0} and {1} disagree on InnerClasses attribute", decl.Name, wrapper.Name));
					}
					return decl.ClassObject;
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
			}

			public static ProtectionDomain getProtectionDomain0(jlClass thisClass)
			{
#if FIRST_PASS
				return null;
#else
				TypeWrapper wrapper = TypeWrapper.FromClass(thisClass);
				while (wrapper.IsArray)
				{
					wrapper = wrapper.ElementTypeWrapper;
				}
				ProtectionDomain pd = wrapper.ClassObject.pd;
				if (pd == null)
				{
					// The protection domain for statically compiled code is created lazily (not at java.lang.Class creation time),
					// to work around boot strap issues.
					AssemblyClassLoader acl = wrapper.GetClassLoader() as AssemblyClassLoader;
					if (acl != null)
					{
						pd = acl.GetProtectionDomain();
					}
				}
				return pd;
#endif
			}

			public static void setProtectionDomain0(jlClass thisClass, ProtectionDomain pd)
			{
#if !FIRST_PASS
				thisClass.pd = pd;
#endif
			}

			public static jlClass getPrimitiveClass(string name)
			{
				// note that this method isn't used anymore (because it is an intrinsic (during core class library compilation))
				// it still remains for compat because it might be invoked through reflection by evil code
				switch (name)
				{
					case "byte":
						return PrimitiveTypeWrapper.BYTE.ClassObject;
					case "char":
						return PrimitiveTypeWrapper.CHAR.ClassObject;
					case "double":
						return PrimitiveTypeWrapper.DOUBLE.ClassObject;
					case "float":
						return PrimitiveTypeWrapper.FLOAT.ClassObject;
					case "int":
						return PrimitiveTypeWrapper.INT.ClassObject;
					case "long":
						return PrimitiveTypeWrapper.LONG.ClassObject;
					case "short":
						return PrimitiveTypeWrapper.SHORT.ClassObject;
					case "boolean":
						return PrimitiveTypeWrapper.BOOLEAN.ClassObject;
					case "void":
						return PrimitiveTypeWrapper.VOID.ClassObject;
					default:
						throw new ArgumentException(name);
				}
			}

			public static string getGenericSignature(jlClass thisClass)
			{
				TypeWrapper tw = TypeWrapper.FromClass(thisClass);
				tw.Finish();
				return tw.GetGenericSignature();
			}

			internal static object AnnotationsToMap(ClassLoaderWrapper loader, object[] objAnn)
			{
#if FIRST_PASS
				return null;
#else
				global::java.util.LinkedHashMap map = new global::java.util.LinkedHashMap();
				if (objAnn != null)
				{
					foreach (object obj in objAnn)
					{
						Annotation a = obj as Annotation;
						if (a != null)
						{
							map.put(a.annotationType(), FreezeOrWrapAttribute(a));
						}
						else if (obj is IKVM.Attributes.DynamicAnnotationAttribute)
						{
							a = (Annotation)JVM.NewAnnotation(loader.GetJavaClassLoader(), ((IKVM.Attributes.DynamicAnnotationAttribute)obj).Definition);
							map.put(a.annotationType(), a);
						}
					}
				}
				return map;
#endif
			}

#if !FIRST_PASS
			internal static Annotation FreezeOrWrapAttribute(Annotation ann)
			{
				global::ikvm.@@internal.AnnotationAttributeBase attr = ann as global::ikvm.@@internal.AnnotationAttributeBase;
				if (attr != null)
				{
#if DONT_WRAP_ANNOTATION_ATTRIBUTES
					attr.freeze();
#else
					// freeze to make sure the defaults are set
					attr.freeze();
					ann = global::sun.reflect.annotation.AnnotationParser.annotationForMap(attr.annotationType(), attr.getValues());
#endif
				}
				return ann;
			}
#endif

			public static object getDeclaredAnnotationsImpl(jlClass thisClass)
			{
#if FIRST_PASS
				return null;
#else
				TypeWrapper wrapper = TypeWrapper.FromClass(thisClass);
				try
				{
					wrapper.Finish();
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				return AnnotationsToMap(wrapper.GetClassLoader(), wrapper.GetDeclaredAnnotations());
#endif
			}

			public static object getDeclaredFields0(jlClass thisClass, bool publicOnly)
			{
#if FIRST_PASS
				return null;
#else
				Profiler.Enter("Class.getDeclaredFields0");
				try
				{
					TypeWrapper wrapper = TypeWrapper.FromClass(thisClass);
					// we need to finish the type otherwise all fields will not be in the field map yet
					wrapper.Finish();
					FieldWrapper[] fields = wrapper.GetFields();
					List<jlrField> list = new List<jlrField>();
					for (int i = 0; i < fields.Length; i++)
					{
						if (fields[i].IsHideFromReflection)
						{
							// skip
						}
						else if (publicOnly && !fields[i].IsPublic)
						{
							// caller is only asking for public field, so we don't return this non-public field
						}
						else
						{
							list.Add((jlrField)fields[i].ToField(false, i));
						}
					}
					return list.ToArray();
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				finally
				{
					Profiler.Leave("Class.getDeclaredFields0");
				}
#endif
			}

			public static object getDeclaredMethods0(jlClass thisClass, bool publicOnly)
			{
#if FIRST_PASS
				return null;
#else
				Profiler.Enter("Class.getDeclaredMethods0");
				try
				{
					TypeWrapper wrapper = TypeWrapper.FromClass(thisClass);
					wrapper.Finish();
					if (wrapper.HasVerifyError)
					{
						// TODO we should get the message from somewhere
						throw new VerifyError();
					}
					if (wrapper.HasClassFormatError)
					{
						// TODO we should get the message from somewhere
						throw new ClassFormatError(wrapper.Name);
					}
					MethodWrapper[] methods = wrapper.GetMethods();
					List<jlrMethod> list = new List<jlrMethod>();
					for (int i = 0; i < methods.Length; i++)
					{
						// we don't want to expose "hideFromReflection" methods (one reason is that it would
						// mess up the serialVersionUID computation)
						if (!methods[i].IsHideFromReflection
							&& methods[i].Name != "<clinit>" && methods[i].Name != "<init>"
							&& (!publicOnly || methods[i].IsPublic))
						{
							list.Add((jlrMethod)methods[i].ToMethodOrConstructor(false));
						}
					}
					return list.ToArray();
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				finally
				{
					Profiler.Leave("Class.getDeclaredMethods0");
				}
#endif
			}

			public static object getDeclaredConstructors0(jlClass thisClass, bool publicOnly)
			{
#if FIRST_PASS
				return null;
#else
				Profiler.Enter("Class.getDeclaredConstructors0");
				try
				{
					TypeWrapper wrapper = TypeWrapper.FromClass(thisClass);
					wrapper.Finish();
					if (wrapper.HasVerifyError)
					{
						// TODO we should get the message from somewhere
						throw new VerifyError();
					}
					if (wrapper.HasClassFormatError)
					{
						// TODO we should get the message from somewhere
						throw new ClassFormatError(wrapper.Name);
					}
					MethodWrapper[] methods = wrapper.GetMethods();
					List<jlrConstructor> list = new List<jlrConstructor>();
					for (int i = 0; i < methods.Length; i++)
					{
						// we don't want to expose "hideFromReflection" methods (one reason is that it would
						// mess up the serialVersionUID computation)
						if (!methods[i].IsHideFromReflection
							&& methods[i].Name == "<init>"
							&& (!publicOnly || methods[i].IsPublic))
						{
							list.Add((jlrConstructor)methods[i].ToMethodOrConstructor(false));
						}
					}
					return list.ToArray();
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				finally
				{
					Profiler.Leave("Class.getDeclaredConstructors0");
				}
#endif
			}

			public static jlClass[] getDeclaredClasses0(jlClass thisClass)
			{
#if FIRST_PASS
				return null;
#else
				try
				{
					TypeWrapper wrapper = TypeWrapper.FromClass(thisClass);
					// NOTE to get at the InnerClasses we need to finish the type
					wrapper.Finish();
					TypeWrapper[] wrappers = wrapper.InnerClasses;
					jlClass[] innerclasses = new jlClass[wrappers.Length];
					for (int i = 0; i < innerclasses.Length; i++)
					{
						if (wrappers[i].IsUnloadable)
						{
							throw new jlNoClassDefFoundError(wrappers[i].Name);
						}
						if (!wrappers[i].IsAccessibleFrom(wrapper))
						{
							throw new IllegalAccessError(string.Format("tried to access class {0} from class {1}", wrappers[i].Name, wrapper.Name));
						}
						wrappers[i].Finish();
						innerclasses[i] = wrappers[i].ClassObject;
					}
					return innerclasses;
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
#endif
			}

			public static bool desiredAssertionStatus0(jlClass clazz)
			{
				return IKVM.Runtime.Assertions.IsEnabled(TypeWrapper.FromClass(clazz));
			}
		}

		static class ClassLoader
		{
			public static global::java.net.URL getBootstrapResource(string name)
			{
				foreach (global::java.net.URL url in ClassLoaderWrapper.GetBootstrapClassLoader().GetResources(name))
				{
					return url;
				}
				return null;
			}

			public static global::java.util.Enumeration getBootstrapResources(string name)
			{
#if FIRST_PASS
				return null;
#else
				return new global::ikvm.runtime.EnumerationWrapper(ClassLoaderWrapper.GetBootstrapClassLoader().GetResources(name));
#endif
			}

			public static jlClass defineClass0(jlClassLoader thisClassLoader, string name, byte[] b, int off, int len, ProtectionDomain pd)
			{
				return defineClass1(thisClassLoader, name, b, off, len, pd, null);
			}

			public static jlClass defineClass1(jlClassLoader thisClassLoader, string name, byte[] b, int off, int len, ProtectionDomain pd, string source)
			{
				// it appears the source argument is only used for trace messages in HotSpot. We'll just ignore it for now.
				Profiler.Enter("ClassLoader.defineClass");
				try
				{
					try
					{
						ClassLoaderWrapper classLoaderWrapper = ClassLoaderWrapper.GetClassLoaderWrapper(thisClassLoader);
						ClassFileParseOptions cfp = ClassFileParseOptions.LineNumberTable;
						if (classLoaderWrapper.EmitDebugInfo)
						{
							cfp |= ClassFileParseOptions.LocalVariableTable;
						}
						if (classLoaderWrapper.RelaxedClassNameValidation)
						{
							cfp |= ClassFileParseOptions.RelaxedClassNameValidation;
						}
						ClassFile classFile = new ClassFile(b, off, len, name, cfp);
						if (name != null && classFile.Name != name)
						{
#if !FIRST_PASS
							throw new jlNoClassDefFoundError(name + " (wrong name: " + classFile.Name + ")");
#endif
						}
						TypeWrapper type = classLoaderWrapper.DefineClass(classFile, pd);
						return type.ClassObject;
					}
					catch (RetargetableJavaException x)
					{
						throw x.ToJava();
					}
				}
				finally
				{
					Profiler.Leave("ClassLoader.defineClass");
				}
			}

			public static jlClass defineClass2(jlClassLoader thisClassLoader, string name, jnByteBuffer bb, int off, int len, ProtectionDomain pd, string source)
			{
#if FIRST_PASS
				return null;
#else
				byte[] buf = new byte[bb.remaining()];
				bb.get(buf);
				return defineClass1(thisClassLoader, name, buf, 0, buf.Length, pd, source);
#endif
			}

			public static void resolveClass0(jlClassLoader thisClassLoader, jlClass clazz)
			{
				// no-op
			}

			public static jlClass findBootstrapClass(jlClassLoader thisClassLoader, string name)
			{
#if FIRST_PASS
				return null;
#else
				TypeWrapper tw;
				try
				{
					tw = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast(name);
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				return tw != null ? tw.ClassObject : null;
#endif
			}

			public static jlClass findLoadedClass0(jlClassLoader thisClassLoader, string name)
			{
				if (name == null)
				{
					return null;
				}
				ClassLoaderWrapper loader = ClassLoaderWrapper.GetClassLoaderWrapper(thisClassLoader);
				TypeWrapper tw = loader.FindLoadedClass(name);
				return tw != null ? tw.ClassObject : null;
			}

			internal static class NativeLibrary
			{
				public static void load(object thisNativeLibrary, string name)
				{
#if !FIRST_PASS
					if (VirtualFileSystem.IsVirtualFS(name))
					{
						// we fake success for native libraries loaded from VFS
						((global::java.lang.ClassLoader.NativeLibrary)thisNativeLibrary).handle = -1;
					}
					else
					{
						doLoad(thisNativeLibrary, name);
					}
#endif
				}

#if !FIRST_PASS
				// we don't want to inline this method, because that would needlessly cause IKVM.Runtime.JNI.dll to be loaded when loading a fake native library from VFS
				[MethodImpl(MethodImplOptions.NoInlining)]
				[global::System.Security.SecuritySafeCritical]
				private static void doLoad(object thisNativeLibrary, string name)
				{
					global::java.lang.ClassLoader.NativeLibrary lib = (global::java.lang.ClassLoader.NativeLibrary)thisNativeLibrary;
					lib.handle = IKVM.Runtime.JniHelper.LoadLibrary(name, TypeWrapper.FromClass(lib.fromClass).GetClassLoader());
				}
#endif

				public static long find(object thisNativeLibrary, string name)
				{
					// TODO
					throw new NotImplementedException();
				}

				[global::System.Security.SecuritySafeCritical]
				public static void unload(object thisNativeLibrary)
				{
#if !FIRST_PASS
					global::java.lang.ClassLoader.NativeLibrary lib = (global::java.lang.ClassLoader.NativeLibrary)thisNativeLibrary;
					long handle = Interlocked.Exchange(ref lib.handle, 0);
					if (handle != 0)
					{
						IKVM.Runtime.JniHelper.UnloadLibrary(handle, TypeWrapper.FromClass(lib.fromClass).GetClassLoader());
					}
#endif
				}
			}

			public static object retrieveDirectives()
			{
				return IKVM.Runtime.Assertions.RetrieveDirectives();
			}
		}

		static class Compiler
		{
			public static void initialize()
			{
			}

			public static void registerNatives()
			{
			}

			public static bool compileClass(object clazz)
			{
				return false;
			}

			public static bool compileClasses(string str)
			{
				return false;
			}

			public static object command(object any)
			{
				return null;
			}

			public static void enable()
			{
			}

			public static void disable()
			{
			}
		}

		static class Double
		{
			public static long doubleToRawLongBits(double value)
			{
				IKVM.Runtime.DoubleConverter converter = new IKVM.Runtime.DoubleConverter();
				return IKVM.Runtime.DoubleConverter.ToLong(value, ref converter);
			}

			public static double longBitsToDouble(long bits)
			{
				IKVM.Runtime.DoubleConverter converter = new IKVM.Runtime.DoubleConverter();
				return IKVM.Runtime.DoubleConverter.ToDouble(bits, ref converter);
			}
		}

		static class Float
		{
			public static int floatToRawIntBits(float value)
			{
				IKVM.Runtime.FloatConverter converter = new IKVM.Runtime.FloatConverter();
				return IKVM.Runtime.FloatConverter.ToInt(value, ref converter);
			}

			public static float intBitsToFloat(int bits)
			{
				IKVM.Runtime.FloatConverter converter = new IKVM.Runtime.FloatConverter();
				return IKVM.Runtime.FloatConverter.ToFloat(bits, ref converter);
			}
		}

		static class Package
		{
			private static Dictionary<string, string> systemPackages;

			private static void LazyInitSystemPackages()
			{
				if (systemPackages == null)
				{
					Dictionary<string, string> dict = new Dictionary<string, string>();
					string path = VirtualFileSystem.GetAssemblyResourcesPath(JVM.CoreAssembly) + "resources.jar";
					foreach (string pkg in ClassLoaderWrapper.GetBootstrapClassLoader().GetPackages())
					{
						dict[pkg.Replace('.', '/') + "/"] = path;
					}
					Interlocked.CompareExchange(ref systemPackages, dict, null);
				}
			}

			public static string getSystemPackage0(string name)
			{
				LazyInitSystemPackages();
				string path;
				systemPackages.TryGetValue(name, out path);
				return path;
			}

			public static string[] getSystemPackages0()
			{
				LazyInitSystemPackages();
				string[] pkgs = new string[systemPackages.Count];
				systemPackages.Keys.CopyTo(pkgs, 0);
				return pkgs;
			}
		}

		static class ProcessEnvironment
		{
			public static string environmentBlock()
			{
				StringBuilder sb = new StringBuilder();
				foreach (global::System.Collections.DictionaryEntry de in Environment.GetEnvironmentVariables())
				{
					sb.Append(de.Key).Append('=').Append(de.Value).Append('\u0000');
				}
				if (sb.Length == 0)
				{
					sb.Append('\u0000');
				}
				sb.Append('\u0000');
				return sb.ToString();
			}
		}

		static class Runtime
		{
			public static int availableProcessors(object thisRuntime)
			{
				return Environment.ProcessorCount;
			}

			public static long freeMemory(object thisRuntime)
			{
				// TODO figure out if there is anything meaningful we can return here
				return 10 * 1024 * 1024;
			}

			public static long totalMemory(object thisRuntime)
			{
				// NOTE this really is a bogus number, but we have to return something
				return GC.GetTotalMemory(false) + freeMemory(thisRuntime);
			}

			public static long maxMemory(object thisRuntime)
			{
				// spec says: If there is no inherent limit then the value Long.MAX_VALUE will be returned.
				return Int64.MaxValue;
			}

			public static void gc(object thisRuntime)
			{
				GC.Collect();
			}

			public static void traceInstructions(object thisRuntime, bool on)
			{
			}

			public static void traceMethodCalls(object thisRuntime, bool on)
			{
			}

			public static void runFinalization0()
			{
				GC.WaitForPendingFinalizers();
			}
		}

		static class SecurityManager
		{
			// this field is set by code in the JNI assembly itself,
			// to prevent having to load the JNI assembly when it isn't used.
			internal static volatile Assembly jniAssembly;

			public static jlClass[] getClassContext(object thisSecurityManager)
			{
#if FIRST_PASS
				return null;
#else
				List<jlClass> stack = new List<jlClass>();
				StackTrace trace = new StackTrace();
				for (int i = 0; i < trace.FrameCount; i++)
				{
					StackFrame frame = trace.GetFrame(i);
					MethodBase method = frame.GetMethod();
					Type type = method.DeclaringType;
					// NOTE these checks should be the same as the ones in Reflection.getCallerClass
					if (IKVM.NativeCode.sun.reflect.Reflection.IsHideFromJava(method)
						|| type == null
						|| type.Assembly == typeof(object).Assembly
						|| type.Assembly == typeof(SecurityManager).Assembly
						|| type.Assembly == jniAssembly
						|| type == typeof(jlrConstructor)
						|| type == typeof(jlrMethod))
					{
						continue;
					}
					if (type == typeof(jlSecurityManager))
					{
						continue;
					}
					stack.Add(ClassLoaderWrapper.GetWrapperFromType(type).ClassObject);
				}
				return stack.ToArray();
#endif
			}

			public static object currentClassLoader0(object thisSecurityManager)
			{
				jlClass currentClass = currentLoadedClass0(thisSecurityManager);
				if (currentClass != null)
				{
					return TypeWrapper.FromClass(currentClass).GetClassLoader().GetJavaClassLoader();
				}
				return null;
			}

			public static int classDepth(object thisSecurityManager, string name)
			{
				throw new NotImplementedException();
			}

			public static int classLoaderDepth0(object thisSecurityManager)
			{
				throw new NotImplementedException();
			}

			public static jlClass currentLoadedClass0(object thisSecurityManager)
			{
				throw new NotImplementedException();
			}
		}

		static class StrictMath
		{
			public static double sin(double d)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.sin(d);
#endif
			}

			public static double cos(double d)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.cos(d);
#endif
			}

			public static double tan(double d)
			{
				return fdlibm.tan(d);
			}

			public static double asin(double d)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.asin(d);
#endif
			}

			public static double acos(double d)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.acos(d);
#endif
			}

			public static double atan(double d)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.atan(d);
#endif
			}

			public static double exp(double d)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.exp(d);
#endif
			}

			public static double log(double d)
			{
				// FPU behavior is correct
				return Math.Log(d);
			}

			public static double log10(double d)
			{
				// FPU behavior is correct
				return Math.Log10(d);
			}

			public static double sqrt(double d)
			{
				// FPU behavior is correct
				return Math.Sqrt(d);
			}

			public static double cbrt(double d)
			{
				return fdlibm.cbrt(d);
			}

			public static double IEEEremainder(double f1, double f2)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.IEEEremainder(f1, f2);
#endif
			}

			public static double ceil(double d)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.ceil(d);
#endif
			}

			public static double floor(double d)
			{
				return fdlibm.floor(d);
			}

			public static double atan2(double y, double x)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.atan2(y, x);
#endif
			}

			public static double pow(double x, double y)
			{
				return fdlibm.__ieee754_pow(x, y);
			}

			public static double sinh(double d)
			{
				return Math.Sinh(d);
			}

			public static double cosh(double d)
			{
				return Math.Cosh(d);
			}

			public static double tanh(double d)
			{
				return Math.Tanh(d);
			}

			public static double rint(double d)
			{
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.rint(d);
#endif
			}

			public static double hypot(double a, double b)
			{
				return fdlibm.__ieee754_hypot(a, b);
			}

			public static double expm1(double d)
			{
				return fdlibm.expm1(d);
			}

			public static double log1p(double d)
			{
				return fdlibm.log1p(d);
			}
		}

		static class System
		{
			public static void arraycopy(object src, int srcPos, object dest, int destPos, int length)
			{
				IKVM.Runtime.ByteCodeHelper.arraycopy(src, srcPos, dest, destPos, length);
			}
		}

		static class Thread
		{
			private static readonly object mainThreadGroup;

#if !FIRST_PASS
			static Thread()
			{
				mainThreadGroup = new jlThreadGroup(jlThreadGroup.createRootGroup(), "main");
			}
#endif

			public static object getMainThreadGroup()
			{
				return mainThreadGroup;
			}

			// this is called from JniInterface.cs
			internal static void WaitUntilLastJniThread()
			{
#if !FIRST_PASS
				int count = jlThread.currentThread().isDaemon() ? 0 : 1;
				while (Interlocked.CompareExchange(ref jlThread.nonDaemonCount[0], 0, 0) > count)
				{
					SystemThreadingThread.Sleep(1);
				}
#endif
			}

			// this is called from JniInterface.cs
			internal static void AttachThreadFromJni(object threadGroup)
			{
#if !FIRST_PASS
				if (threadGroup == null)
				{
					threadGroup = mainThreadGroup;
				}
				if (jlThread.current == null)
				{
					new jlThread((jlThreadGroup)threadGroup);
				}
#endif
			}

			public static jlStackTraceElement[] getStackTrace(StackTrace stack)
			{
#if FIRST_PASS
				return null;
#else
				List<jlStackTraceElement> stackTrace = new List<jlStackTraceElement>();
				ExceptionHelper.ExceptionInfoHelper.Append(stackTrace, stack, 0, true);
				return stackTrace.ToArray();
#endif
			}

            public static object getThreads()
            {
#if FIRST_PASS
				return null;
#else
                return global::java.security.AccessController.doPrivileged(global::ikvm.runtime.Delegates.toPrivilegedAction(delegate
                {
                    jlThreadGroup root = (jlThreadGroup)mainThreadGroup;
                    for (; ; )
                    {
                        jlThread[] threads = new jlThread[root.activeCount()];
                        if (root.enumerate(threads) == threads.Length)
                        {
                            return threads;
                        }
                    }
                }));
#endif
            }
			
		}

		static class ProcessImpl
		{
			public static string mapVfsExecutable(string path)
			{
				if (VirtualFileSystem.IsVirtualFS(path))
				{
					return VirtualFileSystem.MapExecutable(path);
				}
				return path;
			}

			public static int parseCommandString(string cmdstr)
			{
				int pos = cmdstr.IndexOf(' ');
				if (pos == -1)
				{
					return cmdstr.Length;
				}
				if (cmdstr[0] == '"')
				{
					int close = cmdstr.IndexOf('"', 1);
					return close == -1 ? cmdstr.Length : close + 1;
				}
				if (Environment.OSVersion.Platform != PlatformID.Win32NT)
				{
					return pos;
				}
				IList<string> path = null;
				for (; ; )
				{
					string str = cmdstr.Substring(0, pos);
					if (global::System.IO.Path.IsPathRooted(str))
					{
						if (Exists(str))
						{
							return pos;
						}
					}
					else
					{
						if (path == null)
						{
							path = GetSearchPath();
						}
						foreach (string p in path)
						{
							if (Exists(global::System.IO.Path.Combine(p, str)))
							{
								return pos;
							}
						}
					}
					if (pos == cmdstr.Length)
					{
						return cmdstr.IndexOf(' ');
					}
					pos = cmdstr.IndexOf(' ', pos + 1);
					if (pos == -1)
					{
						pos = cmdstr.Length;
					}
				}
			}

			private static List<string> GetSearchPath()
			{
				List<string> list = new List<string>();
				list.Add(global::System.IO.Path.GetDirectoryName(global::System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName));
				list.Add(Environment.CurrentDirectory);
				list.Add(Environment.SystemDirectory);
				string windir = global::System.IO.Path.GetDirectoryName(Environment.SystemDirectory);
				list.Add(global::System.IO.Path.Combine(windir, "System"));
				list.Add(windir);
				string path = Environment.GetEnvironmentVariable("PATH");
				if (path != null)
				{
					foreach (string p in path.Split(global::System.IO.Path.PathSeparator))
					{
						list.Add(p);
					}
				}
				return list;
			}

			private static bool Exists(string file)
			{
				try
				{
					if (global::System.IO.File.Exists(file))
					{
						return true;
					}
					else if (global::System.IO.Directory.Exists(file))
					{
						return false;
					}
					else if (file.IndexOf('.') == -1 && global::System.IO.File.Exists(file + ".exe"))
					{
						return true;
					}
					else
					{
						return false;
					}
				}
				catch
				{
					return false;
				}
			}
		}

		namespace reflect
		{
			static class Proxy
			{
				public static object defineClass0(jlClassLoader classLoader, string name, byte[] b, int off, int len)
				{
					return ClassLoader.defineClass1(classLoader, name, b, off, len, null, null);
				}

				public static jlClass getPrecompiledProxy(jlClassLoader classLoader, string proxyName, jlClass[] interfaces)
				{
					AssemblyClassLoader acl = ClassLoaderWrapper.GetClassLoaderWrapper(classLoader) as AssemblyClassLoader;
					if (acl == null)
					{
						return null;
					}
					TypeWrapper[] wrappers = new TypeWrapper[interfaces.Length];
					for (int i = 0; i < wrappers.Length; i++)
					{
						wrappers[i] = TypeWrapper.FromClass(interfaces[i]);
					}
					// TODO support multi assembly class loaders
					Type type = acl.MainAssembly.GetType(DynamicClassLoader.GetProxyName(wrappers));
					if (type == null)
					{
						return null;
					}
					TypeWrapper tw = CompiledTypeWrapper.newInstance(proxyName, type);
					TypeWrapper tw2 = acl.RegisterInitiatingLoader(tw);
					if (tw != tw2)
					{
						return null;
					}
					TypeWrapper[] wrappers2 = tw.Interfaces;
					if (wrappers.Length != wrappers.Length)
					{
						return null;
					}
					for (int i = 0; i < wrappers.Length; i++)
					{
						if (wrappers[i] != wrappers2[i])
						{
							return null;
						}
					}
					return tw.ClassObject;
				}
			}

			static class Field
			{
				public static object getDeclaredAnnotationsImpl(object thisField)
				{
					FieldWrapper fw = FieldWrapper.FromField(thisField);
					return Class.AnnotationsToMap(fw.DeclaringType.GetClassLoader(), fw.DeclaringType.GetFieldAnnotations(fw));
				}
			}

			static class Method
			{
				public static object getDeclaredAnnotationsImpl(object methodOrConstructor)
				{
					MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(methodOrConstructor);
					return Class.AnnotationsToMap(mw.DeclaringType.GetClassLoader(), mw.DeclaringType.GetMethodAnnotations(mw));
				}

				public static object[][] getParameterAnnotationsImpl(object methodOrConstructor)
				{
#if FIRST_PASS
					return null;
#else
					MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(methodOrConstructor);
					object[][] objAnn = mw.DeclaringType.GetParameterAnnotations(mw);
					if (objAnn == null)
					{
						return null;
					}
					Annotation[][] ann = new Annotation[objAnn.Length][];
					for (int i = 0; i < ann.Length; i++)
					{
						List<Annotation> list = new List<Annotation>();
						foreach (object obj in objAnn[i])
						{
							Annotation a = obj as Annotation;
							if (a != null)
							{
								list.Add(Class.FreezeOrWrapAttribute(a));
							}
							else if (obj is IKVM.Attributes.DynamicAnnotationAttribute)
							{
								list.Add((Annotation)JVM.NewAnnotation(mw.DeclaringType.GetClassLoader().GetJavaClassLoader(), ((IKVM.Attributes.DynamicAnnotationAttribute)obj).Definition));
							}
						}
						ann[i] = list.ToArray();
					}
					return ann;
#endif
				}

				public static object getDefaultValue(object thisMethod)
				{
					MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(thisMethod);
					return mw.DeclaringType.GetAnnotationDefault(mw);
				}
			}
		}
d1455 1
a1455 1
						protection_domain = caller == null ? null : java.lang.Class.getProtectionDomain0(caller);
d1488 1
a1488 1
					|| type.Assembly == java.lang.SecurityManager.jniAssembly
d1496 1
a1496 1
					return java.lang.Class.getProtectionDomain0(tw.ClassObject);
d2803 1
a2803 1
					|| type.Assembly == java.lang.SecurityManager.jniAssembly
@


1.307
log
@Made boot class package handling simpler (more OpenJDK based). The package information is now read from the manifest instead of hard coded.
@
text
@a355 1388
	namespace io
	{
		static class Console
		{
			public static string encoding()
			{
				int cp = 437;
				try
				{
					cp = global::System.Console.InputEncoding.CodePage;
				}
				catch
				{
				}
				if (cp >= 874 && cp <= 950)
				{
					return "ms" + cp;
				}
				return "cp" + cp;
			}

			private const int STD_INPUT_HANDLE = -10;
			private const int ENABLE_ECHO_INPUT = 0x0004;

			[System.Runtime.InteropServices.DllImport("kernel32")]
			private static extern IntPtr GetStdHandle(int nStdHandle);

			[System.Runtime.InteropServices.DllImport("kernel32")]
			private static extern int GetConsoleMode(IntPtr hConsoleHandle, out int lpMode);

			[System.Runtime.InteropServices.DllImport("kernel32")]
			private static extern int SetConsoleMode(IntPtr hConsoleHandle, int dwMode);

			public static bool echo(bool on)
			{
#if !FIRST_PASS
				// HACK the only way to get this to work is by p/invoking the Win32 APIs
				if (Environment.OSVersion.Platform == PlatformID.Win32NT)
				{
					IntPtr hStdIn = GetStdHandle(STD_INPUT_HANDLE);
					if (hStdIn.ToInt64() == 0 || hStdIn.ToInt64() == -1)
					{
						throw new global::java.io.IOException("The handle is invalid");
					}
					int fdwMode;
					if (GetConsoleMode(hStdIn, out fdwMode) == 0)
					{
						throw new global::java.io.IOException("GetConsoleMode failed");
					}
					bool old = (fdwMode & ENABLE_ECHO_INPUT) != 0;
					if (on)
					{
						fdwMode |= ENABLE_ECHO_INPUT;
					}
					else
					{
						fdwMode &= ~ENABLE_ECHO_INPUT;
					}
					if (SetConsoleMode(hStdIn, fdwMode) == 0)
					{
						throw new global::java.io.IOException("SetConsoleMode failed");
					}
					return old;
				}
#endif
				return true;
			}

			public static bool istty()
			{
				// The JDK returns false here if stdin or stdout (not stderr) is redirected to a file
				// or if there is no console associated with the current process.
				// The best we can do is to look at the KeyAvailable property, which
				// will throw an InvalidOperationException if stdin is redirected or not available
				try
				{
					return global::System.Console.KeyAvailable || true;
				}
				catch (InvalidOperationException)
				{
					return false;
				}
			}
		}

		static class FileDescriptor
		{
			private static Converter<int, int> fsync;

			public static System.IO.Stream open(String name, System.IO.FileMode fileMode, System.IO.FileAccess fileAccess)
			{
				if (VirtualFileSystem.IsVirtualFS(name))
				{
					return VirtualFileSystem.Open(name, fileMode, fileAccess);
				}
				else if (fileMode == System.IO.FileMode.Append)
				{
					// this is the way to get atomic append behavior for all writes
					return new System.IO.FileStream(name, fileMode, System.Security.AccessControl.FileSystemRights.AppendData, System.IO.FileShare.ReadWrite, 1, System.IO.FileOptions.None);
				}
				else
				{
					return new System.IO.FileStream(name, fileMode, fileAccess, System.IO.FileShare.ReadWrite, 1, false);
				}
			}

			[System.Security.SecuritySafeCritical]
			public static bool flushPosix(System.IO.FileStream fs)
			{
				if (fsync == null)
				{
					ResolveFSync();
				}
				bool success = false;
				Microsoft.Win32.SafeHandles.SafeFileHandle handle = fs.SafeFileHandle;
				RuntimeHelpers.PrepareConstrainedRegions();
				try
				{
					handle.DangerousAddRef(ref success);
					return fsync(handle.DangerousGetHandle().ToInt32()) == 0;
				}
				finally
				{
					if (success)
					{
						handle.DangerousRelease();
					}
				}
			}

			[System.Security.SecurityCritical]
			private static void ResolveFSync()
			{
				// we don't want a build time dependency on this Mono assembly, so we use reflection
				Type type = Type.GetType("Mono.Unix.Native.Syscall, Mono.Posix, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756");
				if (type != null)
				{
					fsync = (Converter<int, int>)Delegate.CreateDelegate(typeof(Converter<int, int>), type, "fsync", false, false);
				}
				if (fsync == null)
				{
					fsync = DummyFSync;
				}
			}

			private static int DummyFSync(int fd)
			{
				return 0;
			}
		}

		static class FileSystem
		{
			public static object getFileSystem()
			{
#if FIRST_PASS
				return null;
#else
				if (JVM.IsUnix)
				{
					return new global::java.io.UnixFileSystem();
				}
				else
				{
					return new global::java.io.Win32FileSystem();
				}
#endif
			}
		}

		static class ObjectInputStream
		{
			public static void bytesToFloats(byte[] src, int srcpos, float[] dst, int dstpos, int nfloats)
			{
				IKVM.Runtime.FloatConverter converter = new IKVM.Runtime.FloatConverter();
				for (int i = 0; i < nfloats; i++)
				{
					int v = src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					dst[dstpos++] = IKVM.Runtime.FloatConverter.ToFloat(v, ref converter);
				}
			}

			public static void bytesToDoubles(byte[] src, int srcpos, double[] dst, int dstpos, int ndoubles)
			{
				IKVM.Runtime.DoubleConverter converter = new IKVM.Runtime.DoubleConverter();
				for (int i = 0; i < ndoubles; i++)
				{
					long v = src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					dst[dstpos++] = IKVM.Runtime.DoubleConverter.ToDouble(v, ref converter);
				}
			}

			public static object latestUserDefinedLoader()
			{
				// testing shows that it is cheaper the get the full stack trace and then look at a few frames than getting the frames individually
				StackTrace trace = new StackTrace(2, false);
				for (int i = 0; i < trace.FrameCount; i++)
				{
					StackFrame frame = trace.GetFrame(i);
					MethodBase method = frame.GetMethod();
					if (method == null)
					{
						continue;
					}
					Type type = method.DeclaringType;
					if (type != null)
					{
						TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(type);
						if (tw != null)
						{
							ClassLoaderWrapper classLoader = tw.GetClassLoader();
							AssemblyClassLoader acl = classLoader as AssemblyClassLoader;
							if (acl == null || acl.GetAssembly(tw) != typeof(object).Assembly)
							{
								object javaClassLoader = classLoader.GetJavaClassLoader();
								if (javaClassLoader != null)
								{
									return javaClassLoader;
								}
							}
						}
					}
				}
				return null;
			}
		}

		static class ObjectOutputStream
		{
			public static void floatsToBytes(float[] src, int srcpos, byte[] dst, int dstpos, int nfloats)
			{
				IKVM.Runtime.FloatConverter converter = new IKVM.Runtime.FloatConverter();
				for (int i = 0; i < nfloats; i++)
				{
					int v = IKVM.Runtime.FloatConverter.ToInt(src[srcpos++], ref converter);
					dst[dstpos++] = (byte)(v >> 24);
					dst[dstpos++] = (byte)(v >> 16);
					dst[dstpos++] = (byte)(v >> 8);
					dst[dstpos++] = (byte)(v >> 0);
				}
			}

			public static void doublesToBytes(double[] src, int srcpos, byte[] dst, int dstpos, int ndoubles)
			{
				IKVM.Runtime.DoubleConverter converter = new IKVM.Runtime.DoubleConverter();
				for (int i = 0; i < ndoubles; i++)
				{
					long v = IKVM.Runtime.DoubleConverter.ToLong(src[srcpos++], ref converter);
					dst[dstpos++] = (byte)(v >> 56);
					dst[dstpos++] = (byte)(v >> 48);
					dst[dstpos++] = (byte)(v >> 40);
					dst[dstpos++] = (byte)(v >> 32);
					dst[dstpos++] = (byte)(v >> 24);
					dst[dstpos++] = (byte)(v >> 16);
					dst[dstpos++] = (byte)(v >> 8);
					dst[dstpos++] = (byte)(v >> 0);
				}
			}
		}

		public static class IOHelpers
		{
			public static void WriteByte(byte[] buf, int offset, byte value)
			{
				buf[offset] = value;
			}

			public static void WriteBoolean(byte[] buf, int offset, bool value)
			{
				buf[offset] = value ? (byte)1 : (byte)0;
			}

			public static void WriteChar(byte[] buf, int offset, char value)
			{
				buf[offset + 0] = (byte)(value >> 8);
				buf[offset + 1] = (byte)(value >> 0);
			}

			public static void WriteShort(byte[] buf, int offset, short value)
			{
				buf[offset + 0] = (byte)(value >> 8);
				buf[offset + 1] = (byte)(value >> 0);
			}

			public static void WriteInt(byte[] buf, int offset, int value)
			{
				buf[offset + 0] = (byte)(value >> 24);
				buf[offset + 1] = (byte)(value >> 16);
				buf[offset + 2] = (byte)(value >> 8);
				buf[offset + 3] = (byte)(value >> 0);
			}

			public static void WriteFloat(byte[] buf, int offset, float value)
			{
#if !FIRST_PASS
				global::java.io.Bits.putFloat(buf, offset, value);
#endif
			}

			public static void WriteLong(byte[] buf, int offset, long value)
			{
				WriteInt(buf, offset, (int)(value >> 32));
				WriteInt(buf, offset + 4, (int)value);
			}

			public static void WriteDouble(byte[] buf, int offset, double value)
			{
#if !FIRST_PASS
				global::java.io.Bits.putDouble(buf, offset, value);
#endif
			}

			public static byte ReadByte(byte[] buf, int offset)
			{
				return buf[offset];
			}

			public static bool ReadBoolean(byte[] buf, int offset)
			{
				return buf[offset] != 0;
			}

			public static char ReadChar(byte[] buf, int offset)
			{
				return (char)((buf[offset] << 8) + buf[offset + 1]);
			}

			public static short ReadShort(byte[] buf, int offset)
			{
				return (short)((buf[offset] << 8) + buf[offset + 1]);
			}

			public static int ReadInt(byte[] buf, int offset)
			{
				return (buf[offset + 0] << 24)
					 + (buf[offset + 1] << 16)
					 + (buf[offset + 2] << 8)
					 + (buf[offset + 3] << 0);
			}

			public static float ReadFloat(byte[] buf, int offset)
			{
#if FIRST_PASS
				return 0;
#else
				return jlFloat.intBitsToFloat(ReadInt(buf, offset));
#endif
			}

			public static long ReadLong(byte[] buf, int offset)
			{
				long hi = (uint)ReadInt(buf, offset);
				long lo = (uint)ReadInt(buf, offset + 4);
				return lo + (hi << 32);
			}

			public static double ReadDouble(byte[] buf, int offset)
			{
#if FIRST_PASS
				return 0;
#else
				return jlDouble.longBitsToDouble(ReadLong(buf, offset));
#endif
			}
		}

		static class ObjectStreamClass
		{
			public static void initNative()
			{
			}

			public static bool isDynamicTypeWrapper(jlClass cl)
			{
				TypeWrapper wrapper = TypeWrapper.FromClass(cl);
				return !wrapper.IsFastClassLiteralSafe;
			}

			public static bool hasStaticInitializer(jlClass cl)
			{
				TypeWrapper wrapper = TypeWrapper.FromClass(cl);
				try
				{
					wrapper.Finish();
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				Type type = wrapper.TypeAsTBD;
				if (!type.IsArray && type.TypeInitializer != null)
				{
					wrapper.RunClassInit();
					return !AttributeHelper.IsHideFromJava(type.TypeInitializer);
				}
				return false;
			}

#if !FIRST_PASS
			private sealed class FastFieldReflector : iiFieldReflectorBase
			{
				private static readonly MethodInfo ReadByteMethod = typeof(IOHelpers).GetMethod("ReadByte");
				private static readonly MethodInfo ReadBooleanMethod = typeof(IOHelpers).GetMethod("ReadBoolean");
				private static readonly MethodInfo ReadCharMethod = typeof(IOHelpers).GetMethod("ReadChar");
				private static readonly MethodInfo ReadShortMethod = typeof(IOHelpers).GetMethod("ReadShort");
				private static readonly MethodInfo ReadIntMethod = typeof(IOHelpers).GetMethod("ReadInt");
				private static readonly MethodInfo ReadFloatMethod = typeof(IOHelpers).GetMethod("ReadFloat");
				private static readonly MethodInfo ReadLongMethod = typeof(IOHelpers).GetMethod("ReadLong");
				private static readonly MethodInfo ReadDoubleMethod = typeof(IOHelpers).GetMethod("ReadDouble");
				private static readonly MethodInfo WriteByteMethod = typeof(IOHelpers).GetMethod("WriteByte");
				private static readonly MethodInfo WriteBooleanMethod = typeof(IOHelpers).GetMethod("WriteBoolean");
				private static readonly MethodInfo WriteCharMethod = typeof(IOHelpers).GetMethod("WriteChar");
				private static readonly MethodInfo WriteShortMethod = typeof(IOHelpers).GetMethod("WriteShort");
				private static readonly MethodInfo WriteIntMethod = typeof(IOHelpers).GetMethod("WriteInt");
				private static readonly MethodInfo WriteFloatMethod = typeof(IOHelpers).GetMethod("WriteFloat");
				private static readonly MethodInfo WriteLongMethod = typeof(IOHelpers).GetMethod("WriteLong");
				private static readonly MethodInfo WriteDoubleMethod = typeof(IOHelpers).GetMethod("WriteDouble");
				private delegate void ObjFieldGetterSetter(object obj, object[] objarr);
				private delegate void PrimFieldGetterSetter(object obj, byte[] objarr);
				private static readonly ObjFieldGetterSetter objDummy = new ObjFieldGetterSetter(Dummy);
				private static readonly PrimFieldGetterSetter primDummy = new PrimFieldGetterSetter(Dummy);
				private jiObjectStreamField[] fields;
				private ObjFieldGetterSetter objFieldGetter;
				private PrimFieldGetterSetter primFieldGetter;
				private ObjFieldGetterSetter objFieldSetter;
				private PrimFieldGetterSetter primFieldSetter;

				private static void Dummy(object obj, object[] objarr)
				{
				}

				private static void Dummy(object obj, byte[] barr)
				{
				}

				internal FastFieldReflector(jiObjectStreamField[] fields)
				{
					this.fields = fields;
					TypeWrapper tw = null;
					foreach (jiObjectStreamField field in fields)
					{
						FieldWrapper fw = GetFieldWrapper(field);
						if (fw != null)
						{
							if (tw == null)
							{
								tw = fw.DeclaringType;
							}
							else if (tw != fw.DeclaringType)
							{
								// pre-condition is that all fields are from the same Type!
								throw new jlInternalError();
							}
						}
					}
					if (tw == null)
					{
						objFieldGetter = objFieldSetter = objDummy;
						primFieldGetter = primFieldSetter = primDummy;
					}
					else
					{
						try
						{
							tw.Finish();
						}
						catch (RetargetableJavaException x)
						{
							throw x.ToJava();
						}
						DynamicMethod dmObjGetter = DynamicMethodUtils.Create("__<ObjFieldGetter>", tw.TypeAsBaseType, true, null, new Type[] { typeof(object), typeof(object[]) });
						DynamicMethod dmPrimGetter = DynamicMethodUtils.Create("__<PrimFieldGetter>", tw.TypeAsBaseType, true, null, new Type[] { typeof(object), typeof(byte[]) });
						DynamicMethod dmObjSetter = DynamicMethodUtils.Create("__<ObjFieldSetter>", tw.TypeAsBaseType, true, null, new Type[] { typeof(object), typeof(object[]) });
						DynamicMethod dmPrimSetter = DynamicMethodUtils.Create("__<PrimFieldSetter>", tw.TypeAsBaseType, true, null, new Type[] { typeof(object), typeof(byte[]) });
						CodeEmitter ilgenObjGetter = CodeEmitter.Create(dmObjGetter);
						CodeEmitter ilgenPrimGetter = CodeEmitter.Create(dmPrimGetter);
						CodeEmitter ilgenObjSetter = CodeEmitter.Create(dmObjSetter);
						CodeEmitter ilgenPrimSetter = CodeEmitter.Create(dmPrimSetter);

						// we want the getters to be verifiable (because writeObject can be used from partial trust),
						// so we create a local to hold the properly typed object reference
						CodeEmitterLocal objGetterThis = ilgenObjGetter.DeclareLocal(tw.TypeAsBaseType);
						CodeEmitterLocal primGetterThis = ilgenPrimGetter.DeclareLocal(tw.TypeAsBaseType);
						ilgenObjGetter.Emit(OpCodes.Ldarg_0);
						ilgenObjGetter.Emit(OpCodes.Castclass, tw.TypeAsBaseType);
						ilgenObjGetter.Emit(OpCodes.Stloc, objGetterThis);
						ilgenPrimGetter.Emit(OpCodes.Ldarg_0);
						ilgenPrimGetter.Emit(OpCodes.Castclass, tw.TypeAsBaseType);
						ilgenPrimGetter.Emit(OpCodes.Stloc, primGetterThis);

						foreach (jiObjectStreamField field in fields)
						{
							FieldWrapper fw = GetFieldWrapper(field);
							if (fw == null)
							{
								continue;
							}
							fw.ResolveField();
							TypeWrapper fieldType = fw.FieldTypeWrapper;
							try
							{
								fieldType = fieldType.EnsureLoadable(tw.GetClassLoader());
								fieldType.Finish();
							}
							catch (RetargetableJavaException x)
							{
								throw x.ToJava();
							}
							if (fieldType.IsPrimitive)
							{
								// Getter
								ilgenPrimGetter.Emit(OpCodes.Ldarg_1);
								ilgenPrimGetter.EmitLdc_I4(field.getOffset());
								ilgenPrimGetter.Emit(OpCodes.Ldloc, primGetterThis);
								fw.EmitGet(ilgenPrimGetter);
								if (fieldType == PrimitiveTypeWrapper.BYTE)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteByteMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.BOOLEAN)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteBooleanMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.CHAR)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteCharMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.SHORT)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteShortMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.INT)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteIntMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.FLOAT)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteFloatMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.LONG)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteLongMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.DOUBLE)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteDoubleMethod);
								}
								else
								{
									throw new jlInternalError();
								}

								// Setter
								ilgenPrimSetter.Emit(OpCodes.Ldarg_0);
								ilgenPrimSetter.Emit(OpCodes.Castclass, tw.TypeAsBaseType);
								ilgenPrimSetter.Emit(OpCodes.Ldarg_1);
								ilgenPrimSetter.EmitLdc_I4(field.getOffset());
								if (fieldType == PrimitiveTypeWrapper.BYTE)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadByteMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.BOOLEAN)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadBooleanMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.CHAR)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadCharMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.SHORT)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadShortMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.INT)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadIntMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.FLOAT)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadFloatMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.LONG)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadLongMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.DOUBLE)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadDoubleMethod);
								}
								else
								{
									throw new jlInternalError();
								}
								fw.EmitSet(ilgenPrimSetter);
							}
							else
							{
								// Getter
								ilgenObjGetter.Emit(OpCodes.Ldarg_1);
								ilgenObjGetter.EmitLdc_I4(field.getOffset());
								ilgenObjGetter.Emit(OpCodes.Ldloc, objGetterThis);
								fw.EmitGet(ilgenObjGetter);
								fieldType.EmitConvSignatureTypeToStackType(ilgenObjGetter);
								ilgenObjGetter.Emit(OpCodes.Stelem_Ref);

								// Setter
								ilgenObjSetter.Emit(OpCodes.Ldarg_0);
								ilgenObjSetter.Emit(OpCodes.Ldarg_1);
								ilgenObjSetter.EmitLdc_I4(field.getOffset());
								ilgenObjSetter.Emit(OpCodes.Ldelem_Ref);
								fieldType.EmitCheckcast(ilgenObjSetter);
								fieldType.EmitConvStackTypeToSignatureType(ilgenObjSetter, null);
								fw.EmitSet(ilgenObjSetter);
							}
						}
						ilgenObjGetter.Emit(OpCodes.Ret);
						ilgenPrimGetter.Emit(OpCodes.Ret);
						ilgenObjSetter.Emit(OpCodes.Ret);
						ilgenPrimSetter.Emit(OpCodes.Ret);
						ilgenObjGetter.DoEmit();
						ilgenPrimGetter.DoEmit();
						ilgenObjSetter.DoEmit();
						ilgenPrimSetter.DoEmit();
						objFieldGetter = (ObjFieldGetterSetter)dmObjGetter.CreateDelegate(typeof(ObjFieldGetterSetter));
						primFieldGetter = (PrimFieldGetterSetter)dmPrimGetter.CreateDelegate(typeof(PrimFieldGetterSetter));
						objFieldSetter = (ObjFieldGetterSetter)dmObjSetter.CreateDelegate(typeof(ObjFieldGetterSetter));
						primFieldSetter = (PrimFieldGetterSetter)dmPrimSetter.CreateDelegate(typeof(PrimFieldGetterSetter));
					}
				}

				private static FieldWrapper GetFieldWrapper(jiObjectStreamField field)
				{
					jlrField f = field.getField();
					return f == null ? null : FieldWrapper.FromField(f);
				}

				public override jiObjectStreamField[] getFields()
				{
					return fields;
				}

				public override void getObjFieldValues(object obj, object[] objarr)
				{
					objFieldGetter(obj, objarr);
				}

				public override void setObjFieldValues(object obj, object[] objarr)
				{
					objFieldSetter(obj, objarr);
				}

				public override void getPrimFieldValues(object obj, byte[] barr)
				{
					primFieldGetter(obj, barr);
				}

				public override void setPrimFieldValues(object obj, byte[] barr)
				{
					primFieldSetter(obj, barr);
				}
			}
#endif // !FIRST_PASS

			public static object getFastFieldReflector(object fieldsObj)
			{
#if FIRST_PASS
				return null;
#else
				return new FastFieldReflector((jiObjectStreamField[])fieldsObj);
#endif
			}
		}

		static class Win32FileSystem
		{
			internal const int ACCESS_READ = 0x04;
			const int ACCESS_WRITE = 0x02;
			const int ACCESS_EXECUTE = 0x01;

			public static string getDriveDirectory(object _this, int drive)
			{
				try
				{
					string path = ((char)('A' + (drive - 1))) + ":";
					return System.IO.Path.GetFullPath(path).Substring(2);
				}
				catch (ArgumentException)
				{
				}
				catch (System.Security.SecurityException)
				{
				}
				catch (System.IO.PathTooLongException)
				{
				}
				return "\\";
			}

			private static string CanonicalizePath(string path)
			{
				try
				{
					System.IO.FileInfo fi = new System.IO.FileInfo(path);
					if (fi.DirectoryName == null)
					{
						return path.Length > 1 && path[1] == ':'
							? (Char.ToUpper(path[0]) + ":" + System.IO.Path.DirectorySeparatorChar)
							: path;
					}
					string dir = CanonicalizePath(fi.DirectoryName);
					string name = fi.Name;
					try
					{
						if (!VirtualFileSystem.IsVirtualFS(path))
						{
							string[] arr = System.IO.Directory.GetFileSystemEntries(dir, name);
							if (arr.Length == 1)
							{
								name = arr[0];
							}
						}
					}
					catch (System.UnauthorizedAccessException)
					{
					}
					catch (System.IO.IOException)
					{
					}
					return System.IO.Path.Combine(dir, name);
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.Security.SecurityException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				return path;
			}

			public static string canonicalize0(object _this, string path)
			{
#if FIRST_PASS
				return null;
#else
				try
				{
					// TODO there is still a known bug here. A dotted path component right after the root component
					// are not removed as they should be. E.g. "c:\..." => "C:\..." or "\\server\..." => IOException
					// Another know issue is that when running under Mono on Windows, the case names aren't converted
					// to the correct (on file system) casing.
					//
					// FXBUG we're appending the directory separator to work around an apparent .NET bug.
					// If we don't do this, "c:\j\." would be canonicalized to "C:\"
					int colon = path.IndexOf(':', 2);
					if (colon != -1)
					{
						return CanonicalizePath(path.Substring(0, colon) + System.IO.Path.DirectorySeparatorChar) + path.Substring(colon);
					}
					return CanonicalizePath(path + System.IO.Path.DirectorySeparatorChar);
				}
				catch (System.ArgumentException x)
				{
					throw new jiIOException(x.Message);
				}
#endif
			}

			public static string canonicalizeWithPrefix0(object _this, string canonicalPrefix, string pathWithCanonicalPrefix)
			{
				return canonicalize0(_this, pathWithCanonicalPrefix);
			}

			private static string GetPathFromFile(jiFile file)
			{
#if FIRST_PASS
				return null;
#else
				return file.getPath();
#endif
			}

			public static int getBooleanAttributes(object _this, jiFile f)
			{
				try
				{
					string path = GetPathFromFile(f);
					if (VirtualFileSystem.IsVirtualFS(path))
					{
						return VirtualFileSystem.GetBooleanAttributes(path);
					}
					System.IO.FileAttributes attr = System.IO.File.GetAttributes(path);
					const int BA_EXISTS = 0x01;
					const int BA_REGULAR = 0x02;
					const int BA_DIRECTORY = 0x04;
					const int BA_HIDDEN = 0x08;
					int rv = BA_EXISTS;
					if ((attr & System.IO.FileAttributes.Directory) != 0)
					{
						rv |= BA_DIRECTORY;
					}
					else
					{
						rv |= BA_REGULAR;
					}
					if ((attr & System.IO.FileAttributes.Hidden) != 0)
					{
						rv |= BA_HIDDEN;
					}
					return rv;
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.Security.SecurityException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				return 0;
			}

			public static bool checkAccess(object _this, jiFile f, int access)
			{
				string path = GetPathFromFile(f);
				if (VirtualFileSystem.IsVirtualFS(path))
				{
					return VirtualFileSystem.CheckAccess(path, access);
				}
				bool ok = true;
				if ((access & (ACCESS_READ | ACCESS_EXECUTE)) != 0)
				{
					ok = false;
					try
					{
						// HACK if path refers to a directory, we always return true
						if (!System.IO.Directory.Exists(path))
						{
							new System.IO.FileInfo(path).Open(
								System.IO.FileMode.Open,
								System.IO.FileAccess.Read,
								System.IO.FileShare.ReadWrite).Close();
						}
						ok = true;
					}
					catch (System.Security.SecurityException)
					{
					}
					catch (System.ArgumentException)
					{
					}
					catch (System.UnauthorizedAccessException)
					{
					}
					catch (System.IO.IOException)
					{
					}
					catch (System.NotSupportedException)
					{
					}
				}
				if (ok && ((access & ACCESS_WRITE) != 0))
				{
					ok = false;
					try
					{
						// HACK if path refers to a directory, we always return true
						if (System.IO.Directory.Exists(path))
						{
							ok = true;
						}
						else
						{
							System.IO.FileInfo fileInfo = new System.IO.FileInfo(path);
							// Like the JDK we'll only look at the read-only attribute and not
							// the security permissions associated with the file or directory.
							ok = (fileInfo.Attributes & System.IO.FileAttributes.ReadOnly) == 0;
						}
					}
					catch (System.Security.SecurityException)
					{
					}
					catch (System.ArgumentException)
					{
					}
					catch (System.UnauthorizedAccessException)
					{
					}
					catch (System.IO.IOException)
					{
					}
					catch (System.NotSupportedException)
					{
					}
				}
				return ok;
			}

			private static long DateTimeToJavaLongTime(System.DateTime datetime)
			{
				return (System.TimeZone.CurrentTimeZone.ToUniversalTime(datetime) - new System.DateTime(1970, 1, 1)).Ticks / 10000L;
			}

			private static System.DateTime JavaLongTimeToDateTime(long datetime)
			{
				return System.TimeZone.CurrentTimeZone.ToLocalTime(new System.DateTime(new System.DateTime(1970, 1, 1).Ticks + datetime * 10000L));
			}

			public static long getLastModifiedTime(object _this, jiFile f)
			{
				try
				{
					DateTime dt = System.IO.File.GetLastWriteTime(GetPathFromFile(f));
					if (dt.ToFileTime() == 0)
					{
						return 0;
					}
					else
					{
						return DateTimeToJavaLongTime(dt);
					}
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				return 0;
			}

			public static long getLength(object _this, jiFile f)
			{
				try
				{
					string path = GetPathFromFile(f);
					if (VirtualFileSystem.IsVirtualFS(path))
					{
						return VirtualFileSystem.GetLength(path);
					}
					return new System.IO.FileInfo(path).Length;
				}
				catch (System.Security.SecurityException)
				{
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				return 0;
			}

			public static bool setPermission(object _this, jiFile f, int access, bool enable, bool owneronly)
			{
				if ((access & ACCESS_WRITE) != 0)
				{
					try
					{
						System.IO.FileInfo file = new System.IO.FileInfo(GetPathFromFile(f));
						if (enable)
						{
							file.Attributes &= ~System.IO.FileAttributes.ReadOnly;
						}
						else
						{
							file.Attributes |= System.IO.FileAttributes.ReadOnly;
						}
						return true;
					}
					catch (System.Security.SecurityException)
					{
					}
					catch (System.ArgumentException)
					{
					}
					catch (System.UnauthorizedAccessException)
					{
					}
					catch (System.IO.IOException)
					{
					}
					catch (System.NotSupportedException)
					{
					}
					return false;
				}
				return enable;
			}

			public static bool createFileExclusively(object _this, string path)
			{
#if !FIRST_PASS
				try
				{
					System.IO.File.Open(path, System.IO.FileMode.CreateNew, System.IO.FileAccess.ReadWrite, System.IO.FileShare.None).Close();
					return true;
				}
				catch (System.ArgumentException x)
				{
					throw new jiIOException(x.Message);
				}
				catch (System.IO.IOException x)
				{
					if (!System.IO.File.Exists(path) && !System.IO.Directory.Exists(path))
					{
						throw new jiIOException(x.Message);
					}
				}
				catch (System.UnauthorizedAccessException x)
				{
					if (!System.IO.File.Exists(path) && !System.IO.Directory.Exists(path))
					{
						throw new jiIOException(x.Message);
					}
				}
				catch (System.NotSupportedException x)
				{
					throw new jiIOException(x.Message);
				}
#endif
				return false;
			}

			public static bool delete0(object _this, jiFile f)
			{
				System.IO.FileSystemInfo fileInfo = null;
				try
				{
					string path = GetPathFromFile(f);
					if (System.IO.Directory.Exists(path))
					{
						fileInfo = new System.IO.DirectoryInfo(path);
					}
					else if (System.IO.File.Exists(path))
					{
						fileInfo = new System.IO.FileInfo(path);
					}
					else
					{
						return false;
					}
					// We need to be able to delete read-only files/dirs too, so we clear
					// the read-only attribute, if set.
					if ((fileInfo.Attributes & System.IO.FileAttributes.ReadOnly) != 0)
					{
						fileInfo.Attributes &= ~System.IO.FileAttributes.ReadOnly;
					}
					fileInfo.Delete();
					return true;
				}
				catch (System.Security.SecurityException)
				{
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				return false;
			}

			public static string[] list(object _this, jiFile f)
			{
				try
				{
					string path = GetPathFromFile(f);
					if (VirtualFileSystem.IsVirtualFS(path))
					{
						return VirtualFileSystem.List(path);
					}
					string[] l = System.IO.Directory.GetFileSystemEntries(path);
					for (int i = 0; i < l.Length; i++)
					{
						int pos = l[i].LastIndexOf(System.IO.Path.DirectorySeparatorChar);
						if (pos >= 0)
						{
							l[i] = l[i].Substring(pos + 1);
						}
					}
					return l;
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				return null;
			}

			public static bool createDirectory(object _this, jiFile f)
			{
				try
				{
					string path = GetPathFromFile(f);
					System.IO.DirectoryInfo parent = System.IO.Directory.GetParent(path);
					if (parent == null ||
						!System.IO.Directory.Exists(parent.FullName) ||
						System.IO.Directory.Exists(path))
					{
						return false;
					}
					return System.IO.Directory.CreateDirectory(path) != null;
				}
				catch (System.Security.SecurityException)
				{
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				return false;
			}

			public static bool rename0(object _this, jiFile f1, jiFile f2)
			{
				try
				{
					new System.IO.FileInfo(GetPathFromFile(f1)).MoveTo(GetPathFromFile(f2));
					return true;
				}
				catch (System.Security.SecurityException)
				{
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				return false;
			}

			public static bool setLastModifiedTime(object _this, jiFile f, long time)
			{
				try
				{
					new System.IO.FileInfo(GetPathFromFile(f)).LastWriteTime = JavaLongTimeToDateTime(time);
					return true;
				}
				catch (System.Security.SecurityException)
				{
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				return false;
			}

			public static bool setReadOnly(object _this, jiFile f)
			{
				try
				{
					System.IO.FileInfo fileInfo = new System.IO.FileInfo(GetPathFromFile(f));
					fileInfo.Attributes |= System.IO.FileAttributes.ReadOnly;
					return true;
				}
				catch (System.Security.SecurityException)
				{
				}
				catch (System.ArgumentException)
				{
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.NotSupportedException)
				{
				}
				return false;
			}

			public static int listRoots0()
			{
				try
				{
					int drives = 0;
					foreach (string drive in Environment.GetLogicalDrives())
					{
						char c = Char.ToUpper(drive[0]);
						drives |= 1 << (c - 'A');
					}
					return drives;
				}
				catch (System.IO.IOException)
				{
				}
				catch (System.UnauthorizedAccessException)
				{
				}
				catch (System.Security.SecurityException)
				{
				}
				return 0;
			}
			
			[System.Security.SecuritySafeCritical]
			public static long getSpace0(object _this, jiFile f, int t)
			{
				const int SPACE_TOTAL = 0;
				const int SPACE_FREE = 1;
				const int SPACE_USABLE = 2;
				long freeAvailable;
				long total;
				long totalFree;
				if (GetDiskFreeSpaceEx(GetPathFromFile(f), out freeAvailable, out total, out totalFree) != 0)
				{
					switch (t)
					{
						case SPACE_TOTAL:
							return total;
						case SPACE_FREE:
							return totalFree;
						case SPACE_USABLE:
							return freeAvailable;
					}
				}
				return 0;
			}

			[System.Runtime.InteropServices.DllImport("kernel32")]
			private static extern int GetDiskFreeSpaceEx(string directory, out long freeAvailable, out long total, out long totalFree);

			public static void initIDs()
			{
			}
		}

		static class UnixFileSystem
		{
			public static int getBooleanAttributes0(object _this, jiFile f)
			{
				return Win32FileSystem.getBooleanAttributes(_this, f);
			}

			public static long getSpace(object _this, jiFile f, int t)
			{
				// TODO
				return 0;
			}

			public static string getDriveDirectory(object _this, int drive)
			{
				return Win32FileSystem.getDriveDirectory(_this, drive);
			}

			public static string canonicalize0(object _this, string path)
			{
				return Win32FileSystem.canonicalize0(_this, path);
			}

			public static bool checkAccess(object _this, jiFile f, int access)
			{
				return Win32FileSystem.checkAccess(_this, f, access);
			}

			public static long getLastModifiedTime(object _this, jiFile f)
			{
				return Win32FileSystem.getLastModifiedTime(_this, f);
			}

			public static long getLength(object _this, jiFile f)
			{
				return Win32FileSystem.getLength(_this, f);
			}

			public static bool setPermission(object _this, jiFile f, int access, bool enable, bool owneronly)
			{
				// TODO consider using Mono.Posix
				return Win32FileSystem.setPermission(_this, f, access, enable, owneronly);
			}

			public static bool createFileExclusively(object _this, string path)
			{
				return Win32FileSystem.createFileExclusively(_this, path);
			}

			public static bool delete0(object _this, jiFile f)
			{
				return Win32FileSystem.delete0(_this, f);
			}

			public static string[] list(object _this, jiFile f)
			{
				return Win32FileSystem.list(_this, f);
			}

			public static bool createDirectory(object _this, jiFile f)
			{
				return Win32FileSystem.createDirectory(_this, f);
			}

			public static bool rename0(object _this, jiFile f1, jiFile f2)
			{
				return Win32FileSystem.rename0(_this, f1, f2);
			}

			public static bool setLastModifiedTime(object _this, jiFile f, long time)
			{
				return Win32FileSystem.setLastModifiedTime(_this, f, time);
			}

			public static bool setReadOnly(object _this, jiFile f)
			{
				return Win32FileSystem.setReadOnly(_this, f);
			}

			public static void initIDs()
			{
			}
		}
	}

d4686 1
a4686 1
				if (VirtualFileSystem.CheckAccess(path, IKVM.NativeCode.java.io.Win32FileSystem.ACCESS_READ))
d6884 1
a6884 1
			return java.io.ObjectInputStream.latestUserDefinedLoader();
@


1.307.2.1
log
@Backported fixes:
- Volatile long/double fields should not use slow reflection.
- Reduce complexity of annotation custom attributes to improve perf and lower risk (in broken apps that should have used ReflectionOnly).
- Removed accidentally public methods from AnnotationAttributeBase.
- Fixed AnnotationAttributeBase to freeze in writeReplace/Equals/GetHashCode/ToString.
@
text
@a7196 4
					if (fw.IsVolatile && (fw.FieldTypeWrapper == PrimitiveTypeWrapper.LONG || fw.FieldTypeWrapper == PrimitiveTypeWrapper.DOUBLE))
					{
						return false;
					}
@


1.306
log
@Fixed a typo in ikvm.runtime.Startup.addBootClassPathAssembly().
@
text
@d3173 1
a3173 1
		static class LangHelper
d3175 3
a3177 2
			// NOTE the array may contain duplicates!
			public static string[] getBootClassPackages()
d3179 10
a3188 1
				return ClassLoaderWrapper.GetBootstrapClassLoader().GetPackages();
a3189 1
		}
a3190 2
		static class Package
		{
d3193 4
a3196 2
				// this method is not implemented because we redirect Package.getSystemPackage() to our implementation in LangHelper
				throw new NotImplementedException();
d3201 4
a3204 2
				// this method is not implemented because we redirect Package.getSystemPackages() to our implementation in LangHelper
				throw new NotImplementedException();
@


1.305
log
@- Removed CallerID from ICustomInvoke.
- Removed ICustomInvoke constructor invocation path, because there aren't any dynamic only constructors.
@
text
@d347 1
a347 1
		public static void addBootClassPathAssemby(Assembly asm)
@


1.304
log
@Simplified class loading exception handling.
@
text
@d6318 1
a6318 1
					retval = ((ICustomInvoke)mw).Invoke(obj, args, callerID);
a6764 25
		private sealed class ConstructorAccessorImpl : srConstructorAccessor
		{
			private readonly MethodWrapper mw;

			internal ConstructorAccessorImpl(jlrConstructor constructor)
			{
				mw = MethodWrapper.FromMethodOrConstructor(constructor);
			}

			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
			{
				args = ConvertArgs(mw.DeclaringType.GetClassLoader(), mw.GetParameters(), args);
				try
				{
					return ((ICustomInvoke)mw).Invoke(null, args, null);
				}
				catch (MethodAccessException x)
				{
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
				}
			}
		}

d8150 1
a8150 5
			if (mw is ICustomInvoke)
			{
				return new ConstructorAccessorImpl(cons);
			}
			else if (ActivatorConstructorAccessor.IsSuitable(mw))
@


1.303
log
@Finish should be called inside RetargetableJavaException try block.
@
text
@d2430 8
@


1.302
log
@Moved AssemblyClassLoader package definition to runtime.
@
text
@a2589 7
				TypeWrapper tw = TypeWrapper.FromClass(thisClass);
				tw.Finish();
				string[] enc = tw.GetEnclosingMethod();
				if (enc == null)
				{
					return null;
				}
d2592 7
@


1.301
log
@Removed the old Java stub class generator and replaced it with the ikvmstub core.
@
text
@d3165 9
@


1.300
log
@Use EnumerationWrapper to lazily expose the resources.
@
text
@a91 1
using StubGenerator = ikvm.@@internal.stubgen.StubGenerator;
@


1.299
log
@Removed map.xml patching of bootstrap resource loading methods in java.lang.ClassLoader.
@
text
@d2955 1
a2955 6
				global::java.util.Vector v = new global::java.util.Vector();
				foreach (global::java.net.URL url in ClassLoaderWrapper.GetBootstrapClassLoader().GetResources(name))
				{
					v.add(url);
				}
				return v.elements();
@


1.298
log
@Renamed ClassLoaderWrapper.GetLoadedClass() to FindLoadedClass().
@
text
@d2941 23
@


1.297
log
@Project stub classes into the jar the classes originated from.
@
text
@d3026 1
a3026 1
				TypeWrapper tw = loader.GetLoadedClass(name);
@


1.296
log
@Changed GetProtectionDomain() to return java.security.ProtectionDomain instead of object.
@
text
@d5278 42
@


1.295
log
@Added more Class and ClassLoader types in signatures.
@
text
@d2654 1
a2654 1
						pd = (ProtectionDomain)acl.GetProtectionDomain();
@


1.294
log
@Use java.lang.Class in ClassLoader native method signatures.
@
text
@d2533 1
a2533 1
			public static object getClassLoader0(jlClass thisClass)
d2538 1
a2538 1
			public static object getSuperclass(jlClass thisClass)
d2544 1
a2544 1
			public static object getInterfaces(jlClass thisClass)
d2559 1
a2559 1
			public static object getComponentType(jlClass thisClass)
d2608 1
a2608 1
			public static object getDeclaringClass(jlClass thisClass)
d2668 1
a2668 1
			public static object getPrimitiveClass(string name)
d2899 1
a2899 1
			public static object getDeclaredClasses0(jlClass thisClass)
@


1.293
log
@Added support for "dynamic" (non-loadable type) annotations in statically compiled code.
@
text
@d2941 1
a2941 1
			public static object defineClass0(jlClassLoader thisClassLoader, string name, byte[] b, int off, int len, ProtectionDomain pd)
d2946 1
a2946 1
			public static object defineClass1(jlClassLoader thisClassLoader, string name, byte[] b, int off, int len, ProtectionDomain pd, string source)
d2985 1
a2985 1
			public static object defineClass2(jlClassLoader thisClassLoader, string name, jnByteBuffer bb, int off, int len, ProtectionDomain pd, string source)
d2996 1
a2996 1
			public static void resolveClass0(jlClassLoader thisClassLoader, object clazz)
d3001 1
a3001 1
			public static object findBootstrapClass(jlClassLoader thisClassLoader, string name)
d3019 1
a3019 1
			public static object findLoadedClass0(jlClassLoader thisClassLoader, string name)
@


1.292
log
@Forgot to use the resolved field type in two places.
@
text
@d2704 1
a2704 1
			internal static object AnnotationsToMap(object[] objAnn)
d2719 5
d2762 1
a2762 1
				return AnnotationsToMap(wrapper.GetDeclaredAnnotations());
d3701 1
a3701 1
					return Class.AnnotationsToMap(fw.DeclaringType.GetFieldAnnotations(fw));
d3710 1
a3710 1
					return Class.AnnotationsToMap(mw.DeclaringType.GetMethodAnnotations(mw));
d3735 4
@


1.291
log
@Fixed reflection handling of unloadable types.
@
text
@d969 1
a969 1
								fw.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilgenObjGetter);
d977 2
a978 2
								fw.FieldTypeWrapper.EmitCheckcast(ilgenObjSetter);
								fw.FieldTypeWrapper.EmitConvStackTypeToSignatureType(ilgenObjSetter, null);
@


1.290
log
@Removed unused (and bogus) parameter from TypeWrapper.EmitCheckcast() and EmitInstanceOf().
@
text
@d2 1
a2 1
  Copyright (C) 2007-2011 Jeroen Frijters
d868 1
d6167 1
a6167 1
		private static object[] ConvertArgs(TypeWrapper[] argumentTypes, object[] args)
d6193 1
a6193 1
					if (args[i] != null && !argumentTypes[i].IsInstance(args[i]))
d6223 1
a6223 1
				args = ConvertArgs(mw.GetParameters(), args);
d6328 17
a6344 1
				mw.DeclaringType.Finish();
d6358 1
a6358 1
				if (mw.GetParameters().Length == 0)
d6366 1
a6366 1
				ilgen.EmitLdc_I4(mw.GetParameters().Length);
d6373 1
a6373 1
				CodeEmitterLocal[] args = new CodeEmitterLocal[mw.GetParameters().Length + thisCount];
d6380 1
a6380 2
					mw.GetParameters()[i - thisCount].Finish();
					args[i] = ilgen.DeclareLocal(mw.GetParameters()[i - thisCount].TypeAsSignatureType);
d6395 1
a6395 1
					TypeWrapper tw = mw.GetParameters()[i - thisCount];
d6692 1
a6692 1
				args = ConvertArgs(mw.GetParameters(), args);
d6713 17
a6729 1
				mw.DeclaringType.Finish();
d6737 1
a6737 1
				if (mw.GetParameters().Length == 0)
d6745 1
a6745 1
				ilgen.EmitLdc_I4(mw.GetParameters().Length);
d6751 1
a6751 1
				CodeEmitterLocal[] args = new CodeEmitterLocal[mw.GetParameters().Length];
d6754 1
a6754 2
					mw.GetParameters()[i].Finish();
					args[i] = ilgen.DeclareLocal(mw.GetParameters()[i].TypeAsSignatureType);
d6762 1
a6762 1
					TypeWrapper tw = mw.GetParameters()[i];
d7114 2
a7115 1
					return tw.IsNonPrimitiveValueType
d7890 11
a7900 2
				fw.FieldTypeWrapper.Finish();
				fw.DeclaringType.Finish();
d7907 1
a7907 1
					fw.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilgen);
d7915 1
a7915 1
					fw.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilgen);
d7936 11
a7946 2
				fw.FieldTypeWrapper.Finish();
				fw.DeclaringType.Finish();
d7956 2
a7957 2
						fw.FieldTypeWrapper.EmitCheckcast(ilgen);
						fw.FieldTypeWrapper.EmitConvStackTypeToSignatureType(ilgen, null);
d7983 1
a7983 1
						fw.FieldTypeWrapper.EmitCheckcast(ilgen);
d7985 1
a7985 1
					fw.FieldTypeWrapper.EmitConvStackTypeToSignatureType(ilgen, null);
@


1.289
log
@Implemented package access checks (dynamic mode only).
@
text
@d976 1
a976 1
								fw.FieldTypeWrapper.EmitCheckcast(null, ilgenObjSetter);
d6370 1
a6370 1
					mw.DeclaringType.EmitCheckcast(null, ilgen);
d6605 1
a6605 1
					type.EmitCheckcast(null, ilgen);
d7906 1
a7906 1
						fw.FieldTypeWrapper.EmitCheckcast(null, ilgen);
d7933 1
a7933 1
						fw.FieldTypeWrapper.EmitCheckcast(null, ilgen);
@


1.288
log
@Added missing SecuritySafeCritical attribute.
@
text
@d2935 1
a2935 1
			public static object defineClass0(jlClassLoader thisClassLoader, string name, byte[] b, int off, int len, object pd)
d2940 1
a2940 1
			public static object defineClass1(jlClassLoader thisClassLoader, string name, byte[] b, int off, int len, object pd, string source)
@


1.287
log
@Bug fix. Don't try to inject DynamicMethod in array types (applies to array.clone() method for MethodHandles).
@
text
@d5224 1
@


1.286
log
@Removed some O(n^2) operations to improve handling of class files with a large number of fields.
@
text
@d294 1
a294 1
			if (owner.IsInterface)
d296 1
a296 1
				// FXBUG interfaces aren't allowed as owners of dynamic methods
@


1.285
log
@- Marked MemberWrapper class abstract.
- Marked all classes that don't (and shouldn't) have subclasses sealed.
@
text
@d2785 1
a2785 1
							list.Add((jlrField)fields[i].ToField(false));
@


1.285.2.1
log
@Backport: Added missing SecuritySafeCritical attribute.
@
text
@a5223 1
                    [System.Security.SecuritySafeCritical]
@


1.284
log
@Fixed some minor class modifiers issues:
- stub generator now reproduces exact class modifier bits
- unused bits are now properly masked and returned
- non-abstract interfaces now properly return ACC_ABSTRACT
@
text
@d131 1
a131 1
		private class OptionNode
d4075 1
a4075 1
			private class NetworkInterfaceInfo
d5663 1
a5663 1
        private class CriticalCtrlHandler : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
@


1.283
log
@- Made CodeEmitter more "type safe" by adding specific EmitXxx methods instead of following the more general ILGenerator pattern.
- Added some new optimizations to CodeEmitter (disabled unless experimental optimizations are enabled).
- Added some invariant checks to CodeEmitter to help debug optimizations (and document the invariants).
@
text
@d6147 5
a6151 1
			return (int)TypeWrapper.FromClass(clazz).Modifiers;
@


1.282
log
@Integrated OpenJDK 7u4. Not all forked files have been merged yet, just the ones necessary to get things building.
@
text
@d878 1
a878 1
								ilgenPrimGetter.Emit(OpCodes.Ldc_I4, field.getOffset());
d922 1
a922 1
								ilgenPrimSetter.Emit(OpCodes.Ldc_I4, field.getOffset());
d965 1
a965 1
								ilgenObjGetter.Emit(OpCodes.Ldc_I4, field.getOffset());
d974 1
a974 1
								ilgenObjSetter.Emit(OpCodes.Ldc_I4, field.getOffset());
d6340 1
a6340 1
					ilgen.Emit(OpCodes.Brfalse_S, argsLengthOK);
d6344 2
a6345 2
				ilgen.Emit(OpCodes.Ldc_I4, mw.GetParameters().Length);
				ilgen.Emit(OpCodes.Beq_S, argsLengthOK);
d6372 1
a6372 1
					ilgen.Emit(OpCodes.Ldc_I4, i - thisCount);
d6380 1
a6380 1
				ilgen.Emit(OpCodes.Leave, label1);
d6419 1
a6419 1
				ilgen.Emit(OpCodes.Leave, label2);
d6438 1
a6438 1
					ilgen.Emit(OpCodes.Brtrue_S, labelWrap);
d6443 1
a6443 1
					ilgen.Emit(OpCodes.Brtrue_S, label);
d6506 1
a6506 1
					ilgen.Emit(OpCodes.Brfalse_S, next);
d6512 1
a6512 1
					ilgen.Emit(OpCodes.Br_S, done);
d6524 1
a6524 1
						ilgen.Emit(OpCodes.Brfalse_S, next);
d6528 1
a6528 1
						ilgen.Emit(OpCodes.Br_S, done);
d6533 1
a6533 1
						ilgen.Emit(OpCodes.Brfalse_S, next);
d6537 1
a6537 1
						ilgen.Emit(OpCodes.Br_S, done);
d6549 1
a6549 1
							ilgen.Emit(OpCodes.Brfalse_S, next);
d6553 1
a6553 1
							ilgen.Emit(OpCodes.Br_S, done);
d6565 1
a6565 1
								ilgen.Emit(OpCodes.Brfalse_S, next);
d6569 1
a6569 1
								ilgen.Emit(OpCodes.Br_S, done);
d6581 1
a6581 1
									ilgen.Emit(OpCodes.Brfalse_S, next);
d6584 1
a6584 1
									ilgen.Emit(OpCodes.Br_S, done);
d6704 1
a6704 1
					ilgen.Emit(OpCodes.Brfalse_S, argsLengthOK);
d6708 2
a6709 2
				ilgen.Emit(OpCodes.Ldc_I4, mw.GetParameters().Length);
				ilgen.Emit(OpCodes.Beq_S, argsLengthOK);
d6724 1
a6724 1
					ilgen.Emit(OpCodes.Ldc_I4, i);
d6732 1
a6732 1
				ilgen.Emit(OpCodes.Leave, label1);
d6751 1
a6751 1
				ilgen.Emit(OpCodes.Leave, label2);
d6758 1
a6758 1
				ilgen.Emit(OpCodes.Brtrue_S, label);
d7873 1
a7873 1
					ilgen.Emit(OpCodes.Leave, label);
d7905 1
a7905 1
						ilgen.Emit(OpCodes.Leave, label);
d7933 1
a7933 1
					ilgen.Emit(OpCodes.Leave, label);
@


1.281
log
@Move getThreads() to native code for reusing on other place. This is also more like the Java behavior.
@
text
@a8236 1
			SetField(thisObj, "impersonationToken", id.Token.ToInt64());
d8243 5
@


1.280
log
@Bug fix. Don't call Finish on unloadable TypeWrapper.
@
text
@d3506 21
@


1.279
log
@It turns out that it isn't a good idea to mutate the member types (and lose the fact that they are unloadable), so now we only do the conversion when generating the Java reflection wrapper for the member.
@
text
@a2906 1
						wrappers[i].Finish();
d2915 1
@


1.278
log
@mark getSpace0 with SecuritySafeCritical to avoid getting an exception with .NET 4
@
text
@a2784 1
							fields[i].EnsureLoadable();
a2820 2
					// we need to look through the array for unloadable types, because we may not let them
					// escape into the 'wild'
a2830 1
							methods[i].EnsureLoadable();
a2866 2
					// we need to look through the array for unloadable types, because we may not let them
					// escape into the 'wild'
a2876 1
							methods[i].EnsureLoadable();
@


1.277
log
@When a member with unloadable types in its signature is exposed via reflection, the unloadable types should be resolved to actual types.
@
text
@d1626 2
a1627 1

d8490 1
a8490 1
}
@


1.276
log
@Relax class name validation for trusted class loaders.
@
text
@d2784 1
a2784 1
							fields[i].FieldTypeWrapper.EnsureLoadable(wrapper.GetClassLoader());
d2833 1
a2833 6
							methods[i].ReturnType.EnsureLoadable(wrapper.GetClassLoader());
							TypeWrapper[] args = methods[i].GetParameters();
							for (int j = 0; j < args.Length; j++)
							{
								args[j].EnsureLoadable(wrapper.GetClassLoader());
							}
d2882 1
a2882 5
							TypeWrapper[] args = methods[i].GetParameters();
							for (int j = 0; j < args.Length; j++)
							{
								args[j].EnsureLoadable(wrapper.GetClassLoader());
							}
@


1.275
log
@Implemented com.sun.security.auth.module.NTSystem.getCurrent().
@
text
@d2969 4
@


1.275.2.1
log
@Backported fixes:
- FileStore for non-accessible drive should throw exception when trying to create the FileStore, not when accessing the name() or type() properties.
- Graphics2D.clip(null) should only throw NPE for a Component graphics.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Handle Main-Class manifest value that spans multiple lines. Fix for bug #3461012.
- Informational messages should not be treated as error when -warnaserror is specified. Fix for #3443377.
- Don't enforce pre-1.5 class name rules in ikvmc (since HotSpot doesn't enforce any naming rules for classes loaded by the system (and boot) class loader, by default). Fix for #3443373.
- Fix for #3441959.
- Throwable.addSuppressed() didn't have a proper parameter name.
- mark getSpace0 with SecuritySafeCritical to avoid getting an exception with .NET 4
- Bug fix. Removed incorrect check for uninitialized objects on backward branch.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Added AssemblyInformationalVersionAttribute to OpenJDK assemblies (to set the "Product Version"). Part of patch #3458997.
- Include copyright and metadata in IKVM.OpenJDK.Tools.dll. Part of patch #3458997.
- Bug fix. Don't call Finish on unloadable TypeWrapper.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
- Suppress annotation custom attributes when enumerating inner classes.
- IKVM.Reflection: Bug fix. Fixed copy/paste error. FieldInfo.IsAssembly should test for FieldAttributes.Assembly access, not FieldAttributes.Family.
@
text
@d1626 1
a1626 2
			
			[System.Security.SecuritySafeCritical]
d2922 1
a2930 1
						wrappers[i].Finish();
@


1.274
log
@Bug fix. IPInterfaceProperties.GetIPv_Properties() can throw an exception (and does so on Win 8 for some interfaces).
@
text
@d8207 2
d8213 20
a8232 1
			throw new NotImplementedException();
@


1.273
log
@Removed unnecessary link demand (because the class is no longer public) that screws up the .NET 4.0 security model.
@
text
@d4078 24
d4105 1
a4105 1
				System.Net.NetworkInformation.IPv4InterfaceProperties ipv4props = ipprops.GetIPv4Properties();
d4112 1
a4112 1
					System.Net.NetworkInformation.IPv6InterfaceProperties ipv6props = ipprops.GetIPv6Properties();
d4417 1
a4417 1
				System.Net.NetworkInformation.IPv4InterfaceProperties v4props = ipprops.GetIPv4Properties();
d4424 1
a4424 1
					System.Net.NetworkInformation.IPv6InterfaceProperties v6props = ipprops.GetIPv6Properties();
@


1.272
log
@Fix. When disambiguating executable names, we should only try to append .exe if the filename doesn't already contain a dot.
@
text
@a4690 1
		[System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.LinkDemand, UnmanagedCode = true)]
@


1.271
log
@Implemented Unsafe.defineClass().
@
text
@d3615 1
a3615 1
					else if (global::System.IO.File.Exists(file + ".exe"))
@


1.270
log
@Don't use "slow path" for field reflection on remapped types (as getting a Throwable field from cli.System.Exception will cause an exception, but the slow path will generate a different exception).
@
text
@d5864 9
@


1.269
log
@Implemented platform MBean server support (although with very limited information/exposed operations).
@
text
@d7034 1
a7034 1
				protected bool IsSpecialType(TypeWrapper tw)
d7041 1
a7041 1
				protected bool IsSlowPathCompatible(FieldWrapper fw)
d7043 1
a7043 1
					if (IsSpecialType(fw.DeclaringType) || IsSpecialType(fw.FieldTypeWrapper))
@


1.268
log
@Fix findLoadedClass0 to handle null string.
@
text
@d5804 5
a5808 1
			throw new NotImplementedException();
@


1.267
log
@Implemented dual stack sockets.
@
text
@d3026 4
@


1.266
log
@Added Kerberos support (on Windows). Based on patch submitted by Trevor Bell.
@
text
@d3763 16
a3778 5
			// On Linux we can't bind both an IPv4 and IPv6 to the same port, so we have to disable IPv6 until we have a dual-stack implementation.
			// Mono on Windows doesn't appear to support IPv6 either (Mono on Linux does).
			private static readonly bool ipv6supported = Type.GetType("Mono.Runtime") == null
				&& Environment.OSVersion.Platform == PlatformID.Win32NT
				&& System.Net.Sockets.Socket.OSSupportsIPv6;
@


1.265
log
@Merge in java.lang.invoke package and the beginnings of MethodHandle support.
@
text
@a8093 24
namespace IKVM.NativeCode.sun.security.krb5
{
	static class Credentials
	{
		public static object acquireDefaultNativeCreds()
		{
			// TODO
			return null;
		}
	}

	static class Config
	{
		public static string getWindowsDirectory(bool isSystem)
		{
			if (isSystem)
			{
				return Environment.SystemDirectory;
			}
			return Environment.GetEnvironmentVariable("SystemRoot");
		}
	}
}

@


1.264
log
@Add native method for FontDescriptor
@
text
@d5542 11
@


1.263
log
@Updated bulk of java.nio to OpenJDK 7.
@
text
@d5532 10
@


1.262
log
@First small steps in java.nio.file implementation. Update sun.util.calendar.ZoneInfoFile to OpenJDK 7, because it can now use our java.nio.file implementation.
@
text
@d4681 1
a4681 1
			public static bool isLoaded0(object thisMappedByteBuffer, long address, long length)
d4688 1
a4688 1
			public static int load0(object thisMappedByteBuffer, long address, long length, int pageSize)
d4695 2
a4696 2
					length -= pageSize;
					address += pageSize;
a4700 1
				return 0;
d4704 1
a4704 1
			public static void force0(object thisMappedByteBuffer, long address, long length)
@


1.261
log
@Updated java.net package to OpenJDK 7.
@
text
@d5883 56
@


1.260
log
@Add sun.misc.PerfCounter from OpenJDK 7.
@
text
@d4272 16
@


1.259
log
@Updated java.security package and a massive amount of dependencies to OpenJDK 7.
@
text
@d5744 5
a5748 1
			throw new NotImplementedException();
@


1.258
log
@Bug fix. Make FileOutputStream in append mode always append.
@
text
@d8011 1
a8011 1
		public static string getWindowsDirectory()
d8013 4
@


1.257
log
@Updated java.lang.ProcessImpl to OpenJDK 7. Added support for "magic" executable name with spaces detection (on windows).
redirectErrorStream will throw an IOException ("not implemented") when used without redirecting stdout, but previously redirectErrorStream wasn't implemented either (although it just ignored the flag instead of throwing an exception).
@
text
@d452 5
@


1.256
log
@- Updated java.lang.ClassLoader to OpenJDK 7 (minus PerfCounter and parallel class loading support)

Switched to 7:
- java.util.Collections
- sun.misc.ClassFileTransformer
- sun.misc.Launcher

Added from 7:
- java.lang.SafeVargs
@
text
@d3520 100
@


1.255
log
@Updated sun.misc.VM to OpenJDK 7.
@
text
@a2944 4
#if !FIRST_PASS
			private static jlClassNotFoundException classNotFoundException;
#endif

d3015 1
a3015 14
				if (tw == null)
				{
					// HACK for efficiency, we don't allocate a new exception here
					// (as this exception is thrown for *every* non-boot class that we load and
					// the exception is thrown away by our caller anyway)
					if (classNotFoundException == null)
					{
						jlClassNotFoundException ex = new jlClassNotFoundException(null, null);
						ex.setStackTrace(new jlStackTraceElement[] { new jlStackTraceElement("java.lang.ClassLoader", "findBootstrapClass", null, -2) });
						classNotFoundException = ex;
					}
					throw classNotFoundException;
				}
				return tw.ClassObject;
@


1.254
log
@Added experimental (and for the time being undocumented) support for having ikvmc pre-generate proxy classes.
@
text
@a5743 5
		public static void getThreadStateValues(int[][] vmThreadStateValues, string[][] vmThreadStateNames)
		{
			// TODO
		}

@


1.253
log
@Expose annotations on statically compiled code as java.lang.reflect.Proxy instead of the custom attribute object, to deal with broken code that assumes annotations are always implemented with Proxy.
Fix for #3254823.
@
text
@d3547 39
@


1.252
log
@Added ikvm.runtime.Startup.addBootClassPathAssemby() API.
@
text
@d2 1
a2 1
  Copyright (C) 2007, 2008, 2010 Jeroen Frijters
d2710 1
a2710 2
							global::ikvm.@@internal.AnnotationAttributeBase.freeze(a);
							map.put(a.annotationType(), a);
d2718 18
d3586 1
a3586 2
								global::ikvm.@@internal.AnnotationAttributeBase.freeze(a);
								list.Add(a);
@


1.252.2.1
log
@Backport: Bug fix. Make FileOutputStream in append mode always append.
@
text
@a451 5
				else if (fileMode == System.IO.FileMode.Append)
				{
					// this is the way to get atomic append behavior for all writes
					return new System.IO.FileStream(name, fileMode, System.Security.AccessControl.FileSystemRights.AppendData, System.IO.FileShare.ReadWrite, 1, System.IO.FileOptions.None);
				}
@


1.252.2.2
log
@Backport: Fix findLoadedClass0 to handle null string.
@
text
@a3025 4
				if (name == null)
				{
					return null;
				}
@


1.252.2.3
log
@Backport: Bug fix. IPInterfaceProperties.GetIPv_Properties() can throw an exception (and does so on Win 8 for some interfaces).
@
text
@a3928 24
			private static System.Net.NetworkInformation.IPv4InterfaceProperties GetIPv4Properties(System.Net.NetworkInformation.IPInterfaceProperties props)
			{
				try
				{
					return props.GetIPv4Properties();
				}
				catch (System.Net.NetworkInformation.NetworkInformationException)
				{
					return null;
				}
			}

			private static System.Net.NetworkInformation.IPv6InterfaceProperties GetIPv6Properties(System.Net.NetworkInformation.IPInterfaceProperties props)
			{
				try
				{
					return props.GetIPv6Properties();
				}
				catch (System.Net.NetworkInformation.NetworkInformationException)
				{
					return null;
				}
			}

d3932 1
a3932 1
				System.Net.NetworkInformation.IPv4InterfaceProperties ipv4props = GetIPv4Properties(ipprops);
d3939 1
a3939 1
					System.Net.NetworkInformation.IPv6InterfaceProperties ipv6props = GetIPv6Properties(ipprops);
d4228 1
a4228 1
				System.Net.NetworkInformation.IPv4InterfaceProperties v4props = GetIPv4Properties(ipprops);
d4235 1
a4235 1
					System.Net.NetworkInformation.IPv6InterfaceProperties v6props = GetIPv6Properties(ipprops);
@


1.252.2.4
log
@Backport: Implemented com.sun.security.auth.module.NTSystem.getCurrent().
@
text
@a7974 2
	using System.Security.Principal;

d7979 1
a7979 20
			WindowsIdentity id = WindowsIdentity.GetCurrent();
			string[] name = id.Name.Split('\\');
			SetField(thisObj, "userName", name[1]);
			SetField(thisObj, "domain", name[0]);
			SetField(thisObj, "domainSID", id.User.AccountDomainSid.Value);
			SetField(thisObj, "userSID", id.User.Value);
			string[] groups = new string[id.Groups.Count];
			for (int i = 0; i < groups.Length; i++)
			{
				groups[i] = id.Groups[i].Value;
			}
			SetField(thisObj, "groupIDs", groups);
			// HACK it turns out that Groups[0] is the primary group, but AFAIK this is not documented anywhere
			SetField(thisObj, "primaryGroupID", groups[0]);
			SetField(thisObj, "impersonationToken", id.Token.ToInt64());
		}

		private static void SetField(object thisObj, string field, object value)
		{
			thisObj.GetType().GetField(field, BindingFlags.NonPublic | BindingFlags.Instance).SetValue(thisObj, value);
@


1.252.2.5
log
@Backport: Don't use "slow path" for field reflection on remapped types (as getting a Throwable field from cli.System.Exception will cause an exception, but the slow path will generate a different exception).
@
text
@d6814 1
a6814 1
				private bool IsSpecialType(TypeWrapper tw)
d6821 1
a6821 1
				private bool IsSlowPathCompatible(FieldWrapper fw)
d6823 1
a6823 1
					if (IsSpecialType(fw.DeclaringType) || IsSpecialType(fw.FieldTypeWrapper) || fw.DeclaringType.IsRemapped)
@


1.252.2.6
log
@Updated version to 0.46.0.5 and backported bug fixes:
- IKVM.Reflection should ignore unknown metadata streams.
- Off-by-one error in local ref index reusing. Fix for bug #3575555.
- Interface mappings can be "incomplete". Fix for bug #3581564.
- The local variable state at the end of an exception block (if the last instruction is a local variable store) needs to be merged into the exception handler state.
- Local variable analysis for finally blocks was incorrect. Fixes bug #3600788.
- Don't implement interfaces that aren't accessible.
- Updated Mono workaround for Mono 3.0.x.
- Check for supported delegate signatures should detect pointers inside byref and array types and return type should be checked as well.
- Fake nested types should have Static modifier set in innerclasses attribute. Fixes scala compiler interop issue. Thanks to Michael Bayne for reporting this.
- ikvmstub -skiperror should also skip errors during WriteClass.
- An ITEMIDLIST should be freed using CoTaskMemFree.
- String.CaseInsensitiveComparator inner class should be acknowledged by String.
- Fixed the SHFILEINFO declaration. Thanks to Andras Kovacs for reporting this.
- Fixed race condition in MethodWrapper.ResolveMethod().
@
text
@d5111 1
a5111 4
						// older Mono versions did not wrap the exception in a TargetInvocationExcception,
						// so we check both x and x.InnerException
						if (typeofTimeZoneInfo.Assembly.GetType("System.TimeZoneNotFoundException").IsInstanceOfType(x)
							|| typeofTimeZoneInfo.Assembly.GetType("System.TimeZoneNotFoundException").IsInstanceOfType(x.InnerException))
@


1.251
log
@Removed VMThread class which only existed as a container for the jniDetach method.
@
text
@d347 5
@


1.250
log
@Ported fdlibm/floor and fdlibm/tan (and dependencies).
@
text
@d336 14
a3504 11
		static class VMThread
		{
			// this method is called from ikvm.runtime.Startup.exitMainThread() and from JNI
			public static void jniDetach()
			{
#if !FIRST_PASS
				jlThread.currentThread().die();
#endif
			}
		}

@


1.249
log
@Ported fdlibm/s_log1p.
@
text
@d3289 1
a3289 5
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.tan(d);
#endif
d3371 1
a3371 5
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.floor(d);
#endif
@


1.248
log
@Ported fdlibm/e_hypot.
@
text
@d3432 1
a3432 5
				if (d == 0.0)
				{
					return d;
				}
				return Math.Log(d + 1.0);
@


1.247
log
@- Ported fdlibm/s_exmp1.
- Fixed signed/unsigned issues in fdlibm/e_pow.
- Moved constants into method for fdlibm/e_pow and fdlibm/s_scalbn.
@
text
@d3422 1
a3422 1
				return sqrt(a * a + b * b);
@


1.246
log
@Ported fdlibm cbrt to C# and use that for StrictMath.cbrt().
@
text
@d3427 1
a3427 5
				if (d == 0.0)
				{
					return d;
				}
				return Math.Exp(d) - 1.0;
@


1.245
log
@- Added fdlibm files to project.
- Changed StrictMath.pow() to use new fdlibm version.
@
text
@d3352 1
a3352 13
				if (d > 0.0)
				{
					return Math.Pow(d, 1.0 / 3.0);
				}
				else if (d < 0.0)
				{
					return - Math.Pow(Math.Abs(d), 1.0 / 3.0);
				}
				else
				{
					// this handles NaN and signed zero
					return d;
				}
@


1.244
log
@Fixed Math bugs in cbrt, hypot, expm1 and log1p exposed by Malva MathTest.
@
text
@d3405 1
a3405 5
#if FIRST_PASS
				return 0;
#else
				return global::ikvm.@@internal.JMath.pow(x, y);
#endif
@


1.243
log
@- Check current UACVirtualization setting for every write access (because it can change).
- Fixed warning.
- Added check for Vista and up to UACVirtualization check.
@
text
@d3352 13
a3364 1
				return Math.Pow(d, 1.0 / 3.0);
d3438 1
a3438 1
				return a * a + b * b;
d3443 4
d3452 4
@


1.242
log
@Make the access behavior to the system preferences more like Java. Also the behavior with UAC was adapted.
@
text
@a4737 4
                // HACK we check if we can write in the system preferences 
                // we want not user registry virtualization for compatibility
                private static readonly bool windowsUac = Environment.OSVersion.Platform == PlatformID.Win32NT && UACVirtualization.Enabled;

d4799 4
a4802 1
                        if (writable && windowsUac && parent.Name.StartsWith("HKEY_LOCAL_MACHINE")) {
d4853 1
a4853 1
					catch (System.Security.SecurityException ex)
d4857 1
a4857 1
					catch (UnauthorizedAccessException ex)
d5023 4
@


1.241
log
@Made getStackAccessControlContext() parameters typed.
@
text
@d4736 5
a4740 1
				private static Microsoft.Win32.RegistryKey[] keys = new Microsoft.Win32.RegistryKey[16];
d4795 3
a4797 1
					bool writable = (securityMask & 0x30006) != 0;
d4802 13
a4814 1
						resultKey = MapKey(hKey).OpenSubKey(BytesToString(subKey), writable);
d4854 1
a4854 1
					catch (System.Security.SecurityException)
d4858 1
a4858 1
					catch (UnauthorizedAccessException)
d4869 1
a4869 1
						MapKey(hKey).DeleteSubKey(BytesToString(subKey));
d5008 23
a5030 1
		}
@


1.240
log
@Don't call GetIPv6Properties() if IPv6 isn't available.
@
text
@d4592 1
a4592 1
			public static object getStackAccessControlContext(object context, object callerID)
d4598 1
a4598 1
				bool is_privileged = GetProtectionDomains(array, (global::ikvm.@@internal.CallerID)callerID, new StackTrace(1));
d4606 1
a4606 1
				return CreateAccessControlContext(array, is_privileged, (jsAccessControlContext)context);
d4623 1
a4623 1
						global::java.lang.Class caller = ((global::ikvm.@@internal.CallerID)callerID).getCallerClass();
@


1.239
log
@Don't create zero length context arrays, use null reference instead. The Java code assumes that a non-null array always contains at least one element.
@
text
@d3932 1
a3932 1
				else
a3938 1
					return -1;
d3940 1
d4228 1
a4228 2
				System.Net.NetworkInformation.IPv6InterfaceProperties v6props = ipprops.GetIPv6Properties();
				if (v6props != null)
d4230 5
a4234 1
					return v6props.Mtu;
@


1.238
log
@File.canWrite() should always return true for directories (on Windows).
@
text
@a4601 1
					return CreateAccessControlContext(null, is_privileged, context);
d4603 1
a4603 1
				return CreateAccessControlContext(array.ToArray(), is_privileged, context);
d4642 1
a4642 1
			private static object CreateAccessControlContext(ProtectionDomain[] context, bool is_privileged, object privileged_context)
d4644 2
a4645 2
				jsAccessControlContext acc = new jsAccessControlContext(context, is_privileged);
				acc._privilegedContext((jsAccessControlContext)privileged_context);
d4683 1
a4683 1
						return CreateAccessControlContext(list.ToArray(), true, lc.context);
d4687 1
a4687 1
				return CreateAccessControlContext(list.ToArray(), false, null);
@


1.237
log
@UnauthorizedAccessException caused by already existing file or directory should cause createFileExclusively() to return false instead of throwing an exception.
@
text
@d1220 12
a1231 4
						System.IO.FileInfo fileInfo = new System.IO.FileInfo(path);
						// Like the JDK we'll only look at the read-only attribute and not
						// the security permissions associated with the file or directory.
						ok = (fileInfo.Attributes & System.IO.FileAttributes.ReadOnly) == 0;
@


1.236
log
@Remove implementation specific methods from top of stack trace for threads started from Java.
@
text
@d1370 4
a1373 1
					throw new jiIOException(x.Message);
@


1.235
log
@The full Thread parent hierarchy should be considered when capturing the stack.
@
text
@d3486 1
a3486 1
				ExceptionHelper.ExceptionInfoHelper.Append(stackTrace, stack, 0);
@


1.234
log
@AccessController.doPrivileged() stack frame was not recognized properly.
@
text
@d4583 11
a4593 1
				return GetStackAccessControlContextImpl(context, callerID, new StackTrace(1));
d4598 1
a4598 1
			private static object GetStackAccessControlContextImpl(object context, object callerID, StackTrace stack)
d4600 1
a4600 6
				object previous_protection_domain = null;
				object privileged_context = null;
				bool is_privileged = false;
				object protection_domain = null;
				List<ProtectionDomain> array = new List<ProtectionDomain>();

d4603 2
a4609 1
						privileged_context = context;
d4621 1
a4621 1
						array.Add((ProtectionDomain)protection_domain);
d4626 1
a4626 1
						break;
d4629 1
a4629 12

				if (array.Count == 0)
				{
					if (is_privileged && privileged_context == null)
					{
						return null;
					}

					return CreateAccessControlContext(null, is_privileged, privileged_context);
				}

				return CreateAccessControlContext(array.ToArray(), is_privileged, privileged_context);
d4639 1
a4639 1
			private static object GetProtectionDomainFromType(Type type)
d4668 10
a4677 1
				return GetStackAccessControlContextImpl(lc.context, lc.callerID, lc.stackTrace);
@


1.233
log
@Made Thread constructor stack capture more lazy.
@
text
@d4599 1
a4599 1
					if (method.DeclaringType == typeof(AccessController)
@


1.232
log
@File.lastModified() should return 0 for non-existing files. Fix for #3111432. Thanks to Stephen White for the patch.
@
text
@d4583 7
a4593 1
				StackTrace stack = new StackTrace(1);
a4634 1
#endif
a4636 1
#if !FIRST_PASS
d4668 6
a4673 1
				return jlThread.currentThread().inheritedAccessControlContext;
@


1.231
log
@- Removed EndExceptionBlockFinally and folded the behaviour into EndExceptionBlock (runtime compiler only).
- Removed EndExceptionBlockNoFallThrough() and added "leave guard" branch after every EndExceptionBlock (runtime compiler only).
- Fixed remaining dependencies on exception fall through behavior of ILGenerator.
@
text
@d1258 9
a1266 1
					return DateTimeToJavaLongTime(System.IO.File.GetLastWriteTime(GetPathFromFile(f)));
@


1.230
log
@Build intermediate store of MSIL code in CodeEmitter to allow post-processing optimization steps.
@
text
@d6011 2
d6022 1
d6050 2
d6085 1
d6363 2
d6374 1
d6382 2
d6398 1
d7504 2
d7512 1
d7536 2
d7544 1
d7564 2
d7572 1
@


1.229
log
@Wrapped LocalBuilder in new CodeEmitterLocal class to allow CodeEmitter to encapsulate the ILGenerator fully.
@
text
@d961 4
d6082 1
d6389 1
d6443 1
d7501 1
d7554 1
@


1.228
log
@Always wrap InvocationTargetException in another InvocationTargetException, to handle the case where a method is recursively calling itself.
@
text
@d824 2
a825 2
						LocalBuilder objGetterThis = ilgenObjGetter.DeclareLocal(tw.TypeAsBaseType);
						LocalBuilder primGetterThis = ilgenPrimGetter.DeclareLocal(tw.TypeAsBaseType);
d5954 1
a5954 1
				LocalBuilder ret = ilgen.DeclareLocal(typeof(object));
d5979 1
a5979 1
				LocalBuilder[] args = new LocalBuilder[mw.GetParameters().Length + thisCount];
d6317 1
a6317 1
				LocalBuilder ret = ilgen.DeclareLocal(typeof(object));
d6335 1
a6335 1
				LocalBuilder[] args = new LocalBuilder[mw.GetParameters().Length];
d7483 1
a7483 1
					LocalBuilder local = ilgen.DeclareLocal(fieldType);
@


1.227
log
@Implemented IPv6 support for java.net package APIs.
@
text
@d6045 1
d6056 6
d6068 1
@


1.226
log
@Added workaround for Mono TimeZoneInfo bug (https://bugzilla.novell.com/show_bug.cgi?id=622524).
@
text
@d3601 6
d3609 1
a3609 2
				// TODO System.Net.Sockets.Socket.OSSupportsIPv6;
				return false;
@


1.225
log
@Don't expose IPv6 network interface addresses when IPv6 isn't enabled.
@
text
@d4990 17
a5006 1
					return (string)typeofTimeZoneInfo.GetProperty("Id").GetValue(typeofTimeZoneInfo.GetProperty("Local").GetValue(null, null), null);
@


1.224
log
@Added workaround for Mono not implementing UnicastIPAddressInformation.IPv4Mask.
@
text
@d3976 3
a3978 3
					jnInetAddress[] addresses = new jnInetAddress[uipaic.Count];
					jnInterfaceAddress[] bindings = new jnInterfaceAddress[uipaic.Count];
					for (int j = 0; j < addresses.Length; j++)
d3983 2
a3984 2
							addresses[j] = new jnInet4Address(null, addr.GetAddressBytes());
							bindings[j] = new jnInterfaceAddress();
d4001 1
a4001 1
								foreach (byte b in uipaic[j].IPv4Mask.GetAddressBytes())
d4006 1
a4006 1
							else if ((addresses[j].address & ~0xffffff) == 0x7f000000)
d4011 3
a4013 1
							bindings[j]._set(addresses[j], broadcast, mask);
d4015 1
a4015 1
						else
d4028 1
a4028 2
							addresses[j] = ia6;
							bindings[j] = new jnInterfaceAddress();
d4031 3
a4033 1
							bindings[j]._set(addresses[j], null, mask);
d4036 1
a4036 1
					netif._set2(addresses, bindings, new jnNetworkInterface[0]);
@


1.223
log
@Don't return network interfaces that aren't IPv4 or IPv6 interfaces.
@
text
@d3987 11
a3997 1
							if (uipaic[j].IPv4Mask != null && !uipaic[j].IPv4Mask.Equals(System.Net.IPAddress.Any))
@


1.222
log
@Implemented Inet6AddressImpl.isReachable0().
@
text
@d3898 2
a3899 1
				System.Net.NetworkInformation.IPv4InterfaceProperties ipv4props = ni.GetIPProperties().GetIPv4Properties();
d3906 6
a3911 1
					return ni.GetIPProperties().GetIPv6Properties().Index;
d3915 5
d3929 2
@


1.221
log
@Implemented Inet6AddressImpl.getHostByAddr().
@
text
@d3822 46
a3867 1
				throw new NotImplementedException();
@


1.220
log
@Inet[4|6]AddressImpl.lookupAllHostAddr() should throw UnknownHostException instead of returning an empty array.
@
text
@d3802 16
a3817 1
				throw new NotImplementedException();
@


1.219
log
@Implemented network interface address bindings (as far as possible).
@
text
@d3653 4
d3783 4
@


1.218
log
@IPv6 addresses associated with NetworkInterface should have their scope and network interface set (when appropriate).
@
text
@d3896 1
d3903 18
d3936 4
a3941 2
					// TODO should implement bindings
					jnInterfaceAddress[] bindings = new jnInterfaceAddress[0];
@


1.217
log
@Support querying the MTU for IPv6 only interfaces.
@
text
@d3891 3
d3898 20
a3917 1
                        addresses[j] = InetAddress.ConvertIPAddress(uipaic[j].Address, null);
a3918 1
					ret[i] = new jnNetworkInterface(name, GetIndex(ifaces[i]), addresses);
d3920 2
a3921 1
					ret[i]._set(ifaces[i].Description, new jnInterfaceAddress[0], new jnNetworkInterface[0]);
@


1.216
log
@Use the platform interface indexes, instead of the order in which NetworkInterface.GetAllNetworkInterfaces() happens to return the objects and sort the interfaces by their index.
@
text
@d4057 12
a4068 2
				System.Net.NetworkInformation.IPv4InterfaceProperties props = GetDotNetNetworkInterfaceByIndex(ind).GetIPProperties().GetIPv4Properties();
				return props == null ? -1 : props.Mtu;
@


1.215
log
@Sort the IP addresses returned by Inet6Address.lookupAllHostAddr() based on the preferIPv6Address system property.
@
text
@d3821 20
d3850 1
d3897 1
a3897 1
					ret[i] = new jnNetworkInterface(name, i, addresses);
d3910 17
d3932 1
a3932 2
				jnNetworkInterface[] ifaces = GetInterfaces().javaInterfaces;
				if (index < 0 || index >= ifaces.Length)
d3934 4
a3937 1
					return null;
d3939 1
a3939 1
				return ifaces[index];
d4005 1
a4005 1
				return GetInterfaces().dotnetInterfaces[ind].OperationalStatus == System.Net.NetworkInformation.OperationalStatus.Up;
d4014 1
a4014 1
				return GetInterfaces().dotnetInterfaces[ind].NetworkInterfaceType == System.Net.NetworkInformation.NetworkInterfaceType.Loopback;
d4023 1
a4023 1
				return GetInterfaces().dotnetInterfaces[ind].SupportsMulticast;
d4032 1
a4032 1
				switch (GetInterfaces().dotnetInterfaces[ind].NetworkInterfaceType)
d4048 1
a4048 1
				return GetInterfaces().dotnetInterfaces[ind].GetPhysicalAddress().GetAddressBytes();
d4057 1
a4057 1
				System.Net.NetworkInformation.IPv4InterfaceProperties props = GetInterfaces().dotnetInterfaces[ind].GetIPProperties().GetIPv4Properties();
@


1.214
log
@When class GC is enabled, we shouldn't keep a strong reference to Class instances.
@
text
@d3764 1
d3767 11
a3777 1
						addresses[i] = InetAddress.ConvertIPAddress(addr[i], hostname);
@


1.213
log
@JRuby subclasses java.io.File to use the / path separator on Windows and that causes the (Sun) path normalization code to call us with a "C:/\" path which we previously failed to canonicalize correctly.
@
text
@d1698 15
@


1.212
log
@Instead of System.ArgumentException, throw java.net.UnknownHostException in Inet4AddressImpl.getHostByAddr().
@
text
@d1043 3
a1045 1
						return path.Length > 1 && path[1] == ':' ? path.ToUpper() : path;
@


1.211
log
@Field reflection slow path should throw NullPointerException instead of IllegalArgumentException for instance fields if the instance object is null.
@
text
@d3658 4
@


1.210
log
@Fix for bug #3033769.
@
text
@d6476 6
d6519 6
@


1.209
log
@Added "first-pass" build of IKVM.AWT.WinForms.dll and moved "native" AWT code from IKVM.Runtime.dll to IKVM.AWT.WinForms.dll.
@
text
@d7250 1
d7272 4
@


1.209.2.1
log
@New rc version.
- Fix for bug #3033769.
- Improved handling of protected/public member access that requires InternalsVisibleTo in multiple target mode.
@
text
@a7249 1
						fw.FieldTypeWrapper.EmitCheckcast(null, ilgen);
a7270 4
					if (fieldType == typeof(object))
					{
						fw.FieldTypeWrapper.EmitCheckcast(null, ilgen);
					}
@


1.209.2.2
log
@Field reflection slow path should throw NullPointerException instead of IllegalArgumentException for instance fields if the instance object is null.
@
text
@a6475 6
						else if (obj == null)
						{
#if !FIRST_PASS
							throw new global::java.lang.NullPointerException();
#endif
						}
a6512 6
						else if (obj == null)
						{
#if !FIRST_PASS
							throw new global::java.lang.NullPointerException();
#endif
						}
@


1.209.2.3
log
@Instead of System.ArgumentException, throw java.net.UnknownHostException in Inet4AddressImpl.getHostByAddr().
@
text
@a3657 4
				catch (System.ArgumentException x)
				{
					throw new jnUnknownHostException(x.Message);
				}
@


1.209.2.4
log
@JRuby subclasses java.io.File to use the / path separator on Windows and that causes the (Sun) path normalization code to call us with a "C:/\" path which we previously failed to canonicalize correctly.
@
text
@d1043 1
a1043 3
						return path.Length > 1 && path[1] == ':'
							? (Char.ToUpper(path[0]) + ":" + System.IO.Path.DirectorySeparatorChar)
							: path;
@


1.208
log
@More .NET 4.0 security model attributes.
@
text
@a5056 440
namespace IKVM.NativeCode.sun.awt
{
	static class KeyboardFocusManagerPeerImpl
	{
		public static object getNativeFocusedWindow(){return null;}
		public static object getNativeFocusOwner(){return null;}
		public static void clearNativeGlobalFocusOwner(object activeWindow){ }
	}

    static class SunToolkit
    {
        public static void closeSplashScreen() { }
    }
}

namespace IKVM.NativeCode.sun.awt.shell
{
    /// <summary>
    /// This class should use only on Windows that we can access shell32.dll
    /// </summary>
    static class Win32ShellFolder2
    {
        private const uint SHGFI_LARGEICON = 0x0;
        private const uint SHGFI_SMALLICON = 0x1;
        private const uint SHGFI_ICON = 0x100;
        private const uint SHGFI_TYPENAME = 0x400;
        private const uint SHGFI_ATTRIBUTES = 0x800;
        private struct SHFILEINFO
        {
            public IntPtr hIcon;
            public IntPtr iIcon;
            public uint dwAttributes;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
            public string szDisplayName;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 80)]
            public string szTypeName;
        };

        [DllImport("msvcrt.dll", SetLastError = false)]
        static extern IntPtr memcpy(IntPtr dest, IntPtr src, int count);

        [DllImport("gdi32.dll")]
        static extern int GetDIBits(IntPtr hdc, IntPtr hbmp, uint uStartScan,
           uint cScanLines, int[] lpvBits, ref BITMAPINFO lpbmi, uint uUsage);

        [DllImport("gdi32.dll")]
        public static extern int BitBlt(IntPtr hdcDst, int xDst, int yDst, int w, int h, IntPtr hdcSrc, int xSrc, int ySrc, int rop);

        [DllImport("user32.dll")]
        public static extern IntPtr GetDC(IntPtr hwnd);

        [DllImport("gdi32.dll")]
        static extern int GetObject(IntPtr hgdiobj, int cbBuffer, ref BITMAPINFO lpvObject);

        [DllImport("gdi32.dll")]
        public static extern IntPtr CreateCompatibleDC(IntPtr hdc);

        [DllImport("user32.dll")]
        public static extern int ReleaseDC(IntPtr hwnd, IntPtr hdc);

        [DllImport("gdi32.dll")]
        static extern IntPtr CreateCompatibleBitmap(IntPtr hdc, int nWidth, int nHeight);

        [DllImport("gdi32.dll")]
        public static extern int DeleteDC(IntPtr hdc);

        [StructLayout(LayoutKind.Sequential)]
        struct ICONINFO
        {
            public bool fIcon;         // Specifies whether this structure defines an icon or a cursor. A value of TRUE specifies 
            // an icon; FALSE specifies a cursor. 
            public Int32 xHotspot;     // Specifies the x-coordinate of a cursor's hot spot. If this structure defines an icon, the hot 
            // spot is always in the center of the icon, and this member is ignored.
            public Int32 yHotspot;     // Specifies the y-coordinate of the cursor's hot spot. If this structure defines an icon, the hot 
            // spot is always in the center of the icon, and this member is ignored. 
            public IntPtr hbmMask;     // (HBITMAP) Specifies the icon bitmask bitmap. If this structure defines a black and white icon, 
            // this bitmask is formatted so that the upper half is the icon AND bitmask and the lower half is 
            // the icon XOR bitmask. Under this condition, the height should be an even multiple of two. If 
            // this structure defines a color icon, this mask only defines the AND bitmask of the icon. 
            public IntPtr hbmColor;    // (HBITMAP) Handle to the icon color bitmap. This member can be optional if this 
            // structure defines a black and white icon. The AND bitmask of hbmMask is applied with the SRCAND 
            // flag to the destination; subsequently, the color bitmap is applied (using XOR) to the 
            // destination by using the SRCINVERT flag. 
        }

        [DllImport("user32.dll")]
        static extern bool GetIconInfo(IntPtr hIcon, out ICONINFO piconinfo);
        
        [StructLayout(LayoutKind.Sequential)]
        public struct BITMAPINFO
        {
            public uint biSize;
            public int biWidth, biHeight;
            public short biPlanes, biBitCount;
            public uint biCompression, biSizeImage;
            public int biXPelsPerMeter, biYPelsPerMeter;
            public uint biClrUsed, biClrImportant;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
            public uint[] cols;
        }

        [DllImport("shell32.dll")]
        private static extern int FindExecutable(string lpFile, string lpDirectory, StringBuilder lpResult);

        [DllImport("shell32.dll")]
        private static extern IntPtr SHGetFileInfo(string pszPath, uint dwFileAttributes, ref SHFILEINFO psfi, uint cbSizeFileInfo, uint uFlags);

        [DllImport("user32.dll", EntryPoint = "LoadImage")]
        private static extern IntPtr LoadImageID(IntPtr hInstance, int uID, uint type, int width, int height, int load);

        [DllImport("user32.dll", EntryPoint = "LoadImage")]
        private static extern IntPtr LoadImageName(IntPtr hInstance, string lpszName, uint type, int width, int height, int load);

        [DllImport("kernel32.dll")]
        static extern IntPtr LoadLibrary(string Library);

        [DllImport("gdi32.dll", EntryPoint = "DeleteObject")]
        public static extern bool DeleteObject(IntPtr hDc);

        private const uint IMAGE_BITMAP = 0;
        private const uint IMAGE_ICON = 1;

        /// <summary>
        /// Get the program to execute or open the file. If it is a exe then it is self
        /// </summary>
        /// <param name="path">path to the file</param>
        /// <returns></returns>
        public static string getExecutableType(string path)
        {
            StringBuilder objResultBuffer = new StringBuilder(1024);
            int result = FindExecutable(path, path, objResultBuffer);
            if (result >= 32)
            {
                return objResultBuffer.ToString();
            }
            return null;
        }

        /// <summary>
        /// Get the type of a file or folder. On a file it depends on its extension.
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        public static string getFolderType(string path)
        {
            SHFILEINFO shinfo = new SHFILEINFO();
            if (0 == SHGetFileInfo(path, 0, ref shinfo, (uint)Marshal.SizeOf(shinfo), SHGFI_TYPENAME).ToInt32())
            {
                return null;
            }
            return shinfo.szTypeName;
        }

        public static IntPtr getIcon(string path, bool getLargeIcon)
        {
            SHFILEINFO shinfo = new SHFILEINFO();
            if (0 == SHGetFileInfo(path, 0, ref shinfo, (uint)Marshal.SizeOf(shinfo), SHGFI_ICON | (getLargeIcon ? 0 : SHGFI_SMALLICON)).ToInt32())
            {
                return IntPtr.Zero;
            }
            return shinfo.hIcon;
        }

        public static int[] getIconBits(IntPtr hIcon, int iconSize)
        {
            ICONINFO iconInfo;
            if (GetIconInfo(hIcon, out iconInfo))
            {
                IntPtr hWnd = new IntPtr(0);
                IntPtr dc = GetDC(hWnd);
                BITMAPINFO bmi = new BITMAPINFO();
                bmi.biSize = 40;
                bmi.biWidth = iconSize;
                bmi.biHeight = -iconSize;
                bmi.biPlanes = 1;
                bmi.biBitCount = 32;
                bmi.biCompression = 0;
                int intArrSize = iconSize * iconSize;
                int[] iconBits = new int[intArrSize];
                GetDIBits(dc, iconInfo.hbmColor, 0, (uint)iconSize, iconBits, ref bmi, 0);
                bool hasAlpha = false;
                bool isXP = (Environment.OSVersion.Version.Major >= 6) || (Environment.OSVersion.Version.Major == 5 && Environment.OSVersion.Version.Minor>=1);
                if (isXP) {
                    for (int i = 0; i < iconBits.Length; i++)
                    {
                        if ((iconBits[i] & 0xFF000000) != 0)
                        {
                            hasAlpha = true;
                            break;
                        }
                    }
                }
                if (!hasAlpha)
                {
                    int[] maskBits = new int[intArrSize];
                    GetDIBits(dc, iconInfo.hbmMask, 0, (uint)iconSize, maskBits, ref bmi, 0);
                    for (int i = 0; i < iconBits.Length; i++)
                    {
                        if (maskBits[i] == 0) {
                            iconBits[i] = (int)((uint)iconBits[i] | 0xFF000000);
                        }
                    }
                }
                DeleteObject(iconInfo.hbmColor);
                DeleteObject(iconInfo.hbmMask);
                return iconBits;
            }
            return null;
        }

        public static int getAttribute(string path)
        {
            SHFILEINFO shinfo = new SHFILEINFO();
            if (0 == SHGetFileInfo(path, 0, ref shinfo, (uint)Marshal.SizeOf(shinfo), SHGFI_ATTRIBUTES).ToInt32())
            {
                return 0;
            }
            return (int)shinfo.dwAttributes;
        }

        [System.Security.SecuritySafeCritical]
        public static string getLinkLocation(string path)
        {
            using (ShellLink link = new ShellLink())
            {
                link.Load(path);
                return link.GetPath();
            }
        }

        public static int[] getFileChooserBitmapHandle()
        {
            // Code copied from ShellFolder2.cpp Java_sun_awt_shell_Win32ShellFolder2_getFileChooserBitmapBits
            IntPtr libShell32 = LoadLibrary("shell32.dll");
            // Get a handle to an icon.
            bool isVista = Environment.OSVersion.Version.Major >= 6;
            IntPtr hBitmap = isVista ? 
                LoadImageName(libShell32, "IDB_TB_SH_DEF_16", IMAGE_BITMAP, 0, 0, 0) :
                LoadImageID(libShell32, 216, IMAGE_BITMAP, 0, 0, 0);
            if (hBitmap.ToInt32() == 0)
            {
                IntPtr libComCtl32 = LoadLibrary("comctl32.dll");
                hBitmap = LoadImageID(libComCtl32, 124, IMAGE_BITMAP, 0, 0, 0);
            }
            if (hBitmap.ToInt32() == 0)
            {
                return new int[768*16];
            }
            BITMAPINFO bmi = new BITMAPINFO();
            GetObject(hBitmap, Marshal.SizeOf(bmi), ref bmi);
            int width = bmi.biWidth;
            int height = bmi.biHeight;
            bmi.biSize = 40;
            bmi.biHeight = -bmi.biHeight;
            bmi.biPlanes = 1;
            bmi.biBitCount = 32;
            bmi.biCompression = 0;
            IntPtr hwnd = new IntPtr(0);
            IntPtr dc = GetDC(hwnd);
            int[] data = new int[width*height];
            GetDIBits(dc, hBitmap, (uint)0, (uint)height, data, ref bmi, 0);
            DeleteObject(hBitmap);
            ReleaseDC(hwnd, dc);
            return data;
        }

        public static IntPtr getIconResource(String libName, int iconID, int cxDesired, int cyDesired)
        {
            IntPtr hLibName = LoadLibrary(libName);
            return LoadImageID(hLibName, iconID, IMAGE_ICON, cxDesired, cyDesired, 0);
        }
    }

    [System.Security.SecurityCritical]
    class ShellLink : IDisposable
    {
        [ComImport]
        [Guid("0000010B-0000-0000-C000-000000000046")]
        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IPersistFile
        {
            [PreserveSig]
            void GetClassID(out Guid pClassID);
            [PreserveSig]
            void IsDirty();
            [PreserveSig]
            void Load([MarshalAs(UnmanagedType.LPWStr)] string pszFileName, uint dwMode);
            [PreserveSig]
            void Save([MarshalAs(UnmanagedType.LPWStr)] string pszFileName, [MarshalAs(UnmanagedType.Bool)] bool fRemember);
            [PreserveSig]
            void SaveCompleted([MarshalAs(UnmanagedType.LPWStr)] string pszFileName);
            [PreserveSig]
            void GetCurFile([MarshalAs(UnmanagedType.LPWStr)] out string ppszFileName);
        }

        [ComImport]
        [Guid("000214F9-0000-0000-C000-000000000046")]
        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        private interface IShellLinkW
        {
            void GetPath([Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszFile, int cchMaxPath, IntPtr pfd, uint fFlags);
            void GetIDList(out IntPtr ppidl);
            void SetIDList(IntPtr pidl);
            void GetDescription([Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszFile, int cchMaxName);
            void SetDescription([MarshalAs(UnmanagedType.LPWStr)] string pszName);
            void GetWorkingDirectory([Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszDir, int cchMaxPath);
            void SetWorkingDirectory([MarshalAs(UnmanagedType.LPWStr)] string pszDir);
            void GetArguments([Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszArgs, int cchMaxPath);
            void SetArguments([MarshalAs(UnmanagedType.LPWStr)] string pszArgs);
            void GetHotkey(out short pwHotkey);
            void SetHotkey(short pwHotkey);
            void GetShowCmd(out uint piShowCmd);
            void SetShowCmd(uint piShowCmd);
            void GetIconLocation([Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszIconPath, int cchIconPath, out int piIcon);
            void SetIconLocation([MarshalAs(UnmanagedType.LPWStr)] string pszIconPath, int iIcon);
            void SetRelativePath([MarshalAs(UnmanagedType.LPWStr)] string pszPathRel, uint dwReserved);
            void Resolve(IntPtr hWnd, uint fFlags);
            void SetPath([MarshalAs(UnmanagedType.LPWStr)] string pszFile);
        }

        [Guid("00021401-0000-0000-C000-000000000046")]
        [ClassInterfaceAttribute(ClassInterfaceType.None)]
        [ComImport]
        private class CShellLink { }

        [Flags]
        public enum EShowWindowFlags : uint
        {
            SW_HIDE = 0,
            SW_SHOWNORMAL = 1,
            SW_NORMAL = 1,
            SW_SHOWMINIMIZED = 2,
            SW_SHOWMAXIMIZED = 3,
            SW_MAXIMIZE = 3,
            SW_SHOWNOACTIVATE = 4,
            SW_SHOW = 5,
            SW_MINIMIZE = 6,
            SW_SHOWMINNOACTIVE = 7,
            SW_SHOWNA = 8,
            SW_RESTORE = 9,
            SW_SHOWDEFAULT = 10,
            SW_MAX = 10
        }

        private IShellLinkW linkW = (IShellLinkW)new CShellLink();

        [System.Security.SecuritySafeCritical]
        public void Dispose()
        {
            if (linkW != null)
            {
                Marshal.ReleaseComObject(linkW);
                linkW = null;
            }
        }

        public void SetPath(string path)
        {
            linkW.SetPath(path);
        }

        public void SetDescription(string description)
        {
            linkW.SetDescription(description);
        }

        public void SetWorkingDirectory(string dir)
        {
            linkW.SetWorkingDirectory(dir);
        }

        public void SetArguments(string args)
        {
            linkW.SetArguments(args);
        }

        public void SetShowCmd(EShowWindowFlags cmd)
        {
            linkW.SetShowCmd((uint)cmd);
        }

        public void Save(string linkFile)
        {
            ((IPersistFile)linkW).Save(linkFile, true);
        }

        public void Load(string linkFile)
        {
            ((IPersistFile)linkW).Load(linkFile, 0);
        }

        public string GetArguments()
        {
            StringBuilder sb = new StringBuilder(512);
            linkW.GetArguments(sb, sb.Capacity);
            return sb.ToString();
        }

        public string GetPath()
        {
            StringBuilder sb = new StringBuilder(512);
            linkW.GetPath(sb, sb.Capacity, IntPtr.Zero, 0);
            return sb.ToString();
        }
    }
}

namespace IKVM.NativeCode.sun.java2d
{
	static class DefaultDisposerRecord
	{
		public static void invokeNativeDispose(long disposerMethodPointer, long dataPointer)
		{
			throw new NotImplementedException();
		}
	}

	static class Disposer
	{
		public static void initIDs()
		{
		}
	}
}

namespace IKVM.NativeCode.sun.java2d.pipe
{
	static class Region
	{
		public static void initIDs(){ }
	}
	
	static class RenderBuffer
	{
		public static void copyFromArray(object srcArray, long srcPos, long dstAddr, long length){ 
			throw new NotImplementedException(); 
		}
	}
}

@


1.207
log
@.NET 4.0 security model fix.
@
text
@d280 1
d439 1
d463 1
d2987 1
d3001 1
d4282 1
d4299 1
d5277 1
d5403 1
d5648 1
@


1.206
log
@In partial trust, constructing the serialization constructor accessor can fail with a SecurityException. We convert that into a java.lang.SecurityException because the Java code handles that.
@
text
@d5848 6
a5856 1
		private sealed class State { internal int Value; }
@


1.205
log
@Use a LinkedHashMap to preserve annotation order (but only in dynamic mode, because for compiled code we get the .NET attributes in unspecified order). By my reading of the API spec there is no guarantee about the ordering, but the Google Guice test suite depends on it anyway.
@
text
@d7820 8
a7827 1
			return new FastSerializationConstructorAccessorImpl(constructorToCall, classToInstantiate);
@


1.204
log
@Removed exception mapping methods from Throwable and consolidated into a single method (actually, two methods, but the dynamic one should not be necessary and should be removed later).
@
text
@d2640 1
a2640 1
				global::java.util.HashMap map = new global::java.util.HashMap();
@


1.203
log
@Moved ExceptionHelper into proper namespace and some cleanup.
@
text
@d6246 2
a6247 2
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Call, Compiler.mapExceptionFastMethod);
d6552 2
a6553 2
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Call, Compiler.mapExceptionFastMethod);
@


1.202
log
@Moved the last part of ExceptionHelper from Java to C# side.
@
text
@d3452 1
a3452 1
				global::IKVM.NativeCode.java.lang.ExceptionHelper.ExceptionInfoHelper.Append(stackTrace, stack, 0);
@


1.201
log
@Moved ExceptionHelper.getStackTrace() to "native" code of Thread.
@
text
@d3451 3
a3453 5
				global::System.Collections.ArrayList stackTrace = new global::System.Collections.ArrayList();
				global::java.lang.ExceptionHelper.ExceptionInfoHelper.Append(stackTrace, stack, 0);
				jlStackTraceElement[] ste = new jlStackTraceElement[stackTrace.Count];
				stackTrace.CopyTo(0, ste, 0, ste.Length);
				return ste;
@


1.200
log
@More object -> java.lang.Class updates.
@
text
@d49 1
a65 1
using jlStackTraceElement = java.lang.StackTraceElement;
d3445 13
@


1.199
log
@More type safety. TypeWrapper.ClassObject is now typed as java.lang.Class.
@
text
@d1784 1
a1784 1
			public static object newArray(object componentType, int length)
d1789 1
a1789 1
			public static object multiNewArray(object componentType, int[] dimensions)
d2252 1
a2252 1
				public static object newArray(object componentType, int length)
d2289 1
a2289 1
				public static object multiNewArray(object componentType, int[] dimensions)
d2858 1
a2858 1
			public static bool desiredAssertionStatus0(object clazz)
d3198 1
a3198 1
				object currentClass = currentLoadedClass0(thisSecurityManager);
d3216 1
a3216 1
			public static object currentLoadedClass0(object thisSecurityManager)
d5733 1
a5733 1
		public static void ensureClassInitialized(object thisUnsafe, object clazz)
d5751 1
a5751 1
		public static object allocateInstance(object thisUnsafe, object clazz)
d5947 1
a5947 1
		public static int getClassAccessFlags(object clazz)
d5952 1
a5952 1
		public static bool checkInternalAccess(object currentClass, object memberClass)
@


1.198
log
@First stab at making the "native" method signatures more statically typed.
@
text
@d2379 1
a2379 1
				return (jlClass)tw.ClassObject;
d2484 1
a2484 1
					interfaces[i] = (jlClass)ifaces[i].ClassObject;
d2577 1
a2577 1
				ProtectionDomain pd = ((jlClass)wrapper.ClassObject).pd;
d2847 1
a2847 1
						innerclasses[i] = (jlClass)wrappers[i].ClassObject;
d3190 1
a3190 1
					stack.Add((jlClass)ClassLoaderWrapper.GetWrapperFromType(type).ClassObject);
d4399 1
a4399 1
					return java.lang.Class.getProtectionDomain0((jlClass)tw.ClassObject);
d6695 1
a6695 1
				return ((jlClass)fw.FieldTypeWrapper.ClassObject).getName();
@


1.197
log
@Wrap all reflective field access to convert FieldAccessException into java.lang.IllegalAccessException.
@
text
@d44 2
a45 1
#if !FIRST_PASS
d48 4
a80 1
using jlrConstructor = java.lang.reflect.Constructor;
a85 1
using ProtectionDomain = java.security.ProtectionDomain;
a91 1
using jnByteBuffer = java.nio.ByteBuffer;
a99 2
using jiFile = java.io.File;
using jiObjectStreamField = java.io.ObjectStreamField;
d712 1
a712 1
			public static bool isDynamicTypeWrapper(object cl)
d718 1
a718 1
			public static bool hasStaticInitializer(object cl)
d1111 1
a1111 1
			private static string GetPathFromFile(object file)
d1116 1
a1116 1
				return ((jiFile)file).getPath();
d1120 1
a1120 1
			public static int getBooleanAttributes(object _this, object f)
d1167 1
a1167 1
			public static bool checkAccess(object _this, object f, int access)
d1245 1
a1245 1
			public static long getLastModifiedTime(object _this, object f)
d1266 1
a1266 1
			public static long getLength(object _this, object f)
d1295 1
a1295 1
			public static bool setPermission(object _this, object f, int access, bool enable, bool owneronly)
d1363 1
a1363 1
			public static bool delete0(object _this, object f)
d1408 1
a1408 1
			public static string[] list(object _this, object f)
d1443 1
a1443 1
			public static bool createDirectory(object _this, object f)
d1475 1
a1475 1
			public static bool rename0(object _this, object f1, object f2)
d1500 1
a1500 1
			public static bool setLastModifiedTime(object _this, object f, long time)
d1525 1
a1525 1
			public static bool setReadOnly(object _this, object f)
d1575 1
a1575 1
			public static long getSpace0(object _this, object f, int t)
d1608 1
a1608 1
			public static int getBooleanAttributes0(object _this, object f)
d1613 1
a1613 1
			public static long getSpace(object _this, object f, int t)
d1629 1
a1629 1
			public static bool checkAccess(object _this, object f, int access)
d1634 1
a1634 1
			public static long getLastModifiedTime(object _this, object f)
d1639 1
a1639 1
			public static long getLength(object _this, object f)
d1644 1
a1644 1
			public static bool setPermission(object _this, object f, int access, bool enable, bool owneronly)
d1655 1
a1655 1
			public static bool delete0(object _this, object f)
d1660 1
a1660 1
			public static string[] list(object _this, object f)
d1665 1
a1665 1
			public static bool createDirectory(object _this, object f)
d1670 1
a1670 1
			public static bool rename0(object _this, object f1, object f2)
d1675 1
a1675 1
			public static bool setLastModifiedTime(object _this, object f, long time)
d1680 1
a1680 1
			public static bool setReadOnly(object _this, object f)
d2331 1
a2331 1
			public static object forName0(string name, bool initialize, object loader)
d2379 1
a2379 1
				return tw.ClassObject;
d2383 1
a2383 1
			public static bool isInstance(object thisClass, object obj)
d2388 1
a2388 1
			public static bool isAssignableFrom(object thisClass, object otherClass)
d2399 1
a2399 1
			public static bool isInterface(object thisClass)
d2404 1
a2404 1
			public static bool isArray(object thisClass)
d2409 1
a2409 1
			public static bool isPrimitive(object thisClass)
d2414 1
a2414 1
			public static string getName0(object thisClass)
d2459 1
a2459 1
			public static string getSigName(object thisClass)
d2464 1
a2464 1
			public static object getClassLoader0(object thisClass)
d2469 1
a2469 1
			public static object getSuperclass(object thisClass)
d2475 1
a2475 1
			public static object getInterfaces(object thisClass)
d2490 1
a2490 1
			public static object getComponentType(object thisClass)
d2496 1
a2496 1
			public static int getModifiers(object thisClass)
d2504 1
a2504 1
			public static object[] getSigners(object thisClass)
d2509 1
a2509 1
				return ((jlClass)thisClass).signers;
d2513 1
a2513 1
			public static void setSigners(object thisClass, object[] signers)
d2516 1
a2516 1
				((jlClass)thisClass).signers = signers;
d2520 1
a2520 1
			public static object[] getEnclosingMethod0(object thisClass)
d2539 1
a2539 1
			public static object getDeclaringClass(object thisClass)
d2567 1
a2567 1
			public static object getProtectionDomain0(object thisClass)
d2577 1
a2577 1
				object pd = ((jlClass)wrapper.ClassObject).pd;
d2585 1
a2585 1
						pd = acl.GetProtectionDomain();
d2592 1
a2592 1
			public static void setProtectionDomain0(object thisClass, object pd)
d2595 1
a2595 1
				((jlClass)thisClass).pd = (ProtectionDomain)pd;
d2628 1
a2628 1
			public static string getGenericSignature(object thisClass)
d2657 1
a2657 1
			public static object getDeclaredAnnotationsImpl(object thisClass)
d2675 1
a2675 1
			public static object getDeclaredFields0(object thisClass, bool publicOnly)
d2717 1
a2717 1
			public static object getDeclaredMethods0(object thisClass, bool publicOnly)
d2771 1
a2771 1
			public static object getDeclaredConstructors0(object thisClass, bool publicOnly)
d2824 1
a2824 1
			public static object getDeclaredClasses0(object thisClass)
d2870 1
a2870 1
			public static object defineClass0(object thisClassLoader, string name, byte[] b, int off, int len, object pd)
d2875 1
a2875 1
			public static object defineClass1(object thisClassLoader, string name, byte[] b, int off, int len, object pd, string source)
d2910 1
a2910 1
			public static object defineClass2(object thisClassLoader, string name, object b, int off, int len, object pd, string source)
a2914 1
				jnByteBuffer bb = (jnByteBuffer)b;
d2921 1
a2921 1
			public static void resolveClass0(object thisClassLoader, object clazz)
d2926 1
a2926 1
			public static object findBootstrapClass(object thisClassLoader, string name)
d2957 1
a2957 1
			public static object findLoadedClass0(object thisClassLoader, string name)
d3163 1
a3163 1
			public static object getClassContext(object thisSecurityManager)
d3474 1
a3474 1
				public static object defineClass0(object classLoader, string name, byte[] b, int off, int len)
d4399 1
a4399 1
					return java.lang.Class.getProtectionDomain0(tw.ClassObject);
d7804 1
a7804 1
		public static object newConstructorAccessorForSerialization(object classToInstantiate, object constructorToCall)
d7809 1
a7809 2
			jlrConstructor cons = (jlrConstructor)constructorToCall;
			return new FastSerializationConstructorAccessorImpl(cons, (jlClass)classToInstantiate);
@


1.196
log
@Turn MethodAccessExceptions that happen during reflective method invocation (in partial trust scenarios) into java.lang.IllegalAccessExceptions.
@
text
@d7007 8
a7014 1
					return getter(obj, this);
d7019 8
a7026 1
					setter(obj, value, this);
d7058 8
a7065 1
					return getter(obj, this);
d7070 8
a7077 1
					setter(obj, value, this);
d7128 8
a7135 1
					return getter(obj, this);
d7140 8
a7147 1
					setter(obj, value, this);
d7204 8
a7211 1
					return getter(obj, this);
d7216 8
a7223 1
					setter(obj, value, this);
d7288 8
a7295 1
					return getter(obj, this);
d7300 8
a7307 1
					setter(obj, value, this);
d7374 8
a7381 1
					return getter(obj, this);
d7386 8
a7393 1
					setter(obj, value, this);
d7459 8
a7466 1
					return getter(obj, this);
d7471 8
a7478 1
					setter(obj, value, this);
d7546 8
a7553 1
					return getter(obj, this);
d7558 8
a7565 1
					setter(obj, value, this);
d7591 8
a7598 1
					return getter(obj, this);
d7603 8
a7610 1
					setter(obj, value, this);
@


1.195
log
@Workaround x64 JIT bug.
@
text
@d6435 9
a6443 1
				return invoker(obj, args, callerID);
d6557 9
a6565 1
				return invoker(args);
d6610 9
a6618 1
				return invoker();
@


1.194
log
@Added explicit cast to generated reflection argument conversion code, to improve partial trust compatibility and to avoid an x64 JIT bug.
@
text
@a6218 4
				ilgen.Emit(OpCodes.Dup);
				ilgen.Emit(OpCodes.Callvirt, get_TargetSite);
				ilgen.Emit(OpCodes.Call, GetCurrentMethod);
				ilgen.Emit(OpCodes.Ceq);
d6220 16
a6235 1
				ilgen.Emit(OpCodes.Brtrue_S, label);
@


1.193
log
@When a fast  method/constructor invoker throws an exception at the call site (e.g. MethodAccessException in partial trust scenarios) we shouldn't wrap it in an InvocationTargetException.
@
text
@d6284 1
d6302 1
d6311 1
d6327 1
d6343 1
d6359 1
@


1.192
log
@Class.getEnclosingMethod0() and Class.getGenericSignature() should finish the TypeWrapper, otherwise the metadata isn't yet available.
In addition, getGenericSignature() should not re-mangle the sig as that is not necessary.
This fixes several Guice 2.0 test case failures as reported in bug #3004682.
@
text
@d6065 3
d6093 2
d6219 6
d6228 1
d6511 6
d6520 1
@


1.191
log
@Audited CriticalCtrlHandler and added .NET 4.0 security attributes.
@
text
@d2523 1
d2630 3
a2632 6
				string sig = TypeWrapper.FromClass(thisClass).GetGenericSignature();
				if (sig == null)
				{
					return null;
				}
				return sig.Replace('.', '/');
@


1.190
log
@Prep for .NET 4.0 security model:
- unverifiable dynamic methods need to be emitted in a critical assembly
@
text
@a5540 3
        [DllImport("kernel32.dll")]
        private static extern bool SetConsoleCtrlHandler(ConsoleCtrlDelegate e, bool add);

d5545 4
d5553 1
a5553 1
                SetConsoleCtrlHandler(consoleCtrlDelegate, true);
d5556 1
d5559 4
a5562 1
                SetConsoleCtrlHandler(consoleCtrlDelegate, false);
@


1.189
log
@Prep for .NET 4.0 security model:
- added more SecurityCritical attributes
- added SecuritySafeCritical/TreatAsSafe attributes to Direct-X-Buffer classes
@
text
@d2 1
a2 1
  Copyright (C) 2007, 2008, 2009 Jeroen Frijters
d276 4
d284 9
d302 1
@


1.188
log
@Moved Posix file flushing to C# to be able to use delegate instead of reflection to invoke the Mono.Posix method. Also added DangerousAddRef/Release to prevent the handle from being closed while flushing.
@
text
@d3968 1
d5300 1
d5530 1
d5734 1
@


1.187
log
@Partrial trust improvements:
- File.listRoots() now uses Environment.GetLogicalDrives() instead of Directory.GetLogicalDrives(). Both methods are semantically identical, but the former requires EnvironmentPermission(Unrestricted = true) and the latter SecurityPermission(UnmanagedCode = true). We also now swallow a SecurityException, should it occur.
- Getting the host name now falls back to "localhost" if we don't have permission to query the name (or if anything else causes GetHostName to fail).
@
text
@d410 2
d423 42
@


1.186
log
@When running on .NET 3.5 or later, use TimeZoneInfo.Id to identify timezone, because that maps better to the Win32 names that the Java name mapping is based on.
@
text
@d1498 1
a1498 1
					foreach (string drive in System.IO.Directory.GetLogicalDrives())
d1511 3
d3538 4
a3541 1
				catch (System.Net.Sockets.SocketException x)
a3542 1
					throw new jnUnknownHostException(x.Message);
d3544 1
@


1.185
log
@If the current timezone is not one of the recognized names, we should return GMT+offset instead of null, because null maps to GMT.
@
text
@d4682 19
a4702 1
				// HACK this is very lame and probably won't work on localized windows versions
d4704 1
a4704 1
				switch (SystemTimeZone.CurrentTimeZone.StandardName)
@


1.184
log
@Replaced incorrect usages of Type.IsArray with ReflectUtil.IsVector().
@
text
@d4937 1
a4937 1
						return null;
@


1.183
log
@Ignore SecurityException when trying to register Ctrl-Break handler.
@
text
@d1958 1
a1958 1
					if (type.IsArray && ClassLoaderWrapper.GetWrapperFromType(type.GetElementType()).IsPrimitive)
@


1.182
log
@- Moved thread dump code from Thread.java to openjdk.cs.
- Changed thread dump code to write to System.Console.Out, instead of java.lang.System.out.
- Changed formatting slightly and added some info to make it more like the JDK output.
@
text
@d5476 1
a5476 1
        private static CriticalCtrlHandler defaultConsoleCtrlDelegate;
d5540 6
d5556 7
a5562 1
                        defaultConsoleCtrlDelegate = new CriticalCtrlHandler();
@


1.181
log
@use CriticalFinalizerObject for the case of AppDomain unloading
@
text
@d5484 1
a5484 1
                    global::java.lang.Thread.dumpAllStacks();
d5492 23
@


1.180
log
@implements the signal handler for windows
@
text
@d5460 17
a5476 1
        private static ConsoleCtrlDelegate defaultConsoleCtrlDelegate;
d5527 1
a5527 2
                        defaultConsoleCtrlDelegate = new ConsoleCtrlDelegate(ConsoleCtrlCheck);
                        SetConsoleCtrlHandler(defaultConsoleCtrlDelegate, true);
@


1.179
log
@Removed support for "ikvm.stubgen.serialver" property that is no longer needed now that ikvmstub doesn't use the runtime to generate stubs.
@
text
@d5431 44
a5474 6
	static class Signal
	{
		public static int findSignal(string sigName)
		{
			return 0;
		}
d5476 52
a5527 4
		public static long handle0(int sig, long nativeH)
		{
			return 0;
		}
d5529 14
a5542 5
		public static void raise0(int sig)
		{
			throw new NotImplementedException();
		}
	}
@


1.178
log
@Don't use EmitThrow() it needs to lookup the method every time.
@
text
@a649 2
			private static bool runClassInit;

a651 4
#if !FIRST_PASS
				// HACK if we're being run from ikvmstub, don't run the static initializer
				runClassInit = !"true".Equals(ClassLoaderWrapper.DoPrivileged(new global::sun.security.action.GetPropertyAction("ikvm.stubgen.serialver")));
#endif
d674 1
a674 4
					if (runClassInit)
					{
						wrapper.RunClassInit();
					}
@


1.177
log
@Removed unnecessary usage of Java types in field reflection guts.
@
text
@d5839 1
d5864 1
d5919 2
a5920 1
				ilgen.EmitThrow("java.lang.IllegalArgumentException");
d5953 2
a5954 1
				ilgen.EmitThrow("java.lang.IllegalArgumentException");
d5956 2
a5957 1
				ilgen.EmitThrow("java.lang.IllegalArgumentException");
d6236 2
a6237 1
				ilgen.EmitThrow("java.lang.IllegalArgumentException");
d6258 2
a6259 1
				ilgen.EmitThrow("java.lang.IllegalArgumentException");
d6261 2
a6262 1
				ilgen.EmitThrow("java.lang.IllegalArgumentException");
@


1.176
log
@deleting of an not existing Preferences Key should not throw an exception. see JUnit test
@
text
@d6390 1
a6390 1
			private FieldAccessorImplBase(jlrField field, bool overrideAccessCheck)
d6392 1
a6392 1
				fw = FieldWrapper.FromField(field);
d6553 2
a6554 2
				internal FieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
d6668 1
a6668 1
				internal ByteField(jlrField field, bool overrideAccessCheck)
d6730 1
a6730 1
				internal BooleanField(jlrField field, bool overrideAccessCheck)
d6767 1
a6767 1
				internal CharField(jlrField field, bool overrideAccessCheck)
d6823 1
a6823 1
				internal ShortField(jlrField field, bool overrideAccessCheck)
d6885 1
a6885 1
				internal IntField(jlrField field, bool overrideAccessCheck)
d6955 1
a6955 1
				internal FloatField(jlrField field, bool overrideAccessCheck)
d7027 1
a7027 1
				internal LongField(jlrField field, bool overrideAccessCheck)
d7098 1
a7098 1
				internal DoubleField(jlrField field, bool overrideAccessCheck)
d7171 1
a7171 1
				internal ObjectField(jlrField field, bool overrideAccessCheck)
d7280 1
a7280 1
			internal static FieldAccessorImplBase Create(jlrField field, bool overrideAccessCheck)
d7282 2
a7283 2
				jlClass type = field.getType();
				if (type.isPrimitive())
d7285 1
a7285 1
					if (type == jlByte.TYPE)
d7289 1
a7289 1
					if (type == jlBoolean.TYPE)
d7293 1
a7293 1
					if (type == jlCharacter.TYPE)
d7297 1
a7297 1
					if (type == jlShort.TYPE)
d7301 1
a7301 1
					if (type == jlInteger.TYPE)
d7305 1
a7305 1
					if (type == jlFloat.TYPE)
d7309 1
a7309 1
					if (type == jlLong.TYPE)
d7313 1
a7313 1
					if (type == jlDouble.TYPE)
d7332 1
a7332 1
			return FieldAccessorImplBase.Create((jlrField)field, overrideAccessCheck);
d7336 7
@


1.175
log
@Wrapped a couple of forgotten TypeWrapper.Finish() calls to convert exceptions to their Java form.
@
text
@d4575 20
a4594 16
				public static int WindowsRegDeleteValue(int hKey, byte[] valueName)
				{
					try
					{
						MapKey(hKey).DeleteValue(BytesToString(valueName));
						return 0;
					}
					catch (System.Security.SecurityException)
					{
						return 5;
					}
					catch (UnauthorizedAccessException)
					{
						return 5;
					}
				}
@


1.174
log
@Fix for #2887316.
@
text
@d753 8
a760 1
						tw.Finish();
d790 8
a797 1
							fieldType.Finish();
d2317 8
a2324 1
					tw.Finish();
d2613 8
a2620 1
				wrapper.Finish();
d5511 8
a5518 1
				tw.Finish();
@


1.173
log
@Optimized field reflection. We now delay creating the dynamic methods to access the field until after the field has been accessed a couple of times, this saves a lot of memory for fields that are only usused a couple of times.
@
text
@d2470 1
@


1.172
log
@Removed unnecessary class.
@
text
@d6332 1
d6335 14
d6503 124
a6626 2
			
			private class ByteField : FieldAccessorImplBase
d6671 15
d6688 1
a6688 1
			private class BooleanField : FieldAccessorImplBase
d6708 15
d6725 1
a6725 1
			private class CharField : FieldAccessorImplBase
d6764 15
d6781 1
a6781 1
			private class ShortField : FieldAccessorImplBase
d6826 15
d6843 1
a6843 1
			private class IntField : FieldAccessorImplBase
d6896 15
d6913 1
a6913 1
			private class FloatField : FieldAccessorImplBase
d6968 15
d6985 1
a6985 1
			private class LongField : FieldAccessorImplBase
d7039 15
d7056 1
a7056 1
			private class DoubleField : FieldAccessorImplBase
d7063 1
a7063 1
				public override object get(object obj)
d7068 1
a7068 1
				public override void set(object obj, object val)
d7083 1
a7083 1
				public override void setByte(object obj, byte b)
d7088 1
a7088 1
				public override void setChar(object obj, char c)
d7093 1
a7093 1
				public override void setShort(object obj, short s)
d7098 1
a7098 1
				public override void setInt(object obj, int i)
d7103 1
a7103 1
				public override void setLong(object obj, long l)
d7108 1
a7108 1
				public override void setFloat(object obj, float f)
d7112 46
d7165 1
a7165 1
				DynamicMethod dm = DynamicMethodUtils.Create("__<Getter>", fw.DeclaringType.TypeAsBaseType, !fw.IsPublic || !fw.DeclaringType.IsPublic, fieldType, new Type[] { typeof(IReflectionException), typeof(object) });
d7198 1
a7198 1
				DynamicMethod dm = DynamicMethodUtils.Create("__<Setter>", fw.DeclaringType.TypeAsBaseType, !fw.IsPublic || !fw.DeclaringType.IsPublic, null, new Type[] { typeof(IReflectionException), typeof(object), fieldType });
a7239 405
			private sealed class FastByteFieldAccessor : ByteField
			{
				private delegate void Setter(object obj, byte value);
				private delegate byte Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastByteFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private byte lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(byte), fw);
					return getter(obj);
				}

				private void lazySet(object obj, byte value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw FinalFieldIllegalAccessException(jlByte.valueOf(value));
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(byte), fw);
					setter(obj, value);
				}

				public override byte getByte(object obj)
				{
					return getter(obj);
				}

				public override void setByte(object obj, byte value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastBooleanFieldAccessor : BooleanField
			{
				private delegate void Setter(object obj, bool value);
				private delegate bool Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastBooleanFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private bool lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(bool), fw);
					return getter(obj);
				}

				private void lazySet(object obj, bool value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw FinalFieldIllegalAccessException(jlBoolean.valueOf(value));
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(bool), fw);
					setter(obj, value);
				}

				public override bool getBoolean(object obj)
				{
					return getter(obj);
				}

				public override void setBoolean(object obj, bool value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastCharFieldAccessor : CharField
			{
				private delegate void Setter(object obj, char value);
				private delegate char Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastCharFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private char lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(char), fw);
					return getter(obj);
				}

				private void lazySet(object obj, char value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw FinalFieldIllegalAccessException(jlCharacter.valueOf(value));
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(char), fw);
					setter(obj, value);
				}

				public override char getChar(object obj)
				{
					return getter(obj);
				}

				public override void setChar(object obj, char value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastShortFieldAccessor : ShortField
			{
				private delegate void Setter(object obj, short value);
				private delegate short Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastShortFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private short lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(short), fw);
					return getter(obj);
				}

				private void lazySet(object obj, short value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw FinalFieldIllegalAccessException(jlShort.valueOf(value));
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(short), fw);
					setter(obj, value);
				}

				public override short getShort(object obj)
				{
					return getter(obj);
				}

				public override void setShort(object obj, short value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastIntegerFieldAccessor : IntField
			{
				private delegate void Setter(object obj, int value);
				private delegate int Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastIntegerFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private int lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(int), fw);
					return getter(obj);
				}

				private void lazySet(object obj, int value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw FinalFieldIllegalAccessException(jlInteger.valueOf(value));
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(int), fw);
					setter(obj, value);
				}

				public override int getInt(object obj)
				{
					return getter(obj);
				}

				public override void setInt(object obj, int value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastFloatFieldAccessor : FloatField
			{
				private delegate void Setter(object obj, float value);
				private delegate float Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastFloatFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private float lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(float), fw);
					return getter(obj);
				}

				private void lazySet(object obj, float value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw FinalFieldIllegalAccessException(jlFloat.valueOf(value));
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(float), fw);
					setter(obj, value);
				}

				public override float getFloat(object obj)
				{
					return getter(obj);
				}

				public override void setFloat(object obj, float value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastLongFieldAccessor : LongField
			{
				private delegate void Setter(object obj, long value);
				private delegate long Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastLongFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private long lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(long), fw);
					return getter(obj);
				}

				private void lazySet(object obj, long value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw FinalFieldIllegalAccessException(jlLong.valueOf(value));
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(long), fw);
					setter(obj, value);
				}

				public override long getLong(object obj)
				{
					return getter(obj);
				}

				public override void setLong(object obj, long value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastDoubleFieldAccessor : DoubleField
			{
				private delegate void Setter(object obj, double value);
				private delegate double Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastDoubleFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private double lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(double), fw);
					return getter(obj);
				}

				private void lazySet(object obj, double value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw FinalFieldIllegalAccessException(jlDouble.valueOf(value));
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(double), fw);
					setter(obj, value);
				}

				public override double getDouble(object obj)
				{
					return getter(obj);
				}

				public override void setDouble(object obj, double value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastObjectFieldAccessor : FieldAccessorImplBase
			{
				private delegate void Setter(object obj, object value);
				private delegate object Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastObjectFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private object lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(object), fw);
					return getter(obj);
				}

				private void lazySet(object obj, object value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw FinalFieldIllegalAccessException(value);
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(object), fw);
					setter(obj, value);
				}

				public override object get(object obj)
				{
					return getter(obj);
				}

				public override void set(object obj, object value)
				{
					setter(obj, value);
				}
			}

d7247 1
a7247 1
						return new FastByteFieldAccessor(field, overrideAccessCheck);
d7251 1
a7251 1
						return new FastBooleanFieldAccessor(field, overrideAccessCheck);
d7255 1
a7255 1
						return new FastCharFieldAccessor(field, overrideAccessCheck);
d7259 1
a7259 1
						return new FastShortFieldAccessor(field, overrideAccessCheck);
d7263 1
a7263 1
						return new FastIntegerFieldAccessor(field, overrideAccessCheck);
d7267 1
a7267 1
						return new FastFloatFieldAccessor(field, overrideAccessCheck);
d7271 1
a7271 1
						return new FastLongFieldAccessor(field, overrideAccessCheck);
d7275 1
a7275 1
						return new FastDoubleFieldAccessor(field, overrideAccessCheck);
d7281 1
a7281 1
					return new FastObjectFieldAccessor(field, overrideAccessCheck);
@


1.171
log
@Removed two unnecessary fields from FieldAccessorImplBase.
@
text
@a6488 11
			private abstract class ObjectField : FieldAccessorImplBase
			{
				private readonly jlClass fieldType;

				internal ObjectField(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					fieldType = field.getType();
				}
			}

d7312 1
a7312 1
			private sealed class FastObjectFieldAccessor : ObjectField
@


1.170
log
@- code cleanup as per Jereon's suggestion
- add support for java.awt.Image
- fix problem with HDROP
@
text
@a6331 1
			private readonly jlrField field;
a6333 1
			private bool runInit;
a6336 1
				this.field = field;
a6338 1
				runInit = fw.DeclaringType.IsInterface;
d6341 1
a6341 1
			private String GetQualifiedFieldName()
d6343 6
a6348 1
				return field.getDeclaringClass().getName() + "." + field.getName();
d6380 1
a6380 1
				return new jlIllegalArgumentException("Attempt to get " + field.getType().getName() + " field \"" + GetQualifiedFieldName() + "\" with illegal data type conversion to " + type);
d6387 1
a6387 1
				if (jlrModifier.isStatic(field.getModifiers()))
d6391 1
a6391 1
				err += " " + field.getType().getName() + " field " + GetQualifiedFieldName() + " to ";
@


1.169
log
@add primitive support for clipboard and drag and drop
@
text
@a4947 11
    
    static class IkvmDataTransferer
    {
        [DllImport("USER32.DLL", CharSet=CharSet.Auto, SetLastError=true)]
        public static extern int RegisterClipboardFormat(string format);
        
        public static long registerClipboardFormat(string str)
        {
            return RegisterClipboardFormat(str);
        }
    }
@


1.168
log
@Fix for bug #2876211.
@
text
@d4948 11
@


1.167
log
@Moved GetAssemblyClassLoader() (and related stuff) from ClassLoaderWrapper to AssemblyClassLoader and renamed it to FromAssembly().
@
text
@d6300 16
a6315 1
				return Activator.CreateInstance(type);
@


1.167.2.1
log
@Fix for bug #2876211.
@
text
@d6300 1
a6300 16
#if FIRST_PASS
				return null;
#else
				if (objarr != null && objarr.Length != 0)
				{
					throw new global::java.lang.IllegalArgumentException();
				}
				try
				{
					return Activator.CreateInstance(type);
				}
				catch (TargetInvocationException x)
				{
					throw new global::java.lang.reflect.InvocationTargetException(global::ikvm.runtime.Util.mapException(x.InnerException));
				}
#endif
@


1.167.2.2
log
@Backported fix for #2887316.
@
text
@a2469 1
					wrapper.Finish();
@


1.167.2.3
log
@back ported fix: don't use Type.IsArray when we only want to deal with vectors.
@
text
@d1953 1
a1953 1
					if (ReflectUtil.IsVector(type) && ClassLoaderWrapper.GetWrapperFromType(type.GetElementType()).IsPrimitive)
@


1.167.2.4
log
@back ported fix: If the current timezone is not one of the recognized names, we should return GMT+offset instead of null, because null maps to GMT.
@
text
@d4914 1
a4914 1
						return getSystemGMTOffsetID();
@


1.167.2.5
log
@back ported partial trust fixes.
@
text
@d3516 1
a3516 4
				catch (System.Net.Sockets.SocketException)
				{
				}
				catch (System.Security.SecurityException)
d3518 1
a3519 1
				return "localhost";
@


1.167.2.6
log
@Fix for bug #3033769.
@
text
@a6931 1
						fw.FieldTypeWrapper.EmitCheckcast(null, ilgen);
a6952 4
					if (fieldType == typeof(object))
					{
						fw.FieldTypeWrapper.EmitCheckcast(null, ilgen);
					}
@


1.166
log
@Removed EmitHelper class and moved its methods into CodeEmitter.
@
text
@d5401 1
a5401 1
				return ClassLoaderWrapper.GetAssemblyClassLoader(asm).GetJavaClassLoader();
@


1.165
log
@Added support for exposing open generic types as Java classes (special "handle" classes that can only be used for stack walking).
@
text
@d5862 1
a5862 1
					EmitHelper.NullCheck(ilgen);
d5877 1
a5877 1
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
d5910 1
a5910 1
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
d5912 1
a5912 1
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
d6191 1
a6191 1
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
d6212 1
a6212 1
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
d6214 1
a6214 1
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
@


1.164
log
@ConvertIPAddress is not used during first-pass compilation, so don't try to compile it then.
@
text
@d2215 6
d2252 6
@


1.163
log
@fix the build as it is broken during first pass compilation
@
text
@d3461 2
a3462 1
			internal static object ConvertIPAddress(System.Net.IPAddress address, string hostname)
a3463 3
#if FIRST_PASS
				return null;
#else
d3472 1
a3473 1
			}
d3636 1
a3636 1
						addresses[i] = (jnInetAddress) InetAddress.ConvertIPAddress(addr[i], hostname);
d3733 1
a3733 1
                        addresses[j] = (jnInetAddress) InetAddress.ConvertIPAddress(uipaic[j].Address, null);
@


1.162
log
@Added support for converting IPv6 link/site local addresses to .NET to Java form.
@
text
@d3461 1
a3461 1
			internal static jnInetAddress ConvertIPAddress(System.Net.IPAddress address, string hostname)
d3463 3
d3474 1
d3638 1
a3638 1
						addresses[i] = InetAddress.ConvertIPAddress(addr[i], hostname);
d3735 1
a3735 1
						addresses[j] = InetAddress.ConvertIPAddress(uipaic[j].Address, null);
@


1.161
log
@Removed unused field.
@
text
@d3460 12
d3634 1
a3634 1
						addresses[i] = jnInetAddress.getByAddress(hostname, addr[i].GetAddressBytes());
d3731 1
a3731 2
						// TODO for IPv6 addresses we should set the scope
						addresses[j] = jnInetAddress.getByAddress(uipaic[j].Address.GetAddressBytes());
@


1.160
log
@fix the missing alpha chanel on windows shell icons
@
text
@a4956 1
        static int SRCCOPY = 0x00CC0020;
@


1.159
log
@Automagic .NET serialization support (for classes that are Java serializable).
@
text
@d4948 64
d5074 47
d5140 1
a5140 1
        public static IntPtr getFileChooserBitmapHandle()
d5149 6
a5154 1
            if (hBitmap.ToInt32() != 0)
d5156 1
a5156 1
                return hBitmap;
d5158 16
a5173 2
            IntPtr libComCtl32 = LoadLibrary("comctl32.dll");
            return LoadImageID(libComCtl32, 124, IMAGE_BITMAP, 0, 0, 0);
@


1.158
log
@Implemented .NET serialization support for java.lang.Class objects.
@
text
@d660 6
@


1.157
log
@Optimized primitive class literals.
@
text
@d2368 5
@


1.156
log
@- Consolidated system property initialization in VMSystemProperties.
- Fixed bug that caused startup properties set with ikvm.runtime.Startup.setProperties() to be forgotten when doing a System.setProperties(null).
@
text
@d2503 2
@


1.155
log
@implements getIcon() in ShellFolder
@
text
@a3009 8
		static class Props
		{
			public static string getVirtualFileSystemRoot()
			{
				return VirtualFileSystem.RootPath;
			}
		}

@


1.154
log
@Complete the native part of the WinShellFolder
@
text
@d4927 3
d4995 10
@


1.153
log
@Removed unncessary usage of reflection.
@
text
@d4928 1
d4941 1
a4941 1
        private static extern long FindExecutable(string lpFile, string lpDirectory, StringBuilder lpResult);
d4946 15
d4969 2
a4970 2
            long lngResult = FindExecutable(path, path, objResultBuffer);
            if (lngResult >= 32)
d4991 173
@


1.152
log
@Fixed build break.
@
text
@d432 1
a432 1
					return Activator.CreateInstance(typeof(jlClass).Assembly.GetType("java.io.UnixFileSystem"), true);
d436 1
a436 1
					return Activator.CreateInstance(typeof(jlClass).Assembly.GetType("java.io.Win32FileSystem"), true);
@


1.151
log
@Native code of Win32ShellFolder2 Step 1
@
text
@d34 1
a119 1
using System.Runtime.InteropServices;
@


1.150
log
@Implemented class gc (available only when compiling on .NET 4.0).
@
text
@d2 2
a3 1
  Copyright (C) 2007, 2008 Jeroen Frijters
d119 1
d4920 58
@


1.149
log
@Made java.lang.reflect.Field exception messages the same as JDK 6.
@
text
@d5154 27
d5219 1
@


1.148
log
@Doing a Demand probably makes a little more sense, although not a whole lot. An alternative could be to change the Create() method to distinguish between public, private and internal access and when internal access is requested explicitly look for the InternalsVisibleToAttribute on the target assembly to see if it grants us access, but that seems like a lot of complexity for what is essentially a special case (internal access).
@
text
@d5144 8
d5866 1
a5866 1
		private abstract class FieldAccessorImplBase : srFieldAccessor
d5868 1
d5875 1
d5881 60
d5943 1
a5943 1
				throw new jlIllegalArgumentException();
d5948 1
a5948 1
				throw new jlIllegalArgumentException();
d5953 1
a5953 1
				throw new jlIllegalArgumentException();
d5958 1
a5958 1
				throw new jlIllegalArgumentException();
d5963 1
a5963 1
				throw new jlIllegalArgumentException();
d5968 1
a5968 1
				throw new jlIllegalArgumentException();
d5973 1
a5973 1
				throw new jlIllegalArgumentException();
d5978 1
a5978 1
				throw new jlIllegalArgumentException();
d5983 1
a5983 1
				throw new jlIllegalArgumentException();
d5988 1
a5988 1
				throw new jlIllegalArgumentException();
d5993 1
a5993 1
				throw new jlIllegalArgumentException();
d5998 1
a5998 1
				throw new jlIllegalArgumentException();
d6003 1
a6003 1
				throw new jlIllegalArgumentException();
d6008 1
a6008 1
				throw new jlIllegalArgumentException();
d6013 1
a6013 1
				throw new jlIllegalArgumentException();
d6018 1
a6018 1
				throw new jlIllegalArgumentException();
d6076 1
a6076 1
						throw new jlIllegalArgumentException();
d6098 1
a6098 1
						throw new jlIllegalArgumentException();
d6141 1
a6141 1
						throw new jlIllegalArgumentException();
d6183 1
a6183 1
						throw new jlIllegalArgumentException();
d6228 1
a6228 1
						throw new jlIllegalArgumentException();
d6275 1
a6275 1
						throw new jlIllegalArgumentException();
d6336 1
a6336 1
						throw new jlIllegalArgumentException();
d6384 1
a6384 1
						throw new jlIllegalArgumentException();
d6418 1
a6418 1
			private static Delegate GenerateFastGetter(Type delegateType, Type fieldType, FieldWrapper fw)
d6423 1
a6423 1
				DynamicMethod dm = DynamicMethodUtils.Create("__<Getter>", fw.DeclaringType.TypeAsBaseType, !fw.IsPublic || !fw.DeclaringType.IsPublic, fieldType, new Type[] { typeof(object) });
d6433 1
a6433 1
					ilgen.Emit(OpCodes.Ldarg_0);
d6440 4
a6443 1
					EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
d6448 1
a6448 1
				return dm.CreateDelegate(delegateType);
d6451 1
a6451 1
			private static Delegate GenerateFastSetter(Type delegateType, Type fieldType, FieldWrapper fw)
d6456 1
a6456 1
				DynamicMethod dm = DynamicMethodUtils.Create("__<Setter>", fw.DeclaringType.TypeAsBaseType, !fw.IsPublic || !fw.DeclaringType.IsPublic, null, new Type[] { typeof(object), fieldType });
d6463 1
a6463 1
						ilgen.Emit(OpCodes.Ldarg_1);
d6467 4
a6470 1
						EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
d6475 1
a6475 1
						ilgen.Emit(OpCodes.Ldarg_1);
d6482 1
a6482 1
					ilgen.Emit(OpCodes.Ldarg_0);
d6484 1
a6484 1
					ilgen.Emit(OpCodes.Ldarg_1);
d6488 4
a6491 1
					EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
d6495 1
a6495 1
				return dm.CreateDelegate(delegateType);
d6526 1
a6526 1
						throw new jlIllegalAccessException();
d6571 1
a6571 1
						throw new jlIllegalAccessException();
d6616 1
a6616 1
						throw new jlIllegalAccessException();
d6661 1
a6661 1
						throw new jlIllegalAccessException();
d6706 1
a6706 1
						throw new jlIllegalAccessException();
d6751 1
a6751 1
						throw new jlIllegalAccessException();
d6796 1
a6796 1
						throw new jlIllegalAccessException();
d6841 1
a6841 1
						throw new jlIllegalAccessException();
d6886 1
a6886 1
						throw new jlIllegalAccessException();
@


1.147
log
@Improved partial trust support.
@
text
@a273 2
	private static bool? restrictedMemberAccess;

d306 6
a311 1
			if (!restrictedMemberAccess.HasValue)
d313 1
a313 1
				restrictedMemberAccess = System.Security.SecurityManager.IsGranted(new System.Security.Permissions.ReflectionPermission(System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess));
a314 1
			return restrictedMemberAccess.Value;
@


1.146
log
@Made serialization getters verifiable, to allow OutputOutputStream to be used from partial trust.
@
text
@d274 2
d292 6
d303 12
@


1.145
log
@Removed support for .NET 2.0 RTM (we now require at least SP1). Formally, 0.40 already doesn't support RTM, but it still worked, now it no longer works.
@
text
@d732 12
d759 1
a759 1
								ilgenPrimGetter.Emit(OpCodes.Ldarg_0);
d800 1
d846 1
a846 1
								ilgenObjGetter.Emit(OpCodes.Ldarg_0);
@


1.144
log
@closeSplashScreen changed
@
text
@d292 1
a292 1
			return CreateNET20SP1(name, returnType, paramTypes, nonPublic);
a294 7

	private static DynamicMethod CreateNET20SP1(string name, Type returnType, Type[] paramTypes, bool nonPublic)
	{
		// this needs to be in a separate method, because this constructor doesn't exist on .NET 2.0 RTM
		// (and the JIT will turn the entire calling method into a "throw new MethodMissingException()")
		return new DynamicMethod(name, returnType, paramTypes, nonPublic);
	}
@


1.143
log
@- Moved unsafe operations into Java and added link demand for unmanaged code to them.
- Added some deprecated unsafe methods that are apparantly still being used (or at least referenced) by JRuby.
@
text
@d4883 5
@


1.142
log
@Some vfs restructuring to make VFS a true hierarchy and added support for File.list().
@
text
@a5015 1
	[System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.LinkDemand, UnmanagedCode = true)]
a5045 66

		public static void setMemory(long address, long bytes, byte value)
		{
			while (bytes-- > 0)
			{
				putByte(address++, value);
			}
		}

		public static void copyMemory(long srcAddress, long destAddress, long bytes)
		{
			while (bytes-- > 0)
			{
				putByte(destAddress++, getByte(srcAddress++));
			}
		}

		public static byte getByte(long address)
		{
			return System.Runtime.InteropServices.Marshal.ReadByte((IntPtr)address);
		}

		public static void putByte(long address, byte x)
		{
			System.Runtime.InteropServices.Marshal.WriteByte((IntPtr)address, x);
		}

		public static short getShort(long address)
		{
			return System.Runtime.InteropServices.Marshal.ReadInt16((IntPtr)address);
		}

		public static void putShort(long address, short x)
		{
			System.Runtime.InteropServices.Marshal.WriteInt16((IntPtr)address, x);
		}

		public static char getChar(long address)
		{
			return (char)System.Runtime.InteropServices.Marshal.ReadInt16((IntPtr)address);
		}

		public static void putChar(long address, char x)
		{
			System.Runtime.InteropServices.Marshal.WriteInt16((IntPtr)address, x);
		}

		public static int getInt(long address)
		{
			return System.Runtime.InteropServices.Marshal.ReadInt32((IntPtr)address);
		}

		public static void putInt(long address, int x)
		{
			System.Runtime.InteropServices.Marshal.WriteInt32((IntPtr)address, x);
		}

		public static long getLong(long address)
		{
			return System.Runtime.InteropServices.Marshal.ReadInt64((IntPtr)address);
		}

		public static void putLong(long address, long x)
		{
			System.Runtime.InteropServices.Marshal.WriteInt64((IntPtr)address, x);
		}
@


1.141
log
@Moved Virtual File System into a separate source file.
@
text
@d1313 6
a1318 1
					string[] l = System.IO.Directory.GetFileSystemEntries(GetPathFromFile(f));
@


1.140
log
@Don't let System.NotSupportedException escape from list() if the path is invalid.
@
text
@a32 1
using System.Security.Cryptography.X509Certificates;
a908 413
		static class VirtualFileSystem
		{
			internal static readonly string RootPath = JVM.IsUnix ? "/.virtual-ikvm-home/" : @@"C:\.virtual-ikvm-home\";

			internal static bool IsVirtualFS(string path)
			{
				return (path.Length == RootPath.Length - 1 && String.CompareOrdinal(path, 0, RootPath, 0, RootPath.Length - 1) == 0)
					|| String.CompareOrdinal(path, 0, RootPath, 0, RootPath.Length) == 0;
			}

#if !FIRST_PASS
			private static Dictionary<string, VfsEntry> entries;

			private abstract class VfsEntry
			{
				internal abstract long Size { get; }
				internal virtual bool IsDirectory { get { return false; } }
				internal abstract System.IO.Stream Open();
			}

			private class VfsDummyEntry : VfsEntry
			{
				private bool directory;

				internal VfsDummyEntry(bool directory)
				{
					this.directory = directory;
				}

				internal override long Size
				{
					get { return 0; }
				}

				internal override bool IsDirectory
				{
					get { return directory; }
				}

				internal override System.IO.Stream Open()
				{
					return System.IO.Stream.Null;
				}
			}

			private class VfsZipEntry : VfsEntry
			{
				private juzZipFile zipFile;
				private juzZipEntry entry;

				internal VfsZipEntry(juzZipFile zipFile, juzZipEntry entry)
				{
					this.zipFile = zipFile;
					this.entry = entry;
				}

				internal override long Size
				{
					get { return entry.getSize(); }
				}

				internal override bool IsDirectory
				{
					get { return entry.isDirectory(); }
				}

				internal override System.IO.Stream Open()
				{
					return new ZipEntryStream(zipFile, entry);
				}
			}

			private class VfsCacertsEntry : VfsEntry
			{
				private byte[] buf;

				internal override long Size
				{
					get 
					{
						Populate();
						return buf.Length;
					}
				}

				internal override System.IO.Stream Open()
				{
					Populate();
					return new System.IO.MemoryStream(buf, false);
				}

				private void Populate()
				{
					if (buf == null)
					{
						global::java.security.KeyStore jstore = global::java.security.KeyStore.getInstance("jks");
						jstore.load(null);
						global::java.security.cert.CertificateFactory cf = global::java.security.cert.CertificateFactory.getInstance("X509");

						X509Store store = new X509Store(StoreName.Root, StoreLocation.LocalMachine);
						store.Open(OpenFlags.ReadOnly);
						foreach (X509Certificate2 cert in store.Certificates)
						{
							if (!cert.HasPrivateKey)
							{
								jstore.setCertificateEntry(cert.Subject, cf.generateCertificate(new global::java.io.ByteArrayInputStream(cert.RawData)));
							}
						}
						store.Close();
						global::java.io.ByteArrayOutputStream baos = new global::java.io.ByteArrayOutputStream();
						jstore.store(baos, new char[0]);
						buf = baos.toByteArray();
					}
				}
			}

			private class VfsVfsZipEntry : VfsEntry
			{
				internal override long Size
				{
					get
					{
						using (System.IO.Stream stream = Open())
						{
							return stream.Length;
						}
					}
				}

				internal override System.IO.Stream Open()
				{
					//return new System.IO.FileStream("c:\\ikvm\\openjdk\\vfs.zip", System.IO.FileMode.Open);
					return Assembly.GetExecutingAssembly().GetManifestResourceStream("vfs.zip");
				}
			}

			private abstract class VfsExecutable : VfsEntry
			{
				internal override bool IsDirectory { get { return false; } }
				internal override long Size { get { return 0; } }

				internal override System.IO.Stream Open()
				{
					return System.IO.Stream.Null;
				}

				internal abstract string GetPath();
			}

			private class VfsJavaExe : VfsExecutable
			{
				private string path;

				internal override string GetPath()
				{
					if (path == null)
					{
						path = new System.Uri(Assembly.GetEntryAssembly().CodeBase + "/../ikvm.exe").LocalPath;
					}
					return path;
				}
			}

			private static void Initialize()
			{
				// this is a weird loop back, the vfs.zip resource is loaded from vfs,
				// because that's the easiest way to construct a ZipFile from a Stream.
				juzZipFile zf = new juzZipFile(RootPath + "vfs.zip");
				global::java.util.Enumeration e = zf.entries();
				Dictionary<string, VfsEntry> dict = new Dictionary<string, VfsEntry>();
				char sep = jiFile.separatorChar;
				while (e.hasMoreElements())
				{
					juzZipEntry entry = (juzZipEntry)e.nextElement();
					dict[RootPath + entry.getName().Replace('/', sep)] = new VfsZipEntry(zf, entry);
				}
				dict[RootPath.Substring(0, RootPath.Length - 1)] = new VfsDummyEntry(true);
				dict[RootPath + "lib/security/cacerts".Replace('/', sep)] = new VfsCacertsEntry();
				dict[RootPath + "bin"] = new VfsDummyEntry(true);
				dict[RootPath + "bin" + sep + global::java.lang.System.mapLibraryName("zip")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + global::java.lang.System.mapLibraryName("awt")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + global::java.lang.System.mapLibraryName("rmi")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + global::java.lang.System.mapLibraryName("w2k_lsa_auth")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + global::java.lang.System.mapLibraryName("jaas_nt")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + global::java.lang.System.mapLibraryName("jaas_unix")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + global::java.lang.System.mapLibraryName("unpack")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + global::java.lang.System.mapLibraryName("net")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + "java"] = new VfsJavaExe();
				dict[RootPath + "bin" + sep + "javaw"] = new VfsJavaExe();
				dict[RootPath + "bin" + sep + "java.exe"] = new VfsJavaExe();
				dict[RootPath + "bin" + sep + "javaw.exe"] = new VfsJavaExe();
				if (Interlocked.CompareExchange(ref entries, dict, null) != null)
				{
					// we lost the race, so we close our zip file
					zf.close();
				}
			}

			private static VfsEntry GetVfsEntry(string name)
			{
				if (entries == null)
				{
					if (name == RootPath + "vfs.zip")
					{
						return new VfsVfsZipEntry();
					}
					Initialize();
				}
				VfsEntry ve;
				entries.TryGetValue(name, out ve);
				return ve;
			}

			private sealed class ZipEntryStream : System.IO.Stream
			{
				private juzZipFile zipFile;
				private juzZipEntry entry;
				private jiInputStream inp;
				private long position;

				internal ZipEntryStream(juzZipFile zipFile, juzZipEntry entry)
				{
					this.zipFile = zipFile;
					this.entry = entry;
					inp = zipFile.getInputStream(entry);
				}

				public override bool CanRead
				{
					get { return true; }
				}

				public override bool CanWrite
				{
					get { return false; }
				}

				public override bool CanSeek
				{
					get { return true; }
				}

				public override long Length
				{
					get { return entry.getSize(); }
				}

				public override int Read(byte[] buffer, int offset, int count)
				{
					// For compatibility with real file i/o, we try to read the requested number
					// of bytes, instead of returning earlier if the underlying InputStream does so.
					int totalRead = 0;
					while (count > 0)
					{
						int read = inp.read(buffer, offset, count);
						if (read <= 0)
						{
							break;
						}
						offset += read;
						count -= read;
						totalRead += read;
						position += read;
					}
					return totalRead;
				}

				public override long Position
				{
					get
					{
						return position;
					}
					set
					{
						if (value < position)
						{
							if (value < 0)
							{
								throw new System.IO.IOException("Negative seek offset");
							}
							position = 0;
							inp.close();
							inp = zipFile.getInputStream(entry);
						}
						long skip = value - position;
						while (skip > 0)
						{
							long skipped = inp.skip(skip);
							if (skipped == 0)
							{
								if (position != entry.getSize())
								{
									throw new System.IO.IOException("skip failed");
								}
								// we're actually at EOF in the InputStream, but we set the virtual position beyond EOF
								position += skip;
								break;
							}
							position += skipped;
							skip -= skipped;
						}
					}
				}

				public override void Flush()
				{
				}

				public override long Seek(long offset, System.IO.SeekOrigin origin)
				{
					switch (origin)
					{
						case System.IO.SeekOrigin.Begin:
							Position = offset;
							break;
						case System.IO.SeekOrigin.Current:
							Position += offset;
							break;
						case System.IO.SeekOrigin.End:
							Position = entry.getSize() + offset;
							break;
					}
					return position;
				}

				public override void Write(byte[] buffer, int offset, int count)
				{
					throw new NotSupportedException();
				}

				public override void SetLength(long value)
				{
					throw new NotSupportedException();
				}

				public override void Close()
				{
 					base.Close();
					inp.close();
				}
			}
#endif

			internal static System.IO.Stream Open(string name, System.IO.FileMode fileMode, System.IO.FileAccess fileAccess)
			{
#if FIRST_PASS
				return null;
#else
				if (fileMode != System.IO.FileMode.Open || fileAccess != System.IO.FileAccess.Read)
				{
					throw new System.IO.IOException("vfs is read-only");
				}
				VfsEntry entry = GetVfsEntry(name);
				if (entry == null)
				{
					throw new System.IO.FileNotFoundException("File not found");
				}
				return entry.Open();
#endif
			}

			internal static long GetLength(string path)
			{
#if FIRST_PASS
				return 0;
#else
				VfsEntry entry = GetVfsEntry(path);
				return entry == null ? 0 : entry.Size;
#endif
			}

			internal static bool CheckAccess(string path, int access)
			{
#if FIRST_PASS
				return false;
#else
				return access == Win32FileSystem.ACCESS_READ && GetVfsEntry(path) != null;
#endif
			}

			internal static int GetBooleanAttributes(string path)
			{
#if FIRST_PASS
				return 0;
#else
				VfsEntry entry = GetVfsEntry(path);
				if (entry == null)
				{
					return 0;
				}
				const int BA_EXISTS = 0x01;
				const int BA_REGULAR = 0x02;
				const int BA_DIRECTORY = 0x04;
				return entry.IsDirectory ? BA_EXISTS | BA_DIRECTORY : BA_EXISTS | BA_REGULAR;
#endif
			}

			internal static string MapExecutable(string path)
			{
#if FIRST_PASS
				return null;
#else
				VfsExecutable entry = GetVfsEntry(path) as VfsExecutable;
				if (entry == null)
				{
					return path;
				}
				return entry.GetPath();
#endif
			}
		}

d2831 1
a2831 1
					if (java.io.VirtualFileSystem.IsVirtualFS(name))
d2979 1
a2979 1
				return io.VirtualFileSystem.RootPath;
d3332 1
a3332 1
				if (IKVM.NativeCode.java.io.VirtualFileSystem.IsVirtualFS(path))
d3334 1
a3334 1
					return IKVM.NativeCode.java.io.VirtualFileSystem.MapExecutable(path);
@


1.139
log
@Add additional empty native methods for AWT and Swing (mostly initIDs)
@
text
@d1747 3
@


1.138
log
@More Sun classes (SwingUtilities2)
@
text
@d5281 10
d5309 15
d7593 67
d7664 92
@


1.137
log
@Integrated OpenJDK java/awt/image and java/awt/image/renderable packages.
@
text
@d7566 8
@


1.136
log
@Handle case were there is no user class loader.
@
text
@d7583 33
@


1.136.2.1
log
@Workaround for #2843805.
@
text
@d3471 1
a3471 5
					TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(type);
					if (tw != null)
					{
						stack.Add((jlClass)tw.ClassObject);
					}
d5635 1
a5635 6
					TypeWrapper tw = ClassLoaderWrapper.GetWrapperFromType(type);
					if (tw != null)
					{
						return tw.ClassObject;
					}
					return null;
@


1.136.2.2
log
@Backported com.sun.security.auth.module.NTSystem implementation.
@
text
@a7524 2
	using System.Security.Principal;

d7529 1
a7529 20
			WindowsIdentity id = WindowsIdentity.GetCurrent();
			string[] name = id.Name.Split('\\');
			SetField(thisObj, "userName", name[1]);
			SetField(thisObj, "domain", name[0]);
			SetField(thisObj, "domainSID", id.User.AccountDomainSid.Value);
			SetField(thisObj, "userSID", id.User.Value);
			string[] groups = new string[id.Groups.Count];
			for (int i = 0; i < groups.Length; i++)
			{
				groups[i] = id.Groups[i].Value;
			}
			SetField(thisObj, "groupIDs", groups);
			// HACK it turns out that Groups[0] is the primary group, but AFAIK this is not documented anywhere
			SetField(thisObj, "primaryGroupID", groups[0]);
			SetField(thisObj, "impersonationToken", id.Token.ToInt64());
		}

		private static void SetField(object thisObj, string field, object value)
		{
			thisObj.GetType().GetField(field, BindingFlags.NonPublic | BindingFlags.Instance).SetValue(thisObj, value);
@


1.135
log
@Added (limited) support for defining instance fields on remapped types. The fields will only be available on the actual implementation types, not the types they shadow (accessing the field on a shadow instance is undefined, but for reflection we'll at least guarantee that an exception is thrown (current java.lang.IllegalArgumentException)).
@
text
@d462 1
a462 1
				for (int i = 0; ; i++)
d468 1
a468 1
						return null;
d489 1
@


1.134
log
@Implemented native library unloading to support evil trick that com.sun.jna.Native$DeleteNativeLibrary uses (it uses reflection to call ClassLoader$NativeLibrary.finalize() to force the native library to be unloaded, even though the class loader isn't garbage collected.)
@
text
@d6778 1
a6778 1
					ilgen.Emit(OpCodes.Castclass, fw.DeclaringType.TypeAsTBD);
d6821 1
a6821 1
					ilgen.Emit(OpCodes.Castclass, fw.DeclaringType.TypeAsTBD);
@


1.133
log
@Fix. If we don't run the class initializer, we shouldn't still report its presence.
@
text
@d3244 1
a3244 1
						SetHandle(thisNativeLibrary, -1);
d3258 2
a3259 5
					jlClass fromClass = ((global::java.lang.ClassLoader.NativeLibrary)thisNativeLibrary).fromClass;
					if (IKVM.Runtime.JniHelper.LoadLibrary(name, TypeWrapper.FromClass(fromClass).GetClassLoader()) == 1)
					{
						SetHandle(thisNativeLibrary, -1);
					}
a3262 8

				private static void SetHandle(object thisNativeLibrary, long handle)
				{
#if !FIRST_PASS
					((global::java.lang.ClassLoader.NativeLibrary)thisNativeLibrary).handle = handle;
#endif
				}

d3271 8
a3278 2
					// TODO
					throw new NotImplementedException();
@


1.132
log
@Fixed first-pass compilation.
@
text
@d655 1
a655 1
				if (!type.IsArray && type.TypeInitializer != null && runClassInit)
d657 4
a660 1
					wrapper.RunClassInit();
@


1.131
log
@Switched java.awt.event package from GNU Classpath to OpenJDK.
@
text
@d637 1
d640 1
@


1.130
log
@Added hack to skip running the static initializer when computing the serialVersionUID when running in ikvmstub.
@
text
@d7564 18
@


1.129
log
@Fixed first-pass compilation.
@
text
@d633 2
d637 2
d653 1
a653 1
				if (!type.IsArray && type.TypeInitializer != null)
@


1.128
log
@Removed unnecessary field initialization and registerNative call.
@
text
@d6242 26
a7307 26
		sealed class ActivatorConstructorAccessor : srConstructorAccessor
		{
			private readonly Type type;

			internal ActivatorConstructorAccessor(MethodWrapper mw)
			{
				this.type = mw.DeclaringType.TypeAsBaseType;
			}

			public object newInstance(object[] objarr)
			{
				return Activator.CreateInstance(type);
			}

			internal static bool IsSuitable(MethodWrapper mw)
			{
				MethodBase mb = mw.GetMethod();
				return mb != null
					&& mb.IsConstructor
					&& mb.IsPublic
					&& mb.DeclaringType.IsPublic
					&& mb.DeclaringType == mw.DeclaringType.TypeAsBaseType
					&& mb.GetParameters().Length == 0;
			}
		}

@


1.127
log
@Added optimization to reflective instantiation to use Activator.CreateInstance() when that is almost as fast as our LCG based implementation (which has a far higher initial cost).
@
text
@a2612 4
			public static void registerNatives()
			{
			}

@


1.126
log
@Use JMath functions (where possible and necessary) instead of .NET Math functions.
@
text
@d7286 26
d7323 7
@


1.125
log
@Speed up stack walking.
@
text
@d3506 5
a3510 1
				return Math.Sin(d);
d3515 5
a3519 1
				return Math.Cos(d);
d3524 5
a3528 1
				return Math.Tan(d);
d3533 5
a3537 1
				return Math.Asin(d);
d3542 5
a3546 1
				return Math.Acos(d);
d3551 5
a3555 1
				return Math.Atan(d);
d3560 5
a3564 1
				return Math.Exp(d);
d3569 1
d3575 1
d3581 1
d3592 5
a3596 5
				if (SystemDouble.IsInfinity(f2) && !SystemDouble.IsInfinity(f1))
				{
					return f1;
				}
				return Math.IEEERemainder(f1, f2);
d3601 5
a3605 1
				return Math.Ceiling(d);
d3610 5
a3614 1
				return Math.Floor(d);
d3619 5
a3623 26
				if (SystemDouble.IsInfinity(y) && SystemDouble.IsInfinity(x))
				{
					if (SystemDouble.IsPositiveInfinity(y))
					{
						if (SystemDouble.IsPositiveInfinity(x))
						{
							return Math.PI / 4.0;
						}
						else
						{
							return Math.PI * 3.0 / 4.0;
						}
					}
					else
					{
						if (SystemDouble.IsPositiveInfinity(x))
						{
							return -Math.PI / 4.0;
						}
						else
						{
							return -Math.PI * 3.0 / 4.0;
						}
					}
				}
				return Math.Atan2(y, x);
d3628 5
a3632 5
				if (Math.Abs(x) == 1.0 && SystemDouble.IsInfinity(y))
				{
					return SystemDouble.NaN;
				}
				return Math.Pow(x, y);
d3652 5
a3656 1
				return Math.Round(d);
@


1.124
log
@First pass compilation fix.
@
text
@d460 3
a462 1
				for (int i = 1; ; i++)
d464 1
a464 1
					StackFrame frame = new StackFrame(i);
@


1.123
log
@Added supported for redirecting Runtime.exec("java ...") to ikvm.exe.
@
text
@d1298 3
d1307 1
@


1.122
log
@Changed "InternalsVisibleTo" handling to be based on Assembly instead of class loader.
@
text
@d1034 27
d1085 4
d1295 10
d3710 12
@


1.121
log
@Added AssemblyClassLoader.GetAssembly(TypeWrapper) and changed most code that assumed that an AssemblyClassLoader represented a single assembly to use it.
@
text
@d5568 1
a5568 1
			return member.IsInternal && member.GetClassLoader().InternalsVisibleTo(current.GetClassLoader());
@


1.120
log
@Use CallerID instead of stack walking.
@
text
@d476 1
a476 1
							if (acl == null || acl.Assembly != typeof(object).Assembly)
@


1.119
log
@Moved AccessController.doPrivileged() to Java and use CallerID to avoid stack walk.
@
text
@a102 1
using jsDriverManager = java.sql.DriverManager;
a4597 36
	namespace sql
	{
		static class DriverManager
		{
			public static object getCallerClassLoader()
			{
#if FIRST_PASS
				return null;
#else
				for (int i = 1; ; i++)
				{
					StackFrame frame = new StackFrame(i);
					MethodBase method = frame.GetMethod();
					if (method == null)
					{
						return null;
					}
					Type type = method.DeclaringType;
					if (type != typeof(jsDriverManager))
					{
						if (type != null)
						{
							TypeWrapper wrapper = ClassLoaderWrapper.GetWrapperFromType(type);
							if (wrapper != null)
							{
								return wrapper.GetClassLoader().GetJavaClassLoader();
							}
						}
						return null;
					}
				}
#endif
			}
		}
	}

@


1.118
log
@Forked java/util/ResourceBundle.java to remove custom stack walking and use CallerID instead.
@
text
@d4507 1
a4507 65
			[ThreadStatic]
			private static PrivilegedElement privileged_stack_top;

			private class PrivilegedElement
			{
				internal object protection_domain;
				internal object privileged_context;
			}

			// NOTE two different Java methods map to this native method
			public static object doPrivileged(object action)
			{
				return doPrivileged(action, null);
			}

			[MethodImpl(MethodImplOptions.NoInlining)]
			public static object doPrivileged(object action, object context)
			{
#if FIRST_PASS
				return null;
#else
				Type caller;
				for (int i = 1; ; i++)
				{
					caller = new StackFrame(i).GetMethod().DeclaringType;
					if (caller != typeof(AccessController) && caller != typeof(jsAccessController))
					{
						break;
					}
				}

				PrivilegedElement savedPrivilegedElement = privileged_stack_top;
				try
				{
					PrivilegedElement pi = new PrivilegedElement();
					privileged_stack_top = pi;
					pi.privileged_context = context;
					pi.protection_domain = GetProtectionDomainFromType(caller);
					jsPrivilegedAction pa = action as jsPrivilegedAction;
					if (pa != null)
					{
						return pa.run();
					}
					try
					{
						return ((jsPrivilegedExceptionAction)action).run();
					}
					catch (Exception x)
					{
						x = irUtil.mapException(x);
						if (x is jlException && !(x is jlRuntimeException))
						{
							throw new jsPrivilegedActionException((jlException)x);
						}
						throw;
					}
				}
				finally
				{
					privileged_stack_top = savedPrivilegedElement;
				}
#endif
			}

			public static object getStackAccessControlContext()
d4526 3
a4528 3
						PrivilegedElement p = privileged_stack_top;
						privileged_context = p.privileged_context;
						protection_domain = p.protection_domain;
@


1.117
log
@Removed ResolverConfigurationImpl "native" methods that have been moved to Java side.
@
text
@a5020 25
		static class ResourceBundle
		{
			public static object getClassContext()
			{
#if FIRST_PASS
				return null;
#else
				// the caller is only interested in context[2], so that's all we'll fill
				jlClass[] context = new jlClass[3];
				int index = 4;
				// HACK handle inlining or tail-call optimization of native method stub
				if (new StackFrame(1).GetMethod().Name != "getClassContext")
				{
					index--;
				}
				Type type = new StackFrame(index).GetMethod().DeclaringType;
				if (type != null)
				{
					context[2] = (jlClass)ClassLoaderWrapper.GetWrapperFromType(type).ClassObject;
				}
				return context;
#endif
			}
		}

@


1.116
log
@Don't load IKVM.Runtime.JNI.dll when "loading" a fake native library.
@
text
@a119 1
using sndResolverConfigurationImpl = sun.net.dns.ResolverConfigurationImpl;
a5583 57
namespace IKVM.NativeCode.sun.net.dns
{
	static class ResolverConfigurationImpl
	{
		public static void init0()
		{
		}

		private static string StrAppend(string s, string app)
		{
			if (s == "")
			{
				return app;
			}
			if (app == "")
			{
				return s;
			}
			return s + " " + app;
		}

		public static void loadDNSconfig0()
		{
#if !FIRST_PASS
			string searchlist = "";
			string nameservers = "";
			foreach (System.Net.NetworkInformation.NetworkInterface iface in System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces())
			{
				System.Net.NetworkInformation.IPInterfaceProperties props = iface.GetIPProperties();
				foreach (System.Net.IPAddress addr in props.DnsAddresses)
				{
					// no IPv6 support
					if (addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
					{
						nameservers = StrAppend(nameservers, addr.ToString());
					}
				}
				try
				{
					searchlist = StrAppend(searchlist, props.DnsSuffix);
				}
				catch (PlatformNotSupportedException)
				{
				}
			}
			sndResolverConfigurationImpl._set(searchlist, nameservers);
#endif
		}

		public static int notifyAddrChange0()
		{
			// TODO on .NET 2.0 we could use System.Net.NetworkInformation.NetworkChange to detect changes
			return -1;
		}
	}
}

@


1.115
log
@Moved .NEt 2.0 SP1 specific constructor invocation into a separate method, to avoid getting a MissingMethodException on .NET 2.0.
@
text
@d3204 2
@


1.114
log
@Re-introduced workaround for .NET JIT bug that causes .cctor not to run when a DynamicMethod invokes a method or gets/sets a field.
@
text
@d295 1
a295 1
			return new DynamicMethod(name, returnType, paramTypes, nonPublic);
d298 7
@


1.113
log
@Moved sound factory methods to runtime, to allow for easier experimentation with a sound implementation.
@
text
@d5876 25
d6004 4
d6917 2
d6925 2
d6962 2
d6970 2
d7007 2
d7015 2
d7052 2
d7060 2
d7097 2
d7105 2
d7142 2
d7150 2
d7187 2
d7195 2
d7232 2
d7240 2
d7277 2
d7285 2
@


1.113.2.1
log
@Re-introduced workaround for .NET JIT bug that causes .cctor not to run when a DynamicMethod invokes a method or gets/sets a field.
@
text
@a5875 25
			private sealed class RunClassInit
			{
				private FastMethodAccessorImpl outer;
				private TypeWrapper tw;
				private Invoker invoker;

				internal RunClassInit(FastMethodAccessorImpl outer, TypeWrapper tw, Invoker invoker)
				{
					this.outer = outer;
					this.tw = tw;
					this.invoker = invoker;
				}

				[IKVM.Attributes.HideFromJava]
				internal object invoke(object obj, object[] args, global::ikvm.@@internal.CallerID callerID)
				{
					// FXBUG pre-SP1 a DynamicMethod that calls a static method doesn't trigger the cctor, so we do that explicitly.
					// even on .NET 2.0 SP2, interface method invocations don't run the interface cctor
					// NOTE when testing, please test both the x86 and x64 CLR JIT, because they have different bugs (even on .NET 2.0 SP2)
					tw.RunClassInit();
					outer.invoker = invoker;
					return invoker(obj, args, callerID);
				}
			}

a5978 4
				if ((mw.IsStatic || mw.DeclaringType.IsInterface) && mw.DeclaringType.HasStaticInitializer)
				{
					invoker = new Invoker(new RunClassInit(this, mw.DeclaringType, invoker).invoke);
				}
a6887 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a6893 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a6928 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a6934 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a6969 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a6975 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7010 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7016 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7051 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7057 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7092 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7098 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7133 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7139 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7174 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7180 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7215 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7221 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
@


1.113.2.2
log
@Backported fixes and updated version to 0.38.0.1:
- Hide callerID nested types.
- Made finalize() and clone() methods in cli.System.Object and cli.System.Exception final.
- Fixed reflection to work on .NET 2.0 RTM.
@
text
@d295 1
a295 1
			return CreateNET20SP1(name, returnType, paramTypes, nonPublic);
a297 7

	private static DynamicMethod CreateNET20SP1(string name, Type returnType, Type[] paramTypes, bool nonPublic)
	{
		// this needs to be in a separate method, because this constructor doesn't exist on .NET 2.0 RTM
		// (and the JIT will turn the entire calling method into a "throw new MethodMissingException()")
		return new DynamicMethod(name, returnType, paramTypes, nonPublic);
	}
@


1.113.2.3
log
@Changed version to 0.38.0.3 and backported these fixes:
- Fixed the stack trace when an unwrapped java.lang.Error (or subclass) escapes from a static initializer.
- It turns out that we really should create an MBeanServer in sun.management.ManagementFactory.createPlatformMBeanServer(), even if we don't populate it with anything useful, applications might still want to register their own MBeans. This fix allows Derby 10.4.2.0 to work.
- Added helpful message to ClassCastException generated for ghost array casts.
- Added check for constructor with missing body in map.xml.
- Removed over eager state checking from java.util.zip.Deflater. Fixes Lucene issue.
- Fixed enclosing method discovery to work for ReflectionOnly assemblies. This allows ikvmstub to work with ikvmc generated assemblies.
- Always emit an explicit method override if we've mangled the name/sig, because we can't predict whether it will be needed or not (without keeping track of the mangling in the base classes) and the cost is minimal since this doesn't happen all that often.
- Miranda method should use mangled name (if the name is mangled).
- Fixed pointer detection to work for types with multiple indirection levels.
- If the last call site of a subroutine wasn't reachable, the return switch would fall through potentially causing the code to be unverifiable.
- The check for unloadable types on the stack indexed the stack in the wrong order.
- Fixed exception wrapping for java.security.AccessController.doPrivileged().
- Fixed tracer to only add a trace listener in executables.
@
text
@d4545 4
a4550 4
						if (pa != null)
						{
							return pa.run();
						}
@


1.112
log
@Fixed float/double array (de)serialization endianness.
@
text
@d7535 25
@


1.111
log
@Removed the usage of .NET reflection.
@
text
@d425 2
a426 1
				while (nfloats-- > 0)
d428 5
a432 2
					dst[dstpos++] = BitConverter.ToSingle(src, srcpos);
					srcpos += 4;
d438 2
a439 1
				while (ndoubles-- > 0)
d441 9
a449 2
					dst[dstpos++] = BitConverter.ToDouble(src, srcpos);
					srcpos += 8;
d493 1
a493 2
					dst[dstpos++] = (byte)(v >>  0);
					dst[dstpos++] = (byte)(v >>  8);
d495 2
a496 1
					dst[dstpos++] = (byte)(v >> 24);
d506 7
a513 7
					dst[dstpos++] = (byte)(v >> 8);
					dst[dstpos++] = (byte)(v >> 16);
					dst[dstpos++] = (byte)(v >> 24);
					dst[dstpos++] = (byte)(v >> 32);
					dst[dstpos++] = (byte)(v >> 40);
					dst[dstpos++] = (byte)(v >> 48);
					dst[dstpos++] = (byte)(v >> 56);
@


1.110
log
@Moved all creations of DynamicMethod to util method that uniformly handles the fallback to the new .NET 2.0 SP1 constructor that support partial trust.
@
text
@d245 1
a245 2
			Type type = typeof(jlClass).Assembly.GetType("java.lang.AssertionStatusDirectives");
			object obj = Activator.CreateInstance(type, true);
d255 2
a256 2
			type.GetField("classes", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, arrStrings);
			type.GetField("classEnabled", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, arrBools);
d266 4
a269 4
			type.GetField("packages", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, arrStrings);
			type.GetField("packageEnabled", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, arrBools);
			type.GetField("deflt", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, userAsserts);
			return obj;
a656 1
				private static readonly FieldInfo fieldField = typeof(jiObjectStreamField).GetField("field", BindingFlags.Instance | BindingFlags.NonPublic);
d840 1
a840 1
					object f = fieldField.GetValue(field);
d3187 1
a3187 1
					object fromClass = thisNativeLibrary.GetType().GetField("fromClass", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(thisNativeLibrary);
d3198 3
a3200 1
					thisNativeLibrary.GetType().GetField("handle", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(thisNativeLibrary, handle);
a3920 4
			private static ConstructorInfo ni_ctor;
			private static FieldInfo ni_displayName;
			private static FieldInfo ni_bindings;
			private static FieldInfo ni_childs;
a3926 6
#if !FIRST_PASS
				ni_ctor = typeof(jnNetworkInterface).GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { typeof(string), typeof(int), typeof(jnInetAddress[]) }, null);
				ni_displayName = typeof(jnNetworkInterface).GetField("displayName", BindingFlags.Instance | BindingFlags.NonPublic);
				ni_bindings = typeof(jnNetworkInterface).GetField("bindings", BindingFlags.Instance | BindingFlags.NonPublic);
				ni_childs = typeof(jnNetworkInterface).GetField("childs", BindingFlags.Instance | BindingFlags.NonPublic);
#endif
d3992 1
a3992 1
					ret[i] = (jnNetworkInterface)ni_ctor.Invoke(new object[] { name, i, addresses });
d3994 1
a3994 3
					ni_bindings.SetValue(ret[i], new jnInterfaceAddress[0]);
					ni_childs.SetValue(ret[i], new jnNetworkInterface[0]);
					ni_displayName.SetValue(ret[i], ifaces[i].Description);
a4486 3
			private static FieldInfo threadIaccField;
			private static ConstructorInfo accessControlContextContructor;
			private static FieldInfo accessControlContextPrivilegedContextField;
d4608 3
a4610 14
				if (accessControlContextContructor == null)
				{
					accessControlContextContructor = typeof(jsAccessControlContext).GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[] { typeof(ProtectionDomain[]), typeof(bool) }, null);
				}
				object obj = accessControlContextContructor.Invoke(new object[] { context, is_privileged });
				if (privileged_context != null)
				{
					if (accessControlContextPrivilegedContextField == null)
					{
						accessControlContextPrivilegedContextField = typeof(jsAccessControlContext).GetField("privilegedContext", BindingFlags.NonPublic | BindingFlags.Instance);
					}
					accessControlContextPrivilegedContextField.SetValue(obj, privileged_context);
				}
				return obj;
d4637 1
a4637 5
				if (threadIaccField == null)
				{
					threadIaccField = typeof(jlThread).GetField("inheritedAccessControlContext", BindingFlags.NonPublic | BindingFlags.Instance);
				}
				return threadIaccField.GetValue(jlThread.currentThread());
d5609 1
a5609 3
			Type type = typeof(sndResolverConfigurationImpl);
			type.GetField("os_searchlist", BindingFlags.Static | BindingFlags.NonPublic).SetValue(null, searchlist);
			type.GetField("os_nameservers", BindingFlags.Static | BindingFlags.NonPublic).SetValue(null, nameservers);
@


1.109
log
@- Fixed VFS root directory entry.
- Removed no longer needed VM.isBooted() check (VM.isBooted() always returns true now on IKVM).
@
text
@d276 25
d705 4
a708 4
						DynamicMethod dmObjGetter = new DynamicMethod("__<ObjFieldGetter>", null, new Type[] { typeof(object), typeof(object[]) }, tw.TypeAsBaseType);
						DynamicMethod dmPrimGetter = new DynamicMethod("__<PrimFieldGetter>", null, new Type[] { typeof(object), typeof(byte[]) }, tw.TypeAsBaseType);
						DynamicMethod dmObjSetter = new DynamicMethod("__<ObjFieldSetter>", null, new Type[] { typeof(object), typeof(object[]) }, tw.TypeAsBaseType);
						DynamicMethod dmPrimSetter = new DynamicMethod("__<PrimFieldSetter>", null, new Type[] { typeof(object), typeof(byte[]) }, tw.TypeAsBaseType);
d5901 1
a5901 10
				DynamicMethod dm;
				if (mw.DeclaringType.TypeAsBaseType.IsInterface)
				{
					// FXBUG interfaces aren't allowed as owners of dynamic methods
					dm = new DynamicMethod("__<Invoker>", MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, typeof(object), new Type[] { typeof(object), typeof(object[]), typeof(global::ikvm.@@internal.CallerID) }, mw.DeclaringType.TypeAsTBD.Module, true);
				}
				else
				{
					dm = new DynamicMethod("__<Invoker>", typeof(object), new Type[] { typeof(object), typeof(object[]), typeof(global::ikvm.@@internal.CallerID) }, mw.DeclaringType.TypeAsBaseType);
				}
d6217 1
a6217 1
				DynamicMethod dm = new DynamicMethod("__<Invoker>", typeof(object), new Type[] { typeof(object[]) }, mw.DeclaringType.TypeAsTBD);
d6313 1
a6313 1
				DynamicMethod dm = new DynamicMethod("__<SerializationCtor>", typeof(object), null, constructor.DeclaringType.TypeAsBaseType);
d6826 1
a6826 10
				DynamicMethod dm;
				if (fw.DeclaringType.TypeAsBaseType.IsInterface)
				{
					// FXBUG interfaces aren't allowed as owners of dynamic methods
					dm = new DynamicMethod("__<Getter>", MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, fieldType, new Type[] { typeof(object) }, fw.DeclaringType.TypeAsBaseType.Module, true);
				}
				else
				{
					dm = new DynamicMethod("__<Getter>", fieldType, new Type[] { typeof(object) }, fw.DeclaringType.TypeAsBaseType);
				}
d6856 1
a6856 10
				DynamicMethod dm;
				if (fw.DeclaringType.TypeAsBaseType.IsInterface)
				{
					// FXBUG interfaces aren't allowed as owners of dynamic methods
					dm = new DynamicMethod("__<Setter>", MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, null, new Type[] { typeof(object), fieldType }, fw.DeclaringType.TypeAsBaseType.Module, true);
				}
				else
				{
					dm = new DynamicMethod("__<Setter>", null, new Type[] { typeof(object), fieldType }, fw.DeclaringType.TypeAsBaseType);
				}
@


1.108
log
@Removed class init workaround that is no longer required since .NET 2.0 SP1.
@
text
@d1007 1
a1007 1
				dict[RootPath] = new VfsDummyEntry(true);
a4545 8
				if (!smVM.isBooted())
				{
					// NOTE work around boot strap issue. When the main thread is attached,
					// it calls us for the inherited AccessControlContext, but we won't be able
					// to provide anything meaningful (primarily because we can't create
					// ProtectionDomain instances yet) so we return null (which implies full trust).
					return null;
				}
@


1.107
log
@Removed last parts of old-style reflection.
@
text
@a5878 23
			private sealed class RunClassInit
			{
				private FastMethodAccessorImpl outer;
				private TypeWrapper tw;
				private Invoker invoker;

				internal RunClassInit(FastMethodAccessorImpl outer, TypeWrapper tw, Invoker invoker)
				{
					this.outer = outer;
					this.tw = tw;
					this.invoker = invoker;
				}

				[IKVM.Attributes.HideFromJava]
				internal object invoke(object obj, object[] args, global::ikvm.@@internal.CallerID callerID)
				{
					// FXBUG pre-SP1 a DynamicMethod that calls a static method doesn't trigger the cctor, so we do that explicitly.
					tw.RunClassInit();
					outer.invoker = invoker;
					return invoker(obj, args, callerID);
				}
			}

a5990 5

				if (mw.IsStatic)
				{
					invoker = new Invoker(new RunClassInit(this, mw.DeclaringType, invoker).invoke);
				}
a6917 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a6923 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a6958 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a6964 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a6999 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7005 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7040 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7046 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7081 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7087 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7122 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7128 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7163 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7169 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7204 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7210 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7245 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
a7251 2
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
@


1.106
log
@- Removed "slow" reflection.
- Removed MethodWrapper.Invoke().
- Removed FieldWrapper.GetValue()/SetValue().
- Added ICustomInvoke for the few MethodWrappers that still require custom reflection invocation.
@
text
@d5819 1
a5819 1
					retval = ((ICustomInvoke)mw).Invoke(obj, args, false, callerID);
d5908 1
a5908 1
				if (mw.DeclaringType.TypeAsTBD.IsInterface)
d5915 1
a5915 1
					dm = new DynamicMethod("__<Invoker>", typeof(object), new Type[] { typeof(object), typeof(object[]), typeof(global::ikvm.@@internal.CallerID) }, mw.DeclaringType.TypeAsTBD);
d5999 1
a5999 1
					mw.EmitCallvirt(ilgen);
d6217 1
a6217 1
					return ((ICustomInvoke)mw).Invoke(null, args, false, null);
@


1.105
log
@Changed JNI reflection to be based on Java reflection (where possible).
@
text
@a122 21
static class DynamicMethodSupport
{
	internal static readonly bool Enabled = IsFullTrust;

	private static bool IsFullTrust
	{
		get
		{
			try
			{
				new System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode).Demand();
				return true;
			}
			catch (System.Security.SecurityException)
			{
				return false;
			}
		}
	}
}

d853 1
a853 8
				if (DynamicMethodSupport.Enabled)
				{
					return new FastFieldReflector((jiObjectStreamField[])fieldsObj);
				}
				else
				{
					return null;
				}
d5819 1
a5819 1
					retval = mw.Invoke(obj, args, false, callerID);
d6217 1
a6217 1
					return mw.Invoke(null, args, false, null);
a6305 47
		private sealed class SerializationConstructorAccessorImpl : srConstructorAccessor
		{
			private Type type;
			private MethodWrapper constructor;

			internal SerializationConstructorAccessorImpl(jlrConstructor constructorToCall, jlClass classToInstantiate)
			{
				constructor = MethodWrapper.FromMethodOrConstructor(constructorToCall);
				try
				{
					TypeWrapper wrapper = TypeWrapper.FromClass(classToInstantiate);
					wrapper.Finish();
					type = wrapper.TypeAsBaseType;
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
			}

			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
			{
				// if we're trying to deserialize a string as a TC_OBJECT, just return an emtpy string (Sun does the same)
				if (type == typeof(string))
				{
					return "";
				}
				args = ConvertArgs(constructor.GetParameters(), args);
				try
				{
					object obj = FormatterServices.GetUninitializedObject(type);
					constructor.Invoke(obj, args, false, null);
					return obj;
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				catch (MethodAccessException x)
				{
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
				}
			}
		}

d6316 4
a6363 44
			private object getImpl(object obj)
			{
				// if the field is an interface field, we must explicitly run <clinit>,
				// because .NET reflection doesn't
				if (runInit)
				{
					fw.DeclaringType.RunClassInit();
					runInit = false;
				}
				if (!fw.IsStatic && !fw.DeclaringType.IsInstance(obj))
				{
					if (obj == null)
					{
						throw new jlNullPointerException();
					}
					throw new jlIllegalArgumentException();
				}
				return fw.GetValue(obj);
			}

			private void setImpl(object obj, object value)
			{
				// if the field is an interface field, we must explicitly run <clinit>,
				// because .NET reflection doesn't
				if (runInit)
				{
					fw.DeclaringType.RunClassInit();
					runInit = false;
				}
				if (isFinal)
				{
					throw new jlIllegalAccessException();
				}
				if (!fw.IsStatic && !fw.DeclaringType.IsInstance(obj))
				{
					if (obj == null)
					{
						throw new jlNullPointerException();
					}
					throw new jlIllegalArgumentException();
				}
				fw.SetValue(obj, value);
			}

d6447 1
a6447 1
			private class ObjectField : FieldAccessorImplBase
a6455 14

				public override object get(object obj)
				{
					return getImpl(obj);
				}

				public override void set(object obj, object value)
				{
					if (value != null && !fieldType.isInstance(value))
					{
						throw new jlIllegalArgumentException();
					}
					setImpl(obj, value);
				}
a6464 5
				public override byte getByte(object obj)
				{
					return (byte)getImpl(obj);
				}

a6502 5

				public override void setByte(object obj, byte b)
				{
					setImpl(obj, b);
				}
a6511 5
				public override bool getBoolean(object obj)
				{
					return (bool)getImpl(obj);
				}

a6524 5

				public override void setBoolean(object obj, bool b)
				{
					setImpl(obj, b);
				}
a6533 5
				public override char getChar(object obj)
				{
					return (char)getImpl(obj);
				}

a6565 5

				public override void setChar(object obj, char c)
				{
					setImpl(obj, c);
				}
a6574 5
				public override short getShort(object obj)
				{
					return (short)getImpl(obj);
				}

a6612 5

				public override void setShort(object obj, short s)
				{
					setImpl(obj, s);
				}
a6621 5
				public override int getInt(object obj)
				{
					return (int)getImpl(obj);
				}

a6667 5

				public override void setInt(object obj, int i)
				{
					setImpl(obj, i);
				}
a6676 5
				public override float getFloat(object obj)
				{
					return (float)getImpl(obj);
				}

a6724 5

				public override void setFloat(object obj, float f)
				{
					setImpl(obj, f);
				}
a6733 5
				public override long getLong(object obj)
				{
					return (long)getImpl(obj);
				}

a6748 5
				public override void setLong(object obj, long l)
				{
					setImpl(obj, l);
				}

a6789 5
				public override double getDouble(object obj)
				{
					return (double)getImpl(obj);
				}

a6838 5

				public override void setDouble(object obj, double d)
				{
					setImpl(obj, d);
				}
d7342 1
a7342 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastByteFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new ByteField(field, overrideAccessCheck);
						}
d7346 1
a7346 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastBooleanFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new BooleanField(field, overrideAccessCheck);
						}
d7350 1
a7350 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastCharFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new CharField(field, overrideAccessCheck);
						}
d7354 1
a7354 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastShortFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new ShortField(field, overrideAccessCheck);
						}
d7358 1
a7358 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastIntegerFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new IntField(field, overrideAccessCheck);
						}
d7362 1
a7362 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastFloatFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new FloatField(field, overrideAccessCheck);
						}
d7366 1
a7366 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastLongFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new LongField(field, overrideAccessCheck);
						}
d7370 1
a7370 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastDoubleFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new DoubleField(field, overrideAccessCheck);
						}
d7376 1
a7376 8
					if (DynamicMethodSupport.Enabled)
					{
						return new FastObjectFieldAccessor(field, overrideAccessCheck);
					}
					else
					{
						return new ObjectField(field, overrideAccessCheck);
					}
d7397 2
a7398 1
			if (DynamicMethodSupport.Enabled)
d7400 5
a7404 6
				MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(method);
				TypeWrapper tw = TypeWrapper.FromClass(m.getDeclaringClass());
				if (!mw.IsDynamicOnly && !tw.IsRemapped)
				{
					return new FastMethodAccessorImpl(m, false);
				}
a7405 1
			return new MethodAccessorImpl(m);
d7415 2
a7416 2
			if (DynamicMethodSupport.Enabled
				&& !MethodWrapper.FromMethodOrConstructor(constructor).IsDynamicOnly)
d7418 1
a7418 1
				return new FastConstructorAccessorImpl(cons);
d7422 1
a7422 1
				return new ConstructorAccessorImpl(cons);
d7433 1
a7433 10
			if (DynamicMethodSupport.Enabled
				&& cons.getParameterTypes().Length == 0
				&& !MethodWrapper.FromMethodOrConstructor(constructorToCall).IsDynamicOnly)
			{
				return new FastSerializationConstructorAccessorImpl(cons, (jlClass)classToInstantiate);
			}
			else
			{
				return new SerializationConstructorAccessorImpl(cons, (jlClass)classToInstantiate);
			}
@


1.104
log
@Generified all collections.
@
text
@d5862 1
a5862 1
		private sealed class FastMethodAccessorImpl : srMethodAccessor
d5930 1
a5930 1
			internal FastMethodAccessorImpl(jlrMethod method)
d6021 1
a6021 1
				if (mw.IsStatic)
d7675 1
a7675 1
					return new FastMethodAccessorImpl(m);
@


1.103
log
@- Removed Mono workarounds that are no longer needed with Mono 2.0
- Fixed ikvmc build error introduced in previous patch.
@
text
@a24 1
using System.Collections;
d3309 1
a3309 1
				foreach (DictionaryEntry de in Environment.GetEnvironmentVariables())
@


1.102
log
@- Added ghost array tagging to be able to report the instantiated class (instead of object[] which is allocated instead).
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
@
text
@d126 1
a126 2
	// MONOBUG as of Mono 1.2.5.1, DynamicMethod is too broken to be used
	internal static readonly bool Enabled = IsFullTrust && Type.GetType("Mono.Runtime") == null;
@


1.101
log
@Jar meta entries are case insensitive.
@
text
@d2507 6
a2512 1
						return SystemArray.CreateInstance(wrapper.TypeAsArrayType, length);
d2538 6
a2543 1
						return IKVM.Runtime.ByteCodeHelper.multianewarray(wrapper.TypeAsArrayType.TypeHandle, dimensions);
@


1.100
log
@- Renamed ClassLoader.NIL_CLASSLOADER to ClassLoader.DUMMY.
- Removed unused ClassLoader.registerNatives().
- Removed unnecessary field initializers in ClassLoader.
- Moved necessary field initializers in ClassLoader to constructor.
- Changed Thread to make use of ClassLoader.DUMMY, instead of having an extra field to keep track of contextClassLoader status.
@
text
@d5019 1
a5019 1
						if (entry.getName().StartsWith("META-INF/"))
@


1.99
log
@- Renamed CountingILGenerator to CodeEmitter.
- Renamed CountingLabel to CodeEmitterLabel.
@
text
@a3068 4
			public static void registerNatives()
			{
			}

@


1.98
log
@Marked all static classes as static.
@
text
@d707 4
a710 4
						CountingILGenerator ilgenObjGetter = dmObjGetter.GetILGenerator();
						CountingILGenerator ilgenPrimGetter = dmPrimGetter.GetILGenerator();
						CountingILGenerator ilgenObjSetter = dmObjSetter.GetILGenerator();
						CountingILGenerator ilgenPrimSetter = dmPrimSetter.GetILGenerator();
d5941 1
a5941 1
				CountingILGenerator ilgen = dm.GetILGenerator();
d5951 1
a5951 1
				CountingLabel argsLengthOK = ilgen.DefineLabel();
d6045 1
a6045 1
			private static void Expand(CountingILGenerator ilgen, TypeWrapper type)
d6061 1
a6061 1
			internal static void EmitUnboxArg(CountingILGenerator ilgen, TypeWrapper type)
d6086 1
a6086 1
					CountingLabel next = ilgen.DefineLabel();
d6091 1
a6091 1
					CountingLabel done = ilgen.DefineLabel();
d6179 1
a6179 1
			private static void BoxReturnValue(CountingILGenerator ilgen, TypeWrapper type)
d6262 1
a6262 1
				CountingILGenerator ilgen = dm.GetILGenerator();
d6266 1
a6266 1
				CountingLabel argsLengthOK = ilgen.DefineLabel();
d6401 1
a6401 1
				CountingILGenerator ilgen = dm.GetILGenerator();
d7061 1
a7061 1
				CountingILGenerator ilgen = dm.GetILGenerator();
d7100 1
a7100 1
				CountingILGenerator ilgen = dm.GetILGenerator();
@


1.97
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@d124 1
a124 1
sealed class DynamicMethodSupport
d888 1
a888 1
		sealed class VirtualFileSystem
@


1.96
log
@Restructured code to remove (mcs) compiler warnings.
@
text
@d5823 1
a5823 1
			public object invoke(object obj, object[] args)
d5843 1
a5843 1
					retval = mw.Invoke(obj, args, false);
d5877 1
a5877 1
			private delegate object Invoker(object obj, object[] args);
d5917 1
a5917 1
				internal object invoke(object obj, object[] args)
d5922 1
a5922 1
					return invoker(obj, args);
d5935 1
a5935 1
					dm = new DynamicMethod("__<Invoker>", MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, typeof(object), new Type[] { typeof(object), typeof(object[]) }, mw.DeclaringType.TypeAsTBD.Module, true);
d5939 1
a5939 1
					dm = new DynamicMethod("__<Invoker>", typeof(object), new Type[] { typeof(object), typeof(object[]) }, mw.DeclaringType.TypeAsTBD);
d6013 4
d6220 1
a6220 1
			public object invoke(object obj, object[] args)
d6222 1
a6222 1
				return invoker(obj, args);
d6241 1
a6241 1
					return mw.Invoke(null, args, false);
d6362 1
a6362 1
					constructor.Invoke(obj, args, false);
@


1.95
log
@- Use new more efficient float/double to/from int/long bits converters.
- Forward IOHelper.WriteDouble/WriteFloat to java.io.Bits to remove the need to worry about normalizing NaNs or not.
@
text
@a1280 32
			private static System.IO.FileInfo GetFileInfo(string path)
			{
#if FIRST_PASS
				return null;
#else
				try
				{
					return new System.IO.FileInfo(path);
				}
				catch(System.Security.SecurityException x1)
				{
					throw new jiIOException(x1.Message);
				}
				catch(System.ArgumentException x2)
				{
					throw new jiIOException(x2.Message);
				}
				catch(System.UnauthorizedAccessException x3)
				{
					throw new jiIOException(x3.Message);
				}
				catch(System.IO.IOException x4)
				{
					throw new jiIOException(x4.Message);
				}
				catch(System.NotSupportedException x5)
				{
					throw new jiIOException(x5.Message);
				}
#endif
			}

d4442 1
a4442 1
				int bogus = 0;
@


1.94
log
@Fix deserialization of double arrays.
@
text
@d476 2
a477 1
				while (nfloats-- > 0)
d479 5
a483 2
					Buffer.BlockCopy(BitConverter.GetBytes(src[srcpos++]), 0, dst, dstpos, 4);
					dstpos += 4;
d489 2
a490 1
				while (ndoubles-- > 0)
d492 9
a500 2
					Buffer.BlockCopy(BitConverter.GetBytes(src[srcpos++]), 0, dst, dstpos, 8);
					dstpos += 8;
d540 1
a540 1
				WriteInt(buf, offset, jlFloat.floatToIntBits(value));
d553 1
a553 1
				WriteLong(buf, offset, jlDouble.doubleToLongBits(value));
d3291 2
a3292 1
				return BitConverter.DoubleToInt64Bits(value);
d3297 2
a3298 1
				return BitConverter.Int64BitsToDouble(bits);
d3306 2
a3307 1
				return BitConverter.ToInt32(BitConverter.GetBytes(value), 0);
d3312 2
a3313 1
				return BitConverter.ToSingle(BitConverter.GetBytes(bits), 0);
@


1.93
log
@Moved java.lang.Thread "native" methods to Java.
@
text
@d436 1
a436 1
					srcpos += 4;
@


1.92
log
@Moved System.nanoTime() to Java.
@
text
@a3611 5
			[ThreadStatic]
			private static VMThread vmThread;
			[ThreadStatic]
			private static object cleanup;
			private static int nonDaemonCount;
a3612 209
			// we don't really use the Thread.threadStatus field, but we have to set it to a non-zero value,
			// so we use RUNNABLE (which the HotSpot also uses) and the value was taken from the
			// ThreadStatus enum in /openjdk/hotspot/src/share/vm/memory/javaClasses.hpp
			private const int JVMTI_THREAD_STATE_ALIVE = 0x0001;
			private const int JVMTI_THREAD_STATE_RUNNABLE = 0x0004;
			private const int JVMTI_THREAD_STATE_TERMINATED = 0x0002;
			private const int NEW = 0;
			private const int RUNNABLE = JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE;
			private const int TERMINATED = JVMTI_THREAD_STATE_TERMINATED;

			// TODO move all these fields to jlThread and remove VMThread
			internal sealed class VMThread
			{
				internal readonly SystemThreadingThread nativeThread;
#if !FIRST_PASS
				internal jlThread javaThread;
#endif
				internal Exception stillborn;
				internal bool running;
				private bool interruptPending;
				private volatile bool nativeInterruptPending;
				private volatile bool interruptableWait;
				private bool timedWait;

#if !FIRST_PASS
				internal VMThread(jlThread javaThread, SystemThreadingThread nativeThread)
				{
					this.javaThread = javaThread;
					this.nativeThread = nativeThread;
				}

				internal VMThread(jlThread javaThread)
				{
					this.javaThread = javaThread;
					nativeThread = new SystemThreadingThread(new ThreadStart(ThreadProc));
				}
#endif

				internal bool IsInterruptPending(bool clearInterrupt)
				{
					lock (this)
					{
						bool b = interruptPending;
						if (clearInterrupt)
						{
							interruptPending = false;
						}
						return b;
					}
				}

#if !FIRST_PASS
				internal jlThread.State GetState()
				{
					switch (GetThreadStatus(javaThread))
					{
						case NEW:
							return jlThread.State.NEW;
						case TERMINATED:
							return jlThread.State.TERMINATED;
					}
					lock (this)
					{
						if (interruptableWait)
						{
							// NOTE if objectWait has satisfied the wait condition (or has been interrupted or has timed-out),
							// it can be blocking on the re-acquire of the monitor, but we have no way of detecting that.
							return timedWait ? jlThread.State.TIMED_WAITING : jlThread.State.WAITING;
						}
						if ((nativeThread.ThreadState & ThreadState.WaitSleepJoin) != 0)
						{
							return jlThread.State.BLOCKED;
						}
					}
					return jlThread.State.RUNNABLE;
				}
#endif

				internal void EnterInterruptableWait(bool timedWait)
				{
#if !FIRST_PASS
					lock (this)
					{
						if (interruptPending)
						{
							interruptPending = false;
							throw new jlInterruptedException();
						}
						interruptableWait = true;
						this.timedWait = timedWait;
					}
#endif
				}

				internal void LeaveInterruptableWait()
				{
#if !FIRST_PASS
					SystemThreadingThreadInterruptedException dotnetInterrupt = null;
					interruptableWait = false;
					for (; ; )
					{
						try
						{
							lock (this)
							{
								if (nativeInterruptPending)
								{
									nativeInterruptPending = false;
									// HACK if there is a pending Interrupt (on the .NET thread), we need to consume that
									// (if there was no contention on "lock (this)" above the interrupted state isn't checked) 
									try
									{
										SystemThreadingThread t = SystemThreadingThread.CurrentThread;
										// the obvious thing to do would be t.Interrupt() / t.Join(),
										// but for some reason that causes a regression in JSR166TestCase (probably a CLR bug)
										// so we waste a time slice... sigh.
										t.Join(1);
									}
									catch (SystemThreadingThreadInterruptedException)
									{
									}
								}
								if (interruptPending)
								{
									interruptPending = false;
									throw new jlInterruptedException();
								}
							}
							break;
						}
						catch (SystemThreadingThreadInterruptedException x)
						{
							dotnetInterrupt = x;
							nativeInterruptPending = false;
						}
					}
					if (dotnetInterrupt != null)
					{
						throw dotnetInterrupt;
					}
#endif
				}

				internal void Interrupt()
				{
					lock (this)
					{
						if (!interruptPending)
						{
							interruptPending = true;
							if (interruptableWait)
							{
								nativeInterruptPending = true;
								nativeThread.Interrupt();
							}
						}
					}
				}

				internal void ThreadProc()
				{
#if !FIRST_PASS
					vmThread = this;
					try
					{
						lock (javaThread)
						{
							running = true;
							Exception x = stillborn;
							if (x != null)
							{
								stillborn = null;
								throw x;
							}
						}
						javaThread.run();
					}
					catch (Exception x)
					{
						try
						{
							javaThread.getUncaughtExceptionHandler().uncaughtException(javaThread, irUtil.mapException(x));
						}
						catch
						{
						}
					}
					finally
					{
						DetachThread();
					}
#endif
				}
			}

			private sealed class Cleanup
			{
				private object javaThread;

				internal Cleanup(object javaThread)
				{
					this.javaThread = javaThread;
				}

				~Cleanup()
				{
					SetThreadStatus(javaThread, TERMINATED);
				}
			}
d3621 1
a3621 420
			public static void registerNatives()
			{
			}

			public static object currentThread()
			{
#if FIRST_PASS
				return null;
#else
				return CurrentVMThread().javaThread;
#endif
			}

			internal static int GetThreadStatus(object javaThread)
			{
#if FIRST_PASS
				return 0;
#else
				return ((jlThread)javaThread)._threadStatus();
#endif
			}

			internal static void SetThreadStatus(object javaThread, int value)
			{
#if !FIRST_PASS
				if (value == TERMINATED)
				{
					// NOTE there might be a race condition here (when the thread's Cleanup object
					// is finalized during AppDomain shutdown while the thread is also exiting on its own),
					// but that doesn't matter because Thread.exit() is safe to call multiple times.
					((jlThread)javaThread)._exit();
				}
				((jlThread)javaThread)._threadStatus(value);
				if (value == TERMINATED)
				{
					// NOTE locking javaThread here isn't ideal, because we might be invoked from
					// the Cleanup object's finalizer and some user code might own the lock and hence
					// block the finalizer thread.
					lock (javaThread)
					{
						Monitor.PulseAll(javaThread);
					}
					if (!((jlThread)javaThread).isDaemon())
					{
						Interlocked.Decrement(ref nonDaemonCount);
					}
				}
#endif
			}

			private static VMThread CurrentVMThread()
			{
				VMThread t = vmThread;
				if (t == null)
				{
					t = AttachThread(null);
				}
				return t;
			}

			private static VMThread GetVMThread(object threadObj)
			{
#if FIRST_PASS
				return null;
#else
				return ((jlThread)threadObj).vmThread;
#endif
			}

			private static VMThread AttachThread(object threadGroup)
			{
#if FIRST_PASS
				return null;
#else
				if (threadGroup == null)
				{
					threadGroup = mainThreadGroup;
				}
				VMThread t = new VMThread(null, SystemThreadingThread.CurrentThread);
				t.running = true;
				vmThread = t;
				jlThread thread = new jlThread((jlThreadGroup)threadGroup);
				thread.vmThread = t;
				t.javaThread = thread;
				cleanup = new Cleanup(thread);
				if (!thread.isDaemon())
				{
					Interlocked.Increment(ref nonDaemonCount);
				}
				return t;
#endif
			}

#if !FIRST_PASS
			private static SystemThreadingThreadPriority MapJavaPriorityToNative(int priority)
			{
				// TODO consider supporting -XX:JavaPriorityX_To_OSPriority settings
				if (priority == jlThread.MIN_PRIORITY)
				{
					return SystemThreadingThreadPriority.Lowest;
				}
				else if (priority > jlThread.MIN_PRIORITY && priority < jlThread.NORM_PRIORITY)
				{
					return SystemThreadingThreadPriority.BelowNormal;
				}
				else if (priority == jlThread.NORM_PRIORITY)
				{
					return SystemThreadingThreadPriority.Normal;
				}
				else if (priority > jlThread.NORM_PRIORITY && priority < jlThread.MAX_PRIORITY)
				{
					return SystemThreadingThreadPriority.AboveNormal;
				}
				else if (priority == jlThread.MAX_PRIORITY)
				{
					return SystemThreadingThreadPriority.Highest;
				}
				else
				{
					// can't happen
					return SystemThreadingThreadPriority.Normal;
				}
			}
#endif

			public static void yield()
			{
				SystemThreadingThread.Sleep(0);
			}

			public static void sleep(long millis)
			{
#if !FIRST_PASS
				if (millis < 0)
				{
					throw new jlIllegalArgumentException("timeout value is negative");
				}
				VMThread t = CurrentVMThread();
				t.EnterInterruptableWait(true);
				try
				{
					for (long iter = millis / int.MaxValue; iter != 0; iter--)
					{
						SystemThreadingThread.Sleep(int.MaxValue);
					}
					SystemThreadingThread.Sleep((int)(millis % int.MaxValue));
				}
				catch (SystemThreadingThreadInterruptedException)
				{
				}
				finally
				{
					t.LeaveInterruptableWait();
				}
#endif
			}

			public static void start0(object thisThread)
			{
#if !FIRST_PASS
				// TODO on NET 2.0 set the stack size
				VMThread t = new VMThread((jlThread)thisThread);
				((jlThread)thisThread).vmThread = t;
				t.nativeThread.Name = t.javaThread.getName();
				t.nativeThread.IsBackground = t.javaThread.isDaemon();
				t.nativeThread.Priority = MapJavaPriorityToNative(t.javaThread.getPriority());
				string apartment = ((string)jsAccessController.doPrivileged(new ssaGetPropertyAction("ikvm.apartmentstate", ""))).ToLower();
				if (apartment == "mta")
				{
					t.nativeThread.SetApartmentState(ApartmentState.MTA);
				}
				else if (apartment == "sta")
				{
					t.nativeThread.SetApartmentState(ApartmentState.STA);
				}
				SetThreadStatus(thisThread, RUNNABLE);
				t.nativeThread.Start();
				if (!t.javaThread.isDaemon())
				{
					Interlocked.Increment(ref nonDaemonCount);
				}
#endif
			}

			public static bool isInterrupted(object thisThread, bool clearInterrupted)
			{
				VMThread t = GetVMThread(thisThread);
				return t != null && t.IsInterruptPending(clearInterrupted);
			}

			public static bool isAlive(object thisThread)
			{
				int status = GetThreadStatus(thisThread);
				return status != NEW && status != TERMINATED;
			}

			public static int countStackFrames(object thisThread)
			{
				return 0;
			}

			public static bool holdsLock(object obj)
			{
#if FIRST_PASS
				return false;
#else
				if (obj == null)
				{
					throw new jlNullPointerException();
				}
				try
				{
					// The 1.5 memory model (JSR133) explicitly allows spurious wake-ups from Object.wait,
					// so we abuse Pulse to check if we own the monitor.
					Monitor.Pulse(obj);
					return true;
				}
				catch (SynchronizationLockException)
				{
					return false;
				}
#endif
			}

			public static object[][] dumpThreads(object[] threads)
			{
#if FIRST_PASS
				return null;
#else
				jlStackTraceElement[][] stacks = new jlStackTraceElement[threads.Length][];
				for (int i = 0; i < threads.Length; i++)
				{
					VMThread t = GetVMThread(threads[i]);
					if (t == null)
					{
						stacks[i] = new jlStackTraceElement[0];
					}
					else
					{
						try
						{
							bool suspended = false;
							if ((t.nativeThread.ThreadState & ThreadState.Suspended) == 0 && t.nativeThread != SystemThreadingThread.CurrentThread)
							{
								SuspendThread(t.nativeThread);
							}
							StackTrace stack;
							try
							{
								stack = new StackTrace(t.nativeThread, true);
							}
							finally
							{
								if (suspended)
								{
									ResumeThread(t.nativeThread);
								}
							}
							stacks[i] = global::java.lang.ExceptionHelper.getStackTrace(stack, int.MaxValue);
						}
						catch (ThreadStateException)
						{
							stacks[i] = new jlStackTraceElement[0];
						}
					}
				}
				return stacks;
#endif
			}

			private static void SuspendThread(SystemThreadingThread thread)
			{
#pragma warning disable 618
				// Thread.Suspend() is obsolete, we know that. Warning disabled.
				thread.Suspend();
#pragma warning restore
			}

			private static void ResumeThread(SystemThreadingThread thread)
			{
#pragma warning disable 618
				// Thread.Resume() is obsolete, we know that. Warning disabled.
				thread.Resume();
#pragma warning restore
			}

#if !FIRST_PASS
			private sealed class GetThreads : jsPrivilegedAction
			{
				public object run()
				{
					jlThreadGroup root = (jlThreadGroup)mainThreadGroup;
					for (; ; )
					{
						jlThread[] threads = new jlThread[root.activeCount()];
						if (root.enumerate(threads) == threads.Length)
						{
							return threads;
						}
					}
				}
			}
#endif

			public static object[] getThreads()
			{
#if FIRST_PASS
				return null;
#else
				return (object[])jsAccessController.doPrivileged(new GetThreads());
#endif
			}

			public static void setPriority0(object thisThread, int newPriority)
			{
#if !FIRST_PASS
				lock (thisThread)
				{
					VMThread t = GetVMThread(thisThread);
					if (t != null)
					{
						t.nativeThread.Priority = MapJavaPriorityToNative(newPriority);
					}
				}
#endif
			}

			public static void stop0(object thisThread, object o)
			{
#if !FIRST_PASS
				VMThread t = GetVMThread(thisThread);
				if (t.running)
				{
					// NOTE we allow ThreadDeath (and its subclasses) to be thrown on every thread, but any
					// other exception is ignored, except if we're throwing it on the current Thread. This
					// is done to allow exception handlers to be type specific, otherwise every exception
					// handler would have to catch ThreadAbortException and look inside it to see if it
					// contains the real exception that we wish to handle.
					// I hope we can get away with this behavior, because Thread.stop() is deprecated
					// anyway. Note that we do allow arbitrary exceptions to be thrown on the current
					// thread, since this is harmless (because they aren't wrapped) and also because it
					// provides some real value, because it is one of the ways you can throw arbitrary checked
					// exceptions from Java.
					if (t == vmThread)
					{
						throw (Exception)o;
					}
					else if (o is jlThreadDeath)
					{
						try
						{
							t.nativeThread.Abort(o);
						}
						catch (ThreadStateException)
						{
							// .NET 2.0 throws a ThreadStateException if the target thread is currently suspended
							// (but it does record the Abort request)
						}
						try
						{
							ThreadState suspend = ThreadState.Suspended | ThreadState.SuspendRequested;
							while ((t.nativeThread.ThreadState & suspend) != 0)
							{
								ResumeThread(t.nativeThread);
							}
						}
						catch (ThreadStateException)
						{
						}
					}
				}
				else
				{
					t.stillborn = (Exception)o;
				}
#endif
			}

			public static void suspend0(object thisThread)
			{
				VMThread t = GetVMThread(thisThread);
				if (t != null)
				{
					try
					{
						SuspendThread(t.nativeThread);
					}
					catch (ThreadStateException)
					{
					}
				}
			}

			public static void resume0(object thisThread)
			{
				VMThread t = GetVMThread(thisThread);
				if (t != null)
				{
					try
					{
						ResumeThread(t.nativeThread);
					}
					catch (ThreadStateException)
					{
					}
				}
			}

			public static void interrupt0(object thisThread)
			{
				// if the thread hasn't been started yet, the interrupt is ignored
				// (like on the reference implementation)
				VMThread t = GetVMThread(thisThread);
				if (t != null)
				{
					t.Interrupt();
				}
			}

			public static object getState(object thisThread)
d3623 1
a3623 6
#if FIRST_PASS
				return null;
#else
				VMThread t = GetVMThread(thisThread);
				return t == null ? jlThread.State.NEW : t.GetState();
#endif
d3631 1
a3631 1
				while (Interlocked.CompareExchange(ref nonDaemonCount, 0, 0) > count)
d3642 1
a3642 10
				AttachThread(threadGroup);
#endif
			}

			// this is called from JNI and from VMThread.ThreadProc
			internal static void DetachThread()
			{
				SetThreadStatus(currentThread(), TERMINATED);
				vmThread = null;
				if (cleanup != null)
d3644 1
a3644 2
					GC.SuppressFinalize(cleanup);
					cleanup = null;
d3646 1
a3646 14
			}

			public static void objectWait(object o, long timeout, int nanos)
			{
#if !FIRST_PASS
				if (o == null)
				{
					throw new jlNullPointerException();
				}
				if (timeout < 0)
				{
					throw new jlIllegalArgumentException("timeout value is negative");
				}
				if (nanos < 0 || nanos > 999999)
d3648 1
a3648 25
					throw new jlIllegalArgumentException("nanosecond timeout value out of range");
				}
				if (nanos >= 500000 || (nanos != 0 && timeout == 0))
				{
					timeout++;
				}
				VMThread t = CurrentVMThread();
				t.EnterInterruptableWait(timeout != 0);
				try
				{
					if (timeout == 0 || timeout > 922337203685476L)
					{
						Monitor.Wait(o);
					}
					else
					{
						Monitor.Wait(o, new TimeSpan(timeout * 10000));
					}
				}
				catch (SystemThreadingThreadInterruptedException)
				{
				}
				finally
				{
					t.LeaveInterruptableWait();
d3656 1
a3656 1
			// this method has the wrong name, it is only called by ikvm.runtime.Startup.exitMainThread()
d3659 3
a3661 1
				Thread.DetachThread();
@


1.91
log
@Moved a couple of java.lang.System native methods to the Java side.
@
text
@a3607 8

			public static long nanoTime()
			{
				const long NANOS_PER_SEC = 1000000000;
				double current = global::System.Diagnostics.Stopwatch.GetTimestamp();
				double freq = global::System.Diagnostics.Stopwatch.Frequency;
				return (long)((current / freq) * NANOS_PER_SEC);
			}
@


1.90
log
@Use new .NET 2.0 API to get processor count.
@
text
@d1028 8
a1035 8
				dict[RootPath + "bin" + sep + IKVM.NativeCode.java.lang.System.mapLibraryName("zip")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + IKVM.NativeCode.java.lang.System.mapLibraryName("awt")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + IKVM.NativeCode.java.lang.System.mapLibraryName("rmi")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + IKVM.NativeCode.java.lang.System.mapLibraryName("w2k_lsa_auth")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + IKVM.NativeCode.java.lang.System.mapLibraryName("jaas_nt")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + IKVM.NativeCode.java.lang.System.mapLibraryName("jaas_unix")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + IKVM.NativeCode.java.lang.System.mapLibraryName("unpack")] = new VfsDummyEntry(false);
				dict[RootPath + "bin" + sep + IKVM.NativeCode.java.lang.System.mapLibraryName("net")] = new VfsDummyEntry(false);
d3334 8
a3608 12
			// FXBUG this is implemented by a non-virtual call to System.Object.GetHashCode (in map.xml),
			// because RuntimeHelpers.GetHashCode is broken (in v1.x) when called in a secondary AppDomain.
			// See http://weblog.ikvm.net/PermaLink.aspx?guid=c2442bc8-7b48-4570-b082-82649cc347dc
			//
			// public static int identityHashCode(object obj)

			public static long currentTimeMillis()
			{
				const long january_1st_1970 = 62135596800000L;
				return DateTime.UtcNow.Ticks / 10000L - january_1st_1970;
			}

a3615 33

			public static string mapLibraryName(string libname)
			{
#if FIRST_PASS
				return null;
#else
				if (global::ikvm.@@internal.Util.WINDOWS)
				{
					return libname + ".dll";
				}
				else if (global::ikvm.@@internal.Util.MACOSX)
				{
					return "lib" + libname + ".jnilib";
				}
				else
				{
					return "lib" + libname + ".so";
				}
#endif
			}

			public static object initProperties(object props)
			{
#if !FIRST_PASS
				juProperties p = (juProperties)props;
				p.put("openjdk.version", "b13");
				p.put("gnu.classpath.version", "0.95");
				p.put("java.home", io.VirtualFileSystem.RootPath.Substring(0, io.VirtualFileSystem.RootPath.Length - 1));
				p.put("sun.boot.library.path", io.VirtualFileSystem.RootPath + "bin");
				global::gnu.classpath.VMSystemProperties.initOpenJDK(p);
#endif
				return props;
			}
@


1.89
log
@Refactored class library initialization.
@
text
@d3338 1
a3338 15
				string s = JVM.SafeGetEnvironmentVariable("NUMBER_OF_PROCESSORS");
				if (s != null)
				{
					try
					{
						return Int32.Parse(s, NumberFormatInfo.InvariantInfo);
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
				}
				return 1;
@


1.88
log
@Added support for filenames/paths with colons in them (on Win32) to Win32FileSystem.Canonicalize().
@
text
@a3654 5
			public static void registerNatives()
			{
				Thread.Bootstrap();
			}

a3663 14

				// HACK this is an extremely gross hack, here we explicitly call the class initializer of a bunch of
				// classes while their class initializers may already be running. All of their class initializers are
				// idempotent (or so we hope).
				// Normally this wouldn't be necessary, but for some scenarios the initialization order may be such
				// that the code following us will expect the class initializer of the following classes to already have
				// run to completion, but if one of these classes was responsible for triggering bootstrap, a second
				// invocation wouldn't normally result in the class initializer running again, by running them
				// explicitly (and thus possibly twice), we make sure that subsequent code won't see an unexpected
				// state.
				jiFile._reinitHack();
				jlrAccessibleObject._reinitHack();
				jlrModifier._reinitHack();
				jiConsole._reinitHack();
d3890 1
a3890 25
				jlThreadGroup systemThreadGroup = jlThreadGroup.createRootGroup();
				mainThreadGroup = new jlThreadGroup(systemThreadGroup, "main");
				AttachThread(null, false, null);
				jlSystem.runInit();
				// make sure the Launcher singleton is created on the main thread and allow it to install the security manager
				smLauncher.getLauncher();
				if (jlClassLoader.getSystemClassLoader() == null)
				{
					// HACK because of bootstrap issues (Launcher instantiates a URL and GNU Classpath's URL calls getSystemClassLoader) we have
					// to set clear the sclSet flag here, to make sure the system class loader is constructed next time getSystemClassLoader is called
					jlClassLoader.clearSclSet();
				}
				try
				{
					// AppDomain.ProcessExit has a LinkDemand, so we have to have a separate method
					RegisterShutdownHook();
				}
				catch (global::System.Security.SecurityException)
				{
				}
			}

			private static void RegisterShutdownHook()
			{
				AppDomain.CurrentDomain.ProcessExit += delegate { global::java.lang.Shutdown.shutdown(); };
a3892 4
			internal static void Bootstrap()
			{
				// call this method to trigger the bootstrap (in the static initializer)
			}
d3949 1
a3949 1
					t = AttachThread(null, true, null);
d3963 1
a3963 31
			internal static object CurrentThreadFromInit(object newThread)
			{
#if FIRST_PASS
				return null;
#else
				VMThread t = CurrentVMThread();
				jlThread thread = t.javaThread;
				if (thread == null)
				{
					thread = (jlThread)newThread;
					t.javaThread = thread;
					thread.vmThread = t;
					// priority must be set before running the rest of Thread.init(),
					// otherwise it will try to "copy" an illegal priority.
					thread._priority(MapNativePriorityToJava(t.nativeThread.Priority));
				}
				return thread;
#endif
			}

#if !FIRST_PASS
			sealed class GetSystemClassLoaderAction : global::java.security.PrivilegedAction
			{
				public object run()
				{
					return global::java.lang.ClassLoader.getSystemClassLoader();
				}
			}
#endif

			private static VMThread AttachThread(string name, bool addToGroup, object threadGroup)
a3972 5
				if (name == null)
				{
					// inherit the .NET name of the thread (if it has a name)
					name = t.nativeThread.Name;
				}
d3975 3
a3977 9
				jlThread thread;
				if (name != null)
				{
					thread = new jlThread((jlThreadGroup)threadGroup, name);
				}
				else
				{
					thread = new jlThread((jlThreadGroup)threadGroup, (jlRunnable)null);
				}
d3979 1
a3979 7
				thread._priority(MapNativePriorityToJava(t.nativeThread.Priority));
				if (addToGroup)
				{
					thread._contextClassLoader((jlClassLoader)jsAccessController.doPrivileged(new GetSystemClassLoaderAction()));
				}
				bool daemon = t.nativeThread.IsBackground;
				if (!daemon)
a3982 6
				thread._deamon(daemon);
				SetThreadStatus(thread, RUNNABLE);
				if (addToGroup)
				{
					((jlThreadGroup)threadGroup).add(thread);
				}
a3987 19
			private static int MapNativePriorityToJava(SystemThreadingThreadPriority priority)
			{
				// TODO consider supporting -XX:JavaPriorityX_To_OSPriority settings
				switch (priority)
				{
					case SystemThreadingThreadPriority.Lowest:
						return jlThread.MIN_PRIORITY;
					case SystemThreadingThreadPriority.BelowNormal:
						return 3;
					default:
					case SystemThreadingThreadPriority.Normal:
						return jlThread.NORM_PRIORITY;
					case SystemThreadingThreadPriority.AboveNormal:
						return 7;
					case SystemThreadingThreadPriority.Highest:
						return jlThread.MAX_PRIORITY;
				}
			}

d4339 1
a4339 1
				AttachThread(null, true, threadGroup);
a5279 1
				IKVM.NativeCode.java.lang.Thread.Bootstrap();
@


1.87
log
@Fixed mapLibraryName to use platform detection instead of os.name property.
@
text
@d1340 3
d1360 5
@


1.86
log
@Set Thread context class loader for threads started from .NET.
@
text
@d3632 1
a3632 9
				// TODO instead of using the System property, we should use
				// a VM level shared variable that contains the os
				// (and that os.name is defined by)
				string osname = jlSystem.getProperty("os.name");
				if (osname == null)
				{
					return libname;
				}
				else if (osname.IndexOf("Windows") >= 0)
d3636 1
a3636 1
				else if (osname == "Mac OS X")
@


1.85
log
@Ripped out annotation/constant pool support that is no longer needed.
@
text
@d4030 10
d4068 4
@


1.84
log
@Changed System.nanoTime() implementation to use Stopwatch.GetTimestamp().
@
text
@a83 1
using srConstantPool = sun.reflect.ConstantPool;
a90 1
using IConstantPoolWriter = ikvm.@@internal.stubgen.StubGenerator.IConstantPoolWriter;
a2555 57
#if !FIRST_PASS
		sealed class ConstantPoolWriter : IConstantPoolWriter
		{
			private ArrayList items = new ArrayList();

			public short AddUtf8(String str)
			{
				return (short)items.Add(str);
			}

			public short AddInt(int i)
			{
				return (short)items.Add(i);
			}

			public short AddLong(long l)
			{
				return (short)items.Add(l);
			}

			public short AddFloat(float f)
			{
				return (short)items.Add(f);
			}

			public short AddDouble(double d)
			{
				return (short)items.Add(d);
			}

			internal string GetUtf8(int index)
			{
				return (string)items[index];
			}

			internal int GetInt(int index)
			{
				return (int)items[index];
			}

			internal long GetLong(int index)
			{
				return (long)items[index];
			}

			internal float GetFloat(int index)
			{
				return (float)items[index];
			}

			internal double GetDouble(int index)
			{
				return (double)items[index];
			}
		}
#endif

a2885 26
#if !FIRST_PASS
			internal static IConstantPoolWriter GetConstantPoolWriter(TypeWrapper wrapper)
			{
				return (IConstantPoolWriter)((srConstantPool)getConstantPool(wrapper.ClassObject))._constantPoolOop();
			}
#endif

			public static object getConstantPool(object thisClass)
			{
#if FIRST_PASS
				return null;
#else
				lock (thisClass)
				{
					object cp = ((jlClass)thisClass).constantPool;
					if (cp == null)
					{
						cp = new srConstantPool();
						((srConstantPool)cp)._constantPoolOop(new ConstantPoolWriter());
						((jlClass)thisClass).constantPool = cp;
					}
					return cp;
				}
#endif
			}

d8620 1
a8620 5
#if FIRST_PASS
			return 0;
#else
			return ((IKVM.NativeCode.java.lang.ConstantPoolWriter)constantPoolOop).GetInt(index);
#endif
d8625 1
a8625 5
#if FIRST_PASS
			return 0;
#else
			return ((IKVM.NativeCode.java.lang.ConstantPoolWriter)constantPoolOop).GetLong(index);
#endif
d8630 1
a8630 5
#if FIRST_PASS
			return 0;
#else
			return ((IKVM.NativeCode.java.lang.ConstantPoolWriter)constantPoolOop).GetFloat(index);
#endif
d8635 1
a8635 5
#if FIRST_PASS
			return 0;
#else
			return ((IKVM.NativeCode.java.lang.ConstantPoolWriter)constantPoolOop).GetDouble(index);
#endif
d8645 1
a8645 5
#if FIRST_PASS
			return null;
#else
			return ((IKVM.NativeCode.java.lang.ConstantPoolWriter)constantPoolOop).GetUtf8(index);
#endif
@


1.83
log
@Replaced notion of DynamicOnly types with Fake types. Fake types are implemented as generic type instances and can have DynamicOnly methods.
@
text
@d3706 4
a3709 3
				// Note that the epoch is undefined, but we use something similar to the JDK
				const long epoch = 632785401332600000L;
				return (DateTime.UtcNow.Ticks - epoch) * 100L;
@


1.82
log
@- Simplified annotation handling.
- Added support to Class.forName() for assembly qualified Java type names.
@
text
@d8611 1
d8613 1
a8613 1
				if (!tw.IsDynamicOnly && !tw.IsRemapped)
d8629 1
a8629 1
				&& !TypeWrapper.FromClass(cons.getDeclaringClass()).IsDynamicOnly)
d8648 1
a8648 2
				&& !TypeWrapper.FromClass(cons.getDeclaringClass()).IsDynamicOnly
				&& !TypeWrapper.FromClass(classToInstantiate).IsDynamicOnly)
@


1.81
log
@- Forked Class, Constructor and Field.
- Made class annotation handling lazy and bypass encode/decode.
@
text
@d2 1
a2 1
  Copyright (C) 2007 Jeroen Frijters
d2638 1
a2638 1
						tw = DotNetTypeWrapper.GetWrapperFromDotNetType(type);
d2912 1
a2912 1
			public static object getDeclaredAnnotationsImpl(object thisClass)
a2916 3
				TypeWrapper wrapper = TypeWrapper.FromClass(thisClass);
				wrapper.Finish();
				object[] objAnn = wrapper.GetDeclaredAnnotations();
d2925 1
d2934 11
d4606 9
d4617 1
a4617 1
				public static byte[] getRawAnnotations(object thisMethod)
d4619 2
a4620 1
					return MethodWrapper.FromMethodOrConstructor(thisMethod).GetRawAnnotations();
d4623 1
a4623 1
				public static byte[] getRawParameterAnnotations(object thisMethod)
d4625 26
a4650 1
					return MethodWrapper.FromMethodOrConstructor(thisMethod).GetRawParameterAnnotations();
d4653 1
a4653 1
				public static byte[] getRawAnnotationDefault(object thisMethod)
d4655 2
a4656 1
					return MethodWrapper.FromMethodOrConstructor(thisMethod).GetRawAnnotationDefault();
@


1.80
log
@Box/unbox ghost references when (de)serializing.
@
text
@d2912 1
a2912 1
			public static byte[] getRawAnnotations(object thisClass)
d2920 2
a2921 1
				if (objAnn == null)
d2923 1
a2923 6
					return null;
				}
				ArrayList ann = new ArrayList();
				foreach (object obj in objAnn)
				{
					if (obj is Annotation)
d2925 5
a2929 1
						ann.Add(obj);
d2932 1
a2932 2
				IConstantPoolWriter cp = (IConstantPoolWriter)((srConstantPool)getConstantPool(thisClass))._constantPoolOop();
				return StubGenerator.writeAnnotations(cp, (Annotation[])ann.ToArray(typeof(Annotation)));
@


1.79
log
@Partial Trust fixes:
- Added accessor methods for "slot" to Method & Constructor.
- Implemented System.setIn0, setOut0, setErr0 in map.xml.
- Hacked sun.misc.SharedSecrets to replace Unsafe.ensureClassInitialize() with direct calls.
- Replaced java.nio.Bits.byteOrder() with simple System.BitConver.IsLittleEndian based implementation.
- Disabled DynamicMethodSupport when running in partial trust.
- Ignore SecurityException in CanonicalizePath.
- Don't trigger load of JNI assembly when "loading" a fake system library.
@
text
@d804 1
d813 1
@


1.78
log
@- Moved some calls to methods with a LinkDemand (that fails in partial trust) to a separate methods.
- Added stuff to map.xml to remove the need for reflection in VM / Library bootstrap.
- Inverted IKVM.Runtime.JNI dependency in stack walking code.
@
text
@d129 17
a145 1
	internal static readonly bool Enabled = Type.GetType("Mono.Runtime") == null;
d1337 3
d3267 1
a3267 5
						object fromClass = thisNativeLibrary.GetType().GetField("fromClass", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(thisNativeLibrary);
						if (IKVM.Runtime.JniHelper.LoadLibrary(name, TypeWrapper.FromClass(fromClass).GetClassLoader()) == 1)
						{
							SetHandle(thisNativeLibrary, -1);
						}
d3272 12
a3733 26
			public static void setIn0(object @@in)
			{
				SetSystemField("in", @@in);
			}

			public static void setOut0(object @@out)
			{
				SetSystemField("out", @@out);
			}

			public static void setErr0(object err)
			{
				SetSystemField("err", err);
			}

			private static void SetSystemField(string field, object obj)
			{
#if !FIRST_PASS
				// MONOBUG due to a bug in mcs we currently prefix the backing fields with __<>
				field = "__<>" + field;
				typeof(jlSystem)
					.GetField(field, BindingFlags.NonPublic | BindingFlags.Static)
					.SetValue(null, obj);
#endif
			}

@


1.77
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@a2595 5
			private static FieldInfo signersField;
			private static FieldInfo pdField;
			private static FieldInfo constantPoolField;
			private static FieldInfo constantPoolOopField;

a2597 6
#if !FIRST_PASS
				signersField = typeof(jlClass).GetField("signers", BindingFlags.Instance | BindingFlags.NonPublic);
				pdField = typeof(jlClass).GetField("pd", BindingFlags.Instance | BindingFlags.NonPublic);
				constantPoolField = typeof(jlClass).GetField("constantPool", BindingFlags.Instance | BindingFlags.NonPublic);
				constantPoolOopField = typeof(srConstantPool).GetField("constantPoolOop", BindingFlags.Instance | BindingFlags.NonPublic);
#endif
d2763 5
a2767 1
				return (object[])signersField.GetValue(thisClass);
d2772 3
a2774 1
				signersField.SetValue(thisClass, signers);
d2824 3
d2832 1
a2832 1
				object pd = pdField.GetValue(wrapper.ClassObject);
d2844 1
d2849 3
a2851 1
				pdField.SetValue(thisClass, pd);
d2911 1
a2911 1
				IConstantPoolWriter cp = (IConstantPoolWriter)constantPoolOopField.GetValue(getConstantPool(thisClass));
d2919 1
a2919 1
				return (IConstantPoolWriter)constantPoolOopField.GetValue(getConstantPool(wrapper.ClassObject));
d2930 1
a2930 1
					object cp = constantPoolField.GetValue(thisClass);
d2934 2
a2935 2
						constantPoolOopField.SetValue(cp, new ConstantPoolWriter());
						constantPoolField.SetValue(thisClass, cp);
d3434 4
d3455 1
a3455 1
						|| type.Assembly == typeof(IKVM.Runtime.JNI).Assembly
d3752 4
a3755 4
				typeof(jiFile).TypeInitializer.Invoke(null, null);
				typeof(jlrAccessibleObject).TypeInitializer.Invoke(null, null);
				typeof(jlrModifier).TypeInitializer.Invoke(null, null);
				typeof(jiConsole).TypeInitializer.Invoke(null, null);
a3767 8
			private static readonly ConstructorInfo threadConstructor1;
			private static readonly ConstructorInfo threadConstructor2;
			private static readonly FieldInfo vmThreadField;
			private static readonly MethodInfo threadGroupAddMethod;
			private static readonly FieldInfo threadStatusField;
			private static readonly FieldInfo daemonField;
			private static readonly FieldInfo threadPriorityField;
			private static readonly MethodInfo threadExitMethod;
d3779 2
a3780 1
			private sealed class VMThread
d3784 1
a3784 1
				internal readonly jlThread javaThread;
d3982 1
a3982 10
				threadConstructor1 = typeof(jlThread).GetConstructor(new Type[] { typeof(jlThreadGroup), typeof(string) });
				threadConstructor2 = typeof(jlThread).GetConstructor(new Type[] { typeof(jlThreadGroup), typeof(jlRunnable) });
				vmThreadField = typeof(jlThread).GetField("vmThread", BindingFlags.Instance | BindingFlags.NonPublic);
				threadGroupAddMethod = typeof(jlThreadGroup).GetMethod("add", BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { typeof(jlThread) }, null);
				threadStatusField = typeof(jlThread).GetField("threadStatus", BindingFlags.Instance | BindingFlags.NonPublic);
				daemonField = typeof(jlThread).GetField("daemon", BindingFlags.Instance | BindingFlags.NonPublic);
				threadPriorityField = typeof(jlThread).GetField("priority", BindingFlags.Instance | BindingFlags.NonPublic);
				threadExitMethod = typeof(jlThread).GetMethod("exit", BindingFlags.Instance | BindingFlags.NonPublic, null, Type.EmptyTypes, null);

				jlThreadGroup systemThreadGroup = (jlThreadGroup)Activator.CreateInstance(typeof(jlThreadGroup), true);
d3985 1
a3985 1
				typeof(jlSystem).GetMethod("initializeSystemClass", BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, null);
d3992 9
a4000 1
					typeof(jlClassLoader).GetField("sclSet", BindingFlags.Static | BindingFlags.NonPublic).SetValue(null, false);
d4003 5
d4029 5
a4033 3
				// this needs to be a volatile read, but note that we can't synchronize on javaThread
				SystemThreadingThread.MemoryBarrier();
				return (int)threadStatusField.GetValue(javaThread);
d4043 2
a4044 2
					// but that doesn't matter because Thread.exit() is idempotent.
					threadExitMethod.Invoke(javaThread, null);
d4046 1
a4046 3
				// this needs to be a volatile write, but note that we can't synchronize on javaThread
				threadStatusField.SetValue(javaThread, value);
				SystemThreadingThread.MemoryBarrier();
d4076 25
a4100 1
				return (VMThread)vmThreadField.GetValue(threadObj);
d4112 1
a4112 9
				// because the Thread constructor calls Thread.currentThread(), we have to have an instance before we
				// run the constructor
				jlThread thread = (jlThread)FormatterServices.GetUninitializedObject(typeof(jlThread));
				VMThread t = new VMThread(thread, SystemThreadingThread.CurrentThread);
				t.running = true;
				vmThreadField.SetValue(thread, t);
				vmThread = t;
				cleanup = new Cleanup(thread);
				threadPriorityField.SetValue(thread, MapNativePriorityToJava(t.nativeThread.Priority));
d4118 3
d4123 1
a4123 1
					threadConstructor1.Invoke(thread, new object[] { threadGroup, name });
d4127 1
a4127 1
					threadConstructor2.Invoke(thread, new object[] { threadGroup, null });
d4129 2
d4136 1
a4136 1
				daemonField.SetValue(thread, daemon);
d4140 1
a4140 1
					threadGroupAddMethod.Invoke(threadGroup, new object[] { thread });
d4234 1
a4234 1
				vmThreadField.SetValue(thisThread, t);
d5552 1
a5552 1
					|| type.Assembly == typeof(IKVM.Runtime.JNI).Assembly
d6648 1
a6648 1
					|| type.Assembly == typeof(IKVM.Runtime.JNI).Assembly
@


1.76
log
@Made all "native" method classes internal.
@
text
@d479 1
a479 1
		static class ObjectStreamClass
a480 25
			public static void initNative()
			{
			}

			public static bool hasStaticInitializer(object cl)
			{
				TypeWrapper wrapper = TypeWrapper.FromClass(cl);
				try
				{
					wrapper.Finish();
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				Type type = wrapper.TypeAsTBD;
				if (!type.IsArray && type.TypeInitializer != null)
				{
					wrapper.RunClassInit();
					return !AttributeHelper.IsHideFromJava(type.TypeInitializer);
				}
				return false;
			}

#if !FIRST_PASS
d507 2
a508 2
				buf[offset + 2] = (byte)(value >>  8);
				buf[offset + 3] = (byte)(value >>  0);
d513 1
d515 1
d526 1
d528 1
d555 2
a556 2
					 + (buf[offset + 2] <<  8)
					 + (buf[offset + 3] <<  0);
d561 3
d565 1
d577 3
d581 1
d583 1
d585 27
d614 16
a629 16
				private static readonly MethodInfo ReadByteMethod = typeof(ObjectStreamClass).GetMethod("ReadByte");
				private static readonly MethodInfo ReadBooleanMethod = typeof(ObjectStreamClass).GetMethod("ReadBoolean");
				private static readonly MethodInfo ReadCharMethod = typeof(ObjectStreamClass).GetMethod("ReadChar");
				private static readonly MethodInfo ReadShortMethod = typeof(ObjectStreamClass).GetMethod("ReadShort");
				private static readonly MethodInfo ReadIntMethod = typeof(ObjectStreamClass).GetMethod("ReadInt");
				private static readonly MethodInfo ReadFloatMethod = typeof(ObjectStreamClass).GetMethod("ReadFloat");
				private static readonly MethodInfo ReadLongMethod = typeof(ObjectStreamClass).GetMethod("ReadLong");
				private static readonly MethodInfo ReadDoubleMethod = typeof(ObjectStreamClass).GetMethod("ReadDouble");
				private static readonly MethodInfo WriteByteMethod = typeof(ObjectStreamClass).GetMethod("WriteByte");
				private static readonly MethodInfo WriteBooleanMethod = typeof(ObjectStreamClass).GetMethod("WriteBoolean");
				private static readonly MethodInfo WriteCharMethod = typeof(ObjectStreamClass).GetMethod("WriteChar");
				private static readonly MethodInfo WriteShortMethod = typeof(ObjectStreamClass).GetMethod("WriteShort");
				private static readonly MethodInfo WriteIntMethod = typeof(ObjectStreamClass).GetMethod("WriteInt");
				private static readonly MethodInfo WriteFloatMethod = typeof(ObjectStreamClass).GetMethod("WriteFloat");
				private static readonly MethodInfo WriteLongMethod = typeof(ObjectStreamClass).GetMethod("WriteLong");
				private static readonly MethodInfo WriteDoubleMethod = typeof(ObjectStreamClass).GetMethod("WriteDouble");
a3491 10
		static class Shutdown
		{
			public static void halt0(int status)
			{
				Environment.Exit(status);
			}

			// runAllFinalizers() implementation lives in map.xml
		}

d3736 1
a3736 1
				JVM.Library.initProperties(p);
d4307 1
a4307 1
							stacks[i] = JVM.Library.getStackTrace(stack);
d5428 1
a5428 1
						x = JVM.Library.mapException(x);
d6670 1
a6670 1
					nargs[i] = JVM.Library.unbox(args[i]);
d6730 1
a6730 1
					retval = JVM.Library.box(retval);
a8800 31

#if FIRST_PASS
namespace ikvm.@@internal
{
	public interface LibraryVMInterface
	{
		object newClass(object wrapper, object protectionDomain, object classLoader);
		object getWrapperFromClass(object clazz);

		object getWrapperFromClassLoader(object classLoader);
		void setWrapperForClassLoader(object classLoader, object wrapper);

		object box(object val);
		object unbox(object val);

		Exception mapException(Exception t);

		IntPtr getDirectBufferAddress(object buffer);
		int getDirectBufferCapacity(object buffer);

		void setProperties(System.Collections.Hashtable props);

		bool runFinalizersOnExit();

		object newAnnotation(object classLoader, object definition);
		object newAnnotationElementValue(object classLoader, object expectedClass, object definition);

		object newAssemblyClassLoader(Assembly asm);
	}
}
#endif // !FIRST_PASS
@


1.75
log
@Moved JNI implementation into a separate assembly (IKVM.Runtime.JNI.dll) to make IKVM.Runtime.dll verifiable.
@
text
@d134 1
a134 1
	public sealed class Assertions
a154 2
		private Assertions() { }

d289 1
a289 1
		public sealed class Console
d372 1
a372 1
		public sealed class FileDescriptor
d387 1
a387 1
		public sealed class FileSystem
d406 1
a406 1
		public sealed class ObjectInputStream
d458 1
a458 1
		public sealed class ObjectOutputStream
d479 1
a479 1
		public sealed class ObjectStreamClass
d1213 1
a1213 1
		public sealed class Win32FileSystem
d1821 1
a1821 1
		public sealed class UnixFileSystem
d1910 1
a1910 1
			public sealed class Array
d2579 1
a2579 1
		public sealed class Class
a2580 2
			private Class() { }

d3115 1
a3115 1
		public sealed class ClassLoader
a3120 2
			private ClassLoader() { }

d3220 1
a3220 1
			public sealed class NativeLibrary
a3221 2
				private NativeLibrary() { }

d3265 1
a3265 1
		public sealed class Compiler
d3299 1
a3299 1
		public sealed class Double
d3312 1
a3312 1
		public sealed class Float
d3325 1
a3325 1
		public sealed class Package
a3326 2
			private Package() { }

d3340 1
a3340 1
		public sealed class ProcessEnvironment
d3358 1
a3358 1
		public sealed class Runtime
d3416 1
a3416 1
		public sealed class SecurityManager
d3477 1
a3477 1
		public sealed class Shutdown
d3487 1
a3487 1
		public sealed class StrictMath
d3638 1
a3638 1
		public sealed class System
d3751 1
a3751 1
		public sealed class Thread
d4548 1
a4548 1
		public sealed class VMThread
d4559 1
a4559 1
			public sealed class Proxy
a4560 2
				private Proxy() { }

d4567 1
a4567 1
			public sealed class Method
a4568 2
				private Method() { }

d4589 1
a4589 1
		public sealed class DatagramPacket
d4596 1
a4596 1
		public sealed class InetAddress
d4603 1
a4603 1
		public sealed class InetAddressImplFactory
d4612 1
a4612 1
		public sealed class Inet4Address
d4619 1
a4619 1
		public sealed class Inet4AddressImpl
d4727 1
a4727 1
		public sealed class Inet6Address
d4734 1
a4734 1
		public sealed class Inet6AddressImpl
d4789 1
a4789 1
		public sealed class NetworkInterface
d5026 1
a5026 1
		public sealed class Bits
d5302 1
a5302 1
		public sealed class MappedByteBuffer
d5368 1
a5368 1
		public sealed class AccessController
d5555 1
a5555 1
		public sealed class DriverManager
d5593 1
a5593 1
			public sealed class FileHandler
d5605 1
a5605 1
			public sealed class FileSystemPreferences
d5626 1
a5626 1
			public sealed class WindowsPreferences
d5883 1
a5883 1
			public sealed class JarFile
d5911 1
a5911 1
		public sealed class ResourceBundle
d5936 1
a5936 1
		public sealed class TimeZone
d6217 1
a6217 1
	public sealed class DefaultDisposerRecord
d6225 1
a6225 1
	public sealed class Disposer
d6235 1
a6235 1
	public sealed class GC
d6243 1
a6243 1
	public sealed class MessageUtils
d6256 1
a6256 1
	public sealed class MiscHelper
d6268 1
a6268 1
	public sealed class Signal
d6286 1
a6286 1
	public sealed class NativeSignalHandler
d6294 1
a6294 1
	public sealed class Perf
d6332 1
a6332 1
	public sealed class Unsafe
a6333 2
		private Unsafe() { }

d6430 1
a6430 1
	public sealed class Version
d6453 1
a6453 1
	public sealed class VM
a6454 2
		private VM() { }

d6465 1
a6465 1
	public sealed class VMSupport
d6476 1
a6476 1
	public sealed class ResolverConfigurationImpl
d6535 1
a6535 1
	public sealed class DefaultProxySelector
d6552 1
a6552 1
	public sealed class Reflection
a6555 2
		private Reflection() { }

d6647 1
a6647 1
	public sealed class ReflectionFactory
a6648 2
		private ReflectionFactory() { }

d8585 1
a8585 1
	public sealed class ConstantPool
a8586 2
		private ConstantPool() { }

d8681 1
a8681 1
	public sealed class MarshalInputStream
d8692 1
a8692 1
	public sealed class Credentials
d8701 1
a8701 1
	public sealed class Config
d8712 1
a8712 1
	public sealed class NativeSeedGenerator
d8732 1
a8732 1
	public sealed class NativeUnpack
d8772 1
a8772 1
	public sealed class NTSystem
d8780 1
a8780 1
	public sealed class SolarisSystem
d8788 1
a8788 1
	public sealed class UnixSystem
@


1.74
log
@Implemented support for InternalsVisibleToAttribute.
@
text
@d3232 1
d3246 1
d3445 1
d5538 1
d6346 1
a6346 1
	public sealed unsafe class Unsafe
a6380 1
			byte* p = (byte*)address;
d6383 1
a6383 1
				*p++ = value;
a6388 2
			byte* psrc = (byte*)srcAddress;
			byte* pdst = (byte*)destAddress;
d6391 1
a6391 1
				*pdst++ = *psrc++;
d6397 1
a6397 1
			return *(byte*)address;
d6402 1
a6402 1
			*(byte*)address = x;
d6407 1
a6407 1
			return *(short*)address;
d6412 1
a6412 1
			*(short*)address = x;
d6417 1
a6417 1
			return *(char*)address;
d6422 1
a6422 1
			*(char*)address = x;
d6427 1
a6427 1
			return *(int*)address;
d6432 1
a6432 1
			*(int*)address = x;
d6437 1
a6437 1
			return *(long*)address;
d6442 1
a6442 1
			*(long*)address = x;
d6640 1
@


1.73
log
@Implemented native methods of java.io.Console.
@
text
@d6661 1
a6661 1
			return member.IsInternal && member.GetClassLoader() == current.GetClassLoader();
@


1.72
log
@Don't create DynamicMethod with bogus arg in signature.
@
text
@d295 13
a307 2
				// TODO
				return "IBM437";
d310 12
d324 31
a354 2
				// TODO
				return false;
d359 12
a370 4
				// the JDK returns false here if stdin or stdout is redirected (not stderr)
				// or if there is no console associated with the current process
				// TODO figure out if there is a managed way to detect redirection or console presence
				return true;
@


1.71
log
@Removed more .NET 1.1 workarounds.
@
text
@d7090 1
a7090 1
				DynamicMethod dm = new DynamicMethod("__<Invoker>", typeof(object), new Type[] { typeof(object), typeof(object[]) }, mw.DeclaringType.TypeAsTBD);
d7099 1
a7099 1
					ilgen.Emit(OpCodes.Ldarg_1);
d7102 1
a7102 1
				ilgen.Emit(OpCodes.Ldarg_1);
d7118 1
a7118 1
					ilgen.Emit(OpCodes.Ldarg_1);
@


1.70
log
@Oops. Changed vfs.zip path back to resource.
@
text
@a1568 16
					if (Environment.Version.Major == 1 && fileInfo is System.IO.DirectoryInfo)
					{
						// FXBUG on .NET 1.1 DirectoryInfo.Delete() can throw an exception even on success,
						// because it checks GetLastWin32Error() even if RemoveDirectory() succeeded.
						try
						{
							fileInfo.Refresh();
						}
						catch (System.ArgumentException)
						{
						}
						catch (System.IO.IOException)
						{
						}
						return !fileInfo.Exists;
					}
@


1.69
log
@- Improved VFS.
- Dynamically generate "lib/security/cacerts" from .NET X509 store.
@
text
@d918 2
a919 2
					return new System.IO.FileStream("c:\\ikvm\\openjdk\\vfs.zip", System.IO.FileMode.Open);
					//return Assembly.GetExecutingAssembly().GetManifestResourceStream("vfs.zip");
@


1.68
log
@- Regenerated mscorlib.jar for .NET 2.0
- Updated FileChannelImpl to use SafeFileHandle and GC.Add|RemoveMemoryPressure
- Added GC.KeepAlive to "native" methods of MappedByteBuffer
@
text
@d34 1
d798 1
a798 1
			private static juzZipFile zipFile;
d800 8
a807 1
			private class VfsEntry : juzZipEntry
d811 1
a811 2
				internal VfsEntry(bool directory)
					: base("")
d816 6
a821 1
				public override bool isDirectory()
d823 6
a828 1
					return directory;
d832 1
a832 1
			private static juzZipEntry GetZipEntry(string name)
d834 4
a837 1
				if (zipFile == null)
d839 27
a865 4
					// this is a weird loop back, the vfs.zip resource is loaded from vfs,
					// because that's the easiest way to construct a ZipFile from a Stream.
					juzZipFile zf = new juzZipFile(RootPath + "vfs.zip");
					if (Interlocked.CompareExchange(ref zipFile, zf, null) != null)
d867 2
a868 1
						zf.close();
d871 2
a872 1
				if (IsVirtualFS(name))
d874 7
a880 1
					if (name.Length < RootPath.Length)
d882 17
a898 1
						return new VfsEntry(true);
d900 8
a907 1
					else
d909 4
a912 1
						name = name.Substring(RootPath.Length);
d915 42
a956 3
				name = name.Replace('\\', '/');
				juzZipEntry entry = ((juzZipFile)zipFile).getEntry(name);
				if (entry == null)
d958 10
a967 34
					if (name == "bin/" + IKVM.NativeCode.java.lang.System.mapLibraryName("zip")
						|| name == "bin/" + IKVM.NativeCode.java.lang.System.mapLibraryName("awt")
						|| name == "bin/" + IKVM.NativeCode.java.lang.System.mapLibraryName("rmi")
						|| name == "bin/" + IKVM.NativeCode.java.lang.System.mapLibraryName("w2k_lsa_auth")
						|| name == "bin/" + IKVM.NativeCode.java.lang.System.mapLibraryName("jaas_nt")
						|| name == "bin/" + IKVM.NativeCode.java.lang.System.mapLibraryName("jaas_unix")
						|| name == "bin/" + IKVM.NativeCode.java.lang.System.mapLibraryName("unpack")
						|| name == "bin/" + IKVM.NativeCode.java.lang.System.mapLibraryName("net"))
					{
						return new VfsEntry(false);
					}
				}
				return entry;
			}

			/*
			 * On WHIDBEY we should generate cacerts on the fly by using something like this:
			 *
			 * java.security.KeyStore jstore = java.security.KeyStore.getInstance("jks");
			 * jstore.load(null);
			 * java.security.cert.CertificateFactory cf = java.security.cert.CertificateFactory.getInstance("X509");
			 * 
			 * X509Store store = new X509Store(StoreName.Root, StoreLocation.LocalMachine);
			 * store.Open(OpenFlags.ReadOnly);
			 * foreach (X509Certificate2 cert in store.Certificates)
			 * {
			 *   if (!cert.HasPrivateKey)
			 *   {
			 *     jstore.setCertificateEntry(cert.Subject, cf.generateCertificate(new java.io.ByteArrayInputStream(cert.RawData)));
			 *   }
			 * }
			 * java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
			 * jstore.store(baos, new char[0]);
			 */
d1109 1
a1109 6
				name = name.Substring(RootPath.Length);
				if (name == "vfs.zip")
				{
					return Assembly.GetExecutingAssembly().GetManifestResourceStream(name);
				}
				juzZipEntry entry = GetZipEntry(name);
d1114 1
a1114 1
				return new ZipEntryStream(((juzZipFile)zipFile), entry);
d1123 2
a1124 2
				juzZipEntry entry = GetZipEntry(path);
				return entry == null ? 0 : entry.getSize();
d1133 1
a1133 1
				return access == Win32FileSystem.ACCESS_READ && GetZipEntry(path) != null;
d1142 1
a1142 1
				juzZipEntry entry = GetZipEntry(path);
d1150 1
a1150 1
				return entry.isDirectory() ? BA_EXISTS | BA_DIRECTORY : BA_EXISTS | BA_REGULAR;
d1225 1
a1225 2
						string[] arr = System.IO.Directory.GetFileSystemEntries(dir, name);
						if (arr.Length == 1)
d1227 5
a1231 1
							name = arr[0];
d6533 4
@


1.67
log
@More .NET 1.1 -> 2.0 work.
@
text
@d5201 1
d5210 1
d5220 1
@


1.66
log
@More .NET 1.1 -> 2.0 work.
@
text
@d26 1
d2808 1
a2808 1
					ArrayList list = new ArrayList();
d2822 1
a2822 1
							list.Add(fields[i].ToField(false));
d2825 1
a2825 1
					return (jlrField[])list.ToArray(typeof(jlrField));
d2861 1
a2861 1
					ArrayList list = new ArrayList();
d2876 1
a2876 1
							list.Add(methods[i].ToMethodOrConstructor(false));
d2879 1
a2879 1
					return (jlrMethod[])list.ToArray(typeof(jlrMethod));
d2915 1
a2915 1
					ArrayList list = new ArrayList();
d2929 1
a2929 1
							list.Add(methods[i].ToMethodOrConstructor(false));
d2932 1
a2932 1
					return (jlrConstructor[])list.ToArray(typeof(jlrConstructor));
d3297 1
a3297 1
				ArrayList stack = new ArrayList();
d3318 1
a3318 1
					stack.Add(ClassLoaderWrapper.GetWrapperFromType(type).ClassObject);
d3320 1
a3320 1
				return stack.ToArray(typeof(jlClass));
d4522 1
a4522 1
					ArrayList addresses = new ArrayList();
d4531 1
a4531 1
					return (jnInetAddress[])addresses.ToArray(typeof(jnInetAddress));
d5330 1
a5330 1
				ArrayList array = new ArrayList();
d5351 1
a5351 1
						array.Add(protection_domain);
d5370 1
a5370 3
				ProtectionDomain[] context = new ProtectionDomain[array.Count];
				array.CopyTo(context);
				return CreateAccessControlContext(context, is_privileged, privileged_context);
d5765 1
a5765 1
					ArrayList list = null;
d5773 1
a5773 1
								list = new ArrayList();
d5778 1
a5778 1
					return list == null ? null : (string[])list.ToArray(typeof(string));
d6434 1
a6434 1
		private static readonly Hashtable isHideFromJavaCache = Hashtable.Synchronized(new Hashtable());
d6440 9
a6448 7
			// TODO on .NET 2.0 isHideFromJavaCache should be a Dictionary<RuntimeMethodHandle, bool>
			object cached = isHideFromJavaCache[mb];
			if (cached == null)
			{
				cached = mb.IsDefined(typeof(IKVM.Attributes.HideFromJavaAttribute), false)
					|| mb.IsDefined(typeof(IKVM.Attributes.HideFromReflectionAttribute), false);
				isHideFromJavaCache[mb] = cached;
d6450 19
a6468 1
			return (bool)cached;
d6671 1
a6671 1
					// FXBUG a DynamicMethod that calls a static method doesn't trigger the cctor, so we do that explicitly.
a6751 9
				if (mw.DeclaringType.IsInterface && mw.DeclaringType.HasStaticInitializer)
				{
					// NOTE since Everett doesn't support adding static methods to interfaces,
					// EmitRunClassConstructor doesn't work for interface, so we do it manually.
					// TODO once we're on Whidbey, this won't be necessary anymore.
					ilgen.Emit(OpCodes.Ldtoken, mw.DeclaringType.TypeAsBaseType);
					ilgen.Emit(OpCodes.Call, typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("RunClassConstructor"));
				}

@


1.65
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d796 1
a796 2
			// TODO on WHIDBEY this variable can be typed juzZipFile (because Interlocked.CompareExchange<>() is availble there)
			private static object zipFile;
@


1.64
log
@- .NET 1.1 is no longer supported
- Removed .NET 2.0 warnings (except for the "unreachable code" ones)
@
text
@a123 1
#if WHIDBEY
a128 44
#else
sealed class DynamicMethodSupport
{
	internal static readonly bool Enabled = Environment.Version.Major >= 2 && Type.GetType("Mono.Runtime") == null;
}

sealed class DynamicMethod
{
	private static ConstructorInfo ctor1;
	private static ConstructorInfo ctor2;
	private static MethodInfo createMethod;
	private static MethodInfo getILGenMethod;
	private object dm;

	static DynamicMethod()
	{
		Type type = Type.GetType("System.Reflection.Emit.DynamicMethod", true);
		ctor1 = type.GetConstructor(new Type[] { typeof(string), typeof(MethodAttributes), typeof(CallingConventions), typeof(Type), typeof(Type[]), typeof(Module), typeof(bool) });
		ctor2 = type.GetConstructor(new Type[] { typeof(string), typeof(Type), typeof(Type[]), typeof(Type) });
		createMethod = type.GetMethod("CreateDelegate", new Type[] { typeof(Type) });
		getILGenMethod = type.GetMethod("GetILGenerator", new Type[0]);
	}

	internal DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module owner, bool skipVisibility)
	{
		dm = ctor1.Invoke(new object[] { name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility });
	}

	internal DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner)
	{
		dm = ctor2.Invoke(new object[] { name, returnType, parameterTypes, owner });
	}

	internal ILGenerator GetILGenerator()
	{
		return (ILGenerator)getILGenMethod.Invoke(dm, null);
	}

	internal Delegate CreateDelegate(Type delegateType)
	{
		return (Delegate)createMethod.Invoke(dm, new object[] { delegateType });
	}
}
#endif
a4520 1
#if WHIDBEY
a4521 3
#else
					System.Net.IPAddress[] addr = System.Net.Dns.Resolve(hostname).AddressList;
#endif
a4635 1
#if WHIDBEY
a4636 3
#else
					System.Net.IPAddress[] addr = System.Net.Dns.Resolve(hostname).AddressList;
#endif
@


1.63
log
@Don't create the default system class loader if the main executable has a custom assembly class loader.
@
text
@d4131 1
a4131 1
					t.nativeThread.ApartmentState = ApartmentState.MTA;
d4135 1
a4135 1
					t.nativeThread.ApartmentState = ApartmentState.STA;
d4206 1
a4206 2
								t.nativeThread.Suspend();
								suspended = true;
d4217 1
a4217 1
									t.nativeThread.Resume();
d4232 16
d4325 1
a4325 1
								t.nativeThread.Resume();
d4347 1
a4347 1
						t.nativeThread.Suspend();
d4362 1
a4362 1
						t.nativeThread.Resume();
a4597 1
				string s;
d4600 1
a4600 1
					s = System.Net.Dns.GetHostByAddress(string.Format("{0}.{1}.{2}.{3}", addr[0], addr[1], addr[2], addr[3])).HostName;
a4605 17
				try
				{
					System.Net.Dns.GetHostByName(s);
				}
				catch (System.Net.Sockets.SocketException)
				{
					// FXBUG .NET framework bug
					// HACK if GetHostByAddress returns a netbios name, it appends the default DNS suffix, but if the
					// machine's netbios name isn't the same as the DNS hostname, this might result in an unresolvable
					// name, if that happens we chop off the DNS suffix.
					int idx = s.IndexOf('.');
					if (idx > 0)
					{
						return s.Substring(0, idx);
					}
				}
				return s;
@


1.62
log
@Fixed Class.getModifiers() to mask out ACC_SUPER bit.
@
text
@d6189 1
a6189 1
		public static object getAssemblyClassLoader(Assembly asm)
d6191 5
a6195 1
			return ClassLoaderWrapper.GetAssemblyClassLoader(asm).GetJavaClassLoader();
@


1.61
log
@Added support for custom assembly class loaders.
@
text
@d2666 4
a2669 1
				return (int)TypeWrapper.FromClass(thisClass).ReflectiveModifiers;
@


1.60
log
@Regression fix. When getting a static field value, we should convert the value from signature type to stack type (to make sure that non-primitive value types are boxed).
@
text
@d2732 1
a2732 1
				if (pd == null && wrapper.GetClassLoader() is AssemblyClassLoader)
d2734 4
a2737 2
					object loader = wrapper.GetClassLoader().GetJavaClassLoader();
					if (loader != null)
d2739 1
a2739 8
						// The protection domain for statically compiled code is created lazily (not at java.lang.Class creation time),
						// to work around boot strap issues.
						// TODO this should be done more efficiently
						MethodInfo method = loader.GetType().GetMethod("getProtectionDomain", BindingFlags.Public | BindingFlags.Instance);
						if (method != null)
						{
							pd = method.Invoke(loader, null);
						}
@


1.59
log
@Explicitly run <clinit> when calling a static method thru reflection via a DynamicMethod, to work around the .NET 2.0 bug in DynamicMethod that causes it not to call the class constructor in this case.
@
text
@d7858 1
@


1.58
log
@Make sure that passed in reference arguments are of the correct type.
@
text
@d6666 1
a6666 1
			private readonly Invoker invoker;
d6691 23
d6831 5
@


1.57
log
@Disabled the use of DynamicMethod when running on Mono, because as of Mono 1.2.5.1 its DynamicMethod implementation is too broken for us.
@
text
@d6591 4
@


1.56
log
@Implemented optimized reflection/serialization when running on .NET 2.0 (by generating DynamicMethods instead of using .NET reflection).
@
text
@d127 2
a128 1
	internal const bool Enabled = true;
d133 1
a133 1
	internal static readonly bool Enabled = Environment.Version.Major >= 2;
@


1.55
log
@Implemented assertions (OpenJDK only).
@
text
@d28 1
d51 1
d79 1
d99 1
d103 1
d124 50
d488 339
d6641 1
a6641 1
		private sealed class ConstructorAccessorImpl : srConstructorAccessor
d6643 66
a6708 1
			private readonly MethodWrapper mw;
d6710 14
a6723 4
			internal ConstructorAccessorImpl(jlrConstructor constructor)
			{
				mw = MethodWrapper.FromMethodOrConstructor(constructor);
			}
d6725 13
a6737 5
			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
			{
				args = ConvertArgs(mw.GetParameters(), args);
				try
d6739 4
a6742 1
					return mw.Invoke(null, args, false);
d6744 1
a6744 1
				catch (MethodAccessException x)
d6746 7
a6752 2
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
d6754 5
a6758 2
			}
		}
d6760 8
a6767 4
		private sealed class SerializationConstructorAccessorImpl : srConstructorAccessor
		{
			private Type type;
			private MethodWrapper constructor;
d6769 14
a6782 4
			internal SerializationConstructorAccessorImpl(jlrConstructor constructorToCall, jlClass classToInstantiate)
			{
				constructor = MethodWrapper.FromMethodOrConstructor(constructorToCall);
				try
d6784 1
a6784 3
					TypeWrapper wrapper = TypeWrapper.FromClass(classToInstantiate);
					wrapper.Finish();
					type = wrapper.TypeAsBaseType;
d6786 1
a6786 1
				catch (RetargetableJavaException x)
d6788 1
a6788 1
					throw x.ToJava();
d6790 13
d6805 1
a6805 2
			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
d6807 1
a6807 7
				// if we're trying to deserialize a string as a TC_OBJECT, just return an emtpy string (Sun does the same)
				if (type == typeof(string))
				{
					return "";
				}
				args = ConvertArgs(constructor.GetParameters(), args);
				try
d6809 1
a6809 3
					object obj = FormatterServices.GetUninitializedObject(type);
					constructor.Invoke(obj, args, false);
					return obj;
d6811 1
a6811 1
				catch (RetargetableJavaException x)
d6813 1
a6813 1
					throw x.ToJava();
d6815 1
a6815 1
				catch (MethodAccessException x)
d6817 1
a6817 2
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
a6819 7
		}

		private abstract class FieldAccessorImplBase : srFieldAccessor
		{
			private readonly FieldWrapper fw;
			private readonly bool isFinal;
			private bool runInit;
d6821 364
a7184 1
			private FieldAccessorImplBase(jlrField field, bool overrideAccessCheck)
a7212 4
				if (isFinal)
				{
					throw new jlIllegalAccessException();
				}
d7220 4
d7318 1
a7318 1
			private sealed class ObjectField : FieldAccessorImplBase
d7343 1
a7343 1
			private sealed class ByteField : FieldAccessorImplBase
d7355 1
a7355 1
				public override short getShort(object obj)
d7360 1
a7360 1
				public override int getInt(object obj)
d7365 1
a7365 1
				public override long getLong(object obj)
d7370 1
a7370 1
				public override float getFloat(object obj)
d7375 1
a7375 1
				public override double getDouble(object obj)
d7380 1
a7380 1
				public override object get(object obj)
d7385 1
a7385 1
				public override void set(object obj, object val)
d7400 1
a7400 1
			private sealed class BooleanField : FieldAccessorImplBase
d7412 1
a7412 1
				public override object get(object obj)
d7417 1
a7417 1
				public override void set(object obj, object val)
d7432 1
a7432 1
			private sealed class CharField : FieldAccessorImplBase
d7444 1
a7444 1
				public override int getInt(object obj)
d7449 1
a7449 1
				public override long getLong(object obj)
d7454 1
a7454 1
				public override float getFloat(object obj)
d7459 1
a7459 1
				public override double getDouble(object obj)
d7464 1
a7464 1
				public override object get(object obj)
d7469 1
a7469 1
				public override void set(object obj, object val)
d7483 1
a7483 1
			private sealed class ShortField : FieldAccessorImplBase
d7495 1
a7495 1
				public override int getInt(object obj)
d7500 1
a7500 1
				public override long getLong(object obj)
d7505 1
a7505 1
				public override float getFloat(object obj)
d7510 1
a7510 1
				public override double getDouble(object obj)
d7515 1
a7515 1
				public override object get(object obj)
d7520 1
a7520 1
				public override void set(object obj, object val)
d7529 1
a7529 1
				public override void setByte(object obj, byte b)
d7540 1
a7540 1
			private sealed class IntField : FieldAccessorImplBase
d7552 1
a7552 1
				public override long getLong(object obj)
d7557 1
a7557 1
				public override float getFloat(object obj)
d7562 1
a7562 1
				public override double getDouble(object obj)
d7567 1
a7567 1
				public override object get(object obj)
d7572 1
a7572 1
				public override void set(object obj, object val)
d7584 1
a7584 1
				public override void setByte(object obj, byte b)
d7589 1
a7589 1
				public override void setChar(object obj, char c)
d7594 1
a7594 1
				public override void setShort(object obj, short s)
d7605 1
a7605 1
			private sealed class FloatField : FieldAccessorImplBase
d7617 1
a7617 1
				public override double getDouble(object obj)
d7622 1
a7622 1
				public override object get(object obj)
d7627 1
a7627 1
				public override void set(object obj, object val)
d7641 1
a7641 1
				public override void setByte(object obj, byte b)
d7646 1
a7646 1
				public override void setChar(object obj, char c)
d7651 1
a7651 1
				public override void setShort(object obj, short s)
d7656 1
a7656 1
				public override void setInt(object obj, int i)
d7661 1
a7661 1
				public override void setLong(object obj, long l)
d7672 1
a7672 1
			private sealed class LongField : FieldAccessorImplBase
d7684 1
a7684 1
				public override float getFloat(object obj)
d7689 1
a7689 1
				public override double getDouble(object obj)
d7694 1
a7694 1
				public override object get(object obj)
d7704 1
a7704 1
				public override void set(object obj, object val)
d7717 1
a7717 1
				public override void setByte(object obj, byte b)
d7722 1
a7722 1
				public override void setChar(object obj, char c)
d7727 1
a7727 1
				public override void setShort(object obj, short s)
d7732 1
a7732 1
				public override void setInt(object obj, int i)
d7738 1
a7738 1
			private sealed class DoubleField : FieldAccessorImplBase
d7806 1
a7806 1
			internal static FieldAccessorImplBase Create(jlrField field, bool overrideAccessCheck)
d7808 53
a7860 2
				jlClass type = field.getType();
				if (type.isPrimitive())
d7862 1
a7862 1
					if (type == jlByte.TYPE)
d7864 7
a7870 1
						return new ByteField(field, overrideAccessCheck);
d7872 1
a7872 1
					if (type == jlBoolean.TYPE)
d7874 451
a8324 1
						return new BooleanField(field, overrideAccessCheck);
d8328 8
a8335 1
						return new CharField(field, overrideAccessCheck);
d8339 8
a8346 1
						return new ShortField(field, overrideAccessCheck);
d8350 8
a8357 1
						return new IntField(field, overrideAccessCheck);
d8361 8
a8368 1
						return new FloatField(field, overrideAccessCheck);
d8372 8
a8379 1
						return new LongField(field, overrideAccessCheck);
d8383 8
a8390 1
						return new DoubleField(field, overrideAccessCheck);
d8396 8
a8403 1
					return new ObjectField(field, overrideAccessCheck);
d8423 10
a8432 1
			return new MethodAccessorImpl((jlrMethod)method);
d8441 10
a8450 1
			return new ConstructorAccessorImpl((jlrConstructor)constructor);
d8459 12
a8470 1
			return new SerializationConstructorAccessorImpl((jlrConstructor)constructorToCall, (jlClass)classToInstantiate);
@


1.54
log
@Made method annotation resolution lazy to support annotations that annotate themselves.
@
text
@d119 155
d2633 1
a2633 2
				// TODO
				return false;
d2785 1
a2785 13
#if FIRST_PASS
				return null;
#else
				Type type = typeof(jlClass).Assembly.GetType("java.lang.AssertionStatusDirectives");
				object obj = Activator.CreateInstance(type, true);
				// TODO
				type.GetField("classes", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, new string[0]);
				type.GetField("classEnabled", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, new bool[0]);
				type.GetField("packages", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, new string[0]);
				type.GetField("packageEnabled", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, new bool[0]);
				type.GetField("deflt", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, false);
				return obj;
#endif
@


1.53
log
@- Fixed path canonicalization not to throw exceptions that it shouldn't throw.
- Added workaround for .NET 1.1 Directory.Delete() bug.
@
text
@d3936 20
@


1.53.2.1
log
@Ported fixes from trunk. Changed version to 0.36.0.1.
@
text
@a118 155
namespace IKVM.Runtime
{
	public sealed class Assertions
	{
		private static bool sysAsserts;
		private static bool userAsserts;
		private static OptionNode classes;
		private static OptionNode packages;

		private class OptionNode
		{
			internal readonly string name;
			internal readonly bool enabled;
			internal readonly OptionNode next;

			internal OptionNode(string name, bool enabled, OptionNode next)
			{
				this.name = name;
				this.enabled = enabled;
				this.next = next;
			}
		}

		private Assertions() { }

		private static void AddOption(string classOrPackage, bool enabled)
		{
			if (classOrPackage == null)
			{
				throw new ArgumentNullException("classOrPackage");
			}

			if (classOrPackage.EndsWith("..."))
			{
				packages = new OptionNode(classOrPackage.Substring(0, classOrPackage.Length - 3), enabled, packages);
			}
			else
			{
				classes = new OptionNode(classOrPackage, enabled, classes);
			}
		}

		public static void EnableAssertions(string classOrPackage)
		{
			AddOption(classOrPackage, true);
		}

		public static void DisableAssertions(string classOrPackage)
		{
			AddOption(classOrPackage, false);
		}

		public static void EnableAssertions()
		{
			userAsserts = true;
		}

		public static void DisableAssertions()
		{
			userAsserts = false;
		}

		public static void EnableSystemAssertions()
		{
			sysAsserts = true;
		}

		public static void DisableSystemAssertions()
		{
			sysAsserts = false;
		}

		internal static bool IsEnabled(TypeWrapper tw)
		{
			string className = tw.Name;

			// match class name
			for (OptionNode n = classes; n != null; n = n.next)
			{
				if (n.name == className)
				{
					return n.enabled;
				}
			}

			// match package name
			if (packages != null)
			{
				int len = className.Length;
				while (len > 0 && className[--len] != '.') ;

				do
				{
					for (OptionNode n = packages; n != null; n = n.next)
					{
						if (String.Compare(n.name, 0, className, 0, len, false, System.Globalization.CultureInfo.InvariantCulture) == 0 && len == n.name.Length)
						{
							return n.enabled;
						}
					}
					while (len > 0 && className[--len] != '.') ;
				} while (len > 0);
			}

			return tw.GetClassLoader() == ClassLoaderWrapper.GetBootstrapClassLoader() ? sysAsserts : userAsserts;
		}

		private static int Count(OptionNode n)
		{
			int count = 0;
			while (n != null)
			{
				count++;
				n = n.next;
			}
			return count;
		}

		internal static object RetrieveDirectives()
		{
#if FIRST_PASS
			return null;
#else

			Type type = typeof(jlClass).Assembly.GetType("java.lang.AssertionStatusDirectives");
			object obj = Activator.CreateInstance(type, true);
			string[] arrStrings = new string[Count(classes)];
			bool[] arrBools = new bool[arrStrings.Length];
			OptionNode n = classes;
			for (int i = 0; i < arrStrings.Length; i++)
			{
				arrStrings[i] = n.name;
				arrBools[i] = n.enabled;
				n = n.next;
			}
			type.GetField("classes", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, arrStrings);
			type.GetField("classEnabled", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, arrBools);
			arrStrings = new string[Count(packages)];
			arrBools = new bool[arrStrings.Length];
			n = packages;
			for (int i = 0; i < arrStrings.Length; i++)
			{
				arrStrings[i] = n.name;
				arrBools[i] = n.enabled;
				n = n.next;
			}
			type.GetField("packages", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, arrStrings);
			type.GetField("packageEnabled", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, arrBools);
			type.GetField("deflt", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(obj, userAsserts);
			return obj;
#endif
		}
	}
}

d2478 2
a2479 1
				return IKVM.Runtime.Assertions.IsEnabled(TypeWrapper.FromClass(clazz));
d2631 13
a2643 1
				return IKVM.Runtime.Assertions.RetrieveDirectives();
a3935 20

			public sealed class Method
			{
				private Method() { }

				public static byte[] getRawAnnotations(object thisMethod)
				{
					return MethodWrapper.FromMethodOrConstructor(thisMethod).GetRawAnnotations();
				}

				public static byte[] getRawParameterAnnotations(object thisMethod)
				{
					return MethodWrapper.FromMethodOrConstructor(thisMethod).GetRawParameterAnnotations();
				}

				public static byte[] getRawAnnotationDefault(object thisMethod)
				{
					return MethodWrapper.FromMethodOrConstructor(thisMethod).GetRawAnnotationDefault();
				}
			}
@


1.53.2.2
log
@Backported fixes from trunk. Changed version to 0.36.0.3.
@
text
@a27 1
using System.Reflection.Emit;
a49 1
using jlInternalError = java.lang.InternalError;
a76 1
using jlrInvocationTargetException = java.lang.reflect.InvocationTargetException;
a95 1
using jiObjectStreamField = java.io.ObjectStreamField;
a98 1
using iiFieldReflectorBase = ikvm.@@internal.FieldReflectorBase;
a118 51
#if WHIDBEY
sealed class DynamicMethodSupport
{
	// MONOBUG as of Mono 1.2.5.1, DynamicMethod is too broken to be used
	internal static readonly bool Enabled = Type.GetType("Mono.Runtime") == null;
}
#else
sealed class DynamicMethodSupport
{
	internal static readonly bool Enabled = Environment.Version.Major >= 2 && Type.GetType("Mono.Runtime") == null;
}

sealed class DynamicMethod
{
	private static ConstructorInfo ctor1;
	private static ConstructorInfo ctor2;
	private static MethodInfo createMethod;
	private static MethodInfo getILGenMethod;
	private object dm;

	static DynamicMethod()
	{
		Type type = Type.GetType("System.Reflection.Emit.DynamicMethod", true);
		ctor1 = type.GetConstructor(new Type[] { typeof(string), typeof(MethodAttributes), typeof(CallingConventions), typeof(Type), typeof(Type[]), typeof(Module), typeof(bool) });
		ctor2 = type.GetConstructor(new Type[] { typeof(string), typeof(Type), typeof(Type[]), typeof(Type) });
		createMethod = type.GetMethod("CreateDelegate", new Type[] { typeof(Type) });
		getILGenMethod = type.GetMethod("GetILGenerator", new Type[0]);
	}

	internal DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module owner, bool skipVisibility)
	{
		dm = ctor1.Invoke(new object[] { name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility });
	}

	internal DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner)
	{
		dm = ctor2.Invoke(new object[] { name, returnType, parameterTypes, owner });
	}

	internal ILGenerator GetILGenerator()
	{
		return (ILGenerator)getILGenMethod.Invoke(dm, null);
	}

	internal Delegate CreateDelegate(Type delegateType)
	{
		return (Delegate)createMethod.Invoke(dm, new object[] { delegateType });
	}
}
#endif

a432 339

#if !FIRST_PASS
			public static void WriteByte(byte[] buf, int offset, byte value)
			{
				buf[offset] = value;
			}

			public static void WriteBoolean(byte[] buf, int offset, bool value)
			{
				buf[offset] = value ? (byte)1 : (byte)0;
			}

			public static void WriteChar(byte[] buf, int offset, char value)
			{
				buf[offset + 0] = (byte)(value >> 8);
				buf[offset + 1] = (byte)(value >> 0);
			}

			public static void WriteShort(byte[] buf, int offset, short value)
			{
				buf[offset + 0] = (byte)(value >> 8);
				buf[offset + 1] = (byte)(value >> 0);
			}

			public static void WriteInt(byte[] buf, int offset, int value)
			{
				buf[offset + 0] = (byte)(value >> 24);
				buf[offset + 1] = (byte)(value >> 16);
				buf[offset + 2] = (byte)(value >>  8);
				buf[offset + 3] = (byte)(value >>  0);
			}

			public static void WriteFloat(byte[] buf, int offset, float value)
			{
				WriteInt(buf, offset, jlFloat.floatToIntBits(value));
			}

			public static void WriteLong(byte[] buf, int offset, long value)
			{
				WriteInt(buf, offset, (int)(value >> 32));
				WriteInt(buf, offset + 4, (int)value);
			}

			public static void WriteDouble(byte[] buf, int offset, double value)
			{
				WriteLong(buf, offset, jlDouble.doubleToLongBits(value));
			}

			public static byte ReadByte(byte[] buf, int offset)
			{
				return buf[offset];
			}

			public static bool ReadBoolean(byte[] buf, int offset)
			{
				return buf[offset] != 0;
			}

			public static char ReadChar(byte[] buf, int offset)
			{
				return (char)((buf[offset] << 8) + buf[offset + 1]);
			}

			public static short ReadShort(byte[] buf, int offset)
			{
				return (short)((buf[offset] << 8) + buf[offset + 1]);
			}

			public static int ReadInt(byte[] buf, int offset)
			{
				return (buf[offset + 0] << 24)
					 + (buf[offset + 1] << 16)
					 + (buf[offset + 2] <<  8)
					 + (buf[offset + 3] <<  0);
			}

			public static float ReadFloat(byte[] buf, int offset)
			{
				return jlFloat.intBitsToFloat(ReadInt(buf, offset));
			}

			public static long ReadLong(byte[] buf, int offset)
			{
				long hi = (uint)ReadInt(buf, offset);
				long lo = (uint)ReadInt(buf, offset + 4);
				return lo + (hi << 32);
			}

			public static double ReadDouble(byte[] buf, int offset)
			{
				return jlDouble.longBitsToDouble(ReadLong(buf, offset));
			}

			private sealed class FastFieldReflector : iiFieldReflectorBase
			{
				private static readonly MethodInfo ReadByteMethod = typeof(ObjectStreamClass).GetMethod("ReadByte");
				private static readonly MethodInfo ReadBooleanMethod = typeof(ObjectStreamClass).GetMethod("ReadBoolean");
				private static readonly MethodInfo ReadCharMethod = typeof(ObjectStreamClass).GetMethod("ReadChar");
				private static readonly MethodInfo ReadShortMethod = typeof(ObjectStreamClass).GetMethod("ReadShort");
				private static readonly MethodInfo ReadIntMethod = typeof(ObjectStreamClass).GetMethod("ReadInt");
				private static readonly MethodInfo ReadFloatMethod = typeof(ObjectStreamClass).GetMethod("ReadFloat");
				private static readonly MethodInfo ReadLongMethod = typeof(ObjectStreamClass).GetMethod("ReadLong");
				private static readonly MethodInfo ReadDoubleMethod = typeof(ObjectStreamClass).GetMethod("ReadDouble");
				private static readonly MethodInfo WriteByteMethod = typeof(ObjectStreamClass).GetMethod("WriteByte");
				private static readonly MethodInfo WriteBooleanMethod = typeof(ObjectStreamClass).GetMethod("WriteBoolean");
				private static readonly MethodInfo WriteCharMethod = typeof(ObjectStreamClass).GetMethod("WriteChar");
				private static readonly MethodInfo WriteShortMethod = typeof(ObjectStreamClass).GetMethod("WriteShort");
				private static readonly MethodInfo WriteIntMethod = typeof(ObjectStreamClass).GetMethod("WriteInt");
				private static readonly MethodInfo WriteFloatMethod = typeof(ObjectStreamClass).GetMethod("WriteFloat");
				private static readonly MethodInfo WriteLongMethod = typeof(ObjectStreamClass).GetMethod("WriteLong");
				private static readonly MethodInfo WriteDoubleMethod = typeof(ObjectStreamClass).GetMethod("WriteDouble");
				private static readonly FieldInfo fieldField = typeof(jiObjectStreamField).GetField("field", BindingFlags.Instance | BindingFlags.NonPublic);
				private delegate void ObjFieldGetterSetter(object obj, object[] objarr);
				private delegate void PrimFieldGetterSetter(object obj, byte[] objarr);
				private static readonly ObjFieldGetterSetter objDummy = new ObjFieldGetterSetter(Dummy);
				private static readonly PrimFieldGetterSetter primDummy = new PrimFieldGetterSetter(Dummy);
				private jiObjectStreamField[] fields;
				private ObjFieldGetterSetter objFieldGetter;
				private PrimFieldGetterSetter primFieldGetter;
				private ObjFieldGetterSetter objFieldSetter;
				private PrimFieldGetterSetter primFieldSetter;

				private static void Dummy(object obj, object[] objarr)
				{
				}

				private static void Dummy(object obj, byte[] barr)
				{
				}

				internal FastFieldReflector(jiObjectStreamField[] fields)
				{
					this.fields = fields;
					TypeWrapper tw = null;
					foreach (jiObjectStreamField field in fields)
					{
						FieldWrapper fw = GetFieldWrapper(field);
						if (fw != null)
						{
							if (tw == null)
							{
								tw = fw.DeclaringType;
							}
							else if (tw != fw.DeclaringType)
							{
								// pre-condition is that all fields are from the same Type!
								throw new jlInternalError();
							}
						}
					}
					if (tw == null)
					{
						objFieldGetter = objFieldSetter = objDummy;
						primFieldGetter = primFieldSetter = primDummy;
					}
					else
					{
						tw.Finish();
						DynamicMethod dmObjGetter = new DynamicMethod("__<ObjFieldGetter>", null, new Type[] { typeof(object), typeof(object[]) }, tw.TypeAsBaseType);
						DynamicMethod dmPrimGetter = new DynamicMethod("__<PrimFieldGetter>", null, new Type[] { typeof(object), typeof(byte[]) }, tw.TypeAsBaseType);
						DynamicMethod dmObjSetter = new DynamicMethod("__<ObjFieldSetter>", null, new Type[] { typeof(object), typeof(object[]) }, tw.TypeAsBaseType);
						DynamicMethod dmPrimSetter = new DynamicMethod("__<PrimFieldSetter>", null, new Type[] { typeof(object), typeof(byte[]) }, tw.TypeAsBaseType);
						CountingILGenerator ilgenObjGetter = dmObjGetter.GetILGenerator();
						CountingILGenerator ilgenPrimGetter = dmPrimGetter.GetILGenerator();
						CountingILGenerator ilgenObjSetter = dmObjSetter.GetILGenerator();
						CountingILGenerator ilgenPrimSetter = dmPrimSetter.GetILGenerator();
						foreach (jiObjectStreamField field in fields)
						{
							FieldWrapper fw = GetFieldWrapper(field);
							if (fw == null)
							{
								continue;
							}
							fw.ResolveField();
							TypeWrapper fieldType = fw.FieldTypeWrapper;
							fieldType.Finish();
							if (fieldType.IsPrimitive)
							{
								// Getter
								ilgenPrimGetter.Emit(OpCodes.Ldarg_1);
								ilgenPrimGetter.Emit(OpCodes.Ldc_I4, field.getOffset());
								ilgenPrimGetter.Emit(OpCodes.Ldarg_0);
								fw.EmitGet(ilgenPrimGetter);
								if (fieldType == PrimitiveTypeWrapper.BYTE)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteByteMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.BOOLEAN)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteBooleanMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.CHAR)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteCharMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.SHORT)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteShortMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.INT)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteIntMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.FLOAT)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteFloatMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.LONG)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteLongMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.DOUBLE)
								{
									ilgenPrimGetter.Emit(OpCodes.Call, WriteDoubleMethod);
								}
								else
								{
									throw new jlInternalError();
								}

								// Setter
								ilgenPrimSetter.Emit(OpCodes.Ldarg_0);
								ilgenPrimSetter.Emit(OpCodes.Ldarg_1);
								ilgenPrimSetter.Emit(OpCodes.Ldc_I4, field.getOffset());
								if (fieldType == PrimitiveTypeWrapper.BYTE)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadByteMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.BOOLEAN)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadBooleanMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.CHAR)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadCharMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.SHORT)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadShortMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.INT)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadIntMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.FLOAT)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadFloatMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.LONG)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadLongMethod);
								}
								else if (fieldType == PrimitiveTypeWrapper.DOUBLE)
								{
									ilgenPrimSetter.Emit(OpCodes.Call, ReadDoubleMethod);
								}
								else
								{
									throw new jlInternalError();
								}
								fw.EmitSet(ilgenPrimSetter);
							}
							else
							{
								// Getter
								ilgenObjGetter.Emit(OpCodes.Ldarg_1);
								ilgenObjGetter.Emit(OpCodes.Ldc_I4, field.getOffset());
								ilgenObjGetter.Emit(OpCodes.Ldarg_0);
								fw.EmitGet(ilgenObjGetter);
								ilgenObjGetter.Emit(OpCodes.Stelem_Ref);

								// Setter
								ilgenObjSetter.Emit(OpCodes.Ldarg_0);
								ilgenObjSetter.Emit(OpCodes.Ldarg_1);
								ilgenObjSetter.Emit(OpCodes.Ldc_I4, field.getOffset());
								ilgenObjSetter.Emit(OpCodes.Ldelem_Ref);
								fw.FieldTypeWrapper.EmitCheckcast(null, ilgenObjSetter);
								fw.EmitSet(ilgenObjSetter);
							}
						}
						ilgenObjGetter.Emit(OpCodes.Ret);
						ilgenPrimGetter.Emit(OpCodes.Ret);
						ilgenObjSetter.Emit(OpCodes.Ret);
						ilgenPrimSetter.Emit(OpCodes.Ret);
						objFieldGetter = (ObjFieldGetterSetter)dmObjGetter.CreateDelegate(typeof(ObjFieldGetterSetter));
						primFieldGetter = (PrimFieldGetterSetter)dmPrimGetter.CreateDelegate(typeof(PrimFieldGetterSetter));
						objFieldSetter = (ObjFieldGetterSetter)dmObjSetter.CreateDelegate(typeof(ObjFieldGetterSetter));
						primFieldSetter = (PrimFieldGetterSetter)dmPrimSetter.CreateDelegate(typeof(PrimFieldGetterSetter));
					}
				}

				private static FieldWrapper GetFieldWrapper(jiObjectStreamField field)
				{
					object f = fieldField.GetValue(field);
					return f == null ? null : FieldWrapper.FromField(f);
				}

				public override jiObjectStreamField[] getFields()
				{
					return fields;
				}

				public override void getObjFieldValues(object obj, object[] objarr)
				{
					objFieldGetter(obj, objarr);
				}

				public override void setObjFieldValues(object obj, object[] objarr)
				{
					objFieldSetter(obj, objarr);
				}

				public override void getPrimFieldValues(object obj, byte[] barr)
				{
					primFieldGetter(obj, barr);
				}

				public override void setPrimFieldValues(object obj, byte[] barr)
				{
					primFieldSetter(obj, barr);
				}
			}
#endif // !FIRST_PASS

			public static object getFastFieldReflector(object fieldsObj)
			{
#if FIRST_PASS
				return null;
#else
				if (DynamicMethodSupport.Enabled)
				{
					return new FastFieldReflector((jiObjectStreamField[])fieldsObj);
				}
				else
				{
					return null;
				}
#endif
			}
a6195 4
					if (args[i] != null && !argumentTypes[i].IsInstance(args[i]))
					{
						throw new jlIllegalArgumentException();
					}
d6247 1
a6247 1
		private sealed class FastMethodAccessorImpl : srMethodAccessor
d6249 1
a6249 55
			private static readonly MethodInfo valueOfByte;
			private static readonly MethodInfo valueOfBoolean;
			private static readonly MethodInfo valueOfChar;
			private static readonly MethodInfo valueOfShort;
			private static readonly MethodInfo valueOfInt;
			private static readonly MethodInfo valueOfFloat;
			private static readonly MethodInfo valueOfLong;
			private static readonly MethodInfo valueOfDouble;
			private static readonly MethodInfo byteValue;
			private static readonly MethodInfo booleanValue;
			private static readonly MethodInfo charValue;
			private static readonly MethodInfo shortValue;
			private static readonly MethodInfo intValue;
			private static readonly MethodInfo floatValue;
			private static readonly MethodInfo longValue;
			private static readonly MethodInfo doubleValue;
			internal static readonly ConstructorInfo invocationTargetExceptionCtor;
			private delegate object Invoker(object obj, object[] args);
			private Invoker invoker;

			static FastMethodAccessorImpl()
			{
				valueOfByte = typeof(jlByte).GetMethod("valueOf", new Type[] { typeof(byte) });
				valueOfBoolean = typeof(jlBoolean).GetMethod("valueOf", new Type[] { typeof(bool) });
				valueOfChar = typeof(jlCharacter).GetMethod("valueOf", new Type[] { typeof(char) });
				valueOfShort = typeof(jlShort).GetMethod("valueOf", new Type[] { typeof(short) });
				valueOfInt = typeof(jlInteger).GetMethod("valueOf", new Type[] { typeof(int) });
				valueOfFloat = typeof(jlFloat).GetMethod("valueOf", new Type[] { typeof(float) });
				valueOfLong = typeof(jlLong).GetMethod("valueOf", new Type[] { typeof(long) });
				valueOfDouble = typeof(jlDouble).GetMethod("valueOf", new Type[] { typeof(double) });

				byteValue = typeof(jlByte).GetMethod("byteValue", Type.EmptyTypes);
				booleanValue = typeof(jlBoolean).GetMethod("booleanValue", Type.EmptyTypes);
				charValue = typeof(jlCharacter).GetMethod("charValue", Type.EmptyTypes);
				shortValue = typeof(jlShort).GetMethod("shortValue", Type.EmptyTypes);
				intValue = typeof(jlInteger).GetMethod("intValue", Type.EmptyTypes);
				floatValue = typeof(jlFloat).GetMethod("floatValue", Type.EmptyTypes);
				longValue = typeof(jlLong).GetMethod("longValue", Type.EmptyTypes);
				doubleValue = typeof(jlDouble).GetMethod("doubleValue", Type.EmptyTypes);

				invocationTargetExceptionCtor = typeof(jlrInvocationTargetException).GetConstructor(new Type[] { typeof(Exception) });
			}

			private sealed class RunClassInit
			{
				private FastMethodAccessorImpl outer;
				private TypeWrapper tw;
				private Invoker invoker;

				internal RunClassInit(FastMethodAccessorImpl outer, TypeWrapper tw, Invoker invoker)
				{
					this.outer = outer;
					this.tw = tw;
					this.invoker = invoker;
				}
d6251 3
a6253 8
				[IKVM.Attributes.HideFromJava]
				internal object invoke(object obj, object[] args)
				{
					// FXBUG a DynamicMethod that calls a static method doesn't trigger the cctor, so we do that explicitly.
					tw.RunClassInit();
					outer.invoker = invoker;
					return invoker(obj, args);
				}
d6256 2
a6257 1
			internal FastMethodAccessorImpl(jlrMethod method)
d6259 2
a6260 5
				MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(method);
				mw.DeclaringType.Finish();
				mw.ResolveMethod();
				DynamicMethod dm;
				if (mw.DeclaringType.TypeAsTBD.IsInterface)
d6262 1
a6262 2
					// FXBUG interfaces aren't allowed as owners of dynamic methods
					dm = new DynamicMethod("__<Invoker>", MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, typeof(object), new Type[] { typeof(object), typeof(object[]) }, mw.DeclaringType.TypeAsTBD.Module, true);
d6264 1
a6264 1
				else
d6266 2
a6267 9
					dm = new DynamicMethod("__<Invoker>", typeof(object), new Type[] { typeof(object), typeof(object[]) }, mw.DeclaringType.TypeAsTBD);
				}
				CountingILGenerator ilgen = dm.GetILGenerator();
				LocalBuilder ret = ilgen.DeclareLocal(typeof(object));
				if (!mw.IsStatic)
				{
					// check target for null
					ilgen.Emit(OpCodes.Ldarg_0);
					EmitHelper.NullCheck(ilgen);
d6269 2
d6272 4
a6275 14
				// check args length
				CountingLabel argsLengthOK = ilgen.DefineLabel();
				if (mw.GetParameters().Length == 0)
				{
					// zero length array may be null
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Brfalse_S, argsLengthOK);
				}
				ilgen.Emit(OpCodes.Ldarg_1);
				ilgen.Emit(OpCodes.Ldlen);
				ilgen.Emit(OpCodes.Ldc_I4, mw.GetParameters().Length);
				ilgen.Emit(OpCodes.Beq_S, argsLengthOK);
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
				ilgen.MarkLabel(argsLengthOK);
d6277 4
a6280 3
				int thisCount = mw.IsStatic ? 0 : 1;
				LocalBuilder[] args = new LocalBuilder[mw.GetParameters().Length + thisCount];
				if (!mw.IsStatic)
d6282 3
a6284 1
					args[0] = ilgen.DeclareLocal(mw.DeclaringType.TypeAsSignatureType);
d6286 1
a6286 1
				for (int i = thisCount; i < args.Length; i++)
d6288 1
a6288 2
					mw.GetParameters()[i - thisCount].Finish();
					args[i] = ilgen.DeclareLocal(mw.GetParameters()[i - thisCount].TypeAsSignatureType);
d6290 1
a6290 23
				ilgen.BeginExceptionBlock();
				if (!mw.IsStatic)
				{
					ilgen.Emit(OpCodes.Ldarg_0);
					mw.DeclaringType.EmitCheckcast(null, ilgen);
					mw.DeclaringType.EmitConvStackTypeToSignatureType(ilgen, null);
					ilgen.Emit(OpCodes.Stloc, args[0]);
				}
				for (int i = thisCount; i < args.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Ldc_I4, i - thisCount);
					ilgen.Emit(OpCodes.Ldelem_Ref);
					TypeWrapper tw = mw.GetParameters()[i - thisCount];
					EmitUnboxArg(ilgen, tw);
					tw.EmitConvStackTypeToSignatureType(ilgen, null);
					ilgen.Emit(OpCodes.Stloc, args[i]);
				}
				ilgen.BeginCatchBlock(typeof(InvalidCastException));
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
				ilgen.BeginCatchBlock(typeof(NullReferenceException));
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
				ilgen.EndExceptionBlock();
d6292 5
a6296 1
				if (mw.DeclaringType.IsInterface && mw.DeclaringType.HasStaticInitializer)
d6298 1
a6298 5
					// NOTE since Everett doesn't support adding static methods to interfaces,
					// EmitRunClassConstructor doesn't work for interface, so we do it manually.
					// TODO once we're on Whidbey, this won't be necessary anymore.
					ilgen.Emit(OpCodes.Ldtoken, mw.DeclaringType.TypeAsBaseType);
					ilgen.Emit(OpCodes.Call, typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("RunClassConstructor"));
d6300 2
a6301 4

				// this is the actual call
				ilgen.BeginExceptionBlock();
				for (int i = 0; i < args.Length; i++)
d6303 3
a6305 8
					if (i == 0 && !mw.IsStatic && (mw.DeclaringType.IsNonPrimitiveValueType || mw.DeclaringType.IsGhost))
					{
						ilgen.Emit(OpCodes.Ldloca, args[i]);
					}
					else
					{
						ilgen.Emit(OpCodes.Ldloc, args[i]);
					}
d6307 1
a6307 1
				if (mw.IsStatic)
d6309 1
a6309 1
					mw.EmitCall(ilgen);
d6311 1
a6311 1
				else
d6313 2
a6314 1
					mw.EmitCallvirt(ilgen);
d6316 2
a6317 9
				mw.ReturnType.EmitConvSignatureTypeToStackType(ilgen);
				BoxReturnValue(ilgen, mw.ReturnType);
				ilgen.Emit(OpCodes.Stloc, ret);
				ilgen.BeginCatchBlock(typeof(Exception));
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Call, Compiler.mapExceptionFastMethod);
				ilgen.Emit(OpCodes.Newobj, invocationTargetExceptionCtor);
				ilgen.Emit(OpCodes.Throw);
				ilgen.EndExceptionBlock();
d6319 5
a6323 3
				ilgen.Emit(OpCodes.Ldloc, ret);
				ilgen.Emit(OpCodes.Ret);
				invoker = (Invoker)dm.CreateDelegate(typeof(Invoker));
d6325 4
a6328 389
				if (mw.IsStatic)
				{
					invoker = new Invoker(new RunClassInit(this, mw.DeclaringType, invoker).invoke);
				}
			}

			private static void Expand(CountingILGenerator ilgen, TypeWrapper type)
			{
				if (type == PrimitiveTypeWrapper.FLOAT)
				{
					ilgen.Emit(OpCodes.Conv_R4);
				}
				else if (type == PrimitiveTypeWrapper.LONG)
				{
					ilgen.Emit(OpCodes.Conv_I8);
				}
				else if (type == PrimitiveTypeWrapper.DOUBLE)
				{
					ilgen.Emit(OpCodes.Conv_R8);
				}
			}

			internal static void EmitUnboxArg(CountingILGenerator ilgen, TypeWrapper type)
			{
				if (type == PrimitiveTypeWrapper.BYTE)
				{
					ilgen.Emit(OpCodes.Castclass, typeof(jlByte));
					ilgen.Emit(OpCodes.Call, byteValue);
				}
				else if (type == PrimitiveTypeWrapper.BOOLEAN)
				{
					ilgen.Emit(OpCodes.Castclass, typeof(jlBoolean));
					ilgen.Emit(OpCodes.Call, booleanValue);
				}
				else if (type == PrimitiveTypeWrapper.CHAR)
				{
					ilgen.Emit(OpCodes.Castclass, typeof(jlCharacter));
					ilgen.Emit(OpCodes.Call, charValue);
				}
				else if (type == PrimitiveTypeWrapper.SHORT
					|| type == PrimitiveTypeWrapper.INT
					|| type == PrimitiveTypeWrapper.FLOAT
					|| type == PrimitiveTypeWrapper.LONG
					|| type == PrimitiveTypeWrapper.DOUBLE)
				{
					ilgen.Emit(OpCodes.Dup);
					ilgen.Emit(OpCodes.Isinst, typeof(jlByte));
					CountingLabel next = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Brfalse_S, next);
					ilgen.Emit(OpCodes.Call, byteValue);
					ilgen.Emit(OpCodes.Conv_I1);
					Expand(ilgen, type);
					CountingLabel done = ilgen.DefineLabel();
					ilgen.Emit(OpCodes.Br_S, done);
					ilgen.MarkLabel(next);
					if (type == PrimitiveTypeWrapper.SHORT)
					{
						ilgen.Emit(OpCodes.Castclass, typeof(jlShort));
						ilgen.Emit(OpCodes.Call, shortValue);
					}
					else
					{
						ilgen.Emit(OpCodes.Dup);
						ilgen.Emit(OpCodes.Isinst, typeof(jlShort));
						next = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brfalse_S, next);
						ilgen.Emit(OpCodes.Call, shortValue);
						Expand(ilgen, type);
						ilgen.Emit(OpCodes.Br_S, done);
						ilgen.MarkLabel(next);
						ilgen.Emit(OpCodes.Dup);
						ilgen.Emit(OpCodes.Isinst, typeof(jlCharacter));
						next = ilgen.DefineLabel();
						ilgen.Emit(OpCodes.Brfalse_S, next);
						ilgen.Emit(OpCodes.Call, charValue);
						Expand(ilgen, type);
						ilgen.Emit(OpCodes.Br_S, done);
						ilgen.MarkLabel(next);
						if (type == PrimitiveTypeWrapper.INT)
						{
							ilgen.Emit(OpCodes.Castclass, typeof(jlInteger));
							ilgen.Emit(OpCodes.Call, intValue);
						}
						else
						{
							ilgen.Emit(OpCodes.Dup);
							ilgen.Emit(OpCodes.Isinst, typeof(jlInteger));
							next = ilgen.DefineLabel();
							ilgen.Emit(OpCodes.Brfalse_S, next);
							ilgen.Emit(OpCodes.Call, intValue);
							Expand(ilgen, type);
							ilgen.Emit(OpCodes.Br_S, done);
							ilgen.MarkLabel(next);
							if (type == PrimitiveTypeWrapper.LONG)
							{
								ilgen.Emit(OpCodes.Castclass, typeof(jlLong));
								ilgen.Emit(OpCodes.Call, longValue);
							}
							else
							{
								ilgen.Emit(OpCodes.Dup);
								ilgen.Emit(OpCodes.Isinst, typeof(jlLong));
								next = ilgen.DefineLabel();
								ilgen.Emit(OpCodes.Brfalse_S, next);
								ilgen.Emit(OpCodes.Call, longValue);
								Expand(ilgen, type);
								ilgen.Emit(OpCodes.Br_S, done);
								ilgen.MarkLabel(next);
								if (type == PrimitiveTypeWrapper.FLOAT)
								{
									ilgen.Emit(OpCodes.Castclass, typeof(jlFloat));
									ilgen.Emit(OpCodes.Call, floatValue);
								}
								else if (type == PrimitiveTypeWrapper.DOUBLE)
								{
									ilgen.Emit(OpCodes.Dup);
									ilgen.Emit(OpCodes.Isinst, typeof(jlFloat));
									next = ilgen.DefineLabel();
									ilgen.Emit(OpCodes.Brfalse_S, next);
									ilgen.Emit(OpCodes.Call, floatValue);
									ilgen.Emit(OpCodes.Br_S, done);
									ilgen.MarkLabel(next);
									ilgen.Emit(OpCodes.Castclass, typeof(jlDouble));
									ilgen.Emit(OpCodes.Call, doubleValue);
								}
								else
								{
									throw new InvalidOperationException();
								}
							}
						}
					}
					ilgen.MarkLabel(done);
				}
				else
				{
					type.EmitCheckcast(null, ilgen);
				}
			}

			private static void BoxReturnValue(CountingILGenerator ilgen, TypeWrapper type)
			{
				if (type == PrimitiveTypeWrapper.VOID)
				{
					ilgen.Emit(OpCodes.Ldnull);
				}
				else if (type == PrimitiveTypeWrapper.BYTE)
				{
					ilgen.Emit(OpCodes.Call, valueOfByte);
				}
				else if (type == PrimitiveTypeWrapper.BOOLEAN)
				{
					ilgen.Emit(OpCodes.Call, valueOfBoolean);
				}
				else if (type == PrimitiveTypeWrapper.CHAR)
				{
					ilgen.Emit(OpCodes.Call, valueOfChar);
				}
				else if (type == PrimitiveTypeWrapper.SHORT)
				{
					ilgen.Emit(OpCodes.Call, valueOfShort);
				}
				else if (type == PrimitiveTypeWrapper.INT)
				{
					ilgen.Emit(OpCodes.Call, valueOfInt);
				}
				else if (type == PrimitiveTypeWrapper.FLOAT)
				{
					ilgen.Emit(OpCodes.Call, valueOfFloat);
				}
				else if (type == PrimitiveTypeWrapper.LONG)
				{
					ilgen.Emit(OpCodes.Call, valueOfLong);
				}
				else if (type == PrimitiveTypeWrapper.DOUBLE)
				{
					ilgen.Emit(OpCodes.Call, valueOfDouble);
				}
			}

			[IKVM.Attributes.HideFromJava]
			public object invoke(object obj, object[] args)
			{
				return invoker(obj, args);
			}
		}

		private sealed class ConstructorAccessorImpl : srConstructorAccessor
		{
			private readonly MethodWrapper mw;

			internal ConstructorAccessorImpl(jlrConstructor constructor)
			{
				mw = MethodWrapper.FromMethodOrConstructor(constructor);
			}

			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
			{
				args = ConvertArgs(mw.GetParameters(), args);
				try
				{
					return mw.Invoke(null, args, false);
				}
				catch (MethodAccessException x)
				{
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
				}
			}
		}

		private sealed class FastConstructorAccessorImpl : srConstructorAccessor
		{
			private delegate object Invoker(object[] args);
			private Invoker invoker;

			internal FastConstructorAccessorImpl(jlrConstructor constructor)
			{
				MethodWrapper mw = MethodWrapper.FromMethodOrConstructor(constructor);
				mw.DeclaringType.Finish();
				mw.ResolveMethod();
				DynamicMethod dm = new DynamicMethod("__<Invoker>", typeof(object), new Type[] { typeof(object), typeof(object[]) }, mw.DeclaringType.TypeAsTBD);
				CountingILGenerator ilgen = dm.GetILGenerator();
				LocalBuilder ret = ilgen.DeclareLocal(typeof(object));

				// check args length
				CountingLabel argsLengthOK = ilgen.DefineLabel();
				if (mw.GetParameters().Length == 0)
				{
					// zero length array may be null
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Brfalse_S, argsLengthOK);
				}
				ilgen.Emit(OpCodes.Ldarg_1);
				ilgen.Emit(OpCodes.Ldlen);
				ilgen.Emit(OpCodes.Ldc_I4, mw.GetParameters().Length);
				ilgen.Emit(OpCodes.Beq_S, argsLengthOK);
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
				ilgen.MarkLabel(argsLengthOK);

				LocalBuilder[] args = new LocalBuilder[mw.GetParameters().Length];
				for (int i = 0; i < args.Length; i++)
				{
					mw.GetParameters()[i].Finish();
					args[i] = ilgen.DeclareLocal(mw.GetParameters()[i].TypeAsSignatureType);
				}
				ilgen.BeginExceptionBlock();
				for (int i = 0; i < args.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldarg_1);
					ilgen.Emit(OpCodes.Ldc_I4, i);
					ilgen.Emit(OpCodes.Ldelem_Ref);
					TypeWrapper tw = mw.GetParameters()[i];
					FastMethodAccessorImpl.EmitUnboxArg(ilgen, tw);
					tw.EmitConvStackTypeToSignatureType(ilgen, null);
					ilgen.Emit(OpCodes.Stloc, args[i]);
				}
				ilgen.BeginCatchBlock(typeof(InvalidCastException));
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
				ilgen.BeginCatchBlock(typeof(NullReferenceException));
				EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
				ilgen.EndExceptionBlock();

				// this is the actual call
				ilgen.BeginExceptionBlock();
				for (int i = 0; i < args.Length; i++)
				{
					ilgen.Emit(OpCodes.Ldloc, args[i]);
				}
				mw.EmitNewobj(ilgen);
				ilgen.Emit(OpCodes.Stloc, ret);
				ilgen.BeginCatchBlock(typeof(Exception));
				ilgen.Emit(OpCodes.Ldc_I4_1);
				ilgen.Emit(OpCodes.Call, Compiler.mapExceptionFastMethod);
				ilgen.Emit(OpCodes.Newobj, FastMethodAccessorImpl.invocationTargetExceptionCtor);
				ilgen.Emit(OpCodes.Throw);
				ilgen.EndExceptionBlock();

				ilgen.Emit(OpCodes.Ldloc, ret);
				ilgen.Emit(OpCodes.Ret);
				invoker = (Invoker)dm.CreateDelegate(typeof(Invoker));
			}

			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
			{
				return invoker(args);
			}
		}

		private sealed class SerializationConstructorAccessorImpl : srConstructorAccessor
		{
			private Type type;
			private MethodWrapper constructor;

			internal SerializationConstructorAccessorImpl(jlrConstructor constructorToCall, jlClass classToInstantiate)
			{
				constructor = MethodWrapper.FromMethodOrConstructor(constructorToCall);
				try
				{
					TypeWrapper wrapper = TypeWrapper.FromClass(classToInstantiate);
					wrapper.Finish();
					type = wrapper.TypeAsBaseType;
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
			}

			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
			{
				// if we're trying to deserialize a string as a TC_OBJECT, just return an emtpy string (Sun does the same)
				if (type == typeof(string))
				{
					return "";
				}
				args = ConvertArgs(constructor.GetParameters(), args);
				try
				{
					object obj = FormatterServices.GetUninitializedObject(type);
					constructor.Invoke(obj, args, false);
					return obj;
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				catch (MethodAccessException x)
				{
					// this can happen if we're calling a non-public method and the call stack doesn't have ReflectionPermission.MemberAccess
					throw new jlIllegalAccessException().initCause(x);
				}
			}
		}

		private sealed class FastSerializationConstructorAccessorImpl : srConstructorAccessor
		{
			private static readonly MethodInfo GetTypeFromHandleMethod = typeof(Type).GetMethod("GetTypeFromHandle", new Type[] { typeof(RuntimeTypeHandle) });
			private static readonly MethodInfo GetUninitializedObjectMethod = typeof(FormatterServices).GetMethod("GetUninitializedObject", new Type[] { typeof(Type) });
			private delegate object InvokeCtor();
			private InvokeCtor invoker;

			internal FastSerializationConstructorAccessorImpl(jlrConstructor constructorToCall, jlClass classToInstantiate)
			{
				MethodWrapper constructor = MethodWrapper.FromMethodOrConstructor(constructorToCall);
				constructor.Link();
				constructor.ResolveMethod();
				Type type;
				try
				{
					TypeWrapper wrapper = TypeWrapper.FromClass(classToInstantiate);
					wrapper.Finish();
					type = wrapper.TypeAsBaseType;
				}
				catch (RetargetableJavaException x)
				{
					throw x.ToJava();
				}
				DynamicMethod dm = new DynamicMethod("__<SerializationCtor>", typeof(object), null, constructor.DeclaringType.TypeAsBaseType);
				CountingILGenerator ilgen = dm.GetILGenerator();
				ilgen.Emit(OpCodes.Ldtoken, type);
				ilgen.Emit(OpCodes.Call, GetTypeFromHandleMethod);
				ilgen.Emit(OpCodes.Call, GetUninitializedObjectMethod);
				ilgen.Emit(OpCodes.Dup);
				constructor.EmitCall(ilgen);
				ilgen.Emit(OpCodes.Ret);
				invoker = (InvokeCtor)dm.CreateDelegate(typeof(InvokeCtor));
			}

			[IKVM.Attributes.HideFromJava]
			public object newInstance(object[] args)
			{
				return invoker();
			}
		}

		private abstract class FieldAccessorImplBase : srFieldAccessor
		{
			protected readonly FieldWrapper fw;
			protected readonly bool isFinal;
			private bool runInit;

			private FieldAccessorImplBase(jlrField field, bool overrideAccessCheck)
			{
				fw = FieldWrapper.FromField(field);
				isFinal = (!overrideAccessCheck || fw.IsStatic) && fw.IsFinal;
d6354 4
a6364 4
				if (isFinal)
				{
					throw new jlIllegalAccessException();
				}
d6459 1
a6459 1
			private class ObjectField : FieldAccessorImplBase
d6484 1
a6484 1
			private class ByteField : FieldAccessorImplBase
d6496 1
a6496 1
				public sealed override short getShort(object obj)
d6501 1
a6501 1
				public sealed override int getInt(object obj)
d6506 1
a6506 1
				public sealed override long getLong(object obj)
d6511 1
a6511 1
				public sealed override float getFloat(object obj)
d6516 1
a6516 1
				public sealed override double getDouble(object obj)
d6521 1
a6521 1
				public sealed override object get(object obj)
d6526 1
a6526 1
				public sealed override void set(object obj, object val)
d6541 1
a6541 1
			private class BooleanField : FieldAccessorImplBase
d6553 1
a6553 1
				public sealed override object get(object obj)
d6558 1
a6558 1
				public sealed override void set(object obj, object val)
d6573 1
a6573 1
			private class CharField : FieldAccessorImplBase
d6585 1
a6585 1
				public sealed override int getInt(object obj)
d6590 1
a6590 1
				public sealed override long getLong(object obj)
d6595 1
a6595 1
				public sealed override float getFloat(object obj)
d6600 1
a6600 1
				public sealed override double getDouble(object obj)
d6605 1
a6605 1
				public sealed override object get(object obj)
d6610 1
a6610 1
				public sealed override void set(object obj, object val)
d6624 1
a6624 1
			private class ShortField : FieldAccessorImplBase
d6636 1
a6636 1
				public sealed override int getInt(object obj)
d6641 1
a6641 1
				public sealed override long getLong(object obj)
d6646 1
a6646 1
				public sealed override float getFloat(object obj)
d6651 1
a6651 1
				public sealed override double getDouble(object obj)
d6656 1
a6656 1
				public sealed override object get(object obj)
d6661 1
a6661 1
				public sealed override void set(object obj, object val)
d6670 1
a6670 1
				public sealed override void setByte(object obj, byte b)
d6681 1
a6681 1
			private class IntField : FieldAccessorImplBase
d6693 1
a6693 1
				public sealed override long getLong(object obj)
d6698 1
a6698 1
				public sealed override float getFloat(object obj)
d6703 1
a6703 1
				public sealed override double getDouble(object obj)
d6708 1
a6708 1
				public sealed override object get(object obj)
d6713 1
a6713 1
				public sealed override void set(object obj, object val)
d6725 1
a6725 1
				public sealed override void setByte(object obj, byte b)
d6730 1
a6730 1
				public sealed override void setChar(object obj, char c)
d6735 1
a6735 1
				public sealed override void setShort(object obj, short s)
d6746 1
a6746 1
			private class FloatField : FieldAccessorImplBase
d6758 1
a6758 1
				public sealed override double getDouble(object obj)
d6763 1
a6763 1
				public sealed override object get(object obj)
d6768 1
a6768 1
				public sealed override void set(object obj, object val)
d6782 1
a6782 1
				public sealed override void setByte(object obj, byte b)
d6787 1
a6787 1
				public sealed override void setChar(object obj, char c)
d6792 1
a6792 1
				public sealed override void setShort(object obj, short s)
d6797 1
a6797 1
				public sealed override void setInt(object obj, int i)
d6802 1
a6802 1
				public sealed override void setLong(object obj, long l)
d6813 1
a6813 1
			private class LongField : FieldAccessorImplBase
d6825 1
a6825 1
				public sealed override float getFloat(object obj)
d6830 1
a6830 1
				public sealed override double getDouble(object obj)
d6835 1
a6835 1
				public sealed override object get(object obj)
d6845 1
a6845 1
				public sealed override void set(object obj, object val)
d6858 1
a6858 1
				public sealed override void setByte(object obj, byte b)
d6863 1
a6863 1
				public sealed override void setChar(object obj, char c)
d6868 1
a6868 1
				public sealed override void setShort(object obj, short s)
d6873 1
a6873 1
				public sealed override void setInt(object obj, int i)
d6879 1
a6879 1
			private class DoubleField : FieldAccessorImplBase
d6947 1
a6947 1
			private static Delegate GenerateFastGetter(Type delegateType, Type fieldType, FieldWrapper fw)
d6949 2
a6950 5
				fw.FieldTypeWrapper.Finish();
				fw.DeclaringType.Finish();
				fw.ResolveField();
				DynamicMethod dm;
				if (fw.DeclaringType.TypeAsBaseType.IsInterface)
d6952 1
a6952 49
					// FXBUG interfaces aren't allowed as owners of dynamic methods
					dm = new DynamicMethod("__<Getter>", MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, fieldType, new Type[] { typeof(object) }, fw.DeclaringType.TypeAsBaseType.Module, true);
				}
				else
				{
					dm = new DynamicMethod("__<Getter>", fieldType, new Type[] { typeof(object) }, fw.DeclaringType.TypeAsBaseType);
				}
				CountingILGenerator ilgen = dm.GetILGenerator();
				if (fw.IsStatic)
				{
					fw.EmitGet(ilgen);
				}
				else
				{
					ilgen.BeginExceptionBlock();
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Castclass, fw.DeclaringType.TypeAsTBD);
					fw.EmitGet(ilgen);
					fw.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilgen);
					LocalBuilder local = ilgen.DeclareLocal(fieldType);
					ilgen.Emit(OpCodes.Stloc, local);
					ilgen.BeginCatchBlock(typeof(InvalidCastException));
					EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
					ilgen.EndExceptionBlock();
					ilgen.Emit(OpCodes.Ldloc, local);
				}
				ilgen.Emit(OpCodes.Ret);
				return dm.CreateDelegate(delegateType);
			}

			private static Delegate GenerateFastSetter(Type delegateType, Type fieldType, FieldWrapper fw)
			{
				fw.FieldTypeWrapper.Finish();
				fw.DeclaringType.Finish();
				fw.ResolveField();
				DynamicMethod dm;
				if (fw.DeclaringType.TypeAsBaseType.IsInterface)
				{
					// FXBUG interfaces aren't allowed as owners of dynamic methods
					dm = new DynamicMethod("__<Setter>", MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, null, new Type[] { typeof(object), fieldType }, fw.DeclaringType.TypeAsBaseType.Module, true);
				}
				else
				{
					dm = new DynamicMethod("__<Setter>", null, new Type[] { typeof(object), fieldType }, fw.DeclaringType.TypeAsBaseType);
				}
				CountingILGenerator ilgen = dm.GetILGenerator();
				if (fw.IsStatic)
				{
					if (fieldType == typeof(object))
d6954 1
a6954 450
						ilgen.BeginExceptionBlock();
						ilgen.Emit(OpCodes.Ldarg_1);
						fw.FieldTypeWrapper.EmitConvStackTypeToSignatureType(ilgen, null);
						fw.EmitSet(ilgen);
						ilgen.BeginCatchBlock(typeof(InvalidCastException));
						EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
						ilgen.EndExceptionBlock();
					}
					else
					{
						ilgen.Emit(OpCodes.Ldarg_1);
						fw.EmitSet(ilgen);
					}
				}
				else
				{
					ilgen.BeginExceptionBlock();
					ilgen.Emit(OpCodes.Ldarg_0);
					ilgen.Emit(OpCodes.Castclass, fw.DeclaringType.TypeAsTBD);
					ilgen.Emit(OpCodes.Ldarg_1);
					fw.FieldTypeWrapper.EmitConvStackTypeToSignatureType(ilgen, null);
					fw.EmitSet(ilgen);
					ilgen.BeginCatchBlock(typeof(InvalidCastException));
					EmitHelper.Throw(ilgen, "java.lang.IllegalArgumentException");
					ilgen.EndExceptionBlock();
				}
				ilgen.Emit(OpCodes.Ret);
				return dm.CreateDelegate(delegateType);
			}

			private sealed class FastByteFieldAccessor : ByteField
			{
				private delegate void Setter(object obj, byte value);
				private delegate byte Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastByteFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private byte lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(byte), fw);
					return getter(obj);
				}

				private void lazySet(object obj, byte value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(byte), fw);
					setter(obj, value);
				}

				public override byte getByte(object obj)
				{
					return getter(obj);
				}

				public override void setByte(object obj, byte value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastBooleanFieldAccessor : BooleanField
			{
				private delegate void Setter(object obj, bool value);
				private delegate bool Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastBooleanFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private bool lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(bool), fw);
					return getter(obj);
				}

				private void lazySet(object obj, bool value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(bool), fw);
					setter(obj, value);
				}

				public override bool getBoolean(object obj)
				{
					return getter(obj);
				}

				public override void setBoolean(object obj, bool value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastCharFieldAccessor : CharField
			{
				private delegate void Setter(object obj, char value);
				private delegate char Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastCharFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private char lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(char), fw);
					return getter(obj);
				}

				private void lazySet(object obj, char value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(char), fw);
					setter(obj, value);
				}

				public override char getChar(object obj)
				{
					return getter(obj);
				}

				public override void setChar(object obj, char value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastShortFieldAccessor : ShortField
			{
				private delegate void Setter(object obj, short value);
				private delegate short Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastShortFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private short lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(short), fw);
					return getter(obj);
				}

				private void lazySet(object obj, short value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(short), fw);
					setter(obj, value);
				}

				public override short getShort(object obj)
				{
					return getter(obj);
				}

				public override void setShort(object obj, short value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastIntegerFieldAccessor : IntField
			{
				private delegate void Setter(object obj, int value);
				private delegate int Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastIntegerFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private int lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(int), fw);
					return getter(obj);
				}

				private void lazySet(object obj, int value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(int), fw);
					setter(obj, value);
				}

				public override int getInt(object obj)
				{
					return getter(obj);
				}

				public override void setInt(object obj, int value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastFloatFieldAccessor : FloatField
			{
				private delegate void Setter(object obj, float value);
				private delegate float Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastFloatFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private float lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(float), fw);
					return getter(obj);
				}

				private void lazySet(object obj, float value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(float), fw);
					setter(obj, value);
				}

				public override float getFloat(object obj)
				{
					return getter(obj);
				}

				public override void setFloat(object obj, float value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastLongFieldAccessor : LongField
			{
				private delegate void Setter(object obj, long value);
				private delegate long Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastLongFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private long lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(long), fw);
					return getter(obj);
				}

				private void lazySet(object obj, long value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(long), fw);
					setter(obj, value);
				}

				public override long getLong(object obj)
				{
					return getter(obj);
				}

				public override void setLong(object obj, long value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastDoubleFieldAccessor : DoubleField
			{
				private delegate void Setter(object obj, double value);
				private delegate double Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastDoubleFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private double lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(double), fw);
					return getter(obj);
				}

				private void lazySet(object obj, double value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(double), fw);
					setter(obj, value);
				}

				public override double getDouble(object obj)
				{
					return getter(obj);
				}

				public override void setDouble(object obj, double value)
				{
					setter(obj, value);
				}
			}

			private sealed class FastObjectFieldAccessor : ObjectField
			{
				private delegate void Setter(object obj, object value);
				private delegate object Getter(object obj);
				private Setter setter;
				private Getter getter;

				internal FastObjectFieldAccessor(jlrField field, bool overrideAccessCheck)
					: base(field, overrideAccessCheck)
				{
					setter = new Setter(lazySet);
					getter = new Getter(lazyGet);
				}

				private object lazyGet(object obj)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					getter = (Getter)GenerateFastGetter(typeof(Getter), typeof(object), fw);
					return getter(obj);
				}

				private void lazySet(object obj, object value)
				{
					// FXBUG it appears that a ldsfld/stsfld in a DynamicMethod doesn't trigger the class constructor
					fw.DeclaringType.RunClassInit();
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					setter = (Setter)GenerateFastSetter(typeof(Setter), typeof(object), fw);
					setter(obj, value);
				}

				public override object get(object obj)
				{
					return getter(obj);
				}

				public override void set(object obj, object value)
				{
					setter(obj, value);
				}
			}

			internal static FieldAccessorImplBase Create(jlrField field, bool overrideAccessCheck)
			{
				jlClass type = field.getType();
				if (type.isPrimitive())
				{
					if (type == jlByte.TYPE)
					{
						if (DynamicMethodSupport.Enabled)
						{
							return new FastByteFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new ByteField(field, overrideAccessCheck);
						}
d6958 1
a6958 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastBooleanFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new BooleanField(field, overrideAccessCheck);
						}
d6962 1
a6962 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastCharFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new CharField(field, overrideAccessCheck);
						}
d6966 1
a6966 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastShortFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new ShortField(field, overrideAccessCheck);
						}
d6970 1
a6970 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastIntegerFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new IntField(field, overrideAccessCheck);
						}
d6974 1
a6974 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastFloatFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new FloatField(field, overrideAccessCheck);
						}
d6978 1
a6978 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastLongFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new LongField(field, overrideAccessCheck);
						}
d6982 1
a6982 8
						if (DynamicMethodSupport.Enabled)
						{
							return new FastDoubleFieldAccessor(field, overrideAccessCheck);
						}
						else
						{
							return new DoubleField(field, overrideAccessCheck);
						}
d6988 1
a6988 8
					if (DynamicMethodSupport.Enabled)
					{
						return new FastObjectFieldAccessor(field, overrideAccessCheck);
					}
					else
					{
						return new ObjectField(field, overrideAccessCheck);
					}
d7008 1
a7008 10
			jlrMethod m = (jlrMethod)method;
			if (DynamicMethodSupport.Enabled)
			{
				TypeWrapper tw = TypeWrapper.FromClass(m.getDeclaringClass());
				if (!tw.IsDynamicOnly && !tw.IsRemapped)
				{
					return new FastMethodAccessorImpl(m);
				}
			}
			return new MethodAccessorImpl(m);
d7017 1
a7017 10
			jlrConstructor cons = (jlrConstructor)constructor;
			if (DynamicMethodSupport.Enabled
				&& !TypeWrapper.FromClass(cons.getDeclaringClass()).IsDynamicOnly)
			{
				return new FastConstructorAccessorImpl(cons);
			}
			else
			{
				return new ConstructorAccessorImpl(cons);
			}
d7026 1
a7026 12
			jlrConstructor cons = (jlrConstructor)constructorToCall;
			if (DynamicMethodSupport.Enabled
				&& cons.getParameterTypes().Length == 0
				&& !TypeWrapper.FromClass(cons.getDeclaringClass()).IsDynamicOnly
				&& !TypeWrapper.FromClass(classToInstantiate).IsDynamicOnly)
			{
				return new FastSerializationConstructorAccessorImpl(cons, (jlClass)classToInstantiate);
			}
			else
			{
				return new SerializationConstructorAccessorImpl(cons, (jlClass)classToInstantiate);
			}
@


1.53.2.3
log
@Backported fixes. Changed version to 0.36.0.4.
@
text
@a7857 1
					fw.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilgen);
@


1.53.2.4
log
@Backported fixes and changed version to 0.36.0.5
@
text
@d2666 1
a2666 4
				// the 0x7FFF mask comes from JVM_ACC_WRITTEN_FLAGS in hotspot\src\share\vm\utilities\accessFlags.hpp
				// masking out ACC_SUPER comes from instanceKlass::compute_modifier_flags() in hotspot\src\share\vm\oops\instanceKlass.cpp
				const int mask = 0x7FFF & (int)~IKVM.Attributes.Modifiers.Super;
				return (int)TypeWrapper.FromClass(thisClass).ReflectiveModifiers & mask;
d2732 1
a2732 1
				if (pd == null)
d2734 2
a2735 4
					// The protection domain for statically compiled code is created lazily (not at java.lang.Class creation time),
					// to work around boot strap issues.
					AssemblyClassLoader acl = wrapper.GetClassLoader() as AssemblyClassLoader;
					if (acl != null)
d2737 8
a2744 1
						pd = acl.GetProtectionDomain();
d6191 1
a6191 1
		public static object getAssemblyClassLoader(Assembly asm, object extcl)
d6193 1
a6193 5
			if (extcl == null || asm.IsDefined(typeof(IKVM.Attributes.CustomAssemblyClassLoaderAttribute), false))
			{
				return ClassLoaderWrapper.GetAssemblyClassLoader(asm).GetJavaClassLoader();
			}
			return null;
d7054 1
a7054 1
				DynamicMethod dm = new DynamicMethod("__<Invoker>", typeof(object), new Type[] { typeof(object[]) }, mw.DeclaringType.TypeAsTBD);
d7063 1
a7063 1
					ilgen.Emit(OpCodes.Ldarg_0);
d7066 1
a7066 1
				ilgen.Emit(OpCodes.Ldarg_0);
d7082 1
a7082 1
					ilgen.Emit(OpCodes.Ldarg_0);
@


1.53.2.5
log
@- Changed version to 0.36.0.7
- Fixed serialization bug
@
text
@a40 1
using SystemConsole = System.Console;
a757 1
								fw.FieldTypeWrapper.EmitConvSignatureTypeToStackType(ilgenObjGetter);
a765 1
								fw.FieldTypeWrapper.EmitConvStackTypeToSignatureType(ilgenObjSetter, null);
@


1.53.2.6
log
@Added support to Class.forName() for loading Java types with assembly qualified type names.
@
text
@d2531 1
a2531 1
						tw = ClassLoaderWrapper.GetWrapperFromType(type);
@


1.53.2.7
log
@Added workaround for .NET 1.1 bug in Directory.CreateDirectory().
@
text
@a1588 5
					// FXBUG on .NET 1.1 and Mono CreateDirectory doesn't throw an IOException if a file with the same name already exists
					if (System.IO.File.Exists(path))
					{
						return false;
					}
@


1.53.2.8
log
@Set the thread context class loader for threads started from .NET.
@
text
@a3691 1
			private static readonly FieldInfo threadContextClassLoaderField;
a3912 1
				threadContextClassLoaderField = typeof(jlThread).GetField("contextClassLoader", BindingFlags.Instance | BindingFlags.NonPublic);
a3997 10
#if !FIRST_PASS
			sealed class GetSystemClassLoaderAction : jsPrivilegedAction
			{
				public object run()
				{
					return jlClassLoader.getSystemClassLoader();
				}
			}
#endif

a4015 4
				if (addToGroup)
				{
					threadContextClassLoaderField.SetValue(thread, jsAccessController.doPrivileged(new GetSystemClassLoaderAction()));
				}
@


1.53.2.9
log
@Back ported the following fixes:
- Remapped exceptions with explicit remapping code now call suppressFullInStackTrace (to make sure the proper stack trace is captured).
- Fixed memory mapped file bug (mapping at a non-zero offset would fail).
- Fixed .NET type name mangling for nested types that contain a dot in their name (which the C# 3.0 compiler generates for some helper types).
- Fixed bug in deserialization of double arrays.
- Fixed path canonicalization to swallow NotSupportedException (thrown when the path contains a colon, other than the one following the drive letter).
@
text
@d408 1
a408 1
					srcpos += 8;
a1205 3
				catch (System.NotSupportedException)
				{
				}
@


1.53.2.10
log
@Back ported various fixes:
- Changed version to 0.36.0.13.
- Fixed ikvmc not to open the key file for write access.
- Added more efficient float/double to/from int/long bits converters.
- Fixed libikvm-native.so build to include reference to gmodule-2.0 library.
- Fixed ikvmc not to open the key file for write access.
- Fixed Graphics2D.rotate() to convert rotation angle from radians (Java) to degrees (.NET).
- Applied awt patch #1979656 by Daniel Wilson.
- Fixed three String bugs found by OpenJDK string tests.
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
- Removed incorrect DataFormatException thrown in java.util.zip.InflaterHuffmanTree.
- Fixed #2001802 contributed by Andy Malakov.
- Fixed #2001799.
- Fixed #2006953.
- Made finalize() and clone() methods in cli.System.Object and cli.System.Exception final.
@
text
@d2 1
a2 1
  Copyright (C) 2007, 2008 Jeroen Frijters
d396 1
a396 2
				IKVM.Runtime.FloatConverter converter = new IKVM.Runtime.FloatConverter();
				for (int i = 0; i < nfloats; i++)
d398 2
a399 5
					int v = src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					dst[dstpos++] = IKVM.Runtime.FloatConverter.ToFloat(v, ref converter);
d405 1
a405 2
				IKVM.Runtime.DoubleConverter converter = new IKVM.Runtime.DoubleConverter();
				for (int i = 0; i < ndoubles; i++)
d407 2
a408 9
					long v = src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					v = (v << 8) | src[srcpos++];
					dst[dstpos++] = IKVM.Runtime.DoubleConverter.ToDouble(v, ref converter);
d448 1
a448 2
				IKVM.Runtime.FloatConverter converter = new IKVM.Runtime.FloatConverter();
				for (int i = 0; i < nfloats; i++)
d450 2
a451 5
					int v = IKVM.Runtime.FloatConverter.ToInt(src[srcpos++], ref converter);
					dst[dstpos++] = (byte)(v >> 24);
					dst[dstpos++] = (byte)(v >> 16);
					dst[dstpos++] = (byte)(v >> 8);
					dst[dstpos++] = (byte)(v >> 0);
d457 1
a457 2
				IKVM.Runtime.DoubleConverter converter = new IKVM.Runtime.DoubleConverter();
				for (int i = 0; i < ndoubles; i++)
d459 2
a460 9
					long v = IKVM.Runtime.DoubleConverter.ToLong(src[srcpos++], ref converter);
					dst[dstpos++] = (byte)(v >> 56);
					dst[dstpos++] = (byte)(v >> 48);
					dst[dstpos++] = (byte)(v >> 40);
					dst[dstpos++] = (byte)(v >> 32);
					dst[dstpos++] = (byte)(v >> 24);
					dst[dstpos++] = (byte)(v >> 16);
					dst[dstpos++] = (byte)(v >> 8);
					dst[dstpos++] = (byte)(v >> 0);
d3231 1
a3231 2
				IKVM.Runtime.DoubleConverter converter = new IKVM.Runtime.DoubleConverter();
				return IKVM.Runtime.DoubleConverter.ToLong(value, ref converter);
d3236 1
a3236 2
				IKVM.Runtime.DoubleConverter converter = new IKVM.Runtime.DoubleConverter();
				return IKVM.Runtime.DoubleConverter.ToDouble(bits, ref converter);
d3244 1
a3244 2
				IKVM.Runtime.FloatConverter converter = new IKVM.Runtime.FloatConverter();
				return IKVM.Runtime.FloatConverter.ToInt(value, ref converter);
d3249 1
a3249 2
				IKVM.Runtime.FloatConverter converter = new IKVM.Runtime.FloatConverter();
				return IKVM.Runtime.FloatConverter.ToFloat(bits, ref converter);
@


1.52
log
@Implemented sun.net.dns.ResolverConfigurationImpl "native" methods.
@
text
@a621 7
				System.IO.FileInfo fi = new System.IO.FileInfo(path);
				if (fi.DirectoryName == null)
				{
					return path.Length > 1 && path[1] == ':' ? path.ToUpper() : path;
				}
				string dir = CanonicalizePath(fi.DirectoryName);
				string name = fi.Name;
d624 2
a625 2
					string[] arr = System.IO.Directory.GetFileSystemEntries(dir, name);
					if (arr.Length == 1)
d627 1
a627 1
						name = arr[0];
d629 17
d647 4
a650 1
				catch (System.IO.DirectoryNotFoundException)
d653 1
a653 1
				return System.IO.Path.Combine(dir, name);
d658 3
a671 5
				catch (System.IO.IOException)
				{
					return path;
				}
#if !FIRST_PASS
d938 1
a941 1
					System.IO.FileSystemInfo fileInfo;
d974 16
@


1.51
log
@Implemented path canonicalization.
@
text
@d116 1
d656 1
a656 1
				catch (System.IO.IOException x)
d5832 13
a5844 1
			throw new NotImplementedException();
d5849 26
a5874 1
			throw new NotImplementedException();
d5879 2
a5880 1
			throw new NotImplementedException();
@


1.50
log
@Implemented Inet4Address.isReachable().
@
text
@d619 23
d644 12
a655 1
				if (VirtualFileSystem.IsVirtualFS(path))
d659 6
a664 1
				return GetFileInfo(path).FullName;
d669 1
a669 2
				// TODO what's this all about?
				return GetFileInfo(pathWithCanonicalPrefix).FullName;
@


1.49
log
@Implemented Thread.WaitUntilLastJniThread() (used by JNI method DestroyJavaVM() to wait for all non-daemon threads to end).
@
text
@d3993 39
a4031 1
				throw new NotImplementedException();
@


1.48
log
@- Implemented Thread.dumpThreads() and Thread.getThreads().
- Added a couple more fake native libraries to VFS.
@
text
@d3074 1
d3346 1
d3366 4
d3371 1
d3420 6
a3425 1
				daemonField.SetValue(thread, t.nativeThread.IsBackground);
d3538 4
d3778 7
a3784 2
				// TODO
				throw new NotImplementedException();
@


1.47
log
@Refactored system properties initialization.
@
text
@d339 4
d3571 60
a3630 1
				throw new NotImplementedException();
d3632 1
d3636 5
a3640 1
				throw new NotImplementedException();
d3762 1
@


1.46
log
@Integrated OpenJDK java.nio package.
@
text
@a97 1
using gcSystemProperties = gnu.classpath.SystemProperties;
a3038 1
				juProperties p1 = gcSystemProperties.getProperties();
d3040 3
a3042 7
				foreach (string key in (IEnumerable)p1.keySet())
				{
					p.put(key, p1.getProperty(key));
				}
				// TODO instead of setting it here, we should set it before the user specified properties are processed
				// TODO we should chop off the trailing separator
				p.put("java.home", io.VirtualFileSystem.RootPath);
d3044 1
@


1.45
log
@Removed unused code.
@
text
@d4212 340
d5514 2
a5515 1
	public sealed class Unsafe
d5547 69
a6871 1
		object newDirectByteBuffer(IntPtr address, int capacity);
@


1.44
log
@- Fixed thread creation to use AccessController.doPrivileged() to get ikvm.apartmentstate system property.
- Fixed AccessController.getStackAccessControlContext() to use "native" method as marker on the stack for privileged operation (because the native method stub may get inlined away).
@
text
@a3771 10

			public static SystemThreadingThread getNativeThread(object javaThread)
			{
				throw new NotImplementedException();
			}

			public static object getThreadFromId(long id)
			{
				throw new NotImplementedException();
			}
@


1.43
log
@- Fixed java.lang.reflect.Array.set() to only unbox primitives when the array is a primitive array
- Fixed java.lang.reflect.Array.multiNewArray() to finish the array type before using it.
@
text
@d116 1
d3516 1
a3516 1
				string apartment = jlSystem.getProperty("ikvm.apartmentstate", "").ToLower();
d4244 1
d4317 1
a4317 1
					if (method.DeclaringType == typeof(jsAccessController)
@


1.42
log
@- Added fake awt and rmi native libraries to vfs.
- Removed VMStackWalker dependency.
- Several bootstrap issue workarounds.
@
text
@d1522 1
a1522 2
					jlBoolean booleanValue = value as jlBoolean;
					if (booleanValue != null)
d1524 1
a1524 2
						setBoolean(arrayObj, index, booleanValue.booleanValue());
						return;
d1526 2
a1527 2
					jlByte byteValue = value as jlByte;
					if (byteValue != null)
d1529 48
a1576 38
						setByte(arrayObj, index, byteValue.byteValue());
						return;
					}
					jlCharacter charValue = value as jlCharacter;
					if (charValue != null)
					{
						setChar(arrayObj, index, charValue.charValue());
						return;
					}
					jlShort shortValue = value as jlShort;
					if (shortValue != null)
					{
						setShort(arrayObj, index, shortValue.shortValue());
						return;
					}
					jlInteger intValue = value as jlInteger;
					if (intValue != null)
					{
						setInt(arrayObj, index, intValue.intValue());
						return;
					}
					jlFloat floatValue = value as jlFloat;
					if (floatValue != null)
					{
						setFloat(arrayObj, index, floatValue.floatValue());
						return;
					}
					jlLong longValue = value as jlLong;
					if (longValue != null)
					{
						setLong(arrayObj, index, longValue.longValue());
						return;
					}
					jlDouble doubleValue = value as jlDouble;
					if (doubleValue != null)
					{
						setDouble(arrayObj, index, doubleValue.doubleValue());
						return;
d1802 1
a1802 1
						TypeWrapper wrapper = TypeWrapper.FromClass(componentType);
d1804 1
a1804 1
						return IKVM.Runtime.ByteCodeHelper.multianewarray(wrapper.MakeArrayType(dimensions.Length).TypeAsArrayType.TypeHandle, dimensions);
@


1.41
log
@Integrated OpenJDK javax.imageio package (excluding the jpeg support, because OpenJDK uses native code for that).
@
text
@d76 1
d92 1
d337 2
d2112 1
a2112 1
						MethodInfo method = loader.GetType().GetMethod("getProtectionDomain", BindingFlags.NonPublic | BindingFlags.Instance);
a2414 1
				Thread.Bootstrap();
d2737 1
a2737 1
					if (IKVM.NativeCode.gnu.classpath.VMStackWalker.isHideFromJava(method)
d3041 14
d4240 1
d4289 8
d5296 2
d5300 13
d5336 1
a5336 1
				if (IKVM.NativeCode.gnu.classpath.VMStackWalker.isHideFromJava(method)
@


1.40
log
@Added .NET 1.1 implementation of the System.Net.NetworkInformation namespace.
@
text
@d5036 18
@


1.39
log
@Remove usage of .NET 2.0 specific API when compiling for .NET 1.1.
@
text
@d3840 1
a3840 1
							addresses.Add(typeof(jnInet4Address).GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { typeof(string), typeof(byte[]) }, null).Invoke(new object[] { hostname, b }));
d3936 1
a3936 9
						byte[] b = addr[i].GetAddressBytes();
						if (b.Length == 4)
						{
							addresses[i] = (jnInetAddress)typeof(jnInet4Address).GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { typeof(string), typeof(byte[]) }, null).Invoke(new object[] { hostname, b });
						}
						else
						{
							addresses[i] = (jnInetAddress)typeof(jnInet6Address).GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { typeof(string), typeof(byte[]), typeof(int) }, null).Invoke(new object[] { hostname, b, -1 });
						}
a3961 1
#if WHIDBEY
d3964 1
d3969 3
d3992 6
d4043 1
d4055 2
d4189 2
a4190 1
				return GetInterfaces().dotnetInterfaces[ind].GetIPProperties().GetIPv4Properties().Mtu;
a4193 72
#else
		// TODO it would be nice to implement this on .NET 1.1 builds as well
		// (by creating .NET 2.0 compatible reflection based wrappers around the System.Management based implementation)
		public sealed class NetworkInterface
		{
			public static void init()
			{
			}

			public static object getByIndex(int index)
			{
				return null;
			}

			public static object getAll()
			{
				return null;
			}

			public static object getByName0(string name)
			{
				return null;
			}

			public static object getByInetAddress0(object addr)
			{
				return null;
			}

			public static long getSubnet0(string name, int ind)
			{
				// this method is not used by the java code (!)
				return 0;
			}

			public static object getBroadcast0(string name, int ind)
			{
				// this method is not used by the java code (!)
				return null;
			}

			public static bool isUp0(string name, int ind)
			{
				return false;
			}

			public static bool isLoopback0(string name, int ind)
			{
				return false;
			}

			public static bool supportsMulticast0(string name, int ind)
			{
				return false;
			}

			public static bool isP2P0(string name, int ind)
			{
				return false;
			}

			public static byte[] getMacAddr0(byte[] inAddr, string name, int ind)
			{
				return null;
			}

			public static int getMTU0(string name, int ind)
			{
				return 0;
			}
		}
#endif
@


1.38
log
@Implement java.net.NetworkInterface native methods (for .NET 2.0 builds only ATM).
@
text
@d3829 1
d3831 3
d3928 1
d3930 3
@


1.37
log
@Fixed Inet4AddressImpl.lookupAllHostAddr() to set the queried hostname on returned addresses.
@
text
@d112 2
d3962 1
d3965 5
d3972 74
d4047 1
d4051 142
a4192 1
				throw new NotImplementedException();
d4197 1
a4197 1
				throw new NotImplementedException();
d4202 1
a4202 1
				throw new NotImplementedException();
d4207 1
a4207 1
				throw new NotImplementedException();
d4212 2
a4213 1
				throw new NotImplementedException();
d4218 2
a4219 1
				throw new NotImplementedException();
d4224 1
a4224 1
				throw new NotImplementedException();
d4229 1
a4229 1
				throw new NotImplementedException();
d4234 1
a4234 1
				throw new NotImplementedException();
d4239 1
a4239 1
				throw new NotImplementedException();
d4244 1
a4244 1
				throw new NotImplementedException();
d4249 1
a4249 1
				throw new NotImplementedException();
d4252 1
@


1.36
log
@Another attempt to fix race conditions in Thread.interrupt().
@
text
@d110 2
d341 20
d3834 1
a3834 1
							addresses.Add(jnInetAddress.getByAddress(b));
d3926 9
a3934 1
						addresses[i] = jnInetAddress.getByAddress(addr[i].GetAddressBytes());
@


1.35
log
@Clarified comment.
@
text
@d3053 2
a3054 1
				private bool interruptableWait;
d3131 1
d3138 1
a3138 2
								interruptableWait = false;
								if (interruptPending)
d3140 1
d3154 3
d3166 1
d3180 1
a3180 2
						interruptPending = true;
						if (interruptableWait)
d3182 6
a3187 1
							nativeThread.Interrupt();
d3447 3
d3704 3
@


1.34
log
@- Fixed openjdk.cs compilation error.
- Added OpenJDK derived PlainDatagramSocketImpl implementation.
- Added compilation stubs for jgss.
@
text
@d3144 2
a3145 1
										// the obvious thing to do would be t.Interrupt() / t.Join(), but for some reason that doesn't work (probably a CLR bug)
@


1.33
log
@Fixed some FIRST_PASS compilation errors.
@
text
@d3835 1
a3835 1
					int idx = s.indexOf('.');
@


1.32
log
@- Added WINDOWS constant to ikvm.internal.Util to check if we're running on Windows.
- Added a bunch of native methods to openjdk.cs (some real implementations, some stubs)
- Added OpenJDK derived PlainSocketImpl/SocketInputStream/SocketOutputStream implementations.
- Added OpenJDK derived file protocol handler (a single class that supports both Windows and non-Windows)
@
text
@d3767 3
d3778 1
d3813 3
d3842 1
d3862 3
d3873 1
@


1.31
log
@Implemented native methods of OpenJDK's java.security.AccessController (not yet integrated).
@
text
@d101 1
d108 2
d330 2
a331 1
					if (name == "bin/" + IKVM.NativeCode.java.lang.System.mapLibraryName("zip"))
d3731 238
d4475 30
d4866 37
d4973 46
d6053 107
@


1.30
log
@Added support for "loading" fake native libraries from VFS and removed hack to bypass loadLibrary() call in System.initializeSystemClass().
@
text
@d46 1
d54 1
d102 5
d3727 178
@


1.29
log
@"Implemented" ClassLoader.retrieveDirectives() by returning empty AssertionStatusDirectives object. Enabling assertions on the ikvm.exe command line is still not implemented.
@
text
@d279 3
a281 1
				internal VfsEntry()
d284 1
d289 1
a289 1
					return true;
d309 1
a309 1
						return new VfsEntry();
d316 10
a325 1
				return ((juzZipFile)zipFile).getEntry(name.Replace('\\', '/'));
d578 4
d2480 1
a2480 2
					object fromClass = thisNativeLibrary.GetType().GetField("fromClass", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(thisNativeLibrary);
					if (IKVM.Runtime.JniHelper.LoadLibrary(name, TypeWrapper.FromClass(fromClass).GetClassLoader()) == 1)
d2482 1
d2485 8
d3002 1
@


1.28
log
@- Fixed latestUserDefinedLoader() to ignore mscorlib.
- Added support to VFS for the VFS root directory.
- Fixed FieldAccessorImpl to check the type of the object passed in.
@
text
@d2491 5
d2497 7
a2503 1
				throw new NotImplementedException();
@


1.27
log
@Changed VFS ZipEntryStream.Read() to always try to read the requested number of bytes, instead of returning earlier. For maximum compatibility with real file i/o.
@
text
@d199 3
a201 2
							object javaClassLoader = tw.GetClassLoader().GetJavaClassLoader();
							if (javaClassLoader != null)
d203 5
a207 1
								return javaClassLoader;
d269 2
a270 1
				return String.CompareOrdinal(path, 0, RootPath, 0, RootPath.Length) == 0;
d277 13
d304 8
a311 1
					name = name.Substring(RootPath.Length);
d1833 1
d4680 8
d4704 8
@


1.26
log
@Added lib/logging.properties to VFS and implemented an additional VFS operation required for reading it.
@
text
@d326 16
a341 3
					int read = inp.read(buffer, offset, count);
					position += read;
					return read;
@


1.25
log
@- Implemented java.util.concurrent.locks.LockSupport.
- Fixed race condition in Thread.interrupt() that could cause cli.System.Threading.ThreadInterruptedException to be thrown from interruptable waits/sleep.
@
text
@d449 17
d549 6
a554 1
					System.IO.FileAttributes attr = System.IO.File.GetAttributes(GetPathFromFile(f));
@


1.24
log
@Implemented the beginnings of a virtual file system for the java.home directory.
@
text
@d3030 12
a3596 20
			public static void park(Object blocker, long nanos)
			{
				throw new NotImplementedException();
			}

			public static void park(long nanos)
			{
				throw new NotImplementedException();
			}

			public static void unpark(object javaThread)
			{
				throw new NotImplementedException();
			}

			public static Object getBlocker(object javaThread)
			{
				throw new NotImplementedException();
			}

@


1.23
log
@Integrated OpenJDK's java.rmi package.
@
text
@d97 3
d129 15
d151 1
a151 1
				if (Environment.OSVersion.Platform == PlatformID.Win32NT || Environment.OSVersion.Platform == PlatformID.Win32Windows)
d153 1
a153 1
					return Activator.CreateInstance(typeof(jlClass).Assembly.GetType("java.io.Win32FileSystem"), true);
d157 1
a157 1
					return Activator.CreateInstance(typeof(jlClass).Assembly.GetType("java.io.UnixFileSystem"), true);
d258 193
d453 1
a453 1
			const int ACCESS_READ = 0x04;
d573 4
d673 6
a678 1
					return new System.IO.FileInfo(GetPathFromFile(f)).Length;
d2902 3
d3987 255
a4241 4
				// TODO we need to return the corresponding Java name for TimeZone.CurrentTimeZone.StandardName.
				// The mappings are defined in $JAVA_HOME/lib/tzmappings, but we need the entire $JAVA_HOME/lib/zi
				// directory tree before this is useless, because those files contain the actual time zone definitions.
				return null;
@


1.22
log
@Integrated OpenJDK's java.util.logging and java.util.spi packages.
@
text
@d3790 8
d4922 11
@


1.21
log
@Integrated OpenJDK's java.util.prefs package.
@
text
@d3445 12
@


1.20
log
@Fix to make it compile on .NET 1.1
@
text
@d3445 278
@


1.19
log
@Integrated OpenJDK's java.util package.
@
text
@d733 1
a733 1
						char c = Char.ToUpperInvariant(drive[0]);
@


1.18
log
@Integrated OpenJDK's java.util.concurrent, java.math and java.sql packages.
@
text
@d36 1
d3442 54
@


1.17
log
@Integrated OpenJDK's java.io package (except java.io.FilePermission class).
@
text
@d95 1
d3405 36
@


1.16
log
@Integrated OpenJDK's java.io.File class.
@
text
@d143 95
d3693 47
d4428 5
a4432 1
			throw new NotImplementedException();
@


1.15
log
@More bootstrap issues.
@
text
@d89 2
d123 641
@


1.14
log
@Fixed initialization order issue.
@
text
@d42 1
d1338 1
d2162 1
a2162 2
				// the first thread here is the main thread
				AttachThread("main", false, null);
d2166 6
@


1.13
log
@Integerated OpenJDK's java.io.Console class.
@
text
@d1902 1
a1902 3
#if !FIRST_PASS
				Thread.currentThread();
#endif
a2159 6
			}
#endif

			public static void registerNatives()
			{
#if !FIRST_PASS
d2165 1
d2167 7
@


1.12
log
@Moved common (between GNU Classpath & OpenJDK) "native" code to common.cs.
@
text
@d96 26
a1899 27
#if !FIRST_PASS
			sealed class JavaIOAccess : smJavaIOAccess
			{
				public jiConsole console()
				{
					return null;
				}

				class ConsoleRestoreHook : jlRunnable
				{
					public void run()
					{
					}
				}

				public jlRunnable consoleRestoreHook()
				{
					return new ConsoleRestoreHook();
				}

				public jnCharset charset()
				{
					return null;
				}
			}
#endif

a1902 1
				smSharedSecrets.setJavaIOAccess(new JavaIOAccess());
@


1.11
log
@Implemented the hooks to set the system class loader to the entry assembly's class loader if java.class.path and java.ext.dirs properties aren't set.
@
text
@d2712 34
d3737 32
@


1.10
log
@Replaced zip library loading hack with new method call replacement hack.
@
text
@d85 1
d2173 2
d2678 8
@


1.9
log
@- Integrated OpenJDK's java.lang package.
- Integrated OpenJDK's java.util.regex package.
- Integrated OpenJDK's java.text.Normalizer and support classes.
- New StringHelper.java based on OpenJDK's String.java.
- More fixes to Reflection.getCallerClass()
@
text
@a1412 6
					if (name == Assembly.GetExecutingAssembly().Location)
					{
						// HACK work around for the zip library
						SetHandle(thisNativeLibrary, -1);
						return;
					}
a1849 5
				if (libname == "zip")
				{
					// HACK prevent failure zip library loading
					return Assembly.GetExecutingAssembly().Location;
				}
@


1.8
log
@- Integrated OpenJDK's java.lang.System and friends.
- Fixed a couple of OpenJDK Thread issues.
@
text
@d33 1
d35 1
d1451 60
d1604 60
d1674 151
d2673 13
d2756 2
d2763 2
a2764 2
			// HACK compensate for not inlining (or no tail-call optimization) of the native method stub
			if (new StackFrame(1, false).GetMethod().DeclaringType == typeof(srReflection))
d2766 2
a2767 1
				realFramesToSkip++;
d2769 1
d2772 9
a2780 2
				Type type = new StackFrame(realFramesToSkip++, false).GetMethod().DeclaringType;
				if (type == null
d2788 4
a2791 1
				return ClassLoaderWrapper.GetWrapperFromType(type).ClassObject;
@


1.7
log
@Added clean up for attached threads.
@
text
@d26 6
d33 4
d82 7
d196 1
a196 1
				private static System.Array CheckArray(object arrayObj)
d202 1
a202 1
					System.Array arr = arrayObj as System.Array;
d217 1
a217 1
					System.Array arr = CheckArray(arrayObj);
d468 1
a468 1
					catch (System.InvalidCastException)
d472 1
a472 1
					catch (System.IndexOutOfRangeException)
d664 1
a664 1
						return System.Array.CreateInstance(wrapper.TypeAsArrayType, length);
d762 4
a765 4
			private static System.Reflection.FieldInfo signersField;
			private static System.Reflection.FieldInfo pdField;
			private static System.Reflection.FieldInfo constantPoolField;
			private static System.Reflection.FieldInfo constantPoolOopField;
d770 4
a773 7
				signersField = typeof(jlClass).GetField("signers", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
				pdField = typeof(jlClass).GetField("pd", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
				constantPoolField = typeof(jlClass).GetField("constantPool", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
				constantPoolOopField = typeof(srConstantPool).GetField("constantPoolOop", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);

				// HACK force LangHelper static initializer to run to register JavaLangAccess with SharedSecrets.
				System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(typeof(jlClass).Assembly.GetType("java.lang.LangHelper").TypeHandle);
d977 1
a977 1
					if (System.Array.IndexOf(decl.InnerClasses, wrapper) == -1)
d996 17
a1012 1
				return pdField.GetValue(wrapper.ClassObject);
d1411 16
a1426 2
					// TODO
					throw new NotImplementedException();
d1466 220
d1692 8
a1699 8
			private static readonly System.Reflection.ConstructorInfo threadConstructor1;
			private static readonly System.Reflection.ConstructorInfo threadConstructor2;
			private static readonly System.Reflection.FieldInfo vmThreadField;
			private static readonly System.Reflection.MethodInfo threadGroupAddMethod;
			private static readonly System.Reflection.FieldInfo threadStatusField;
			private static readonly System.Reflection.FieldInfo daemonField;
			private static readonly System.Reflection.FieldInfo threadPriorityField;
			private static readonly System.Reflection.MethodInfo threadExitMethod;
d1707 1
d1713 1
a1713 1
				internal System.Threading.Thread nativeThread;
d1715 1
a1715 1
				internal jlThread javaThread;
d1721 15
d1750 27
d1788 1
d1796 1
a1796 1
					System.Threading.ThreadInterruptedException dotnetInterrupt = null;
d1812 1
a1812 1
						catch (System.Threading.ThreadInterruptedException x)
d1858 1
a1858 1
							javaThread.getUncaughtExceptionHandler().uncaughtException(javaThread, x);
d1883 1
a1883 6
					threadExitMethod.Invoke(javaThread, null);
					threadStatusField.SetValue(javaThread, TERMINATED);
					lock (javaThread)
					{
						System.Threading.Monitor.PulseAll(javaThread);
					}
d1892 6
a1897 6
				vmThreadField = typeof(jlThread).GetField("vmThread", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
				threadGroupAddMethod = typeof(jlThreadGroup).GetMethod("add", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic, null, new Type[] { typeof(jlThread) }, null);
				threadStatusField = typeof(jlThread).GetField("threadStatus", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
				daemonField = typeof(jlThread).GetField("daemon", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
				threadPriorityField = typeof(jlThread).GetField("priority", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
				threadExitMethod = typeof(jlThread).GetMethod("exit", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic, null, Type.EmptyTypes, null);
d1906 1
d1908 3
a1910 2
				// AttachThread(null, false);
				// call System.initializeSystemClass()
d1922 31
d1979 2
a1980 4
				jlThread thread = (jlThread)System.Runtime.Serialization.FormatterServices.GetUninitializedObject(typeof(jlThread));
				VMThread t = new VMThread();
				t.javaThread = thread;
				t.nativeThread = System.Threading.Thread.CurrentThread;
d2000 1
a2000 1
				threadStatusField.SetValue(thread, RUNNABLE);
d2010 1
a2010 1
			private static int MapNativePriorityToJava(System.Threading.ThreadPriority priority)
d2015 1
a2015 1
					case System.Threading.ThreadPriority.Lowest:
d2017 1
a2017 1
					case System.Threading.ThreadPriority.BelowNormal:
d2020 1
a2020 1
					case System.Threading.ThreadPriority.Normal:
d2022 1
a2022 1
					case System.Threading.ThreadPriority.AboveNormal:
d2024 1
a2024 1
					case System.Threading.ThreadPriority.Highest:
d2029 1
a2029 1
			private static System.Threading.ThreadPriority MapJavaPriorityToNative(int priority)
d2034 1
a2034 1
					return System.Threading.ThreadPriority.Lowest;
d2038 1
a2038 1
					return System.Threading.ThreadPriority.BelowNormal;
d2042 1
a2042 1
					return System.Threading.ThreadPriority.Normal;
d2046 1
a2046 1
					return System.Threading.ThreadPriority.AboveNormal;
d2050 1
a2050 1
					return System.Threading.ThreadPriority.Highest;
d2055 1
a2055 1
					return System.Threading.ThreadPriority.Normal;
d2062 1
a2062 1
				System.Threading.Thread.Sleep(0);
d2067 5
d2078 1
a2078 1
						System.Threading.Thread.Sleep(int.MaxValue);
d2080 1
a2080 1
					System.Threading.Thread.Sleep((int)(millis % int.MaxValue));
d2086 1
d2092 2
a2093 2
				VMThread t = new VMThread();
				t.javaThread = (jlThread)thisThread;
a2094 2
				// TODO on NET 2.0 set the stack size
				t.nativeThread = new System.Threading.Thread(new System.Threading.ThreadStart(t.ThreadProc));
d2101 1
a2101 1
					t.nativeThread.ApartmentState = System.Threading.ApartmentState.MTA;
d2105 1
a2105 1
					t.nativeThread.ApartmentState = System.Threading.ApartmentState.STA;
d2107 1
d2120 2
a2121 2
				VMThread t = GetVMThread(thisThread);
				return t != null && t.nativeThread.IsAlive && (int)threadStatusField.GetValue(thisThread) != TERMINATED;
d2142 1
a2142 1
					System.Threading.Monitor.Pulse(obj);
d2145 1
a2145 1
				catch (System.Threading.SynchronizationLockException)
d2202 1
a2202 1
						catch (System.Threading.ThreadStateException)
d2209 1
a2209 1
							System.Threading.ThreadState suspend = System.Threading.ThreadState.Suspended | System.Threading.ThreadState.SuspendRequested;
d2215 1
a2215 1
						catch (System.Threading.ThreadStateException)
d2236 1
a2236 1
					catch (System.Threading.ThreadStateException)
d2251 1
a2251 1
					catch (System.Threading.ThreadStateException)
d2268 10
d2292 1
a2292 1
			// this is called from JniInterface.cs
d2295 3
a2297 4
				object javaThread = currentThread();
				threadExitMethod.Invoke(javaThread, null);
				threadStatusField.SetValue(javaThread, TERMINATED);
				lock (javaThread)
d2299 2
a2300 1
					System.Threading.Monitor.PulseAll(javaThread);
a2301 1
				vmThread = null;
d2329 1
a2329 1
						System.Threading.Monitor.Wait(o);
d2333 1
a2333 1
						System.Threading.Monitor.Wait(o, new System.TimeSpan(timeout * 10000));
d2372 1
a2372 1
			public static System.Threading.Thread getNativeThread(object javaThread)
d2400 49
@


1.6
log
@Integrated OpenJDK's java.lang.Thread
@
text
@d1426 2
d1558 1
a1558 6
						threadExitMethod.Invoke(javaThread, null);
						threadStatusField.SetValue(javaThread, TERMINATED);
						lock (javaThread)
						{
							System.Threading.Monitor.PulseAll(javaThread);
						}
d1564 20
d1650 1
d1787 1
a1787 1
				throw new NotImplementedException();
d1801 1
a1801 1
					// The new 1.5 memory model explicitly allows spurious wake-ups from Object.wait,
d1944 1
a1944 1
			internal static void DetachThreadFromJni()
d1963 9
a1971 1
				if (timeout < 0 || nanos < 0 || nanos > 999999)
d1973 1
a1973 1
					throw new jlIllegalArgumentException("argument out of range");
d1976 1
a1976 1
				t.EnterInterruptableWait(timeout != 0 || nanos != 0);
d1979 1
a1979 1
					if ((timeout == 0 && nanos == 0) || timeout > 922337203685476L)
d1985 1
a1985 1
						System.Threading.Monitor.Wait(o, new System.TimeSpan(timeout * 10000 + (nanos + 99) / 100));
d2001 1
a2001 1
				Thread.DetachThreadFromJni();
@


1.5
log
@Another getCallerClass() fix.
@
text
@d34 1
d38 1
d42 3
d1422 587
@


1.4
log
@Fixed some reflection regressions.
@
text
@a1454 12
		// this method will return null for global methods on .NET 1.1
		// (.NET 1.1 doesn't have a way to go from MethodBase to Module or Assembly)
		private static System.Reflection.Assembly GetAssemblyFromMethodBase(System.Reflection.MethodBase mb)
		{
#if WHIDBEY
			return mb.Module.Assembly;
#else
			Type type = mb.DeclaringType;
			return type == null ? null : type.Assembly;
#endif
		}

d1470 1
d1472 1
a1472 2
					|| type == typeof(jlrConstructor)
					|| type == typeof(IKVM.Runtime.JNIEnv))
@


1.3
log
@- Integrated OpenJDK's java.lang.reflect.Array class.
- Changed Class.isInstance() to use TypeWrapper.IsInstance().
@
text
@d446 1
a446 1
					catch (System.ArrayTypeMismatchException)
d630 4
d656 4
d809 6
d1197 3
a1199 1
						if (!methods[i].IsHideFromReflection)
d1201 2
a1202 1
							if (methods[i].Name == "<init>")
d1204 1
a1204 6
								TypeWrapper[] args = methods[i].GetParameters();
								for (int j = 0; j < args.Length; j++)
								{
									args[j].EnsureLoadable(wrapper.GetClassLoader());
								}
								list.Add(methods[i].ToMethodOrConstructor(false));
d1206 1
d1477 1
a1477 3
			StackFrame frame;
			// skip reflection frames
			while (GetAssemblyFromMethodBase((frame = new StackFrame(realFramesToSkip, false)).GetMethod()) == typeof(object).Assembly)
d1479 6
a1484 1
				for (;;)
d1486 1
a1486 13
					Type type = new StackFrame(realFramesToSkip++, false).GetMethod().DeclaringType;
					if (type == typeof(jlrMethod) || type == typeof(jlrConstructor))
					{
						break;
					}
					if (type == typeof(IKVM.Runtime.JNIEnv))
					{
						while (new StackFrame(realFramesToSkip, false).GetMethod().DeclaringType == typeof(IKVM.Runtime.JNIEnv))
						{
							realFramesToSkip++;
						}
						break;
					}
d1488 1
a1489 1
			return ClassLoaderWrapper.GetWrapperFromType(frame.GetMethod().DeclaringType).ClassObject;
d1514 4
d1555 8
d1564 6
d1617 1
d1623 29
d1749 1
a1749 1
					return fw.GetValue(obj);
a1753 4
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
d1758 1
a1758 1
					fw.SetValue(obj, value);
d1771 1
a1771 1
					return (byte)fw.GetValue(obj);
d1815 1
a1815 5
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					fw.SetValue(obj, b);
d1828 1
a1828 1
					return (bool)fw.GetValue(obj);
d1847 1
a1847 5
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					fw.SetValue(obj, b);
d1860 1
a1860 1
					return (char)fw.GetValue(obj);
d1898 1
a1898 5
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					fw.SetValue(obj, c);
d1911 1
a1911 1
					return (short)fw.GetValue(obj);
d1955 1
a1955 5
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					fw.SetValue(obj, s);
d1968 1
a1968 1
					return (int)fw.GetValue(obj);
d2020 1
a2020 5
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					fw.SetValue(obj, i);
d2033 1
a2033 1
					return (float)fw.GetValue(obj);
d2087 1
a2087 5
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					fw.SetValue(obj, f);
d2100 1
a2100 1
					return (long)fw.GetValue(obj);
d2120 1
a2120 5
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					fw.SetValue(obj, l);
d2166 1
a2166 1
					return (double)fw.GetValue(obj);
d2221 1
a2221 5
					if (isFinal)
					{
						throw new jlIllegalAccessException();
					}
					fw.SetValue(obj, d);
@


1.2
log
@Integrated OpenJDK's java.lang.reflect.* classes (except for Array).
@
text
@d30 1
d34 1
d36 1
d73 598
d796 1
a796 1
				return obj != null && IKVM.NativeCode.ikvm.runtime.Util.GetTypeWrapperFromObject(obj).IsAssignableTo(TypeWrapper.FromClass(thisClass));
d944 1
a944 1
					if (Array.IndexOf(decl.InnerClasses, wrapper) == -1)
@


1.1
log
@Forgot to add this file.
@
text
@d26 1
d31 2
d38 10
d51 1
d56 1
d58 1
a70 73
		sealed class LangReflectAccessImpl : srLangReflectAccess
		{
		    public jlrField newField(jlClass declaringClass, string name, jlClass type, int modifiers, int slot, string signature, byte[] annotations)
			{
				throw new NotImplementedException();
			}

			public jlrMethod newMethod(jlClass declaringClass, string name, jlClass[] parameterTypes, jlClass returnType, jlClass[] checkedExceptions, int modifiers, int slot, string signature, byte[] annotations, byte[] parameterAnnotations, byte[] annotationDefault)
			{
				throw new NotImplementedException();
			}

			public jlrConstructor newConstructor(jlClass declaringClass, jlClass[] parameterTypes, jlClass[] checkedExceptions, int modifiers, int slot, string signature, byte[] annotations, byte[] parameterAnnotations)
			{
				throw new NotImplementedException();
			}

		    public srMethodAccessor getMethodAccessor(jlrMethod m)
			{
				throw new NotImplementedException();
			}

		    public void setMethodAccessor(jlrMethod m, srMethodAccessor accessor)
			{
				throw new NotImplementedException();
			}

		    public srConstructorAccessor getConstructorAccessor(jlrConstructor c)
			{
				throw new NotImplementedException();
			}

		    public void setConstructorAccessor(jlrConstructor c, srConstructorAccessor accessor)
			{
				throw new NotImplementedException();
			}

		    public int getConstructorSlot(jlrConstructor c)
			{
				throw new NotImplementedException();
			}

		    public string getConstructorSignature(jlrConstructor c)
			{
				throw new NotImplementedException();
			}

		    public byte[] getConstructorAnnotations(jlrConstructor c)
			{
				throw new NotImplementedException();
			}

		    public byte[] getConstructorParameterAnnotations(jlrConstructor c)
			{
				throw new NotImplementedException();
			}

		    public jlrMethod copyMethod(jlrMethod arg)
			{
				return (jlrMethod)JVM.Library.newMethod(arg.getDeclaringClass(), JVM.Library.getWrapperFromMethodOrConstructor(arg));
			}

			public jlrField copyField(jlrField arg)
			{
				return (jlrField)JVM.Library.newField(arg.getDeclaringClass(), JVM.Library.getWrapperFromField(arg));
			}

			public jlrConstructor copyConstructor(jlrConstructor arg)
			{
				return (jlrConstructor)JVM.Library.newConstructor(arg.getDeclaringClass(), JVM.Library.getWrapperFromMethodOrConstructor(arg));
			}
		}

a138 3
				// HACK to avoid triggering java.lang.System initialization we directly access the private field of ReflectionFactory
				srReflectionFactory fact = (srReflectionFactory)typeof(srReflectionFactory).GetField("soleInstance", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static).GetValue(null);
				fact.setLangReflectAccess(new LangReflectAccessImpl());
d432 7
d484 1
a484 1
							list.Add(JVM.Library.newField(thisClass, fields[i]));
d532 3
a534 1
							if (!JVM.EnableReflectionOnMethodsWithUnloadableTypeParameters)
d536 1
a536 6
								methods[i].ReturnType.EnsureLoadable(wrapper.GetClassLoader());
								TypeWrapper[] args = methods[i].GetParameters();
								for (int j = 0; j < args.Length; j++)
								{
									args[j].EnsureLoadable(wrapper.GetClassLoader());
								}
d538 1
a538 1
							list.Add(JVM.Library.newMethod(thisClass, methods[i]));
a585 1
								methods[i].ReturnType.EnsureLoadable(wrapper.GetClassLoader());
d591 1
a591 1
								list.Add(JVM.Library.newConstructor(thisClass, methods[i]));
d841 12
d855 3
a857 1
			System.Diagnostics.StackTrace stack = new System.Diagnostics.StackTrace(false);
d859 1
a859 1
			if (stack.GetFrame(1).GetMethod().DeclaringType.FullName == "sun.reflect.Reflection")
d863 23
a885 2
			// TODO implement skipping reflection frames
			return ClassLoaderWrapper.GetWrapperFromType(stack.GetFrame(realFramesToSkip).GetMethod().DeclaringType).ClassObject;
d901 1
a901 1
	public sealed class NativeConstructorAccessorImpl
d903 61
a963 1
		private NativeConstructorAccessorImpl() { }
d965 1
a965 1
		public static object newInstance0(object thisConstructor, object[] args)
d967 21
a987 1
			throw new NotImplementedException();
a988 1
	}
d990 691
a1680 3
	public sealed class NativeMethodAccessorImpl
	{
		private NativeMethodAccessorImpl() { }
d1682 1
a1682 1
		public static object invoke0(object thisMethod, object obj, object[] args)
@

