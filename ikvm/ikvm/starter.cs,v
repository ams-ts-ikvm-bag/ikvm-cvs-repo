head	1.66;
access;
symbols
	v8_1_5717_0:1.66
	v8_1:1.66.0.4
	v8_0_5449_1:1.66
	v8_0_5449_0:1.66
	v8_0:1.66.0.2
	v7_4_5196_0:1.65
	v7_4:1.65.0.2
	v7_3:1.64.0.2
	v7_2_4630_6:1.58
	v7_2_4630_5:1.58
	v7_2_4630_4:1.58
	v7_2_4630_3:1.58
	v7_2_4630_2:1.58
	v0_46_0_4:1.54
	v7_2_4630_1:1.58
	v7_2:1.58.0.4
	v7_1_4532_2:1.58
	v7_1_4532_1:1.58
	v7_1_4532_0:1.58
	v7_1:1.58.0.2
	v7_0_4335_3:1.57
	v7_0_4335_2:1.57
	v7_0_4335_1:1.57
	v0_46_0_2:1.54
	v7_0_4335_0:1.57
	v7_0:1.57.0.2
	v0_40_0_6:1.49
	v0_40_0_5:1.49
	v0_46_0_1:1.54
	v0_46_0_0:1.54
	v0_46:1.54.0.2
	v0_36_0_14:1.44.2.1
	v0_44_0_6:1.52
	v0_44_0_5:1.52
	v0_44_0_4:1.52
	v0_44_0_3:1.52
	v0_44_0_2:1.52
	v0_42_0_7:1.51
	v0_44_0_1:1.52
	v0_44_0_0:1.52
	v0_44:1.52.0.2
	v0_42_0_6:1.51
	v0_42_0_5:1.51
	v0_42_0_4:1.51
	v0_42_0_3:1.51
	v0_42_0_2:1.51
	v0_42_0_1:1.51
	v0_42_0_0:1.51
	v0_42:1.51.0.2
	v0_40_0_3:1.49
	v0_40_0_2:1.49
	v0_40_0_1:1.49
	v0_40_0_0:1.49
	v0_40:1.49.0.2
	v0_36_0_13:1.44.2.1
	v0_38_0_1:1.46
	v0_38_0_0:1.46
	v0_38:1.46.0.2
	v0_36_0_9:1.44.2.1
	v0_36_0_7:1.44.2.1
	v0_36_0_5:1.44.2.1
	v0_36_0_4:1.44.2.1
	v0_36_0_3:1.44.2.1
	v0_36_0_2:1.44.2.1
	v0_36_0_1:1.44.2.1
	v0_36_0_0:1.44
	v0_36:1.44.0.2
	v0_34_0_3:1.41
	v0_34_0_2:1.41
	v0_34_0_1:1.41
	v0_34_0_0:1.41
	v0_34:1.41.0.4
	v0_32:1.41.0.2
	v0_32_0_0:1.41
	v0_30:1.36.0.2
	v0_28_0_0:1.35
	v0_26_0_1:1.34
	v0_26_0_0:1.34
	v0_24_0_1:1.33
	v0_24_0_0:1.33
	v0_22_0_0:1.32
	v0_20_0_0:1.32
	v0_18_0_0:1.32
	v0_16_0_0:1.30
	v0_14_0_1:1.30
	v0_14_0_0:1.30
	v0_12_0_0:1.29
	v0_10_0_1:1.28
	v0_10_0_0:1.28
	v0_8_0_0:1.18
	initial:1.1.1.1
	ikvm:1.1.1;
locks; strict;
comment	@ * @;


1.66
date	2014.10.28.10.13.06;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2013.07.28.00.43.31;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2013.02.26.12.02.05;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2013.02.07.19.34.06;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2013.02.07.09.06.42;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2013.01.31.10.54.57;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2013.01.30.17.41.16;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2013.01.30.16.25.23;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2011.11.29.07.03.22;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2011.08.01.08.41.05;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.12.07.41.24;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.12.05.59.24;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2010.12.28.09.06.15;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2010.11.03.12.25.09;	author smallsql;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.25.10.18.29;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2009.07.03.06.55.19;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.02.07.38.21;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2009.02.21.09.35.40;	author smallsql;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.04.07.03.30;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2008.12.23.05.45.03;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.15.12.01.11;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.12.06.51.37;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2007.08.16.12.57.32;	author jfrijters;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2007.05.31.08.21.14;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.18.06.06.52;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2006.09.28.18.56.00;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2006.09.14.12.55.25;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.20.09.15.23;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.17.08.14.47;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.17.07.33.39;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2006.06.28.08.07.29;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.10.09.09.10;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.31.10.13.32;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.19.15.12.49;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.18.07.27.43;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.14.12.28.45;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.11.13.56.45;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.23.13.07.03;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.04.12.50.33;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.19.13.43.56;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.04.19.30.54;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.27.10.17.34;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.15.13.35.46;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.05.09.37.59;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.10.07.19.57;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.17.09.14.51;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.14.09.31.58;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.23.14.21.46;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.02.08.13.14;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.20.13.25.08;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.16.17.10.11;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.08.15.18.48;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.24.11.51.41;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.19.22.19.19;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.29.10.14.08;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.21.12.13.13;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.10.11.43.12;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.14.09.42.00;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.17.14.04.28;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.15.17.08.10;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.29.16.33.07;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.27.09.09.39;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.18.16.01.24;	author jfrijters;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.12.18.16.01.24;	author jfrijters;	state Exp;
branches;
next	;

1.44.2.1
date	2007.09.13.07.30.05;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.66
log
@Ignore -Xmn and -XX: Oracle Java specific command line options.
@
text
@/*
  Copyright (C) 2002-2013 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using IKVM.Internal;
using ikvm.runtime;
using java.lang.reflect;

public static class Starter
{
	private class Timer
	{
		private static Timer t;
		private DateTime now = DateTime.Now;

		internal Timer()
		{
			t = this;
		}

		~Timer()
		{
			Console.WriteLine(DateTime.Now - now);
		}
	}

	private class SaveAssemblyShutdownHook : java.lang.Thread
	{
		private java.lang.Class clazz;

		internal SaveAssemblyShutdownHook(java.lang.Class clazz)
			: base("SaveAssemblyShutdownHook")
		{
			this.clazz = clazz;
		}

		public override void run()
		{
			System.Threading.Thread.CurrentThread.Priority = System.Threading.ThreadPriority.AboveNormal;
			try
			{
				IKVM.Internal.Starter.SaveDebugImage();
			}
			catch(Exception x)
			{
				Console.Error.WriteLine(x);
				Console.Error.WriteLine(new System.Diagnostics.StackTrace(x, true));
				System.Diagnostics.Debug.Assert(false, x.ToString());
			}
		}
	}

	private class WaitShutdownHook : java.lang.Thread
	{
		internal WaitShutdownHook()
			: base("WaitShutdownHook")
		{
		}

		public override void run()
		{
			Console.Error.WriteLine("IKVM runtime terminated. Waiting for Ctrl+C...");
			for(;;)
			{
				System.Threading.Thread.Sleep(System.Threading.Timeout.Infinite);
			}
		}
	}

	[STAThread]	// NOTE this is here because otherwise SWT's RegisterDragDrop (a COM thing) doesn't work
	[IKVM.Attributes.HideFromJava]
	static int Main(string[] args)
	{
		Tracer.EnableTraceConsoleListener();
		Tracer.EnableTraceForDebug();
		System.Collections.Hashtable props = new System.Collections.Hashtable();
		string classpath = Environment.GetEnvironmentVariable("CLASSPATH");
		if(classpath == null || classpath == "")
		{
			classpath = ".";
		}
		props["java.class.path"] = classpath;
		bool jar = false;
		bool saveAssembly = false;
		bool saveAssemblyX = false;
		bool waitOnExit = false;
		bool showVersion = false;
		string mainClass = null;
		int vmargsIndex = -1;
        bool debug = false;
        String debugArg = null;
		bool noglobbing = false;
		for(int i = 0; i < args.Length; i++)
		{
            String arg = args[i];
			if(arg[0] == '-')
			{
				if(arg == "-help" || arg == "-?")
				{
					PrintHelp();
					return 1;
				}
				else if(arg == "-X")
				{
					PrintXHelp();
					return 1;
				}
				else if(arg == "-Xsave")
				{
					saveAssembly = true;
					IKVM.Internal.Starter.PrepareForSaveDebugImage();
				}
				else if(arg == "-XXsave")
				{
					saveAssemblyX = true;
					IKVM.Internal.Starter.PrepareForSaveDebugImage();
				}
				else if(arg == "-Xtime")
				{
					new Timer();
				}
				else if(arg == "-Xwait")
				{
					waitOnExit = true;
				}
				else if(arg == "-Xbreak")
				{
					System.Diagnostics.Debugger.Break();
				}
				else if(arg == "-Xnoclassgc")
				{
					IKVM.Internal.Starter.ClassUnloading = false;
				}
				else if(arg == "-Xverify")
				{
					IKVM.Internal.Starter.RelaxedVerification = false;
				}
				else if(arg == "-jar")
				{
					jar = true;
				}
				else if(arg == "-version")
				{
					Console.WriteLine(Startup.getVersionAndCopyrightInfo());
					Console.WriteLine();
					Console.WriteLine("CLR version: {0} ({1} bit)", Environment.Version, IntPtr.Size * 8);
					System.Type type = System.Type.GetType("Mono.Runtime");
					if(type != null)
					{
						Console.WriteLine("Mono version: {0}", type.InvokeMember("GetDisplayName", BindingFlags.InvokeMethod | BindingFlags.Static | BindingFlags.NonPublic, null, null, new object[0]));
					}
					foreach(Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
					{
						Console.WriteLine("{0}: {1}", asm.GetName().Name, asm.GetName().Version);
					}
					string ver = java.lang.System.getProperty("openjdk.version");
					if(ver != null)
					{
						Console.WriteLine("OpenJDK version: {0}", ver);
					}
					return 0;
				}
				else if(arg == "-showversion")
				{
					showVersion = true;
				}
				else if(arg.StartsWith("-D"))
				{
				    arg = arg.Substring(2);
                    string[] keyvalue = arg.Split('=');
				    string value;
					if(keyvalue.Length == 2) // -Dabc=x
					{
                        value = keyvalue[1];
					} 
                    else if (keyvalue.Length == 1) // -Dabc
                    {
                        value = "";
                    } 
                    else // -Dabc=x=y
					{
                        value = arg.Substring(keyvalue[0].Length + 1);
					}
                    props[keyvalue[0]] = value;
				}
				else if(arg == "-ea" || arg == "-enableassertions")
				{
					IKVM.Runtime.Assertions.EnableAssertions();
				}
				else if(arg == "-da" || arg == "-disableassertions")
				{
					IKVM.Runtime.Assertions.DisableAssertions();
				}
				else if(arg == "-esa" || arg == "-enablesystemassertions")
				{
					IKVM.Runtime.Assertions.EnableSystemAssertions();
				}
				else if(arg == "-dsa" || arg == "-disablesystemassertions")
				{
					IKVM.Runtime.Assertions.DisableSystemAssertions();
				}
				else if(arg.StartsWith("-ea:") || arg.StartsWith("-enableassertions:"))
				{
					IKVM.Runtime.Assertions.EnableAssertions(arg.Substring(arg.IndexOf(':') + 1));
				}
				else if(arg.StartsWith("-da:") || arg.StartsWith("-disableassertions:"))
				{
					IKVM.Runtime.Assertions.DisableAssertions(arg.Substring(arg.IndexOf(':') + 1));
				}
				else if(arg == "-cp" || arg == "-classpath")
				{
					props["java.class.path"] = args[++i];
				}
				else if(arg.StartsWith("-Xtrace:"))
				{
					Tracer.SetTraceLevel(arg.Substring(8));
				}
				else if(arg.StartsWith("-Xmethodtrace:"))
				{
					Tracer.HandleMethodTrace(arg.Substring(14));
				}
                else if(arg == "-Xdebug")
                {
                    debug = true;
                }
                else if (arg == "-Xnoagent")
                {
                    //ignore it, disable support for oldjdb
                }
                else if (arg.StartsWith("-Xrunjdwp") || arg.StartsWith("-agentlib:jdwp"))
                {
                    debugArg = arg;
                    debug = true;
                }
                else if (arg.StartsWith("-Xreference:"))
                {
                    Startup.addBootClassPathAssembly(Assembly.LoadFrom(arg.Substring(12)));
                }
                else if (arg == "-Xnoglobbing")
                {
                    noglobbing = true;
                }
                else if (arg == "-XX:+AllowNonVirtualCalls")
                {
                    IKVM.Internal.Starter.AllowNonVirtualCalls = true;
                }
                else if (arg.StartsWith("-Xms")
                    || arg.StartsWith("-Xmx")
                    || arg.StartsWith("-Xmn")
                    || arg.StartsWith("-Xss")
                    || arg.StartsWith("-XX:")
                    || arg == "-Xmixed"
                    || arg == "-Xint"
                    || arg == "-Xincgc"
                    || arg == "-Xbatch"
                    || arg == "-Xfuture"
                    || arg == "-Xrs"
                    || arg == "-Xcheck:jni"
                    || arg == "-Xshare:off"
                    || arg == "-Xshare:auto"
                    || arg == "-Xshare:on"
                    )
                {
                    Console.Error.WriteLine("Unsupported option ignored: {0}", arg);
                }
                else
                {
                    Console.Error.WriteLine("{0}: illegal argument", arg);
                    break;
                }
			}
			else
			{
				mainClass = arg;
				vmargsIndex = i + 1;
				break;
			}
		}
		if(mainClass == null || showVersion)
		{
			Console.Error.WriteLine(Startup.getVersionAndCopyrightInfo());
			Console.Error.WriteLine();
		}
		if(mainClass == null)
		{
			PrintHelp();
			return 1;
		}
		try
		{
            if (debug)
            {
                // Starting the debugger
                Assembly asm = Assembly.GetExecutingAssembly();
                String arguments = debugArg + " -pid:" + System.Diagnostics.Process.GetCurrentProcess().Id;
                String program = new FileInfo(asm.Location).DirectoryName + "\\debugger.exe";
                try
                {
                    ProcessStartInfo info = new ProcessStartInfo(program, arguments);
                    info.UseShellExecute = false;
                    Process debugger = new Process();
                    debugger.StartInfo = info;
                    debugger.Start();
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine(program + " " + arguments);
                    throw ex;
                }
            }
			if(jar)
			{
				props["java.class.path"] = mainClass;
			}
			// like the JDK we don't quote the args (even if they contain spaces)
			props["sun.java.command"] = String.Join(" ", args, vmargsIndex - 1, args.Length - (vmargsIndex - 1));
			props["sun.java.launcher"] = "SUN_STANDARD";
			Startup.setProperties(props);
			Startup.enterMainThread();
			string[] vmargs;
			if (noglobbing)
			{
				vmargs = new string[args.Length - vmargsIndex];
				System.Array.Copy(args, vmargsIndex, vmargs, 0, vmargs.Length);
			}
			else
			{
				// Startup.glob() uses Java code, so we need to do this after we've initialized
				vmargs = Startup.glob(args, vmargsIndex);
			}
			try
			{
				java.lang.Class clazz = sun.launcher.LauncherHelper.checkAndLoadMain(true, jar ? 2 : 1, mainClass);
				// we don't need to do any checking on the main method, as that was already done by checkAndLoadMain
				Method method = clazz.getMethod("main", typeof(string[]));
				// if clazz isn't public, we can still call main
				method.setAccessible(true);
				if(saveAssembly)
				{
					java.lang.Runtime.getRuntime().addShutdownHook(new SaveAssemblyShutdownHook(clazz));
				}
				if(waitOnExit)
				{
					java.lang.Runtime.getRuntime().addShutdownHook(new WaitShutdownHook());
				}
				try
				{
					method.invoke(null, new object[] { vmargs });
					return 0;
				}
				catch(InvocationTargetException x)
				{
					throw x.getCause();
				}
			}
			finally
			{
				if(saveAssemblyX)
				{
					IKVM.Internal.Starter.SaveDebugImage();
				}
			}
		}
		catch(System.Exception x)
		{
			java.lang.Thread thread = java.lang.Thread.currentThread();
			thread.getThreadGroup().uncaughtException(thread, ikvm.runtime.Util.mapException(x));
		}
		finally
		{
			Startup.exitMainThread();
		}
		return 1;
	}

	private static void PrintHelp()
	{
		Console.Error.WriteLine("usage: ikvm [-options] <class> [args...]");
		Console.Error.WriteLine("          (to execute a class)");
		Console.Error.WriteLine("    or ikvm -jar [-options] <jarfile> [args...]");
		Console.Error.WriteLine("          (to execute a jar file)");
		Console.Error.WriteLine();
		Console.Error.WriteLine("where options include:");
		Console.Error.WriteLine("    -? -help          Display this message");
		Console.Error.WriteLine("    -X                Display non-standard options");
		Console.Error.WriteLine("    -version          Display IKVM and runtime version");
		Console.Error.WriteLine("    -showversion      Display version and continue running");
		Console.Error.WriteLine("    -cp -classpath <directories and zip/jar files separated by {0}>", Path.PathSeparator);
		Console.Error.WriteLine("                      Set search path for application classes and resources");
		Console.Error.WriteLine("    -D<name>=<value>  Set a system property");
		Console.Error.WriteLine("    -ea[:<packagename>...|:<classname>]");
		Console.Error.WriteLine("    -enableassertions[:<packagename>...|:<classname>]");
		Console.Error.WriteLine("                      Enable assertions.");
		Console.Error.WriteLine("    -da[:<packagename>...|:<classname>]");
		Console.Error.WriteLine("    -disableassertions[:<packagename>...|:<classname>]");
		Console.Error.WriteLine("                      Disable assertions");
	}

	private static void PrintXHelp()
	{
		Console.Error.WriteLine("    -Xsave            Save the generated assembly (for troubleshooting)");
		Console.Error.WriteLine("    -Xtime            Time the execution");
		Console.Error.WriteLine("    -Xtrace:<string>  Displays all tracepoints with the given name");
		Console.Error.WriteLine("    -Xmethodtrace:<string>");
		Console.Error.WriteLine("                      Builds method trace into the specified output methods");
		Console.Error.WriteLine("    -Xwait            Keep process hanging around after exit");
		Console.Error.WriteLine("    -Xbreak           Trigger a user defined breakpoint at startup");
		Console.Error.WriteLine("    -Xnoclassgc       Disable class garbage collection");
		Console.Error.WriteLine("    -Xnoglobbing      Disable argument globbing");
		Console.Error.WriteLine("    -Xverify          Enable strict class file verification");
		Console.Error.WriteLine();
		Console.Error.WriteLine("The -X options are non-standard and subject to change without notice.");
		Console.Error.WriteLine();
	}
}
@


1.65
log
@Removed -X options from standard help text and added -X option to print -X options.
@
text
@d272 1
d274 1
@


1.64
log
@Fixed a typo in ikvm.runtime.Startup.addBootClassPathAssembly().
@
text
@d32 1
a32 1
public class Starter
d123 7
a129 1
					break;
d307 1
a307 28
			Console.Error.WriteLine("usage: ikvm [-options] <class> [args...]");
			Console.Error.WriteLine("          (to execute a class)");
			Console.Error.WriteLine("    or ikvm -jar [-options] <jarfile> [args...]");
			Console.Error.WriteLine("          (to execute a jar file)");
			Console.Error.WriteLine();
			Console.Error.WriteLine("where options include:");
			Console.Error.WriteLine("    -? -help          Display this message");
			Console.Error.WriteLine("    -version          Display IKVM and runtime version");
			Console.Error.WriteLine("    -showversion      Display version and continue running");
			Console.Error.WriteLine("    -cp -classpath <directories and zip/jar files separated by {0}>", Path.PathSeparator);
			Console.Error.WriteLine("                      Set search path for application classes and resources");
			Console.Error.WriteLine("    -D<name>=<value>  Set a system property");
			Console.Error.WriteLine("    -ea[:<packagename>...|:<classname>]");
			Console.Error.WriteLine("    -enableassertions[:<packagename>...|:<classname>]");
			Console.Error.WriteLine("                      Enable assertions.");
			Console.Error.WriteLine("    -da[:<packagename>...|:<classname>]");
			Console.Error.WriteLine("    -disableassertions[:<packagename>...|:<classname>]");
			Console.Error.WriteLine("                      Disable assertions");
			Console.Error.WriteLine("    -Xsave            Save the generated assembly (for debugging)");
			Console.Error.WriteLine("    -Xtime            Time the execution");
			Console.Error.WriteLine("    -Xtrace:<string>  Displays all tracepoints with the given name");
			Console.Error.WriteLine("    -Xmethodtrace:<string>");
			Console.Error.WriteLine("                      Builds method trace into the specified output methods");
			Console.Error.WriteLine("    -Xwait            Keep process hanging around after exit");
			Console.Error.WriteLine("    -Xbreak           Trigger a user defined breakpoint at startup");
			Console.Error.WriteLine("    -Xnoclassgc       Disable class garbage collection");
			Console.Error.WriteLine("    -Xnoglobbing      Disable argument globbing");
			Console.Error.WriteLine("    -Xverify          Enable strict class file verification");
d396 40
@


1.63
log
@Stop considering ACC_SUPER when linking invokespecial (unless compatibility switch is set). This change matches the security change in Java 7u13.
@
text
@d254 1
a254 1
                    Startup.addBootClassPathAssemby(Assembly.LoadFrom(arg.Substring(12)));
@


1.62
log
@Moved progress reporting of saving dynamic assemblies dump into DynamicClassLoader.cs.
@
text
@d260 4
@


1.61
log
@Regression fix. The main method should be retrieved with getMethod() not getDeclaredMethod(), because we don't want to resolve non-public method signatures.
@
text
@a62 1
			Console.Error.WriteLine("Saving dynamic assembly...");
a65 1
				Console.Error.WriteLine("Saving done.");
@


1.60
log
@Removed unused code.
@
text
@d375 1
a375 1
				Method method = clazz.getDeclaredMethod("main", typeof(string[]));
@


1.59
log
@Use sun.launcher.LauncherHelper to make the launcher more consistent with Java.
@
text
@d2 1
a2 1
  Copyright (C) 2002-2011 Jeroen Frijters
d25 1
a28 1

a30 6
using java.net;
using java.util.jar;
using java.io;

using Console = System.Console;
using System.Diagnostics;
a414 25

	private static string GetMainClassFromJarManifest(string mainClass)
	{
		JarFile jf = new JarFile(mainClass);
		try
		{
			Manifest manifest = jf.getManifest();
			if (manifest == null)
			{
				Console.Error.WriteLine("Jar file doesn't contain manifest");
				return null;
			}
			mainClass = manifest.getMainAttributes().getValue(Attributes.Name.MAIN_CLASS);
		}
		finally
		{
			jf.close();
		}
		if (mainClass == null)
		{
			Console.Error.WriteLine("Manifest doesn't contain a Main-Class.");
			return null;
		}
		return mainClass.Replace('/', '.');
	}
@


1.58
log
@Added -Xverify option to ikvm.exe.
@
text
@d377 1
a377 1
			if (jar)
d379 6
a384 2
				mainClass = GetMainClassFromJarManifest(mainClass);
				if (mainClass == null)
d386 1
a386 1
					return 1;
d388 1
a388 6
			}
			java.lang.Class clazz = java.lang.Class.forName(mainClass, true, java.lang.ClassLoader.getSystemClassLoader());
			try
			{
				Method method = IKVM.Internal.Starter.FindMainMethod(clazz);
				if(method == null)
d390 1
a390 1
					throw new java.lang.NoSuchMethodError("main");
d392 1
a392 1
				else if(!Modifier.isPublic(method.getModifiers()))
d394 2
a395 1
					Console.Error.WriteLine("Main method not public.");
d397 1
a397 1
				else
d399 1
a399 19
					// if clazz isn't public, we can still call main
					method.setAccessible(true);
					if(saveAssembly)
					{
						java.lang.Runtime.getRuntime().addShutdownHook(new SaveAssemblyShutdownHook(clazz));
					}
					if(waitOnExit)
					{
						java.lang.Runtime.getRuntime().addShutdownHook(new WaitShutdownHook());
					}
					try
					{
						method.invoke(null, new object[] { vmargs });
						return 0;
					}
					catch(InvocationTargetException x)
					{
						throw x.getCause();
					}
@


1.57
log
@Set sun.java.command and sun.java.launcher properties.
@
text
@d159 4
a272 1
                    || arg == "-Xnoclassgc"
d332 1
@


1.56
log
@Updated Windows globbing to be compatible with Java 7.
@
text
@d357 3
@


1.55
log
@Added -Xnoglobbing option to ikvm.exe
@
text
@d291 1
a291 1
				vmargsIndex = i + 2;
d362 2
a363 2
				vmargs = new string[args.Length - (vmargsIndex - 1)];
				System.Array.Copy(args, vmargsIndex - 1, vmargs, 0, vmargs.Length);
d368 1
a368 1
				vmargs = Startup.glob(vmargsIndex);
@


1.54
log
@Added -Xreference: option to ikvm.
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d123 1
d260 4
d328 1
d359 11
a369 2
			// HACK Starup.glob() uses Java code, so we need to do this after we've initialized
			string[] vmargs = Startup.glob(vmargsIndex);
@


1.53
log
@Fix setting of system properties with an equals character in the value like -Dabc=x=y
@
text
@d255 4
@


1.52
log
@Moved FindMainMethod into runtime, to avoid the need for hacks (to avoid NoClassDefFoundErrors).
@
text
@d189 4
a192 2
					string[] keyvalue = args[i].Substring(2).Split('=');
					if(keyvalue.Length != 2)
d194 9
a202 1
						keyvalue = new string[] { keyvalue[0], "" };
d204 1
a204 1
					props[keyvalue[0]] = keyvalue[1];
@


1.51
log
@Removed GNU Classpath version info.
@
text
@d352 1
a352 1
				Method method = FindMainMethod(clazz);
a427 30

	private static Method FindMainMethod(java.lang.Class clazz)
	{
		// HACK without this hack, clazz.getDeclaredMethods would throw a NoClassDefFoundError if any
		// of the methods in the class had an unloadable parameter type, but we don't want that.
		IKVM.Internal.Starter.EnableReflectionOnMethodsWithUnloadableTypeParameters = true;
		try
		{
			while(clazz != null)
			{
				foreach(Method m in clazz.getDeclaredMethods())
				{
					if(m.getName() == "main" && m.getReturnType() == java.lang.Void.TYPE)
					{
						java.lang.Class[] parameters = m.getParameterTypes();
						if(parameters.Length == 1 && parameters[0] == java.lang.Class.forName("[Ljava.lang.String;"))
						{
							return m;
						}
					}
				}
				clazz = clazz.getSuperclass();
			}
			return null;
		}
		finally
		{
			IKVM.Internal.Starter.EnableReflectionOnMethodsWithUnloadableTypeParameters = false;
		}
	}
@


1.50
log
@Implemented class gc (available only when compiling on .NET 4.0).
@
text
@d176 1
a176 6
					string ver = java.lang.System.getProperty("gnu.classpath.version");
					if(ver != null)
					{
						Console.WriteLine("GNU Classpath version: {0}", ver);
					}
					ver = java.lang.System.getProperty("openjdk.version");
@


1.49
log
@add Start of the Debugger
@
text
@d154 4
d313 1
@


1.48
log
@- Fixed tracer to only add a trace listener in executables. Bug #2533728.
@
text
@d36 1
d121 2
d125 2
a126 1
			if(args[i][0] == '-')
d128 1
a128 1
				if(args[i] == "-help" || args[i] == "-?")
d132 1
a132 1
				else if(args[i] == "-Xsave")
d137 1
a137 1
				else if(args[i] == "-XXsave")
d142 1
a142 1
				else if(args[i] == "-Xtime")
d146 1
a146 1
				else if(args[i] == "-Xwait")
d150 1
a150 1
				else if(args[i] == "-Xbreak")
d154 1
a154 1
				else if(args[i] == "-jar")
d158 1
a158 1
				else if(args[i] == "-version")
d184 1
a184 1
				else if(args[i] == "-showversion")
d188 1
a188 1
				else if(args[i].StartsWith("-D"))
d197 1
a197 1
				else if(args[i] == "-ea" || args[i] == "-enableassertions")
d201 1
a201 1
				else if(args[i] == "-da" || args[i] == "-disableassertions")
d205 1
a205 1
				else if(args[i] == "-esa" || args[i] == "-enablesystemassertions")
d209 1
a209 1
				else if(args[i] == "-dsa" || args[i] == "-disablesystemassertions")
d213 1
a213 1
				else if(args[i].StartsWith("-ea:") || args[i].StartsWith("-enableassertions:"))
d215 1
a215 1
					IKVM.Runtime.Assertions.EnableAssertions(args[i].Substring(args[i].IndexOf(':') + 1));
d217 1
a217 1
				else if(args[i].StartsWith("-da:") || args[i].StartsWith("-disableassertions:"))
d219 1
a219 1
					IKVM.Runtime.Assertions.DisableAssertions(args[i].Substring(args[i].IndexOf(':') + 1));
d221 1
a221 1
				else if(args[i] == "-cp" || args[i] == "-classpath")
d225 1
a225 1
				else if(args[i].StartsWith("-Xtrace:"))
d227 1
a227 1
					Tracer.SetTraceLevel(args[i].Substring(8));
d229 1
a229 1
				else if(args[i].StartsWith("-Xmethodtrace:"))
d231 1
a231 24
					Tracer.HandleMethodTrace(args[i].Substring(14));
				}
				else if(args[i].StartsWith("-Xms")
					|| args[i].StartsWith("-Xmx")
					|| args[i].StartsWith("-Xss")
					|| args[i] == "-Xmixed"
					|| args[i] == "-Xint"
					|| args[i] == "-Xnoclassgc"
					|| args[i] == "-Xincgc"
					|| args[i] == "-Xbatch"
					|| args[i] == "-Xfuture"
					|| args[i] == "-Xrs"
					|| args[i] == "-Xcheck:jni"
					|| args[i] == "-Xshare:off"
					|| args[i] == "-Xshare:auto"
					|| args[i] == "-Xshare:on"
					)
				{
					Console.Error.WriteLine("Unsupported option ignored: {0}", args[i]);
				}
				else
				{
					Console.Error.WriteLine("{0}: illegal argument", args[i]);
					break;
d233 36
d272 1
a272 1
				mainClass = args[i];
d313 20
@


1.47
log
@Moved jar inspection into a separate method, to avoid loading the JarFile type unless necessary.
@
text
@d104 1
@


1.46
log
@Generified all collections.
@
text
@d305 2
a306 2
				JarFile jf = new JarFile(mainClass);
				try
a307 15
					Manifest manifest = jf.getManifest();
					if(manifest == null)
					{
						Console.Error.WriteLine("Jar file doesn't contain manifest");
						return 1;
					}
					mainClass = manifest.getMainAttributes().getValue(Attributes.Name.MAIN_CLASS);
				}
				finally
				{
					jf.close();
				}
				if(mainClass == null)
				{
					Console.Error.WriteLine("Manifest doesn't contain a Main-Class.");
a309 1
				mainClass = mainClass.Replace('/', '.');
d366 25
@


1.45
log
@Implemented assertions (OpenJDK only).
@
text
@a26 4
using System.Reflection.Emit;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
d105 1
a105 1
		Hashtable props = new Hashtable();
@


1.44
log
@Changed class library version printing to support both GNU Classpath and OpenJDK.
@
text
@d198 1
a198 1
					props["ikvm.assert.default"] = "true";
d202 9
a210 1
					props["ikvm.assert.default"] = "false";
d214 1
a214 1
					props["ikvm.assert.enable"] = args[i].Substring(args[i].IndexOf(':') + 1);
d218 1
a218 1
					props["ikvm.assert.disable"] = args[i].Substring(args[i].IndexOf(':') + 1);
@


1.44.2.1
log
@Ported fixes from trunk. Changed version to 0.36.0.1.
@
text
@d198 1
a198 1
					IKVM.Runtime.Assertions.EnableAssertions();
d202 1
a202 9
					IKVM.Runtime.Assertions.DisableAssertions();
				}
				else if(args[i] == "-esa" || args[i] == "-enablesystemassertions")
				{
					IKVM.Runtime.Assertions.EnableSystemAssertions();
				}
				else if(args[i] == "-dsa" || args[i] == "-disablesystemassertions")
				{
					IKVM.Runtime.Assertions.DisableSystemAssertions();
d206 1
a206 1
					IKVM.Runtime.Assertions.EnableAssertions(args[i].Substring(args[i].IndexOf(':') + 1));
d210 1
a210 1
					IKVM.Runtime.Assertions.DisableAssertions(args[i].Substring(args[i].IndexOf(':') + 1));
@


1.43
log
@Moved argument globbing to after VM has been initialized to resolve initialization order issue (on OpenJDK hybrid build).
@
text
@d171 10
a180 1
					Console.WriteLine("GNU Classpath version: {0}", java.lang.System.getProperty("gnu.classpath.version"));
@


1.42
log
@Disambiguate System.Console and java.io.Console.
@
text
@d122 1
a122 1
		string[] vmargs = null;
d242 1
a242 1
				vmargs = Startup.glob(i + 2);
d288 3
a290 1
			if(jar)
@


1.41
log
@*** empty log message ***
@
text
@d39 2
@


1.40
log
@*** empty log message ***
@
text
@d160 5
@


1.39
log
@*** empty log message ***
@
text
@d73 1
a73 1
				IKVM.Internal.Starter.SaveDebugImage(clazz);
d344 1
a344 1
					IKVM.Internal.Starter.SaveDebugImage(clazz);
@


1.38
log
@*** empty log message ***
@
text
@d306 1
a306 2
			Method method = FindMainMethod(clazz);
			if(method == null)
d308 2
a309 11
				throw new java.lang.NoSuchMethodError("main");
			}
			else if(!Modifier.isPublic(method.getModifiers()))
			{
				Console.Error.WriteLine("Main method not public.");
			}
			else
			{
				// if clazz isn't public, we can still call main
				method.setAccessible(true);
				if(saveAssembly)
d311 1
a311 1
					java.lang.Runtime.getRuntime().addShutdownHook(new SaveAssemblyShutdownHook(clazz));
d313 1
a313 1
				if(waitOnExit)
d315 1
a315 1
					java.lang.Runtime.getRuntime().addShutdownHook(new WaitShutdownHook());
d317 1
a317 1
				try
d319 19
a337 2
					method.invoke(null, new object[] { vmargs });
					return 0;
d339 4
a342 1
				catch(InvocationTargetException x)
d344 1
a344 8
					throw x.getCause();
				}
				finally
				{
					if(saveAssemblyX)
					{
						IKVM.Internal.Starter.SaveDebugImage(clazz);
					}
@


1.37
log
@*** empty log message ***
@
text
@d108 6
@


1.36
log
@*** empty log message ***
@
text
@a31 1
using IKVM.Runtime;
d33 1
d151 1
a151 1
					Console.WriteLine(IKVM.Runtime.Startup.GetVersionAndCopyrightInfo());
d229 1
a229 1
				vmargs = Startup.Glob(i + 2);
d235 1
a235 1
			Console.Error.WriteLine(IKVM.Runtime.Startup.GetVersionAndCopyrightInfo());
d273 2
a274 2
			Startup.SetProperties(props);
			Startup.EnterMainThread();
d342 1
a342 1
			thread.getThreadGroup().uncaughtException(thread, IKVM.Runtime.Util.MapException(x));
d346 1
a346 1
			Startup.ExitMainThread();
@


1.35
log
@*** empty log message ***
@
text
@a56 30
	public class PathClassLoader : URLClassLoader
	{
		private static URL[] GetClassPath(string classpath)
		{
			string[] s = classpath.Split(Path.PathSeparator);
			URL[] urls = new URL[s.Length];
			for(int i = 0; i < urls.Length; i++)
			{
				// TODO non-existing file/dir is treated as current directory, this obviously isn't correct
				urls[i] = new java.io.File(s[i]).toURL();
			}
			return urls;
		}

		public PathClassLoader(string classpath, java.lang.ClassLoader parent)
			: base(GetClassPath(classpath), parent)
		{
		}

		protected override java.lang.Class loadClass(string name, bool resolve)
		{
			java.lang.Class c = findClass(name);
			if(resolve)
			{
				resolveClass(c);
			}
			return c;
		}
	}

a114 1
		string bootclasspath = null;
a193 4
				else if(args[i].StartsWith("-Xbootclasspath:"))
				{
					bootclasspath = args[i].Substring(16);
				}
a259 2
			Console.Error.WriteLine("    -Xbootclasspath:<directories and zip/jar files separated by {0}>", Path.PathSeparator);
			Console.Error.WriteLine("                      Set search path for bootstrap classes and resources");
a298 4
			if(bootclasspath != null)
			{
				IKVM.Internal.Starter.SetBootstrapClassLoader(new PathClassLoader(bootclasspath, null));
			}
@


1.34
log
@*** empty log message ***
@
text
@d103 1
a103 1
				JVM.SaveDebugImage(clazz);
d157 1
a157 1
					JVM.PrepareForSaveDebugImage();
d162 1
a162 1
					JVM.PrepareForSaveDebugImage();
d338 1
a338 1
				JVM.SetBootstrapClassLoader(new PathClassLoader(bootclasspath, null));
d375 1
a375 1
						JVM.SaveDebugImage(clazz);
d396 1
a396 1
		JVM.EnableReflectionOnMethodsWithUnloadableTypeParameters = true;
d418 1
a418 1
			JVM.EnableReflectionOnMethodsWithUnloadableTypeParameters = false;
@


1.33
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
d142 1
d182 2
d192 4
d268 5
d283 1
@


1.32
log
@*** empty log message ***
@
text
@d304 7
a310 1
					mainClass = jf.getManifest().getMainAttributes().getValue(Attributes.Name.MAIN_CLASS).Replace('/', '.');
d321 1
@


1.31
log
@*** empty log message ***
@
text
@d186 1
@


1.30
log
@*** empty log message ***
@
text
@d229 18
@


1.29
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d181 1
a181 1
					Console.WriteLine("CLR version: {0}", Environment.Version);
@


1.28
log
@*** empty log message ***
@
text
@d355 4
a358 1
		while(clazz != null)
d360 1
a360 1
			foreach(Method m in clazz.getDeclaredMethods())
d362 1
a362 1
				if(m.getName() == "main" && m.getReturnType() == java.lang.Void.TYPE)
d364 1
a364 2
					java.lang.Class[] parameters = m.getParameterTypes();
					if(parameters.Length == 1 && parameters[0] == java.lang.Class.forName("[Ljava.lang.String;"))
d366 5
a370 1
						return m;
d373 1
d375 5
a379 1
			clazz = clazz.getSuperclass();
a380 1
		return null;
@


1.27
log
@*** empty log message ***
@
text
@d344 1
a344 1
			thread.getThreadGroup().uncaughtException(thread, java.lang.ExceptionHelper.MapExceptionFast(x));
@


1.26
log
@*** empty log message ***
@
text
@d285 1
a285 1
					mainClass = jf.getManifest().getMainAttributes().getValue(Attributes.Name.MAIN_CLASS);
@


1.25
log
@*** empty log message ***
@
text
@d133 1
d137 1
a137 1
		StringDictionary props = new StringDictionary();
@


1.24
log
@*** empty log message ***
@
text
@a136 3
		// HACK we take our own assembly location as the location of classpath (this is used by the Security infrastructure
		// to find the classpath.security file)
		props["gnu.classpath.home"] = new System.IO.FileInfo(Assembly.GetExecutingAssembly().Location).DirectoryName;
d196 16
d250 1
d254 6
d265 2
a266 1
			Console.Error.WriteLine("    -Xmethodtrace:<string>  Builds method trace into the specified output methods");
d268 1
a268 1
			Console.Error.WriteLine("    -Xbreak           Trigger a user defined breakpoint");
@


1.23
log
@*** empty log message ***
@
text
@d92 1
d117 5
a135 1
		System.Threading.Thread.CurrentThread.Name = "main";
d137 3
d252 4
d257 1
a257 3
			// HACK we take our own assembly location as the location of classpath (this is used by the Security infrastructure
			// to find the classpath.security file)
			java.lang.System.setProperty("gnu.classpath.home", new System.IO.FileInfo(Assembly.GetExecutingAssembly().Location).DirectoryName);
a259 1
				java.lang.System.setProperty("java.class.path", mainClass);
d326 1
a326 6
			// FXBUG when the main thread ends, it doesn't actually die, it stays around to manage the lifetime
			// of the CLR, but in doing so it also keeps alive the thread local storage for this thread and we
			// use the TLS as a hack to track when the thread dies (if the object stored in the TLS is finalized,
			// we know the thread is dead). So to make that work for the main thread, we explicitly clear the TLS
			// slot that contains our hack object.
			System.Threading.Thread.SetData(System.Threading.Thread.GetNamedDataSlot("ikvm-thread-hack"), null);
@


1.22
log
@*** empty log message ***
@
text
@d29 1
d32 1
d131 1
a131 1
		Hashtable props = new Hashtable();
d216 1
a216 2
				vmargs = new string[args.Length - (i + 1)];
				System.Array.Copy(args, i + 1, vmargs, 0, vmargs.Length);
d228 1
a228 1
			Console.Error.WriteLine("    -? -help          display this message");
d230 4
a233 4
			Console.Error.WriteLine("                      set search path for application classes and resources");
			Console.Error.WriteLine("    -D<name>=<value>  set a system property");
			Console.Error.WriteLine("    -Xsave            save the generated assembly (for debugging)");
			Console.Error.WriteLine("    -Xtime            time the execution");
d235 1
a235 1
			Console.Error.WriteLine("                      set search path for bootstrap classes and resources");
d244 1
a244 4
			// HACK poke the properties into a special field in VMRuntime, so that they are copied into the
			// defaultProperties collection.
			Type vmruntime = typeof(java.lang.Runtime).Assembly.GetType("java.lang.VMRuntime");
			vmruntime.GetField("props", BindingFlags.NonPublic | BindingFlags.Static).SetValue(null, props);
@


1.21
log
@*** empty log message ***
@
text
@d30 1
@


1.20
log
@*** empty log message ***
@
text
@d128 1
d131 1
d149 5
d186 1
a186 1
					java.lang.System.setProperty(keyvalue[0], keyvalue[1]);
d190 1
a190 1
					java.lang.System.setProperty("java.class.path", args[++i]);
d242 4
d302 7
@


1.19
log
@*** empty log message ***
@
text
@a53 52
	private class ExtClassLoader : URLClassLoader
	{
		private static URL[] GetClassPath()
		{
			string classpath = java.lang.System.getProperty("java.ext.dirs", "");
			string[] s = classpath.Split(Path.PathSeparator);
			ArrayList jars = new ArrayList();
			for(int i = 0; i < s.Length; i++)
			{
				try
				{
					string[] files = Directory.GetFiles(s[i]);
					for(int j = 0; j < files.Length; j++)
					{
						jars.Add(new java.io.File(files[j]).toURL());
					}
				}
				catch(ArgumentException)
				{
					// ignore any malformed components
				}
			}
			return (URL[])jars.ToArray(typeof(URL));
		}

		internal ExtClassLoader(java.lang.ClassLoader parent)
			: base(GetClassPath(), parent)
		{
		}
	}

	public class AppClassLoader : URLClassLoader
	{
		private static URL[] GetClassPath()
		{
			string classpath = java.lang.System.getProperty("java.class.path", ".");
			string[] s = classpath.Split(Path.PathSeparator);
			URL[] urls = new URL[s.Length];
			for(int i = 0; i < urls.Length; i++)
			{
				// TODO non-existing file/dir is treated as current directory, this obviously isn't correct
				urls[i] = new java.io.File(s[i]).toURL();
			}
			return urls;
		}

		public AppClassLoader(java.lang.ClassLoader parent)
			: base(GetClassPath(), new ExtClassLoader(parent))
		{
		}
	}

d95 1
d133 1
d187 1
a187 1
					java.lang.System.setProperty("ikvm.boot.class.path", args[i].Substring(16));
d240 1
a240 2
				// TODO if there is no classpath, we're adding the current directory, but is this correct when running a jar?
				java.lang.System.setProperty("java.class.path", mainClass + Path.PathSeparator + java.lang.System.getProperty("java.class.path"));
d256 1
a256 6
			// NOTE we should use the default systemclassloader (gnu.java.lang.SystemClassLoader),
			// but at the moment it is broken (doesn't implement findClass())
			java.lang.System.setProperty("java.system.class.loader", typeof(AppClassLoader).AssemblyQualifiedName);
			java.lang.ClassLoader loader = java.lang.ClassLoader.getSystemClassLoader();
			string bootclasspath = java.lang.System.getProperty("ikvm.boot.class.path", "");
			if(bootclasspath != "")
d258 1
a258 20
				StringBuilder sb = new StringBuilder();
				foreach(string part in bootclasspath.Split(Path.PathSeparator))
				{
					if(part.ToUpper().EndsWith(".DLL"))
					{
						Assembly.Load(part.Substring(0, part.Length - 4));
					}
					else
					{
						if(sb.Length > 0)
						{
							sb.Append(Path.PathSeparator);
						}
						sb.Append(part);
					}
				}
				if(sb.Length > 0)
				{
					JVM.SetBootstrapClassLoader(new PathClassLoader(sb.ToString(), null));
				}
d260 1
a260 1
			java.lang.Class clazz = java.lang.Class.forName(mainClass, true, loader);
@


1.18
log
@*** empty log message ***
@
text
@d205 4
d280 1
@


1.17
log
@*** empty log message ***
@
text
@d342 2
@


1.16
log
@*** empty log message ***
@
text
@a173 1
	[StackTraceInfo(Hidden = true, EatFrames = 1)]
@


1.15
log
@*** empty log message ***
@
text
@d151 1
@


1.14
log
@*** empty log message ***
@
text
@d161 12
d181 1
d201 4
d275 1
d346 4
@


1.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002 Jeroen Frijters
d155 1
@


1.12
log
@*** empty log message ***
@
text
@a311 4
			if(saveAssembly)
			{
				java.lang.Runtime.getRuntime().addShutdownHook(new SaveAssemblyShutdownHook(clazz));
			}
d323 4
d341 1
a341 1
			thread.getThreadGroup().uncaughtException(thread, ExceptionHelper.MapExceptionFast(x));
d345 6
a350 1
			// TODO the current thread should be removed from its ThreadGroup and signaled
@


1.11
log
@*** empty log message ***
@
text
@d164 1
d217 1
a217 1
				else if(args[i] == "-Xlogclf")
d219 5
a223 1
					JVM.LogClassLoadFailures = true;
d255 2
a256 1
			Console.Error.WriteLine("    -Xlogclf          log class load failures");
@


1.10
log
@*** empty log message ***
@
text
@d147 10
a156 1
			JVM.SaveDebugImage(clazz);
d305 1
a305 1
			java.lang.Class clazz = loader.loadClass(mainClass);
a309 2
			// NOTE Sun's JRE runs the static initializer even if the main method doesn't exist, so we do the same.
			System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(NativeCode.java.lang.VMClass.getType(clazz).TypeHandle);
@


1.9
log
@*** empty log message ***
@
text
@d136 15
d297 1
a297 2
			Method method = clazz.getMethod("main", new java.lang.Class[] { java.lang.Class.forName("[Ljava.lang.String;") });
			if(!Modifier.isPublic(method.getModifiers()))
d299 1
a299 2
				Console.Error.WriteLine("Main method not public.");
				return 1;
d301 4
a304 1
			if(!Modifier.isStatic(method.getModifiers()))
d308 5
a312 1
			try
d317 1
d319 1
a319 1
				finally
d321 1
a321 7
					if(saveAssembly)
					{
						// TODO it would be nice to wait for other threads to exit
						// TODO consider using a Shutdown hook!
						JVM.SaveDebugImage(clazz);
						saveAssembly = false;
					}
a323 11
			catch(InvocationTargetException x)
			{
				throw x.getCause();
			}
			if(saveAssembly)
			{
				// TODO it would be nice to wait for other threads to exit
				// TODO consider using a Shutdown hook!
				JVM.SaveDebugImage(clazz);
			}
			return 0;
a328 1
			return 1;
d330 25
@


1.8
log
@*** empty log message ***
@
text
@d288 4
@


1.7
log
@*** empty log message ***
@
text
@d166 9
@


1.6
log
@*** empty log message ***
@
text
@d156 1
@


1.5
log
@*** empty log message ***
@
text
@d231 1
a231 2
					// TODO use Attributes.Name.MAIN_CLASS (we don't support inner classes at the moment)
					mainClass = jf.getManifest().getMainAttributes().getValue("Main-Class");
d272 1
a272 1
			Method method = clazz.getMethod("main", new java.lang.Class[] { java.lang.Class.getClassFromType(typeof(string[])) });
@


1.4
log
@no message
@
text
@d149 1
a149 1
				if(args[i] == "-help")
d153 1
a153 1
				else if(args[i] == "-save")
d157 1
a157 1
				else if(args[i] == "-time")
d182 4
d208 2
a209 2
			Console.Error.WriteLine("    -help             display this message");
			Console.Error.WriteLine("    -cp -classpath <directories and zip/jar files separated by ;>");
a210 2
			Console.Error.WriteLine("    -save             save the generated assembly (for debugging)");
			Console.Error.WriteLine("    -time             time the execution");
d212 3
a214 1
			Console.Error.WriteLine("    -Xbootclasspath:<directories and zip/jar files separated by ;>");
d216 1
@


1.3
log
@no message
@
text
@d59 1
a59 1
			string[] s = classpath.Split(';');
d90 1
a90 1
			string[] s = classpath.Split(';');
d110 1
a110 1
			string[] s = classpath.Split(';');
d222 1
a222 1
				java.lang.System.setProperty("java.class.path", mainClass + ";" + java.lang.System.getProperty("java.class.path"));
d247 1
a247 1
				foreach(string part in bootclasspath.Split(';'))
d257 1
a257 1
							sb.Append(';');
@


1.2
log
@no message
@
text
@d29 1
d243 2
a244 1
			if(java.lang.System.getProperty("ikvm.boot.class.path", "") != "")
d246 20
a265 1
				JVM.SetBootstrapClassLoader(new PathClassLoader(java.lang.System.getProperty("ikvm.boot.class.path"), null));
@


1.1
log
@Initial revision
@
text
@d105 30
d177 4
d203 1
a203 1
			Console.Error.WriteLine("    -help             Display this message");
d206 5
a210 3
			Console.Error.WriteLine("    -save             Save the generated assembly (for debugging)");
			Console.Error.WriteLine("    -time             Time the execution");
			Console.Error.WriteLine("    -D<name>=<value>  Set a system property");
d242 4
@


1.1.1.1
log
@no message
@
text
@@
