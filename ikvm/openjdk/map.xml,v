head	1.116;
access;
symbols
	v8_1_5717_0:1.115
	v8_1:1.115.0.2
	v8_0_5449_1:1.107
	v8_0_5449_0:1.107
	v8_0:1.107.0.2
	v7_4_5196_0:1.99
	v7_4:1.99.0.2
	v7_3:1.94.0.2
	v7_2_4630_6:1.91
	v7_2_4630_5:1.91
	v7_2_4630_4:1.91
	v7_2_4630_3:1.91
	v7_2_4630_2:1.91
	v0_46_0_4:1.70.2.1
	v7_2_4630_1:1.91
	v7_2:1.91.0.2
	v7_1_4532_2:1.88
	v7_1_4532_1:1.88
	v7_1_4532_0:1.88
	v7_1:1.88.0.2
	v7_0_4335_3:1.87.2.1
	v7_0_4335_2:1.87.2.1
	v7_0_4335_1:1.87.2.1
	v0_46_0_2:1.70.2.1
	v7_0_4335_0:1.87
	v7_0:1.87.0.2
	v0_40_0_6:1.45.2.1
	v0_40_0_5:1.45.2.1
	v0_46_0_1:1.70
	v0_46_0_0:1.70
	v0_46:1.70.0.2
	v0_36_0_14:1.17.2.5
	v0_44_0_6:1.65.2.2
	v0_44_0_5:1.65.2.1
	v0_44_0_4:1.65.2.1
	v0_44_0_3:1.65
	v0_44_0_2:1.65
	v0_42_0_7:1.51
	v0_44_0_1:1.65
	v0_44_0_0:1.65
	v0_44:1.65.0.2
	v0_42_0_6:1.51
	v0_42_0_5:1.51
	v0_42_0_4:1.51
	v0_42_0_3:1.51
	v0_42_0_2:1.51
	v0_42_0_1:1.51
	v0_42_0_0:1.51
	v0_42:1.51.0.2
	v0_40_0_3:1.45
	v0_40_0_2:1.45
	v0_40_0_1:1.45
	v0_40_0_0:1.45
	v0_40:1.45.0.2
	v0_36_0_13:1.17.2.4
	v0_38_0_1:1.41
	v0_38_0_0:1.41
	v0_38:1.41.0.2
	v0_36_0_9:1.17.2.3
	v0_36_0_7:1.17.2.1
	v0_36_0_5:1.17.2.1
	v0_36_0_4:1.17.2.1
	v0_36_0_3:1.17.2.1
	v0_36_0_2:1.17.2.1
	v0_36_0_1:1.17
	v0_36_0_0:1.17
	v0_36:1.17.0.2;
locks; strict;
comment	@# @;


1.116
date	2016.09.07.07.57.52;	author jfrijters;	state Exp;
branches;
next	1.115;

1.115
date	2015.06.24.14.10.40;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2015.06.23.07.24.39;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2015.06.21.06.23.29;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2015.06.20.05.18.28;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2015.06.09.09.28.43;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2015.03.14.08.29.41;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2015.03.06.13.26.19;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2015.03.06.12.32.46;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2014.11.19.07.26.05;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2014.11.10.09.18.25;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2014.06.07.08.41.47;	author jfrijters;	state Exp;
branches;
next	1.104;

1.104
date	2014.05.27.10.07.27;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2014.05.26.12.21.18;	author jfrijters;	state Exp;
branches;
next	1.102;

1.102
date	2014.05.23.11.29.21;	author jfrijters;	state Exp;
branches;
next	1.101;

1.101
date	2014.05.22.13.20.42;	author jfrijters;	state Exp;
branches;
next	1.100;

1.100
date	2014.05.19.12.43.36;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2014.02.27.06.57.35;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2014.02.07.14.14.10;	author jfrijters;	state Exp;
branches;
next	1.97;

1.97
date	2013.07.16.13.23.43;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2013.04.21.10.48.04;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2013.03.20.14.03.28;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2013.02.28.07.43.17;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2013.02.21.13.49.03;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2012.12.30.12.25.58;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2012.08.29.11.54.35;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2012.08.29.07.25.42;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2012.07.07.07.15.30;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2011.11.28.13.23.42;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2011.10.17.07.12.23;	author jfrijters;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2011.09.29.05.56.50;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2011.09.01.15.57.22;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2011.08.10.12.03.23;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2011.08.08.11.29.35;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2011.07.30.10.34.13;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2011.07.30.09.57.21;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2011.07.11.07.35.47;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2011.07.07.07.52.59;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.07.07.04.32;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2011.07.01.14.03.41;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2011.07.01.08.56.51;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2011.06.27.15.15.32;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2011.06.26.06.32.47;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2011.06.19.10.17.19;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2011.06.17.14.46.36;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2011.05.13.07.29.31;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2010.11.20.07.41.00;	author jfrijters;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2010.10.22.06.07.25;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2010.10.05.04.54.09;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2010.09.01.06.40.28;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2010.08.09.12.27.39;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.11.07.02.29;	author jfrijters;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2010.05.30.06.53.49;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2010.05.27.16.07.56;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.27.14.54.41;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2010.05.27.14.08.58;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2010.05.27.13.23.04;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2010.05.27.13.03.26;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.27.12.36.40;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.27.12.08.01;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.27.11.21.23;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.27.09.17.56;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2010.04.28.14.22.51;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.12.06.38.46;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.12.04.17.40;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2009.08.11.05.59.52;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2009.08.06.06.46.54;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2009.07.29.09.36.56;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2009.07.29.07.04.44;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.28.13.01.26;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2009.07.14.06.27.41;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.16.05.50.59;	author jfrijters;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2009.03.16.05.48.13;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.23.06.18.50;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.23.05.41.26;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.01.05.19.05;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.01.04.00.22;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.21.06.05.24;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.14.06.51.33;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.14.06.02.54;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.15.09.12.18;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.06.07.07.18;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.05.06.06.10;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.21.04.48.32;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2008.04.25.04.48.57;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.23.05.24.35;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.23.05.21.10;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.23.04.25.22;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.22.06.47.18;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.14.05.14.53;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.14.09.17.08;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.03.08.28.23;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2008.03.03.07.05.19;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2008.02.18.08.01.05;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2008.02.09.17.40.18;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.28.14.55.33;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.27.15.16.49;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.19.11.28.10;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.19.09.35.57;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.23.09.26.46;	author jfrijters;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2007.08.22.11.44.06;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.08.09.23.08;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.07.07.38.27;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.05.11.53.06;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.04.12.20.52;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.29.08.48.22;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.28.14.00.10;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.18.09.16.19;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.15.06.47.03;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.14.06.42.23;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.12.12.54.20;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.12.11.47.11;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.11.09.17.29;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.09.08.33.09;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.05.06.57.18;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.24.09.23.02;	author jfrijters;	state Exp;
branches;
next	;

1.17.2.1
date	2007.09.20.13.54.23;	author jfrijters;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2008.02.20.14.24.40;	author jfrijters;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2008.02.27.07.09.46;	author jfrijters;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2008.11.05.07.52.01;	author jfrijters;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2010.11.11.05.59.57;	author jfrijters;	state Exp;
branches;
next	;

1.45.2.1
date	2011.05.16.06.54.23;	author jfrijters;	state Exp;
branches;
next	;

1.65.2.1
date	2010.08.09.12.31.30;	author jfrijters;	state Exp;
branches;
next	1.65.2.2;

1.65.2.2
date	2010.10.22.07.33.46;	author jfrijters;	state Exp;
branches;
next	;

1.70.2.1
date	2011.12.20.11.05.32;	author jfrijters;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2013.09.10.15.16.02;	author jfrijters;	state Exp;
branches;
next	;

1.87.2.1
date	2012.01.03.12.16.37;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.116
log
@Bug fix. Added missing methods to String (chars() and codePoints()).
@
text
@<?xml version="1.0" encoding="utf-8" ?>
<!--
  Copyright (C) 2002-2015 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
-->
<root>
    <assembly>
        <class name="java.lang.Object" shadows="System.Object" modifiers="public">
            <attribute type="System.SerializableAttribute" sig="()V" />
            <constructor sig="()V" modifiers="public" />
            <method name="notifyAll" sig="()V" modifiers="public final">
                <body>
                    <ldarg_0 />
                    <call type="System.Threading.Monitor" name="PulseAll" sig="(Ljava.lang.Object;)V" />
                    <ret />
                </body>
            </method>
            <method name="notify" sig="()V" modifiers="public final">
                <body>
                    <ldarg_0 />
                    <call type="System.Threading.Monitor" name="Pulse" sig="(Ljava.lang.Object;)V" />
                    <ret />
                </body>
            </method>
            <method name="wait" sig="()V" modifiers="public final">
                <throws class="java.lang.InterruptedException" />
                <body>
                    <ldarg_0 />
                    <ldc_i4_0 />
                    <conv_i8 />
                    <call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;J)V" />
                    <ret />
                </body>
            </method>
            <method name="wait" sig="(J)V" modifiers="public final">
                <parameter name="timeout" />
                <throws class="java.lang.InterruptedException" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;J)V" />
                    <ret />
                </body>
            </method>
            <method name="wait" sig="(JI)V" modifiers="public final">
                <parameter name="timeout" />
                <parameter name="nanos" />
                <throws class="java.lang.InterruptedException" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <ldarg_2 />
                    <call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
                    <ret />
                </body>
            </method>
            <method name="getClass" sig="()Ljava.lang.Class;" modifiers="public final">
                <attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
                    <parameter>()Ljava/lang/Class&lt;+Ljava/lang/Object;&gt;;</parameter>
                </attribute>
                <body>
                    <ldarg_0 />
                    <call class="ikvm.runtime.Util" name="getClassFromObject" sig="(Ljava.lang.Object;)Ljava.lang.Class;" />
                    <ret />
                </body>
            </method>
            <method name="clone" sig="()Ljava.lang.Object;" modifiers="protected">
                <throws class="java.lang.CloneNotSupportedException" />
                <body>
                    <ldarg_0 />
                    <isinst class="java.lang.Cloneable" />
                    <brtrue name="ok" />
                    <newobj class="java.lang.CloneNotSupportedException" name="&lt;init&gt;" sig="()V" />
                    <throw />
                    <label name="ok" />
                    <ldarg_0 />
                    <call type="System.Object" name="MemberwiseClone" sig="()Ljava.lang.Object;" />
                    <ret />
                </body>
                <alternateBody>
                    <ldarg_0 />
                    <isinst type="System.Array" />
                    <dup />
                    <brfalse name="not_array" />
                    <call type="System.Array" name="Clone" sig="()Ljava.lang.Object;" />
                    <ret />
                    <label name="not_array" />
                    <pop />
                    <ldarg_0 />
                    <isinst class="java.lang.Cloneable" />
                    <brfalse name="not_cloneable" />
                    <!--
		     This means we're Cloneable, but not derived from java.lang.Object or java.lang.Throwable.
		     It also means that we must have been invoked thru reflection (or by code in the java.lang package),
		     so it is OK to use reflection to call Object.MemberwiseClone().
		     -->
                    <ldtoken type="System.Object" />
                    <call type="System.Type" name="GetTypeFromHandle" sig="(Lcli.System.RuntimeTypeHandle;)Lcli.System.Type;" />
                    <ldstr value="MemberwiseClone" />
                    <ldc_i4 value="36" />
                    <ldnull />
                    <ldsfld type="System.Type" name="EmptyTypes" sig="[Lcli.SystemType;" />
                    <ldnull />
                    <callvirt type="System.Type" name="GetMethod" sig="(Ljava.lang.String;Lcli.System.Reflection.BindingFlags;Lcli.System.Reflection.Binder;[Lcli.System.Type;[Lcli.System.Reflection.ParameterModifier;)Lcli.System.Reflection.MethodInfo;" />
                    <ldarg_0 />
                    <ldnull />
                    <callvirt type="System.Reflection.MethodInfo" name="Invoke" sig="(Ljava.lang.Object;[Ljava.lang.Object;)Ljava.lang.Object;" />
                    <ret />
                    <label name="not_cloneable" />
                    <newobj class="java.lang.CloneNotSupportedException" name="&lt;init&gt;" sig="()V" />
                    <throw />
                </alternateBody>
            </method>
            <method name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" modifiers="private static">
                <body>
                    <ldarg_0 />
                    <callvirt class="java.lang.Object" name="getClass" sig="()Ljava.lang.Class;" />
                    <call class="java.lang.Class" name="getName" sig="()Ljava.lang.String;" />
                    <ldstr value="@@" />
                    <ldarg_0 />
                    <callvirt class="java.lang.Object" name="hashCode" sig="()I" />
                    <call class="java.lang.Integer" name="toHexString" sig="(I)Ljava.lang.String;" />
                    <call type="System.String" name="Concat" sig="(Ljava.lang.String;Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" />
                    <ret />
                </body>
            </method>
            <method name="toString" sig="()Ljava.lang.String;" modifiers="public">
                <override name="ToString" />
                <body>
                    <ldarg_0 />
                    <call class="java.lang.Object" name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
                    <ret />
                </body>
                <alternateBody>
                    <ldarg_0 />
                    <isinst type="System.Array" />
                    <brfalse name="skip" />
                    <ldarg_0 />
                    <call class="java.lang.Object" name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
                    <br name="end" />
                    <label name="skip" />
                    <ldarg_0 />
                    <callvirt type="System.Object" name="ToString" sig="()Ljava.lang.String;" />
                    <label name="end" />
                    <ret />
                </alternateBody>
                <nonvirtualAlternateBody>
                    <ldarg_0 />
                    <call class="java.lang.Object" name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
                    <ret />
                </nonvirtualAlternateBody>
            </method>
            <method name="hashCode" sig="()I" modifiers="public">
                <override name="GetHashCode" />
                <nonvirtualAlternateBody>
                    <ldarg_0 />
                    <call type="System.Runtime.CompilerServices.RuntimeHelpers" name="GetHashCode" sig="(Ljava.lang.Object;)I" />
                    <ret />
                </nonvirtualAlternateBody>
            </method>
            <method name="equals" sig="(Ljava.lang.Object;)Z" modifiers="public">
                <parameter name="obj" />
                <override name="Equals" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <ceq />
                    <ret />
                </body>
                <alternateBody>
                    <ldarg_0 />
                    <ldarg_1 />
                    <callvirt type="System.Object" name="Equals" sig="(Ljava.lang.Object;)Z" />
                    <ret />
                </alternateBody>
                <nonvirtualAlternateBody>
                    <ldarg_0 />
                    <ldarg_1 />
                    <ceq />
                    <ret />
                </nonvirtualAlternateBody>
            </method>
            <method name="finalize" sig="()V" modifiers="protected">
                <throws class="java.lang.Throwable" />
                <!-- NOTE we don't override Finalize, because that would be bad for performance,
		     instead, the compiler contains a hack to lazily override Finalize when a class
		     overrides our finalize
		     TODO consider adding code to constructor (in debug builds) to detect that someone
		     has overriden our finalize from another .NET language (if no intermediate Java base class
		     has overriden finalize, the lazy override of Object.Finalize hasn't kicked in and finalize
		     will never be called)
		-->
                <body>
                    <ldarg_0 />
                    <call type="System.Object" name="Finalize" sig="()V" />
                    <ret />
                </body>
                <alternateBody>
                    <!-- if code in the java.lang package explicitly invokes finalize on a non java.lang.Object
			 derived object	we just ignore it -->
                    <ret />
                </alternateBody>
            </method>
        </class>
        <class name="java.lang.String" shadows="System.String" modifiers="public final">
            <implements class="java.io.Serializable" />
            <implements class="java.lang.Comparable" />
            <implements class="java.lang.CharSequence" />
            <attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
                <parameter>Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/lang/CharSequence;</parameter>
            </attribute>
            <attribute type="IKVM.Attributes.NonNestedInnerClassAttribute" sig="(Ljava.lang.String;)V">
                <parameter>java.lang.String$CaseInsensitiveComparator</parameter>
            </attribute>
            <field name="serialVersionUID" sig="J" modifiers="private static final" constant="-6849794470754667710" />
            <constructor sig="()V" modifiers="public">
                <alternateBody>
                    <ldstr value="" />
                    <call type="System.String" name="Copy" sig="(Ljava.lang.String;)Ljava.lang.String;" />
                    <ret />
                </alternateBody>
            </constructor>
            <constructor sig="([C)V" modifiers="public">
                <parameter name="value" />
                <alternateBody>
                    <!-- force a NullPointerException if the array is null -->
                    <ldarg_0 />
                    <ldlen />
                    <pop />
                    <ldarg_0 />
                    <newobj type="System.String" name=".ctor" sig="([C)V" />
                    <ret />
                </alternateBody>
            </constructor>
            <constructor sig="([CII)V" modifiers="public">
                <parameter name="value" />
                <parameter name="offset" />
                <parameter name="count" />
            </constructor>
            <!-- Package private constructor (that OpenJDK uses to avoid copying the array) -->
            <constructor sig="([CZ)V" modifiers="">
                <alternateBody>
                    <ldarg_0 />
                    <newobj type="System.String" name=".ctor" sig="([C)V" />
                    <ret />
                </alternateBody>
            </constructor>
            <constructor sig="(Ljava.lang.String;)V" modifiers="public">
                <parameter name="original" />
                <redirect class="System.String, mscorlib" name="Copy" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
            </constructor>
            <constructor sig="(Ljava.lang.StringBuffer;)V" modifiers="public">
                <parameter name="buffer" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="(Ljava.lang.StringBuffer;)Ljava.lang.String;" />
            </constructor>
            <constructor sig="(Ljava.lang.StringBuilder;)V" modifiers="public">
                <parameter name="builder" />
                <alternateBody>
                    <ldarg_0 />
                    <ldfld class="java.lang.StringBuilder" name="value" sig="[C" />
                    <ldc_i4_0 />
                    <ldarg_0 />
                    <ldfld class="java.lang.StringBuilder" name="count" sig="I" />
                    <newobj type="System.String" name=".ctor" sig="([CII)V" />
                    <ret />
                </alternateBody>
            </constructor>
            <constructor sig="([B)V" modifiers="public">
                <parameter name="bytes" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([B)Ljava.lang.String;" />
            </constructor>
            <constructor sig="([BI)V" modifiers="public">
                <parameter name="ascii" />
                <parameter name="hibyte" />
                <attribute type="System.ObsoleteAttribute" sig="()V" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BI)Ljava.lang.String;" />
            </constructor>
            <constructor sig="([BII)V" modifiers="public">
                <parameter name="bytes" />
                <parameter name="offset" />
                <parameter name="length" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BII)Ljava.lang.String;" />
            </constructor>
            <constructor sig="([BIII)V" modifiers="public">
                <parameter name="ascii" />
                <parameter name="hibyte" />
                <parameter name="offset" />
                <parameter name="count" />
                <attribute type="System.ObsoleteAttribute" sig="()V" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIII)Ljava.lang.String;" />
            </constructor>
            <constructor sig="([BLjava.lang.String;)V" modifiers="public">
                <parameter name="bytes" />
                <parameter name="charsetName" />
                <throws class="java.io.UnsupportedEncodingException" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BLjava.lang.String;)Ljava.lang.String;" />
            </constructor>
            <constructor sig="([BIILjava.lang.String;)V" modifiers="public">
                <parameter name="bytes" />
                <parameter name="offset" />
                <parameter name="length" />
                <parameter name="charsetName" />
                <throws class="java.io.UnsupportedEncodingException" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIILjava.lang.String;)Ljava.lang.String;" />
            </constructor>
            <constructor sig="([III)V" modifiers="public">
                <parameter name="codePoints" />
                <parameter name="offset" />
                <parameter name="count" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([III)Ljava.lang.String;" />
            </constructor>
            <constructor sig="([BIILjava.nio.charset.Charset;)V" modifiers="public">
                <parameter name="bytes" />
                <parameter name="offset" />
                <parameter name="length" />
                <parameter name="charset" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIILjava.nio.charset.Charset;)Ljava.lang.String;" />
            </constructor>
            <constructor sig="([BLjava.nio.charset.Charset;)V" modifiers="public">
                <parameter name="bytes" />
                <parameter name="charset" />
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BLjava.nio.charset.Charset;)Ljava.lang.String;" />
            </constructor>
            <method name="hashCode" sig="()I" modifiers="public">
                <redirect class="java.lang.StringHelper" name="hashCode" type="static" sig="(Lcli.System.String;)I" />
            </method>
            <!-- we have a toString here to make sure that it shows up as a declared method in reflection -->
            <method name="toString" sig="()Ljava.lang.String;" modifiers="public" />
            <!-- we have an equals here to make sure that it shows up as a declared method in reflection -->
            <method name="equals" sig="(Ljava.lang.Object;)Z" modifiers="public">
                <parameter name="anObject" />
            </method>
            <method name="valueOf" sig="(Z)Ljava.lang.String;" modifiers="public static">
                <parameter name="b" />
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="valueOf" sig="(I)Ljava.lang.String;" modifiers="public static">
                <parameter name="i" />
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="valueOf" sig="(J)Ljava.lang.String;" modifiers="public static">
                <parameter name="l" />
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="valueOf" sig="(C)Ljava.lang.String;" modifiers="public static">
                <parameter name="c" />
                <body>
                    <ldarg_0 />
                    <ldc_i4_1 />
                    <newobj type="System.String" name=".ctor" sig="(CI)V" />
                    <ret />
                </body>
            </method>
            <method name="valueOf" sig="(F)Ljava.lang.String;" modifiers="public static">
                <parameter name="f" />
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="valueOf" sig="(D)Ljava.lang.String;" modifiers="public static">
                <parameter name="d" />
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="valueOf" sig="([C)Ljava.lang.String;" modifiers="public static">
                <parameter name="data" />
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="valueOf" sig="([CII)Ljava.lang.String;" modifiers="public static">
                <parameter name="data" />
                <parameter name="offset" />
                <parameter name="count" />
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="valueOf" sig="(Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
                <parameter name="obj" />
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="substring" sig="(I)Ljava.lang.String;" modifiers="public">
                <parameter name="beginIndex" />
                <redirect name="Substring" />
            </method>
            <method name="length" sig="()I" modifiers="public">
                <redirect name="get_Length" />
            </method>
            <method name="charAt" sig="(I)C" modifiers="public" nonullcheck="true">
                <parameter name="index" />
                <body>
                    <ldarg_1 />
                    <ldarg_0 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <bge_un name="throw" />
                    <ldarg_0 />
                    <ldarg_1 />
                    <callvirt type="System.String" name="get_Chars" sig="(I)C" />
                    <ret />
                    <label name="throw" />
                    <newobj class="java.lang.StringIndexOutOfBoundsException" name="&lt;init&gt;" sig="()V" />
                    <throw />
                </body>
            </method>
            <method name="substring" sig="(II)Ljava.lang.String;" modifiers="public">
                <parameter name="beginIndex" />
                <parameter name="endIndex" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)Ljava.lang.String;" />
            </method>
            <method name="indexOf" sig="(I)I" modifiers="public">
                <parameter name="ch" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;I)I" />
            </method>
            <method name="indexOf" sig="(II)I" modifiers="public" nonullcheck="true">
                <parameter name="ch" />
                <parameter name="fromIndex" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)I" />
            </method>
            <method name="indexOf" sig="(Ljava.lang.String;)I" modifiers="public">
                <parameter name="str" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
            </method>
            <method name="indexOf" sig="(Ljava.lang.String;I)I" modifiers="public">
                <parameter name="str" />
                <parameter name="fromIndex" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
            </method>
            <!-- These methods are package private and used by (Abstract)StringBuilder/Buffer -->
            <method name="getChars" sig="([CI)V" modifiers="">
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;[CI)V" />
            </method>
            <method name="indexOf" sig="([CII[CIII)I" modifiers="static">
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="indexOf" sig="([CIILjava.lang.String;I)I" modifiers="static">
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="lastIndexOf" sig="([CII[CIII)I" modifiers="static">
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="lastIndexOf" sig="([CIILjava.lang.String;I)I" modifiers="static">
                <redirect class="java.lang.StringHelper" />
            </method>
            <!-- end of package private methods used by (Abstract)StringBuilder/Buffer -->
            <method name="lastIndexOf" sig="(I)I" modifiers="public">
                <parameter name="ch" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;I)I" />
            </method>
            <method name="lastIndexOf" sig="(II)I" modifiers="public">
                <parameter name="ch" />
                <parameter name="fromIndex" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)I" />
            </method>
            <method name="lastIndexOf" sig="(Ljava.lang.String;)I" modifiers="public">
                <parameter name="str" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
            </method>
            <method name="lastIndexOf" sig="(Ljava.lang.String;I)I" modifiers="public">
                <parameter name="str" />
                <parameter name="fromIndex" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
            </method>
            <method name="toCharArray" sig="()[C" modifiers="public">
                <redirect name="ToCharArray" />
            </method>
            <method name="getChars" sig="(II[CI)V" modifiers="public">
                <parameter name="srcBegin" />
                <parameter name="srcEnd" />
                <parameter name="dst" />
                <parameter name="dstBegin" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II[CI)V" />
            </method>
            <method name="startsWith" sig="(Ljava.lang.String;)Z" modifiers="public" nonullcheck="true">
                <parameter name="prefix" />
                <body>
                    <!--
		    if (this.Length >= prefix.Length)
		    {
		        for (int i = 0; i < prefix.Length; i++)
		        {
		            if (this[i] != prefix[i])
		            {
			            return false;
		            }
		        }
		        return true;
		    }
		    return false;
                    -->
                    <ldarg_0 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <ldarg_1 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <blt name="ret_false" />
                    <ldc_i4_0 />
                    <stloc name="i" type="System.Int32" />
                    <br name="start_loop" />
                    <label name="next" />
                    <ldarg_0 />
                    <ldloc name="i" />
                    <callvirt type="System.String" name="get_Chars" sig="(I)C" />
                    <ldarg_1 />
                    <ldloc name="i" />
                    <callvirt type="System.String" name="get_Chars" sig="(I)C" />
                    <bne_un name="ret_false" />
                    <ldloc name="i" />
                    <ldc_i4_1 />
                    <add />
                    <stloc name="i" type="System.Int32" />
                    <label name="start_loop" />
                    <ldloc name="i" />
                    <ldarg_1 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <blt name="next" />
                    <ldc_i4_1 />
                    <ret />
                    <label name="ret_false" />
                    <ldc_i4_0 />
                    <ret />
                </body>
            </method>
            <method name="startsWith" sig="(Ljava.lang.String;I)Z" modifiers="public" nonullcheck="true">
                <parameter name="prefix" />
                <parameter name="toffset" />
                <body>
                    <!--
		        if (toffset >= 0
                            && toffset <= this.Length
                            && this.Length - toffset >= prefix.Length)
		        {
		            for (int i = 0; i < prefix.Length; i++)
		            {
	                        if (this[i + toffset] != prefix[i])
	                        {
		                        return false;
	                        }
		            }
		            return true;
		        }
		        return false;
                    -->
                    <ldarg_0 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <ldarg_2 />
                    <blt_un name="ret_false" />
                    <ldarg_0 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <ldarg_2 />
                    <sub />
                    <ldarg_1 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <blt name="ret_false" />
                    <ldc_i4_0 />
                    <stloc name="i" type="System.Int32" />
                    <br name="start_loop" />
                    <label name="next" />
                    <ldarg_0 />
                    <ldloc name="i" />
                    <ldarg_2 />
                    <add />
                    <callvirt type="System.String" name="get_Chars" sig="(I)C" />
                    <ldarg_1 />
                    <ldloc name="i" />
                    <callvirt type="System.String" name="get_Chars" sig="(I)C" />
                    <bne_un name="ret_false" />
                    <ldloc name="i" />
                    <ldc_i4_1 />
                    <add />
                    <stloc name="i" type="System.Int32" />
                    <label name="start_loop" />
                    <ldloc name="i" />
                    <ldarg_1 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <blt name="next" />
                    <ldc_i4_1 />
                    <ret />
                    <label name="ret_false" />
                    <ldc_i4_0 />
                    <ret />
                </body>
            </method>
            <method name="endsWith" sig="(Ljava.lang.String;)Z" modifiers="public" nonullcheck="true">
                <parameter name="suffix" />
                <body>
                    <!--
                    int j = this.Length - suffix.Length;
                    if (j >= 0)
                    {
                        for (int i = 0; i < suffix.Length; i++)
                        {
                            if (this[j++] != suffix[i])
                            {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                    -->
                    <ldarg_0 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <ldarg_1 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <sub />
                    <stloc name="j" type="System.Int32" />
                    <ldloc name="j" />
                    <ldc_i4_0 />
                    <blt name="ret_false" />
                    <ldc_i4_0 />
                    <stloc name="i" type="System.Int32" />
                    <br name="start_loop" />
                    <label name="next" />
                    <ldarg_0 />
                    <ldloc name="j" />
                    <dup />
                    <ldc_i4_1 />
                    <add />
                    <stloc name="j" type="System.Int32" />
                    <callvirt type="System.String" name="get_Chars" sig="(I)C" />
                    <ldarg_1 />
                    <ldloc name="i" />
                    <callvirt type="System.String" name="get_Chars" sig="(I)C" />
                    <bne_un name="ret_false" />
                    <ldloc name="i" />
                    <ldc_i4_1 />
                    <add />
                    <stloc name="i" type="System.Int32" />
                    <label name="start_loop" />
                    <ldloc name="i" />
                    <ldarg_1 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <blt name="next" />
                    <ldc_i4_1 />
                    <ret />
                    <label name="ret_false" />
                    <ldc_i4_0 />
                    <ret />
                </body>
            </method>
            <method name="toUpperCase" sig="()Ljava.lang.String;" modifiers="public">
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
            </method>
            <method name="toUpperCase" sig="(Ljava.util.Locale;)Ljava.lang.String;" modifiers="public">
                <parameter name="locale" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.util.Locale;)Ljava.lang.String;" />
            </method>
            <method name="toLowerCase" sig="()Ljava.lang.String;" modifiers="public">
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
            </method>
            <method name="toLowerCase" sig="(Ljava.util.Locale;)Ljava.lang.String;" modifiers="public">
                <parameter name="locale" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.util.Locale;)Ljava.lang.String;" />
            </method>
            <method name="compareToIgnoreCase" sig="(Ljava.lang.String;)I" modifiers="public">
                <parameter name="str" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
            </method>
            <method name="equalsIgnoreCase" sig="(Ljava.lang.String;)Z" modifiers="public">
                <parameter name="anotherString" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Z" />
            </method>
            <method name="intern" sig="()Ljava.lang.String;" modifiers="public">
                <redirect type="static" name="Intern" sig="(Ljava.lang.String;)Ljava.lang.String;" />
            </method>
            <method name="compareTo" sig="(Ljava.lang.String;)I" modifiers="public">
                <parameter name="anotherString" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
            </method>
            <method name="compareTo" sig="(Ljava.lang.Object;)I" modifiers="public ACC_BRIDGE ACC_SYNTHETIC">
                <parameter name="o" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <castclass type="System.String" />
                    <call class="java.lang.StringHelper" name="compareTo" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
                    <ret />
                </body>
            </method>
            <method name="replace" sig="(CC)Ljava.lang.String;" modifiers="public">
                <parameter name="oldChar" />
                <parameter name="newChar" />
                <redirect name="Replace" />
            </method>
            <method name="getBytes" sig="()[B" modifiers="public">
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)[B" />
            </method>
            <method name="getBytes" sig="(Ljava.lang.String;)[B" modifiers="public">
                <parameter name="charsetName" />
                <throws class="java.io.UnsupportedEncodingException" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)[B" />
            </method>
            <method name="subSequence" sig="(II)Ljava.lang.CharSequence;" modifiers="public">
                <parameter name="beginIndex" />
                <parameter name="endIndex" />
                <redirect class="java.lang.StringHelper" type="static" name="substring" sig="(Lcli.System.String;II)Ljava.lang.String;" />
            </method>
            <method name="trim" sig="()Ljava.lang.String;" modifiers="public">
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
            </method>
            <method name="regionMatches" sig="(ZILjava.lang.String;II)Z" modifiers="public">
                <parameter name="ignoreCase" />
                <parameter name="toffset" />
                <parameter name="other" />
                <parameter name="ooffset" />
                <parameter name="len" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;ZILjava.lang.String;II)Z" />
            </method>
            <method name="regionMatches" sig="(ILjava.lang.String;II)Z" modifiers="public">
                <parameter name="toffset" />
                <parameter name="other" />
                <parameter name="ooffset" />
                <parameter name="len" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;ILjava.lang.String;II)Z" />
            </method>
            <method name="getBytes" sig="(II[BI)V" modifiers="public">
                <parameter name="srcBegin" />
                <parameter name="srcEnd" />
                <parameter name="dst" />
                <parameter name="dstBegin" />
                <attribute type="System.ObsoleteAttribute" sig="()V" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II[BI)V" />
            </method>
            <method name="concat" sig="(Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
                <parameter name="str" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" />
            </method>
            <method name="contains" sig="(Ljava.lang.CharSequence;)Z" modifiers="public">
                <parameter name="s" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
            </method>
            <method name="codePointAt" sig="(I)I" modifiers="public">
                <parameter name="index" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;I)I" />
            </method>
            <method name="codePointBefore" sig="(I)I" modifiers="public">
                <parameter name="index" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;I)I" />
            </method>
            <method name="codePointCount" sig="(II)I" modifiers="public">
                <parameter name="beginIndex" />
                <parameter name="endIndex" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II)I" />
            </method>
            <method name="offsetByCodePoints" sig="(II)I" modifiers="public">
                <parameter name="index" />
                <parameter name="codePointOffset" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II)I" />
            </method>
            <method name="contentEquals" sig="(Ljava.lang.CharSequence;)Z" modifiers="public">
                <parameter name="cs" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
            </method>
            <method name="contentEquals" sig="(Ljava.lang.StringBuffer;)Z" modifiers="public">
                <parameter name="sb" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <callvirt class="java.lang.StringBuffer" name="toString" sig="()Ljava.lang.String;" />
                    <callvirt type="System.String" name="Equals" sig="(Ljava.lang.String;)Z" />
                    <ret />
                </body>
            </method>
            <method name="replace" sig="(Ljava.lang.CharSequence;Ljava.lang.CharSequence;)Ljava.lang.String;" modifiers="public">
                <parameter name="target" />
                <parameter name="replacement" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.CharSequence;Ljava.lang.CharSequence;)Ljava.lang.String;" />
            </method>
            <method name="matches" sig="(Ljava.lang.String;)Z" modifiers="public">
                <parameter name="regex" />
                <body>
                    <ldarg_1 />
                    <ldarg_0 />
                    <call class="java.util.regex.Pattern" name="matches" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
                    <ret />
                </body>
            </method>
            <method name="replaceAll" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
                <parameter name="regex" />
                <parameter name="replacement" />
                <body>
                    <ldarg_1 />
                    <call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
                    <ldarg_0 />
                    <callvirt class="java.util.regex.Pattern" name="matcher" sig="(Ljava.lang.CharSequence;)Ljava.util.regex.Matcher;" />
                    <ldarg_2 />
                    <callvirt class="java.util.regex.Matcher" name="replaceAll" sig="(Ljava.lang.String;)Ljava.lang.String;" />
                    <ret />
                </body>
            </method>
            <method name="replaceFirst" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
                <parameter name="regex" />
                <parameter name="replacement" />
                <body>
                    <ldarg_1 />
                    <call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
                    <ldarg_0 />
                    <callvirt class="java.util.regex.Pattern" name="matcher" sig="(Ljava.lang.CharSequence;)Ljava.util.regex.Matcher;" />
                    <ldarg_2 />
                    <callvirt class="java.util.regex.Matcher" name="replaceFirst" sig="(Ljava.lang.String;)Ljava.lang.String;" />
                    <ret />
                </body>
            </method>
            <method name="split" sig="(Ljava.lang.String;)[Ljava.lang.String;" modifiers="public">
                <parameter name="regex" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <ldc_i4_0 />
                    <callvirt class="java.lang.String" name="split" sig="(Ljava.lang.String;I)[Ljava.lang.String;" />
                    <ret />
                </body>
            </method>
            <method name="split" sig="(Ljava.lang.String;I)[Ljava.lang.String;" modifiers="public">
                <parameter name="regex" />
                <parameter name="limit" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)[Ljava.lang.String;" />
            </method>
            <method name="copyValueOf" sig="([C)Ljava.lang.String;" modifiers="public static">
                <parameter name="data" />
                <body>
                    <!-- force a NullPointerException if the array is null -->
                    <ldarg_0 />
                    <ldlen />
                    <pop />
                    <ldarg_0 />
                    <newobj type="System.String" name=".ctor" sig="([C)V" />
                    <ret />
                </body>
            </method>
            <method name="copyValueOf" sig="([CII)Ljava.lang.String;" modifiers="public static">
                <parameter name="data" />
                <parameter name="offset" />
                <parameter name="count" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <ldarg_2 />
                    <newobj type="System.String" name=".ctor" sig="([CII)V" />
                    <ret />
                </body>
            </method>
            <method name="format" sig="(Ljava.lang.String;[Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
                <parameter name="format" />
                <parameter name="args">
                    <attribute type="System.ParamArrayAttribute" sig="()V" />
                </parameter>
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="format" sig="(Ljava.util.Locale;Ljava.lang.String;[Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
                <parameter name="l" />
                <parameter name="format" />
                <parameter name="args">
                    <attribute type="System.ParamArrayAttribute" sig="()V" />
                </parameter>
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="isEmpty" sig="()Z" modifiers="public">
                <body>
                    <ldarg_0 />
                    <callvirt type="System.String" name="get_Length" sig="()I" />
                    <ldc_i4_0 />
                    <ceq />
                    <ret />
                </body>
            </method>
            <method name="getBytes" sig="(Ljava.nio.charset.Charset;)[B" modifiers="public">
                <parameter name="charset" />
                <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.nio.charset.Charset;)[B" />
            </method>
            <method name="join" sig="(Ljava.lang.CharSequence;[Ljava.lang.CharSequence;)Ljava.lang.String;" modifiers="public static">
                <parameter name="delimiter" />
                <parameter name="elements">
                    <attribute type="System.ParamArrayAttribute" sig="()V" />
                </parameter>
                <redirect class="java.lang.StringHelper" />
            </method>
            <method name="join" sig="(Ljava.lang.CharSequence;Ljava.lang.Iterable;)Ljava.lang.String;" modifiers="public static">
                <parameter name="delimiter" />
                <parameter name="elements" />
                <attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
                    <parameter>(Ljava/lang/CharSequence;Ljava/lang/Iterable&lt;+Ljava/lang/CharSequence;&gt;;)Ljava/lang/String;</parameter>
                </attribute>
                <redirect class="java.lang.StringHelper" />
            </method>
            <!-- default interface methods we should interherit from CharSequence (currently this isn't done automatically) -->
            <method name="chars" sig="()Ljava.util.stream.IntStream;" modifiers="public">
                <redirect class="java.lang.StringHelper" sig="(Ljava.lang.String;)Ljava.util.stream.IntStream;" type="static" />
            </method>
            <method name="codePoints" sig="()Ljava.util.stream.IntStream;" modifiers="public">
                <redirect class="java.lang.StringHelper" sig="(Ljava.lang.String;)Ljava.util.stream.IntStream;" type="static" />
            </method>
            <field name="CASE_INSENSITIVE_ORDER" sig="Ljava.util.Comparator;" modifiers="public static final">
                <attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
                    <parameter>Ljava/util/Comparator&lt;Ljava/lang/String;&gt;;</parameter>
                </attribute>
            </field>
            <!-- TODO mark this method as BeforeFieldInit (and benchmark to see if that is faster) -->
            <clinit>
                <body>
                    <ldnull />
                    <newobj class="java.lang.String$CaseInsensitiveComparator" name="&lt;init&gt;" sig="(Ljava.lang.String$1;)V" />
                    <stsfld class="java.lang.String" name="CASE_INSENSITIVE_ORDER" sig="Ljava.util.Comparator;" />
                    <ret />
                </body>
            </clinit>
        </class>
        <class name="java.lang.Throwable" shadows="System.Exception" modifiers="public">
            <implements class="java.io.Serializable" />
            <attribute type="System.SerializableAttribute" sig="()V" />
            <field name="serialVersionUID" sig="J" modifiers="private static final" constant="-3042686055658047285" />
            <field name="serialPersistentFields" sig="[Ljava.io.ObjectStreamField;" modifiers="private static final" />
            <field name="suppressFillInStackTrace" sig="Z" modifiers="static">
                <attribute type="System.ThreadStaticAttribute" sig="()V" />
            </field>
            <field name="UNASSIGNED_STACK" sig="[Ljava.lang.StackTraceElement;" modifiers="static final" />
            <field name="SUPPRESSED_SENTINEL" sig="Ljava.util.List;" modifiers="static final" />
            <field name="detailMessage" sig="Ljava.lang.String;" />
            <field name="cause" sig="Ljava.lang.Throwable;" />
            <field name="original" sig="Ljava.lang.Throwable;" />
            <field name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
            <field name="tracePart1" sig="Lcli.System.Diagnostics.StackTrace;" />
            <field name="tracePart2" sig="Lcli.System.Diagnostics.StackTrace;" />
            <field name="suppressedExceptions" sig="Ljava.util.List;" />
            <clinit>
                <body>
                    <call type="IKVM.Internal.ExceptionHelper" name="getPersistentFields" sig="()[Ljava.io.ObjectStreamField;" />
                    <stsfld class="java.lang.Throwable" name="serialPersistentFields" sig="[Ljava.io.ObjectStreamField;" />
                    <ldc_i4_0 />
                    <newarr sig="Ljava.lang.StackTraceElement;" />
                    <stsfld class="java.lang.Throwable" name="UNASSIGNED_STACK" sig="[Ljava.lang.StackTraceElement;" />
                    <ldc_i4_0 />
                    <newobj class="java.util.ArrayList" name="&lt;init&gt;" sig="(I)V" />
                    <call class="java.util.Collections" name="unmodifiableList" sig="(Ljava.util.List;)Ljava.util.List;" />
                    <stsfld class="java.lang.Throwable" name="SUPPRESSED_SENTINEL" sig="Ljava.util.List;" />
                    <ret />
                </body>
            </clinit>
            <method name="__&lt;suppressFillInStackTrace&gt;" sig="()V" modifiers="public static">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
                    <parameter>Never</parameter>
                </attribute>
                <body>
                    <ldc_i4_1 />
                    <stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <ret />
                </body>
            </method>
            <method name="__mapImpl" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="static">
                <body>
                    <!-- this emits the conversion code based on the <exceptionMappings /> defined below -->
                    <exceptionMapping />
                </body>
            </method>
            <method name="__&lt;unmap&gt;" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public static">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
                    <parameter>Never</parameter>
                </attribute>
                <body>
                    <ldarg_0 />
                    <call type="IKVM.Internal.ExceptionHelper" name="UnmapException" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
                    <ret />
                </body>
            </method>
            <method name="__&lt;fixate&gt;" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public static">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
                    <parameter>Never</parameter>
                </attribute>
                <body>
                    <ldarg_0 />
                    <call type="IKVM.Internal.ExceptionHelper" name="FixateException" sig="(Ljava.lang.Throwable;)V" />
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="readObject" sig="(Ljava.io.ObjectInputStream;)V" modifiers="private">
                <throws class="java.io.IOException" />
                <throws class="java.lang.ClassNotFoundException" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <call type="IKVM.Internal.ExceptionHelper" name="readObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectInputStream;)V" />
                    <ret />
                </body>
            </method>
            <method name="writeObject" sig="(Ljava.io.ObjectOutputStream;)V" modifiers="private">
                <throws class="java.io.IOException" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <call type="IKVM.Internal.ExceptionHelper" name="writeObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectOutputStream;)V" />
                    <ret />
                </body>
            </method>
            <constructor sig="()V" modifiers="public">
                <body>
                    <!-- Start field initialization -->
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="UNASSIGNED_STACK" sig="[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="SUPPRESSED_SENTINEL" sig="Ljava.util.List;" />
                    <stfld class="java.lang.Throwable" name="suppressedExceptions" sig="Ljava.util.List;" />
                    <!-- End field initialization -->
                    <ldarg_0 />
                    <ldstr value="" />
                    <call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;)V" />
                    <ldarg_0 />
                    <ldarg_0 />
                    <stfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                    <!-- Start fillInStackTrace call -->
                    <ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <ldc_i4_0 />
                    <stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <brtrue name="skipFillInStackTrace" />
                    <ldarg_0 />
                    <callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
                    <pop />
                    <label name="skipFillInStackTrace" />
                    <!-- End fillInStackTrace call -->
                    <ret />
                </body>
            </constructor>
            <constructor sig="(Ljava.lang.String;)V" modifiers="public">
                <parameter name="message" />
                <body>
                    <!-- Start field initialization -->
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="UNASSIGNED_STACK" sig="[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="SUPPRESSED_SENTINEL" sig="Ljava.util.List;" />
                    <stfld class="java.lang.Throwable" name="suppressedExceptions" sig="Ljava.util.List;" />
                    <!-- End field initialization -->
                    <ldarg_0 />
                    <ldarg_1 />
                    <call type="IKVM.Internal.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
                    <call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;)V" />
                    <ldarg_0 />
                    <ldarg_0 />
                    <stfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                    <!-- Start fillInStackTrace call -->
                    <ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <ldc_i4_0 />
                    <stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <brtrue name="skipFillInStackTrace" />
                    <ldarg_0 />
                    <callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
                    <pop />
                    <label name="skipFillInStackTrace" />
                    <!-- End fillInStackTrace call -->
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.lang.Throwable" name="detailMessage" sig="Ljava.lang.String;" />
                    <ret />
                </body>
            </constructor>
            <constructor sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" modifiers="public">
                <parameter name="message" />
                <parameter name="cause" />
                <body>
                    <!-- Start field initialization -->
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="UNASSIGNED_STACK" sig="[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="SUPPRESSED_SENTINEL" sig="Ljava.util.List;" />
                    <stfld class="java.lang.Throwable" name="suppressedExceptions" sig="Ljava.util.List;" />
                    <!-- End field initialization -->
                    <ldarg_0 />
                    <ldarg_1 />
                    <call type="IKVM.Internal.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
                    <ldarg_2 />
                    <call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
                    <ldarg_0 />
                    <ldarg_0 />
                    <stfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                    <!-- Start fillInStackTrace call -->
                    <ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <ldc_i4_0 />
                    <stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <brtrue name="skipFillInStackTrace" />
                    <ldarg_0 />
                    <callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
                    <pop />
                    <label name="skipFillInStackTrace" />
                    <!-- End fillInStackTrace call -->
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.lang.Throwable" name="detailMessage" sig="Ljava.lang.String;" />
                    <ldarg_0 />
                    <ldarg_2 />
                    <stfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                    <ret />
                </body>
            </constructor>
            <constructor sig="(Ljava.lang.Throwable;)V" modifiers="public">
                <parameter name="cause" />
                <body>
                    <!-- Start field initialization -->
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="UNASSIGNED_STACK" sig="[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="SUPPRESSED_SENTINEL" sig="Ljava.util.List;" />
                    <stfld class="java.lang.Throwable" name="suppressedExceptions" sig="Ljava.util.List;" />
                    <!-- End field initialization -->
                    <ldarg_0 />
                    <ldarg_1 />
                    <call type="IKVM.Internal.ExceptionHelper" name="GetMessageFromCause" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" />
                    <ldarg_1 />
                    <call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
                    <ldarg_0 />
                    <ldarg_0 />
                    <stfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                    <!-- Start fillInStackTrace call -->
                    <ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <ldc_i4_0 />
                    <stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <brtrue name="skipFillInStackTrace" />
                    <ldarg_0 />
                    <callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
                    <pop />
                    <label name="skipFillInStackTrace" />
                    <!-- End fillInStackTrace call -->
                    <ldarg_1 />
                    <brfalse name="no_cause" />
                    <ldarg_0 />
                    <ldarg_1 />
                    <callvirt class="java.lang.Throwable" name="toString" sig="()Ljava.lang.String;" />
                    <stfld class="java.lang.Throwable" name="detailMessage" sig="Ljava.lang.String;" />
                    <label name="no_cause" />
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                    <ret />
                </body>
            </constructor>
            <constructor sig="(Ljava.lang.String;Ljava.lang.Throwable;ZZ)V" modifiers="protected">
                <parameter name="message" />
                <parameter name="cause" />
                <parameter name="enableSuppression" />
                <parameter name="writableStackTrace" />
                <body>
                    <!-- Start field initialization -->
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="UNASSIGNED_STACK" sig="[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
                    <ldsfld class="java.lang.Throwable" name="SUPPRESSED_SENTINEL" sig="Ljava.util.List;" />
                    <stfld class="java.lang.Throwable" name="suppressedExceptions" sig="Ljava.util.List;" />
                    <!-- End field initialization -->
                    <ldarg_0 />
                    <ldarg_1 />
                    <call type="IKVM.Internal.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
                    <ldarg_2 />
                    <call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
                    <ldarg_s argNum="4" />
                    <brfalse name="else" />
                    <!-- Start fillInStackTrace call -->
                    <ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <ldc_i4_0 />
                    <stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
                    <brtrue name="skipFillInStackTrace" />
                    <ldarg_0 />
                    <callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
                    <pop />
                    <label name="skipFillInStackTrace" />
                    <!-- End fillInStackTrace call -->
                    <br name="endif" />
                    <label name="else" />
                    <ldarg_0 />
                    <ldnull />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <label name="endif" />
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.lang.Throwable" name="detailMessage" sig="Ljava.lang.String;" />
                    <ldarg_0 />
                    <ldarg_2 />
                    <stfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                    <ldarg_3 />
                    <brtrue name="end" />
                    <ldarg_0 />
                    <ldnull />
                    <stfld class="java.lang.Throwable" name="suppressedExceptions" sig="Ljava.util.List;" />
                    <label name="end" />
                    <ret />
                </body>
            </constructor>
            <method name="printStackTrace" sig="()V" modifiers="public">
                <redirect class="java.lang.ThrowableHelper" sig="(Ljava.lang.Throwable;)V" type="static" />
            </method>
            <method name="printStackTrace" sig="(Ljava.io.PrintStream;)V" modifiers="public">
                <parameter name="s" />
                <redirect class="java.lang.ThrowableHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintStream;)V" type="static" />
            </method>
            <method name="printStackTrace" sig="(Ljava.io.PrintWriter;)V" modifiers="public">
                <parameter name="s" />
                <redirect class="java.lang.ThrowableHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintWriter;)V" type="static" />
            </method>
            <method name="getMessage" sig="()Ljava.lang.String;" modifiers="public">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.lang.Throwable" name="detailMessage" sig="Ljava.lang.String;" />
                    <ret />
                </body>
                <alternateBody>
                    <ldarg_0 />
                    <callvirt class="cli.System.Exception" name="get_Message" sig="()Ljava.lang.String;" />
                    <ret />
                </alternateBody>
            </method>
            <method name="getLocalizedMessage" sig="()Ljava.lang.String;" modifiers="public">
                <redirect class="cli.IKVM.Internal.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
            </method>
            <method name="fillInStackTrace" sig="()Ljava.lang.Throwable;" modifiers="public">
                <body>
                    <ldarg_0 />
                    <call type="System.Threading.Monitor" name="Enter" sig="(Ljava.lang.Object;)V" />
                    <exceptionBlock>
                        <try>
                            <ldarg_0 />
                            <ldfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                            <brfalse name="leave" />
                            <!--
	                    stackTrace = UNASSIGNED_STACK;
                            tracePart1 = null;
                            tracePart2 = new cli.System.Diagnostics.StackTrace(true);
                            -->
                            <ldarg_0 />
                            <ldsfld class="java.lang.Throwable" name="UNASSIGNED_STACK" sig="[Ljava.lang.StackTraceElement;" />
                            <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                            <ldarg_0 />
                            <ldnull />
                            <stfld class="java.lang.Throwable" name="tracePart1" sig="Lcli.System.Diagnostics.StackTrace;" />
                            <ldarg_0 />
                            <ldc_i4_1 />
                            <newobj type="System.Diagnostics.StackTrace" name=".ctor" sig="(Z)V" />
                            <stfld class="java.lang.Throwable" name="tracePart2" sig="Lcli.System.Diagnostics.StackTrace;" />
                            <label name="leave" />
                            <leave name="end" />
                        </try>
                        <finally>
                            <ldarg_0 />
                            <call type="System.Threading.Monitor" name="Exit" sig="(Ljava.lang.Object;)V" />
                            <endfinally />
                        </finally>
                    </exceptionBlock>
                    <label name="end" />
                    <ldarg_0 />
                    <ret />
                </body>
                <alternateBody>
                    <ldarg_0 />
                    <call type="IKVM.Internal.ExceptionHelper" name="fillInStackTrace" sig="(Ljava.lang.Throwable;)V" />
                    <ldarg_0 />
                    <ret />
                </alternateBody>
            </method>
            <method name="initCause" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public">
                <parameter name="cause" />
                <body>
                    <ldarg_0 />
                    <call type="System.Threading.Monitor" name="Enter" sig="(Ljava.lang.Object;)V" />
                    <exceptionBlock>
                        <try>
                            <ldarg_0 />
                            <ldarg_0 />
                            <ldfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                            <ldarg_1 />
                            <call type="IKVM.Internal.ExceptionHelper" name="checkInitCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;Ljava.lang.Throwable;)V" />
                            <ldarg_0 />
                            <ldarg_1 />
                            <stfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                            <leave name="end" />
                        </try>
                        <finally>
                            <ldarg_0 />
                            <call type="System.Threading.Monitor" name="Exit" sig="(Ljava.lang.Object;)V" />
                            <endfinally />
                        </finally>
                    </exceptionBlock>
                    <label name="end" />
                    <ldarg_0 />
                    <ret />
                </body>
                <alternateBody>
                    <!-- non-Java exception cannot have its cause changed, so we call checkInitCause in a way that will always throw -->
                    <ldarg_0 />
                    <ldnull />
                    <ldnull />
                    <call type="IKVM.Internal.ExceptionHelper" name="checkInitCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;Ljava.lang.Throwable;)V" />
                    <ldarg_0 />
                    <ret />
                </alternateBody>
            </method>
            <method name="getCause" sig="()Ljava.lang.Throwable;" modifiers="public">
                <body>
                    <ldarg_0 />
                    <call type="IKVM.Internal.ExceptionHelper" name="getCause" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
                    <ret />
                </body>
                <alternateBody>
                    <ldarg_0 />
                    <call class="cli.System.Exception" name="get_InnerException" sig="()Ljava.lang.Throwable;" />
                    <ret />
                </alternateBody>
            </method>
            <method name="getStackTrace" sig="()[Ljava.lang.StackTraceElement;" modifiers="public">
                <body>
                    <ldarg_0 />
                    <call type="IKVM.Internal.ExceptionHelper" name="getOurStackTrace" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" />
                    <callvirt type="System.Array" name="Clone" sig="()Ljava.lang.Object;" />
                    <castclass class="[Ljava.lang.StackTraceElement;" />
                    <ret />
                </body>
            </method>
            <method name="getOurStackTrace" sig="()[Ljava.lang.StackTraceElement;" modifiers="private">
                <redirect class="cli.IKVM.Internal.ExceptionHelper" name="getOurStackTrace" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" />
            </method>
            <method name="setStackTrace" sig="([Ljava.lang.StackTraceElement;)V" modifiers="public">
                <parameter name="stackTrace" />
                <redirect class="cli.IKVM.Internal.ExceptionHelper" name="setStackTrace" sig="(Ljava.lang.Throwable;[Ljava.lang.StackTraceElement;)V" />
            </method>
            <method name="toString" sig="()Ljava.lang.String;" modifiers="public">
                <redirect class="cli.IKVM.Internal.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
            </method>
            <method name="GetObjectData" sig="(Lcli.System.Runtime.Serialization.SerializationInfo;Lcli.System.Runtime.Serialization.StreamingContext;)V" modifiers="public">
                <attribute type="System.Security.Permissions.SecurityPermissionAttribute" sig="(Lcli.System.Security.Permissions.SecurityAction;)V">
                    <parameter>Demand</parameter>
                    <property name="SerializationFormatter" sig="Z">true</property>
                </attribute>
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
                    <parameter>Never</parameter>
                </attribute>
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <ldarg_2 />
                    <call type="System.Exception" name="GetObjectData" sig="(Lcli.System.Runtime.Serialization.SerializationInfo;Lcli.System.Runtime.Serialization.StreamingContext;)V" />
                    <ldarg_0 />
                    <ldarg_1 />
                    <call class="ikvm.internal.Serialization" name="writeObject" sig="(Ljava.lang.Object;Lcli.System.Runtime.Serialization.SerializationInfo;)V" />
                    <ret />
                </body>
            </method>
            <constructor sig="(Lcli.System.Runtime.Serialization.SerializationInfo;Lcli.System.Runtime.Serialization.StreamingContext;)V" modifiers="protected">
                <attribute type="System.Security.Permissions.SecurityPermissionAttribute" sig="(Lcli.System.Security.Permissions.SecurityAction;)V">
                    <parameter>Demand</parameter>
                    <property name="SerializationFormatter" sig="Z">true</property>
                </attribute>
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <ldarg_2 />
                    <call type="System.Exception" name=".ctor" sig="(Lcli.System.Runtime.Serialization.SerializationInfo;Lcli.System.Runtime.Serialization.StreamingContext;)V" />
                    <ldarg_0 />
                    <ldarg_1 />
                    <call class="ikvm.internal.Serialization" name="readObject" sig="(Ljava.lang.Object;Lcli.System.Runtime.Serialization.SerializationInfo;)V" />
                    <ret />
                </body>
            </constructor>
            <method name="addSuppressed" sig="(Ljava.lang.Throwable;)V" modifiers="public final">
                <parameter name="exception" />
                <redirect class="cli.IKVM.Internal.ExceptionHelper" name="addSuppressed" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)V" />
            </method>
            <method name="getSuppressed" sig="()[Ljava.lang.Throwable;" modifiers="public final">
                <redirect class="cli.IKVM.Internal.ExceptionHelper" name="getSuppressed" sig="(Ljava.lang.Throwable;)[Ljava.lang.Throwable;" />
            </method>
            <method name="getStackTraceDepth" sig="()I" modifiers="">
                <redirect class="cli.IKVM.Internal.ExceptionHelper" name="getStackTraceDepth" sig="(Ljava.lang.Throwable;)I" />
            </method>
            <method name="getStackTraceElement" sig="(I)Ljava.lang.StackTraceElement;" modifiers="">
                <redirect class="cli.IKVM.Internal.ExceptionHelper" name="getStackTraceElement" sig="(Ljava.lang.Throwable;I)Ljava.lang.StackTraceElement;" />
            </method>
        </class>
        <class name="java.lang.ThrowableHelper">
            <method name="getOurStackTrace" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;">
                <body>
                    <ldarg_0 />
                    <call type="IKVM.Internal.ExceptionHelper" name="getOurStackTrace" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.Comparable" shadows="System.IComparable" modifiers="public abstract interface">
            <attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
                <parameter>&lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</parameter>
            </attribute>
            <method name="compareTo" sig="(Ljava.lang.Object;)I" modifiers="public abstract">
                <attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
                    <parameter>(TT;)I</parameter>
                </attribute>
                <parameter name="o" />
                <override name="CompareTo" />
            </method>
        </class>
        <class name="java.lang.AutoCloseable" shadows="System.IDisposable" modifiers="public abstract interface">
            <method name="close" sig="()V" modifiers="public abstract">
                <throws class="java.lang.Exception" />
                <override name="Dispose" />
            </method>
        </class>
        <!-- Here we are adding/replacing methods to existing classes -->
        <class name="java.lang.Class">
            <implements class="cli.System.Runtime.Serialization.ISerializable" />
            <field name="typeWrapper" sig="Lcli.IKVM.Internal.TypeWrapper;" modifiers="">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </field>
        </class>
        <class name="java.lang.ClassLoader">
            <field name="wrapper" sig="Lcli.IKVM.Internal.ClassLoaderWrapper;" modifiers="">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </field>
            <constructor sig="(Z)V">
                <body>
                    <ldarg_0 />
                    <call class="java.lang.Object" name="&lt;init&gt;" sig="()V" />
                    <ret />
                </body>
            </constructor>
        </class>
        <class name="java.lang.Enum">
            <implements class="cli.System.Runtime.Serialization.ISerializable" />
        </class>
        <class name="java.lang.Thread">
            <field name="parkLock" sig="Ljava.lang.Object;" modifiers="" />
            <field name="parkState" sig="I" modifiers="" />
            <constructor sig="(Ljava.lang.Void;)V">
                <body>
                    <ldarg_0 />
                    <call class="java.lang.Object" name="&lt;init&gt;" sig="()V" />
                    <ret />
                </body>
            </constructor>
            <method name="isCCLOverridden" sig="(Ljava.lang.Thread;)Z">
                <body>
                    <ldftn class="java.lang.Thread" name="getContextClassLoader" sig="()Ljava.lang.ClassLoader;" />
                    <ldarg_0 />
                    <ldvirtftn class="java.lang.Thread" name="getContextClassLoader" sig="()Ljava.lang.ClassLoader;" />
                    <ceq />
                    <ldftn class="java.lang.Thread" name="setContextClassLoader" sig="(Ljava.lang.ClassLoader;)V" />
                    <ldarg_0 />
                    <ldvirtftn class="java.lang.Thread" name="setContextClassLoader" sig="(Ljava.lang.ClassLoader;)V" />
                    <ceq />
                    <and />
                    <ldc_i4_0 />
                    <ceq />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.ThreadGroup">
            <method name="createRootGroup" sig="()Ljava.lang.ThreadGroup;" modifiers="static">
                <body>
                    <newobj class="java.lang.ThreadGroup" name="&lt;init&gt;" sig="()V" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.reflect.Constructor">
            <method name="_slot" sig="()I">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.lang.reflect.Constructor" name="slot" sig="I" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.reflect.Executable">
            <method name="_slot" sig="()I" modifiers="abstract" attributes="NewSlot Virtual" />
        </class>
        <class name="java.lang.reflect.Field">
            <method name="_slot" sig="()I">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.lang.reflect.Field" name="slot" sig="I" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.reflect.Method">
            <method name="_slot" sig="()I">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.lang.reflect.Method" name="slot" sig="I" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.net.Inet6Address">
            <method name="_holder" sig="()Ljava.net.Inet6Address$Inet6AddressHolder;" modifiers="">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.net.Inet6Address" name="holder6" sig="Ljava.net.Inet6Address$Inet6AddressHolder;" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.net.InterfaceAddress">
            <method name="_set" sig="(Ljava.net.InetAddress;Ljava.net.Inet4Address;S)V" modifiers="">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.net.InterfaceAddress" name="address" sig="Ljava.net.InetAddress;" />
                    <ldarg_0 />
                    <ldarg_2 />
                    <stfld class="java.net.InterfaceAddress" name="broadcast" sig="Ljava.net.Inet4Address;" />
                    <ldarg_0 />
                    <ldarg_3 />
                    <stfld class="java.net.InterfaceAddress" name="maskLength" sig="S" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.net.NetworkInterface">
            <method name="_set1" sig="(Ljava.lang.String;Ljava.lang.String;I)V" modifiers="">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.net.NetworkInterface" name="name" sig="Ljava.lang.String;" />
                    <ldarg_0 />
                    <ldarg_2 />
                    <stfld class="java.net.NetworkInterface" name="displayName" sig="Ljava.lang.String;" />
                    <ldarg_0 />
                    <ldarg_3 />
                    <stfld class="java.net.NetworkInterface" name="index" sig="I" />
                    <ret />
                </body>
            </method>
            <method name="_set2" sig="([Ljava.net.InetAddress;[Ljava.net.InterfaceAddress;[Ljava.net.NetworkInterface;)V" modifiers="">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.net.NetworkInterface" name="addrs" sig="[Ljava.net.InetAddress;" />
                    <ldarg_0 />
                    <ldarg_2 />
                    <stfld class="java.net.NetworkInterface" name="bindings" sig="[Ljava.net.InterfaceAddress;" />
                    <ldarg_0 />
                    <ldarg_3 />
                    <stfld class="java.net.NetworkInterface" name="childs" sig="[Ljava.net.NetworkInterface;" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.security.AccessControlContext">
            <method name="_privilegedContext" sig="(Ljava.security.AccessControlContext;)V" modifiers="">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.security.AccessControlContext" name="privilegedContext" sig="Ljava.security.AccessControlContext;" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.AbstractCollection">
            <!-- We're adding an Add(object) method to allow collection initializers and Xml (soap) serialization to magically work -->
            <!-- NOTE Modifiers.Final and MethodAttributes.NewSlot is recognized by AotTypeWrapper.MapModifiers() as a magic combination that generates a non-virtual method -->
            <method name="Add" sig="(Ljava.lang.Object;)V" modifiers="public final" attributes="NewSlot">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
                    <parameter>Never</parameter>
                </attribute>
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <callvirt class="java.util.AbstractCollection" name="add" sig="(Ljava.lang.Object;)Z" />
                    <pop />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.AbstractMap">
            <!-- NOTE the compiler will not magically make all Maps enumerable, so we manually implement IEnumerable here -->
            <implements class="cli.System.Collections.IEnumerable" />
            <method name="System.Collections.IEnumerable.GetEnumerator" sig="()Lcli.System.Collections.IEnumerator;" modifiers="private" attributes="NewSlot Virtual Final">
                <override class="cli.System.Collections.IEnumerable" name="GetEnumerator" />
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <body>
                    <ldarg_0 />
                    <newobj class="ikvm.lang.MapEnumerator" name="&lt;init&gt;" sig="(Ljava.util.Map;)V" />
                    <ret />
                </body>
            </method>
            <!-- We're adding an Add(object,object) method to allow collection initializers to magically work -->
            <!-- NOTE Modifiers.Final and MethodAttributes.NewSlot is recognized by AotTypeWrapper.MapModifiers() as a magic combination that generates a non-virtual method -->
            <method name="Add" sig="(Ljava.lang.Object;Ljava.lang.Object;)V" modifiers="public final" attributes="NewSlot">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
                    <parameter>Never</parameter>
                </attribute>
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <ldarg_2 />
                    <callvirt class="java.util.AbstractMap" name="put" sig="(Ljava.lang.Object;Ljava.lang.Object;)Ljava.lang.Object;" />
                    <pop />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.concurrent.locks.AbstractQueuedSynchronizer">
            <method name="compareAndSetState" sig="(II)Z">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.locks.AbstractQueuedSynchronizer" name="state" sig="I" />
                    <ldarg_2 />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
                    <ldarg_1 />
                    <ceq />
                    <ret />
                </body>
            </method>
            <method name="compareAndSetWaitStatus" sig="(Ljava.util.concurrent.locks.AbstractQueuedSynchronizer$Node;II)Z">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.locks.AbstractQueuedSynchronizer$Node" name="waitStatus" sig="I" />
                    <ldarg_2 />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
                    <ldarg_1 />
                    <ceq />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.concurrent.locks.LockSupport">
            <method name="cmpxchgParkState" sig="(Ljava.lang.Thread;II)I">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.lang.Thread" name="parkState" sig="I" />
                    <ldarg_1 />
                    <ldarg_2 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
                    <ret />
                </body>
            </method>
            <method name="getParkLock" sig="(Ljava.lang.Thread;)Ljava.lang.Object;">
                <body>
                    <ldarg_0 />
                    <volatile />
                    <ldfld class="java.lang.Thread" name="parkLock" sig="Ljava.lang.Object;" />
                    <ret />
                </body>
            </method>
            <method name="setParkLock" sig="(Ljava.lang.Thread;Ljava.lang.Object;)V">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <volatile />
                    <stfld class="java.lang.Thread" name="parkLock" sig="Ljava.lang.Object;" />
                    <call type="System.Threading.Thread" name="MemoryBarrier" sig="" />
                    <ret />
                </body>
            </method>
        </class>
        <!-- This is where the "native" helper methods start -->
        <class name="ikvm.lang.CIL">
            <method name="unbox_byte" sig="(Ljava.lang.Object;)B">
                <body>
                    <ldarg_0 />
                    <unbox type="System.Byte" />
                    <ldind_i1 />
                    <ret />
                </body>
            </method>
            <method name="unbox_boolean" sig="(Ljava.lang.Object;)Z">
                <body>
                    <ldarg_0 />
                    <unbox type="System.Boolean" />
                    <ldind_i1 />
                    <ret />
                </body>
            </method>
            <method name="unbox_short" sig="(Ljava.lang.Object;)S">
                <body>
                    <ldarg_0 />
                    <unbox type="System.Int16" />
                    <ldind_i2 />
                    <ret />
                </body>
            </method>
            <method name="unbox_char" sig="(Ljava.lang.Object;)C">
                <body>
                    <ldarg_0 />
                    <unbox type="System.Char" />
                    <ldind_i2 />
                    <ret />
                </body>
            </method>
            <method name="unbox_int" sig="(Ljava.lang.Object;)I">
                <body>
                    <ldarg_0 />
                    <unbox type="System.Int32" />
                    <ldind_i4 />
                    <ret />
                </body>
            </method>
            <method name="unbox_float" sig="(Ljava.lang.Object;)F">
                <body>
                    <ldarg_0 />
                    <unbox type="System.Single" />
                    <ldind_r4 />
                    <ret />
                </body>
            </method>
            <method name="unbox_long" sig="(Ljava.lang.Object;)J">
                <body>
                    <ldarg_0 />
                    <unbox type="System.Int64" />
                    <ldind_i8 />
                    <ret />
                </body>
            </method>
            <method name="unbox_double" sig="(Ljava.lang.Object;)D">
                <body>
                    <ldarg_0 />
                    <unbox type="System.Double" />
                    <ldind_r8 />
                    <ret />
                </body>
            </method>
            <method name="box_byte" sig="(B)Lcli.System.Byte;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_boolean" sig="(Z)Lcli.System.Boolean;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_short" sig="(S)Lcli.System.Int16;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_char" sig="(C)Lcli.System.Char;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_int" sig="(I)Lcli.System.Int32;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_float" sig="(F)Lcli.System.Single;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_long" sig="(J)Lcli.System.Int64;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_double" sig="(D)Lcli.System.Double;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_sbyte" sig="(B)Lcli.System.SByte;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_ushort" sig="(S)Lcli.System.UInt16;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_uint" sig="(I)Lcli.System.UInt32;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="box_ulong" sig="(J)Lcli.System.UInt64;">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="unbox_sbyte" sig="(Lcli.System.SByte;)B">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="unbox_ushort" sig="(Lcli.System.UInt16;)S">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="unbox_uint" sig="(Lcli.System.UInt32;)I">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
            <method name="unbox_ulong" sig="(Lcli.System.UInt64;)J">
                <body>
                    <ldarg_0 />
                    <ret />
                </body>
            </method>
        </class>
        <class name="sun.invoke.util.VerifyAccess">
            <method name="isTypeVisible" sig="(Ljava.lang.Class;Ljava.lang.Class;)Z">
                <replace-method-call class="java.lang.Class" name="getClassLoader" sig="()Ljava.lang.ClassLoader;">
                    <code>
                        <call type="Java_sun_invoke_util_VerifyAccess" name="Class_getClassLoader" sig="(Ljava.lang.Class;)Ljava.lang.ClassLoader;" />
                    </code>
                </replace-method-call>
            </method>
        </class>
        <class name="sun.misc.Launcher">
            <method name="&lt;init&gt;" sig="()V">
                <replace-method-call class="sun.misc.Launcher$ExtClassLoader" name="getExtClassLoader" sig="()Lsun.misc.Launcher$ExtClassLoader;">
                    <code>
                        <call class="sun.misc.MiscHelper" name="getExtClassLoader" sig="()Lsun.misc.Launcher$ExtClassLoader;" />
                    </code>
                </replace-method-call>
                <replace-method-call class="sun.misc.Launcher$AppClassLoader" name="getAppClassLoader" sig="(Ljava.lang.ClassLoader;)Ljava.lang.ClassLoader;">
                    <code>
                        <call class="sun.misc.MiscHelper" name="getAppClassLoader" sig="(Ljava.lang.ClassLoader;)Ljava.lang.ClassLoader;" />
                    </code>
                </replace-method-call>
                <replace-method-call class="java.lang.Thread" name="setContextClassLoader" sig="(Ljava.lang.ClassLoader;)V">
                    <code>
                        <!--
                        The JDK uses setContextClassLoader() here, but we don't want to overwrite the context class loader if it has already been set.
                        -->
                        <callvirt class="java.lang.Thread" name="initContextClassLoader" sig="(Ljava.lang.ClassLoader;)V" />
                    </code>
                </replace-method-call>
            </method>
        </class>
        <class name="java.util.concurrent.atomic.AtomicReference">
            <method name="compareAndSet" sig="(Ljava.lang.Object;Ljava.lang.Object;)Z">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicReference" name="value" sig="Ljava.lang.Object;" />
                    <ldarg_2 />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Object&amp;;System.Object;System.Object" />
                    <ldarg_1 />
                    <ceq />
                    <ret />
                </body>
            </method>
            <method name="getAndSet" sig="(Ljava.lang.Object;)Ljava.lang.Object;">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicReference" name="value" sig="Ljava.lang.Object;" />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="Exchange" sig="System.Object&amp;;System.Object" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.concurrent.atomic.AtomicReferenceArray">
            <method name="get" sig="(I)Ljava.lang.Object;">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
                    <ldarg_1 />
                    <ldelema sig="Ljava.lang.Object;" />
                    <volatile />
                    <ldind_ref />
                    <ret />
                </body>
            </method>
            <method name="set" sig="(ILjava.lang.Object;)V">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
                    <ldarg_1 />
                    <ldelema sig="Ljava.lang.Object;" />
                    <ldarg_2 />
                    <volatile />
                    <stind_ref />
                    <call type="System.Threading.Thread" name="MemoryBarrier" sig="" />
                    <ret />
                </body>
            </method>
            <method name="getAndSet" sig="(ILjava.lang.Object;)Ljava.lang.Object;">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
                    <ldarg_1 />
                    <ldelema sig="Ljava.lang.Object;" />
                    <ldarg_2 />
                    <call type="System.Threading.Interlocked" name="Exchange" sig="System.Object&amp;;System.Object" />
                    <ret />
                </body>
            </method>
            <method name="compareAndSet" sig="(ILjava.lang.Object;Ljava.lang.Object;)Z">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
                    <ldarg_1 />
                    <ldelema sig="Ljava.lang.Object;" />
                    <ldarg_3 />
                    <ldarg_2 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Object&amp;;System.Object;System.Object" />
                    <ldarg_2 />
                    <ceq />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.concurrent.atomic.AtomicBoolean">
            <method name="compareAndSwapInt" sig="(II)Z">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicBoolean" name="value" sig="I" />
                    <ldarg_2 />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
                    <ldarg_1 />
                    <ceq />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.concurrent.atomic.AtomicInteger">
            <method name="getAndSet" sig="(I)I">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="Exchange" sig="System.Int32&amp;;System.Int32" />
                    <ret />
                </body>
            </method>
            <method name="compareAndSet" sig="(II)Z">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
                    <ldarg_2 />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
                    <ldarg_1 />
                    <ceq />
                    <ret />
                </body>
            </method>
            <method name="incrementAndGet" sig="()I">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
                    <call type="System.Threading.Interlocked" name="Increment" sig="System.Int32&amp;" />
                    <ret />
                </body>
            </method>
            <method name="decrementAndGet" sig="()I">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
                    <call type="System.Threading.Interlocked" name="Decrement" sig="System.Int32&amp;" />
                    <ret />
                </body>
            </method>
            <method name="addAndGet" sig="(I)I">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="Add" sig="System.Int32&amp;;System.Int32" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.concurrent.atomic.AtomicIntegerArray">
            <method name="get" sig="(I)I">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
                    <ldarg_1 />
                    <ldelema sig="I" />
                    <volatile />
                    <ldind_i4 />
                    <ret />
                </body>
            </method>
            <method name="set" sig="(II)V">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
                    <ldarg_1 />
                    <ldelema sig="I" />
                    <ldarg_2 />
                    <volatile />
                    <stind_i4 />
                    <call type="System.Threading.Thread" name="MemoryBarrier" sig="" />
                    <ret />
                </body>
            </method>
            <method name="getAndSet" sig="(II)I">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
                    <ldarg_1 />
                    <ldelema sig="I" />
                    <ldarg_2 />
                    <call type="System.Threading.Interlocked" name="Exchange" sig="System.Int32&amp;;System.Int32" />
                    <ret />
                </body>
            </method>
            <method name="compareAndSet" sig="(III)Z">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
                    <ldarg_1 />
                    <ldelema sig="I" />
                    <ldarg_3 />
                    <ldarg_2 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
                    <ldarg_2 />
                    <ceq />
                    <ret />
                </body>
            </method>
            <method name="incrementAndGet" sig="(I)I">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
                    <ldarg_1 />
                    <ldelema sig="I" />
                    <call type="System.Threading.Interlocked" name="Increment" sig="System.Int32&amp;" />
                    <ret />
                </body>
            </method>
            <method name="decrementAndGet" sig="(I)I">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
                    <ldarg_1 />
                    <ldelema sig="I" />
                    <call type="System.Threading.Interlocked" name="Decrement" sig="System.Int32&amp;" />
                    <ret />
                </body>
            </method>
            <method name="addAndGet" sig="(II)I">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
                    <ldarg_1 />
                    <ldelema sig="I" />
                    <ldarg_2 />
                    <call type="System.Threading.Interlocked" name="Add" sig="System.Int32&amp;;System.Int32" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.concurrent.atomic.AtomicLong">
            <method name="getAndSet" sig="(J)J">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicLong" name="value" sig="J" />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="Exchange" sig="System.Int64&amp;;System.Int64" />
                    <ret />
                </body>
            </method>
            <method name="compareAndSet" sig="(JJ)Z">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicLong" name="value" sig="J" />
                    <ldarg_2 />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int64&amp;;System.Int64;System.Int64" />
                    <ldarg_1 />
                    <ceq />
                    <ret />
                </body>
            </method>
            <method name="incrementAndGet" sig="()J">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicLong" name="value" sig="J" />
                    <call type="System.Threading.Interlocked" name="Increment" sig="System.Int64&amp;" />
                    <ret />
                </body>
            </method>
            <method name="decrementAndGet" sig="()J">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicLong" name="value" sig="J" />
                    <call type="System.Threading.Interlocked" name="Decrement" sig="System.Int64&amp;" />
                    <ret />
                </body>
            </method>
            <method name="addAndGet" sig="(J)J">
                <body>
                    <ldarg_0 />
                    <ldflda class="java.util.concurrent.atomic.AtomicLong" name="value" sig="J" />
                    <ldarg_1 />
                    <call type="System.Threading.Interlocked" name="Add" sig="System.Int64&amp;;System.Int64" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.util.concurrent.atomic.AtomicLongArray">
            <method name="get" sig="(I)J">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicLongArray" name="array" sig="[J" />
                    <ldarg_1 />
                    <ldelema sig="J" />
                    <volatile />
                    <ldind_i8 />
                    <ret />
                </body>
            </method>
            <method name="set" sig="(IJ)V">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicLongArray" name="array" sig="[J" />
                    <ldarg_1 />
                    <ldelema sig="J" />
                    <ldarg_2 />
                    <volatile />
                    <stind_i8 />
                    <call type="System.Threading.Thread" name="MemoryBarrier" sig="" />
                    <ret />
                </body>
            </method>
            <method name="getAndSet" sig="(IJ)J">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicLongArray" name="array" sig="[J" />
                    <ldarg_1 />
                    <ldelema sig="J" />
                    <ldarg_2 />
                    <call type="System.Threading.Interlocked" name="Exchange" sig="System.Int64&amp;;System.Int64" />
                    <ret />
                </body>
            </method>
            <method name="compareAndSet" sig="(IJJ)Z">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicLongArray" name="array" sig="[J" />
                    <ldarg_1 />
                    <ldelema sig="J" />
                    <ldarg_3 />
                    <ldarg_2 />
                    <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int64&amp;;System.Int64;System.Int64" />
                    <ldarg_2 />
                    <ceq />
                    <ret />
                </body>
            </method>
            <method name="incrementAndGet" sig="(I)J">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicLongArray" name="array" sig="[J" />
                    <ldarg_1 />
                    <ldelema sig="J" />
                    <call type="System.Threading.Interlocked" name="Increment" sig="System.Int64&amp;" />
                    <ret />
                </body>
            </method>
            <method name="decrementAndGet" sig="(I)J">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicLongArray" name="array" sig="[J" />
                    <ldarg_1 />
                    <ldelema sig="J" />
                    <call type="System.Threading.Interlocked" name="Decrement" sig="System.Int64&amp;" />
                    <ret />
                </body>
            </method>
            <method name="addAndGet" sig="(IJ)J">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.util.concurrent.atomic.AtomicLongArray" name="array" sig="[J" />
                    <ldarg_1 />
                    <ldelema sig="J" />
                    <ldarg_2 />
                    <call type="System.Threading.Interlocked" name="Add" sig="System.Int64&amp;;System.Int64" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.Byte">
            <implements class="cli.System.IFormattable">
                <method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
                    <redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Byte;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
                </method>
            </implements>
        </class>
        <class name="java.lang.Short">
            <implements class="cli.System.IFormattable">
                <method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
                    <redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Short;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
                </method>
            </implements>
        </class>
        <class name="java.lang.Integer">
            <implements class="cli.System.IFormattable">
                <method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
                    <redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Integer;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
                </method>
            </implements>
            <method name="compareUnsigned" sig="(II)I">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <bge_un name="ge" />
                    <ldc_i4_m1 />
                    <ret />
                    <label name="ge" />
                    <ldarg_0 />
                    <ldarg_1 />
                    <bne_un name="ne" />
                    <ldc_i4_0 />
                    <ret />
                    <label name="ne" />
                    <ldc_i4_1 />
                    <ret />
                </body>
            </method>
            <method name="divideUnsigned" sig="(II)I">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <div_un />
                    <ret />
                </body>
            </method>
            <method name="remainderUnsigned" sig="(II)I">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <rem_un />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.Long">
            <implements class="cli.System.IFormattable">
                <method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
                    <redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Long;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
                </method>
            </implements>
            <method name="compareUnsigned" sig="(JJ)I">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <bge_un name="ge" />
                    <ldc_i4_m1 />
                    <ret />
                    <label name="ge" />
                    <ldarg_0 />
                    <ldarg_1 />
                    <bne_un name="ne" />
                    <ldc_i4_0 />
                    <ret />
                    <label name="ne" />
                    <ldc_i4_1 />
                    <ret />
                </body>
            </method>
            <method name="divideUnsigned" sig="(JJ)J">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <div_un />
                    <ret />
                </body>
            </method>
            <method name="remainderUnsigned" sig="(JJ)J">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <rem_un />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.Float">
            <implements class="cli.System.IFormattable">
                <method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
                    <redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Float;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
                </method>
            </implements>
        </class>
        <class name="java.lang.Double">
            <implements class="cli.System.IFormattable">
                <method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
                    <redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Double;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
                </method>
            </implements>
        </class>
        <class name="java.nio.ByteBufferAsCharBufferB">
            <method name="getUnchecked" sig="(I)C">
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.ByteBufferAsCharBufferL">
            <method name="getUnchecked" sig="(I)C">
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.CharBuffer">
            <method name="getUnchecked" sig="(I)C">
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.CharBufferSpliterator">
            <method name="forEachRemaining" sig="(Ljava.util.function.IntConsumer;)V">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="tryAdvance" sig="(Ljava.util.function.IntConsumer;)Z">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectByteBuffer">
            <!-- add a constructor accessor for JNI -->
            <method name="__new" sig="(JI)Ljava.nio.DirectByteBuffer;" modifiers="static">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <newobj class="java.nio.DirectByteBuffer" name="&lt;init&gt;" sig="(JI)V" />
                    <ret />
                </body>
            </method>
            <constructor sig="(I)V">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </constructor>
            <method name="_get" sig="(I)B">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="_put" sig="(IB)V">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="()B">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)B">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([BII)Ljava.nio.ByteBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="getChar" sig="(J)C">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="putChar" sig="(JC)Ljava.nio.ByteBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="getShort" sig="(J)S">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="putShort" sig="(JS)Ljava.nio.ByteBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="getInt" sig="(J)I">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="putInt" sig="(JI)Ljava.nio.ByteBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="getLong" sig="(J)J">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="putLong" sig="(JJ)Ljava.nio.ByteBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="getFloat" sig="(J)F">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="putFloat" sig="(JF)Ljava.nio.ByteBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="getDouble" sig="(J)D">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="putDouble" sig="(JD)Ljava.nio.ByteBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.ByteBuffer;)Ljava.nio.ByteBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(B)Ljava.nio.ByteBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(IB)Ljava.nio.ByteBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([BII)Ljava.nio.ByteBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.ByteBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectByteBuffer$Deallocator">
            <method name="run" sig="()V">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectByteBufferR">
            <method name="_get" sig="(I)B">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectCharBufferS">
            <method name="get" sig="()C">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)C">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([CII)Ljava.nio.CharBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="getUnchecked" sig="(I)C">
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.CharBuffer;)Ljava.nio.CharBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(C)Ljava.nio.CharBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(IC)Ljava.nio.CharBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([CII)Ljava.nio.CharBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.CharBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectCharBufferU">
            <method name="get" sig="()C">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)C">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([CII)Ljava.nio.CharBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="getUnchecked" sig="(I)C">
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.CharBuffer;)Ljava.nio.CharBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(C)Ljava.nio.CharBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(IC)Ljava.nio.CharBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([CII)Ljava.nio.CharBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.CharBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectDoubleBufferS">
            <method name="get" sig="()D">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)D">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([DII)Ljava.nio.DoubleBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.DoubleBuffer;)Ljava.nio.DoubleBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(D)Ljava.nio.DoubleBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(ID)Ljava.nio.DoubleBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([DII)Ljava.nio.DoubleBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.DoubleBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectDoubleBufferU">
            <method name="get" sig="()D">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)D">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([DII)Ljava.nio.DoubleBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.DoubleBuffer;)Ljava.nio.DoubleBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(D)Ljava.nio.DoubleBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(ID)Ljava.nio.DoubleBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([DII)Ljava.nio.DoubleBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.DoubleBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectFloatBufferS">
            <method name="get" sig="()F">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)F">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([FII)Ljava.nio.FloatBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.FloatBuffer;)Ljava.nio.FloatBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(F)Ljava.nio.FloatBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(IF)Ljava.nio.FloatBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([FII)Ljava.nio.FloatBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.FloatBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectFloatBufferU">
            <method name="get" sig="()F">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)F">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([FII)Ljava.nio.FloatBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.FloatBuffer;)Ljava.nio.FloatBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(F)Ljava.nio.FloatBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(IF)Ljava.nio.FloatBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([FII)Ljava.nio.FloatBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.FloatBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectIntBufferS">
            <method name="get" sig="()I">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)I">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([III)Ljava.nio.IntBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.IntBuffer;)Ljava.nio.IntBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(I)Ljava.nio.IntBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(II)Ljava.nio.IntBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([III)Ljava.nio.IntBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.IntBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectIntBufferU">
            <method name="get" sig="()I">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)I">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([III)Ljava.nio.IntBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.IntBuffer;)Ljava.nio.IntBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(I)Ljava.nio.IntBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(II)Ljava.nio.IntBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([III)Ljava.nio.IntBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.IntBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectLongBufferS">
            <method name="get" sig="()J">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)J">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([JII)Ljava.nio.LongBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.LongBuffer;)Ljava.nio.LongBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(J)Ljava.nio.LongBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(IJ)Ljava.nio.LongBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([JII)Ljava.nio.LongBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.LongBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectLongBufferU">
            <method name="get" sig="()J">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)J">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([JII)Ljava.nio.LongBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.LongBuffer;)Ljava.nio.LongBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(J)Ljava.nio.LongBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(IJ)Ljava.nio.LongBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([JII)Ljava.nio.LongBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.LongBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectShortBufferS">
            <method name="get" sig="()S">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)S">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([SII)Ljava.nio.ShortBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.ShortBuffer;)Ljava.nio.ShortBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(S)Ljava.nio.ShortBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(IS)Ljava.nio.ShortBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([SII)Ljava.nio.ShortBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.ShortBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.DirectShortBufferU">
            <method name="get" sig="()S">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="(I)S">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="get" sig="([SII)Ljava.nio.ShortBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="put" sig="(Ljava.nio.ShortBuffer;)Ljava.nio.ShortBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(S)Ljava.nio.ShortBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="(IS)Ljava.nio.ShortBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="put" sig="([SII)Ljava.nio.ShortBuffer;">
                <!-- we use TreasAsSafe + Critical instead of SafeCritical to workaround PEVerify bug on .NET 2.0/3.5 -->
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
                <attribute type="System.Security.SecurityTreatAsSafeAttribute" sig="()V" />
            </method>
            <method name="compact" sig="()Ljava.nio.ShortBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.HeapCharBuffer">
            <method name="getUnchecked" sig="(I)C">
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.MappedByteBuffer">
            <method name="load" sig="()Ljava.nio.MappedByteBuffer;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="java.nio.StringCharBuffer">
            <method name="getUnchecked" sig="(I)C">
                <attribute type="System.Security.SecurityCriticalAttribute" sig="()V" />
            </method>
        </class>
        <class name="sun.reflect.Reflection">
            <!-- we manually hook up this native method, to prevent inlining and tail-call optimizations -->
            <method name="getCallerClass" sig="(I)Ljava.lang.Class;">
                <attribute type="System.Runtime.CompilerServices.MethodImplAttribute" sig="(Lcli.System.Runtime.CompilerServices.MethodImplOptions;)V">
                    <parameter>NoInlining</parameter>
                </attribute>
                <body>
                    <ldarg_0 />
                    <call type="Java_sun_reflect_Reflection" name="getCallerClass" sig="(I)Ljava.lang.Class;" />
                    <stloc name="class" class="java.lang.Class" />
                    <!-- "leave" is to thwart tail-call optimization -->
                    <leave name="x" />
                    <label name="x" />
                    <ldloc name="class" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.StackTraceElement">
            <attribute type="System.SerializableAttribute" sig="()V" />
        </class>
        <class name="java.lang.invoke.CallSite">
            <field name="ics" sig="Lcli.IKVM.Runtime.IIndyCallSite;" modifiers="">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </field>
        </class>
        <class name="java.lang.invoke.LambdaForm">
            <method name="_arity" sig="()I"  modifiers="final">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.lang.invoke.LambdaForm" name="arity" sig="I" />
                    <ret />
                </body>
            </method>
            <method name="compileToBytecode" sig="()Ljava.lang.invoke.MemberName;">
                <replace-method-call class="java.lang.invoke.InvokerBytecodeGenerator" name="generateCustomizedCode" sig="(Ljava.lang.invoke.LambdaForm;Ljava.lang.invoke.MethodType;)Ljava.lang.invoke.MemberName;">
                    <code>
                        <call type="NativeInvokerBytecodeGenerator" name="generateCustomizedCode" sig="(Ljava.lang.invoke.LambdaForm;Ljava.lang.invoke.MethodType;)Ljava.lang.invoke.MemberName;" />
                    </code>
                </replace-method-call>
            </method>
        </class>
        <class name="java.lang.invoke.LambdaForm$Name">
            <method name="_type" sig="()Ljava.lang.invoke.LambdaForm$BasicType;"  modifiers="final">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.lang.invoke.LambdaForm$Name" name="type" sig="Ljava.lang.invoke.LambdaForm$BasicType;" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.invoke.LambdaForm$NamedFunction">
            <method name="_member" sig="()Ljava.lang.invoke.MemberName;"  modifiers="final">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.lang.invoke.LambdaForm$NamedFunction" name="member" sig="Ljava.lang.invoke.MemberName;" />
                    <ret />
                </body>
            </method>
            <method name="_resolvedHandle" sig="()Ljava.lang.invoke.MethodHandle;"  modifiers="final">
                <body>
                    <ldarg_0 />
                    <ldfld class="java.lang.invoke.LambdaForm$NamedFunction" name="resolvedHandle" sig="Ljava.lang.invoke.MethodHandle;" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.invoke.MemberName">
            <field name="vmtarget" sig="Ljava.lang.Object;" modifiers="">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </field>
            <constructor sig="(Ljava.lang.reflect.Method;Z)V">
                <replace-method-call class="java.lang.invoke.MethodHandleNatives" name="init" sig="(Ljava.lang.invoke.MemberName;Ljava.lang.Object;)V">
                    <code>
                        <ldarg_2 />
                        <call type="Java_java_lang_invoke_MethodHandleNatives" name="init" sig="(Ljava.lang.invoke.MemberName;Ljava.lang.Object;Z)V" />
                    </code>
                </replace-method-call>
            </constructor>
            <method name="_clazz" sig="(Ljava.lang.Class;)V" modifiers="final">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.lang.invoke.MemberName" name="clazz" sig="Ljava.lang.Class;" />
                    <ret />
                </body>
            </method>
            <method name="_name" sig="(Ljava.lang.String;)V" modifiers="final">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.lang.invoke.MemberName" name="name" sig="Ljava.lang.String;" />
                    <ret />
                </body>
            </method>
            <method name="_type" sig="(Ljava.lang.invoke.MethodType;)V" modifiers="final">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.lang.invoke.MemberName" name="type" sig="Ljava.lang.Object;" />
                    <ret />
                </body>
            </method>
            <method name="_flags" sig="()I" modifiers="final">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <body>
                    <ldarg_0 />
                    <ldfld class="java.lang.invoke.MemberName" name="flags" sig="I" />
                    <ret />
                </body>
            </method>
            <method name="_flags" sig="(I)V" modifiers="final">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <stfld class="java.lang.invoke.MemberName" name="flags" sig="I" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="java.lang.invoke.MethodHandle">
            <field name="_invokeExactDelegate" sig="Ljava.lang.Object;" modifiers="">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </field>
            <method name="invoke" sig="([Ljava.lang.Object;)Ljava.lang.Object;">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </method>
            <method name="invokeExact" sig="([Ljava.lang.Object;)Ljava.lang.Object;">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </method>
            <method name="reflectionInvoke" sig="([Ljava.lang.Object;)Ljava.lang.Object;" modifiers="final">
                <throws class="java.lang.Throwable" />
                <attribute type="System.Runtime.CompilerServices.MethodImplAttribute" sig="(Lcli.System.Runtime.CompilerServices.MethodImplOptions;)V">
                    <parameter>NoInlining</parameter>
                </attribute>
                <attribute type="IKVM.Attributes.NameSigAttribute" sig="(Ljava.lang.String;Ljava.lang.String;)V">
                    <parameter>invoke</parameter>
                    <parameter>([Ljava.lang.Object;)Ljava.lang.Object;</parameter>
                </attribute>
                <attribute type="IKVM.Attributes.ModifiersAttribute" sig="(Lcli.IKVM.Attributes.Modifiers;)V">
                    <parameter>Public,Final,Native,VarArgs</parameter>
                </attribute>
                <body>
                    <ldstr value="MethodHandle.invoke cannot be invoked reflectively" />
                    <newobj class="java.lang.UnsupportedOperationException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
                    <throw />
                </body>
            </method>
            <method name="reflectionInvokeExact" sig="([Ljava.lang.Object;)Ljava.lang.Object;" modifiers="final">
                <throws class="java.lang.Throwable" />
                <attribute type="System.Runtime.CompilerServices.MethodImplAttribute" sig="(Lcli.System.Runtime.CompilerServices.MethodImplOptions;)V">
                    <parameter>NoInlining</parameter>
                </attribute>
                <attribute type="IKVM.Attributes.NameSigAttribute" sig="(Ljava.lang.String;Ljava.lang.String;)V">
                    <parameter>invokeExact</parameter>
                    <parameter>([Ljava.lang.Object;)Ljava.lang.Object;</parameter>
                </attribute>
                <attribute type="IKVM.Attributes.ModifiersAttribute" sig="(Lcli.IKVM.Attributes.Modifiers;)V">
                    <parameter>Public,Final,Native,VarArgs</parameter>
                </attribute>
                <body>
                    <ldstr value="MethodHandle.invokeExact cannot be invoked reflectively" />
                    <newobj class="java.lang.UnsupportedOperationException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
                    <throw />
                </body>
            </method>
        </class>
        <class name="java.lang.invoke.MethodHandleImpl">
            <method name="castReference" sig="(Ljava.lang.Class;Ljava.lang.Object;)Ljava.lang.Object;">
                <replace-method-call class="java.lang.Class" name="isInstance" sig="(Ljava.lang.Object;)Z">
                    <code>
                        <call type="Java_java_lang_invoke_MethodHandleNatives" name="Class_isInstance" sig="(Ljava.lang.Class;Ljava.lang.Object;)Z" />
                    </code>
                </replace-method-call>
            </method>
            <method name="makePairwiseConvert" sig="(Ljava.lang.invoke.MethodHandle;Ljava.lang.invoke.MethodType;ZZ)Ljava.lang.invoke.MethodHandle;">
                <replace-method-call class="java.lang.invoke.MethodHandleImpl" name="makePairwiseConvertByEditor" sig="(Ljava.lang.invoke.MethodHandle;Ljava.lang.invoke.MethodType;ZZ)Ljava.lang.invoke.MethodHandle;">
                    <code>
                        <call type="Java_java_lang_invoke_MethodHandleImpl" name="makePairwiseConvert" sig="(Ljava.lang.invoke.MethodHandle;Ljava.lang.invoke.MethodType;ZZ)Ljava.lang.invoke.MethodHandle;" />
                    </code>
                </replace-method-call>
            </method>
        </class>
        <class name="java.lang.invoke.DirectMethodHandle">
            <method name="_preparedLambdaForm" sig="(Ljava.lang.invoke.MethodType;I)Ljava.lang.invoke.LambdaForm;" modifiers="static">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <call class="java.lang.invoke.DirectMethodHandle" name="preparedLambdaForm" sig="(Ljava.lang.invoke.MethodType;I)Ljava.lang.invoke.LambdaForm;" />
                    <ret />
                </body>
            </method>
            <method name="allocateInstance" sig="(Ljava.lang.Object;)Ljava.lang.Object;">
                <attribute type="System.Security.SecuritySafeCriticalAttribute" sig="()V" />
            </method>
            <method name="makeAllocator" sig="(Ljava.lang.invoke.MemberName;)Ljava.lang.invoke.DirectMethodHandle;">
                <prologue>
                    <ldarg_0 />
                    <call type="Java_java_lang_invoke_DirectMethodHandle" name="makeStringAllocator" sig="(Ljava.lang.invoke.MemberName;)Ljava.lang.invoke.DirectMethodHandle;" />
                    <dup />
                    <brfalse name="continue" />
                    <ret />
                    <label name="continue" />
                    <pop />
                </prologue>
            </method>
        </class>
        <class name="java.lang.invoke.MethodType">
            <field name="voidAdapter" sig="Ljava.lang.Object;" modifiers="">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </field>
            <field name="_invokeExactDynamicMethod" sig="Lcli.System.Reflection.Emit.DynamicMethod;" modifiers="">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </field>
            <field name="_invokeExactDelegateType" sig="Lcli.System.Type;" modifiers="">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
            </field>
        </class>
        <class name="sun.util.locale.provider.JRELocaleProviderAdapter">
            <!-- We replace this method, because it looks for %JAVA_HOME%/lib/ext/localedata.jar and we don't have that -->
            <method name="isNonENLangSupported" sig="()Z">
                <body>
                    <call type="JRELocaleProviderAdapter" name="isNonENLangSupported" sig="()Z" />
                    <ret />
                </body>
            </method>
        </class>
        <class name="com.sun.xml.internal.ws.developer.ServerSideException">
            <!-- HACK we replace getMessage to remove the additional text that OpenJDK 8 appends -->
            <method name="getMessage" sig="()Ljava.lang.String;">
                <body>
                    <ldarg_0 />
                    <call class="java.lang.Throwable" name="getMessage" sig="()Ljava.lang.String;" />
                    <ret />
                </body>
            </method>
        </class>
    </assembly>
    <exceptionMappings>
        <exception src="System.NullReferenceException" dst="java.lang.NullPointerException" />
        <!-- many of the String and Object methods throw ArgumentNullException where Java throws an NPE -->
        <exception src="System.ArgumentNullException" dst="java.lang.NullPointerException" />
        <exception src="System.IndexOutOfRangeException" dst="java.lang.ArrayIndexOutOfBoundsException" />
        <!-- HACK for String methods, we remap ArgumentOutOfRangeException to StringIndexOutOfBoundsException -->
        <exception src="System.ArgumentOutOfRangeException" dst="java.lang.StringIndexOutOfBoundsException" />
        <exception src="System.InvalidCastException" dst="java.lang.ClassCastException">
            <code>
                <callvirt type="System.Exception" name="get_Message" sig="()Ljava.lang.String;" />
                <newobj class="java.lang.ClassCastException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
            </code>
        </exception>
        <!-- NOTE we "map" to java.lang.Error, because that is the base class of all possible mappings.
             The * in front of the class name means that all subclasses can be thrown as well.
        -->
        <exception src="System.TypeInitializationException" dst="*java.lang.Error">
            <code>
                <!-- this code is unreachable, TypeInitializationException is handled explicitly in ExceptionHelper.java -->
            </code>
        </exception>
        <exception src="System.Threading.SynchronizationLockException" dst="java.lang.IllegalMonitorStateException" />
        <exception src="System.OutOfMemoryException" dst="java.lang.OutOfMemoryError" />
        <exception src="System.DivideByZeroException" dst="java.lang.ArithmeticException">
            <code>
                <pop />
                <ldstr value="/ by zero" />
                <newobj class="java.lang.ArithmeticException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
            </code>
        </exception>
        <exception src="System.ArrayTypeMismatchException" dst="java.lang.ArrayStoreException" />
        <exception src="System.StackOverflowException" dst="java.lang.StackOverflowError" />
        <exception src="System.Threading.ThreadAbortException" dst="java.lang.ThreadDeath">
            <code>
                <castclass type="System.Threading.ThreadAbortException" />
                <call type="System.Threading.ThreadAbortException" name="get_ExceptionState" sig="()Ljava.lang.Object;" />
                <isinst class="java.lang.ThreadDeath" />
                <dup />
                <brtrue name="end" />
                <pop />
                <newobj class="java.lang.ThreadDeath" name="&lt;init&gt;" sig="()V" />
                <label name="end" />
                <!-- NOTE we do this last because ResetAbort clears the ExceptionState of the ThreadAbortException (why?) -->
                <!-- TODO we should put an exception handler around the ResetAbort call, because it will throw a ThreadStateException
		     if no Abort is pending (someone could have thrown the exception manually, or we could have called on a 
		     previous handler that turned out not to be match for this exception type) -->
                <stloc name="x" class="java.lang.ThreadDeath" />
                <exceptionBlock>
                    <try>
                        <!-- TODO instead of catching the ThreadStateException, we should check the ThreadState
			     before calling ResetAbort -->
                        <call type="System.Threading.Thread" name="ResetAbort" sig="()V" />
                        <leave name="next" />
                    </try>
                    <catch type="System.Threading.ThreadStateException">
                        <!-- ignore the exception -->
                        <leave name="next" />
                    </catch>
                </exceptionBlock>
                <label name="next" />
                <ldloc name="x" />
            </code>
        </exception>
        <!-- TODO make sure the originating method was from an IKVM.NET generated assembly, because if it was
	     generated by non-Java code, this remapping is obviously bogus. -->
        <exception src="System.OverflowException" dst="java.lang.NegativeArraySizeException" />
    </exceptionMappings>
</root>
@


1.115
log
@Optimized LambdaForm compiler.
@
text
@d898 7
@


1.114
log
@Fixed regression introduced with pairwise convert optimization. MethodHandle String construction is now handled much more cleanly by hooking DirectMethodHandle.makeAllocator() instead of fiddling with the MemberName.
@
text
@d2870 41
d2932 9
@


1.113
log
@Make non-public final methods defined in map.xml that don't override anything automatically non-virtual.
@
text
@d2891 9
d2981 8
a2988 8
        <class name="java.lang.invoke.MethodHandles$Lookup">
            <!-- We hook this to undo the fiddling we do to support string constructors -->
            <method name="revealDirect" sig="(Ljava.lang.invoke.MethodHandle;)Ljava.lang.invoke.MethodHandleInfo;">
                <replace-method-call class="java.lang.invoke.MethodHandle" name="internalMemberName" sig="()Ljava.lang.invoke.MemberName;">
                    <code>
                        <call type="Java_java_lang_invoke_MethodHandleNatives" name="internalMemberName" sig="(Ljava.lang.invoke.MethodHandle;)Ljava.lang.invoke.MemberName;" />
                    </code>
                </replace-method-call>
a2989 2
        </class>
        <class name="java.lang.invoke.DirectMethodHandle">
d2993 11
@


1.112
log
@Improve MetrhodHandle.asType() performance by directly creating a single LambdaForm to do the conversion, instead of creating various intermediate forms (and MethodHandles).
@
text
@d2919 1
a2919 2
            <!-- NOTE Modifiers.Final and MethodAttributes.NewSlot is recognized by AotTypeWrapper.MapModifiers() as a magic combination that generates a non-virtual method -->
            <method name="reflectionInvoke" sig="([Ljava.lang.Object;)Ljava.lang.Object;" modifiers="final" attributes="NewSlot">
d2937 1
a2937 2
            <!-- NOTE Modifiers.Final and MethodAttributes.NewSlot is recognized by AotTypeWrapper.MapModifiers() as a magic combination that generates a non-virtual method -->
            <method name="reflectionInvokeExact" sig="([Ljava.lang.Object;)Ljava.lang.Object;" modifiers="final" attributes="NewSlot">
@


1.111
log
@Integrated OpenJDK 8u45.
@
text
@d2966 7
@


1.110
log
@Removed obsolete workaround.
@
text
@a1832 9
        <class name="sun.invoke.util.ValueConversions">
            <method name="castReference" sig="(Ljava.lang.Class;Ljava.lang.Object;)Ljava.lang.Object;">
                <replace-method-call class="java.lang.Class" name="isInstance" sig="(Ljava.lang.Object;)Z">
                    <code>
                        <call type="Java_sun_invoke_util_ValueConversions" name="Class_isInstance" sig="(Ljava.lang.Class;Ljava.lang.Object;)Z" />
                    </code>
                </replace-method-call>
            </method>
        </class>
d2958 9
@


1.109
log
@Bug fix. Allow MethodHandle for cli.System.Object methods to work on (Java compatble) arrays to handle a hole in the type system.
@
text
@a2967 6
            <!-- We have to disable this check, because we rely on Lookup.lookup() in our lambda bootstrap method -->
            <method name="checkUnprivilegedlookupClass" sig="(Ljava.lang.Class;I)V">
                <body>
                    <ret />
                </body>
            </method>
@


1.108
log
@Bug fix. Bootstrap classes that use .NET types in their signatures should be accessible via MethodHandles.
@
text
@d1833 9
@


1.107
log
@Optimized [Integer|Long].[compare|divide|remainder]Unsigned().
@
text
@d3 1
a3 1
  Copyright (C) 2002-2014 Jeroen Frijters
d1833 9
@


1.106
log
@Changed Thread.parkBlocker field accessiblity to internal, to allow java.util.concurrent.ForkJoinPool direct access.
@
text
@d2223 34
d2264 34
@


1.105
log
@Added security attributes needed for .NET 4 build.
@
text
@a1650 18
            <method name="getBlocker" sig="(Ljava.lang.Thread;)Ljava.lang.Object;">
                <body>
                    <ldarg_0 />
                    <volatile />
                    <ldfld class="java.lang.Thread" name="parkBlocker" sig="Ljava.lang.Object;" />
                    <ret />
                </body>
            </method>
            <method name="setBlocker" sig="(Ljava.lang.Thread;Ljava.lang.Object;)V">
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <volatile />
                    <stfld class="java.lang.Thread" name="parkBlocker" sig="Ljava.lang.Object;" />
                    <call type="System.Threading.Thread" name="MemoryBarrier" sig="" />
                    <ret />
                </body>
            </method>
@


1.104
log
@Replaced MethodWrapper.From[Method|Constructor|MethodOrConstructor] methods with MethodWrapper.FromExecutable().
@
text
@d2263 23
d2416 3
d2449 3
d2770 5
d2780 5
@


1.103
log
@Replaced AtomicReference[Array].getAndSet() implementations with Interlocked.Exchange() based implementations.
@
text
@d1482 3
@


1.102
log
@Don't report non-English locales if IKVM.OpenJDK.Localedata.dll is not available.
@
text
@d1883 9
d1918 11
@


1.101
log
@Bug fix. MethodHandle.invoke[Exact] methods should have VarArgs flag set.
@
text
@a2870 1
            <!-- TODO if we move locale data into a separate assembly, we could try to load that here -->
d2873 1
a2873 1
                    <ldc_i4_1 />
@


1.100
log
@First part of OpenJDK 8 integration.
@
text
@d2809 1
a2809 1
                    <parameter>Public,Final,Native</parameter>
d2828 1
a2828 1
                    <parameter>Public,Final,Native</parameter>
@


1.99
log
@Integrated OpenJDK 7u40 JSR-292 implementation (aka LambdaForms).
@
text
@a266 4
            <!-- Package private constructor, that we redirect to static helper -->
            <constructor sig="(II[C)V" modifiers="">
                <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="(II[C)Ljava.lang.String;" />
            </constructor>
d441 1
a441 1
            <!-- These three methods are package private and used by (Abstract)StringBuilder/Buffer -->
d448 3
d454 3
d883 15
d1501 1
a1501 1
            <method name="_set" sig="(ILjava.net.NetworkInterface;)V" modifiers="">
d1504 1
a1504 8
                    <ldarg_1 />
                    <stfld class="java.net.Inet6Address" name="scope_id" sig="I" />
                    <ldarg_0 />
                    <ldc_i4_1 />
                    <stfld class="java.net.Inet6Address" name="scope_id_set" sig="Z" />
                    <ldarg_0 />
                    <ldarg_2 />
                    <stfld class="java.net.Inet6Address" name="scope_ifname" sig="Ljava.net.NetworkInterface;" />
d2725 1
a2725 1
            <method name="getCallerClass0" sig="(I)Ljava.lang.Class;">
d2731 1
a2731 1
                    <call type="Java_sun_reflect_Reflection" name="getCallerClass0" sig="(I)Ljava.lang.Class;" />
d2837 16
d2869 20
@


1.98
log
@Merged OpenJDK 7u40 b34, except for java.lang.invoke and sun.invoke packages.
@
text
@d3 1
a3 1
  Copyright (C) 2002-2012 Jeroen Frijters
d2734 44
d2779 3
d2827 2
a2828 2
        <class name="java.lang.invoke.MethodHandleImpl$AllocateObject">
            <method name="allocate" sig="()Ljava.lang.Object;">
d2832 11
@


1.97
log
@Bug fix. String.CaseInsensitiveComparator inner class should be acknowledged by String.
@
text
@d2715 1
a2715 1
            <method name="getCallerClass" sig="(I)Ljava.lang.Class;">
d2721 2
a2722 2
                    <call type="Java_sun_reflect_Reflection" name="getCallerClass" sig="(I)Ljava.lang.Object;" />
                    <stloc name="class" class="java.lang.Object" />
a2726 1
                    <castclass class="java.lang.Class" />
@


1.96
log
@Performance fix. When throwing a ClassNotFoundException from Class.forName() or AssemblyClassLoader.loadClass() we should avoid calling fillInStackTrace() on the exception.
@
text
@d231 3
@


1.95
log
@Moved the remaining code from openjdk.cs to separate files.
@
text
@d898 1
a898 1
            <field name="suppressFillInStackTrace" sig="Z" modifiers="private static">
@


1.94
log
@Made boot class package handling simpler (more OpenJDK based). The package information is now read from the manifest instead of hard coded.
@
text
@d2718 1
a2718 1
                    <call type="IKVM.NativeCode.sun.reflect.Reflection" name="getCallerClass" sig="(I)Ljava.lang.Object;" />
@


1.93
log
@Removed map.xml patching of bootstrap resource loading methods in java.lang.ClassLoader.
@
text
@a1671 17
        <class name="java.lang.Package">
            <method name="getSystemPackage" sig="(Ljava.lang.String;)Ljava.lang.Package;">
                <body>
                    <ldsfld class="java.lang.Package" name="pkgs" sig="Ljava.util.Map;" />
                    <ldarg_0 />
                    <call class="java.lang.LangHelper" name="getSystemPackage" sig="(Ljava.util.Map;Ljava.lang.String;)Ljava.lang.Package;" />
                    <ret />
                </body>
            </method>
            <method name="getSystemPackages" sig="()[Ljava.lang.Package;">
                <body>
                    <ldsfld class="java.lang.Package" name="pkgs" sig="Ljava.util.Map;" />
                    <call class="java.lang.LangHelper" name="getSystemPackages" sig="(Ljava.util.Map;)[Ljava.lang.Package;" />
                    <ret />
                </body>
            </method>
        </class>
@


1.92
log
@Removed meaningless "modifiers" attribute on methods where we're just replacing the method body.
@
text
@a1413 14
            <method name="getBootstrapResource" sig="(Ljava.lang.String;)Ljava.net.URL;">
                <body>
                    <ldarg_0 />
                    <call class="java.lang.LangHelper" name="getBootstrapResource" sig="(Ljava.lang.String;)Ljava.net.URL;" />
                    <ret />
                </body>
            </method>
            <method name="getBootstrapResources" sig="(Ljava.lang.String;)Ljava.util.Enumeration;">
                <body>
                    <ldarg_0 />
                    <call class="java.lang.LangHelper" name="getBootstrapResources" sig="(Ljava.lang.String;)Ljava.util.Enumeration;" />
                    <ret />
                </body>
            </method>
@


1.91
log
@Add new to 7u6 (package private) String constructor.
@
text
@d1687 1
a1687 1
            <method name="getSystemPackage" sig="(Ljava.lang.String;)Ljava.lang.Package;" modifiers="static">
d1695 1
a1695 1
            <method name="getSystemPackages" sig="()[Ljava.lang.Package;" modifiers="static">
@


1.90
log
@Optimized String.valueOf(char).
@
text
@d256 8
@


1.89
log
@Mark String.compareTo(Object0 as bridge method.
@
text
@d3 1
a3 1
  Copyright (C) 2002-2011 Jeroen Frijters
d359 6
a364 1
                <redirect class="java.lang.StringHelper" />
@


1.88
log
@Throwable.addSuppressed() didn't have a proper parameter name.
@
text
@d664 1
a664 1
            <method name="compareTo" sig="(Ljava.lang.Object;)I" modifiers="public">
@


1.87
log
@Fixed Throwable.fillInStackTrace() to respect non-writeable stack trace.
@
text
@d1343 1
@


1.87.2.1
log
@Backported fixes:
- FileStore for non-accessible drive should throw exception when trying to create the FileStore, not when accessing the name() or type() properties.
- Graphics2D.clip(null) should only throw NPE for a Component graphics.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Handle Main-Class manifest value that spans multiple lines. Fix for bug #3461012.
- Informational messages should not be treated as error when -warnaserror is specified. Fix for #3443377.
- Don't enforce pre-1.5 class name rules in ikvmc (since HotSpot doesn't enforce any naming rules for classes loaded by the system (and boot) class loader, by default). Fix for #3443373.
- Fix for #3441959.
- Throwable.addSuppressed() didn't have a proper parameter name.
- mark getSpace0 with SecuritySafeCritical to avoid getting an exception with .NET 4
- Bug fix. Removed incorrect check for uninitialized objects on backward branch.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Added AssemblyInformationalVersionAttribute to OpenJDK assemblies (to set the "Product Version"). Part of patch #3458997.
- Include copyright and metadata in IKVM.OpenJDK.Tools.dll. Part of patch #3458997.
- Bug fix. Don't call Finish on unloadable TypeWrapper.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
- Suppress annotation custom attributes when enumerating inner classes.
- IKVM.Reflection: Bug fix. Fixed copy/paste error. FieldInfo.IsAssembly should test for FieldAttributes.Assembly access, not FieldAttributes.Family.
@
text
@a1342 1
                <parameter name="exception" />
@


1.86
log
@Don't map System.Security.VerificationException to java.lang.VerifyError.
@
text
@d1198 3
d1216 1
@


1.85
log
@Updated StringHelper to OpenJDK 7.
@
text
@a2828 1
        <exception src="System.Security.VerificationException" dst="java.lang.VerifyError" />
@


1.84
log
@Prevent inlining of the reflective invoke/invokeExact methods into the reflection dispatch DynamicMethod (as that screws up the exception location detection in the reflection dispatch method).
@
text
@d811 1
a811 8
                <body>
                    <ldarg_1 />
                    <call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
                    <ldarg_0 />
                    <ldarg_2 />
                    <callvirt class="java.util.regex.Pattern" name="split" sig="(Ljava.lang.CharSequence;I)[Ljava.lang.String;" />
                    <ret />
                </body>
d842 1
a842 8
                <body>
                    <newobj class="java.util.Formatter" name="&lt;init&gt;" sig="()V" />
                    <ldarg_0 />
                    <ldarg_1 />
                    <callvirt class="java.util.Formatter" name="format" sig="(Ljava.lang.String;[Ljava.lang.Object;)Ljava.util.Formatter;" />
                    <callvirt class="java.util.Formatter" name="toString" sig="()Ljava.lang.String;" />
                    <ret />
                </body>
d850 1
a850 9
                <body>
                    <ldarg_0 />
                    <newobj class="java.util.Formatter" name="&lt;init&gt;" sig="(Ljava.util.Locale;)V" />
                    <ldarg_1 />
                    <ldarg_2 />
                    <callvirt class="java.util.Formatter" name="format" sig="(Ljava.lang.String;[Ljava.lang.Object;)Ljava.util.Formatter;" />
                    <callvirt class="java.util.Formatter" name="toString" sig="()Ljava.lang.String;" />
                    <ret />
                </body>
@


1.83
log
@Special case reflective invocation of MethodHandle.invoke[Exact].
@
text
@d2777 3
d2796 3
@


1.82
log
@Added .NET 4 security attributes.
@
text
@d2767 40
@


1.81
log
@Switched to a different way to force Thread.[get|set]ContextClassLoader methods to be JIT compiled eagerly to avod RuntimeHelpers.PrepareMethod() which requires full trust.
Added back in the (unused) OpenJDK override checking code.
@
text
@d2740 5
d2767 5
@


1.80
log
@Fixed Thread.isCCLOverridden() bug. If the [g|s]etContextClassLoader() methods were not JITted before isCCLOverridden(), ldftn would return the JIT stub address and the vtable could contain the JITted method address.
@
text
@d1439 1
a1439 1
            <method name="prepareCCL" sig="()V">
d1441 2
a1442 4
                    <ldtoken class="java.lang.Thread" method="getContextClassLoader" sig="()Ljava.lang.ClassLoader;" />
                    <call class="cli.System.Runtime.CompilerServices.RuntimeHelpers" name="PrepareMethod" sig="(Lcli.System.RuntimeMethodHandle;)V" />
                    <ldtoken class="java.lang.Thread" method="setContextClassLoader" sig="(Ljava.lang.ClassLoader;)V" />
                    <call class="cli.System.Runtime.CompilerServices.RuntimeHelpers" name="PrepareMethod" sig="(Lcli.System.RuntimeMethodHandle;)V" />
d1445 1
a1445 1
            </method>
@


1.79
log
@Made sun.misc.Unsafe.ensureClassInitialized() into an intrinsic.
@
text
@d1439 9
@


1.78
log
@Updated java.nio.Bits to OpenJDK 7.
@
text
@a1884 49
        <class name="sun.misc.SharedSecrets">
            <method name="javaUtilJarAccess" sig="()Lsun.misc.JavaUtilJarAccess;">
                <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
                    <code>
                        <pop />
                        <pop />
                        <runclassinit class="java.util.jar.JarFile" />
                    </code>
                </replace-method-call>
            </method>
            <method name="getJavaNioAccess" sig="()Lsun.misc.JavaNioAccess;">
                <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
                    <code>
                        <pop />
                        <pop />
                        <!-- the Java source initializes java.nio.ByteOrder (which causes java.nio.Bits to initialize) -->
                        <runclassinit class="java.nio.Bits" />
                    </code>
                </replace-method-call>
            </method>
            <method name="getJavaIOAccess" sig="()Lsun.misc.JavaIOAccess;">
                <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
                    <code>
                        <pop />
                        <pop />
                        <runclassinit class="java.io.Console" />
                    </code>
                </replace-method-call>
            </method>
            <method name="getJavaSecurityProtectionDomainAccess" sig="()Lsun.misc.JavaSecurityProtectionDomainAccess;">
                <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
                    <code>
                        <pop />
                        <pop />
                        <runclassinit class="java.security.ProtectionDomain" />
                    </code>
                </replace-method-call>
            </method>
            <method name="getJavaSecurityAccess" sig="()Lsun.misc.JavaSecurityAccess;">
                <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
                    <code>
                        <pop />
                        <pop />
                        <!-- JDK bug: They are initializing AccessController here, but the setJavaSecurityAccess call is in ProtectionDomain -->
                        <runclassinit class="java.security.ProtectionDomain" />
                    </code>
                </replace-method-call>
            </method>
        </class>
@


1.77
log
@Updated java.security package and a massive amount of dependencies to OpenJDK 7.
@
text
@d1895 10
@


1.76
log
@Updated java.io package to OpenJDK 7.
@
text
@d1904 19
@


1.75
log
@Include OpenJDK 7 java.lang.AutoCloseable interface and make it shadow System.IDisposable. Removed java.io.Closeable special casing to support IDisposable (now automatic because Closeable extends AutoCloseable).
@
text
@a1903 9
            <method name="getJavaIODeleteOnExitAccess" sig="()Lsun.misc.JavaIODeleteOnExitAccess;">
                <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
                    <code>
                        <pop />
                        <pop />
                        <runclassinit class="java.io.File" />
                    </code>
                </replace-method-call>
            </method>
@


1.74
log
@Updated java.lang.Throwable to OpenJDK 7.
@
text
@d1394 6
@


1.73
log
@Unforked sun.misc.Launcher. Use (more) map.xml patching instead.
@
text
@d910 2
a911 1
            <field name="emptyStackTrace" sig="[Ljava.lang.StackTraceElement;" modifiers="private static final" />
d918 1
d925 5
a929 1
                    <stsfld class="java.lang.Throwable" name="emptyStackTrace" sig="[Ljava.lang.StackTraceElement;" />
d994 8
a1013 3
                    <ldsfld class="java.lang.Throwable" name="emptyStackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
d1024 8
a1044 3
                    <ldsfld class="java.lang.Throwable" name="emptyStackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
d1059 8
a1080 3
                    <ldsfld class="java.lang.Throwable" name="emptyStackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
d1097 8
a1118 3
                    <ldsfld class="java.lang.Throwable" name="emptyStackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
d1136 52
d1189 1
a1189 1
                <redirect class="cli.IKVM.Internal.ExceptionHelper" sig="(Ljava.lang.Throwable;)V" type="static" />
d1193 1
a1193 1
                <redirect class="cli.IKVM.Internal.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintStream;)V" type="static" />
d1197 1
a1197 1
                <redirect class="cli.IKVM.Internal.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintWriter;)V" type="static" />
d1221 1
a1221 1
	                    stackTrace = null;
d1226 1
a1226 1
                            <ldnull />
d1294 1
a1294 3
                    <ldarg_0 />
                    <ldfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                    <call type="IKVM.Internal.ExceptionHelper" name="getCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
d1306 1
a1306 1
                    <call class="java.lang.Throwable" name="getOurStackTrace" sig="()[Ljava.lang.StackTraceElement;" />
a1310 5
                <alternateBody>
                    <ldarg_0 />
                    <call type="IKVM.Internal.ExceptionHelper" name="getStackTrace" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" />
                    <ret />
                </alternateBody>
d1313 1
a1313 42
                <body>
                    <ldarg_0 />
                    <call type="System.Threading.Monitor" name="Enter" sig="(Ljava.lang.Object;)V" />
                    <exceptionBlock>
                        <try>
                            <ldarg_0 />
                            <ldfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                            <brfalse name="gen" />
                            <leave name="ok" />
                            <label name="gen" />
                            <ldarg_0 />
                            <ldarg_0 />
                            <ldarg_0 />
                            <ldfld class="java.lang.Throwable" name="tracePart1" sig="Lcli.System.Diagnostics.StackTrace;" />
                            <ldarg_0 />
                            <ldfld class="java.lang.Throwable" name="tracePart2" sig="Lcli.System.Diagnostics.StackTrace;" />
                            <call type="IKVM.Internal.ExceptionHelper" name="computeStackTrace" sig="(Ljava.lang.Throwable;Lcli.System.Diagnostics.StackTrace;Lcli.System.Diagnostics.StackTrace;)[Ljava.lang.StackTraceElement;" />
                            <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                            <ldarg_0 />
                            <ldnull />
                            <stfld class="java.lang.Throwable" name="tracePart1" sig="Lcli.System.Diagnostics.StackTrace;" />
                            <ldarg_0 />
                            <ldnull />
                            <stfld class="java.lang.Throwable" name="tracePart2" sig="Lcli.System.Diagnostics.StackTrace;" />
                            <leave name="ok" />
                        </try>
                        <finally>
                            <ldarg_0 />
                            <call type="System.Threading.Monitor" name="Exit" sig="(Ljava.lang.Object;)V" />
                            <endfinally />
                        </finally>
                    </exceptionBlock>
                    <label name="ok" />
                    <ldarg_0 />
                    <ldfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ret />
                </body>
                <alternateBody>
                    <ldarg_0 />
                    <call type="IKVM.Internal.ExceptionHelper" name="getStackTrace" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" />
                    <ret />
                </alternateBody>
d1317 1
a1317 19
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <call type="IKVM.Internal.ExceptionHelper" name="checkStackTrace" sig="([Ljava.lang.StackTraceElement;)[Ljava.lang.StackTraceElement;" />
                    <stfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <ldarg_0 />
                    <ldnull />
                    <stfld class="java.lang.Throwable" name="tracePart1" sig="Lcli.System.Diagnostics.StackTrace;" />
                    <ldarg_0 />
                    <ldnull />
                    <stfld class="java.lang.Throwable" name="tracePart2" sig="Lcli.System.Diagnostics.StackTrace;" />
                    <ret />
                </body>
                <alternateBody>
                    <ldarg_0 />
                    <ldarg_1 />
                    <call type="IKVM.Internal.ExceptionHelper" name="setStackTrace" sig="(Ljava.lang.Throwable;[Ljava.lang.StackTraceElement;)V" />
                    <ret />
                </alternateBody>
d1360 21
@


1.72
log
@Use some map.xml magic to create a no-op constructor that will allow the number of source differences to be reduced while maintaining the optimized nature of the DUMMY instance.
@
text
@d1836 8
@


1.71
log
@- Updated AtomicInteger, AtomicIntegerArray, AtomicLonger, AtomicLongerArray to use .NET 2.0 interlocked operations.
- Added stind_i8 opcode to remapper.
@
text
@d1372 7
@


1.70
log
@- Replaced reflection based implementation of isCCLOverridden() with an MSIL version that directly compares the method pointers.
- Always use isCCLOverridden() to determine if we need to call parent.getContextClassLoader(), this avoids resolving ClassLoader.DUMMY when we're creating a new thread.
@
text
@d3 1
a3 1
  Copyright (C) 2002-2010 Jeroen Frijters
d1966 9
d2001 11
d2026 31
d2059 30
a2088 1
            <method name="VMSupportsCS8" sig="()Z">
d2090 94
a2183 1
                    <ldc_i4_0 />
@


1.70.2.1
log
@Backport: Make sure that getContextClassLoader() and setContextClassLoader() are JITed before isCCLOverridden().
@
text
@a1392 7
            <constructor sig="(Ljava.lang.Void;)V">
                <body>
                    <ldarg_0 />
                    <call class="java.lang.Object" name="&lt;init&gt;" sig="()V" />
                    <ret />
                </body>
            </constructor>
@


1.70.2.2
log
@Updated version to 0.46.0.5 and backported bug fixes:
- IKVM.Reflection should ignore unknown metadata streams.
- Off-by-one error in local ref index reusing. Fix for bug #3575555.
- Interface mappings can be "incomplete". Fix for bug #3581564.
- The local variable state at the end of an exception block (if the last instruction is a local variable store) needs to be merged into the exception handler state.
- Local variable analysis for finally blocks was incorrect. Fixes bug #3600788.
- Don't implement interfaces that aren't accessible.
- Updated Mono workaround for Mono 3.0.x.
- Check for supported delegate signatures should detect pointers inside byref and array types and return type should be checked as well.
- Fake nested types should have Static modifier set in innerclasses attribute. Fixes scala compiler interop issue. Thanks to Michael Bayne for reporting this.
- ikvmstub -skiperror should also skip errors during WriteClass.
- An ITEMIDLIST should be freed using CoTaskMemFree.
- String.CaseInsensitiveComparator inner class should be acknowledged by String.
- Fixed the SHFILEINFO declaration. Thanks to Andras Kovacs for reporting this.
- Fixed race condition in MethodWrapper.ResolveMethod().
@
text
@a230 3
            <attribute type="IKVM.Attributes.NonNestedInnerClassAttribute" sig="(Ljava.lang.String;)V">
                <parameter>java.lang.String$CaseInsensitiveComparator</parameter>
            </attribute>
@


1.69
log
@Add explicit memory barriers after volatile stores.
@
text
@d1393 16
@


1.68
log
@Don't depend on leave/endfinally instructions being inserted automatically by ILGenerator.
@
text
@d1598 1
d1616 1
d1879 1
d1972 1
@


1.67
log
@IPv6 addresses associated with NetworkInterface should have their scope and network interface set (when appropriate).
@
text
@d1157 1
d1162 1
d1165 1
d1191 1
d1196 1
d1199 1
d1266 1
d1271 1
d2591 1
d2595 1
d2598 1
@


1.66
log
@- Split objectWait into two. One for the nanos variant and one that does the actual waiting.
- Fixed edge case where timeout == Long.MAX_VALUE and nanos >= 500000 that should cause IllegalArgumentException (to be compatible with the JDK, although that is arguably a JDK bug).
- Fixed exception when timeout > Integer.MAX_VALUE. Thanks to Andy Malakov for reporting this.
@
text
@d1421 32
d1454 1
a1454 1
            <method name="_set" sig="(Ljava.lang.String;[Ljava.net.InterfaceAddress;[Ljava.net.NetworkInterface;)V" modifiers="">
d1458 3
d1463 11
@


1.65
log
@Removed LinkDemand on addShutdownHook. .NET 4.0 removed the LinkDemand from the AppDomain.ProcessExit event, so it probably is harmless.
@
text
@d50 1
a50 2
                    <ldc_i4_0 />
                    <call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
d60 1
a60 2
                    <ldc_i4_0 />
                    <call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
@


1.65.2.1
log
@- Split objectWait into two. One for the nanos variant and one that does the actual waiting.
- Fixed edge case where timeout == Long.MAX_VALUE and nanos >= 500000 that should cause IllegalArgumentException (to be compatible with the JDK, although that is arguably a JDK bug).
- Fixed exception when timeout > Integer.MAX_VALUE. Thanks to Andy Malakov for reporting this.
@
text
@d50 2
a51 1
                    <call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;J)V" />
d61 2
a62 1
                    <call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;J)V" />
@


1.65.2.2
log
@Backport: Add explicit memory barriers after volatile stores.
@
text
@a1543 1
                    <call type="System.Threading.Thread" name="MemoryBarrier" sig="" />
a1560 1
                    <call type="System.Threading.Thread" name="MemoryBarrier" sig="" />
a1822 1
                    <call type="System.Threading.Thread" name="MemoryBarrier" sig="" />
a1914 1
                    <call type="System.Threading.Thread" name="MemoryBarrier" sig="" />
@


1.64
log
@Removed exception mapping methods from Throwable and consolidated into a single method (actually, two methods, but the dynamic one should not be necessary and should be removed later).
@
text
@a1984 8
        <class name="java.lang.Runtime">
            <method name="addShutdownHook" sig="(Ljava.lang.Thread;)V">
                <attribute type="System.Security.Permissions.SecurityPermissionAttribute" sig="(Lcli.System.Security.Permissions.SecurityAction;)V">
                    <parameter>LinkDemand</parameter>
                    <property name="ControlAppDomain" sig="Z">true</property>
                </attribute>
            </method>
        </class>
@


1.63
log
@Moved ExceptionHelper into proper namespace and some cleanup.
@
text
@a945 25
            <method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" modifiers="public static">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
                    <parameter>Never</parameter>
                </attribute>
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <call type="IKVM.Internal.ExceptionHelper" name="MapExceptionFast" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" />
                    <ret />
                </body>
            </method>
            <method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;" modifiers="public static">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
                    <parameter>Never</parameter>
                </attribute>
                <body>
                    <ldarg_0 />
                    <ldarg_1 />
                    <ldarg_2 />
                    <call type="IKVM.Internal.ExceptionHelper" name="MapException" sig="(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;" />
                    <ret />
                </body>
            </method>
@


1.62
log
@Moved the remainder of the exception mapping to the C# side.
@
text
@d921 1
a921 1
                    <call type="IKVM.NativeCode.java.lang.ExceptionHelper" name="getPersistentFields" sig="()[Ljava.io.ObjectStreamField;" />
d954 1
a954 1
                    <call type="IKVM.NativeCode.java.lang.ExceptionHelper" name="MapExceptionFast" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" />
d967 1
a967 1
                    <call type="IKVM.NativeCode.java.lang.ExceptionHelper" name="MapException" sig="(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;" />
d978 1
a978 1
                    <call type="IKVM.NativeCode.java.lang.ExceptionHelper" name="UnmapException" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
d989 1
a989 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="FixateException" sig="(Ljava.lang.Throwable;)V" />
d1000 1
a1000 1
                    <call type="IKVM.NativeCode.java.lang.ExceptionHelper" name="readObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectInputStream;)V" />
d1009 1
a1009 1
                    <call type="IKVM.NativeCode.java.lang.ExceptionHelper" name="writeObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectOutputStream;)V" />
d1042 1
a1042 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
d1072 1
a1072 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
d1105 1
a1105 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="GetMessageFromCause" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" />
d1138 1
a1138 1
                <redirect class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)V" type="static" />
d1142 1
a1142 1
                <redirect class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintStream;)V" type="static" />
d1146 1
a1146 1
                <redirect class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintWriter;)V" type="static" />
d1161 1
a1161 1
                <redirect class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
d1195 1
a1195 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="fillInStackTrace" sig="(Ljava.lang.Throwable;)V" />
d1211 1
a1211 1
                            <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="checkInitCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;Ljava.lang.Throwable;)V" />
d1229 1
a1229 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="checkInitCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;Ljava.lang.Throwable;)V" />
d1239 1
a1239 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="getCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
d1258 1
a1258 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="getStackTrace" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" />
d1279 1
a1279 1
                            <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="computeStackTrace" sig="(Ljava.lang.Throwable;Lcli.System.Diagnostics.StackTrace;Lcli.System.Diagnostics.StackTrace;)[Ljava.lang.StackTraceElement;" />
d1300 1
a1300 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="getStackTrace" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" />
d1309 1
a1309 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="checkStackTrace" sig="([Ljava.lang.StackTraceElement;)[Ljava.lang.StackTraceElement;" />
d1322 1
a1322 1
                    <call class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" name="setStackTrace" sig="(Ljava.lang.Throwable;[Ljava.lang.StackTraceElement;)V" />
d1327 1
a1327 1
                <redirect class="cli.IKVM.NativeCode.java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
@


1.61
log
@- Added new public API to unmap exception (ikvm.runtime.Util.unmapException()).
- Moved (parts of) mapping and unmapping to C# side.
@
text
@d967 1
a967 1
                    <call class="java.lang.ExceptionHelper" name="MapException" sig="(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;" />
a2009 45
        <class name="java.lang.ExceptionHelper">
            <method name="setOriginal" sig="(Ljava.lang.Throwable;Lcli.System.Exception;)V">
                <body>
                    <ldarg_0 />
                    <castclass_impl class="java.lang.Throwable" />
                    <ldarg_1 />
                    <stfld class="java.lang.Throwable" name="original" sig="Ljava.lang.Throwable;" />
                    <ret />
                </body>
            </method>
            <method name="needStackTraceInfo" sig="(Ljava.lang.Throwable;)Z">
                <body>
                    <ldarg_0 />
                    <castclass_impl class="java.lang.Throwable" />
                    <ldfld class="java.lang.Throwable" name="tracePart1" sig="Lcli.System.Diagnostics.StackTrace;" />
                    <brtrue name="no" />
                    <ldarg_0 />
                    <castclass_impl class="java.lang.Throwable" />
                    <ldfld class="java.lang.Throwable" name="tracePart2" sig="Lcli.System.Diagnostics.StackTrace;" />
                    <brtrue name="no" />
                    <ldarg_0 />
                    <castclass_impl class="java.lang.Throwable" />
                    <ldfld class="java.lang.Throwable" name="stackTrace" sig="[Ljava.lang.StackTraceElement;" />
                    <brtrue name="no" />
                    <ldc_i4_1 />
                    <ret />
                    <label name="no" />
                    <ldc_i4_0 />
                    <ret />
                </body>
            </method>
            <method name="setStackTraceInfo" sig="(Ljava.lang.Throwable;Lcli.System.Diagnostics.StackTrace;Lcli.System.Diagnostics.StackTrace;)V">
                <body>
                    <ldarg_0 />
                    <castclass_impl class="java.lang.Throwable" />
                    <ldarg_1 />
                    <stfld class="java.lang.Throwable" name="tracePart1" sig="Lcli.System.Diagnostics.StackTrace;" />
                    <ldarg_0 />
                    <castclass_impl class="java.lang.Throwable" />
                    <ldarg_2 />
                    <stfld class="java.lang.Throwable" name="tracePart2" sig="Lcli.System.Diagnostics.StackTrace;" />
                    <ret />
                </body>
            </method>
        </class>
@


1.60
log
@Moved more ExceptionHelper methods to C# side.
@
text
@d954 1
a954 1
                    <call class="java.lang.ExceptionHelper" name="MapExceptionFast" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" />
d978 1
a978 1
                    <call class="java.lang.ExceptionHelper" name="UnmapException" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
d989 1
a989 1
                    <call class="java.lang.ExceptionHelper" name="FixateException" sig="(Lcli.System.Exception;)V" />
a2010 12
            <method name="getOriginalAndClear" sig="(Ljava.lang.Throwable;)Lcli.System.Exception;">
                <body>
                    <ldarg_0 />
                    <castclass_impl class="java.lang.Throwable" />
                    <ldfld class="java.lang.Throwable" name="original" sig="Ljava.lang.Throwable;" />
                    <ldarg_0 />
                    <castclass_impl class="java.lang.Throwable" />
                    <ldnull />
                    <stfld class="java.lang.Throwable" name="original" sig="Ljava.lang.Throwable;" />
                    <ret />
                </body>
            </method>
@


1.59
log
@Yet more ExceptionHelper moving.
@
text
@d1195 1
a1195 1
                    <call class="java.lang.ExceptionHelper" name="fillInStackTrace" sig="(Lcli.System.Exception;)V" />
d1258 1
a1258 1
                    <call class="java.lang.ExceptionHelper" name="getStackTrace" sig="(Lcli.System.Exception;)[Ljava.lang.StackTraceElement;" />
d1300 1
a1300 1
                    <call class="java.lang.ExceptionHelper" name="getStackTrace" sig="(Lcli.System.Exception;)[Ljava.lang.StackTraceElement;" />
d1309 1
a1309 1
                    <call class="java.lang.ExceptionHelper" name="checkStackTrace" sig="([Ljava.lang.StackTraceElement;)[Ljava.lang.StackTraceElement;" />
d1322 1
a1322 1
                    <call class="java.lang.ExceptionHelper" name="setStackTrace" sig="(Lcli.System.Exception;[Ljava.lang.StackTraceElement;)V" />
@


1.58
log
@Moved a few more ExceptionHelper methods to C# side.
@
text
@d1211 1
a1211 1
                            <call class="java.lang.ExceptionHelper" name="checkInitCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;Ljava.lang.Throwable;)V" />
d1229 1
a1229 1
                    <call class="java.lang.ExceptionHelper" name="checkInitCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;Ljava.lang.Throwable;)V" />
d1239 1
a1239 1
                    <call class="java.lang.ExceptionHelper" name="getCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
d1279 1
a1279 1
                            <call class="java.lang.ExceptionHelper" name="computeStackTrace" sig="(Ljava.lang.Throwable;Lcli.System.Diagnostics.StackTrace;Lcli.System.Diagnostics.StackTrace;)[Ljava.lang.StackTraceElement;" />
@


1.57
log
@Moved printStackTrace to C# side.
@
text
@d1042 1
a1042 1
                    <call class="java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
d1072 1
a1072 1
                    <call class="java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
d1105 1
a1105 1
                    <call class="java.lang.ExceptionHelper" name="GetMessageFromCause" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" />
d1161 1
a1161 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
d1327 1
a1327 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
@


1.56
log
@Moved readObject/writeObject to C# side.
@
text
@d1138 1
a1138 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)V" type="static" />
d1142 1
a1142 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintStream;)V" type="static" />
d1146 1
a1146 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintWriter;)V" type="static" />
@


1.55
log
@First step of moving all exception handling code to C#.
@
text
@d1000 1
a1000 1
                    <call class="java.lang.ExceptionHelper" name="readObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectInputStream;)V" />
d1009 1
a1009 1
                    <call class="java.lang.ExceptionHelper" name="writeObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectOutputStream;)V" />
a2010 8
            <method name="getCauseForSerialization" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;">
                <body>
                    <ldarg_0 />
                    <castclass_impl class="java.lang.Throwable" />
                    <ldfld class="java.lang.Throwable" name="cause" sig="Ljava.lang.Throwable;" />
                    <ret />
                </body>
            </method>
@


1.54
log
@Remove use of reflection for getting the slot of a java.lang.reflect.Field.
@
text
@d921 1
a921 1
                    <call class="java.lang.ExceptionHelper" name="getPersistentFields" sig="()[Ljava.io.ObjectStreamField;" />
@


1.53
log
@Prep for .NET 4.0 security model:
- added more SecurityCritical attributes
- added SecuritySafeCritical/TreatAsSafe attributes to Direct-X-Buffer classes
@
text
@d1430 9
@


1.52
log
@Prep for .NET 4.0 security model:
- serialization methods must be critical.
@
text
@d3 1
a3 1
  Copyright (C) 2002-2009 Jeroen Frijters
d2084 467
@


1.51
log
@Make java.lang.Throwable .NET serializable.
@
text
@d1334 1
@


1.50
log
@Removed unused attribute (Method.Type).
@
text
@d906 1
d1329 37
@


1.49
log
@Implemented support for .NET serialization of Java enums.
(The CreateEnumEnum move in FakeTypes.cs is because java.lang.Enum now has a dependency on custom attribute annotations.)
@
text
@d1136 1
a1136 1
            <method type="virtual" name="printStackTrace" sig="()V" modifiers="public">
d1139 1
a1139 1
            <method type="virtual" name="printStackTrace" sig="(Ljava.io.PrintStream;)V" modifiers="public">
d1143 1
a1143 1
            <method type="virtual" name="printStackTrace" sig="(Ljava.io.PrintWriter;)V" modifiers="public">
d1147 1
a1147 1
            <method type="virtual" name="getMessage" sig="()Ljava.lang.String;" modifiers="public">
d1159 1
a1159 1
            <method type="virtual" name="getLocalizedMessage" sig="()Ljava.lang.String;" modifiers="public">
d1162 1
a1162 1
            <method type="virtual" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" modifiers="public">
d1199 1
a1199 1
            <method type="virtual" name="initCause" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public">
d1233 1
a1233 1
            <method type="virtual" name="getCause" sig="()Ljava.lang.Throwable;" modifiers="public">
d1247 1
a1247 1
            <method type="virtual" name="getStackTrace" sig="()[Ljava.lang.StackTraceElement;" modifiers="public">
d1303 1
a1303 1
            <method type="virtual" name="setStackTrace" sig="([Ljava.lang.StackTraceElement;)V" modifiers="public">
d1325 1
a1325 1
            <method type="virtual" name="toString" sig="()Ljava.lang.String;" modifiers="public">
@


1.48
log
@Implemented .NET serialization support for java.lang.Class objects.
@
text
@d1367 3
@


1.47
log
@Moved most java.lang.Class changes from map.xml to java source.
@
text
@d1343 1
@


1.46
log
@Moved responsibility for creating java.lang.Class instances for "fast literal" enable types into ClassLiteral<T>, this allows class literals to be really cheap, because non of the underlying reflection is needed, the class will cache the Type and lazily resolve it to its TypeWrapper.
@
text
@a1345 10
            <field name="pd" sig="Ljava.security.ProtectionDomain;" modifiers="" />
            <field name="signers" sig="[Ljava.lang.Object;" modifiers="" />
            <method name="op_Implicit" sig="(Lcli.System.Type;)Ljava.lang.Class;" modifiers="public static" attributes="SpecialName">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <body>
                    <ldarg_0 />
                    <call class="ikvm.runtime.Util" name="getFriendlyClassFromType" sig="(Lcli.System.Type;)Ljava.lang.Class;" />
                    <ret />
                </body>
            </method>
@


1.45
log
@Rewrote exception handling to store Java exception state in our java.lang.Throwable class, instead of an additional object in a weak keyed map.
@
text
@a1355 7
            <method name="newClass" sig="()Ljava.lang.Class;" modifiers="static">
                <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
                <body>
                    <newobj class="java.lang.Class" name="&lt;init&gt;" sig="()V" />
                    <ret />
                </body>
            </method>
@


1.45.2.1
log
@Backport: Volatile stores require a memory barrier. Fix for #3086040.
@
text
@a1535 1
                    <call class="cli.System.Threading.Thread" name="MemoryBarrier" sig="()V" />
a1552 1
                    <call class="cli.System.Threading.Thread" name="MemoryBarrier" sig="()V" />
a1814 1
                    <call class="cli.System.Threading.Thread" name="MemoryBarrier" sig="()V" />
a1906 1
                    <call class="cli.System.Threading.Thread" name="MemoryBarrier" sig="()V" />
@


1.44
log
@Marked java.lang.Object and java.lang.StackTraceElement as serializable (in the .NET sense).
@
text
@d3 1
a3 1
  Copyright (C) 2002-2008 Jeroen Frijters
d911 7
d922 3
d981 12
d1015 1
a1015 1
                    <call class="java.lang.ExceptionHelper" name="get_NullString" sig="()Ljava.lang.String;" />
d1017 3
d1026 3
d1043 3
d1052 3
d1059 3
d1074 3
d1083 3
d1090 3
a1092 2
                    <ldarg_2 />
                    <brtrue name="skip" />
d1095 1
a1095 3
                    <call class="java.lang.ExceptionHelper" name="initCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
                    <pop />
                    <label name="skip" />
d1107 3
d1116 3
d1124 6
a1129 1
                    <brtrue name="skip" />
d1132 1
a1132 3
                    <call class="java.lang.ExceptionHelper" name="initCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
                    <pop />
                    <label name="skip" />
d1148 10
a1157 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
d1163 35
a1197 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
d1201 31
a1231 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
d1234 12
a1245 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
d1248 54
a1301 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" type="static" />
d1305 19
a1323 1
                <redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;[Ljava.lang.StackTraceElement;)V" type="static" />
d1975 65
@


1.43
log
@Removed workaround I no longer care about.
@
text
@d28 1
d1807 3
@


1.42
log
@Removed accessor that is no longer needed now that ResolverConfigurationImpl has been forked.
@
text
@a1805 39
        <class name="com.sun.beans.ObjectHandler">
            <!-- HACK this is a workaround for an OpenJDK regression. It apparently no longer supports primitive types in the bean xml deserialization. -->
            <method name="classForName2" sig="(Ljava.lang.String;)Ljava.lang.Class;">
                <body>
                    <ldarg_1 />
                    <call class="com.sun.beans.ObjectHandler" name="typeNameToPrimitiveClass" sig="(Ljava.lang.String;)Ljava.lang.Class;" />
                    <dup />
                    <brfalse name="not_primitive" />
                    <ret />
                    <label name="not_primitive" />
                    <pop />
                    <exceptionBlock>
                        <try>
                            <ldarg_1 />
                            <ldarg_0 />
                            <ldfld class="com.sun.beans.ObjectHandler" name="ldr" sig="Ljava.lang.ClassLoader;" />
                            <call class="com.sun.beans.finder.ClassFinder" name="findClass" sig="(Ljava.lang.String;Ljava.lang.ClassLoader;)Ljava.lang.Class;" />
                            <stloc name="retval" class="java.lang.Class" />
                        </try>
                        <catch class="java.lang.ClassNotFoundException">
                            <stloc name="e" class="java.lang.ClassNotFoundException" />
                            <ldarg_0 />
                            <ldfld class="com.sun.beans.ObjectHandler" name="is" sig="Ljava.beans.XMLDecoder;" />
                            <brfalse name="skip" />
                            <ldarg_0 />
                            <ldfld class="com.sun.beans.ObjectHandler" name="is" sig="Ljava.beans.XMLDecoder;" />
                            <callvirt class="java.beans.XMLDecoder" name="getExceptionListener" sig="()Ljava.beans.ExceptionListener;" />
                            <ldloc name="e" />
                            <callvirt class="java.beans.ExceptionListener" name="exceptionThrown" sig="(Ljava.lang.Exception;)V" />
                            <label name="skip" />
                            <ldnull />
                            <stloc name="retval" class="java.lang.Class" />
                        </catch>
                    </exceptionBlock>
                    <ldloc name="retval" />
                    <ret />
                </body>
            </method>
        </class>
@


1.41
log
@Removed the usage of .NET reflection.
@
text
@a1572 11
        <class name="sun.net.dns.ResolverConfigurationImpl">
            <method name="_set" sig="(Ljava.lang.String;Ljava.lang.String;)V" modifiers="static">
                <body>
                    <ldarg_0 />
                    <stsfld class="sun.net.dns.ResolverConfigurationImpl" name="os_searchlist" sig="Ljava.lang.String;" />
                    <ldarg_1 />
                    <stsfld class="sun.net.dns.ResolverConfigurationImpl" name="os_nameservers" sig="Ljava.lang.String;" />
                    <ret />
                </body>
            </method>
        </class>
@


1.40
log
@Forked java/nio/Bits.java to remove unsafe code from static initializer.
@
text
@d1206 26
d1573 11
@


1.39
log
@Added helper methods to no longer require reflection to instantiate DirectByteBuffer from JNI.
@
text
@a1749 13
        <class name="java.nio.Bits">
            <method name="byteOrder" sig="()Ljava.nio.ByteOrder;">
                <body>
                    <ldsfld type="System.BitConverter" name="IsLittleEndian" sig="Z" />
                    <brfalse name="big" />
                    <ldsfld class="java.nio.ByteOrder" name="LITTLE_ENDIAN" sig="Ljava.nio.ByteOrder;" />
                    <ret />
                    <label name="big" />
                    <ldsfld class="java.nio.ByteOrder" name="BIG_ENDIAN" sig="Ljava.nio.ByteOrder;" />
                    <ret />
                </body>
            </method>
        </class>
@


1.38
log
@Moved generated exception mapping code from ExceptionHelper to Throwable and made it slightly less hacky.
@
text
@d1763 11
@


1.37
log
@Reformatted.
@
text
@d928 6
@


1.36
log
@- Implemented connected datagram sockets using .NET 2.0 Socket.Connect()/Disconnect() API.
- Used .NET 2.0 Socket.IOControl() API to disable WSAECONNRESET errors (when not connected).
- Removed workaround for OpenJDK bug from map.xml.
@
text
@d1 1
a1 1
<?xml version="1.0" encoding="utf-8" ?> 
d26 74
a99 216
	<assembly>
		<class name="java.lang.Object" shadows="System.Object" modifiers="public">
			<constructor sig="()V" modifiers="public" />
			<method name="notifyAll" sig="()V" modifiers="public final">
				<body>
					<ldarg_0 />
					<call type="System.Threading.Monitor" name="PulseAll" sig="(Ljava.lang.Object;)V" />
					<ret />
				</body>
			</method>
			<method name="notify" sig="()V" modifiers="public final">
				<body>
					<ldarg_0 />
					<call type="System.Threading.Monitor" name="Pulse" sig="(Ljava.lang.Object;)V" />
					<ret />
				</body>
			</method>
			<method name="wait" sig="()V" modifiers="public final">
				<throws class="java.lang.InterruptedException" />
				<body>
					<ldarg_0 />
					<ldc_i4_0 />
					<conv_i8 />
					<ldc_i4_0 />
					<call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
					<ret />
				</body>
			</method>
			<method name="wait" sig="(J)V" modifiers="public final">
				<parameter name="timeout" />
				<throws class="java.lang.InterruptedException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldc_i4_0 />
					<call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
          <ret />
        </body>
      </method>
      <method name="wait" sig="(JI)V" modifiers="public final">
        <parameter name="timeout" />
        <parameter name="nanos" />
        <throws class="java.lang.InterruptedException" />
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <ldarg_2 />
          <call class="java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
					<ret />
				</body>
			</method>
			<method name="getClass" sig="()Ljava.lang.Class;" modifiers="public final">
				<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
					<parameter>()Ljava/lang/Class&lt;+Ljava/lang/Object;&gt;;</parameter>
				</attribute>
				<body>
					<ldarg_0 />
					<call class="ikvm.runtime.Util" name="getClassFromObject" sig="(Ljava.lang.Object;)Ljava.lang.Class;" />
					<ret />
				</body>
			</method>
			<method name="clone" sig="()Ljava.lang.Object;" modifiers="protected">
				<throws class="java.lang.CloneNotSupportedException" />
				<body>
					<ldarg_0 />
					<isinst class="java.lang.Cloneable" />
					<brtrue name="ok" />
					<newobj class="java.lang.CloneNotSupportedException" name="&lt;init&gt;" sig="()V" />
					<throw />
					<label name="ok" />
					<ldarg_0 />
					<call type="System.Object" name="MemberwiseClone" sig="()Ljava.lang.Object;" />
					<ret />
				</body>
				<alternateBody>
					<ldarg_0 />
					<isinst type="System.Array" />
					<dup />
					<brfalse name="not_array" />
					<call type="System.Array" name="Clone" sig="()Ljava.lang.Object;" />
					<ret />
					<label name="not_array" />
					<pop />
					<ldarg_0 />
					<isinst class="java.lang.Cloneable" />
					<brfalse name="not_cloneable" />
					<!--
					 This means we're Cloneable, but not derived from java.lang.Object or java.lang.Throwable.
					 It also means that we must have been invoked thru reflection (or by code in the java.lang package),
					 so it is OK to use reflection to call Object.MemberwiseClone().
					 -->
					<ldtoken type="System.Object" />
					<call type="System.Type" name="GetTypeFromHandle" sig="(Lcli.System.RuntimeTypeHandle;)Lcli.System.Type;" />
					<ldstr value="MemberwiseClone" />
					<ldc_i4 value="36" />
					<ldnull />
					<ldsfld type="System.Type" name="EmptyTypes" sig="[Lcli.SystemType;" />
					<ldnull />
					<callvirt type="System.Type" name="GetMethod" sig="(Ljava.lang.String;Lcli.System.Reflection.BindingFlags;Lcli.System.Reflection.Binder;[Lcli.System.Type;[Lcli.System.Reflection.ParameterModifier;)Lcli.System.Reflection.MethodInfo;" />
					<ldarg_0 />
					<ldnull />
					<callvirt type="System.Reflection.MethodInfo" name="Invoke" sig="(Ljava.lang.Object;[Ljava.lang.Object;)Ljava.lang.Object;" />
					<ret />
					<label name="not_cloneable" />
					<newobj class="java.lang.CloneNotSupportedException" name="&lt;init&gt;" sig="()V" />
					<throw />
				</alternateBody>
			</method>
			<method name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" modifiers="private static">
				<body>
					<ldarg_0 />
					<callvirt class="java.lang.Object" name="getClass" sig="()Ljava.lang.Class;" />
					<call class="java.lang.Class" name="getName" sig="()Ljava.lang.String;" />
					<ldstr value="@@" />
					<ldarg_0 />
					<callvirt class="java.lang.Object" name="hashCode" sig="()I" />
					<call class="java.lang.Integer" name="toHexString" sig="(I)Ljava.lang.String;" />
					<call type="System.String" name="Concat" sig="(Ljava.lang.String;Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="toString" sig="()Ljava.lang.String;" modifiers="public">
				<override name="ToString" />
				<body>
					<ldarg_0 />
					<call class="java.lang.Object" name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
					<ret />
				</body>
				<alternateBody>
					<ldarg_0 />
					<isinst type="System.Array" />
					<brfalse name="skip" />
					<ldarg_0 />
					<call class="java.lang.Object" name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
					<br name="end" />
					<label name="skip" />
					<ldarg_0 />
					<callvirt type="System.Object" name="ToString" sig="()Ljava.lang.String;" />
					<label name="end" />
					<ret />
				</alternateBody>
				<nonvirtualAlternateBody>
					<ldarg_0 />
					<call class="java.lang.Object" name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
					<ret />
				</nonvirtualAlternateBody>
			</method>
			<method name="hashCode" sig="()I" modifiers="public">
				<override name="GetHashCode" />
				<nonvirtualAlternateBody>
          <ldarg_0 />
          <call type="System.Runtime.CompilerServices.RuntimeHelpers" name="GetHashCode" sig="(Ljava.lang.Object;)I" />
					<ret />
				</nonvirtualAlternateBody>
			</method>
			<method name="equals" sig="(Ljava.lang.Object;)Z" modifiers="public">
				<parameter name="obj" />
				<override name="Equals" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ceq />
					<ret />
				</body>
				<alternateBody>
					<ldarg_0 />
					<ldarg_1 />
					<callvirt type="System.Object" name="Equals" sig="(Ljava.lang.Object;)Z" />
					<ret />
				</alternateBody>
				<nonvirtualAlternateBody>
					<ldarg_0 />
					<ldarg_1 />
					<ceq />
					<ret />
				</nonvirtualAlternateBody>
			</method>
			<method name="finalize" sig="()V" modifiers="protected">
				<throws class="java.lang.Throwable" />
				<!-- NOTE we don't override Finalize, because that would be bad for performance,
					 instead, the compiler contains a hack to lazily override Finalize when a class
					 overrides our finalize
					 TODO consider adding code to constructor (in debug builds) to detect that someone
					 has overriden our finalize from another .NET language (if no intermediate Java base class
					 has overriden finalize, the lazy override of Object.Finalize hasn't kicked in and finalize
					 will never be called)
				-->
				<body>
					<ldarg_0 />
					<call type="System.Object" name="Finalize" sig="()V" />
					<ret />
				</body>
				<alternateBody>
					<!-- if code in the java.lang package explicitly invokes finalize on a non java.lang.Object
						 derived object	we just ignore it -->
					<ret />
				</alternateBody>
			</method>
		</class>
		<class name="java.lang.String" shadows="System.String" modifiers="public final">
			<implements class="java.io.Serializable" />
			<implements class="java.lang.Comparable" />
			<implements class="java.lang.CharSequence" />
			<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
				<parameter>Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/lang/CharSequence;</parameter>
			</attribute>			
			<field name="serialVersionUID" sig="J" modifiers="private static final" constant="-6849794470754667710" />
			<constructor sig="()V" modifiers="public">
				<alternateBody>
					<ldstr value="" />
					<call type="System.String" name="Copy" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</alternateBody>
			</constructor>
			<constructor sig="([C)V" modifiers="public">
				<parameter name="value" />
d101 1780
a1880 1638
					<!-- force a NullPointerException if the array is null -->
					<ldarg_0 />
					<ldlen />
					<pop />
					<ldarg_0 />
					<newobj type="System.String" name=".ctor" sig="([C)V" />
					<ret />
				</alternateBody>
			</constructor>
			<constructor sig="([CII)V" modifiers="public">
				<parameter name="value" />
				<parameter name="offset" />
				<parameter name="count" />
			</constructor>
			<!-- Package private constructor, that we redirect to static helper -->
			<constructor sig="(II[C)V" modifiers="">
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="(II[C)Ljava.lang.String;" />
			</constructor>
			<constructor sig="(Ljava.lang.String;)V" modifiers="public">
				<parameter name="original" />
				<redirect class="System.String, mscorlib" name="Copy" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="(Ljava.lang.StringBuffer;)V" modifiers="public">
				<parameter name="buffer" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="(Ljava.lang.StringBuffer;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="(Ljava.lang.StringBuilder;)V" modifiers="public">
				<parameter name="builder" />
				<alternateBody>
					<ldarg_0 />
					<ldfld class="java.lang.StringBuilder" name="value" sig="[C" />
					<ldc_i4_0 />
					<ldarg_0 />
					<ldfld class="java.lang.StringBuilder" name="count" sig="I" />
					<newobj type="System.String" name=".ctor" sig="([CII)V" />
					<ret />
				</alternateBody>
			</constructor>
			<constructor sig="([B)V" modifiers="public">
				<parameter name="bytes" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([B)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BI)V" modifiers="public">
				<parameter name="ascii" />
				<parameter name="hibyte" />
				<attribute type="System.ObsoleteAttribute" sig="()V" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BI)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BII)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="offset" />
				<parameter name="length" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BII)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BIII)V" modifiers="public">
				<parameter name="ascii" />
				<parameter name="hibyte" />
				<parameter name="offset" />
				<parameter name="count" />
				<attribute type="System.ObsoleteAttribute" sig="()V" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIII)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BLjava.lang.String;)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="charsetName" />
				<throws class="java.io.UnsupportedEncodingException" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BLjava.lang.String;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BIILjava.lang.String;)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="offset" />
				<parameter name="length" />
				<parameter name="charsetName" />
				<throws class="java.io.UnsupportedEncodingException" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIILjava.lang.String;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([III)V" modifiers="public">
				<parameter name="codePoints" />
				<parameter name="offset" />
				<parameter name="count" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([III)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BIILjava.nio.charset.Charset;)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="offset" />
				<parameter name="length" />
				<parameter name="charset" />
        <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIILjava.nio.charset.Charset;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BLjava.nio.charset.Charset;)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="charset" />
        <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BLjava.nio.charset.Charset;)Ljava.lang.String;" />
      </constructor>
			<method name="hashCode" sig="()I" modifiers="public">
				<redirect class="java.lang.StringHelper" name="hashCode" type="static" sig="(Lcli.System.String;)I" />
			</method>
			<!-- we have a toString here to make sure that it shows up as a declared method in reflection -->
			<method name="toString" sig="()Ljava.lang.String;" modifiers="public" />
			<!-- we have an equals here to make sure that it shows up as a declared method in reflection -->
			<method name="equals" sig="(Ljava.lang.Object;)Z" modifiers="public">
				<parameter name="anObject" />
			</method>
			<method name="valueOf" sig="(Z)Ljava.lang.String;" modifiers="public static">
				<parameter name="b" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(I)Ljava.lang.String;" modifiers="public static">
				<parameter name="i" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(J)Ljava.lang.String;" modifiers="public static">
				<parameter name="l" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(C)Ljava.lang.String;" modifiers="public static">
				<parameter name="c" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(F)Ljava.lang.String;" modifiers="public static">
				<parameter name="f" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(D)Ljava.lang.String;" modifiers="public static">
				<parameter name="d" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="([C)Ljava.lang.String;" modifiers="public static">
				<parameter name="data" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="([CII)Ljava.lang.String;" modifiers="public static">
				<parameter name="data" />
				<parameter name="offset" />
				<parameter name="count" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
				<parameter name="obj" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="substring" sig="(I)Ljava.lang.String;" modifiers="public">
				<parameter name="beginIndex" />
				<redirect name="Substring" />
			</method>
			<method name="length" sig="()I" modifiers="public">
				<redirect name="get_Length" />
			</method>
			<method name="charAt" sig="(I)C" modifiers="public" nonullcheck="true">
				<parameter name="index" />
				<body>
          <ldarg_1 />
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <bge_un name="throw" />
          <ldarg_0 />
				  <ldarg_1 />
				  <callvirt type="System.String" name="get_Chars" sig="(I)C" />
				  <ret />
          <label name="throw" />
					<newobj class="java.lang.StringIndexOutOfBoundsException" name="&lt;init&gt;" sig="()V" />
					<throw />
				</body>
			</method>
			<method name="substring" sig="(II)Ljava.lang.String;" modifiers="public">
				<parameter name="beginIndex" />
				<parameter name="endIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)Ljava.lang.String;" />
			</method>
			<method name="indexOf" sig="(I)I" modifiers="public">
				<parameter name="ch" />
        <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;I)I" />
			</method>
			<method name="indexOf" sig="(II)I" modifiers="public" nonullcheck="true">
				<parameter name="ch" />
				<parameter name="fromIndex" />
        <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)I" />
			</method>
			<method name="indexOf" sig="(Ljava.lang.String;)I" modifiers="public">
				<parameter name="str" />
        <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
      </method>
			<method name="indexOf" sig="(Ljava.lang.String;I)I" modifiers="public">
				<parameter name="str" />
				<parameter name="fromIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
			</method>
      <!-- These three methods are package private and used by (Abstract)StringBuilder/Buffer -->
      <method name="getChars" sig="([CI)V" modifiers="">
        <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;[CI)V" />
      </method>
      <method name="indexOf" sig="([CII[CIII)I" modifiers="static">
        <redirect class="java.lang.StringHelper" />
      </method>
      <method name="lastIndexOf" sig="([CII[CIII)I" modifiers="static">
        <redirect class="java.lang.StringHelper" />
      </method>
      <!-- end of package private methods used by (Abstract)StringBuilder/Buffer -->
      <method name="lastIndexOf" sig="(I)I" modifiers="public">
				<parameter name="ch" />
        <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;I)I" />
      </method>
      <method name="lastIndexOf" sig="(II)I" modifiers="public">
        <parameter name="ch" />
        <parameter name="fromIndex" />
        <redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)I" />
      </method>
      <method name="lastIndexOf" sig="(Ljava.lang.String;)I" modifiers="public">
        <parameter name="str" />
        <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
      </method>
      <method name="lastIndexOf" sig="(Ljava.lang.String;I)I" modifiers="public">
        <parameter name="str" />
				<parameter name="fromIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
			</method>
			<method name="toCharArray" sig="()[C" modifiers="public">
				<redirect name="ToCharArray" />
			</method>
			<method name="getChars" sig="(II[CI)V" modifiers="public">
				<parameter name="srcBegin" />
				<parameter name="srcEnd" />
				<parameter name="dst" />
				<parameter name="dstBegin" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II[CI)V" />
			</method>
			<method name="startsWith" sig="(Ljava.lang.String;)Z" modifiers="public" nonullcheck="true">
				<parameter name="prefix" />
        <body>
          <!--
			    if (this.Length >= prefix.Length)
			    {
				    for (int i = 0; i < prefix.Length; i++)
				    {
					    if (this[i] != prefix[i])
					    {
						    return false;
					    }
				    }
				    return true;
			    }
			    return false;
          -->
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="ret_false" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <bne_un name="ret_false" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_1 />
          <ret />
          <label name="ret_false" />
          <ldc_i4_0 />
          <ret />
        </body>
      </method>
			<method name="startsWith" sig="(Ljava.lang.String;I)Z" modifiers="public" nonullcheck="true">
				<parameter name="prefix" />
				<parameter name="toffset" />
        <body>
          <!--
			    if (toffset >= 0
             && toffset <= this.Length
             && this.Length - toffset >= prefix.Length)
			    {
				    for (int i = 0; i < prefix.Length; i++)
				    {
					    if (this[i + toffset] != prefix[i])
					    {
						    return false;
					    }
				    }
				    return true;
			    }
			    return false;
          -->
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_2 />
          <blt_un name="ret_false" />
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_2 />
          <sub />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="ret_false" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="i" />
          <ldarg_2 />
          <add />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <bne_un name="ret_false" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_1 />
          <ret />
          <label name="ret_false" />
          <ldc_i4_0 />
          <ret />
        </body>
      </method>
			<method name="endsWith" sig="(Ljava.lang.String;)Z" modifiers="public" nonullcheck="true">
				<parameter name="suffix" />
        <body>
          <!--
			    int j = this.Length - suffix.Length;
			    if (j >= 0)
			    {
				    for (int i = 0; i < suffix.Length; i++)
				    {
					    if (this[j++] != suffix[i])
					    {
						    return false;
					    }
				    }
				    return true;
			    }
			    return false;
          -->
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <sub />
          <stloc name="j" type="System.Int32" />
          <ldloc name="j" />
          <ldc_i4_0 />
          <blt name="ret_false" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="j" />
          <dup />
          <ldc_i4_1 />
          <add />
          <stloc name="j" type="System.Int32" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <bne_un name="ret_false" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_1 />
          <ret />
          <label name="ret_false" />
          <ldc_i4_0 />
          <ret />
        </body>
      </method>
			<method name="toUpperCase" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="toUpperCase" sig="(Ljava.util.Locale;)Ljava.lang.String;" modifiers="public">
				<parameter name="locale" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.util.Locale;)Ljava.lang.String;" />
			</method>
			<method name="toLowerCase" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="toLowerCase" sig="(Ljava.util.Locale;)Ljava.lang.String;" modifiers="public">
				<parameter name="locale" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.util.Locale;)Ljava.lang.String;" />
			</method>
			<method name="compareToIgnoreCase" sig="(Ljava.lang.String;)I" modifiers="public">
				<parameter name="str" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
			</method>
			<method name="equalsIgnoreCase" sig="(Ljava.lang.String;)Z" modifiers="public">
				<parameter name="anotherString" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Z" />
			</method>
			<method name="intern" sig="()Ljava.lang.String;" modifiers="public">
				<redirect type="static" name="Intern" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="compareTo" sig="(Ljava.lang.String;)I" modifiers="public">
				<parameter name="anotherString" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
			</method>
			<method name="compareTo" sig="(Ljava.lang.Object;)I" modifiers="public">
				<parameter name="o" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<castclass type="System.String" />
					<call class="java.lang.StringHelper" name="compareTo" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
					<ret />
				</body>
			</method>
			<method name="replace" sig="(CC)Ljava.lang.String;" modifiers="public">
				<parameter name="oldChar" />
				<parameter name="newChar" />
				<redirect name="Replace" />
			</method>
			<method name="getBytes" sig="()[B" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)[B" />
			</method>
			<method name="getBytes" sig="(Ljava.lang.String;)[B" modifiers="public">
				<parameter name="charsetName" />
				<throws class="java.io.UnsupportedEncodingException" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)[B" />
			</method>
			<method name="subSequence" sig="(II)Ljava.lang.CharSequence;" modifiers="public">
				<parameter name="beginIndex" />
				<parameter name="endIndex" />
				<redirect class="java.lang.StringHelper" type="static" name="substring" sig="(Lcli.System.String;II)Ljava.lang.String;" />
			</method>
			<method name="trim" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="regionMatches" sig="(ZILjava.lang.String;II)Z" modifiers="public">
				<parameter name="ignoreCase" />
				<parameter name="toffset" />
				<parameter name="other" />
				<parameter name="ooffset" />
				<parameter name="len" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;ZILjava.lang.String;II)Z" />
			</method>
			<method name="regionMatches" sig="(ILjava.lang.String;II)Z" modifiers="public">
				<parameter name="toffset" />
				<parameter name="other" />
				<parameter name="ooffset" />
				<parameter name="len" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;ILjava.lang.String;II)Z" />
			</method>
			<method name="getBytes" sig="(II[BI)V" modifiers="public">
				<parameter name="srcBegin" />
				<parameter name="srcEnd" />
				<parameter name="dst" />
				<parameter name="dstBegin" />
				<attribute type="System.ObsoleteAttribute" sig="()V" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II[BI)V" />
			</method>
			<method name="concat" sig="(Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
				<parameter name="str" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="contains" sig="(Ljava.lang.CharSequence;)Z" modifiers="public">
				<parameter name="s" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
			</method>
			<method name="codePointAt" sig="(I)I" modifiers="public">
				<parameter name="index" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;I)I" />
			</method>
			<method name="codePointBefore" sig="(I)I" modifiers="public">
				<parameter name="index" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;I)I" />
			</method>
			<method name="codePointCount" sig="(II)I" modifiers="public">
				<parameter name="beginIndex" />
				<parameter name="endIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II)I" />
			</method>
			<method name="offsetByCodePoints" sig="(II)I" modifiers="public">
				<parameter name="index" />
				<parameter name="codePointOffset" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II)I" />
			</method>
			<method name="contentEquals" sig="(Ljava.lang.CharSequence;)Z" modifiers="public">
				<parameter name="cs" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
			</method>
			<method name="contentEquals" sig="(Ljava.lang.StringBuffer;)Z" modifiers="public">
				<parameter name="sb" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<callvirt class="java.lang.StringBuffer" name="toString" sig="()Ljava.lang.String;" />
					<callvirt type="System.String" name="Equals" sig="(Ljava.lang.String;)Z" />
					<ret />
				</body>
			</method>
			<method name="replace" sig="(Ljava.lang.CharSequence;Ljava.lang.CharSequence;)Ljava.lang.String;" modifiers="public">
				<parameter name="target" />
				<parameter name="replacement" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.CharSequence;Ljava.lang.CharSequence;)Ljava.lang.String;" />
			</method>
			<method name="matches" sig="(Ljava.lang.String;)Z" modifiers="public">
				<parameter name="regex" />
				<body>
					<ldarg_1 />
					<ldarg_0 />
					<call class="java.util.regex.Pattern" name="matches" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
					<ret />
				</body>
			</method>
			<method name="replaceAll" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
				<parameter name="regex" />
				<parameter name="replacement" />
				<body>
					<ldarg_1 />
					<call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
					<ldarg_0 />
					<callvirt class="java.util.regex.Pattern" name="matcher" sig="(Ljava.lang.CharSequence;)Ljava.util.regex.Matcher;" />
					<ldarg_2 />
					<callvirt class="java.util.regex.Matcher" name="replaceAll" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="replaceFirst" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
				<parameter name="regex" />
				<parameter name="replacement" />
				<body>
					<ldarg_1 />
					<call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
					<ldarg_0 />
					<callvirt class="java.util.regex.Pattern" name="matcher" sig="(Ljava.lang.CharSequence;)Ljava.util.regex.Matcher;" />
					<ldarg_2 />
					<callvirt class="java.util.regex.Matcher" name="replaceFirst" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="split" sig="(Ljava.lang.String;)[Ljava.lang.String;" modifiers="public">
				<parameter name="regex" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldc_i4_0 />
					<callvirt class="java.lang.String" name="split" sig="(Ljava.lang.String;I)[Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="split" sig="(Ljava.lang.String;I)[Ljava.lang.String;" modifiers="public">
				<parameter name="regex" />
				<parameter name="limit" />
				<body>
					<ldarg_1 />
					<call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
					<ldarg_0 />
					<ldarg_2 />
					<callvirt class="java.util.regex.Pattern" name="split" sig="(Ljava.lang.CharSequence;I)[Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="copyValueOf" sig="([C)Ljava.lang.String;" modifiers="public static">
				<parameter name="data" />
				<body>
					<!-- force a NullPointerException if the array is null -->
					<ldarg_0 />
					<ldlen />
					<pop />
					<ldarg_0 />
					<newobj type="System.String" name=".ctor" sig="([C)V" />
					<ret />
				</body>
			</method>
			<method name="copyValueOf" sig="([CII)Ljava.lang.String;" modifiers="public static">
				<parameter name="data" />
				<parameter name="offset" />
				<parameter name="count" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<newobj type="System.String" name=".ctor" sig="([CII)V" />
					<ret />
				</body>
			</method>
			<method name="format" sig="(Ljava.lang.String;[Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
				<parameter name="format" />
				<parameter name="args">
					<attribute type="System.ParamArrayAttribute" sig="()V" />
				</parameter>
				<body>
					<newobj class="java.util.Formatter" name="&lt;init&gt;" sig="()V" />
					<ldarg_0 />
					<ldarg_1 />
					<callvirt class="java.util.Formatter" name="format" sig="(Ljava.lang.String;[Ljava.lang.Object;)Ljava.util.Formatter;" />
					<callvirt class="java.util.Formatter" name="toString" sig="()Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="format" sig="(Ljava.util.Locale;Ljava.lang.String;[Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
				<parameter name="l" />
				<parameter name="format" />
				<parameter name="args">
					<attribute type="System.ParamArrayAttribute" sig="()V" />
				</parameter>
				<body>
					<ldarg_0 />
					<newobj class="java.util.Formatter" name="&lt;init&gt;" sig="(Ljava.util.Locale;)V" />
					<ldarg_1 />
					<ldarg_2 />
					<callvirt class="java.util.Formatter" name="format" sig="(Ljava.lang.String;[Ljava.lang.Object;)Ljava.util.Formatter;" />
					<callvirt class="java.util.Formatter" name="toString" sig="()Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="isEmpty" sig="()Z" modifiers="public">
				<body>
					<ldarg_0 />
					<callvirt type="System.String" name="get_Length" sig="()I" />
					<ldc_i4_0 />
					<ceq />
					<ret />
				</body>
			</method>
			<method name="getBytes" sig="(Ljava.nio.charset.Charset;)[B" modifiers="public">
				<parameter name="charset" />
        <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.nio.charset.Charset;)[B" />
			</method>
			<field name="CASE_INSENSITIVE_ORDER" sig="Ljava.util.Comparator;" modifiers="public static final">
				<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
					<parameter>Ljava/util/Comparator&lt;Ljava/lang/String;&gt;;</parameter>
				</attribute>
			</field>
			<!-- TODO mark this method as BeforeFieldInit (and benchmark to see if that is faster) -->
			<clinit>
				<body>
          <ldnull />
					<newobj class="java.lang.String$CaseInsensitiveComparator" name="&lt;init&gt;" sig="(Ljava.lang.String$1;)V" />
					<stsfld class="java.lang.String" name="CASE_INSENSITIVE_ORDER" sig="Ljava.util.Comparator;" />
					<ret />
				</body>
			</clinit>
		</class>
		<class name="java.lang.Throwable" shadows="System.Exception" modifiers="public">
			<implements class="java.io.Serializable" />
			<field name="serialVersionUID" sig="J" modifiers="private static final" constant="-3042686055658047285" />
			<field name="serialPersistentFields" sig="[Ljava.io.ObjectStreamField;" modifiers="private static final" />
			<field name="suppressFillInStackTrace" sig="Z" modifiers="private static">
				<attribute type="System.ThreadStaticAttribute" sig="()V" />
			</field>
			<clinit>
				<body>
					<call class="java.lang.ExceptionHelper" name="getPersistentFields" sig="()[Ljava.io.ObjectStreamField;" />
					<stsfld class="java.lang.Throwable" name="serialPersistentFields" sig="[Ljava.io.ObjectStreamField;" />
					<ret />
				</body>
			</clinit>
			<method name="__&lt;suppressFillInStackTrace&gt;" sig="()V" modifiers="public static">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
					<parameter>Never</parameter>
				</attribute>
				<body>
					<ldc_i4_1 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ret />
				</body>
			</method>
			<method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" modifiers="public static">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
					<parameter>Never</parameter>
				</attribute>
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="MapExceptionFast" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" />
					<ret />
				</body>
			</method>
			<method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;" modifiers="public static">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
					<parameter>Never</parameter>
				</attribute>
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<call class="java.lang.ExceptionHelper" name="MapException" sig="(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;" />
					<ret />
				</body>
			</method>
			<method name="__&lt;unmap&gt;" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public static">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
					<parameter>Never</parameter>
				</attribute>
				<body>
					<ldarg_0 />
					<call class="java.lang.ExceptionHelper" name="UnmapException" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
					<ret />
				</body>
			</method>
			<method name="readObject" sig="(Ljava.io.ObjectInputStream;)V" modifiers="private">
				<throws class="java.io.IOException" />
				<throws class="java.lang.ClassNotFoundException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="readObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectInputStream;)V" />
					<ret />
				</body>
			</method>
			<method name="writeObject" sig="(Ljava.io.ObjectOutputStream;)V" modifiers="private">
				<throws class="java.io.IOException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="writeObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectOutputStream;)V" />
					<ret />
				</body>
			</method>
			<constructor sig="()V" modifiers="public">
				<body>
					<ldarg_0 />
					<call class="java.lang.ExceptionHelper" name="get_NullString" sig="()Ljava.lang.String;" />
					<call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;)V" />
					<!-- Start fillInStackTrace call -->
					<ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ldc_i4_0 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<brtrue name="skipFillInStackTrace" />
					<ldarg_0 />
					<callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
					<pop />
					<label name="skipFillInStackTrace" />
					<!-- End fillInStackTrace call -->
					<ret />
				</body>
			</constructor>
			<constructor sig="(Ljava.lang.String;)V" modifiers="public">
				<parameter name="message" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;)V" />
					<!-- Start fillInStackTrace call -->
					<ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ldc_i4_0 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<brtrue name="skipFillInStackTrace" />
					<ldarg_0 />
					<callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
					<pop />
					<label name="skipFillInStackTrace" />
					<!-- End fillInStackTrace call -->
					<ret />
				</body>
			</constructor>
			<constructor sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" modifiers="public">
				<parameter name="message" />
				<parameter name="cause" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ldarg_2 />
					<call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
					<!-- Start fillInStackTrace call -->
					<ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ldc_i4_0 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<brtrue name="skipFillInStackTrace" />
					<ldarg_0 />
					<callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
					<pop />
					<label name="skipFillInStackTrace" />
					<!-- End fillInStackTrace call -->
					<ldarg_2 />
					<brtrue name="skip" />
					<ldarg_0 />
					<ldarg_2 />
					<call class="java.lang.ExceptionHelper" name="initCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
					<pop />
					<label name="skip" />
					<ret />
				</body>
			</constructor>
			<constructor sig="(Ljava.lang.Throwable;)V" modifiers="public">
				<parameter name="cause" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="GetMessageFromCause" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" />
					<ldarg_1 />
					<call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
					<!-- Start fillInStackTrace call -->
					<ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ldc_i4_0 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<brtrue name="skipFillInStackTrace" />
					<ldarg_0 />
					<callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
					<pop />
					<label name="skipFillInStackTrace" />
					<!-- End fillInStackTrace call -->
					<ldarg_1 />
					<brtrue name="skip" />
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="initCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
					<pop />
					<label name="skip" />
					<ret />
				</body>
			</constructor>
			<method type="virtual" name="printStackTrace" sig="()V" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)V" type="static" />
			</method>
			<method type="virtual" name="printStackTrace" sig="(Ljava.io.PrintStream;)V" modifiers="public">
				<parameter name="s" />
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintStream;)V" type="static" />
			</method>
			<method type="virtual" name="printStackTrace" sig="(Ljava.io.PrintWriter;)V" modifiers="public">
				<parameter name="s" />
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintWriter;)V" type="static" />
			</method>
			<method type="virtual" name="getMessage" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
			</method>
			<method type="virtual" name="getLocalizedMessage" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
			</method>
			<method type="virtual" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
			</method>
			<method type="virtual" name="initCause" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public">
				<parameter name="cause" />
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
			</method>
			<method type="virtual" name="getCause" sig="()Ljava.lang.Throwable;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
			</method>
			<method type="virtual" name="getStackTrace" sig="()[Ljava.lang.StackTraceElement;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" type="static" />
			</method>
			<method type="virtual" name="setStackTrace" sig="([Ljava.lang.StackTraceElement;)V" modifiers="public">
				<parameter name="stackTrace" />
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;[Ljava.lang.StackTraceElement;)V" type="static" />
			</method>
			<method type="virtual" name="toString" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
			</method>
		</class>
		<class name="java.lang.Comparable" shadows="System.IComparable" modifiers="public abstract interface">
			<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
				<parameter>&lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</parameter>
			</attribute>
			<method name="compareTo" sig="(Ljava.lang.Object;)I" modifiers="public abstract">
				<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
					<parameter>(TT;)I</parameter>
				</attribute>
				<parameter name="o" />
				<override name="CompareTo" />
			</method>
		</class>
		<!-- Here we are adding/replacing methods to existing classes -->
		<class name="java.lang.Class">
      <field name="typeWrapper" sig="Lcli.IKVM.Internal.TypeWrapper;" modifiers="">
        <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
      </field>
      <field name="pd" sig="Ljava.security.ProtectionDomain;" modifiers="" />
      <field name="signers" sig="[Ljava.lang.Object;" modifiers="" />
			<method name="op_Implicit" sig="(Lcli.System.Type;)Ljava.lang.Class;" modifiers="public static" attributes="SpecialName">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<body>
					<ldarg_0 />
					<call class="ikvm.runtime.Util" name="getFriendlyClassFromType" sig="(Lcli.System.Type;)Ljava.lang.Class;" />
					<ret />
				</body>
			</method>
      <method name="newClass" sig="()Ljava.lang.Class;" modifiers="static">
        <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
        <body>
          <newobj class="java.lang.Class" name="&lt;init&gt;" sig="()V" />
          <ret />
        </body>
      </method>
		</class>
    <class name="java.lang.ClassLoader">
      <field name="wrapper" sig="Lcli.IKVM.Internal.ClassLoaderWrapper;" modifiers="">
        <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
      </field>
      <method name="getBootstrapResource" sig="(Ljava.lang.String;)Ljava.net.URL;">
        <body>
          <ldarg_0 />
          <call class="java.lang.LangHelper" name="getBootstrapResource" sig="(Ljava.lang.String;)Ljava.net.URL;" />
          <ret />
        </body>
      </method>
      <method name="getBootstrapResources" sig="(Ljava.lang.String;)Ljava.util.Enumeration;">
        <body>
          <ldarg_0 />
          <call class="java.lang.LangHelper" name="getBootstrapResources" sig="(Ljava.lang.String;)Ljava.util.Enumeration;" />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.lang.Thread">
      <field name="parkLock" sig="Ljava.lang.Object;" modifiers="" />
      <field name="parkState" sig="I" modifiers="" />
    </class>
    <class name="java.lang.ThreadGroup">
      <method name="createRootGroup" sig="()Ljava.lang.ThreadGroup;" modifiers="static">
        <body>
          <newobj class="java.lang.ThreadGroup" name="&lt;init&gt;" sig="()V" />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.lang.reflect.Constructor">
      <method name="_slot" sig="()I">
        <body>
          <ldarg_0 />
          <ldfld class="java.lang.reflect.Constructor" name="slot" sig="I" />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.lang.reflect.Method">
      <method name="_slot" sig="()I">
        <body>
          <ldarg_0 />
          <ldfld class="java.lang.reflect.Method" name="slot" sig="I" />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.util.AbstractCollection">
      <!-- We're adding an Add(object) method to allow collection initializers and Xml (soap) serialization to magically work -->
      <!-- NOTE Modifiers.Final and MethodAttributes.NewSlot is recognized by AotTypeWrapper.MapModifiers() as a magic combination that generates a non-virtual method -->
      <method name="Add" sig="(Ljava.lang.Object;)V" modifiers="public final" attributes="NewSlot">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
        <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
          <parameter>Never</parameter>
        </attribute>
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <callvirt class="java.util.AbstractCollection" name="add" sig="(Ljava.lang.Object;)Z" />
          <pop />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.util.AbstractMap">
      <!-- NOTE the compiler will not magically make all Maps enumerable, so we manually implement IEnumerable here -->
      <implements class="cli.System.Collections.IEnumerable" />
      <method name="System.Collections.IEnumerable.GetEnumerator" sig="()Lcli.System.Collections.IEnumerator;" modifiers="private" attributes="NewSlot Virtual Final">
        <override class="cli.System.Collections.IEnumerable" name="GetEnumerator" />
        <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
        <body>
          <ldarg_0 />
          <newobj class="ikvm.lang.MapEnumerator" name="&lt;init&gt;" sig="(Ljava.util.Map;)V" />
          <ret />
        </body>
      </method>
      <!-- We're adding an Add(object,object) method to allow collection initializers to magically work -->
      <!-- NOTE Modifiers.Final and MethodAttributes.NewSlot is recognized by AotTypeWrapper.MapModifiers() as a magic combination that generates a non-virtual method -->
      <method name="Add" sig="(Ljava.lang.Object;Ljava.lang.Object;)V" modifiers="public final" attributes="NewSlot">
        <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
        <attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
          <parameter>Never</parameter>
        </attribute>
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <ldarg_2 />
          <callvirt class="java.util.AbstractMap" name="put" sig="(Ljava.lang.Object;Ljava.lang.Object;)Ljava.lang.Object;" />
          <pop />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.util.concurrent.locks.AbstractQueuedSynchronizer">
      <method name="compareAndSetState" sig="(II)Z">
        <body>
          <ldarg_0 />
          <ldflda class="java.util.concurrent.locks.AbstractQueuedSynchronizer" name="state" sig="I" />
          <ldarg_2 />
          <ldarg_1 />
          <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
          <ldarg_1 />
          <ceq />
          <ret />
        </body>
      </method>
      <method name="compareAndSetWaitStatus" sig="(Ljava.util.concurrent.locks.AbstractQueuedSynchronizer$Node;II)Z">
        <body>
          <ldarg_0 />
          <ldflda class="java.util.concurrent.locks.AbstractQueuedSynchronizer$Node" name="waitStatus" sig="I" />
          <ldarg_2 />
          <ldarg_1 />
          <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
          <ldarg_1 />
          <ceq />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.util.concurrent.locks.LockSupport">
      <method name="cmpxchgParkState" sig="(Ljava.lang.Thread;II)I">
        <body>
          <ldarg_0 />
          <ldflda class="java.lang.Thread" name="parkState" sig="I" />
          <ldarg_1 />
          <ldarg_2 />
          <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
          <ret />
        </body>
      </method>
      <method name="getBlocker" sig="(Ljava.lang.Thread;)Ljava.lang.Object;">
        <body>
          <ldarg_0 />
          <volatile />
          <ldfld class="java.lang.Thread" name="parkBlocker" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
      <method name="setBlocker" sig="(Ljava.lang.Thread;Ljava.lang.Object;)V">
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <volatile />
          <stfld class="java.lang.Thread" name="parkBlocker" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
      <method name="getParkLock" sig="(Ljava.lang.Thread;)Ljava.lang.Object;">
        <body>
          <ldarg_0 />
          <volatile />
          <ldfld class="java.lang.Thread" name="parkLock" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
      <method name="setParkLock" sig="(Ljava.lang.Thread;Ljava.lang.Object;)V">
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <volatile />
          <stfld class="java.lang.Thread" name="parkLock" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.lang.Package">
      <method name="getSystemPackage" sig="(Ljava.lang.String;)Ljava.lang.Package;" modifiers="static">
        <body>
          <ldsfld class="java.lang.Package" name="pkgs" sig="Ljava.util.Map;" />
          <ldarg_0 />
          <call class="java.lang.LangHelper" name="getSystemPackage" sig="(Ljava.util.Map;Ljava.lang.String;)Ljava.lang.Package;" />
          <ret />
        </body>
      </method>
      <method name="getSystemPackages" sig="()[Ljava.lang.Package;" modifiers="static">
        <body>
          <ldsfld class="java.lang.Package" name="pkgs" sig="Ljava.util.Map;" />
          <call class="java.lang.LangHelper" name="getSystemPackages" sig="(Ljava.util.Map;)[Ljava.lang.Package;" />
          <ret />
        </body>
      </method>
    </class>
		<!-- This is where the "native" helper methods start -->
		<class name="ikvm.lang.CIL">
			<method name="unbox_byte" sig="(Ljava.lang.Object;)B">
				<body>
					<ldarg_0 />
					<unbox type="System.Byte" />
					<ldind_i1 />
					<ret />
				</body>
			</method>
			<method name="unbox_boolean" sig="(Ljava.lang.Object;)Z">
				<body>
					<ldarg_0 />
					<unbox type="System.Boolean" />
					<ldind_i1 />
					<ret />
				</body>
			</method>
			<method name="unbox_short" sig="(Ljava.lang.Object;)S">
				<body>
					<ldarg_0 />
					<unbox type="System.Int16" />
					<ldind_i2 />
					<ret />
				</body>
			</method>
			<method name="unbox_char" sig="(Ljava.lang.Object;)C">
				<body>
					<ldarg_0 />
					<unbox type="System.Char" />
					<ldind_i2 />
					<ret />
				</body>
			</method>
			<method name="unbox_int" sig="(Ljava.lang.Object;)I">
				<body>
					<ldarg_0 />
					<unbox type="System.Int32" />
					<ldind_i4 />
					<ret />
				</body>
			</method>
			<method name="unbox_float" sig="(Ljava.lang.Object;)F">
				<body>
					<ldarg_0 />
					<unbox type="System.Single" />
					<ldind_r4 />
					<ret />
				</body>
			</method>
			<method name="unbox_long" sig="(Ljava.lang.Object;)J">
				<body>
					<ldarg_0 />
					<unbox type="System.Int64" />
					<ldind_i8 />
					<ret />
				</body>
			</method>
			<method name="unbox_double" sig="(Ljava.lang.Object;)D">
				<body>
					<ldarg_0 />
					<unbox type="System.Double" />
					<ldind_r8 />
					<ret />
				</body>
			</method>
			<method name="box_byte" sig="(B)Lcli.System.Byte;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_boolean" sig="(Z)Lcli.System.Boolean;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_short" sig="(S)Lcli.System.Int16;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_char" sig="(C)Lcli.System.Char;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_int" sig="(I)Lcli.System.Int32;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_float" sig="(F)Lcli.System.Single;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_long" sig="(J)Lcli.System.Int64;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_double" sig="(D)Lcli.System.Double;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_sbyte" sig="(B)Lcli.System.SByte;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_ushort" sig="(S)Lcli.System.UInt16;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_uint" sig="(I)Lcli.System.UInt32;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_ulong" sig="(J)Lcli.System.UInt64;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_sbyte" sig="(Lcli.System.SByte;)B">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_ushort" sig="(Lcli.System.UInt16;)S">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_uint" sig="(Lcli.System.UInt32;)I">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_ulong" sig="(Lcli.System.UInt64;)J">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
		</class>
    <class name="sun.misc.Launcher">
      <method name="&lt;init&gt;" sig="()V">
        <replace-method-call class="sun.misc.Launcher$ExtClassLoader" name="getExtClassLoader" sig="()Lsun.misc.Launcher$ExtClassLoader;">
          <code>
            <call class="sun.misc.MiscHelper" name="getExtClassLoader" sig="()Lsun.misc.Launcher$ExtClassLoader;" />
          </code>
        </replace-method-call>
        <replace-method-call class="sun.misc.Launcher$AppClassLoader" name="getAppClassLoader" sig="(Ljava.lang.ClassLoader;)Ljava.lang.ClassLoader;">
          <code>
            <call class="sun.misc.MiscHelper" name="getAppClassLoader" sig="(Ljava.lang.ClassLoader;)Ljava.lang.ClassLoader;" />
          </code>
        </replace-method-call>
      </method>
    </class>
    <class name="sun.misc.SharedSecrets">
      <method name="javaUtilJarAccess" sig="()Lsun.misc.JavaUtilJarAccess;">
        <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
          <code>
            <pop />
            <pop />
            <runclassinit class="java.util.jar.JarFile" />
          </code>
        </replace-method-call>
      </method>
      <method name="getJavaIOAccess" sig="()Lsun.misc.JavaIOAccess;">
        <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
          <code>
            <pop />
            <pop />
            <runclassinit class="java.io.Console" />
          </code>
        </replace-method-call>
      </method>
      <method name="getJavaIODeleteOnExitAccess" sig="()Lsun.misc.JavaIODeleteOnExitAccess;">
        <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
          <code>
            <pop />
            <pop />
            <runclassinit class="java.io.File" />
          </code>
        </replace-method-call>
      </method>
    </class>
		<class name="java.util.concurrent.atomic.AtomicReference">
			<method name="compareAndSet" sig="(Ljava.lang.Object;Ljava.lang.Object;)Z">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicReference" name="value" sig="Ljava.lang.Object;" />
					<ldarg_2 />
					<ldarg_1 />
					<call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Object&amp;;System.Object;System.Object" />
					<ldarg_1 />
					<ceq />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.util.concurrent.atomic.AtomicReferenceArray">
			<method name="get" sig="(I)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
					<ldarg_1 />
					<ldelema sig="Ljava.lang.Object;" />
					<volatile />
					<ldind_ref />
					<ret />
				</body>
			</method>
			<method name="set" sig="(ILjava.lang.Object;)V">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
					<ldarg_1 />
					<ldelema sig="Ljava.lang.Object;" />
					<ldarg_2 />
					<volatile />
					<stind_ref />
					<ret />
				</body>
			</method>
			<method name="compareAndSet" sig="(ILjava.lang.Object;Ljava.lang.Object;)Z">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
					<ldarg_1 />
					<ldelema sig="Ljava.lang.Object;" />
					<ldarg_3 />
					<ldarg_2 />
					<call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Object&amp;;System.Object;System.Object" />
					<ldarg_2 />
					<ceq />
					<ret />
				</body>
			</method>
		</class>
    <class name="java.util.concurrent.atomic.AtomicBoolean">
      <method name="compareAndSwapInt" sig="(II)Z">
        <body>
          <ldarg_0 />
          <ldflda class="java.util.concurrent.atomic.AtomicBoolean" name="value" sig="I" />
          <ldarg_2 />
          <ldarg_1 />
          <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
          <ldarg_1 />
          <ceq />
          <ret />
        </body>
      </method>
    </class>
		<class name="java.util.concurrent.atomic.AtomicInteger">
			<method name="getAndSet" sig="(I)I">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
					<ldarg_1 />
					<call type="System.Threading.Interlocked" name="Exchange" sig="System.Int32&amp;;System.Int32" />
					<ret />					
				</body>
			</method>
			<method name="compareAndSet" sig="(II)Z">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
					<ldarg_2 />
					<ldarg_1 />
					<call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
					<ldarg_1 />
					<ceq />
					<ret />
				</body>
			</method>
			<method name="incrementAndGet" sig="()I">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
					<call type="System.Threading.Interlocked" name="Increment" sig="System.Int32&amp;" />
					<ret />					
				</body>
			</method>
			<method name="decrementAndGet" sig="()I">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
					<call type="System.Threading.Interlocked" name="Decrement" sig="System.Int32&amp;" />
					<ret />					
				</body>
			</method>
		</class>
		<class name="java.util.concurrent.atomic.AtomicIntegerArray">
			<method name="get" sig="(I)I">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
					<ldarg_1 />
					<ldelema sig="I" />
					<volatile />
					<ldind_i4 />
					<ret />
				</body>
			</method>
			<method name="set" sig="(II)V">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
					<ldarg_1 />
					<ldelema sig="I" />
					<ldarg_2 />
					<volatile />
					<stind_i4 />
					<ret />
				</body>
			</method>
			<method name="compareAndSet" sig="(III)Z">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
					<ldarg_1 />
					<ldelema sig="I" />
					<ldarg_3 />
					<ldarg_2 />
					<call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
					<ldarg_2 />
					<ceq />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.util.concurrent.atomic.AtomicLong">
			<method name="VMSupportsCS8" sig="()Z">
				<body>
					<ldc_i4_0 />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.lang.Byte">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Byte;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Short">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Short;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Integer">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Integer;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Long">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Long;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Float">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Float;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Double">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Double;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
    <class name="java.lang.Runtime">
      <method name="addShutdownHook" sig="(Ljava.lang.Thread;)V">
        <attribute type="System.Security.Permissions.SecurityPermissionAttribute" sig="(Lcli.System.Security.Permissions.SecurityAction;)V">
          <parameter>LinkDemand</parameter>
          <property name="ControlAppDomain" sig="Z">true</property>
        </attribute>
      </method>
    </class>
    <class name="java.nio.Bits">
      <method name="byteOrder" sig="()Ljava.nio.ByteOrder;">
        <body>
          <ldsfld type="System.BitConverter" name="IsLittleEndian" sig="Z" />
          <brfalse name="big" />
          <ldsfld class="java.nio.ByteOrder" name="LITTLE_ENDIAN" sig="Ljava.nio.ByteOrder;" />
          <ret />
          <label name="big" />
          <ldsfld class="java.nio.ByteOrder" name="BIG_ENDIAN" sig="Ljava.nio.ByteOrder;" />
          <ret />
        </body>
      </method>
    </class>
    <class name="sun.reflect.Reflection">
      <!-- we manually hook up this native method, to prevent inlining and tail-call optimizations -->
      <method name="getCallerClass" sig="(I)Ljava.lang.Class;">
        <attribute type="System.Runtime.CompilerServices.MethodImplAttribute" sig="(Lcli.System.Runtime.CompilerServices.MethodImplOptions;)V">
          <parameter>NoInlining</parameter>
        </attribute>
        <body>
          <ldarg_0 />
          <call type="IKVM.NativeCode.sun.reflect.Reflection" name="getCallerClass" sig="(I)Ljava.lang.Object;" />
          <stloc name="class" class="java.lang.Object" />
          <!-- "leave" is to thwart tail-call optimization -->
          <leave name="x" />
          <label name="x" />
          <ldloc name="class" />
          <castclass class="java.lang.Class" />
          <ret />
        </body>
      </method>
    </class>
    <class name="com.sun.beans.ObjectHandler">
      <!-- HACK this is a workaround for an OpenJDK regression. It apparently no longer supports primitive types in the bean xml deserialization. -->
      <method name="classForName2" sig="(Ljava.lang.String;)Ljava.lang.Class;">
        <body>
          <ldarg_1 />
          <call class="com.sun.beans.ObjectHandler" name="typeNameToPrimitiveClass" sig="(Ljava.lang.String;)Ljava.lang.Class;" />
          <dup />
          <brfalse name="not_primitive" />
          <ret />
          <label name="not_primitive" />
          <pop />
          <exceptionBlock>
            <try>
              <ldarg_1 />
              <ldarg_0 />
              <ldfld class="com.sun.beans.ObjectHandler" name="ldr" sig="Ljava.lang.ClassLoader;" />
              <call class="com.sun.beans.finder.ClassFinder" name="findClass" sig="(Ljava.lang.String;Ljava.lang.ClassLoader;)Ljava.lang.Class;" />
              <stloc name="retval" class="java.lang.Class" />
            </try>
            <catch class="java.lang.ClassNotFoundException">
              <stloc name="e" class="java.lang.ClassNotFoundException" />
              <ldarg_0 />
              <ldfld class="com.sun.beans.ObjectHandler" name="is" sig="Ljava.beans.XMLDecoder;" />
              <brfalse name="skip" />
              <ldarg_0 />
              <ldfld class="com.sun.beans.ObjectHandler" name="is" sig="Ljava.beans.XMLDecoder;" />
              <callvirt class="java.beans.XMLDecoder" name="getExceptionListener" sig="()Ljava.beans.ExceptionListener;" />
              <ldloc name="e" />
              <callvirt class="java.beans.ExceptionListener" name="exceptionThrown" sig="(Ljava.lang.Exception;)V" />
              <label name="skip" />
              <ldnull />
              <stloc name="retval" class="java.lang.Class" />
            </catch>
          </exceptionBlock>
          <ldloc name="retval" />
          <ret />
        </body>
      </method>
    </class>
	</assembly>
	<exceptionMappings>
		<exception src="System.NullReferenceException" dst="java.lang.NullPointerException" />
		<!-- many of the String and Object methods throw ArgumentNullException where Java throws an NPE -->
		<exception src="System.ArgumentNullException" dst="java.lang.NullPointerException" />
		<exception src="System.IndexOutOfRangeException" dst="java.lang.ArrayIndexOutOfBoundsException" />
		<!-- HACK for String methods, we remap ArgumentOutOfRangeException to StringIndexOutOfBoundsException -->
		<exception src="System.ArgumentOutOfRangeException" dst="java.lang.StringIndexOutOfBoundsException" />
    <exception src="System.InvalidCastException" dst="java.lang.ClassCastException">
      <code>
        <callvirt type="System.Exception" name="get_Message" sig="()Ljava.lang.String;" />
        <newobj class="java.lang.ClassCastException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
      </code>
    </exception>
		<!-- NOTE we "map" to java.lang.Error, because that is the base class of all possible mappings.
			The * in front of the class name means that all subclasses can be thrown as well.
		 -->
		<exception src="System.TypeInitializationException" dst="*java.lang.Error">
			<code>
				<!-- this code is unreachable, TypeInitializationException is handled explicitly in ExceptionHelper.java -->
			</code>
		</exception>
		<exception src="System.Threading.SynchronizationLockException" dst="java.lang.IllegalMonitorStateException" />
		<exception src="System.OutOfMemoryException" dst="java.lang.OutOfMemoryError" />
		<exception src="System.DivideByZeroException" dst="java.lang.ArithmeticException">
			<code>
				<pop />
				<ldstr value="/ by zero" />
				<newobj class="java.lang.ArithmeticException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
			</code>
		</exception>
		<exception src="System.ArrayTypeMismatchException" dst="java.lang.ArrayStoreException" />
		<exception src="System.StackOverflowException" dst="java.lang.StackOverflowError" />
		<exception src="System.Security.VerificationException" dst="java.lang.VerifyError" />
		<exception src="System.Threading.ThreadAbortException" dst="java.lang.ThreadDeath">
			<code>
				<castclass type="System.Threading.ThreadAbortException" />
				<call type="System.Threading.ThreadAbortException" name="get_ExceptionState" sig="()Ljava.lang.Object;" />
				<isinst class="java.lang.ThreadDeath" />
				<dup />
				<brtrue name="end" />
				<pop />
				<newobj class="java.lang.ThreadDeath" name="&lt;init&gt;" sig="()V" />
				<label name="end" />
				<!-- NOTE we do this last because ResetAbort clears the ExceptionState of the ThreadAbortException (why?) -->
				<!-- TODO we should put an exception handler around the ResetAbort call, because it will throw a ThreadStateException
				     if no Abort is pending (someone could have thrown the exception manually, or we could have called on a 
				     previous handler that turned out not to be match for this exception type) -->
				<stloc name="x" class="java.lang.ThreadDeath" />
				<exceptionBlock>
					<try>
						<!-- TODO instead of catching the ThreadStateException, we should check the ThreadState
						     before calling ResetAbort -->
						<call type="System.Threading.Thread" name="ResetAbort" sig="()V" />
					</try>
					<catch type="System.Threading.ThreadStateException">
						<!-- ignore the exception -->
					</catch>
				</exceptionBlock>
				<ldloc name="x" />
			</code>
		</exception>
		<!-- TODO make sure the originating method was from an IKVM.NET generated assembly, because if it was
	    generated by non-Java code, this remapping is obviously bogus. -->
		<exception src="System.OverflowException" dst="java.lang.NegativeArraySizeException" />
	</exceptionMappings>
@


1.35
log
@Changed compareAndSet methods from map.xml based implementation to AtomicReferenceFieldUpdater based implementation. This reduces the number of differences between upstream and our version.
@
text
@a1199 13
    <class name="java.net.DatagramSocket">
      <method name="receive" sig="(Ljava.net.DatagramPacket;)V">
        <!-- HACK this is to work around a bug in DatagramSocket. It compares an Inet4Address instance with an InetAddress instance,
             but the Inet4Address.equals(Object obj) method never returns true if obj isn't also an Inet4Address.
             Normally this code path in DatagramSocket.receive() isn't used, but since we don't supported DatagramSocketImpl.connect()
             we do end up here. -->
        <replace-method-call class="java.net.InetAddress" name="equals" sig="(Ljava.lang.Object;)Z">
          <code>
            <call class="java.net.PlainDatagramSocketImpl" name="equalsHack" sig="(Ljava.net.InetAddress;Ljava.net.InetAddress;)Z" />
          </code>
        </replace-method-call>
      </method>
    </class>
@


1.34
log
@Fixed three String bugs found by OpenJDK string tests.
@
text
@a1271 24
      <method name="compareAndSetHead" sig="(Ljava.util.concurrent.locks.AbstractQueuedSynchronizer$Node;)Z">
        <body>
          <ldarg_0 />
          <ldflda class="java.util.concurrent.locks.AbstractQueuedSynchronizer" name="head" sig="Ljava.lang.Object;" />
          <ldarg_1 />
          <ldnull />
          <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Object&amp;;System.Object;System.Object" />
          <ldnull />
          <ceq />
          <ret />
        </body>
      </method>
      <method name="compareAndSetTail" sig="(Ljava.util.concurrent.locks.AbstractQueuedSynchronizer$Node;Ljava.util.concurrent.locks.AbstractQueuedSynchronizer$Node;)Z">
        <body>
          <ldarg_0 />
          <ldflda class="java.util.concurrent.locks.AbstractQueuedSynchronizer" name="tail" sig="Ljava.lang.Object;" />
          <ldarg_2 />
          <ldarg_1 />
          <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Object&amp;;System.Object;System.Object" />
          <ldarg_1 />
          <ceq />
          <ret />
        </body>
      </method>
@


1.33
log
@Removed .NET 1.1 specific workaround.
@
text
@d330 1
a330 10
				<alternateBody>
					<ldarg_3 />
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<call class="java.nio.ByteBuffer" name="wrap" sig="([BII)Ljava.nio.ByteBuffer;" />
					<callvirt class="java.nio.charset.Charset" name="decode" sig="(Ljava.nio.ByteBuffer;)Ljava.nio.CharBuffer;" />
					<callvirt class="java.nio.CharBuffer" name="toString" sig="()Ljava.lang.String;" />
					<ret />
				</alternateBody>
d335 2
a336 9
				<alternateBody>
					<ldarg_1 />
					<ldarg_0 />
					<call class="java.nio.ByteBuffer" name="wrap" sig="([B)Ljava.nio.ByteBuffer;" />
					<callvirt class="java.nio.charset.Charset" name="decode" sig="(Ljava.nio.ByteBuffer;)Ljava.nio.CharBuffer;" />
					<callvirt class="java.nio.CharBuffer" name="toString" sig="()Ljava.lang.String;" />
					<ret />
				</alternateBody>
			</constructor>
d886 1
a886 7
				<body>
					<ldarg_1 />
					<ldarg_0 />
					<callvirt class="java.nio.charset.Charset" name="encode" sig="(Ljava.lang.String;)Ljava.nio.ByteBuffer;" />
					<callvirt class="java.nio.ByteBuffer" name="array" sig="()[B" />
					<ret />
				</body>
@


1.32
log
@Moved java.lang.Thread "native" methods to Java.
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d176 2
a177 12
					<ldarg_0 />
					<conditional framework="2.0">
						<code>
							<call type="System.Runtime.CompilerServices.RuntimeHelpers" name="GetHashCode" sig="(Ljava.lang.Object;)I" />
						</code>
					</conditional>
					<conditional framework="1.1">
						<code>
							<!-- FXBUG RuntimeHelpers.GetHashCode is broken in multi AppDomain scenarios (on v1.x) -->
							<call type="System.Object" name="GetHashCode" sig="()I" />
						</code>
					</conditional>
@


1.31
log
@Moved a couple of java.lang.System native methods to the Java side.
@
text
@d50 1
a50 1
					<call type="IKVM.NativeCode.java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
d61 1
a61 1
					<call type="IKVM.NativeCode.java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
d73 1
a73 1
          <call type="IKVM.NativeCode.java.lang.Thread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
a1202 3
      <field name="vmThread" sig="Lcli.IKVM.NativeCode.java.lang.Thread$VMThread;" modifiers="">
        <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
      </field>
a1204 32
      <method name="getState" sig="()Ljava.lang.Thread$State;">
        <body>
          <ldarg_0 />
          <call type="IKVM.NativeCode.java.lang.Thread" name="getState" sig="(Ljava.lang.Object;)Ljava.lang.Object;" />
          <castclass class="java.lang.Thread$State" />
          <ret />
        </body>
      </method>
      <method name="_exit" sig="()V">
        <body>
          <ldarg_0 />
          <call class="java.lang.Thread" name="exit" sig="()V" />
          <ret />
        </body>
      </method>
      <method name="_threadStatus" sig="()I">
        <body>
          <ldarg_0 />
          <volatile />
          <ldfld class="java.lang.Thread" name="threadStatus" sig="I" />
          <ret />
        </body>
      </method>
      <method name="_threadStatus" sig="(I)V">
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <volatile />
          <stfld class="java.lang.Thread" name="threadStatus" sig="I" />
          <ret />
        </body>
      </method>
@


1.30
log
@Removed initialization hack that is no longer needed.
@
text
@a1601 19
		<class name="java.lang.System">
			<method name="identityHashCode" sig="(Ljava.lang.Object;)I">
				<body>
					<ldarg_0 />
					<conditional framework="2.0">
						<code>
							<call type="System.Runtime.CompilerServices.RuntimeHelpers" name="GetHashCode" sig="(Ljava.lang.Object;)I" />
						</code>
					</conditional>
					<conditional framework="1.1">
						<code>
							<!-- FXBUG RuntimeHelpers.GetHashCode is broken in multi AppDomain scenarios (on v1.x) -->
							<call type="System.Object" name="GetHashCode" sig="()I" />
						</code>
					</conditional>
					<ret />
				</body>
			</method>
    </class>
@


1.29
log
@Refactored class library initialization.
@
text
@a1663 11
    <class name="sun.misc.Unsafe">
      <method name="getUnsafe" sig="()Lsun.misc.Unsafe;">
        <replace-method-call class="sun.misc.Unsafe" name="ensureClassInitialized" sig="(Ljava.lang.Class;)V">
          <code>
            <pop />
            <pop />
            <runclassinit class="java.lang.System" />
          </code>
        </replace-method-call>
      </method>
    </class>
@


1.28
log
@Include exception message in ClassCastException.
@
text
@a1160 16
    <class name="java.io.Console">
      <method name="_reinitHack" sig="()V" modifiers="static">
        <body>
          <call class="java.io.Console" name="&lt;clinit&gt;" sig="()V" />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.io.File">
      <method name="_reinitHack" sig="()V" modifiers="static">
        <body>
          <call class="java.io.File" name="&lt;clinit&gt;" sig="()V" />
          <ret />
        </body>
      </method>
    </class>
a1200 7
      <method name="clearSclSet" sig="()V" modifiers="static">
        <body>
          <ldc_i4_0 />
          <stsfld class="java.lang.ClassLoader" name="sclSet" sig="Z" />
          <ret />
        </body>
      </method>
a1207 35
      <constructor sig="(Lcli.IKVM.NativeCode.java.lang.Thread$VMThread;Ljava.lang.ThreadGroup;Ljava.lang.String;)V">
        <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <stfld class="java.lang.Thread" name="vmThread" sig="Lcli.IKVM.NativeCode.java.lang.Thread$VMThread;" />
          <ldarg_0 />
          <ldarg_2 />
          <ldarg_3 />
          <call class="java.lang.Thread" name="&lt;init&gt;" sig="(Ljava.lang.ThreadGroup;Ljava.lang.String;)V" />
          <ret />
        </body>
      </constructor>
      <constructor sig="(Lcli.IKVM.NativeCode.java.lang.Thread$VMThread;Ljava.lang.ThreadGroup;Ljava.lang.Runnable;)V">
        <attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <stfld class="java.lang.Thread" name="vmThread" sig="Lcli.IKVM.NativeCode.java.lang.Thread$VMThread;" />
          <ldarg_0 />
          <ldarg_2 />
          <ldarg_3 />
          <call class="java.lang.Thread" name="&lt;init&gt;" sig="(Ljava.lang.ThreadGroup;Ljava.lang.Runnable;)V" />
          <ret />
        </body>
      </constructor>
      <method name="init" sig="(Ljava.lang.ThreadGroup;Ljava.lang.Runnable;Ljava.lang.String;J)V">
        <replace-method-call class="java.lang.Thread" name="currentThread" sig="()Ljava.lang.Thread;">
          <code>
            <ldarg_0 />
            <call type="IKVM.NativeCode.java.lang.Thread" name="CurrentThreadFromInit" sig="(Ljava.lang.Object;)Ljava.lang.Object;" />
            <castclass class="java.lang.Thread" />
          </code>
        </replace-method-call>
      </method>
a1239 24
      <method name="_deamon" sig="(Z)V">
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <stfld class="java.lang.Thread" name="daemon" sig="Z" />
          <ret />
        </body>
      </method>
      <method name="_priority" sig="(I)V">
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <stfld class="java.lang.Thread" name="priority" sig="I" />
          <ret />
        </body>
      </method>
      <method name="_contextClassLoader" sig="(Ljava.lang.ClassLoader;)V">
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <stfld class="java.lang.Thread" name="contextClassLoader" sig="Ljava.lang.ClassLoader;" />
          <ret />
        </body>
      </method>
a1248 8
    <class name="java.lang.reflect.AccessibleObject">
      <method name="_reinitHack" sig="()V" modifiers="static">
        <body>
          <call class="java.lang.reflect.AccessibleObject" name="&lt;clinit&gt;" sig="()V" />
          <ret />
        </body>
      </method>
    </class>
a1266 8
    <class name="java.lang.reflect.Modifier">
      <method name="_reinitHack" sig="()V" modifiers="static">
        <body>
          <call class="java.lang.reflect.Modifier" name="&lt;clinit&gt;" sig="()V" />
          <ret />
        </body>
      </method>
    </class>
a1602 8
      <!-- HACK we replace <clinit> to remove the null initialization of in/out/err,
           because we have to trigger VM initialization in registerNatives. -->
      <method name="&lt;clinit&gt;" sig="()V">
        <body>
          <call class="java.lang.System" name="registerNatives" sig="()V" />
          <ret />
        </body>
      </method>
a1619 6
      <method name="runInit" sig="()V" modifiers="static">
        <body>
          <call class="java.lang.System" name="initializeSystemClass" sig="()V" />
          <ret />
        </body>
      </method>
a1890 15
    <class name="java.nio.charset.spi.CharsetProvider">
      <method name="&lt;init&gt;" sig="()V">
        <!-- HACK this is a work around for a bootstrap issue, we can't trigger initialization of java.lang.System from here -->
        <replace-method-call class="java.lang.System" name="getSecurityManager" sig="()Ljava.lang.SecurityManager;">
          <code>
            <ldnull />
            <call class="sun.misc.VM" name="isBooted" sig="()Z" />
            <brfalse name="skip" />
            <pop />
            <call class="java.lang.System" name="getSecurityManager" sig="()Ljava.lang.SecurityManager;" />
            <label name="skip" />
          </code>
        </replace-method-call>
      </method>
    </class>
@


1.27
log
@Implemented System.in/out/err as .NET properties (explicitly).
@
text
@d2084 6
a2089 1
		<exception src="System.InvalidCastException" dst="java.lang.ClassCastException" />
@


1.26
log
@Set Thread context class loader for threads started from .NET.
@
text
@a1731 21
      <method name="setIn0" sig="(Ljava.io.InputStream;)V">
        <body>
          <ldarg_0 />
          <stsfld class="java.lang.System" name="in" sig="Ljava.io.InputStream;" />
          <ret />
        </body>
      </method>
      <method name="setOut0" sig="(Ljava.io.PrintStream;)V">
        <body>
          <ldarg_0 />
          <stsfld class="java.lang.System" name="out" sig="Ljava.io.PrintStream;" />
          <ret />
        </body>
      </method>
      <method name="setErr0" sig="(Ljava.io.PrintStream;)V">
        <body>
          <ldarg_0 />
          <stsfld class="java.lang.System" name="err" sig="Ljava.io.PrintStream;" />
          <ret />
        </body>
      </method>
@


1.25
log
@Ripped out annotation/constant pool support that is no longer needed.
@
text
@d1314 8
@


1.24
log
@Replaced notion of DynamicOnly types with Fake types. Fake types are implemented as generic type instances and can have DynamicOnly methods.
@
text
@a1182 1
      <field name="constantPool" sig="Ljava.lang.Object;" modifiers="" />
a2030 17
    <class name="sun.reflect.ConstantPool">
      <method name="_constantPoolOop" sig="()Ljava.lang.Object;">
        <body>
          <ldarg_0 />
          <ldfld class="sun.reflect.ConstantPool" name="constantPoolOop" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
      <method name="_constantPoolOop" sig="(Ljava.lang.Object;)V">
        <body>
          <ldarg_0 />
          <ldarg_1 />
          <stfld class="sun.reflect.ConstantPool" name="constantPoolOop" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
    </class>
@


1.23
log
@Made java.util.AbstractMap enumerable and added Add() method to support C# 3.0 collection initialization syntax.
@
text
@a1512 3
		<class name="ikvm.internal.EnumEnum">
			<field name="typeWrapper" sig="Ljava.lang.Object;" modifiers="private" />
		</class>
@


1.22
log
@Added "Add" method to java.util.AbstractCollection to make some of the .NET magic work on Java collections.
@
text
@d1388 29
@


1.21
log
@Partial Trust fixes:
- Added accessor methods for "slot" to Method & Constructor.
- Implemented System.setIn0, setOut0, setErr0 in map.xml.
- Hacked sun.misc.SharedSecrets to replace Unsafe.ensureClassInitialize() with direct calls.
- Replaced java.nio.Bits.byteOrder() with simple System.BitConver.IsLittleEndian based implementation.
- Disabled DynamicMethodSupport when running in partial trust.
- Ignore SecurityException in CanonicalizePath.
- Don't trigger load of JNI assembly when "loading" a fake system library.
@
text
@d1371 17
@


1.20
log
@- Moved some calls to methods with a LinkDemand (that fails in partial trust) to a separate methods.
- Added stuff to map.xml to remove the need for reflection in VM / Library bootstrap.
- Inverted IKVM.Runtime.JNI dependency in stack walking code.
@
text
@d1332 18
d1682 22
a1703 1
		</class>
d1718 40
d1961 13
@


1.19
log
@Restructured VM <-> Library interface to take advantage of InternalsVisibleTo to remove public methods and reflection usage.
@
text
@d1161 16
d1218 7
d1227 3
a1229 1
      <field name="vmThread" sig="Ljava.lang.Object;" modifiers="private" />
d1232 35
d1275 64
a1637 1
          <call class="java.lang.LangHelper" name="init" sig="()V" />
d1658 6
d1897 17
@


1.18
log
@Changed LibraryVMInterfaceImpl.getWrapperFromClass() and getWrapperFromClassLoader() from using reflection to a map.xml implementation to improve performance.
It turns out that Constructor.newInstance() calls Class.getModifiers() which indirectly uses getWrapperFromClass() and using reflection significantly affected deserialization performance.
@
text
@d1162 6
a1167 4
      <field name="typeWrapper" sig="Ljava.lang.Object;" modifiers="" />
      <field name="pd" sig="Ljava.security.ProtectionDomain;" modifiers="private" />
      <field name="signers" sig="[Ljava.lang.Object;" modifiers="private" />
      <field name="constantPool" sig="Ljava.lang.Object;" modifiers="private" />
d1176 7
d1185 3
a1187 1
      <field name="wrapper" sig="Ljava.lang.Object;" modifiers="" />
a1507 10
    <class name="java.lang.Shutdown">
      <method name="runAllFinalizers" sig="()V">
        <body>
          <ldc_i4_1 />
          <volatile />
          <stsfld class="java.lang.LibraryVMInterfaceImpl" name="runFinalizersOnExitFlag" sig="Z" />
          <ret />
        </body>
      </method>
    </class>
a1535 18
    <class name="java.lang.LibraryVMInterfaceImpl">
      <method name="getWrapperFromClass" sig="(Ljava.lang.Object;)Ljava.lang.Object;">
        <body>
          <ldarg_1 />
          <castclass class="java.lang.Class" />
          <ldfld class="java.lang.Class" name="typeWrapper" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
      <method name="getWrapperFromClassLoader" sig="(Ljava.lang.Object;)Ljava.lang.Object;">
        <body>
          <ldarg_1 />
          <castclass class="java.lang.ClassLoader" />
          <ldfld class="java.lang.ClassLoader" name="wrapper" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
    </class>
@


1.17
log
@Added workaround for OpenJDK bug.
@
text
@d1162 1
a1162 1
      <field name="typeWrapper" sig="Ljava.lang.Object;" modifiers="private" />
d1176 1
a1176 1
      <field name="wrapper" sig="Ljava.lang.Object;" modifiers="private" />
d1535 18
@


1.17.2.1
log
@Backported fixes from trunk. Changed version to 0.36.0.2.
@
text
@d1162 1
a1162 1
      <field name="typeWrapper" sig="Ljava.lang.Object;" modifiers="" />
d1176 1
a1176 1
      <field name="wrapper" sig="Ljava.lang.Object;" modifiers="" />
a1534 18
    <class name="java.lang.LibraryVMInterfaceImpl">
      <method name="getWrapperFromClass" sig="(Ljava.lang.Object;)Ljava.lang.Object;">
        <body>
          <ldarg_1 />
          <castclass class="java.lang.Class" />
          <ldfld class="java.lang.Class" name="typeWrapper" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
      <method name="getWrapperFromClassLoader" sig="(Ljava.lang.Object;)Ljava.lang.Object;">
        <body>
          <ldarg_1 />
          <castclass class="java.lang.ClassLoader" />
          <ldfld class="java.lang.ClassLoader" name="wrapper" sig="Ljava.lang.Object;" />
          <ret />
        </body>
      </method>
    </class>
@


1.17.2.2
log
@- Changed version to 0.36.0.9
- Added java.util.BitSet perf hack to map.xml
- Back ported codegen optimizations from 0.37.2970
@
text
@d3 1
a3 1
  Copyright (C) 2002-2008 Jeroen Frijters
a1217 9
    <class name="java.util.BitSet">
      <!-- HACK we "comment" out the asserts in checkInvariants, because they aren't used and yet have a significant perf impact
           because the CLR JIT isn't as clever as HotSpot about optimizing them away -->
      <method name="checkInvariants" sig="()V">
        <body>
          <ret />
        </body>
      </method>
    </class>
@


1.17.2.3
log
@- Added -removeassertions optimization option to ikvmc.
- Removed hack from map.xml to remove assertions from java.util.BitSet.checkInvariants().
- Added -removeassertions to IKVM.OpenJDK.ClassLibrary.dll build.
@
text
@d1218 9
@


1.17.2.4
log
@Back ported various fixes:
- Changed version to 0.36.0.13.
- Fixed ikvmc not to open the key file for write access.
- Added more efficient float/double to/from int/long bits converters.
- Fixed libikvm-native.so build to include reference to gmodule-2.0 library.
- Fixed ikvmc not to open the key file for write access.
- Fixed Graphics2D.rotate() to convert rotation angle from radians (Java) to degrees (.NET).
- Applied awt patch #1979656 by Daniel Wilson.
- Fixed three String bugs found by OpenJDK string tests.
- Fixed ldc <class> where <class> is a ghost array.
- Fixed bug in instanceof <class> where <class> is a Serializable[].
- Removed incorrect DataFormatException thrown in java.util.zip.InflaterHuffmanTree.
- Fixed #2001802 contributed by Andy Malakov.
- Fixed #2001799.
- Fixed #2006953.
- Made finalize() and clone() methods in cli.System.Object and cli.System.Exception final.
@
text
@d340 10
a349 1
        <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIILjava.nio.charset.Charset;)Ljava.lang.String;" />
d354 8
a361 1
        <redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BLjava.nio.charset.Charset;)Ljava.lang.String;" />
d912 7
a918 1
        <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.nio.charset.Charset;)[B" />
@


1.17.2.5
log
@Backport: Volatile stores require a memory barrier. Fix for #3086040.
@
text
@a1270 1
          <call class="cli.System.Threading.Thread" name="MemoryBarrier" sig="()V" />
a1287 1
          <call class="cli.System.Threading.Thread" name="MemoryBarrier" sig="()V" />
a1480 1
          <call class="cli.System.Threading.Thread" name="MemoryBarrier" sig="()V" />
a1579 1
					<call class="cli.System.Threading.Thread" name="MemoryBarrier" sig="()V" />
a1671 1
					<call class="cli.System.Threading.Thread" name="MemoryBarrier" sig="()V" />
@


1.16
log
@- Added workaround for java.net.DatagramSocket.receive() bug.
- Removed unused code.
@
text
@d1786 39
@


1.15
log
@Changed AtomicBoolean.value field to int to be serialization compatible with JDK.
@
text
@d1205 13
a1548 17
		<class name="gnu.java.net.PlainDatagramSocketImpl">
			<method name="setDatagramPacketLength" sig="(Ljava.net.DatagramPacket;I)V">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<stfld class="java.net.DatagramPacket" name="length" sig="I" />
					<ret />
				</body>
			</method>
			<method name="getDatagramPacketBufferLength" sig="(Ljava.net.DatagramPacket;)I">
				<body>
					<ldarg_0 />
					<ldfld class="java.net.DatagramPacket" name="maxlen" sig="I" />
					<ret />
				</body>
			</method>
		</class>
@


1.14
log
@Added hack to work around bootstrap issue in java.nio.charset.spi.CharsetProvider.
@
text
@d1606 14
@


1.13
log
@Added support for "loading" fake native libraries from VFS and removed hack to bypass loadLibrary() call in System.initializeSystemClass().
@
text
@d1742 15
@


1.12
log
@Switched to javac compiler for building OpenJDK sources.
@
text
@a1520 7
      <method name="initializeSystemClass" sig="()V">
        <replace-method-call class="java.lang.System" name="loadLibrary" sig="(Ljava.lang.String;)V">
          <code>
            <pop />
          </code>
        </replace-method-call>
      </method>
@


1.11
log
@- Imported a modified version of AbstractQueuedSynchronizer that is more efficient and doesn't use reflection & unsafe to reduce initialization order dependencies.
- Changed unsafe to use more efficient internal helper class to copy Field and make it accessible (this also reduces initialization order dependencies).
@
text
@d929 1
a929 1
					<newobj class="java.lang.String$CaseInsensitiveComparator" name="&lt;init&gt;" sig="(Ljava.lang.String$CaseInsensitiveComparator;)V" />
@


1.10
log
@- Implemented java.util.concurrent.locks.LockSupport.
- Fixed race condition in Thread.interrupt() that could cause cli.System.Threading.ThreadInterruptedException to be thrown from interruptable waits/sleep.
@
text
@d1205 50
@


1.9
log
@Integrated OpenJDK's java.io.FileDescriptor, FileInputStream, FileOutputStream & RandomAccessFile.
@
text
@d1194 2
d1205 46
@


1.8
log
@Removed NormalizerDataReader specific workaround and fixed InputStreamWrapper in a more generic way.
@
text
@a1461 16
		<class name="java.nio.channels.VMChannels">
			<method name="newInputStream" sig="(Lgnu.java.nio.FileChannelImpl;)Ljava.io.FileInputStream;">
				<body>
					<ldarg_0 />
					<newobj class="java.io.FileInputStream" name="&lt;init&gt;" sig="(Lgnu.java.nio.FileChannelImpl;)V" />
					<ret />
				</body>
			</method>
			<method name="newOutputStream" sig="(Lgnu.java.nio.FileChannelImpl;)Ljava.io.FileOutputStream;">
				<body>
					<ldarg_0 />
					<newobj class="java.io.FileOutputStream" name="&lt;init&gt;" sig="(Lgnu.java.nio.FileChannelImpl;)V" />
					<ret />
				</body>
			</method>
		</class>
@


1.7
log
@Added workaround for OpenJDK bug.
@
text
@a1685 16
    <class name="sun.text.normalizer.NormalizerDataReader">
      <method name="read" sig="([B[B[B[C[C)V">
        <!-- OPENJDKBUG -->
        <replace-method-call class="java.io.DataInputStream" name="read" sig="([B)I">
          <code>
            <stloc name="buf" type="System.Byte[]" />
            <stloc name="inp" class="java.io.DataInputStream" />
            <ldloc name="inp" />
            <ldloc name="buf" />
            <callvirt class="java.io.DataInputStream" name="readFully" sig="([B)V" />
            <ldloc name="buf" />
            <ldlen />
          </code>
        </replace-method-call>
      </method>
    </class>
@


1.6
log
@Implemented the hooks to set the system class loader to the entry assembly's class loader if java.class.path and java.ext.dirs properties aren't set.
@
text
@d1686 16
@


1.5
log
@Replaced zip library loading hack with new method call replacement hack.
@
text
@d1431 14
@


1.4
log
@- Integrated OpenJDK's java.lang package.
- Integrated OpenJDK's java.util.regex package.
- Integrated OpenJDK's java.text.Normalizer and support classes.
- New StringHelper.java based on OpenJDK's String.java.
- More fixes to Reflection.getCallerClass()
@
text
@d1423 7
@


1.3
log
@- Integrated OpenJDK's java.lang.System and friends.
- Fixed a couple of OpenJDK Thread issues.
@
text
@d268 2
a269 2
			<constructor sig="([CIIZ)V" modifiers="">
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([CIIZ)Ljava.lang.String;" />
d386 1
a386 1
				<redirect class="java.lang.StringHelper" sig="(C)Lcli.System.String;" />
d440 1
a440 12
				<body>
					<ldarg_1 />
					<ldc_i4 value="65535" />
					<ble_un name="ok" />
					<ldc_i4_m1 />
					<ret />
					<label name="ok" />
					<ldarg_0 />
					<ldarg_1 />
					<call type="System.String" name="IndexOf" sig="(C)I" />
					<ret />
				</body>
d445 1
a445 40
        <body>
          <!--
    			for (int i = fromIndex < 0 ? 0 : fromIndex; i < s.Length; i++)
			    {
				    if (this[i] == ch)
				    {
					    return i;
				    }
			    }
			    return -1;
          -->
          <ldarg_2 />
          <stloc name="i" type="System.Int32" />
          <ldc_i4_0 />
          <ldloc name="i" />
          <blt name="start_loop" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <beq name="ret_i" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_m1 />
          <ret />
          <label name="ret_i" />
          <ldloc name="i" />
          <ret />
        </body>
d456 12
a467 1
			<method name="lastIndexOf" sig="(I)I" modifiers="public">
d469 13
a481 24
				<body>
					<ldarg_1 />
					<ldc_i4 value="65535" />
					<ble_un name="ok" />
					<ldc_i4_m1 />
					<ret />
					<label name="ok" />
					<ldarg_0 />
					<ldarg_1 />
					<call type="System.String" name="LastIndexOf" sig="(C)I" />
					<ret />
				</body>
			</method>
			<method name="lastIndexOf" sig="(II)I" modifiers="public">
				<parameter name="ch" />
				<parameter name="fromIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)I" />
			</method>
			<method name="lastIndexOf" sig="(Ljava.lang.String;)I" modifiers="public">
				<parameter name="str" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
			</method>
			<method name="lastIndexOf" sig="(Ljava.lang.String;I)I" modifiers="public">
				<parameter name="str" />
a924 23
			<!-- NOTE we're redirecting fields to static methods here!
				NOTE only reading fields can be redirected
			-->
			<field name="count" sig="I" modifiers="">
				<redirect class="java.lang.StringHelper" type="static" name="GetCountField" sig="(Lcli.System.String;)I" />
			</field>
			<!-- Making a new char array instead of directly accessing the contents of the string, probably isn't
				as efficient as the coder of this construct wished for, but hey ;-) At least it works...
			-->
			<method name="zeroBasedStringValue" sig="(Ljava.lang.String;)[C" modifiers="static">
				<body>
					<ldarg_0 />
					<call type="System.String" name="ToCharArray" sig="()[C" />
					<ret />
				</body>
			</method>
			<!-- NOTE value and offset aren't used anymore in Classpath's StringBuffer, so we should drop them -->
			<field name="value" sig="[C" modifiers="">
				<redirect class="java.lang.StringHelper" type="static" name="GetValueField" sig="(Lcli.System.String;)[C" />
			</field>
			<field name="offset" sig="I" modifiers="">
				<redirect class="java.lang.StringHelper" type="static" name="GetOffsetField" sig="(Lcli.System.String;)I" />
			</field>
d928 2
a929 1
					<newobj class="java.lang.String$CaseInsensitiveComparator" name="&lt;init&gt;" sig="()V" />
d1646 19
@


1.2
log
@Integrated OpenJDK's java.lang.Thread
@
text
@d1266 8
d1458 20
a1477 1
		<class name="java.lang.VMSystem">
@


1.1
log
@First batch of OpenJDK integration code.
@
text
@d50 1
a50 1
					<call class="java.lang.VMThread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
d61 13
a73 13
					<call class="java.lang.VMThread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
					<ret />
				</body>
			</method>
			<method name="wait" sig="(JI)V" modifiers="public final">
				<parameter name="timeout" />
				<parameter name="nanos" />
				<throws class="java.lang.InterruptedException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<call class="java.lang.VMThread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
d1264 3
@

