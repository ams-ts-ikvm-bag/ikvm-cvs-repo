head	1.11;
access;
symbols
	v8_0_5449_1:1.9
	v8_0_5449_0:1.9
	v8_0:1.9.0.2
	v7_4_5196_0:1.8
	v7_4:1.8.0.2
	v7_3:1.6.0.4
	v7_2_4630_6:1.6
	v7_2_4630_5:1.6
	v7_2_4630_4:1.6
	v7_2_4630_3:1.6
	v7_2_4630_2:1.6
	v0_46_0_4:1.5
	v7_2_4630_1:1.6
	v7_2:1.6.0.2
	v7_1_4532_2:1.5
	v7_1_4532_1:1.5
	v7_1_4532_0:1.5
	v7_1:1.5.0.6
	v7_0_4335_3:1.5
	v7_0_4335_2:1.5
	v7_0_4335_1:1.5
	v0_46_0_2:1.5
	v7_0_4335_0:1.5
	v7_0:1.5.0.4
	v0_40_0_6:1.4
	v0_40_0_5:1.4
	v0_46_0_1:1.5
	v0_46_0_0:1.5
	v0_46:1.5.0.2
	v0_36_0_14:1.1
	v0_44_0_6:1.4
	v0_44_0_5:1.4
	v0_44_0_4:1.4
	v0_44_0_3:1.4
	v0_44_0_2:1.4
	v0_42_0_7:1.4
	v0_44_0_1:1.4
	v0_44_0_0:1.4
	v0_44:1.4.0.8
	v0_42_0_6:1.4
	v0_42_0_5:1.4
	v0_42_0_4:1.4
	v0_42_0_3:1.4
	v0_42_0_2:1.4
	v0_42_0_1:1.4
	v0_42_0_0:1.4
	v0_42:1.4.0.6
	v0_40_0_3:1.4
	v0_40_0_2:1.4
	v0_40_0_1:1.4
	v0_40_0_0:1.4
	v0_40:1.4.0.4
	v0_36_0_13:1.1
	v0_38_0_1:1.4
	v0_38_0_0:1.4
	v0_38:1.4.0.2
	v0_36_0_9:1.1
	v0_36_0_7:1.1
	v0_36_0_5:1.1
	v0_36_0_4:1.1
	v0_36_0_3:1.1
	v0_36_0_2:1.1
	v0_36_0_1:1.1
	v0_36_0_0:1.1
	v0_36:1.1.0.2;
locks; strict;
comment	@# @;


1.11
date	2015.06.26.11.37.07;	author jfrijters;	state dead;
branches;
next	1.10;

1.10
date	2015.06.09.09.28.43;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2014.05.19.12.43.38;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2014.02.07.14.14.10;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.15.12.47.21;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.29.07.18.06;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.24.16.40.22;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.13.09.01.08;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.12.09.09.19;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.11.09.05.08;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.18.09.16.20;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Unforked java/io/FileInputStream.java, java/io/FileOutputStream.java and java/io/RandomAccessFile.java.
@
text
@/*
 * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.io;

import java.nio.channels.FileChannel;
import sun.nio.ch.FileChannelImpl;


/**
 * Instances of this class support both reading and writing to a
 * random access file. A random access file behaves like a large
 * array of bytes stored in the file system. There is a kind of cursor,
 * or index into the implied array, called the <em>file pointer</em>;
 * input operations read bytes starting at the file pointer and advance
 * the file pointer past the bytes read. If the random access file is
 * created in read/write mode, then output operations are also available;
 * output operations write bytes starting at the file pointer and advance
 * the file pointer past the bytes written. Output operations that write
 * past the current end of the implied array cause the array to be
 * extended. The file pointer can be read by the
 * {@@code getFilePointer} method and set by the {@@code seek}
 * method.
 * <p>
 * It is generally true of all the reading routines in this class that
 * if end-of-file is reached before the desired number of bytes has been
 * read, an {@@code EOFException} (which is a kind of
 * {@@code IOException}) is thrown. If any byte cannot be read for
 * any reason other than end-of-file, an {@@code IOException} other
 * than {@@code EOFException} is thrown. In particular, an
 * {@@code IOException} may be thrown if the stream has been closed.
 *
 * @@author  unascribed
 * @@since   JDK1.0
 */

public class RandomAccessFile implements DataOutput, DataInput, Closeable {

    private FileDescriptor fd;
    private FileChannel channel = null;
    private boolean rw;

    /**
     * The path of the referenced file
     * (null if the stream is created with a file descriptor)
     */
    private final String path;

    private Object closeLock = new Object();
    private volatile boolean closed = false;

    private static final int O_RDONLY = 1;
    private static final int O_RDWR =   2;
    private static final int O_SYNC =   4;
    private static final int O_DSYNC =  8;

    /**
     * Creates a random access file stream to read from, and optionally
     * to write to, a file with the specified name. A new
     * {@@link FileDescriptor} object is created to represent the
     * connection to the file.
     *
     * <p> The <tt>mode</tt> argument specifies the access mode with which the
     * file is to be opened.  The permitted values and their meanings are as
     * specified for the <a
     * href="#mode"><tt>RandomAccessFile(File,String)</tt></a> constructor.
     *
     * <p>
     * If there is a security manager, its {@@code checkRead} method
     * is called with the {@@code name} argument
     * as its argument to see if read access to the file is allowed.
     * If the mode allows writing, the security manager's
     * {@@code checkWrite} method
     * is also called with the {@@code name} argument
     * as its argument to see if write access to the file is allowed.
     *
     * @@param      name   the system-dependent filename
     * @@param      mode   the access <a href="#mode">mode</a>
     * @@exception  IllegalArgumentException  if the mode argument is not equal
     *               to one of <tt>"r"</tt>, <tt>"rw"</tt>, <tt>"rws"</tt>, or
     *               <tt>"rwd"</tt>
     * @@exception FileNotFoundException
     *            if the mode is <tt>"r"</tt> but the given string does not
     *            denote an existing regular file, or if the mode begins with
     *            <tt>"rw"</tt> but the given string does not denote an
     *            existing, writable regular file and a new regular file of
     *            that name cannot be created, or if some other error occurs
     *            while opening or creating the file
     * @@exception  SecurityException         if a security manager exists and its
     *               {@@code checkRead} method denies read access to the file
     *               or the mode is "rw" and the security manager's
     *               {@@code checkWrite} method denies write access to the file
     * @@see        java.lang.SecurityException
     * @@see        java.lang.SecurityManager#checkRead(java.lang.String)
     * @@see        java.lang.SecurityManager#checkWrite(java.lang.String)
     * @@revised 1.4
     * @@spec JSR-51
     */
    public RandomAccessFile(String name, String mode)
        throws FileNotFoundException
    {
        this(name != null ? new File(name) : null, mode);
    }

    /**
     * Creates a random access file stream to read from, and optionally to
     * write to, the file specified by the {@@link File} argument.  A new {@@link
     * FileDescriptor} object is created to represent this file connection.
     *
     * <p>The <a name="mode"><tt>mode</tt></a> argument specifies the access mode
     * in which the file is to be opened.  The permitted values and their
     * meanings are:
     *
     * <table summary="Access mode permitted values and meanings">
     * <tr><th align="left">Value</th><th align="left">Meaning</th></tr>
     * <tr><td valign="top"><tt>"r"</tt></td>
     *     <td> Open for reading only.  Invoking any of the <tt>write</tt>
     *     methods of the resulting object will cause an {@@link
     *     java.io.IOException} to be thrown. </td></tr>
     * <tr><td valign="top"><tt>"rw"</tt></td>
     *     <td> Open for reading and writing.  If the file does not already
     *     exist then an attempt will be made to create it. </td></tr>
     * <tr><td valign="top"><tt>"rws"</tt></td>
     *     <td> Open for reading and writing, as with <tt>"rw"</tt>, and also
     *     require that every update to the file's content or metadata be
     *     written synchronously to the underlying storage device.  </td></tr>
     * <tr><td valign="top"><tt>"rwd"&nbsp;&nbsp;</tt></td>
     *     <td> Open for reading and writing, as with <tt>"rw"</tt>, and also
     *     require that every update to the file's content be written
     *     synchronously to the underlying storage device. </td></tr>
     * </table>
     *
     * The <tt>"rws"</tt> and <tt>"rwd"</tt> modes work much like the {@@link
     * java.nio.channels.FileChannel#force(boolean) force(boolean)} method of
     * the {@@link java.nio.channels.FileChannel} class, passing arguments of
     * <tt>true</tt> and <tt>false</tt>, respectively, except that they always
     * apply to every I/O operation and are therefore often more efficient.  If
     * the file resides on a local storage device then when an invocation of a
     * method of this class returns it is guaranteed that all changes made to
     * the file by that invocation will have been written to that device.  This
     * is useful for ensuring that critical information is not lost in the
     * event of a system crash.  If the file does not reside on a local device
     * then no such guarantee is made.
     *
     * <p>The <tt>"rwd"</tt> mode can be used to reduce the number of I/O
     * operations performed.  Using <tt>"rwd"</tt> only requires updates to the
     * file's content to be written to storage; using <tt>"rws"</tt> requires
     * updates to both the file's content and its metadata to be written, which
     * generally requires at least one more low-level I/O operation.
     *
     * <p>If there is a security manager, its {@@code checkRead} method is
     * called with the pathname of the {@@code file} argument as its
     * argument to see if read access to the file is allowed.  If the mode
     * allows writing, the security manager's {@@code checkWrite} method is
     * also called with the path argument to see if write access to the file is
     * allowed.
     *
     * @@param      file   the file object
     * @@param      mode   the access mode, as described
     *                    <a href="#mode">above</a>
     * @@exception  IllegalArgumentException  if the mode argument is not equal
     *               to one of <tt>"r"</tt>, <tt>"rw"</tt>, <tt>"rws"</tt>, or
     *               <tt>"rwd"</tt>
     * @@exception FileNotFoundException
     *            if the mode is <tt>"r"</tt> but the given file object does
     *            not denote an existing regular file, or if the mode begins
     *            with <tt>"rw"</tt> but the given file object does not denote
     *            an existing, writable regular file and a new regular file of
     *            that name cannot be created, or if some other error occurs
     *            while opening or creating the file
     * @@exception  SecurityException         if a security manager exists and its
     *               {@@code checkRead} method denies read access to the file
     *               or the mode is "rw" and the security manager's
     *               {@@code checkWrite} method denies write access to the file
     * @@see        java.lang.SecurityManager#checkRead(java.lang.String)
     * @@see        java.lang.SecurityManager#checkWrite(java.lang.String)
     * @@see        java.nio.channels.FileChannel#force(boolean)
     * @@revised 1.4
     * @@spec JSR-51
     */
    public RandomAccessFile(File file, String mode)
        throws FileNotFoundException
    {
        String name = (file != null ? file.getPath() : null);
        int imode = -1;
        if (mode.equals("r"))
            imode = O_RDONLY;
        else if (mode.startsWith("rw")) {
            imode = O_RDWR;
            rw = true;
            if (mode.length() > 2) {
                if (mode.equals("rws"))
                    imode |= O_SYNC;
                else if (mode.equals("rwd"))
                    imode |= O_DSYNC;
                else
                    imode = -1;
            }
        }
        if (imode < 0)
            throw new IllegalArgumentException("Illegal mode \"" + mode
                                               + "\" must be one of "
                                               + "\"r\", \"rw\", \"rws\","
                                               + " or \"rwd\"");
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkRead(name);
            if (rw) {
                security.checkWrite(name);
            }
        }
        if (name == null) {
            throw new NullPointerException();
        }
        if (file.isInvalid()) {
            throw new FileNotFoundException("Invalid file path");
        }
        fd = new FileDescriptor();
        fd.attach(this);
        path = name;
        open(name, imode);
    }

    /**
     * Returns the opaque file descriptor object associated with this
     * stream.
     *
     * @@return     the file descriptor object associated with this stream.
     * @@exception  IOException  if an I/O error occurs.
     * @@see        java.io.FileDescriptor
     */
    public final FileDescriptor getFD() throws IOException {
        if (fd != null) {
            return fd;
        }
        throw new IOException();
    }

    /**
     * Returns the unique {@@link java.nio.channels.FileChannel FileChannel}
     * object associated with this file.
     *
     * <p> The {@@link java.nio.channels.FileChannel#position()
     * position} of the returned channel will always be equal to
     * this object's file-pointer offset as returned by the {@@link
     * #getFilePointer getFilePointer} method.  Changing this object's
     * file-pointer offset, whether explicitly or by reading or writing bytes,
     * will change the position of the channel, and vice versa.  Changing the
     * file's length via this object will change the length seen via the file
     * channel, and vice versa.
     *
     * @@return  the file channel associated with this file
     *
     * @@since 1.4
     * @@spec JSR-51
     */
    public final FileChannel getChannel() {
        synchronized (this) {
            if (channel == null) {
                channel = FileChannelImpl.open(fd, path, true, rw, this);
            }
            return channel;
        }
    }

    /**
     * Opens a file and returns the file descriptor.  The file is
     * opened in read-write mode if the O_RDWR bit in {@@code mode}
     * is true, else the file is opened as read-only.
     * If the {@@code name} refers to a directory, an IOException
     * is thrown.
     *
     * @@param name the name of the file
     * @@param mode the mode flags, a combination of the O_ constants
     *             defined above
     */
    private void open(String name, int mode)
        throws FileNotFoundException
    {
        if ((mode & O_RDWR) == O_RDWR)
        {
            fd.openReadWrite(name);
        }
        else
        {
            fd.openReadOnly(name);
        }
    }

    // 'Read' primitives

    /**
     * Reads a byte of data from this file. The byte is returned as an
     * integer in the range 0 to 255 ({@@code 0x00-0x0ff}). This
     * method blocks if no input is yet available.
     * <p>
     * Although {@@code RandomAccessFile} is not a subclass of
     * {@@code InputStream}, this method behaves in exactly the same
     * way as the {@@link InputStream#read()} method of
     * {@@code InputStream}.
     *
     * @@return     the next byte of data, or {@@code -1} if the end of the
     *             file has been reached.
     * @@exception  IOException  if an I/O error occurs. Not thrown if
     *                          end-of-file has been reached.
     */
    public int read() throws IOException {
        return fd.read();
    }

    /**
     * Reads a sub array as a sequence of bytes.
     * @@param b the buffer into which the data is read.
     * @@param off the start offset of the data.
     * @@param len the number of bytes to read.
     * @@exception IOException If an I/O error has occurred.
     */
    private int readBytes(byte b[], int off, int len) throws IOException
    {
        return fd.readBytes(b, off, len);
    }

    /**
     * Reads up to {@@code len} bytes of data from this file into an
     * array of bytes. This method blocks until at least one byte of input
     * is available.
     * <p>
     * Although {@@code RandomAccessFile} is not a subclass of
     * {@@code InputStream}, this method behaves in exactly the
     * same way as the {@@link InputStream#read(byte[], int, int)} method of
     * {@@code InputStream}.
     *
     * @@param      b     the buffer into which the data is read.
     * @@param      off   the start offset in array {@@code b}
     *                   at which the data is written.
     * @@param      len   the maximum number of bytes read.
     * @@return     the total number of bytes read into the buffer, or
     *             {@@code -1} if there is no more data because the end of
     *             the file has been reached.
     * @@exception  IOException If the first byte cannot be read for any reason
     * other than end of file, or if the random access file has been closed, or if
     * some other I/O error occurs.
     * @@exception  NullPointerException If {@@code b} is {@@code null}.
     * @@exception  IndexOutOfBoundsException If {@@code off} is negative,
     * {@@code len} is negative, or {@@code len} is greater than
     * {@@code b.length - off}
     */
    public int read(byte b[], int off, int len) throws IOException {
        return readBytes(b, off, len);
    }

    /**
     * Reads up to {@@code b.length} bytes of data from this file
     * into an array of bytes. This method blocks until at least one byte
     * of input is available.
     * <p>
     * Although {@@code RandomAccessFile} is not a subclass of
     * {@@code InputStream}, this method behaves in exactly the
     * same way as the {@@link InputStream#read(byte[])} method of
     * {@@code InputStream}.
     *
     * @@param      b   the buffer into which the data is read.
     * @@return     the total number of bytes read into the buffer, or
     *             {@@code -1} if there is no more data because the end of
     *             this file has been reached.
     * @@exception  IOException If the first byte cannot be read for any reason
     * other than end of file, or if the random access file has been closed, or if
     * some other I/O error occurs.
     * @@exception  NullPointerException If {@@code b} is {@@code null}.
     */
    public int read(byte b[]) throws IOException {
        return readBytes(b, 0, b.length);
    }

    /**
     * Reads {@@code b.length} bytes from this file into the byte
     * array, starting at the current file pointer. This method reads
     * repeatedly from the file until the requested number of bytes are
     * read. This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     *
     * @@param      b   the buffer into which the data is read.
     * @@exception  EOFException  if this file reaches the end before reading
     *               all the bytes.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final void readFully(byte b[]) throws IOException {
        readFully(b, 0, b.length);
    }

    /**
     * Reads exactly {@@code len} bytes from this file into the byte
     * array, starting at the current file pointer. This method reads
     * repeatedly from the file until the requested number of bytes are
     * read. This method blocks until the requested number of bytes are
     * read, the end of the stream is detected, or an exception is thrown.
     *
     * @@param      b     the buffer into which the data is read.
     * @@param      off   the start offset of the data.
     * @@param      len   the number of bytes to read.
     * @@exception  EOFException  if this file reaches the end before reading
     *               all the bytes.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final void readFully(byte b[], int off, int len) throws IOException {
        int n = 0;
        do {
            int count = this.read(b, off + n, len - n);
            if (count < 0)
                throw new EOFException();
            n += count;
        } while (n < len);
    }

    /**
     * Attempts to skip over {@@code n} bytes of input discarding the
     * skipped bytes.
     * <p>
     *
     * This method may skip over some smaller number of bytes, possibly zero.
     * This may result from any of a number of conditions; reaching end of
     * file before {@@code n} bytes have been skipped is only one
     * possibility. This method never throws an {@@code EOFException}.
     * The actual number of bytes skipped is returned.  If {@@code n}
     * is negative, no bytes are skipped.
     *
     * @@param      n   the number of bytes to be skipped.
     * @@return     the actual number of bytes skipped.
     * @@exception  IOException  if an I/O error occurs.
     */
    public int skipBytes(int n) throws IOException {
        long pos;
        long len;
        long newpos;

        if (n <= 0) {
            return 0;
        }
        pos = getFilePointer();
        len = length();
        newpos = pos + n;
        if (newpos > len) {
            newpos = len;
        }
        seek(newpos);

        /* return the actual number of bytes skipped */
        return (int) (newpos - pos);
    }

    // 'Write' primitives

    /**
     * Writes the specified byte to this file. The write starts at
     * the current file pointer.
     *
     * @@param      b   the {@@code byte} to be written.
     * @@exception  IOException  if an I/O error occurs.
     */
    public void write(int b) throws IOException {
        fd.write(b);
    }

    /**
     * Writes a sub array as a sequence of bytes.
     * @@param b the data to be written

     * @@param off the start offset in the data
     * @@param len the number of bytes that are written
     * @@exception IOException If an I/O error has occurred.
     */
    private void writeBytes(byte b[], int off, int len) throws IOException {
        fd.writeBytes(b, off, len);
    }

    /**
     * Writes {@@code b.length} bytes from the specified byte array
     * to this file, starting at the current file pointer.
     *
     * @@param      b   the data.
     * @@exception  IOException  if an I/O error occurs.
     */
    public void write(byte b[]) throws IOException {
        writeBytes(b, 0, b.length);
    }

    /**
     * Writes {@@code len} bytes from the specified byte array
     * starting at offset {@@code off} to this file.
     *
     * @@param      b     the data.
     * @@param      off   the start offset in the data.
     * @@param      len   the number of bytes to write.
     * @@exception  IOException  if an I/O error occurs.
     */
    public void write(byte b[], int off, int len) throws IOException {
        writeBytes(b, off, len);
    }

    // 'Random access' stuff

    /**
     * Returns the current offset in this file.
     *
     * @@return     the offset from the beginning of the file, in bytes,
     *             at which the next read or write occurs.
     * @@exception  IOException  if an I/O error occurs.
     */
    public long getFilePointer() throws IOException
    {
        return fd.getFilePointer();
    }

    /**
     * Sets the file-pointer offset, measured from the beginning of this
     * file, at which the next read or write occurs.  The offset may be
     * set beyond the end of the file. Setting the offset beyond the end
     * of the file does not change the file length.  The file length will
     * change only by writing after the offset has been set beyond the end
     * of the file.
     *
     * @@param      pos   the offset position, measured in bytes from the
     *                   beginning of the file, at which to set the file
     *                   pointer.
     * @@exception  IOException  if {@@code pos} is less than
     *                          {@@code 0} or if an I/O error occurs.
     */
    public void seek(long pos) throws IOException {
        if (pos < 0) {
            throw new IOException("Negative seek offset");
        } else {
            fd.seek(pos);
        }
    }

    /**
     * Returns the length of this file.
     *
     * @@return     the length of this file, measured in bytes.
     * @@exception  IOException  if an I/O error occurs.
     */
    public long length() throws IOException
    {
        return fd.length();
    }

    /**
     * Sets the length of this file.
     *
     * <p> If the present length of the file as returned by the
     * {@@code length} method is greater than the {@@code newLength}
     * argument then the file will be truncated.  In this case, if the file
     * offset as returned by the {@@code getFilePointer} method is greater
     * than {@@code newLength} then after this method returns the offset
     * will be equal to {@@code newLength}.
     *
     * <p> If the present length of the file as returned by the
     * {@@code length} method is smaller than the {@@code newLength}
     * argument then the file will be extended.  In this case, the contents of
     * the extended portion of the file are not defined.
     *
     * @@param      newLength    The desired length of the file
     * @@exception  IOException  If an I/O error occurs
     * @@since      1.2
     */
    public void setLength(long newLength) throws IOException
    {
        fd.setLength(newLength);
    }

    /**
     * Closes this random access file stream and releases any system
     * resources associated with the stream. A closed random access
     * file cannot perform input or output operations and cannot be
     * reopened.
     *
     * <p> If this file has an associated channel then the channel is closed
     * as well.
     *
     * @@exception  IOException  if an I/O error occurs.
     *
     * @@revised 1.4
     * @@spec JSR-51
     */
    public void close() throws IOException {
        synchronized (closeLock) {
            if (closed) {
                return;
            }
            closed = true;
        }
        if (channel != null) {
            channel.close();
        }

        fd.closeAll(new Closeable() {
            public void close() throws IOException {
               close0();
           }
        });
    }

    //
    //  Some "reading/writing Java data types" methods stolen from
    //  DataInputStream and DataOutputStream.
    //

    /**
     * Reads a {@@code boolean} from this file. This method reads a
     * single byte from the file, starting at the current file pointer.
     * A value of {@@code 0} represents
     * {@@code false}. Any other value represents {@@code true}.
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @@return     the {@@code boolean} value read.
     * @@exception  EOFException  if this file has reached the end.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final boolean readBoolean() throws IOException {
        int ch = this.read();
        if (ch < 0)
            throw new EOFException();
        return (ch != 0);
    }

    /**
     * Reads a signed eight-bit value from this file. This method reads a
     * byte from the file, starting from the current file pointer.
     * If the byte read is {@@code b}, where
     * <code>0&nbsp;&lt;=&nbsp;b&nbsp;&lt;=&nbsp;255</code>,
     * then the result is:
     * <blockquote><pre>
     *     (byte)(b)
     * </pre></blockquote>
     * <p>
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @@return     the next byte of this file as a signed eight-bit
     *             {@@code byte}.
     * @@exception  EOFException  if this file has reached the end.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final byte readByte() throws IOException {
        int ch = this.read();
        if (ch < 0)
            throw new EOFException();
        return (byte)(ch);
    }

    /**
     * Reads an unsigned eight-bit number from this file. This method reads
     * a byte from this file, starting at the current file pointer,
     * and returns that byte.
     * <p>
     * This method blocks until the byte is read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @@return     the next byte of this file, interpreted as an unsigned
     *             eight-bit number.
     * @@exception  EOFException  if this file has reached the end.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final int readUnsignedByte() throws IOException {
        int ch = this.read();
        if (ch < 0)
            throw new EOFException();
        return ch;
    }

    /**
     * Reads a signed 16-bit number from this file. The method reads two
     * bytes from this file, starting at the current file pointer.
     * If the two bytes read, in order, are
     * {@@code b1} and {@@code b2}, where each of the two values is
     * between {@@code 0} and {@@code 255}, inclusive, then the
     * result is equal to:
     * <blockquote><pre>
     *     (short)((b1 &lt;&lt; 8) | b2)
     * </pre></blockquote>
     * <p>
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @@return     the next two bytes of this file, interpreted as a signed
     *             16-bit number.
     * @@exception  EOFException  if this file reaches the end before reading
     *               two bytes.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final short readShort() throws IOException {
        int ch1 = this.read();
        int ch2 = this.read();
        if ((ch1 | ch2) < 0)
            throw new EOFException();
        return (short)((ch1 << 8) + (ch2 << 0));
    }

    /**
     * Reads an unsigned 16-bit number from this file. This method reads
     * two bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * {@@code b1} and {@@code b2}, where
     * <code>0&nbsp;&lt;=&nbsp;b1, b2&nbsp;&lt;=&nbsp;255</code>,
     * then the result is equal to:
     * <blockquote><pre>
     *     (b1 &lt;&lt; 8) | b2
     * </pre></blockquote>
     * <p>
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @@return     the next two bytes of this file, interpreted as an unsigned
     *             16-bit integer.
     * @@exception  EOFException  if this file reaches the end before reading
     *               two bytes.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final int readUnsignedShort() throws IOException {
        int ch1 = this.read();
        int ch2 = this.read();
        if ((ch1 | ch2) < 0)
            throw new EOFException();
        return (ch1 << 8) + (ch2 << 0);
    }

    /**
     * Reads a character from this file. This method reads two
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * {@@code b1} and {@@code b2}, where
     * <code>0&nbsp;&lt;=&nbsp;b1,&nbsp;b2&nbsp;&lt;=&nbsp;255</code>,
     * then the result is equal to:
     * <blockquote><pre>
     *     (char)((b1 &lt;&lt; 8) | b2)
     * </pre></blockquote>
     * <p>
     * This method blocks until the two bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @@return     the next two bytes of this file, interpreted as a
     *                  {@@code char}.
     * @@exception  EOFException  if this file reaches the end before reading
     *               two bytes.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final char readChar() throws IOException {
        int ch1 = this.read();
        int ch2 = this.read();
        if ((ch1 | ch2) < 0)
            throw new EOFException();
        return (char)((ch1 << 8) + (ch2 << 0));
    }

    /**
     * Reads a signed 32-bit integer from this file. This method reads 4
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are {@@code b1},
     * {@@code b2}, {@@code b3}, and {@@code b4}, where
     * <code>0&nbsp;&lt;=&nbsp;b1, b2, b3, b4&nbsp;&lt;=&nbsp;255</code>,
     * then the result is equal to:
     * <blockquote><pre>
     *     (b1 &lt;&lt; 24) | (b2 &lt;&lt; 16) + (b3 &lt;&lt; 8) + b4
     * </pre></blockquote>
     * <p>
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @@return     the next four bytes of this file, interpreted as an
     *             {@@code int}.
     * @@exception  EOFException  if this file reaches the end before reading
     *               four bytes.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final int readInt() throws IOException {
        int ch1 = this.read();
        int ch2 = this.read();
        int ch3 = this.read();
        int ch4 = this.read();
        if ((ch1 | ch2 | ch3 | ch4) < 0)
            throw new EOFException();
        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));
    }

    /**
     * Reads a signed 64-bit integer from this file. This method reads eight
     * bytes from the file, starting at the current file pointer.
     * If the bytes read, in order, are
     * {@@code b1}, {@@code b2}, {@@code b3},
     * {@@code b4}, {@@code b5}, {@@code b6},
     * {@@code b7}, and {@@code b8,} where:
     * <blockquote><pre>
     *     0 &lt;= b1, b2, b3, b4, b5, b6, b7, b8 &lt;=255,
     * </pre></blockquote>
     * <p>
     * then the result is equal to:
     * <blockquote><pre>
     *     ((long)b1 &lt;&lt; 56) + ((long)b2 &lt;&lt; 48)
     *     + ((long)b3 &lt;&lt; 40) + ((long)b4 &lt;&lt; 32)
     *     + ((long)b5 &lt;&lt; 24) + ((long)b6 &lt;&lt; 16)
     *     + ((long)b7 &lt;&lt; 8) + b8
     * </pre></blockquote>
     * <p>
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @@return     the next eight bytes of this file, interpreted as a
     *             {@@code long}.
     * @@exception  EOFException  if this file reaches the end before reading
     *               eight bytes.
     * @@exception  IOException   if an I/O error occurs.
     */
    public final long readLong() throws IOException {
        return ((long)(readInt()) << 32) + (readInt() & 0xFFFFFFFFL);
    }

    /**
     * Reads a {@@code float} from this file. This method reads an
     * {@@code int} value, starting at the current file pointer,
     * as if by the {@@code readInt} method
     * and then converts that {@@code int} to a {@@code float}
     * using the {@@code intBitsToFloat} method in class
     * {@@code Float}.
     * <p>
     * This method blocks until the four bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @@return     the next four bytes of this file, interpreted as a
     *             {@@code float}.
     * @@exception  EOFException  if this file reaches the end before reading
     *             four bytes.
     * @@exception  IOException   if an I/O error occurs.
     * @@see        java.io.RandomAccessFile#readInt()
     * @@see        java.lang.Float#intBitsToFloat(int)
     */
    public final float readFloat() throws IOException {
        return Float.intBitsToFloat(readInt());
    }

    /**
     * Reads a {@@code double} from this file. This method reads a
     * {@@code long} value, starting at the current file pointer,
     * as if by the {@@code readLong} method
     * and then converts that {@@code long} to a {@@code double}
     * using the {@@code longBitsToDouble} method in
     * class {@@code Double}.
     * <p>
     * This method blocks until the eight bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @@return     the next eight bytes of this file, interpreted as a
     *             {@@code double}.
     * @@exception  EOFException  if this file reaches the end before reading
     *             eight bytes.
     * @@exception  IOException   if an I/O error occurs.
     * @@see        java.io.RandomAccessFile#readLong()
     * @@see        java.lang.Double#longBitsToDouble(long)
     */
    public final double readDouble() throws IOException {
        return Double.longBitsToDouble(readLong());
    }

    /**
     * Reads the next line of text from this file.  This method successively
     * reads bytes from the file, starting at the current file pointer,
     * until it reaches a line terminator or the end
     * of the file.  Each byte is converted into a character by taking the
     * byte's value for the lower eight bits of the character and setting the
     * high eight bits of the character to zero.  This method does not,
     * therefore, support the full Unicode character set.
     *
     * <p> A line of text is terminated by a carriage-return character
     * ({@@code '\u005Cr'}), a newline character ({@@code '\u005Cn'}), a
     * carriage-return character immediately followed by a newline character,
     * or the end of the file.  Line-terminating characters are discarded and
     * are not included as part of the string returned.
     *
     * <p> This method blocks until a newline character is read, a carriage
     * return and the byte following it are read (to see if it is a newline),
     * the end of the file is reached, or an exception is thrown.
     *
     * @@return     the next line of text from this file, or null if end
     *             of file is encountered before even one byte is read.
     * @@exception  IOException  if an I/O error occurs.
     */

    public final String readLine() throws IOException {
        StringBuffer input = new StringBuffer();
        int c = -1;
        boolean eol = false;

        while (!eol) {
            switch (c = read()) {
            case -1:
            case '\n':
                eol = true;
                break;
            case '\r':
                eol = true;
                long cur = getFilePointer();
                if ((read()) != '\n') {
                    seek(cur);
                }
                break;
            default:
                input.append((char)c);
                break;
            }
        }

        if ((c == -1) && (input.length() == 0)) {
            return null;
        }
        return input.toString();
    }

    /**
     * Reads in a string from this file. The string has been encoded
     * using a
     * <a href="DataInput.html#modified-utf-8">modified UTF-8</a>
     * format.
     * <p>
     * The first two bytes are read, starting from the current file
     * pointer, as if by
     * {@@code readUnsignedShort}. This value gives the number of
     * following bytes that are in the encoded string, not
     * the length of the resulting string. The following bytes are then
     * interpreted as bytes encoding characters in the modified UTF-8 format
     * and are converted into characters.
     * <p>
     * This method blocks until all the bytes are read, the end of the
     * stream is detected, or an exception is thrown.
     *
     * @@return     a Unicode string.
     * @@exception  EOFException            if this file reaches the end before
     *               reading all the bytes.
     * @@exception  IOException             if an I/O error occurs.
     * @@exception  UTFDataFormatException  if the bytes do not represent
     *               valid modified UTF-8 encoding of a Unicode string.
     * @@see        java.io.RandomAccessFile#readUnsignedShort()
     */
    public final String readUTF() throws IOException {
        return DataInputStream.readUTF(this);
    }

    /**
     * Writes a {@@code boolean} to the file as a one-byte value. The
     * value {@@code true} is written out as the value
     * {@@code (byte)1}; the value {@@code false} is written out
     * as the value {@@code (byte)0}. The write starts at
     * the current position of the file pointer.
     *
     * @@param      v   a {@@code boolean} value to be written.
     * @@exception  IOException  if an I/O error occurs.
     */
    public final void writeBoolean(boolean v) throws IOException {
        write(v ? 1 : 0);
        //written++;
    }

    /**
     * Writes a {@@code byte} to the file as a one-byte value. The
     * write starts at the current position of the file pointer.
     *
     * @@param      v   a {@@code byte} value to be written.
     * @@exception  IOException  if an I/O error occurs.
     */
    public final void writeByte(int v) throws IOException {
        write(v);
        //written++;
    }

    /**
     * Writes a {@@code short} to the file as two bytes, high byte first.
     * The write starts at the current position of the file pointer.
     *
     * @@param      v   a {@@code short} to be written.
     * @@exception  IOException  if an I/O error occurs.
     */
    public final void writeShort(int v) throws IOException {
        write((v >>> 8) & 0xFF);
        write((v >>> 0) & 0xFF);
        //written += 2;
    }

    /**
     * Writes a {@@code char} to the file as a two-byte value, high
     * byte first. The write starts at the current position of the
     * file pointer.
     *
     * @@param      v   a {@@code char} value to be written.
     * @@exception  IOException  if an I/O error occurs.
     */
    public final void writeChar(int v) throws IOException {
        write((v >>> 8) & 0xFF);
        write((v >>> 0) & 0xFF);
        //written += 2;
    }

    /**
     * Writes an {@@code int} to the file as four bytes, high byte first.
     * The write starts at the current position of the file pointer.
     *
     * @@param      v   an {@@code int} to be written.
     * @@exception  IOException  if an I/O error occurs.
     */
    public final void writeInt(int v) throws IOException {
        write((v >>> 24) & 0xFF);
        write((v >>> 16) & 0xFF);
        write((v >>>  8) & 0xFF);
        write((v >>>  0) & 0xFF);
        //written += 4;
    }

    /**
     * Writes a {@@code long} to the file as eight bytes, high byte first.
     * The write starts at the current position of the file pointer.
     *
     * @@param      v   a {@@code long} to be written.
     * @@exception  IOException  if an I/O error occurs.
     */
    public final void writeLong(long v) throws IOException {
        write((int)(v >>> 56) & 0xFF);
        write((int)(v >>> 48) & 0xFF);
        write((int)(v >>> 40) & 0xFF);
        write((int)(v >>> 32) & 0xFF);
        write((int)(v >>> 24) & 0xFF);
        write((int)(v >>> 16) & 0xFF);
        write((int)(v >>>  8) & 0xFF);
        write((int)(v >>>  0) & 0xFF);
        //written += 8;
    }

    /**
     * Converts the float argument to an {@@code int} using the
     * {@@code floatToIntBits} method in class {@@code Float},
     * and then writes that {@@code int} value to the file as a
     * four-byte quantity, high byte first. The write starts at the
     * current position of the file pointer.
     *
     * @@param      v   a {@@code float} value to be written.
     * @@exception  IOException  if an I/O error occurs.
     * @@see        java.lang.Float#floatToIntBits(float)
     */
    public final void writeFloat(float v) throws IOException {
        writeInt(Float.floatToIntBits(v));
    }

    /**
     * Converts the double argument to a {@@code long} using the
     * {@@code doubleToLongBits} method in class {@@code Double},
     * and then writes that {@@code long} value to the file as an
     * eight-byte quantity, high byte first. The write starts at the current
     * position of the file pointer.
     *
     * @@param      v   a {@@code double} value to be written.
     * @@exception  IOException  if an I/O error occurs.
     * @@see        java.lang.Double#doubleToLongBits(double)
     */
    public final void writeDouble(double v) throws IOException {
        writeLong(Double.doubleToLongBits(v));
    }

    /**
     * Writes the string to the file as a sequence of bytes. Each
     * character in the string is written out, in sequence, by discarding
     * its high eight bits. The write starts at the current position of
     * the file pointer.
     *
     * @@param      s   a string of bytes to be written.
     * @@exception  IOException  if an I/O error occurs.
     */
    @@SuppressWarnings("deprecation")
    public final void writeBytes(String s) throws IOException {
        int len = s.length();
        byte[] b = new byte[len];
        s.getBytes(0, len, b, 0);
        writeBytes(b, 0, len);
    }

    /**
     * Writes a string to the file as a sequence of characters. Each
     * character is written to the data output stream as if by the
     * {@@code writeChar} method. The write starts at the current
     * position of the file pointer.
     *
     * @@param      s   a {@@code String} value to be written.
     * @@exception  IOException  if an I/O error occurs.
     * @@see        java.io.RandomAccessFile#writeChar(int)
     */
    public final void writeChars(String s) throws IOException {
        int clen = s.length();
        int blen = 2*clen;
        byte[] b = new byte[blen];
        char[] c = new char[clen];
        s.getChars(0, clen, c, 0);
        for (int i = 0, j = 0; i < clen; i++) {
            b[j++] = (byte)(c[i] >>> 8);
            b[j++] = (byte)(c[i] >>> 0);
        }
        writeBytes(b, 0, blen);
    }

    /**
     * Writes a string to the file using
     * <a href="DataInput.html#modified-utf-8">modified UTF-8</a>
     * encoding in a machine-independent manner.
     * <p>
     * First, two bytes are written to the file, starting at the
     * current file pointer, as if by the
     * {@@code writeShort} method giving the number of bytes to
     * follow. This value is the number of bytes actually written out,
     * not the length of the string. Following the length, each character
     * of the string is output, in sequence, using the modified UTF-8 encoding
     * for each character.
     *
     * @@param      str   a string to be written.
     * @@exception  IOException  if an I/O error occurs.
     */
    public final void writeUTF(String str) throws IOException {
        DataOutputStream.writeUTF(str, this);
    }

    private void close0() throws IOException
    {
        fd.close();
    }
}
@


1.10
log
@Integrated OpenJDK 8u45.
@
text
@@


1.9
log
@First part of OpenJDK 8 integration.
@
text
@d65 6
d242 1
d282 1
a282 1
                channel = FileChannelImpl.open(fd, true, rw, this);
@


1.8
log
@Merged OpenJDK 7u40 b34, except for java.lang.invoke and sun.invoke packages.
@
text
@a29 1
import sun.misc.IoTrace;
d44 1
a44 1
 * <code>getFilePointer</code> method and set by the <code>seek</code>
d49 5
a53 5
 * read, an <code>EOFException</code> (which is a kind of
 * <code>IOException</code>) is thrown. If any byte cannot be read for
 * any reason other than end-of-file, an <code>IOException</code> other
 * than <code>EOFException</code> is thrown. In particular, an
 * <code>IOException</code> may be thrown if the stream has been closed.
a64 3
    /* The path of the referenced file */
    private final String path;

d85 2
a86 2
     * If there is a security manager, its <code>checkRead</code> method
     * is called with the <code>name</code> argument
d89 2
a90 2
     * <code>checkWrite</code> method
     * is also called with the <code>name</code> argument
d106 1
a106 1
     *               <code>checkRead</code> method denies read access to the file
d108 1
a108 1
     *               <code>checkWrite</code> method denies write access to the file
d126 1
a126 1
     * <a name="mode"><p> The <tt>mode</tt> argument specifies the access mode
d130 2
a131 2
     * <blockquote><table summary="Access mode permitted values and meanings">
     * <tr><th><p align="left">Value</p></th><th><p align="left">Meaning</p></th></tr>
d147 1
a147 1
     * </table></blockquote>
d161 1
a161 1
     * <p> The <tt>"rwd"</tt> mode can be used to reduce the number of I/O
d167 2
a168 2
     * <p> If there is a security manager, its <code>checkRead</code> method is
     * called with the pathname of the <code>file</code> argument as its
d170 1
a170 1
     * allows writing, the security manager's <code>checkWrite</code> method is
d188 1
a188 1
     *               <code>checkRead</code> method denies read access to the file
d190 1
a190 1
     *               <code>checkWrite</code> method denies write access to the file
d235 1
a235 2
        fd.incrementAndGetUseCount();
        this.path = name;
d241 1
a241 1
     * stream. </p>
d248 3
a250 1
        if (fd != null) return fd;
d259 1
a259 1
     * </code>position<code>} of the returned channel will always be equal to
d275 1
a275 12
                channel = FileChannelImpl.open(fd, path, true, rw, this);

                /*
                 * FileDescriptor could be shared by FileInputStream or
                 * FileOutputStream.
                 * Ensure that FD is GC'ed only when all the streams/channels
                 * are done using it.
                 * Increment fd's use count. Invoking the channel's close()
                 * method will result in decrementing the use count set for
                 * the channel.
                 */
                fd.incrementAndGetUseCount();
d283 1
a283 1
     * opened in read-write mode if the O_RDWR bit in <code>mode</code>
d285 1
a285 1
     * If the <code>name</code> refers to a directory, an IOException
d309 1
a309 1
     * integer in the range 0 to 255 (<code>0x00-0x0ff</code>). This
d312 2
a313 2
     * Although <code>RandomAccessFile</code> is not a subclass of
     * <code>InputStream</code>, this method behaves in exactly the same
d315 1
a315 1
     * <code>InputStream</code>.
d317 1
a317 1
     * @@return     the next byte of data, or <code>-1</code> if the end of the
d323 1
a323 8
        Object traceContext = IoTrace.fileReadBegin(path);
        int b = 0;
        try {
            b = fd.read();
        } finally {
            IoTrace.fileReadEnd(traceContext, b == -1 ? 0 : 1);
        }
        return b;
d335 1
a335 8
        Object traceContext = IoTrace.fileReadBegin(path);
        int bytesRead = 0;
        try {
            bytesRead = fd.readBytes(b, off, len);
        } finally {
            IoTrace.fileReadEnd(traceContext, bytesRead == -1 ? 0 : bytesRead);
        }
        return bytesRead;
d339 1
a339 1
     * Reads up to <code>len</code> bytes of data from this file into an
d343 2
a344 2
     * Although <code>RandomAccessFile</code> is not a subclass of
     * <code>InputStream</code>, this method behaves in exactly the
d346 1
a346 1
     * <code>InputStream</code>.
d349 1
a349 1
     * @@param      off   the start offset in array <code>b</code>
d353 1
a353 1
     *             <code>-1</code> if there is no more data because the end of
d358 4
a361 4
     * @@exception  NullPointerException If <code>b</code> is <code>null</code>.
     * @@exception  IndexOutOfBoundsException If <code>off</code> is negative,
     * <code>len</code> is negative, or <code>len</code> is greater than
     * <code>b.length - off</code>
d368 1
a368 1
     * Reads up to <code>b.length</code> bytes of data from this file
d372 2
a373 2
     * Although <code>RandomAccessFile</code> is not a subclass of
     * <code>InputStream</code>, this method behaves in exactly the
d375 1
a375 1
     * <code>InputStream</code>.
d379 1
a379 1
     *             <code>-1</code> if there is no more data because the end of
d384 1
a384 1
     * @@exception  NullPointerException If <code>b</code> is <code>null</code>.
d391 1
a391 1
     * Reads <code>b.length</code> bytes from this file into the byte
d407 1
a407 1
     * Reads exactly <code>len</code> bytes from this file into the byte
d431 1
a431 1
     * Attempts to skip over <code>n</code> bytes of input discarding the
d437 3
a439 3
     * file before <code>n</code> bytes have been skipped is only one
     * possibility. This method never throws an <code>EOFException</code>.
     * The actual number of bytes skipped is returned.  If <code>n</code>
d472 1
a472 1
     * @@param      b   the <code>byte</code> to be written.
d476 1
a476 8
        Object traceContext = IoTrace.fileWriteBegin(path);
        int bytesWritten = 0;
        try {
            fd.write(b);
            bytesWritten = 1;
        } finally {
            IoTrace.fileWriteEnd(traceContext, bytesWritten);
        }
d488 1
a488 8
        Object traceContext = IoTrace.fileWriteBegin(path);
        int bytesWritten = 0;
        try {
            fd.writeBytes(b, off, len);
            bytesWritten = len;
        } finally {
            IoTrace.fileWriteEnd(traceContext, bytesWritten);
        }
d492 1
a492 1
     * Writes <code>b.length</code> bytes from the specified byte array
d503 2
a504 2
     * Writes <code>len</code> bytes from the specified byte array
     * starting at offset <code>off</code> to this file.
d540 2
a541 2
     * @@exception  IOException  if <code>pos</code> is less than
     *                          <code>0</code> or if an I/O error occurs.
d543 6
a548 3
    public void seek(long pos) throws IOException
    {
        fd.seek(pos);
d566 1
a566 1
     * <code>length</code> method is greater than the <code>newLength</code>
d568 3
a570 3
     * offset as returned by the <code>getFilePointer</code> method is greater
     * than <code>newLength</code> then after this method returns the offset
     * will be equal to <code>newLength</code>.
d573 1
a573 1
     * <code>length</code> method is smaller than the <code>newLength</code>
a607 6
            /*
             * Decrement FD use count associated with the channel. The FD use
             * count is incremented whenever a new channel is obtained from
             * this stream.
             */
            fd.decrementAndGetUseCount();
d611 5
a615 6
        /*
         * Decrement FD use count associated with this stream.
         * The count got incremented by FileDescriptor during its construction.
         */
        fd.decrementAndGetUseCount();
        close0();
d624 1
a624 1
     * Reads a <code>boolean</code> from this file. This method reads a
d626 2
a627 2
     * A value of <code>0</code> represents
     * <code>false</code>. Any other value represents <code>true</code>.
d631 1
a631 1
     * @@return     the <code>boolean</code> value read.
d645 1
a645 1
     * If the byte read is <code>b</code>, where
d656 1
a656 1
     *             <code>byte</code>.
d691 2
a692 2
     * <code>b1</code> and <code>b2</code>, where each of the two values is
     * between <code>0</code> and <code>255</code>, inclusive, then the
d719 1
a719 1
     * <code>b1</code> and <code>b2</code>, where
d747 1
a747 1
     * <code>b1</code> and <code>b2</code>, where
d758 1
a758 1
     *                  <code>char</code>.
d774 2
a775 2
     * If the bytes read, in order, are <code>b1</code>,
     * <code>b2</code>, <code>b3</code>, and <code>b4</code>, where
d786 1
a786 1
     *             <code>int</code>.
d805 3
a807 3
     * <code>b1</code>, <code>b2</code>, <code>b3</code>,
     * <code>b4</code>, <code>b5</code>, <code>b6</code>,
     * <code>b7</code>, and <code>b8,</code> where:
d813 1
a813 1
     * <p><blockquote><pre>
d824 1
a824 1
     *             <code>long</code>.
d834 6
a839 6
     * Reads a <code>float</code> from this file. This method reads an
     * <code>int</code> value, starting at the current file pointer,
     * as if by the <code>readInt</code> method
     * and then converts that <code>int</code> to a <code>float</code>
     * using the <code>intBitsToFloat</code> method in class
     * <code>Float</code>.
d845 1
a845 1
     *             <code>float</code>.
d857 6
a862 6
     * Reads a <code>double</code> from this file. This method reads a
     * <code>long</code> value, starting at the current file pointer,
     * as if by the <code>readLong</code> method
     * and then converts that <code>long</code> to a <code>double</code>
     * using the <code>longBitsToDouble</code> method in
     * class <code>Double</code>.
d868 1
a868 1
     *             <code>double</code>.
d889 1
a889 1
     * (<code>'&#92;r'</code>), a newline character (<code>'&#92;n'</code>), a
d941 1
a941 1
     * <code>readUnsignedShort</code>. This value gives the number of
d963 4
a966 4
     * Writes a <code>boolean</code> to the file as a one-byte value. The
     * value <code>true</code> is written out as the value
     * <code>(byte)1</code>; the value <code>false</code> is written out
     * as the value <code>(byte)0</code>. The write starts at
d969 1
a969 1
     * @@param      v   a <code>boolean</code> value to be written.
d978 1
a978 1
     * Writes a <code>byte</code> to the file as a one-byte value. The
d981 1
a981 1
     * @@param      v   a <code>byte</code> value to be written.
d990 1
a990 1
     * Writes a <code>short</code> to the file as two bytes, high byte first.
d993 1
a993 1
     * @@param      v   a <code>short</code> to be written.
d1003 1
a1003 1
     * Writes a <code>char</code> to the file as a two-byte value, high
d1007 1
a1007 1
     * @@param      v   a <code>char</code> value to be written.
d1017 1
a1017 1
     * Writes an <code>int</code> to the file as four bytes, high byte first.
d1020 1
a1020 1
     * @@param      v   an <code>int</code> to be written.
d1032 1
a1032 1
     * Writes a <code>long</code> to the file as eight bytes, high byte first.
d1035 1
a1035 1
     * @@param      v   a <code>long</code> to be written.
d1051 3
a1053 3
     * Converts the float argument to an <code>int</code> using the
     * <code>floatToIntBits</code> method in class <code>Float</code>,
     * and then writes that <code>int</code> value to the file as a
d1057 1
a1057 1
     * @@param      v   a <code>float</code> value to be written.
d1066 3
a1068 3
     * Converts the double argument to a <code>long</code> using the
     * <code>doubleToLongBits</code> method in class <code>Double</code>,
     * and then writes that <code>long</code> value to the file as an
d1072 1
a1072 1
     * @@param      v   a <code>double</code> value to be written.
d1089 1
d1100 1
a1100 1
     * <code>writeChar</code> method. The write starts at the current
d1103 1
a1103 1
     * @@param      s   a <code>String</code> value to be written.
d1127 1
a1127 1
     * <code>writeShort</code> method giving the number of bytes to
@


1.7
log
@Merged IoTrace hooks.
@
text
@a234 1
        /*
a237 1
        */
@


1.6
log
@Updated copyright year.
@
text
@d2 1
a2 1
 * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.
d30 1
d66 3
d235 5
d242 1
d280 1
a280 1
                channel = FileChannelImpl.open(fd, true, rw, this);
d338 9
a346 3
    public int read() throws IOException
    {
        return fd.read();
d358 8
a365 1
        return fd.readBytes(b, off, len);
d505 9
a513 3
    public void write(int b) throws IOException
    {
        fd.write(b);
d524 9
a532 3
    private void writeBytes(byte b[], int off, int len) throws IOException
    {
        fd.writeBytes(b, off, len);
@


1.5
log
@Integrated OpenJDK 6 b21.
@
text
@d2 1
a2 1
 * Copyright (c) 1994, 2007, Oracle and/or its affiliates. All rights reserved.
@


1.4
log
@Integrated OpenJDK 6 b10.
@
text
@d2 1
a2 1
 * Copyright 1994-2007 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.3
log
@Merged OpenJDK 6 b10 whitespace and comment changes.
@
text
@d232 1
@


1.2
log
@Converted tabs to spaces.
@
text
@d33 13
a45 13
 * Instances of this class support both reading and writing to a 
 * random access file. A random access file behaves like a large 
 * array of bytes stored in the file system. There is a kind of cursor, 
 * or index into the implied array, called the <em>file pointer</em>; 
 * input operations read bytes starting at the file pointer and advance 
 * the file pointer past the bytes read. If the random access file is 
 * created in read/write mode, then output operations are also available; 
 * output operations write bytes starting at the file pointer and advance 
 * the file pointer past the bytes written. Output operations that write 
 * past the current end of the implied array cause the array to be 
 * extended. The file pointer can be read by the 
 * <code>getFilePointer</code> method and set by the <code>seek</code> 
 * method. 
d47 6
a52 6
 * It is generally true of all the reading routines in this class that 
 * if end-of-file is reached before the desired number of bytes has been 
 * read, an <code>EOFException</code> (which is a kind of 
 * <code>IOException</code>) is thrown. If any byte cannot be read for 
 * any reason other than end-of-file, an <code>IOException</code> other 
 * than <code>EOFException</code> is thrown. In particular, an 
a55 1
 * @@version 1.89, 05/05/07
d74 3
a76 3
     * Creates a random access file stream to read from, and optionally 
     * to write to, a file with the specified name. A new 
     * {@@link FileDescriptor} object is created to represent the 
d78 1
a78 1
     * 
d272 1
a272 1
                 * FileDescriptor could be shared by FileInputStream or 
d278 2
a279 2
                 * the channel. 
                 */ 
d313 3
a315 3
     * Reads a byte of data from this file. The byte is returned as an 
     * integer in the range 0 to 255 (<code>0x00-0x0ff</code>). This 
     * method blocks if no input is yet available. 
d317 3
a319 3
     * Although <code>RandomAccessFile</code> is not a subclass of 
     * <code>InputStream</code>, this method behaves in exactly the same 
     * way as the {@@link InputStream#read()} method of 
d324 1
a324 1
     * @@exception  IOException  if an I/O error occurs. Not thrown if  
d333 1
a333 1
     * Reads a sub array as a sequence of bytes. 
d345 3
a347 3
     * Reads up to <code>len</code> bytes of data from this file into an 
     * array of bytes. This method blocks until at least one byte of input 
     * is available. 
d349 3
a351 3
     * Although <code>RandomAccessFile</code> is not a subclass of 
     * <code>InputStream</code>, this method behaves in exactly the 
     * same way as the {@@link InputStream#read(byte[], int, int)} method of 
d365 2
a366 2
     * @@exception  IndexOutOfBoundsException If <code>off</code> is negative, 
     * <code>len</code> is negative, or <code>len</code> is greater than 
d374 3
a376 3
     * Reads up to <code>b.length</code> bytes of data from this file 
     * into an array of bytes. This method blocks until at least one byte 
     * of input is available. 
d378 3
a380 3
     * Although <code>RandomAccessFile</code> is not a subclass of 
     * <code>InputStream</code>, this method behaves in exactly the 
     * same way as the {@@link InputStream#read(byte[])} method of 
d397 5
a401 5
     * Reads <code>b.length</code> bytes from this file into the byte 
     * array, starting at the current file pointer. This method reads 
     * repeatedly from the file until the requested number of bytes are 
     * read. This method blocks until the requested number of bytes are 
     * read, the end of the stream is detected, or an exception is thrown. 
d406 1
a406 1
     * @@exception  IOException   if an I/O error occurs.       
d413 5
a417 5
     * Reads exactly <code>len</code> bytes from this file into the byte 
     * array, starting at the current file pointer. This method reads 
     * repeatedly from the file until the requested number of bytes are 
     * read. This method blocks until the requested number of bytes are 
     * read, the end of the stream is detected, or an exception is thrown. 
d437 2
a438 2
     * Attempts to skip over <code>n</code> bytes of input discarding the 
     * skipped bytes. 
d440 6
a445 6
     * 
     * This method may skip over some smaller number of bytes, possibly zero. 
     * This may result from any of a number of conditions; reaching end of 
     * file before <code>n</code> bytes have been skipped is only one 
     * possibility. This method never throws an <code>EOFException</code>. 
     * The actual number of bytes skipped is returned.  If <code>n</code> 
d455 1
a455 1
        long newpos; 
d475 1
a475 1
     * Writes the specified byte to this file. The write starts at 
d487 1
a487 1
     * Writes a sub array as a sequence of bytes. 
d500 2
a501 2
     * Writes <code>b.length</code> bytes from the specified byte array 
     * to this file, starting at the current file pointer. 
d507 1
a507 1
        writeBytes(b, 0, b.length); 
d511 2
a512 2
     * Writes <code>len</code> bytes from the specified byte array 
     * starting at offset <code>off</code> to this file. 
d526 1
a526 1
     * Returns the current offset in this file. 
d538 6
a543 6
     * Sets the file-pointer offset, measured from the beginning of this 
     * file, at which the next read or write occurs.  The offset may be 
     * set beyond the end of the file. Setting the offset beyond the end 
     * of the file does not change the file length.  The file length will 
     * change only by writing after the offset has been set beyond the end 
     * of the file. 
d545 2
a546 2
     * @@param      pos   the offset position, measured in bytes from the 
     *                   beginning of the file, at which to set the file 
d548 1
a548 1
     * @@exception  IOException  if <code>pos</code> is less than 
d592 3
a594 3
     * Closes this random access file stream and releases any system 
     * resources associated with the stream. A closed random access 
     * file cannot perform input or output operations and cannot be 
d629 1
a629 1
    
d636 6
a641 6
     * Reads a <code>boolean</code> from this file. This method reads a 
     * single byte from the file, starting at the current file pointer. 
     * A value of <code>0</code> represents 
     * <code>false</code>. Any other value represents <code>true</code>. 
     * This method blocks until the byte is read, the end of the stream 
     * is detected, or an exception is thrown. 
d655 4
a658 4
     * Reads a signed eight-bit value from this file. This method reads a 
     * byte from the file, starting from the current file pointer. 
     * If the byte read is <code>b</code>, where 
     * <code>0&nbsp;&lt;=&nbsp;b&nbsp;&lt;=&nbsp;255</code>, 
d664 2
a665 2
     * This method blocks until the byte is read, the end of the stream 
     * is detected, or an exception is thrown. 
d680 3
a682 3
     * Reads an unsigned eight-bit number from this file. This method reads 
     * a byte from this file, starting at the current file pointer, 
     * and returns that byte. 
d684 2
a685 2
     * This method blocks until the byte is read, the end of the stream 
     * is detected, or an exception is thrown. 
d700 5
a704 5
     * Reads a signed 16-bit number from this file. The method reads two 
     * bytes from this file, starting at the current file pointer. 
     * If the two bytes read, in order, are 
     * <code>b1</code> and <code>b2</code>, where each of the two values is 
     * between <code>0</code> and <code>255</code>, inclusive, then the 
d710 2
a711 2
     * This method blocks until the two bytes are read, the end of the 
     * stream is detected, or an exception is thrown. 
d728 5
a732 5
     * Reads an unsigned 16-bit number from this file. This method reads 
     * two bytes from the file, starting at the current file pointer. 
     * If the bytes read, in order, are 
     * <code>b1</code> and <code>b2</code>, where 
     * <code>0&nbsp;&lt;=&nbsp;b1, b2&nbsp;&lt;=&nbsp;255</code>, 
d738 2
a739 2
     * This method blocks until the two bytes are read, the end of the 
     * stream is detected, or an exception is thrown. 
d757 4
a760 4
     * bytes from the file, starting at the current file pointer. 
     * If the bytes read, in order, are 
     * <code>b1</code> and <code>b2</code>, where 
     * <code>0&nbsp;&lt;=&nbsp;b1,&nbsp;b2&nbsp;&lt;=&nbsp;255</code>, 
d766 2
a767 2
     * This method blocks until the two bytes are read, the end of the 
     * stream is detected, or an exception is thrown. 
d784 2
a785 2
     * Reads a signed 32-bit integer from this file. This method reads 4 
     * bytes from the file, starting at the current file pointer. 
d787 2
a788 2
     * <code>b2</code>, <code>b3</code>, and <code>b4</code>, where 
     * <code>0&nbsp;&lt;=&nbsp;b1, b2, b3, b4&nbsp;&lt;=&nbsp;255</code>, 
d794 2
a795 2
     * This method blocks until the four bytes are read, the end of the 
     * stream is detected, or an exception is thrown. 
d815 4
a818 4
     * bytes from the file, starting at the current file pointer. 
     * If the bytes read, in order, are 
     * <code>b1</code>, <code>b2</code>, <code>b3</code>, 
     * <code>b4</code>, <code>b5</code>, <code>b6</code>, 
d832 2
a833 2
     * This method blocks until the eight bytes are read, the end of the 
     * stream is detected, or an exception is thrown. 
d846 6
a851 6
     * Reads a <code>float</code> from this file. This method reads an 
     * <code>int</code> value, starting at the current file pointer, 
     * as if by the <code>readInt</code> method 
     * and then converts that <code>int</code> to a <code>float</code> 
     * using the <code>intBitsToFloat</code> method in class 
     * <code>Float</code>. 
d853 2
a854 2
     * This method blocks until the four bytes are read, the end of the 
     * stream is detected, or an exception is thrown. 
d869 5
a873 5
     * Reads a <code>double</code> from this file. This method reads a 
     * <code>long</code> value, starting at the current file pointer, 
     * as if by the <code>readLong</code> method 
     * and then converts that <code>long</code> to a <code>double</code> 
     * using the <code>longBitsToDouble</code> method in 
d876 2
a877 2
     * This method blocks until the eight bytes are read, the end of the 
     * stream is detected, or an exception is thrown. 
d893 1
a893 1
     * reads bytes from the file, starting at the current file pointer, 
d946 1
a946 1
     * Reads in a string from this file. The string has been encoded 
d949 1
a949 1
     * format. 
d951 3
a953 3
     * The first two bytes are read, starting from the current file 
     * pointer, as if by 
     * <code>readUnsignedShort</code>. This value gives the number of 
d955 3
a957 3
     * the length of the resulting string. The following bytes are then 
     * interpreted as bytes encoding characters in the modified UTF-8 format 
     * and are converted into characters. 
d959 2
a960 2
     * This method blocks until all the bytes are read, the end of the 
     * stream is detected, or an exception is thrown. 
d966 1
a966 1
     * @@exception  UTFDataFormatException  if the bytes do not represent 
d975 4
a978 4
     * Writes a <code>boolean</code> to the file as a one-byte value. The 
     * value <code>true</code> is written out as the value 
     * <code>(byte)1</code>; the value <code>false</code> is written out 
     * as the value <code>(byte)0</code>. The write starts at 
d990 1
a990 1
     * Writes a <code>byte</code> to the file as a one-byte value. The 
d1002 1
a1002 1
     * Writes a <code>short</code> to the file as two bytes, high byte first. 
d1016 1
a1016 1
     * byte first. The write starts at the current position of the 
d1029 1
a1029 1
     * Writes an <code>int</code> to the file as four bytes, high byte first. 
d1044 1
a1044 1
     * Writes a <code>long</code> to the file as eight bytes, high byte first. 
d1063 4
a1066 4
     * Converts the float argument to an <code>int</code> using the 
     * <code>floatToIntBits</code> method in class <code>Float</code>, 
     * and then writes that <code>int</code> value to the file as a 
     * four-byte quantity, high byte first. The write starts at the 
d1078 4
a1081 4
     * Converts the double argument to a <code>long</code> using the 
     * <code>doubleToLongBits</code> method in class <code>Double</code>, 
     * and then writes that <code>long</code> value to the file as an 
     * eight-byte quantity, high byte first. The write starts at the current 
d1093 3
a1095 3
     * Writes the string to the file as a sequence of bytes. Each 
     * character in the string is written out, in sequence, by discarding 
     * its high eight bits. The write starts at the current position of 
d1109 3
a1111 3
     * Writes a string to the file as a sequence of characters. Each 
     * character is written to the data output stream as if by the 
     * <code>writeChar</code> method. The write starts at the current 
d1134 1
a1134 1
     * encoding in a machine-independent manner. 
d1136 7
a1142 7
     * First, two bytes are written to the file, starting at the 
     * current file pointer, as if by the 
     * <code>writeShort</code> method giving the number of bytes to 
     * follow. This value is the number of bytes actually written out, 
     * not the length of the string. Following the length, each character 
     * of the string is output, in sequence, using the modified UTF-8 encoding 
     * for each character. 
@


1.1
log
@Integrated OpenJDK's java.io.FileDescriptor, FileInputStream, FileOutputStream & RandomAccessFile.
@
text
@d117 1
a117 1
	throws FileNotFoundException
d199 1
a199 1
	throws FileNotFoundException
d201 28
a228 28
	String name = (file != null ? file.getPath() : null);
	int imode = -1;
	if (mode.equals("r"))
	    imode = O_RDONLY;
	else if (mode.startsWith("rw")) {
	    imode = O_RDWR;
	    rw = true;
	    if (mode.length() > 2) {
		if (mode.equals("rws"))
		    imode |= O_SYNC;
		else if (mode.equals("rwd"))
		    imode |= O_DSYNC;
		else
		    imode = -1;
	    }
	}
	if (imode < 0)
	    throw new IllegalArgumentException("Illegal mode \"" + mode
					       + "\" must be one of "
					       + "\"r\", \"rw\", \"rws\","
					       + " or \"rwd\"");
	SecurityManager security = System.getSecurityManager();
	if (security != null) {
	    security.checkRead(name);
	    if (rw) {
		security.checkWrite(name);
	    }
	}
d232 2
a233 2
	fd = new FileDescriptor();
	open(name, imode);
d245 2
a246 2
	if (fd != null) return fd;
	throw new IOException();
d268 17
a284 17
	synchronized (this) {
	    if (channel == null) {
		channel = FileChannelImpl.open(fd, true, rw, this);

		/*
	 	 * FileDescriptor could be shared by FileInputStream or 
		 * FileOutputStream.
	 	 * Ensure that FD is GC'ed only when all the streams/channels
		 * are done using it.
		 * Increment fd's use count. Invoking the channel's close()
		 * method will result in decrementing the use count set for
		 * the channel. 
		 */ 
		fd.incrementAndGetUseCount();
	    }
	    return channel;
	}
d299 1
a299 1
	throws FileNotFoundException
d301 8
a308 8
	if ((mode & O_RDWR) == O_RDWR)
	{
	    fd.openReadWrite(name);
	}
	else
	{
	    fd.openReadOnly(name);
	}
d330 1
a330 1
	return fd.read();
d342 1
a342 1
	return fd.readBytes(b, off, len);
d371 1
a371 1
	return readBytes(b, off, len);
d394 1
a394 1
	return readBytes(b, 0, b.length);
d410 1
a410 1
	readFully(b, 0, b.length);
d429 6
a434 6
	do {
	    int count = this.read(b, off + n, len - n);
	    if (count < 0)
		throw new EOFException();
	    n += count;
	} while (n < len);
d455 2
a456 2
	long len;
	long newpos; 
d458 10
a467 10
	if (n <= 0) {
	    return 0;
	}
	pos = getFilePointer();
	len = length();
	newpos = pos + n;
	if (newpos > len) {
	    newpos = len;
	}
	seek(newpos);
d469 2
a470 2
	/* return the actual number of bytes skipped */
	return (int) (newpos - pos);
d484 1
a484 1
	fd.write(b);
d497 1
a497 1
	fd.writeBytes(b, off, len);
d508 1
a508 1
	writeBytes(b, 0, b.length); 
d521 1
a521 1
	writeBytes(b, off, len);
d535 1
a535 1
	return fd.getFilePointer();
d554 1
a554 1
	fd.seek(pos);
d565 1
a565 1
	return fd.length();
d589 1
a589 1
	fd.setLength(newLength);
d607 2
a608 2
	synchronized (closeLock) {
	    if (closed) {
d612 10
a621 10
	}
	if (channel != null) {
	    /*
	     * Decrement FD use count associated with the channel. The FD use
	     * count is incremented whenever a new channel is obtained from
	     * this stream.
	     */
	    fd.decrementAndGetUseCount();
	    channel.close();
	}
d625 1
a625 1
	 * The count got incremented by FileDescriptor during its construction.
d627 2
a628 2
	fd.decrementAndGetUseCount();
	close0();
d649 4
a652 4
	int ch = this.read();
	if (ch < 0)
	    throw new EOFException();
	return (ch != 0);
d674 4
a677 4
	int ch = this.read();
	if (ch < 0)
	    throw new EOFException();
	return (byte)(ch);
d694 4
a697 4
	int ch = this.read();
	if (ch < 0)
	    throw new EOFException();
	return ch;
d721 5
a725 5
	int ch1 = this.read();
	int ch2 = this.read();
	if ((ch1 | ch2) < 0)
	    throw new EOFException();
	return (short)((ch1 << 8) + (ch2 << 0));
d749 5
a753 5
	int ch1 = this.read();
	int ch2 = this.read();
	if ((ch1 | ch2) < 0)
	    throw new EOFException();
	return (ch1 << 8) + (ch2 << 0);
d771 1
a771 1
     *			<code>char</code>.
d777 5
a781 5
	int ch1 = this.read();
	int ch2 = this.read();
	if ((ch1 | ch2) < 0)
	    throw new EOFException();
	return (char)((ch1 << 8) + (ch2 << 0));
d805 7
a811 7
	int ch1 = this.read();
	int ch2 = this.read();
	int ch3 = this.read();
	int ch4 = this.read();
	if ((ch1 | ch2 | ch3 | ch4) < 0)
	    throw new EOFException();
	return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));
d843 1
a843 1
	return ((long)(readInt()) << 32) + (readInt() & 0xFFFFFFFFL);
d866 1
a866 1
	return Float.intBitsToFloat(readInt());
d889 1
a889 1
	return Double.longBitsToDouble(readLong());
d917 27
a943 27
	StringBuffer input = new StringBuffer();
	int c = -1;
	boolean eol = false;

	while (!eol) {
	    switch (c = read()) {
	    case -1:
	    case '\n':
		eol = true;
		break;
	    case '\r':
		eol = true;
		long cur = getFilePointer();
		if ((read()) != '\n') {
		    seek(cur);
		}
		break;
	    default:
		input.append((char)c);
		break;
	    }
	}

	if ((c == -1) && (input.length() == 0)) {
	    return null;
	}
	return input.toString();
d972 1
a972 1
	return DataInputStream.readUTF(this);
d986 2
a987 2
	write(v ? 1 : 0);
	//written++;
d998 2
a999 2
	write(v);
	//written++;
d1010 3
a1012 3
	write((v >>> 8) & 0xFF);
	write((v >>> 0) & 0xFF);
	//written += 2;
d1024 3
a1026 3
	write((v >>> 8) & 0xFF);
	write((v >>> 0) & 0xFF);
	//written += 2;
d1037 5
a1041 5
	write((v >>> 24) & 0xFF);
	write((v >>> 16) & 0xFF);
	write((v >>>  8) & 0xFF);
	write((v >>>  0) & 0xFF);
	//written += 4;
d1052 9
a1060 9
	write((int)(v >>> 56) & 0xFF);
	write((int)(v >>> 48) & 0xFF);
	write((int)(v >>> 40) & 0xFF);
	write((int)(v >>> 32) & 0xFF);
	write((int)(v >>> 24) & 0xFF);
	write((int)(v >>> 16) & 0xFF);
	write((int)(v >>>  8) & 0xFF);
	write((int)(v >>>  0) & 0xFF);
	//written += 8;
d1075 1
a1075 1
	writeInt(Float.floatToIntBits(v));
d1090 1
a1090 1
	writeLong(Double.doubleToLongBits(v));
d1103 4
a1106 4
	int len = s.length();
	byte[] b = new byte[len];
	s.getBytes(0, len, b, 0);
	writeBytes(b, 0, len);
d1120 10
a1129 10
	int clen = s.length();
	int blen = 2*clen;
	byte[] b = new byte[blen];
	char[] c = new char[clen];
	s.getChars(0, clen, c, 0);
	for (int i = 0, j = 0; i < clen; i++) {
	    b[j++] = (byte)(c[i] >>> 8);
	    b[j++] = (byte)(c[i] >>> 0);
	}
	writeBytes(b, 0, blen);
d1154 1
a1154 1
	fd.close();
@

