head	1.8;
access;
symbols
	v8_1_5717_0:1.8
	v8_1:1.8.0.4
	v8_0_5449_1:1.8
	v8_0_5449_0:1.8
	v8_0:1.8.0.2
	v7_4_5196_0:1.7
	v7_4:1.7.0.2
	v7_3:1.6.0.8
	v7_2_4630_6:1.6
	v7_2_4630_5:1.6
	v7_2_4630_4:1.6
	v7_2_4630_3:1.6
	v7_2_4630_2:1.6
	v0_46_0_4:1.5
	v7_2_4630_1:1.6
	v7_2:1.6.0.6
	v7_1_4532_2:1.6
	v7_1_4532_1:1.6
	v7_1_4532_0:1.6
	v7_1:1.6.0.4
	v7_0_4335_3:1.6
	v7_0_4335_2:1.6
	v7_0_4335_1:1.6
	v0_46_0_2:1.5
	v7_0_4335_0:1.6
	v7_0:1.6.0.2
	v0_40_0_6:1.2
	v0_40_0_5:1.2
	v0_46_0_1:1.5
	v0_46_0_0:1.5
	v0_46:1.5.0.2
	v0_44_0_6:1.2
	v0_44_0_5:1.2
	v0_44_0_4:1.2
	v0_44_0_3:1.2
	v0_44_0_2:1.2
	v0_42_0_7:1.2
	v0_44_0_1:1.2
	v0_44_0_0:1.2
	v0_44:1.2.0.6
	v0_42_0_6:1.2
	v0_42_0_5:1.2
	v0_42_0_4:1.2
	v0_42_0_3:1.2
	v0_42_0_2:1.2
	v0_42_0_1:1.2
	v0_42_0_0:1.2
	v0_42:1.2.0.4
	v0_40_0_3:1.2
	v0_40_0_2:1.2
	v0_40_0_1:1.2
	v0_40_0_0:1.2
	v0_40:1.2.0.2;
locks; strict;
comment	@# @;


1.8
date	2014.05.19.12.43.39;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.12.07.55.57;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.19.12.04.11;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.24.16.40.23;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.23.09.39.49;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.23.07.30.30;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.02.10.44.05;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.02.09.04.06;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.8
log
@First part of OpenJDK 8 integration.
@
text
@/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import ikvm.internal.CallerID;
import sun.security.util.Debug;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;

/**
 * <p> The AccessController class is used for access control operations
 * and decisions.
 *
 * <p> More specifically, the AccessController class is used for
 * three purposes:
 *
 * <ul>
 * <li> to decide whether an access to a critical system
 * resource is to be allowed or denied, based on the security policy
 * currently in effect,
 * <li>to mark code as being "privileged", thus affecting subsequent
 * access determinations, and
 * <li>to obtain a "snapshot" of the current calling context so
 * access-control decisions from a different context can be made with
 * respect to the saved context. </ul>
 *
 * <p> The {@@link #checkPermission(Permission) checkPermission} method
 * determines whether the access request indicated by a specified
 * permission should be granted or denied. A sample call appears
 * below. In this example, {@@code checkPermission} will determine
 * whether or not to grant "read" access to the file named "testFile" in
 * the "/temp" directory.
 *
 * <pre>
 *
 * FilePermission perm = new FilePermission("/temp/testFile", "read");
 * AccessController.checkPermission(perm);
 *
 * </pre>
 *
 * <p> If a requested access is allowed,
 * {@@code checkPermission} returns quietly. If denied, an
 * AccessControlException is
 * thrown. AccessControlException can also be thrown if the requested
 * permission is of an incorrect type or contains an invalid value.
 * Such information is given whenever possible.
 *
 * Suppose the current thread traversed m callers, in the order of caller 1
 * to caller 2 to caller m. Then caller m invoked the
 * {@@code checkPermission} method.
 * The {@@code checkPermission} method determines whether access
 * is granted or denied based on the following algorithm:
 *
 *  <pre> {@@code
 * for (int i = m; i > 0; i--) {
 *
 *     if (caller i's domain does not have the permission)
 *         throw AccessControlException
 *
 *     else if (caller i is marked as privileged) {
 *         if (a context was specified in the call to doPrivileged)
 *             context.checkPermission(permission)
 *         if (limited permissions were specified in the call to doPrivileged) {
 *             for (each limited permission) {
 *                 if (the limited permission implies the requested permission)
 *                     return;
 *             }
 *         } else
 *             return;
 *     }
 * }
 *
 * // Next, check the context inherited when the thread was created.
 * // Whenever a new thread is created, the AccessControlContext at
 * // that time is stored and associated with the new thread, as the
 * // "inherited" context.
 *
 * inheritedContext.checkPermission(permission);
 * }</pre>
 *
 * <p> A caller can be marked as being "privileged"
 * (see {@@link #doPrivileged(PrivilegedAction) doPrivileged} and below).
 * When making access control decisions, the {@@code checkPermission}
 * method stops checking if it reaches a caller that
 * was marked as "privileged" via a {@@code doPrivileged}
 * call without a context argument (see below for information about a
 * context argument). If that caller's domain has the
 * specified permission and at least one limiting permission argument (if any)
 * implies the requested permission, no further checking is done and
 * {@@code checkPermission}
 * returns quietly, indicating that the requested access is allowed.
 * If that domain does not have the specified permission, an exception
 * is thrown, as usual. If the caller's domain had the specified permission
 * but it was not implied by any limiting permission arguments given in the call
 * to {@@code doPrivileged} then the permission checking continues
 * until there are no more callers or another {@@code doPrivileged}
 * call matches the requested permission and returns normally.
 *
 * <p> The normal use of the "privileged" feature is as follows. If you
 * don't need to return a value from within the "privileged" block, do
 * the following:
 *
 *  <pre> {@@code
 * somemethod() {
 *     ...normal code here...
 *     AccessController.doPrivileged(new PrivilegedAction<Void>() {
 *         public Void run() {
 *             // privileged code goes here, for example:
 *             System.loadLibrary("awt");
 *             return null; // nothing to return
 *         }
 *     });
 *     ...normal code here...
 * }}</pre>
 *
 * <p>
 * PrivilegedAction is an interface with a single method, named
 * {@@code run}.
 * The above example shows creation of an implementation
 * of that interface; a concrete implementation of the
 * {@@code run} method is supplied.
 * When the call to {@@code doPrivileged} is made, an
 * instance of the PrivilegedAction implementation is passed
 * to it. The {@@code doPrivileged} method calls the
 * {@@code run} method from the PrivilegedAction
 * implementation after enabling privileges, and returns the
 * {@@code run} method's return value as the
 * {@@code doPrivileged} return value (which is
 * ignored in this example).
 *
 * <p> If you need to return a value, you can do something like the following:
 *
 *  <pre> {@@code
 * somemethod() {
 *     ...normal code here...
 *     String user = AccessController.doPrivileged(
 *         new PrivilegedAction<String>() {
 *         public String run() {
 *             return System.getProperty("user.name");
 *             }
 *         });
 *     ...normal code here...
 * }}</pre>
 *
 * <p>If the action performed in your {@@code run} method could
 * throw a "checked" exception (those listed in the {@@code throws} clause
 * of a method), then you need to use the
 * {@@code PrivilegedExceptionAction} interface instead of the
 * {@@code PrivilegedAction} interface:
 *
 *  <pre> {@@code
 * somemethod() throws FileNotFoundException {
 *     ...normal code here...
 *     try {
 *         FileInputStream fis = AccessController.doPrivileged(
 *         new PrivilegedExceptionAction<FileInputStream>() {
 *             public FileInputStream run() throws FileNotFoundException {
 *                 return new FileInputStream("someFile");
 *             }
 *         });
 *     } catch (PrivilegedActionException e) {
 *         // e.getException() should be an instance of FileNotFoundException,
 *         // as only "checked" exceptions will be "wrapped" in a
 *         // PrivilegedActionException.
 *         throw (FileNotFoundException) e.getException();
 *     }
 *     ...normal code here...
 *  }}</pre>
 *
 * <p> Be *very* careful in your use of the "privileged" construct, and
 * always remember to make the privileged code section as small as possible.
 * You can pass {@@code Permission} arguments to further limit the
 * scope of the "privilege" (see below).
 *
 *
 * <p> Note that {@@code checkPermission} always performs security checks
 * within the context of the currently executing thread.
 * Sometimes a security check that should be made within a given context
 * will actually need to be done from within a
 * <i>different</i> context (for example, from within a worker thread).
 * The {@@link #getContext() getContext} method and
 * AccessControlContext class are provided
 * for this situation. The {@@code getContext} method takes a "snapshot"
 * of the current calling context, and places
 * it in an AccessControlContext object, which it returns. A sample call is
 * the following:
 *
 * <pre>
 *
 * AccessControlContext acc = AccessController.getContext()
 *
 * </pre>
 *
 * <p>
 * AccessControlContext itself has a {@@code checkPermission} method
 * that makes access decisions based on the context <i>it</i> encapsulates,
 * rather than that of the current execution thread.
 * Code within a different context can thus call that method on the
 * previously-saved AccessControlContext object. A sample call is the
 * following:
 *
 * <pre>
 *
 * acc.checkPermission(permission)
 *
 * </pre>
 *
 * <p> There are also times where you don't know a priori which permissions
 * to check the context against. In these cases you can use the
 * doPrivileged method that takes a context. You can also limit the scope
 * of the privileged code by passing additional {@@code Permission}
 * parameters.
 *
 *  <pre> {@@code
 * somemethod() {
 *     AccessController.doPrivileged(new PrivilegedAction<Object>() {
 *         public Object run() {
 *             // Code goes here. Any permission checks within this
 *             // run method will require that the intersection of the
 *             // caller's protection domain and the snapshot's
 *             // context have the desired permission. If a requested
 *             // permission is not implied by the limiting FilePermission
 *             // argument then checking of the thread continues beyond the
 *             // caller of doPrivileged.
 *         }
 *     }, acc, new FilePermission("/temp/*", read));
 *     ...normal code here...
 * }}</pre>
 * <p> Passing a limiting {@@code Permission} argument of an instance of
 * {@@code AllPermission} is equivalent to calling the equivalent
 * {@@code doPrivileged} method without limiting {@@code Permission}
 * arguments. Passing a zero length array of {@@code Permission} disables
 * the code privileges so that checking always continues beyond the caller of
 * that {@@code doPrivileged} method.
 *
 * @@see AccessControlContext
 *
 * @@author Li Gong
 * @@author Roland Schemers
 */

public final class AccessController {

    @@cli.System.ThreadStaticAttribute.Annotation
    private static PrivilegedElement privileged_stack_top;

    @@ikvm.lang.Internal
    public static final class LazyContext {
        LazyContext parent;
        CallerID callerID;
        AccessControlContext context;
        final cli.System.Diagnostics.StackTrace stackTrace = new cli.System.Diagnostics.StackTrace(1);
    }

    @@ikvm.lang.Internal
    public static Object getLazyContext(Object parent) {
        if (!(parent instanceof LazyContext)) {
            // we don't have an optimized path if the current thread already has an AccessControlContext
            // instead of a LazyContext, because this is not worth it
            return getContext();
        }
        LazyContext lc = new LazyContext();
        lc.parent = (LazyContext)parent;
        if (privileged_stack_top != null) {
            lc.callerID = privileged_stack_top.callerID;
            lc.context = privileged_stack_top.context;
        }
        return lc;
    }

    private static final class PrivilegedElement {
        CallerID callerID;
        AccessControlContext context;
    }

    private static Object doPrivileged(Object action, AccessControlContext context, CallerID callerID) {
        PrivilegedElement savedPrivilegedElement = privileged_stack_top;
        try {
            PrivilegedElement pi = new PrivilegedElement();
            pi.callerID = callerID;
            pi.context = context;
            privileged_stack_top = pi;
            try {
                if (action instanceof PrivilegedAction) {
                    return ((PrivilegedAction)action).run();
                } else {
                    return ((PrivilegedExceptionAction)action).run();
                }
            } catch (Exception x) {
                if (!(x instanceof RuntimeException)) {
                    sun.misc.Unsafe.getUnsafe().throwException(new PrivilegedActionException(x));
                }
                throw (RuntimeException)x;
            }
        } finally {
            privileged_stack_top = savedPrivilegedElement;
        }
    }

    /**
     * Don't allow anyone to instantiate an AccessController
     */
    private AccessController() { }

    /**
     * Performs the specified {@@code PrivilegedAction} with privileges
     * enabled. The action is performed with <i>all</i> of the permissions
     * possessed by the caller's protection domain.
     *
     * <p> If the action's {@@code run} method throws an (unchecked)
     * exception, it will propagate through this method.
     *
     * <p> Note that any DomainCombiner associated with the current
     * AccessControlContext will be ignored while the action is performed.
     *
     * @@param <T> the type of the value returned by the PrivilegedAction's
     *                  {@@code run} method.
     *
     * @@param action the action to be performed.
     *
     * @@return the value returned by the action's {@@code run} method.
     *
     * @@exception NullPointerException if the action is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction,AccessControlContext)
     * @@see #doPrivileged(PrivilegedExceptionAction)
     * @@see #doPrivilegedWithCombiner(PrivilegedAction)
     * @@see java.security.DomainCombiner
     */

    @@CallerSensitive
    public static <T> T doPrivileged(PrivilegedAction<T> action) {
        return (T)doPrivileged(action, null, CallerID.getCallerID());
    }

    /**
     * Performs the specified {@@code PrivilegedAction} with privileges
     * enabled. The action is performed with <i>all</i> of the permissions
     * possessed by the caller's protection domain.
     *
     * <p> If the action's {@@code run} method throws an (unchecked)
     * exception, it will propagate through this method.
     *
     * <p> This method preserves the current AccessControlContext's
     * DomainCombiner (which may be null) while the action is performed.
     *
     * @@param <T> the type of the value returned by the PrivilegedAction's
     *                  {@@code run} method.
     *
     * @@param action the action to be performed.
     *
     * @@return the value returned by the action's {@@code run} method.
     *
     * @@exception NullPointerException if the action is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction)
     * @@see java.security.DomainCombiner
     *
     * @@since 1.6
     */
    @@CallerSensitive
    public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action) {
        AccessControlContext acc = getStackAccessControlContext();
        if (acc == null) {
            return AccessController.doPrivileged(action);
        }
        DomainCombiner dc = acc.getAssignedCombiner();
        return AccessController.doPrivileged(action,
                                             preserveCombiner(dc, Reflection.getCallerClass()));
    }


    /**
     * Performs the specified {@@code PrivilegedAction} with privileges
     * enabled and restricted by the specified {@@code AccessControlContext}.
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified {@@code AccessControlContext}.
     * <p>
     * If the action's {@@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     * <p>
     * If a security manager is installed and the specified
     * {@@code AccessControlContext} was not created by system code and the
     * caller's {@@code ProtectionDomain} has not been granted the
     * {@@literal "createAccessControlContext"}
     * {@@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @@param <T> the type of the value returned by the PrivilegedAction's
     *                  {@@code run} method.
     * @@param action the action to be performed.
     * @@param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@@code null}, then no additional restriction is applied.
     *
     * @@return the value returned by the action's {@@code run} method.
     *
     * @@exception NullPointerException if the action is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction)
     * @@see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     */
    @@CallerSensitive
    public static <T> T doPrivileged(PrivilegedAction<T> action,
                                     AccessControlContext context) {
        return (T)doPrivileged(action, context, CallerID.getCallerID());
    }


    /**
     * Performs the specified {@@code PrivilegedAction} with privileges
     * enabled and restricted by the specified
     * {@@code AccessControlContext} and with a privilege scope limited
     * by specified {@@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@@code AccessControlContext}.
     * <p>
     * If the action's {@@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     * <p>
     * If a security manager is installed and the specified
     * {@@code AccessControlContext} was not created by system code and the
     * caller's {@@code ProtectionDomain} has not been granted the
     * {@@literal "createAccessControlContext"}
     * {@@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @@param <T> the type of the value returned by the PrivilegedAction's
     *                  {@@code run} method.
     * @@param action the action to be performed.
     * @@param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@@code null},
     *                then no additional restriction is applied.
     * @@param perms the {@@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @@return the value returned by the action's {@@code run} method.
     *
     * @@throws NullPointerException if action or perms or any element of
     *         perms is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction)
     * @@see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     *
     * @@since 1.8
     */
    @@CallerSensitive
    public static <T> T doPrivileged(PrivilegedAction<T> action,
        AccessControlContext context, Permission... perms) {

        AccessControlContext parent = getContext();
        if (perms == null) {
            throw new NullPointerException("null permissions parameter");
        }
        Class <?> caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(null,
            caller, parent, context, perms));
    }


    /**
     * Performs the specified {@@code PrivilegedAction} with privileges
     * enabled and restricted by the specified
     * {@@code AccessControlContext} and with a privilege scope limited
     * by specified {@@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@@code AccessControlContext}.
     * <p>
     * If the action's {@@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     *
     * <p> This method preserves the current AccessControlContext's
     * DomainCombiner (which may be null) while the action is performed.
     * <p>
     * If a security manager is installed and the specified
     * {@@code AccessControlContext} was not created by system code and the
     * caller's {@@code ProtectionDomain} has not been granted the
     * {@@literal "createAccessControlContext"}
     * {@@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @@param <T> the type of the value returned by the PrivilegedAction's
     *                  {@@code run} method.
     * @@param action the action to be performed.
     * @@param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@@code null},
     *                then no additional restriction is applied.
     * @@param perms the {@@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @@return the value returned by the action's {@@code run} method.
     *
     * @@throws NullPointerException if action or perms or any element of
     *         perms is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction)
     * @@see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     * @@see java.security.DomainCombiner
     *
     * @@since 1.8
     */
    @@CallerSensitive
    public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action,
        AccessControlContext context, Permission... perms) {

        AccessControlContext parent = getContext();
        DomainCombiner dc = parent.getCombiner();
        if (dc == null && context != null) {
            dc = context.getCombiner();
        }
        if (perms == null) {
            throw new NullPointerException("null permissions parameter");
        }
        Class <?> caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(dc, caller,
            parent, context, perms));
    }

    /**
     * Performs the specified {@@code PrivilegedExceptionAction} with
     * privileges enabled.  The action is performed with <i>all</i> of the
     * permissions possessed by the caller's protection domain.
     *
     * <p> If the action's {@@code run} method throws an <i>unchecked</i>
     * exception, it will propagate through this method.
     *
     * <p> Note that any DomainCombiner associated with the current
     * AccessControlContext will be ignored while the action is performed.
     *
     * @@param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@@code run} method.
     *
     * @@param action the action to be performed
     *
     * @@return the value returned by the action's {@@code run} method
     *
     * @@exception PrivilegedActionException if the specified action's
     *         {@@code run} method threw a <i>checked</i> exception
     * @@exception NullPointerException if the action is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction)
     * @@see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     * @@see #doPrivilegedWithCombiner(PrivilegedExceptionAction)
     * @@see java.security.DomainCombiner
     */
    @@CallerSensitive
    public static <T> T
        doPrivileged(PrivilegedExceptionAction<T> action)
        throws PrivilegedActionException {
        return (T)doPrivileged(action, null, CallerID.getCallerID());
    }


    /**
     * Performs the specified {@@code PrivilegedExceptionAction} with
     * privileges enabled.  The action is performed with <i>all</i> of the
     * permissions possessed by the caller's protection domain.
     *
     * <p> If the action's {@@code run} method throws an <i>unchecked</i>
     * exception, it will propagate through this method.
     *
     * <p> This method preserves the current AccessControlContext's
     * DomainCombiner (which may be null) while the action is performed.
     *
     * @@param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@@code run} method.
     *
     * @@param action the action to be performed.
     *
     * @@return the value returned by the action's {@@code run} method
     *
     * @@exception PrivilegedActionException if the specified action's
     *         {@@code run} method threw a <i>checked</i> exception
     * @@exception NullPointerException if the action is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction)
     * @@see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
     * @@see java.security.DomainCombiner
     *
     * @@since 1.6
     */
    @@CallerSensitive
    public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action)
        throws PrivilegedActionException
    {
        AccessControlContext acc = getStackAccessControlContext();
        if (acc == null) {
            return AccessController.doPrivileged(action);
        }
        DomainCombiner dc = acc.getAssignedCombiner();
        return AccessController.doPrivileged(action,
                                             preserveCombiner(dc, Reflection.getCallerClass()));
    }

    /**
     * preserve the combiner across the doPrivileged call
     */
    private static AccessControlContext preserveCombiner(DomainCombiner combiner,
                                                         Class<?> caller)
    {
        return createWrapper(combiner, caller, null, null, null);
    }

    /**
     * Create a wrapper to contain the limited privilege scope data.
     */
    private static AccessControlContext
        createWrapper(DomainCombiner combiner, Class<?> caller,
                      AccessControlContext parent, AccessControlContext context,
                      Permission[] perms)
    {
        ProtectionDomain callerPD = getCallerPD(caller);
        // check if caller is authorized to create context
        if (context != null && !context.isAuthorized() &&
            System.getSecurityManager() != null &&
            !callerPD.impliesCreateAccessControlContext())
        {
            ProtectionDomain nullPD = new ProtectionDomain(null, null);
            return new AccessControlContext(new ProtectionDomain[] { nullPD });
        } else {
            return new AccessControlContext(callerPD, combiner, parent,
                                            context, perms);
        }
    }

    private static ProtectionDomain getCallerPD(final Class <?> caller) {
        ProtectionDomain callerPd = doPrivileged
            (new PrivilegedAction<ProtectionDomain>() {
            public ProtectionDomain run() {
                return caller.getProtectionDomain();
            }
        });

        return callerPd;
    }

    /**
     * Performs the specified {@@code PrivilegedExceptionAction} with
     * privileges enabled and restricted by the specified
     * {@@code AccessControlContext}.  The action is performed with the
     * intersection of the permissions possessed by the caller's
     * protection domain, and those possessed by the domains represented by the
     * specified {@@code AccessControlContext}.
     * <p>
     * If the action's {@@code run} method throws an <i>unchecked</i>
     * exception, it will propagate through this method.
     * <p>
     * If a security manager is installed and the specified
     * {@@code AccessControlContext} was not created by system code and the
     * caller's {@@code ProtectionDomain} has not been granted the
     * {@@literal "createAccessControlContext"}
     * {@@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @@param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@@code run} method.
     * @@param action the action to be performed
     * @@param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@@code null}, then no additional restriction is applied.
     *
     * @@return the value returned by the action's {@@code run} method
     *
     * @@exception PrivilegedActionException if the specified action's
     *         {@@code run} method threw a <i>checked</i> exception
     * @@exception NullPointerException if the action is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction)
     * @@see #doPrivileged(PrivilegedAction,AccessControlContext)
     */
    @@CallerSensitive
    public static <T> T
        doPrivileged(PrivilegedExceptionAction<T> action,
                     AccessControlContext context)
        throws PrivilegedActionException {
        return (T)doPrivileged(action, context, CallerID.getCallerID());
    }

    /**
     * Performs the specified {@@code PrivilegedExceptionAction} with
     * privileges enabled and restricted by the specified
     * {@@code AccessControlContext} and with a privilege scope limited by
     * specified {@@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@@code AccessControlContext}.
     * <p>
     * If the action's {@@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     * <p>
     * If a security manager is installed and the specified
     * {@@code AccessControlContext} was not created by system code and the
     * caller's {@@code ProtectionDomain} has not been granted the
     * {@@literal "createAccessControlContext"}
     * {@@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @@param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@@code run} method.
     * @@param action the action to be performed.
     * @@param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@@code null},
     *                then no additional restriction is applied.
     * @@param perms the {@@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @@return the value returned by the action's {@@code run} method.
     *
     * @@throws PrivilegedActionException if the specified action's
     *         {@@code run} method threw a <i>checked</i> exception
     * @@throws NullPointerException if action or perms or any element of
     *         perms is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction)
     * @@see #doPrivileged(PrivilegedAction,AccessControlContext)
     *
     * @@since 1.8
     */
    @@CallerSensitive
    public static <T> T doPrivileged(PrivilegedExceptionAction<T> action,
                                     AccessControlContext context, Permission... perms)
        throws PrivilegedActionException
    {
        AccessControlContext parent = getContext();
        if (perms == null) {
            throw new NullPointerException("null permissions parameter");
        }
        Class <?> caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(null, caller, parent, context, perms));
    }


    /**
     * Performs the specified {@@code PrivilegedExceptionAction} with
     * privileges enabled and restricted by the specified
     * {@@code AccessControlContext} and with a privilege scope limited by
     * specified {@@code Permission} arguments.
     *
     * The action is performed with the intersection of the permissions
     * possessed by the caller's protection domain, and those possessed
     * by the domains represented by the specified
     * {@@code AccessControlContext}.
     * <p>
     * If the action's {@@code run} method throws an (unchecked) exception,
     * it will propagate through this method.
     *
     * <p> This method preserves the current AccessControlContext's
     * DomainCombiner (which may be null) while the action is performed.
     * <p>
     * If a security manager is installed and the specified
     * {@@code AccessControlContext} was not created by system code and the
     * caller's {@@code ProtectionDomain} has not been granted the
     * {@@literal "createAccessControlContext"}
     * {@@link java.security.SecurityPermission}, then the action is performed
     * with no permissions.
     *
     * @@param <T> the type of the value returned by the
     *                  PrivilegedExceptionAction's {@@code run} method.
     * @@param action the action to be performed.
     * @@param context an <i>access control context</i>
     *                representing the restriction to be applied to the
     *                caller's domain's privileges before performing
     *                the specified action.  If the context is
     *                {@@code null},
     *                then no additional restriction is applied.
     * @@param perms the {@@code Permission} arguments which limit the
     *              scope of the caller's privileges. The number of arguments
     *              is variable.
     *
     * @@return the value returned by the action's {@@code run} method.
     *
     * @@throws PrivilegedActionException if the specified action's
     *         {@@code run} method threw a <i>checked</i> exception
     * @@throws NullPointerException if action or perms or any element of
     *         perms is {@@code null}
     *
     * @@see #doPrivileged(PrivilegedAction)
     * @@see #doPrivileged(PrivilegedAction,AccessControlContext)
     * @@see java.security.DomainCombiner
     *
     * @@since 1.8
     */
    @@CallerSensitive
    public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action,
                                                 AccessControlContext context,
                                                 Permission... perms)
        throws PrivilegedActionException
    {
        AccessControlContext parent = getContext();
        DomainCombiner dc = parent.getCombiner();
        if (dc == null && context != null) {
            dc = context.getCombiner();
        }
        if (perms == null) {
            throw new NullPointerException("null permissions parameter");
        }
        Class <?> caller = Reflection.getCallerClass();
        return AccessController.doPrivileged(action, createWrapper(dc, caller,
            parent, context, perms));
    }

    /**
     * Returns the AccessControl context. i.e., it gets
     * the protection domains of all the callers on the stack,
     * starting at the first class with a non-null
     * ProtectionDomain.
     *
     * @@return the access control context based on the current stack or
     *         null if there was only privileged system code.
     */

    private static AccessControlContext getStackAccessControlContext() {
        AccessControlContext context = null;
        CallerID callerID = null;
        PrivilegedElement pi = privileged_stack_top;
        if (pi != null) {
            context = pi.context;
            callerID = pi.callerID;
        }
        return getStackAccessControlContext(context, callerID);
    }
    
    private static native AccessControlContext getStackAccessControlContext(AccessControlContext context, CallerID callerID);

    /**
     * Returns the "inherited" AccessControl context. This is the context
     * that existed when the thread was created. Package private so
     * AccessControlContext can use it.
     */

    static native AccessControlContext getInheritedAccessControlContext();

    /**
     * This method takes a "snapshot" of the current calling context, which
     * includes the current Thread's inherited AccessControlContext and any
     * limited privilege scope, and places it in an AccessControlContext object.
     * This context may then be checked at a later point, possibly in another thread.
     *
     * @@see AccessControlContext
     *
     * @@return the AccessControlContext based on the current context.
     */

    public static AccessControlContext getContext()
    {
        AccessControlContext acc = getStackAccessControlContext();
        if (acc == null) {
            // all we had was privileged system code. We don't want
            // to return null though, so we construct a real ACC.
            return new AccessControlContext(null, true);
        } else {
            return acc.optimize();
        }
    }

    /**
     * Determines whether the access request indicated by the
     * specified permission should be allowed or denied, based on
     * the current AccessControlContext and security policy.
     * This method quietly returns if the access request
     * is permitted, or throws an AccessControlException otherwise. The
     * getPermission method of the AccessControlException returns the
     * {@@code perm} Permission object instance.
     *
     * @@param perm the requested permission.
     *
     * @@exception AccessControlException if the specified permission
     *            is not permitted, based on the current security policy.
     * @@exception NullPointerException if the specified permission
     *            is {@@code null} and is checked based on the
     *            security policy currently in effect.
     */

    public static void checkPermission(Permission perm)
        throws AccessControlException
    {
        //System.err.println("checkPermission "+perm);
        //Thread.currentThread().dumpStack();

        if (perm == null) {
            throw new NullPointerException("permission can't be null");
        }

        AccessControlContext stack = getStackAccessControlContext();
        // if context is null, we had privileged system code on the stack.
        if (stack == null) {
            Debug debug = AccessControlContext.getDebug();
            boolean dumpDebug = false;
            if (debug != null) {
                dumpDebug = !Debug.isOn("codebase=");
                dumpDebug &= !Debug.isOn("permission=") ||
                    Debug.isOn("permission=" + perm.getClass().getCanonicalName());
            }

            if (dumpDebug && Debug.isOn("stack")) {
                Thread.dumpStack();
            }

            if (dumpDebug && Debug.isOn("domain")) {
                debug.println("domain (context is null)");
            }

            if (dumpDebug) {
                debug.println("access allowed "+perm);
            }
            return;
        }

        AccessControlContext acc = stack.optimize();
        acc.checkPermission(perm);
    }
}
@


1.7
log
@Switched from @@HasCallerID to @@CallerSensitive and merged CallerSenstive related 7u40 changes.
@
text
@d2 1
a2 1
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
a28 1
import sun.misc.Unsafe;
d43 1
a43 1
 * currently in effect,<p>
d45 1
a45 1
 * access determinations, and<p>
d53 1
a53 1
 * below. In this example, <code>checkPermission</code> will determine
d65 1
a65 1
 * <code>checkPermission</code> returns quietly. If denied, an
d73 2
a74 2
 * <code>checkPermission</code> method.
 * The <code>checkPermission </code>method determines whether access
d86 7
a92 1
 *         return;
d94 1
a94 1
 * };
d106 1
a106 1
 * When making access control decisions, the <code>checkPermission</code>
d108 1
a108 1
 * was marked as "privileged" via a <code>doPrivileged</code>
d111 3
a113 2
 * specified permission, no further checking is done and
 * <code>checkPermission</code>
d116 5
a120 1
 * is thrown, as usual.
d141 1
a141 1
 * <code>run</code>.
d144 2
a145 2
 * <code>run</code> method is supplied.
 * When the call to <code>doPrivileged</code> is made, an
d147 2
a148 2
 * to it. The <code>doPrivileged</code> method calls the
 * <code>run</code> method from the PrivilegedAction
d150 2
a151 2
 * <code>run</code> method's return value as the
 * <code>doPrivileged</code> return value (which is
d168 2
a169 2
 * <p>If the action performed in your <code>run</code> method could
 * throw a "checked" exception (those listed in the <code>throws</code> clause
d171 2
a172 2
 * <code>PrivilegedExceptionAction</code> interface instead of the
 * <code>PrivilegedAction</code> interface:
d195 3
d199 1
a199 1
 * <p> Note that <code>checkPermission</code> always performs security checks
d206 1
a206 1
 * for this situation. The <code>getContext</code> method takes a "snapshot"
d218 1
a218 1
 * AccessControlContext itself has a <code>checkPermission</code> method
d233 3
a235 1
 * doPrivileged method that takes a context:
d243 5
a247 2
 *             // callers protection domain and the snapshot's
 *             // context have the desired permission.
d249 1
a249 1
 *     }, acc);
d252 6
d279 6
a284 1
    public static LazyContext getLazyContext(LazyContext parent) {
d286 1
a286 1
        lc.parent = parent;
d314 1
a314 1
                    Unsafe.getUnsafe().throwException(new PrivilegedActionException(x));
d329 1
a329 1
     * Performs the specified <code>PrivilegedAction</code> with privileges
d333 1
a333 1
     * <p> If the action's <code>run</code> method throws an (unchecked)
d339 3
d344 1
a344 1
     * @@return the value returned by the action's <code>run</code> method.
d346 1
a346 1
     * @@exception NullPointerException if the action is <code>null</code>
d360 1
a360 1
     * Performs the specified <code>PrivilegedAction</code> with privileges
d364 1
a364 1
     * <p> If the action's <code>run</code> method throws an (unchecked)
d370 3
d375 1
a375 1
     * @@return the value returned by the action's <code>run</code> method.
d377 1
a377 1
     * @@exception NullPointerException if the action is <code>null</code>
d391 42
a432 1
        return AccessController.doPrivileged(action, preserveCombiner(dc, Reflection.getCallerClass()));
d437 1
a437 1
     * Performs the specified <code>PrivilegedAction</code> with privileges
d439 3
a441 1
     * <code>AccessControlContext</code>.
d445 1
a445 1
     * <code>AccessControlContext</code>.
d447 1
a447 1
     * If the action's <code>run</code> method throws an (unchecked) exception,
d449 7
d457 2
d464 1
a464 1
     *                <code>null</code>,
d466 3
d470 1
a470 1
     * @@return the value returned by the action's <code>run</code> method.
d472 2
a473 1
     * @@exception NullPointerException if the action is <code>null</code>
d477 2
d482 75
a556 2
                                     AccessControlContext context) {
        return (T)doPrivileged(action, context, CallerID.getCallerID());
d560 1
a560 1
     * Performs the specified <code>PrivilegedExceptionAction</code> with
d564 1
a564 1
     * <p> If the action's <code>run</code> method throws an <i>unchecked</i>
d570 3
d575 1
a575 1
     * @@return the value returned by the action's <code>run</code> method
d578 2
a579 2
     *         <code>run</code> method threw a <i>checked</i> exception
     * @@exception NullPointerException if the action is <code>null</code>
d595 1
a595 1
     * Performs the specified <code>PrivilegedExceptionAction</code> with
d599 1
a599 1
     * <p> If the action's <code>run</code> method throws an <i>unchecked</i>
d605 3
d610 1
a610 1
     * @@return the value returned by the action's <code>run</code> method
d613 2
a614 2
     *         <code>run</code> method threw a <i>checked</i> exception
     * @@exception NullPointerException if the action is <code>null</code>
d623 3
a625 3
    public static <T> T doPrivilegedWithCombiner
        (PrivilegedExceptionAction<T> action) throws PrivilegedActionException {

d631 2
a632 1
        return AccessController.doPrivileged(action, preserveCombiner(dc, Reflection.getCallerClass()));
d639 28
a666 1
                                                         final Class<?> caller) {
d674 1
a674 9
        // perform 'combine' on the caller of doPrivileged,
        // even if the caller is from the bootclasspath
        ProtectionDomain[] pds = new ProtectionDomain[] {callerPd};
        if (combiner == null) {
            return new AccessControlContext(pds);
        } else {
            return new AccessControlContext(combiner.combine(pds, null),
                                            combiner);
        }
a676 1

d678 1
a678 1
     * Performs the specified <code>PrivilegedExceptionAction</code> with
d680 1
a680 1
     * <code>AccessControlContext</code>.  The action is performed with the
d683 1
a683 1
     * specified <code>AccessControlContext</code>.
d685 1
a685 1
     * If the action's <code>run</code> method throws an <i>unchecked</i>
d687 7
d695 2
d702 1
a702 2
     *                <code>null</code>,
     *                then no additional restriction is applied.
d704 1
a704 1
     * @@return the value returned by the action's <code>run</code> method
d707 2
a708 3
     *         <code>run</code> method
     *         threw a <i>checked</i> exception
     * @@exception NullPointerException if the action is <code>null</code>
d711 1
a711 1
     * @@see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)
d722 129
d883 3
a885 3
     * includes the current Thread's inherited AccessControlContext,
     * and places it in an AccessControlContext object. This context may then
     * be checked at a later point, possibly in another thread.
d911 1
a911 1
     * <code>perm</code> Permission object instance.
d918 1
a918 1
     *            is <code>null</code> and is checked based on the
d923 1
a923 1
                 throws AccessControlException
d944 1
a944 1
                Thread.currentThread().dumpStack();
@


1.6
log
@Updated to OpenJDK 7:
- java.lang.Class
- java.security.AccessController
- sun.reflect.ReflectionFactory
@
text
@d2 1
a2 1
 * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
d31 2
d322 1
a322 1
    @@ikvm.internal.HasCallerID
d349 1
a350 2

        DomainCombiner dc = null;
d352 1
a352 1
        if (acc == null || (dc = acc.getAssignedCombiner()) == null) {
d355 2
a356 1
        return AccessController.doPrivileged(action, preserveCombiner(dc));
d387 1
a387 1
    @@ikvm.internal.HasCallerID
d417 1
a417 1
    @@ikvm.internal.HasCallerID
d450 1
a453 1
        DomainCombiner dc = null;
d455 1
a455 1
        if (acc == null || (dc = acc.getAssignedCombiner()) == null) {
d458 2
a459 1
        return AccessController.doPrivileged(action, preserveCombiner(dc));
d465 2
a466 10
    private static AccessControlContext preserveCombiner
                                        (DomainCombiner combiner) {

        /**
         * callerClass[0] = Reflection.getCallerClass
         * callerClass[1] = AccessController.preserveCombiner
         * callerClass[2] = AccessController.doPrivileged
         * callerClass[3] = caller
         */
        final Class callerClass = sun.reflect.Reflection.getCallerClass(3);
d470 1
a470 1
                return callerClass.getProtectionDomain();
d477 6
a482 1
        return new AccessControlContext(combiner.combine(pds, null), combiner);
d515 1
a515 1
    @@ikvm.internal.HasCallerID
@


1.5
log
@Integrated OpenJDK 6 b21.
@
text
@d490 1
a490 1
     * intersection of the the permissions possessed by the caller's
d582 3
a584 1
     * is permitted, or throws a suitable AccessControlException otherwise.
@


1.4
log
@The full Thread parent hierarchy should be considered when capturing the stack.
@
text
@d2 1
a2 1
 * Copyright 1997-2007 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.3
log
@Made Thread constructor stack capture more lazy.
@
text
@d246 1
d253 1
a253 1
    public static LazyContext getLazyContext() {
d255 1
@


1.2
log
@Moved AccessController.doPrivileged() to Java and use CallerID to avoid stack walk.
@
text
@d244 17
@


1.1
log
@Forked java/security/AccessController.java.
@
text
@d28 2
d241 32
d301 4
a304 1
    public static native <T> T doPrivileged(PrivilegedAction<T> action);
d366 5
a370 2
    public static native <T> T doPrivileged(PrivilegedAction<T> action,
                                            AccessControlContext context);
d396 2
a397 1
    public static native <T> T
d399 3
a401 1
        throws PrivilegedActionException;
d496 2
a497 1
    public static native <T> T
d500 3
a502 1
        throws PrivilegedActionException;
d514 12
a525 1
    private static native AccessControlContext getStackAccessControlContext();
@

