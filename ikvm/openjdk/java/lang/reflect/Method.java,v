head	1.11;
access;
symbols
	v8_1_5717_0:1.11
	v8_1:1.11.0.2
	v8_0_5449_1:1.10
	v8_0_5449_0:1.10
	v8_0:1.10.0.2
	v7_4_5196_0:1.9
	v7_4:1.9.0.2
	v7_3:1.8.0.8
	v7_2_4630_6:1.8
	v7_2_4630_5:1.8
	v7_2_4630_4:1.8
	v7_2_4630_3:1.8
	v7_2_4630_2:1.8
	v0_46_0_4:1.7
	v7_2_4630_1:1.8
	v7_2:1.8.0.6
	v7_1_4532_2:1.8
	v7_1_4532_1:1.8
	v7_1_4532_0:1.8
	v7_1:1.8.0.4
	v7_0_4335_3:1.8
	v7_0_4335_2:1.8
	v7_0_4335_1:1.8
	v0_46_0_2:1.7
	v7_0_4335_0:1.8
	v7_0:1.8.0.2
	v0_40_0_6:1.6
	v0_40_0_5:1.6
	v0_46_0_1:1.7
	v0_46_0_0:1.7
	v0_46:1.7.0.2
	v0_36_0_14:1.1.2.2
	v0_44_0_6:1.6
	v0_44_0_5:1.6
	v0_44_0_4:1.6
	v0_44_0_3:1.6
	v0_44_0_2:1.6
	v0_42_0_7:1.6
	v0_44_0_1:1.6
	v0_44_0_0:1.6
	v0_44:1.6.0.8
	v0_42_0_6:1.6
	v0_42_0_5:1.6
	v0_42_0_4:1.6
	v0_42_0_3:1.6
	v0_42_0_2:1.6
	v0_42_0_1:1.6
	v0_42_0_0:1.6
	v0_42:1.6.0.6
	v0_40_0_3:1.6
	v0_40_0_2:1.6
	v0_40_0_1:1.6
	v0_40_0_0:1.6
	v0_40:1.6.0.4
	v0_36_0_13:1.1.2.2
	v0_38_0_1:1.6
	v0_38_0_0:1.6
	v0_38:1.6.0.2
	v0_36_0_9:1.1.2.2
	v0_36_0_7:1.1.2.2
	v0_36_0_5:1.1.2.2
	v0_36_0_4:1.1.2.2
	v0_36_0_3:1.1.2.2
	v0_36_0_2:1.1.2.2
	v0_36_0_1:1.1.2.2
	v0_36:1.1.0.2;
locks; strict;
comment	@# @;


1.11
date	2015.06.09.09.28.43;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2014.05.19.12.43.38;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.12.07.55.57;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.29.15.07.09;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.24.16.40.22;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.13.09.01.20;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.12.09.09.48;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.11.09.05.23;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.15.20.35;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.29.08.03.10;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.10.06.16.50;	author jfrijters;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2007.09.10.06.16.50;	author jfrijters;	state dead;
branches;
next	1.1.2.2;

1.1.2.2
date	2007.09.13.07.30.17;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Integrated OpenJDK 8u45.
@
text
@/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.reflect;

import sun.reflect.CallerSensitive;
import sun.reflect.MethodAccessor;
import sun.reflect.Reflection;
import sun.reflect.generics.repository.MethodRepository;
import sun.reflect.generics.factory.CoreReflectionFactory;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.scope.MethodScope;
import sun.reflect.annotation.AnnotationType;
import sun.reflect.annotation.AnnotationParser;
import java.lang.annotation.Annotation;
import java.lang.annotation.AnnotationFormatError;
import java.nio.ByteBuffer;

/**
 * A {@@code Method} provides information about, and access to, a single method
 * on a class or interface.  The reflected method may be a class method
 * or an instance method (including an abstract method).
 *
 * <p>A {@@code Method} permits widening conversions to occur when matching the
 * actual parameters to invoke with the underlying method's formal
 * parameters, but it throws an {@@code IllegalArgumentException} if a
 * narrowing conversion would occur.
 *
 * @@see Member
 * @@see java.lang.Class
 * @@see java.lang.Class#getMethods()
 * @@see java.lang.Class#getMethod(String, Class[])
 * @@see java.lang.Class#getDeclaredMethods()
 * @@see java.lang.Class#getDeclaredMethod(String, Class[])
 *
 * @@author Kenneth Russell
 * @@author Nakul Saraiya
 */
public final class Method extends Executable {
    private Class<?>            clazz;
    private int                 slot;
    // This is guaranteed to be interned by the VM in the 1.4
    // reflection implementation
    private String              name;
    private Class<?>            returnType;
    private Class<?>[]          parameterTypes;
    private Class<?>[]          exceptionTypes;
    private int                 modifiers;
    // Generics and annotations support
    private transient String              signature;
    // generic info repository; lazily initialized
    private transient MethodRepository genericInfo;
    private volatile MethodAccessor methodAccessor;
    // For sharing of MethodAccessors. This branching structure is
    // currently only two levels deep (i.e., one root Method and
    // potentially many Method objects pointing to it.)
    //
    // If this branching structure would ever contain cycles, deadlocks can
    // occur in annotation code.
    private Method              root;

    // Generics infrastructure
    private String getGenericSignature() {return signature;}

    // Accessor for factory
    private GenericsFactory getFactory() {
        // create scope and factory
        return CoreReflectionFactory.make(this, MethodScope.make(this));
    }

    // Accessor for generic info repository
    @@Override
    MethodRepository getGenericInfo() {
        // lazily initialize repository if necessary
        if (genericInfo == null) {
            // create and cache generic info repository
            genericInfo = MethodRepository.make(getGenericSignature(),
                                                getFactory());
        }
        return genericInfo; //return cached repository
    }

    /**
     * Package-private constructor used by ReflectAccess to enable
     * instantiation of these objects in Java code from the java.lang
     * package via sun.reflect.LangReflectAccess.
     */
    Method(Class<?> declaringClass,
           String name,
           Class<?>[] parameterTypes,
           Class<?> returnType,
           Class<?>[] checkedExceptions,
           int modifiers,
           int slot,
           String signature,
           byte[] unused1,
           byte[] unused2,
           byte[] unused3) {
        this.clazz = declaringClass;
        this.name = name;
        this.parameterTypes = parameterTypes;
        this.returnType = returnType;
        this.exceptionTypes = checkedExceptions;
        this.modifiers = modifiers;
        this.slot = slot;
        this.signature = signature;
    }

    /**
     * Package-private routine (exposed to java.lang.Class via
     * ReflectAccess) which returns a copy of this Method. The copy's
     * "root" field points to this Method.
     */
    Method copy() {
        // This routine enables sharing of MethodAccessor objects
        // among Method objects which refer to the same underlying
        // method in the VM. (All of this contortion is only necessary
        // because of the "accessibility" bit in AccessibleObject,
        // which implicitly requires that new java.lang.reflect
        // objects be fabricated for each reflective call on Class
        // objects.)
        if (this.root != null)
            throw new IllegalArgumentException("Can not copy a non-root Method");

        Method res = new Method(clazz, name, parameterTypes, returnType,
                                exceptionTypes, modifiers, slot, signature,
                                null, null, null);
        res.root = this;
        // Might as well eagerly propagate this if already present
        res.methodAccessor = methodAccessor;
        return res;
    }

    /**
     * Used by Excecutable for annotation sharing.
     */
    @@Override
    Executable getRoot() {
        return root;
    }

    @@Override
    boolean hasGenericInformation() {
        return (getGenericSignature() != null);
    }

    /**
     * {@@inheritDoc}
     */
    @@Override
    public Class<?> getDeclaringClass() {
        return clazz;
    }

    /**
     * Returns the name of the method represented by this {@@code Method}
     * object, as a {@@code String}.
     */
    @@Override
    public String getName() {
        return name;
    }

    /**
     * {@@inheritDoc}
     */
    @@Override
    public int getModifiers() {
        return modifiers;
    }

    /**
     * {@@inheritDoc}
     * @@throws GenericSignatureFormatError {@@inheritDoc}
     * @@since 1.5
     */
    @@Override
    @@SuppressWarnings({"rawtypes", "unchecked"})
    public TypeVariable<Method>[] getTypeParameters() {
        if (getGenericSignature() != null)
            return (TypeVariable<Method>[])getGenericInfo().getTypeParameters();
        else
            return (TypeVariable<Method>[])new TypeVariable[0];
    }

    /**
     * Returns a {@@code Class} object that represents the formal return type
     * of the method represented by this {@@code Method} object.
     *
     * @@return the return type for the method this object represents
     */
    public Class<?> getReturnType() {
        return returnType;
    }

    /**
     * Returns a {@@code Type} object that represents the formal return
     * type of the method represented by this {@@code Method} object.
     *
     * <p>If the return type is a parameterized type,
     * the {@@code Type} object returned must accurately reflect
     * the actual type parameters used in the source code.
     *
     * <p>If the return type is a type variable or a parameterized type, it
     * is created. Otherwise, it is resolved.
     *
     * @@return  a {@@code Type} object that represents the formal return
     *     type of the underlying  method
     * @@throws GenericSignatureFormatError
     *     if the generic method signature does not conform to the format
     *     specified in
     *     <cite>The Java&trade; Virtual Machine Specification</cite>
     * @@throws TypeNotPresentException if the underlying method's
     *     return type refers to a non-existent type declaration
     * @@throws MalformedParameterizedTypeException if the
     *     underlying method's return typed refers to a parameterized
     *     type that cannot be instantiated for any reason
     * @@since 1.5
     */
    public Type getGenericReturnType() {
      if (getGenericSignature() != null) {
        return getGenericInfo().getReturnType();
      } else { return getReturnType();}
    }

    /**
     * {@@inheritDoc}
     */
    @@Override
    public Class<?>[] getParameterTypes() {
        return parameterTypes.clone();
    }

    /**
     * {@@inheritDoc}
     */
    public int getParameterCount() { return parameterTypes.length; }


    /**
     * {@@inheritDoc}
     * @@throws GenericSignatureFormatError {@@inheritDoc}
     * @@throws TypeNotPresentException {@@inheritDoc}
     * @@throws MalformedParameterizedTypeException {@@inheritDoc}
     * @@since 1.5
     */
    @@Override
    public Type[] getGenericParameterTypes() {
        return super.getGenericParameterTypes();
    }

    /**
     * {@@inheritDoc}
     */
    @@Override
    public Class<?>[] getExceptionTypes() {
        return exceptionTypes.clone();
    }

    /**
     * {@@inheritDoc}
     * @@throws GenericSignatureFormatError {@@inheritDoc}
     * @@throws TypeNotPresentException {@@inheritDoc}
     * @@throws MalformedParameterizedTypeException {@@inheritDoc}
     * @@since 1.5
     */
    @@Override
    public Type[] getGenericExceptionTypes() {
        return super.getGenericExceptionTypes();
    }

    /**
     * Compares this {@@code Method} against the specified object.  Returns
     * true if the objects are the same.  Two {@@code Methods} are the same if
     * they were declared by the same class and have the same name
     * and formal parameter types and return type.
     */
    public boolean equals(Object obj) {
        if (obj != null && obj instanceof Method) {
            Method other = (Method)obj;
            if ((getDeclaringClass() == other.getDeclaringClass())
                && (getName() == other.getName())) {
                if (!returnType.equals(other.getReturnType()))
                    return false;
                return equalParamTypes(parameterTypes, other.parameterTypes);
            }
        }
        return false;
    }

    /**
     * Returns a hashcode for this {@@code Method}.  The hashcode is computed
     * as the exclusive-or of the hashcodes for the underlying
     * method's declaring class name and the method's name.
     */
    public int hashCode() {
        return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
    }

    /**
     * Returns a string describing this {@@code Method}.  The string is
     * formatted as the method access modifiers, if any, followed by
     * the method return type, followed by a space, followed by the
     * class declaring the method, followed by a period, followed by
     * the method name, followed by a parenthesized, comma-separated
     * list of the method's formal parameter types. If the method
     * throws checked exceptions, the parameter list is followed by a
     * space, followed by the word throws followed by a
     * comma-separated list of the thrown exception types.
     * For example:
     * <pre>
     *    public boolean java.lang.Object.equals(java.lang.Object)
     * </pre>
     *
     * <p>The access modifiers are placed in canonical order as
     * specified by "The Java Language Specification".  This is
     * {@@code public}, {@@code protected} or {@@code private} first,
     * and then other modifiers in the following order:
     * {@@code abstract}, {@@code default}, {@@code static}, {@@code final},
     * {@@code synchronized}, {@@code native}, {@@code strictfp}.
     *
     * @@return a string describing this {@@code Method}
     *
     * @@jls 8.4.3 Method Modifiers
     */
    public String toString() {
        return sharedToString(Modifier.methodModifiers(),
                              isDefault(),
                              parameterTypes,
                              exceptionTypes);
    }

    @@Override
    void specificToStringHeader(StringBuilder sb) {
        sb.append(getReturnType().getTypeName()).append(' ');
        sb.append(getDeclaringClass().getTypeName()).append('.');
        sb.append(getName());
    }

    /**
     * Returns a string describing this {@@code Method}, including
     * type parameters.  The string is formatted as the method access
     * modifiers, if any, followed by an angle-bracketed
     * comma-separated list of the method's type parameters, if any,
     * followed by the method's generic return type, followed by a
     * space, followed by the class declaring the method, followed by
     * a period, followed by the method name, followed by a
     * parenthesized, comma-separated list of the method's generic
     * formal parameter types.
     *
     * If this method was declared to take a variable number of
     * arguments, instead of denoting the last parameter as
     * "<tt><i>Type</i>[]</tt>", it is denoted as
     * "<tt><i>Type</i>...</tt>".
     *
     * A space is used to separate access modifiers from one another
     * and from the type parameters or return type.  If there are no
     * type parameters, the type parameter list is elided; if the type
     * parameter list is present, a space separates the list from the
     * class name.  If the method is declared to throw exceptions, the
     * parameter list is followed by a space, followed by the word
     * throws followed by a comma-separated list of the generic thrown
     * exception types.
     *
     * <p>The access modifiers are placed in canonical order as
     * specified by "The Java Language Specification".  This is
     * {@@code public}, {@@code protected} or {@@code private} first,
     * and then other modifiers in the following order:
     * {@@code abstract}, {@@code default}, {@@code static}, {@@code final},
     * {@@code synchronized}, {@@code native}, {@@code strictfp}.
     *
     * @@return a string describing this {@@code Method},
     * include type parameters
     *
     * @@since 1.5
     *
     * @@jls 8.4.3 Method Modifiers
     */
    @@Override
    public String toGenericString() {
        return sharedToGenericString(Modifier.methodModifiers(), isDefault());
    }

    @@Override
    void specificToGenericStringHeader(StringBuilder sb) {
        Type genRetType = getGenericReturnType();
        sb.append(genRetType.getTypeName()).append(' ');
        sb.append(getDeclaringClass().getTypeName()).append('.');
        sb.append(getName());
    }

    /**
     * Invokes the underlying method represented by this {@@code Method}
     * object, on the specified object with the specified parameters.
     * Individual parameters are automatically unwrapped to match
     * primitive formal parameters, and both primitive and reference
     * parameters are subject to method invocation conversions as
     * necessary.
     *
     * <p>If the underlying method is static, then the specified {@@code obj}
     * argument is ignored. It may be null.
     *
     * <p>If the number of formal parameters required by the underlying method is
     * 0, the supplied {@@code args} array may be of length 0 or null.
     *
     * <p>If the underlying method is an instance method, it is invoked
     * using dynamic method lookup as documented in The Java Language
     * Specification, Second Edition, section 15.12.4.4; in particular,
     * overriding based on the runtime type of the target object will occur.
     *
     * <p>If the underlying method is static, the class that declared
     * the method is initialized if it has not already been initialized.
     *
     * <p>If the method completes normally, the value it returns is
     * returned to the caller of invoke; if the value has a primitive
     * type, it is first appropriately wrapped in an object. However,
     * if the value has the type of an array of a primitive type, the
     * elements of the array are <i>not</i> wrapped in objects; in
     * other words, an array of primitive type is returned.  If the
     * underlying method return type is void, the invocation returns
     * null.
     *
     * @@param obj  the object the underlying method is invoked from
     * @@param args the arguments used for the method call
     * @@return the result of dispatching the method represented by
     * this object on {@@code obj} with parameters
     * {@@code args}
     *
     * @@exception IllegalAccessException    if this {@@code Method} object
     *              is enforcing Java language access control and the underlying
     *              method is inaccessible.
     * @@exception IllegalArgumentException  if the method is an
     *              instance method and the specified object argument
     *              is not an instance of the class or interface
     *              declaring the underlying method (or of a subclass
     *              or implementor thereof); if the number of actual
     *              and formal parameters differ; if an unwrapping
     *              conversion for primitive arguments fails; or if,
     *              after possible unwrapping, a parameter value
     *              cannot be converted to the corresponding formal
     *              parameter type by a method invocation conversion.
     * @@exception InvocationTargetException if the underlying method
     *              throws an exception.
     * @@exception NullPointerException      if the specified object is null
     *              and the method is an instance method.
     * @@exception ExceptionInInitializerError if the initialization
     * provoked by this method fails.
     */
    @@CallerSensitive
    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class<?> caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, obj, modifiers);
            }
        }
        MethodAccessor ma = methodAccessor;             // read volatile
        if (ma == null) {
            ma = acquireMethodAccessor();
        }
        return ma.invoke(obj, args, ikvm.internal.CallerID.getCallerID());
    }

    /**
     * Returns {@@code true} if this method is a bridge
     * method; returns {@@code false} otherwise.
     *
     * @@return true if and only if this method is a bridge
     * method as defined by the Java Language Specification.
     * @@since 1.5
     */
    public boolean isBridge() {
        return (getModifiers() & Modifier.BRIDGE) != 0;
    }

    /**
     * {@@inheritDoc}
     * @@since 1.5
     */
    @@Override
    public boolean isVarArgs() {
        return super.isVarArgs();
    }

    /**
     * {@@inheritDoc}
     * @@jls 13.1 The Form of a Binary
     * @@since 1.5
     */
    @@Override
    public boolean isSynthetic() {
        return super.isSynthetic();
    }

    /**
     * Returns {@@code true} if this method is a default
     * method; returns {@@code false} otherwise.
     *
     * A default method is a public non-abstract instance method, that
     * is, a non-static method with a body, declared in an interface
     * type.
     *
     * @@return true if and only if this method is a default
     * method as defined by the Java Language Specification.
     * @@since 1.8
     */
    public boolean isDefault() {
        // Default methods are public non-abstract instance methods
        // declared in an interface.
        return ((getModifiers() & (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) ==
                Modifier.PUBLIC) && getDeclaringClass().isInterface();
    }

    // NOTE that there is no synchronization used here. It is correct
    // (though not efficient) to generate more than one MethodAccessor
    // for a given Method. However, avoiding synchronization will
    // probably make the implementation more scalable.
    private MethodAccessor acquireMethodAccessor() {
        // First check to see if one has been created yet, and take it
        // if so
        MethodAccessor tmp = null;
        if (root != null) tmp = root.getMethodAccessor();
        if (tmp != null) {
            methodAccessor = tmp;
        } else {
            // Otherwise fabricate one and propagate it up to the root
            tmp = reflectionFactory.newMethodAccessor(this);
            setMethodAccessor(tmp);
        }

        return tmp;
    }

    // Returns MethodAccessor for this Method object, not looking up
    // the chain to the root
    MethodAccessor getMethodAccessor() {
        return methodAccessor;
    }

    // Sets the MethodAccessor for this Method object and
    // (recursively) its root
    void setMethodAccessor(MethodAccessor accessor) {
        methodAccessor = accessor;
        // Propagate up
        if (root != null) {
            root.setMethodAccessor(accessor);
        }
    }

    /**
     * Returns the default value for the annotation member represented by
     * this {@@code Method} instance.  If the member is of a primitive type,
     * an instance of the corresponding wrapper type is returned. Returns
     * null if no default is associated with the member, or if the method
     * instance does not represent a declared member of an annotation type.
     *
     * @@return the default value for the annotation member represented
     *     by this {@@code Method} instance.
     * @@throws TypeNotPresentException if the annotation is of type
     *     {@@link Class} and no definition can be found for the
     *     default class value.
     * @@since  1.5
     */
    public native Object getDefaultValue();

    /**
     * {@@inheritDoc}
     * @@throws NullPointerException  {@@inheritDoc}
     * @@since 1.5
     */
    public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
        return super.getAnnotation(annotationClass);
    }

    /**
     * {@@inheritDoc}
     * @@since 1.5
     */
    public Annotation[] getDeclaredAnnotations()  {
        return super.getDeclaredAnnotations();
    }

    /**
     * {@@inheritDoc}
     * @@since 1.5
     */
    @@Override
    public Annotation[][] getParameterAnnotations() {
        return sharedGetParameterAnnotations(parameterTypes);
    }

    /**
     * {@@inheritDoc}
     * @@since 1.8
     */
    @@Override
    public AnnotatedType getAnnotatedReturnType() {
        return getAnnotatedReturnType0(getGenericReturnType());
    }

    @@Override
    void handleParameterNumberMismatch(int resultLength, int numParameters) {
        throw new AnnotationFormatError("Parameter annotations don't match number of parameters");
    }
}
@


1.10
log
@First part of OpenJDK 8 integration.
@
text
@d79 3
d144 3
d156 8
@


1.9
log
@Switched from @@HasCallerID to @@CallerSensitive and merged CallerSenstive related 7u40 changes.
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 2006, Oracle and/or its affiliates. All rights reserved.
a27 1
import ikvm.internal.CallerID;
a39 1
import java.util.Map;
d61 1
a61 3
public final
    class Method extends AccessibleObject implements GenericDeclaration,
                                                     Member {
d81 1
a81 2
   // Generics infrastructure

d91 2
a92 1
    private MethodRepository getGenericInfo() {
d117 1
a117 2
           byte[] unused3)
    {
d150 5
d156 1
a156 2
     * Returns the {@@code Class} object representing the class or interface
     * that declares the method represented by this {@@code Method} object.
d158 1
d167 1
d173 1
a173 5
     * Returns the Java language modifiers for the method represented
     * by this {@@code Method} object, as an integer. The {@@code Modifier} class should
     * be used to decode the modifiers.
     *
     * @@see Modifier
d175 1
d181 2
a182 12
     * Returns an array of {@@code TypeVariable} objects that represent the
     * type variables declared by the generic declaration represented by this
     * {@@code GenericDeclaration} object, in declaration order.  Returns an
     * array of length 0 if the underlying generic declaration declares no type
     * variables.
     *
     * @@return an array of {@@code TypeVariable} objects that represent
     *     the type variables declared by this generic declaration
     * @@throws GenericSignatureFormatError if the generic
     *     signature of this generic declaration does not conform to
     *     the format specified in
     *     <cite>The Java&trade; Virtual Machine Specification</cite>
d185 2
a233 1

d235 1
a235 7
     * Returns an array of {@@code Class} objects that represent the formal
     * parameter types, in declaration order, of the method
     * represented by this {@@code Method} object.  Returns an array of length
     * 0 if the underlying method takes no parameters.
     *
     * @@return the parameter types for the method this object
     * represents
d237 1
d239 1
a239 1
        return (Class<?>[]) parameterTypes.clone();
d243 10
a252 24
     * Returns an array of {@@code Type} objects that represent the formal
     * parameter types, in declaration order, of the method represented by
     * this {@@code Method} object. Returns an array of length 0 if the
     * underlying method takes no parameters.
     *
     * <p>If a formal parameter type is a parameterized type,
     * the {@@code Type} object returned for it must accurately reflect
     * the actual type parameters used in the source code.
     *
     * <p>If a formal parameter type is a type variable or a parameterized
     * type, it is created. Otherwise, it is resolved.
     *
     * @@return an array of Types that represent the formal
     *     parameter types of the underlying method, in declaration order
     * @@throws GenericSignatureFormatError
     *     if the generic method signature does not conform to the format
     *     specified in
     *     <cite>The Java&trade; Virtual Machine Specification</cite>
     * @@throws TypeNotPresentException if any of the parameter
     *     types of the underlying method refers to a non-existent type
     *     declaration
     * @@throws MalformedParameterizedTypeException if any of
     *     the underlying method's parameter types refer to a parameterized
     *     type that cannot be instantiated for any reason
d255 1
d257 1
a257 4
        if (getGenericSignature() != null)
            return getGenericInfo().getParameterTypes();
        else
            return getParameterTypes();
a259 1

d261 1
a261 8
     * Returns an array of {@@code Class} objects that represent
     * the types of the exceptions declared to be thrown
     * by the underlying method
     * represented by this {@@code Method} object.  Returns an array of length
     * 0 if the method declares no exceptions in its {@@code throws} clause.
     *
     * @@return the exception types declared as being thrown by the
     * method this object represents
d263 1
d265 1
a265 1
        return (Class<?>[]) exceptionTypes.clone();
d269 4
a272 19
     * Returns an array of {@@code Type} objects that represent the
     * exceptions declared to be thrown by this {@@code Method} object.
     * Returns an array of length 0 if the underlying method declares
     * no exceptions in its {@@code throws} clause.
     *
     * <p>If an exception type is a type variable or a parameterized
     * type, it is created. Otherwise, it is resolved.
     *
     * @@return an array of Types that represent the exception types
     *     thrown by the underlying method
     * @@throws GenericSignatureFormatError
     *     if the generic method signature does not conform to the format
     *     specified in
     *     <cite>The Java&trade; Virtual Machine Specification</cite>
     * @@throws TypeNotPresentException if the underlying method's
     *     {@@code throws} clause refers to a non-existent type declaration
     * @@throws MalformedParameterizedTypeException if
     *     the underlying method's {@@code throws} clause refers to a
     *     parameterized type that cannot be instantiated for any reason
d275 4
a278 8
      public Type[] getGenericExceptionTypes() {
          Type[] result;
          if (getGenericSignature() != null &&
              ((result = getGenericInfo().getExceptionTypes()).length > 0))
              return result;
          else
              return getExceptionTypes();
      }
d293 1
a293 10
                /* Avoid unnecessary cloning */
                Class<?>[] params1 = parameterTypes;
                Class<?>[] params2 = other.parameterTypes;
                if (params1.length == params2.length) {
                    for (int i = 0; i < params1.length; i++) {
                        if (params1[i] != params2[i])
                            return false;
                    }
                    return true;
                }
d327 1
a327 1
     * {@@code abstract}, {@@code static}, {@@code final},
d329 4
d335 11
a345 29
        try {
            StringBuilder sb = new StringBuilder();
            int mod = getModifiers() & Modifier.methodModifiers();
            if (mod != 0) {
                sb.append(Modifier.toString(mod)).append(' ');
            }
            sb.append(Field.getTypeName(getReturnType())).append(' ');
            sb.append(Field.getTypeName(getDeclaringClass())).append('.');
            sb.append(getName()).append('(');
            Class<?>[] params = parameterTypes; // avoid clone
            for (int j = 0; j < params.length; j++) {
                sb.append(Field.getTypeName(params[j]));
                if (j < (params.length - 1))
                    sb.append(',');
            }
            sb.append(')');
            Class<?>[] exceptions = exceptionTypes; // avoid clone
            if (exceptions.length > 0) {
                sb.append(" throws ");
                for (int k = 0; k < exceptions.length; k++) {
                    sb.append(exceptions[k].getName());
                    if (k < (exceptions.length - 1))
                        sb.append(',');
                }
            }
            return sb.toString();
        } catch (Exception e) {
            return "<" + e + ">";
        }
d371 1
a371 2
     * exception types.  If there are no type parameters, the type
     * parameter list is elided.
d377 1
a377 1
     * {@@code abstract}, {@@code static}, {@@code final},
d384 2
d387 1
d389 2
a390 20
        try {
            StringBuilder sb = new StringBuilder();
            int mod = getModifiers() & Modifier.methodModifiers();
            if (mod != 0) {
                sb.append(Modifier.toString(mod)).append(' ');
            }
            TypeVariable<?>[] typeparms = getTypeParameters();
            if (typeparms.length > 0) {
                boolean first = true;
                sb.append('<');
                for(TypeVariable<?> typeparm: typeparms) {
                    if (!first)
                        sb.append(',');
                    // Class objects can't occur here; no need to test
                    // and call Class.getName().
                    sb.append(typeparm.toString());
                    first = false;
                }
                sb.append("> ");
            }
d392 6
a397 34
            Type genRetType = getGenericReturnType();
            sb.append( ((genRetType instanceof Class<?>)?
                        Field.getTypeName((Class<?>)genRetType):genRetType.toString()))
                    .append(' ');

            sb.append(Field.getTypeName(getDeclaringClass())).append('.');
            sb.append(getName()).append('(');
            Type[] params = getGenericParameterTypes();
            for (int j = 0; j < params.length; j++) {
                String param = (params[j] instanceof Class)?
                    Field.getTypeName((Class)params[j]):
                    (params[j].toString());
                if (isVarArgs() && (j == params.length - 1)) // replace T[] with T...
                    param = param.replaceFirst("\\[\\]$", "...");
                sb.append(param);
                if (j < (params.length - 1))
                    sb.append(',');
            }
            sb.append(')');
            Type[] exceptions = getGenericExceptionTypes();
            if (exceptions.length > 0) {
                sb.append(" throws ");
                for (int k = 0; k < exceptions.length; k++) {
                    sb.append((exceptions[k] instanceof Class)?
                              ((Class)exceptions[k]).getName():
                              exceptions[k].toString());
                    if (k < (exceptions.length - 1))
                        sb.append(',');
                }
            }
            return sb.toString();
        } catch (Exception e) {
            return "<" + e + ">";
        }
d472 1
a472 1
        return ma.invoke(obj, args, CallerID.getCallerID());
d488 1
a488 6
     * Returns {@@code true} if this method was declared to take
     * a variable number of arguments; returns {@@code false}
     * otherwise.
     *
     * @@return {@@code true} if an only if this method was declared to
     * take a variable number of arguments.
d491 1
d493 11
a503 1
        return (getModifiers() & Modifier.VARARGS) != 0;
d507 1
a507 1
     * Returns {@@code true} if this method is a synthetic
d510 5
a514 1
     * @@return true if and only if this method is a synthetic
d516 1
a516 1
     * @@since 1.5
d518 5
a522 2
    public boolean isSynthetic() {
        return Modifier.isSynthetic(getModifiers());
a561 31
     * @@throws NullPointerException {@@inheritDoc}
     * @@since 1.5
     */
    public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
        if (annotationClass == null)
            throw new NullPointerException();

        return (T) declaredAnnotations().get(annotationClass);
    }

    private static final Annotation[] EMPTY_ANNOTATION_ARRAY=new Annotation[0];

    /**
     * @@since 1.5
     */
    public Annotation[] getDeclaredAnnotations()  {
        return declaredAnnotations().values().toArray(EMPTY_ANNOTATION_ARRAY);
    }

    private transient Map<Class<? extends Annotation>, Annotation> declaredAnnotations;

    private synchronized  Map<Class<? extends Annotation>, Annotation> declaredAnnotations() {
        if (declaredAnnotations == null) {
            declaredAnnotations = getDeclaredAnnotationsImpl(this);
        }
        return declaredAnnotations;
    }
    
    static native Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationsImpl(Object methodOrConstructor);

    /**
d578 10
a587 13
     * Returns an array of arrays that represent the annotations on the formal
     * parameters, in declaration order, of the method represented by
     * this {@@code Method} object. (Returns an array of length zero if the
     * underlying method is parameterless.  If the method has one or more
     * parameters, a nested array of length zero is returned for each parameter
     * with no annotations.) The annotation objects contained in the returned
     * arrays are serializable.  The caller of this method is free to modify
     * the returned arrays; it will have no effect on the arrays returned to
     * other callers.
     *
     * @@return an array of arrays that represent the annotations on the formal
     *    parameters, in declaration order, of the method represented by this
     *    Method object
d590 9
d600 1
a600 9
        Annotation[][] result = getParameterAnnotationsImpl(this);
        int numParameters = parameterTypes.length;
        if (result == null)
            return new Annotation[numParameters][0];

        if (result.length != numParameters)
            throw new java.lang.annotation.AnnotationFormatError(
                "Parameter annotations don't match number of parameters");
        return result;
d603 13
a615 1
    static native Annotation[][] getParameterAnnotationsImpl(Object methodOrConstructor);
@


1.8
log
@Updated java.lang.reflect package (minus ReflectAccess.java) to OpenJDK 7.
@
text
@d29 1
d582 1
a582 1
    @@ikvm.internal.HasCallerID
d589 1
a589 2
                Class<?> caller = CallerID.getCallerID().getCallerClass();

@


1.7
log
@Integrated OpenJDK 6 b21.
@
text
@d65 1
a65 1
    private Class               clazz;
d70 3
a72 3
    private Class               returnType;
    private Class[]             parameterTypes;
    private Class[]             exceptionTypes;
a83 11
    // More complicated security check cache needed here than for
    // Class.newInstance() and Constructor.newInstance()
    private Class securityCheckCache;
    private Class securityCheckTargetClassCache;

    // Modifiers that can be applied to a method in source code
    private static final int LANGUAGE_MODIFIERS =
        Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
        Modifier.ABSTRACT       | Modifier.STATIC       | Modifier.FINAL   |
        Modifier.SYNCHRONIZED   | Modifier.NATIVE;

d110 1
a110 1
    Method(Class declaringClass,
d112 3
a114 3
           Class[] parameterTypes,
           Class returnType,
           Class[] checkedExceptions,
d192 2
a193 2
     *     the format specified in the Java Virtual Machine Specification,
     *     3rd edition
d228 2
a229 1
     *     specified in the Java Virtual Machine Specification, 3rd edition
d274 2
a275 1
     *     specified in the Java Virtual Machine Specification, 3rd edition
a311 4
     * <p>If an exception type is a parameterized type, the {@@code Type}
     * object returned for it must accurately reflect the actual type
     * parameters used in the source code.
     *
d319 2
a320 1
     *     specified in the Java Virtual Machine Specification, 3rd edition
d351 2
a352 2
                Class[] params1 = parameterTypes;
                Class[] params2 = other.parameterTypes;
d394 1
a394 1
     * {@@code synchronized}, {@@code native}.
d398 2
a399 2
            StringBuffer sb = new StringBuffer();
            int mod = getModifiers() & LANGUAGE_MODIFIERS;
d401 1
a401 1
                sb.append(Modifier.toString(mod) + " ");
d403 4
a406 4
            sb.append(Field.getTypeName(getReturnType()) + " ");
            sb.append(Field.getTypeName(getDeclaringClass()) + ".");
            sb.append(getName() + "(");
            Class[] params = parameterTypes; // avoid clone
d410 1
a410 1
                    sb.append(",");
d412 2
a413 2
            sb.append(")");
            Class[] exceptions = exceptionTypes; // avoid clone
d419 1
a419 1
                        sb.append(",");
d439 5
d459 1
a459 1
     * {@@code synchronized} {@@code native}.
d469 1
a469 1
            int mod = getModifiers() & LANGUAGE_MODIFIERS;
d471 1
a471 1
                sb.append(Modifier.toString(mod) + " ");
d476 1
a476 1
                sb.append("<");
d479 1
a479 1
                        sb.append(",");
d490 2
a491 1
                        Field.getTypeName((Class<?>)genRetType):genRetType.toString())  + " ");
d493 2
a494 2
            sb.append(Field.getTypeName(getDeclaringClass()) + ".");
            sb.append(getName() + "(");
d500 2
d504 1
a504 1
                    sb.append(",");
d506 1
a506 1
            sb.append(")");
d515 1
a515 1
                        sb.append(",");
d562 1
a562 1
     *              enforces Java language access control and the underlying
d588 3
a590 17
                Class caller = CallerID.getCallerID().getCallerClass();
                Class targetClass = ((obj == null || !Modifier.isProtected(modifiers))
                                     ? clazz
                                     : obj.getClass());

                boolean cached;
                synchronized (this) {
                    cached = (securityCheckCache == caller)
                            && (securityCheckTargetClassCache == targetClass);
                }
                if (!cached) {
                    Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);
                    synchronized (this) {
                        securityCheckCache = caller;
                        securityCheckTargetClassCache = targetClass;
                    }
                }
d593 5
a597 2
        if (methodAccessor == null) acquireMethodAccessor();
        return methodAccessor.invoke(obj, args, CallerID.getCallerID());
d641 1
a641 1
    private void acquireMethodAccessor() {
d648 4
a651 1
            return;
d653 2
a654 3
        // Otherwise fabricate one and propagate it up to the root
        tmp = reflectionFactory.newMethodAccessor(this);
        setMethodAccessor(tmp);
d693 1
a693 1
    private transient Map<Class, Annotation> declaredAnnotations;
d695 1
a695 1
    private synchronized  Map<Class, Annotation> declaredAnnotations() {
d702 1
a702 1
    static native Map<Class, Annotation> getDeclaredAnnotationsImpl(Object methodOrConstructor);
@


1.6
log
@Integrated OpenJDK 6 b10.
@
text
@d2 1
a2 1
 * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.5
log
@Merged OpenJDK 6 b10 whitespace and comment changes.
@
text
@d480 1
a480 1
            Type[] typeparms = getTypeParameters();
d484 1
a484 1
                for(Type typeparm: typeparms) {
d487 3
a489 4
                    if (typeparm instanceof Class)
                        sb.append(((Class)typeparm).getName());
                    else
                        sb.append(typeparm.toString());
d496 2
a497 2
            sb.append( ((genRetType instanceof Class)?
                        Field.getTypeName((Class)genRetType):genRetType.toString())  + " ");
a505 2
                if (isVarArgs() && (j == params.length - 1)) // replace T[] with T...
                    param = param.replaceFirst("\\[\\]$", "...");
@


1.4
log
@Converted tabs to spaces.
@
text
@d43 1
a43 1
 * A <code>Method</code> provides information about, and access to, a single method
d47 1
a47 1
 * <p>A <code>Method</code> permits widening conversions to occur when matching the
d49 1
a49 1
 * parameters, but it throws an <code>IllegalArgumentException</code> if a
d63 1
a63 1
    class Method extends AccessibleObject implements GenericDeclaration, 
d90 3
a92 3
    private static final int LANGUAGE_MODIFIERS = 
        Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE | 
        Modifier.ABSTRACT       | Modifier.STATIC       | Modifier.FINAL   |  
d102 1
a102 1
        return CoreReflectionFactory.make(this, MethodScope.make(this)); 
d110 1
a110 1
            genericInfo = MethodRepository.make(getGenericSignature(), 
d166 2
a167 2
     * Returns the <code>Class</code> object representing the class or interface
     * that declares the method represented by this <code>Method</code> object.
d174 2
a175 2
     * Returns the name of the method represented by this <code>Method</code> 
     * object, as a <code>String</code>.
d183 1
a183 1
     * by this <code>Method</code> object, as an integer. The <code>Modifier</code> class should
d193 1
a193 1
     * Returns an array of <tt>TypeVariable</tt> objects that represent the
d195 1
a195 1
     * <tt>GenericDeclaration</tt> object, in declaration order.  Returns an
d199 1
a199 1
     * @@return an array of <tt>TypeVariable</tt> objects that represent
d215 3
a217 3
     * Returns a <code>Class</code> object that represents the formal return type
     * of the method represented by this <code>Method</code> object.
     * 
d225 3
a227 3
     * Returns a <tt>Type</tt> object that represents the formal return 
     * type of the method represented by this <tt>Method</tt> object.
     * 
d229 1
a229 1
     * the <tt>Type</tt> object returned must accurately reflect
d231 1
a231 1
     * 
d235 1
a235 1
     * @@return  a <tt>Type</tt> object that represents the formal return 
d255 1
a255 1
     * Returns an array of <code>Class</code> objects that represent the formal
d257 1
a257 1
     * represented by this <code>Method</code> object.  Returns an array of length
d259 1
a259 1
     * 
d268 1
a268 1
     * Returns an array of <tt>Type</tt> objects that represent the formal
d270 1
a270 1
     * this <tt>Method</tt> object. Returns an array of length 0 if the
d272 1
a272 1
     * 
d274 1
a274 1
     * the <tt>Type</tt> object returned for it must accurately reflect
d277 1
a277 1
     * <p>If a formal parameter type is a type variable or a parameterized 
d302 1
a302 1
     * Returns an array of <code>Class</code> objects that represent 
d305 3
a307 3
     * represented by this <code>Method</code> object.  Returns an array of length
     * 0 if the method declares no exceptions in its <code>throws</code> clause.
     * 
d316 2
a317 2
     * Returns an array of <tt>Type</tt> objects that represent the 
     * exceptions declared to be thrown by this <tt>Method</tt> object. 
d319 3
a321 3
     * no exceptions in its <tt>throws</tt> clause.  
     * 
     * <p>If an exception type is a parameterized type, the <tt>Type</tt>
d325 1
a325 1
     * <p>If an exception type is a type variable or a parameterized 
d334 1
a334 1
     *     <tt>throws</tt> clause refers to a non-existent type declaration
d336 1
a336 1
     *     the underlying method's <tt>throws</tt> clause refers to a
d350 2
a351 2
     * Compares this <code>Method</code> against the specified object.  Returns
     * true if the objects are the same.  Two <code>Methods</code> are the same if
d378 1
a378 1
     * Returns a hashcode for this <code>Method</code>.  The hashcode is computed
d387 1
a387 1
     * Returns a string describing this <code>Method</code>.  The string is
d403 1
a403 1
     * <tt>public</tt>, <tt>protected</tt> or <tt>private</tt> first,
d405 2
a406 2
     * <tt>abstract</tt>, <tt>static</tt>, <tt>final</tt>,
     * <tt>synchronized</tt>, <tt>native</tt>.
d441 1
a441 1
     * Returns a string describing this <code>Method</code>, including
d449 1
a449 6
     * formal parameter types. 
     *
     * If this method was declared to take a variable number of
     * arguments, instead of denoting the last parameter as
     * "<code><i>Type</i>[]</code>", it is denoted as
     * "<code><i>Type</i></code>...".
d463 1
a463 1
     * <tt>public</tt>, <tt>protected</tt> or <tt>private</tt> first,
d465 2
a466 2
     * <tt>abstract</tt>, <tt>static</tt>, <tt>final</tt>,
     * <tt>synchronized</tt> <tt>native</tt>.
d468 1
a468 1
     * @@return a string describing this <code>Method</code>,
d532 1
a532 1
     * Invokes the underlying method represented by this <code>Method</code> 
d539 1
a539 1
     * <p>If the underlying method is static, then the specified <code>obj</code> 
d543 1
a543 1
     * 0, the supplied <code>args</code> array may be of length 0 or null.
d565 2
a566 2
     * this object on <code>obj</code> with parameters
     * <code>args</code>
d568 1
a568 1
     * @@exception IllegalAccessException    if this <code>Method</code> object
d619 2
a620 2
     * Returns <tt>true</tt> if this method is a bridge
     * method; returns <tt>false</tt> otherwise.
d631 2
a632 2
     * Returns <tt>true</tt> if this method was declared to take
     * a variable number of arguments; returns <tt>false</tt>
d635 1
a635 1
     * @@return <tt>true</tt> if an only if this method was declared to
d644 2
a645 2
     * Returns <tt>true</tt> if this method is a synthetic
     * method; returns <tt>false</tt> otherwise.
d722 1
a722 1
     * this <tt>Method</tt> instance.  If the member is of a primitive type,
d728 1
a728 1
     *     by this <tt>Method</tt> instance.
d739 1
a739 1
     * this <tt>Method</tt> object. (Returns an array of length zero if the
@


1.3
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@d64 3
a66 3
						     Member {
    private Class		clazz;
    private int			slot;
d69 5
a73 5
    private String		name;
    private Class		returnType;
    private Class[]		parameterTypes;
    private Class[]		exceptionTypes;
    private int			modifiers;
d91 3
a93 3
	Modifier.PUBLIC		| Modifier.PROTECTED	| Modifier.PRIVATE | 
	Modifier.ABSTRACT	| Modifier.STATIC	| Modifier.FINAL   |  
	Modifier.SYNCHRONIZED	| Modifier.NATIVE;
d101 2
a102 2
	// create scope and factory
	return CoreReflectionFactory.make(this, MethodScope.make(this)); 
d107 7
a113 7
	// lazily initialize repository if necessary
	if (genericInfo == null) {
	    // create and cache generic info repository
	    genericInfo = MethodRepository.make(getGenericSignature(), 
						getFactory());
	}
	return genericInfo; //return cached repository
d170 1
a170 1
	return clazz;
d178 1
a178 1
	return name;
d189 1
a189 1
	return modifiers;
d208 4
a211 4
	if (getGenericSignature() != null)
	    return (TypeVariable<Method>[])getGenericInfo().getTypeParameters();
	else
	    return (TypeVariable<Method>[])new TypeVariable[0];
d221 1
a221 1
	return returnType;
d249 1
a249 1
	return getGenericInfo().getReturnType();
d264 1
a264 1
	return (Class<?>[]) parameterTypes.clone();
d294 4
a297 4
	if (getGenericSignature() != null)
	    return getGenericInfo().getParameterTypes();
	else
	    return getParameterTypes();
d312 1
a312 1
	return (Class<?>[]) exceptionTypes.clone();
d341 6
a346 6
	  Type[] result;
	  if (getGenericSignature() != null &&
	      ((result = getGenericInfo().getExceptionTypes()).length > 0))
	      return result;
	  else
	      return getExceptionTypes();
d356 19
a374 19
	if (obj != null && obj instanceof Method) {
	    Method other = (Method)obj;
	    if ((getDeclaringClass() == other.getDeclaringClass())
		&& (getName() == other.getName())) {
		if (!returnType.equals(other.getReturnType()))
		    return false;
		/* Avoid unnecessary cloning */
		Class[] params1 = parameterTypes;
		Class[] params2 = other.parameterTypes;
		if (params1.length == params2.length) {
		    for (int i = 0; i < params1.length; i++) {
			if (params1[i] != params2[i])
			    return false;
		    }
		    return true;
		}
	    }
	}
	return false;
d383 1
a383 1
	return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
d409 29
a437 29
	try {
	    StringBuffer sb = new StringBuffer();
	    int mod = getModifiers() & LANGUAGE_MODIFIERS;
	    if (mod != 0) {
		sb.append(Modifier.toString(mod) + " ");
	    }
	    sb.append(Field.getTypeName(getReturnType()) + " ");
	    sb.append(Field.getTypeName(getDeclaringClass()) + ".");
	    sb.append(getName() + "(");
	    Class[] params = parameterTypes; // avoid clone
	    for (int j = 0; j < params.length; j++) {
		sb.append(Field.getTypeName(params[j]));
		if (j < (params.length - 1))
		    sb.append(",");
	    }
	    sb.append(")");
	    Class[] exceptions = exceptionTypes; // avoid clone
	    if (exceptions.length > 0) {
		sb.append(" throws ");
		for (int k = 0; k < exceptions.length; k++) {
		    sb.append(exceptions[k].getName());
		    if (k < (exceptions.length - 1))
			sb.append(",");
		}
	    }
	    return sb.toString();
	} catch (Exception e) {
	    return "<" + e + ">";
	}
d479 55
a533 55
	try {
	    StringBuilder sb = new StringBuilder();
	    int mod = getModifiers() & LANGUAGE_MODIFIERS;
	    if (mod != 0) {
		sb.append(Modifier.toString(mod) + " ");
	    }
	    Type[] typeparms = getTypeParameters();
	    if (typeparms.length > 0) {
		boolean first = true;
		sb.append("<");
		for(Type typeparm: typeparms) {
		    if (!first)
			sb.append(",");
		    if (typeparm instanceof Class)
			sb.append(((Class)typeparm).getName());
		    else
			sb.append(typeparm.toString());
		    first = false;
		}
		sb.append("> ");
	    }

	    Type genRetType = getGenericReturnType();
	    sb.append( ((genRetType instanceof Class)?
			Field.getTypeName((Class)genRetType):genRetType.toString())  + " ");

	    sb.append(Field.getTypeName(getDeclaringClass()) + ".");
	    sb.append(getName() + "(");
	    Type[] params = getGenericParameterTypes();
	    for (int j = 0; j < params.length; j++) {
		String param = (params[j] instanceof Class)?
		    Field.getTypeName((Class)params[j]):
		    (params[j].toString());
		if (isVarArgs() && (j == params.length - 1)) // replace T[] with T...
		    param = param.replaceFirst("\\[\\]$", "...");
		sb.append(param);
		if (j < (params.length - 1))
		    sb.append(",");
	    }
	    sb.append(")");
	    Type[] exceptions = getGenericExceptionTypes();
	    if (exceptions.length > 0) {
		sb.append(" throws ");
		for (int k = 0; k < exceptions.length; k++) {
		    sb.append((exceptions[k] instanceof Class)?
			      ((Class)exceptions[k]).getName():
			      exceptions[k].toString());
		    if (k < (exceptions.length - 1))
			sb.append(",");
		}
	    }
	    return sb.toString();
	} catch (Exception e) {
	    return "<" + e + ">";
	}
d595 1
a595 1
	throws IllegalAccessException, IllegalArgumentException,
d605 12
a616 12
		boolean cached;
		synchronized (this) {
		    cached = (securityCheckCache == caller)
			    && (securityCheckTargetClassCache == targetClass);
		}
		if (!cached) {
		    Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);
		    synchronized (this) {
			securityCheckCache = caller;
			securityCheckTargetClassCache = targetClass;
		    }
		}
d758 1
a758 1
	Annotation[][] result = getParameterAnnotationsImpl(this);
@


1.2
log
@- Simplified annotation handling.
- Added support to Class.forName() for assembly qualified Java type names.
@
text
@d28 1
d593 1
d600 1
a600 1
                Class caller = Reflection.getCallerClass(1);
d620 1
a620 1
        return methodAccessor.invoke(obj, args);
@


1.1
log
@Made method annotation resolution lazy to support annotations that annotate themselves.
@
text
@a76 3
    //private byte[]              annotations;
    //private byte[]              parameterAnnotations;
    //private byte[]              annotationDefault;
d128 3
a130 3
           byte[] annotations,
           byte[] parameterAnnotations,
           byte[] annotationDefault)
a139 3
        //this.annotations = annotations;
        //this.parameterAnnotations = parameterAnnotations;
        //this.annotationDefault = annotationDefault;
d157 1
a157 2
				null, null, null);
                                //annotations, parameterAnnotations, annotationDefault);
d716 1
a716 5
	    byte[] annotations = getRawAnnotations();
            declaredAnnotations = AnnotationParser.parseAnnotations(
                annotations, sun.misc.SharedSecrets.getJavaLangAccess().
                getConstantPool(getDeclaringClass()),
                getDeclaringClass());
d720 2
d737 1
a737 15
    public Object getDefaultValue() {
	byte[] annotationDefault = getRawAnnotationDefault();
        if  (annotationDefault == null)
            return null;
        Class memberType = AnnotationType.invocationHandlerReturnType(
            getReturnType());
        Object result = AnnotationParser.parseMemberValue(
            memberType, ByteBuffer.wrap(annotationDefault),
            sun.misc.SharedSecrets.getJavaLangAccess().
                getConstantPool(getDeclaringClass()),
            getDeclaringClass());
        if (result instanceof sun.reflect.annotation.ExceptionProxy)
            throw new AnnotationFormatError("Invalid default: " + this);
        return result;
    }
d756 1
a756 1
	byte[] parameterAnnotations = getRawParameterAnnotations();
d758 1
a758 1
        if (parameterAnnotations == null)
a760 5
        Annotation[][] result = AnnotationParser.parseParameterAnnotations(
            parameterAnnotations,
            sun.misc.SharedSecrets.getJavaLangAccess().
                getConstantPool(getDeclaringClass()),
            getDeclaringClass());
d767 1
a767 3
    private native byte[] getRawAnnotations();
    private native byte[] getRawParameterAnnotations();
    private native byte[] getRawAnnotationDefault();
@


1.1.2.1
log
@file Method.java was added on branch v0_36 on 2007-09-13 07:30:17 +0000
@
text
@d1 798
@


1.1.2.2
log
@Ported fixes from trunk. Changed version to 0.36.0.1.
@
text
@a0 798
/*
 * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Sun designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Sun in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 */

package java.lang.reflect;

import sun.reflect.MethodAccessor;
import sun.reflect.Reflection;
import sun.reflect.generics.repository.MethodRepository;
import sun.reflect.generics.factory.CoreReflectionFactory;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.scope.MethodScope;
import sun.reflect.annotation.AnnotationType;
import sun.reflect.annotation.AnnotationParser;
import java.lang.annotation.Annotation;
import java.lang.annotation.AnnotationFormatError;
import java.nio.ByteBuffer;
import java.util.Map;

/**
 * A <code>Method</code> provides information about, and access to, a single method
 * on a class or interface.  The reflected method may be a class method
 * or an instance method (including an abstract method).
 *
 * <p>A <code>Method</code> permits widening conversions to occur when matching the
 * actual parameters to invoke with the underlying method's formal
 * parameters, but it throws an <code>IllegalArgumentException</code> if a
 * narrowing conversion would occur.
 *
 * @@see Member
 * @@see java.lang.Class
 * @@see java.lang.Class#getMethods()
 * @@see java.lang.Class#getMethod(String, Class[])
 * @@see java.lang.Class#getDeclaredMethods()
 * @@see java.lang.Class#getDeclaredMethod(String, Class[])
 *
 * @@author Kenneth Russell
 * @@author Nakul Saraiya
 */
public final
    class Method extends AccessibleObject implements GenericDeclaration, 
						     Member {
    private Class		clazz;
    private int			slot;
    // This is guaranteed to be interned by the VM in the 1.4
    // reflection implementation
    private String		name;
    private Class		returnType;
    private Class[]		parameterTypes;
    private Class[]		exceptionTypes;
    private int			modifiers;
    // Generics and annotations support
    private transient String              signature;
    // generic info repository; lazily initialized
    private transient MethodRepository genericInfo;
    //private byte[]              annotations;
    //private byte[]              parameterAnnotations;
    //private byte[]              annotationDefault;
    private volatile MethodAccessor methodAccessor;
    // For sharing of MethodAccessors. This branching structure is
    // currently only two levels deep (i.e., one root Method and
    // potentially many Method objects pointing to it.)
    private Method              root;

    // More complicated security check cache needed here than for
    // Class.newInstance() and Constructor.newInstance()
    private Class securityCheckCache;
    private Class securityCheckTargetClassCache;

    // Modifiers that can be applied to a method in source code
    private static final int LANGUAGE_MODIFIERS = 
	Modifier.PUBLIC		| Modifier.PROTECTED	| Modifier.PRIVATE | 
	Modifier.ABSTRACT	| Modifier.STATIC	| Modifier.FINAL   |  
	Modifier.SYNCHRONIZED	| Modifier.NATIVE;

   // Generics infrastructure

    private String getGenericSignature() {return signature;}

    // Accessor for factory
    private GenericsFactory getFactory() {
	// create scope and factory
	return CoreReflectionFactory.make(this, MethodScope.make(this)); 
    }

    // Accessor for generic info repository
    private MethodRepository getGenericInfo() {
	// lazily initialize repository if necessary
	if (genericInfo == null) {
	    // create and cache generic info repository
	    genericInfo = MethodRepository.make(getGenericSignature(), 
						getFactory());
	}
	return genericInfo; //return cached repository
    }

    /**
     * Package-private constructor used by ReflectAccess to enable
     * instantiation of these objects in Java code from the java.lang
     * package via sun.reflect.LangReflectAccess.
     */
    Method(Class declaringClass,
           String name,
           Class[] parameterTypes,
           Class returnType,
           Class[] checkedExceptions,
           int modifiers,
           int slot,
           String signature,
           byte[] annotations,
           byte[] parameterAnnotations,
           byte[] annotationDefault)
    {
        this.clazz = declaringClass;
        this.name = name;
        this.parameterTypes = parameterTypes;
        this.returnType = returnType;
        this.exceptionTypes = checkedExceptions;
        this.modifiers = modifiers;
        this.slot = slot;
        this.signature = signature;
        //this.annotations = annotations;
        //this.parameterAnnotations = parameterAnnotations;
        //this.annotationDefault = annotationDefault;
    }

    /**
     * Package-private routine (exposed to java.lang.Class via
     * ReflectAccess) which returns a copy of this Method. The copy's
     * "root" field points to this Method.
     */
    Method copy() {
        // This routine enables sharing of MethodAccessor objects
        // among Method objects which refer to the same underlying
        // method in the VM. (All of this contortion is only necessary
        // because of the "accessibility" bit in AccessibleObject,
        // which implicitly requires that new java.lang.reflect
        // objects be fabricated for each reflective call on Class
        // objects.)
        Method res = new Method(clazz, name, parameterTypes, returnType,
                                exceptionTypes, modifiers, slot, signature,
				null, null, null);
                                //annotations, parameterAnnotations, annotationDefault);
        res.root = this;
        // Might as well eagerly propagate this if already present
        res.methodAccessor = methodAccessor;
        return res;
    }

    /**
     * Returns the <code>Class</code> object representing the class or interface
     * that declares the method represented by this <code>Method</code> object.
     */
    public Class<?> getDeclaringClass() {
	return clazz;
    }

    /**
     * Returns the name of the method represented by this <code>Method</code> 
     * object, as a <code>String</code>.
     */
    public String getName() {
	return name;
    }

    /**
     * Returns the Java language modifiers for the method represented
     * by this <code>Method</code> object, as an integer. The <code>Modifier</code> class should
     * be used to decode the modifiers.
     *
     * @@see Modifier
     */
    public int getModifiers() {
	return modifiers;
    }

    /**
     * Returns an array of <tt>TypeVariable</tt> objects that represent the
     * type variables declared by the generic declaration represented by this
     * <tt>GenericDeclaration</tt> object, in declaration order.  Returns an
     * array of length 0 if the underlying generic declaration declares no type
     * variables.
     *
     * @@return an array of <tt>TypeVariable</tt> objects that represent
     *     the type variables declared by this generic declaration
     * @@throws GenericSignatureFormatError if the generic
     *     signature of this generic declaration does not conform to
     *     the format specified in the Java Virtual Machine Specification,
     *     3rd edition
     * @@since 1.5
     */
    public TypeVariable<Method>[] getTypeParameters() {
	if (getGenericSignature() != null)
	    return (TypeVariable<Method>[])getGenericInfo().getTypeParameters();
	else
	    return (TypeVariable<Method>[])new TypeVariable[0];
    }

    /**
     * Returns a <code>Class</code> object that represents the formal return type
     * of the method represented by this <code>Method</code> object.
     * 
     * @@return the return type for the method this object represents
     */
    public Class<?> getReturnType() {
	return returnType;
    }

    /**
     * Returns a <tt>Type</tt> object that represents the formal return 
     * type of the method represented by this <tt>Method</tt> object.
     * 
     * <p>If the return type is a parameterized type,
     * the <tt>Type</tt> object returned must accurately reflect
     * the actual type parameters used in the source code.
     * 
     * <p>If the return type is a type variable or a parameterized type, it
     * is created. Otherwise, it is resolved.
     *
     * @@return  a <tt>Type</tt> object that represents the formal return 
     *     type of the underlying  method
     * @@throws GenericSignatureFormatError
     *     if the generic method signature does not conform to the format
     *     specified in the Java Virtual Machine Specification, 3rd edition
     * @@throws TypeNotPresentException if the underlying method's
     *     return type refers to a non-existent type declaration
     * @@throws MalformedParameterizedTypeException if the
     *     underlying method's return typed refers to a parameterized
     *     type that cannot be instantiated for any reason
     * @@since 1.5
     */
    public Type getGenericReturnType() {
      if (getGenericSignature() != null) {
	return getGenericInfo().getReturnType();
      } else { return getReturnType();}
    }


    /**
     * Returns an array of <code>Class</code> objects that represent the formal
     * parameter types, in declaration order, of the method
     * represented by this <code>Method</code> object.  Returns an array of length
     * 0 if the underlying method takes no parameters.
     * 
     * @@return the parameter types for the method this object
     * represents
     */
    public Class<?>[] getParameterTypes() {
	return (Class<?>[]) parameterTypes.clone();
    }

    /**
     * Returns an array of <tt>Type</tt> objects that represent the formal
     * parameter types, in declaration order, of the method represented by
     * this <tt>Method</tt> object. Returns an array of length 0 if the
     * underlying method takes no parameters.
     * 
     * <p>If a formal parameter type is a parameterized type,
     * the <tt>Type</tt> object returned for it must accurately reflect
     * the actual type parameters used in the source code.
     *
     * <p>If a formal parameter type is a type variable or a parameterized 
     * type, it is created. Otherwise, it is resolved.
     *
     * @@return an array of Types that represent the formal
     *     parameter types of the underlying method, in declaration order
     * @@throws GenericSignatureFormatError
     *     if the generic method signature does not conform to the format
     *     specified in the Java Virtual Machine Specification, 3rd edition
     * @@throws TypeNotPresentException if any of the parameter
     *     types of the underlying method refers to a non-existent type
     *     declaration
     * @@throws MalformedParameterizedTypeException if any of
     *     the underlying method's parameter types refer to a parameterized
     *     type that cannot be instantiated for any reason
     * @@since 1.5
     */
    public Type[] getGenericParameterTypes() {
	if (getGenericSignature() != null)
	    return getGenericInfo().getParameterTypes();
	else
	    return getParameterTypes();
    }


    /**
     * Returns an array of <code>Class</code> objects that represent 
     * the types of the exceptions declared to be thrown
     * by the underlying method
     * represented by this <code>Method</code> object.  Returns an array of length
     * 0 if the method declares no exceptions in its <code>throws</code> clause.
     * 
     * @@return the exception types declared as being thrown by the
     * method this object represents
     */
    public Class<?>[] getExceptionTypes() {
	return (Class<?>[]) exceptionTypes.clone();
    }

    /**
     * Returns an array of <tt>Type</tt> objects that represent the 
     * exceptions declared to be thrown by this <tt>Method</tt> object. 
     * Returns an array of length 0 if the underlying method declares
     * no exceptions in its <tt>throws</tt> clause.  
     * 
     * <p>If an exception type is a parameterized type, the <tt>Type</tt>
     * object returned for it must accurately reflect the actual type
     * parameters used in the source code.
     *
     * <p>If an exception type is a type variable or a parameterized 
     * type, it is created. Otherwise, it is resolved.
     *
     * @@return an array of Types that represent the exception types
     *     thrown by the underlying method
     * @@throws GenericSignatureFormatError
     *     if the generic method signature does not conform to the format
     *     specified in the Java Virtual Machine Specification, 3rd edition
     * @@throws TypeNotPresentException if the underlying method's
     *     <tt>throws</tt> clause refers to a non-existent type declaration
     * @@throws MalformedParameterizedTypeException if
     *     the underlying method's <tt>throws</tt> clause refers to a
     *     parameterized type that cannot be instantiated for any reason
     * @@since 1.5
     */
      public Type[] getGenericExceptionTypes() {
	  Type[] result;
	  if (getGenericSignature() != null &&
	      ((result = getGenericInfo().getExceptionTypes()).length > 0))
	      return result;
	  else
	      return getExceptionTypes();
      }

    /**
     * Compares this <code>Method</code> against the specified object.  Returns
     * true if the objects are the same.  Two <code>Methods</code> are the same if
     * they were declared by the same class and have the same name
     * and formal parameter types and return type.
     */
    public boolean equals(Object obj) {
	if (obj != null && obj instanceof Method) {
	    Method other = (Method)obj;
	    if ((getDeclaringClass() == other.getDeclaringClass())
		&& (getName() == other.getName())) {
		if (!returnType.equals(other.getReturnType()))
		    return false;
		/* Avoid unnecessary cloning */
		Class[] params1 = parameterTypes;
		Class[] params2 = other.parameterTypes;
		if (params1.length == params2.length) {
		    for (int i = 0; i < params1.length; i++) {
			if (params1[i] != params2[i])
			    return false;
		    }
		    return true;
		}
	    }
	}
	return false;
    }

    /**
     * Returns a hashcode for this <code>Method</code>.  The hashcode is computed
     * as the exclusive-or of the hashcodes for the underlying
     * method's declaring class name and the method's name.
     */
    public int hashCode() {
	return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
    }

    /**
     * Returns a string describing this <code>Method</code>.  The string is
     * formatted as the method access modifiers, if any, followed by
     * the method return type, followed by a space, followed by the
     * class declaring the method, followed by a period, followed by
     * the method name, followed by a parenthesized, comma-separated
     * list of the method's formal parameter types. If the method
     * throws checked exceptions, the parameter list is followed by a
     * space, followed by the word throws followed by a
     * comma-separated list of the thrown exception types.
     * For example:
     * <pre>
     *    public boolean java.lang.Object.equals(java.lang.Object)
     * </pre>
     *
     * <p>The access modifiers are placed in canonical order as
     * specified by "The Java Language Specification".  This is
     * <tt>public</tt>, <tt>protected</tt> or <tt>private</tt> first,
     * and then other modifiers in the following order:
     * <tt>abstract</tt>, <tt>static</tt>, <tt>final</tt>,
     * <tt>synchronized</tt>, <tt>native</tt>.
     */
    public String toString() {
	try {
	    StringBuffer sb = new StringBuffer();
	    int mod = getModifiers() & LANGUAGE_MODIFIERS;
	    if (mod != 0) {
		sb.append(Modifier.toString(mod) + " ");
	    }
	    sb.append(Field.getTypeName(getReturnType()) + " ");
	    sb.append(Field.getTypeName(getDeclaringClass()) + ".");
	    sb.append(getName() + "(");
	    Class[] params = parameterTypes; // avoid clone
	    for (int j = 0; j < params.length; j++) {
		sb.append(Field.getTypeName(params[j]));
		if (j < (params.length - 1))
		    sb.append(",");
	    }
	    sb.append(")");
	    Class[] exceptions = exceptionTypes; // avoid clone
	    if (exceptions.length > 0) {
		sb.append(" throws ");
		for (int k = 0; k < exceptions.length; k++) {
		    sb.append(exceptions[k].getName());
		    if (k < (exceptions.length - 1))
			sb.append(",");
		}
	    }
	    return sb.toString();
	} catch (Exception e) {
	    return "<" + e + ">";
	}
    }

    /**
     * Returns a string describing this <code>Method</code>, including
     * type parameters.  The string is formatted as the method access
     * modifiers, if any, followed by an angle-bracketed
     * comma-separated list of the method's type parameters, if any,
     * followed by the method's generic return type, followed by a
     * space, followed by the class declaring the method, followed by
     * a period, followed by the method name, followed by a
     * parenthesized, comma-separated list of the method's generic
     * formal parameter types. 
     *
     * If this method was declared to take a variable number of
     * arguments, instead of denoting the last parameter as
     * "<code><i>Type</i>[]</code>", it is denoted as
     * "<code><i>Type</i></code>...".
     *
     * A space is used to separate access modifiers from one another
     * and from the type parameters or return type.  If there are no
     * type parameters, the type parameter list is elided; if the type
     * parameter list is present, a space separates the list from the
     * class name.  If the method is declared to throw exceptions, the
     * parameter list is followed by a space, followed by the word
     * throws followed by a comma-separated list of the generic thrown
     * exception types.  If there are no type parameters, the type
     * parameter list is elided.
     *
     * <p>The access modifiers are placed in canonical order as
     * specified by "The Java Language Specification".  This is
     * <tt>public</tt>, <tt>protected</tt> or <tt>private</tt> first,
     * and then other modifiers in the following order:
     * <tt>abstract</tt>, <tt>static</tt>, <tt>final</tt>,
     * <tt>synchronized</tt> <tt>native</tt>.
     *
     * @@return a string describing this <code>Method</code>,
     * include type parameters
     *
     * @@since 1.5
     */
    public String toGenericString() {
	try {
	    StringBuilder sb = new StringBuilder();
	    int mod = getModifiers() & LANGUAGE_MODIFIERS;
	    if (mod != 0) {
		sb.append(Modifier.toString(mod) + " ");
	    }
	    Type[] typeparms = getTypeParameters();
	    if (typeparms.length > 0) {
		boolean first = true;
		sb.append("<");
		for(Type typeparm: typeparms) {
		    if (!first)
			sb.append(",");
		    if (typeparm instanceof Class)
			sb.append(((Class)typeparm).getName());
		    else
			sb.append(typeparm.toString());
		    first = false;
		}
		sb.append("> ");
	    }

	    Type genRetType = getGenericReturnType();
	    sb.append( ((genRetType instanceof Class)?
			Field.getTypeName((Class)genRetType):genRetType.toString())  + " ");

	    sb.append(Field.getTypeName(getDeclaringClass()) + ".");
	    sb.append(getName() + "(");
	    Type[] params = getGenericParameterTypes();
	    for (int j = 0; j < params.length; j++) {
		String param = (params[j] instanceof Class)?
		    Field.getTypeName((Class)params[j]):
		    (params[j].toString());
		if (isVarArgs() && (j == params.length - 1)) // replace T[] with T...
		    param = param.replaceFirst("\\[\\]$", "...");
		sb.append(param);
		if (j < (params.length - 1))
		    sb.append(",");
	    }
	    sb.append(")");
	    Type[] exceptions = getGenericExceptionTypes();
	    if (exceptions.length > 0) {
		sb.append(" throws ");
		for (int k = 0; k < exceptions.length; k++) {
		    sb.append((exceptions[k] instanceof Class)?
			      ((Class)exceptions[k]).getName():
			      exceptions[k].toString());
		    if (k < (exceptions.length - 1))
			sb.append(",");
		}
	    }
	    return sb.toString();
	} catch (Exception e) {
	    return "<" + e + ">";
	}
    }

    /**
     * Invokes the underlying method represented by this <code>Method</code> 
     * object, on the specified object with the specified parameters.
     * Individual parameters are automatically unwrapped to match
     * primitive formal parameters, and both primitive and reference
     * parameters are subject to method invocation conversions as
     * necessary.
     *
     * <p>If the underlying method is static, then the specified <code>obj</code> 
     * argument is ignored. It may be null.
     *
     * <p>If the number of formal parameters required by the underlying method is
     * 0, the supplied <code>args</code> array may be of length 0 or null.
     *
     * <p>If the underlying method is an instance method, it is invoked
     * using dynamic method lookup as documented in The Java Language
     * Specification, Second Edition, section 15.12.4.4; in particular,
     * overriding based on the runtime type of the target object will occur.
     *
     * <p>If the underlying method is static, the class that declared
     * the method is initialized if it has not already been initialized.
     *
     * <p>If the method completes normally, the value it returns is
     * returned to the caller of invoke; if the value has a primitive
     * type, it is first appropriately wrapped in an object. However,
     * if the value has the type of an array of a primitive type, the
     * elements of the array are <i>not</i> wrapped in objects; in
     * other words, an array of primitive type is returned.  If the
     * underlying method return type is void, the invocation returns
     * null.
     *
     * @@param obj  the object the underlying method is invoked from
     * @@param args the arguments used for the method call
     * @@return the result of dispatching the method represented by
     * this object on <code>obj</code> with parameters
     * <code>args</code>
     *
     * @@exception IllegalAccessException    if this <code>Method</code> object
     *              enforces Java language access control and the underlying
     *              method is inaccessible.
     * @@exception IllegalArgumentException  if the method is an
     *              instance method and the specified object argument
     *              is not an instance of the class or interface
     *              declaring the underlying method (or of a subclass
     *              or implementor thereof); if the number of actual
     *              and formal parameters differ; if an unwrapping
     *              conversion for primitive arguments fails; or if,
     *              after possible unwrapping, a parameter value
     *              cannot be converted to the corresponding formal
     *              parameter type by a method invocation conversion.
     * @@exception InvocationTargetException if the underlying method
     *              throws an exception.
     * @@exception NullPointerException      if the specified object is null
     *              and the method is an instance method.
     * @@exception ExceptionInInitializerError if the initialization
     * provoked by this method fails.
     */
    public Object invoke(Object obj, Object... args)
	throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class caller = Reflection.getCallerClass(1);
                Class targetClass = ((obj == null || !Modifier.isProtected(modifiers))
                                     ? clazz
                                     : obj.getClass());

		boolean cached;
		synchronized (this) {
		    cached = (securityCheckCache == caller)
			    && (securityCheckTargetClassCache == targetClass);
		}
		if (!cached) {
		    Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);
		    synchronized (this) {
			securityCheckCache = caller;
			securityCheckTargetClassCache = targetClass;
		    }
		}
            }
        }
        if (methodAccessor == null) acquireMethodAccessor();
        return methodAccessor.invoke(obj, args);
    }

    /**
     * Returns <tt>true</tt> if this method is a bridge
     * method; returns <tt>false</tt> otherwise.
     *
     * @@return true if and only if this method is a bridge
     * method as defined by the Java Language Specification.
     * @@since 1.5
     */
    public boolean isBridge() {
        return (getModifiers() & Modifier.BRIDGE) != 0;
    }

    /**
     * Returns <tt>true</tt> if this method was declared to take
     * a variable number of arguments; returns <tt>false</tt>
     * otherwise.
     *
     * @@return <tt>true</tt> if an only if this method was declared to
     * take a variable number of arguments.
     * @@since 1.5
     */
    public boolean isVarArgs() {
        return (getModifiers() & Modifier.VARARGS) != 0;
    }

    /**
     * Returns <tt>true</tt> if this method is a synthetic
     * method; returns <tt>false</tt> otherwise.
     *
     * @@return true if and only if this method is a synthetic
     * method as defined by the Java Language Specification.
     * @@since 1.5
     */
    public boolean isSynthetic() {
        return Modifier.isSynthetic(getModifiers());
    }

    // NOTE that there is no synchronization used here. It is correct
    // (though not efficient) to generate more than one MethodAccessor
    // for a given Method. However, avoiding synchronization will
    // probably make the implementation more scalable.
    private void acquireMethodAccessor() {
        // First check to see if one has been created yet, and take it
        // if so
        MethodAccessor tmp = null;
        if (root != null) tmp = root.getMethodAccessor();
        if (tmp != null) {
            methodAccessor = tmp;
            return;
        }
        // Otherwise fabricate one and propagate it up to the root
        tmp = reflectionFactory.newMethodAccessor(this);
        setMethodAccessor(tmp);
    }

    // Returns MethodAccessor for this Method object, not looking up
    // the chain to the root
    MethodAccessor getMethodAccessor() {
        return methodAccessor;
    }

    // Sets the MethodAccessor for this Method object and
    // (recursively) its root
    void setMethodAccessor(MethodAccessor accessor) {
        methodAccessor = accessor;
        // Propagate up
        if (root != null) {
            root.setMethodAccessor(accessor);
        }
    }

    /**
     * @@throws NullPointerException {@@inheritDoc}
     * @@since 1.5
     */
    public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
        if (annotationClass == null)
            throw new NullPointerException();

        return (T) declaredAnnotations().get(annotationClass);
    }

    private static final Annotation[] EMPTY_ANNOTATION_ARRAY=new Annotation[0];

    /**
     * @@since 1.5
     */
    public Annotation[] getDeclaredAnnotations()  {
        return declaredAnnotations().values().toArray(EMPTY_ANNOTATION_ARRAY);
    }

    private transient Map<Class, Annotation> declaredAnnotations;

    private synchronized  Map<Class, Annotation> declaredAnnotations() {
        if (declaredAnnotations == null) {
	    byte[] annotations = getRawAnnotations();
            declaredAnnotations = AnnotationParser.parseAnnotations(
                annotations, sun.misc.SharedSecrets.getJavaLangAccess().
                getConstantPool(getDeclaringClass()),
                getDeclaringClass());
        }
        return declaredAnnotations;
    }

    /**
     * Returns the default value for the annotation member represented by
     * this <tt>Method</tt> instance.  If the member is of a primitive type,
     * an instance of the corresponding wrapper type is returned. Returns
     * null if no default is associated with the member, or if the method
     * instance does not represent a declared member of an annotation type.
     *
     * @@return the default value for the annotation member represented
     *     by this <tt>Method</tt> instance.
     * @@throws TypeNotPresentException if the annotation is of type
     *     {@@link Class} and no definition can be found for the
     *     default class value.
     * @@since  1.5
     */
    public Object getDefaultValue() {
	byte[] annotationDefault = getRawAnnotationDefault();
        if  (annotationDefault == null)
            return null;
        Class memberType = AnnotationType.invocationHandlerReturnType(
            getReturnType());
        Object result = AnnotationParser.parseMemberValue(
            memberType, ByteBuffer.wrap(annotationDefault),
            sun.misc.SharedSecrets.getJavaLangAccess().
                getConstantPool(getDeclaringClass()),
            getDeclaringClass());
        if (result instanceof sun.reflect.annotation.ExceptionProxy)
            throw new AnnotationFormatError("Invalid default: " + this);
        return result;
    }

    /**
     * Returns an array of arrays that represent the annotations on the formal
     * parameters, in declaration order, of the method represented by
     * this <tt>Method</tt> object. (Returns an array of length zero if the
     * underlying method is parameterless.  If the method has one or more
     * parameters, a nested array of length zero is returned for each parameter
     * with no annotations.) The annotation objects contained in the returned
     * arrays are serializable.  The caller of this method is free to modify
     * the returned arrays; it will have no effect on the arrays returned to
     * other callers.
     *
     * @@return an array of arrays that represent the annotations on the formal
     *    parameters, in declaration order, of the method represented by this
     *    Method object
     * @@since 1.5
     */
    public Annotation[][] getParameterAnnotations() {
	byte[] parameterAnnotations = getRawParameterAnnotations();
        int numParameters = parameterTypes.length;
        if (parameterAnnotations == null)
            return new Annotation[numParameters][0];

        Annotation[][] result = AnnotationParser.parseParameterAnnotations(
            parameterAnnotations,
            sun.misc.SharedSecrets.getJavaLangAccess().
                getConstantPool(getDeclaringClass()),
            getDeclaringClass());
        if (result.length != numParameters)
            throw new java.lang.annotation.AnnotationFormatError(
                "Parameter annotations don't match number of parameters");
        return result;
    }

    private native byte[] getRawAnnotations();
    private native byte[] getRawParameterAnnotations();
    private native byte[] getRawAnnotationDefault();
}
@


