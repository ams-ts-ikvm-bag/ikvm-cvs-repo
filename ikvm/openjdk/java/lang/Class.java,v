head	1.24;
access;
symbols
	v8_1_5717_0:1.24
	v8_1:1.24.0.2
	v8_0_5449_1:1.22
	v8_0_5449_0:1.22
	v8_0:1.22.0.2
	v7_4_5196_0:1.19
	v7_4:1.19.0.2
	v7_3:1.16.0.6
	v7_2_4630_6:1.16
	v7_2_4630_5:1.16
	v7_2_4630_4:1.16
	v7_2_4630_3:1.16
	v7_2_4630_2:1.16
	v0_46_0_4:1.14
	v7_2_4630_1:1.16
	v7_2:1.16.0.4
	v7_1_4532_2:1.16
	v7_1_4532_1:1.16
	v7_1_4532_0:1.16
	v7_1:1.16.0.2
	v7_0_4335_3:1.15
	v7_0_4335_2:1.15
	v7_0_4335_1:1.15
	v0_46_0_2:1.14
	v7_0_4335_0:1.15
	v7_0:1.15.0.2
	v0_40_0_6:1.8
	v0_40_0_5:1.8
	v0_46_0_1:1.14
	v0_46_0_0:1.14
	v0_46:1.14.0.2
	v0_44_0_6:1.13
	v0_44_0_5:1.13
	v0_44_0_4:1.13
	v0_44_0_3:1.13
	v0_44_0_2:1.13
	v0_42_0_7:1.12
	v0_44_0_1:1.13
	v0_44_0_0:1.13
	v0_44:1.13.0.2
	v0_42_0_6:1.12
	v0_42_0_5:1.12
	v0_42_0_4:1.12
	v0_42_0_3:1.12
	v0_42_0_2:1.12
	v0_42_0_1:1.12
	v0_42_0_0:1.12
	v0_42:1.12.0.2
	v0_40_0_3:1.8
	v0_40_0_2:1.8
	v0_40_0_1:1.8
	v0_40_0_0:1.8
	v0_40:1.8.0.2
	v0_38_0_1:1.7
	v0_38_0_0:1.7
	v0_38:1.7.0.2;
locks; strict;
comment	@# @;


1.24
date	2015.06.25.13.30.12;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2015.06.09.09.28.43;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2014.07.07.07.40.35;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.27.12.32.26;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.19.12.43.38;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2014.02.20.16.51.25;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2014.02.04.09.25.17;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2013.08.12.07.55.57;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2012.05.23.10.00.03;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.19.12.04.11;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.24.16.40.22;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.12.04.17.40;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.29.07.04.42;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.28.13.01.25;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.16.06.15.08;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.14.06.27.41;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2009.02.27.05.53.27;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.13.09.01.09;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.12.09.09.24;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.11.09.05.15;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.31.15.20.32;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.23.04.25.48;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2008.03.03.08.28.23;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2008.02.19.16.52.54;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Moved ClassSerializationProxy into its own source file.
@
text
@/*
 * Copyright (c) 1994, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;

import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.GenericDeclaration;
import java.lang.reflect.Member;
import java.lang.reflect.Field;
import java.lang.reflect.Executable;
import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.AnnotatedType;
import java.lang.ref.SoftReference;
import java.io.InputStream;
import java.io.ObjectStreamField;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.util.Objects;
import sun.misc.Unsafe;
import sun.reflect.CallerSensitive;
import sun.reflect.ConstantPool;
import sun.reflect.Reflection;
import sun.reflect.ReflectionFactory;
import sun.reflect.generics.factory.CoreReflectionFactory;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.repository.ClassRepository;
import sun.reflect.generics.repository.MethodRepository;
import sun.reflect.generics.repository.ConstructorRepository;
import sun.reflect.generics.scope.ClassScope;
import sun.security.util.SecurityConstants;
import java.lang.annotation.Annotation;
import java.lang.reflect.Proxy;
import sun.reflect.annotation.*;
import sun.reflect.misc.ReflectUtil;
import cli.System.Runtime.Serialization.SerializationInfo;
import cli.System.Runtime.Serialization.StreamingContext;

/**
 * Instances of the class {@@code Class} represent classes and
 * interfaces in a running Java application.  An enum is a kind of
 * class and an annotation is a kind of interface.  Every array also
 * belongs to a class that is reflected as a {@@code Class} object
 * that is shared by all arrays with the same element type and number
 * of dimensions.  The primitive Java types ({@@code boolean},
 * {@@code byte}, {@@code char}, {@@code short},
 * {@@code int}, {@@code long}, {@@code float}, and
 * {@@code double}), and the keyword {@@code void} are also
 * represented as {@@code Class} objects.
 *
 * <p> {@@code Class} has no public constructor. Instead {@@code Class}
 * objects are constructed automatically by the Java Virtual Machine as classes
 * are loaded and by calls to the {@@code defineClass} method in the class
 * loader.
 *
 * <p> The following example uses a {@@code Class} object to print the
 * class name of an object:
 *
 * <blockquote><pre>
 *     void printClassName(Object obj) {
 *         System.out.println("The class of " + obj +
 *                            " is " + obj.getClass().getName());
 *     }
 * </pre></blockquote>
 *
 * <p> It is also possible to get the {@@code Class} object for a named
 * type (or for void) using a class literal.  See Section 15.8.2 of
 * <cite>The Java&trade; Language Specification</cite>.
 * For example:
 *
 * <blockquote>
 *     {@@code System.out.println("The name of class Foo is: "+Foo.class.getName());}
 * </blockquote>
 *
 * @@param <T> the type of the class modeled by this {@@code Class}
 * object.  For example, the type of {@@code String.class} is {@@code
 * Class<String>}.  Use {@@code Class<?>} if the class being modeled is
 * unknown.
 *
 * @@author  unascribed
 * @@see     java.lang.ClassLoader#defineClass(byte[], int, int)
 * @@since   JDK1.0
 */
@@cli.System.SerializableAttribute.Annotation
public final class Class<T> implements java.io.Serializable,
                              GenericDeclaration,
                              Type,
                              AnnotatedElement {
    private static final int ANNOTATION= 0x00002000;
    private static final int ENUM      = 0x00004000;
    private static final int SYNTHETIC = 0x00001000;

    // [IKVM] additional fields
    java.security.ProtectionDomain pd;
    Object[] signers;

    // For types that live in a static .NET assembly (i.e. ikvmc compiled or .NET types)
    // this field contains the type (used for .NET serialization of Class objects).
    // This field is also used by fast class literals to remember the type that can then
    // lazily be resolved to the corresponding TypeWrapper.
    // For dynamically loaded classes and primitives it is null.
    final cli.System.Type type;

    /*
     * Private constructor. Only the Java Virtual Machine creates Class objects.
     * This constructor is not used and prevents the default constructor being
     * generated.
     */
    private Class(ClassLoader loader) {
        // Initialize final field for classLoader.  The initialization value of non-null
        // prevents future JIT optimizations from assuming this final field is null.
        //classLoader = loader;
        throw new InternalError();
    }

    @@cli.IKVM.Attributes.HideFromJavaAttribute.Annotation
    Class(cli.System.Type type)
    {
        this.type = type;
    }
    
    // We use custom serialization, because we want to deserialize a via proxy that properly resolves the Class singletons.
    // Note that we don't implement ISerializable in this source, but in map.xml to avoid it being visible to Java code.
    // We don't have a security demand, because the information exposed is harmless.
    @@cli.IKVM.Attributes.HideFromJavaAttribute.Annotation
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        info.AddValue("type", type);
        info.AddValue("sig", type == null ? getSigName() : null);
        info.SetType(ikvm.runtime.Util.getInstanceTypeFromClass(ClassSerializationProxy.class));
    }

    private native String getSigName();

    // [IKVM] this provides an implicit conversion operator from System.Type to java.lang.Class
    @@cli.System.Runtime.CompilerServices.SpecialNameAttribute.Annotation
    @@cli.IKVM.Attributes.HideFromJavaAttribute.Annotation
    public static Class op_Implicit(cli.System.Type type)
    {
        return ikvm.runtime.Util.getFriendlyClassFromType(type);
    }

    /**
     * Converts the object to a string. The string representation is the
     * string "class" or "interface", followed by a space, and then by the
     * fully qualified name of the class in the format returned by
     * {@@code getName}.  If this {@@code Class} object represents a
     * primitive type, this method returns the name of the primitive type.  If
     * this {@@code Class} object represents void this method returns
     * "void".
     *
     * @@return a string representation of this class object.
     */
    public String toString() {
        return (isInterface() ? "interface " : (isPrimitive() ? "" : "class "))
            + getName();
    }

    /**
     * Returns a string describing this {@@code Class}, including
     * information about modifiers and type parameters.
     *
     * The string is formatted as a list of type modifiers, if any,
     * followed by the kind of type (empty string for primitive types
     * and {@@code class}, {@@code enum}, {@@code interface}, or
     * <code>&#64;</code>{@@code interface}, as appropriate), followed
     * by the type's name, followed by an angle-bracketed
     * comma-separated list of the type's type parameters, if any.
     *
     * A space is used to separate modifiers from one another and to
     * separate any modifiers from the kind of type. The modifiers
     * occur in canonical order. If there are no type parameters, the
     * type parameter list is elided.
     *
     * <p>Note that since information about the runtime representation
     * of a type is being generated, modifiers not present on the
     * originating source code or illegal on the originating source
     * code may be present.
     *
     * @@return a string describing this {@@code Class}, including
     * information about modifiers and type parameters
     *
     * @@since 1.8
     */
    public String toGenericString() {
        if (isPrimitive()) {
            return toString();
        } else {
            StringBuilder sb = new StringBuilder();

            // Class modifiers are a superset of interface modifiers
            int modifiers = getModifiers() & Modifier.classModifiers();
            if (modifiers != 0) {
                sb.append(Modifier.toString(modifiers));
                sb.append(' ');
            }

            if (isAnnotation()) {
                sb.append('@@');
            }
            if (isInterface()) { // Note: all annotation types are interfaces
                sb.append("interface");
            } else {
                if (isEnum())
                    sb.append("enum");
                else
                    sb.append("class");
            }
            sb.append(' ');
            sb.append(getName());

            TypeVariable<?>[] typeparms = getTypeParameters();
            if (typeparms.length > 0) {
                boolean first = true;
                sb.append('<');
                for(TypeVariable<?> typeparm: typeparms) {
                    if (!first)
                        sb.append(',');
                    sb.append(typeparm.getTypeName());
                    first = false;
                }
                sb.append('>');
            }

            return sb.toString();
        }
    }

    /**
     * Returns the {@@code Class} object associated with the class or
     * interface with the given string name.  Invoking this method is
     * equivalent to:
     *
     * <blockquote>
     *  {@@code Class.forName(className, true, currentLoader)}
     * </blockquote>
     *
     * where {@@code currentLoader} denotes the defining class loader of
     * the current class.
     *
     * <p> For example, the following code fragment returns the
     * runtime {@@code Class} descriptor for the class named
     * {@@code java.lang.Thread}:
     *
     * <blockquote>
     *   {@@code Class t = Class.forName("java.lang.Thread")}
     * </blockquote>
     * <p>
     * A call to {@@code forName("X")} causes the class named
     * {@@code X} to be initialized.
     *
     * @@param      className   the fully qualified name of the desired class.
     * @@return     the {@@code Class} object for the class with the
     *             specified name.
     * @@exception LinkageError if the linkage fails
     * @@exception ExceptionInInitializerError if the initialization provoked
     *            by this method fails
     * @@exception ClassNotFoundException if the class cannot be located
     */
    @@CallerSensitive
    public static Class<?> forName(String className)
                throws ClassNotFoundException {
        Class<?> caller = Reflection.getCallerClass();
        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
    }


    /**
     * Returns the {@@code Class} object associated with the class or
     * interface with the given string name, using the given class loader.
     * Given the fully qualified name for a class or interface (in the same
     * format returned by {@@code getName}) this method attempts to
     * locate, load, and link the class or interface.  The specified class
     * loader is used to load the class or interface.  If the parameter
     * {@@code loader} is null, the class is loaded through the bootstrap
     * class loader.  The class is initialized only if the
     * {@@code initialize} parameter is {@@code true} and if it has
     * not been initialized earlier.
     *
     * <p> If {@@code name} denotes a primitive type or void, an attempt
     * will be made to locate a user-defined class in the unnamed package whose
     * name is {@@code name}. Therefore, this method cannot be used to
     * obtain any of the {@@code Class} objects representing primitive
     * types or void.
     *
     * <p> If {@@code name} denotes an array class, the component type of
     * the array class is loaded but not initialized.
     *
     * <p> For example, in an instance method the expression:
     *
     * <blockquote>
     *  {@@code Class.forName("Foo")}
     * </blockquote>
     *
     * is equivalent to:
     *
     * <blockquote>
     *  {@@code Class.forName("Foo", true, this.getClass().getClassLoader())}
     * </blockquote>
     *
     * Note that this method throws errors related to loading, linking or
     * initializing as specified in Sections 12.2, 12.3 and 12.4 of <em>The
     * Java Language Specification</em>.
     * Note that this method does not check whether the requested class
     * is accessible to its caller.
     *
     * <p> If the {@@code loader} is {@@code null}, and a security
     * manager is present, and the caller's class loader is not null, then this
     * method calls the security manager's {@@code checkPermission} method
     * with a {@@code RuntimePermission("getClassLoader")} permission to
     * ensure it's ok to access the bootstrap class loader.
     *
     * @@param name       fully qualified name of the desired class
     * @@param initialize if {@@code true} the class will be initialized.
     *                   See Section 12.4 of <em>The Java Language Specification</em>.
     * @@param loader     class loader from which the class must be loaded
     * @@return           class object representing the desired class
     *
     * @@exception LinkageError if the linkage fails
     * @@exception ExceptionInInitializerError if the initialization provoked
     *            by this method fails
     * @@exception ClassNotFoundException if the class cannot be located by
     *            the specified class loader
     *
     * @@see       java.lang.Class#forName(String)
     * @@see       java.lang.ClassLoader
     * @@since     1.2
     */
    @@CallerSensitive
    public static Class<?> forName(String name, boolean initialize,
                                   ClassLoader loader)
        throws ClassNotFoundException
    {
        Class<?> caller = null;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            // Reflective call to get caller class is only needed if a security manager
            // is present.  Avoid the overhead of making this call otherwise.
            caller = Reflection.getCallerClass();
            if (sun.misc.VM.isSystemDomainLoader(loader)) {
                ClassLoader ccl = ClassLoader.getClassLoader(caller);
                if (!sun.misc.VM.isSystemDomainLoader(ccl)) {
                    sm.checkPermission(
                        SecurityConstants.GET_CLASSLOADER_PERMISSION);
                }
            }
        }
        return forName0(name, initialize, loader, caller);
    }

    /** Called after security check for system loader access checks have been made. */
    private static native Class<?> forName0(String name, boolean initialize,
                                            ClassLoader loader,
                                            Class<?> caller)
        throws ClassNotFoundException;

    /**
     * Creates a new instance of the class represented by this {@@code Class}
     * object.  The class is instantiated as if by a {@@code new}
     * expression with an empty argument list.  The class is initialized if it
     * has not already been initialized.
     *
     * <p>Note that this method propagates any exception thrown by the
     * nullary constructor, including a checked exception.  Use of
     * this method effectively bypasses the compile-time exception
     * checking that would otherwise be performed by the compiler.
     * The {@@link
     * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
     * Constructor.newInstance} method avoids this problem by wrapping
     * any exception thrown by the constructor in a (checked) {@@link
     * java.lang.reflect.InvocationTargetException}.
     *
     * @@return  a newly allocated instance of the class represented by this
     *          object.
     * @@throws  IllegalAccessException  if the class or its nullary
     *          constructor is not accessible.
     * @@throws  InstantiationException
     *          if this {@@code Class} represents an abstract class,
     *          an interface, an array class, a primitive type, or void;
     *          or if the class has no nullary constructor;
     *          or if the instantiation fails for some other reason.
     * @@throws  ExceptionInInitializerError if the initialization
     *          provoked by this method fails.
     * @@throws  SecurityException
     *          If a security manager, <i>s</i>, is present and
     *          the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class.
     */
    @@CallerSensitive
    public T newInstance()
        throws InstantiationException, IllegalAccessException
    {
        if (System.getSecurityManager() != null) {
            checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);
        }

        // NOTE: the following code may not be strictly correct under
        // the current Java memory model.

        // Constructor lookup
        if (cachedConstructor == null) {
            if (this == Class.class) {
                throw new IllegalAccessException(
                    "Can not call newInstance() on the Class for java.lang.Class"
                );
            }
            try {
                Class<?>[] empty = {};
                final Constructor<T> c = getConstructor0(empty, Member.DECLARED);
                // Disable accessibility checks on the constructor
                // since we have to do the security check here anyway
                // (the stack depth is wrong for the Constructor's
                // security check to work)
                java.security.AccessController.doPrivileged(
                    new java.security.PrivilegedAction<Void>() {
                        public Void run() {
                                c.setAccessible(true);
                                return null;
                            }
                        });
                cachedConstructor = c;
            } catch (NoSuchMethodException e) {
                throw (InstantiationException)
                    new InstantiationException(getName()).initCause(e);
            }
        }
        Constructor<T> tmpConstructor = cachedConstructor;
        // Security check (same as in java.lang.reflect.Constructor)
        int modifiers = tmpConstructor.getModifiers();
        if (!Reflection.quickCheckMemberAccess(this, modifiers)) {
            Class<?> caller = Reflection.getCallerClass();
            if (newInstanceCallerCache != caller) {
                Reflection.ensureMemberAccess(caller, this, null, modifiers);
                newInstanceCallerCache = caller;
            }
        }
        // Run constructor
        try {
            return tmpConstructor.newInstance((Object[])null);
        } catch (InvocationTargetException e) {
            Unsafe.getUnsafe().throwException(e.getTargetException());
            // Not reached
            return null;
        }
    }
    private volatile transient Constructor<T> cachedConstructor;
    private volatile transient Class<?>       newInstanceCallerCache;


    /**
     * Determines if the specified {@@code Object} is assignment-compatible
     * with the object represented by this {@@code Class}.  This method is
     * the dynamic equivalent of the Java language {@@code instanceof}
     * operator. The method returns {@@code true} if the specified
     * {@@code Object} argument is non-null and can be cast to the
     * reference type represented by this {@@code Class} object without
     * raising a {@@code ClassCastException.} It returns {@@code false}
     * otherwise.
     *
     * <p> Specifically, if this {@@code Class} object represents a
     * declared class, this method returns {@@code true} if the specified
     * {@@code Object} argument is an instance of the represented class (or
     * of any of its subclasses); it returns {@@code false} otherwise. If
     * this {@@code Class} object represents an array class, this method
     * returns {@@code true} if the specified {@@code Object} argument
     * can be converted to an object of the array class by an identity
     * conversion or by a widening reference conversion; it returns
     * {@@code false} otherwise. If this {@@code Class} object
     * represents an interface, this method returns {@@code true} if the
     * class or any superclass of the specified {@@code Object} argument
     * implements this interface; it returns {@@code false} otherwise. If
     * this {@@code Class} object represents a primitive type, this method
     * returns {@@code false}.
     *
     * @@param   obj the object to check
     * @@return  true if {@@code obj} is an instance of this class
     *
     * @@since JDK1.1
     */
    public native boolean isInstance(Object obj);


    /**
     * Determines if the class or interface represented by this
     * {@@code Class} object is either the same as, or is a superclass or
     * superinterface of, the class or interface represented by the specified
     * {@@code Class} parameter. It returns {@@code true} if so;
     * otherwise it returns {@@code false}. If this {@@code Class}
     * object represents a primitive type, this method returns
     * {@@code true} if the specified {@@code Class} parameter is
     * exactly this {@@code Class} object; otherwise it returns
     * {@@code false}.
     *
     * <p> Specifically, this method tests whether the type represented by the
     * specified {@@code Class} parameter can be converted to the type
     * represented by this {@@code Class} object via an identity conversion
     * or via a widening reference conversion. See <em>The Java Language
     * Specification</em>, sections 5.1.1 and 5.1.4 , for details.
     *
     * @@param cls the {@@code Class} object to be checked
     * @@return the {@@code boolean} value indicating whether objects of the
     * type {@@code cls} can be assigned to objects of this class
     * @@exception NullPointerException if the specified Class parameter is
     *            null.
     * @@since JDK1.1
     */
    public native boolean isAssignableFrom(Class<?> cls);


    /**
     * Determines if the specified {@@code Class} object represents an
     * interface type.
     *
     * @@return  {@@code true} if this object represents an interface;
     *          {@@code false} otherwise.
     */
    public native boolean isInterface();


    /**
     * Determines if this {@@code Class} object represents an array class.
     *
     * @@return  {@@code true} if this object represents an array class;
     *          {@@code false} otherwise.
     * @@since   JDK1.1
     */
    public native boolean isArray();


    /**
     * Determines if the specified {@@code Class} object represents a
     * primitive type.
     *
     * <p> There are nine predefined {@@code Class} objects to represent
     * the eight primitive types and void.  These are created by the Java
     * Virtual Machine, and have the same names as the primitive types that
     * they represent, namely {@@code boolean}, {@@code byte},
     * {@@code char}, {@@code short}, {@@code int},
     * {@@code long}, {@@code float}, and {@@code double}.
     *
     * <p> These objects may only be accessed via the following public static
     * final variables, and are the only {@@code Class} objects for which
     * this method returns {@@code true}.
     *
     * @@return true if and only if this class represents a primitive type
     *
     * @@see     java.lang.Boolean#TYPE
     * @@see     java.lang.Character#TYPE
     * @@see     java.lang.Byte#TYPE
     * @@see     java.lang.Short#TYPE
     * @@see     java.lang.Integer#TYPE
     * @@see     java.lang.Long#TYPE
     * @@see     java.lang.Float#TYPE
     * @@see     java.lang.Double#TYPE
     * @@see     java.lang.Void#TYPE
     * @@since JDK1.1
     */
    public native boolean isPrimitive();

    /**
     * Returns true if this {@@code Class} object represents an annotation
     * type.  Note that if this method returns true, {@@link #isInterface()}
     * would also return true, as all annotation types are also interfaces.
     *
     * @@return {@@code true} if this class object represents an annotation
     *      type; {@@code false} otherwise
     * @@since 1.5
     */
    public boolean isAnnotation() {
        return (getModifiers() & ANNOTATION) != 0;
    }

    /**
     * Returns {@@code true} if this class is a synthetic class;
     * returns {@@code false} otherwise.
     * @@return {@@code true} if and only if this class is a synthetic class as
     *         defined by the Java Language Specification.
     * @@jls 13.1 The Form of a Binary
     * @@since 1.5
     */
    public boolean isSynthetic() {
        return (getModifiers() & SYNTHETIC) != 0;
    }

    /**
     * Returns the  name of the entity (class, interface, array class,
     * primitive type, or void) represented by this {@@code Class} object,
     * as a {@@code String}.
     *
     * <p> If this class object represents a reference type that is not an
     * array type then the binary name of the class is returned, as specified
     * by
     * <cite>The Java&trade; Language Specification</cite>.
     *
     * <p> If this class object represents a primitive type or void, then the
     * name returned is a {@@code String} equal to the Java language
     * keyword corresponding to the primitive type or void.
     *
     * <p> If this class object represents a class of arrays, then the internal
     * form of the name consists of the name of the element type preceded by
     * one or more '{@@code [}' characters representing the depth of the array
     * nesting.  The encoding of element type names is as follows:
     *
     * <blockquote><table summary="Element types and encodings">
     * <tr><th> Element Type <th> &nbsp;&nbsp;&nbsp; <th> Encoding
     * <tr><td> boolean      <td> &nbsp;&nbsp;&nbsp; <td align=center> Z
     * <tr><td> byte         <td> &nbsp;&nbsp;&nbsp; <td align=center> B
     * <tr><td> char         <td> &nbsp;&nbsp;&nbsp; <td align=center> C
     * <tr><td> class or interface
     *                       <td> &nbsp;&nbsp;&nbsp; <td align=center> L<i>classname</i>;
     * <tr><td> double       <td> &nbsp;&nbsp;&nbsp; <td align=center> D
     * <tr><td> float        <td> &nbsp;&nbsp;&nbsp; <td align=center> F
     * <tr><td> int          <td> &nbsp;&nbsp;&nbsp; <td align=center> I
     * <tr><td> long         <td> &nbsp;&nbsp;&nbsp; <td align=center> J
     * <tr><td> short        <td> &nbsp;&nbsp;&nbsp; <td align=center> S
     * </table></blockquote>
     *
     * <p> The class or interface name <i>classname</i> is the binary name of
     * the class specified above.
     *
     * <p> Examples:
     * <blockquote><pre>
     * String.class.getName()
     *     returns "java.lang.String"
     * byte.class.getName()
     *     returns "byte"
     * (new Object[3]).getClass().getName()
     *     returns "[Ljava.lang.Object;"
     * (new int[3][4][5][6][7][8][9]).getClass().getName()
     *     returns "[[[[[[[I"
     * </pre></blockquote>
     *
     * @@return  the name of the class or interface
     *          represented by this object.
     */
    public String getName() {
        String name = this.name;
        if (name == null)
            this.name = name = getName0();
        return name;
    }

    // cache the name to reduce the number of calls into the VM
    private transient String name;
    private native String getName0();

    /**
     * Returns the class loader for the class.  Some implementations may use
     * null to represent the bootstrap class loader. This method will return
     * null in such implementations if this class was loaded by the bootstrap
     * class loader.
     *
     * <p> If a security manager is present, and the caller's class loader is
     * not null and the caller's class loader is not the same as or an ancestor of
     * the class loader for the class whose class loader is requested, then
     * this method calls the security manager's {@@code checkPermission}
     * method with a {@@code RuntimePermission("getClassLoader")}
     * permission to ensure it's ok to access the class loader for the class.
     *
     * <p>If this object
     * represents a primitive type or void, null is returned.
     *
     * @@return  the class loader that loaded the class or interface
     *          represented by this object.
     * @@throws SecurityException
     *    if a security manager exists and its
     *    {@@code checkPermission} method denies
     *    access to the class loader for the class.
     * @@see java.lang.ClassLoader
     * @@see SecurityManager#checkPermission
     * @@see java.lang.RuntimePermission
     */
    @@CallerSensitive
    public ClassLoader getClassLoader() {
        ClassLoader cl = getClassLoader0();
        if (cl == null)
            return null;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
        }
        return cl;
    }

    // Package-private to allow ClassLoader access
    native ClassLoader getClassLoader0();


    /**
     * Returns an array of {@@code TypeVariable} objects that represent the
     * type variables declared by the generic declaration represented by this
     * {@@code GenericDeclaration} object, in declaration order.  Returns an
     * array of length 0 if the underlying generic declaration declares no type
     * variables.
     *
     * @@return an array of {@@code TypeVariable} objects that represent
     *     the type variables declared by this generic declaration
     * @@throws java.lang.reflect.GenericSignatureFormatError if the generic
     *     signature of this generic declaration does not conform to
     *     the format specified in
     *     <cite>The Java&trade; Virtual Machine Specification</cite>
     * @@since 1.5
     */
    @@SuppressWarnings("unchecked")
    public TypeVariable<Class<T>>[] getTypeParameters() {
        ClassRepository info = getGenericInfo();
        if (info != null)
            return (TypeVariable<Class<T>>[])info.getTypeParameters();
        else
            return (TypeVariable<Class<T>>[])new TypeVariable<?>[0];
    }


    /**
     * Returns the {@@code Class} representing the superclass of the entity
     * (class, interface, primitive type or void) represented by this
     * {@@code Class}.  If this {@@code Class} represents either the
     * {@@code Object} class, an interface, a primitive type, or void, then
     * null is returned.  If this object represents an array class then the
     * {@@code Class} object representing the {@@code Object} class is
     * returned.
     *
     * @@return the superclass of the class represented by this object.
     */
    public native Class<? super T> getSuperclass();


    /**
     * Returns the {@@code Type} representing the direct superclass of
     * the entity (class, interface, primitive type or void) represented by
     * this {@@code Class}.
     *
     * <p>If the superclass is a parameterized type, the {@@code Type}
     * object returned must accurately reflect the actual type
     * parameters used in the source code. The parameterized type
     * representing the superclass is created if it had not been
     * created before. See the declaration of {@@link
     * java.lang.reflect.ParameterizedType ParameterizedType} for the
     * semantics of the creation process for parameterized types.  If
     * this {@@code Class} represents either the {@@code Object}
     * class, an interface, a primitive type, or void, then null is
     * returned.  If this object represents an array class then the
     * {@@code Class} object representing the {@@code Object} class is
     * returned.
     *
     * @@throws java.lang.reflect.GenericSignatureFormatError if the generic
     *     class signature does not conform to the format specified in
     *     <cite>The Java&trade; Virtual Machine Specification</cite>
     * @@throws TypeNotPresentException if the generic superclass
     *     refers to a non-existent type declaration
     * @@throws java.lang.reflect.MalformedParameterizedTypeException if the
     *     generic superclass refers to a parameterized type that cannot be
     *     instantiated  for any reason
     * @@return the superclass of the class represented by this object
     * @@since 1.5
     */
    public Type getGenericSuperclass() {
        ClassRepository info = getGenericInfo();
        if (info == null) {
            return getSuperclass();
        }

        // Historical irregularity:
        // Generic signature marks interfaces with superclass = Object
        // but this API returns null for interfaces
        if (isInterface()) {
            return null;
        }

        return info.getSuperclass();
    }

    /**
     * Gets the package for this class.  The class loader of this class is used
     * to find the package.  If the class was loaded by the bootstrap class
     * loader the set of packages loaded from CLASSPATH is searched to find the
     * package of the class. Null is returned if no package object was created
     * by the class loader of this class.
     *
     * <p> Packages have attributes for versions and specifications only if the
     * information was defined in the manifests that accompany the classes, and
     * if the class loader created the package instance with the attributes
     * from the manifest.
     *
     * @@return the package of the class, or null if no package
     *         information is available from the archive or codebase.
     */
    public Package getPackage() {
        return Package.getPackage(this);
    }


    /**
     * Determines the interfaces implemented by the class or interface
     * represented by this object.
     *
     * <p> If this object represents a class, the return value is an array
     * containing objects representing all interfaces implemented by the
     * class. The order of the interface objects in the array corresponds to
     * the order of the interface names in the {@@code implements} clause
     * of the declaration of the class represented by this object. For
     * example, given the declaration:
     * <blockquote>
     * {@@code class Shimmer implements FloorWax, DessertTopping { ... }}
     * </blockquote>
     * suppose the value of {@@code s} is an instance of
     * {@@code Shimmer}; the value of the expression:
     * <blockquote>
     * {@@code s.getClass().getInterfaces()[0]}
     * </blockquote>
     * is the {@@code Class} object that represents interface
     * {@@code FloorWax}; and the value of:
     * <blockquote>
     * {@@code s.getClass().getInterfaces()[1]}
     * </blockquote>
     * is the {@@code Class} object that represents interface
     * {@@code DessertTopping}.
     *
     * <p> If this object represents an interface, the array contains objects
     * representing all interfaces extended by the interface. The order of the
     * interface objects in the array corresponds to the order of the interface
     * names in the {@@code extends} clause of the declaration of the
     * interface represented by this object.
     *
     * <p> If this object represents a class or interface that implements no
     * interfaces, the method returns an array of length 0.
     *
     * <p> If this object represents a primitive type or void, the method
     * returns an array of length 0.
     *
     * <p> If this {@@code Class} object represents an array type, the
     * interfaces {@@code Cloneable} and {@@code java.io.Serializable} are
     * returned in that order.
     *
     * @@return an array of interfaces implemented by this class.
     */
    public Class<?>[] getInterfaces() {
        ReflectionData<T> rd = reflectionData();
        if (rd == null) {
            // no cloning required
            return getInterfaces0();
        } else {
            Class<?>[] interfaces = rd.interfaces;
            if (interfaces == null) {
                interfaces = getInterfaces0();
                rd.interfaces = interfaces;
            }
            // defensively copy before handing over to user code
            return interfaces.clone();
        }
    }

    private native Class<?>[] getInterfaces0();

    /**
     * Returns the {@@code Type}s representing the interfaces
     * directly implemented by the class or interface represented by
     * this object.
     *
     * <p>If a superinterface is a parameterized type, the
     * {@@code Type} object returned for it must accurately reflect
     * the actual type parameters used in the source code. The
     * parameterized type representing each superinterface is created
     * if it had not been created before. See the declaration of
     * {@@link java.lang.reflect.ParameterizedType ParameterizedType}
     * for the semantics of the creation process for parameterized
     * types.
     *
     * <p> If this object represents a class, the return value is an
     * array containing objects representing all interfaces
     * implemented by the class. The order of the interface objects in
     * the array corresponds to the order of the interface names in
     * the {@@code implements} clause of the declaration of the class
     * represented by this object.  In the case of an array class, the
     * interfaces {@@code Cloneable} and {@@code Serializable} are
     * returned in that order.
     *
     * <p>If this object represents an interface, the array contains
     * objects representing all interfaces directly extended by the
     * interface.  The order of the interface objects in the array
     * corresponds to the order of the interface names in the
     * {@@code extends} clause of the declaration of the interface
     * represented by this object.
     *
     * <p>If this object represents a class or interface that
     * implements no interfaces, the method returns an array of length
     * 0.
     *
     * <p>If this object represents a primitive type or void, the
     * method returns an array of length 0.
     *
     * @@throws java.lang.reflect.GenericSignatureFormatError
     *     if the generic class signature does not conform to the format
     *     specified in
     *     <cite>The Java&trade; Virtual Machine Specification</cite>
     * @@throws TypeNotPresentException if any of the generic
     *     superinterfaces refers to a non-existent type declaration
     * @@throws java.lang.reflect.MalformedParameterizedTypeException
     *     if any of the generic superinterfaces refer to a parameterized
     *     type that cannot be instantiated for any reason
     * @@return an array of interfaces implemented by this class
     * @@since 1.5
     */
    public Type[] getGenericInterfaces() {
        ClassRepository info = getGenericInfo();
        return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
    }


    /**
     * Returns the {@@code Class} representing the component type of an
     * array.  If this class does not represent an array class this method
     * returns null.
     *
     * @@return the {@@code Class} representing the component type of this
     * class if this class is an array
     * @@see     java.lang.reflect.Array
     * @@since JDK1.1
     */
    public native Class<?> getComponentType();


    /**
     * Returns the Java language modifiers for this class or interface, encoded
     * in an integer. The modifiers consist of the Java Virtual Machine's
     * constants for {@@code public}, {@@code protected},
     * {@@code private}, {@@code final}, {@@code static},
     * {@@code abstract} and {@@code interface}; they should be decoded
     * using the methods of class {@@code Modifier}.
     *
     * <p> If the underlying class is an array class, then its
     * {@@code public}, {@@code private} and {@@code protected}
     * modifiers are the same as those of its component type.  If this
     * {@@code Class} represents a primitive type or void, its
     * {@@code public} modifier is always {@@code true}, and its
     * {@@code protected} and {@@code private} modifiers are always
     * {@@code false}. If this object represents an array class, a
     * primitive type or void, then its {@@code final} modifier is always
     * {@@code true} and its interface modifier is always
     * {@@code false}. The values of its other modifiers are not determined
     * by this specification.
     *
     * <p> The modifier encodings are defined in <em>The Java Virtual Machine
     * Specification</em>, table 4.1.
     *
     * @@return the {@@code int} representing the modifiers for this class
     * @@see     java.lang.reflect.Modifier
     * @@since JDK1.1
     */
    public native int getModifiers();


    /**
     * Gets the signers of this class.
     *
     * @@return  the signers of this class, or null if there are no signers.  In
     *          particular, this method returns null if this object represents
     *          a primitive type or void.
     * @@since   JDK1.1
     */
    public native Object[] getSigners();


    /**
     * Set the signers of this class.
     */
    native void setSigners(Object[] signers);


    /**
     * If this {@@code Class} object represents a local or anonymous
     * class within a method, returns a {@@link
     * java.lang.reflect.Method Method} object representing the
     * immediately enclosing method of the underlying class. Returns
     * {@@code null} otherwise.
     *
     * In particular, this method returns {@@code null} if the underlying
     * class is a local or anonymous class immediately enclosed by a type
     * declaration, instance initializer or static initializer.
     *
     * @@return the immediately enclosing method of the underlying class, if
     *     that class is a local or anonymous class; otherwise {@@code null}.
     *
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and any of the
     *         following conditions is met:
     *
     *         <ul>
     *
     *         <li> the caller's class loader is not the same as the
     *         class loader of the enclosing class and invocation of
     *         {@@link SecurityManager#checkPermission
     *         s.checkPermission} method with
     *         {@@code RuntimePermission("accessDeclaredMembers")}
     *         denies access to the methods within the enclosing class
     *
     *         <li> the caller's class loader is not the same as or an
     *         ancestor of the class loader for the enclosing class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of the enclosing class
     *
     *         </ul>
     * @@since 1.5
     */
    @@CallerSensitive
    public Method getEnclosingMethod() throws SecurityException {
        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();

        if (enclosingInfo == null)
            return null;
        else {
            if (!enclosingInfo.isMethod())
                return null;

            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
                                                              getFactory());
            Class<?>   returnType       = toClass(typeInfo.getReturnType());
            Type []    parameterTypes   = typeInfo.getParameterTypes();
            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];

            // Convert Types to Classes; returned types *should*
            // be class objects since the methodDescriptor's used
            // don't have generics information
            for(int i = 0; i < parameterClasses.length; i++)
                parameterClasses[i] = toClass(parameterTypes[i]);

            // Perform access check
            Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();
            enclosingCandidate.checkMemberAccess(Member.DECLARED,
                                                 Reflection.getCallerClass(), true);
            /*
             * Loop over all declared methods; match method name,
             * number of and type of parameters, *and* return
             * type.  Matching return type is also necessary
             * because of covariant returns, etc.
             */
            for(Method m: enclosingCandidate.getDeclaredMethods()) {
                if (m.getName().equals(enclosingInfo.getName()) ) {
                    Class<?>[] candidateParamClasses = m.getParameterTypes();
                    if (candidateParamClasses.length == parameterClasses.length) {
                        boolean matches = true;
                        for(int i = 0; i < candidateParamClasses.length; i++) {
                            if (!candidateParamClasses[i].equals(parameterClasses[i])) {
                                matches = false;
                                break;
                            }
                        }

                        if (matches) { // finally, check return type
                            if (m.getReturnType().equals(returnType) )
                                return m;
                        }
                    }
                }
            }

            throw new InternalError("Enclosing method not found");
        }
    }

    private native Object[] getEnclosingMethod0();

    private EnclosingMethodInfo getEnclosingMethodInfo() {
        Object[] enclosingInfo = getEnclosingMethod0();
        if (enclosingInfo == null)
            return null;
        else {
            return new EnclosingMethodInfo(enclosingInfo);
        }
    }

    private final static class EnclosingMethodInfo {
        private Class<?> enclosingClass;
        private String name;
        private String descriptor;

        private EnclosingMethodInfo(Object[] enclosingInfo) {
            if (enclosingInfo.length != 3)
                throw new InternalError("Malformed enclosing method information");
            try {
                // The array is expected to have three elements:

                // the immediately enclosing class
                enclosingClass = (Class<?>) enclosingInfo[0];
                assert(enclosingClass != null);

                // the immediately enclosing method or constructor's
                // name (can be null).
                name            = (String)   enclosingInfo[1];

                // the immediately enclosing method or constructor's
                // descriptor (null iff name is).
                descriptor      = (String)   enclosingInfo[2];
                assert((name != null && descriptor != null) || name == descriptor);
            } catch (ClassCastException cce) {
                throw new InternalError("Invalid type in enclosing method information", cce);
            }
        }

        boolean isPartial() {
            return enclosingClass == null || name == null || descriptor == null;
        }

        boolean isConstructor() { return !isPartial() && "<init>".equals(name); }

        boolean isMethod() { return !isPartial() && !isConstructor() && !"<clinit>".equals(name); }

        Class<?> getEnclosingClass() { return enclosingClass; }

        String getName() { return name; }

        String getDescriptor() { return descriptor; }

    }

    private static Class<?> toClass(Type o) {
        if (o instanceof GenericArrayType)
            return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
                                     0)
                .getClass();
        return (Class<?>)o;
     }

    /**
     * If this {@@code Class} object represents a local or anonymous
     * class within a constructor, returns a {@@link
     * java.lang.reflect.Constructor Constructor} object representing
     * the immediately enclosing constructor of the underlying
     * class. Returns {@@code null} otherwise.  In particular, this
     * method returns {@@code null} if the underlying class is a local
     * or anonymous class immediately enclosed by a type declaration,
     * instance initializer or static initializer.
     *
     * @@return the immediately enclosing constructor of the underlying class, if
     *     that class is a local or anonymous class; otherwise {@@code null}.
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and any of the
     *         following conditions is met:
     *
     *         <ul>
     *
     *         <li> the caller's class loader is not the same as the
     *         class loader of the enclosing class and invocation of
     *         {@@link SecurityManager#checkPermission
     *         s.checkPermission} method with
     *         {@@code RuntimePermission("accessDeclaredMembers")}
     *         denies access to the constructors within the enclosing class
     *
     *         <li> the caller's class loader is not the same as or an
     *         ancestor of the class loader for the enclosing class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of the enclosing class
     *
     *         </ul>
     * @@since 1.5
     */
    @@CallerSensitive
    public Constructor<?> getEnclosingConstructor() throws SecurityException {
        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();

        if (enclosingInfo == null)
            return null;
        else {
            if (!enclosingInfo.isConstructor())
                return null;

            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
                                                                        getFactory());
            Type []    parameterTypes   = typeInfo.getParameterTypes();
            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];

            // Convert Types to Classes; returned types *should*
            // be class objects since the methodDescriptor's used
            // don't have generics information
            for(int i = 0; i < parameterClasses.length; i++)
                parameterClasses[i] = toClass(parameterTypes[i]);

            // Perform access check
            Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();
            enclosingCandidate.checkMemberAccess(Member.DECLARED,
                                                 Reflection.getCallerClass(), true);
            /*
             * Loop over all declared constructors; match number
             * of and type of parameters.
             */
            for(Constructor<?> c: enclosingCandidate.getDeclaredConstructors()) {
                Class<?>[] candidateParamClasses = c.getParameterTypes();
                if (candidateParamClasses.length == parameterClasses.length) {
                    boolean matches = true;
                    for(int i = 0; i < candidateParamClasses.length; i++) {
                        if (!candidateParamClasses[i].equals(parameterClasses[i])) {
                            matches = false;
                            break;
                        }
                    }

                    if (matches)
                        return c;
                }
            }

            throw new InternalError("Enclosing constructor not found");
        }
    }


    /**
     * If the class or interface represented by this {@@code Class} object
     * is a member of another class, returns the {@@code Class} object
     * representing the class in which it was declared.  This method returns
     * null if this class or interface is not a member of any other class.  If
     * this {@@code Class} object represents an array class, a primitive
     * type, or void,then this method returns null.
     *
     * @@return the declaring class for this class
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and the caller's
     *         class loader is not the same as or an ancestor of the class
     *         loader for the declaring class and invocation of {@@link
     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
     *         denies access to the package of the declaring class
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Class<?> getDeclaringClass() throws SecurityException {
        final Class<?> candidate = getDeclaringClass0();

        if (candidate != null)
            candidate.checkPackageAccess(
                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
        return candidate;
    }

    private native Class<?> getDeclaringClass0();


    /**
     * Returns the immediately enclosing class of the underlying
     * class.  If the underlying class is a top level class this
     * method returns {@@code null}.
     * @@return the immediately enclosing class of the underlying class
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and the caller's
     *             class loader is not the same as or an ancestor of the class
     *             loader for the enclosing class and invocation of {@@link
     *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
     *             denies access to the package of the enclosing class
     * @@since 1.5
     */
    @@CallerSensitive
    public Class<?> getEnclosingClass() throws SecurityException {
        // There are five kinds of classes (or interfaces):
        // a) Top level classes
        // b) Nested classes (static member classes)
        // c) Inner classes (non-static member classes)
        // d) Local classes (named classes declared within a method)
        // e) Anonymous classes


        // JVM Spec 4.8.6: A class must have an EnclosingMethod
        // attribute if and only if it is a local class or an
        // anonymous class.
        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
        Class<?> enclosingCandidate;

        if (enclosingInfo == null) {
            // This is a top level or a nested class or an inner class (a, b, or c)
            enclosingCandidate = getDeclaringClass();
        } else {
            Class<?> enclosingClass = enclosingInfo.getEnclosingClass();
            // This is a local class or an anonymous class (d or e)
            if (enclosingClass == this || enclosingClass == null)
                throw new InternalError("Malformed enclosing method information");
            else
                enclosingCandidate = enclosingClass;
        }

        if (enclosingCandidate != null)
            enclosingCandidate.checkPackageAccess(
                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
        return enclosingCandidate;
    }

    /**
     * Returns the simple name of the underlying class as given in the
     * source code. Returns an empty string if the underlying class is
     * anonymous.
     *
     * <p>The simple name of an array is the simple name of the
     * component type with "[]" appended.  In particular the simple
     * name of an array whose component type is anonymous is "[]".
     *
     * @@return the simple name of the underlying class
     * @@since 1.5
     */
    public String getSimpleName() {
        if (isArray())
            return getComponentType().getSimpleName()+"[]";

        String simpleName = getSimpleBinaryName();
        if (simpleName == null) { // top level class
            simpleName = getName();
            return simpleName.substring(simpleName.lastIndexOf(".")+1); // strip the package name
        }
        // According to JLS3 "Binary Compatibility" (13.1) the binary
        // name of non-package classes (not top level) is the binary
        // name of the immediately enclosing class followed by a '$' followed by:
        // (for nested and inner classes): the simple name.
        // (for local classes): 1 or more digits followed by the simple name.
        // (for anonymous classes): 1 or more digits.

        // Since getSimpleBinaryName() will strip the binary name of
        // the immediatly enclosing class, we are now looking at a
        // string that matches the regular expression "\$[0-9]*"
        // followed by a simple name (considering the simple of an
        // anonymous class to be the empty string).

        // Remove leading "\$[0-9]*" from the name
        int length = simpleName.length();
        if (length < 1 || simpleName.charAt(0) != '$')
            throw new InternalError("Malformed class name");
        int index = 1;
        while (index < length && isAsciiDigit(simpleName.charAt(index)))
            index++;
        // Eventually, this is the empty string iff this is an anonymous class
        return simpleName.substring(index);
    }

    /**
     * Return an informative string for the name of this type.
     *
     * @@return an informative string for the name of this type
     * @@since 1.8
     */
    public String getTypeName() {
        if (isArray()) {
            try {
                Class<?> cl = this;
                int dimensions = 0;
                while (cl.isArray()) {
                    dimensions++;
                    cl = cl.getComponentType();
                }
                StringBuilder sb = new StringBuilder();
                sb.append(cl.getName());
                for (int i = 0; i < dimensions; i++) {
                    sb.append("[]");
                }
                return sb.toString();
            } catch (Throwable e) { /*FALLTHRU*/ }
        }
        return getName();
    }

    /**
     * Character.isDigit answers {@@code true} to some non-ascii
     * digits.  This one does not.
     */
    private static boolean isAsciiDigit(char c) {
        return '0' <= c && c <= '9';
    }

    /**
     * Returns the canonical name of the underlying class as
     * defined by the Java Language Specification.  Returns null if
     * the underlying class does not have a canonical name (i.e., if
     * it is a local or anonymous class or an array whose component
     * type does not have a canonical name).
     * @@return the canonical name of the underlying class if it exists, and
     * {@@code null} otherwise.
     * @@since 1.5
     */
    public String getCanonicalName() {
        if (isArray()) {
            String canonicalName = getComponentType().getCanonicalName();
            if (canonicalName != null)
                return canonicalName + "[]";
            else
                return null;
        }
        if (isLocalOrAnonymousClass())
            return null;
        Class<?> enclosingClass = getEnclosingClass();
        if (enclosingClass == null) { // top level class
            return getName();
        } else {
            String enclosingName = enclosingClass.getCanonicalName();
            if (enclosingName == null)
                return null;
            return enclosingName + "." + getSimpleName();
        }
    }

    /**
     * Returns {@@code true} if and only if the underlying class
     * is an anonymous class.
     *
     * @@return {@@code true} if and only if this class is an anonymous class.
     * @@since 1.5
     */
    public boolean isAnonymousClass() {
        return "".equals(getSimpleName());
    }

    /**
     * Returns {@@code true} if and only if the underlying class
     * is a local class.
     *
     * @@return {@@code true} if and only if this class is a local class.
     * @@since 1.5
     */
    public boolean isLocalClass() {
        return isLocalOrAnonymousClass() && !isAnonymousClass();
    }

    /**
     * Returns {@@code true} if and only if the underlying class
     * is a member class.
     *
     * @@return {@@code true} if and only if this class is a member class.
     * @@since 1.5
     */
    public boolean isMemberClass() {
        return getSimpleBinaryName() != null && !isLocalOrAnonymousClass();
    }

    /**
     * Returns the "simple binary name" of the underlying class, i.e.,
     * the binary name without the leading enclosing class name.
     * Returns {@@code null} if the underlying class is a top level
     * class.
     */
    private String getSimpleBinaryName() {
        Class<?> enclosingClass = getEnclosingClass();
        if (enclosingClass == null) // top level class
            return null;
        // Otherwise, strip the enclosing class' name
        try {
            return getName().substring(enclosingClass.getName().length());
        } catch (IndexOutOfBoundsException ex) {
            throw new InternalError("Malformed class name", ex);
        }
    }

    /**
     * Returns {@@code true} if this is a local class or an anonymous
     * class.  Returns {@@code false} otherwise.
     */
    private boolean isLocalOrAnonymousClass() {
        // JVM Spec 4.8.6: A class must have an EnclosingMethod
        // attribute if and only if it is a local class or an
        // anonymous class.
        return getEnclosingMethodInfo() != null;
    }

    /**
     * Returns an array containing {@@code Class} objects representing all
     * the public classes and interfaces that are members of the class
     * represented by this {@@code Class} object.  This includes public
     * class and interface members inherited from superclasses and public class
     * and interface members declared by the class.  This method returns an
     * array of length 0 if this {@@code Class} object has no public member
     * classes or interfaces.  This method also returns an array of length 0 if
     * this {@@code Class} object represents a primitive type, an array
     * class, or void.
     *
     * @@return the array of {@@code Class} objects representing the public
     *         members of this class
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Class<?>[] getClasses() {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);

        // Privileged so this implementation can look at DECLARED classes,
        // something the caller might not have privilege to do.  The code here
        // is allowed to look at DECLARED classes because (1) it does not hand
        // out anything other than public members and (2) public member access
        // has already been ok'd by the SecurityManager.

        return java.security.AccessController.doPrivileged(
            new java.security.PrivilegedAction<Class<?>[]>() {
                public Class<?>[] run() {
                    List<Class<?>> list = new ArrayList<>();
                    Class<?> currentClass = Class.this;
                    while (currentClass != null) {
                        Class<?>[] members = currentClass.getDeclaredClasses();
                        for (int i = 0; i < members.length; i++) {
                            if (Modifier.isPublic(members[i].getModifiers())) {
                                list.add(members[i]);
                            }
                        }
                        currentClass = currentClass.getSuperclass();
                    }
                    return list.toArray(new Class<?>[0]);
                }
            });
    }


    /**
     * Returns an array containing {@@code Field} objects reflecting all
     * the accessible public fields of the class or interface represented by
     * this {@@code Class} object.
     *
     * <p> If this {@@code Class} object represents a class or interface with no
     * no accessible public fields, then this method returns an array of length
     * 0.
     *
     * <p> If this {@@code Class} object represents a class, then this method
     * returns the public fields of the class and of all its superclasses.
     *
     * <p> If this {@@code Class} object represents an interface, then this
     * method returns the fields of the interface and of all its
     * superinterfaces.
     *
     * <p> If this {@@code Class} object represents an array type, a primitive
     * type, or void, then this method returns an array of length 0.
     *
     * <p> The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * @@return the array of {@@code Field} objects representing the
     *         public fields
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @@since JDK1.1
     * @@jls 8.2 Class Members
     * @@jls 8.3 Field Declarations
     */
    @@CallerSensitive
    public Field[] getFields() throws SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);
        return copyFields(privateGetPublicFields(null));
    }


    /**
     * Returns an array containing {@@code Method} objects reflecting all the
     * public methods of the class or interface represented by this {@@code
     * Class} object, including those declared by the class or interface and
     * those inherited from superclasses and superinterfaces.
     *
     * <p> If this {@@code Class} object represents a type that has multiple
     * public methods with the same name and parameter types, but different
     * return types, then the returned array has a {@@code Method} object for
     * each such method.
     *
     * <p> If this {@@code Class} object represents a type with a class
     * initialization method {@@code <clinit>}, then the returned array does
     * <em>not</em> have a corresponding {@@code Method} object.
     *
     * <p> If this {@@code Class} object represents an array type, then the
     * returned array has a {@@code Method} object for each of the public
     * methods inherited by the array type from {@@code Object}. It does not
     * contain a {@@code Method} object for {@@code clone()}.
     *
     * <p> If this {@@code Class} object represents an interface then the
     * returned array does not contain any implicitly declared methods from
     * {@@code Object}. Therefore, if no methods are explicitly declared in
     * this interface or any of its superinterfaces then the returned array
     * has length 0. (Note that a {@@code Class} object which represents a class
     * always has public methods, inherited from {@@code Object}.)
     *
     * <p> If this {@@code Class} object represents a primitive type or void,
     * then the returned array has length 0.
     *
     * <p> Static methods declared in superinterfaces of the class or interface
     * represented by this {@@code Class} object are not considered members of
     * the class or interface.
     *
     * <p> The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * @@return the array of {@@code Method} objects representing the
     *         public methods of this class
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @@jls 8.2 Class Members
     * @@jls 8.4 Method Declarations
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Method[] getMethods() throws SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);
        return copyMethods(privateGetPublicMethods());
    }


    /**
     * Returns an array containing {@@code Constructor} objects reflecting
     * all the public constructors of the class represented by this
     * {@@code Class} object.  An array of length 0 is returned if the
     * class has no public constructors, or if the class is an array class, or
     * if the class reflects a primitive type or void.
     *
     * Note that while this method returns an array of {@@code
     * Constructor<T>} objects (that is an array of constructors from
     * this class), the return type of this method is {@@code
     * Constructor<?>[]} and <em>not</em> {@@code Constructor<T>[]} as
     * might be expected.  This less informative return type is
     * necessary since after being returned from this method, the
     * array could be modified to hold {@@code Constructor} objects for
     * different classes, which would violate the type guarantees of
     * {@@code Constructor<T>[]}.
     *
     * @@return the array of {@@code Constructor} objects representing the
     *         public constructors of this class
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Constructor<?>[] getConstructors() throws SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);
        return copyConstructors(privateGetDeclaredConstructors(true));
    }


    /**
     * Returns a {@@code Field} object that reflects the specified public member
     * field of the class or interface represented by this {@@code Class}
     * object. The {@@code name} parameter is a {@@code String} specifying the
     * simple name of the desired field.
     *
     * <p> The field to be reflected is determined by the algorithm that
     * follows.  Let C be the class or interface represented by this object:
     *
     * <OL>
     * <LI> If C declares a public field with the name specified, that is the
     *      field to be reflected.</LI>
     * <LI> If no field was found in step 1 above, this algorithm is applied
     *      recursively to each direct superinterface of C. The direct
     *      superinterfaces are searched in the order they were declared.</LI>
     * <LI> If no field was found in steps 1 and 2 above, and C has a
     *      superclass S, then this algorithm is invoked recursively upon S.
     *      If C has no superclass, then a {@@code NoSuchFieldException}
     *      is thrown.</LI>
     * </OL>
     *
     * <p> If this {@@code Class} object represents an array type, then this
     * method does not find the {@@code length} field of the array type.
     *
     * @@param name the field name
     * @@return the {@@code Field} object of this class specified by
     *         {@@code name}
     * @@throws NoSuchFieldException if a field with the specified name is
     *         not found.
     * @@throws NullPointerException if {@@code name} is {@@code null}
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @@since JDK1.1
     * @@jls 8.2 Class Members
     * @@jls 8.3 Field Declarations
     */
    @@CallerSensitive
    public Field getField(String name)
        throws NoSuchFieldException, SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);
        Field field = getField0(name);
        if (field == null) {
            throw new NoSuchFieldException(name);
        }
        return field;
    }


    /**
     * Returns a {@@code Method} object that reflects the specified public
     * member method of the class or interface represented by this
     * {@@code Class} object. The {@@code name} parameter is a
     * {@@code String} specifying the simple name of the desired method. The
     * {@@code parameterTypes} parameter is an array of {@@code Class}
     * objects that identify the method's formal parameter types, in declared
     * order. If {@@code parameterTypes} is {@@code null}, it is
     * treated as if it were an empty array.
     *
     * <p> If the {@@code name} is "{@@code <init>}" or "{@@code <clinit>}" a
     * {@@code NoSuchMethodException} is raised. Otherwise, the method to
     * be reflected is determined by the algorithm that follows.  Let C be the
     * class or interface represented by this object:
     * <OL>
     * <LI> C is searched for a <I>matching method</I>, as defined below. If a
     *      matching method is found, it is reflected.</LI>
     * <LI> If no matching method is found by step 1 then:
     *   <OL TYPE="a">
     *   <LI> If C is a class other than {@@code Object}, then this algorithm is
     *        invoked recursively on the superclass of C.</LI>
     *   <LI> If C is the class {@@code Object}, or if C is an interface, then
     *        the superinterfaces of C (if any) are searched for a matching
     *        method. If any such method is found, it is reflected.</LI>
     *   </OL></LI>
     * </OL>
     *
     * <p> To find a matching method in a class or interface C:&nbsp; If C
     * declares exactly one public method with the specified name and exactly
     * the same formal parameter types, that is the method reflected. If more
     * than one such method is found in C, and one of these methods has a
     * return type that is more specific than any of the others, that method is
     * reflected; otherwise one of the methods is chosen arbitrarily.
     *
     * <p>Note that there may be more than one matching method in a
     * class because while the Java language forbids a class to
     * declare multiple methods with the same signature but different
     * return types, the Java virtual machine does not.  This
     * increased flexibility in the virtual machine can be used to
     * implement various language features.  For example, covariant
     * returns can be implemented with {@@linkplain
     * java.lang.reflect.Method#isBridge bridge methods}; the bridge
     * method and the method being overridden would have the same
     * signature but different return types.
     *
     * <p> If this {@@code Class} object represents an array type, then this
     * method does not find the {@@code clone()} method.
     *
     * <p> Static methods declared in superinterfaces of the class or interface
     * represented by this {@@code Class} object are not considered members of
     * the class or interface.
     *
     * @@param name the name of the method
     * @@param parameterTypes the list of parameters
     * @@return the {@@code Method} object that matches the specified
     *         {@@code name} and {@@code parameterTypes}
     * @@throws NoSuchMethodException if a matching method is not found
     *         or if the name is "&lt;init&gt;"or "&lt;clinit&gt;".
     * @@throws NullPointerException if {@@code name} is {@@code null}
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @@jls 8.2 Class Members
     * @@jls 8.4 Method Declarations
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Method getMethod(String name, Class<?>... parameterTypes)
        throws NoSuchMethodException, SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);
        Method method = getMethod0(name, parameterTypes, true);
        if (method == null) {
            throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes));
        }
        return method;
    }


    /**
     * Returns a {@@code Constructor} object that reflects the specified
     * public constructor of the class represented by this {@@code Class}
     * object. The {@@code parameterTypes} parameter is an array of
     * {@@code Class} objects that identify the constructor's formal
     * parameter types, in declared order.
     *
     * If this {@@code Class} object represents an inner class
     * declared in a non-static context, the formal parameter types
     * include the explicit enclosing instance as the first parameter.
     *
     * <p> The constructor to reflect is the public constructor of the class
     * represented by this {@@code Class} object whose formal parameter
     * types match those specified by {@@code parameterTypes}.
     *
     * @@param parameterTypes the parameter array
     * @@return the {@@code Constructor} object of the public constructor that
     *         matches the specified {@@code parameterTypes}
     * @@throws NoSuchMethodException if a matching method is not found.
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Constructor<T> getConstructor(Class<?>... parameterTypes)
        throws NoSuchMethodException, SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);
        return getConstructor0(parameterTypes, Member.PUBLIC);
    }


    /**
     * Returns an array of {@@code Class} objects reflecting all the
     * classes and interfaces declared as members of the class represented by
     * this {@@code Class} object. This includes public, protected, default
     * (package) access, and private classes and interfaces declared by the
     * class, but excludes inherited classes and interfaces.  This method
     * returns an array of length 0 if the class declares no classes or
     * interfaces as members, or if this {@@code Class} object represents a
     * primitive type, an array class, or void.
     *
     * @@return the array of {@@code Class} objects representing all the
     *         declared members of this class
     * @@throws SecurityException
     *         If a security manager, <i>s</i>, is present and any of the
     *         following conditions is met:
     *
     *         <ul>
     *
     *         <li> the caller's class loader is not the same as the
     *         class loader of this class and invocation of
     *         {@@link SecurityManager#checkPermission
     *         s.checkPermission} method with
     *         {@@code RuntimePermission("accessDeclaredMembers")}
     *         denies access to the declared classes within this class
     *
     *         <li> the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class
     *
     *         </ul>
     *
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Class<?>[] getDeclaredClasses() throws SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), false);
        return getDeclaredClasses0();
    }


    /**
     * Returns an array of {@@code Field} objects reflecting all the fields
     * declared by the class or interface represented by this
     * {@@code Class} object. This includes public, protected, default
     * (package) access, and private fields, but excludes inherited fields.
     *
     * <p> If this {@@code Class} object represents a class or interface with no
     * declared fields, then this method returns an array of length 0.
     *
     * <p> If this {@@code Class} object represents an array type, a primitive
     * type, or void, then this method returns an array of length 0.
     *
     * <p> The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * @@return  the array of {@@code Field} objects representing all the
     *          declared fields of this class
     * @@throws  SecurityException
     *          If a security manager, <i>s</i>, is present and any of the
     *          following conditions is met:
     *
     *          <ul>
     *
     *          <li> the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@@code RuntimePermission("accessDeclaredMembers")}
     *          denies access to the declared fields within this class
     *
     *          <li> the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          </ul>
     *
     * @@since JDK1.1
     * @@jls 8.2 Class Members
     * @@jls 8.3 Field Declarations
     */
    @@CallerSensitive
    public Field[] getDeclaredFields() throws SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);
        return copyFields(privateGetDeclaredFields(false));
    }


    /**
     *
     * Returns an array containing {@@code Method} objects reflecting all the
     * declared methods of the class or interface represented by this {@@code
     * Class} object, including public, protected, default (package)
     * access, and private methods, but excluding inherited methods.
     *
     * <p> If this {@@code Class} object represents a type that has multiple
     * declared methods with the same name and parameter types, but different
     * return types, then the returned array has a {@@code Method} object for
     * each such method.
     *
     * <p> If this {@@code Class} object represents a type that has a class
     * initialization method {@@code <clinit>}, then the returned array does
     * <em>not</em> have a corresponding {@@code Method} object.
     *
     * <p> If this {@@code Class} object represents a class or interface with no
     * declared methods, then the returned array has length 0.
     *
     * <p> If this {@@code Class} object represents an array type, a primitive
     * type, or void, then the returned array has length 0.
     *
     * <p> The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * @@return  the array of {@@code Method} objects representing all the
     *          declared methods of this class
     * @@throws  SecurityException
     *          If a security manager, <i>s</i>, is present and any of the
     *          following conditions is met:
     *
     *          <ul>
     *
     *          <li> the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@@code RuntimePermission("accessDeclaredMembers")}
     *          denies access to the declared methods within this class
     *
     *          <li> the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          </ul>
     *
     * @@jls 8.2 Class Members
     * @@jls 8.4 Method Declarations
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Method[] getDeclaredMethods() throws SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);
        return copyMethods(privateGetDeclaredMethods(false));
    }


    /**
     * Returns an array of {@@code Constructor} objects reflecting all the
     * constructors declared by the class represented by this
     * {@@code Class} object. These are public, protected, default
     * (package) access, and private constructors.  The elements in the array
     * returned are not sorted and are not in any particular order.  If the
     * class has a default constructor, it is included in the returned array.
     * This method returns an array of length 0 if this {@@code Class}
     * object represents an interface, a primitive type, an array class, or
     * void.
     *
     * <p> See <em>The Java Language Specification</em>, section 8.2.
     *
     * @@return  the array of {@@code Constructor} objects representing all the
     *          declared constructors of this class
     * @@throws  SecurityException
     *          If a security manager, <i>s</i>, is present and any of the
     *          following conditions is met:
     *
     *          <ul>
     *
     *          <li> the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@@code RuntimePermission("accessDeclaredMembers")}
     *          denies access to the declared constructors within this class
     *
     *          <li> the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          </ul>
     *
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Constructor<?>[] getDeclaredConstructors() throws SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);
        return copyConstructors(privateGetDeclaredConstructors(false));
    }


    /**
     * Returns a {@@code Field} object that reflects the specified declared
     * field of the class or interface represented by this {@@code Class}
     * object. The {@@code name} parameter is a {@@code String} that specifies
     * the simple name of the desired field.
     *
     * <p> If this {@@code Class} object represents an array type, then this
     * method does not find the {@@code length} field of the array type.
     *
     * @@param name the name of the field
     * @@return  the {@@code Field} object for the specified field in this
     *          class
     * @@throws  NoSuchFieldException if a field with the specified name is
     *          not found.
     * @@throws  NullPointerException if {@@code name} is {@@code null}
     * @@throws  SecurityException
     *          If a security manager, <i>s</i>, is present and any of the
     *          following conditions is met:
     *
     *          <ul>
     *
     *          <li> the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@@code RuntimePermission("accessDeclaredMembers")}
     *          denies access to the declared field
     *
     *          <li> the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          </ul>
     *
     * @@since JDK1.1
     * @@jls 8.2 Class Members
     * @@jls 8.3 Field Declarations
     */
    @@CallerSensitive
    public Field getDeclaredField(String name)
        throws NoSuchFieldException, SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);
        Field field = searchFields(privateGetDeclaredFields(false), name);
        if (field == null) {
            throw new NoSuchFieldException(name);
        }
        return field;
    }


    /**
     * Returns a {@@code Method} object that reflects the specified
     * declared method of the class or interface represented by this
     * {@@code Class} object. The {@@code name} parameter is a
     * {@@code String} that specifies the simple name of the desired
     * method, and the {@@code parameterTypes} parameter is an array of
     * {@@code Class} objects that identify the method's formal parameter
     * types, in declared order.  If more than one method with the same
     * parameter types is declared in a class, and one of these methods has a
     * return type that is more specific than any of the others, that method is
     * returned; otherwise one of the methods is chosen arbitrarily.  If the
     * name is "&lt;init&gt;"or "&lt;clinit&gt;" a {@@code NoSuchMethodException}
     * is raised.
     *
     * <p> If this {@@code Class} object represents an array type, then this
     * method does not find the {@@code clone()} method.
     *
     * @@param name the name of the method
     * @@param parameterTypes the parameter array
     * @@return  the {@@code Method} object for the method of this class
     *          matching the specified name and parameters
     * @@throws  NoSuchMethodException if a matching method is not found.
     * @@throws  NullPointerException if {@@code name} is {@@code null}
     * @@throws  SecurityException
     *          If a security manager, <i>s</i>, is present and any of the
     *          following conditions is met:
     *
     *          <ul>
     *
     *          <li> the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@@code RuntimePermission("accessDeclaredMembers")}
     *          denies access to the declared method
     *
     *          <li> the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          </ul>
     *
     * @@jls 8.2 Class Members
     * @@jls 8.4 Method Declarations
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Method getDeclaredMethod(String name, Class<?>... parameterTypes)
        throws NoSuchMethodException, SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);
        Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
        if (method == null) {
            throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes));
        }
        return method;
    }


    /**
     * Returns a {@@code Constructor} object that reflects the specified
     * constructor of the class or interface represented by this
     * {@@code Class} object.  The {@@code parameterTypes} parameter is
     * an array of {@@code Class} objects that identify the constructor's
     * formal parameter types, in declared order.
     *
     * If this {@@code Class} object represents an inner class
     * declared in a non-static context, the formal parameter types
     * include the explicit enclosing instance as the first parameter.
     *
     * @@param parameterTypes the parameter array
     * @@return  The {@@code Constructor} object for the constructor with the
     *          specified parameter list
     * @@throws  NoSuchMethodException if a matching method is not found.
     * @@throws  SecurityException
     *          If a security manager, <i>s</i>, is present and any of the
     *          following conditions is met:
     *
     *          <ul>
     *
     *          <li> the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@@code RuntimePermission("accessDeclaredMembers")}
     *          denies access to the declared constructor
     *
     *          <li> the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          </ul>
     *
     * @@since JDK1.1
     */
    @@CallerSensitive
    public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)
        throws NoSuchMethodException, SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);
        return getConstructor0(parameterTypes, Member.DECLARED);
    }

    /**
     * Finds a resource with a given name.  The rules for searching resources
     * associated with a given class are implemented by the defining
     * {@@linkplain ClassLoader class loader} of the class.  This method
     * delegates to this object's class loader.  If this object was loaded by
     * the bootstrap class loader, the method delegates to {@@link
     * ClassLoader#getSystemResourceAsStream}.
     *
     * <p> Before delegation, an absolute resource name is constructed from the
     * given resource name using this algorithm:
     *
     * <ul>
     *
     * <li> If the {@@code name} begins with a {@@code '/'}
     * (<tt>'&#92;u002f'</tt>), then the absolute name of the resource is the
     * portion of the {@@code name} following the {@@code '/'}.
     *
     * <li> Otherwise, the absolute name is of the following form:
     *
     * <blockquote>
     *   {@@code modified_package_name/name}
     * </blockquote>
     *
     * <p> Where the {@@code modified_package_name} is the package name of this
     * object with {@@code '/'} substituted for {@@code '.'}
     * (<tt>'&#92;u002e'</tt>).
     *
     * </ul>
     *
     * @@param  name name of the desired resource
     * @@return      A {@@link java.io.InputStream} object or {@@code null} if
     *              no resource with this name is found
     * @@throws  NullPointerException If {@@code name} is {@@code null}
     * @@since  JDK1.1
     */
     public InputStream getResourceAsStream(String name) {
        name = resolveName(name);
        ClassLoader cl = getClassLoader0();
        if (cl==null) {
            // A system class.
            return ClassLoader.getSystemResourceAsStream(name);
        }
        return cl.getResourceAsStream(name);
    }

    /**
     * Finds a resource with a given name.  The rules for searching resources
     * associated with a given class are implemented by the defining
     * {@@linkplain ClassLoader class loader} of the class.  This method
     * delegates to this object's class loader.  If this object was loaded by
     * the bootstrap class loader, the method delegates to {@@link
     * ClassLoader#getSystemResource}.
     *
     * <p> Before delegation, an absolute resource name is constructed from the
     * given resource name using this algorithm:
     *
     * <ul>
     *
     * <li> If the {@@code name} begins with a {@@code '/'}
     * (<tt>'&#92;u002f'</tt>), then the absolute name of the resource is the
     * portion of the {@@code name} following the {@@code '/'}.
     *
     * <li> Otherwise, the absolute name is of the following form:
     *
     * <blockquote>
     *   {@@code modified_package_name/name}
     * </blockquote>
     *
     * <p> Where the {@@code modified_package_name} is the package name of this
     * object with {@@code '/'} substituted for {@@code '.'}
     * (<tt>'&#92;u002e'</tt>).
     *
     * </ul>
     *
     * @@param  name name of the desired resource
     * @@return      A  {@@link java.net.URL} object or {@@code null} if no
     *              resource with this name is found
     * @@since  JDK1.1
     */
    public java.net.URL getResource(String name) {
        name = resolveName(name);
        ClassLoader cl = getClassLoader0();
        if (cl==null) {
            // A system class.
            return ClassLoader.getSystemResource(name);
        }
        return cl.getResource(name);
    }



    /** protection domain returned when the internal domain is null */
    private static java.security.ProtectionDomain allPermDomain;


    /**
     * Returns the {@@code ProtectionDomain} of this class.  If there is a
     * security manager installed, this method first calls the security
     * manager's {@@code checkPermission} method with a
     * {@@code RuntimePermission("getProtectionDomain")} permission to
     * ensure it's ok to get the
     * {@@code ProtectionDomain}.
     *
     * @@return the ProtectionDomain of this class
     *
     * @@throws SecurityException
     *        if a security manager exists and its
     *        {@@code checkPermission} method doesn't allow
     *        getting the ProtectionDomain.
     *
     * @@see java.security.ProtectionDomain
     * @@see SecurityManager#checkPermission
     * @@see java.lang.RuntimePermission
     * @@since 1.2
     */
    public java.security.ProtectionDomain getProtectionDomain() {
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
        }
        java.security.ProtectionDomain pd = getProtectionDomain0();
        if (pd == null) {
            if (allPermDomain == null) {
                java.security.Permissions perms =
                    new java.security.Permissions();
                perms.add(SecurityConstants.ALL_PERMISSION);
                allPermDomain =
                    new java.security.ProtectionDomain(null, perms);
            }
            pd = allPermDomain;
        }
        return pd;
    }


    /**
     * Returns the ProtectionDomain of this class.
     */
    private native java.security.ProtectionDomain getProtectionDomain0();

    /*
     * Return the Virtual Machine's Class object for the named
     * primitive type.
     */
    static native Class<?> getPrimitiveClass(String name);

    /*
     * Check if client is allowed to access members.  If access is denied,
     * throw a SecurityException.
     *
     * This method also enforces package access.
     *
     * <p> Default policy: allow all clients access with normal Java access
     * control.
     */
    private void checkMemberAccess(int which, Class<?> caller, boolean checkProxyInterfaces) {
        final SecurityManager s = System.getSecurityManager();
        if (s != null) {
            /* Default policy allows access to all {@@link Member#PUBLIC} members,
             * as well as access to classes that have the same class loader as the caller.
             * In all other cases, it requires RuntimePermission("accessDeclaredMembers")
             * permission.
             */
            final ClassLoader ccl = ClassLoader.getClassLoader(caller);
            final ClassLoader cl = getClassLoader0();
            if (which != Member.PUBLIC) {
                if (ccl != cl) {
                    s.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
                }
            }
            this.checkPackageAccess(ccl, checkProxyInterfaces);
        }
    }

    /*
     * Checks if a client loaded in ClassLoader ccl is allowed to access this
     * class under the current package access policy. If access is denied,
     * throw a SecurityException.
     */
    private void checkPackageAccess(final ClassLoader ccl, boolean checkProxyInterfaces) {
        final SecurityManager s = System.getSecurityManager();
        if (s != null) {
            final ClassLoader cl = getClassLoader0();

            if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
                String name = this.getName();
                int i = name.lastIndexOf('.');
                if (i != -1) {
                    // skip the package access check on a proxy class in default proxy package
                    String pkg = name.substring(0, i);
                    if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
                        s.checkPackageAccess(pkg);
                    }
                }
            }
            // check package access on the proxy interfaces
            if (checkProxyInterfaces && Proxy.isProxyClass(this)) {
                ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
            }
        }
    }

    /**
     * Add a package name prefix if the name is not absolute Remove leading "/"
     * if name is absolute
     */
    private String resolveName(String name) {
        if (name == null) {
            return name;
        }
        if (!name.startsWith("/")) {
            Class<?> c = this;
            while (c.isArray()) {
                c = c.getComponentType();
            }
            String baseName = c.getName();
            int index = baseName.lastIndexOf('.');
            if (index != -1) {
                name = baseName.substring(0, index).replace('.', '/')
                    +"/"+name;
            }
        } else {
            name = name.substring(1);
        }
        return name;
    }

    /**
     * Atomic operations support.
     */
    private static class Atomic {
        @@ikvm.internal.InterlockedCompareAndSet("reflectionData")
        static native <T> boolean casReflectionData(Class<?> clazz,
                                             SoftReference<ReflectionData<T>> oldData,
                                             SoftReference<ReflectionData<T>> newData);

        @@ikvm.internal.InterlockedCompareAndSet("annotationType")
        static native <T> boolean casAnnotationType(Class<?> clazz,
                                             AnnotationType oldType,
                                             AnnotationType newType);

        @@ikvm.internal.InterlockedCompareAndSet("annotationData")
        static native <T> boolean casAnnotationData(Class<?> clazz,
                                             AnnotationData oldData,
                                             AnnotationData newData);
    }

    /**
     * Reflection support.
     */

    // Caches for certain reflective results
    private static boolean useCaches;

    // reflection data that might get invalidated when JVM TI RedefineClasses() is called
    private static class ReflectionData<T> {
        volatile Field[] declaredFields;
        volatile Field[] publicFields;
        volatile Method[] declaredMethods;
        volatile Method[] publicMethods;
        volatile Constructor<T>[] declaredConstructors;
        volatile Constructor<T>[] publicConstructors;
        // Intermediate results for getFields and getMethods
        volatile Field[] declaredPublicFields;
        volatile Method[] declaredPublicMethods;
        volatile Class<?>[] interfaces;

        // Value of classRedefinedCount when we created this ReflectionData instance
        final int redefinedCount;

        ReflectionData(int redefinedCount) {
            this.redefinedCount = redefinedCount;
        }
    }

    private volatile transient SoftReference<ReflectionData<T>> reflectionData;

    // Incremented by the VM on each call to JVM TI RedefineClasses()
    // that redefines this class or a superclass.
    private volatile transient int classRedefinedCount;

    // Lazily create and cache ReflectionData
    private ReflectionData<T> reflectionData() {
        SoftReference<ReflectionData<T>> reflectionData = this.reflectionData;
        int classRedefinedCount = this.classRedefinedCount;
        ReflectionData<T> rd;
        if (useCaches &&
            reflectionData != null &&
            (rd = reflectionData.get()) != null &&
            rd.redefinedCount == classRedefinedCount) {
            return rd;
        }
        // else no SoftReference or cleared SoftReference or stale ReflectionData
        // -> create and replace new instance
        return newReflectionData(reflectionData, classRedefinedCount);
    }

    private ReflectionData<T> newReflectionData(SoftReference<ReflectionData<T>> oldReflectionData,
                                                int classRedefinedCount) {
        if (!useCaches) return null;

        while (true) {
            ReflectionData<T> rd = new ReflectionData<>(classRedefinedCount);
            // try to CAS it...
            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference<>(rd))) {
                return rd;
            }
            // else retry
            oldReflectionData = this.reflectionData;
            classRedefinedCount = this.classRedefinedCount;
            if (oldReflectionData != null &&
                (rd = oldReflectionData.get()) != null &&
                rd.redefinedCount == classRedefinedCount) {
                return rd;
            }
        }
    }

    // Generic signature handling
    private native String getGenericSignature0();

    // Generic info repository; lazily initialized
    private volatile transient ClassRepository genericInfo;

    // accessor for factory
    private GenericsFactory getFactory() {
        // create scope and factory
        return CoreReflectionFactory.make(this, ClassScope.make(this));
    }

    // accessor for generic info repository;
    // generic info is lazily initialized
    private ClassRepository getGenericInfo() {
        ClassRepository genericInfo = this.genericInfo;
        if (genericInfo == null) {
            String signature = getGenericSignature0();
            if (signature == null) {
                genericInfo = ClassRepository.NONE;
            } else {
                genericInfo = ClassRepository.make(signature, getFactory());
            }
            this.genericInfo = genericInfo;
        }
        return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
    }

    // Annotations handling
    private native Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationsImpl();
    // Since 1.8
    native byte[] getRawTypeAnnotations();
    static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
        return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
    }

    native ConstantPool getConstantPool();

    //
    //
    // java.lang.reflect.Field handling
    //
    //

    // Returns an array of "root" fields. These Field objects must NOT
    // be propagated to the outside world, but must instead be copied
    // via ReflectionFactory.copyField.
    private Field[] privateGetDeclaredFields(boolean publicOnly) {
        checkInitted();
        Field[] res;
        ReflectionData<T> rd = reflectionData();
        if (rd != null) {
            res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
            if (res != null) return res;
        }
        // No cached value available; request value from VM
        res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
        if (rd != null) {
            if (publicOnly) {
                rd.declaredPublicFields = res;
            } else {
                rd.declaredFields = res;
            }
        }
        return res;
    }

    // Returns an array of "root" fields. These Field objects must NOT
    // be propagated to the outside world, but must instead be copied
    // via ReflectionFactory.copyField.
    private Field[] privateGetPublicFields(Set<Class<?>> traversedInterfaces) {
        checkInitted();
        Field[] res;
        ReflectionData<T> rd = reflectionData();
        if (rd != null) {
            res = rd.publicFields;
            if (res != null) return res;
        }

        // No cached value available; compute value recursively.
        // Traverse in correct order for getField().
        List<Field> fields = new ArrayList<>();
        if (traversedInterfaces == null) {
            traversedInterfaces = new HashSet<>();
        }

        // Local fields
        Field[] tmp = privateGetDeclaredFields(true);
        addAll(fields, tmp);

        // Direct superinterfaces, recursively
        for (Class<?> c : getInterfaces()) {
            if (!traversedInterfaces.contains(c)) {
                traversedInterfaces.add(c);
                addAll(fields, c.privateGetPublicFields(traversedInterfaces));
            }
        }

        // Direct superclass, recursively
        if (!isInterface()) {
            Class<?> c = getSuperclass();
            if (c != null) {
                addAll(fields, c.privateGetPublicFields(traversedInterfaces));
            }
        }

        res = new Field[fields.size()];
        fields.toArray(res);
        if (rd != null) {
            rd.publicFields = res;
        }
        return res;
    }

    private static void addAll(Collection<Field> c, Field[] o) {
        for (int i = 0; i < o.length; i++) {
            c.add(o[i]);
        }
    }


    //
    //
    // java.lang.reflect.Constructor handling
    //
    //

    // Returns an array of "root" constructors. These Constructor
    // objects must NOT be propagated to the outside world, but must
    // instead be copied via ReflectionFactory.copyConstructor.
    private Constructor<T>[] privateGetDeclaredConstructors(boolean publicOnly) {
        checkInitted();
        Constructor<T>[] res;
        ReflectionData<T> rd = reflectionData();
        if (rd != null) {
            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
            if (res != null) return res;
        }
        // No cached value available; request value from VM
        if (isInterface()) {
            @@SuppressWarnings("unchecked")
            Constructor<T>[] temporaryRes = (Constructor<T>[]) new Constructor<?>[0];
            res = temporaryRes;
        } else {
            res = getDeclaredConstructors0(publicOnly);
        }
        if (rd != null) {
            if (publicOnly) {
                rd.publicConstructors = res;
            } else {
                rd.declaredConstructors = res;
            }
        }
        return res;
    }

    //
    //
    // java.lang.reflect.Method handling
    //
    //

    // Returns an array of "root" methods. These Method objects must NOT
    // be propagated to the outside world, but must instead be copied
    // via ReflectionFactory.copyMethod.
    private Method[] privateGetDeclaredMethods(boolean publicOnly) {
        checkInitted();
        Method[] res;
        ReflectionData<T> rd = reflectionData();
        if (rd != null) {
            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
            if (res != null) return res;
        }
        // No cached value available; request value from VM
        res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
        if (rd != null) {
            if (publicOnly) {
                rd.declaredPublicMethods = res;
            } else {
                rd.declaredMethods = res;
            }
        }
        return res;
    }

    static class MethodArray {
        // Don't add or remove methods except by add() or remove() calls.
        private Method[] methods;
        private int length;
        private int defaults;

        MethodArray() {
            this(20);
        }

        MethodArray(int initialSize) {
            if (initialSize < 2)
                throw new IllegalArgumentException("Size should be 2 or more");

            methods = new Method[initialSize];
            length = 0;
            defaults = 0;
        }

        boolean hasDefaults() {
            return defaults != 0;
        }

        void add(Method m) {
            if (length == methods.length) {
                methods = Arrays.copyOf(methods, 2 * methods.length);
            }
            methods[length++] = m;

            if (m != null && m.isDefault())
                defaults++;
        }

        void addAll(Method[] ma) {
            for (int i = 0; i < ma.length; i++) {
                add(ma[i]);
            }
        }

        void addAll(MethodArray ma) {
            for (int i = 0; i < ma.length(); i++) {
                add(ma.get(i));
            }
        }

        void addIfNotPresent(Method newMethod) {
            for (int i = 0; i < length; i++) {
                Method m = methods[i];
                if (m == newMethod || (m != null && m.equals(newMethod))) {
                    return;
                }
            }
            add(newMethod);
        }

        void addAllIfNotPresent(MethodArray newMethods) {
            for (int i = 0; i < newMethods.length(); i++) {
                Method m = newMethods.get(i);
                if (m != null) {
                    addIfNotPresent(m);
                }
            }
        }

        /* Add Methods declared in an interface to this MethodArray.
         * Static methods declared in interfaces are not inherited.
         */
        void addInterfaceMethods(Method[] methods) {
            for (Method candidate : methods) {
                if (!Modifier.isStatic(candidate.getModifiers())) {
                    add(candidate);
                }
            }
        }

        int length() {
            return length;
        }

        Method get(int i) {
            return methods[i];
        }

        Method getFirst() {
            for (Method m : methods)
                if (m != null)
                    return m;
            return null;
        }

        void removeByNameAndDescriptor(Method toRemove) {
            for (int i = 0; i < length; i++) {
                Method m = methods[i];
                if (m != null && matchesNameAndDescriptor(m, toRemove)) {
                    remove(i);
                }
            }
        }

        private void remove(int i) {
            if (methods[i] != null && methods[i].isDefault())
                defaults--;
            methods[i] = null;
        }

        private boolean matchesNameAndDescriptor(Method m1, Method m2) {
            return m1.getReturnType() == m2.getReturnType() &&
                   m1.getName() == m2.getName() && // name is guaranteed to be interned
                   arrayContentsEq(m1.getParameterTypes(),
                           m2.getParameterTypes());
        }

        void compactAndTrim() {
            int newPos = 0;
            // Get rid of null slots
            for (int pos = 0; pos < length; pos++) {
                Method m = methods[pos];
                if (m != null) {
                    if (pos != newPos) {
                        methods[newPos] = m;
                    }
                    newPos++;
                }
            }
            if (newPos != methods.length) {
                methods = Arrays.copyOf(methods, newPos);
            }
        }

        /* Removes all Methods from this MethodArray that have a more specific
         * default Method in this MethodArray.
         *
         * Users of MethodArray are responsible for pruning Methods that have
         * a more specific <em>concrete</em> Method.
         */
        void removeLessSpecifics() {
            if (!hasDefaults())
                return;

            for (int i = 0; i < length; i++) {
                Method m = get(i);
                if  (m == null || !m.isDefault())
                    continue;

                for (int j  = 0; j < length; j++) {
                    if (i == j)
                        continue;

                    Method candidate = get(j);
                    if (candidate == null)
                        continue;

                    if (!matchesNameAndDescriptor(m, candidate))
                        continue;

                    if (hasMoreSpecificClass(m, candidate))
                        remove(j);
                }
            }
        }

        Method[] getArray() {
            return methods;
        }

        // Returns true if m1 is more specific than m2
        static boolean hasMoreSpecificClass(Method m1, Method m2) {
            Class<?> m1Class = m1.getDeclaringClass();
            Class<?> m2Class = m2.getDeclaringClass();
            return m1Class != m2Class && m2Class.isAssignableFrom(m1Class);
        }
    }


    // Returns an array of "root" methods. These Method objects must NOT
    // be propagated to the outside world, but must instead be copied
    // via ReflectionFactory.copyMethod.
    private Method[] privateGetPublicMethods() {
        checkInitted();
        Method[] res;
        ReflectionData<T> rd = reflectionData();
        if (rd != null) {
            res = rd.publicMethods;
            if (res != null) return res;
        }

        // No cached value available; compute value recursively.
        // Start by fetching public declared methods
        MethodArray methods = new MethodArray();
        {
            Method[] tmp = privateGetDeclaredMethods(true);
            methods.addAll(tmp);
        }
        // Now recur over superclass and direct superinterfaces.
        // Go over superinterfaces first so we can more easily filter
        // out concrete implementations inherited from superclasses at
        // the end.
        MethodArray inheritedMethods = new MethodArray();
        for (Class<?> i : getInterfaces()) {
            inheritedMethods.addInterfaceMethods(i.privateGetPublicMethods());
        }
        if (!isInterface()) {
            Class<?> c = getSuperclass();
            if (c != null) {
                MethodArray supers = new MethodArray();
                supers.addAll(c.privateGetPublicMethods());
                // Filter out concrete implementations of any
                // interface methods
                for (int i = 0; i < supers.length(); i++) {
                    Method m = supers.get(i);
                    if (m != null &&
                            !Modifier.isAbstract(m.getModifiers()) &&
                            !m.isDefault()) {
                        inheritedMethods.removeByNameAndDescriptor(m);
                    }
                }
                // Insert superclass's inherited methods before
                // superinterfaces' to satisfy getMethod's search
                // order
                supers.addAll(inheritedMethods);
                inheritedMethods = supers;
            }
        }
        // Filter out all local methods from inherited ones
        for (int i = 0; i < methods.length(); i++) {
            Method m = methods.get(i);
            inheritedMethods.removeByNameAndDescriptor(m);
        }
        methods.addAllIfNotPresent(inheritedMethods);
        methods.removeLessSpecifics();
        methods.compactAndTrim();
        res = methods.getArray();
        if (rd != null) {
            rd.publicMethods = res;
        }
        return res;
    }


    //
    // Helpers for fetchers of one field, method, or constructor
    //

    private static Field searchFields(Field[] fields, String name) {
        String internedName = name.intern();
        for (int i = 0; i < fields.length; i++) {
            if (fields[i].getName() == internedName) {
                return getReflectionFactory().copyField(fields[i]);
            }
        }
        return null;
    }

    private Field getField0(String name) throws NoSuchFieldException {
        // Note: the intent is that the search algorithm this routine
        // uses be equivalent to the ordering imposed by
        // privateGetPublicFields(). It fetches only the declared
        // public fields for each class, however, to reduce the number
        // of Field objects which have to be created for the common
        // case where the field being requested is declared in the
        // class which is being queried.
        Field res;
        // Search declared public fields
        if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
            return res;
        }
        // Direct superinterfaces, recursively
        Class<?>[] interfaces = getInterfaces();
        for (int i = 0; i < interfaces.length; i++) {
            Class<?> c = interfaces[i];
            if ((res = c.getField0(name)) != null) {
                return res;
            }
        }
        // Direct superclass, recursively
        if (!isInterface()) {
            Class<?> c = getSuperclass();
            if (c != null) {
                if ((res = c.getField0(name)) != null) {
                    return res;
                }
            }
        }
        return null;
    }

    private static Method searchMethods(Method[] methods,
                                        String name,
                                        Class<?>[] parameterTypes)
    {
        Method res = null;
        String internedName = name.intern();
        for (int i = 0; i < methods.length; i++) {
            Method m = methods[i];
            if (m.getName() == internedName
                && arrayContentsEq(parameterTypes, m.getParameterTypes())
                && (res == null
                    || res.getReturnType().isAssignableFrom(m.getReturnType())))
                res = m;
        }

        return (res == null ? res : getReflectionFactory().copyMethod(res));
    }

    private Method getMethod0(String name, Class<?>[] parameterTypes, boolean includeStaticMethods) {
        MethodArray interfaceCandidates = new MethodArray(2);
        Method res =  privateGetMethodRecursive(name, parameterTypes, includeStaticMethods, interfaceCandidates);
        if (res != null)
            return res;

        // Not found on class or superclass directly
        interfaceCandidates.removeLessSpecifics();
        return interfaceCandidates.getFirst(); // may be null
    }

    private Method privateGetMethodRecursive(String name,
            Class<?>[] parameterTypes,
            boolean includeStaticMethods,
            MethodArray allInterfaceCandidates) {
        // Note: the intent is that the search algorithm this routine
        // uses be equivalent to the ordering imposed by
        // privateGetPublicMethods(). It fetches only the declared
        // public methods for each class, however, to reduce the
        // number of Method objects which have to be created for the
        // common case where the method being requested is declared in
        // the class which is being queried.
        //
        // Due to default methods, unless a method is found on a superclass,
        // methods declared in any superinterface needs to be considered.
        // Collect all candidates declared in superinterfaces in {@@code
        // allInterfaceCandidates} and select the most specific if no match on
        // a superclass is found.

        // Must _not_ return root methods
        Method res;
        // Search declared public methods
        if ((res = searchMethods(privateGetDeclaredMethods(true),
                                 name,
                                 parameterTypes)) != null) {
            if (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))
                return res;
        }
        // Search superclass's methods
        if (!isInterface()) {
            Class<? super T> c = getSuperclass();
            if (c != null) {
                if ((res = c.getMethod0(name, parameterTypes, true)) != null) {
                    return res;
                }
            }
        }
        // Search superinterfaces' methods
        Class<?>[] interfaces = getInterfaces();
        for (Class<?> c : interfaces)
            if ((res = c.getMethod0(name, parameterTypes, false)) != null)
                allInterfaceCandidates.add(res);
        // Not found
        return null;
    }

    private Constructor<T> getConstructor0(Class<?>[] parameterTypes,
                                        int which) throws NoSuchMethodException
    {
        Constructor<T>[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
        for (Constructor<T> constructor : constructors) {
            if (arrayContentsEq(parameterTypes,
                                constructor.getParameterTypes())) {
                return getReflectionFactory().copyConstructor(constructor);
            }
        }
        throw new NoSuchMethodException(getName() + ".<init>" + argumentTypesToString(parameterTypes));
    }

    //
    // Other helpers and base implementation
    //

    private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
        if (a1 == null) {
            return a2 == null || a2.length == 0;
        }

        if (a2 == null) {
            return a1.length == 0;
        }

        if (a1.length != a2.length) {
            return false;
        }

        for (int i = 0; i < a1.length; i++) {
            if (a1[i] != a2[i]) {
                return false;
            }
        }

        return true;
    }

    private static Field[] copyFields(Field[] arg) {
        Field[] out = new Field[arg.length];
        ReflectionFactory fact = getReflectionFactory();
        for (int i = 0; i < arg.length; i++) {
            out[i] = fact.copyField(arg[i]);
        }
        return out;
    }

    private static Method[] copyMethods(Method[] arg) {
        Method[] out = new Method[arg.length];
        ReflectionFactory fact = getReflectionFactory();
        for (int i = 0; i < arg.length; i++) {
            out[i] = fact.copyMethod(arg[i]);
        }
        return out;
    }

    private static <U> Constructor<U>[] copyConstructors(Constructor<U>[] arg) {
        Constructor<U>[] out = arg.clone();
        ReflectionFactory fact = getReflectionFactory();
        for (int i = 0; i < out.length; i++) {
            out[i] = fact.copyConstructor(out[i]);
        }
        return out;
    }

    private native Field[]       getDeclaredFields0(boolean publicOnly);
    private native Method[]      getDeclaredMethods0(boolean publicOnly);
    private native Constructor<T>[] getDeclaredConstructors0(boolean publicOnly);
    private native Class<?>[]   getDeclaredClasses0();

    private static String        argumentTypesToString(Class<?>[] argTypes) {
        StringBuilder buf = new StringBuilder();
        buf.append("(");
        if (argTypes != null) {
            for (int i = 0; i < argTypes.length; i++) {
                if (i > 0) {
                    buf.append(", ");
                }
                Class<?> c = argTypes[i];
                buf.append((c == null) ? "null" : c.getName());
            }
        }
        buf.append(")");
        return buf.toString();
    }

    /** use serialVersionUID from JDK 1.1 for interoperability */
    private static final long serialVersionUID = 3206093459760846163L;


    /**
     * Class Class is special cased within the Serialization Stream Protocol.
     *
     * A Class instance is written initially into an ObjectOutputStream in the
     * following format:
     * <pre>
     *      {@@code TC_CLASS} ClassDescriptor
     *      A ClassDescriptor is a special cased serialization of
     *      a {@@code java.io.ObjectStreamClass} instance.
     * </pre>
     * A new handle is generated for the initial time the class descriptor
     * is written into the stream. Future references to the class descriptor
     * are written as references to the initial class descriptor instance.
     *
     * @@see java.io.ObjectStreamClass
     */
    
    @@ikvm.lang.Property(get="get_spf")
    private static final ObjectStreamField[] serialPersistentFields = null;
    
    private static ObjectStreamField[] get_spf() {
        return java.io.ObjectStreamClass.NO_FIELDS;
    }


    /**
     * Returns the assertion status that would be assigned to this
     * class if it were to be initialized at the time this method is invoked.
     * If this class has had its assertion status set, the most recent
     * setting will be returned; otherwise, if any package default assertion
     * status pertains to this class, the most recent setting for the most
     * specific pertinent package default assertion status is returned;
     * otherwise, if this class is not a system class (i.e., it has a
     * class loader) its class loader's default assertion status is returned;
     * otherwise, the system class default assertion status is returned.
     * <p>
     * Few programmers will have any need for this method; it is provided
     * for the benefit of the JRE itself.  (It allows a class to determine at
     * the time that it is initialized whether assertions should be enabled.)
     * Note that this method is not guaranteed to return the actual
     * assertion status that was (or will be) associated with the specified
     * class when it was (or will be) initialized.
     *
     * @@return the desired assertion status of the specified class.
     * @@see    java.lang.ClassLoader#setClassAssertionStatus
     * @@see    java.lang.ClassLoader#setPackageAssertionStatus
     * @@see    java.lang.ClassLoader#setDefaultAssertionStatus
     * @@since  1.4
     */
    public boolean desiredAssertionStatus() {
        ClassLoader loader = getClassLoader();
        // If the loader is null this is a system class, so ask the VM
        if (loader == null)
            return desiredAssertionStatus0(this);

        // If the classloader has been initialized with the assertion
        // directives, ask it. Otherwise, ask the VM.
        synchronized(loader.assertionLock) {
            if (loader.classAssertionStatus != null) {
                return loader.desiredAssertionStatus(getName());
            }
        }
        return desiredAssertionStatus0(this);
    }

    // Retrieves the desired assertion status of this class from the VM
    private static native boolean desiredAssertionStatus0(Class<?> clazz);

    /**
     * Returns true if and only if this class was declared as an enum in the
     * source code.
     *
     * @@return true if and only if this class was declared as an enum in the
     *     source code
     * @@since 1.5
     */
    public boolean isEnum() {
        // An enum must both directly extend java.lang.Enum and have
        // the ENUM bit set; classes for specialized enum constants
        // don't do the former.
        return (this.getModifiers() & ENUM) != 0 &&
        this.getSuperclass() == java.lang.Enum.class;
    }

    // Fetches the factory for reflective objects
    private static ReflectionFactory getReflectionFactory() {
        if (reflectionFactory == null) {
            reflectionFactory =
                java.security.AccessController.doPrivileged
                    (new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());
        }
        return reflectionFactory;
    }
    private static ReflectionFactory reflectionFactory;

    // To be able to query system properties as soon as they're available
    private static boolean initted;
    private static void checkInitted() {
        if (initted) return;
        useCaches = true;
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
                public Void run() {
                    // Tests to ensure the system properties table is fully
                    // initialized. This is needed because reflection code is
                    // called very early in the initialization process (before
                    // command-line arguments have been parsed and therefore
                    // these user-settable properties installed.)

                    if (!sun.misc.VM.isBooted()) {
                        return null;
                    }

                    // Doesn't use Boolean.getBoolean to avoid class init.
                    String val =
                        System.getProperty("sun.reflect.noCaches");
                    if (val != null && val.equals("true")) {
                        useCaches = false;
                    }

                    initted = true;
                    return null;
                }
            });
    }

    /**
     * Returns the elements of this enum class or null if this
     * Class object does not represent an enum type.
     *
     * @@return an array containing the values comprising the enum class
     *     represented by this Class object in the order they're
     *     declared, or null if this Class object does not
     *     represent an enum type
     * @@since 1.5
     */
    public T[] getEnumConstants() {
        T[] values = getEnumConstantsShared();
        return (values != null) ? values.clone() : null;
    }

    /**
     * Returns the elements of this enum class or null if this
     * Class object does not represent an enum type;
     * identical to getEnumConstants except that the result is
     * uncloned, cached, and shared by all callers.
     */
    T[] getEnumConstantsShared() {
        if (enumConstants == null) {
            if (!isEnum()) return null;
            try {
                final Method values = getMethod("values");
                java.security.AccessController.doPrivileged(
                    new java.security.PrivilegedAction<Void>() {
                        public Void run() {
                                values.setAccessible(true);
                                return null;
                            }
                        });
                @@SuppressWarnings("unchecked")
                T[] temporaryConstants = (T[])values.invoke(null);
                enumConstants = temporaryConstants;
            }
            // These can happen when users concoct enum-like classes
            // that don't comply with the enum spec.
            catch (InvocationTargetException | NoSuchMethodException |
                   IllegalAccessException ex) { return null; }
        }
        return enumConstants;
    }
    private volatile transient T[] enumConstants;

    /**
     * Returns a map from simple name to enum constant.  This package-private
     * method is used internally by Enum to implement
     * {@@code public static <T extends Enum<T>> T valueOf(Class<T>, String)}
     * efficiently.  Note that the map is returned by this method is
     * created lazily on first use.  Typically it won't ever get created.
     */
    Map<String, T> enumConstantDirectory() {
        if (enumConstantDirectory == null) {
            T[] universe = getEnumConstantsShared();
            if (universe == null)
                throw new IllegalArgumentException(
                    getName() + " is not an enum type");
            Map<String, T> m = new HashMap<>(2 * universe.length);
            for (T constant : universe)
                m.put(((Enum<?>)constant).name(), constant);
            enumConstantDirectory = m;
        }
        return enumConstantDirectory;
    }
    private volatile transient Map<String, T> enumConstantDirectory;

    /**
     * Casts an object to the class or interface represented
     * by this {@@code Class} object.
     *
     * @@param obj the object to be cast
     * @@return the object after casting, or null if obj is null
     *
     * @@throws ClassCastException if the object is not
     * null and is not assignable to the type T.
     *
     * @@since 1.5
     */
    @@SuppressWarnings("unchecked")
    public T cast(Object obj) {
        if (obj != null && !isInstance(obj))
            throw new ClassCastException(cannotCastMsg(obj));
        return (T) obj;
    }

    private String cannotCastMsg(Object obj) {
        return "Cannot cast " + obj.getClass().getName() + " to " + getName();
    }

    /**
     * Casts this {@@code Class} object to represent a subclass of the class
     * represented by the specified class object.  Checks that the cast
     * is valid, and throws a {@@code ClassCastException} if it is not.  If
     * this method succeeds, it always returns a reference to this class object.
     *
     * <p>This method is useful when a client needs to "narrow" the type of
     * a {@@code Class} object to pass it to an API that restricts the
     * {@@code Class} objects that it is willing to accept.  A cast would
     * generate a compile-time warning, as the correctness of the cast
     * could not be checked at runtime (because generic types are implemented
     * by erasure).
     *
     * @@param <U> the type to cast this class object to
     * @@param clazz the class of the type to cast this class object to
     * @@return this {@@code Class} object, cast to represent a subclass of
     *    the specified class object.
     * @@throws ClassCastException if this {@@code Class} object does not
     *    represent a subclass of the specified class (here "subclass" includes
     *    the class itself).
     * @@since 1.5
     */
    @@SuppressWarnings("unchecked")
    public <U> Class<? extends U> asSubclass(Class<U> clazz) {
        if (clazz.isAssignableFrom(this))
            return (Class<? extends U>) this;
        else
            throw new ClassCastException(this.toString());
    }

    /**
     * @@throws NullPointerException {@@inheritDoc}
     * @@since 1.5
     */
    @@SuppressWarnings("unchecked")
    public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
        Objects.requireNonNull(annotationClass);

        return (A) annotationData().annotations.get(annotationClass);
    }

    /**
     * {@@inheritDoc}
     * @@throws NullPointerException {@@inheritDoc}
     * @@since 1.5
     */
    @@Override
    public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
        return GenericDeclaration.super.isAnnotationPresent(annotationClass);
    }

    /**
     * @@throws NullPointerException {@@inheritDoc}
     * @@since 1.8
     */
    @@Override
    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationClass) {
        Objects.requireNonNull(annotationClass);

        AnnotationData annotationData = annotationData();
        return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
                                                          this,
                                                          annotationClass);
    }

    /**
     * @@since 1.5
     */
    public Annotation[] getAnnotations() {
        return AnnotationParser.toArray(annotationData().annotations);
    }

    /**
     * @@throws NullPointerException {@@inheritDoc}
     * @@since 1.8
     */
    @@Override
    @@SuppressWarnings("unchecked")
    public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass) {
        Objects.requireNonNull(annotationClass);

        return (A) annotationData().declaredAnnotations.get(annotationClass);
    }

    /**
     * @@throws NullPointerException {@@inheritDoc}
     * @@since 1.8
     */
    @@Override
    public <A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationClass) {
        Objects.requireNonNull(annotationClass);

        return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
                                                                 annotationClass);
    }

    /**
     * @@since 1.5
     */
    public Annotation[] getDeclaredAnnotations()  {
        return AnnotationParser.toArray(annotationData().declaredAnnotations);
    }

    // annotation data that might get invalidated when JVM TI RedefineClasses() is called
    private static class AnnotationData {
        final Map<Class<? extends Annotation>, Annotation> annotations;
        final Map<Class<? extends Annotation>, Annotation> declaredAnnotations;

        // Value of classRedefinedCount when we created this AnnotationData instance
        final int redefinedCount;

        AnnotationData(Map<Class<? extends Annotation>, Annotation> annotations,
                       Map<Class<? extends Annotation>, Annotation> declaredAnnotations,
                       int redefinedCount) {
            this.annotations = annotations;
            this.declaredAnnotations = declaredAnnotations;
            this.redefinedCount = redefinedCount;
        }
    }

    // Annotations cache
    @@SuppressWarnings("UnusedDeclaration")
    private volatile transient AnnotationData annotationData;

    private AnnotationData annotationData() {
        while (true) { // retry loop
            AnnotationData annotationData = this.annotationData;
            int classRedefinedCount = this.classRedefinedCount;
            if (annotationData != null &&
                annotationData.redefinedCount == classRedefinedCount) {
                return annotationData;
            }
            // null or stale annotationData -> optimistically create new instance
            AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
            // try to install it
            if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
                // successfully installed new AnnotationData
                return newAnnotationData;
            }
        }
    }

    private AnnotationData createAnnotationData(int classRedefinedCount) {
        Map<Class<? extends Annotation>, Annotation> declaredAnnotations =
            getDeclaredAnnotationsImpl();
        Class<?> superClass = getSuperclass();
        Map<Class<? extends Annotation>, Annotation> annotations = null;
        if (superClass != null) {
            Map<Class<? extends Annotation>, Annotation> superAnnotations =
                superClass.annotationData().annotations;
            for (Map.Entry<Class<? extends Annotation>, Annotation> e : superAnnotations.entrySet()) {
                Class<? extends Annotation> annotationClass = e.getKey();
                if (AnnotationType.getInstance(annotationClass).isInherited()) {
                    if (annotations == null) { // lazy construction
                        annotations = new LinkedHashMap<>((Math.max(
                                declaredAnnotations.size(),
                                Math.min(12, declaredAnnotations.size() + superAnnotations.size())
                            ) * 4 + 2) / 3
                        );
                    }
                    annotations.put(annotationClass, e.getValue());
                }
            }
        }
        if (annotations == null) {
            // no inherited annotations -> share the Map with declaredAnnotations
            annotations = declaredAnnotations;
        } else {
            // at least one inherited annotation -> declared may override inherited
            annotations.putAll(declaredAnnotations);
        }
        return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
    }

    // Annotation types cache their internal (AnnotationType) form

    @@SuppressWarnings("UnusedDeclaration")
    private volatile transient AnnotationType annotationType;

    boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
        return Atomic.casAnnotationType(this, oldType, newType);
    }

    AnnotationType getAnnotationType() {
        return annotationType;
    }

    Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap() {
        return annotationData().declaredAnnotations;
    }

    /* Backing store of user-defined values pertaining to this class.
     * Maintained by the ClassValue class.
     */
    transient ClassValue.ClassValueMap classValueMap;

    /**
     * Returns an {@@code AnnotatedType} object that represents the use of a
     * type to specify the superclass of the entity represented by this {@@code
     * Class} object. (The <em>use</em> of type Foo to specify the superclass
     * in '...  extends Foo' is distinct from the <em>declaration</em> of type
     * Foo.)
     *
     * <p> If this {@@code Class} object represents a type whose declaration
     * does not explicitly indicate an annotated superclass, then the return
     * value is an {@@code AnnotatedType} object representing an element with no
     * annotations.
     *
     * <p> If this {@@code Class} represents either the {@@code Object} class, an
     * interface type, an array type, a primitive type, or void, the return
     * value is {@@code null}.
     *
     * @@return an object representing the superclass
     * @@since 1.8
     */
    public AnnotatedType getAnnotatedSuperclass() {
        if (this == Object.class ||
                isInterface() ||
                isArray() ||
                isPrimitive() ||
                this == Void.TYPE) {
            return null;
        }

        return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
    }

    /**
     * Returns an array of {@@code AnnotatedType} objects that represent the use
     * of types to specify superinterfaces of the entity represented by this
     * {@@code Class} object. (The <em>use</em> of type Foo to specify a
     * superinterface in '... implements Foo' is distinct from the
     * <em>declaration</em> of type Foo.)
     *
     * <p> If this {@@code Class} object represents a class, the return value is
     * an array containing objects representing the uses of interface types to
     * specify interfaces implemented by the class. The order of the objects in
     * the array corresponds to the order of the interface types used in the
     * 'implements' clause of the declaration of this {@@code Class} object.
     *
     * <p> If this {@@code Class} object represents an interface, the return
     * value is an array containing objects representing the uses of interface
     * types to specify interfaces directly extended by the interface. The
     * order of the objects in the array corresponds to the order of the
     * interface types used in the 'extends' clause of the declaration of this
     * {@@code Class} object.
     *
     * <p> If this {@@code Class} object represents a class or interface whose
     * declaration does not explicitly indicate any annotated superinterfaces,
     * the return value is an array of length 0.
     *
     * <p> If this {@@code Class} object represents either the {@@code Object}
     * class, an array type, a primitive type, or void, the return value is an
     * array of length 0.
     *
     * @@return an array representing the superinterfaces
     * @@since 1.8
     */
    public AnnotatedType[] getAnnotatedInterfaces() {
         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
    }
}
@


1.23
log
@Integrated OpenJDK 8u45.
@
text
@a72 2
import cli.System.Runtime.Serialization.IObjectReference;
import cli.System.Runtime.Serialization.SerializationException;
a75 57
@@cli.System.SerializableAttribute.Annotation
final class ClassSerializationProxy implements IObjectReference
{
    private cli.System.Type type;
    private String sig;

    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public Object GetRealObject(StreamingContext context)
    {
        if (sig != null)
        {
            if (sig.length() == 1)
            {
                switch (sig.charAt(0))
                {
                    case 'B':
                        return Byte.TYPE;
                    case 'C':
                        return Character.TYPE;
                    case 'D':
                        return Double.TYPE;
                    case 'F':
                        return Float.TYPE;
                    case 'I':
                        return Integer.TYPE;
                    case 'J':
                        return Long.TYPE;
                    case 'S':
                        return Short.TYPE;
                    case 'Z':
                        return Boolean.TYPE;
                    case 'V':
                        return Void.TYPE;
                }
            }
            String className;
            if (sig.charAt(0) == 'L')
            {
                className = sig.substring(1, sig.length() - 1);
            }
            else
            {
                className = sig;
            }
            try
            {
                return Class.forName(className, false, Thread.currentThread().getContextClassLoader());
            }
            catch (ClassNotFoundException x)
            {
                ikvm.runtime.Util.throwException(new SerializationException(x.getMessage(), x));
            }
        }
        return ikvm.runtime.Util.getClassFromTypeHandle(type.get_TypeHandle());
    }
}

@


1.22
log
@Simplified the anonymous class name mangling.
@
text
@d2 1
a2 1
 * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.
d201 8
a208 7
     * Constructor. Only the Java Virtual Machine creates Class
     * objects.
     */
    private Class()
    {
        // this constructor is not used, but exists for compatibility
        // (otherwise it would look as if this class doesn't have a constructor, which might break some code)
d360 2
a361 2
        return forName0(className, true,
                        ClassLoader.getClassLoader(Reflection.getCallerClass()));
d431 8
a438 4
        if (sun.misc.VM.isSystemDomainLoader(loader)) {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                ClassLoader ccl = ClassLoader.getClassLoader(Reflection.getCallerClass());
d445 1
a445 1
        return forName0(name, initialize, loader);
d448 1
a448 1
    /** Called after security checks have been made. */
d450 2
a451 1
                                            ClassLoader loader)
d2778 1
d2781 1
d2784 8
a2791 1
            methods = new Method[20];
d2793 5
d2805 3
d2841 4
a2844 1
        void addAllNonStatic(Method[] methods) {
d2860 8
a2867 1
        void removeByNameAndSignature(Method toRemove) {
d2870 2
a2871 6
                if (m != null &&
                    m.getReturnType() == toRemove.getReturnType() &&
                    m.getName() == toRemove.getName() &&
                    arrayContentsEq(m.getParameterTypes(),
                                    toRemove.getParameterTypes())) {
                    methods[i] = null;
d2876 13
d2906 32
d2941 7
d2975 2
a2976 3
        Class<?>[] interfaces = getInterfaces();
        for (int i = 0; i < interfaces.length; i++) {
            inheritedMethods.addAllNonStatic(interfaces[i].privateGetPublicMethods());
d2987 4
a2990 2
                    if (m != null && !Modifier.isAbstract(m.getModifiers())) {
                        inheritedMethods.removeByNameAndSignature(m);
d3003 1
a3003 1
            inheritedMethods.removeByNameAndSignature(m);
d3006 1
d3081 5
d3087 9
a3095 1
    private Method getMethod0(String name, Class<?>[] parameterTypes, boolean includeStaticMethods) {
d3103 8
d3132 1
a3132 1
                return res;
@


1.21
log
@Replaced Unsafe cas operations in Class with Interlocked.CompareExchange().
@
text
@d738 1
a738 1
    /*private*/ transient String name;
@


1.20
log
@First part of OpenJDK 8 integration.
@
text
@d2499 2
a2500 26
        // initialize Unsafe machinery here, since we need to call Class.class instance method
        // and have to avoid calling it in the static initializer of the Class class...
        private static final Unsafe unsafe = Unsafe.getUnsafe();
        // offset of Class.reflectionData instance field
        private static final long reflectionDataOffset;
        // offset of Class.annotationType instance field
        private static final long annotationTypeOffset;
        // offset of Class.annotationData instance field
        private static final long annotationDataOffset;

        static {
            Field[] fields = Class.class.getDeclaredFields0(false); // bypass caches
            reflectionDataOffset = objectFieldOffset(fields, "reflectionData");
            annotationTypeOffset = objectFieldOffset(fields, "annotationType");
            annotationDataOffset = objectFieldOffset(fields, "annotationData");
        }

        private static long objectFieldOffset(Field[] fields, String fieldName) {
            Field field = searchFields(fields, fieldName);
            if (field == null) {
                throw new Error("No " + fieldName + " field found in java.lang.Class");
            }
            return unsafe.objectFieldOffset(field);
        }

        static <T> boolean casReflectionData(Class<?> clazz,
d2502 1
a2502 3
                                             SoftReference<ReflectionData<T>> newData) {
            return unsafe.compareAndSwapObject(clazz, reflectionDataOffset, oldData, newData);
        }
d2504 2
a2505 1
        static <T> boolean casAnnotationType(Class<?> clazz,
d2507 1
a2507 3
                                             AnnotationType newType) {
            return unsafe.compareAndSwapObject(clazz, annotationTypeOffset, oldType, newType);
        }
d2509 2
a2510 1
        static <T> boolean casAnnotationData(Class<?> clazz,
d2512 1
a2512 3
                                             AnnotationData newData) {
            return unsafe.compareAndSwapObject(clazz, annotationDataOffset, oldData, newData);
        }
@


1.19
log
@Added Unsafe.defineAnonymousClass().
@
text
@d2 1
a2 1
 * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.
d28 1
d31 1
d34 1
a36 1
import java.lang.reflect.GenericDeclaration;
d41 1
d51 1
a51 1
import java.util.Iterator;
a52 2
import java.util.LinkedList;
import java.util.LinkedHashSet;
d56 1
a57 1
import sun.misc.VM;
a61 1
import sun.reflect.SignatureIterator;
d155 1
a155 1
 * <p> <blockquote><pre>
d167 1
a167 1
 * <p> <blockquote>
d181 4
a184 5
public final
    class Class<T> implements java.io.Serializable,
                              java.lang.reflect.GenericDeclaration,
                              java.lang.reflect.Type,
                              java.lang.reflect.AnnotatedElement {
d255 69
d410 2
a411 1
     * @@param initialize whether the class must be initialized
d430 1
a430 1
        if (loader == null) {
d434 1
a434 1
                if (ccl != null) {
d464 18
a481 30
     * @@return     a newly allocated instance of the class represented by this
     *             object.
     * @@exception  IllegalAccessException  if the class or its nullary
     *               constructor is not accessible.
     * @@exception  InstantiationException
     *               if this {@@code Class} represents an abstract class,
     *               an interface, an array class, a primitive type, or void;
     *               or if the class has no nullary constructor;
     *               or if the instantiation fails for some other reason.
     * @@exception  ExceptionInInitializerError if the initialization
     *               provoked by this method fails.
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
     *
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)} denies
     *             creation of new instances of this class
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
     *
d517 2
a518 1
                throw new InstantiationException(getName());
d672 1
d798 1
d800 3
a802 2
        if (getGenericSignature() != null)
            return (TypeVariable<Class<T>>[])getGenericInfo().getTypeParameters();
d852 2
a853 8
        if (getGenericSignature() != null) {
            // Historical irregularity:
            // Generic signature marks interfaces with superclass = Object
            // but this API returns null for interfaces
            if (isInterface())
                return null;
            return getGenericInfo().getSuperclass();
        } else
d855 10
d925 4
d931 17
a947 1
    public native Class<?>[] getInterfaces();
d999 2
a1000 4
        if (getGenericSignature() != null)
            return getGenericInfo().getSuperInterfaces();
        else
            return getInterfaces();
d1077 21
d1101 1
a1101 1
    public Method getEnclosingMethod() {
a1123 5
            // be very careful not to change the stack depth of this
            // checkMemberAccess call for security reasons
            // see java.lang.SecurityManager.checkMemberAccess
            //
            // Note that we need to do this on the enclosing class
d1191 1
a1191 1
                throw new InternalError("Invalid type in enclosing method information");
d1231 20
d1254 1
a1254 1
    public Constructor<?> getEnclosingConstructor() {
a1275 5
            // be very careful not to change the stack depth of this
            // checkMemberAccess call for security reasons
            // see java.lang.SecurityManager.checkMemberAccess
            //
            // Note that we need to do this on the enclosing class
d1312 6
d1320 11
a1330 1
    public native Class<?> getDeclaringClass();
d1338 6
d1347 1
a1347 1
    public Class<?> getEnclosingClass() {
d1426 26
d1537 1
a1537 1
            throw new InternalError("Malformed class name");
d1564 8
a1571 19
     * members of this class
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
     *
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)} method
     *             denies access to the classes within this class
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
a1576 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d1587 1
a1587 1
                public Class[] run() {
d1599 1
a1599 1
                    return list.toArray(new Class[0]);
d1608 1
a1608 14
     * this {@@code Class} object.  The elements in the array returned are
     * not sorted and are not in any particular order.  This method returns an
     * array of length 0 if the class or interface has no accessible public
     * fields, or if it represents an array class, a primitive type, or void.
     *
     * <p> Specifically, if this {@@code Class} object represents a class,
     * this method returns the public fields of this class and of all its
     * superclasses.  If this {@@code Class} object represents an
     * interface, this method returns the fields of this interface and of all
     * its superinterfaces.
     *
     * <p> The implicit length field for array class is not reflected by this
     * method. User code should use the methods of class {@@code Array} to
     * manipulate arrays.
d1610 3
a1612 1
     * <p> See <em>The Java Language Specification</em>, sections 8.2 and 8.3.
d1614 2
a1615 5
     * @@return the array of {@@code Field} objects representing the
     * public fields
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
d1617 3
a1619 1
     *             <ul>
d1621 2
a1622 10
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)} denies
     *             access to the fields within this class
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
d1624 12
a1635 1
     *             </ul>
d1638 2
a1642 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d1649 32
a1680 15
     * Returns an array containing {@@code Method} objects reflecting all
     * the public <em>member</em> methods of the class or interface represented
     * by this {@@code Class} object, including those declared by the class
     * or interface and those inherited from superclasses and
     * superinterfaces.  Array classes return all the (public) member methods
     * inherited from the {@@code Object} class.  The elements in the array
     * returned are not sorted and are not in any particular order.  This
     * method returns an array of length 0 if this {@@code Class} object
     * represents a class or interface that has no public member methods, or if
     * this {@@code Class} object represents a primitive type or void.
     *
     * <p> The class initialization method {@@code <clinit>} is not
     * included in the returned array. If the class declares multiple public
     * member methods with the same parameter types, they are all included in
     * the returned array.
d1682 2
a1683 1
     * <p> See <em>The Java Language Specification</em>, sections 8.2 and 8.4.
d1686 8
a1693 19
     * public methods of this class
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
     *
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)} denies
     *             access to the methods within this class
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
d1695 2
a1700 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d1724 8
a1731 19
     *  public constructors of this class
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
     *
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)} denies
     *             access to the constructors within this class
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
a1736 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d1743 4
a1746 4
     * Returns a {@@code Field} object that reflects the specified public
     * member field of the class or interface represented by this
     * {@@code Class} object. The {@@code name} parameter is a
     * {@@code String} specifying the simple name of the desired field.
d1749 2
a1750 1
     * follows.  Let C be the class represented by this object:
d1763 2
a1764 1
     * <p> See <em>The Java Language Specification</em>, sections 8.2 and 8.3.
d1767 12
a1778 23
     * @@return  the {@@code Field} object of this class specified by
     * {@@code name}
     * @@exception NoSuchFieldException if a field with the specified name is
     *              not found.
     * @@exception NullPointerException if {@@code name} is {@@code null}
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
     *
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)} denies
     *             access to the field
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
d1781 2
a1786 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d1806 1
a1806 1
     * <p> If the {@@code name} is "{@@code <init>};"or "{@@code <clinit>}" a
d1809 1
a1809 1
     * class represented by this object:
d1811 10
a1820 6
     * <LI> C is searched for any <I>matching methods</I>. If no matching
     *      method is found, the algorithm of step 1 is invoked recursively on
     *      the superclass of C.</LI>
     * <LI> If no method was found in step 1 above, the superinterfaces of C
     *      are searched for a matching method. If any such method is found, it
     *      is reflected.</LI>
d1823 6
a1828 6
     * To find a matching method in a class C:&nbsp; If C declares exactly one
     * public method with the specified name and exactly the same formal
     * parameter types, that is the method reflected. If more than one such
     * method is found in C, and one of these methods has a return type that is
     * more specific than any of the others, that method is reflected;
     * otherwise one of the methods is chosen arbitrarily.
d1841 6
a1846 1
     * <p> See <em>The Java Language Specification</em>, sections 8.2 and 8.4.
d1851 11
a1861 22
     * {@@code name} and {@@code parameterTypes}
     * @@exception NoSuchMethodException if a matching method is not found
     *            or if the name is "&lt;init&gt;"or "&lt;clinit&gt;".
     * @@exception NullPointerException if {@@code name} is {@@code null}
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
     *
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)} denies
     *             access to the method
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
d1863 2
a1869 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d1871 1
a1871 1
        Method method = getMethod0(name, parameterTypes);
d1896 9
a1904 20
     * matches the specified {@@code parameterTypes}
     * @@exception NoSuchMethodException if a matching method is not found.
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
     *
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)} denies
     *             access to the constructor
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
a1910 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d1927 4
a1930 4
     * declared members of this class
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
d1932 1
a1932 1
     *             <ul>
d1934 12
a1945 10
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)} denies
     *             access to the declared classes within this class
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
d1947 1
a1947 1
     *             </ul>
a1952 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
a1962 4
     * The elements in the array returned are not sorted and are not in any
     * particular order.  This method returns an array of length 0 if the class
     * or interface declares no fields, or if this {@@code Class} object
     * represents a primitive type, an array class, or void.
d1964 2
a1965 1
     * <p> See <em>The Java Language Specification</em>, sections 8.2 and 8.3.
d1967 2
a1968 5
     * @@return    the array of {@@code Field} objects representing all the
     * declared fields of this class
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
d1970 2
a1971 1
     *             <ul>
d1973 20
a1992 10
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)} denies
     *             access to the declared fields within this class
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
d1994 1
a1994 1
     *             </ul>
d1997 2
a2001 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
a2007 14
     * Returns an array of {@@code Method} objects reflecting all the
     * methods declared by the class or interface represented by this
     * {@@code Class} object. This includes public, protected, default
     * (package) access, and private methods, but excludes inherited methods.
     * The elements in the array returned are not sorted and are not in any
     * particular order.  This method returns an array of length 0 if the class
     * or interface declares no methods, or if this {@@code Class} object
     * represents a primitive type, an array class, or void.  The class
     * initialization method {@@code <clinit>} is not included in the
     * returned array. If the class declares multiple public member methods
     * with the same parameter types, they are all included in the returned
     * array.
     *
     * <p> See <em>The Java Language Specification</em>, section 8.2.
d2009 43
a2051 5
     * @@return    the array of {@@code Method} objects representing all the
     * declared methods of this class
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
d2053 1
a2053 14
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)} denies
     *             access to the declared methods within this class
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
d2055 2
a2060 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d2079 20
a2098 5
     * @@return    the array of {@@code Constructor} objects representing all the
     * declared constructors of this class
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
d2100 1
a2100 14
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)} denies
     *             access to the declared constructors within this class
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
a2105 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d2114 5
a2118 3
     * object. The {@@code name} parameter is a {@@code String} that
     * specifies the simple name of the desired field.  Note that this method
     * will not reflect the {@@code length} field of an array class.
d2121 23
a2143 8
     * @@return the {@@code Field} object for the specified field in this
     * class
     * @@exception NoSuchFieldException if a field with the specified name is
     *              not found.
     * @@exception NullPointerException if {@@code name} is {@@code null}
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
d2145 1
a2145 14
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)} denies
     *             access to the declared field
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
d2148 2
a2153 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d2177 3
d2182 22
a2203 7
     * @@return    the {@@code Method} object for the method of this class
     * matching the specified name and parameters
     * @@exception NoSuchMethodException if a matching method is not found.
     * @@exception NullPointerException if {@@code name} is {@@code null}
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
d2205 1
a2205 14
     *             <ul>
     *
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)} denies
     *             access to the declared method
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
d2207 2
a2213 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
d2235 21
a2255 8
     * @@return    The {@@code Constructor} object for the constructor with the
     * specified parameter list
     * @@exception NoSuchMethodException if a matching method is not found.
     * @@exception  SecurityException
     *             If a security manager, <i>s</i>, is present and any of the
     *             following conditions is met:
     *
     *             <ul>
d2257 1
a2257 12
     *             <li> invocation of
     *             {@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)} denies
     *             access to the declared constructor
     *
     *             <li> the caller's class loader is not the same as or an
     *             ancestor of the class loader for the current class and
     *             invocation of {@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()} denies access to the package
     *             of this class
     *
     *             </ul>
a2263 3
        // be very careful not to change the stack depth of this
        // checkMemberAccess call for security reasons
        // see java.lang.SecurityManager.checkMemberAccess
a2407 8

    /**
     * Set the ProtectionDomain for this class. Called by
     * ClassLoader.defineClass.
     */
    native void setProtectionDomain0(java.security.ProtectionDomain pd);


d2412 1
a2412 10
    static native Class getPrimitiveClass(String name);

    private static boolean isCheckMemberAccessOverridden(SecurityManager smgr) {
        if (smgr.getClass() == SecurityManager.class) return false;

        Class<?>[] paramTypes = new Class<?>[] {Class.class, int.class};
        return smgr.getClass().getMethod0("checkMemberAccess", paramTypes).
                getDeclaringClass() != SecurityManager.class;
    }

d2426 5
d2433 3
a2435 6
            if (!isCheckMemberAccessOverridden(s)) {
                // Inlined SecurityManager.checkMemberAccess
                if (which != Member.PUBLIC) {
                    if (ccl != cl) {
                        s.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
                    }
a2436 4
            } else {
                // Don't refactor; otherwise break the stack depth for
                // checkMemberAccess of subclasses of SecurityManager as specified.
                s.checkMemberAccess(this, which);
d2451 1
d2496 48
d2549 23
a2571 9
    private volatile transient SoftReference<Field[]> declaredFields;
    private volatile transient SoftReference<Field[]> publicFields;
    private volatile transient SoftReference<Method[]> declaredMethods;
    private volatile transient SoftReference<Method[]> publicMethods;
    private volatile transient SoftReference<Constructor<T>[]> declaredConstructors;
    private volatile transient SoftReference<Constructor<T>[]> publicConstructors;
    // Intermediate results for getFields and getMethods
    private volatile transient SoftReference<Field[]> declaredPublicFields;
    private volatile transient SoftReference<Method[]> declaredPublicMethods;
d2577 34
a2610 19
    // Value of classRedefinedCount when we last cleared the cached values
    // that are sensitive to class redefinition.
    private volatile transient int lastRedefinedCount;

    // Clears cached values that might possibly have been obsoleted by
    // a class redefinition.
    private void clearCachesOnClassRedefinition() {
        if (lastRedefinedCount != classRedefinedCount) {
            declaredFields = publicFields = declaredPublicFields = null;
            declaredMethods = publicMethods = declaredPublicMethods = null;
            declaredConstructors = publicConstructors = null;
            annotations = declaredAnnotations = null;

            // Use of "volatile" (and synchronization by caller in the case
            // of annotations) ensures that no thread sees the update to
            // lastRedefinedCount before seeing the caches cleared.
            // We do not guard against brief windows during which multiple
            // threads might redundantly work to fill an empty cache.
            lastRedefinedCount = classRedefinedCount;
d2615 1
a2615 1
    private native String getGenericSignature();
d2618 1
a2618 1
    private transient ClassRepository genericInfo;
d2626 2
a2627 1
    // accessor for generic info repository
d2629 1
a2629 1
        // lazily initialize repository if necessary
d2631 7
a2637 3
            // create and cache generic info repository
            genericInfo = ClassRepository.make(getGenericSignature(),
                                               getFactory());
d2639 1
a2639 1
        return genericInfo; //return cached repository
d2644 7
d2663 4
a2666 12
        Field[] res = null;
        if (useCaches) {
            clearCachesOnClassRedefinition();
            if (publicOnly) {
                if (declaredPublicFields != null) {
                    res = declaredPublicFields.get();
                }
            } else {
                if (declaredFields != null) {
                    res = declaredFields.get();
                }
            }
d2671 1
a2671 1
        if (useCaches) {
d2673 1
a2673 1
                declaredPublicFields = new SoftReference<>(res);
d2675 1
a2675 1
                declaredFields = new SoftReference<>(res);
d2686 4
a2689 6
        Field[] res = null;
        if (useCaches) {
            clearCachesOnClassRedefinition();
            if (publicFields != null) {
                res = publicFields.get();
            }
d2722 2
a2723 2
        if (useCaches) {
            publicFields = new SoftReference<>(res);
d2746 4
a2749 12
        Constructor<T>[] res = null;
        if (useCaches) {
            clearCachesOnClassRedefinition();
            if (publicOnly) {
                if (publicConstructors != null) {
                    res = publicConstructors.get();
                }
            } else {
                if (declaredConstructors != null) {
                    res = declaredConstructors.get();
                }
            }
d2754 3
a2756 1
            res = new Constructor[0];
d2760 1
a2760 1
        if (useCaches) {
d2762 1
a2762 1
                publicConstructors = new SoftReference<>(res);
d2764 1
a2764 1
                declaredConstructors = new SoftReference<>(res);
d2781 4
a2784 12
        Method[] res = null;
        if (useCaches) {
            clearCachesOnClassRedefinition();
            if (publicOnly) {
                if (declaredPublicMethods != null) {
                    res = declaredPublicMethods.get();
                }
            } else {
                if (declaredMethods != null) {
                    res = declaredMethods.get();
                }
            }
d2789 1
a2789 1
        if (useCaches) {
d2791 1
a2791 1
                declaredPublicMethods = new SoftReference<>(res);
d2793 1
a2793 1
                declaredMethods = new SoftReference<>(res);
d2846 8
d2903 4
a2906 6
        Method[] res = null;
        if (useCaches) {
            clearCachesOnClassRedefinition();
            if (publicMethods != null) {
                res = publicMethods.get();
            }
d2924 1
a2924 1
            inheritedMethods.addAll(interfaces[i].privateGetPublicMethods());
d2954 2
a2955 2
        if (useCaches) {
            publicMethods = new SoftReference<>(res);
d2965 1
a2965 1
    private Field searchFields(Field[] fields, String name) {
d2983 1
a2983 1
        Field res = null;
d3027 1
a3027 1
    private Method getMethod0(String name, Class<?>[] parameterTypes) {
d3035 1
a3035 1
        Method res = null;
d3040 2
a3041 1
            return res;
d3047 1
a3047 1
                if ((res = c.getMethod0(name, parameterTypes)) != null) {
d3054 2
a3055 3
        for (int i = 0; i < interfaces.length; i++) {
            Class<?> c = interfaces[i];
            if ((res = c.getMethod0(name, parameterTypes)) != null) {
a3056 2
            }
        }
d3260 1
a3260 1
                    if (!VM.isBooted()) {
d3264 1
d3310 3
a3312 1
                enumConstants = (T[])values.invoke(null);
d3316 2
a3317 3
            catch (InvocationTargetException ex) { return null; }
            catch (NoSuchMethodException ex) { return null; }
            catch (IllegalAccessException ex) { return null; }
d3326 1
a3326 1
     *     public static <T extends Enum<T>> T valueOf(Class<T>, String)
d3357 1
d3370 1
a3370 1
     * represented by the specified class object.  Checks that that the cast
d3381 2
d3390 1
d3402 1
d3404 1
a3404 2
        if (annotationClass == null)
            throw new NullPointerException();
d3406 1
a3406 2
        initAnnotationsIfNecessary();
        return (A) annotations.get(annotationClass);
d3410 1
d3414 4
a3417 4
    public boolean isAnnotationPresent(
        Class<? extends Annotation> annotationClass) {
        if (annotationClass == null)
            throw new NullPointerException();
d3419 12
a3430 1
        return getAnnotation(annotationClass) != null;
a3432 1

d3437 25
a3461 3
        initAnnotationsIfNecessary();
        Collection<Annotation> values = annotations.values();
        return values.toArray(new Annotation[values.size()]);
d3468 18
a3485 3
        initAnnotationsIfNecessary();
        Collection<Annotation> values = declaredAnnotations.values();
        return values.toArray(new Annotation[values.size()]);
d3489 20
a3508 2
    private transient Map<Class<? extends Annotation>, Annotation> annotations;
    private transient Map<Class<? extends Annotation>, Annotation> declaredAnnotations;
d3510 3
a3512 5
    private synchronized void initAnnotationsIfNecessary() {
        clearCachesOnClassRedefinition();
        if (annotations != null)
            return;
        declaredAnnotations = getDeclaredAnnotationsImpl();
d3514 5
a3518 6
        if (superClass == null) {
            annotations = declaredAnnotations;
        } else {
            annotations = new HashMap<>();
            superClass.initAnnotationsIfNecessary();
            for (Map.Entry<Class<? extends Annotation>, Annotation> e : superClass.annotations.entrySet()) {
d3520 8
a3527 1
                if (AnnotationType.getInstance(annotationClass).isInherited())
d3529 1
d3531 6
d3539 1
d3544 2
a3545 1
    private AnnotationType annotationType;
d3547 2
a3548 2
    void setAnnotationType(AnnotationType type) {
        annotationType = type;
d3555 4
d3563 66
@


1.18
log
@Fixed initialization order issue. Don't abuse System.out to check if the intialization is complete.
@
text
@d679 1
a679 1
    private transient String name;
@


1.17
log
@Switched from @@HasCallerID to @@CallerSensitive and merged CallerSenstive related 7u40 changes.
@
text
@d56 1
d3086 1
a3086 4
                    // these user-settable properties installed.) We assume that
                    // if System.out is non-null then the System class has been
                    // fully initialized and that the bulk of the startup code
                    // has been run.
d3088 1
a3088 2
                    if (System.out == null) {
                        // java.lang.System not yet fully initialized
@


1.16
log
@Integrated OpenJDK 7u4. Not all forked files have been merged yet, just the ones necessary to get things building.
@
text
@d56 1
d69 3
a71 1
import sun.reflect.annotation.AnnotationType;
d287 1
a287 1
    @@ikvm.internal.HasCallerID
d290 2
a291 1
        return forName0(className, true, ClassLoader.getCallerClassLoader());
d355 1
a355 1
    @@ikvm.internal.HasCallerID
d363 1
a363 1
                ClassLoader ccl = ClassLoader.getCallerClassLoader();
d425 1
a425 1
    @@ikvm.internal.HasCallerID
d430 1
a430 1
            checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
a431 2
        return newInstance0(ikvm.internal.CallerID.getCallerID());
    }
a432 3
    private T newInstance0(ikvm.internal.CallerID callerID)
        throws InstantiationException, IllegalAccessException
    {
d466 1
a466 1
            Class<?> caller = callerID.getCallerClass();
d707 1
a707 1
    @@ikvm.internal.HasCallerID
d714 1
a714 4
            ClassLoader ccl = ClassLoader.getCallerClassLoader();
            if (ccl != null && ccl != cl && !cl.isAncestor(ccl)) {
                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
            }
d995 1
d1017 9
d1032 1
a1032 1
            for(Method m: enclosingInfo.getEnclosingClass().getDeclaredMethods()) {
d1133 1
d1154 9
d1167 1
a1167 1
            for(Constructor<?> c: enclosingInfo.getEnclosingClass().getDeclaredConstructors()) {
d1209 1
d1223 1
d1227 1
a1227 1
            return getDeclaringClass();
d1234 1
a1234 1
                return enclosingClass;
d1236 5
d1423 1
a1423 1
    @@ikvm.internal.HasCallerID
d1428 1
a1428 1
        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
d1499 1
a1499 1
    @@ikvm.internal.HasCallerID
d1504 1
a1504 1
        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
d1551 1
a1551 1
    @@ikvm.internal.HasCallerID
d1556 1
a1556 1
        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
d1601 1
a1601 1
    @@ikvm.internal.HasCallerID
d1606 1
a1606 1
        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
d1660 1
a1660 1
    @@ikvm.internal.HasCallerID
d1666 1
a1666 1
        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
d1746 1
a1746 1
    @@ikvm.internal.HasCallerID
d1752 1
a1752 1
        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
d1801 1
a1801 1
    @@ikvm.internal.HasCallerID
d1807 1
a1807 1
        checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
d1845 1
a1845 1
    @@ikvm.internal.HasCallerID
d1850 1
a1850 1
        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
d1890 1
a1890 1
    @@ikvm.internal.HasCallerID
d1895 1
a1895 1
        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
d1939 1
a1939 1
    @@ikvm.internal.HasCallerID
d1944 1
a1944 1
        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
d1985 1
a1985 1
    @@ikvm.internal.HasCallerID
d1990 1
a1990 1
        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
d2029 1
a2029 1
    @@ikvm.internal.HasCallerID
d2035 1
a2035 1
        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
d2085 1
a2085 1
    @@ikvm.internal.HasCallerID
d2091 1
a2091 1
        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
d2136 1
a2136 1
    @@ikvm.internal.HasCallerID
d2142 1
a2142 1
        checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
d2300 8
d2313 1
a2313 3
     * Be very careful not to change the stack depth of this checkMemberAccess
     * call for security reasons.
     * See java.lang.SecurityManager.checkMemberAccess.
d2318 2
a2319 2
    private void checkMemberAccess(int which, ClassLoader ccl) {
        SecurityManager s = System.getSecurityManager();
d2321 28
a2348 4
            s.checkMemberAccess(this, which);
            ClassLoader cl = getClassLoader0();
            if ((ccl != null) && (ccl != cl) &&
                  ((cl == null) || !cl.isAncestor(ccl))) {
d2352 5
a2356 1
                    s.checkPackageAccess(name.substring(0, i));
d2359 4
@


1.15
log
@Updated to OpenJDK 7:
- java.lang.Class
- java.security.AccessController
- sun.reflect.ReflectionFactory
@
text
@d3240 5
@


1.14
log
@Integrated OpenJDK 6 b21.
@
text
@d2 1
a2 1
 * Copyright (c) 1994, 2006, Oracle and/or its affiliates. All rights reserved.
d159 2
a160 2
 * type (or for void) using a class literal
 * (JLS Section <A HREF="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530">15.8.2</A>).
d370 1
a370 1
    private static native Class forName0(String name, boolean initialize,
d445 1
a445 1
                Class[] empty = {};
d451 3
a453 3
                java.security.AccessController.doPrivileged
                    (new java.security.PrivilegedAction() {
                            public Object run() {
d467 1
a467 1
            Class caller = callerID.getCallerClass();
d483 1
a483 1
    private volatile transient Class       newInstanceCallerCache;
d627 2
a628 1
     * by the Java Language Specification, Second Edition.
d672 1
d674 1
a674 1
            name = getName0();
d736 1
a736 1
     * @@throws GenericSignatureFormatError if the generic
d738 2
a739 2
     *     the format specified in the Java Virtual Machine Specification,
     *     3rd edition
d746 1
a746 1
            return (TypeVariable<Class<T>>[])new TypeVariable[0];
d782 3
a784 3
     * @@throws GenericSignatureFormatError if the generic
     *     class signature does not conform to the format specified in the
     *     Java Virtual Machine Specification, 3rd edition
d787 1
a787 1
     * @@throws MalformedParameterizedTypeException if the
d904 1
a904 1
     * @@throws GenericSignatureFormatError
d906 2
a907 1
     *     specified in the Java Virtual Machine Specification, 3rd edition
d910 3
a912 3
     * @@throws MalformedParameterizedTypeException if any of the
     *     generic superinterfaces refer to a parameterized type that cannot
     *     be instantiated  for any reason
d1010 1
a1010 1
            Class      returnType       = toClass(typeInfo.getReturnType());
d1105 1
a1105 1
    private static Class toClass(Type o) {
d1110 1
a1110 1
        return (Class)o;
d1151 1
a1151 1
            for(Constructor c: enclosingInfo.getEnclosingClass().getDeclaredConstructors()) {
d1413 5
a1417 5
        Class[] result = (Class[]) java.security.AccessController.doPrivileged
            (new java.security.PrivilegedAction() {
                public Object run() {
                    java.util.List<Class> list = new java.util.ArrayList();
                    Class currentClass = Class.this;
d1419 1
a1419 1
                        Class[] members = currentClass.getDeclaredClasses();
d1427 1
a1427 2
                    Class[] empty = {};
                    return list.toArray(empty);
a1429 2

        return result;
d2314 1
a2314 1
            Class c = this;
d2336 6
a2341 6
    private volatile transient SoftReference declaredFields;
    private volatile transient SoftReference publicFields;
    private volatile transient SoftReference declaredMethods;
    private volatile transient SoftReference publicMethods;
    private volatile transient SoftReference declaredConstructors;
    private volatile transient SoftReference publicConstructors;
d2343 2
a2344 2
    private volatile transient SoftReference declaredPublicFields;
    private volatile transient SoftReference declaredPublicMethods;
d2396 1
a2396 1
    private native Map<Class, Annotation> getDeclaredAnnotationsImpl();
d2414 1
a2414 1
                    res = (Field[]) declaredPublicFields.get();
d2418 1
a2418 1
                    res = (Field[]) declaredFields.get();
d2427 1
a2427 1
                declaredPublicFields = new SoftReference(res);
d2429 1
a2429 1
                declaredFields = new SoftReference(res);
d2438 1
a2438 1
    private Field[] privateGetPublicFields(Set traversedInterfaces) {
d2444 1
a2444 1
                res = (Field[]) publicFields.get();
d2451 1
a2451 1
        List fields = new ArrayList();
d2453 1
a2453 1
            traversedInterfaces = new HashSet();
d2461 1
a2461 3
        Class[] interfaces = getInterfaces();
        for (int i = 0; i < interfaces.length; i++) {
            Class c = interfaces[i];
d2470 1
a2470 1
            Class c = getSuperclass();
d2479 1
a2479 1
            publicFields = new SoftReference(res);
d2484 1
a2484 1
    private static void addAll(Collection c, Field[] o) {
d2500 1
a2500 1
    private Constructor[] privateGetDeclaredConstructors(boolean publicOnly) {
d2502 1
a2502 1
        Constructor[] res = null;
d2507 1
a2507 1
                    res = (Constructor[]) publicConstructors.get();
d2511 1
a2511 1
                    res = (Constructor[]) declaredConstructors.get();
d2524 1
a2524 1
                publicConstructors = new SoftReference(res);
d2526 1
a2526 1
                declaredConstructors = new SoftReference(res);
d2548 1
a2548 1
                    res = (Method[]) declaredPublicMethods.get();
d2552 1
a2552 1
                    res = (Method[]) declaredMethods.get();
d2561 1
a2561 1
                declaredPublicMethods = new SoftReference(res);
d2563 1
a2563 1
                declaredMethods = new SoftReference(res);
d2669 1
a2669 1
                res = (Method[]) publicMethods.get();
d2686 1
a2686 1
        Class[] interfaces = getInterfaces();
d2691 1
a2691 1
            Class c = getSuperclass();
d2719 1
a2719 1
            publicMethods = new SoftReference(res);
d2753 1
a2753 1
        Class[] interfaces = getInterfaces();
d2755 1
a2755 1
            Class c = interfaces[i];
d2762 1
a2762 1
            Class c = getSuperclass();
d2774 1
a2774 1
                                        Class[] parameterTypes)
d2791 1
a2791 1
    private Method getMethod0(String name, Class[] parameterTypes) {
d2808 1
a2808 1
            Class c = getSuperclass();
d2816 1
a2816 1
        Class[] interfaces = getInterfaces();
d2818 1
a2818 1
            Class c = interfaces[i];
d2827 1
a2827 1
    private Constructor<T> getConstructor0(Class[] parameterTypes,
d2830 2
a2831 2
        Constructor[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
        for (int i = 0; i < constructors.length; i++) {
d2833 2
a2834 2
                                constructors[i].getParameterTypes())) {
                return getReflectionFactory().copyConstructor(constructors[i]);
d2884 2
a2885 2
    private static Constructor[] copyConstructors(Constructor[] arg) {
        Constructor[] out = new Constructor[arg.length];
d2887 2
a2888 2
        for (int i = 0; i < arg.length; i++) {
            out[i] = fact.copyConstructor(arg[i]);
d2895 2
a2896 2
    private native Constructor[] getDeclaredConstructors0(boolean publicOnly);
    private native Class[]   getDeclaredClasses0();
d2898 1
a2898 1
    private static String        argumentTypesToString(Class[] argTypes) {
d2906 1
a2906 1
                Class c = argTypes[i];
d2973 6
a2978 7
        synchronized(loader) {
            // If the classloader has been initialized with
            // the assertion directives, ask it. Otherwise,
            // ask the VM.
            return (loader.classAssertionStatus == null ?
                    desiredAssertionStatus0(this) :
                    loader.desiredAssertionStatus(getName()));
d2980 1
d2984 1
a2984 1
    private static native boolean desiredAssertionStatus0(Class clazz);
d3005 1
a3005 1
            reflectionFactory =  (ReflectionFactory)
d3018 2
a3019 2
        AccessController.doPrivileged(new PrivilegedAction() {
                public Object run() {
d3064 2
a3065 2
     * identical to getEnumConstantsShared except that
     * the result is uncloned, cached, and shared by all callers.
d3072 3
a3074 3
                java.security.AccessController.doPrivileged
                    (new java.security.PrivilegedAction() {
                            public Object run() {
d3104 1
a3104 1
            Map<String, T> m = new HashMap<String, T>(2 * universe.length);
d3106 1
a3106 1
                m.put(((Enum)constant).name(), constant);
d3206 2
a3207 2
    private transient Map<Class, Annotation> annotations;
    private transient Map<Class, Annotation> declaredAnnotations;
d3218 1
a3218 1
            annotations = new HashMap<Class, Annotation>();
d3220 2
a3221 2
            for (Map.Entry<Class, Annotation> e : superClass.annotations.entrySet()) {
                Class annotationClass = e.getKey();
@


1.13
log
@Prep for .NET 4.0 security model:
- serialization methods must be critical.
@
text
@d2 1
a2 1
 * Copyright 1994-2006 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.12
log
@Implemented .NET serialization support for java.lang.Class objects.
@
text
@d80 1
d218 1
@


1.11
log
@Moved most java.lang.Class changes from map.xml to java source.
@
text
@d69 60
d175 1
d189 5
a193 2
    // for types that support fast class literals, this is used to store the Type that can later (on demand)
    // be resolved to the corresponding TypeWrapper, but for other types this will be null.
d212 13
@


1.10
log
@Changes to make <clinit> trivial.
@
text
@d124 4
d149 8
@


1.9
log
@Moved responsibility for creating java.lang.Class instances for "fast literal" enable types into ClassLiteral<T>, this allows class literals to be really cheap, because non of the underlying reflection is needed, the class will cache the Type and lazily resolve it to its TypeWrapper.
@
text
@d2244 1
a2244 1
    private static boolean useCaches = true;
d2845 7
a2851 2
    private static final ObjectStreamField[] serialPersistentFields =
        new ObjectStreamField[0];
d2925 1
a2925 1
    private static boolean initted = false;
d2928 1
a3097 2
    private static Annotation[] EMPTY_ANNOTATIONS_ARRAY = new Annotation[0];

d3103 2
a3104 1
        return annotations.values().toArray(EMPTY_ANNOTATIONS_ARRAY);
d3112 2
a3113 1
        return declaredAnnotations.values().toArray(EMPTY_ANNOTATIONS_ARRAY);
@


1.8
log
@Removed unnecessary field initialization and registerNative call.
@
text
@d124 4
d132 6
a137 1
    private Class() {}
d139 5
@


1.7
log
@Integrated OpenJDK 6 b10.
@
text
@a123 5
    private static native void registerNatives();
    static {
        registerNatives();
    }

d2243 1
a2243 1
    private volatile transient int classRedefinedCount = 0;
d2247 1
a2247 1
    private volatile transient int lastRedefinedCount = 0;
d2980 1
a2980 1
    private volatile transient T[] enumConstants = null;
d3002 1
a3002 1
    private volatile transient Map<String, T> enumConstantDirectory = null;
@


1.6
log
@Merged OpenJDK 6 b10 whitespace and comment changes.
@
text
@d3023 1
a3023 2
            throw new ClassCastException("Cannot cast " + obj.getClass().getName() 
                                         + " to " + getName());
d3027 4
@


1.5
log
@Converted tabs to spaces.
@
text
@d71 1
a71 1
 * Instances of the class <code>Class</code> represent classes and
d74 1
a74 1
 * belongs to a class that is reflected as a <code>Class</code> object
d76 5
a80 5
 * of dimensions.  The primitive Java types (<code>boolean</code>,
 * <code>byte</code>, <code>char</code>, <code>short</code>,
 * <code>int</code>, <code>long</code>, <code>float</code>, and
 * <code>double</code>), and the keyword <code>void</code> are also
 * represented as <code>Class</code> objects.
d82 1
a82 1
 * <p> <code>Class</code> has no public constructor. Instead <code>Class</code>
d84 1
a84 1
 * are loaded and by calls to the <code>defineClass</code> method in the class
d87 1
a87 1
 * <p> The following example uses a <code>Class</code> object to print the
d96 4
a99 4
 * 
 * <p> It is also possible to get the <code>Class</code> object for a named
 * type (or for void) using a class literal 
 * (JLS Section <A HREF="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530">15.8.2</A>). 
d102 3
a104 3
 * <p> <blockquote><pre>
 *     System.out.println("The name of class Foo is: "+Foo.class.getName());
 * </pre></blockquote>
a111 1
 * @@version 1.209, 05/05/07
d116 2
a117 2
    class Class<T> implements java.io.Serializable, 
                              java.lang.reflect.GenericDeclaration, 
d140 1
a140 1
     * <code>getName</code>.  If this <code>Class</code> object represents a
d142 1
a142 1
     * this <code>Class</code> object represents void this method returns
d154 1
a154 1
     * Returns the <code>Class</code> object associated with the class or
d158 3
a160 3
     * <blockquote><pre>
     *  Class.forName(className, true, currentLoader)
     * </pre></blockquote>
d162 1
a162 1
     * where <code>currentLoader</code> denotes the defining class loader of
d166 2
a167 2
     * runtime <code>Class</code> descriptor for the class named
     * <code>java.lang.Thread</code>:
d169 3
a171 3
     * <blockquote><pre>
     *   Class&nbsp;t&nbsp;= Class.forName("java.lang.Thread")
     * </pre></blockquote>
d173 2
a174 2
     * A call to <tt>forName("X")</tt> causes the class named 
     * <tt>X</tt> to be initialized.
d177 1
a177 1
     * @@return     the <code>Class</code> object for the class with the
d185 1
a185 1
    public static Class<?> forName(String className) 
d192 1
a192 1
     * Returns the <code>Class</code> object associated with the class or
d195 1
a195 1
     * format returned by <code>getName</code>) this method attempts to
d198 1
a198 1
     * <code>loader</code> is null, the class is loaded through the bootstrap
d200 1
a200 1
     * <code>initialize</code> parameter is <code>true</code> and if it has
d203 1
a203 1
     * <p> If <code>name</code> denotes a primitive type or void, an attempt
d205 2
a206 2
     * name is <code>name</code>. Therefore, this method cannot be used to
     * obtain any of the <code>Class</code> objects representing primitive
d209 1
a209 1
     * <p> If <code>name</code> denotes an array class, the component type of
d214 3
a216 3
     * <blockquote><pre>
     *  Class.forName("Foo")
     * </pre></blockquote>
d220 3
a222 3
     * <blockquote><pre>
     *  Class.forName("Foo", true, this.getClass().getClassLoader())
     * </pre></blockquote>
d227 1
a227 1
     * Note that this method does not check whether the requested class 
d230 1
a230 1
     * <p> If the <code>loader</code> is <code>null</code>, and a security
d232 2
a233 2
     * method calls the security manager's <code>checkPermission</code> method
     * with a <code>RuntimePermission("getClassLoader")</code> permission to
d240 1
a240 1
     * 
d247 1
a247 1
     * @@see       java.lang.Class#forName(String) 
d275 2
a276 2
     * Creates a new instance of the class represented by this <tt>Class</tt>
     * object.  The class is instantiated as if by a <code>new</code>
d292 1
a292 1
     * @@exception  IllegalAccessException  if the class or its nullary 
d294 2
a295 2
     * @@exception  InstantiationException 
     *               if this <code>Class</code> represents an abstract class,
d307 3
a309 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
d314 2
a315 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d322 1
a322 1
    public T newInstance() 
d387 7
a393 7
     * Determines if the specified <code>Object</code> is assignment-compatible
     * with the object represented by this <code>Class</code>.  This method is
     * the dynamic equivalent of the Java language <code>instanceof</code>
     * operator. The method returns <code>true</code> if the specified
     * <code>Object</code> argument is non-null and can be cast to the
     * reference type represented by this <code>Class</code> object without
     * raising a <code>ClassCastException.</code> It returns <code>false</code>
d396 6
a401 6
     * <p> Specifically, if this <code>Class</code> object represents a
     * declared class, this method returns <code>true</code> if the specified
     * <code>Object</code> argument is an instance of the represented class (or
     * of any of its subclasses); it returns <code>false</code> otherwise. If
     * this <code>Class</code> object represents an array class, this method
     * returns <code>true</code> if the specified <code>Object</code> argument
d404 6
a409 6
     * <code>false</code> otherwise. If this <code>Class</code> object
     * represents an interface, this method returns <code>true</code> if the
     * class or any superclass of the specified <code>Object</code> argument
     * implements this interface; it returns <code>false</code> otherwise. If
     * this <code>Class</code> object represents a primitive type, this method
     * returns <code>false</code>.
d412 1
a412 1
     * @@return  true if <code>obj</code> is an instance of this class
d421 1
a421 1
     * <code>Class</code> object is either the same as, or is a superclass or
d423 2
a424 2
     * <code>Class</code> parameter. It returns <code>true</code> if so;
     * otherwise it returns <code>false</code>. If this <code>Class</code>
d426 3
a428 3
     * <code>true</code> if the specified <code>Class</code> parameter is
     * exactly this <code>Class</code> object; otherwise it returns
     * <code>false</code>.
d431 2
a432 2
     * specified <code>Class</code> parameter can be converted to the type
     * represented by this <code>Class</code> object via an identity conversion
d435 4
a438 4
     * 
     * @@param cls the <code>Class</code> object to be checked
     * @@return the <code>boolean</code> value indicating whether objects of the
     * type <code>cls</code> can be assigned to objects of this class
d447 1
a447 1
     * Determines if the specified <code>Class</code> object represents an
d450 2
a451 2
     * @@return  <code>true</code> if this object represents an interface;
     *          <code>false</code> otherwise.
d457 1
a457 1
     * Determines if this <code>Class</code> object represents an array class.
d459 2
a460 2
     * @@return  <code>true</code> if this object represents an array class;
     *          <code>false</code> otherwise.
d467 1
a467 1
     * Determines if the specified <code>Class</code> object represents a
d470 1
a470 1
     * <p> There are nine predefined <code>Class</code> objects to represent
d473 3
a475 3
     * they represent, namely <code>boolean</code>, <code>byte</code>,
     * <code>char</code>, <code>short</code>, <code>int</code>,
     * <code>long</code>, <code>float</code>, and <code>double</code>.
d478 2
a479 2
     * final variables, and are the only <code>Class</code> objects for which
     * this method returns <code>true</code>.
d497 1
a497 1
     * Returns true if this <tt>Class</tt> object represents an annotation
d501 2
a502 2
     * @@return <tt>true</tt> if this class object represents an annotation
     *      type; <tt>false</tt> otherwise
d510 3
a512 3
     * Returns <tt>true</tt> if this class is a synthetic class;
     * returns <tt>false</tt> otherwise.
     * @@return <tt>true</tt> if and only if this class is a synthetic class as
d522 3
a524 3
     * primitive type, or void) represented by this <tt>Class</tt> object,
     * as a <tt>String</tt>.
     * 
d530 1
a530 1
     * name returned is a <tt>String</tt> equal to the Java language
d532 1
a532 1
     * 
d535 1
a535 1
     * one or more '<tt>[</tt>' characters representing the depth of the array
d543 1
a543 1
     * <tr><td> class or interface  
d589 2
a590 2
     * this method calls the security manager's <code>checkPermission</code> 
     * method with a <code>RuntimePermission("getClassLoader")</code> 
d592 1
a592 1
     * 
d599 2
a600 2
     *    if a security manager exists and its 
     *    <code>checkPermission</code> method denies
d626 1
a626 1
     * Returns an array of <tt>TypeVariable</tt> objects that represent the
d628 1
a628 1
     * <tt>GenericDeclaration</tt> object, in declaration order.  Returns an
d632 1
a632 1
     * @@return an array of <tt>TypeVariable</tt> objects that represent
d641 1
a641 1
        if (getGenericSignature() != null) 
d649 1
a649 1
     * Returns the <code>Class</code> representing the superclass of the entity
d651 2
a652 2
     * <code>Class</code>.  If this <code>Class</code> represents either the
     * <code>Object</code> class, an interface, a primitive type, or void, then
d654 1
a654 1
     * <code>Class</code> object representing the <code>Object</code> class is
d663 1
a663 1
     * Returns the <tt>Type</tt> representing the direct superclass of
d665 3
a667 3
     * this <tt>Class</tt>.
     * 
     * <p>If the superclass is a parameterized type, the <tt>Type</tt>
d674 1
a674 1
     * this <tt>Class</tt> represents either the <tt>Object</tt>
d677 1
a677 1
     * <tt>Class</tt> object representing the <tt>Object</tt> class is
d685 1
a685 1
     * @@throws MalformedParameterizedTypeException if the 
d730 2
a731 2
     * the order of the interface names in the <code>implements</code> clause
     * of the declaration of the class represented by this object. For 
d733 15
a747 15
     * <blockquote><pre>
     * class Shimmer implements FloorWax, DessertTopping { ... }
     * </pre></blockquote>
     * suppose the value of <code>s</code> is an instance of 
     * <code>Shimmer</code>; the value of the expression:
     * <blockquote><pre>
     * s.getClass().getInterfaces()[0]
     * </pre></blockquote>
     * is the <code>Class</code> object that represents interface 
     * <code>FloorWax</code>; and the value of:
     * <blockquote><pre>
     * s.getClass().getInterfaces()[1]
     * </pre></blockquote>
     * is the <code>Class</code> object that represents interface 
     * <code>DessertTopping</code>.
d752 1
a752 1
     * names in the <code>extends</code> clause of the declaration of the
d766 1
a766 1
     * Returns the <tt>Type</tt>s representing the interfaces 
d771 1
a771 1
     * <tt>Type</tt> object returned for it must accurately reflect
d783 1
a783 1
     * the <tt>implements</tt> clause of the declaration of the class
d785 1
a785 1
     * interfaces <tt>Cloneable</tt> and <tt>Serializable</tt> are
d792 1
a792 1
     * <tt>extends</tt> clause of the declaration of the interface
d807 1
a807 1
     * @@throws MalformedParameterizedTypeException if any of the 
d822 1
a822 1
     * Returns the <code>Class</code> representing the component type of an
d826 1
a826 1
     * @@return the <code>Class</code> representing the component type of this
d837 4
a840 4
     * constants for <code>public</code>, <code>protected</code>,
     * <code>private</code>, <code>final</code>, <code>static</code>,
     * <code>abstract</code> and <code>interface</code>; they should be decoded
     * using the methods of class <code>Modifier</code>.
d843 1
a843 1
     * <code>public</code>, <code>private</code> and <code>protected</code>
d845 7
a851 7
     * <code>Class</code> represents a primitive type or void, its
     * <code>public</code> modifier is always <code>true</code>, and its
     * <code>protected</code> and <code>private</code> modifiers are always
     * <code>false</code>. If this object represents an array class, a
     * primitive type or void, then its <code>final</code> modifier is always
     * <code>true</code> and its interface modifier is always
     * <code>false</code>. The values of its other modifiers are not determined
d857 1
a857 1
     * @@return the <code>int</code> representing the modifiers for this class
d873 1
a873 1
        
d882 1
a882 1
     * If this <tt>Class</tt> object represents a local or anonymous
d886 1
a886 1
     * <tt>null</tt> otherwise.
d888 1
a888 1
     * In particular, this method returns <tt>null</tt> if the underlying
d893 1
a893 1
     *     that class is a local or anonymous class; otherwise <tt>null</tt>.
d898 1
a898 1
        
d905 1
a905 1
            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(), 
d934 1
a934 1
                            
d942 1
a942 1
                
d975 1
a975 1
                name            = (String)   enclosingInfo[1]; 
d1011 1
a1011 1
     * If this <tt>Class</tt> object represents a local or anonymous
d1015 2
a1016 2
     * class. Returns <tt>null</tt> otherwise.  In particular, this
     * method returns <tt>null</tt> if the underlying class is a local
d1021 1
a1021 1
     *     that class is a local or anonymous class; otherwise <tt>null</tt>.
d1026 1
a1026 1
        
d1033 1
a1033 1
            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(), 
d1058 1
a1058 1
                        
d1063 1
a1063 1
                
d1070 2
a1071 2
     * If the class or interface represented by this <code>Class</code> object
     * is a member of another class, returns the <code>Class</code> object
d1074 1
a1074 1
     * this <code>Class</code> object represents an array class, a primitive
d1086 1
a1086 1
     * method returns <tt>null</tt>.
d1163 1
a1163 1
     * Character.isDigit answers <tt>true</tt> to some non-ascii
d1177 1
a1177 1
     * <tt>null</tt> otherwise.
d1200 1
a1200 1
 
d1202 1
a1202 1
     * Returns <tt>true</tt> if and only if the underlying class
d1205 1
a1205 1
     * @@return <tt>true</tt> if and only if this class is an anonymous class.
d1211 1
a1211 1
 
d1213 1
a1213 1
     * Returns <tt>true</tt> if and only if the underlying class
d1216 1
a1216 1
     * @@return <tt>true</tt> if and only if this class is a local class.
d1224 1
a1224 1
     * Returns <tt>true</tt> if and only if the underlying class
d1227 1
a1227 1
     * @@return <tt>true</tt> if and only if this class is a member class.
d1237 1
a1237 1
     * Returns <tt>null</tt> if the underlying class is a top level
d1253 2
a1254 2
     * Returns <tt>true</tt> if this is a local class or an anonymous
     * class.  Returns <tt>false</tt> otherwise.
d1264 1
a1264 1
     * Returns an array containing <code>Class</code> objects representing all
d1266 1
a1266 1
     * represented by this <code>Class</code> object.  This includes public
d1269 1
a1269 1
     * array of length 0 if this <code>Class</code> object has no public member
d1271 1
a1271 1
     * this <code>Class</code> object represents a primitive type, an array
d1273 2
a1274 2
     * 
     * @@return the array of <code>Class</code> objects representing the public
d1282 3
a1284 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> method
d1289 2
a1290 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package 
d1292 1
a1292 1
     * 
d1300 1
a1300 1
        // checkMemberAccess call for security reasons 
d1334 1
a1334 1
     * Returns an array containing <code>Field</code> objects reflecting all
d1336 1
a1336 1
     * this <code>Class</code> object.  The elements in the array returned are
d1341 1
a1341 1
     * <p> Specifically, if this <code>Class</code> object represents a class,
d1343 1
a1343 1
     * superclasses.  If this <code>Class</code> object represents an
d1348 1
a1348 1
     * method. User code should use the methods of class <code>Array</code> to
d1353 1
a1353 1
     * @@return the array of <code>Field</code> objects representing the
d1361 3
a1363 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
d1368 2
a1369 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1379 1
a1379 1
        // checkMemberAccess call for security reasons 
d1387 1
a1387 1
     * Returns an array containing <code>Method</code> objects reflecting all
d1389 1
a1389 1
     * by this <code>Class</code> object, including those declared by the class
d1391 4
a1394 4
     * superinterfaces.  Array classes return all the (public) member methods 
     * inherited from the <code>Object</code> class.  The elements in the array 
     * returned are not sorted and are not in any particular order.  This 
     * method returns an array of length 0 if this <code>Class</code> object
d1396 1
a1396 1
     * this <code>Class</code> object represents a primitive type or void.
d1398 1
a1398 1
     * <p> The class initialization method <code>&lt;clinit&gt;</code> is not
d1405 1
a1405 1
     * @@return the array of <code>Method</code> objects representing the
d1413 3
a1415 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
d1420 2
a1421 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1431 1
a1431 1
        // checkMemberAccess call for security reasons 
d1439 1
a1439 1
     * Returns an array containing <code>Constructor</code> objects reflecting
d1441 1
a1441 1
     * <code>Class</code> object.  An array of length 0 is returned if the
d1455 1
a1455 1
     * @@return the array of <code>Constructor</code> objects representing the
d1463 3
a1465 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
d1470 2
a1471 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1481 1
a1481 1
        // checkMemberAccess call for security reasons 
d1489 1
a1489 1
     * Returns a <code>Field</code> object that reflects the specified public
d1491 2
a1492 2
     * <code>Class</code> object. The <code>name</code> parameter is a
     * <code>String</code> specifying the simple name of the desired field.
d1504 1
a1504 1
     *      If C has no superclass, then a <code>NoSuchFieldException</code>
d1509 1
a1509 1
     * 
d1511 2
a1512 2
     * @@return  the <code>Field</code> object of this class specified by 
     * <code>name</code>
d1515 1
a1515 1
     * @@exception NullPointerException if <code>name</code> is <code>null</code>
d1522 3
a1524 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
d1529 2
a1530 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1541 1
a1541 1
        // checkMemberAccess call for security reasons 
d1553 1
a1553 1
     * Returns a <code>Method</code> object that reflects the specified public
d1555 3
a1557 3
     * <code>Class</code> object. The <code>name</code> parameter is a
     * <code>String</code> specifying the simple name of the desired method. The
     * <code>parameterTypes</code> parameter is an array of <code>Class</code>
d1559 1
a1559 1
     * order. If <code>parameterTypes</code> is <code>null</code>, it is 
d1562 2
a1563 2
     * <p> If the <code>name</code> is "{@@code <init>};"or "{@@code <clinit>}" a
     * <code>NoSuchMethodException</code> is raised. Otherwise, the method to
d1597 2
a1598 2
     * @@return the <code>Method</code> object that matches the specified
     * <code>name</code> and <code>parameterTypes</code>
d1601 1
a1601 1
     * @@exception NullPointerException if <code>name</code> is <code>null</code>
d1608 3
a1610 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
d1615 2
a1616 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1627 1
a1627 1
        // checkMemberAccess call for security reasons 
d1639 5
a1643 5
     * Returns a <code>Constructor</code> object that reflects the specified
     * public constructor of the class represented by this <code>Class</code>
     * object. The <code>parameterTypes</code> parameter is an array of
     * <code>Class</code> objects that identify the constructor's formal
     * parameter types, in declared order.  
d1645 1
a1645 1
     * If this <code>Class</code> object represents an inner class
d1650 2
a1651 2
     * represented by this <code>Class</code> object whose formal parameter
     * types match those specified by <code>parameterTypes</code>.
d1654 2
a1655 2
     * @@return the <code>Constructor</code> object of the public constructor that
     * matches the specified <code>parameterTypes</code>
d1663 3
a1665 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.PUBLIC)}</tt> denies
d1670 2
a1671 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1682 1
a1682 1
        // checkMemberAccess call for security reasons 
d1690 1
a1690 1
     * Returns an array of <code>Class</code> objects reflecting all the
d1692 1
a1692 1
     * this <code>Class</code> object. This includes public, protected, default
d1696 1
a1696 1
     * interfaces as members, or if this <code>Class</code> object represents a
d1699 1
a1699 1
     * @@return the array of <code>Class</code> objects representing all the 
d1707 3
a1709 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)}</tt> denies
d1714 2
a1715 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1725 1
a1725 1
        // checkMemberAccess call for security reasons 
d1733 1
a1733 1
     * Returns an array of <code>Field</code> objects reflecting all the fields
d1735 1
a1735 1
     * <code>Class</code> object. This includes public, protected, default
d1739 1
a1739 1
     * or interface declares no fields, or if this <code>Class</code> object
d1744 1
a1744 1
     * @@return    the array of <code>Field</code> objects representing all the
d1752 3
a1754 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)}</tt> denies
d1759 2
a1760 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1770 1
a1770 1
        // checkMemberAccess call for security reasons 
d1778 1
a1778 1
     * Returns an array of <code>Method</code> objects reflecting all the
d1780 1
a1780 1
     * <code>Class</code> object. This includes public, protected, default
d1784 1
a1784 1
     * or interface declares no methods, or if this <code>Class</code> object
d1786 1
a1786 1
     * initialization method <code>&lt;clinit&gt;</code> is not included in the
d1793 1
a1793 1
     * @@return    the array of <code>Method</code> objects representing all the
d1801 3
a1803 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)}</tt> denies
d1808 2
a1809 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1819 1
a1819 1
        // checkMemberAccess call for security reasons 
d1827 1
a1827 1
     * Returns an array of <code>Constructor</code> objects reflecting all the
d1829 1
a1829 1
     * <code>Class</code> object. These are public, protected, default
d1833 1
a1833 1
     * This method returns an array of length 0 if this <code>Class</code>
d1839 1
a1839 1
     * @@return    the array of <code>Constructor</code> objects representing all the
d1847 3
a1849 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)}</tt> denies
d1854 2
a1855 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1865 1
a1865 1
        // checkMemberAccess call for security reasons 
d1873 3
a1875 3
     * Returns a <code>Field</code> object that reflects the specified declared
     * field of the class or interface represented by this <code>Class</code>
     * object. The <code>name</code> parameter is a <code>String</code> that
d1877 1
a1877 1
     * will not reflect the <code>length</code> field of an array class.
d1880 1
a1880 1
     * @@return the <code>Field</code> object for the specified field in this
d1884 1
a1884 1
     * @@exception NullPointerException if <code>name</code> is <code>null</code>
d1891 3
a1893 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)}</tt> denies
d1898 2
a1899 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1910 1
a1910 1
        // checkMemberAccess call for security reasons 
d1922 1
a1922 1
     * Returns a <code>Method</code> object that reflects the specified
d1924 4
a1927 4
     * <code>Class</code> object. The <code>name</code> parameter is a
     * <code>String</code> that specifies the simple name of the desired
     * method, and the <code>parameterTypes</code> parameter is an array of
     * <code>Class</code> objects that identify the method's formal parameter
d1932 1
a1932 1
     * name is "&lt;init&gt;"or "&lt;clinit&gt;" a <code>NoSuchMethodException</code>
d1937 1
a1937 1
     * @@return    the <code>Method</code> object for the method of this class
d1940 1
a1940 1
     * @@exception NullPointerException if <code>name</code> is <code>null</code>
d1947 3
a1949 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)}</tt> denies
d1954 2
a1955 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d1966 1
a1966 1
        // checkMemberAccess call for security reasons 
d1978 1
a1978 1
     * Returns a <code>Constructor</code> object that reflects the specified
d1980 2
a1981 2
     * <code>Class</code> object.  The <code>parameterTypes</code> parameter is
     * an array of <code>Class</code> objects that identify the constructor's
d1984 1
a1984 1
     * If this <code>Class</code> object represents an inner class
d1989 1
a1989 1
     * @@return    The <code>Constructor</code> object for the constructor with the
d1998 3
a2000 3
     *             <li> invocation of 
     *             <tt>{@@link SecurityManager#checkMemberAccess
     *             s.checkMemberAccess(this, Member.DECLARED)}</tt> denies
d2005 2
a2006 2
     *             invocation of <tt>{@@link SecurityManager#checkPackageAccess
     *             s.checkPackageAccess()}</tt> denies access to the package
d2017 1
a2017 1
        // checkMemberAccess call for security reasons 
d2036 1
a2036 1
     * <li> If the <tt>name</tt> begins with a <tt>'/'</tt>
d2038 1
a2038 1
     * portion of the <tt>name</tt> following the <tt>'/'</tt>. 
d2042 3
a2044 3
     * <blockquote><pre>
     *   <tt>modified_package_name</tt>/<tt>name</tt>
     * </pre></blockquote>
d2046 2
a2047 2
     * <p> Where the <tt>modified_package_name</tt> is the package name of this
     * object with <tt>'/'</tt> substituted for <tt>'.'</tt>
d2053 1
a2053 1
     * @@return      A {@@link java.io.InputStream} object or <tt>null</tt> if
d2055 1
a2055 1
     * @@throws  NullPointerException If <tt>name</tt> is <tt>null</tt>
d2081 1
a2081 1
     * <li> If the <tt>name</tt> begins with a <tt>'/'</tt>
d2083 1
a2083 1
     * portion of the <tt>name</tt> following the <tt>'/'</tt>. 
d2087 3
a2089 3
     * <blockquote><pre>
     *   <tt>modified_package_name</tt>/<tt>name</tt>
     * </pre></blockquote>
d2091 2
a2092 2
     * <p> Where the <tt>modified_package_name</tt> is the package name of this
     * object with <tt>'/'</tt> substituted for <tt>'.'</tt>
d2098 1
a2098 1
     * @@return      A  {@@link java.net.URL} object or <tt>null</tt> if no
d2119 1
a2119 1
     * Returns the <code>ProtectionDomain</code> of this class.  If there is a
d2121 2
a2122 2
     * manager's <code>checkPermission</code> method with a
     * <code>RuntimePermission("getProtectionDomain")</code> permission to
d2124 1
a2124 1
     * <code>ProtectionDomain</code>.
d2129 2
a2130 2
     *        if a security manager exists and its 
     *        <code>checkPermission</code> method doesn't allow 
d2146 1
a2146 1
                java.security.Permissions perms = 
d2149 1
a2149 1
                allPermDomain = 
d2194 1
a2194 1
            if ((ccl != null) && (ccl != cl) && 
d2281 1
a2281 1
        return CoreReflectionFactory.make(this, ClassScope.make(this)); 
d2289 1
a2289 1
            genericInfo = ClassRepository.make(getGenericSignature(), 
d2355 1
a2355 1
        
d2479 1
a2479 1
        
d2691 1
a2691 1
  
d2821 1
a2821 1
     * Class Class is special cased within the Serialization Stream Protocol. 
d2823 1
a2823 1
     * A Class instance is written initially into an ObjectOutputStream in the 
d2826 3
a2828 3
     *      <code>TC_CLASS</code> ClassDescriptor
     *      A ClassDescriptor is a special cased serialization of 
     *      a <code>java.io.ObjectStreamClass</code> instance. 
d2836 1
a2836 1
    private static final ObjectStreamField[] serialPersistentFields = 
d2895 1
a2895 1
        return (this.getModifiers() & ENUM) != 0 && 
d2935 1
a2935 1
          
d2989 1
a2989 1
     * method is used internally by Enum to implement 
d3011 1
a3011 1
     * by this <tt>Class</tt> object.
d3029 1
a3029 1
     * Casts this <tt>Class</tt> object to represent a subclass of the class
d3031 1
a3031 1
     * is valid, and throws a <tt>ClassCastException</tt> if it is not.  If
d3035 2
a3036 2
     * a <tt>Class</tt> object to pass it to an API that restricts the
     * <tt>Class</tt> objects that it is willing to accept.  A cast would
d3041 1
a3041 1
     * @@return this <tt>Class</tt> object, cast to represent a subclass of
d3043 1
a3043 1
     * @@throws ClassCastException if this <tt>Class</tt> object does not
d3085 1
a3085 1
    public Annotation[] getAnnotations() { 
@


1.4
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@d118 2
a119 2
			      java.lang.reflect.GenericDeclaration, 
			      java.lang.reflect.Type,
d248 3
a250 3
     * @@see 	  java.lang.Class#forName(String) 
     * @@see 	  java.lang.ClassLoader
     * @@since 	  1.2
d254 1
a254 1
				   ClassLoader loader)
d257 11
a267 11
	if (loader == null) {
	    SecurityManager sm = System.getSecurityManager();
	    if (sm != null) {
		ClassLoader ccl = ClassLoader.getCallerClassLoader();
		if (ccl != null) {
		    sm.checkPermission(
			SecurityConstants.GET_CLASSLOADER_PERMISSION);
		}
	    }
	}
	return forName0(name, initialize, loader);
d272 2
a273 2
					    ClassLoader loader)
	throws ClassNotFoundException;
d326 4
a329 4
	if (System.getSecurityManager() != null) {
	    checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
	}
	return newInstance0(ikvm.internal.CallerID.getCallerID());
d346 1
a346 1
		Class[] empty = {};
d507 1
a507 1
	return (getModifiers() & ANNOTATION) != 0;
d518 1
a518 1
	return (getModifiers() & SYNTHETIC) != 0;
d572 3
a574 3
	if (name == null)
	    name = getName0();
	return name;
d642 4
a645 4
	if (getGenericSignature() != null) 
	    return (TypeVariable<Class<T>>[])getGenericInfo().getTypeParameters();
	else
	    return (TypeVariable<Class<T>>[])new TypeVariable[0];
d693 9
a701 9
	if (getGenericSignature() != null) {
	    // Historical irregularity:
	    // Generic signature marks interfaces with superclass = Object
	    // but this API returns null for interfaces
	    if (isInterface())
		return null;
	    return getGenericInfo().getSuperclass();
	} else
	    return getSuperclass();
d815 4
a818 4
	if (getGenericSignature() != null)
	    return getGenericInfo().getSuperInterfaces();
	else
	    return getInterfaces();
d869 3
a871 3
     * 		particular, this method returns null if this object represents
     * 		a primitive type or void.
     * @@since 	JDK1.1
d898 48
a945 48
	EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
	
	if (enclosingInfo == null)
	    return null;
	else {
	    if (!enclosingInfo.isMethod())
		return null;

	    MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(), 
							      getFactory());
	    Class      returnType       = toClass(typeInfo.getReturnType());
	    Type []    parameterTypes   = typeInfo.getParameterTypes();
	    Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];

	    // Convert Types to Classes; returned types *should*
	    // be class objects since the methodDescriptor's used
	    // don't have generics information
	    for(int i = 0; i < parameterClasses.length; i++)
		parameterClasses[i] = toClass(parameterTypes[i]);

	    /*
	     * Loop over all declared methods; match method name,
	     * number of and type of parameters, *and* return
	     * type.  Matching return type is also necessary
	     * because of covariant returns, etc.
	     */
	    for(Method m: enclosingInfo.getEnclosingClass().getDeclaredMethods()) {
		if (m.getName().equals(enclosingInfo.getName()) ) {
		    Class<?>[] candidateParamClasses = m.getParameterTypes();
		    if (candidateParamClasses.length == parameterClasses.length) {
			boolean matches = true;
			for(int i = 0; i < candidateParamClasses.length; i++) {
			    if (!candidateParamClasses[i].equals(parameterClasses[i])) {
				matches = false;
				break;
			    }
			}
			    
			if (matches) { // finally, check return type
			    if (m.getReturnType().equals(returnType) )
				return m;
			}
		    }
		}
	    }
		
	    throw new InternalError("Enclosing method not found");
	}
d951 6
a956 6
	Object[] enclosingInfo = getEnclosingMethod0();
	if (enclosingInfo == null)
	    return null;
	else {
	    return new EnclosingMethodInfo(enclosingInfo);
	}
d960 30
a989 32
	private Class<?> enclosingClass;
	private String name;
	private String descriptor;

	private EnclosingMethodInfo(Object[] enclosingInfo) {
	    if (enclosingInfo.length != 3)
		throw new InternalError("Malformed enclosing method information");
	    try {
		// The array is expected to have three elements:

		// the immediately enclosing class
		enclosingClass = (Class<?>) enclosingInfo[0];
		assert(enclosingClass != null);

		// the immediately enclosing method or constructor's
		// name (can be null).
		name		= (String)   enclosingInfo[1]; 

		// the immediately enclosing method or constructor's
		// descriptor (null iff name is).
		descriptor	= (String)   enclosingInfo[2];
		assert((name != null && descriptor != null) || name == descriptor);
	    } catch (ClassCastException cce) {
		throw new InternalError("Invalid type in enclosing method information");
	    }
	}

	boolean isPartial() {
	    return enclosingClass == null || name == null || descriptor == null;
	}

	boolean isConstructor() { return !isPartial() && "<init>".equals(name); }
d991 1
a991 1
	boolean isMethod() { return !isPartial() && !isConstructor() && !"<clinit>".equals(name); }
d993 1
a993 1
	Class<?> getEnclosingClass() { return enclosingClass; }
d995 1
a995 1
	String getName() { return name; }
d997 3
a999 1
	String getDescriptor() { return descriptor; }
d1004 5
a1008 5
	if (o instanceof GenericArrayType)
	    return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
				     0)
		.getClass();
	return (Class)o;
d1026 41
a1066 41
	EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
	
	if (enclosingInfo == null)
	    return null;
	else {
	    if (!enclosingInfo.isConstructor())
		return null;

	    ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(), 
									getFactory());
	    Type []    parameterTypes   = typeInfo.getParameterTypes();
	    Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];

	    // Convert Types to Classes; returned types *should*
	    // be class objects since the methodDescriptor's used
	    // don't have generics information
	    for(int i = 0; i < parameterClasses.length; i++)
		parameterClasses[i] = toClass(parameterTypes[i]);

	    /*
	     * Loop over all declared constructors; match number
	     * of and type of parameters.
	     */
	    for(Constructor c: enclosingInfo.getEnclosingClass().getDeclaredConstructors()) {
		Class<?>[] candidateParamClasses = c.getParameterTypes();
		if (candidateParamClasses.length == parameterClasses.length) {
		    boolean matches = true;
		    for(int i = 0; i < candidateParamClasses.length; i++) {
			if (!candidateParamClasses[i].equals(parameterClasses[i])) {
			    matches = false;
			    break;
			}
		    }
			
		    if (matches)
			return c;
		}
	    }
		
	    throw new InternalError("Enclosing constructor not found");
	}
d1092 24
a1115 24
	// There are five kinds of classes (or interfaces):
	// a) Top level classes
	// b) Nested classes (static member classes)
	// c) Inner classes (non-static member classes)
	// d) Local classes (named classes declared within a method)
	// e) Anonymous classes


	// JVM Spec 4.8.6: A class must have an EnclosingMethod
	// attribute if and only if it is a local class or an
	// anonymous class.
	EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();

	if (enclosingInfo == null) {
	    // This is a top level or a nested class or an inner class (a, b, or c)
	    return getDeclaringClass();
	} else {
	    Class<?> enclosingClass = enclosingInfo.getEnclosingClass();
	    // This is a local class or an anonymous class (d or e)
	    if (enclosingClass == this || enclosingClass == null)
		throw new InternalError("Malformed enclosing method information");
	    else
		return enclosingClass;
	}
d1131 2
a1132 2
	if (isArray())
	    return getComponentType().getSimpleName()+"[]";
d1134 27
a1160 27
	String simpleName = getSimpleBinaryName();
	if (simpleName == null) { // top level class
	    simpleName = getName();
	    return simpleName.substring(simpleName.lastIndexOf(".")+1); // strip the package name
	}
	// According to JLS3 "Binary Compatibility" (13.1) the binary
	// name of non-package classes (not top level) is the binary
	// name of the immediately enclosing class followed by a '$' followed by:
	// (for nested and inner classes): the simple name.
	// (for local classes): 1 or more digits followed by the simple name.
	// (for anonymous classes): 1 or more digits.

	// Since getSimpleBinaryName() will strip the binary name of
	// the immediatly enclosing class, we are now looking at a
	// string that matches the regular expression "\$[0-9]*"
	// followed by a simple name (considering the simple of an
	// anonymous class to be the empty string).

	// Remove leading "\$[0-9]*" from the name
	int length = simpleName.length();
	if (length < 1 || simpleName.charAt(0) != '$')
	    throw new InternalError("Malformed class name");
	int index = 1;
	while (index < length && isAsciiDigit(simpleName.charAt(index)))
	    index++;
	// Eventually, this is the empty string iff this is an anonymous class
	return simpleName.substring(index);
d1168 1
a1168 1
	return '0' <= c && c <= '9';
d1182 18
a1199 18
	if (isArray()) {
	    String canonicalName = getComponentType().getCanonicalName();
	    if (canonicalName != null)
		return canonicalName + "[]";
	    else
		return null;
	}
	if (isLocalOrAnonymousClass())
	    return null;
	Class<?> enclosingClass = getEnclosingClass();
	if (enclosingClass == null) { // top level class
	    return getName();
	} else {
	    String enclosingName = enclosingClass.getCanonicalName();
	    if (enclosingName == null)
		return null;
	    return enclosingName + "." + getSimpleName();
	}
d1210 1
a1210 1
	return "".equals(getSimpleName());
d1221 1
a1221 1
	return isLocalOrAnonymousClass() && !isAnonymousClass();
d1232 1
a1232 1
	return getSimpleBinaryName() != null && !isLocalOrAnonymousClass();
d1242 9
a1250 9
	Class<?> enclosingClass = getEnclosingClass();
	if (enclosingClass == null) // top level class
	    return null;
	// Otherwise, strip the enclosing class' name
	try {
	    return getName().substring(enclosingClass.getName().length());
	} catch (IndexOutOfBoundsException ex) {
	    throw new InternalError("Malformed class name");
	}
d1258 4
a1261 4
	// JVM Spec 4.8.6: A class must have an EnclosingMethod
	// attribute if and only if it is a local class or an
	// anonymous class.
	return getEnclosingMethodInfo() != null;
d1300 3
a1302 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1305 24
a1328 24
	// Privileged so this implementation can look at DECLARED classes,
	// something the caller might not have privilege to do.  The code here
	// is allowed to look at DECLARED classes because (1) it does not hand
	// out anything other than public members and (2) public member access
	// has already been ok'd by the SecurityManager.

	Class[] result = (Class[]) java.security.AccessController.doPrivileged
	    (new java.security.PrivilegedAction() {
	        public Object run() {
		    java.util.List<Class> list = new java.util.ArrayList();
		    Class currentClass = Class.this;
		    while (currentClass != null) {
			Class[] members = currentClass.getDeclaredClasses();
			for (int i = 0; i < members.length; i++) {
			    if (Modifier.isPublic(members[i].getModifiers())) {
				list.add(members[i]);
			    }
			}
			currentClass = currentClass.getSuperclass();
		    }
		    Class[] empty = {};
		    return list.toArray(empty);
		}
	    });
d1379 3
a1381 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1431 3
a1433 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1481 3
a1483 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1501 2
a1502 2
     * 	    recursively to each direct superinterface of C. The direct
     * 	    superinterfaces are searched in the order they were declared.</LI>
d1541 3
a1543 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1569 2
a1570 2
     * 	    method is found, the algorithm of step 1 is invoked recursively on
     * 	    the superclass of C.</LI>
d1627 3
a1629 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1682 3
a1684 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1725 3
a1727 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1770 3
a1772 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1819 3
a1821 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1865 3
a1867 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1910 3
a1912 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d1966 3
a1968 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d2017 3
a2019 3
	// be very careful not to change the stack depth of this
	// checkMemberAccess call for security reasons 
	// see java.lang.SecurityManager.checkMemberAccess
d2194 1
a2194 1
	    ClassLoader cl = getClassLoader0();
d2197 7
a2203 7
		String name = this.getName();
		int i = name.lastIndexOf('.');
		if (i != -1) {
		    s.checkPackageAccess(name.substring(0, i));
		}
	    }
	}
d2258 13
a2270 13
	if (lastRedefinedCount != classRedefinedCount) {
	    declaredFields = publicFields = declaredPublicFields = null;
	    declaredMethods = publicMethods = declaredPublicMethods = null;
	    declaredConstructors = publicConstructors = null;
	    annotations = declaredAnnotations = null;

	    // Use of "volatile" (and synchronization by caller in the case
	    // of annotations) ensures that no thread sees the update to
	    // lastRedefinedCount before seeing the caches cleared.
	    // We do not guard against brief windows during which multiple
	    // threads might redundantly work to fill an empty cache.
	    lastRedefinedCount = classRedefinedCount;
	}
d2281 2
a2282 2
	// create scope and factory
	return CoreReflectionFactory.make(this, ClassScope.make(this)); 
d2287 7
a2293 7
	// lazily initialize repository if necessary
	if (genericInfo == null) {
	    // create and cache generic info repository
	    genericInfo = ClassRepository.make(getGenericSignature(), 
					       getFactory());
	}
	return genericInfo; //return cached repository
d2679 1
a2679 1
 	Method res = null;
d2682 1
a2682 1
	    Method m = methods[i];
d2684 4
a2687 4
		&& arrayContentsEq(parameterTypes, m.getParameterTypes())
		&& (res == null
		    || res.getReturnType().isAssignableFrom(m.getReturnType())))
		res = m;
d2690 1
a2690 1
	return (res == null ? res : getReflectionFactory().copyMethod(res));
d2809 2
a2810 2
		Class c = argTypes[i];
		buf.append((c == null) ? "null" : c.getName());
d2838 1
a2838 1
	new ObjectStreamField[0];
d2893 5
a2897 5
	// An enum must both directly extend java.lang.Enum and have
	// the ENUM bit set; classes for specialized enum constants
	// don't do the former.
	return (this.getModifiers() & ENUM) != 0 && 
	this.getSuperclass() == java.lang.Enum.class;
d2954 2
a2955 2
	T[] values = getEnumConstantsShared();
	return (values != null) ? values.clone() : null;
d2965 4
a2968 4
	if (enumConstants == null) {
	    if (!isEnum()) return null;
	    try {
		final Method values = getMethod("values");
d2976 9
a2984 9
		enumConstants = (T[])values.invoke(null);
	    }
	    // These can happen when users concoct enum-like classes
	    // that don't comply with the enum spec.
	    catch (InvocationTargetException ex) { return null; }
	    catch (NoSuchMethodException ex) { return null; }
	    catch (IllegalAccessException ex) { return null; }
	}
	return enumConstants;
d2996 1
a2996 1
	if (enumConstantDirectory == null) {
d3023 4
a3026 4
	if (obj != null && !isInstance(obj))
	    throw new ClassCastException("Cannot cast " + obj.getClass().getName() 
					 + " to " + getName());
	return (T) obj;
@


1.3
log
@Removed method that is no longer needed.
@
text
@d185 1
d252 1
d322 1
d329 1
a329 1
	return newInstance0();
d332 1
a332 1
    private T newInstance0()
d368 1
a368 1
            Class caller = Reflection.getCallerClass(3);
d607 1
d1298 1
d1377 1
d1429 1
d1479 1
d1538 1
d1624 1
d1679 1
d1723 1
d1768 1
d1817 1
d1863 1
d1907 1
d1963 1
d2014 1
@


1.2
log
@Ripped out annotation/constant pool support that is no longer needed.
@
text
@a2280 5
    ConstantPool getConstantPool()
    {
	throw new NoSuchMethodError();
    }

@


1.1
log
@- Forked Class, Constructor and Field.
- Made class annotation handling lazy and bypass encode/decode.
@
text
@d2281 4
a2284 2
// TODO remove this
    native ConstantPool getConstantPool();
@

