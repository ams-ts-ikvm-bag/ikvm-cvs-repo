head	1.41;
access;
symbols
	v8_1_5717_0:1.41
	v8_1:1.41.0.2
	v8_0_5449_1:1.39
	v8_0_5449_0:1.39
	v8_0:1.39.0.2
	v7_4_5196_0:1.35
	v7_4:1.35.0.2
	v7_3:1.33.0.6
	v7_2_4630_6:1.33
	v7_2_4630_5:1.33
	v7_2_4630_4:1.33
	v7_2_4630_3:1.33
	v7_2_4630_2:1.33
	v0_46_0_4:1.26.2.1
	v7_2_4630_1:1.33
	v7_2:1.33.0.4
	v7_1_4532_2:1.33
	v7_1_4532_1:1.33
	v7_1_4532_0:1.33
	v7_1:1.33.0.2
	v7_0_4335_3:1.32
	v7_0_4335_2:1.32
	v7_0_4335_1:1.32
	v0_46_0_2:1.26.2.1
	v7_0_4335_0:1.32
	v7_0:1.32.0.2
	v0_40_0_6:1.12
	v0_40_0_5:1.12
	v0_46_0_1:1.26
	v0_46_0_0:1.26
	v0_46:1.26.0.2
	v0_44_0_6:1.17.2.1
	v0_44_0_5:1.17.2.1
	v0_44_0_4:1.17.2.1
	v0_44_0_3:1.17
	v0_44_0_2:1.17
	v0_42_0_7:1.12
	v0_44_0_1:1.17
	v0_44_0_0:1.17
	v0_44:1.17.0.2
	v0_42_0_6:1.12
	v0_42_0_5:1.12
	v0_42_0_4:1.12
	v0_42_0_3:1.12
	v0_42_0_2:1.12
	v0_42_0_1:1.12
	v0_42_0_0:1.12
	v0_42:1.12.0.4
	v0_40_0_3:1.12
	v0_40_0_2:1.12
	v0_40_0_1:1.12
	v0_40_0_0:1.12
	v0_40:1.12.0.2
	v0_38_0_1:1.11
	v0_38_0_0:1.11
	v0_38:1.11.0.2;
locks; strict;
comment	@# @;


1.41
date	2015.06.26.14.58.40;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2015.06.25.13.14.36;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2014.11.10.09.18.25;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2014.10.29.06.13.36;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2014.06.10.11.14.53;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2014.05.19.12.43.38;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2013.08.12.07.55.57;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2013.05.30.15.21.48;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2012.04.15.14.43.25;	author smallsql;	state Exp;
branches;
next	1.32;

1.32
date	2011.09.01.13.14.55;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.30.09.57.21;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.15.09.05.27;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.11.07.35.47;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.19.11.11.31;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.17.12.32.06;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.24.16.40.22;	author jfrijters;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2010.12.01.06.50.32;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2010.11.30.07.58.35;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2010.11.24.06.38.14;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2010.11.23.09.39.49;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.23.07.30.30;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2010.11.20.07.41.00;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.09.06.35.55;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.09.12.27.39;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.27.11.47.42;	author jfrijters;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2010.02.04.05.08.55;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.31.13.13.30;	author smallsql;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.30.15.49.05;	author smallsql;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.16.20.33.54;	author smallsql;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.19.06.47.29;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.01.05.19.04;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.13.09.01.13;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.12.09.09.40;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.11.09.05.19;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.04.05.12.59;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.25.05.17.54;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.25.04.48.57;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.23.04.25.22;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2008.03.30.06.59.16;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.05.06.57.18;	author jfrijters;	state dead;
branches;
next	1.1;

1.1
date	2007.05.24.09.23.03;	author jfrijters;	state Exp;
branches;
next	;

1.17.2.1
date	2010.08.09.12.31.30;	author jfrijters;	state Exp;
branches;
next	;

1.26.2.1
date	2011.12.20.11.05.32;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Use (cheaper) InterlockedCompareAndSet "native" method instead of AtomicReferenceFieldUpdater.
@
text
@/*
 * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.security.AccessController;
import java.security.AccessControlContext;
import java.security.PrivilegedAction;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.LockSupport;
import sun.nio.ch.Interruptible;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;
import sun.security.util.SecurityConstants;


/**
 * A <i>thread</i> is a thread of execution in a program. The Java
 * Virtual Machine allows an application to have multiple threads of
 * execution running concurrently.
 * <p>
 * Every thread has a priority. Threads with higher priority are
 * executed in preference to threads with lower priority. Each thread
 * may or may not also be marked as a daemon. When code running in
 * some thread creates a new <code>Thread</code> object, the new
 * thread has its priority initially set equal to the priority of the
 * creating thread, and is a daemon thread if and only if the
 * creating thread is a daemon.
 * <p>
 * When a Java Virtual Machine starts up, there is usually a single
 * non-daemon thread (which typically calls the method named
 * <code>main</code> of some designated class). The Java Virtual
 * Machine continues to execute threads until either of the following
 * occurs:
 * <ul>
 * <li>The <code>exit</code> method of class <code>Runtime</code> has been
 *     called and the security manager has permitted the exit operation
 *     to take place.
 * <li>All threads that are not daemon threads have died, either by
 *     returning from the call to the <code>run</code> method or by
 *     throwing an exception that propagates beyond the <code>run</code>
 *     method.
 * </ul>
 * <p>
 * There are two ways to create a new thread of execution. One is to
 * declare a class to be a subclass of <code>Thread</code>. This
 * subclass should override the <code>run</code> method of class
 * <code>Thread</code>. An instance of the subclass can then be
 * allocated and started. For example, a thread that computes primes
 * larger than a stated value could be written as follows:
 * <hr><blockquote><pre>
 *     class PrimeThread extends Thread {
 *         long minPrime;
 *         PrimeThread(long minPrime) {
 *             this.minPrime = minPrime;
 *         }
 *
 *         public void run() {
 *             // compute primes larger than minPrime
 *             &nbsp;.&nbsp;.&nbsp;.
 *         }
 *     }
 * </pre></blockquote><hr>
 * <p>
 * The following code would then create a thread and start it running:
 * <blockquote><pre>
 *     PrimeThread p = new PrimeThread(143);
 *     p.start();
 * </pre></blockquote>
 * <p>
 * The other way to create a thread is to declare a class that
 * implements the <code>Runnable</code> interface. That class then
 * implements the <code>run</code> method. An instance of the class can
 * then be allocated, passed as an argument when creating
 * <code>Thread</code>, and started. The same example in this other
 * style looks like the following:
 * <hr><blockquote><pre>
 *     class PrimeRun implements Runnable {
 *         long minPrime;
 *         PrimeRun(long minPrime) {
 *             this.minPrime = minPrime;
 *         }
 *
 *         public void run() {
 *             // compute primes larger than minPrime
 *             &nbsp;.&nbsp;.&nbsp;.
 *         }
 *     }
 * </pre></blockquote><hr>
 * <p>
 * The following code would then create a thread and start it running:
 * <blockquote><pre>
 *     PrimeRun p = new PrimeRun(143);
 *     new Thread(p).start();
 * </pre></blockquote>
 * <p>
 * Every thread has a name for identification purposes. More than
 * one thread may have the same name. If a name is not specified when
 * a thread is created, a new name is generated for it.
 * <p>
 * Unless otherwise noted, passing a {@@code null} argument to a constructor
 * or method in this class will cause a {@@link NullPointerException} to be
 * thrown.
 *
 * @@author  unascribed
 * @@see     Runnable
 * @@see     Runtime#exit(int)
 * @@see     #run()
 * @@see     #stop()
 * @@since   JDK1.0
 */
public
class Thread implements Runnable {
    // [IKVM]
    static {
        // force the set/getContextClassLoader methods to be JIT compiled, because isCCLOverridden(Thread) depends on it
        // (we don't want to use RuntimeHelpers.PrepareMethod() because it requires full trust)
        Thread dummy = new Thread((Void)null);
        dummy.getContextClassLoader();
        dummy.setContextClassLoader(ClassLoader.DUMMY);
    }
    private Thread(Void _) {
        // body replaced in map.xml
    }
    final class Cleanup {
        protected void finalize() {
            Thread.this.die();
        }
    }
    /* --- start IKVM specific state --- */
    static final int[] nonDaemonCount = new int[1];
    @@cli.System.ThreadStaticAttribute.Annotation
    static Thread current;
    @@cli.System.ThreadStaticAttribute.Annotation
    private static Cleanup cleanup;
    private final Object lock = new Object();
    private cli.System.Threading.Thread nativeThread;
    private Throwable stillborn;
    private boolean running;    // used only for coordination with stop0(), is never set to false
    private volatile boolean interruptPending;
    private volatile boolean nativeInterruptPending;
    private volatile boolean interruptableWait;
    private boolean timedWait;
    volatile Object parkLock;   // used by get/setParkLock in map.xml
    int parkState;              // used by cmpxchgParkState in map.xml
    /* --- end IKVM specific state --- */

    private volatile char  name[];
    private int            priority;
    private Thread         threadQ;
    private long           eetop;

    /* Whether or not to single_step this thread. */
    private boolean     single_step;

    /* Whether or not the thread is a daemon thread. */
    private boolean     daemon = false;

    /* What will be run. */
    private Runnable target;

    /* The group of this thread */
    private ThreadGroup group;

    /* The context ClassLoader for this thread */
    private volatile ClassLoader contextClassLoader;

    /* The inherited AccessControlContext of this thread */
    /* [IKVM] this contains either an AccessControlContext or an AccessController.LazyContext */
    Object inheritedAccessControlContext;

    /* For autonumbering anonymous threads. */
    private static int threadInitNumber;
    private static synchronized int nextThreadNum() {
        return threadInitNumber++;
    }

    /* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */
    ThreadLocal.ThreadLocalMap threadLocals = null;

    /*
     * InheritableThreadLocal values pertaining to this thread. This map is
     * maintained by the InheritableThreadLocal class.
     */
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;

    /*
     * The requested stack size for this thread, or 0 if the creator did
     * not specify a stack size.  It is up to the VM to do whatever it
     * likes with this number; some VMs will ignore it.
     */
    private long stackSize;

    /*
     * JVM-private state that persists after native thread termination.
     */
    private long nativeParkEventPointer;

    /*
     * Thread ID
     */
    private long tid;

    /* For generating thread ID */
    private static long threadSeqNumber;

    /* Java thread status for tools,
     * initialized to indicate thread 'not yet started'
     */

    private volatile int threadStatus = 0;


    private static synchronized long nextThreadID() {
        return ++threadSeqNumber;
    }

    /**
     * The argument supplied to the current call to
     * java.util.concurrent.locks.LockSupport.park.
     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
     */
    @@ikvm.lang.Internal // [IKVM] accessed from java.util.concurrent
    public volatile Object parkBlocker;

    /* The object in which this thread is blocked in an interruptible I/O
     * operation, if any.  The blocker's interrupt method should be invoked
     * after setting this thread's interrupt status.
     */
    private volatile Interruptible blocker;
    private final Object blockerLock = new Object();

    /* Set the blocker field; invoked via sun.misc.SharedSecrets from java.nio code
     */
    void blockedOn(Interruptible b) {
        synchronized (blockerLock) {
            blocker = b;
        }
    }

    /**
     * The minimum priority that a thread can have.
     */
    public final static int MIN_PRIORITY = 1;

   /**
     * The default priority that is assigned to a thread.
     */
    public final static int NORM_PRIORITY = 5;

    /**
     * The maximum priority that a thread can have.
     */
    public final static int MAX_PRIORITY = 10;

    /**
     * Returns a reference to the currently executing thread object.
     *
     * @@return  the currently executing thread.
     */
    public static Thread currentThread() {
        Thread c = current;
        if (c == null) {
            c = new Thread(getMainThreadGroup());
        }
        return c;
    }
    
    private static native ThreadGroup getMainThreadGroup();

    /**
     * A hint to the scheduler that the current thread is willing to yield
     * its current use of a processor. The scheduler is free to ignore this
     * hint.
     *
     * <p> Yield is a heuristic attempt to improve relative progression
     * between threads that would otherwise over-utilise a CPU. Its use
     * should be combined with detailed profiling and benchmarking to
     * ensure that it actually has the desired effect.
     *
     * <p> It is rarely appropriate to use this method. It may be useful
     * for debugging or testing purposes, where it may help to reproduce
     * bugs due to race conditions. It may also be useful when designing
     * concurrency control constructs such as the ones in the
     * {@@link java.util.concurrent.locks} package.
     */
    public static void yield() {
        cli.System.Threading.Thread.Sleep(0);
    }
    
    private void enterInterruptableWait(boolean timedWait) throws InterruptedException {
        synchronized (lock) {
            if (interruptPending) {
                interruptPending = false;
                throw new InterruptedException();
            }
            interruptableWait = true;
            this.timedWait = timedWait;
        }
    }
    
    private void leaveInterruptableWait() throws InterruptedException {
        cli.System.Threading.ThreadInterruptedException dotnetInterrupt = null;
        interruptableWait = false;
        for (; ; ) {
            try {
                if (false) throw new cli.System.Threading.ThreadInterruptedException();
                synchronized (lock) {
                    if (nativeInterruptPending) {
                        nativeInterruptPending = false;
                        // HACK if there is a pending Interrupt (on the .NET thread), we need to consume that
                        // (if there was no contention on "lock (this)" above the interrupted state isn't checked) 
                        try {
                            if (false) throw new cli.System.Threading.ThreadInterruptedException();
                            cli.System.Threading.Thread t = cli.System.Threading.Thread.get_CurrentThread();
                            // the obvious thing to do would be t.Interrupt() / t.Join(),
                            // but for some reason that causes a regression in JSR166TestCase (probably a CLR bug)
                            // so we waste a time slice... sigh.
                            t.Join(1);
                        }
                        catch (cli.System.Threading.ThreadInterruptedException _) {
                        }
                    }
                    if (interruptPending) {
                        interruptPending = false;
                        throw new InterruptedException();
                    }
                }
                break;
            }
            catch (cli.System.Threading.ThreadInterruptedException x) {
                dotnetInterrupt = x;
                nativeInterruptPending = false;
            }
        }
        if (dotnetInterrupt != null) {
            ikvm.runtime.Util.throwException(dotnetInterrupt);
        }
    }

    /**
     * Causes the currently executing thread to sleep (temporarily cease
     * execution) for the specified number of milliseconds, subject to
     * the precision and accuracy of system timers and schedulers. The thread
     * does not lose ownership of any monitors.
     *
     * @@param  millis
     *         the length of time to sleep in milliseconds
     *
     * @@throws  IllegalArgumentException
     *          if the value of {@@code millis} is negative
     *
     * @@throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public static void sleep(long millis) throws InterruptedException {
        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
        Thread c = currentThread();
        c.enterInterruptableWait(true);
        try {
            if (false) throw new cli.System.Threading.ThreadInterruptedException();
            for (long iter = millis / Integer.MAX_VALUE; iter != 0; iter--)
            {
                cli.System.Threading.Thread.Sleep(Integer.MAX_VALUE);
            }
            cli.System.Threading.Thread.Sleep((int)(millis % Integer.MAX_VALUE));
        }
        catch (cli.System.Threading.ThreadInterruptedException _) {
        }
        finally {
            c.leaveInterruptableWait();
        }
    }

    /**
     * Causes the currently executing thread to sleep (temporarily cease
     * execution) for the specified number of milliseconds plus the specified
     * number of nanoseconds, subject to the precision and accuracy of system
     * timers and schedulers. The thread does not lose ownership of any
     * monitors.
     *
     * @@param  millis
     *         the length of time to sleep in milliseconds
     *
     * @@param  nanos
     *         {@@code 0-999999} additional nanoseconds to sleep
     *
     * @@throws  IllegalArgumentException
     *          if the value of {@@code millis} is negative, or the value of
     *          {@@code nanos} is not in the range {@@code 0-999999}
     *
     * @@throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public static void sleep(long millis, int nanos)
    throws InterruptedException {
        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }

        if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
            millis++;
        }

        sleep(millis);
    }

    /**
     * Initializes a Thread with the current AccessControlContext.
     * @@see #init(ThreadGroup,Runnable,String,long,AccessControlContext)
     */
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize) {
        init(g, target, name, stackSize, null);
    }

    /**
     * Initializes a Thread.
     *
     * @@param g the Thread group
     * @@param target the object whose run() method gets called
     * @@param name the name of the new Thread
     * @@param stackSize the desired stack size for the new thread, or
     *        zero to indicate that this parameter is to be ignored.
     * @@param acc the AccessControlContext to inherit, or
     *            AccessController.getContext() if null
     */
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc) {
        if (name == null) {
            throw new NullPointerException("name cannot be null");
        }

        this.name = name.toCharArray();

        Thread parent = currentThread();
        SecurityManager security = System.getSecurityManager();
        if (g == null) {
            /* Determine if it's an applet or not */

            /* If there is a security manager, ask the security manager
               what to do. */
            if (security != null) {
                g = security.getThreadGroup();
            }

            /* If the security doesn't have a strong opinion of the matter
               use the parent thread group. */
            if (g == null) {
                g = parent.getThreadGroup();
            }
        }

        /* checkAccess regardless of whether or not threadgroup is
           explicitly passed in. */
        g.checkAccess();

        /*
         * Do we have the required permissions?
         */
        if (security != null) {
            if (isCCLOverridden(this)) {
                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
            }
        }

        g.addUnstarted();

        this.group = g;
        this.daemon = parent.isDaemon();
        this.priority = parent.getPriority();
        if (isCCLOverridden(parent))
            this.contextClassLoader = parent.getContextClassLoader();
        else
            this.contextClassLoader = parent.contextClassLoader;
        this.inheritedAccessControlContext =
                acc != null ? acc : AccessController.getLazyContext(parent.inheritedAccessControlContext);
        this.target = target;
        setPriority(priority);
        if (parent.inheritableThreadLocals != null)
            this.inheritableThreadLocals =
                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
        /* Stash the specified stack size in case the VM cares */
        this.stackSize = stackSize;

        /* Set thread ID */
        tid = nextThreadID();
    }
    
    // [IKVM] constructor for attaching to a .NET thread
    Thread(ThreadGroup g) {
        this.running = true;
        cli.System.Threading.Thread thread = cli.System.Threading.Thread.get_CurrentThread();
        nativeThread = thread;
        String name = thread.get_Name();
        if (name == null) {
            name = "Thread-" + nextThreadNum();
        }

        this.group = g;
        this.daemon = thread.get_IsBackground();
        this.priority = mapClrPriorityToJava(thread.get_Priority().Value);
        this.name = name.toCharArray();
        this.contextClassLoader = ClassLoader.DUMMY;
        this.threadStatus = 0x0005; /* JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE */

        /* Set thread ID */
        tid = nextThreadID();

        synchronized (g) {
            g.addUnstarted();
            g.add(this);
        }

        current = this;
        cleanup = new Cleanup();

        if (!daemon) {
            cli.System.Threading.Interlocked.Increment(nonDaemonCount);
        }
    }
    
    private static int mapClrPriorityToJava(int priority) {
        // TODO consider supporting -XX:JavaPriorityX_To_OSPriority settings
        switch (priority) {
        case cli.System.Threading.ThreadPriority.Lowest:
            return MIN_PRIORITY;
        case cli.System.Threading.ThreadPriority.BelowNormal:
            return 3;
        default:
        case cli.System.Threading.ThreadPriority.Normal:
            return NORM_PRIORITY;
        case cli.System.Threading.ThreadPriority.AboveNormal:
            return 7;
        case cli.System.Threading.ThreadPriority.Highest:
            return MAX_PRIORITY;
        }
    }
    
    private static int mapJavaPriorityToClr(int priority) {
        // TODO consider supporting -XX:JavaPriorityX_To_OSPriority settings
        if (priority == MIN_PRIORITY) {
            return cli.System.Threading.ThreadPriority.Lowest;
        }
        else if (priority > Thread.MIN_PRIORITY && priority < Thread.NORM_PRIORITY) {
            return cli.System.Threading.ThreadPriority.BelowNormal;
        }
        else if (priority == Thread.NORM_PRIORITY) {
            return cli.System.Threading.ThreadPriority.Normal;
        }
        else if (priority > Thread.NORM_PRIORITY && priority < Thread.MAX_PRIORITY) {
            return cli.System.Threading.ThreadPriority.AboveNormal;
        }
        else if (priority == Thread.MAX_PRIORITY) {
            return cli.System.Threading.ThreadPriority.Highest;
        }
        else {
            // can't happen
            return cli.System.Threading.ThreadPriority.Normal;
        }
    }

    /**
     * Throws CloneNotSupportedException as a Thread can not be meaningfully
     * cloned. Construct a new Thread instead.
     *
     * @@throws  CloneNotSupportedException
     *          always
     */
    @@Override
    protected Object clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException();
    }

    /**
     * Allocates a new {@@code Thread} object. This constructor has the same
     * effect as {@@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
     * {@@code (null, null, gname)}, where {@@code gname} is a newly generated
     * name. Automatically generated names are of the form
     * {@@code "Thread-"+}<i>n</i>, where <i>n</i> is an integer.
     */
    public Thread() {
        init(null, null, "Thread-" + nextThreadNum(), 0);
    }

    /**
     * Allocates a new {@@code Thread} object. This constructor has the same
     * effect as {@@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
     * {@@code (null, target, gname)}, where {@@code gname} is a newly generated
     * name. Automatically generated names are of the form
     * {@@code "Thread-"+}<i>n</i>, where <i>n</i> is an integer.
     *
     * @@param  target
     *         the object whose {@@code run} method is invoked when this thread
     *         is started. If {@@code null}, this classes {@@code run} method does
     *         nothing.
     */
    public Thread(Runnable target) {
        init(null, target, "Thread-" + nextThreadNum(), 0);
    }

    /**
     * Creates a new Thread that inherits the given AccessControlContext.
     * This is not a public constructor.
     */
    Thread(Runnable target, AccessControlContext acc) {
        init(null, target, "Thread-" + nextThreadNum(), 0, acc);
    }

    /**
     * Allocates a new {@@code Thread} object. This constructor has the same
     * effect as {@@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
     * {@@code (group, target, gname)} ,where {@@code gname} is a newly generated
     * name. Automatically generated names are of the form
     * {@@code "Thread-"+}<i>n</i>, where <i>n</i> is an integer.
     *
     * @@param  group
     *         the thread group. If {@@code null} and there is a security
     *         manager, the group is determined by {@@linkplain
     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
     *         If there is not a security manager or {@@code
     *         SecurityManager.getThreadGroup()} returns {@@code null}, the group
     *         is set to the current thread's thread group.
     *
     * @@param  target
     *         the object whose {@@code run} method is invoked when this thread
     *         is started. If {@@code null}, this thread's run method is invoked.
     *
     * @@throws  SecurityException
     *          if the current thread cannot create a thread in the specified
     *          thread group
     */
    public Thread(ThreadGroup group, Runnable target) {
        init(group, target, "Thread-" + nextThreadNum(), 0);
    }

    /**
     * Allocates a new {@@code Thread} object. This constructor has the same
     * effect as {@@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
     * {@@code (null, null, name)}.
     *
     * @@param   name
     *          the name of the new thread
     */
    public Thread(String name) {
        init(null, null, name, 0);
    }

    /**
     * Allocates a new {@@code Thread} object. This constructor has the same
     * effect as {@@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
     * {@@code (group, null, name)}.
     *
     * @@param  group
     *         the thread group. If {@@code null} and there is a security
     *         manager, the group is determined by {@@linkplain
     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
     *         If there is not a security manager or {@@code
     *         SecurityManager.getThreadGroup()} returns {@@code null}, the group
     *         is set to the current thread's thread group.
     *
     * @@param  name
     *         the name of the new thread
     *
     * @@throws  SecurityException
     *          if the current thread cannot create a thread in the specified
     *          thread group
     */
    public Thread(ThreadGroup group, String name) {
        init(group, null, name, 0);
    }

    /**
     * Allocates a new {@@code Thread} object. This constructor has the same
     * effect as {@@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
     * {@@code (null, target, name)}.
     *
     * @@param  target
     *         the object whose {@@code run} method is invoked when this thread
     *         is started. If {@@code null}, this thread's run method is invoked.
     *
     * @@param  name
     *         the name of the new thread
     */
    public Thread(Runnable target, String name) {
        init(null, target, name, 0);
    }

    /**
     * Allocates a new {@@code Thread} object so that it has {@@code target}
     * as its run object, has the specified {@@code name} as its name,
     * and belongs to the thread group referred to by {@@code group}.
     *
     * <p>If there is a security manager, its
     * {@@link SecurityManager#checkAccess(ThreadGroup) checkAccess}
     * method is invoked with the ThreadGroup as its argument.
     *
     * <p>In addition, its {@@code checkPermission} method is invoked with
     * the {@@code RuntimePermission("enableContextClassLoaderOverride")}
     * permission when invoked directly or indirectly by the constructor
     * of a subclass which overrides the {@@code getContextClassLoader}
     * or {@@code setContextClassLoader} methods.
     *
     * <p>The priority of the newly created thread is set equal to the
     * priority of the thread creating it, that is, the currently running
     * thread. The method {@@linkplain #setPriority setPriority} may be
     * used to change the priority to a new value.
     *
     * <p>The newly created thread is initially marked as being a daemon
     * thread if and only if the thread creating it is currently marked
     * as a daemon thread. The method {@@linkplain #setDaemon setDaemon}
     * may be used to change whether or not a thread is a daemon.
     *
     * @@param  group
     *         the thread group. If {@@code null} and there is a security
     *         manager, the group is determined by {@@linkplain
     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
     *         If there is not a security manager or {@@code
     *         SecurityManager.getThreadGroup()} returns {@@code null}, the group
     *         is set to the current thread's thread group.
     *
     * @@param  target
     *         the object whose {@@code run} method is invoked when this thread
     *         is started. If {@@code null}, this thread's run method is invoked.
     *
     * @@param  name
     *         the name of the new thread
     *
     * @@throws  SecurityException
     *          if the current thread cannot create a thread in the specified
     *          thread group or cannot override the context class loader methods.
     */
    public Thread(ThreadGroup group, Runnable target, String name) {
        init(group, target, name, 0);
    }

    /**
     * Allocates a new {@@code Thread} object so that it has {@@code target}
     * as its run object, has the specified {@@code name} as its name,
     * and belongs to the thread group referred to by {@@code group}, and has
     * the specified <i>stack size</i>.
     *
     * <p>This constructor is identical to {@@link
     * #Thread(ThreadGroup,Runnable,String)} with the exception of the fact
     * that it allows the thread stack size to be specified.  The stack size
     * is the approximate number of bytes of address space that the virtual
     * machine is to allocate for this thread's stack.  <b>The effect of the
     * {@@code stackSize} parameter, if any, is highly platform dependent.</b>
     *
     * <p>On some platforms, specifying a higher value for the
     * {@@code stackSize} parameter may allow a thread to achieve greater
     * recursion depth before throwing a {@@link StackOverflowError}.
     * Similarly, specifying a lower value may allow a greater number of
     * threads to exist concurrently without throwing an {@@link
     * OutOfMemoryError} (or other internal error).  The details of
     * the relationship between the value of the <tt>stackSize</tt> parameter
     * and the maximum recursion depth and concurrency level are
     * platform-dependent.  <b>On some platforms, the value of the
     * {@@code stackSize} parameter may have no effect whatsoever.</b>
     *
     * <p>The virtual machine is free to treat the {@@code stackSize}
     * parameter as a suggestion.  If the specified value is unreasonably low
     * for the platform, the virtual machine may instead use some
     * platform-specific minimum value; if the specified value is unreasonably
     * high, the virtual machine may instead use some platform-specific
     * maximum.  Likewise, the virtual machine is free to round the specified
     * value up or down as it sees fit (or to ignore it completely).
     *
     * <p>Specifying a value of zero for the {@@code stackSize} parameter will
     * cause this constructor to behave exactly like the
     * {@@code Thread(ThreadGroup, Runnable, String)} constructor.
     *
     * <p><i>Due to the platform-dependent nature of the behavior of this
     * constructor, extreme care should be exercised in its use.
     * The thread stack size necessary to perform a given computation will
     * likely vary from one JRE implementation to another.  In light of this
     * variation, careful tuning of the stack size parameter may be required,
     * and the tuning may need to be repeated for each JRE implementation on
     * which an application is to run.</i>
     *
     * <p>Implementation note: Java platform implementers are encouraged to
     * document their implementation's behavior with respect to the
     * {@@code stackSize} parameter.
     *
     *
     * @@param  group
     *         the thread group. If {@@code null} and there is a security
     *         manager, the group is determined by {@@linkplain
     *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
     *         If there is not a security manager or {@@code
     *         SecurityManager.getThreadGroup()} returns {@@code null}, the group
     *         is set to the current thread's thread group.
     *
     * @@param  target
     *         the object whose {@@code run} method is invoked when this thread
     *         is started. If {@@code null}, this thread's run method is invoked.
     *
     * @@param  name
     *         the name of the new thread
     *
     * @@param  stackSize
     *         the desired stack size for the new thread, or zero to indicate
     *         that this parameter is to be ignored.
     *
     * @@throws  SecurityException
     *          if the current thread cannot create a thread in the specified
     *          thread group
     *
     * @@since 1.4
     */
    public Thread(ThreadGroup group, Runnable target, String name,
                  long stackSize) {
        init(group, target, name, stackSize);
    }

    /**
     * Causes this thread to begin execution; the Java Virtual Machine
     * calls the <code>run</code> method of this thread.
     * <p>
     * The result is that two threads are running concurrently: the
     * current thread (which returns from the call to the
     * <code>start</code> method) and the other thread (which executes its
     * <code>run</code> method).
     * <p>
     * It is never legal to start a thread more than once.
     * In particular, a thread may not be restarted once it has completed
     * execution.
     *
     * @@exception  IllegalThreadStateException  if the thread was already
     *               started.
     * @@see        #run()
     * @@see        #stop()
     */
    public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }

    private void start0() {
        cli.System.Threading.ThreadStart threadStart = new cli.System.Threading.ThreadStart(new cli.System.Threading.ThreadStart.Method() {
            @@cli.IKVM.Attributes.HideFromJavaAttribute.Annotation
            public void Invoke() {
                threadProc();
            }
        });
        if (stackSize <= 0) {
            nativeThread = new cli.System.Threading.Thread(threadStart);
        }
        else {
            int maxStackSize = (int)Math.min(Math.max(128 * 1024, stackSize), Integer.MAX_VALUE);
            nativeThread = new cli.System.Threading.Thread(threadStart, maxStackSize);
        }
        nativeThread.set_Name(getName());
        nativeThread.set_IsBackground(daemon);
        nativeThread.set_Priority(cli.System.Threading.ThreadPriority.wrap(mapJavaPriorityToClr(priority)));
        String apartment = Props.props.getProperty("ikvm.apartmentstate", "").toLowerCase();
        if ("mta".equals(apartment)) {
            nativeThread.SetApartmentState(cli.System.Threading.ApartmentState.wrap(cli.System.Threading.ApartmentState.MTA));
        }
        else if ("sta".equals(apartment)) {
            nativeThread.SetApartmentState(cli.System.Threading.ApartmentState.wrap(cli.System.Threading.ApartmentState.STA));
        }
        threadStatus = 0x0005; // JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE
        nativeThread.Start();
        if (!daemon) {
            cli.System.Threading.Interlocked.Increment(nonDaemonCount);
        }
    }

    /**
     * If this thread was constructed using a separate
     * <code>Runnable</code> run object, then that
     * <code>Runnable</code> object's <code>run</code> method is called;
     * otherwise, this method does nothing and returns.
     * <p>
     * Subclasses of <code>Thread</code> should override this method.
     *
     * @@see     #start()
     * @@see     #stop()
     * @@see     #Thread(ThreadGroup, Runnable, String)
     */
    @@Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
    
    // [IKVM] for threads started from Java, this method is called on the thread itself,
    // but for .NET threads it will be called by the finalizer of the Cleanup object.
    // NOTE there might be a race condition here (when the thread's Cleanup object
    // is finalized during AppDomain shutdown while the thread is also exiting on its own),
    // but that doesn't matter because Thread.exit() is safe to call multiple times.
    void die() {
        exit();
        synchronized (lock) {
            nativeThread = null;
            threadStatus = 0x0002; // JVMTI_THREAD_STATE_TERMINATED
        }
        wakeupJoinedThreads();
        if (!daemon) {
            // TODO there is a race condition in the non-daemon counting
            // (setDaemon() isn't synchronized so it may clear/set the daemon flag without the count being affected)
            cli.System.Threading.Interlocked.Decrement(nonDaemonCount);
        }
        if (current == this) {
            current = null;
            // check if we have a cleanup object, this happens if we attach and subsequently detach from JNI code
            if (cleanup != null) {
                cli.System.GC.SuppressFinalize(cleanup);
                cleanup = null;
            }
        }
    }

    private void wakeupJoinedThreads() {
        // HACK locking this here isn't ideal, because we might be invoked from
        // the Cleanup object's finalizer and some user code might own the lock and hence
        // block the finalizer thread.
        // A second scenario is that another thread is currently blocking inside stop()
        // (the Thread.Abort() call will block while we are running the finally block)
        // and that thread will own the lock on our thread object.
        boolean locked = false;
        try {
            locked = cli.System.Threading.Monitor.TryEnter(this);
            if (locked) {
                notifyAll();
            } else {
                // HACK schedule an asynchronous notification
                cli.System.Threading.ThreadPool.QueueUserWorkItem(
                    new cli.System.Threading.WaitCallback(
                        new cli.System.Threading.WaitCallback.Method() {
                            public void Invoke(Object thread) {
                                synchronized (thread) {
                                    thread.notifyAll();
                                }
                            }
                        }), this);
            }
        }
        finally {
            if (locked)
                cli.System.Threading.Monitor.Exit(this);
        }
    }

    /**
     * This method is called by the system to give a Thread
     * a chance to clean up before it actually exits.
     */
    private void exit() {
        if (group != null) {
            group.threadTerminated(this);
            group = null;
        }
        /* Aggressively null out all reference fields: see bug 4006245 */
        target = null;
        /* Speed the release of some of these resources */
        threadLocals = null;
        inheritableThreadLocals = null;
        inheritedAccessControlContext = null;
        blocker = null;
        uncaughtExceptionHandler = null;
    }

    /**
     * Forces the thread to stop executing.
     * <p>
     * If there is a security manager installed, its <code>checkAccess</code>
     * method is called with <code>this</code>
     * as its argument. This may result in a
     * <code>SecurityException</code> being raised (in the current thread).
     * <p>
     * If this thread is different from the current thread (that is, the current
     * thread is trying to stop a thread other than itself), the
     * security manager's <code>checkPermission</code> method (with a
     * <code>RuntimePermission("stopThread")</code> argument) is called in
     * addition.
     * Again, this may result in throwing a
     * <code>SecurityException</code> (in the current thread).
     * <p>
     * The thread represented by this thread is forced to stop whatever
     * it is doing abnormally and to throw a newly created
     * <code>ThreadDeath</code> object as an exception.
     * <p>
     * It is permitted to stop a thread that has not yet been started.
     * If the thread is eventually started, it immediately terminates.
     * <p>
     * An application should not normally try to catch
     * <code>ThreadDeath</code> unless it must do some extraordinary
     * cleanup operation (note that the throwing of
     * <code>ThreadDeath</code> causes <code>finally</code> clauses of
     * <code>try</code> statements to be executed before the thread
     * officially dies).  If a <code>catch</code> clause catches a
     * <code>ThreadDeath</code> object, it is important to rethrow the
     * object so that the thread actually dies.
     * <p>
     * The top-level error handler that reacts to otherwise uncaught
     * exceptions does not print out a message or otherwise notify the
     * application if the uncaught exception is an instance of
     * <code>ThreadDeath</code>.
     *
     * @@exception  SecurityException  if the current thread cannot
     *               modify this thread.
     * @@see        #interrupt()
     * @@see        #checkAccess()
     * @@see        #run()
     * @@see        #start()
     * @@see        ThreadDeath
     * @@see        ThreadGroup#uncaughtException(Thread,Throwable)
     * @@see        SecurityManager#checkAccess(Thread)
     * @@see        SecurityManager#checkPermission
     * @@deprecated This method is inherently unsafe.  Stopping a thread with
     *       Thread.stop causes it to unlock all of the monitors that it
     *       has locked (as a natural consequence of the unchecked
     *       <code>ThreadDeath</code> exception propagating up the stack).  If
     *       any of the objects previously protected by these monitors were in
     *       an inconsistent state, the damaged objects become visible to
     *       other threads, potentially resulting in arbitrary behavior.  Many
     *       uses of <code>stop</code> should be replaced by code that simply
     *       modifies some variable to indicate that the target thread should
     *       stop running.  The target thread should check this variable
     *       regularly, and return from its run method in an orderly fashion
     *       if the variable indicates that it is to stop running.  If the
     *       target thread waits for long periods (on a condition variable,
     *       for example), the <code>interrupt</code> method should be used to
     *       interrupt the wait.
     *       For more information, see
     *       <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why
     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.
     */
    @@Deprecated
    public final void stop() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            checkAccess();
            if (this != Thread.currentThread()) {
                security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);
            }
        }
        // A zero status value corresponds to "NEW", it can't change to
        // not-NEW because we hold the lock.
        if (threadStatus != 0) {
            resume(); // Wake up thread if it was suspended; no-op otherwise
        }

        // The VM can handle all thread states
        stop0(new ThreadDeath());
    }

    /**
     * Throws {@@code UnsupportedOperationException}.
     *
     * @@param obj ignored
     *
     * @@deprecated This method was originally designed to force a thread to stop
     *        and throw a given {@@code Throwable} as an exception. It was
     *        inherently unsafe (see {@@link #stop()} for details), and furthermore
     *        could be used to generate exceptions that the target thread was
     *        not prepared to handle.
     *        For more information, see
     *        <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why
     *        are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.
     */
    @@Deprecated
    public final synchronized void stop(Throwable obj) {
        throw new UnsupportedOperationException();
    }

    /**
     * Interrupts this thread.
     *
     * <p> Unless the current thread is interrupting itself, which is
     * always permitted, the {@@link #checkAccess() checkAccess} method
     * of this thread is invoked, which may cause a {@@link
     * SecurityException} to be thrown.
     *
     * <p> If this thread is blocked in an invocation of the {@@link
     * Object#wait() wait()}, {@@link Object#wait(long) wait(long)}, or {@@link
     * Object#wait(long, int) wait(long, int)} methods of the {@@link Object}
     * class, or of the {@@link #join()}, {@@link #join(long)}, {@@link
     * #join(long, int)}, {@@link #sleep(long)}, or {@@link #sleep(long, int)},
     * methods of this class, then its interrupt status will be cleared and it
     * will receive an {@@link InterruptedException}.
     *
     * <p> If this thread is blocked in an I/O operation upon an {@@link
     * java.nio.channels.InterruptibleChannel InterruptibleChannel}
     * then the channel will be closed, the thread's interrupt
     * status will be set, and the thread will receive a {@@link
     * java.nio.channels.ClosedByInterruptException}.
     *
     * <p> If this thread is blocked in a {@@link java.nio.channels.Selector}
     * then the thread's interrupt status will be set and it will return
     * immediately from the selection operation, possibly with a non-zero
     * value, just as if the selector's {@@link
     * java.nio.channels.Selector#wakeup wakeup} method were invoked.
     *
     * <p> If none of the previous conditions hold then this thread's interrupt
     * status will be set. </p>
     *
     * <p> Interrupting a thread that is not alive need not have any effect.
     *
     * @@throws  SecurityException
     *          if the current thread cannot modify this thread
     *
     * @@revised 6.0
     * @@spec JSR-51
     */
    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }

    /**
     * Tests whether the current thread has been interrupted.  The
     * <i>interrupted status</i> of the thread is cleared by this method.  In
     * other words, if this method were to be called twice in succession, the
     * second call would return false (unless the current thread were
     * interrupted again, after the first call had cleared its interrupted
     * status and before the second call had examined it).
     *
     * <p>A thread interruption ignored because a thread was not alive
     * at the time of the interrupt will be reflected by this method
     * returning false.
     *
     * @@return  <code>true</code> if the current thread has been interrupted;
     *          <code>false</code> otherwise.
     * @@see #isInterrupted()
     * @@revised 6.0
     */
    public static boolean interrupted() {
        Thread current = currentThread();
        if (!current.interruptPending) {
            return false;
        }
        current.interruptPending = false;
        return true;
    }

    /**
     * Tests whether this thread has been interrupted.  The <i>interrupted
     * status</i> of the thread is unaffected by this method.
     *
     * <p>A thread interruption ignored because a thread was not alive
     * at the time of the interrupt will be reflected by this method
     * returning false.
     *
     * @@return  <code>true</code> if this thread has been interrupted;
     *          <code>false</code> otherwise.
     * @@see     #interrupted()
     * @@revised 6.0
     */
    public boolean isInterrupted() {
        return interruptPending;
    }

    /**
     * Throws {@@link NoSuchMethodError}.
     *
     * @@deprecated This method was originally designed to destroy this
     *     thread without any cleanup. Any monitors it held would have
     *     remained locked. However, the method was never implemented.
     *     If if were to be implemented, it would be deadlock-prone in
     *     much the manner of {@@link #suspend}. If the target thread held
     *     a lock protecting a critical system resource when it was
     *     destroyed, no thread could ever access this resource again.
     *     If another thread ever attempted to lock this resource, deadlock
     *     would result. Such deadlocks typically manifest themselves as
     *     "frozen" processes. For more information, see
     *     <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">
     *     Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.
     * @@throws NoSuchMethodError always
     */
    @@Deprecated
    public void destroy() {
        throw new NoSuchMethodError();
    }

    /**
     * Tests if this thread is alive. A thread is alive if it has
     * been started and has not yet died.
     *
     * @@return  <code>true</code> if this thread is alive;
     *          <code>false</code> otherwise.
     */
    public final boolean isAlive() {
        return (threadStatus & 0x0001) != 0;
    }

    /**
     * Suspends this thread.
     * <p>
     * First, the <code>checkAccess</code> method of this thread is called
     * with no arguments. This may result in throwing a
     * <code>SecurityException </code>(in the current thread).
     * <p>
     * If the thread is alive, it is suspended and makes no further
     * progress unless and until it is resumed.
     *
     * @@exception  SecurityException  if the current thread cannot modify
     *               this thread.
     * @@see #checkAccess
     * @@deprecated   This method has been deprecated, as it is
     *   inherently deadlock-prone.  If the target thread holds a lock on the
     *   monitor protecting a critical system resource when it is suspended, no
     *   thread can access this resource until the target thread is resumed. If
     *   the thread that would resume the target thread attempts to lock this
     *   monitor prior to calling <code>resume</code>, deadlock results.  Such
     *   deadlocks typically manifest themselves as "frozen" processes.
     *   For more information, see
     *   <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why
     *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.
     */
    @@Deprecated
    public final void suspend() {
        checkAccess();
        suspend0();
    }

    /**
     * Resumes a suspended thread.
     * <p>
     * First, the <code>checkAccess</code> method of this thread is called
     * with no arguments. This may result in throwing a
     * <code>SecurityException</code> (in the current thread).
     * <p>
     * If the thread is alive but suspended, it is resumed and is
     * permitted to make progress in its execution.
     *
     * @@exception  SecurityException  if the current thread cannot modify this
     *               thread.
     * @@see        #checkAccess
     * @@see        #suspend()
     * @@deprecated This method exists solely for use with {@@link #suspend},
     *     which has been deprecated because it is deadlock-prone.
     *     For more information, see
     *     <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why
     *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.
     */
    @@Deprecated
    public final void resume() {
        checkAccess();
        resume0();
    }

    /**
     * Changes the priority of this thread.
     * <p>
     * First the <code>checkAccess</code> method of this thread is called
     * with no arguments. This may result in throwing a
     * <code>SecurityException</code>.
     * <p>
     * Otherwise, the priority of this thread is set to the smaller of
     * the specified <code>newPriority</code> and the maximum permitted
     * priority of the thread's thread group.
     *
     * @@param newPriority priority to set this thread to
     * @@exception  IllegalArgumentException  If the priority is not in the
     *               range <code>MIN_PRIORITY</code> to
     *               <code>MAX_PRIORITY</code>.
     * @@exception  SecurityException  if the current thread cannot modify
     *               this thread.
     * @@see        #getPriority
     * @@see        #checkAccess()
     * @@see        #getThreadGroup()
     * @@see        #MAX_PRIORITY
     * @@see        #MIN_PRIORITY
     * @@see        ThreadGroup#getMaxPriority()
     */
    public final void setPriority(int newPriority) {
        ThreadGroup g;
        checkAccess();
        if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
            throw new IllegalArgumentException();
        }
        if((g = getThreadGroup()) != null) {
            if (newPriority > g.getMaxPriority()) {
                newPriority = g.getMaxPriority();
            }
            setPriority0(priority = newPriority);
        }
    }

    /**
     * Returns this thread's priority.
     *
     * @@return  this thread's priority.
     * @@see     #setPriority
     */
    public final int getPriority() {
        return priority;
    }

    /**
     * Changes the name of this thread to be equal to the argument
     * <code>name</code>.
     * <p>
     * First the <code>checkAccess</code> method of this thread is called
     * with no arguments. This may result in throwing a
     * <code>SecurityException</code>.
     *
     * @@param      name   the new name for this thread.
     * @@exception  SecurityException  if the current thread cannot modify this
     *               thread.
     * @@see        #getName
     * @@see        #checkAccess()
     */
    public final synchronized void setName(String name) {
        checkAccess();
        this.name = name.toCharArray();
        if (threadStatus != 0) {
            setNativeName(name);
        }
    }

    /**
     * Returns this thread's name.
     *
     * @@return  this thread's name.
     * @@see     #setName(String)
     */
    public final String getName() {
        return String.valueOf(name);
    }

    /**
     * Returns the thread group to which this thread belongs.
     * This method returns null if this thread has died
     * (been stopped).
     *
     * @@return  this thread's thread group.
     */
    public final ThreadGroup getThreadGroup() {
        return group;
    }

    /**
     * Returns an estimate of the number of active threads in the current
     * thread's {@@linkplain java.lang.ThreadGroup thread group} and its
     * subgroups. Recursively iterates over all subgroups in the current
     * thread's thread group.
     *
     * <p> The value returned is only an estimate because the number of
     * threads may change dynamically while this method traverses internal
     * data structures, and might be affected by the presence of certain
     * system threads. This method is intended primarily for debugging
     * and monitoring purposes.
     *
     * @@return  an estimate of the number of active threads in the current
     *          thread's thread group and in any other thread group that
     *          has the current thread's thread group as an ancestor
     */
    public static int activeCount() {
        return currentThread().getThreadGroup().activeCount();
    }

    /**
     * Copies into the specified array every active thread in the current
     * thread's thread group and its subgroups. This method simply
     * invokes the {@@link java.lang.ThreadGroup#enumerate(Thread[])}
     * method of the current thread's thread group.
     *
     * <p> An application might use the {@@linkplain #activeCount activeCount}
     * method to get an estimate of how big the array should be, however
     * <i>if the array is too short to hold all the threads, the extra threads
     * are silently ignored.</i>  If it is critical to obtain every active
     * thread in the current thread's thread group and its subgroups, the
     * invoker should verify that the returned int value is strictly less
     * than the length of {@@code tarray}.
     *
     * <p> Due to the inherent race condition in this method, it is recommended
     * that the method only be used for debugging and monitoring purposes.
     *
     * @@param  tarray
     *         an array into which to put the list of threads
     *
     * @@return  the number of threads put into the array
     *
     * @@throws  SecurityException
     *          if {@@link java.lang.ThreadGroup#checkAccess} determines that
     *          the current thread cannot access its thread group
     */
    public static int enumerate(Thread tarray[]) {
        return currentThread().getThreadGroup().enumerate(tarray);
    }

    /**
     * Counts the number of stack frames in this thread. The thread must
     * be suspended.
     *
     * @@return     the number of stack frames in this thread.
     * @@exception  IllegalThreadStateException  if this thread is not
     *             suspended.
     * @@deprecated The definition of this call depends on {@@link #suspend},
     *             which is deprecated.  Further, the results of this call
     *             were never well-defined.
     */
    @@Deprecated
    public int countStackFrames() {
        return 0;
    }

    /**
     * Waits at most {@@code millis} milliseconds for this thread to
     * die. A timeout of {@@code 0} means to wait forever.
     *
     * <p> This implementation uses a loop of {@@code this.wait} calls
     * conditioned on {@@code this.isAlive}. As a thread terminates the
     * {@@code this.notifyAll} method is invoked. It is recommended that
     * applications not use {@@code wait}, {@@code notify}, or
     * {@@code notifyAll} on {@@code Thread} instances.
     *
     * @@param  millis
     *         the time to wait in milliseconds
     *
     * @@throws  IllegalArgumentException
     *          if the value of {@@code millis} is negative
     *
     * @@throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }

    /**
     * Waits at most {@@code millis} milliseconds plus
     * {@@code nanos} nanoseconds for this thread to die.
     *
     * <p> This implementation uses a loop of {@@code this.wait} calls
     * conditioned on {@@code this.isAlive}. As a thread terminates the
     * {@@code this.notifyAll} method is invoked. It is recommended that
     * applications not use {@@code wait}, {@@code notify}, or
     * {@@code notifyAll} on {@@code Thread} instances.
     *
     * @@param  millis
     *         the time to wait in milliseconds
     *
     * @@param  nanos
     *         {@@code 0-999999} additional nanoseconds to wait
     *
     * @@throws  IllegalArgumentException
     *          if the value of {@@code millis} is negative, or the value
     *          of {@@code nanos} is not in the range {@@code 0-999999}
     *
     * @@throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public final synchronized void join(long millis, int nanos)
    throws InterruptedException {

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }

        if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
            millis++;
        }

        join(millis);
    }

    /**
     * Waits for this thread to die.
     *
     * <p> An invocation of this method behaves in exactly the same
     * way as the invocation
     *
     * <blockquote>
     * {@@linkplain #join(long) join}{@@code (0)}
     * </blockquote>
     *
     * @@throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public final void join() throws InterruptedException {
        join(0);
    }

    /**
     * Prints a stack trace of the current thread to the standard error stream.
     * This method is used only for debugging.
     *
     * @@see     Throwable#printStackTrace()
     */
    public static void dumpStack() {
        new Exception("Stack trace").printStackTrace();
    }

    /**
     * Marks this thread as either a {@@linkplain #isDaemon daemon} thread
     * or a user thread. The Java Virtual Machine exits when the only
     * threads running are all daemon threads.
     *
     * <p> This method must be invoked before the thread is started.
     *
     * @@param  on
     *         if {@@code true}, marks this thread as a daemon thread
     *
     * @@throws  IllegalThreadStateException
     *          if this thread is {@@linkplain #isAlive alive}
     *
     * @@throws  SecurityException
     *          if {@@link #checkAccess} determines that the current
     *          thread cannot modify this thread
     */
    public final void setDaemon(boolean on) {
        checkAccess();
        if (isAlive()) {
            throw new IllegalThreadStateException();
        }
        daemon = on;
    }

    /**
     * Tests if this thread is a daemon thread.
     *
     * @@return  <code>true</code> if this thread is a daemon thread;
     *          <code>false</code> otherwise.
     * @@see     #setDaemon(boolean)
     */
    public final boolean isDaemon() {
        return daemon;
    }

    /**
     * Determines if the currently running thread has permission to
     * modify this thread.
     * <p>
     * If there is a security manager, its <code>checkAccess</code> method
     * is called with this thread as its argument. This may result in
     * throwing a <code>SecurityException</code>.
     *
     * @@exception  SecurityException  if the current thread is not allowed to
     *               access this thread.
     * @@see        SecurityManager#checkAccess(Thread)
     */
    public final void checkAccess() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkAccess(this);
        }
    }

    /**
     * Returns a string representation of this thread, including the
     * thread's name, priority, and thread group.
     *
     * @@return  a string representation of this thread.
     */
    public String toString() {
        ThreadGroup group = getThreadGroup();
        if (group != null) {
            return "Thread[" + getName() + "," + getPriority() + "," +
                           group.getName() + "]";
        } else {
            return "Thread[" + getName() + "," + getPriority() + "," +
                            "" + "]";
        }
    }

    /**
     * Returns the context ClassLoader for this Thread. The context
     * ClassLoader is provided by the creator of the thread for use
     * by code running in this thread when loading classes and resources.
     * If not {@@linkplain #setContextClassLoader set}, the default is the
     * ClassLoader context of the parent Thread. The context ClassLoader of the
     * primordial thread is typically set to the class loader used to load the
     * application.
     *
     * <p>If a security manager is present, and the invoker's class loader is not
     * {@@code null} and is not the same as or an ancestor of the context class
     * loader, then this method invokes the security manager's {@@link
     * SecurityManager#checkPermission(java.security.Permission) checkPermission}
     * method with a {@@link RuntimePermission RuntimePermission}{@@code
     * ("getClassLoader")} permission to verify that retrieval of the context
     * class loader is permitted.
     *
     * @@return  the context ClassLoader for this Thread, or {@@code null}
     *          indicating the system class loader (or, failing that, the
     *          bootstrap class loader)
     *
     * @@throws  SecurityException
     *          if the current thread cannot get the context ClassLoader
     *
     * @@since 1.2
     */
    @@CallerSensitive
    public ClassLoader getContextClassLoader() {
        if (contextClassLoader == ClassLoader.DUMMY) {
            contextClassLoader = ClassLoader.getSystemClassLoader();
        }
        if (contextClassLoader == null)
            return null;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            ClassLoader.checkClassLoaderPermission(contextClassLoader,
                                                   Reflection.getCallerClass());
        }
        return contextClassLoader;
    }

    /**
     * Sets the context ClassLoader for this Thread. The context
     * ClassLoader can be set when a thread is created, and allows
     * the creator of the thread to provide the appropriate class loader,
     * through {@@code getContextClassLoader}, to code running in the thread
     * when loading classes and resources.
     *
     * <p>If a security manager is present, its {@@link
     * SecurityManager#checkPermission(java.security.Permission) checkPermission}
     * method is invoked with a {@@link RuntimePermission RuntimePermission}{@@code
     * ("setContextClassLoader")} permission to see if setting the context
     * ClassLoader is permitted.
     *
     * @@param  cl
     *         the context ClassLoader for this Thread, or null  indicating the
     *         system class loader (or, failing that, the bootstrap class loader)
     *
     * @@throws  SecurityException
     *          if the current thread cannot set the context ClassLoader
     *
     * @@since 1.2
     */
    public void setContextClassLoader(ClassLoader cl) {
        if (cl == ClassLoader.DUMMY) {
            // we're being called by Thread.<clinit> to force this method to be JIT compiled
            return;
        }
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new RuntimePermission("setContextClassLoader"));
        }
        contextClassLoader = cl;
    }

    // [IKVM] called by sun.misc.Launcher (via map.xml patch) to initialize the context class loader
    final void initContextClassLoader(ClassLoader cl) {
        // we only set contextClassLoader if it hasn't been set (by user code) previously
        casContextClassLoader(ClassLoader.DUMMY, cl);
    }
    
    @@ikvm.internal.InterlockedCompareAndSet("contextClassLoader")
    private native boolean casContextClassLoader(ClassLoader oldValue, ClassLoader newValue);

    /**
     * Returns <tt>true</tt> if and only if the current thread holds the
     * monitor lock on the specified object.
     *
     * <p>This method is designed to allow a program to assert that
     * the current thread already holds a specified lock:
     * <pre>
     *     assert Thread.holdsLock(obj);
     * </pre>
     *
     * @@param  obj the object on which to test lock ownership
     * @@throws NullPointerException if obj is <tt>null</tt>
     * @@return <tt>true</tt> if the current thread holds the monitor lock on
     *         the specified object.
     * @@since 1.4
     */
    public static boolean holdsLock(Object obj) {
        if (obj == null) {
            throw new NullPointerException();
        }
        try {
            if (false) throw new cli.System.Threading.SynchronizationLockException();
            // The 1.5 memory model (JSR133) explicitly allows spurious wake-ups from Object.wait,
            // so we abuse Pulse to check if we own the monitor.
            cli.System.Threading.Monitor.Pulse(obj);
            return true;
        }
        catch (cli.System.Threading.SynchronizationLockException _) {
            return false;
        }
    }

    private static final StackTraceElement[] EMPTY_STACK_TRACE
        = new StackTraceElement[0];

    /**
     * Returns an array of stack trace elements representing the stack dump
     * of this thread.  This method will return a zero-length array if
     * this thread has not started, has started but has not yet been
     * scheduled to run by the system, or has terminated.
     * If the returned array is of non-zero length then the first element of
     * the array represents the top of the stack, which is the most recent
     * method invocation in the sequence.  The last element of the array
     * represents the bottom of the stack, which is the least recent method
     * invocation in the sequence.
     *
     * <p>If there is a security manager, and this thread is not
     * the current thread, then the security manager's
     * <tt>checkPermission</tt> method is called with a
     * <tt>RuntimePermission("getStackTrace")</tt> permission
     * to see if it's ok to get the stack trace.
     *
     * <p>Some virtual machines may, under some circumstances, omit one
     * or more stack frames from the stack trace.  In the extreme case,
     * a virtual machine that has no stack trace information concerning
     * this thread is permitted to return a zero-length array from this
     * method.
     *
     * @@return an array of <tt>StackTraceElement</tt>,
     * each represents one stack frame.
     *
     * @@throws SecurityException
     *        if a security manager exists and its
     *        <tt>checkPermission</tt> method doesn't allow
     *        getting the stack trace of thread.
     * @@see SecurityManager#checkPermission
     * @@see RuntimePermission
     * @@see Throwable#getStackTrace
     *
     * @@since 1.5
     */
    public StackTraceElement[] getStackTrace() {
        if (this != Thread.currentThread()) {
            // check for getStackTrace permission
            SecurityManager security = System.getSecurityManager();
            if (security != null) {
                security.checkPermission(
                    SecurityConstants.GET_STACK_TRACE_PERMISSION);
            }
            // optimization so we do not call into the vm for threads that
            // have not yet started or have terminated
            if (!isAlive()) {
                return EMPTY_STACK_TRACE;
            }
            StackTraceElement[][] stackTraceArray = dumpThreads(new Thread[] {this});
            StackTraceElement[] stackTrace = stackTraceArray[0];
            // a thread that was alive during the previous isAlive call may have
            // since terminated, therefore not having a stacktrace.
            if (stackTrace == null) {
                stackTrace = EMPTY_STACK_TRACE;
            }
            return stackTrace;
        } else {
            // Don't need JVM help for current thread
            return (new Exception()).getStackTrace();
        }
    }

    /**
     * Returns a map of stack traces for all live threads.
     * The map keys are threads and each map value is an array of
     * <tt>StackTraceElement</tt> that represents the stack dump
     * of the corresponding <tt>Thread</tt>.
     * The returned stack traces are in the format specified for
     * the {@@link #getStackTrace getStackTrace} method.
     *
     * <p>The threads may be executing while this method is called.
     * The stack trace of each thread only represents a snapshot and
     * each stack trace may be obtained at different time.  A zero-length
     * array will be returned in the map value if the virtual machine has
     * no stack trace information about a thread.
     *
     * <p>If there is a security manager, then the security manager's
     * <tt>checkPermission</tt> method is called with a
     * <tt>RuntimePermission("getStackTrace")</tt> permission as well as
     * <tt>RuntimePermission("modifyThreadGroup")</tt> permission
     * to see if it is ok to get the stack trace of all threads.
     *
     * @@return a <tt>Map</tt> from <tt>Thread</tt> to an array of
     * <tt>StackTraceElement</tt> that represents the stack trace of
     * the corresponding thread.
     *
     * @@throws SecurityException
     *        if a security manager exists and its
     *        <tt>checkPermission</tt> method doesn't allow
     *        getting the stack trace of thread.
     * @@see #getStackTrace
     * @@see SecurityManager#checkPermission
     * @@see RuntimePermission
     * @@see Throwable#getStackTrace
     *
     * @@since 1.5
     */
    public static Map<Thread, StackTraceElement[]> getAllStackTraces() {
        // check for getStackTrace permission
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkPermission(
                SecurityConstants.GET_STACK_TRACE_PERMISSION);
            security.checkPermission(
                SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
        }

        // Get a snapshot of the list of all threads
        Thread[] threads = getThreads();
        StackTraceElement[][] traces = dumpThreads(threads);
        Map<Thread, StackTraceElement[]> m = new HashMap<>(threads.length);
        for (int i = 0; i < threads.length; i++) {
            StackTraceElement[] stackTrace = traces[i];
            if (stackTrace != null) {
                m.put(threads[i], stackTrace);
            }
            // else terminated so we don't put it in the map
        }
        return m;
    }


    private static final RuntimePermission SUBCLASS_IMPLEMENTATION_PERMISSION =
                    new RuntimePermission("enableContextClassLoaderOverride");

    /** cache of subclass security audit results */
    /* Replace with ConcurrentReferenceHashMap when/if it appears in a future
     * release */
    private static class Caches {
        /** cache of subclass security audit results */
        static final ConcurrentMap<WeakClassKey,Boolean> subclassAudits =
            new ConcurrentHashMap<>();

        /** queue for WeakReferences to audited subclasses */
        static final ReferenceQueue<Class<?>> subclassAuditsQueue =
            new ReferenceQueue<>();
    }

    /**
     * Verifies that this (possibly subclass) instance can be constructed
     * without violating security constraints: the subclass must not override
     * security-sensitive non-final methods, or else the
     * "enableContextClassLoaderOverride" RuntimePermission is checked.
     */
    @@cli.System.Runtime.CompilerServices.MethodImplAttribute.Annotation(value = cli.System.Runtime.CompilerServices.MethodImplOptions.__Enum.NoInlining)
    private static native boolean isCCLOverridden(Thread thread); // [IKVM] implemented in map.xml

    private static boolean isCCLOverridden(Class<?> cl) {
        if (cl == Thread.class)
            return false;

        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
        Boolean result = Caches.subclassAudits.get(key);
        if (result == null) {
            result = Boolean.valueOf(auditSubclass(cl));
            Caches.subclassAudits.putIfAbsent(key, result);
        }

        return result.booleanValue();
    }

    /**
     * Performs reflective checks on given subclass to verify that it doesn't
     * override security-sensitive non-final methods.  Returns true if the
     * subclass overrides any of the methods, false otherwise.
     */
    private static boolean auditSubclass(final Class<?> subcl) {
        Boolean result = AccessController.doPrivileged(
            new PrivilegedAction<Boolean>() {
                public Boolean run() {
                    for (Class<?> cl = subcl;
                         cl != Thread.class;
                         cl = cl.getSuperclass())
                    {
                        try {
                            cl.getDeclaredMethod("getContextClassLoader", new Class<?>[0]);
                            return Boolean.TRUE;
                        } catch (NoSuchMethodException ex) {
                        }
                        try {
                            Class<?>[] params = {ClassLoader.class};
                            cl.getDeclaredMethod("setContextClassLoader", params);
                            return Boolean.TRUE;
                        } catch (NoSuchMethodException ex) {
                        }
                    }
                    return Boolean.FALSE;
                }
            }
        );
        return result.booleanValue();
    }

    private static StackTraceElement[][] dumpThreads(Thread[] threads) {
        StackTraceElement[][] stacks = new StackTraceElement[threads.length][];
        for (int i = 0; i < threads.length; i++) {
            cli.System.Threading.Thread nativeThread = threads[i].nativeThread;
            if (nativeThread == null) {
                stacks[i] = new StackTraceElement[0];
            } else {
                try {
                    if (false) throw new cli.System.Threading.ThreadStateException();
                    boolean suspended = false;
                    if ((nativeThread.get_ThreadState().Value & cli.System.Threading.ThreadState.Suspended) == 0 && nativeThread != cli.System.Threading.Thread.get_CurrentThread()) {
                        suspended = true;
                        nativeThread.Suspend();
                    }
                    cli.System.Diagnostics.StackTrace stack;
                    try {
                        stack = new cli.System.Diagnostics.StackTrace(nativeThread, true);
                    }
                    finally {
                        if (suspended) {
                            nativeThread.Resume();
                        }
                    }
                    stacks[i] = getStackTrace(stack);
                }
                catch (cli.System.Threading.ThreadStateException _) {
                    stacks[i] = new StackTraceElement[0];
                }
            }
        }
        return stacks;
    }
    
    private static native StackTraceElement[] getStackTrace(cli.System.Diagnostics.StackTrace stack);

    private static native Thread[] getThreads();

    /**
     * Returns the identifier of this Thread.  The thread ID is a positive
     * <tt>long</tt> number generated when this thread was created.
     * The thread ID is unique and remains unchanged during its lifetime.
     * When a thread is terminated, this thread ID may be reused.
     *
     * @@return this thread's ID.
     * @@since 1.5
     */
    public long getId() {
        return tid;
    }

    /**
     * A thread state.  A thread can be in one of the following states:
     * <ul>
     * <li>{@@link #NEW}<br>
     *     A thread that has not yet started is in this state.
     *     </li>
     * <li>{@@link #RUNNABLE}<br>
     *     A thread executing in the Java virtual machine is in this state.
     *     </li>
     * <li>{@@link #BLOCKED}<br>
     *     A thread that is blocked waiting for a monitor lock
     *     is in this state.
     *     </li>
     * <li>{@@link #WAITING}<br>
     *     A thread that is waiting indefinitely for another thread to
     *     perform a particular action is in this state.
     *     </li>
     * <li>{@@link #TIMED_WAITING}<br>
     *     A thread that is waiting for another thread to perform an action
     *     for up to a specified waiting time is in this state.
     *     </li>
     * <li>{@@link #TERMINATED}<br>
     *     A thread that has exited is in this state.
     *     </li>
     * </ul>
     *
     * <p>
     * A thread can be in only one state at a given point in time.
     * These states are virtual machine states which do not reflect
     * any operating system thread states.
     *
     * @@since   1.5
     * @@see #getState
     */
    public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@@link #join() Thread.join} with no timeout</li>
         *   <li>{@@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@@link #sleep Thread.sleep}</li>
         *   <li>{@@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@@link #join(long) Thread.join} with timeout</li>
         *   <li>{@@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }

    /**
     * Returns the state of this thread.
     * This method is designed for use in monitoring of the system state,
     * not for synchronization control.
     *
     * @@return this thread's state.
     * @@since 1.5
     */
    public State getState() {
        // get current thread state
        switch (threadStatus) {
            case 0:
                return State.NEW;
            case 0x0002:
                return State.TERMINATED;
        }
        synchronized (lock) {
            if (interruptableWait) {
                // NOTE if objectWait has satisfied the wait condition (or has been interrupted or has timed-out),
                // it can be blocking on the re-acquire of the monitor, but we have no way of detecting that.
                return timedWait ? State.TIMED_WAITING : State.WAITING;
            }
        }
        cli.System.Threading.Thread nativeThread = this.nativeThread;
        if (nativeThread == null) {
            return State.TERMINATED;
        }
        if ((nativeThread.get_ThreadState().Value & cli.System.Threading.ThreadState.WaitSleepJoin) != 0) {
            return State.BLOCKED;
        }
        return State.RUNNABLE;
    }

    // Added in JSR-166

    /**
     * Interface for handlers invoked when a <tt>Thread</tt> abruptly
     * terminates due to an uncaught exception.
     * <p>When a thread is about to terminate due to an uncaught exception
     * the Java Virtual Machine will query the thread for its
     * <tt>UncaughtExceptionHandler</tt> using
     * {@@link #getUncaughtExceptionHandler} and will invoke the handler's
     * <tt>uncaughtException</tt> method, passing the thread and the
     * exception as arguments.
     * If a thread has not had its <tt>UncaughtExceptionHandler</tt>
     * explicitly set, then its <tt>ThreadGroup</tt> object acts as its
     * <tt>UncaughtExceptionHandler</tt>. If the <tt>ThreadGroup</tt> object
     * has no
     * special requirements for dealing with the exception, it can forward
     * the invocation to the {@@linkplain #getDefaultUncaughtExceptionHandler
     * default uncaught exception handler}.
     *
     * @@see #setDefaultUncaughtExceptionHandler
     * @@see #setUncaughtExceptionHandler
     * @@see ThreadGroup#uncaughtException
     * @@since 1.5
     */
    @@FunctionalInterface
    public interface UncaughtExceptionHandler {
        /**
         * Method invoked when the given thread terminates due to the
         * given uncaught exception.
         * <p>Any exception thrown by this method will be ignored by the
         * Java Virtual Machine.
         * @@param t the thread
         * @@param e the exception
         */
        void uncaughtException(Thread t, Throwable e);
    }

    // null unless explicitly set
    private volatile UncaughtExceptionHandler uncaughtExceptionHandler;

    // null unless explicitly set
    private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;

    /**
     * Set the default handler invoked when a thread abruptly terminates
     * due to an uncaught exception, and no other handler has been defined
     * for that thread.
     *
     * <p>Uncaught exception handling is controlled first by the thread, then
     * by the thread's {@@link ThreadGroup} object and finally by the default
     * uncaught exception handler. If the thread does not have an explicit
     * uncaught exception handler set, and the thread's thread group
     * (including parent thread groups)  does not specialize its
     * <tt>uncaughtException</tt> method, then the default handler's
     * <tt>uncaughtException</tt> method will be invoked.
     * <p>By setting the default uncaught exception handler, an application
     * can change the way in which uncaught exceptions are handled (such as
     * logging to a specific device, or file) for those threads that would
     * already accept whatever &quot;default&quot; behavior the system
     * provided.
     *
     * <p>Note that the default uncaught exception handler should not usually
     * defer to the thread's <tt>ThreadGroup</tt> object, as that could cause
     * infinite recursion.
     *
     * @@param eh the object to use as the default uncaught exception handler.
     * If <tt>null</tt> then there is no default handler.
     *
     * @@throws SecurityException if a security manager is present and it
     *         denies <tt>{@@link RuntimePermission}
     *         (&quot;setDefaultUncaughtExceptionHandler&quot;)</tt>
     *
     * @@see #setUncaughtExceptionHandler
     * @@see #getUncaughtExceptionHandler
     * @@see ThreadGroup#uncaughtException
     * @@since 1.5
     */
    public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(
                new RuntimePermission("setDefaultUncaughtExceptionHandler")
                    );
        }

         defaultUncaughtExceptionHandler = eh;
     }

    /**
     * Returns the default handler invoked when a thread abruptly terminates
     * due to an uncaught exception. If the returned value is <tt>null</tt>,
     * there is no default.
     * @@since 1.5
     * @@see #setDefaultUncaughtExceptionHandler
     * @@return the default uncaught exception handler for all threads
     */
    public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler(){
        return defaultUncaughtExceptionHandler;
    }

    /**
     * Returns the handler invoked when this thread abruptly terminates
     * due to an uncaught exception. If this thread has not had an
     * uncaught exception handler explicitly set then this thread's
     * <tt>ThreadGroup</tt> object is returned, unless this thread
     * has terminated, in which case <tt>null</tt> is returned.
     * @@since 1.5
     * @@return the uncaught exception handler for this thread
     */
    public UncaughtExceptionHandler getUncaughtExceptionHandler() {
        return uncaughtExceptionHandler != null ?
            uncaughtExceptionHandler : group;
    }

    /**
     * Set the handler invoked when this thread abruptly terminates
     * due to an uncaught exception.
     * <p>A thread can take full control of how it responds to uncaught
     * exceptions by having its uncaught exception handler explicitly set.
     * If no such handler is set then the thread's <tt>ThreadGroup</tt>
     * object acts as its handler.
     * @@param eh the object to use as this thread's uncaught exception
     * handler. If <tt>null</tt> then this thread has no explicit handler.
     * @@throws  SecurityException  if the current thread is not allowed to
     *          modify this thread.
     * @@see #setDefaultUncaughtExceptionHandler
     * @@see ThreadGroup#uncaughtException
     * @@since 1.5
     */
    public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
        checkAccess();
        uncaughtExceptionHandler = eh;
    }

    /**
     * Dispatch an uncaught exception to the handler. This method is
     * intended to be called only by the JVM.
     */
    private void dispatchUncaughtException(Throwable e) {
        getUncaughtExceptionHandler().uncaughtException(this, e);
    }

    /**
     * Removes from the specified map any keys that have been enqueued
     * on the specified reference queue.
     */
    static void processQueue(ReferenceQueue<Class<?>> queue,
                             ConcurrentMap<? extends
                             WeakReference<Class<?>>, ?> map)
    {
        Reference<? extends Class<?>> ref;
        while((ref = queue.poll()) != null) {
            map.remove(ref);
        }
    }

    /**
     *  Weak key for Class objects.
     **/
    static class WeakClassKey extends WeakReference<Class<?>> {
        /**
         * saved value of the referent's identity hash code, to maintain
         * a consistent hash code after the referent has been cleared
         */
        private final int hash;

        /**
         * Create a new WeakClassKey to the given object, registered
         * with a queue.
         */
        WeakClassKey(Class<?> cl, ReferenceQueue<Class<?>> refQueue) {
            super(cl, refQueue);
            hash = System.identityHashCode(cl);
        }

        /**
         * Returns the identity hash code of the original referent.
         */
        @@Override
        public int hashCode() {
            return hash;
        }

        /**
         * Returns true if the given object is this identical
         * WeakClassKey instance, or, if this object's referent has not
         * been cleared, if the given object is another WeakClassKey
         * instance with the identical non-null referent as this one.
         */
        @@Override
        public boolean equals(Object obj) {
            if (obj == this)
                return true;

            if (obj instanceof WeakClassKey) {
                Object referent = get();
                return (referent != null) &&
                       (referent == ((WeakClassKey) obj).get());
            } else {
                return false;
            }
        }
    }


    // The following three initially uninitialized fields are exclusively
    // managed by class java.util.concurrent.ThreadLocalRandom. These
    // fields are used to build the high-performance PRNGs in the
    // concurrent code, and we can not risk accidental false sharing.
    // Hence, the fields are isolated with @@Contended.

    /** The current seed for a ThreadLocalRandom */
    @@sun.misc.Contended("tlr")
    long threadLocalRandomSeed;

    /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
    @@sun.misc.Contended("tlr")
    @@ikvm.lang.Internal // [IKVM] accessed from java.util.concurrent.atomic.Striped64
    public int threadLocalRandomProbe;

    /** Secondary seed isolated from public ThreadLocalRandom sequence */
    @@sun.misc.Contended("tlr")
    @@ikvm.lang.Internal // [IKVM] accessed from java.util.concurrent.locks.LockSupport
    public int threadLocalRandomSecondarySeed;

    /* Some private helper methods */
    private synchronized void setPriority0(int newPriority) {
        cli.System.Threading.Thread nativeThread = this.nativeThread;
        if (nativeThread != null) {
            try {
                if (false) throw new cli.System.Threading.ThreadStateException();
                nativeThread.set_Priority(cli.System.Threading.ThreadPriority.wrap(mapJavaPriorityToClr(newPriority)));
            }
            catch (cli.System.Threading.ThreadStateException _) {
            }
        }
    }

    private void stop0(Throwable x) {
        synchronized (lock) {
            if (!running) {
                stillborn = x;
                x = null;
            }
        }
        if (x != null) {
            // NOTE we allow ThreadDeath (and its subclasses) to be thrown on every thread, but any
            // other exception is ignored, except if we're throwing it on the current Thread. This
            // is done to allow exception handlers to be type specific, otherwise every exception
            // handler would have to catch ThreadAbortException and look inside it to see if it
            // contains the real exception that we wish to handle.
            // I hope we can get away with this behavior, because Thread.stop() is deprecated
            // anyway. Note that we do allow arbitrary exceptions to be thrown on the current
            // thread, since this is harmless (because they aren't wrapped) and also because it
            // provides some real value, because it is one of the ways you can throw arbitrary checked
            // exceptions from Java.
            if (this == current) {
                sun.misc.Unsafe.getUnsafe().throwException(x);
            }
            else if (x instanceof ThreadDeath) {
                cli.System.Threading.Thread nativeThread = this.nativeThread;
                if (nativeThread == null) {
                    return;
                }
                try {
                    if (false) throw new cli.System.Threading.ThreadStateException();
                    nativeThread.Abort(x);
                }
                catch (cli.System.Threading.ThreadStateException _) {
                    // .NET 2.0 throws a ThreadStateException if the target thread is currently suspended
                    // (but it does record the Abort request)
                }
                try {
                    if (false) throw new cli.System.Threading.ThreadStateException();
                    int suspend = cli.System.Threading.ThreadState.Suspended | cli.System.Threading.ThreadState.SuspendRequested;
                    while ((nativeThread.get_ThreadState().Value & suspend) != 0) {
                        nativeThread.Resume();
                    }
                }
                catch (cli.System.Threading.ThreadStateException _) {
                }
            }
        }
    }

    private void suspend0() {
        try {
            if (false) throw new cli.System.Threading.ThreadStateException();
            cli.System.Threading.Thread nativeThread = this.nativeThread;
            if (nativeThread != null) {
                nativeThread.Suspend();
            }
        }
        catch (cli.System.Threading.ThreadStateException _) {
        }
    }

    private void resume0() {
        try {
            if (false) throw new cli.System.Threading.ThreadStateException();
            cli.System.Threading.Thread nativeThread = this.nativeThread;
            if (nativeThread != null) {
                nativeThread.Resume();
            }
        }
        catch (cli.System.Threading.ThreadStateException _) {
        }
    }

    private void interrupt0() {
        synchronized (lock) {
            // if the thread hasn't been started yet or has been terminated, the interrupt is ignored
            // (like on the reference implementation)
            if (nativeThread == null) {
                return;
            }
            if (!interruptPending) {
                interruptPending = true;
                if (interruptableWait) {
                    nativeInterruptPending = true;
                    nativeThread.Interrupt();
                }
            }
        }
    }
    
    private void setRunningAndCheckStillborn() throws Throwable {
        Throwable x;
        synchronized (lock) {
            running = true;
            x = stillborn;
            stillborn = null;
        }
        if (x != null) {
            throw x;
        }
    }

    // [IKVM] this the entry point of thread started from Java
    @@cli.IKVM.Attributes.HideFromJavaAttribute.Annotation
    void threadProc() {
        current = this;
        try {
            // the body of the try block is in another method to allow the (limited) try/finally optimizer
            // to properly recognize the try/finally block, because we want to make sure that die()
            // runs in a finally block to prevent it from being asynchronously aborted.
            threadProc2();
        }
        finally {
            die();
        }
    }
    
    @@cli.IKVM.Attributes.HideFromJavaAttribute.Annotation
    private void threadProc2() {
        try {
            setRunningAndCheckStillborn();
            run();
        }
        catch (Throwable x) {
            try {
                getUncaughtExceptionHandler().uncaughtException(this, x);
            }
            catch (Throwable _) {
            }
        }
    }

    // [IKVM] this the implementation of Object.wait(long timeout, int nanos). It is hooked up in map.xml.
    static void objectWait(Object o, long timeout, int nanos) throws InterruptedException {
        if (o == null) {
            throw new NullPointerException();
        }
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException("nanosecond timeout value out of range");
        }
        if (nanos >= 500000 || (nanos != 0 && timeout == 0)) {
            timeout++;
        }
        objectWait(o, timeout);
    }

    // [IKVM] this the implementation of Object.wait(long timeout). It is hooked up in map.xml.
    static void objectWait(Object o, long timeout) throws InterruptedException {
        if (o == null) {
            throw new NullPointerException();
        }
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
        Thread t = currentThread();
        t.enterInterruptableWait(timeout != 0);
        try {
            if (false) throw new cli.System.Threading.ThreadInterruptedException();
            if (timeout == 0 || timeout > 922337203685476L) {
                cli.System.Threading.Monitor.Wait(o);
            }
            else {
                // We wait a maximum of Integer.MAX_VALUE milliseconds, because that is the maximum that Monitor.Wait will wait.
                // Note that the Object.wait() specification allows for spurious wakeups, so this isn't a problem. Trying to
                // emulate a longer wait with multiple Monitor.Wait() calls is not allowed, because that would mean that
                // we acquire and release the synchronization lock multiple times during the wait.
                cli.System.Threading.Monitor.Wait(o, (int)Math.min(timeout, Integer.MAX_VALUE));
            }
        }
        catch (cli.System.Threading.ThreadInterruptedException _) {
        }
        finally {
            t.leaveInterruptableWait();
        }
    }

    private void setNativeName(String name) {
        cli.System.Threading.Thread thread = nativeThread;
        if (thread != null) {
            try {
                if (false) throw new cli.System.InvalidOperationException();
                thread.set_Name(name);
            } catch (cli.System.InvalidOperationException _) {
            }
        }
    }
}
@


1.40
log
@No need to explicitly capture thread reference in Cleanup object, as it's an inner class.
@
text
@d1750 1
a1750 3
        java.util.concurrent.atomic.AtomicReferenceFieldUpdater
            .newUpdater(Thread.class, ClassLoader.class, "contextClassLoader")
            .compareAndSet(this, ClassLoader.DUMMY, cl);
d1752 3
@


1.39
log
@Changed Thread.parkBlocker field accessiblity to internal, to allow java.util.concurrent.ForkJoinPool direct access.
@
text
@a153 6
        private final Thread thread;

        Cleanup(Thread thread) {
            this.thread = thread;
        }

d155 1
a155 1
            thread.die();
d557 1
a557 1
        cleanup = new Cleanup(this);
@


1.38
log
@Merged fix from 8u11.
@
text
@d259 2
a260 1
    volatile Object parkBlocker;
@


1.37
log
@Removed sun.misc.Unsafe usage from java.util.concurrent.atomic.Striped64.
@
text
@d480 2
a517 1
        this.name = name.toCharArray();
@


1.36
log
@First part of OpenJDK 8 integration.
@
text
@d2388 2
a2389 1
    int threadLocalRandomProbe;
@


1.35
log
@Switched from @@HasCallerID to @@CallerSensitive and merged CallerSenstive related 7u40 changes.
@
text
@d2 1
a2 1
 * Copyright (c) 1994, 2011, Oracle and/or its affiliates. All rights reserved.
d79 1
a79 1
 * <p><hr><blockquote><pre>
d94 1
a94 1
 * <p><blockquote><pre>
d105 1
a105 1
 * <p><hr><blockquote><pre>
d120 1
a120 1
 * <p><blockquote><pre>
d182 4
a185 4
    private char        name[];
    private int         priority;
    private Thread      threadQ;
    private long        eetop;
d203 2
a204 1
    AccessController.LazyContext lazyInheritedAccessControlContext;
d455 9
d471 2
d475 1
a475 1
                      long stackSize) {
a510 1

d521 2
a522 1
        this.lazyInheritedAccessControlContext = AccessController.getLazyContext(parent.lazyInheritedAccessControlContext);
d648 8
d1033 1
a1033 1
        lazyInheritedAccessControlContext = null;
a1105 57
        stop(new ThreadDeath());
    }

    /**
     * Forces the thread to stop executing.
     * <p>
     * If there is a security manager installed, the <code>checkAccess</code>
     * method of this thread is called, which may result in a
     * <code>SecurityException</code> being raised (in the current thread).
     * <p>
     * If this thread is different from the current thread (that is, the current
     * thread is trying to stop a thread other than itself) or
     * <code>obj</code> is not an instance of <code>ThreadDeath</code>, the
     * security manager's <code>checkPermission</code> method (with the
     * <code>RuntimePermission("stopThread")</code> argument) is called in
     * addition.
     * Again, this may result in throwing a
     * <code>SecurityException</code> (in the current thread).
     * <p>
     * If the argument <code>obj</code> is null, a
     * <code>NullPointerException</code> is thrown (in the current thread).
     * <p>
     * The thread represented by this thread is forced to stop
     * whatever it is doing abnormally and to throw the
     * <code>Throwable</code> object <code>obj</code> as an exception. This
     * is an unusual action to take; normally, the <code>stop</code> method
     * that takes no arguments should be used.
     * <p>
     * It is permitted to stop a thread that has not yet been started.
     * If the thread is eventually started, it immediately terminates.
     *
     * @@param      obj   the Throwable object to be thrown.
     * @@exception  SecurityException  if the current thread cannot modify
     *               this thread.
     * @@throws     NullPointerException if obj is <tt>null</tt>.
     * @@see        #interrupt()
     * @@see        #checkAccess()
     * @@see        #run()
     * @@see        #start()
     * @@see        #stop()
     * @@see        SecurityManager#checkAccess(Thread)
     * @@see        SecurityManager#checkPermission
     * @@deprecated This method is inherently unsafe.  See {@@link #stop()}
     *        for details.  An additional danger of this
     *        method is that it may be used to generate exceptions that the
     *        target thread is unprepared to handle (including checked
     *        exceptions that the thread could not possibly throw, were it
     *        not for this method).
     *        For more information, see
     *        <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why
     *        are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a>.
     */
    @@Deprecated
    public final synchronized void stop(Throwable obj) {
        if (obj == null)
            throw new NullPointerException();

d1109 1
a1109 2
            if ((this != Thread.currentThread()) ||
                (!(obj instanceof ThreadDeath))) {
d1120 20
a1139 1
        stop0(obj);
d1159 2
a1160 2
     * java.nio.channels.InterruptibleChannel </code>interruptible
     * channel<code>} then the channel will be closed, the thread's interrupt
d1390 1
a1390 1
    public final void setName(String name) {
d1393 3
a1708 1

d1750 1
a1750 1
    
d1942 1
a1942 1
    private static boolean isCCLOverridden(Class cl) {
d1962 1
a1962 1
    private static boolean auditSubclass(final Class subcl) {
d1966 1
a1966 1
                    for (Class cl = subcl;
d1971 1
a1971 1
                            cl.getDeclaredMethod("getContextClassLoader", new Class[0]);
d1976 1
a1976 1
                            Class[] params = {ClassLoader.class};
d2195 1
d2265 1
d2278 1
d2375 20
d2584 11
@


1.34
log
@Simplified Thread.interrupted flag checking.
@
text
@d40 2
d1718 1
d1725 1
d1728 2
a1729 5
            ClassLoader ccl = ClassLoader.getCallerClassLoader();
            if (ccl != null && ccl != contextClassLoader &&
                    !contextClassLoader.isAncestor(ccl)) {
                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
            }
@


1.33
log
@Move getThreads() to native code for reusing on other place. This is also more like the Java behavior.
@
text
@d172 1
a172 1
    private boolean interruptPending;
d1231 6
a1236 1
        return currentThread().isInterrupted(true);
d1253 1
a1253 16
        return isInterrupted(false);
    }

    /**
     * Tests if some Thread has been interrupted.  The interrupted state
     * is reset or not based on the value of ClearInterrupted that is
     * passed.
     */
    private boolean isInterrupted(boolean ClearInterrupted) {
        synchronized (lock) {
            boolean b = interruptPending;
            if (ClearInterrupted) {
                interruptPending = false;
            }
            return b;
        }
@


1.32
log
@Fixed race condition in Thread.initContextClassLoader().
@
text
@d2050 1
a2050 14
    private static Thread[] getThreads() {
        return (Thread[])AccessController.doPrivileged(
            new PrivilegedAction() {
                public Object run() {
                    ThreadGroup root = getMainThreadGroup();
                    for (; ; ) {
                        Thread[] threads = new Thread[root.activeCount()];
                        if (root.enumerate(threads) == threads.length) {
                            return threads;
                        }
                    }
                }
            });
    }
@


1.31
log
@Switched to a different way to force Thread.[get|set]ContextClassLoader methods to be JIT compiled eagerly to avod RuntimeHelpers.PrepareMethod() which requires full trust.
Added back in the (unused) OpenJDK override checking code.
@
text
@d198 1
a198 1
    private ClassLoader contextClassLoader;
d1780 3
a1782 3
        if (contextClassLoader == ClassLoader.DUMMY) {
            contextClassLoader = cl;
        }
@


1.30
log
@Updated bulk of java.nio to OpenJDK 7.
@
text
@d28 3
d36 2
a140 1
    private static native void prepareCCL();
d142 8
a149 1
        prepareCCL();
d1766 4
d1946 13
d1965 1
d1968 47
d2349 62
@


1.29
log
@Fixed Thread.isCCLOverridden() bug. If the [g|s]etContextClassLoader() methods were not JITted before isCCLOverridden(), ldftn would return the JIT stub address and the vtable could contain the JITted method address.
@
text
@d1195 1
a1195 1
                b.interrupt();
@


1.28
log
@- Updated java.lang.Thread to OpenJDK 7

Switched to 7:
- java.lang.ThreadGroup
@
text
@d136 4
@


1.27
log
@Partially updated to OpenJDK 7.
@
text
@a272 6
    /* If stop was called before start */
    private boolean stopBeforeStart;

    /* Remembered Throwable from stop before start */
    private Throwable throwableFromStop;

d852 4
d857 14
a870 3
        start0();
        if (stopBeforeStart) {
            stop0(throwableFromStop);
d988 1
a988 1
            group.remove(this);
d1138 1
a1138 7
            stop0(obj);
        } else {

            // Must do the null arg check that the VM would do with stop0
            if (obj == null) {
                throw new NullPointerException();
            }
d1140 2
a1141 4
            // Remember this stop attempt for if/when start is used
            stopBeforeStart = true;
            throwableFromStop = obj;
        }
d1758 2
a1759 3
    // [IKVM] called by sun.misc.Launcher to initialize the context class loader
    @@ikvm.lang.Internal
    public void initContextClassLoader(ClassLoader cl) {
d1912 1
a1912 2
        Map<Thread, StackTraceElement[]> m
            = new HashMap<Thread, StackTraceElement[]>(threads.length);
a2282 3
        if (x == null) {
            throw new NullPointerException();
        }
@


1.26
log
@Integrated OpenJDK 6 b21.
@
text
@d2 1
a2 1
 * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.
a32 1
import java.util.Collections;
d121 4
d230 1
d248 1
a248 1
    private Object blockerLock = new Object();
a278 4
    /* Whether or not the Thread has been completely constructed;
     * init or clone method has successfully completed */
    private volatile Thread me;    // null

d295 14
a308 2
     * Causes the currently executing thread object to temporarily pause
     * and allow other threads to execute.
d370 10
a379 5
     * @@param      millis   the length of time to sleep in milliseconds.
     * @@exception  InterruptedException if any thread has interrupted
     *             the current thread.  The <i>interrupted status</i> of the
     *             current thread is cleared when this exception is thrown.
     * @@see        Object#notify()
d403 3
a405 3
     * Causes the currently executing thread to sleep (cease execution)
     * for the specified number of milliseconds plus the specified number
     * of nanoseconds, subject to the precision and accuracy of system
d409 14
a422 9
     * @@param      millis   the length of time to sleep in milliseconds.
     * @@param      nanos    0-999999 additional nanoseconds to sleep.
     * @@exception  IllegalArgumentException  if the value of millis is
     *             negative or the value of nanos is not in the range
     *             0-999999.
     * @@exception  InterruptedException if any thread has interrupted
     *             the current thread.  The <i>interrupted status</i> of the
     *             current thread is cleared when this exception is thrown.
     * @@see        Object#notify()
d453 4
a509 2

        this.me = this;
a542 2

        this.me = this;
d586 2
a587 3
     * Returns a clone if the class of this object is {@@link Cloneable Cloneable}.
     *
     * @@return  a clone if the class of this object is {@@code Cloneable}
d590 1
a590 2
     *          if this method is invoked on a class that does not
     *          support {@@code Cloneable}
d594 1
a594 24
        Thread t;
        synchronized(this) {
            t = (Thread) super.clone();

            t.tid = nextThreadID();
            t.parkBlocker = null;
            t.blocker = null;
            t.blockerLock = new Object();
            t.threadLocals = null;

            group.checkAccess();
            if (threadStatus == 0) {
                group.addUnstarted();
            }
            t.setPriority(priority);

            final Thread current = Thread.currentThread();
            if (current.inheritableThreadLocals != null)
                t.inheritableThreadLocals =
                    ThreadLocal.createInheritedMap(current.inheritableThreadLocals);
        }

        t.me = t;
        return t;
d598 5
a602 7
     * Allocates a new <code>Thread</code> object. This constructor has
     * the same effect as <code>Thread(null, null,</code>
     * <i>gname</i><code>)</code>, where <b><i>gname</i></b> is
     * a newly generated name. Automatically generated names are of the
     * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer.
     *
     * @@see     #Thread(ThreadGroup, Runnable, String)
d609 10
a618 8
     * Allocates a new <code>Thread</code> object. This constructor has
     * the same effect as <code>Thread(null, target,</code>
     * <i>gname</i><code>)</code>, where <i>gname</i> is
     * a newly generated name. Automatically generated names are of the
     * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer.
     *
     * @@param   target   the object whose <code>run</code> method is called.
     * @@see     #Thread(ThreadGroup, Runnable, String)
d625 21
a645 11
     * Allocates a new <code>Thread</code> object. This constructor has
     * the same effect as <code>Thread(group, target,</code>
     * <i>gname</i><code>)</code>, where <i>gname</i> is
     * a newly generated name. Automatically generated names are of the
     * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer.
     *
     * @@param      group    the thread group.
     * @@param      target   the object whose <code>run</code> method is called.
     * @@exception  SecurityException  if the current thread cannot create a
     *             thread in the specified thread group.
     * @@see        #Thread(ThreadGroup, Runnable, String)
d652 3
a654 2
     * Allocates a new <code>Thread</code> object. This constructor has
     * the same effect as <code>Thread(null, null, name)</code>.
d656 2
a657 2
     * @@param   name   the name of the new thread.
     * @@see     #Thread(ThreadGroup, Runnable, String)
d664 11
a674 2
     * Allocates a new <code>Thread</code> object. This constructor has
     * the same effect as <code>Thread(group, null, name)</code>
d676 6
a681 5
     * @@param      group   the thread group.
     * @@param      name    the name of the new thread.
     * @@exception  SecurityException  if the current thread cannot create a
     *               thread in the specified thread group.
     * @@see        #Thread(ThreadGroup, Runnable, String)
d688 7
a694 2
     * Allocates a new <code>Thread</code> object. This constructor has
     * the same effect as <code>Thread(null, target, name)</code>.
d696 2
a697 3
     * @@param   target   the object whose <code>run</code> method is called.
     * @@param   name     the name of the new thread.
     * @@see     #Thread(ThreadGroup, Runnable, String)
d704 10
a713 18
     * Allocates a new <code>Thread</code> object so that it has
     * <code>target</code> as its run object, has the specified
     * <code>name</code> as its name, and belongs to the thread group
     * referred to by <code>group</code>.
     * <p>
     * If <code>group</code> is <code>null</code> and there is a
     * security manager, the group is determined by the security manager's
     * <code>getThreadGroup</code> method. If <code>group</code> is
     * <code>null</code> and there is not a security manager, or the
     * security manager's <code>getThreadGroup</code> method returns
     * <code>null</code>, the group is set to be the same ThreadGroup
     * as the thread that is creating the new thread.
     *
     * <p>If there is a security manager, its <code>checkAccess</code>
     * method is called with the ThreadGroup as its argument.
     * <p>In addition, its <code>checkPermission</code>
     * method is called with the
     * <code>RuntimePermission("enableContextClassLoaderOverride")</code>
d715 4
a718 12
     * of a subclass which overrides the <code>getContextClassLoader</code>
     * or <code>setContextClassLoader</code> methods.
     * This may result in a SecurityException.

     * <p>
     * If the <code>target</code> argument is not <code>null</code>, the
     * <code>run</code> method of the <code>target</code> is called when
     * this thread is started. If the target argument is
     * <code>null</code>, this thread's <code>run</code> method is called
     * when this thread is started.
     * <p>
     * The priority of the newly created thread is set equal to the
d720 4
a723 4
     * thread. The method <code>setPriority</code> may be used to
     * change the priority to a new value.
     * <p>
     * The newly created thread is initially marked as being a daemon
d725 14
a738 2
     * as a daemon thread. The method <code>setDaemon </code> may be used
     * to change whether or not a thread is a daemon.
d740 6
a745 12
     * @@param      group     the thread group.
     * @@param      target   the object whose <code>run</code> method is called.
     * @@param      name     the name of the new thread.
     * @@exception  SecurityException  if the current thread cannot create a
     *               thread in the specified thread group or cannot
     *               override the context class loader methods.
     * @@see        Runnable#run()
     * @@see        #run()
     * @@see        #setDaemon(boolean)
     * @@see        #setPriority(int)
     * @@see        ThreadGroup#checkAccess()
     * @@see        SecurityManager#checkAccess
d752 4
a755 4
     * Allocates a new <code>Thread</code> object so that it has
     * <code>target</code> as its run object, has the specified
     * <code>name</code> as its name, belongs to the thread group referred to
     * by <code>group</code>, and has the specified <i>stack size</i>.
d762 1
a762 1
     * <tt>stackSize</tt> parameter, if any, is highly platform dependent.</b>
d765 1
a765 1
     * <tt>stackSize</tt> parameter may allow a thread to achieve greater
d773 1
a773 1
     * <tt>stackSize</tt> parameter may have no effect whatsoever.</b>
d775 1
a775 1
     * <p>The virtual machine is free to treat the <tt>stackSize</tt>
d783 1
a783 1
     * <p>Specifying a value of zero for the <tt>stackSize</tt> parameter will
d785 1
a785 1
     * <tt>Thread(ThreadGroup, Runnable, String)</tt> constructor.
d797 25
a821 1
     * <tt>stackSize parameter</tt>.
a822 7
     * @@param      group    the thread group.
     * @@param      target   the object whose <code>run</code> method is called.
     * @@param      name     the name of the new thread.
     * @@param      stackSize the desired stack size for the new thread, or
     *             zero to indicate that this parameter is to be ignored.
     * @@exception  SecurityException  if the current thread cannot create a
     *               thread in the specified thread group.
d856 1
a856 1
        if (threadStatus != 0 || this != me)
d908 1
d1060 1
a1060 6
        // If the thread is already dead, return.
        // A zero status value corresponds to "NEW".
        if ((threadStatus != 0) && !isAlive()) {
            return;
        }
        stop1(new ThreadDeath());
d1114 2
a1115 2
        stop1(obj);
    }
a1116 4
    /**
     * Common impl for stop() and stop(Throwable).
     */
    private final synchronized void stop1(Throwable th) {
d1121 1
a1121 1
                (!(th instanceof ThreadDeath))) {
d1125 2
a1126 1
        // A zero status value corresponds to "NEW"
d1129 1
a1129 1
            stop0(th);
d1133 1
a1133 1
            if (th == null) {
d1139 1
a1139 1
            throwableFromStop = th;
d1428 14
a1441 5
     * Returns the number of active threads in the current thread's thread
     * group.
     *
     * @@return  the number of active threads in the current thread's thread
     *          group.
d1448 18
a1465 10
     * Copies into the specified array every active thread in
     * the current thread's thread group and its subgroups. This method simply
     * calls the <code>enumerate</code> method of the current thread's thread
     * group with the array argument.
     * <p>
     * First, if there is a security manager, that <code>enumerate</code>
     * method calls the security
     * manager's <code>checkAccess</code> method
     * with the thread group as its argument. This may result
     * in throwing a <code>SecurityException</code>.
a1466 1
     * @@param tarray an array of Thread objects to copy to
d1468 4
a1471 4
     * @@exception  SecurityException  if a security manager exists and its
     *             <code>checkAccess</code> method doesn't allow the operation.
     * @@see     ThreadGroup#enumerate(Thread[])
     * @@see     SecurityManager#checkAccess(ThreadGroup)
d1494 2
a1495 2
     * Waits at most <code>millis</code> milliseconds for this thread to
     * die. A timeout of <code>0</code> means to wait forever.
d1497 16
a1512 4
     * @@param      millis   the time to wait in milliseconds.
     * @@exception  InterruptedException if any thread has interrupted
     *             the current thread.  The <i>interrupted status</i> of the
     *             current thread is cleared when this exception is thrown.
d1540 2
a1541 2
     * Waits at most <code>millis</code> milliseconds plus
     * <code>nanos</code> nanoseconds for this thread to die.
d1543 20
a1562 7
     * @@param      millis   the time to wait in milliseconds.
     * @@param      nanos    0-999999 additional nanoseconds to wait.
     * @@exception  IllegalArgumentException  if the value of millis is negative
     *               the value of nanos is not in the range 0-999999.
     * @@exception  InterruptedException if any thread has interrupted
     *             the current thread.  The <i>interrupted status</i> of the
     *             current thread is cleared when this exception is thrown.
d1586 11
a1596 3
     * @@exception  InterruptedException if any thread has interrupted
     *             the current thread.  The <i>interrupted status</i> of the
     *             current thread is cleared when this exception is thrown.
d1613 15
a1627 18
     * Marks this thread as either a daemon thread or a user thread. The
     * Java Virtual Machine exits when the only threads running are all
     * daemon threads.
     * <p>
     * This method must be called before the thread is started.
      * <p>
     * This method first calls the <code>checkAccess</code> method
     * of this thread
     * with no arguments. This may result in throwing a
     * <code>SecurityException </code>(in the current thread).
    *
     * @@param      on   if <code>true</code>, marks this thread as a
     *                  daemon thread.
     * @@exception  IllegalThreadStateException  if this thread is active.
     * @@exception  SecurityException  if the current thread cannot modify
     *               this thread.
     * @@see        #isDaemon()
     * @@see        #checkAccess
d1688 16
a1703 12
     * If not set, the default is the ClassLoader context of the parent
     * Thread. The context ClassLoader of the primordial thread is
     * typically set to the class loader used to load the application.
     *
     * <p>First, if there is a security manager, and the caller's class
     * loader is not null and the caller's class loader is not the same as or
     * an ancestor of the context class loader for the thread whose
     * context class loader is being requested, then the security manager's
     * <code>checkPermission</code>
     * method is called with a
     * <code>RuntimePermission("getClassLoader")</code> permission
     *  to see if it's ok to get the context ClassLoader..
d1705 2
a1706 9
     * @@return the context ClassLoader for this Thread
     *
     * @@throws SecurityException
     *        if a security manager exists and its
     *        <code>checkPermission</code> method doesn't allow
     *        getting the context ClassLoader.
     * @@see #setContextClassLoader
     * @@see SecurityManager#checkPermission
     * @@see RuntimePermission
d1730 13
a1742 2
     * the creator of the thread to provide the appropriate class loader
     * to code running in the thread when loading classes and resources.
d1744 2
a1745 12
     * <p>First, if there is a security manager, its <code>checkPermission</code>
     * method is called with a
     * <code>RuntimePermission("setContextClassLoader")</code> permission
     *  to see if it's ok to set the context ClassLoader..
     *
     * @@param cl the context ClassLoader for this Thread
     *
     * @@exception  SecurityException  if the current thread cannot set the
     * context ClassLoader.
     * @@see #getContextClassLoader
     * @@see SecurityManager#checkPermission
     * @@see RuntimePermission
d1804 2
a1805 1
     * this thread has not started or has terminated.
@


1.26.2.1
log
@Backport: Make sure that getContextClassLoader() and setContextClassLoader() are JITed before isCCLOverridden().
@
text
@a132 10
    static {
        // force the set/getContextClassLoader methods to be JIT compiled, because isCCLOverridden(Thread) depends on it
        // (we don't want to use RuntimeHelpers.PrepareMethod() because it requires full trust)
        Thread dummy = new Thread((Void)null);
        dummy.getContextClassLoader();
        dummy.setContextClassLoader(ClassLoader.DUMMY);
    }
    private Thread(Void _) {
        // body replaced in map.xml
    }
@


1.25
log
@Use safe version of ThreadPool.QueueUserWorkItem().
@
text
@d2 1
a2 1
 * Copyright 1994-2007 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
d275 4
d484 2
d519 2
d563 20
d584 17
a600 1
   /**
d827 1
a827 1
        if (threadStatus != 0)
@


1.24
log
@- Restructured threadProc() to allow try/finally block to be recognized by code generator and thus allow the finally block to run without asynchronous exceptions.
- Hacked wakeupJoinedThreads() to avoid deadlocks by deferring notification (by scheduling a thread pool task) if the lock cannot be obtained.
@
text
@d867 1
a867 1
    
d882 1
a882 1
                cli.System.Threading.ThreadPool.UnsafeQueueUserWorkItem(
@


1.23
log
@Remove implementation specific methods from top of stack trace for threads started from Java.
@
text
@a851 3
        // NOTE locking this here isn't ideal, because we might be invoked from
        // the Cleanup object's finalizer and some user code might own the lock and hence
        // block the finalizer thread.
d868 29
a896 2
    private synchronized void wakeupJoinedThreads() {
        notifyAll();
d2280 13
a2302 3
        finally {
            die();
        }
@


1.22
log
@The full Thread parent hierarchy should be considered when capturing the stack.
@
text
@d794 1
d2252 1
@


1.21
log
@Made Thread constructor stack capture more lazy.
@
text
@d469 1
a469 1
        this.lazyInheritedAccessControlContext = AccessController.getLazyContext();
@


1.20
log
@- Replaced reflection based implementation of isCCLOverridden() with an MSIL version that directly compares the method pointers.
- Always use isCCLOverridden() to determine if we need to call parent.getContextClassLoader(), this avoids resolving ClassLoader.DUMMY when we're creating a new thread.
@
text
@d183 1
a183 1
    AccessControlContext inheritedAccessControlContext;
d469 1
a469 1
        this.inheritedAccessControlContext = AccessController.getContext();
d888 1
a888 1
        inheritedAccessControlContext = null;
@


1.19
log
@Thread should synchronize on private lock instead of Thread object in thread startup code, to avoid deadlock with user code.
@
text
@a34 1
import sun.misc.SoftCache;
d453 1
a453 1
            if (isCCLOverridden(getClass())) {
d465 1
a465 1
        if (security == null || isCCLOverridden(parent.getClass()))
a1791 4
    /** cache of subclass security audit results */
    private static final SoftCache subclassAudits = new SoftCache(10);


d1798 1
a1798 50
    private static boolean isCCLOverridden(Class cl) {
        if (cl == Thread.class)
            return false;
        Boolean result = null;
        synchronized (subclassAudits) {
            result = (Boolean) subclassAudits.get(cl);
            if (result == null) {
                /*
                 * Note: only new Boolean instances (i.e., not Boolean.TRUE or
                 * Boolean.FALSE) must be used as cache values, otherwise cache
                 * entry will pin associated class.
                 */
                result = new Boolean(auditSubclass(cl));
                subclassAudits.put(cl, result);
            }
        }
        return result.booleanValue();
    }

    /**
     * Performs reflective checks on given subclass to verify that it doesn't
     * override security-sensitive non-final methods.  Returns true if the
     * subclass overrides any of the methods, false otherwise.
     */
    private static boolean auditSubclass(final Class subcl) {
        Boolean result = AccessController.doPrivileged(
            new PrivilegedAction<Boolean>() {
                public Boolean run() {
                    for (Class cl = subcl;
                         cl != Thread.class;
                         cl = cl.getSuperclass())
                    {
                        try {
                            cl.getDeclaredMethod("getContextClassLoader", new Class[0]);
                            return Boolean.TRUE;
                        } catch (NoSuchMethodException ex) {
                        }
                        try {
                            Class[] params = {ClassLoader.class};
                            cl.getDeclaredMethod("setContextClassLoader", params);
                            return Boolean.TRUE;
                        } catch (NoSuchMethodException ex) {
                        }
                    }
                    return Boolean.FALSE;
                }
            }
        );
        return result.booleanValue();
    }
@


1.18
log
@- Split objectWait into two. One for the nanos variant and one that does the actual waiting.
- Fixed edge case where timeout == Long.MAX_VALUE and nanos >= 500000 that should cause IllegalArgumentException (to be compatible with the JDK, although that is arguably a JDK bug).
- Fixed exception when timeout > Integer.MAX_VALUE. Thanks to Andy Malakov for reporting this.
@
text
@d2202 10
a2211 1
        if (running) {
a2248 3
        else {
            stillborn = x;
        }
d2291 8
a2298 4

    private synchronized void setRunningAndCheckStillborn() throws Throwable {
        running = true;
        Throwable x = stillborn;
a2299 1
            stillborn = null;
@


1.17
log
@Moved ExceptionHelper.getStackTrace() to "native" code of Thread.
@
text
@d2314 1
a2314 1
    // [IKVM] this the implementation of Object.wait(). It is hooked up in map.xml.
d2328 11
d2347 5
a2351 1
                cli.System.Threading.Monitor.Wait(o, new cli.System.TimeSpan(timeout * 10000));
@


1.17.2.1
log
@- Split objectWait into two. One for the nanos variant and one that does the actual waiting.
- Fixed edge case where timeout == Long.MAX_VALUE and nanos >= 500000 that should cause IllegalArgumentException (to be compatible with the JDK, although that is arguably a JDK bug).
- Fixed exception when timeout > Integer.MAX_VALUE. Thanks to Andy Malakov for reporting this.
@
text
@d2314 1
a2314 1
    // [IKVM] this the implementation of Object.wait(long timeout, int nanos). It is hooked up in map.xml.
a2327 11
        objectWait(o, timeout);
    }

    // [IKVM] this the implementation of Object.wait(long timeout). It is hooked up in map.xml.
    static void objectWait(Object o, long timeout) throws InterruptedException {
        if (o == null) {
            throw new NullPointerException();
        }
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
d2336 1
a2336 5
                // We wait a maximum of Integer.MAX_VALUE milliseconds, because that is the maximum that Monitor.Wait will wait.
                // Note that the Object.wait() specification allows for spurious wakeups, so this isn't a problem. Trying to
                // emulate a longer wait with multiple Monitor.Wait() calls is not allowed, because that would mean that
                // we acquire and release the synchronization lock multiple times during the wait.
                cli.System.Threading.Monitor.Wait(o, (int)Math.min(timeout, Integer.MAX_VALUE));
@


1.16
log
@- Moved thread dump code from Thread.java to openjdk.cs.
- Changed thread dump code to write to System.Console.Out, instead of java.lang.System.out.
- Changed formatting slightly and added some info to make it more like the JDK output.
@
text
@d1877 1
a1877 1
                    stacks[i] = ExceptionHelper.getStackTrace(stack, Integer.MAX_VALUE);
d1886 2
@


1.15
log
@Change the method dumpAllStacks() from hide to internal
@
text
@a1853 32
    @@ikvm.lang.Internal
    public static void dumpAllStacks()
    {
        Thread currentThread = currentThread();
        Map<Thread, StackTraceElement[]> traces = getAllStackTraces();
        traces.remove(currentThread);
        System.out.println("Full thread dump");
        java.util.Iterator<Map.Entry<Thread, StackTraceElement[]>> enties = traces.entrySet().iterator();
        while (enties.hasNext())
        {
            Map.Entry<Thread, StackTraceElement[]> entry = enties.next();
            java.lang.Thread thread = entry.getKey();
            java.lang.StackTraceElement[] trace = entry.getValue();
            StringBuilder text = new StringBuilder();
            text.append("\n");
            text.append(thread.getName());
            if (thread.isDaemon())
            {
                text.append(" daemon");
            }
            text.append(" prio=");
            text.append(thread.getPriority());
            text.append(" ");
            text.append(currentThread.nativeThread.get_ThreadState().ToString());
            System.out.println(text);
            for (int i = 0; i < trace.length; i++)
            {
                System.out.println("\tat " + trace[i]);
            }
        }
    }
    
@


1.14
log
@Add a method for dumping all stacktraces to the console.
@
text
@d1854 1
a1854 1
    @@cli.IKVM.Attributes.HideFromJavaAttribute.Annotation
@


1.13
log
@Thread.getAllStackTraces() has ever suspend all Threads
@
text
@d1854 32
@


1.12
log
@Don't overwrite the thread context class loader if it has already been set when sun.misc.Launcher initializes.
@
text
@d1865 1
@


1.11
log
@Removed the usage of .NET reflection.
@
text
@d1622 9
@


1.10
log
@Integrated OpenJDK 6 b10.
@
text
@d184 1
a184 1
    private AccessControlContext inheritedAccessControlContext;
@


1.9
log
@Merged OpenJDK 6 b10 whitespace and comment changes.
@
text
@d1706 8
a1713 1
            return dumpThreads(new Thread[] {this})[0];
d1771 2
a1772 5
            if (threads[i].isAlive()) { 
                StackTraceElement[] stackTrace = traces[i];
                if (stackTrace == null) {
                    stackTrace = EMPTY_STACK_TRACE;
                } 
d1819 3
a1821 3
        Boolean result = (Boolean) AccessController.doPrivileged(
            new PrivilegedAction() {
                public Object run() {
@


1.8
log
@Converted tabs to spaces.
@
text
@d2 1
a2 1
 * Copyright 1994-2006 Sun Microsystems, Inc.  All Rights Reserved.
d41 3
a43 3
 * A <i>thread</i> is a thread of execution in a program. The Java 
 * Virtual Machine allows an application to have multiple threads of 
 * execution running concurrently. 
d45 7
a51 7
 * Every thread has a priority. Threads with higher priority are 
 * executed in preference to threads with lower priority. Each thread 
 * may or may not also be marked as a daemon. When code running in 
 * some thread creates a new <code>Thread</code> object, the new 
 * thread has its priority initially set equal to the priority of the 
 * creating thread, and is a daemon thread if and only if the 
 * creating thread is a daemon. 
d53 5
a57 5
 * When a Java Virtual Machine starts up, there is usually a single 
 * non-daemon thread (which typically calls the method named 
 * <code>main</code> of some designated class). The Java Virtual 
 * Machine continues to execute threads until either of the following 
 * occurs: 
d59 5
a63 5
 * <li>The <code>exit</code> method of class <code>Runtime</code> has been 
 *     called and the security manager has permitted the exit operation 
 *     to take place. 
 * <li>All threads that are not daemon threads have died, either by 
 *     returning from the call to the <code>run</code> method or by 
d68 6
a73 6
 * There are two ways to create a new thread of execution. One is to 
 * declare a class to be a subclass of <code>Thread</code>. This 
 * subclass should override the <code>run</code> method of class 
 * <code>Thread</code>. An instance of the subclass can then be 
 * allocated and started. For example, a thread that computes primes 
 * larger than a stated value could be written as follows: 
d80 1
a80 1
 * 
d88 1
a88 1
 * The following code would then create a thread and start it running: 
d94 6
a99 6
 * The other way to create a thread is to declare a class that 
 * implements the <code>Runnable</code> interface. That class then 
 * implements the <code>run</code> method. An instance of the class can 
 * then be allocated, passed as an argument when creating 
 * <code>Thread</code>, and started. The same example in this other 
 * style looks like the following: 
d106 1
a106 1
 * 
d114 1
a114 1
 * The following code would then create a thread and start it running: 
d120 3
a122 3
 * Every thread has a name for identification purposes. More than 
 * one thread may have the same name. If a name is not specified when 
 * a thread is created, a new name is generated for it. 
a124 1
 * @@version 1.179, 05/05/07
d198 2
a199 2
     * maintained by the InheritableThreadLocal class.  
     */ 
d222 1
a222 1
    /* Java thread status for tools, 
d233 1
a233 1
     * The argument supplied to the current call to 
d256 1
a256 1
     * The minimum priority that a thread can have. 
d261 1
a261 1
     * The default priority that is assigned to a thread. 
d266 1
a266 1
     * The maximum priority that a thread can have. 
d292 2
a293 2
     * Causes the currently executing thread object to temporarily pause 
     * and allow other threads to execute. 
d349 4
a352 4
    /** 
     * Causes the currently executing thread to sleep (temporarily cease 
     * execution) for the specified number of milliseconds, subject to 
     * the precision and accuracy of system timers and schedulers. The thread 
d383 4
a386 4
     * Causes the currently executing thread to sleep (cease execution) 
     * for the specified number of milliseconds plus the specified number 
     * of nanoseconds, subject to the precision and accuracy of system 
     * timers and schedulers. The thread does not lose ownership of any 
d391 2
a392 2
     * @@exception  IllegalArgumentException  if the value of millis is 
     *             negative or the value of nanos is not in the range 
d399 1
a399 1
    public static void sleep(long millis, int nanos) 
d432 1
a432 1
            
d558 1
a558 1
     * Allocates a new <code>Thread</code> object. This constructor has 
d560 3
a562 3
     * <i>gname</i><code>)</code>, where <b><i>gname</i></b> is 
     * a newly generated name. Automatically generated names are of the 
     * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer. 
d571 1
a571 1
     * Allocates a new <code>Thread</code> object. This constructor has 
d573 3
a575 3
     * <i>gname</i><code>)</code>, where <i>gname</i> is 
     * a newly generated name. Automatically generated names are of the 
     * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer. 
d585 1
a585 1
     * Allocates a new <code>Thread</code> object. This constructor has 
d587 3
a589 3
     * <i>gname</i><code>)</code>, where <i>gname</i> is 
     * a newly generated name. Automatically generated names are of the 
     * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer. 
d602 2
a603 2
     * Allocates a new <code>Thread</code> object. This constructor has 
     * the same effect as <code>Thread(null, null, name)</code>. 
d613 2
a614 2
     * Allocates a new <code>Thread</code> object. This constructor has 
     * the same effect as <code>Thread(group, null, name)</code> 
d627 2
a628 2
     * Allocates a new <code>Thread</code> object. This constructor has 
     * the same effect as <code>Thread(null, target, name)</code>. 
d639 3
a641 3
     * Allocates a new <code>Thread</code> object so that it has 
     * <code>target</code> as its run object, has the specified 
     * <code>name</code> as its name, and belongs to the thread group 
d644 3
a646 3
     * If <code>group</code> is <code>null</code> and there is a 
     * security manager, the group is determined by the security manager's 
     * <code>getThreadGroup</code> method. If <code>group</code> is 
d648 2
a649 2
     * security manager's <code>getThreadGroup</code> method returns 
     * <code>null</code>, the group is set to be the same ThreadGroup 
d651 2
a652 2
     * 
     * <p>If there is a security manager, its <code>checkAccess</code> 
d663 15
a677 15
     * If the <code>target</code> argument is not <code>null</code>, the 
     * <code>run</code> method of the <code>target</code> is called when 
     * this thread is started. If the target argument is 
     * <code>null</code>, this thread's <code>run</code> method is called 
     * when this thread is started. 
     * <p>
     * The priority of the newly created thread is set equal to the 
     * priority of the thread creating it, that is, the currently running 
     * thread. The method <code>setPriority</code> may be used to 
     * change the priority to a new value. 
     * <p>
     * The newly created thread is initially marked as being a daemon 
     * thread if and only if the thread creating it is currently marked 
     * as a daemon thread. The method <code>setDaemon </code> may be used 
     * to change whether or not a thread is a daemon. 
d719 1
a719 1
     * 
d759 2
a760 2
     * Causes this thread to begin execution; the Java Virtual Machine 
     * calls the <code>run</code> method of this thread. 
d762 4
a765 4
     * The result is that two threads are running concurrently: the 
     * current thread (which returns from the call to the 
     * <code>start</code> method) and the other thread (which executes its 
     * <code>run</code> method). 
d779 1
a779 1
         * group threads created/set up by the VM. Any new functionality added 
d824 4
a827 4
     * If this thread was constructed using a separate 
     * <code>Runnable</code> run object, then that 
     * <code>Runnable</code> object's <code>run</code> method is called; 
     * otherwise, this method does nothing and returns. 
d829 1
a829 1
     * Subclasses of <code>Thread</code> should override this method. 
d894 1
a894 1
    /** 
d898 3
a900 3
     * method is called with <code>this</code> 
     * as its argument. This may result in a 
     * <code>SecurityException</code> being raised (in the current thread). 
d907 2
a908 2
     * Again, this may result in throwing a 
     * <code>SecurityException</code> (in the current thread). 
d910 20
a929 20
     * The thread represented by this thread is forced to stop whatever 
     * it is doing abnormally and to throw a newly created 
     * <code>ThreadDeath</code> object as an exception. 
     * <p>
     * It is permitted to stop a thread that has not yet been started. 
     * If the thread is eventually started, it immediately terminates. 
     * <p>
     * An application should not normally try to catch 
     * <code>ThreadDeath</code> unless it must do some extraordinary 
     * cleanup operation (note that the throwing of 
     * <code>ThreadDeath</code> causes <code>finally</code> clauses of 
     * <code>try</code> statements to be executed before the thread 
     * officially dies).  If a <code>catch</code> clause catches a 
     * <code>ThreadDeath</code> object, it is important to rethrow the 
     * object so that the thread actually dies. 
     * <p>
     * The top-level error handler that reacts to otherwise uncaught 
     * exceptions does not print out a message or otherwise notify the 
     * application if the uncaught exception is an instance of 
     * <code>ThreadDeath</code>. 
d931 1
a931 1
     * @@exception  SecurityException  if the current thread cannot 
d950 1
a950 1
     *       stop running.  The target thread should check this variable  
d955 3
a957 3
     *       interrupt the wait. 
     *       For more information, see 
     *       <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why 
d974 2
a975 2
     * method of this thread is called, which may result in a 
     * <code>SecurityException</code> being raised (in the current thread). 
d983 2
a984 2
     * Again, this may result in throwing a 
     * <code>SecurityException</code> (in the current thread). 
d986 2
a987 2
     * If the argument <code>obj</code> is null, a 
     * <code>NullPointerException</code> is thrown (in the current thread). 
d989 5
a993 5
     * The thread represented by this thread is forced to stop 
     * whatever it is doing abnormally and to throw the 
     * <code>Throwable</code> object <code>obj</code> as an exception. This 
     * is an unusual action to take; normally, the <code>stop</code> method 
     * that takes no arguments should be used. 
d995 2
a996 2
     * It is permitted to stop a thread that has not yet been started. 
     * If the thread is eventually started, it immediately terminates. 
d1015 2
a1016 2
     *        For more information, see 
     *        <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why 
d1055 1
a1055 1
     * 
d1085 1
a1085 1
     * 
d1115 2
a1116 2
     * <p>A thread interruption ignored because a thread was not alive 
     * at the time of the interrupt will be reflected by this method 
d1132 2
a1133 2
     * <p>A thread interruption ignored because a thread was not alive 
     * at the time of the interrupt will be reflected by this method 
d1183 2
a1184 2
     * Tests if this thread is alive. A thread is alive if it has 
     * been started and has not yet died. 
d1196 3
a1198 3
     * First, the <code>checkAccess</code> method of this thread is called 
     * with no arguments. This may result in throwing a 
     * <code>SecurityException </code>(in the current thread). 
d1200 2
a1201 2
     * If the thread is alive, it is suspended and makes no further 
     * progress unless and until it is resumed. 
d1213 2
a1214 2
     *   For more information, see 
     *   <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why 
d1226 3
a1228 3
     * First, the <code>checkAccess</code> method of this thread is called 
     * with no arguments. This may result in throwing a 
     * <code>SecurityException</code> (in the current thread). 
d1230 2
a1231 2
     * If the thread is alive but suspended, it is resumed and is 
     * permitted to make progress in its execution. 
d1239 2
a1240 2
     *     For more information, see 
     *     <a href="{@@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why 
d1250 1
a1250 1
     * Changes the priority of this thread. 
d1252 7
a1258 7
     * First the <code>checkAccess</code> method of this thread is called 
     * with no arguments. This may result in throwing a 
     * <code>SecurityException</code>. 
     * <p>
     * Otherwise, the priority of this thread is set to the smaller of 
     * the specified <code>newPriority</code> and the maximum permitted 
     * priority of the thread's thread group. 
d1298 2
a1299 2
     * Changes the name of this thread to be equal to the argument 
     * <code>name</code>. 
d1301 3
a1303 3
     * First the <code>checkAccess</code> method of this thread is called 
     * with no arguments. This may result in throwing a 
     * <code>SecurityException</code>. 
d1327 1
a1327 1
     * Returns the thread group to which this thread belongs. 
d1349 4
a1352 4
     * Copies into the specified array every active thread in 
     * the current thread's thread group and its subgroups. This method simply 
     * calls the <code>enumerate</code> method of the current thread's thread 
     * group with the array argument. 
d1356 3
a1358 3
     * manager's <code>checkAccess</code> method 
     * with the thread group as its argument. This may result 
     * in throwing a <code>SecurityException</code>. 
d1362 1
a1362 1
     * @@exception  SecurityException  if a security manager exists and its  
d1372 2
a1373 2
     * Counts the number of stack frames in this thread. The thread must 
     * be suspended. 
d1388 2
a1389 2
     * Waits at most <code>millis</code> milliseconds for this thread to 
     * die. A timeout of <code>0</code> means to wait forever. 
d1396 1
a1396 1
    public final synchronized void join(long millis) 
d1422 2
a1423 2
     * Waits at most <code>millis</code> milliseconds plus 
     * <code>nanos</code> nanoseconds for this thread to die. 
d1433 1
a1433 1
    public final synchronized void join(long millis, int nanos) 
d1453 1
a1453 1
     * Waits for this thread to die. 
d1465 1
a1465 1
     * This method is used only for debugging. 
d1474 3
a1476 3
     * Marks this thread as either a daemon thread or a user thread. The 
     * Java Virtual Machine exits when the only threads running are all 
     * daemon threads. 
d1478 1
a1478 1
     * This method must be called before the thread is started. 
d1480 4
a1483 4
     * This method first calls the <code>checkAccess</code> method 
     * of this thread 
     * with no arguments. This may result in throwing a 
     * <code>SecurityException </code>(in the current thread). 
d1513 2
a1514 2
     * Determines if the currently running thread has permission to 
     * modify this thread. 
d1516 3
a1518 3
     * If there is a security manager, its <code>checkAccess</code> method 
     * is called with this thread as its argument. This may result in 
     * throwing a <code>SecurityException</code>. 
d1532 1
a1532 1
     * Returns a string representation of this thread, including the 
d1540 1
a1540 1
            return "Thread[" + getName() + "," + getPriority() + "," + 
d1543 1
a1543 1
            return "Thread[" + getName() + "," + getPriority() + "," + 
d1548 1
a1548 1
    /**    
d1560 2
a1561 2
     * <code>checkPermission</code> 
     * method is called with a 
d1563 1
a1563 1
     *  to see if it's ok to get the context ClassLoader.. 
d1568 2
a1569 2
     *        if a security manager exists and its 
     *        <code>checkPermission</code> method doesn't allow 
d1574 1
a1574 1
     * 
d1586 1
a1586 1
            if (ccl != null && ccl != contextClassLoader && 
d1594 1
a1594 1
    /**   
d1600 2
a1601 2
     * <p>First, if there is a security manager, its <code>checkPermission</code> 
     * method is called with a 
d1603 1
a1603 1
     *  to see if it's ok to set the context ClassLoader.. 
d1606 2
a1607 2
     * 
     * @@exception  SecurityException  if the current thread cannot set the 
d1612 2
a1613 2
     * 
     * @@since 1.2 
d1661 2
a1662 2
     * this thread has not started or has terminated. 
     * If the returned array is of non-zero length then the first element of 
d1668 3
a1670 3
     * <p>If there is a security manager, and this thread is not 
     * the current thread, then the security manager's 
     * <tt>checkPermission</tt> method is called with a 
d1672 1
a1672 1
     * to see if it's ok to get the stack trace. 
d1678 1
a1678 1
     * method.  
d1680 1
a1680 1
     * @@return an array of <tt>StackTraceElement</tt>, 
d1684 2
a1685 2
     *        if a security manager exists and its 
     *        <tt>checkPermission</tt> method doesn't allow 
d1701 2
d1724 1
a1724 1
     * array will be returned in the map value if the virtual machine has 
d1727 2
a1728 2
     * <p>If there is a security manager, then the security manager's 
     * <tt>checkPermission</tt> method is called with a 
d1731 1
a1731 1
     * to see if it is ok to get the stack trace of all threads. 
d1733 2
a1734 2
     * @@return a <tt>Map</tt> from <tt>Thread</tt> to an array of 
     * <tt>StackTraceElement</tt> that represents the stack trace of 
d1738 2
a1739 2
     *        if a security manager exists and its 
     *        <tt>checkPermission</tt> method doesn't allow 
d1758 2
a1759 2
        // Get a snapshot of the list of all threads 
        Thread[] threads = getThreads(); 
d1771 1
d1890 2
a1891 2
     * <tt>long</tt> number generated when this thread was created.  
     * The thread ID is unique and remains unchanged during its lifetime.  
d1902 1
a1902 1
     * A thread state.  A thread can be in one of the following states: 
d1908 1
a1908 1
     *     A thread executing in the Java virtual machine is in this state. 
d1911 2
a1912 2
     *     A thread that is blocked waiting for a monitor lock 
     *     is in this state. 
d1915 2
a1916 2
     *     A thread that is waiting indefinitely for another thread to 
     *     perform a particular action is in this state. 
d1919 2
a1920 2
     *     A thread that is waiting for another thread to perform an action 
     *     for up to a specified waiting time is in this state. 
d1922 1
a1922 1
     * <li>{@@link #TERMINATED}<br> 
d1928 1
a1928 1
     * A thread can be in only one state at a given point in time. 
d1931 1
a1931 1
     * 
d1940 1
a1940 1
        
d1948 1
a1948 1
        
d1952 1
a1952 1
         * to enter a synchronized block/method or 
d1957 1
a1957 1
    
d1960 1
a1960 1
         * A thread is in the waiting state due to calling one of the 
d1967 1
a1967 1
         * 
d1969 1
a1969 1
         * perform a particular action.  
d1972 3
a1974 3
         * on an object is waiting for another thread to call 
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on 
         * that object. A thread that has called <tt>Thread.join()</tt> 
d1978 1
a1978 1
        
d1981 1
a1981 1
         * A thread is in the timed waiting state due to calling one of 
d1987 1
a1987 1
         *   <li>{@@link LockSupport#parkNanos LockSupport.parkNanos}</li> 
d2004 1
a2004 1
     * 
d2036 2
a2037 2
     * Interface for handlers invoked when a <tt>Thread</tt> abruptly 
     * terminates due to an uncaught exception. 
d2040 1
a2040 1
     * <tt>UncaughtExceptionHandler</tt> using 
d2048 2
a2049 2
     * special requirements for dealing with the exception, it can forward 
     * the invocation to the {@@linkplain #getDefaultUncaughtExceptionHandler 
d2057 2
a2058 2
    public interface UncaughtExceptionHandler { 
        /** 
d2078 1
a2078 1
     * for that thread. 
d2084 1
a2084 1
     * (including parent thread groups)  does not specialize its 
d2139 1
a2139 1
    public UncaughtExceptionHandler getUncaughtExceptionHandler() { 
d2146 1
a2146 1
     * due to an uncaught exception. 
d2159 1
a2159 1
    public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) { 
d2165 1
a2165 1
     * Dispatch an uncaught exception to the handler. This method is 
@


1.7
log
@- Renamed ClassLoader.NIL_CLASSLOADER to ClassLoader.DUMMY.
- Removed unused ClassLoader.registerNatives().
- Removed unnecessary field initializers in ClassLoader.
- Moved necessary field initializers in ClassLoader to constructor.
- Changed Thread to make use of ClassLoader.DUMMY, instead of having an extra field to keep track of contextClassLoader status.
@
text
@d136 1
a136 1
	private final Thread thread;
d138 7
a144 7
	Cleanup(Thread thread) {
	    this.thread = thread;
	}

	protected void finalize() {
	    thread.die();
	}
d155 1
a155 1
    private boolean running;	// used only for coordination with stop0(), is never set to false
d160 2
a161 2
    volatile Object parkLock;	// used by get/setParkLock in map.xml
    int parkState;		// used by cmpxchgParkState in map.xml
d164 1
a164 1
    private char	name[];
d166 2
a167 2
    private Thread	threadQ;
    private long	eetop;
d170 1
a170 1
    private boolean	single_step;
d173 1
a173 1
    private boolean	daemon = false;
d179 1
a179 1
    private ThreadGroup	group;
d190 1
a190 1
	return threadInitNumber++;
d230 1
a230 1
	return ++threadSeqNumber;
d251 3
a253 3
	synchronized (blockerLock) {
	    blocker = b;
	}
d283 5
a287 5
	Thread c = current;
	if (c == null) {
	    c = new Thread(getMainThreadGroup());
	}
	return c;
d297 1
a297 1
	cli.System.Threading.Thread.Sleep(0);
d301 8
a308 8
	synchronized (lock) {
	    if (interruptPending) {
		interruptPending = false;
		throw new InterruptedException();
	    }
	    interruptableWait = true;
	    this.timedWait = timedWait;
	}
d312 36
a347 36
	cli.System.Threading.ThreadInterruptedException dotnetInterrupt = null;
	interruptableWait = false;
	for (; ; ) {
	    try {
		if (false) throw new cli.System.Threading.ThreadInterruptedException();
		synchronized (lock) {
		    if (nativeInterruptPending) {
			nativeInterruptPending = false;
			// HACK if there is a pending Interrupt (on the .NET thread), we need to consume that
			// (if there was no contention on "lock (this)" above the interrupted state isn't checked) 
			try {
			    if (false) throw new cli.System.Threading.ThreadInterruptedException();
			    cli.System.Threading.Thread t = cli.System.Threading.Thread.get_CurrentThread();
			    // the obvious thing to do would be t.Interrupt() / t.Join(),
			    // but for some reason that causes a regression in JSR166TestCase (probably a CLR bug)
			    // so we waste a time slice... sigh.
			    t.Join(1);
			}
			catch (cli.System.Threading.ThreadInterruptedException _) {
			}
		    }
		    if (interruptPending) {
			interruptPending = false;
			throw new InterruptedException();
		    }
		}
		break;
	    }
	    catch (cli.System.Threading.ThreadInterruptedException x) {
		dotnetInterrupt = x;
		nativeInterruptPending = false;
	    }
	}
	if (dotnetInterrupt != null) {
	    ikvm.runtime.Util.throwException(dotnetInterrupt);
	}
d350 1
a350 1
    /**	
d363 18
a380 18
	if (millis < 0) {
	    throw new IllegalArgumentException("timeout value is negative");
	}
	Thread c = currentThread();
	c.enterInterruptableWait(true);
	try {
	    if (false) throw new cli.System.Threading.ThreadInterruptedException();
	    for (long iter = millis / Integer.MAX_VALUE; iter != 0; iter--)
	    {
		cli.System.Threading.Thread.Sleep(Integer.MAX_VALUE);
	    }
	    cli.System.Threading.Thread.Sleep((int)(millis % Integer.MAX_VALUE));
	}
	catch (cli.System.Threading.ThreadInterruptedException _) {
	}
	finally {
	    c.leaveInterruptableWait();
	}
d402 1
a402 1
	if (millis < 0) {
d404 1
a404 1
	}
d406 1
a406 1
	if (nanos < 0 || nanos > 999999) {
d408 2
a409 2
				"nanosecond timeout value out of range");
	}
d411 3
a413 3
	if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
	    millis++;
	}
d415 1
a415 1
	sleep(millis);
d429 10
a438 17
	Thread parent = currentThread();
	SecurityManager security = System.getSecurityManager();
	if (g == null) {
	    /* Determine if it's an applet or not */
	    
	    /* If there is a security manager, ask the security manager
	       what to do. */
	    if (security != null) {
		g = security.getThreadGroup();
	    }

	    /* If the security doesn't have a strong opinion of the matter
	       use the parent thread group. */
	    if (g == null) {
		g = parent.getThreadGroup();
	    }
	}
d440 8
a447 1
	/* checkAccess regardless of whether or not threadgroup is
d449 1
a449 1
	g.checkAccess();
d451 8
a458 8
	/*
	 * Do we have the required permissions?
	 */
	if (security != null) {
	    if (isCCLOverridden(getClass())) {
	        security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
	    }
	}
d463 11
a473 11
	this.group = g;
	this.daemon = parent.isDaemon();
	this.priority = parent.getPriority();
	this.name = name.toCharArray();
	if (security == null || isCCLOverridden(parent.getClass()))
	    this.contextClassLoader = parent.getContextClassLoader();
	else
	    this.contextClassLoader = parent.contextClassLoader;
	this.inheritedAccessControlContext = AccessController.getContext();
	this.target = target;
	setPriority(priority);
d475 2
a476 2
	    this.inheritableThreadLocals =
		ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
d486 14
a499 14
	this.running = true;
	cli.System.Threading.Thread thread = cli.System.Threading.Thread.get_CurrentThread();
	nativeThread = thread;
	String name = thread.get_Name();
	if (name == null) {
	    name = "Thread-" + nextThreadNum();
	}

	this.group = g;
	this.daemon = thread.get_IsBackground();
	this.priority = mapClrPriorityToJava(thread.get_Priority().Value);
	this.name = name.toCharArray();
	this.contextClassLoader = ClassLoader.DUMMY;
	this.threadStatus = 0x0005; /* JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE */
d504 11
a514 11
	synchronized (g) {
	    g.addUnstarted();
	    g.add(this);
	}

	current = this;
	cleanup = new Cleanup(this);

	if (!daemon) {
	    cli.System.Threading.Interlocked.Increment(nonDaemonCount);
	}
d518 14
a531 14
	// TODO consider supporting -XX:JavaPriorityX_To_OSPriority settings
	switch (priority) {
	case cli.System.Threading.ThreadPriority.Lowest:
	    return MIN_PRIORITY;
	case cli.System.Threading.ThreadPriority.BelowNormal:
	    return 3;
	default:
	case cli.System.Threading.ThreadPriority.Normal:
	    return NORM_PRIORITY;
	case cli.System.Threading.ThreadPriority.AboveNormal:
	    return 7;
	case cli.System.Threading.ThreadPriority.Highest:
	    return MAX_PRIORITY;
	}
d535 20
a554 20
	// TODO consider supporting -XX:JavaPriorityX_To_OSPriority settings
	if (priority == MIN_PRIORITY) {
	    return cli.System.Threading.ThreadPriority.Lowest;
	}
	else if (priority > Thread.MIN_PRIORITY && priority < Thread.NORM_PRIORITY) {
	    return cli.System.Threading.ThreadPriority.BelowNormal;
	}
	else if (priority == Thread.NORM_PRIORITY) {
	    return cli.System.Threading.ThreadPriority.Normal;
	}
	else if (priority > Thread.NORM_PRIORITY && priority < Thread.MAX_PRIORITY) {
	    return cli.System.Threading.ThreadPriority.AboveNormal;
	}
	else if (priority == Thread.MAX_PRIORITY) {
	    return cli.System.Threading.ThreadPriority.Highest;
	}
	else {
	    // can't happen
	    return cli.System.Threading.ThreadPriority.Normal;
	}
d568 1
a568 1
	init(null, null, "Thread-" + nextThreadNum(), 0);
d582 1
a582 1
	init(null, target, "Thread-" + nextThreadNum(), 0);
d599 1
a599 1
	init(group, target, "Thread-" + nextThreadNum(), 0);
d610 1
a610 1
	init(null, null, name, 0);
d624 1
a624 1
	init(group, null, name, 0);
d636 1
a636 1
	init(null, target, name, 0);
d694 1
a694 1
	init(group, target, name, 0);
d756 1
a756 1
	init(group, target, name, stackSize);
d779 5
a783 5
	 * This method is not invoked for the main method thread or "system"
	 * group threads created/set up by the VM. Any new functionality added 
	 * to this method in the future may have to also be added to the VM.
	 *
	 * A zero status value corresponds to state "NEW".
d790 2
a791 2
	    stop0(throwableFromStop);
	}
d795 27
a821 27
	cli.System.Threading.ThreadStart threadStart = new cli.System.Threading.ThreadStart(new cli.System.Threading.ThreadStart.Method() {
	    public void Invoke() {
		threadProc();
	    }
	});
	if (stackSize <= 0) {
	    nativeThread = new cli.System.Threading.Thread(threadStart);
	}
	else {
	    int maxStackSize = (int)Math.min(Math.max(128 * 1024, stackSize), Integer.MAX_VALUE);
	    nativeThread = new cli.System.Threading.Thread(threadStart, maxStackSize);
	}
	nativeThread.set_Name(getName());
	nativeThread.set_IsBackground(daemon);
	nativeThread.set_Priority(cli.System.Threading.ThreadPriority.wrap(mapJavaPriorityToClr(priority)));
	String apartment = Props.props.getProperty("ikvm.apartmentstate", "").toLowerCase();
	if ("mta".equals(apartment)) {
	    nativeThread.SetApartmentState(cli.System.Threading.ApartmentState.wrap(cli.System.Threading.ApartmentState.MTA));
	}
	else if ("sta".equals(apartment)) {
	    nativeThread.SetApartmentState(cli.System.Threading.ApartmentState.wrap(cli.System.Threading.ApartmentState.STA));
	}
	threadStatus = 0x0005; // JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE
	nativeThread.Start();
	if (!daemon) {
	    cli.System.Threading.Interlocked.Increment(nonDaemonCount);
	}
d837 3
a839 3
	if (target != null) {
	    target.run();
	}
d848 22
a869 22
	exit();
	synchronized (lock) {
	    nativeThread = null;
	    threadStatus = 0x0002; // JVMTI_THREAD_STATE_TERMINATED
	}
	// NOTE locking this here isn't ideal, because we might be invoked from
	// the Cleanup object's finalizer and some user code might own the lock and hence
	// block the finalizer thread.
	wakeupJoinedThreads();
	if (!daemon) {
	    // TODO there is a race condition in the non-daemon counting
	    // (setDaemon() isn't synchronized so it may clear/set the daemon flag without the count being affected)
	    cli.System.Threading.Interlocked.Decrement(nonDaemonCount);
	}
	if (current == this) {
	    current = null;
	    // check if we have a cleanup object, this happens if we attach and subsequently detach from JNI code
	    if (cleanup != null) {
		cli.System.GC.SuppressFinalize(cleanup);
		cleanup = null;
	    }
	}
d873 1
a873 1
	notifyAll();
d881 7
a887 7
	if (group != null) {
	    group.remove(this);
	    group = null;
	}
	/* Aggressively null out all reference fields: see bug 4006245 */
	target = null;
	/* Speed the release of some of these resources */
d943 3
a945 3
     *	     Thread.stop causes it to unlock all of the monitors that it
     *	     has locked (as a natural consequence of the unchecked
     *	     <code>ThreadDeath</code> exception propagating up the stack).  If
d964 5
a968 5
	// A zero status value corresponds to "NEW".
	if ((threadStatus != 0) && !isAlive()) {
	    return;
	}
	stop1(new ThreadDeath());
d1022 1
a1022 1
	stop1(obj);
d1029 8
a1036 8
	SecurityManager security = System.getSecurityManager();
	if (security != null) {
	    checkAccess();
	    if ((this != Thread.currentThread()) ||
		(!(th instanceof ThreadDeath))) {
		security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);
	    }
	}
d1038 4
a1041 4
	if (threadStatus != 0) {
	    resume(); // Wake up thread if it was suspended; no-op otherwise
	    stop0(th);
	} else {
d1044 3
a1046 3
	    if (th == null) {
	 	throw new NullPointerException();
	    }
d1049 2
a1050 2
	    stopBeforeStart = true;
	    throwableFromStop = th;
d1094 2
a1095 2
	if (this != Thread.currentThread())
	    checkAccess();
d1097 9
a1105 9
	synchronized (blockerLock) {
	    Interruptible b = blocker;
	    if (b != null) {
		interrupt0();		// Just to set the interrupt flag
		b.interrupt();
		return;
	    }
	}
	interrupt0();
d1126 1
a1126 1
	return currentThread().isInterrupted(true);
d1143 1
a1143 1
	return isInterrupted(false);
d1152 7
a1158 7
	synchronized (lock) {
	    boolean b = interruptPending;
	    if (ClearInterrupted) {
		interruptPending = false;
	    }
	    return b;
	}
d1180 1
a1180 1
	throw new NoSuchMethodError();
d1191 1
a1191 1
	return (threadStatus & 0x0001) != 0;
d1220 2
a1221 2
	checkAccess();
	suspend0();
d1246 2
a1247 2
	checkAccess();
	resume0();
d1276 9
a1284 9
	checkAccess();
	if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
	    throw new IllegalArgumentException();
	}
	if((g = getThreadGroup()) != null) {
	    if (newPriority > g.getMaxPriority()) {
		newPriority = g.getMaxPriority();
	    }
	    setPriority0(priority = newPriority);
d1295 1
a1295 1
	return priority;
d1313 2
a1314 2
	checkAccess();
	this.name = name.toCharArray();
d1324 1
a1324 1
	return String.valueOf(name);
d1335 1
a1335 1
	return group;
d1346 1
a1346 1
	return currentThread().getThreadGroup().activeCount();
d1369 1
a1369 1
	return currentThread().getThreadGroup().enumerate(tarray);
d1380 2
a1381 2
     *		   which is deprecated.  Further, the results of this call
     *		   were never well-defined.
d1385 1
a1385 1
	return 0;
d1399 2
a1400 2
	long base = System.currentTimeMillis();
	long now = 0;
d1402 1
a1402 1
	if (millis < 0) {
d1404 1
a1404 1
	}
d1406 14
a1419 14
	if (millis == 0) {
	    while (isAlive()) {
		wait(0);
	    }
	} else {
	    while (isAlive()) {
		long delay = millis - now;
		if (delay <= 0) {
		    break;
		}
		wait(delay);
		now = System.currentTimeMillis() - base;
	    }
	}
d1437 1
a1437 1
	if (millis < 0) {
d1439 1
a1439 1
	}
d1441 1
a1441 1
	if (nanos < 0 || nanos > 999999) {
d1443 2
a1444 2
				"nanosecond timeout value out of range");
	}
d1446 3
a1448 3
	if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
	    millis++;
	}
d1450 1
a1450 1
	join(millis);
d1461 1
a1461 1
	join(0);
d1471 1
a1471 1
	new Exception("Stack trace").printStackTrace();
d1495 5
a1499 5
	checkAccess();
	if (isAlive()) {
	    throw new IllegalThreadStateException();
	}
	daemon = on;
d1510 1
a1510 1
	return daemon;
d1526 4
a1529 4
	SecurityManager security = System.getSecurityManager();
	if (security != null) {
	    security.checkAccess(this);
	}
d1540 7
a1546 7
	if (group != null) {
	    return "Thread[" + getName() + "," + getPriority() + "," + 
		           group.getName() + "]";
	} else {
	    return "Thread[" + getName() + "," + getPriority() + "," + 
		            "" + "]";
	}
d1579 9
a1587 9
	if (contextClassLoader == ClassLoader.DUMMY) {
	    contextClassLoader = ClassLoader.getSystemClassLoader();
	}
	if (contextClassLoader == null)
	    return null;
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    ClassLoader ccl = ClassLoader.getCallerClassLoader();
	    if (ccl != null && ccl != contextClassLoader && 
d1589 4
a1592 4
		sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
	    }
	}
	return contextClassLoader;
d1617 5
a1621 5
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    sm.checkPermission(new RuntimePermission("setContextClassLoader"));
	}
	contextClassLoader = cl;
d1641 13
a1653 13
	if (obj == null) {
	    throw new NullPointerException();
	}
	try {
	    if (false) throw new cli.System.Threading.SynchronizationLockException();
	    // The 1.5 memory model (JSR133) explicitly allows spurious wake-ups from Object.wait,
	    // so we abuse Pulse to check if we own the monitor.
	    cli.System.Threading.Monitor.Pulse(obj);
	    return true;
	}
	catch (cli.System.Threading.SynchronizationLockException _) {
	    return false;
	}
d1702 4
a1705 4
	    if (!isAlive()) {
		return EMPTY_STACK_TRACE;
	    }
	    return dumpThreads(new Thread[] {this})[0];
d1707 3
a1709 3
	    // Don't need JVM help for current thread
	    return (new Exception()).getStackTrace();
	}
d1761 1
a1761 1
	    = new HashMap<Thread, StackTraceElement[]>(threads.length);
d1789 16
a1804 16
	if (cl == Thread.class)
	    return false;
	Boolean result = null;
	synchronized (subclassAudits) {
	    result = (Boolean) subclassAudits.get(cl);
	    if (result == null) {
		/*
		 * Note: only new Boolean instances (i.e., not Boolean.TRUE or
		 * Boolean.FALSE) must be used as cache values, otherwise cache
		 * entry will pin associated class.
		 */
		result = new Boolean(auditSubclass(cl));
		subclassAudits.put(cl, result);
	    }
	}
	return result.booleanValue();
d1813 24
a1836 24
	Boolean result = (Boolean) AccessController.doPrivileged(
	    new PrivilegedAction() {
		public Object run() {
		    for (Class cl = subcl;
			 cl != Thread.class;
			 cl = cl.getSuperclass())
		    {
			try {
			    cl.getDeclaredMethod("getContextClassLoader", new Class[0]);
			    return Boolean.TRUE;
			} catch (NoSuchMethodException ex) {
			}
			try {
			    Class[] params = {ClassLoader.class};
			    cl.getDeclaredMethod("setContextClassLoader", params);
			    return Boolean.TRUE;
			} catch (NoSuchMethodException ex) {
			}
		    }
		    return Boolean.FALSE;
		}
	    }
	);
	return result.booleanValue();
d1840 29
a1868 29
	StackTraceElement[][] stacks = new StackTraceElement[threads.length][];
	for (int i = 0; i < threads.length; i++) {
	    cli.System.Threading.Thread nativeThread = threads[i].nativeThread;
	    if (nativeThread == null) {
		stacks[i] = new StackTraceElement[0];
	    } else {
		try {
		    if (false) throw new cli.System.Threading.ThreadStateException();
		    boolean suspended = false;
		    if ((nativeThread.get_ThreadState().Value & cli.System.Threading.ThreadState.Suspended) == 0 && nativeThread != cli.System.Threading.Thread.get_CurrentThread()) {
			nativeThread.Suspend();
		    }
		    cli.System.Diagnostics.StackTrace stack;
		    try {
			stack = new cli.System.Diagnostics.StackTrace(nativeThread, true);
		    }
		    finally {
			if (suspended) {
			    nativeThread.Resume();
			}
		    }
		    stacks[i] = ExceptionHelper.getStackTrace(stack, Integer.MAX_VALUE);
		}
		catch (cli.System.Threading.ThreadStateException _) {
		    stacks[i] = new StackTraceElement[0];
		}
	    }
	}
	return stacks;
d1872 12
a1883 12
	return (Thread[])AccessController.doPrivileged(
	    new PrivilegedAction() {
		public Object run() {
		    ThreadGroup root = getMainThreadGroup();
		    for (; ; ) {
			Thread[] threads = new Thread[root.activeCount()];
			if (root.enumerate(threads) == threads.length) {
			    return threads;
			}
		    }
		}
	    });
d2009 20
a2028 20
	    case 0:
		return State.NEW;
	    case 0x0002:
		return State.TERMINATED;
        }
	synchronized (lock) {
	    if (interruptableWait) {
		// NOTE if objectWait has satisfied the wait condition (or has been interrupted or has timed-out),
		// it can be blocking on the re-acquire of the monitor, but we have no way of detecting that.
		return timedWait ? State.TIMED_WAITING : State.WAITING;
	    }
	}
	cli.System.Threading.Thread nativeThread = this.nativeThread;
	if (nativeThread == null) {
	    return State.TERMINATED;
	}
	if ((nativeThread.get_ThreadState().Value & cli.System.Threading.ThreadState.WaitSleepJoin) != 0) {
	    return State.BLOCKED;
	}
	return State.RUNNABLE;
d2172 9
a2180 9
	cli.System.Threading.Thread nativeThread = this.nativeThread;
	if (nativeThread != null) {
	    try {
		if (false) throw new cli.System.Threading.ThreadStateException();
		nativeThread.set_Priority(cli.System.Threading.ThreadPriority.wrap(mapJavaPriorityToClr(newPriority)));
	    }
	    catch (cli.System.Threading.ThreadStateException _) {
	    }
	}
d2184 41
a2224 41
	if (running) {
	    // NOTE we allow ThreadDeath (and its subclasses) to be thrown on every thread, but any
	    // other exception is ignored, except if we're throwing it on the current Thread. This
	    // is done to allow exception handlers to be type specific, otherwise every exception
	    // handler would have to catch ThreadAbortException and look inside it to see if it
	    // contains the real exception that we wish to handle.
	    // I hope we can get away with this behavior, because Thread.stop() is deprecated
	    // anyway. Note that we do allow arbitrary exceptions to be thrown on the current
	    // thread, since this is harmless (because they aren't wrapped) and also because it
	    // provides some real value, because it is one of the ways you can throw arbitrary checked
	    // exceptions from Java.
	    if (this == current) {
		sun.misc.Unsafe.getUnsafe().throwException(x);
	    }
	    else if (x instanceof ThreadDeath) {
		cli.System.Threading.Thread nativeThread = this.nativeThread;
		if (nativeThread == null) {
		    return;
		}
		try {
		    if (false) throw new cli.System.Threading.ThreadStateException();
		    nativeThread.Abort(x);
		}
		catch (cli.System.Threading.ThreadStateException _) {
		    // .NET 2.0 throws a ThreadStateException if the target thread is currently suspended
		    // (but it does record the Abort request)
		}
		try {
		    if (false) throw new cli.System.Threading.ThreadStateException();
		    int suspend = cli.System.Threading.ThreadState.Suspended | cli.System.Threading.ThreadState.SuspendRequested;
		    while ((nativeThread.get_ThreadState().Value & suspend) != 0) {
			nativeThread.Resume();
		    }
		}
		catch (cli.System.Threading.ThreadStateException _) {
		}
	    }
	}
	else {
	    stillborn = x;
	}
d2228 9
a2236 9
	try {
	    if (false) throw new cli.System.Threading.ThreadStateException();
	    cli.System.Threading.Thread nativeThread = this.nativeThread;
	    if (nativeThread != null) {
		nativeThread.Suspend();
	    }
	}
	catch (cli.System.Threading.ThreadStateException _) {
	}
d2240 9
a2248 9
	try {
	    if (false) throw new cli.System.Threading.ThreadStateException();
	    cli.System.Threading.Thread nativeThread = this.nativeThread;
	    if (nativeThread != null) {
		nativeThread.Resume();
	    }
	}
	catch (cli.System.Threading.ThreadStateException _) {
	}
d2252 14
a2265 14
	synchronized (lock) {
	    // if the thread hasn't been started yet or has been terminated, the interrupt is ignored
	    // (like on the reference implementation)
	    if (nativeThread == null) {
		return;
	    }
	    if (!interruptPending) {
		interruptPending = true;
		if (interruptableWait) {
		    nativeInterruptPending = true;
		    nativeThread.Interrupt();
		}
	    }
	}
d2269 6
a2274 6
	running = true;
	Throwable x = stillborn;
	if (x != null) {
	    stillborn = null;
	    throw x;
	}
d2279 15
a2293 15
	current = this;
	try {
	    setRunningAndCheckStillborn();
	    run();
	}
	catch (Throwable x) {
	    try {
		getUncaughtExceptionHandler().uncaughtException(this, x);
	    }
	    catch (Throwable _) {
	    }
	}
	finally {
	    die();
	}
d2298 28
a2325 28
	if (o == null) {
	    throw new NullPointerException();
	}
	if (timeout < 0) {
	    throw new IllegalArgumentException("timeout value is negative");
	}
	if (nanos < 0 || nanos > 999999) {
	    throw new IllegalArgumentException("nanosecond timeout value out of range");
	}
	if (nanos >= 500000 || (nanos != 0 && timeout == 0)) {
	    timeout++;
	}
	Thread t = currentThread();
	t.enterInterruptableWait(timeout != 0);
	try {
	    if (false) throw new cli.System.Threading.ThreadInterruptedException();
	    if (timeout == 0 || timeout > 922337203685476L) {
		cli.System.Threading.Monitor.Wait(o);
	    }
	    else {
		cli.System.Threading.Monitor.Wait(o, new cli.System.TimeSpan(timeout * 10000));
	    }
	}
	catch (cli.System.Threading.ThreadInterruptedException _) {
	}
	finally {
	    t.leaveInterruptableWait();
	}
@


1.6
log
@Implemented support for specifying Thread stack size.
@
text
@a182 1
    private boolean contextClassLoaderIsSystemClassLoader;
d469 1
a469 1
	else {
a470 2
	    this.contextClassLoaderIsSystemClassLoader = parent.contextClassLoaderIsSystemClassLoader;
	}
d498 1
a498 1
	this.contextClassLoaderIsSystemClassLoader = true;
d1579 2
a1580 6
	if (contextClassLoader == null) {
	    if (contextClassLoaderIsSystemClassLoader) {
		contextClassLoader = ClassLoader.getSystemClassLoader();
	    } else {
		return null;
	    }
d1582 2
a1620 1
	contextClassLoaderIsSystemClassLoader = false;
@


1.5
log
@Moved java.lang.Thread "native" methods to Java.
@
text
@d798 1
a798 2
	// TODO on NET 2.0 set the stack size
	nativeThread = new cli.System.Threading.Thread(new cli.System.Threading.ThreadStart(new cli.System.Threading.ThreadStart.Method() {
d802 8
a809 1
	}));
@


1.4
log
@Refactored class library initialization.
@
text
@d134 29
a162 5
    /* Make sure registerNatives is the first thing <clinit> does. */
    private static native void registerNatives();
    static {
        registerNatives();
    }
a174 3
    /* JVM state */
    private boolean	stillborn = false;

d228 1
a228 2
    private int threadStatus = 0;

d283 9
a291 1
    public static native Thread currentThread();
d297 53
a349 1
    public static native void yield();
d363 20
a382 1
    public static native void sleep(long millis) throws InterruptedException;
d489 1
d491 1
d502 1
a502 1
	this.threadStatus = 5; /* JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE */
d511 7
d536 24
d797 23
a819 1
    private native void start0();
d838 34
d1148 9
a1156 1
    private native boolean isInterrupted(boolean ClearInterrupted);
d1187 3
a1189 1
    public final native boolean isAlive();
d1381 3
a1383 1
    public native int countStackFrames();
d1640 15
a1654 1
    public static native boolean holdsLock(Object obj);
d1839 46
a1884 2
    private native static StackTraceElement[][] dumpThreads(Thread[] threads);
    private native static Thread[] getThreads();
d2008 21
a2028 1
        return sun.misc.VM.toThreadState(threadStatus);
d2171 156
a2326 5
    private native void setPriority0(int newPriority);
    private native void stop0(Object o);
    private native void suspend0();
    private native void resume0();
    private native void interrupt0();
@


1.3
log
@Forked OpenJDK sources that are going to be modified to refactor the library initialization.
@
text
@d162 1
d371 1
a371 1
	else
d373 2
d387 41
d1376 7
a1382 2
	if (contextClassLoader == null)
	    return null;
d1420 1
@


1.2
log
@Integrated OpenJDK's java.lang.Thread
@
text
@d1 24
a24 37
/* Thread -- an independent thread of executable code
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
   Free Software Foundation

This file is part of GNU Classpath.

GNU Classpath is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU Classpath is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Classpath; see the file COPYING.  If not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301 USA.

Linking this library statically or dynamically with other modules is
making a combined work based on this library.  Thus, the terms and
conditions of the GNU General Public License cover the whole
combination.

As a special exception, the copyright holders of this library give you
permission to link this library with independent modules to produce an
executable, regardless of the license terms of these independent
modules, and to copy and distribute the resulting executable under
terms of your choice, provided that you also meet, for each linked
independent module, the terms and conditions of the license of that
module.  An independent module is a module which is not derived from
or based on this library.  If you modify this library, you may extend
this exception to your version of the library, but you are not
obligated to do so.  If you do not wish to do so, delete this
exception statement from your version. */
d28 4
a31 9
import gnu.classpath.VMStackWalker;
import gnu.java.util.WeakIdentityHashMap;

import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;

import java.security.Permission;

d33 5
a37 1
import java.util.Map;
a38 7
/* Written using "Java Class Libraries", 2nd edition, ISBN 0-201-31002-3
 * "The Java Language Specification", ISBN 0-201-63451-1
 * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.
 * Status:  Believed complete to version 1.4, with caveats. We do not
 *          implement the deprecated (and dangerous) stop, suspend, and resume
 *          methods. Security implementation is not complete.
 */
d41 82
a122 9
 * Thread represents a single thread of execution in the VM. When an
 * application VM starts up, it creates a non-daemon Thread which calls the
 * main() method of a particular class.  There may be other Threads running,
 * such as the garbage collection thread.
 *
 * <p>Threads have names to identify them.  These names are not necessarily
 * unique. Every Thread has a priority, as well, which tells the VM which
 * Threads should get more running time. New threads inherit the priority
 * and daemon status of the parent thread, by default.
d124 7
a130 28
 * <p>There are two methods of creating a Thread: you may subclass Thread and
 * implement the <code>run()</code> method, at which point you may start the
 * Thread by calling its <code>start()</code> method, or you may implement
 * <code>Runnable</code> in the class you want to use and then call new
 * <code>Thread(your_obj).start()</code>.
 *
 * <p>The virtual machine runs until all non-daemon threads have died (either
 * by returning from the run() method as invoked by start(), or by throwing
 * an uncaught exception); or until <code>System.exit</code> is called with
 * adequate permissions.
 *
 * <p>It is unclear at what point a Thread should be added to a ThreadGroup,
 * and at what point it should be removed. Should it be inserted when it
 * starts, or when it is created?  Should it be removed when it is suspended
 * or interrupted?  The only thing that is clear is that the Thread should be
 * removed when it is stopped.
 *
 * @@author Tom Tromey
 * @@author John Keiser
 * @@author Eric Blake (ebb9@@email.byu.edu)
 * @@author Andrew John Hughes (gnu_andrew@@member.fsf.org)
 * @@see Runnable
 * @@see Runtime#exit(int)
 * @@see #run()
 * @@see #start()
 * @@see ThreadLocal
 * @@since 1.0
 * @@status updated to 1.4
d132 1515
a1646 269
public class Thread implements Runnable
{
  /** The minimum priority for a Thread. */
  public static final int MIN_PRIORITY = 1;

  /** The priority a Thread gets by default. */
  public static final int NORM_PRIORITY = 5;

  /** The maximum priority for a Thread. */
  public static final int MAX_PRIORITY = 10;

  /** The underlying VM thread, only set when the thread is actually running.
   */
  volatile VMThread vmThread;

  /**
   * The group this thread belongs to. This is set to null by
   * ThreadGroup.removeThread when the thread dies.
   */
  volatile ThreadGroup group;

  /** The object to run(), null if this is the target. */
  final Runnable runnable;

  /** The thread name, non-null. */
  volatile String name;

  /** Whether the thread is a daemon. */
  volatile boolean daemon;

  /** The thread priority, 1 to 10. */
  volatile int priority;

  /** Native thread stack size. 0 = use default */
  private long stacksize;

  /** Was the thread stopped before it was started? */
  Throwable stillborn;

  /** The context classloader for this Thread. */
  private ClassLoader contextClassLoader;
  private boolean contextClassLoaderIsSystemClassLoader;

  /** This thread's ID.  */
  private final long threadId;
  
  /** The park blocker.  See LockSupport.  */
  Object parkBlocker;

  /** The next thread number to use. */
  private static int numAnonymousThreadsCreated;
  
  /** Used to generate the next thread ID to use.  */
  private static long totalThreadsCreated;

  /** The default exception handler.  */
  private static UncaughtExceptionHandler defaultHandler;

  /** Thread local storage. Package accessible for use by
    * InheritableThreadLocal.
    */
  WeakIdentityHashMap locals;

  /** The uncaught exception handler.  */
  UncaughtExceptionHandler exceptionHandler;

  /**
   * Allocates a new <code>Thread</code> object. This constructor has
   * the same effect as <code>Thread(null, null,</code>
   * <i>gname</i><code>)</code>, where <b><i>gname</i></b> is
   * a newly generated name. Automatically generated names are of the
   * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer.
   * <p>
   * Threads created this way must have overridden their
   * <code>run()</code> method to actually do anything.  An example
   * illustrating this method being used follows:
   * <p><blockquote><pre>
   *     import java.lang.*;
   *
   *     class plain01 implements Runnable {
   *         String name;
   *         plain01() {
   *             name = null;
   *         }
   *         plain01(String s) {
   *             name = s;
   *         }
   *         public void run() {
   *             if (name == null)
   *                 System.out.println("A new thread created");
   *             else
   *                 System.out.println("A new thread with name " + name +
   *                                    " created");
   *         }
   *     }
   *     class threadtest01 {
   *         public static void main(String args[] ) {
   *             int failed = 0 ;
   *
   *             <b>Thread t1 = new Thread();</b>
   *             if (t1 != null)
   *                 System.out.println("new Thread() succeed");
   *             else {
   *                 System.out.println("new Thread() failed");
   *                 failed++;
   *             }
   *         }
   *     }
   * </pre></blockquote>
   *
   * @@see     java.lang.Thread#Thread(java.lang.ThreadGroup,
   *          java.lang.Runnable, java.lang.String)
   */
  public Thread()
  {
    this(null, (Runnable) null);
  }

  /**
   * Allocates a new <code>Thread</code> object. This constructor has
   * the same effect as <code>Thread(null, target,</code>
   * <i>gname</i><code>)</code>, where <i>gname</i> is
   * a newly generated name. Automatically generated names are of the
   * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer.
   *
   * @@param target the object whose <code>run</code> method is called.
   * @@see java.lang.Thread#Thread(java.lang.ThreadGroup,
   *                              java.lang.Runnable, java.lang.String)
   */
  public Thread(Runnable target)
  {
    this(null, target);
  }

  /**
   * Allocates a new <code>Thread</code> object. This constructor has
   * the same effect as <code>Thread(null, null, name)</code>.
   *
   * @@param   name   the name of the new thread.
   * @@see     java.lang.Thread#Thread(java.lang.ThreadGroup,
   *          java.lang.Runnable, java.lang.String)
   */
  public Thread(String name)
  {
    this(null, null, name, 0);
  }

  /**
   * Allocates a new <code>Thread</code> object. This constructor has
   * the same effect as <code>Thread(group, target,</code>
   * <i>gname</i><code>)</code>, where <i>gname</i> is
   * a newly generated name. Automatically generated names are of the
   * form <code>"Thread-"+</code><i>n</i>, where <i>n</i> is an integer.
   *
   * @@param group the group to put the Thread into
   * @@param target the Runnable object to execute
   * @@throws SecurityException if this thread cannot access <code>group</code>
   * @@throws IllegalThreadStateException if group is destroyed
   * @@see #Thread(ThreadGroup, Runnable, String)
   */
  public Thread(ThreadGroup group, Runnable target)
  {
    this(group, target, createAnonymousThreadName(), 0);
  }

  /**
   * Allocates a new <code>Thread</code> object. This constructor has
   * the same effect as <code>Thread(group, null, name)</code>
   *
   * @@param group the group to put the Thread into
   * @@param name the name for the Thread
   * @@throws NullPointerException if name is null
   * @@throws SecurityException if this thread cannot access <code>group</code>
   * @@throws IllegalThreadStateException if group is destroyed
   * @@see #Thread(ThreadGroup, Runnable, String)
   */
  public Thread(ThreadGroup group, String name)
  {
    this(group, null, name, 0);
  }

  /**
   * Allocates a new <code>Thread</code> object. This constructor has
   * the same effect as <code>Thread(null, target, name)</code>.
   *
   * @@param target the Runnable object to execute
   * @@param name the name for the Thread
   * @@throws NullPointerException if name is null
   * @@see #Thread(ThreadGroup, Runnable, String)
   */
  public Thread(Runnable target, String name)
  {
    this(null, target, name, 0);
  }

  /**
   * Allocate a new Thread object, with the specified ThreadGroup and name, and
   * using the specified Runnable object's <code>run()</code> method to
   * execute.  If the Runnable object is null, <code>this</code> (which is
   * a Runnable) is used instead.
   *
   * <p>If the ThreadGroup is null, the security manager is checked. If a
   * manager exists and returns a non-null object for
   * <code>getThreadGroup</code>, that group is used; otherwise the group
   * of the creating thread is used. Note that the security manager calls
   * <code>checkAccess</code> if the ThreadGroup is not null.
   *
   * <p>The new Thread will inherit its creator's priority and daemon status.
   * These can be changed with <code>setPriority</code> and
   * <code>setDaemon</code>.
   *
   * @@param group the group to put the Thread into
   * @@param target the Runnable object to execute
   * @@param name the name for the Thread
   * @@throws NullPointerException if name is null
   * @@throws SecurityException if this thread cannot access <code>group</code>
   * @@throws IllegalThreadStateException if group is destroyed
   * @@see Runnable#run()
   * @@see #run()
   * @@see #setDaemon(boolean)
   * @@see #setPriority(int)
   * @@see SecurityManager#checkAccess(ThreadGroup)
   * @@see ThreadGroup#checkAccess()
   */
  public Thread(ThreadGroup group, Runnable target, String name)
  {
    this(group, target, name, 0);
  }

  /**
   * Allocate a new Thread object, as if by
   * <code>Thread(group, null, name)</code>, and give it the specified stack
   * size, in bytes. The stack size is <b>highly platform independent</b>,
   * and the virtual machine is free to round up or down, or ignore it
   * completely.  A higher value might let you go longer before a
   * <code>StackOverflowError</code>, while a lower value might let you go
   * longer before an <code>OutOfMemoryError</code>.  Or, it may do absolutely
   * nothing! So be careful, and expect to need to tune this value if your
   * virtual machine even supports it.
   *
   * @@param group the group to put the Thread into
   * @@param target the Runnable object to execute
   * @@param name the name for the Thread
   * @@param size the stack size, in bytes; 0 to be ignored
   * @@throws NullPointerException if name is null
   * @@throws SecurityException if this thread cannot access <code>group</code>
   * @@throws IllegalThreadStateException if group is destroyed
   * @@since 1.4
   */
  public Thread(ThreadGroup group, Runnable target, String name, long size)
  {
    // Bypass System.getSecurityManager, for bootstrap efficiency.
    SecurityManager sm = SecurityManager.current;
    Thread current = currentThread();
    if (group == null)
      {
	if (sm != null)
	  group = sm.getThreadGroup();
	if (group == null)
	  group = current.group;
      }
    if (sm != null)
      sm.checkAccess(group);

    this.group = group;
    // Use toString hack to detect null.
    this.name = name.toString();
    this.runnable = target;
    this.stacksize = size;
d1648 193
a1840 1011
    synchronized (Thread.class)
      {
        this.threadId = ++totalThreadsCreated;
      }

    priority = current.priority;
    daemon = current.daemon;
    contextClassLoader = current.contextClassLoader;
    contextClassLoaderIsSystemClassLoader =
        current.contextClassLoaderIsSystemClassLoader;

    group.addThread(this);
    InheritableThreadLocal.newChildThread(this);
  }

  /**
   * Used by the VM to create thread objects for threads started outside
   * of Java. Note: caller is responsible for adding the thread to
   * a group and InheritableThreadLocal.
   * Note: This constructor should not call any methods that could result
   * in a call to Thread.currentThread(), because that makes life harder
   * for the VM.
   *
   * @@param vmThread the native thread
   * @@param name the thread name or null to use the default naming scheme
   * @@param priority current priority
   * @@param daemon is the thread a background thread?
   */
  Thread(VMThread vmThread, String name, int priority, boolean daemon)
  {
    this.vmThread = vmThread;
    this.runnable = null;
    if (name == null)
      name = createAnonymousThreadName();
    this.name = name;
    this.priority = priority;
    this.daemon = daemon;
    // By default the context class loader is the system class loader,
    // we set a flag to signal this because we don't want to call
    // ClassLoader.getSystemClassLoader() at this point, because on
    // VMs that lazily create the system class loader that might result
    // in running user code (when a custom system class loader is specified)
    // and that user code could call Thread.currentThread().
    // ClassLoader.getSystemClassLoader() can also return null, if the system
    // is currently in the process of constructing the system class loader
    // (and, as above, the constructiong sequence calls Thread.currenThread()).
    contextClassLoaderIsSystemClassLoader = true;
    synchronized (Thread.class)
    {
      this.threadId = ++totalThreadsCreated;
    }
  }
  
  /**
   * Generate a name for an anonymous thread.
   */
  private static synchronized String createAnonymousThreadName()
  {
    return "Thread-" + ++numAnonymousThreadsCreated;
  }

  /**
   * Get the number of active threads in the current Thread's ThreadGroup.
   * This implementation calls
   * <code>currentThread().getThreadGroup().activeCount()</code>.
   *
   * @@return the number of active threads in the current ThreadGroup
   * @@see ThreadGroup#activeCount()
   */
  public static int activeCount()
  {
    return currentThread().group.activeCount();
  }

  /**
   * Check whether the current Thread is allowed to modify this Thread. This
   * passes the check on to <code>SecurityManager.checkAccess(this)</code>.
   *
   * @@throws SecurityException if the current Thread cannot modify this Thread
   * @@see SecurityManager#checkAccess(Thread)
   */
  public final void checkAccess()
  {
    // Bypass System.getSecurityManager, for bootstrap efficiency.
    SecurityManager sm = SecurityManager.current;
    if (sm != null)
      sm.checkAccess(this);
  }

  /**
   * Count the number of stack frames in this Thread.  The Thread in question
   * must be suspended when this occurs.
   *
   * @@return the number of stack frames in this Thread
   * @@throws IllegalThreadStateException if this Thread is not suspended
   * @@deprecated pointless, since suspend is deprecated
   */
  public int countStackFrames()
  {
    VMThread t = vmThread;
    if (t == null || group == null)
      throw new IllegalThreadStateException();

    return t.countStackFrames();
  }

  /**
   * Get the currently executing Thread. In the situation that the
   * currently running thread was created by native code and doesn't
   * have an associated Thread object yet, a new Thread object is
   * constructed and associated with the native thread.
   *
   * @@return the currently executing Thread
   */
  public static Thread currentThread()
  {
    return VMThread.currentThread();
  }

  /**
   * Originally intended to destroy this thread, this method was never
   * implemented by Sun, and is hence a no-op.
   *
   * @@deprecated This method was originally intended to simply destroy
   *             the thread without performing any form of cleanup operation.
   *             However, it was never implemented.  It is now deprecated
   *             for the same reason as <code>suspend()</code>,
   *             <code>stop()</code> and <code>resume()</code>; namely,
   *             it is prone to deadlocks.  If a thread is destroyed while
   *             it still maintains a lock on a resource, then this resource
   *             will remain locked and any attempts by other threads to
   *             access the resource will result in a deadlock.  Thus, even
   *             an implemented version of this method would be still be
   *             deprecated, due to its unsafe nature.
   * @@throws NoSuchMethodError as this method was never implemented.
   */
  public void destroy()
  {
    throw new NoSuchMethodError();
  }
  
  /**
   * Print a stack trace of the current thread to stderr using the same
   * format as Throwable's printStackTrace() method.
   *
   * @@see Throwable#printStackTrace()
   */
  public static void dumpStack()
  {
    new Throwable().printStackTrace();
  }

  /**
   * Copy every active thread in the current Thread's ThreadGroup into the
   * array. Extra threads are silently ignored. This implementation calls
   * <code>getThreadGroup().enumerate(array)</code>, which may have a
   * security check, <code>checkAccess(group)</code>.
   *
   * @@param array the array to place the Threads into
   * @@return the number of Threads placed into the array
   * @@throws NullPointerException if array is null
   * @@throws SecurityException if you cannot access the ThreadGroup
   * @@see ThreadGroup#enumerate(Thread[])
   * @@see #activeCount()
   * @@see SecurityManager#checkAccess(ThreadGroup)
   */
  public static int enumerate(Thread[] array)
  {
    return currentThread().group.enumerate(array);
  }
  
  /**
   * Get this Thread's name.
   *
   * @@return this Thread's name
   */
  public final String getName()
  {
    VMThread t = vmThread;
    return t == null ? name : t.getName();
  }

  /**
   * Get this Thread's priority.
   *
   * @@return the Thread's priority
   */
  public final synchronized int getPriority()
  {
    VMThread t = vmThread;
    return t == null ? priority : t.getPriority();
  }

  /**
   * Get the ThreadGroup this Thread belongs to. If the thread has died, this
   * returns null.
   *
   * @@return this Thread's ThreadGroup
   */
  public final ThreadGroup getThreadGroup()
  {
    return group;
  }

  /**
   * Checks whether the current thread holds the monitor on a given object.
   * This allows you to do <code>assert Thread.holdsLock(obj)</code>.
   *
   * @@param obj the object to test lock ownership on.
   * @@return true if the current thread is currently synchronized on obj
   * @@throws NullPointerException if obj is null
   * @@since 1.4
   */
  public static boolean holdsLock(Object obj)
  {
    return VMThread.holdsLock(obj);
  }

  /**
   * Interrupt this Thread. First, there is a security check,
   * <code>checkAccess</code>. Then, depending on the current state of the
   * thread, various actions take place:
   *
   * <p>If the thread is waiting because of {@@link #wait()},
   * {@@link #sleep(long)}, or {@@link #join()}, its <i>interrupt status</i>
   * will be cleared, and an InterruptedException will be thrown. Notice that
   * this case is only possible if an external thread called interrupt().
   *
   * <p>If the thread is blocked in an interruptible I/O operation, in
   * {@@link java.nio.channels.InterruptibleChannel}, the <i>interrupt
   * status</i> will be set, and ClosedByInterruptException will be thrown.
   *
   * <p>If the thread is blocked on a {@@link java.nio.channels.Selector}, the
   * <i>interrupt status</i> will be set, and the selection will return, with
   * a possible non-zero value, as though by the wakeup() method.
   *
   * <p>Otherwise, the interrupt status will be set.
   *
   * @@throws SecurityException if you cannot modify this Thread
   */
  public synchronized void interrupt()
  {
    checkAccess();
    VMThread t = vmThread;
    if (t != null)
      t.interrupt();
  }

  /**
   * Determine whether the current Thread has been interrupted, and clear
   * the <i>interrupted status</i> in the process.
   *
   * @@return whether the current Thread has been interrupted
   * @@see #isInterrupted()
   */
  public static boolean interrupted()
  {
    return VMThread.interrupted();
  }

  /**
   * Determine whether the given Thread has been interrupted, but leave
   * the <i>interrupted status</i> alone in the process.
   *
   * @@return whether the Thread has been interrupted
   * @@see #interrupted()
   */
  public boolean isInterrupted()
  {
    VMThread t = vmThread;
    return t != null && t.isInterrupted();
  }

  /**
   * Determine whether this Thread is alive. A thread which is alive has
   * started and not yet died.
   *
   * @@return whether this Thread is alive
   */
  public final boolean isAlive()
  {
    return vmThread != null && group != null;
  }

  /**
   * Tell whether this is a daemon Thread or not.
   *
   * @@return whether this is a daemon Thread or not
   * @@see #setDaemon(boolean)
   */
  public final boolean isDaemon()
  {
    VMThread t = vmThread;
    return t == null ? daemon : t.isDaemon();
  }

  /**
   * Wait forever for the Thread in question to die.
   *
   * @@throws InterruptedException if the Thread is interrupted; it's
   *         <i>interrupted status</i> will be cleared
   */
  public final void join() throws InterruptedException
  {
    join(0, 0);
  }

  /**
   * Wait the specified amount of time for the Thread in question to die.
   *
   * @@param ms the number of milliseconds to wait, or 0 for forever
   * @@throws InterruptedException if the Thread is interrupted; it's
   *         <i>interrupted status</i> will be cleared
   */
  public final void join(long ms) throws InterruptedException
  {
    join(ms, 0);
  }

  /**
   * Wait the specified amount of time for the Thread in question to die.
   *
   * <p>Note that 1,000,000 nanoseconds == 1 millisecond, but most VMs do
   * not offer that fine a grain of timing resolution. Besides, there is
   * no guarantee that this thread can start up immediately when time expires,
   * because some other thread may be active.  So don't expect real-time
   * performance.
   *
   * @@param ms the number of milliseconds to wait, or 0 for forever
   * @@param ns the number of extra nanoseconds to sleep (0-999999)
   * @@throws InterruptedException if the Thread is interrupted; it's
   *         <i>interrupted status</i> will be cleared
   * @@throws IllegalArgumentException if ns is invalid
   */
  public final void join(long ms, int ns) throws InterruptedException
  {
    if (ms < 0 || ns < 0 || ns > 999999)
      throw new IllegalArgumentException();

    VMThread t = vmThread;
    if (t != null)
      t.join(ms, ns);
  }

  /**
   * Resume this Thread.  If the thread is not suspended, this method does
   * nothing. To mirror suspend(), there may be a security check:
   * <code>checkAccess</code>.
   *
   * @@throws SecurityException if you cannot resume the Thread
   * @@see #checkAccess()
   * @@see #suspend()
   * @@deprecated pointless, since suspend is deprecated
   */
  public final synchronized void resume()
  {
    checkAccess();
    VMThread t = vmThread;
    if (t != null)
      t.resume();
  }
  
  /**
   * The method of Thread that will be run if there is no Runnable object
   * associated with the Thread. Thread's implementation does nothing at all.
   *
   * @@see #start()
   * @@see #Thread(ThreadGroup, Runnable, String)
   */
  public void run()
  {
    if (runnable != null)
      runnable.run();
  }

  /**
   * Set the daemon status of this Thread.  If this is a daemon Thread, then
   * the VM may exit even if it is still running.  This may only be called
   * before the Thread starts running. There may be a security check,
   * <code>checkAccess</code>.
   *
   * @@param daemon whether this should be a daemon thread or not
   * @@throws SecurityException if you cannot modify this Thread
   * @@throws IllegalThreadStateException if the Thread is active
   * @@see #isDaemon()
   * @@see #checkAccess()
   */
  public final synchronized void setDaemon(boolean daemon)
  {
    if (vmThread != null)
      throw new IllegalThreadStateException();
    checkAccess();
    this.daemon = daemon;
  }

  /**
   * Returns the context classloader of this Thread. The context
   * classloader can be used by code that want to load classes depending
   * on the current thread. Normally classes are loaded depending on
   * the classloader of the current class. There may be a security check
   * for <code>RuntimePermission("getClassLoader")</code> if the caller's
   * class loader is not null or an ancestor of this thread's context class
   * loader.
   *
   * @@return the context class loader
   * @@throws SecurityException when permission is denied
   * @@see #setContextClassLoader(ClassLoader)
   * @@since 1.2
   */
  public synchronized ClassLoader getContextClassLoader()
  {
    ClassLoader loader = contextClassLoaderIsSystemClassLoader ?
        ClassLoader.getSystemClassLoader() : contextClassLoader;
    // Check if we may get the classloader
    SecurityManager sm = SecurityManager.current;
    if (loader != null && sm != null)
      {
        // Get the calling classloader
	ClassLoader cl = VMStackWalker.getCallingClassLoader();
        if (!loader.isAncestor(cl))
          sm.checkPermission(new RuntimePermission("getClassLoader"));
      }
    return loader;
  }

  /**
   * Sets the context classloader for this Thread. When not explicitly set,
   * the context classloader for a thread is the same as the context
   * classloader of the thread that created this thread. The first thread has
   * as context classloader the system classloader. There may be a security
   * check for <code>RuntimePermission("setContextClassLoader")</code>.
   *
   * @@param classloader the new context class loader
   * @@throws SecurityException when permission is denied
   * @@see #getContextClassLoader()
   * @@since 1.2
   */
  public synchronized void setContextClassLoader(ClassLoader classloader)
  {
    SecurityManager sm = SecurityManager.current;
    if (sm != null)
      sm.checkPermission(new RuntimePermission("setContextClassLoader"));
    this.contextClassLoader = classloader;
    contextClassLoaderIsSystemClassLoader = false;
  }

  /**
   * Set this Thread's name.  There may be a security check,
   * <code>checkAccess</code>.
   *
   * @@param name the new name for this Thread
   * @@throws NullPointerException if name is null
   * @@throws SecurityException if you cannot modify this Thread
   */
  public final synchronized void setName(String name)
  {
    checkAccess();
    // The Class Libraries book says ``threadName cannot be null''.  I
    // take this to mean NullPointerException.
    if (name == null)
      throw new NullPointerException();
    VMThread t = vmThread;
    if (t != null)
      t.setName(name);
    else
      this.name = name;
  }

  /**
   * Yield to another thread. The Thread will not lose any locks it holds
   * during this time. There are no guarantees which thread will be
   * next to run, and it could even be this one, but most VMs will choose
   * the highest priority thread that has been waiting longest.
   */
  public static void yield()
  {
    VMThread.yield();
  }

  /**
   * Suspend the current Thread's execution for the specified amount of
   * time. The Thread will not lose any locks it has during this time. There
   * are no guarantees which thread will be next to run, but most VMs will
   * choose the highest priority thread that has been waiting longest.
   *
   * @@param ms the number of milliseconds to sleep, or 0 for forever
   * @@throws InterruptedException if the Thread is (or was) interrupted;
   *         it's <i>interrupted status</i> will be cleared
   * @@throws IllegalArgumentException if ms is negative
   * @@see #interrupt()
   * @@see #notify()
   * @@see #wait(long)
   */
  public static void sleep(long ms) throws InterruptedException
  {
    sleep(ms, 0);
  }

  /**
   * Suspend the current Thread's execution for the specified amount of
   * time. The Thread will not lose any locks it has during this time. There
   * are no guarantees which thread will be next to run, but most VMs will
   * choose the highest priority thread that has been waiting longest.
   * <p>
   * Note that 1,000,000 nanoseconds == 1 millisecond, but most VMs
   * do not offer that fine a grain of timing resolution. When ms is
   * zero and ns is non-zero the Thread will sleep for at least one
   * milli second. There is no guarantee that this thread can start up
   * immediately when time expires, because some other thread may be
   * active.  So don't expect real-time performance.
   *
   * @@param ms the number of milliseconds to sleep, or 0 for forever
   * @@param ns the number of extra nanoseconds to sleep (0-999999)
   * @@throws InterruptedException if the Thread is (or was) interrupted;
   *         it's <i>interrupted status</i> will be cleared
   * @@throws IllegalArgumentException if ms or ns is negative
   *         or ns is larger than 999999.
   * @@see #interrupt()
   * @@see #notify()
   * @@see #wait(long, int)
   */
  public static void sleep(long ms, int ns) throws InterruptedException
  {
    // Check parameters
    if (ms < 0 )
      throw new IllegalArgumentException("Negative milliseconds: " + ms);

    if (ns < 0 || ns > 999999)
      throw new IllegalArgumentException("Nanoseconds ouf of range: " + ns);

    // Really sleep
    VMThread.sleep(ms, ns);
  }

  /**
   * Start this Thread, calling the run() method of the Runnable this Thread
   * was created with, or else the run() method of the Thread itself. This
   * is the only way to start a new thread; calling run by yourself will just
   * stay in the same thread. The virtual machine will remove the thread from
   * its thread group when the run() method completes.
   *
   * @@throws IllegalThreadStateException if the thread has already started
   * @@see #run()
   */
  public synchronized void start()
  {
    if (vmThread != null || group == null)
      throw new IllegalThreadStateException();

    VMThread.create(this, stacksize);
  }
  
  /**
   * Cause this Thread to stop abnormally because of the throw of a ThreadDeath
   * error. If you stop a Thread that has not yet started, it will stop
   * immediately when it is actually started.
   *
   * <p>This is inherently unsafe, as it can interrupt synchronized blocks and
   * leave data in bad states.  Hence, there is a security check:
   * <code>checkAccess(this)</code>, plus another one if the current thread
   * is not this: <code>RuntimePermission("stopThread")</code>. If you must
   * catch a ThreadDeath, be sure to rethrow it after you have cleaned up.
   * ThreadDeath is the only exception which does not print a stack trace when
   * the thread dies.
   *
   * @@throws SecurityException if you cannot stop the Thread
   * @@see #interrupt()
   * @@see #checkAccess()
   * @@see #start()
   * @@see ThreadDeath
   * @@see ThreadGroup#uncaughtException(Thread, Throwable)
   * @@see SecurityManager#checkAccess(Thread)
   * @@see SecurityManager#checkPermission(Permission)
   * @@deprecated unsafe operation, try not to use
   */
  public final void stop()
  {
    stop(new ThreadDeath());
  }

  /**
   * Cause this Thread to stop abnormally and throw the specified exception.
   * If you stop a Thread that has not yet started, the stop is ignored
   * (contrary to what the JDK documentation says).
   * <b>WARNING</b>This bypasses Java security, and can throw a checked
   * exception which the call stack is unprepared to handle. Do not abuse
   * this power.
   *
   * <p>This is inherently unsafe, as it can interrupt synchronized blocks and
   * leave data in bad states.  Hence, there is a security check:
   * <code>checkAccess(this)</code>, plus another one if the current thread
   * is not this: <code>RuntimePermission("stopThread")</code>. If you must
   * catch a ThreadDeath, be sure to rethrow it after you have cleaned up.
   * ThreadDeath is the only exception which does not print a stack trace when
   * the thread dies.
   *
   * @@param t the Throwable to throw when the Thread dies
   * @@throws SecurityException if you cannot stop the Thread
   * @@throws NullPointerException in the calling thread, if t is null
   * @@see #interrupt()
   * @@see #checkAccess()
   * @@see #start()
   * @@see ThreadDeath
   * @@see ThreadGroup#uncaughtException(Thread, Throwable)
   * @@see SecurityManager#checkAccess(Thread)
   * @@see SecurityManager#checkPermission(Permission)
   * @@deprecated unsafe operation, try not to use
   */
  public final synchronized void stop(Throwable t)
  {
    if (t == null)
      throw new NullPointerException();
    // Bypass System.getSecurityManager, for bootstrap efficiency.
    SecurityManager sm = SecurityManager.current;
    if (sm != null)
      {
        sm.checkAccess(this);
        if (this != currentThread() || !(t instanceof ThreadDeath))
          sm.checkPermission(new RuntimePermission("stopThread"));
      }
    VMThread vt = vmThread;
    if (vt != null)
	vt.stop(t);
    else
	stillborn = t;
  }

  /**
   * Suspend this Thread.  It will not come back, ever, unless it is resumed.
   *
   * <p>This is inherently unsafe, as the suspended thread still holds locks,
   * and can potentially deadlock your program.  Hence, there is a security
   * check: <code>checkAccess</code>.
   *
   * @@throws SecurityException if you cannot suspend the Thread
   * @@see #checkAccess()
   * @@see #resume()
   * @@deprecated unsafe operation, try not to use
   */
  public final synchronized void suspend()
  {
    checkAccess();
    VMThread t = vmThread;
    if (t != null)
      t.suspend();
  }

  /**
   * Set this Thread's priority. There may be a security check,
   * <code>checkAccess</code>, then the priority is set to the smaller of
   * priority and the ThreadGroup maximum priority.
   *
   * @@param priority the new priority for this Thread
   * @@throws IllegalArgumentException if priority exceeds MIN_PRIORITY or
   *         MAX_PRIORITY
   * @@throws SecurityException if you cannot modify this Thread
   * @@see #getPriority()
   * @@see #checkAccess()
   * @@see ThreadGroup#getMaxPriority()
   * @@see #MIN_PRIORITY
   * @@see #MAX_PRIORITY
   */
  public final synchronized void setPriority(int priority)
  {
    checkAccess();
    if (priority < MIN_PRIORITY || priority > MAX_PRIORITY)
      throw new IllegalArgumentException("Invalid thread priority value "
                                         + priority + ".");
    priority = Math.min(priority, group.getMaxPriority());
    VMThread t = vmThread;
    if (t != null)
      t.setPriority(priority);
    else
      this.priority = priority;
  }

  /**
   * Returns a string representation of this thread, including the
   * thread's name, priority, and thread group.
   *
   * @@return a human-readable String representing this Thread
   */
  public String toString()
  {
    return ("Thread[" + name + "," + priority + ","
	    + (group == null ? "" : group.getName()) + "]");
  }

  /**
   * Clean up code, called by VMThread when thread dies.
   */
  synchronized void die()
  {
    group.removeThread(this);
    vmThread = null;
    locals = null;
  }

  /**
   * Returns the map used by ThreadLocal to store the thread local values.
   */
  static Map getThreadLocals()
  {
    Thread thread = currentThread();
    Map locals = thread.locals;
    if (locals == null)
      {
        locals = thread.locals = new WeakIdentityHashMap();
      }
    return locals;
  }

  /** 
   * Assigns the given <code>UncaughtExceptionHandler</code> to this
   * thread.  This will then be called if the thread terminates due
   * to an uncaught exception, pre-empting that of the
   * <code>ThreadGroup</code>.
   *
   * @@param h the handler to use for this thread.
   * @@throws SecurityException if the current thread can't modify this thread.
   * @@since 1.5 
   */
  public void setUncaughtExceptionHandler(UncaughtExceptionHandler h)
  {
    SecurityManager sm = SecurityManager.current; // Be thread-safe.
    if (sm != null)
      sm.checkAccess(this);    
    exceptionHandler = h;
  }

  /** 
   * <p>
   * Returns the handler used when this thread terminates due to an
   * uncaught exception.  The handler used is determined by the following:
   * </p>
   * <ul>
   * <li>If this thread has its own handler, this is returned.</li>
   * <li>If not, then the handler of the thread's <code>ThreadGroup</code>
   * object is returned.</li>
   * <li>If both are unavailable, then <code>null</code> is returned
   *     (which can only happen when the thread was terminated since
   *      then it won't have an associated thread group anymore).</li>
   * </ul>
   * 
   * @@return the appropriate <code>UncaughtExceptionHandler</code> or
   *         <code>null</code> if one can't be obtained.
   * @@since 1.5 
   */
  public UncaughtExceptionHandler getUncaughtExceptionHandler()
  {
    return exceptionHandler != null ? exceptionHandler : group;
  }

  /** 
   * <p>
   * Sets the default uncaught exception handler used when one isn't
   * provided by the thread or its associated <code>ThreadGroup</code>.
   * This exception handler is used when the thread itself does not
   * have an exception handler, and the thread's <code>ThreadGroup</code>
   * does not override this default mechanism with its own.  As the group
   * calls this handler by default, this exception handler should not defer
   * to that of the group, as it may lead to infinite recursion.
   * </p>
   * <p>
   * Uncaught exception handlers are used when a thread terminates due to
   * an uncaught exception.  Replacing this handler allows default code to
   * be put in place for all threads in order to handle this eventuality.
   * </p>
   *
   * @@param h the new default uncaught exception handler to use.
   * @@throws SecurityException if a security manager is present and
   *                           disallows the runtime permission
   *                           "setDefaultUncaughtExceptionHandler".
   * @@since 1.5 
   */
  public static void 
    setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler h)
  {
    SecurityManager sm = SecurityManager.current; // Be thread-safe.
    if (sm != null)
      sm.checkPermission(new RuntimePermission("setDefaultUncaughtExceptionHandler"));    
    defaultHandler = h;
  }

  /** 
   * Returns the handler used by default when a thread terminates
   * unexpectedly due to an exception, or <code>null</code> if one doesn't
   * exist.
   *
   * @@return the default uncaught exception handler.
   * @@since 1.5 
   */
  public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()
  {
    return defaultHandler;
  }
  
  /** 
   * Returns the unique identifier for this thread.  This ID is generated
   * on thread creation, and may be re-used on its death.
   *
   * @@return a positive long number representing the thread's ID.
   * @@since 1.5 
   */
  public long getId()
  {
    return threadId;
  }

  /**
   * <p>
   * This interface is used to handle uncaught exceptions
   * which cause a <code>Thread</code> to terminate.  When
   * a thread, t, is about to terminate due to an uncaught
   * exception, the virtual machine looks for a class which
   * implements this interface, in order to supply it with
   * the dying thread and its uncaught exception.
   * </p>
   * <p>
   * The virtual machine makes two attempts to find an
   * appropriate handler for the uncaught exception, in
   * the following order:
   * </p>
   * <ol>
   * <li>
   * <code>t.getUncaughtExceptionHandler()</code> --
   * the dying thread is queried first for a handler
   * specific to that thread.
   * </li>
   * <li>
   * <code>t.getThreadGroup()</code> --
   * the thread group of the dying thread is used to
   * handle the exception.  If the thread group has
   * no special requirements for handling the exception,
   * it may simply forward it on to
   * <code>Thread.getDefaultUncaughtExceptionHandler()</code>,
   * the default handler, which is used as a last resort.
   * </li>
   * </ol>
   * <p>
   * The first handler found is the one used to handle
   * the uncaught exception.
   * </p>
   *
   * @@author Tom Tromey <tromey@@redhat.com>
   * @@author Andrew John Hughes <gnu_andrew@@member.fsf.org>
   * @@since 1.5
   * @@see Thread#getUncaughtExceptionHandler()
   * @@see Thread#setUncaughtExceptionHandler(UncaughtExceptionHandler)
   * @@see Thread#getDefaultUncaughtExceptionHandler()
   * @@see
   * Thread#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)
   */
  public interface UncaughtExceptionHandler
  {
    /**
     * Invoked by the virtual machine with the dying thread
     * and the uncaught exception.  Any exceptions thrown
     * by this method are simply ignored by the virtual
     * machine.
     *
     * @@param thr the dying thread.
     * @@param exc the uncaught exception.
     */
    void uncaughtException(Thread thr, Throwable exc);
  }

  /** 
   * <p>
   * Represents the current state of a thread, according to the VM rather
   * than the operating system.  It can be one of the following:
   * </p>
   * <ul>
   * <li>NEW -- The thread has just been created but is not yet running.</li>
   * <li>RUNNABLE -- The thread is currently running or can be scheduled
   * to run.</li>
   * <li>BLOCKED -- The thread is blocked waiting on an I/O operation
   * or to obtain a lock.</li>
   * <li>WAITING -- The thread is waiting indefinitely for another thread
   * to do something.</li>
   * <li>TIMED_WAITING -- The thread is waiting for a specific amount of time
   * for another thread to do something.</li>
   * <li>TERMINATED -- The thread has exited.</li>
   * </ul>
   *
   * @@since 1.5 
   */
  public enum State
  {
    BLOCKED, NEW, RUNNABLE, TERMINATED, TIMED_WAITING, WAITING;

    /**
     * For compatability with Sun's JDK
     */
    private static final long serialVersionUID = 605505746047245783L;
  }


  /**
   * Returns the current state of the thread.  This
   * is designed for monitoring thread behaviour, rather
   * than for synchronization control.
   *
   * @@return the current thread state.
   */
  public State getState()
  {
    VMThread t = vmThread;
    if (t != null)
      return State.valueOf(t.getState());
    if (group == null)
      return State.TERMINATED;
    return State.NEW;
  }

  /**
   * <p>
   * Returns a map of threads to stack traces for each
   * live thread.  The keys of the map are {@@link Thread}
   * objects, which map to arrays of {@@link StackTraceElement}s.
   * The results obtained from Calling this method are
   * equivalent to calling {@@link getStackTrace()} on each
   * thread in succession.  Threads may be executing while
   * this takes place, and the results represent a snapshot
   * of the thread at the time its {@@link getStackTrace()}
   * method is called.
   * </p>
   * <p>
   * The stack trace information contains the methods called
   * by the thread, with the most recent method forming the
   * first element in the array.  The array will be empty
   * if the virtual machine can not obtain information on the
   * thread. 
   * </p>
   * <p>
   * To execute this method, the current security manager
   * (if one exists) must allow both the
   * <code>"getStackTrace"</code> and
   * <code>"modifyThreadGroup"</code> {@@link RuntimePermission}s.
   * </p>
   * 
   * @@return a map of threads to arrays of {@@link StackTraceElement}s.
   * @@throws SecurityException if a security manager exists, and
   *                           prevents either or both the runtime
   *                           permissions specified above.
   * @@since 1.5
   * @@see #getStackTrace()
   */
  public static Map<Thread, StackTraceElement[]> getAllStackTraces()
  {
    ThreadGroup group = currentThread().group;
    while (group.getParent() != null)
      group = group.getParent();
    int arraySize = group.activeCount();
    Thread[] threadList = new Thread[arraySize];
    int filled = group.enumerate(threadList);
    while (filled == arraySize)
      {
	arraySize *= 2;
	threadList = new Thread[arraySize];
	filled = group.enumerate(threadList);
      }
    Map traces = new HashMap();
    for (int a = 0; a < filled; ++a)
      traces.put(threadList[a],
		 threadList[a].getStackTrace());
    return traces;
  }

  /**
   * <p>
   * Returns an array of {@@link StackTraceElement}s
   * representing the current stack trace of this thread.
   * The first element of the array is the most recent
   * method called, and represents the top of the stack.
   * The elements continue in this order, with the last
   * element representing the bottom of the stack.
   * </p>
   * <p>
   * A zero element array is returned for threads which
   * have not yet started (and thus have not yet executed
   * any methods) or for those which have terminated.
   * Where the virtual machine can not obtain a trace for
   * the thread, an empty array is also returned.  The
   * virtual machine may also omit some methods from the
   * trace in non-zero arrays.
   * </p>
   * <p>
   * To execute this method, the current security manager
   * (if one exists) must allow both the
   * <code>"getStackTrace"</code> and
   * <code>"modifyThreadGroup"</code> {@@link RuntimePermission}s.
   * </p>
   *
   * @@return a stack trace for this thread.
   * @@throws SecurityException if a security manager exists, and
   *                           prevents the use of the
   *                           <code>"getStackTrace"</code>
   *                           permission.
   * @@since 1.5
   * @@see #getAllStackTraces()
   */
  public StackTraceElement[] getStackTrace()
  {
    SecurityManager sm = SecurityManager.current; // Be thread-safe.
    if (sm != null)
      sm.checkPermission(new RuntimePermission("getStackTrace"));
    ThreadMXBean bean = ManagementFactory.getThreadMXBean();
    ThreadInfo info = bean.getThreadInfo(threadId, Integer.MAX_VALUE);
    return info.getStackTrace();
  }
d1842 6
@


1.1
log
@First batch of OpenJDK integration code.
@
text
@@

