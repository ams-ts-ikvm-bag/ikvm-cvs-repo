head	1.10;
access;
symbols
	v8_1_5717_0:1.10
	v8_1:1.10.0.4
	v8_0_5449_1:1.10
	v8_0_5449_0:1.10
	v8_0:1.10.0.2
	v7_4_5196_0:1.9
	v7_4:1.9.0.2
	v7_3:1.8.0.8
	v7_2_4630_6:1.8
	v7_2_4630_5:1.8
	v7_2_4630_4:1.8
	v7_2_4630_3:1.8
	v7_2_4630_2:1.8
	v7_2_4630_1:1.8
	v7_2:1.8.0.6
	v7_1_4532_2:1.8
	v7_1_4532_1:1.8
	v7_1_4532_0:1.8
	v7_1:1.8.0.4
	v7_0_4335_3:1.8
	v7_0_4335_2:1.8
	v7_0_4335_1:1.8
	v7_0_4335_0:1.8
	v7_0:1.8.0.2
	v0_40_0_6:1.4
	v0_40_0_5:1.4
	v0_36_0_14:1.2
	v0_44_0_6:1.4
	v0_44_0_5:1.4
	v0_44_0_4:1.4
	v0_44_0_3:1.4
	v0_44_0_2:1.4
	v0_42_0_7:1.4
	v0_44_0_1:1.4
	v0_44_0_0:1.4
	v0_44:1.4.0.8
	v0_42_0_6:1.4
	v0_42_0_5:1.4
	v0_42_0_4:1.4
	v0_42_0_3:1.4
	v0_42_0_2:1.4
	v0_42_0_1:1.4
	v0_42_0_0:1.4
	v0_42:1.4.0.6
	v0_40_0_3:1.4
	v0_40_0_2:1.4
	v0_40_0_1:1.4
	v0_40_0_0:1.4
	v0_40:1.4.0.4
	v0_36_0_13:1.2
	v0_38_0_1:1.4
	v0_38_0_0:1.4
	v0_38:1.4.0.2
	v0_36_0_9:1.2
	v0_36_0_7:1.2
	v0_36_0_5:1.2
	v0_36_0_4:1.2
	v0_36_0_3:1.2
	v0_36_0_2:1.2
	v0_36_0_1:1.2
	v0_36_0_0:1.2
	v0_36:1.2.0.2;
locks; strict;
comment	@# @;


1.10
date	2014.05.19.12.43.39;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.14.14.04.06;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2011.08.29.09.45.54;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2011.08.29.08.43.45;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.09.06.55.31;	author jfrijters;	state dead;
branches;
next	1.5;

1.5
date	2010.08.27.06.21.56;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.13.09.01.24;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.11.09.05.24;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2007.07.18.05.46.38;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.12.08.40.33;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.10
log
@First part of OpenJDK 8 integration.
@
text
@/*
 * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.net;

import java.io.*;
import java.security.PrivilegedAction;

/*
 * This class PlainSocketImpl simply delegates to the appropriate real
 * SocketImpl. We do this because PlainSocketImpl is already extended
 * by SocksSocketImpl.
 * <p>
 * There are two possibilities for the real SocketImpl,
 * TwoStacksPlainSocketImpl or DualStackPlainSocketImpl. We use
 * DualStackPlainSocketImpl on systems that have a dual stack
 * TCP implementation. Otherwise we create an instance of
 * TwoStacksPlainSocketImpl and delegate to it.
 *
 * @@author Chris Hegarty
 */

class PlainSocketImpl extends AbstractPlainSocketImpl
{
    private AbstractPlainSocketImpl impl;

    /* the windows version. */
    private static float version;

    /* java.net.preferIPv4Stack */
    private static boolean preferIPv4Stack = false;

    /* If the version supports a dual stack TCP implementation */
    private static boolean useDualStackImpl = false;

    /* sun.net.useExclusiveBind */
    private static String exclBindProp;

    /* True if exclusive binding is on for Windows */
    private static boolean exclusiveBind = true;

    static {
        java.security.AccessController.doPrivileged( new PrivilegedAction<Object>() {
                public Object run() {
                    version = 0;
                    try {
                        version = Float.parseFloat(System.getProperties().getProperty("os.version"));
                        preferIPv4Stack = Boolean.parseBoolean(
                                          System.getProperties().getProperty("java.net.preferIPv4Stack"));
                        exclBindProp = System.getProperty("sun.net.useExclusiveBind");
                    } catch (NumberFormatException e ) {
                        assert false : e;
                    }
                    return null; // nothing to return
                } });

        String ipv6 = ikvm.internal.Util.SafeGetEnvironmentVariable("IKVM_IPV6");
        if (ipv6 != null) {
            try {
                if ((Integer.parseInt(ipv6) & 4) == 0) {
                    preferIPv4Stack = true;
                } else {
                    useDualStackImpl = true;
                }
            } catch (NumberFormatException _) {
            }
        } else if (!InetAddressImplFactory.isIPv6Supported()) {
            preferIPv4Stack = true;
        }

        // (version >= 6.0) implies Vista or greater.
        if (version >= 6.0 && !preferIPv4Stack) {
                useDualStackImpl = true;
        }

        if (exclBindProp != null) {
            // sun.net.useExclusiveBind is true
            exclusiveBind = exclBindProp.length() == 0 ? true
                    : Boolean.parseBoolean(exclBindProp);
        } else if (version < 6.0) {
            exclusiveBind = false;
        }
    }

    /**
     * Constructs an empty instance.
     */
    PlainSocketImpl() {
        if (useDualStackImpl) {
            impl = new DualStackPlainSocketImpl(exclusiveBind);
        } else {
            impl = new TwoStacksPlainSocketImpl(exclusiveBind);
        }
    }

    /**
     * Constructs an instance with the given file descriptor.
     */
    PlainSocketImpl(FileDescriptor fd) {
        if (useDualStackImpl) {
            impl = new DualStackPlainSocketImpl(fd, exclusiveBind);
        } else {
            impl = new TwoStacksPlainSocketImpl(fd, exclusiveBind);
        }
    }

    // Override methods in SocketImpl that access impl's fields.

    protected FileDescriptor getFileDescriptor() {
        return impl.getFileDescriptor();
    }

    protected InetAddress getInetAddress() {
        return impl.getInetAddress();
    }

    protected int getPort() {
        return impl.getPort();
    }

    protected int getLocalPort() {
        return impl.getLocalPort();
    }

    void setSocket(Socket soc) {
        impl.setSocket(soc);
    }

    Socket getSocket() {
        return impl.getSocket();
    }

    void setServerSocket(ServerSocket soc) {
        impl.setServerSocket(soc);
    }

    ServerSocket getServerSocket() {
        return impl.getServerSocket();
    }

    public String toString() {
        return impl.toString();
    }

    // Override methods in AbstractPlainSocketImpl that access impl's fields.

    protected synchronized void create(boolean stream) throws IOException {
        impl.create(stream);

        // set fd to delegate's fd to be compatible with older releases
        this.fd = impl.fd;
    }

    protected void connect(String host, int port)
        throws UnknownHostException, IOException
    {
        impl.connect(host, port);
    }

    protected void connect(InetAddress address, int port) throws IOException {
        impl.connect(address, port);
    }

    protected void connect(SocketAddress address, int timeout) throws IOException {
        impl.connect(address, timeout);
    }

    public void setOption(int opt, Object val) throws SocketException {
        impl.setOption(opt, val);
    }

    public Object getOption(int opt) throws SocketException {
        return impl.getOption(opt);
    }

    synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
        impl.doConnect(address, port, timeout);
    }

    protected synchronized void bind(InetAddress address, int lport)
        throws IOException
    {
        impl.bind(address, lport);
    }

    protected synchronized void accept(SocketImpl s) throws IOException {
        if (s instanceof PlainSocketImpl) {
            // pass in the real impl not the wrapper.
            SocketImpl delegate = ((PlainSocketImpl)s).impl;
            delegate.address = new InetAddress();
            delegate.fd = new FileDescriptor();
            impl.accept(delegate);
            // set fd to delegate's fd to be compatible with older releases
            s.fd = delegate.fd;
        } else {
            impl.accept(s);
        }
    }

    void setFileDescriptor(FileDescriptor fd) {
        impl.setFileDescriptor(fd);
    }

    void setAddress(InetAddress address) {
        impl.setAddress(address);
    }

    void setPort(int port) {
        impl.setPort(port);
    }

    void setLocalPort(int localPort) {
        impl.setLocalPort(localPort);
    }

    protected synchronized InputStream getInputStream() throws IOException {
        return impl.getInputStream();
    }

    void setInputStream(SocketInputStream in) {
        impl.setInputStream(in);
    }

    protected synchronized OutputStream getOutputStream() throws IOException {
        return impl.getOutputStream();
    }

    protected void close() throws IOException {
        try {
            impl.close();
        } finally {
            // set fd to delegate's fd to be compatible with older releases
            this.fd = null;
        }
    }

    void reset() throws IOException {
        try {
            impl.reset();
        } finally {
            // set fd to delegate's fd to be compatible with older releases
            this.fd = null;
        }
    }

    protected void shutdownInput() throws IOException {
        impl.shutdownInput();
    }

    protected void shutdownOutput() throws IOException {
        impl.shutdownOutput();
    }

    protected void sendUrgentData(int data) throws IOException {
        impl.sendUrgentData(data);
    }

    FileDescriptor acquireFD() {
        return impl.acquireFD();
    }

    void releaseFD() {
        impl.releaseFD();
    }

    public boolean isConnectionReset() {
        return impl.isConnectionReset();
    }

    public boolean isConnectionResetPending() {
        return impl.isConnectionResetPending();
    }

    public void setConnectionReset() {
        impl.setConnectionReset();
    }

    public void setConnectionResetPending() {
        impl.setConnectionResetPending();
    }

    public boolean isClosedOrPending() {
        return impl.isClosedOrPending();
    }

    public int getTimeout() {
        return impl.getTimeout();
    }

    // Override methods in AbstractPlainSocketImpl that need to be implemented.

    void socketCreate(boolean isServer) throws IOException {
        impl.socketCreate(isServer);
    }

    void socketConnect(InetAddress address, int port, int timeout)
        throws IOException {
        impl.socketConnect(address, port, timeout);
    }

    void socketBind(InetAddress address, int port)
        throws IOException {
        impl.socketBind(address, port);
    }

    void socketListen(int count) throws IOException {
        impl.socketListen(count);
    }

    void socketAccept(SocketImpl s) throws IOException {
        impl.socketAccept(s);
    }

    int socketAvailable() throws IOException {
        return impl.socketAvailable();
    }

    void socketClose0(boolean useDeferredClose) throws IOException {
        impl.socketClose0(useDeferredClose);
    }

    void socketShutdown(int howto) throws IOException {
        impl.socketShutdown(howto);
    }

    void socketSetOption(int cmd, boolean on, Object value)
        throws SocketException {
        impl.socketSetOption(cmd, on, value);
    }

    int socketGetOption(int opt, Object iaContainerObj) throws SocketException {
        return impl.socketGetOption(opt, iaContainerObj);
    }

    void socketSendUrgentData(int data) throws IOException {
        impl.socketSendUrgentData(data);
    }
}
@


1.9
log
@Merged OpenJDK 7u40 changes to use SO_EXCLUSIVEADDRUSE for stream sockets that don't use SO_REUSEADDR.
@
text
@d2 1
a2 1
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
d208 11
a218 8
        // pass in the real impl not the wrapper.
        SocketImpl delegate = ((PlainSocketImpl)s).impl;
        delegate.address = new InetAddress();
        delegate.fd = new FileDescriptor();
        impl.accept(delegate);

        // set fd to delegate's fd to be compatible with older releases
        s.fd = delegate.fd;
d349 1
a349 1
        socketSetOption(cmd, on, value);
@


1.8
log
@Use IPv4 (two stacks) implementation when IPv6 is not available and added IKVM_IPV6 environment support to override.
@
text
@d57 6
d71 1
d94 9
a102 1
            useDualStackImpl = true;
d111 1
a111 1
            impl = new DualStackPlainSocketImpl();
d113 1
a113 1
            impl = new TwoStacksPlainSocketImpl();
d122 1
a122 1
            impl = new DualStackPlainSocketImpl(fd);
d124 1
a124 1
            impl = new TwoStacksPlainSocketImpl(fd);
@


1.7
log
@Prepare for forking.
@
text
@d71 14
@


1.6
log
@Implemented IPv6 support for java.net package APIs.
@
text
@d2 1
a2 1
 * Copyright 1995-2006 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
d25 1
d27 2
a28 1
package java.net;
d30 10
a39 25
import cli.System.Net.IPAddress;
import cli.System.Net.IPEndPoint;
import cli.System.Net.Sockets.LingerOption;
import cli.System.Net.Sockets.SelectMode;
import cli.System.Net.Sockets.SocketOptionName;
import cli.System.Net.Sockets.SocketOptionLevel;
import cli.System.Net.Sockets.SocketFlags;
import cli.System.Net.Sockets.SocketType;
import cli.System.Net.Sockets.ProtocolType;
import cli.System.Net.Sockets.AddressFamily;
import cli.System.Net.Sockets.SocketShutdown;
import ikvm.lang.CIL;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.InterruptedIOException;
import java.io.FileDescriptor;
import java.io.ByteArrayOutputStream;

import sun.net.ConnectionResetException;

/**
 * Default Socket Implementation. This implementation does
 * not implement any security checks.
 * Note this class should <b>NOT</b> be public.
d41 1
a41 2
 * @@author  Steven B. Byrne
 * @@version 1.73, 05/05/07
d43 2
a44 2
@@ikvm.lang.Internal
public class PlainSocketImpl extends SocketImpl
d46 30
a75 49
    private cli.System.Net.Sockets.Socket netSocket;
    /* instance variable for SO_TIMEOUT */
    int timeout;   // timeout in millisec
    // traffic class
    private int trafficClass;

    private boolean shut_rd = false;
    private boolean shut_wr = false;
    
    private SocketInputStream socketInputStream = null;

    /* number of threads using the FileDescriptor */
    private int fdUseCount = 0;

    /* lock when increment/decrementing fdUseCount */
    private Object fdLock = new Object();

    /* indicates a close is pending on the file descriptor */
    private boolean closePending = false;

    /* indicates connection reset state */
    private int CONNECTION_NOT_RESET = 0;
    private int CONNECTION_RESET_PENDING = 1;
    private int CONNECTION_RESET = 2;
    private int resetState;
    private Object resetLock = new Object();

    /* second fd, used for ipv6 on windows only.
     * fd1 is used for listeners and for client sockets at initialization
     * until the socket is connected. Up to this point fd always refers
     * to the ipv4 socket and fd1 to the ipv6 socket. After the socket
     * becomes connected, fd always refers to the connected socket 
     * (either v4 or v6) and fd1 is closed.
     *
     * For ServerSockets, fd always refers to the v4 listener and 
     * fd1 the v6 listener.
     */
    private FileDescriptor fd1;
    /*
     * Needed for ipv6 on windows because we need to know
     * if the socket is bound to ::0 or 0.0.0.0, when a caller
     * asks for it. Otherwise we don't know which socket to ask.
     */
    private InetAddress anyLocalBoundAddr=null;
 
    /* to prevent starvation when listening on two sockets, this is
     * is used to hold the id of the last socket we accepted on.
     */
    private int lastfd = -1;
d80 7
a86 1
    PlainSocketImpl() { }
d89 1
a89 2
     * Creates a socket with a boolean that specifies whether this
     * is a stream socket (true) or an unconnected UDP socket (false).
d91 48
d140 4
a143 7
        fd = new FileDescriptor();
        fd1 = new FileDescriptor();
        socketCreate(stream);
        if (socket != null)
            socket.setCreated();
        if (serverSocket != null)
            serverSocket.setCreated();
a145 6
    /**
     * Creates a socket and connects it to the specified port on
     * the specified host.
     * @@param host the specified host
     * @@param port the specified port
     */
d149 1
a149 17
        IOException pending = null;
        try {
            InetAddress address = InetAddress.getByName(host);

            try {
                connectToAddress(address, port, timeout);
                return;
            } catch (IOException e) {
                pending = e;
            }
        } catch (UnknownHostException e) {
            pending = e;
        }

        // everything failed
        close();
        throw pending;
a151 6
    /**
     * Creates a socket and connects it to the specified address on
     * the specified port.
     * @@param address the address
     * @@param port the specified port
     */
d153 1
a153 11
        this.port = port;
        this.address = address;

        try {
            connectToAddress(address, port, timeout);
            return;
        } catch (IOException e) {
            // everything failed
            close();
            throw e;
        }
a155 10
    /**
     * Creates a socket and connects it to the specified address on
     * the specified port.
     * @@param address the address
     * @@param timeout the timeout value in milliseconds, or zero for no timeout.
     * @@throws IOException if connection fails
     * @@throws  IllegalArgumentException if address is null or is a
     *          SocketAddress subclass not supported by this socket
     * @@since 1.4
     */
d157 1
a157 16
        if (address == null || !(address instanceof InetSocketAddress))
            throw new IllegalArgumentException("unsupported address type");
        InetSocketAddress addr = (InetSocketAddress) address;
        if (addr.isUnresolved())
            throw new UnknownHostException(addr.getHostName());
        this.port = addr.getPort();
        this.address = addr.getAddress();

        try {
            connectToAddress(this.address, port, timeout);
            return;
        } catch (IOException e) {
            // everything failed
            close();
            throw e;
        }
d160 2
a161 6
    private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {
        if (address.isAnyLocalAddress()) {
            doConnect(InetAddress.getLocalHost(), port, timeout);
        } else {
            doConnect(address, port, timeout);
        }
a163 67
    public void setOption(int opt, Object val) throws SocketException {
        if (isClosedOrPending()) {
            throw new SocketException("Socket Closed");
        }
        boolean on = true;
        switch (opt) {
            /* check type safety b4 going native.  These should never
             * fail, since only java.Socket* has access to
             * PlainSocketImpl.setOption().
             */
        case SO_LINGER:
            if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean)))
                throw new SocketException("Bad parameter for option");
            if (val instanceof Boolean) {
                /* true only if disabling - enabling should be Integer */
                on = false;
            }
            break;
        case SO_TIMEOUT:
            if (val == null || (!(val instanceof Integer)))
                throw new SocketException("Bad parameter for SO_TIMEOUT");
            int tmp = ((Integer) val).intValue();
            if (tmp < 0)
                throw new IllegalArgumentException("timeout < 0");
            timeout = tmp;
            break;
        case IP_TOS:
             if (val == null || !(val instanceof Integer)) {
                 throw new SocketException("bad argument for IP_TOS");
             }
             trafficClass = ((Integer)val).intValue();
             break;
        case SO_BINDADDR:
            throw new SocketException("Cannot re-bind socket");
        case TCP_NODELAY:
            if (val == null || !(val instanceof Boolean))
                throw new SocketException("bad parameter for TCP_NODELAY");
            on = ((Boolean)val).booleanValue();
            break;
        case SO_SNDBUF:
        case SO_RCVBUF:
            if (val == null || !(val instanceof Integer) ||
                !(((Integer)val).intValue() > 0)) {
                throw new SocketException("bad parameter for SO_SNDBUF " +
                                          "or SO_RCVBUF");
            }
            break;
        case SO_KEEPALIVE:
            if (val == null || !(val instanceof Boolean))
                throw new SocketException("bad parameter for SO_KEEPALIVE");
            on = ((Boolean)val).booleanValue();
            break;
        case SO_OOBINLINE:
            if (val == null || !(val instanceof Boolean))
                throw new SocketException("bad parameter for SO_OOBINLINE");
            on = ((Boolean)val).booleanValue();
            break;
        case SO_REUSEADDR:
            if (val == null || !(val instanceof Boolean)) 
                throw new SocketException("bad parameter for SO_REUSEADDR");
            on = ((Boolean)val).booleanValue();
            break;
        default:
            throw new SocketException("unrecognized TCP option: " + opt);
        }
        socketSetOption(opt, on, val);
    }
d165 1
a165 54
        if (isClosedOrPending()) {
            throw new SocketException("Socket Closed");
        }
        if (opt == SO_TIMEOUT) {
            return new Integer(timeout);
        }
        int ret = 0;
        /*
         * The native socketGetOption() knows about 3 options.
         * The 32 bit value it returns will be interpreted according
         * to what we're asking.  A return of -1 means it understands
         * the option but its turned off.  It will raise a SocketException
         * if "opt" isn't one it understands.
         */

        switch (opt) {
        case TCP_NODELAY:
            ret = socketGetOption(opt, null);
            return Boolean.valueOf(ret != -1);
        case SO_OOBINLINE:
            ret = socketGetOption(opt, null);
            return Boolean.valueOf(ret != -1);
        case SO_LINGER:
            ret = socketGetOption(opt, null);
            return (ret == -1) ? Boolean.FALSE: (Object)(new Integer(ret));
        case SO_REUSEADDR:
            ret = socketGetOption(opt, null);
            return Boolean.valueOf(ret != -1);
        case SO_BINDADDR:
            if (fd != null && fd1 != null ) {
                /* must be unbound or else bound to anyLocal */
                return anyLocalBoundAddr;
            }
            InetAddressContainer in = new InetAddressContainer();
            ret = socketGetOption(opt, in); 
            return in.addr;
        case SO_SNDBUF:
        case SO_RCVBUF:
            ret = socketGetOption(opt, null);
            return new Integer(ret);
        case IP_TOS:
            ret = socketGetOption(opt, null);
            if (ret == -1) { // ipv6 tos
                return new Integer(trafficClass);
            } else {
                return new Integer(ret);
            }
        case SO_KEEPALIVE:
            ret = socketGetOption(opt, null);
            return Boolean.valueOf(ret != -1);
        // should never get here
        default:
            return null;
        }
d168 2
a169 26
    /**
     * The workhorse of the connection operation.  Tries several times to
     * establish a connection to the given <host, port>.  If unsuccessful,
     * throws an IOException indicating what went wrong.
     */

    private synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
        try {
            FileDescriptor fd = acquireFD();
            try {
                socketConnect(address, port, timeout);
                // If we have a ref. to the Socket, then sets the flags
                // created, bound & connected to true.
                // This is normally done in Socket.connect() but some
                // subclasses of Socket may call impl.connect() directly!
                if (socket != null) {
                    socket.setBound();
                    socket.setConnected();
                }
            } finally {
                releaseFD();
            }
        } catch (IOException e) {       
            close();
            throw e;
        }
a171 5
    /**
     * Binds the socket to the specified address of the specified local port.
     * @@param address the address
     * @@param port the port
     */
d175 1
a175 8
        socketBind(address, lport);
        if (socket != null)
            socket.setBound();
        if (serverSocket != null)
            serverSocket.setBound();
        if (address.isAnyLocalAddress()) {
            anyLocalBoundAddr = address;
        }
d178 6
a183 7
    /**
     * Listens, for a specified amount of time, for connections.
     * @@param count the amount of time to listen for connections
     */
    protected synchronized void listen(int count) throws IOException {
        socketListen(count);
    }
d185 2
a186 11
    /**
     * Accepts connections.
     * @@param s the connection
     */
    protected synchronized void accept(SocketImpl s) throws IOException {
        FileDescriptor fd = acquireFD();
        try {
            socketAccept(s);
        } finally {
            releaseFD();
        }
d190 1
a190 1
        this.netSocket = fd.getSocket();
d194 1
a194 1
        this.address = address;
d198 1
a198 1
        this.port = port;
d202 1
a202 1
        this.localport = localPort;
a204 3
    /**
     * Gets an InputStream for this socket.
     */
d206 1
a206 10
        if (isClosedOrPending()) {
            throw new IOException("Socket Closed");
        }
        if (shut_rd) {
            throw new IOException("Socket input is shutdown");
        }
        if (socketInputStream == null) {
            socketInputStream = new SocketInputStream(this);
        }
        return socketInputStream;
d210 1
a210 1
        socketInputStream = in;
a212 3
    /**
     * Gets an OutputStream for this socket.
     */
d214 1
a214 7
        if (isClosedOrPending()) {
            throw new IOException("Socket Closed");
        }
        if (shut_wr) {
            throw new IOException("Socket output is shutdown");
        }
        return new SocketOutputStream(this);
d217 6
a222 14
    /**
     * Returns the number of bytes that can be read without blocking.
     */
    protected synchronized int available() throws IOException {
        if (isClosedOrPending()) {
            throw new IOException("Stream closed.");
        }

        /*
         * If connection has been reset then return 0 to indicate
         * there are no buffered bytes.
         */
        if (isConnectionReset()) {
            return 0;
a223 25

        /*
         * If no bytes available and we were previously notified
         * of a connection reset then we move to the reset state.
         *
         * If are notified of a connection reset then check
         * again if there are bytes buffered on the socket. 
         */
        int n = 0;
        try { 
            n = socketAvailable();
            if (n == 0 && isConnectionResetPending()) {
                setConnectionReset();
            }
        } catch (ConnectionResetException exc1) {
            setConnectionResetPending();
            try {
                n = socketAvailable();
                if (n == 0) {
                    setConnectionReset();
                }
            } catch (ConnectionResetException exc2) {
            }
        }
        return n;
a225 44
    /**
     * Closes the socket.
     */
    protected void close() throws IOException {
        synchronized(fdLock) {
            if (fd != null || fd1 != null) {
                if (fdUseCount == 0) {
                    if (closePending) {
                        return;
                    }
                    closePending = true;
                    /*
                     * We close the FileDescriptor in two-steps - first the
                     * "pre-close" which closes the socket but doesn't
                     * release the underlying file descriptor. This operation
                     * may be lengthy due to untransmitted data and a long
                     * linger interval. Once the pre-close is done we do the
                     * actual socket to release the fd.
                     */
                    try {
                        socketPreClose();
                    } finally {
                        socketClose();
                    }
                    fd = null;
                    fd1 = null;
                    return;
                } else {
                    /*
                     * If a thread has acquired the fd and a close
                     * isn't pending then use a deferred close.
                     * Also decrement fdUseCount to signal the last
                     * thread that releases the fd to close it.
                     */
                    if (!closePending) {
                        closePending = true;
                        fdUseCount--;
                        socketPreClose();
                    }
                }
            }
        }
    }
    
d227 5
a231 2
        if (fd != null || fd1 != null) {
            socketClose();
a232 3
        fd = null;
        fd1 = null;
        super.reset();
a234 4

    /**
     * Shutdown read-half of the socket connection;
     */
d236 2
a237 8
      if (fd != null) {
          socketShutdown(SHUT_RD);
          if (socketInputStream != null) {
              socketInputStream.setEOF(true);
          }
          shut_rd = true;
      }
    } 
a238 3
    /**
     * Shutdown write-half of the socket connection;
     */
d240 1
a240 8
      if (fd != null) {
          socketShutdown(SHUT_WR);
          shut_wr = true;
      }
    } 

    protected boolean supportsUrgentData () {
        return true;
d243 2
a244 5
    protected void sendUrgentData (int data) throws IOException {
        if (fd == null) {
            throw new IOException("Socket Closed");
        }
        socketSendUrgentData (data);
d247 2
a248 11
    /*
     * "Acquires" and returns the FileDescriptor for this impl
     *
     * A corresponding releaseFD is required to "release" the
     * FileDescriptor.
     */
    public final FileDescriptor acquireFD() {
        synchronized (fdLock) {
            fdUseCount++;
            return fd;
        }
d251 2
a252 19
    /*
     * "Release" the FileDescriptor for this impl. 
     *
     * If the use count goes to -1 then the socket is closed.
     */
    public final void releaseFD() {
        synchronized (fdLock) {
            fdUseCount--;
            if (fdUseCount == -1) {
                if (fd != null) {
                    try {
                        socketClose();
                    } catch (IOException e) { 
                    } finally {
                        fd = null;
                    }
                }
            }
        }
d256 1
a256 3
        synchronized (resetLock) {
            return (resetState == CONNECTION_RESET);
        }
d260 1
a260 3
        synchronized (resetLock) {
            return (resetState == CONNECTION_RESET_PENDING);
        }
d264 1
a264 3
        synchronized (resetLock) {
            resetState = CONNECTION_RESET;
        }
d268 1
a268 6
        synchronized (resetLock) {
            if (resetState == CONNECTION_NOT_RESET) {
                resetState = CONNECTION_RESET_PENDING;
            }
        }

a270 3
    /*
     * Return true if already closed or close is pending
     */
d272 1
a272 11
        /*
         * Lock on fdLock to ensure that we wait if a
         * close is in progress.
         */
        synchronized (fdLock) {
            if (closePending || (fd == null && fd1 == null)) {
                return true;
            } else {
                return false;
            }
        }
a274 3
    /*
     * Return the current value of SO_TIMEOUT
     */
d276 1
a276 9
        return timeout;
    }

    /*
     * "Pre-close" a socket by dup'ing the file descriptor - this enables
     * the socket to be closed without releasing the file descriptor.
     */
    private void socketPreClose() throws IOException {
        socketClose0(true);
d279 1
a279 70
    /*
     * Close the socket (and release the file descriptor).
     */
    private void socketClose() throws IOException {
        socketClose0(false);
    }

    private void socketCreate(boolean stream) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            if (stream)
            {
                netSocket = new cli.System.Net.Sockets.Socket(AddressFamily.wrap(AddressFamily.InterNetwork), SocketType.wrap(SocketType.Stream), ProtocolType.wrap(ProtocolType.Tcp));
            }
            else
            {
                netSocket = new cli.System.Net.Sockets.Socket(AddressFamily.wrap(AddressFamily.InterNetwork), SocketType.wrap(SocketType.Dgram), ProtocolType.wrap(ProtocolType.Udp));
            }
            fd1 = null;
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
    }

    private void socketConnect(InetAddress address, int port, int timeout) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            IPEndPoint ep = new IPEndPoint(SocketUtil.getAddressFromInetAddress(address), port);
            if (timeout <= 0)
            {
                netSocket.Connect(ep);
            }
            else
            {
                cli.System.IAsyncResult result = netSocket.BeginConnect(ep, null, null);
                if (!result.get_AsyncWaitHandle().WaitOne(timeout, false))
                {
                    netSocket.Close();
                    throw new SocketTimeoutException();
                }
                netSocket.EndConnect(result);
            }
            this.address = address;
            this.port = port;
            if (this.localport == 0)
            {
                this.localport = ((IPEndPoint)netSocket.get_LocalEndPoint()).get_Port();
            }
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw new ConnectException(x.getMessage());
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
    }
d281 2
a282 25
    private void socketBind(InetAddress address, int localport) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            netSocket.Bind(new IPEndPoint(SocketUtil.getAddressFromInetAddress(address), localport));
            this.address = address;
            if (localport == 0)
            {
                this.localport = ((IPEndPoint)netSocket.get_LocalEndPoint()).get_Port();
            }
            else
            {
                this.localport = localport;
            }
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw new BindException(x.getMessage());
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
d285 3
a287 16
    private void socketListen(int count) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            netSocket.Listen(count);
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
d290 3
a292 28
    private void socketAccept(SocketImpl s) throws IOException
    {
        PlainSocketImpl impl = (PlainSocketImpl)s;
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            if (timeout > 0 && !netSocket.Poll(Math.min(timeout, Integer.MAX_VALUE / 1000) * 1000,
                SelectMode.wrap(SelectMode.SelectRead)))
            {
                throw new SocketTimeoutException("Accept timed out");
            }
            cli.System.Net.Sockets.Socket accept = netSocket.Accept();
            impl.netSocket = accept;
            IPEndPoint remoteEndPoint = ((IPEndPoint)accept.get_RemoteEndPoint());
            impl.address = SocketUtil.getInetAddressFromIPEndPoint(remoteEndPoint);
            impl.port = remoteEndPoint.get_Port();
            impl.localport = ((IPEndPoint)accept.get_LocalEndPoint()).get_Port();
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            // TODO we may have to throw java.io.InterruptedIOException here
            throw new SocketException("Socket is closed");
        }
d295 2
a296 16
    private int socketAvailable() throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            return netSocket.get_Available();
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
d299 2
a300 19
    private void socketClose0(boolean useDeferredClose) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            if (netSocket != null)
            {
                netSocket.Close();
            }
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
d303 2
a304 16
    private void socketShutdown(int howto) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            netSocket.Shutdown(SocketShutdown.wrap(howto == SHUT_RD ? SocketShutdown.Receive : SocketShutdown.Send));
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
d307 2
a308 46
    private void socketSetOption(int cmd, boolean on, Object value) throws SocketException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            switch (cmd)
            {
                case SocketOptions.SO_LINGER:
                    if (on)
                    {
                        netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.Linger), new LingerOption(true, ((Integer)value).intValue()));
                    }
                    else
                    {
                        netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.Linger), new LingerOption(false, 0));
                    }
                    break;
                case SocketOptions.SO_TIMEOUT:
                    if (serverSocket == null)
                    {
                        netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReceiveTimeout), timeout <= 5000 ? 0 : timeout);
                    }
                    break;
                case SocketOptions.TCP_NODELAY:
                    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Tcp), SocketOptionName.wrap(SocketOptionName.NoDelay), on ? 1 : 0);
                    break;
                case SocketOptions.SO_KEEPALIVE:
                    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.KeepAlive), on ? 1 : 0);
                    break;
                case SocketOptions.SO_OOBINLINE:
                    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.OutOfBandInline), on ? 1 : 0);
                    break;
                default:
                    SocketUtil.setCommonSocketOption(netSocket, cmd, on, value);
                    break;
            }
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw new SocketException(x.getMessage());
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
d311 2
a312 35
    private int socketGetOption(int opt, Object iaContainerObj) throws SocketException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            switch (opt)
            {
                case SocketOptions.TCP_NODELAY:
                    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Tcp), SocketOptionName.wrap(SocketOptionName.NoDelay))) == 0 ? -1 : 1;
                case SocketOptions.SO_KEEPALIVE:
                    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.KeepAlive))) == 0 ? -1 : 1;
                case SocketOptions.SO_LINGER:
                    {
                        LingerOption linger = (LingerOption)netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.Linger));
                        if (linger.get_Enabled())
                        {
                            return linger.get_LingerTime();
                        }
                        return -1;
                    }
                case SocketOptions.SO_OOBINLINE:
                    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.OutOfBandInline))) == 0 ? -1 : 1;
                default:
                    return SocketUtil.getCommonSocketOption(netSocket, opt, iaContainerObj);
            }
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw new SocketException(x.getMessage());
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
d315 3
a317 17
    private void socketSendUrgentData(int data) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            byte[] oob = { (byte)data };
            netSocket.Send(oob, SocketFlags.wrap(SocketFlags.OutOfBand));
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
d320 2
a321 33
    // used by SocketInputStream
    int read(byte[] buf, int offset, int len, int timeout) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            if (timeout > 0 && !netSocket.Poll(Math.min(timeout, Integer.MAX_VALUE / 1000) * 1000,
                SelectMode.wrap(SelectMode.SelectRead)))
            {
                throw new SocketTimeoutException();
            }
            int read = netSocket.Receive(buf, offset, len, SocketFlags.wrap(SocketFlags.None));
            return read == 0 ? -1 : read;
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            if (x.get_ErrorCode() == SocketUtil.WSAESHUTDOWN)
            {
                // the socket was shutdown, so we have to return EOF
                return -1;
            }
            else if (x.get_ErrorCode() == SocketUtil.WSAEWOULDBLOCK)
            {
                // nothing to read and would block
                return 0;
            }
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
d324 2
a325 17
    // used by SocketOutputStream
    int write(byte[] buf, int offset, int len) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            return netSocket.Send(buf, offset, len, SocketFlags.wrap(SocketFlags.None));
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
a326 7

    public final static int SHUT_RD = 0;
    public final static int SHUT_WR = 1;
}

class InetAddressContainer {
    InetAddress addr;
@


1.5
log
@Moved shared socket functionality from PlainSocketImpl.java to SocketUtil.java.
@
text
@@


1.4
log
@Integrated OpenJDK 6 b10.
@
text
@a59 128
    // Winsock Error Codes
    public static final int WSAEWOULDBLOCK = 10035;
    private static final int WSAEADDRINUSE = 10048;
    private static final int WSAENETUNREACH = 10051;
    public static final int WSAESHUTDOWN = 10058;
    private static final int WSAETIMEDOUT = 10060;
    private static final int WSAECONNREFUSED = 10061;
    private static final int WSAEHOSTUNREACH = 10065;
    private static final int WSAHOST_NOT_FOUND = 11001;

    public static IOException convertSocketExceptionToIOException(cli.System.Net.Sockets.SocketException x) throws IOException
    {
        switch (x.get_ErrorCode())
        {
            case WSAEADDRINUSE:
                return new BindException(x.getMessage());
            case WSAENETUNREACH:
            case WSAEHOSTUNREACH:
                return new NoRouteToHostException(x.getMessage());
            case WSAETIMEDOUT:
                return new SocketTimeoutException(x.getMessage());
            case WSAECONNREFUSED:
                return new PortUnreachableException(x.getMessage());
            case WSAHOST_NOT_FOUND:
                return new UnknownHostException(x.getMessage());
            default:
                return new SocketException(x.getMessage() + "\nError Code: " + x.get_ErrorCode());
        }
    }

    public static IPAddress getAddressFromInetAddress(InetAddress addr)
    {
        byte[] b = addr.getAddress();
        if (b.length == 16)
        {
            // FXBUG in .NET 1.1 you can only construct IPv6 addresses (not IPv4) with this constructor
            // (according to the documentation this was fixed in .NET 2.0)
            return new IPAddress(b);
        }
        else
        {
            return new IPAddress((((b[3] & 0xff) << 24) + ((b[2] & 0xff) << 16) + ((b[1] & 0xff) << 8) + (b[0] & 0xff)) & 0xffffffffL);
        }
    }

    public static InetAddress getInetAddressFromIPEndPoint(IPEndPoint endpoint)
    {
        try
        {
            return InetAddress.getByAddress(endpoint.get_Address().GetAddressBytes());
        }
        catch (UnknownHostException x)
        {
            // this exception only happens if the address byte array is of invalid length, which cannot happen unless
            // the .NET socket returns a bogus address
            throw (InternalError)new InternalError().initCause(x);
        }
    }

    static void setCommonSocketOption(cli.System.Net.Sockets.Socket netSocket, int cmd, boolean on, Object value) throws SocketException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            switch (cmd)
            {
                case SocketOptions.SO_REUSEADDR:
                    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReuseAddress), on ? 1 : 0);
                    break;
                case SocketOptions.SO_SNDBUF:
                    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.SendBuffer), ((Integer)value).intValue());
                    break;
                case SocketOptions.SO_RCVBUF:
                    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReceiveBuffer), ((Integer)value).intValue());
                    break;
                case SocketOptions.IP_TOS:
                    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.IP), SocketOptionName.wrap(SocketOptionName.TypeOfService), ((Integer)value).intValue());
                    break;
                case SocketOptions.SO_BINDADDR: // read-only
                default:
                    throw new SocketException("Invalid socket option: " + cmd);
            }
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw new SocketException(x.getMessage());
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
    }

    static int getCommonSocketOption(cli.System.Net.Sockets.Socket netSocket, int opt, Object iaContainerObj) throws SocketException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            switch (opt)
            {
                case SocketOptions.SO_REUSEADDR:
                    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReuseAddress))) == 0 ? -1 : 1;
                case SocketOptions.SO_SNDBUF:
                    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.SendBuffer)));
                case SocketOptions.SO_RCVBUF:
                    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReceiveBuffer)));
                case SocketOptions.IP_TOS:
                    // TODO handle IPv6 here
                    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.IP), SocketOptionName.wrap(SocketOptionName.TypeOfService)));
                case SocketOptions.SO_BINDADDR:
                    ((InetAddressContainer)iaContainerObj).addr = getInetAddressFromIPEndPoint((IPEndPoint)netSocket.get_LocalEndPoint());
                    return 0;
                default:
                    throw new SocketException("Invalid socket option: " + opt);
            }
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw new SocketException(x.getMessage());
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
    }

d702 1
a702 1
            throw convertSocketExceptionToIOException(x);
d716 1
a716 1
            IPEndPoint ep = new IPEndPoint(getAddressFromInetAddress(address), port);
d754 1
a754 1
            netSocket.Bind(new IPEndPoint(getAddressFromInetAddress(address), localport));
d785 1
a785 1
            throw convertSocketExceptionToIOException(x);
d808 1
a808 1
            impl.address = getInetAddressFromIPEndPoint(remoteEndPoint);
d814 1
a814 1
            throw convertSocketExceptionToIOException(x);
d833 1
a833 1
            throw convertSocketExceptionToIOException(x);
d854 1
a854 1
            throw convertSocketExceptionToIOException(x);
d872 1
a872 1
            throw convertSocketExceptionToIOException(x);
d914 1
a914 1
                    setCommonSocketOption(netSocket, cmd, on, value);
d952 1
a952 1
                    return getCommonSocketOption(netSocket, opt, iaContainerObj);
d976 1
a976 1
            throw convertSocketExceptionToIOException(x);
d1001 1
a1001 1
            if (x.get_ErrorCode() == WSAESHUTDOWN)
d1006 1
a1006 1
            else if (x.get_ErrorCode() == WSAEWOULDBLOCK)
d1011 1
a1011 1
            throw convertSocketExceptionToIOException(x);
d1030 1
a1030 1
            throw convertSocketExceptionToIOException(x);
@


1.3
log
@Converted tabs to spaces.
@
text
@d533 16
@


1.2
log
@Implement SocketChannelImpl & DotNetSelectorImpl.
@
text
@d72 16
a87 16
	switch (x.get_ErrorCode())
	{
	    case WSAEADDRINUSE:
		return new BindException(x.getMessage());
	    case WSAENETUNREACH:
	    case WSAEHOSTUNREACH:
		return new NoRouteToHostException(x.getMessage());
	    case WSAETIMEDOUT:
		return new SocketTimeoutException(x.getMessage());
	    case WSAECONNREFUSED:
		return new PortUnreachableException(x.getMessage());
	    case WSAHOST_NOT_FOUND:
		return new UnknownHostException(x.getMessage());
	    default:
		return new SocketException(x.getMessage() + "\nError Code: " + x.get_ErrorCode());
	}
d92 11
a102 11
	byte[] b = addr.getAddress();
	if (b.length == 16)
	{
	    // FXBUG in .NET 1.1 you can only construct IPv6 addresses (not IPv4) with this constructor
	    // (according to the documentation this was fixed in .NET 2.0)
	    return new IPAddress(b);
	}
	else
	{
	    return new IPAddress((((b[3] & 0xff) << 24) + ((b[2] & 0xff) << 16) + ((b[1] & 0xff) << 8) + (b[0] & 0xff)) & 0xffffffffL);
	}
d107 10
a116 10
	try
	{
	    return InetAddress.getByAddress(endpoint.get_Address().GetAddressBytes());
	}
	catch (UnknownHostException x)
	{
	    // this exception only happens if the address byte array is of invalid length, which cannot happen unless
	    // the .NET socket returns a bogus address
	    throw (InternalError)new InternalError().initCause(x);
	}
d121 31
a151 31
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    switch (cmd)
	    {
		case SocketOptions.SO_REUSEADDR:
		    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReuseAddress), on ? 1 : 0);
		    break;
		case SocketOptions.SO_SNDBUF:
		    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.SendBuffer), ((Integer)value).intValue());
		    break;
		case SocketOptions.SO_RCVBUF:
		    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReceiveBuffer), ((Integer)value).intValue());
		    break;
		case SocketOptions.IP_TOS:
		    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.IP), SocketOptionName.wrap(SocketOptionName.TypeOfService), ((Integer)value).intValue());
		    break;
		case SocketOptions.SO_BINDADDR:	// read-only
		default:
		    throw new SocketException("Invalid socket option: " + cmd);
	    }
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw new SocketException(x.getMessage());
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d156 30
a185 30
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    switch (opt)
	    {
		case SocketOptions.SO_REUSEADDR:
		    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReuseAddress))) == 0 ? -1 : 1;
		case SocketOptions.SO_SNDBUF:
		    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.SendBuffer)));
		case SocketOptions.SO_RCVBUF:
		    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReceiveBuffer)));
		case SocketOptions.IP_TOS:
		    // TODO handle IPv6 here
		    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.IP), SocketOptionName.wrap(SocketOptionName.TypeOfService)));
		case SocketOptions.SO_BINDADDR:
		    ((InetAddressContainer)iaContainerObj).addr = getInetAddressFromIPEndPoint((IPEndPoint)netSocket.get_LocalEndPoint());
		    return 0;
		default:
		    throw new SocketException("Invalid socket option: " + opt);
	    }
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw new SocketException(x.getMessage());
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d248 7
a254 7
	fd = new FileDescriptor();
	fd1 = new FileDescriptor();
	socketCreate(stream);
	if (socket != null)
	    socket.setCreated();
	if (serverSocket != null)
	    serverSocket.setCreated();
d266 17
a282 17
	IOException pending = null;
	try {
	    InetAddress address = InetAddress.getByName(host);

	    try {
		connectToAddress(address, port, timeout);
		return;
	    } catch (IOException e) {
		pending = e;
	    }
	} catch (UnknownHostException e) {
	    pending = e;
	}

	// everything failed
	close();
	throw pending;
d292 2
a293 2
	this.port = port;
	this.address = address;
d295 8
a302 8
	try {
	    connectToAddress(address, port, timeout);
	    return;
	} catch (IOException e) {
	    // everything failed
	    close();
	    throw e;
	}
d316 16
a331 16
	if (address == null || !(address instanceof InetSocketAddress))
	    throw new IllegalArgumentException("unsupported address type");
	InetSocketAddress addr = (InetSocketAddress) address;
	if (addr.isUnresolved())
	    throw new UnknownHostException(addr.getHostName());
	this.port = addr.getPort();
	this.address = addr.getAddress();

	try {
	    connectToAddress(this.address, port, timeout);
	    return;
	} catch (IOException e) {
	    // everything failed
	    close();
	    throw e;
	}
d335 5
a339 5
	if (address.isAnyLocalAddress()) {
	    doConnect(InetAddress.getLocalHost(), port, timeout);
	} else {
	    doConnect(address, port, timeout);
	}
d343 65
a407 65
	if (isClosedOrPending()) {
	    throw new SocketException("Socket Closed");
	}
	boolean on = true;
	switch (opt) {
	    /* check type safety b4 going native.  These should never
	     * fail, since only java.Socket* has access to
	     * PlainSocketImpl.setOption().
	     */
	case SO_LINGER:
	    if (val == null || (!(val instanceof Integer) && !(val instanceof Boolean)))
		throw new SocketException("Bad parameter for option");
	    if (val instanceof Boolean) {
		/* true only if disabling - enabling should be Integer */
		on = false;
	    }
	    break;
	case SO_TIMEOUT:
	    if (val == null || (!(val instanceof Integer)))
		throw new SocketException("Bad parameter for SO_TIMEOUT");
	    int tmp = ((Integer) val).intValue();
	    if (tmp < 0)
		throw new IllegalArgumentException("timeout < 0");
	    timeout = tmp;
	    break;
	case IP_TOS:
	     if (val == null || !(val instanceof Integer)) {
		 throw new SocketException("bad argument for IP_TOS");
	     }
	     trafficClass = ((Integer)val).intValue();
	     break;
	case SO_BINDADDR:
	    throw new SocketException("Cannot re-bind socket");
	case TCP_NODELAY:
	    if (val == null || !(val instanceof Boolean))
		throw new SocketException("bad parameter for TCP_NODELAY");
	    on = ((Boolean)val).booleanValue();
	    break;
	case SO_SNDBUF:
	case SO_RCVBUF:
	    if (val == null || !(val instanceof Integer) ||
		!(((Integer)val).intValue() > 0)) {
		throw new SocketException("bad parameter for SO_SNDBUF " +
					  "or SO_RCVBUF");
	    }
	    break;
	case SO_KEEPALIVE:
	    if (val == null || !(val instanceof Boolean))
		throw new SocketException("bad parameter for SO_KEEPALIVE");
	    on = ((Boolean)val).booleanValue();
	    break;
	case SO_OOBINLINE:
	    if (val == null || !(val instanceof Boolean))
		throw new SocketException("bad parameter for SO_OOBINLINE");
	    on = ((Boolean)val).booleanValue();
	    break;
	case SO_REUSEADDR:
	    if (val == null || !(val instanceof Boolean)) 
	        throw new SocketException("bad parameter for SO_REUSEADDR");
	    on = ((Boolean)val).booleanValue();
	    break;
	default:
	    throw new SocketException("unrecognized TCP option: " + opt);
	}
	socketSetOption(opt, on, val);
d410 37
a446 37
	if (isClosedOrPending()) {
	    throw new SocketException("Socket Closed");
	}
	if (opt == SO_TIMEOUT) {
	    return new Integer(timeout);
	}
	int ret = 0;
	/*
	 * The native socketGetOption() knows about 3 options.
	 * The 32 bit value it returns will be interpreted according
	 * to what we're asking.  A return of -1 means it understands
	 * the option but its turned off.  It will raise a SocketException
	 * if "opt" isn't one it understands.
	 */

	switch (opt) {
	case TCP_NODELAY:
	    ret = socketGetOption(opt, null);
	    return Boolean.valueOf(ret != -1);
	case SO_OOBINLINE:
	    ret = socketGetOption(opt, null);
	    return Boolean.valueOf(ret != -1);
	case SO_LINGER:
	    ret = socketGetOption(opt, null);
	    return (ret == -1) ? Boolean.FALSE: (Object)(new Integer(ret));
	case SO_REUSEADDR:
	    ret = socketGetOption(opt, null);
	    return Boolean.valueOf(ret != -1);
	case SO_BINDADDR:
	    if (fd != null && fd1 != null ) {
		/* must be unbound or else bound to anyLocal */
		return anyLocalBoundAddr;
	    }
	    InetAddressContainer in = new InetAddressContainer();
	    ret = socketGetOption(opt, in); 
	    return in.addr;
	case SO_SNDBUF:
d448 16
a463 16
	    ret = socketGetOption(opt, null);
	    return new Integer(ret);
	case IP_TOS:
	    ret = socketGetOption(opt, null);
	    if (ret == -1) { // ipv6 tos
		return new Integer(trafficClass);
	    } else {
		return new Integer(ret);
	    }
	case SO_KEEPALIVE:
	    ret = socketGetOption(opt, null);
  	    return Boolean.valueOf(ret != -1);
	// should never get here
	default:
	    return null;
	}
d474 18
a491 18
	    FileDescriptor fd = acquireFD();
	    try {
	        socketConnect(address, port, timeout);
		// If we have a ref. to the Socket, then sets the flags
		// created, bound & connected to true.
		// This is normally done in Socket.connect() but some
		// subclasses of Socket may call impl.connect() directly!
		if (socket != null) {
		    socket.setBound();
		    socket.setConnected();
		}
	    } finally {
		releaseFD();
	    }
	} catch (IOException e) {	
	    close();
	    throw e;
	}
d500 1
a500 1
	throws IOException
d502 8
a509 8
	socketBind(address, lport);
	if (socket != null)
	    socket.setBound();
	if (serverSocket != null)
	    serverSocket.setBound();
	if (address.isAnyLocalAddress()) {
	    anyLocalBoundAddr = address;
	}
d517 1
a517 1
	socketListen(count);
d525 6
a530 6
	FileDescriptor fd = acquireFD();
	try {
	    socketAccept(s);
	} finally {
	    releaseFD();
	}
d537 10
a546 10
	if (isClosedOrPending()) {
	    throw new IOException("Socket Closed");
	}
	if (shut_rd) {
	    throw new IOException("Socket input is shutdown");
	}
	if (socketInputStream == null) {
	    socketInputStream = new SocketInputStream(this);
	}
	return socketInputStream;
d550 1
a550 1
	socketInputStream = in;
d557 3
a559 3
	if (isClosedOrPending()) {
	    throw new IOException("Socket Closed");
	}
d561 3
a563 3
	    throw new IOException("Socket output is shutdown");
	}
	return new SocketOutputStream(this);
d570 1
a570 1
	if (isClosedOrPending()) {
d572 1
a572 1
	}
d574 32
a605 32
	/*
	 * If connection has been reset then return 0 to indicate
	 * there are no buffered bytes.
	 */
	if (isConnectionReset()) {
	    return 0;
	}

	/*
	 * If no bytes available and we were previously notified
	 * of a connection reset then we move to the reset state.
	 *
	 * If are notified of a connection reset then check
	 * again if there are bytes buffered on the socket. 
	 */
	int n = 0;
	try { 
	    n = socketAvailable();
	    if (n == 0 && isConnectionResetPending()) {
	        setConnectionReset();
	    }
	} catch (ConnectionResetException exc1) {
	    setConnectionResetPending();
	    try {
	        n = socketAvailable();
		if (n == 0) {
		    setConnectionReset();
		}
	    } catch (ConnectionResetException exc2) {
	    }
	}
	return n;
d612 38
a649 38
	synchronized(fdLock) {
	    if (fd != null || fd1 != null) {
		if (fdUseCount == 0) {
		    if (closePending) {
			return;
		    }
		    closePending = true;
		    /*
		     * We close the FileDescriptor in two-steps - first the
 		     * "pre-close" which closes the socket but doesn't
		     * release the underlying file descriptor. This operation
		     * may be lengthy due to untransmitted data and a long
		     * linger interval. Once the pre-close is done we do the
		     * actual socket to release the fd.
		     */
		    try {
		        socketPreClose();
		    } finally {
		        socketClose();
		    }
		    fd = null;
		    fd1 = null;
		    return;
		} else {
		    /*
		     * If a thread has acquired the fd and a close
		     * isn't pending then use a deferred close.
		     * Also decrement fdUseCount to signal the last
		     * thread that releases the fd to close it.
		     */
		    if (!closePending) {
			closePending = true;
		        fdUseCount--;
			socketPreClose();
		    }
		}
	    }
	}
d667 5
a671 5
	  socketShutdown(SHUT_RD);
	  if (socketInputStream != null) {
	      socketInputStream.setEOF(true);
	  }
	  shut_rd = true;
d680 2
a681 2
	  socketShutdown(SHUT_WR);
	  shut_wr = true;
d703 4
a706 4
	synchronized (fdLock) {
	    fdUseCount++;
	    return fd;
	}
d715 13
a727 13
	synchronized (fdLock) {
	    fdUseCount--;
	    if (fdUseCount == -1) {
		if (fd != null) {
	            try {
			socketClose();
	            } catch (IOException e) { 
		    } finally {
		        fd = null;
		    }
		}
	    }
	}
d731 3
a733 3
	synchronized (resetLock) {
	    return (resetState == CONNECTION_RESET);
	}
d737 1
a737 1
	synchronized (resetLock) {
d743 1
a743 1
	synchronized (resetLock) {
d749 1
a749 1
	synchronized (resetLock) {
d761 11
a771 11
	/*
	 * Lock on fdLock to ensure that we wait if a
	 * close is in progress.
	 */
	synchronized (fdLock) {
	    if (closePending || (fd == null && fd1 == null)) {
		return true;
	    } else {
		return false;
	    }
	}
d778 1
a778 1
	return timeout;
d786 1
a786 1
	socketClose0(true);
d793 1
a793 1
	socketClose0(false);
d798 22
a819 22
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    if (stream)
	    {
		netSocket = new cli.System.Net.Sockets.Socket(AddressFamily.wrap(AddressFamily.InterNetwork), SocketType.wrap(SocketType.Stream), ProtocolType.wrap(ProtocolType.Tcp));
	    }
	    else
	    {
		netSocket = new cli.System.Net.Sockets.Socket(AddressFamily.wrap(AddressFamily.InterNetwork), SocketType.wrap(SocketType.Dgram), ProtocolType.wrap(ProtocolType.Udp));
	    }
	    fd1 = null;
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d824 34
a857 34
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    IPEndPoint ep = new IPEndPoint(getAddressFromInetAddress(address), port);
	    if (timeout <= 0)
	    {
		netSocket.Connect(ep);
	    }
	    else
	    {
		cli.System.IAsyncResult result = netSocket.BeginConnect(ep, null, null);
		if (!result.get_AsyncWaitHandle().WaitOne(timeout, false))
		{
		    netSocket.Close();
		    throw new SocketTimeoutException();
		}
		netSocket.EndConnect(result);
	    }
	    this.address = address;
	    this.port = port;
	    if (this.localport == 0)
	    {
		this.localport = ((IPEndPoint)netSocket.get_LocalEndPoint()).get_Port();
	    }
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw new ConnectException(x.getMessage());
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d862 23
a884 23
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    netSocket.Bind(new IPEndPoint(getAddressFromInetAddress(address), localport));
	    this.address = address;
	    if (localport == 0)
	    {
		this.localport = ((IPEndPoint)netSocket.get_LocalEndPoint()).get_Port();
	    }
	    else
	    {
		this.localport = localport;
	    }
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw new BindException(x.getMessage());
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d889 14
a902 14
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    netSocket.Listen(count);
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d907 26
a932 26
	PlainSocketImpl impl = (PlainSocketImpl)s;
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    if (timeout > 0 && !netSocket.Poll(Math.min(timeout, Integer.MAX_VALUE / 1000) * 1000,
		SelectMode.wrap(SelectMode.SelectRead)))
	    {
		throw new SocketTimeoutException("Accept timed out");
	    }
	    cli.System.Net.Sockets.Socket accept = netSocket.Accept();
	    impl.netSocket = accept;
	    IPEndPoint remoteEndPoint = ((IPEndPoint)accept.get_RemoteEndPoint());
	    impl.address = getInetAddressFromIPEndPoint(remoteEndPoint);
	    impl.port = remoteEndPoint.get_Port();
	    impl.localport = ((IPEndPoint)accept.get_LocalEndPoint()).get_Port();
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    // TODO we may have to throw java.io.InterruptedIOException here
	    throw new SocketException("Socket is closed");
	}
d937 14
a950 14
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    return netSocket.get_Available();
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d955 17
a971 17
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    if (netSocket != null)
	    {
		netSocket.Close();
	    }
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d976 14
a989 14
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    netSocket.Shutdown(SocketShutdown.wrap(howto == SHUT_RD ? SocketShutdown.Receive : SocketShutdown.Send));
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d994 44
a1037 44
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    switch (cmd)
	    {
		case SocketOptions.SO_LINGER:
		    if (on)
		    {
			netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.Linger), new LingerOption(true, ((Integer)value).intValue()));
		    }
		    else
		    {
			netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.Linger), new LingerOption(false, 0));
		    }
		    break;
		case SocketOptions.SO_TIMEOUT:
		    if (serverSocket == null)
		    {
			netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.ReceiveTimeout), timeout <= 5000 ? 0 : timeout);
		    }
		    break;
		case SocketOptions.TCP_NODELAY:
		    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Tcp), SocketOptionName.wrap(SocketOptionName.NoDelay), on ? 1 : 0);
		    break;
		case SocketOptions.SO_KEEPALIVE:
		    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.KeepAlive), on ? 1 : 0);
		    break;
		case SocketOptions.SO_OOBINLINE:
		    netSocket.SetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.OutOfBandInline), on ? 1 : 0);
		    break;
		default:
		    setCommonSocketOption(netSocket, cmd, on, value);
		    break;
	    }
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw new SocketException(x.getMessage());
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d1042 33
a1074 33
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    switch (opt)
	    {
		case SocketOptions.TCP_NODELAY:
		    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Tcp), SocketOptionName.wrap(SocketOptionName.NoDelay))) == 0 ? -1 : 1;
		case SocketOptions.SO_KEEPALIVE:
		    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.KeepAlive))) == 0 ? -1 : 1;
		case SocketOptions.SO_LINGER:
		    {
			LingerOption linger = (LingerOption)netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.Linger));
			if (linger.get_Enabled())
			{
			    return linger.get_LingerTime();
			}
			return -1;
		    }
		case SocketOptions.SO_OOBINLINE:
		    return CIL.unbox_int(netSocket.GetSocketOption(SocketOptionLevel.wrap(SocketOptionLevel.Socket), SocketOptionName.wrap(SocketOptionName.OutOfBandInline))) == 0 ? -1 : 1;
		default:
		    return getCommonSocketOption(netSocket, opt, iaContainerObj);
	    }
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw new SocketException(x.getMessage());
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d1079 15
a1093 15
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    byte[] oob = { (byte)data };
	    netSocket.Send(oob, SocketFlags.wrap(SocketFlags.OutOfBand));
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d1099 30
a1128 30
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    if (timeout > 0 && !netSocket.Poll(Math.min(timeout, Integer.MAX_VALUE / 1000) * 1000,
		SelectMode.wrap(SelectMode.SelectRead)))
	    {
		throw new SocketTimeoutException();
	    }
	    int read = netSocket.Receive(buf, offset, len, SocketFlags.wrap(SocketFlags.None));
	    return read == 0 ? -1 : read;
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    if (x.get_ErrorCode() == WSAESHUTDOWN)
	    {
		// the socket was shutdown, so we have to return EOF
		return -1;
	    }
	    else if (x.get_ErrorCode() == WSAEWOULDBLOCK)
	    {
		// nothing to read and would block
		return 0;
	    }
	    throw convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d1134 14
a1147 14
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    return netSocket.Send(buf, offset, len, SocketFlags.wrap(SocketFlags.None));
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
@


1.1
log
@- Added WINDOWS constant to ikvm.internal.Util to check if we're running on Windows.
- Added a bunch of native methods to openjdk.cs (some real implementations, some stubs)
- Added OpenJDK derived PlainSocketImpl/SocketInputStream/SocketOutputStream implementations.
- Added OpenJDK derived file protocol handler (a single class that supports both Windows and non-Windows)
@
text
@d57 2
a58 1
class PlainSocketImpl extends SocketImpl
d61 1
a61 1
    private static final int WSAEWOULDBLOCK = 10035;
d64 1
a64 1
    private static final int WSAESHUTDOWN = 10058;
d70 1
a70 1
    static IOException convertSocketExceptionToIOException(cli.System.Net.Sockets.SocketException x) throws IOException
d90 1
a90 1
    static IPAddress getAddressFromInetAddress(InetAddress addr)
d105 1
a105 1
    static InetAddress getInetAddressFromIPEndPoint(IPEndPoint endpoint)
@

