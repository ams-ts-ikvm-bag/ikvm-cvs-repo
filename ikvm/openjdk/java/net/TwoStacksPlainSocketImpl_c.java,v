head	1.8;
access;
symbols
	v8_1_5717_0:1.8
	v8_1:1.8.0.2
	v8_0_5449_1:1.7
	v8_0_5449_0:1.7
	v8_0:1.7.0.2
	v7_4_5196_0:1.6
	v7_4:1.6.0.2
	v7_3:1.4.0.10
	v7_2_4630_6:1.4
	v7_2_4630_5:1.4
	v7_2_4630_4:1.4
	v7_2_4630_3:1.4
	v7_2_4630_2:1.4
	v0_46_0_4:1.4
	v7_2_4630_1:1.4
	v7_2:1.4.0.8
	v7_1_4532_2:1.4
	v7_1_4532_1:1.4
	v7_1_4532_0:1.4
	v7_1:1.4.0.6
	v7_0_4335_3:1.4
	v7_0_4335_2:1.4
	v7_0_4335_1:1.4
	v0_46_0_2:1.4
	v7_0_4335_0:1.4
	v7_0:1.4.0.4
	v0_46_0_1:1.4
	v0_46_0_0:1.4
	v0_46:1.4.0.2;
locks; strict;
comment	@# @;


1.8
date	2015.06.09.09.28.43;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2014.05.19.12.43.39;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2013.08.14.14.04.06;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.14.12.39.36;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.24.16.40.22;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.06.17.04.58;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.09.06.55.31;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.09.06.42.59;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Integrated OpenJDK 8u45.
@
text
@/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.net;

import java.io.FileDescriptor;
import static ikvm.internal.JNI.*;
import static ikvm.internal.Winsock.*;
import static java.net.net_util_md.*;
import static java.net.InetAddress.IPv4;
import static java.net.InetAddress.IPv6;

final class TwoStacksPlainSocketImpl_c
{
static final int JVM_IO_ERR = -1;
static final int JVM_IO_INTR = -2;

static final int java_net_SocketOptions_SO_TIMEOUT = SocketOptions.SO_TIMEOUT;
static final int java_net_SocketOptions_SO_BINDADDR = SocketOptions.SO_BINDADDR;
static final int java_net_SocketOptions_SO_SNDBUF = SocketOptions.SO_SNDBUF;
static final int java_net_SocketOptions_SO_RCVBUF = SocketOptions.SO_RCVBUF;
static final int java_net_SocketOptions_IP_TOS = SocketOptions.IP_TOS;
static final int java_net_SocketOptions_SO_REUSEADDR = SocketOptions.SO_REUSEADDR;
static final int java_net_SocketOptions_TCP_NODELAY = SocketOptions.TCP_NODELAY;
static final int java_net_SocketOptions_SO_OOBINLINE = SocketOptions.SO_OOBINLINE;
static final int java_net_SocketOptions_SO_KEEPALIVE = SocketOptions.SO_KEEPALIVE;
static final int java_net_SocketOptions_SO_LINGER = SocketOptions.SO_LINGER;

/*
#include <windows.h>
#include <winsock2.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <sys/types.h>

#include "java_net_SocketOptions.h"
#include "java_net_TwoStacksPlainSocketImpl.h"
#include "java_net_InetAddress.h"
#include "java_io_FileDescriptor.h"
#include "java_lang_Integer.h"

#include "jvm.h"
#include "net_util.h"
#include "jni_util.h"
*/

/************************************************************************
 * TwoStacksPlainSocketImpl
 */

/*
static jfieldID IO_fd_fdID;

jfieldID psi_fdID;
jfieldID psi_fd1ID;
jfieldID psi_addressID;
jfieldID psi_portID;
jfieldID psi_localportID;
jfieldID psi_timeoutID;
jfieldID psi_trafficClassID;
jfieldID psi_serverSocketID;
jfieldID psi_lastfdID;
*/

/*
 * the level of the TCP protocol for setsockopt and getsockopt
 * we only want to look this up once, from the static initializer
 * of TwoStacksPlainSocketImpl
 */
static int tcp_level = -1;

static cli.System.Net.Sockets.Socket getFD(JNIEnv env, TwoStacksPlainSocketImpl _this) {
    FileDescriptor fdObj = _this.fd;

    if (fdObj == NULL) {
        return null;
    }
    return fdObj.getSocket();
}

static cli.System.Net.Sockets.Socket getFD1(JNIEnv env, TwoStacksPlainSocketImpl _this) {
    FileDescriptor fdObj = _this.fd1;

    if (fdObj == NULL) {
        return null;
    }
    return fdObj.getSocket();
}


/*
 * The initProto function is called whenever TwoStacksPlainSocketImpl is
 * loaded, to cache fieldIds for efficiency. This is called everytime
 * the Java class is loaded.
 *
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    initProto

 * Signature: ()V
 */
/*
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_initProto(JNIEnv *env, jclass cls) {

    struct protoent *proto = getprotobyname("TCP");
    tcp_level = (proto == 0 ? IPPROTO_TCP: proto->p_proto);

    psi_fdID = (*env)->GetFieldID(env, cls , "fd", "Ljava/io/FileDescriptor;");
    CHECK_NULL(psi_fdID);
    psi_fd1ID =(*env)->GetFieldID(env, cls , "fd1", "Ljava/io/FileDescriptor;");
    CHECK_NULL(psi_fd1ID);
    psi_addressID = (*env)->GetFieldID(env, cls, "address",
                                          "Ljava/net/InetAddress;");
    CHECK_NULL(psi_addressID);
    psi_portID = (*env)->GetFieldID(env, cls, "port", "I");
    CHECK_NULL(psi_portID);
    psi_lastfdID = (*env)->GetFieldID(env, cls, "lastfd", "I");
    CHECK_NULL(psi_portID);
    psi_localportID = (*env)->GetFieldID(env, cls, "localport", "I");
    CHECK_NULL(psi_localportID);
    psi_timeoutID = (*env)->GetFieldID(env, cls, "timeout", "I");
    CHECK_NULL(psi_timeoutID);
    psi_trafficClassID = (*env)->GetFieldID(env, cls, "trafficClass", "I");
    CHECK_NULL(psi_trafficClassID);
    psi_serverSocketID = (*env)->GetFieldID(env, cls, "serverSocket",
                                            "Ljava/net/ServerSocket;");
    CHECK_NULL(psi_serverSocketID);
    IO_fd_fdID = NET_GetFileDescriptorID(env);
    CHECK_NULL(IO_fd_fdID);
}
*/

/*
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketCreate
 * Signature: (Z)V
 */
static void socketCreate(JNIEnv env, TwoStacksPlainSocketImpl _this, boolean stream) {
    FileDescriptor fdObj = _this.fd;
    FileDescriptor fd1Obj = _this.fd1;
    cli.System.Net.Sockets.Socket fd = null;
    cli.System.Net.Sockets.Socket fd1 = null;

    if (IS_NULL(fdObj)) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                        "null fd object");
        return;
    }
    fd = socket(AF_INET, (stream ? SOCK_STREAM: SOCK_DGRAM), 0);
    if (fd == INVALID_SOCKET) {
        NET_ThrowCurrent(env, "create");
        return;
    } else {
        /* Set socket attribute so it is not passed to any child process */
        //SetHandleInformation((HANDLE)(UINT_PTR)fd, HANDLE_FLAG_INHERIT, FALSE);
        fdObj.setSocket(fd);
    }
    if (ipv6_available()) {

        if (IS_NULL(fd1Obj)) {
            JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                            "null fd1 object");
            fdObj.setSocket(null);
            NET_SocketClose(fd);
            return;
        }
        fd1 = socket(AF_INET6, (stream ? SOCK_STREAM: SOCK_DGRAM), 0);
        if (fd1 == INVALID_SOCKET) {
            NET_ThrowCurrent(env, "create");
            fdObj.setSocket(null);
            NET_SocketClose(fd);
            return;
        } else {
            fd1Obj.setSocket(fd1);
        }
    } else {
        _this.fd1 = null;
    }
}

/*
 * inetAddress is the address object passed to the socket connect
 * call.
 *
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketConnect
 * Signature: (Ljava/net/InetAddress;I)V
 */
static void socketConnect(JNIEnv env, TwoStacksPlainSocketImpl _this, InetAddress iaObj, int port, int timeout)
{
    int localport = _this.localport;

    /* family and localport are int fields of iaObj */
    int family;
    cli.System.Net.Sockets.Socket fd = null;
    cli.System.Net.Sockets.Socket fd1 = null;
    boolean ipv6_supported = ipv6_available();

    /* fd initially points to the IPv4 socket and fd1 to the IPv6 socket
     * If we want to connect to IPv6 then we swap the two sockets/objects
     * This way, fd is always the connected socket, and fd1 always gets closed.
     */
    FileDescriptor fdObj = _this.fd;
    FileDescriptor fd1Obj = _this.fd1;

    SOCKETADDRESS him;
    him = new SOCKETADDRESS();

    /* The result of the connection */
    int connect_res;

    if (!IS_NULL(fdObj)) {
        fd = fdObj.getSocket();
    }

    if (ipv6_supported && !IS_NULL(fd1Obj)) {
        fd1 = fd1Obj.getSocket();
    }

    if (IS_NULL(iaObj)) {
        JNU_ThrowNullPointerException(env, "inet address argument is null.");
        return;
    }

    if (NET_InetAddressToSockaddr(env, iaObj, port, him, JNI_FALSE) != 0) {
      return;
    }

    family = him.him.sa_family;
    if (family == AF_INET6) {
        if (!ipv6_supported) {
            JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                            "Protocol family not supported");
            return;
        } else {
            if (fd1 == null) {
                JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                                "Destination unreachable");
                return;
            }
            /* close the v4 socket, and set fd to be the v6 socket */
            _this.fd = fd1Obj;
            _this.fd1 = null;
            NET_SocketClose(fd);
            fd = fd1; fdObj = fd1Obj;
        }
    } else {
        if (fd1 != null) {
            fd1Obj.setSocket(null);
            NET_SocketClose(fd1);
        }
        if (fd == null) {
            JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                            "Destination unreachable");
            return;
        }
    }
    _this.fd1 = null;

    if (timeout <= 0) {
        connect_res = connect(fd, him);
        if (connect_res == SOCKET_ERROR) {
            connect_res = WSAGetLastError();
        }
    } else {
        int optval;

        /* make socket non-blocking */
        optval = 1;
        ioctlsocket( fd, FIONBIO, optval );

        /* initiate the connect */
        connect_res = connect(fd, him);
        if (connect_res == SOCKET_ERROR) {
            if (WSAGetLastError() != WSAEWOULDBLOCK) {
                connect_res = WSAGetLastError();
            } else {
                fd_set wr, ex;
                wr = new fd_set(); ex = new fd_set();
                timeval t = new timeval();

                FD_ZERO(wr);
                FD_ZERO(ex);
                FD_SET(fd, wr);
                FD_SET(fd, ex);
                t.tv_sec = timeout / 1000;
                t.tv_usec = (timeout % 1000) * 1000;

                /*
                 * Wait for timout, connection established or
                 * connection failed.
                 */
                connect_res = select(null, wr, ex, t);

                /*
                 * Timeout before connection is established/failed so
                 * we throw exception and shutdown input/output to prevent
                 * socket from being used.
                 * The socket should be closed immediately by the caller.
                 */
                if (connect_res == 0) {
                    JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketTimeoutException",
                                    "connect timed out");
                    shutdown( fd, SD_BOTH );

                     /* make socket blocking again - just in case */
                    optval = 0;
                    ioctlsocket( fd, FIONBIO, optval );
                    return;
                }

                /*
                 * We must now determine if the connection has been established
                 * or if it has failed. The logic here is designed to work around
                 * bug on Windows NT whereby using getsockopt to obtain the
                 * last error (SO_ERROR) indicates there is no error. The workaround
                 * on NT is to allow winsock to be scheduled and this is done by
                 * yielding and retrying. As yielding is problematic in heavy
                 * load conditions we attempt up to 3 times to get the error reason.
                 */
                if (!FD_ISSET(fd, ex)) {
                    connect_res = 0;
                } else {
                    int retry;
                    for (retry=0; retry<3; retry++) {
                        int[] tmp = { 0 };
                        NET_GetSockOpt(fd, SOL_SOCKET, SO_ERROR,
                                       tmp);
                        connect_res = tmp[0];
                        if (connect_res != 0) {
                            break;
                        }
                        Sleep(0);
                    }

                    if (connect_res == 0) {
                        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                                        "Unable to establish connection");
                        return;
                    }
                }
            }
        }

        /* make socket blocking again */
        optval = 0;
        ioctlsocket(fd, FIONBIO, optval);
    }

    if (connect_res != 0) {
        if (connect_res == WSAEADDRNOTAVAIL) {
            JNU_ThrowByName(env, JNU_JAVANETPKG+"ConnectException",
                "connect: Address is invalid on local machine, or port is not valid on remote machine");
        } else {
            NET_ThrowNew(env, connect_res, "connect");
        }
        return;
    }

    fdObj.setSocket(fd);

    /* set the remote peer address and port */
    _this.address = iaObj;
    _this.port = port;

    /*
     * we need to initialize the local port field if bind was called
     * previously to the connect (by the client) then localport field
     * will already be initialized
     */
    if (localport == 0) {
        /* Now that we're a connected socket, let's extract the port number
         * that the system chose for us and store it in the Socket object.
         */
        if (getsockname(fd, him) == -1) {

            if (WSAGetLastError() == WSAENOTSOCK) {
                JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                        "Socket closed");
            } else {
                NET_ThrowCurrent(env, "getsockname failed");
            }
            return;
        }
        port = ntohs (GET_PORT(him));
        _this.localport = port;
    }
}

/*
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketBind
 * Signature: (Ljava/net/InetAddress;I)V
 */
static void socketBind(JNIEnv env, TwoStacksPlainSocketImpl _this,
                                         InetAddress iaObj, int localport,
                                         boolean exclBind) {
    FileDescriptor fdObj = _this.fd;
    FileDescriptor fd1Obj = _this.fd1;
    cli.System.Net.Sockets.Socket fd = null;
    cli.System.Net.Sockets.Socket fd1 = null;
    boolean ipv6_supported = ipv6_available();

    /* family is an int field of iaObj */
    int family;
    int rv;

    SOCKETADDRESS him;
    him = new SOCKETADDRESS();

    family = getInetAddress_family(env, iaObj);

    if (family == IPv6 && !ipv6_supported) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                        "Protocol family not supported");
        return;
    }

    if (IS_NULL(fdObj) || (ipv6_supported && IS_NULL(fd1Obj))) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                        "Socket closed");
        return;
    } else {
        fd = fdObj.getSocket();
        if (ipv6_supported) {
            fd1 = fd1Obj.getSocket();
        }
    }
    if (IS_NULL(iaObj)) {
        JNU_ThrowNullPointerException(env, "inet address argument");
        return;
    }

    if (NET_InetAddressToSockaddr(env, iaObj, localport,
                          him, JNI_FALSE) != 0) {
      return;
    }
    if (ipv6_supported) {
        ipv6bind v6bind = new ipv6bind();
        v6bind.addr = him;
        v6bind.ipv4_fd = fd;
        v6bind.ipv6_fd = fd1;
        rv = NET_BindV6(v6bind, exclBind);
        if (rv != -1) {
            /* check if the fds have changed */
            if (v6bind.ipv4_fd != fd) {
                fd = v6bind.ipv4_fd;
                if (fd == null) {
                    /* socket is closed. */
                    _this.fd = null;
                } else {
                    /* socket was re-created */
                    fdObj.setSocket(fd);
                }
            }
            if (v6bind.ipv6_fd != fd1) {
                fd1 = v6bind.ipv6_fd;
                if (fd1 == null) {
                    /* socket is closed. */
                    _this.fd1 = null;
                } else {
                    /* socket was re-created */
                    fd1Obj.setSocket(fd1);
                }
            } else {
                /* NET_BindV6() closes both sockets upon a failure */
                _this.fd = null;
                _this.fd1 = null;
            }
        }
    } else {
        rv = NET_WinBind(fd, him, exclBind);
    }

    if (rv == -1) {
        NET_ThrowCurrent(env, "JVM_Bind");
        return;
    }

    /* set the address */
    _this.address = iaObj;

    /* intialize the local port */
    if (localport == 0) {
        /* Now that we're a bound socket, let's extract the port number
         * that the system chose for us and store it in the Socket object.
         */
        int port;
        fd = him.him.sa_family == AF_INET? fd: fd1;

        if (getsockname(fd, him) == -1) {
            NET_ThrowCurrent(env, "getsockname in plain socketBind");
            return;
        }
        port = ntohs (GET_PORT (him));

        _this.localport = port;
    } else {
        _this.localport = localport;
    }
}

/*
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketListen
 * Signature: (I)V
 */
static void socketListen (JNIEnv env, TwoStacksPlainSocketImpl _this, int count)
{
    /* this FileDescriptor fd field */
    FileDescriptor fdObj = _this.fd;
    FileDescriptor fd1Obj = _this.fd1;
    InetAddress address;
    /* fdObj's int fd field */
    cli.System.Net.Sockets.Socket fd = null;
    cli.System.Net.Sockets.Socket fd1 = null;
    SOCKETADDRESS addr = new SOCKETADDRESS();

    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                        "socket closed");
        return;
    }

    if (!IS_NULL(fdObj)) {
        fd = fdObj.getSocket();
    }
    /* Listen on V4 if address type is v4 or if v6 and address is ::0.
     * Listen on V6 if address type is v6 or if v4 and address is 0.0.0.0.
     * In cases, where we listen on one space only, we close the other socket.
     */
    address = _this.address;
    if (IS_NULL(address)) {
        JNU_ThrowNullPointerException(env, "socket address");
        return;
    }
    if (NET_InetAddressToSockaddr(env, address, 0, addr,
                                  JNI_FALSE) != 0) {
      return;
    }

    if (addr.him.sa_family == AF_INET || IN6ADDR_ISANY(addr.him6)) {
        /* listen on v4 */
        if (listen(fd, count) == -1) {
            NET_ThrowCurrent(env, "listen failed");
        }
    } else {
        NET_SocketClose (fd);
        _this.fd = null;
    }
    if (ipv6_available() && !IS_NULL(fd1Obj)) {
        fd1 = fd1Obj.getSocket();
        if (addr.him.sa_family == AF_INET6 || addr.him4.sin_addr.s_addr == INADDR_ANY) {
            /* listen on v6 */
            if (listen(fd1, count) == -1) {
                NET_ThrowCurrent(env, "listen failed");
            }
        } else {
            NET_SocketClose (fd1);
            _this.fd1 = null;
        }
    }
}

/*
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketAccept
 * Signature: (Ljava/net/SocketImpl;)V
 */
static void socketAccept(JNIEnv env, TwoStacksPlainSocketImpl _this, SocketImpl socket)
{
    /* fields on this */
    int port;
    int timeout = _this.timeout;
    FileDescriptor fdObj = _this.fd;
    FileDescriptor fd1Obj = _this.fd1;

    /* the FileDescriptor field on socket */
    FileDescriptor socketFdObj;

    /* the InetAddress field on socket */
    InetAddress socketAddressObj;

    /* the fd int field on fdObj */
    cli.System.Net.Sockets.Socket fd=null, fd1=null;

    SOCKETADDRESS him;
    him = new SOCKETADDRESS();

    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                        "Socket closed");
        return;
    }
    if (!IS_NULL(fdObj)) {
        fd = fdObj.getSocket();
    }
    if (!IS_NULL(fd1Obj)) {
        fd1 = fd1Obj.getSocket();
    }
    if (IS_NULL(socket)) {
        JNU_ThrowNullPointerException(env, "socket is null");
        return;
    } else {
        socketFdObj = socket.fd;
        socketAddressObj = socket.address;
    }
    if ((IS_NULL(socketAddressObj)) || (IS_NULL(socketFdObj))) {
        JNU_ThrowNullPointerException(env, "socket address or fd obj");
        return;
    }
    if (fd != null && fd1 != null) {
        fd_set rfds = new fd_set();
        timeval t = new timeval();
        cli.System.Net.Sockets.Socket lastfd, fd2;
        FD_ZERO(rfds);
        FD_SET(fd,rfds);
        FD_SET(fd1,rfds);
        if (timeout != 0) {
            t.tv_sec = timeout/1000;
            t.tv_usec = (timeout%1000)*1000;
        } else {
            t = null;
        }
        int res = select (rfds, null, null, t);
        if (res == 0) {
            JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketTimeoutException",
                            "Accept timed out");
            return;
        } else if (res == 1) {
            fd2 = FD_ISSET(fd, rfds)? fd: fd1;
        } else if (res == 2) {
            /* avoid starvation */
            lastfd = _this.lastfd;
            if (lastfd != null) {
                fd2 = lastfd==fd? fd1: fd;
            } else {
                fd2 = fd;
            }
            _this.lastfd = fd2;
        } else {
            JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                            "select failed");
            return;
        }
        fd = fd2;
    } else {
        int ret;
        if (fd1 != null) {
            fd = fd1;
        }
        if (timeout != 0) {
            ret = NET_Timeout(fd, timeout);
            if (ret == 0) {
                JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketTimeoutException",
                                "Accept timed out");
                return;
            } else if (ret == -1) {
                JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException", "socket closed");
            /* REMIND: SOCKET CLOSED PROBLEM */
    /*        NET_ThrowCurrent(env, "Accept failed"); */
                return;
            } else if (ret == -2) {
                JNU_ThrowByName(env, JNU_JAVAIOPKG+"InterruptedIOException",
                                "operation interrupted");
                return;
            }
        }
    }
    fd = accept(fd, him);
    if (fd == null) {
        /* REMIND: SOCKET CLOSED PROBLEM */
        if (false) {
            JNU_ThrowByName(env, JNU_JAVAIOPKG+"InterruptedIOException",
                            "operation interrupted");
        } else {
            JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                            "socket closed");
        }
        return;
    }
    socketFdObj.setSocket(fd);

    if (him.him.sa_family == AF_INET) {

        /*
         * fill up the remote peer port and address in the new socket structure
         */
        socketAddressObj = new Inet4Address(null, ntohl(him.him4.sin_addr.s_addr));
        socket.address = socketAddressObj;
    } else {
        /* AF_INET6 -> Inet6Address */

        // [IKVM] We need to convert scope_id 0 to -1 here, because for sin6_scope_id 0 means unspecified, whereas Java uses -1
        int scopeId = him.him6.sin6_scope_id;
        socketAddressObj = new Inet6Address(null, him.him6.sin6_addr, scopeId == 0 ? -1 : scopeId);
    }
    /* fields common to AF_INET and AF_INET6 */

    port = ntohs (GET_PORT (him));
    socket.port = port;
    port = _this.localport;
    socket.localport = port;
    socket.address = socketAddressObj;
}

/*
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketAvailable
 * Signature: ()I
 */
static int socketAvailable(JNIEnv env, TwoStacksPlainSocketImpl _this) {

    int[] available = { -1 };
    int res;
    FileDescriptor fdObj = _this.fd;
    cli.System.Net.Sockets.Socket fd;

    if (IS_NULL(fdObj)) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException", "Socket closed");
        return -1;
    } else {
        fd = fdObj.getSocket();
    }
    res = ioctlsocket(fd, FIONREAD, available);
    /* if result isn't 0, it means an error */
    if (res != 0) {
        NET_ThrowNew(env, res, "socket available");
    }
    return available[0];
}

/*
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketClose
 * Signature: ()V
 */
static void socketClose0(JNIEnv env, TwoStacksPlainSocketImpl _this, boolean useDeferredClose) {

    FileDescriptor fdObj = _this.fd;
    FileDescriptor fd1Obj = _this.fd1;
    cli.System.Net.Sockets.Socket fd = null;
    cli.System.Net.Sockets.Socket fd1 = null;

    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                        "socket already closed");
        return;
    }
    if (!IS_NULL(fdObj)) {
        fd = fdObj.getSocket();
    }
    if (!IS_NULL(fd1Obj)) {
        fd1 = fd1Obj.getSocket();
    }
    if (fd != null) {
        fdObj.setSocket(null);
        NET_SocketClose(fd);
    }
    if (fd1 != null) {
        fd1Obj.setSocket(null);
        NET_SocketClose(fd1);
    }
}

/*
 * Socket options for plainsocketImpl
 *
 *
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketNativeSetOption
 * Signature: (IZLjava/lang/Object;)V
 */
static void socketNativeSetOption(JNIEnv env, TwoStacksPlainSocketImpl _this, int cmd, boolean on, Object value) {
    cli.System.Net.Sockets.Socket fd, fd1;
    int[] level = new int[1];
    int[] optname = new int[1];
    Object optval;

    /*
     * Get SOCKET and check that it hasn't been closed
     */
    fd = getFD(env, _this);
    fd1 = getFD1(env, _this);
    if (fd == null && fd1 == null) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException", "Socket closed");
        return;
    }

    /*
     * SO_TIMEOUT is the socket option used to specify the timeout
     * for ServerSocket.accept and Socket.getInputStream().read.
     * It does not typically map to a native level socket option.
     * For Windows we special-case this and use the SOL_SOCKET/SO_RCVTIMEO
     * socket option to specify a receive timeout on the socket. This
     * receive timeout is applicable to Socket only and the socket
     * option should not be set on ServerSocket.
     */
    if (cmd == java_net_SocketOptions_SO_TIMEOUT) {

        /*
         * Don't enable the socket option on ServerSocket as it's
         * meaningless (we don't receive on a ServerSocket).
         */
        Object ssObj = _this.serverSocket;
        if (ssObj != NULL) {
            return;
        }

        /*
         * SO_RCVTIMEO is only supported on Microsoft's implementation
         * of Windows Sockets so if WSAENOPROTOOPT returned then
         * reset flag and timeout will be implemented using
         * select() -- see SocketInputStream.socketRead.
         */
        if (isRcvTimeoutSupported) {
            int timeout = ((Integer)value).intValue();

            /*
             * Disable SO_RCVTIMEO if timeout is <= 5 second.
             */
            if (timeout <= 5000) {
                timeout = 0;
            }

            if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, timeout) < 0) {
                if (WSAGetLastError() == WSAENOPROTOOPT) {
                    isRcvTimeoutSupported = JNI_FALSE;
                } else {
                    NET_ThrowCurrent(env, "setsockopt SO_RCVTIMEO");
                }
            }
            if (fd1 != null) {
                if (setsockopt(fd1, SOL_SOCKET, SO_RCVTIMEO, timeout) < 0) {
                    NET_ThrowCurrent(env, "setsockopt SO_RCVTIMEO");
                }
            }
        }
        return;
    }

    /*
     * Map the Java level socket option to the platform specific
     * level
     */
    if (NET_MapSocketOption(cmd, level, optname) != 0) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                        "Invalid option");
        return;
    }

    switch (cmd) {

        case java_net_SocketOptions_TCP_NODELAY :
        case java_net_SocketOptions_SO_OOBINLINE :
        case java_net_SocketOptions_SO_KEEPALIVE :
        case java_net_SocketOptions_SO_REUSEADDR :
            optval = on;
            break;

        case java_net_SocketOptions_SO_SNDBUF :
        case java_net_SocketOptions_SO_RCVBUF :
        case java_net_SocketOptions_IP_TOS :
            optval = ((Integer)value).intValue();
            break;

        case java_net_SocketOptions_SO_LINGER :
            {
                linger ling = new linger();
                if (on) {
                    ling.l_onoff = 1;
                    ling.l_linger = ((Integer)value).intValue();
                } else {
                    ling.l_onoff = 0;
                    ling.l_linger = 0;
                }
                optval = ling;
            }
            break;

        default: /* shouldn't get here */
            JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                "Option not supported by TwoStacksPlainSocketImpl");
            return;
    }

    if (fd != null) {
        if (NET_SetSockOpt(fd, level[0], optname[0], optval) < 0) {
            NET_ThrowCurrent(env, "setsockopt");
        }
    }

    if (fd1 != null) {
        if (NET_SetSockOpt(fd1, level[0], optname[0], optval) < 0) {
            NET_ThrowCurrent(env, "setsockopt");
        }
    }
}


/*
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketGetOption
 * Signature: (I)I
 */
static int socketGetOption(JNIEnv env, TwoStacksPlainSocketImpl _this, int opt, Object iaContainerObj) {

    cli.System.Net.Sockets.Socket fd, fd1;
    int[] level = new int[1];
    int[] optname = new int[1];
    Object optval;

    /*
     * Get SOCKET and check it hasn't been closed
     */
    fd = getFD(env, _this);
    fd1 = getFD1(env, _this);

    if (fd == null && fd1 == null) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException", "Socket closed");
        return -1;
    }
    if (fd == null) {
        fd = fd1;
    }

    /* For IPv6, we assume both sockets have the same setting always */

    /*
     * SO_BINDADDR isn't a socket option
     */
    if (opt == java_net_SocketOptions_SO_BINDADDR) {
        SOCKETADDRESS him;
        him = new SOCKETADDRESS();
        int[] port = { 0 };
        InetAddress iaObj;

        if (fd == null) {
            /* must be an IPV6 only socket. Case where both sockets are != -1
             * is handled in java
             */
            fd = getFD1 (env, _this);
        }

        if (getsockname(fd, him) < 0) {
            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG+"SocketException",
                             "Error getting socket name");
            return -1;
        }
        iaObj = NET_SockaddrToInetAddress(him, port);
        ((InetAddressContainer)iaContainerObj).addr = iaObj;
        return 0; /* notice change from before */
    }

    /*
     * Map the Java level socket option to the platform specific
     * level and option name.
     */
    if (NET_MapSocketOption(opt, level, optname) != 0) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException", "Invalid option");
        return -1;
    }

    /*
     * Args are int except for SO_LINGER
     */
    if (opt == java_net_SocketOptions_SO_LINGER) {
        optval = new linger();
    } else {
        optval = new int[1];
    }

    if (NET_GetSockOpt(fd, level[0], optname[0], optval) < 0) {
        NET_ThrowCurrent(env, "getsockopt");
        return -1;
    }

    switch (opt) {
        case java_net_SocketOptions_SO_LINGER:
            return (((linger)optval).l_onoff != 0 ? ((linger)optval).l_linger: -1);

        case java_net_SocketOptions_SO_SNDBUF:
        case java_net_SocketOptions_SO_RCVBUF:
        case java_net_SocketOptions_IP_TOS:
            return ((int[])optval)[0];

        case java_net_SocketOptions_TCP_NODELAY :
        case java_net_SocketOptions_SO_OOBINLINE :
        case java_net_SocketOptions_SO_KEEPALIVE :
        case java_net_SocketOptions_SO_REUSEADDR :
            return (((int[])optval)[0] == 0) ? -1 : 1;

        default: /* shouldn't get here */
            JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                "Option not supported by TwoStacksPlainSocketImpl");
            return -1;
    }
}

/*
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketShutdown
 * Signature: (I)V
 */
static void socketShutdown(JNIEnv env, TwoStacksPlainSocketImpl _this, int howto)
{

    FileDescriptor fdObj = _this.fd;
    cli.System.Net.Sockets.Socket fd;

    /*
     * WARNING: THIS NEEDS LOCKING. ALSO: SHOULD WE CHECK for fd being
     * -1 already?
     */
    if (IS_NULL(fdObj)) {
        JNU_ThrowByName(env, JNU_JAVANETPKG+"SocketException",
                        "socket already closed");
        return;
    } else {
        fd = fdObj.getSocket();
    }
    shutdown(fd, howto);
}

/*
 * Class:     java_net_TwoStacksPlainSocketImpl
 * Method:    socketSendUrgentData
 * Signature: (B)V
 */
static void socketSendUrgentData(JNIEnv env, TwoStacksPlainSocketImpl _this, int data) {
    /* The fd field */
    FileDescriptor fdObj = _this.fd;
    int n;
    cli.System.Net.Sockets.Socket fd;

    if (IS_NULL(fdObj)) {
        JNU_ThrowByName(env, "java/net/SocketException", "Socket closed");
        return;
    } else {
        fd = fdObj.getSocket();
        /* Bug 4086704 - If the Socket associated with this file descriptor
         * was closed (sysCloseFD), the the file descriptor is set to -1.
         */
        if (fd == null) {
            JNU_ThrowByName(env, "java/net/SocketException", "Socket closed");
            return;
        }

    }
    n = send(fd, new byte[] { (byte)data }, 1, MSG_OOB);
    if (n == JVM_IO_ERR) {
        NET_ThrowCurrent(env, "send");
        return;
    }
    if (n == JVM_IO_INTR) {
        JNU_ThrowByName(env, "java/io/InterruptedIOException", null);
        return;
    }
}
}
@


1.7
log
@First part of OpenJDK 8 integration.
@
text
@d488 4
@


1.6
log
@Merged OpenJDK 7u40 changes to use SO_EXCLUSIVEADDRUSE for stream sockets that don't use SO_REUSEADDR.
@
text
@d2 1
a2 1
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
a60 1
#include "java_net_SocketImpl.h"
@


1.5
log
@Merged OpenJDK 7u40 changes to use SO_EXCLUSIVEADDRUSE for datagram sockets that don't use SO_REUSEADDR.
@
text
@d2 1
a2 1
 * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
d419 3
a421 1
static void socketBind(JNIEnv env, TwoStacksPlainSocketImpl _this, InetAddress iaObj, int localport) {
d435 1
a435 1
    family = iaObj.family;
d467 1
a467 1
        rv = NET_BindV6(v6bind, false);
d492 1
a492 1
        rv = NET_Bind(fd, him);
d791 1
a791 1
 * Method:    socketSetOption
d794 1
a794 1
static void socketSetOption(JNIEnv env, TwoStacksPlainSocketImpl _this, int cmd, boolean on, Object value) {
@


1.4
log
@Integrated OpenJDK 6 b21.
@
text
@a459 1

d465 1
a465 1
        rv = NET_BindV6(v6bind);
@


1.3
log
@Unspecified scope id should be -1 in Java, not 0.
@
text
@d2 1
a2 1
 * Copyright 1997-2007 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.2
log
@Implemented IPv6 support for java.net package APIs.
@
text
@d713 3
a715 1
        socketAddressObj = new Inet6Address(null, him.him6.sin6_addr, him.him6.sin6_scope_id);
@


1.1
log
@Prepare for forking. Note that these are .c files renamed to .java, they will be ported to Java in an as straightforward as possible way.
@
text
@d25 1
d27 24
d69 1
d75 1
d87 1
d96 2
a97 2
static int getFD(JNIEnv *env, jobject this) {
    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);
d100 1
a100 1
        return -1;
d102 1
a102 1
    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d105 2
a106 2
static int getFD1(JNIEnv *env, jobject this) {
    jobject fdObj = (*env)->GetObjectField(env, this, psi_fd1ID);
d109 1
a109 1
        return -1;
d111 1
a111 1
    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d125 1
d155 1
d162 5
a166 7
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketCreate(JNIEnv *env, jobject this,
                                           jboolean stream) {
    jobject fdObj, fd1Obj;
    int fd, fd1;

    fdObj = (*env)->GetObjectField(env, this, psi_fdID);
d169 1
a169 1
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d174 1
a174 1
    if (fd == -1) {
d179 2
a180 2
        SetHandleInformation((HANDLE)(UINT_PTR)fd, HANDLE_FLAG_INHERIT, FALSE);
        (*env)->SetIntField(env, fdObj, IO_fd_fdID, (int)fd);
a182 1
        fd1Obj = (*env)->GetObjectField(env, this, psi_fd1ID);
d185 1
a185 1
            JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d187 1
a187 1
            (*env)->SetIntField(env, fdObj, IO_fd_fdID, -1);
d192 1
a192 1
        if (fd1 == -1) {
d194 1
a194 1
            (*env)->SetIntField(env, fdObj, IO_fd_fdID, -1);
d198 1
a198 1
            (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, fd1);
d201 1
a201 1
        (*env)->SetObjectField(env, this, psi_fd1ID, NULL);
d213 1
a213 4
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketConnect(JNIEnv *env, jobject this,
                                            jobject iaObj, jint port,
                                            jint timeout)
d215 1
a215 1
    jint localport = (*env)->GetIntField(env, this, psi_localportID);
d219 3
a221 3
    jint fd, fd1=-1;
    jint len;
    int  ipv6_supported = ipv6_available();
d227 2
a228 2
    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);
    jobject fd1Obj = (*env)->GetObjectField(env, this, psi_fd1ID);
d231 1
d237 1
a237 1
        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d241 1
a241 1
        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);
d249 1
a249 1
    if (NET_InetAddressToSockaddr(env, iaObj, port, (struct sockaddr *)&him, &len, JNI_FALSE) != 0) {
d256 1
a256 1
            JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d260 2
a261 2
            if (fd1 == -1) {
                JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d266 2
a267 2
            (*env)->SetObjectField(env, this, psi_fdID, fd1Obj);
            (*env)->SetObjectField(env, this, psi_fd1ID, NULL);
d272 2
a273 2
        if (fd1 != -1) {
            (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, -1);
d276 2
a277 2
        if (fd == -1) {
            JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d282 1
a282 1
    (*env)->SetObjectField(env, this, psi_fd1ID, NULL);
d285 1
a285 1
        connect_res = connect(fd, (struct sockaddr *) &him, SOCKETADDRESS_LEN(&him));
a290 1
        int optlen = sizeof(optval);
d294 1
a294 1
        ioctlsocket( fd, FIONBIO, &optval );
d297 1
a297 1
        connect_res = connect(fd, (struct sockaddr *) &him, SOCKETADDRESS_LEN(&him));
d303 2
a304 1
                struct timeval t;
d306 4
a309 4
                FD_ZERO(&wr);
                FD_ZERO(&ex);
                FD_SET(fd, &wr);
                FD_SET(fd, &ex);
d317 1
a317 1
                connect_res = select(fd+1, 0, &wr, &ex, &t);
d326 1
a326 1
                    JNU_ThrowByName(env, JNU_JAVANETPKG "SocketTimeoutException",
d332 1
a332 1
                    ioctlsocket( fd, FIONBIO, &optval );
d345 1
a345 1
                if (!FD_ISSET(fd, &ex)) {
d350 1
d352 3
a354 2
                                       (char*)&connect_res, &optlen);
                        if (connect_res) {
d361 1
a361 1
                        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d371 1
a371 1
        ioctlsocket(fd, FIONBIO, &optval);
d374 1
a374 1
    if (connect_res) {
d376 1
a376 1
            JNU_ThrowByName(env, JNU_JAVANETPKG "ConnectException",
d384 1
a384 1
    (*env)->SetIntField(env, fdObj, IO_fd_fdID, (int)fd);
d387 2
a388 2
    (*env)->SetObjectField(env, this, psi_addressID, iaObj);
    (*env)->SetIntField(env, this, psi_portID, port);
d399 1
a399 3
        u_short port;
        int len = SOCKETADDRESS_LEN(&him);
        if (getsockname(fd, (struct sockaddr *)&him, &len) == -1) {
d402 1
a402 1
                JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d409 2
a410 2
        port = ntohs ((u_short)GET_PORT(&him));
        (*env)->SetIntField(env, this, psi_localportID, (int) port);
d419 6
a424 9
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketBind(JNIEnv *env, jobject this,
                                         jobject iaObj, jint localport) {

    /* fdObj is the FileDescriptor field on this */
    jobject fdObj, fd1Obj;
    /* fd is an int field on fdObj */
    int fd, fd1, len;
    int ipv6_supported = ipv6_available();
d431 1
d433 1
a433 4
    fdObj = (*env)->GetObjectField(env, this, psi_fdID);
    fd1Obj = (*env)->GetObjectField(env, this, psi_fd1ID);

    family = (*env)->GetIntField(env, iaObj, ia_familyID);
d436 1
a436 1
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d442 1
a442 1
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d446 1
a446 1
        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d448 1
a448 1
            fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);
d457 1
a457 1
                          (struct sockaddr *)&him, &len, JNI_FALSE) != 0) {
d462 2
a463 2
        struct ipv6bind v6bind;
        v6bind.addr = &him;
d466 1
a466 1
        rv = NET_BindV6(&v6bind);
d471 1
a471 1
                if (fd == -1) {
d473 1
a473 1
                    (*env)->SetObjectField(env, this, psi_fdID, NULL);
d476 1
a476 1
                    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);
d481 1
a481 1
                if (fd1 == -1) {
d483 1
a483 1
                    (*env)->SetObjectField(env, this, psi_fd1ID, NULL);
d486 1
a486 1
                    (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, fd1);
d491 1
a491 1
        rv = NET_Bind(fd, (struct sockaddr *)&him, len);
d500 1
a500 1
    (*env)->SetObjectField(env, this, psi_addressID, iaObj);
d507 1
a507 2
        int len = SOCKETADDRESS_LEN(&him);
        u_short port;
d510 1
a510 1
        if (getsockname(fd, (struct sockaddr *)&him, &len) == -1) {
d514 1
a514 1
        port = ntohs ((u_short) GET_PORT (&him));
d516 1
a516 1
        (*env)->SetIntField(env, this, psi_localportID, (int) port);
d518 1
a518 1
        (*env)->SetIntField(env, this, psi_localportID, localport);
d527 1
a527 3
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketListen (JNIEnv *env, jobject this,
                                            jint count)
d530 3
a532 3
    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);
    jobject fd1Obj = (*env)->GetObjectField(env, this, psi_fd1ID);
    jobject address;
d534 3
a536 2
    int fd, fd1;
    SOCKETADDRESS addr; int addrlen;
d539 1
a539 1
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d545 1
a545 1
        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d551 1
a551 1
    address = (*env)->GetObjectField(env, this, psi_addressID);
d556 2
a557 2
    if (NET_InetAddressToSockaddr(env, address, 0, (struct sockaddr *)&addr,
                                  &addrlen, JNI_FALSE) != 0) {
d561 1
a561 1
    if (addr.him.sa_family == AF_INET || IN6ADDR_ISANY(&addr.him6)) {
d568 1
a568 1
        (*env)->SetObjectField(env, this, psi_fdID, NULL);
d571 1
a571 1
        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);
d579 1
a579 1
            (*env)->SetObjectField(env, this, psi_fd1ID, NULL);
d589 1
a589 3
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketAccept(JNIEnv *env, jobject this,
                                           jobject socket)
d592 4
a595 4
    jint port;
    jint timeout = (*env)->GetIntField(env, this, psi_timeoutID);
    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);
    jobject fd1Obj = (*env)->GetObjectField(env, this, psi_fd1ID);
d598 1
a598 5
    jobject socketFdObj;

    /* cache the Inet4/6Address classes */
    static jclass inet4Cls;
    static jclass inet6Cls;
d601 1
a601 1
    jobject socketAddressObj;
d604 1
a604 1
    jint fd=-1, fd1=-1;
d607 1
a607 1
    jint len;
d610 1
a610 1
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d615 1
a615 1
        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d618 1
a618 1
        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);
d624 2
a625 2
        socketFdObj = (*env)->GetObjectField(env, socket, psi_fdID);
        socketAddressObj = (*env)->GetObjectField(env, socket, psi_addressID);
d631 8
a638 8
    if (fd != -1 && fd1 != -1) {
        fd_set rfds;
        struct timeval t, *tP=&t;
        int lastfd, res, fd2;
        FD_ZERO(&rfds);
        FD_SET(fd,&rfds);
        FD_SET(fd1,&rfds);
        if (timeout) {
d642 1
a642 1
            tP = NULL;
d644 1
a644 1
        res = select (fd, &rfds, NULL, NULL, tP);
d646 1
a646 1
            JNU_ThrowByName(env, JNU_JAVANETPKG "SocketTimeoutException",
d650 1
a650 1
            fd2 = FD_ISSET(fd, &rfds)? fd: fd1;
d653 2
a654 2
            lastfd = (*env)->GetIntField(env, this, psi_lastfdID);
            if (lastfd != -1) {
d659 1
a659 1
            (*env)->SetIntField(env, this, psi_lastfdID, fd2);
d661 1
a661 1
            JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
a664 5
        if (fd2 == fd) { /* v4 */
            len = sizeof (struct sockaddr_in);
        } else {
            len = sizeof (struct SOCKADDR_IN6);
        }
d668 1
a668 1
        if (fd1 != -1) {
a669 3
            len = sizeof (struct SOCKADDR_IN6);
        } else {
            len = sizeof (struct sockaddr_in);
d671 1
a671 1
        if (timeout) {
d674 1
a674 1
                JNU_ThrowByName(env, JNU_JAVANETPKG "SocketTimeoutException",
d678 1
a678 1
                JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "socket closed");
d683 1
a683 1
                JNU_ThrowByName(env, JNU_JAVAIOPKG "InterruptedIOException",
d689 2
a690 2
    fd = accept(fd, (struct sockaddr *)&him, &len);
    if (fd < 0) {
d692 2
a693 2
        if (fd == -2) {
            JNU_ThrowByName(env, JNU_JAVAIOPKG "InterruptedIOException",
d696 1
a696 1
            JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d701 1
a701 1
    (*env)->SetIntField(env, socketFdObj, IO_fd_fdID, fd);
a703 7
        if (inet4Cls == NULL) {
            jclass c = (*env)->FindClass(env, "java/net/Inet4Address");
            if (c != NULL) {
                inet4Cls = (*env)->NewGlobalRef(env, c);
                (*env)->DeleteLocalRef(env, c);
            }
        }
d708 2
a709 18
        if (inet4Cls != NULL) {
            socketAddressObj = (*env)->NewObject(env, inet4Cls, ia4_ctrID);
        } else {
            socketAddressObj = NULL;
        }
        if (socketAddressObj == NULL) {
            /*
             * FindClass or NewObject failed so close connection and
             * exist (there will be a pending exception).
             */
            NET_SocketClose(fd);
            return;
        }

        (*env)->SetIntField(env, socketAddressObj, ia_addressID,
                            ntohl(him.him4.sin_addr.s_addr));
        (*env)->SetIntField(env, socketAddressObj, ia_familyID, IPv4);
        (*env)->SetObjectField(env, socket, psi_addressID, socketAddressObj);
a710 1
        jbyteArray addr;
a711 7
        if (inet6Cls == 0) {
            jclass c = (*env)->FindClass(env, "java/net/Inet6Address");
            if (c != NULL) {
                inet6Cls = (*env)->NewGlobalRef(env, c);
                (*env)->DeleteLocalRef(env, c);
            }
        }
d713 1
a713 17
        if (inet6Cls != NULL) {
            socketAddressObj = (*env)->NewObject(env, inet6Cls, ia6_ctrID);
        } else {
            socketAddressObj = NULL;
        }
        if (socketAddressObj == NULL) {
            /*
             * FindClass or NewObject failed so close connection and
             * exist (there will be a pending exception).
             */
            NET_SocketClose(fd);
            return;
        }
        addr = (*env)->GetObjectField (env, socketAddressObj, ia6_ipaddressID);
        (*env)->SetByteArrayRegion (env, addr, 0, 16, (const char *)&him.him6.sin6_addr);
        (*env)->SetIntField(env, socketAddressObj, ia_familyID, IPv6);
        (*env)->SetIntField(env, socketAddressObj, ia6_scopeidID, him.him6.sin6_scope_id);
d717 5
a721 5
    port = ntohs ((u_short) GET_PORT (&him));
    (*env)->SetIntField(env, socket, psi_portID, (int)port);
    port = (*env)->GetIntField(env, this, psi_localportID);
    (*env)->SetIntField(env, socket, psi_localportID, port);
    (*env)->SetObjectField(env, socket, psi_addressID, socketAddressObj);
d729 1
a729 2
JNIEXPORT jint JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketAvailable(JNIEnv *env, jobject this) {
d731 4
a734 4
    jint available = -1;
    jint res;
    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);
    jint fd;
d737 1
a737 1
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
d740 1
a740 1
        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d742 1
a742 1
    res = ioctlsocket(fd, FIONREAD, &available);
d747 1
a747 1
    return available;
d755 1
a755 3
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketClose0(JNIEnv *env, jobject this,
                                           jboolean useDeferredClose) {
d757 4
a760 3
    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);
    jobject fd1Obj = (*env)->GetObjectField(env, this, psi_fd1ID);
    jint fd=-1, fd1=-1;
d763 1
a763 1
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d768 1
a768 1
        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d771 1
a771 1
        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);
d773 2
a774 2
    if (fd != -1) {
        (*env)->SetIntField(env, fdObj, IO_fd_fdID, -1);
d777 2
a778 2
    if (fd1 != -1) {
        (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, -1);
d791 5
a795 10
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketSetOption(JNIEnv *env, jobject this,
                                              jint cmd, jboolean on,
                                              jobject value) {
    int fd, fd1;
    int level, optname, optlen;
    union {
        int i;
        struct linger ling;
    } optval;
d800 4
a803 4
    fd = getFD(env, this);
    fd1 = getFD1(env, this);
    if (fd < 0 && fd1 < 0) {
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
d822 1
a822 1
        jobject ssObj = (*env)->GetObjectField(env, this, psi_serverSocketID);
d834 1
a834 8
            jclass iCls = (*env)->FindClass(env, "java/lang/Integer");
            jfieldID i_valueID;
            jint timeout;

            CHECK_NULL(iCls);
            i_valueID = (*env)->GetFieldID(env, iCls, "value", "I");
            CHECK_NULL(i_valueID);
            timeout = (*env)->GetIntField(env, value, i_valueID);
d843 1
a843 2
            if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout,
                sizeof(timeout)) < 0) {
d850 2
a851 3
            if (fd1 != -1) {
                if (setsockopt(fd1, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout,
                                        sizeof(timeout)) < 0) {
d863 2
a864 2
    if (NET_MapSocketOption(cmd, &level, &optname)) {
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d875 1
a875 2
            optval.i = (on ? 1 : 0);
            optlen = sizeof(optval.i);
d881 1
a881 12
            {
                jclass cls;
                jfieldID fid;

                cls = (*env)->FindClass(env, "java/lang/Integer");
                CHECK_NULL(cls);
                fid = (*env)->GetFieldID(env, cls, "value", "I");
                CHECK_NULL(fid);

                optval.i = (*env)->GetIntField(env, value, fid);
                optlen = sizeof(optval.i);
            }
d886 1
a886 8
                jclass cls;
                jfieldID fid;

                cls = (*env)->FindClass(env, "java/lang/Integer");
                CHECK_NULL(cls);
                fid = (*env)->GetFieldID(env, cls, "value", "I");
                CHECK_NULL(fid);

d888 2
a889 2
                    optval.ling.l_onoff = 1;
                    optval.ling.l_linger = (*env)->GetIntField(env, value, fid);
d891 2
a892 2
                    optval.ling.l_onoff = 0;
                    optval.ling.l_linger = 0;
d894 1
a894 1
                optlen = sizeof(optval.ling);
d899 1
a899 1
            JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d904 2
a905 2
    if (fd != -1) {
        if (NET_SetSockOpt(fd, level, optname, (void *)&optval, optlen) < 0) {
d910 2
a911 2
    if (fd1 != -1) {
        if (NET_SetSockOpt(fd1, level, optname, (void *)&optval, optlen) < 0) {
d923 6
a928 10
JNIEXPORT jint JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketGetOption(JNIEnv *env, jobject this,
                                              jint opt, jobject iaContainerObj) {

    int fd, fd1;
    int level, optname, optlen;
    union {
        int i;
        struct linger ling;
    } optval;
d933 2
a934 2
    fd = getFD(env, this);
    fd1 = getFD1(env, this);
d936 2
a937 2
    if (fd < 0 && fd1 < 0) {
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
d940 1
a940 1
    if (fd < 0) {
d950 4
a953 6
        SOCKET_ADDRESS him;
        int len;
        int port;
        jobject iaObj;
        jclass iaCntrClass;
        jfieldID iaFieldID;
d955 1
a955 3
        len = sizeof(struct sockaddr_in);

        if (fd == -1) {
d959 1
a959 2
            fd = getFD1 (env, this);
            len = sizeof(struct SOCKADDR_IN6);
d962 2
a963 2
        if (getsockname(fd, (struct sockaddr *)&him, &len) < 0) {
            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException",
d967 2
a968 7
        iaObj = NET_SockaddrToInetAddress(env, (struct sockaddr *)&him, &port);
        CHECK_NULL_RETURN(iaObj, -1);

        iaCntrClass = (*env)->GetObjectClass(env, iaContainerObj);
        iaFieldID = (*env)->GetFieldID(env, iaCntrClass, "addr", "Ljava/net/InetAddress;");
        CHECK_NULL_RETURN(iaFieldID, -1);
        (*env)->SetObjectField(env, iaContainerObj, iaFieldID, iaObj);
d976 2
a977 2
    if (NET_MapSocketOption(opt, &level, &optname)) {
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Invalid option");
d985 1
a985 1
        optlen = sizeof(optval.ling);
d987 1
a987 2
        optlen = sizeof(optval.i);
        optval.i = 0;
d990 1
a990 1
    if (NET_GetSockOpt(fd, level, optname, (void *)&optval, &optlen) < 0) {
d997 1
a997 1
            return (optval.ling.l_onoff ? optval.ling.l_linger: -1);
d1002 1
a1002 1
            return optval.i;
d1008 1
a1008 1
            return (optval.i == 0) ? -1 : 1;
d1011 1
a1011 1
            JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d1022 1
a1022 3
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketShutdown(JNIEnv *env, jobject this,
                                             jint howto)
d1025 2
a1026 2
    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);
    jint fd;
d1033 1
a1033 1
        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
d1037 1
a1037 1
        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d1047 1
a1047 3
JNIEXPORT void JNICALL
Java_java_net_TwoStacksPlainSocketImpl_socketSendUrgentData(JNIEnv *env, jobject this,
                                             jint data) {
d1049 3
a1051 3
    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);
    int n, fd;
    unsigned char d = data & 0xff;
d1057 1
a1057 1
        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
d1061 1
a1061 1
        if (fd == -1) {
d1067 1
a1067 1
    n = send(fd, (char *)&data, 1, MSG_OOB);
d1073 1
a1073 1
        JNU_ThrowByName(env, "java/io/InterruptedIOException", 0);
d1077 1
@

