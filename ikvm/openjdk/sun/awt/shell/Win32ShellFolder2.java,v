head	1.15;
access;
symbols
	v8_1_5717_0:1.15
	v8_1:1.15.0.2
	v8_0_5449_1:1.14
	v8_0_5449_0:1.14
	v8_0:1.14.0.2
	v7_4_5196_0:1.13
	v7_4:1.13.0.8
	v7_3:1.13.0.6
	v7_2_4630_6:1.13
	v7_2_4630_5:1.13
	v7_2_4630_4:1.13
	v7_2_4630_3:1.13
	v7_2_4630_2:1.13
	v0_46_0_4:1.10
	v7_2_4630_1:1.13
	v7_2:1.13.0.4
	v7_1_4532_2:1.13
	v7_1_4532_1:1.13
	v7_1_4532_0:1.13
	v7_1:1.13.0.2
	v7_0_4335_3:1.10
	v7_0_4335_2:1.10
	v7_0_4335_1:1.10
	v0_46_0_2:1.10
	v7_0_4335_0:1.10
	v7_0:1.10.0.4
	v0_46_0_1:1.10
	v0_46_0_0:1.10
	v0_46:1.10.0.2
	v0_44_0_6:1.6
	v0_44_0_5:1.6
	v0_44_0_4:1.6
	v0_44_0_3:1.6
	v0_44_0_2:1.6
	v0_42_0_7:1.5
	v0_44_0_1:1.6
	v0_44_0_0:1.6
	v0_44:1.6.0.2
	v0_42_0_6:1.5
	v0_42_0_5:1.5
	v0_42_0_4:1.5
	v0_42_0_3:1.5
	v0_42_0_2:1.5
	v0_42_0_1:1.5
	v0_42_0_0:1.5
	v0_42:1.5.0.2;
locks; strict;
comment	@# @;


1.15
date	2015.06.09.09.28.44;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.19.12.43.40;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2012.03.21.08.36.09;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2012.03.19.09.03.32;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2012.03.18.13.24.31;	author smallsql;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.24.16.40.23;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.01.06.49.35;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2010.11.08.15.42.32;	author smallsql;	state Exp;
branches;
next	1.7;

1.7
date	2010.08.09.09.07.06;	author smallsql;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.11.06.57.44;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.12.18.36.50;	author smallsql;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.27.20.43.43;	author smallsql;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.27.17.51.28;	author smallsql;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.27.10.22.34;	author smallsql;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.21.19.22.29;	author smallsql;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Integrated OpenJDK 8u45.
@
text
@/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * Copyright (C) 2009 Volker Berlin (i-net software)
 * Copyright (C) 2010 Karsten Heinrich (i-net software)
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.shell;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;
import javax.swing.SwingConstants;

import cli.System.IntPtr;
import cli.System.Drawing.Bitmap;

// NOTE: This class basically a conversion of the OpenJDK Wen32ShellFolder2, but uses
// .NET pointers and objects instead of representing pointers as long

/**
 * Win32 Shell Folders
 * <P>
 * <BR>
 * There are two fundamental types of shell folders : file system folders
 * and non-file system folders.  File system folders are relatively easy
 * to deal with.  Non-file system folders are items such as My Computer,
 * Network Neighborhood, and the desktop.  Some of these non-file system
 * folders have special values and properties.
 * <P>
 * <BR>
 * Win32 keeps two basic data structures for shell folders.  The first
 * of these is called an ITEMIDLIST.  Usually a pointer, called an
 * LPITEMIDLIST, or more frequently just "PIDL".  This structure holds
 * a series of identifiers and can be either relative to the desktop
 * (an absolute PIDL), or relative to the shell folder that contains them.
 * Some Win32 functions can take absolute or relative PIDL values, and
 * others can only accept relative values.
 * <BR>
 * The second data structure is an IShellFolder COM interface.  Using
 * this interface, one can enumerate the relative PIDLs in a shell
 * folder, get attributes, etc.
 * <BR>
 * All Win32ShellFolder2 objects which are folder types (even non-file
 * system folders) contain an IShellFolder object. Files are named in
 * directories via relative PIDLs.
 *
 * @@author Michael Martak
 * @@author Leif Samuelsson
 * @@author Kenneth Russell
 * @@author Volker Berlin
 * @@author Karsten Heinrich
 * @@since 1.4 */

final class Win32ShellFolder2 extends ShellFolder {

    // Win32 Shell Folder Constants
    public static final int DESKTOP = 0x0000;
    public static final int INTERNET = 0x0001;
    public static final int PROGRAMS = 0x0002;
    public static final int CONTROLS = 0x0003;
    public static final int PRINTERS = 0x0004;
    public static final int PERSONAL = 0x0005;
    public static final int FAVORITES = 0x0006;
    public static final int STARTUP = 0x0007;
    public static final int RECENT = 0x0008;
    public static final int SENDTO = 0x0009;
    public static final int BITBUCKET = 0x000a;
    public static final int STARTMENU = 0x000b;
    public static final int DESKTOPDIRECTORY = 0x0010;
    public static final int DRIVES = 0x0011;
    public static final int NETWORK = 0x0012;
    public static final int NETHOOD = 0x0013;
    public static final int FONTS = 0x0014;
    public static final int TEMPLATES = 0x0015;
    public static final int COMMON_STARTMENU = 0x0016;
    public static final int COMMON_PROGRAMS = 0X0017;
    public static final int COMMON_STARTUP = 0x0018;
    public static final int COMMON_DESKTOPDIRECTORY = 0x0019;
    public static final int APPDATA = 0x001a;
    public static final int PRINTHOOD = 0x001b;
    public static final int ALTSTARTUP = 0x001d;
    public static final int COMMON_ALTSTARTUP = 0x001e;
    public static final int COMMON_FAVORITES = 0x001f;
    public static final int INTERNET_CACHE = 0x0020;
    public static final int COOKIES = 0x0021;
    public static final int HISTORY = 0x0022;

    // Win32 shell folder attributes
    public static final int ATTRIB_CANCOPY          = 0x00000001;
    public static final int ATTRIB_CANMOVE          = 0x00000002;
    public static final int ATTRIB_CANLINK          = 0x00000004;
    public static final int ATTRIB_CANRENAME        = 0x00000010;
    public static final int ATTRIB_CANDELETE        = 0x00000020;
    public static final int ATTRIB_HASPROPSHEET     = 0x00000040;
    public static final int ATTRIB_DROPTARGET       = 0x00000100;
    public static final int ATTRIB_LINK             = 0x00010000;
    public static final int ATTRIB_SHARE            = 0x00020000;
    public static final int ATTRIB_READONLY         = 0x00040000;
    public static final int ATTRIB_GHOSTED          = 0x00080000;
    public static final int ATTRIB_HIDDEN           = 0x00080000;
    public static final int ATTRIB_FILESYSANCESTOR  = 0x10000000;
    public static final int ATTRIB_FOLDER           = 0x20000000;
    public static final int ATTRIB_FILESYSTEM       = 0x40000000;
    public static final int ATTRIB_HASSUBFOLDER     = 0x80000000;
    public static final int ATTRIB_VALIDATE         = 0x01000000;
    public static final int ATTRIB_REMOVABLE        = 0x02000000;
    public static final int ATTRIB_COMPRESSED       = 0x04000000;
    public static final int ATTRIB_BROWSABLE        = 0x08000000;
    public static final int ATTRIB_NONENUMERATED    = 0x00100000;
    public static final int ATTRIB_NEWCONTENT       = 0x00200000;

    // IShellFolder::GetDisplayNameOf constants
    public static final int SHGDN_NORMAL            = 0;
    public static final int SHGDN_INFOLDER          = 1;
    public static final int SHGDN_INCLUDE_NONFILESYS= 0x2000;
    public static final int SHGDN_FORADDRESSBAR     = 0x4000;
    public static final int SHGDN_FORPARSING        = 0x8000;

    // Values for system call LoadIcon()
    public enum SystemIcon {
        IDI_APPLICATION(32512),
        IDI_HAND(32513),
        IDI_ERROR(32513),
        IDI_QUESTION(32514),
        IDI_EXCLAMATION(32515),
        IDI_WARNING(32515),
        IDI_ASTERISK(32516),
        IDI_INFORMATION(32516),
        IDI_WINLOGO(32517);

        private final int iconID;

        SystemIcon(int iconID) {
            this.iconID = iconID;
        }

        public int getIconID() {
            return iconID;
        }
    }

    static class FolderDisposer implements sun.java2d.DisposerRecord {
        /*
         * This is cached as a concession to getFolderType(), which needs
         * an absolute PIDL.
         */
        cli.System.IntPtr absolutePIDL;
        /*
         * We keep track of shell folders through the IShellFolder
         * interface of their parents plus their relative PIDL.
         */
        cli.System.Object pIShellFolder;
        cli.System.IntPtr relativePIDL;

        boolean disposed;
 
        @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
        public void dispose() {
            if (disposed)
                return;
            if ( relativePIDL != null && !cli.System.IntPtr.Zero.Equals( relativePIDL ) ) {
                releasePIDL(relativePIDL);
            }
            if ( absolutePIDL != null && !cli.System.IntPtr.Zero.Equals( absolutePIDL ) ) {
                releasePIDL(absolutePIDL);
            }
            if ( pIShellFolder != null ) {
                releaseIShellFolder(pIShellFolder);
            }
            disposed = true;
        }
    }

    FolderDisposer disposer = new FolderDisposer();

    private void setIShellFolder( cli.System.Object iShellFolder ) {
        disposer.pIShellFolder = iShellFolder;
    }

    private void setRelativePIDL(cli.System.IntPtr relativePIDL) {
        disposer.relativePIDL = relativePIDL;
    }

    /*
     * The following are for caching various shell folder properties.
     */
    private cli.System.Object pIShellIcon = null;
    private String folderType = null;
    private String displayName = null;
    private Image smallIcon = null;
    private Image largeIcon = null;
    private Boolean isDir = null;

    /*
     * The following is to identify the My Documents folder as being special
     */
    private boolean isPersonal;

    /**
     * Create a system special shell folder, such as the
     * desktop or Network Neighborhood.
     */
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    Win32ShellFolder2(final int csidl) throws IOException, InterruptedException {
        // Desktop is parent of DRIVES and NETWORK, not necessarily
        // other special shell folders.
        super ( null, (getFileSystemPath(csidl) == null) ? ("ShellFolder: 0x" + Integer.toHexString(csidl)) : getFileSystemPath(csidl));
        if (csidl == DESKTOP) {
        	// compared to the Java implementation we require two steps here since
        	// we don't have a callback from the native methods in to this instance
            setIShellFolder( initDesktopFolder() );
            setRelativePIDL( initDesktopPIDL() );
        } else {
        	cli.System.Object desktopFolder = getDesktop().getIShellFolder();
        	cli.System.IntPtr pidl = initSpecialPIDL( desktopFolder, csidl );
            setRelativePIDL( pidl );
            setIShellFolder( initSpecialFolder(desktopFolder, pidl) );
            // At this point, the native method initSpecial() has set our relativePIDL
            // relative to the Desktop, which may not be our immediate parent. We need
            // to traverse this ID list and break it into a chain of shell folders from
            // the top, with each one having an immediate parent and a relativePIDL
            // relative to that parent.
            bindToDesktop();
        }

        sun.java2d.Disposer.addRecord(this , disposer);
    }

        @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
	protected void bindToDesktop() {
		cli.System.IntPtr pIDL = disposer.relativePIDL;
		parent = getDesktop();
		while ( pIDL != null && !cli.System.IntPtr.Zero.Equals( pIDL ) ) {
		    // Get a child pidl relative to 'parent'
			cli.System.IntPtr childPIDL = copyFirstPIDLEntry(pIDL);
		    if (childPIDL != null && !cli.System.IntPtr.Zero.Equals( childPIDL ) ) {
		        // Get a handle to the the rest of the ID list
		        // i,e, parent's grandchilren and down
		        pIDL = getNextPIDLEntry(pIDL);
		        if ( pIDL != null && !cli.System.IntPtr.Zero.Equals( pIDL ) ) {
		            // Now we know that parent isn't immediate to 'this' because it
		            // has a continued ID list. Create a shell folder for this child
		            // pidl and make it the new 'parent'.
		            parent = new Win32ShellFolder2( (Win32ShellFolder2) parent, childPIDL );
		        } else {
		            // No grandchildren means we have arrived at the parent of 'this',
		            // and childPIDL is directly relative to parent.
		            disposer.relativePIDL = childPIDL;
		        }
		    } else {
		        break;
		    }
		}
	}

    /**
     * Create a system shell folder
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    Win32ShellFolder2(Win32ShellFolder2 parent, cli.System.Object pIShellFolder, cli.System.IntPtr relativePIDL, String path) {
        super(parent, (path != null) ? path : "ShellFolder: ");
        this.disposer.pIShellFolder = pIShellFolder;
        this.disposer.relativePIDL = relativePIDL;
        sun.java2d.Disposer.addRecord(this, disposer);
    }

    /**
     * Creates a shell folder with a parent and relative PIDL
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    Win32ShellFolder2(Win32ShellFolder2 parent, cli.System.IntPtr relativePIDL) {
        super (parent, getFileSystemPath(parent.getIShellFolder(), relativePIDL));
        this .disposer.relativePIDL = relativePIDL;
        getAbsolutePath();
        sun.java2d.Disposer.addRecord(this , disposer);
    }

    // Initializes the desktop shell folder
    /**
     * Returns the pIDL of the Desktop folder (pIDL root)
     * @@return the pIDL of the Desktop folder (pIDL root)
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.IntPtr initDesktopPIDL();
    /**
     * Returns the IShellFolder pointer of the Desktop folder (pIDL root)
     * @@return the IShellFolder pointer of the Desktop folder (pIDL root)
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.Object initDesktopFolder();

    // Initializes a special, non-file system shell folder
    // from one of the above constants
    /**
     * initializes a special folder
     * @@param desktopIShellFolder the IShellFolder reference of the desktop folder
     * @@param csidl the CSIDL of the requested special folder
     * @@return the pIDL of the special folder relative to the desktop root
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.IntPtr initSpecialPIDL(cli.System.Object desktopIShellFolder, int csidl);
    /**
     * initializes a special folder
     * @@param desktopIShellFolder the IShellFolder reference of the desktop folder
     * @@param pidl the pIDL of the requested folder relative to the desktopIShellFolder
     * @@return the IShellFolder reference for the requested folder
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.Object initSpecialFolder(cli.System.Object desktopIShellFolder, cli.System.IntPtr pidl);

    /** Marks this folder as being the My Documents (Personal) folder */
    public void setIsPersonal() {
        isPersonal = true;
    }

    /**
     * This method is implemented to make sure that no instances
     * of <code>ShellFolder</code> are ever serialized. If <code>isFileSystem()</code> returns
     * <code>true</code>, then the object is representable with an instance of
     * <code>java.io.File</code> instead. If not, then the object depends
     * on native PIDL state and should not be serialized.
     *
     * @@returns a <code>java.io.File</code> replacement object. If the folder
     * is a not a normal directory, then returns the first non-removable
     * drive (normally "C:\").
     */
    protected Object writeReplace()
            throws java.io.ObjectStreamException {
        if (isFileSystem()) {
            return new File(getPath());
        } else {
            Win32ShellFolder2 drives = Win32ShellFolderManager2.getDrives();
            if (drives != null) {
                File[] driveRoots = drives.listFiles();
                if (driveRoots != null) {
                    for (int i = 0; i < driveRoots.length; i++) {
                        if (driveRoots[i] instanceof  Win32ShellFolder2) {
                            Win32ShellFolder2 sf = (Win32ShellFolder2) driveRoots[i];
                            if (sf.isFileSystem() && !sf.hasAttribute(ATTRIB_REMOVABLE)) {
                                return new File(sf.getPath());
                            }
                        }
                    }
                }
            }
            // Ouch, we have no hard drives. Return something "valid" anyway.
            return new File("C:\\");
        }
    }

    /**
     * Finalizer to clean up any COM objects or PIDLs used by this object.
     */
    protected void dispose() {
        disposer.dispose();
    }

    // Given a (possibly multi-level) relative PIDL (with respect to
    // the desktop, at least in all of the usage cases in this code),
    // return a pointer to the next entry. Does not mutate the PIDL in
    // any way. Returns 0 if the null terminator is reached.
    // Needs to be accessible to Win32ShellFolderManager2
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native cli.System.IntPtr getNextPIDLEntry(cli.System.IntPtr pIDL);

    // Given a (possibly multi-level) relative PIDL (with respect to
    // the desktop, at least in all of the usage cases in this code),
    // copy the first entry into a newly-allocated PIDL. Returns 0 if
    // the PIDL is at the end of the list.
    // Needs to be accessible to Win32ShellFolderManager2
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native cli.System.IntPtr copyFirstPIDLEntry(cli.System.IntPtr pIDL);

    // Given a parent's absolute PIDL and our relative PIDL, build an absolute PIDL
    /**
     * Combines a parent pIDL with a descendant pIDL. It doesn't matter whether the parent pIDL
     * is relative or absolute since this is only a concatenation of the IDLs
     * @@param ppIDL the parent pIDL
     * @@param pIDL the pIDL relative to the ppIDL
     * @@return a pIDL for the item referenced by the original pIDL but relative to the parent of ppIDL 
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.IntPtr combinePIDLs(cli.System.IntPtr ppIDL, cli.System.IntPtr pIDL);

    // Release a PIDL object
    // Needs to be accessible to Win32ShellFolderManager2
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native void releasePIDL(cli.System.IntPtr pIDL);

    // Release an IShellFolder object
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native void releaseIShellFolder( cli.System.Object iShellFolder );

    /**
     * Accessor for IShellFolder
     */
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    public cli.System.Object getIShellFolder() {
        if (disposer.pIShellFolder == null ) {
            assert (isDirectory());
            assert (parent != null);
            cli.System.Object parentIShellFolder = getParentIShellFolder();
            if (parentIShellFolder == null) {
                throw new InternalError( "Parent IShellFolder was null for " + getAbsolutePath() );
            }
            // We are a directory with a parent and a relative PIDL.
            // We want to bind to the parent so we get an IShellFolder instance associated with us.
            disposer.pIShellFolder = bindToObject(parentIShellFolder, disposer.relativePIDL);
            if (disposer.pIShellFolder == null ) {
                throw new InternalError("Unable to bind " + getAbsolutePath() + " to parent");
            }
        }
        return disposer.pIShellFolder;
    }

    /**
     * Get the parent ShellFolder's IShellFolder interface
     */
    public cli.System.Object getParentIShellFolder() {
        Win32ShellFolder2 parent = (Win32ShellFolder2) getParentFile();
        cli.System.Object parentFolder;
        if (parent == null) {
            // Parent should only be null if this is the desktop, whose
            // relativePIDL is relative to its own IShellFolder.
        	parentFolder = getIShellFolder();
        } else {
        	parentFolder = parent.getIShellFolder();
        }
        return parentFolder;
    }

    /**
     * Accessor for relative PIDL
     */
    public cli.System.IntPtr getRelativePIDL() {
        if (disposer.relativePIDL == null) {
            throw new InternalError( "Should always have a relative PIDL" );
        }
        return disposer.relativePIDL;
    }

    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    private cli.System.IntPtr getAbsolutePIDL() {
        if (parent == null) {
            // This is the desktop
            return getRelativePIDL();
        } else {
            if (disposer.absolutePIDL == null || disposer.absolutePIDL.Equals( IntPtr.Zero )) {
                disposer.absolutePIDL = combinePIDLs( ((Win32ShellFolder2) parent).getAbsolutePIDL(), getRelativePIDL());
            }

            return disposer.absolutePIDL;
        }
    }

    /**
     * Helper function to return the desktop
     */
    public Win32ShellFolder2 getDesktop() {
        return Win32ShellFolderManager2.getDesktop();
    }

    /**
     * Helper function to return the desktop IShellFolder interface
     */
    public cli.System.Object getDesktopIShellFolder() {
        return getDesktop().getIShellFolder();
    }

    private static boolean pathsEqual(String path1, String path2) {
        // Same effective implementation as Win32FileSystem
        return path1.equalsIgnoreCase(path2);
    }

    /**
     * Check to see if two ShellFolder objects are the same
     */
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    public boolean equals(Object o) {
        if (o == null || !(o instanceof Win32ShellFolder2)) {
            // Short-circuit circuitous delegation path
            if (!(o instanceof File)) {
                return super.equals(o);
            }
            return pathsEqual(getPath(), ((File) o).getPath());
        }
        Win32ShellFolder2 rhs = (Win32ShellFolder2) o;
        if ((parent == null && rhs.parent != null) ||
            (parent != null && rhs.parent == null)) {
            return false;
        }

        if (isFileSystem() && rhs.isFileSystem()) {
            // Only folders with identical parents can be equal
            return (pathsEqual(getPath(), rhs.getPath()) &&
                    (parent == rhs.parent || parent.equals(rhs.parent)));
        }

        if (parent == rhs.parent || parent.equals(rhs.parent)) {
            try {
                return pidlsEqual(getParentIShellFolder(), disposer.relativePIDL, rhs.disposer.relativePIDL);
            } catch (InterruptedException e) {
                return false;
            }
        }

        return false;
    }

    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static boolean pidlsEqual(final cli.System.Object pIShellFolder, final cli.System.IntPtr pidl1, final cli.System.IntPtr pidl2)
            throws InterruptedException {
        return invoke(new Callable<Boolean>() {
            @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
            public Boolean call() {
                return compareIDs(pIShellFolder, pidl1, pidl2) == 0;
            }
        }, RuntimeException.class);
    }

    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native int compareIDs(cli.System.Object pParentIShellFolder, cli.System.IntPtr pidl1, cli.System.IntPtr pidl2);

    private volatile Boolean cachedIsFileSystem;

    /**
     * @@return Whether this is a file system shell folder
     */
    public boolean isFileSystem() {
        if (cachedIsFileSystem == null) {
            cachedIsFileSystem = hasAttribute(ATTRIB_FILESYSTEM);
        }

        return cachedIsFileSystem;
    }

    /**
     * Return whether the given attribute flag is set for this object
     */
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    public boolean hasAttribute(int attribute) {
        // Caching at this point doesn't seem to be cost efficient
        return (getAttributes0(getParentIShellFolder(), getRelativePIDL(), attribute) & attribute) != 0;
    }

    /**
     * Returns the queried attributes specified in attrsMask.
     *
     * Could plausibly be used for attribute caching but have to be
     * very careful not to touch network drives and file system roots
     * with a full attrsMask
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native int getAttributes0(cli.System.Object pParentIShellFolder, cli.System.IntPtr pIDL, int attrsMask);

    // Return the path to the underlying file system object
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static String getFileSystemPath(cli.System.Object parentIShellFolder, cli.System.IntPtr relativePIDL) {
        int linkedFolder = ATTRIB_LINK | ATTRIB_FOLDER;
        if (parentIShellFolder == Win32ShellFolderManager2.getNetwork().getIShellFolder() &&
                getAttributes0(parentIShellFolder, relativePIDL, linkedFolder) == linkedFolder) {

        	cli.System.Object desktopIShellFolder = Win32ShellFolderManager2.getDesktop().getIShellFolder();
            String path = getDisplayNameOf(parentIShellFolder, relativePIDL, SHGDN_FORPARSING );
			String s = getFileSystemPath(desktopIShellFolder, getLinkLocation( path, false));
            if (s != null && s.startsWith("\\\\")) {
                return s;
            }
        }
        return getDisplayNameOf(parentIShellFolder, relativePIDL, SHGDN_NORMAL | SHGDN_FORPARSING);
    }

    // Needs to be accessible to Win32ShellFolderManager2
    static String getFileSystemPath(final int csidl) throws IOException, InterruptedException {
        String path = invoke(new Callable<String>() {
            public String call() throws IOException {
                return getFileSystemPath0(csidl);
            }
        }, IOException.class);
        if (path != null) {
            SecurityManager security = System.getSecurityManager();
            if (security != null) {
                security.checkRead(path);
            }
        }
        return path;
    }

    // NOTE: this method uses COM and must be called on the 'COM thread'. See ComInvoker for the details
    private static native String getFileSystemPath0(int csidl) throws IOException;

    // Return whether the path is a network root.
    // Path is assumed to be non-null
    private static boolean isNetworkRoot(String path) {
        return (path.equals("\\\\") || path.equals("\\") || path.equals("//") || path.equals("/"));
    }

    /**
     * @@return The parent shell folder of this shell folder, null if
     * there is no parent
     */
    public File getParentFile() {
        return parent;
    }

    public boolean isDirectory() {
        if (isDir == null) {
            // Folders with SFGAO_BROWSABLE have "shell extension" handlers and are
            // not traversable in JFileChooser.
            if (hasAttribute(ATTRIB_FOLDER) && !hasAttribute(ATTRIB_BROWSABLE)) {
                isDir = Boolean.TRUE;
            } else if (isLink()) {
                ShellFolder linkLocation = getLinkLocation(false);
                isDir = Boolean.valueOf(linkLocation != null && linkLocation.isDirectory());
            } else {
                isDir = Boolean.FALSE;
            }
        }
        return isDir.booleanValue();
    }

    /*
     * Functions for enumerating an IShellFolder's children
     */
    // Returns an IEnumIDList interface for an IShellFolder.  The value
    // returned must be released using releaseEnumObjects().
    /**
     * Returns an IEnumIDList interface for an IShellFolder.  The value 
     * returned must be released using releaseEnumObjects().
     * @@param pIShellFolder the IShellFolder instance of the parent shell folder
     * @@param includeHiddenFiles if true, hidden files will be included in the enumeration
     * @@return an instance of IEnumIDList 
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    cli.System.Object getEnumObjects(cli.System.Object pIShellFolder, boolean includeHiddenFiles) {
        boolean isDesktop = (disposer.pIShellFolder == getDesktopIShellFolder());
        return getEnumObjects(disposer.pIShellFolder, isDesktop, includeHiddenFiles);
    }

    /**
     * Returns an IEnumIDList interface for an IShellFolder.  The value 
     * returned must be released using releaseEnumObjects().
     * @@param pIShellFolder the IShellFolder instance of the parent shell folder
     * @@param isDesktop must be set to true, if the pIShellFolder is the desktop shell folder
     * @@param includeHiddenFiles if true, hidden files will be included in the enumeration
     * @@return an instance of IEnumIDList 
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.Object getEnumObjects(cli.System.Object pIShellFolder, boolean isDesktop, boolean includeHiddenFiles);

    /**
     * Returns the next sequential child as a relative PIDL
     * from an IEnumIDList interface.  The value returned must
     * be released using releasePIDL().
     * @@param pEnumObjects the IEnumIDList instance to get the next child from
     * @@return the next child or {@@link IntPtr#Zero} if the end of the enumeration is reached 
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native cli.System.IntPtr getNextChild(cli.System.Object pEnumObjects);

    /**
     * Releases the IEnumIDList interface
     * @@param pEnumObjects an IEnumIDList instance 
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native void releaseEnumObjects(cli.System.Object pEnumObjects);

    /**
     * Returns the IShellFolder of a child from a parent IShellFolder and a relative pIDL. The pIDL
     * may as well be any other  descendant of the shell folder - at least this is, what the windows API 
     * documentation says.  
     * The value returned must be released using releaseIShellFolder().
     * @@param parentIShellFolder an IShellFolder instance as root for the pIDL 
     * @@param pIDL a pIDL relative to the parent shell folder
     * @@return a NEW instance of an IShellFolder for the path given by the pIDL, may be null if the path is invalid
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.Object bindToObject(cli.System.Object parentIShellFolder, cli.System.IntPtr pIDL);

    /**
     * @@return An array of shell folders that are children of this shell folder
     *         object. The array will be empty if the folder is empty.  Returns
     *         <code>null</code> if this shellfolder does not denote a directory.
     */
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    public File[] listFiles(final boolean includeHiddenFiles) {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkRead(getPath());
        }

        try {
            return invoke(new Callable<File[]>() {
                @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
                public File[] call() throws InterruptedException {
                    if (!isDirectory()) {
                        return null;
                    }
                    // Links to directories are not directories and cannot be parents.
                    // This does not apply to folders in My Network Places (NetHood)
                    // because they are both links and real directories!
                    if (isLink() && !hasAttribute(ATTRIB_FOLDER)) {
                        return new File[0];
                    }

                    Win32ShellFolder2 desktop = Win32ShellFolderManager2.getDesktop();
                    Win32ShellFolder2 personal = Win32ShellFolderManager2.getPersonal();

                    // If we are a directory, we have a parent and (at least) a
                    // relative PIDL. We must first ensure we are bound to the
                    // parent so we have an IShellFolder to query.
                    cli.System.Object pIShellFolder = getIShellFolder();
                    // Now we can enumerate the objects in this folder.
                    ArrayList<Win32ShellFolder2> list = new ArrayList<Win32ShellFolder2>();
                    cli.System.Object pEnumObjects = getEnumObjects(pIShellFolder, includeHiddenFiles);
                    if (pEnumObjects != null) {
                        cli.System.IntPtr childPIDL = null;
                        int testedAttrs = ATTRIB_FILESYSTEM | ATTRIB_FILESYSANCESTOR;
                        do {
                            if (Thread.currentThread().isInterrupted()) {
                                return new File[0];
                            }
                            childPIDL = getNextChild(pEnumObjects);
                            boolean releasePIDL = true;
                            if ( childPIDL != null && !cli.System.IntPtr.Zero.Equals( childPIDL ) && (getAttributes0(pIShellFolder, childPIDL, testedAttrs) & testedAttrs) != 0) {
                                Win32ShellFolder2 childFolder = null;
                                if (this .equals(desktop) && personal != null
                                        && pidlsEqual(pIShellFolder, childPIDL, personal.disposer.relativePIDL) ) {
                                    childFolder = personal;
                                } else {
                                    childFolder = new Win32ShellFolder2(Win32ShellFolder2.this , childPIDL);
                                    releasePIDL = false;
                                }
                                list.add(childFolder);
                            }
                            if (releasePIDL) {
                                releasePIDL(childPIDL);
                            }
                        } while (childPIDL != null && !childPIDL.Equals( cli.System.IntPtr.Zero ));
                        releaseEnumObjects(pEnumObjects);
                    }
                    return Thread.currentThread().isInterrupted()
                        ? new File[0]
                        : list.toArray(new ShellFolder[list.size()]);
                }
            }, InterruptedException.class);
        } catch (InterruptedException e) {
            return new File[0];
        }
    }


    /**
     * Look for (possibly special) child folder by it's path. Note: this will not work an an ancestor(not child)
     * of the current folder. 
     * @@return The child shell folder, or null if not found.
     */
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    Win32ShellFolder2 getChildByPath(String filePath) {
    	cli.System.Object pIShellFolder = getIShellFolder();
    	cli.System.Object pEnumObjects = getEnumObjects(pIShellFolder, true);
        Win32ShellFolder2 child = null;
        cli.System.IntPtr childPIDL = null;
        
        childPIDL = getNextChild(pEnumObjects);
        while ( childPIDL != null && !cli.System.IntPtr.Zero.Equals( childPIDL ) ) {
            if (getAttributes0(pIShellFolder, childPIDL, ATTRIB_FILESYSTEM) != 0) {
                String path = getFileSystemPath(pIShellFolder, childPIDL);
                if (path != null && path.equalsIgnoreCase(filePath)) {
                	cli.System.Object childIShellFolder = bindToObject( pIShellFolder, childPIDL);
                    child = new Win32ShellFolder2(this, childIShellFolder, childPIDL, path);
                    break;
                }
            }
            releasePIDL(childPIDL);
            childPIDL = getNextChild(pEnumObjects);
        }
        releaseEnumObjects(pEnumObjects);
        return child;
    }

    private volatile Boolean cachedIsLink;

    /**
     * @@return Whether this shell folder is a link
     */
    public boolean isLink() {
        if (cachedIsLink == null) {
            cachedIsLink = hasAttribute(ATTRIB_LINK);
        }

        return cachedIsLink;
    }

    /**
     * @@return Whether this shell folder is marked as hidden
     */
    public boolean isHidden() {
        return hasAttribute(ATTRIB_HIDDEN);
    }

    // Return the link location of a shell folder
    /**
     * Resolves the link location of an item to an ABSOLUTE pIDL
     * @@param parentIShellFolder the pointer to the parent IShellFolder of the item
     * @@param relativePIDL a single-level pIDL to the item
     * @@param resolve 
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native cli.System.IntPtr getLinkLocation( String path, boolean resolve);

    /**
     * @@return The shell folder linked to by this shell folder, or null
     * if this shell folder is not a link or is a broken or invalid link
     */
    public ShellFolder getLinkLocation()  {
        return getLinkLocation(true);
    }

    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    private ShellFolder getLinkLocation(final boolean resolve) {
        return invoke(new Callable<ShellFolder>() {
            @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
            public ShellFolder call() {
                if (!isLink()) {
                    return null;
                }

                ShellFolder location = null;
                cli.System.IntPtr linkLocationPIDL = getLinkLocation( getAbsolutePath(), resolve);
                if (linkLocationPIDL != null && !cli.System.IntPtr.Zero.Equals( linkLocationPIDL ) ) {
                    try {
                        location =
                                Win32ShellFolderManager2.createShellFolderFromRelativePIDL(getDesktop(),
                                        linkLocationPIDL);
                    } catch (InterruptedException e) {
                        // Return null
                    } catch (InternalError e) {
                        // Could be a link to a non-bindable object, such as a network connection
                        // TODO: getIShellFolder() should throw FileNotFoundException instead
                    }
                }
                return location;
            }
        });
    }

    /**
     * Parse a display name into a PIDL relative to the current IShellFolder.
     * @@param name the name or relative path
     * @@return a pIDL for the path, may be {@@link IntPtr#Zero} if not found
     * @@throws FileNotFoundException
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    cli.System.IntPtr parseDisplayName(String name) throws FileNotFoundException {
        try {
            return parseDisplayName0(getIShellFolder(), name);
        } catch (IOException e) {
            throw new FileNotFoundException("Could not find file " + name);
        }
    }

    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.IntPtr parseDisplayName0(cli.System.Object pIShellFolder, String name) throws IOException;

    /**
     * Returns the display name of an item in a folder
     * @@param parentIShellFolder the pointer to the IShellFolder interface of the parent folder
     * @@param relativePIDL single-level pIDL to the requested item within the parent folder
     * @@param attrs formatting attributes for the display name, refer to SHGDN in MSDN
     * @@return
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native String getDisplayNameOf( cli.System.Object parentIShellFolder, cli.System.IntPtr relativePIDL, int attrs);

    /**
     * @@return The name used to display this shell folder
     */
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    public String getDisplayName() {
        if (displayName == null) {
            displayName = getDisplayNameOf(getParentIShellFolder(), getRelativePIDL(), SHGDN_NORMAL);
        }
        return displayName;
    }

    // Return the folder type of a shell folder
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native String getFolderType(cli.System.IntPtr pIDL);

    /**
     * @@return The type of shell folder as a string
     */
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    public String getFolderType() {
        if (folderType == null) {
            folderType = getFolderType(getAbsolutePIDL());
        }
        return folderType;
    }

    // Return the executable type of a file system shell folder
    private static native String getExecutableType(String path);

    /**
     * @@return The executable type as a string
     */
    public String getExecutableType() {
        if (!isFileSystem()) {
            return null;
        }
        return getExecutableType(getAbsolutePath());
    }

    // Icons

    private static Map smallSystemImages = new HashMap();
    private static Map largeSystemImages = new HashMap();
    private static Map smallLinkedSystemImages = new HashMap();
    private static Map largeLinkedSystemImages = new HashMap();

    /**
     * Returns the icon index in the system image list  
     * @@param parentIShellIcon the the pointer to the IShellIcon instance of the parent folder 
     * @@param relativePIDL the relative pIDL to the requested item
     * @@return the system image list index for the icon of the item or zero, if there is no entry
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native int getIconIndex(cli.System.Object parentIShellFolder, cli.System.IntPtr relativePIDL);

    // Return the icon of a file system shell folder in the form of an HICON
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.IntPtr getIcon(String absolutePath, boolean getLargeIcon);

    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.IntPtr extractIcon(cli.System.Object parentIShellFolder, cli.System.IntPtr relativePIDL,
                                           boolean getLargeIcon);

    /**
     * Returns the {@@link Bitmap} for a HICON.
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native Bitmap getIconBits(cli.System.IntPtr hIcon, int size);

    /**
     * Disposes a icon handle
     * @@param hIcon the handle to be disposed
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native void disposeIcon(cli.System.IntPtr hIcon);

    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native Bitmap getStandardViewButton0(int iconIndex);

    /**
     * Creates a Java icon for a HICON pointer
     * @@param hIcon the handle for the icon
     * @@param getLargeIcon true for a large icon, false for a small icon
     * @@return the created image or null, if the handle is invalid
     */
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static Image makeIcon(cli.System.IntPtr hIcon, boolean getLargeIcon) {
        if (hIcon != null ) {
            // Get the bits.  This has the side effect of setting the imageHash value for this object.
            Bitmap bitmap = getIconBits(hIcon, getLargeIcon ? 32 : 16 );
            if (bitmap == null) {
                return null;
            }            
            return new BufferedImage(bitmap);
        }
        return null;
    }


    /**
     * @@return The icon image used to display this shell folder
     */
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    public Image getIcon(boolean getLargeIcon) {
        Image icon = getLargeIcon ? largeIcon : smallIcon;
        if (icon == null) {
            cli.System.IntPtr relativePIDL = getRelativePIDL();

            if (isFileSystem() && parent != null) {
                // These are cached per type (using the index in the system image list)
                int index = getIconIndex( ((Win32ShellFolder2)parent).getIShellFolder(), relativePIDL);
                if (index > 0) {
                    Map imageCache;
                    if (isLink()) {
                        imageCache = getLargeIcon ? largeLinkedSystemImages : smallLinkedSystemImages;
                    } else {
                        imageCache = getLargeIcon ? largeSystemImages : smallSystemImages;
                    }
                    icon = (Image) imageCache.get(Integer.valueOf(index));
                    if (icon == null) {
                    	cli.System.IntPtr hIcon = getIcon(getAbsolutePath(), getLargeIcon);
                        icon = makeIcon(hIcon, getLargeIcon);
                        disposeIcon(hIcon);
                        if (icon != null) {
                            imageCache.put(Integer.valueOf(index), icon);
                        }
                    }
                }
            }

            if (icon == null) {
                // These are only cached per object
            	cli.System.IntPtr hIcon = extractIcon(getParentIShellFolder(), getRelativePIDL(), getLargeIcon);
                icon = makeIcon(hIcon, getLargeIcon);
                disposeIcon(hIcon);
            }

            if (getLargeIcon) {
                largeIcon = icon;
            } else {
                smallIcon = icon;
            }
        }
        if (icon == null) {
            icon = super .getIcon(getLargeIcon);
        }
        return icon;
    }

    /**
     * Gets an icon from the Windows system icon list as an <code>Image</code>
     */
    static Image getShell32Icon(int iconID, boolean getLargeIcon) {
        Bitmap bitmap = getShell32IconResourceAsBitmap(iconID, getLargeIcon);
        if (bitmap == null) {
            return null;
        }
        return new BufferedImage(bitmap);
    }
    
    private static native Bitmap getShell32IconResourceAsBitmap(int iconID, boolean getLargeIcon);

    /**
     * Returns the canonical form of this abstract pathname.  Equivalent to
     * <code>new&nbsp;Win32ShellFolder2(getParentFile(), this.{@@link java.io.File#getCanonicalPath}())</code>.
     *
     * @@see java.io.File#getCanonicalFile
     */
    public File getCanonicalFile() throws IOException {
        return this;
    }

    /*
     * Indicates whether this is a special folder (includes My Documents)
     */
    public boolean isSpecial() {
        return isPersonal || !isFileSystem() || (this == getDesktop());
    }

    /**
     * Compares this object with the specified object for order.
     *
     * @@see sun.awt.shell.ShellFolder#compareTo(File)
     */
    public int compareTo(File file2) {
        if (!(file2 instanceof Win32ShellFolder2)) {
            if (isFileSystem() && !isSpecial()) {
                return super.compareTo(file2);
            } else {
                return -1; // Non-file shellfolders sort before files
            }
        }
        return Win32ShellFolderManager2.compareShellFolders(this, (Win32ShellFolder2) file2);
    }

    // native constants from commctrl.h
    private static final int LVCFMT_LEFT = 0;
    private static final int LVCFMT_RIGHT = 1;
    private static final int LVCFMT_CENTER = 2;

    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    public ShellFolderColumnInfo[] getFolderColumns() {
    	Object o = doGetColumnInfo(getIShellFolder());
        ShellFolderColumnInfo[] columns = (ShellFolderColumnInfo[]) o;

        if (columns != null) {
            List<ShellFolderColumnInfo> notNullColumns = new ArrayList<ShellFolderColumnInfo>();
            for (int i = 0; i < columns.length; i++) {
                ShellFolderColumnInfo column = columns[i];
                if (column != null) {
                    column.setAlignment(column.getAlignment() == LVCFMT_RIGHT ? SwingConstants.RIGHT
                                    : column.getAlignment() == LVCFMT_CENTER ? SwingConstants.CENTER
                                            : SwingConstants.LEADING);

                    column.setComparator(new ColumnComparator(i));

                    notNullColumns.add(column);
                }
            }
            columns = new ShellFolderColumnInfo[notNullColumns.size()];
            notNullColumns.toArray(columns);
        }
        return columns;
    }

    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    public Object getFolderColumnValue(int column) {
        return doGetColumnValue(getParentIShellFolder(), getRelativePIDL(), column);
    }

    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native cli.System.Object /*ShellFolderColumnInfo[]*/ doGetColumnInfo( cli.System.Object iShellFolder2 );

    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    private static native Object doGetColumnValue(cli.System.Object parentIShellFolder2, cli.System.IntPtr childPIDL, int columnIdx);

    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native int compareIDsByColumn(cli.System.Object pParentIShellFolder, cli.System.IntPtr pidl1, cli.System.IntPtr pidl2, int columnIdx);

    private class ColumnComparator implements Comparator {
        private final int columnIdx;

        public ColumnComparator(int columnIdx) {
            this.columnIdx = columnIdx;
        }

        // compares 2 objects within this folder by the specified column
        @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
        public int compare(Object o, Object o1) {
            if (o instanceof  Win32ShellFolder2 && o1 instanceof  Win32ShellFolder2) {
                // delegates comparison to native method
                return compareIDsByColumn(getIShellFolder(),
                        ((Win32ShellFolder2) o).getRelativePIDL(),
                        ((Win32ShellFolder2) o1).getRelativePIDL(),
                        columnIdx);
            }
            return 0;
        }
    }
}@


1.14
log
@First part of OpenJDK 8 integration.
@
text
@d599 17
a615 2
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    static native String getFileSystemPath(int csidl) throws IOException, InterruptedException;
@


1.13
log
@Fixed the .NET 4 security attributes.
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2009, Oracle and/or its affiliates. All rights reserved.
@


1.12
log
@Fixed security critical attributes.
@
text
@d308 1
d314 1
d325 1
d599 1
d644 2
a645 1
    private cli.System.Object getEnumObjects(cli.System.Object pIShellFolder, boolean includeHiddenFiles) {
d658 1
d668 2
a669 1
    private static native cli.System.IntPtr getNextChild(cli.System.Object pEnumObjects);
d819 2
a820 1
    private static native cli.System.IntPtr getLinkLocation( String path, boolean resolve);
d864 1
d873 1
d942 1
d1086 1
d1111 1
d1116 1
d1119 1
d1122 2
a1123 1
    private static native int compareIDsByColumn(cli.System.Object pParentIShellFolder, cli.System.IntPtr pidl1, cli.System.IntPtr pidl2, int columnIdx);
d1133 1
@


1.11
log
@Merge Win32SchellFolder code with JDK7 sources to fix a bug with Windows7
@
text
@d533 1
a533 1
    private static boolean pidlsEqual(final cli.System.Object pIShellFolder, final cli.System.IntPtr pidl1, final cli.System.IntPtr pidl2)
d536 1
d544 1
a544 1
    private static native int compareIDs(cli.System.Object pParentIShellFolder, cli.System.IntPtr pidl1, cli.System.IntPtr pidl2);
d576 1
a576 1
    private static native int getAttributes0(cli.System.Object pParentIShellFolder, cli.System.IntPtr pIDL, int attrsMask);
d669 1
a669 1
    private static native void releaseEnumObjects(cli.System.Object pEnumObjects);
d697 1
d825 1
@


1.10
log
@Integrated OpenJDK 6 b21.
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
d35 2
a36 6
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

d68 1
a68 1
 * All Win32ShellFolder2Orig objects which are folder types (even non-file
d77 1
a77 1
 * */
d114 22
a135 22
    public static final int ATTRIB_CANCOPY = 0x00000001;
    public static final int ATTRIB_CANMOVE = 0x00000002;
    public static final int ATTRIB_CANLINK = 0x00000004;
    public static final int ATTRIB_CANRENAME = 0x00000010;
    public static final int ATTRIB_CANDELETE = 0x00000020;
    public static final int ATTRIB_HASPROPSHEET = 0x00000040;
    public static final int ATTRIB_DROPTARGET = 0x00000100;
    public static final int ATTRIB_LINK = 0x00010000;
    public static final int ATTRIB_SHARE = 0x00020000;
    public static final int ATTRIB_READONLY = 0x00040000;
    public static final int ATTRIB_GHOSTED = 0x00080000;
    public static final int ATTRIB_HIDDEN = 0x00080000;
    public static final int ATTRIB_FILESYSANCESTOR = 0x10000000;
    public static final int ATTRIB_FOLDER = 0x20000000;
    public static final int ATTRIB_FILESYSTEM = 0x40000000;
    public static final int ATTRIB_HASSUBFOLDER = 0x80000000;
    public static final int ATTRIB_VALIDATE = 0x01000000;
    public static final int ATTRIB_REMOVABLE = 0x02000000;
    public static final int ATTRIB_COMPRESSED = 0x04000000;
    public static final int ATTRIB_BROWSABLE = 0x08000000;
    public static final int ATTRIB_NONENUMERATED = 0x00100000;
    public static final int ATTRIB_NEWCONTENT = 0x00200000;
d138 17
a154 5
    public static final int SHGDN_NORMAL = 0; // is used alone, returns the name of the item itself without extension 
    public static final int SHGDN_INFOLDER = 1; // name relative to the parent folder, use this flag in combinations with SHGDN_FORPARSING and SHGDN_FOREDITING.
    public static final int SHGDN_INCLUDE_NONFILESYS = 0x2000; // The name is used for in-place editing when the user renames the item.
    public static final int SHGDN_FORADDRESSBAR = 0x4000; // The name is displayed in an address bar combo box.
    public static final int SHGDN_FORPARSING = 0x8000; // return a parsable display name relative to desktop
d156 12
a167 1
    static class FolderDisposer implements  sun.java2d.DisposerRecord {
d229 1
a229 1
    Win32ShellFolder2(int csidl) throws IOException {
d286 4
a289 4
        super (parent, (path != null) ? path : "ShellFolder: ");
        this .disposer.pIShellFolder = pIShellFolder;
        this .disposer.relativePIDL = relativePIDL;
        sun.java2d.Disposer.addRecord(this , disposer);
d502 1
a502 1
        if (o == null || !(o instanceof  Win32ShellFolder2)) {
d504 2
a505 2
            if (!(o instanceof  File)) {
                return super .equals(o);
d510 2
a511 1
        if ((parent == null && rhs.parent != null) || (parent != null && rhs.parent == null)) {
d517 2
a518 1
            return (pathsEqual(getPath(), rhs.getPath()) && (parent == rhs.parent || parent.equals(rhs.parent)));
d522 5
a526 1
            return pidlsEqual(getParentIShellFolder(), disposer.relativePIDL, rhs.disposer.relativePIDL);
d533 7
a539 2
    private static boolean pidlsEqual(cli.System.Object pIShellFolder, cli.System.IntPtr pidl1, cli.System.IntPtr pidl2) {
        return (compareIDs(pIShellFolder, pidl1, pidl2) == 0);
d545 2
d551 5
a555 1
        return hasAttribute(ATTRIB_FILESYSTEM);
d581 2
a582 2
        if (parentIShellFolder == Win32ShellFolderManager2.getNetwork().getIShellFolder()
                && getAttributes0(parentIShellFolder, relativePIDL, linkedFolder) == linkedFolder) {
d595 1
a595 2
    static native String getFileSystemPath(int csidl)
            throws IOException;
d615 1
a615 1
            if ((hasAttribute(ATTRIB_HASSUBFOLDER) || hasAttribute(ATTRIB_FOLDER)) && (!hasAttribute(ATTRIB_BROWSABLE) )) {
d688 4
a691 9
    public File[] listFiles(boolean includeHiddenFiles) {
        if (!isDirectory()) {
            return null;
        }
        // Links to directories are not directories and cannot be parents.
        // This does not apply to folders in My Network Places (NetHood)
        // because they are both links and real directories!
        if (isLink() && !hasAttribute(ATTRIB_FOLDER)) {
            return new File[0];
d694 15
a708 2
        Win32ShellFolder2 desktop = Win32ShellFolderManager2.getDesktop();
        Win32ShellFolder2 personal = Win32ShellFolderManager2.getPersonal();
d710 32
a741 24
        // If we are a directory, we have a parent and (at least) a
        // relative PIDL. We must first ensure we are bound to the
        // parent so we have an IShellFolder to query.
        cli.System.Object pIShellFolder = getIShellFolder();
        // Now we can enumerate the objects in this folder.
        ArrayList list = new ArrayList();
        cli.System.Object pEnumObjects = getEnumObjects(pIShellFolder, includeHiddenFiles);
        if (pEnumObjects != null) {
        	cli.System.IntPtr childPIDL = null;
            int testedAttrs = ATTRIB_FILESYSTEM | ATTRIB_FILESYSANCESTOR;
            do {
                if (Thread.currentThread().isInterrupted()) {
                    return new File[0];
                }
                childPIDL = getNextChild(pEnumObjects);
                boolean releasePIDL = true;
                if ( childPIDL != null && !cli.System.IntPtr.Zero.Equals( childPIDL ) && (getAttributes0(pIShellFolder, childPIDL, testedAttrs) & testedAttrs) != 0) {
                    Win32ShellFolder2 childFolder = null;
                    if (this .equals(desktop) && personal != null
                            && pidlsEqual(pIShellFolder, childPIDL, personal.disposer.relativePIDL) ) {
                        childFolder = personal;
                    } else {
                        childFolder = new Win32ShellFolder2(this , childPIDL);
                        releasePIDL = false;
d743 3
a745 1
                    list.add(childFolder);
d747 3
a749 5
                if (releasePIDL) {
                    releasePIDL(childPIDL);
                }
            } while (childPIDL != null && !childPIDL.Equals( cli.System.IntPtr.Zero ));
            releaseEnumObjects(pEnumObjects);
a750 1
        return (ShellFolder[]) list.toArray(new ShellFolder[list.size()]);
d753 1
d783 2
d789 5
a793 1
        return hasAttribute(ATTRIB_LINK);
d816 1
a816 1
    public ShellFolder getLinkLocation() {
d821 6
a826 4
    private ShellFolder getLinkLocation(boolean resolve) {
        if (!isLink()) {
            return null;
        }
d828 15
a842 8
        ShellFolder location = null;
        cli.System.IntPtr linkLocationPIDL = getLinkLocation( getAbsolutePath(), resolve);
        if (linkLocationPIDL != null && !cli.System.IntPtr.Zero.Equals( linkLocationPIDL ) ) {
            try {
                location = Win32ShellFolderManager2.createShellFolderFromRelativePIDL( getDesktop(), linkLocationPIDL );
            } catch (InternalError e) {
                // Could be a link to a non-bindable object, such as a network connection
                // TODO: getIShellFolder() should throw FileNotFoundException instead
d844 1
a844 2
        }
        return location;
d932 2
a933 1
    private static native cli.System.IntPtr extractIcon(cli.System.Object parentIShellFolder, cli.System.IntPtr relativePIDL, boolean getLargeIcon);
d948 2
a949 26
    static int[] fileChooserBitmapBits = null;
    static Image[] fileChooserIcons = null;

    static Image getFileChooserIcon(int idx){
        if(fileChooserIcons == null){
            fileChooserIcons = new Image[47];

            try{
                Bitmap bitmap = getFileChooserBitmap();
                if (bitmap == null) {
                    return null;
                }
                
                for(int i = 0; i < fileChooserIcons.length; i++){
                    cli.System.Drawing.Rectangle rect = new cli.System.Drawing.Rectangle(16 * i, 0, 16, 16);
                    Bitmap icon = bitmap.Clone(rect, bitmap.get_PixelFormat());
                    fileChooserIcons[i] = new BufferedImage(icon);
                }
            }catch(Throwable ex){
                ex.printStackTrace();
            }
        }
        return fileChooserIcons[idx];
    }
    
    private static native Bitmap getFileChooserBitmap();
d970 1
d1024 2
a1025 2
    static Image getShell32Icon(int iconID) {
        Bitmap bitmap = getShell32IconResourceAsBitmap(iconID);
d1032 1
a1032 1
    private static native Bitmap getShell32IconResourceAsBitmap(int iconID);
d1036 1
a1036 1
     * <code>new&nbsp;Win32ShellFolder2Orig(getParentFile(), this.{@@link java.io.File#getCanonicalPath}())</code>.
d1041 1
a1041 1
        return this ;
d1048 1
a1048 1
        return isPersonal || !isFileSystem() || (this  == getDesktop());
d1057 1
a1057 1
        if (!(file2 instanceof  Win32ShellFolder2)) {
d1059 1
a1059 1
                return super .compareTo(file2);
d1064 1
a1064 2
        return Win32ShellFolderManager2.compareShellFolders(this ,
                (Win32ShellFolder2) file2);
d1106 1
a1106 1
    private class ColumnComparator implements  Comparator {
d1110 1
a1110 1
            this .columnIdx = columnIdx;
@


1.9
log
@Added .NET 4 security attributes.
@
text
@d2 3
a4 26
  Copyright (C) 2009 Volker Berlin (i-net software)
  Copyright (C) 2010 Karsten Heinrich (i-net software)

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
 */

/*
 * Copyright 2003-2006 Sun Microsystems, Inc.  All Rights Reserved.
d9 1
a9 1
 * published by the Free Software Foundation.  Sun designates this
d11 1
a11 1
 * by Sun in the LICENSE file that accompanied this code.
d23 3
a25 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.8
log
@Activate the new Shell Folder API for a better support of virtual folder like Desktop, Computer, etc
@
text
@d186 1
d232 1
d258 1
d288 1
d299 1
d334 1
d389 1
d397 1
d408 1
d413 1
d417 2
a418 1
    private static native void releaseIShellFolder( cli.System.Object iShellFolder );
d423 1
d468 1
d504 1
d530 1
d535 1
d548 1
d561 1
d565 1
d655 1
d667 1
d675 1
d731 1
d786 1
d828 1
d834 1
d843 1
d849 1
d883 1
d889 1
d895 1
d902 1
d938 1
d954 1
@


1.7
log
@Fix listFiles() for MyComputer and isFileSystemRoot()
@
text
@d58 5
a62 1
import java.io.ObjectStreamException;
d64 3
a66 1
import cli.System.Environment.SpecialFolder;
d68 3
a70 4
import cli.System.Drawing.Imaging.BitmapData;
import cli.System.Drawing.Imaging.ImageLockMode;
import cli.System.Drawing.Imaging.PixelFormat;
import cli.System.Runtime.InteropServices.Marshal;
d73 29
d103 2
a104 2
 */
public class Win32ShellFolder2 extends ShellFolder{
d106 1
a106 1
    private String folderType;
d109 1
a109 2
    public static final int DESKTOP = cli.System.Environment.SpecialFolder.Desktop;

d111 1
a111 3

    public static final int PROGRAMS = cli.System.Environment.SpecialFolder.Programs;

a112 1

d114 5
a118 11

    public static final int PERSONAL = cli.System.Environment.SpecialFolder.Personal;

    public static final int FAVORITES = cli.System.Environment.SpecialFolder.Favorites;

    public static final int STARTUP = cli.System.Environment.SpecialFolder.Startup;

    public static final int RECENT = cli.System.Environment.SpecialFolder.Recent;

    public static final int SENDTO = cli.System.Environment.SpecialFolder.SendTo;

d120 3
a122 7

    public static final int STARTMENU = cli.System.Environment.SpecialFolder.StartMenu;

    public static final int DESKTOPDIRECTORY = cli.System.Environment.SpecialFolder.DesktopDirectory;

    public static final int DRIVES = cli.System.Environment.SpecialFolder.MyComputer;

a123 1

a124 1

d126 1
a126 3

    public static final int TEMPLATES = cli.System.Environment.SpecialFolder.Templates;

a127 1

a128 1

a129 1

d131 1
a131 3

    public static final int APPDATA = cli.System.Environment.SpecialFolder.ApplicationData;

a132 1

a133 1

a134 1

d136 3
a138 6

    public static final int INTERNET_CACHE = cli.System.Environment.SpecialFolder.InternetCache;

    public static final int COOKIES = cli.System.Environment.SpecialFolder.Cookies;

    public static final int HISTORY = cli.System.Environment.SpecialFolder.History;
a141 1

a142 1

a143 1

a144 1

a145 1

a146 1

a147 1

a148 1

a149 1

a150 1

a151 1

a152 1

a153 1

a154 1

a155 1

a156 1

a157 1

a158 1

a159 1

a160 1

a161 1

d165 36
a200 1
    public static final int SHGDN_NORMAL = 0;
d202 1
a202 1
    public static final int SHGDN_INFOLDER = 1;
d204 3
a206 1
    public static final int SHGDN_INCLUDE_NONFILESYS = 0x2000;
d208 3
a210 1
    public static final int SHGDN_FORADDRESSBAR = 0x4000;
d212 9
a220 1
    public static final int SHGDN_FORPARSING = 0x8000;
d222 1
a222 1
    /**
d227 143
a369 5
    static Image[] fileChooserIcons;
    
    private Image smallIcon = null;
    
    private Image largeIcon = null;
a370 2
	private int folder = -1;
    
d372 1
a372 2
     * @@param folder
     *            value of the Enumeration cli.System.Environment.SpecialFolder
d374 2
a375 3
    Win32ShellFolder2(int folder) throws IOException{
        super(null, getFileSystemPath(folder));
		this.folder = folder;
d378 27
d406 22
a427 2
    Win32ShellFolder2(File file) throws IOException{
        super(getParent(file), file.getCanonicalPath());
d430 15
d446 8
a453 2
    Win32ShellFolder2(String filename){
        super(getParent(new File(filename)), filename);
d456 8
d465 2
a466 2
    Win32ShellFolder2(Win32ShellFolder2 parent, String filename){
        super(parent, filename);
d469 6
d476 31
a506 5
    static String getFileSystemPath(int folder) throws IOException{
        try{
            return cli.System.Environment.GetFolderPath(cli.System.Environment.SpecialFolder.wrap(folder));
        }catch(Throwable ex){
            throw new IOException(ex);
d508 10
d520 1
d522 5
a526 3
    private static Win32ShellFolder2 getParent(File file){
        String parent = file.getParent();
        return parent !=null ? new Win32ShellFolder2(parent) : null;
d529 16
d546 12
a557 6
    @@Override
    public String getDisplayName(){
        // TODO Sun is using IShellFolder::GetDisplayNameOf instead of this hack
        String name = getName();
        if(name.endsWith(".lnk")){
            name = name.substring(0, name.length() - 4);
d559 11
a569 1
        return name;
d572 7
d580 12
a591 4
    @@Override
    public String getExecutableType(){
        if(!isFileSystem()){
            return null;
d593 18
a610 1
        return getExecutableType(getAbsolutePath());
d613 9
d624 5
a628 1
     * Use FindExecutable in shell32
d630 34
a663 1
    private static native String getExecutableType(String path);
d665 2
d668 32
a699 4
    @@Override
    public String getFolderType(){
        if(folderType == null){
            folderType = getFolderType(getAbsolutePath());
d701 1
a701 1
        return folderType;
d704 27
d732 6
a737 1
    private static native String getFolderType(String path);
d739 6
d746 19
a764 3
    @@Override
    public ShellFolder getLinkLocation() throws FileNotFoundException{
        if(!isLink()){
d767 12
a778 1
        return new Win32ShellFolder2(getLinkLocation(getPath()));
d781 13
d795 1
a795 1
    private static native String getLinkLocation(String path);
d797 8
d806 8
a813 3
    @@Override
    public boolean isLink(){
        return hasAttribute(ATTRIB_LINK);
d816 2
d819 8
a826 3
    @@Override
    protected Object writeReplace() throws ObjectStreamException{
        return new File(getPath());
d829 2
d833 1
a833 1
     * @@return Whether this is a file system shell folder
d835 5
a839 3
    @@Override
    public boolean isFileSystem() {
        return hasAttribute(ATTRIB_FILESYSTEM);
d842 24
a865 3
    public boolean hasAttribute(int attribute){
        return (getAttribute(getPath()) & attribute) == attribute;
    }
d867 5
d873 2
a874 1
    private static native int getAttribute(String path);
d899 68
a966 1
    
d980 8
a987 3
    /** Marks this folder as being the My Documents (Personal) folder */
    public void setIsPersonal(){
        isPersonal = true;
d990 1
a990 2

    /**
d993 2
a994 2
    public boolean isSpecial(){
        return isPersonal || !isFileSystem() || (this == Win32ShellFolderManager2.getDesktop());
d998 3
a1000 3
     * @@return An array of shell folders that are children of this shell folder
     *         object. The array will be empty if the folder is empty.  Returns
     *         <code>null</code> if this shell folder does not denote a directory.
d1002 7
a1008 5
    @@Override
    public File[] listFiles(final boolean includeHiddenFiles) {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkRead(getPath());
d1010 29
a1038 2
        if (folder < 0 && !isDirectory()) {
            return null;
d1040 18
a1057 5
        // Links to directories are not directories and cannot be parents.
        // This does not apply to folders in My Network Places (NetHood)
        // because they are both links and real directories!
        if (isLink() && !hasAttribute(ATTRIB_FOLDER)) {
            return new File[0];
d1059 9
a1067 37
        File[] files;
        if( folder == DRIVES ){
        	// 'MyComputer' has no path in .NET, so we can't use a 
        	// normal listFiles in that case.
        	String[] drives = cli.System.IO.Directory.GetLogicalDrives();
        	files = new File[ drives.length ];
        	for( int i = 0; i < drives.length; i++ ){
        		files[i] = new Win32ShellFolder2( this, drives[i] );
        	}
        	return files;
        } else {
        	files = super.listFiles(includeHiddenFiles);
        }
        Win32ShellFolder2[] shellFiles = new Win32ShellFolder2[files.length];
        for(int i = 0; i < files.length; i++){
            File file = files[i];
            shellFiles[i] = new Win32ShellFolder2( this, file.getPath());
        }
        return shellFiles;
    }
    
    /**
     * @@return The icon image used to display this shell folder
     */
    @@Override
    public Image getIcon(final boolean getLargeIcon) {
        Image icon = getLargeIcon ? largeIcon : smallIcon;
        if (icon == null) {
            Bitmap bitmap = getIconBitmap(getPath(), getLargeIcon);
            if (bitmap == null) {
                return null;
            }            
            icon = new BufferedImage(bitmap);
            if (getLargeIcon) {
                largeIcon = icon;
            } else {
                smallIcon = icon;
d1069 1
a1070 1
        return icon;
d1072 1
a1072 4
    
    // Return the icon of a file system shell folder in the form of a Bitmap
    private static native Bitmap getIconBitmap(String absolutePath, boolean getLargeIcon);
}
@


1.6
log
@- Moved security critical code to C# side.
- Cleaned up code.
- Introduced safe handles where possible.
@
text
@d3 1
d60 1
d201 2
d210 1
d382 1
a382 1
        if (!isDirectory()) {
d391 13
a403 2
        
        File[] files = super.listFiles(includeHiddenFiles);
@


1.5
log
@fix the missing alpha chanel on windows shell icons
@
text
@d321 4
a324 5
                int[] data = getFileChooserBitmapHandle();
                Bitmap bitmap = new Bitmap(data.length/16, 16, PixelFormat.wrap(PixelFormat.Format32bppArgb));
                BitmapData bitmapData = bitmap.LockBits(new cli.System.Drawing.Rectangle(0,0,bitmap.get_Width(), bitmap.get_Height()), ImageLockMode.wrap(ImageLockMode.WriteOnly), PixelFormat.wrap(PixelFormat.Format32bppArgb));
                Marshal.Copy(data, 0, bitmapData.get_Scan0(), data.length);
                bitmap.UnlockBits(bitmapData);
d338 1
a338 3
    private static native int[] getFileChooserBitmapHandle();
    
    private static native boolean DeleteObject(cli.System.IntPtr hDc);
d344 2
a345 2
        cli.System.IntPtr hIcon = getIconResource("shell32.dll", iconID, 16, 16);
        if(hIcon.ToInt32() == 0){
a347 2
        Bitmap bitmap = Bitmap.FromHicon(hIcon);
        DeleteObject(hIcon);
d351 1
a351 1
    private static native cli.System.IntPtr getIconResource(String libName, int iconID, int cxDesired, int cyDesired);
d403 2
a404 3
        	int size = getLargeIcon ? 32 : 16;
            cli.System.IntPtr hIcon = getIcon( getPath(), getLargeIcon);
            if(hIcon.ToInt32() == 0){
d406 1
a406 8
            }
            DeleteObject(hIcon);
            int[] iconPixels = getIconBits(hIcon, size);
            Bitmap bitmap = new Bitmap(size, size, PixelFormat.wrap(PixelFormat.Format32bppArgb));
            BitmapData bitmapData = bitmap.LockBits(new cli.System.Drawing.Rectangle(0,0,size, size), ImageLockMode.wrap(ImageLockMode.WriteOnly), PixelFormat.wrap(PixelFormat.Format32bppArgb));
            Marshal.Copy(iconPixels, 0, bitmapData.get_Scan0(), iconPixels.length);
            bitmap.UnlockBits(bitmapData);
            
d417 2
a418 5
    // Return the icon of a file system shell folder in the form of an HICON
    private static native cli.System.IntPtr getIcon(String absolutePath, boolean getLargeIcon);
    
    private static native int[] getIconBits(cli.System.IntPtr hIcon, int iconSize);

@


1.4
log
@implements getIcon() in ShellFolder
@
text
@d60 4
d321 6
a326 3
                cli.System.IntPtr handle = getFileChooserBitmapHandle();
                Bitmap bitmap = Bitmap.FromHbitmap(handle);
                DeleteObject(handle);
d339 1
a339 1
    private static native cli.System.IntPtr getFileChooserBitmapHandle();
d408 1
a412 1
            Bitmap bitmap = Bitmap.FromHicon(hIcon);
d414 6
d432 2
@


1.3
log
@listFiles(boolean) must return instances Win32ShellFolders2
@
text
@d192 4
d393 27
@


1.2
log
@Fix different bugs in ShellFolder
@
text
@d360 29
@


1.1
log
@Win32ShellFolder2 Step 2
@
text
@d93 1
a93 1
    public static final int DESKTOPDIRECTORY = 0x0010;
d95 1
a95 1
    public static final int DRIVES = 0x0011;
d113 1
a113 1
    public static final int APPDATA = 0x001a;
d123 1
a123 1
    public static final int INTERNET_CACHE = 0x0020;
d127 1
a127 1
    public static final int HISTORY = 0x0022;
d190 1
a190 1
    static Image[] fileChooserIcons = new Image[47];
d233 6
a238 1
        return getName();
d308 16
a323 3
    static Image getFileChooserIcon(int i) {
        if (fileChooserIcons[i] != null) {
            return fileChooserIcons[i];
d325 1
a325 1
        return new BufferedImage(Bitmap.FromHbitmap(getFileChooserBitmapHandle()));
d330 2
d337 6
a342 1
        return new BufferedImage(Bitmap.FromHicon(hIcon));
@

