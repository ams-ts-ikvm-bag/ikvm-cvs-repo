head	1.26;
access;
symbols
	v8_0_5449_1:1.24
	v8_0_5449_0:1.24
	v8_0:1.24.0.2
	v7_4_5196_0:1.23
	v7_4:1.23.0.2
	v7_3:1.20.0.6
	v7_2_4630_6:1.20
	v7_2_4630_5:1.20
	v7_2_4630_4:1.20
	v7_2_4630_3:1.20
	v7_2_4630_2:1.20
	v0_46_0_4:1.14
	v7_2_4630_1:1.20
	v7_2:1.20.0.4
	v7_1_4532_2:1.20
	v7_1_4532_1:1.20
	v7_1_4532_0:1.20
	v7_1:1.20.0.2
	v7_0_4335_3:1.19
	v7_0_4335_2:1.19
	v7_0_4335_1:1.19
	v0_46_0_2:1.14
	v7_0_4335_0:1.19
	v7_0:1.19.0.2
	v0_40_0_6:1.4
	v0_40_0_5:1.4
	v0_46_0_1:1.14
	v0_46_0_0:1.14
	v0_46:1.14.0.2
	v0_44_0_6:1.11
	v0_44_0_5:1.11
	v0_44_0_4:1.11
	v0_44_0_3:1.11
	v0_44_0_2:1.11
	v0_42_0_7:1.9
	v0_44_0_1:1.11
	v0_44_0_0:1.11
	v0_44:1.11.0.2
	v0_42_0_6:1.9
	v0_42_0_5:1.9
	v0_42_0_4:1.9
	v0_42_0_3:1.9
	v0_42_0_2:1.9
	v0_42_0_1:1.9
	v0_42_0_0:1.9
	v0_42:1.9.0.2
	v0_40_0_3:1.4
	v0_40_0_2:1.4
	v0_40_0_1:1.4
	v0_40_0_0:1.4
	v0_40:1.4.0.2;
locks; strict;
comment	@# @;


1.26
date	2015.06.30.11.51.04;	author jfrijters;	state dead;
branches;
next	1.25;

1.25
date	2015.06.09.09.28.43;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2014.05.19.12.43.40;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2014.02.07.14.14.12;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2013.08.15.11.35.13;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2013.08.15.10.09.09;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2012.05.23.10.00.03;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.28.13.32.44;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.09.15.11.24;	author smallsql;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.26.17.07.11;	author smallsql;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.26.16.05.19;	author smallsql;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.24.21.14.03;	author smallsql;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.24.16.40.23;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.17.05.21.38;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.27.10.33.40;	author smallsql;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.02.03.54.06;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.14.13.44.27;	author natl;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.22.19.59.24;	author smallsql;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.12.04.10.13;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.08.12.04.59;	author smallsql;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.03.19.17.35;	author smallsql;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.22.16.27.56;	author smallsql;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.04.11.12.51;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.04.09.50.31;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.04.09.21.42;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.04.08.18.38;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Unforked sun/awt/SunToolkit.java.
@
text
@/*
 * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt;

import java.awt.*;
import static java.awt.RenderingHints.*;
import java.awt.dnd.*;
import java.awt.dnd.peer.DragSourceContextPeer;
import java.awt.peer.*;
import java.awt.event.WindowEvent;
import java.awt.event.KeyEvent;
import java.awt.image.*;
import java.awt.TrayIcon;
import java.awt.SystemTray;
import java.awt.event.InputEvent;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import sun.awt.datatransfer.DataTransferer;
import sun.security.util.SecurityConstants;
import sun.util.logging.PlatformLogger;
import sun.misc.SoftCache;
import sun.font.FontDesignMetrics;
import sun.awt.im.InputContext;
import sun.awt.image.*;
import sun.net.util.URLUtil;
import sun.security.action.GetPropertyAction;
import sun.security.action.GetBooleanAction;
import java.lang.reflect.InvocationTargetException;
import java.security.AccessController;

public abstract class SunToolkit extends Toolkit
    implements WindowClosingSupport, WindowClosingListener,
    ComponentFactory, InputMethodSupport, KeyboardFocusManagerPeerProvider {

    // 8014718: logging has been removed from SunToolkit

    /**
     * Special mask for the UngrabEvent events, in addition to the
     * public masks defined in AWTEvent.  Should be used as the mask
     * value for Toolkit.addAWTEventListener.
     */
    public static final int GRAB_EVENT_MASK = 0x80000000;

    /* The key to put()/get() the PostEventQueue into/from the AppContext.
     */
    private static final String POST_EVENT_QUEUE_KEY = "PostEventQueue";

    /**
     * Number of buttons.
     * By default it's taken from the system. If system value does not
     * fit into int type range, use our own MAX_BUTTONS_SUPPORT value.
     */
    protected static int numberOfButtons = 0;


    /* XFree standard mention 24 buttons as maximum:
     * http://www.xfree86.org/current/mouse.4.html
     * We workaround systems supporting more than 24 buttons.
     * Otherwise, we have to use long type values as masks
     * which leads to API change.
     * InputEvent.BUTTON_DOWN_MASK may contain only 21 masks due to
     * the 4-bytes limit for the int type. (CR 6799099)
     * One more bit is reserved for FIRST_HIGH_BIT.
     */
    public final static int MAX_BUTTONS_SUPPORTED = 20;

    /**
     * Creates and initializes EventQueue instance for the specified
     * AppContext.
     * Note that event queue must be created from createNewAppContext()
     * only in order to ensure that EventQueue constructor obtains
     * the correct AppContext.
     * @@param appContext AppContext to associate with the event queue
     */
    private static void initEQ(AppContext appContext) {
        EventQueue eventQueue;

        String eqName = System.getProperty("AWT.EventQueueClass",
                "java.awt.EventQueue");

        try {
            eventQueue = (EventQueue)Class.forName(eqName).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("Failed loading " + eqName + ": " + e);
            eventQueue = new EventQueue();
        }
        appContext.put(AppContext.EVENT_QUEUE_KEY, eventQueue);

        PostEventQueue postEventQueue = new PostEventQueue(eventQueue);
        appContext.put(POST_EVENT_QUEUE_KEY, postEventQueue);
    }

    public SunToolkit() {
    }

    public boolean useBufferPerWindow() {
        return false;
    }

    public abstract WindowPeer createWindow(Window target)
        throws HeadlessException;

    public abstract FramePeer createFrame(Frame target)
        throws HeadlessException;

    public abstract FramePeer createLightweightFrame(LightweightFrame target)
        throws HeadlessException;

    public abstract DialogPeer createDialog(Dialog target)
        throws HeadlessException;

    public abstract ButtonPeer createButton(Button target)
        throws HeadlessException;

    public abstract TextFieldPeer createTextField(TextField target)
        throws HeadlessException;

    public abstract ChoicePeer createChoice(Choice target)
        throws HeadlessException;

    public abstract LabelPeer createLabel(Label target)
        throws HeadlessException;

    public abstract ListPeer createList(java.awt.List target)
        throws HeadlessException;

    public abstract CheckboxPeer createCheckbox(Checkbox target)
        throws HeadlessException;

    public abstract ScrollbarPeer createScrollbar(Scrollbar target)
        throws HeadlessException;

    public abstract ScrollPanePeer createScrollPane(ScrollPane target)
        throws HeadlessException;

    public abstract TextAreaPeer createTextArea(TextArea target)
        throws HeadlessException;

    public abstract FileDialogPeer createFileDialog(FileDialog target)
        throws HeadlessException;

    public abstract MenuBarPeer createMenuBar(MenuBar target)
        throws HeadlessException;

    public abstract MenuPeer createMenu(Menu target)
        throws HeadlessException;

    public abstract PopupMenuPeer createPopupMenu(PopupMenu target)
        throws HeadlessException;

    public abstract MenuItemPeer createMenuItem(MenuItem target)
        throws HeadlessException;

    public abstract CheckboxMenuItemPeer createCheckboxMenuItem(
        CheckboxMenuItem target)
        throws HeadlessException;

    public abstract DragSourceContextPeer createDragSourceContextPeer(
        DragGestureEvent dge)
        throws InvalidDnDOperationException;

    public abstract TrayIconPeer createTrayIcon(TrayIcon target)
        throws HeadlessException, AWTException;

    public abstract SystemTrayPeer createSystemTray(SystemTray target);

    public abstract boolean isTraySupported();

    @@SuppressWarnings("deprecation")
    public abstract FontPeer getFontPeer(String name, int style);

    public abstract RobotPeer createRobot(Robot target, GraphicsDevice screen)
        throws AWTException;

    public abstract KeyboardFocusManagerPeer getKeyboardFocusManagerPeer()
        throws HeadlessException;

    /**
     * The AWT lock is typically only used on Unix platforms to synchronize
     * access to Xlib, OpenGL, etc.  However, these methods are implemented
     * in SunToolkit so that they can be called from shared code (e.g.
     * from the OGL pipeline) or from the X11 pipeline regardless of whether
     * XToolkit or MToolkit is currently in use.  There are native macros
     * (such as AWT_LOCK) defined in awt.h, so if the implementation of these
     * methods is changed, make sure it is compatible with the native macros.
     *
     * Note: The following methods (awtLock(), awtUnlock(), etc) should be
     * used in place of:
     *     synchronized (getAWTLock()) {
     *         ...
     *     }
     *
     * By factoring these methods out specially, we are able to change the
     * implementation of these methods (e.g. use more advanced locking
     * mechanisms) without impacting calling code.
     *
     * Sample usage:
     *     private void doStuffWithXlib() {
     *         assert !SunToolkit.isAWTLockHeldByCurrentThread();
     *         SunToolkit.awtLock();
     *         try {
     *             ...
     *             XlibWrapper.XDoStuff();
     *         } finally {
     *             SunToolkit.awtUnlock();
     *         }
     *     }
     */

    private static final ReentrantLock AWT_LOCK = new ReentrantLock();
    private static final Condition AWT_LOCK_COND = AWT_LOCK.newCondition();

    public static final void awtLock() {
        AWT_LOCK.lock();
    }

    public static final boolean awtTryLock() {
        return AWT_LOCK.tryLock();
    }

    public static final void awtUnlock() {
        AWT_LOCK.unlock();
    }

    public static final void awtLockWait()
        throws InterruptedException
    {
        AWT_LOCK_COND.await();
    }

    public static final void awtLockWait(long timeout)
        throws InterruptedException
    {
        AWT_LOCK_COND.await(timeout, TimeUnit.MILLISECONDS);
    }

    public static final void awtLockNotify() {
        AWT_LOCK_COND.signal();
    }

    public static final void awtLockNotifyAll() {
        AWT_LOCK_COND.signalAll();
    }

    public static final boolean isAWTLockHeldByCurrentThread() {
        return AWT_LOCK.isHeldByCurrentThread();
    }

    /*
     * Create a new AppContext, along with its EventQueue, for a
     * new ThreadGroup.  Browser code, for example, would use this
     * method to create an AppContext & EventQueue for an Applet.
     */
    public static AppContext createNewAppContext() {
        ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();
        return createNewAppContext(threadGroup);
    }

    static final AppContext createNewAppContext(ThreadGroup threadGroup) {
        // Create appContext before initialization of EventQueue, so all
        // the calls to AppContext.getAppContext() from EventQueue ctor
        // return correct values
        AppContext appContext = new AppContext(threadGroup);
        initEQ(appContext);

        return appContext;
    }

    static void wakeupEventQueue(EventQueue q, boolean isShutdown){
        AWTAccessor.getEventQueueAccessor().wakeup(q, isShutdown);
    }

    /*
     * Fetch the peer associated with the given target (as specified
     * in the peer creation method).  This can be used to determine
     * things like what the parent peer is.  If the target is null
     * or the target can't be found (either because the a peer was
     * never created for it or the peer was disposed), a null will
     * be returned.
     */
    protected static Object targetToPeer(Object target) {
        if (target != null && !GraphicsEnvironment.isHeadless()) {
            return AWTAutoShutdown.getInstance().getPeer(target);
        }
        return null;
    }

    protected static void targetCreatedPeer(Object target, Object peer) {
        if (target != null && peer != null &&
            !GraphicsEnvironment.isHeadless())
        {
            AWTAutoShutdown.getInstance().registerPeer(target, peer);
        }
    }

    protected static void targetDisposedPeer(Object target, Object peer) {
        if (target != null && peer != null &&
            !GraphicsEnvironment.isHeadless())
        {
            AWTAutoShutdown.getInstance().unregisterPeer(target, peer);
        }
    }

    // Maps from non-Component/MenuComponent to AppContext.
    // WeakHashMap<Component,AppContext>
    private static final Map<Object, AppContext> appContextMap =
        Collections.synchronizedMap(new WeakHashMap<Object, AppContext>());

    /**
     * Sets the appContext field of target. If target is not a Component or
     * MenuComponent, this returns false.
     */
    private static boolean setAppContext(Object target,
                                         AppContext context) {
        if (target instanceof Component) {
            AWTAccessor.getComponentAccessor().
                setAppContext((Component)target, context);
        } else if (target instanceof MenuComponent) {
            AWTAccessor.getMenuComponentAccessor().
                setAppContext((MenuComponent)target, context);
        } else {
            return false;
        }
        return true;
    }

    /**
     * Returns the appContext field for target. If target is not a
     * Component or MenuComponent this returns null.
     */
    private static AppContext getAppContext(Object target) {
        if (target instanceof Component) {
            return AWTAccessor.getComponentAccessor().
                       getAppContext((Component)target);
        } else if (target instanceof MenuComponent) {
            return AWTAccessor.getMenuComponentAccessor().
                       getAppContext((MenuComponent)target);
        } else {
            return null;
        }
    }

    /*
     * Fetch the AppContext associated with the given target.
     * This can be used to determine things like which EventQueue
     * to use for posting events to a Component.  If the target is
     * null or the target can't be found, a null with be returned.
     */
    public static AppContext targetToAppContext(Object target) {
        if (target == null) {
            return null;
        }
        AppContext context = getAppContext(target);
        if (context == null) {
            // target is not a Component/MenuComponent, try the
            // appContextMap.
            context = appContextMap.get(target);
        }
        return context;
    }

     /**
      * Sets the synchronous status of focus requests on lightweight
      * components in the specified window to the specified value.
      * If the boolean parameter is <code>true</code> then the focus
      * requests on lightweight components will be performed
      * synchronously, if it is <code>false</code>, then asynchronously.
      * By default, all windows have their lightweight request status
      * set to asynchronous.
      * <p>
      * The application can only set the status of lightweight focus
      * requests to synchronous for any of its windows if it doesn't
      * perform focus transfers between different heavyweight containers.
      * In this case the observable focus behaviour is the same as with
      * asynchronous status.
      * <p>
      * If the application performs focus transfer between different
      * heavyweight containers and sets the lightweight focus request
      * status to synchronous for any of its windows, then further focus
      * behaviour is unspecified.
      * <p>
      * @@param    w window for which the lightweight focus request status
      *             should be set
      * @@param    status the value of lightweight focus request status
      */

    public static void setLWRequestStatus(Window changed,boolean status){
        AWTAccessor.getWindowAccessor().setLWRequestStatus(changed, status);
    };

    public static void checkAndSetPolicy(Container cont) {
        FocusTraversalPolicy defaultPolicy = KeyboardFocusManager.
            getCurrentKeyboardFocusManager().
                getDefaultFocusTraversalPolicy();

        cont.setFocusTraversalPolicy(defaultPolicy);
    }

    private static FocusTraversalPolicy createLayoutPolicy() {
        FocusTraversalPolicy policy = null;
        try {
            Class<?> layoutPolicyClass =
                Class.forName("javax.swing.LayoutFocusTraversalPolicy");
            policy = (FocusTraversalPolicy)layoutPolicyClass.newInstance();
        }
        catch (ClassNotFoundException e) {
            assert false;
        }
        catch (InstantiationException e) {
            assert false;
        }
        catch (IllegalAccessException e) {
            assert false;
        }

        return policy;
    }

    /*
     * Insert a mapping from target to AppContext, for later retrieval
     * via targetToAppContext() above.
     */
    public static void insertTargetMapping(Object target, AppContext appContext) {
        if (!setAppContext(target, appContext)) {
            // Target is not a Component/MenuComponent, use the private Map
            // instead.
            appContextMap.put(target, appContext);
        }
    }

    /*
     * Post an AWTEvent to the Java EventQueue, using the PostEventQueue
     * to avoid possibly calling client code (EventQueueSubclass.postEvent())
     * on the toolkit (AWT-Windows/AWT-Motif) thread.  This function should
     * not be called under another lock since it locks the EventQueue.
     * See bugids 4632918, 4526597.
     */
    public static void postEvent(AppContext appContext, AWTEvent event) {
        if (event == null) {
            throw new NullPointerException();
        }

        AWTAccessor.SequencedEventAccessor sea = AWTAccessor.getSequencedEventAccessor();
        if (sea != null && sea.isSequencedEvent(event)) {
            AWTEvent nested = sea.getNested(event);
            if (nested.getID() == WindowEvent.WINDOW_LOST_FOCUS &&
                nested instanceof TimedWindowEvent)
            {
                TimedWindowEvent twe = (TimedWindowEvent)nested;
                ((SunToolkit)Toolkit.getDefaultToolkit()).
                    setWindowDeactivationTime((Window)twe.getSource(), twe.getWhen());
            }
        }

        // All events posted via this method are system-generated.
        // Placing the following call here reduces considerably the
        // number of places throughout the toolkit that would
        // otherwise have to be modified to precisely identify
        // system-generated events.
        setSystemGenerated(event);
        AppContext eventContext = targetToAppContext(event.getSource());
        if (eventContext != null && !eventContext.equals(appContext)) {
            throw new RuntimeException("Event posted on wrong app context : " + event);
        }
        PostEventQueue postEventQueue =
            (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);
        if (postEventQueue != null) {
            postEventQueue.postEvent(event);
        }
    }

    /*
     * Post AWTEvent of high priority.
     */
    public static void postPriorityEvent(final AWTEvent e) {
        PeerEvent pe = new PeerEvent(Toolkit.getDefaultToolkit(), new Runnable() {
                public void run() {
                    AWTAccessor.getAWTEventAccessor().setPosted(e);
                    ((Component)e.getSource()).dispatchEvent(e);
                }
            }, PeerEvent.ULTIMATE_PRIORITY_EVENT);
        postEvent(targetToAppContext(e.getSource()), pe);
    }

    /*
     * Flush any pending events which haven't been posted to the AWT
     * EventQueue yet.
     */
    public static void flushPendingEvents()  {
        AppContext appContext = AppContext.getAppContext();
        flushPendingEvents(appContext);
    }

    /*
     * Flush the PostEventQueue for the right AppContext.
     * The default flushPendingEvents only flushes the thread-local context,
     * which is not always correct, c.f. 3746956
     */
    public static void flushPendingEvents(AppContext appContext) {
        PostEventQueue postEventQueue =
                (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);
        if (postEventQueue != null) {
            postEventQueue.flush();
        }
    }

    /*
     * Execute a chunk of code on the Java event handler thread for the
     * given target.  Does not wait for the execution to occur before
     * returning to the caller.
     */
    public static void executeOnEventHandlerThread(Object target,
                                                   Runnable runnable) {
        executeOnEventHandlerThread(new PeerEvent(target, runnable, PeerEvent.PRIORITY_EVENT));
    }

    /*
     * Fixed 5064013: the InvocationEvent time should be equals
     * the time of the ActionEvent
     */
    @@SuppressWarnings("serial")
    public static void executeOnEventHandlerThread(Object target,
                                                   Runnable runnable,
                                                   final long when) {
        executeOnEventHandlerThread(
            new PeerEvent(target, runnable, PeerEvent.PRIORITY_EVENT) {
                public long getWhen() {
                    return when;
                }
            });
    }

    /*
     * Execute a chunk of code on the Java event handler thread for the
     * given target.  Does not wait for the execution to occur before
     * returning to the caller.
     */
    public static void executeOnEventHandlerThread(PeerEvent peerEvent) {
        postEvent(targetToAppContext(peerEvent.getSource()), peerEvent);
    }

    /*
     * Execute a chunk of code on the Java event handler thread. The
     * method takes into account provided AppContext and sets
     * <code>SunToolkit.getDefaultToolkit()</code> as a target of the
     * event. See 6451487 for detailes.
     * Does not wait for the execution to occur before returning to
     * the caller.
     */
     public static void invokeLaterOnAppContext(
        AppContext appContext, Runnable dispatcher)
     {
        postEvent(appContext,
            new PeerEvent(Toolkit.getDefaultToolkit(), dispatcher,
                PeerEvent.PRIORITY_EVENT));
     }

    /*
     * Execute a chunk of code on the Java event handler thread for the
     * given target.  Waits for the execution to occur before returning
     * to the caller.
     */
    public static void executeOnEDTAndWait(Object target, Runnable runnable)
        throws InterruptedException, InvocationTargetException
    {
        if (EventQueue.isDispatchThread()) {
            throw new Error("Cannot call executeOnEDTAndWait from any event dispatcher thread");
        }

        class AWTInvocationLock {}
        Object lock = new AWTInvocationLock();

        PeerEvent event = new PeerEvent(target, runnable, lock, true, PeerEvent.PRIORITY_EVENT);

        synchronized (lock) {
            executeOnEventHandlerThread(event);
            while(!event.isDispatched()) {
                lock.wait();
            }
        }

        Throwable eventThrowable = event.getThrowable();
        if (eventThrowable != null) {
            throw new InvocationTargetException(eventThrowable);
        }
    }

    /*
     * Returns true if the calling thread is the event dispatch thread
     * contained within AppContext which associated with the given target.
     * Use this call to ensure that a given task is being executed
     * (or not being) on the event dispatch thread for the given target.
     */
    public static boolean isDispatchThreadForAppContext(Object target) {
        AppContext appContext = targetToAppContext(target);
        EventQueue eq = (EventQueue)appContext.get(AppContext.EVENT_QUEUE_KEY);

        AWTAccessor.EventQueueAccessor accessor = AWTAccessor.getEventQueueAccessor();
        return accessor.isDispatchThreadImpl(eq);
    }

    public Dimension getScreenSize() {
        return new Dimension(getScreenWidth(), getScreenHeight());
    }
    protected abstract int getScreenWidth();
    protected abstract int getScreenHeight();

    @@SuppressWarnings("deprecation")
    public FontMetrics getFontMetrics(Font font) {
        return FontDesignMetrics.getMetrics(font);
    }

    @@SuppressWarnings("deprecation")
    public String[] getFontList() {
        String[] hardwiredFontList = {
            Font.DIALOG, Font.SANS_SERIF, Font.SERIF, Font.MONOSPACED,
            Font.DIALOG_INPUT

            // -- Obsolete font names from 1.0.2.  It was decided that
            // -- getFontList should not return these old names:
            //    "Helvetica", "TimesRoman", "Courier", "ZapfDingbats"
        };
        return hardwiredFontList;
    }

    public PanelPeer createPanel(Panel target) {
        return (PanelPeer)createComponent(target);
    }

    public CanvasPeer createCanvas(Canvas target) {
        return (CanvasPeer)createComponent(target);
    }

    /**
     * Disables erasing of background on the canvas before painting if
     * this is supported by the current toolkit. It is recommended to
     * call this method early, before the Canvas becomes displayable,
     * because some Toolkit implementations do not support changing
     * this property once the Canvas becomes displayable.
     */
    public void disableBackgroundErase(Canvas canvas) {
        disableBackgroundEraseImpl(canvas);
    }

    /**
     * Disables the native erasing of the background on the given
     * component before painting if this is supported by the current
     * toolkit. This only has an effect for certain components such as
     * Canvas, Panel and Window. It is recommended to call this method
     * early, before the Component becomes displayable, because some
     * Toolkit implementations do not support changing this property
     * once the Component becomes displayable.
     */
    public void disableBackgroundErase(Component component) {
        disableBackgroundEraseImpl(component);
    }

    private void disableBackgroundEraseImpl(Component component) {
        AWTAccessor.getComponentAccessor().setBackgroundEraseDisabled(component, true);
    }

    /**
     * Returns the value of "sun.awt.noerasebackground" property. Default
     * value is {@@code false}.
     */
    public static boolean getSunAwtNoerasebackground() {
        return AccessController.doPrivileged(new GetBooleanAction("sun.awt.noerasebackground"));
    }

    /**
     * Returns the value of "sun.awt.erasebackgroundonresize" property. Default
     * value is {@@code false}.
     */
    public static boolean getSunAwtErasebackgroundonresize() {
        return AccessController.doPrivileged(new GetBooleanAction("sun.awt.erasebackgroundonresize"));
    }


    static final SoftCache imgCache = new SoftCache();

    static Image getImageFromHash(Toolkit tk, URL url) {
        checkPermissions(url);
        synchronized (imgCache) {
            Image img = (Image)imgCache.get(url);
            if (img == null) {
                try {
                    img = tk.createImage(new URLImageSource(url));
                    imgCache.put(url, img);
                } catch (Exception e) {
                }
            }
            return img;
        }
    }

    static Image getImageFromHash(Toolkit tk,
                                               String filename) {
        checkPermissions(filename);
        synchronized (imgCache) {
            Image img = (Image)imgCache.get(filename);
            if (img == null) {
                try {
                    img = tk.createImage(new FileImageSource(filename));
                    imgCache.put(filename, img);
                } catch (Exception e) {
                }
            }
            return img;
        }
    }

    public Image getImage(String filename) {
        return getImageFromHash(this, filename);
    }

    public Image getImage(URL url) {
        return getImageFromHash(this, url);
    }

    protected Image getImageWithResolutionVariant(String fileName,
            String resolutionVariantName) {
        synchronized (imgCache) {
            Image image = getImageFromHash(this, fileName);
            if (image instanceof MultiResolutionImage) {
                return image;
            }
            Image resolutionVariant = getImageFromHash(this, resolutionVariantName);
            image = createImageWithResolutionVariant(image, resolutionVariant);
            imgCache.put(fileName, image);
            return image;
        }
    }

    protected Image getImageWithResolutionVariant(URL url,
            URL resolutionVariantURL) {
        synchronized (imgCache) {
            Image image = getImageFromHash(this, url);
            if (image instanceof MultiResolutionImage) {
                return image;
            }
            Image resolutionVariant = getImageFromHash(this, resolutionVariantURL);
            image = createImageWithResolutionVariant(image, resolutionVariant);
            imgCache.put(url, image);
            return image;
        }
    }


    public Image createImage(String filename) {
        checkPermissions(filename);
        return createImage(new FileImageSource(filename));
    }

    public Image createImage(URL url) {
        checkPermissions(url);
        return createImage(new URLImageSource(url));
    }

    public Image createImage(byte[] data, int offset, int length) {
        return createImage(new ByteArrayImageSource(data, offset, length));
    }

    public Image createImage(ImageProducer producer) {
        return new ToolkitImage(producer);
    }

    public static Image createImageWithResolutionVariant(Image image,
            Image resolutionVariant) {
        return new MultiResolutionToolkitImage(image, resolutionVariant);
    }

    public int checkImage(Image img, int w, int h, ImageObserver o) {
        if (!(img instanceof ToolkitImage)) {
            return ImageObserver.ALLBITS;
        }

        ToolkitImage tkimg = (ToolkitImage)img;
        int repbits;
        if (w == 0 || h == 0) {
            repbits = ImageObserver.ALLBITS;
        } else {
            repbits = tkimg.getImageRep().check(o);
        }
        return (tkimg.check(o) | repbits) & checkResolutionVariant(img, w, h, o);
    }

    public boolean prepareImage(Image img, int w, int h, ImageObserver o) {
        if (w == 0 || h == 0) {
            return true;
        }

        // Must be a ToolkitImage
        if (!(img instanceof ToolkitImage)) {
            return true;
        }

        ToolkitImage tkimg = (ToolkitImage)img;
        if (tkimg.hasError()) {
            if (o != null) {
                o.imageUpdate(img, ImageObserver.ERROR|ImageObserver.ABORT,
                              -1, -1, -1, -1);
            }
            return false;
        }
        ImageRepresentation ir = tkimg.getImageRep();
        return ir.prepare(o) & prepareResolutionVariant(img, w, h, o);
    }

    private int checkResolutionVariant(Image img, int w, int h, ImageObserver o) {
        ToolkitImage rvImage = getResolutionVariant(img);
        int rvw = getRVSize(w);
        int rvh = getRVSize(h);
        // Ignore the resolution variant in case of error
        return (rvImage == null || rvImage.hasError()) ? 0xFFFF :
                checkImage(rvImage, rvw, rvh, MultiResolutionToolkitImage.
                                getResolutionVariantObserver(
                                        img, o, w, h, rvw, rvh, true));
    }

    private boolean prepareResolutionVariant(Image img, int w, int h,
            ImageObserver o) {

        ToolkitImage rvImage = getResolutionVariant(img);
        int rvw = getRVSize(w);
        int rvh = getRVSize(h);
        // Ignore the resolution variant in case of error
        return rvImage == null || rvImage.hasError() || prepareImage(
                rvImage, rvw, rvh,
                MultiResolutionToolkitImage.getResolutionVariantObserver(
                        img, o, w, h, rvw, rvh, true));
    }

    private static int getRVSize(int size){
        return size == -1 ? -1 : 2 * size;
    }

    private static ToolkitImage getResolutionVariant(Image image) {
        if (image instanceof MultiResolutionToolkitImage) {
            Image resolutionVariant = ((MultiResolutionToolkitImage) image).
                    getResolutionVariant();
            if (resolutionVariant instanceof ToolkitImage) {
                return (ToolkitImage) resolutionVariant;
            }
        }
        return null;
    }

    protected static boolean imageCached(Object key) {
        return imgCache.containsKey(key);
    }

    protected static boolean imageExists(String filename) {
        checkPermissions(filename);
        return filename != null && new File(filename).exists();
    }

    @@SuppressWarnings("try")
    protected static boolean imageExists(URL url) {
        checkPermissions(url);
        if (url != null) {
            try (InputStream is = url.openStream()) {
                return true;
            }catch(IOException e){
                return false;
            }
        }
        return false;
    }

    private static void checkPermissions(String filename) {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkRead(filename);
        }
    }

    private static void checkPermissions(URL url) {
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            try {
                java.security.Permission perm =
                    URLUtil.getConnectPermission(url);
                if (perm != null) {
                    try {
                        sm.checkPermission(perm);
                    } catch (SecurityException se) {
                        // fallback to checkRead/checkConnect for pre 1.2
                        // security managers
                        if ((perm instanceof java.io.FilePermission) &&
                            perm.getActions().indexOf("read") != -1) {
                            sm.checkRead(perm.getName());
                        } else if ((perm instanceof
                            java.net.SocketPermission) &&
                            perm.getActions().indexOf("connect") != -1) {
                            sm.checkConnect(url.getHost(), url.getPort());
                        } else {
                            throw se;
                        }
                    }
                }
            } catch (java.io.IOException ioe) {
                    sm.checkConnect(url.getHost(), url.getPort());
            }
        }
    }

    /**
     * Scans {@@code imageList} for best-looking image of specified dimensions.
     * Image can be scaled and/or padded with transparency.
     */
    public static BufferedImage getScaledIconImage(java.util.List<Image> imageList, int width, int height) {
        if (width == 0 || height == 0) {
            return null;
        }
        Image bestImage = null;
        int bestWidth = 0;
        int bestHeight = 0;
        double bestSimilarity = 3; //Impossibly high value
        double bestScaleFactor = 0;
        for (Iterator<Image> i = imageList.iterator();i.hasNext();) {
            //Iterate imageList looking for best matching image.
            //'Similarity' measure is defined as good scale factor and small insets.
            //best possible similarity is 0 (no scale, no insets).
            //It's found while the experiments that good-looking result is achieved
            //with scale factors x1, x3/4, x2/3, xN, x1/N.
            Image im = i.next();
            if (im == null) {
                continue;
            }
            if (im instanceof ToolkitImage) {
                ImageRepresentation ir = ((ToolkitImage)im).getImageRep();
                ir.reconstruct(ImageObserver.ALLBITS);
            }
            int iw;
            int ih;
            try {
                iw = im.getWidth(null);
                ih = im.getHeight(null);
            } catch (Exception e){
                continue;
            }
            if (iw > 0 && ih > 0) {
                //Calc scale factor
                double scaleFactor = Math.min((double)width / (double)iw,
                                              (double)height / (double)ih);
                //Calculate scaled image dimensions
                //adjusting scale factor to nearest "good" value
                int adjw = 0;
                int adjh = 0;
                double scaleMeasure = 1; //0 - best (no) scale, 1 - impossibly bad
                if (scaleFactor >= 2) {
                    //Need to enlarge image more than twice
                    //Round down scale factor to multiply by integer value
                    scaleFactor = Math.floor(scaleFactor);
                    adjw = iw * (int)scaleFactor;
                    adjh = ih * (int)scaleFactor;
                    scaleMeasure = 1.0 - 0.5 / scaleFactor;
                } else if (scaleFactor >= 1) {
                    //Don't scale
                    scaleFactor = 1.0;
                    adjw = iw;
                    adjh = ih;
                    scaleMeasure = 0;
                } else if (scaleFactor >= 0.75) {
                    //Multiply by 3/4
                    scaleFactor = 0.75;
                    adjw = iw * 3 / 4;
                    adjh = ih * 3 / 4;
                    scaleMeasure = 0.3;
                } else if (scaleFactor >= 0.6666) {
                    //Multiply by 2/3
                    scaleFactor = 0.6666;
                    adjw = iw * 2 / 3;
                    adjh = ih * 2 / 3;
                    scaleMeasure = 0.33;
                } else {
                    //Multiply size by 1/scaleDivider
                    //where scaleDivider is minimum possible integer
                    //larger than 1/scaleFactor
                    double scaleDivider = Math.ceil(1.0 / scaleFactor);
                    scaleFactor = 1.0 / scaleDivider;
                    adjw = (int)Math.round((double)iw / scaleDivider);
                    adjh = (int)Math.round((double)ih / scaleDivider);
                    scaleMeasure = 1.0 - 1.0 / scaleDivider;
                }
                double similarity = ((double)width - (double)adjw) / (double)width +
                    ((double)height - (double)adjh) / (double)height + //Large padding is bad
                    scaleMeasure; //Large rescale is bad
                if (similarity < bestSimilarity) {
                    bestSimilarity = similarity;
                    bestScaleFactor = scaleFactor;
                    bestImage = im;
                    bestWidth = adjw;
                    bestHeight = adjh;
                }
                if (similarity == 0) break;
            }
        }
        if (bestImage == null) {
            //No images were found, possibly all are broken
            return null;
        }
        BufferedImage bimage =
            new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = bimage.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,
                           RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        try {
            int x = (width - bestWidth) / 2;
            int y = (height - bestHeight) / 2;
            g.drawImage(bestImage, x, y, bestWidth, bestHeight, null);
        } finally {
            g.dispose();
        }
        return bimage;
    }

    public static DataBufferInt getScaledIconData(java.util.List<Image> imageList, int width, int height) {
        BufferedImage bimage = getScaledIconImage(imageList, width, height);
        if (bimage == null) {
            return null;
        }
        Raster raster = bimage.getRaster();
        DataBuffer buffer = raster.getDataBuffer();
        return (DataBufferInt)buffer;
    }

    protected EventQueue getSystemEventQueueImpl() {
        return getSystemEventQueueImplPP();
    }

    // Package private implementation
    static EventQueue getSystemEventQueueImplPP() {
        return getSystemEventQueueImplPP(AppContext.getAppContext());
    }

    public static EventQueue getSystemEventQueueImplPP(AppContext appContext) {
        EventQueue theEventQueue =
            (EventQueue)appContext.get(AppContext.EVENT_QUEUE_KEY);
        return theEventQueue;
    }

    /**
     * Give native peers the ability to query the native container
     * given a native component (eg the direct parent may be lightweight).
     */
    public static Container getNativeContainer(Component c) {
        return Toolkit.getNativeContainer(c);
    }

    /**
     * Gives native peers the ability to query the closest HW component.
     * If the given component is heavyweight, then it returns this. Otherwise,
     * it goes one level up in the hierarchy and tests next component.
     */
    public static Component getHeavyweightComponent(Component c) {
        while (c != null && AWTAccessor.getComponentAccessor().isLightweight(c)) {
            c = AWTAccessor.getComponentAccessor().getParent(c);
        }
        return c;
    }

    /**
     * Returns key modifiers used by Swing to set up a focus accelerator key stroke.
     */
    public int getFocusAcceleratorKeyMask() {
        return InputEvent.ALT_MASK;
    }

    /**
     * Tests whether specified key modifiers mask can be used to enter a printable
     * character. This is a default implementation of this method, which reflects
     * the way things work on Windows: here, pressing ctrl + alt allows user to enter
     * characters from the extended character set (like euro sign or math symbols)
     */
    public boolean isPrintableCharacterModifiersMask(int mods) {
        return ((mods & InputEvent.ALT_MASK) == (mods & InputEvent.CTRL_MASK));
    }

    /**
     * Returns whether popup is allowed to be shown above the task bar.
     * This is a default implementation of this method, which checks
     * corresponding security permission.
     */
    public boolean canPopupOverlapTaskBar() {
        boolean result = true;
        try {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPermission(
                        SecurityConstants.AWT.SET_WINDOW_ALWAYS_ON_TOP_PERMISSION);
            }
        } catch (SecurityException se) {
            // There is no permission to show popups over the task bar
            result = false;
        }
        return result;
    }

    /**
     * Returns a new input method window, with behavior as specified in
     * {@@link java.awt.im.spi.InputMethodContext#createInputMethodWindow}.
     * If the inputContext is not null, the window should return it from its
     * getInputContext() method. The window needs to implement
     * sun.awt.im.InputMethodWindow.
     * <p>
     * SunToolkit subclasses can override this method to return better input
     * method windows.
     */
    public Window createInputMethodWindow(String title, InputContext context) {
        throw new Error();
    }

    /**
     * Returns whether enableInputMethods should be set to true for peered
     * TextComponent instances on this platform. False by default.
     */
    public boolean enableInputMethodsForTextComponent() {
        return false;
    }

    private static Locale startupLocale = null;

    /**
     * Returns the locale in which the runtime was started.
     */
    public static Locale getStartupLocale() {
        if (startupLocale == null) {
            String language, region, country, variant;
            language = AccessController.doPrivileged(
                            new GetPropertyAction("user.language", "en"));
            // for compatibility, check for old user.region property
            region = AccessController.doPrivileged(
                            new GetPropertyAction("user.region"));
            if (region != null) {
                // region can be of form country, country_variant, or _variant
                int i = region.indexOf('_');
                if (i >= 0) {
                    country = region.substring(0, i);
                    variant = region.substring(i + 1);
                } else {
                    country = region;
                    variant = "";
                }
            } else {
                country = AccessController.doPrivileged(
                                new GetPropertyAction("user.country", ""));
                variant = AccessController.doPrivileged(
                                new GetPropertyAction("user.variant", ""));
            }
            startupLocale = new Locale(language, country, variant);
        }
        return startupLocale;
    }

    /**
     * Returns the default keyboard locale of the underlying operating system
     */
    public Locale getDefaultKeyboardLocale() {
        return getStartupLocale();
    }

    // Support for window closing event notifications
    private transient WindowClosingListener windowClosingListener = null;
    /**
     * @@see sun.awt.WindowClosingSupport#getWindowClosingListener
     */
    public WindowClosingListener getWindowClosingListener() {
        return windowClosingListener;
    }
    /**
     * @@see sun.awt.WindowClosingSupport#setWindowClosingListener
     */
    public void setWindowClosingListener(WindowClosingListener wcl) {
        windowClosingListener = wcl;
    }

    /**
     * @@see sun.awt.WindowClosingListener#windowClosingNotify
     */
    public RuntimeException windowClosingNotify(WindowEvent event) {
        if (windowClosingListener != null) {
            return windowClosingListener.windowClosingNotify(event);
        } else {
            return null;
        }
    }
    /**
     * @@see sun.awt.WindowClosingListener#windowClosingDelivered
     */
    public RuntimeException windowClosingDelivered(WindowEvent event) {
        if (windowClosingListener != null) {
            return windowClosingListener.windowClosingDelivered(event);
        } else {
            return null;
        }
    }



    /**
     * Returns whether default toolkit needs the support of the xembed
     * from embedding host(if any).
     * @@return <code>true</code>, if XEmbed is needed, <code>false</code> otherwise
     */
    public static boolean needsXEmbed() {
        String noxembed = AccessController.
            doPrivileged(new GetPropertyAction("sun.awt.noxembed", "false"));
        if ("true".equals(noxembed)) {
            return false;
        }

        Toolkit tk = Toolkit.getDefaultToolkit();
        if (tk instanceof SunToolkit) {
            // SunToolkit descendants should override this method to specify
            // concrete behavior
            return ((SunToolkit)tk).needsXEmbedImpl();
        } else {
            // Non-SunToolkit doubtly might support XEmbed
            return false;
        }
    }

    /**
     * Returns whether this toolkit needs the support of the xembed
     * from embedding host(if any).
     * @@return <code>true</code>, if XEmbed is needed, <code>false</code> otherwise
     */
    protected boolean needsXEmbedImpl() {
        return false;
    }

    private static Dialog.ModalExclusionType DEFAULT_MODAL_EXCLUSION_TYPE = null;

    /**
     * Returns whether the XEmbed server feature is requested by
     * developer.  If true, Toolkit should return an
     * XEmbed-server-enabled CanvasPeer instead of the ordinary CanvasPeer.
     */
    protected final boolean isXEmbedServerRequested() {
        return AccessController.doPrivileged(new GetBooleanAction("sun.awt.xembedserver"));
    }

    /**
     * Returns whether the modal exclusion API is supported by the current toolkit.
     * When it isn't supported, calling <code>setModalExcluded</code> has no
     * effect, and <code>isModalExcluded</code> returns false for all windows.
     *
     * @@return true if modal exclusion is supported by the toolkit, false otherwise
     *
     * @@see sun.awt.SunToolkit#setModalExcluded(java.awt.Window)
     * @@see sun.awt.SunToolkit#isModalExcluded(java.awt.Window)
     *
     * @@since 1.5
     */
    public static boolean isModalExcludedSupported()
    {
        Toolkit tk = Toolkit.getDefaultToolkit();
        return tk.isModalExclusionTypeSupported(DEFAULT_MODAL_EXCLUSION_TYPE);
    }
    /*
     * Default implementation for isModalExcludedSupportedImpl(), returns false.
     *
     * @@see sun.awt.windows.WToolkit#isModalExcludeSupportedImpl
     * @@see sun.awt.X11.XToolkit#isModalExcludeSupportedImpl
     *
     * @@since 1.5
     */
    protected boolean isModalExcludedSupportedImpl()
    {
        return false;
    }

    /*
     * Sets this window to be excluded from being modally blocked. When the
     * toolkit supports modal exclusion and this method is called, input
     * events, focus transfer and z-order will continue to work for the
     * window, it's owned windows and child components, even in the
     * presence of a modal dialog.
     * For details on which <code>Window</code>s are normally blocked
     * by modal dialog, see {@@link java.awt.Dialog}.
     * Invoking this method when the modal exclusion API is not supported by
     * the current toolkit has no effect.
     * @@param window Window to be marked as not modally blocked
     * @@see java.awt.Dialog
     * @@see java.awt.Dialog#setModal(boolean)
     * @@see sun.awt.SunToolkit#isModalExcludedSupported
     * @@see sun.awt.SunToolkit#isModalExcluded(java.awt.Window)
     */
    public static void setModalExcluded(Window window)
    {
        if (DEFAULT_MODAL_EXCLUSION_TYPE == null) {
            DEFAULT_MODAL_EXCLUSION_TYPE = Dialog.ModalExclusionType.APPLICATION_EXCLUDE;
        }
        window.setModalExclusionType(DEFAULT_MODAL_EXCLUSION_TYPE);
    }

    /*
     * Returns whether the specified window is blocked by modal dialogs.
     * If the modal exclusion API isn't supported by the current toolkit,
     * it returns false for all windows.
     *
     * @@param window Window to test for modal exclusion
     *
     * @@return true if the window is modal excluded, false otherwise. If
     * the modal exclusion isn't supported by the current Toolkit, false
     * is returned
     *
     * @@see sun.awt.SunToolkit#isModalExcludedSupported
     * @@see sun.awt.SunToolkit#setModalExcluded(java.awt.Window)
     *
     * @@since 1.5
     */
    public static boolean isModalExcluded(Window window)
    {
        if (DEFAULT_MODAL_EXCLUSION_TYPE == null) {
            DEFAULT_MODAL_EXCLUSION_TYPE = Dialog.ModalExclusionType.APPLICATION_EXCLUDE;
        }
        return window.getModalExclusionType().compareTo(DEFAULT_MODAL_EXCLUSION_TYPE) >= 0;
    }

    /**
     * Overridden in XToolkit and WToolkit
     */
    public boolean isModalityTypeSupported(Dialog.ModalityType modalityType) {
        return (modalityType == Dialog.ModalityType.MODELESS) ||
               (modalityType == Dialog.ModalityType.APPLICATION_MODAL);
    }

    /**
     * Overridden in XToolkit and WToolkit
     */
    public boolean isModalExclusionTypeSupported(Dialog.ModalExclusionType exclusionType) {
        return (exclusionType == Dialog.ModalExclusionType.NO_EXCLUDE);
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // The following is used by the Java Plug-in to coordinate dialog modality
    // between containing applications (browsers, ActiveX containers etc) and
    // the AWT.
    //
    ///////////////////////////////////////////////////////////////////////////

    private ModalityListenerList modalityListeners = new ModalityListenerList();

    public void addModalityListener(ModalityListener listener) {
        modalityListeners.add(listener);
    }

    public void removeModalityListener(ModalityListener listener) {
        modalityListeners.remove(listener);
    }

    public void notifyModalityPushed(Dialog dialog) {
        notifyModalityChange(ModalityEvent.MODALITY_PUSHED, dialog);
    }

    public void notifyModalityPopped(Dialog dialog) {
        notifyModalityChange(ModalityEvent.MODALITY_POPPED, dialog);
    }

    final void notifyModalityChange(int id, Dialog source) {
        ModalityEvent ev = new ModalityEvent(source, modalityListeners, id);
        ev.dispatch();
    }

    static class ModalityListenerList implements ModalityListener {

        Vector<ModalityListener> listeners = new Vector<ModalityListener>();

        void add(ModalityListener listener) {
            listeners.addElement(listener);
        }

        void remove(ModalityListener listener) {
            listeners.removeElement(listener);
        }

        public void modalityPushed(ModalityEvent ev) {
            Iterator<ModalityListener> it = listeners.iterator();
            while (it.hasNext()) {
                it.next().modalityPushed(ev);
            }
        }

        public void modalityPopped(ModalityEvent ev) {
            Iterator<ModalityListener> it = listeners.iterator();
            while (it.hasNext()) {
                it.next().modalityPopped(ev);
            }
        }
    } // end of class ModalityListenerList

    ///////////////////////////////////////////////////////////////////////////
    // End Plug-in code
    ///////////////////////////////////////////////////////////////////////////

    public static boolean isLightweightOrUnknown(Component comp) {
        if (comp.isLightweight()
            || !(getDefaultToolkit() instanceof SunToolkit))
        {
            return true;
        }
        return !(comp instanceof Button
            || comp instanceof Canvas
            || comp instanceof Checkbox
            || comp instanceof Choice
            || comp instanceof Label
            || comp instanceof java.awt.List
            || comp instanceof Panel
            || comp instanceof Scrollbar
            || comp instanceof ScrollPane
            || comp instanceof TextArea
            || comp instanceof TextField
            || comp instanceof Window);
    }

    @@SuppressWarnings("serial")
    public static class OperationTimedOut extends RuntimeException {
        public OperationTimedOut(String msg) {
            super(msg);
        }
        public OperationTimedOut() {
        }
    }

    @@SuppressWarnings("serial")
    public static class InfiniteLoop extends RuntimeException {
    }

    @@SuppressWarnings("serial")
    public static class IllegalThreadException extends RuntimeException {
        public IllegalThreadException(String msg) {
            super(msg);
        }
        public IllegalThreadException() {
        }
    }

    public static final int DEFAULT_WAIT_TIME = 10000;
    private static final int MAX_ITERS = 20;
    private static final int MIN_ITERS = 0;
    private static final int MINIMAL_EDELAY = 0;

    /**
     * Parameterless version of realsync which uses default timout (see DEFAUL_WAIT_TIME).
     */
    public void realSync() throws OperationTimedOut, InfiniteLoop {
        realSync(DEFAULT_WAIT_TIME);
    }

    /**
     * Forces toolkit to synchronize with the native windowing
     * sub-system, flushing all pending work and waiting for all the
     * events to be processed.  This method guarantees that after
     * return no additional Java events will be generated, unless
     * cause by user. Obviously, the method cannot be used on the
     * event dispatch thread (EDT). In case it nevertheless gets
     * invoked on this thread, the method throws the
     * IllegalThreadException runtime exception.
     *
     * <p> This method allows to write tests without explicit timeouts
     * or wait for some event.  Example:
     * <code>
     * Frame f = ...;
     * f.setVisible(true);
     * ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
     * </code>
     *
     * <p> After realSync, <code>f</code> will be completely visible
     * on the screen, its getLocationOnScreen will be returning the
     * right result and it will be the focus owner.
     *
     * <p> Another example:
     * <code>
     * b.requestFocus();
     * ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
     * </code>
     *
     * <p> After realSync, <code>b</code> will be focus owner.
     *
     * <p> Notice that realSync isn't guaranteed to work if recurring
     * actions occur, such as if during processing of some event
     * another request which may generate some events occurs.  By
     * default, sync tries to perform as much as {@@value MAX_ITERS}
     * cycles of event processing, allowing for roughly {@@value
     * MAX_ITERS} additional requests.
     *
     * <p> For example, requestFocus() generates native request, which
     * generates one or two Java focus events, which then generate a
     * serie of paint events, a serie of Java focus events, which then
     * generate a serie of paint events which then are processed -
     * three cycles, minimum.
     *
     * @@param timeout the maximum time to wait in milliseconds, negative means "forever".
     */
    public void realSync(final long timeout) throws OperationTimedOut, InfiniteLoop
    {
        if (EventQueue.isDispatchThread()) {
            throw new IllegalThreadException("The SunToolkit.realSync() method cannot be used on the event dispatch thread (EDT).");
        }
        int bigLoop = 0;
        do {
            // Let's do sync first
            sync();

            // During the wait process, when we were processing incoming
            // events, we could have made some new request, which can
            // generate new events.  Example: MapNotify/XSetInputFocus.
            // Therefore, we dispatch them as long as there is something
            // to dispatch.
            int iters = 0;
            while (iters < MIN_ITERS) {
                syncNativeQueue(timeout);
                iters++;
            }
            while (syncNativeQueue(timeout) && iters < MAX_ITERS) {
                iters++;
            }
            if (iters >= MAX_ITERS) {
                throw new InfiniteLoop();
            }

            // native requests were dispatched by X/Window Manager or Windows
            // Moreover, we processed them all on Toolkit thread
            // Now wait while EDT processes them.
            //
            // During processing of some events (focus, for example),
            // some other events could have been generated.  So, after
            // waitForIdle, we may end up with full EventQueue
            iters = 0;
            while (iters < MIN_ITERS) {
                waitForIdle(timeout);
                iters++;
            }
            while (waitForIdle(timeout) && iters < MAX_ITERS) {
                iters++;
            }
            if (iters >= MAX_ITERS) {
                throw new InfiniteLoop();
            }

            bigLoop++;
            // Again, for Java events, it was simple to check for new Java
            // events by checking event queue, but what if Java events
            // resulted in native requests?  Therefor, check native events again.
        } while ((syncNativeQueue(timeout) || waitForIdle(timeout)) && bigLoop < MAX_ITERS);
    }

    /**
     * Platform toolkits need to implement this method to perform the
     * sync of the native queue.  The method should wait until native
     * requests are processed, all native events are processed and
     * corresponding Java events are generated.  Should return
     * <code>true</code> if some events were processed,
     * <code>false</code> otherwise.
     */
    protected abstract boolean syncNativeQueue(final long timeout);

    private boolean eventDispatched = false;
    private boolean queueEmpty = false;
    private final Object waitLock = "Wait Lock";

    private boolean isEQEmpty() {
        EventQueue queue = getSystemEventQueueImpl();
        return AWTAccessor.getEventQueueAccessor().noEvents(queue);
    }

    /**
     * Waits for the Java event queue to empty.  Ensures that all
     * events are processed (including paint events), and that if
     * recursive events were generated, they are also processed.
     * Should return <code>true</code> if more processing is
     * necessary, <code>false</code> otherwise.
     */
    @@SuppressWarnings("serial")
    protected final boolean waitForIdle(final long timeout) {
        flushPendingEvents();
        boolean queueWasEmpty = isEQEmpty();
        queueEmpty = false;
        eventDispatched = false;
        synchronized(waitLock) {
            postEvent(AppContext.getAppContext(),
                      new PeerEvent(getSystemEventQueueImpl(), null, PeerEvent.LOW_PRIORITY_EVENT) {
                          public void dispatch() {
                              // Here we block EDT.  It could have some
                              // events, it should have dispatched them by
                              // now.  So native requests could have been
                              // generated.  First, dispatch them.  Then,
                              // flush Java events again.
                              int iters = 0;
                              while (iters < MIN_ITERS) {
                                  syncNativeQueue(timeout);
                                  iters++;
                              }
                              while (syncNativeQueue(timeout) && iters < MAX_ITERS) {
                                  iters++;
                              }
                              flushPendingEvents();

                              synchronized(waitLock) {
                                  queueEmpty = isEQEmpty();
                                  eventDispatched = true;
                                  waitLock.notifyAll();
                              }
                          }
                      });
            try {
                while (!eventDispatched) {
                    waitLock.wait();
                }
            } catch (InterruptedException ie) {
                return false;
            }
        }

        try {
            Thread.sleep(MINIMAL_EDELAY);
        } catch (InterruptedException ie) {
            throw new RuntimeException("Interrupted");
        }

        flushPendingEvents();

        // Lock to force write-cache flush for queueEmpty.
        synchronized (waitLock) {
            return !(queueEmpty && isEQEmpty() && queueWasEmpty);
        }
    }

    /**
     * Grabs the mouse input for the given window.  The window must be
     * visible.  The window or its children do not receive any
     * additional mouse events besides those targeted to them.  All
     * other events will be dispatched as before - to the respective
     * targets.  This Window will receive UngrabEvent when automatic
     * ungrab is about to happen.  The event can be listened to by
     * installing AWTEventListener with WINDOW_EVENT_MASK.  See
     * UngrabEvent class for the list of conditions when ungrab is
     * about to happen.
     * @@see UngrabEvent
     */
    public abstract void grab(Window w);

    /**
     * Forces ungrab.  No event will be sent.
     */
    public abstract void ungrab(Window w);


    /**
     * Locates the splash screen library in a platform dependent way and closes
     * the splash screen. Should be invoked on first top-level frame display.
     * @@see java.awt.SplashScreen
     * @@since 1.6
     */
    public static native void closeSplashScreen();

    /* The following methods and variables are to support retrieving
     * desktop text anti-aliasing settings
     */

    /* Need an instance method because setDesktopProperty(..) is protected. */
    private void fireDesktopFontPropertyChanges() {
        setDesktopProperty(SunToolkit.DESKTOPFONTHINTS,
                           SunToolkit.getDesktopFontHints());
    }

    private static boolean checkedSystemAAFontSettings;
    private static boolean useSystemAAFontSettings;
    private static boolean lastExtraCondition = true;
    private static RenderingHints desktopFontHints;

    /* Since Swing is the reason for this "extra condition" logic its
     * worth documenting it in some detail.
     * First, a goal is for Swing and applications to both retrieve and
     * use the same desktop property value so that there is complete
     * consistency between the settings used by JDK's Swing implementation
     * and 3rd party custom Swing components, custom L&Fs and any general
     * text rendering that wants to be consistent with these.
     * But by default on Solaris & Linux Swing will not use AA text over
     * remote X11 display (unless Xrender can be used which is TBD and may not
     * always be available anyway) as that is a noticeable performance hit.
     * So there needs to be a way to express that extra condition so that
     * it is seen by all clients of the desktop property API.
     * If this were the only condition it could be handled here as it would
     * be the same for any L&F and could reasonably be considered to be
     * a static behaviour of those systems.
     * But GTK currently has an additional test based on locale which is
     * not applied by Metal. So mixing GTK in a few locales with Metal
     * would mean the last one wins.
     * This could be stored per-app context which would work
     * for different applets, but wouldn't help for a single application
     * using GTK and some other L&F concurrently.
     * But it is expected this will be addressed within GTK and the font
     * system so is a temporary and somewhat unlikely harmless corner case.
     */
    public static void setAAFontSettingsCondition(boolean extraCondition) {
        if (extraCondition != lastExtraCondition) {
            lastExtraCondition = extraCondition;
            if (checkedSystemAAFontSettings) {
                /* Someone already asked for this info, under a different
                 * condition.
                 * We'll force re-evaluation instead of replicating the
                 * logic, then notify any listeners of any change.
                 */
                checkedSystemAAFontSettings = false;
                Toolkit tk = Toolkit.getDefaultToolkit();
                if (tk instanceof SunToolkit) {
                     ((SunToolkit)tk).fireDesktopFontPropertyChanges();
                }
            }
        }
    }

    /* "false", "off", ""default" aren't explicitly tested, they
     * just fall through to produce a null return which all are equated to
     * "false".
     */
    private static RenderingHints getDesktopAAHintsByName(String hintname) {
        Object aaHint = null;
        hintname = hintname.toLowerCase(Locale.ENGLISH);
        if (hintname.equals("on")) {
            aaHint = VALUE_TEXT_ANTIALIAS_ON;
        } else if (hintname.equals("gasp")) {
            aaHint = VALUE_TEXT_ANTIALIAS_GASP;
        } else if (hintname.equals("lcd") || hintname.equals("lcd_hrgb")) {
            aaHint = VALUE_TEXT_ANTIALIAS_LCD_HRGB;
        } else if (hintname.equals("lcd_hbgr")) {
            aaHint = VALUE_TEXT_ANTIALIAS_LCD_HBGR;
        } else if (hintname.equals("lcd_vrgb")) {
            aaHint = VALUE_TEXT_ANTIALIAS_LCD_VRGB;
        } else if (hintname.equals("lcd_vbgr")) {
            aaHint = VALUE_TEXT_ANTIALIAS_LCD_VBGR;
        }
        if (aaHint != null) {
            RenderingHints map = new RenderingHints(null);
            map.put(KEY_TEXT_ANTIALIASING, aaHint);
            return map;
        } else {
            return null;
        }
    }

    /* This method determines whether to use the system font settings,
     * or ignore them if a L&F has specified they should be ignored, or
     * to override both of these with a system property specified value.
     * If the toolkit isn't a SunToolkit, (eg may be headless) then that
     * system property isn't applied as desktop properties are considered
     * to be inapplicable in that case. In that headless case although
     * this method will return "true" the toolkit will return a null map.
     */
    private static boolean useSystemAAFontSettings() {
        if (!checkedSystemAAFontSettings) {
            useSystemAAFontSettings = true; /* initially set this true */
            String systemAAFonts = null;
            Toolkit tk = Toolkit.getDefaultToolkit();
            if (tk instanceof SunToolkit) {
                systemAAFonts =
                    AccessController.doPrivileged(
                         new GetPropertyAction("awt.useSystemAAFontSettings"));
            }
            if (systemAAFonts != null) {
                useSystemAAFontSettings =
                    Boolean.valueOf(systemAAFonts).booleanValue();
                /* If it is anything other than "true", then it may be
                 * a hint name , or it may be "off, "default", etc.
                 */
                if (!useSystemAAFontSettings) {
                    desktopFontHints = getDesktopAAHintsByName(systemAAFonts);
                }
            }
            /* If its still true, apply the extra condition */
            if (useSystemAAFontSettings) {
                 useSystemAAFontSettings = lastExtraCondition;
            }
            checkedSystemAAFontSettings = true;
        }
        return useSystemAAFontSettings;
    }

    /* A variable defined for the convenience of JDK code */
    public static final String DESKTOPFONTHINTS = "awt.font.desktophints";

    /* Overridden by subclasses to return platform/desktop specific values */
    protected RenderingHints getDesktopAAHints() {
        return null;
    }

    /* Subclass desktop property loading methods call this which
     * in turn calls the appropriate subclass implementation of
     * getDesktopAAHints() when system settings are being used.
     * Its public rather than protected because subclasses may delegate
     * to a helper class.
     */
    public static RenderingHints getDesktopFontHints() {
        if (useSystemAAFontSettings()) {
             Toolkit tk = Toolkit.getDefaultToolkit();
             if (tk instanceof SunToolkit) {
                 Object map = ((SunToolkit)tk).getDesktopAAHints();
                 return (RenderingHints)map;
             } else { /* Headless Toolkit */
                 return null;
             }
        } else if (desktopFontHints != null) {
            /* cloning not necessary as the return value is cloned later, but
             * its harmless.
             */
            return (RenderingHints)(desktopFontHints.clone());
        } else {
            return null;
        }
    }


    public abstract boolean isDesktopSupported();

    /*
     * consumeNextKeyTyped() method is not currently used,
     * however Swing could use it in the future.
     */
    public static synchronized void consumeNextKeyTyped(KeyEvent keyEvent) {
        try {
            AWTAccessor.getDefaultKeyboardFocusManagerAccessor().consumeNextKeyTyped(
                (DefaultKeyboardFocusManager)KeyboardFocusManager.
                    getCurrentKeyboardFocusManager(),
                keyEvent);
        } catch (ClassCastException cce) {
             cce.printStackTrace();
        }
    }

    protected static void dumpPeers(final PlatformLogger aLog) {
        AWTAutoShutdown.getInstance().dumpPeers(aLog);
    }

    /**
     * Returns the <code>Window</code> ancestor of the component <code>comp</code>.
     * @@return Window ancestor of the component or component by itself if it is Window;
     *         null, if component is not a part of window hierarchy
     */
    public static Window getContainingWindow(Component comp) {
        while (comp != null && !(comp instanceof Window)) {
            comp = comp.getParent();
        }
        return (Window)comp;
    }

    private static Boolean sunAwtDisableMixing = null;

    /**
     * Returns the value of "sun.awt.disableMixing" property. Default
     * value is {@@code false}.
     */
    public synchronized static boolean getSunAwtDisableMixing() {
        if (sunAwtDisableMixing == null) {
            sunAwtDisableMixing = AccessController.doPrivileged(
                                      new GetBooleanAction("sun.awt.disableMixing"));
        }
        return sunAwtDisableMixing.booleanValue();
    }

    /**
     * Returns true if the native GTK libraries are available.  The
     * default implementation returns false, but UNIXToolkit overrides this
     * method to provide a more specific answer.
     */
    public boolean isNativeGTKAvailable() {
        return false;
    }

    private static final Object DEACTIVATION_TIMES_MAP_KEY = new Object();

    public synchronized void setWindowDeactivationTime(Window w, long time) {
        AppContext ctx = getAppContext(w);
        WeakHashMap<Window, Long> map = (WeakHashMap<Window, Long>)ctx.get(DEACTIVATION_TIMES_MAP_KEY);
        if (map == null) {
            map = new WeakHashMap<Window, Long>();
            ctx.put(DEACTIVATION_TIMES_MAP_KEY, map);
        }
        map.put(w, time);
    }

    public synchronized long getWindowDeactivationTime(Window w) {
        AppContext ctx = getAppContext(w);
        WeakHashMap<Window, Long> map = (WeakHashMap<Window, Long>)ctx.get(DEACTIVATION_TIMES_MAP_KEY);
        if (map == null) {
            return -1;
        }
        Long time = map.get(w);
        return time == null ? -1 : time;
    }

    // Cosntant alpha
    public boolean isWindowOpacitySupported() {
        return false;
    }

    // Shaping
    public boolean isWindowShapingSupported() {
        return false;
    }

    // Per-pixel alpha
    public boolean isWindowTranslucencySupported() {
        return false;
    }

    public boolean isTranslucencyCapable(GraphicsConfiguration gc) {
        return false;
    }

    /**
     * Returns true if swing backbuffer should be translucent.
     */
    public boolean isSwingBackbufferTranslucencySupported() {
        return false;
    }

    /**
     * Returns whether or not a containing top level window for the passed
     * component is
     * {@@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}.
     *
     * @@param c a Component which toplevel's to check
     * @@return {@@code true}  if the passed component is not null and has a
     * containing toplevel window which is opaque (so per-pixel translucency
     * is not enabled), {@@code false} otherwise
     * @@see GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT
     */
    public static boolean isContainingTopLevelOpaque(Component c) {
        Window w = getContainingWindow(c);
        return w != null && w.isOpaque();
    }

    /**
     * Returns whether or not a containing top level window for the passed
     * component is
     * {@@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}.
     *
     * @@param c a Component which toplevel's to check
     * @@return {@@code true} if the passed component is not null and has a
     * containing toplevel window which has opacity less than
     * 1.0f (which means that it is translucent), {@@code false} otherwise
     * @@see GraphicsDevice.WindowTranslucency#TRANSLUCENT
     */
    public static boolean isContainingTopLevelTranslucent(Component c) {
        Window w = getContainingWindow(c);
        return w != null && w.getOpacity() < 1.0f;
    }

    /**
     * Returns whether the native system requires using the peer.updateWindow()
     * method to update the contents of a non-opaque window, or if usual
     * painting procedures are sufficient. The default return value covers
     * the X11 systems. On MS Windows this method is overriden in WToolkit
     * to return true.
     */
    public boolean needUpdateWindow() {
        return false;
    }

    /**
     * Descendants of the SunToolkit should override and put their own logic here.
     */
    public int getNumberOfButtons(){
        return 3;
    }

    /**
     * Checks that the given object implements/extends the given
     * interface/class.
     *
     * Note that using the instanceof operator causes a class to be loaded.
     * Using this method doesn't load a class and it can be used instead of
     * the instanceof operator for performance reasons.
     *
     * @@param obj Object to be checked
     * @@param type The name of the interface/class. Must be
     * fully-qualified interface/class name.
     * @@return true, if this object implements/extends the given
     *         interface/class, false, otherwise, or if obj or type is null
     */
    public static boolean isInstanceOf(Object obj, String type) {
        if (obj == null) return false;
        if (type == null) return false;

        return isInstanceOf(obj.getClass(), type);
    }

    private static boolean isInstanceOf(Class<?> cls, String type) {
        if (cls == null) return false;

        if (cls.getName().equals(type)) {
            return true;
        }

        for (Class<?> c : cls.getInterfaces()) {
            if (c.getName().equals(type)) {
                return true;
            }
        }
        return isInstanceOf(cls.getSuperclass(), type);
    }

    protected static LightweightFrame getLightweightFrame(Component c) {
        for (; c != null; c = c.getParent()) {
            if (c instanceof LightweightFrame) {
                return (LightweightFrame)c;
            }
            if (c instanceof Window) {
                // Don't traverse owner windows
                return null;
            }
        }
        return null;
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // The following methods help set and identify whether a particular
    // AWTEvent object was produced by the system or by user code. As of this
    // writing the only consumer is the Java Plug-In, although this information
    // could be useful to more clients and probably should be formalized in
    // the public API.
    //
    ///////////////////////////////////////////////////////////////////////////

    public static void setSystemGenerated(AWTEvent e) {
        AWTAccessor.getAWTEventAccessor().setSystemGenerated(e);
    }

    public static boolean isSystemGenerated(AWTEvent e) {
        return AWTAccessor.getAWTEventAccessor().isSystemGenerated(e);
    }

} // class SunToolkit


/*
 * PostEventQueue is a Thread that runs in the same AppContext as the
 * Java EventQueue.  It is a queue of AWTEvents to be posted to the
 * Java EventQueue.  The toolkit Thread (AWT-Windows/AWT-Motif) posts
 * events to this queue, which then calls EventQueue.postEvent().
 *
 * We do this because EventQueue.postEvent() may be overridden by client
 * code, and we mustn't ever call client code from the toolkit thread.
 */
class PostEventQueue {
    private EventQueueItem queueHead = null;
    private EventQueueItem queueTail = null;
    private final EventQueue eventQueue;

    private Thread flushThread = null;

    PostEventQueue(EventQueue eq) {
        eventQueue = eq;
    }

    /*
     * Continually post pending AWTEvents to the Java EventQueue. The method
     * is synchronized to ensure the flush is completed before a new event
     * can be posted to this queue.
     *
     * 7177040: The method couldn't be wholly synchronized because of calls
     * of EventQueue.postEvent() that uses pushPopLock, otherwise it could
     * potentially lead to deadlock
     */
    public void flush() {

        Thread newThread = Thread.currentThread();

        try {
            EventQueueItem tempQueue;
            synchronized (this) {
                // Avoid method recursion
                if (newThread == flushThread) {
                    return;
                }
                // Wait for other threads' flushing
                while (flushThread != null) {
                    wait();
                }
                // Skip everything if queue is empty
                if (queueHead == null) {
                    return;
                }
                // Remember flushing thread
                flushThread = newThread;

                tempQueue = queueHead;
                queueHead = queueTail = null;
            }
            try {
                while (tempQueue != null) {
                    eventQueue.postEvent(tempQueue.event);
                    tempQueue = tempQueue.next;
                }
            }
            finally {
                // Only the flushing thread can get here
                synchronized (this) {
                    // Forget flushing thread, inform other pending threads
                    flushThread = null;
                    notifyAll();
                }
            }
        }
        catch (InterruptedException e) {
            // Couldn't allow exception go up, so at least recover the flag
            newThread.interrupt();
        }
    }

    /*
     * Enqueue an AWTEvent to be posted to the Java EventQueue.
     */
    void postEvent(AWTEvent event) {
        EventQueueItem item = new EventQueueItem(event);

        synchronized (this) {
            if (queueHead == null) {
                queueHead = queueTail = item;
            } else {
                queueTail.next = item;
                queueTail = item;
            }
        }
        SunToolkit.wakeupEventQueue(eventQueue, event.getSource() == AWTAutoShutdown.getInstance());
    }
} // class PostEventQueue
@


1.25
log
@Integrated OpenJDK 8u45.
@
text
@@


1.24
log
@First part of OpenJDK 8 integration.
@
text
@d2 1
a2 1
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
d39 3
d49 1
d56 1
d382 1
a382 1
        if (target == null || GraphicsEnvironment.isHeadless()) {
d456 4
a459 6
        if (!GraphicsEnvironment.isHeadless()) {
            if (!setAppContext(target, appContext)) {
                // Target is not a Component/MenuComponent, use the private Map
                // instead.
                appContextMap.put(target, appContext);
            }
d714 1
a714 27
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            try {
                java.security.Permission perm =
                    url.openConnection().getPermission();
                if (perm != null) {
                    try {
                        sm.checkPermission(perm);
                    } catch (SecurityException se) {
                        // fallback to checkRead/checkConnect for pre 1.2
                        // security managers
                        if ((perm instanceof java.io.FilePermission) &&
                            perm.getActions().indexOf("read") != -1) {
                            sm.checkRead(perm.getName());
                        } else if ((perm instanceof
                            java.net.SocketPermission) &&
                            perm.getActions().indexOf("connect") != -1) {
                            sm.checkConnect(url.getHost(), url.getPort());
                        } else {
                            throw se;
                        }
                    }
                }
            } catch (java.io.IOException ioe) {
                    sm.checkConnect(url.getHost(), url.getPort());
            }
        }
d730 1
a730 4
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkRead(filename);
        }
d752 29
d782 1
a782 4
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkRead(filename);
        }
d787 1
a787 27
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            try {
                java.security.Permission perm =
                    url.openConnection().getPermission();
                if (perm != null) {
                    try {
                        sm.checkPermission(perm);
                    } catch (SecurityException se) {
                        // fallback to checkRead/checkConnect for pre 1.2
                        // security managers
                        if ((perm instanceof java.io.FilePermission) &&
                            perm.getActions().indexOf("read") != -1) {
                            sm.checkRead(perm.getName());
                        } else if ((perm instanceof
                            java.net.SocketPermission) &&
                            perm.getActions().indexOf("connect") != -1) {
                            sm.checkConnect(url.getHost(), url.getPort());
                        } else {
                            throw se;
                        }
                    }
                }
            } catch (java.io.IOException ioe) {
                    sm.checkConnect(url.getHost(), url.getPort());
            }
        }
d799 5
d816 1
a816 1
        return tkimg.check(o) | repbits;
d838 99
a936 1
        return ir.prepare(o);
a1194 13
    private static String dataTransfererClassName = null;

    protected static void setDataTransfererClassName(String className) {
        dataTransfererClassName = className;
    }

    public static String getDataTransfererClassName() {
        if (dataTransfererClassName == null) {
            Toolkit.getDefaultToolkit(); // transferer set during toolkit init
        }
        return dataTransfererClassName;
    }

d2039 13
@


1.23
log
@Merged OpenJDK 7u40 b34, except for java.lang.invoke and sun.invoke packages.
@
text
@d2 1
a2 1
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
d61 1
a61 1
    // 8014736: logging has been removed from SunToolkit
d133 3
d196 1
d333 2
a334 2
    private static final Map appContextMap =
        Collections.synchronizedMap(new WeakHashMap());
d384 1
a384 1
            context = (AppContext)appContextMap.get(target);
d429 1
a429 1
            Class layoutPolicyClass =
d431 1
a431 1
            policy = (FocusTraversalPolicy) layoutPolicyClass.newInstance();
d490 4
a513 3
    protected static final Lock flushLock = new ReentrantLock();
    private static boolean isFlushingPendingEvents = false;

d523 6
a528 24
    public static void flushPendingEvents(AppContext appContext)  {
        flushLock.lock();
        try {
            // Don't call flushPendingEvents() recursively
            if (!isFlushingPendingEvents) {
                isFlushingPendingEvents = true;
                try {
                    PostEventQueue postEventQueue =
                        (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);
                    if (postEventQueue != null) {
                        postEventQueue.flush();
                    }
                }
                finally {
                    isFlushingPendingEvents = false;
                }
            }
        } finally {
            flushLock.unlock();
        }
    }

    public static boolean isPostEventQueueEmpty()  {
        AppContext appContext = AppContext.getAppContext();
d530 1
a530 1
            (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);
d532 1
a532 3
            return postEventQueue.noEvents();
        } else {
            return true;
d550 1
d554 3
a556 2
        executeOnEventHandlerThread(new PeerEvent(target, runnable, PeerEvent.PRIORITY_EVENT){
                public long getWhen(){
d637 6
d707 114
d1056 14
d1085 1
a1085 1
            language = (String) AccessController.doPrivileged(
d1088 1
a1088 1
            region = (String) AccessController.doPrivileged(
d1101 1
a1101 1
                country = (String) AccessController.doPrivileged(
d1103 1
a1103 1
                variant = (String) AccessController.doPrivileged(
d1175 1
a1175 1
        String noxembed = (String) AccessController.
d1387 1
d1395 2
d1400 1
d1545 1
d1729 1
a1729 1
                    (String)AccessController.doPrivileged(
d1918 1
a1918 1
        return w != null && ((Window)w).getOpacity() < 1.0f;
d1960 1
a1960 1
    private static boolean isInstanceOf(Class cls, String type) {
d1967 1
a1967 1
        for (Class c : cls.getInterfaces()) {
d2010 1
a2010 2
    // For the case when queue is cleared but events are not posted
    private volatile boolean isFlushing = false;
a2015 4
    public synchronized boolean noEvents() {
        return queueHead == null && !isFlushing;
    }

d2026 3
a2028 6
        EventQueueItem tempQueue;
        synchronized (this) {
            tempQueue = queueHead;
            queueHead = queueTail = null;
            isFlushing = (tempQueue != null);
        }
d2030 33
a2062 3
            while (tempQueue != null) {
                eventQueue.postEvent(tempQueue.event);
                tempQueue = tempQueue.next;
d2065 3
a2067 2
        finally {
            isFlushing = false;
@


1.22
log
@Partial 7u40 merge.
@
text
@a53 3
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
a55 3
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
a69 1
    private static Method  wakeupMethod;
d198 1
a198 1
    public abstract KeyboardFocusManagerPeer createKeyboardFocusManagerPeer(KeyboardFocusManager manager)
a291 18
    public static Field getField(final Class klass, final String fieldName) {
        return AccessController.doPrivileged(new PrivilegedAction<Field>() {
            public Field run() {
                try {
                    Field field = klass.getDeclaredField(fieldName);
                    assert (field != null);
                    field.setAccessible(true);
                    return field;
                } catch (SecurityException e) {
                    assert false;
                } catch (NoSuchFieldException e) {
                    assert false;
                }
                return null;
            }//run
        });
    }

d293 1
a293 27
        if (wakeupMethod == null){
            wakeupMethod = (Method)AccessController.doPrivileged(new PrivilegedAction(){
                    public Object run(){
                        try {
                            Method method  = EventQueue.class.getDeclaredMethod("wakeup",new Class [] {Boolean.TYPE} );
                            if (method != null) {
                                method.setAccessible(true);
                            }
                            return method;
                        } catch (NoSuchMethodException e) {
                            assert false;
                        } catch (SecurityException e) {
                            assert false;
                        }
                        return null;
                    }//run
                });
        }
        try{
            if (wakeupMethod != null){
                wakeupMethod.invoke(q, new Object[]{Boolean.valueOf(isShutdown)});
            }
        } catch (InvocationTargetException e){
            assert false;
        } catch (IllegalAccessException e) {
            assert false;
        }
d467 13
a1265 16
    public static Method getMethod(final Class clz, final String methodName, final Class[] params) {
        Method res = null;
        try {
            res = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {
                    public Method run() throws Exception {
                        Method m = clz.getDeclaredMethod(methodName, params);
                        m.setAccessible(true);
                        return m;
                    }
                });
        } catch (PrivilegedActionException ex) {
            ex.printStackTrace();
        }
        return res;
    }

a1407 2
    static Method eqNoEvents;

d1410 1
a1410 11
        synchronized(SunToolkit.class) {
            if (eqNoEvents == null) {
                eqNoEvents = getMethod(java.awt.EventQueue.class, "noEvents", null);
            }
        }
        try {
            return (Boolean)eqNoEvents.invoke(queue);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
a1664 1
    private static Method consumeNextKeyTypedMethod = null;
a1665 5
        if (consumeNextKeyTypedMethod == null) {
            consumeNextKeyTypedMethod = getMethod(DefaultKeyboardFocusManager.class,
                                                  "consumeNextKeyTyped",
                                                  new Class[] {KeyEvent.class});
        }
d1667 6
a1672 6
            consumeNextKeyTypedMethod.invoke(KeyboardFocusManager.getCurrentKeyboardFocusManager(),
                                             keyEvent);
        } catch (IllegalAccessException iae) {
            iae.printStackTrace();
        } catch (InvocationTargetException ite) {
            ite.printStackTrace();
@


1.21
log
@Merged 7u40 AppContext and TimeZone decoupling mechanism.
@
text
@d67 1
a67 1
    private static final PlatformLogger log = PlatformLogger.getLogger("sun.awt.SunToolkit");
d100 8
a523 4
        AppContext eventContext = targetToAppContext(event.getSource());
        if (eventContext != null && !eventContext.equals(appContext)) {
            log.fine("Event posted on wrong app context : " + event);
        }
d552 5
d562 9
a570 5
                AppContext appContext = AppContext.getAppContext();
                PostEventQueue postEventQueue =
                    (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);
                if (postEventQueue != null) {
                    postEventQueue.flush();
a573 1
            isFlushingPendingEvents = false;
a813 4
                if (log.isLoggable(PlatformLogger.FINER)) {
                    log.finer("SunToolkit.getScaledIconImage: " +
                              "Skipping the image passed into Java because it's null.");
                }
a825 4
                if (log.isLoggable(PlatformLogger.FINER)) {
                    log.finer("SunToolkit.getScaledIconImage: " +
                              "Perhaps the image passed into Java is broken. Skipping this icon.");
                }
a896 8
            if (log.isLoggable(PlatformLogger.FINER)) {
                log.finer("WWindowPeer.getScaledIconData() result : " +
                        "w : " + width + " h : " + height +
                        " iW : " + bestImage.getWidth(null) + " iH : " + bestImage.getHeight(null) +
                        " sim : " + bestSimilarity + " sf : " + bestScaleFactor +
                        " adjW : " + bestWidth + " adjH : " + bestHeight +
                        " x : " + x + " y : " + y);
            }
a906 4
             if (log.isLoggable(PlatformLogger.FINER)) {
                 log.finer("SunToolkit.getScaledIconData: " +
                           "Perhaps the image passed into Java is broken. Skipping this icon.");
             }
a1763 19
    /**
     * Returns the value of the system property indicated by the specified key.
     */
    public static String getSystemProperty(final String key) {
        return (String)AccessController.doPrivileged(new PrivilegedAction() {
                public Object run() {
                    return System.getProperty(key);
                }
            });
    }

    /**
     * Returns the boolean value of the system property indicated by the specified key.
     */
    protected static Boolean getBooleanSystemProperty(String key) {
        return Boolean.valueOf(AccessController.
                   doPrivileged(new GetBooleanAction(key)));
    }

d1772 2
a1773 1
            sunAwtDisableMixing = getBooleanSystemProperty("sun.awt.disableMixing");
d1787 22
d1829 7
d1956 3
d1964 1
a1964 1
        return queueHead == null;
d1971 4
d1976 15
a1990 6
    public synchronized void flush() {
        EventQueueItem tempQueue = queueHead;
        queueHead = queueTail = null;
        while (tempQueue != null) {
            eventQueue.postEvent(tempQueue.event);
            tempQueue = tempQueue.next;
@


1.20
log
@Integrated OpenJDK 7u4. Not all forked files have been merged yet, just the ones necessary to get things building.
@
text
@a119 2
        // 7122796: Always create an EQ for the main AppContext
        initEQ(AppContext.getMainAppContext());
d278 4
a285 1

@


1.19
log
@Complete migration to OpenJDK 7. Thanks to Volker Berlin for the bulk of this patch.
@
text
@d2 1
a2 1
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
a34 1
import java.awt.im.spi.InputMethodDescriptor;
d36 3
a38 2
import java.awt.geom.AffineTransform;
import java.io.*;
a39 1
import java.net.JarURLConnection;
d43 1
d45 3
a47 2
import java.util.logging.Level;
import java.util.logging.Logger;
d49 2
a53 2
import sun.util.logging.PlatformLogger;

a62 1

d65 1
a65 3
    ComponentFactory, InputMethodSupport {

    private static final Logger log = Logger.getLogger("sun.awt.SunToolkit");
d67 1
a67 7
    /* Load debug settings for native code */
//    static {
//        String nativeDebug = System.getProperty("sun.awt.nativedebug");
//        if ("true".equalsIgnoreCase(nativeDebug)) {
//            DebugSettings.init();
//        }
//    };
a75 1
    private static Field syncLWRequestsField;
a76 6
    private static Field componentKeyField;
    private static Field menuComponentKeyField;
    private static Field trayIconKeyField;
    private static Field componentAppContextField;
    private static Field menuComponentAppContextField;
    private static Field isPostedField;
d81 7
a87 10
    public SunToolkit() {
        /* If awt.threadgroup is set to class name the instance of
         * this class is created (should be subclass of ThreadGroup)
         * and EventDispatchThread is created inside of it
         *
         * If loaded class overrides uncaughtException instance
         * handles all uncaught exception on EventDispatchThread
         */
        ThreadGroup threadGroup = null;
        String tgName = System.getProperty("awt.threadgroup", "");
d89 10
a98 9
        if (tgName.length() != 0) {
            try {
                Constructor ctor = Class.forName(tgName).
                    getConstructor(new Class[] {String.class});
                threadGroup = (ThreadGroup)ctor.newInstance(new Object[] {"AWT-ThreadGroup"});
            } catch (Exception e) {
                System.err.println("Failed loading " + tgName + ": " + e);
            }
        }
d100 2
a101 3
        Runnable initEQ = new Runnable() {
            public void run () {
                EventQueue eventQueue;
d103 2
a104 2
                String eqName = System.getProperty("AWT.EventQueueClass",
                                                   "java.awt.EventQueue");
d106 8
a113 9
                try {
                    eventQueue = (EventQueue)Class.forName(eqName).newInstance();
                } catch (Exception e) {
                    e.printStackTrace();
                    System.err.println("Failed loading " + eqName + ": " + e);
                    eventQueue = new EventQueue();
                }
                AppContext appContext = AppContext.getAppContext();
                appContext.put(AppContext.EVENT_QUEUE_KEY, eventQueue);
d115 3
a117 4
                PostEventQueue postEventQueue = new PostEventQueue(eventQueue);
                appContext.put(POST_EVENT_QUEUE_KEY, postEventQueue);
            }
        };
d119 3
a121 11
        if (threadGroup != null) {
            Thread eqInitThread = new Thread(threadGroup, initEQ, "EventQueue-Init");
            eqInitThread.start();
            try {
                eqInitThread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } else {
            initEQ.run();
        }
d199 3
a201 2
    public abstract KeyboardFocusManagerPeer createKeyboardFocusManagerPeer(KeyboardFocusManager manager) throws HeadlessException;
    
d280 3
a282 9
        EventQueue eventQueue;
        String eqName = System.getProperty("AWT.EventQueueClass",
                                           "java.awt.EventQueue");
        try {
            eventQueue = (EventQueue)Class.forName(eqName).newInstance();
        } catch (Exception e) {
            System.err.println("Failed loading " + eqName + ": " + e);
            eventQueue = new EventQueue();
        }
a283 1
        appContext.put(AppContext.EVENT_QUEUE_KEY, eventQueue);
d285 1
a285 2
        PostEventQueue postEventQueue = new PostEventQueue(eventQueue);
        appContext.put(POST_EVENT_QUEUE_KEY, postEventQueue);
a373 1

d378 9
a386 3
    private static boolean setAppContext(Object target, AppContext context)
    {
        if (!(target instanceof Component) && !(target instanceof MenuComponent)) {
a388 16
        try{
            if (target instanceof Component){
                if (componentAppContextField == null) {
                    componentAppContextField = getField(Component.class, "appContext");
                }
                componentAppContextField.set(target, context);
            } else if (target instanceof MenuComponent) {
                if (menuComponentAppContextField == null) {
                    menuComponentAppContextField = getField(MenuComponent.class, "appContext");
                }
                menuComponentAppContextField.set(target, context);
            }
        } catch( IllegalAccessException e){
            assert false;
        }

d397 8
a404 15
        AppContext retObj = null;
        try{
            if (target instanceof Component){
                if (componentAppContextField == null) {
                    componentAppContextField = getField(Component.class, "appContext");
                }
                retObj = (AppContext) componentAppContextField.get(target);
            } else if (target instanceof MenuComponent) {
                if (menuComponentAppContextField == null) {
                    menuComponentAppContextField = getField(MenuComponent.class, "appContext");
                }
                retObj = (AppContext) menuComponentAppContextField.get(target);
            }
        } catch( IllegalAccessException e){
            assert false;
a405 1
        return retObj;
d425 1
a425 1
    }    
d453 1
a453 10
        if (syncLWRequestsField == null){
            syncLWRequestsField = getField(Window.class, "syncLWRequests");
        }
        try{
            if (syncLWRequestsField != null){
                syncLWRequestsField.setBoolean(changed, status);
            }
        } catch( IllegalAccessException e){
            assert false;
        }
d456 4
a459 4
    public static void checkAndSetPolicy(Container cont, boolean isSwingCont)
    {
        FocusTraversalPolicy defaultPolicy = KeyboardFocusManager
            .getCurrentKeyboardFocusManager().getDefaultFocusTraversalPolicy();
a460 37
        String toolkitName = Toolkit.getDefaultToolkit().getClass().getName();
        // if this is not XAWT then use default policy
        // because Swing change it
        if (!"sun.awt.X11.XToolkit".equals(toolkitName)) {
            cont.setFocusTraversalPolicy(defaultPolicy);
            return;
        }

        String policyName = defaultPolicy.getClass().getName();

        if (DefaultFocusTraversalPolicy.class != defaultPolicy.getClass()) {
            // Policy was changed
            // Check if it is awt policy or swing policy
            // If it is Swing policy we shouldn't use it in AWT frames
            // If it is AWT policy  we shouldn't use it in Swing frames
            // Otherwise we should use this policy
            if (policyName.startsWith("java.awt.")) {
                // AWT
                if (isSwingCont) {
                    // Can't use AWT policy in Swing windows - should use Swing's one.
                    defaultPolicy = createLayoutPolicy();
                } else {
                    // New awt policy.
                }
            } else if (policyName.startsWith("javax.swing.")) {
                if (isSwingCont) {
                    // New Swing's policy
                } else {
                    defaultPolicy = new DefaultFocusTraversalPolicy();
                }
            }
        } else {
            // Policy is default, use different default policy for swing
            if (isSwingCont) {
                defaultPolicy = createLayoutPolicy();
            }
        }
d509 6
d521 1
a521 1
        if(postEventQueue != null) {
a529 3
        if (isPostedField == null) {
            isPostedField = getField(AWTEvent.class, "isPosted");
        }
d532 1
a532 7
                    try {
                        isPostedField.setBoolean(e, true);
                    } catch (IllegalArgumentException e) {
                        assert(false);
                    } catch (IllegalAccessException e) {
                        assert(false);
                    }
d539 3
d547 15
a561 5
        AppContext appContext = AppContext.getAppContext();
        PostEventQueue postEventQueue =
            (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);
        if(postEventQueue != null) {
            postEventQueue.flush();
d644 3
a646 1
            lock.wait();
a655 30
     * Returns next queue for the given EventQueue which has private access
     */
    private static EventQueue getNextQueue(final Object o) {
        EventQueue result = null;
        try{
            Field nextQueueField = getField(EventQueue.class,
                                            "nextQueue");
            result = (EventQueue)nextQueueField.get(o);
        } catch( IllegalAccessException e){
            assert false;
        }
        return result;
    }

    /*
     * Returns dispatch thread for the given EventQueue which has private access
     */
    private static Thread getDispatchThread(final Object o) {
        Thread result = null;
        try{
            Field dispatchThreadField = getField(EventQueue.class,
                                                 "dispatchThread");
            result = (Thread)dispatchThreadField.get(o);
        } catch( IllegalAccessException e){
            assert false;
        }
        return result;
    }

    /*
d665 2
a666 7
        EventQueue next = getNextQueue(eq);
        while (next != null) {
            eq = next;
            next = getNextQueue(eq);
        }

        return (Thread.currentThread() == getDispatchThread(eq));
d675 11
a685 15
//    public FontMetrics getFontMetrics(Font font) {
//        return FontDesignMetrics.getMetrics(font);
//    }
//
//    public String[] getFontList() {
//        String[] hardwiredFontList = {
//            Font.DIALOG, Font.SANS_SERIF, Font.SERIF, Font.MONOSPACED,
//            Font.DIALOG_INPUT
//
//            // -- Obsolete font names from 1.0.2.  It was decided that
//            // -- getFontList should not return these old names:
//            //    "Helvetica", "TimesRoman", "Courier", "ZapfDingbats"
//        };
//        return hardwiredFontList;
//    }
d696 5
a700 5
     * Disables erasing of background on the canvas before painting
     * if this is supported by the current toolkit.
     *
     * @@throws IllegalStateException if the canvas is not displayable
     * @@see java.awt.Component#isDisplayable
d703 18
a720 3
        if (!canvas.isDisplayable()) {
            throw new IllegalStateException("Canvas must have a valid peer");
        }
a738 117
    /**
     * Makes the window OverrideRedirect, on X11 platforms. See
     * ICCCM specification for more details about OverrideRedirect
     * windows. Implemented in XToolkit, no-op in WToolkit.
     */
    public void setOverrideRedirect(Window target) {
    }

//    static SoftCache imgCache = new SoftCache();
//
//    static synchronized Image getImageFromHash(Toolkit tk, URL url) {
//        SecurityManager sm = System.getSecurityManager();
//        if (sm != null) {
//            try {
//                java.security.Permission perm =
//                    url.openConnection().getPermission();
//                if (perm != null) {
//                    try {
//                        sm.checkPermission(perm);
//                    } catch (SecurityException se) {
//                        // fallback to checkRead/checkConnect for pre 1.2
//                        // security managers
//                        if ((perm instanceof java.io.FilePermission) &&
//                            perm.getActions().indexOf("read") != -1) {
//                            sm.checkRead(perm.getName());
//                        } else if ((perm instanceof
//                            java.net.SocketPermission) &&
//                            perm.getActions().indexOf("connect") != -1) {
//                            sm.checkConnect(url.getHost(), url.getPort());
//                        } else {
//                            throw se;
//                        }
//                    }
//                }
//            } catch (java.io.IOException ioe) {
//                    sm.checkConnect(url.getHost(), url.getPort());
//            }
//        }
//        Image img = (Image)imgCache.get(url);
//        if (img == null) {
//            try {
//                img = tk.createImage(new URLImageSource(url));
//                imgCache.put(url, img);
//            } catch (Exception e) {
//            }
//        }
//        return img;
//    }

//    static synchronized Image getImageFromHash(Toolkit tk,
//                                               String filename) {
//        SecurityManager security = System.getSecurityManager();
//        if (security != null) {
//            security.checkRead(filename);
//        }
//        Image img = (Image)imgCache.get(filename);
//        if (img == null) {
//            try {
//                img = tk.createImage(new FileImageSource(filename));
//                imgCache.put(filename, img);
//            } catch (Exception e) {
//            }
//        }
//        return img;
//    }
//
//    public Image getImage(String filename) {
//        return getImageFromHash(this, filename);
//    }
//
//    public Image getImage(URL url) {
//        return getImageFromHash(this, url);
//    }
//
//    public Image createImage(String filename) {
//        SecurityManager security = System.getSecurityManager();
//        if (security != null) {
//            security.checkRead(filename);
//        }
//        return createImage(new FileImageSource(filename));
//    }
//
//    public Image createImage(URL url) {
//        SecurityManager sm = System.getSecurityManager();
//        if (sm != null) {
//            try {
//                java.security.Permission perm =
//                    url.openConnection().getPermission();
//                if (perm != null) {
//                    try {
//                        sm.checkPermission(perm);
//                    } catch (SecurityException se) {
//                        // fallback to checkRead/checkConnect for pre 1.2
//                        // security managers
//                        if ((perm instanceof java.io.FilePermission) &&
//                            perm.getActions().indexOf("read") != -1) {
//                            sm.checkRead(perm.getName());
//                        } else if ((perm instanceof
//                            java.net.SocketPermission) &&
//                            perm.getActions().indexOf("connect") != -1) {
//                            sm.checkConnect(url.getHost(), url.getPort());
//                        } else {
//                            throw se;
//                        }
//                    }
//                }
//            } catch (java.io.IOException ioe) {
//                    sm.checkConnect(url.getHost(), url.getPort());
//            }
//        }
//        return createImage(new URLImageSource(url));
//    }
//
//    public Image createImage(byte[] data, int offset, int length) {
//        return createImage(new ByteArrayImageSource(data, offset, length));
//    }

d801 3
a803 3
                if (log.isLoggable(Level.FINER)) {
                    log.log(Level.FINER, "SunToolkit.getScaledIconImage: " +
                            "Skipping the image passed into Java because it's null.");
d817 3
a819 3
                if (log.isLoggable(Level.FINER)) {
                    log.log(Level.FINER, "SunToolkit.getScaledIconImage: " +
                            "Perhaps the image passed into Java is broken. Skipping this icon.");
d892 2
a893 2
            if (log.isLoggable(Level.FINER)) {
                log.log(Level.FINER, "WWindowPeer.getScaledIconData() result : " +
d910 3
a912 3
             if (log.isLoggable(Level.FINER)) {
                 log.log(Level.FINER, "SunToolkit.getScaledIconData: " +
                         "Perhaps the image passed into Java is broken. Skipping this icon.");
d945 47
a991 12
     * Returns a new input method window, with behavior as specified in
     * {@@link java.awt.im.spi.InputMethodContext#createInputMethodWindow}.
     * If the inputContext is not null, the window should return it from its
     * getInputContext() method. The window needs to implement
     * sun.awt.im.InputMethodWindow.
     * <p>
     * SunToolkit subclasses can override this method to return better input
     * method windows.
     */
//    public Window createInputMethodWindow(String title, InputContext context) {
//        return new sun.awt.im.SimpleInputMethodWindow(title, context);
//    }
d1048 1
a1048 2
    public static String getDataTransfererClassName()
    {
a1090 8
//    private static DefaultMouseInfoPeer mPeer = null;
//
//    protected synchronized MouseInfoPeer getMouseInfoPeer() {
//        if (mPeer == null) {
//            mPeer = new DefaultMouseInfoPeer();
//        }
//        return mPeer;
//    }
d1125 1
a1125 16
    private static Dialog.ModalExclusionType DEFAULT_MODAL_EXCLUSION_TYPE;

    static {
        DEFAULT_MODAL_EXCLUSION_TYPE = (Dialog.ModalExclusionType)AccessController.doPrivileged(new PrivilegedAction() {
            public Object run() {
                Dialog.ModalExclusionType defaultType = Dialog.ModalExclusionType.NO_EXCLUDE;
                try {
                    java.lang.reflect.Field f = Dialog.class.getDeclaredField("DEFAULT_MODAL_EXCLUSION_TYPE");
                    f.setAccessible(true);
                    defaultType = (Dialog.ModalExclusionType)f.get(null);
                } catch (Exception e) {
                }
                return defaultType;
            }
        });
    }
d1184 3
d1208 3
a1810 1
    
a1829 1
    
d1848 16
d1916 1
a1916 1
    
d1956 1
a1956 1
    public boolean noEvents() {
d1961 10
a1970 22
     * Continually post pending AWTEvents to the Java EventQueue.
     */
    public void flush() {
        if (queueHead != null) {
            EventQueueItem tempQueue;
            /*
             * We have to execute the loop inside the synchronized block
             * to ensure that the flush is completed before a new event
             * can be posted to this queue.
             */
            synchronized (this) {
                tempQueue = queueHead;
                queueHead = queueTail = null;
                /*
                 * If this PostEventQueue is flushed in parallel on two
                 * different threads tempQueue will be null for one of them.
                 */
                while (tempQueue != null) {
                    eventQueue.postEvent(tempQueue.event);
                    tempQueue = tempQueue.next;
                }
            }
@


1.18
log
@Add methods set/isSystemGenerated in SunToolkit for Java 7
@
text
@d51 2
d227 2
a228 5
    public KeyboardFocusManagerPeer createKeyboardFocusManagerPeer(KeyboardFocusManager manager) throws HeadlessException {
        KeyboardFocusManagerPeerImpl peer = new KeyboardFocusManagerPeerImpl(manager);
        return peer;
    }

d1967 1
a1967 1
    protected static void dumpPeers(final Logger aLog) {
@


1.17
log
@move EventQueueItem in a separate file for JDK7
@
text
@d2115 19
@


1.16
log
@More JDK7 methods in SunToolkit
@
text
@a2182 9

class EventQueueItem {
    AWTEvent event;
    EventQueueItem next;

    EventQueueItem(AWTEvent evt) {
        event = evt;
    }
} // class EventQueueItem
@


1.15
log
@Add methods getNumberOfButtons() and instanceof() for JDK7
@
text
@d1973 44
d2025 48
@


1.14
log
@Integrated OpenJDK 6 b21.
@
text
@d1980 43
@


1.13
log
@Removed unused imports of sun.reflect.generics.reflectiveObjects.NotImplementedException.
@
text
@d2 1
a2 1
 * Copyright 1997-2008 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.12
log
@* Added Image Content Handler in package sun.net.www.content.image
* Replace NetProducerImage with the original ToolkitImage and ImageRepresentation. Now this image work correctly with the MediaTracker together.
* remove some methods Image methods from NetToolkit and use the original of SunToolkit
@
text
@a48 1
import sun.reflect.generics.reflectiveObjects.NotImplementedException;
@


1.11
log
@Integrated OpenJDK 6 b18.
@
text
@d969 41
a1009 41
//
//    public Image createImage(ImageProducer producer) {
//        return new ToolkitImage(producer);
//    }
//
//    public int checkImage(Image img, int w, int h, ImageObserver o) {
//        if (!(img instanceof ToolkitImage)) {
//            return ImageObserver.ALLBITS;
//        }
//
//        ToolkitImage tkimg = (ToolkitImage)img;
//        int repbits;
//        if (w == 0 || h == 0) {
//            repbits = ImageObserver.ALLBITS;
//        } else {
//            repbits = tkimg.getImageRep().check(o);
//        }
//        return tkimg.check(o) | repbits;
//    }
//
//    public boolean prepareImage(Image img, int w, int h, ImageObserver o) {
//        if (w == 0 || h == 0) {
//            return true;
//        }
//
//        // Must be a ToolkitImage
//        if (!(img instanceof ToolkitImage)) {
//            return true;
//        }
//
//        ToolkitImage tkimg = (ToolkitImage)img;
//        if (tkimg.hasError()) {
//            if (o != null) {
//                o.imageUpdate(img, ImageObserver.ERROR|ImageObserver.ABORT,
//                              -1, -1, -1, -1);
//            }
//            return false;
//        }
//        ImageRepresentation ir = tkimg.getImageRep();
//        return ir.prepare(o);
//    }
@


1.10
log
@add primitive support for clipboard and drag and drop
@
text
@d2 1
a2 1
 * Copyright 1997-2007 Sun Microsystems, Inc.  All Rights Reserved.
d853 8
@


1.9
log
@closeSplashScreen changed
@
text
@d1238 4
a1241 1
    return "sun.awt.IkvmDataTransferer";
@


1.8
log
@Removed workaround that is no longer needed, now that ikvmc automatically works around this issue.
@
text
@d1776 1
a1776 3
    public static void closeSplashScreen(){
        throw new NotImplementedException();
    }
@


1.7
log
@extends the NetToolkit from the SunToolkit instead of GNU ClasspathToolkit
@
text
@d62 1
a62 1
public abstract class SunToolkit extends AbstractDummyToolkit
@


1.6
log
@Replace the AWT / Swing implementation from GNU with Sun
@
text
@d62 1
a62 1
public abstract class SunToolkit extends Toolkit
@


1.5
log
@More Sun classes (package sun.awt)
@
text
@d49 1
d214 4
a217 4
//    public abstract TrayIconPeer createTrayIcon(TrayIcon target)
//        throws HeadlessException, AWTException;
//
//    public abstract SystemTrayPeer createSystemTray(SystemTray target);
d226 4
a229 4
//    public KeyboardFocusManagerPeer createKeyboardFocusManagerPeer(KeyboardFocusManager manager) throws HeadlessException {
//        KeyboardFocusManagerPeerImpl peer = new KeyboardFocusManagerPeerImpl(manager);
//        return peer;
//    }
d1319 16
a1334 16
//    private static Dialog.ModalExclusionType DEFAULT_MODAL_EXCLUSION_TYPE;
//
//    static {
//        DEFAULT_MODAL_EXCLUSION_TYPE = (Dialog.ModalExclusionType)AccessController.doPrivileged(new PrivilegedAction() {
//            public Object run() {
//                Dialog.ModalExclusionType defaultType = Dialog.ModalExclusionType.NO_EXCLUDE;
//                try {
//                    java.lang.reflect.Field f = Dialog.class.getDeclaredField("DEFAULT_MODAL_EXCLUSION_TYPE");
//                    f.setAccessible(true);
//                    defaultType = (Dialog.ModalExclusionType)f.get(null);
//                } catch (Exception e) {
//                }
//                return defaultType;
//            }
//        });
//    }
d1357 5
a1361 5
//    public static boolean isModalExcludedSupported()
//    {
//        Toolkit tk = Toolkit.getDefaultToolkit();
//        return tk.isModalExclusionTypeSupported(DEFAULT_MODAL_EXCLUSION_TYPE);
//    }
d1391 4
a1394 4
//    public static void setModalExcluded(Window window)
//    {
//        window.setModalExclusionType(DEFAULT_MODAL_EXCLUSION_TYPE);
//    }
d1412 4
a1415 4
//    public static boolean isModalExcluded(Window window)
//    {
//        return window.getModalExclusionType().compareTo(DEFAULT_MODAL_EXCLUSION_TYPE) >= 0;
//    }
d1420 4
a1423 4
//    public boolean isModalityTypeSupported(Dialog.ModalityType modalityType) {
//        return (modalityType == Dialog.ModalityType.MODELESS) ||
//               (modalityType == Dialog.ModalityType.APPLICATION_MODAL);
//    }
d1428 3
a1430 3
//    public boolean isModalExclusionTypeSupported(Dialog.ModalExclusionType exclusionType) {
//        return (exclusionType == Dialog.ModalExclusionType.NO_EXCLUDE);
//    }
d1776 3
a1778 1
//    public static native void closeSplashScreen();
@


1.4
log
@Added flavormap.properties and content-types.properties and added some hacks to make DataTransferer "work".
@
text
@d2 23
a24 1
  Copyright (C) 2009 Jeroen Frijters
d26 198
a223 15
  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
d225 4
a228 2
  Jeroen Frijters
  jeroen@@frijters.net 
d230 31
a260 1
*/
d262 14
a275 1
package sun.awt;
d277 5
a281 2
import java.awt.AWTEvent;
import java.awt.GraphicsEnvironment;
d283 2
a284 3
public class SunToolkit
{
    public static AppContext targetToAppContext(Object target)
d286 106
a391 1
	if (target == null || GraphicsEnvironment.isHeadless())
d393 744
a1136 1
	    return null;
d1138 48
a1185 2
	// we only support a single AppContext
	return AppContext.getAppContext();
d1187 48
a1234 1
    
d1237 1
a1237 1
	return "sun.awt.IkvmDataTransferer";
d1239 131
a1369 2
    
    public static void executeOnEventHandlerThread(Object target, Runnable runnable)
d1371 174
a1544 1
        throw new Error("Not implemented");
d1546 59
a1604 2
    
    public static void postEvent(AppContext appContext, AWTEvent event)
d1606 49
a1654 1
        throw new Error("Not implemented");
d1656 388
a2043 4
    
    public static void invokeLaterOnAppContext(AppContext appContext, Runnable dispatcher)
    {
        throw new Error("Not implemented");
d2045 1
a2045 1
}
@


1.3
log
@Switched java.awt.dnd package from GNU Classpath to OpenJDK.
@
text
@d44 1
a44 1
        throw new Error("Not implemented");
@


1.2
log
@Switched java.awt.datatransfer package from GNU Classpath to OpenJDK.
@
text
@d56 5
@


1.1
log
@Switched java.awt.event package from GNU Classpath to OpenJDK.
@
text
@d27 1
d41 15
@

