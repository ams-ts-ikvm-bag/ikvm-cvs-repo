head	1.10;
access;
symbols
	v7_3:1.8.0.6
	v7_2_4630_6:1.8
	v7_2_4630_5:1.8
	v7_2_4630_4:1.8
	v7_2_4630_3:1.8
	v7_2_4630_2:1.8
	v0_46_0_4:1.5
	v7_2_4630_1:1.8
	v7_2:1.8.0.4
	v7_1_4532_2:1.8
	v7_1_4532_1:1.8
	v7_1_4532_0:1.8
	v7_1:1.8.0.2
	v7_0_4335_3:1.7
	v7_0_4335_2:1.7
	v7_0_4335_1:1.7
	v0_46_0_2:1.5
	v7_0_4335_0:1.7
	v7_0:1.7.0.2
	v0_40_0_6:1.3
	v0_40_0_5:1.3
	v0_46_0_1:1.5
	v0_46_0_0:1.5
	v0_46:1.5.0.2
	v0_36_0_14:1.1
	v0_44_0_6:1.4
	v0_44_0_5:1.4
	v0_44_0_4:1.4
	v0_44_0_3:1.4
	v0_44_0_2:1.4
	v0_42_0_7:1.4
	v0_44_0_1:1.4
	v0_44_0_0:1.4
	v0_44:1.4.0.4
	v0_42_0_6:1.4
	v0_42_0_5:1.4
	v0_42_0_4:1.4
	v0_42_0_3:1.4
	v0_42_0_2:1.4
	v0_42_0_1:1.4
	v0_42_0_0:1.4
	v0_42:1.4.0.2
	v0_40_0_3:1.3
	v0_40_0_2:1.3
	v0_40_0_1:1.3
	v0_40_0_0:1.3
	v0_40:1.3.0.2
	v0_36_0_13:1.1
	v0_38_0_1:1.1
	v0_38_0_0:1.1
	v0_38:1.1.0.4
	v0_36_0_9:1.1
	v0_36_0_7:1.1
	v0_36_0_5:1.1
	v0_36_0_4:1.1
	v0_36_0_3:1.1
	v0_36_0_2:1.1
	v0_36_0_1:1.1
	v0_36_0_0:1.1
	v0_36:1.1.0.2;
locks; strict;
comment	@# @;


1.10
date	2014.02.07.14.14.12;	author jfrijters;	state dead;
branches;
next	1.9;

1.9
date	2013.08.15.10.09.09;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.23.10.00.03;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.17.14.00.16;	author smallsql;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.26.18.16.44;	author smallsql;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.24.16.40.23;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.22.16.27.56;	author smallsql;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.04.09.21.42;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.04.08.18.37;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.31.06.14.32;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Merged OpenJDK 7u40 b34, except for java.lang.invoke and sun.invoke packages.
@
text
@/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt;

import java.awt.EventQueue;
import java.awt.Window;
import java.awt.SystemTray;
import java.awt.TrayIcon;
import java.awt.Toolkit;
import java.awt.GraphicsEnvironment;
import java.awt.event.InvocationEvent;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Collections;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyChangeListener;
import sun.util.logging.PlatformLogger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * The AppContext is a table referenced by ThreadGroup which stores
 * application service instances.  (If you are not writing an application
 * service, or don't know what one is, please do not use this class.)
 * The AppContext allows applet access to what would otherwise be
 * potentially dangerous services, such as the ability to peek at
 * EventQueues or change the look-and-feel of a Swing application.<p>
 *
 * Most application services use a singleton object to provide their
 * services, either as a default (such as getSystemEventQueue or
 * getDefaultToolkit) or as static methods with class data (System).
 * The AppContext works with the former method by extending the concept
 * of "default" to be ThreadGroup-specific.  Application services
 * lookup their singleton in the AppContext.<p>
 *
 * For example, here we have a Foo service, with its pre-AppContext
 * code:<p>
 * <code><pre>
 *    public class Foo {
 *        private static Foo defaultFoo = new Foo();
 *
 *        public static Foo getDefaultFoo() {
 *            return defaultFoo;
 *        }
 *
 *    ... Foo service methods
 *    }</pre></code><p>
 *
 * The problem with the above is that the Foo service is global in scope,
 * so that applets and other untrusted code can execute methods on the
 * single, shared Foo instance.  The Foo service therefore either needs
 * to block its use by untrusted code using a SecurityManager test, or
 * restrict its capabilities so that it doesn't matter if untrusted code
 * executes it.<p>
 *
 * Here's the Foo class written to use the AppContext:<p>
 * <code><pre>
 *    public class Foo {
 *        public static Foo getDefaultFoo() {
 *            Foo foo = (Foo)AppContext.getAppContext().get(Foo.class);
 *            if (foo == null) {
 *                foo = new Foo();
 *                getAppContext().put(Foo.class, foo);
 *            }
 *            return foo;
 *        }
 *
 *    ... Foo service methods
 *    }</pre></code><p>
 *
 * Since a separate AppContext can exist for each ThreadGroup, trusted
 * and untrusted code have access to different Foo instances.  This allows
 * untrusted code access to "system-wide" services -- the service remains
 * within the AppContext "sandbox".  For example, say a malicious applet
 * wants to peek all of the key events on the EventQueue to listen for
 * passwords; if separate EventQueues are used for each ThreadGroup
 * using AppContexts, the only key events that applet will be able to
 * listen to are its own.  A more reasonable applet request would be to
 * change the Swing default look-and-feel; with that default stored in
 * an AppContext, the applet's look-and-feel will change without
 * disrupting other applets or potentially the browser itself.<p>
 *
 * Because the AppContext is a facility for safely extending application
 * service support to applets, none of its methods may be blocked by a
 * a SecurityManager check in a valid Java implementation.  Applets may
 * therefore safely invoke any of its methods without worry of being
 * blocked.
 *
 * Note: If a SecurityManager is installed which derives from
 * sun.awt.AWTSecurityManager, it may override the
 * AWTSecurityManager.getAppContext() method to return the proper
 * AppContext based on the execution context, in the case where
 * the default ThreadGroup-based AppContext indexing would return
 * the main "system" AppContext.  For example, in an applet situation,
 * if a system thread calls into an applet, rather than returning the
 * main "system" AppContext (the one corresponding to the system thread),
 * an installed AWTSecurityManager may return the applet's AppContext
 * based on the execution context.
 *
 * @@author  Thomas Ball
 * @@author  Fred Ecks
 */
public final class AppContext {
    private static final PlatformLogger log = PlatformLogger.getLogger("sun.awt.AppContext");

    /* Since the contents of an AppContext are unique to each Java
     * session, this class should never be serialized. */

    /*
     * The key to put()/get() the Java EventQueue into/from the AppContext.
     */
    public static final Object EVENT_QUEUE_KEY = new StringBuffer("EventQueue");

    /*
     * The keys to store EventQueue push/pop lock and condition.
     */
    public final static Object EVENT_QUEUE_LOCK_KEY = new StringBuilder("EventQueue.Lock");
    public final static Object EVENT_QUEUE_COND_KEY = new StringBuilder("EventQueue.Condition");

    /* A map of AppContexts, referenced by ThreadGroup.
     */
    private static final Map<ThreadGroup, AppContext> threadGroup2appContext =
            Collections.synchronizedMap(new IdentityHashMap<ThreadGroup, AppContext>());

    /**
     * Returns a set containing all <code>AppContext</code>s.
     */
    public static Set<AppContext> getAppContexts() {
        synchronized (threadGroup2appContext) {
            return new HashSet<AppContext>(threadGroup2appContext.values());
        }
    }

    /* The main "system" AppContext, used by everything not otherwise
       contained in another AppContext. It is implicitly created for
       standalone apps only (i.e. not applets)
    */
    private static volatile AppContext mainAppContext = null;

    /*
     * The hash map associated with this AppContext.  A private delegate
     * is used instead of subclassing HashMap so as to avoid all of
     * HashMap's potentially risky methods, such as clear(), elements(),
     * putAll(), etc.
     */
    private final HashMap table = new HashMap();

    private final ThreadGroup threadGroup;

    /**
     * If any <code>PropertyChangeListeners</code> have been registered,
     * the <code>changeSupport</code> field describes them.
     *
     * @@see #addPropertyChangeListener
     * @@see #removePropertyChangeListener
     * @@see #firePropertyChange
     */
    private PropertyChangeSupport changeSupport = null;

    public static final String DISPOSED_PROPERTY_NAME = "disposed";
    public static final String GUI_DISPOSED = "guidisposed";

    private enum State {
        VALID,
        BEING_DISPOSED,
        DISPOSED
    };

    private volatile State state = State.VALID;

    public boolean isDisposed() {
        return state == State.DISPOSED;
    }

    /*
     * The total number of AppContexts, system-wide.  This number is
     * incremented at the beginning of the constructor, and decremented
     * at the end of dispose().  getAppContext() checks to see if this
     * number is 1.  If so, it returns the sole AppContext without
     * checking Thread.currentThread().
     */
    private static final AtomicInteger numAppContexts = new AtomicInteger(0);

    /*
     * The context ClassLoader that was used to create this AppContext.
     */
    private final ClassLoader contextClassLoader;

    /**
     * Constructor for AppContext.  This method is <i>not</i> public,
     * nor should it ever be used as such.  The proper way to construct
     * an AppContext is through the use of SunToolkit.createNewAppContext.
     * A ThreadGroup is created for the new AppContext, a Thread is
     * created within that ThreadGroup, and that Thread calls
     * SunToolkit.createNewAppContext before calling anything else.
     * That creates both the new AppContext and its EventQueue.
     *
     * @@param   threadGroup     The ThreadGroup for the new AppContext
     * @@see     sun.awt.SunToolkit
     * @@since   1.2
     */
    AppContext(ThreadGroup threadGroup) {
        numAppContexts.incrementAndGet();

        this.threadGroup = threadGroup;
        threadGroup2appContext.put(threadGroup, this);

        this.contextClassLoader =
             AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
                    public ClassLoader run() {
                        return Thread.currentThread().getContextClassLoader();
                    }
                });

        // Initialize push/pop lock and its condition to be used by all the
        // EventQueues within this AppContext
        Lock eventQueuePushPopLock = new ReentrantLock();
        put(EVENT_QUEUE_LOCK_KEY, eventQueuePushPopLock);
        Condition eventQueuePushPopCond = eventQueuePushPopLock.newCondition();
        put(EVENT_QUEUE_COND_KEY, eventQueuePushPopCond);
    }

    private static final ThreadLocal<AppContext> threadAppContext =
            new ThreadLocal<AppContext>();

    private final static void initMainAppContext() {
        // On the main Thread, we get the ThreadGroup, make a corresponding
        // AppContext, and instantiate the Java EventQueue.  This way, legacy
        // code is unaffected by the move to multiple AppContext ability.
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {
                ThreadGroup currentThreadGroup =
                        Thread.currentThread().getThreadGroup();
                ThreadGroup parentThreadGroup = currentThreadGroup.getParent();
                while (parentThreadGroup != null) {
                    // Find the root ThreadGroup to construct our main AppContext
                    currentThreadGroup = parentThreadGroup;
                    parentThreadGroup = currentThreadGroup.getParent();
                }

                mainAppContext = SunToolkit.createNewAppContext(currentThreadGroup);
                return null;
            }
        });
    }

    /**
     * Returns the appropriate AppContext for the caller,
     * as determined by its ThreadGroup.  If the main "system" AppContext
     * would be returned and there's an AWTSecurityManager installed, it
     * is called to get the proper AppContext based on the execution
     * context.
     *
     * @@return  the AppContext for the caller.
     * @@see     java.lang.ThreadGroup
     * @@since   1.2
     */
    public final static AppContext getAppContext() {
        // we are standalone app, return the main app context
        if (numAppContexts.get() == 1 && mainAppContext != null) {
            return mainAppContext;
        }

        AppContext appContext = threadAppContext.get();

        if (null == appContext) {
            appContext = AccessController.doPrivileged(new PrivilegedAction<AppContext>()
            {
                public AppContext run() {
                    // Get the current ThreadGroup, and look for it and its
                    // parents in the hash from ThreadGroup to AppContext --
                    // it should be found, because we use createNewContext()
                    // when new AppContext objects are created.
                    ThreadGroup currentThreadGroup = Thread.currentThread().getThreadGroup();
                    ThreadGroup threadGroup = currentThreadGroup;

                    // Special case: we implicitly create the main app context
                    // if no contexts have been created yet. This covers standalone apps
                    // and excludes applets because by the time applet starts
                    // a number of contexts have already been created by the plugin.
                    if (numAppContexts.get() == 0) {
                        // This check is not necessary, its purpose is to help
                        // Plugin devs to catch all the cases of main AC creation.
                        if (System.getProperty("javaplugin.version") == null &&
                                System.getProperty("javawebstart.version") == null) {
                            initMainAppContext();
                        }
                    }

                    AppContext context = threadGroup2appContext.get(threadGroup);
                    while (context == null) {
                        threadGroup = threadGroup.getParent();
                        if (threadGroup == null) {
                            return null;
                        }
                        context = threadGroup2appContext.get(threadGroup);
                    }

                    // In case we did anything in the above while loop, we add
                    // all the intermediate ThreadGroups to threadGroup2appContext
                    // so we won't spin again.
                    for (ThreadGroup tg = currentThreadGroup; tg != threadGroup; tg = tg.getParent()) {
                        threadGroup2appContext.put(tg, context);
                    }

                    // Now we're done, so we cache the latest key/value pair.
                    threadAppContext.set(context);

                    return context;
                }
            });
        }

        return appContext;
    }

    /**
     * Returns true if the specified AppContext is the main AppContext.
     *
     * @@param   ctx the context to compare with the main context
     * @@return  true if the specified AppContext is the main AppContext.
     * @@since   1.8
     */
    public final static boolean isMainContext(AppContext ctx) {
        return (ctx != null && ctx == mainAppContext);
    }

    private final static AppContext getExecutionAppContext() {
        SecurityManager securityManager = System.getSecurityManager();
        if ((securityManager != null) &&
            (securityManager instanceof AWTSecurityManager))
        {
            AWTSecurityManager awtSecMgr = (AWTSecurityManager) securityManager;
            AppContext secAppContext = awtSecMgr.getAppContext();
            return secAppContext; // Return what we're told
        }
        return null;
    }

    private long DISPOSAL_TIMEOUT = 5000;  // Default to 5-second timeout
                                           // for disposal of all Frames
                                           // (we wait for this time twice,
                                           // once for dispose(), and once
                                           // to clear the EventQueue).

    private long THREAD_INTERRUPT_TIMEOUT = 1000;
                            // Default to 1-second timeout for all
                            // interrupted Threads to exit, and another
                            // 1 second for all stopped Threads to die.

    /**
     * Disposes of this AppContext, all of its top-level Frames, and
     * all Threads and ThreadGroups contained within it.
     *
     * This method must be called from a Thread which is not contained
     * within this AppContext.
     *
     * @@exception  IllegalThreadStateException  if the current thread is
     *                                    contained within this AppContext
     * @@since      1.2
     */
    public void dispose() throws IllegalThreadStateException {
        // Check to be sure that the current Thread isn't in this AppContext
        if (this.threadGroup.parentOf(Thread.currentThread().getThreadGroup())) {
            throw new IllegalThreadStateException(
                "Current Thread is contained within AppContext to be disposed."
              );
        }

        synchronized(this) {
            if (this.state != State.VALID) {
                return; // If already disposed or being disposed, bail.
            }

            this.state = State.BEING_DISPOSED;
        }

        final PropertyChangeSupport changeSupport = this.changeSupport;
        if (changeSupport != null) {
            changeSupport.firePropertyChange(DISPOSED_PROPERTY_NAME, false, true);
        }

        // First, we post an InvocationEvent to be run on the
        // EventDispatchThread which disposes of all top-level Frames and TrayIcons

        final Object notificationLock = new Object();

        Runnable runnable = new Runnable() {
            public void run() {
                Window[] windowsToDispose = Window.getOwnerlessWindows();
                for (Window w : windowsToDispose) {
                    try {
                        w.dispose();
                    } catch (Throwable t) {
                        log.finer("exception occured while disposing app context", t);
                    }
                }
                AccessController.doPrivileged(new PrivilegedAction() {
                        public Object run() {
                            if (!GraphicsEnvironment.isHeadless() && SystemTray.isSupported())
                            {
                                SystemTray systemTray = SystemTray.getSystemTray();
                                TrayIcon[] trayIconsToDispose = systemTray.getTrayIcons();
                                for (TrayIcon ti : trayIconsToDispose) {
                                    systemTray.remove(ti);
                                }
                            }
                            return null;
                        }
                    });
                // Alert PropertyChangeListeners that the GUI has been disposed.
                if (changeSupport != null) {
                    changeSupport.firePropertyChange(GUI_DISPOSED, false, true);
                }
                synchronized(notificationLock) {
                    notificationLock.notifyAll(); // Notify caller that we're done
                }
            }
        };
        synchronized(notificationLock) {
            SunToolkit.postEvent(this,
                new InvocationEvent(Toolkit.getDefaultToolkit(), runnable));
            try {
                notificationLock.wait(DISPOSAL_TIMEOUT);
            } catch (InterruptedException e) { }
        }

        // Next, we post another InvocationEvent to the end of the
        // EventQueue.  When it's executed, we know we've executed all
        // events in the queue.

        runnable = new Runnable() { public void run() {
            synchronized(notificationLock) {
                notificationLock.notifyAll(); // Notify caller that we're done
            }
        } };
        synchronized(notificationLock) {
            SunToolkit.postEvent(this,
                new InvocationEvent(Toolkit.getDefaultToolkit(), runnable));
            try {
                notificationLock.wait(DISPOSAL_TIMEOUT);
            } catch (InterruptedException e) { }
        }

        // We are done with posting events, so change the state to disposed
        synchronized(this) {
            this.state = State.DISPOSED;
        }

        // Next, we interrupt all Threads in the ThreadGroup
        this.threadGroup.interrupt();
            // Note, the EventDispatchThread we've interrupted may dump an
            // InterruptedException to the console here.  This needs to be
            // fixed in the EventDispatchThread, not here.

        // Next, we sleep 10ms at a time, waiting for all of the active
        // Threads in the ThreadGroup to exit.

        long startTime = System.currentTimeMillis();
        long endTime = startTime + THREAD_INTERRUPT_TIMEOUT;
        while ((this.threadGroup.activeCount() > 0) &&
               (System.currentTimeMillis() < endTime)) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) { }
        }

        // Then, we stop any remaining Threads
        this.threadGroup.stop();

        // Next, we sleep 10ms at a time, waiting for all of the active
        // Threads in the ThreadGroup to die.

        startTime = System.currentTimeMillis();
        endTime = startTime + THREAD_INTERRUPT_TIMEOUT;
        while ((this.threadGroup.activeCount() > 0) &&
               (System.currentTimeMillis() < endTime)) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) { }
        }

        // Next, we remove this and all subThreadGroups from threadGroup2appContext
        int numSubGroups = this.threadGroup.activeGroupCount();
        if (numSubGroups > 0) {
            ThreadGroup [] subGroups = new ThreadGroup[numSubGroups];
            numSubGroups = this.threadGroup.enumerate(subGroups);
            for (int subGroup = 0; subGroup < numSubGroups; subGroup++) {
                threadGroup2appContext.remove(subGroups[subGroup]);
            }
        }
        threadGroup2appContext.remove(this.threadGroup);

        threadAppContext.set(null);

        // Finally, we destroy the ThreadGroup entirely.
        try {
            this.threadGroup.destroy();
        } catch (IllegalThreadStateException e) {
            // Fired if not all the Threads died, ignore it and proceed
        }

        synchronized (table) {
            this.table.clear(); // Clear out the Hashtable to ease garbage collection
        }

        numAppContexts.decrementAndGet();

        mostRecentKeyValue = null;
    }

    static final class PostShutdownEventRunnable implements Runnable {
        private final AppContext appContext;

        public PostShutdownEventRunnable(AppContext ac) {
            appContext = ac;
        }

        public void run() {
            final EventQueue eq = (EventQueue)appContext.get(EVENT_QUEUE_KEY);
            if (eq != null) {
                eq.postEvent(AWTAutoShutdown.getShutdownEvent());
            }
        }
    }

    static final class CreateThreadAction implements PrivilegedAction {
        private final AppContext appContext;
        private final Runnable runnable;

        public CreateThreadAction(AppContext ac, Runnable r) {
            appContext = ac;
            runnable = r;
        }

        public Object run() {
            Thread t = new Thread(appContext.getThreadGroup(), runnable);
            t.setContextClassLoader(appContext.getContextClassLoader());
            t.setPriority(Thread.NORM_PRIORITY + 1);
            t.setDaemon(true);
            return t;
        }
    }

    static void stopEventDispatchThreads() {
        for (AppContext appContext: getAppContexts()) {
            if (appContext.isDisposed()) {
                continue;
            }
            Runnable r = new PostShutdownEventRunnable(appContext);
            // For security reasons EventQueue.postEvent should only be called
            // on a thread that belongs to the corresponding thread group.
            if (appContext != AppContext.getAppContext()) {
                // Create a thread that belongs to the thread group associated
                // with the AppContext and invokes EventQueue.postEvent.
                PrivilegedAction action = new CreateThreadAction(appContext, r);
                Thread thread = (Thread)AccessController.doPrivileged(action);
                thread.start();
            } else {
                r.run();
            }
        }
    }

    private MostRecentKeyValue mostRecentKeyValue = null;
    private MostRecentKeyValue shadowMostRecentKeyValue = null;

    /**
     * Returns the value to which the specified key is mapped in this context.
     *
     * @@param   key   a key in the AppContext.
     * @@return  the value to which the key is mapped in this AppContext;
     *          <code>null</code> if the key is not mapped to any value.
     * @@see     #put(Object, Object)
     * @@since   1.2
     */
    public Object get(Object key) {
        /*
         * The most recent reference should be updated inside a synchronized
         * block to avoid a race when put() and get() are executed in
         * parallel on different threads.
         */
        synchronized (table) {
            // Note: this most recent key/value caching is thread-hot.
            // A simple test using SwingSet found that 72% of lookups
            // were matched using the most recent key/value.  By instantiating
            // a simple MostRecentKeyValue object on cache misses, the
            // cache hits can be processed without synchronization.

            MostRecentKeyValue recent = mostRecentKeyValue;
            if ((recent != null) && (recent.key == key)) {
                return recent.value;
            }

            Object value = table.get(key);
            if(mostRecentKeyValue == null) {
                mostRecentKeyValue = new MostRecentKeyValue(key, value);
                shadowMostRecentKeyValue = new MostRecentKeyValue(key, value);
            } else {
                MostRecentKeyValue auxKeyValue = mostRecentKeyValue;
                shadowMostRecentKeyValue.setPair(key, value);
                mostRecentKeyValue = shadowMostRecentKeyValue;
                shadowMostRecentKeyValue = auxKeyValue;
            }
            return value;
        }
    }

    /**
     * Maps the specified <code>key</code> to the specified
     * <code>value</code> in this AppContext.  Neither the key nor the
     * value can be <code>null</code>.
     * <p>
     * The value can be retrieved by calling the <code>get</code> method
     * with a key that is equal to the original key.
     *
     * @@param      key     the AppContext key.
     * @@param      value   the value.
     * @@return     the previous value of the specified key in this
     *             AppContext, or <code>null</code> if it did not have one.
     * @@exception  NullPointerException  if the key or value is
     *               <code>null</code>.
     * @@see     #get(Object)
     * @@since   1.2
     */
    public Object put(Object key, Object value) {
        synchronized (table) {
            MostRecentKeyValue recent = mostRecentKeyValue;
            if ((recent != null) && (recent.key == key))
                recent.value = value;
            return table.put(key, value);
        }
    }

    /**
     * Removes the key (and its corresponding value) from this
     * AppContext. This method does nothing if the key is not in the
     * AppContext.
     *
     * @@param   key   the key that needs to be removed.
     * @@return  the value to which the key had been mapped in this AppContext,
     *          or <code>null</code> if the key did not have a mapping.
     * @@since   1.2
     */
    public Object remove(Object key) {
        synchronized (table) {
            MostRecentKeyValue recent = mostRecentKeyValue;
            if ((recent != null) && (recent.key == key))
                recent.value = null;
            return table.remove(key);
        }
    }

    /**
     * Returns the root ThreadGroup for all Threads contained within
     * this AppContext.
     * @@since   1.2
     */
    public ThreadGroup getThreadGroup() {
        return threadGroup;
    }

    /**
     * Returns the context ClassLoader that was used to create this
     * AppContext.
     *
     * @@see java.lang.Thread#getContextClassLoader
     */
    public ClassLoader getContextClassLoader() {
        return contextClassLoader;
    }

    /**
     * Returns a string representation of this AppContext.
     * @@since   1.2
     */
    @@Override
    public String toString() {
        return getClass().getName() + "[threadGroup=" + threadGroup.getName() + "]";
    }

    /**
     * Returns an array of all the property change listeners
     * registered on this component.
     *
     * @@return all of this component's <code>PropertyChangeListener</code>s
     *         or an empty array if no property change
     *         listeners are currently registered
     *
     * @@see      #addPropertyChangeListener
     * @@see      #removePropertyChangeListener
     * @@see      #getPropertyChangeListeners(java.lang.String)
     * @@see      java.beans.PropertyChangeSupport#getPropertyChangeListeners
     * @@since    1.4
     */
    public synchronized PropertyChangeListener[] getPropertyChangeListeners() {
        if (changeSupport == null) {
            return new PropertyChangeListener[0];
        }
        return changeSupport.getPropertyChangeListeners();
    }

    /**
     * Adds a PropertyChangeListener to the listener list for a specific
     * property. The specified property may be one of the following:
     * <ul>
     *    <li>if this AppContext is disposed ("disposed")</li>
     * </ul>
     * <ul>
     *    <li>if this AppContext's unowned Windows have been disposed
     *    ("guidisposed").  Code to cleanup after the GUI is disposed
     *    (such as LookAndFeel.uninitialize()) should execute in response to
     *    this property being fired.  Notifications for the "guidisposed"
     *    property are sent on the event dispatch thread.</li>
     * </ul>
     * <p>
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @@param propertyName one of the property names listed above
     * @@param listener the PropertyChangeListener to be added
     *
     * @@see #removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     * @@see #getPropertyChangeListeners(java.lang.String)
     * @@see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     */
    public synchronized void addPropertyChangeListener(
                             String propertyName,
                             PropertyChangeListener listener) {
        if (listener == null) {
            return;
        }
        if (changeSupport == null) {
            changeSupport = new PropertyChangeSupport(this);
        }
        changeSupport.addPropertyChangeListener(propertyName, listener);
    }

    /**
     * Removes a PropertyChangeListener from the listener list for a specific
     * property. This method should be used to remove PropertyChangeListeners
     * that were registered for a specific bound property.
     * <p>
     * If listener is null, no exception is thrown and no action is performed.
     *
     * @@param propertyName a valid property name
     * @@param listener the PropertyChangeListener to be removed
     *
     * @@see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     * @@see #getPropertyChangeListeners(java.lang.String)
     * @@see #removePropertyChangeListener(java.beans.PropertyChangeListener)
     */
    public synchronized void removePropertyChangeListener(
                             String propertyName,
                             PropertyChangeListener listener) {
        if (listener == null || changeSupport == null) {
            return;
        }
        changeSupport.removePropertyChangeListener(propertyName, listener);
    }

    /**
     * Returns an array of all the listeners which have been associated
     * with the named property.
     *
     * @@return all of the <code>PropertyChangeListeners</code> associated with
     *         the named property or an empty array if no listeners have
     *         been added
     *
     * @@see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     * @@see #removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)
     * @@see #getPropertyChangeListeners
     * @@since 1.4
     */
    public synchronized PropertyChangeListener[] getPropertyChangeListeners(
                                                        String propertyName) {
        if (changeSupport == null) {
            return new PropertyChangeListener[0];
        }
        return changeSupport.getPropertyChangeListeners(propertyName);
    }

    // Set up JavaAWTAccess in SharedSecrets
    static {
        sun.misc.SharedSecrets.setJavaAWTAccess(new sun.misc.JavaAWTAccess() {
            public Object get(Object key) {
                AppContext ac = getAppContext();
                return (ac == null) ? null : ac.get(key);
            }
            public void put(Object key, Object value) {
                AppContext ac = getAppContext();
                if (ac != null) {
                    ac.put(key, value);
                }
            }
            public void remove(Object key) {
                AppContext ac = getAppContext();
                if (ac != null) {
                    ac.remove(key);
                }
            }
            public boolean isDisposed() {
                AppContext ac = getAppContext();
                return (ac == null) ? true : ac.isDisposed();
            }
            public boolean isMainAppContext() {
                return (numAppContexts.get() == 1 && mainAppContext != null);
            }
            public Object getContext() {
                return getAppContext();
            }
            public Object getExecutionContext() {
                return getExecutionAppContext();
            }
            public Object get(Object context, Object key) {
                return ((AppContext)context).get(key);
            }
            public void put(Object context, Object key, Object value) {
                ((AppContext)context).put(key, value);
            }
            public void remove(Object context, Object key) {
                ((AppContext)context).remove(key);
            }
        });
    }
}

final class MostRecentKeyValue {
    Object key;
    Object value;
    MostRecentKeyValue(Object k, Object v) {
        key = k;
        value = v;
    }
    void setPair(Object k, Object v) {
        key = k;
        value = v;
    }
}
@


1.9
log
@Merged 7u40 AppContext and TimeZone decoupling mechanism.
@
text
@@


1.8
log
@Integrated OpenJDK 7u4. Not all forked files have been merged yet, just the ones necessary to get things building.
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
d49 1
d133 1
a133 1
public final class AppContext extends AppContextDC {
d165 3
a167 2
       contained in another AppContext.
     */
d193 7
a199 1
    private volatile boolean isDisposed = false; // true if AppContext is disposed
d202 1
a202 22
        return isDisposed;
    }

    static {
        // On the main Thread, we get the ThreadGroup, make a corresponding
        // AppContext, and instantiate the Java EventQueue.  This way, legacy
        // code is unaffected by the move to multiple AppContext ability.
        AccessController.doPrivileged(new PrivilegedAction() {
            public Object run() {
                ThreadGroup currentThreadGroup =
                        Thread.currentThread().getThreadGroup();
                ThreadGroup parentThreadGroup = currentThreadGroup.getParent();
                while (parentThreadGroup != null) {
                    // Find the root ThreadGroup to construct our main AppContext
                    currentThreadGroup = parentThreadGroup;
                    parentThreadGroup = currentThreadGroup.getParent();
                }
                mainAppContext = new AppContext(currentThreadGroup);
                numAppContexts = 1;
                return mainAppContext;
            }
        });
d212 1
a212 1
    private static volatile int numAppContexts;
d233 1
a233 1
        numAppContexts++;
d256 21
d289 4
a292 2
        if (numAppContexts == 1)   // If there's only one system-wide,
            return mainAppContext; // return the main system AppContext.
d306 14
d324 1
a324 6
                            // If we get here, we're running under a ThreadGroup that
                            // has no AppContext associated with it.  This should never
                            // happen, because createNewContext() should be used by the
                            // toolkit to create the ThreadGroup that everything runs
                            // under.
                            throw new RuntimeException("Invalid ThreadGroup");
d328 1
d335 1
a336 3
                    // (we do this before checking with any AWTSecurityManager, so if
                    // this Thread equates with the main AppContext in the cache, it
                    // still will)
a343 16
        if (appContext == mainAppContext)  {
            // Before we return the main "system" AppContext, check to
            // see if there's an AWTSecurityManager installed.  If so,
            // allow it to choose the AppContext to return.
            SecurityManager securityManager = System.getSecurityManager();
            if ((securityManager != null) &&
                (securityManager instanceof AWTSecurityManager))
            {
                AWTSecurityManager awtSecMgr = (AWTSecurityManager)securityManager;
                AppContext secAppContext = awtSecMgr.getAppContext();
                if (secAppContext != null)  {
                    appContext = secAppContext; // Return what we're told
                }
            }
        }

d348 1
a348 1
     * Returns the main ("system") AppContext.
d350 2
a351 1
     * @@return  the main AppContext
d354 14
a367 2
    final static AppContext getMainAppContext() {
        return mainAppContext;
d401 2
a402 2
            if (this.isDisposed) {
                return; // If already disposed, bail.
d404 2
a405 1
            this.isDisposed = true;
d420 21
d475 5
d537 1
a537 1
        numAppContexts--;
d811 44
@


1.7
log
@Init EventQueue lock for Java 7
@
text
@d30 2
a31 2
//import java.awt.SystemTray;
//import java.awt.TrayIcon;
d45 1
d132 2
a133 1
public final class AppContext {
d138 2
a139 1
    /* The key to put()/get() the Java EventQueue into/from the AppContext.
d158 3
a160 1
        return new HashSet<AppContext>(threadGroup2appContext.values());
d202 13
a214 13
          public Object run() {
            ThreadGroup currentThreadGroup =
                                Thread.currentThread().getThreadGroup();
            ThreadGroup parentThreadGroup = currentThreadGroup.getParent();
            while (parentThreadGroup != null) {
                // Find the root ThreadGroup to construct our main AppContext
                currentThreadGroup = parentThreadGroup;
                parentThreadGroup = currentThreadGroup.getParent();
            }
            mainAppContext = new AppContext(currentThreadGroup);
            numAppContexts = 1;
            return mainAppContext;
          }
d252 2
a253 2
            (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
                    public Object run() {
d266 2
a267 1
    private static MostRecentThreadAppContext mostRecentThreadAppContext = null;
d284 1
a284 1
        final Thread currentThread = Thread.currentThread();
d286 34
a319 1
        AppContext appContext = null;
d321 1
a321 30
        // Note: this most recent Thread/AppContext caching is thread-hot.
        // A simple test using SwingSet found that 96.8% of lookups
        // were matched using the most recent Thread/AppContext.  By
        // instantiating a simple MostRecentThreadAppContext object on
        // cache misses, the cache hits can be processed without
        // synchronization.

        MostRecentThreadAppContext recent = mostRecentThreadAppContext;
        if ((recent != null) && (recent.thread == currentThread))  {
            appContext = recent.appContext; // Cache hit
        } else {
          appContext = (AppContext)AccessController.doPrivileged(
                                            new PrivilegedAction() {
            public Object run() {
            // Get the current ThreadGroup, and look for it and its
            // parents in the hash from ThreadGroup to AppContext --
            // it should be found, because we use createNewContext()
            // when new AppContext objects are created.
            ThreadGroup currentThreadGroup = currentThread.getThreadGroup();
            ThreadGroup threadGroup = currentThreadGroup;
            AppContext context = threadGroup2appContext.get(threadGroup);
            while (context == null) {
                threadGroup = threadGroup.getParent();
                if (threadGroup == null) {
                    // If we get here, we're running under a ThreadGroup that
                    // has no AppContext associated with it.  This should never
                    // happen, because createNewContext() should be used by the
                    // toolkit to create the ThreadGroup that everything runs
                    // under.
                    throw new RuntimeException("Invalid ThreadGroup");
d323 1
a323 18
                context = threadGroup2appContext.get(threadGroup);
            }
            // In case we did anything in the above while loop, we add
            // all the intermediate ThreadGroups to threadGroup2appContext
            // so we won't spin again.
            for (ThreadGroup tg = currentThreadGroup; tg != threadGroup; tg = tg.getParent()) {
                threadGroup2appContext.put(tg, context);
            }
            // Now we're done, so we cache the latest key/value pair.
            // (we do this before checking with any AWTSecurityManager, so if
            // this Thread equates with the main AppContext in the cache, it
            // still will)
            mostRecentThreadAppContext =
                new MostRecentThreadAppContext(currentThread, context);

            return context;
          }
         });
d332 3
a334 3
                (securityManager instanceof AWTSecurityManager))  {
                AWTSecurityManager awtSecMgr =
                                      (AWTSecurityManager)securityManager;
d345 10
a403 17
//                Window[] windowsToDispose = Window.getOwnerlessWindows();
//                for (Window w : windowsToDispose) {
//                    w.dispose();
//                }
//                AccessController.doPrivileged(new PrivilegedAction() {
//                        public Object run() {
//                            if (!GraphicsEnvironment.isHeadless() && SystemTray.isSupported())
//                            {
//                                SystemTray systemTray = SystemTray.getSystemTray();
//                                TrayIcon[] trayIconsToDispose = systemTray.getTrayIcons();
//                                for (TrayIcon ti : trayIconsToDispose) {
//                                    systemTray.remove(ti);
//                                }
//                            }
//                            return null;
//                        }
//                    });
d482 1
a482 4
        MostRecentThreadAppContext recent = mostRecentThreadAppContext;
        if ((recent != null) && (recent.appContext == this))
            mostRecentThreadAppContext = null;
                // If the "most recent" points to this, clear it for GC
a770 9
final class MostRecentThreadAppContext {
    final Thread thread;
    final AppContext appContext;
    MostRecentThreadAppContext(Thread key, AppContext value) {
        thread = key;
        appContext = value;
    }
}

@


1.6
log
@Add const for locking of event queue in JDK7
@
text
@d2 1
a2 1
 * Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved.
d45 3
d161 1
a161 1
    private static AppContext mainAppContext = null;
d186 1
a186 1
    private boolean isDisposed = false; // true if AppContext is disposed
a191 1

d220 1
a220 1
    private static int numAppContexts;
d252 7
d462 1
a462 1
        long endTime = startTime + (long)THREAD_INTERRUPT_TIMEOUT;
d477 1
a477 1
        endTime = startTime + (long)THREAD_INTERRUPT_TIMEOUT;
d682 1
@


1.5
log
@Integrated OpenJDK 6 b21.
@
text
@d137 6
@


1.4
log
@More Sun classes (package sun.awt)
@
text
@d2 1
a2 1
 * Copyright 1998-2007 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.3
log
@Switched java.awt.datatransfer package from GNU Classpath to OpenJDK.
@
text
@d2 23
a24 1
  Copyright (C) 2007 Jeroen Frijters
d26 106
a131 15
  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
d133 3
a135 2
  Jeroen Frijters
  jeroen@@frijters.net 
d137 4
a140 1
*/
d142 21
a162 1
package sun.awt;
d164 9
a172 3
import java.util.HashSet;
import java.util.Set;
import java.beans.PropertyChangeListener;
a173 2
public final class AppContext extends java.util.Hashtable
{
d175 270
a444 1
    private static final AppContext instance = new AppContext();
d446 8
a453 1
    private AppContext() {}
d455 336
a790 25
    public static AppContext getAppContext()
    {
        return instance;
    }
    
    public static Set<AppContext> getAppContexts()
    {
        HashSet<AppContext> set = new HashSet<AppContext>();
        set.add(instance);
        return set;
    }
    
    public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener)
    {
        throw new Error("Not implemented");
    }
    
    public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener)
    {
        throw new Error("Not implemented");
    }
    
    public boolean isDisposed()
    {
        return false;
@


1.2
log
@Switched java.awt.event package from GNU Classpath to OpenJDK.
@
text
@d27 4
d33 2
a34 1
  private static final AppContext instance = new AppContext();
d36 1
a36 1
  private AppContext() {}
d38 26
a63 4
  public static AppContext getAppContext()
  {
    return instance;
  }
@


1.1
log
@Integrated OpenJDK javax.imageio package (excluding the jpeg support, because OpenJDK uses native code for that).
@
text
@d1 24
@

