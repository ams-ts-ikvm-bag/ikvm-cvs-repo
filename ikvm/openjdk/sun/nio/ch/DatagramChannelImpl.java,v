head	1.19;
access;
symbols
	v8_1_5717_0:1.19
	v8_1:1.19.0.2
	v8_0_5449_1:1.18
	v8_0_5449_0:1.18
	v8_0:1.18.0.2
	v7_4_5196_0:1.17
	v7_4:1.17.0.2
	v7_3:1.15.0.4
	v7_2_4630_6:1.15
	v7_2_4630_5:1.15
	v7_2_4630_4:1.15
	v7_2_4630_3:1.15
	v7_2_4630_2:1.15
	v0_46_0_4:1.9
	v7_2_4630_1:1.15
	v7_2:1.15.0.2
	v7_1_4532_2:1.14
	v7_1_4532_1:1.14
	v7_1_4532_0:1.14
	v7_1:1.14.0.2
	v7_0_4335_3:1.13
	v7_0_4335_2:1.13
	v7_0_4335_1:1.13
	v0_46_0_2:1.9
	v7_0_4335_0:1.13
	v7_0:1.13.0.2
	v0_40_0_6:1.6
	v0_40_0_5:1.6
	v0_46_0_1:1.9
	v0_46_0_0:1.9
	v0_46:1.9.0.2
	v0_36_0_14:1.2
	v0_44_0_6:1.6
	v0_44_0_5:1.6
	v0_44_0_4:1.6
	v0_44_0_3:1.6
	v0_44_0_2:1.6
	v0_42_0_7:1.6
	v0_44_0_1:1.6
	v0_44_0_0:1.6
	v0_44:1.6.0.8
	v0_42_0_6:1.6
	v0_42_0_5:1.6
	v0_42_0_4:1.6
	v0_42_0_3:1.6
	v0_42_0_2:1.6
	v0_42_0_1:1.6
	v0_42_0_0:1.6
	v0_42:1.6.0.6
	v0_40_0_3:1.6
	v0_40_0_2:1.6
	v0_40_0_1:1.6
	v0_40_0_0:1.6
	v0_40:1.6.0.4
	v0_36_0_13:1.2
	v0_38_0_1:1.6
	v0_38_0_0:1.6
	v0_38:1.6.0.2
	v0_36_0_9:1.2
	v0_36_0_7:1.2
	v0_36_0_5:1.2
	v0_36_0_4:1.2
	v0_36_0_3:1.2
	v0_36_0_2:1.2
	v0_36_0_1:1.2
	v0_36_0_0:1.2
	v0_36:1.2.0.2;
locks; strict;
comment	@# @;


1.19
date	2015.06.09.09.28.44;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2014.05.19.12.43.41;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2014.02.07.14.14.12;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2013.08.15.16.25.09;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2012.08.31.11.24.28;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2012.05.23.14.25.32;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2011.08.24.11.58.40;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.15.09.05.27;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.10.09.15.37;	author smallsql;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.09.10.50.12;	author smallsql;	state Exp;
branches;
next	1.9;

1.9
date	2011.03.02.07.32.51;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.24.16.40.23;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2010.08.27.06.21.56;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.16.09.13.11;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.15.09.42.37;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.12.09.10.08;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.11.09.05.50;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2007.07.23.13.15.55;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.20.09.17.26;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Integrated OpenJDK 8u45.
@
text
@/*
 * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.ch;

import java.io.FileDescriptor;
import java.io.IOException;
import java.net.*;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.nio.channels.spi.*;
import java.util.*;
import sun.net.ResourceManager;
import sun.net.ExtendedOptionsImpl;

/**
 * An implementation of DatagramChannels.
 */

class DatagramChannelImpl
    extends DatagramChannel
    implements SelChImpl
{

    // Used to make native read and write calls
    private static NativeDispatcher nd = new SocketDispatcher();

    // Our file descriptor
    private final FileDescriptor fd;

    // fd value needed for dev/poll. This value will remain valid
    // even after the value in the file descriptor object has been set to -1
    private final int fdVal;

    // The protocol family of the socket
    private final ProtocolFamily family;

    // IDs of native threads doing reads and writes, for signalling
    private volatile long readerThread = 0;
    private volatile long writerThread = 0;

    // Cached InetAddress and port for unconnected DatagramChannels
    // used by receive0
    private InetAddress cachedSenderInetAddress;
    private int cachedSenderPort;

    // Lock held by current reading or connecting thread
    private final Object readLock = new Object();

    // Lock held by current writing or connecting thread
    private final Object writeLock = new Object();

    // Lock held by any thread that modifies the state fields declared below
    // DO NOT invoke a blocking I/O operation while holding this lock!
    private final Object stateLock = new Object();

    // -- The following fields are protected by stateLock

    // State (does not necessarily increase monotonically)
    private static final int ST_UNINITIALIZED = -1;
    private static final int ST_UNCONNECTED = 0;
    private static final int ST_CONNECTED = 1;
    private static final int ST_KILLED = 2;
    private int state = ST_UNINITIALIZED;

    // Binding
    private InetSocketAddress localAddress;
    private InetSocketAddress remoteAddress;

    // Our socket adaptor, if any
    private DatagramSocket socket;

    // Multicast support
    private MembershipRegistry registry;

    // set true when socket is bound and SO_REUSEADDRESS is emulated
    private boolean reuseAddressEmulated;

    // set true/false when socket is already bound and SO_REUSEADDR is emulated
    private boolean isReuseAddress;

    // -- End of fields protected by stateLock


    public DatagramChannelImpl(SelectorProvider sp)
        throws IOException
    {
        super(sp);
        ResourceManager.beforeUdpCreate();
        try {
            this.family = Net.isIPv6Available() ?
                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
            this.fd = Net.socket(family, false);
            this.fdVal = IOUtil.fdVal(fd);
            this.state = ST_UNCONNECTED;
        } catch (IOException ioe) {
            ResourceManager.afterUdpClose();
            throw ioe;
        }
    }

    public DatagramChannelImpl(SelectorProvider sp, ProtocolFamily family)
        throws IOException
    {
        super(sp);
        if ((family != StandardProtocolFamily.INET) &&
            (family != StandardProtocolFamily.INET6))
        {
            if (family == null)
                throw new NullPointerException("'family' is null");
            else
                throw new UnsupportedOperationException("Protocol family not supported");
        }
        if (family == StandardProtocolFamily.INET6) {
            if (!Net.isIPv6Available()) {
                throw new UnsupportedOperationException("IPv6 not available");
            }
        }
        this.family = family;
        this.fd = Net.socket(family, false);
        this.fdVal = IOUtil.fdVal(fd);
        this.state = ST_UNCONNECTED;
    }

    public DatagramChannelImpl(SelectorProvider sp, FileDescriptor fd)
        throws IOException
    {
        super(sp);
        this.family = Net.isIPv6Available() ?
            StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
        this.fd = fd;
        this.fdVal = IOUtil.fdVal(fd);
        this.state = ST_UNCONNECTED;
        this.localAddress = Net.localAddress(fd);
    }

    public DatagramSocket socket() {
        synchronized (stateLock) {
            if (socket == null)
                socket = DatagramSocketAdaptor.create(this);
            return socket;
        }
    }

    @@Override
    public SocketAddress getLocalAddress() throws IOException {
        synchronized (stateLock) {
            if (!isOpen())
                throw new ClosedChannelException();
            // Perform security check before returning address
            return Net.getRevealedLocalAddress(localAddress);
        }
    }

    @@Override
    public SocketAddress getRemoteAddress() throws IOException {
        synchronized (stateLock) {
            if (!isOpen())
                throw new ClosedChannelException();
            return remoteAddress;
        }
    }

    @@Override
    public <T> DatagramChannel setOption(SocketOption<T> name, T value)
        throws IOException
    {
        if (name == null)
            throw new NullPointerException();
        if (!supportedOptions().contains(name))
            throw new UnsupportedOperationException("'" + name + "' not supported");

        synchronized (stateLock) {
            ensureOpen();

            if (name == StandardSocketOptions.IP_TOS ||
                name == StandardSocketOptions.IP_MULTICAST_TTL ||
                name == StandardSocketOptions.IP_MULTICAST_LOOP)
            {
                // options are protocol dependent
                Net.setSocketOption(fd, family, name, value);
                return this;
            }

            if (name == StandardSocketOptions.IP_MULTICAST_IF) {
                if (value == null)
                    throw new IllegalArgumentException("Cannot set IP_MULTICAST_IF to 'null'");
                NetworkInterface interf = (NetworkInterface)value;
                if (family == StandardProtocolFamily.INET6) {
                    int index = interf.getIndex();
                    if (index == -1)
                        throw new IOException("Network interface cannot be identified");
                    Net.setInterface6(fd, index);
                } else {
                    // need IPv4 address to identify interface
                    Inet4Address target = Net.anyInet4Address(interf);
                    if (target == null)
                        throw new IOException("Network interface not configured for IPv4");
                    int targetAddress = Net.inet4AsInt(target);
                    Net.setInterface4(fd, targetAddress);
                }
                return this;
            }
            if (name == StandardSocketOptions.SO_REUSEADDR &&
                    Net.useExclusiveBind() && localAddress != null)
            {
                reuseAddressEmulated = true;
                this.isReuseAddress = (Boolean)value;
            }

            // remaining options don't need any special handling
            Net.setSocketOption(fd, Net.UNSPEC, name, value);
            return this;
        }
    }

    @@Override
    @@SuppressWarnings("unchecked")
    public <T> T getOption(SocketOption<T> name)
        throws IOException
    {
        if (name == null)
            throw new NullPointerException();
        if (!supportedOptions().contains(name))
            throw new UnsupportedOperationException("'" + name + "' not supported");

        synchronized (stateLock) {
            ensureOpen();

            if (name == StandardSocketOptions.IP_TOS ||
                name == StandardSocketOptions.IP_MULTICAST_TTL ||
                name == StandardSocketOptions.IP_MULTICAST_LOOP)
            {
                return (T) Net.getSocketOption(fd, family, name);
            }

            if (name == StandardSocketOptions.IP_MULTICAST_IF) {
                if (family == StandardProtocolFamily.INET) {
                    int address = Net.getInterface4(fd);
                    if (address == 0)
                        return null;    // default interface

                    InetAddress ia = Net.inet4FromInt(address);
                    NetworkInterface ni = NetworkInterface.getByInetAddress(ia);
                    if (ni == null)
                        throw new IOException("Unable to map address to interface");
                    return (T) ni;
                } else {
                    int index = Net.getInterface6(fd);
                    if (index == 0)
                        return null;    // default interface

                    NetworkInterface ni = NetworkInterface.getByIndex(index);
                    if (ni == null)
                        throw new IOException("Unable to map index to interface");
                    return (T) ni;
                }
            }

            if (name == StandardSocketOptions.SO_REUSEADDR &&
                    reuseAddressEmulated)
            {
                return (T)Boolean.valueOf(isReuseAddress);
            }

            // no special handling
            return (T) Net.getSocketOption(fd, Net.UNSPEC, name);
        }
    }

    private static class DefaultOptionsHolder {
        static final Set<SocketOption<?>> defaultOptions = defaultOptions();

        private static Set<SocketOption<?>> defaultOptions() {
            HashSet<SocketOption<?>> set = new HashSet<SocketOption<?>>(8);
            set.add(StandardSocketOptions.SO_SNDBUF);
            set.add(StandardSocketOptions.SO_RCVBUF);
            set.add(StandardSocketOptions.SO_REUSEADDR);
            set.add(StandardSocketOptions.SO_BROADCAST);
            set.add(StandardSocketOptions.IP_TOS);
            set.add(StandardSocketOptions.IP_MULTICAST_IF);
            set.add(StandardSocketOptions.IP_MULTICAST_TTL);
            set.add(StandardSocketOptions.IP_MULTICAST_LOOP);
            if (ExtendedOptionsImpl.flowSupported()) {
                set.add(jdk.net.ExtendedSocketOptions.SO_FLOW_SLA);
            }
            return Collections.unmodifiableSet(set);
        }
    }

    @@Override
    public final Set<SocketOption<?>> supportedOptions() {
        return DefaultOptionsHolder.defaultOptions;
    }

    private void ensureOpen() throws ClosedChannelException {
        if (!isOpen())
            throw new ClosedChannelException();
    }

    SocketAddress sender;       // Set by receive0 (## ugh)

    public SocketAddress receive(ByteBuffer dst) throws IOException {
        if (dst.isReadOnly())
            throw new IllegalArgumentException("Read-only buffer");
        if (dst == null)
            throw new NullPointerException();
        synchronized (readLock) {
            ensureOpen();
            // Socket was not bound before attempting receive
            if (localAddress() == null)
                bind(null);
            int n = 0;
            ByteBuffer bb = null;
            try {
                begin();
                if (!isOpen())
                    return null;
                SecurityManager security = System.getSecurityManager();
                readerThread = NativeThread.current();
                if (isConnected() || (security == null)) {
                    do {
                        n = receive(fd, dst);
                    } while ((n == IOStatus.INTERRUPTED) && isOpen());
                    if (n == IOStatus.UNAVAILABLE)
                        return null;
                } else {
                    bb = ByteBuffer.allocate(dst.remaining());
                    for (;;) {
                        do {
                            n = receive(fd, bb);
                        } while ((n == IOStatus.INTERRUPTED) && isOpen());
                        if (n == IOStatus.UNAVAILABLE)
                            return null;
                        InetSocketAddress isa = (InetSocketAddress)sender;
                        try {
                            security.checkAccept(
                                isa.getAddress().getHostAddress(),
                                isa.getPort());
                        } catch (SecurityException se) {
                            // Ignore packet
                            bb.clear();
                            n = 0;
                            continue;
                        }
                        bb.flip();
                        dst.put(bb);
                        break;
                    }
                }
                return sender;
            } finally {
                readerThread = 0;
                end((n > 0) || (n == IOStatus.UNAVAILABLE));
                assert IOStatus.check(n);
            }
        }
    }

    private int receive(FileDescriptor fd, ByteBuffer dst)
        throws IOException
    {
        int pos = dst.position();
        int lim = dst.limit();
        assert (pos <= lim);
        int rem = (pos <= lim ? lim - pos : 0);
        if (dst.hasArray() && rem > 0)
            return receiveIntoManagedBuffer(fd, dst, rem, pos);

        // Substitute a managed buffer. If the supplied buffer is empty
        // we must instead use a nonempty buffer, otherwise the call
        // will not block waiting for a datagram on some platforms.
        int newSize = Math.max(rem, 1);
        ByteBuffer bb = ByteBuffer.allocate(newSize);
        try {
            int n = receiveIntoManagedBuffer(fd, bb, newSize, 0);
            bb.flip();
            if (n > 0 && rem > 0)
                dst.put(bb);
            return n;
        } finally {
        }
    }

    private int receiveIntoManagedBuffer(FileDescriptor fd, ByteBuffer bb,
                                        int rem, int pos)
        throws IOException
    {
        int n = receive0(fd, bb.array(), bb.arrayOffset() + pos, rem,
                         isConnected());
        if (n > 0)
            bb.position(pos + n);
        return n;
    }

    public int send(ByteBuffer src, SocketAddress target)
        throws IOException
    {
        if (src == null)
            throw new NullPointerException();

        synchronized (writeLock) {
            ensureOpen();
            InetSocketAddress isa = Net.checkAddress(target);
            InetAddress ia = isa.getAddress();
            if (ia == null)
                throw new IOException("Target address not resolved");
            synchronized (stateLock) {
                if (!isConnected()) {
                    if (target == null)
                        throw new NullPointerException();
                    SecurityManager sm = System.getSecurityManager();
                    if (sm != null) {
                        if (ia.isMulticastAddress()) {
                            sm.checkMulticast(ia);
                        } else {
                            sm.checkConnect(ia.getHostAddress(),
                                            isa.getPort());
                        }
                    }
                } else { // Connected case; Check address then write
                    if (!target.equals(remoteAddress)) {
                        throw new IllegalArgumentException(
                            "Connected address not equal to target address");
                    }
                    return write(src);
                }
            }

            int n = 0;
            try {
                begin();
                if (!isOpen())
                    return 0;
                writerThread = NativeThread.current();
                do {
                    n = send(fd, src, isa);
                } while ((n == IOStatus.INTERRUPTED) && isOpen());

                synchronized (stateLock) {
                    if (isOpen() && (localAddress == null)) {
                        localAddress = Net.localAddress(fd);
                    }
                }
                return IOStatus.normalize(n);
            } finally {
                writerThread = 0;
                end((n > 0) || (n == IOStatus.UNAVAILABLE));
                assert IOStatus.check(n);
            }
        }
    }

    private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
        throws IOException
    {
        if (src.hasArray())
            return sendFromManagedBuffer(fd, src, target);

        // Substitute a managed buffer
        int pos = src.position();
        int lim = src.limit();
        assert (pos <= lim);
        int rem = (pos <= lim ? lim - pos : 0);

        ByteBuffer bb = ByteBuffer.allocate(rem);
        try {
            bb.put(src);
            bb.flip();
            // Do not update src until we see how many bytes were written
            src.position(pos);

            int n = sendFromManagedBuffer(fd, bb, target);
            if (n > 0) {
                // now update src
                src.position(pos + n);
            }
            return n;
        } finally {
        }
    }

    private int sendFromManagedBuffer(FileDescriptor fd, ByteBuffer bb,
                                     InetSocketAddress target)
        throws IOException
    {
        int pos = bb.position();
        int lim = bb.limit();
        assert (pos <= lim);
        int rem = (pos <= lim ? lim - pos : 0);

        boolean preferIPv6 = (family != StandardProtocolFamily.INET);
        int written;
        try {
            written = send0(preferIPv6, fd, bb.array(), bb.arrayOffset() + pos,
                            rem, target.getAddress(), target.getPort());
        } catch (PortUnreachableException pue) {
            if (isConnected())
                throw pue;
            written = rem;
        }
        if (written > 0)
            bb.position(pos + written);
        return written;
    }

    public int read(ByteBuffer buf) throws IOException {
        if (buf == null)
            throw new NullPointerException();
        synchronized (readLock) {
            synchronized (stateLock) {
                ensureOpen();
                if (!isConnected())
                    throw new NotYetConnectedException();
            }
            int n = 0;
            try {
                begin();
                if (!isOpen())
                    return 0;
                readerThread = NativeThread.current();
                do {
                    n = IOUtil.read(fd, buf, -1, nd);
                } while ((n == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(n);
            } finally {
                readerThread = 0;
                end((n > 0) || (n == IOStatus.UNAVAILABLE));
                assert IOStatus.check(n);
            }
        }
    }

    public long read(ByteBuffer[] dsts, int offset, int length)
        throws IOException
    {
        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
            throw new IndexOutOfBoundsException();
        synchronized (readLock) {
            synchronized (stateLock) {
                ensureOpen();
                if (!isConnected())
                    throw new NotYetConnectedException();
            }
            long n = 0;
            try {
                begin();
                if (!isOpen())
                    return 0;
                readerThread = NativeThread.current();
                do {
                    n = IOUtil.read(fd, dsts, offset, length, nd);
                } while ((n == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(n);
            } finally {
                readerThread = 0;
                end((n > 0) || (n == IOStatus.UNAVAILABLE));
                assert IOStatus.check(n);
            }
        }
    }

    public int write(ByteBuffer buf) throws IOException {
        if (buf == null)
            throw new NullPointerException();
        synchronized (writeLock) {
            synchronized (stateLock) {
                ensureOpen();
                if (!isConnected())
                    throw new NotYetConnectedException();
            }
            int n = 0;
            try {
                begin();
                if (!isOpen())
                    return 0;
                writerThread = NativeThread.current();
                do {
                    n = IOUtil.write(fd, buf, -1, nd);
                } while ((n == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(n);
            } finally {
                writerThread = 0;
                end((n > 0) || (n == IOStatus.UNAVAILABLE));
                assert IOStatus.check(n);
            }
        }
    }

    public long write(ByteBuffer[] srcs, int offset, int length)
        throws IOException
    {
        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))
            throw new IndexOutOfBoundsException();
        synchronized (writeLock) {
            synchronized (stateLock) {
                ensureOpen();
                if (!isConnected())
                    throw new NotYetConnectedException();
            }
            long n = 0;
            try {
                begin();
                if (!isOpen())
                    return 0;
                writerThread = NativeThread.current();
                do {
                    n = IOUtil.write(fd, srcs, offset, length, nd);
                } while ((n == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(n);
            } finally {
                writerThread = 0;
                end((n > 0) || (n == IOStatus.UNAVAILABLE));
                assert IOStatus.check(n);
            }
        }
    }

    protected void implConfigureBlocking(boolean block) throws IOException {
        IOUtil.configureBlocking(fd, block);
    }

    public SocketAddress localAddress() {
        synchronized (stateLock) {
            return localAddress;
        }
    }

    public SocketAddress remoteAddress() {
        synchronized (stateLock) {
            return remoteAddress;
        }
    }

    @@Override
    public DatagramChannel bind(SocketAddress local) throws IOException {
        synchronized (readLock) {
            synchronized (writeLock) {
                synchronized (stateLock) {
                    ensureOpen();
                    if (localAddress != null)
                        throw new AlreadyBoundException();
                    InetSocketAddress isa;
                    if (local == null) {
                        // only Inet4Address allowed with IPv4 socket
                        if (family == StandardProtocolFamily.INET) {
                            isa = new InetSocketAddress(InetAddress.getByName("0.0.0.0"), 0);
                        } else {
                            isa = new InetSocketAddress(0);
                        }
                    } else {
                        isa = Net.checkAddress(local);

                        // only Inet4Address allowed with IPv4 socket
                        if (family == StandardProtocolFamily.INET) {
                            InetAddress addr = isa.getAddress();
                            if (!(addr instanceof Inet4Address))
                                throw new UnsupportedAddressTypeException();
                        }
                    }
                    SecurityManager sm = System.getSecurityManager();
                    if (sm != null) {
                        sm.checkListen(isa.getPort());
                    }
                    Net.bind(family, fd, isa.getAddress(), isa.getPort());
                    localAddress = Net.localAddress(fd);
                }
            }
        }
        return this;
    }

    public boolean isConnected() {
        synchronized (stateLock) {
            return (state == ST_CONNECTED);
        }
    }

    void ensureOpenAndUnconnected() throws IOException { // package-private
        synchronized (stateLock) {
            if (!isOpen())
                throw new ClosedChannelException();
            if (state != ST_UNCONNECTED)
                throw new IllegalStateException("Connect already invoked");
        }
    }

    @@Override
    public DatagramChannel connect(SocketAddress sa) throws IOException {
        int localPort = 0;

        synchronized(readLock) {
            synchronized(writeLock) {
                synchronized (stateLock) {
                    ensureOpenAndUnconnected();
                    InetSocketAddress isa = Net.checkAddress(sa);
                    SecurityManager sm = System.getSecurityManager();
                    if (sm != null)
                        sm.checkConnect(isa.getAddress().getHostAddress(),
                                        isa.getPort());
                    int n = Net.connect(family,
                                        fd,
                                        isa.getAddress(),
                                        isa.getPort());
                    if (n <= 0)
                        throw new Error();      // Can't happen

                    // Connection succeeded; disallow further invocation
                    state = ST_CONNECTED;
                    remoteAddress = isa;
                    sender = isa;
                    cachedSenderInetAddress = isa.getAddress();
                    cachedSenderPort = isa.getPort();

                    // set or refresh local address
                    localAddress = Net.localAddress(fd);

                    // flush any packets already received.
                    boolean blocking = false;
                    synchronized (blockingLock()) {
                        try {
                            blocking = isBlocking();
                            // remainder of each packet thrown away
                            ByteBuffer tmpBuf = ByteBuffer.allocate(1);
                            if (blocking) {
                                configureBlocking(false);
                            }
                            do {
                                tmpBuf.clear();
                            } while (receive(tmpBuf) != null);
                        } finally {
                            if (blocking) {
                                configureBlocking(true);
                            }
                        }
                    }
                }
            }
        }
        return this;
    }

    public DatagramChannel disconnect() throws IOException {
        synchronized(readLock) {
            synchronized(writeLock) {
                synchronized (stateLock) {
                    if (!isConnected() || !isOpen())
                        return this;
                    InetSocketAddress isa = remoteAddress;
                    SecurityManager sm = System.getSecurityManager();
                    if (sm != null)
                        sm.checkConnect(isa.getAddress().getHostAddress(),
                                        isa.getPort());
                    boolean isIPv6 = (family == StandardProtocolFamily.INET6);
                    disconnect0(fd, isIPv6);
                    remoteAddress = null;
                    state = ST_UNCONNECTED;

                    // refresh local address
                    localAddress = Net.localAddress(fd);
                }
            }
        }
        return this;
    }

    /**
     * Joins channel's socket to the given group/interface and
     * optional source address.
     */
    private MembershipKey innerJoin(InetAddress group,
                                    NetworkInterface interf,
                                    InetAddress source)
        throws IOException
    {
        if (!group.isMulticastAddress())
            throw new IllegalArgumentException("Group not a multicast address");

        // check multicast address is compatible with this socket
        if (group instanceof Inet4Address) {
            if (family == StandardProtocolFamily.INET6 && !Net.canIPv6SocketJoinIPv4Group())
                throw new IllegalArgumentException("IPv6 socket cannot join IPv4 multicast group");
        } else if (group instanceof Inet6Address) {
            if (family != StandardProtocolFamily.INET6)
                throw new IllegalArgumentException("Only IPv6 sockets can join IPv6 multicast group");
        } else {
            throw new IllegalArgumentException("Address type not supported");
        }

        // check source address
        if (source != null) {
            if (source.isAnyLocalAddress())
                throw new IllegalArgumentException("Source address is a wildcard address");
            if (source.isMulticastAddress())
                throw new IllegalArgumentException("Source address is multicast address");
            if (source.getClass() != group.getClass())
                throw new IllegalArgumentException("Source address is different type to group");
        }

        SecurityManager sm = System.getSecurityManager();
        if (sm != null)
            sm.checkMulticast(group);

        synchronized (stateLock) {
            if (!isOpen())
                throw new ClosedChannelException();

            // check the registry to see if we are already a member of the group
            if (registry == null) {
                registry = new MembershipRegistry();
            } else {
                // return existing membership key
                MembershipKey key = registry.checkMembership(group, interf, source);
                if (key != null)
                    return key;
            }

            MembershipKeyImpl key;
            if ((family == StandardProtocolFamily.INET6) &&
                ((group instanceof Inet6Address) || Net.canJoin6WithIPv4Group()))
            {
                int index = interf.getIndex();
                if (index == -1)
                    throw new IOException("Network interface cannot be identified");

                // need multicast and source address as byte arrays
                byte[] groupAddress = Net.inet6AsByteArray(group);
                byte[] sourceAddress = (source == null) ? null :
                    Net.inet6AsByteArray(source);

                // join the group
                int n = Net.join6(fd, groupAddress, index, sourceAddress);
                if (n == IOStatus.UNAVAILABLE)
                    throw new UnsupportedOperationException();

                key = new MembershipKeyImpl.Type6(this, group, interf, source,
                                                  groupAddress, index, sourceAddress);

            } else {
                // need IPv4 address to identify interface
                Inet4Address target = Net.anyInet4Address(interf);
                if (target == null)
                    throw new IOException("Network interface not configured for IPv4");

                int groupAddress = Net.inet4AsInt(group);
                int targetAddress = Net.inet4AsInt(target);
                int sourceAddress = (source == null) ? 0 : Net.inet4AsInt(source);

                // join the group
                int n = Net.join4(fd, groupAddress, targetAddress, sourceAddress);
                if (n == IOStatus.UNAVAILABLE)
                    throw new UnsupportedOperationException();

                key = new MembershipKeyImpl.Type4(this, group, interf, source,
                                                  groupAddress, targetAddress, sourceAddress);
            }

            registry.add(key);
            return key;
        }
    }

    @@Override
    public MembershipKey join(InetAddress group,
                              NetworkInterface interf)
        throws IOException
    {
        return innerJoin(group, interf, null);
    }

    @@Override
    public MembershipKey join(InetAddress group,
                              NetworkInterface interf,
                              InetAddress source)
        throws IOException
    {
        if (source == null)
            throw new NullPointerException("source address is null");
        return innerJoin(group, interf, source);
    }

    // package-private
    void drop(MembershipKeyImpl key) {
        assert key.channel() == this;

        synchronized (stateLock) {
            if (!key.isValid())
                return;

            try {
                if (key instanceof MembershipKeyImpl.Type6) {
                    MembershipKeyImpl.Type6 key6 =
                        (MembershipKeyImpl.Type6)key;
                    Net.drop6(fd, key6.groupAddress(), key6.index(), key6.source());
                } else {
                    MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4)key;
                    Net.drop4(fd, key4.groupAddress(), key4.interfaceAddress(),
                        key4.source());
                }
            } catch (IOException ioe) {
                // should not happen
                throw new AssertionError(ioe);
            }

            key.invalidate();
            registry.remove(key);
        }
    }

    /**
     * Block datagrams from given source if a memory to receive all
     * datagrams.
     */
    void block(MembershipKeyImpl key, InetAddress source)
        throws IOException
    {
        assert key.channel() == this;
        assert key.sourceAddress() == null;

        synchronized (stateLock) {
            if (!key.isValid())
                throw new IllegalStateException("key is no longer valid");
            if (source.isAnyLocalAddress())
                throw new IllegalArgumentException("Source address is a wildcard address");
            if (source.isMulticastAddress())
                throw new IllegalArgumentException("Source address is multicast address");
            if (source.getClass() != key.group().getClass())
                throw new IllegalArgumentException("Source address is different type to group");

            int n;
            if (key instanceof MembershipKeyImpl.Type6) {
                 MembershipKeyImpl.Type6 key6 =
                    (MembershipKeyImpl.Type6)key;
                n = Net.block6(fd, key6.groupAddress(), key6.index(),
                               Net.inet6AsByteArray(source));
            } else {
                MembershipKeyImpl.Type4 key4 =
                    (MembershipKeyImpl.Type4)key;
                n = Net.block4(fd, key4.groupAddress(), key4.interfaceAddress(),
                               Net.inet4AsInt(source));
            }
            if (n == IOStatus.UNAVAILABLE) {
                // ancient kernel
                throw new UnsupportedOperationException();
            }
        }
    }

    /**
     * Unblock given source.
     */
    void unblock(MembershipKeyImpl key, InetAddress source) {
        assert key.channel() == this;
        assert key.sourceAddress() == null;

        synchronized (stateLock) {
            if (!key.isValid())
                throw new IllegalStateException("key is no longer valid");

            try {
                if (key instanceof MembershipKeyImpl.Type6) {
                    MembershipKeyImpl.Type6 key6 =
                        (MembershipKeyImpl.Type6)key;
                    Net.unblock6(fd, key6.groupAddress(), key6.index(),
                                 Net.inet6AsByteArray(source));
                } else {
                    MembershipKeyImpl.Type4 key4 =
                        (MembershipKeyImpl.Type4)key;
                    Net.unblock4(fd, key4.groupAddress(), key4.interfaceAddress(),
                                 Net.inet4AsInt(source));
                }
            } catch (IOException ioe) {
                // should not happen
                throw new AssertionError(ioe);
            }
        }
    }

    protected void implCloseSelectableChannel() throws IOException {
        synchronized (stateLock) {
            if (state != ST_KILLED)
                nd.preClose(fd);
            ResourceManager.afterUdpClose();

            // if member of mulitcast group then invalidate all keys
            if (registry != null)
                registry.invalidateAll();

            long th;
            if ((th = readerThread) != 0)
                NativeThread.signal(th);
            if ((th = writerThread) != 0)
                NativeThread.signal(th);
            if (!isRegistered())
                kill();
        }
    }

    public void kill() throws IOException {
        synchronized (stateLock) {
            if (state == ST_KILLED)
                return;
            if (state == ST_UNINITIALIZED) {
                state = ST_KILLED;
                return;
            }
            assert !isOpen() && !isRegistered();
            nd.close(fd);
            state = ST_KILLED;
        }
    }

    /**
     * Translates native poll revent set into a ready operation set
     */
    public boolean translateReadyOps(int ops, int initialOps,
                                     SelectionKeyImpl sk) {
        int intOps = sk.nioInterestOps(); // Do this just once, it synchronizes
        int oldOps = sk.nioReadyOps();
        int newOps = initialOps;

        if ((ops & Net.POLLNVAL) != 0) {
            // This should only happen if this channel is pre-closed while a
            // selection operation is in progress
            // ## Throw an error if this channel has not been pre-closed
            return false;
        }

        if ((ops & (Net.POLLERR | Net.POLLHUP)) != 0) {
            newOps = intOps;
            sk.nioReadyOps(newOps);
            return (newOps & ~oldOps) != 0;
        }

        if (((ops & Net.POLLIN) != 0) &&
            ((intOps & SelectionKey.OP_READ) != 0))
            newOps |= SelectionKey.OP_READ;

        if (((ops & Net.POLLOUT) != 0) &&
            ((intOps & SelectionKey.OP_WRITE) != 0))
            newOps |= SelectionKey.OP_WRITE;

        sk.nioReadyOps(newOps);
        return (newOps & ~oldOps) != 0;
    }

    public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl sk) {
        return translateReadyOps(ops, sk.nioReadyOps(), sk);
    }

    public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl sk) {
        return translateReadyOps(ops, 0, sk);
    }

    // package-private
    int poll(int events, long timeout) throws IOException {
        assert Thread.holdsLock(blockingLock()) && !isBlocking();

        synchronized (readLock) {
            int n = 0;
            try {
                begin();
                synchronized (stateLock) {
                    if (!isOpen())
                        return 0;
                    readerThread = NativeThread.current();
                }
                n = Net.poll(fd, events, timeout);
            } finally {
                readerThread = 0;
                end(n > 0);
            }
            return n;
        }
    }

    /**
     * Translates an interest operation set into a native poll event set
     */
    public void translateAndSetInterestOps(int ops, SelectionKeyImpl sk) {
        int newOps = 0;

        if ((ops & SelectionKey.OP_READ) != 0)
            newOps |= Net.POLLIN;
        if ((ops & SelectionKey.OP_WRITE) != 0)
            newOps |= Net.POLLOUT;
        if ((ops & SelectionKey.OP_CONNECT) != 0)
            newOps |= Net.POLLIN;
        sk.selector.putEventOps(sk, newOps);
    }

    public FileDescriptor getFD() {
        return fd;
    }

    public int getFDVal() {
        return fdVal;
    }


    // -- Native methods --

    private static native void initIDs();

    private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
        throws IOException;

    private native int receive0(FileDescriptor fd, byte[] buf, int pos, int len,
                                boolean connected)
        throws IOException;

    private native int send0(boolean preferIPv6, FileDescriptor fd, byte[] buf, int pos,
                             int len, InetAddress addr, int port)
        throws IOException;

    static {
        IOUtil.load();
        initIDs();
    }

}
@


1.18
log
@First part of OpenJDK 8 integration.
@
text
@d36 1
d198 2
a199 9
            if (name == StandardSocketOptions.IP_TOS) {
                // IPv4 only; no-op for IPv6
                if (family == StandardProtocolFamily.INET) {
                    Net.setSocketOption(fd, family, name, value);
                }
                return this;
            }

            if (name == StandardSocketOptions.IP_MULTICAST_TTL ||
d252 2
a253 10
            if (name == StandardSocketOptions.IP_TOS) {
                // IPv4 only; always return 0 on IPv6
                if (family == StandardProtocolFamily.INET) {
                    return (T) Net.getSocketOption(fd, family, name);
                } else {
                    return (T) Integer.valueOf(0);
                }
            }

            if (name == StandardSocketOptions.IP_MULTICAST_TTL ||
d306 3
d739 20
d1044 1
a1044 1
        if ((ops & PollArrayWrapper.POLLNVAL) != 0) {
d1051 1
a1051 2
        if ((ops & (PollArrayWrapper.POLLERR
                    | PollArrayWrapper.POLLHUP)) != 0) {
d1057 1
a1057 1
        if (((ops & PollArrayWrapper.POLLIN) != 0) &&
d1061 1
a1061 1
        if (((ops & PollArrayWrapper.POLLOUT) != 0) &&
d1106 1
a1106 1
            newOps |= PollArrayWrapper.POLLIN;
d1108 1
a1108 1
            newOps |= PollArrayWrapper.POLLOUT;
d1110 1
a1110 1
            newOps |= PollArrayWrapper.POLLIN;
@


1.17
log
@Merged OpenJDK 7u40 b34, except for java.lang.invoke and sun.invoke packages.
@
text
@d2 1
a2 1
 * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
a36 1

d171 1
d1069 22
d1131 1
a1131 1
        Util.load();
@


1.16
log
@Merged 7u40 changes in sun/nio/ch/Net.java and partially merged DatagramChannelImpl.java.
@
text
@d556 1
a556 1
                    n = IOUtil.read(fd, buf, -1, nd, readLock);
d612 1
a612 1
                    n = IOUtil.write(fd, buf, -1, nd, writeLock);
@


1.15
log
@Merged OpenJDK 7u6.
@
text
@d89 2
a90 2
    private SocketAddress localAddress;
    private SocketAddress remoteAddress;
d98 6
d172 1
a172 1
            return localAddress;
d232 6
d296 6
d437 1
a437 1
            InetSocketAddress isa = (InetSocketAddress)target;
d448 1
a448 1
                            sm.checkMulticast(isa.getAddress());
d450 1
a450 1
                            sm.checkConnect(isa.getAddress().getHostAddress(),
d470 1
a470 1
                    n = send(fd, src, target);
d487 1
a487 1
    private int send(FileDescriptor fd, ByteBuffer src, SocketAddress target)
d517 1
a517 1
                                            SocketAddress target)
d529 1
a529 1
                            rem, target);
d721 1
d743 1
a743 1
                    remoteAddress = sa;
d762 1
a762 1
                    InetSocketAddress isa = (InetSocketAddress)remoteAddress;
d767 2
a768 1
                    disconnect0(fd);
d1097 1
a1097 1
    private static native void disconnect0(FileDescriptor fd)
d1104 2
a1105 2
    private native int send0(boolean preferIPv6, FileDescriptor fd, byte[] buf, int pos, int len,
                             SocketAddress sa)
@


1.14
log
@First part of forked file merge of OpenJDK 7u4 changes.
@
text
@d2 1
a2 1
 * Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
d660 6
a665 1
                        isa = new InetSocketAddress(0);
d974 2
a975 1
            nd.preClose(fd);
@


1.13
log
@Reduced the number of DatagramChannelImpl differences.
@
text
@d508 3
a510 1
        int written = send0(preferIPv6, fd, bb.array(), bb.arrayOffset() + pos,
d512 5
@


1.12
log
@Updated bulk of java.nio to OpenJDK 7.
@
text
@a45 6
    // Windows 2000 introduced a "feature" that causes it to return WSAECONNRESET from receive,
    // if a previous send resulted in an ICMP port unreachable. We disable this feature by using
    // this ioctl.
    private static final int IOC_IN = (int)0x80000000;
    private static final int IOC_VENDOR = 0x18000000;
    private static final int SIO_UDP_CONNRESET = IOC_IN | IOC_VENDOR | 12;
a111 9
            try
            {
                if (false) throw new cli.System.Net.Sockets.SocketException();
                fd.getSocket().IOControl(SIO_UDP_CONNRESET, new byte[] { 0 }, null);
            }
            catch (cli.System.Net.Sockets.SocketException x)
            {
                throw SocketUtil.convertSocketExceptionToIOException(x);
            }
a138 9
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            fd.getSocket().IOControl(SIO_UDP_CONNRESET, new byte[] { 0 }, null);
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
d316 1
a316 1
    private SocketAddress sender;       // Set by receive0 (## ugh)
d338 1
a338 1
                        n = receive0(dst);
d346 1
a346 1
                            n = receive0(bb);
d375 36
d452 1
a452 1
                    n = sendImpl(src, isa);
d469 46
d703 6
a708 15
                    try
                    {
                        if (false) throw new cli.System.Net.Sockets.SocketException();
                        if (false) throw new cli.System.ObjectDisposedException("");
                        fd.getSocket().Connect(SocketUtil.getAddressFromInetAddress(isa.getAddress()), isa.getPort());
                        fd.getSocket().IOControl(SIO_UDP_CONNRESET, new byte[] { 1 }, null);
                    }
                    catch (cli.System.Net.Sockets.SocketException x)
                    {
                        throw new SocketException(x.getMessage());
                    }
                    catch (cli.System.ObjectDisposedException x1)
                    {
                        throw new SocketException("Socket is closed");
                    }
d1062 4
a1065 18
    private static void disconnect0(FileDescriptor fd) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            fd.getSocket().Connect(new cli.System.Net.IPEndPoint(cli.System.Net.IPAddress.Any, 0));
            fd.getSocket().IOControl(SIO_UDP_CONNRESET, new byte[] { 0 }, null);
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
    }
d1067 11
a1077 58
    private int receive0(ByteBuffer bb) throws IOException
    {
        byte[] buf = new byte[bb.remaining()];
        cli.System.Net.EndPoint[] remoteEP = new cli.System.Net.EndPoint[] 
            {
                new cli.System.Net.IPEndPoint(0, 0)
            };
        InetSocketAddress addr;
        int length;
        do
        {
            for (; ; )
            {
                try
                {
                    if (false) throw new cli.System.Net.Sockets.SocketException();
                    if (false) throw new cli.System.ObjectDisposedException("");
                    length = fd.getSocket().ReceiveFrom(buf, 0, buf.length, cli.System.Net.Sockets.SocketFlags.wrap(cli.System.Net.Sockets.SocketFlags.None), remoteEP);
                    break;
                }
                catch (cli.System.Net.Sockets.SocketException x)
                {
                    if (x.get_ErrorCode() == SocketUtil.WSAECONNRESET)
                    {
                        // A previous send failed (i.e. the remote host responded with a ICMP that the port is closed) and
                        // the winsock stack helpfully lets us know this, but we only care about this when we're connected,
                        // otherwise we'll simply retry the receive (note that we use SIO_UDP_CONNRESET to prevent these
                        // WSAECONNRESET exceptions, but when switching from connected to disconnected, some can slip through).
                        if (isConnected())
                        {
                            throw new PortUnreachableException();
                        }
                        continue;
                    }
                    if (x.get_ErrorCode() == SocketUtil.WSAEMSGSIZE)
                    {
                        // The buffer size was too small for the packet, ReceiveFrom receives the part of the packet
                        // that fits in the buffer and then throws an exception, so we have to ignore the exception in this case.
                        length = buf.length;
                        break;
                    }
                    if (x.get_ErrorCode() == SocketUtil.WSAEWOULDBLOCK)
                    {
                        return IOStatus.UNAVAILABLE;
                    }
                    throw SocketUtil.convertSocketExceptionToIOException(x);
                }
                catch (cli.System.ObjectDisposedException x1)
                {
                    throw new SocketException("Socket is closed");
                }
            }
            cli.System.Net.IPEndPoint ep = (cli.System.Net.IPEndPoint)remoteEP[0];
            addr = new InetSocketAddress(SocketUtil.getInetAddressFromIPEndPoint(ep), ep.get_Port());
        } while (remoteAddress != null && !addr.equals(remoteAddress));
        sender = addr;
        bb.put(buf, 0, length);
        return length;
a1079 48
    private int sendImpl(ByteBuffer bb, InetSocketAddress addr) throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            int position = bb.position();
            byte[] buf;
            int offset;
            int length;
            if (bb.hasArray())
            {
                buf = bb.array();
                offset = bb.arrayOffset() + bb.position();
                length = bb.remaining();
            }
            else
            {
                buf = new byte[bb.remaining()];
                offset = 0;
                length = buf.length;
                bb.get(buf);
                bb.position(position);
            }
            int sent = fd.getSocket().SendTo(buf, offset, length, cli.System.Net.Sockets.SocketFlags.wrap(cli.System.Net.Sockets.SocketFlags.None), new cli.System.Net.IPEndPoint(SocketUtil.getAddressFromInetAddress(addr.getAddress()), addr.getPort()));
            if (bb.hasArray())
            {
                bb.position(position + sent);
            }
            else
            {
                bb.put(buf, 0, sent);
            }
            return sent;
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            if (x.get_ErrorCode() == SocketUtil.WSAEWOULDBLOCK)
            {
                return IOStatus.UNAVAILABLE;
            }
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
    }
@


1.11
log
@Add methods in DatagramChannelImpl for Java 7
@
text
@d2 1
a2 1
 * Copyright (c) 2001, 2006, Oracle and/or its affiliates. All rights reserved.
a27 2
import ikvm.internal.NotYetImplementedError;

d34 1
a34 4
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.lang.ref.SoftReference;
d53 3
d57 5
a61 1
    FileDescriptor fd = null;
d72 2
a73 2
    private InetAddress cachedSenderInetAddress = null;
    private int cachedSenderPort = 0;
d89 2
a90 2
    private static int ST_UNCONNECTED = 0;
    private static int ST_CONNECTED = 1;
d95 2
a96 2
    private SocketAddress localAddress = null;
    SocketAddress remoteAddress = null;
d98 2
a99 2
    // Options
    private SocketOpts.IP options = null;
d101 2
a102 2
    // Our socket adaptor, if any
    private DatagramSocket socket = null;
d114 3
a116 2
                    StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
            this.fd = Net.socket(false);
d134 1
a134 1
            throws IOException
d138 1
a138 1
                (family != StandardProtocolFamily.INET6))
d151 12
a162 1
        throw new NotYetImplementedError(); //TODO JDK7
d170 1
a170 1
                StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
d172 1
d174 1
d185 1
d194 1
d203 1
d257 1
d330 1
d349 3
a351 3
            // If socket is not bound then behave as if nothing received
            if (!isBound())             // ## NotYetBoundException ??
                return null;
d442 6
d473 1
a473 1
                    n = readImpl(buf);
d484 5
a488 3
    private long read0(ByteBuffer[] bufs) throws IOException {
        if (bufs == null)
            throw new NullPointerException();
d502 1
a502 1
                    n = readImpl(bufs);
a512 9
    public long read(ByteBuffer[] dsts, int offset, int length)
        throws IOException
    {
        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
           throw new IndexOutOfBoundsException();
        // ## Fix IOUtil.write so that we can avoid this array copy
        return read0(Util.subsequence(dsts, offset, length));
    }

d529 1
a529 1
                    n = writeImpl(buf);
d540 5
a544 3
    private long write0(ByteBuffer[] bufs) throws IOException {
        if (bufs == null)
            throw new NullPointerException();
d558 1
a558 1
                    n = writeImpl(bufs);
a568 9
    public long write(ByteBuffer[] srcs, int offset, int length)
        throws IOException
    {
        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))
            throw new IndexOutOfBoundsException();
        // ## Fix IOUtil.write so that we can avoid this array copy
        return write0(Util.subsequence(srcs, offset, length));
    }

a572 24
    public SocketOpts options() {
        synchronized (stateLock) {
            if (options == null) {
                SocketOptsImpl.Dispatcher d
                    = new SocketOptsImpl.Dispatcher() {
                            int getInt(int opt) throws IOException {
                                return Net.getIntOption(fd, opt);
                            }
                            void setInt(int opt, int arg)
                                throws IOException
                            {
                                Net.setIntOption(fd, opt, arg);
                            }
                        };
                options = new SocketOptsImpl.IP(d);
            }
            return options;
        }
    }

    public boolean isBound() {
        return Net.localPortNumber(fd) != 0;
    }

a574 10
            if (isConnected() && (localAddress == null)) {
                // Socket was not bound before connecting,
                // so ask what the address turned out to be
                localAddress = Net.localAddress(fd);
            }
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                InetSocketAddress isa = (InetSocketAddress)localAddress;
                sm.checkConnect(isa.getAddress().getHostAddress(), -1);
            }
d585 1
d591 1
a591 1
                    if (isBound())
d593 13
a605 1
                    InetSocketAddress isa = Net.checkAddress(local);
d607 1
a607 1
                    if (sm != null)
d609 2
a610 1
                    Net.bind(fd, isa.getAddress(), isa.getPort());
a633 1
        int trafficClass = 0;
d667 3
d690 3
d708 85
a792 1
        throw new NotYetImplementedError(); //TODO JDK7
d795 1
d803 1
d813 98
a910 1
    
d913 1
a913 1
            closeImpl();
d915 5
d939 1
a939 1
            closeImpl();
d1007 1
a1007 1
        throw new Error();
a1012 18
    private void closeImpl() throws IOException
    {
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            if (false) throw new cli.System.ObjectDisposedException("");
            fd.getSocket().Close();
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
        }
        catch (cli.System.ObjectDisposedException x1)
        {
            throw new SocketException("Socket is closed");
        }
    }

a1139 63

    private int readImpl(ByteBuffer bb) throws IOException
    {
        return receive0(bb);
    }

    private long readImpl(ByteBuffer[] bb) throws IOException
    {
        // This is a rather lame implementation. On .NET 2.0 we could make this more
        // efficient by using the IList<ArraySegment<byte>> overload of Socket.Send()
        long size = 0;
        for (int i = 0; i < bb.length; i++)
        {
            size += bb[i].remaining();
        }
        // UDP has a maximum packet size of 64KB
        byte[] buf = new byte[(int)Math.min(65536, size)];
        int n = receive0(ByteBuffer.wrap(buf));
        if (n <= 0)
        {
            return n;
        }
        for (int i = 0, pos = 0; i < bb.length && pos < buf.length; i++)
        {
            int len = Math.min(bb[i].remaining(), buf.length - pos);
            bb[i].put(buf, pos, len);
            pos += len;
        }
        return n;
    }

    private int writeImpl(ByteBuffer bb) throws IOException
    {
        return sendImpl(bb, (InetSocketAddress)remoteAddress);
    }

    private long writeImpl(ByteBuffer[] bb) throws IOException
    {
        // This is a rather lame implementation. On .NET 2.0 we could make this more
        // efficient by using the IList<ArraySegment<byte>> overload of Socket.Send()
        long totalWritten = 0;
        for (int i = 0; i < bb.length; i++)
        {
            try
            {
                int len = writeImpl(bb[i]);
                if (len < 0)
                {
                    return totalWritten > 0 ? totalWritten : len;
                }
                totalWritten += len;
            }
            catch (IOException x)
            {
                if (totalWritten > 0)
                {
                    return totalWritten;
                }
                throw x;
            }
        }
        return totalWritten;
    }
@


1.10
log
@dummy Constructor for Java 7
@
text
@d36 3
d61 3
d111 2
d134 14
d155 2
d169 145
d701 29
@


1.9
log
@Update to OpenJDK 6 b22.
@
text
@d28 2
d122 7
d437 1
a437 1
    public void bind(SocketAddress local) throws IOException {
d453 1
@


1.8
log
@Integrated OpenJDK 6 b21.
@
text
@d35 1
d101 16
a116 10
        this.fd = Net.socket(false);
        this.state = ST_UNCONNECTED;
        try
        {
            if (false) throw new cli.System.Net.Sockets.SocketException();
            fd.getSocket().IOControl(SIO_UDP_CONNRESET, new byte[] { 0 }, null);
        }
        catch (cli.System.Net.Sockets.SocketException x)
        {
            throw SocketUtil.convertSocketExceptionToIOException(x);
d525 1
@


1.7
log
@Moved shared socket functionality from PlainSocketImpl.java to SocketUtil.java.
@
text
@d2 1
a2 1
 * Copyright 2001-2006 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.6
log
@Oops. Turns out that Socket.Disconnect() doesn't work for datagram sockets. Connecting to IPAddress.Any, however, does.
@
text
@d109 1
a109 1
            throw PlainSocketImpl.convertSocketExceptionToIOException(x);
d471 1
a471 1
                        fd.getSocket().Connect(PlainSocketImpl.getAddressFromInetAddress(isa.getAddress()), isa.getPort());
d621 1
a621 1
            throw PlainSocketImpl.convertSocketExceptionToIOException(x);
d640 1
a640 1
            throw PlainSocketImpl.convertSocketExceptionToIOException(x);
d670 1
a670 1
                    if (x.get_ErrorCode() == Net.WSAECONNRESET)
d682 1
a682 1
                    if (x.get_ErrorCode() == Net.WSAEMSGSIZE)
d689 1
a689 1
                    if (x.get_ErrorCode() == Net.WSAEWOULDBLOCK)
d693 1
a693 1
                    throw PlainSocketImpl.convertSocketExceptionToIOException(x);
d701 1
a701 1
            addr = new InetSocketAddress(PlainSocketImpl.getInetAddressFromIPEndPoint(ep), ep.get_Port());
d732 1
a732 1
            int sent = fd.getSocket().SendTo(buf, offset, length, cli.System.Net.Sockets.SocketFlags.wrap(cli.System.Net.Sockets.SocketFlags.None), new cli.System.Net.IPEndPoint(PlainSocketImpl.getAddressFromInetAddress(addr.getAddress()), addr.getPort()));
d745 1
a745 1
            if (x.get_ErrorCode() == Net.WSAEWOULDBLOCK)
d749 1
a749 1
            throw PlainSocketImpl.convertSocketExceptionToIOException(x);
@


1.5
log
@- Implemented connect/disconnect with .NET 2.0 Connect/Disconnect API.
- Throw PortUnreachableException from receive() if we receive WSAECONNRESET while connected.
- Use  Socket.IOControl() .NET 2.0 API to disable WSAECONNRESET while not connected.
@
text
@d635 1
a635 1
            fd.getSocket().Disconnect(true);
@


1.4
log
@Merged OpenJDK 6 b10 whitespace and comment changes.
@
text
@d45 7
d102 9
d467 8
a474 3
                    // We simulate connectedness, so we don't call connect here,
                    // but if we're not yet bound, we should bind here.
                    if (!isBound())
d476 5
a480 1
                        socket().bind(null);
a481 6
                    //int n = Net.connect(fd,
                    //                    isa.getAddress(),
                    //                    isa.getPort(),
                    //                    trafficClass);
                    //if (n <= 0)
                    //    throw new Error();    // Can't happen
d631 15
a645 1
        // since we simulate connectedness, we don't need to do anything here
d673 7
a679 1
                        // the winsock stack helpfully lets us know this, but we don't care so we just retry the receive.
@


1.3
log
@Converted tabs to spaces.
@
text
@d46 1
a46 1
    FileDescriptor fd = null;   
@


1.2
log
@Implemented multi-buffer read/write and fixed connect to do a bind.
@
text
@d46 1
a46 1
    FileDescriptor fd = null;	
d90 1
a90 1
	throws IOException
d92 3
a94 3
	super(sp);
	this.fd = Net.socket(false);
	this.state = ST_UNCONNECTED;
d98 1
a98 1
	throws IOException
d100 3
a102 3
	super(sp);
	this.fd = fd;
	this.state = ST_UNCONNECTED;
d106 5
a110 5
	synchronized (stateLock) {
	    if (socket == null)
		socket = DatagramSocketAdaptor.create(this);
	    return socket;
	}
d114 2
a115 2
	if (!isOpen())
	    throw new ClosedChannelException();
d118 1
a118 1
    private SocketAddress sender;	// Set by receive0 (## ugh)
d121 5
a125 5
	if (dst.isReadOnly())
	    throw new IllegalArgumentException("Read-only buffer");
	if (dst == null)
	    throw new NullPointerException();
	synchronized (readLock) {
d128 1
a128 1
            if (!isBound())		// ## NotYetBoundException ??
d130 1
a130 1
	    int n = 0;
d132 4
a135 4
	    try {
		begin();
		if (!isOpen())
		    return null;
d137 1
a137 1
		readerThread = NativeThread.current();
d139 5
a143 5
		    do {
			n = receive0(dst);
		    } while ((n == IOStatus.INTERRUPTED) && isOpen());
		    if (n == IOStatus.UNAVAILABLE)
			return null;
d147 3
a149 3
			do {
			    n = receive0(bb);
			} while ((n == IOStatus.INTERRUPTED) && isOpen());
d168 7
a174 7
		return sender;
	    } finally {
		readerThread = 0;
		end((n > 0) || (n == IOStatus.UNAVAILABLE));
		assert IOStatus.check(n);
	    }
	}
d183 1
a183 1
	synchronized (writeLock) {
d189 16
a204 16
	    synchronized (stateLock) {
		if (!isConnected()) {
		    if (target == null)
			throw new NullPointerException();
		    SecurityManager sm = System.getSecurityManager();
		    if (sm != null) {
			if (ia.isMulticastAddress()) {
			    sm.checkMulticast(isa.getAddress());
			} else {
			    sm.checkConnect(isa.getAddress().getHostAddress(),
					    isa.getPort());
			}
		    }
		} else { // Connected case; Check address then write
		    if (!target.equals(remoteAddress)) {
			throw new IllegalArgumentException(
d206 1
a206 1
		    }
d208 2
a209 2
		}
	    }
d211 9
a219 9
	    int n = 0;
	    try {
		begin();
		if (!isOpen())
		    return 0;
		writerThread = NativeThread.current();
		do {
		    n = sendImpl(src, isa);
		} while ((n == IOStatus.INTERRUPTED) && isOpen());
d221 6
a226 6
	    } finally {
		writerThread = 0;
		end((n > 0) || (n == IOStatus.UNAVAILABLE));
		assert IOStatus.check(n);
	    }
	}
d230 24
a253 24
	if (buf == null)
	    throw new NullPointerException();
	synchronized (readLock) {
	    synchronized (stateLock) {
		ensureOpen();
		if (!isConnected())
		    throw new NotYetConnectedException();
	    }
	    int n = 0;
	    try {
		begin();
		if (!isOpen())
		    return 0;
		readerThread = NativeThread.current();
		do {
		    n = readImpl(buf);
		} while ((n == IOStatus.INTERRUPTED) && isOpen());
		return IOStatus.normalize(n);
	    } finally {
		readerThread = 0;
		end((n > 0) || (n == IOStatus.UNAVAILABLE));
		assert IOStatus.check(n);
	    }
	}
d259 22
a280 22
	synchronized (readLock) {
	    synchronized (stateLock) {
		ensureOpen();
		if (!isConnected())
		    throw new NotYetConnectedException();
	    }
	    long n = 0;
	    try {
		begin();
		if (!isOpen())
		    return 0;
		readerThread = NativeThread.current();
		do {
		    n = readImpl(bufs);
		} while ((n == IOStatus.INTERRUPTED) && isOpen());
		return IOStatus.normalize(n);
	    } finally {
		readerThread = 0;
		end((n > 0) || (n == IOStatus.UNAVAILABLE));
		assert IOStatus.check(n);
	    }
	}
d284 1
a284 1
	throws IOException
d288 2
a289 2
	// ## Fix IOUtil.write so that we can avoid this array copy
	return read0(Util.subsequence(dsts, offset, length));
d295 22
a316 22
	synchronized (writeLock) {
	    synchronized (stateLock) {
		ensureOpen();
		if (!isConnected())
		    throw new NotYetConnectedException();
	    }
	    int n = 0;
	    try {
		begin();
		if (!isOpen())
		    return 0;
		writerThread = NativeThread.current();
		do {
		    n = writeImpl(buf);
		} while ((n == IOStatus.INTERRUPTED) && isOpen());
		return IOStatus.normalize(n);
	    } finally {
		writerThread = 0;
		end((n > 0) || (n == IOStatus.UNAVAILABLE));
		assert IOStatus.check(n);
	    }
	}
d322 22
a343 22
	synchronized (writeLock) {
	    synchronized (stateLock) {
		ensureOpen();
		if (!isConnected())
		    throw new NotYetConnectedException();
	    }
	    long n = 0;
	    try {
		begin();
		if (!isOpen())
		    return 0;
		writerThread = NativeThread.current();
		do {
		    n = writeImpl(bufs);
		} while ((n == IOStatus.INTERRUPTED) && isOpen());
		return IOStatus.normalize(n);
	    } finally {
		writerThread = 0;
		end((n > 0) || (n == IOStatus.UNAVAILABLE));
		assert IOStatus.check(n);
	    }
	}
d347 1
a347 1
	throws IOException
d351 2
a352 2
	// ## Fix IOUtil.write so that we can avoid this array copy
	return write0(Util.subsequence(srcs, offset, length));
d356 1
a356 1
	IOUtil.configureBlocking(fd, block);
d360 17
a376 17
	synchronized (stateLock) {
	    if (options == null) {
		SocketOptsImpl.Dispatcher d
		    = new SocketOptsImpl.Dispatcher() {
			    int getInt(int opt) throws IOException {
				return Net.getIntOption(fd, opt);
			    }
			    void setInt(int opt, int arg)
				throws IOException
			    {
				Net.setIntOption(fd, opt, arg);
			    }
			};
		options = new SocketOptsImpl.IP(d);
	    }
	    return options;
	}
d384 13
a396 13
	synchronized (stateLock) {
	    if (isConnected() && (localAddress == null)) {
		// Socket was not bound before connecting,
		// so ask what the address turned out to be
		localAddress = Net.localAddress(fd);
	    }
	    SecurityManager sm = System.getSecurityManager();
	    if (sm != null) {
		InetSocketAddress isa = (InetSocketAddress)localAddress;
		sm.checkConnect(isa.getAddress().getHostAddress(), -1);
	    }
	    return localAddress;
	}
d400 3
a402 3
	synchronized (stateLock) {
	    return remoteAddress;
	}
d406 15
a420 15
	synchronized (readLock) {
	    synchronized (writeLock) {
		synchronized (stateLock) {
		    ensureOpen();
		    if (isBound())
			throw new AlreadyBoundException();
		    InetSocketAddress isa = Net.checkAddress(local);
		    SecurityManager sm = System.getSecurityManager();
		    if (sm != null)
			sm.checkListen(isa.getPort());
		    Net.bind(fd, isa.getAddress(), isa.getPort());
		    localAddress = Net.localAddress(fd);
		}
	    }
	}
d424 3
a426 3
	synchronized (stateLock) {
	    return (state == ST_CONNECTED);
	}
d430 6
a435 6
	synchronized (stateLock) {
	    if (!isOpen())
		throw new ClosedChannelException();
	    if (state != ST_UNCONNECTED)
		throw new IllegalStateException("Connect already invoked");
	}
d439 2
a440 2
	int trafficClass = 0;
	int localPort = 0;
d444 27
a470 27
		synchronized (stateLock) {
		    ensureOpenAndUnconnected();
		    InetSocketAddress isa = Net.checkAddress(sa);
		    SecurityManager sm = System.getSecurityManager();
		    if (sm != null)
			sm.checkConnect(isa.getAddress().getHostAddress(),
					isa.getPort());
		    // We simulate connectedness, so we don't call connect here,
		    // but if we're not yet bound, we should bind here.
		    if (!isBound())
		    {
			socket().bind(null);
		    }
		    //int n = Net.connect(fd,
		    //                    isa.getAddress(),
		    //                    isa.getPort(),
		    //                    trafficClass);
		    //if (n <= 0)
		    //    throw new Error();	// Can't happen

		    // Connection succeeded; disallow further invocation
		    state = ST_CONNECTED;
		    remoteAddress = sa;
		    sender = isa;
		    cachedSenderInetAddress = isa.getAddress();
		    cachedSenderPort = isa.getPort();
		}
d473 1
a473 1
	return this;
d479 12
a490 12
		synchronized (stateLock) {
		    if (!isConnected() || !isOpen())
			return this;
		    InetSocketAddress isa = (InetSocketAddress)remoteAddress;
		    SecurityManager sm = System.getSecurityManager();
		    if (sm != null)
			sm.checkConnect(isa.getAddress().getHostAddress(),
					isa.getPort());
		    disconnect0(fd);
		    remoteAddress = null;
		    state = ST_UNCONNECTED;
		}
d493 1
a493 1
	return this;
d497 10
a506 10
	synchronized (stateLock) {
	    closeImpl();
	    long th;
	    if ((th = readerThread) != 0)
		NativeThread.signal(th);
	    if ((th = writerThread) != 0)
		NativeThread.signal(th);
	    if (!isRegistered())
		kill();
	}
d510 4
a513 4
	synchronized (stateLock) {
	    if (state == ST_KILLED)
		return;
	    if (state == ST_UNINITIALIZED) {
d515 1
a515 1
		return;
d517 4
a520 4
	    assert !isOpen() && !isRegistered();
	    closeImpl();
	    state = ST_KILLED;
	}
d533 5
a537 5
	    // This should only happen if this channel is pre-closed while a
	    // selection operation is in progress
	    // ## Throw an error if this channel has not been pre-closed
	    return false;
	}
d586 1
a586 1
	throw new Error();
d594 14
a607 14
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    fd.getSocket().Close();
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    throw PlainSocketImpl.convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d612 1
a612 1
	// since we simulate connectedness, we don't need to do anything here
d617 2
a618 2
	byte[] buf = new byte[bb.remaining()];
	cli.System.Net.EndPoint[] remoteEP = new cli.System.Net.EndPoint[] 
d622 45
a666 45
	InetSocketAddress addr;
	int length;
	do
	{
	    for (; ; )
	    {
		try
		{
		    if (false) throw new cli.System.Net.Sockets.SocketException();
		    if (false) throw new cli.System.ObjectDisposedException("");
		    length = fd.getSocket().ReceiveFrom(buf, 0, buf.length, cli.System.Net.Sockets.SocketFlags.wrap(cli.System.Net.Sockets.SocketFlags.None), remoteEP);
		    break;
		}
		catch (cli.System.Net.Sockets.SocketException x)
		{
		    if (x.get_ErrorCode() == Net.WSAECONNRESET)
		    {
			// A previous send failed (i.e. the remote host responded with a ICMP that the port is closed) and
			// the winsock stack helpfully lets us know this, but we don't care so we just retry the receive.
			continue;
		    }
		    if (x.get_ErrorCode() == Net.WSAEMSGSIZE)
		    {
			// The buffer size was too small for the packet, ReceiveFrom receives the part of the packet
			// that fits in the buffer and then throws an exception, so we have to ignore the exception in this case.
			length = buf.length;
			break;
		    }
		    if (x.get_ErrorCode() == Net.WSAEWOULDBLOCK)
		    {
			return IOStatus.UNAVAILABLE;
		    }
		    throw PlainSocketImpl.convertSocketExceptionToIOException(x);
		}
		catch (cli.System.ObjectDisposedException x1)
		{
		    throw new SocketException("Socket is closed");
		}
	    }
	    cli.System.Net.IPEndPoint ep = (cli.System.Net.IPEndPoint)remoteEP[0];
	    addr = new InetSocketAddress(PlainSocketImpl.getInetAddressFromIPEndPoint(ep), ep.get_Port());
	} while (remoteAddress != null && !addr.equals(remoteAddress));
	sender = addr;
	bb.put(buf, 0, length);
	return length;
d671 45
a715 45
	try
	{
	    if (false) throw new cli.System.Net.Sockets.SocketException();
	    if (false) throw new cli.System.ObjectDisposedException("");
	    int position = bb.position();
	    byte[] buf;
	    int offset;
	    int length;
	    if (bb.hasArray())
	    {
		buf = bb.array();
		offset = bb.arrayOffset() + bb.position();
		length = bb.remaining();
	    }
	    else
	    {
		buf = new byte[bb.remaining()];
		offset = 0;
		length = buf.length;
		bb.get(buf);
		bb.position(position);
	    }
	    int sent = fd.getSocket().SendTo(buf, offset, length, cli.System.Net.Sockets.SocketFlags.wrap(cli.System.Net.Sockets.SocketFlags.None), new cli.System.Net.IPEndPoint(PlainSocketImpl.getAddressFromInetAddress(addr.getAddress()), addr.getPort()));
	    if (bb.hasArray())
	    {
		bb.position(position + sent);
	    }
	    else
	    {
		bb.put(buf, 0, sent);
	    }
	    return sent;
	}
	catch (cli.System.Net.Sockets.SocketException x)
	{
	    if (x.get_ErrorCode() == Net.WSAEWOULDBLOCK)
	    {
		return IOStatus.UNAVAILABLE;
	    }
	    throw PlainSocketImpl.convertSocketExceptionToIOException(x);
	}
	catch (cli.System.ObjectDisposedException x1)
	{
	    throw new SocketException("Socket is closed");
	}
d720 1
a720 1
	return receive0(bb);
d725 21
a745 21
	// This is a rather lame implementation. On .NET 2.0 we could make this more
	// efficient by using the IList<ArraySegment<byte>> overload of Socket.Send()
	long size = 0;
	for (int i = 0; i < bb.length; i++)
	{
	    size += bb[i].remaining();
	}
	// UDP has a maximum packet size of 64KB
	byte[] buf = new byte[(int)Math.min(65536, size)];
	int n = receive0(ByteBuffer.wrap(buf));
	if (n <= 0)
	{
	    return n;
	}
	for (int i = 0, pos = 0; i < bb.length && pos < buf.length; i++)
	{
	    int len = Math.min(bb[i].remaining(), buf.length - pos);
	    bb[i].put(buf, pos, len);
	    pos += len;
	}
	return n;
d750 1
a750 1
	return sendImpl(bb, (InetSocketAddress)remoteAddress);
d755 24
a778 24
	// This is a rather lame implementation. On .NET 2.0 we could make this more
	// efficient by using the IList<ArraySegment<byte>> overload of Socket.Send()
	long totalWritten = 0;
	for (int i = 0; i < bb.length; i++)
	{
	    try
	    {
		int len = writeImpl(bb[i]);
		if (len < 0)
		{
		    return totalWritten > 0 ? totalWritten : len;
		}
		totalWritten += len;
	    }
	    catch (IOException x)
	    {
		if (totalWritten > 0)
		{
		    return totalWritten;
		}
		throw x;
	    }
	}
	return totalWritten;
@


1.1
log
@- Implemented DatagramChannelImpl and PipeImpl.
- More nio fixes.
@
text
@d451 6
d725 21
a745 2
	// TODO
	throw new Error("TODO");
d755 24
a778 2
	// TODO
	throw new Error("TODO");
@

