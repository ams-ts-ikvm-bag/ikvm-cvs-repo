head	1.22;
access;
symbols
	v8_1_5717_0:1.22
	v8_1:1.22.0.2
	v8_0_5449_1:1.21
	v8_0_5449_0:1.21
	v8_0:1.21.0.2
	v7_4_5196_0:1.20
	v7_4:1.20.0.2
	v7_3:1.17.0.8
	v7_2_4630_6:1.17
	v7_2_4630_5:1.17
	v7_2_4630_4:1.17
	v7_2_4630_3:1.17
	v7_2_4630_2:1.17
	v0_46_0_4:1.12
	v7_2_4630_1:1.17
	v7_2:1.17.0.6
	v7_1_4532_2:1.17
	v7_1_4532_1:1.17
	v7_1_4532_0:1.17
	v7_1:1.17.0.4
	v7_0_4335_3:1.17
	v7_0_4335_2:1.17
	v7_0_4335_1:1.17
	v0_46_0_2:1.12
	v7_0_4335_0:1.17
	v7_0:1.17.0.2
	v0_40_0_6:1.9
	v0_40_0_5:1.9
	v0_46_0_1:1.12
	v0_46_0_0:1.12
	v0_46:1.12.0.2
	v0_36_0_14:1.3.2.2
	v0_44_0_6:1.11
	v0_44_0_5:1.11
	v0_44_0_4:1.11
	v0_44_0_3:1.11
	v0_44_0_2:1.11
	v0_42_0_7:1.9
	v0_44_0_1:1.11
	v0_44_0_0:1.11
	v0_44:1.11.0.2
	v0_42_0_6:1.9
	v0_42_0_5:1.9
	v0_42_0_4:1.9
	v0_42_0_3:1.9
	v0_42_0_2:1.9
	v0_42_0_1:1.9
	v0_42_0_0:1.9
	v0_42:1.9.0.6
	v0_40_0_3:1.9
	v0_40_0_2:1.9
	v0_40_0_1:1.9
	v0_40_0_0:1.9
	v0_40:1.9.0.4
	v0_36_0_13:1.3.2.2
	v0_38_0_1:1.9
	v0_38_0_0:1.9
	v0_38:1.9.0.2
	v0_36_0_9:1.3.2.1
	v0_36_0_7:1.3.2.1
	v0_36_0_5:1.3.2.1
	v0_36_0_4:1.3
	v0_36_0_3:1.3
	v0_36_0_2:1.3
	v0_36_0_1:1.3
	v0_36_0_0:1.3
	v0_36:1.3.0.2;
locks; strict;
comment	@# @;


1.22
date	2015.06.09.09.28.44;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.19.12.43.41;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2014.02.07.14.14.12;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2013.08.15.12.47.22;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.10.08.18.20;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2011.08.19.09.24.19;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2011.08.19.09.15.52;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2011.08.18.12.45.17;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2011.08.18.11.36.45;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.15.09.05.27;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.24.16.40.23;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.08.12.47.51;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.12.14.09.14;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.13.09.01.30;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.12.09.10.13;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.11.09.05.58;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.14.05.08.24;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.26.12.51.39;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.12.06.45.36;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.21.07.23.53;	author jfrijters;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2007.08.15.12.04.26;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.18.09.16.21;	author jfrijters;	state Exp;
branches;
next	;

1.3.2.1
date	2007.12.04.06.04.32;	author jfrijters;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2008.05.04.08.29.03;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Integrated OpenJDK 8u45.
@
text
@/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.ch;

import cli.Microsoft.Win32.SafeHandles.SafeFileHandle;
import cli.System.IntPtr;
import cli.System.IO.FileStream;
import cli.System.Runtime.InteropServices.DllImportAttribute;
import java.io.FileDescriptor;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.ClosedByInterruptException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.channels.FileLockInterruptionException;
import java.nio.channels.NonReadableChannelException;
import java.nio.channels.NonWritableChannelException;
import java.nio.channels.OverlappingFileLockException;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.List;

import sun.misc.Cleaner;
import sun.security.action.GetPropertyAction;

public class FileChannelImpl
    extends FileChannel
{
    private static final boolean win32 = ikvm.internal.Util.WINDOWS;

    // Memory allocation size for mapping buffers
    private static final long allocationGranularity = 64 * 1024;    // HACK we're using a hard coded value here that works on all mainstream platforms

    // Used to make native read and write calls
    private final FileDispatcher nd;

    // File descriptor
    private final FileDescriptor fd;

    // File access mode (immutable)
    private final boolean writable;
    private final boolean readable;
    private final boolean append;

    // Required to prevent finalization of creating stream (immutable)
    private final Object parent;

    // The path of the referenced file
    // (null if the parent stream is created with a file descriptor)
    private final String path;

    // Thread-safe set of IDs of native threads, for signalling
    private final NativeThreadSet threads = new NativeThreadSet(2);

    // Lock for operations involving position and size
    private final Object positionLock = new Object();

    private FileChannelImpl(FileDescriptor fd, String path, boolean readable,
                            boolean writable, boolean append, Object parent)
    {
        this.fd = fd;
        this.readable = readable;
        this.writable = writable;
        this.append = append;
        this.parent = parent;
        this.path = path;
        this.nd = new FileDispatcherImpl(append);
    }

    // Used by FileInputStream.getChannel() and RandomAccessFile.getChannel()
    public static FileChannel open(FileDescriptor fd, String path,
                                   boolean readable, boolean writable,
                                   Object parent)
    {
        return new FileChannelImpl(fd, path, readable, writable, false, parent);
    }

    // Used by FileOutputStream.getChannel
    public static FileChannel open(FileDescriptor fd, String path,
                                   boolean readable, boolean writable,
                                   boolean append, Object parent)
    {
        return new FileChannelImpl(fd, path, readable, writable, append, parent);
    }

    private void ensureOpen() throws IOException {
        if (!isOpen())
            throw new ClosedChannelException();
    }


    // -- Standard channel operations --

    protected void implCloseChannel() throws IOException {
        // Release and invalidate any locks that we still hold
        if (fileLockTable != null) {
            for (FileLock fl: fileLockTable.removeAll()) {
                synchronized (fl) {
                    if (fl.isValid()) {
                        nd.release(fd, fl.position(), fl.size());
                        ((FileLockImpl)fl).invalidate();
                    }
                }
            }
        }

        // signal any threads blocked on this channel
        threads.signalAndWait();

        if (parent != null) {

            // Close the fd via the parent stream's close method.  The parent
            // will reinvoke our close method, which is defined in the
            // superclass AbstractInterruptibleChannel, but the isOpen logic in
            // that method will prevent this method from being reinvoked.
            //
            ((java.io.Closeable)parent).close();
        } else {
            nd.close(fd);
        }

    }

    public int read(ByteBuffer dst) throws IOException {
        ensureOpen();
        if (!readable)
            throw new NonReadableChannelException();
        synchronized (positionLock) {
            int n = 0;
            int ti = -1;
            try {
                begin();
                ti = threads.add();
                if (!isOpen())
                    return 0;
                do {
                    n = IOUtil.read(fd, dst, -1, nd);
                } while ((n == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(n);
            } finally {
                threads.remove(ti);
                end(n > 0);
                assert IOStatus.check(n);
            }
        }
    }

    public long read(ByteBuffer[] dsts, int offset, int length)
        throws IOException
    {
        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
            throw new IndexOutOfBoundsException();
        ensureOpen();
        if (!readable)
            throw new NonReadableChannelException();
        synchronized (positionLock) {
            long n = 0;
            int ti = -1;
            try {
                begin();
                ti = threads.add();
                if (!isOpen())
                    return 0;
                do {
                    n = IOUtil.read(fd, dsts, offset, length, nd);
                } while ((n == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(n);
            } finally {
                threads.remove(ti);
                end(n > 0);
                assert IOStatus.check(n);
            }
        }
    }

    public int write(ByteBuffer src) throws IOException {
        ensureOpen();
        if (!writable)
            throw new NonWritableChannelException();
        synchronized (positionLock) {
            int n = 0;
            int ti = -1;
            try {
                begin();
                ti = threads.add();
                if (!isOpen())
                    return 0;
                do {
                    n = IOUtil.write(fd, src, -1, nd);
                } while ((n == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(n);
            } finally {
                threads.remove(ti);
                end(n > 0);
                assert IOStatus.check(n);
            }
        }
    }

    public long write(ByteBuffer[] srcs, int offset, int length)
        throws IOException
    {
        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))
            throw new IndexOutOfBoundsException();
        ensureOpen();
        if (!writable)
            throw new NonWritableChannelException();
        synchronized (positionLock) {
            long n = 0;
            int ti = -1;
            try {
                begin();
                ti = threads.add();
                if (!isOpen())
                    return 0;
                do {
                    n = IOUtil.write(fd, srcs, offset, length, nd);
                } while ((n == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(n);
            } finally {
                threads.remove(ti);
                end(n > 0);
                assert IOStatus.check(n);
            }
        }
    }

    // -- Other operations --

    public long position() throws IOException {
        ensureOpen();
        synchronized (positionLock) {
            long p = -1;
            int ti = -1;
            try {
                begin();
                ti = threads.add();
                if (!isOpen())
                    return 0;
                do {
                    // in append-mode then position is advanced to end before writing
                    p = (append) ? nd.size(fd) : position0(fd, -1);
                } while ((p == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(p);
            } finally {
                threads.remove(ti);
                end(p > -1);
                assert IOStatus.check(p);
            }
        }
    }

    public FileChannel position(long newPosition) throws IOException {
        ensureOpen();
        if (newPosition < 0)
            throw new IllegalArgumentException();
        synchronized (positionLock) {
            long p = -1;
            int ti = -1;
            try {
                begin();
                ti = threads.add();
                if (!isOpen())
                    return null;
                do {
                    p  = position0(fd, newPosition);
                } while ((p == IOStatus.INTERRUPTED) && isOpen());
                return this;
            } finally {
                threads.remove(ti);
                end(p > -1);
                assert IOStatus.check(p);
            }
        }
    }

    public long size() throws IOException {
        ensureOpen();
        synchronized (positionLock) {
            long s = -1;
            int ti = -1;
            try {
                begin();
                ti = threads.add();
                if (!isOpen())
                    return -1;
                do {
                    s = nd.size(fd);
                } while ((s == IOStatus.INTERRUPTED) && isOpen());
                return IOStatus.normalize(s);
            } finally {
                threads.remove(ti);
                end(s > -1);
                assert IOStatus.check(s);
            }
        }
    }

    public FileChannel truncate(long newSize) throws IOException {
        ensureOpen();
        if (newSize < 0)
            throw new IllegalArgumentException("Negative size");
        if (!writable)
            throw new NonWritableChannelException();
        synchronized (positionLock) {
            int rv = -1;
            long p = -1;
            int ti = -1;
            try {
                begin();
                ti = threads.add();
                if (!isOpen())
                    return null;

                // get current size
                long size;
                do {
                    size = nd.size(fd);
                } while ((size == IOStatus.INTERRUPTED) && isOpen());
                if (!isOpen())
                    return null;

                // get current position
                do {
                    p = position0(fd, -1);
                } while ((p == IOStatus.INTERRUPTED) && isOpen());
                if (!isOpen())
                    return null;
                assert p >= 0;

                // truncate file if given size is less than the current size
                if (newSize < size) {
                    do {
                        rv = nd.truncate(fd, newSize);
                    } while ((rv == IOStatus.INTERRUPTED) && isOpen());
                    if (!isOpen())
                        return null;
                }

                // [IKVM] in append mode we're not allowed to seek backwards, but the atomic append will honor the new file size
                if (append)
                    return this;

                // if position is beyond new size then adjust it
                if (p > newSize)
                    p = newSize;
                do {
                    rv = (int)position0(fd, p);
                } while ((rv == IOStatus.INTERRUPTED) && isOpen());
                return this;
            } finally {
                threads.remove(ti);
                end(rv > -1);
                assert IOStatus.check(rv);
            }
        }
    }

    public void force(boolean metaData) throws IOException {
        ensureOpen();
        int rv = -1;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return;
            do {
                rv = nd.force(fd, metaData);
            } while ((rv == IOStatus.INTERRUPTED) && isOpen());
        } finally {
            threads.remove(ti);
            end(rv > -1);
            assert IOStatus.check(rv);
        }
    }

    private long transferToArbitraryChannel(long position, int icount,
                                            WritableByteChannel target)
        throws IOException
    {
        // Untrusted target: Use a newly-erased buffer
        int c = Math.min(icount, TRANSFER_SIZE);
        ByteBuffer bb = ByteBuffer.allocate(c);
        long tw = 0;                    // Total bytes written
        long pos = position;
        try {
            while (tw < icount) {
                bb.limit(Math.min((int)(icount - tw), TRANSFER_SIZE));
                int nr = read(bb, pos);
                if (nr <= 0)
                    break;
                bb.flip();
                // ## Bug: Will block writing target if this channel
                // ##      is asynchronously closed
                int nw = target.write(bb);
                tw += nw;
                if (nw != nr)
                    break;
                pos += nw;
                bb.clear();
            }
            return tw;
        } catch (IOException x) {
            if (tw > 0)
                return tw;
            throw x;
        }
    }

    public long transferTo(long position, long count,
                           WritableByteChannel target)
        throws IOException
    {
        ensureOpen();
        if (!target.isOpen())
            throw new ClosedChannelException();
        if (!readable)
            throw new NonReadableChannelException();
        if (target instanceof FileChannelImpl &&
            !((FileChannelImpl)target).writable)
            throw new NonWritableChannelException();
        if ((position < 0) || (count < 0))
            throw new IllegalArgumentException();
        long sz = size();
        if (position > sz)
            return 0;
        int icount = (int)Math.min(count, Integer.MAX_VALUE);
        if ((sz - position) < icount)
            icount = (int)(sz - position);

        // Slow path for untrusted targets
        return transferToArbitraryChannel(position, icount, target);
    }

    private long transferFromFileChannel(FileChannelImpl src,
                                         long position, long count)
        throws IOException
    {
        if (!src.readable)
            throw new NonReadableChannelException();
        return transferFromArbitraryChannel(src, position, count);
    }

    private static final int TRANSFER_SIZE = 8192;

    private long transferFromArbitraryChannel(ReadableByteChannel src,
                                              long position, long count)
        throws IOException
    {
        // Untrusted target: Use a newly-erased buffer
        int c = (int)Math.min(count, TRANSFER_SIZE);
        ByteBuffer bb = ByteBuffer.allocate(c);
        long tw = 0;                    // Total bytes written
        long pos = position;
        try {
            while (tw < count) {
                bb.limit((int)Math.min((count - tw), (long)TRANSFER_SIZE));
                // ## Bug: Will block reading src if this channel
                // ##      is asynchronously closed
                int nr = src.read(bb);
                if (nr <= 0)
                    break;
                bb.flip();
                int nw = write(bb, pos);
                tw += nw;
                if (nw != nr)
                    break;
                pos += nw;
                bb.clear();
            }
            return tw;
        } catch (IOException x) {
            if (tw > 0)
                return tw;
            throw x;
        }
    }

    public long transferFrom(ReadableByteChannel src,
                             long position, long count)
        throws IOException
    {
        ensureOpen();
        if (!src.isOpen())
            throw new ClosedChannelException();
        if (!writable)
            throw new NonWritableChannelException();
        if ((position < 0) || (count < 0))
            throw new IllegalArgumentException();
        if (position > size())
            return 0;
        if (src instanceof FileChannelImpl)
           return transferFromFileChannel((FileChannelImpl)src,
                                          position, count);

        return transferFromArbitraryChannel(src, position, count);
    }

    public int read(ByteBuffer dst, long position) throws IOException {
        if (dst == null)
            throw new NullPointerException();
        if (position < 0)
            throw new IllegalArgumentException("Negative position");
        if (!readable)
            throw new NonReadableChannelException();
        ensureOpen();
        if (nd.needsPositionLock()) {
            synchronized (positionLock) {
                return readInternal(dst, position);
            }
        } else {
            return readInternal(dst, position);
        }
    }

    private int readInternal(ByteBuffer dst, long position) throws IOException {
        assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
        int n = 0;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return -1;
            do {
                n = IOUtil.read(fd, dst, position, nd);
            } while ((n == IOStatus.INTERRUPTED) && isOpen());
            return IOStatus.normalize(n);
        } finally {
            threads.remove(ti);
            end(n > 0);
            assert IOStatus.check(n);
        }
    }

    public int write(ByteBuffer src, long position) throws IOException {
        if (src == null)
            throw new NullPointerException();
        if (position < 0)
            throw new IllegalArgumentException("Negative position");
        if (!writable)
            throw new NonWritableChannelException();
        ensureOpen();
        if (nd.needsPositionLock()) {
            synchronized (positionLock) {
                return writeInternal(src, position);
            }
        } else {
            return writeInternal(src, position);
        }
    }

    private int writeInternal(ByteBuffer src, long position) throws IOException {
        assert !nd.needsPositionLock() || Thread.holdsLock(positionLock);
        int n = 0;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return -1;
            do {
                n = IOUtil.write(fd, src, position, nd);
            } while ((n == IOStatus.INTERRUPTED) && isOpen());
            return IOStatus.normalize(n);
        } finally {
            threads.remove(ti);
            end(n > 0);
            assert IOStatus.check(n);
        }
    }


    // -- Memory-mapped buffers --

    private static class Unmapper
        implements Runnable
    {
        // may be required to close file
        private static final NativeDispatcher nd = new FileDispatcherImpl();

        // keep track of mapped buffer usage
        static volatile int count;
        static volatile long totalSize;
        static volatile long totalCapacity;

        private volatile long address;
        private final long size;
        private final int cap;
        private final FileDescriptor fd;

        private Unmapper(long address, long size, int cap,
                         FileDescriptor fd)
        {
            assert (address != 0);
            this.address = address;
            this.size = size;
            this.cap = cap;
            this.fd = fd;

            synchronized (Unmapper.class) {
                count++;
                totalSize += size;
                totalCapacity += cap;
            }
        }

        public void run() {
            if (address == 0)
                return;
            unmap0(address, size);
            address = 0;

            // if this mapping has a valid file descriptor then we close it
            if (fd.valid()) {
                try {
                    nd.close(fd);
                } catch (IOException ignore) {
                    // nothing we can do
                }
            }

            synchronized (Unmapper.class) {
                count--;
                totalSize -= size;
                totalCapacity -= cap;
            }
        }
    }

    private static void unmap(MappedByteBuffer bb) {
        Cleaner cl = ((DirectBuffer)bb).cleaner();
        if (cl != null)
            cl.clean();
    }

    private static final int MAP_RO = 0;
    private static final int MAP_RW = 1;
    private static final int MAP_PV = 2;

    public MappedByteBuffer map(MapMode mode, long position, long size)
        throws IOException
    {
        ensureOpen();
        if (mode == null)
            throw new NullPointerException("Mode is null");
        if (position < 0L)
            throw new IllegalArgumentException("Negative position");
        if (size < 0L)
            throw new IllegalArgumentException("Negative size");
        if (position + size < 0)
            throw new IllegalArgumentException("Position + size overflow");
        if (size > Integer.MAX_VALUE)
            throw new IllegalArgumentException("Size exceeds Integer.MAX_VALUE");

        int imode = -1;
        if (mode == MapMode.READ_ONLY)
            imode = MAP_RO;
        else if (mode == MapMode.READ_WRITE)
            imode = MAP_RW;
        else if (mode == MapMode.PRIVATE)
            imode = MAP_PV;
        assert (imode >= 0);
        if ((mode != MapMode.READ_ONLY) && !writable)
            throw new NonWritableChannelException();
        if (!readable)
            throw new NonReadableChannelException();

        long addr = -1;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return null;

            long filesize;
            do {
                filesize = nd.size(fd);
            } while ((filesize == IOStatus.INTERRUPTED) && isOpen());
            if (!isOpen())
                return null;

            if (filesize < position + size) { // Extend file size
                if (!writable) {
                    throw new IOException("Channel not open for writing " +
                        "- cannot extend file to required size");
                }
                int rv;
                do {
                    rv = nd.truncate(fd, position + size);
                } while ((rv == IOStatus.INTERRUPTED) && isOpen());
                if (!isOpen())
                    return null;
            }
            if (size == 0) {
                addr = 0;
                // a valid file descriptor is not required
                FileDescriptor dummy = new FileDescriptor();
                if ((!writable) || (imode == MAP_RO))
                    return Util.newMappedByteBufferR(0, 0, dummy, null);
                else
                    return Util.newMappedByteBuffer(0, 0, dummy, null);
            }

            int pagePosition = (int)(position % allocationGranularity);
            long mapPosition = position - pagePosition;
            long mapSize = size + pagePosition;
            try {
                // If no exception was thrown from map0, the address is valid
                addr = map0(imode, mapPosition, mapSize);
            } catch (OutOfMemoryError x) {
                // An OutOfMemoryError may indicate that we've exhausted memory
                // so force gc and re-attempt map
                System.gc();
                try {
                    Thread.sleep(100);
                } catch (InterruptedException y) {
                    Thread.currentThread().interrupt();
                }
                try {
                    addr = map0(imode, mapPosition, mapSize);
                } catch (OutOfMemoryError y) {
                    // After a second OOME, fail
                    throw new IOException("Map failed", y);
                }
            }

            // On Windows, and potentially other platforms, we need an open
            // file descriptor for some mapping operations.
            FileDescriptor mfd;
            try {
                mfd = nd.duplicateForMapping(fd);
            } catch (IOException ioe) {
                unmap0(addr, mapSize);
                throw ioe;
            }

            assert (IOStatus.checkAll(addr));
            assert (addr % allocationGranularity == 0);
            int isize = (int)size;
            Unmapper um = new Unmapper(addr, mapSize, isize, mfd);
            if ((!writable) || (imode == MAP_RO)) {
                return Util.newMappedByteBufferR(isize,
                                                 addr + pagePosition,
                                                 mfd,
                                                 um);
            } else {
                return Util.newMappedByteBuffer(isize,
                                                addr + pagePosition,
                                                mfd,
                                                um);
            }
        } finally {
            threads.remove(ti);
            end(IOStatus.checkAll(addr));
        }
    }

    /**
     * Invoked by sun.management.ManagementFactoryHelper to create the management
     * interface for mapped buffers.
     */
    public static sun.misc.JavaNioAccess.BufferPool getMappedBufferPool() {
        return new sun.misc.JavaNioAccess.BufferPool() {
            @@Override
            public String getName() {
                return "mapped";
            }
            @@Override
            public long getCount() {
                return Unmapper.count;
            }
            @@Override
            public long getTotalCapacity() {
                return Unmapper.totalCapacity;
            }
            @@Override
            public long getMemoryUsed() {
                return Unmapper.totalSize;
            }
        };
    }

    // -- Locks --



    // keeps track of locks on this file
    private volatile FileLockTable fileLockTable;

    // indicates if file locks are maintained system-wide (as per spec)
    private static boolean isSharedFileLockTable;

    // indicates if the disableSystemWideOverlappingFileLockCheck property
    // has been checked
    private static volatile boolean propertyChecked;

    // The lock list in J2SE 1.4/5.0 was local to each FileChannel instance so
    // the overlap check wasn't system wide when there were multiple channels to
    // the same file. This property is used to get 1.4/5.0 behavior if desired.
    private static boolean isSharedFileLockTable() {
        if (!propertyChecked) {
            synchronized (FileChannelImpl.class) {
                if (!propertyChecked) {
                    String value = AccessController.doPrivileged(
                        new GetPropertyAction(
                            "sun.nio.ch.disableSystemWideOverlappingFileLockCheck"));
                    isSharedFileLockTable = ((value == null) || value.equals("false"));
                    propertyChecked = true;
                }
            }
        }
        return isSharedFileLockTable;
    }

    private FileLockTable fileLockTable() throws IOException {
        if (fileLockTable == null) {
            synchronized (this) {
                if (fileLockTable == null) {
                    if (isSharedFileLockTable()) {
                        int ti = threads.add();
                        try {
                            ensureOpen();
                            fileLockTable = FileLockTable.newSharedFileLockTable(this, fd);
                        } finally {
                            threads.remove(ti);
                        }
                    } else {
                        fileLockTable = new SimpleFileLockTable();
                    }
                }
            }
        }
        return fileLockTable;
    }

    public FileLock lock(long position, long size, boolean shared)
        throws IOException
    {
        ensureOpen();
        if (shared && !readable)
            throw new NonReadableChannelException();
        if (!shared && !writable)
            throw new NonWritableChannelException();
        FileLockImpl fli = new FileLockImpl(this, position, size, shared);
        FileLockTable flt = fileLockTable();
        flt.add(fli);
        boolean completed = false;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return null;
            int n;
            do {
                n = nd.lock(fd, true, position, size, shared);
            } while ((n == FileDispatcher.INTERRUPTED) && isOpen());
            if (isOpen()) {
                if (n == FileDispatcher.RET_EX_LOCK) {
                    assert shared;
                    FileLockImpl fli2 = new FileLockImpl(this, position, size,
                                                         false);
                    flt.replace(fli, fli2);
                    fli = fli2;
                }
                completed = true;
            }
        } finally {
            if (!completed)
                flt.remove(fli);
            threads.remove(ti);
            try {
                end(completed);
            } catch (ClosedByInterruptException e) {
                throw new FileLockInterruptionException();
            }
        }
        return fli;
    }

    public FileLock tryLock(long position, long size, boolean shared)
        throws IOException
    {
        ensureOpen();
        if (shared && !readable)
            throw new NonReadableChannelException();
        if (!shared && !writable)
            throw new NonWritableChannelException();
        FileLockImpl fli = new FileLockImpl(this, position, size, shared);
        FileLockTable flt = fileLockTable();
        flt.add(fli);
        int result;

        int ti = threads.add();
        try {
            try {
                ensureOpen();
                result = nd.lock(fd, false, position, size, shared);
            } catch (IOException e) {
                flt.remove(fli);
                throw e;
            }
            if (result == FileDispatcher.NO_LOCK) {
                flt.remove(fli);
                return null;
            }
            if (result == FileDispatcher.RET_EX_LOCK) {
                assert shared;
                FileLockImpl fli2 = new FileLockImpl(this, position, size,
                                                     false);
                flt.replace(fli, fli2);
                return fli2;
            }
            return fli;
        } finally {
            threads.remove(ti);
        }
    }

    void release(FileLockImpl fli) throws IOException {
        int ti = threads.add();
        try {
            ensureOpen();
            nd.release(fd, fli.position(), fli.size());
        } finally {
            threads.remove(ti);
        }
        assert fileLockTable != null;
        fileLockTable.remove(fli);
    }

    // -- File lock support --

    /**
     * A simple file lock table that maintains a list of FileLocks obtained by a
     * FileChannel. Use to get 1.4/5.0 behaviour.
     */
    private static class SimpleFileLockTable extends FileLockTable {
        // synchronize on list for access
        private final List<FileLock> lockList = new ArrayList<FileLock>(2);

        public SimpleFileLockTable() {
        }

        private void checkList(long position, long size)
            throws OverlappingFileLockException
        {
            assert Thread.holdsLock(lockList);
            for (FileLock fl: lockList) {
                if (fl.overlaps(position, size)) {
                    throw new OverlappingFileLockException();
                }
            }
        }

        public void add(FileLock fl) throws OverlappingFileLockException {
            synchronized (lockList) {
                checkList(fl.position(), fl.size());
                lockList.add(fl);
            }
        }

        public void remove(FileLock fl) {
            synchronized (lockList) {
                lockList.remove(fl);
            }
        }

        public List<FileLock> removeAll() {
            synchronized(lockList) {
                List<FileLock> result = new ArrayList<FileLock>(lockList);
                lockList.clear();
                return result;
            }
        }

        public void replace(FileLock fl1, FileLock fl2) {
            synchronized (lockList) {
                lockList.remove(fl1);
                lockList.add(fl2);
            }
        }
    }

    // -- Native methods --

    // Creates a new mapping
    private long map0(int prot, long position, long length) throws IOException
    {
        FileStream fs = (FileStream)fd.getStream();
        if (win32)
            return mapViewOfFileWin32(fs, prot, position, length);
        else
            return mapViewOfFilePosix(fs, prot, position, length);
    }

    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    private static long mapViewOfFileWin32(FileStream fs, int prot, long position, long length) throws IOException
    {
        try
        {
            int PAGE_READONLY = 2;
            int PAGE_READWRITE = 4;
            int PAGE_WRITECOPY = 8;
            
            int FILE_MAP_WRITE = 2;
            int FILE_MAP_READ = 4;
            int FILE_MAP_COPY = 1;

            int fileProtect;
            int mapAccess;

            switch (prot)
            {
                case MAP_RO:
                    fileProtect = PAGE_READONLY;
                    mapAccess = FILE_MAP_READ;
                    break;
                case MAP_RW:
                    fileProtect = PAGE_READWRITE;
                    mapAccess = FILE_MAP_WRITE;
                    break;
                case MAP_PV:
                    fileProtect = PAGE_WRITECOPY;
                    mapAccess = FILE_MAP_COPY;
                    break;
                default:
                    throw new Error();
            }

            long maxSize = length + position;
            SafeFileHandle hFileMapping = CreateFileMapping(fs.get_SafeFileHandle(), IntPtr.Zero, fileProtect, (int)(maxSize >> 32), (int)maxSize, null);
            int err = cli.System.Runtime.InteropServices.Marshal.GetLastWin32Error();
            if (hFileMapping.get_IsInvalid())
            {
                throw new IOException("Win32 error " + err);
            }
            IntPtr p = MapViewOfFile(hFileMapping, mapAccess, (int)(position >> 32), (int)position, IntPtr.op_Explicit(length));
            err = cli.System.Runtime.InteropServices.Marshal.GetLastWin32Error();
            hFileMapping.Close();
            if (p.Equals(IntPtr.Zero))
            {
                if (err == 8 /*ERROR_NOT_ENOUGH_MEMORY*/)
                {
                    throw new OutOfMemoryError("Map failed");
                }
                throw new IOException("Win32 error " + err);
            }
            cli.System.GC.AddMemoryPressure(length);
            return p.ToInt64();
        }
        finally
        {
            cli.System.GC.KeepAlive(fs);
        }
    }

    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    private static long mapViewOfFilePosix(FileStream fs, int prot, long position, long length) throws IOException
    {
        byte writeable = prot != MAP_RO ? (byte)1 : (byte)0;
        byte copy_on_write = prot == MAP_PV ? (byte)1 : (byte)0;
        IntPtr p = ikvm_mmap(fs.get_SafeFileHandle(), writeable, copy_on_write, position, (int)length);
        cli.System.GC.KeepAlive(fs);
        // HACK ikvm_mmap should really be changed to return a null pointer on failure,
        // instead of whatever MAP_FAILED is defined to on the particular system we're running on,
        // common values for MAP_FAILED are 0 and -1, so we test for these.
        if (p.Equals(IntPtr.Zero) || p.Equals(new IntPtr(-1)))
        {
            throw new IOException("file mapping failed");
        }
        cli.System.GC.AddMemoryPressure(length);
        return p.ToInt64();
    }

    @@DllImportAttribute.Annotation(value="kernel32", SetLastError=true)
    private static native SafeFileHandle CreateFileMapping(SafeFileHandle hFile, IntPtr lpAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, String lpName);

    @@DllImportAttribute.Annotation(value="kernel32", SetLastError=true)
    private static native IntPtr MapViewOfFile(SafeFileHandle hFileMapping, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);

    @@DllImportAttribute.Annotation("kernel32")
    private static native int UnmapViewOfFile(IntPtr lpBaseAddress);

    @@DllImportAttribute.Annotation("ikvm-native")
    private static native int ikvm_munmap(IntPtr address, int size);

    @@DllImportAttribute.Annotation("ikvm-native")
    private static native IntPtr ikvm_mmap(SafeFileHandle handle, byte writeable, byte copy_on_write, long position, int size);

    // Removes an existing mapping
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    static int unmap0(long address, long length)
    {
        if (win32)
            UnmapViewOfFile(IntPtr.op_Explicit(address));
        else
            ikvm_munmap(IntPtr.op_Explicit(address), (int)length);
        cli.System.GC.RemoveMemoryPressure(length);
        return 0;
    }

    // Sets or reports this file's position
    // If offset is -1, the current position is returned
    // otherwise the position is set to offset
    private static long position0(FileDescriptor fd, long offset) throws IOException
    {
        if (offset == -1)
        {
            return fd.getFilePointer();
        }
        fd.seek(offset);
        return offset;
    }
}
@


1.21
log
@First part of OpenJDK 8 integration.
@
text
@d36 11
a46 1
import java.nio.channels.*;
d49 1
a49 1
import java.security.AccessController;
d75 4
d85 1
a85 1
    private FileChannelImpl(FileDescriptor fd, boolean readable,
d93 1
d98 1
a98 1
    public static FileChannel open(FileDescriptor fd,
d102 1
a102 1
        return new FileChannelImpl(fd, readable, writable, false, parent);
d106 1
a106 1
    public static FileChannel open(FileDescriptor fd,
d110 1
a110 1
        return new FileChannelImpl(fd, readable, writable, append, parent);
d134 1
a134 1
        nd.preClose(fd);
@


1.20
log
@Merged OpenJDK 7u40 b34, except for java.lang.invoke and sun.invoke packages.
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
a40 1
import sun.misc.IoTrace;
a64 3
    // The path of the referenced file (null if the parent stream is created with a file descriptor)
    private final String path;

d71 1
a71 1
    private FileChannelImpl(FileDescriptor fd, String path, boolean readable,
a78 1
        this.path = path;
d83 1
a83 1
    public static FileChannel open(FileDescriptor fd, String path,
d87 1
a87 1
        return new FileChannelImpl(fd, path, readable, writable, false, parent);
d91 1
a91 1
    public static FileChannel open(FileDescriptor fd, String path,
d95 1
a95 1
        return new FileChannelImpl(fd, path, readable, writable, append, parent);
a142 1
            Object traceContext = IoTrace.fileReadBegin(path);
a153 1
                IoTrace.fileReadEnd(traceContext, n > 0 ? n : 0);
a170 1
            Object traceContext = IoTrace.fileReadBegin(path);
a181 1
                IoTrace.fileReadEnd(traceContext, n > 0 ? n : 0);
a194 1
            Object traceContext = IoTrace.fileWriteBegin(path);
a206 1
                IoTrace.fileWriteEnd(traceContext, n > 0 ? n : 0);
a222 1
            Object traceContext = IoTrace.fileWriteBegin(path);
a233 1
                IoTrace.fileWriteEnd(traceContext, n > 0 ? n : 0);
d311 1
a311 1
    public FileChannel truncate(long size) throws IOException {
d313 2
a314 4
        if (size < 0)
            throw new IllegalArgumentException();
        if (size > size())
            return this;
d327 8
d343 8
a350 6
                // truncate file
                do {
                    rv = nd.truncate(fd, size);
                } while ((rv == IOStatus.INTERRUPTED) && isOpen());
                if (!isOpen())
                    return null;
d356 3
a358 3
                // set position to size if greater than size
                if (p > size)
                    p = size;
a532 1
        Object traceContext = IoTrace.fileReadBegin(path);
a543 1
            IoTrace.fileReadEnd(traceContext, n > 0 ? n : 0);
a569 1
        Object traceContext = IoTrace.fileWriteBegin(path);
a581 1
            IoTrace.fileWriteEnd(traceContext, n > 0 ? n : 0);
d658 2
d668 1
d689 9
a697 1
            if (size() < position + size) { // Extend file size
d706 2
@


1.19
log
@Merged IoTrace hooks.
@
text
@d155 1
a155 1
                    n = IOUtil.read(fd, dst, -1, nd, positionLock);
d211 1
a211 1
                    n = IOUtil.write(fd, src, -1, nd, positionLock);
d525 11
d545 1
a545 1
                n = IOUtil.read(fd, dst, position, nd, positionLock);
d564 11
d584 1
a584 1
                n = IOUtil.write(fd, src, position, nd, positionLock);
@


1.18
log
@Removed unused imports.
@
text
@d41 1
d66 3
d75 1
a75 1
    private FileChannelImpl(FileDescriptor fd, boolean readable,
d83 1
d88 1
a88 1
    public static FileChannel open(FileDescriptor fd,
d92 1
a92 1
        return new FileChannelImpl(fd, readable, writable, false, parent);
d96 1
a96 1
    public static FileChannel open(FileDescriptor fd,
d100 1
a100 1
        return new FileChannelImpl(fd, readable, writable, append, parent);
d148 1
d160 1
d178 1
d190 1
d204 1
d217 1
d234 1
d246 1
d527 1
d539 1
d555 1
d568 1
@


1.17
log
@Fixed several append issues:
- FileChannelImpl.truncate() should not attempt to seek (would throw an exception)
- FileDispatcherImpl.write() doesn't need to seek to EOF
- FileDispatcherImpl.truncate() can't use fd.setLength() to truncate on append FileStream, so we open the file again to truncate it
- NetFileSystemProvider.newFileChannel() should not set FileSystemRights.Write in append mode
@
text
@a31 2
import cli.System.Runtime.InteropServices.StructLayoutAttribute;
import cli.System.Runtime.InteropServices.LayoutKind;
@


1.16
log
@Fix to make sure that FileChannel.transferFrom() throws a NonReadableChannelException when the source is a write-only FileChannel.
@
text
@d346 4
@


1.15
log
@Moved FileChannelImpl read/write operations to NativeDispatcher.
@
text
@d438 9
d495 3
@


1.14
log
@Reduce the number of differences in FileChannelImpl.
@
text
@d150 3
a152 1
                n = readImpl(dst);
d178 3
a180 1
                n = readImpl(dsts, offset, length);
d202 3
a204 3
                if (append)
                    position(size());
                n = writeImpl(src);
d230 3
a232 3
                if (append)
                    position(size());
                n = writeImpl(srcs, offset, length);
d505 3
a507 1
            n = readImpl(dst, position);
d531 3
a533 1
            n = writeImpl(src, position);
a944 141
    private int readImpl(ByteBuffer dst) throws IOException
    {
        if (dst.hasArray())
        {
            byte[] buf = dst.array();
            int len = fd.readBytes(buf, dst.arrayOffset() + dst.position(), dst.remaining());
            if (len > 0)
            {
                dst.position(dst.position() + len);
            }
            return len;
        }
        else
        {
            byte[] buf = new byte[dst.remaining()];
            int len = fd.readBytes(buf, 0, buf.length);
            if (len > 0)
            {
                dst.put(buf, 0, len);
            }
            return len;
        }
    }

    private int readImpl(ByteBuffer dst, long position) throws IOException
    {
        synchronized (positionLock)
        {
            long prev = position0(fd, -1);
            try
            {
                position0(fd, position);
                return readImpl(dst);
            }
            finally
            {
                position0(fd, prev);
            }
        }
    }

    private long readImpl(ByteBuffer[] dsts, int offset, int length) throws IOException
    {
        long totalRead = 0;
        try
        {
            for (int i = offset; i < offset + length; i++)
            {
                int size = dsts[i].remaining();
                if (size > 0)
                {
                    int read = readImpl(dsts[i]);
                    if (read < 0)
                    {
                        break;
                    }
                    totalRead += read;
                    if (read < size || fd.available() == 0)
                    {
                        break;
                    }
                }
            }
        }
        catch (IOException x)
        {
            if (totalRead == 0)
            {
                throw x;
            }
        }
        return totalRead;
    }

    private int writeImpl(ByteBuffer src) throws IOException
    {
        if (src.hasArray())
        {
            byte[] buf = src.array();
            int len = src.remaining();
            fd.writeBytes(buf, src.arrayOffset() + src.position(), len);
            src.position(src.position() + len);
            return len;
        }
        else
        {
            int pos = src.position();
            byte[] buf = new byte[src.remaining()];
            src.get(buf);
            fd.writeBytes(buf, 0, buf.length);
            src.position(pos + buf.length);
            return buf.length;
        }
    }

    private int writeImpl(ByteBuffer src, long position) throws IOException
    {
        synchronized (positionLock)
        {
            long prev = position0(fd, -1);
            try
            {
                position0(fd, position);
                return writeImpl(src);
            }
            finally
            {
                position0(fd, prev);
            }
        }
    }

    private long writeImpl(ByteBuffer[] srcs, int offset, int length) throws IOException
    {
        long totalWritten = 0;
        try
        {
            for (int i = offset; i < offset + length; i++)
            {
                int size = srcs[i].remaining();
                if (size > 0)
                {
                    int written = writeImpl(srcs[i]);
                    totalWritten += written;
                    if (written < size)
                    {
                        break;
                    }
                }
            }
        }
        catch (IOException x)
        {
            if (totalWritten == 0)
            {
                throw x;
            }
        }
        return totalWritten;
    }

@


1.13
log
@Updated bulk of java.nio to OpenJDK 7.
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
a30 3
import cli.System.Reflection.MethodInfo;
import cli.System.Reflection.ParameterModifier;
import cli.System.Reflection.BindingFlags;
a33 1
import cli.System.Type;
a34 3
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.RandomAccessFile;
a38 1
import java.nio.channels.spi.*;
a40 5
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.ref.WeakReference;
import java.lang.ref.ReferenceQueue;
import java.lang.reflect.Field;
a41 1
import java.security.PrivilegedAction;
a44 1

a48 1
    private static final boolean winNT = cli.System.Environment.get_OSVersion().get_Platform().Value == cli.System.PlatformID.Win32NT;
d53 3
d57 1
a57 1
    private FileDescriptor fd;
d60 3
a62 3
    private boolean writable;
    private boolean readable;
    private boolean appending;
d65 4
a68 1
    private Object parent;
d71 1
a71 1
    private Object positionLock = new Object();
d74 1
a74 1
                            boolean writable, Object parent, boolean append)
d79 1
d81 1
a81 1
        this.appending = append;
d84 1
a84 3
    // Invoked by getChannel() methods
    // of java.io.File{Input,Output}Stream and RandomAccessFile
    //
d89 1
a89 1
        return new FileChannelImpl(fd, readable, writable, parent, false);
d92 1
d95 1
a95 1
                                   Object parent, boolean append)
d97 1
a97 1
        return new FileChannelImpl(fd, readable, writable, parent, append);
d109 1
a109 2

        // Invalidate and release any locks that we still hold
d111 6
a116 4
            fileLockTable.removeAll( new FileLockTable.Releaser() {
                public void release(FileLock fl) throws IOException {
                    ((FileLockImpl)fl).invalidate();
                    release0(fd, fl.position(), fl.size());
d118 1
a118 1
            });
d121 3
d131 1
a131 9
            if (parent instanceof FileInputStream)
                ((FileInputStream)parent).close();
            else if (parent instanceof FileOutputStream)
                ((FileOutputStream)parent).close();
            else if (parent instanceof RandomAccessFile)
                ((RandomAccessFile)parent).close();
            else
                assert false;

d133 1
a133 1
            fd.close();
d144 1
d147 1
d153 1
d160 5
a164 1
    private long read0(ByteBuffer[] dsts) throws IOException {
d170 1
d173 1
d176 1
a176 1
                n = readImpl(dsts);
d179 1
a185 9
    public long read(ByteBuffer[] dsts, int offset, int length)
        throws IOException
    {
        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
           throw new IndexOutOfBoundsException();
        // ## Fix IOUtil.write so that we can avoid this array copy
        return read0(Util.subsequence(dsts, offset, length));
    }

d192 1
d195 1
d198 1
a198 1
                if (appending)
d203 1
d210 5
a214 1
    private long write0(ByteBuffer[] srcs) throws IOException {
d220 1
d223 1
d226 1
a226 1
                if (appending)
d228 1
a228 1
                n = writeImpl(srcs);
d231 1
a237 10
    public long write(ByteBuffer[] srcs, int offset, int length)
        throws IOException
    {
        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))
           throw new IndexOutOfBoundsException();
        // ## Fix IOUtil.write so that we can avoid this array copy
        return write0(Util.subsequence(srcs, offset, length));
    }


d244 1
d247 1
d251 2
a252 1
                    p = position0(fd, -1);
d256 1
d269 1
d272 1
d280 1
d291 1
d294 1
d298 1
a298 1
                    s = size0(fd);
d302 1
d320 1
d323 1
d337 1
a337 1
                    rv = truncate0(fd, size);
d350 1
d360 1
d363 1
d367 1
a367 1
                rv = force0(fd, metaData);
d370 1
d495 1
d498 1
d504 1
d519 1
d522 1
d528 1
d540 2
d543 9
a551 2
        private long address;
        private long size;
d553 3
a555 1
        private Unmapper(long address, long size) {
d559 8
d574 15
a589 1

d628 1
d631 1
d641 1
a641 1
                    rv = truncate0(fd, position + size);
d677 10
d690 12
a701 5
            Unmapper um = new Unmapper(addr, size + pagePosition);
            if ((!writable) || (imode == MAP_RO))
                return Util.newMappedByteBufferR(isize, addr + pagePosition, fd, um);
            else
                return Util.newMappedByteBuffer(isize, addr + pagePosition, fd, um);
d703 1
d708 24
d735 1
a735 4
    public static final int NO_LOCK = -1;       // Failed to lock
    public static final int LOCKED = 0;         // Obtained requested lock
    public static final int RET_EX_LOCK = 1;    // Obtained exclusive lock
    public static final int INTERRUPTED = 2;    // Request interrupted
d765 1
a765 1
    private FileLockTable fileLockTable() {
d769 11
a779 2
                    fileLockTable = isSharedFileLockTable() ?
                        new SharedFileLockTable(this) : new SimpleFileLockTable();
d797 2
a798 1
        boolean i = true;
d801 1
d804 13
a816 7
            int result = lock0(fd, true, position, size, shared);
            if (result == RET_EX_LOCK) {
                assert shared;
                FileLockImpl fli2 = new FileLockImpl(this, position, size,
                                                     false);
                flt.replace(fli, fli2);
                return fli2;
d818 2
a819 1
            if (result == INTERRUPTED || result == NO_LOCK) {
d821 1
a821 6
                i = false;
            }
        } catch (IOException e) {
            flt.remove(fli);
            throw e;
        } finally {
d823 1
a823 1
                end(i);
d842 25
a866 11
        int result = lock0(fd, false, position, size, shared);
        if (result == NO_LOCK) {
            flt.remove(fli);
            return null;
        }
        if (result == RET_EX_LOCK) {
            assert shared;
            FileLockImpl fli2 = new FileLockImpl(this, position, size,
                                                 false);
            flt.replace(fli, fli2);
            return fli2;
a867 1
        return fli;
d871 7
a877 2
        ensureOpen();
        release0(fd, fli.position(), fli.size());
d882 1
a882 43

    // -- File lock support  --

    /**
     * A table of FileLocks.
     */
    private interface FileLockTable {
        /**
         * Adds a file lock to the table.
         *
         * @@throws OverlappingFileLockException if the file lock overlaps
         *         with an existing file lock in the table
         */
        void add(FileLock fl) throws OverlappingFileLockException;

        /**
         * Remove an existing file lock from the table.
         */
        void remove(FileLock fl);

        /**
         * An implementation of this interface releases a given file lock.
         * Used with removeAll.
         */
        interface Releaser {
            void release(FileLock fl) throws IOException;
        }

        /**
         * Removes all file locks from the table.
         * <p>
         * The Releaser#release method is invoked for each file lock before
         * it is removed.
         *
         * @@throws IOException if the release method throws IOException
         */
        void removeAll(Releaser r) throws IOException;

        /**
         * Replaces an existing file lock in the table.
         */
        void replace(FileLock fl1, FileLock fl2);
    }
d888 1
a888 1
    private static class SimpleFileLockTable implements FileLockTable {
d890 1
a890 1
        private List<FileLock> lockList = new ArrayList<FileLock>(2);
d919 1
a919 1
        public void removeAll(Releaser releaser) throws IOException {
d921 3
a923 6
                Iterator<FileLock> i = lockList.iterator();
                while (i.hasNext()) {
                    FileLock fl = i.next();
                    releaser.release(fl);
                    i.remove();
                }
a934 191
    /**
     * A weak reference to a FileLock.
     * <p>
     * SharedFileLockTable uses a list of file lock references to avoid keeping the
     * FileLock (and FileChannel) alive.
     */
    private static class FileLockReference extends WeakReference<FileLock> {
        private FileKey fileKey;

        FileLockReference(FileLock referent,
                          ReferenceQueue queue,
                          FileKey key) {
            super(referent, queue);
            this.fileKey = key;
        }

        private FileKey fileKey() {
            return fileKey;
        }
    }

    /**
     * A file lock table that is over a system-wide map of all file locks.
     */
    private static class SharedFileLockTable implements FileLockTable {
        // The system-wide map is a ConcurrentHashMap that is keyed on the FileKey.
        // The map value is a list of file locks represented by FileLockReferences.
        // All access to the list must be synchronized on the list.
        private static ConcurrentHashMap<FileKey, ArrayList<FileLockReference>> lockMap =
            new ConcurrentHashMap<FileKey, ArrayList<FileLockReference>>();

        // reference queue for cleared refs
        private static ReferenceQueue queue = new ReferenceQueue();

        // the enclosing file channel
        private FileChannelImpl fci;

        // File key for the file that this channel is connected to
        private FileKey fileKey;

        public SharedFileLockTable(FileChannelImpl fci) {
            this.fci = fci;
            this.fileKey = FileKey.create(fci.fd);
        }

        public void add(FileLock fl) throws OverlappingFileLockException {
            ArrayList<FileLockReference> list = lockMap.get(fileKey);

            for (;;) {

                // The key isn't in the map so we try to create it atomically
                if (list == null) {
                    list = new ArrayList<FileLockReference>(2);
                    ArrayList<FileLockReference> prev;
                    synchronized (list) {
                        prev = lockMap.putIfAbsent(fileKey, list);
                        if (prev == null) {
                            // we successfully created the key so we add the file lock
                            list.add(new FileLockReference(fl, queue, fileKey));
                            break;
                        }
                    }
                    // someone else got there first
                    list = prev;
                }

                // There is already a key. It is possible that some other thread
                // is removing it so we re-fetch the value from the map. If it
                // hasn't changed then we check the list for overlapping locks
                // and add the new lock to the list.
                synchronized (list) {
                    ArrayList<FileLockReference> current = lockMap.get(fileKey);
                    if (list == current) {
                        checkList(list, fl.position(), fl.size());
                        list.add(new FileLockReference(fl, queue, fileKey));
                        break;
                    }
                    list = current;
                }

            }

            // process any stale entries pending in the reference queue
            removeStaleEntries();
        }

        private void removeKeyIfEmpty(FileKey fk, ArrayList<FileLockReference> list) {
            assert Thread.holdsLock(list);
            assert lockMap.get(fk) == list;
            if (list.isEmpty()) {
                lockMap.remove(fk);
            }
        }

        public void remove(FileLock fl) {
            assert fl != null;

            // the lock must exist so the list of locks must be present
            ArrayList<FileLockReference> list = lockMap.get(fileKey);
            assert list != null;

            synchronized (list) {
                int index = 0;
                while (index < list.size()) {
                    FileLockReference ref = list.get(index);
                    FileLock lock = ref.get();
                    if (lock == fl) {
                        assert (lock != null) && (lock.channel() == fci);
                        ref.clear();
                        list.remove(index);
                        break;
                    }
                    index++;
                }
            }
        }

        public void removeAll(Releaser releaser) throws IOException {
            ArrayList<FileLockReference> list = lockMap.get(fileKey);
            if (list != null) {
                synchronized (list) {
                    int index = 0;
                    while (index < list.size()) {
                        FileLockReference ref = list.get(index);
                        FileLock lock = ref.get();

                        // remove locks obtained by this channel
                        if (lock != null && lock.channel() == fci) {
                            // invoke the releaser to invalidate/release the lock
                            releaser.release(lock);

                            // remove the lock from the list
                            ref.clear();
                            list.remove(index);
                        } else {
                            index++;
                        }
                    }

                    // once the lock list is empty we remove it from the map
                    removeKeyIfEmpty(fileKey, list);
                }
            }
        }

        public void replace(FileLock fromLock, FileLock toLock) {
            // the lock must exist so there must be a list
            ArrayList<FileLockReference> list = lockMap.get(fileKey);
            assert list != null;

            synchronized (list) {
                for (int index=0; index<list.size(); index++) {
                    FileLockReference ref = list.get(index);
                    FileLock lock = ref.get();
                    if (lock == fromLock) {
                        ref.clear();
                        list.set(index, new FileLockReference(toLock, queue, fileKey));
                        break;
                    }
                }
            }
        }

        // Check for overlapping file locks
        private void checkList(List<FileLockReference> list, long position, long size)
            throws OverlappingFileLockException
        {
            assert Thread.holdsLock(list);
            for (FileLockReference ref: list) {
                FileLock fl = ref.get();
                if (fl != null && fl.overlaps(position, size))
                    throw new OverlappingFileLockException();
            }
        }

        // Process the reference queue
        private void removeStaleEntries() {
            FileLockReference ref;
            while ((ref = (FileLockReference)queue.poll()) != null) {
                FileKey fk = ref.fileKey();
                ArrayList<FileLockReference> list = lockMap.get(fk);
                if (list != null) {
                    synchronized (list) {
                        list.remove(ref);
                        removeKeyIfEmpty(fk, list);
                    }
                }
            }
        }
    }

d978 1
a978 1
    private long readImpl(ByteBuffer[] dsts) throws IOException
d983 1
a983 1
            for (int i = 0; i < dsts.length; i++)
d1049 1
a1049 1
    private long writeImpl(ByteBuffer[] srcs) throws IOException
d1054 1
a1054 1
            for (int i = 0; i < srcs.length; i++)
a1077 119
    @@StructLayoutAttribute.Annotation(LayoutKind.__Enum.Sequential)
    private static final class OVERLAPPED extends cli.System.Object
    {
        IntPtr Internal;
        IntPtr InternalHigh;
        int OffsetLow;
        int OffsetHigh;
        IntPtr hEvent;
    }

    // Grabs a file lock
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    static int lock0(FileDescriptor fd, boolean blocking, long pos, long size, boolean shared) throws IOException
    {
        FileStream fs = (FileStream)fd.getStream();
        if (winNT)
        {
            int LOCKFILE_FAIL_IMMEDIATELY = 1;
            int LOCKFILE_EXCLUSIVE_LOCK = 2;
            int ERROR_LOCK_VIOLATION = 33;
            int flags = 0;
            OVERLAPPED o = new OVERLAPPED();
            o.OffsetLow = (int)pos;
            o.OffsetHigh = (int)(pos >> 32);
            if (!blocking)
            {
                flags |= LOCKFILE_FAIL_IMMEDIATELY;
            }
            if (!shared)
            {
                flags |= LOCKFILE_EXCLUSIVE_LOCK;
            }
            int result = LockFileEx(fs.get_SafeFileHandle(), flags, 0, (int)size, (int)(size >> 32), o);
            if (result == 0)
            {
                int error = cli.System.Runtime.InteropServices.Marshal.GetLastWin32Error();
                if (!blocking && error == ERROR_LOCK_VIOLATION)
                {
                    return NO_LOCK;
                }
                throw new IOException("Lock failed");
            }
            return LOCKED;
        }
        else
        {
            try
            {
                if (false) throw new cli.System.ArgumentOutOfRangeException();
                for (;;)
                {
                    try
                    {
                        if (false) throw new cli.System.IO.IOException();
                        if (false) throw new cli.System.ObjectDisposedException("");
                        fs.Lock(pos, size);
                        return shared ? RET_EX_LOCK : LOCKED;
                    }
                    catch (cli.System.IO.IOException x)
                    {
                        if (!blocking)
                        {
                            return NO_LOCK;
                        }
                        cli.System.Threading.Thread.Sleep(100);
                    }
                    catch (cli.System.ObjectDisposedException x)
                    {
                        throw new IOException(x.getMessage());
                    }
                }
            }
            catch (cli.System.ArgumentOutOfRangeException x)
            {
                throw new IOException(x.getMessage());
            }
        }
    }

    // Releases a file lock
    @@cli.System.Security.SecuritySafeCriticalAttribute.Annotation
    static void release0(FileDescriptor fd, long pos, long size) throws IOException
    {
        FileStream fs = (FileStream)fd.getStream();
        if (winNT)
        {
            OVERLAPPED o = new OVERLAPPED();
            o.OffsetLow = (int)pos;
            o.OffsetHigh = (int)(pos >> 32);
            int result = UnlockFileEx(fs.get_SafeFileHandle(), 0, (int)size, (int)(size >> 32), o);
            if (result == 0)
            {
                throw new IOException("Release failed");
            }
        }
        else
        {
            try
            {
                if (false) throw new cli.System.ArgumentOutOfRangeException();
                if (false) throw new cli.System.IO.IOException();
                if (false) throw new cli.System.ObjectDisposedException("");
                fs.Unlock(pos, size);
            }
            catch (cli.System.ArgumentOutOfRangeException x)
            {
                throw new IOException(x.getMessage());
            }
            catch (cli.System.IO.IOException x)
            {
                throw new IOException(x.getMessage());
            }
            catch (cli.System.ObjectDisposedException x)
            {
                throw new IOException(x.getMessage());
            }
        }
    }

a1175 6
    @@DllImportAttribute.Annotation(value="kernel32", SetLastError=true)
    static native int LockFileEx(SafeFileHandle hFile, int dwFlags, int dwReserved, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh, OVERLAPPED lpOverlapped);

    @@DllImportAttribute.Annotation("kernel32")
    static native int UnlockFileEx(SafeFileHandle hFile, int dwReserved, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh, OVERLAPPED lpOverlapped);

a1193 14
    // Forces output to device
    private static int force0(FileDescriptor fd, boolean metaData) throws IOException
    {
        fd.sync();
        return 0;
    }

    // Truncates a file
    private static int truncate0(FileDescriptor fd, long size) throws IOException
    {
        fd.setLength(size);
        return 0;
    }

a1205 6

    // Reports this file's size
    private static long size0(FileDescriptor fd) throws IOException
    {
        return fd.length();
    }
@


1.12
log
@Integrated OpenJDK 6 b21.
@
text
@a68 3
    // Cached field for MappedByteBuffer.isAMappedBuffer
    private static Field isAMappedBufferField;

d602 2
d605 1
a605 1
                    return Util.newMappedByteBufferR(0, 0, null);
d607 1
a607 1
                    return Util.newMappedByteBuffer(0, 0, null);
d638 1
a638 1
                return Util.newMappedByteBufferR(isize, addr + pagePosition, um);
d640 1
a640 1
                return Util.newMappedByteBuffer(isize, addr + pagePosition, um);
a1472 6

    static {
        isAMappedBufferField = Reflect.lookupField("java.nio.MappedByteBuffer",
                                          "isAMappedBuffer");
    }

@


1.11
log
@More .NET 4.0 security model attributes.
@
text
@d2 1
a2 1
 * Copyright 2000-2006 Sun Microsystems, Inc.  All Rights Reserved.
d7 1
a7 1
 * published by the Free Software Foundation.  Sun designates this
d9 1
a9 1
 * by Sun in the LICENSE file that accompanied this code.
d21 3
a23 3
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
@


1.10
log
@Use FileDescriptor.sync() instead of duplicating FileStream flushing here.
@
text
@d1212 1
d1281 1
d1330 1
d1391 1
d1431 1
@


1.9
log
@Integrated OpenJDK 6 b10.
@
text
@a1404 26
    private static boolean flushWin32(FileStream fs)
    {
        int rc = FlushFileBuffers(fs.get_SafeFileHandle());
        cli.System.GC.KeepAlive(fs);
        return rc != 0;
    }

    private static boolean flushPosix(FileStream fs)
    {
        Type t = Type.GetType("Mono.Posix.Syscall, Mono.Posix");
        if(t != null)
        {
            BindingFlags flags = BindingFlags.wrap(BindingFlags.Public | BindingFlags.Static);
            MethodInfo mono_1_1_Flush = t.GetMethod("fsync", flags, null, new Type[] { Type.GetType("System.Int32") }, new ParameterModifier[0]);
            if(mono_1_1_Flush != null)
            {
                Object[] args = new Object[] { ikvm.lang.CIL.box_int(fs.get_Handle().ToInt32()) };
                return ikvm.lang.CIL.unbox_int(mono_1_1_Flush.Invoke(null, args)) == 0;
            }
        }
        return true;
    }

    @@DllImportAttribute.Annotation("kernel32")
    private static native int FlushFileBuffers(SafeFileHandle handle);

d1440 1
a1440 6
        FileStream fs = (FileStream)fd.getStream();
        boolean rc = win32 ? flushWin32(fs) : flushPosix(fs);
        if (!rc)
        {
            throw new IOException("Force failed");
        }
@


1.8
log
@Merged OpenJDK 6 b10 whitespace and comment changes.
@
text
@d672 3
a674 3
                    PrivilegedAction pa = new GetPropertyAction(
                        "sun.nio.ch.disableSystemWideOverlappingFileLockCheck");
                    String value = (String)AccessController.doPrivileged(pa);                   
@


1.7
log
@Converted tabs to spaces.
@
text
@d73 1
a73 1
    private FileDescriptor fd;   
d84 1
a84 1
    private Object positionLock = new Object();   
d93 1
a93 1
        this.appending = append;            
d125 1
a125 1
            fileLockTable.removeAll( new FileLockTable.Releaser() { 
d253 1
a253 1

d335 1
a335 1
                if (!isOpen()) 
d528 1
a528 1

d613 1
a613 1
            long mapSize = size + pagePosition;  
d623 1
a623 1
                } catch (InterruptedException y) { 
d631 1
a631 1
                } 
d647 1
a647 1

d654 1
a654 1
    
d657 1
a657 1
    
d661 1
a661 1
    // indicates if the disableSystemWideOverlappingFileLockCheck property 
d663 2
a664 2
    private static volatile boolean propertyChecked; 
    
d666 2
a667 2
    // the overlap check wasn't system wide when there were multiple channels to 
    // the same file. This property is used to get 1.4/5.0 behavior if desired.         
d679 2
a680 2
        }        
        return isSharedFileLockTable;        
d682 1
a682 1
                      
d686 2
a687 2
                if (fileLockTable == null) {       
                    fileLockTable = isSharedFileLockTable() ? 
d703 1
a703 1
        FileLockImpl fli = new FileLockImpl(this, position, size, shared);        
d768 2
a769 2
      

d771 1
a771 1
        
d775 1
a775 1
    private interface FileLockTable {   
d783 1
a783 1
        
d788 1
a788 1
        
d793 4
a796 4
        interface Releaser { 
            void release(FileLock fl) throws IOException; 
        } 
        
d806 1
a806 1
                        
d809 2
a810 2
         */         
        void replace(FileLock fl1, FileLock fl2);        
d812 1
a812 1
        
d819 3
a821 3
        private List<FileLock> lockList = new ArrayList<FileLock>(2);       
                        
        public SimpleFileLockTable() {          
d823 1
a823 1
        
d825 1
a825 1
            throws OverlappingFileLockException 
d834 1
a834 1
  
d836 1
a836 1
            synchronized (lockList) {  
d841 1
a841 1
        
d847 1
a847 1
        
d858 1
a858 1
        
d864 1
a864 1
        }                      
d866 1
a866 1
        
d868 1
a868 1
     * A weak reference to a FileLock. 
d870 1
a870 1
     * SharedFileLockTable uses a list of file lock references to avoid keeping the 
d872 1
a872 1
     */    
d874 2
a875 2
        private FileKey fileKey; 
        
d878 1
a878 1
                          FileKey key) {                           
d882 1
a882 1
                
d885 1
a885 1
        }       
d887 1
a887 1
        
d889 1
a889 1
     * A file lock table that is over a system-wide map of all file locks.   
d891 1
a891 1
    private static class SharedFileLockTable implements FileLockTable {              
d894 2
a895 2
        // All access to the list must be synchronized on the list.         
        private static ConcurrentHashMap<FileKey, ArrayList<FileLockReference>> lockMap = 
d897 1
a897 1
        
d900 1
a900 1
            
d902 1
a902 1
        private FileChannelImpl fci;            
d905 2
a906 2
        private FileKey fileKey;    
                
d910 3
a912 3
        }        
                
        public void add(FileLock fl) throws OverlappingFileLockException {                        
d914 1
a914 1
            
d916 2
a917 2
                
                // The key isn't in the map so we try to create it atomically                
d921 1
a921 1
                    synchronized (list) {                                        
d923 1
a923 1
                        if (prev == null) {   
d925 1
a925 1
                            list.add(new FileLockReference(fl, queue, fileKey));                                                       
d927 1
a927 1
                        }                            
d930 7
a936 7
                    list = prev; 
                } 
                
                // There is already a key. It is possible that some other thread  
                // is removing it so we re-fetch the value from the map. If it 
                // hasn't changed then we check the list for overlapping locks 
                // and add the new lock to the list.                 
d941 1
a941 1
                        list.add(new FileLockReference(fl, queue, fileKey));                                                
d946 4
a949 4
                
            } 
            
            // process any stale entries pending in the reference queue 
d952 1
a952 1
        
d956 3
a958 3
            if (list.isEmpty()) {                     
                lockMap.remove(fk);                   
            }             
d960 1
a960 1
                
d963 1
a963 1
            
d965 4
a968 4
            ArrayList<FileLockReference> list = lockMap.get(fileKey);            
            assert list != null;                                              
                        
            synchronized (list) {                     
d973 1
a973 1
                    if (lock == fl) {                        
d980 2
a981 2
                }         
            }            
d983 2
a984 2
        
        public void removeAll(Releaser releaser) throws IOException {    
d986 2
a987 2
            if (list != null) {                                             
                synchronized (list) {                                
d992 1
a992 1
                        
d994 1
a994 1
                        if (lock != null && lock.channel() == fci) {                                                       
d997 1
a997 1
                            
d1005 1
a1005 1
                    
d1007 2
a1008 2
                    removeKeyIfEmpty(fileKey, list);         
                }    
d1011 2
a1012 2
        
        public void replace(FileLock fromLock, FileLock toLock) {           
d1014 4
a1017 4
            ArrayList<FileLockReference> list = lockMap.get(fileKey);            
            assert list != null;                         
            
            synchronized (list) {               
d1021 1
a1021 1
                    if (lock == fromLock) {   
d1028 4
a1031 4
        }   
                     
        // Check for overlapping file locks         
        private void checkList(List<FileLockReference> list, long position, long size) 
d1035 1
a1035 1
            for (FileLockReference ref: list) {                
d1037 1
a1037 1
                if (fl != null && fl.overlaps(position, size)) 
d1040 3
a1042 3
        }                          
        
        // Process the reference queue        
d1045 1
a1045 1
            while ((ref = (FileLockReference)queue.poll()) != null) {                
d1050 2
a1051 2
                        list.remove(ref);                              
                        removeKeyIfEmpty(fk, list); 
d1055 1
a1055 1
        }               
d1057 1
a1057 1
 
@


1.6
log
@- Fixed memory mapped file bug that caused mapping at non-zero file position to fail.
- Close mapping handle using the Close() method on SafeFileHanlde instead of p/invoking the Win32 API directly.
@
text
@d89 3
a91 3
	this.fd = fd;
	this.readable = readable;
	this.writable = writable;
d100 2
a101 2
				   boolean readable, boolean writable,
				   Object parent)
d103 1
a103 1
	return new FileChannelImpl(fd, readable, writable, parent, false);
d107 2
a108 2
				   boolean readable, boolean writable,
				   Object parent, boolean append)
d110 1
a110 1
	return new FileChannelImpl(fd, readable, writable, parent, append);
d114 2
a115 2
	if (!isOpen())
	    throw new ClosedChannelException();
d133 15
a147 1
	if (parent != null) {
d149 3
a151 17
	    // Close the fd via the parent stream's close method.  The parent
	    // will reinvoke our close method, which is defined in the
	    // superclass AbstractInterruptibleChannel, but the isOpen logic in
	    // that method will prevent this method from being reinvoked.
	    //
	    if (parent instanceof FileInputStream)
		((FileInputStream)parent).close();
	    else if (parent instanceof FileOutputStream)
		((FileOutputStream)parent).close();
	    else if (parent instanceof RandomAccessFile)
		((RandomAccessFile)parent).close();
	    else
		assert false;

	} else {
	    fd.close();
	}
d156 16
a171 16
	ensureOpen();
	if (!readable)
	    throw new NonReadableChannelException();
	synchronized (positionLock) {
	    int n = 0;
	    try {
		begin();
		if (!isOpen())
		    return 0;
		n = readImpl(dst);
		return IOStatus.normalize(n);
	    } finally {
		end(n > 0);
		assert IOStatus.check(n);
	    }
	}
d175 1
a175 1
	ensureOpen();
d178 13
a190 13
	synchronized (positionLock) {
	    long n = 0;
	    try {
		begin();
		if (!isOpen())
		    return 0;
		n = readImpl(dsts);
		return IOStatus.normalize(n);
	    } finally {
		end(n > 0);
		assert IOStatus.check(n);
	    }
	}
d194 1
a194 1
	throws IOException
d198 2
a199 2
	// ## Fix IOUtil.write so that we can avoid this array copy
	return read0(Util.subsequence(dsts, offset, length));
d203 1
a203 1
	ensureOpen();
d206 6
a211 6
	synchronized (positionLock) {
	    int n = 0;
	    try {
		begin();
		if (!isOpen())
		    return 0;
d214 7
a220 7
		n = writeImpl(src);
		return IOStatus.normalize(n);
	    } finally {
		end(n > 0);
		assert IOStatus.check(n);
	    }
	}
d224 1
a224 1
	ensureOpen();
d227 6
a232 6
	synchronized (positionLock) {
	    long n = 0;
	    try {
		begin();
		if (!isOpen())
		    return 0;
d235 7
a241 7
		n = writeImpl(srcs);
		return IOStatus.normalize(n);
	    } finally {
		end(n > 0);
		assert IOStatus.check(n);
	    }
	}
d245 1
a245 1
	throws IOException
d249 2
a250 2
	// ## Fix IOUtil.write so that we can avoid this array copy
	return write0(Util.subsequence(srcs, offset, length));
d257 16
a272 16
	ensureOpen();
	synchronized (positionLock) {
	    long p = -1;
	    try {
		begin();
		if (!isOpen())
		    return 0;
		do {
		    p = position0(fd, -1);
		} while ((p == IOStatus.INTERRUPTED) && isOpen());
		return IOStatus.normalize(p);
	    } finally {
		end(p > -1);
		assert IOStatus.check(p);
	    }
	}
d276 1
a276 1
	ensureOpen();
d279 15
a293 15
	synchronized (positionLock) {
	    long p = -1;
	    try {
		begin();
		if (!isOpen())
		    return null;
		do {
		    p  = position0(fd, newPosition);
		} while ((p == IOStatus.INTERRUPTED) && isOpen());
		return this;
	    } finally {
		end(p > -1);
		assert IOStatus.check(p);
	    }
	}
d297 16
a312 16
	ensureOpen();
	synchronized (positionLock) {
	    long s = -1;
	    try {
		begin();
		if (!isOpen())
		    return -1;
		do {
		    s = size0(fd);
		} while ((s == IOStatus.INTERRUPTED) && isOpen());
		return IOStatus.normalize(s);
	    } finally {
		end(s > -1);
		assert IOStatus.check(s);
	    }
	}
d316 1
a316 1
	ensureOpen();
d321 3
a323 3
	if (!writable)
	    throw new NonWritableChannelException();
	synchronized (positionLock) {
d325 5
a329 5
	    long p = -1;
	    try {
		begin();
		if (!isOpen())
		    return null;
d332 4
a335 4
		do {
		    p = position0(fd, -1);
		} while ((p == IOStatus.INTERRUPTED) && isOpen());
		if (!isOpen()) 
d339 4
a342 4
		// truncate file
		do {
		    rv = truncate0(fd, size);
		} while ((rv == IOStatus.INTERRUPTED) && isOpen());
d346 1
a346 1
		// set position to size if greater than size
d352 6
a357 6
		return this;
	    } finally {
		end(rv > -1);
		assert IOStatus.check(rv);
	    }
	}
d361 13
a373 13
	ensureOpen();
	int rv = -1;
	try {
	    begin();
	    if (!isOpen())
		return;
	    do {
		rv = force0(fd, metaData);
	    } while ((rv == IOStatus.INTERRUPTED) && isOpen());
	} finally {
	    end(rv > -1);
	    assert IOStatus.check(rv);
	}
d377 2
a378 2
					    WritableByteChannel target)
	throws IOException
d380 2
a381 2
	// Untrusted target: Use a newly-erased buffer
	int c = Math.min(icount, TRANSFER_SIZE);
d383 23
a405 23
	long tw = 0;			// Total bytes written
	long pos = position;
	try {
	    while (tw < icount) {
		bb.limit(Math.min((int)(icount - tw), TRANSFER_SIZE));
		int nr = read(bb, pos);
		if (nr <= 0)
		    break;
		bb.flip();
		// ## Bug: Will block writing target if this channel
		// ##      is asynchronously closed
		int nw = target.write(bb);
		tw += nw;
		if (nw != nr)
		    break;
		pos += nw;
		bb.clear();
	    }
	    return tw;
	} catch (IOException x) {
	    if (tw > 0)
		return tw;
	    throw x;
d410 2
a411 2
			   WritableByteChannel target)
	throws IOException
d413 1
a413 1
	ensureOpen();
d423 1
a423 1
	long sz = size();
d426 1
a426 1
	int icount = (int)Math.min(count, Integer.MAX_VALUE);
d430 2
a431 2
	// Slow path for untrusted targets
	return transferToArbitraryChannel(position, icount, target);
d440 2
a441 2
	// Untrusted target: Use a newly-erased buffer
	int c = (int)Math.min(count, TRANSFER_SIZE);
d443 2
a444 2
	long tw = 0;			// Total bytes written
	long pos = position;
d446 1
a446 1
	    while (tw < count) {
d448 18
a465 18
		// ## Bug: Will block reading src if this channel
		// ##      is asynchronously closed
		int nr = src.read(bb);
		if (nr <= 0)
		    break;
		bb.flip();
		int nw = write(bb, pos);
		tw += nw;
		if (nw != nr)
		    break;
		pos += nw;
		bb.clear();
	    }
	    return tw;
	} catch (IOException x) {
	    if (tw > 0)
		return tw;
	    throw x;
d470 2
a471 2
			     long position, long count)
	throws IOException
d473 1
a473 1
	ensureOpen();
d494 11
a504 11
	int n = 0;
	try {
	    begin();
	    if (!isOpen())
		return -1;
	    n = readImpl(dst, position);
	    return IOStatus.normalize(n);
	} finally {
	    end(n > 0);
	    assert IOStatus.check(n);
	}
d515 11
a525 11
	int n = 0;
	try {
	    begin();
	    if (!isOpen())
		return -1;
	    n = writeImpl(src, position);
	    return IOStatus.normalize(n);
	} finally {
	    end(n > 0);
	    assert IOStatus.check(n);
	}
d532 1
a532 1
	implements Runnable
d535 2
a536 2
	private long address;
	private long size;
d538 12
a549 12
	private Unmapper(long address, long size) {
	    assert (address != 0);
	    this.address = address;
	    this.size = size;
	}

	public void run() {
	    if (address == 0)
		return;
	    unmap0(address, size);
	    address = 0;
	}
d554 3
a556 3
	Cleaner cl = ((DirectBuffer)bb).cleaner();
	if (cl != null)
	    cl.clean();
d567 4
a570 4
	if (position < 0L)
	    throw new IllegalArgumentException("Negative position");
	if (size < 0L)
	    throw new IllegalArgumentException("Negative size");
d573 3
a575 3
	if (size > Integer.MAX_VALUE)
	    throw new IllegalArgumentException("Size exceeds Integer.MAX_VALUE");
	int imode = -1;
d577 16
a592 16
	    imode = MAP_RO;
	else if (mode == MapMode.READ_WRITE)
	    imode = MAP_RW;
	else if (mode == MapMode.PRIVATE)
	    imode = MAP_PV;
	assert (imode >= 0);
	if ((mode != MapMode.READ_ONLY) && !writable)
	    throw new NonWritableChannelException();
	if (!readable)
	    throw new NonReadableChannelException();

	long addr = -1;
	try {
	    begin();
	    if (!isOpen())
		return null;
d598 4
a601 4
		int rv;
		do {
		    rv = truncate0(fd, position + size);
		} while ((rv == IOStatus.INTERRUPTED) && isOpen());
d611 22
a632 22
	    int pagePosition = (int)(position % allocationGranularity);
	    long mapPosition = position - pagePosition;
	    long mapSize = size + pagePosition;  
	    try {
		// If no exception was thrown from map0, the address is valid
		addr = map0(imode, mapPosition, mapSize);
	    } catch (OutOfMemoryError x) {
		// An OutOfMemoryError may indicate that we've exhausted memory
		// so force gc and re-attempt map
		System.gc();
		try {
		    Thread.sleep(100);
		} catch (InterruptedException y) { 
		    Thread.currentThread().interrupt();
		}
		try {
		    addr = map0(imode, mapPosition, mapSize);
		} catch (OutOfMemoryError y) {
		    // After a second OOME, fail
		    throw new IOException("Map failed", y);
		} 
	    }
d642 3
a644 3
	} finally {
	    end(IOStatus.checkAll(addr));
	}
d696 1
a696 1
	throws IOException
d699 4
a702 4
	if (shared && !readable)
	    throw new NonReadableChannelException();
	if (!shared && !writable)
	    throw new NonWritableChannelException();
d709 2
a710 2
	    if (!isOpen())
		return null;
d737 1
a737 1
	throws IOException
d740 4
a743 4
	if (shared && !readable)
	    throw new NonReadableChannelException();
	if (!shared && !writable)
	    throw new NonWritableChannelException();
d747 12
a758 12
	int result = lock0(fd, false, position, size, shared);
	if (result == NO_LOCK) {
	    flt.remove(fli);
	    return null;
	}
	if (result == RET_EX_LOCK) {
	    assert shared;
	    FileLockImpl fli2 = new FileLockImpl(this, position, size,
						 false);
	    flt.replace(fli, fli2);
	    return fli2;
	}
d763 1
a763 1
	ensureOpen();
d1062 20
a1081 20
	if (dst.hasArray())
	{
	    byte[] buf = dst.array();
	    int len = fd.readBytes(buf, dst.arrayOffset() + dst.position(), dst.remaining());
	    if (len > 0)
	    {
		dst.position(dst.position() + len);
	    }
	    return len;
	}
	else
	{
	    byte[] buf = new byte[dst.remaining()];
	    int len = fd.readBytes(buf, 0, buf.length);
	    if (len > 0)
	    {
		dst.put(buf, 0, len);
	    }
	    return len;
	}
d1086 13
a1098 13
	synchronized (positionLock)
	{
	    long prev = position0(fd, -1);
	    try
	    {
		position0(fd, position);
		return readImpl(dst);
	    }
	    finally
	    {
		position0(fd, prev);
	    }
	}
d1103 29
a1131 29
	long totalRead = 0;
	try
	{
	    for (int i = 0; i < dsts.length; i++)
	    {
		int size = dsts[i].remaining();
		if (size > 0)
		{
		    int read = readImpl(dsts[i]);
		    if (read < 0)
		    {
			break;
		    }
		    totalRead += read;
		    if (read < size || fd.available() == 0)
		    {
			break;
		    }
		}
	    }
	}
	catch (IOException x)
	{
	    if (totalRead == 0)
	    {
		throw x;
	    }
	}
	return totalRead;
d1136 17
a1152 17
	if (src.hasArray())
	{
	    byte[] buf = src.array();
	    int len = src.remaining();
	    fd.writeBytes(buf, src.arrayOffset() + src.position(), len);
	    src.position(src.position() + len);
	    return len;
	}
	else
	{
	    int pos = src.position();
	    byte[] buf = new byte[src.remaining()];
	    src.get(buf);
	    fd.writeBytes(buf, 0, buf.length);
	    src.position(pos + buf.length);
	    return buf.length;
	}
d1157 13
a1169 13
	synchronized (positionLock)
	{
	    long prev = position0(fd, -1);
	    try
	    {
		position0(fd, position);
		return writeImpl(src);
	    }
	    finally
	    {
		position0(fd, prev);
	    }
	}
d1174 25
a1198 25
	long totalWritten = 0;
	try
	{
	    for (int i = 0; i < srcs.length; i++)
	    {
		int size = srcs[i].remaining();
		if (size > 0)
		{
		    int written = writeImpl(srcs[i]);
		    totalWritten += written;
		    if (written < size)
		    {
			break;
		    }
		}
	    }
	}
	catch (IOException x)
	{
	    if (totalWritten == 0)
	    {
		throw x;
	    }
	}
	return totalWritten;
d1204 5
a1208 5
	IntPtr Internal;
	IntPtr InternalHigh;
	int OffsetLow;
	int OffsetHigh;
	IntPtr hEvent;
d1214 63
a1276 63
	FileStream fs = (FileStream)fd.getStream();
	if (winNT)
	{
	    int LOCKFILE_FAIL_IMMEDIATELY = 1;
	    int LOCKFILE_EXCLUSIVE_LOCK = 2;
	    int ERROR_LOCK_VIOLATION = 33;
	    int flags = 0;
	    OVERLAPPED o = new OVERLAPPED();
	    o.OffsetLow = (int)pos;
	    o.OffsetHigh = (int)(pos >> 32);
	    if (!blocking)
	    {
		flags |= LOCKFILE_FAIL_IMMEDIATELY;
	    }
	    if (!shared)
	    {
		flags |= LOCKFILE_EXCLUSIVE_LOCK;
	    }
	    int result = LockFileEx(fs.get_SafeFileHandle(), flags, 0, (int)size, (int)(size >> 32), o);
	    if (result == 0)
	    {
		int error = cli.System.Runtime.InteropServices.Marshal.GetLastWin32Error();
		if (!blocking && error == ERROR_LOCK_VIOLATION)
		{
		    return NO_LOCK;
		}
		throw new IOException("Lock failed");
	    }
	    return LOCKED;
	}
	else
	{
	    try
	    {
		if (false) throw new cli.System.ArgumentOutOfRangeException();
		for (;;)
		{
		    try
		    {
			if (false) throw new cli.System.IO.IOException();
			if (false) throw new cli.System.ObjectDisposedException("");
			fs.Lock(pos, size);
			return shared ? RET_EX_LOCK : LOCKED;
		    }
		    catch (cli.System.IO.IOException x)
		    {
			if (!blocking)
			{
			    return NO_LOCK;
			}
			cli.System.Threading.Thread.Sleep(100);
		    }
		    catch (cli.System.ObjectDisposedException x)
		    {
			throw new IOException(x.getMessage());
		    }
		}
	    }
	    catch (cli.System.ArgumentOutOfRangeException x)
	    {
		throw new IOException(x.getMessage());
	    }
	}
d1282 34
a1315 34
	FileStream fs = (FileStream)fd.getStream();
	if (winNT)
	{
	    OVERLAPPED o = new OVERLAPPED();
	    o.OffsetLow = (int)pos;
	    o.OffsetHigh = (int)(pos >> 32);
	    int result = UnlockFileEx(fs.get_SafeFileHandle(), 0, (int)size, (int)(size >> 32), o);
	    if (result == 0)
	    {
		throw new IOException("Release failed");
	    }
	}
	else
	{
	    try
	    {
		if (false) throw new cli.System.ArgumentOutOfRangeException();
		if (false) throw new cli.System.IO.IOException();
		if (false) throw new cli.System.ObjectDisposedException("");
		fs.Unlock(pos, size);
	    }
	    catch (cli.System.ArgumentOutOfRangeException x)
	    {
		throw new IOException(x.getMessage());
	    }
	    catch (cli.System.IO.IOException x)
	    {
		throw new IOException(x.getMessage());
	    }
	    catch (cli.System.ObjectDisposedException x)
	    {
		throw new IOException(x.getMessage());
	    }
	}
d1321 5
a1325 5
	FileStream fs = (FileStream)fd.getStream();
	if (win32)
	    return mapViewOfFileWin32(fs, prot, position, length);
	else
	    return mapViewOfFilePosix(fs, prot, position, length);
d1330 56
a1385 56
	try
	{
	    int PAGE_READONLY = 2;
	    int PAGE_READWRITE = 4;
	    int PAGE_WRITECOPY = 8;
	    
	    int FILE_MAP_WRITE = 2;
	    int FILE_MAP_READ = 4;
	    int FILE_MAP_COPY = 1;

	    int fileProtect;
	    int mapAccess;

	    switch (prot)
	    {
		case MAP_RO:
		    fileProtect = PAGE_READONLY;
		    mapAccess = FILE_MAP_READ;
		    break;
		case MAP_RW:
		    fileProtect = PAGE_READWRITE;
		    mapAccess = FILE_MAP_WRITE;
		    break;
		case MAP_PV:
		    fileProtect = PAGE_WRITECOPY;
		    mapAccess = FILE_MAP_COPY;
		    break;
		default:
		    throw new Error();
	    }

	    long maxSize = length + position;
	    SafeFileHandle hFileMapping = CreateFileMapping(fs.get_SafeFileHandle(), IntPtr.Zero, fileProtect, (int)(maxSize >> 32), (int)maxSize, null);
	    int err = cli.System.Runtime.InteropServices.Marshal.GetLastWin32Error();
	    if (hFileMapping.get_IsInvalid())
	    {
		throw new IOException("Win32 error " + err);
	    }
	    IntPtr p = MapViewOfFile(hFileMapping, mapAccess, (int)(position >> 32), (int)position, IntPtr.op_Explicit(length));
	    err = cli.System.Runtime.InteropServices.Marshal.GetLastWin32Error();
	    hFileMapping.Close();
	    if (p.Equals(IntPtr.Zero))
	    {
		if (err == 8 /*ERROR_NOT_ENOUGH_MEMORY*/)
		{
		    throw new OutOfMemoryError("Map failed");
		}
		throw new IOException("Win32 error " + err);
	    }
	    cli.System.GC.AddMemoryPressure(length);
	    return p.ToInt64();
	}
	finally
	{
	    cli.System.GC.KeepAlive(fs);
	}
d1390 2
a1391 2
	byte writeable = prot != MAP_RO ? (byte)1 : (byte)0;
	byte copy_on_write = prot == MAP_PV ? (byte)1 : (byte)0;
d1401 1
a1401 1
	cli.System.GC.AddMemoryPressure(length);
d1460 1
a1460 1
	return 0;
d1466 7
a1472 7
	FileStream fs = (FileStream)fd.getStream();
	boolean rc = win32 ? flushWin32(fs) : flushPosix(fs);
	if (!rc)
	{
	    throw new IOException("Force failed");
	}
	return 0;
d1478 2
a1479 2
	fd.setLength(size);
	return 0;
d1487 6
a1492 6
	if (offset == -1)
	{
	    return fd.getFilePointer();
	}
	fd.seek(offset);
	return offset;
d1498 1
a1498 1
	return fd.length();
@


1.5
log
@- Regenerated mscorlib.jar for .NET 2.0
- Updated FileChannelImpl to use SafeFileHandle and GC.Add|RemoveMemoryPressure
- Added GC.KeepAlive to "native" methods of MappedByteBuffer
@
text
@d1361 2
a1362 1
	    SafeFileHandle hFileMapping = CreateFileMapping(fs.get_SafeFileHandle(), IntPtr.Zero, fileProtect, (int)(length >> 32), (int)length, null);
d1370 1
a1370 1
	    CloseHandle(hFileMapping);
a1430 3
    @@DllImportAttribute.Annotation("kernel32")
    private static native int CloseHandle(SafeFileHandle handle);

@


1.4
log
@Close the file descriptor after releasing the locks.
@
text
@d28 1
d1232 1
a1232 1
	    int result = LockFileEx(fs.get_Handle(), flags, 0, (int)size, (int)(size >> 32), o);
d1288 1
a1288 1
	    int result = UnlockFileEx(fs.get_Handle(), 0, (int)size, (int)(size >> 32), o);
d1361 1
a1361 1
	    IntPtr hFileMapping = CreateFileMapping(fs.get_Handle(), IntPtr.Zero, fileProtect, (int)(length >> 32), (int)length, null);
d1363 1
a1363 1
	    if (hFileMapping.Equals(IntPtr.Zero))
d1378 1
d1391 1
a1391 1
        IntPtr p = ikvm_mmap(fs.get_Handle(), writeable, copy_on_write, position, (int)length);
d1400 1
d1406 1
a1406 1
        int rc = FlushFileBuffers(fs.get_Handle());
d1428 1
a1428 1
    private static native int FlushFileBuffers(IntPtr handle);
d1431 1
a1431 1
    private static native int CloseHandle(IntPtr handle);
d1434 1
a1434 1
    private static native IntPtr CreateFileMapping(IntPtr hFile, IntPtr lpAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, String lpName);
d1437 1
a1437 1
    private static native IntPtr MapViewOfFile(IntPtr hFileMapping, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);
d1443 1
a1443 1
    static native int LockFileEx(IntPtr hFile, int dwFlags, int dwReserved, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh, OVERLAPPED lpOverlapped);
d1446 1
a1446 1
    static native int UnlockFileEx(IntPtr hFile, int dwReserved, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh, OVERLAPPED lpOverlapped);
d1452 1
a1452 1
    private static native IntPtr ikvm_mmap(IntPtr handle, byte writeable, byte copy_on_write, long position, int size);
d1461 1
@


1.3
log
@New FileChannelImpl implementation based on OpenJDK.
@
text
@a121 2
	fd.close();
        
d148 2
@


1.3.2.1
log
@Backported fixes and changed version to 0.36.0.5
@
text
@d122 2
a149 2
	} else {
	    fd.close();
@


1.3.2.2
log
@Back ported the following fixes:
- Remapped exceptions with explicit remapping code now call suppressFullInStackTrace (to make sure the proper stack trace is captured).
- Fixed memory mapped file bug (mapping at a non-zero offset would fail).
- Fixed .NET type name mangling for nested types that contain a dot in their name (which the C# 3.0 compiler generates for some helper types).
- Fixed bug in deserialization of double arrays.
- Fixed path canonicalization to swallow NotSupportedException (thrown when the path contains a colon, other than the one following the drive letter).
@
text
@d1360 1
a1360 2
	    long maxSize = length + position;
	    IntPtr hFileMapping = CreateFileMapping(fs.get_Handle(), IntPtr.Zero, fileProtect, (int)(maxSize >> 32), (int)maxSize, null);
@


1.2
log
@Integrated OpenJDK java.nio package.
@
text
@d1 24
a24 37
/* FileChannelImpl.java -- 
   Copyright (C) 2002, 2004, 2005, 2006 Free Software Foundation, Inc.

This file is part of GNU Classpath.

GNU Classpath is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU Classpath is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Classpath; see the file COPYING.  If not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301 USA.

Linking this library statically or dynamically with other modules is
making a combined work based on this library.  Thus, the terms and
conditions of the GNU General Public License cover the whole
combination.

As a special exception, the copyright holders of this library give you
permission to link this library with independent modules to produce an
executable, regardless of the license terms of these independent
modules, and to copy and distribute the resulting executable under
terms of your choice, provided that you also meet, for each linked
independent module, the terms and conditions of the license of that
module.  An independent module is a module which is not derived from
or based on this library.  If you modify this library, you may extend
this exception to your version of the library, but you are not
obligated to do so.  If you do not wish to do so, delete this
exception statement from your version. */

d28 9
a36 3
import gnu.classpath.Configuration;

import java.io.File;
d38 3
a40 1
import java.io.FileNotFoundException;
d44 13
a56 7
import java.nio.channels.ClosedChannelException;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.channels.NonReadableChannelException;
import java.nio.channels.NonWritableChannelException;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
a57 8
import cli.System.Console;
import cli.System.IO.*;
import cli.System.IntPtr;
import cli.System.Type;
import cli.System.Reflection.MethodInfo;
import cli.System.Reflection.ParameterModifier;
import cli.System.Reflection.BindingFlags;
import cli.System.Runtime.InteropServices.DllImportAttribute;
d59 2
a60 2
@@ikvm.lang.Internal
public final class FileChannelImpl extends FileChannel
d62 2
a63 4
    // These are mode values for open().
    public static final int READ   = 1;
    public static final int WRITE  = 2;
    public static final int APPEND = 4;
d65 2
a66 4
    // EXCL is used only when making a temp file.
    public static final int EXCL   = 8;
    public static final int SYNC   = 16;
    public static final int DSYNC  = 32;
d68 2
a69 1
    private static final boolean win32 = runningOnWindows();
d71 2
a72 2
    private volatile Stream stream;
    private int mode;
d74 4
a77 7
    private static boolean runningOnWindows()
    {
        cli.System.OperatingSystem os = cli.System.Environment.get_OSVersion();
        int platform = os.get_Platform().Value;
        return platform == cli.System.PlatformID.Win32NT || 
            platform == cli.System.PlatformID.Win32Windows;
    }
d79 2
a80 4
    void release(FileLockImpl lock)
    {
	// TODO
    }
d82 2
a83 4
    public static java.nio.channels.FileChannel open(FileDescriptor fd, boolean readable, boolean writable, Object parent)
    {
	return create(fd.getStream());
    }
d85 2
a86 1
    public static java.nio.channels.FileChannel open(FileDescriptor fd, boolean readable, boolean writable, Object parent, boolean append)
d88 5
a92 1
	return create(fd.getStream());
d95 6
a100 1
    private static IntPtr mapViewOfFile(FileStream fs, boolean writeable, boolean copy_on_write, long position, int size) throws IOException
d102 1
a102 4
        if (win32)
            return mapViewOfFileWin32(fs, writeable, copy_on_write, position, size);
        else
            return mapViewOfFilePosix(fs, writeable, copy_on_write, position, size);
d105 3
a107 1
    static void unmapViewOfFile(IntPtr ptr, int size)
d109 1
a109 4
        if (win32)
            UnmapViewOfFile(ptr);
        else
            ikvm_munmap(ptr, size);
d112 3
a114 6
    public static void flushViewOfFile(IntPtr ptr, int size)
    {
        if (win32)
            FlushViewOfFile(ptr, IntPtr.Zero);
        else
            ikvm_msync(ptr, size);
a116 48
    private static IntPtr mapViewOfFileWin32(FileStream fs, boolean writeable, boolean copy_on_write, long position, int size) throws IOException
    {
        try
        {
            int PAGE_READONLY = 2;
            int PAGE_READWRITE = 4;
            int PAGE_WRITECOPY = 8;
            IntPtr hFileMapping = CreateFileMapping(fs.get_Handle(), IntPtr.Zero, 
                copy_on_write ? PAGE_WRITECOPY : (writeable ? PAGE_READWRITE : PAGE_READONLY),
                0, size, null);
            int err = cli.System.Runtime.InteropServices.Marshal.GetLastWin32Error();
            if(hFileMapping.Equals(IntPtr.Zero))
            {
                throw new IOException("Win32 error " + err);
            }
            int FILE_MAP_WRITE = 2;
            int FILE_MAP_READ = 4;
            int FILE_MAP_COPY = 1;
            IntPtr p = MapViewOfFile(hFileMapping,
                copy_on_write ? FILE_MAP_COPY : (writeable ? FILE_MAP_WRITE : FILE_MAP_READ),
                (int)(position >> 32), (int)position, new IntPtr(size));
            err = cli.System.Runtime.InteropServices.Marshal.GetLastWin32Error();
            CloseHandle(hFileMapping);
            if(p.Equals(IntPtr.Zero))
            {
                throw new IOException("Win32 error " + err);
            }
            return p;                
        }
        finally
        {
            cli.System.GC.KeepAlive(fs);
        }
    }
        
    private static IntPtr mapViewOfFilePosix(FileStream fs, boolean writeable, boolean copy_on_write, long position, int size) throws IOException
    {
        IntPtr p = ikvm_mmap(fs.get_Handle(), (byte)(writeable ? 1 : 0), (byte)(copy_on_write ? 1 : 0), position, size);
        cli.System.GC.KeepAlive(fs);
        // HACK ikvm_mmap should really be changed to return a null pointer on failure,
        // instead of whatever MAP_FAILED is defined to on the particular system we're running on,
        // common values for MAP_FAILED are 0 and -1, so we test for these.
        if(p.Equals(IntPtr.Zero) || p.Equals(new IntPtr(-1)))
        {
            throw new IOException("file mapping failed");
        }
        return p;
    }
d118 1
a118 7
    private static boolean flush(FileStream fs)
    {
        if (win32)
            return flushWin32(fs);
        else
            return flushPosix(fs);
    }
d120 1
a120 6
    private static boolean flushWin32(FileStream fs)
    {
        int rc = FlushFileBuffers(fs.get_Handle());
        cli.System.GC.KeepAlive(fs);
        return rc != 0;
    }
d122 10
a131 12
    private static boolean flushPosix(FileStream fs)
    {
        Type t = Type.GetType("Mono.Posix.Syscall, Mono.Posix");
        if(t != null)
        {
            BindingFlags flags = BindingFlags.wrap(BindingFlags.Public | BindingFlags.Static);
            MethodInfo mono_1_1_Flush = t.GetMethod("fsync", flags, null, new Type[] { Type.GetType("System.Int32") }, new ParameterModifier[0]);
            if(mono_1_1_Flush != null)
            {
                Object[] args = new Object[] { ikvm.lang.CIL.box_int(fs.get_Handle().ToInt32()) };
                return ikvm.lang.CIL.unbox_int(mono_1_1_Flush.Invoke(null, args)) == 0;
            }
a132 2
        return true;
    }
d134 1
a134 2
    @@DllImportAttribute.Annotation("kernel32")
    private static native int FlushFileBuffers(IntPtr handle);
d136 13
a148 2
    @@DllImportAttribute.Annotation("kernel32")
    private static native int CloseHandle(IntPtr handle);
d150 1
a150 2
    @@DllImportAttribute.Annotation(value="kernel32", SetLastError=true)
    private static native IntPtr CreateFileMapping(IntPtr hFile, IntPtr lpAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, String lpName);
d152 1
a152 2
    @@DllImportAttribute.Annotation(value="kernel32", SetLastError=true)
    private static native IntPtr MapViewOfFile(IntPtr hFileMapping, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);
d154 18
a171 2
    @@DllImportAttribute.Annotation("kernel32")
    private static native int FlushViewOfFile(IntPtr lpBaseAddress, IntPtr dwNumberOfBytesToFlush);
d173 18
a190 2
    @@DllImportAttribute.Annotation("kernel32")
    private static native int UnmapViewOfFile(IntPtr lpBaseAddress);
d192 8
a199 2
    @@DllImportAttribute.Annotation("ikvm-native")
    private static native int ikvm_munmap(IntPtr address, int size);
d201 20
a220 2
    @@DllImportAttribute.Annotation("ikvm-native")
    private static native int ikvm_msync(IntPtr address, int size);
d222 20
a241 2
    @@DllImportAttribute.Annotation("ikvm-native")
    private static native IntPtr ikvm_mmap(IntPtr handle, byte writeable, byte copy_on_write, long position, int size);
d243 2
a244 3
    /* Open a file.  MODE is a combination of the above mode flags. */
    public static FileChannelImpl create(File file, int mode)
        throws FileNotFoundException
d246 26
a271 1
        return new FileChannelImpl(file, mode);
d274 19
a292 5
    FileChannelImpl(File file, int mode)
        throws FileNotFoundException
    {
	stream = open(file.getPath(), mode);
	this.mode = mode;
d295 17
a311 3
    public static FileChannelImpl create(Stream stream)
    {
        return new FileChannelImpl(stream);
d314 43
a356 4
    private FileChannelImpl(Stream stream)
    {
	this.stream = stream;
	mode = (stream.get_CanRead() ? READ : 0) | (stream.get_CanWrite() ? WRITE : 0);
d359 15
a373 3
    public static final FileChannelImpl in;
    public static final FileChannelImpl out;
    public static final FileChannelImpl err;
d375 3
a377 1
    static
d379 26
a404 8
        FileChannelImpl _in;
        FileChannelImpl _out;
        FileChannelImpl _err;
        try
        {
            _in = FileChannelImpl.create(getStandardStream(0));
            _out = FileChannelImpl.create(getStandardStream(1));
            _err = FileChannelImpl.create(getStandardStream(2));
a405 9
        catch(cli.System.MissingMethodException _)
        {
            _in = FileChannelImpl.create(Stream.Null);
            _out = FileChannelImpl.create(Stream.Null);
            _err = FileChannelImpl.create(Stream.Null);
        }
        in = _in;
        out = _out;
        err = _err;
d408 3
a410 2
    private static Stream getStandardStream(int id)
        throws cli.System.MissingMethodException
d412 19
a430 11
        switch(id)
        {
            case 0:
                return Console.OpenStandardInput();
            case 1:
                return Console.OpenStandardOutput();
            case 2:
                return Console.OpenStandardError();
            default:
                throw new Error();
        }
d433 5
a437 1
    private Stream open (String path, int mode) throws FileNotFoundException
d439 12
a450 17
	if(stream != null)
	    throw new InternalError("FileChannelImpl already open");
	try
	{
	    int fileMode;
	    int fileAccess;
	    int fileShare;
	    // NOTE we don't support SYNC or DSYNC
	    switch(mode & (READ|WRITE|APPEND))
	    {
		case READ:
		    fileMode = FileMode.Open;
		    fileAccess = FileAccess.Read;
		    break;
		case READ|WRITE:
		    fileMode = FileMode.OpenOrCreate;
		    fileAccess = FileAccess.ReadWrite;
d452 4
a455 3
		case WRITE:
		    fileMode = FileMode.Create;
		    fileAccess = FileAccess.Write;
d457 2
a458 7
		case APPEND:
		case APPEND|WRITE:
		    fileMode = FileMode.Append;
		    fileAccess = FileAccess.Write;
		    break;
		default:
		    throw new IllegalArgumentException("Invalid mode value: " + mode);
d460 6
a465 28
	    if(false) throw new cli.System.IO.IOException();
	    if(false) throw new cli.System.Security.SecurityException();
	    if(false) throw new cli.System.UnauthorizedAccessException();
	    if(false) throw new cli.System.ArgumentException();
	    if(false) throw new cli.System.NotSupportedException();
	    return new FileStream(demanglePath(path), FileMode.wrap(fileMode), FileAccess.wrap(fileAccess), FileShare.wrap(FileShare.ReadWrite), 1, false);
	}
	catch(cli.System.Security.SecurityException x1)
	{
	    throw new SecurityException(x1.getMessage());
	}
	catch(cli.System.IO.IOException x2)
	{
	    throw new FileNotFoundException(x2.getMessage());
	}
	catch(cli.System.UnauthorizedAccessException x3)
	{
	    // this is caused by "name" being a directory instead of a file
	    throw new FileNotFoundException(x3.getMessage());
	}
	catch(cli.System.ArgumentException x4)
	{
	    throw new FileNotFoundException(x4.getMessage());
	}
	catch(cli.System.NotSupportedException x5)
	{
	    throw new FileNotFoundException(x5.getMessage());
	}
d468 3
a470 1
    private static String demanglePath(String path)
d472 31
a502 5
	// HACK for some reason Java accepts: \c:\foo.txt
	// I don't know what else, but for now lets just support this
	if(path.length() > 3 && (path.charAt(0) == '\\' || path.charAt(0) == '/') && path.charAt(2) == ':')
	{
	    path = path.substring(1);
a503 1
	return path;
d506 18
a523 22
    public int available () throws IOException
    {
	if(stream == null)
	    throw new IOException("Invalid FileChannelImpl");

	try
	{
	    if(false) throw new cli.System.IO.IOException();
	    if(false) throw new cli.System.NotSupportedException();
	    if(stream.get_CanSeek())
		return (int)Math.min(Integer.MAX_VALUE, Math.max(0, stream.get_Length() - stream.get_Position()));
	    return 0;
	}
	catch(cli.System.IO.IOException x)
	{
	    throw new IOException(x.getMessage());
	}
	catch(cli.System.NotSupportedException x1)
	{
	    // this means we have a broken Stream, because if CanSeek returns true, it must
	    // support Length and Position
	    return 0;
d527 5
a531 1
    private long implPosition () throws IOException
a532 2
	if(stream == null)
	    throw new IOException("Invalid FileChannelImpl");
d534 7
a540 4
	try
	{
	    if(false) throw new cli.System.IO.IOException();
	    return stream.get_Position();
d542 6
a547 3
	catch(cli.System.IO.IOException x)
	{
	    throw new IOException(x.getMessage());
d549 1
a549 1
	// TODO map al the other exceptions as well...
d552 12
a563 1
    private void seek (long newPosition) throws IOException
d565 67
a631 2
	if(stream == null)
	    throw new IOException("Invalid FileChannelImpl");
d633 10
a642 4
	try
	{
	    if(false) throw new cli.System.IO.IOException();
	    stream.Seek(newPosition, SeekOrigin.wrap(SeekOrigin.Begin));
a643 5
	catch(cli.System.IO.IOException x)
	{
	    throw new IOException(x.getMessage());
	}
	// TODO map al the other exceptions as well...
d646 13
a658 4
    private void implTruncate (long size) throws IOException
    {
	if(stream == null)
	    throw new IOException("Invalid FileChannelImpl");
d660 29
a688 6
	try
	{
	    if(false) throw new cli.System.IO.IOException();
            if(size < stream.get_Length())
            {
	        stream.SetLength(size);
d690 2
a691 6
	}
	catch(cli.System.IO.IOException x)
	{
	    throw new IOException(x.getMessage());
	}
	// TODO map al the other exceptions as well...
d693 3
a695 2
  
    public void unlock (long pos, long len) throws IOException
d697 37
a733 2
	if(stream == null)
	    throw new IOException("Invalid FileChannelImpl");
d735 320
a1054 19
	try
	{
	    if(false) throw new cli.System.IO.IOException();
	    if(false) throw new cli.System.ArgumentOutOfRangeException();
	    ((FileStream)stream).Unlock(pos, len);
	}
	catch(ClassCastException c)
	{
	    throw new IOException("Locking not supported");
	}
	catch(cli.System.ArgumentOutOfRangeException x1)
	{
	    throw new IOException(x1.getMessage());
	}
	catch(cli.System.IO.IOException x)
	{
	    throw new IOException(x.getMessage());
	}
	// TODO map al the other exceptions as well...
d1056 2
d1059 1
a1059 1
    public long size () throws IOException
d1061 1
a1061 4
	if(stream == null)
	    throw new IOException("Invalid FileChannelImpl");

	try
d1063 7
a1069 2
	    if(false) throw new cli.System.IO.IOException();
	    return stream.get_Length();
d1071 1
a1071 1
	catch(cli.System.IO.IOException x)
d1073 7
a1079 1
	    throw new IOException(x.getMessage());
a1080 1
	// TODO map al the other exceptions as well...
d1082 2
a1083 2
    
    protected void implCloseChannel() throws IOException
d1085 1
a1085 1
	if(stream != null)
d1087 1
a1087 2
            Stream local = stream;
            stream = null;
d1090 2
a1091 3
		local.Close();
                if(false) throw new cli.System.IO.IOException();
                if(false) throw new cli.System.NotSupportedException();
d1093 1
a1093 6
            catch(cli.System.NotSupportedException _)
            {
                // FXBUG ignore this, there's a bug in System.IO.__ConsoleStream,
                // it throws this exception when you try to close it.
            }
            catch(cli.System.IO.IOException x)
d1095 1
a1095 1
		throw new IOException(x.getMessage());
d1100 1
a1100 42
    public int read(ByteBuffer dst) throws IOException
    {
        if (dst.hasArray())
        {
            byte[] buffer = dst.array();
            int result = read(buffer, dst.arrayOffset() + dst.position(), dst.remaining());
            if (result > 0)
            {
                dst.position(dst.position() + result);
            }
            return result;
        }
        else
        {
	    byte[] buffer = new byte[dst.remaining()];
	    int result = read(buffer, 0, buffer.length);
	    if (result > 0)
            {
	        dst.put(buffer, 0, result);
            }
	    return result;
        }
    }

    public int read(ByteBuffer dst, long position) throws IOException
    {
	if (position < 0)
            throw new IllegalArgumentException ("position: " + position);

        long oldPosition = implPosition();
	seek(position);
        try
        {
	    return read(dst);
        }
        finally
        {
	    seek(oldPosition);
        }
    }

    public int read() throws IOException
d1102 1
a1102 3
	if(stream == null)
	    throw new IOException("Invalid FileChannelImpl");

d1105 17
a1121 2
	    if(false) throw new cli.System.IO.IOException();
	    return stream.ReadByte();
d1123 1
a1123 1
	catch(cli.System.IO.IOException x)
d1125 4
a1128 1
	    throw new IOException(x.getMessage());
d1130 1
a1130 1
	// TODO map al the other exceptions as well...
d1133 1
a1133 1
    public int read (byte[] buf, int offset, int len) throws IOException
d1135 1
a1135 13
	if(stream == null)
	    throw new IOException("Invalid FileChannelImpl");

	if (len == 0)
	    return(0);

	if ((offset < 0) || (offset > buf.length))
	    throw new IllegalArgumentException("Offset invalid: " + offset);

	if ((len < 0) || (len > (buf.length - offset)))
	    throw new IllegalArgumentException("Length invalid: " + len);

	try
d1137 5
a1141 7
	    if(false) throw new cli.System.IO.IOException();
            int count = stream.Read(buf, offset, len);
	    if(count == 0)
	    {
		count = -1;
	    }
	    return count;
d1143 1
a1143 1
	catch(cli.System.IO.IOException x)
d1145 6
a1150 1
	    throw new IOException(x.getMessage());
a1151 1
	// TODO map al the other exceptions as well...
d1154 1
a1154 1
    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException
d1156 1
a1156 3
	long result = 0;

	for (int i = offset; i < offset + length; i++)
d1158 10
a1167 1
	    result += read(dsts [i]);
a1168 2

	return result;
d1171 1
a1171 1
    public int write(ByteBuffer src) throws IOException
d1173 2
a1174 2
	int len = src.remaining();
	if (src.hasArray() && !src.isReadOnly())
d1176 13
a1188 3
	    byte[] buffer = src.array();
	    write(buffer, src.arrayOffset() + src.position(), len);
            src.position(src.position() + len);
d1190 1
a1190 1
	else
d1192 4
a1195 4
	    // Use a more efficient native method! FIXME!
	    byte[] buffer = new byte[len];
	    src.get(buffer, 0, len);
	    write(buffer, 0, len);
d1197 1
a1197 1
	return len;
d1199 3
a1201 2
    
    public int write(ByteBuffer src, long position) throws IOException
d1203 5
a1207 19
	if (position < 0)
            throw new IllegalArgumentException ("position: " + position);

	if (!isOpen ())
	    throw new ClosedChannelException ();
    
	if ((mode & WRITE) == 0)
	    throw new NonWritableChannelException ();

	long oldPosition = implPosition();
	seek(position);
        try
        {
	    return write(src);
        }
        finally
        {
	    seek(oldPosition);
        }
d1210 2
a1211 1
    public void write(byte[] buf, int offset, int len) throws IOException
d1213 2
a1214 13
	if(stream == null)
	    throw new ClosedChannelException();

	if (len == 0)
	    return;

	if ((offset < 0) || (offset > buf.length))
	    throw new IllegalArgumentException("Offset invalid: " + offset);

	if ((len < 0) || (len > (buf.length - offset)))
	    throw new IllegalArgumentException("Length invalid: " + len);

	try
d1216 26
a1241 5
            if(false) throw new cli.System.IO.IOException();
            if(false) throw new cli.System.ObjectDisposedException(null);
	    stream.Write(buf, offset, len);
	    // NOTE FileStream buffers the output, so we have to flush explicitly
	    stream.Flush();
d1243 1
a1243 1
	catch(cli.System.IO.IOException x)
d1245 30
a1274 1
	    throw new IOException(x.getMessage());
a1275 27
        catch(cli.System.ObjectDisposedException x2)
        {
            throw new ClosedChannelException();
        }
    }
  
    public void write(int b) throws IOException
    {
        if(stream == null)
            throw new ClosedChannelException();

        try
        {
            if(false) throw new cli.System.IO.IOException();
            if(false) throw new cli.System.ObjectDisposedException(null);
            stream.WriteByte((byte)b);
            // NOTE FileStream buffers the output, so we have to flush explicitly
            stream.Flush();
        }
        catch(cli.System.IO.IOException x)
        {
            throw new IOException(x.getMessage());
        }
        catch(cli.System.ObjectDisposedException x2)
        {
            throw new ClosedChannelException();
        }
d1278 2
a1279 2
    public long write(ByteBuffer[] srcs, int offset, int length)
	throws IOException
d1281 2
a1282 3
	long result = 0;

	for (int i = offset;i < offset + length;i++)
d1284 8
a1291 1
	    result += write (srcs[i]);
d1293 20
a1312 13
    
	return result;
    }
				   
    private MappedByteBuffer mapImpl (char mode, long position, final int size) throws IOException
    {
        if (! (stream instanceof FileStream))
            throw new IllegalArgumentException("only file streams can be mapped");

        final IntPtr ptr = mapViewOfFile((FileStream)stream, mode != 'r', mode == 'c', position, size);
	Runnable um = new Runnable() {
	    public void run() {
		unmapViewOfFile(ptr, size);
d1314 1
a1314 4
	};
	return mode != 'r'
	    ? Util.newMappedByteBuffer(size, ptr.ToInt64(), um)
	    : Util.newMappedByteBufferR(size, ptr.ToInt64(), um);
d1317 2
a1318 3
    public MappedByteBuffer map (FileChannel.MapMode mode,
	long position, long size)
	throws IOException
d1320 3
a1322 15
	char nmode = 0;
	if (mode == MapMode.READ_ONLY)
	{
	    nmode = 'r';
	    if ((this.mode & READ) == 0)
		throw new NonReadableChannelException();
	}
	else if (mode == MapMode.READ_WRITE || mode == MapMode.PRIVATE)
	{
	    nmode = mode == MapMode.READ_WRITE ? '+' : 'c';
            if ((this.mode & READ) == 0)
                throw new NonReadableChannelException();
            if ((this.mode & WRITE) == 0)
                throw new NonWritableChannelException();
	}
d1324 1
a1324 6
            throw new IllegalArgumentException ("mode: " + mode);
    
	if (position < 0 || size < 0 || size > Integer.MAX_VALUE)
            throw new IllegalArgumentException ("position: " + position
                                                + ", size: " + size);
        return mapImpl(nmode, position, (int) size);
d1327 1
a1327 4
    /**
     * msync with the disk
     */
    public void force (boolean metaData) throws IOException
d1329 9
a1337 2
	if (!isOpen ())
	    throw new ClosedChannelException ();
d1339 2
a1340 2
	if (!stream.get_CanWrite())
	    return;
d1342 17
a1358 9
	try
	{
	    if (false) throw new cli.System.IO.IOException();
	    stream.Flush();
	}
	catch(cli.System.IO.IOException x)
	{
	    throw new IOException(x.getMessage());
	}
d1360 10
a1369 3
	if (stream instanceof FileStream)
	{
	    if(!flush(((FileStream)stream)))
d1371 5
a1375 1
		throw new IOException();
d1377 5
d1385 1
a1385 1
    public long transferTo(long position, long count, WritableByteChannel target) throws IOException
d1387 13
a1399 2
        if (position < 0 || count < 0)
            throw new IllegalArgumentException ("position: " + position + ", count: " + count);
d1401 6
a1406 2
        if (!isOpen())
            throw new ClosedChannelException ();
d1408 4
a1411 7
        if ((mode & READ) == 0)
            throw new NonReadableChannelException ();
   
        long total = 0;
        ByteBuffer buf = ByteBuffer.allocate((int)Math.min(4096, count));

        while (count > 0)
d1413 3
a1415 4
            buf.clear();
            buf.limit((int)Math.min(buf.capacity(), count));
            int bytesRead = read(buf, position);
            if (bytesRead <= 0)
d1417 2
a1418 10
                break;
            }
            buf.flip();
            int bytesWritten = target.write(buf);
            total += bytesWritten;
            position += bytesWritten;
            count -= bytesWritten;
            if (bytesWritten != bytesRead)
            {
                break;
d1421 2
d1424 2
a1425 2
        return total;
    }
d1427 2
a1428 4
    public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException
    {
        if (position < 0 || count < 0)
            throw new IllegalArgumentException ("position: " + position + ", count: " + count);
d1430 2
a1431 2
        if (!isOpen())
            throw new ClosedChannelException ();
d1433 2
a1434 2
        if ((mode & WRITE) == 0)
            throw new NonWritableChannelException ();
d1436 2
a1437 2
        long total = 0;
        ByteBuffer buf = ByteBuffer.allocate((int)Math.min(4096, count));
d1439 2
a1440 15
        while (count > 0)
        {
            buf.clear();
            buf.limit((int)Math.min(buf.capacity(), count));
            long transferred = src.read(buf);
            if (transferred <= 0)
            {
                break;
            }
            buf.flip();
            write(buf, position);
            total += transferred;
            position += transferred;
            count -= transferred;
        }
d1442 2
a1443 2
        return total;
    }
d1445 2
a1446 8
    // Shared sanity checks between lock and tryLock methods.
    private void lockCheck(long position, long size, boolean shared)
        throws IOException
    {
        if (position < 0
            || size < 0)
            throw new IllegalArgumentException ("position: " + position
                + ", size: " + size);
d1448 2
a1449 2
        if (!isOpen ())
            throw new ClosedChannelException();
d1451 8
a1458 5
        if (shared && ((mode & READ) == 0))
            throw new NonReadableChannelException();
	
        if (!shared && ((mode & WRITE) == 0))
            throw new NonWritableChannelException();
d1461 2
a1462 2
    public FileLock tryLock (long position, long size, boolean shared)
	throws IOException
d1464 3
a1466 14
        lockCheck(position, size, shared);
	
	boolean completed = false;
    
	try
	{
	    begin();
	    boolean lockable = lock(position, size, shared, false);
	    completed = true;
            return (lockable
                ? new FileLockImpl(this, position, size, shared)
                : null);
	}
	finally
d1468 1
a1468 1
	    end(completed);
d1470 1
d1473 2
a1474 6
    /** Try to acquire a lock at the given position and size.
     * On success return true.
     * If wait as specified, block until we can get it.
     * Otherwise return false.
     */
    private boolean lock(long position, long size, boolean shared, boolean wait) throws IOException
d1476 3
a1478 2
	if(stream == null)
	    throw new IOException("Invalid FileChannelImpl");
d1480 4
a1483 50
	try
	{
	    if(false) throw new cli.System.ArgumentOutOfRangeException();
            int backoff = 5;
            for(;;)
            {
                try
                {
                    if(false) throw new cli.System.IO.IOException();
                    ((FileStream)stream).Lock(position, size);
                    return true;
                }
                catch(cli.System.IO.IOException x)
                {
                    if(!wait)
                    {
                        return false;
                    }
                    try
                    {
                        Thread.sleep(backoff);
                        backoff *= 2;
                        if(backoff > 1000)
                        {
                            backoff = 40;
                        }
                    }
                    catch(InterruptedException _)
                    {
                        // SPECNOTE The API spec says that an interrupt lock
                        // throws a FileLockInterruptedException, but in
                        // reality Sun returns null from lock (at least on Windows).
                        return false;
                    }
                }
            }
	}
	catch(ClassCastException c)
	{
	    throw new IOException("Locking not supported");
	}
	catch(cli.System.ArgumentOutOfRangeException x1)
	{
	    throw new IOException(x1.getMessage());
	}
	// TODO map al the other exceptions as well...	
    }
  
    public FileLock lock (long position, long size, boolean shared)
	throws IOException
d1485 1
a1485 13
        lockCheck(position, size, shared);

	boolean completed = false;

	try
	{
	    boolean lockable = lock(position, size, shared, true);
	    completed = true;
	    return (lockable
		? new FileLockImpl(this, position, size, shared)
		: null);
	}
	finally
d1487 1
a1487 1
	    end(completed);
d1489 2
d1493 2
a1494 11
    public long position ()
	throws IOException
    {
	if (!isOpen ())
	    throw new ClosedChannelException ();

	return implPosition ();
    }
  
    public FileChannel position (long newPosition)
	throws IOException
d1496 1
a1496 10
	if (newPosition < 0)
            throw new IllegalArgumentException ("newPostition: " + newPosition);

	if (!isOpen ())
	    throw new ClosedChannelException ();

	// FIXME note semantics if seeking beyond eof.
	// We should seek lazily - only on a write.
	seek (newPosition);
	return this;
a1497 6
  
    public FileChannel truncate (long size)
	throws IOException
    {
	if (size < 0)
            throw new IllegalArgumentException ("size: " + size);
d1499 3
a1501 9
	if (!isOpen ())
	    throw new ClosedChannelException ();

	if ((mode & WRITE) == 0)
	    throw new NonWritableChannelException ();

        if (size < size ())
            implTruncate (size);
	return this;
a1503 4
    public Stream getStream()
    {
	return stream;
    }
@


1.1
log
@Integrated OpenJDK's java.io.FileDescriptor, FileInputStream, FileOutputStream & RandomAccessFile.
@
text
@d1 38
d41 24
a64 1
import java.io.*;
d66 2
a67 1
public final class FileChannelImpl
d69 28
d99 1
a99 1
	return gnu.java.nio.FileChannelImpl.create(fd.getStream());
d104 939
a1042 1
	return gnu.java.nio.FileChannelImpl.create(fd.getStream());
@

