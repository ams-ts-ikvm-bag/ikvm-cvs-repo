head	1.36;
access;
symbols
	v8_1_5717_0:1.35
	v8_1:1.35.0.2
	v8_0_5449_1:1.32
	v8_0_5449_0:1.32
	v8_0:1.32.0.2
	v7_4_5196_0:1.27
	v7_4:1.27.0.2
	v7_3:1.23.0.4
	v7_2_4630_6:1.23
	v7_2_4630_5:1.23
	v7_2_4630_4:1.23
	v7_2_4630_3:1.23
	v7_2_4630_2:1.23
	v0_46_0_4:1.14
	v7_2_4630_1:1.23
	v7_2:1.23.0.2
	v7_1_4532_2:1.22
	v7_1_4532_1:1.22
	v7_1_4532_0:1.22
	v7_1:1.22.0.2
	v7_0_4335_3:1.20
	v7_0_4335_2:1.20
	v7_0_4335_1:1.20
	v0_46_0_2:1.14
	v7_0_4335_0:1.20
	v7_0:1.20.0.2
	v0_40_0_6:1.10
	v0_40_0_5:1.10
	v0_46_0_1:1.14
	v0_46_0_0:1.14
	v0_46:1.14.0.4
	v0_36_0_14:1.6
	v0_44_0_6:1.14
	v0_44_0_5:1.14
	v0_44_0_4:1.14
	v0_44_0_3:1.14
	v0_44_0_2:1.14
	v0_42_0_7:1.12
	v0_44_0_1:1.14
	v0_44_0_0:1.14
	v0_44:1.14.0.2
	v0_42_0_6:1.12
	v0_42_0_5:1.12
	v0_42_0_4:1.12
	v0_42_0_3:1.12
	v0_42_0_2:1.12
	v0_42_0_1:1.12
	v0_42_0_0:1.12
	v0_42:1.12.0.2
	v0_40_0_3:1.10
	v0_40_0_2:1.10
	v0_40_0_1:1.10
	v0_40_0_0:1.10
	v0_40:1.10.0.4
	v0_36_0_13:1.6
	v0_38_0_1:1.10
	v0_38_0_0:1.10
	v0_38:1.10.0.2
	v0_36_0_9:1.6
	v0_36_0_7:1.6
	v0_36_0_5:1.6
	v0_36_0_4:1.6
	v0_36_0_3:1.6
	v0_36_0_2:1.6
	v0_36_0_1:1.6
	v0_36_0_0:1.6
	v0_36:1.6.0.2;
locks; strict;
comment	@# @;


1.36
date	2015.12.12.10.10.17;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2015.05.31.08.43.55;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2015.03.11.08.44.44;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2015.03.05.13.25.30;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2014.11.14.15.27.44;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2014.11.06.12.29.25;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.22.12.07.41;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.19.12.43.41;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.04.03.13.45;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2014.02.27.06.57.35;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2014.02.21.08.47.21;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2014.02.20.16.51.25;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2013.08.12.07.55.58;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2012.07.05.09.57.09;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2012.03.11.13.31.19;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2012.02.23.11.51.07;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2011.09.02.09.59.49;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2011.09.02.08.16.21;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.25.23.11.09;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.15.09.05.27;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.06.12.43.06;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.01.08.56.51;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.02.08.21.00;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.12.06.38.46;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.14.08.45.36;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.17.06.16.34;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.11.09.05.45;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.31.15.20.35;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.23.05.21.10;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.28.10.19.39;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.15.12.04.25;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.07.07.41.43;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.29.08.48.22;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.25.06.48.12;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.19.06.09.13;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.29.16.27.11;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Added Unsafe.setMemory(Object, ...) overload.
@
text
@/*
  Copyright (C) 2006-2014 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/

package sun.misc;

import cli.System.Buffer;
import cli.System.IntPtr;
import cli.System.Runtime.InteropServices.Marshal;
import cli.System.Security.Permissions.SecurityAction;
import cli.System.Security.Permissions.SecurityPermissionAttribute;
import ikvm.lang.Internal;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.security.ProtectionDomain;
import java.util.ArrayList;

public final class Unsafe
{
    public static final int INVALID_FIELD_OFFSET = -1;
    public static final int ARRAY_BYTE_BASE_OFFSET = 0;
    // NOTE sun.corba.Bridge actually access this field directly (via reflection),
    // so the name must match the JDK name.
    private static final Unsafe theUnsafe = new Unsafe();
    private static final ArrayList<Field> fields = new ArrayList<Field>();

    private Unsafe() { }

    @@sun.reflect.CallerSensitive
    public static Unsafe getUnsafe()
    {
        if(!VM.isSystemDomainLoader(ikvm.internal.CallerID.getCallerID().getCallerClassLoader()))
        {
            throw new SecurityException("Unsafe");
        }
        return theUnsafe;
    }

    private static native Field createFieldAndMakeAccessible(Class c, String field);
    private static native Field copyFieldAndMakeAccessible(Field field);

    // this is the intrinsified version of objectFieldOffset(XXX.class.getDeclaredField("xxx"))
    public long objectFieldOffset(Class c, String field)
    {
        return allocateUnsafeFieldId(createFieldAndMakeAccessible(c, field));
    }

    // NOTE we have a really lame (and slow) implementation!
    public long objectFieldOffset(Field field)
    {
        if(Modifier.isStatic(field.getModifiers()))
        {
            throw new IllegalArgumentException();
        }
        return allocateUnsafeFieldId(field);
    }
    
    public long staticFieldOffset(Field field)
    {
        if(!Modifier.isStatic(field.getModifiers()))
        {
            throw new IllegalArgumentException();
        }
        return allocateUnsafeFieldId(field);
    }

    @@Deprecated
    public int fieldOffset(Field original)
    {
        return allocateUnsafeFieldId(original);
    }
    
    static int allocateUnsafeFieldId(Field original)
    {
        Field copy = copyFieldAndMakeAccessible(original);
        synchronized(fields)
        {
            int id = fields.size();
            fields.add(copy);
            return id;
        }
    }

    public int arrayBaseOffset(Class c)
    {
        // don't change this, the Unsafe intrinsics depend on this value
        return 0;
    }

    public int arrayIndexScale(Class c)
    {
        if (c == byte[].class || c == boolean[].class)
        {
            return 1;
        }
        if (c == char[].class || c == short[].class)
        {
            return 2;
        }
        if (c == int[].class || c == float[].class)
        {
            return 4;
        }
        if (c == long[].class || c == double[].class)
        {
            return 8;
        }
        // don't change this, the Unsafe intrinsics depend on this value
        return 1;
    }

    static Field getField(long offset)
    {
        synchronized(fields)
        {
            return fields.get((int)offset);
        }
    }

    public final native boolean compareAndSwapObject(Object obj, long offset, Object expect, Object update);

    public void putObjectVolatile(Object obj, long offset, Object newValue)
    {
        if(obj instanceof Object[])
        {
            synchronized(this)
            {
                ((Object[])obj)[(int)offset] = newValue;
            }
        }
        else
        {
            Field field = getField(offset);
            synchronized(field)
            {
                try
                {
                    field.set(obj, newValue);
                }
                catch(IllegalAccessException x)
                {
                    throw (InternalError)new InternalError().initCause(x);
                }
            }
        }
    }

    public void putOrderedObject(Object obj, long offset, Object newValue)
    {
        putObjectVolatile(obj, offset, newValue);
    }

    public Object getObjectVolatile(Object obj, long offset)
    {
        if(obj instanceof Object[])
        {
            synchronized(this)
            {
                return ((Object[])obj)[(int)offset];
            }
        }
        else
        {
            Field field = getField(offset);
            synchronized(field)
            {
                try
                {
                    return field.get(obj);
                }
                catch(IllegalAccessException x)
                {
                    throw (InternalError)new InternalError().initCause(x);
                }
            }
        }
    }

    private static native short ReadInt16(Object obj, long offset);
    private static native int ReadInt32(Object obj, long offset);
    private static native long ReadInt64(Object obj, long offset);
    private static native void WriteInt16(Object obj, long offset, short value);
    private static native void WriteInt32(Object obj, long offset, int value);
    private static native void WriteInt64(Object obj, long offset, long value);

    public final native boolean compareAndSwapInt(Object obj, long offset, int expect, int update);

    public void putIntVolatile(Object obj, long offset, int newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            synchronized(this)
            {
                WriteInt32(obj, offset, newValue);
            }
        }
        else
        {
            Field field = getField(offset);
            synchronized(field)
            {
                try
                {
                    field.setInt(obj, newValue);
                }
                catch(IllegalAccessException x)
                {
                    throw (InternalError)new InternalError().initCause(x);
                }
            }
        }
    }

    public void putOrderedInt(Object obj, long offset, int newValue)
    {
        putIntVolatile(obj, offset, newValue);
    }

    public int getIntVolatile(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            synchronized(this)
            {
                return ReadInt32(obj, offset);
            }
        }
        else
        {
            Field field = getField(offset);
            synchronized(field)
            {
                try
                {
                    return field.getInt(obj);
                }
                catch(IllegalAccessException x)
                {
                    throw (InternalError)new InternalError().initCause(x);
                }
            }
        }
    }

    public final native boolean compareAndSwapLong(Object obj, long offset, long expect, long update);

    public void putLongVolatile(Object obj, long offset, long newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            synchronized(this)
            {
                WriteInt64(obj, offset, newValue);
            }
        }
        else
        {
            Field field = getField(offset);
            synchronized(field)
            {
                try
                {
                    field.setLong(obj, newValue);
                }
                catch(IllegalAccessException x)
                {
                    throw (InternalError)new InternalError().initCause(x);
                }
            }
        }
    }

    public void putOrderedLong(Object obj, long offset, long newValue)
    {
        putLongVolatile(obj, offset, newValue);
    }

    public long getLongVolatile(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            synchronized(this)
            {
                return ReadInt64(obj, offset);
            }
        }
        else
        {
            Field field = getField(offset);
            synchronized(field)
            {
                try
                {
                    return field.getLong(obj);
                }
                catch(IllegalAccessException x)
                {
                    throw (InternalError)new InternalError().initCause(x);
                }
            }
        }
    }

    public void putBoolean(Object obj, long offset, boolean newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            Buffer.SetByte((cli.System.Array)obj, (int)offset, newValue ? (byte)1 : (byte)0);
        }
        else
        {
            try
            {
                getField(offset).setBoolean(obj, newValue);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public void putBooleanVolatile(Object obj, long offset, boolean newValue)
    {
        putBoolean(obj, offset, newValue);
    }

    public boolean getBoolean(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            return Buffer.GetByte((cli.System.Array)obj, (int)offset) != 0;
        }
        else
        {
            try
            {
                return getField(offset).getBoolean(obj);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public boolean getBooleanVolatile(Object obj, long offset)
    {
        return getBoolean(obj, offset);
    }

    public void putByte(Object obj, long offset, byte newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            Buffer.SetByte((cli.System.Array)obj, (int)offset, newValue);
        }
        else
        {
            try
            {
                getField(offset).setByte(obj, newValue);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public void putByteVolatile(Object obj, long offset, byte newValue)
    {
        putByte(obj, offset, newValue);
    }

    public byte getByte(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            return Buffer.GetByte((cli.System.Array)obj, (int)offset);
        }
        else
        {
            try
            {
                return getField(offset).getByte(obj);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public byte getByteVolatile(Object obj, long offset)
    {
        return getByte(obj, offset);
    }

    public void putChar(Object obj, long offset, char newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            WriteInt16(obj, offset, (short)newValue);
        }
        else
        {
            try
            {
                getField(offset).setChar(obj, newValue);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public void putCharVolatile(Object obj, long offset, char newValue)
    {
        putChar(obj, offset, newValue);
    }

    public char getChar(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            return (char)ReadInt16(obj, offset);
        }
        else
        {
            try
            {
                return getField(offset).getChar(obj);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public char getCharVolatile(Object obj, long offset)
    {
        return getChar(obj, offset);
    }

    public void putShort(Object obj, long offset, short newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            WriteInt16(obj, offset, newValue);
        }
        else
        {
            try
            {
                getField(offset).setShort(obj, newValue);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public void putShortVolatile(Object obj, long offset, short newValue)
    {
        putShort(obj, offset, newValue);
    }

    public short getShort(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            return ReadInt16(obj, offset);
        }
        else
        {
            try
            {
                return getField(offset).getShort(obj);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public short getShortVolatile(Object obj, long offset)
    {
        return getShort(obj, offset);
    }

    public void putInt(Object obj, long offset, int newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            WriteInt32(obj, offset, newValue);
        }
        else
        {
            try
            {
                getField(offset).setInt(obj, newValue);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public int getInt(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            return ReadInt32(obj, offset);
        }
        else
        {
            try
            {
                return getField(offset).getInt(obj);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public void putFloat(Object obj, long offset, float newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            WriteInt32(obj, offset, Float.floatToRawIntBits(newValue));
        }
        else
        {
            try
            {
                getField(offset).setFloat(obj, newValue);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public void putFloatVolatile(Object obj, long offset, float newValue)
    {
        putFloat(obj, offset, newValue);
    }

    public float getFloat(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            return Float.intBitsToFloat(ReadInt32(obj, offset));
        }
        else
        {
            try
            {
                return getField(offset).getFloat(obj);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public float getFloatVolatile(Object obj, long offset)
    {
        return getFloat(obj, offset);
    }

    public void putLong(Object obj, long offset, long newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            WriteInt64(obj, offset, newValue);
        }
        else
        {
            try
            {
                getField(offset).setLong(obj, newValue);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public long getLong(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            return ReadInt64(obj, offset);
        }
        else
        {
            try
            {
                return getField(offset).getLong(obj);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public void putDouble(Object obj, long offset, double newValue)
    {
        if (obj instanceof cli.System.Array)
        {
            WriteInt64(obj, offset, Double.doubleToRawLongBits(newValue));
        }
        else
        {
            try
            {
                getField(offset).setDouble(obj, newValue);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public void putDoubleVolatile(Object obj, long offset, double newValue)
    {
        synchronized (this)
        {
            putDouble(obj, offset, newValue);
        }
    }

    public double getDouble(Object obj, long offset)
    {
        if (obj instanceof cli.System.Array)
        {
            return Double.longBitsToDouble(ReadInt64(obj, offset));
        }
        else
        {
            try
            {
                return getField(offset).getDouble(obj);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public double getDoubleVolatile(Object obj, long offset)
    {
        synchronized (this)
        {
            return getDouble(obj, offset);
        }
    }

    public void putObject(Object obj, long offset, Object newValue)
    {
        if (obj instanceof Object[])
        {
            ((Object[])obj)[(int)offset] = newValue;
        }
        else
        {
            try
            {
                getField(offset).set(obj, newValue);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    public Object getObject(Object obj, long offset)
    {
        if (obj instanceof Object[])
        {
            return ((Object[])obj)[(int)offset];
        }
        else
        {
            try
            {
                return getField(offset).get(obj);
            }
            catch (IllegalAccessException x)
            {
                throw (InternalError)new InternalError().initCause(x);
            }
        }
    }

    @@Deprecated
    public int getInt(Object o, int offset)
    {
        return getInt(o, (long)offset);
    }

    @@Deprecated
    public void putInt(Object o, int offset, int x)
    {
        putInt(o, (long)offset, x);
    }

    @@Deprecated
    public Object getObject(Object o, int offset)
    {
        return getObject(o, (long)offset);
    }

    @@Deprecated
    public void putObject(Object o, int offset, Object x)
    {
        putObject(o, (long)offset, x);
    }

    @@Deprecated
    public boolean getBoolean(Object o, int offset)
    {
        return getBoolean(o, (long)offset);
    }

    @@Deprecated
    public void putBoolean(Object o, int offset, boolean x)
    {
        putBoolean(o, (long)offset, x);
    }

    @@Deprecated
    public byte getByte(Object o, int offset)
    {
        return getByte(o, (long)offset);
    }

    @@Deprecated
    public void putByte(Object o, int offset, byte x)
    {
        putByte(o, (long)offset, x);
    }

    @@Deprecated
    public short getShort(Object o, int offset)
    {
        return getShort(o, (long)offset);
    }

    @@Deprecated
    public void putShort(Object o, int offset, short x)
    {
        putShort(o, (long)offset, x);
    }

    @@Deprecated
    public char getChar(Object o, int offset)
    {
        return getChar(o, (long)offset);
    }

    @@Deprecated
    public void putChar(Object o, int offset, char x)
    {
        putChar(o, (long)offset, x);
    }

    @@Deprecated
    public long getLong(Object o, int offset)
    {
        return getLong(o, (long)offset);
    }

    @@Deprecated
    public void putLong(Object o, int offset, long x)
    {
        putLong(o, (long)offset, x);
    }

    @@Deprecated
    public float getFloat(Object o, int offset)
    {
        return getFloat(o, (long)offset);
    }

    @@Deprecated
    public void putFloat(Object o, int offset, float x)
    {
        putFloat(o, (long)offset, x);
    }

    @@Deprecated
    public double getDouble(Object o, int offset)
    {
        return getDouble(o, (long)offset);
    }

    @@Deprecated
    public void putDouble(Object o, int offset, double x)
    {
        putDouble(o, (long)offset, x);
    }

    public native void throwException(Throwable t);

    public native void ensureClassInitialized(Class clazz);

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, SerializationFormatter = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public native Object allocateInstance(Class clazz) throws InstantiationException;

    public int addressSize()
    {
        return IntPtr.get_Size();
    }

    public int pageSize()
    {
        return 4096;
    }

    // The really unsafe methods start here. They are all have a LinkDemand for unmanaged code.

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public long allocateMemory(long bytes)
    {
        if (bytes == 0)
        {
            return 0;
        }
        try
        {
            if (false) throw new cli.System.OutOfMemoryException();
            return Marshal.AllocHGlobal(IntPtr.op_Explicit(bytes)).ToInt64();
        }
        catch (cli.System.OutOfMemoryException x)
        {
            throw new OutOfMemoryError(x.get_Message());
        }
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public long reallocateMemory(long address, long bytes)
    {
        if (bytes == 0)
        {
            freeMemory(address);
            return 0;
        }
        try
        {
            if (false) throw new cli.System.OutOfMemoryException();
            return Marshal.ReAllocHGlobal(IntPtr.op_Explicit(address), IntPtr.op_Explicit(bytes)).ToInt64();
        }
        catch (cli.System.OutOfMemoryException x)
        {
            throw new OutOfMemoryError(x.get_Message());
        }
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void freeMemory(long address)
    {
        Marshal.FreeHGlobal(IntPtr.op_Explicit(address));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void setMemory(long address, long bytes, byte value)
    {
        while (bytes-- > 0)
        {
            putByte(address++, value);
        }
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void setMemory(Object o, long offset, long bytes, byte value)
    {
        if (o == null)
        {
            setMemory(offset, bytes, value);
        }
        else if (o instanceof byte[])
        {
            byte[] array = (byte[])o;
            for (int i = 0; i < bytes; i++)
            {
                array[(int)(offset + i)] = value;
            }
        }
        else if (o instanceof cli.System.Array)
        {
            cli.System.Array array = (cli.System.Array)o;
            for (int i = 0; i < bytes; i++)
            {
                cli.System.Buffer.SetByte(array, (int)(offset + i), value);
            }
        }
        else
        {
            throw new IllegalArgumentException();
        }
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void copyMemory(long srcAddress, long destAddress, long bytes)
    {
	while (bytes-- > 0)
	{
	    putByte(destAddress++, getByte(srcAddress++));
	}
    }
    
    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes)
    {
        if (srcBase == null)
        {
            if (destBase instanceof byte[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy(IntPtr.op_Explicit(srcOffset), (byte[])destBase, (int)destOffset, (int)bytes);
            }
            else if (destBase instanceof boolean[])
            {
                byte[] tmp = new byte[(int)bytes];
                copyMemory(srcBase, srcOffset, tmp, 0, bytes);
                copyMemory(tmp, 0, destBase, destOffset, bytes);
            }
            else if (destBase instanceof short[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy(IntPtr.op_Explicit(srcOffset), (short[])destBase, (int)(destOffset >> 1), (int)(bytes >> 1));
            }
            else if (destBase instanceof char[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy(IntPtr.op_Explicit(srcOffset), (char[])destBase, (int)(destOffset >> 1), (int)(bytes >> 1));
            }
            else if (destBase instanceof int[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy(IntPtr.op_Explicit(srcOffset), (int[])destBase, (int)(destOffset >> 2), (int)(bytes >> 2));
            }
            else if (destBase instanceof float[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy(IntPtr.op_Explicit(srcOffset), (float[])destBase, (int)(destOffset >> 2), (int)(bytes >> 2));
            }
            else if (destBase instanceof long[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy(IntPtr.op_Explicit(srcOffset), (long[])destBase, (int)(destOffset >> 3), (int)(bytes >> 3));
            }
            else if (destBase instanceof double[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy(IntPtr.op_Explicit(srcOffset), (double[])destBase, (int)(destOffset >> 3), (int)(bytes >> 3));
            }
            else if (destBase == null)
            {
                copyMemory(srcOffset, destOffset, bytes);
            }
            else
            {
                throw new IllegalArgumentException();
            }
        }
        else if (srcBase instanceof cli.System.Array && destBase instanceof cli.System.Array)
        {
            cli.System.Buffer.BlockCopy((cli.System.Array)srcBase, (int)srcOffset, (cli.System.Array)destBase, (int)destOffset, (int)bytes);
        }
        else
        {
            if (srcBase instanceof byte[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy((byte[])srcBase, (int)srcOffset, IntPtr.op_Explicit(destOffset), (int)bytes);
            }
            else if (srcBase instanceof boolean[])
            {
                byte[] tmp = new byte[(int)bytes];
                copyMemory(srcBase, srcOffset, tmp, 0, bytes);
                copyMemory(tmp, 0, destBase, destOffset, bytes);
            }
            else if (srcBase instanceof short[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy((short[])srcBase, (int)(srcOffset >> 1), IntPtr.op_Explicit(destOffset), (int)(bytes >> 1));
            }
            else if (srcBase instanceof char[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy((char[])srcBase, (int)(srcOffset >> 1), IntPtr.op_Explicit(destOffset), (int)(bytes >> 1));
            }
            else if (srcBase instanceof int[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy((int[])srcBase, (int)(srcOffset >> 2), IntPtr.op_Explicit(destOffset), (int)(bytes >> 2));
            }
            else if (srcBase instanceof float[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy((float[])srcBase, (int)(srcOffset >> 2), IntPtr.op_Explicit(destOffset), (int)(bytes >> 2));
            }
            else if (srcBase instanceof long[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy((long[])srcBase, (int)(srcOffset >> 3), IntPtr.op_Explicit(destOffset), (int)(bytes >> 3));
            }
            else if (srcBase instanceof double[])
            {
                cli.System.Runtime.InteropServices.Marshal.Copy((double[])srcBase, (int)(srcOffset >> 3), IntPtr.op_Explicit(destOffset), (int)(bytes >> 3));
            }
            else
            {
                throw new IllegalArgumentException();
            }
        }
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public byte getByte(long address)
    {
	return cli.System.Runtime.InteropServices.Marshal.ReadByte(IntPtr.op_Explicit(address));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void putByte(long address, byte x)
    {
	cli.System.Runtime.InteropServices.Marshal.WriteByte(IntPtr.op_Explicit(address), x);
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public short getShort(long address)
    {
	return cli.System.Runtime.InteropServices.Marshal.ReadInt16(IntPtr.op_Explicit(address));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void putShort(long address, short x)
    {
	cli.System.Runtime.InteropServices.Marshal.WriteInt16(IntPtr.op_Explicit(address), x);
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public char getChar(long address)
    {
        return (char)cli.System.Runtime.InteropServices.Marshal.ReadInt16(IntPtr.op_Explicit(address));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void putChar(long address, char x)
    {
        cli.System.Runtime.InteropServices.Marshal.WriteInt16(IntPtr.op_Explicit(address), (short)x);
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public int getInt(long address)
    {
	return cli.System.Runtime.InteropServices.Marshal.ReadInt32(IntPtr.op_Explicit(address));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void putInt(long address, int x)
    {
	cli.System.Runtime.InteropServices.Marshal.WriteInt32(IntPtr.op_Explicit(address), x);
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public long getLong(long address)
    {
	return cli.System.Runtime.InteropServices.Marshal.ReadInt64(IntPtr.op_Explicit(address));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void putLong(long address, long x)
    {
	cli.System.Runtime.InteropServices.Marshal.WriteInt64(IntPtr.op_Explicit(address), x);
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public long getAddress(long address)
    {
	return cli.System.Runtime.InteropServices.Marshal.ReadIntPtr(IntPtr.op_Explicit(address)).ToInt64();
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void putAddress(long address, long x)
    {
	cli.System.Runtime.InteropServices.Marshal.WriteIntPtr(IntPtr.op_Explicit(address), IntPtr.op_Explicit(x));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public float getFloat(long address)
    {
        return Float.intBitsToFloat(getInt(address));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void putFloat(long address, float x)
    {
        putInt(address, Float.floatToIntBits(x));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public double getDouble(long address)
    {
        return Double.longBitsToDouble(getLong(address));
    }

    @@SecurityPermissionAttribute.Annotation(value = SecurityAction.__Enum.LinkDemand, UnmanagedCode = true)
    @@cli.System.Security.SecurityCriticalAttribute.Annotation
    public void putDouble(long address, double x)
    {
        putLong(address, Double.doubleToLongBits(x));
    }
    
    public int getLoadAverage(double[] loadavg, int nelems)
    {
        return -1;
    }

    public void park(boolean isAbsolute, long time)
    {
        if (isAbsolute)
        {
            java.util.concurrent.locks.LockSupport.parkUntil(time);
        }
        else
        {
            if (time == 0)
            {
                time = Long.MAX_VALUE;
            }
            java.util.concurrent.locks.LockSupport.parkNanos(time);
        }
    }

    public void unpark(Object thread)
    {
        java.util.concurrent.locks.LockSupport.unpark((Thread)thread);
    }

    public Object staticFieldBase(Field f)
    {
        return null;
    }
    
    @@Deprecated
    public Object staticFieldBase(Class<?> c)
    {
        return null;
    }

    public native boolean shouldBeInitialized(Class<?> c);

    public native Class defineClass(String name, byte[] buf, int offset, int length, ClassLoader cl, ProtectionDomain pd);

    @@Deprecated
    @@sun.reflect.CallerSensitive
    public native Class defineClass(String name, byte[] b, int off, int len);

    public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches);

    public void monitorEnter(Object o)
    {
        cli.System.Threading.Monitor.Enter(o);
    }

    public void monitorExit(Object o)
    {
        cli.System.Threading.Monitor.Exit(o);
    }

    public boolean tryMonitorEnter(Object o)
    {
        return cli.System.Threading.Monitor.TryEnter(o);
    }

    public final int getAndAddInt(Object o, long offset, int delta)
    {
        for (;;)
        {
            int value = getIntVolatile(o, offset);
            if (compareAndSwapInt(o, offset, value, value + delta))
            {
                return value;
            }
        }
    }

    public final long getAndAddLong(Object o, long offset, long delta)
    {
        for (;;)
        {
            long value = getLongVolatile(o, offset);
            if (compareAndSwapLong(o, offset, value, value + delta))
            {
                return value;
            }
        }
    }

    public final int getAndSetInt(Object o, long offset, int newValue)
    {
        for (;;)
        {
            int value = getIntVolatile(o, offset);
            if (compareAndSwapInt(o, offset, value, newValue))
            {
                return value;
            }
        }
    }

    public final long getAndSetLong(Object o, long offset, long newValue)
    {
        for (;;)
        {
            long value = getLongVolatile(o, offset);
            if (compareAndSwapLong(o, offset, value, newValue))
            {
                return value;
            }
        }
    }

    public final Object getAndSetObject(Object o, long offset, Object newValue)
    {
        for (;;)
        {
            Object value = getObjectVolatile(o, offset);
            if (compareAndSwapObject(o, offset, value, newValue))
            {
                return value;
            }
        }
    }

    public void loadFence()
    {
        cli.System.Threading.Thread.MemoryBarrier();
    }

    public void storeFence()
    {
        cli.System.Threading.Thread.MemoryBarrier();
    }

    public void fullFence()
    {
        cli.System.Threading.Thread.MemoryBarrier();
    }
}
@


1.35
log
@Added Unsafe.staticFieldOffset() and Unsafe.staticFieldBase() methods.
@
text
@d918 30
@


1.34
log
@Bug fix. MethodHandle and JNI should be able to set static final fields.
@
text
@d77 9
d1164 6
@


1.33
log
@Added Unsafe.reallocateMemory() and fixed allocateMemory() to do nothing if zero length is allocated.
@
text
@a34 1
import java.lang.reflect.ReflectHelper;
d59 3
d65 1
a65 1
        return allocateUnsafeFieldId(ReflectHelper.createFieldAndMakeAccessible(c, field));
d86 1
a86 1
        Field copy = ReflectHelper.copyFieldAndMakeAccessible(original);
@


1.32
log
@Made Unsafe interlocked operations truly atomic (except for unaligned array access and 'wrong' array type access).
@
text
@d853 4
d870 20
@


1.31
log
@Made sun.misc.Unsafe array access more compatible with JDK. It is now possible to get/set primitive values from arrays of a different (primitive) type
@
text
@d121 1
a121 1
    private static Field getField(long offset)
d129 1
a129 37
    public boolean compareAndSwapObject(Object obj, long offset, Object expect, Object update)
    {
        if(obj instanceof Object[])
        {
            Object[] arr = (Object[])obj;
            int index = (int)offset;
            synchronized(this)
            {
                if(arr[index] == expect)
                {
                    arr[index] = update;
                    return true;
                }
                return false;
            }
        }
        else
        {
            Field field = getField(offset);
            synchronized(field)
            {
                try
                {
                    if(field.get(obj) == expect)
                    {
                        field.set(obj, update);
                        return true;
                    }
                    return false;
                }
                catch(IllegalAccessException x)
                {
                    throw (InternalError)new InternalError().initCause(x);
                }
            }
        }
    }
d195 1
a195 35
    public boolean compareAndSwapInt(Object obj, long offset, int expect, int update)
    {
        if (obj instanceof cli.System.Array)
        {
            synchronized(this)
            {
                if(ReadInt32(obj, offset) == expect)
                {
                    WriteInt32(obj, offset, update);
                    return true;
                }
                return false;
            }
        }
        else
        {
            Field field = getField(offset);
            synchronized(field)
            {
                try
                {
                    if(field.getInt(obj) == expect)
                    {
                        field.setInt(obj, update);
                        return true;
                    }
                    return false;
                }
                catch(IllegalAccessException x)
                {
                    throw (InternalError)new InternalError().initCause(x);
                }
            }
        }
    }
d254 1
a254 35
    public boolean compareAndSwapLong(Object obj, long offset, long expect, long update)
    {
        if (obj instanceof cli.System.Array)
        {
            synchronized(this)
            {
                if(ReadInt64(obj, offset) == expect)
                {
                    WriteInt64(obj, offset, update);
                    return true;
                }
                return false;
            }
        }
        else
        {
            Field field = getField(offset);
            synchronized(field)
            {
                try
                {
                    if(field.getLong(obj) == expect)
                    {
                        field.setLong(obj, update);
                        return true;
                    }
                    return false;
                }
                catch(IllegalAccessException x)
                {
                    throw (InternalError)new InternalError().initCause(x);
                }
            }
        }
    }
@


1.30
log
@Bug fix. The MethodHandle code requires the volatile field accessors in Unsafe for volatile field access.
@
text
@d27 1
d101 16
d224 7
d233 1
a233 1
        if(obj instanceof int[])
a234 2
            int[] arr = (int[])obj;
            int index = (int)offset;
d237 1
a237 1
                if(arr[index] == expect)
d239 1
a239 1
                    arr[index] = update;
d269 1
a269 1
        if(obj instanceof int[])
d273 1
a273 1
                ((int[])obj)[(int)offset] = newValue;
d300 1
a300 1
        if(obj instanceof int[])
d304 1
a304 1
                return ((int[])obj)[(int)offset];
d326 1
a326 1
        if(obj instanceof long[])
a327 2
            long[] arr = (long[])obj;
            int index = (int)offset;
d330 1
a330 1
                if(arr[index] == expect)
d332 1
a332 1
                    arr[index] = update;
d362 1
a362 1
        if(obj instanceof long[])
d366 1
a366 1
                ((long[])obj)[(int)offset] = newValue;
d393 1
a393 1
        if(obj instanceof long[])
d397 1
a397 1
                return ((long[])obj)[(int)offset];
d419 1
a419 1
        if (obj instanceof boolean[])
d421 1
a421 1
            ((boolean[])obj)[(int)offset] = newValue;
d443 1
a443 1
        if (obj instanceof boolean[])
d445 1
a445 1
            return ((boolean[])obj)[(int)offset];
d467 1
a467 1
        if (obj instanceof byte[])
d469 1
a469 1
            ((byte[])obj)[(int)offset] = newValue;
d491 1
a491 1
        if (obj instanceof byte[])
d493 1
a493 1
            return ((byte[])obj)[(int)offset];
d515 1
a515 1
        if (obj instanceof char[])
d517 1
a517 1
            ((char[])obj)[(int)offset] = newValue;
d539 1
a539 1
        if (obj instanceof char[])
d541 1
a541 1
            return ((char[])obj)[(int)offset];
d563 1
a563 1
        if (obj instanceof short[])
d565 1
a565 1
            ((short[])obj)[(int)offset] = newValue;
d587 1
a587 1
        if (obj instanceof short[])
d589 1
a589 1
            return ((short[])obj)[(int)offset];
d611 1
a611 1
        if (obj instanceof int[])
d613 1
a613 1
            ((int[])obj)[(int)offset] = newValue;
d630 1
a630 1
        if (obj instanceof int[])
d632 1
a632 1
            return ((int[])obj)[(int)offset];
d649 1
a649 1
        if (obj instanceof float[])
d651 1
a651 1
            ((float[])obj)[(int)offset] = newValue;
d673 1
a673 1
        if (obj instanceof float[])
d675 1
a675 1
            return ((float[])obj)[(int)offset];
d697 1
a697 1
        if (obj instanceof long[])
d699 1
a699 1
            ((long[])obj)[(int)offset] = newValue;
d716 1
a716 1
        if (obj instanceof long[])
d718 1
a718 1
            return ((long[])obj)[(int)offset];
d735 1
a735 1
        if (obj instanceof double[])
d737 1
a737 1
            ((double[])obj)[(int)offset] = newValue;
d762 1
a762 1
        if (obj instanceof double[])
d764 1
a764 1
            return ((double[])obj)[(int)offset];
@


1.29
log
@First part of OpenJDK 8 integration.
@
text
@d416 5
d440 5
d464 5
d488 5
d512 5
d536 5
d560 5
d584 5
d646 5
d670 5
d732 8
d759 8
@


1.28
log
@Bug fix. Unsafe.park(false, 0) means infinite wait timeout, contrary to LockSupport.parkNanos(0).
@
text
@d52 1
a52 1
        if(ikvm.internal.CallerID.getCallerID().getCallerClassLoader() != null)
d1172 75
@


1.27
log
@Integrated OpenJDK 7u40 JSR-292 implementation (aka LambdaForms).
@
text
@d1130 4
@


1.26
log
@Added Unsafe.shouldBeInitialized() and Unsafe.defineClass() overload.
@
text
@d62 1
a62 1
        return fieldOffset(ReflectHelper.createFieldAndMakeAccessible(c, field));
d72 1
a72 1
        return fieldOffset(field);
d78 5
@


1.25
log
@Added Unsafe.defineAnonymousClass().
@
text
@d1139 2
d1143 4
@


1.24
log
@Switched from @@HasCallerID to @@CallerSensitive and merged CallerSenstive related 7u40 changes.
@
text
@d2 1
a2 1
  Copyright (C) 2006-2012 Jeroen Frijters
d1141 2
@


1.23
log
@Added intrinsics for (some usages of) Unsafe methods: putObject, putOrderedObject, putObjectVolatile, getObjectVolatile, getObject, compareAndSwapObject.
@
text
@d49 1
a49 1
    @@ikvm.internal.HasCallerID
@


1.22
log
@Added some Unsafe methods used by Akka. Thanks to http://tountas-software.blogspot.com/2012/03/c-actors-with-akka-20-via-ikvm-net.html
@
text
@d89 1
d95 1
@


1.21
log
@Intrinsified the unsafe.objectFieldOffset(XXX.class.getDeclaredField("xxx")) pattern to avoid expensive reflection field lookup in static initializers of common OpenJDK classes.
@
text
@d1115 12
d1138 15
@


1.20
log
@Completed implementation of new Unsafe.copyMemory() overload. This fixes several direct ByteBuffer regressions (introduced when we started using OpenJDK 7).
@
text
@d2 1
a2 1
  Copyright (C) 2006-2011 Jeroen Frijters
d59 6
@


1.19
log
@Implemented Unsafe.defineClass().
@
text
@d906 34
d942 1
a942 1
                throw new ikvm.internal.NotYetImplementedError("destBase = " + destBase);
d945 4
d955 30
d987 1
a987 1
                throw new ikvm.internal.NotYetImplementedError("srcBase = " + srcBase);
@


1.18
log
@Merge in java.lang.invoke package and the beginnings of MethodHandle support.
@
text
@d1051 1
a1051 4
    public Class defineClass(String name, byte[] buf, int offset, int length, ClassLoader cl, ProtectionDomain pd)
    {
        throw new ikvm.internal.NotYetImplementedError();
    }
@


1.17
log
@Updated bulk of java.nio to OpenJDK 7.
@
text
@d35 1
d1045 10
@


1.16
log
@Updated java.util.concurrent.* packages to OpenJDK 7.
@
text
@d895 2
d899 22
a920 1
        throw new ikvm.internal.NotYetImplementedError();
@


1.15
log
@Updated java.io package to OpenJDK 7.
@
text
@d1016 5
@


1.14
log
@Implemented OperatingSystemMXBean.
@
text
@d2 1
a2 1
  Copyright (C) 2006, 2007, 2009 Jeroen Frijters
d40 1
d894 5
@


1.13
log
@Prep for .NET 4.0 security model:
- added more SecurityCritical attributes
- added SecuritySafeCritical/TreatAsSafe attributes to Direct-X-Buffer classes
@
text
@d1005 5
@


1.12
log
@Use CallerID.getCallerClassLoader() to bypass Class.getClassLoader().
@
text
@d837 1
d853 1
d868 1
d875 1
d885 1
d895 1
d902 1
d909 1
d916 1
d923 1
d930 1
d937 1
d944 1
d951 1
d958 1
d965 1
d972 1
d979 1
d986 1
d993 1
d1000 1
@


1.11
log
@- Moved unsafe operations into Java and added link demand for unmanaged code to them.
- Added some deprecated unsafe methods that are apparantly still being used (or at least referenced) by JRuby.
@
text
@d50 1
a50 2
        Class c = sun.reflect.Reflection.getCallerClass(2);
        if(c.getClassLoader() != null)
@


1.10
log
@Converted tabs to spaces.
@
text
@d2 1
a2 1
  Copyright (C) 2006, 2007 Jeroen Frijters
d29 2
d68 1
d725 108
d837 1
d850 1
a850 2
    // The really unsafe methods start here. They are all @@Internal to prevent
    // external code from accessing them.
d852 1
a852 1
    @@Internal
d866 1
a866 1
    @@Internal
d872 8
a879 2
    @@Internal
    public static native void setMemory(long address, long bytes, byte value);
d881 8
a888 2
    @@Internal
    public static native void copyMemory(long srcAddress, long destAddress, long bytes);
d890 5
a894 2
    @@Internal
    public static native byte getByte(long address);
d896 5
a900 2
    @@Internal
    public static native void putByte(long address, byte x);
d902 5
a906 2
    @@Internal
    public static native short getShort(long address);
d908 5
a912 2
    @@Internal
    public static native void putShort(long address, short x);
d914 5
a918 2
    @@Internal
    public static native char getChar(long address);
d920 5
a924 2
    @@Internal
    public static native void putChar(long address, char x);
d926 5
a930 2
    @@Internal
    public static native int getInt(long address);
d932 5
a936 2
    @@Internal
    public static native void putInt(long address, int x);
d938 11
a948 2
    @@Internal
    public static native long getLong(long address);
d950 11
a960 2
    @@Internal
    public static native void putLong(long address, long x);
d962 1
a962 1
    @@Internal
d968 1
a968 1
    @@Internal
d974 1
a974 1
    @@Internal
d980 1
a980 1
    @@Internal
@


1.9
log
@- Implemented CallerID infrastructure.
- Marked various methods with HasCallerID annotation.
- Rewrote some methods to explicitly use CallerID.
@
text
@d48 1
a48 1
	Class c = sun.reflect.Reflection.getCallerClass(2);
d53 1
a53 1
	return theUnsafe;
d59 5
a63 5
	if(Modifier.isStatic(field.getModifiers()))
	{
	    throw new IllegalArgumentException();
	}
	return fieldOffset(field);
d68 7
a74 7
	Field copy = ReflectHelper.copyFieldAndMakeAccessible(original);
	synchronized(fields)
	{
	    int id = fields.size();
	    fields.add(copy);
	    return id;
	}
d116 13
a128 13
		try
		{
		    if(field.get(obj) == expect)
		    {
			field.set(obj, update);
			return true;
		    }
		    return false;
		}
		catch(IllegalAccessException x)
		{
		    throw (InternalError)new InternalError().initCause(x);
		}
d147 2
a148 2
		try
		{
d150 5
a154 5
		}
		catch(IllegalAccessException x)
		{
		    throw (InternalError)new InternalError().initCause(x);
		}
d178 8
a185 8
		try
		{
		    return field.get(obj);
		}
		catch(IllegalAccessException x)
		{
		    throw (InternalError)new InternalError().initCause(x);
		}
d211 13
a223 13
		try
		{
		    if(field.getInt(obj) == expect)
		    {
			field.setInt(obj, update);
			return true;
		    }
		    return false;
		}
		catch(IllegalAccessException x)
		{
		    throw (InternalError)new InternalError().initCause(x);
		}
d242 2
a243 2
		try
		{
d245 5
a249 5
		}
		catch(IllegalAccessException x)
		{
		    throw (InternalError)new InternalError().initCause(x);
		}
d273 2
a274 2
		try
		{
d276 5
a280 5
		}
		catch(IllegalAccessException x)
		{
		    throw (InternalError)new InternalError().initCause(x);
		}
d306 13
a318 13
		try
		{
		    if(field.getLong(obj) == expect)
		    {
			field.setLong(obj, update);
			return true;
		    }
		    return false;
		}
		catch(IllegalAccessException x)
		{
		    throw (InternalError)new InternalError().initCause(x);
		}
d337 2
a338 2
		try
		{
d340 5
a344 5
		}
		catch(IllegalAccessException x)
		{
		    throw (InternalError)new InternalError().initCause(x);
		}
d368 2
a369 2
		try
		{
d371 5
a375 5
		}
		catch(IllegalAccessException x)
		{
		    throw (InternalError)new InternalError().initCause(x);
		}
d382 15
a396 15
	if (obj instanceof boolean[])
	{
	    ((boolean[])obj)[(int)offset] = newValue;
	}
	else
	{
	    try
	    {
		getField(offset).setBoolean(obj, newValue);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d401 15
a415 15
	if (obj instanceof boolean[])
	{
	    return ((boolean[])obj)[(int)offset];
	}
	else
	{
	    try
	    {
		return getField(offset).getBoolean(obj);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d420 15
a434 15
	if (obj instanceof byte[])
	{
	    ((byte[])obj)[(int)offset] = newValue;
	}
	else
	{
	    try
	    {
		getField(offset).setByte(obj, newValue);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d439 15
a453 15
	if (obj instanceof byte[])
	{
	    return ((byte[])obj)[(int)offset];
	}
	else
	{
	    try
	    {
		return getField(offset).getByte(obj);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d458 15
a472 15
	if (obj instanceof char[])
	{
	    ((char[])obj)[(int)offset] = newValue;
	}
	else
	{
	    try
	    {
		getField(offset).setChar(obj, newValue);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d477 15
a491 15
	if (obj instanceof char[])
	{
	    return ((char[])obj)[(int)offset];
	}
	else
	{
	    try
	    {
		return getField(offset).getChar(obj);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d496 15
a510 15
	if (obj instanceof short[])
	{
	    ((short[])obj)[(int)offset] = newValue;
	}
	else
	{
	    try
	    {
		getField(offset).setShort(obj, newValue);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d515 15
a529 15
	if (obj instanceof short[])
	{
	    return ((short[])obj)[(int)offset];
	}
	else
	{
	    try
	    {
		return getField(offset).getShort(obj);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d534 15
a548 15
	if (obj instanceof int[])
	{
	    ((int[])obj)[(int)offset] = newValue;
	}
	else
	{
	    try
	    {
		getField(offset).setInt(obj, newValue);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d553 15
a567 15
	if (obj instanceof int[])
	{
	    return ((int[])obj)[(int)offset];
	}
	else
	{
	    try
	    {
		return getField(offset).getInt(obj);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d572 15
a586 15
	if (obj instanceof float[])
	{
	    ((float[])obj)[(int)offset] = newValue;
	}
	else
	{
	    try
	    {
		getField(offset).setFloat(obj, newValue);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d591 15
a605 15
	if (obj instanceof float[])
	{
	    return ((float[])obj)[(int)offset];
	}
	else
	{
	    try
	    {
		return getField(offset).getFloat(obj);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d610 15
a624 15
	if (obj instanceof long[])
	{
	    ((long[])obj)[(int)offset] = newValue;
	}
	else
	{
	    try
	    {
		getField(offset).setLong(obj, newValue);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d629 15
a643 15
	if (obj instanceof long[])
	{
	    return ((long[])obj)[(int)offset];
	}
	else
	{
	    try
	    {
		return getField(offset).getLong(obj);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d648 15
a662 15
	if (obj instanceof double[])
	{
	    ((double[])obj)[(int)offset] = newValue;
	}
	else
	{
	    try
	    {
		getField(offset).setDouble(obj, newValue);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d667 15
a681 15
	if (obj instanceof double[])
	{
	    return ((double[])obj)[(int)offset];
	}
	else
	{
	    try
	    {
		return getField(offset).getDouble(obj);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d686 15
a700 15
	if (obj instanceof Object[])
	{
	    ((Object[])obj)[(int)offset] = newValue;
	}
	else
	{
	    try
	    {
		getField(offset).set(obj, newValue);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d705 15
a719 15
	if (obj instanceof Object[])
	{
	    return ((Object[])obj)[(int)offset];
	}
	else
	{
	    try
	    {
		return getField(offset).get(obj);
	    }
	    catch (IllegalAccessException x)
	    {
		throw (InternalError)new InternalError().initCause(x);
	    }
	}
d730 1
a730 1
	return IntPtr.get_Size();
d735 1
a735 1
	return 4096;
d744 9
a752 9
	try
	{
	    if (false) throw new cli.System.OutOfMemoryException();
	    return Marshal.AllocHGlobal(IntPtr.op_Explicit(bytes)).ToInt64();
	}
	catch (cli.System.OutOfMemoryException x)
	{
	    throw new OutOfMemoryError(x.get_Message());
	}
d758 1
a758 1
	Marshal.FreeHGlobal(IntPtr.op_Explicit(address));
d800 1
a800 1
	return Float.intBitsToFloat(getInt(address));
d806 1
a806 1
	putInt(address, Float.floatToIntBits(x));
d812 1
a812 1
	return Double.longBitsToDouble(getLong(address));
d818 1
a818 1
	putLong(address, Double.doubleToLongBits(x));
@


1.8
log
@Removed initialization hack that is no longer needed.
@
text
@d45 1
@


1.7
log
@Added check to prevent objectFieldOffset from working on static fields.
@
text
@a51 5
	if(c == SharedSecrets.class)
	{
	    // HACK make sure that bootstrap has occurred before SharedSecrets.getJavaLangAccess() is called.
	    theUnsafe.ensureClassInitialized(System.class);
	}
@


1.6
log
@Integrated OpenJDK java.nio package.
@
text
@d31 1
d63 4
@


1.5
log
@- Removed VMStackWalker dependency
- Added bootstrap work around
- Renamed instance field to theUnsafe, to facilitate sun.corba.Bridge which accesses the field thru reflection.
@
text
@d27 3
d726 93
@


1.4
log
@- Imported a modified version of AbstractQueuedSynchronizer that is more efficient and doesn't use reflection & unsafe to reduce initialization order dependencies.
- Changed unsafe to use more efficient internal helper class to copy Field and make it accessible (this also reduces initialization order dependencies).
@
text
@a26 1
import gnu.classpath.VMStackWalker;
d34 3
a36 1
    private static final Unsafe instance = new Unsafe();
d39 1
a39 1
    private Unsafe() {}
d43 2
a44 1
        if(VMStackWalker.getCallingClassLoader() != null)
d46 1
a46 1
            throw new SecurityException();
d48 6
a53 1
        return instance;
@


1.3
log
@Removed AccessController.doPrivileged() call in fieldOffset, to work around Mauve brokenness (and other potential broken SecurityManagers).
@
text
@a26 2
import cli.System.Reflection.BindingFlags;
import cli.System.Reflection.FieldInfo;
a27 3
import ikvm.lang.CIL;
import ikvm.runtime.Util;
import java.lang.reflect.AccessibleObject;
d29 1
a30 3
import java.security.AccessController;
import java.security.PrivilegedAction;
import sun.reflect.ReflectionFactory;
a36 2
    private static final ReflectionFactory factory = (ReflectionFactory)AccessController.doPrivileged(new ReflectionFactory.GetReflectionFactoryAction());
    private static final FieldInfo accessibleField = Util.getInstanceTypeFromClass(AccessibleObject.class).GetField("override", BindingFlags.wrap(BindingFlags.Instance | BindingFlags.NonPublic));
d57 1
a57 4
	Field copy = factory.copyField(original);
	// we use .NET reflection to directly set the override field (equivalent to calling setAccessible(true)),
	// because a broken Mauve security manager prevents us from using AccessController.doPrivileged().
	accessibleField.SetValue(copy, CIL.box_boolean(true));
@


1.2
log
@Integrated OpenJDK's java.io package (except java.io.FilePermission class).
@
text
@d27 2
d30 3
d45 1
d66 4
a69 7
	final Field copy = factory.copyField(original);
	AccessController.doPrivileged(new PrivilegedAction() {
	    public Object run() {
		copy.setAccessible(true);
		return null;
	    }
	});
@


1.1
log
@Integrated OpenJDK's java.lang.reflect.* classes (except for Array).
@
text
@d36 1
d378 228
d608 15
a622 1
        putLongVolatile(obj, offset, newValue);
d627 91
a717 1
        return getLongVolatile(obj, offset);
@

