head	1.56;
access;
symbols
	v0_40_0_6:1.55
	v0_40_0_5:1.55
	v0_36_0_14:1.55
	v0_40_0_3:1.55
	v0_40_0_2:1.55
	v0_40_0_1:1.55
	v0_40_0_0:1.55
	v0_40:1.55.0.6
	v0_36_0_13:1.55
	v0_38_0_1:1.55
	v0_38_0_0:1.55
	v0_38:1.55.0.4
	v0_36_0_9:1.55
	v0_36_0_7:1.55
	v0_36_0_5:1.55
	v0_36_0_4:1.55
	v0_36_0_3:1.55
	v0_36_0_2:1.55
	v0_36_0_1:1.55
	v0_36_0_0:1.55
	v0_36:1.55.0.2
	v0_34_0_3:1.53
	v0_34_0_2:1.53
	v0_34_0_1:1.53
	v0_34_0_0:1.53
	v0_34:1.53.0.2
	v0_32:1.41.0.2
	v0_32_0_0:1.41
	v0_30:1.34.0.2
	v0_28_0_0:1.26
	v0_26_0_1:1.25
	v0_26_0_0:1.25
	v0_24_0_1:1.25
	v0_24_0_0:1.24
	v0_22_0_0:1.24
	v0_20_0_0:1.24
	v0_18_0_0:1.22
	v0_16_0_0:1.21
	v0_14_0_1:1.19
	v0_14_0_0:1.19
	v0_12_0_0:1.18
	v0_10_0_1:1.17
	v0_10_0_0:1.17
	v0_8_0_0:1.10
	initial:1.1.1.1
	ikvm:1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2009.04.15.04.22.00;	author jfrijters;	state dead;
branches;
next	1.55;

1.55
date	2007.07.04.09.16.40;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2007.07.03.06.34.54;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2007.03.15.07.59.33;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2007.03.13.08.10.13;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.09.07.11.52;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.28.09.57.28;	author smallsql;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.27.15.40.42;	author smallsql;	state Exp;
branches;
next	1.48;

1.48
date	2007.01.21.20.29.52;	author smallsql;	state Exp;
branches;
next	1.47;

1.47
date	2007.01.21.14.18.03;	author smallsql;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.14.16.13.51;	author smallsql;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.07.13.59.43;	author smallsql;	state Exp;
branches;
next	1.44;

1.44
date	2007.01.04.20.43.41;	author smallsql;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.30.15.10.54;	author smallsql;	state Exp;
branches;
next	1.42;

1.42
date	2006.12.21.08.38.07;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2006.12.11.07.07.12;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.07.09.14.08;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.01.10.15.47;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2006.09.22.05.52.10;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2006.09.20.05.20.26;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2006.08.29.08.08.37;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.17.16.57.40;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2006.08.03.12.41.27;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.03.08.08.51;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.31.13.30.32;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.31.13.11.44;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.31.12.46.44;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.18.07.38.24;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.04.10.13.32;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.09.13.17.54;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.10.09.18.37;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.23.10.18.44;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.19.10.11.36;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.16.12.46.20;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.14.08.38.36;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.26.06.53.50;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.25.13.44.08;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.15.11.45.49;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.02.15.11.27;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.05.12.11.50;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.03.08.26.21;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.02.16.06.37;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.02.13.19.04;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.04.12.50.28;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.19.13.43.55;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.27.10.17.34;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.26.10.19.22;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.16.17.10.10;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.11.13.14.43;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.12.13.09.31;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.10.09.31.06;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.24.21.02.18;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.23.12.50.11;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.21.12.12.40;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.17.14.04.27;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.18.16.00.27;	author jfrijters;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.12.18.16.00.27;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Remove unused files.
@
text
@/*
  Copyright (C) 2002, 2004, 2005, 2006, 2007 Jeroen Frijters
  Copyright (C) 2006 Active Endpoints, Inc.
  Copyright (C) 2006, 2007 Volker Berlin

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net 

*/

using System;
using System.Drawing;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Windows.Forms;
using System.ComponentModel;
using System.Reflection;
using java.awt.datatransfer;
using java.awt.image;
using java.awt.peer;
using java.net;
using java.util;

namespace ikvm.awt
{
	delegate void SetVoid();
	delegate void SetBool(bool b);
	delegate void SetInt(int i);
	delegate void SetXYWH(int x, int y, int w, int h);
	delegate void SetString(string s);
	delegate string GetString();
	delegate void SetStringInt(string s, int i);
	delegate void SetRectangle(Rectangle r);
	delegate void SetColor(java.awt.Color c);
	delegate void SetFont(java.awt.Font f);
    delegate void SetCursor(java.awt.Cursor cursor);
	delegate java.awt.Dimension GetDimension();
    delegate Rectangle ConvertRectangle(Rectangle r);
    delegate Point ConvertPoint(Point p);
	delegate object GetObject();

	class UndecoratedForm : Form
	{
		public UndecoratedForm()
		{
			this.FormBorderStyle = FormBorderStyle.None;
			SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw, true);
		}
	}

	class MyForm : Form
	{
		public MyForm()
		{
			SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw, true);
		}
	}

	class MyControl : Control
	{
		public MyControl()
		{
			SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw, true);
		}
	}

	class MyContainerControl : ContainerControl
	{
		public MyContainerControl()
		{
			SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw, true);
		}
	}

    public class NetToolkit : gnu.java.awt.ClasspathToolkit
	{
        internal static java.awt.EventQueue eventQueue = new java.awt.EventQueue();
		internal static volatile Form bogusForm;
		private static Delegate createControlInstance;
		private int resolution;

        private delegate NetComponentPeer CreateControlInstanceDelegate(Type controlType, java.awt.Component target, Type peerType);

		private static void MessageLoop()
		{
			createControlInstance = new CreateControlInstanceDelegate(CreateControlImpl);
			using(Form form = new Form())
			{
				form.CreateControl();
				// HACK I have no idea why this line is necessary...
				IntPtr p = form.Handle;
				if(p == IntPtr.Zero)
				{
					// shut up compiler warning
				}
				bogusForm = form;
				// FXBUG to make sure we can be aborted (Thread.Abort) we need to periodically
				// fire an event (because otherwise we'll be blocking in unmanaged code and
				// the Abort cannot be handled there).
				System.Windows.Forms.Timer t = new System.Windows.Forms.Timer();
				t.Interval = 100;
				t.Start();
				Application.Run();
			}
		}

        internal static NetComponentPeer CreateControlImpl(Type controlType, java.awt.Component target, Type peerType)
		{
            Control control = (Control)Activator.CreateInstance(controlType);
            control.CreateControl();
            // HACK here we go again...
			IntPtr p = control.Handle;
			if(p == IntPtr.Zero)
			{
				// shut up compiler warning
			}
            NetComponentPeer peer = (NetComponentPeer)Activator.CreateInstance(peerType, new object[] { target, control });
            peer.initEvents();
            return peer;
        }

        internal static NetComponentPeer CreatePeer(Type controlType, java.awt.Component target, Type peerType)
		{
            java.awt.Container parent = target.getParent();
            if (parent != null && parent.getPeer() == null)
            {
                //This should do in Java, but it is a Bug in GNU classpath
                //because synchronized in Java this must be call with the caller thread
                parent.addNotify();
            }
            NetComponentPeer peer = (NetComponentPeer)bogusForm.Invoke(createControlInstance, new object[] { controlType, target, peerType });
            peer.init();
            return peer;
		}

		public NetToolkit()
		{
			lock(typeof(NetToolkit))
			{
				System.Diagnostics.Debug.Assert(bogusForm == null);

				Thread thread = new Thread(new ThreadStart(MessageLoop));
				thread.ApartmentState = ApartmentState.STA;
				thread.Name = "IKVM AWT WinForms Message Loop";
				thread.IsBackground = true;
				thread.Start();
				// TODO don't use polling...
				while(bogusForm == null && thread.IsAlive)
				{
					Thread.Sleep(1);
				}
			}
		}

		protected override void loadSystemColors(int[] systemColors)
		{
			// initialize all colors to purple to make the ones we might have missed stand out
			for(int i = 0; i < systemColors.Length; i++)
			{
				systemColors[i] = Color.Purple.ToArgb();
			}
			systemColors[java.awt.SystemColor.DESKTOP] = SystemColors.Desktop.ToArgb();
			systemColors[java.awt.SystemColor.ACTIVE_CAPTION] = SystemColors.ActiveCaption.ToArgb();
			systemColors[java.awt.SystemColor.ACTIVE_CAPTION_TEXT] = SystemColors.ActiveCaptionText.ToArgb();
			systemColors[java.awt.SystemColor.ACTIVE_CAPTION_BORDER] = SystemColors.ActiveBorder.ToArgb();
			systemColors[java.awt.SystemColor.INACTIVE_CAPTION] = SystemColors.InactiveCaption.ToArgb();
			systemColors[java.awt.SystemColor.INACTIVE_CAPTION_TEXT] = SystemColors.InactiveCaptionText.ToArgb();
			systemColors[java.awt.SystemColor.INACTIVE_CAPTION_BORDER] = SystemColors.InactiveBorder.ToArgb();
			systemColors[java.awt.SystemColor.WINDOW] = SystemColors.Window.ToArgb();
			systemColors[java.awt.SystemColor.WINDOW_BORDER] = SystemColors.WindowFrame.ToArgb();
			systemColors[java.awt.SystemColor.WINDOW_TEXT] = SystemColors.WindowText.ToArgb();
			systemColors[java.awt.SystemColor.MENU] = SystemColors.Menu.ToArgb();
			systemColors[java.awt.SystemColor.MENU_TEXT] = SystemColors.MenuText.ToArgb();
			systemColors[java.awt.SystemColor.TEXT] = SystemColors.Window.ToArgb();
			systemColors[java.awt.SystemColor.TEXT_TEXT] = SystemColors.WindowText.ToArgb();
			systemColors[java.awt.SystemColor.TEXT_HIGHLIGHT] = SystemColors.Highlight.ToArgb();
			systemColors[java.awt.SystemColor.TEXT_HIGHLIGHT_TEXT] = SystemColors.HighlightText.ToArgb();
			systemColors[java.awt.SystemColor.TEXT_INACTIVE_TEXT] = SystemColors.GrayText.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL] = SystemColors.Control.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_TEXT] = SystemColors.ControlText.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_HIGHLIGHT] = SystemColors.ControlLight.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_LT_HIGHLIGHT] = SystemColors.ControlLightLight.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_SHADOW] = SystemColors.ControlDark.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_DK_SHADOW] = SystemColors.ControlDarkDark.ToArgb();
			systemColors[java.awt.SystemColor.SCROLLBAR] = SystemColors.ScrollBar.ToArgb();
			systemColors[java.awt.SystemColor.INFO] = SystemColors.Info.ToArgb();
			systemColors[java.awt.SystemColor.INFO_TEXT] = SystemColors.InfoText.ToArgb();
		}

		protected override java.awt.peer.ButtonPeer createButton(java.awt.Button target)
		{
            return (NetButtonPeer)CreatePeer(typeof(Button), target, typeof(NetButtonPeer));
		}

		protected override java.awt.peer.TextFieldPeer createTextField(java.awt.TextField target)
		{
            return (NetTextFieldPeer)CreatePeer(typeof(TextBox), target, typeof(NetTextFieldPeer));
        }

		protected override java.awt.peer.LabelPeer createLabel(java.awt.Label target)
		{
            return (NetLabelPeer)CreatePeer(typeof(Label), target, typeof(NetLabelPeer));
		}

		protected override java.awt.peer.ListPeer createList(java.awt.List target)
		{
            return (NetListPeer)CreatePeer(typeof(ListBox), target, typeof(NetListPeer));
		}

		protected override java.awt.peer.CheckboxPeer createCheckbox(java.awt.Checkbox target)
		{
            return (NetCheckboxPeer)CreatePeer(typeof(CheckBox), target, typeof(NetCheckboxPeer));
		}

		protected override java.awt.peer.ScrollbarPeer createScrollbar(java.awt.Scrollbar target)
		{
			throw new NotImplementedException();
		}

		protected override java.awt.peer.ScrollPanePeer createScrollPane(java.awt.ScrollPane target)
		{
			throw new NotImplementedException();
		}

		protected override java.awt.peer.TextAreaPeer createTextArea(java.awt.TextArea target)
		{
            return (NetTextAreaPeer)CreatePeer(typeof(TextBox), target, typeof(NetTextAreaPeer));
		}

		protected override java.awt.peer.ChoicePeer createChoice(java.awt.Choice target)
		{
            return (NetChoicePeer)CreatePeer(typeof(ComboBox), target, typeof(NetChoicePeer));
		}

		protected override java.awt.peer.FramePeer createFrame(java.awt.Frame target)
		{
            if (!target.isFontSet())
            {
                java.awt.Font font = new java.awt.Font("Dialog", java.awt.Font.PLAIN, 12);
                target.setFont(font);
            }
            return (NetFramePeer)CreatePeer(typeof(MyForm), target, typeof(NetFramePeer));
		}

		protected override java.awt.peer.CanvasPeer createCanvas(java.awt.Canvas target)
		{
            return (NewCanvasPeer)CreatePeer(typeof(MyControl), target, typeof(NewCanvasPeer));
		}

		protected override java.awt.peer.PanelPeer createPanel(java.awt.Panel target)
		{
            return (NetPanelPeer)CreatePeer(typeof(ContainerControl), target, typeof(NetPanelPeer));
		}

		protected override java.awt.peer.WindowPeer createWindow(java.awt.Window target)
		{
            return (NetWindowPeer)CreatePeer(typeof(UndecoratedForm), target, typeof(NetWindowPeer));
		}

		protected override java.awt.peer.DialogPeer createDialog(java.awt.Dialog target)
		{
            return (NetDialogPeer)CreatePeer(typeof(MyForm), target, typeof(NetDialogPeer));
		}

		protected override java.awt.peer.MenuBarPeer createMenuBar(java.awt.MenuBar target)
		{
			throw new NotImplementedException();
		}

		protected override java.awt.peer.MenuPeer createMenu(java.awt.Menu target)
		{
			throw new NotImplementedException();
		}

		protected override java.awt.peer.PopupMenuPeer createPopupMenu(java.awt.PopupMenu target)
		{
			throw new NotImplementedException();
		}

		protected override java.awt.peer.MenuItemPeer createMenuItem(java.awt.MenuItem target)
		{
			throw new NotImplementedException();
		}

		protected override java.awt.peer.FileDialogPeer createFileDialog(java.awt.FileDialog target)
		{
			throw new NotImplementedException();
		}

		protected override java.awt.peer.CheckboxMenuItemPeer createCheckboxMenuItem(java.awt.CheckboxMenuItem target)
		{
			throw new NotImplementedException();
		}

		[Obsolete]
		protected override java.awt.peer.FontPeer getFontPeer(string name, int style)
		{
			throw new NotImplementedException();
		}

		public override java.awt.Dimension getScreenSize()
		{
			return new java.awt.Dimension(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height);
		}

		public override int getScreenResolution()
		{
			if(resolution == 0)
			{
				using(Graphics g = bogusForm.CreateGraphics())
				{
					resolution = (int)Math.Round(g.DpiY);
				}
			}
			return resolution;
		}

		public override ColorModel getColorModel()
		{
			throw new NotImplementedException();
		}

		[Obsolete]
		public override string[] getFontList()
		{
			// This method is deprecated and Sun's JDK only returns these fonts as well
			return new string[] { "Dialog", "SansSerif", "Serif", "Monospaced", "DialogInput" };
		}

		[Obsolete]
		public override java.awt.FontMetrics getFontMetrics(java.awt.Font font)
		{
			return new NetFontMetrics(font);
		}

		public override void sync()
		{
			throw new NotImplementedException();
		}

		public override java.awt.Image getImage(string filename)
		{
			try
			{
				using(System.IO.FileStream stream = new System.IO.FileStream(filename, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.ReadWrite))
				{
					return new NetBufferedImage(new Bitmap(Image.FromStream(stream)));
				}
			}
			catch(Exception ex)
			{
                return new NoImage();
			}
		}

		public override java.awt.Image getImage(URL url)
		{
			// TODO extremely lame...
			System.IO.MemoryStream mem = new System.IO.MemoryStream();
			java.io.InputStream inS = url.openStream();
			int b;
			while((b = inS.read()) >= 0)
			{
				mem.WriteByte((byte)b);
			}
			try
			{
				mem.Position = 0;
				return new NetBufferedImage(new Bitmap(Image.FromStream(mem)));
			}
			catch
			{
				return new NoImage();
			}
		}

		public override java.awt.Image createImage(string filename)
		{
			return getImage(filename);
		}

		public override java.awt.Image createImage(URL url)
		{
			return getImage(url);
		}

		const int ERROR = java.awt.image.ImageObserver.__Fields.ERROR;
		const int ABORT = java.awt.image.ImageObserver.__Fields.ABORT;
		const int WIDTH = java.awt.image.ImageObserver.__Fields.WIDTH;
		const int HEIGHT = java.awt.image.ImageObserver.__Fields.HEIGHT;
		const int FRAMEBITS = java.awt.image.ImageObserver.__Fields.FRAMEBITS;
		const int ALLBITS = java.awt.image.ImageObserver.__Fields.ALLBITS;

		public override bool prepareImage(java.awt.Image image, int width, int height, java.awt.image.ImageObserver observer)
		{
			// HACK for now we call checkImage to obtain the status and fire the observer
			return (checkImage(image, width, height, observer) & (ALLBITS | ERROR | ABORT)) != 0;
		}

		public override int checkImage(java.awt.Image image, int width, int height, java.awt.image.ImageObserver observer)
		{
			if(image.getWidth(null) == -1)
			{
				if(observer != null)
				{
					observer.imageUpdate(image, ERROR | ABORT, 0, 0, -1, -1);
				}
				return ERROR | ABORT;
			}
			if(observer != null)
			{
				observer.imageUpdate(image, WIDTH + HEIGHT + FRAMEBITS + ALLBITS, 0, 0, image.getWidth(null), image.getHeight(null));
			}
			return WIDTH + HEIGHT + FRAMEBITS + ALLBITS;
		}

		public override java.awt.Image createImage(java.awt.image.ImageProducer producer)
		{
			NetProducerImage img = new NetProducerImage(producer);
			if(producer != null)
			{
				producer.startProduction(img);
			}
			return img;
		}

		public override java.awt.Image createImage(byte[] imagedata, int imageoffset, int imagelength)
		{
            try
            {
                return new NetBufferedImage(new Bitmap(new MemoryStream(imagedata, imageoffset, imagelength, false)));
            }
            catch (Exception ex)
            {
                return new NoImage();//TODO should throw the exception unstead of NoImage()
            }
		}

		public override java.awt.PrintJob getPrintJob(java.awt.Frame frame, string jobtitle, Properties props)
		{
			throw new NotImplementedException();
		}

		public override void beep()
        {
#if WHIDBEY && !COMPACT_FRAMEWORK
            Console.Beep();
#endif
		}

		public override java.awt.datatransfer.Clipboard getSystemClipboard()
		{
			throw new NotImplementedException();
		}

		protected override java.awt.EventQueue getSystemEventQueueImpl()
		{
			return eventQueue;
		}

		public override java.awt.dnd.peer.DragSourceContextPeer createDragSourceContextPeer(java.awt.dnd.DragGestureEvent dge)
		{
			throw new NotImplementedException();
		}

		public override Map mapInputMethodHighlight(java.awt.im.InputMethodHighlight highlight)
		{
			throw new NotImplementedException();
		}

#if false
		protected override java.awt.peer.LightweightPeer createComponent(java.awt.Component target)
		{
			if(target is java.awt.Container)
			{
				return new NetLightweightContainerPeer((java.awt.Container)target);
			}
			return new NetLightweightComponentPeer(target);
		}
#endif

		public override java.awt.Font createFont(int format, java.io.InputStream stream)
		{
			throw new NotImplementedException();
		}

		public override gnu.java.awt.peer.ClasspathFontPeer getClasspathFontPeer(string name, java.util.Map attrs)
		{
			return new NetFontPeer(name, attrs);
		}

		public override java.awt.GraphicsEnvironment getLocalGraphicsEnvironment()
		{
			return new NetGraphicsEnvironment();
		}

		public override RobotPeer createRobot(java.awt.GraphicsDevice screen)
		{
            String osname = gnu.classpath.SystemProperties.getProperty("os.name");
            if (osname.IndexOf("Windows") >= 0)
            {
                return new WindowsRobot(screen);
            }
            throw new java.awt.AWTException("Robot not supported for this OS");
		}

		public override gnu.java.awt.peer.EmbeddedWindowPeer createEmbeddedWindow(gnu.java.awt.EmbeddedWindow ew)
		{
			throw new NotImplementedException();
		}

		protected override DesktopPeer createDesktopPeer(java.awt.Desktop target)
		{
			return new NetDesktopPeer();
		}

		public override bool isModalExclusionTypeSupported(java.awt.Dialog.ModalExclusionType modalExclusionType)
		{
			// TODO
			return false;
		}

		public override bool isModalityTypeSupported(java.awt.Dialog.ModalityType modalityType)
		{
			// TODO
			return false;
		}
	}

	class NetLightweightComponentPeer : NetComponentPeer, java.awt.peer.LightweightPeer
	{
		public NetLightweightComponentPeer(java.awt.Component target)
			: base(target, ((NetComponentPeer)target.getParent().getPeer()).control)
		{
		}
	}

	class NetLightweightContainerPeer : NetContainerPeer, java.awt.peer.LightweightPeer
	{
		public NetLightweightContainerPeer(java.awt.Container target)
			: base(target, GetContainerControl(target.getParent()))
		{
		}

		private static ContainerControl GetContainerControl(java.awt.Container aContainer)
		{
			ContainerControl control = null;

			if (aContainer != null)
			{
				control = (ContainerControl) ((NetContainerPeer) aContainer.getPeer()).control;
			}

			return control;
		}
	}

	class NetComponentPeer : ComponentPeer
	{
		internal readonly java.awt.Component component;
		internal readonly Control control;
        private bool isMouseClick;

		public NetComponentPeer(java.awt.Component component, Control control)
		{
            this.control = control;
			this.component = component;
			control.TabStop = false;
			java.awt.Container parent = component.getParent();
			if(parent != null && !(this is java.awt.peer.LightweightPeer))
			{
				if(control is Form)
				{
                    NetComponentPeer parentPeer = (NetComponentPeer)parent.getPeer();
                    if (parentPeer != null)
					{
						((Form)control).Owner = (Form)parentPeer.control;
					}
				}
				else
				{
					java.awt.Container p = parent;
					while(p != null && p.getPeer() is java.awt.peer.LightweightPeer)
					{
						p = p.getParent();
					}
					if(p != null)
					{
						control.Parent = ((NetComponentPeer)p.getPeer()).control;
					}
				}
			}
            SetBoundsImpl(component.getX(), component.getY(), component.getWidth(), component.getHeight());
            // we need the null check, because for a Window, at this time it doesn't have a foreground yet
			if(component.getForeground() != null)
			{
                SetForeColorImpl(component.getForeground());
			}
			// we need the null check, because for a Window, at this time it doesn't have a background yet
			if(component.getBackground() != null)
			{
                SetBackColorImpl(component.getBackground());
			}
			setEnabled(component.isEnabled());
		}

        internal virtual void initEvents()
        {
            // TODO we really only should hook these events when they are needed...
            control.KeyDown += new KeyEventHandler(OnKeyDown);
            control.KeyUp += new KeyEventHandler(OnKeyUp);
            control.KeyPress += new KeyPressEventHandler(OnKeyPress);
            control.MouseMove += new MouseEventHandler(OnMouseMove);
            control.MouseDown += new MouseEventHandler(OnMouseDown);
            control.Click += new EventHandler(OnClick);
            control.MouseUp += new MouseEventHandler(OnMouseUp);
            control.MouseEnter += new EventHandler(OnMouseEnter);
            control.MouseLeave += new EventHandler(OnMouseLeave);
            control.GotFocus += new EventHandler(OnGotFocus);
            control.LostFocus += new EventHandler(OnLostFocus);
            control.SizeChanged += new EventHandler(OnBoundsChanged);
            control.Leave += new EventHandler(OnBoundsChanged);
            control.Paint += new PaintEventHandler(OnPaint);
        }

        /// <summary>
        /// This method is called from the same thread that call Commponent.addNotify().
        /// The constructor is called from the global event thread with form.   Invoke()
        /// Because addNotfy is synchronized with getTreeLock() and some classes are 
        /// also synchronized with it self in the GNU classpath there can be dead locks.
        /// You can use this method to modify the Component class thread safe.
        /// </summary>
        internal virtual void init()
        {
            // TODO temporaly disabled, because a Bug in classpath (Bug 30122)
            // http://gcc.gnu.org/bugzilla/show_bug.cgi?id=30122
            if(component.isFontSet())
            {
                //setFontImpl(component.getFont());
                setFont(component.getFont());
            }
        }

        protected virtual int getInsetsLeft()
        {
            return 0;
        }

        protected virtual int getInsetsTop()
        {
            return 0;
        }


        /// <summary>
        /// .NET calculate the offset relative to the detail area.
        /// Java is using the top left point of a window.
        /// That be must compensate the cordinate of a component
        /// if the parent is a window, frame or dialog.
        /// </summary>
        /// <returns>The offset of the details area in the parent</returns>
        private Point getParentOffset()
        {
            if (!(component is java.awt.Window))
            {
                java.awt.Container parent = component.getParent();
                if (parent != null)
                {
                    ComponentPeer peer = parent.getPeer();
                    if (peer is NetComponentPeer)
                    {
                        return new Point(
                            ((NetComponentPeer)peer).getInsetsLeft(),
                            ((NetComponentPeer)peer).getInsetsTop());
                    }
                }
            }
            return new Point();
        }

        private void OnPaint(object sender, PaintEventArgs e)
		{
			if(!e.ClipRectangle.IsEmpty)
			{
                int x = getInsetsLeft();
                int y = getInsetsTop();
				java.awt.Rectangle rect = new java.awt.Rectangle(e.ClipRectangle.X + x, e.ClipRectangle.Y + y, e.ClipRectangle.Width, e.ClipRectangle.Height);
				postEvent(new java.awt.@@event.PaintEvent(component, java.awt.@@event.PaintEvent.UPDATE, rect));
			}
		}

		private static int MapKeyCode(Keys key)
		{
			switch(key)
			{
				default:
					return (int)key;
			}
		}

        private static int GetMouseEventModifiers(MouseEventArgs ev)
        {
            int modifiers = GetModifiers(Control.ModifierKeys);
            //Which button was pressed or released, because it can only one that it is a switch
            MouseButtons button = ev.Button;
            switch(button){
                case MouseButtons.Left:
                    modifiers |= java.awt.@@event.InputEvent.BUTTON1_MASK;
                    break;
                case MouseButtons.Middle:
                    modifiers |= java.awt.@@event.InputEvent.BUTTON2_MASK;
                    break;
                case MouseButtons.Right:
                    modifiers |= java.awt.@@event.InputEvent.BUTTON3_MASK;
                    break;
            }
            return modifiers;
        }

        private static int GetModifiers(Keys keys)
		{
			int modifiers = 0;
            if ((keys & Keys.Shift) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.SHIFT_DOWN_MASK;
			}
			if((keys & Keys.Control) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.CTRL_DOWN_MASK;
			}
			if((keys & Keys.Alt) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.ALT_DOWN_MASK;
			}
			if((Control.MouseButtons & MouseButtons.Left) != 0)
			{
                modifiers |= java.awt.@@event.InputEvent.BUTTON1_DOWN_MASK;
			}
			if((Control.MouseButtons & MouseButtons.Middle) != 0)
			{
                modifiers |= java.awt.@@event.InputEvent.BUTTON2_DOWN_MASK;
			}
			if((Control.MouseButtons & MouseButtons.Right) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.BUTTON3_DOWN_MASK;
			}
			return modifiers;
		}

        private void OnKeyDown(object sender, KeyEventArgs e)
		{
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(e.Modifiers);
			int keyCode = MapKeyCode(e.KeyCode);
			// TODO set keyChar
			char keyChar = ' ';
			int keyLocation = java.awt.@@event.KeyEvent.KEY_LOCATION_STANDARD;
			postEvent(new java.awt.@@event.KeyEvent(component, java.awt.@@event.KeyEvent.KEY_PRESSED, when, modifiers, keyCode, keyChar, keyLocation));
		}

        private void OnKeyUp(object sender, KeyEventArgs e)
		{
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(e.Modifiers);
			int keyCode = MapKeyCode(e.KeyCode);
			// TODO set keyChar
			char keyChar = ' ';
			int keyLocation = java.awt.@@event.KeyEvent.KEY_LOCATION_STANDARD;
			postEvent(new java.awt.@@event.KeyEvent(component, java.awt.@@event.KeyEvent.KEY_RELEASED, when, modifiers, keyCode, keyChar, keyLocation));
		}

		protected virtual void OnKeyPress(object sender, KeyPressEventArgs e)
		{
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(Control.ModifierKeys);
			int keyCode = java.awt.@@event.KeyEvent.VK_UNDEFINED;
			char keyChar = e.KeyChar;
			int keyLocation = java.awt.@@event.KeyEvent.KEY_LOCATION_STANDARD;
			postEvent(new java.awt.@@event.KeyEvent(component, java.awt.@@event.KeyEvent.KEY_TYPED, when, modifiers, keyCode, keyChar, keyLocation));
		}

        private void postMouseEvent(MouseEventArgs ev, int id)
        {
            long when = java.lang.System.currentTimeMillis();
            int modifiers = GetMouseEventModifiers(ev);
            int button = GetButton(ev);
            int clickCount = ev.Clicks;
            int x = ev.X + getInsetsLeft(); //The Inset correctur is needed for Window and extended classes
            int y = ev.Y + getInsetsTop();
            postEvent(new java.awt.@@event.MouseEvent(component, id, when, modifiers, x, y, clickCount, false, button));
        }

        private void postMouseEvent(EventArgs ev, int id)
        {
            long when = java.lang.System.currentTimeMillis();
            int modifiers = GetModifiers(Control.ModifierKeys);
            int button = 0;
            int clickCount = 0;
            int x = Control.MousePosition.X - control.Location.X;
            int y = Control.MousePosition.Y - control.Location.Y;
            postEvent(new java.awt.@@event.MouseEvent(component, id, when, modifiers, x, y, clickCount, false, button));
        }

        protected virtual void OnMouseMove(object sender, MouseEventArgs ev)
		{
			if((ev.Button & (MouseButtons.Left | MouseButtons.Right)) != 0)
			{
                postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_DRAGGED);
			}
			else
			{
                postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_MOVED);
			}
		}

		private static int GetButton(MouseEventArgs e)
		{
            if((e.Button & MouseButtons.Left) != 0)
			{
				return java.awt.@@event.MouseEvent.BUTTON1;
			}
			else if((e.Button & MouseButtons.Middle) != 0)
			{
				return java.awt.@@event.MouseEvent.BUTTON2;
			}
			else if((e.Button & MouseButtons.Right) != 0)
			{
				return java.awt.@@event.MouseEvent.BUTTON3;
			}
			else
			{
				return java.awt.@@event.MouseEvent.NOBUTTON;
			}
		}

        private void OnMouseDown(object sender, MouseEventArgs ev)
		{
            isMouseClick = false;
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_PRESSED);
		}

        private void OnClick(object sender, EventArgs ev)
        {
            isMouseClick = true;
        }

        private void OnMouseUp(object sender, MouseEventArgs ev)
		{
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_RELEASED);
            if (isMouseClick)
			{
                //We make our own mouse click event because the event order is different in .NET
                //in .NET the click occured before MouseUp
                postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_CLICKED);
            }
            isMouseClick = false;
		}

		private void OnMouseEnter(object sender, EventArgs ev)
		{
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_ENTERED);
        }

		private void OnMouseLeave(object sender, EventArgs ev)
		{
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_EXITED);
		}

		private void OnGotFocus(object sender, EventArgs e)
		{
			postEvent(new java.awt.@@event.FocusEvent(component, java.awt.@@event.FocusEvent.FOCUS_GAINED));
		}

		private void OnLostFocus(object sender, EventArgs e)
		{
			postEvent(new java.awt.@@event.FocusEvent(component, java.awt.@@event.FocusEvent.FOCUS_LOST));
		}

        /// <summary>
        /// Set the size of the component to the size of the peer if different.
        /// </summary>
        private void componentSetBounds()
        {
            Point offset = getParentOffset();
            int x = control.Left + offset.X;
            int y = control.Top + offset.Y;
            int width = control.Width;
            int height = control.Height;
            if (x != component.getX() ||
                y != component.getY() ||
                width != component.getWidth() ||
                height != component.getHeight())
            {
                component.setBounds(x, y, width, height);
            }
        }

        private void OnBoundsChanged(object sender, EventArgs e)
		{
            int x = control.Left;
            int y = control.Top;
            int width = control.Width;
            int height = control.Height;
            if (x != component.getX() ||
                y != component.getY() ||
                width != component.getWidth() ||
                height != component.getHeight())
            {
                //If the component different then we need to update.
                //We call this in a different thread
                //because this event can be a result of a size change with the API
                //If it a result of a API change then component can be synchronized in another thread.
                new SetVoid(componentSetBounds).BeginInvoke(null, null);
            }
            //Will allready send in component.setBounds
            //postEvent(new java.awt.@@event.ComponentEvent(component, java.awt.@@event.ComponentEvent.COMPONENT_RESIZED));
		}

		protected void postEvent(java.awt.AWTEvent evt)
		{
			NetToolkit.eventQueue.postEvent(evt);
		}

		public int checkImage(java.awt.Image img, int width, int height, java.awt.image.ImageObserver ob)
		{
			return getToolkit().checkImage(img, width, height, ob);
		}

		public java.awt.Image createImage(java.awt.image.ImageProducer prod)
		{
			throw new NotImplementedException();
		}

		public java.awt.Image createImage(int width, int height)
		{
			return new NetBufferedImage(width, height);
		}

		public void disable()
		{
			setEnabled(false);
		}

		public void dispose()
		{
			control.Invoke(new SetVoid(disposeImpl));
		}

		private void disposeImpl()
		{
			// HACK we should dispose the control here, but that hangs in an infinite loop...
			control.Hide();
		}

		public void enable()
		{
			setEnabled(true);
		}

		public ColorModel getColorModel()
		{
			throw new NotImplementedException();
		}

		public java.awt.FontMetrics getFontMetrics(java.awt.Font f)
		{
			return new NetFontMetrics(f);
		}

		public virtual java.awt.Graphics getGraphics()
		{
            return new ComponentGraphics(this);
		}

		public java.awt.Point getLocationOnScreen()
		{
			Point p = new Point(0, 0);
            p = control.InvokeRequired ?
                    (Point)control.Invoke(new ConvertPoint(control.PointToScreen), new object[] { p }) :
                    control.PointToScreen(p);
			return new java.awt.Point(p.X, p.Y);
		}

		public java.awt.Dimension getMinimumSize()
		{
			return minimumSize();
		}

		public java.awt.Dimension getPreferredSize()
		{
			return preferredSize();
		}

		public java.awt.Toolkit getToolkit()
		{
			return java.awt.Toolkit.getDefaultToolkit();
		}

		public void handleEvent(java.awt.AWTEvent e)
		{
            if (e is java.awt.@@event.PaintEvent)
            {
                java.awt.Graphics g = component.getGraphics();
                try
                {
                    java.awt.Rectangle r = ((java.awt.@@event.PaintEvent)e).getUpdateRect();
                    g.clipRect(r.x, r.y, r.width, r.height);
                    switch (e.getID())
                    {
                        case java.awt.@@event.PaintEvent.UPDATE:
                            component.update(g);
                            break;
                        case java.awt.@@event.PaintEvent.PAINT:
                            component.paint(g);
                            break;
                        default:
                            Console.WriteLine("Unknown PaintEvent: {0}", e.getID());
                            break;
                    }
                }
                finally
                {
                    g.dispose();
                }
            }
		}

        public void hide()
		{
			setVisible(false);
		}

		public bool isFocusTraversable()
		{
			throw new NotImplementedException();
		}

		public virtual java.awt.Dimension minimumSize()
		{
			return component.getSize();
		}

		public virtual java.awt.Dimension preferredSize()
		{
			return minimumSize();
		}

		public void paint(java.awt.Graphics graphics)
		{
			//throw new NotImplementedException();
		}

		public bool prepareImage(java.awt.Image img, int width, int height, ImageObserver ob)
		{
			return getToolkit().prepareImage(img, width, height, ob);
		}

		public void print(java.awt.Graphics graphics)
		{
			throw new NotImplementedException();
		}

		public void repaint(long tm, int x, int y, int width, int height)
		{
			// TODO do something with the tm parameter
			java.awt.Rectangle rect = new java.awt.Rectangle(x, y, width, height);
			postEvent(new java.awt.@@event.PaintEvent(component, java.awt.@@event.PaintEvent.UPDATE, rect));
		}

		public void requestFocus()
		{
			control.Invoke(new SetVoid(requestFocusImpl), null);
		}

		private void requestFocusImpl()
		{
			control.Focus();
		}

		public bool requestFocus(java.awt.Component request, bool temporary, bool allowWindowFocus, long time, sun.awt.CausedFocusEvent.Cause cause)
		{
			return requestFocus(request, temporary, allowWindowFocus, time);
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="request">the component for which the focus is requested</param>
        /// <param name="temporary">indicates if the focus change is temporary (true) or permanent (false)</param>
        /// <param name="allowWindowFocus">indicates if it's allowed to change window focus</param>
        /// <param name="time">the timestamp</param>
        /// <returns></returns>
        public bool requestFocus(java.awt.Component request, bool temporary, bool allowWindowFocus, long time)
		{
            if (!control.Enabled || !control.Visible)
            {
                return false;
            }
            postEvent(new java.awt.@@event.FocusEvent(request, java.awt.@@event.FocusEvent.FOCUS_GAINED, temporary, component));
			return true;
		}

		public void reshape(int x, int y, int width, int height)
		{
			setBounds(x, y, width, height);
		}

		public void setBackground(java.awt.Color color)
		{
			control.Invoke(new SetColor(SetBackColorImpl), new object[] { color });
		}

		private void SetBackColorImpl(java.awt.Color color)
		{
            control.BackColor = Color.FromArgb(color.getRGB());
		}

        protected virtual void SetBoundsImpl(int x, int y, int width, int height)
		{
            Point offset = getParentOffset(); 
            control.SetBounds(x - offset.X, y - offset.Y, width, height);
		}

		public void setBounds(int x, int y, int width, int height)
		{
			control.Invoke(new SetXYWH(SetBoundsImpl), new object[] { x, y, width, height });
            componentSetBounds();
		}

		private void setCursorImpl(java.awt.Cursor cursor)
		{
			switch(cursor.getType())
			{
				case java.awt.Cursor.WAIT_CURSOR:
					control.Cursor = Cursors.WaitCursor;
					break;
				case java.awt.Cursor.DEFAULT_CURSOR:
					control.Cursor = Cursors.Default;
					break;
				case java.awt.Cursor.HAND_CURSOR:
					control.Cursor = Cursors.Hand;
					break;
				case java.awt.Cursor.CROSSHAIR_CURSOR:
					control.Cursor = Cursors.Cross;
					break;
				case java.awt.Cursor.W_RESIZE_CURSOR:
				case java.awt.Cursor.E_RESIZE_CURSOR:
					control.Cursor = Cursors.SizeWE;
					break;
				case java.awt.Cursor.MOVE_CURSOR:
					control.Cursor = Cursors.SizeAll;
					break;
				case java.awt.Cursor.N_RESIZE_CURSOR:
				case java.awt.Cursor.S_RESIZE_CURSOR:
					control.Cursor = Cursors.SizeNS;
					break;
				case java.awt.Cursor.NE_RESIZE_CURSOR:
				case java.awt.Cursor.SW_RESIZE_CURSOR:
					control.Cursor = Cursors.SizeNESW;
					break;
				case java.awt.Cursor.NW_RESIZE_CURSOR:
				case java.awt.Cursor.SE_RESIZE_CURSOR:
					control.Cursor = Cursors.SizeNWSE;
					break;
				case java.awt.Cursor.TEXT_CURSOR:
					control.Cursor = Cursors.IBeam;
					break;
				default:
					Console.WriteLine("setCursor not implement for: " + cursor);
					break;
			}
		}

        public void setCursor(java.awt.Cursor cursor)
        {
            control.Invoke(new SetCursor(setCursorImpl), new object[] { cursor });
        }

		private void setEnabledImpl(bool enabled)
		{
			control.Enabled = enabled;
		}

		public void setEnabled(bool enabled)
		{
			control.Invoke(new SetBool(setEnabledImpl), new object[] { enabled });
		}

        private void setFontImpl(java.awt.Font font)
		{
            control.Font = ((NetFontPeer)font.getPeer()).netFont;
		}

		public void setFont(java.awt.Font font)
		{
			control.Invoke(new SetFont(setFontImpl), new object[] { font });
		}

		public void setForeground(java.awt.Color color)
		{
			control.Invoke(new SetColor(SetForeColorImpl), new object[] { color });
		}

		private void SetForeColorImpl(java.awt.Color color)
		{
            control.ForeColor = Color.FromArgb(color.getRGB());
		}

		private void setVisibleImpl(bool visible)
		{
			control.Visible = visible;
            //will already Post from GNU Classpath
			//postEvent(new java.awt.@@event.ComponentEvent(component,
			//	visible ? java.awt.@@event.ComponentEvent.COMPONENT_SHOWN : java.awt.@@event.ComponentEvent.COMPONENT_HIDDEN));
		}

		public void setVisible(bool visible)
		{
			control.Invoke(new SetBool(setVisibleImpl), new object[] { visible });
		}

		public void show()
		{
			setVisible(true);
		}

		public java.awt.GraphicsConfiguration getGraphicsConfiguration()
		{
			return new NetGraphicsConfiguration(Screen.FromControl(control));
		}

		public void setEventMask (long mask)
		{
			//Console.WriteLine("NOTE: NetComponentPeer.setEventMask not implemented");
		}

		public bool isObscured()
		{
			return false;
		}

		public bool canDetermineObscurity()
		{
			return false;
		}

		public void coalescePaintEvent(java.awt.@@event.PaintEvent e)
		{
		}

		public void updateCursorImmediately()
		{
		}

		public java.awt.image.VolatileImage createVolatileImage(int width, int height)
		{
			return new NetVolatileImage(width, height);
		}

		public bool handlesWheelScrolling()
		{
			return true;
		}

		public void createBuffers(int x, java.awt.BufferCapabilities capabilities)
		{
			throw new NotImplementedException();
		}

		public java.awt.Image getBackBuffer()
		{
			throw new NotImplementedException();
		}

		public void flip(java.awt.BufferCapabilities.FlipContents contents)
		{
			throw new NotImplementedException();
		}

		public void destroyBuffers()
		{
			throw new NotImplementedException();
		}

		public bool isFocusable()
		{
			// TODO
			return true;
		}

		public java.awt.Rectangle getBounds()
		{
			Rectangle r = control.Bounds;
			return new java.awt.Rectangle(r.X, r.Y, r.Width, r.Height);
		}

		public void setBounds(int x, int y, int width, int height, int z)
		{
            setBounds(x, y, width, height);
            //TODO changing the Z-Order
		}

		public void reparent(java.awt.peer.ContainerPeer parent)
		{
			throw new NotImplementedException();
		}

		public bool isReparentSupported()
		{
			return false;
		}

		public void layout()
		{
		}
	}

	class NetButtonPeer : NetComponentPeer, ButtonPeer
	{
		public NetButtonPeer(java.awt.Button awtbutton, Button button)
			: base(awtbutton, button)
		{
			if(!awtbutton.isBackgroundSet())
			{
				awtbutton.setBackground(java.awt.SystemColor.control);
			}
			button.BackColor = Color.FromArgb(awtbutton.getBackground().getRGB());
			setLabel(awtbutton.getLabel());
			control.Invoke(new SetVoid(Setup));
		}

		private void Setup()
		{
			((Button)control).Click += new EventHandler(OnClick);
		}

		private void OnClick(object sender, EventArgs e)
		{
			// TODO set all these properties correctly
			string cmd = "";
			long when = 0;
			int modifiers = 0;
			postEvent(new java.awt.@@event.ActionEvent(component, java.awt.@@event.ActionEvent.ACTION_PERFORMED, cmd, when, modifiers));
		}

		private void setLabelImpl(string label)
		{
			control.Text = label;
		}

		public void setLabel(string label)
		{
			control.Invoke(new SetString(setLabelImpl), new object[] { label });
		}

		public override java.awt.Dimension minimumSize()
		{
			using(Graphics g = control.CreateGraphics())
			{
				// TODO get these fudge factors from somewhere
				return new java.awt.Dimension((int)Math.Round(12 + g.MeasureString(control.Text, control.Font).Width) * 8 / 7, 6 + control.Font.Height * 8 / 7);
			}
		}
	}

	class NetTextComponentPeer : NetComponentPeer, TextComponentPeer
	{
		public NetTextComponentPeer(java.awt.TextComponent textComponent, TextBox textBox)
			: base(textComponent, textBox)
		{
			if(!component.isBackgroundSet())
			{
				component.setBackground(java.awt.SystemColor.window);
			}
			setBackground(component.getBackground());
			textBox.AutoSize = false;
			textBox.Text = ((java.awt.TextComponent)component).getText();
		}

		protected override void OnKeyPress(object sender, KeyPressEventArgs e)
		{
			base.OnKeyPress(sender, e);
			// TODO for TextAreas this probably isn't the right behaviour
			if(e.KeyChar == '\r')
			{
				// TODO set all these properties correctly
				string cmd = "";
				long when = 0;
				int modifiers = 0;
				postEvent(new java.awt.@@event.ActionEvent(component, java.awt.@@event.ActionEvent.ACTION_PERFORMED, cmd, when, modifiers));
			}
		}

		public int getSelectionEnd()
		{
			throw new NotImplementedException();
		}
		public int getSelectionStart()
		{
			throw new NotImplementedException();
		}

		private string getTextImpl()
		{
			return control.Text;
		}

		public string getText()
		{
			return (string)control.Invoke(new GetString(getTextImpl));
		}

		private void setTextImpl(string text)
		{
			control.Text = text;
		}

		public void setText(string text)
		{
			control.Invoke(new SetString(setTextImpl), new object[] { text });
		}

		public void select(int start_pos, int end_pos)
		{
			throw new NotImplementedException();
		}
		public void setEditable(bool editable)
		{
			throw new NotImplementedException();
		}
		public int getCaretPosition()
		{
			throw new NotImplementedException();
		}

		private void setCaretPositionImpl(int pos)
		{
			((TextBox)control).SelectionStart = pos;
			((TextBox)control).SelectionLength = 0;
		}

		public void setCaretPosition(int pos)
		{
			control.Invoke(new SetInt(setCaretPositionImpl), new object[] { pos });
		}

		public long filterEvents(long filter)
		{
			throw new NotImplementedException();
		}

		public int getIndexAtPoint(int x, int y)
		{
			throw new NotImplementedException();
		}

		public java.awt.Rectangle getCharacterBounds(int pos)
		{
			throw new NotImplementedException();
		}

		public java.awt.im.InputMethodRequests getInputMethodRequests()
		{
			throw new NotImplementedException();
		}
	}

	class NetChoicePeer : NetComponentPeer, ChoicePeer
	{
		public NetChoicePeer(java.awt.Choice target, ComboBox combobox)
			: base(target, combobox)
		{
		}

		public void add(string str, int i)
		{
			// TODO:  Add NetChoicePeer.add implementation
		}

		public void addItem(string str, int i)
		{
			// TODO:  Add NetChoicePeer.addItem implementation
		}

		public void select(int i)
		{
			// TODO:  Add NetChoicePeer.select implementation
		}

		public void removeAll()
		{
			// TODO:  Add NetChoicePeer.removeAll implementation
		}

		public void remove(int i)
		{
			// TODO:  Add NetChoicePeer.remove implementation
		}
	}

	class NetCheckboxPeer : NetComponentPeer, CheckboxPeer
	{
		public NetCheckboxPeer(java.awt.Checkbox target, CheckBox checkbox)
			: base(target, checkbox)
		{
		}

		public void setCheckboxGroup(java.awt.CheckboxGroup cg)
		{
			// TODO:  Add NetCheckboxPeer.setCheckboxGroup implementation
		}

		public void setState(bool b)
		{
			// TODO:  Add NetCheckboxPeer.setState implementation
		}

		public void setLabel(string str)
		{
			// TODO:  Add NetCheckboxPeer.setLabel implementation
		}
	}

	class NetLabelPeer : NetComponentPeer, LabelPeer
	{
		public NetLabelPeer(java.awt.Label jlabel, Label label)
			: base(jlabel, label)
		{
			label.Text = jlabel.getText();
			setAlignment(jlabel.getAlignment());
		}

		public void setAlignment(int align)
		{
			switch(align)
			{
				case java.awt.Label.LEFT:
					control.Invoke(new SetInt(setAlignImpl), new object[] { ContentAlignment.TopLeft });
					break;
				case java.awt.Label.CENTER:
					control.Invoke(new SetInt(setAlignImpl), new object[] { ContentAlignment.TopCenter });
					break;
				case java.awt.Label.RIGHT:
					control.Invoke(new SetInt(setAlignImpl), new object[] { ContentAlignment.TopRight });
					break;
			}
		}

		private void setAlignImpl(int align)
		{
			((Label)control).TextAlign = (ContentAlignment)align;
		}

		public void setText(string s)
		{
			control.Invoke(new SetString(setTextImpl), new Object[] { s });
		}

		private void setTextImpl(string s)
		{
			control.Text = s;
		}

		public override java.awt.Dimension preferredSize()
		{
			return (java.awt.Dimension)control.Invoke(new GetDimension(getPreferredSizeImpl), null);
		}

		private java.awt.Dimension getPreferredSizeImpl()
		{
			Label lab = (Label)control;
			// HACK get these fudge factors from somewhere
			return new java.awt.Dimension(lab.PreferredWidth, 2 + lab.PreferredHeight);
		}
	}

	class NetTextFieldPeer : NetTextComponentPeer, TextFieldPeer
	{
		public NetTextFieldPeer(java.awt.TextField textField, TextBox textBox)
			: base(textField, textBox)
		{
			setEchoCharacter(textField.getEchoChar());
		}

		public java.awt.Dimension minimumSize(int len)
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension preferredSize(int len)
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension getMinimumSize(int len)
		{
			return getPreferredSize(len);
		}

		public java.awt.Dimension getPreferredSize(int len)
		{
			// TODO use control.Invoke
			using(Graphics g = control.CreateGraphics())
			{
				return new java.awt.Dimension((int)Math.Round((g.MeasureString("abcdefghijklm", control.Font).Width * len) / 13), ((TextBox)control).PreferredHeight);
			}
		}

		public void setEchoChar(char echo_char)
		{
			setEchoCharacter(echo_char);
		}

		public void setEchoCharacter(char echo_char)
		{
			// TODO use control.Invoke
			((TextBox)control).PasswordChar = echo_char;
		}
	}

	class NetTextAreaPeer : NetTextComponentPeer, TextAreaPeer
	{
		public NetTextAreaPeer(java.awt.TextArea textArea, TextBox textBox)
			: base(textArea, textBox)
		{
			textBox.ReadOnly = !((java.awt.TextArea)component).isEditable();
			textBox.WordWrap = false;
			textBox.ScrollBars = ScrollBars.Both;
			textBox.Multiline = true;
		}

		private void insertImpl(string text, int pos)
		{
			control.Text = control.Text.Insert(pos, text);
		}

		public void insert(string text, int pos)
		{
			control.Invoke(new SetStringInt(insertImpl), new Object[] { text, pos });
		}

		public void insertText(string text, int pos)
		{
			throw new NotImplementedException();
		}
		public java.awt.Dimension minimumSize(int rows, int cols)
		{
			return getMinimumSize(rows, cols);
		}
		public java.awt.Dimension getMinimumSize(int rows, int cols)
		{
			return new java.awt.Dimension(0, 0);
		}
		public java.awt.Dimension preferredSize(int rows, int cols)
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension getPreferredSize(int rows, int cols)
		{
			Console.WriteLine("NOTE: NetTextAreaPeer.getPreferredSize not implemented");
			return new java.awt.Dimension(10 * cols, 15 * rows);
		}

		public void replaceRange(string text, int start_pos, int end_pos)
		{
			throw new NotImplementedException();
		}
		public void replaceText(string text, int start_pos, int end_pos)
		{
			throw new NotImplementedException();
		}
	}

	class NetContainerPeer : NetComponentPeer, ContainerPeer
	{
		protected java.awt.Insets _insets = new java.awt.Insets(0, 0, 0, 0);

		public NetContainerPeer(java.awt.Container awtcontainer, ContainerControl container)
			: base(awtcontainer, container)
		{
		}

        protected override int getInsetsLeft()
        {
            return _insets.left; ;
        }

        protected override int getInsetsTop()
        {
            return _insets.top;
        }

        public java.awt.Insets insets()
		{
			return getInsets();
		}

		public java.awt.Insets getInsets()
		{
			return _insets;
		}

		public void beginValidate()
		{
		}

		public void endValidate()
		{
		}

		public void beginLayout()
		{
		}

		public void endLayout()
		{
		}

		public bool isPaintPending()
		{
			throw new NotImplementedException();
		}

		public bool isRestackSupported()
		{
			return false;
		}

		public void cancelPendingPaint(int x, int y, int width, int height)
		{
			throw new NotImplementedException();
		}

		public void restack()
		{
			throw new NotImplementedException();
		}
	}

	class NetPanelPeer : NetContainerPeer, PanelPeer
	{
		public NetPanelPeer(java.awt.Panel panel, ContainerControl container)
			: base(panel, container)
		{
		}
	}

	class NewCanvasPeer : NetComponentPeer, CanvasPeer
	{
		public NewCanvasPeer(java.awt.Canvas canvas, Control control)
			: base(canvas, control)
		{
		}
	}

	class NetWindowPeer : NetContainerPeer, WindowPeer
	{
		public NetWindowPeer(java.awt.Window window, Form form)
			: base(window, form)
		{
            //form.Shown += new EventHandler(OnOpened); Will already post in java.awt.Window.show()
            form.Closing += new CancelEventHandler(OnClosing);
            form.Closed += new EventHandler(OnClosed);
            form.Activated += new EventHandler(OnActivated);
            form.Deactivate += new EventHandler(OnDeactivate);

            //Calculate the Insets one time
            //This is many faster because there no thread change is needed.
            Rectangle client = control.ClientRectangle;
            Rectangle r = control.RectangleToScreen( client );
            int x = r.Location.X - control.Location.X;
            int y = r.Location.Y - control.Location.Y;
            _insets = new java.awt.Insets(y, x, control.Height - client.Height - y, control.Width - client.Width - x);
        }

        private void OnOpened(object sender, EventArgs e)
        {
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_OPENED));
        }

        private void OnClosing(object sender, CancelEventArgs e)
        {
            e.Cancel = true;
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_CLOSING));
        }

        private void OnClosed(object sender, EventArgs e)
        {
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_CLOSED));
        }

        private void OnActivated(object sender, EventArgs e)
        {
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_ACTIVATED));
        }

        private void OnDeactivate(object sender, EventArgs e)
        {
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_DEACTIVATED));
        }

        public override java.awt.Graphics getGraphics()
        {
            java.awt.Graphics g = base.getGraphics();
            java.awt.Insets insets = getInsets();
            g.translate(-insets.left, -insets.top);
            g.setClip(insets.left, insets.top, control.ClientRectangle.Width, control.ClientRectangle.Height);
            return g;
        }

        protected override void SetBoundsImpl(int x, int y, int width, int height)
        {
            Form form = (Form)control;
            form.DesktopBounds = new Rectangle(x, y, width, height);
        }

        public void toBack()
		{
            control.BeginInvoke(new SetVoid(((Form)control).SendToBack));
		}

		public void toFront()
		{
            control.BeginInvoke(new SetVoid(((Form)control).Activate));
		}

		public void updateAlwaysOnTop()
		{
			throw new NotImplementedException();
		}

		public bool requestWindowFocus()
		{
			return control.Focus();
		}

		public void setAlwaysOnTop(bool alwaysOnTop)
		{
			throw new NotImplementedException();
		}

		public void updateFocusableWindowState()
		{
			throw new NotImplementedException();
		}

		public void setModalBlocked(java.awt.Dialog blocker, bool blocked)
		{
			throw new NotImplementedException();
		}

		public void updateMinimumSize()
		{
			throw new NotImplementedException();
		}

		public void updateIconImages()
		{
			throw new NotImplementedException();
		}
	}

	class NetFramePeer : NetWindowPeer, FramePeer
	{
		public NetFramePeer(java.awt.Frame frame, Form form)
			: base(frame, form)
		{
			setTitle(frame.getTitle());
        }

        internal override void init()
        {
            if (!component.isFontSet())
            {
                java.awt.Font font = new java.awt.Font("Dialog", java.awt.Font.PLAIN, 12);
                component.setFont(font);
            }
            if (!component.isForegroundSet())
            {
                component.setForeground(java.awt.SystemColor.windowText);
            }
            if (!component.isBackgroundSet())
            {
                component.setBackground(java.awt.SystemColor.window);
            }
            base.init();
        }

		private class ValidateHelper : java.lang.Runnable
		{
			private java.awt.Component comp;

			internal ValidateHelper(java.awt.Component comp)
			{
				this.comp = comp;
			}

			public void run()
			{
				comp.validate();
			}
		}

		public void setIconImage(java.awt.Image image)
		{
			Console.WriteLine("NOTE: setIconImage not implemented");
		}

		public void setMenuBar(java.awt.MenuBar mb)
		{
			throw new NotImplementedException();
		}

		public void setResizable(bool resizable)
		{
			throw new NotImplementedException();
		}

		private void setTitleImpl(string title)
		{
			control.Text = title;
		}

		public void setTitle(string title)
		{
			control.Invoke(new SetString(setTitleImpl), new object[] { title });
		}

		public int getState()
		{
            Form f = (Form)control;
            FormWindowState state = f.WindowState;
            switch (state)
            {
                case FormWindowState.Normal:
                    return java.awt.Frame.NORMAL;
                case FormWindowState.Maximized:
                    return java.awt.Frame.MAXIMIZED_BOTH;
                case FormWindowState.Minimized:
                    return java.awt.Frame.ICONIFIED;
                default:
                    throw new InvalidEnumArgumentException();
            }
		}

		public void setState(int state)
		{
			throw new NotImplementedException();
		}

		public void setMaximizedBounds(java.awt.Rectangle r)
		{
			throw new NotImplementedException();
		}

		private void SetBoundsImpl(int x, int y, int width, int height)
		{
			control.Bounds = new Rectangle(x, y, width, height);
		}

		public void setBoundsPrivate(int x, int y, int width, int height)
		{
			control.Invoke(new SetXYWH(SetBoundsImpl), new object[] { x, y, width, height });
		}

		private object GetBoundsImpl()
		{
			Rectangle r = control.Bounds;
			return new java.awt.Rectangle(r.Left, r.Top, r.Width, r.Height);
		}

		public java.awt.Rectangle getBoundsPrivate()
		{
			return (java.awt.Rectangle)control.Invoke(new GetObject(GetBoundsImpl));
		}
	}

	class NetDialogPeer : NetWindowPeer, DialogPeer
	{
        public NetDialogPeer(java.awt.Dialog target, Form form)
			: base(target, form)
		{
            form.MaximizeBox = false;
            form.MinimizeBox = false;
		}

		private void setTitleImpl(string title)
		{
			control.Text = title;
		}

		public void setTitle(string title)
		{
			control.Invoke(new SetString(setTitleImpl), new object[] { title });
		}

		public void setResizable(bool resizable)
		{
			throw new NotImplementedException();
		}
	}

	class NetListPeer : NetComponentPeer, ListPeer
	{
		internal NetListPeer(java.awt.List target, ListBox listbox)
			: base(target, listbox)
		{
		}

		public void add(String item, int index)
		{
			throw new NotImplementedException();
		}

		public void addItem(String item, int index)
		{
			throw new NotImplementedException();
		}

		public void clear()
		{
			throw new NotImplementedException();
		}

		public void delItems(int start_index, int end_index)
		{
			throw new NotImplementedException();
		}

		public void deselect(int index)
		{
			throw new NotImplementedException();
		}

		public int[] getSelectedIndexes()
		{
			throw new NotImplementedException();
		}

		public void makeVisible(int index)
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension minimumSize(int s)
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension preferredSize(int s)
		{
			throw new NotImplementedException();
		}

		public void removeAll()
		{
			throw new NotImplementedException();
		}

		public void select(int index)
		{
			throw new NotImplementedException();
		}

		public void setMultipleMode(bool multi)
		{
			throw new NotImplementedException();
		}

		public void setMultipleSelections(bool multi)
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension getPreferredSize(int s)
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension getMinimumSize(int s)
		{
			throw new NotImplementedException();
		}
	}

	class NetDesktopPeer : DesktopPeer
	{
		private static void ShellExecute(string file, string verb)
		{
			try
			{
				ProcessStartInfo psi = new ProcessStartInfo(file);
				psi.UseShellExecute = true;
				psi.Verb = verb;
				Process p = Process.Start(psi);
				if (p != null)
				{
					p.Dispose();
				}
			}
			catch (System.ComponentModel.Win32Exception x)
			{
				throw new java.io.IOException(x.Message);
			}
		}

		public void browse(URI uri)
		{
			ShellExecute(uri.toString(), "open");
		}

		public void edit(java.io.File f)
		{
			ShellExecute(f.toString(), "edit");
		}

		public bool isSupported(java.awt.Desktop.Action da)
		{
			return da == java.awt.Desktop.Action.BROWSE
				|| da == java.awt.Desktop.Action.EDIT
				|| da == java.awt.Desktop.Action.MAIL
				|| da == java.awt.Desktop.Action.OPEN
				|| da == java.awt.Desktop.Action.PRINT;
		}

		public void mail(URI uri)
		{
			if (uri.getScheme().ToLower(System.Globalization.CultureInfo.InvariantCulture) != "mailto")
			{
				throw new java.lang.IllegalArgumentException("URI scheme is not \"mailto\"");
			}
			ShellExecute(uri.toString(), "open");
		}

		public void mail()
		{
			ShellExecute("mailto:", "open");
		}

		public void open(java.io.File f)
		{
			ShellExecute(f.toString(), "open");
		}

		public void print(java.io.File f)
		{
			ShellExecute(f.toString(), "print");
		}
	}
}
@


1.55
log
@Fixed to compile against .NET 1.1.
@
text
@@


1.54
log
@Updated to compile with Classpath HEAD again.
@
text
@d1981 1
a1981 1
			control.Invoke(new SetXYWH(SetBoundsImpl), x, y, width, height);
@


1.53
log
@Removed .NET 2.0 specific code introduced in previous patch.
@
text
@d57 1
d533 12
d1097 5
d1854 25
d1974 5
d1981 12
a1992 2
			// TODO use control.Invoke
			control.Bounds = new Rectangle(x, y, width, height);
@


1.52
log
@Implemented java.awt.Desktop peer.
@
text
@d2088 1
a2088 1
			if (!uri.getScheme().Equals("mailto", StringComparison.OrdinalIgnoreCase))
@


1.51
log
@Set AWT/WinForms thread as Background to stop it from keeping the process alive.
@
text
@d527 5
d2046 64
@


1.50
log
@Regression with setBounds() --> StackOverflow
@
text
@d161 1
a161 1
				//thread.IsBackground = true;
@


1.49
log
@Robot for Windows Implementiert
@
text
@d653 8
d663 1
a663 2
            java.awt.Container parent = component.getParent();
            if (parent != null)
d665 2
a666 2
                ComponentPeer peer = parent.getPeer();
                if (peer is NetComponentPeer)
d668 7
a674 3
                    return new Point(
                        ((NetComponentPeer)peer).getInsetsLeft(),
                        ((NetComponentPeer)peer).getInsetsTop());
@


1.48
log
@Fix some Winforms thread problems with calling of Invoke.
@
text
@d513 1
a513 1
		public override RobotPeer createRobot(java.awt.GraphicsDevice param)
d515 6
a520 1
			throw new NotImplementedException();
d592 1
a592 1
            control.SetBounds(component.getX(), component.getY(), component.getWidth(), component.getHeight());
d653 16
d872 3
a874 2
            int x = control.Left;
            int y = control.Top;
d1088 1
a1088 1
			throw new NotImplementedException();
d1101 1
a1101 1
		protected virtual void setBoundsImpl(int x, int y, int width, int height)
d1103 2
a1104 1
            control.SetBounds(x, y, width, height);
d1109 1
a1109 1
			control.Invoke(new SetXYWH(setBoundsImpl), new object[] { x, y, width, height });
d1282 2
a1283 1
			control.Bounds = new Rectangle(x, y, width, height);
d1795 1
a1795 1
        protected override void setBoundsImpl(int x, int y, int width, int height)
@


1.47
log
@Restructing the awt project part 2
@
text
@d56 1
d943 4
a946 2
			// TODO use control.Invoke
			Point p = control.PointToScreen(new Point(0, 0));
d1779 1
a1779 1
			((Form)control).SendToBack();
d1784 1
a1784 1
			((Form)control).Activate();
@


1.46
log
@Some fixes for SwingSet2 from Jeroen
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004, 2005, 2006 Jeroen Frijters, Volker Berlin
d4 1
a550 46
	class NoImage : java.awt.Image
	{

		public override int getWidth(java.awt.image.ImageObserver observer)
		{
			if(observer != null)
			{
				observer.imageUpdate(this, java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT, 0, 0, -1, -1);
			}
			return -1;
		}

		public override int getHeight(java.awt.image.ImageObserver observer)
		{
			if(observer != null)
			{
				observer.imageUpdate(this, java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT, 0, 0, -1, -1);
			}
			return -1;
		}

		public override ImageProducer getSource()
		{
			return null;
		}

		public override java.awt.Graphics getGraphics()
		{
			// TODO throw java.lang.IllegalAccessError: getGraphics() only valid for images created with createImage(w, h)
			return null;
		}

		public override object getProperty(string name, java.awt.image.ImageObserver observer)
		{
			if(observer != null)
			{
				observer.imageUpdate(this, java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT, 0, 0, -1, -1);
			}
			return null;
		}

		public override void flush()
		{
		}
	}

a1273 228
	class NetVolatileImage : java.awt.image.VolatileImage
	{
		internal Bitmap bitmap;

		internal NetVolatileImage(int width, int height)
		{
			bitmap = new Bitmap(width, height);
			using(Graphics g = Graphics.FromImage(bitmap))
			{
				g.Clear(Color.White);
			}
		}

		public override bool contentsLost()
		{
			return false;
		}

		public override int getHeight(ImageObserver io)
		{
			return bitmap.Height;
		}

		public override int getWidth(ImageObserver io)
		{
			return bitmap.Width;
		}

		public override object getProperty(string str, ImageObserver io)
		{
			throw new NotImplementedException();
		}

		public override java.awt.Graphics2D createGraphics()
		{
			Graphics g = Graphics.FromImage(bitmap);
			// HACK for off-screen images we don't want ClearType or anti-aliasing
			// TODO I'm sure Java 2D has a way to control text rendering quality, we should honor that
			g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;
            return new BitmapGraphics(bitmap);
		}

		public override int getHeight()
		{
			return bitmap.Height;
		}

		public override int getWidth()
		{
			return bitmap.Width;
		}

		public override BufferedImage getSnapshot()
		{
			return new NetBufferedImage(bitmap);
		}

		public override int validate(java.awt.GraphicsConfiguration gc)
		{
			return 0;
		}

		public override java.awt.ImageCapabilities getCapabilities()
		{
			throw new NotImplementedException();
		}
	}

	// HACK Classpath should have a working BufferedImage, but currently it doesn't, until then, we
	// provide a hacked up version
	class NetBufferedImage : java.awt.image.BufferedImage
	{
		internal Bitmap bitmap;

		internal NetBufferedImage(Bitmap bitmap)
			: base(bitmap.Width, bitmap.Height, java.awt.image.BufferedImage.TYPE_INT_RGB)
		{
			this.bitmap = bitmap;
		}

		internal NetBufferedImage(int width, int height)
			: base(width, height, java.awt.image.BufferedImage.TYPE_INT_RGB)
		{
			bitmap = new Bitmap(width, height);
			using(Graphics g = Graphics.FromImage(bitmap))
			{
				g.Clear(Color.White);
			}
		}

		public override java.awt.Graphics2D createGraphics()
		{
			Graphics g = Graphics.FromImage(bitmap);
			// HACK for off-screen images we don't want ClearType or anti-aliasing
			// TODO I'm sure Java 2D has a way to control text rendering quality, we should honor that
			g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;
            return new BitmapGraphics(bitmap);
		}

		public override java.awt.image.ImageProducer getSource()
		{
			int[] pix = new int[bitmap.Width * bitmap.Height];
			for(int y = 0; y < bitmap.Height; y++)
			{
				for(int x = 0; x < bitmap.Width; x++)
				{
					pix[x + y * bitmap.Width] = bitmap.GetPixel(x, y).ToArgb();
				}
			}
			return new java.awt.image.MemoryImageSource(bitmap.Width, bitmap.Height, pix, 0, bitmap.Width);
		}
	}

	class NetProducerImage : java.awt.Image, java.awt.image.ImageConsumer
	{
		private java.awt.image.ImageProducer source;

		private int mHeight = 0;

		private int mWidth = 0;

		private int mHintFlags = 0;

		private ColorModel mColorModel = null;

		private Hashtable mProperties;

		private Bitmap mBitmap;

		internal NetProducerImage(java.awt.image.ImageProducer source)
		{
			this.source = source;
		}

		public override void flush()
		{
		}

		public override java.awt.Graphics getGraphics()
		{
			return null;
		}

		public override int getHeight(ImageObserver param)
		{
			return mHeight;
		}

		public override int getWidth(ImageObserver param)
		{
			return mWidth;
		}

		public override object getProperty(string param, ImageObserver obs)
		{
			return null;
		}

		public override ImageProducer getSource()
		{
			return source;
		}

		public void setHints(int hintflags)
		{
			mHintFlags = hintflags;
		}

		public void setPixels(int x, int y, int w, int h, ColorModel model, byte[] pixels, int off, int scansize)
		{
			Console.WriteLine("NetBufferedImage: setPixels");
		}

		/// <summary>
		/// Create a bitmap from the pixel array. The bitmap will be used
		/// by drawImage.
		/// </summary>
		void java.awt.image.ImageConsumer.setPixels(int aX, int aY, int w, int h, ColorModel model, int[] pixels, int off, int scansize)
		{
			mWidth = w;
			mHeight = h;
			mColorModel = model;
			mBitmap = new Bitmap(mWidth, mHeight);
			int pixel = 0;
			for (int y = 0; y < mHeight; ++y)
			{
				for (int x = 0; x < mWidth; x++)
				{
					uint argb = (uint)pixels[pixel++];
					int blue = (int)argb & 0xff;
					argb >>= 8;
					int green = (int)argb & 0xff;
					argb >>= 8;
					int red = (int)argb & 0xff;
					argb >>= 8;
					int alpha = (int)argb & 0xff;
					mBitmap.SetPixel(x, y, Color.FromArgb(alpha, red, green, blue));
				}
			}
		}

		public Bitmap getBitmap()
		{
			return mBitmap;
		}

		public void setDimensions(int width, int height)
		{
			mWidth = width;
			mHeight = height;
		}

		public void imageComplete(int status)
		{
			// Console.WriteLine("NetBufferedImage: imageComplete");
		}

		public void setColorModel(ColorModel model)
		{
			mColorModel = model;
		}

		public void setProperties(Hashtable props)
		{
			mProperties = props;
		}
	}

@


1.45
log
@* many problems with MouseEvents fix
* bee() implemented
* getInsets() optimized
@
text
@d1148 1
d1193 1
a1193 1
            control.Font = NetGraphics.NetFontFromJavaFont(font, component.getToolkit().getScreenResolution());
@


1.44
log
@* First Implementation of GlyphVector for .Net 1.1
* Compilerproblem with .NET 1.1 fixed
@
text
@d459 4
a462 2
		{
			throw new NotImplementedException();
d600 1
a600 3
		private Point mouseDown;
		private long lastClick;
		private int clickCount;
d653 1
d682 11
a692 1
		private void OnPaint(object sender, PaintEventArgs e)
d696 2
a697 8
				int x = 0;
				int y = 0;
				if(component is java.awt.Window)
				{
                    java.awt.Insets insets = ((java.awt.Window)component).getInsets();
					x = insets.left;
					y = insets.top;
				}
d712 20
a731 1
		private static int GetModifiers(Keys keys)
d734 1
a734 1
			if((keys & Keys.Shift) != 0)
d736 1
a736 1
				modifiers |= java.awt.@@event.KeyEvent.SHIFT_DOWN_MASK;
d740 1
a740 1
				modifiers |= java.awt.@@event.KeyEvent.CTRL_DOWN_MASK;
d744 1
a744 1
				modifiers |= java.awt.@@event.KeyEvent.ALT_DOWN_MASK;
d748 1
a748 1
				modifiers |= java.awt.@@event.KeyEvent.BUTTON1_DOWN_MASK;
d752 1
a752 1
				modifiers |= java.awt.@@event.KeyEvent.BUTTON2_DOWN_MASK;
d756 1
a756 1
				modifiers |= java.awt.@@event.KeyEvent.BUTTON3_DOWN_MASK;
d761 1
a761 1
		protected virtual void OnKeyDown(object sender, KeyEventArgs e)
d772 1
a772 1
		protected virtual void OnKeyUp(object sender, KeyEventArgs e)
d793 23
a815 1
		protected virtual void OnMouseMove(object sender, MouseEventArgs e)
d817 1
a817 3
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(Control.ModifierKeys);
			if((e.Button & (MouseButtons.Left | MouseButtons.Right)) != 0)
d819 1
a819 1
				postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_DRAGGED, when, modifiers, e.X, e.Y, 0, false));
d823 1
a823 1
				postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_MOVED, when, modifiers, e.X, e.Y, 0, false));
d829 1
a829 1
			if((e.Button & MouseButtons.Left) != 0)
d847 1
a847 1
		private static bool IsWithinDoubleClickRectangle(Point p, int x, int y)
d849 2
a850 2
			return Math.Abs(x - p.X) <= SystemInformation.DoubleClickSize.Width / 2 &&
				Math.Abs(y - p.Y) <= SystemInformation.DoubleClickSize.Height / 2;
d853 4
a856 15
		protected virtual void OnMouseDown(object sender, MouseEventArgs e)
		{
			long when = java.lang.System.currentTimeMillis();
			if(when > lastClick + SystemInformation.DoubleClickTime
				|| !IsWithinDoubleClickRectangle(mouseDown, e.X, e.Y))
			{
				clickCount = 0;
			}
			clickCount++;
			lastClick = when;
			mouseDown = new Point(e.X, e.Y);
			int modifiers = GetModifiers(Control.ModifierKeys);
			int button = GetButton(e);
			postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_PRESSED, when, modifiers, e.X, e.Y, clickCount, false, button));
		}
d858 1
a858 1
		protected virtual void OnMouseUp(object sender, MouseEventArgs e)
d860 2
a861 5
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(Control.ModifierKeys);
			int button = GetButton(e);
			postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_RELEASED, when, modifiers, e.X, e.Y, clickCount, (e.Button & MouseButtons.Right) != 0, button));
			if(mouseDown.X == e.X && mouseDown.Y == e.Y)
d863 5
a867 2
				postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_CLICKED, when, modifiers, e.X, e.Y, clickCount, false, button));
			}
d870 1
a870 1
		private void OnMouseEnter(object sender, EventArgs e)
d872 2
a873 6
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(Control.ModifierKeys);
			int x = Control.MousePosition.X;
			int y = Control.MousePosition.Y;
			postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_ENTERED, when, modifiers, x, y, 0, false));
		}
d875 1
a875 1
		private void OnMouseLeave(object sender, EventArgs e)
d877 1
a877 5
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(Control.ModifierKeys);
			int x = Control.MousePosition.X;
			int y = Control.MousePosition.Y;
			postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_EXITED, when, modifiers, x, y, 0, false));
d1088 9
a1096 1
		public bool requestFocus(java.awt.Component source, bool bool1, bool bool2, long x)
d1098 5
a1102 2
			// TODO what do all the args mean?
			requestFocus();
d1905 1
a1905 1
		private java.awt.Insets _insets = new java.awt.Insets(0, 0, 0, 0);
d1912 11
a1922 1
		public java.awt.Insets insets()
d1927 1
a1927 1
		public virtual java.awt.Insets getInsets()
d1995 8
a2030 14
        private Rectangle RectangleToScreen(Rectangle rec)
        {
            return control.RectangleToScreen(rec);
        }

        public override java.awt.Insets getInsets()
        {
            Rectangle client = control.ClientRectangle;
            Rectangle r = (Rectangle)control.Invoke(new ConvertRectangle(RectangleToScreen), new object[] { client });
            int x = r.Location.X - control.Location.X;
            int y = r.Location.Y - control.Location.Y;
            return new java.awt.Insets(y, x, control.Height - client.Height - y, control.Width - client.Width - x);
        }

@


1.43
log
@Restructing of the awt files step 1
@
text
@d347 1
a347 1
			return new NetFontMetrics(font, getScreenResolution());
d952 1
a952 1
			return new NetFontMetrics(f, 0);
@


1.42
log
@*** empty log message ***
@
text
@a27 2
using System.Drawing.Drawing2D;
using System.Drawing.Text;
a33 1
using System.Text;
a519 159
	class NetGraphicsEnvironment : java.awt.GraphicsEnvironment
	{
		// Create a bitmap with the dimensions of the argument image. Then
		// create a graphics objects from the bitmap. All paint operations will
		// then paint the bitmap.
		public override java.awt.Graphics2D createGraphics(BufferedImage bi)
		{
			Bitmap bitmap = new Bitmap(bi.getWidth(), bi.getHeight());
            return new BitmapGraphics(bitmap);
		}

		public override java.awt.Font[] getAllFonts()
		{
			throw new NotImplementedException();
		}

		public override string[] getAvailableFontFamilyNames()
		{
			throw new NotImplementedException();
		}

		public override string[] getAvailableFontFamilyNames(Locale l)
		{
			throw new NotImplementedException();
		}

		public override java.awt.GraphicsDevice getDefaultScreenDevice()
		{
			return new NetGraphicsDevice();
		}

		public override java.awt.GraphicsDevice[] getScreenDevices()
		{
			throw new NotImplementedException();
		}
	}

	class NetGraphicsDevice : java.awt.GraphicsDevice
	{
		public override java.awt.GraphicsConfiguration[] getConfigurations()
		{
			throw new NotImplementedException();
		}

		public override java.awt.GraphicsConfiguration getDefaultConfiguration()
		{
			return new NetGraphicsConfiguration(Screen.PrimaryScreen);
		}

		public override string getIDstring()
		{
			throw new NotImplementedException();
		}

		public override int getType()
		{
			return TYPE_RASTER_SCREEN;
		}
	}

	class NetFontPeer : gnu.java.awt.peer.ClasspathFontPeer
	{
		internal NetFontPeer(string name, java.util.Map attrs)
			: base(name, attrs)
		{
		}

		public override bool canDisplay(java.awt.Font param1, char param2)
		{
			throw new NotImplementedException();
		}

		public override int canDisplayUpTo(java.awt.Font param1, java.text.CharacterIterator param2, int param3, int param4)
		{
			throw new NotImplementedException();
		}

		public override java.awt.font.GlyphVector createGlyphVector(java.awt.Font param1, java.awt.font.FontRenderContext param2, int[] param3)
		{
			throw new NotImplementedException();
		}

		public override java.awt.font.GlyphVector createGlyphVector(java.awt.Font param1, java.awt.font.FontRenderContext param2, java.text.CharacterIterator param3)
		{
			throw new NotImplementedException();
		}

		public override byte getBaselineFor(java.awt.Font param1, char param2)
		{
			throw new NotImplementedException();
		}

		public override java.awt.FontMetrics getFontMetrics(java.awt.Font aFont)
		{
			return new NetFontMetrics(aFont, 0);
		}

		public override string getGlyphName(java.awt.Font param1, int param2)
		{
			throw new NotImplementedException();
		}

		public override java.awt.font.LineMetrics getLineMetrics(java.awt.Font aFont, java.text.CharacterIterator aCharacterIterator, int aBegin, int aLimit, java.awt.font.FontRenderContext aFontRenderContext)
		{
			string s = ToString(aCharacterIterator, aBegin, aLimit);
			return new NetLineMetrics(aFont, s);
		}

		public override java.awt.geom.Rectangle2D getMaxCharBounds(java.awt.Font param1, java.awt.font.FontRenderContext param2)
		{
			throw new NotImplementedException();
		}

		public override int getMissingGlyphCode(java.awt.Font param)
		{
			throw new NotImplementedException();
		}

		public override int getNumGlyphs(java.awt.Font param)
		{
			throw new NotImplementedException();
		}

		public override string getPostScriptName(java.awt.Font param)
		{
			throw new NotImplementedException();
		}

		public override bool hasUniformLineMetrics(java.awt.Font param)
		{
			throw new NotImplementedException();
		}

		public override java.awt.font.GlyphVector layoutGlyphVector(java.awt.Font param1, java.awt.font.FontRenderContext param2, char[] param3, int param4, int param5, int param6)
		{
			throw new NotImplementedException();
		}

		public override string getSubFamilyName(java.awt.Font param1, Locale param2)
		{
			throw new NotImplementedException();
		}

		private static string ToString(java.text.CharacterIterator aCharacterIterator, int aBegin, int aLimit)
		{
			aCharacterIterator.setIndex(aBegin);
			StringBuilder sb = new StringBuilder();

			for (int i = aBegin; i <= aLimit; ++i)
			{
				char c = aCharacterIterator.current();
				sb.Append(c);
				aCharacterIterator.next();
			}

			return sb.ToString();
		}
	}

d526 1
a526 769
	}

	class NetLightweightContainerPeer : NetContainerPeer, java.awt.peer.LightweightPeer
	{
		public NetLightweightContainerPeer(java.awt.Container target)
			: base(target, GetContainerControl(target.getParent()))
		{
		}

		private static ContainerControl GetContainerControl(java.awt.Container aContainer)
		{
			ContainerControl control = null;

			if (aContainer != null)
			{
				control = (ContainerControl) ((NetContainerPeer) aContainer.getPeer()).control;
			}

			return control;
		}
	}

	class NoImage : java.awt.Image
	{

		public override int getWidth(java.awt.image.ImageObserver observer)
		{
			if(observer != null)
			{
				observer.imageUpdate(this, java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT, 0, 0, -1, -1);
			}
			return -1;
		}

		public override int getHeight(java.awt.image.ImageObserver observer)
		{
			if(observer != null)
			{
				observer.imageUpdate(this, java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT, 0, 0, -1, -1);
			}
			return -1;
		}

		public override ImageProducer getSource()
		{
			return null;
		}

		public override java.awt.Graphics getGraphics()
		{
			// TODO throw java.lang.IllegalAccessError: getGraphics() only valid for images created with createImage(w, h)
			return null;
		}

		public override object getProperty(string name, java.awt.image.ImageObserver observer)
		{
			if(observer != null)
			{
				observer.imageUpdate(this, java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT, 0, 0, -1, -1);
			}
			return null;
		}

		public override void flush()
		{
		}
	}

    internal class ComponentGraphics : NetGraphics
    {
        private readonly Control control;

        internal ComponentGraphics(NetComponentPeer peer)
            : base(peer.control.CreateGraphics(), peer.component.getFont(), peer.control.BackColor)
        {
            control = peer.control;
        }

        public override java.awt.Graphics create()
        {
            ComponentGraphics newGraphics = (ComponentGraphics)MemberwiseClone();
            newGraphics.init(control.CreateGraphics());
            return newGraphics;
        }
    }

    internal class BitmapGraphics : NetGraphics
    {
        private readonly Bitmap bitmap;

        internal BitmapGraphics(Bitmap bitmap)
            : base(Graphics.FromImage(bitmap), null, Color.White)
        {
            this.bitmap = bitmap;
        }

        public override java.awt.Graphics create()
        {
            BitmapGraphics newGraphics = (BitmapGraphics)MemberwiseClone();
            newGraphics.init(Graphics.FromImage(bitmap));
            return newGraphics;
        }
    }

    internal abstract class NetGraphics : java.awt.Graphics2D
	{
		private Graphics g;
		private java.awt.Color jcolor;
		private Color color = SystemColors.WindowText;
		private Color bgcolor;
		private java.awt.Font font;
        private java.awt.Stroke stroke;
        private static java.awt.BasicStroke defaultStroke = new java.awt.BasicStroke(); 
		private Font netfont;
        private Brush brush;
        private Pen pen;

        protected NetGraphics(Graphics g, java.awt.Font font, Color bgcolor)
		{
            if(font == null)
			{
				font = new java.awt.Font("Dialog", java.awt.Font.PLAIN, 12);
			}
			this.font = font;
			netfont = NetFontFromJavaFont(font, g.DpiY);
			this.bgcolor = bgcolor;
            init(g);
		}

        protected void init(Graphics graphics)
        {
            if (g != null)
            {
                //Transfer the state from the original graphics
                //occur on call of create()
                graphics.Transform = g.Transform;
                graphics.Clip = g.Clip;
                graphics.SmoothingMode = g.SmoothingMode;
                graphics.TextRenderingHint = g.TextRenderingHint;
                graphics.InterpolationMode = g.InterpolationMode;
            }
            g = graphics;
            brush = new SolidBrush(color);
            pen = new Pen(color);
        }

		public override void clearRect(int x, int y, int width, int height)
		{
            using (Brush br = new SolidBrush(bgcolor))
            {
                g.FillRectangle(br, x, y, width, height);
            }
		}

		public override void clipRect(int x, int y, int w, int h)
		{
            g.IntersectClip(new Rectangle(x, y, w, h));
		}

        public override void clip(java.awt.Shape shape)
		{
            if (shape == null)
            {
                // the API specification says that this will clear
                // the clip, but in fact the reference implementation throws a 
                // NullPointerException - see the following entry in the bug parade:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6206189
                throw new java.lang.NullPointerException();
            }
            else
            {
                g.IntersectClip(new Region(J2C.ConvertShape(shape)));
            }
        }

        public override void copyArea(int param1, int param2, int param3, int param4, int param5, int param6)
		{
            throw new NotImplementedException();
		}

		public override void dispose()
		{
            g.Dispose();
		}

		public override void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle)
		{
            g.DrawArc(pen, x, y, width, height, startAngle, arcAngle);
		}

		public override void drawBytes(byte[] data, int offset, int length, int x, int y)
		{
            char[] chars = new char[length];
            for (int i = 0; i < length; i++)
            {
                chars[i] = (char)data[offset + i];
            }
            drawChars(chars, 0, length, x, y);
		}

        public override void drawChars(char[] data, int offset, int length, int x, int y)
		{
            drawString(new String(data, offset, length), x, y);
		}

        public override bool drawImage(java.awt.Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, java.awt.Color color, java.awt.image.ImageObserver observer)
		{
            Image image = J2C.ConvertImage(img);
            if (image == null)
            {
                return false;
            }
            Rectangle destRect = new Rectangle(dx1, dy1, dx2 - dx1, dy2 - dy1);
            Rectangle srcRect = new Rectangle(sx1, sy1, sx2 - sx1, sy2 - sy1);
            using(Brush brush = J2C.CreateBrush(color) )
            {
                g.FillRectangle(brush, destRect);
            }
            g.DrawImage(image, destRect, srcRect, GraphicsUnit.Pixel);
            return true;
		}

		public override bool drawImage(java.awt.Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, java.awt.image.ImageObserver observer)
		{
            Image image = J2C.ConvertImage(img);
            if (image == null)
            {
                return false;
            }
            Rectangle destRect = new Rectangle(dx1, dy1, dx2 - dx1, dy2 - dy1);
            Rectangle srcRect = new Rectangle(sx1, sy1, sx2 - sx1, sy2 - sy1);
            g.DrawImage(image, destRect, srcRect, GraphicsUnit.Pixel);
            return true;
		}

        public override bool drawImage(java.awt.Image img, int param2, int param3, int param4, int param5, java.awt.Color col, java.awt.image.ImageObserver observer)
		{
            Console.WriteLine(new System.Diagnostics.StackTrace());
            throw new NotImplementedException();
		}

		public override bool drawImage(java.awt.Image param1, int param2, int param3, java.awt.Color param4, java.awt.image.ImageObserver param5)
		{
            Console.WriteLine(new System.Diagnostics.StackTrace());
            throw new NotImplementedException();
		}

		public override bool drawImage(java.awt.Image param1, int param2, int param3, int param4, int param5, java.awt.image.ImageObserver param6)
		{
            Console.WriteLine(new System.Diagnostics.StackTrace());
            throw new NotImplementedException();
		}

		public override bool drawImage(java.awt.Image img, int x, int y, java.awt.image.ImageObserver observer)
		{
            if (img is NetBufferedImage)
			{
				g.DrawImage(((NetBufferedImage)img).bitmap, x, y);
			}
			else if(img is NetProducerImage)
			{
				g.DrawImage(((NetProducerImage)img).getBitmap(), x, y);
			}
			else if(img is NetVolatileImage)
			{
				g.DrawImage(((NetVolatileImage)img).bitmap, x, y);
			}
			else if(img is java.awt.image.BufferedImage)
			{
				// TODO this is horrible...
				java.awt.image.BufferedImage bufImg = (java.awt.image.BufferedImage)img;
				for(int iy = 0; iy < bufImg.getHeight(); iy++)
				{
					for(int ix = 0; ix < bufImg.getWidth(); ix++)
					{
						using(Pen p = new Pen(Color.FromArgb(bufImg.getRGB(ix, iy))))
						{
							g.DrawLine(p, x + ix, y + iy, x + ix + 1, y + iy);
						}
					}
				}
			}
			else
			{
                Console.WriteLine(new System.Diagnostics.StackTrace());
                throw new NotImplementedException(img.GetType().FullName);
			}
			return true;
		}

		public override void drawLine(int x1, int y1, int x2, int y2)
		{
			// HACK DrawLine doesn't appear to draw the last pixel, so for single pixel lines, we have
			// a freaky workaround
			if(x1 == x2 && y1 == y2)
			{
				g.DrawLine(pen, x1, y1, x1 + 0.01f, y2 + 0.01f);
			}
			else
			{
				g.DrawLine(pen, x1, y1, x2, y2);
			}
		}

		public override void drawOval(int x, int y, int w, int h)
		{
            g.DrawEllipse(pen, x, y, w, h);
		}

		public override void drawPolygon(java.awt.Polygon polygon)
		{
            drawPolygon(polygon.xpoints, polygon.ypoints, polygon.npoints);
		}

		public override void drawPolygon(int[] aX, int[] aY, int aLength)
		{
            Point[] points = new Point[aLength];
			for (int i = 0; i < aLength; i++)
			{
				points[i].X = aX[i];
				points[i].Y = aY[i];
			}
			g.DrawPolygon(pen, points);
		}

		/// <summary>
		/// Draw a sequence of connected lines
		/// </summary>
		/// <param name="aX">Array of x coordinates</param>
		/// <param name="aY">Array of y coordinates</param>
		/// <param name="aLength">Length of coordinate arrays</param>
		public override void drawPolyline(int[] aX, int[] aY, int aLength)
		{
			for (int i = 0; i < aLength - 1; i++)
			{
				Point point1 = new Point(aX[i], aY[i]);
				Point point2 = new Point(aX[i+1], aY[i+1]);
				g.DrawLine(pen, point1, point2);
			}
		}

		public override void drawRect(int x, int y, int width, int height)
		{
			g.DrawRectangle(pen, x, y, width, height);
		}

		/// <summary>
		/// Apparently there is no rounded rec function in .Net. Draw the
		/// rounded rectangle by using lines and arcs.
		/// </summary>
		public override void drawRoundRect(int x, int y, int w, int h, int radius, int param6)
		{
            using (GraphicsPath gp = createRoundRect(x, y, w, h, radius))
			g.DrawPath(pen, gp);
		}

		/// <summary>
		/// Create a rounded rectangle using lines and arcs
		/// </summary>
		/// <param name="x">upper left x coordinate</param>
		/// <param name="y">upper left y coordinate</param>
		/// <param name="w">width</param>
		/// <param name="h">height</param>
		/// <param name="radius">radius of arc</param>
		/// <returns></returns>
		private GraphicsPath createRoundRect(int x, int y, int w, int h, int radius)
		{
            GraphicsPath gp = new GraphicsPath();

			gp.AddLine(x + radius, y, x + w - (radius * 2), y);
			gp.AddArc(x + w - (radius * 2), y, radius * 2, radius * 2, 270, 90);
			gp.AddLine(x + w, y + radius, x + w, y + h - (radius * 2));
			gp.AddArc(x + w - (radius * 2), y + h - (radius * 2), radius * 2, radius * 2, 0, 90);
			gp.AddLine(x + w - (radius * 2), y + h, x + radius, y + h);
			gp.AddArc(x, y + h - (radius * 2), radius * 2, radius * 2, 90, 90);
			gp.AddLine(x, y + h - (radius * 2), x, y + radius);
			gp.AddArc(x, y, radius * 2, radius * 2, 180, 90);

			gp.CloseFigure();

			return gp;
		}

        private java.awt.Rectangle createRectangle(RectangleF rec)
        {
            return new java.awt.Rectangle( (int)rec.X, (int)rec.Y, (int)rec.Width, (int)rec.Height );
        }

		public override void drawString(java.text.AttributedCharacterIterator param1, int param2, int param3)
		{
            throw new NotImplementedException();
		}

		public override void drawString(string str, int x, int y)
		{
            int descent = netfont.FontFamily.GetCellDescent(netfont.Style);
            int descentPixel = (int)Math.Round(netfont.Size * descent / netfont.FontFamily.GetEmHeight(netfont.Style));
            g.DrawString(str, netfont, brush, x, y - netfont.Height + descentPixel);
		}

		public override void fill3DRect(int param1, int param2, int param3, int param4, bool param5)
		{
            throw new NotImplementedException();
		}

		public override void fillArc(int x, int y, int width, int height, int startAngle, int arcAngle)
		{
            g.FillPie(brush, x, y, width, height, startAngle, arcAngle);
		}

		public override void fillOval(int x, int y, int w, int h)
		{
            g.FillEllipse(brush, x, y, w, h);
		}

		public override void fillPolygon(java.awt.Polygon polygon)
		{
            fillPolygon(polygon.xpoints, polygon.ypoints, polygon.npoints);
		}

		public override void fillPolygon(int[] aX, int[] aY, int aLength)
		{
            Point[] points = new Point[aLength];
			for (int i = 0; i < aLength; i++)
			{
				points[i].X = aX[i];
				points[i].Y = aY[i];
			}
			g.FillPolygon(brush, points);
		}

		public override void fillRect(int x, int y, int width, int height)
		{
            g.FillRectangle(brush, x, y, width, height);
		}

		public override void fillRoundRect(int x, int y, int w, int h, int radius, int param6)
		{
            GraphicsPath gp = createRoundRect(x, y, w, h, radius);
			g.FillPath(brush, gp);
			gp.Dispose();
		}

		public override java.awt.Shape getClip()
		{
			return getClipBounds();
		}

		public override java.awt.Rectangle getClipBounds(java.awt.Rectangle r)
		{
            Region clip = g.Clip;
			if(!clip.IsInfinite(g))
			{
                RectangleF rec = clip.GetBounds(g);
                r.x = (int)rec.X;
                r.y = (int)rec.Y;
                r.width = (int)rec.Width;
                r.height = (int)rec.Height;
			}
			return r;
		}

		public override java.awt.Rectangle getClipBounds()
		{
            Region clip = g.Clip;
			if(clip.IsInfinite(g))
            {
                return null;
            }
            RectangleF rec = clip.GetBounds(g);
            return createRectangle(rec);
		}

		[Obsolete]
		public override java.awt.Rectangle getClipRect()
		{
            return getClipBounds();
		}

		public override java.awt.Color getColor()
		{
			if(jcolor == null)
			{
				jcolor = new java.awt.Color(color.ToArgb());
			}
			return jcolor;
		}

		public override java.awt.Font getFont()
		{
			return font;
		}

		internal static Font NetFontFromJavaFont(java.awt.Font f, float dpi)
		{
			FontFamily fam;
			switch(f.getName())
			{
				case "Monospaced":
				case "Courier":
				case "courier":
					fam = FontFamily.GenericMonospace;
					break;
				case "Serif":
					fam = FontFamily.GenericSerif;
					break;
				case "SansSerif":
				case "Dialog":
				case "DialogInput":
				case null:
				case "Default":
					fam = FontFamily.GenericSansSerif;
					break;
				default:
					try
					{
						fam = new FontFamily(f.getName());
					}
					catch(ArgumentException)
					{
						fam = FontFamily.GenericSansSerif;
					}
					break;
			}
			// NOTE Regular is guaranteed zero
			FontStyle style = FontStyle.Regular;
			if(f.isBold())
			{
				style |= FontStyle.Bold;
			}
			if(f.isItalic())
			{
				style |= FontStyle.Italic;
			}
			float em = fam.GetEmHeight(style);
			float line = fam.GetLineSpacing(style);
			return new Font(fam, (int)Math.Round(((f.getSize() * dpi) / 72) * em / line), style, GraphicsUnit.Pixel);
		}

		public override java.awt.FontMetrics getFontMetrics(java.awt.Font f)
		{
            return new NetFontMetrics(f, g.DpiY);
		}

		public override java.awt.FontMetrics getFontMetrics()
		{
            return new NetFontMetrics(font, g.DpiY);
		}

		public override void setClip(int x, int y, int width, int height)
		{
            g.Clip = new Region(new Rectangle(x, y, width, height));
		}

		public override void setClip(java.awt.Shape shape)
		{
            if (shape == null)
            {
                Region clip = g.Clip;
                clip.MakeInfinite();
                g.Clip = clip;
            }
            else
            {
                g.Clip = new Region(J2C.ConvertShape(shape));
            }
		}

		public override void setColor(java.awt.Color color)
		{
			if(color == null)
			{
				// TODO is this the correct default color?
				//color = java.awt.SystemColor.controlText;
                throw new java.lang.IllegalArgumentException("Color can't be null");
			}
			this.jcolor = color;
			this.color = Color.FromArgb(color.getRGB());
            if(brush is SolidBrush){
                ((SolidBrush)brush).Color = this.color;
            }else{
                brush.Dispose();
                brush = new SolidBrush(this.color);
            }
            pen.Color = this.color;
		}

		public override void setFont(java.awt.Font f)
		{
			// TODO why is Component calling us with a null reference and is this legal?
            if (f != null)
            {
                Font newfont = NetFontFromJavaFont(f, g.DpiY);
                netfont.Dispose();
                netfont = newfont;
                font = f;
            }
            else
            {
                Console.WriteLine("Font is null");
                Console.WriteLine(new System.Diagnostics.StackTrace());
            }
		}

		public override void setPaintMode()
		{
            throw new NotImplementedException();
		}

		public override void setXORMode(java.awt.Color param)
		{
            throw new NotImplementedException();
		}

		public override void translate(int x, int y)
		{
            Matrix transform = g.Transform;
            transform.Translate(x, y);
            g.Transform = transform;
		}

		public override void draw(java.awt.Shape shape)
		{
            using (GraphicsPath gp = J2C.ConvertShape(shape))
            {
                g.DrawPath(pen,gp);
            }
        }

		public override bool drawImage(java.awt.Image image, java.awt.geom.AffineTransform xform, ImageObserver obs)
		{
            Console.WriteLine(new System.Diagnostics.StackTrace());
            throw new NotImplementedException();
		}

		public override void drawImage(java.awt.image.BufferedImage image, BufferedImageOp op, int x, int y)
		{
            Console.WriteLine(new System.Diagnostics.StackTrace());
            throw new NotImplementedException();
		}

		public override void drawRenderedImage(java.awt.image.RenderedImage image, java.awt.geom.AffineTransform xform)
		{
            throw new NotImplementedException();
		}

		public override void drawRenderableImage(java.awt.image.renderable.RenderableImage image, java.awt.geom.AffineTransform xform)
		{
            throw new NotImplementedException();
		}

		public override void drawString(string text, float x, float y)
		{
            g.DrawString(text, netfont, brush, x, y);
		}

		public override void drawString(java.text.AttributedCharacterIterator iterator, float x, float y)
		{
            throw new NotImplementedException();
		}

		public override void fill(java.awt.Shape shape)
		{
            using (Region region = new Region(J2C.ConvertShape(shape)))
            {
                g.FillRegion(brush,region);
            }
		}

		public override bool hit(java.awt.Rectangle rect, java.awt.Shape s, bool onStroke)
		{
            if (onStroke)
            {
                //TODO use stroke
                //s = stroke.createStrokedShape(s);
            }
            return s.intersects(rect);
		}

		public override java.awt.GraphicsConfiguration getDeviceConfiguration()
		{
            throw new NotImplementedException();
		}

		public override void setComposite(java.awt.Composite comp)
		{
            throw new NotImplementedException();
		}

		public override void setPaint(java.awt.Paint paint)
		{
            throw new NotImplementedException();
		}

		public override void setStroke(java.awt.Stroke stroke)
		{
            if (defaultStroke.equals(stroke))
            {
                stroke = null;
                return;
            }
            this.stroke = stroke;
		}

		public override void setRenderingHint(java.awt.RenderingHints.Key hintKey, Object hintValue)
		{
            if(hintKey == java.awt.RenderingHints.KEY_ANTIALIASING)
            {
                if (hintValue == java.awt.RenderingHints.VALUE_ANTIALIAS_DEFAULT)
                {
                    g.SmoothingMode = SmoothingMode.Default;
                    return;
                }
                if (hintValue == java.awt.RenderingHints.VALUE_ANTIALIAS_OFF)
                {
                    g.SmoothingMode = SmoothingMode.None;
                    return;
                }
                if (hintValue == java.awt.RenderingHints.VALUE_ANTIALIAS_ON)
                {
                    g.SmoothingMode = SmoothingMode.AntiAlias;
                    return;
                }
                return;
            }
            if (hintKey == java.awt.RenderingHints.KEY_INTERPOLATION)
            {
                if (hintValue == java.awt.RenderingHints.VALUE_INTERPOLATION_BILINEAR)
                {
                    g.InterpolationMode = InterpolationMode.Bilinear;
                    return;
                }
                if (hintValue == java.awt.RenderingHints.VALUE_INTERPOLATION_BICUBIC)
                {
                    g.InterpolationMode = InterpolationMode.Bicubic;
                    return;
                }
                if (hintValue == java.awt.RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR)
                {
                    g.InterpolationMode = InterpolationMode.NearestNeighbor;
                    return;
                }
                return;
            }
            if (hintKey == java.awt.RenderingHints.KEY_TEXT_ANTIALIASING)
            {
                if (hintValue == java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT)
                {
                    g.TextRenderingHint = TextRenderingHint.SystemDefault;
                    return;
                }
                if (hintValue == java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_OFF)
                {
                    g.TextRenderingHint = TextRenderingHint.SingleBitPerPixel;
                    return;
                }
                if (hintValue == java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON)
                {
                    g.TextRenderingHint = TextRenderingHint.AntiAlias;
                    return;
                }
                return;
            }
		}

		public override object getRenderingHint(java.awt.RenderingHints.Key hintKey)
		{
            return getRenderingHints().get(hintKey);
		}
d528 4
a531 1
		public override void setRenderingHints(java.util.Map hints)
a532 2
            addRenderingHints(hints);
            //TODO all not included values should reset to default, but was is default?
d535 1
a535 1
		public override void addRenderingHints(java.util.Map hints)
d537 1
a537 7
            Iterator iterator = hints.entrySet().iterator();
            while (iterator.hasNext())
            {
                java.util.Map.Entry entry = (java.util.Map.Entry)iterator.next();
                setRenderingHint( (java.awt.RenderingHints.Key)entry.getKey(), entry.getValue());
            }
		}
d539 4
a542 15
		public override java.awt.RenderingHints getRenderingHints()
		{
            java.awt.RenderingHints hints = new java.awt.RenderingHints(null);
            switch (g.SmoothingMode)
            {
                case SmoothingMode.Default:
                    hints.put(java.awt.RenderingHints.KEY_ANTIALIASING, java.awt.RenderingHints.VALUE_ANTIALIAS_DEFAULT);
                    break;
                case SmoothingMode.None:
                    hints.put(java.awt.RenderingHints.KEY_ANTIALIASING, java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);
                    break;
                case SmoothingMode.AntiAlias:
                    hints.put(java.awt.RenderingHints.KEY_ANTIALIASING, java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
                    break;
            }
d544 1
a544 133
            switch(g.InterpolationMode)
            {
                case InterpolationMode.Bilinear:
                case InterpolationMode.HighQualityBilinear:
                    hints.put(java.awt.RenderingHints.KEY_INTERPOLATION, java.awt.RenderingHints.VALUE_INTERPOLATION_BILINEAR);
                    break;
                case InterpolationMode.Bicubic:
                case InterpolationMode.HighQualityBicubic:
                    hints.put(java.awt.RenderingHints.KEY_INTERPOLATION, java.awt.RenderingHints.VALUE_INTERPOLATION_BICUBIC);
                    break;
                case InterpolationMode.NearestNeighbor:
                    hints.put(java.awt.RenderingHints.KEY_INTERPOLATION, java.awt.RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
                    break;
            }

            switch (g.TextRenderingHint)
            {
                case TextRenderingHint.SystemDefault:
                    hints.put(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING, java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT);
                    break;
                case TextRenderingHint.SingleBitPerPixelGridFit:
                case TextRenderingHint.SingleBitPerPixel:
                    hints.put(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING, java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
                    break;
                case TextRenderingHint.AntiAlias:
                case TextRenderingHint.AntiAliasGridFit:
                    hints.put(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING, java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
                    break;
            }
            return hints;
		}

		public override void translate(double x, double y)
		{
            Matrix transform = g.Transform;
            transform.Translate((float)x, (float)y);
            g.Transform = transform;
        }

		public override void rotate(double angle)
		{
            Matrix transform = g.Transform;
            transform.Rotate((float)angle);
            g.Transform = transform;
		}

		public override void rotate(double angle, double x, double y)
		{
            Matrix transform = g.Transform;
            transform.Translate((float)x, (float)y);
            transform.Rotate((float)angle);
            transform.Translate(-(float)x, -(float)y);
            g.Transform = transform;
        }

		public override void scale(double scaleX, double scaleY)
		{
            using (Matrix transform = g.Transform)
            {
                transform.Scale((float)scaleX, (float)scaleY);
                g.Transform = transform;
            }
        }

		public override void shear(double shearX, double shearY)
		{
            using (Matrix transform = g.Transform)
            {
                transform.Shear((float)shearX, (float)shearY);
                g.Transform = transform;
            }
        }

		public override void transform(java.awt.geom.AffineTransform tx)
		{
            using (Matrix transform = g.Transform, 
                matrix = J2C.ConvertTransform(tx))
            {
                transform.Multiply(matrix);
                g.Transform = transform;
            }
		}

		public override void setTransform(java.awt.geom.AffineTransform tx)
		{
            g.Transform = J2C.ConvertTransform(tx);
		}

		public override java.awt.geom.AffineTransform getTransform()
		{
            using (Matrix matrix = g.Transform)
            {
                return C2J.ConvertMatrix(matrix);
            }
		}

		public override java.awt.Paint getPaint()
		{
            throw new NotImplementedException();
		}

		public override java.awt.Composite getComposite()
		{
            throw new NotImplementedException();
		}

		public override void setBackground(java.awt.Color color)
		{
            bgcolor = Color.FromArgb(color.getRGB());
		}

		public override java.awt.Color getBackground()
		{
            return new java.awt.Color(bgcolor.ToArgb());
		}

		public override java.awt.Stroke getStroke()
		{
            if (stroke == null)
            {
                return defaultStroke;
            }
            return stroke;
		}

		public override java.awt.font.FontRenderContext getFontRenderContext()
		{
            throw new NotImplementedException();
		}

		public override void drawGlyphVector(java.awt.font.GlyphVector g, float x, float y)
		{
            throw new NotImplementedException();
d548 1
a548 1
	class NetFontMetrics : java.awt.FontMetrics, IDisposable
a549 2
		private float dpi;
		private Font mFont;
d551 1
a551 1
		public NetFontMetrics(java.awt.Font font, float dpi) : base(font)
d553 5
a557 1
			this.dpi = dpi;
d560 1
a560 1
		private Font RealizeFont()
d562 1
a562 1
			if (mFont == null)
d564 1
a564 9
				if (dpi == 0)
				{
					using (Graphics g = NetToolkit.bogusForm.CreateGraphics())
					{
						dpi = g.DpiY;
					}
				}

				mFont = NetGraphics.NetFontFromJavaFont(getFont(), dpi);
d566 1
a566 2

			return mFont;
d569 1
a569 1
		public override int getHeight()
d571 1
a571 1
			return RealizeFont().Height;
d574 1
a574 1
		public override int getLeading()
d576 2
a577 1
			return (int) Math.Round(GetLeadingFloat());
d580 1
a580 1
		public override int getMaxAdvance()
d582 1
a582 53
			// HACK very lame
			return charWidth('M');
		}

		public override int charWidth(char ch)
		{
			// HACK we average 20 characters to decrease the influence of the pre/post spacing
			return stringWidth(new String(ch, 20)) / 20;
		}

		public override int charsWidth(char[] data, int off, int len)
		{
			return stringWidth(new String(data, off, len));
		}

		public override int getAscent()
		{
			return (int) Math.Round(GetAscentFloat());
		}

		public override int getDescent()
		{
			return (int) Math.Round(GetDescentFloat());
		}

		public override int stringWidth(string s)
		{
			return (int) Math.Round(GetStringBounds(s).getWidth());
		}

		public float GetAscentFloat()
		{
			Font f = RealizeFont();
			int ascent = f.FontFamily.GetCellAscent(f.Style);
			return f.Size * ascent / f.FontFamily.GetEmHeight(f.Style);
		}

		public float GetDescentFloat()
		{
			Font f = RealizeFont();
			int descent = f.FontFamily.GetCellDescent(f.Style);
			return f.Size * descent / f.FontFamily.GetEmHeight(f.Style);
		}

		public float GetLeadingFloat()
		{
			float leading = getHeight() - (GetAscentFloat() + GetDescentFloat());
			return Math.Max(0.0f, leading);
		}

		public java.awt.geom.Rectangle2D GetStringBounds(String aString)
		{
			using (Graphics g = NetToolkit.bogusForm.CreateGraphics())
d584 1
a584 15
				// TODO (KR) Could replace with System.Windows.Forms.TextRenderer#MeasureText (to skip creating Graphics)
				//
				// From .NET Framework Class Library documentation for Graphics#MeasureString:
				//
				//    To obtain metrics suitable for adjacent strings in layout (for
				//    example, when implementing formatted text), use the
				//    MeasureCharacterRanges method or one of the MeasureString
				//    methods that takes a StringFormat, and pass GenericTypographic.
				//    Also, ensure the TextRenderingHint for the Graphics is
				//    AntiAlias.
				//
				// TODO (KR) Consider implementing with one of the Graphics#MeasureString methods that takes a StringFormat.
				// TODO (KR) Consider implementing with Graphics#MeasureCharacterRanges().
				SizeF size = g.MeasureString(aString, RealizeFont(), Int32.MaxValue, StringFormat.GenericTypographic);
				return new java.awt.geom.Rectangle2D.Float(0, 0, size.Width, size.Height);
d586 1
d589 1
a589 3
		#region IDisposable Members

		public void Dispose()
a590 4
			if (mFont != null)
			{
				mFont.Dispose();
			}
a591 2

		#endregion
a1509 76
	class NetGraphicsConfiguration : java.awt.GraphicsConfiguration
	{
        Screen screen;

        public NetGraphicsConfiguration(Screen screen)
        {
            this.screen = screen;
        }

		public override java.awt.image.BufferedImage createCompatibleImage(int param1, int param2, int param3)
		{
			throw new NotImplementedException();
		}

		public override java.awt.image.BufferedImage createCompatibleImage(int width, int height)
		{
			return new NetBufferedImage(width, height);
		}

		public override java.awt.image.VolatileImage createCompatibleVolatileImage(int param1, int param2, java.awt.ImageCapabilities param3)
		{
			throw new NotImplementedException();
		}

		public override java.awt.image.VolatileImage createCompatibleVolatileImage(int param1, int param2)
		{
			throw new NotImplementedException();
		}

		public override java.awt.Rectangle getBounds()
		{
            System.Drawing.Rectangle bounds = screen.Bounds;
			return new java.awt.Rectangle(bounds.X, bounds.Y, bounds.Width, bounds.Height );
		}

		public override java.awt.BufferCapabilities getBufferCapabilities()
		{
			throw new NotImplementedException();
		}

		public override java.awt.image.ColorModel getColorModel(int param)
		{
			throw new NotImplementedException();
		}

		public override java.awt.image.ColorModel getColorModel()
		{
			throw new NotImplementedException();
		}

		public override java.awt.geom.AffineTransform getDefaultTransform()
		{
			throw new NotImplementedException();
		}

		public override java.awt.GraphicsDevice getDevice()
		{
			return new NetGraphicsDevice();
		}

		public override java.awt.ImageCapabilities getImageCapabilities()
		{
			throw new NotImplementedException();
		}

		public override java.awt.geom.AffineTransform getNormalizingTransform()
		{
			throw new NotImplementedException();
		}

		public override VolatileImage createCompatibleVolatileImage(int i1, int i2, int i3)
		{
			throw new NotImplementedException();
		}
	}

a2234 71
	class NetLineMetrics : java.awt.font.LineMetrics
	{
		private java.awt.Font mFont;
		private String mString;
		private NetFontMetrics mFontMetrics;

		public NetLineMetrics(java.awt.Font aFont, String aString)
		{
			mFont = aFont;
			mString = aString;
			mFontMetrics = new NetFontMetrics(aFont, 0);
		}

		public override float getAscent()
		{
			return mFontMetrics.GetAscentFloat();
		}

		public override int getBaselineIndex()
		{
			throw new NotImplementedException();
		}

		public override float[] getBaselineOffsets()
		{
			// TODO (KR) Probably could implement with Graphics#MeasureCharacterRanges(), if called.
			throw new NotImplementedException();
		}

		public override float getDescent()
		{
			return mFontMetrics.GetDescentFloat();
		}

		public override float getHeight()
		{
			// TODO (KR) Could implement with Graphics#MeasureString().
			// TODO (KR) Consider implementing with Graphics#MeasureCharacterRanges().
			return mFontMetrics.getHeight();
		}

		public override float getLeading()
		{
			return mFontMetrics.GetLeadingFloat();
		}

		public override int getNumChars()
		{
			return mString.Length;
		}

		public override float getStrikethroughOffset()
		{
			throw new NotImplementedException();
		}

		public override float getStrikethroughThickness()
		{
			throw new NotImplementedException();
		}

		public override float getUnderlineOffset()
		{
			throw new NotImplementedException();
		}

		public override float getUnderlineThickness()
		{
			throw new NotImplementedException();
		}
	}
@


1.41
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004, 2005, 2006 Jeroen Frijters
d22 2
a23 2
  jeroen@@frijters.net
  
d27 1
d29 2
a33 1
using System.Drawing;
d53 3
a55 2
	delegate void SetColor(Color c);
	delegate void SetFont(Font f);
d57 1
a65 4

		protected override void OnPaintBackground(PaintEventArgs pevent)
		{
		}
a73 4

		protected override void OnPaintBackground(PaintEventArgs pevent)
		{
		}
a81 4

		protected override void OnPaintBackground(PaintEventArgs pevent)
		{
		}
a89 4

		protected override void OnPaintBackground(PaintEventArgs pevent)
		{
		}
d92 1
a92 1
	public class NetToolkit : gnu.java.awt.ClasspathToolkit
d94 1
a94 1
		internal static java.awt.EventQueue eventQueue = new java.awt.EventQueue();
d99 1
a99 1
		private delegate Control CreateControlInstanceDelegate(Type type);
d124 1
a124 1
		internal static Control CreateControlImpl(Type type)
d126 3
a128 3
			Control control = (Control)Activator.CreateInstance(type);
			control.CreateControl();
			// HACK here we go again...
d134 17
a150 6
			return control;
		}

		internal static Control CreateControl(Type type)
		{
			return (Control)bogusForm.Invoke(createControlInstance, new object[] { type });
d209 1
a209 1
			return new NetButtonPeer(target, (Button)CreateControl(typeof(Button)));
d214 2
a215 2
			return new NetTextFieldPeer(target, (TextBox)CreateControl(typeof(TextBox)));
		}
d219 1
a219 1
			return new NetLabelPeer(target, (Label)CreateControl(typeof(Label)));
d224 1
a224 1
			return new NetListPeer(target, (ListBox)CreateControl(typeof(ListBox)));
d229 1
a229 1
			return new NetCheckboxPeer(target, (CheckBox)CreateControl(typeof(CheckBox)));
d244 1
a244 1
			return new NetTextAreaPeer(target, (TextBox)CreateControl(typeof(TextBox)));
d249 1
a249 1
			return new NetChoicePeer(target, (ComboBox)CreateControl(typeof(ComboBox)));
d254 6
a259 1
			return new NetFramePeer(target, (Form)CreateControl(typeof(MyForm)));
d264 1
a264 1
			return new NewCanvasPeer(target, (Control)CreateControl(typeof(MyControl)));
d269 1
a269 1
			return new NetPanelPeer(target, (ContainerControl)CreateControl(typeof(MyContainerControl)));
d274 1
a274 1
			return new NetWindowPeer(target, (Form)CreateControl(typeof(UndecoratedForm)));
d279 1
a279 1
			return new NetDialogPeer(target, (Form)CreateControl(typeof(MyForm)));
d367 1
a367 1
			catch(Exception)
d369 1
a369 1
				return new NoImage();
d446 8
a453 1
			throw new NotImplementedException();
d531 1
a531 3
			NetGraphics g = new NetGraphics(Graphics.FromImage(bitmap), null, Color.Wheat, true);
			g.setBitmap(bitmap);
			return g;
d569 1
a569 1
			return new NetGraphicsConfiguration();
d712 1
d756 37
a792 1
	public class NetGraphics : java.awt.Graphics2D
a793 1
		private bool disposable;
d799 2
d802 2
a803 2
		private java.awt.Rectangle _clip;
		private Bitmap mBitmap;
d805 1
a805 1
		public NetGraphics(Graphics g, java.awt.Font font, Color bgcolor, bool disposable)
d807 1
a807 1
			if(font == null)
a810 1
			this.g = g;
d814 1
a814 10
			this.disposable = disposable;
			if(!g.IsClipEmpty)
			{
				_clip = new java.awt.Rectangle((int)Math.Round(g.ClipBounds.Left), (int)Math.Round(g.ClipBounds.Top), (int)Math.Round(g.ClipBounds.Width), (int)Math.Round(g.ClipBounds.Height));
			}
		}

		public Bitmap getBitmap()
		{
			return mBitmap;
d817 16
a832 4
		public void setBitmap(Bitmap aBitmap)
		{
			mBitmap = aBitmap;
		}
d836 4
a839 8
			using(SolidBrush b = new SolidBrush(bgcolor))
			{
				g.FillRectangle(b, x, y, width, height);
			}
		}

		public override void clipRect(int param1, int param2, int param3, int param4)
		{
d842 1
a842 1
		public override void copyArea(int param1, int param2, int param3, int param4, int param5, int param6)
d844 1
d847 1
a847 1
		public override java.awt.Graphics create(int x, int y, int width, int height)
d849 13
a861 5
			java.awt.Graphics g = create();
			g.translate(x, y);
			g.setClip(0, 0, width, height);
			return g;
		}
d863 1
a863 1
		public override java.awt.Graphics create()
d865 1
a865 7
			// TODO we need to actually recreate a new underlying Graphics object, but .NET doesn't
			// seem to have a way of doing that, so we probably need access to the underlying surface.
			// Sigh...
			NetGraphics newg = new NetGraphics(g, font, bgcolor, false);
			disposable = false;
			// TODO copy other attributes
			return newg;
d870 1
a870 11
			if(disposable)
			{
				disposable = false;
				g.Dispose();
				g = null;
			}
			netfont.Dispose();
		}

		public override void draw3DRect(int param1, int param2, int param3, int param4, bool param5)
		{
d873 1
a873 1
		public override void drawArc(int param1, int param2, int param3, int param4, int param5, int param6)
d875 1
d878 1
a878 1
		public override void drawBytes(byte[] param1, int param2, int param3, int param4, int param5)
d880 6
d888 1
a888 1
		public override void drawChars(char[] param1, int param2, int param3, int param4, int param5)
d890 1
d893 1
a893 1
		public override bool drawImage(java.awt.Image param1, int param2, int param3, int param4, int param5, int param6, int param7, int param8, int param9, java.awt.Color param10, java.awt.image.ImageObserver param11)
d895 13
a907 1
			return true;
d912 9
a920 17
			if(img is NetBufferedImage)
			{
				Rectangle destRect = new Rectangle(dx1, dy1, dx2 - dx1, dy2 - dy1);
				Rectangle srcRect = new Rectangle(sx1, sy1, sx2 - sx1, sy2 - sy1);
				g.DrawImage(((NetBufferedImage)img).bitmap, destRect, srcRect, GraphicsUnit.Pixel);
			}
			else if(img is NetVolatileImage)
			{
				Rectangle destRect = new Rectangle(dx1, dy1, dx2 - dx1, dy2 - dy1);
				Rectangle srcRect = new Rectangle(sx1, sy1, sx2 - sx1, sy2 - sy1);
				g.DrawImage(((NetVolatileImage)img).bitmap, destRect, srcRect, GraphicsUnit.Pixel);
			}
			else
			{
				throw new NotImplementedException();
			}
			return true;
d923 1
a923 1
		public override bool drawImage(java.awt.Image param1, int param2, int param3, int param4, int param5, java.awt.Color param6, java.awt.image.ImageObserver param7)
d925 2
a926 1
			return true;
d931 2
a932 1
			return true;
d937 2
a938 1
			return true;
d943 1
a943 1
			if(img is NetBufferedImage)
d972 2
a973 1
				throw new NotImplementedException(img.GetType().FullName);
d980 7
a986 1
			using(Pen p = new Pen(color, 1))
d988 1
a988 10
				// HACK DrawLine doesn't appear to draw the last pixel, so for single pixel lines, we have
				// a freaky workaround
				if(x1 == x2 && y1 == y2)
				{
					g.DrawLine(p, x1, y1, x1 + 0.01f, y2 + 0.01f);
				}
				else
				{
					g.DrawLine(p, x1, y1, x2, y2);
				}
d992 1
a992 1
		public override void drawOval(int param1, int param2, int param3, int param4)
d994 1
d997 1
a997 1
		public override void drawPolygon(java.awt.Polygon param)
d999 1
d1004 1
a1004 2
			Point[] points = new Point[aLength];

d1010 1
a1010 5

			using (Pen pen = new Pen(color))
			{
				g.DrawPolygon(pen, points);
			}
d1021 1
a1021 1
			using (Pen pen = new Pen(color))
d1023 3
a1025 6
				for (int i = 0; i < aLength - 1; i++)
				{
					Point point1 = new Point(aX[i], aY[i]);
					Point point2 = new Point(aX[i+1], aY[i+1]);
					g.DrawLine(pen, point1, point2);
				}
d1031 1
a1031 4
			using(Pen pen = new Pen(color))
			{
				g.DrawRectangle(pen, x, y, width, height);
			}
d1040 2
a1041 5
			using (GraphicsPath gp = createRoundRect(x, y, w, h, radius))
			using (Pen pen = new Pen(color))
			{
				g.DrawPath(pen, gp);
			}
d1055 1
a1055 1
			GraphicsPath gp = new GraphicsPath();
d1071 5
d1078 1
d1083 3
a1085 6
			using(Brush brush = new SolidBrush(color))
			{
				int descent = netfont.FontFamily.GetCellDescent(netfont.Style);
				int descentPixel = (int)Math.Round(netfont.Size * descent / netfont.FontFamily.GetEmHeight(netfont.Style));
				g.DrawString(str, netfont, brush, x, y - netfont.Height + descentPixel);
			}
d1090 1
d1093 1
a1093 1
		public override void fillArc(int param1, int param2, int param3, int param4, int param5, int param6)
d1095 1
d1098 1
a1098 1
		public override void fillOval(int param1, int param2, int param3, int param4)
d1100 1
d1103 1
a1103 1
		public override void fillPolygon(java.awt.Polygon aPolygon)
d1105 1
a1105 12
			Point[] points = new Point[aPolygon.npoints];

			for (int i = 0; i < aPolygon.npoints; i++)
			{
				points[i].X = aPolygon.xpoints[i];
				points[i].Y = aPolygon.ypoints[i];
			}

			using(Brush brush = new SolidBrush(color))
			{
				g.FillPolygon(brush, points);
			}
d1110 1
a1110 2
			Point[] points = new Point[aLength];

d1116 1
a1116 5

			using(Brush brush = new SolidBrush(color))
			{
				g.FillPolygon(brush, points);
			}
d1121 1
a1121 4
			using(Brush brush = new SolidBrush(color))
			{
				g.FillRectangle(brush, x, y, width, height);
			}
d1126 2
a1127 6
			GraphicsPath gp = createRoundRect(x, y, w, h, radius);

			using(Brush brush = new SolidBrush(color))
			{
				g.FillPath(brush, gp);
			}
d1138 2
a1139 1
			if(_clip != null)
d1141 5
a1145 4
				r.x = _clip.x;
				r.y = _clip.y;
				r.width = _clip.width;
				r.height = _clip.height;
d1152 7
a1158 1
			return getClipRect();
d1164 1
a1164 5
			if(_clip != null)
			{
				return new java.awt.Rectangle(_clip);
			}
			return null;
d1229 1
a1229 1
			return new NetFontMetrics(f, g.DpiY);
d1234 1
a1234 6
			return new NetFontMetrics(font, g.DpiY);
		}

		public override bool hitClip(int param1, int param2, int param3, int param4)
		{
			return true;
d1239 1
a1239 2
			_clip = new java.awt.Rectangle(x, y, width, height);
			g.Clip = new Region(new Rectangle(x, y, width, height));
d1242 1
a1242 1
		public override void setClip(java.awt.Shape param)
d1244 10
a1253 3
			// NOTE we only support rectangular clipping for the moment
			java.awt.Rectangle r = param.getBounds();
			setClip(r.x, r.y, r.width, r.height);
d1261 2
a1262 1
				color = java.awt.SystemColor.controlText;
d1266 7
d1278 12
a1289 7
			if(f != null)
			{
				Font newfont = NetFontFromJavaFont(f, g.DpiY);
				netfont.Dispose();
				netfont = newfont;
				font = f;
			}
d1294 1
d1299 1
d1304 3
a1306 3
			System.Drawing.Drawing2D.Matrix matrix = g.Transform;
			matrix.Translate(x, y);
			g.Transform = matrix;
d1311 5
a1315 1
		}
d1319 2
a1320 1
			return false;
d1325 2
d1331 1
d1336 1
d1341 1
d1346 1
d1351 4
d1357 8
a1364 3
		public override bool hit(java.awt.Rectangle rect, java.awt.Shape text, bool onStroke)
		{
			return false;
d1369 1
a1369 1
			return null;
d1374 1
d1379 1
d1384 6
d1394 57
d1455 1
a1455 1
			return null;
d1460 2
d1466 6
d1476 68
a1543 14
			return null;
		}

		public override void translate(double tx, double ty)
		{
		}

		public override void rotate(double theta)
		{
		}

		public override void rotate(double theta, double x, double y)
		{
		}
d1547 6
a1552 1
		}
d1556 15
d1573 1
a1573 5
		public override void transform(java.awt.geom.AffineTransform Tx)
		{
		}

		public override void setTransform(java.awt.geom.AffineTransform Tx)
d1575 1
d1580 4
a1583 1
			return null;
d1588 1
a1588 1
			return null;
d1593 1
a1593 1
			return null;
d1598 1
d1603 1
a1603 1
			return null;
d1608 5
a1612 5
			return null;
		}

		public override void clip(java.awt.Shape s)
		{
d1617 1
a1617 1
			return null;
d1622 1
a1754 2
		private int offsetX;
		private int offsetY;
d1761 1
a1761 1
			this.control = control;
d1769 2
a1770 2
					NetComponentPeer parentPeer = (NetComponentPeer)parent.getPeer();
					if(parentPeer != null)
a1773 4
					else
					{
						// TODO later on when the owner peer is created we should set our owner
					}
a1786 10
				if(parent is java.awt.Frame && !(control is Form))
				{
					java.awt.Insets ins = ((NetFramePeer)parent.getPeer()).getInsets();
					offsetX = -ins.left;
					offsetY = -ins.top;
				}
			}
			if(component.isFontSet())
			{
				setFont(component.getFont());
d1788 2
a1789 1
			// we need the null check, because for a Window, at this time it doesn't have a foreground yet
d1792 1
a1792 1
				setForeground(component.getForeground());
d1797 1
a1797 1
				setBackground(component.getBackground());
a1799 4
			//setBounds(component.getX(), component.getY(), component.getWidth(), component.getHeight());
			control.Invoke(new SetVoid(Setup));
			control.Paint += new PaintEventHandler(OnPaint);
			component.invalidate();
d1802 36
d1844 1
a1844 1
				if(component is java.awt.Frame)
d1846 1
a1846 1
					java.awt.Insets insets = ((java.awt.Frame)component).getInsets();
a1854 16
		private void Setup()
		{
			// TODO we really only should hook these events when they are needed...
			control.KeyDown += new KeyEventHandler(OnKeyDown);
			control.KeyUp += new KeyEventHandler(OnKeyUp);
			control.KeyPress += new KeyPressEventHandler(OnKeyPress);
			control.MouseMove += new MouseEventHandler(OnMouseMove);
			control.MouseDown += new MouseEventHandler(OnMouseDown);
			control.MouseUp += new MouseEventHandler(OnMouseUp);
			control.MouseEnter += new EventHandler(OnMouseEnter);
			control.MouseLeave += new EventHandler(OnMouseLeave);
			control.GotFocus += new EventHandler(OnGotFocus);
			control.LostFocus += new EventHandler(OnLostFocus);
			control.SizeChanged += new EventHandler(OnSizeChanged);
		}

d2022 37
a2058 3
		private void OnSizeChanged(object sender, EventArgs e)
		{
			postEvent(new java.awt.@@event.ComponentEvent(component, java.awt.@@event.ComponentEvent.COMPONENT_RESIZED));
d2114 1
a2114 1
			return new NetGraphics(control.CreateGraphics(), component.getFont(), control.BackColor, true);
d2141 25
a2165 26
			if(e is java.awt.@@event.PaintEvent)
			{
				java.awt.Graphics g = component.getGraphics();
				try
				{
					java.awt.Rectangle r = ((java.awt.@@event.PaintEvent)e).getUpdateRect();
					r = r.intersection(g.getClipRect());
					g.setClip(r);
					switch(e.getID())
					{
						case java.awt.@@event.PaintEvent.UPDATE:
							component.update(g);
							break;
						case java.awt.@@event.PaintEvent.PAINT:
							component.paint(g);
							break;
						default:
							Console.WriteLine("Unknown PaintEvent: {0}", e.getID());
							break;
					}
				}
				finally
				{
					g.dispose();
				}
			}
d2168 1
a2168 1
		public void hide()
d2234 1
a2234 1
			control.Invoke(new SetColor(SetBackColorImpl), new object[] { Color.FromArgb(color.getRGB()) });
d2237 1
a2237 1
		private void SetBackColorImpl(Color c)
d2239 1
a2239 1
			control.BackColor = c;
d2242 1
a2242 1
		private void setBoundsImpl(int x, int y, int width, int height)
d2244 1
a2244 1
			control.SetBounds(x, y, width, height);
d2249 2
a2250 1
			control.Invoke(new SetXYWH(setBoundsImpl), new object[] { x + offsetX, y + offsetY, width, height });
d2253 1
a2253 1
		public void setCursor(java.awt.Cursor cursor)
d2296 5
d2311 1
a2311 1
		private void setFontImpl(Font font)
d2313 1
a2313 1
			control.Font = font;
d2318 1
a2318 1
			control.Invoke(new SetFont(setFontImpl), new object[] { NetGraphics.NetFontFromJavaFont(font, component.getToolkit().getScreenResolution()) });
d2323 1
a2323 1
			control.Invoke(new SetColor(SetForeColorImpl), new object[] { Color.FromArgb(color.getRGB()) });
d2326 1
a2326 1
		private void SetForeColorImpl(Color c)
d2328 1
a2328 1
			control.ForeColor = c;
d2334 3
a2336 2
			postEvent(new java.awt.@@event.ComponentEvent(component,
				visible ? java.awt.@@event.ComponentEvent.COMPONENT_SHOWN : java.awt.@@event.ComponentEvent.COMPONENT_HIDDEN));
d2351 1
a2351 1
			return new NetGraphicsConfiguration();
d2478 1
a2478 1
			return new NetGraphics(g, null, Color.White, true);
d2535 1
a2535 1
			return new NetGraphics(g, null, Color.White, true);
d2669 7
d2698 2
a2699 1
			throw new NotImplementedException();
a2795 5
			control.Invoke(new SetVoid(Setup));
		}

		private void Setup()
		{
a2799 1
			TextBox textBox = (TextBox)control;
a3050 6
			control.Invoke(new SetVoid(Setup));
		}

		private void Setup()
		{
			TextBox textBox = (TextBox)control;
d3177 61
a3237 17
			if(!window.isFontSet())
			{
				window.setFont(new java.awt.Font("Dialog", java.awt.Font.PLAIN, 12));
			}
			if(!window.isForegroundSet())
			{
				window.setForeground(java.awt.SystemColor.windowText);
			}
			if(!window.isBackgroundSet())
			{
				window.setBackground(java.awt.SystemColor.window);
			}
			setFont(window.getFont());
			setForeground(window.getForeground());
			setBackground(window.getBackground());
			form.SetBounds(window.getX(), window.getY(), window.getWidth(), window.getHeight());
		}
d3239 1
a3239 1
		public void toBack()
d3266 1
a3266 8
			control.Invoke(new SetVoid(Setup));
		}

		private void Setup()
		{
			Form form = (Form)control;
			form.Closing += new CancelEventHandler(Closing);
		}
d3268 17
a3284 5
		private void Closing(object sender, CancelEventArgs e)
		{
			e.Cancel = true;
			postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_CLOSING));
		}
a3300 9
		public override java.awt.Graphics getGraphics()
		{
			NetGraphics g = new NetGraphics(control.CreateGraphics(), component.getFont(), control.BackColor, true);
			java.awt.Insets insets = ((java.awt.Frame)component).getInsets();
			g.translate(-insets.left, -insets.top);
			g.setClip(insets.left, insets.top, control.ClientRectangle.Width, control.ClientRectangle.Height);
			return g;
		}

a3325 11
		public override java.awt.Insets getInsets()
		{
			// TODO use control.Invoke
			Form f = (Form)control;
			Rectangle client = f.ClientRectangle;
			Rectangle r = f.RectangleToScreen(client);
			int x = r.Location.X - f.Location.X;
			int y = r.Location.Y - f.Location.Y;
			return new java.awt.Insets(y, x, control.Height - client.Height - y, control.Width - client.Width - x);
		}

d3328 13
a3340 1
			throw new NotImplementedException();
d3362 1
a3362 1
		internal NetDialogPeer(java.awt.Dialog target, Form form)
d3365 2
@


1.40
log
@*** empty log message ***
@
text
@d1560 9
a1568 1
					((Form)control).Owner = (Form)((NetComponentPeer)parent.getPeer()).control;
d1582 1
a1582 1
				if(parent is java.awt.Frame)
@


1.39
log
@*** empty log message ***
@
text
@a641 8
		public override java.awt.geom.Rectangle2D getStringBounds(java.awt.Font aFont, java.text.CharacterIterator aCharacterIterator, int aBegin, int aLimit, java.awt.font.FontRenderContext aFontRenderContext)
		{
			NetFontMetrics fontMetrics = (NetFontMetrics) getFontMetrics(aFont);
			string s = ToString(aCharacterIterator, aBegin, aLimit);

			return fontMetrics.GetStringBounds(s);
		}

@


1.38
log
@*** empty log message ***
@
text
@a2880 1
			throw new NotImplementedException();
a2884 1
			throw new NotImplementedException();
@


1.37
log
@*** empty log message ***
@
text
@d163 1
@


1.36
log
@*** empty log message ***
@
text
@d2108 1
a2108 1
			throw new NotImplementedException();
d2113 1
a2113 1
			throw new NotImplementedException();
a2117 1
			throw new NotImplementedException();
a2121 1
			throw new NotImplementedException();
d2131 1
a2131 1
			throw new NotImplementedException();
@


1.35
log
@*** empty log message ***
@
text
@d121 4
d142 4
d342 1
d1143 1
a1143 1
				return (java.awt.Rectangle)_clip.clone();
@


1.34
log
@*** empty log message ***
@
text
@d858 6
d896 19
d917 1
a917 1
				throw new NotImplementedException();
d2119 1
a2119 1
			throw new NotImplementedException();
d2179 68
d3009 1
a3009 1
			throw new NotImplementedException();
@


1.33
log
@*** empty log message ***
@
text
@d52 1
d154 1
d2025 5
d2032 1
a2032 2
			// TODO use control.Invoke
			control.Font = NetGraphics.NetFontFromJavaFont(font, component.getToolkit().getScreenResolution());
@


1.32
log
@*** empty log message ***
@
text
@d797 1
a797 1
		public override java.awt.Graphics create(int param1, int param2, int param3, int param4)
d799 4
a802 1
			return null;
@


1.31
log
@*** empty log message ***
@
text
@d1532 9
a1540 1
					control.Parent = ((NetComponentPeer)parent.getPeer()).control;
@


1.30
log
@*** empty log message ***
@
text
@d1592 1
d1762 5
d1835 1
a1835 1
		public virtual java.awt.Dimension getPreferredSize()
d1885 1
a1885 1
		public java.awt.Dimension minimumSize()
d1890 1
a1890 1
		public java.awt.Dimension preferredSize()
d2403 1
a2403 1
		public override java.awt.Dimension getPreferredSize()
d2617 1
a2617 1
		public override java.awt.Dimension getPreferredSize()
a2863 1
			form.Resize += new EventHandler(Resize);
a2887 14
		private void Resize(object sender, EventArgs e)
		{
			if(component.getWidth() != control.Bounds.Width
				|| component.getHeight() != control.Bounds.Height)
			{
				component.setSize(control.Bounds.Width, control.Bounds.Height);
			}
			if(component.getX() != control.Bounds.X
				|| component.getY() != control.Bounds.Y)
			{
				component.setLocation(control.Bounds.X, control.Bounds.Y);
			}
		}

@


1.29
log
@*** empty log message ***
@
text
@d1783 1
a1783 1
			throw new NotImplementedException();
d1799 1
a1799 1
			throw new NotImplementedException();
d1871 1
a1871 1
			throw new NotImplementedException();
d1923 3
a1925 1
			throw new NotImplementedException();
@


1.28
log
@*** empty log message ***
@
text
@d1210 8
a1217 4
			Font newfont = NetFontFromJavaFont(f, g.DpiY);
			netfont.Dispose();
			netfont = newfont;
			font = f;
d2034 1
a2034 1
			throw new NotImplementedException();
@


1.27
log
@*** empty log message ***
@
text
@a488 5
		public override gnu.java.awt.peer.ClasspathTextLayoutPeer getClasspathTextLayoutPeer(java.text.AttributedString str, java.awt.font.FontRenderContext ctxt)
		{
			throw new NotImplementedException();
		}

@


1.26
log
@moved CompilerClassLoader.cs and remapper.cs from runtime to ikvmc
@
text
@d1041 4
a1044 2
			g.FillPolygon(new SolidBrush(color), points);

d1057 4
a1060 1
			g.FillPolygon(new SolidBrush(color), points);
d1075 4
a1078 1
			g.FillPath(new SolidBrush(color), gp);
@


1.25
log
@*** empty log message ***
@
text
@d3 1
d27 2
d34 1
d271 1
d276 1
d281 1
d286 1
d291 1
d463 1
d472 1
d507 3
d512 4
a515 1
			throw new NotImplementedException();
d599 1
a599 1
		public override java.awt.FontMetrics getFontMetrics(java.awt.Font param)
d601 1
a601 1
			throw new NotImplementedException();
d609 1
a609 1
		public override java.awt.font.LineMetrics getLineMetrics(java.awt.Font param1, java.text.CharacterIterator param2, int param3, int param4, java.awt.font.FontRenderContext param5)
d611 2
a612 1
			throw new NotImplementedException();
d635 1
a635 1
		public override java.awt.geom.Rectangle2D getStringBounds(java.awt.Font param1, java.text.CharacterIterator param2, int param3, int param4, java.awt.font.FontRenderContext param5)
d637 4
a640 1
			throw new NotImplementedException();
d657 15
d685 1
a685 1
			: base(target, (ContainerControl)((NetContainerPeer)target.getParent().getPeer()).control)
d688 12
d747 1
a747 1
	class NetGraphics : java.awt.Graphics2D
d757 1
d776 10
a795 1
		
a799 1
		
a830 1
		
a834 1
		
a838 1
		
a842 1
		
d888 1
a888 1
				Console.WriteLine("TODO: Draw NetProducerImage");
a915 1
		
a919 1
		
d922 1
a922 1
		public override void drawPolygon(int[] param1, int[] param2, int param3)
d924 12
a935 1
		
d938 7
a944 1
		public override void drawPolyline(int[] param1, int[] param2, int param3)
d946 9
a954 1
		
d962 1
a962 1
			}		
d965 38
a1002 3
		public override void drawRoundRect(int param1, int param2, int param3, int param4, int param5, int param6)
		{
		
a1006 1
		
a1020 1
		
a1024 1
		
a1028 1
		
d1031 1
a1031 1
		public override void fillPolygon(java.awt.Polygon param)
d1033 10
a1042 1
		
d1045 1
a1045 1
		public override void fillPolygon(int[] param1, int[] param2, int param3)
d1047 9
a1055 1
		
d1066 1
a1066 1
		public override void fillRoundRect(int param1, int param2, int param3, int param4, int param5, int param6)
d1068 4
a1071 1
		
d1190 1
a1190 1
			java.awt.Rectangle r = param.getBounds();			
a1214 1
		
a1218 1
		
d1252 1
a1252 1
    
d1260 1
a1260 1
    
d1274 1
a1274 1
    
d1291 1
a1291 1
  
d1308 1
a1308 1
    
d1328 1
a1328 1
  
d1376 1
a1376 1
	class NetFontMetrics : java.awt.FontMetrics
d1379 1
d1388 1
a1388 1
			if(dpi == 0)
d1390 1
a1390 1
				using(Graphics g = NetToolkit.bogusForm.CreateGraphics())
d1392 4
a1395 1
					dpi = g.DpiY;
d1397 2
d1400 2
a1401 1
			return NetGraphics.NetFontFromJavaFont(getFont(), dpi);
d1406 1
a1406 4
			using(Font f = RealizeFont())
			{
				return f.Height;
			}
d1411 1
a1411 2
			// HACK we always return 1
			return 1;
d1433 1
a1433 5
			using(Font f = RealizeFont())
			{
				int ascent = f.FontFamily.GetCellAscent(f.Style);
				return (int)Math.Round(f.Size * ascent / f.FontFamily.GetEmHeight(f.Style));
			}
d1438 31
a1468 1
			using(Font f = RealizeFont())
d1470 15
a1484 2
				int descent = f.FontFamily.GetCellDescent(f.Style);
				return (int)Math.Round(f.Size * descent / f.FontFamily.GetEmHeight(f.Style));
d1488 3
a1490 1
		public override int stringWidth(string s)
d1492 1
a1492 2
			using(Font f = RealizeFont())
			using(Graphics g = NetToolkit.bogusForm.CreateGraphics())
d1494 1
a1494 1
				return (int)Math.Round(g.MeasureString(s, f).Width);
d1497 2
d2171 12
a2189 1

d2199 1
a2199 1
			return 0;
d2204 1
a2204 1
			return 0;
d2214 1
a2214 1
			return null;
d2219 1
a2219 1
			Console.WriteLine("NetBufferedImage: setHints");
d2224 29
a2252 1
			Console.WriteLine("NetBufferedImage: setPixels1");
d2255 1
a2255 1
		void java.awt.image.ImageConsumer.setPixels(int x, int y, int w, int h, ColorModel model, int[] pixels, int off, int scansize)
d2257 1
a2257 1
			Console.WriteLine("NetBufferedImage: setPixels2");
d2262 2
a2263 1
			Console.WriteLine("NetBufferedImage: setDimensions");
d2268 1
a2268 1
			Console.WriteLine("NetBufferedImage: imageComplete");
d2273 1
a2273 1
			Console.WriteLine("NetBufferedImage: setColorModel");
d2278 1
a2278 1
			Console.WriteLine("NetBufferedImage: setProperties");
d2473 1
a2473 1
		
d2484 1
d2489 1
d2494 1
a2538 1

d2745 1
d2750 1
d2755 1
d2770 1
a2770 1
  
d2901 1
d2906 1
d2911 1
d2916 1
d2937 1
d2942 1
d3060 72
@


1.24
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004, 2005 Jeroen Frijters
d148 1
@


1.23
log
@*** empty log message ***
@
text
@d1924 25
d2132 5
d2285 5
d2544 15
d2609 10
d2660 10
a2669 4
			Rectangle r = control.Bounds;
			component.GetType().InvokeMember("setBoundsCallback", BindingFlags.InvokeMethod | BindingFlags.Instance | BindingFlags.NonPublic, null, component, new object[] { r.X, r.Y, r.Width, r.Height });
			// HACK we somehow need to trigger a validate and I don't know how, so for now I'll use invokeLater
			java.awt.EventQueue.invokeLater(new ValidateHelper(component));
d2725 6
@


1.22
log
@*** empty log message ***
@
text
@d55 41
d101 1
a101 2
		internal static System.Collections.ArrayList nativeQueue = System.Collections.ArrayList.Synchronized(new System.Collections.ArrayList());
		private static java.awt.EventQueue eventQueue = new java.awt.EventQueue();
d239 1
a239 1
			return new NetFramePeer(target, (Form)CreateControl(typeof(Form)));
d244 1
a244 1
			return new NewCanvasPeer(target, (Control)CreateControl(typeof(Control)));
d249 1
a249 1
			return new NetPanelPeer(target, (ContainerControl)CreateControl(typeof(ContainerControl)));
d259 1
a259 1
			return new NetDialogPeer(target, (Form)CreateControl(typeof(Form)));
a486 36
		public override bool nativeQueueEmpty()
		{
			return nativeQueue.Count == 0;
		}

		public override void wakeNativeQueue()
		{
			// TODO if we're blocking in iterateNativeQueue() we should release that thread
		}

		public override void iterateNativeQueue(java.awt.EventQueue locked, bool block)
		{
			lock(nativeQueue)
			{
				if(nativeQueue.Count > 0)
				{
					locked.postEvent((java.awt.AWTEvent)nativeQueue[0]);
					nativeQueue.RemoveAt(0);
					return;
				}
			}
			if(block)
			{
				Monitor.Exit(locked);
				try
				{
					//Application.DoEvents();
					Thread.Sleep(100);
				}
				finally
				{
					Monitor.Enter(locked);
				}
			}
		}

d1386 13
a1398 4
			// TODO figure out if we need an update or a paint
			java.awt.Rectangle rect = new java.awt.Rectangle(e.ClipRectangle.X, e.ClipRectangle.Y, e.ClipRectangle.Width, e.ClipRectangle.Height);
			//postEvent(new java.awt.@@event.PaintEvent(component, java.awt.@@event.PaintEvent.UPDATE, rect));
			postEvent(new java.awt.@@event.PaintEvent(component, java.awt.@@event.PaintEvent.PAINT, rect));
d1585 1
a1585 2
			NetToolkit.nativeQueue.Add(evt);
			//getToolkit().getSystemEventQueue().postEvent(evt);
d1668 3
d1729 2
a1730 3
			Rectangle rect = new Rectangle(x, y, width, height);
			rect.Offset(offsetX, offsetY);
			control.Invoke(new SetRectangle(control.Invalidate), new object[] { rect });
d2583 15
d2602 2
a2603 1
			component.validate();
@


1.21
log
@*** empty log message ***
@
text
@d482 5
@


1.20
log
@*** empty log message ***
@
text
@d30 1
d62 1
a62 1
		private static volatile Form bogusForm;
d284 1
a284 1
			return new NetFontMetrics(font, NetGraphics.NetFontFromJavaFont(font, getScreenResolution()), null, null);
d536 1
a536 1
			throw new NotImplementedException();
d746 1
d757 1
d1031 1
a1031 1
			return new NetFontMetrics(f, NetFontFromJavaFont(f, g.DpiY), g, null);
d1036 1
a1036 1
			return new NetFontMetrics(font, netfont, g, null);
d1243 6
a1248 3
		private Font netFont;
		private Graphics g;
		private Control c;
d1250 1
a1250 1
		public NetFontMetrics(java.awt.Font f, Font netFont, Graphics g, Control c) : base(f)
d1252 8
a1259 3
			this.netFont = netFont;
			this.g = g;
			this.c = c;
d1264 4
a1267 1
			return netFont.Height;
d1295 5
a1299 2
			int ascent = netFont.FontFamily.GetCellAscent(netFont.Style);
			return (int)Math.Round(netFont.Size * ascent / netFont.FontFamily.GetEmHeight(netFont.Style));
d1304 5
a1308 2
			int descent = netFont.FontFamily.GetCellDescent(netFont.Style);
			return (int)Math.Round(netFont.Size * descent / netFont.FontFamily.GetEmHeight(netFont.Style));
d1313 2
a1314 1
			if(g != null)
d1316 1
a1316 15
				try
				{
					return (int)Math.Round(g.MeasureString(s, netFont).Width);
				}
				catch(ObjectDisposedException)
				{
					g = null;
				}
			}
			if(c != null)
			{
				using(Graphics g1 = c.CreateGraphics())
				{
					return (int)Math.Round(g1.MeasureString(s, netFont).Width);
				}
a1317 2
			// as a last resort, we make a lame guess
			return s.Length * getHeight() / 2;
d1614 1
a1614 6
			// HACK this is a very heavy weight way to determine DPI, it should be possible
			// to do this without creating a Graphics object
			using(Graphics g = control.CreateGraphics())
			{
				return new NetFontMetrics(f, NetGraphics.NetFontFromJavaFont(f, g.DpiY), null, control);
			}
d1624 3
a1626 1
			throw new NotImplementedException();
d2076 1
a2076 1
			throw new NotImplementedException();
a2565 1
			// TODO I have no clue what I should do here...
d2567 1
a2567 2
			component.setBounds(r.X, r.Y, r.Width, r.Height);
			component.invalidate();
a2568 1
			postEvent(new java.awt.@@event.ComponentEvent(component, java.awt.@@event.ComponentEvent.COMPONENT_RESIZED));
@


1.19
log
@*** empty log message ***
@
text
@d173 1
a173 1
			throw new NotImplementedException();
d193 1
a193 1
			throw new NotImplementedException();
d433 1
a433 1
			throw new NotImplementedException();
d483 56
d1322 3
d1330 1
d1387 4
d1402 30
d1434 2
a1435 3
			// TODO set all this stuff...
			long when = 0;
			int modifiers = 0;
d1437 1
d1439 1
a1439 1
			int keyLocation = 0;
d1445 2
a1446 3
			// TODO set all this stuff...
			long when = 0;
			int modifiers = 0;
d1448 1
d1450 1
a1450 1
			int keyLocation = 0;
d1456 3
a1458 4
			// TODO set all this stuff...
			long when = 0;
			int modifiers = 0;
			int keyCode = 0;
d1460 1
a1460 1
			int keyLocation = 0;
d1466 36
a1501 4
			// TODO set all this stuff...
			long when = 0;
			int modifiers = 0;
			postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_MOVED, when, modifiers, e.X, e.Y, 0, false));
d1506 12
a1517 4
			// TODO set all this stuff...
			long when = 0;
			int modifiers = 0;
			postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_PRESSED, when, modifiers, e.X, e.Y, e.Clicks, false));
d1522 36
a1557 6
			// TODO set all this stuff...
			long when = 0;
			int modifiers = 0;
			// TODO set popupTrigger
			postEvent(new java.awt.@@event.MouseEvent(component, java.awt.@@event.MouseEvent.MOUSE_RELEASED, when, modifiers, e.X, e.Y, e.Clicks, false));
			// TODO send MOUSE_CLICKED if the mouse didn't move more than whatever the threshold is 
d1649 12
a1660 1
					component.update(g);
a1666 4
			else
			{
				Console.WriteLine("NOTE: NetComponentPeer.handleEvent not implemented: " + e);
			}
d1762 27
d1845 1
a1845 1
			Console.WriteLine("NOTE: NetComponentPeer.setEventMask not implemented");
d2236 57
d2351 1
d2380 1
a2380 1
			throw new NotImplementedException();
d2385 2
a2386 1
			throw new NotImplementedException();
d2423 1
a2423 1
			throw new NotImplementedException();
d2427 1
a2427 1
			throw new NotImplementedException();
d2452 2
d2461 1
a2461 1
			throw new NotImplementedException();
d2466 1
a2466 2
			Console.WriteLine("NOTE: NetContainerPeer.getInsets not implemented");
			return new java.awt.Insets(0, 0, 0, 0);
a2470 1
			Console.WriteLine("NOTE: NetContainerPeer.beginValidate not implemented");
a2474 1
			Console.WriteLine("NOTE: NetContainerPeer.endValidate not implemented");
@


1.18
log
@*** empty log message ***
@
text
@d338 1
d347 1
a347 1
			return (checkImage(image, width, height, observer) & ALLBITS) != 0;
d356 1
a356 1
					observer.imageUpdate(image, ERROR, 0, 0, -1, -1);
d358 1
a358 1
				return ERROR;
d591 4
d600 4
d620 4
@


1.17
log
@*** empty log message ***
@
text
@d59 1
d376 1
a376 1
		public override java.awt.Image createImage(sbyte[] imagedata, int imageoffset, int imagelength)
d444 36
d509 1
a509 1
		public override sbyte getBaselineFor(java.awt.Font param1, char param2)
d700 1
a700 1
		public override void drawBytes(sbyte[] param1, int param2, int param3, int param4, int param5)
d1386 2
a1387 1
			getToolkit().getSystemEventQueue().postEvent(evt);
d1784 1
a1784 1
		public void setPixels(int x, int y, int w, int h, ColorModel model, sbyte[] pixels, int off, int scansize)
@


1.16
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002, 2004 Jeroen Frijters
d438 5
@


1.15
log
@*** empty log message ***
@
text
@d75 1
a75 1
				// HACK to make sure we can be aborted (Thread.Abort) we need to periodically
d336 6
d345 1
a345 1
			return (checkImage(image, width, height, observer) & 32) != 0;
d354 1
a354 1
					observer.imageUpdate(image, 64, 0, 0, -1, -1);
d356 1
a356 1
				return 64; // ERROR
d360 1
a360 1
				observer.imageUpdate(image, 1 + 2 + 16 + 32, 0, 0, image.getWidth(null), image.getHeight(null));
d362 1
a362 2
			// HACK we cannot use the constants defined in the interface from C#, so we hardcode the flags
			return 1 + 2 + 16 + 32; // WIDTH + HEIGHT + FRAMEBITS + ALLBITS
@


1.14
log
@*** empty log message ***
@
text
@d60 1
a60 1
		private static Form bogusForm;
d69 14
a82 12
			Form form = new Form();
			form.CreateControl();
			// HACK I have no idea why this line is necessary...
			IntPtr p = form.Handle;
			bogusForm = form;
			// HACK to make sure we can be aborted (Thread.Abort) we need to periodically
			// fire an event (because otherwise we'll be blocking in unmanaged code and
			// the Abort cannot be handled there).
			System.Windows.Forms.Timer t = new System.Windows.Forms.Timer();
			t.Interval = 100;
			t.Start();
			Application.Run();
d108 1
a108 1
				while(bogusForm == null)
@


1.13
log
@*** empty log message ***
@
text
@d74 6
@


1.12
log
@*** empty log message ***
@
text
@d236 2
d265 1
d268 2
a269 1
			throw new NotImplementedException();
d832 1
@


1.11
log
@*** empty log message ***
@
text
@d416 5
@


1.10
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2002 Jeroen Frijters
d209 1
a209 1
			throw new NotImplementedException();
d211 1
d295 17
a311 1
			throw new NotImplementedException();
d316 1
a316 1
			throw new NotImplementedException();
d318 1
d321 1
a321 1
			throw new NotImplementedException();
d350 6
a355 1
			throw new NotImplementedException();
d687 4
d922 5
d1592 1
a1592 1
		public VolatileImage createVolatileImage(int width, int height)
d1674 75
d1935 7
d1944 1
a1944 1
			throw new NotImplementedException();
d2293 23
@


1.9
log
@*** empty log message ***
@
text
@d49 8
d204 1
a204 1
			throw new NotImplementedException();
d206 1
d239 1
d242 1
a242 1
			throw new NotImplementedException();
d1164 8
a1171 1
				control.Parent = ((NetComponentPeer)parent.getPeer()).control;
@


1.8
log
@*** empty log message ***
@
text
@d49 1
a49 1
	public class NetToolkit : java.awt.Toolkit
d368 103
d1287 1
a1287 1
			throw new NotImplementedException();
d1297 7
a1303 1
			control.Parent = null;
d1393 1
a1393 1
			throw new NotImplementedException();
d1893 1
d1898 1
d1901 1
a1901 1
			throw new NotImplementedException();
d1917 1
@


1.7
log
@*** empty log message ***
@
text
@d87 2
a88 4
				if(bogusForm != null)
				{
					throw new InvalidOperationException();
				}
@


1.6
log
@*** empty log message ***
@
text
@d153 1
a153 1
			throw new NotImplementedException();
d729 8
a736 1
					fam = new FontFamily(f.getName());
d2047 83
@


1.5
log
@*** empty log message ***
@
text
@d715 1
@


1.4
log
@*** empty log message ***
@
text
@d427 1
d432 1
a432 1
		public NetGraphics(Graphics g, java.awt.Font font, bool disposable)
d441 1
d451 4
a454 2
			// TODO get the background color from somewhere
			g.FillRectangle(SystemBrushes.Window, x, y, width, height);
d477 1
a477 1
			NetGraphics newg = new NetGraphics(g, font, false);
d562 1
a562 1
			using(Pen p = new Pen(color))
d564 2
a565 2
				// HACK DrawLine doesn't appear to draw the last pixel, so for single pixel lines, we add one
				// TODO figure out if this applies to all lines
d568 5
a572 1
					x2++;
a573 1
				g.DrawLine(p, x1, y1, x2, y2);
d1088 3
d1135 26
d1213 1
a1213 1
			return new NetGraphics(control.CreateGraphics(), component.getFont(), true);
d1493 1
a1493 1
			return new NetGraphics(g, null, true);
d1991 1
a1991 1
			NetGraphics g = new NetGraphics(control.CreateGraphics(), component.getFont(), true);
@


1.3
log
@*** empty log message ***
@
text
@d273 1
a273 1
				using(System.IO.FileStream stream = new System.IO.FileStream(filename, System.IO.FileMode.Open))
d297 2
a298 4
		public override bool prepareImage(java.awt.Image image,
			int width,
			int height,
			java.awt.image.ImageObserver observer)
d300 2
a301 1
			throw new NotImplementedException();
d304 1
a304 4
		public override int checkImage(java.awt.Image image,
			int width,
			int height,
			java.awt.image.ImageObserver observer)
d308 4
d314 4
d326 2
a327 3
		public override java.awt.Image createImage(sbyte[] imagedata,
			int imageoffset,
			int imagelength)
d331 2
a332 3
		public override java.awt.PrintJob getPrintJob(java.awt.Frame frame,
			string jobtitle,
			Properties props)
d336 1
d341 1
d361 25
d470 6
a475 1
			return null;
d513 1
a513 1
		public override bool drawImage(java.awt.Image param1, int param2, int param3, int param4, int param5, int param6, int param7, int param8, int param9, java.awt.image.ImageObserver param10)
d515 10
d543 1
a543 1
		public override bool drawImage(java.awt.Image param1, int param2, int param3, java.awt.image.ImageObserver param4)
d545 8
d560 6
d1036 1
a1036 1
			if(parent != null)
d1132 1
a1132 1
			throw new NotImplementedException();
d1152 1
d1247 1
a1247 1
			throw new NotImplementedException();
d1348 2
a1349 4
			if(visible)
			{
				postEvent(new java.awt.@@event.ComponentEvent(component, java.awt.@@event.ComponentEvent.COMPONENT_SHOWN));
			}
d1433 1
a1433 1
		private Bitmap bitmap;
d1756 1
a1756 6
				string text = control.Text;
				if(text == "")
				{
					text = "W";
				}
				return new java.awt.Dimension((int)Math.Round(g.MeasureString(text, control.Font, -1, new StringFormat(StringFormatFlags.MeasureTrailingSpaces)).Width), ((TextBox)control).PreferredHeight);
@


1.2
log
@*** empty log message ***
@
text
@d40 1
d45 3
d54 1
d69 1
a69 1
		private static Control CreateControlImpl(Type type)
d101 35
d148 1
a148 1
			throw new NotImplementedException();
d188 1
a188 1
			throw new NotImplementedException();
d236 1
d239 8
a246 1
			throw new NotImplementedException();
d248 1
d253 1
d258 1
d261 1
a261 1
			throw new NotImplementedException();
d263 1
d268 1
d271 31
d304 566
a869 1
		public override java.awt.Image getImage(URL url)
d871 1
a871 1
			throw new NotImplementedException();
d873 2
a874 1
		public override java.awt.Image createImage(string filename)
a875 1
			throw new NotImplementedException();
d877 2
a878 1
		public override java.awt.Image createImage(URL url)
d880 1
a880 1
			throw new NotImplementedException();
d882 2
a883 4
		public override bool prepareImage(java.awt.Image image,
			int width,
			int height,
			java.awt.image.ImageObserver observer)
a884 1
			throw new NotImplementedException();
d886 9
a894 4
		public override int checkImage(java.awt.Image image,
			int width,
			int height,
			java.awt.image.ImageObserver observer)
d896 3
a898 1
			throw new NotImplementedException();
d900 2
a901 1
		public override java.awt.Image createImage(java.awt.image.ImageProducer producer)
d903 1
a903 1
			throw new NotImplementedException();
d905 2
a906 3
		public override java.awt.Image createImage(sbyte[] imagedata,
			int imageoffset,
			int imagelength)
d908 2
a909 1
			throw new NotImplementedException();
d911 2
a912 3
		public override java.awt.PrintJob getPrintJob(java.awt.Frame frame,
			string jobtitle,
			Properties props)
d914 2
a915 1
			throw new NotImplementedException();
d917 2
a918 1
		public override void beep()
d920 2
a921 1
			throw new NotImplementedException();
d923 2
a924 1
		public override java.awt.datatransfer.Clipboard getSystemClipboard()
d926 1
a926 1
			throw new NotImplementedException();
d929 1
a929 1
		protected override java.awt.EventQueue getSystemEventQueueImpl()
d931 2
a932 1
			return eventQueue;
d935 1
a935 1
		public override java.awt.dnd.peer.DragSourceContextPeer createDragSourceContextPeer(java.awt.dnd.DragGestureEvent dge)
d937 2
a938 1
			throw new NotImplementedException();
d941 1
a941 1
		public override Map mapInputMethodHighlight(java.awt.im.InputMethodHighlight highlight)
d943 20
a962 1
			throw new NotImplementedException();
d970 2
d981 20
a1002 1
			component.invalidate();
d1005 10
d1076 1
d1081 1
d1086 1
d1091 1
a1093 1
			throw new NotImplementedException();
d1095 1
d1100 1
d1105 1
d1108 6
a1113 1
			throw new NotImplementedException();
d1115 2
a1116 1
		public java.awt.Graphics getGraphics()
d1118 1
a1118 1
			throw new NotImplementedException();
d1120 1
d1125 1
d1128 1
a1128 1
			throw new NotImplementedException();
d1133 1
a1133 2
			Console.WriteLine("NOTE: NetComponentPeer.getPreferredSize not implemented");
			return new java.awt.Dimension(0, 0);
d1143 16
a1158 1
			Console.WriteLine("NOTE: NetComponentPeer.handleEvent not implemented");
d1160 1
d1165 1
d1170 1
d1173 1
a1173 1
			throw new NotImplementedException();
d1178 1
a1178 2
			Console.WriteLine("NOTE: NetComponentPeer.preferredSize not implemented");
			return new java.awt.Dimension(0, 0);
d1185 1
d1190 1
d1195 1
d1198 4
a1201 1
			throw new NotImplementedException();
d1203 1
d1206 6
a1211 1
			throw new NotImplementedException();
d1213 1
d1218 1
d1223 1
d1226 6
a1231 1
			throw new NotImplementedException();
d1241 1
a1241 1
			control.Invoke(new SetXYWH(setBoundsImpl), new object[] { x, y, width, height });
d1246 12
a1257 1
			throw new NotImplementedException();
d1272 2
a1273 1
			throw new NotImplementedException();
d1275 1
d1278 6
a1283 1
			throw new NotImplementedException();
d1289 4
d1304 1
d1307 1
a1307 1
			throw new NotImplementedException();
d1372 108
d1485 5
d1520 5
a1524 2
			// TODO get the size from somewhere...
			return new java.awt.Dimension(80, 15);
d1533 13
d1621 53
a1695 1
			TextBox b = (TextBox)control;
d1697 9
a1705 1
			return new java.awt.Dimension(200, b.PreferredHeight);
d1728 5
a1732 4
			((TextBox)control).ReadOnly = !((java.awt.TextArea)component).isEditable();
			((TextBox)control).WordWrap = false;
			((TextBox)control).ScrollBars = ScrollBars.Both;
			((TextBox)control).Multiline = true;
d1737 1
a1737 1
			((TextBox)control).Text = ((TextBox)control).Text.Insert(pos, text);
d1827 8
d1840 16
d1860 1
a1860 1
			throw new NotImplementedException();
d1865 1
a1865 1
			Console.WriteLine("NOTE: NetWindowPeer.toFront not implemented");
d1901 9
a1932 3
			// NOTE that we're not returning the "real" insets, but the result is equivalent (I think)
			// and it doesn't require me to remap the client coordinates
			Rectangle client = control.ClientRectangle;
d1934 6
a1939 1
			return new java.awt.Insets(0, 0, control.Height - client.Height, control.Width - client.Width);
d1941 1
@


1.1
log
@Initial revision
@
text
@d461 4
d531 56
d695 12
d832 12
d932 12
@


1.1.1.1
log
@no message
@
text
@@
