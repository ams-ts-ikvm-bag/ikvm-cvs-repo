head	1.115;
access;
symbols
	v8_1_5717_0:1.114
	v8_1:1.114.0.2
	v8_0_5449_1:1.110
	v8_0_5449_0:1.110
	v8_0:1.110.0.2
	v7_4_5196_0:1.107
	v7_4:1.107.0.2
	v7_3:1.104.0.2
	v7_2_4630_6:1.101
	v7_2_4630_5:1.101
	v7_2_4630_4:1.101
	v7_2_4630_3:1.101
	v7_2_4630_2:1.101
	v0_46_0_4:1.91
	v7_2_4630_1:1.101
	v7_2:1.101.0.2
	v7_1_4532_2:1.100
	v7_1_4532_1:1.100
	v7_1_4532_0:1.100
	v7_1:1.100.0.2
	v7_0_4335_3:1.92.2.1
	v7_0_4335_2:1.92.2.1
	v7_0_4335_1:1.92.2.1
	v0_46_0_2:1.91
	v7_0_4335_0:1.92
	v7_0:1.92.0.2
	v0_40_0_6:1.13
	v0_40_0_5:1.13
	v0_46_0_1:1.91
	v0_46_0_0:1.91
	v0_46:1.91.0.2
	v0_36_0_14:1.2
	v0_44_0_6:1.71
	v0_44_0_5:1.71
	v0_44_0_4:1.71
	v0_44_0_3:1.71
	v0_44_0_2:1.71
	v0_42_0_7:1.51
	v0_44_0_1:1.71
	v0_44_0_0:1.71
	v0_44:1.71.0.2
	v0_42_0_6:1.51
	v0_42_0_5:1.51
	v0_42_0_4:1.51
	v0_42_0_3:1.51
	v0_42_0_2:1.51
	v0_42_0_1:1.51
	v0_42_0_0:1.51
	v0_42:1.51.0.2
	v0_40_0_3:1.13
	v0_40_0_2:1.13
	v0_40_0_1:1.13
	v0_40_0_0:1.13
	v0_40:1.13.0.2
	v0_36_0_13:1.2
	v0_38_0_1:1.7
	v0_38_0_0:1.7
	v0_38:1.7.0.2
	v0_36_0_9:1.2
	v0_36_0_7:1.2
	v0_36_0_5:1.2
	v0_36_0_4:1.2
	v0_36_0_3:1.2
	v0_36_0_2:1.2
	v0_36_0_1:1.2
	v0_36_0_0:1.2
	v0_36:1.2.0.2;
locks; strict;
comment	@ * @;


1.115
date	2017.02.07.14.50.34;	author jfrijters;	state Exp;
branches;
next	1.114;

1.114
date	2015.06.09.09.28.37;	author jfrijters;	state Exp;
branches;
next	1.113;

1.113
date	2015.05.06.07.17.40;	author jfrijters;	state Exp;
branches;
next	1.112;

1.112
date	2015.04.16.14.02.10;	author jfrijters;	state Exp;
branches;
next	1.111;

1.111
date	2015.04.16.13.57.53;	author jfrijters;	state Exp;
branches;
next	1.110;

1.110
date	2014.11.17.16.47.17;	author jfrijters;	state Exp;
branches;
next	1.109;

1.109
date	2014.06.03.08.56.30;	author jfrijters;	state Exp;
branches;
next	1.108;

1.108
date	2014.05.19.12.43.29;	author jfrijters;	state Exp;
branches;
next	1.107;

1.107
date	2014.02.07.14.14.10;	author jfrijters;	state Exp;
branches;
next	1.106;

1.106
date	2013.05.03.07.53.47;	author jfrijters;	state Exp;
branches;
next	1.105;

1.105
date	2013.04.01.18.12.45;	author smallsql;	state Exp;
branches;
next	1.104;

1.104
date	2013.03.07.10.04.53;	author jfrijters;	state Exp;
branches;
next	1.103;

1.103
date	2013.02.16.15.14.49;	author smallsql;	state Exp;
branches;
next	1.102;

1.102
date	2013.02.13.13.33.26;	author smallsql;	state Exp;
branches;
next	1.101;

1.101
date	2012.08.29.21.19.36;	author smallsql;	state Exp;
branches;
next	1.100;

1.100
date	2012.05.22.15.23.58;	author jfrijters;	state Exp;
branches;
next	1.99;

1.99
date	2012.04.11.08.55.38;	author jfrijters;	state Exp;
branches;
next	1.98;

1.98
date	2012.03.19.20.06.05;	author smallsql;	state Exp;
branches;
next	1.97;

1.97
date	2012.03.10.22.26.15;	author smallsql;	state Exp;
branches;
next	1.96;

1.96
date	2012.03.01.15.01.40;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2012.02.03.21.28.52;	author smallsql;	state Exp;
branches;
next	1.94;

1.94
date	2012.02.03.20.28.36;	author smallsql;	state Exp;
branches;
next	1.93;

1.93
date	2011.11.28.08.21.26;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2011.07.28.13.32.44;	author jfrijters;	state Exp;
branches
	1.92.2.1;
next	1.91;

1.91
date	2011.02.22.20.44.19;	author smallsql;	state Exp;
branches;
next	1.90;

1.90
date	2011.01.25.11.10.47;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2011.01.23.11.20.38;	author smallsql;	state Exp;
branches;
next	1.88;

1.88
date	2010.12.27.21.16.43;	author smallsql;	state Exp;
branches;
next	1.87;

1.87
date	2010.12.27.10.36.00;	author smallsql;	state Exp;
branches;
next	1.86;

1.86
date	2010.12.19.15.04.30;	author smallsql;	state Exp;
branches;
next	1.85;

1.85
date	2010.12.17.22.08.15;	author smallsql;	state Exp;
branches;
next	1.84;

1.84
date	2010.12.15.14.27.20;	author smallsql;	state Exp;
branches;
next	1.83;

1.83
date	2010.12.10.14.43.31;	author smallsql;	state Exp;
branches;
next	1.82;

1.82
date	2010.12.01.06.49.35;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2010.11.16.15.59.27;	author smallsql;	state Exp;
branches;
next	1.80;

1.80
date	2010.11.01.12.52.00;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2010.10.28.16.03.22;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2010.10.28.11.15.21;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2010.10.28.08.25.12;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2010.10.28.08.19.38;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2010.10.21.11.18.33;	author smallsql;	state Exp;
branches;
next	1.74;

1.74
date	2010.09.24.08.23.22;	author smallsql;	state Exp;
branches;
next	1.73;

1.73
date	2010.08.05.12.08.26;	author smallsql;	state Exp;
branches;
next	1.72;

1.72
date	2010.08.05.10.16.00;	author smallsql;	state Exp;
branches;
next	1.71;

1.71
date	2010.06.18.07.21.09;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2009.12.09.00.45.55;	author natl;	state Exp;
branches;
next	1.69;

1.69
date	2009.11.25.21.26.26;	author smallsql;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.22.22.55.08;	author smallsql;	state Exp;
branches;
next	1.67;

1.67
date	2009.11.07.21.14.34;	author smallsql;	state Exp;
branches;
next	1.66;

1.66
date	2009.11.02.23.45.54;	author natl;	state Exp;
branches;
next	1.65;

1.65
date	2009.10.31.16.14.04;	author natl;	state Exp;
branches;
next	1.64;

1.64
date	2009.10.29.16.35.13;	author natl;	state Exp;
branches;
next	1.63;

1.63
date	2009.10.29.16.12.40;	author natl;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.28.01.04.30;	author natl;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.27.13.15.52;	author natl;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.25.16.22.49;	author natl;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.17.15.55.03;	author natl;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.17.15.29.24;	author natl;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.17.01.29.13;	author natl;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.16.16.11.08;	author natl;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.15.00.20.01;	author natl;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.14.23.56.52;	author natl;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.14.15.31.48;	author natl;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.14.13.44.28;	author natl;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.02.00.37.57;	author natl;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.02.00.05.19;	author natl;	state Exp;
branches;
next	1.49;

1.49
date	2009.09.30.16.22.15;	author natl;	state Exp;
branches;
next	1.48;

1.48
date	2009.09.20.09.39.33;	author smallsql;	state Exp;
branches;
next	1.47;

1.47
date	2009.09.19.14.51.45;	author smallsql;	state Exp;
branches;
next	1.46;

1.46
date	2009.09.07.09.16.39;	author natl;	state Exp;
branches;
next	1.45;

1.45
date	2009.09.07.01.24.31;	author natl;	state Exp;
branches;
next	1.44;

1.44
date	2009.08.28.06.47.16;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2009.08.26.23.47.09;	author natl;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.19.08.21.54;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2009.08.18.09.11.06;	author natl;	state Exp;
branches;
next	1.40;

1.40
date	2009.08.08.18.42.19;	author smallsql;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.02.19.34.13;	author smallsql;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.31.21.29.23;	author smallsql;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.29.17.38.42;	author smallsql;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.28.06.31.37;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.26.16.20.22;	author smallsql;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.26.14.28.47;	author smallsql;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.13.08.02.17;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.12.06.00.44;	author smallsql;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.02.18.06.09;	author smallsql;	state Exp;
branches;
next	1.30;

1.30
date	2009.06.22.17.48.19;	author smallsql;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.09.10.24.09;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.09.06.03.21;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.05.07.56.02;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.05.07.09.34;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.04.18.57.27;	author smallsql;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.01.16.08.52;	author smallsql;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.01.08.44.20;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2009.05.31.20.28.43;	author smallsql;	state Exp;
branches;
next	1.21;

1.21
date	2009.05.31.09.04.50;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2009.05.30.19.47.29;	author smallsql;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.22.21.08.24;	author smallsql;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.22.18.44.48;	author smallsql;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.16.16.34.40;	author smallsql;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.08.12.05.00;	author smallsql;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.03.20.17.02;	author smallsql;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.15.04.58.12;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.07.08.40.46;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.04.08.18.36;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.03.20.05.35;	author smallsql;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.07.14.52.20;	author smallsql;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.31.15.37.28;	author smallsql;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.30.10.28.10;	author smallsql;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.21.09.38.15;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.18.05.41.54;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.14.05.04.10;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.26.08.38.38;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.26.05.50.57;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.17.09.10.18;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.16.09.53.02;	author jfrijters;	state Exp;
branches;
next	;

1.92.2.1
date	2012.01.03.12.16.36;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.115
log
@Fix by Dmitry Firsakov <Dmitry.Firsakov@@exanebnpparibas.com>.
@
text
@/*
 * Copyright 1996-2007 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Sun designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Sun in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 */

/*
Copyright (C) 2002, 2004-2009 Jeroen Frijters
Copyright (C) 2006 Active Endpoints, Inc.
Copyright (C) 2006-2013 Volker Berlin (i-net software)
Copyright (C) 2010-2011 Karsten Heinrich (i-net software)

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
  claim that you wrote the original software. If you use this software
  in a product, an acknowledgment in the product documentation would be
  appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
  misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Jeroen Frijters
jeroen@@frijters.net 

*/

using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Windows.Forms;
using System.ComponentModel;
using System.Reflection;
using java.net;
using java.util;
using ikvm.awt.printing;
using ikvm.runtime;
using sun.awt;
using System.Runtime.InteropServices;
using System.Drawing.Drawing2D;

namespace ikvm.awt
{
    internal delegate TResult Func<TResult>();
    internal delegate void Action<T>(T t);

	class UndecoratedForm : Form
	{
	    private bool focusableWindow = true;
	    private bool alwaysOnTop;

		public UndecoratedForm()
		{
			setBorderStyle();
            SetStyle(ControlStyles.UserPaint | ControlStyles.ResizeRedraw | ControlStyles.SupportsTransparentBackColor, true);
		}

        protected virtual void setBorderStyle()
        {
            this.FormBorderStyle = FormBorderStyle.None;
            this.ShowInTaskbar = false;
        }

        internal void SetWindowState(bool focusableWindow, bool alwaysOnTop)
        {
            this.focusableWindow = focusableWindow;
            this.alwaysOnTop = alwaysOnTop;
        }

        protected override bool ShowWithoutActivation {
            // This work not like in Java. In Java it is not possible to click on a not focusable Window
            // But now the windows is not stealing the focus on showing
            get
            {
                return !focusableWindow;
            }
        }

	    private const int WS_EX_TOPMOST = 0x00000008;
        private const int WS_EX_NOACTIVATE = 0x08000000;
	    private const int WS_DISABLED = 0x08000000;

        protected override CreateParams CreateParams {
            get {
                CreateParams baseParams = base.CreateParams;
                int exStyle = baseParams.ExStyle;

                // This work not like in Java. In Java it is not possible to click on a not focusable Window
                // But now the windows is not stealing the focus on showing
                exStyle = focusableWindow ? exStyle & ~WS_EX_NOACTIVATE : exStyle | WS_EX_NOACTIVATE;
                
                // we need to set TOPMOST here because the property TopMost does not work with ShowWithoutActivation
                baseParams.ExStyle = alwaysOnTop ? exStyle | WS_EX_TOPMOST : exStyle & ~WS_EX_TOPMOST;

                // the Enabled on Forms has no effect. In Java a window beep if ot is disabled
                // the same effect have we with this flag
                baseParams.Style = Enabled ? baseParams.Style & ~WS_DISABLED : baseParams.Style | WS_DISABLED;
                return baseParams;
            }
        }

		private const int WM_MOUSEACTIVATE = 0x0021;
		private const int MA_NOACTIVATE = 0x0003;

		protected override void WndProc(ref Message m)
		{
			if (!focusableWindow && m.Msg == WM_MOUSEACTIVATE)
			{
				m.Result = (IntPtr)MA_NOACTIVATE;
				return;
			}
			base.WndProc(ref m);
		}

		protected override void OnPaintBackground(PaintEventArgs e)
		{
			NetComponentPeer peer = NetComponentPeer.FromControl(this);
			if (peer.eraseBackground)
			{
				base.OnPaintBackground(e);
			}
		}
	}

    class MyForm : UndecoratedForm
	{
        /// <summary>
        /// Original MaximizedBounds
        /// </summary>
        private Rectangle maxBounds;
        private bool maxBoundsSet;
        public java.awt.Insets peerInsets;

        /// <summary>
        /// Creates the native form
        /// </summary>
        /// <param name="peerInsets">the insets instance of the peer instance</param>
		public MyForm( java.awt.Insets peerInsets )
		{
            this.peerInsets = peerInsets;
		}

        protected override void setBorderStyle()
        {
            //nothing, default behaviour
        }

        public void setMaximizedBounds(java.awt.Rectangle rect)
        {
            if (rect == null)
            {
                // null means reset to the original system setting
                if (maxBoundsSet)
                {
                    SetMaximizedBoundsImpl(maxBounds);
                }
            }
            else
            {
                if (!maxBoundsSet)
                {
                    maxBounds = MaximizedBounds;
                    maxBoundsSet = true;
                }
                SetMaximizedBoundsImpl(J2C.ConvertRect(rect));
            }
        }

		private void SetMaximizedBoundsImpl(Rectangle rect)
		{
			NetToolkit.Invoke(delegate { MaximizedBounds = rect; });
		}
	}

	sealed class EventQueueSynchronizationContext : SynchronizationContext
	{
		public override SynchronizationContext CreateCopy()
		{
			return new EventQueueSynchronizationContext();
		}

		public override void Post(SendOrPostCallback d, object state)
		{
			java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate { d(state); }));
		}

		public override void Send(SendOrPostCallback d, object state)
		{
			java.awt.EventQueue.invokeAndWait(Delegates.toRunnable(delegate { d(state); }));
		}

		[System.Security.SecuritySafeCritical]
		internal static void Install()
		{
			SynchronizationContext.SetSynchronizationContext(new EventQueueSynchronizationContext());
		}
	}

	static class WinFormsMessageLoop
	{
		private static readonly object mylock = new object();
		private static Form theForm;

		private static Form GetForm()
		{
			lock (mylock)
			{
				if (theForm == null)
				{
					Thread thread = new Thread(MessageLoop);
					thread.SetApartmentState(ApartmentState.STA);
					thread.Name = "IKVM AWT WinForms Message Loop";
					thread.IsBackground = true;
					thread.Start();
					while (theForm == null && thread.IsAlive)
					{
						Thread.Sleep(1);
					}
				}
			}
			return theForm;
		}

		private static void MessageLoop()
		{
			using (Form form = new Form())
			{
				NetToolkit.CreateNative(form);
				theForm = form;
				Application.Run();
			}
		}

		internal static bool InvokeRequired
		{
			get { return GetForm().InvokeRequired; }
		}

		internal static object Invoke(Delegate method)
		{
			return GetForm().Invoke(method);
		}

		internal static object Invoke(Delegate method, params object[] args)
		{
			return GetForm().Invoke(method, args);
		}

		internal static IAsyncResult BeginInvoke(Delegate method)
		{
			return GetForm().BeginInvoke(method);
		}

		internal static IAsyncResult BeginInvoke(Delegate method, params object[] args)
		{
			return GetForm().BeginInvoke(method, args);
		}
	}

	public sealed class NetToolkit : sun.awt.SunToolkit, ikvm.awt.IkvmToolkit, sun.awt.KeyboardFocusManagerPeerProvider
    {
        private int resolution;
        private NetClipboard clipboard;
		private bool eventQueueSynchronizationContext;

		protected internal override java.awt.EventQueue getSystemEventQueueImpl()
		{
			java.awt.EventQueue eq = base.getSystemEventQueueImpl();
			if (!eventQueueSynchronizationContext)
			{
				InstallEventQueueSynchronizationContext(eq);
			}
			return eq;
		}

		private void InstallEventQueueSynchronizationContext(java.awt.EventQueue eq)
		{
			bool install;
			lock (this)
			{
				install = !eventQueueSynchronizationContext;
				eventQueueSynchronizationContext = true;
			}
			if (install)
			{
				eq.postEvent(new java.awt.@@event.InvocationEvent(this, Delegates.toRunnable(EventQueueSynchronizationContext.Install), null, true));
			}
		}

		internal static void CreateNative(Control control)
		{
			control.CreateControl();
			// HACK I have no idea why this line is necessary...
			IntPtr p = control.Handle;
			if (p == IntPtr.Zero)
			{
				// shut up compiler warning
			}
		}

        public NetToolkit()
        {
        }

        /// <summary>
        /// Run on a win 32 system
        /// </summary>
        /// <returns></returns>
        internal static bool isWin32()
        {
            return Environment.OSVersion.Platform == PlatformID.Win32NT || Environment.OSVersion.Platform == PlatformID.Win32Windows;
        }

        protected internal override void loadSystemColors(int[] systemColors)
        {
            // initialize all colors to purple to make the ones we might have missed stand out
            for (int i = 0; i < systemColors.Length; i++)
            {
                systemColors[i] = Color.Purple.ToArgb();
            }
            systemColors[java.awt.SystemColor.DESKTOP] = SystemColors.Desktop.ToArgb();
            systemColors[java.awt.SystemColor.ACTIVE_CAPTION] = SystemColors.ActiveCaption.ToArgb();
            systemColors[java.awt.SystemColor.ACTIVE_CAPTION_TEXT] = SystemColors.ActiveCaptionText.ToArgb();
            systemColors[java.awt.SystemColor.ACTIVE_CAPTION_BORDER] = SystemColors.ActiveBorder.ToArgb();
            systemColors[java.awt.SystemColor.INACTIVE_CAPTION] = SystemColors.InactiveCaption.ToArgb();
            systemColors[java.awt.SystemColor.INACTIVE_CAPTION_TEXT] = SystemColors.InactiveCaptionText.ToArgb();
            systemColors[java.awt.SystemColor.INACTIVE_CAPTION_BORDER] = SystemColors.InactiveBorder.ToArgb();
            systemColors[java.awt.SystemColor.WINDOW] = SystemColors.Window.ToArgb();
            systemColors[java.awt.SystemColor.WINDOW_BORDER] = SystemColors.WindowFrame.ToArgb();
            systemColors[java.awt.SystemColor.WINDOW_TEXT] = SystemColors.WindowText.ToArgb();
            systemColors[java.awt.SystemColor.MENU] = SystemColors.Menu.ToArgb();
            systemColors[java.awt.SystemColor.MENU_TEXT] = SystemColors.MenuText.ToArgb();
            systemColors[java.awt.SystemColor.TEXT] = SystemColors.Window.ToArgb();
            systemColors[java.awt.SystemColor.TEXT_TEXT] = SystemColors.WindowText.ToArgb();
            systemColors[java.awt.SystemColor.TEXT_HIGHLIGHT] = SystemColors.Highlight.ToArgb();
            systemColors[java.awt.SystemColor.TEXT_HIGHLIGHT_TEXT] = SystemColors.HighlightText.ToArgb();
            systemColors[java.awt.SystemColor.TEXT_INACTIVE_TEXT] = SystemColors.GrayText.ToArgb();
            systemColors[java.awt.SystemColor.CONTROL] = SystemColors.Control.ToArgb();
            systemColors[java.awt.SystemColor.CONTROL_TEXT] = SystemColors.ControlText.ToArgb();
            systemColors[java.awt.SystemColor.CONTROL_HIGHLIGHT] = SystemColors.ControlLight.ToArgb();
            systemColors[java.awt.SystemColor.CONTROL_LT_HIGHLIGHT] = SystemColors.ControlLightLight.ToArgb();
            systemColors[java.awt.SystemColor.CONTROL_SHADOW] = SystemColors.ControlDark.ToArgb();
            systemColors[java.awt.SystemColor.CONTROL_DK_SHADOW] = SystemColors.ControlDarkDark.ToArgb();
            systemColors[java.awt.SystemColor.SCROLLBAR] = SystemColors.ScrollBar.ToArgb();
            systemColors[java.awt.SystemColor.INFO] = SystemColors.Info.ToArgb();
            systemColors[java.awt.SystemColor.INFO_TEXT] = SystemColors.InfoText.ToArgb();
        }

        public override java.awt.peer.ButtonPeer createButton(java.awt.Button target)
        {
			java.awt.peer.ButtonPeer peer = Invoke<NetButtonPeer>(delegate { return new NetButtonPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

		// MONOBUG mcs refuses to override these two methods, so we disable them when building with mcs
		// (since AWT isn't supported anyway)
#if !__MonoCS__
        public override java.awt.peer.CanvasPeer createCanvas(java.awt.Canvas target)
        {
            java.awt.peer.CanvasPeer peer = Invoke<NetCanvasPeer>(delegate { return new NetCanvasPeer(target); });
            targetCreatedPeer(target, peer);
            return peer;
        }

        public override java.awt.peer.PanelPeer createPanel(java.awt.Panel target)
        {
            java.awt.peer.PanelPeer peer = Invoke<NetPanelPeer>(delegate { return new NetPanelPeer(target); });
            targetCreatedPeer(target, peer);
            return peer;
        }
#endif

        public override java.awt.peer.TextFieldPeer createTextField(java.awt.TextField target)
        {
			java.awt.peer.TextFieldPeer peer = Invoke<NetTextFieldPeer>(delegate { return new NetTextFieldPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.LabelPeer createLabel(java.awt.Label target)
        {
			java.awt.peer.LabelPeer peer = Invoke<NetLabelPeer>(delegate { return new NetLabelPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.ListPeer createList(java.awt.List target)
        {
			java.awt.peer.ListPeer peer = Invoke<NetListPeer>(delegate { return new NetListPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.CheckboxPeer createCheckbox(java.awt.Checkbox target)
        {
			java.awt.peer.CheckboxPeer peer = Invoke<NetCheckboxPeer>(delegate { return new NetCheckboxPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.ScrollbarPeer createScrollbar(java.awt.Scrollbar target)
        {
			java.awt.peer.ScrollbarPeer peer = Invoke<NetScrollbarPeer>(delegate { return new NetScrollbarPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.ScrollPanePeer createScrollPane(java.awt.ScrollPane target)
        {
			java.awt.peer.ScrollPanePeer peer = Invoke<NetScrollPanePeer>(delegate { return new NetScrollPanePeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.TextAreaPeer createTextArea(java.awt.TextArea target)
        {
			java.awt.peer.TextAreaPeer peer = Invoke<NetTextAreaPeer>(delegate { return new NetTextAreaPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.ChoicePeer createChoice(java.awt.Choice target)
        {
			java.awt.peer.ChoicePeer peer = Invoke<NetChoicePeer>(delegate { return new NetChoicePeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.FramePeer createFrame(java.awt.Frame target)
        {
			bool isFocusableWindow = target.isFocusableWindow();
			bool isAlwaysOnTop = target.isAlwaysOnTop();
            java.awt.peer.FramePeer peer = Invoke<NetFramePeer>(delegate { return new NetFramePeer(target, isFocusableWindow, isAlwaysOnTop); });
            targetCreatedPeer(target, peer);
            return peer;
        }

        public override java.awt.peer.WindowPeer createWindow(java.awt.Window target)
        {
			bool isFocusableWindow = target.isFocusableWindow();
			bool isAlwaysOnTop = target.isAlwaysOnTop();
			java.awt.peer.WindowPeer peer = Invoke<NetWindowPeer>(delegate { return new NetWindowPeer(target, isFocusableWindow, isAlwaysOnTop); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.DialogPeer createDialog(java.awt.Dialog target)
        {
			bool isFocusableWindow = target.isFocusableWindow();
			bool isAlwaysOnTop = target.isAlwaysOnTop();
			java.awt.peer.DialogPeer peer = Invoke<NetDialogPeer>(delegate { return new NetDialogPeer(target, isFocusableWindow, isAlwaysOnTop); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.MenuBarPeer createMenuBar(java.awt.MenuBar target)
        {
			// we need to force peer creation of the sub menus here, because we're
			// transitioning to the UI thread to do the rest of the work and there
			// we cannot acquire the AWT tree lock (because it is owned by the current thread)
			for (int i = 0; i < target.getMenuCount(); i++)
			{
				target.getMenu(i).addNotify();
			}
			java.awt.Menu help = target.getHelpMenu();
			if (help != null)
			{
				help.addNotify();
			}
			java.awt.peer.MenuBarPeer peer = Invoke<NetMenuBarPeer>(delegate { return new NetMenuBarPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
        }

        public override java.awt.peer.MenuPeer createMenu(java.awt.Menu target)
        {
			for (int i = 0; i < target.getItemCount(); i++)
			{
				target.getItem(i).addNotify();
			}
			java.awt.peer.MenuPeer peer = Invoke<NetMenuPeer>(delegate { return new NetMenuPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
        }

        public override java.awt.peer.PopupMenuPeer createPopupMenu(java.awt.PopupMenu target)
        {
			for (int i = 0; i < target.getItemCount(); i++)
			{
				target.getItem(i).addNotify();
			}
			java.awt.peer.PopupMenuPeer peer = Invoke<NetPopupMenuPeer>(delegate { return new NetPopupMenuPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
        }

        public override java.awt.peer.MenuItemPeer createMenuItem(java.awt.MenuItem target)
        {
			java.awt.peer.MenuItemPeer peer = Invoke<NetMenuItemPeer>(delegate { return new NetMenuItemPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}

        public override java.awt.peer.FileDialogPeer createFileDialog(java.awt.FileDialog target)
        {
			bool isFocusableWindow = target.isFocusableWindow();
			bool isAlwaysOnTop = target.isAlwaysOnTop();
			java.awt.peer.FileDialogPeer peer = Invoke<NetFileDialogPeer>(delegate { return new NetFileDialogPeer(target, isFocusableWindow, isAlwaysOnTop); });
            targetCreatedPeer(target, peer);
            return peer;
        }

        public override java.awt.peer.CheckboxMenuItemPeer createCheckboxMenuItem(java.awt.CheckboxMenuItem target)
        {
			return new NetCheckboxMenuItemPeer(target);
		}

        public override java.awt.peer.FontPeer getFontPeer(string name, int style)
        {
            throw new NotImplementedException();
        }

        public override java.awt.peer.KeyboardFocusManagerPeer getKeyboardFocusManagerPeer()
        {
            return new NetKeyboardFocusManagerPeer();
        }

        public override java.awt.Dimension getScreenSize()
        {
            return new java.awt.Dimension(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height);
        }

        public override int getScreenResolution()
        {
            if (resolution == 0)
            {
                using (Form form = new Form())
                using (Graphics g = form.CreateGraphics())
                {
                    resolution = (int)Math.Round(g.DpiY);
                }
            }
            return resolution;
        }

        public override java.awt.image.ColorModel getColorModel()
        {
            //we return the default ColorModel because this produce the fewest problems with convertions
            return java.awt.image.ColorModel.getRGBdefault();
        }

        public override void sync()
        {
        }

        public override java.awt.Image getImage(string filename)
        {
            try
            {
                filename = new java.io.File(filename).getPath(); //convert a Java file name to .NET filename (slahes, backslasches, etc)
                using (System.IO.FileStream stream = new System.IO.FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    return new java.awt.image.BufferedImage(new Bitmap(Image.FromStream(stream)));
                }
            }
            catch (Exception)
            {
                return new NoImage(new sun.awt.image.FileImageSource(filename));
            }
        }

        public override java.awt.Image getImage(URL url)
        {
            // TODO extremely lame...
            System.IO.MemoryStream mem = new System.IO.MemoryStream();
            java.io.InputStream inS = url.openStream();
            int b;
            while ((b = inS.read()) >= 0)
            {
                mem.WriteByte((byte)b);
            }
            try
            {
                mem.Position = 0;
                return new java.awt.image.BufferedImage(new Bitmap(Image.FromStream(mem)));
            }
            catch
            {
                return new NoImage(new sun.awt.image.URLImageSource(url));
            }
        }

        public override java.awt.Image createImage(string filename)
        {
            return getImage(filename);
        }

        public override java.awt.Image createImage(URL url)
        {
            return getImage(url);
        }

        public override java.awt.Image createImage(byte[] imagedata, int imageoffset, int imagelength)
        {
            try
            {
                return new java.awt.image.BufferedImage(new Bitmap(new MemoryStream(imagedata, imageoffset, imagelength, false)));
            }
            catch (Exception)
            {
                return new NoImage(new sun.awt.image.ByteArrayImageSource(imagedata, imageoffset, imagelength));
            }
        }

        public override java.awt.PrintJob getPrintJob(java.awt.Frame frame, string jobtitle, java.util.Properties props)
        {
            throw new NotImplementedException();
        }

        public override void beep()
        {
            Console.Beep();
        }

        public override java.awt.datatransfer.Clipboard getSystemClipboard()
        {
            lock(this)
            {
                if (clipboard==null)
                {
                    clipboard = new NetClipboard();
                }
            }
            return clipboard;
        }

        public override java.awt.dnd.DragGestureRecognizer createDragGestureRecognizer(java.lang.Class abstractRecognizerClass, java.awt.dnd.DragSource ds, java.awt.Component c, int srcActions, java.awt.dnd.DragGestureListener dgl)
        {
            java.lang.Class clazz = typeof(java.awt.dnd.MouseDragGestureRecognizer);
            if (abstractRecognizerClass == clazz)
                return new NetMouseDragGestureRecognizer(ds, c, srcActions, dgl);
            else
                return null;
        }

        public override java.awt.dnd.peer.DragSourceContextPeer createDragSourceContextPeer(java.awt.dnd.DragGestureEvent dge)
        {
            return NetDragSourceContextPeer.createDragSourceContextPeer(dge);
        }

        public override Map mapInputMethodHighlight(java.awt.im.InputMethodHighlight highlight)
        {
            throw new NotImplementedException();
        }

#if false
		protected override java.awt.peer.LightweightPeer createComponent(java.awt.Component target)
		{
			if(target is java.awt.Container)
			{
				return new NetLightweightContainerPeer((java.awt.Container)target);
			}
			return new NetLightweightComponentPeer(target);
		}
#endif

/*        public override java.awt.Font createFont(int format, java.io.InputStream stream)
        {
            throw new NotImplementedException();
        }

        public override gnu.java.awt.peer.ClasspathFontPeer getClasspathFontPeer(string name, java.util.Map attrs)
        {
            return new NetFontPeer(name, attrs);
        }

        public override java.awt.GraphicsEnvironment getLocalGraphicsEnvironment()
        {
            return new NetGraphicsEnvironment();
        }

        public override RobotPeer createRobot(java.awt.GraphicsDevice screen)
        {
            if (Environment.OSVersion.Platform == PlatformID.Win32NT || Environment.OSVersion.Platform == PlatformID.Win32Windows)
            {
                return new WindowsRobot(screen);
            }
            throw new java.awt.AWTException("Robot not supported for this OS");
        }

        public override gnu.java.awt.peer.EmbeddedWindowPeer createEmbeddedWindow(gnu.java.awt.EmbeddedWindow ew)
        {
            throw new NotImplementedException();
        }
*/
        protected internal override java.awt.peer.DesktopPeer createDesktopPeer(java.awt.Desktop target)
        {
            return new NetDesktopPeer();
        }

        public override java.awt.Dimension getBestCursorSize(int preferredWidth, int preferredHeight)
        {
            // TODO
            return new java.awt.Dimension(preferredWidth, preferredHeight);
        }

        public override java.awt.Cursor createCustomCursor(java.awt.Image cursor, java.awt.Point hotSpot, string name)
        {
            return new NetCustomCursor(cursor, hotSpot, name);
        }

        private object getRegistry(string subKey, string valueName)
        {
			using (Microsoft.Win32.RegistryKey key = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(subKey, false))
			{
				return key == null ? null : key.GetValue(valueName);
			}
        }

        protected internal override void initializeDesktopProperties()
        {
            //copied from WToolkit.java
            desktopProperties.put("DnD.Autoscroll.initialDelay", java.lang.Integer.valueOf(50));
            desktopProperties.put("DnD.Autoscroll.interval", java.lang.Integer.valueOf(50));

            try
            {
                if (isWin32())
                {
                    desktopProperties.put("Shell.shellFolderManager", "sun.awt.shell.Win32ShellFolderManager2" );
                    object themeActive = getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager", "ThemeActive");
//                    string dllName = (string)getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager", "DllName");
//                    string sizeName = (string)getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager", "SizeName");
//                    string colorName = (string)getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager", "ColorName");
                    desktopProperties.put("win.xpstyle.themeActive", java.lang.Boolean.valueOf("1".Equals(themeActive)));
//                    desktopProperties.put("win.xpstyle.dllName", dllName);
//                    desktopProperties.put("win.xpstyle.sizeName", sizeName);
//                    desktopProperties.put("win.xpstyle.colorName", colorName);
                }
            }
            catch (java.lang.ClassNotFoundException)
            {
            }
        }

        protected internal override Object lazilyLoadDesktopProperty(String name)
        {
            switch (name)
            {
                case "win.defaultGUI.font":
                    return C2J.ConvertFont(Control.DefaultFont);
                case "win.highContrast.on":
                    return java.lang.Boolean.valueOf(SystemInformation.HighContrast);
                default:
                    return null;
            }
        }

        protected internal override java.awt.peer.MouseInfoPeer getMouseInfoPeer() {
            return new NetMouseInfoPeer();
        }

        /*===============================
         * Implementations of interface IkvmToolkit
         */

        /// <summary>
        /// Get a helper class for implementing the print API
        /// </summary>
        /// <returns></returns>
        public sun.print.PrintPeer getPrintPeer()
        {
            if (isWin32())
            {
                return new Win32PrintPeer();
            }
            else
            {
                return new LinuxPrintPeer();
            }
        }

        /// <summary>
        /// Create a outline from the given text and font parameter
        /// </summary>
        /// <param name="javaFont">the font</param>
        /// <param name="frc">font render context</param>
        /// <param name="text">the text</param>
        /// <param name="x">x - position</param>
        /// <param name="y">y - position</param>
        /// <returns></returns>
        public java.awt.Shape outline(java.awt.Font javaFont, java.awt.font.FontRenderContext frc, string text, float x, float y) {
            GraphicsPath path = new GraphicsPath(FillMode.Winding);
            Font netFont = javaFont.getNetFont();
            FontFamily family = netFont.FontFamily;
            FontStyle style = netFont.Style;
            float factor = netFont.Size / family.GetEmHeight(style);
            float ascent = family.GetCellAscent(style) * factor;
            y -= ascent;

            StringFormat format = new StringFormat(StringFormat.GenericTypographic);
            format.FormatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap | StringFormatFlags.FitBlackBox;
            format.Trimming = StringTrimming.None;

            path.AddString(text, family, (int)style, netFont.Size, new PointF(x, y), format);
            return C2J.ConvertShape(path);
        }

        /*===============================
         * Implementations of interface SunToolkit
         */

        public override bool isModalExclusionTypeSupported(java.awt.Dialog.ModalExclusionType dmet)
        {
            return false;
        }

        public override bool isModalityTypeSupported(java.awt.Dialog.ModalityType type)
        {
            return type.ordinal() == java.awt.Dialog.ModalityType.MODELESS.ordinal() ||
                type.ordinal() == java.awt.Dialog.ModalityType.APPLICATION_MODAL.ordinal();
        }

        public override java.awt.Window createInputMethodWindow(string __p1, sun.awt.im.InputContext __p2)
        {
            throw new NotImplementedException();
        }

        public override java.awt.peer.RobotPeer createRobot(java.awt.Robot r, java.awt.GraphicsDevice screen)
        {
            if (isWin32())
            {
                return new WindowsRobot(screen);
            }
            throw new java.awt.AWTException("Robot not supported for this OS");
        }

        public override java.awt.peer.SystemTrayPeer createSystemTray(java.awt.SystemTray target)
        {
            NetSystemTrayPeer peer = new NetSystemTrayPeer(target);
            targetCreatedPeer(target, peer);
            return peer;
        }

        public override java.awt.peer.TrayIconPeer createTrayIcon(java.awt.TrayIcon target)
        {
            NetTrayIconPeer peer = new NetTrayIconPeer(target);
            targetCreatedPeer(target, peer);
            return peer;
        }

        public override java.awt.im.spi.InputMethodDescriptor getInputMethodAdapterDescriptor()
        {
            return null;
        }

        protected internal override int getScreenHeight()
        {
            return Screen.PrimaryScreen.Bounds.Height;
        }

        protected internal override int getScreenWidth()
        {
            return Screen.PrimaryScreen.Bounds.Width;
        }

		public override java.awt.Insets getScreenInsets(java.awt.GraphicsConfiguration gc)
		{
			NetGraphicsConfiguration ngc = gc as NetGraphicsConfiguration;
			if (ngc != null)
			{
				Rectangle rectWorkingArea = ngc.screen.WorkingArea;
				Rectangle rectBounds = ngc.screen.Bounds;
				return new java.awt.Insets(
					rectWorkingArea.Top - rectBounds.Top,
					rectWorkingArea.Left - rectBounds.Left,
					rectBounds.Bottom - rectWorkingArea.Bottom,
					rectBounds.Right - rectWorkingArea.Right);
			}
			else
			{
				return base.getScreenInsets(gc);
			}
		}

        public override void grab(java.awt.Window window)
        {
            NetWindowPeer peer = (NetWindowPeer)window.getPeer();
            if (peer != null)
            {
                peer.Grab();
            }
        }

        public override bool isDesktopSupported()
        {
            return true;
        }

        public override bool isTraySupported()
        {
            return true;
        }

        public override bool isFrameStateSupported(int state)
        {
            switch (state)
            {
                case java.awt.Frame.NORMAL:
                case java.awt.Frame.ICONIFIED:
                case java.awt.Frame.MAXIMIZED_BOTH:
                    return true;
                default:
                    return false;
            }
        }
        
        protected internal override bool syncNativeQueue(long l)
        {
            throw new NotImplementedException();
        }

        public override void ungrab(java.awt.Window window)
        {
            NetWindowPeer peer = (NetWindowPeer)window.getPeer();
            if (peer != null)
            {
                peer.Ungrab(false);
            }
        }

		internal new static object targetToPeer(object target)
		{
			return SunToolkit.targetToPeer(target);
		}

        internal new static void targetDisposedPeer(object target, object peer)
        {
            SunToolkit.targetDisposedPeer(target, peer);
        }

		internal static void BeginInvoke(MethodInvoker del)
        {
            if (WinFormsMessageLoop.InvokeRequired)
            {
                WinFormsMessageLoop.BeginInvoke(del);
            }
            else
            {
                del();
            }
        }

        internal static void BeginInvoke<T>(Action<T> del, T t)
        {
            if (WinFormsMessageLoop.InvokeRequired)
            {
                WinFormsMessageLoop.BeginInvoke(del, t);
            }
            else
            {
                del(t);
            }
        }
        internal static void Invoke<T>(Action<T> del, T t)
        {
            if (WinFormsMessageLoop.InvokeRequired)
            {
                WinFormsMessageLoop.Invoke(del, t);
            }
            else
            {
                del(t);
            }
        }

        internal static TResult Invoke<TResult>(Func<TResult> del)
        {
            if (WinFormsMessageLoop.InvokeRequired)
            {
                return (TResult)WinFormsMessageLoop.Invoke(del);
            }
            else
            {
                return del();
            }
        }

        internal static void Invoke(MethodInvoker del)
        {
            if (WinFormsMessageLoop.InvokeRequired)
            {
                WinFormsMessageLoop.Invoke(del);
            }
            else
            {
                del();
            }
        }

		public override bool areExtraMouseButtonsEnabled()
		{
			return true;
		}

		public override java.awt.peer.FramePeer createLightweightFrame(sun.awt.LightweightFrame lf)
		{
			throw new NotImplementedException();
		}

		public override sun.awt.datatransfer.DataTransferer getDataTransferer()
		{
			return NetDataTransferer.getInstanceImpl();
		}
	}

	sealed class NetMenuBarPeer : java.awt.peer.MenuBarPeer
	{
		internal readonly MainMenu menu = new MainMenu();

		internal NetMenuBarPeer(java.awt.MenuBar target)
		{
			menu.Tag = target;
			for (int i = 0; i < target.getMenuCount(); i++)
			{
				addMenu(target.getMenu(i));
			}
		}

		public void addHelpMenu(java.awt.Menu m)
		{
			addMenu(m);
		}

		public void addMenu(java.awt.Menu m)
		{
			if (m.getPeer() == null)
			{
				m.addNotify();
			}
			NetToolkit.Invoke(delegate { menu.MenuItems.Add(((NetMenuPeer)m.getPeer()).menu); });
		}

		public void delMenu(int i)
		{
			NetToolkit.Invoke(delegate { menu.MenuItems.RemoveAt(i); });
		}

		public void dispose()
		{
			NetToolkit.Invoke(delegate { menu.Dispose(); });
		}

		public void setFont(java.awt.Font f)
		{
			throw new NotImplementedException();
		}
	}

	sealed class NetMenuPeer : java.awt.peer.MenuPeer
	{
		internal readonly MenuItem menu = new MenuItem();

		internal NetMenuPeer(java.awt.Menu target)
		{
			menu.Tag = target;
			menu.Text = target.getLabel();
			for (int i = 0; i < target.getItemCount(); i++)
			{
				addItem(target.getItem(i));
			}
		}

		public void addItem(java.awt.MenuItem item)
		{
			if (item.getPeer() == null)
			{
				item.addNotify();
			}
			if (item.getPeer() is NetMenuItemPeer)
			{
				NetToolkit.Invoke(delegate { menu.MenuItems.Add(((NetMenuItemPeer)item.getPeer()).menuitem); });
			}
			else
			{
				NetToolkit.Invoke(delegate { menu.MenuItems.Add(((NetMenuPeer)item.getPeer()).menu); });
			}
		}

		public void addSeparator()
		{
			NetToolkit.Invoke(delegate { menu.MenuItems.Add(new MenuItem("-")); });
		}

		public void delItem(int i)
		{
			NetToolkit.Invoke(delegate { menu.MenuItems.RemoveAt(i); });
		}

		public void dispose()
		{
			NetToolkit.Invoke(delegate { menu.Dispose(); });
		}

		public void setFont(java.awt.Font f)
		{
			throw new NotImplementedException();
		}

		public void disable()
		{
			setEnabled(false);
		}

		public void enable()
		{
			setEnabled(true);
		}

		public void setEnabled(bool b)
		{
			NetToolkit.Invoke(delegate { menu.Enabled = b; });
		}

		public void setLabel(string str)
		{
			NetToolkit.Invoke(delegate { menu.Text = str; });
		}
	}

	class NetMenuItemPeer : java.awt.peer.MenuItemPeer
	{
		protected readonly java.awt.MenuItem target;
		internal readonly MenuItem menuitem = new MenuItem();

		internal NetMenuItemPeer(java.awt.MenuItem target)
		{
			this.target = target;
			setEnabled(target.isEnabled());
			setLabel(target.getLabel());
			menuitem.Click += OnClick;
		}

		protected virtual void OnClick(object sender, EventArgs e)
		{
			long when = java.lang.System.currentTimeMillis();
			int modifiers = NetComponentPeer.GetModifiers(Control.ModifierKeys);
			NetToolkit.executeOnEventHandlerThread(target, Delegates.toRunnable(delegate
			{
				NetToolkit.postEvent(NetToolkit.targetToAppContext(target), new java.awt.@@event.ActionEvent(target, java.awt.@@event.ActionEvent.ACTION_PERFORMED,
						  target.getActionCommand(), when, modifiers));
			}));
		}

		public void disable()
		{
			setEnabled(false);
		}

		public void enable()
		{
			setEnabled(true);
		}

		public void setEnabled(bool b)
		{
			NetToolkit.Invoke(delegate { menuitem.Enabled = b; });
		}

		public void setLabel(string str)
		{
			NetToolkit.Invoke(delegate { menuitem.Text = str; });
		}

		public void dispose()
		{
			NetToolkit.Invoke(delegate { menuitem.Dispose(); });
		}

		public void setFont(java.awt.Font f)
		{
		}
	}

	sealed class NetCheckboxMenuItemPeer : NetMenuItemPeer, java.awt.peer.CheckboxMenuItemPeer
	{
		internal NetCheckboxMenuItemPeer(java.awt.CheckboxMenuItem target)
			: base(target)
		{
			setState(target.getState());
		}

		protected override void OnClick(object sender, EventArgs e)
		{
			java.awt.CheckboxMenuItem target = (java.awt.CheckboxMenuItem)this.target;
			NetToolkit.executeOnEventHandlerThread(target, Delegates.toRunnable(delegate
			{
				bool state = !menuitem.Checked;
				target.setState(state);
				NetToolkit.postEvent(NetToolkit.targetToAppContext(target), new java.awt.@@event.ItemEvent(target, java.awt.@@event.ItemEvent.ITEM_STATE_CHANGED,
										target.getLabel(), (state)
										  ? java.awt.@@event.ItemEvent.SELECTED
										  : java.awt.@@event.ItemEvent.DESELECTED));
			}));
		}

		public void setState(bool b)
		{
			NetToolkit.Invoke(delegate { menuitem.Checked = b; });
		}
	}

    internal class NetDragSourceContextPeer : sun.awt.dnd.SunDragSourceContextPeer
    {
        private static readonly NetDragSourceContextPeer theInstance = new NetDragSourceContextPeer(null);
        private bool dragStart = false;

        private NetDragSourceContextPeer(java.awt.dnd.DragGestureEvent dge) : base(dge)
        {
        }

        public static NetDragSourceContextPeer createDragSourceContextPeer(java.awt.dnd.DragGestureEvent dge)
        {
            theInstance.setTrigger(dge);
            return theInstance;
        }

        public override void startSecondaryEventLoop()
        {
            //NetToolkit.startSecondaryEventLoop();
        }
        
        public override void quitSecondaryEventLoop()
        {
            //NetToolkit.quitSecondaryEventLoop();
        }

        internal static new java.awt.dnd.DragSourceContext getDragSourceContext()
        {
            return theInstance.getDragSourceContextCore();
        }

        internal static NetDragSourceContextPeer getInstance()
        {
            return theInstance;
        }

        internal java.awt.dnd.DragSourceContext getDragSourceContextCore()
        {
            return base.getDragSourceContext();
        }

        internal new void dragDropFinished(bool success, int operations, int x, int y)
        {
            if (dragStart)
            {
			    java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate {
                        base.dragDropFinished(success, operations, x, y);
			    }));
            }
            dragStart = false;
        }

        protected internal override void startDrag(java.awt.datatransfer.Transferable trans, long[] formats, Map formatMap)
        {
            dragStart = true;

            createDragSource(getTrigger().getComponent(),
                                               trans,
                                               getTrigger().getTriggerEvent(),
                                               getTrigger().getSourceAsDragGestureRecognizer().getSourceActions(),
                                               formats,
                                               formatMap);
            NetDropTargetContextPeer.setCurrentJVMLocalSourceTransferable(trans);
        }

        private long createDragSource(java.awt.Component component,
                                 java.awt.datatransfer.Transferable transferable,
                                 java.awt.@@event.InputEvent nativeTrigger,
                                 int actions,
                                 long[] formats,
                                 Map formatMap)
        {
            java.awt.Component controlOwner = component;
            while (controlOwner!=null && (controlOwner.getPeer() == null || controlOwner.getPeer() is sun.awt.NullComponentPeer))
            {
                controlOwner = controlOwner.getParent();
            }
            if (controlOwner != null)
            {
                NetComponentPeer peer = controlOwner.getPeer() as NetComponentPeer;
                if (peer != null)
                {
                    peer.performedDragDropEffects = DragDropEffects.None;
                    Control control = peer.Control;
                    if (control != null)
                    {
                        java.awt.dnd.DragSource dragSource = getTrigger().getDragSource();
                        IDataObject data = NetDataTransferer.getInstanceImpl().getDataObject(transferable, 
                            NetDataTransferer.adaptFlavorMap(dragSource.getFlavorMap()));
                        NetToolkit.BeginInvoke(delegate
                                                   {
                                                       DragDropEffects effects = control.DoDragDrop(data, DragDropEffects.All);
                                                       if (effects == DragDropEffects.None && peer.performedDragDropEffects!=DragDropEffects.None) 
                                                       {
                                                           effects = peer.performedDragDropEffects;
                                                       }
                                                       peer.performedDragDropEffects = DragDropEffects.None;
                                                       dragDropFinished(effects != DragDropEffects.None,
                                                                        NetComponentPeer.getAction(effects),
                                                                        Control.MousePosition.X, Control.MousePosition.Y);
                                                   });
                    }
                }
            }
            return 0;
        }

        protected internal override void setNativeCursor(long nativeCtxt, java.awt.Cursor c, int cType)
        {
            
        }
    }

    internal class NetDropTargetContextPeer : sun.awt.dnd.SunDropTargetContextPeer
    {
        private IDataObject data;

        internal static NetDropTargetContextPeer getNetDropTargetContextPeer()
        {
            return new NetDropTargetContextPeer();
        }

        internal int handleEnterMessage(java.awt.Component component,
                                      int x, int y,
                                      int dropAction,
                                      int actions,
                                      long[] formats,
                                      long nativeCtxt)
        {
            return postDropTargetEvent(component, x, y, dropAction, actions,
                                       formats, nativeCtxt,
                                       sun.awt.dnd.SunDropTargetEvent.MOUSE_ENTERED,
                                       sun.awt.dnd.SunDropTargetContextPeer.DISPATCH_SYNC);
        }

        internal void handleExitMessage(java.awt.Component component,
                                   long nativeCtxt)
        {
            postDropTargetEvent(component, 0, 0, java.awt.dnd.DnDConstants.ACTION_NONE,
                                java.awt.dnd.DnDConstants.ACTION_NONE, null, nativeCtxt,
                                sun.awt.dnd.SunDropTargetEvent.MOUSE_EXITED,
                                sun.awt.dnd.SunDropTargetContextPeer.DISPATCH_SYNC);
        }

        internal int handleMotionMessage(java.awt.Component component,
                                    int x, int y,
                                    int dropAction,
                                    int actions, long[] formats,
                                    long nativeCtxt)
        {
            return postDropTargetEvent(component, x, y, dropAction, actions,
                                       formats, nativeCtxt,
                                       sun.awt.dnd.SunDropTargetEvent.MOUSE_DRAGGED,
                                       sun.awt.dnd.SunDropTargetContextPeer.DISPATCH_SYNC);
        }

        internal void handleDropMessage(java.awt.Component component,
                               int x, int y,
                               int dropAction, int actions,
                                long[] formats,
                                long nativeCtxt, IDataObject data)
        {
            this.data = data;
            postDropTargetEvent(component, x, y, dropAction, actions,
                                formats, nativeCtxt,
                                sun.awt.dnd.SunDropTargetEvent.MOUSE_DROPPED,
                                !sun.awt.dnd.SunDropTargetContextPeer.DISPATCH_SYNC);
        }

        internal new int postDropTargetEvent(java.awt.Component component,
                                      int x, int y,
                                      int dropAction,
                                      int actions,
                                      long[] formats,
                                      long nativeCtxt,
                                      int eventID,
                                      bool dispatchType)
        {
            NetComponentPeer peer = (NetComponentPeer)component.getPeer();
            Control control = peer.Control;
            Point screenPt = new Point(x, y);
            Point clientPt = control.PointToClient(screenPt);
            return base.postDropTargetEvent(component, clientPt.X, clientPt.Y,
                                     dropAction, actions, formats, nativeCtxt, eventID, dispatchType);
        }

        protected internal override void doDropDone(bool success, int dropAction, bool isLocal)
        {
            // Don't do anything as .NET framework already handle the message pump
        }

        public override bool isDataFlavorSupported(java.awt.datatransfer.DataFlavor df)
        {
            if (isTransferableJVMLocal())
                return base.isDataFlavorSupported(df);
            return base.isDataFlavorSupported(df);
        }

        public override object getTransferData(java.awt.datatransfer.DataFlavor df)
        {
            if (isTransferableJVMLocal())
                return base.getTransferData(df);
            return new NetClipboardTransferable(data).getTransferData(df);
        }

        protected internal override object getNativeData(long l)
        {
            throw new NotImplementedException();
        }
    }

    internal class NetMouseDragGestureRecognizer : java.awt.dnd.MouseDragGestureRecognizer
    {
        protected static int motionThreshold;

        protected static readonly int ButtonMask = java.awt.@@event.InputEvent.BUTTON1_DOWN_MASK |
                                                   java.awt.@@event.InputEvent.BUTTON2_DOWN_MASK |
                                                   java.awt.@@event.InputEvent.BUTTON3_DOWN_MASK;

        public NetMouseDragGestureRecognizer(java.awt.dnd.DragSource source, java.awt.Component component1, int actions,
                                             java.awt.dnd.DragGestureListener listener) :
                                                 base(source, component1, actions, listener)
        {
        }

        protected int mapDragOperationFromModifiers(java.awt.@@event.MouseEvent e)
        {
            int mods = e.getModifiersEx();
            int btns = mods & ButtonMask;

            // Prohibit multi-button drags.
            if (!(btns == java.awt.@@event.InputEvent.BUTTON1_DOWN_MASK ||
                  btns == java.awt.@@event.InputEvent.BUTTON2_DOWN_MASK ||
                  btns == java.awt.@@event.InputEvent.BUTTON3_DOWN_MASK))
            {
                return java.awt.dnd.DnDConstants.ACTION_NONE;
            }

            return
                sun.awt.dnd.SunDragSourceContextPeer.convertModifiersToDropAction(mods,
                                                                      getSourceActions());
        }

        public override void mouseClicked(java.awt.@@event.MouseEvent e)
        {
            // do nothing
        }

        public override void mousePressed(java.awt.@@event.MouseEvent e)
        {
            events.clear();

            if (mapDragOperationFromModifiers(e) != java.awt.dnd.DnDConstants.ACTION_NONE)
            {
                try
                {
                    motionThreshold = java.awt.dnd.DragSource.getDragThreshold();
                }
                catch 
                {
                    motionThreshold = 5;
                }
                appendEvent(e);
            }
        }

        public override void mouseReleased(java.awt.@@event.MouseEvent e)
        {
            events.clear();
        }

        public override void mouseEntered(java.awt.@@event.MouseEvent e)
        {
            events.clear();
        }

        public override void mouseExited(java.awt.@@event.MouseEvent e)
        {
            if (!events.isEmpty())
            { // gesture pending
                int dragAction = mapDragOperationFromModifiers(e);

                if (dragAction == java.awt.dnd.DnDConstants.ACTION_NONE)
                {
                    events.clear();
                }
            }
        }

        public override void mouseDragged(java.awt.@@event.MouseEvent e)
        {
            if (!events.isEmpty())
            { // gesture pending
                int dop = mapDragOperationFromModifiers(e);

                if (dop == java.awt.dnd.DnDConstants.ACTION_NONE)
                {
                    return;
                }

                java.awt.@@event.MouseEvent trigger = (java.awt.@@event.MouseEvent)events.get(0);


                java.awt.Point origin = trigger.getPoint();
                java.awt.Point current = e.getPoint();

                int dx = java.lang.Math.abs(origin.x - current.x);
                int dy = java.lang.Math.abs(origin.y - current.y);

                if (dx > motionThreshold || dy > motionThreshold)
                {
                    fireDragGestureRecognized(dop, ((java.awt.@@event.MouseEvent)getTriggerEvent()).getPoint());
                }
                else
                    appendEvent(e);
            }
        }

    }

    class NetInputMethodDescriptor : java.awt.im.spi.InputMethodDescriptor
    {
        public java.awt.im.spi.InputMethod createInputMethod()
        {
            throw new NotImplementedException();
        }

        public Locale[] getAvailableLocales()
        {
            // TODO Feature with .NET 3.0 available
            //IEnumerable languages = System.Windows.Input.InputLanguageManager.AvailableInputLanguages;
            // as a hack we return the default locale
            return new Locale[]{Locale.getDefault()};
        }

        public string getInputMethodDisplayName(Locale inputLocale, Locale displayLanguage)
        {
            // copied from WInputMethodDescriptor

            // We ignore the input locale.
            // When displaying for the default locale, rely on the localized AWT properties;
            // for any other locale, fall back to English.
            String name = "System Input Methods";
            if (Locale.getDefault().equals(displayLanguage))
            {
                name = java.awt.Toolkit.getProperty("AWT.HostInputMethodDisplayName", name);
            }
            return name;
        }

        public java.awt.Image getInputMethodIcon(Locale l)
        {
            //WInputMethodDescriptor return also ever null
            return null;
        }

        public bool hasDynamicLocaleList()
        {
            // Java return also true
            return true;
        }
    }

	class NetCustomCursor : java.awt.Cursor
	{
		private Cursor cursor;
		public Cursor Cursor
		{
			get { return cursor; }
		}

		internal NetCustomCursor(java.awt.Image cursorIm, java.awt.Point hotSpot, String name) // throws IndexOutOfBoundsException
			: base(name)
		{
			java.awt.Toolkit toolkit = java.awt.Toolkit.getDefaultToolkit();

			// Make sure image is fully loaded.
			java.awt.Component c = new java.awt.Canvas(); // for its imageUpdate method
			java.awt.MediaTracker tracker = new java.awt.MediaTracker(c);
			tracker.addImage(cursorIm, 0);
			try
			{
				tracker.waitForAll();
			}
			catch (java.lang.InterruptedException)
			{
			}
			int width = cursorIm.getWidth(c);
			int height = cursorIm.getHeight(c);

			// Fix for bug 4212593 The Toolkit.createCustomCursor does not
			//                     check absence of the image of cursor
			// If the image is invalid, the cursor will be hidden (made completely
			// transparent). In this case, getBestCursorSize() will adjust negative w and h,
			// but we need to set the hotspot inside the image here.
			if (tracker.isErrorAny() || width < 0 || height < 0)
			{
				hotSpot.x = hotSpot.y = 0;
			}

			// Scale image to nearest supported size.
			java.awt.Dimension nativeSize = toolkit.getBestCursorSize(width, height);
			if (nativeSize.width != width || nativeSize.height != height)
			{
				cursorIm = cursorIm.getScaledInstance(nativeSize.width,
												  nativeSize.height,
												  java.awt.Image.SCALE_DEFAULT);
				width = nativeSize.width;
				height = nativeSize.height;
			}

			// Verify that the hotspot is within cursor bounds.
			if (hotSpot.x >= width || hotSpot.y >= height || hotSpot.x < 0 || hotSpot.y < 0)
			{
				throw new ArgumentException("invalid hotSpot");
			}

            Bitmap bitmap = J2C.ConvertImage(cursorIm);
			IntPtr hIcon = bitmap.GetHicon();
			cursor = new Cursor(hIcon);
		}
	}

	sealed class NetLightweightComponentPeer : NetComponentPeer<java.awt.Component, Control>, java.awt.peer.LightweightPeer
	{
		public NetLightweightComponentPeer(java.awt.Component target)
			: base(target)
		{
		}

		protected override Control CreateControl()
		{
			throw new NotImplementedException();
		}
	}

    sealed class NetLightweightContainerPeer : NetContainerPeer<java.awt.Container, ContainerControl>, java.awt.peer.LightweightPeer
    {
        public NetLightweightContainerPeer(java.awt.Container target)
            : base(target)
        {
        }
    }

	abstract class NetComponentPeer : java.awt.peer.ComponentPeer
	{
		internal bool eraseBackground = true;

		public abstract void applyShape(sun.java2d.pipe.Region r);
		public abstract bool canDetermineObscurity();
		public abstract int checkImage(java.awt.Image i1, int i2, int i3, java.awt.image.ImageObserver io);
		public abstract void coalescePaintEvent(java.awt.@@event.PaintEvent pe);
		public abstract void createBuffers(int i, java.awt.BufferCapabilities bc);
		public abstract java.awt.Image createImage(int i1, int i2);
		public abstract java.awt.Image createImage(java.awt.image.ImageProducer ip);
		public abstract java.awt.image.VolatileImage createVolatileImage(int i1, int i2);
		public abstract void destroyBuffers();
		public abstract void disable();
		public abstract void dispose();
		public abstract void enable();
		public abstract void flip(java.awt.BufferCapabilities.FlipContents bcfc);
		public abstract java.awt.Image getBackBuffer();
		public abstract java.awt.Rectangle getBounds();
		public abstract java.awt.image.ColorModel getColorModel();
		public abstract java.awt.FontMetrics getFontMetrics(java.awt.Font f);
		public abstract java.awt.Graphics getGraphics();
		public abstract java.awt.GraphicsConfiguration getGraphicsConfiguration();
		public abstract java.awt.Point getLocationOnScreen();
		public abstract java.awt.Dimension getMinimumSize();
		public abstract java.awt.Dimension getPreferredSize();
		public abstract java.awt.Toolkit getToolkit();
		public abstract void handleEvent(java.awt.AWTEvent awte);
		public abstract bool handlesWheelScrolling();
		public abstract void hide();
		public abstract bool isFocusable();
		public abstract bool isObscured();
		public abstract bool isReparentSupported();
		public abstract void layout();
		public abstract java.awt.Dimension minimumSize();
		public abstract void paint(java.awt.Graphics g);
		public abstract java.awt.Dimension preferredSize();
		public abstract bool prepareImage(java.awt.Image i1, int i2, int i3, java.awt.image.ImageObserver io);
		public abstract void print(java.awt.Graphics g);
		public abstract void repaint(long l, int i1, int i2, int i3, int i4);
		public abstract void reparent(java.awt.peer.ContainerPeer cp);
		public abstract bool requestFocus(java.awt.Component c, bool b1, bool b2, long l, CausedFocusEvent.Cause cfec);
		public abstract void reshape(int i1, int i2, int i3, int i4);
		public abstract void setBackground(java.awt.Color c);
		public abstract void setBounds(int i1, int i2, int i3, int i4, int i5);
		public abstract void setEnabled(bool b);
		public abstract void setFont(java.awt.Font f);
		public abstract void setForeground(java.awt.Color c);
		public abstract void setVisible(bool b);
		public abstract void show();
		public abstract void updateCursorImmediately();
		public abstract void flip(int x1, int y1, int x2, int y2, java.awt.BufferCapabilities.FlipContents flipAction);
		public abstract void setZOrder(java.awt.peer.ComponentPeer above);
        public abstract bool updateGraphicsData(java.awt.GraphicsConfiguration gc);

		internal DragDropEffects performedDragDropEffects = DragDropEffects.None;

		internal abstract Control Control { get; }
		internal abstract java.awt.Component Target { get; }

        internal abstract int getInsetsLeft();
		internal abstract int getInsetsTop();

		internal static int getAction(DragDropEffects effects)
		{
			int actions = java.awt.dnd.DnDConstants.ACTION_NONE;
			switch (effects)
			{
				case DragDropEffects.None:
					actions = java.awt.dnd.DnDConstants.ACTION_NONE;
					break;
				case DragDropEffects.Copy:
					actions = java.awt.dnd.DnDConstants.ACTION_COPY;
					break;
				case DragDropEffects.Move:
					actions = java.awt.dnd.DnDConstants.ACTION_MOVE;
					break;
				case DragDropEffects.Move | DragDropEffects.Copy:
					actions = java.awt.dnd.DnDConstants.ACTION_COPY_OR_MOVE;
					break;
				case DragDropEffects.Link:
					actions = java.awt.dnd.DnDConstants.ACTION_LINK;
					break;
			}
			return actions;
		}

		internal static int GetMouseEventModifiers(MouseEventArgs ev)
		{
			int modifiers = GetModifiers(Control.ModifierKeys);
			//Which button was pressed or released, because it can only one that it is a switch
			MouseButtons button = ev.Button;
			switch (button)
			{
				case MouseButtons.Left:
					modifiers |= java.awt.@@event.InputEvent.BUTTON1_MASK;
					break;
				case MouseButtons.Middle:
					modifiers |= java.awt.@@event.InputEvent.BUTTON2_MASK;
					break;
				case MouseButtons.Right:
					modifiers |= java.awt.@@event.InputEvent.BUTTON3_MASK;
					break;
			}
			return modifiers;
		}

		internal static int GetModifiers(Keys keys)
		{
			int modifiers = 0;
			if ((keys & Keys.Shift) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.SHIFT_DOWN_MASK;
			}
            switch (keys & (Keys.Control | Keys.Alt))
            {
                case Keys.Control:
                    modifiers |= java.awt.@@event.InputEvent.CTRL_DOWN_MASK;
                    break;
                case Keys.Alt:
                    modifiers |= java.awt.@@event.InputEvent.ALT_DOWN_MASK;
                    break;
                case Keys.Control | Keys.Alt:
                    modifiers |= java.awt.@@event.InputEvent.ALT_GRAPH_DOWN_MASK;
                    break;
            }
			if ((Control.MouseButtons & MouseButtons.Left) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.BUTTON1_DOWN_MASK;
			}
			if ((Control.MouseButtons & MouseButtons.Middle) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.BUTTON2_DOWN_MASK;
			}
			if ((Control.MouseButtons & MouseButtons.Right) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.BUTTON3_DOWN_MASK;
			}
			return modifiers;
		}

		internal static int GetButton(MouseEventArgs e)
		{
			if ((e.Button & MouseButtons.Left) != 0)
			{
				return java.awt.@@event.MouseEvent.BUTTON1;
			}
			else if ((e.Button & MouseButtons.Middle) != 0)
			{
				return java.awt.@@event.MouseEvent.BUTTON2;
			}
			else if ((e.Button & MouseButtons.Right) != 0)
			{
				return java.awt.@@event.MouseEvent.BUTTON3;
			}
			else
			{
				return java.awt.@@event.MouseEvent.NOBUTTON;
			}
		}

		internal static NetComponentPeer FromControl(Control control)
		{
			return (NetComponentPeer)control.Tag;
		}
	}

    abstract class NetComponentPeer<T, C> : NetComponentPeer
		where T : java.awt.Component
		where C : Control
	{
		protected static readonly java.awt.Font defaultFont = new java.awt.Font(java.awt.Font.DIALOG, java.awt.Font.PLAIN, 12);
		internal readonly T target;
		internal readonly C control;
        private bool isMouseClick;
        private bool isDoubleClick;
        private bool isPopupMenu;
		private int oldWidth = -1;
		private int oldHeight = -1;
		private bool sm_suppressFocusAndActivation;
		//private bool m_callbacksEnabled;
		//private int m_validationNestCount;
		private int serialNum = 0;
		private bool isLayouting = false;
		private bool paintPending = false;
		private RepaintArea paintArea;
		private java.awt.Font font;
		private java.awt.Color foreground;
		private java.awt.Color background;
	    private volatile bool disposed;
        private NetDropTargetContextPeer dropTargetPeer;

		internal override Control Control
		{
			get { return control; }
		}

		internal override java.awt.Component Target
		{
			get { return target; }
		}

		public NetComponentPeer(T target)
		{
			this.target = target;
			this.paintArea = new RepaintArea();
			// A window has an owner, but it does NOT have a container. 
			// Component getNativeContainer() was changed in 8.2 so it returns null for Window
			// We have to use getParent() instead
			//java.awt.Container parent = SunToolkit.getNativeContainer(target);
			java.awt.Component parent = SunToolkit.getHeavyweightComponent(target.getParent());
			NetComponentPeer parentPeer = (NetComponentPeer)NetToolkit.targetToPeer(parent);
			control = Create(parentPeer);
			// fix for 5088782: check if window object is created successfully
			//checkCreation();
			//this.winGraphicsConfig = (NetGraphicsConfiguration)getGraphicsConfiguration();
			/*
			this.surfaceData =
				winGraphicsConfig.createSurfaceData(this, numBackBuffers);
			 */
			initialize();
			start();  // Initialize enable/disable state, turn on callbacks
		}

		protected virtual void initialize()
		{
			if (target.isVisible())
			{
				show();  // the wnd starts hidden
			}
			java.awt.Color fg = target.getForeground();
			if (fg != null)
			{
				setForeground(fg);
			}
			// Set background color in C++, to avoid inheriting a parent's color.
			java.awt.Font f = target.getFont();
			if (f != null)
			{
				setFont(f);
			}
			if (!target.isEnabled())
			{
				disable();
			}
			java.awt.Rectangle r = target.getBounds();
            setBounds(r.x, r.y, r.width, r.height, java.awt.peer.ComponentPeer.__Fields.SET_BOUNDS);

			// this is from initialize() in WCanvasPeer.java
			eraseBackground = !SunToolkit.getSunAwtNoerasebackground();
			if (!PaintEventDispatcher.getPaintEventDispatcher().shouldDoNativeBackgroundErase(target))
			{
				eraseBackground = false;
			}
		}

		void start()
		{
            NetToolkit.BeginInvoke(delegate
            {
                hookEvents();
                // JDK native code also disables the window here, but since that is already done in initialize(),
                // I don't see the point
                EnableCallbacks(true);
                control.Invalidate();
                control.Update();
            });
		}

		void EnableCallbacks(bool enabled)
		{
			//m_callbacksEnabled = enabled;
		}

		private C Create(NetComponentPeer parent)
		{
			C control = CreateControl();
			control.Tag = this;
			if (parent != null)
			{
				Form form = control as Form;
				if (form != null)
				{
					form.Owner = parent.Control.FindForm();
				}
				else
				{
					control.Parent = parent.Control;
				}
			}
			NetToolkit.CreateNative(control);
			return control;
		}

		protected abstract C CreateControl();

	    void pShow()
		{
            NetToolkit.BeginInvoke(delegate { control.Visible = true; });
		}

		void Enable(bool enable)
		{
			sm_suppressFocusAndActivation = true;
			control.Enabled = enable;
			sm_suppressFocusAndActivation = false;
		}

		internal virtual void hookEvents()
		{
			// TODO we really only should hook these events when they are needed...
			control.KeyDown += new KeyEventHandler(OnKeyDown);
			control.KeyUp += new KeyEventHandler(OnKeyUp);
			control.KeyPress += new KeyPressEventHandler(OnKeyPress);
			control.MouseMove += new MouseEventHandler(OnMouseMove);
			control.MouseDown += new MouseEventHandler(OnMouseDown);
            control.MouseWheel += new MouseEventHandler(OnMouseWheel);
			control.Click += new EventHandler(OnClick);
			control.DoubleClick += new EventHandler(OnDoubleClick);
			control.MouseUp += new MouseEventHandler(OnMouseUp);
			control.MouseEnter += new EventHandler(OnMouseEnter);
			control.MouseLeave += new EventHandler(OnMouseLeave);
			control.GotFocus += new EventHandler(OnGotFocus);
			control.LostFocus += new EventHandler(OnLostFocus);
			//control.Leave += new EventHandler(OnBoundsChanged);
			control.Paint += new PaintEventHandler(OnPaint);
			control.ContextMenu = new ContextMenu();
			control.ContextMenu.Popup += new EventHandler(OnPopupMenu);
		    control.AllowDrop = true;
		    control.DragDrop += new DragEventHandler(OnDragDrop);
            control.DragOver += new DragEventHandler(OnDragOver);
            control.DragLeave += new EventHandler(OnDragLeave);
		    control.DragEnter += new DragEventHandler(OnDragEnter);
            control.QueryContinueDrag += new QueryContinueDragEventHandler(OnQueryContinueDrag);
		}

        internal virtual void unhookEvents()
        {
            control.KeyDown -= new KeyEventHandler(OnKeyDown);
            control.KeyUp -= new KeyEventHandler(OnKeyUp);
            control.KeyPress -= new KeyPressEventHandler(OnKeyPress);
            control.MouseMove -= new MouseEventHandler(OnMouseMove);
            control.MouseDown -= new MouseEventHandler(OnMouseDown);
            control.MouseWheel -= new MouseEventHandler(OnMouseWheel);
            control.Click -= new EventHandler(OnClick);
            control.DoubleClick -= new EventHandler(OnDoubleClick);
            control.MouseUp -= new MouseEventHandler(OnMouseUp);
            control.MouseEnter -= new EventHandler(OnMouseEnter);
            control.MouseLeave -= new EventHandler(OnMouseLeave);
            control.GotFocus -= new EventHandler(OnGotFocus);
            control.LostFocus -= new EventHandler(OnLostFocus);
            //control.Leave -= new EventHandler(OnBoundsChanged);
            control.Paint -= new PaintEventHandler(OnPaint);
            control.DragDrop -= new DragEventHandler(OnDragDrop);
            control.DragOver -= new DragEventHandler(OnDragOver);
            control.DragLeave -= new EventHandler(OnDragLeave);
            control.DragEnter -= new DragEventHandler(OnDragEnter);
            if (control.ContextMenu != null)
                control.ContextMenu.Popup -= new EventHandler(OnPopupMenu);
        }

		protected void SendEvent(java.awt.AWTEvent evt)
		{
			postEvent(evt);
		}

        /// <summary>
        /// Get the left insets of the .NET Window.
        /// In .NET the coordinate of a window start on the most left, top point with 0,0
        /// In Java the most left, top point with 0,0 is in the detail area of the window.
        /// In all not Windows Component this return ever 0.
        /// </summary>
        /// <returns></returns>
		internal override int getInsetsLeft()
        {
            return 0;
        }

        /// <summary>
        /// Get the top insets of the .NET Window.
        /// In .NET the coordinate of a window start on the most left, top point with 0,0
        /// In Java the most left, top point with 0,0 is in the detail area of the window.
        /// In all not Windows Component this return ever 0.
        /// </summary>
        /// <returns></returns>
		internal override int getInsetsTop()
        {
            return 0;
        }


        /// <summary>
        /// .NET calculates the offset relative to the detail area.
        /// Java uses the top left point of a window.
        /// That means we must compensate the coordinate of a component
        /// if the parent is a window, frame or dialog.
        /// </summary>
        /// <returns>The offset of the details area in the parent</returns>
        private Point getParentOffset()
        {
            if (!(target is java.awt.Window))
            {
                java.awt.Container parent = target.getParent();
                if (parent != null)
                {
                    NetComponentPeer peer = parent.getPeer() as NetComponentPeer;
                    if (peer != null)
                    {
						return new Point(peer.getInsetsLeft(), peer.getInsetsTop());
                    }
                }
            }
            return new Point();
        }

        private void OnPaint(object sender, PaintEventArgs e)
		{
			//CheckFontSmoothingSettings(GetHWnd());
			/* Set draw state */
			//SetDrawState(GetDrawState() | JAWT_LOCK_CLIP_CHANGED);
			WmPaint(e.Graphics, e.ClipRectangle);
		}

		private void WmPaint(Graphics g, Rectangle r)
		{
            handlePaint(r.X + getInsetsLeft(), r.Y + getInsetsTop(), r.Width, r.Height);
		}

		/* Invoke a paint() method call on the target, without clearing the
		 * damaged area.  This is normally called by a native control after
		 * it has painted itself.
		 *
		 * NOTE: This is called on the privileged toolkit thread. Do not
		 *       call directly into user code using this thread!
		 */
		private void handlePaint(int x, int y, int w, int h)
		{
			postPaintIfNecessary(x, y, w, h);
		}

		private void postPaintIfNecessary(int x, int y, int w, int h)
		{
			if (!AWTAccessor.getComponentAccessor().getIgnoreRepaint(target))
			{
				java.awt.@@event.PaintEvent evt = PaintEventDispatcher.getPaintEventDispatcher().createPaintEvent(target, x, y, w, h);
				if (evt != null)
				{
					postEvent(evt);
				}
			}
		}

		private static int MapKeyCode(Keys key)
		{
			switch (key)
			{
				case Keys.Delete:
					return java.awt.@@event.KeyEvent.VK_DELETE;

				case Keys.Enter:
					return java.awt.@@event.KeyEvent.VK_ENTER;

				default:
					return (int)key;
			}
		}

        private void OnKeyDown(object sender, KeyEventArgs e)
		{
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(e.Modifiers);
			int keyCode = MapKeyCode(e.KeyCode);
			// TODO set keyChar
            char keyChar = ' ';
			int keyLocation = java.awt.@@event.KeyEvent.KEY_LOCATION_STANDARD;
			java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate {
				postEvent(new java.awt.@@event.KeyEvent(target, java.awt.@@event.KeyEvent.KEY_PRESSED, when, modifiers, keyCode, keyChar, keyLocation));
			}));
		}

        private void OnQueryContinueDrag(object sender, QueryContinueDragEventArgs e)
        {
        }

        private void OnDragEnter(object sender, DragEventArgs e)
        {
            IDataObject obj = e.Data;
            long[] formats = NetDataTransferer.getInstanceImpl().getClipboardFormatCodes(obj.GetFormats());
            dropTargetPeer = NetDropTargetContextPeer.getNetDropTargetContextPeer();
            int actions = dropTargetPeer.handleEnterMessage(target, e.X, e.Y, getDropAction(e.AllowedEffect, e.KeyState), getAction(e.AllowedEffect),
                                              formats, 0);
            e.Effect = getDragDropEffects(actions);
        }

        private void OnDragOver(object sender, DragEventArgs e)
        {
            IDataObject obj = e.Data;
            long[] formats = NetDataTransferer.getInstanceImpl().getClipboardFormatCodes(obj.GetFormats());
            dropTargetPeer = NetDropTargetContextPeer.getNetDropTargetContextPeer();
            int actions = dropTargetPeer.handleMotionMessage(target, e.X, e.Y, getDropAction(e.AllowedEffect, e.KeyState), getAction(e.AllowedEffect),
                                              formats, 0);
            e.Effect = getDragDropEffects(actions);
        }

        private void OnDragLeave(object sender, EventArgs e)
        {
            if (dropTargetPeer!=null)
                dropTargetPeer.handleExitMessage(target, 0);
            dropTargetPeer = null;
        }

        private void OnDragDrop(object sender, DragEventArgs e)
        {
            IDataObject obj = e.Data;
            long[] formats = NetDataTransferer.getInstanceImpl().getClipboardFormatCodes(obj.GetFormats());
            int actions = getAction(e.Effect);
            if (dropTargetPeer != null)
                dropTargetPeer.handleDropMessage(target, e.X, e.Y, getAction(e.Effect), getAction(e.AllowedEffect),
                                                 formats, 0, e.Data);
            NetDragSourceContextPeer.getInstance().dragDropFinished(true, actions, e.X, e.Y);
            performedDragDropEffects = e.Effect;
            dropTargetPeer = null;
        }

        private static DragDropEffects getDragDropEffects(int actions)
        {
            switch(actions)
            {
                case java.awt.dnd.DnDConstants.ACTION_COPY:
                    return DragDropEffects.Copy;
                case java.awt.dnd.DnDConstants.ACTION_MOVE:
                    return DragDropEffects.Move;
                case java.awt.dnd.DnDConstants.ACTION_COPY_OR_MOVE:
                    return DragDropEffects.Move | DragDropEffects.Copy;
                case java.awt.dnd.DnDConstants.ACTION_LINK:
                    return DragDropEffects.Link;
                default:
                    return DragDropEffects.None;
            }
        }

        private static int getDropAction(DragDropEffects effects, int keyState)
        {
            int ret = java.awt.dnd.DnDConstants.ACTION_NONE;
            const int MK_CONTROL = 0x8;
            const int MK_SHIFT = 0x4;
//            const int WM_MOUSEWHEEL = 0x20A;
//            const int MK_LBUTTON = 0x1;
//            const int MK_MBUTTON = 0x10;
//            const int MK_RBUTTON = 0x2;
//            const int MK_XBUTTON1 = 0x20;
//            const int MK_XBUTTON2 = 0x40;
            switch (keyState & (MK_CONTROL | MK_SHIFT))
            {
                case MK_CONTROL:
                    if ((effects & DragDropEffects.Copy) == DragDropEffects.Copy)
                        ret = java.awt.dnd.DnDConstants.ACTION_COPY;
                    else
                        ret = java.awt.dnd.DnDConstants.ACTION_NONE;
                    break;

                case MK_CONTROL | MK_SHIFT:
                    if ((effects & DragDropEffects.Link) == DragDropEffects.Link)
                        ret = java.awt.dnd.DnDConstants.ACTION_LINK;
                    else
                        ret = java.awt.dnd.DnDConstants.ACTION_NONE;
                    break;

                case MK_SHIFT:
                    if ((effects & DragDropEffects.Move) == DragDropEffects.Move)
                        ret = java.awt.dnd.DnDConstants.ACTION_MOVE;
                    else
                        ret = java.awt.dnd.DnDConstants.ACTION_NONE;
                    break;

                default:
                    if ((effects & DragDropEffects.Move) == DragDropEffects.Move)
                    {
                        ret = java.awt.dnd.DnDConstants.ACTION_MOVE;
                    }
                    else if ((effects & DragDropEffects.Copy) == DragDropEffects.Copy)
                    {
                        ret = java.awt.dnd.DnDConstants.ACTION_COPY;
                    }
                    else if ((effects & DragDropEffects.Link) == DragDropEffects.Link)
                    {
                        ret = java.awt.dnd.DnDConstants.ACTION_LINK;
                    }
                    break;
            }

            return ret;
        }
        
        private void OnKeyUp(object sender, KeyEventArgs e)
		{
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(e.Modifiers);
			int keyCode = MapKeyCode(e.KeyCode);
			// TODO set keyChar
			char keyChar = ' ';
			int keyLocation = java.awt.@@event.KeyEvent.KEY_LOCATION_STANDARD;
			java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate {
				postEvent(new java.awt.@@event.KeyEvent(target, java.awt.@@event.KeyEvent.KEY_RELEASED, when, modifiers, keyCode, keyChar, keyLocation));
			}));
		}

		protected virtual void OnKeyPress(object sender, KeyPressEventArgs e)
		{
			long when = java.lang.System.currentTimeMillis();
			int modifiers = GetModifiers(Control.ModifierKeys);
			int keyCode = java.awt.@@event.KeyEvent.VK_UNDEFINED;
			char keyChar = e.KeyChar;
			int keyLocation = java.awt.@@event.KeyEvent.KEY_LOCATION_UNKNOWN;
			java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate {
				postEvent(new java.awt.@@event.KeyEvent(target, java.awt.@@event.KeyEvent.KEY_TYPED, when, modifiers, keyCode, keyChar, keyLocation));
			}));
		}

		private void postMouseEvent(MouseEventArgs ev, int id, int clicks)
        {
            long when = java.lang.System.currentTimeMillis();
            int modifiers = GetMouseEventModifiers(ev);
            int button = GetButton(ev);
			int clickCount = clicks;
            int x = ev.X + getInsetsLeft(); //The Inset correctur is needed for Window and extended classes
            int y = ev.Y + getInsetsTop();
            bool isPopup = isPopupMenu;
			java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate {
				postEvent(new java.awt.@@event.MouseEvent(target, id, when, modifiers, x, y, clickCount, isPopup, button));
			}));
            isPopupMenu = false;
        }

        private void postMouseEvent(EventArgs ev, int id)
        {
            long when = java.lang.System.currentTimeMillis();
            int modifiers = GetModifiers(Control.ModifierKeys);
            int button = 0;
            int clickCount = 0;
            int x = Control.MousePosition.X - control.Location.X;
            int y = Control.MousePosition.Y - control.Location.Y;
            bool isPopup = isPopupMenu;
			java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate {
	            postEvent(new java.awt.@@event.MouseEvent(target, id, when, modifiers, x, y, clickCount, isPopup, button));
			}));
            isPopupMenu = false;
        }

        private void postMouseWheelEvent(EventArgs ev, int id, int delta)
        {
            long when = java.lang.System.currentTimeMillis();
            int modifiers = GetModifiers(Control.ModifierKeys);
            int scrollAmount = -delta * SystemInformation.MouseWheelScrollLines / 120;
            int clickCount = 0;
            int x = Control.MousePosition.X - control.Location.X;
            int y = Control.MousePosition.Y - control.Location.Y;
            bool isPopup = isPopupMenu;
            java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate
            {
                postEvent(new java.awt.@@event.MouseWheelEvent(target, id, when, modifiers, x, y, clickCount, isPopup, java.awt.@@event.MouseWheelEvent.WHEEL_UNIT_SCROLL, scrollAmount, scrollAmount));
            }));
        }

        protected virtual void OnMouseMove(object sender, MouseEventArgs ev)
		{
			if((ev.Button & (MouseButtons.Left | MouseButtons.Right)) != 0)
			{
				postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_DRAGGED, ev.Clicks);
			}
			else
			{
                postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_MOVED, ev.Clicks);
			}
		}

		protected virtual void OnMouseDown(object sender, MouseEventArgs ev)
		{
			isMouseClick = false;
			isDoubleClick = false;
			isPopupMenu = false;
			postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_PRESSED, ev.Clicks);
		}

        private void OnMouseWheel(object sender, MouseEventArgs ev)
        {
            postMouseWheelEvent(ev, java.awt.@@event.MouseEvent.MOUSE_WHEEL, ev.Delta);
        }

        private void OnClick(object sender, EventArgs ev)
        {
            isMouseClick = true;
        }

		private void OnDoubleClick(object sender, EventArgs ev)
        {
            isDoubleClick = true;
        }

		private void OnMouseUp(object sender, MouseEventArgs ev)
		{
			postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_RELEASED, ev.Clicks);
            if (isMouseClick || isDoubleClick) // there can only be an Click OR an DoubleClick event - both count as click here
			{
				//We make our own mouse click event because the event order is different in .NET
				//in .NET the click occured before MouseUp
				int clicks = ev.Clicks;
				if (isDoubleClick)
				{
					clicks = 2;
				}
				postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_CLICKED, clicks);
			}
			isMouseClick = false;
		}

		private void OnMouseEnter(object sender, EventArgs ev)
		{
			postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_ENTERED);
		}

		private void OnMouseLeave(object sender, EventArgs ev)
		{
			postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_EXITED);
		}

		private void OnGotFocus(object sender, EventArgs e)
		{
			if (sm_suppressFocusAndActivation)
			{
				return;
			}
			java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate {
				postEvent(new java.awt.@@event.FocusEvent(target, java.awt.@@event.FocusEvent.FOCUS_GAINED));
			}));
		}

		private void OnLostFocus(object sender, EventArgs e)
		{
			java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate {
				postEvent(new java.awt.@@event.FocusEvent(target, java.awt.@@event.FocusEvent.FOCUS_LOST));
			}));
		}

		/*
		 * Called from native code (on Toolkit thread) in order to
		 * dynamically layout the Container during resizing
		 */
		internal void dynamicallyLayoutContainer() {
			// If we got the WM_SIZING, this must be a Container, right?
			// In fact, it must be the top-level Container.
			//if (log.isLoggable(Level.FINE)) {
			//    java.awt.Container parent = NetToolkit.getNativeContainer((java.awt.Component)target);
			//    if (parent != null) {
			//        log.log(Level.FINE, "Assertion (parent == null) failed");
			//    }
			//}
			java.awt.Container cont = (java.awt.Container)(object)target;

			NetToolkit.executeOnEventHandlerThread(cont, Delegates.toRunnable(delegate {
				// Discarding old paint events doesn't seem to be necessary.
				cont.invalidate();
				cont.validate();

				//if (surfaceData instanceof OGLSurfaceData) {
				//    // 6290245: When OGL is enabled, it is necessary to
				//    // replace the SurfaceData for each dynamic layout
				//    // request so that the OGL viewport stays in sync
				//    // with the window bounds.
				//    try {
				//        replaceSurfaceData();
				//    } catch (InvalidPipeException e) {
				//        // REMIND: this is unlikely to occur for OGL, but
				//        // what do we do if surface creation fails?
				//    }
				//}

				// Forcing a paint here doesn't seem to be necessary.
				// paintDamagedAreaImmediately();
			}));
		}

		/*
		 * Paints any portion of the component that needs updating
		 * before the call returns (similar to the Win32 API UpdateWindow)
		 */
		internal void paintDamagedAreaImmediately()
		{
			// force Windows to send any pending WM_PAINT events so
			// the damage area is updated on the Java side
			updateWindow();
			// make sure paint events are transferred to main event queue
			// for coalescing
			NetToolkit.flushPendingEvents();
			// paint the damaged area
			paintArea.paint(target, shouldClearRectBeforePaint());
		}

        private void updateWindow()
        {
            NetToolkit.BeginInvoke(delegate
            {
                control.Update();
            });
        }

		/* override and return false on components that DO NOT require
		   a clearRect() before painting (i.e. native components) */
		public virtual bool shouldClearRectBeforePaint()
		{
			return true;
		}

        private void OnPopupMenu(object sender, EventArgs ev)
        {
            isPopupMenu = true;
        }

		/*
		 * Post an event. Queue it for execution by the callback thread.
		 */
		internal void postEvent(java.awt.AWTEvent evt)
		{
			NetToolkit.postEvent(NetToolkit.targetToAppContext(target), evt);
		}

		// Routines to support deferred window positioning.
		public void beginLayout()
		{
			// Skip all painting till endLayout
			isLayouting = true;
		}

		public void endLayout()
		{
			if (!paintArea.isEmpty() && !paintPending &&
				!target.getIgnoreRepaint())
			{
				// if not waiting for native painting repaint damaged area
				postEvent(new java.awt.@@event.PaintEvent(target, java.awt.@@event.PaintEvent.PAINT, new java.awt.Rectangle()));
			}
			isLayouting = false;
		}

		public void beginValidate()
		{
			//    Invoke(delegate
			//    {
			//        if (m_validationNestCount == 0)
			//        {
			//            m_hdwp = BeginDeferWindowPos();
			//        }
			//        m_validationNestCount++;
			//    });
		}

		public void endValidate()
		{
            //    Invoke(delegate
            //    {
			//    m_validationNestCount--;
			//    if (m_validationNestCount == 0) {
			//        // if this call to EndValidate is not nested inside another
			//        // Begin/EndValidate pair, end deferred window positioning
			//        ::EndDeferWindowPos(m_hdwp);
			//        m_hdwp = NULL;
			//    }
            //    });
        }

		// Returns true if we are inside begin/endLayout and
		// are waiting for native painting
		public bool isPaintPending()
		{
			return paintPending && isLayouting;
		}

		public override int checkImage(java.awt.Image img, int width, int height, java.awt.image.ImageObserver ob)
		{
			return getToolkit().checkImage(img, width, height, ob);
		}

		public override java.awt.Image createImage(java.awt.image.ImageProducer prod)
		{
            return new sun.awt.image.ToolkitImage(prod);
		}

		public override java.awt.Image createImage(int width, int height)
		{
            return new java.awt.image.BufferedImage(width, height, java.awt.image.BufferedImage.TYPE_INT_ARGB);
		}

		public override void disable()
		{
            NetToolkit.BeginInvoke(delegate { Enable( false ); });
		}

		public override void dispose()
		{
		    bool callDisposed = true;
            lock(this)
            {
                if (disposed)
                    callDisposed = false;
                disposed = true;
            }
            if (callDisposed)
            {
                disposeImpl();
            }
		}

		protected virtual void disposeImpl()
		{
            NetToolkit.targetDisposedPeer(target, this);
            NetToolkit.Invoke(nativeDispose);
        }

        protected virtual void nativeDispose()
        {
            unhookEvents();
            control.Dispose();
        }

		public override void enable()
		{
            NetToolkit.BeginInvoke(delegate { Enable(true); });
		}

		public override java.awt.image.ColorModel getColorModel()
		{
            //we return the default ColorModel because this causes the least problems with conversions
            return java.awt.image.ColorModel.getRGBdefault();
        }

		public override java.awt.FontMetrics getFontMetrics(java.awt.Font f)
		{
            return sun.font.FontDesignMetrics.getMetrics(f);
		}

		public override java.awt.Graphics getGraphics()
		{
			if (!control.IsDisposed)
			{
				/* Fix for bug 4746122. Color and Font shouldn't be null */
				java.awt.Color bgColor = background;
				if (bgColor == null)
				{
					bgColor = java.awt.SystemColor.window;
				}
				java.awt.Color fgColor = foreground;
				if (fgColor == null)
				{
					fgColor = java.awt.SystemColor.windowText;
				}
				java.awt.Font font = this.font;
				if (font == null)
				{
					font = defaultFont;
				}
				return new ComponentGraphics(this.control, target, fgColor, bgColor, font);
			}
			return null;
		}

		public override java.awt.Point getLocationOnScreen()
        {
            return NetToolkit.Invoke<java.awt.Point>(delegate
            {
				Point p = new Point(0 - getInsetsLeft(), 0 - getInsetsTop());
                p = control.PointToScreen(p);
                return new java.awt.Point(p.X, p.Y);
            });
        }

		public override java.awt.Dimension getMinimumSize()
		{
			return target.getSize();
		}

		public override java.awt.Dimension getPreferredSize()
		{
			return getMinimumSize();
		}

		public override java.awt.Toolkit getToolkit()
		{
			return java.awt.Toolkit.getDefaultToolkit();
		}

		// returns true if the event has been handled and shouldn't be propagated
		// though handleEvent method chain - e.g. WTextFieldPeer returns true
		// on handling '\n' to prevent it from being passed to native code
		public virtual bool handleJavaKeyEvent(java.awt.@@event.KeyEvent e) { return false; }

		private void nativeHandleEvent(java.awt.AWTEvent e)
		{
				// TODO arrghh!! code from void AwtComponent::_NativeHandleEvent(void *param) in awt_Component.cpp should be here
		}

		public override void handleEvent(java.awt.AWTEvent e)
		{
			int id = e.getID();

			if (((java.awt.Component)target).isEnabled() && (e is java.awt.@@event.KeyEvent) && !((java.awt.@@event.KeyEvent)e).isConsumed())
			{
				if (handleJavaKeyEvent((java.awt.@@event.KeyEvent)e))
				{
					return;
				}
			}

			switch (id)
			{
				case java.awt.@@event.PaintEvent.PAINT:
					// Got native painting
					paintPending = false;
					// Fallthrough to next statement
					goto case java.awt.@@event.PaintEvent.UPDATE;
				case java.awt.@@event.PaintEvent.UPDATE:
					// Skip all painting while layouting and all UPDATEs
					// while waiting for native paint
					if (!isLayouting && !paintPending)
					{
						paintArea.paint(target, shouldClearRectBeforePaint());
					}
					return;
				default:
					break;
			}

			// Call the native code
			nativeHandleEvent(e);
		}

		public override void hide()
		{
            NetToolkit.BeginInvoke(delegate { control.Visible = false; });
		}

		public bool isFocusTraversable()
		{
			return true;
		}

		public override java.awt.Dimension minimumSize()
		{
			return getMinimumSize();
		}

		public override java.awt.Dimension preferredSize()
		{
			return getPreferredSize();
		}

		public override void paint(java.awt.Graphics graphics)
		{
			target.paint(graphics);
		}

		public override bool prepareImage(java.awt.Image img, int width, int height, java.awt.image.ImageObserver ob)
		{
			return getToolkit().prepareImage(img, width, height, ob);
		}

		public override void print(java.awt.Graphics graphics)
		{
			throw new NotImplementedException();
		}

		public override void repaint(long tm, int x, int y, int width, int height)
		{
		}

		public void requestFocus()
		{
			NetToolkit.Invoke<bool>(control.Focus);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="request">the component for which the focus is requested</param>
        /// <param name="temporary">indicates if the focus change is temporary (true) or permanent (false)</param>
        /// <param name="allowWindowFocus">indicates if it's allowed to change window focus</param>
        /// <param name="time">the timestamp</param>
        /// <returns></returns>
		public bool requestFocus(java.awt.Component request, bool temporary, bool allowWindowFocus, long time)
		{
            if (!getEnabled() || !getVisible())
            {
                return false;
            }
            postEvent(new java.awt.@@event.FocusEvent(request, java.awt.@@event.FocusEvent.FOCUS_GAINED, temporary, target));
			return true;
		}

		public override void reshape(int x, int y, int width, int height)
        {
            NetToolkit.BeginInvoke(delegate
            {
                Form window = control.FindForm();
                java.awt.Insets insets;
                if (window is MyForm)
                {
                    insets = ((MyForm)window).peerInsets;
                }
                else
                {
                    insets = new java.awt.Insets(0, 0, 0, 0);
                }
                control.SetBounds(x - insets.left, y - insets.top, width, height);
                //If the .NET control does not accept the new bounds (minimum size, maximum size) 
                //then we need to reflect the real bounds on the .NET site to the Java site
                Rectangle bounds = control.Bounds;
                if (bounds.X + insets.left != x || bounds.Y + insets.top != y)
                {
                    AWTAccessor.getComponentAccessor().setLocation(target, bounds.X + insets.left, bounds.Y + insets.top);
                }
                if (bounds.Width != width || bounds.Height != height)
                {
                    AWTAccessor.getComponentAccessor().setSize(target, bounds.Width, bounds.Height);
                }
            });
        }

		public override void setBackground(java.awt.Color color)
		{
			lock (this)
			{
				this.background = color;
				NetToolkit.BeginInvoke(delegate { control.BackColor = J2C.ConvertColor(color); });
			}
		}

		private void reshapeNoCheck(int x, int y, int width, int height)
		{
            NetToolkit.BeginInvoke(delegate { control.SetBounds(x, y, width, height); });
		}

		public override void setBounds(int x, int y, int width, int height, int op)
		{
			// Should set paintPending before reahape to prevent
			// thread race between paint events
			// Native components do redraw after resize
			paintPending = (width != oldWidth) || (height != oldHeight);

            if ((op & java.awt.peer.ComponentPeer.__Fields.NO_EMBEDDED_CHECK) != 0)
			{
				reshapeNoCheck(x, y, width, height);
			}
			else
			{
				reshape(x, y, width, height);
			}
			if ((width != oldWidth) || (height != oldHeight))
			{
				// Only recreate surfaceData if this setBounds is called
				// for a resize; a simple move should not trigger a recreation
				try
				{
					//replaceSurfaceData();
				}
				catch (sun.java2d.InvalidPipeException)
				{
					// REMIND : what do we do if our surface creation failed?
				}
				oldWidth = width;
				oldHeight = height;
			}

			serialNum++;
		}

		private void setCursorImpl(java.awt.Cursor cursor)
		{
			if (cursor is NetCustomCursor)
			{
				NetCustomCursor ncc = (NetCustomCursor)cursor;
				control.Cursor = ncc.Cursor;
				return;
			}
			switch(cursor.getType())
			{
				case java.awt.Cursor.WAIT_CURSOR:
					control.Cursor = Cursors.WaitCursor;
					break;
				case java.awt.Cursor.DEFAULT_CURSOR:
					control.Cursor = Cursors.Default;
					break;
				case java.awt.Cursor.HAND_CURSOR:
					control.Cursor = Cursors.Hand;
					break;
				case java.awt.Cursor.CROSSHAIR_CURSOR:
					control.Cursor = Cursors.Cross;
					break;
				case java.awt.Cursor.W_RESIZE_CURSOR:
				case java.awt.Cursor.E_RESIZE_CURSOR:
					control.Cursor = Cursors.SizeWE;
					break;
				case java.awt.Cursor.MOVE_CURSOR:
					control.Cursor = Cursors.SizeAll;
					break;
				case java.awt.Cursor.N_RESIZE_CURSOR:
				case java.awt.Cursor.S_RESIZE_CURSOR:
					control.Cursor = Cursors.SizeNS;
					break;
				case java.awt.Cursor.NE_RESIZE_CURSOR:
				case java.awt.Cursor.SW_RESIZE_CURSOR:
					control.Cursor = Cursors.SizeNESW;
					break;
				case java.awt.Cursor.NW_RESIZE_CURSOR:
				case java.awt.Cursor.SE_RESIZE_CURSOR:
					control.Cursor = Cursors.SizeNWSE;
					break;
				case java.awt.Cursor.TEXT_CURSOR:
					control.Cursor = Cursors.IBeam;
					break;
				default:
					Console.WriteLine("setCursor not implement for: " + cursor);
					break;
			}
		}

        public void setCursor(java.awt.Cursor cursor)
        {
            NetToolkit.Invoke(setCursorImpl, cursor);
        }

        public bool getEnabled()
        {
            return NetToolkit.Invoke<bool>(delegate { return control.Enabled; });
        }

        public bool getFocused()
        {
            return NetToolkit.Invoke<bool>(delegate { return control.Focused; });
        }

        public bool getVisible()
        {
            return NetToolkit.Invoke<bool>(delegate { return control.Visible; });
        }

		public override void setEnabled(bool enabled)
		{
			if (enabled)
			{
				enable();
			}
			else
			{
				disable();
			}
		}

		public override void setFont(java.awt.Font font)
		{
			lock (this)
			{
				this.font = font;
				NetToolkit.BeginInvoke(delegate { control.Font = font.getNetFont(); });
			}
		}

		public override void setForeground(java.awt.Color color)
		{
			lock (this)
			{
				this.foreground = color;
				NetToolkit.BeginInvoke(delegate { control.ForeColor = J2C.ConvertColor(color); });
			}
		}

		public override void setVisible(bool visible)
		{
			if (visible)
			{
				show();
			}
			else
			{
				hide();
			}
		}

		public override void show()
		{
			java.awt.Dimension s = target.getSize();
			oldHeight = s.height;
			oldWidth = s.width;
			pShow();
		}

		/*
		 * Return the GraphicsConfiguration associated with this peer, either
		 * the locally stored winGraphicsConfig, or that of the target Component.
		 */
		public override java.awt.GraphicsConfiguration getGraphicsConfiguration()
        {
            // we don't need a treelock here, since
            // Component.getGraphicsConfiguration() gets it itself.
            return target.getGraphicsConfiguration();
        }

		public void setEventMask (long mask)
		{
			//Console.WriteLine("NOTE: NetComponentPeer.setEventMask not implemented");
		}

		public override bool isObscured()
		{
			// should never be called because we return false from canDetermineObscurity()
			return true;
		}

		public override bool canDetermineObscurity()
		{
			// JDK returns true here and uses GetClipBox to determine if the window is partially obscured,
			// this is an optimization for scrolling in javax.swing.JViewport, since there appears to be
			// no managed equivalent of GetClipBox, we'll simply return false and forgo the optimization.
			return false;
		}

		public override void coalescePaintEvent(java.awt.@@event.PaintEvent e)
		{
			java.awt.Rectangle r = e.getUpdateRect();
			if (!(e is sun.awt.@@event.IgnorePaintEvent))
			{
				paintArea.add(r, e.getID());
			}
		}

		public override void updateCursorImmediately()
		{
		}

		public override java.awt.image.VolatileImage createVolatileImage(int width, int height)
		{
			return new NetVolatileImage(target, width, height);
		}

		public override bool handlesWheelScrolling()
		{
			return true;
		}

		public override void createBuffers(int x, java.awt.BufferCapabilities capabilities)
		{
			throw new NotImplementedException();
		}

		public override java.awt.Image getBackBuffer()
		{
			throw new NotImplementedException();
		}

		public override void flip(java.awt.BufferCapabilities.FlipContents contents)
		{
			throw new NotImplementedException();
		}

		public override void destroyBuffers()
		{
			throw new NotImplementedException();
		}

		public override bool isFocusable()
		{
			return false;
		}

	    protected bool isDisposed()
	    {
	        return disposed;
	    }

		public override java.awt.Rectangle getBounds()
		{
			return target.getBounds();
		}

		public override void reparent(java.awt.peer.ContainerPeer parent)
		{
			throw new NotImplementedException();
		}

		public override bool isReparentSupported()
		{
			return false;
		}

		// Do nothing for heavyweight implementation
		public override void layout()
		{
		}

        public override void applyShape(sun.java2d.pipe.Region shape)
        {
            NetToolkit.BeginInvoke(ApplyShapeImpl, shape);
        }

        private void ApplyShapeImpl(sun.java2d.pipe.Region shape)
        {
            control.Region = J2C.ConvertRegion(shape);
        }

        //copied form KeyboardFocusManager
        private const int SNFH_FAILURE = 0;
        private const int SNFH_SUCCESS_HANDLED = 1;
        private const int SNFH_SUCCESS_PROCEED = 2;

        private static java.lang.reflect.Method shouldNativelyFocusHeavyweight;
		private static java.lang.reflect.Method processSynchronousLightweightTransfer;
		private static java.lang.reflect.Method removeLastFocusRequest;

		public override bool requestFocus(java.awt.Component lightweightChild, bool temporary, bool focusedWindowChangeAllowed, long time, sun.awt.CausedFocusEvent.Cause cause)
        {
            // this is a interpretation of the code in WComponentPeer.java and awt_component.cpp
            try
            {
                if (processSynchronousLightweightTransfer == null)
                {
					java.security.AccessController.doPrivileged(Delegates.toPrivilegedAction(delegate
					{
						java.lang.Class keyboardFocusManagerCls = typeof(java.awt.KeyboardFocusManager);
						java.lang.reflect.Method method = keyboardFocusManagerCls.getDeclaredMethod(
							"processSynchronousLightweightTransfer",
							typeof(java.awt.Component),
							typeof(java.awt.Component),
							java.lang.Boolean.TYPE,
							java.lang.Boolean.TYPE,
							java.lang.Long.TYPE);
						method.setAccessible(true);
						processSynchronousLightweightTransfer = method;
						return null;
					}));
                }
                processSynchronousLightweightTransfer.invoke(
                null,
                target,
                lightweightChild,
                java.lang.Boolean.valueOf(temporary),
                java.lang.Boolean.valueOf(focusedWindowChangeAllowed),
                java.lang.Long.valueOf(time));
            }
            catch
            {
                return true;
            }
            if (shouldNativelyFocusHeavyweight == null)
            {
				java.security.AccessController.doPrivileged(Delegates.toPrivilegedAction(delegate
				{
					java.lang.Class keyboardFocusManagerCls = typeof(java.awt.KeyboardFocusManager);
					java.lang.reflect.Method method = keyboardFocusManagerCls.getDeclaredMethod(
						"shouldNativelyFocusHeavyweight",
						typeof(java.awt.Component),
						typeof(java.awt.Component),
						java.lang.Boolean.TYPE,
						java.lang.Boolean.TYPE,
						java.lang.Long.TYPE,
						typeof(sun.awt.CausedFocusEvent.Cause));
					method.setAccessible(true);
					shouldNativelyFocusHeavyweight = method;
					return null;
				}));
            }
            int retval = ((java.lang.Integer)shouldNativelyFocusHeavyweight.invoke(
                null,
                target,
                lightweightChild,
                java.lang.Boolean.valueOf(temporary),
                java.lang.Boolean.valueOf(focusedWindowChangeAllowed),
                java.lang.Long.valueOf(time),
                cause)).intValue();
            if (retval == SNFH_SUCCESS_HANDLED)
            {
                return true;
            }
            else if (retval == SNFH_SUCCESS_PROCEED)
            {
                if (getFocused())
                {
                    return true;
                }
                if (removeLastFocusRequest == null)
                {
					java.security.AccessController.doPrivileged(Delegates.toPrivilegedAction(delegate
					{
						java.lang.Class keyboardFocusManagerCls = typeof(java.awt.KeyboardFocusManager);
						java.lang.reflect.Method method = keyboardFocusManagerCls.getDeclaredMethod(
							"removeLastFocusRequest",
							typeof(java.awt.Component));
						method.setAccessible(true);
						removeLastFocusRequest = method;
						return null;
					}));
                }
                removeLastFocusRequest.invoke(null, target);
            }
            //SNFH_FAILURE
            return false;
        }

        /**
         * Move the back buffer to the front buffer.
         *
         * @@param x1 the area to be flipped, upper left X coordinate
         * @@param y1 the area to be flipped, upper left Y coordinate
         * @@param x2 the area to be flipped, lower right X coordinate
         * @@param y2 the area to be flipped, lower right Y coordinate
         * @@param flipAction the flip action to perform
         *
         * @@see Component.FlipBufferStrategy#flip
         */
        public override void flip(int x1, int y1, int x2, int y2, java.awt.BufferCapabilities.FlipContents flipAction)
        {
            throw new ikvm.@@internal.NotYetImplementedError();
        }

        /**
         * Lowers this component at the bottom of the above HW peer. If the above parameter
         * is null then the method places this component at the top of the Z-order.
         */
        public override void setZOrder(java.awt.peer.ComponentPeer above)
        {
            Control.ControlCollection controls = control.Controls;
            if (!controls.Contains(control))
            {
                // Control was not added to any window. Occur if you call addNotify without
                return;
            }
            if (above == null)
            {
                controls.SetChildIndex(control, 0);
            }
            else
            {
                NetComponentPeer<T, C> netPeer = (NetComponentPeer<T, C>)above;
                controls.SetChildIndex(control, controls.GetChildIndex(netPeer.control));
            }
        }

        /**
         * Updates internal data structures related to the component's GC.
         *
         * @@return if the peer needs to be recreated for the changes to take effect
         * @@since 1.7
         */
        public override bool updateGraphicsData(java.awt.GraphicsConfiguration gc)
        {
            throw new ikvm.@@internal.NotYetImplementedError();
        }

	}

	sealed class NetScrollbarPeer : NetComponentPeer<java.awt.Scrollbar, ScrollBar>, java.awt.peer.ScrollbarPeer
	{
		internal NetScrollbarPeer(java.awt.Scrollbar target)
			: base(target)
		{
		}

		public void setLineIncrement(int i)
		{
		}

		public void setPageIncrement(int i)
		{
		}

		public void setValues(int i1, int i2, int i3, int i4)
		{
		}

		protected override ScrollBar CreateControl()
		{
			switch (target.getOrientation())
			{
				case java.awt.Scrollbar.VERTICAL:
					return new VScrollBar();
				default:
					return new HScrollBar();
			}
		}
	}

	sealed class NetScrollPanePeer : NetComponentPeer<java.awt.ScrollPane, ScrollableControl>, java.awt.peer.ScrollPanePeer
	{
		internal NetScrollPanePeer(java.awt.ScrollPane pane)
			: base(pane)
		{
		}

		public void childResized(int i1, int i2)
		{
		}

		public int getHScrollbarHeight()
		{
			return NetToolkit.Invoke<int>(delegate { return 0; });
		}

		public int getVScrollbarWidth()
		{
			return NetToolkit.Invoke<int>(delegate { return 0; });
		}

		public void setScrollPosition(int i1, int i2)
		{
		}

		public void setUnitIncrement(java.awt.Adjustable a, int i)
		{
		}

		public void setValue(java.awt.Adjustable a, int i)
		{
		}

		public java.awt.Insets getInsets()
		{
			return NetToolkit.Invoke<java.awt.Insets>(delegate { return new java.awt.Insets(0, 0, 0, 0); });
		}

		public java.awt.Insets insets()
		{
			return getInsets();
		}

		public bool isRestackSupported()
		{
			return false;
		}

		public void restack()
		{
			throw new NotImplementedException();
		}

		protected override ScrollableControl CreateControl()
		{
			return new ScrollableControl();
		}
	}

    sealed class NetButtonPeer : NetComponentPeer<java.awt.Button, Button>, java.awt.peer.ButtonPeer
	{
		public NetButtonPeer(java.awt.Button awtbutton)
			: base(awtbutton)
		{
			if (!awtbutton.isBackgroundSet())
			{
				awtbutton.setBackground(java.awt.SystemColor.control);
			}
			control.BackColor = Color.FromArgb(awtbutton.getBackground().getRGB());
			control.Text = awtbutton.getLabel();
			control.Click += new EventHandler(OnClick);
		}

		private void OnClick(object sender, EventArgs e)
		{
			// TODO set all these properties correctly
			string cmd = "";
			long when = 0;
			int modifiers = 0;
			postEvent(new java.awt.@@event.ActionEvent(target, java.awt.@@event.ActionEvent.ACTION_PERFORMED, cmd, when, modifiers));
		}

		public void setLabel(string label)
		{
			NetToolkit.Invoke(delegate { control.Text = label; });
		}

		public override java.awt.Dimension getMinimumSize()
		{
			using(Graphics g = control.CreateGraphics())
			{
				// TODO get these fudge factors from somewhere
				return new java.awt.Dimension((int)Math.Round(12 + g.MeasureString(control.Text, control.Font).Width) * 8 / 7, 6 + control.Font.Height * 8 / 7);
			}
		}

        public override bool shouldClearRectBeforePaint()
        {
            return false;
        }

		protected override Button CreateControl()
		{
			return new Button();
		}
	}

    abstract class NetTextComponentPeer<T> : NetComponentPeer<T, TextBox>, java.awt.peer.TextComponentPeer
		where T : java.awt.TextComponent
	{
		public NetTextComponentPeer(java.awt.TextComponent textComponent)
			: base((T)textComponent)
		{
#if __MonoCS__
			// MONOBUG mcs generates a ldflda on a readonly field, so we use a temp
			T target = this.target;
#endif
			if (!target.isBackgroundSet())
			{
				target.setBackground(java.awt.SystemColor.window);
			}
			setBackground(target.getBackground());
			control.AutoSize = false;
			control.Text = target.getText();
		}

        public override bool isFocusable()
        {
            return true;
        }

		protected override void OnKeyPress(object sender, KeyPressEventArgs e)
		{
			base.OnKeyPress(sender, e);
			// TODO for TextAreas this probably isn't the right behaviour
			if(e.KeyChar == '\r')
			{
				// TODO set all these properties correctly
				string cmd = "";
				long when = 0;
				int modifiers = 0;
				postEvent(new java.awt.@@event.ActionEvent(target, java.awt.@@event.ActionEvent.ACTION_PERFORMED, cmd, when, modifiers));
			}
		}

		public int getSelectionEnd()
		{
			return NetToolkit.Invoke<int>(delegate { return control.SelectionStart + control.SelectionLength; });
		}

		public int getSelectionStart()
		{
			return NetToolkit.Invoke<int>(delegate { return control.SelectionStart; });
		}

		public string getText()
		{
		    return NetToolkit.Invoke<string>(delegate { return control.Text; });
		}

		public void setText(string text)
		{
			NetToolkit.Invoke(delegate { control.Text = text; });
        }

		public void select(int start_pos, int end_pos)
		{
			throw new NotImplementedException();
		}

		public void setEditable(bool editable)
		{
			throw new NotImplementedException();
		}

		public int getCaretPosition()
		{
			return getSelectionStart();
		}

		private void setCaretPositionImpl(int pos)
		{
			control.SelectionStart = pos;
			control.SelectionLength = 0;
		}

		public void setCaretPosition(int pos)
		{
			NetToolkit.Invoke(setCaretPositionImpl, pos);
		}

		public long filterEvents(long filter)
		{
			throw new NotImplementedException();
		}

		public int getIndexAtPoint(int x, int y)
		{
			throw new NotImplementedException();
		}

		public java.awt.Rectangle getCharacterBounds(int pos)
		{
			throw new NotImplementedException();
		}

		public java.awt.im.InputMethodRequests getInputMethodRequests()
		{
			throw new NotImplementedException();
		}

		protected sealed override TextBox CreateControl()
		{
			return new TextBox();
		}
	}

	sealed class NetChoicePeer : NetComponentPeer<java.awt.Choice, RadioButton>, java.awt.peer.ChoicePeer
	{
		public NetChoicePeer(java.awt.Choice target)
			: base(target)
		{
		}

		public void add(string str, int i)
		{
			// TODO:  Add NetChoicePeer.add implementation
		}

		public void addItem(string str, int i)
		{
			// TODO:  Add NetChoicePeer.addItem implementation
		}

		public void select(int i)
		{
			// TODO:  Add NetChoicePeer.select implementation
		}

		public void removeAll()
		{
			// TODO:  Add NetChoicePeer.removeAll implementation
		}

		public void remove(int i)
		{
			// TODO:  Add NetChoicePeer.remove implementation
		}

		protected override RadioButton CreateControl()
		{
			return new RadioButton();
		}
	}

    sealed class NetCheckboxPeer : NetComponentPeer<java.awt.Checkbox, CheckBox>, java.awt.peer.CheckboxPeer
	{
		public NetCheckboxPeer(java.awt.Checkbox target)
			: base(target)
		{
		}

		public void setCheckboxGroup(java.awt.CheckboxGroup cg)
		{
			// TODO:  Add NetCheckboxPeer.setCheckboxGroup implementation
		}

		public void setState(bool b)
		{
			// TODO:  Add NetCheckboxPeer.setState implementation
		}

		public void setLabel(string str)
		{
			// TODO:  Add NetCheckboxPeer.setLabel implementation
		}

		protected override CheckBox CreateControl()
		{
			return new CheckBox();
		}
	}

    sealed class NetLabelPeer : NetComponentPeer<java.awt.Label, Label>, java.awt.peer.LabelPeer
	{
		public NetLabelPeer(java.awt.Label jlabel)
			: base(jlabel)
		{
			control.Text = jlabel.getText();
			setAlignment(jlabel.getAlignment());
		}

		public void setAlignment(int align)
		{
		    ContentAlignment alignment;
			switch(align)
			{
				case java.awt.Label.LEFT:
			        alignment = ContentAlignment.TopLeft;
					break;
				case java.awt.Label.CENTER:
                    alignment = ContentAlignment.TopCenter;
					break;
				case java.awt.Label.RIGHT:
                    alignment = ContentAlignment.TopRight;
					break;
                default:
			        return;
			}
		    NetToolkit.Invoke(setAlignImpl, alignment);
		}

		private void setAlignImpl(ContentAlignment alignment)
		{
            control.TextAlign = (ContentAlignment)alignment;
		}

		public void setText(string s)
		{
            NetToolkit.Invoke(setTextImpl, s);
		}

		private void setTextImpl(string s)
		{
			control.Text = s;
		}

		public override java.awt.Dimension preferredSize()
		{
            return NetToolkit.Invoke<java.awt.Dimension>(getPreferredSizeImpl);
		}

		private java.awt.Dimension getPreferredSizeImpl()
		{
			// HACK get these fudge factors from somewhere
			return new java.awt.Dimension(control.PreferredWidth, 2 + control.PreferredHeight);
		}

        public override bool shouldClearRectBeforePaint()
        {
            // is native control, don't clear 
            return false;
        }

		protected override Label CreateControl()
		{
			return new Label();
		}
	}

    sealed class NetTextFieldPeer : NetTextComponentPeer<java.awt.TextField>, java.awt.peer.TextFieldPeer
	{
		public NetTextFieldPeer(java.awt.TextField textField)
			: base(textField)
		{
			setEchoCharacterImpl(textField.getEchoChar());
		}

		public java.awt.Dimension minimumSize(int len)
		{
			return getMinimumSize(len);
		}

		public java.awt.Dimension preferredSize(int len)
		{
			return getPreferredSize(len);
		}

		public java.awt.Dimension getMinimumSize(int len)
		{
			return getPreferredSize(len);
		}

		public java.awt.Dimension getPreferredSize(int len)
		{
			// TODO use control.Invoke
			using(Graphics g = control.CreateGraphics())
			{
				return new java.awt.Dimension((int)Math.Round((g.MeasureString("abcdefghijklm", control.Font).Width * len) / 13), ((TextBox)control).PreferredHeight);
			}
		}

		public void setEchoChar(char echo_char)
		{
			setEchoCharacter(echo_char);
		}

        private void setEchoCharacterImpl(char echo_char)
        {
            control.PasswordChar = echo_char;
        }

		public void setEchoCharacter(char echo_char)
		{
		    control.Invoke(new Action<char>(setEchoCharacterImpl), echo_char);
		}

        public override bool handleJavaKeyEvent(java.awt.@@event.KeyEvent e)
        {
            switch (e.getID())
            {
                case java.awt.@@event.KeyEvent.KEY_TYPED:
                    if ((e.getKeyChar() == '\n') && !e.isAltDown() && !e.isControlDown())
                    {
                        postEvent(new java.awt.@@event.ActionEvent(target, java.awt.@@event.ActionEvent.ACTION_PERFORMED,
                                                  getText(), e.getWhen(), e.getModifiers()));
                        return true;
                    }
                    break;
            }
            return false;
        }
	}

    sealed class NetTextAreaPeer : NetComponentPeer<java.awt.TextArea, RichTextBox>, java.awt.peer.TextAreaPeer
	{
		public NetTextAreaPeer(java.awt.TextArea textArea)
			: base(textArea)
		{
			control.ReadOnly = !((java.awt.TextArea)target).isEditable();
			control.WordWrap = false;
			control.ScrollBars = RichTextBoxScrollBars.Both;
			control.Multiline = true;
			control.AutoSize = false;
			control.Text = target.getText();
		}

		public override bool isFocusable()
		{
			return true;
		}

		public int getSelectionEnd()
		{
			return NetToolkit.Invoke<int>(delegate { return control.SelectionStart + control.SelectionLength; });
		}

		public int getSelectionStart()
		{
			return NetToolkit.Invoke<int>(delegate { return control.SelectionStart; });
		}

		public string getText()
		{
			return NetToolkit.Invoke<string>(delegate { return control.Text; });
		}

		public void setText(string text)
		{
			NetToolkit.Invoke(delegate { control.Text = text; });
		}

		public void select(int start_pos, int end_pos)
		{
			throw new NotImplementedException();
		}

		public void setEditable(bool editable)
		{
			throw new NotImplementedException();
		}

		public int getCaretPosition()
		{
			return getSelectionStart();
		}

		private void setCaretPositionImpl(int pos)
		{
			control.SelectionStart = pos;
			control.SelectionLength = 0;
		}

		public void setCaretPosition(int pos)
		{
			NetToolkit.Invoke(setCaretPositionImpl, pos);
		}

		public void insert(string text, int pos)
		{
			NetToolkit.Invoke(delegate { control.Text = control.Text.Insert(pos, text); });
		}

		public void insertText(string text, int pos)
		{
			insert(text, pos);
		}

        public override java.awt.Dimension getMinimumSize()
        {
            return getMinimumSize(10, 60);
        }

        public java.awt.Dimension minimumSize(int rows, int cols)
        {
            return getMinimumSize(rows, cols);
        }
        
        public java.awt.Dimension getMinimumSize(int rows, int cols)
		{
            java.awt.FontMetrics fm = getFontMetrics(target.getFont());
            return new java.awt.Dimension(fm.charWidth('0') * cols + 20, fm.getHeight() * rows + 20);
        }

        public java.awt.Dimension preferredSize(int rows, int cols)
        {
            return getPreferredSize(rows, cols);
        }

        public java.awt.Dimension getPreferredSize(int rows, int cols)
		{
            return getMinimumSize(rows, cols);
		}

		public void replaceRange(string text, int start_pos, int end_pos)
		{
			NetToolkit.Invoke(delegate { control.Text = control.Text.Substring(0, start_pos) + text + control.Text.Substring(end_pos); });
		}

		public void replaceText(string text, int start_pos, int end_pos)
		{
			replaceRange(text, start_pos, end_pos);
		}

		public java.awt.im.InputMethodRequests getInputMethodRequests()
		{
			throw new NotImplementedException();
		}

		protected sealed override RichTextBox CreateControl()
		{
			return new RichTextBox();
		}
	}

    class NetContainerPeer<T, C> : NetComponentPeer<T, C>, java.awt.peer.ContainerPeer
		where T : java.awt.Container
		where C : Control
	{
        /// <summary>
        /// The native insets of the .NET Window
        /// </summary>
		protected java.awt.Insets _insets = new java.awt.Insets(0, 0, 0, 0);

		public NetContainerPeer(java.awt.Container awtcontainer)
			: base((T)awtcontainer)
		{
		}

        internal override int getInsetsLeft()
        {
            return _insets.left; ;
        }

        internal override int getInsetsTop()
        {
            return _insets.top;
        }

        public java.awt.Insets insets()
		{
			return getInsets();
		}

		public java.awt.Insets getInsets()
		{
			return _insets;
		}

		public bool isRestackSupported()
		{
			return false;
		}

		public void cancelPendingPaint(int x, int y, int width, int height)
		{
			throw new NotImplementedException();
		}

		public void restack()
		{
			throw new NotImplementedException();
		}

		protected override C CreateControl()
		{
			throw new NotImplementedException();
		}
	}

    sealed class NetPanelPeer : NetContainerPeer<java.awt.Panel, ContainerControl>, java.awt.peer.PanelPeer
	{
		public NetPanelPeer(java.awt.Panel panel)
			: base(panel)
		{
		}

        protected override ContainerControl CreateControl()
		{
            return new ContainerControl();
		}
	}

    sealed class NetCanvasPeer : NetComponentPeer<java.awt.Canvas, Control>, java.awt.peer.CanvasPeer
	{
		public NetCanvasPeer(java.awt.Canvas canvas)
			: base(canvas)
		{
		}

		protected override Control CreateControl()
		{
            return new Control();
		}

        /**
         * Requests a GC that best suits this Canvas. The returned GC may differ
         * from the requested GC passed as the argument to this method. This method
         * must return a non-null value (given the argument is non-null as well).
         *
         * @@since 1.7
         */
        public java.awt.GraphicsConfiguration getAppropriateGraphicsConfiguration(java.awt.GraphicsConfiguration gc)
        {
            return gc;
        }
    }

    class NetWindowPeer : NetContainerPeer<java.awt.Window, Form>, java.awt.peer.WindowPeer
	{
        // we can't use NetDialogPeer as blocker may be an instance of NetPrintDialogPeer that
        // extends NetWindowPeer, not NetDialogPeer
        private NetWindowPeer modalBlocker;
        private bool modalSavedEnabled;

        private static NetWindowPeer grabbedWindow;

		public NetWindowPeer(java.awt.Window window, bool isFocusableWindow, bool isAlwaysOnTop)
			: base(window)
		{
            //form.Shown += new EventHandler(OnOpened); Will already post in java.awt.Window.show()
			control.Closing += new CancelEventHandler(OnClosing);
			control.Closed += new EventHandler(OnClosed);
			control.Activated += new EventHandler(OnActivated);
			control.Deactivate += new EventHandler(OnDeactivate);
			control.SizeChanged += new EventHandler(OnSizeChanged);
			control.Resize += new EventHandler(OnResize);
            control.Move += new EventHandler(OnMove);
			((UndecoratedForm)control).SetWindowState(isFocusableWindow, isAlwaysOnTop);
		}

        protected override void initialize()
        {
            base.initialize();
            updateIconImages();
            if (target.getBackground() == null)
            {
                AWTAccessor.getComponentAccessor().setBackground(target, target is java.awt.Dialog ? java.awt.SystemColor.control : java.awt.SystemColor.window);
            }
            control.BackColor = J2C.ConvertColor(target.getBackground());
            if (target.getForeground() == null)
            {
                target.setForeground(java.awt.SystemColor.windowText);
            }
            if (target.getFont() == null)
            {
                //target.setFont(defaultFont);
                //HACK: Sun is calling setFont(Font) here and this is calling firePropertyChange("font", oldFont, newFont)
                //but this produce a deadlock with getTreeLock() because the creating of the peer is already in this synchronized
                java.security.AccessController.doPrivileged(Delegates.toPrivilegedAction(delegate
                {
                    java.lang.Class component = typeof(java.awt.Component);
                    java.lang.reflect.Field field = component.getDeclaredField("font");
                    field.setAccessible(true);
                    field.set(target, defaultFont);
                    java.lang.reflect.Method method = component.getDeclaredMethod(
                        "firePropertyChange",
                        typeof(java.lang.String),
                        typeof(java.lang.Object),
                        typeof(java.lang.Object));
                    method.setAccessible(true);
                    method.invoke(target, "font", null, defaultFont);
                    return null;
                }));
            }
        }

		private void OnResize(object sender, EventArgs e)
		{
            // WmSizing
			SendComponentEvent(java.awt.@@event.ComponentEvent.COMPONENT_RESIZED);
			dynamicallyLayoutContainer();
		}

        private void OnMove(object sender, EventArgs e)
        {
            // WmMove
            AWTAccessor.getComponentAccessor().setLocation(target, control.Left, control.Top);
            SendComponentEvent(java.awt.@@event.ComponentEvent.COMPONENT_MOVED);
        }

		/*
		 * Although this function sends ComponentEvents, it needs to be defined
		 * here because only top-level windows need to have move and resize
		 * events fired from native code.  All contained windows have these events
		 * fired from common Java code.
		 */
		private void SendComponentEvent(int eventId)
		{
			SendEvent(new java.awt.@@event.ComponentEvent(target, eventId));
		}

		private void OnSizeChanged(object sender, EventArgs e)
		{
			// WmSize
			typeof(java.awt.Component).GetField("width", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(target, control.Width);
			typeof(java.awt.Component).GetField("height", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(target, control.Height);
			SendComponentEvent(java.awt.@@event.ComponentEvent.COMPONENT_RESIZED);
        }

        private void OnOpened(object sender, EventArgs e)
        {
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)target, java.awt.@@event.WindowEvent.WINDOW_OPENED));
        }

        private void OnClosing(object sender, CancelEventArgs e)
        {
            e.Cancel = true;
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)target, java.awt.@@event.WindowEvent.WINDOW_CLOSING));
        }

        private void OnClosed(object sender, EventArgs e)
        {
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)target, java.awt.@@event.WindowEvent.WINDOW_CLOSED));
        }

		private const int WA_ACTIVE = 1;
		private const int WA_INACTIVE = 2;

        private void OnActivated(object sender, EventArgs e)
        {
			WmActivate(WA_ACTIVE, control.WindowState == FormWindowState.Minimized, null);
        }

		private void OnDeactivate(object sender, EventArgs e)
		{
			WmActivate(WA_INACTIVE, control.WindowState == FormWindowState.Minimized, null);
		}

		private void WmActivate(int nState, bool fMinimized, Control opposite)
		{
			int type;

			if (nState != WA_INACTIVE)
			{
				type = java.awt.@@event.WindowEvent.WINDOW_GAINED_FOCUS;
			}
			else
			{
                if (grabbedWindow != null && !grabbedWindow.IsOneOfOwnersOf(this))
                {
                    grabbedWindow.Ungrab(true);
                }
                type = java.awt.@@event.WindowEvent.WINDOW_LOST_FOCUS;
			}

			SendWindowEvent(type, opposite);
		}

		private void SendWindowEvent(int id, Control opposite) { SendWindowEvent(id, opposite, 0, 0); }

		private void SendWindowEvent(int id, Control opposite, int oldState, int newState)
		{
			java.awt.AWTEvent evt = new java.awt.@@event.WindowEvent((java.awt.Window)target, id, null);

			if (id == java.awt.@@event.WindowEvent.WINDOW_GAINED_FOCUS
				|| id == java.awt.@@event.WindowEvent.WINDOW_LOST_FOCUS)
			{
				Type type = typeof(java.awt.Component).Assembly.GetType("java.awt.SequencedEvent");
				ConstructorInfo cons = type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public, null, new Type[] { typeof(java.awt.AWTEvent) }, null);
				evt = (java.awt.AWTEvent)cons.Invoke(new object[] { evt });
			}

			SendEvent(evt);
		}

        public override java.awt.Graphics getGraphics()
        {
            java.awt.Graphics g = base.getGraphics();
            java.awt.Insets insets = getInsets();
            g.translate(-insets.left, -insets.top);
            g.setClip(insets.left, insets.top, control.ClientRectangle.Width, control.ClientRectangle.Height);
            return g;
        }

        public override bool shouldClearRectBeforePaint()
        {
            // clearing the window before repainting causes the controls to "flicker" on screen
            return false;
        }

        /// <summary>
        /// Set the border style of the window and recalc the insets
        /// </summary>
        /// <param name="style">the new style</param>
        protected void setFormBorderStyle(FormBorderStyle style)
        {
            NetToolkit.BeginInvoke(delegate
            {
				control.FormBorderStyle = style;
                //Calculate the Insets one time
                //This is many faster because there no thread change is needed.
				CalcInsetsImpl();
            });
        }

		protected void CalcInsetsImpl()
		{
			Rectangle client = control.ClientRectangle;
			if (client.Height == 0)
			{
				// HACK for .NET bug if form has the minimum size then ClientRectangle is not recalulate
				// if the FormBorderStyle is changed
				Size size = control.Size;
				size.Height++;
				control.Size = size;
				size.Height--;
				control.Size = size;
				client = control.ClientRectangle;
			}
			Rectangle r = control.RectangleToScreen(client);
			int x = r.Location.X - control.Location.X;
			int y = r.Location.Y - control.Location.Y;
			// only modify this instance, since it's shared by the control-peers of this form
			_insets.top = y;
			_insets.left = x;
			_insets.bottom = control.Height - client.Height - y;
			if (control.Menu != null)
			{
				_insets.bottom += SystemInformation.MenuHeight;
			}
			_insets.right = control.Width - client.Width - x;
		}

        public override void reshape(int x, int y, int width, int height)
        {
            NetToolkit.BeginInvoke(delegate
            {
                control.SetBounds(x, y, width, height);
                //If the .NET control does not accept the new bounds (minimum size, maximum size) 
                //then we need to reflect the real bounds on the .NET site to the Java site
                Rectangle bounds = control.Bounds;
                if (bounds.X != x || bounds.Y != y)
                {
                    AWTAccessor.getComponentAccessor().setLocation(target, bounds.X, bounds.Y);
                }
                if (bounds.Width != width || bounds.Height != height)
                {
                    AWTAccessor.getComponentAccessor().setSize(target, bounds.Width, bounds.Height);
                }
            });
        }

        public void toBack()
		{
			NetToolkit.BeginInvoke(control.SendToBack);
		}

		public void toFront()
		{
			NetToolkit.BeginInvoke(control.Activate);
		}

		public bool requestWindowFocus()
		{
			return NetToolkit.Invoke<bool>(control.Focus);
		}

        public void updateAlwaysOnTopState()
        {
            // The .NET property TopMost does not work with a not focusable Window
            // that we need to set the window flags directly. To reduce double code
            // we call updateFocusableWindowState().
            updateFocusableWindowState();
        }

        public bool isModalBlocked()
        {
            return modalBlocker != null;
        }

        public void setModalBlocked(java.awt.Dialog dialog, bool blocked)
        {
            lock (target.getTreeLock()) // State lock should always be after awtLock
            {
                // use NetWindowPeer instead of NetDialogPeer because of FileDialogs and PrintDialogs
                NetWindowPeer blockerPeer = (NetWindowPeer)dialog.getPeer();
                if (blocked)
                {
                    modalBlocker = blockerPeer;
                    modalSavedEnabled = control.Enabled;
                    disable();
                }
                else
                {
                    modalBlocker = null;
                    if(modalSavedEnabled){
                        enable();
                    }
                    else
                    {
                        disable();
                    }
                }
            }
        }

        public void updateFocusableWindowState()
        {
            ((UndecoratedForm)control).SetWindowState(((java.awt.Window)target).isFocusableWindow(), ((java.awt.Window)target).isAlwaysOnTop());
        }

        public void updateIconImages()
        {
            java.util.List imageList = ((java.awt.Window)target).getIconImages();
            Icon icon;
            if (imageList == null || imageList.size() == 0)
            {
                icon = null;
            }
            else
            {
                IconFactory factory = new IconFactory();
                icon = factory.CreateIcon(imageList, SystemInformation.IconSize);
            }
            NetToolkit.BeginInvoke(delegate
               {
                   ((Form)control).Icon = icon;
               });
        }

        public void updateMinimumSize()
        {
            java.awt.Dimension dim = target.getMinimumSize();
            NetToolkit.BeginInvoke(delegate
            {
				control.MinimumSize = new Size(dim.width, dim.height);
            });
        }

        /**
         * Sets the level of opacity for the window.
         *
         * @@see Window#setOpacity(float)
         */
        public void setOpacity(float opacity)
        {
            throw new ikvm.@@internal.NotYetImplementedError();
        }

        /**
         * Enables the per-pixel alpha support for the window.
         *
         * @@see Window#setBackground(Color)
         */
        public void setOpaque(bool isOpaque)
        {
            throw new ikvm.@@internal.NotYetImplementedError();
        }


        /**
         * Updates the native part of non-opaque window.
         *
         * @@see Window#setBackground(Color)
         */
        public void updateWindow()
        {
            throw new ikvm.@@internal.NotYetImplementedError();
        }


        /**
         * Instructs the peer to update the position of the security warning.
         */
        public void repositionSecurityWarning()
        {
            throw new ikvm.@@internal.NotYetImplementedError();
        }



		protected override Form CreateControl()
		{
			return new UndecoratedForm();
		}

        protected override void OnMouseDown(object sender, MouseEventArgs ev)
        {
            if (grabbedWindow != null && !grabbedWindow.IsOneOfOwnersOf(this))
            {
                grabbedWindow.Ungrab(true);
            }
            base.OnMouseDown(sender, ev);
        }

        internal void Grab()
        {
            //copy from file awt_Windows.cpp
            if (grabbedWindow != null)
            {
                grabbedWindow.Ungrab(true);
            }
            grabbedWindow = this;
            if (Form.ActiveForm == null)
            {
                Ungrab(true);
            }
            else if (control != Form.ActiveForm)
            {
                toFront();
            }
        }

        internal void Ungrab(bool doPost)
        {
            //copy from file awt_Windows.cpp
            if (grabbedWindow == this)
            {
                if (doPost)
                {
                    SendEvent(new sun.awt.UngrabEvent(this.target));
                }
                grabbedWindow = null;
            }
        }

        private bool IsOneOfOwnersOf(NetWindowPeer window)
        {
            while (window != null)
            {
                if (window == this)
                {
                    return true;
                }
                java.awt.Container parent = window.target.getParent();
                window = parent == null ? null : (NetWindowPeer)parent.getPeer();
            }
            return false;
        }
	}

    sealed class NetFramePeer : NetWindowPeer, java.awt.peer.FramePeer
	{
		public NetFramePeer(java.awt.Frame frame, bool isFocusableWindow, bool isAlwaysOnTop)
			: base(frame, isFocusableWindow, isAlwaysOnTop)
		{
        }

        protected override void initialize()
        {
            base.initialize();
            java.awt.Frame target = (java.awt.Frame)this.target;

            if (target.getTitle() != null)
            {
                setTitle(target.getTitle());
            }
            setResizable(target.isResizable());
            setState(target.getExtendedState());
        }

		public void setMenuBar(java.awt.MenuBar mb)
		{
			if (mb == null)
			{
				NetToolkit.Invoke(delegate
				{
					control.Menu = null;
					CalcInsetsImpl();
				});
			}
			else
			{
				mb.addNotify();
				NetToolkit.Invoke(delegate
				{
					control.Menu = ((NetMenuBarPeer)mb.getPeer()).menu;
					CalcInsetsImpl();
				});
			}
		}

        public void setResizable(bool resizable)
        {
            if (((java.awt.Frame)target).isUndecorated())
            {
                setFormBorderStyle(FormBorderStyle.None);
            }
            else
            {
                if (resizable)
                {
                    setFormBorderStyle(FormBorderStyle.Sizable);
                }
                else
                {
                    setFormBorderStyle(FormBorderStyle.FixedSingle);
                }
            }
        }

		public void setTitle(string title)
		{
            NetToolkit.BeginInvoke(delegate { control.Text = title; });
		}

		public int getState()
		{
            Form f = (Form)control;
            FormWindowState state = f.WindowState;
            switch (state)
            {
                case FormWindowState.Normal:
                    return java.awt.Frame.NORMAL;
                case FormWindowState.Maximized:
                    return java.awt.Frame.MAXIMIZED_BOTH;
                case FormWindowState.Minimized:
                    return java.awt.Frame.ICONIFIED;
                default:
                    throw new InvalidEnumArgumentException();
            }
		}

		public void setState(int state)
		{
			NetToolkit.BeginInvoke(delegate
               {
                   MyForm form = (MyForm) control;
			       switch(state)
			       {
                       case java.awt.Frame.NORMAL:
                           form.WindowState = FormWindowState.Normal;
                           break;
                       case java.awt.Frame.MAXIMIZED_BOTH:
			               form.WindowState = FormWindowState.Maximized;
			               break;
                       case java.awt.Frame.ICONIFIED:
                           form.WindowState = FormWindowState.Minimized;
                           break;
                   }
               });
		}

        public void setMaximizedBounds(java.awt.Rectangle rect)
		{
            ((MyForm)control).setMaximizedBounds(rect);
		}

		public void setBoundsPrivate(int x, int y, int width, int height)
		{
			NetToolkit.Invoke(delegate { control.Bounds = new Rectangle(x, y, width, height); });
		}

        public java.awt.Rectangle getBoundsPrivate()
        {
            throw new NotImplementedException();
        }

		protected override Form CreateControl()
		{
			return new MyForm(_insets);
		}

		public void emulateActivation(bool b)
		{
			throw new NotImplementedException();
		}
    }

    sealed class NetDialogPeer : NetWindowPeer, java.awt.peer.DialogPeer
	{
		public NetDialogPeer(java.awt.Dialog target, bool isFocusableWindow, bool isAlwaysOnTop)
			: base(target, isFocusableWindow, isAlwaysOnTop)
		{
			control.MaximizeBox = false;
			control.MinimizeBox = false;
			control.ShowInTaskbar = false;
            setTitle(target.getTitle());
            setResizable(target.isResizable());
        }

		public void setTitle(string title)
		{
            NetToolkit.Invoke(delegate { control.Text = title; });
		}

        public void setResizable(bool resizable)
        {
            if (((java.awt.Dialog)target).isUndecorated())
            {
                setFormBorderStyle(FormBorderStyle.None);
            }
            else
            {
                if (resizable)
                {
                    setFormBorderStyle(FormBorderStyle.Sizable);
                }
                else
                {
                    setFormBorderStyle(FormBorderStyle.FixedSingle);
                }
            }
        }

        public void blockWindows(List toBlock)
        {
            // code copies from sun.awt.windows.WDialogPeer.java
            for (Iterator it = toBlock.iterator(); it.hasNext();) {
                java.awt.Window w = (java.awt.Window)it.next();
                java.awt.peer.WindowPeer wp = (java.awt.peer.WindowPeer)AWTAccessor.getComponentAccessor().getPeer(w);
                if (wp != null) {
                    wp.setModalBlocked((java.awt.Dialog)target, true);
                }
            }
        }

		protected override Form CreateControl()
		{
			return new MyForm(_insets);
		}
    }

    sealed class NetKeyboardFocusManagerPeer : java.awt.peer.KeyboardFocusManagerPeer
    {
        private static java.lang.reflect.Method m_removeLastFocusRequest;

        public void clearGlobalFocusOwner(java.awt.Window activeWindow)
        {
        }

        public java.awt.Component getCurrentFocusOwner()
        {
            return getNativeFocusOwner();
        }

        public void setCurrentFocusOwner(java.awt.Component component)
        {
        }

        public java.awt.Window getCurrentFocusedWindow()
        {
            return getNativeFocusedWindow();
        }

		public void setCurrentFocusedWindow(java.awt.Window w)
		{
		}

		private static java.awt.Component getNativeFocusOwner()
		{
			return NetToolkit.Invoke<java.awt.Component>(delegate
			{
				UndecoratedForm form = Form.ActiveForm as UndecoratedForm;
				if (form != null)
				{
					Control control = form.ActiveControl;
					while (control is ContainerControl)
					{
						control = ((ContainerControl)control).ActiveControl;
					}
					NetComponentPeer peer;
					if (control == null)
					{
						peer = NetComponentPeer.FromControl(form);
					}
					else
					{
						while ((peer = NetComponentPeer.FromControl(form)) == null)
						{
							control = control.Parent;
						}
					}
					return peer.Target;
				}
				return null;
			});
		}

		private static java.awt.Window getNativeFocusedWindow()
        {
			return NetToolkit.Invoke<java.awt.Window>(delegate
            {
				Form form = Form.ActiveForm;
                if (form != null)
                {
					NetComponentPeer peer = NetComponentPeer.FromControl(form);
					if (peer != null)
					{
						return (java.awt.Window)peer.Target;
					}
                }
                return null;
            });
        }

		public static void removeLastFocusRequest(java.awt.Component heavyweight)
        {
            try
            {
                if (m_removeLastFocusRequest == null)
                {
					java.security.AccessController.doPrivileged(Delegates.toPrivilegedAction(delegate
					{
						java.lang.Class keyboardFocusManagerCls = typeof(java.awt.KeyboardFocusManager);
						java.lang.reflect.Method method = keyboardFocusManagerCls.getDeclaredMethod(
							"removeLastFocusRequest",
							typeof(java.awt.Component));
						method.setAccessible(true);
						m_removeLastFocusRequest = method;
						return null;
					}));
				}
                m_removeLastFocusRequest.invoke(null, new Object[] { heavyweight });
            }
            catch (java.lang.reflect.InvocationTargetException ite)
            {
                ite.printStackTrace();
            }
            catch (java.lang.IllegalAccessException ex)
            {
                ex.printStackTrace();
            }
        }
    }

    sealed class NetListPeer : NetComponentPeer<java.awt.List, ListBox>, java.awt.peer.ListPeer
	{
		internal NetListPeer(java.awt.List target)
			: base(target)
		{
			control.IntegralHeight = false;
			setMultipleMode(target.isMultipleMode());
			for (int i = 0; i < target.getItemCount(); i++)
			{
				add(target.getItem(i), i);
				if (target.isSelected(i))
				{
					select(i);
				}
			}
			makeVisible(target.getVisibleIndex());
		}

		public void add(string item, int index)
		{
			NetToolkit.Invoke(delegate { control.Items.Insert(index, item); });
		}

		public void addItem(string item, int index)
		{
			add(item, index);
		}

		public void clear()
		{
			NetToolkit.Invoke(delegate { control.Items.Clear(); });
		}

		public void delItems(int start_index, int end_index)
		{
			NetToolkit.Invoke(delegate
			{
				for (int i = start_index; i < end_index; i++)
				{
					control.Items.RemoveAt(start_index);
				}
			});
		}

		public void deselect(int index)
		{
			NetToolkit.Invoke(delegate { control.SelectedIndices.Remove(index); });
		}

		public int[] getSelectedIndexes()
		{
			return NetToolkit.Invoke<int[]>(delegate
			{
				ListBox.SelectedIndexCollection sic = control.SelectedIndices;
				int[] indexes = new int[sic.Count];
				sic.CopyTo(indexes, 0);
				return indexes;
			});
		}

		public void makeVisible(int index)
		{
			NetToolkit.Invoke(delegate { control.TopIndex = index; });
		}

		public java.awt.Dimension minimumSize(int s)
		{
			return getMinimumSize(s);
		}

		public java.awt.Dimension preferredSize(int s)
		{
			return getPreferredSize(s);
		}

		public void removeAll()
		{
			clear();
		}

		public void select(int index)
		{
			NetToolkit.Invoke(delegate { control.SelectedIndices.Add(index); });
		}

		public void setMultipleMode(bool multi)
		{
			NetToolkit.Invoke(delegate { control.SelectionMode = multi ? SelectionMode.MultiSimple : SelectionMode.One; });
		}

		public void setMultipleSelections(bool multi)
		{
			setMultipleMode(multi);
		}

		public java.awt.Dimension getPreferredSize(int s)
		{
			return getMinimumSize(s);
		}

		public java.awt.Dimension getMinimumSize(int s)
		{
			return new java.awt.Dimension(100, 100);
		}

		protected override ListBox CreateControl()
		{
			return new ListBox();
		}
	}

    sealed class NetDesktopPeer : java.awt.peer.DesktopPeer
	{
		private static void ShellExecute(string file, string verb)
		{
			try
			{
				ProcessStartInfo psi = new ProcessStartInfo(file);
				psi.UseShellExecute = true;
				psi.Verb = verb;
				Process p = Process.Start(psi);
				if (p != null)
				{
					p.Dispose();
				}
			}
			catch (System.ComponentModel.Win32Exception x)
			{
				throw new java.io.IOException(x.Message);
			}
		}

		public void browse(URI uri)
		{
			ShellExecute(uri.toString(), "open");
		}

		public void edit(java.io.File f)
		{
			ShellExecute(f.toString(), "edit");
		}

		public bool isSupported(java.awt.Desktop.Action da)
		{
			return da == java.awt.Desktop.Action.BROWSE
				|| da == java.awt.Desktop.Action.EDIT
				|| da == java.awt.Desktop.Action.MAIL
				|| da == java.awt.Desktop.Action.OPEN
				|| da == java.awt.Desktop.Action.PRINT;
		}

		public void mail(URI uri)
		{
			if (uri.getScheme().ToLower(System.Globalization.CultureInfo.InvariantCulture) != "mailto")
			{
				throw new java.lang.IllegalArgumentException("URI scheme is not \"mailto\"");
			}
			ShellExecute(uri.toString(), "open");
		}

		public void mail()
		{
			ShellExecute("mailto:", "open");
		}

		public void open(java.io.File f)
		{
			ShellExecute(f.toString(), "open");
		}

		public void print(java.io.File f)
		{
			ShellExecute(f.toString(), "print");
		}
	}

    //also WFileDialogPeer extends from WWindowPeer
	class NetFileDialogPeer : NetWindowPeer, java.awt.peer.FileDialogPeer
	{
		internal NetFileDialogPeer(java.awt.FileDialog dialog, bool isFocusableWindow, bool isAlwaysOnTop)
			: base(dialog, isFocusableWindow, isAlwaysOnTop)
		{
		}

		public void setDirectory(string str)
		{
		}

		public void setFile(string str)
		{
		}

		public void setFilenameFilter(java.io.FilenameFilter ff)
		{
		}

		public void setResizable(bool b)
		{
		}

		public void setTitle(string str)
		{
		}

		public override void show()
		{
            java.awt.FileDialog dialog = (java.awt.FileDialog)target;
			if (dialog.getMode() != java.awt.FileDialog.LOAD)
			{
				throw new NotImplementedException();
			}
			Thread t = new Thread((ThreadStart)delegate
			{
				using (OpenFileDialog dlg = new OpenFileDialog())
				{
					if (dlg.ShowDialog() == DialogResult.OK)
					{
						dialog.setFile(Path.GetFileName(dlg.FileName));
						dialog.setDirectory(Path.GetDirectoryName(dlg.FileName) + java.io.File.separator);
						dialog.hide();
					}
					else
					{
						dialog.setFile(null);
						dialog.hide();
					}
				}
			});
			t.SetApartmentState(ApartmentState.STA);
			t.Start();
		}

        public void blockWindows(List toBlock)
        {
            // code copies from sun.awt.windows.WFileDialogPeer.java
            for (Iterator it = toBlock.iterator(); it.hasNext(); ) {
                java.awt.Window w = (java.awt.Window)it.next();
                java.awt.peer.WindowPeer wp = (java.awt.peer.WindowPeer)AWTAccessor.getComponentAccessor().getPeer(w);
                if (wp != null) {
                    wp.setModalBlocked((java.awt.Dialog)target, true);
                }
            }
        }
	}

    class NetSystemTrayPeer : java.awt.peer.SystemTrayPeer
    {
        //private java.awt.SystemTray target;

        internal NetSystemTrayPeer(java.awt.SystemTray target)
        {
            //this.target = target;
        }

        public java.awt.Dimension getTrayIconSize()
        {
            return new java.awt.Dimension(NetTrayIconPeer.TRAY_ICON_WIDTH, NetTrayIconPeer.TRAY_ICON_HEIGHT);
        }

        public bool isSupported()
        {
            return ((NetToolkit) java.awt.Toolkit.getDefaultToolkit()).isTraySupported();
        }
    }

    sealed class NetPopupMenuPeer : java.awt.peer.PopupMenuPeer
    {
		private readonly java.awt.PopupMenu target;
		private readonly ContextMenu menu = new ContextMenu();

		internal NetPopupMenuPeer(java.awt.PopupMenu target)
		{
			this.target = target;
			for (int i = 0; i < target.getItemCount(); i++)
			{
				addItem(target.getItem(i));
			}
		}

		public void show(java.awt.Event e)
        {
			show((java.awt.Component)e.target, new java.awt.Point(e.x, e.y));
        }

        public void show(java.awt.Component origin, java.awt.Point p)
        {
			NetComponentPeer peer = (NetComponentPeer)origin.getPeer();
			Point pt = new Point(p.x, p.y);
			pt.Offset(- peer.getInsetsLeft(), - peer.getInsetsTop());
			NetToolkit.Invoke(delegate { menu.Show(peer.Control, pt); });
        }

        public void dispose()
        {
			NetToolkit.Invoke(delegate { menu.Dispose(); });
        }

        public void setFont(java.awt.Font f)
        {
            throw new NotImplementedException();
        }

        public void disable()
        {
			setEnabled(false);
        }

        public void enable()
        {
			setEnabled(true);
		}

        public void setEnabled(bool b)
        {
			NetToolkit.Invoke(delegate
			{
				for (int i = 0; i < target.getItemCount(); i++)
				{
					menu.MenuItems[i].Enabled = b && target.getItem(i).isEnabled();
				}
			});
		}

        public void setLabel(string str)
        {
        }

        public void addItem(java.awt.MenuItem item)
        {
			if (item.getPeer() == null)
			{
				item.addNotify();
			}
			if (item.getPeer() is NetMenuItemPeer)
			{
				NetToolkit.Invoke(delegate { menu.MenuItems.Add(((NetMenuItemPeer)item.getPeer()).menuitem); });
			}
			else
			{
				NetToolkit.Invoke(delegate { menu.MenuItems.Add(((NetMenuPeer)item.getPeer()).menu); });
			}
		}

        public void addSeparator()
        {
			NetToolkit.Invoke(delegate { menu.MenuItems.Add(new MenuItem("-")); });
        }

        public void delItem(int i)
        {
			NetToolkit.Invoke(delegate { menu.MenuItems.RemoveAt(i); });
		}
    }

    class NetTrayIconPeer : java.awt.peer.TrayIconPeer
    {
        internal const int TRAY_ICON_WIDTH = 16;
        internal const int TRAY_ICON_HEIGHT = 16;
        internal const int TRAY_ICON_MASK_SIZE = TRAY_ICON_WIDTH*TRAY_ICON_HEIGHT/8;

        private java.awt.TrayIcon target;
        private NotifyIcon notifyIcon;
        private java.awt.Frame popupParent = new java.awt.Frame("PopupMessageWindow");
        private java.awt.PopupMenu popup;
        private bool disposed;
        private bool isPopupMenu;

        internal NetTrayIconPeer(java.awt.TrayIcon target)
        {
            this.target = target;
            popupParent.addNotify();
            create();
            updateImage();
        }

        public void displayMessage(string caption, string text, string messageType)
        {
            ToolTipIcon icon = ToolTipIcon.None;
            switch(messageType)
            {
                case "ERROR" :
                    icon = ToolTipIcon.Error;
                    break;
                case "WARNING" :
                    icon = ToolTipIcon.Warning;
                    break;
                case "INFO" :
                    icon = ToolTipIcon.Info;
                    break;
                case "NONE" :
                    icon = ToolTipIcon.None;
                    break;
            }
            NetToolkit.BeginInvoke(delegate
                                  {
                                      notifyIcon.ShowBalloonTip(10000, caption, text, icon);
                                  });
        }

        private void create()
        {
            NetToolkit.Invoke(delegate
                                  {
                                      notifyIcon = new NotifyIcon();
                                      hookEvents();
                                      notifyIcon.Visible = true;
                                  });
        }

        public void dispose()
        {
            bool callDisposed = true;
            lock (this)
            {
                if (disposed)
                    callDisposed = false;
                disposed = true;
            }
            if (callDisposed)
                disposeImpl();
        }

        protected void disposeImpl()
        {
            if (popupParent != null)
            {
                popupParent.dispose();
            }
            NetToolkit.targetDisposedPeer(target, this);
            NetToolkit.BeginInvoke(nativeDispose);
        }

        private void hookEvents()
        {
            notifyIcon.MouseClick += new MouseEventHandler(OnClick);
            notifyIcon.MouseDoubleClick += new MouseEventHandler(OnDoubleClick);
            notifyIcon.MouseDown += new MouseEventHandler(OnMouseDown);
            notifyIcon.MouseUp += new MouseEventHandler(OnMouseUp);
            notifyIcon.MouseMove += new MouseEventHandler(OnMouseMove);
        }

        private void unhookEvents()
        {
            notifyIcon.MouseClick -= new MouseEventHandler(OnClick);
            notifyIcon.MouseDoubleClick -= new MouseEventHandler(OnDoubleClick);
            notifyIcon.MouseDown -= new MouseEventHandler(OnMouseDown);
            notifyIcon.MouseUp -= new MouseEventHandler(OnMouseUp);
            notifyIcon.MouseMove -= new MouseEventHandler(OnMouseMove);
        }

        internal void postEvent(java.awt.AWTEvent evt)
        {
            NetToolkit.postEvent(NetToolkit.targetToAppContext(target), evt);
        }
        
        private void postMouseEvent(MouseEventArgs ev, int id, int clicks)
        {
            long when = java.lang.System.currentTimeMillis();
            int modifiers = NetComponentPeer.GetMouseEventModifiers(ev);
            int button = NetComponentPeer.GetButton(ev);
            int clickCount = clicks;
            int x = Control.MousePosition.X;
            int y = Control.MousePosition.Y;
            bool isPopup = isPopupMenu;
            java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate
            {
                java.awt.Component fake = new java.awt.TextField();
                java.awt.@@event.MouseEvent mouseEvent = new java.awt.@@event.MouseEvent(fake, id, when, modifiers, x, y, clickCount, isPopup, button);
                mouseEvent.setSource(target);
                postEvent(mouseEvent);
            }));
            isPopupMenu = false;
        }

        private void postMouseEvent(EventArgs ev, int id)
        {
            long when = java.lang.System.currentTimeMillis();
            int modifiers = NetComponentPeer.GetModifiers(Control.ModifierKeys);
            int button = 0;
            int clickCount = 0;
            int x = Control.MousePosition.X;
            int y = Control.MousePosition.Y;
            bool isPopup = isPopupMenu;
            java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate
            {
                java.awt.Component fake = new java.awt.TextField();
                java.awt.@@event.MouseEvent mouseEvent = new java.awt.@@event.MouseEvent(fake, id, when, modifiers, x, y, clickCount, isPopup, button);
                mouseEvent.setSource(target);
                postEvent(mouseEvent);
            }));
            isPopupMenu = false;
        }

        protected virtual void OnMouseDown(object sender, MouseEventArgs ev)
        {
            isPopupMenu = false;
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_PRESSED, ev.Clicks);
        }

        private void OnClick(object sender, MouseEventArgs ev)
        {
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_CLICKED, ev.Clicks);
        }

        private void OnDoubleClick(object sender, MouseEventArgs ev)
        {
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_CLICKED, ev.Clicks);
            long when = java.lang.System.currentTimeMillis();
            int modifiers = NetComponentPeer.GetModifiers(Control.ModifierKeys);
            postEvent(new java.awt.@@event.ActionEvent(target, java.awt.@@event.ActionEvent.ACTION_PERFORMED, target.getActionCommand(), when, modifiers));
        }

        private void OnMouseUp(object sender, MouseEventArgs ev)
        {
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_RELEASED, ev.Clicks);
        }

        private void OnMouseEnter(object sender, EventArgs ev)
        {
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_ENTERED);
        }

        private void OnMouseLeave(object sender, EventArgs ev)
        {
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_EXITED);
        }

        protected virtual void OnMouseMove(object sender, MouseEventArgs ev)
        {
            if ((ev.Button & (MouseButtons.Left | MouseButtons.Right)) != 0)
            {
                postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_DRAGGED, ev.Clicks);
            }
            else
            {
                postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_MOVED, ev.Clicks);
            }
        }

        private void nativeDispose()
        {
            if (notifyIcon!=null)
            {
                unhookEvents();
                notifyIcon.Dispose();
            }
        }

        public void setToolTip(string str)
        {
            NetToolkit.BeginInvoke(delegate { notifyIcon.Text = str; });
        }

        protected bool isDisposed()
        {
            return disposed;
        }

        public void showPopupMenu(int x, int y)
        {
            if (isDisposed())
                return;
            java.lang.Runnable runnable = Delegates.toRunnable(delegate
               {
                   java.awt.PopupMenu newPopup = ((java.awt.TrayIcon)target).getPopupMenu();
                    if (popup != newPopup) {
                        if (popup != null) {
                            popupParent.remove(popup);
                        }
                        if (newPopup != null) {
                            popupParent.add(newPopup);
                        }
                        popup = newPopup;
                    }
                    if (popup != null) {
                        ((NetPopupMenuPeer)popup.getPeer()).show(popupParent, new java.awt.Point(x, y));
                    }
               });
            SunToolkit.executeOnEventHandlerThread(target, runnable);
        }

        public void updateImage()
        {
            java.awt.Image image = ((java.awt.TrayIcon) target).getImage();
            if (image != null)
            {
                updateNativeImage(image);
            }
        }

        private void updateNativeImage(java.awt.Image image)
        {
            lock (this)
            {
                if (isDisposed())
                    return;
                bool autosize = ((java.awt.TrayIcon) target).isImageAutoSize();

                using (Bitmap bitmap = getNativeImage(image, autosize))
                {
                    IntPtr hicon = bitmap.GetHicon();
                    Icon icon = Icon.FromHandle(hicon);
                    notifyIcon.Icon = icon;
                }
            }
        }

        private Bitmap getNativeImage(java.awt.Image image, bool autosize)
        {
            if (image is NoImage)
                return new Bitmap(TRAY_ICON_WIDTH, TRAY_ICON_HEIGHT);
            else
            {
                Image netImage = J2C.ConvertImage(image);
                if (autosize)
                    return new Bitmap(netImage, TRAY_ICON_WIDTH, TRAY_ICON_HEIGHT);
                else
                    return new Bitmap(netImage);
            }
        }
    }


    internal class NetMouseInfoPeer : java.awt.peer.MouseInfoPeer
    {
        public int fillPointWithCoords(java.awt.Point p)
        {
            p.x = Cursor.Position.X;
            p.y = Cursor.Position.Y;
            //TODO multi screen device
            return 0; //return the number of the screen device
        }

        [DllImport("user32.dll")]
        private static extern IntPtr WindowFromPoint(POINT Point);

        [StructLayout(LayoutKind.Sequential)]
        private struct POINT
        {
            public int X;
            public int Y;

            internal POINT(Point pt)
            {
                this.X = pt.X;
                this.Y = pt.Y;
            }
        }

        [System.Security.SecuritySafeCritical]
        public bool isWindowUnderMouse(java.awt.Window window)
        {
            if (NetToolkit.isWin32())
            {
                NetWindowPeer peer = (NetWindowPeer)window.getPeer();
                if (peer != null)
                {
                    IntPtr hWnd = WindowFromPoint(new POINT(Cursor.Position));
                    return peer.control.Handle.Equals(hWnd);
                }
                return false;
            }
            else
            {
                throw new NotImplementedException();
            }
        }
    }
    
    public class NetClipboard : java.awt.datatransfer.Clipboard
    {
        public static readonly java.awt.datatransfer.FlavorTable flavorMap =
            (java.awt.datatransfer.FlavorTable)java.awt.datatransfer.SystemFlavorMap.getDefaultFlavorMap();

        public NetClipboard() : base("System") { }

        public override void setContents(java.awt.datatransfer.Transferable contents, java.awt.datatransfer.ClipboardOwner owner)
        {
            if (contents == null)
            {
                throw new java.lang.NullPointerException("contents");
            }

            java.awt.datatransfer.ClipboardOwner oldOwner = this.owner;
            java.awt.datatransfer.Transferable oldContents = this.contents;
            try
            {
                this.owner = owner;
                this.contents = new sun.awt.datatransfer.TransferableProxy(contents, true);

                setContentsNative(contents);
            }
            finally
            {
                if (oldOwner != null && oldOwner != owner)
                {
                    java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate() 
                        {
                            oldOwner.lostOwnership(this, oldContents);
                        }));
                }
            }
        }

        private void setContentsNative(java.awt.datatransfer.Transferable contents)
        {
            IDataObject clipObj = NetDataTransferer.getInstanceImpl().getDataObject(contents, flavorMap);
            NetToolkit.BeginInvoke(delegate
                                       {
                                           Clipboard.SetDataObject(clipObj, true);
                                       });
        }

        public override java.awt.datatransfer.Transferable getContents(object requestor)
        {
            if (contents != null)
            {
                return contents;
            }
            return new NetClipboardTransferable(NetToolkit.Invoke<IDataObject>(Clipboard.GetDataObject));
        }
    }

    public class NetClipboardTransferable : java.awt.datatransfer.Transferable
    {
        private readonly Map flavorToData = new HashMap();
        private readonly java.awt.datatransfer.DataFlavor[] flavors;
        public NetClipboardTransferable(IDataObject data)
        {
            flavorToData = NetDataTransferer.getInstanceImpl().translateFromClipboard(data);
            flavors = (java.awt.datatransfer.DataFlavor[])flavorToData.keySet().toArray(new java.awt.datatransfer.DataFlavor[0]);
        }

        public java.awt.datatransfer.DataFlavor[] getTransferDataFlavors()
        {
            return flavors;
        }
        public object getTransferData(java.awt.datatransfer.DataFlavor df)
        {
            return flavorToData.get(df);
        }

        public bool isDataFlavorSupported(java.awt.datatransfer.DataFlavor df)
        {
            return flavorToData.containsKey(df);
        }
    }

    public class NetDataTransferer : sun.awt.IkvmDataTransferer
    {
        class NetToolkitThreadBlockedHandler : sun.awt.datatransfer.ToolkitThreadBlockedHandler
        {
            private bool locked;
            private Thread owner;
            
            protected bool isOwned()
            {
                return (locked && Thread.CurrentThread == owner);
            }

		    public void enter() 
            {
                if (!isOwned())
                {
                    throw new java.lang.IllegalMonitorStateException();
                }
                unlock();
				if (Application.MessageLoop)
				{
					Application.DoEvents();
				}
		        @@lock();
		    }

		    public void exit() 
            {
                if (!isOwned())
                {
                    throw new java.lang.IllegalMonitorStateException();
                }
            }

            public void @@lock() {
                lock(this)
                {
                    if (locked && Thread.CurrentThread == owner)
                    {
                        throw new java.lang.IllegalMonitorStateException();
                    }
                    do
                    {
                        if (!locked)
                        {
                            locked = true;
                            owner = Thread.CurrentThread;
                        }
                        else
                        {
                            try
                            {
                                Monitor.Wait(this);
                            }
                            catch (ThreadInterruptedException)
                            {
                                // try again
                            }
                        }
                    } while (owner != Thread.CurrentThread);
                }
            }

            public void unlock()
            {
                lock (this)
                {
                    if (Thread.CurrentThread != owner)
                    {
                        throw new java.lang.IllegalMonitorStateException();
                    }
                    owner = null;
                    locked = false;
                    Monitor.Pulse(this);
                }
            }
        }


        private static readonly NetDataTransferer instance = new NetDataTransferer();
        private static readonly NetToolkitThreadBlockedHandler handler = new NetToolkitThreadBlockedHandler();

        public static NetDataTransferer getInstanceImpl()
        {
            return instance;
        }

        internal long[] getClipboardFormatCodes(string[] formats)
        {
            long[] longData = new long[formats.Length];
            for(int i=0; i<formats.Length; i++)
            {
                DataFormats.Format dataFormat = DataFormats.GetFormat(formats[i]);
                longData[i] = dataFormat==null?0:dataFormat.Id;
            }
            return longData;
        }

        internal string getNativeClipboardFormatName(long format)
        {
            DataFormats.Format dataFormat = DataFormats.GetFormat((int)format);
            if (dataFormat == null)
                return null;
            else
                return dataFormat.Name;
        }

        internal Map translateFromClipboard(IDataObject data)
        {
            java.awt.datatransfer.FlavorTable defaultFlavorMap = (java.awt.datatransfer.FlavorTable)java.awt.datatransfer.SystemFlavorMap.getDefaultFlavorMap();
            Map/*<DataFlavor,object>*/ map = new HashMap();
            if (data == null)
            {
                return map;
            }
            string[] formats = data.GetFormats();
            if (formats != null && formats.Length > 0)
            {
                long[] longFormats = getClipboardFormatCodes(formats);
                Map /*<DataFlavor,long>*/ flavorMap = getFlavorsForFormats(longFormats, defaultFlavorMap);
                java.awt.datatransfer.DataFlavor[] flavors =
                    (java.awt.datatransfer.DataFlavor[])
                    (flavorMap.keySet().toArray(new java.awt.datatransfer.DataFlavor[0]));
                for(int i=0; i<flavors.Length; i++)
                {
                    java.awt.datatransfer.DataFlavor df = flavors[i];
                    long format = ((java.lang.Long) flavorMap.get(df)).longValue();
                    string stringFormat = getNativeClipboardFormatName(format);
                    if (stringFormat==null) continue; // clipboard format is not registered in Windows system
                    object formatData = data.GetData(stringFormat);
                    if (formatData == null) continue; // no data for that format
                    object translatedData = null;
                    if (df.isFlavorJavaFileListType())
                    {
                        // translate string[] into java.util.List<java.io.File>
                        string[] nativeFileList = (string[])formatData;
                        List fileList = new ArrayList(nativeFileList.Length);
                        for (int j = 0; j < nativeFileList.Length; j++)
                        {
                            java.io.File file = new java.io.File(nativeFileList[i]);
                            fileList.add(file);
                        }
                        translatedData = fileList;
                    }
                    else if (java.awt.datatransfer.DataFlavor.imageFlavor.equals(df) && formatData is Bitmap)
                    {
                        // translate System.Drawing.Bitmap into java.awt.Image
                        translatedData = new java.awt.image.BufferedImage((Bitmap) formatData);
                    }
                    else if (formatData is string)
                    {
                        if (df.isFlavorTextType())
                            translatedData = formatData;
                        else if (((java.lang.Class)typeof(java.io.Reader)).equals(df.getRepresentationClass()))
                            translatedData = new java.io.StringReader((string) formatData);
                        else if (((java.lang.Class)typeof(java.io.InputStream)).equals(df.getRepresentationClass()))
                            translatedData = new java.io.StringBufferInputStream((string)formatData);
                        else
                            throw new java.awt.datatransfer.UnsupportedFlavorException(df);
                    }
                    if (translatedData!=null)
                        map.put(df, translatedData);
                }
            }
            return map;
        }

        internal IDataObject getDataObject(java.awt.datatransfer.Transferable transferable, java.awt.datatransfer.FlavorTable flavorMap)
        {
            DataObject obj = new DataObject();
            SortedMap/*<java.lang.Long,java.awt.datatransfer.DataFlavor>*/ formatMap = getFormatsForTransferable(transferable, flavorMap);
            for (Iterator iterator = formatMap.entrySet().iterator(); iterator.hasNext();)
            {
                Map.Entry entry = (Map.Entry) iterator.next();
                java.lang.Long lFormat = (java.lang.Long) entry.getKey();
                long format = lFormat == null ? -1 : lFormat.longValue();
                java.awt.datatransfer.DataFlavor flavor = (java.awt.datatransfer.DataFlavor) entry.getValue();
                object contents = transferable.getTransferData(flavor);
                if (contents==null) continue;
                try
                {
                    if (java.awt.datatransfer.DataFlavor.javaFileListFlavor.equals(flavor))
                    {
                        List list = (List)contents;
                        System.Collections.Specialized.StringCollection files =
                            new System.Collections.Specialized.StringCollection();
                        for (int i = 0; i < list.size(); i++)
                        {
                            files.Add(((java.io.File) list.get(i)).getAbsolutePath());
                        }
                        obj.SetFileDropList(files);
                    }
                    else if (flavor.isFlavorTextType())
                    {
                        if (contents is string) 
                        {
                            obj.SetText((string) transferable.getTransferData(flavor));
                        }
                        else
                        {
                            try
                            {
                                java.io.Reader reader = flavor.getReaderForText(transferable);
                                java.io.StringWriter writer = new java.io.StringWriter();
                                char[] buffer = new char[1024];
                                int n;
                                while ((n = reader.read(buffer)) != -1)
                                {
                                    writer.write(buffer, 0, n);
                                }
                                obj.SetText(writer.toString());
                            }
                            catch
                            {
                            }
                        }
                    }
                    else if (java.awt.datatransfer.DataFlavor.imageFlavor.equals(flavor))
                    {
                        java.awt.Image image = contents as java.awt.Image;
                        if (image != null)
                        {
                            Image netImage = J2C.ConvertImage(image);
                            if (netImage != null)
                            {
                                obj.SetImage(netImage);
                            }
                        }
                    }
                    else if (flavor.isRepresentationClassCharBuffer())
                    {
                        if (!(isFlavorCharsetTextType(flavor) && isTextFormat(format)))
                        {
                            throw new IOException("cannot transfer non-text data as CharBuffer");
                        }
                        java.nio.CharBuffer buffer = (java.nio.CharBuffer)contents;
                        int size = buffer.remaining();
                        char[] chars = new char[size];
                        buffer.get(chars, 0, size);
                        obj.SetText(new string(chars));
                    }
                    else
                    {
                        // don't know what to do with it...
                        obj.SetData(transferable.getTransferData(flavor));
                    }
                }
                catch (java.io.IOException e)
                {
                    if (!(flavor.isMimeTypeEqual(java.awt.datatransfer.DataFlavor.javaJVMLocalObjectMimeType) &&
                          e is java.io.NotSerializableException))
                    {
                        e.printStackTrace();
                    }
                }
            }
            return obj;
        }

        protected internal override string getClipboardFormatName(long format)
        {
            return getNativeClipboardFormatName(format);
        }

        protected internal override byte[] imageToStandardBytes(java.awt.Image image, string mimeType)
        {
            if (image is NoImage) return null;
            Image netImage = J2C.ConvertImage(image);
            ImageFormat format;
            switch(mimeType)
            {
                case "image/jpg":
                case "image/jpeg":
                    format = ImageFormat.Jpeg;
                    break;
                case "image/png":
                    format = ImageFormat.Png;
                    break;
                case "image/gif":
                    format = ImageFormat.Gif;
                    break;
                case "image/x-win-metafile":
                case "image/x-wmf":
                case "image/wmf":
                    format = ImageFormat.Wmf;
                    break;
                default:
                    return null;
            }
            using(MemoryStream stream = new MemoryStream())
            {
                netImage.Save(stream, format);
                return stream.GetBuffer();
            }
        }

        public override sun.awt.datatransfer.ToolkitThreadBlockedHandler getToolkitThreadBlockedHandler()
        {
            return handler;
        }

        protected internal override java.io.ByteArrayOutputStream convertFileListToBytes(java.util.ArrayList fileList)
        {
            throw new ikvm.@@internal.NotYetImplementedError();
        }

		protected internal override java.awt.Image platformImageBytesToImage(byte[] barr, long l)
		{
			throw new NotImplementedException();
		}
	}

}
@


1.114
log
@Integrated OpenJDK 8u45.
@
text
@d1891 5
a1895 1
			java.awt.Container parent = SunToolkit.getNativeContainer(target);
@


1.113
log
@Fixed drag-n-drop coordinates. Patch by Daniel Zatonyi <dzatonyi@@chemaxon.com>.
@
text
@a289 2
        public static readonly String DATA_TRANSFERER_CLASS_NAME = typeof(NetDataTransferer).AssemblyQualifiedName;

a330 1
            setDataTransfererClassName(DATA_TRANSFERER_CLASS_NAME);
d1039 5
@


1.112
log
@Handle more text sources for clipboard copy by using an appropriate Reader for the source data. Patch by Daniel Zatonyi <dzatonyi@@chemaxon.com>.
@
text
@d1417 5
a1421 1
            return base.postDropTargetEvent(component, x, y,
@


1.111
log
@Added support for "high contrast" desktop property. Inspired by patch from Daniel Zatonyi <dzatonyi@@chemaxon.com>.
@
text
@d5543 1
d5545 19
@


1.110
log
@Bug fix. NetComponentPeer.getLocationOnScreen() should take insets into account. Thanks to Maria Papendieck <maria.papendieck@@pure-systems.com> for this fix.
@
text
@d780 1
a780 1
            if ("win.defaultGUI.font".Equals(name))
d782 6
a787 2
                Font font = Control.DefaultFont;
                return C2J.ConvertFont(font);
a788 1
            return null;
@


1.109
log
@- Prevent unfocable windows from being activated by mouse click.
- Fixed clipboard access to use the right thread.
(Based on patch by Maria Papendieck of pure-systems.)
@
text
@d2641 1
a2641 1
                Point p = new Point();
@


1.108
log
@First part of OpenJDK 8 integration.
@
text
@d130 13
d5316 1
a5316 1
            return new NetClipboardTransferable(Clipboard.GetDataObject());
@


1.107
log
@Merged OpenJDK 7u40 b34, except for java.lang.invoke and sun.invoke packages.
@
text
@a570 13
        [Obsolete]
        public override string[] getFontList()
        {
            // This method is deprecated and Sun's JDK only returns these fonts as well
            return new string[] { "Dialog", "SansSerif", "Serif", "Monospaced", "DialogInput" };
        }

        [Obsolete]
        public override java.awt.FontMetrics getFontMetrics(java.awt.Font font)
        {
            return sun.font.FontDesignMetrics.getMetrics(font);
        }

d1021 5
d4420 5
d5617 6
a5622 1
    }
@


1.106
log
@- Allow IKVM.AWT.WinForms.dll access to internals of class library.
- Made BufferedImage.toBitmap() package private.
@
text
@d542 1
a542 1
        public override java.awt.peer.KeyboardFocusManagerPeer createKeyboardFocusManagerPeer(java.awt.KeyboardFocusManager manager)
d544 1
a544 1
            return new NetKeyboardFocusManagerPeer(manager);
d4133 1
a4133 1
        public void setAlwaysOnTop(bool alwaysOnTop)
a4485 1
        //private readonly java.awt.KeyboardFocusManager manager;
a4487 5
        public NetKeyboardFocusManagerPeer(java.awt.KeyboardFocusManager manager)
        {
            //this.manager = manager;
        }

d4506 4
d4563 11
a4573 3
                    m_removeLastFocusRequest = SunToolkit.getMethod(typeof(java.awt.KeyboardFocusManager), "removeLastFocusRequest",
                                                                  new java.lang.Class[] { typeof(java.awt.Component) });
                }
@


1.105
log
@Prepare the usage of SunGraphics2D as super class of all graphics classes and pass the destination object in the constructor.
Remove a not used method (createGraphics) from IkvmToolkit.
@
text
@d283 1
a283 1
		protected override java.awt.EventQueue getSystemEventQueueImpl()
d332 1
a332 1
        protected override void loadSystemColors(int[] systemColors)
d728 1
a728 1
        protected override java.awt.peer.DesktopPeer createDesktopPeer(java.awt.Desktop target)
d752 1
a752 1
        protected override void initializeDesktopProperties()
d778 1
a778 1
        protected override Object lazilyLoadDesktopProperty(String name)
d788 1
a788 1
        protected override java.awt.peer.MouseInfoPeer getMouseInfoPeer() {
d886 1
a886 1
        protected override int getScreenHeight()
d891 1
a891 1
        protected override int getScreenWidth()
d947 1
a947 1
        protected override bool syncNativeQueue(long l)
d1283 1
a1283 1
        protected override void startDrag(java.awt.datatransfer.Transferable trans, long[] formats, Map formatMap)
d1338 1
a1338 1
        protected override void setNativeCursor(long nativeCtxt, java.awt.Cursor c, int cType)
d1413 1
a1413 1
        protected override void doDropDone(bool success, int dropAction, bool isLocal)
d1432 1
a1432 1
        protected override object getNativeData(long l)
d5568 1
a5568 1
        protected override string getClipboardFormatName(long format)
d5573 1
a5573 1
        protected override byte[] imageToStandardBytes(java.awt.Image image, string mimeType)
d5610 1
a5610 1
        protected override java.io.ByteArrayOutputStream convertFileListToBytes(java.util.ArrayList fileList)
@


1.104
log
@Changed TextArea peer from TextBox to RichTextBox (to handle LF correctly) and implemented replaceRange.
@
text
@a795 5
        public java.awt.Graphics2D createGraphics(System.Drawing.Bitmap bitmap)
        {
            return new BitmapGraphics(bitmap);
        }

d2627 1
a2627 1
				return new ComponentGraphics(this.control, fgColor, bgColor, font);
@


1.103
log
@Prevent System.MethodAccessException
@
text
@d3674 1
a3674 1
    sealed class NetTextAreaPeer : NetTextComponentPeer<java.awt.TextArea>, java.awt.peer.TextAreaPeer
d3681 1
a3681 1
			control.ScrollBars = ScrollBars.Both;
d3683 53
d3776 1
a3776 1
			throw new NotImplementedException();
d3778 1
d3781 5
d3788 5
@


1.102
log
@Also broken ToolkitImage need to return a ImageSource
@
text
@d5171 1
@


1.101
log
@Fix Window.setIconImages. Now all images are used. Before only the first image was used.
@
text
@d29 1
a29 1
Copyright (C) 2006-2011 Volker Berlin (i-net software)
d600 1
a600 1
                return new NoImage();
d621 1
a621 1
                return new NoImage();
d643 1
a643 1
                return new NoImage();//TODO should throw the exception unstead of NoImage()
@


1.100
log
@Refactored WindowPeer construction to remove calls from WinForms thread back into Java. On OpenJDK 7u4 this caused a deadlock.
@
text
@d4120 2
a4121 2
            java.util.List imageList = ((java.awt.Window) target).getIconImages();
            Bitmap originalImage;
d4124 1
a4124 1
                originalImage = null;
d4128 2
a4129 2
                java.awt.Image image = (java.awt.Image)imageList.get(0);
                originalImage = J2C.ConvertImage(image);
d4133 1
a4133 5
                   Size iconSize = SystemInformation.IconSize;
                   using (Bitmap scaleBitmap = originalImage == null ? null : new Bitmap(originalImage, iconSize))
                   {
                       ((Form) control).Icon = scaleBitmap == null ? null : Icon.FromHandle(scaleBitmap.GetHicon());
                   }
a4134 1

@


1.99
log
@Made WinForms message loop thread creation lazy to hopefully allow more applications to run without message loop thread. This is a (partial) workaround for bug #3515033.
@
text
@d450 3
a452 1
            java.awt.peer.FramePeer peer = Invoke<NetFramePeer>(delegate { return new NetFramePeer(target); });
d459 3
a461 1
            java.awt.peer.WindowPeer peer = Invoke<NetWindowPeer>(delegate { return new NetWindowPeer(target); });
d468 3
a470 1
            java.awt.peer.DialogPeer peer = Invoke<NetDialogPeer>(delegate { return new NetDialogPeer(target); });
d525 3
a527 1
            java.awt.peer.FileDialogPeer peer = Invoke<NetFileDialogPeer>(delegate { return new NetFileDialogPeer(target); });
d3833 1
a3833 1
        public NetWindowPeer(java.awt.Window window)
d3844 2
a3845 1
        }
d4195 1
a4195 3
			UndecoratedForm form = new UndecoratedForm();
            form.SetWindowState(target.isFocusableWindow(),target.isAlwaysOnTop());
		    return form;
d4255 2
a4256 2
		public NetFramePeer(java.awt.Frame frame)
			: base(frame)
d4378 2
a4379 2
        public NetDialogPeer(java.awt.Dialog target)
			: base(target)
d4706 2
a4707 1
		internal NetFileDialogPeer(java.awt.FileDialog dialog) : base(dialog)
@


1.98
log
@Revert the usage of generics for subclasses of NetWindowPeer
@
text
@d214 61
a278 1
        private static volatile Form bogusForm;
a306 10
        private static void MessageLoop()
        {
            using (Form form = new Form())
            {
				CreateNative(form);
                bogusForm = form;
                Application.Run();
            }
        }

d320 1
a320 16
            lock (typeof(NetToolkit))
            {
                System.Diagnostics.Debug.Assert(bogusForm == null);
                setDataTransfererClassName(DATA_TRANSFERER_CLASS_NAME);

                Thread thread = new Thread(new ThreadStart(MessageLoop));
                thread.SetApartmentState(ApartmentState.STA);
                thread.Name = "IKVM AWT WinForms Message Loop";
                thread.IsBackground = true;
                thread.Start();
                // TODO don't use polling...
                while (bogusForm == null && thread.IsAlive)
                {
                    Thread.Sleep(1);
                }
            }
d548 2
a549 1
                using (Graphics g = bogusForm.CreateGraphics())
d970 1
a970 1
            if (bogusForm.InvokeRequired)
d972 1
a972 1
                bogusForm.BeginInvoke(del);
d982 1
a982 1
            if (bogusForm.InvokeRequired)
d984 1
a984 1
                bogusForm.BeginInvoke(del, t);
d993 1
a993 1
            if (bogusForm.InvokeRequired)
d995 1
a995 1
                bogusForm.Invoke(del, t);
d1005 1
a1005 1
            if (bogusForm.InvokeRequired)
d1007 1
a1007 1
                return (TResult)bogusForm.Invoke(del);
d1017 1
a1017 1
            if (bogusForm.InvokeRequired)
d1019 1
a1019 1
                bogusForm.Invoke(del);
@


1.97
log
@* extends the generics from NetContainerPeer to NetWindowPeer
* add support for window with transparent background
* support undecorated Frame and Dialog
@
text
@d422 4
a425 4
            java.awt.peer.WindowPeer peer = Invoke<NetWindowPeer<java.awt.Window, UndecoratedForm>>(delegate { return new NetWindowPeer<java.awt.Window, UndecoratedForm>(target); });
            targetCreatedPeer(target, peer);
            return peer;
        }
d878 1
a878 1
            NetWindowPeer<java.awt.Window, UndecoratedForm> peer = (NetWindowPeer<java.awt.Window, UndecoratedForm>)window.getPeer();
d915 1
a915 1
            NetWindowPeer<java.awt.Window, UndecoratedForm> peer = (NetWindowPeer<java.awt.Window, UndecoratedForm>)window.getPeer();
d3780 1
a3780 3
    class NetWindowPeer<T, C> : NetContainerPeer<T, C>, java.awt.peer.WindowPeer
		where T : java.awt.Window
		where C : UndecoratedForm
d3784 1
a3784 1
        private NetWindowPeer<T, C> modalBlocker;
d3787 1
a3787 1
        private static NetWindowPeer<T, C> grabbedWindow;
d4047 1
a4047 1
                NetWindowPeer<T, C> blockerPeer = (NetWindowPeer<T, C>)dialog.getPeer();
d4148 1
a4148 1
        protected override C CreateControl()
d4150 1
a4150 1
			C form = (C)new UndecoratedForm();
d4195 1
a4195 1
        private bool IsOneOfOwnersOf(NetWindowPeer<T, C> window)
d4204 1
a4204 1
                window = parent == null ? null : (NetWindowPeer<T, C>)parent.getPeer();
d4210 1
a4210 1
    sealed class NetFramePeer : NetWindowPeer<java.awt.Frame, MyForm>, java.awt.peer.FramePeer
d4253 1
a4253 1
            if (target.isUndecorated())
d4327 1
a4327 1
		protected override MyForm CreateControl()
d4333 1
a4333 1
    sealed class NetDialogPeer : NetWindowPeer<java.awt.Dialog,MyForm>, java.awt.peer.DialogPeer
d4352 1
a4352 1
            if (target.isUndecorated())
d4381 1
a4381 1
		protected override MyForm CreateControl()
d4661 1
a4661 1
    class NetFileDialogPeer : NetWindowPeer<java.awt.FileDialog, MyForm>, java.awt.peer.FileDialogPeer
d5136 1
a5136 1
                NetWindowPeer<java.awt.Window, UndecoratedForm> peer = (NetWindowPeer<java.awt.Window, UndecoratedForm>)window.getPeer();
@


1.96
log
@We should override Toolkit.areExtraMouseButtonsEnabled() to avoid infinite recursion.
@
text
@d83 1
a83 1
			SetStyle(ControlStyles.UserPaint | ControlStyles.ResizeRedraw, true);
d422 4
a425 4
            java.awt.peer.WindowPeer peer = Invoke<NetWindowPeer>(delegate { return new NetWindowPeer(target); });
			targetCreatedPeer(target, peer);
			return peer;
		}
d878 1
a878 1
            NetWindowPeer peer = (NetWindowPeer)window.getPeer();
d915 1
a915 1
            NetWindowPeer peer = (NetWindowPeer)window.getPeer();
d3780 3
a3782 1
    class NetWindowPeer : NetContainerPeer<java.awt.Window, Form>, java.awt.peer.WindowPeer
d3786 1
a3786 1
        private NetWindowPeer modalBlocker;
d3789 1
a3789 1
        private static NetWindowPeer grabbedWindow;
d4049 1
a4049 1
                NetWindowPeer blockerPeer = (NetWindowPeer)dialog.getPeer();
d4150 1
a4150 1
		protected override Form CreateControl()
d4152 1
a4152 1
			UndecoratedForm form = new UndecoratedForm();
d4197 1
a4197 1
        private bool IsOneOfOwnersOf(NetWindowPeer window)
d4206 1
a4206 1
                window = parent == null ? null : (NetWindowPeer)parent.getPeer();
d4212 1
a4212 1
    sealed class NetFramePeer : NetWindowPeer, java.awt.peer.FramePeer
d4255 1
a4255 1
            if (resizable)
d4257 1
a4257 1
                setFormBorderStyle(FormBorderStyle.Sizable);
d4261 8
a4268 1
                setFormBorderStyle(FormBorderStyle.FixedSingle);
d4329 1
a4329 1
		protected override Form CreateControl()
d4335 1
a4335 1
    sealed class NetDialogPeer : NetWindowPeer, java.awt.peer.DialogPeer
d4354 1
a4354 1
            if (resizable)
d4356 1
a4356 1
                setFormBorderStyle(FormBorderStyle.Sizable);
d4360 8
a4367 1
                setFormBorderStyle(FormBorderStyle.FixedDialog);
d4383 1
a4383 1
		protected override Form CreateControl()
d4663 1
a4663 1
	class NetFileDialogPeer : NetWindowPeer, java.awt.peer.FileDialogPeer
d5138 1
a5138 1
                NetWindowPeer peer = (NetWindowPeer)window.getPeer();
@


1.95
log
@Fix the native file dialog, it was created in the wrong thread and the method blockWindows(List) was not implemented
@
text
@d990 5
@


1.94
log
@Fix a bug with a ToolkitImage as frame icon.
@
text
@d484 3
a486 1
            return new NetFileDialogPeer(target);
d4696 1
a4696 1
        public void blockWindows(List l)
d4698 8
a4705 1
            throw new NotImplementedException();
@


1.93
log
@Fix for #3441959.
@
text
@d4077 1
a4077 1
                originalImage = ((java.awt.image.BufferedImage)image).getBitmap();
@


1.92
log
@Complete migration to OpenJDK 7. Thanks to Volker Berlin for the bulk of this patch.
@
text
@d803 1
a803 1
            throw new NotImplementedException();
@


1.92.2.1
log
@Backported fixes:
- FileStore for non-accessible drive should throw exception when trying to create the FileStore, not when accessing the name() or type() properties.
- Graphics2D.clip(null) should only throw NPE for a Component graphics.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Handle Main-Class manifest value that spans multiple lines. Fix for bug #3461012.
- Informational messages should not be treated as error when -warnaserror is specified. Fix for #3443377.
- Don't enforce pre-1.5 class name rules in ikvmc (since HotSpot doesn't enforce any naming rules for classes loaded by the system (and boot) class loader, by default). Fix for #3443373.
- Fix for #3441959.
- Throwable.addSuppressed() didn't have a proper parameter name.
- mark getSpace0 with SecuritySafeCritical to avoid getting an exception with .NET 4
- Bug fix. Removed incorrect check for uninitialized objects on backward branch.
- Don't crash when ikvmc -resource: or -externalresource: option doesn't contain an = sign.
- Added AssemblyInformationalVersionAttribute to OpenJDK assemblies (to set the "Product Version"). Part of patch #3458997.
- Include copyright and metadata in IKVM.OpenJDK.Tools.dll. Part of patch #3458997.
- Bug fix. Don't call Finish on unloadable TypeWrapper.
- Bug fix. When constructing a generic class loader we can't use GetWrapperFromType() on the type arguments, because they might refer to a subtype that is currently being loaded.
- Fix. When decoding a NameSigAttribute it is possible that a type does not exist (i.e. is an unloadable) and that results in a warning emitted against the referenced assemblies class loader.
- Suppress annotation custom attributes when enumerating inner classes.
- IKVM.Reflection: Bug fix. Fixed copy/paste error. FieldInfo.IsAssembly should test for FieldAttributes.Assembly access, not FieldAttributes.Family.
@
text
@d803 1
a803 1
            return false;
@


1.91
log
@An additional MOUSE_CLICKED event will now be generated OnMouseUp for double clicks (similar to the single click solution)
@
text
@d214 1
a214 1
    public sealed class NetToolkit : sun.awt.SunToolkit, ikvm.awt.IkvmToolkit
d601 1
a601 1
        public override java.awt.PrintJob getPrintJob(java.awt.Frame frame, string jobtitle, Properties props)
d716 1
a716 1
                    desktopProperties.put("Shell.shellFolderManager", java.lang.Class.forName("sun.awt.shell.Win32ShellFolderManager2"));
d988 1
a988 1
    }
d1676 3
d2063 1
a2063 1
			if (!ComponentAccessor.getIgnoreRepaint(target))
d2736 1
a2736 5
                if (bounds.X + insets.left != x)
                {
                    ComponentAccessor.setX(target, bounds.X + insets.left);
                }
                if (bounds.Y + insets.top != y)
d2738 1
a2738 1
                    ComponentAccessor.setY(target, bounds.Y + insets.top);
d2740 1
a2740 1
                if (bounds.Width != width)
d2742 1
a2742 5
                    ComponentAccessor.setWidth(target, bounds.Width);
                }
                if (bounds.Height != height)
                {
                    ComponentAccessor.setHeight(target, bounds.Height);
d3125 51
d3759 13
a3771 1
	}
d3801 1
a3801 1
                target.setBackground(target is java.awt.Dialog ? java.awt.SystemColor.control : java.awt.SystemColor.window);
d3841 1
a3841 2
            ComponentAccessor.setX(target, control.Left);
            ComponentAccessor.setY(target, control.Top);
d3996 1
a3996 9
                if (bounds.X != x)
                {
                    ComponentAccessor.setX(target, bounds.X);
                }
                if (bounds.Y != y)
                {
                    ComponentAccessor.setY(target, bounds.Y);
                }
                if (bounds.Width != width)
d3998 1
a3998 1
                    ComponentAccessor.setWidth(target, bounds.Width);
d4000 1
a4000 1
                if (bounds.Height != height)
d4002 1
a4002 1
                    ComponentAccessor.setHeight(target, bounds.Height);
d4099 42
d4353 1
a4353 1
                java.awt.peer.WindowPeer wp = (java.awt.peer.WindowPeer)ComponentAccessor.getPeer(w);
d5482 5
@


1.90
log
@- Commented out unused (or write-only) fields.
- Made POINT field public to avoid mcs warning.
- Added workarounds for two mcs bugs.
@
text
@d30 1
a30 1
Copyright (C) 2010 Karsten Heinrich (i-net software)
d2320 1
a2320 1
			if (isMouseClick)
@


1.89
log
@Currently there are an inconsistency between NetFontMetrics and FontDesignMetrics. To prevent this we replace all with FontDesignMetrics and remove NetFontMetrics.
@
text
@d339 3
d355 1
a1239 1
            long nativeCtxtLocal = 0;
d1241 1
a1241 1
            nativeCtxtLocal = createDragSource(getTrigger().getComponent(),
d1802 1
a1802 1
		private bool m_callbacksEnabled;
d1889 1
a1889 1
			m_callbacksEnabled = enabled;
d3276 5
a3280 1
			if(!target.isBackgroundSet())
d4277 1
a4277 1
        private readonly java.awt.KeyboardFocusManager manager;
d4282 1
a4282 1
            this.manager = manager;
d4611 1
a4611 1
        private java.awt.SystemTray target;
d4615 1
a4615 1
            this.target = target;
d5003 2
a5004 2
            private int X;
            private int Y;
@


1.88
log
@remove NetProducerImage and replace it with ToolkitImage
@
text
@d29 1
a29 1
Copyright (C) 2006-2010 Volker Berlin (i-net software)
d531 1
a531 1
            return new NetFontMetrics(font);
d2552 1
a2552 1
			return new NetFontMetrics(f);
@


1.87
log
@remove some Image methods from NetToolkit and use the original of SunToolkit
@
text
@d1595 1
a1595 3
			NetProducerImage npi = new NetProducerImage(cursorIm.getSource());
			cursorIm.getSource().startProduction(npi);
			Bitmap bitmap = npi.getBitmap();
d2499 1
a2499 3
            NetProducerImage npi = new NetProducerImage(prod);
            prod.startProduction(npi);
            return new java.awt.image.BufferedImage(npi.getBitmap());
@


1.86
log
@If we set the bound back to Java then we need to add the windows insets that be have subtract before.
@
text
@a584 40
        const int ERROR = java.awt.image.ImageObserver.__Fields.ERROR;
        const int ABORT = java.awt.image.ImageObserver.__Fields.ABORT;
        const int WIDTH = java.awt.image.ImageObserver.__Fields.WIDTH;
        const int HEIGHT = java.awt.image.ImageObserver.__Fields.HEIGHT;
        const int FRAMEBITS = java.awt.image.ImageObserver.__Fields.FRAMEBITS;
        const int ALLBITS = java.awt.image.ImageObserver.__Fields.ALLBITS;

        public override bool prepareImage(java.awt.Image image, int width, int height, java.awt.image.ImageObserver observer)
        {
            // HACK for now we call checkImage to obtain the status and fire the observer
            return (checkImage(image, width, height, observer) & (ALLBITS | ERROR | ABORT)) != 0;
        }

        public override int checkImage(java.awt.Image image, int width, int height, java.awt.image.ImageObserver observer)
        {
            if (image.getWidth(null) == -1)
            {
                if (observer != null)
                {
                    observer.imageUpdate(image, ERROR | ABORT, 0, 0, -1, -1);
                }
                return ERROR | ABORT;
            }
            if (observer != null)
            {
                observer.imageUpdate(image, WIDTH + HEIGHT + FRAMEBITS + ALLBITS, 0, 0, image.getWidth(null), image.getHeight(null));
            }
            return WIDTH + HEIGHT + FRAMEBITS + ALLBITS;
        }

        public override java.awt.Image createImage(java.awt.image.ImageProducer producer)
        {
            NetProducerImage img = new NetProducerImage(producer);
            if (producer != null)
            {
                producer.startProduction(img);
            }
            return img;
        }

@


1.85
log
@complete the peer of Canvas and Panel
@
text
@d2761 1
d2764 1
a2764 2
                    java.awt.Insets insets = ((MyForm)window).peerInsets;
                    control.SetBounds(x - insets.left, y - insets.top, width, height);
d2768 1
a2768 1
                    control.SetBounds(x, y, width, height);
d2770 1
d2774 1
a2774 1
                if (bounds.X != x)
d2776 1
a2776 1
                    ComponentAccessor.setX(target, bounds.X);
d2778 1
a2778 1
                if (bounds.Y != y)
d2780 1
a2780 1
                    ComponentAccessor.setY(target, bounds.Y);
@


1.84
log
@There seems no difference between fractional and not fractional font metrics for the outline of a GlyphVector.
@
text
@d339 14
d3725 1
a3725 1
    sealed class NetPanelPeer : NetContainerPeer<java.awt.Panel, Control>, java.awt.peer.PanelPeer
d3732 1
a3732 1
		protected override Control CreateControl()
d3734 1
a3734 1
			throw new NotImplementedException();
d3738 1
a3738 1
    sealed class NewCanvasPeer : NetComponentPeer<java.awt.Canvas, Control>, java.awt.peer.CanvasPeer
d3740 1
a3740 1
		public NewCanvasPeer(java.awt.Canvas canvas)
d3747 1
a3747 1
			throw new NotImplementedException();
@


1.83
log
@Fix the stealing of focus from a tooltip which is partly outside of the window. The bug was a not working updateFocusableWindowState().
@
text
@d810 6
a815 1
            path.AddString(text, family, (int)style, netFont.Size, new PointF(x, y), J2C.CreateStringFormat(frc));
@


1.82
log
@Added .NET 4 security attributes.
@
text
@d77 3
d92 1
a92 1
        internal void setFocusableWindow(bool value)
d94 34
a127 1
            SetStyle(ControlStyles.Selectable, value);
a3984 5
		public void updateAlwaysOnTop()
		{
			throw new NotImplementedException();
		}

d3992 4
a3995 4
            if ((alwaysOnTop && target.isVisible()) || !alwaysOnTop)
            {
				NetToolkit.Invoke(delegate { control.TopMost = alwaysOnTop; });
            }
d4031 1
a4031 1
            ((UndecoratedForm)control).setFocusableWindow( ((java.awt.Window)target).isFocusableWindow());
d4069 3
a4071 1
			return new UndecoratedForm();
@


1.81
log
@Add support for keys with ALT_GR or ALT+CTRL.
@
text
@d171 1
@


1.80
log
@Install SynchronizationContext on the event dispatcher thread to allow C# 5 async feature to stay on the event thread.
@
text
@d1719 12
a1730 8
			if ((keys & Keys.Control) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.CTRL_DOWN_MASK;
			}
			if ((keys & Keys.Alt) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.ALT_DOWN_MASK;
			}
@


1.79
log
@Implemented popup menu.
@
text
@d154 23
d184 25
@


1.78
log
@Fixed background painting of Frame and Window. For AWT we should paint the background, but for Swing we shouldn't.
@
text
@d363 4
d4560 1
a4560 1
    class NetPopupMenuPeer : java.awt.peer.PopupMenuPeer
d4562 3
d4567 5
d4576 1
a4576 1
            throw new NotImplementedException();
d4581 4
a4584 15
            NetComponentPeer peer = (NetComponentPeer)NetToolkit.targetToPeer(origin);
            java.awt.Event e = new java.awt.Event(origin, 0, java.awt.Event.MOUSE_DOWN, p.x, p.y, 0, 0);
            if (peer == null)
            {
                java.awt.Component nativeOrigin = NetToolkit.getNativeContainer(origin);
                e.target = nativeOrigin;
            }
            e.x = p.x;
            e.y = p.y;
            nativeShow(e);
        }

        private void nativeShow(java.awt.Event e)
        {
            
d4589 1
a4589 1
            throw new NotImplementedException();
d4599 1
a4599 1
            throw new NotImplementedException();
d4604 2
a4605 2
            throw new NotImplementedException();
        }
d4609 8
a4616 2
            throw new NotImplementedException();
        }
a4619 1
            throw new NotImplementedException();
d4622 1
a4622 1
        public void addItem(java.awt.MenuItem mi)
d4624 13
a4636 2
            throw new NotImplementedException();
        }
d4640 1
a4640 1
            throw new NotImplementedException();
d4645 2
a4646 2
            throw new NotImplementedException();
        }
@


1.77
log
@- Implemented screen insets.
- Moved bound setting to UI thread.
- Take menu presence into account for frame insets.
@
text
@d80 1
a80 1
			SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw, true);
d96 5
a100 1
			// JDK sets a NULL background brush, we emulate that by not doing any background painting
a1553 12

		//private static ContainerControl GetContainerControl(java.awt.Container aContainer)
		//{
		//    ContainerControl control = null;

		//    if (aContainer != null)
		//    {
		//        control = (ContainerControl)((NetContainerPeer)aContainer.getPeer()).control;
		//    }

		//    return control;
		//}
d1558 2
d1792 7
d3669 1
d3728 1
@


1.76
log
@Massive AWT peer restructuring.
@
text
@d130 1
a130 1
                    MaximizedBounds = maxBounds;
d140 1
a140 1
                MaximizedBounds = J2C.ConvertRect(rect);
d143 5
d779 19
d3820 1
a3820 20
                Rectangle client = control.ClientRectangle;
                if (client.Height == 0)
                {
                    // HACK for .NET bug if form has the minimum size then ClientRectangle is not recalulate
                    // if the FormBorderStyle is changed
                    Size size = control.Size;
                    size.Height++;
                    control.Size = size;
                    size.Height--;
                    control.Size = size;
                    client = control.ClientRectangle;
                }
                Rectangle r = control.RectangleToScreen(client);
                int x = r.Location.X - control.Location.X;
                int y = r.Location.Y - control.Location.Y;
                // only modify this instance, since it's accessed by the control-peers of this form
                _insets.top = y;
                _insets.left = x;
                _insets.bottom = control.Height - client.Height - y;
                _insets.right = control.Width - client.Width - x;
d3824 28
a4042 15
		private class ValidateHelper : java.lang.Runnable
		{
			private java.awt.Component comp;

			internal ValidateHelper(java.awt.Component comp)
			{
				this.comp = comp;
			}

			public void run()
			{
				comp.validate();
			}
		}

d4060 5
a4064 1
				NetToolkit.Invoke(delegate { control.Menu = null; });
d4069 5
a4073 1
				NetToolkit.Invoke(delegate { control.Menu = ((NetMenuBarPeer)mb.getPeer()).menu; });
d4138 1
a4138 2
			// TODO use control.Invoke
			control.Bounds = new Rectangle(x, y, width, height);
@


1.75
log
@implementation of getOutline in toolkit
@
text
@a72 4
    internal delegate TResult Func<T,TResult>(T t);
    internal delegate TResult Func<T1, T2, TResult>(T1 t1, T2 t2);
    internal delegate TResult Func<T1, T2, T3, TResult>(T1 t1, T2 t2, T3 t3);
    internal delegate TResult Func<T1, T2, T3, T4, TResult>(T1 t1, T2 t2, T3 t3, T4 t4);
a73 3
    internal delegate void Action<T1, T2>(T1 t1, T2 t2);
    internal delegate void Action<T1, T2, T3>(T1 t1, T2 t2, T3 t3);
    internal delegate void Action<T1, T2, T3, T4>(T1 t1, T2 t2, T3 t3, T4 t4);
d145 1
a145 17
	class MyControl : Control
	{
		public MyControl()
		{
			SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw, true);
		}
	}

	class MyContainerControl : ContainerControl
	{
		public MyContainerControl()
		{
			SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw, true);
		}
	}

    public class NetToolkit : sun.awt.SunToolkit, ikvm.awt.IkvmToolkit
d149 1
a149 1
        internal static volatile Form bogusForm;
d240 1
a240 1
            java.awt.peer.ButtonPeer peer = new NetButtonPeer(target);
d247 1
a247 1
            java.awt.peer.TextFieldPeer peer = new NetTextFieldPeer(target);
d254 1
a254 1
            java.awt.peer.LabelPeer peer = new NetLabelPeer(target);
d261 1
a261 1
            java.awt.peer.ListPeer peer = new NetListPeer(target);
d268 1
a268 1
            java.awt.peer.CheckboxPeer peer = new NetCheckboxPeer(target);
d275 4
a278 2
            throw new NotImplementedException();
        }
d282 4
a285 2
            throw new NotImplementedException();
        }
d289 1
a289 1
            java.awt.peer.TextAreaPeer peer = new NetTextAreaPeer(target);
d296 1
a296 1
            java.awt.peer.ChoicePeer peer = new NetChoicePeer(target);
d303 1
a303 1
            java.awt.peer.FramePeer peer = Invoke((Func<java.awt.peer.FramePeer>)delegate { return new NetFramePeer(target); });
d310 1
a310 1
            java.awt.peer.WindowPeer peer = Invoke((Func<java.awt.peer.WindowPeer>)delegate { return new NetWindowPeer(target); });
d317 1
a317 1
            java.awt.peer.DialogPeer peer = Invoke((Func<java.awt.peer.DialogPeer>)delegate { return new NetDialogPeer(target); });
d324 15
a338 1
            throw new NotImplementedException();
d343 7
a349 1
            throw new NotImplementedException();
d354 3
a356 1
            throw new NotImplementedException();
d361 4
a364 2
            throw new NotImplementedException();
        }
d373 2
a374 2
            throw new NotImplementedException();
        }
a423 1
            throw new NotImplementedException();
d820 1
a820 1
		protected internal new static object targetToPeer(object target)
d825 1
a825 1
        protected internal new static void targetDisposedPeer(object target, object peer)
d830 1
a830 1
        internal static void BeginInvoke(ThreadStart del)
a864 12
        internal static void Invoke<T1, T2>(Action<T1, T2> del, T1 t1, T2 t2)
        {
            if (bogusForm.InvokeRequired)
            {
                bogusForm.Invoke(del, t1, t2);
            }
            else
            {
                del(t1,t2);
            }
        }

d877 1
a877 1
        internal static TResult Invoke<T, TResult>(Func<T, TResult> del, T t)
d881 1
a881 1
                return (TResult)bogusForm.Invoke(del, t);
d885 1
a885 1
                return del(t);
d888 159
d1048 9
a1056 11
        internal static TResult Invoke<T1, T2, TResult>(Func<T1, T2, TResult> del, T1 t1, T2 t2)
        {
            if (bogusForm.InvokeRequired)
            {
                return (TResult)bogusForm.Invoke(del, t1, t2);
            }
            else
            {
                return del(t1, t2);
            }
        }
d1058 7
a1064 11
        internal static TResult Invoke<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult> del, T1 t1, T2 t2, T3 t3)
        {
            if (bogusForm.InvokeRequired)
            {
                return (TResult)bogusForm.Invoke(del, t1, t2, t3);
            }
            else
            {
                return del(t1, t2, t3);
            }
        }
d1066 13
a1078 11
        internal static TResult Invoke<T1, T2, T3, T4, TResult>(Func<T1, T2, T3, T4, TResult> del, T1 t1, T2 t2, T3 t3, T4 t4)
        {
            if (bogusForm.InvokeRequired)
            {
                return (TResult)bogusForm.Invoke(del, t1, t2, t3, t4);
            }
            else
            {
                return del(t1, t2, t3, t4);
            }
        }
d1080 5
a1084 12
        internal static void Invoke(MethodInvoker del)
        {
            if (bogusForm.InvokeRequired)
            {
                bogusForm.Invoke(del);
            }
            else
            {
                del();
            }
        }
    }
d1169 1
a1169 1
                    Control control = peer.control;
d1507 1
a1507 1
	class NetLightweightComponentPeer : NetComponentPeer, java.awt.peer.LightweightPeer
d1514 1
a1514 1
		internal override void create(NetComponentPeer parent)
d1520 1
a1520 1
    class NetLightweightContainerPeer : NetContainerPeer, java.awt.peer.LightweightPeer
d1527 8
a1534 3
        private static ContainerControl GetContainerControl(java.awt.Container aContainer)
        {
            ContainerControl control = null;
d1536 2
a1537 7
            if (aContainer != null)
            {
                control = (ContainerControl)((NetContainerPeer)aContainer.getPeer()).control;
            }

            return control;
        }
d1540 1
a1540 1
	sealed class AwtToolkit
d1542 99
a1640 1
		internal delegate void CreateComponentDelegate(NetComponentPeer parent);
d1642 1
a1642 1
		internal static void CreateComponent(CreateComponentDelegate factory, NetComponentPeer parent)
d1644 2
a1645 1
			NetToolkit.bogusForm.Invoke((ThreadStart)delegate
d1647 48
a1694 9
				try
				{
					factory(parent);
				}
				catch (Exception x)
				{
					Console.WriteLine(x);
				}
			});
d1698 3
a1700 1
    abstract class NetComponentPeer : java.awt.peer.ComponentPeer
d1703 2
a1704 2
		internal readonly java.awt.Component target;
		internal Control control;
a1721 1
        internal DragDropEffects performedDragDropEffects = DragDropEffects.None;
d1723 11
a1733 1
		public NetComponentPeer(java.awt.Component target)
d1739 1
a1739 1
			create(parentPeer);
d1794 21
a1814 1
		internal abstract void create(NetComponentPeer parent);
d1893 1
a1893 1
        protected virtual int getInsetsLeft()
d1905 1
a1905 1
        protected virtual int getInsetsTop()
d1912 3
a1914 3
        /// .NET calculate the offset relative to the detail area.
        /// Java is using the top left point of a window.
        /// That be must compensate the cordinate of a component
d1925 2
a1926 2
                    java.awt.peer.ComponentPeer peer = parent.getPeer();
                    if (peer is NetComponentPeer)
d1928 1
a1928 3
                        return new Point(
                            ((NetComponentPeer)peer).getInsetsLeft(),
                            ((NetComponentPeer)peer).getInsetsTop());
a1986 49
        internal static int GetMouseEventModifiers(MouseEventArgs ev)
        {
            int modifiers = GetModifiers(Control.ModifierKeys);
            //Which button was pressed or released, because it can only one that it is a switch
            MouseButtons button = ev.Button;
            switch(button){
                case MouseButtons.Left:
                    modifiers |= java.awt.@@event.InputEvent.BUTTON1_MASK;
                    break;
                case MouseButtons.Middle:
                    modifiers |= java.awt.@@event.InputEvent.BUTTON2_MASK;
                    break;
                case MouseButtons.Right:
                    modifiers |= java.awt.@@event.InputEvent.BUTTON3_MASK;
                    break;
            }
            return modifiers;
        }

        internal static int GetModifiers(Keys keys)
		{
			int modifiers = 0;
            if ((keys & Keys.Shift) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.SHIFT_DOWN_MASK;
			}
			if((keys & Keys.Control) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.CTRL_DOWN_MASK;
			}
			if((keys & Keys.Alt) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.ALT_DOWN_MASK;
			}
			if((Control.MouseButtons & MouseButtons.Left) != 0)
			{
                modifiers |= java.awt.@@event.InputEvent.BUTTON1_DOWN_MASK;
			}
			if((Control.MouseButtons & MouseButtons.Middle) != 0)
			{
                modifiers |= java.awt.@@event.InputEvent.BUTTON2_DOWN_MASK;
			}
			if((Control.MouseButtons & MouseButtons.Right) != 0)
			{
				modifiers |= java.awt.@@event.InputEvent.BUTTON3_DOWN_MASK;
			}
			return modifiers;
		}

a2113 24
        internal static int getAction(DragDropEffects effects)
        {
            int actions = java.awt.dnd.DnDConstants.ACTION_NONE;
            switch (effects)
            {
                case DragDropEffects.None:
                    actions = java.awt.dnd.DnDConstants.ACTION_NONE;
                    break;
                case DragDropEffects.Copy:
                    actions = java.awt.dnd.DnDConstants.ACTION_COPY;
                    break;
                case DragDropEffects.Move:
                    actions = java.awt.dnd.DnDConstants.ACTION_MOVE;
                    break;
                case DragDropEffects.Move | DragDropEffects.Copy:
                    actions = java.awt.dnd.DnDConstants.ACTION_COPY_OR_MOVE;
                    break;
                case DragDropEffects.Link:
                    actions = java.awt.dnd.DnDConstants.ACTION_LINK;
                    break;
            }
            return actions;
        }

a2195 20
		internal static int GetButton(MouseEventArgs e)
		{
            if((e.Button & MouseButtons.Left) != 0)
			{
				return java.awt.@@event.MouseEvent.BUTTON1;
			}
			else if((e.Button & MouseButtons.Middle) != 0)
			{
				return java.awt.@@event.MouseEvent.BUTTON2;
			}
			else if((e.Button & MouseButtons.Right) != 0)
			{
				return java.awt.@@event.MouseEvent.BUTTON3;
			}
			else
			{
				return java.awt.@@event.MouseEvent.NOBUTTON;
			}
		}

d2277 1
a2277 1
			java.awt.Container cont = (java.awt.Container)target;
d2397 1
a2397 1
		public int checkImage(java.awt.Image img, int width, int height, java.awt.image.ImageObserver ob)
d2402 1
a2402 1
		public java.awt.Image createImage(java.awt.image.ImageProducer prod)
d2409 1
a2409 1
		public java.awt.Image createImage(int width, int height)
d2414 1
a2414 1
		public void disable()
d2419 1
a2419 1
		public void dispose()
d2437 1
a2437 1
            NetToolkit.Invoke((MethodInvoker)delegate { nativeDispose(); });
d2446 1
a2446 2

		public void enable()
d2451 1
a2451 1
        public java.awt.image.ColorModel getColorModel()
d2453 1
a2453 1
            //we return the default ColorModel because this produce the fewest problems with convertions
d2457 1
a2457 1
		public java.awt.FontMetrics getFontMetrics(java.awt.Font f)
d2462 1
a2462 1
		public virtual java.awt.Graphics getGraphics()
d2487 1
a2487 1
        public java.awt.Point getLocationOnScreen()
d2489 1
a2489 1
            return NetToolkit.Invoke((Func<java.awt.Point>)delegate
d2497 1
a2497 1
		public virtual java.awt.Dimension getMinimumSize()
d2502 1
a2502 1
        public virtual java.awt.Dimension getPreferredSize()
d2507 1
a2507 1
		public java.awt.Toolkit getToolkit()
d2522 1
a2522 1
		public void handleEvent(java.awt.AWTEvent e)
d2557 1
a2557 1
        public void hide()
d2567 1
a2567 1
		public virtual java.awt.Dimension minimumSize()
d2572 1
a2572 1
		public virtual java.awt.Dimension preferredSize()
d2577 1
a2577 1
		public void paint(java.awt.Graphics graphics)
d2582 1
a2582 1
        public bool prepareImage(java.awt.Image img, int width, int height, java.awt.image.ImageObserver ob)
d2587 1
a2587 1
		public void print(java.awt.Graphics graphics)
d2592 1
a2592 1
		public void repaint(long tm, int x, int y, int width, int height)
d2598 1
a2598 1
            control.Invoke((MethodInvoker) delegate { control.Focus(); });
d2609 1
a2609 1
        public bool requestFocus(java.awt.Component request, bool temporary, bool allowWindowFocus, long time)
d2619 1
a2619 1
        public virtual void reshape(int x, int y, int width, int height)
d2655 1
a2655 1
		public void setBackground(java.awt.Color color)
d2669 1
a2669 1
		public void setBounds(int x, int y, int width, int height, int op)
d2760 1
a2760 1
            return NetToolkit.Invoke((Func<bool>)delegate { return control.Enabled; });
d2765 1
a2765 1
            return NetToolkit.Invoke((Func<bool>)delegate { return control.Focused; });
d2770 1
a2770 1
            return NetToolkit.Invoke((Func<bool>)delegate { return control.Visible; });
d2773 1
a2773 1
        public void setEnabled(bool enabled)
d2785 1
a2785 1
		public void setFont(java.awt.Font font)
d2794 1
a2794 1
		public void setForeground(java.awt.Color color)
d2803 1
a2803 1
		public void setVisible(bool visible)
d2815 1
a2815 1
		public virtual void show()
d2817 1
a2817 1
			java.awt.Dimension s = ((java.awt.Component)target).getSize();
d2827 1
a2827 1
        public java.awt.GraphicsConfiguration getGraphicsConfiguration()
d2839 1
a2839 1
		public bool isObscured()
d2845 1
a2845 1
		public bool canDetermineObscurity()
d2853 1
a2853 1
		public void coalescePaintEvent(java.awt.@@event.PaintEvent e)
d2862 1
a2862 1
		public void updateCursorImmediately()
d2866 1
a2866 1
		public java.awt.image.VolatileImage createVolatileImage(int width, int height)
d2871 1
a2871 1
		public bool handlesWheelScrolling()
d2876 1
a2876 1
		public void createBuffers(int x, java.awt.BufferCapabilities capabilities)
d2881 1
a2881 1
		public java.awt.Image getBackBuffer()
d2886 1
a2886 1
		public void flip(java.awt.BufferCapabilities.FlipContents contents)
d2891 1
a2891 1
		public void destroyBuffers()
d2896 1
a2896 1
		public virtual bool isFocusable()
d2905 2
a2906 2
        
		public java.awt.Rectangle getBounds()
d2911 1
a2911 1
		public void reparent(java.awt.peer.ContainerPeer parent)
d2916 1
a2916 1
		public bool isReparentSupported()
d2922 1
a2922 1
		public void layout()
d2926 1
a2926 1
        public void applyShape(sun.java2d.pipe.Region shape)
d2945 1
a2945 1
        public bool requestFocus(java.awt.Component lightweightChild, bool temporary, bool focusedWindowChangeAllowed, long time, sun.awt.CausedFocusEvent.Cause cause)
d3033 65
d3099 21
a3119 1
		internal static NetComponentPeer FromControl(Control control)
d3121 1
a3121 1
			return (NetComponentPeer)control.Tag;
d3125 1
a3125 1
    class NetButtonPeer : NetComponentPeer, java.awt.peer.ButtonPeer
d3130 1
a3130 1
			if(!awtbutton.isBackgroundSet())
d3135 2
a3136 2
			setLabel(awtbutton.getLabel());
		    NetToolkit.Invoke(delegate { ((Button) control).Click += new EventHandler(OnClick); });
d3150 1
a3150 1
            NetToolkit.BeginInvoke(delegate(string x) { control.Text = x; }, label);
d3167 4
a3170 16
        internal override void create(NetComponentPeer parent)
        {
            AwtToolkit.CreateComponent(Create, parent);
        }

        void Create(NetComponentPeer parent)
        {
            Button button = new Button();
            button.Tag = this;
            if (parent != null)
            {
                button.Parent = parent.control;
            }
            NetToolkit.CreateNative(button);
            this.control = button;
        }
d3173 2
a3174 1
    class NetTextComponentPeer : NetComponentPeer, java.awt.peer.TextComponentPeer
d3177 1
a3177 1
			: base(textComponent)
d3184 2
a3185 2
			((TextBox)control).AutoSize = false;
			((TextBox)control).Text = ((java.awt.TextComponent)target).getText();
d3209 1
a3209 1
			throw new NotImplementedException();
d3211 1
d3214 1
a3214 1
			throw new NotImplementedException();
d3219 1
a3219 1
		    return NetToolkit.Invoke((Func<string>)delegate { return control.Text; });
d3224 1
a3224 1
			NetToolkit.Invoke(delegate(string x) { control.Text = x; }, text);
d3231 1
d3236 1
d3239 1
a3239 1
			throw new NotImplementedException();
d3244 2
a3245 2
			((TextBox)control).SelectionStart = pos;
			((TextBox)control).SelectionLength = 0;
d3273 1
a3273 1
		internal override void create(NetComponentPeer parent)
d3275 1
a3275 1
			throw new NotImplementedException();
d3279 1
a3279 1
    class NetChoicePeer : NetComponentPeer, java.awt.peer.ChoicePeer
d3311 1
a3311 1
		internal override void create(NetComponentPeer parent)
d3313 1
a3313 1
			throw new NotImplementedException();
d3317 1
a3317 1
    class NetCheckboxPeer : NetComponentPeer, java.awt.peer.CheckboxPeer
d3339 1
a3339 1
		internal override void create(NetComponentPeer parent)
d3341 1
a3341 1
			throw new NotImplementedException();
d3345 1
a3345 1
    class NetLabelPeer : NetComponentPeer, java.awt.peer.LabelPeer
d3350 1
a3350 2
            NetToolkit.Invoke(setTextImpl, jlabel.getText());
			// ((Label)control).Text = jlabel.getText();
d3376 1
a3376 1
            ((Label)control).TextAlign = (ContentAlignment)alignment;
a3395 1
			Label lab = (Label)control;
d3397 1
a3397 1
			return new java.awt.Dimension(lab.PreferredWidth, 2 + lab.PreferredHeight);
d3406 4
a3409 16
        internal override void create(NetComponentPeer parent)
        {
            AwtToolkit.CreateComponent(Create, parent);
        }

        void Create(NetComponentPeer parent)
        {
            Label label = new Label();
            label.Tag = this;
            if (parent != null)
            {
                label.Parent = parent.control;
            }
            NetToolkit.CreateNative(label);
            this.control = label;
        }
d3412 1
a3412 1
    class NetTextFieldPeer : NetTextComponentPeer, java.awt.peer.TextFieldPeer
d3417 1
a3417 1
			setEchoCharacter(textField.getEchoChar());
d3422 1
a3422 1
			throw new NotImplementedException();
d3427 1
a3427 1
			throw new NotImplementedException();
d3451 1
a3451 1
            ((TextBox)control).PasswordChar = echo_char;
d3476 1
a3476 1
    class NetTextAreaPeer : NetTextComponentPeer, java.awt.peer.TextAreaPeer
d3481 4
a3484 9
			((TextBox)control).ReadOnly = !((java.awt.TextArea)target).isEditable();
			((TextBox)control).WordWrap = false;
			((TextBox)control).ScrollBars = ScrollBars.Both;
			((TextBox)control).Multiline = true;
		}

		private void insertImpl(string text, int pos)
		{
			control.Text = control.Text.Insert(pos, text);
d3489 1
a3489 1
			NetToolkit.Invoke(insertImpl, text, pos);
d3494 1
a3494 1
			throw new NotImplementedException();
d3533 3
a3535 1
    class NetContainerPeer : NetComponentPeer, java.awt.peer.ContainerPeer
d3543 1
a3543 1
			: base(awtcontainer)
d3547 1
a3547 1
        protected override int getInsetsLeft()
d3552 1
a3552 1
        protected override int getInsetsTop()
d3582 1
a3582 1
		internal override void create(NetComponentPeer parent)
d3588 1
a3588 1
    class NetPanelPeer : NetContainerPeer, java.awt.peer.PanelPeer
d3594 5
d3601 1
a3601 1
    class NewCanvasPeer : NetComponentPeer, java.awt.peer.CanvasPeer
d3608 1
a3608 1
		internal override void create(NetComponentPeer parent)
d3614 1
a3614 1
    class NetWindowPeer : NetContainerPeer, java.awt.peer.WindowPeer
d3627 4
a3630 4
            ((Form)control).Closing += new CancelEventHandler(OnClosing);
			((Form)control).Closed += new EventHandler(OnClosed);
			((Form)control).Activated += new EventHandler(OnActivated);
			((Form)control).Deactivate += new EventHandler(OnDeactivate);
d3725 1
a3725 1
			WmActivate(WA_ACTIVE, ((Form)control).WindowState == FormWindowState.Minimized, null);
d3730 1
a3730 1
			WmActivate(WA_INACTIVE, ((Form)control).WindowState == FormWindowState.Minimized, null);
d3793 1
a3793 1
                ((Form)control).FormBorderStyle = style;
a3818 6
        protected void SetBoundsImpl(int x, int y, int width, int height)
        {
            Form form = (Form)control;
            form.DesktopBounds = new Rectangle(x, y, width, height);
        }

d3848 1
a3848 1
            NetToolkit.BeginInvoke(((Form)control).SendToBack);
d3853 1
a3853 1
            NetToolkit.BeginInvoke(((Form)control).Activate);
d3868 1
a3868 1
            if ((alwaysOnTop && ((java.awt.Window)target).isVisible()) || !alwaysOnTop)
d3870 1
a3870 4
                NetToolkit.BeginInvoke(delegate(bool topMost)
                                           {
                                               ((Form) control).TopMost = topMost;
                                           }, alwaysOnTop);
d3939 1
a3939 1
                ((Form)control).MinimumSize = new Size(dim.width, dim.height);
d3943 1
a3943 6
		internal override void create(NetComponentPeer parent)
		{
			AwtToolkit.CreateComponent(Create, parent);
		}

		void Create(NetComponentPeer parent)
d3945 1
a3945 8
			Form form = new UndecoratedForm();
			form.Tag = this;
			if (parent != null)
			{
				form.Owner = parent.control.FindForm();
			}
			NetToolkit.CreateNative(form);
			this.control = form;
d4003 1
a4003 1
    class NetFramePeer : NetWindowPeer, java.awt.peer.FramePeer
d4040 9
a4048 1
			throw new NotImplementedException();
d4121 1
a4121 6
		internal override void create(NetComponentPeer parent)
		{
			AwtToolkit.CreateComponent(Create, parent);
		}

		void Create(NetComponentPeer parent)
d4123 1
a4123 8
			Form form = new MyForm( _insets );
			form.Tag = this;
			if (parent != null)
			{
				form.Owner = parent.control.FindForm();
			}
			NetToolkit.CreateNative(form);
			this.control = form;
d4127 1
a4127 1
    class NetDialogPeer : NetWindowPeer, java.awt.peer.DialogPeer
d4132 3
a4134 3
            ((Form)control).MaximizeBox = false;
			((Form)control).MinimizeBox = false;
            ((Form)control).ShowInTaskbar = false;
d4141 1
a4141 1
            NetToolkit.BeginInvoke(delegate { control.Text = title; });
d4168 4
a4171 16
        internal override void create(NetComponentPeer parent)
        {
            AwtToolkit.CreateComponent(Create, parent);
        }

        void Create(NetComponentPeer parent)
        {
            Form form = new MyForm( _insets );
			form.Tag = this;
			if (parent != null)
            {
                form.Owner = parent.control.FindForm();
            }
            NetToolkit.CreateNative(form);
            this.control = form;
        }
d4204 1
a4204 1
			return (java.awt.Component)NetToolkit.bogusForm.Invoke((Func<java.awt.Component>)delegate
d4226 1
a4226 1
					return peer.target;
d4234 1
a4234 1
            return (java.awt.Window)NetToolkit.bogusForm.Invoke((Func<java.awt.Window>)delegate
d4242 1
a4242 1
						return (java.awt.Window)peer.target;
d4271 1
a4271 1
    class NetListPeer : NetComponentPeer, java.awt.peer.ListPeer
d4276 11
d4289 1
a4289 1
		public void add(String item, int index)
d4291 1
a4291 1
			throw new NotImplementedException();
d4294 1
a4294 1
		public void addItem(String item, int index)
d4296 1
a4296 1
			throw new NotImplementedException();
d4301 1
a4301 1
			throw new NotImplementedException();
d4306 7
a4312 1
			throw new NotImplementedException();
d4317 1
a4317 1
			throw new NotImplementedException();
d4322 7
a4328 1
			throw new NotImplementedException();
d4333 1
a4333 1
			throw new NotImplementedException();
d4338 1
a4338 1
			throw new NotImplementedException();
d4343 1
a4343 1
			throw new NotImplementedException();
d4348 1
a4348 1
			throw new NotImplementedException();
d4353 1
a4353 1
			throw new NotImplementedException();
d4358 1
a4358 1
			throw new NotImplementedException();
d4363 1
a4363 1
			throw new NotImplementedException();
d4368 1
a4368 1
			throw new NotImplementedException();
d4373 1
a4373 1
			throw new NotImplementedException();
d4376 1
a4376 1
		internal override void create(NetComponentPeer parent)
d4378 1
a4378 1
			throw new NotImplementedException();
d4382 1
a4382 1
    class NetDesktopPeer : java.awt.peer.DesktopPeer
d4530 5
a4534 1
        public void show(java.awt.Event e)
d4679 1
a4679 1
            NetToolkit.BeginInvoke(delegate { nativeDispose(); });
a4916 1

a4998 3
        public static readonly java.awt.datatransfer.FlavorTable flavorMap =
            (java.awt.datatransfer.FlavorTable)java.awt.datatransfer.SystemFlavorMap.getDefaultFlavorMap();

d5016 4
a5019 5
                if (!NetToolkit.bogusForm.InvokeRequired)
                {
                    Application.DoEvents();
                    Thread.Sleep(0);
                }
@


1.74
log
@create() for ButtonPeer and LabelPeer implemented
@
text
@d68 1
d662 4
d691 19
a709 3
        protected override java.awt.peer.MouseInfoPeer getMouseInfoPeer()
        {
            return new NetMouseInfoPeer();
@


1.73
log
@Fix typus with Maximum / Minimum
@
text
@d30 1
d113 1
d115 5
a119 1
		public MyForm()
d121 1
d2385 1
a2385 1
        public void reshape(int x, int y, int width, int height)
d2389 10
a2398 1
                control.SetBounds(x, y, width, height);
d2694 6
a2699 1
			control.Region = J2C.ConvertRegion(shape);
d2831 1
a2831 1
            NetToolkit.Invoke(delegate(string x) { control.Text = x; }, label);
d2834 1
a2834 1
		public override java.awt.Dimension minimumSize()
d2843 21
a2863 4
		internal override void create(NetComponentPeer parent)
		{
			throw new NotImplementedException();
		}
d3039 2
a3040 1
			((Label)control).Text = jlabel.getText();
d3091 22
a3112 4
		internal override void create(NetComponentPeer parent)
		{
			throw new NotImplementedException();
		}
d3480 6
d3512 5
a3516 1
                _insets = new java.awt.Insets(y, x, control.Height - client.Height - y, control.Width - client.Width - x);
d3526 27
d3842 1
a3842 1
			Form form = new MyForm();
d3901 1
a3901 1
            Form form = new MyForm();
a4697 1

d4824 4
@


1.72
log
@implements Window.setMinimumSize()
@
text
@d3552 1
a3552 1
            java.awt.Dimension dim = target.getMaximumSize();
@


1.71
log
@Removed workaround that is no longer necessary.
@
text
@d29 1
a29 1
Copyright (C) 2006, 2007, 2008, 2009 Volker Berlin (i-net software)
d3552 5
a3556 1
            throw new NotImplementedException();
@


1.70
log
@fix dragdropinprogress
@
text
@a173 6
                // FXBUG to make sure we can be aborted (Thread.Abort) we need to periodically
                // fire an event (because otherwise we'll be blocking in unmanaged code and
                // the Abort cannot be handled there).
                System.Windows.Forms.Timer t = new System.Windows.Forms.Timer();
                t.Interval = 100;
                t.Start();
@


1.69
log
@Implement MouseInfoPeer
@
text
@d1006 1
d1010 1
d1012 1
a1012 1
                            NetDataTransferer.adaptFlavorMap(getTrigger().getDragSource().getFlavorMap()));
d1015 9
a1023 1
                                                       control.DoDragDrop(data, DragDropEffects.All);
d1420 1
d1760 1
d1833 2
a1834 1
        private static int getAction(DragDropEffects effects)
@


1.68
log
@Fix the default values background, foreground and font of Window, Frame and Dialog.
@
text
@d66 1
d685 5
d4477 47
@


1.67
log
@implement getColorModel() and fix a junit test
@
text
@d1384 1
a1384 1
		private static readonly java.awt.Font defaultFont = new java.awt.Font(java.awt.Font.DIALOG, java.awt.Font.PLAIN, 12);
d3271 29
@


1.66
log
@attempt to fix local datatransfer again
@
text
@d397 2
a398 1
            throw new NotImplementedException();
d2199 3
a2201 2
			throw new NotImplementedException();
		}
@


1.65
log
@add support for Reader and InputStream
@
text
@d960 5
a964 1
                base.dragDropFinished(success, operations, x, y);
d4528 8
d4538 5
d4548 1
d4553 5
a4557 2
                // empty
		    }
d4559 27
a4585 3
            public void @@lock()
            {
                // empty
d4590 10
a4599 1
                // empty
@


1.64
log
@fix CPU usage
@
text
@a4530 1
		        //throw new NotImplementedException();
d4535 1
a4535 1
                //throw new NotImplementedException();
d4540 1
a4540 1
                //throw new NotImplementedException();
d4545 1
a4545 1
                //throw new NotImplementedException();
d4620 6
@


1.63
log
@fix local transfer
@
text
@d4527 1
d4529 3
a4531 1
                //throw new NotImplementedException();
@


1.62
log
@fixed filelist drop
@
text
@d1090 7
d1099 2
a1733 1
            NetDragSourceContextPeer.getInstance().dragDropFinished(true, actions, e.X, e.Y);
d1737 1
@


1.61
log
@remove unused code
@
text
@d54 1
a65 2
using System.Drawing.Imaging;
using System.Runtime.InteropServices;
d4484 2
a4485 2
        private HashMap flavorToData = new HashMap();
        private java.awt.datatransfer.DataFlavor[] flavors;
d4488 2
a4489 32
            java.awt.datatransfer.FlavorTable map = (java.awt.datatransfer.FlavorTable) java.awt.datatransfer.SystemFlavorMap.getDefaultFlavorMap();
            if (data != null)
            {
                string[] formats = data.GetFormats();
                if (formats != null && formats.Length > 0)
                {
                    long[] longFormats = NetDataTransferer.getInstanceImpl().getClipboardFormatCodes(formats);
                    Map/*<DataFlavor,long>*/ flavorMap = NetDataTransferer.getInstanceImpl().getFlavorsForFormats(longFormats, map);
                    flavors = (java.awt.datatransfer.DataFlavor[])(flavorMap.keySet().toArray(new java.awt.datatransfer.DataFlavor[0]));
                    object[] dataArr = new object[formats.Length];
                    for (int i = 0; i < formats.Length; i++)
                    {
                        string format = formats[i];
                        dataArr[i] = data.GetData(format);
                    }
                    for(Iterator iter = flavorMap.entrySet().iterator(); iter.hasNext();)
                    {
                        Map.Entry entry = (Map.Entry) iter.next();
                        long formatCode = ((java.lang.Long)entry.getValue()).longValue();
                        int idx;
                        for (idx = 0; idx < formats.Length; idx++)
                        {
                            if (longFormats[idx] == formatCode) break;
                        }
                        if (idx<formats.Length)
                        {
                            java.awt.datatransfer.DataFlavor flavor = (java.awt.datatransfer.DataFlavor) entry.getKey();
                            flavorToData.put(flavor, dataArr[idx]);
                        }
                    }
                }
            }
d4567 50
@


1.60
log
@implement Drop feature
@
text
@a1003 6
                                                       try
                                                       {
                                                           setDragDropInProgress(false);
                                                       } catch
                                                       {
                                                       }
@


1.59
log
@add explicit cast for delegate
@
text
@d66 1
d1025 2
d1070 1
a1070 1
                                long nativeCtxt)
d1072 1
d1094 6
a1099 2
            // TODO: do something here... 
            throw new NotImplementedException();
d1735 1
a1735 1
                                                 formats, 0);
d4485 1
a4485 1
            return new NetClipboardTransferable(this);
d4493 1
a4493 1
        public NetClipboardTransferable(NetClipboard clipboard)
a4494 1
            IDataObject data = Clipboard.GetDataObject();
@


1.58
log
@fix preferredSize
@
text
@d319 1
a319 1
            java.awt.peer.FramePeer peer = Invoke(delegate { return new NetFramePeer(target); });
d326 1
a326 1
            java.awt.peer.WindowPeer peer = Invoke(delegate { return new NetWindowPeer(target); });
d333 1
a333 1
            java.awt.peer.DialogPeer peer = Invoke(delegate { return new NetDialogPeer(target); });
d2167 1
a2167 1
            NetToolkit.Invoke(delegate { nativeDispose(); });
d2219 1
a2219 1
            return NetToolkit.Invoke<java.awt.Point>(delegate
d2222 1
a2222 1
                NetToolkit.BeginInvoke(delegate { p = control.PointToScreen(p); });
d2481 1
a2481 1
            return NetToolkit.Invoke(delegate { return control.Enabled; });
d2486 1
a2486 1
            return NetToolkit.Invoke(delegate { return control.Focused; });
d2491 1
a2491 1
            return NetToolkit.Invoke(delegate { return control.Visible; });
d2843 1
a2843 1
		    return (string) NetToolkit.Invoke(delegate { return control.Text; });
@


1.57
log
@code cleanup #1
@
text
@d3119 1
a3119 1
        public java.awt.Dimension getMinimumSize()
d3123 5
a3128 5
        public java.awt.Dimension minimumSize(int rows, int cols)
		{
			return getMinimumSize(rows, cols);
		}
		
d3131 1
a3131 1
            java.awt.FontMetrics fm = getFontMetrics(((java.awt.TextArea)target).getFont());
d3135 3
a3137 3
		public java.awt.Dimension preferredSize(int rows, int cols)
		{
            return getMinimumSize(rows, cols);
d3140 1
a3140 1
		public java.awt.Dimension getPreferredSize(int rows, int cols)
d3142 1
a3142 2
			Console.WriteLine("NOTE: NetTextAreaPeer.getPreferredSize not implemented");
			return new java.awt.Dimension(10 * cols, 15 * rows);
a3234 1
        private bool alwaysOnTop;
a4169 2
        private bool isMouseClick;
        private bool isDoubleClick;
@


1.56
log
@- implements AlwaysOnTop
- add more supports for clipboard
@
text
@d69 9
a77 14
	delegate void SetVoid();
	delegate void SetBool(bool b);
	delegate void SetInt(int i);
	delegate void SetXYWH(int x, int y, int w, int h);
	delegate void SetString(string s);
	delegate string GetString();
	delegate void SetStringInt(string s, int i);
	delegate void SetRectangle(Rectangle r);
	delegate void SetColor(java.awt.Color c);
    delegate void SetCursor(java.awt.Cursor cursor);
	delegate java.awt.Dimension GetDimension();
    delegate Rectangle ConvertRectangle(Rectangle r);
    delegate object GetObject();
    internal delegate T Func<T>();
d319 1
a319 1
            java.awt.peer.FramePeer peer = (NetFramePeer)bogusForm.Invoke((GetObject)delegate { return new NetFramePeer(target); });
d326 1
a326 1
            java.awt.peer.WindowPeer peer = (NetWindowPeer)bogusForm.Invoke((GetObject)delegate { return new NetWindowPeer(target); });
d333 1
a333 1
            java.awt.peer.DialogPeer peer = (java.awt.peer.DialogPeer)bogusForm.Invoke((GetObject)delegate { return new NetDialogPeer(target); });
d809 1
a809 1
        internal static T Invoke<T>(Func<T> del)
d813 36
a848 1
                return (T)bogusForm.Invoke(del);
d856 48
d2227 1
a2227 1
		public java.awt.Dimension getMinimumSize()
d2232 1
a2232 1
		public java.awt.Dimension getPreferredSize()
d2476 1
a2476 1
            control.Invoke(new SetCursor(setCursorImpl), new object[] { cursor });
d2481 1
a2481 1
            return NetToolkit.Invoke((Func<bool>)delegate { return control.Enabled; });
d2486 1
a2486 1
            return NetToolkit.Invoke((Func<bool>)delegate { return control.Focused; });
d2491 1
a2491 1
            return NetToolkit.Invoke((Func<bool>)delegate { return control.Visible; });
d2767 1
a2767 6
			control.Invoke(new SetVoid(Setup));
		}

		private void Setup()
		{
			((Button)control).Click += new EventHandler(OnClick);
a2778 5
		private void setLabelImpl(string label)
		{
			control.Text = label;
		}

d2781 1
a2781 1
			control.Invoke(new SetString(setLabelImpl), new object[] { label });
a2840 5
		private string getTextImpl()
		{
			return control.Text;
		}

d2843 1
a2843 6
			return (string)control.Invoke(new GetString(getTextImpl));
		}

		private void setTextImpl(string text)
		{
			control.Text = text;
d2848 2
a2849 2
			control.Invoke(new SetString(setTextImpl), new object[] { text });
		}
d2872 1
a2872 1
			control.Invoke(new SetInt(setCaretPositionImpl), new object[] { pos });
d2978 1
d2982 1
a2982 1
					control.Invoke(new SetInt(setAlignImpl), new object[] { ContentAlignment.TopLeft });
d2985 1
a2985 1
					control.Invoke(new SetInt(setAlignImpl), new object[] { ContentAlignment.TopCenter });
d2988 1
a2988 1
					control.Invoke(new SetInt(setAlignImpl), new object[] { ContentAlignment.TopRight });
d2990 2
d2993 1
d2996 1
a2996 1
		private void setAlignImpl(int align)
d2998 1
a2998 1
			((Label)control).TextAlign = (ContentAlignment)align;
d3003 1
a3003 1
			control.Invoke(new SetString(setTextImpl), new Object[] { s });
d3013 1
a3013 1
			return (java.awt.Dimension)control.Invoke(new GetDimension(getPreferredSizeImpl), null);
d3111 1
a3111 1
			control.Invoke(new SetStringInt(insertImpl), new Object[] { text, pos });
d3118 7
a3124 1
		public java.awt.Dimension minimumSize(int rows, int cols)
d3128 2
a3129 1
		public java.awt.Dimension getMinimumSize(int rows, int cols)
d3131 4
a3134 2
			return new java.awt.Dimension(0, 0);
		}
d3137 2
a3138 2
			throw new NotImplementedException();
		}
d3236 1
d3405 1
a3405 1
            control.BeginInvoke(new SetVoid(((Form)control).SendToBack));
d3410 1
a3410 1
            control.BeginInvoke(new SetVoid(((Form)control).Activate));
d3420 1
a3420 1
			return control.Focus();
d3423 1
a3423 1
        public void setAlwaysOnTop(bool b)
d3425 7
a3431 4
            control.BeginInvoke((Action<bool>)delegate (bool topMost)
                                    {
                                        ((Form) control).TopMost = topMost;
                                    }, b);
a4432 4
        private System.Collections.Generic.Dictionary<int, java.awt.datatransfer.DataFlavor> flavorById =
            new System.Collections.Generic.Dictionary<int, java.awt.datatransfer.DataFlavor>();
        private System.Collections.Generic.Dictionary<string, java.awt.datatransfer.DataFlavor> flavorByName =
            new System.Collections.Generic.Dictionary<string, java.awt.datatransfer.DataFlavor>();
a4482 39

        private java.awt.datatransfer.DataFlavor GetFlavor(DataFormats.Format format)
        {
            string name = format.Name;
            string mimeType;
            switch (name)
            {
                case "Unicode String":
                    mimeType = "text/string";
                    break;
                default:
                    mimeType = null;
                    break;
            }
            return new java.awt.datatransfer.DataFlavor(mimeType, name);
        }

        internal java.awt.datatransfer.DataFlavor GetFlavor(int id)
        {
            java.awt.datatransfer.DataFlavor flavor;
            if (!flavorById.TryGetValue(id, out flavor))
            {
                DataFormats.Format format = DataFormats.GetFormat(id);
                flavorById[id] = GetFlavor(format);
            }
            return flavor;
        }

        internal java.awt.datatransfer.DataFlavor GetFlavor(string name)
        {
            java.awt.datatransfer.DataFlavor flavor;
            if (!flavorByName.TryGetValue(name, out flavor))
            {
                DataFormats.Format format = DataFormats.GetFormat(name);
                flavorByName[name] = GetFlavor(format);
            }
            return flavor;
        }

a4521 12
//                    Map flavorMap = NetDataTransferer.getInstanceImpl().getFlavorsForFormats(formats, map);
//                    flavors = (java.awt.datatransfer.DataFlavor[])(flavorMap.keySet().toArray(new java.awt.datatransfer.DataFlavor[0]));
//                    for(Iterator iter = flavorMap.entrySet().iterator(); iter.hasNext();)
//                    {
//                        Map.Entry entry = (Map.Entry) iter.next();
//                        string format = (string) entry.getValue();
//                        if (format == "UNICODE TEXT") format = "UnicodeText";
//                        if (format == "TEXT") format = "Text";
//                        java.awt.datatransfer.DataFlavor flavor = (java.awt.datatransfer.DataFlavor) entry.getKey();
//                        object objData = ConvertData(data.GetData(format), flavor, format);
//                        flavorToData.put(flavor, objData);
//                    }
@


1.55
log
@add support for swing component text
@
text
@a65 1
using sun.awt.dnd;
d960 2
a961 2
                                       SunDropTargetEvent.MOUSE_ENTERED,
                                       SunDropTargetContextPeer.DISPATCH_SYNC);
d969 2
a970 2
                                SunDropTargetEvent.MOUSE_EXITED,
                                SunDropTargetContextPeer.DISPATCH_SYNC);
d981 2
a982 2
                                       SunDropTargetEvent.MOUSE_DRAGGED,
                                       SunDropTargetContextPeer.DISPATCH_SYNC);
d993 2
a994 2
                                SunDropTargetEvent.MOUSE_DROPPED,
                                !SunDropTargetContextPeer.DISPATCH_SYNC);
a1088 1

d1603 1
a1603 1
			char keyChar = ' ';
d2092 1
a2092 1
        protected void nativeDispose()
d3353 4
a3356 1
            throw new NotImplementedException();
d4584 1
a4584 1
            SortedMap formatMap = getFormatsForTransferable(transferable, flavorMap);
d4588 2
d4591 2
d4597 1
a4597 1
                        List list = (List) transferable.getTransferData(flavor);
d4608 2
a4609 1
                        obj.SetText((string) transferable.getTransferData(flavor));
d4613 1
a4613 1
                        java.awt.Image image = transferable.getTransferData(flavor) as java.awt.Image;
d4623 17
@


1.54
log
@call Clipboard.SetData on the right thread
@
text
@d4601 1
a4601 1
                    else if (java.awt.datatransfer.DataFlavor.stringFlavor.equals(flavor))
@


1.53
log
@- code cleanup as per Jereon's suggestion
- add support for java.awt.Image
- fix problem with HDROP
@
text
@d4397 4
a4400 1
            Clipboard.SetDataObject(clipObj,true);
@


1.52
log
@add primitive support for clipboard and drag and drop
@
text
@d921 2
a922 1
                        IDataObject data = NetDataTransferer.getInstanceImpl().getDataObject(transferable);
d926 6
a931 1
                                                       setDragDropInProgress(false);
d4396 1
a4396 21
            Map formatMap = NetDataTransferer.getInstanceImpl().getFormatsForTransferable(contents, flavorMap);
            DataObject clipObj = new DataObject();
            for (Iterator iterator = formatMap.entrySet().iterator(); iterator.hasNext(); )
            {
                Map.Entry entry = (Map.Entry) iterator.next();
                java.lang.Long lFormat = (java.lang.Long)entry.getKey();
                java.awt.datatransfer.DataFlavor flavor = (java.awt.datatransfer.DataFlavor) entry.getValue();
                long format = lFormat.longValue();
                string nativeFormat = NetDataTransferer.getInstanceImpl().getNativeClipboardFormatName(format);
                try
                {
                    if (flavor.isFlavorTextType())
                        clipObj.SetData(nativeFormat, contents.getTransferData(flavor));
                } catch (java.io.IOException e)
                {
                    if (!(flavor.isMimeTypeEqual(java.awt.datatransfer.DataFlavor.javaJVMLocalObjectMimeType) &&
                          e is java.io.NotSerializableException)) {
                        e.printStackTrace();
                    }
                }             
            }
d4577 1
a4577 1
        internal IDataObject getDataObject(java.awt.datatransfer.Transferable transferable)
a4579 1
            java.awt.datatransfer.DataFlavor[] flavors = transferable.getTransferDataFlavors();
d4581 1
a4581 1
            for (Iterator iterator = formatMap.entrySet().iterator(); iterator.hasNext(); )
d4583 5
a4587 9
                Map.Entry entry = (Map.Entry)iterator.next();
//                java.lang.Long lFormat = (java.lang.Long)entry.getKey();
                java.awt.datatransfer.DataFlavor flavor = (java.awt.datatransfer.DataFlavor)entry.getValue();
                if (java.awt.datatransfer.DataFlavor.javaFileListFlavor.equals(flavor))
                {
                    List list = (List)transferable.getTransferData(flavor);
                    System.Collections.Specialized.StringCollection files =
                        new System.Collections.Specialized.StringCollection();
                    for(int i=0; i<list.size(); i++)
d4589 24
a4612 1
                        files.Add(((java.io.File)list.get(i)).getAbsolutePath());
a4613 4
                    obj.SetFileDropList(files);
                } else if (java.awt.datatransfer.DataFlavor.stringFlavor.equals(flavor))
                {
                    obj.SetText((string)transferable.getTransferData(flavor));
d4615 1
a4615 1
                else if (java.awt.datatransfer.DataFlavor.imageFlavor.equals(flavor))
d4617 5
a4621 1
                    obj.SetImage(null);
@


1.51
log
@add missing Bitmap cleanup code
@
text
@d65 2
d167 2
d171 1
d205 1
d535 17
a551 1
            throw new NotImplementedException();
d556 1
a556 1
            throw new NotImplementedException();
d840 287
d1306 1
d1403 6
d1428 5
a1432 1
            if (control.ContextMenu!=null)
d1606 136
d4348 318
@


1.50
log
@- implement setExtendedState on FramePeer
- move icon implementation from Frame to Window
- reuse initialize method as a way to initialize component (may not be the great idea as it will be called when subclass' constructor hasn't finish executing.. if we can clean up such that all subclass' constructor are empty then we're okay)
@
text
@d2948 4
a2951 2
                   Bitmap scaleBitmap = originalImage==null ? null : new Bitmap(originalImage, iconSize);
                   ((Form)control).Icon = scaleBitmap==null ? null : Icon.FromHandle(scaleBitmap.GetHicon());
@


1.49
log
@fix a bug where the default foreground/background color in paint method are not derived from the color setting of the component
@
text
@d744 13
d1016 1
a1016 1
		void initialize()
d2721 6
d2934 18
a2951 1
            throw new NotImplementedException();
a3035 3
			setTitle(frame.getTitle());
			setResizable(frame.isResizable());
            setIconImage(frame.getIconImage());
d3053 12
a3064 8
		public void setIconImage(java.awt.Image image)
		{
            if (image is java.awt.image.BufferedImage)
			{
				Bitmap bitmap = ((java.awt.image.BufferedImage)image).getBitmap();
				((Form)control).Icon = Icon.FromHandle(bitmap.GetHicon());
			}
		}
d3107 16
a3122 1
			throw new NotImplementedException();
@


1.48
log
@If the .NET control does not accept the new bounds (minimum size, maximum size) then we need to reflect the real bounds on the .NET site to the Java site
@
text
@d2038 1
a2038 1
			return new NetVolatileImage(width, height);
@


1.47
log
@COMPONENT_MOVED event added
@
text
@d1798 26
a1823 4
		public void reshape(int x, int y, int width, int height)
		{
            NetToolkit.BeginInvoke(delegate { control.SetBounds(x, y, width, height); });
		}
d2710 1
a2710 1
			// WmSizing
d2739 1
a2739 1
		}
@


1.46
log
@add basic tray icon support (note that mouse enter / exit as well as context menu don't work as .NET NotifyIcon doesn't really support it yet)
@
text
@d2683 1
d2693 8
@


1.45
log
@* code cleanup
* fix problem with swing shutdown
* experiment new code to dispose underlying .NET control and unhook all events when the peer is disposed instead of just hiding it
@
text
@d696 1
a696 1
        public override java.awt.peer.SystemTrayPeer createSystemTray(java.awt.SystemTray st)
d698 3
a700 1
            throw new NotImplementedException();
d703 1
a703 1
        public override java.awt.peer.TrayIconPeer createTrayIcon(java.awt.TrayIcon ti)
d705 3
a707 1
            throw new NotImplementedException();
d741 1
a741 1
            throw new NotImplementedException();
d1211 1
a1211 1
        private static int GetMouseEventModifiers(MouseEventArgs ev)
d1230 1
a1230 1
        private static int GetModifiers(Keys keys)
d1355 1
a1355 1
		private static int GetButton(MouseEventArgs e)
d1605 1
a1605 1
                disposed = false;
d1608 3
a1610 1
                NetToolkit.BeginInvoke(delegate { disposeImpl(); });
d1613 1
a1613 1
		private void disposeImpl()
d1616 5
d1623 2
a1624 1
		}
a2053 1

d3445 362
@


1.44
log
@Removed vestigial compact framework support.
@
text
@a59 3
using java.awt.datatransfer;
using java.awt.image;
using java.awt.peer;
d260 1
a260 1
			ButtonPeer peer = new NetButtonPeer(target);
d267 1
a267 1
			TextFieldPeer peer = new NetTextFieldPeer(target);
d274 1
a274 1
			LabelPeer peer = new NetLabelPeer(target);
d281 1
a281 1
			ListPeer peer = new NetListPeer(target);
d288 1
a288 1
			CheckboxPeer peer = new NetCheckboxPeer(target);
d305 1
a305 1
			TextAreaPeer peer = new NetTextAreaPeer(target);
d312 1
a312 1
			ChoicePeer peer = new NetChoicePeer(target);
d319 1
a319 1
            FramePeer peer = (NetFramePeer)bogusForm.Invoke( (GetObject)delegate { return new NetFramePeer(target); });
d326 1
a326 1
            WindowPeer peer = (NetWindowPeer)bogusForm.Invoke((GetObject)delegate { return new NetWindowPeer(target); });
d333 1
a333 1
            DialogPeer peer = (DialogPeer)bogusForm.Invoke((GetObject)delegate { return new NetDialogPeer(target); });
d395 1
a395 1
        public override ColorModel getColorModel()
d423 1
a423 1
                using (System.IO.FileStream stream = new System.IO.FileStream(filename, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.ReadWrite))
d425 1
a425 1
                    return new BufferedImage(new Bitmap(Image.FromStream(stream)));
d447 1
a447 1
                return new BufferedImage(new Bitmap(Image.FromStream(mem)));
d509 1
a509 1
                return new BufferedImage(new Bitmap(new MemoryStream(imagedata, imageoffset, imagelength, false)));
d582 1
a582 1
        protected override DesktopPeer createDesktopPeer(java.awt.Desktop target)
d687 1
a687 1
        public override RobotPeer createRobot(java.awt.Robot r, java.awt.GraphicsDevice screen)
d696 1
a696 1
        public override SystemTrayPeer createSystemTray(java.awt.SystemTray st)
d701 1
a701 1
        public override TrayIconPeer createTrayIcon(java.awt.TrayIcon ti)
a707 4
            // Input Method needs .NET 3.0 or higher.
            // package System.Windows.Input requiered
            //return new NetInputMethodDescriptor();
            // we don't have to provide a native input method adapter
d754 1
a754 1
		internal static new object targetToPeer(object target)
d758 41
d959 1
a959 1
	abstract class NetComponentPeer : ComponentPeer
d979 1
d1021 1
a1021 1
			setBounds(r.x, r.y, r.width, r.height, ComponentPeer.__Fields.SET_BOUNDS);
d1026 1
a1026 1
            BeginInvoke(delegate
d1028 1
a1028 1
                initEvents();
d1044 1
a1044 1
		internal void BeginInvoke(ThreadStart del)
d1046 1
a1046 37
            if (NetToolkit.bogusForm.InvokeRequired)
            {
                NetToolkit.bogusForm.BeginInvoke(del);
            }
            else
            {
                del();
            }
		}

        internal T Invoke<T>(Func<T> del)
        {
            if (NetToolkit.bogusForm.InvokeRequired)
            {
                return (T)NetToolkit.bogusForm.Invoke(del);
            }
            else
            {
                return del();
            }
        }

        internal void Invoke(MethodInvoker del)
        {
            if (NetToolkit.bogusForm.InvokeRequired)
            {
                NetToolkit.bogusForm.Invoke(del);
            }
            else
            {
                del();
            }
        }

		void pShow()
		{
            BeginInvoke(delegate { control.Visible = true; });
d1056 1
a1056 1
		internal virtual void initEvents()
d1078 21
d1143 1
a1143 1
                    ComponentPeer peer = parent.getPeer();
d1495 1
a1495 1
            BeginInvoke(delegate
d1581 1
a1581 1
            return new BufferedImage(npi.getBitmap());
d1586 1
a1586 1
			return new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
d1591 1
a1591 1
            BeginInvoke(delegate { Enable( false ); });
d1596 9
a1604 1
            BeginInvoke(delegate { disposeImpl(); });
d1609 3
a1611 2
			// HACK we should dispose the control here, but that hangs in an infinite loop...
			control.Hide();
d1616 1
a1616 1
            BeginInvoke(delegate { Enable(true); });
d1619 1
a1619 1
		public ColorModel getColorModel()
d1656 1
a1656 1
            return Invoke<java.awt.Point>(delegate
d1659 1
a1659 1
                BeginInvoke(delegate { p = control.PointToScreen(p); });
d1726 1
a1726 1
            BeginInvoke(delegate { control.Visible = false; });
d1749 1
a1749 1
		public bool prepareImage(java.awt.Image img, int width, int height, ImageObserver ob)
d1788 1
a1788 1
            BeginInvoke(delegate { control.SetBounds(x, y, width, height); });
d1796 1
a1796 1
				BeginInvoke(delegate { control.BackColor = J2C.ConvertColor(color); });
d1802 1
a1802 1
            BeginInvoke(delegate { control.SetBounds(x, y, width, height); });
d1812 1
a1812 1
			if ((op & ComponentPeer.__Fields.NO_EMBEDDED_CHECK) != 0)
d1896 1
a1896 1
            return Invoke((Func<bool>)delegate { return control.Enabled; });
d1901 1
a1901 1
            return Invoke((Func<bool>)delegate { return control.Focused; });
d1906 1
a1906 1
            return Invoke((Func<bool>)delegate { return control.Visible; });
d1926 1
a1926 1
				BeginInvoke(delegate { control.Font = font.getNetFont(); });
d1935 1
a1935 1
				BeginInvoke(delegate { control.ForeColor = J2C.ConvertColor(color); });
d2037 6
d2172 1
a2172 1
	class NetButtonPeer : NetComponentPeer, ButtonPeer
d2225 1
a2225 1
	class NetTextComponentPeer : NetComponentPeer, TextComponentPeer
d2337 1
a2337 1
	class NetChoicePeer : NetComponentPeer, ChoicePeer
d2375 1
a2375 1
	class NetCheckboxPeer : NetComponentPeer, CheckboxPeer
d2403 1
a2403 1
	class NetLabelPeer : NetComponentPeer, LabelPeer
d2461 1
a2461 1
	class NetTextFieldPeer : NetTextComponentPeer, TextFieldPeer
d2525 1
a2525 1
	class NetTextAreaPeer : NetTextComponentPeer, TextAreaPeer
d2579 1
a2579 1
	class NetContainerPeer : NetComponentPeer, ContainerPeer
d2632 1
a2632 1
	class NetPanelPeer : NetContainerPeer, PanelPeer
d2640 1
a2640 1
	class NewCanvasPeer : NetComponentPeer, CanvasPeer
d2653 1
a2653 1
	class NetWindowPeer : NetContainerPeer, WindowPeer
d2780 1
a2780 1
            BeginInvoke(delegate
d2953 1
a2953 1
	class NetFramePeer : NetWindowPeer, FramePeer
d2980 1
a2980 1
			if (image is BufferedImage)
d2982 1
a2982 1
				Bitmap bitmap = ((BufferedImage)image).getBitmap();
d3006 1
a3006 1
            BeginInvoke(delegate { control.Text = title; });
d3065 1
a3065 1
	class NetDialogPeer : NetWindowPeer, DialogPeer
d3079 1
a3079 1
            BeginInvoke(delegate { control.Text = title; });
d3099 1
a3099 1
                WindowPeer wp = (WindowPeer)ComponentAccessor.getPeer(w);
d3124 1
a3124 1
    sealed class NetKeyboardFocusManagerPeer : KeyboardFocusManagerPeer
d3221 1
a3221 1
	class NetListPeer : NetComponentPeer, ListPeer
d3309 1
a3309 1
	class NetDesktopPeer : DesktopPeer
@


1.43
log
@- code cleanup for GUI thread invocation
- fix keyboard focus and typing issue
@
text
@a526 1
#if !COMPACT_FRAMEWORK
a527 1
#endif
@


1.42
log
@- Dispose registry key.
- Removed unused local variable.
@
text
@d376 5
d1035 12
d1738 2
a1739 7
			control.Invoke(new SetVoid(requestFocusImpl), null);
		}

		private void requestFocusImpl()
		{
			control.Focus();
		}
d1751 1
a1751 1
            if (!control.Enabled || !control.Visible)
a1866 5
        private bool getEnabledImpl()
        {
            return control.Enabled;
        }

d1869 1
a1869 1
            return (bool)control.Invoke(new Func<bool>(getEnabledImpl));
d1872 1
a1872 1
        private bool getFocusImpl()
d1874 1
a1874 1
            return control.Focused;
d1877 1
a1877 1
        public bool getFocused()
d1879 1
a1879 1
            return (bool)control.Invoke(new Func<bool>(getFocusImpl));
d2132 6
a2137 1
    }
d2856 1
d3022 1
d3081 2
a3082 1
            if (parent != null)
d3091 97
@


1.41
log
@- added support for mouse wheel
- fixed UI related methods being called in the wrong thread
- fixed windows L&F not showing correctly on Windows platform
@
text
@d600 4
a603 2
            Microsoft.Win32.RegistryKey key = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(subKey, false);
            return key==null ? null : key.GetValue(valueName);
a1293 1
            int button = 0;
@


1.40
log
@fix the painting bug on the bottom and right border of not resizable dialogs.
@
text
@d598 6
d615 8
d715 1
a715 1
            throw new NotImplementedException();
d720 1
a720 1
            throw new NotImplementedException();
d734 1
a734 1
            throw new NotImplementedException();
d1048 1
d1287 16
d1343 5
d1854 21
a1874 1
		public void setEnabled(bool enabled)
d1997 1
a1997 1
		public bool isFocusable()
d2062 3
a2064 3
                temporary,
                focusedWindowChangeAllowed,
                time);
d2092 3
a2094 3
                temporary,
                focusedWindowChangeAllowed,
                time,
d2102 1
a2102 1
                if (control.Focused)
d2193 5
d2452 5
d2459 1
a2459 2
			// TODO use control.Invoke
			((TextBox)control).PasswordChar = echo_char;
d2461 16
@


1.39
log
@* implement setResizeable for dialogs
* remove the icon from dialogs
* not resizeable border of frame was wrong
@
text
@d97 1
a2544 7
            //Calculate the Insets one time
            //This is many faster because there no thread change is needed.
            Rectangle client = control.ClientRectangle;
            Rectangle r = control.RectangleToScreen( client );
            int x = r.Location.X - control.Location.X;
            int y = r.Location.Y - control.Location.Y;
            _insets = new java.awt.Insets(y, x, control.Height - client.Height - y, control.Width - client.Width - x);
d2647 30
d2864 11
a2874 11
		public void setResizable(bool resizable)
		{
			if (resizable)
			{
				((Form)control).FormBorderStyle = FormBorderStyle.Sizable;
			}
			else
			{
				((Form)control).FormBorderStyle = FormBorderStyle.FixedSingle;
			}
		}
d2953 2
a2954 2
		public void setResizable(bool resizable)
		{
d2957 1
a2957 1
                ((Form)control).FormBorderStyle = FormBorderStyle.SizableToolWindow;
d2961 1
a2961 1
                ((Form)control).FormBorderStyle = FormBorderStyle.FixedToolWindow;
@


1.38
log
@Move all control access to the bogusForm thread, a .NET requirement
@
text
@d2848 1
a2848 1
				((Form)control).FormBorderStyle = FormBorderStyle.Fixed3D;
a2851 5
		private void setTitleImpl(string title)
		{
			control.Text = title;
		}

d2854 1
a2854 1
			control.Invoke(new SetString(setTitleImpl), new object[] { title });
d2919 4
a2922 7
            control.Text = target.getTitle();
		}

		private void setTitleImpl(string title)
		{
			control.Text = title;
		}
d2926 1
a2926 1
			control.Invoke(new SetString(setTitleImpl), new object[] { title });
d2931 9
a2939 2
			throw new NotImplementedException();
		}
@


1.37
log
@implements grab() and ungrab()
@
text
@d83 2
d321 4
a324 4
			FramePeer peer = new NetFramePeer(target);
			targetCreatedPeer(target, peer);
			return peer;
		}
d328 1
a328 1
			WindowPeer peer = new NetWindowPeer(target);
d335 1
a335 1
			DialogPeer peer = new NetDialogPeer(target);
a886 18
		private static readonly AwtToolkit theInstance = new AwtToolkit();

		internal static AwtToolkit GetInstance() { return theInstance; }

		internal void SyncCall(ThreadStart del)
		{
			// TODO if we're not on the right thread we should lock (see awt_Toolkit.cpp)
			del();
		}

		internal delegate T Func<T>();

		internal T SyncCall<T>(Func<T> del)
		{
			// TODO if we're not on the right thread we should lock (see awt_Toolkit.cpp)
			return del();
		}

a921 1
		protected NetGraphicsConfiguration winGraphicsConfig;
d935 1
a935 2
			this.winGraphicsConfig =
				(NetGraphicsConfiguration)getGraphicsConfiguration();
d971 9
a979 17
			lock (this)
			{
				AwtToolkit.GetInstance().SyncCall(_Start);
			}
		}

		void _Start()
		{
			if (control.IsHandleCreated)
			{
				initEvents();
				// JDK native code also disables the window here, but since that is already done in initialize(),
				// I don't see the point
				EnableCallbacks(true);
				control.Invalidate();
				control.Update();
			}
d989 1
a989 1
		internal void Invoke(ThreadStart del)
d991 8
a998 1
			control.Invoke(del);
d1001 12
d1015 1
a1015 36
			lock (this)
			{
				AwtToolkit.GetInstance().SyncCall(_Show);
			}
		}

		void _Show()
		{
			if (control.IsHandleCreated)
			{
				Invoke(delegate { control.Visible = true; });
			}
		}

		void _Hide()
		{
			if (control.IsHandleCreated)
			{
				Invoke(delegate { control.Visible = false; });
			}
		}

		void _Enable()
		{
			if (control.IsHandleCreated)
			{
				Enable(true);
			}
		}

		void _Disable()
		{
			if (control.IsHandleCreated)
			{
				Enable(false);
			}
a1022 2
			//CriticalSection::Lock l(GetLock());
			//VerifyState();
d1420 7
a1426 18
		private void updateWindow()
		{
			lock (this)
			{
				AwtToolkit.GetInstance().SyncCall(_UpdateWindow);
			}
		}

		private void _UpdateWindow()
		{
            if (control.IsHandleCreated)
			{
				Invoke(delegate
				{
					control.Update();
				});
			}
		}
a1467 7
			AwtToolkit.GetInstance().SyncCall(_BeginValidate);
		}

		private void _BeginValidate()
		{
			//if (control.IsHandleCreated)
			//{
a1475 1
			//}
d1480 2
a1481 7
			AwtToolkit.GetInstance().SyncCall(_EndValidate);
		}

		private void _EndValidate()
		{
			//if (control.IsHandleCreated)
			//{
d1489 2
a1490 2
			//}
		}
d1518 1
a1518 4
			lock (this)
			{
				AwtToolkit.GetInstance().SyncCall(_Disable);
			}
d1523 1
a1523 1
			control.Invoke(new SetVoid(disposeImpl));
d1534 1
a1534 4
			lock (this)
			{
				AwtToolkit.GetInstance().SyncCall(_Enable);
			}
d1572 9
a1580 15
		private java.awt.Point _GetLocationOnScreen()
		{
			if (control.IsHandleCreated)
			{
				Point p = new Point();
				Invoke(delegate { p = control.PointToScreen(p); });
				return new java.awt.Point(p.X, p.Y);
			}
			return null;
		}

		public java.awt.Point getLocationOnScreen()
		{
			return AwtToolkit.GetInstance().SyncCall<java.awt.Point>(_GetLocationOnScreen);
		}
a1603 7
			AwtToolkit.GetInstance().SyncCall(delegate { _NativeHandleEvent(e); });
		}

		private void _NativeHandleEvent(java.awt.AWTEvent e)
		{
			if (control.IsHandleCreated)
			{
a1604 1
			}
d1644 1
a1644 4
			lock (this)
			{
				AwtToolkit.GetInstance().SyncCall(_Hide);
			}
d1711 1
a1711 16
			lock (this)
			{
				AwtToolkit.GetInstance().SyncCall(delegate { _Reshape(x, y, width, height); });
			}
		}

		private void _Reshape(int x, int y, int width, int height)
		{
			if (control.IsHandleCreated)
			{
				//if (IsEmbeddedFrame())
				//{
				//    ::OffsetRect(r, -r->left, -r->top);
				//}
				_ReshapeNoCheck(x, y, width, height);
			}
d1719 1
a1719 13
				Invoke(delegate { control.BackColor = J2C.ConvertColor(color); });
			}
		}

		private void _ReshapeNoCheck(int x, int y, int width, int height)
		{
			if (control.IsHandleCreated)
			{
				Invoke(delegate
				{
					// TODO this code should be made equivalent to void AwtComponent::Reshape(int x, int y, int w, int h) in awt_Component.cpp
					control.SetBounds(x, y, width, height);
				});
d1725 1
a1725 1
			AwtToolkit.GetInstance().SyncCall(delegate { _ReshapeNoCheck(x, y, width, height); });
d1834 1
a1834 1
				Invoke(delegate { control.Font = font.getNetFont(); });
d1843 1
a1843 1
				Invoke(delegate { control.ForeColor = J2C.ConvertColor(color); });
d1871 6
a1876 13
		public java.awt.GraphicsConfiguration getGraphicsConfiguration()
		{
			if (winGraphicsConfig != null)
			{
				return winGraphicsConfig;
			}
			else
			{
				// we don't need a treelock here, since
				// Component.getGraphicsConfiguration() gets it itself.
				return target.getGraphicsConfiguration();
			}
		}
@


1.36
log
@Remove duplicate event queue.
@
text
@d706 1
a706 1
        public override void grab(java.awt.Window w)
d708 5
a712 1
            throw new NotImplementedException();
d730 1
a730 1
        public override void ungrab(java.awt.Window w)
d732 5
a736 1
            throw new NotImplementedException();
d1347 1
a1347 1
		private void OnMouseDown(object sender, MouseEventArgs ev)
d2657 2
d2742 5
a2746 1
				type = java.awt.@@event.WindowEvent.WINDOW_LOST_FOCUS;
d2870 54
@


1.35
log
@fix the repainting bug on bottom and right border, what a regression of the last component restructuring
@
text
@a164 1
        internal static java.awt.EventQueue eventQueue = new java.awt.EventQueue();
a528 5
        protected override java.awt.EventQueue getSystemEventQueueImpl()
        {
            return eventQueue;
        }

@


1.34
log
@remove unused code
@
text
@d1093 7
d1105 7
d1154 1
a1154 1
			handlePaint(r.X, r.Y, r.Width, r.Height);
d1472 1
a1472 1
			if (control.IsHandleCreated)
d2576 3
@


1.33
log
@Comment out currently unused variable.
@
text
@a939 29
        private static readonly java.lang.reflect.Field compX;
        private static readonly java.lang.reflect.Field compY;
        private static readonly java.lang.reflect.Field compWidth;
        private static readonly java.lang.reflect.Field compHeight;

		static NetComponentPeer()
        {
			java.lang.reflect.Field _compX = null;
			java.lang.reflect.Field _compY = null;
			java.lang.reflect.Field _compWidth = null;
			java.lang.reflect.Field _compHeight = null;
			java.security.AccessController.doPrivileged(Delegates.toPrivilegedAction(delegate
			{
				java.lang.Class clazz = typeof(java.awt.Component);
				_compX = clazz.getDeclaredField("x");
				_compX.setAccessible(true);
				_compY = clazz.getDeclaredField("y");
				_compY.setAccessible(true);
				_compWidth = clazz.getDeclaredField("width");
				_compWidth.setAccessible(true);
				_compHeight = clazz.getDeclaredField("height");
				_compHeight.setAccessible(true);
				return null;
			}));
			compX = _compX;
			compY = _compY;
			compWidth = _compWidth;
			compHeight = _compHeight;
        }
@


1.32
log
@* WindowPeer.setModalBlocked implemented
* NetFileDialog extends from NetWindowPeer now.
@
text
@d931 1
a931 1
		private int m_validationNestCount;
@


1.31
log
@First step of Toolkit.lazilyLoadDesktopProperty(String)
@
text
@d1990 1
a1990 1
		public void show()
d2662 5
d2813 1
a2813 1
        public void setModalBlocked(java.awt.Dialog d, bool b)
d2815 27
a2841 1
            throw new NotImplementedException();
d3199 2
a3200 1
	class NetFileDialogPeer : java.awt.peer.FileDialogPeer
d3202 1
a3202 3
		private readonly java.awt.FileDialog dialog;

		internal NetFileDialogPeer(java.awt.FileDialog dialog)
a3203 1
			this.dialog = dialog;
a3223 76
			throw new NotImplementedException();
		}

		public bool requestWindowFocus()
		{
			throw new NotImplementedException();
		}

		public void toBack()
		{
			throw new NotImplementedException();
		}

		public void toFront()
		{
		}

		public void updateAlwaysOnTop()
		{
			throw new NotImplementedException();
		}

		public void beginValidate()
		{
		}

		public void cancelPendingPaint(int i1, int i2, int i3, int i4)
		{
		}

		public void endValidate()
		{
		}

		public java.awt.Insets getInsets()
		{
			return new java.awt.Insets(0, 0, 0, 0);
		}

		public java.awt.Insets insets()
		{
			return getInsets();
		}

		public bool isPaintPending()
		{
			return false;
		}

		public bool isRestackSupported()
		{
			return false;
		}

		public void restack()
		{
		}

		public bool canDetermineObscurity()
		{
			return false;
		}

		public int checkImage(java.awt.Image i1, int i2, int i3, ImageObserver io)
		{
			throw new NotImplementedException();
		}

		public void coalescePaintEvent(java.awt.@@event.PaintEvent pe)
		{
			throw new NotImplementedException();
		}

		public void createBuffers(int i, java.awt.BufferCapabilities bc)
		{
			throw new NotImplementedException();
d3226 1
a3226 223
		public java.awt.Image createImage(int i1, int i2)
		{
			throw new NotImplementedException();
		}

		public java.awt.Image createImage(ImageProducer ip)
		{
			throw new NotImplementedException();
		}

		public VolatileImage createVolatileImage(int i1, int i2)
		{
			throw new NotImplementedException();
		}

		public void destroyBuffers()
		{
			throw new NotImplementedException();
		}

		public void disable()
		{
			throw new NotImplementedException();
		}

		public void dispose()
		{
		}

		public void enable()
		{
			throw new NotImplementedException();
		}

		public void flip(java.awt.BufferCapabilities.FlipContents bcfc)
		{
			throw new NotImplementedException();
		}

		public java.awt.Image getBackBuffer()
		{
			throw new NotImplementedException();
		}

		public java.awt.Rectangle getBounds()
		{
			throw new NotImplementedException();
		}

		public ColorModel getColorModel()
		{
			throw new NotImplementedException();
		}

		public java.awt.FontMetrics getFontMetrics(java.awt.Font f)
		{
			throw new NotImplementedException();
		}

		public java.awt.Graphics getGraphics()
		{
			throw new NotImplementedException();
		}

		public java.awt.GraphicsConfiguration getGraphicsConfiguration()
		{
			throw new NotImplementedException();
		}

		public java.awt.Point getLocationOnScreen()
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension getMinimumSize()
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension getPreferredSize()
		{
			throw new NotImplementedException();
		}

		public java.awt.Toolkit getToolkit()
		{
			throw new NotImplementedException();
		}

		public void handleEvent(java.awt.AWTEvent awte)
		{
			throw new NotImplementedException();
		}

		public bool handlesWheelScrolling()
		{
			throw new NotImplementedException();
		}

		public void hide()
		{
		}

		public bool isFocusTraversable()
		{
			throw new NotImplementedException();
		}

		public bool isFocusable()
		{
			throw new NotImplementedException();
		}

		public bool isObscured()
		{
			throw new NotImplementedException();
		}

		public bool isReparentSupported()
		{
			throw new NotImplementedException();
		}

		public void layout()
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension minimumSize()
		{
			throw new NotImplementedException();
		}

		public void paint(java.awt.Graphics g)
		{
			throw new NotImplementedException();
		}

		public java.awt.Dimension preferredSize()
		{
			throw new NotImplementedException();
		}

		public bool prepareImage(java.awt.Image i1, int i2, int i3, ImageObserver io)
		{
			throw new NotImplementedException();
		}

		public void print(java.awt.Graphics g)
		{
			throw new NotImplementedException();
		}

		public void repaint(long l, int i1, int i2, int i3, int i4)
		{
			throw new NotImplementedException();
		}

		public void reparent(ContainerPeer cp)
		{
			throw new NotImplementedException();
		}

		public void requestFocus()
		{
			throw new NotImplementedException();
		}

		public bool requestFocus(java.awt.Component c, bool b1, bool b2, long l)
		{
			throw new NotImplementedException();
		}

		public void reshape(int i1, int i2, int i3, int i4)
		{
			throw new NotImplementedException();
		}

		public void setBackground(java.awt.Color c)
		{
			throw new NotImplementedException();
		}

		public void setBounds(int i1, int i2, int i3, int i4, int i5)
		{
			throw new NotImplementedException();
		}

		public void setBounds(int i1, int i2, int i3, int i4)
		{
			throw new NotImplementedException();
		}

		public void setCursor(java.awt.Cursor c)
		{
			throw new NotImplementedException();
		}

		public void setEnabled(bool b)
		{
			throw new NotImplementedException();
		}

		public void setEventMask(long l)
		{
		}

		public void setFont(java.awt.Font f)
		{
			throw new NotImplementedException();
		}

		public void setForeground(java.awt.Color c)
		{
			throw new NotImplementedException();
		}

		public void setVisible(bool b)
		{
			throw new NotImplementedException();
		}

		public void show()
d3228 1
a3253 40
		public void updateCursorImmediately()
		{
			throw new NotImplementedException();
		}

        public void applyShape(sun.java2d.pipe.Region r)
        {
            throw new NotImplementedException();
        }

        public bool requestFocus(java.awt.Component c, bool b1, bool b2, long l, sun.awt.CausedFocusEvent.Cause cfec)
        {
            throw new NotImplementedException();
        }

        public void setAlwaysOnTop(bool b)
        {
            throw new NotImplementedException();
        }

        public void setModalBlocked(java.awt.Dialog d, bool b)
        {
            throw new NotImplementedException();
        }

        public void updateFocusableWindowState()
        {
            throw new NotImplementedException();
        }

        public void updateIconImages()
        {
            throw new NotImplementedException();
        }

        public void updateMinimumSize()
        {
            throw new NotImplementedException();
        }

a3257 10

		public void beginLayout()
		{
			throw new NotImplementedException();
		}

		public void endLayout()
		{
			throw new NotImplementedException();
		}
@


1.30
log
@Give the JDialog a border back; register sun.awt.shell.Win32ShellFolderManager2 as ShellFolderManager
@
text
@d619 10
@


1.29
log
@Disabled background painting and added window activation.
@
text
@d215 9
d601 18
d634 1
a634 1
            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
d666 1
a666 1
            if (Environment.OSVersion.Platform == PlatformID.Win32NT || Environment.OSVersion.Platform == PlatformID.Win32Windows)
d2987 16
@


1.28
log
@More component work.
@
text
@d101 5
d2634 1
d2644 7
a2663 4
			// WmSizing
			SendComponentEvent(java.awt.@@event.ComponentEvent.COMPONENT_RESIZED);
			dynamicallyLayoutContainer();

d2685 3
d2690 1
a2690 1
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)target, java.awt.@@event.WindowEvent.WINDOW_ACTIVATED));
d2693 37
a2729 4
        private void OnDeactivate(object sender, EventArgs e)
        {
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)target, java.awt.@@event.WindowEvent.WINDOW_DEACTIVATED));
        }
@


1.27
log
@foreground color, background color and font fixes. Background color still isn't working though.
@
text
@a82 1
    delegate Point ConvertPoint(Point p);
d851 8
d889 6
d931 1
a931 1
			//this.paintArea = new RepaintArea();
a934 1
			/*
d936 1
a936 1
			checkCreation();
d938 2
a939 1
				(Win32GraphicsConfig)getGraphicsConfiguration();
d1069 1
a1069 2
			control.SizeChanged += new EventHandler(OnBoundsChanged);
			control.Leave += new EventHandler(OnBoundsChanged);
d1075 4
a1078 17
        /// <summary>
        /// This method is called from the same thread that call Commponent.addNotify().
        /// The constructor is called from the global event thread with form.   Invoke()
        /// Because addNotfy is synchronized with getTreeLock() and some classes are 
        /// also synchronized with it self in the GNU classpath there can be dead locks.
        /// You can use this method to modify the Component class thread safe.
        /// </summary>
        internal virtual void init()
        {
            // TODO temporaly disabled, because a Bug in classpath (Bug 30122)
            // http://gcc.gnu.org/bugzilla/show_bug.cgi?id=30122
            if(target.isFontSet())
            {
                //setFontImpl(component.getFont());
                setFont(target.getFont());
            }
        }
d1119 26
a1144 1
			if(!e.ClipRectangle.IsEmpty)
d1146 5
a1150 4
                int x = getInsetsLeft();
                int y = getInsetsTop();
				java.awt.Rectangle rect = new java.awt.Rectangle(e.ClipRectangle.X + x, e.ClipRectangle.Y + y, e.ClipRectangle.Width, e.ClipRectangle.Height);
				postEvent(new java.awt.@@event.PaintEvent(target, java.awt.@@event.PaintEvent.UPDATE, rect));
d1365 4
d1381 72
a1452 17
        /// <summary>
        /// Set the size of the component to the size of the peer if different.
        /// </summary>
        private void componentSetBounds()
        {
            Point offset = getParentOffset();
            int x = control.Left + offset.X;
            int y = control.Top + offset.Y;
            int width = control.Width;
            int height = control.Height;
            //we set it via Reflection because Sun do it also
            //a call of setBounds produce another behaviuor
            compX.setInt(this.target, x);
            compY.setInt(this.target, y);
            compWidth.setInt(this.target, width);
            compHeight.setInt(this.target, height);
        }
d1454 3
a1456 1
        private void OnBoundsChanged(object sender, EventArgs e)
d1458 1
a1458 4
			java.awt.EventQueue.invokeLater(Delegates.toRunnable(delegate {
                componentSetBounds();
				postEvent(new java.awt.@@event.ComponentEvent(target, java.awt.@@event.ComponentEvent.COMPONENT_RESIZED));
			}));
d1466 4
a1469 1
		protected void postEvent(java.awt.AWTEvent evt)
d1471 65
a1535 1
			NetToolkit.eventQueue.postEvent(evt);
d1617 11
d1630 1
a1630 5
			Point p = new Point(0, 0);
            p = control.InvokeRequired ?
                    (Point)control.Invoke(new ConvertPoint(control.PointToScreen), new object[] { p }) :
                    control.PointToScreen(p);
			return new java.awt.Point(p.X, p.Y);
d1635 1
a1635 1
			return minimumSize();
d1640 1
a1640 1
			return preferredSize();
d1648 18
d1668 31
a1698 25
            if (e is java.awt.@@event.PaintEvent)
            {
                java.awt.Graphics g = target.getGraphics();
                try
                {
                    java.awt.Rectangle r = ((java.awt.@@event.PaintEvent)e).getUpdateRect();
                    g.clipRect(r.x, r.y, r.width, r.height);
                    switch (e.getID())
                    {
                        case java.awt.@@event.PaintEvent.UPDATE:
                            target.update(g);
                            break;
                        case java.awt.@@event.PaintEvent.PAINT:
                            target.paint(g);
                            break;
                        default:
                            Console.WriteLine("Unknown PaintEvent: {0}", e.getID());
                            break;
                    }
                }
                finally
                {
                    g.dispose();
                }
            }
d1716 1
a1716 1
			return target.getSize();
d1721 1
a1721 1
			return minimumSize();
d1726 1
a1726 1
			//throw new NotImplementedException();
a1740 3
			// TODO do something with the tm parameter
			java.awt.Rectangle rect = new java.awt.Rectangle(x, y, width, height);
			postEvent(new java.awt.@@event.PaintEvent(target, java.awt.@@event.PaintEvent.UPDATE, rect));
d1773 16
a1788 1
            setBounds(x, y, width, height, java.awt.peer.ComponentPeer.__Fields.DEFAULT_OPERATION);
d1800 13
a1812 1
        protected virtual void SetBoundsImpl(int x, int y, int width, int height)
d1814 2
a1815 3
            Point offset = getParentOffset(); 
            control.SetBounds(x - offset.X, y - offset.Y, width, height);
        }
d1817 1
a1817 1
		public void setBounds(int x, int y, int width, int height, int operation)
d1819 31
a1849 3
			control.Invoke(new SetXYWH(SetBoundsImpl), new object[] { x, y, width, height });
            componentSetBounds();
        }
d1956 4
d1962 10
a1971 1
			return new NetGraphicsConfiguration(Screen.FromControl(control));
d1995 5
d2038 1
a2038 2
			// TODO
			return true;
d2043 1
a2043 2
			Rectangle r = control.Bounds;
			return new java.awt.Rectangle(r.X, r.Y, r.Width, r.Height);
d2056 1
a2575 21
		public void beginValidate()
		{
		}

		public void endValidate()
		{
		}

		public void beginLayout()
		{
		}

		public void endLayout()
		{
		}

		public bool isPaintPending()
		{
			throw new NotImplementedException();
		}

d2628 1
d2638 22
d2695 1
a2695 1
        protected override void SetBoundsImpl(int x, int y, int width, int height)
a2772 18
        internal override void init()
        {
            if (!target.isFontSet())
            {
                java.awt.Font font = new java.awt.Font("Dialog", java.awt.Font.PLAIN, 12);
                target.setFont(font);
            }
            if (!target.isForegroundSet())
            {
                target.setForeground(java.awt.SystemColor.windowText);
            }
            if (!target.isBackgroundSet())
            {
                target.setBackground(java.awt.SystemColor.window);
            }
            base.init();
        }

a3118 4
		public void beginLayout()
		{
		}

a3126 4
		public void endLayout()
		{
		}

d3468 11
a3478 1
    }
@


1.26
log
@- Changed NetComponentPeer construction to match JDK's WComponentPeer structure.
- Wrapped reflection in doPrivileged() blocks.
@
text
@a79 1
	delegate void SetFont(java.awt.Font f);
d872 1
d882 3
d1444 21
a1464 1
            return new ComponentGraphics(this);
d1600 5
a1604 6
			control.Invoke(new SetColor(SetBackColorImpl), new object[] { color });
		}

		private void SetBackColorImpl(java.awt.Color color)
		{
            control.BackColor = Color.FromArgb(color.getRGB());
a1673 5
		private void setEnabledImpl(bool enabled)
		{
			control.Enabled = enabled;
		}

d1676 8
a1683 6
			control.Invoke(new SetBool(setEnabledImpl), new object[] { enabled });
		}

        private void setFontImpl(java.awt.Font font)
		{
            control.Font = font.getNetFont();
d1688 5
a1692 1
			control.Invoke(new SetFont(setFontImpl), new object[] { font });
d1697 5
a1701 6
			control.Invoke(new SetColor(SetForeColorImpl), new object[] { color });
		}

		private void SetForeColorImpl(java.awt.Color color)
		{
            control.ForeColor = Color.FromArgb(color.getRGB());
@


1.25
log
@implements isModalityTypeSupported() and blockWindows()
@
text
@d2 44
a45 19
  Copyright (C) 2002, 2004, 2005, 2006, 2007 Jeroen Frijters
  Copyright (C) 2006 Active Endpoints, Inc.
  Copyright (C) 2006, 2007, 2008, 2009 Volker Berlin (i-net software)

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
d47 2
a48 2
  Jeroen Frijters
  jeroen@@frijters.net 
a163 1
        private static Delegate createControlInstance;
a165 2
        private delegate NetComponentPeer CreateControlInstanceDelegate(Type controlType, java.awt.Component target, Type peerType);

a167 1
            createControlInstance = new CreateControlInstanceDelegate(CreateControlImpl);
d170 1
a170 7
                form.CreateControl();
                // HACK I have no idea why this line is necessary...
                IntPtr p = form.Handle;
                if (p == IntPtr.Zero)
                {
                    // shut up compiler warning
                }
d182 10
a191 28
        internal static NetComponentPeer CreateControlImpl(Type controlType, java.awt.Component target, Type peerType)
        {
            Control control = (Control)Activator.CreateInstance(controlType);
            control.CreateControl();
            // HACK here we go again...
            IntPtr p = control.Handle;
            if (p == IntPtr.Zero)
            {
                // shut up compiler warning
            }
            NetComponentPeer peer = (NetComponentPeer)Activator.CreateInstance(peerType, new object[] { target, control });
            peer.initEvents();
            return peer;
        }

        internal static NetComponentPeer CreatePeer(Type controlType, java.awt.Component target, Type peerType)
        {
            java.awt.Container parent = target.getParent();
            if (parent != null && parent.getPeer() == null)
            {
                //This should do in Java, but it is a Bug in GNU classpath
                //because synchronized in Java this must be call with the caller thread
                parent.addNotify();
            }
            NetComponentPeer peer = (NetComponentPeer)bogusForm.Invoke(createControlInstance, new object[] { controlType, target, peerType });
            peer.init();
            return peer;
        }
d249 4
a252 2
            return (NetButtonPeer)CreatePeer(typeof(Button), target, typeof(NetButtonPeer));
        }
d256 4
a259 2
            return (NetTextFieldPeer)CreatePeer(typeof(TextBox), target, typeof(NetTextFieldPeer));
        }
d263 4
a266 2
            return (NetLabelPeer)CreatePeer(typeof(Label), target, typeof(NetLabelPeer));
        }
d270 4
a273 2
            return (NetListPeer)CreatePeer(typeof(ListBox), target, typeof(NetListPeer));
        }
d277 4
a280 2
            return (NetCheckboxPeer)CreatePeer(typeof(CheckBox), target, typeof(NetCheckboxPeer));
        }
d294 4
a297 2
            return (NetTextAreaPeer)CreatePeer(typeof(TextBox), target, typeof(NetTextAreaPeer));
        }
d301 4
a304 2
            return (NetChoicePeer)CreatePeer(typeof(ComboBox), target, typeof(NetChoicePeer));
        }
d308 4
a311 12
            if (!target.isFontSet())
            {
                java.awt.Font font = new java.awt.Font("Dialog", java.awt.Font.PLAIN, 12);
                target.setFont(font);
            }
            return (NetFramePeer)CreatePeer(typeof(MyForm), target, typeof(NetFramePeer));
        }

/*        public override java.awt.peer.CanvasPeer createCanvas(java.awt.Canvas target)
        {
            return (NewCanvasPeer)CreatePeer(typeof(MyControl), target, typeof(NewCanvasPeer));
        }
a312 5
        public override java.awt.peer.PanelPeer createPanel(java.awt.Panel target)
        {
            return (NetPanelPeer)CreatePeer(typeof(ContainerControl), target, typeof(NetPanelPeer));
        }
*/
d315 4
a318 2
            return (NetWindowPeer)CreatePeer(typeof(UndecoratedForm), target, typeof(NetWindowPeer));
        }
d322 4
a325 2
            return (NetDialogPeer)CreatePeer(typeof(MyForm), target, typeof(NetDialogPeer));
        }
d696 5
d811 5
a815 1
			: base(target, ((NetComponentPeer)target.getParent().getPeer()).control)
d817 1
d824 1
a824 1
            : base(target, GetContainerControl(target.getParent()))
d841 31
a871 1
	class NetComponentPeer : ComponentPeer
d873 2
a874 2
		internal readonly java.awt.Component component;
		internal readonly Control control;
d878 4
a881 1

d886 2
a887 1
        static NetComponentPeer()
d889 119
a1007 18
            java.lang.Class clazz = typeof(java.awt.Component);
            compX = clazz.getDeclaredField("x");
            compX.setAccessible(true);
            compY = clazz.getDeclaredField("y");
            compY.setAccessible(true);
            compWidth = clazz.getDeclaredField("width");
            compWidth.setAccessible(true);
            compHeight = clazz.getDeclaredField("height");
            compHeight.setAccessible(true);
        }

		public NetComponentPeer(java.awt.Component component, Control control)
		{
            this.control = control;
			this.component = component;
			control.TabStop = false;
			java.awt.Container parent = component.getParent();
			if(parent != null && !(this is java.awt.peer.LightweightPeer))
d1009 1
a1009 20
				if(control is Form)
				{
                    NetComponentPeer parentPeer = (NetComponentPeer)parent.getPeer();
                    if (parentPeer != null)
					{
						((Form)control).Owner = (Form)parentPeer.control;
					}
				}
				else
				{
					java.awt.Container p = parent;
					while(p != null && p.getPeer() is java.awt.peer.LightweightPeer)
					{
						p = p.getParent();
					}
					if(p != null)
					{
						control.Parent = ((NetComponentPeer)p.getPeer()).control;
					}
				}
d1011 5
a1015 3
            SetBoundsImpl(component.getX(), component.getY(), component.getWidth(), component.getHeight());
            // we need the null check, because for a Window, at this time it doesn't have a foreground yet
			if(component.getForeground() != null)
d1017 1
a1017 1
                SetForeColorImpl(component.getForeground());
d1019 5
a1023 2
			// we need the null check, because for a Window, at this time it doesn't have a background yet
			if(component.getBackground() != null)
d1025 1
a1025 1
                SetBackColorImpl(component.getBackground());
d1027 9
a1035 1
			setEnabled(component.isEnabled());
d1071 1
a1071 1
            if(component.isFontSet())
d1074 1
a1074 1
                setFont(component.getFont());
d1098 1
a1098 1
            if (!(component is java.awt.Window))
d1100 1
a1100 1
                java.awt.Container parent = component.getParent();
d1122 1
a1122 1
				postEvent(new java.awt.@@event.PaintEvent(component, java.awt.@@event.PaintEvent.UPDATE, rect));
d1199 1
a1199 1
				postEvent(new java.awt.@@event.KeyEvent(component, java.awt.@@event.KeyEvent.KEY_PRESSED, when, modifiers, keyCode, keyChar, keyLocation));
d1212 1
a1212 1
				postEvent(new java.awt.@@event.KeyEvent(component, java.awt.@@event.KeyEvent.KEY_RELEASED, when, modifiers, keyCode, keyChar, keyLocation));
d1224 1
a1224 1
				postEvent(new java.awt.@@event.KeyEvent(component, java.awt.@@event.KeyEvent.KEY_TYPED, when, modifiers, keyCode, keyChar, keyLocation));
d1238 1
a1238 1
				postEvent(new java.awt.@@event.MouseEvent(component, id, when, modifiers, x, y, clickCount, isPopup, button));
d1253 1
a1253 1
	            postEvent(new java.awt.@@event.MouseEvent(component, id, when, modifiers, x, y, clickCount, isPopup, button));
d1338 1
a1338 1
				postEvent(new java.awt.@@event.FocusEvent(component, java.awt.@@event.FocusEvent.FOCUS_GAINED));
d1345 1
a1345 1
				postEvent(new java.awt.@@event.FocusEvent(component, java.awt.@@event.FocusEvent.FOCUS_LOST));
d1361 4
a1364 4
            compX.setInt(this.component, x);
            compY.setInt(this.component, y);
            compWidth.setInt(this.component, width);
            compHeight.setInt(this.component, height);
d1371 1
a1371 1
				postEvent(new java.awt.@@event.ComponentEvent(component, java.awt.@@event.ComponentEvent.COMPONENT_RESIZED));
d1404 4
a1407 1
			setEnabled(false);
d1423 4
a1426 1
			setEnabled(true);
d1472 1
a1472 1
                java.awt.Graphics g = component.getGraphics();
d1480 1
a1480 1
                            component.update(g);
d1483 1
a1483 1
                            component.paint(g);
d1499 4
a1502 1
			setVisible(false);
d1512 1
a1512 1
			return component.getSize();
d1539 1
a1539 1
			postEvent(new java.awt.@@event.PaintEvent(component, java.awt.@@event.PaintEvent.UPDATE, rect));
d1566 1
a1566 1
            postEvent(new java.awt.@@event.FocusEvent(request, java.awt.@@event.FocusEvent.FOCUS_GAINED, temporary, component));
a1681 8
		private void setVisibleImpl(bool visible)
		{
			control.Visible = visible;
            //will already Post from GNU Classpath
			//postEvent(new java.awt.@@event.ComponentEvent(component,
			//	visible ? java.awt.@@event.ComponentEvent.COMPONENT_SHOWN : java.awt.@@event.ComponentEvent.COMPONENT_HIDDEN));
		}

d1684 8
a1691 1
			control.Invoke(new SetBool(setVisibleImpl), new object[] { visible });
d1696 4
a1699 1
			setVisible(true);
d1714 2
a1715 1
			return false;
d1720 3
d1800 3
a1802 3
        private java.lang.reflect.Method shouldNativelyFocusHeavyweight;
        private java.lang.reflect.Method processSynchronousLightweightTransfer;
        private java.lang.reflect.Method removeLastFocusRequest;
d1811 14
a1824 9
                    java.lang.Class keyboardFocusManagerCls = typeof(java.awt.KeyboardFocusManager);
                    processSynchronousLightweightTransfer = keyboardFocusManagerCls.getDeclaredMethod(
                        "processSynchronousLightweightTransfer",
                        typeof(java.awt.Component),
                        typeof(java.awt.Component),
                        java.lang.Boolean.TYPE,
                        java.lang.Boolean.TYPE,
                        java.lang.Long.TYPE);
                    processSynchronousLightweightTransfer.setAccessible(true);
d1828 1
a1828 1
                component,
d1840 15
a1854 10
                java.lang.Class keyboardFocusManagerCls = typeof(java.awt.KeyboardFocusManager);
                shouldNativelyFocusHeavyweight = keyboardFocusManagerCls.getDeclaredMethod(
                    "shouldNativelyFocusHeavyweight",
                    typeof(java.awt.Component),
                    typeof(java.awt.Component),
                    java.lang.Boolean.TYPE,
                    java.lang.Boolean.TYPE,
                    java.lang.Long.TYPE,
                    typeof(sun.awt.CausedFocusEvent.Cause));
                shouldNativelyFocusHeavyweight.setAccessible(true);
d1856 1
a1856 1
            int retval = (int)shouldNativelyFocusHeavyweight.invoke(
d1858 1
a1858 1
                component,
d1863 1
a1863 1
                cause);
d1876 10
a1885 5
                    java.lang.Class keyboardFocusManagerCls = typeof(java.awt.KeyboardFocusManager);
                    removeLastFocusRequest = keyboardFocusManagerCls.getDeclaredMethod(
                        "removeLastFocusRequest",
                        typeof(java.awt.Component));
                    removeLastFocusRequest.setAccessible(true);
d1887 1
a1887 1
                removeLastFocusRequest.invoke(null, component);
d1896 2
a1897 2
		public NetButtonPeer(java.awt.Button awtbutton, Button button)
			: base(awtbutton, button)
d1903 1
a1903 1
			button.BackColor = Color.FromArgb(awtbutton.getBackground().getRGB());
d1919 1
a1919 1
			postEvent(new java.awt.@@event.ActionEvent(component, java.awt.@@event.ActionEvent.ACTION_PERFORMED, cmd, when, modifiers));
d1940 5
d1949 2
a1950 2
		public NetTextComponentPeer(java.awt.TextComponent textComponent, TextBox textBox)
			: base(textComponent, textBox)
d1952 1
a1952 1
			if(!component.isBackgroundSet())
d1954 1
a1954 1
				component.setBackground(java.awt.SystemColor.window);
d1956 3
a1958 3
			setBackground(component.getBackground());
			textBox.AutoSize = false;
			textBox.Text = ((java.awt.TextComponent)component).getText();
d1971 1
a1971 1
				postEvent(new java.awt.@@event.ActionEvent(component, java.awt.@@event.ActionEvent.ACTION_PERFORMED, cmd, when, modifiers));
d2047 5
d2056 2
a2057 2
		public NetChoicePeer(java.awt.Choice target, ComboBox combobox)
			: base(target, combobox)
d2085 5
d2094 2
a2095 2
		public NetCheckboxPeer(java.awt.Checkbox target, CheckBox checkbox)
			: base(target, checkbox)
d2113 5
d2122 2
a2123 2
		public NetLabelPeer(java.awt.Label jlabel, Label label)
			: base(jlabel, label)
d2125 1
a2125 1
			label.Text = jlabel.getText();
d2171 5
d2180 2
a2181 2
		public NetTextFieldPeer(java.awt.TextField textField, TextBox textBox)
			: base(textField, textBox)
d2224 2
a2225 2
		public NetTextAreaPeer(java.awt.TextArea textArea, TextBox textBox)
			: base(textArea, textBox)
d2227 4
a2230 4
			textBox.ReadOnly = !((java.awt.TextArea)component).isEditable();
			textBox.WordWrap = false;
			textBox.ScrollBars = ScrollBars.Both;
			textBox.Multiline = true;
d2280 2
a2281 2
		public NetContainerPeer(java.awt.Container awtcontainer, ContainerControl container)
			: base(awtcontainer, container)
d2340 5
d2349 2
a2350 2
		public NetPanelPeer(java.awt.Panel panel, ContainerControl container)
			: base(panel, container)
d2357 6
a2362 2
		public NewCanvasPeer(java.awt.Canvas canvas, Control control)
			: base(canvas, control)
d2364 1
d2370 2
a2371 2
        public NetWindowPeer(java.awt.Window window, UndecoratedForm form)
			: base(window, form)
d2374 4
a2377 4
            form.Closing += new CancelEventHandler(OnClosing);
            form.Closed += new EventHandler(OnClosed);
            form.Activated += new EventHandler(OnActivated);
            form.Deactivate += new EventHandler(OnDeactivate);
d2389 1
a2389 1
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_OPENED));
d2395 1
a2395 1
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_CLOSING));
d2400 1
a2400 1
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_CLOSED));
d2405 1
a2405 1
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_ACTIVATED));
d2410 1
a2410 1
            postEvent(new java.awt.@@event.WindowEvent((java.awt.Window)component, java.awt.@@event.WindowEvent.WINDOW_DEACTIVATED));
d2460 1
a2460 1
            ((UndecoratedForm)control).setFocusableWindow( ((java.awt.Window)component).isFocusableWindow());
d2472 17
a2488 1
    }
d2492 2
a2493 2
		public NetFramePeer(java.awt.Frame frame, MyForm form)
			: base(frame, form)
d2502 1
a2502 1
            if (!component.isFontSet())
d2505 1
a2505 1
                component.setFont(font);
d2507 1
a2507 1
            if (!component.isForegroundSet())
d2509 1
a2509 1
                component.setForeground(java.awt.SystemColor.windowText);
d2511 1
a2511 1
            if (!component.isBackgroundSet())
d2513 1
a2513 1
                component.setBackground(java.awt.SystemColor.window);
d2606 16
d2626 2
a2627 2
        public NetDialogPeer(java.awt.Dialog target, MyForm form)
			: base(target, form)
d2629 2
a2630 2
            form.MaximizeBox = false;
            form.MinimizeBox = false;
d2656 1
a2656 1
                    wp.setModalBlocked((java.awt.Dialog)component, true);
d2664 2
a2665 2
		internal NetListPeer(java.awt.List target, ListBox listbox)
			: base(target, listbox)
d2743 5
@


1.24
log
@Fix a thread problem with setBounds. The result can be a wrong bound if it call fast multiple times. The behavior is now more like the from Sun.
@
text
@d42 1
d621 1
a621 1
        public override bool isModalityTypeSupported(java.awt.Dialog.ModalityType dmt)
d623 2
a624 1
            throw new NotImplementedException();
d2411 1
a2411 1
        public void blockWindows(List l)
d2413 8
a2420 1
            throw new NotImplementedException();
@


1.23
log
@Implemented ComponentPeer.applyShape()
@
text
@d835 17
d1216 6
a1221 7
            if (x != component.getX() ||
                y != component.getY() ||
                width != component.getWidth() ||
                height != component.getHeight())
            {
                component.setBounds(x, y, width, height);
            }
a1225 15
            int x = control.Left;
            int y = control.Top;
            int width = control.Width;
            int height = control.Height;
            if (x != component.getX() ||
                y != component.getY() ||
                width != component.getWidth() ||
                height != component.getHeight())
            {
                //If the component different then we need to update.
                //We call this in a different thread
                //because this event can be a result of a size change with the API
                //If it a result of a API change then component can be synchronized in another thread.
                new SetVoid(componentSetBounds).BeginInvoke(null, null);
            }
d1227 1
d1420 1
a1420 1
			setBounds(x, y, width, height);
d1437 1
a1437 1
		}
d1439 1
a1439 1
		public void setBounds(int x, int y, int width, int height)
d1443 1
a1443 1
		}
a1617 6
		public void setBounds(int x, int y, int width, int height, int z)
		{
            setBounds(x, y, width, height);
            //TODO changing the Z-Order
		}

a2169 1

@


1.22
log
@first step for support of InputMethod but disable now
@
text
@d1636 1
a1636 1
        public void applyShape(sun.java2d.pipe.Region r)
d1638 1
a1638 1
            throw new NotImplementedException();
@


1.21
log
@Toolkit.getInputMethodAdapterDescriptor() is allowed to return null.
@
text
@d651 5
a655 2
			// we don't have to provide a native input method adapter
			return null;
d694 43
@


1.20
log
@implementing of requestFocus
@
text
@d651 2
a652 1
            throw new NotImplementedException();
@


1.19
log
@implement WindowPeer.updateFocusableWindowState()
@
text
@d1594 10
a1603 1
        public bool requestFocus(java.awt.Component c, bool b1, bool b2, long l, sun.awt.CausedFocusEvent.Cause cfec)
d1605 70
a1674 1
            throw new NotImplementedException();
@


1.18
log
@Implement FramePeer.setMaximizedBounds
@
text
@d64 1
a64 1
			this.FormBorderStyle = FormBorderStyle.None;
d67 10
d79 1
a79 1
	class MyForm : Form
a88 1
			SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.ResizeRedraw, true);
d91 7
a97 1
        public void setMaximizedBounds(java.awt.Rectangle rect){
d2041 1
a2041 1
		public NetWindowPeer(java.awt.Window window, Form form)
d2132 1
a2132 1
            throw new NotImplementedException();
d2266 1
a2266 1
        public NetDialogPeer(java.awt.Dialog target, Form form)
@


1.17
log
@Replace the GNU ClasspathToolkit with the SunToolkit in .NET Code. Replace the usage of the FontPeer with the Java2D. Replace the NetGlyphVector with the StandardGlyphVector
@
text
@d71 6
d81 20
d2133 1
a2133 1
		public NetFramePeer(java.awt.Frame frame, Form form)
d2232 1
a2232 1
		public void setMaximizedBounds(java.awt.Rectangle r)
d2234 1
a2234 1
			throw new NotImplementedException();
@


1.16
log
@extends the NetToolkit from the SunToolkit instead of GNU ClasspathToolkit
@
text
@d1422 1
a1422 1
            control.Font = ((NetFontPeer)font.getPeer()).netFont;
@


1.15
log
@Add the new methods of the JDK6 peers with a NotImplementedException
@
text
@d4 1
a4 1
  Copyright (C) 2006, 2007, 2008 Volker Berlin (i-net software)
d93 1
a93 1
    public class NetToolkit : gnu.java.awt.ClasspathToolkit, ikvm.awt.IkvmToolkit
d208 1
a208 1
        protected override java.awt.peer.ButtonPeer createButton(java.awt.Button target)
d213 1
a213 1
        protected override java.awt.peer.TextFieldPeer createTextField(java.awt.TextField target)
d218 1
a218 1
        protected override java.awt.peer.LabelPeer createLabel(java.awt.Label target)
d223 1
a223 1
        protected override java.awt.peer.ListPeer createList(java.awt.List target)
d228 1
a228 1
        protected override java.awt.peer.CheckboxPeer createCheckbox(java.awt.Checkbox target)
d233 1
a233 1
        protected override java.awt.peer.ScrollbarPeer createScrollbar(java.awt.Scrollbar target)
d238 1
a238 1
        protected override java.awt.peer.ScrollPanePeer createScrollPane(java.awt.ScrollPane target)
d243 1
a243 1
        protected override java.awt.peer.TextAreaPeer createTextArea(java.awt.TextArea target)
d248 1
a248 1
        protected override java.awt.peer.ChoicePeer createChoice(java.awt.Choice target)
d253 1
a253 1
        protected override java.awt.peer.FramePeer createFrame(java.awt.Frame target)
d263 1
a263 1
        protected override java.awt.peer.CanvasPeer createCanvas(java.awt.Canvas target)
d268 1
a268 1
        protected override java.awt.peer.PanelPeer createPanel(java.awt.Panel target)
d272 2
a273 2

        protected override java.awt.peer.WindowPeer createWindow(java.awt.Window target)
d278 1
a278 1
        protected override java.awt.peer.DialogPeer createDialog(java.awt.Dialog target)
d283 1
a283 1
        protected override java.awt.peer.MenuBarPeer createMenuBar(java.awt.MenuBar target)
d288 1
a288 1
        protected override java.awt.peer.MenuPeer createMenu(java.awt.Menu target)
d293 1
a293 1
        protected override java.awt.peer.PopupMenuPeer createPopupMenu(java.awt.PopupMenu target)
d298 1
a298 1
        protected override java.awt.peer.MenuItemPeer createMenuItem(java.awt.MenuItem target)
d303 1
a303 1
        protected override java.awt.peer.FileDialogPeer createFileDialog(java.awt.FileDialog target)
d308 1
a308 1
        protected override java.awt.peer.CheckboxMenuItemPeer createCheckboxMenuItem(java.awt.CheckboxMenuItem target)
d313 1
a313 2
        [Obsolete]
        protected override java.awt.peer.FontPeer getFontPeer(string name, int style)
d500 1
a500 1
        public override java.awt.Font createFont(int format, java.io.InputStream stream)
d528 1
a528 1

d570 3
d583 64
@


1.14
log
@converter.cs
- ConvertRoundRect - correction in representation differences
- LineJoin, LineCap, Dash conversions
- CreateFontFamily - case sensitivity fix
fonts.cs, fonts-0.95.cs
- overriding FontMetrics.getStringBounds
- y coordinate of the returned rectangle should be the negative ascent in Java
graphics.cs
- NetGraphics.drawArc, fillArc - correction in representation differences
- NetGraphics.drawRoundRect, fillRoundRect - correction in representation differences
- NetGraphics.drawString - text was mispositioned
- NetGraphics.setStroke - BasicStroke support for LineCap, LineJoin, LineDash
- NetGraphicsEnvironment.createGraphics returned empty image
images.cs
- NetProducerImage.setPixels - implementation for byte[] argument
toolkit.cs, toolkit-0.95.cs
toolkit.cs: NetToolkit implements ikvm.awt.IkvmToolkit, see BufferedImage.createGraphics implementation
NetToolkit - getBestCursorSize, createCustomCursor implementation
NetToolkit - DoubleClick, ContextMenu support
NetToolkit - MapKeyCode did not work for Enter and Delete keys
NetToolkit - OnBoundsChanged - component resized event seems to be missing
NetToolkit - createImage(ImageProducer) implementation
NetToolkit - setCursorImpl, NetCustomCursor
NetDialogPeer - setting the title of the dialog
NetFramePeer - setting icon for the frame

Contributed by: Judit Vasko-Szedlar (Chemaxon)
@
text
@d571 10
d1481 11
a1491 1
	}
d2012 26
a2037 1
	}
d2150 6
a2155 1
	}
d2181 6
a2186 1
	}
d2702 41
a2742 1
	}
@


1.13
log
@Use new RunnableDelegate.
@
text
@d535 6
d543 1
a543 1
            throw new java.awt.AWTException("Not implemented");
d573 62
d668 2
d714 21
a734 18
        internal virtual void initEvents()
        {
            // TODO we really only should hook these events when they are needed...
            control.KeyDown += new KeyEventHandler(OnKeyDown);
            control.KeyUp += new KeyEventHandler(OnKeyUp);
            control.KeyPress += new KeyPressEventHandler(OnKeyPress);
            control.MouseMove += new MouseEventHandler(OnMouseMove);
            control.MouseDown += new MouseEventHandler(OnMouseDown);
            control.Click += new EventHandler(OnClick);
            control.MouseUp += new MouseEventHandler(OnMouseUp);
            control.MouseEnter += new EventHandler(OnMouseEnter);
            control.MouseLeave += new EventHandler(OnMouseLeave);
            control.GotFocus += new EventHandler(OnGotFocus);
            control.LostFocus += new EventHandler(OnLostFocus);
            control.SizeChanged += new EventHandler(OnBoundsChanged);
            control.Leave += new EventHandler(OnBoundsChanged);
            control.Paint += new PaintEventHandler(OnPaint);
        }
d804 1
a804 1
			switch(key)
d806 6
d904 1
a904 1
        private void postMouseEvent(MouseEventArgs ev, int id)
d909 1
a909 1
            int clickCount = ev.Clicks;
d912 1
d914 1
a914 1
				postEvent(new java.awt.@@event.MouseEvent(component, id, when, modifiers, x, y, clickCount, false, button));
d916 1
d927 1
d929 1
a929 1
	            postEvent(new java.awt.@@event.MouseEvent(component, id, when, modifiers, x, y, clickCount, false, button));
d931 1
d938 1
a938 1
                postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_DRAGGED);
d942 1
a942 1
                postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_MOVED);
d966 1
a966 1
        private void OnMouseDown(object sender, MouseEventArgs ev)
d968 4
a971 2
            isMouseClick = false;
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_PRESSED);
d979 6
a984 1
        private void OnMouseUp(object sender, MouseEventArgs ev)
d986 2
a987 2
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_RELEASED);
            if (isMouseClick)
d989 10
a998 5
                //We make our own mouse click event because the event order is different in .NET
                //in .NET the click occured before MouseUp
                postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_CLICKED);
            }
            isMouseClick = false;
d1003 2
a1004 2
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_ENTERED);
        }
d1008 1
a1008 1
            postMouseEvent(ev, java.awt.@@event.MouseEvent.MOUSE_EXITED);
d1061 3
a1063 2
            //Will allready send in component.setBounds
            //postEvent(new java.awt.@@event.ComponentEvent(component, java.awt.@@event.ComponentEvent.COMPONENT_RESIZED));
d1066 5
d1083 3
a1085 1
			throw new NotImplementedException();
d1281 6
d2001 1
d2039 5
a2043 1
			Console.WriteLine("NOTE: setIconImage not implemented");
d2114 1
@


1.12
log
@Switched java.awt.event package from GNU Classpath to OpenJDK.
@
text
@d41 1
a786 20
		private sealed class RunnableWrapper : java.lang.Runnable
		{
			private readonly ThreadStart action;

			internal RunnableWrapper(ThreadStart action)
			{
				this.action = action;
			}

			public void run()
			{
				action();
			}
		}

		private void InvokeLater(ThreadStart action)
		{
			java.awt.EventQueue.invokeLater(new RunnableWrapper(action));
		}

d795 1
a795 1
			InvokeLater(delegate {
d797 1
a797 1
			});
d808 1
a808 1
			InvokeLater(delegate {
d810 1
a810 1
			});
d820 1
a820 1
			InvokeLater(delegate {
d822 1
a822 1
			});
d833 1
a833 1
			InvokeLater(delegate {
d835 1
a835 1
			});
d846 1
a846 1
			InvokeLater(delegate {
d848 1
a848 1
			});
d918 1
a918 1
			InvokeLater(delegate {
d920 1
a920 1
			});
d925 1
a925 1
			InvokeLater(delegate {
d927 1
a927 1
			});
@


1.11
log
@Add a PrintPeer as helper class for the print API
@
text
@d786 20
d814 3
a816 1
			postEvent(new java.awt.@@event.KeyEvent(component, java.awt.@@event.KeyEvent.KEY_PRESSED, when, modifiers, keyCode, keyChar, keyLocation));
d827 3
a829 1
			postEvent(new java.awt.@@event.KeyEvent(component, java.awt.@@event.KeyEvent.KEY_RELEASED, when, modifiers, keyCode, keyChar, keyLocation));
d838 4
a841 2
			int keyLocation = java.awt.@@event.KeyEvent.KEY_LOCATION_STANDARD;
			postEvent(new java.awt.@@event.KeyEvent(component, java.awt.@@event.KeyEvent.KEY_TYPED, when, modifiers, keyCode, keyChar, keyLocation));
d852 3
a854 1
            postEvent(new java.awt.@@event.MouseEvent(component, id, when, modifiers, x, y, clickCount, false, button));
d865 3
a867 1
            postEvent(new java.awt.@@event.MouseEvent(component, id, when, modifiers, x, y, clickCount, false, button));
d937 3
a939 1
			postEvent(new java.awt.@@event.FocusEvent(component, java.awt.@@event.FocusEvent.FOCUS_GAINED));
d944 3
a946 1
			postEvent(new java.awt.@@event.FocusEvent(component, java.awt.@@event.FocusEvent.FOCUS_LOST));
@


1.10
log
@convert a Java filename to a .NET filename in createImage(String)
@
text
@d40 1
d93 1
a93 1
	{
d95 3
a97 3
		internal static volatile Form bogusForm;
		private static Delegate createControlInstance;
		private int resolution;
d101 22
a122 22
		private static void MessageLoop()
		{
			createControlInstance = new CreateControlInstanceDelegate(CreateControlImpl);
			using(Form form = new Form())
			{
				form.CreateControl();
				// HACK I have no idea why this line is necessary...
				IntPtr p = form.Handle;
				if(p == IntPtr.Zero)
				{
					// shut up compiler warning
				}
				bogusForm = form;
				// FXBUG to make sure we can be aborted (Thread.Abort) we need to periodically
				// fire an event (because otherwise we'll be blocking in unmanaged code and
				// the Abort cannot be handled there).
				System.Windows.Forms.Timer t = new System.Windows.Forms.Timer();
				t.Interval = 100;
				t.Start();
				Application.Run();
			}
		}
d125 1
a125 1
		{
d129 5
a133 5
			IntPtr p = control.Handle;
			if(p == IntPtr.Zero)
			{
				// shut up compiler warning
			}
d140 1
a140 1
		{
d151 1
a151 1
		}
d153 5
a157 5
		public NetToolkit()
		{
			lock(typeof(NetToolkit))
			{
				System.Diagnostics.Debug.Assert(bogusForm == null);
d159 12
a170 12
				Thread thread = new Thread(new ThreadStart(MessageLoop));
				thread.SetApartmentState(ApartmentState.STA);
				thread.Name = "IKVM AWT WinForms Message Loop";
				thread.IsBackground = true;
				thread.Start();
				// TODO don't use polling...
				while(bogusForm == null && thread.IsAlive)
				{
					Thread.Sleep(1);
				}
			}
		}
d172 34
a205 34
		protected override void loadSystemColors(int[] systemColors)
		{
			// initialize all colors to purple to make the ones we might have missed stand out
			for(int i = 0; i < systemColors.Length; i++)
			{
				systemColors[i] = Color.Purple.ToArgb();
			}
			systemColors[java.awt.SystemColor.DESKTOP] = SystemColors.Desktop.ToArgb();
			systemColors[java.awt.SystemColor.ACTIVE_CAPTION] = SystemColors.ActiveCaption.ToArgb();
			systemColors[java.awt.SystemColor.ACTIVE_CAPTION_TEXT] = SystemColors.ActiveCaptionText.ToArgb();
			systemColors[java.awt.SystemColor.ACTIVE_CAPTION_BORDER] = SystemColors.ActiveBorder.ToArgb();
			systemColors[java.awt.SystemColor.INACTIVE_CAPTION] = SystemColors.InactiveCaption.ToArgb();
			systemColors[java.awt.SystemColor.INACTIVE_CAPTION_TEXT] = SystemColors.InactiveCaptionText.ToArgb();
			systemColors[java.awt.SystemColor.INACTIVE_CAPTION_BORDER] = SystemColors.InactiveBorder.ToArgb();
			systemColors[java.awt.SystemColor.WINDOW] = SystemColors.Window.ToArgb();
			systemColors[java.awt.SystemColor.WINDOW_BORDER] = SystemColors.WindowFrame.ToArgb();
			systemColors[java.awt.SystemColor.WINDOW_TEXT] = SystemColors.WindowText.ToArgb();
			systemColors[java.awt.SystemColor.MENU] = SystemColors.Menu.ToArgb();
			systemColors[java.awt.SystemColor.MENU_TEXT] = SystemColors.MenuText.ToArgb();
			systemColors[java.awt.SystemColor.TEXT] = SystemColors.Window.ToArgb();
			systemColors[java.awt.SystemColor.TEXT_TEXT] = SystemColors.WindowText.ToArgb();
			systemColors[java.awt.SystemColor.TEXT_HIGHLIGHT] = SystemColors.Highlight.ToArgb();
			systemColors[java.awt.SystemColor.TEXT_HIGHLIGHT_TEXT] = SystemColors.HighlightText.ToArgb();
			systemColors[java.awt.SystemColor.TEXT_INACTIVE_TEXT] = SystemColors.GrayText.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL] = SystemColors.Control.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_TEXT] = SystemColors.ControlText.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_HIGHLIGHT] = SystemColors.ControlLight.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_LT_HIGHLIGHT] = SystemColors.ControlLightLight.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_SHADOW] = SystemColors.ControlDark.ToArgb();
			systemColors[java.awt.SystemColor.CONTROL_DK_SHADOW] = SystemColors.ControlDarkDark.ToArgb();
			systemColors[java.awt.SystemColor.SCROLLBAR] = SystemColors.ScrollBar.ToArgb();
			systemColors[java.awt.SystemColor.INFO] = SystemColors.Info.ToArgb();
			systemColors[java.awt.SystemColor.INFO_TEXT] = SystemColors.InfoText.ToArgb();
		}
d207 2
a208 2
		protected override java.awt.peer.ButtonPeer createButton(java.awt.Button target)
		{
d210 1
a210 1
		}
d212 2
a213 2
		protected override java.awt.peer.TextFieldPeer createTextField(java.awt.TextField target)
		{
d217 2
a218 2
		protected override java.awt.peer.LabelPeer createLabel(java.awt.Label target)
		{
d220 1
a220 1
		}
d222 2
a223 2
		protected override java.awt.peer.ListPeer createList(java.awt.List target)
		{
d225 1
a225 1
		}
d227 2
a228 2
		protected override java.awt.peer.CheckboxPeer createCheckbox(java.awt.Checkbox target)
		{
d230 1
a230 1
		}
d232 4
a235 4
		protected override java.awt.peer.ScrollbarPeer createScrollbar(java.awt.Scrollbar target)
		{
			throw new NotImplementedException();
		}
d237 4
a240 4
		protected override java.awt.peer.ScrollPanePeer createScrollPane(java.awt.ScrollPane target)
		{
			throw new NotImplementedException();
		}
d242 2
a243 2
		protected override java.awt.peer.TextAreaPeer createTextArea(java.awt.TextArea target)
		{
d245 1
a245 1
		}
d247 2
a248 2
		protected override java.awt.peer.ChoicePeer createChoice(java.awt.Choice target)
		{
d250 1
a250 1
		}
d252 2
a253 2
		protected override java.awt.peer.FramePeer createFrame(java.awt.Frame target)
		{
d260 1
a260 1
		}
d262 2
a263 2
		protected override java.awt.peer.CanvasPeer createCanvas(java.awt.Canvas target)
		{
d265 1
a265 1
		}
d267 2
a268 2
		protected override java.awt.peer.PanelPeer createPanel(java.awt.Panel target)
		{
d270 1
a270 1
		}
d272 2
a273 2
		protected override java.awt.peer.WindowPeer createWindow(java.awt.Window target)
		{
d275 1
a275 1
		}
d277 2
a278 2
		protected override java.awt.peer.DialogPeer createDialog(java.awt.Dialog target)
		{
d280 1
a280 1
		}
d282 4
a285 4
		protected override java.awt.peer.MenuBarPeer createMenuBar(java.awt.MenuBar target)
		{
			throw new NotImplementedException();
		}
d287 4
a290 4
		protected override java.awt.peer.MenuPeer createMenu(java.awt.Menu target)
		{
			throw new NotImplementedException();
		}
d292 4
a295 4
		protected override java.awt.peer.PopupMenuPeer createPopupMenu(java.awt.PopupMenu target)
		{
			throw new NotImplementedException();
		}
d297 4
a300 4
		protected override java.awt.peer.MenuItemPeer createMenuItem(java.awt.MenuItem target)
		{
			throw new NotImplementedException();
		}
d302 4
a305 4
		protected override java.awt.peer.FileDialogPeer createFileDialog(java.awt.FileDialog target)
		{
			return new NetFileDialogPeer(target);
		}
d307 4
a310 4
		protected override java.awt.peer.CheckboxMenuItemPeer createCheckboxMenuItem(java.awt.CheckboxMenuItem target)
		{
			throw new NotImplementedException();
		}
d312 5
a316 5
		[Obsolete]
		protected override java.awt.peer.FontPeer getFontPeer(string name, int style)
		{
			throw new NotImplementedException();
		}
d318 4
a321 4
		public override java.awt.Dimension getScreenSize()
		{
			return new java.awt.Dimension(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height);
		}
d323 11
a333 11
		public override int getScreenResolution()
		{
			if(resolution == 0)
			{
				using(Graphics g = bogusForm.CreateGraphics())
				{
					resolution = (int)Math.Round(g.DpiY);
				}
			}
			return resolution;
		}
d335 4
a338 4
		public override ColorModel getColorModel()
		{
			throw new NotImplementedException();
		}
d340 6
a345 6
		[Obsolete]
		public override string[] getFontList()
		{
			// This method is deprecated and Sun's JDK only returns these fonts as well
			return new string[] { "Dialog", "SansSerif", "Serif", "Monospaced", "DialogInput" };
		}
d347 5
a351 5
		[Obsolete]
		public override java.awt.FontMetrics getFontMetrics(java.awt.Font font)
		{
			return new NetFontMetrics(font);
		}
d353 4
a356 4
		public override void sync()
		{
			throw new NotImplementedException();
		}
d358 12
a369 12
		public override java.awt.Image getImage(string filename)
		{
			try
			{
				filename = new java.io.File(filename).getPath(); //convert a Java file name to .NET filename (slahes, backslasches, etc)
				using(System.IO.FileStream stream = new System.IO.FileStream(filename, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.ReadWrite))
				{
					return new BufferedImage(new Bitmap(Image.FromStream(stream)));
				}
			}
			catch(Exception)
			{
d371 2
a372 2
			}
		}
d374 20
a393 20
		public override java.awt.Image getImage(URL url)
		{
			// TODO extremely lame...
			System.IO.MemoryStream mem = new System.IO.MemoryStream();
			java.io.InputStream inS = url.openStream();
			int b;
			while((b = inS.read()) >= 0)
			{
				mem.WriteByte((byte)b);
			}
			try
			{
				mem.Position = 0;
				return new BufferedImage(new Bitmap(Image.FromStream(mem)));
			}
			catch
			{
				return new NoImage();
			}
		}
d395 4
a398 4
		public override java.awt.Image createImage(string filename)
		{
			return getImage(filename);
		}
d400 4
a403 4
		public override java.awt.Image createImage(URL url)
		{
			return getImage(url);
		}
d405 6
a410 6
		const int ERROR = java.awt.image.ImageObserver.__Fields.ERROR;
		const int ABORT = java.awt.image.ImageObserver.__Fields.ABORT;
		const int WIDTH = java.awt.image.ImageObserver.__Fields.WIDTH;
		const int HEIGHT = java.awt.image.ImageObserver.__Fields.HEIGHT;
		const int FRAMEBITS = java.awt.image.ImageObserver.__Fields.FRAMEBITS;
		const int ALLBITS = java.awt.image.ImageObserver.__Fields.ALLBITS;
d412 5
a416 5
		public override bool prepareImage(java.awt.Image image, int width, int height, java.awt.image.ImageObserver observer)
		{
			// HACK for now we call checkImage to obtain the status and fire the observer
			return (checkImage(image, width, height, observer) & (ALLBITS | ERROR | ABORT)) != 0;
		}
d418 16
a433 16
		public override int checkImage(java.awt.Image image, int width, int height, java.awt.image.ImageObserver observer)
		{
			if(image.getWidth(null) == -1)
			{
				if(observer != null)
				{
					observer.imageUpdate(image, ERROR | ABORT, 0, 0, -1, -1);
				}
				return ERROR | ABORT;
			}
			if(observer != null)
			{
				observer.imageUpdate(image, WIDTH + HEIGHT + FRAMEBITS + ALLBITS, 0, 0, image.getWidth(null), image.getHeight(null));
			}
			return WIDTH + HEIGHT + FRAMEBITS + ALLBITS;
		}
d435 9
a443 9
		public override java.awt.Image createImage(java.awt.image.ImageProducer producer)
		{
			NetProducerImage img = new NetProducerImage(producer);
			if(producer != null)
			{
				producer.startProduction(img);
			}
			return img;
		}
d445 2
a446 2
		public override java.awt.Image createImage(byte[] imagedata, int imageoffset, int imagelength)
		{
d455 1
a455 1
		}
d457 4
a460 4
		public override java.awt.PrintJob getPrintJob(java.awt.Frame frame, string jobtitle, Properties props)
		{
			throw new NotImplementedException();
		}
d462 1
a462 1
		public override void beep()
d467 1
a467 1
		}
d469 4
a472 4
		public override java.awt.datatransfer.Clipboard getSystemClipboard()
		{
			throw new NotImplementedException();
		}
d474 4
a477 4
		protected override java.awt.EventQueue getSystemEventQueueImpl()
		{
			return eventQueue;
		}
d479 4
a482 4
		public override java.awt.dnd.peer.DragSourceContextPeer createDragSourceContextPeer(java.awt.dnd.DragGestureEvent dge)
		{
			throw new NotImplementedException();
		}
d484 4
a487 4
		public override Map mapInputMethodHighlight(java.awt.im.InputMethodHighlight highlight)
		{
			throw new NotImplementedException();
		}
d500 4
a503 4
		public override java.awt.Font createFont(int format, java.io.InputStream stream)
		{
			throw new NotImplementedException();
		}
d505 4
a508 4
		public override gnu.java.awt.peer.ClasspathFontPeer getClasspathFontPeer(string name, java.util.Map attrs)
		{
			return new NetFontPeer(name, attrs);
		}
d510 4
a513 4
		public override java.awt.GraphicsEnvironment getLocalGraphicsEnvironment()
		{
			return new NetGraphicsEnvironment();
		}
d515 2
a516 2
		public override RobotPeer createRobot(java.awt.GraphicsDevice screen)
		{
d522 20
a541 1
		}
d543 4
a546 4
		public override gnu.java.awt.peer.EmbeddedWindowPeer createEmbeddedWindow(gnu.java.awt.EmbeddedWindow ew)
		{
			throw new NotImplementedException();
		}
d548 15
a562 4
		protected override DesktopPeer createDesktopPeer(java.awt.Desktop target)
		{
			return new NetDesktopPeer();
		}
d564 1
a564 14
		public override java.awt.Cursor createCustomCursor(java.awt.Image cursor, java.awt.Point hotSpot, string name)
		{
			throw new java.awt.AWTException("Not implemented");
		}
		
		/*===============================
		 * Implementations of interface IkvmToolkit
		 */
		 
		public java.awt.Graphics2D createGraphics(System.Drawing.Bitmap bitmap)
		{
		    return new BitmapGraphics(bitmap);
		}
	}
d574 6
a579 6
	class NetLightweightContainerPeer : NetContainerPeer, java.awt.peer.LightweightPeer
	{
		public NetLightweightContainerPeer(java.awt.Container target)
			: base(target, GetContainerControl(target.getParent()))
		{
		}
d581 3
a583 3
		private static ContainerControl GetContainerControl(java.awt.Container aContainer)
		{
			ContainerControl control = null;
d585 4
a588 4
			if (aContainer != null)
			{
				control = (ContainerControl) ((NetContainerPeer) aContainer.getPeer()).control;
			}
d590 3
a592 3
			return control;
		}
	}
@


1.9
log
@Hide new public methods in BufferedImage
@
text
@d361 1
@


1.8
log
@Remove NetBufferedImage and merge the code in the class BufferedImage. Now the class BufferedImage has 2 buffers. A Java Raster and .NET Bitmap.
@
text
@d953 1
a953 1
			return new BufferedImage(width, height);
@


1.7
log
@- Partially implemented FileDialog peer.
- Implemented isFocusTraversable() (by always returning true).
@
text
@d4 1
a4 1
  Copyright (C) 2006, 2007 Volker Berlin
d91 1
a91 1
    public class NetToolkit : gnu.java.awt.ClasspathToolkit
d363 1
a363 1
					return new NetBufferedImage(new Bitmap(Image.FromStream(stream)));
d385 1
a385 1
				return new NetBufferedImage(new Bitmap(Image.FromStream(mem)));
d447 1
a447 1
                return new NetBufferedImage(new Bitmap(new MemoryStream(imagedata, imageoffset, imagelength, false)));
d536 9
d953 1
a953 1
			return new NetBufferedImage(width, height);
@


1.6
log
@Implemented java.awt.Frame.setResizable() support.
@
text
@d303 1
a303 1
			throw new NotImplementedException();
d1043 1
a1043 1
			throw new NotImplementedException();
d2122 368
@


1.5
log
@Override not implemented method because base class returns null.
@
text
@d1848 1
d1896 8
a1903 1
			throw new NotImplementedException();
@


1.4
log
@- Removed .NET 1.1 specific code
- Removed conditional compilation of .NET 2.0 specific code
@
text
@d531 5
@


1.3
log
@- .NET 1.1 is no longer supported
- Removed .NET 2.0 warnings (except for the "unreachable code" ones)
@
text
@d462 1
a462 1
#if WHIDBEY && !COMPACT_FRAMEWORK
@


1.2
log
@Removed gnu.classpath.SystemProperties usage.
@
text
@d159 1
a159 1
				thread.ApartmentState = ApartmentState.STA;
d366 1
a366 1
			catch(Exception ex)
d449 1
a449 1
            catch (Exception ex)
@


1.1
log
@- Switched GNU Classpath AWT/Swing back to version 0.95.
- Copied GNU Classpath version of java.text.Bidi into openjdk directory.
- Copied and integrated GNU Classpath's pure Java zip support with OpenJDK zip classes.
- Added GNU Classpath 0.95 compatible versions of awt\font.cs and awt\toolkit.cs.
@
text
@d515 1
a515 2
            String osname = gnu.classpath.SystemProperties.getProperty("os.name");
            if (osname.IndexOf("Windows") >= 0)
@

