head	1.46;
access;
symbols
	v0_40_0_6:1.34
	v0_40_0_5:1.34
	v0_36_0_14:1.31.2.1
	v0_42_0_7:1.35
	v0_42_0_6:1.35
	v0_42_0_5:1.35
	v0_42_0_4:1.35
	v0_42_0_3:1.35
	v0_42_0_2:1.35
	v0_42_0_1:1.35
	v0_42_0_0:1.35
	v0_42:1.35.0.2
	v0_40_0_3:1.34
	v0_40_0_2:1.34
	v0_40_0_1:1.34
	v0_40_0_0:1.34
	v0_40:1.34.0.2
	v0_36_0_13:1.31.2.1
	v0_38_0_1:1.32
	v0_38_0_0:1.32
	v0_38:1.32.0.2
	v0_36_0_9:1.31.2.1
	v0_36_0_7:1.31.2.1
	v0_36_0_5:1.31.2.1
	v0_36_0_4:1.31.2.1
	v0_36_0_3:1.31.2.1
	v0_36_0_2:1.31
	v0_36_0_1:1.31
	v0_36_0_0:1.31
	v0_36:1.31.0.2
	v0_34_0_3:1.26.4.2
	v0_34_0_2:1.26
	v0_34_0_1:1.26
	v0_34_0_0:1.26
	v0_34:1.26.0.4
	v0_32:1.26.0.2
	v0_32_0_0:1.26
	v0_30:1.24.0.2
	v0_28_0_0:1.22
	v0_26_0_1:1.21
	v0_26_0_0:1.21
	v0_24_0_1:1.21
	v0_24_0_0:1.21
	v0_22_0_0:1.21
	v0_20_0_0:1.20
	v0_18_0_0:1.17
	v0_16_0_0:1.17
	v0_14_0_1:1.14
	v0_14_0_0:1.14
	v0_12_0_0:1.14
	v0_10_0_1:1.13
	v0_10_0_0:1.13
	v0_8_0_0:1.5;
locks; strict;
comment	@# @;


1.46
date	2010.05.27.15.24.29;	author jfrijters;	state dead;
branches;
next	1.45;

1.45
date	2010.05.27.14.54.41;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.27.14.08.58;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.27.13.23.04;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.27.13.03.26;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.27.12.36.40;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.27.12.08.01;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.27.11.47.41;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.27.11.21.23;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.27.09.17.56;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.12.04.17.39;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.14.06.22.44;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.16.05.50.59;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2008.12.24.06.21.41;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.01.10.46.30;	author jfrijters;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2007.06.01.14.03.54;	author jfrijters;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2007.06.01.13.54.01;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.31.07.04.47;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.01.09.18.29;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.12.09.24.30;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2006.08.17.07.33.39;	author jfrijters;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	2006.08.12.07.20.53;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.02.13.45.54;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.28.09.18.16;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.05.08.19.00;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.13.10.45.05;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.07.07.02.48;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.28.11.01.31;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.22.12.26.14;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.24.11.54.20;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.24.08.45.42;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.23.08.24.08;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.23.13.20.07;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.07.09.53.42;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.02.08.43.06;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.29.09.48.05;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.08.10.01.46;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.19.14.23.39;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.19.13.43.55;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.05.09.37.59;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.10.07.19.57;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.17.12.01.54;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.23.14.21.46;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.08.15.18.48;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.11.13.14.43;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.19.22.19.18;	author jfrijters;	state Exp;
branches;
next	;

1.26.4.1
date	2007.05.30.09.47.40;	author jfrijters;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2007.05.30.12.16.36;	author jfrijters;	state Exp;
branches;
next	;

1.31.2.1
date	2007.10.01.13.02.40;	author jfrijters;	state Exp;
branches;
next	;

1.32.2.1
date	2009.02.02.05.58.20;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Moved the last part of ExceptionHelper from Java to C# side.
@
text
@/*
  Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
package java.lang;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;
import java.util.ArrayList;
import cli.System.Runtime.Serialization.OnSerializingAttribute;
import cli.System.Runtime.Serialization.SerializationInfo;
import cli.System.Runtime.Serialization.StreamingContext;

final class ExceptionHelper
{
    private static final boolean cleanStackTrace = SafeGetEnvironmentVariable("IKVM_DISABLE_STACKTRACE_CLEANING") == null;
    private static final cli.System.Type System_Reflection_MethodBase = ikvm.runtime.Util.getInstanceTypeFromClass(cli.System.Reflection.MethodBase.class);
    private static final cli.System.Type System_Exception = ikvm.runtime.Util.getInstanceTypeFromClass(cli.System.Exception.class);

    @@cli.System.SerializableAttribute.Annotation
    private static final class ExceptionInfoHelper
    {
	private transient cli.System.Diagnostics.StackTrace tracePart1;
	private transient cli.System.Diagnostics.StackTrace tracePart2;
	private StackTraceElement[] stackTrace;

        ExceptionInfoHelper(StackTraceElement[] stackTrace)
        {
            this.stackTrace = stackTrace;
        }

        ExceptionInfoHelper(cli.System.Diagnostics.StackTrace tracePart1, cli.System.Diagnostics.StackTrace tracePart2)
        {
            this.tracePart1 = tracePart1;
            this.tracePart2 = tracePart2;
        }

	ExceptionInfoHelper(Throwable x, boolean captureAdditionalStackTrace)
	{
	    tracePart1 = new cli.System.Diagnostics.StackTrace(x, true);
            if(captureAdditionalStackTrace)
            {
	        tracePart2 = new cli.System.Diagnostics.StackTrace(true);
            }
	}

        @@OnSerializingAttribute.Annotation
        private void OnSerializing(StreamingContext context)
        {
            // make sure the stack trace is computed before serializing
            get_StackTrace(null);
        }

	private static boolean IsPrivateScope(cli.System.Reflection.MethodBase mb)
	{
	    // HACK shouldn't there be a better way to determine whether a method is privatescope?
	    return !mb.get_IsPrivate() && !mb.get_IsFamily() && !mb.get_IsFamilyAndAssembly() &&
		    !mb.get_IsFamilyOrAssembly() && !mb.get_IsPublic() && !mb.get_IsAssembly();
	}

	private static String getDeclaringTypeNameSafe(cli.System.Reflection.MethodBase mb)
	{
	    cli.System.Type type = mb.get_DeclaringType();
	    return type == null ? "" : type.get_FullName();
	}

	StackTraceElement[] get_StackTrace(Throwable t)
	{
	    synchronized(this)
	    {
		if(stackTrace == null)
		{
		    cli.System.Collections.ArrayList stackTrace = new cli.System.Collections.ArrayList();
                    if(tracePart1 != null)
                    {
		        int skip1 = 0;
		        if(cleanStackTrace && t instanceof NullPointerException && tracePart1.get_FrameCount() > 0)
		        {
			    // HACK if a NullPointerException originated inside an instancehelper method,
			    // we assume that the reference the method was called on was really the one that was null,
			    // so we filter it.
			    if(tracePart1.GetFrame(0).GetMethod().get_Name().startsWith("instancehelper_") &&
			        !GetMethodName(tracePart1.GetFrame(0).GetMethod()).startsWith("instancehelper_"))
			    {
			        skip1 = 1;
			    }
		        }
		        Append(stackTrace, tracePart1, skip1);
                    }
		    if(tracePart2 != null)
		    {
			int skip = 0;
			if(cleanStackTrace)
			{
			    while(tracePart2.get_FrameCount() > skip && 
				getDeclaringTypeNameSafe(tracePart2.GetFrame(skip).GetMethod()).startsWith("java.lang.ExceptionHelper"))
			    {
				skip++;
			    }
                            if(tracePart2.get_FrameCount() > skip)
                            {
                                cli.System.Reflection.MethodBase mb = tracePart2.GetFrame(skip).GetMethod();
				// here we have to check for both fillInStackTrace and .ctor, because on x64 the fillInStackTrace method
				// disappears from the stack trace due to the tail call optimization.
                                if(getDeclaringTypeNameSafe(mb).equals("java.lang.Throwable") &&
                                    (mb.get_Name().endsWith("fillInStackTrace") || mb.get_Name().equals(".ctor")))
                                {
                                    while(tracePart2.get_FrameCount() > skip)
                                    {
                                        mb = tracePart2.GetFrame(skip).GetMethod();
                                        if(!getDeclaringTypeNameSafe(mb).equals("java.lang.Throwable")
                                            || !mb.get_Name().endsWith("fillInStackTrace"))
                                        {
                                            break;
                                        }
                                        skip++;
                                    }
                                    cli.System.Type exceptionType = getTypeFromObject(t);
                                    while(tracePart2.get_FrameCount() > skip)
                                    {
                                        mb = tracePart2.GetFrame(skip).GetMethod();
                                        if(!mb.get_Name().equals(".ctor")
                                            || !mb.get_DeclaringType().IsAssignableFrom(exceptionType))
                                        {
                                            break;
                                        }
                                        skip++;
                                    }
                                }
                            }
                            // skip java.lang.Throwable.__<map>
                            while(tracePart2.get_FrameCount() > skip && IsHideFromJava(tracePart2.GetFrame(skip).GetMethod()))
                            {
                                skip++;
                            }
			    if(tracePart1 != null &&
                                tracePart1.get_FrameCount() > 0 &&
				tracePart2.get_FrameCount() > skip &&
				tracePart1.GetFrame(tracePart1.get_FrameCount() - 1).GetMethod() == tracePart2.GetFrame(skip).GetMethod())
			    {
				skip++;
			    }
			}
			Append(stackTrace, tracePart2, skip);
		    }
		    if(cleanStackTrace && stackTrace.get_Count() > 0)
		    {
			StackTraceElement elem = (StackTraceElement)stackTrace.get_Item(stackTrace.get_Count() - 1);
			if(elem.getClassName().equals("java.lang.reflect.Method"))
			{
			    stackTrace.RemoveAt(stackTrace.get_Count() - 1);
			}
		    }
		    tracePart1 = null;
		    tracePart2 = null;
	            StackTraceElement[] array = new StackTraceElement[stackTrace.get_Count()];
	            stackTrace.CopyTo((cli.System.Array)(Object)array);
	            this.stackTrace = array;
		}
	    }
	    return stackTrace.clone();
	}
	
	static void Append(cli.System.Collections.ArrayList stackTrace, cli.System.Diagnostics.StackTrace st, int skip)
	{
	    for(int i = skip; i < st.get_FrameCount(); i++)
	    {
		cli.System.Diagnostics.StackFrame frame = st.GetFrame(i);
		cli.System.Reflection.MethodBase m = frame.GetMethod();
		// TODO I may need more safety checks like these
		if(m == null || m.get_DeclaringType() == null)
		{
		    continue;
		}
                String methodName = GetMethodName(m);
                String className = getClassNameFromType(m.get_DeclaringType());
                if(cleanStackTrace &&
		    (System_Reflection_MethodBase.IsAssignableFrom(m.get_DeclaringType())
		    || className.startsWith("java.lang.ExceptionHelper")
		    || className.equals("cli.System.RuntimeMethodHandle")
                    || className.equals("java.lang.LibraryVMInterfaceImpl")
                    || (className.equals("java.lang.Throwable") && m.get_Name().equals("instancehelper_fillInStackTrace"))
                    || methodName.startsWith("__<")
		    || IsHideFromJava(m)
		    || IsPrivateScope(m))) // NOTE we assume that privatescope methods are always stubs that we should exclude
		{
		    continue;
		}
		int lineNumber = frame.GetFileLineNumber();
		if(lineNumber == 0)
		{
		    lineNumber = GetLineNumber(frame);
		}
		String fileName = frame.GetFileName();
		if(fileName != null)
		{
		    try
		    {
			fileName = new cli.System.IO.FileInfo(fileName).get_Name();
		    }
		    catch(Throwable x)
		    {
			// Mono returns "<unknown>" for frame.GetFileName() and the FileInfo constructor
			// doesn't like that
			fileName = null;
		    }
		}
		if(fileName == null)
		{
		    fileName = GetFileName(frame);
		}
		stackTrace.Add(new StackTraceElement(className, methodName, fileName, IsNative(m) ? -2 : lineNumber));
	    }
	}
    }

    // NOTE these should all be private, but they're used from the inner class and we don't want the accessor methods
    static native boolean IsHideFromJava(cli.System.Reflection.MethodBase mb);
    static native boolean IsNative(cli.System.Reflection.MethodBase mb);
    static native String GetMethodName(cli.System.Reflection.MethodBase mb);
    static native String getClassNameFromType(cli.System.Type type);
    static native int GetLineNumber(cli.System.Diagnostics.StackFrame frame);
    static native String GetFileName(cli.System.Diagnostics.StackFrame frame);
    static native cli.System.Type getTypeFromObject(Object o);

    private static native String SafeGetEnvironmentVariable(String name);
}
@


1.45
log
@Moved the remainder of the exception mapping to the C# side.
@
text
@@


1.44
log
@- Added new public API to unmap exception (ikvm.runtime.Util.unmapException()).
- Moved (parts of) mapping and unmapping to C# side.
@
text
@a30 2
import cli.System.Runtime.Serialization.IObjectReference;
import cli.System.Runtime.Serialization.ISerializable;
d35 1
a35 2
@@ikvm.lang.Internal
public final class ExceptionHelper
a36 2
    static final Key EXCEPTION_DATA_KEY = new Key();
    static final ikvm.internal.WeakIdentityMap exceptions = new ikvm.internal.WeakIdentityMap();
a39 29
    // we use Activator.CreateInstance to prevent the exception from being added to the exceptions map
    static final Throwable NOT_REMAPPED = (Throwable)cli.System.Activator.CreateInstance(System_Exception);
    private static final java.util.Hashtable failedTypes = new java.util.Hashtable();

    static
    {
        // make sure the exceptions map continues to work during AppDomain finalization
        cli.System.GC.SuppressFinalize(exceptions);
    }
    
    @@cli.System.SerializableAttribute.Annotation
    private static final class Key implements ISerializable
    {
        @@cli.System.SerializableAttribute.Annotation
        private static final class Helper implements IObjectReference
        {
            @@cli.System.Security.SecurityCriticalAttribute.Annotation
            public Object GetRealObject(StreamingContext context)
            {
                return EXCEPTION_DATA_KEY;
            }
        }

        @@cli.System.Security.SecurityCriticalAttribute.Annotation
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.SetType(ikvm.runtime.Util.getInstanceTypeFromClass(Helper.class));
        }
    }
a244 1
    static native Throwable MapExceptionImpl(Throwable t);
a247 115
    
    // native methods implemented in map.xml
    private static native void setOriginal(Throwable t, cli.System.Exception org);
    private static native boolean needStackTraceInfo(Throwable t);
    private static native void setStackTraceInfo(Throwable t, cli.System.Diagnostics.StackTrace part1, cli.System.Diagnostics.StackTrace part2);

    static Throwable MapException(Throwable t, cli.System.Type handler, boolean remap)
    {
        Throwable org = t;
        boolean nonJavaException = t instanceof cli.System.Exception;
        if (nonJavaException && remap)
        {
            if (t instanceof cli.System.TypeInitializationException)
            {
                return MapTypeInitializeException((cli.System.TypeInitializationException)t, handler);
            }
            Object obj = exceptions.get(t);
            Throwable remapped = (Throwable)obj;
            if (remapped == null)
            {
                remapped = MapExceptionImpl(t);
                if (remapped == t)
                {
                    exceptions.put(t, NOT_REMAPPED);
                }
                else
                {
                    exceptions.put(t, remapped);
                    t = remapped;
                }
            }
            else if (remapped != NOT_REMAPPED)
            {
                t = remapped;
            }
        }

        if (handler == null || isInstanceOfType(t, handler, remap))
        {
            if (t instanceof cli.System.Exception)
            {
                cli.System.Exception x = (cli.System.Exception)t;
                cli.System.Collections.IDictionary data = x.get_Data();
                if (data != null && !data.get_IsReadOnly())
                {
                    synchronized (data)
                    {
                        if (!data.Contains(EXCEPTION_DATA_KEY))
                        {
                            data.Add(EXCEPTION_DATA_KEY, new ExceptionInfoHelper(t, true));
                        }
                    }
                }
            }
            else
            {
                if (needStackTraceInfo(t))
                {
	            cli.System.Diagnostics.StackTrace tracePart1 = new cli.System.Diagnostics.StackTrace(org, true);
                    cli.System.Diagnostics.StackTrace tracePart2 = new cli.System.Diagnostics.StackTrace(true);
                    setStackTraceInfo(t, tracePart1, tracePart2);
                }
            }
            
            if (nonJavaException && !remap)
            {
                exceptions.put(t, NOT_REMAPPED);
            }
            
            if (t != org)
            {
                setOriginal(t, (cli.System.Exception)org);
	        exceptions.remove(org);
            }
            return t;
        }
        return null;
    }

    private static boolean isInstanceOfType(Throwable t, cli.System.Type type, boolean remap)
    {
        if(!remap && type == System_Exception)
        {
            return t instanceof cli.System.Exception;
        }
        return type.IsInstanceOfType(t);
    }

    static Throwable MapTypeInitializeException(cli.System.TypeInitializationException t, cli.System.Type handler)
    {
        boolean wrapped = false;
        Throwable r = ikvm.runtime.Util.mapException(t.get_InnerException());
        if(!(r instanceof Error))
        {
            r = new ExceptionInInitializerError(r);
            wrapped = true;
        }
        String type = t.get_TypeName();
        if(failedTypes.containsKey(type))
        {
            r = new NoClassDefFoundError(type).initCause(r);
            wrapped = true;
        }
        if(handler != null && !handler.IsInstanceOfType(r))
        {
            return null;
        }
        failedTypes.put(type, type);
        if(wrapped)
        {
            // transplant the stack trace
            r.setStackTrace(new ExceptionInfoHelper(t, true).get_StackTrace(t));
        }
        return r;
    }
@


1.43
log
@Moved more ExceptionHelper methods to C# side.
@
text
@a284 1
    private static native cli.System.Exception getOriginalAndClear(Throwable t);
a288 26
    static void FixateException(cli.System.Exception x)
    {
        exceptions.put(x, NOT_REMAPPED);
    }

    // also used by ikvm.extensions.ExtensionMethods.printStackTrace()
    public static Throwable UnmapException(Throwable t)
    {
        if(!(t instanceof cli.System.Exception))
        {
            cli.System.Exception org = getOriginalAndClear(t);
            if(org != null)
            {
	        exceptions.put(org, t);
                t = org;
            }
        }
        return t;
    }

    // used by ikvm.runtime.Util
    public static Throwable MapExceptionFast(Throwable t, boolean remap)
    {
        return MapException(t, null, remap);
    }

d374 1
a374 1
        Throwable r = MapExceptionFast(t.get_InnerException(), true);
@


1.42
log
@Yet more ExceptionHelper moving.
@
text
@d41 1
a41 1
    private static final ikvm.internal.WeakIdentityMap exceptions = new ikvm.internal.WeakIdentityMap();
a294 60
    static StackTraceElement[] getStackTrace(cli.System.Exception x)
    {
        synchronized (x)
        {
            ExceptionInfoHelper eih = null;
            cli.System.Collections.IDictionary data = x.get_Data();
            if (data != null && !data.get_IsReadOnly())
            {
                synchronized (data)
                {
                    eih = (ExceptionInfoHelper)data.get_Item(EXCEPTION_DATA_KEY);
                }
            }
	    if (eih == null)
	    {
	        return new StackTraceElement[0];
	    }
	    return eih.get_StackTrace(x);
	}
    }
    
    static StackTraceElement[] checkStackTrace(StackTraceElement[] original)
    {
        StackTraceElement[] copy = original.clone();
        for (int i = 0; i < copy.length; i++)
        {
            copy[i].getClass(); // efficient null check
        }
        return copy;
    }

    static void setStackTrace(cli.System.Exception x, StackTraceElement[] stackTrace)
    {
        ExceptionInfoHelper eih = new ExceptionInfoHelper(checkStackTrace(stackTrace));
        cli.System.Collections.IDictionary data = x.get_Data();
        if (data != null && !data.get_IsReadOnly())
        {
            synchronized (data)
            {
                data.set_Item(EXCEPTION_DATA_KEY, eih);
            }
        }
    }

    static void fillInStackTrace(cli.System.Exception x)
    {
        synchronized (x)
        {
            ExceptionInfoHelper eih = new ExceptionInfoHelper(null, new cli.System.Diagnostics.StackTrace(true));
            cli.System.Collections.IDictionary data = x.get_Data();
            if (data != null && !data.get_IsReadOnly())
            {
                synchronized (data)
                {
                    data.set_Item(EXCEPTION_DATA_KEY, eih);
                }
            }
        }
    }

@


1.41
log
@Moved a few more ExceptionHelper methods to C# side.
@
text
@d40 1
a40 1
    private static final Key EXCEPTION_DATA_KEY = new Key();
d46 1
a46 1
    private static final Throwable NOT_REMAPPED = (Throwable)cli.System.Activator.CreateInstance(System_Exception);
a289 12
    static void checkInitCause(Throwable _this, Throwable _this_cause, Throwable cause)
    {
        if (_this_cause != _this)
        {
            throw new IllegalStateException("Can't overwrite cause");
        }
        if (cause == _this)
        {
            throw new IllegalArgumentException("Self-causation not permitted");
        }
    }

a293 11
    
    static Throwable getCause(Throwable _this, Throwable cause)
    {
        return cause == _this ? null : cause;
    }
    
    static StackTraceElement[] computeStackTrace(Throwable t, cli.System.Diagnostics.StackTrace part1, cli.System.Diagnostics.StackTrace part2)
    {
        ExceptionInfoHelper eih = new ExceptionInfoHelper(part1, part2);
        return eih.get_StackTrace(t);
    }
@


1.40
log
@Moved printStackTrace to C# side.
@
text
@a361 23
    static String FilterMessage(String message)
    {
	if(message == null)
	{
	    message = "";
	}
	return message;
    }

    static String GetMessageFromCause(Throwable cause)
    {
	if(cause == null)
	{
	    return "";
	}
	return cause.toString();
    }

    static String getLocalizedMessage(Throwable x)
    {
	return x.getMessage();
    }

a377 10
    static String toString(Throwable x)
    {
	String message = x.getLocalizedMessage();
	if(message == null)
	{
	    return x.getClass().getName();
	}
	return x.getClass().getName() + ": " + message;
    }

@


1.39
log
@Moved ExceptionHelper.getStackTrace() to "native" code of Thread.
@
text
@a289 81
    static void printStackTrace(Throwable x)
    {
	x.printStackTrace(System.err);
    }

    static void printStackTrace(Throwable x, java.io.PrintStream printStream)
    {
        synchronized (printStream)
        {
	    for (String line : buildStackTrace(x))
	    {
	        printStream.println(line);
	    }
	}
    }

    static void printStackTrace(Throwable x, java.io.PrintWriter printWriter)
    {
        synchronized (printWriter)
        {
	    for (String line : buildStackTrace(x))
	    {
	        printWriter.println(line);
	    }
	}
    }

    private static ArrayList<String> buildStackTrace(Throwable x)
    {
	ArrayList<String> list = new ArrayList<String>();
	list.add(x.toString());
	StackTraceElement[] stack = x.getStackTrace();
	for(int i = 0; i < stack.length; i++)
	{
	    list.add("\tat " + stack[i]);
	}
	Throwable cause = x.getCause();
	while(cause != null)
	{
	    list.add("Caused by: " + cause);

	    // Cause stacktrace
	    StackTraceElement[] parentStack = stack;
	    stack = cause.getStackTrace();
	    boolean equal = false; // Is rest of stack equal to parent frame?
	    for(int i = 0; i < stack.length && !equal; i++)
	    {
		// Check if we already printed the rest of the stack
		// since it was the tail of the parent stack
		int remaining = stack.length - i;
		int element = i;
		int parentElement = parentStack.length - remaining;
		equal = parentElement >= 0 && parentElement < parentStack.length;
		while(equal && element < stack.length)
		{
		    if(stack[element].equals(parentStack[parentElement]))
		    {
			element++;
			parentElement++;
		    }
		    else
		    {
			equal = false;
		    }
		}
		// Print stacktrace element or indicate the rest is equal 
		if(!equal)
		{
		    list.add("\tat " + stack[i]);
		}
		else
		{
		    list.add("\t... " + remaining + " more");
		    break; // from stack printing for loop
		}
	    }
	    cause = cause.getCause();
	}
	return list;
    }
    
@


1.38
log
@Moved readObject/writeObject to C# side.
@
text
@a621 10

    // helper for use by java.lang.management.VMThreadInfo
    public static StackTraceElement[] getStackTrace(cli.System.Diagnostics.StackTrace st, int maxDepth)
    {
        cli.System.Collections.ArrayList stackTrace = new cli.System.Collections.ArrayList();
        ExceptionInfoHelper.Append(stackTrace, st, 0);
        StackTraceElement[] ste = new StackTraceElement[Math.min(maxDepth, stackTrace.get_Count())];
        stackTrace.CopyTo(0, (cli.System.Array)(Object)ste, 0, ste.length);
        return ste;
    }
@


1.37
log
@First step of moving all exception handling code to C#.
@
text
@a278 1
    static native void initThrowable(Object throwable, Object detailMessage, Object cause);
a284 1
    private static native Throwable getCauseForSerialization(Throwable t);
a594 25
    static void writeObject(Throwable t, ObjectOutputStream s) throws IOException
    {
        synchronized (t)
        {
	    ObjectOutputStream.PutField fields = s.putFields();
	    fields.put("detailMessage", t.getMessage());
	    Throwable cause = t.getCause();
	    if (cause == null && !(t instanceof cli.System.Exception))
	    {
	        cause = getCauseForSerialization(t);
	    }
	    fields.put("cause", cause);
	    fields.put("stackTrace", t.getStackTrace());
	    s.writeFields();
	}
    }

    static void readObject(Throwable t, ObjectInputStream s) throws IOException, ClassNotFoundException
    {
	ObjectInputStream.GetField fields = s.readFields();
	initThrowable(t, fields.get("detailMessage", null), fields.get("cause", null));
	StackTraceElement[] stackTrace = (StackTraceElement[])fields.get("stackTrace", null);
	t.setStackTrace(stackTrace == null ? new StackTraceElement[0] : stackTrace);
    }

@


1.36
log
@Prep for .NET 4.0 security model:
- serialization methods must be critical.
@
text
@a596 9
    static ObjectStreamField[] getPersistentFields()
    {
	return new ObjectStreamField[] {
	    new ObjectStreamField("detailMessage", String.class),
	    new ObjectStreamField("cause", Throwable.class),
	    new ObjectStreamField("stackTrace", StackTraceElement[].class)
	};
    }

@


1.35
log
@Take advantage of the fact that Util.getInstanceTypeFromClass() is now an intrinsic.
@
text
@d61 1
d68 1
@


1.34
log
@Rewrote exception handling to store Java exception state in our java.lang.Throwable class, instead of an additional object in a weak keyed map.
@
text
@d43 2
a44 2
    private static final cli.System.Type System_Reflection_MethodBase = cli.System.Type.GetType("System.Reflection.MethodBase, mscorlib");
    private static final cli.System.Type System_Exception = cli.System.Type.GetType("System.Exception, mscorlib");
@


1.33
log
@When an unwrapper Error escapes from a static initializer, we shouldn't replace the stack trace.
@
text
@d2 1
a2 1
  Copyright (C) 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
d31 5
d40 1
a40 4
    // the contents of the NULL_STRING should be empty (because when the exception propagates to other .NET code
    // it will return that text as the Message property), but it *must* be a copy, because we need to be
    // able to distinguish it from a user specified blank string
    private static final String NULL_STRING = new String();
a46 2
    // non-private because it is used by the ExceptionInfoHelper inner class
    /*private*/ static final Throwable CAUSE_NOT_SET = (Throwable)cli.System.Activator.CreateInstance(System_Exception);
d54 12
d67 7
d76 3
a78 5
	private cli.System.Diagnostics.StackTrace tracePart1;
	private cli.System.Diagnostics.StackTrace tracePart2;
	private cli.System.Collections.ArrayList stackTrace;
	private Throwable cause;
        private Throwable original;
d80 1
a80 1
        ExceptionInfoHelper()
d82 7
a88 1
            cause = CAUSE_NOT_SET;
a97 14
	    cause = getInnerException(x);
	    if(cause == null)
	    {
		cause = CAUSE_NOT_SET;
	    }
	}

	void captureCause(Throwable x)
	{
	    Throwable cause = getInnerException(x);
	    if(cause != null)
	    {
		this.cause = cause;
	    }
d100 2
a101 1
        void captureStack(Throwable x)
d103 2
a104 12
            if(tracePart1 == null && tracePart2 == null && stackTrace == null)
            {
                tracePart1 = new cli.System.Diagnostics.StackTrace(x, true);
                tracePart2 = new cli.System.Diagnostics.StackTrace(true);
            }
        }

        Throwable getOriginal()
        {
            Throwable org = original;
            original = null;
            return org;
a106 34
        void setOriginal(Throwable org)
        {
            original = org;
        }

	Throwable getCauseForSerialization(Throwable t)
	{
	    return cause == CAUSE_NOT_SET ? t : cause;
	}

	Throwable get_Cause()
	{
	    return cause == CAUSE_NOT_SET ? null : cause;
	}

	void set_Cause(Throwable value)
	{
	    if(cause == CAUSE_NOT_SET)
	    {
		cause = value;
	    }
	    else
	    {
		throw new IllegalStateException("Throwable cause already initialized");
	    }
	}

	void ResetStackTrace()
	{
	    stackTrace = null;
            tracePart1 = null;
            tracePart2 = new cli.System.Diagnostics.StackTrace(true);
	}

d126 1
a126 1
		    stackTrace = new cli.System.Collections.ArrayList();
d209 3
d214 1
a214 3
	    StackTraceElement[] array = new StackTraceElement[stackTrace.get_Count()];
	    stackTrace.CopyTo((cli.System.Array)(Object)array);
	    return array;
a216 7
	void set_StackTrace(StackTraceElement[] value)
	{
	    stackTrace = new cli.System.Collections.ArrayList((cli.System.Collections.ICollection)(Object)value);
	    tracePart1 = null;
	    tracePart2 = null;
	}

a271 2
    static native cli.System.Exception getInnerException(Throwable t);
    static native String getMessageFromCliException(Throwable t);
d282 7
d297 6
a302 3
	for(String line : buildStackTrace(x))
	{
	    printStream.println(line);
d308 6
a313 3
	for(String line : buildStackTrace(x))
	{
	    printWriter.println(line);
a318 4
	if(x == null)
	{
	    throw new NullPointerException();
	}
d370 2
a371 2

    private static ExceptionInfoHelper getExceptionInfoHelper(Throwable t)
d373 1
a373 2
        Object o = exceptions.get(t);
        if(o == null || o instanceof ExceptionInfoHelper)
d375 1
a375 1
            return (ExceptionInfoHelper)o;
d377 1
a377 1
        else if(o == NOT_REMAPPED)
d379 1
a379 19
            ExceptionInfoHelper eih = new ExceptionInfoHelper(t, false);
            exceptions.put(t, eih);
            return eih;
        }
        else
        {
            o = exceptions.get(o);
            if(o instanceof ExceptionInfoHelper)
            {
                return (ExceptionInfoHelper)o;
            }
            Throwable remapped = (Throwable)o;
            ExceptionInfoHelper eih = (ExceptionInfoHelper)exceptions.get(remapped);
            if(eih == null)
            {
                eih = new ExceptionInfoHelper(t, false);
                exceptions.put(remapped, eih);
            }
            return eih;
d383 1
a383 1
    static Throwable initCause(Throwable x, Throwable cause)
d385 1
a385 23
	if(x == null)
	{
	    throw new NullPointerException();
	}
	if(cause == x)
	{
	    throw new IllegalArgumentException("Cause cannot be self");
	}
        // HACK since the compiler abuses initCause(null) to trigger creation
        // of an ExceptionInfoHelper for explicitly created non-Java exceptions,
        // we allow that
        if(x instanceof cli.System.Exception && cause != null)
        {
            throw new IllegalStateException("Throwable cause already initialized");
        }
	ExceptionInfoHelper eih = getExceptionInfoHelper(x);
	if(eih == null)
	{
	    eih = new ExceptionInfoHelper();
	    exceptions.put(x, eih);
	}
	eih.set_Cause(cause);
	return x;
d387 2
a388 2

    static Throwable getCause(Throwable x)
d390 1
a390 10
	if(x == null)
	{
	    throw new NullPointerException();
	}
	ExceptionInfoHelper eih = getExceptionInfoHelper(x);
	if(eih == null)
	{
	    return getInnerException(x);
	}
	return eih.get_Cause();
d392 2
a393 2

    static StackTraceElement[] getStackTrace(Throwable x)
d395 2
a396 10
	if(x == null)
	{
	    throw new NullPointerException();
	}
	ExceptionInfoHelper ei = getExceptionInfoHelper(x);
	if(ei == null)
	{
	    return new StackTraceElement[0];
	}
	return ei.get_StackTrace(x);
d399 1
a399 1
    static void setStackTrace(Throwable x, StackTraceElement[] stackTrace)
d401 12
a412 7
	if(x == null)
	{
	    throw new NullPointerException();
	}
	for(int i = 0; i < stackTrace.length; i++)
	{
	    if(stackTrace[i] == null)
d414 1
a414 1
		throw new NullPointerException();
d416 1
d418 10
a427 8
	ExceptionInfoHelper ei = getExceptionInfoHelper(x);
	if(ei == null)
	{
	    ei = new ExceptionInfoHelper();
	    ei.captureCause(x);
	    exceptions.put(x, ei);
	}
	ei.set_StackTrace(stackTrace);
d430 1
a430 1
    static String get_NullString()
d432 9
a440 1
	return NULL_STRING;
d447 1
a447 1
	    message = NULL_STRING;
d456 1
a456 1
	    return NULL_STRING;
a460 10
    static String getMessage(Throwable x)
    {
	String message = getMessageFromCliException(x);
	if(message == NULL_STRING)
	{
	    message = null;
	}
	return message;
    }

d466 1
a466 1
    static Throwable fillInStackTrace(Throwable x)
d468 12
a479 13
	if(x == null)
	{
	    throw new NullPointerException();
	}
	ExceptionInfoHelper eih = getExceptionInfoHelper(x);
	if(eih == null)
	{
	    eih = new ExceptionInfoHelper();
	    eih.captureCause(x);
	    exceptions.put(x, eih);
	}
        eih.ResetStackTrace();
	return x;
d492 2
a493 1
    static Throwable UnmapException(Throwable t)
d497 2
a498 2
            ExceptionInfoHelper eih = (ExceptionInfoHelper)exceptions.get(t);
            if(eih != null)
d500 2
a501 6
                Throwable org = eih.getOriginal();
                if(org != null)
                {
		    exceptions.put(org, t);
                    t = org;
                }
d517 1
a517 1
        if(nonJavaException && remap)
d519 1
a519 1
            if(t instanceof cli.System.TypeInitializationException)
d524 2
a525 6
            if(obj instanceof ExceptionInfoHelper)
            {
                // we don't need to capture the stack later
                nonJavaException = false;
            }
            else
d527 2
a528 2
                Throwable remapped = (Throwable)obj;
                if(remapped == null)
d530 1
a530 10
                    remapped = MapExceptionImpl(t);
                    if(remapped == t)
                    {
                        exceptions.put(t, NOT_REMAPPED);
                    }
                    else
                    {
                        exceptions.put(t, remapped);
                        t = remapped;
                    }
d532 1
a532 1
                else if(remapped != NOT_REMAPPED)
d534 1
d538 4
d544 1
a544 1
        if(handler == null || isInstanceOfType(t, handler, remap))
d546 1
a546 1
            if(t != org || nonJavaException)
d548 3
a550 2
                ExceptionInfoHelper eih = t != org ? (ExceptionInfoHelper)exceptions.get(t) : null;
                if(eih == null)
d552 1
a552 4
                    // the exception is escaping into the wild for the first time,
                    // so we have to capture the stack trace
                    eih = new ExceptionInfoHelper(org, true);
                    if(t != org)
d554 4
a557 2
                        eih.setOriginal(org);
			exceptions.remove(org);
a558 11
                    exceptions.put(t, eih);
                    Throwable inner = getInnerException(org);
                    if(inner != null && !exceptions.containsKey(inner))
                    {
                        exceptions.put(inner, new ExceptionInfoHelper(inner, true));
                    }
                }
                else
                {
                    eih.setOriginal(org);
		    exceptions.remove(org);
d563 1
a563 2
                ExceptionInfoHelper eih = (ExceptionInfoHelper)exceptions.get(t);
                if(eih == null)
d565 3
a567 6
                    eih = new ExceptionInfoHelper(t, true);
                    exceptions.put(t, eih);
                }
                else
                {
                    eih.captureStack(t);
d569 11
d606 12
a617 11
	ObjectOutputStream.PutField fields = s.putFields();
	fields.put("detailMessage", t.getMessage());
	Throwable cause;
	ExceptionInfoHelper eih = getExceptionInfoHelper(t);
	if(eih == null)
	{
	    cause = getInnerException(t);
	}
	else
	{
	    cause = eih.getCauseForSerialization(t);
a618 3
	fields.put("cause", cause);
	fields.put("stackTrace", t.getStackTrace());
	s.writeFields();	    
d626 1
a626 1
	setStackTrace(t, stackTrace == null ? new StackTraceElement[0] : stackTrace);
d652 1
a652 1
            setStackTrace(r, new ExceptionInfoHelper(t, true).get_StackTrace(t));
@


1.32
log
@Fixed handling of methods that don't have a DeclaringType.
@
text
@d734 1
d739 1
d745 1
d752 5
a756 2
        // transplant the stack trace
        setStackTrace(r, new ExceptionInfoHelper(t, true).get_StackTrace(t));
@


1.32.2.1
log
@Changed version to 0.38.0.3 and backported these fixes:
- Fixed the stack trace when an unwrapped java.lang.Error (or subclass) escapes from a static initializer.
- It turns out that we really should create an MBeanServer in sun.management.ManagementFactory.createPlatformMBeanServer(), even if we don't populate it with anything useful, applications might still want to register their own MBeans. This fix allows Derby 10.4.2.0 to work.
- Added helpful message to ClassCastException generated for ghost array casts.
- Added check for constructor with missing body in map.xml.
- Removed over eager state checking from java.util.zip.Deflater. Fixes Lucene issue.
- Fixed enclosing method discovery to work for ReflectionOnly assemblies. This allows ikvmstub to work with ikvmc generated assemblies.
- Always emit an explicit method override if we've mangled the name/sig, because we can't predict whether it will be needed or not (without keeping track of the mangling in the base classes) and the cost is minimal since this doesn't happen all that often.
- Miranda method should use mangled name (if the name is mangled).
- Fixed pointer detection to work for types with multiple indirection levels.
- If the last call site of a subroutine wasn't reachable, the return switch would fall through potentially causing the code to be unverifiable.
- The check for unloadable types on the stack indexed the stack in the wrong order.
- Fixed exception wrapping for java.security.AccessController.doPrivileged().
- Fixed tracer to only add a trace listener in executables.
@
text
@a733 1
        boolean wrapped = false;
a737 1
            wrapped = true;
a742 1
            wrapped = true;
d749 2
a750 5
        if(wrapped)
        {
            // transplant the stack trace
            setStackTrace(r, new ExceptionInfoHelper(t, true).get_StackTrace(t));
        }
@


1.31
log
@Changed to use public StackTraceElement constructor instead of GNU Classpath specific one.
@
text
@d148 6
d183 1
a183 1
				tracePart2.GetFrame(skip).GetMethod().get_DeclaringType().get_FullName().startsWith("java.lang.ExceptionHelper"))
d192 1
a192 1
                                if(mb.get_DeclaringType().get_FullName().equals("java.lang.Throwable") &&
d198 1
a198 1
                                        if(!mb.get_DeclaringType().get_FullName().equals("java.lang.Throwable")
@


1.31.2.1
log
@Backported fixes from trunk. Changed version to 0.36.0.3.
@
text
@a147 6
	private static String getDeclaringTypeNameSafe(cli.System.Reflection.MethodBase mb)
	{
	    cli.System.Type type = mb.get_DeclaringType();
	    return type == null ? "" : type.get_FullName();
	}

d177 1
a177 1
				getDeclaringTypeNameSafe(tracePart2.GetFrame(skip).GetMethod()).startsWith("java.lang.ExceptionHelper"))
d186 1
a186 1
                                if(getDeclaringTypeNameSafe(mb).equals("java.lang.Throwable") &&
d192 1
a192 1
                                        if(!getDeclaringTypeNameSafe(mb).equals("java.lang.Throwable")
@


1.30
log
@Added tweak to exception stack trace filtering to handle x64 tail call optimization.
@
text
@d299 1
a299 1
		stackTrace.Add(new StackTraceElement(fileName, lineNumber, className, methodName, IsNative(m)));
@


1.29
log
@Fixed exception mapping memory leak.
@
text
@d184 2
d187 1
a187 1
                                    mb.get_Name().endsWith("fillInStackTrace"))
@


1.28
log
@- Fixed Throwable.printStackTrace() to call Throwable.printStackTrace(OutputStream) to support exception classes that only override printStackTrace(OutputStream).
- Fixed Throwable.printStackTrace(...) to use PrintWriter/PrintStream.println() to trigger flushing on auto-flush writers/streams.
- Fixed Throwable constructor to set cause correctly if an exception was instantiated but not thrown immediately.
@
text
@d580 1
d646 1
d658 1
@


1.27
log
@- Fixed exception handling to continue working during AppDomain finalization for unload.
- Removed static initializer from ExceptionInfoHelper.
- Use Activator.CreateInstance() hack to create NOT_REMAPPED and CAUSE_NOT_SET to prevent them from ending up in the exceptions map.
@
text
@d30 1
d82 9
d319 1
a319 1
	printStackTrace(x, System.err);
d324 4
a327 1
	printStream.print(buildStackTrace(x));
d332 4
a335 1
	printWriter.print(buildStackTrace(x));
d338 1
a338 1
    private static String buildStackTrace(Throwable x)
d344 2
a345 3
	String newline = cli.System.Environment.get_NewLine();
	StringBuffer sb = new StringBuffer();
	sb.append(x).append(newline);
d349 1
a349 1
	    sb.append("\tat ").append(stack[i]).append(newline);
d354 1
a354 1
	    sb.append("Caused by: ").append(cause).append(newline);
d383 1
a383 1
		    sb.append("\tat ").append(stack[i]).append(newline);
d387 1
a387 1
		    sb.append("\t... ").append(remaining).append(" more").append(newline);
d393 1
a393 1
	return sb.toString();
d499 1
d553 1
@


1.26
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2003, 2004, 2005, 2006 Jeroen Frijters
d26 4
a29 3
import java.io.*;
import java.lang.reflect.*;
import gnu.classpath.SystemProperties;
d40 6
a45 3
    private static cli.System.Type System_Reflection_MethodBase = cli.System.Type.GetType("System.Reflection.MethodBase, mscorlib");
    private static cli.System.Type System_Exception = cli.System.Type.GetType("System.Exception, mscorlib");
    private static final Throwable NOT_REMAPPED = new cli.System.Exception();
d48 6
a55 1
	private static final Throwable CAUSE_NOT_SET = new cli.System.Exception();
@


1.26.4.1
log
@Fixed exception mapping memory leak.
@
text
@d2 1
a2 1
  Copyright (C) 2003, 2004, 2005, 2006, 2007 Jeroen Frijters
a553 1
		    exceptions.put(org, t);
a618 1
			exceptions.remove(org);
a629 1
		    exceptions.remove(org);
@


1.26.4.2
log
@Back ported exception fixes:
- Fixed Throwable.printStackTrace() to call Throwable.printStackTrace(OutputStream) to support exception classes that only override printStackTrace(OutputStream).
- Fixed Throwable.printStackTrace(…) to use PrintWriter/PrintStream.println() to trigger flushing on auto-flush writers/streams.
- Fixed Throwable constructor to set cause correctly if an exception was instantiated but not thrown immediately.
@
text
@d26 3
a28 5
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;
import java.util.ArrayList;
d39 3
a41 6
    private static final cli.System.Type System_Reflection_MethodBase = cli.System.Type.GetType("System.Reflection.MethodBase, mscorlib");
    private static final cli.System.Type System_Exception = cli.System.Type.GetType("System.Exception, mscorlib");
    // we use Activator.CreateInstance to prevent the exception from being added to the exceptions map
    private static final Throwable NOT_REMAPPED = (Throwable)cli.System.Activator.CreateInstance(System_Exception);
    // non-private because it is used by the ExceptionInfoHelper inner class
    /*private*/ static final Throwable CAUSE_NOT_SET = (Throwable)cli.System.Activator.CreateInstance(System_Exception);
a43 6
    static
    {
        // make sure the exceptions map continues to work during AppDomain finalization
        cli.System.GC.SuppressFinalize(exceptions);
    }

d46 1
a71 9
	void captureCause(Throwable x)
	{
	    Throwable cause = getInnerException(x);
	    if(cause != null)
	    {
		this.cause = cause;
	    }
	}

d300 1
a300 1
	x.printStackTrace(System.err);
d305 1
a305 4
	for(String line : buildStackTrace(x))
	{
	    printStream.println(line);
	}
d310 1
a310 4
	for(String line : buildStackTrace(x))
	{
	    printWriter.println(line);
	}
d313 1
a313 1
    private static ArrayList<String> buildStackTrace(Throwable x)
d319 3
a321 2
	ArrayList<String> list = new ArrayList<String>();
	list.add(x.toString());
d325 1
a325 1
	    list.add("\tat " + stack[i]);
d330 1
a330 1
	    list.add("Caused by: " + cause);
d359 1
a359 1
		    list.add("\tat " + stack[i]);
d363 1
a363 1
		    list.add("\t... " + remaining + " more");
d369 1
a369 1
	return list;
a474 1
	    ei.captureCause(x);
a527 1
	    eih.captureCause(x);
@


1.25
log
@*** empty log message ***
@
text
@d561 2
a562 1
    static Throwable MapExceptionFast(Throwable t, boolean remap)
@


1.24
log
@*** empty log message ***
@
text
@d387 6
a392 1
            Throwable remapped = (Throwable)exceptions.get(o);
@


1.23
log
@*** empty log message ***
@
text
@d569 1
a569 1
                return MapTypeInitializeException((cli.System.TypeInitializationException)t);
d689 1
a689 1
    static Throwable MapTypeInitializeException(cli.System.TypeInitializationException t)
d691 5
a695 1
        Throwable r;
d699 1
a699 1
            r = new NoClassDefFoundError();
d701 1
a701 1
        else
d703 1
a703 6
            failedTypes.put(type, type);
            r = MapExceptionFast(t.get_InnerException(), true);
            if(!(r instanceof Error))
            {
                r = new ExceptionInInitializerError(r);
            }
d705 1
@


1.22
log
@*** empty log message ***
@
text
@d30 2
a31 1
final class ExceptionHelper
d710 10
@


1.21
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2003, 2004, 2005 Jeroen Frijters
d36 1
a36 1
    private static final java.util.WeakHashMap exceptions = new java.util.WeakHashMap();
d248 1
@


1.20
log
@*** empty log message ***
@
text
@d57 1
a57 1
	ExceptionInfoHelper(Throwable x)
d60 4
a63 1
	    tracePart2 = new cli.System.Diagnostics.StackTrace(true);
d370 26
d413 1
a413 1
	ExceptionInfoHelper eih = (ExceptionInfoHelper)exceptions.get(x);
d429 1
a429 1
	ExceptionInfoHelper eih = (ExceptionInfoHelper)exceptions.get(x);
d443 1
a443 1
	ExceptionInfoHelper ei = (ExceptionInfoHelper)exceptions.get(x);
d464 1
a464 1
	ExceptionInfoHelper ei = (ExceptionInfoHelper)exceptions.get(x);
d517 1
a517 1
	ExceptionInfoHelper eih = (ExceptionInfoHelper)exceptions.get(x);
d607 1
a607 1
                    eih = new ExceptionInfoHelper(org);
d616 1
a616 1
                        exceptions.put(inner, new ExceptionInfoHelper(inner));
d629 1
a629 1
                    eih = new ExceptionInfoHelper(t);
d665 1
a665 1
	ExceptionInfoHelper eih = (ExceptionInfoHelper)exceptions.get(t);
d705 1
a705 1
        setStackTrace(r, new ExceptionInfoHelper(t).get_StackTrace(t));
@


1.19
log
@*** empty log message ***
@
text
@d37 1
a37 1
    private static final boolean cleanStackTrace = SystemProperties.getProperty("ikvm.cleanstacktrace", "1").equals("1");
d291 2
@


1.18
log
@*** empty log message ***
@
text
@d658 1
a658 1
        // TODO we should handle the stack traces better
d662 1
a662 1
            return new NoClassDefFoundError();
d664 1
a664 3
        failedTypes.put(type, type);
        Throwable r = MapExceptionFast(t.get_InnerException(), true);
        if(r instanceof Error)
d666 6
a671 1
            return r;
d673 3
a675 1
        return new ExceptionInInitializerError(r);
@


1.17
log
@*** empty log message ***
@
text
@d41 1
d534 4
d655 17
@


1.16
log
@*** empty log message ***
@
text
@d643 1
a643 1
    static void readObject(Throwable t, ObjectInputStream s) throws IOException
d645 1
a645 9
	ObjectInputStream.GetField fields = null;
	try
	{
	    fields = s.readFields();
	}
	catch(ClassNotFoundException x)
	{
	    throw new IOException(x.getMessage());
	}
@


1.15
log
@*** empty log message ***
@
text
@d49 1
a49 1
        private cli.System.WeakReference original;
d56 1
a56 1
	ExceptionInfoHelper(Throwable x, Throwable org)
a57 8
            if(org != null)
            {
                // TODO to prevent a memory leak, we must use a WeakReference here, but it is not
                // actually correct because it will allow the original to be collected to early.
                // This problem will be resolved when we move the state for Java exceptions into
                // java.lang.Throwable.
                original = new cli.System.WeakReference(org);
            }
d78 8
a85 5
            if(original != null)
            {
                return (Throwable)original.get_Target();
            }
            return null;
d555 1
a555 1
                else
d557 1
a557 1
                    t = remapped == NOT_REMAPPED ? t : remapped;
d566 18
a583 5
                // the exception is escaping into the wild for the first time,
                // so we have to capture the stack trace
                exceptions.put(t, new ExceptionInfoHelper(org, t != org ? org : null));
                Throwable inner = getInnerException(org);
                if(inner != null && !exceptions.containsKey(inner))
d585 1
a585 1
                    exceptions.put(inner, new ExceptionInfoHelper(inner, null));
d593 1
a593 1
                    eih = new ExceptionInfoHelper(t, null);
@


1.14
log
@*** empty log message ***
@
text
@d40 1
d42 1
a42 1
    private static class ExceptionInfoHelper
d49 1
d51 15
a65 2
	ExceptionInfoHelper(Throwable x)
	{
d75 18
d118 2
a119 2
	    tracePart1 = new cli.System.Diagnostics.StackTrace(true);
	    tracePart2 = null;
d136 16
a151 13
		    int skip1 = 0;
		    if(cleanStackTrace && t instanceof NullPointerException && tracePart1.get_FrameCount() > 0)
		    {
			// HACK if a NullPointerException originated inside an instancehelper method,
			// we assume that the reference the method was called on was really the one that was null,
			// so we filter it.
			if(tracePart1.GetFrame(0).GetMethod().get_Name().startsWith("instancehelper_") &&
			    !GetMethodName(tracePart1.GetFrame(0).GetMethod()).startsWith("instancehelper_"))
			{
			    skip1 = 1;
			}
		    }
		    Append(stackTrace, tracePart1, skip1);
d166 1
a166 1
                                    mb.get_Name().equals("fillInStackTrace"))
d168 21
a188 1
                                    skip++;
d191 7
a197 1
			    if(tracePart1.get_FrameCount() > 0 &&
d248 1
d282 12
a293 10
    private static native boolean IsHideFromJava(cli.System.Reflection.MethodBase mb);
    private static native cli.System.Exception getInnerException(Throwable t);
    private static native String getMessageFromCliException(Throwable t);
    private static native boolean IsNative(cli.System.Reflection.MethodBase mb);
    private static native String GetMethodName(cli.System.Reflection.MethodBase mb);
    private static native String getClassNameFromType(cli.System.Type type);
    private static native int GetLineNumber(cli.System.Diagnostics.StackFrame frame);
    private static native String GetFileName(cli.System.Diagnostics.StackFrame frame);
    private static native void initThrowable(Object throwable, Object detailMessage, Object cause);
    private static native Throwable MapExceptionImpl(Throwable t);
d379 7
d389 1
a389 1
	    eih = new ExceptionInfoHelper(x);
d440 1
a440 1
	    ei = new ExceptionInfoHelper(x);
d493 1
a493 1
	    eih = new ExceptionInfoHelper(x);
d496 1
a496 4
	else
	{
	    eih.ResetStackTrace();
	}
d510 1
a510 10
    static Throwable MapExceptionFast(Throwable t)
    {
	if(exceptions.containsKey(t))
	{
	    return t;
	}
	return MapException(t, System_Exception);
    }

    static Throwable MapException(Throwable t, cli.System.Type handler)
d512 93
a604 16
	//cli.System.Console.WriteLine("MapException: {0}, {1}", t, handler);
	//Console.WriteLine(new StackTrace(t));
	Throwable org = t;

	t = MapExceptionImpl(t);

	if(!exceptions.containsKey(t))
	{
	    exceptions.put(t, new ExceptionInfoHelper(org));
	    Throwable inner = getInnerException(org);
	    if(inner != null && !exceptions.containsKey(inner))
	    {
		exceptions.put(inner, new ExceptionInfoHelper(inner));
	    }
	}
	return handler.IsInstanceOfType(t) ? t : null;
@


1.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2003, 2004 Jeroen Frijters
d30 1
a30 1
public final class ExceptionHelper
d126 9
d179 3
a181 1
		if(cleanStackTrace &&
d183 3
a185 3
		    || m.get_DeclaringType().get_FullName().startsWith("java.lang.ExceptionHelper")
		    || m.get_DeclaringType().get_FullName().equals("System.RuntimeMethodHandle")
                    || m.get_DeclaringType().get_FullName().equals("java.lang.LibraryVMInterfaceImpl")
a190 1
		String methodName = GetMethodName(frame.GetMethod());
a213 1
		String className = getClassNameFromType(frame.GetMethod().get_DeclaringType());
d230 1
a230 1
    public static void printStackTrace(Throwable x)
d235 1
a235 1
    public static void printStackTrace(Throwable x, java.io.PrintStream printStream)
d240 1
a240 1
    public static void printStackTrace(Throwable x, java.io.PrintWriter printWriter)
d304 1
a304 1
    public static Throwable initCause(Throwable x, Throwable cause)
d324 1
a324 1
    public static Throwable getCause(Throwable x)
d338 1
a338 1
    public static StackTraceElement[] getStackTrace(Throwable x)
d352 1
a352 1
    public static void setStackTrace(Throwable x, StackTraceElement[] stackTrace)
d374 1
a374 1
    public static String get_NullString()
d379 1
a379 1
    public static String FilterMessage(String message)
d388 1
a388 1
    public static String GetMessageFromCause(Throwable cause)
d397 1
a397 1
    public static String getMessage(Throwable x)
d407 1
a407 1
    public static String getLocalizedMessage(Throwable x)
d412 1
a412 1
    public static Throwable fillInStackTrace(Throwable x)
d431 1
a431 1
    public static String toString(Throwable x)
d441 1
a441 1
    public static Throwable MapExceptionFast(Throwable t)
d450 1
a450 1
    public static Throwable MapException(Throwable t, cli.System.Type handler)
@


1.12
log
@*** empty log message ***
@
text
@d28 1
d37 1
a37 2
    // We access Runtime.defaultProperties directly, to prevent problems should an exception occur during library bootstrap
    private static final boolean cleanStackTrace = Runtime.defaultProperties.getProperty("ikvm.cleanstacktrace", "1").equals("1");
@


1.11
log
@*** empty log message ***
@
text
@d174 1
@


1.10
log
@*** empty log message ***
@
text
@d93 1
a93 1
		    !mb.get_IsFamilyOrAssembly() && !mb.get_IsPublic();
@


1.9
log
@*** empty log message ***
@
text
@d36 2
a37 1
    private static final boolean cleanStackTrace = System.getProperty("ikvm.cleanstacktrace", "1").equals("1");
@


1.8
log
@*** empty log message ***
@
text
@d103 1
a103 1
		    if(t instanceof NullPointerException && tracePart1.get_FrameCount() > 0)
d118 1
a118 2
			while(tracePart2.get_FrameCount() > skip && 
			    tracePart2.GetFrame(skip).GetMethod().get_DeclaringType().get_FullName().startsWith("java.lang.ExceptionHelper"))
d120 11
a130 7
			    skip++;
			}
			if(tracePart1.get_FrameCount() > 0 &&
			    tracePart2.get_FrameCount() > skip &&
			    tracePart1.GetFrame(tracePart1.get_FrameCount() - 1).GetMethod() == tracePart2.GetFrame(skip).GetMethod())
			{
			    skip++;
d134 1
a134 1
		    if(stackTrace.get_Count() > 0)
@


1.7
log
@*** empty log message ***
@
text
@d37 1
a37 1
    private static cli.System.Type System_Reflection_MethodInfo = cli.System.Type.GetType("System.Reflection.MethodInfo, mscorlib");
d52 1
a52 1
	    cause = ((cli.System.Exception)x).get_InnerException();
d95 1
a95 1
	StackTraceElement[] get_StackTrace()
d97 1
a97 1
	    if(stackTrace == null)
d99 1
a99 3
		stackTrace = new cli.System.Collections.ArrayList();
		Append(stackTrace, tracePart1);
		if(tracePart2 != null)
d101 15
a115 8
		    Append(stackTrace, tracePart2);
		}
		tracePart1 = null;
		tracePart2 = null;
		if(cleanStackTrace)
		{
		    int chop = 0;
		    for(int i = stackTrace.get_Count() - 1; i >= 0; i--)
d117 9
a125 2
			StackTraceElement ste = (StackTraceElement)stackTrace.get_Item(i);
			if(ste.getClassName().equals("System.Reflection.MethodBase"))
d127 1
a127 2
			    // skip method invocation by reflection, if it is at the top of the stack
			    chop++;
d129 6
a134 1
			else
d136 1
a136 1
			    break;
d139 2
a140 1
		    stackTrace.RemoveRange(stackTrace.get_Count() - chop, chop);
d155 1
a155 1
	public static void Append(cli.System.Collections.ArrayList stackTrace, cli.System.Diagnostics.StackTrace st)
d157 1
a157 1
	    if(st.get_FrameCount() > 0)
d159 19
a177 2
		int baseSize = stackTrace.get_Count();
		for(int i = 0; i < st.get_FrameCount(); i++)
d179 6
a184 4
		    cli.System.Diagnostics.StackFrame frame = st.GetFrame(i);
		    cli.System.Reflection.MethodBase m = frame.GetMethod();
		    // TODO I may need more safety checks like these
		    if(m == null || m.get_DeclaringType() == null || m.get_ReflectedType() == null)
d186 1
a186 1
			continue;
d188 1
a188 3
		    if(cleanStackTrace &&
			(m.get_DeclaringType().IsSubclassOf(System_Reflection_MethodInfo)
			|| IsPrivateScope(m))) // NOTE we assume that privatescope methods are always stubs that we should exclude
d190 3
a192 1
			continue;
a193 30
		    String methodName = frame.GetMethod().get_Name();
		    if(methodName.equals(".ctor"))
		    {
			methodName = "<init>";
		    }
		    else if(methodName.equals(".cctor"))
		    {
			methodName = "<clinit>";
		    }
		    int lineNumber = frame.GetFileLineNumber();
		    if(lineNumber == 0)
		    {
			lineNumber = -1;
		    }
		    String fileName = frame.GetFileName();
		    if(fileName != null)
		    {
			try
			{
			    fileName = new cli.System.IO.FileInfo(fileName).get_Name();
			}
			catch(Throwable x)
			{
			    // Mono returns "<unknown>" for frame.GetFileName() and the FileInfo constructor
			    // doesn't like that
			    fileName = null;
			}
		    }
		    String className = getClassNameFromType(frame.GetMethod().get_ReflectedType());
		    stackTrace.Add(new StackTraceElement(fileName, lineNumber, className, methodName, IsNative(m)));
d195 6
d205 3
d209 1
d211 4
d319 1
a319 1
	    return ((cli.System.Exception)x).get_InnerException();
d335 1
a335 1
	return ei.get_StackTrace();
d385 1
a385 1
	String message = ((cli.System.Exception)x).get_Message();
a435 2
    private static native Throwable MapExceptionImpl(Throwable t);

d447 1
a447 1
	    Throwable inner = ((cli.System.Exception)org).get_InnerException();
d473 1
a473 1
	    cause = ((cli.System.Exception)t).get_InnerException();
a498 2

    private static native void initThrowable(Object throwable, Object detailMessage, Object cause);
@


1.6
log
@*** empty log message ***
@
text
@d420 1
a420 1
	//Console.WriteLine("MapException: {0}, {1}", t, handler);
@


1.5
log
@*** empty log message ***
@
text
@d459 1
a459 5
	    // TODO we need to use getCauseForSerialization, but Classpath 0.09 has a bug that
	    // causes infinite recursion if we try to save a reference to this here (which
	    // happens if cause was uninitialized [it gets set to 'this' to signal that])
	    cause = eih.get_Cause();
	    //cause = eih.getCauseForSerialization(t);
d478 2
a479 1
	setStackTrace(t, (StackTraceElement[])fields.get("stackTrace", null));
@


1.4
log
@*** empty log message ***
@
text
@d26 3
d59 5
d437 49
@


1.3
log
@*** empty log message ***
@
text
@d39 1
a39 1
	private static final Throwable CAUSE_NOT_SET = cli.System.Exception.__new();
d49 1
a49 1
	    cause = cli.System.Exception.get_InnerException(x);
d291 1
a291 1
	    return cli.System.Exception.get_InnerException(x);
d357 1
a357 1
	String message = cli.System.Exception.get_Message(x);
d421 1
a421 1
	    Throwable inner = cli.System.Exception.get_InnerException(org);
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
  Copyright (C) 2003 Jeroen Frijters
@


1.1
log
@*** empty log message ***
@
text
@d34 2
d145 1
a145 1
			(m.get_DeclaringType().IsSubclassOf(typeof(cli.System.Reflection.MethodInfo.class))
d405 1
a405 1
	return MapException(t, typeof(Throwable.class));
a417 81
//	cli.System.Type type = cli.System.Object.GetType(t);
//	// TODO don't remap if the exception already has associated ExceptionInfoHelper object (this means
//	// that the .NET exception was thrown from Java code, explicitly).
//	if(type == typeof(cli.System.NullReferenceException.class))
//	{
//	    t = new NullPointerException();
//	}
//	// HACK many of the String and Object methods throw ArgumentNullException where Java throws an NPE
//	else if(type == typeof(cli.System.ArgumentNullException.class))
//	{
//	    t = new NullPointerException();
//	}
//	else if(type == typeof(cli.System.IndexOutOfRangeException.class))
//	{
//	    t = new ArrayIndexOutOfBoundsException();
//	}
//	    // HACK for String methods, we remap ArgumentOutOfRangeException to StringIndexOutOfBoundsException
//	else if(type == typeof(cli.System.ArgumentOutOfRangeException.class))
//	{
//	    t = new StringIndexOutOfBoundsException();
//	}
//	else if(type == typeof(cli.System.InvalidCastException.class))
//	{
//	    t = new ClassCastException();
//	}
//	else if(type == typeof(cli.System.TypeInitializationException.class))
//	{
//	    t = MapExceptionFast(cli.System.Exception.get_InnerException(t));
//	    if(!(t instanceof Error))
//	    {
//		t = new ExceptionInInitializerError(t);
//	    }
//	}
//	else if(type == typeof(cli.System.Threading.SynchronizationLockException.class))
//	{
//	    t = new IllegalMonitorStateException();
//	}
//	else if(type == typeof(cli.System.Threading.ThreadInterruptedException.class))
//	{
//	    t = new InterruptedException();
//	}
//	else if(type == typeof(cli.System.OutOfMemoryException.class))
//	{
//	    t = new OutOfMemoryError();
//	}
//	else if(type == typeof(cli.System.DivideByZeroException.class))
//	{
//	    t = new ArithmeticException("/ by zero");
//	}
//	else if(type == typeof(cli.System.ArrayTypeMismatchException.class))
//	{
//	    t = new ArrayStoreException();
//	}
//	else if(type == typeof(cli.System.StackOverflowException.class))
//	{
//	    t = new StackOverflowError();
//	}
//	else if(type == typeof(cli.System.Security.VerificationException.class))
//	{
//	    t = new VerifyError();
//	}
//	else if(type == typeof(cli.System.Threading.ThreadAbortException.class))
//	{
//	    cli.System.Threading.ThreadAbortException abort = (cli.System.Threading.ThreadAbortException)t;
//	    if(abort.get_ExceptionState() instanceof Throwable)
//	    {
//		t = (Throwable)abort.get_ExceptionState();
//	    }
//	    else
//	    {
//		t = new ThreadDeath();
//	    }
//	    cli.System.Threading.Thread.ResetAbort();
//	}
//	else if(type == typeof(cli.System.OverflowException.class))
//	{
//	    // TODO make sure the originating method was from an IKVM.NET generated assembly, because if it was
//	    // generated by non-Java code, this remapping is obviously bogus.
//	    t = new NegativeArraySizeException();
//	}

a428 2

    private static native cli.System.Type typeof(Class c);
@

