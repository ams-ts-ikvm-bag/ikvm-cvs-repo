head	1.23;
access;
symbols
	v0_36_0_14:1.22
	v0_36_0_13:1.22
	v0_36_0_9:1.22
	v0_36_0_7:1.22
	v0_36_0_5:1.22
	v0_36_0_4:1.22
	v0_36_0_3:1.22
	v0_36_0_2:1.22
	v0_36_0_1:1.22
	v0_36_0_0:1.22
	v0_36:1.22.0.4
	v0_34_0_3:1.22
	v0_34_0_2:1.22
	v0_34_0_1:1.22
	v0_34_0_0:1.22
	v0_34:1.22.0.2
	v0_32:1.21.0.4
	v0_32_0_0:1.21
	v0_30:1.21.0.2
	v0_28_0_0:1.21
	v0_26_0_1:1.15
	v0_26_0_0:1.15
	v0_24_0_1:1.14
	v0_24_0_0:1.14
	v0_22_0_0:1.14
	v0_20_0_0:1.14
	v0_18_0_0:1.14
	v0_16_0_0:1.14
	v0_14_0_1:1.13
	v0_14_0_0:1.13
	v0_12_0_0:1.11
	v0_10_0_1:1.9
	v0_10_0_0:1.9
	v0_8_0_0:1.5
	initial:1.1.1.1
	ikvm:1.1.1;
locks; strict;
comment	@# @;


1.23
date	2008.08.06.12.51.20;	author jfrijters;	state dead;
branches;
next	1.22;

1.22
date	2006.12.11.13.13.27;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.21.12.36.23;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.17.08.33.49;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.05.11.04.44;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.05.08.19.00;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.27.16.21.32;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.27.07.59.35;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.06.10.58.55;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.20.13.33.16;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.23.09.33.39;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.21.13.33.15;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.11.14.47.04;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.02.15.12.02;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.21.10.26.52;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.29.09.48.05;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.25.09.38.07;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.14.10.36.39;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.02.09.46.26;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.17.14.04.27;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.18.16.01.05;	author jfrijters;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.12.18.16.01.05;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Removed files that are no longer needed no that GNU Classpath support has been dropped.
@
text
@/* java.lang.reflect.Field - reflection of Java fields
   Copyright (C) 1998, 2001, 2005 Free Software Foundation, Inc.

This file is part of GNU Classpath.

GNU Classpath is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
 
GNU Classpath is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Classpath; see the file COPYING.  If not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301 USA.

Linking this library statically or dynamically with other modules is
making a combined work based on this library.  Thus, the terms and
conditions of the GNU General Public License cover the whole
combination.

As a special exception, the copyright holders of this library give you
permission to link this library with independent modules to produce an
executable, regardless of the license terms of these independent
modules, and to copy and distribute the resulting executable under
terms of your choice, provided that you also meet, for each linked
independent module, the terms and conditions of the license of that
module.  An independent module is a module which is not derived from
or based on this library.  If you modify this library, you may extend
this exception to your version of the library, but you are not
obligated to do so.  If you do not wish to do so, delete this
exception statement from your version. */


package java.lang.reflect;

import java.lang.annotation.Annotation;
import gnu.java.lang.ClassHelper;
import gnu.classpath.VMStackWalker;
import gnu.java.lang.reflect.FieldSignatureParser;
import gnu.java.lang.reflect.VMField;

/**
 * The Field class represents a member variable of a class. It also allows
 * dynamic access to a member, via reflection. This works for both
 * static and instance fields. Operations on Field objects know how to
 * do widening conversions, but throw {@@link IllegalArgumentException} if
 * a narrowing conversion would be necessary. You can query for information
 * on this Field regardless of location, but get and set access may be limited
 * by Java language access controls. If you can't do it in the compiler, you
 * can't normally do it here either.<p>
 *
 * <B>Note:</B> This class returns and accepts types as Classes, even
 * primitive types; there are Class types defined that represent each
 * different primitive type.  They are <code>java.lang.Boolean.TYPE,
 * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,
 * byte.class</code>, etc.  These are not to be confused with the
 * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are
 * real classes.<p>
 *
 * Also note that this is not a serializable class.  It is entirely feasible
 * to make it serializable using the Externalizable interface, but this is
 * on Sun, not me.
 *
 * @@author John Keiser
 * @@author Eric Blake <ebb9@@email.byu.edu>
 * @@author Jeroen Frijters
 * @@see Member
 * @@see Class
 * @@see Class#getField(String)
 * @@see Class#getDeclaredField(String)
 * @@see Class#getFields()
 * @@see Class#getDeclaredFields()
 * @@since 1.1
 * @@status updated to 1.4
 */
public final class Field
    extends AccessibleObject implements Member
{
    private static final int FIELD_MODIFIERS
        = Modifier.FINAL | Modifier.PRIVATE | Modifier.PROTECTED
        | Modifier.PUBLIC | Modifier.STATIC | Modifier.TRANSIENT
        | Modifier.VOLATILE;
    // package accessible to allow VM to access it
    @@ikvm.lang.Internal
    public VMField impl;

	/**
	 * This class is uninstantiable except natively.
	 */
	Field(VMField impl)
	{
            this.impl = impl;
	}

	/**
	 * Gets the class that declared this field, or the class where this field
	 * is a non-inherited member.
	 * @@return the class that declared this member
	 */
	public Class<?> getDeclaringClass()
	{
	    return impl.getDeclaringClass();
	}

	/**
	 * Gets the name of this field.
	 * @@return the name of this field
	 */
	public String getName()
	{
	    return impl.getName();
	}

    /**
     * Return the raw modifiers for this field.
     * @@return the field's modifiers
     */
    private int getModifiersInternal()
    {
        return impl.getModifiers();
    }

        /**
	 * Gets the modifiers this field uses.  Use the <code>Modifier</code>
	 * class to interpret the values.  A field can only have a subset of the
	 * following modifiers: public, private, protected, static, final,
	 * transient, and volatile.
	 *
	 * @@return an integer representing the modifiers to this Member
	 * @@see Modifier
	 */
	public int getModifiers()
	{
            return getModifiersInternal() & FIELD_MODIFIERS;
        }

        /**
         * Return true if this field is synthetic, false otherwise.
         * @@since 1.5
         */
        public boolean isSynthetic()
        {
            return (getModifiersInternal() & Modifier.SYNTHETIC) != 0;
        }

        /**
         * Return true if this field represents an enum constant,
         * false otherwise.
         * @@since 1.5
         */
        public boolean isEnumConstant()
        {
            return (getModifiersInternal() & Modifier.ENUM) != 0;
	}

	/**
	 * Gets the type of this field.
	 * @@return the type of this field
	 */
	public Class<?> getType()
	{
            return impl.getType();
	}

	/**
	 * Compare two objects to see if they are semantically equivalent.
	 * Two Fields are semantically equivalent if they have the same declaring
         * class, name, and type. Since you can't creat a Field except through
         * the VM, this is just the == relation.
	 *
	 * @@param o the object to compare to
	 * @@return <code>true</code> if they are equal; <code>false</code> if not
	 */
	public boolean equals(Object o)
	{
	    if(!(o instanceof Field))
		return false;

            Field that = (Field)o; 
            if (this.getDeclaringClass() != that.getDeclaringClass())
		return false;

            if (!this.getName().equals(that.getName()))
                return false;

            if (this.getType() != that.getType())
                return false;

            return true;
	}

	/**
	 * Get the hash code for the Field. The Field hash code is the hash code
	 * of its name XOR'd with the hash code of its class name.
	 *
	 * @@return the hash code for the object.
	 */
	public int hashCode()
	{
		return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
	}

	/**
	 * Get a String representation of the Field. A Field's String
	 * representation is "&lt;modifiers&gt; &lt;type&gt;
	 * &lt;class&gt;.&lt;fieldname&gt;".<br> Example:
	 * <code>public transient boolean gnu.parse.Parser.parseComplete</code>
	 *
	 * @@return the String representation of the Field
	 */
	public String toString()
	{
            // 64 is a reasonable buffer initial size for field
            StringBuffer sb = new StringBuffer(64);
            Modifier.toString(getModifiers(), sb);
            if (sb.length() > 0)
                sb.append(' ');
            sb.append(ClassHelper.getUserName(getType())).append(' ');
            sb.append(getDeclaringClass().getName()).append('.');
	    sb.append(getName());
	    return sb.toString();
	}

        public String toGenericString()
        {
            StringBuilder sb = new StringBuilder(64);
            Modifier.toString(getModifiers(), sb);
            if (sb.length() > 0)
                sb.append(' ');
            sb.append(getGenericType()).append(' ');
            sb.append(getDeclaringClass().getName()).append('.');
            sb.append(getName());
            return sb.toString();
        }

	/**
	 * Get the value of this Field.  If it is primitive, it will be wrapped
	 * in the appropriate wrapper type (boolean = java.lang.Boolean).<p>
	 *
	 * If the field is static, <code>o</code> will be ignored. Otherwise, if
	 * <code>o</code> is null, you get a <code>NullPointerException</code>,
	 * and if it is incompatible with the declaring class of the field, you
	 * get an <code>IllegalArgumentException</code>.<p>
	 *
	 * Next, if this Field enforces access control, your runtime context is
	 * evaluated, and you may have an <code>IllegalAccessException</code> if
	 * you could not access this field in similar compiled code. If the field
	 * is static, and its class is uninitialized, you trigger class
	 * initialization, which may end in a
	 * <code>ExceptionInInitializerError</code>.<p>
	 *
	 * Finally, the field is accessed, and primitives are wrapped (but not
	 * necessarily in new objects). This method accesses the field of the
	 * declaring class, even if the instance passed in belongs to a subclass
	 * which declares another field to hide this one.
	 *
	 * @@param o the object to get the value of this Field from
	 * @@return the value of the Field
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if <code>o</code> is not an instance of
	 *         the class or interface declaring this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #getBoolean(Object)
	 * @@see #getByte(Object)
	 * @@see #getChar(Object)
	 * @@see #getShort(Object)
	 * @@see #getInt(Object)
	 * @@see #getLong(Object)
	 * @@see #getFloat(Object)
	 * @@see #getDouble(Object)
	 */
	public Object get(Object o)
		throws IllegalAccessException
	{
	    if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            return impl.get(o);
	}

	/**
	 * Get the value of this boolean Field. If the field is static,
	 * <code>o</code> will be ignored.
	 *
	 * @@param o the object to get the value of this Field from
	 * @@return the value of the Field
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a boolean field of
	 *         <code>o</code>, or if <code>o</code> is not an instance of the
	 *         declaring class of this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #get(Object)
	 */
	public boolean getBoolean(Object o)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            return impl.getBoolean(o);
	}

	/**
	 * Get the value of this byte Field. If the field is static,
	 * <code>o</code> will be ignored.
	 *
	 * @@param o the object to get the value of this Field from
	 * @@return the value of the Field
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a byte field of
	 *         <code>o</code>, or if <code>o</code> is not an instance of the
	 *         declaring class of this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #get(Object)
	 */
	public byte getByte(Object o)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            return impl.getByte(o);
	}

	/**
	 * Get the value of this Field as a char. If the field is static,
	 * <code>o</code> will be ignored.
	 *
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a char field of
	 *         <code>o</code>, or if <code>o</code> is not an instance
	 *         of the declaring class of this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #get(Object)
	 */
	public char getChar(Object o)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            return impl.getChar(o);
	}

	/**
	 * Get the value of this Field as a short. If the field is static,
	 * <code>o</code> will be ignored.
	 *
	 * @@param o the object to get the value of this Field from
	 * @@return the value of the Field
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a byte or short
	 *         field of <code>o</code>, or if <code>o</code> is not an instance
	 *         of the declaring class of this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #get(Object)
	 */
	public short getShort(Object o)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            return impl.getShort(o);
	}

	/**
	 * Get the value of this Field as an int. If the field is static,
	 * <code>o</code> will be ignored.
	 *
	 * @@param o the object to get the value of this Field from
	 * @@return the value of the Field
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a byte, short, char, or
	 *         int field of <code>o</code>, or if <code>o</code> is not an
	 *         instance of the declaring class of this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #get(Object)
	 */
	public int getInt(Object o)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            return impl.getInt(o);
	}

	/**
	 * Get the value of this Field as a long. If the field is static,
	 * <code>o</code> will be ignored.
	 *
	 * @@param o the object to get the value of this Field from
	 * @@return the value of the Field
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a byte, short, char, int,
	 *         or long field of <code>o</code>, or if <code>o</code> is not an
	 *         instance of the declaring class of this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #get(Object)
	 */
	public long getLong(Object o)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            return impl.getLong(o);
	}

	/**
	 * Get the value of this Field as a float. If the field is static,
	 * <code>o</code> will be ignored.
	 *
	 * @@param o the object to get the value of this Field from
	 * @@return the value of the Field
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a byte, short, char, int,
	 *         long, or float field of <code>o</code>, or if <code>o</code> is
	 *         not an instance of the declaring class of this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #get(Object)
	 */
	public float getFloat(Object o)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            return impl.getFloat(o);
	}

	/**
	 * Get the value of this Field as a double. If the field is static,
	 * <code>o</code> will be ignored.
	 *
	 * @@param o the object to get the value of this Field from
	 * @@return the value of the Field
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a byte, short, char, int,
	 *         long, float, or double field of <code>o</code>, or if
	 *         <code>o</code> is not an instance of the declaring class of this
	 *         field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #get(Object)
	 */
	public double getDouble(Object o)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            return impl.getDouble(o);
	}

	/**
	 * Set the value of this Field.  If it is a primitive field, the value
	 * will be unwrapped from the passed object (boolean = java.lang.Boolean).<p>
	 *
	 * If the field is static, <code>o</code> will be ignored. Otherwise, if
	 * <code>o</code> is null, you get a <code>NullPointerException</code>,
	 * and if it is incompatible with the declaring class of the field, you
	 * get an <code>IllegalArgumentException</code>.<p>
	 *
	 * Next, if this Field enforces access control, your runtime context is
	 * evaluated, and you may have an <code>IllegalAccessException</code> if
	 * you could not access this field in similar compiled code. This also
	 * occurs whether or not there is access control if the field is final.
	 * If the field is primitive, and unwrapping your argument fails, you will
	 * get an <code>IllegalArgumentException</code>; likewise, this error
	 * happens if <code>value</code> cannot be cast to the correct object type.
	 * If the field is static, and its class is uninitialized, you trigger class
	 * initialization, which may end in a
	 * <code>ExceptionInInitializerError</code>.<p>
	 *
	 * Finally, the field is set with the widened value. This method accesses
	 * the field of the declaring class, even if the instance passed in belongs
	 * to a subclass which declares another field to hide this one.
	 *
	 * @@param o the object to set this Field on
	 * @@param value the value to set this Field to
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if <code>value</code> cannot be
	 *         converted by a widening conversion to the underlying type of
	 *         the Field, or if <code>o</code> is not an instance of the class
	 *         declaring this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #setBoolean(Object, boolean)
	 * @@see #setByte(Object, byte)
	 * @@see #setChar(Object, char)
	 * @@see #setShort(Object, short)
	 * @@see #setInt(Object, int)
	 * @@see #setLong(Object, long)
	 * @@see #setFloat(Object, float)
	 * @@see #setDouble(Object, double)
	 */
	public void set(Object o, Object value)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            impl.set(o, value, isAccessible());
	}

	/**
	 * Set this boolean Field. If the field is static, <code>o</code> will be
	 * ignored.
	 *
	 * @@param o the object to set this Field on
	 * @@param value the value to set this Field to
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a boolean field, or if
	 *         <code>o</code> is not an instance of the class declaring this
	 *         field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #set(Object, Object)
	 */
	public void setBoolean(Object o, boolean value)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            impl.setBoolean(o, value, isAccessible());
	}

	/**
	 * Set this byte Field. If the field is static, <code>o</code> will be
	 * ignored.
	 *
	 * @@param o the object to set this Field on
	 * @@param value the value to set this Field to
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a byte, short, int, long,
	 *         float, or double field, or if <code>o</code> is not an instance
	 *         of the class declaring this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #set(Object, Object)
	 */
	public void setByte(Object o, byte value)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            impl.setByte(o, value, isAccessible());
	}

	/**
	 * Set this char Field. If the field is static, <code>o</code> will be
	 * ignored.
	 *
	 * @@param o the object to set this Field on
	 * @@param value the value to set this Field to
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a char, int, long,
	 *         float, or double field, or if <code>o</code> is not an instance
	 *         of the class declaring this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #set(Object, Object)
	 */
	public void setChar(Object o, char value)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            impl.setChar(o, value, isAccessible());
	}

	/**
	 * Set this short Field. If the field is static, <code>o</code> will be
	 * ignored.
	 *
	 * @@param o the object to set this Field on
	 * @@param value the value to set this Field to
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a short, int, long,
	 *         float, or double field, or if <code>o</code> is not an instance
	 *         of the class declaring this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #set(Object, Object)
	 */
	public void setShort(Object o, short value)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            impl.setShort(o, value, isAccessible());
	}

	/**
	 * Set this int Field. If the field is static, <code>o</code> will be
	 * ignored.
	 *
	 * @@param o the object to set this Field on
	 * @@param value the value to set this Field to
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not an int, long, float, or
	 *         double field, or if <code>o</code> is not an instance of the
	 *         class declaring this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #set(Object, Object)
	 */
	public void setInt(Object o, int value)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            impl.setInt(o, value, isAccessible());
	}

	/**
	 * Set this long Field. If the field is static, <code>o</code> will be
	 * ignored.
	 *
	 * @@param o the object to set this Field on
	 * @@param value the value to set this Field to
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a long, float, or double
	 *         field, or if <code>o</code> is not an instance of the class
	 *         declaring this field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #set(Object, Object)
	 */
	public void setLong(Object o, long value)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            impl.setLong(o, value, isAccessible());
	}

	/**
	 * Set this float Field. If the field is static, <code>o</code> will be
	 * ignored.
	 *
	 * @@param o the object to set this Field on
	 * @@param value the value to set this Field to
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a float or long field, or
	 *         if <code>o</code> is not an instance of the class declaring this
	 *         field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #set(Object, Object)
	 */
	public void setFloat(Object o, float value)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            impl.setFloat(o, value, isAccessible());
	}

	/**
	 * Set this double Field. If the field is static, <code>o</code> will be
	 * ignored.
	 *
	 * @@param o the object to set this Field on
	 * @@param value the value to set this Field to
	 * @@throws IllegalAccessException if you could not normally access this field
	 *         (i.e. it is not public)
	 * @@throws IllegalArgumentException if this is not a double field, or if
	 *         <code>o</code> is not an instance of the class declaring this
	 *         field
	 * @@throws NullPointerException if <code>o</code> is null and this field
	 *         requires an instance
	 * @@throws ExceptionInInitializerError if accessing a static field triggered
	 *         class initialization, which then failed
	 * @@see #set(Object, Object)
	 */
	public void setDouble(Object o, double value)
		throws IllegalAccessException
	{
            if(impl.needsAccessCheck(isAccessible()))
                VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
            impl.setDouble(o, value, isAccessible());
	}

        public Type getGenericType()
        {
            String signature = impl.getSignature();
            if (signature == null)
                return getType();
            FieldSignatureParser p = new FieldSignatureParser(getDeclaringClass(), signature);
            return p.getFieldType();
        }

        public <T extends Annotation> T getAnnotation(Class<T> annotationClass)
        {
            for (Annotation annotation : getDeclaredAnnotations())
                if (annotation.annotationType() == annotationClass)
                    return (T) annotation;
            return null;
        }

        public Annotation[] getDeclaredAnnotations()
        {
            return Method.toAnnotationArray(VMFieldImpl.GetDeclaredAnnotations(impl.fieldCookie));
        }
}
@


1.22
log
@*** empty log message ***
@
text
@@


1.21
log
@*** empty log message ***
@
text
@d105 1
a105 1
	public Class getDeclaringClass()
d119 9
a128 9
         * Return the raw modifiers for this field.
         * @@return the field's modifiers
         */
        private int getModifiersInternal()
        {
            return impl.getModifiers();
        }

	/**
d159 1
a159 1
        }
d161 1
a161 1
        /**
d165 1
a165 1
	public Class getType()
d182 1
a182 1
                return false;
d186 1
a186 1
                return false;
d195 1
a195 1
        }
d205 1
a205 1
            return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
d224 1
a224 1
	    sb.append(getDeclaringClass().getName()).append('.');
d231 1
a231 1
            StringBuffer sb = new StringBuffer(64);
d285 2
a286 2
		VMFieldImpl.checkAccess(impl.fieldCookie, o, VMStackWalker.getCallingClass());
	    return impl.get(o);
d750 1
a750 1
        public Annotation getAnnotation(Class annotationClass)
d754 1
a754 1
                    return annotation;
@


1.20
log
@*** empty log message ***
@
text
@d41 1
d229 12
d741 21
a761 8
    public Type getGenericType()
    {
        String signature = impl.getSignature();
        if (signature == null)
            return getType();
        FieldSignatureParser p = new FieldSignatureParser(getDeclaringClass(), signature);
        return p.getFieldType();
    }
@


1.19
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1998, 2001 Free Software Foundation, Inc.
@


1.18
log
@*** empty log message ***
@
text
@d43 1
d727 9
@


1.17
log
@*** empty log message ***
@
text
@d218 3
a220 1
            Modifier.toString(getModifiers(), sb).append(' ');
d271 1
a271 1
		impl.checkAccess(o, VMStackWalker.getCallingClass());
d296 1
a296 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d321 1
a321 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d344 1
a344 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d369 1
a369 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d394 1
a394 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d419 1
a419 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d444 1
a444 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d470 1
a470 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d523 1
a523 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d548 1
a548 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d573 1
a573 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d598 1
a598 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d623 1
a623 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d648 1
a648 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d673 1
a673 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d698 1
a698 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
d723 1
a723 1
                impl.checkAccess(o, VMStackWalker.getCallingClass());
@


1.16
log
@*** empty log message ***
@
text
@d87 2
a88 1
    VMField impl;
@


1.15
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1998, 2001, 2005 Free Software Foundation, Inc.
d18 2
a19 2
Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.
d41 1
d79 2
a80 1
public final class Field extends AccessibleObject implements Member
d82 4
d116 9
d136 21
a156 2
	    return impl.getModifiers();
	}
d158 1
a158 1
	/**
d170 2
a171 1
	 * class, name, and type.
d178 2
a179 2
		if(!(o instanceof Field))
			return false;
d181 3
a183 3
		Field f = (Field)o;
		if(!getName().equals(f.getName()))
			return false;
d185 2
a186 2
		if(getDeclaringClass() != f.getDeclaringClass())
			return false;
d188 2
a189 2
		if(getType() != f.getType())
			return false;
d191 2
a192 2
		return true;
	}
d202 1
a202 1
		return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
d215 7
a221 6
		StringBuffer sb = new StringBuffer();
		sb.append(Modifier.toString(getModifiers())).append(' ');
		sb.append(Constructor.getUserName(getType())).append(' ');
		sb.append(getDeclaringClass().getName()).append('.');
		sb.append(getName());
		return sb.toString();
@


1.14
log
@*** empty log message ***
@
text
@d182 1
a182 1
		sb.append(getType().getName()).append(' ');
@


1.13
log
@*** empty log message ***
@
text
@d181 1
a181 1
		Modifier.toString(getModifiers(), sb).append(' ');
@


1.12
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1998, 2001 Free Software Foundation, Inc.
a40 1
import cli.System.Diagnostics.StackFrame;
d42 1
a42 1
import ikvm.lang.CIL;
d68 1
d80 2
a81 575
	private Class declaringClass;
        // package accessible (actually "assembly") to allow map.xml implementation
        // of LibraryVMInterfaceImpl.getWrapperFromField() to access it.
	Object fieldCookie;
	private int modifiers;
        private boolean classIsPublic;
        private FieldImpl impl;

    private static native Object GetValue(Object fieldCookie, Object o);
    private static native void SetValue(Object fieldCookie, Object o, Object value, boolean accessible);

    abstract static class FieldImpl
    {
        private Object fieldCookie;

        FieldImpl(Object fieldCookie)
        {
            this.fieldCookie = fieldCookie;
        }

        final Object getImpl(Object obj)
        {
            return Field.GetValue(fieldCookie, obj);
        }

        final void setImpl(Object obj, Object val, boolean accessible)
        {
            Field.SetValue(fieldCookie, obj, val, accessible);
        }

        abstract Object get(Object obj);

        boolean getBoolean(Object obj)
        {
            throw new IllegalArgumentException();
        }
        byte getByte(Object obj)
        {
            throw new IllegalArgumentException();
        }
        char getChar(Object obj)
        {
            throw new IllegalArgumentException();
        }
        short getShort(Object obj)
        {
            throw new IllegalArgumentException();
        }
        int getInt(Object obj)
        {
            throw new IllegalArgumentException();
        }
        float getFloat(Object obj)
        {
            throw new IllegalArgumentException();
        }
        long getLong(Object obj)
        {
            throw new IllegalArgumentException();
        }
        double getDouble(Object obj)
        {
            throw new IllegalArgumentException();
        }

        abstract void set(Object obj, Object val, boolean accessible);

        void setBoolean(Object obj, boolean val, boolean accessible)
        {
            throw new IllegalArgumentException();
        }
        void setByte(Object obj, byte val, boolean accessible)
        {
            throw new IllegalArgumentException();
        }
        void setChar(Object obj, char val, boolean accessible)
        {
            throw new IllegalArgumentException();
        }
        void setShort(Object obj, short val, boolean accessible)
        {
            throw new IllegalArgumentException();
        }
        void setInt(Object obj, int val, boolean accessible)
        {
            throw new IllegalArgumentException();
        }
        void setFloat(Object obj, float val, boolean accessible)
        {
            throw new IllegalArgumentException();
        }
        void setLong(Object obj, long val, boolean accessible)
        {
            throw new IllegalArgumentException();
        }
        void setDouble(Object obj, double val, boolean accessible)
        {
            throw new IllegalArgumentException();
        }
    }

    final static class ObjectFieldImpl extends FieldImpl
    {
        ObjectFieldImpl(Object fieldCookie)
        {
            super(fieldCookie);
        }

        Object get(Object obj)
        {
            return getImpl(obj);
        }

        void set(Object obj, Object val, boolean accessible)
        {
            setImpl(obj, val, accessible);
        }
    }

    final static class BooleanFieldImpl extends FieldImpl
    {
        BooleanFieldImpl(Object fieldCookie)
        {
            super(fieldCookie);
        }

        Object get(Object obj)
        {
            return getBoolean(obj) ? Boolean.TRUE : Boolean.FALSE;
        }

        boolean getBoolean(Object obj)
        {
            return CIL.unbox_boolean(getImpl(obj));
        }

        void set(Object obj, Object val, boolean accessible)
        {
            if(! (val instanceof Boolean))
              throw new IllegalArgumentException();
            setBoolean(obj, ((Boolean)val).booleanValue(), accessible);
        }

        void setBoolean(Object obj, boolean val, boolean accessible)
        {
            setImpl(obj, CIL.box_boolean(val), accessible);
        }
    }

    final static class ByteFieldImpl extends FieldImpl
    {
        ByteFieldImpl(Object fieldCookie)
        {
            super(fieldCookie);
        }

        Object get(Object obj)
        {
            return new Byte(getByte(obj));
        }

        byte getByte(Object obj)
        {
            return CIL.unbox_byte(getImpl(obj));
        }

        short getShort(Object obj)
        {
            return getByte(obj);
        }

        int getInt(Object obj)
        {
            return getByte(obj);
        }

        float getFloat(Object obj)
        {
            return getByte(obj);
        }

        long getLong(Object obj)
        {
            return getByte(obj);
        }

        double getDouble(Object obj)
        {
            return getByte(obj);
        }

        void set(Object obj, Object val, boolean accessible)
        {
            if(! (val instanceof Byte))
              throw new IllegalArgumentException();
            setByte(obj, ((Byte)val).byteValue(), accessible);
        }

        void setByte(Object obj, byte val, boolean accessible)
        {
            setImpl(obj, CIL.box_byte(val), accessible);
        }
    }

    final static class CharFieldImpl extends FieldImpl
    {
        CharFieldImpl(Object fieldCookie)
        {
            super(fieldCookie);
        }

        Object get(Object obj)
        {
            return new Character(getChar(obj));
        }

        char getChar(Object obj)
        {
            return CIL.unbox_char(getImpl(obj));
        }

        int getInt(Object obj)
        {
            return getChar(obj);
        }

        float getFloat(Object obj)
        {
            return getChar(obj);
        }

        long getLong(Object obj)
        {
            return getChar(obj);
        }

        double getDouble(Object obj)
        {
            return getChar(obj);
        }

        void set(Object obj, Object val, boolean accessible)
        {
            if(! (val instanceof Character))
              throw new IllegalArgumentException();
            setChar(obj, ((Character)val).charValue(), accessible);
        }

        void setChar(Object obj, char val, boolean accessible)
        {
            setImpl(obj, CIL.box_char(val), accessible);
        }
    }

    final static class ShortFieldImpl extends FieldImpl
    {
        ShortFieldImpl(Object fieldCookie)
        {
            super(fieldCookie);
        }

        Object get(Object obj)
        {
            return new Short(getShort(obj));
        }

        short getShort(Object obj)
        {
            return CIL.unbox_short(getImpl(obj));
        }

        int getInt(Object obj)
        {
            return getShort(obj);
        }

        float getFloat(Object obj)
        {
            return getShort(obj);
        }

        long getLong(Object obj)
        {
            return getShort(obj);
        }

        double getDouble(Object obj)
        {
            return getShort(obj);
        }

        void set(Object obj, Object val, boolean accessible)
        {
            if(! (val instanceof Short
                 || val instanceof Byte))
              throw new IllegalArgumentException();
            setShort(obj, ((Number)val).shortValue(), accessible);
        }

        void setShort(Object obj, short val, boolean accessible)
        {
            setImpl(obj, CIL.box_short(val), accessible);
        }

        void setByte(Object obj, byte val, boolean accessible)
        {
            setShort(obj, val, accessible);
        }
    }

    final static class IntFieldImpl extends FieldImpl
    {
        IntFieldImpl(Object fieldCookie)
        {
            super(fieldCookie);
        }

        Object get(Object obj)
        {
            return new Integer(getInt(obj));
        }

        int getInt(Object obj)
        {
            return CIL.unbox_int(getImpl(obj));
        }

        float getFloat(Object obj)
        {
            return getInt(obj);
        }

        long getLong(Object obj)
        {
            return getInt(obj);
        }

        double getDouble(Object obj)
        {
            return getInt(obj);
        }

        void set(Object obj, Object val, boolean accessible)
        {
            if (val instanceof Integer
               || val instanceof Byte
               || val instanceof Short)
              setInt(obj, ((Number)val).intValue(), accessible);
            else if (val instanceof Character)
              setInt(obj, ((Character)val).charValue(), accessible);
            else
              throw new IllegalArgumentException();
        }

        void setInt(Object obj, int val, boolean accessible)
        {
            setImpl(obj, CIL.box_int(val), accessible);
        }

        void setByte(Object obj, byte val, boolean accessible)
        {
            setInt(obj, val, accessible);
        }

        void setChar(Object obj, char val, boolean accessible)
        {
            setInt(obj, val, accessible);
        }

        void setShort(Object obj, short val, boolean accessible)
        {
            setInt(obj, val, accessible);
        }
    }

    final static class FloatFieldImpl extends FieldImpl
    {
        FloatFieldImpl(Object fieldCookie)
        {
            super(fieldCookie);
        }

        Object get(Object obj)
        {
            return new Float(getFloat(obj));
        }

        float getFloat(Object obj)
        {
            return CIL.unbox_float(getImpl(obj));
        }

        double getDouble(Object obj)
        {
            return getFloat(obj);
        }

        void set(Object obj, Object val, boolean accessible)
        {
            if (val instanceof Float
               || val instanceof Byte
               || val instanceof Short
               || val instanceof Integer
               || val instanceof Long)
              setFloat(obj, ((Number)val).floatValue(), accessible);
            else if (val instanceof Character)
              setFloat(obj, ((Character)val).charValue(), accessible);
            else
              throw new IllegalArgumentException();
        }

        void setFloat(Object obj, float val, boolean accessible)
        {
            setImpl(obj, CIL.box_float(val), accessible);
        }

        void setByte(Object obj, byte val, boolean accessible)
        {
            setFloat(obj, val, accessible);
        }

        void setChar(Object obj, char val, boolean accessible)
        {
            setFloat(obj, val, accessible);
        }

        void setShort(Object obj, short val, boolean accessible)
        {
            setFloat(obj, val, accessible);
        }

        void setInt(Object obj, int val, boolean accessible)
        {
            setFloat(obj, val, accessible);
        }

        void setLong(Object obj, long val, boolean accessible)
        {
            setFloat(obj, val, accessible);
        }
    }

    final static class LongFieldImpl extends FieldImpl
    {
        LongFieldImpl(Object fieldCookie)
        {
            super(fieldCookie);
        }

        Object get(Object obj)
        {
            return new Long(getLong(obj));
        }

        long getLong(Object obj)
        {
            return CIL.unbox_long(getImpl(obj));
        }

        float getFloat(Object obj)
        {
            return getLong(obj);
        }

        double getDouble(Object obj)
        {
            return getLong(obj);
        }

        void set(Object obj, Object val, boolean accessible)
        {
            if (val instanceof Long
               || val instanceof Byte
               || val instanceof Short
               || val instanceof Integer)
              setLong(obj, ((Number)val).longValue(), accessible);
            else if (val instanceof Character)
              setLong(obj, ((Character)val).charValue(), accessible);
            else
              throw new IllegalArgumentException();
        }

        void setLong(Object obj, long val, boolean accessible)
        {
            setImpl(obj, CIL.box_long(val), accessible);
        }

        void setByte(Object obj, byte val, boolean accessible)
        {
            setLong(obj, val, accessible);
        }

        void setChar(Object obj, char val, boolean accessible)
        {
            setLong(obj, val, accessible);
        }

        void setShort(Object obj, short val, boolean accessible)
        {
            setLong(obj, val, accessible);
        }

        void setInt(Object obj, int val, boolean accessible)
        {
            setLong(obj, val, accessible);
        }
    }

    final static class DoubleFieldImpl extends FieldImpl
    {
        DoubleFieldImpl(Object fieldCookie)
        {
            super(fieldCookie);
        }

        Object get(Object obj)
        {
            return new Double(getDouble(obj));
        }

        double getDouble(Object obj)
        {
            return CIL.unbox_double(getImpl(obj));
        }

        void set(Object obj, Object val, boolean accessible)
        {
            if (val instanceof Double
                || val instanceof Byte
                || val instanceof Short
                || val instanceof Integer
                || val instanceof Float
                || val instanceof Long)
              setDouble(obj, ((Number)val).doubleValue(), accessible);
            else if (val instanceof Character)
              setDouble(obj, ((Character)val).charValue(), accessible);
            else
              throw new IllegalArgumentException();
        }

        void setDouble(Object obj, double val, boolean accessible)
        {
            setImpl(obj, CIL.box_double(val), accessible);
        }

        void setByte(Object obj, byte val, boolean accessible)
        {
            setDouble(obj, val, accessible);
        }

        void setChar(Object obj, char val, boolean accessible)
        {
            setDouble(obj, val, accessible);
        }

        void setShort(Object obj, short val, boolean accessible)
        {
            setDouble(obj, val, accessible);
        }

        void setInt(Object obj, int val, boolean accessible)
        {
            setDouble(obj, val, accessible);
        }

        void setFloat(Object obj, float val, boolean accessible)
        {
            setDouble(obj, val, accessible);
        }

        void setLong(Object obj, long val, boolean accessible)
        {
            setDouble(obj, val, accessible);
        }
    }
d86 1
a86 1
	Field(Class declaringClass, Object fieldCookie)
d88 1
a88 23
	    this.declaringClass = declaringClass;
	    this.fieldCookie = fieldCookie;
	    modifiers = GetModifiers(fieldCookie);
	    classIsPublic = (Method.GetRealModifiers(declaringClass) & Modifier.PUBLIC) != 0;
            Class type = getType();
            if (type == Boolean.TYPE)
              impl = new BooleanFieldImpl(fieldCookie);
            else if (type == Byte.TYPE)
              impl = new ByteFieldImpl(fieldCookie);
            else if (type == Character.TYPE)
              impl = new CharFieldImpl(fieldCookie);
            else if (type == Short.TYPE)
              impl = new ShortFieldImpl(fieldCookie);
            else if (type == Integer.TYPE)
              impl = new IntFieldImpl(fieldCookie);
            else if (type == Float.TYPE)
              impl = new FloatFieldImpl(fieldCookie);
            else if (type == Long.TYPE)
              impl = new LongFieldImpl(fieldCookie);
            else if (type == Double.TYPE)
              impl = new DoubleFieldImpl(fieldCookie);
            else
              impl = new ObjectFieldImpl(fieldCookie);
a89 1
        private static native int GetModifiers(Object fieldCookie);
d98 1
a98 1
		return declaringClass;
d107 1
a107 1
		return GetName(fieldCookie);
a108 2
	private static native String GetName(Object fieldCookie);

d121 1
a121 1
	    return modifiers;
d130 1
a130 1
		return (Class)GetFieldType(fieldCookie);
a131 1
	private static native Object GetFieldType(Object fieldCookie);
d150 1
a150 1
		if(declaringClass != f.declaringClass)
d231 2
a232 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d256 2
a257 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d281 2
a282 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d304 2
a305 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d329 2
a330 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d354 2
a355 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d379 2
a380 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d404 2
a405 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d430 2
a431 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d483 2
a484 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
a487 25
	static void checkAccess(int modifiers, Object o, Class declaringClass, Class caller) throws IllegalAccessException
	{
	    // when we're invoking a constructor, modifiers will not be static, but o will be null.
	    Class actualClass = Modifier.isStatic(modifiers) || o == null ? declaringClass : o.getClass();
	    boolean declaringClassIsPublic = (Method.GetRealModifiers(declaringClass) & Modifier.PUBLIC) != 0;
	    if((!Modifier.isPublic(modifiers) || !declaringClassIsPublic) && declaringClass != caller)
	    {
		// if the caller is a global method, the class returned will be null
		if(caller == null)
		{
		    throw new IllegalAccessException();
		}
		if(Modifier.isProtected(modifiers) && actualClass.isAssignableFrom(caller))
		{
		}
		else if(!isSamePackage(declaringClass, caller) || Modifier.isPrivate(modifiers))
		{
		    throw new IllegalAccessException("Class " + caller.getName() +
                         " can not access a member of class " + declaringClass.getName() +
                         " with modifiers \"" + Modifier.toString(modifiers & (Modifier.PRIVATE | Modifier.PROTECTED)) + "\"");
		}
	    }
	}
	private static native boolean isSamePackage(Class a, Class b);

d508 2
a509 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d533 2
a534 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d558 2
a559 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d583 2
a584 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d608 2
a609 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d633 2
a634 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d658 2
a659 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
d683 2
a684 4
	    if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
		checkAccess(modifiers, o, declaringClass, VMStackWalker.getCallingClass());
            if(o != null && !declaringClass.isInstance(o))
                throw new IllegalArgumentException();
@


1.11
log
@*** empty log message ***
@
text
@d43 1
d81 2
d86 569
d665 19
d832 3
a834 1
	    return GetValue(fieldCookie, o);
a835 1
	private static native Object GetValue(Object fieldCookie, Object o);
d859 3
a861 1
	    return ((Boolean)GetValue(fieldCookie, o)).booleanValue();
d886 3
a888 1
	    return ((Byte)GetValue(fieldCookie, o)).byteValue();
d911 3
a913 1
	    return ((Character)GetValue(fieldCookie, o)).charValue();
d938 3
a940 1
	    return ((Short)GetValue(fieldCookie, o)).shortValue();
d965 3
a967 1
	    return ((Integer)GetValue(fieldCookie, o)).intValue();
d992 3
a994 1
	    return ((Long)GetValue(fieldCookie, o)).longValue();
d1019 3
a1021 1
	    return ((Float)GetValue(fieldCookie, o)).floatValue();
d1047 3
a1049 1
	    return ((Double)GetValue(fieldCookie, o)).doubleValue();
d1102 3
a1104 1
	    SetValue(fieldCookie, o, value, isAccessible());
a1105 1
	private static native void SetValue(Object fieldCookie, Object o, Object value, boolean accessible);
d1154 3
a1156 1
	    SetValue(fieldCookie, o, new Boolean(value), isAccessible());
d1181 3
a1183 1
	    SetValue(fieldCookie, o, new Byte(value), isAccessible());
d1208 3
a1210 1
	    SetValue(fieldCookie, o, new Character(value), isAccessible());
d1235 3
a1237 1
	    SetValue(fieldCookie, o, new Short(value), isAccessible());
d1262 3
a1264 1
	    SetValue(fieldCookie, o, new Integer(value), isAccessible());
d1289 3
a1291 1
	    SetValue(fieldCookie, o, new Long(value), isAccessible());
d1316 3
a1318 1
	    SetValue(fieldCookie, o, new Float(value), isAccessible());
d1343 3
a1345 1
	    SetValue(fieldCookie, o, new Double(value), isAccessible());
@


1.10
log
@*** empty log message ***
@
text
@d494 1
a494 1
	    SetValue(fieldCookie, o, value);
d496 1
a496 1
	private static native void SetValue(Object fieldCookie, Object o, Object value);
d545 1
a545 1
	    SetValue(fieldCookie, o, new Boolean(value));
d570 1
a570 1
	    SetValue(fieldCookie, o, new Byte(value));
d595 1
a595 1
	    SetValue(fieldCookie, o, new Character(value));
d620 1
a620 1
	    SetValue(fieldCookie, o, new Short(value));
d645 1
a645 1
	    SetValue(fieldCookie, o, new Integer(value));
d670 1
a670 1
	    SetValue(fieldCookie, o, new Long(value));
d695 1
a695 1
	    SetValue(fieldCookie, o, new Float(value));
d720 1
a720 1
	    SetValue(fieldCookie, o, new Double(value));
@


1.9
log
@*** empty log message ***
@
text
@d42 1
d240 1
a240 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d266 1
a266 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d291 1
a291 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d314 1
a314 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d339 1
a339 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d364 1
a364 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d389 1
a389 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d414 1
a414 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d440 1
a440 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d493 1
a493 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d498 1
a498 1
	static void checkAccess(int modifiers, Object o, Class declaringClass, StackFrame frame) throws IllegalAccessException
a502 1
	    Class caller = getClassFromFrame(frame);
d515 3
a517 1
		    throw new IllegalAccessException();
a521 1
	private static native Class getClassFromFrame(StackFrame frame);
d544 1
a544 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d569 1
a569 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d594 1
a594 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d619 1
a619 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d644 1
a644 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d669 1
a669 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d694 1
a694 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
d719 1
a719 1
		checkAccess(modifiers, o, declaringClass, new StackFrame(1));
@


1.8
log
@*** empty log message ***
@
text
@d91 1
a91 1
	    classIsPublic = (declaringClass.getModifiers() & Modifier.PUBLIC) != 0;
d501 1
a501 1
	    boolean declaringClassIsPublic = (declaringClass.getModifiers() & Modifier.PUBLIC) != 0;
@


1.7
log
@*** empty log message ***
@
text
@d79 1
a79 1
	private Object fieldCookie;
@


1.6
log
@*** empty log message ***
@
text
@d86 1
a86 1
	public Field(Class declaringClass, Object fieldCookie)
@


1.5
log
@*** empty log message ***
@
text
@d505 5
@


1.4
log
@*** empty log message ***
@
text
@d239 1
a239 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d265 1
a265 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d290 1
a290 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d313 1
a313 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d338 1
a338 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d363 1
a363 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d388 1
a388 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d413 1
a413 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d439 1
a439 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d492 1
a492 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d497 1
a497 1
	static void checkAccess(int modifiers, Class declaringClass, StackFrame frame) throws IllegalAccessException
d499 2
d505 1
a505 1
		if(Modifier.isProtected(modifiers) && declaringClass.isAssignableFrom(caller))
d538 1
a538 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d563 1
a563 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d588 1
a588 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d613 1
a613 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d638 1
a638 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d663 1
a663 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d688 1
a688 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
d713 1
a713 1
		checkAccess(modifiers, declaringClass, new StackFrame(1));
@


1.3
log
@*** empty log message ***
@
text
@d81 1
d91 1
d238 1
a238 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d264 1
a264 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d289 1
a289 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d312 1
a312 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d337 1
a337 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d362 1
a362 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d387 1
a387 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d412 1
a412 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d438 1
a438 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d491 1
a491 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d499 1
d501 1
a501 1
	    if(!Modifier.isPublic(modifiers) && declaringClass != caller)
d535 1
a535 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d560 1
a560 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d585 1
a585 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d610 1
a610 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d635 1
a635 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d660 1
a660 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d685 1
a685 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
d710 1
a710 1
	    if(!isAccessible() && !Modifier.isPublic(modifiers))
@


1.2
log
@*** empty log message ***
@
text
@d41 2
d80 1
d87 3
a89 2
		this.declaringClass = declaringClass;
		this.fieldCookie = fieldCookie;
d91 1
d125 1
a125 1
		return GetModifiers(fieldCookie);
a126 1
	private static native int GetModifiers(Object fieldCookie);
d236 3
a238 1
		return GetValue(fieldCookie, o);
d262 3
a264 1
		return ((Boolean)get(o)).booleanValue();
d287 3
a289 1
		return ((Byte)get(o)).byteValue();
d310 3
a312 1
		return ((Character)get(o)).charValue();
d335 3
a337 1
		return ((Short)get(o)).shortValue();
d360 3
a362 1
		return ((Integer)get(o)).intValue();
d385 3
a387 1
		return ((Long)get(o)).longValue();
d410 3
a412 1
		return ((Float)get(o)).floatValue();
d436 3
a438 1
		return ((Double)get(o)).doubleValue();
d489 3
a491 1
		SetValue(fieldCookie, o, value);
d495 17
d532 3
a534 1
		set(o, new Boolean(value));
d557 3
a559 1
		set(o, new Byte(value));
d582 3
a584 1
		set(o, new Character(value));
d607 3
a609 1
		set(o, new Short(value));
d632 3
a634 1
		set(o, new Integer(value));
d657 3
a659 1
		set(o, new Long(value));
d682 3
a684 1
		set(o, new Float(value));
d707 3
a709 1
		set(o, new Double(value));
@


1.1
log
@Initial revision
@
text
@d137 1
a137 2
	 * class, name, and type. Since you can't creat a Field except through
	 * the VM, this is just the == relation.
d144 14
a157 5
		if(o instanceof Field)
		{
			return fieldCookie == ((Field)o).fieldCookie;
		}
		return false;
@


1.1.1.1
log
@no message
@
text
@@
