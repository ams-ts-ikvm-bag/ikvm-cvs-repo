head	1.29;
access;
symbols
	v0_36_0_14:1.28
	v0_36_0_13:1.28
	v0_36_0_9:1.28
	v0_36_0_7:1.28
	v0_36_0_5:1.28
	v0_36_0_4:1.28
	v0_36_0_3:1.28
	v0_36_0_2:1.28
	v0_36_0_1:1.28
	v0_36_0_0:1.28
	v0_36:1.28.0.4
	v0_34_0_3:1.28
	v0_34_0_2:1.28
	v0_34_0_1:1.28
	v0_34_0_0:1.28
	v0_34:1.28.0.2
	v0_32:1.27.0.2
	v0_32_0_0:1.27
	v0_30:1.26.0.2
	v0_28_0_0:1.26
	v0_26_0_1:1.19
	v0_26_0_0:1.19
	v0_24_0_1:1.18
	v0_24_0_0:1.18
	v0_22_0_0:1.18
	v0_20_0_0:1.18
	v0_18_0_0:1.18
	v0_16_0_0:1.18
	v0_14_0_1:1.16
	v0_14_0_0:1.16
	v0_12_0_0:1.15
	v0_10_0_1:1.14
	v0_10_0_0:1.14
	v0_8_0_0:1.10
	initial:1.1.1.1
	ikvm:1.1.1;
locks; strict;
comment	@# @;


1.29
date	2008.08.06.12.51.20;	author jfrijters;	state dead;
branches;
next	1.28;

1.28
date	2006.12.11.13.13.27;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.21.05.15.52;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.21.12.36.23;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.17.08.33.49;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.05.08.59.29;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.05.08.19.00;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.27.16.21.32;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.27.10.22.23;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.27.07.59.35;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.06.10.58.54;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.20.13.33.16;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.13.11.41.33;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.23.09.33.39;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.02.15.12.02;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.21.10.26.52;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.07.09.53.42;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.29.09.48.05;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.25.09.38.07;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.14.10.36.39;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.02.09.46.26;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.24.11.51.41;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.21.10.06.36;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.14.09.41.59;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.27.16.42.30;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.17.13.48.14;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.17.14.35.02;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.18.16.01.03;	author jfrijters;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.12.18.16.01.03;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Removed files that are no longer needed no that GNU Classpath support has been dropped.
@
text
@/* java.lang.reflect.Constructor - reflection of Java constructors
   Copyright (C) 1998, 2001, 2004, 2005 Free Software Foundation, Inc.

This file is part of GNU Classpath.

GNU Classpath is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.
 
GNU Classpath is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Classpath; see the file COPYING.  If not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301 USA.

Linking this library statically or dynamically with other modules is
making a combined work based on this library.  Thus, the terms and
conditions of the GNU General Public License cover the whole
combination.

As a special exception, the copyright holders of this library give you
permission to link this library with independent modules to produce an
executable, regardless of the license terms of these independent
modules, and to copy and distribute the resulting executable under
terms of your choice, provided that you also meet, for each linked
independent module, the terms and conditions of the license of that
module.  An independent module is a module which is not derived from
or based on this library.  If you modify this library, you may extend
this exception to your version of the library, but you are not
obligated to do so.  If you do not wish to do so, delete this
exception statement from your version. */


package java.lang.reflect;

import gnu.java.lang.ClassHelper;

import gnu.java.lang.reflect.MethodSignatureParser;
import java.lang.annotation.Annotation;
import java.util.Arrays;
import gnu.classpath.VMStackWalker;

/**
 * The Constructor class represents a constructor of a class. It also allows
 * dynamic creation of an object, via reflection. Invocation on Constructor
 * objects knows how to do widening conversions, but throws
 * {@@link IllegalArgumentException} if a narrowing conversion would be
 * necessary. You can query for information on this Constructor regardless
 * of location, but construction access may be limited by Java language
 * access controls. If you can't do it in the compiler, you can't normally
 * do it here either.<p>
 *
 * <B>Note:</B> This class returns and accepts types as Classes, even
 * primitive types; there are Class types defined that represent each
 * different primitive type.  They are <code>java.lang.Boolean.TYPE,
 * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,
 * byte.class</code>, etc.  These are not to be confused with the
 * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are
 * real classes.<p>
 *
 * Also note that this is not a serializable class.  It is entirely feasible
 * to make it serializable using the Externalizable interface, but this is
 * on Sun, not me.
 *
 * @@author John Keiser
 * @@author Eric Blake <ebb9@@email.byu.edu>
 * @@see Member
 * @@see Class
 * @@see java.lang.Class#getConstructor(Class[])
 * @@see java.lang.Class#getDeclaredConstructor(Class[])
 * @@see java.lang.Class#getConstructors()
 * @@see java.lang.Class#getDeclaredConstructors()
 * @@since 1.1
 * @@status updated to 1.4
 */
public final class Constructor<T>
    extends AccessibleObject
    implements GenericDeclaration, Member
{
    private Class<T> clazz;
    private static final int CONSTRUCTOR_MODIFIERS
        = Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC;
    @@ikvm.lang.Internal
    public Object methodCookie;
    private int modifiers;
    private boolean classIsPublic;
  
    /**
     * This class is uninstantiable except from native code.
     */
    @@ikvm.lang.Internal
    public Constructor(Class declaringClass, Object methodCookie)
    {
	this.clazz = declaringClass;
	this.methodCookie = methodCookie;
	modifiers = Method.GetModifiers(methodCookie);
	classIsPublic = (Method.GetRealModifiers(declaringClass) & Modifier.PUBLIC) != 0;
    }

    /**
     * Gets the class that declared this constructor.
     * @@return the class that declared this member
     */
    public Class<T> getDeclaringClass()
    {
	return clazz;
    }

    /**
     * Gets the name of this constructor (the non-qualified name of the class
     * it was declared in).
     * @@return the name of this constructor
     */
    public String getName()
    {
        return getDeclaringClass().getName();
    }

    /**
     * Return the raw modifiers for this constructor.  In particular
     * this will include the synthetic and varargs bits.
     * @@return the constructor's modifiers
     */
    private int getModifiersInternal()
    {
        return modifiers;
    }

    /**
     * Gets the modifiers this constructor uses.  Use the <code>Modifier</code>
     * class to interpret the values. A constructor can only have a subset of the
     * following modifiers: public, private, protected.
     *
     * @@return an integer representing the modifiers to this Member
     * @@see Modifier
     */
    public int getModifiers()
    {
        return getModifiersInternal() & CONSTRUCTOR_MODIFIERS;
    }

    /**
     * Return true if this constructor is synthetic, false otherwise.
     * A synthetic member is one which is created by the compiler,
     * and which does not appear in the user's source code.
     * @@since 1.5
     */
    public boolean isSynthetic()
    {
        return (getModifiersInternal() & Modifier.SYNTHETIC) != 0;
    }

    /**
     * Return true if this is a varargs constructor, that is if
     * the constructor takes a variable number of arguments.
     * @@since 1.5
     */
    public boolean isVarArgs()
    {
        return (getModifiersInternal() & Modifier.VARARGS) != 0;
    }

    /**
     * Get the parameter list for this constructor, in declaration order. If the
     * constructor takes no parameters, returns a 0-length array (not null).
     *
     * @@return a list of the types of the constructor's parameters
     */
    public Class<?>[] getParameterTypes()
    {
	return Method.GetParameterTypesHelper(methodCookie);
    }

    /**
     * Get the exception types this constructor says it throws, in no particular
     * order. If the constructor has no throws clause, returns a 0-length array
     * (not null).
     *
     * @@return a list of the types in the constructor's throws clause
     */
    public Class<?>[] getExceptionTypes()
    {
	ClassLoader loader = getDeclaringClass().getClassLoader();
	String[] ex = Method.GetExceptionTypes(methodCookie);
	Class[] exc = new Class[ex.length];
	for(int i = 0; i < ex.length; i++)
	{
	    try
	    {  
		exc[i] = Class.forName(ex[i], false, loader);
	    }
	    catch(ClassNotFoundException x)
	    {
		throw new NoClassDefFoundError(ex[i]);
	    }
	}
	return exc;
    }

    /**
     * Compare two objects to see if they are semantically equivalent.
     * Two Constructors are semantically equivalent if they have the same
     * declaring class and the same parameter list.  This ignores different
     * exception clauses, but since you can't create a Method except through the
     * VM, this is just the == relation.
     *
     * @@param o the object to compare to
     * @@return <code>true</code> if they are equal; <code>false</code> if not.
     */
    public boolean equals(Object o)
    {
        if (!(o instanceof Constructor))
            return false;
        Constructor that = (Constructor)o; 
        if (this.getDeclaringClass() != that.getDeclaringClass())
            return false;
        if (!Arrays.equals(this.getParameterTypes(), that.getParameterTypes()))
            return false;
        return true;
    }

    /**
     * Get the hash code for the Constructor. The Constructor hash code is the
     * hash code of the declaring class's name.
     *
     * @@return the hash code for the object
     */
    public int hashCode()
    {
	return getDeclaringClass().getName().hashCode();
    }

    /**
     * Get a String representation of the Constructor. A Constructor's String
     * representation is "&lt;modifier&gt; &lt;classname&gt;(&lt;paramtypes&gt;)
     * throws &lt;exceptions&gt;", where everything after ')' is omitted if
     * there are no exceptions.<br> Example:
     * <code>public java.io.FileInputStream(java.lang.Runnable)
     * throws java.io.FileNotFoundException</code>
     *
     * @@return the String representation of the Constructor
     */
    public String toString()
    {
        // 128 is a reasonable buffer initial size for constructor
        StringBuffer sb = new StringBuffer(128);
        Modifier.toString(getModifiers(), sb);
        if (sb.length() > 0)
            sb.append(' ');
        sb.append(getDeclaringClass().getName()).append('(');
	Class[] c = getParameterTypes();
	if (c.length > 0)
	{
            sb.append(ClassHelper.getUserName(c[0]));
            for (int i = 1; i < c.length; i++)
                sb.append(',').append(ClassHelper.getUserName(c[i]));
        }
	sb.append(')');
	c = getExceptionTypes();
	if (c.length > 0)
	{
	    sb.append(" throws ").append(c[0].getName());
	    for (int i = 1; i < c.length; i++)
		sb.append(',').append(c[i].getName());
	}
	return sb.toString();
    }
 
    /* FIXME[GENERICS]: Add X extends GenericDeclaration and TypeVariable<X> */
    static void addTypeParameters(StringBuffer sb, TypeVariable[] typeArgs)
    {
        if (typeArgs.length == 0)
            return;
        sb.append('<');
        for (int i = 0; i < typeArgs.length; ++i)
        {
            if (i > 0)
                sb.append(',');
            sb.append(typeArgs[i]);
        }
        sb.append("> ");
    }

    public String toGenericString()
    {
        StringBuffer sb = new StringBuffer(128);
        Modifier.toString(getModifiers(), sb).append(' ');
        addTypeParameters(sb, getTypeParameters());
        sb.append(getDeclaringClass().getName()).append('(');
        Type[] types = getGenericParameterTypes();
        if (types.length > 0)
        {
            sb.append(types[0]);
            for (int i = 1; i < types.length; ++i)
                sb.append(',').append(types[i]);
        }
        sb.append(')');
        types = getGenericExceptionTypes();
        if (types.length > 0)
        {
            sb.append(" throws ").append(types[0]);
            for (int i = 1; i < types.length; i++)
                sb.append(',').append(types[i]);
        }
        return sb.toString();
    }

    /**
     * Create a new instance by invoking the constructor. Arguments are
     * automatically unwrapped and widened, if needed.<p>
     *
     * If this class is abstract, you will get an
     * <code>InstantiationException</code>. If the constructor takes 0
     * arguments, you may use null or a 0-length array for <code>args</code>.<p>
     *
     * If this Constructor enforces access control, your runtime context is
     * evaluated, and you may have an <code>IllegalAccessException</code> if
     * you could not create this object in similar compiled code. If the class
     * is uninitialized, you trigger class initialization, which may end in a
     * <code>ExceptionInInitializerError</code>.<p>
     *
     * Then, the constructor is invoked. If it completes normally, the return
     * value will be the new object. If it completes abruptly, the exception is
     * wrapped in an <code>InvocationTargetException</code>.
     *
     * @@param args the arguments to the constructor
     * @@return the newly created object
     * @@throws IllegalAccessException if the constructor could not normally be
     *         called by the Java code (i.e. it is not public)
     * @@throws IllegalArgumentException if the number of arguments is incorrect;
     *         or if the arguments types are wrong even with a widening
     *         conversion
     * @@throws InstantiationException if the class is abstract
     * @@throws InvocationTargetException if the constructor throws an exception
     * @@throws ExceptionInInitializerError if construction triggered class
     *         initialization, which then failed
     */
    public T newInstance(Object... args)
	throws InstantiationException, IllegalAccessException,
	InvocationTargetException
    {
	if(!isAccessible() && (!Modifier.isPublic(modifiers) || !classIsPublic))
	    VMFieldImpl.checkAccess(methodCookie, null, VMStackWalker.getCallingClass());
        if(clazz.isEnum())
        {
            throw new IllegalArgumentException("Cannot reflectively create enum objects");
        }
        int mods = clazz.getModifiers() | Method.GetRealModifiers(clazz);
	if(Modifier.isAbstract(mods) || Modifier.isInterface(mods))
	{
	    throw new InstantiationException();
	}
	return (T)Method.Invoke(methodCookie, null, args);
    }

    /**
     * Returns an array of <code>TypeVariable</code> objects that represents
     * the type variables declared by this constructor, in declaration order.
     * An array of size zero is returned if this constructor has no type
     * variables.
     *
     * @@return the type variables associated with this constructor.
     * @@throws GenericSignatureFormatError if the generic signature does
     *         not conform to the format specified in the Virtual Machine
     *         specification, version 3.
     * @@since 1.5
     */
    public TypeVariable<Constructor<T>>[] getTypeParameters()
    {
        String sig = getSignature();
        if (sig == null)
            return new TypeVariable[0];
        MethodSignatureParser p = new MethodSignatureParser(this, sig);
        return p.getTypeParameters();
    }

    /**
     * Return the String in the Signature attribute for this constructor. If there
     * is no Signature attribute, return null.
     */
    private String getSignature()
    {
        return Method.GetSignature(methodCookie);
    }

    /**
     * Returns an array of <code>Type</code> objects that represents
     * the exception types declared by this constructor, in declaration order.
     * An array of size zero is returned if this constructor declares no
     * exceptions.
     *
     * @@return the exception types declared by this constructor. 
     * @@throws GenericSignatureFormatError if the generic signature does
     *         not conform to the format specified in the Virtual Machine
     *         specification, version 3.
     * @@since 1.5
     */
    public Type[] getGenericExceptionTypes()
    {
        String sig = getSignature();
        if (sig == null)
            return getExceptionTypes();
        MethodSignatureParser p = new MethodSignatureParser(this, sig);
        return p.getGenericExceptionTypes();
    }

    /**
     * Returns an array of <code>Type</code> objects that represents
     * the parameter list for this constructor, in declaration order.
     * An array of size zero is returned if this constructor takes no
     * parameters.
     *
     * @@return a list of the types of the constructor's parameters
     * @@throws GenericSignatureFormatError if the generic signature does
     *         not conform to the format specified in the Virtual Machine
     *         specification, version 3.
     * @@since 1.5
     */
    public Type[] getGenericParameterTypes()
    {
        String sig = getSignature();
        if (sig == null)
            return getParameterTypes();
        MethodSignatureParser p = new MethodSignatureParser(this, sig);
        return p.getGenericParameterTypes();
    }

    public <T extends Annotation> T getAnnotation(Class<T> annotationClass)
    {
        for (Annotation annotation : getDeclaredAnnotations())
            if (annotation.annotationType() == annotationClass)
                return (T) annotation;
        return null;
    }

    public Annotation[] getDeclaredAnnotations()
    {
        return Method.toAnnotationArray(Method.GetDeclaredAnnotations(methodCookie));
    }

    public Annotation[][] getParameterAnnotations()
    {
        return Method.toAnnotationArrayArray(Method.GetParameterAnnotations(methodCookie));
    }
}
@


1.28
log
@*** empty log message ***
@
text
@@


1.27
log
@*** empty log message ***
@
text
@a43 1

d81 1
a81 1
public final class Constructor
d85 1
a85 1
    private Class clazz;
d109 1
a109 1
    public Class getDeclaringClass()
d111 1
a111 1
        return clazz;
d121 1
a121 1
	return getDeclaringClass().getName();
d174 1
a174 1
    public Class[] getParameterTypes()
d186 1
a186 1
    public Class[] getExceptionTypes()
d343 1
a343 1
    public Object newInstance(Object args[])
d358 1
a358 1
	return Method.Invoke(methodCookie, null, args);
d373 1
a373 2
    /* FIXME[GENERICS]: Add <Constructor<T>> */
    public TypeVariable[] getTypeParameters()
d433 1
a433 1
    public Annotation getAnnotation(Class annotationClass)
d437 1
a437 1
                return annotation;
@


1.26
log
@*** empty log message ***
@
text
@d350 4
@


1.25
log
@*** empty log message ***
@
text
@d45 1
d430 18
@


1.24
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1998, 2001 Free Software Foundation, Inc.
@


1.23
log
@*** empty log message ***
@
text
@d43 2
d82 2
a83 1
    extends AccessibleObject implements Member
d274 39
d356 73
@


1.22
log
@*** empty log message ***
@
text
@d249 4
a252 2
        Modifier.toString(getModifiers(), sb).append(' ');
	sb.append(getDeclaringClass().getName()).append('(');
d306 1
a306 1
	    VMFieldImpl.checkAccess(modifiers, null, clazz, VMStackWalker.getCallingClass());
@


1.21
log
@*** empty log message ***
@
text
@d85 2
a86 1
    Object methodCookie;
d93 2
a94 1
    Constructor(Class declaringClass, Object methodCookie)
@


1.20
log
@*** empty log message ***
@
text
@a43 1
import cli.System.Diagnostics.StackFrame;
@


1.19
log
@*** empty log message ***
@
text
@d18 2
a19 2
Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.
d41 3
d73 2
a74 2
 * @@see java.lang.Class#getConstructor(Object[])
 * @@see java.lang.Class#getDeclaredConstructor(Object[])
d83 3
a85 1
    private Class declaringClass;
d91 1
a91 1
     * This class is instantiated by java.lang.Class
d95 1
a95 1
	this.declaringClass = declaringClass;
d107 1
a107 1
	return declaringClass;
d117 11
a127 1
	return declaringClass.getName();
d140 22
a161 1
	return modifiers;
d213 8
a220 5
	if(o instanceof Constructor)
	{
	    return methodCookie == ((Constructor)o).methodCookie;
	}
	return false;
a234 28
     * Return the name of the class as written by the user.
     * This is used by the various reflection toString methods.
     * It differs from {@@link Class#getName()} in that it prints
     * arrays with trailing "[]"s.  Note that it does not treat
     * member classes specially, so a dollar sign may still appear
     * in the result.  This is intentional.
     * @@param klass the class
     * @@return a pretty form of the class' name
     */
    static String getUserName(Class klass)
    {
        int arrayCount = 0;
        while (klass.isArray())
        {
            ++arrayCount;
            klass = klass.getComponentType();
        }
        String name = klass.getName();
        if (arrayCount == 0)
            return name;
        StringBuilder b = new StringBuilder(name.length() + 2 * arrayCount);
        b.append(name);
        for (int i = 0; i < arrayCount; ++i)
            b.append("[]");
        return b.toString();
    }

    /**
d246 3
a248 4
	StringBuffer sb = new StringBuffer();
	sb.append(Modifier.toString(getModifiers()));
	if (sb.length() > 0)
	    sb.append(' ');
d253 4
a256 4
	    sb.append(getUserName(c[0]));
	    for (int i = 1; i < c.length; i++)
		sb.append(',').append(getUserName(c[i]));
	}
d303 2
a304 2
	    VMFieldImpl.checkAccess(modifiers, null, declaringClass, VMStackWalker.getCallingClass());
        int mods = declaringClass.getModifiers() | Method.GetRealModifiers(declaringClass);
@


1.18
log
@*** empty log message ***
@
text
@d196 28
d243 1
a243 1
	    sb.append(c[0].getName());
d245 1
a245 1
		sb.append(',').append(c[i].getName());
@


1.17
log
@*** empty log message ***
@
text
@d208 1
a208 1
	Modifier.toString(getModifiers(), sb);
@


1.16
log
@*** empty log message ***
@
text
@d208 3
a210 1
	Modifier.toString(getModifiers(), sb).append(' ');
@


1.15
log
@*** empty log message ***
@
text
@d263 1
a263 1
	    Field.checkAccess(modifiers, null, declaringClass, VMStackWalker.getCallingClass());
@


1.14
log
@*** empty log message ***
@
text
@d42 1
d263 1
a263 1
	    Field.checkAccess(modifiers, null, declaringClass, new StackFrame(1));
@


1.13
log
@*** empty log message ***
@
text
@d92 1
a92 1
	classIsPublic = (declaringClass.getModifiers() & Modifier.PUBLIC) != 0;
d263 2
a264 1
	if(Modifier.isAbstract(declaringClass.getModifiers()))
@


1.12
log
@*** empty log message ***
@
text
@d135 1
a135 4
	Object[] params = Method.GetParameterTypes(methodCookie);
	Class[] paramsClass = new Class[params.length];
	System.arraycopy(params, 0, paramsClass, 0, params.length);
	return paramsClass;
@


1.11
log
@*** empty log message ***
@
text
@d80 1
a80 1
    private Object methodCookie;
@


1.10
log
@*** empty log message ***
@
text
@d87 1
a87 2
    // TODO this constructor shouldn't be public (but it needs to be accessible to java.lang.Class)
    public Constructor(Class declaringClass, Object methodCookie)
@


1.9
log
@*** empty log message ***
@
text
@d266 1
a266 1
	    Field.checkAccess(modifiers, declaringClass, new StackFrame(1));
@


1.8
log
@*** empty log message ***
@
text
@d82 1
d93 1
d265 1
a265 1
	if(!isAccessible() && !Modifier.isPublic(modifiers))
@


1.7
log
@*** empty log message ***
@
text
@d41 2
d79 1
a79 1
    private Class clazz;
d81 1
d89 1
a89 1
	this.clazz = declaringClass;
d91 1
d100 1
a100 1
	return clazz;
d110 1
a110 1
	return clazz.getName();
d123 1
a123 1
	return Method.GetModifiers(methodCookie);
d263 3
a265 1
	if(Modifier.isAbstract(clazz.getModifiers()))
@


1.6
log
@*** empty log message ***
@
text
@d75 1
a75 1
	extends AccessibleObject implements Member
d77 2
a78 2
	private Class clazz;
	private Object methodCookie;
d80 141
a220 132
	/**
	 * This class is instantiated by java.lang.Class
	 */
	// TODO this constructor shouldn't be public (but it needs to be accessible to java.lang.Class)
	public Constructor(Class declaringClass, Object methodCookie)
	{
		this.clazz = declaringClass;
		this.methodCookie = methodCookie;
	}

	/**
	 * Gets the class that declared this constructor.
	 * @@return the class that declared this member
	 */
	public Class getDeclaringClass()
	{
		return clazz;
	}

	/**
	 * Gets the name of this constructor (the non-qualified name of the class
	 * it was declared in).
	 * @@return the name of this constructor
	 */
	public String getName()
	{
		return clazz.getName();
	}

	/**
	 * Gets the modifiers this constructor uses.  Use the <code>Modifier</code>
	 * class to interpret the values. A constructor can only have a subset of the
	 * following modifiers: public, private, protected.
	 *
	 * @@return an integer representing the modifiers to this Member
	 * @@see Modifier
	 */
	public int getModifiers()
	{
		return Method.GetModifiers(methodCookie);
	}

	/**
	 * Get the parameter list for this constructor, in declaration order. If the
	 * constructor takes no parameters, returns a 0-length array (not null).
	 *
	 * @@return a list of the types of the constructor's parameters
	 */
	public Class[] getParameterTypes()
	{
		Object[] params = Method.GetParameterTypes(methodCookie);
		Class[] paramsClass = new Class[params.length];
		System.arraycopy(params, 0, paramsClass, 0, params.length);
		return paramsClass;
	}

	/**
	 * Get the exception types this constructor says it throws, in no particular
	 * order. If the constructor has no throws clause, returns a 0-length array
	 * (not null).
	 *
	 * @@return a list of the types in the constructor's throws clause
	 */
	public Class[] getExceptionTypes()
	{
		Object[] ex = Method.GetExceptionTypes(methodCookie);
		Class[] exc = new Class[ex.length];
		System.arraycopy(ex, 0, exc, 0, ex.length);
		return exc;
	}

	/**
	 * Compare two objects to see if they are semantically equivalent.
	 * Two Constructors are semantically equivalent if they have the same
	 * declaring class and the same parameter list.  This ignores different
	 * exception clauses, but since you can't create a Method except through the
	 * VM, this is just the == relation.
	 *
	 * @@param o the object to compare to
	 * @@return <code>true</code> if they are equal; <code>false</code> if not.
	 */
	public boolean equals(Object o)
	{
		if(o instanceof Constructor)
		{
			return methodCookie == ((Constructor)o).methodCookie;
		}
		return false;
	}

	/**
	 * Get the hash code for the Constructor. The Constructor hash code is the
	 * hash code of the declaring class's name.
	 *
	 * @@return the hash code for the object
	 */
	public int hashCode()
	{
		return getDeclaringClass().getName().hashCode();
	}

	/**
	 * Get a String representation of the Constructor. A Constructor's String
	 * representation is "&lt;modifier&gt; &lt;classname&gt;(&lt;paramtypes&gt;)
	 * throws &lt;exceptions&gt;", where everything after ')' is omitted if
	 * there are no exceptions.<br> Example:
	 * <code>public java.io.FileInputStream(java.lang.Runnable)
	 * throws java.io.FileNotFoundException</code>
	 *
	 * @@return the String representation of the Constructor
	 */
	public String toString()
	{
		StringBuffer sb = new StringBuffer();
		Modifier.toString(getModifiers(), sb).append(' ');
		sb.append(getDeclaringClass().getName()).append('(');
		Class[] c = getParameterTypes();
		if (c.length > 0)
		{
			sb.append(c[0].getName());
			for (int i = 1; i < c.length; i++)
				sb.append(',').append(c[i].getName());
		}
		sb.append(')');
		c = getExceptionTypes();
		if (c.length > 0)
		{
			sb.append(" throws ").append(c[0].getName());
			for (int i = 1; i < c.length; i++)
				sb.append(',').append(c[i].getName());
		}
		return sb.toString();
d222 2
d225 35
a259 33
	/**
	 * Create a new instance by invoking the constructor. Arguments are
	 * automatically unwrapped and widened, if needed.<p>
	 *
	 * If this class is abstract, you will get an
	 * <code>InstantiationException</code>. If the constructor takes 0
	 * arguments, you may use null or a 0-length array for <code>args</code>.<p>
	 *
	 * If this Constructor enforces access control, your runtime context is
	 * evaluated, and you may have an <code>IllegalAccessException</code> if
	 * you could not create this object in similar compiled code. If the class
	 * is uninitialized, you trigger class initialization, which may end in a
	 * <code>ExceptionInInitializerError</code>.<p>
	 *
	 * Then, the constructor is invoked. If it completes normally, the return
	 * value will be the new object. If it completes abruptly, the exception is
	 * wrapped in an <code>InvocationTargetException</code>.
	 *
	 * @@param args the arguments to the constructor
	 * @@return the newly created object
	 * @@throws IllegalAccessException if the constructor could not normally be
	 *         called by the Java code (i.e. it is not public)
	 * @@throws IllegalArgumentException if the number of arguments is incorrect;
	 *         or if the arguments types are wrong even with a widening
	 *         conversion
	 * @@throws InstantiationException if the class is abstract
	 * @@throws InvocationTargetException if the constructor throws an exception
	 * @@throws ExceptionInInitializerError if construction triggered class
	 *         initialization, which then failed
	 */
	public Object newInstance(Object args[])
		throws InstantiationException, IllegalAccessException,
		InvocationTargetException
d261 1
a261 5
		if(Modifier.isAbstract(clazz.getModifiers()))
		{
			throw new InstantiationException();
		}
		return Method.Invoke(methodCookie, null, args);
d263 2
@


1.5
log
@*** empty log message ***
@
text
@a40 2
import system.reflection.*;

d163 1
a163 1
		if(o instanceof ConstructorInfo)
@


1.4
log
@*** empty log message ***
@
text
@a40 1
import system.*;
@


1.3
log
@*** empty log message ***
@
text
@d255 1
a255 9
		// TODO check args and accessibility
		try
		{
			return Method.Invoke(methodCookie, null, args);
		}
		catch(Throwable x)
		{
			throw new InvocationTargetException(x);
		}
@


1.2
log
@no message
@
text
@d109 1
a109 1
		return Method.GetName(methodCookie);
@


1.1
log
@Initial revision
@
text
@d251 1
a251 3
		return Method.Invoke(methodCookie, null, args);
		/*
		try
d253 1
a253 6
			if(false) throw new MemberAccessException();
			if(false) throw new ArgumentException();
			if(false) throw new TargetParameterCountException();
			if(false) throw new TargetInvocationException(null);
			// TODO wrappers need to be unwrapped (e.g. java.lang.Integer -> boxed System.Int32)
			return ci.Invoke(args);
d255 2
a256 9
		catch(MemberAccessException x1)
		{
			throw new IllegalAccessException(x1.get_Message());
		}
		catch(ArgumentException x2)
		{
			throw new IllegalArgumentException();
		}
		catch(TargetParameterCountException x3)
d258 1
a258 1
			throw new IllegalArgumentException();
d260 1
a260 1
		catch(TargetInvocationException x4)
d262 1
a262 3
			InstantiationException ie = new InstantiationException();
			ie.initCause(Method.mapException(x4.get_InnerException()));
			throw ie;
a263 1
		*/
@


1.1.1.1
log
@no message
@
text
@@
