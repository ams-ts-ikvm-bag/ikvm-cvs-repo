head	1.63;
access;
symbols
	v0_36_0_14:1.62
	v0_36_0_13:1.62
	v0_36_0_9:1.62
	v0_36_0_7:1.62
	v0_36_0_5:1.62
	v0_36_0_4:1.62
	v0_36_0_3:1.62
	v0_36_0_2:1.62
	v0_36_0_1:1.62
	v0_36_0_0:1.62
	v0_36:1.62.0.2
	v0_34_0_3:1.58.2.2
	v0_34_0_2:1.58.2.2
	v0_34_0_1:1.58.2.2
	v0_34_0_0:1.58.2.2
	v0_34:1.58.0.2
	v0_32:1.55.0.2
	v0_32_0_0:1.55
	v0_30:1.47.0.2
	v0_28_0_0:1.42
	v0_26_0_1:1.38
	v0_26_0_0:1.38
	v0_24_0_1:1.38
	v0_24_0_0:1.38
	v0_22_0_0:1.37
	v0_20_0_0:1.36
	v0_18_0_0:1.33
	v0_16_0_0:1.33
	v0_14_0_1:1.28
	v0_14_0_0:1.28
	v0_12_0_0:1.25
	v0_10_0_1:1.22
	v0_10_0_0:1.22
	v0_8_0_0:1.9;
locks; strict;
comment	@# @;


1.63
date	2008.08.06.12.51.13;	author jfrijters;	state dead;
branches;
next	1.62;

1.62
date	2007.08.09.07.09.13;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.18.06.05.26;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.23.08.14.55;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.19.10.14.05;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2007.03.15.08.01.50;	author jfrijters;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2007.01.05.08.14.18;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2007.01.04.07.46.39;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.20.09.33.15;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.09.07.46.00;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2006.10.22.01.33.34;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2006.10.19.06.12.48;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2006.10.04.09.03.18;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2006.10.02.07.10.53;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.20.05.53.38;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.17.07.33.39;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.02.13.45.54;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2006.06.20.14.31.57;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.15.12.29.12;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.09.13.17.55;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2006.06.08.09.26.38;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.21.09.38.07;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.05.11.04.43;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.05.08.18.59;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.27.16.21.32;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.07.09.06.32;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.01.11.16.12;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.19.09.08.43;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.03.14.10.00;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.22.12.26.15;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.16.07.42.32;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.31.08.57.34;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.24.11.54.20;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.23.08.24.08;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.18.11.54.28;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.27.06.10.02;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.11.08.05.43;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.23.09.33.39;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.23.13.10.45;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.11.14.47.00;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.02.15.11.51;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.03.08.26.22;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.02.08.43.06;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.29.13.58.21;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.29.09.48.05;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.23.17.46.40;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.16.11.11.54;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.19.13.43.56;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.04.19.30.54;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.27.10.17.34;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.09.11.17.55;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.30.15.56.24;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.17.09.05.25;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.10.07.19.57;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.25.09.38.07;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.18.15.56.24;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.17.14.38.09;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.17.12.01.54;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.14.10.36.39;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.23.14.21.45;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.20.13.25.08;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.16.17.10.11;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.08.15.18.48;	author jfrijters;	state Exp;
branches;
next	;

1.58.2.1
date	2007.04.13.06.46.38;	author jfrijters;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2007.04.23.07.25.23;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Removed files that are no longer needed no that GNU Classpath support has been dropped.
@
text
@<?xml version="1.0" encoding="utf-8" ?> 
<!--
  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
-->
<root>
	<assembly>
		<class name="java.lang.Object" shadows="System.Object" modifiers="public">
			<constructor sig="()V" modifiers="public" />
			<method name="notifyAll" sig="()V" modifiers="public final">
				<body>
					<ldarg_0 />
					<call type="System.Threading.Monitor" name="PulseAll" sig="(Ljava.lang.Object;)V" />
					<ret />
				</body>
			</method>
			<method name="notify" sig="()V" modifiers="public final">
				<body>
					<ldarg_0 />
					<call type="System.Threading.Monitor" name="Pulse" sig="(Ljava.lang.Object;)V" />
					<ret />
				</body>
			</method>
			<method name="wait" sig="()V" modifiers="public final">
				<throws class="java.lang.InterruptedException" />
				<body>
					<ldarg_0 />
					<ldc_i4_0 />
					<conv_i8 />
					<ldc_i4_0 />
					<call class="java.lang.VMThread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
					<ret />
				</body>
			</method>
			<method name="wait" sig="(J)V" modifiers="public final">
				<parameter name="timeout" />
				<throws class="java.lang.InterruptedException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldc_i4_0 />
					<call class="java.lang.VMThread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
					<ret />
				</body>
			</method>
			<method name="wait" sig="(JI)V" modifiers="public final">
				<parameter name="timeout" />
				<parameter name="nanos" />
				<throws class="java.lang.InterruptedException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<call class="java.lang.VMThread" name="objectWait" sig="(Ljava.lang.Object;JI)V" />
					<ret />
				</body>
			</method>
			<method name="getClass" sig="()Ljava.lang.Class;" modifiers="public final">
				<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
					<parameter>()Ljava/lang/Class&lt;+Ljava/lang/Object;&gt;;</parameter>
				</attribute>
				<body>
					<ldarg_0 />
					<call class="ikvm.runtime.Util" name="getClassFromObject" sig="(Ljava.lang.Object;)Ljava.lang.Class;" />
					<ret />
				</body>
			</method>
			<method name="clone" sig="()Ljava.lang.Object;" modifiers="protected">
				<throws class="java.lang.CloneNotSupportedException" />
				<body>
					<ldarg_0 />
					<isinst class="java.lang.Cloneable" />
					<brtrue name="ok" />
					<newobj class="java.lang.CloneNotSupportedException" name="&lt;init&gt;" sig="()V" />
					<throw />
					<label name="ok" />
					<ldarg_0 />
					<call type="System.Object" name="MemberwiseClone" sig="()Ljava.lang.Object;" />
					<ret />
				</body>
				<alternateBody>
					<ldarg_0 />
					<isinst type="System.Array" />
					<dup />
					<brfalse name="not_array" />
					<call type="System.Array" name="Clone" sig="()Ljava.lang.Object;" />
					<ret />
					<label name="not_array" />
					<pop />
					<ldarg_0 />
					<isinst class="java.lang.Cloneable" />
					<brfalse name="not_cloneable" />
					<!--
					 This means we're Cloneable, but not derived from java.lang.Object or java.lang.Throwable.
					 It also means that we must have been invoked thru reflection (or by code in the java.lang package),
					 so it is OK to use reflection to call Object.MemberwiseClone().
					 -->
					<ldtoken type="System.Object" />
					<call type="System.Type" name="GetTypeFromHandle" sig="(Lcli.System.RuntimeTypeHandle;)Lcli.System.Type;" />
					<ldstr value="MemberwiseClone" />
					<ldc_i4 value="36" />
					<ldnull />
					<ldsfld type="System.Type" name="EmptyTypes" sig="[Lcli.SystemType;" />
					<ldnull />
					<callvirt type="System.Type" name="GetMethod" sig="(Ljava.lang.String;Lcli.System.Reflection.BindingFlags;Lcli.System.Reflection.Binder;[Lcli.System.Type;[Lcli.System.Reflection.ParameterModifier;)Lcli.System.Reflection.MethodInfo;" />
					<ldarg_0 />
					<ldnull />
					<callvirt type="System.Reflection.MethodInfo" name="Invoke" sig="(Ljava.lang.Object;[Ljava.lang.Object;)Ljava.lang.Object;" />
					<ret />
					<label name="not_cloneable" />
					<newobj class="java.lang.CloneNotSupportedException" name="&lt;init&gt;" sig="()V" />
					<throw />
				</alternateBody>
			</method>
			<method name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" modifiers="private static">
				<body>
					<ldarg_0 />
					<callvirt class="java.lang.Object" name="getClass" sig="()Ljava.lang.Class;" />
					<call class="java.lang.Class" name="getName" sig="()Ljava.lang.String;" />
					<ldstr value="@@" />
					<ldarg_0 />
					<callvirt class="java.lang.Object" name="hashCode" sig="()I" />
					<call class="java.lang.Integer" name="toHexString" sig="(I)Ljava.lang.String;" />
					<call type="System.String" name="Concat" sig="(Ljava.lang.String;Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="toString" sig="()Ljava.lang.String;" modifiers="public">
				<override name="ToString" />
				<body>
					<ldarg_0 />
					<call class="java.lang.Object" name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
					<ret />
				</body>
				<alternateBody>
					<ldarg_0 />
					<isinst type="System.Array" />
					<brfalse name="skip" />
					<ldarg_0 />
					<call class="java.lang.Object" name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
					<br name="end" />
					<label name="skip" />
					<ldarg_0 />
					<callvirt type="System.Object" name="ToString" sig="()Ljava.lang.String;" />
					<label name="end" />
					<ret />
				</alternateBody>
				<nonvirtualAlternateBody>
					<ldarg_0 />
					<call class="java.lang.Object" name="toStringImpl" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
					<ret />
				</nonvirtualAlternateBody>
			</method>
			<method name="hashCode" sig="()I" modifiers="public">
				<override name="GetHashCode" />
				<nonvirtualAlternateBody>
					<ldarg_0 />
					<conditional framework="2.0">
						<code>
							<call type="System.Runtime.CompilerServices.RuntimeHelpers" name="GetHashCode" sig="(Ljava.lang.Object;)I" />
						</code>
					</conditional>
					<conditional framework="1.1">
						<code>
							<!-- FXBUG RuntimeHelpers.GetHashCode is broken in multi AppDomain scenarios (on v1.x) -->
							<call type="System.Object" name="GetHashCode" sig="()I" />
						</code>
					</conditional>
					<ret />
				</nonvirtualAlternateBody>
			</method>
			<method name="equals" sig="(Ljava.lang.Object;)Z" modifiers="public">
				<parameter name="obj" />
				<override name="Equals" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ceq />
					<ret />
				</body>
				<alternateBody>
					<ldarg_0 />
					<ldarg_1 />
					<callvirt type="System.Object" name="Equals" sig="(Ljava.lang.Object;)Z" />
					<ret />
				</alternateBody>
				<nonvirtualAlternateBody>
					<ldarg_0 />
					<ldarg_1 />
					<ceq />
					<ret />
				</nonvirtualAlternateBody>
			</method>
			<method name="finalize" sig="()V" modifiers="protected">
				<throws class="java.lang.Throwable" />
				<!-- NOTE we don't override Finalize, because that would be bad for performance,
					 instead, the compiler contains a hack to lazily override Finalize when a class
					 overrides our finalize
					 TODO consider adding code to constructor (in debug builds) to detect that someone
					 has overriden our finalize from another .NET language (if no intermediate Java base class
					 has overriden finalize, the lazy override of Object.Finalize hasn't kicked in and finalize
					 will never be called)
				-->
				<body>
					<ldarg_0 />
					<call type="System.Object" name="Finalize" sig="()V" />
					<ret />
				</body>
				<alternateBody>
					<!-- if code in the java.lang package explicitly invokes finalize on a non java.lang.Object
						 derived object	we just ignore it -->
					<ret />
				</alternateBody>
			</method>
		</class>
		<class name="java.lang.String" shadows="System.String" modifiers="public final">
			<implements class="java.io.Serializable" />
			<implements class="java.lang.Comparable" />
			<implements class="java.lang.CharSequence" />
			<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
				<parameter>Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/lang/CharSequence;</parameter>
			</attribute>			
			<field name="serialVersionUID" sig="J" modifiers="private static final" constant="-6849794470754667710" />
			<constructor sig="()V" modifiers="public">
				<alternateBody>
					<ldstr value="" />
					<call type="System.String" name="Copy" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</alternateBody>
			</constructor>
			<constructor sig="([C)V" modifiers="public">
				<parameter name="value" />
                <alternateBody>
					<!-- force a NullPointerException if the array is null -->
					<ldarg_0 />
					<ldlen />
					<pop />
					<ldarg_0 />
					<newobj type="System.String" name=".ctor" sig="([C)V" />
					<ret />
				</alternateBody>
			</constructor>
			<constructor sig="([CII)V" modifiers="public">
				<parameter name="value" />
				<parameter name="offset" />
				<parameter name="count" />
			</constructor>
			<!-- Package private constructor, that we redirect to static helper -->
			<constructor sig="([CIIZ)V" modifiers="">
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([CIIZ)Ljava.lang.String;" />
			</constructor>
			<constructor sig="(Ljava.lang.String;)V" modifiers="public">
				<parameter name="original" />
				<redirect class="System.String, mscorlib" name="Copy" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="(Ljava.lang.StringBuffer;)V" modifiers="public">
				<parameter name="buffer" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="(Ljava.lang.StringBuffer;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="(Ljava.lang.StringBuilder;)V" modifiers="public">
				<parameter name="builder" />
				<alternateBody>
					<ldarg_0 />
					<ldfld class="java.lang.StringBuilder" name="value" sig="[C" />
					<ldc_i4_0 />
					<ldarg_0 />
					<ldfld class="java.lang.StringBuilder" name="count" sig="I" />
					<newobj type="System.String" name=".ctor" sig="([CII)V" />
					<ret />
				</alternateBody>
			</constructor>
			<constructor sig="([B)V" modifiers="public">
				<parameter name="bytes" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([B)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BI)V" modifiers="public">
				<parameter name="ascii" />
				<parameter name="hibyte" />
				<attribute type="System.ObsoleteAttribute" sig="()V" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BI)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BII)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="offset" />
				<parameter name="length" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BII)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BIII)V" modifiers="public">
				<parameter name="ascii" />
				<parameter name="hibyte" />
				<parameter name="offset" />
				<parameter name="count" />
				<attribute type="System.ObsoleteAttribute" sig="()V" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIII)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BLjava.lang.String;)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="charsetName" />
				<throws class="java.io.UnsupportedEncodingException" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BLjava.lang.String;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BIILjava.lang.String;)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="offset" />
				<parameter name="length" />
				<parameter name="charsetName" />
				<throws class="java.io.UnsupportedEncodingException" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([BIILjava.lang.String;)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([III)V" modifiers="public">
				<parameter name="codePoints" />
				<parameter name="offset" />
				<parameter name="count" />
				<redirect class="java.lang.StringHelper" name="NewString" type="static" sig="([III)Ljava.lang.String;" />
			</constructor>
			<constructor sig="([BIILjava.nio.charset.Charset;)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="offset" />
				<parameter name="length" />
				<parameter name="charset" />
				<alternateBody>
					<ldarg_3 />
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<call class="java.nio.ByteBuffer" name="wrap" sig="([BII)Ljava.nio.ByteBuffer;" />
					<callvirt class="java.nio.charset.Charset" name="decode" sig="(Ljava.nio.ByteBuffer;)Ljava.nio.CharBuffer;" />
					<callvirt class="java.nio.CharBuffer" name="toString" sig="()Ljava.lang.String;" />
					<ret />
				</alternateBody>
			</constructor>
			<constructor sig="([BLjava.nio.charset.Charset;)V" modifiers="public">
				<parameter name="bytes" />
				<parameter name="charset" />
				<alternateBody>
					<ldarg_1 />
					<ldarg_0 />
					<call class="java.nio.ByteBuffer" name="wrap" sig="([B)Ljava.nio.ByteBuffer;" />
					<callvirt class="java.nio.charset.Charset" name="decode" sig="(Ljava.nio.ByteBuffer;)Ljava.nio.CharBuffer;" />
					<callvirt class="java.nio.CharBuffer" name="toString" sig="()Ljava.lang.String;" />
					<ret />
				</alternateBody>
			</constructor>
			<method name="hashCode" sig="()I" modifiers="public">
				<redirect class="java.lang.StringHelper" name="hashCode" type="static" sig="(Lcli.System.String;)I" />
			</method>
			<!-- we have a toString here to make sure that it shows up as a declared method in reflection -->
			<method name="toString" sig="()Ljava.lang.String;" modifiers="public" />
			<!-- we have an equals here to make sure that it shows up as a declared method in reflection -->
			<method name="equals" sig="(Ljava.lang.Object;)Z" modifiers="public">
				<parameter name="anObject" />
			</method>
			<method name="valueOf" sig="(Z)Ljava.lang.String;" modifiers="public static">
				<parameter name="b" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(I)Ljava.lang.String;" modifiers="public static">
				<parameter name="i" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(J)Ljava.lang.String;" modifiers="public static">
				<parameter name="l" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(C)Ljava.lang.String;" modifiers="public static">
				<parameter name="c" />
				<redirect class="java.lang.StringHelper" sig="(C)Lcli.System.String;" />
			</method>
			<method name="valueOf" sig="(F)Ljava.lang.String;" modifiers="public static">
				<parameter name="f" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(D)Ljava.lang.String;" modifiers="public static">
				<parameter name="d" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="([C)Ljava.lang.String;" modifiers="public static">
				<parameter name="data" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="([CII)Ljava.lang.String;" modifiers="public static">
				<parameter name="data" />
				<parameter name="offset" />
				<parameter name="count" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="valueOf" sig="(Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
				<parameter name="obj" />
				<redirect class="java.lang.StringHelper" />
			</method>
			<method name="substring" sig="(I)Ljava.lang.String;" modifiers="public">
				<parameter name="beginIndex" />
				<redirect name="Substring" />
			</method>
			<method name="length" sig="()I" modifiers="public">
				<redirect name="get_Length" />
			</method>
			<method name="charAt" sig="(I)C" modifiers="public" nonullcheck="true">
				<parameter name="index" />
				<body>
          <ldarg_1 />
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <bge_un name="throw" />
          <ldarg_0 />
				  <ldarg_1 />
				  <callvirt type="System.String" name="get_Chars" sig="(I)C" />
				  <ret />
          <label name="throw" />
					<newobj class="java.lang.StringIndexOutOfBoundsException" name="&lt;init&gt;" sig="()V" />
					<throw />
				</body>
			</method>
			<method name="substring" sig="(II)Ljava.lang.String;" modifiers="public">
				<parameter name="beginIndex" />
				<parameter name="endIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)Ljava.lang.String;" />
			</method>
			<method name="indexOf" sig="(I)I" modifiers="public">
				<parameter name="ch" />
				<body>
					<ldarg_1 />
					<ldc_i4 value="65535" />
					<ble_un name="ok" />
					<ldc_i4_m1 />
					<ret />
					<label name="ok" />
					<ldarg_0 />
					<ldarg_1 />
					<call type="System.String" name="IndexOf" sig="(C)I" />
					<ret />
				</body>
			</method>
			<method name="indexOf" sig="(II)I" modifiers="public" nonullcheck="true">
				<parameter name="ch" />
				<parameter name="fromIndex" />
        <body>
          <!--
    			for (int i = fromIndex < 0 ? 0 : fromIndex; i < s.Length; i++)
			    {
				    if (this[i] == ch)
				    {
					    return i;
				    }
			    }
			    return -1;
          -->
          <ldarg_2 />
          <stloc name="i" type="System.Int32" />
          <ldc_i4_0 />
          <ldloc name="i" />
          <blt name="start_loop" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <beq name="ret_i" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_m1 />
          <ret />
          <label name="ret_i" />
          <ldloc name="i" />
          <ret />
        </body>
			</method>
			<method name="indexOf" sig="(Ljava.lang.String;)I" modifiers="public">
				<parameter name="str" />
        <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
      </method>
			<method name="indexOf" sig="(Ljava.lang.String;I)I" modifiers="public">
				<parameter name="str" />
				<parameter name="fromIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
			</method>
			<method name="lastIndexOf" sig="(I)I" modifiers="public">
				<parameter name="ch" />
				<body>
					<ldarg_1 />
					<ldc_i4 value="65535" />
					<ble_un name="ok" />
					<ldc_i4_m1 />
					<ret />
					<label name="ok" />
					<ldarg_0 />
					<ldarg_1 />
					<call type="System.String" name="LastIndexOf" sig="(C)I" />
					<ret />
				</body>
			</method>
			<method name="lastIndexOf" sig="(II)I" modifiers="public">
				<parameter name="ch" />
				<parameter name="fromIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)I" />
			</method>
			<method name="lastIndexOf" sig="(Ljava.lang.String;)I" modifiers="public">
				<parameter name="str" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
			</method>
			<method name="lastIndexOf" sig="(Ljava.lang.String;I)I" modifiers="public">
				<parameter name="str" />
				<parameter name="fromIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
			</method>
			<method name="toCharArray" sig="()[C" modifiers="public">
				<redirect name="ToCharArray" />
			</method>
			<method name="getChars" sig="(II[CI)V" modifiers="public">
				<parameter name="srcBegin" />
				<parameter name="srcEnd" />
				<parameter name="dst" />
				<parameter name="dstBegin" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II[CI)V" />
			</method>
			<method name="startsWith" sig="(Ljava.lang.String;)Z" modifiers="public" nonullcheck="true">
				<parameter name="prefix" />
        <body>
          <!--
			    if (this.Length >= prefix.Length)
			    {
				    for (int i = 0; i < prefix.Length; i++)
				    {
					    if (this[i] != prefix[i])
					    {
						    return false;
					    }
				    }
				    return true;
			    }
			    return false;
          -->
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="ret_false" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <bne_un name="ret_false" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_1 />
          <ret />
          <label name="ret_false" />
          <ldc_i4_0 />
          <ret />
        </body>
      </method>
			<method name="startsWith" sig="(Ljava.lang.String;I)Z" modifiers="public" nonullcheck="true">
				<parameter name="prefix" />
				<parameter name="toffset" />
        <body>
          <!--
			    if (toffset >= 0
             && toffset <= this.Length
             && this.Length - toffset >= prefix.Length)
			    {
				    for (int i = 0; i < prefix.Length; i++)
				    {
					    if (this[i + toffset] != prefix[i])
					    {
						    return false;
					    }
				    }
				    return true;
			    }
			    return false;
          -->
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_2 />
          <blt_un name="ret_false" />
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_2 />
          <sub />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="ret_false" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="i" />
          <ldarg_2 />
          <add />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <bne_un name="ret_false" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_1 />
          <ret />
          <label name="ret_false" />
          <ldc_i4_0 />
          <ret />
        </body>
      </method>
			<method name="endsWith" sig="(Ljava.lang.String;)Z" modifiers="public" nonullcheck="true">
				<parameter name="suffix" />
        <body>
          <!--
			    int j = this.Length - suffix.Length;
			    if (j >= 0)
			    {
				    for (int i = 0; i < suffix.Length; i++)
				    {
					    if (this[j++] != suffix[i])
					    {
						    return false;
					    }
				    }
				    return true;
			    }
			    return false;
          -->
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <sub />
          <stloc name="j" type="System.Int32" />
          <ldloc name="j" />
          <ldc_i4_0 />
          <blt name="ret_false" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="j" />
          <dup />
          <ldc_i4_1 />
          <add />
          <stloc name="j" type="System.Int32" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <bne_un name="ret_false" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_1 />
          <ret />
          <label name="ret_false" />
          <ldc_i4_0 />
          <ret />
        </body>
      </method>
			<method name="toUpperCase" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="toUpperCase" sig="(Ljava.util.Locale;)Ljava.lang.String;" modifiers="public">
				<parameter name="locale" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.util.Locale;)Ljava.lang.String;" />
			</method>
			<method name="toLowerCase" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="toLowerCase" sig="(Ljava.util.Locale;)Ljava.lang.String;" modifiers="public">
				<parameter name="locale" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.util.Locale;)Ljava.lang.String;" />
			</method>
			<method name="compareToIgnoreCase" sig="(Ljava.lang.String;)I" modifiers="public">
				<parameter name="str" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
			</method>
			<method name="equalsIgnoreCase" sig="(Ljava.lang.String;)Z" modifiers="public">
				<parameter name="anotherString" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Z" />
			</method>
			<method name="intern" sig="()Ljava.lang.String;" modifiers="public">
				<redirect type="static" name="Intern" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="compareTo" sig="(Ljava.lang.String;)I" modifiers="public">
				<parameter name="anotherString" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
			</method>
			<method name="compareTo" sig="(Ljava.lang.Object;)I" modifiers="public">
				<parameter name="o" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<castclass type="System.String" />
					<call class="java.lang.StringHelper" name="compareTo" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
					<ret />
				</body>
			</method>
			<method name="replace" sig="(CC)Ljava.lang.String;" modifiers="public">
				<parameter name="oldChar" />
				<parameter name="newChar" />
				<redirect name="Replace" />
			</method>
			<method name="getBytes" sig="()[B" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)[B" />
			</method>
			<method name="getBytes" sig="(Ljava.lang.String;)[B" modifiers="public">
				<parameter name="charsetName" />
				<throws class="java.io.UnsupportedEncodingException" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)[B" />
			</method>
			<method name="subSequence" sig="(II)Ljava.lang.CharSequence;" modifiers="public">
				<parameter name="beginIndex" />
				<parameter name="endIndex" />
				<redirect class="java.lang.StringHelper" type="static" name="substring" sig="(Lcli.System.String;II)Ljava.lang.String;" />
			</method>
			<method name="trim" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="regionMatches" sig="(ZILjava.lang.String;II)Z" modifiers="public">
				<parameter name="ignoreCase" />
				<parameter name="toffset" />
				<parameter name="other" />
				<parameter name="ooffset" />
				<parameter name="len" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;ZILjava.lang.String;II)Z" />
			</method>
			<method name="regionMatches" sig="(ILjava.lang.String;II)Z" modifiers="public">
				<parameter name="toffset" />
				<parameter name="other" />
				<parameter name="ooffset" />
				<parameter name="len" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;ILjava.lang.String;II)Z" />
			</method>
			<method name="getBytes" sig="(II[BI)V" modifiers="public">
				<parameter name="srcBegin" />
				<parameter name="srcEnd" />
				<parameter name="dst" />
				<parameter name="dstBegin" />
				<attribute type="System.ObsoleteAttribute" sig="()V" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II[BI)V" />
			</method>
			<method name="concat" sig="(Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
				<parameter name="str" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" />
			</method>
			<method name="contains" sig="(Ljava.lang.CharSequence;)Z" modifiers="public">
				<parameter name="s" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
			</method>
			<method name="codePointAt" sig="(I)I" modifiers="public">
				<parameter name="index" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;I)I" />
			</method>
			<method name="codePointBefore" sig="(I)I" modifiers="public">
				<parameter name="index" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;I)I" />
			</method>
			<method name="codePointCount" sig="(II)I" modifiers="public">
				<parameter name="beginIndex" />
				<parameter name="endIndex" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II)I" />
			</method>
			<method name="offsetByCodePoints" sig="(II)I" modifiers="public">
				<parameter name="index" />
				<parameter name="codePointOffset" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II)I" />
			</method>
			<method name="contentEquals" sig="(Ljava.lang.CharSequence;)Z" modifiers="public">
				<parameter name="cs" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
			</method>
			<method name="contentEquals" sig="(Ljava.lang.StringBuffer;)Z" modifiers="public">
				<parameter name="sb" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<callvirt class="java.lang.StringBuffer" name="toString" sig="()Ljava.lang.String;" />
					<callvirt type="System.String" name="Equals" sig="(Ljava.lang.String;)Z" />
					<ret />
				</body>
			</method>
			<method name="replace" sig="(Ljava.lang.CharSequence;Ljava.lang.CharSequence;)Ljava.lang.String;" modifiers="public">
				<parameter name="target" />
				<parameter name="replacement" />
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.CharSequence;Ljava.lang.CharSequence;)Ljava.lang.String;" />
			</method>
			<method name="matches" sig="(Ljava.lang.String;)Z" modifiers="public">
				<parameter name="regex" />
				<body>
					<ldarg_1 />
					<ldarg_0 />
					<call class="java.util.regex.Pattern" name="matches" sig="(Ljava.lang.String;Ljava.lang.CharSequence;)Z" />
					<ret />
				</body>
			</method>
			<method name="replaceAll" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
				<parameter name="regex" />
				<parameter name="replacement" />
				<body>
					<ldarg_1 />
					<call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
					<ldarg_0 />
					<callvirt class="java.util.regex.Pattern" name="matcher" sig="(Ljava.lang.CharSequence;)Ljava.util.regex.Matcher;" />
					<ldarg_2 />
					<callvirt class="java.util.regex.Matcher" name="replaceAll" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="replaceFirst" sig="(Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" modifiers="public">
				<parameter name="regex" />
				<parameter name="replacement" />
				<body>
					<ldarg_1 />
					<call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
					<ldarg_0 />
					<callvirt class="java.util.regex.Pattern" name="matcher" sig="(Ljava.lang.CharSequence;)Ljava.util.regex.Matcher;" />
					<ldarg_2 />
					<callvirt class="java.util.regex.Matcher" name="replaceFirst" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="split" sig="(Ljava.lang.String;)[Ljava.lang.String;" modifiers="public">
				<parameter name="regex" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldc_i4_0 />
					<callvirt class="java.lang.String" name="split" sig="(Ljava.lang.String;I)[Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="split" sig="(Ljava.lang.String;I)[Ljava.lang.String;" modifiers="public">
				<parameter name="regex" />
				<parameter name="limit" />
				<body>
					<ldarg_1 />
					<call class="java.util.regex.Pattern" name="compile" sig="(Ljava.lang.String;)Ljava.util.regex.Pattern;" />
					<ldarg_0 />
					<ldarg_2 />
					<callvirt class="java.util.regex.Pattern" name="split" sig="(Ljava.lang.CharSequence;I)[Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="copyValueOf" sig="([C)Ljava.lang.String;" modifiers="public static">
				<parameter name="data" />
				<body>
					<!-- force a NullPointerException if the array is null -->
					<ldarg_0 />
					<ldlen />
					<pop />
					<ldarg_0 />
					<newobj type="System.String" name=".ctor" sig="([C)V" />
					<ret />
				</body>
			</method>
			<method name="copyValueOf" sig="([CII)Ljava.lang.String;" modifiers="public static">
				<parameter name="data" />
				<parameter name="offset" />
				<parameter name="count" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<newobj type="System.String" name=".ctor" sig="([CII)V" />
					<ret />
				</body>
			</method>
			<method name="format" sig="(Ljava.lang.String;[Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
				<parameter name="format" />
				<parameter name="args">
					<attribute type="System.ParamArrayAttribute" sig="()V" />
				</parameter>
				<body>
					<newobj class="java.util.Formatter" name="&lt;init&gt;" sig="()V" />
					<ldarg_0 />
					<ldarg_1 />
					<callvirt class="java.util.Formatter" name="format" sig="(Ljava.lang.String;[Ljava.lang.Object;)Ljava.util.Formatter;" />
					<callvirt class="java.util.Formatter" name="toString" sig="()Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="format" sig="(Ljava.util.Locale;Ljava.lang.String;[Ljava.lang.Object;)Ljava.lang.String;" modifiers="public static">
				<parameter name="l" />
				<parameter name="format" />
				<parameter name="args">
					<attribute type="System.ParamArrayAttribute" sig="()V" />
				</parameter>
				<body>
					<ldarg_0 />
					<newobj class="java.util.Formatter" name="&lt;init&gt;" sig="(Ljava.util.Locale;)V" />
					<ldarg_1 />
					<ldarg_2 />
					<callvirt class="java.util.Formatter" name="format" sig="(Ljava.lang.String;[Ljava.lang.Object;)Ljava.util.Formatter;" />
					<callvirt class="java.util.Formatter" name="toString" sig="()Ljava.lang.String;" />
					<ret />
				</body>
			</method>
			<method name="isEmpty" sig="()Z" modifiers="public">
				<body>
					<ldarg_0 />
					<callvirt type="System.String" name="get_Length" sig="()I" />
					<ldc_i4_0 />
					<ceq />
					<ret />
				</body>
			</method>
			<method name="getBytes" sig="(Ljava.nio.charset.Charset;)[B" modifiers="public">
				<parameter name="charset" />
				<body>
					<ldarg_1 />
					<ldarg_0 />
					<callvirt class="java.nio.charset.Charset" name="encode" sig="(Ljava.lang.String;)Ljava.nio.ByteBuffer;" />
					<callvirt class="java.nio.ByteBuffer" name="array" sig="()[B" />
					<ret />
				</body>
			</method>
			<field name="CASE_INSENSITIVE_ORDER" sig="Ljava.util.Comparator;" modifiers="public static final">
				<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
					<parameter>Ljava/util/Comparator&lt;Ljava/lang/String;&gt;;</parameter>
				</attribute>
			</field>
			<!-- NOTE we're redirecting fields to static methods here!
				NOTE only reading fields can be redirected
			-->
			<field name="count" sig="I" modifiers="">
				<redirect class="java.lang.StringHelper" type="static" name="GetCountField" sig="(Lcli.System.String;)I" />
			</field>
			<!-- Making a new char array instead of directly accessing the contents of the string, probably isn't
				as efficient as the coder of this construct wished for, but hey ;-) At least it works...
			-->
			<method name="zeroBasedStringValue" sig="(Ljava.lang.String;)[C" modifiers="static">
				<body>
					<ldarg_0 />
					<call type="System.String" name="ToCharArray" sig="()[C" />
					<ret />
				</body>
			</method>
			<!-- NOTE value and offset aren't used anymore in Classpath's StringBuffer, so we should drop them -->
			<field name="value" sig="[C" modifiers="">
				<redirect class="java.lang.StringHelper" type="static" name="GetValueField" sig="(Lcli.System.String;)[C" />
			</field>
			<field name="offset" sig="I" modifiers="">
				<redirect class="java.lang.StringHelper" type="static" name="GetOffsetField" sig="(Lcli.System.String;)I" />
			</field>
			<!-- TODO mark this method as BeforeFieldInit (and benchmark to see if that is faster) -->
			<clinit>
				<body>
					<newobj class="java.lang.String$CaseInsensitiveComparator" name="&lt;init&gt;" sig="()V" />
					<stsfld class="java.lang.String" name="CASE_INSENSITIVE_ORDER" sig="Ljava.util.Comparator;" />
					<ret />
				</body>
			</clinit>
		</class>
		<class name="java.lang.Throwable" shadows="System.Exception" modifiers="public">
			<implements class="java.io.Serializable" />
			<field name="serialVersionUID" sig="J" modifiers="private static final" constant="-3042686055658047285" />
			<field name="serialPersistentFields" sig="[Ljava.io.ObjectStreamField;" modifiers="private static final" />
			<field name="suppressFillInStackTrace" sig="Z" modifiers="private static">
				<attribute type="System.ThreadStaticAttribute" sig="()V" />
			</field>
			<clinit>
				<body>
					<call class="java.lang.ExceptionHelper" name="getPersistentFields" sig="()[Ljava.io.ObjectStreamField;" />
					<stsfld class="java.lang.Throwable" name="serialPersistentFields" sig="[Ljava.io.ObjectStreamField;" />
					<ret />
				</body>
			</clinit>
			<method name="__&lt;suppressFillInStackTrace&gt;" sig="()V" modifiers="public static">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
					<parameter>Never</parameter>
				</attribute>
				<body>
					<ldc_i4_1 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ret />
				</body>
			</method>
			<method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" modifiers="public static">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
					<parameter>Never</parameter>
				</attribute>
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="MapExceptionFast" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" />
					<ret />
				</body>
			</method>
			<method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;" modifiers="public static">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
					<parameter>Never</parameter>
				</attribute>
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<call class="java.lang.ExceptionHelper" name="MapException" sig="(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;" />
					<ret />
				</body>
			</method>
			<method name="__&lt;unmap&gt;" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public static">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<attribute type="System.ComponentModel.EditorBrowsableAttribute" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
					<parameter>Never</parameter>
				</attribute>
				<body>
					<ldarg_0 />
					<call class="java.lang.ExceptionHelper" name="UnmapException" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
					<ret />
				</body>
			</method>
			<method name="readObject" sig="(Ljava.io.ObjectInputStream;)V" modifiers="private">
				<throws class="java.io.IOException" />
				<throws class="java.lang.ClassNotFoundException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="readObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectInputStream;)V" />
					<ret />
				</body>
			</method>
			<method name="writeObject" sig="(Ljava.io.ObjectOutputStream;)V" modifiers="private">
				<throws class="java.io.IOException" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="writeObject" sig="(Ljava.lang.Throwable;Ljava.io.ObjectOutputStream;)V" />
					<ret />
				</body>
			</method>
			<constructor sig="()V" modifiers="public">
				<body>
					<ldarg_0 />
					<call class="java.lang.ExceptionHelper" name="get_NullString" sig="()Ljava.lang.String;" />
					<call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;)V" />
					<!-- Start fillInStackTrace call -->
					<ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ldc_i4_0 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<brtrue name="skipFillInStackTrace" />
					<ldarg_0 />
					<callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
					<pop />
					<label name="skipFillInStackTrace" />
					<!-- End fillInStackTrace call -->
					<ret />
				</body>
			</constructor>
			<constructor sig="(Ljava.lang.String;)V" modifiers="public">
				<parameter name="message" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;)V" />
					<!-- Start fillInStackTrace call -->
					<ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ldc_i4_0 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<brtrue name="skipFillInStackTrace" />
					<ldarg_0 />
					<callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
					<pop />
					<label name="skipFillInStackTrace" />
					<!-- End fillInStackTrace call -->
					<ret />
				</body>
			</constructor>
			<constructor sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" modifiers="public">
				<parameter name="message" />
				<parameter name="cause" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="FilterMessage" sig="(Ljava.lang.String;)Ljava.lang.String;" />
					<ldarg_2 />
					<call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
					<!-- Start fillInStackTrace call -->
					<ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ldc_i4_0 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<brtrue name="skipFillInStackTrace" />
					<ldarg_0 />
					<callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
					<pop />
					<label name="skipFillInStackTrace" />
					<!-- End fillInStackTrace call -->
					<ldarg_2 />
					<brtrue name="skip" />
					<ldarg_0 />
					<ldarg_2 />
					<call class="java.lang.ExceptionHelper" name="initCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
					<pop />
					<label name="skip" />
					<ret />
				</body>
			</constructor>
			<constructor sig="(Ljava.lang.Throwable;)V" modifiers="public">
				<parameter name="cause" />
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="GetMessageFromCause" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" />
					<ldarg_1 />
					<call type="System.Exception" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
					<!-- Start fillInStackTrace call -->
					<ldsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<ldc_i4_0 />
					<stsfld class="java.lang.Throwable" name="suppressFillInStackTrace" sig="Z" />
					<brtrue name="skipFillInStackTrace" />
					<ldarg_0 />
					<callvirt class="java.lang.Throwable" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" />
					<pop />
					<label name="skipFillInStackTrace" />
					<!-- End fillInStackTrace call -->
					<ldarg_1 />
					<brtrue name="skip" />
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.ExceptionHelper" name="initCause" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
					<pop />
					<label name="skip" />
					<ret />
				</body>
			</constructor>
			<method type="virtual" name="printStackTrace" sig="()V" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)V" type="static" />
			</method>
			<method type="virtual" name="printStackTrace" sig="(Ljava.io.PrintStream;)V" modifiers="public">
				<parameter name="s" />
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintStream;)V" type="static" />
			</method>
			<method type="virtual" name="printStackTrace" sig="(Ljava.io.PrintWriter;)V" modifiers="public">
				<parameter name="s" />
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.io.PrintWriter;)V" type="static" />
			</method>
			<method type="virtual" name="getMessage" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
			</method>
			<method type="virtual" name="getLocalizedMessage" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
			</method>
			<method type="virtual" name="fillInStackTrace" sig="()Ljava.lang.Throwable;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
			</method>
			<method type="virtual" name="initCause" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public">
				<parameter name="cause" />
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
			</method>
			<method type="virtual" name="getCause" sig="()Ljava.lang.Throwable;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" type="static" />
			</method>
			<method type="virtual" name="getStackTrace" sig="()[Ljava.lang.StackTraceElement;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)[Ljava.lang.StackTraceElement;" type="static" />
			</method>
			<method type="virtual" name="setStackTrace" sig="([Ljava.lang.StackTraceElement;)V" modifiers="public">
				<parameter name="stackTrace" />
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;[Ljava.lang.StackTraceElement;)V" type="static" />
			</method>
			<method type="virtual" name="toString" sig="()Ljava.lang.String;" modifiers="public">
				<redirect class="java.lang.ExceptionHelper" sig="(Ljava.lang.Throwable;)Ljava.lang.String;" type="static" />
			</method>
		</class>
		<class name="java.lang.Comparable" shadows="System.IComparable" modifiers="public abstract interface">
			<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
				<parameter>&lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</parameter>
			</attribute>
			<method name="compareTo" sig="(Ljava.lang.Object;)I" modifiers="public abstract">
				<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
					<parameter>(TT;)I</parameter>
				</attribute>
				<parameter name="o" />
				<override name="CompareTo" />
			</method>
		</class>
		<!-- Here we are adding methods to existing classes -->
		<class name="java.lang.Class">
			<method name="op_Implicit" sig="(Lcli.System.Type;)Ljava.lang.Class;" modifiers="public static" attributes="SpecialName">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
				<body>
					<ldarg_0 />
					<call class="ikvm.runtime.Util" name="getFriendlyClassFromType" sig="(Lcli.System.Type;)Ljava.lang.Class;" />
					<ret />
				</body>
			</method>
			<method name="newInstance" sig="()Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<ldc_i4_0 />
					<call class="java.lang.Class" name="memberAccessCheck" sig="(I)V" />
					<ldarg_0 />
					<volatile />
					<ldfld class="java.lang.Class" name="constructor" sig="Ljava.lang.reflect.Constructor;" />
					<dup />
					<brtrue name="ok" />
					<pop />
					<ldarg_0 />
					<ldarg_0 />
					<call class="java.lang.VMClass" name="getConstructor" sig="(Ljava.lang.Class;)Ljava.lang.reflect.Constructor;" />
					<dup />
					<stloc name="constructor" class="java.lang.reflect.Constructor" />
					<volatile />
					<stfld class="java.lang.Class" name="constructor" sig="Ljava.lang.reflect.Constructor;" />
					<ldloc name="constructor" />
					<label name="ok" />
					<dup />
					<stloc name="constructor" class="java.lang.reflect.Constructor" />
					<call class="java.lang.VMClass" name="isPublic" sig="(Ljava.lang.reflect.Constructor;)Z" />
					<brtrue name="doit" />
					<ldloc name="constructor" />
					<call class="gnu.classpath.VMStackWalker" name="getCallingClass" sig="()Ljava.lang.Class;" />
					<call class="java.lang.VMClass" name="checkAccess" sig="(Ljava.lang.reflect.Constructor;Ljava.lang.Class;)V" />
					<label name="doit" />
					<exceptionBlock>
						<try>
							<ldloc name="constructor" />
							<ldnull />
							<callvirt class="java.lang.reflect.Constructor" name="newInstance" sig="([Ljava.lang.Object;)Ljava.lang.Object;" />
							<stloc name="retval" class="java.lang.Object" />
						</try>
						<catch class="java.lang.reflect.InvocationTargetException">
							<callvirt class="java.lang.reflect.InvocationTargetException" name="getTargetException" sig="()Ljava.lang.Throwable;" />
							<throw />
						</catch>
					</exceptionBlock>
					<ldloc name="retval" />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.math.BigInteger">
			<!-- HACK we don't need BigInteger$NativeMPI (and it includes native methods that we don't have)
			so the build script excludes this class, this results in a field in BigInteger of a missing class,
			ikvmstub would barf on this. This needs to be fixed, but for the time being we'll just hide the
			field -->
			<field name="mpz" sig="Ljava.math.BigInteger$NativeMPI;">
				<attribute type="IKVM.Attributes.HideFromJavaAttribute" sig="()V" />
			</field>
		</class>
		<class name="ikvm.internal.EnumEnum">
			<field name="typeWrapper" sig="Ljava.lang.Object;" modifiers="private" />
		</class>
		<!-- This is where the "native" helper methods start -->
		<class name="ikvm.lang.CIL">
			<method name="unbox_byte" sig="(Ljava.lang.Object;)B">
				<body>
					<ldarg_0 />
					<unbox type="System.Byte" />
					<ldind_i1 />
					<ret />
				</body>
			</method>
			<method name="unbox_boolean" sig="(Ljava.lang.Object;)Z">
				<body>
					<ldarg_0 />
					<unbox type="System.Boolean" />
					<ldind_i1 />
					<ret />
				</body>
			</method>
			<method name="unbox_short" sig="(Ljava.lang.Object;)S">
				<body>
					<ldarg_0 />
					<unbox type="System.Int16" />
					<ldind_i2 />
					<ret />
				</body>
			</method>
			<method name="unbox_char" sig="(Ljava.lang.Object;)C">
				<body>
					<ldarg_0 />
					<unbox type="System.Char" />
					<ldind_i2 />
					<ret />
				</body>
			</method>
			<method name="unbox_int" sig="(Ljava.lang.Object;)I">
				<body>
					<ldarg_0 />
					<unbox type="System.Int32" />
					<ldind_i4 />
					<ret />
				</body>
			</method>
			<method name="unbox_float" sig="(Ljava.lang.Object;)F">
				<body>
					<ldarg_0 />
					<unbox type="System.Single" />
					<ldind_r4 />
					<ret />
				</body>
			</method>
			<method name="unbox_long" sig="(Ljava.lang.Object;)J">
				<body>
					<ldarg_0 />
					<unbox type="System.Int64" />
					<ldind_i8 />
					<ret />
				</body>
			</method>
			<method name="unbox_double" sig="(Ljava.lang.Object;)D">
				<body>
					<ldarg_0 />
					<unbox type="System.Double" />
					<ldind_r8 />
					<ret />
				</body>
			</method>
			<method name="box_byte" sig="(B)Lcli.System.Byte;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_boolean" sig="(Z)Lcli.System.Boolean;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_short" sig="(S)Lcli.System.Int16;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_char" sig="(C)Lcli.System.Char;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_int" sig="(I)Lcli.System.Int32;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_float" sig="(F)Lcli.System.Single;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_long" sig="(J)Lcli.System.Int64;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_double" sig="(D)Lcli.System.Double;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_sbyte" sig="(B)Lcli.System.SByte;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_ushort" sig="(S)Lcli.System.UInt16;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_uint" sig="(I)Lcli.System.UInt32;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="box_ulong" sig="(J)Lcli.System.UInt64;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_sbyte" sig="(Lcli.System.SByte;)B">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_ushort" sig="(Lcli.System.UInt16;)S">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_uint" sig="(Lcli.System.UInt32;)I">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="unbox_ulong" sig="(Lcli.System.UInt64;)J">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.lang.VMSystem">
			<method name="identityHashCode" sig="(Ljava.lang.Object;)I">
				<body>
					<ldarg_0 />
					<conditional framework="2.0">
						<code>
							<call type="System.Runtime.CompilerServices.RuntimeHelpers" name="GetHashCode" sig="(Ljava.lang.Object;)I" />
						</code>
					</conditional>
					<conditional framework="1.1">
						<code>
							<!-- FXBUG RuntimeHelpers.GetHashCode is broken in multi AppDomain scenarios (on v1.x) -->
							<call type="System.Object" name="GetHashCode" sig="()I" />
						</code>
					</conditional>
					<ret />
				</body>
			</method>
		</class>
		<class name="gnu.java.net.PlainDatagramSocketImpl">
			<method name="setDatagramPacketLength" sig="(Ljava.net.DatagramPacket;I)V">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<stfld class="java.net.DatagramPacket" name="length" sig="I" />
					<ret />
				</body>
			</method>
			<method name="getDatagramPacketBufferLength" sig="(Ljava.net.DatagramPacket;)I">
				<body>
					<ldarg_0 />
					<ldfld class="java.net.DatagramPacket" name="maxlen" sig="I" />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.nio.channels.VMChannels">
			<method name="newInputStream" sig="(Lgnu.java.nio.FileChannelImpl;)Ljava.io.FileInputStream;">
				<body>
					<ldarg_0 />
					<newobj class="java.io.FileInputStream" name="&lt;init&gt;" sig="(Lgnu.java.nio.FileChannelImpl;)V" />
					<ret />
				</body>
			</method>
			<method name="newOutputStream" sig="(Lgnu.java.nio.FileChannelImpl;)Ljava.io.FileOutputStream;">
				<body>
					<ldarg_0 />
					<newobj class="java.io.FileOutputStream" name="&lt;init&gt;" sig="(Lgnu.java.nio.FileChannelImpl;)V" />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.util.concurrent.atomic.AtomicReference">
			<method name="compareAndSet" sig="(Ljava.lang.Object;Ljava.lang.Object;)Z">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicReference" name="value" sig="Ljava.lang.Object;" />
					<ldarg_2 />
					<ldarg_1 />
					<call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Object&amp;;System.Object;System.Object" />
					<ldarg_1 />
					<ceq />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.util.concurrent.atomic.AtomicReferenceArray">
			<method name="get" sig="(I)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
					<ldarg_1 />
					<ldelema sig="Ljava.lang.Object;" />
					<volatile />
					<ldind_ref />
					<ret />
				</body>
			</method>
			<method name="set" sig="(ILjava.lang.Object;)V">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
					<ldarg_1 />
					<ldelema sig="Ljava.lang.Object;" />
					<ldarg_2 />
					<volatile />
					<stind_ref />
					<ret />
				</body>
			</method>
			<method name="compareAndSet" sig="(ILjava.lang.Object;Ljava.lang.Object;)Z">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicReferenceArray" name="array" sig="[Ljava.lang.Object;" />
					<ldarg_1 />
					<ldelema sig="Ljava.lang.Object;" />
					<ldarg_3 />
					<ldarg_2 />
					<call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Object&amp;;System.Object;System.Object" />
					<ldarg_2 />
					<ceq />
					<ret />
				</body>
			</method>
		</class>
    <class name="java.util.concurrent.atomic.AtomicBoolean">
      <method name="compareAndSwapInt" sig="(II)Z">
        <body>
          <ldarg_0 />
          <ldflda class="java.util.concurrent.atomic.AtomicBoolean" name="value" sig="I" />
          <ldarg_2 />
          <ldarg_1 />
          <call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
          <ldarg_1 />
          <ceq />
          <ret />
        </body>
      </method>
    </class>
    <class name="java.util.concurrent.atomic.AtomicInteger">
			<method name="getAndSet" sig="(I)I">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
					<ldarg_1 />
					<call type="System.Threading.Interlocked" name="Exchange" sig="System.Int32&amp;;System.Int32" />
					<ret />					
				</body>
			</method>
			<method name="compareAndSet" sig="(II)Z">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
					<ldarg_2 />
					<ldarg_1 />
					<call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
					<ldarg_1 />
					<ceq />
					<ret />
				</body>
			</method>
			<method name="incrementAndGet" sig="()I">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
					<call type="System.Threading.Interlocked" name="Increment" sig="System.Int32&amp;" />
					<ret />					
				</body>
			</method>
			<method name="decrementAndGet" sig="()I">
				<body>
					<ldarg_0 />
					<ldflda class="java.util.concurrent.atomic.AtomicInteger" name="value" sig="I" />
					<call type="System.Threading.Interlocked" name="Decrement" sig="System.Int32&amp;" />
					<ret />					
				</body>
			</method>
		</class>
		<class name="java.util.concurrent.atomic.AtomicIntegerArray">
			<method name="get" sig="(I)I">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
					<ldarg_1 />
					<ldelema sig="I" />
					<volatile />
					<ldind_i4 />
					<ret />
				</body>
			</method>
			<method name="set" sig="(II)V">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
					<ldarg_1 />
					<ldelema sig="I" />
					<ldarg_2 />
					<volatile />
					<stind_i4 />
					<ret />
				</body>
			</method>
			<method name="compareAndSet" sig="(III)Z">
				<body>
					<ldarg_0 />
					<ldfld class="java.util.concurrent.atomic.AtomicIntegerArray" name="array" sig="[I" />
					<ldarg_1 />
					<ldelema sig="I" />
					<ldarg_3 />
					<ldarg_2 />
					<call type="System.Threading.Interlocked" name="CompareExchange" sig="System.Int32&amp;;System.Int32;System.Int32" />
					<ldarg_2 />
					<ceq />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.util.concurrent.atomic.AtomicLong">
			<method name="VMSupportsCS8" sig="()Z">
				<body>
					<ldc_i4_0 />
					<ret />
				</body>
			</method>
		</class>
		<class name="java.lang.Byte">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Byte;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Short">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Short;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Integer">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Integer;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Long">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Long;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Float">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Float;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
		<class name="java.lang.Double">
			<implements class="cli.System.IFormattable">
				<method name="ToString" sig="(Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;">
					<redirect class="ikvm.internal.Formatter" type="static" name="ToString" sig="(Ljava.lang.Double;Ljava.lang.String;Lcli.System.IFormatProvider;)Ljava.lang.String;" />
				</method>
			</implements>
		</class>
    <class name="java.lang.Runtime">
      <method name="addShutdownHook" sig="(Ljava.lang.Thread;)V">
        <attribute type="System.Security.Permissions.SecurityPermissionAttribute" sig="(Lcli.System.Security.Permissions.SecurityAction;)V">
          <parameter>LinkDemand</parameter>
          <property name="ControlAppDomain" sig="Z">true</property>
        </attribute>
      </method>
    </class>
	</assembly>
	<exceptionMappings>
		<exception src="System.NullReferenceException" dst="java.lang.NullPointerException" />
		<!-- many of the String and Object methods throw ArgumentNullException where Java throws an NPE -->
		<exception src="System.ArgumentNullException" dst="java.lang.NullPointerException" />
		<exception src="System.IndexOutOfRangeException" dst="java.lang.ArrayIndexOutOfBoundsException" />
		<!-- HACK for String methods, we remap ArgumentOutOfRangeException to StringIndexOutOfBoundsException -->
		<exception src="System.ArgumentOutOfRangeException" dst="java.lang.StringIndexOutOfBoundsException" />
		<exception src="System.InvalidCastException" dst="java.lang.ClassCastException" />
		<!-- NOTE we "map" to java.lang.Error, because that is the base class of all possible mappings.
			The * in front of the class name means that all subclasses can be thrown as well.
		 -->
		<exception src="System.TypeInitializationException" dst="*java.lang.Error">
			<code>
				<!-- this code is unreachable, TypeInitializationException is handled explicitly in ExceptionHelper.java -->
			</code>
		</exception>
		<exception src="System.Threading.SynchronizationLockException" dst="java.lang.IllegalMonitorStateException" />
		<exception src="System.OutOfMemoryException" dst="java.lang.OutOfMemoryError" />
		<exception src="System.DivideByZeroException" dst="java.lang.ArithmeticException">
			<code>
				<pop />
				<ldstr value="/ by zero" />
				<newobj class="java.lang.ArithmeticException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
			</code>
		</exception>
		<exception src="System.ArrayTypeMismatchException" dst="java.lang.ArrayStoreException" />
		<exception src="System.StackOverflowException" dst="java.lang.StackOverflowError" />
		<exception src="System.Security.VerificationException" dst="java.lang.VerifyError" />
		<exception src="System.Threading.ThreadAbortException" dst="java.lang.ThreadDeath">
			<code>
				<castclass type="System.Threading.ThreadAbortException" />
				<call type="System.Threading.ThreadAbortException" name="get_ExceptionState" sig="()Ljava.lang.Object;" />
				<isinst class="java.lang.ThreadDeath" />
				<dup />
				<brtrue name="end" />
				<pop />
				<newobj class="java.lang.ThreadDeath" name="&lt;init&gt;" sig="()V" />
				<label name="end" />
				<!-- NOTE we do this last because ResetAbort clears the ExceptionState of the ThreadAbortException (why?) -->
				<!-- TODO we should put an exception handler around the ResetAbort call, because it will throw a ThreadStateException
				     if no Abort is pending (someone could have thrown the exception manually, or we could have called on a 
				     previous handler that turned out not to be match for this exception type) -->
				<stloc name="x" class="java.lang.ThreadDeath" />
				<exceptionBlock>
					<try>
						<!-- TODO instead of catching the ThreadStateException, we should check the ThreadState
						     before calling ResetAbort -->
						<call type="System.Threading.Thread" name="ResetAbort" sig="()V" />
					</try>
					<catch type="System.Threading.ThreadStateException">
						<!-- ignore the exception -->
					</catch>
				</exceptionBlock>
				<ldloc name="x" />
			</code>
		</exception>
		<!-- TODO make sure the originating method was from an IKVM.NET generated assembly, because if it was
	    generated by non-Java code, this remapping is obviously bogus. -->
		<exception src="System.OverflowException" dst="java.lang.NegativeArraySizeException" />
	</exceptionMappings>
</root>
@


1.62
log
@Added "native" method that I introduced in AtomicBoolean.
@
text
@@


1.61
log
@Removed generics signature that is no longer needed since the Classpath generics branch merge.
@
text
@d1567 15
a1581 1
		<class name="java.util.concurrent.atomic.AtomicInteger">
@


1.60
log
@Optimized various String methods.
@
text
@a1233 3
			<attribute type="IKVM.Attributes.SignatureAttribute" sig="(Ljava.lang.String;)V">
				<parameter>&lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/reflect/Type;Ljava/lang/reflect/AnnotatedElement;Ljava/lang/reflect/GenericDeclaration;</parameter>
			</attribute>
@


1.59
log
@Fixed various String methods (indexOf, lastIndexOf, startsWith, endsWith, contains, replace) to use ordinal semantics instead of culture dependent word matching. Thanks to Louis Boydstun for tracking this bug down.
@
text
@d417 1
a417 1
			<method name="charAt" sig="(I)C" modifiers="public">
d420 11
a430 15
					<exceptionBlock>
						<try>
							<ldarg_0 />
							<ldarg_1 />
							<callvirt type="System.String" name="get_Chars" sig="(I)C" />
							<stloc name="char" type="System.Char" />
						</try>
						<catch type="System.IndexOutOfRangeException">
							<pop />
							<newobj class="java.lang.StringIndexOutOfBoundsException" name="&lt;init&gt;" sig="()V" />
							<throw />
						</catch>
					</exceptionBlock>
					<ldloc name="char" />
					<ret />
d453 1
a453 1
			<method name="indexOf" sig="(II)I" modifiers="public">
d456 40
a495 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;II)I" />
d545 1
a545 1
			<method name="startsWith" sig="(Ljava.lang.String;)Z" modifiers="public">
d547 46
a592 1
        <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Z" />
d594 1
a594 1
			<method name="startsWith" sig="(Ljava.lang.String;I)Z" modifiers="public">
d597 58
a654 3
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)Z" />
			</method>
			<method name="endsWith" sig="(Ljava.lang.String;)Z" modifiers="public">
d656 55
a710 1
        <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)Z" />
@


1.58
log
@As pointed out by FxCopy: Runtime.addShutdownHook() indirectly exposes the AppDomain.ProcessExit event, which has a LinkDemand, so we're adding the LinkDemand to addShutdownHook.
@
text
@d464 2
a465 2
				<redirect name="IndexOf" />
			</method>
d469 1
a469 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;Ljava.lang.String;I)I" />
d493 1
a493 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;Ljava.lang.String;)I" />
d498 1
a498 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;Ljava.lang.String;I)I" />
d512 2
a513 2
				<redirect name="StartsWith" />
			</method>
d517 1
a517 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;Ljava.lang.String;I)Z" />
d521 2
a522 2
				<redirect name="EndsWith" />
			</method>
@


1.58.2.1
log
@Preparing for release.
@
text
@d1101 9
@


1.58.2.2
log
@Backported:
- String fixes and optimizations.
- Thread death deadlock
@
text
@d417 1
a417 1
			<method name="charAt" sig="(I)C" modifiers="public" nonullcheck="true">
d420 15
a434 11
          <ldarg_1 />
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <bge_un name="throw" />
          <ldarg_0 />
				  <ldarg_1 />
				  <callvirt type="System.String" name="get_Chars" sig="(I)C" />
				  <ret />
          <label name="throw" />
					<newobj class="java.lang.StringIndexOutOfBoundsException" name="&lt;init&gt;" sig="()V" />
					<throw />
d457 1
a457 1
			<method name="indexOf" sig="(II)I" modifiers="public" nonullcheck="true">
d460 1
a460 40
        <body>
          <!--
    			for (int i = fromIndex < 0 ? 0 : fromIndex; i < s.Length; i++)
			    {
				    if (this[i] == ch)
				    {
					    return i;
				    }
			    }
			    return -1;
          -->
          <ldarg_2 />
          <stloc name="i" type="System.Int32" />
          <ldc_i4_0 />
          <ldloc name="i" />
          <blt name="start_loop" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <beq name="ret_i" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_m1 />
          <ret />
          <label name="ret_i" />
          <ldloc name="i" />
          <ret />
        </body>
d464 2
a465 2
        <redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
      </method>
d469 1
a469 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
d493 1
a493 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
d498 1
a498 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
d510 1
a510 1
			<method name="startsWith" sig="(Ljava.lang.String;)Z" modifiers="public" nonullcheck="true">
d512 3
a514 48
        <body>
          <!--
			    if (this.Length >= prefix.Length)
			    {
				    for (int i = 0; i < prefix.Length; i++)
				    {
					    if (this[i] != prefix[i])
					    {
						    return false;
					    }
				    }
				    return true;
			    }
			    return false;
          -->
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="ret_false" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <bne_un name="ret_false" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_1 />
          <ret />
          <label name="ret_false" />
          <ldc_i4_0 />
          <ret />
        </body>
      </method>
			<method name="startsWith" sig="(Ljava.lang.String;I)Z" modifiers="public" nonullcheck="true">
d517 3
a519 58
        <body>
          <!--
			    if (toffset >= 0
             && toffset <= this.Length
             && this.Length - toffset >= prefix.Length)
			    {
				    for (int i = 0; i < prefix.Length; i++)
				    {
					    if (this[i + toffset] != prefix[i])
					    {
						    return false;
					    }
				    }
				    return true;
			    }
			    return false;
          -->
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_2 />
          <blt_un name="ret_false" />
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_2 />
          <sub />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="ret_false" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="i" />
          <ldarg_2 />
          <add />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <bne_un name="ret_false" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_1 />
          <ret />
          <label name="ret_false" />
          <ldc_i4_0 />
          <ret />
        </body>
      </method>
			<method name="endsWith" sig="(Ljava.lang.String;)Z" modifiers="public" nonullcheck="true">
d521 2
a522 56
        <body>
          <!--
			    int j = this.Length - suffix.Length;
			    if (j >= 0)
			    {
				    for (int i = 0; i < suffix.Length; i++)
				    {
					    if (this[j++] != suffix[i])
					    {
						    return false;
					    }
				    }
				    return true;
			    }
			    return false;
          -->
          <ldarg_0 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <sub />
          <stloc name="j" type="System.Int32" />
          <ldloc name="j" />
          <ldc_i4_0 />
          <blt name="ret_false" />
          <ldc_i4_0 />
          <stloc name="i" type="System.Int32" />
          <br name="start_loop" />
          <label name="next" />
          <ldarg_0 />
          <ldloc name="j" />
          <dup />
          <ldc_i4_1 />
          <add />
          <stloc name="j" type="System.Int32" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <ldarg_1 />
          <ldloc name="i" />
          <callvirt type="System.String" name="get_Chars" sig="(I)C" />
          <bne_un name="ret_false" />
          <ldloc name="i" />
          <ldc_i4_1 />
          <add />
          <stloc name="i" type="System.Int32" />
          <label name="start_loop" />
          <ldloc name="i" />
          <ldarg_1 />
          <callvirt type="System.String" name="get_Length" sig="()I" />
          <blt name="next" />
          <ldc_i4_1 />
          <ret />
          <label name="ret_false" />
          <ldc_i4_0 />
          <ret />
        </body>
      </method>
@


1.57
log
@*** empty log message ***
@
text
@d1509 8
@


1.56
log
@*** empty log message ***
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003, 2004, 2005, 2006 Jeroen Frijters
d335 28
d762 19
@


1.55
log
@*** empty log message ***
@
text
@d1063 3
@


1.54
log
@*** empty log message ***
@
text
@d104 26
a129 1
					<brtrue name="ok" />
a131 3
					<label name="ok" />
					<call type="System.Array" name="Clone" sig="()Ljava.lang.Object;" />
					<ret />
@


1.53
log
@*** empty log message ***
@
text
@d682 30
@


1.52
log
@*** empty log message ***
@
text
@d1002 9
@


1.51
log
@*** empty log message ***
@
text
@a1216 92
		<class name="java.nio.DirectByteBufferImpl">
			<method name="get" sig="()B">
				<body>
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="limit" sig="I" />
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="pos" sig="I" />
					<ble_un name="err" />
					<ldarg_0 />
					<ldfld class="java.nio.DirectByteBufferImpl" name="address" sig="Lgnu.classpath.Pointer;" />
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="pos" sig="I" />
					<call type="gnu.classpath.Pointer" name="ReadByte" sig="(I)B" />
					<stloc name="result" type="System.Byte" />
					<ldarg_0 />
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="pos" sig="I" />
					<ldc_i4_1 />
					<add />
					<stfld class="java.nio.Buffer" name="pos" sig="I" />
					<ldloc name="result" />
					<ret />
					<label name="err" />
					<newobj class="java.nio.BufferUnderflowException" name="&lt;init&gt;" sig="()V" />
					<throw />
				</body>
			</method>
			<method name="put" sig="(B)Ljava.nio.ByteBuffer;">
				<body>
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="limit" sig="I" />
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="pos" sig="I" />
					<ble_un name="err" />
					<ldarg_0 />
					<ldfld class="java.nio.DirectByteBufferImpl" name="address" sig="Lgnu.classpath.Pointer;" />
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="pos" sig="I" />
					<ldarg_1 />
					<call type="gnu.classpath.Pointer" name="WriteByte" sig="(IB)V" />
					<ldarg_0 />
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="pos" sig="I" />
					<ldc_i4_1 />
					<add />
					<stfld class="java.nio.Buffer" name="pos" sig="I" />
					<ldarg_0 />
					<ret />
					<label name="err" />
					<newobj class="java.nio.BufferOverflowException" name="&lt;init&gt;" sig="()V" />
					<throw />
				</body>
			</method>
			<method name="get" sig="(I)B">
				<body>
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="limit" sig="I" />
					<ldarg_1 />
					<ble_un name="err" />
					<ldarg_0 />
					<ldfld class="java.nio.DirectByteBufferImpl" name="address" sig="Lgnu.classpath.Pointer;" />
					<ldarg_1 />
					<call type="gnu.classpath.Pointer" name="ReadByte" sig="(I)B" />
					<ret />
					<label name="err" />
					<ldarg_1 />
					<call class="java.lang.Integer" name="toString" sig="(I)Ljava.lang.String;" />
					<newobj class="java.lang.IndexOutOfBoundsException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
					<throw />
				</body>
			</method>
			<method name="put" sig="(IB)Ljava.nio.ByteBuffer;">
				<body>
					<ldarg_0 />
					<ldfld class="java.nio.Buffer" name="limit" sig="I" />
					<ldarg_1 />
					<ble_un name="err" />
					<ldarg_0 />
					<ldfld class="java.nio.DirectByteBufferImpl" name="address" sig="Lgnu.classpath.Pointer;" />
					<ldarg_1 />
					<ldarg_2 />
					<call type="gnu.classpath.Pointer" name="WriteByte" sig="(IB)V" />
					<ldarg_0 />
					<ret />
					<label name="err" />
					<ldarg_1 />
					<call class="java.lang.Integer" name="toString" sig="(I)Ljava.lang.String;" />
					<newobj class="java.lang.IndexOutOfBoundsException" name="&lt;init&gt;" sig="(Ljava.lang.String;)V" />
					<throw />
				</body>
			</method>
		</class>
@


1.50
log
@*** empty log message ***
@
text
@d1068 1
a1068 1
			<method name="box_byte" sig="(B)Ljava.lang.Object;">
a1070 1
					<box type="System.Byte" />
d1074 1
a1074 1
			<method name="box_boolean" sig="(Z)Ljava.lang.Object;">
a1076 1
					<box type="System.Boolean" />
d1080 1
a1080 1
			<method name="box_short" sig="(S)Ljava.lang.Object;">
a1082 1
					<box type="System.Int16" />
d1086 1
a1086 1
			<method name="box_char" sig="(C)Ljava.lang.Object;">
a1088 1
					<box type="System.Char" />
d1092 1
a1092 1
			<method name="box_int" sig="(I)Ljava.lang.Object;">
a1094 1
					<box type="System.Int32" />
d1098 1
a1098 1
			<method name="box_float" sig="(F)Ljava.lang.Object;">
a1100 1
					<box type="System.Single" />
d1104 1
a1104 1
			<method name="box_long" sig="(J)Ljava.lang.Object;">
a1106 1
					<box type="System.Int64" />
d1110 1
a1110 1
			<method name="box_double" sig="(D)Ljava.lang.Object;">
a1112 1
					<box type="System.Double" />
@


1.49
log
@*** empty log message ***
@
text
@d1456 42
@


1.48
log
@*** empty log message ***
@
text
@d1210 1
a1210 1
			<method name="newInputStream" sig="(Lgnu.java.nio.channels.FileChannelImpl;)Ljava.io.FileInputStream;">
d1213 1
a1213 1
					<newobj class="java.io.FileInputStream" name="&lt;init&gt;" sig="(Lgnu.java.nio.channels.FileChannelImpl;)V" />
d1217 1
a1217 1
			<method name="newOutputStream" sig="(Lgnu.java.nio.channels.FileChannelImpl;)Ljava.io.FileOutputStream;">
d1220 1
a1220 1
					<newobj class="java.io.FileOutputStream" name="&lt;init&gt;" sig="(Lgnu.java.nio.channels.FileChannelImpl;)V" />
@


1.47
log
@*** empty log message ***
@
text
@d83 1
a83 2
					<call type="IKVM.Runtime.Util" name="GetClassFromObject" sig="(Ljava.lang.Object;)Ljava.lang.Object;" />
					<castclass class="java.lang.Class" />
d953 1
a953 2
					<call type="IKVM.Runtime.Util" name="GetFriendlyClassFromType" sig="(Lcli.System.Type;)Ljava.lang.Object;" />
					<castclass class="java.lang.Class" />
a1316 8
		<class name="ikvm.internal.Library">
			<method name="doGetImpl" sig="()Likvm.internal.LibraryVMInterface;">
				<body>
					<newobj class="java.lang.LibraryVMInterfaceImpl" name="&lt;init&gt;" sig="()V" />
					<ret />
				</body>
			</method>
		</class>
@


1.46
log
@*** empty log message ***
@
text
@d1480 1
a1480 2
				<castclass type="System.TypeInitializationException" />
				<call class="java.lang.ExceptionHelper" name="MapTypeInitializeException" sig="(Lcli.System.TypeInitializationException;)Ljava.lang.Throwable;" />
@


1.45
log
@*** empty log message ***
@
text
@a26 15
		<attribute type="System.Reflection.AssemblyCompanyAttribute" sig="(Ljava.lang.String;)V">
			<parameter>Jeroen Frijters</parameter>
		</attribute>
		<attribute type="System.Reflection.AssemblyCopyrightAttribute" sig="(Ljava.lang.String;)V">
			<parameter>This software is licensed under the GNU General Public License + GNU Classpath exception.
			See http://www.gnu.org/software/classpath/license.html for details.
			Copyright (C) 1998-2006 Free Software Foundation, Inc.
			Copyright (C) 2002-2006 Jeroen Frijters</parameter>
		</attribute>
		<attribute type="System.Reflection.AssemblyTitleAttribute" sig="(Ljava.lang.String;)V">
			<parameter>IKVM GNU Classpath library for .NET</parameter>
		</attribute>
		<attribute type="System.Reflection.AssemblyProductAttribute" sig="(Ljava.lang.String;)V">
			<parameter>IKVM.NET</parameter>
		</attribute>
a1326 76
		<class name="java.lang.VMClassLoader">
			<field name="__tls_nestedGetResourcesHack" sig="Z">
				<attribute type="System.ThreadStaticAttribute" sig="()V" />
			</field>
		</class>
		<class name="java.lang.VMThread">
			<field name="__tls_javaThread" sig="Ljava.lang.Thread;">
				<attribute type="System.ThreadStaticAttribute" sig="()V" />
			</field>
			<field name="__tls_cleanup" sig="Ljava.lang.Object;">
				<attribute type="System.ThreadStaticAttribute" sig="()V" />
			</field>
		</class>
		<class name="java.security.VMAccessController">
			<field name="__tls_contexts" sig="Ljava.util.LinkedList;">
				<attribute type="System.ThreadStaticAttribute" sig="()V" />
			</field>
			<field name="__tls_inGetContext" sig="Z">
				<attribute type="System.ThreadStaticAttribute" sig="()V" />
			</field>
		</class>
		<class name="gnu.java.nio.channels.FileChannelImpl$Win32">
			<method name="FlushFileBuffers" sig="(Lcli.System.IntPtr;)I">
				<attribute type="System.Runtime.InteropServices.DllImportAttribute" sig="(Ljava.lang.String;)V">
					<parameter>kernel32</parameter>
				</attribute>
			</method>
			<method name="CloseHandle" sig="(Lcli.System.IntPtr;)I">
				<attribute type="System.Runtime.InteropServices.DllImportAttribute" sig="(Ljava.lang.String;)V">
					<parameter>kernel32</parameter>
				</attribute>
			</method>
			<method name="CreateFileMapping" sig="(Lcli.System.IntPtr;Lcli.System.IntPtr;IIILjava.lang.String;)Lcli.System.IntPtr;">
				<attribute type="System.Runtime.InteropServices.DllImportAttribute" sig="(Ljava.lang.String;)V">
					<parameter>kernel32</parameter>
					<field name="SetLastError" sig="Z">true</field>
				</attribute>
			</method>
			<method name="MapViewOfFile" sig="(Lcli.System.IntPtr;IIILcli.System.IntPtr;)Lcli.System.IntPtr;">
				<attribute type="System.Runtime.InteropServices.DllImportAttribute" sig="(Ljava.lang.String;)V">
					<parameter>kernel32</parameter>
					<field name="SetLastError" sig="Z">true</field>
				</attribute>
			</method>
		</class>
		<class name="gnu.java.nio.channels.FileChannelImpl$Posix">
			<method name="ikvm_mmap" sig="(Lcli.System.IntPtr;BBJI)Lcli.System.IntPtr;">
				<attribute type="System.Runtime.InteropServices.DllImportAttribute" sig="(Ljava.lang.String;)V">
					<parameter>ikvm-native</parameter>
				</attribute>
			</method>
		</class>
		<class name="java.nio.MappedByteBufferImpl$Win32">
			<method name="UnmapViewOfFile" sig="(Lcli.System.IntPtr;)I">
				<attribute type="System.Runtime.InteropServices.DllImportAttribute" sig="(Ljava.lang.String;)V">
					<parameter>kernel32</parameter>
				</attribute>
			</method>
			<method name="FlushViewOfFile" sig="(Lcli.System.IntPtr;Lcli.System.IntPtr;)I">
				<attribute type="System.Runtime.InteropServices.DllImportAttribute" sig="(Ljava.lang.String;)V">
					<parameter>kernel32</parameter>
				</attribute>
			</method>
		</class>
		<class name="java.nio.MappedByteBufferImpl$Posix">
			<method name="ikvm_munmap" sig="(Lcli.System.IntPtr;I)I">
				<attribute type="System.Runtime.InteropServices.DllImportAttribute" sig="(Ljava.lang.String;)V">
					<parameter>ikvm-native</parameter>
				</attribute>
			</method>
			<method name="ikvm_msync" sig="(Lcli.System.IntPtr;I)I">
				<attribute type="System.Runtime.InteropServices.DllImportAttribute" sig="(Ljava.lang.String;)V">
					<parameter>ikvm-native</parameter>
				</attribute>
			</method>
		</class>
@


1.44
log
@*** empty log message ***
@
text
@d33 2
a34 2
			Copyright (C) 1998-2005 Free Software Foundation, Inc.
			Copyright (C) 2002-2005 Jeroen Frijters</parameter>
@


1.43
log
@*** empty log message ***
@
text
@d1472 9
d1493 16
@


1.42
log
@*** empty log message ***
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003, 2004, 2005 Jeroen Frijters
d1418 114
@


1.41
log
@*** empty log message ***
@
text
@d963 1
a963 1
				<parameter>&lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</parameter>
@


1.40
log
@*** empty log message ***
@
text
@d962 3
@


1.39
log
@*** empty log message ***
@
text
@d971 44
@


1.38
log
@*** empty log message ***
@
text
@a1142 26
		<class name="java.lang.VMClass">
			<method name="createField" sig="(Ljava.lang.Class;Ljava.lang.Object;)Ljava.lang.reflect.Field;">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<call class="java.lang.reflect.VMFieldImpl" name="newField" sig="(Ljava.lang.Class;Ljava.lang.Object;)Ljava.lang.reflect.Field;" />
					<ret />
				</body>
			</method>
			<method name="createMethod" sig="(Ljava.lang.Class;Ljava.lang.Object;)Ljava.lang.reflect.Method;">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<newobj class="java.lang.reflect.Method" name="&lt;init&gt;" sig="(Ljava.lang.Class;Ljava.lang.Object;)V" />
					<ret />
				</body>
			</method>
			<method name="createConstructor" sig="(Ljava.lang.Class;Ljava.lang.Object;)Ljava.lang.reflect.Constructor;">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<newobj class="java.lang.reflect.Constructor" name="&lt;init&gt;" sig="(Ljava.lang.Class;Ljava.lang.Object;)V" />
					<ret />
				</body>
			</method>
		</class>
a1161 40
		<class name="java.lang.LibraryVMInterfaceImpl">
			<method name="getWrapperFromField" sig="(Ljava.lang.reflect.Field;)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<ldfld class="java.lang.reflect.Field" name="impl" sig="Lgnu.java.lang.reflect.VMField;" />
					<ldfld class="gnu.java.lang.reflect.VMField" name="fieldCookie" sig="Ljava.lang.Object;" />
					<ret />
				</body>
			</method>
			<method name="getWrapperFromMethod" sig="(Ljava.lang.reflect.Method;)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<ldfld class="java.lang.reflect.Method" name="methodCookie" sig="Ljava.lang.Object;" />
					<ret />
				</body>
			</method>
			<method name="getWrapperFromConstructor" sig="(Ljava.lang.reflect.Constructor;)Ljava.lang.Object;">
				<body>
					<ldarg_0 />
					<ldfld class="java.lang.reflect.Constructor" name="methodCookie" sig="Ljava.lang.Object;" />
					<ret />
				</body>
			</method>
			<method name="newDirectByteBuffer" sig="(Lcli.System.IntPtr;I)Ljava.lang.Object;">
				<body>
					<ldarg_1 />
					<ldarg_2 />
					<call class="java.nio.VMDirectByteBuffer" name="NewDirectByteBuffer" sig="(Lcli.System.IntPtr;I)Ljava.nio.ByteBuffer;" />
					<ret />
				</body>
			</method>
			<method name="getDirectBufferAddress" sig="(Ljava.lang.Object;)Lcli.System.IntPtr;">
				<body>
					<ldarg_1 />
					<castclass class="java.nio.Buffer" />
					<call class="java.nio.VMDirectByteBuffer" name="GetDirectBufferAddress" sig="(Ljava.nio.Buffer;)Lcli.System.IntPtr;" />
					<ret />
				</body>
			</method>
		</class>
a1178 12
		<class name="gnu.java.nio.channels.FileChannelImpl">
			<method name="createMappedByteBufferImpl" sig="(Lgnu.classpath.Pointer;IZZ)Ljava.nio.MappedByteBuffer;">
				<body>
					<ldarg_0 />
					<ldarg_1 />
					<ldarg_2 />
					<ldarg_3 />
					<call class="java.nio.MappedByteBufferImpl" name="create" sig="(Lgnu.classpath.Pointer;IZZ)Ljava.nio.MappedByteBufferImpl;" />
					<ret />
				</body>
			</method>
		</class>
@


1.37
log
@*** empty log message ***
@
text
@d27 1
a27 1
		<attribute type="System.Reflection.AssemblyCompanyAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d30 1
a30 1
		<attribute type="System.Reflection.AssemblyCopyrightAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d36 1
a36 1
		<attribute type="System.Reflection.AssemblyTitleAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d39 1
a39 1
		<attribute type="System.Reflection.AssemblyProductAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d42 1
a42 1
		<class name="java.lang.Object" shadows="System.Object, mscorlib" modifiers="public">
d47 1
a47 1
					<call type="System.Threading.Monitor, mscorlib" name="PulseAll" sig="(Ljava.lang.Object;)V" />
d54 1
a54 1
					<call type="System.Threading.Monitor, mscorlib" name="Pulse" sig="(Ljava.lang.Object;)V" />
d113 1
a113 1
					<call type="System.Object, mscorlib" name="MemberwiseClone" sig="()Ljava.lang.Object;" />
d118 1
a118 1
					<isinst type="System.Array, mscorlib" />
d124 1
a124 1
					<call type="System.Array, mscorlib" name="Clone" sig="()Ljava.lang.Object;" />
d137 1
a137 1
					<call type="System.String, mscorlib" name="Concat" sig="(Ljava.lang.String;Ljava.lang.String;Ljava.lang.String;)Ljava.lang.String;" />
d150 1
a150 1
					<isinst type="System.Array, mscorlib" />
d157 1
a157 1
					<callvirt type="System.Object, mscorlib" name="ToString" sig="()Ljava.lang.String;" />
d169 15
d188 18
d219 1
a219 1
					<call type="System.Object, mscorlib" name="Finalize" sig="()V" />
d229 1
a229 1
		<class name="java.lang.String" shadows="System.String, mscorlib" modifiers="public final">
d240 1
a240 1
					<call type="System.String, mscorlib" name="Copy" sig="(Ljava.lang.String;)Ljava.lang.String;" />
d252 1
a252 1
					<newobj type="System.String, mscorlib" name=".ctor" sig="([C)V" />
d281 1
a281 1
					<newobj type="System.String, mscorlib" name=".ctor" sig="([CII)V" />
d292 1
a292 1
				<attribute type="System.ObsoleteAttribute, mscorlib" sig="()V" />
d306 1
a306 1
				<attribute type="System.ObsoleteAttribute, mscorlib" sig="()V" />
d390 2
a391 2
							<callvirt type="System.String, mscorlib" name="get_Chars" sig="(I)C" />
							<stloc name="char" type="System.Char, mscorlib" />
d393 1
a393 1
						<catch type="System.IndexOutOfRangeException, mscorlib">
d419 1
a419 1
					<call type="System.String, mscorlib" name="IndexOf" sig="(C)I" />
d448 1
a448 1
					<call type="System.String, mscorlib" name="LastIndexOf" sig="(C)I" />
d523 1
a523 1
					<castclass type="System.String, mscorlib" />
d569 1
a569 1
				<attribute type="System.ObsoleteAttribute, mscorlib" sig="()V" />
d608 1
a608 1
					<callvirt type="System.String, mscorlib" name="Equals" sig="(Ljava.lang.String;)Z" />
d682 1
a682 1
					<newobj type="System.String, mscorlib" name=".ctor" sig="([C)V" />
d694 1
a694 1
					<newobj type="System.String, mscorlib" name=".ctor" sig="([CII)V" />
d715 1
a715 1
					<call type="System.String, mscorlib" name="ToCharArray" sig="()[C" />
d735 1
a735 1
		<class name="java.lang.Throwable" shadows="System.Exception, mscorlib" modifiers="public">
d740 1
a740 1
				<attribute type="System.ThreadStaticAttribute, mscorlib" sig="()V" />
d751 1
a751 1
				<attribute type="System.ComponentModel.EditorBrowsableAttribute, System, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
d762 1
a762 1
				<attribute type="System.ComponentModel.EditorBrowsableAttribute, System, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
d774 1
a774 1
				<attribute type="System.ComponentModel.EditorBrowsableAttribute, System, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
d787 1
a787 1
				<attribute type="System.ComponentModel.EditorBrowsableAttribute, System, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" sig="(Lcli.System.ComponentModel.EditorBrowsableState;)V">
d819 1
a819 1
					<call type="System.Exception, mscorlib" name=".ctor" sig="(Ljava.lang.String;)V" />
d839 1
a839 1
					<call type="System.Exception, mscorlib" name=".ctor" sig="(Ljava.lang.String;)V" />
d861 1
a861 1
					<call type="System.Exception, mscorlib" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
d889 1
a889 1
					<call type="System.Exception, mscorlib" name=".ctor" sig="(Ljava.lang.String;Ljava.lang.Throwable;)V" />
d948 1
a948 1
		<class name="java.lang.Comparable" shadows="System.IComparable, mscorlib" modifiers="public abstract interface">
d977 1
a977 1
					<unbox type="System.Byte, mscorlib" />
d985 1
a985 1
					<unbox type="System.Boolean, mscorlib" />
d993 1
a993 1
					<unbox type="System.Int16, mscorlib" />
d1001 1
a1001 1
					<unbox type="System.Char, mscorlib" />
d1009 1
a1009 1
					<unbox type="System.Int32, mscorlib" />
d1017 1
a1017 1
					<unbox type="System.Single, mscorlib" />
d1025 1
a1025 1
					<unbox type="System.Int64, mscorlib" />
d1033 1
a1033 1
					<unbox type="System.Double, mscorlib" />
d1041 1
a1041 1
					<box type="System.Byte, mscorlib" />
d1048 1
a1048 1
					<box type="System.Boolean, mscorlib" />
d1055 1
a1055 1
					<box type="System.Int16, mscorlib" />
d1062 1
a1062 1
					<box type="System.Char, mscorlib" />
d1069 1
a1069 1
					<box type="System.Int32, mscorlib" />
d1076 1
a1076 1
					<box type="System.Single, mscorlib" />
d1083 1
a1083 1
					<box type="System.Int64, mscorlib" />
d1090 1
a1090 1
					<box type="System.Double, mscorlib" />
a1171 1
					<!-- FXBUG RuntimeHelpers.GetHashCode is broken in multi AppDomain scenarios (on v1.x) -->
d1173 11
a1183 1
					<call type="System.Object, mscorlib" name="GetHashCode" sig="()I" />
d1286 1
a1286 1
					<stloc name="result" type="System.Byte, mscorlib" />
d1365 8
d1375 1
a1375 1
				<attribute type="System.ThreadStaticAttribute, mscorlib" sig="()V" />
d1380 1
a1380 1
				<attribute type="System.ThreadStaticAttribute, mscorlib" sig="()V" />
d1383 1
a1383 1
				<attribute type="System.ThreadStaticAttribute, mscorlib" sig="()V" />
d1388 1
a1388 1
				<attribute type="System.ThreadStaticAttribute, mscorlib" sig="()V" />
d1391 1
a1391 1
				<attribute type="System.ThreadStaticAttribute, mscorlib" sig="()V" />
d1396 1
a1396 1
				<attribute type="System.Runtime.InteropServices.DllImportAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d1401 1
a1401 1
				<attribute type="System.Runtime.InteropServices.DllImportAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d1406 1
a1406 1
				<attribute type="System.Runtime.InteropServices.DllImportAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d1412 1
a1412 1
				<attribute type="System.Runtime.InteropServices.DllImportAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d1420 1
a1420 1
				<attribute type="System.Runtime.InteropServices.DllImportAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d1427 1
a1427 1
				<attribute type="System.Runtime.InteropServices.DllImportAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d1432 1
a1432 1
				<attribute type="System.Runtime.InteropServices.DllImportAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d1439 1
a1439 1
				<attribute type="System.Runtime.InteropServices.DllImportAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d1444 1
a1444 1
				<attribute type="System.Runtime.InteropServices.DllImportAttribute, mscorlib" sig="(Ljava.lang.String;)V">
d1451 1
a1451 1
		<exception src="System.NullReferenceException, mscorlib" dst="java.lang.NullPointerException" />
d1453 2
a1454 2
		<exception src="System.ArgumentNullException, mscorlib" dst="java.lang.NullPointerException" />
		<exception src="System.IndexOutOfRangeException, mscorlib" dst="java.lang.ArrayIndexOutOfBoundsException" />
d1456 2
a1457 2
		<exception src="System.ArgumentOutOfRangeException, mscorlib" dst="java.lang.StringIndexOutOfBoundsException" />
		<exception src="System.InvalidCastException, mscorlib" dst="java.lang.ClassCastException" />
d1461 1
a1461 1
		<exception src="System.TypeInitializationException, mscorlib" dst="*java.lang.Error">
d1463 1
a1463 1
				<castclass type="System.TypeInitializationException, mscorlib" />
d1467 3
a1469 3
		<exception src="System.Threading.SynchronizationLockException, mscorlib" dst="java.lang.IllegalMonitorStateException" />
		<exception src="System.OutOfMemoryException, mscorlib" dst="java.lang.OutOfMemoryError" />
		<exception src="System.DivideByZeroException, mscorlib" dst="java.lang.ArithmeticException">
d1476 4
a1479 4
		<exception src="System.ArrayTypeMismatchException, mscorlib" dst="java.lang.ArrayStoreException" />
		<exception src="System.StackOverflowException, mscorlib" dst="java.lang.StackOverflowError" />
		<exception src="System.Security.VerificationException, mscorlib" dst="java.lang.VerifyError" />
		<exception src="System.Threading.ThreadAbortException, mscorlib" dst="java.lang.ThreadDeath">
d1481 2
a1482 2
				<castclass type="System.Threading.ThreadAbortException, mscorlib" />
				<call type="System.Threading.ThreadAbortException, mscorlib" name="get_ExceptionState" sig="()Ljava.lang.Object;" />
d1498 1
a1498 1
						<call type="System.Threading.Thread, mscorlib" name="ResetAbort" sig="()V" />
d1500 1
a1500 1
					<catch type="System.Threading.ThreadStateException, mscorlib">
d1509 1
a1509 1
		<exception src="System.OverflowException, mscorlib" dst="java.lang.NegativeArraySizeException" />
@


1.36
log
@*** empty log message ***
@
text
@d93 3
d197 1
d200 3
a202 1
			<implements class="java.io.Serializable" />
d665 5
a669 1
			<field name="CASE_INSENSITIVE_ORDER" sig="Ljava.util.Comparator;" modifiers="public static final" />
d916 3
d920 3
@


1.35
log
@*** empty log message ***
@
text
@d911 12
@


1.34
log
@*** empty log message ***
@
text
@d1176 1
a1176 1
			<method name="createMappedByteBufferImpl" sig="(Lgnu.classpath.RawData;IZZ)Ljava.nio.MappedByteBuffer;">
d1182 1
a1182 1
					<call class="java.nio.MappedByteBufferImpl" name="create" sig="(Lgnu.classpath.RawData;IZZ)Ljava.nio.MappedByteBufferImpl;" />
d1212 1
a1212 1
					<ldfld class="java.nio.DirectByteBufferImpl" name="address" sig="Lgnu.classpath.RawData;" />
d1215 1
a1215 1
					<call type="gnu.classpath.RawData" name="ReadByte" sig="(I)B" />
d1238 1
a1238 1
					<ldfld class="java.nio.DirectByteBufferImpl" name="address" sig="Lgnu.classpath.RawData;" />
d1242 1
a1242 1
					<call type="gnu.classpath.RawData" name="WriteByte" sig="(IB)V" />
d1263 1
a1263 1
					<ldfld class="java.nio.DirectByteBufferImpl" name="address" sig="Lgnu.classpath.RawData;" />
d1265 1
a1265 1
					<call type="gnu.classpath.RawData" name="ReadByte" sig="(I)B" />
d1281 1
a1281 1
					<ldfld class="java.nio.DirectByteBufferImpl" name="address" sig="Lgnu.classpath.RawData;" />
d1284 1
a1284 1
					<call type="gnu.classpath.RawData" name="WriteByte" sig="(IB)V" />
@


1.33
log
@*** empty log message ***
@
text
@d1385 2
a1386 8
				<call type="System.Exception, mscorlib" name="get_InnerException" sig="()Ljava.lang.Throwable;" />
				<ldc_i4_1 />
				<call class="java.lang.ExceptionHelper" name="MapExceptionFast" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" />
				<dup />
				<isinst class="java.lang.Error" />
				<brtrue name="end" />
				<newobj class="java.lang.ExceptionInInitializerError" name="&lt;init&gt;" sig="(Ljava.lang.Throwable;)V" />
				<label name="end" />
@


1.32
log
@*** empty log message ***
@
text
@d27 3
d36 6
@


1.31
log
@*** empty log message ***
@
text
@d1167 1
a1167 1
			<method name="createMappedByteBufferImpl" sig="(Lgnu.classpath.RawData;IZ)Ljava.nio.MappedByteBuffer;">
d1172 2
a1173 1
					<newobj class="java.nio.MappedByteBufferImpl" name="&lt;init&gt;" sig="(Lgnu.classpath.RawData;IZ)V" />
d1307 55
@


1.30
log
@*** empty log message ***
@
text
@d61 1
d72 2
d159 1
d197 1
d208 5
a212 1
			<constructor sig="([CII)V" modifiers="public" />
d218 1
d222 1
d226 1
d238 1
d241 4
a244 1
			<constructor sig="([BI)V" modifiers="public" deprecated="true">
d248 3
d253 6
a258 1
			<constructor sig="([BIII)V" modifiers="public" deprecated="true">
d262 2
d268 4
d276 3
d287 3
a289 1
			<method name="equals" sig="(Ljava.lang.Object;)Z" modifiers="public" />
d291 1
d295 1
d299 1
d303 1
d307 1
d311 1
d315 1
d319 3
d325 1
d329 1
d336 1
d356 2
d361 1
d376 2
d381 1
d385 2
d390 1
d405 2
d410 1
d414 2
d422 4
d429 1
d433 2
d438 1
d445 1
d452 1
d456 1
d460 1
d467 1
d471 1
d481 2
d489 1
d494 2
d502 5
d510 4
d516 6
a521 1
			<method name="getBytes" sig="(II[BI)V" modifiers="public" deprecated="true">
d525 1
d529 1
d533 1
d537 1
d541 2
d546 2
d551 1
d555 1
d565 2
d570 1
d579 2
d592 2
d605 1
d615 2
d627 1
d639 3
d697 2
a698 1
			<method name="__&lt;suppressFillInStackTrace&gt;" sig="()V" modifiers="public static" hidefromjava="true">
d708 2
a709 1
			<method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;Z)Ljava.lang.Throwable;" modifiers="public static" hidefromjava="true">
d720 2
a721 1
			<method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;Lcli.System.Type;Z)Ljava.lang.Throwable;" modifiers="public static" hidefromjava="true">
d733 2
a734 1
			<method name="__&lt;unmap&gt;" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public static" hidefromjava="true">
d746 1
d782 1
d802 2
d831 1
d862 1
d866 1
d879 1
d889 1
d898 1
@


1.29
log
@*** empty log message ***
@
text
@d568 3
d578 14
a591 1
			<method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" modifiers="public static" hidefromjava="true">
d594 2
a595 1
					<call class="java.lang.ExceptionHelper" name="MapExceptionFast" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
d597 1
a597 1
				</body>				
d599 4
a602 1
			<method name="__&lt;map&gt;" sig="(Ljava.lang.Throwable;Lcli.System.Type;)Ljava.lang.Throwable;" modifiers="public static" hidefromjava="true">
d606 12
a617 1
					<call class="java.lang.ExceptionHelper" name="MapException" sig="(Ljava.lang.Throwable;Lcli.System.Type;)Ljava.lang.Throwable;" />
d619 1
a619 1
				</body>				
d644 10
d663 10
d683 10
d710 10
d1188 2
a1189 1
				<call class="java.lang.ExceptionHelper" name="MapExceptionFast" sig="(Ljava.lang.Throwable;)Ljava.lang.Throwable;" />
@


1.28
log
@*** empty log message ***
@
text
@d245 3
d432 18
d459 3
@


1.27
log
@*** empty log message ***
@
text
@d27 6
d1057 21
@


1.26
log
@*** empty log message ***
@
text
@d932 11
@


1.25
log
@*** empty log message ***
@
text
@d844 1
a844 1
					<newobj class="java.lang.reflect.Field" name="&lt;init&gt;" sig="(Ljava.lang.Class;Ljava.lang.Object;)V" />
d879 2
a880 1
					<ldfld class="java.lang.reflect.Field" name="fieldCookie" sig="Ljava.lang.Object;" />
@


1.24
log
@*** empty log message ***
@
text
@d545 15
@


1.23
log
@*** empty log message ***
@
text
@d850 10
@


1.22
log
@*** empty log message ***
@
text
@d3 1
a3 1
  Copyright (C) 2002, 2003, 2004 Jeroen Frijters
d208 11
d658 1
a658 1
					<unbox type="System.SByte, mscorlib" />
d722 1
a722 1
					<box type="System.SByte, mscorlib" />
d775 1
a775 1
			<method name="box_ubyte" sig="(B)Lcli.System.Byte;">
d799 1
a799 1
			<method name="unbox_ubyte" sig="(Lcli.System.Byte;)B">
a823 14
		<class name="ikvm.lang.ByteArrayHack">
			<method name="cast" sig="([B)[Lcli.System.Byte;">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
			<method name="cast" sig="([Lcli.System.Byte;)[B">
				<body>
					<ldarg_0 />
					<ret />
				</body>
			</method>
		</class>
d883 2
a884 5
					<castclass class="java.nio.ByteBuffer" />
					<call class="java.nio.VMDirectByteBuffer" name="GetDirectBufferAddress" sig="(Ljava.nio.ByteBuffer;)Lcli.System.IntPtr;" />
					<!-- LAME we need to unbox the return value -->
					<unbox type="System.IntPtr, mscorlib" />
					<ldobj type="System.IntPtr, mscorlib" />
d906 1
a906 1
		<class name="java.nio.channels.Channels">
d935 1
a935 1
					<stloc name="result" type="System.SByte, mscorlib" />
@


1.21
log
@*** empty log message ***
@
text
@d47 4
a50 3
					<call type="System.Threading.Monitor, mscorlib" name="Wait" sig="(Ljava.lang.Object;)Z" />
					<!-- For some reason, Wait returns a boolean -->
					<pop />
d60 1
a60 1
					<call class="java.lang.ObjectHelper" name="wait" sig="(Ljava.lang.Object;JI)V" />
d70 1
a70 1
					<call class="java.lang.ObjectHelper" name="wait" sig="(Ljava.lang.Object;JI)V" />
d107 13
d124 1
a124 1
					<call class="java.lang.ObjectHelper" name="toStringSpecial" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
d132 1
a132 1
					<call class="java.lang.ObjectHelper" name="toStringSpecial" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
d142 1
a142 1
					<call class="java.lang.ObjectHelper" name="toStringSpecial" sig="(Ljava.lang.Object;)Ljava.lang.String;" />
d951 1
a951 1
					<newobj class="java.nio.BufferOverflowException" name="&lt;init&gt;" sig="()V" />
a1043 1
		<exception src="System.Threading.ThreadInterruptedException, mscorlib" dst="java.lang.InterruptedException" />
@


1.20
log
@*** empty log message ***
@
text
@d898 16
@


1.19
log
@*** empty log message ***
@
text
@d839 42
@


1.18
log
@*** empty log message ***
@
text
@d813 43
@


1.17
log
@*** empty log message ***
@
text
@d813 92
@


1.16
log
@*** empty log message ***
@
text
@d197 1
a197 1
			<constructor sig="([BI)V" modifiers="public">
d203 1
a203 1
			<constructor sig="([BIII)V" modifiers="public">
d392 1
a392 1
			<method name="getBytes" sig="(II[BI)V" modifiers="public">
@


1.15
log
@*** empty log message ***
@
text
@d76 1
a76 2
					<call type="System.Object, mscorlib" name="GetType" sig="()Lcli.System.Type;" />
					<call type="IKVM.NativeCode.java.lang.VMClass" name="getClassFromType" sig="(Lcli.System.Type;)Ljava.lang.Class;" />
d215 1
a215 5
				<body>
					<ldarg_0 />
					<call class="java.lang.StringHelper" name="hashCode" sig="(Lcli.System.String;)I" />
					<ret />
				</body>
d255 17
a271 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;I)C" />
@


1.14
log
@*** empty log message ***
@
text
@d76 2
a77 2
					<call type="System.Object, mscorlib" name="GetType" />
					<call type="IKVM.NativeCode.java.lang.VMClass" name="getClassFromType" />
d92 1
a92 1
					<call type="System.Object, mscorlib" name="MemberwiseClone" />
d123 1
a123 1
					<callvirt type="System.Object, mscorlib" name="ToString" />
d151 1
a151 1
					<call type="System.Object, mscorlib" name="Finalize" />
d169 1
a169 1
					<call type="System.String, mscorlib" name="Copy" />
@


1.13
log
@*** empty log message ***
@
text
@a616 15
		<class name="gnu.classpath.RawData" shadows="System.IntPtr, mscorlib" scope="private">
			<!-- TODO custom boxing isn't support for non-private remapped types, but since this is the only
			     type that has a custom boxing rule, this isn't yet an issue -->
			<box>
				<!-- We special case boxing, to "box" IntPtr.Zero as null -->
				<dup />
				<brfalse name="null" />
				<box type="System.IntPtr, mscorlib" />
				<br name="end" />
				<label name="null" />
				<pop />
				<ldnull />
				<label name="end" />
			</box>
		</class>
@


1.12
log
@*** empty log message ***
@
text
@d77 1
a77 1
					<call type="NativeCode.java.lang.VMClass" name="getClassFromType" />
@


1.11
log
@*** empty log message ***
@
text
@d870 2
@


1.10
log
@*** empty log message ***
@
text
@d127 5
d857 1
a858 1
				<isinst class="java.lang.ThreadDeath" />
d867 10
a876 2
				<castclass class="java.lang.ThreadDeath" />
				<call type="System.Threading.Thread, mscorlib" name="ResetAbort" sig="()V" />
@


1.9
log
@*** empty log message ***
@
text
@d346 7
a352 1
				<redirect name="CompareTo" />
d821 4
a824 2
		<!-- NOTE we "map" to java.lang.Error, because that is the base class of all possible mappings -->
		<exception src="System.TypeInitializationException, mscorlib" dst="java.lang.Error">
@


1.8
log
@*** empty log message ***
@
text
@d261 12
a272 1
				<redirect name="IndexOf" sig="(C)I" />
d275 1
a275 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;CI)I" />
d284 12
a295 1
				<redirect name="LastIndexOf" sig="(C)I" />
d298 1
a298 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Lcli.System.String;CI)I" />
@


1.7
log
@*** empty log message ***
@
text
@d168 11
a178 1
			<constructor sig="([C)V" modifiers="public" />
@


1.6
log
@*** empty log message ***
@
text
@d404 4
@


1.5
log
@*** empty log message ***
@
text
@d454 26
d504 7
d521 7
@


1.4
log
@*** empty log message ***
@
text
@d547 32
d587 128
@


1.3
log
@*** empty log message ***
@
text
@d26 2
a27 2
	<remappings>
		<class name="java.lang.Object" type="System.Object, mscorlib" modifiers="public">
d156 1
a156 1
		<class name="java.lang.String" type="System.String, mscorlib" modifiers="public final">
d203 1
a203 1
					<call class="java.lang.StringHelper" name="hashCode" sig="(Ljava.lang.String;)I" />
d221 1
a221 1
				<redirect class="java.lang.StringHelper" />
d245 1
a245 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;I)C" />
d248 1
a248 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II)Ljava.lang.String;" />
d254 1
a254 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;CI)I" />
d260 1
a260 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
d266 1
a266 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;CI)I" />
d269 1
a269 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;)I" />
d272 1
a272 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)I" />
d278 1
a278 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;II[CI)V" />
d284 1
a284 1
				<redirect class="java.lang.StringHelper" type="static" sig="(Ljava.lang.String;Ljava.lang.String;I)Z" />
d327 1
a327 1
				<redirect class="java.lang.StringHelper" type="static" name="substring" sig="(Ljava.lang.String;II)Ljava.lang.String;" />
d423 1
a423 1
				<redirect class="java.lang.StringHelper" type="static" name="GetCountField" sig="(Ljava.lang.String;)I" />
d437 1
a437 1
				<redirect class="java.lang.StringHelper" type="static" name="GetValueField" sig="(Ljava.lang.String;)[C" />
d440 1
a440 1
				<redirect class="java.lang.StringHelper" type="static" name="GetOffsetField" sig="(Ljava.lang.String;)I" />
d451 1
a451 1
		<class name="java.lang.Throwable" type="System.Exception, mscorlib" modifiers="public">
d525 1
a525 1
		<class name="java.lang.Comparable" type="System.IComparable, mscorlib" modifiers="public abstract interface">
d530 3
a532 3
		<class name="gnu.classpath.RawData" type="System.IntPtr, mscorlib" oneway="true">
			<!-- TODO custom boxing isn't support for non-oneway remapped types, but since this is the only
			     type that has a custom boxing rule, this isn't yet as issue -->
d545 1
a545 2
	</remappings>
	<nativeMethods>
d570 1
a570 1
	</nativeMethods>
@


1.2
log
@*** empty log message ***
@
text
@a529 1
		<!-- TODO support "oneway" attribute (don't associate System.IntPtr with gnu.classpath.RawData -->
d531 2
@


1.1
log
@*** empty log message ***
@
text
@d207 1
a207 1
			<!-- we have a toString here to make sure that toString shows up as a declared method in reflection -->
d209 2
d313 3
d344 58
@

