head	1.33;
access;
symbols
	v8_1_5717_0:1.31
	v8_1:1.31.0.2
	v8_0_5449_1:1.30
	v8_0_5449_0:1.30
	v8_0:1.30.0.6
	v7_4_5196_0:1.30
	v7_4:1.30.0.4
	v7_3:1.30.0.2
	v7_2_4630_6:1.29
	v7_2_4630_5:1.29
	v7_2_4630_4:1.29
	v7_2_4630_3:1.29
	v7_2_4630_2:1.29
	v0_46_0_4:1.13
	v7_2_4630_1:1.29
	v7_2:1.29.0.2
	v7_1_4532_2:1.24
	v7_1_4532_1:1.24
	v7_1_4532_0:1.24
	v7_1:1.24.0.2
	v7_0_4335_3:1.18
	v7_0_4335_2:1.18
	v7_0_4335_1:1.18
	v0_46_0_2:1.13
	v7_0_4335_0:1.18
	v7_0:1.18.0.2
	v0_46_0_1:1.13
	v0_46_0_0:1.13
	v0_46:1.13.0.2
	v0_44_0_6:1.10
	v0_44_0_5:1.10
	v0_44_0_4:1.10
	v0_44_0_3:1.10
	v0_44_0_2:1.10
	v0_44_0_1:1.10
	v0_44_0_0:1.10
	v0_44:1.10.0.2;
locks; strict;
comment	@ * @;


1.33
date	2016.07.20.05.43.14;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2016.07.20.05.16.33;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2015.04.06.06.54.43;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2012.10.14.15.00.22;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2012.07.13.13.08.28;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.13.10.13.21;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.13.09.45.43;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.13.09.29.35;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.13.09.12.28;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2012.05.02.15.24.00;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2012.04.19.12.49.10;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.19.12.14.52;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2012.04.10.06.18.32;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.30.14.24.28;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2012.01.27.10.11.18;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.13.09.51.01;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.08.08.41.00;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2011.03.06.07.38.58;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.06.06.48.05;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.03.12.35.48;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2011.03.03.08.34.58;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.20.18.11.09;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.06.10.31.53;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.28.09.38.00;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.28.09.33.27;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.18.06.57.18;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.18.08.58.19;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.02.03.52.22;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.26.09.26.20;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.09.07.50.07;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.09.05.43.43;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.25.05.49.02;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.25.05.29.31;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.33
log
@We don't support custom attributes on DeclSecurity or GenericParamConstraint, so there is no need to implement it.
@
text
@/*
  Copyright (C) 2009-2012 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
using System.Text;
using IKVM.Reflection.Emit;
using IKVM.Reflection.Writer;
using IKVM.Reflection.Reader;

namespace IKVM.Reflection.Metadata
{
	internal abstract class Table
	{
		internal bool Sorted;

		internal bool IsBig
		{
			get { return RowCount > 65535; }
		}

		internal abstract int RowCount { get; set; }

		internal abstract void Write(MetadataWriter mw);
		internal abstract void Read(MetadataReader mr);

		internal int GetLength(MetadataWriter md)
		{
			return RowCount * GetRowSize(new RowSizeCalc(md));
		}

		protected abstract int GetRowSize(RowSizeCalc rsc);

		protected sealed class RowSizeCalc
		{
			private readonly MetadataWriter mw;
			private int size;

			internal RowSizeCalc(MetadataWriter mw)
			{
				this.mw = mw;
			}

			internal RowSizeCalc AddFixed(int size)
			{
				this.size += size;
				return this;
			}

			internal RowSizeCalc WriteStringIndex()
			{
				if (mw.bigStrings)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteGuidIndex()
			{
				if (mw.bigGuids)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteBlobIndex()
			{
				if (mw.bigBlobs)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteTypeDefOrRef()
			{
				if (mw.bigTypeDefOrRef)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteField()
			{
				if (mw.bigField)
				{
					size += 4;
				}
				else
				{
					size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteMethodDef()
			{
				if (mw.bigMethodDef)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteParam()
			{
				if (mw.bigParam)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteResolutionScope()
			{
				if (mw.bigResolutionScope)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteMemberRefParent()
			{
				if (mw.bigMemberRefParent)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteHasCustomAttribute()
			{
				if (mw.bigHasCustomAttribute)
				{
					size += 4;
				}
				else
				{
					size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteCustomAttributeType()
			{
				if (mw.bigCustomAttributeType)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteHasConstant()
			{
				if (mw.bigHasConstant)
				{
					size += 4;
				}
				else
				{
					size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteTypeDef()
			{
				if (mw.bigTypeDef)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteMethodDefOrRef()
			{
				if (mw.bigMethodDefOrRef)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteEvent()
			{
				if (mw.bigEvent)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteProperty()
			{
				if (mw.bigProperty)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteHasSemantics()
			{
				if (mw.bigHasSemantics)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteImplementation()
			{
				if (mw.bigImplementation)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteTypeOrMethodDef()
			{
				if (mw.bigTypeOrMethodDef)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteGenericParam()
			{
				if (mw.bigGenericParam)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteHasDeclSecurity()
			{
				if (mw.bigHasDeclSecurity)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteMemberForwarded()
			{
				if (mw.bigMemberForwarded)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteModuleRef()
			{
				if (mw.bigModuleRef)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal RowSizeCalc WriteHasFieldMarshal()
			{
				if (mw.bigHasFieldMarshal)
				{
					this.size += 4;
				}
				else
				{
					this.size += 2;
				}
				return this;
			}

			internal int Value
			{
				get { return size; }
			}
		}
	}

	abstract class Table<T> : Table
	{
		internal T[] records = Empty<T>.Array;
		protected int rowCount;

		internal sealed override int RowCount
		{
			get { return rowCount; }
			set { rowCount = value; records = new T[value]; }
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			throw new InvalidOperationException();
		}

		internal int AddRecord(T newRecord)
		{
			if (rowCount == records.Length)
			{
				Array.Resize(ref records, Math.Max(16, records.Length * 2));
			}
			records[rowCount++] = newRecord;
			return rowCount;
		}

		internal int AddVirtualRecord()
		{
			return ++rowCount;
		}

		internal override void Write(MetadataWriter mw)
		{
			throw new InvalidOperationException();
		}
	}

	abstract class SortedTable<T> : Table<T>
		where T : SortedTable<T>.IRecord
	{
		internal interface IRecord
		{
			int SortKey { get; }
			int FilterKey { get; }
		}

		internal struct Enumerable
		{
			private readonly SortedTable<T> table;
			private readonly int token;

			internal Enumerable(SortedTable<T> table, int token)
			{
				this.table = table;
				this.token = token;
			}

			public Enumerator GetEnumerator()
			{
				T[] records = table.records;
				if (!table.Sorted)
				{
					return new Enumerator(records, table.RowCount - 1, -1, token);
				}
				int index = BinarySearch(records, table.RowCount, token & 0xFFFFFF);
				if (index < 0)
				{
					return new Enumerator(null, 0, 1, -1);
				}
				int start = index;
				while (start > 0 && (records[start - 1].FilterKey & 0xFFFFFF) == (token & 0xFFFFFF))
				{
					start--;
				}
				int end = index;
				int max = table.RowCount - 1;
				while (end < max && (records[end + 1].FilterKey & 0xFFFFFF) == (token & 0xFFFFFF))
				{
					end++;
				}
				return new Enumerator(records, end, start - 1, token);
			}

			private static int BinarySearch(T[] records, int length, int maskedToken)
			{
				int min = 0;
				int max = length - 1;
				while (min <= max)
				{
					int mid = min + ((max - min) / 2);
					int maskedValue = records[mid].FilterKey & 0xFFFFFF;
					if (maskedToken == maskedValue)
					{
						return mid;
					}
					else if (maskedToken < maskedValue)
					{
						max = mid - 1;
					}
					else
					{
						min = mid + 1;
					}
				}
				return -1;
			}
		}

		internal struct Enumerator
		{
			private readonly T[] records;
			private readonly int token;
			private readonly int max;
			private int index;

			internal Enumerator(T[] records, int max, int index, int token)
			{
				this.records = records;
				this.token = token;
				this.max = max;
				this.index = index;
			}

			public int Current
			{
				get { return index; }
			}

			public bool MoveNext()
			{
				while (index < max)
				{
					index++;
					if (records[index].FilterKey == token)
					{
						return true;
					}
				}
				return false;
			}
		}

		internal Enumerable Filter(int token)
		{
			return new Enumerable(this, token);
		}

		protected void Sort()
		{
			ulong[] map = new ulong[rowCount];
			for (uint i = 0; i < map.Length; i++)
			{
				map[i] = ((ulong)records[i].SortKey << 32) | i;
			}
			Array.Sort(map);
			T[] newRecords = new T[rowCount];
			for (int i = 0; i < map.Length; i++)
			{
				newRecords[i] = records[(int)map[i]];
			}
			records = newRecords;
		}
	}

	sealed class ModuleTable : Table<ModuleTable.Record>
	{
		internal const int Index = 0x00;

		internal struct Record
		{
			internal short Generation;
			internal int Name; // -> StringHeap
			internal int Mvid; // -> GuidHeap
			internal int EncId; // -> GuidHeap
			internal int EncBaseId; // -> GuidHeap
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Generation = mr.ReadInt16();
				records[i].Name = mr.ReadStringIndex();
				records[i].Mvid = mr.ReadGuidIndex();
				records[i].EncId = mr.ReadGuidIndex();
				records[i].EncBaseId = mr.ReadGuidIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Generation);
				mw.WriteStringIndex(records[i].Name);
				mw.WriteGuidIndex(records[i].Mvid);
				mw.WriteGuidIndex(records[i].EncId);
				mw.WriteGuidIndex(records[i].EncBaseId);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(2)
				.WriteStringIndex()
				.WriteGuidIndex()
				.WriteGuidIndex()
				.WriteGuidIndex()
				.Value;
		}

		internal void Add(short generation, int name, int mvid, int encid, int encbaseid)
		{
			Record record = new Record();
			record.Generation = generation;
			record.Name = name;
			record.Mvid = mvid;
			record.EncId = encid;
			record.EncBaseId = encbaseid;
			AddRecord(record);
		}
	}

	sealed class TypeRefTable : Table<TypeRefTable.Record>
	{
		internal const int Index = 0x01;

		internal struct Record
		{
			internal int ResolutionScope;
			internal int TypeName;
			internal int TypeNamespace;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].ResolutionScope = mr.ReadResolutionScope();
				records[i].TypeName = mr.ReadStringIndex();
				records[i].TypeNamespace = mr.ReadStringIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteResolutionScope(records[i].ResolutionScope);
				mw.WriteStringIndex(records[i].TypeName);
				mw.WriteStringIndex(records[i].TypeNamespace);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteResolutionScope()
				.WriteStringIndex()
				.WriteStringIndex()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].ResolutionScope);
			}
		}
	}

	sealed class TypeDefTable : Table<TypeDefTable.Record>
	{
		internal const int Index = 0x02;

		internal struct Record
		{
			internal int Flags;
			internal int TypeName;
			internal int TypeNamespace;
			internal int Extends;
			internal int FieldList;
			internal int MethodList;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Flags = mr.ReadInt32();
				records[i].TypeName = mr.ReadStringIndex();
				records[i].TypeNamespace = mr.ReadStringIndex();
				records[i].Extends = mr.ReadTypeDefOrRef();
				records[i].FieldList = mr.ReadField();
				records[i].MethodList = mr.ReadMethodDef();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			mw.ModuleBuilder.WriteTypeDefTable(mw);
		}

		internal int AllocToken()
		{
			return 0x02000000 + AddVirtualRecord();
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(4)
				.WriteStringIndex()
				.WriteStringIndex()
				.WriteTypeDefOrRef()
				.WriteField()
				.WriteMethodDef()
				.Value;
		}
	}

	sealed class FieldPtrTable : Table<int>
	{
		internal const int Index = 0x03;

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i] = mr.ReadField();
			}
		}
	}

	sealed class FieldTable : Table<FieldTable.Record>
	{
		internal const int Index = 0x04;

		internal struct Record
		{
			internal short Flags;
			internal int Name;
			internal int Signature;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Flags = mr.ReadInt16();
				records[i].Name = mr.ReadStringIndex();
				records[i].Signature = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			mw.ModuleBuilder.WriteFieldTable(mw);
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(2)
				.WriteStringIndex()
				.WriteBlobIndex()
				.Value;
		}
	}

	sealed class MethodPtrTable : Table<int>
	{
		internal const int Index = 0x05;

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i] = mr.ReadMethodDef();
			}
		}
	}

	sealed class MethodDefTable : Table<MethodDefTable.Record>
	{
		internal const int Index = 0x06;
		private int baseRVA;

		internal struct Record
		{
			internal int RVA;
			internal short ImplFlags;
			internal short Flags;
			internal int Name;
			internal int Signature;
			internal int ParamList;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].RVA = mr.ReadInt32();
				records[i].ImplFlags = mr.ReadInt16();
				records[i].Flags = mr.ReadInt16();
				records[i].Name = mr.ReadStringIndex();
				records[i].Signature = mr.ReadBlobIndex();
				records[i].ParamList = mr.ReadParam();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			mw.ModuleBuilder.WriteMethodDefTable(baseRVA, mw);
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(8)
				.WriteStringIndex()
				.WriteBlobIndex()
				.WriteParam()
				.Value;
		}

		internal void Fixup(TextSection code)
		{
			baseRVA = (int)code.MethodBodiesRVA;
		}
	}

	sealed class ParamPtrTable : Table<int>
	{
		internal const int Index = 0x07;

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i] = mr.ReadParam();
			}
		}
	}

	sealed class ParamTable : Table<ParamTable.Record>
	{
		internal const int Index = 0x08;

		internal struct Record
		{
			internal short Flags;
			internal short Sequence;
			internal int Name;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Flags = mr.ReadInt16();
				records[i].Sequence = mr.ReadInt16();
				records[i].Name = mr.ReadStringIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			mw.ModuleBuilder.WriteParamTable(mw);
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(4)
				.WriteStringIndex()
				.Value;
		}
	}

	sealed class InterfaceImplTable : SortedTable<InterfaceImplTable.Record>
	{
		internal const int Index = 0x09;

		internal struct Record : IRecord
		{
			internal int Class;
			internal int Interface;

			int IRecord.SortKey
			{
				get { return Class; }
			}

			int IRecord.FilterKey
			{
				get { return Class; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Class = mr.ReadTypeDef();
				records[i].Interface = mr.ReadTypeDefOrRef();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteTypeDef(records[i].Class);
				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteTypeDef()
				.WriteTypeDefOrRef()
				.Value;
		}

		internal void Fixup()
		{
			for (int i = 0; i < rowCount; i++)
			{
				int token = records[i].Interface;
				switch (token >> 24)
				{
					case 0:
						break;
					case TypeDefTable.Index:
						token = (token & 0xFFFFFF) << 2 | 0;
						break;
					case TypeRefTable.Index:
						token = (token & 0xFFFFFF) << 2 | 1;
						break;
					case TypeSpecTable.Index:
						token = (token & 0xFFFFFF) << 2 | 2;
						break;
					default:
						throw new InvalidOperationException();
				}
				records[i].Interface = token;
			}
			// LAMESPEC the CLI spec says that InterfaceImpl should be sorted by { Class, Interface },
			// but it appears to only be necessary to sort by Class (and csc emits InterfaceImpl records in
			// source file order, so to be able to support round tripping, we need to retain ordering as well).
			Sort();
		}
	}

	sealed class MemberRefTable : Table<MemberRefTable.Record>
	{
		internal const int Index = 0x0A;

		internal struct Record
		{
			internal int Class;
			internal int Name;
			internal int Signature;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Class = mr.ReadMemberRefParent();
				records[i].Name = mr.ReadStringIndex();
				records[i].Signature = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteMemberRefParent(records[i].Class);
				mw.WriteStringIndex(records[i].Name);
				mw.WriteBlobIndex(records[i].Signature);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteMemberRefParent()
				.WriteStringIndex()
				.WriteBlobIndex()
				.Value;
		}

		internal int FindOrAddRecord(Record record)
		{
			for (int i = 0; i < rowCount; i++)
			{
				if (records[i].Class == record.Class
					&& records[i].Name == record.Name
					&& records[i].Signature == record.Signature)
				{
					return i + 1;
				}
			}
			return AddRecord(record);
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].Class);
			}
		}
	}

	sealed class ConstantTable : SortedTable<ConstantTable.Record>
	{
		internal const int Index = 0x0B;

		internal struct Record : IRecord
		{
			internal short Type;
			internal int Parent;
			internal int Value;

			int IRecord.SortKey
			{
				get { return EncodeHasConstant(Parent); }
			}

			int IRecord.FilterKey
			{
				get { return Parent; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Type = mr.ReadInt16();
				records[i].Parent = mr.ReadHasConstant();
				records[i].Value = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Type);
				mw.WriteHasConstant(records[i].Parent);
				mw.WriteBlobIndex(records[i].Value);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(2)
				.WriteHasConstant()
				.WriteBlobIndex()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].Parent);
			}
			Sort();
		}

		internal static int EncodeHasConstant(int token)
		{
			switch (token >> 24)
			{
				case FieldTable.Index:
					return (token & 0xFFFFFF) << 2 | 0;
				case ParamTable.Index:
					return (token & 0xFFFFFF) << 2 | 1;
				case PropertyTable.Index:
					return (token & 0xFFFFFF) << 2 | 2;
				default:
					throw new InvalidOperationException();
			}
		}

		internal object GetRawConstantValue(Module module, int parent)
		{
			foreach (int i in Filter(parent))
			{
				ByteReader br = module.GetBlob(module.Constant.records[i].Value);
				switch (module.Constant.records[i].Type)
				{
					// see ModuleBuilder.AddConstant for the encodings
					case Signature.ELEMENT_TYPE_BOOLEAN:
						return br.ReadByte() != 0;
					case Signature.ELEMENT_TYPE_I1:
						return br.ReadSByte();
					case Signature.ELEMENT_TYPE_I2:
						return br.ReadInt16();
					case Signature.ELEMENT_TYPE_I4:
						return br.ReadInt32();
					case Signature.ELEMENT_TYPE_I8:
						return br.ReadInt64();
					case Signature.ELEMENT_TYPE_U1:
						return br.ReadByte();
					case Signature.ELEMENT_TYPE_U2:
						return br.ReadUInt16();
					case Signature.ELEMENT_TYPE_U4:
						return br.ReadUInt32();
					case Signature.ELEMENT_TYPE_U8:
						return br.ReadUInt64();
					case Signature.ELEMENT_TYPE_R4:
						return br.ReadSingle();
					case Signature.ELEMENT_TYPE_R8:
						return br.ReadDouble();
					case Signature.ELEMENT_TYPE_CHAR:
						return br.ReadChar();
					case Signature.ELEMENT_TYPE_STRING:
						{
							char[] chars = new char[br.Length / 2];
							for (int j = 0; j < chars.Length; j++)
							{
								chars[j] = br.ReadChar();
							}
							return new String(chars);
						}
					case Signature.ELEMENT_TYPE_CLASS:
						if (br.ReadInt32() != 0)
						{
							throw new BadImageFormatException();
						}
						return null;
					default:
						throw new BadImageFormatException();
				}
			}
			throw new InvalidOperationException();
		}
	}

	sealed class CustomAttributeTable : SortedTable<CustomAttributeTable.Record>
	{
		internal const int Index = 0x0C;

		internal struct Record : IRecord
		{
			internal int Parent;
			internal int Type;
			internal int Value;

			int IRecord.SortKey
			{
				get { return EncodeHasCustomAttribute(Parent); }
			}

			int IRecord.FilterKey
			{
				get { return Parent; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Parent = mr.ReadHasCustomAttribute();
				records[i].Type = mr.ReadCustomAttributeType();
				records[i].Value = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteHasCustomAttribute(records[i].Parent);
				mw.WriteCustomAttributeType(records[i].Type);
				mw.WriteBlobIndex(records[i].Value);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteHasCustomAttribute()
				.WriteCustomAttributeType()
				.WriteBlobIndex()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			int[] genericParamFixup = moduleBuilder.GenericParam.GetIndexFixup();
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].Type);
				moduleBuilder.FixupPseudoToken(ref records[i].Parent);
				if (records[i].Parent >> 24 == GenericParamTable.Index)
				{
					records[i].Parent = (GenericParamTable.Index << 24) + genericParamFixup[(records[i].Parent & 0xFFFFFF) - 1] + 1;
				}
				// TODO if we ever add support for custom attributes on DeclSecurity or GenericParamConstraint
				// we need to fix them up here (because they are sorted tables, like GenericParam)
			}
			Sort();
		}

		internal static int EncodeHasCustomAttribute(int token)
		{
			switch (token >> 24)
			{
				case MethodDefTable.Index:
					return (token & 0xFFFFFF) << 5 | 0;
				case FieldTable.Index:
					return (token & 0xFFFFFF) << 5 | 1;
				case TypeRefTable.Index:
					return (token & 0xFFFFFF) << 5 | 2;
				case TypeDefTable.Index:
					return (token & 0xFFFFFF) << 5 | 3;
				case ParamTable.Index:
					return (token & 0xFFFFFF) << 5 | 4;
				case InterfaceImplTable.Index:
					return (token & 0xFFFFFF) << 5 | 5;
				case MemberRefTable.Index:
					return (token & 0xFFFFFF) << 5 | 6;
				case ModuleTable.Index:
					return (token & 0xFFFFFF) << 5 | 7;
				// LAMESPEC spec calls this Permission table
				case DeclSecurityTable.Index:
					//return (token & 0xFFFFFF) << 5 | 8;
					throw new NotImplementedException();
				case PropertyTable.Index:
					return (token & 0xFFFFFF) << 5 | 9;
				case EventTable.Index:
					return (token & 0xFFFFFF) << 5 | 10;
				case StandAloneSigTable.Index:
					return (token & 0xFFFFFF) << 5 | 11;
				case ModuleRefTable.Index:
					return (token & 0xFFFFFF) << 5 | 12;
				case TypeSpecTable.Index:
					return (token & 0xFFFFFF) << 5 | 13;
				case AssemblyTable.Index:
					return (token & 0xFFFFFF) << 5 | 14;
				case AssemblyRefTable.Index:
					return (token & 0xFFFFFF) << 5 | 15;
				case FileTable.Index:
					return (token & 0xFFFFFF) << 5 | 16;
				case ExportedTypeTable.Index:
					return (token & 0xFFFFFF) << 5 | 17;
				case ManifestResourceTable.Index:
					return (token & 0xFFFFFF) << 5 | 18;
				case GenericParamTable.Index:
					return (token & 0xFFFFFF) << 5 | 19;
				case GenericParamConstraintTable.Index:
					//return (token & 0xFFFFFF) << 5 | 20;
					throw new NotImplementedException();
				case MethodSpecTable.Index:
					return (token & 0xFFFFFF) << 5 | 21;
				default:
					throw new InvalidOperationException();
			}
		}
	}

	sealed class FieldMarshalTable : SortedTable<FieldMarshalTable.Record>
	{
		internal const int Index = 0x0D;

		internal struct Record : IRecord
		{
			internal int Parent;
			internal int NativeType;

			int IRecord.SortKey
			{
				get { return EncodeHasFieldMarshal(Parent); }
			}

			int IRecord.FilterKey
			{
				get { return Parent; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Parent = mr.ReadHasFieldMarshal();
				records[i].NativeType = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteHasFieldMarshal(records[i].Parent);
				mw.WriteBlobIndex(records[i].NativeType);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteHasFieldMarshal()
				.WriteBlobIndex()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				records[i].Parent = moduleBuilder.ResolvePseudoToken(records[i].Parent);
			}
			Sort();
		}

		internal static int EncodeHasFieldMarshal(int token)
		{
			switch (token >> 24)
			{
				case FieldTable.Index:
					return (token & 0xFFFFFF) << 1 | 0;
				case ParamTable.Index:
					return (token & 0xFFFFFF) << 1 | 1;
				default:
					throw new InvalidOperationException();
			}
		}
	}

	sealed class DeclSecurityTable : SortedTable<DeclSecurityTable.Record>
	{
		internal const int Index = 0x0E;

		internal struct Record : IRecord
		{
			internal short Action;
			internal int Parent;
			internal int PermissionSet;

			int IRecord.SortKey
			{
				get { return Parent; }
			}

			int IRecord.FilterKey
			{
				get { return Parent; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Action = mr.ReadInt16();
				records[i].Parent = mr.ReadHasDeclSecurity();
				records[i].PermissionSet = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Action);
				mw.WriteHasDeclSecurity(records[i].Parent);
				mw.WriteBlobIndex(records[i].PermissionSet);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(2)
				.WriteHasDeclSecurity()
				.WriteBlobIndex()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				int token = records[i].Parent;
				moduleBuilder.FixupPseudoToken(ref token);
				// do the HasDeclSecurity encoding, so that we can sort the table
				switch (token >> 24)
				{
					case TypeDefTable.Index:
						token = (token & 0xFFFFFF) << 2 | 0;
						break;
					case MethodDefTable.Index:
						token = (token & 0xFFFFFF) << 2 | 1;
						break;
					case AssemblyTable.Index:
						token = (token & 0xFFFFFF) << 2 | 2;
						break;
					default:
						throw new InvalidOperationException();
				}
				records[i].Parent = token;
			}
			Sort();
		}
	}

	sealed class ClassLayoutTable : SortedTable<ClassLayoutTable.Record>
	{
		internal const int Index = 0x0f;

		internal struct Record : IRecord
		{
			internal short PackingSize;
			internal int ClassSize;
			internal int Parent;

			int IRecord.SortKey
			{
				get { return Parent; }
			}

			int IRecord.FilterKey
			{
				get { return Parent; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].PackingSize = mr.ReadInt16();
				records[i].ClassSize = mr.ReadInt32();
				records[i].Parent = mr.ReadTypeDef();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			Sort();
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].PackingSize);
				mw.Write(records[i].ClassSize);
				mw.WriteTypeDef(records[i].Parent);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(6)
				.WriteTypeDef()
				.Value;
		}
	}

	sealed class FieldLayoutTable : SortedTable<FieldLayoutTable.Record>
	{
		internal const int Index = 0x10;

		internal struct Record : IRecord
		{
			internal int Offset;
			internal int Field;

			int IRecord.SortKey
			{
				get { return Field; }
			}

			int IRecord.FilterKey
			{
				get { return Field; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Offset = mr.ReadInt32();
				records[i].Field = mr.ReadField();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Offset);
				mw.WriteField(records[i].Field);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(4)
				.WriteField()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field) & 0xFFFFFF;
			}
			Sort();
		}
	}

	sealed class StandAloneSigTable : Table<int>
	{
		internal const int Index = 0x11;

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i] = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteBlobIndex(records[i]);
			}
		}

		protected override int GetRowSize(Table.RowSizeCalc rsc)
		{
			return rsc.WriteBlobIndex().Value;
		}

		internal int FindOrAddRecord(int blob)
		{
			for (int i = 0; i < rowCount; i++)
			{
				if (records[i] == blob)
				{
					return i + 1;
				}
			}
			return AddRecord(blob);
		}
	}

	sealed class EventMapTable : SortedTable<EventMapTable.Record>
	{
		internal const int Index = 0x12;

		internal struct Record : IRecord
		{
			internal int Parent;
			internal int EventList;

			int IRecord.SortKey
			{
				get { return Parent; }
			}

			int IRecord.FilterKey
			{
				get { return Parent; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Parent = mr.ReadTypeDef();
				records[i].EventList = mr.ReadEvent();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteTypeDef(records[i].Parent);
				mw.WriteEvent(records[i].EventList);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteTypeDef()
				.WriteEvent()
				.Value;
		}
	}

	sealed class EventPtrTable : Table<int>
	{
		internal const int Index = 0x13;

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i] = mr.ReadEvent();
			}
		}
	}

	sealed class EventTable : Table<EventTable.Record>
	{
		internal const int Index = 0x14;

		internal struct Record
		{
			internal short EventFlags;
			internal int Name;
			internal int EventType;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].EventFlags = mr.ReadInt16();
				records[i].Name = mr.ReadStringIndex();
				records[i].EventType = mr.ReadTypeDefOrRef();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].EventFlags);
				mw.WriteStringIndex(records[i].Name);
				mw.WriteTypeDefOrRef(records[i].EventType);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(2)
				.WriteStringIndex()
				.WriteTypeDefOrRef()
				.Value;
		}
	}

	sealed class PropertyMapTable : SortedTable<PropertyMapTable.Record>
	{
		internal const int Index = 0x15;

		internal struct Record : IRecord
		{
			internal int Parent;
			internal int PropertyList;

			int IRecord.SortKey
			{
				get { return Parent; }
			}

			int IRecord.FilterKey
			{
				get { return Parent; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Parent = mr.ReadTypeDef();
				records[i].PropertyList = mr.ReadProperty();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteTypeDef(records[i].Parent);
				mw.WriteProperty(records[i].PropertyList);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteTypeDef()
				.WriteProperty()
				.Value;
		}
	}

	sealed class PropertyPtrTable : Table<int>
	{
		internal const int Index = 0x16;

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i] = mr.ReadProperty();
			}
		}
	}

	sealed class PropertyTable : Table<PropertyTable.Record>
	{
		internal const int Index = 0x17;

		internal struct Record
		{
			internal short Flags;
			internal int Name;
			internal int Type;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Flags = mr.ReadInt16();
				records[i].Name = mr.ReadStringIndex();
				records[i].Type = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Flags);
				mw.WriteStringIndex(records[i].Name);
				mw.WriteBlobIndex(records[i].Type);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(2)
				.WriteStringIndex()
				.WriteBlobIndex()
				.Value;
		}
	}

	sealed class MethodSemanticsTable : SortedTable<MethodSemanticsTable.Record>
	{
		internal const int Index = 0x18;

		// semantics
		internal const short Setter = 0x0001;
		internal const short Getter = 0x0002;
		internal const short Other = 0x0004;
		internal const short AddOn = 0x0008;
		internal const short RemoveOn = 0x0010;
		internal const short Fire = 0x0020;

		internal struct Record : IRecord
		{
			internal short Semantics;
			internal int Method;
			internal int Association;

			int IRecord.SortKey
			{
				get { return Association; }
			}

			int IRecord.FilterKey
			{
				get { return Association; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Semantics = mr.ReadInt16();
				records[i].Method = mr.ReadMethodDef();
				records[i].Association = mr.ReadHasSemantics();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Semantics);
				mw.WriteMethodDef(records[i].Method);
				mw.WriteHasSemantics(records[i].Association);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(2)
				.WriteMethodDef()
				.WriteHasSemantics()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].Method);
				int token = records[i].Association;
				// do the HasSemantics encoding, so that we can sort the table
				switch (token >> 24)
				{
					case EventTable.Index:
						token = (token & 0xFFFFFF) << 1 | 0;
						break;
					case PropertyTable.Index:
						token = (token & 0xFFFFFF) << 1 | 1;
						break;
					default:
						throw new InvalidOperationException();
				}
				records[i].Association = token;
			}
			Sort();
		}

		internal MethodInfo GetMethod(Module module, int token, bool nonPublic, short semantics)
		{
			foreach (int i in Filter(token))
			{
				if ((records[i].Semantics & semantics) != 0)
				{
					MethodBase method = module.ResolveMethod((MethodDefTable.Index << 24) + records[i].Method);
					if (nonPublic || method.IsPublic)
					{
						return (MethodInfo)method;
					}
				}
			}
			return null;
		}

		internal MethodInfo[] GetMethods(Module module, int token, bool nonPublic, short semantics)
		{
			List<MethodInfo> methods = new List<MethodInfo>();
			foreach (int i in Filter(token))
			{
				if ((records[i].Semantics & semantics) != 0)
				{
					MethodInfo method = (MethodInfo)module.ResolveMethod((MethodDefTable.Index << 24) + records[i].Method);
					if (nonPublic || method.IsPublic)
					{
						methods.Add(method);
					}
				}
			}
			return methods.ToArray();
		}

		internal void ComputeFlags(Module module, int token, out bool isPublic, out bool isNonPrivate, out bool isStatic)
		{
			isPublic = false;
			isNonPrivate = false;
			isStatic = false;
			foreach (int i in Filter(token))
			{
				MethodBase method = module.ResolveMethod((MethodDefTable.Index << 24) + records[i].Method);
				isPublic |= method.IsPublic;
				isNonPrivate |= (method.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private;
				isStatic |= method.IsStatic;
			}
		}
	}

	sealed class MethodImplTable : SortedTable<MethodImplTable.Record>
	{
		internal const int Index = 0x19;

		internal struct Record : IRecord
		{
			internal int Class;
			internal int MethodBody;
			internal int MethodDeclaration;

			int IRecord.SortKey
			{
				get { return Class; }
			}

			int IRecord.FilterKey
			{
				get { return Class; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Class = mr.ReadTypeDef();
				records[i].MethodBody = mr.ReadMethodDefOrRef();
				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteTypeDef(records[i].Class);
				mw.WriteMethodDefOrRef(records[i].MethodBody);
				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteTypeDef()
				.WriteMethodDefOrRef()
				.WriteMethodDefOrRef()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].MethodBody);
				moduleBuilder.FixupPseudoToken(ref records[i].MethodDeclaration);
			}
			Sort();
		}
	}

	sealed class ModuleRefTable : Table<int>
	{
		internal const int Index = 0x1A;

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i] = mr.ReadStringIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteStringIndex(records[i]);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteStringIndex()
				.Value;
		}

		internal int FindOrAddRecord(int str)
		{
			for (int i = 0; i < rowCount; i++)
			{
				if (records[i] == str)
				{
					return i + 1;
				}
			}
			return AddRecord(str);
		}
	}

	sealed class TypeSpecTable : Table<int>
	{
		internal const int Index = 0x1B;

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i] = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteBlobIndex(records[i]);
			}
		}

		protected override int GetRowSize(Table.RowSizeCalc rsc)
		{
			return rsc.WriteBlobIndex().Value;
		}
	}

	sealed class ImplMapTable : SortedTable<ImplMapTable.Record>
	{
		internal const int Index = 0x1C;

		internal struct Record : IRecord
		{
			internal short MappingFlags;
			internal int MemberForwarded;
			internal int ImportName;
			internal int ImportScope;

			int IRecord.SortKey
			{
				get { return MemberForwarded; }
			}

			int IRecord.FilterKey
			{
				get { return MemberForwarded; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].MappingFlags = mr.ReadInt16();
				records[i].MemberForwarded = mr.ReadMemberForwarded();
				records[i].ImportName = mr.ReadStringIndex();
				records[i].ImportScope = mr.ReadModuleRef();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].MappingFlags);
				mw.WriteMemberForwarded(records[i].MemberForwarded);
				mw.WriteStringIndex(records[i].ImportName);
				mw.WriteModuleRef(records[i].ImportScope);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(2)
				.WriteMemberForwarded()
				.WriteStringIndex()
				.WriteModuleRef()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].MemberForwarded);
			}
			Sort();
		}
	}

	sealed class FieldRVATable : SortedTable<FieldRVATable.Record>
	{
		internal const int Index = 0x1D;

		internal struct Record : IRecord
		{
			internal int RVA;		// we set the high bit to signify that the RVA is in the CIL stream (instead of .sdata)
			internal int Field;

			int IRecord.SortKey
			{
				get { return Field; }
			}

			int IRecord.FilterKey
			{
				get { return Field; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].RVA = mr.ReadInt32();
				records[i].Field = mr.ReadField();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].RVA);
				mw.WriteField(records[i].Field);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(4)
				.WriteField()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder, int sdataRVA, int cilRVA)
		{
			for (int i = 0; i < rowCount; i++)
			{
				if (records[i].RVA < 0)
				{
					records[i].RVA = (records[i].RVA & 0x7fffffff) + cilRVA;
				}
				else
				{
					records[i].RVA += sdataRVA;
				}
				moduleBuilder.FixupPseudoToken(ref records[i].Field);
			}
			Sort();
		}
	}

	sealed class AssemblyTable : Table<AssemblyTable.Record>
	{
		internal const int Index = 0x20;

		internal struct Record
		{
			internal int HashAlgId;
			internal ushort MajorVersion;
			internal ushort MinorVersion;
			internal ushort BuildNumber;
			internal ushort RevisionNumber;
			internal int Flags;
			internal int PublicKey;
			internal int Name;
			internal int Culture;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].HashAlgId = mr.ReadInt32();
				records[i].MajorVersion = mr.ReadUInt16();
				records[i].MinorVersion = mr.ReadUInt16();
				records[i].BuildNumber = mr.ReadUInt16();
				records[i].RevisionNumber = mr.ReadUInt16();
				records[i].Flags = mr.ReadInt32();
				records[i].PublicKey = mr.ReadBlobIndex();
				records[i].Name = mr.ReadStringIndex();
				records[i].Culture = mr.ReadStringIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].HashAlgId);
				mw.Write(records[i].MajorVersion);
				mw.Write(records[i].MinorVersion);
				mw.Write(records[i].BuildNumber);
				mw.Write(records[i].RevisionNumber);
				mw.Write(records[i].Flags);
				mw.WriteBlobIndex(records[i].PublicKey);
				mw.WriteStringIndex(records[i].Name);
				mw.WriteStringIndex(records[i].Culture);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(16)
				.WriteBlobIndex()
				.WriteStringIndex()
				.WriteStringIndex()
				.Value;
		}
	}

	sealed class AssemblyRefTable : Table<AssemblyRefTable.Record>
	{
		internal const int Index = 0x23;

		internal struct Record
		{
			internal ushort MajorVersion;
			internal ushort MinorVersion;
			internal ushort BuildNumber;
			internal ushort RevisionNumber;
			internal int Flags;
			internal int PublicKeyOrToken;
			internal int Name;
			internal int Culture;
			internal int HashValue;
		}

		internal int FindOrAddRecord(Record rec)
		{
			for (int i = 0; i < rowCount; i++)
			{
				// note that we ignore HashValue here!
				if (records[i].Name == rec.Name
					&& records[i].MajorVersion == rec.MajorVersion
					&& records[i].MinorVersion == rec.MinorVersion
					&& records[i].BuildNumber == rec.BuildNumber
					&& records[i].RevisionNumber == rec.RevisionNumber
					&& records[i].Flags == rec.Flags
					&& records[i].PublicKeyOrToken == rec.PublicKeyOrToken
					&& records[i].Culture == rec.Culture
					)
				{
					return i + 1;
				}
			}
			return AddRecord(rec);
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].MajorVersion = mr.ReadUInt16();
				records[i].MinorVersion = mr.ReadUInt16();
				records[i].BuildNumber = mr.ReadUInt16();
				records[i].RevisionNumber = mr.ReadUInt16();
				records[i].Flags = mr.ReadInt32();
				records[i].PublicKeyOrToken = mr.ReadBlobIndex();
				records[i].Name = mr.ReadStringIndex();
				records[i].Culture = mr.ReadStringIndex();
				records[i].HashValue = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].MajorVersion);
				mw.Write(records[i].MinorVersion);
				mw.Write(records[i].BuildNumber);
				mw.Write(records[i].RevisionNumber);
				mw.Write(records[i].Flags);
				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
				mw.WriteStringIndex(records[i].Name);
				mw.WriteStringIndex(records[i].Culture);
				mw.WriteBlobIndex(records[i].HashValue);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(12)
				.WriteBlobIndex()
				.WriteStringIndex()
				.WriteStringIndex()
				.WriteBlobIndex()
				.Value;
		}
	}

	sealed class FileTable : Table<FileTable.Record>
	{
		internal const int Index = 0x26;

		internal struct Record
		{
			internal int Flags;
			internal int Name;
			internal int HashValue;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Flags = mr.ReadInt32();
				records[i].Name = mr.ReadStringIndex();
				records[i].HashValue = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Flags);
				mw.WriteStringIndex(records[i].Name);
				mw.WriteBlobIndex(records[i].HashValue);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(4)
				.WriteStringIndex()
				.WriteBlobIndex()
				.Value;
		}
	}

	sealed class ExportedTypeTable : Table<ExportedTypeTable.Record>
	{
		internal const int Index = 0x27;

		internal struct Record
		{
			internal int Flags;
			internal int TypeDefId;
			internal int TypeName;
			internal int TypeNamespace;
			internal int Implementation;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Flags = mr.ReadInt32();
				records[i].TypeDefId = mr.ReadInt32();
				records[i].TypeName = mr.ReadStringIndex();
				records[i].TypeNamespace = mr.ReadStringIndex();
				records[i].Implementation = mr.ReadImplementation();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Flags);
				mw.Write(records[i].TypeDefId);
				mw.WriteStringIndex(records[i].TypeName);
				mw.WriteStringIndex(records[i].TypeNamespace);
				mw.WriteImplementation(records[i].Implementation);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(8)
				.WriteStringIndex()
				.WriteStringIndex()
				.WriteImplementation()
				.Value;
		}

		internal int FindOrAddRecord(Record rec)
		{
			for (int i = 0; i < rowCount; i++)
			{
				if (records[i].Implementation == rec.Implementation
					&& records[i].TypeName == rec.TypeName
					&& records[i].TypeNamespace == rec.TypeNamespace)
				{
					return i + 1;
				}
			}
			return AddRecord(rec);
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].Implementation);
			}
		}
	}

	sealed class ManifestResourceTable : Table<ManifestResourceTable.Record>
	{
		internal const int Index = 0x28;

		internal struct Record
		{
			internal int Offset;
			internal int Flags;
			internal int Name;
			internal int Implementation;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Offset = mr.ReadInt32();
				records[i].Flags = mr.ReadInt32();
				records[i].Name = mr.ReadStringIndex();
				records[i].Implementation = mr.ReadImplementation();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Offset);
				mw.Write(records[i].Flags);
				mw.WriteStringIndex(records[i].Name);
				mw.WriteImplementation(records[i].Implementation);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(8)
				.WriteStringIndex()
				.WriteImplementation()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].Implementation);
			}
		}
	}

	sealed class NestedClassTable : SortedTable<NestedClassTable.Record>
	{
		internal const int Index = 0x29;

		internal struct Record : IRecord
		{
			internal int NestedClass;
			internal int EnclosingClass;

			int IRecord.SortKey
			{
				get { return NestedClass; }
			}

			int IRecord.FilterKey
			{
				get { return NestedClass; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].NestedClass = mr.ReadTypeDef();
				records[i].EnclosingClass = mr.ReadTypeDef();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteTypeDef(records[i].NestedClass);
				mw.WriteTypeDef(records[i].EnclosingClass);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteTypeDef()
				.WriteTypeDef()
				.Value;
		}

		internal List<int> GetNestedClasses(int enclosingClass)
		{
			List<int> nestedClasses = new List<int>();
			for (int i = 0; i < rowCount; i++)
			{
				if (records[i].EnclosingClass == enclosingClass)
				{
					nestedClasses.Add(records[i].NestedClass);
				}
			}
			return nestedClasses;
		}
	}

	sealed class GenericParamTable : SortedTable<GenericParamTable.Record>, IComparer<GenericParamTable.Record>
	{
		internal const int Index = 0x2A;

		internal struct Record : IRecord
		{
			internal short Number;
			internal short Flags;
			internal int Owner;
			internal int Name;
			// not part of the table, we use it to be able to fixup the GenericParamConstraint table
			internal int unsortedIndex;

			int IRecord.SortKey
			{
				get { return Owner; }
			}

			int IRecord.FilterKey
			{
				get { return Owner; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Number = mr.ReadInt16();
				records[i].Flags = mr.ReadInt16();
				records[i].Owner = mr.ReadTypeOrMethodDef();
				records[i].Name = mr.ReadStringIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.Write(records[i].Number);
				mw.Write(records[i].Flags);
				mw.WriteTypeOrMethodDef(records[i].Owner);
				mw.WriteStringIndex(records[i].Name);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.AddFixed(4)
				.WriteTypeOrMethodDef()
				.WriteStringIndex()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				int token = records[i].Owner;
				moduleBuilder.FixupPseudoToken(ref token);
				// do the TypeOrMethodDef encoding, so that we can sort the table
				switch (token >> 24)
				{
					case TypeDefTable.Index:
						records[i].Owner = (token & 0xFFFFFF) << 1 | 0;
						break;
					case MethodDefTable.Index:
						records[i].Owner = (token & 0xFFFFFF) << 1 | 1;
						break;
					default:
						throw new InvalidOperationException();
				}
				records[i].unsortedIndex = i;
			}
			// FXBUG the unnecessary (IComparer<Record>) cast is a workaround for a .NET 2.0 C# compiler bug
			Array.Sort(records, 0, rowCount, (IComparer<Record>)this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			if (x.Owner == y.Owner)
			{
				return x.Number == y.Number ? 0 : (x.Number > y.Number ? 1 : -1);
			}
			return x.Owner > y.Owner ? 1 : -1;
		}

		internal void PatchAttribute(int token, GenericParameterAttributes genericParameterAttributes)
		{
			records[(token & 0xFFFFFF) - 1].Flags = (short)genericParameterAttributes;
		}

		internal int[] GetIndexFixup()
		{
			int[] array = new int[rowCount];
			for (int i = 0; i < rowCount; i++)
			{
				array[records[i].unsortedIndex] = i;
			}
			return array;
		}

		internal int FindFirstByOwner(int token)
		{
			foreach (int i in Filter(token))
			{
				return i;
			}
			return -1;
		}
	}

	sealed class MethodSpecTable : Table<MethodSpecTable.Record>
	{
		internal const int Index = 0x2B;

		internal struct Record
		{
			internal int Method;
			internal int Instantiation;
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Method = mr.ReadMethodDefOrRef();
				records[i].Instantiation = mr.ReadBlobIndex();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteMethodDefOrRef(records[i].Method);
				mw.WriteBlobIndex(records[i].Instantiation);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteMethodDefOrRef()
				.WriteBlobIndex()
				.Value;
		}

		internal int FindOrAddRecord(Record record)
		{
			for (int i = 0; i < rowCount; i++)
			{
				if (records[i].Method == record.Method
					&& records[i].Instantiation == record.Instantiation)
				{
					return i + 1;
				}
			}
			return AddRecord(record);
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			for (int i = 0; i < rowCount; i++)
			{
				moduleBuilder.FixupPseudoToken(ref records[i].Method);
			}
		}
	}

	sealed class GenericParamConstraintTable : SortedTable<GenericParamConstraintTable.Record>
	{
		internal const int Index = 0x2C;

		internal struct Record : IRecord
		{
			internal int Owner;
			internal int Constraint;

			int IRecord.SortKey
			{
				get { return Owner; }
			}

			int IRecord.FilterKey
			{
				get { return Owner; }
			}
		}

		internal override void Read(MetadataReader mr)
		{
			for (int i = 0; i < records.Length; i++)
			{
				records[i].Owner = mr.ReadGenericParam();
				records[i].Constraint = mr.ReadTypeDefOrRef();
			}
		}

		internal override void Write(MetadataWriter mw)
		{
			for (int i = 0; i < rowCount; i++)
			{
				mw.WriteGenericParam(records[i].Owner);
				mw.WriteTypeDefOrRef(records[i].Constraint);
			}
		}

		protected override int GetRowSize(RowSizeCalc rsc)
		{
			return rsc
				.WriteGenericParam()
				.WriteTypeDefOrRef()
				.Value;
		}

		internal void Fixup(ModuleBuilder moduleBuilder)
		{
			int[] fixups = moduleBuilder.GenericParam.GetIndexFixup();
			for (int i = 0; i < rowCount; i++)
			{
				records[i].Owner = fixups[records[i].Owner - 1] + 1;
			}
			Sort();
		}
	}
}
@


1.32
log
@Bug fix. Handle custom attributes on DeclSecurity, GenericParam, GenericParamConstraint and MethodSpec tables.
@
text
@d1200 2
d1228 2
a1229 1
					return (token & 0xFFFFFF) << 5 | 8;
d1253 2
a1254 1
					return (token & 0xFFFFFF) << 5 | 20;
@


1.31
log
@Renamed TypeNameSpace to TypeNamespace for consistency.
@
text
@d1224 3
a1226 1
				// Permission (8) table doesn't exist in the spec
d1249 4
@


1.30
log
@Small optimization to table record allocation. Thanks to Marek for the pointer.
@
text
@d621 1
a621 1
			internal int TypeNameSpace;
d630 1
a630 1
				records[i].TypeNameSpace = mr.ReadStringIndex();
d640 1
a640 1
				mw.WriteStringIndex(records[i].TypeNameSpace);
@


1.29
log
@Fixed regression in __TryGetFieldOffset. The FieldLayout.Field field is an index (not a token), except for unsaved modules where it is a pseudo token.
@
text
@d391 1
a391 1
		internal T[] records = new T[1];
d409 1
a409 3
				T[] newarr = new T[records.Length * 2];
				Array.Copy(records, newarr, records.Length);
				records = newarr;
@


1.28
log
@Removed unreachable code.
@
text
@d1502 1
a1502 1
				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
@


1.27
log
@Bug fix. FieldBuilder.GetRawConstantValue() didn't work after saving the module.
@
text
@a1076 1
					break;
a1078 1
					break;
a1080 1
					break;
@


1.26
log
@Optimized table sorting.
@
text
@d1024 1
a1024 1
				get { return Parent; }
d1066 1
a1066 17
				int token = records[i].Parent;
				moduleBuilder.FixupPseudoToken(ref token);
				// do the HasConstant encoding, so that we can sort the table
				switch (token >> 24)
				{
					case FieldTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 2 | 0;
						break;
					case ParamTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 2 | 1;
						break;
					case PropertyTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 2 | 2;
						break;
					default:
						throw new InvalidOperationException();
				}
d1071 18
@


1.25
log
@Bug fix. Don't do the HasCustomAttribute and HasFieldMarshal in the tables, but only when writing the final data. Previously we weren't able to lookup anything in these tables after the module was saved.
@
text
@d428 1
a428 1
	abstract class SortedTable<T> : Table<T>, IComparer<int>
d540 2
a541 2
			int[] map = new int[rowCount];
			for (int i = 0; i < map.Length; i++)
d543 1
a543 1
				map[i] = i;
d545 1
a545 1
			Array.Sort(map, this);
d549 1
a549 1
				newRecords[i] = records[map[i]];
a552 6

		int IComparer<int>.Compare(int x, int y)
		{
			int rc = records[x].SortKey.CompareTo(records[y].SortKey);
			return rc == 0 ? x.CompareTo(y) : rc;
		}
@


1.24
log
@Changed table sort implementation to reuse the ISortKey interface and switched to a stable sort.
@
text
@d429 1
a429 1
		where T : SortedTable<T>.ISortKey
d431 1
a431 1
		internal interface ISortKey
d433 2
a434 1
			int Key { get; }
d461 1
a461 1
				while (start > 0 && (records[start - 1].Key & 0xFFFFFF) == (token & 0xFFFFFF))
d467 1
a467 1
				while (end < max && (records[end + 1].Key & 0xFFFFFF) == (token & 0xFFFFFF))
d481 1
a481 1
					int maskedValue = records[mid].Key & 0xFFFFFF;
d524 1
a524 1
					if (records[index].Key == token)
d556 1
a556 1
			int rc = records[x].Key.CompareTo(records[y].Key);
d883 1
a883 1
		internal struct Record : ISortKey
d888 6
a893 1
			int ISortKey.Key
d1022 1
a1022 1
		internal struct Record : ISortKey
d1028 6
a1033 1
			int ISortKey.Key
d1152 1
a1152 1
		internal struct Record : ISortKey
d1158 6
a1163 1
			int ISortKey.Key
d1204 2
a1205 4
				int token = records[i].Parent;
				moduleBuilder.FixupPseudoToken(ref token);
				// do the HasCustomAttribute encoding, so that we can sort the table
				switch (token >> 24)
d1207 1
a1207 60
					case MethodDefTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 0;
						break;
					case FieldTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 1;
						break;
					case TypeRefTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 2;
						break;
					case TypeDefTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 3;
						break;
					case ParamTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 4;
						break;
					case InterfaceImplTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 5;
						break;
					case MemberRefTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 6;
						break;
					case ModuleTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 7;
						break;
					// Permission (8) table doesn't exist in the spec
					case PropertyTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 9;
						break;
					case EventTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 10;
						break;
					case StandAloneSigTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 11;
						break;
					case ModuleRefTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 12;
						break;
					case TypeSpecTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 13;
						break;
					case AssemblyTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 14;
						break;
					case AssemblyRefTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 15;
						break;
					case FileTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 16;
						break;
					case ExportedTypeTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 17;
						break;
					case ManifestResourceTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 5 | 18;
						break;
					case GenericParamTable.Index:
						records[i].Parent = (genericParamFixup[(token & 0xFFFFFF) - 1] + 1) << 5 | 19;
						break;
					default:
						throw new InvalidOperationException();
d1212 48
d1266 1
a1266 1
		internal struct Record : ISortKey
d1271 6
a1276 1
			int ISortKey.Key
d1312 1
a1312 13
				int token = moduleBuilder.ResolvePseudoToken(records[i].Parent);
				// do the HasFieldMarshal encoding, so that we can sort the table
				switch (token >> 24)
				{
					case FieldTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 1 | 0;
						break;
					case ParamTable.Index:
						records[i].Parent = (token & 0xFFFFFF) << 1 | 1;
						break;
					default:
						throw new InvalidOperationException();
				}
d1316 13
d1335 1
a1335 1
		internal struct Record : ISortKey
d1341 6
a1346 1
			int ISortKey.Key
d1412 1
a1412 1
		internal struct Record : ISortKey
d1418 6
a1423 1
			int ISortKey.Key
d1463 1
a1463 1
		internal struct Record : ISortKey
d1468 6
a1473 1
			int ISortKey.Key
d1557 1
a1557 1
		internal struct Record : ISortKey
d1562 6
a1567 1
			int ISortKey.Key
d1658 1
a1658 1
		internal struct Record : ISortKey
d1663 6
a1668 1
			int ISortKey.Key
d1767 1
a1767 1
		internal struct Record : ISortKey
d1773 6
a1778 1
			int ISortKey.Key
d1888 1
a1888 1
		internal struct Record : ISortKey
d1894 6
a1899 1
			int ISortKey.Key
d2015 1
a2015 1
		internal struct Record : ISortKey
d2022 6
a2027 1
			int ISortKey.Key
d2079 1
a2079 1
		internal struct Record : ISortKey
d2084 6
a2089 1
			int ISortKey.Key
d2448 1
a2448 1
		internal struct Record : ISortKey
d2453 6
a2458 1
			int ISortKey.Key
d2508 1
a2508 1
		internal struct Record : ISortKey
d2517 6
a2522 1
			int ISortKey.Key
d2679 1
a2679 1
		internal struct Record : ISortKey
d2684 6
a2689 1
			int ISortKey.Key
@


1.23
log
@Use FixupPseudoToken() method instead of test/resolve pattern.
@
text
@a425 36

#if STABLE_SORT
		private struct OrdinalWrapper
		{
			internal int ordinal;
			internal T value;
		}

		protected void Sort(IComparer<T> comparer)
		{
			OrdinalWrapper[] items = new OrdinalWrapper[rowCount];
			for (int i = 0; i < items.Length; i++)
			{
				items[i].ordinal = i;
				items[i].value = records[i];
			}
			Array.Sort(items, delegate(OrdinalWrapper x, OrdinalWrapper y)
			{
				int res = comparer.Compare(x.value, y.value);
				if (res == 0)
				{
					res = x.ordinal.CompareTo(y.ordinal);
				}
				return res;
			});
			for (int i = 0; i < items.Length; i++)
			{
				records[i] = items[i].value;
			}
		}
#else
		protected void Sort(IComparer<T> comparer)
		{
			Array.Sort(records, 0, rowCount, comparer);
		}
#endif
d428 1
a428 1
	abstract class SortedTable<T> : Table<T>
d536 22
d878 1
a878 1
	sealed class InterfaceImplTable : SortedTable<InterfaceImplTable.Record>, IComparer<InterfaceImplTable.Record>
d942 4
a945 16
			Sort(this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			if (x.Class == y.Class)
			{
#if STABLE_SORT
				return 0;
#else
				// LAMESPEC the CLI spec says that InterfaceImpl should be sorted by { Class, Interface }, but it appears to be
				// only necessary to sort by Class.
				return x.Interface == y.Interface ? 0 : (x.Interface > y.Interface ? 1 : -1);
#endif
			}
			return x.Class > y.Class ? 1 : -1;
d1012 1
a1012 1
	sealed class ConstantTable : SortedTable<ConstantTable.Record>, IComparer<ConstantTable.Record>
d1079 1
a1079 6
			Array.Sort(records, 0, rowCount, this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : -1);
d1137 1
a1137 1
	sealed class CustomAttributeTable : SortedTable<CustomAttributeTable.Record>, IComparer<CustomAttributeTable.Record>
d1255 1
a1255 6
			Sort(this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : -1);
d1259 1
a1259 1
	sealed class FieldMarshalTable : SortedTable<FieldMarshalTable.Record>, IComparer<FieldMarshalTable.Record>
d1318 1
a1318 6
			Array.Sort(records, 0, rowCount, this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : -1);
d1322 1
a1322 1
	sealed class DeclSecurityTable : SortedTable<DeclSecurityTable.Record>, IComparer<DeclSecurityTable.Record>
d1390 1
a1390 6
			Sort(this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : -1);
d1394 1
a1394 1
	sealed class ClassLayoutTable : SortedTable<ClassLayoutTable.Record>, IComparer<ClassLayoutTable.Record>
d1422 1
a1422 1
			Array.Sort(records, 0, rowCount, this);
a1437 5

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Parent == y.Parent ? 0 : (x.Parent > y.Parent ? 1 : -1);
		}
d1440 1
a1440 1
	sealed class FieldLayoutTable : SortedTable<FieldLayoutTable.Record>, IComparer<FieldLayoutTable.Record>
d1487 1
a1487 6
			Array.Sort(records, 0, rowCount, this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Field == y.Field ? 0 : (x.Field > y.Field ? 1 : -1);
d1721 1
a1721 1
	sealed class MethodSemanticsTable : SortedTable<MethodSemanticsTable.Record>, IComparer<MethodSemanticsTable.Record>
d1794 1
a1794 6
			Sort(this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Association == y.Association ? 0 : (x.Association > y.Association ? 1 : -1);
d1845 1
a1845 1
	sealed class MethodImplTable : SortedTable<MethodImplTable.Record>, IComparer<MethodImplTable.Record>
d1897 1
a1897 6
			Sort(this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Class == y.Class ? 0 : (x.Class > y.Class ? 1 : -1);
d1967 1
a1967 1
	sealed class ImplMapTable : SortedTable<ImplMapTable.Record>, IComparer<ImplMapTable.Record>
d2022 1
a2022 6
			Array.Sort(records, 0, rowCount, this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.MemberForwarded == y.MemberForwarded ? 0 : (x.MemberForwarded > y.MemberForwarded ? 1 : -1);
d2026 1
a2026 1
	sealed class FieldRVATable : SortedTable<FieldRVATable.Record>, IComparer<FieldRVATable.Record>
d2081 1
a2081 6
			Array.Sort(records, 0, rowCount, this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Field == y.Field ? 0 : (x.Field > y.Field ? 1 : -1);
d2515 2
a2516 1
			Array.Sort(records, 0, rowCount, this);
d2611 1
a2611 1
	sealed class GenericParamConstraintTable : SortedTable<GenericParamConstraintTable.Record>, IComparer<GenericParamConstraintTable.Record>
d2659 1
a2659 6
			Sort(this);
		}

		int IComparer<Record>.Compare(Record x, Record y)
		{
			return x.Owner == y.Owner ? 0 : (x.Owner > y.Owner ? 1 : -1);
@


1.22
log
@- Added ModuleBuilder.__GetAssemblyToken() API.
- Changed assembly refs to use general pseudo mechanism, instead of its own special case.
@
text
@d1033 1
a1033 4
				if (moduleBuilder.IsPseudoToken(records[i].Class))
				{
					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
				}
d1088 1
a1088 4
				if (moduleBuilder.IsPseudoToken(token))
				{
					token = moduleBuilder.ResolvePseudoToken(token);
				}
d1218 1
a1218 4
				if (moduleBuilder.IsPseudoToken(records[i].Type))
				{
					records[i].Type = moduleBuilder.ResolvePseudoToken(records[i].Type);
				}
d1220 1
a1220 4
				if (moduleBuilder.IsPseudoToken(token))
				{
					token = moduleBuilder.ResolvePseudoToken(token);
				}
d1413 1
a1413 4
				if (moduleBuilder.IsPseudoToken(token))
				{
					token = moduleBuilder.ResolvePseudoToken(token);
				}
d1834 1
a1834 4
				if (moduleBuilder.IsPseudoToken(records[i].Method))
				{
					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
				}
d1955 2
a1956 8
				if (moduleBuilder.IsPseudoToken(records[i].MethodBody))
				{
					records[i].MethodBody = moduleBuilder.ResolvePseudoToken(records[i].MethodBody);
				}
				if (moduleBuilder.IsPseudoToken(records[i].MethodDeclaration))
				{
					records[i].MethodDeclaration = moduleBuilder.ResolvePseudoToken(records[i].MethodDeclaration);
				}
d2086 1
a2086 4
				if (moduleBuilder.IsPseudoToken(records[i].MemberForwarded))
				{
					records[i].MemberForwarded = moduleBuilder.ResolvePseudoToken(records[i].MemberForwarded);
				}
d2150 1
a2150 4
				if (moduleBuilder.IsPseudoToken(records[i].Field))
				{
					records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
				}
d2576 1
a2576 4
				if (moduleBuilder.IsPseudoToken(token))
				{
					token = moduleBuilder.ResolvePseudoToken(token);
				}
d2681 1
a2681 4
				if (moduleBuilder.IsPseudoToken(records[i].Method))
				{
					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
				}
@


1.21
log
@Moved GetEvents(), GetFields(), GetConstructors(), GetNestedTypes() and GetProperties() to a common implementation that fixes a number of bugs.
@
text
@d673 8
d2434 8
d2486 8
@


1.20
log
@Made two methods static and removed an unused method.
@
text
@d1901 1
a1901 1
		internal void ComputeFlags(Module module, int token, out bool isPublic, out bool isStatic)
d1904 1
d1910 1
@


1.19
log
@Generalized sorted metadata table lookups with binary search.
@
text
@d509 1
a509 1
			private int BinarySearch(T[] records, int length, int maskedToken)
a2609 5
		internal GenericParameterAttributes GetAttributes(int token)
		{
			return (GenericParameterAttributes)records[(token & 0xFFFFFF) - 1].Flags;
		}

@


1.18
log
@Support roundtripping hash in AssemblyRef record.
@
text
@d2 1
a2 1
  Copyright (C) 2009-2011 Jeroen Frijters
d35 2
d464 110
d884 1
a884 1
	sealed class InterfaceImplTable : Table<InterfaceImplTable.Record>, IComparer<InterfaceImplTable.Record>
d888 1
a888 1
		internal struct Record
d892 5
d1033 1
a1033 1
	sealed class ConstantTable : Table<ConstantTable.Record>, IComparer<ConstantTable.Record>
d1037 1
a1037 1
		internal struct Record
d1042 5
d1113 1
a1113 2
			// TODO use binary search (if sorted)
			for (int i = 0; i < module.Constant.records.Length; i++)
d1115 2
a1116 1
				if (module.Constant.records[i].Parent == parent)
d1118 29
a1146 29
					ByteReader br = module.GetBlob(module.Constant.records[i].Value);
					switch (module.Constant.records[i].Type)
					{
						// see ModuleBuilder.AddConstant for the encodings
						case Signature.ELEMENT_TYPE_BOOLEAN:
							return br.ReadByte() != 0;
						case Signature.ELEMENT_TYPE_I1:
							return br.ReadSByte();
						case Signature.ELEMENT_TYPE_I2:
							return br.ReadInt16();
						case Signature.ELEMENT_TYPE_I4:
							return br.ReadInt32();
						case Signature.ELEMENT_TYPE_I8:
							return br.ReadInt64();
						case Signature.ELEMENT_TYPE_U1:
							return br.ReadByte();
						case Signature.ELEMENT_TYPE_U2:
							return br.ReadUInt16();
						case Signature.ELEMENT_TYPE_U4:
							return br.ReadUInt32();
						case Signature.ELEMENT_TYPE_U8:
							return br.ReadUInt64();
						case Signature.ELEMENT_TYPE_R4:
							return br.ReadSingle();
						case Signature.ELEMENT_TYPE_R8:
							return br.ReadDouble();
						case Signature.ELEMENT_TYPE_CHAR:
							return br.ReadChar();
						case Signature.ELEMENT_TYPE_STRING:
d1148 1
a1148 6
								char[] chars = new char[br.Length / 2];
								for (int j = 0; j < chars.Length; j++)
								{
									chars[j] = br.ReadChar();
								}
								return new String(chars);
d1150 5
a1154 7
						case Signature.ELEMENT_TYPE_CLASS:
							if (br.ReadInt32() != 0)
							{
								throw new BadImageFormatException();
							}
							return null;
						default:
d1156 4
a1159 1
					}
d1166 1
a1166 1
	sealed class CustomAttributeTable : Table<CustomAttributeTable.Record>, IComparer<CustomAttributeTable.Record>
d1170 1
a1170 1
		internal struct Record
d1175 5
d1299 1
a1299 1
	sealed class FieldMarshalTable : Table<FieldMarshalTable.Record>, IComparer<FieldMarshalTable.Record>
d1303 1
a1303 1
		internal struct Record
d1307 5
d1367 1
a1367 1
	sealed class DeclSecurityTable : Table<DeclSecurityTable.Record>, IComparer<DeclSecurityTable.Record>
d1371 1
a1371 1
		internal struct Record
d1376 5
d1447 1
a1447 1
	sealed class ClassLayoutTable : Table<ClassLayoutTable.Record>, IComparer<ClassLayoutTable.Record>
d1451 1
a1451 1
		internal struct Record
d1456 5
d1498 1
a1498 1
	sealed class FieldLayoutTable : Table<FieldLayoutTable.Record>, IComparer<FieldLayoutTable.Record>
d1502 1
a1502 1
		internal struct Record
d1506 5
d1592 1
a1592 1
	sealed class EventMapTable : Table<EventMapTable.Record>
d1596 1
a1596 1
		internal struct Record
d1600 5
d1688 1
a1688 1
	sealed class PropertyMapTable : Table<PropertyMapTable.Record>
d1692 1
a1692 1
		internal struct Record
d1696 5
d1784 1
a1784 1
	sealed class MethodSemanticsTable : Table<MethodSemanticsTable.Record>, IComparer<MethodSemanticsTable.Record>
d1796 1
a1796 1
		internal struct Record
d1801 5
d1870 12
a1881 2
			int i = 0;
			return GetNextMethod(module, token, nonPublic, semantics, ref i);
d1887 1
a1887 2
			MethodInfo method;
			for (int i = 0; (method = GetNextMethod(module, token, nonPublic, semantics, ref i)) != null; )
d1889 1
a1889 11
				methods.Add(method);
			}
			return methods.ToArray();
		}

		private MethodInfo GetNextMethod(Module module, int token, bool nonPublic, short semantics, ref int i)
		{
			// TODO use binary search?
			for (; i < records.Length; i++)
			{
				if (records[i].Association == token)
d1891 2
a1892 1
					if ((records[i].Semantics & semantics) != 0)
d1894 1
a1894 6
						MethodInfo method = (MethodInfo)module.ResolveMethod((MethodDefTable.Index << 24) + records[i].Method);
						if (nonPublic || method.IsPublic)
						{
							i++;
							return method;
						}
d1898 1
a1898 1
			return null;
d1905 1
a1905 2
			MethodInfo method;
			for (int i = 0; (method = GetNextMethod(module, token, true, -1, ref i)) != null; )
d1907 3
a1909 8
				if (method.IsPublic)
				{
					isPublic = true;
				}
				if (method.IsStatic)
				{
					isStatic = true;
				}
d1914 1
a1914 1
	sealed class MethodImplTable : Table<MethodImplTable.Record>, IComparer<MethodImplTable.Record>
d1918 1
a1918 1
		internal struct Record
d1923 5
d2047 1
a2047 1
	sealed class ImplMapTable : Table<ImplMapTable.Record>, IComparer<ImplMapTable.Record>
d2051 1
a2051 1
		internal struct Record
d2057 5
d2114 1
a2114 1
	sealed class FieldRVATable : Table<FieldRVATable.Record>, IComparer<FieldRVATable.Record>
d2118 1
a2118 1
		internal struct Record
d2122 5
d2470 1
a2470 1
	sealed class NestedClassTable : Table<NestedClassTable.Record>
d2474 1
a2474 1
		internal struct Record
d2478 5
d2525 1
a2525 1
	sealed class GenericParamTable : Table<GenericParamTable.Record>, IComparer<GenericParamTable.Record>
d2529 1
a2529 1
		internal struct Record
d2537 5
d2632 1
a2632 2
			// TODO use binary search (if sorted)
			for (int i = 0; i < records.Length; i++)
d2634 1
a2634 4
				if (records[i].Owner == token)
				{
					return i;
				}
d2701 1
a2701 1
	sealed class GenericParamConstraintTable : Table<GenericParamConstraintTable.Record>, IComparer<GenericParamConstraintTable.Record>
d2705 1
a2705 1
		internal struct Record
d2709 5
@


1.17
log
@Added FieldBuilder.__SetReadOnlyDataAndRVA() to define read-only initialized data.
@
text
@d2100 1
a2108 1
					&& records[i].HashValue == rec.HashValue
@


1.16
log
@Removed unused methods (since earlier patch that add __SetStructLayoutAttribute to TypeBuilder).
@
text
@d1963 1
a1963 1
			internal int RVA;
d1993 1
a1993 1
		internal void Fixup(ModuleBuilder moduleBuilder, int sdataRVA)
d1997 8
a2004 1
				records[i].RVA += sdataRVA;
@


1.15
log
@Use stable sort for DeclSecurity, MethodSemantics and GenericParamConstraint tables (if STABLE_SORT is defined).
@
text
@a1324 13
		internal void AddOrReplaceRecord(Record rec)
		{
			for (int i = 0; i < records.Length; i++)
			{
				if (records[i].Parent == rec.Parent)
				{
					records[i] = rec;
					return;
				}
			}
			AddRecord(rec);
		}

a1357 13

		internal void GetLayout(int token, ref int pack, ref int size)
		{
			for (int i = 0; i < rowCount; i++)
			{
				if (records[i].Parent == token)
				{
					pack = records[i].PackingSize;
					size = records[i].ClassSize;
					break;
				}
			}
		}
@


1.14
log
@Added (disabled) code to use a stable sort for some metadata tables. When STABLE_SORT is defined, the stable sort is used for InterfaceImpl, CustomAttribute and MethodImpl and this makes roundtripping possible which is handy for debugging (by comparing ildasm output of the input and output assemblies).
@
text
@d1305 1
a1305 1
			Array.Sort(records, 0, rowCount, this);
d1728 1
a1728 1
			Array.Sort(records, 0, rowCount, this);
d2595 1
a2595 1
			Array.Sort(records, 0, rowCount, this);
@


1.13
log
@Added limited support for #- metadata stream ("uncompressed" table heap). ParamPtr table is not yet implemented.
@
text
@d424 36
d831 1
a831 1
			Array.Sort(records, 0, rowCount, this);
d838 5
d844 1
d1167 1
a1167 1
			Array.Sort(records, 0, rowCount, this);
d1846 1
a1846 1
			Array.Sort(records, 0, rowCount, this);
@


1.12
log
@Don't create duplicate ClassLayout table records when using the DefineType overload that specifies the size and also applying a StructLayoutAttribute.
@
text
@d2 1
a2 1
  Copyright (C) 2009 Jeroen Frijters
d577 13
d626 13
d688 13
d1470 13
d1561 13
@


1.11
log
@Custom attributes applied to GenericTypeParameterBuilder were attached to the type token, instead of the type parameter token.
@
text
@d1244 13
@


1.10
log
@Avoid adding duplicate MethodSpec rows.
@
text
@d1009 1
d1080 1
a1080 1
						records[i].Parent = (token & 0xFFFFFF) << 5 | 19;
@


1.9
log
@Renamed StandAloneSigTable and ModuleRefTable Add methods to FindOrAddRecord for clarity and consistency with the other FindOrAddRecord methods.
@
text
@d2406 13
@


1.8
log
@Since referenced assembly identities can change (if they're an AssemblyBuilder), we have to postpone creating an AssemblyRef record until save time.
Note that we also take into account the possibility of having multiple assemblies with the same identity and collapse those into a single record. This is to support circular ref scenarios where you load a previous version of an assembly while generating a newer version (with the same identity). A future patch will enable this.
@
text
@d1367 1
a1367 1
		internal int Add(int blob)
d1761 1
a1761 1
		internal int Add(int str)
@


1.7
log
@Version parts should be treated as unsigned.
@
text
@d1994 21
@


1.6
log
@- Assembly version number parts should be treated as unsigned shorts.
- Added support for encoding/decoding custom attributes on generic parameters (this encoding is missing from the June 2006 ECMA CLI spec).
@
text
@d1983 4
a1986 4
			internal short MajorVersion;
			internal short MinorVersion;
			internal short BuildNumber;
			internal short RevisionNumber;
d1998 4
a2001 4
				records[i].MajorVersion = mr.ReadInt16();
				records[i].MinorVersion = mr.ReadInt16();
				records[i].BuildNumber = mr.ReadInt16();
				records[i].RevisionNumber = mr.ReadInt16();
@


1.5
log
@Made property and event public/static flag handling compatible with .NET
@
text
@d1078 3
d1924 4
a1927 4
			internal short MajorVersion;
			internal short MinorVersion;
			internal short BuildNumber;
			internal short RevisionNumber;
d1939 4
a1942 4
				records[i].MajorVersion = mr.ReadInt16();
				records[i].MinorVersion = mr.ReadInt16();
				records[i].BuildNumber = mr.ReadInt16();
				records[i].RevisionNumber = mr.ReadInt16();
@


1.4
log
@Implemented GenericTypeParameterBuilder.GenericParameterAttributes.
@
text
@d1649 18
@


1.3
log
@Bug fix.
@
text
@d2294 5
@


1.2
log
@Removed UTF-8 byte order marks.
@
text
@d1641 1
@


1.1
log
@New IKVM.Reflection implementation.
@
text
@d1 1
a1 1
﻿/*
@

