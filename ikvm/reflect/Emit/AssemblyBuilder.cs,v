head	1.66;
access;
symbols
	v8_1_5717_0:1.61
	v8_1:1.61.0.2
	v8_0_5449_1:1.59
	v8_0_5449_0:1.59
	v8_0:1.59.0.2
	v7_4_5196_0:1.58
	v7_4:1.58.0.2
	v7_3:1.53.0.2
	v7_2_4630_6:1.51
	v7_2_4630_5:1.51
	v7_2_4630_4:1.51
	v7_2_4630_3:1.51
	v7_2_4630_2:1.51
	v0_46_0_4:1.33
	v7_2_4630_1:1.51
	v7_2:1.51.0.2
	v7_1_4532_2:1.47
	v7_1_4532_1:1.47
	v7_1_4532_0:1.47
	v7_1:1.47.0.2
	v7_0_4335_3:1.40
	v7_0_4335_2:1.40
	v7_0_4335_1:1.40
	v0_46_0_2:1.33
	v7_0_4335_0:1.40
	v7_0:1.40.0.2
	v0_46_0_1:1.33
	v0_46_0_0:1.33
	v0_46:1.33.0.2
	v0_44_0_6:1.21
	v0_44_0_5:1.21
	v0_44_0_4:1.21
	v0_44_0_3:1.21
	v0_44_0_2:1.21
	v0_44_0_1:1.21
	v0_44_0_0:1.21
	v0_44:1.21.0.2;
locks; strict;
comment	@ * @;


1.66
date	2016.07.04.05.15.00;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2016.07.01.05.44.41;	author jfrijters;	state Exp;
branches;
next	1.64;

1.64
date	2016.07.01.05.15.22;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2016.06.30.06.01.01;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2015.11.03.08.19.22;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2015.02.16.12.24.28;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2015.01.27.09.54.44;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2014.06.02.11.30.14;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.16.08.50.32;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2013.05.10.10.10.08;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.10.06.16.58;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2013.04.17.13.32.15;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.17.13.27.03;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2012.10.24.16.50.30;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2012.10.12.07.43.00;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2012.07.13.07.35.25;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2012.07.07.08.07.58;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2012.06.26.15.53.33;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2012.06.21.09.34.55;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2012.04.09.10.04.58;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2012.03.20.13.01.02;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2012.03.20.12.58.15;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2012.03.19.12.40.17;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2012.01.25.14.56.35;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.25.08.10.15;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2011.11.07.14.05.52;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2011.10.13.11.01.12;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.11.14.10.15;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2011.03.10.16.09.59;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.08.06.43.01;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2011.03.08.06.14.22;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2011.03.08.05.49.01;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.06.06.38.44;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2011.01.20.14.31.10;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2011.01.20.05.38.12;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.18.16.44.39;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.18.07.11.23;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2010.12.09.13.31.58;	author jfrijters;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.09.06.12.19;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.08.06.33.03;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.06.13.59.52;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.06.05.56.51;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2010.11.29.09.28.48;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2010.11.29.06.59.20;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2010.11.29.06.36.17;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.18.06.57.18;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.20.09.25.30;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.10.08.24.35;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.07.16.38.13;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.07.05.45.29;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.07.04.44.11;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.07.04.29.01;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.06.14.50.22;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.06.14.38.42;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.06.12.40.07;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.06.06.03.34;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.06.05.23.47;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.28.09.39.53;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.20.05.16.59;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.19.13.55.18;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.19.13.52.59;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.18.08.39.21;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.02.03.52.22;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.04.11.18.07;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.25.05.49.01;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.25.05.29.31;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.66
log
@Removed [Obsolete] methods from NETSTANDARD build.
@
text
@/*
  Copyright (C) 2008-2013 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.Collections.Generic;
#if !NETSTANDARD
using System.Configuration.Assemblies;
#endif
using System.IO;
using System.Diagnostics;
using System.Globalization;
using System.Resources;
using System.Security.Cryptography;
using System.Security;
using IKVM.Reflection.Metadata;
using IKVM.Reflection.Impl;
using IKVM.Reflection.Writer;

namespace IKVM.Reflection.Emit
{
	public sealed class AssemblyBuilder : Assembly
	{
		private readonly string name;
		private ushort majorVersion;
		private ushort minorVersion;
		private ushort buildVersion;
		private ushort revisionVersion;
		private string culture;
		private AssemblyNameFlags flags;
		private AssemblyHashAlgorithm hashAlgorithm;
		private StrongNameKeyPair keyPair;
		private byte[] publicKey;
		internal readonly string dir;
		private PEFileKinds fileKind = PEFileKinds.Dll;
		private MethodInfo entryPoint;
		private VersionInfo versionInfo;
		private byte[] win32icon;
		private byte[] win32manifest;
		private byte[] win32resources;
		private string imageRuntimeVersion;
		internal int mdStreamVersion = 0x20000;
		private Module pseudoManifestModule;
		private readonly List<ResourceFile> resourceFiles = new List<ResourceFile>();
		private readonly List<ModuleBuilder> modules = new List<ModuleBuilder>();
		private readonly List<Module> addedModules = new List<Module>();
		private readonly List<CustomAttributeBuilder> customAttributes = new List<CustomAttributeBuilder>();
		private readonly List<CustomAttributeBuilder> declarativeSecurity = new List<CustomAttributeBuilder>();
		private readonly List<TypeForwarder> typeForwarders = new List<TypeForwarder>();

		struct TypeForwarder
		{
			internal readonly Type Type;
			internal readonly bool IncludeNested;

			internal TypeForwarder(Type type, bool includeNested)
			{
				this.Type = type;
				this.IncludeNested = includeNested;
			}
		}

		private struct ResourceFile
		{
			internal string Name;
			internal string FileName;
			internal ResourceAttributes Attributes;
#if !NETSTANDARD
			internal ResourceWriter Writer;
#endif
		}

		internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, IEnumerable<CustomAttributeBuilder> customAttributes)
			: base(universe)
		{
			this.name = name.Name;
			SetVersionHelper(name.Version);
			if (!string.IsNullOrEmpty(name.CultureName))
			{
				this.culture = name.CultureName;
			}
			this.flags = name.RawFlags;
			this.hashAlgorithm = name.HashAlgorithm;
			if (this.hashAlgorithm == AssemblyHashAlgorithm.None)
			{
				this.hashAlgorithm = AssemblyHashAlgorithm.SHA1;
			}
			this.keyPair = name.KeyPair;
			if (this.keyPair != null)
			{
				this.publicKey = this.keyPair.PublicKey;
			}
			else
			{
				byte[] publicKey = name.GetPublicKey();
				if (publicKey != null && publicKey.Length != 0)
				{
					this.publicKey = (byte[])publicKey.Clone();
				}
			}
			this.dir = dir ?? ".";
			if (customAttributes != null)
			{
				this.customAttributes.AddRange(customAttributes);
			}
			if (universe.HasMscorlib && !universe.Mscorlib.__IsMissing && universe.Mscorlib.ImageRuntimeVersion != null)
			{
				this.imageRuntimeVersion = universe.Mscorlib.ImageRuntimeVersion;
			}
			else
			{
#if NETSTANDARD1_3 || NETSTANDARD1_4
				using (Universe temp = new Universe(UniverseOptions.MetadataOnly))
				using (RawModule mscorlib = temp.OpenRawModule(TypeUtil.GetAssembly(typeof(object)).ManifestModule.FullyQualifiedName))
				{
					this.imageRuntimeVersion = mscorlib.ImageRuntimeVersion;
				}
#else
				this.imageRuntimeVersion = TypeUtil.GetAssembly(typeof(object)).ImageRuntimeVersion;
#endif
			}
			universe.RegisterDynamicAssembly(this);
		}

		private void SetVersionHelper(Version version)
		{
			if (version == null)
			{
				majorVersion = 0;
				minorVersion = 0;
				buildVersion = 0;
				revisionVersion = 0;
			}
			else
			{
				majorVersion = (ushort)version.Major;
				minorVersion = (ushort)version.Minor;
				buildVersion = version.Build == -1 ? (ushort)0 : (ushort)version.Build;
				revisionVersion = version.Revision == -1 ? (ushort)0 : (ushort)version.Revision;
			}
		}

		private void Rename(AssemblyName oldName)
		{
			this.fullName = null;
			universe.RenameAssembly(this, oldName);
		}

		public void __SetAssemblyVersion(Version version)
		{
			AssemblyName oldName = GetName();
			SetVersionHelper(version);
			Rename(oldName);
		}

		public void __SetAssemblyCulture(string cultureName)
		{
			AssemblyName oldName = GetName();
			this.culture = cultureName;
			Rename(oldName);
		}

		public void __SetAssemblyKeyPair(StrongNameKeyPair keyPair)
		{
			AssemblyName oldName = GetName();
			this.keyPair = keyPair;
			if (keyPair != null)
			{
				this.publicKey = keyPair.PublicKey;
			}
			Rename(oldName);
		}

		// this is used in combination with delay signing
		public void __SetAssemblyPublicKey(byte[] publicKey)
		{
			AssemblyName oldName = GetName();
			this.publicKey = publicKey == null ? null : (byte[])publicKey.Clone();
			Rename(oldName);
		}

		public void __SetAssemblyAlgorithmId(AssemblyHashAlgorithm hashAlgorithm)
		{
			this.hashAlgorithm = hashAlgorithm;
		}

#if !NETSTANDARD
		[Obsolete("Use __AssemblyFlags property instead.")]
		public void __SetAssemblyFlags(AssemblyNameFlags flags)
		{
			this.__AssemblyFlags = flags;
		}
#endif

		protected override AssemblyNameFlags GetAssemblyFlags()
		{
			return flags;
		}

		public new AssemblyNameFlags __AssemblyFlags
		{
			get { return flags; }
			set
			{
				AssemblyName oldName = GetName();
				this.flags = value;
				Rename(oldName);
			}
		}

		internal string Name
		{
			get { return name; }
		}

		public override AssemblyName GetName()
		{
			AssemblyName n = new AssemblyName();
			n.Name = name;
			n.Version = new Version(majorVersion, minorVersion, buildVersion, revisionVersion);
			n.CultureName = culture ?? "";
			n.HashAlgorithm = hashAlgorithm;
			n.RawFlags = flags;
			n.SetPublicKey(publicKey != null ? (byte[])publicKey.Clone() : Empty<byte>.Array);
			n.KeyPair = keyPair;
			return n;
		}

		public override string Location
		{
			get { throw new NotSupportedException(); }
		}

		public ModuleBuilder DefineDynamicModule(string name, string fileName)
		{
			return DefineDynamicModule(name, fileName, false);
		}

		public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
		{
			ModuleBuilder module = new ModuleBuilder(this, name, fileName, emitSymbolInfo);
			modules.Add(module);
			return module;
		}

		public ModuleBuilder GetDynamicModule(string name)
		{
			foreach (ModuleBuilder module in modules)
			{
				if (module.Name == name)
				{
					return module;
				}
			}
			return null;
		}

		public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
		{
			SetCustomAttribute(new CustomAttributeBuilder(con, binaryAttribute));
		}

		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
		{
			customAttributes.Add(customBuilder);
		}

		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
		{
			declarativeSecurity.Add(customBuilder);
		}

		public void __AddTypeForwarder(Type type)
		{
			__AddTypeForwarder(type, true);
		}

		public void __AddTypeForwarder(Type type, bool includeNested)
		{
			typeForwarders.Add(new TypeForwarder(type, includeNested));
		}

		public void SetEntryPoint(MethodInfo entryMethod)
		{
			SetEntryPoint(entryMethod, PEFileKinds.ConsoleApplication);
		}

		public void SetEntryPoint(MethodInfo entryMethod, PEFileKinds fileKind)
		{
			this.entryPoint = entryMethod;
			this.fileKind = fileKind;
		}

		public void __Save(Stream stream, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
		{
			if (!stream.CanRead || !stream.CanWrite || !stream.CanSeek || stream.Position != 0)
			{
				throw new ArgumentException("Stream must support read/write/seek and current position must be zero.", "stream");
			}
			if (modules.Count != 1)
			{
				throw new NotSupportedException("Saving to a stream is only supported for single module assemblies.");
			}
			SaveImpl(modules[0].fileName, stream, portableExecutableKind, imageFileMachine);
		}

		public void Save(string assemblyFileName)
		{
			Save(assemblyFileName, PortableExecutableKinds.ILOnly, ImageFileMachine.I386);
		}

		public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
		{
			SaveImpl(assemblyFileName, null, portableExecutableKind, imageFileMachine);
		}

		private void SaveImpl(string assemblyFileName, Stream streamOrNull, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
		{
			ModuleBuilder manifestModule = null;

			foreach (ModuleBuilder moduleBuilder in modules)
			{
				moduleBuilder.SetIsSaved();
				moduleBuilder.PopulatePropertyAndEventTables();

				if (manifestModule == null
					&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
				{
					manifestModule = moduleBuilder;
				}
			}

			if (manifestModule == null)
			{
				manifestModule = DefineDynamicModule("RefEmit_OnDiskManifestModule", assemblyFileName, false);
			}

			AssemblyTable.Record assemblyRecord = new AssemblyTable.Record();
			assemblyRecord.HashAlgId = (int)hashAlgorithm;
			assemblyRecord.Name = manifestModule.Strings.Add(name);
			assemblyRecord.MajorVersion = majorVersion;
			assemblyRecord.MinorVersion = minorVersion;
			assemblyRecord.BuildNumber = buildVersion;
			assemblyRecord.RevisionNumber = revisionVersion;
			if (publicKey != null)
			{
				assemblyRecord.PublicKey = manifestModule.Blobs.Add(ByteBuffer.Wrap(publicKey));
				assemblyRecord.Flags = (int)(flags | AssemblyNameFlags.PublicKey);
			}
			else
			{
				assemblyRecord.Flags = (int)(flags & ~AssemblyNameFlags.PublicKey);
			}
			if (culture != null)
			{
				assemblyRecord.Culture = manifestModule.Strings.Add(culture);
			}
			manifestModule.AssemblyTable.AddRecord(assemblyRecord);

			ResourceSection unmanagedResources = versionInfo != null || win32icon != null || win32manifest != null || win32resources != null
				? new ResourceSection()
				: null;

			if (versionInfo != null)
			{
				versionInfo.SetName(GetName());
				versionInfo.SetFileName(assemblyFileName);
				foreach (CustomAttributeBuilder cab in customAttributes)
				{
					// .NET doesn't support copying blob custom attributes into the version info
					if (!cab.HasBlob || universe.DecodeVersionInfoAttributeBlobs)
					{
						versionInfo.SetAttribute(this, cab);
					}
				}
				ByteBuffer versionInfoData = new ByteBuffer(512);
				versionInfo.Write(versionInfoData);
				unmanagedResources.AddVersionInfo(versionInfoData);
			}

			if (win32icon != null)
			{
				unmanagedResources.AddIcon(win32icon);
			}

			if (win32manifest != null)
			{
				unmanagedResources.AddManifest(win32manifest, fileKind == PEFileKinds.Dll ? (ushort)2 : (ushort)1);
			}

			if (win32resources != null)
			{
				unmanagedResources.ExtractResources(win32resources);
			}

			foreach (CustomAttributeBuilder cab in customAttributes)
			{
				// we intentionally don't filter out the version info (pseudo) custom attributes (to be compatible with .NET)
				manifestModule.SetCustomAttribute(0x20000001, cab);
			}

			manifestModule.AddDeclarativeSecurity(0x20000001, declarativeSecurity);

			foreach (TypeForwarder fwd in typeForwarders)
			{
				manifestModule.AddTypeForwarder(fwd.Type, fwd.IncludeNested);
			}

			foreach (ResourceFile resfile in resourceFiles)
			{
#if !NETSTANDARD
				if (resfile.Writer != null)
				{
					resfile.Writer.Generate();
					resfile.Writer.Close();
				}
#endif
				int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
				ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
				rec.Offset = 0;
				rec.Flags = (int)resfile.Attributes;
				rec.Name = manifestModule.Strings.Add(resfile.Name);
				rec.Implementation = fileToken;
				manifestModule.ManifestResource.AddRecord(rec);
			}

			int entryPointToken = 0;

			foreach (ModuleBuilder moduleBuilder in modules)
			{
				moduleBuilder.FillAssemblyRefTable();
				moduleBuilder.EmitResources();
				if (moduleBuilder != manifestModule)
				{
					int fileToken;
					if (entryPoint != null && entryPoint.Module == moduleBuilder)
					{
						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
						entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
					}
					else
					{
						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
						fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
					}
					moduleBuilder.ExportTypes(fileToken, manifestModule);
				}
				moduleBuilder.CloseResources();
			}

			foreach (Module module in addedModules)
			{
				int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
				module.ExportTypes(fileToken, manifestModule);
			}

			if (entryPointToken == 0 && entryPoint != null)
			{
				entryPointToken = entryPoint.MetadataToken;
			}

			// finally, write the manifest module
			ModuleWriter.WriteModule(keyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken, streamOrNull);
		}

		private int AddFile(ModuleBuilder manifestModule, string fileName, int flags)
		{
			string fullPath = fileName;
			if (dir != null)
			{
				fullPath = Path.Combine(dir, fileName);
			}
			byte[] hash;
			using (SHA1 sha1 = SHA1.Create())
			using (FileStream fs = new FileStream(fullPath, FileMode.Open, FileAccess.Read))
			{
				hash = sha1.ComputeHash(fs);
			}
			return manifestModule.__AddModule(flags, Path.GetFileName(fileName), hash);
		}

		public void AddResourceFile(string name, string fileName)
		{
			AddResourceFile(name, fileName, ResourceAttributes.Public);
		}

		public void AddResourceFile(string name, string fileName, ResourceAttributes attribs)
		{
			ResourceFile resfile = new ResourceFile();
			resfile.Name = name;
			resfile.FileName = fileName;
			resfile.Attributes = attribs;
			resourceFiles.Add(resfile);
		}

#if !NETSTANDARD
		public IResourceWriter DefineResource(string name, string description, string fileName)
		{
			return DefineResource(name, description, fileName, ResourceAttributes.Public);
		}

		public IResourceWriter DefineResource(string name, string description, string fileName, ResourceAttributes attribute)
		{
			// FXBUG we ignore the description, because there is no such thing

			string fullPath = fileName;
			if (dir != null)
			{
				fullPath = Path.Combine(dir, fileName);
			}
			ResourceWriter rw = new ResourceWriter(fullPath);
			ResourceFile resfile;
			resfile.Name = name;
			resfile.FileName = fileName;
			resfile.Attributes = attribute;
			resfile.Writer = rw;
			resourceFiles.Add(resfile);
			return rw;
		}
#endif

		public void DefineVersionInfoResource()
		{
			if (versionInfo != null || win32resources != null)
			{
				throw new ArgumentException("Native resource has already been defined.");
			}
			versionInfo = new VersionInfo();
		}

		public void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark)
		{
			if (versionInfo != null || win32resources != null)
			{
				throw new ArgumentException("Native resource has already been defined.");
			}
			versionInfo = new VersionInfo();
			versionInfo.product = product;
			versionInfo.informationalVersion = productVersion;
			versionInfo.company = company;
			versionInfo.copyright = copyright;
			versionInfo.trademark = trademark;
		}

		public void __DefineIconResource(byte[] iconFile)
		{
			if (win32icon != null || win32resources != null)
			{
				throw new ArgumentException("Native resource has already been defined.");
			}
			win32icon = (byte[])iconFile.Clone();
		}

		public void __DefineManifestResource(byte[] manifest)
		{
			if (win32manifest != null || win32resources != null)
			{
				throw new ArgumentException("Native resource has already been defined.");
			}
			win32manifest = (byte[])manifest.Clone();
		}

		public void __DefineUnmanagedResource(byte[] resource)
		{
			if (versionInfo != null || win32icon != null || win32manifest != null || win32resources != null)
			{
				throw new ArgumentException("Native resource has already been defined.");
			}
			// The standard .NET DefineUnmanagedResource(byte[]) is useless, because it embeds "resource" (as-is) as the .rsrc section,
			// but it doesn't set the PE file Resource Directory entry to point to it. That's why we have a renamed version, which behaves
			// like DefineUnmanagedResource(string).
			win32resources = (byte[])resource.Clone();
		}

		public void DefineUnmanagedResource(string resourceFileName)
		{
			// This method reads the specified resource file (Win32 .res file) and converts it into the appropriate format and embeds it in the .rsrc section,
			// also setting the Resource Directory entry.
			__DefineUnmanagedResource(File.ReadAllBytes(resourceFileName));
		}

		public override Type[] GetTypes()
		{
			List<Type> list = new List<Type>();
			foreach (ModuleBuilder module in modules)
			{
				module.GetTypesImpl(list);
			}
			foreach (Module module in addedModules)
			{
				module.GetTypesImpl(list);
			}
			return list.ToArray();
		}

		internal override Type FindType(TypeName typeName)
		{
			foreach (ModuleBuilder mb in modules)
			{
				Type type = mb.FindType(typeName);
				if (type != null)
				{
					return type;
				}
			}
			foreach (Module module in addedModules)
			{
				Type type = module.FindType(typeName);
				if (type != null)
				{
					return type;
				}
			}
			return null;
		}

		internal override Type FindTypeIgnoreCase(TypeName lowerCaseName)
		{
			foreach (ModuleBuilder mb in modules)
			{
				Type type = mb.FindTypeIgnoreCase(lowerCaseName);
				if (type != null)
				{
					return type;
				}
			}
			foreach (Module module in addedModules)
			{
				Type type = module.FindTypeIgnoreCase(lowerCaseName);
				if (type != null)
				{
					return type;
				}
			}
			return null;
		}

		public override string ImageRuntimeVersion
		{
			get { return imageRuntimeVersion; }
		}

		public void __SetImageRuntimeVersion(string imageRuntimeVersion, int mdStreamVersion)
		{
			this.imageRuntimeVersion = imageRuntimeVersion;
			this.mdStreamVersion = mdStreamVersion;
		}

		public override Module ManifestModule
		{
			get
			{
				if (pseudoManifestModule == null)
				{
					pseudoManifestModule = new ManifestModule(this);
				}
				return pseudoManifestModule;
			}
		}

		public override MethodInfo EntryPoint
		{
			get { return entryPoint; }
		}

		public override AssemblyName[] GetReferencedAssemblies()
		{
			return Empty<AssemblyName>.Array;
		}

		public override Module[] GetLoadedModules(bool getResourceModules)
		{
			return GetModules(getResourceModules);
		}

		public override Module[] GetModules(bool getResourceModules)
		{
			List<Module> list = new List<Module>();
			foreach (ModuleBuilder module in modules)
			{
				if (getResourceModules || !module.IsResource())
				{
					list.Add(module);
				}
			}
			foreach (Module module in addedModules)
			{
				if (getResourceModules || !module.IsResource())
				{
					list.Add(module);
				}
			}
			return list.ToArray();
		}

		public override Module GetModule(string name)
		{
			foreach (ModuleBuilder module in modules)
			{
				if (module.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
				{
					return module;
				}
			}
			foreach (Module module in addedModules)
			{
				if (module.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
				{
					return module;
				}
			}
			return null;
		}

		public Module __AddModule(RawModule module)
		{
			Module mod = module.ToModule(this);
			addedModules.Add(mod);
			return mod;
		}

		public override ManifestResourceInfo GetManifestResourceInfo(string resourceName)
		{
			throw new NotSupportedException();
		}

		public override string[] GetManifestResourceNames()
		{
			throw new NotSupportedException();
		}

		public override Stream GetManifestResourceStream(string resourceName)
		{
			throw new NotSupportedException();
		}

		public override bool IsDynamic
		{
			get { return true; }
		}

		public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access)
		{
			return new Universe().DefineDynamicAssembly(name, access);
		}

		public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder> assemblyAttributes)
		{
			return new Universe().DefineDynamicAssembly(name, access, assemblyAttributes);
		}

		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
		{
			List<CustomAttributeData> list = new List<CustomAttributeData>();
			foreach (CustomAttributeBuilder cab in customAttributes)
			{
				if (attributeType == null || attributeType.IsAssignableFrom(cab.Constructor.DeclaringType))
				{
					list.Add(cab.ToData(this));
				}
			}
			return list;
		}

		internal bool IsWindowsRuntime
		{
			get { return (flags & (AssemblyNameFlags)0x200) != 0; }
		}
	}

	sealed class ManifestModule : NonPEModule
	{
		private readonly AssemblyBuilder assembly;
		private readonly Guid guid = Guid.NewGuid();

		internal ManifestModule(AssemblyBuilder assembly)
			: base(assembly.universe)
		{
			this.assembly = assembly;
		}

		public override int MDStreamVersion
		{
			get { return assembly.mdStreamVersion; }
		}

		public override Assembly Assembly
		{
			get { return assembly; }
		}

		internal override Type FindType(TypeName typeName)
		{
			return null;
		}

		internal override Type FindTypeIgnoreCase(TypeName lowerCaseName)
		{
			return null;
		}

		internal override void  GetTypesImpl(List<Type> list)
		{
		}

		public override string FullyQualifiedName
		{
			get { return Path.Combine(assembly.dir, "RefEmit_InMemoryManifestModule"); }
		}

		public override string Name
		{
			get { return "<In Memory Module>"; }
		}

		public override Guid ModuleVersionId
		{
			get { return guid; }
		}

		public override string ScopeName
		{
			get { return "RefEmit_InMemoryManifestModule"; }
		}

		protected override Exception NotSupportedException()
		{
			return new InvalidOperationException();
		}
	}
}
@


1.65
log
@Replaced CORECLR symbol with NETSTANDARD.
@
text
@d206 1
d212 1
@


1.64
log
@Added support for building against .NET Standard 1.3.
@
text
@d87 1
a87 1
#if !CORECLR
d428 1
a428 1
#if !CORECLR
d513 1
a513 1
#if !CORECLR
@


1.63
log
@Avoid SHA1Managed and CryptoStream.
@
text
@d26 1
d28 1
d131 9
a139 1
				this.imageRuntimeVersion = typeof(object).Assembly.ImageRuntimeVersion;
@


1.62
log
@Added AssemblyName.CultureName property setter that was introduced with .NET 4.6.
@
text
@a474 1
			SHA1Managed hash = new SHA1Managed();
d480 2
d484 1
a484 5
				using (CryptoStream cs = new CryptoStream(Stream.Null, hash, CryptoStreamMode.Write))
				{
					byte[] buf = new byte[8192];
					ModuleWriter.HashChunk(fs, cs, buf, (int)fs.Length);
				}
d486 1
a486 1
			return manifestModule.__AddModule(flags, Path.GetFileName(fileName), hash.Hash);
@


1.61
log
@Added CoreCLR target for IKVM.Reflection.
@
text
@d95 1
a95 1
			if (!string.IsNullOrEmpty(name.Culture))
d97 1
a97 1
				this.culture = name.Culture;
d228 1
a228 1
			n.Culture = culture ?? "";
@


1.60
log
@Fixed ModuleBuilder.DefineManifestResource() to support very large resources.
@
text
@d85 1
d87 1
d418 1
d424 1
d506 1
d530 1
@


1.59
log
@Added UniverseOptions.DecodeVersionInfoAttributeBlobs to support decoding CustomAttributeBuilder with blob to extract version info fields.
@
text
@d451 1
@


1.58
log
@Added new overload for __AddTypeForwarder() that takes an additional bool to disable automatically forwarding nested types.
@
text
@d376 1
a376 1
					if (!cab.HasBlob)
d378 1
a378 1
						versionInfo.SetAttribute(cab);
@


1.57
log
@Simplified legacy PermissionSet handling.
@
text
@d66 13
a78 1
		private readonly List<Type> typeForwarders = new List<Type>();
d280 6
a285 1
			typeForwarders.Add(type);
d409 1
a409 1
			foreach (Type type in typeForwarders)
d411 1
a411 1
				manifestModule.AddTypeForwarder(type);
@


1.56
log
@Replaced incorrect usage of StringComparison.InvariantCultureIgnoreCase with StringComparison.OrdinalIgnoreCase.
@
text
@a51 3
		private readonly PermissionSet requiredPermissions;
		private readonly PermissionSet optionalPermissions;
		private readonly PermissionSet refusedPermissions;
d76 1
a76 1
		internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, IEnumerable<CustomAttributeBuilder> customAttributes)
a104 3
			this.requiredPermissions = requiredPermissions;
			this.optionalPermissions = optionalPermissions;
			this.refusedPermissions = refusedPermissions;
d346 1
a346 20
			int token = 0x20000000 + manifestModule.AssemblyTable.AddRecord(assemblyRecord);

#pragma warning disable 618
			// this values are obsolete, but we already know that so we disable the warning
			System.Security.Permissions.SecurityAction requestMinimum = System.Security.Permissions.SecurityAction.RequestMinimum;
			System.Security.Permissions.SecurityAction requestOptional = System.Security.Permissions.SecurityAction.RequestOptional;
			System.Security.Permissions.SecurityAction requestRefuse = System.Security.Permissions.SecurityAction.RequestRefuse;
#pragma warning restore 618
			if (requiredPermissions != null)
			{
				manifestModule.AddDeclarativeSecurity(token, requestMinimum, requiredPermissions);
			}
			if (optionalPermissions != null)
			{
				manifestModule.AddDeclarativeSecurity(token, requestOptional, optionalPermissions);
			}
			if (refusedPermissions != null)
			{
				manifestModule.AddDeclarativeSecurity(token, requestRefuse, refusedPermissions);
			}
@


1.55
log
@Added new .NET 4.5 static AssemblyBuilder.DefineDynamicAssembly() methods. They implicitly create a universe.
@
text
@d711 1
a711 1
				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
d718 1
a718 1
				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
@


1.54
log
@ Bug fix and minor refactoring. DefineDynamicAssembly() overload taking an IEnumerable<CustomAttributeBuilder> should accept null.
@
text
@d753 10
@


1.53
log
@Made AssemblyBuilder.__AssemblyFlags a read/write property and marked __SetAssemblyFlags() obsolete.
@
text
@d2 1
a2 1
  Copyright (C) 2008-2012 Jeroen Frijters
d79 1
a79 1
		internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
d111 4
d123 1
@


1.52
log
@Added new .NET 4.0 property Assembly.IsDynamic.
@
text
@d183 1
d186 1
a186 3
			AssemblyName oldName = GetName();
			this.flags = flags;
			Rename(oldName);
d189 6
a194 1
		public override AssemblyNameFlags __AssemblyFlags
d197 6
@


1.51
log
@Keep track of whether a ModuleBuilder has been saved (and only allow it to be saved once).
@
text
@d733 5
@


1.50
log
@Added missing DefineResource() APIs to ModuleBuilder and AssemblyBuilder.
@
text
@d302 1
@


1.49
log
@Enable to generation of WindowsRuntime assemblies.
@
text
@d30 1
d76 1
d408 5
d427 1
d493 24
@


1.48
log
@Added .NET 4.5 AssemblyName.ContentType property. Defining WinRT assemblies is not yet implemented.
@
text
@a79 4
			if (name.ContentType != AssemblyContentType.Default)
			{
				throw new NotImplementedException("Generating WinRT assemblies is not yet implemented.");
			}
d712 5
@


1.47
log
@Added support for case-insensitive type lookup.
@
text
@d80 4
@


1.46
log
@It turns out that for DLLs the resource id for the manifest should be 2. This is what the C# compiler does. See "Using Side-by-Side Assemblies as a Resource" (http://msdn.microsoft.com/en-us/library/aa376617(VS.85).aspx) for more information.
@
text
@d580 21
d740 5
@


1.45
log
@Moved ResourceSection creation to SaveImpl (for pending manifest fix) and throw appropriate exceptions when duplicate unmanaged resources are defined.
@
text
@d383 1
a383 1
				unmanagedResources.AddManifest(win32manifest);
@


1.44
log
@Added AssemblyBuilder.__DefineManifestResource() API to add a Win32 manifest resource.
@
text
@d57 3
a59 2
		private ResourceSection unmanagedResources;
		private bool rawUnmanagedResources;
d355 4
a372 4
				if (unmanagedResources == null)
				{
					unmanagedResources = new ResourceSection();
				}
d376 15
d487 4
d496 4
d510 1
a510 1
			if (unmanagedResources == null || rawUnmanagedResources)
d512 1
a512 1
				unmanagedResources = new ResourceSection();
d514 1
a514 2
			rawUnmanagedResources = false;
			unmanagedResources.AddIcon(iconFile);
d519 1
a519 1
			if (unmanagedResources == null || rawUnmanagedResources)
d521 1
a521 1
				unmanagedResources = new ResourceSection();
d523 1
a523 2
			rawUnmanagedResources = false;
			unmanagedResources.AddManifest(manifest);
d528 4
d535 1
a535 3
			rawUnmanagedResources = true;
			unmanagedResources = new ResourceSection();
			unmanagedResources.ExtractResources(resource);
@


1.43
log
@Cache the assembly FullName in Assembly. This brings the Assembly.FullName property performance more inline with System.Reflection which also caches the FullName (computing the FullName is expensive).
@
text
@d2 1
a2 1
  Copyright (C) 2008-2011 Jeroen Frijters
d58 1
d486 5
a490 1
			unmanagedResources = new ResourceSection();
d494 10
d509 1
@


1.42
log
@Optimized assembly lookup. Thanks to Marek Safar for the pointer.
@
text
@d135 6
d145 1
a145 1
			universe.RenameAssembly(this, oldName);
d152 1
a152 1
			universe.RenameAssembly(this, oldName);
d163 1
a163 1
			universe.RenameAssembly(this, oldName);
d171 1
a171 1
			universe.RenameAssembly(this, oldName);
d181 1
d183 1
a208 5
		public override string FullName
		{
			get { return GetName().FullName; }
		}

@


1.41
log
@Implemented most of AssemblyName (except parsing) without dependency on System.Reflection.AssemblyName.
@
text
@d183 5
@


1.40
log
@Added support for process architecture in assembly flags.
@
text
@d80 1
a80 1
			if (name.CultureInfo != null && !string.IsNullOrEmpty(name.CultureInfo.Name))
d82 1
a82 1
				this.culture = name.CultureInfo.Name;
d188 1
a188 1
			n.Culture = culture;
@


1.39
log
@Added API extensions to add low-level Module and ManifestResource table records.
@
text
@d84 1
a84 1
			this.flags = name.Flags;
d190 1
a190 1
			n.Flags = flags;
@


1.38
log
@Added API extension Assembly.__AssemblyFlags to query all the assembly flags. The AssemblyName.Flags property returns only a subset of the flags.
@
text
@d443 1
a443 5
			FileTable.Record file = new FileTable.Record();
			file.Flags = flags;
			file.Name = manifestModule.Strings.Add(Path.GetFileName(fileName));
			file.HashValue = manifestModule.Blobs.Add(ByteBuffer.Wrap(hash.Hash));
			return 0x26000000 + manifestModule.File.AddRecord(file);
@


1.37
log
@Introduced base class for virtual Module classes to have common place to implement abstract Module methods that aren't supported.
@
text
@d178 5
@


1.36
log
@Added API extension __ImageBase to Module.
@
text
@d644 1
a644 1
	sealed class ManifestModule : Module
a688 30
		public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			throw new ArgumentException();
		}

		public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			throw new ArgumentException();
		}

		public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			throw new ArgumentException();
		}

		public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			throw new ArgumentException();
		}

		public override string ResolveString(int metadataToken)
		{
			throw new ArgumentException();
		}

		public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
		{
			throw new ArgumentException();
		}

d694 1
a694 21
		public override AssemblyName[] __GetReferencedAssemblies()
		{
			throw new InvalidOperationException();
		}

		public override string[] __GetReferencedModules()
		{
			throw new InvalidOperationException();
		}

		internal override Type GetModuleType()
		{
			throw new InvalidOperationException();
		}

		internal override IKVM.Reflection.Reader.ByteReader GetBlob(int blobIndex)
		{
			throw new InvalidOperationException();
		}

		protected override long GetImageBaseImpl()
d696 1
a696 1
			throw new InvalidOperationException();
@


1.35
log
@Added API extensions to get and add referenced modules.
@
text
@d743 5
@


1.34
log
@If mscorlib is a missing assembly, don't try to copy its image runtime version.
@
text
@d729 5
@


1.33
log
@Move missing type support into universe and optionally allow missing types to be resolved inside all Assemblies.
@
text
@d107 1
a107 1
			if (universe.HasMscorlib && universe.Mscorlib.ImageRuntimeVersion != null)
@


1.32
log
@More type name fixes. This time to support the fact that the CLR and Mono both treat TypeNamespace and TypeName as separate names and do not consider fullName to be relevant.
@
text
@a66 1
		private Dictionary<ScopedTypeName, Type> missingTypes;
a74 28
		private struct ScopedTypeName : IEquatable<ScopedTypeName>
		{
			private readonly Type declaringType;
			private readonly TypeName name;

			internal ScopedTypeName(Type declaringType, TypeName name)
			{
				this.declaringType = declaringType;
				this.name = name;
			}

			public override bool Equals(object obj)
			{
				ScopedTypeName? other = obj as ScopedTypeName?;
				return other != null && ((IEquatable<ScopedTypeName>)other.Value).Equals(this);
			}

			public override int GetHashCode()
			{
				return declaringType == null ? name.GetHashCode() : declaringType.GetHashCode() * 7 + name.GetHashCode();
			}

			bool IEquatable<ScopedTypeName>.Equals(ScopedTypeName other)
			{
				return other.declaringType == declaringType && other.name == name;
			}
		}

a530 29
		internal override Type GetMissingType(TypeName name)
		{
			return GetMissingType(this.ManifestModule, null, name);
		}

		internal Type GetMissingType(Module module, Type declaringType, TypeName name)
		{
			if (missingTypes == null)
			{
				return null;
			}
			ScopedTypeName stn = new ScopedTypeName(declaringType, name);
			Type type;
			if (!missingTypes.TryGetValue(stn, out type))
			{
				type = new MissingType(module, declaringType, name.Namespace, name.Name);
				missingTypes.Add(stn, type);
			}
			return type;
		}

		public void __EnableMissingTypeResolution()
		{
			if (missingTypes == null)
			{
				missingTypes = new Dictionary<ScopedTypeName, Type>();
			}
		}

@


1.31
log
@Added support for resolving MissingTypes in AssemblyBuilder.
@
text
@d67 1
a67 1
		private Dictionary<string, Type> missingTypes;
d76 28
d539 1
a539 1
		internal override Type GetTypeImpl(string typeName)
d543 1
a543 1
				Type type = mb.GetTypeImpl(typeName);
d551 1
a551 1
				Type type = module.GetTypeImpl(typeName);
d560 1
a560 1
		internal override Type ResolveType(string ns, string name)
d562 1
a562 1
			return base.ResolveType(ns, name) ?? GetMissingType(this.ManifestModule, null, ns, name);
d565 1
a565 1
		internal Type GetMissingType(Module module, Type declaringType, string ns, string name)
d571 1
a571 1
			Type mt = new MissingType(module, declaringType, ns, name);
d573 1
a573 1
			if (!missingTypes.TryGetValue(mt.FullName, out type))
d575 2
a576 2
				missingTypes.Add(mt.FullName, mt);
				type = mt;
d585 1
a585 1
				missingTypes = new Dictionary<string, Type>();
d723 1
a723 1
		internal override Type GetTypeImpl(string typeName)
@


1.30
log
@Added support for saving to a stream instead of a file.
@
text
@d67 1
d532 29
@


1.29
log
@Fixed stupid copy/paste bug in AssemblyBuilder.GetTypeImpl(). The modules list was iterated twice instead of looking through both modules and addedModules.
@
text
@d2 1
a2 1
  Copyright (C) 2008-2010 Jeroen Frijters
d256 13
d276 5
d419 1
a419 1
			ModuleWriter.WriteModule(keyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
@


1.28
log
@According to Marek, Mono requires the PropertyMap table to be sorted.
@
text
@d502 1
a502 1
			foreach (Module module in modules)
@


1.27
log
@Added Module.__GetReferencedAssemblies() API.
@
text
@d267 4
a270 1
				if (string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
a272 1
					break;
@


1.26
log
@Added support for emitting assemblies with non-existing cultures.
@
text
@d704 5
@


1.25
log
@HashAlgId in assembly manifest record turns out to be useless (SHA1 is always used).
@
text
@d183 1
a183 1
			n.CultureInfo = culture != null ? CultureInfo.GetCultureInfo(culture) : CultureInfo.InvariantCulture;
@


1.24
log
@Added AssemblyBuilder.__AddModule() to allow pre-existing modules to be linked in.
@
text
@a278 4
			if (hashAlgorithm != AssemblyHashAlgorithm.SHA1)
			{
				throw new NotImplementedException();
			}
@


1.23
log
@Added AssemblyBuilder.__DefineIconResource() API.
@
text
@d63 1
d391 6
d424 1
a424 1
			file.Name = manifestModule.Strings.Add(fileName);
d487 4
d504 8
d563 7
d582 7
d592 7
@


1.22
log
@Use ResourceSection directly to collect unmanaged resources. To prepare for adding win32 icon resource support.
@
text
@d451 6
@


1.21
log
@Since referenced assembly identities can change (if they're an AssemblyBuilder), we have to postpone creating an AssemblyRef record until save time.
Note that we also take into account the possibility of having multiple assemblies with the same identity and collapse those into a single record. This is to support circular ref scenarios where you load a previous version of an assembly while generating a newer version (with the same identity). A future patch will enable this.
@
text
@d57 1
a57 1
		private byte[] unmanagedResources;
a322 1
			ByteBuffer versionInfoData = null;
d335 1
a335 1
				versionInfoData = new ByteBuffer(512);
d337 5
d378 1
a378 1
						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, null, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
d383 1
a383 1
						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, null, moduleBuilder.unmanagedResources, 0);
d396 1
a396 1
			ModuleWriter.WriteModule(keyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, versionInfoData, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
d456 2
a457 1
			this.unmanagedResources = (byte[])resource.Clone();
d464 1
a464 1
			this.unmanagedResources = File.ReadAllBytes(resourceFileName);
@


1.20
log
@Implemented custom attribute filtering at the source. Added support for custom attribute sub typing.
@
text
@d368 1
@


1.19
log
@Made mscorlib handling more explicit (and simpler) and fixed Import() to not load assemblies directly, but go through the resolve event.
@
text
@d562 1
a562 1
		internal override IList<CustomAttributeData> GetCustomAttributesData()
d567 4
a570 1
				list.Add(cab.ToData(this));
@


1.18
log
@Moved AssemblyHashAlgorithm.None -> SHA1 to constructor for .NET compat.
@
text
@d106 1
a106 1
			if (universe.HasMscorlib && universe.System_Object != null)
d108 1
a108 1
				this.imageRuntimeVersion = universe.System_Object.Assembly.ImageRuntimeVersion;
@


1.17
log
@Added __SetAssemblyVersion(), __SetAssemblyCulture(), __SetAssemblyKeyPair(), __SetAssemblyPublicKey(), __SetAssemblyAlgorithmId() and __SetAssemblyFlags() methods to AssemblyBuilder.
@
text
@d85 4
a277 4
			if (hashAlgorithm == AssemblyHashAlgorithm.None)
			{
				hashAlgorithm = AssemblyHashAlgorithm.SHA1;
			}
@


1.16
log
@Removed support for pseudo custom attributes TypeForwardedToAttribute and DefaultParameterValueAttribute that aren't supported by .NET reflection either.
@
text
@d78 1
a78 14
			Version version = name.Version;
			if (version != null)
			{
				majorVersion = (ushort)version.Major;
				minorVersion = (ushort)version.Minor;
				if (version.Build != -1)
				{
					buildVersion = (ushort)version.Build;
				}
				if (version.Revision != -1)
				{
					revisionVersion = (ushort)version.Revision;
				}
			}
d112 61
@


1.15
log
@Don't store AssemblyName, because it is mutable.
@
text
@d294 2
a295 1
				manifestModule.SetAssemblyCustomAttribute(cab);
@


1.14
log
@Support for defining mscorlib assembly.
@
text
@d26 1
d29 1
d40 10
a49 1
		private readonly AssemblyName name;
d77 34
a110 1
			this.name = name;
d128 7
a134 4
			n.Name = name.Name;
			n.Version = name.Version ?? new Version(0, 0, 0, 0);
			n.CultureInfo = name.CultureInfo ?? System.Globalization.CultureInfo.InvariantCulture;
			n.SetPublicKey(GetPublicKey(name) ?? Empty<byte>.Array);
d226 8
d235 6
a240 10
			assemblyRecord.HashAlgId = 0x8004;	// SHA1
			assemblyRecord.Name = manifestModule.Strings.Add(name.Name);
			if (name.Version != null)
			{
				assemblyRecord.MajorVersion = (ushort)name.Version.Major;
				assemblyRecord.MinorVersion = (ushort)name.Version.Minor;
				assemblyRecord.BuildNumber = (ushort)(name.Version.Build == -1 ? 0 : name.Version.Build);
				assemblyRecord.RevisionNumber = (ushort)(name.Version.Revision == -1 ? 0 : name.Version.Revision);
			}
			byte[] publicKey = GetPublicKey(name);
d244 5
a248 1
				assemblyRecord.Flags |= 0x0001;	// PublicKey
d250 1
a250 1
			if (name.CultureInfo != null)
d252 1
a252 1
				assemblyRecord.Culture = manifestModule.Strings.Add(name.CultureInfo.Name);
d278 1
a278 1
				versionInfo.SetName(name);
d342 1
a342 16
			ModuleWriter.WriteModule(name.KeyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, versionInfoData, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
		}

		private static byte[] GetPublicKey(AssemblyName name)
		{
			StrongNameKeyPair keyPair = name.KeyPair;
			if (keyPair != null)
			{
				return keyPair.PublicKey;
			}
			byte[] key = name.GetPublicKey();
			if (key == null || key.Length == 0)
			{
				return null;
			}
			return key;
@


1.13
log
@Removed unused parameter.
@
text
@d71 8
a78 1
			this.imageRuntimeVersion = universe.System_Object.Assembly.ImageRuntimeVersion;
@


1.12
log
@Ignore version info custom attributes that were specified using blob. This is same behavior as .NET.
@
text
@d63 1
a63 1
		internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
@


1.11
log
@Added AssemblyBuilder.__AddTypeForwarder() to allow type forwarders to be added explictly, because the pseudo custom attribute will be removed (because .NET doesn't support that pseudo custom attribute).
@
text
@d220 5
a224 1
					versionInfo.SetAttribute(cab);
@


1.10
log
@Marked a few fields readonly.
@
text
@d2 1
a2 1
  Copyright (C) 2008, 2009 Jeroen Frijters
d54 1
d133 5
d233 5
@


1.9
log
@Removed mcs specific flag that is no longer required.
@
text
@d50 4
a53 4
		private List<ResourceFile> resourceFiles = new List<ResourceFile>();
		private List<ModuleBuilder> modules = new List<ModuleBuilder>();
		private List<CustomAttributeBuilder> customAttributes = new List<CustomAttributeBuilder>();
		private List<CustomAttributeBuilder> declarativeSecurity = new List<CustomAttributeBuilder>();
@


1.8
log
@AssemblyBuilder.GetName() should return a name with a public key when were doing delay signing.
@
text
@a39 1
		internal readonly bool mcs;
a70 2
			// support for mcs specific flag
			mcs = (access & (AssemblyBuilderAccess)0x800) != 0;
@


1.7
log
@Added support for delay signing (i.e. setting the public key without having the private key).
@
text
@d82 1
a82 8
			if (name.KeyPair != null)
			{
				n.SetPublicKey(name.KeyPair.PublicKey);
			}
			else
			{
				n.SetPublicKey(Empty<byte>.Array);
			}
@


1.6
log
@A Version object that only has Major.Minor set will return -1 for Build and Revision. Handle that case by setting these parts to zero, instead of casting to 65535.
@
text
@d186 2
a187 1
			if (name.KeyPair != null)
d189 1
a189 1
				assemblyRecord.PublicKey = manifestModule.Blobs.Add(ByteBuffer.Wrap(name.KeyPair.PublicKey));
d257 1
a257 1
						ModuleWriter.WriteModule(null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, null, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
d262 1
a262 1
						ModuleWriter.WriteModule(null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, null, moduleBuilder.unmanagedResources, 0);
d275 16
a290 1
			ModuleWriter.WriteModule(name.KeyPair, manifestModule, fileKind, portableExecutableKind, imageFileMachine, versionInfoData, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
@


1.5
log
@Introduced Empty<T> to cache zero length arrays.
@
text
@d183 2
a184 2
				assemblyRecord.BuildNumber = (ushort)name.Version.Build;
				assemblyRecord.RevisionNumber = (ushort)name.Version.Revision;
@


1.4
log
@- Assembly version number parts should be treated as unsigned shorts.
- Added support for encoding/decoding custom attributes on generic parameters (this encoding is missing from the June 2006 ECMA CLI spec).
@
text
@d88 1
a88 1
				n.SetPublicKey(new byte[0]);
d397 1
a397 1
			return new AssemblyName[0];
@


1.3
log
@Support for mcs specific AssemblyBuilderAccess flag (0x800 aka COMPILER_ACCESS) to allow access to members of unbaked TypeBuilders.
@
text
@d181 4
a184 4
				assemblyRecord.MajorVersion = (short)name.Version.Major;
				assemblyRecord.MinorVersion = (short)name.Version.Minor;
				assemblyRecord.BuildNumber = (short)name.Version.Build;
				assemblyRecord.RevisionNumber = (short)name.Version.Revision;
@


1.2
log
@Removed UTF-8 byte order marks.
@
text
@d40 1
d63 1
a63 1
		internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
d72 2
@


1.1
log
@New IKVM.Reflection implementation.
@
text
@d1 1
a1 1
﻿/*
@

