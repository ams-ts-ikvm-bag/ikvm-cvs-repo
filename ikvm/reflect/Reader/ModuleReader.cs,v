head	1.97;
access;
symbols
	v8_1_5717_0:1.92
	v8_1:1.92.0.2
	v8_0_5449_1:1.89
	v8_0_5449_0:1.89
	v8_0:1.89.0.4
	v7_4_5196_0:1.89
	v7_4:1.89.0.2
	v7_3:1.82.0.2
	v7_2_4630_6:1.65.2.2
	v7_2_4630_5:1.65.2.2
	v7_2_4630_4:1.65.2.2
	v7_2_4630_3:1.65.2.2
	v7_2_4630_2:1.65.2.1
	v0_46_0_4:1.29.2.1
	v7_2_4630_1:1.65
	v7_2:1.65.0.2
	v7_1_4532_2:1.62
	v7_1_4532_1:1.62
	v7_1_4532_0:1.62
	v7_1:1.62.0.2
	v7_0_4335_3:1.45
	v7_0_4335_2:1.45
	v7_0_4335_1:1.45
	v0_46_0_2:1.29.2.1
	v7_0_4335_0:1.45
	v7_0:1.45.0.2
	v0_46_0_1:1.29.2.1
	v0_46_0_0:1.29
	v0_46:1.29.0.2
	v0_44_0_6:1.12
	v0_44_0_5:1.12
	v0_44_0_4:1.12
	v0_44_0_3:1.12
	v0_44_0_2:1.12
	v0_44_0_1:1.12
	v0_44_0_0:1.12
	v0_44:1.12.0.2;
locks; strict;
comment	@ * @;


1.97
date	2016.07.01.05.44.41;	author jfrijters;	state Exp;
branches;
next	1.96;

1.96
date	2016.07.01.05.15.22;	author jfrijters;	state Exp;
branches;
next	1.95;

1.95
date	2016.07.01.04.52.50;	author jfrijters;	state Exp;
branches;
next	1.94;

1.94
date	2015.11.03.09.28.18;	author jfrijters;	state Exp;
branches;
next	1.93;

1.93
date	2015.11.03.08.19.22;	author jfrijters;	state Exp;
branches;
next	1.92;

1.92
date	2015.04.06.07.06.31;	author jfrijters;	state Exp;
branches;
next	1.91;

1.91
date	2015.04.06.06.54.43;	author jfrijters;	state Exp;
branches;
next	1.90;

1.90
date	2015.02.16.12.24.28;	author jfrijters;	state Exp;
branches;
next	1.89;

1.89
date	2013.12.03.15.50.33;	author jfrijters;	state Exp;
branches;
next	1.88;

1.88
date	2013.12.03.13.04.24;	author jfrijters;	state Exp;
branches;
next	1.87;

1.87
date	2013.09.24.06.11.52;	author jfrijters;	state Exp;
branches;
next	1.86;

1.86
date	2013.09.22.06.54.37;	author jfrijters;	state Exp;
branches;
next	1.85;

1.85
date	2013.09.20.12.49.23;	author jfrijters;	state Exp;
branches;
next	1.84;

1.84
date	2013.09.11.13.30.51;	author jfrijters;	state Exp;
branches;
next	1.83;

1.83
date	2013.06.04.10.11.23;	author jfrijters;	state Exp;
branches;
next	1.82;

1.82
date	2013.01.29.11.54.43;	author jfrijters;	state Exp;
branches;
next	1.81;

1.81
date	2013.01.29.08.10.44;	author jfrijters;	state Exp;
branches;
next	1.80;

1.80
date	2013.01.28.07.18.51;	author jfrijters;	state Exp;
branches;
next	1.79;

1.79
date	2013.01.07.13.22.30;	author jfrijters;	state Exp;
branches;
next	1.78;

1.78
date	2013.01.07.12.03.05;	author jfrijters;	state Exp;
branches;
next	1.77;

1.77
date	2013.01.07.11.57.04;	author jfrijters;	state Exp;
branches;
next	1.76;

1.76
date	2012.12.06.13.55.02;	author jfrijters;	state Exp;
branches;
next	1.75;

1.75
date	2012.12.04.09.03.20;	author jfrijters;	state Exp;
branches;
next	1.74;

1.74
date	2012.11.21.07.36.04;	author jfrijters;	state Exp;
branches;
next	1.73;

1.73
date	2012.11.20.15.01.55;	author jfrijters;	state Exp;
branches;
next	1.72;

1.72
date	2012.11.20.14.33.13;	author jfrijters;	state Exp;
branches;
next	1.71;

1.71
date	2012.11.20.13.31.09;	author jfrijters;	state Exp;
branches;
next	1.70;

1.70
date	2012.10.19.19.19.20;	author jfrijters;	state Exp;
branches;
next	1.69;

1.69
date	2012.10.14.15.00.22;	author jfrijters;	state Exp;
branches;
next	1.68;

1.68
date	2012.10.13.20.12.32;	author jfrijters;	state Exp;
branches;
next	1.67;

1.67
date	2012.10.12.14.09.42;	author jfrijters;	state Exp;
branches;
next	1.66;

1.66
date	2012.10.04.11.45.36;	author jfrijters;	state Exp;
branches;
next	1.65;

1.65
date	2012.07.16.12.36.31;	author jfrijters;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2012.07.16.07.23.00;	author jfrijters;	state Exp;
branches;
next	1.63;

1.63
date	2012.07.12.09.13.43;	author jfrijters;	state Exp;
branches;
next	1.62;

1.62
date	2012.04.18.09.56.34;	author jfrijters;	state Exp;
branches;
next	1.61;

1.61
date	2012.04.18.09.55.23;	author jfrijters;	state Exp;
branches;
next	1.60;

1.60
date	2012.04.18.09.20.46;	author jfrijters;	state Exp;
branches;
next	1.59;

1.59
date	2012.04.09.10.04.58;	author jfrijters;	state Exp;
branches;
next	1.58;

1.58
date	2012.03.21.12.36.44;	author jfrijters;	state Exp;
branches;
next	1.57;

1.57
date	2012.03.21.11.32.08;	author jfrijters;	state Exp;
branches;
next	1.56;

1.56
date	2012.03.21.11.09.23;	author jfrijters;	state Exp;
branches;
next	1.55;

1.55
date	2012.01.27.10.11.18;	author jfrijters;	state Exp;
branches;
next	1.54;

1.54
date	2012.01.26.05.48.13;	author jfrijters;	state Exp;
branches;
next	1.53;

1.53
date	2012.01.18.11.15.46;	author jfrijters;	state Exp;
branches;
next	1.52;

1.52
date	2012.01.18.07.58.24;	author jfrijters;	state Exp;
branches;
next	1.51;

1.51
date	2012.01.16.08.49.56;	author jfrijters;	state Exp;
branches;
next	1.50;

1.50
date	2012.01.16.06.17.56;	author jfrijters;	state Exp;
branches;
next	1.49;

1.49
date	2012.01.12.06.50.52;	author jfrijters;	state Exp;
branches;
next	1.48;

1.48
date	2012.01.05.14.05.26;	author jfrijters;	state Exp;
branches;
next	1.47;

1.47
date	2011.12.01.12.03.23;	author jfrijters;	state Exp;
branches;
next	1.46;

1.46
date	2011.11.07.14.05.52;	author jfrijters;	state Exp;
branches;
next	1.45;

1.45
date	2011.10.11.04.57.58;	author jfrijters;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.19.21.26.44;	author jfrijters;	state Exp;
branches;
next	1.43;

1.43
date	2011.03.18.16.55.14;	author jfrijters;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.18.05.49.06;	author jfrijters;	state Exp;
branches;
next	1.41;

1.41
date	2011.03.17.09.19.10;	author jfrijters;	state Exp;
branches;
next	1.40;

1.40
date	2011.03.17.08.39.43;	author jfrijters;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.17.08.15.02;	author jfrijters;	state Exp;
branches;
next	1.38;

1.38
date	2011.03.13.09.51.01;	author jfrijters;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.11.15.15.25;	author jfrijters;	state Exp;
branches;
next	1.36;

1.36
date	2011.03.10.10.54.21;	author jfrijters;	state Exp;
branches;
next	1.35;

1.35
date	2011.03.09.06.06.00;	author jfrijters;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.08.07.47.46;	author jfrijters;	state Exp;
branches;
next	1.33;

1.33
date	2011.03.08.06.14.22;	author jfrijters;	state Exp;
branches;
next	1.32;

1.32
date	2011.03.08.05.49.01;	author jfrijters;	state Exp;
branches;
next	1.31;

1.31
date	2011.03.07.14.52.24;	author jfrijters;	state Exp;
branches;
next	1.30;

1.30
date	2011.03.03.16.06.44;	author jfrijters;	state Exp;
branches;
next	1.29;

1.29
date	2011.03.03.08.34.58;	author jfrijters;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2011.02.15.13.47.49;	author jfrijters;	state Exp;
branches;
next	1.27;

1.27
date	2011.02.14.05.54.46;	author jfrijters;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.26.13.34.04;	author jfrijters;	state Exp;
branches;
next	1.25;

1.25
date	2011.01.23.08.12.13;	author jfrijters;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.20.05.38.12;	author jfrijters;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.13.10.44.45;	author jfrijters;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.13.07.52.19;	author jfrijters;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.13.07.24.50;	author jfrijters;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.13.06.47.22;	author jfrijters;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.13.06.39.18;	author jfrijters;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.09.13.30.25;	author jfrijters;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.09.07.32.15;	author jfrijters;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.08.06.33.03;	author jfrijters;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.07.13.38.47;	author jfrijters;	state Exp;
branches;
next	1.14;

1.14
date	2010.11.29.14.00.11;	author jfrijters;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.29.09.28.48;	author jfrijters;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.30.07.28.11;	author jfrijters;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.30.07.24.21;	author jfrijters;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.30.07.22.06;	author jfrijters;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.12.06.14.19;	author jfrijters;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.12.05.56.19;	author jfrijters;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.11.06.09.50;	author jfrijters;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.06.06.45.30;	author jfrijters;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.06.05.59.17;	author jfrijters;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.18.09.05.26;	author jfrijters;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.25.10.37.56;	author jfrijters;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.25.05.49.02;	author jfrijters;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.25.05.29.32;	author jfrijters;	state Exp;
branches;
next	;

1.29.2.1
date	2011.03.17.05.18.42;	author jfrijters;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2013.09.10.15.16.03;	author jfrijters;	state Exp;
branches;
next	;

1.65.2.1
date	2012.10.08.07.43.48;	author jfrijters;	state Exp;
branches;
next	1.65.2.2;

1.65.2.2
date	2012.10.23.08.15.53;	author jfrijters;	state Exp;
branches;
next	;


desc
@@


1.97
log
@Replaced CORECLR symbol with NETSTANDARD.
@
text
@/*
  Copyright (C) 2009-2013 Jeroen Frijters

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jeroen Frijters
  jeroen@@frijters.net
  
*/
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using IKVM.Reflection.Metadata;

namespace IKVM.Reflection.Reader
{
	sealed class StreamHeader
	{
		internal uint Offset;
		internal uint Size;
		internal string Name;

		internal void Read(BinaryReader br)
		{
			Offset = br.ReadUInt32();
			Size = br.ReadUInt32();
			byte[] buf = new byte[32];
			byte b;
			int len = 0;
			while ((b = br.ReadByte()) != 0)
			{
				buf[len++] = b;
			}
			Name = Encoding.UTF8.GetString(buf, 0, len); ;
			int padding = -1 + ((len + 4) & ~3) - len;
			br.BaseStream.Seek(padding, SeekOrigin.Current);
		}
	}

	sealed class ModuleReader : Module
	{
		private readonly Stream stream;
		private readonly string location;
		private Assembly assembly;
		private readonly PEReader peFile = new PEReader();
		private readonly CliHeader cliHeader = new CliHeader();
		private string imageRuntimeVersion;
		private int metadataStreamVersion;
		private byte[] stringHeap;
		private byte[] blobHeap;
		private byte[] guidHeap;
		private uint userStringHeapOffset;
		private uint userStringHeapSize;
		private byte[] lazyUserStringHeap;
		private TypeDefImpl[] typeDefs;
		private TypeDefImpl moduleType;
		private Assembly[] assemblyRefs;
		private Type[] typeRefs;
		private Type[] typeSpecs;
		private FieldInfo[] fields;
		private MethodBase[] methods;
		private MemberInfo[] memberRefs;
		private Dictionary<int, string> strings = new Dictionary<int, string>();
		private Dictionary<TypeName, Type> types = new Dictionary<TypeName, Type>();
		private Dictionary<TypeName, LazyForwardedType> forwardedTypes = new Dictionary<TypeName, LazyForwardedType>();

		private sealed class LazyForwardedType
		{
			private readonly int index;
			private Type type;

			internal LazyForwardedType(int index)
			{
				this.index = index;
			}

			internal Type GetType(ModuleReader module)
			{
				// guard against circular type forwarding
				if (type == MarkerType.LazyResolveInProgress)
				{
					TypeName typeName = module.GetTypeName(module.ExportedType.records[index].TypeNamespace, module.ExportedType.records[index].TypeName);
					return module.universe.GetMissingTypeOrThrow(module, module, null, typeName).SetCyclicTypeForwarder();
				}
				else if (type == null)
				{
					type = MarkerType.LazyResolveInProgress;
					type = module.ResolveExportedType(index);
				}
				return type;
			}
		}

		internal ModuleReader(AssemblyReader assembly, Universe universe, Stream stream, string location, bool mapped)
			: base(universe)
		{
			this.stream = universe != null && universe.MetadataOnly ? null : stream;
			this.location = location;
			Read(stream, mapped);
			if (universe != null && universe.WindowsRuntimeProjection && imageRuntimeVersion.StartsWith("WindowsRuntime ", StringComparison.Ordinal))
			{
				WindowsRuntimeProjection.Patch(this, strings, ref imageRuntimeVersion, ref blobHeap);
			}
			if (assembly == null && AssemblyTable.records.Length != 0)
			{
				assembly = new AssemblyReader(location, this);
			}
			this.assembly = assembly;
		}

		private void Read(Stream stream, bool mapped)
		{
			BinaryReader br = new BinaryReader(stream);
			peFile.Read(br, mapped);
			stream.Seek(peFile.RvaToFileOffset(peFile.GetComDescriptorVirtualAddress()), SeekOrigin.Begin);
			cliHeader.Read(br);
			stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaData.VirtualAddress), SeekOrigin.Begin);
			foreach (StreamHeader sh in ReadStreamHeaders(br, out imageRuntimeVersion))
			{
				switch (sh.Name)
				{
					case "#Strings":
						stringHeap = ReadHeap(stream, sh.Offset, sh.Size);
						break;
					case "#Blob":
						blobHeap = ReadHeap(stream, sh.Offset, sh.Size);
						break;
					case "#US":
						userStringHeapOffset = sh.Offset;
						userStringHeapSize = sh.Size;
						break;
					case "#GUID":
						guidHeap = ReadHeap(stream, sh.Offset, sh.Size);
						break;
					case "#~":
					case "#-":
						stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaData.VirtualAddress + sh.Offset), SeekOrigin.Begin);
						ReadTables(br);
						break;
					default:
						// we ignore unknown streams, because the CLR does so too
						// (and some obfuscators add bogus streams)
						break;
				}
			}
		}

		internal void SetAssembly(Assembly assembly)
		{
			this.assembly = assembly;
		}

		private static StreamHeader[] ReadStreamHeaders(BinaryReader br, out string Version)
		{
			uint Signature = br.ReadUInt32();
			if (Signature != 0x424A5342)
			{
				throw new BadImageFormatException("Invalid metadata signature");
			}
			/*ushort MajorVersion =*/ br.ReadUInt16();
			/*ushort MinorVersion =*/ br.ReadUInt16();
			/*uint Reserved =*/ br.ReadUInt32();
			uint Length = br.ReadUInt32();
			byte[] buf = br.ReadBytes((int)Length);
			Version = Encoding.UTF8.GetString(buf).TrimEnd('\u0000');
			/*ushort Flags =*/ br.ReadUInt16();
			ushort Streams = br.ReadUInt16();
			StreamHeader[] streamHeaders = new StreamHeader[Streams];
			for (int i = 0; i < streamHeaders.Length; i++)
			{
				streamHeaders[i] = new StreamHeader();
				streamHeaders[i].Read(br);
			}
			return streamHeaders;
		}

		private void ReadTables(BinaryReader br)
		{
			Table[] tables = GetTables();
			/*uint Reserved0 =*/ br.ReadUInt32();
			byte MajorVersion = br.ReadByte();
			byte MinorVersion = br.ReadByte();
			metadataStreamVersion = MajorVersion << 16 | MinorVersion;
			byte HeapSizes = br.ReadByte();
			/*byte Reserved7 =*/ br.ReadByte();
			ulong Valid = br.ReadUInt64();
			ulong Sorted = br.ReadUInt64();
			for (int i = 0; i < 64; i++)
			{
				if ((Valid & (1UL << i)) != 0)
				{
					tables[i].Sorted = (Sorted & (1UL << i)) != 0;
					tables[i].RowCount = br.ReadInt32();
				}
			}
			MetadataReader mr = new MetadataReader(this, br.BaseStream, HeapSizes);
			for (int i = 0; i < 64; i++)
			{
				if ((Valid & (1UL << i)) != 0)
				{
					tables[i].Read(mr);
				}
			}
			if (ParamPtr.RowCount != 0)
			{
				throw new NotImplementedException("ParamPtr table support has not yet been implemented.");
			}
		}

		private byte[] ReadHeap(Stream stream, uint offset, uint size)
		{
			byte[] buf = new byte[size];
			stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaData.VirtualAddress + offset), SeekOrigin.Begin);
			for (int pos = 0; pos < buf.Length; )
			{
				int read = stream.Read(buf, pos, buf.Length - pos);
				if (read == 0)
				{
					throw new BadImageFormatException();
				}
				pos += read;
			}
			return buf;
		}

		internal void SeekRVA(int rva)
		{
			GetStream().Seek(peFile.RvaToFileOffset((uint)rva), SeekOrigin.Begin);
		}

		internal Stream GetStream()
		{
			if (stream == null)
			{
				throw new InvalidOperationException("Operation not available when UniverseOptions.MetadataOnly is enabled.");
			}
			return stream;
		}

		internal override void GetTypesImpl(List<Type> list)
		{
			PopulateTypeDef();
			foreach (TypeDefImpl type in typeDefs)
			{
				if (type != moduleType)
				{
					list.Add(type);
				}
			}
		}

		private void PopulateTypeDef()
		{
			if (typeDefs == null)
			{
				typeDefs = new TypeDefImpl[TypeDef.records.Length];
				for (int i = 0; i < typeDefs.Length; i++)
				{
					TypeDefImpl type = new TypeDefImpl(this, i);
					typeDefs[i] = type;
					if (type.IsModulePseudoType)
					{
						moduleType = type;
					}
					else if (!type.IsNestedByFlags)
					{
						types.Add(type.TypeName, type);
					}
				}
				// add forwarded types to forwardedTypes dictionary (because Module.GetType(string) should return them)
				for (int i = 0; i < ExportedType.records.Length; i++)
				{
					int implementation = ExportedType.records[i].Implementation;
					if (implementation >> 24 == AssemblyRefTable.Index)
					{
						TypeName typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
						forwardedTypes.Add(typeName, new LazyForwardedType(i));
					}
				}
			}
		}

		internal override string GetString(int index)
		{
			if (index == 0)
			{
				return null;
			}
			string str;
			if (!strings.TryGetValue(index, out str))
			{
				int len = 0;
				while (stringHeap[index + len] != 0)
				{
					len++;
				}
				str = Encoding.UTF8.GetString(stringHeap, index, len);
				strings.Add(index, str);
			}
			return str;
		}

		private static int ReadCompressedUInt(byte[] buffer, ref int offset)
		{
			byte b1 = buffer[offset++];
			if (b1 <= 0x7F)
			{
				return b1;
			}
			else if ((b1 & 0xC0) == 0x80)
			{
				byte b2 = buffer[offset++];
				return ((b1 & 0x3F) << 8) | b2;
			}
			else
			{
				byte b2 = buffer[offset++];
				byte b3 = buffer[offset++];
				byte b4 = buffer[offset++];
				return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;
			}
		}

		internal byte[] GetBlobCopy(int blobIndex)
		{
			int len = ReadCompressedUInt(blobHeap, ref blobIndex);
			byte[] buf = new byte[len];
			Buffer.BlockCopy(blobHeap, blobIndex, buf, 0, len);
			return buf;
		}

		internal override ByteReader GetBlob(int blobIndex)
		{
			return ByteReader.FromBlob(blobHeap, blobIndex);
		}

		public override string ResolveString(int metadataToken)
		{
			string str;
			if (!strings.TryGetValue(metadataToken, out str))
			{
				if ((metadataToken >> 24) != 0x70)
				{
					throw TokenOutOfRangeException(metadataToken);
				}
				if (lazyUserStringHeap == null)
				{
					lazyUserStringHeap = ReadHeap(GetStream(), userStringHeapOffset, userStringHeapSize);
				}
				int index = metadataToken & 0xFFFFFF;
				int len = ReadCompressedUInt(lazyUserStringHeap, ref index) & ~1;
				StringBuilder sb = new StringBuilder(len / 2);
				for (int i = 0; i < len; i += 2)
				{
					char ch = (char)(lazyUserStringHeap[index + i] | lazyUserStringHeap[index + i + 1] << 8);
					sb.Append(ch);
				}
				str = sb.ToString();
				strings.Add(metadataToken, str);
			}
			return str;
		}

		internal override Type ResolveType(int metadataToken, IGenericContext context)
		{
			int index = (metadataToken & 0xFFFFFF) - 1;
			if (index < 0)
			{
				throw TokenOutOfRangeException(metadataToken);
			}
			else if ((metadataToken >> 24) == TypeDefTable.Index && index < TypeDef.RowCount)
			{
				PopulateTypeDef();
				return typeDefs[index];
			}
			else if ((metadataToken >> 24) == TypeRefTable.Index && index < TypeRef.RowCount)
			{
				if (typeRefs == null)
				{
					typeRefs = new Type[TypeRef.records.Length];
				}
				if (typeRefs[index] == null)
				{
					int scope = TypeRef.records[index].ResolutionScope;
					switch (scope >> 24)
					{
						case AssemblyRefTable.Index:
							{
								Assembly assembly = ResolveAssemblyRef((scope & 0xFFFFFF) - 1);
								TypeName typeName = GetTypeName(TypeRef.records[index].TypeNamespace, TypeRef.records[index].TypeName);
								typeRefs[index] = assembly.ResolveType(this, typeName);
								break;
							}
						case TypeRefTable.Index:
							{
								Type outer = ResolveType(scope, null);
								TypeName typeName = GetTypeName(TypeRef.records[index].TypeNamespace, TypeRef.records[index].TypeName);
								typeRefs[index] = outer.ResolveNestedType(this, typeName);
								break;
							}
						case ModuleTable.Index:
						case ModuleRefTable.Index:
							{
								Module module;
								if (scope >> 24 == ModuleTable.Index)
								{
									if (scope == 0 || scope == 1)
									{
										module = this;
									}
									else
									{
										throw new NotImplementedException("self reference scope?");
									}
								}
								else
								{
									module = ResolveModuleRef(ModuleRef.records[(scope & 0xFFFFFF) - 1]);
								}
								TypeName typeName = GetTypeName(TypeRef.records[index].TypeNamespace, TypeRef.records[index].TypeName);
								typeRefs[index] = module.FindType(typeName) ?? module.universe.GetMissingTypeOrThrow(this, module, null, typeName);
								break;
							}
						default:
							throw new NotImplementedException("ResolutionScope = " + scope.ToString("X"));
					}
				}
				return typeRefs[index];
			}
			else if ((metadataToken >> 24) == TypeSpecTable.Index && index < TypeSpec.RowCount)
			{
				if (typeSpecs == null)
				{
					typeSpecs = new Type[TypeSpec.records.Length];
				}
				Type type = typeSpecs[index];
				if (type == null)
				{
					TrackingGenericContext tc = context == null ? null : new TrackingGenericContext(context);
					typeSpecs[index] = MarkerType.LazyResolveInProgress;
					try
					{
						type = Signature.ReadTypeSpec(this, ByteReader.FromBlob(blobHeap, TypeSpec.records[index]), tc);
					}
					finally
					{
						typeSpecs[index] = null;
					}
					if (tc == null || !tc.IsUsed)
					{
						typeSpecs[index] = type;
					}
				}
				else if (type == MarkerType.LazyResolveInProgress)
				{
					if (universe.MissingMemberResolution)
					{
						return universe.GetMissingTypeOrThrow(this, this, null, new TypeName(null, "Cyclic TypeSpec " + metadataToken.ToString("X")))
							.SetCyclicTypeSpec()
							.SetMetadataTokenForMissing(metadataToken, 0);
					}
					throw new BadImageFormatException("Cyclic TypeSpec " + metadataToken.ToString("X"));
				}
				return type;
			}
			else
			{
				throw TokenOutOfRangeException(metadataToken);
			}
		}

		private Module ResolveModuleRef(int moduleNameIndex)
		{
			string moduleName = GetString(moduleNameIndex);
			Module module = assembly.GetModule(moduleName);
			if (module == null)
			{
				throw new FileNotFoundException(moduleName);
			}
			return module;
		}

		private sealed class TrackingGenericContext : IGenericContext
		{
			private readonly IGenericContext context;
			private bool used;

			internal TrackingGenericContext(IGenericContext context)
			{
				this.context = context;
			}

			internal bool IsUsed
			{
				get { return used; }
			}

			public Type GetGenericTypeArgument(int index)
			{
				used = true;
				return context.GetGenericTypeArgument(index);
			}

			public Type GetGenericMethodArgument(int index)
			{
				used = true;
				return context.GetGenericMethodArgument(index);
			}
		}

		private TypeName GetTypeName(int typeNamespace, int typeName)
		{
			return new TypeName(GetString(typeNamespace), GetString(typeName));
		}

		internal Assembly ResolveAssemblyRef(int index)
		{
			if (assemblyRefs == null)
			{
				assemblyRefs = new Assembly[AssemblyRef.RowCount];
			}
			if (assemblyRefs[index] == null)
			{
				assemblyRefs[index] = ResolveAssemblyRefImpl(ref AssemblyRef.records[index]);
			}
			return assemblyRefs[index];
		}

		private Assembly ResolveAssemblyRefImpl(ref AssemblyRefTable.Record rec)
		{
			const int PublicKey = 0x0001;
			string name = AssemblyName.GetFullName(
				GetString(rec.Name),
				rec.MajorVersion,
				rec.MinorVersion,
				rec.BuildNumber,
				rec.RevisionNumber,
				rec.Culture == 0 ? "neutral" : GetString(rec.Culture),
				rec.PublicKeyOrToken == 0 ? Empty<byte>.Array : (rec.Flags & PublicKey) == 0 ? GetBlobCopy(rec.PublicKeyOrToken) : AssemblyName.ComputePublicKeyToken(GetBlobCopy(rec.PublicKeyOrToken)),
				rec.Flags);
			return universe.Load(name, this, true);
		}

		public override Guid ModuleVersionId
		{
			get
			{
				byte[] buf = new byte[16];
				Buffer.BlockCopy(guidHeap, 16 * (ModuleTable.records[0].Mvid - 1), buf, 0, 16);
				return new Guid(buf);
			}
		}

		public override string FullyQualifiedName
		{
			get { return location ?? "<Unknown>"; }
		}

		public override string Name
		{
			get { return location == null ? "<Unknown>" : System.IO.Path.GetFileName(location); }
		}

		public override Assembly Assembly
		{
			get { return assembly; }
		}

		internal override Type FindType(TypeName typeName)
		{
			PopulateTypeDef();
			Type type;
			if (!types.TryGetValue(typeName, out type))
			{
				LazyForwardedType fw;
				if (forwardedTypes.TryGetValue(typeName, out fw))
				{
					return fw.GetType(this);
				}
			}
			return type;
		}

		internal override Type FindTypeIgnoreCase(TypeName lowerCaseName)
		{
			PopulateTypeDef();
			foreach (Type type in types.Values)
			{
				if (type.TypeName.ToLowerInvariant() == lowerCaseName)
				{
					return type;
				}
			}
			foreach (TypeName name in forwardedTypes.Keys)
			{
				if (name.ToLowerInvariant() == lowerCaseName)
				{
					return forwardedTypes[name].GetType(this);
				}
			}
			return null;
		}

		private Exception TokenOutOfRangeException(int metadataToken)
		{
			return new ArgumentOutOfRangeException("metadataToken", String.Format("Token 0x{0:x8} is not valid in the scope of module {1}.", metadataToken, this.Name));
		}

		public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			switch (metadataToken >> 24)
			{
				case FieldTable.Index:
					return ResolveField(metadataToken, genericTypeArguments, genericMethodArguments);
				case MemberRefTable.Index:
					int index = (metadataToken & 0xFFFFFF) - 1;
					if (index < 0 || index >= MemberRef.RowCount)
					{
						goto default;
					}
					return GetMemberRef(index, genericTypeArguments, genericMethodArguments);
				case MethodDefTable.Index:
				case MethodSpecTable.Index:
					return ResolveMethod(metadataToken, genericTypeArguments, genericMethodArguments);
				case TypeRefTable.Index:
				case TypeDefTable.Index:
				case TypeSpecTable.Index:
					return ResolveType(metadataToken, genericTypeArguments, genericMethodArguments);
				default:
					throw TokenOutOfRangeException(metadataToken);
			}
		}

		internal FieldInfo GetFieldAt(TypeDefImpl owner, int index)
		{
			if (fields == null)
			{
				fields = new FieldInfo[Field.records.Length];
			}
			if (fields[index] == null)
			{
				fields[index] = new FieldDefImpl(this, owner ?? FindFieldOwner(index), index);
			}
			return fields[index];
		}

		public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			int index = (metadataToken & 0xFFFFFF) - 1;
			if (index < 0)
			{
				throw TokenOutOfRangeException(metadataToken);
			}
			else if ((metadataToken >> 24) == FieldTable.Index && index < Field.RowCount)
			{
				return GetFieldAt(null, index);
			}
			else if ((metadataToken >> 24) == MemberRefTable.Index && index < MemberRef.RowCount)
			{
				FieldInfo field = GetMemberRef(index, genericTypeArguments, genericMethodArguments) as FieldInfo;
				if (field != null)
				{
					return field;
				}
				throw new ArgumentException(String.Format("Token 0x{0:x8} is not a valid FieldInfo token in the scope of module {1}.", metadataToken, this.Name), "metadataToken");
			}
			else
			{
				throw TokenOutOfRangeException(metadataToken);
			}
		}

		private TypeDefImpl FindFieldOwner(int fieldIndex)
		{
			// TODO use binary search?
			for (int i = 0; i < TypeDef.records.Length; i++)
			{
				int field = TypeDef.records[i].FieldList - 1;
				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 : Field.records.Length;
				if (field <= fieldIndex && fieldIndex < end)
				{
					PopulateTypeDef();
					return typeDefs[i];
				}
			}
			throw new InvalidOperationException();
		}

		internal MethodBase GetMethodAt(TypeDefImpl owner, int index)
		{
			if (methods == null)
			{
				methods = new MethodBase[MethodDef.records.Length];
			}
			if (methods[index] == null)
			{
				MethodDefImpl method = new MethodDefImpl(this, owner ?? FindMethodOwner(index), index);
				methods[index] = method.IsConstructor ? new ConstructorInfoImpl(method) : (MethodBase)method;
			}
			return methods[index];
		}

		public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			int index = (metadataToken & 0xFFFFFF) - 1;
			if (index < 0)
			{
				throw TokenOutOfRangeException(metadataToken);
			}
			else if ((metadataToken >> 24) == MethodDefTable.Index && index < MethodDef.RowCount)
			{
				return GetMethodAt(null, index);
			}
			else if ((metadataToken >> 24) == MemberRefTable.Index && index < MemberRef.RowCount)
			{
				MethodBase method = GetMemberRef(index, genericTypeArguments, genericMethodArguments) as MethodBase;
				if (method != null)
				{
					return method;
				}
				throw new ArgumentException(String.Format("Token 0x{0:x8} is not a valid MethodBase token in the scope of module {1}.", metadataToken, this.Name), "metadataToken");
			}
			else if ((metadataToken >> 24) == MethodSpecTable.Index && index < MethodSpec.RowCount)
			{
				MethodInfo method = (MethodInfo)ResolveMethod(MethodSpec.records[index].Method, genericTypeArguments, genericMethodArguments);
				ByteReader instantiation = ByteReader.FromBlob(blobHeap, MethodSpec.records[index].Instantiation);
				return method.MakeGenericMethod(Signature.ReadMethodSpec(this, instantiation, new GenericContext(genericTypeArguments, genericMethodArguments)));
			}
			else
			{
				throw TokenOutOfRangeException(metadataToken);
			}
		}

		public override Type[] __ResolveOptionalParameterTypes(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments, out CustomModifiers[] customModifiers)
		{
			int index = (metadataToken & 0xFFFFFF) - 1;
			if (index < 0)
			{
				throw TokenOutOfRangeException(metadataToken);
			}
			else if ((metadataToken >> 24) == MemberRefTable.Index && index < MemberRef.RowCount)
			{
				int sig = MemberRef.records[index].Signature;
				return Signature.ReadOptionalParameterTypes(this, GetBlob(sig), new GenericContext(genericTypeArguments, genericMethodArguments), out customModifiers);
			}
			else if ((metadataToken >> 24) == MethodDefTable.Index && index < MethodDef.RowCount)
			{
				// for convenience, we support passing a MethodDef token as well, because in some places
				// it makes sense to have a vararg method that is referred to by its methoddef (e.g. ldftn).
				// Note that MethodSpec doesn't make sense, because generic methods cannot be vararg.
				customModifiers = Empty<CustomModifiers>.Array;
				return Type.EmptyTypes;
			}
			else
			{
				throw TokenOutOfRangeException(metadataToken);
			}
		}

		public override CustomModifiers __ResolveTypeSpecCustomModifiers(int typeSpecToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			int index = (typeSpecToken & 0xFFFFFF) - 1;
			if (typeSpecToken >> 24 != TypeSpecTable.Index || index < 0 || index >= TypeSpec.RowCount)
			{
				throw TokenOutOfRangeException(typeSpecToken);
			}
			return CustomModifiers.Read(this, ByteReader.FromBlob(blobHeap, TypeSpec.records[index]), new GenericContext(genericTypeArguments, genericMethodArguments));
		}

		public override string ScopeName
		{
			get { return GetString(ModuleTable.records[0].Name); }
		}

		private TypeDefImpl FindMethodOwner(int methodIndex)
		{
			// TODO use binary search?
			for (int i = 0; i < TypeDef.records.Length; i++)
			{
				int method = TypeDef.records[i].MethodList - 1;
				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 : MethodDef.records.Length;
				if (method <= methodIndex && methodIndex < end)
				{
					PopulateTypeDef();
					return typeDefs[i];
				}
			}
			throw new InvalidOperationException();
		}

		private MemberInfo GetMemberRef(int index, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			if (memberRefs == null)
			{
				memberRefs = new MemberInfo[MemberRef.records.Length];
			}
			if (memberRefs[index] == null)
			{
				int owner = MemberRef.records[index].Class;
				int sig = MemberRef.records[index].Signature;
				string name = GetString(MemberRef.records[index].Name);
				switch (owner >> 24)
				{
					case MethodDefTable.Index:
						return GetMethodAt(null, (owner & 0xFFFFFF) - 1);
					case ModuleRefTable.Index:
						memberRefs[index] = ResolveTypeMemberRef(ResolveModuleType(owner), name, ByteReader.FromBlob(blobHeap, sig));
						break;
					case TypeDefTable.Index:
					case TypeRefTable.Index:
						memberRefs[index] = ResolveTypeMemberRef(ResolveType(owner), name, ByteReader.FromBlob(blobHeap, sig));
						break;
					case TypeSpecTable.Index:
					{
						Type type = ResolveType(owner, genericTypeArguments, genericMethodArguments);
						if (type.IsArray)
						{
							MethodSignature methodSig = MethodSignature.ReadSig(this, ByteReader.FromBlob(blobHeap, sig), new GenericContext(genericTypeArguments, genericMethodArguments));
							return type.FindMethod(name, methodSig)
								?? universe.GetMissingMethodOrThrow(this, type, name, methodSig);
						}
						else if (type.IsConstructedGenericType)
						{
							MemberInfo member = ResolveTypeMemberRef(type.GetGenericTypeDefinition(), name, ByteReader.FromBlob(blobHeap, sig));
							MethodBase mb = member as MethodBase;
							if (mb != null)
							{
								member = mb.BindTypeParameters(type);
							}
							FieldInfo fi = member as FieldInfo;
							if (fi != null)
							{
								member = fi.BindTypeParameters(type);
							}
							return member;
						}
						else
						{
							return ResolveTypeMemberRef(type, name, ByteReader.FromBlob(blobHeap, sig));
						}
					}
					default:
						throw new BadImageFormatException();
				}
			}
			return memberRefs[index];
		}

		private Type ResolveModuleType(int token)
		{
			int index = (token & 0xFFFFFF) - 1;
			string name = GetString(ModuleRef.records[index]);
			Module module = assembly.GetModule(name);
			if (module == null || module.IsResource())
			{
				throw new BadImageFormatException();
			}
			return module.GetModuleType();
		}

		private MemberInfo ResolveTypeMemberRef(Type type, string name, ByteReader sig)
		{
			if (sig.PeekByte() == Signature.FIELD)
			{
				Type org = type;
				FieldSignature fieldSig = FieldSignature.ReadSig(this, sig, type);
				FieldInfo field = type.FindField(name, fieldSig);
				if (field == null && universe.MissingMemberResolution)
				{
					return universe.GetMissingFieldOrThrow(this, type, name, fieldSig);
				}
				while (field == null && (type = type.BaseType) != null)
				{
					field = type.FindField(name, fieldSig);
				}
				if (field != null)
				{
					return field;
				}
#if NETSTANDARD
				throw new MissingFieldException(org.ToString() + "." + name);
#else
				throw new MissingFieldException(org.ToString(), name);
#endif
			}
			else
			{
				Type org = type;
				MethodSignature methodSig = MethodSignature.ReadSig(this, sig, type);
				MethodBase method = type.FindMethod(name, methodSig);
				if (method == null && universe.MissingMemberResolution)
				{
					return universe.GetMissingMethodOrThrow(this, type, name, methodSig);
				}
				while (method == null && (type = type.BaseType) != null)
				{
					method = type.FindMethod(name, methodSig);
				}
				if (method != null)
				{
					return method;
				}
#if NETSTANDARD
				throw new MissingMethodException(org.ToString() + "." + name);
#else
				throw new MissingMethodException(org.ToString(), name);
#endif
			}
		}

		internal ByteReader GetStandAloneSig(int index)
		{
			return ByteReader.FromBlob(blobHeap, StandAloneSig.records[index]);
		}

		public override byte[] ResolveSignature(int metadataToken)
		{
			int index = (metadataToken & 0xFFFFFF) - 1;
			if ((metadataToken >> 24) == StandAloneSigTable.Index && index >= 0 && index < StandAloneSig.RowCount)
			{
				ByteReader br = GetStandAloneSig(index);
				return br.ReadBytes(br.Length);
			}
			else
			{
				throw TokenOutOfRangeException(metadataToken);
			}
		}

		public override __StandAloneMethodSig __ResolveStandAloneMethodSig(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			int index = (metadataToken & 0xFFFFFF) - 1;
			if ((metadataToken >> 24) == StandAloneSigTable.Index && index >= 0 && index < StandAloneSig.RowCount)
			{
				return MethodSignature.ReadStandAloneMethodSig(this, GetStandAloneSig(index), new GenericContext(genericTypeArguments, genericMethodArguments));
			}
			else
			{
				throw TokenOutOfRangeException(metadataToken);
			}
		}

		internal MethodInfo GetEntryPoint()
		{
			if (cliHeader.EntryPointToken != 0 && (cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT) == 0)
			{
				return (MethodInfo)ResolveMethod((int)cliHeader.EntryPointToken);
			}
			return null;
		}

		internal string[] GetManifestResourceNames()
		{
			string[] names = new string[ManifestResource.records.Length];
			for (int i = 0; i < ManifestResource.records.Length; i++)
			{
				names[i] = GetString(ManifestResource.records[i].Name);
			}
			return names;
		}

		internal ManifestResourceInfo GetManifestResourceInfo(string resourceName)
		{
			for (int i = 0; i < ManifestResource.records.Length; i++)
			{
				if (resourceName == GetString(ManifestResource.records[i].Name))
				{
					ManifestResourceInfo info = new ManifestResourceInfo(this, i);
					Assembly asm = info.ReferencedAssembly;
					if (asm != null && !asm.__IsMissing && asm.GetManifestResourceInfo(resourceName) == null)
					{
						return null;
					}
					return info;
				}
			}
			return null;
		}

		internal Stream GetManifestResourceStream(string resourceName)
		{
			for (int i = 0; i < ManifestResource.records.Length; i++)
			{
				if (resourceName == GetString(ManifestResource.records[i].Name))
				{
					if (ManifestResource.records[i].Implementation != 0x26000000)
					{
						ManifestResourceInfo info = new ManifestResourceInfo(this, i);
						switch (ManifestResource.records[i].Implementation >> 24)
						{
							case FileTable.Index:
								string fileName = Path.Combine(Path.GetDirectoryName(location), info.FileName);
								if (System.IO.File.Exists(fileName))
								{
									// note that, like System.Reflection, we return null for zero length files and
									// ManifestResource.Offset is ignored
									FileStream fs = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);
									if (fs.Length == 0)
									{
										fs.Dispose();
										return null;
									}
									return fs;
								}
								return null;
							case AssemblyRefTable.Index:
								Assembly asm = info.ReferencedAssembly;
								if (asm.__IsMissing)
								{
									return null;
								}
								return asm.GetManifestResourceStream(resourceName);
							default:
								throw new BadImageFormatException();
						}
					}
					SeekRVA((int)cliHeader.Resources.VirtualAddress + ManifestResource.records[i].Offset);
					BinaryReader br = new BinaryReader(stream);
					int length = br.ReadInt32();
					return new MemoryStream(br.ReadBytes(length));
				}
			}
			return null;
		}

		public override AssemblyName[] __GetReferencedAssemblies()
		{
			List<AssemblyName> list = new List<AssemblyName>();
			for (int i = 0; i < AssemblyRef.records.Length; i++)
			{
				AssemblyName name = new AssemblyName();
				name.Name = GetString(AssemblyRef.records[i].Name);
				name.Version = new Version(
					AssemblyRef.records[i].MajorVersion,
					AssemblyRef.records[i].MinorVersion,
					AssemblyRef.records[i].BuildNumber,
					AssemblyRef.records[i].RevisionNumber);
				if (AssemblyRef.records[i].PublicKeyOrToken != 0)
				{
					byte[] keyOrToken = GetBlobCopy(AssemblyRef.records[i].PublicKeyOrToken);
					const int PublicKey = 0x0001;
					if ((AssemblyRef.records[i].Flags & PublicKey) != 0)
					{
						name.SetPublicKey(keyOrToken);
					}
					else
					{
						name.SetPublicKeyToken(keyOrToken);
					}
				}
				else
				{
					name.SetPublicKeyToken(Empty<byte>.Array);
				}
				if (AssemblyRef.records[i].Culture != 0)
				{
					name.CultureName = GetString(AssemblyRef.records[i].Culture);
				}
				else
				{
					name.CultureName = "";
				}
				if (AssemblyRef.records[i].HashValue != 0)
				{
					name.hash = GetBlobCopy(AssemblyRef.records[i].HashValue);
				}
				name.RawFlags = (AssemblyNameFlags)AssemblyRef.records[i].Flags;
				list.Add(name);
			}
			return list.ToArray();
		}

		public override void __ResolveReferencedAssemblies(Assembly[] assemblies)
		{
			if (assemblyRefs == null)
			{
				assemblyRefs = new Assembly[AssemblyRef.RowCount];
			}
			for (int i = 0; i < assemblies.Length; i++)
			{
				if (assemblyRefs[i] == null)
				{
					assemblyRefs[i] = assemblies[i];
				}
			}
		}

		public override string[] __GetReferencedModules()
		{
			string[] arr = new string[this.ModuleRef.RowCount];
			for (int i = 0; i < arr.Length; i++)
			{
				arr[i] = GetString(this.ModuleRef.records[i]);
			}
			return arr;
		}

		public override Type[] __GetReferencedTypes()
		{
			Type[] arr = new Type[this.TypeRef.RowCount];
			for (int i = 0; i < arr.Length; i++)
			{
				arr[i] = ResolveType((TypeRefTable.Index << 24) + i + 1);
			}
			return arr;
		}

		public override Type[] __GetExportedTypes()
		{
			Type[] arr = new Type[this.ExportedType.RowCount];
			for (int i = 0; i < arr.Length; i++)
			{
				arr[i] = ResolveExportedType(i);
			}
			return arr;
		}

		private Type ResolveExportedType(int index)
		{
			TypeName typeName = GetTypeName(ExportedType.records[index].TypeNamespace, ExportedType.records[index].TypeName);
			int implementation = ExportedType.records[index].Implementation;
			int token = ExportedType.records[index].TypeDefId;
			int flags = ExportedType.records[index].Flags;
			switch (implementation >> 24)
			{
				case AssemblyRefTable.Index:
					return ResolveAssemblyRef((implementation & 0xFFFFFF) - 1).ResolveType(this, typeName).SetMetadataTokenForMissing(token, flags);
				case ExportedTypeTable.Index:
					return ResolveExportedType((implementation & 0xFFFFFF) - 1).ResolveNestedType(this, typeName).SetMetadataTokenForMissing(token, flags);
				case FileTable.Index:
					Module module = assembly.GetModule(GetString(File.records[(implementation & 0xFFFFFF) - 1].Name));
					return module.FindType(typeName) ?? module.universe.GetMissingTypeOrThrow(this, module, null, typeName).SetMetadataTokenForMissing(token, flags);
				default:
					throw new BadImageFormatException();
			}
		}

		internal override Type GetModuleType()
		{
			PopulateTypeDef();
			return moduleType;
		}

		public override string __ImageRuntimeVersion
		{
			get { return imageRuntimeVersion; }
		}

		public override int MDStreamVersion
		{
			get { return metadataStreamVersion; }
		}

		public override void __GetDataDirectoryEntry(int index, out int rva, out int length)
		{
			peFile.GetDataDirectoryEntry(index, out rva, out length);
		}

		public override long __RelativeVirtualAddressToFileOffset(int rva)
		{
			return peFile.RvaToFileOffset((uint)rva);
		}

		public override bool __GetSectionInfo(int rva, out string name, out int characteristics, out int virtualAddress, out int virtualSize, out int pointerToRawData, out int sizeOfRawData)
		{
			return peFile.GetSectionInfo(rva, out name, out characteristics, out virtualAddress, out virtualSize, out pointerToRawData, out sizeOfRawData);
		}

		public override int __ReadDataFromRVA(int rva, byte[] data, int offset, int length)
		{
			SeekRVA(rva);
			int totalBytesRead = 0;
			while (length > 0)
			{
				int read = stream.Read(data, offset, length);
				if (read == 0)
				{
					// C++ assemblies can have fields that have an RVA that lies outside of the file
					break;
				}
				offset += read;
				length -= read;
				totalBytesRead += read;
			}
			return totalBytesRead;
		}

		public override void GetPEKind(out PortableExecutableKinds peKind, out ImageFileMachine machine)
		{
			peKind = 0;
			if ((cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_ILONLY) != 0)
			{
				peKind |= PortableExecutableKinds.ILOnly;
			}
			switch (cliHeader.Flags & (CliHeader.COMIMAGE_FLAGS_32BITREQUIRED | CliHeader.COMIMAGE_FLAGS_32BITPREFERRED))
			{
				case CliHeader.COMIMAGE_FLAGS_32BITREQUIRED:
					peKind |= PortableExecutableKinds.Required32Bit;
					break;
				case CliHeader.COMIMAGE_FLAGS_32BITREQUIRED | CliHeader.COMIMAGE_FLAGS_32BITPREFERRED:
					peKind |= PortableExecutableKinds.Preferred32Bit;
					break;
				default:
					// COMIMAGE_FLAGS_32BITPREFERRED by itself is illegal, so we ignore it
					// (not setting any flag is ok)
					break;
			}
			if (peFile.OptionalHeader.Magic == IMAGE_OPTIONAL_HEADER.IMAGE_NT_OPTIONAL_HDR64_MAGIC)
			{
				peKind |= PortableExecutableKinds.PE32Plus;
			}

			machine = (ImageFileMachine)peFile.FileHeader.Machine;
		}

		public override int __Subsystem
		{
			get { return peFile.OptionalHeader.Subsystem; }
		}

		public override IList<CustomAttributeData> __GetPlaceholderAssemblyCustomAttributes(bool multiple, bool security)
		{
			TypeName typeName;
			switch ((multiple ? 1 : 0) + (security ? 2 : 0))
			{
				case 0:
					typeName = new TypeName("System.Runtime.CompilerServices", "AssemblyAttributesGoHere");
					break;
				case 1:
					typeName = new TypeName("System.Runtime.CompilerServices", "AssemblyAttributesGoHereM");
					break;
				case 2:
					typeName = new TypeName("System.Runtime.CompilerServices", "AssemblyAttributesGoHereS");
					break;
				case 3:
				default:
					typeName = new TypeName("System.Runtime.CompilerServices", "AssemblyAttributesGoHereSM");
					break;
			}
			List<CustomAttributeData> list = new List<CustomAttributeData>();
			for (int i = 0; i < CustomAttribute.records.Length; i++)
			{
				if ((CustomAttribute.records[i].Parent >> 24) == TypeRefTable.Index)
				{
					int index = (CustomAttribute.records[i].Parent & 0xFFFFFF) - 1;
					if (typeName == GetTypeName(TypeRef.records[index].TypeNamespace, TypeRef.records[index].TypeName))
					{
						list.Add(new CustomAttributeData(this, i));
					}
				}
			}
			return list;
		}

		internal override void Dispose()
		{
			if (stream != null)
			{
				stream.Dispose();
			}
		}

		internal override void ExportTypes(int fileToken, IKVM.Reflection.Emit.ModuleBuilder manifestModule)
		{
			PopulateTypeDef();
			manifestModule.ExportTypes(typeDefs, fileToken);
		}

		protected override long GetImageBaseImpl()
		{
			return (long)peFile.OptionalHeader.ImageBase;
		}

		protected override long GetStackReserveImpl()
		{
			return (long)peFile.OptionalHeader.SizeOfStackReserve;
		}

		protected override int GetFileAlignmentImpl()
		{
			return (int)peFile.OptionalHeader.FileAlignment;
		}

		protected override DllCharacteristics GetDllCharacteristicsImpl()
		{
			return (DllCharacteristics)peFile.OptionalHeader.DllCharacteristics;
		}

		public override int __EntryPointRVA
		{
			get { return (cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT) != 0 ? (int)cliHeader.EntryPointToken : 0; }
		}

		public override int __EntryPointToken
		{
			get { return (cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT) == 0 ? (int)cliHeader.EntryPointToken : 0; }
		}

#if !NO_AUTHENTICODE
		public override System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate()
		{
			return Authenticode.GetSignerCertificate(GetStream());
		}
#endif // !NO_AUTHENTICODE
	}
}
@


1.96
log
@Added support for building against .NET Standard 1.3.
@
text
@d896 1
a896 1
#if CORECLR
d919 1
a919 1
#if CORECLR
@


1.95
log
@Added supported for cyclic TypeSpec.
@
text
@d1016 1
a1016 1
										fs.Close();
d1275 1
a1275 1
				stream.Close();
@


1.94
log
@Added a dedicated MarkerType for circular type forwarding detection, instead of abusing MarkerType.Pinned.
@
text
@d455 9
a463 1
					type = Signature.ReadTypeSpec(this, ByteReader.FromBlob(blobHeap, TypeSpec.records[index]), tc);
d469 10
@


1.93
log
@Added AssemblyName.CultureName property setter that was introduced with .NET 4.6.
@
text
@d95 1
a95 1
				if (type == MarkerType.Pinned)
d102 1
a102 1
					type = MarkerType.Pinned;
@


1.92
log
@Added internal Type.TypeName virtual property to retrieve type name with a single virtual method call.
@
text
@d1055 1
a1055 1
					name.Culture = GetString(AssemblyRef.records[i].Culture);
d1059 1
a1059 1
					name.Culture = "";
@


1.91
log
@Renamed TypeNameSpace to TypeNamespace for consistency.
@
text
@d282 1
a282 1
						types.Add(new TypeName(type.__Namespace, type.__Name), type);
d586 1
a586 1
				if (new TypeName(type.__Namespace, type.__Name).ToLowerInvariant() == lowerCaseName)
@


1.90
log
@Added CoreCLR target for IKVM.Reflection.
@
text
@d405 1
a405 1
								TypeName typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
d412 1
a412 1
								TypeName typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
d435 1
a435 1
								TypeName typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
d1244 1
a1244 1
					if (typeName == GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName))
@


1.89
log
@When a cyclic type forwarder is found and UniverseOptions.ResolveMissingMembers is set, we should not throw an exception but instead create a missing type. Added a new Type.__IsCyclicTypeForwarder property to allow detecting this case.
@
text
@d878 3
d882 1
d901 3
d905 1
@


1.88
log
@Throw TypeLoadException when exported type (indirectly) points to itself.
@
text
@d98 1
a98 1
					throw new TypeLoadException(String.Format("Could not load type '{0}' from assembly '{1}'.", typeName, module.Assembly.FullName));
@


1.87
log
@Fixed regression. AssemblyName.GetAssemblyName() constructs a module without a universe, so we need to check if universe is null before using it.
@
text
@d94 12
a105 1
				return type ?? (type = module.ResolveExportedType(index));
@


1.86
log
@Fixed WindowsRuntime assembly detection (for projection purposes).
@
text
@d104 1
a104 1
			if (universe.WindowsRuntimeProjection && imageRuntimeVersion.StartsWith("WindowsRuntime ", StringComparison.Ordinal))
@


1.85
log
@Implemented WinMD projection support.
@
text
@d104 4
a109 4
				if (universe.WindowsRuntimeProjection && (AssemblyTable.records[0].Flags & 0xE00) >> 9 == 1)
				{
					WindowsRuntimeProjection.Patch(this, strings, ref imageRuntimeVersion, ref blobHeap);
				}
@


1.84
log
@Fixed ResolveAssemblyRefImpl() to use AssemblyName.GetFullName() to fix a number of bugs:
- Name was not escaped.
- Retargetable and ContentType attributes were not added.
- PublicKey was not converted to PublicKeyToken.
@
text
@d106 4
@


1.83
log
@Added Universe.OpenMappedRawModule() API to enable reading modules from memory or a crash dump file.
@
text
@d514 1
a514 1
			string name = String.Format("{0}, Version={1}.{2}.{3}.{4}, Culture={5}, {6}={7}",
d521 2
a522 2
				(rec.Flags & PublicKey) == 0 ? "PublicKeyToken" : "PublicKey",
				PublicKeyOrTokenToString(rec.PublicKeyOrToken));
a525 19
		private string PublicKeyOrTokenToString(int publicKeyOrToken)
		{
			if (publicKeyOrToken == 0)
			{
				return "null";
			}
			ByteReader br = GetBlob(publicKeyOrToken);
			if (br.Length == 0)
			{
				return "null";
			}
			StringBuilder sb = new StringBuilder(br.Length * 2);
			while (br.Length > 0)
			{
				sb.AppendFormat("{0:x2}", br.ReadByte());
			}
			return sb.ToString();
		}

@


1.82
log
@Added another overload of the public API Module.__GetSectionInfo() that returns more information about the section.
@
text
@d98 1
a98 1
		internal ModuleReader(AssemblyReader assembly, Universe universe, Stream stream, string location)
d103 1
a103 1
			Read(stream);
d111 1
a111 1
		private void Read(Stream stream)
d114 1
a114 1
			peFile.Read(br);
@


1.81
log
@Added new public API Module.__ResolveTypeSpecCustomModifiers() to resolve the (useless) custom modifiers that can be put on TypeSpecs.
@
text
@d1158 1
a1158 1
		public override bool __GetSectionInfo(int rva, out string name, out int characteristics)
d1160 1
a1160 1
			return peFile.GetSectionInfo(rva, out name, out characteristics);
@


1.80
log
@Regression fix. The AssemblyNames returned by Module.__GetReferencedAssemblies() didn't have the ContentType set for windowruntime assembly references.
@
text
@d2 1
a2 1
  Copyright (C) 2009-2012 Jeroen Frijters
d762 10
@


1.79
log
@Implemented Universe.ResolvedMissingMember event for fields, methods and properties.
@
text
@d1051 1
a1051 1
				name.Flags = (AssemblyNameFlags)AssemblyRef.records[i].Flags;
@


1.78
log
@Added Universe.ResolvedMissingMember event.
@
text
@d812 1
a812 1
								?? universe.GetMissingMethodOrThrow(type, name, methodSig);
d862 1
a862 1
					return universe.GetMissingFieldOrThrow(type, name, fieldSig);
d881 1
a881 1
					return universe.GetMissingMethodOrThrow(type, name, methodSig);
@


1.77
log
@Changed type name parser to use Module as context, instead of Assembly.
@
text
@d391 1
a391 1
								typeRefs[index] = assembly.ResolveType(typeName);
d398 1
a398 1
								typeRefs[index] = outer.ResolveNestedType(typeName);
d421 1
a421 1
								typeRefs[index] = module.FindType(typeName) ?? module.universe.GetMissingTypeOrThrow(module, null, typeName);
d1111 1
a1111 1
					return ResolveAssemblyRef((implementation & 0xFFFFFF) - 1).ResolveType(typeName).SetMetadataTokenForMissing(token, flags);
d1113 1
a1113 1
					return ResolveExportedType((implementation & 0xFFFFFF) - 1).ResolveNestedType(typeName).SetMetadataTokenForMissing(token, flags);
d1116 1
a1116 1
					return module.FindType(typeName) ?? module.universe.GetMissingTypeOrThrow(module, null, typeName).SetMetadataTokenForMissing(token, flags);
@


1.76
log
@Fixed regression introduced in recent change that introduced UniverseOptions.MetadataOnly. A ModuleReader can be constructed with a null universe.
@
text
@d523 1
a523 1
			return universe.Load(name, this.Assembly, true);
@


1.75
log
@- Added UniverseOptions.MetadataOnly.
- Added comment describing UniverseOptions.
- Made user string heap loading lazy.
@
text
@d101 1
a101 1
			this.stream = universe.MetadataOnly ? null : stream;
@


1.74
log
@Made authenticode support optional because mcs can't depend on System.Security.dll. To disable it define NO_AUTHENTICODE.
@
text
@d57 1
a57 1
		internal readonly Stream stream;
a65 1
		private byte[] userStringHeap;
d67 3
d101 1
a101 1
			this.stream = stream;
d103 1
a103 1
			Read();
d111 1
a111 1
		private void Read()
d123 1
a123 1
						stringHeap = ReadHeap(stream, sh);
d126 1
a126 1
						blobHeap = ReadHeap(stream, sh);
d129 2
a130 1
						userStringHeap = ReadHeap(stream, sh);
d133 1
a133 1
						guidHeap = ReadHeap(stream, sh);
d210 1
a210 1
		private byte[] ReadHeap(Stream stream, StreamHeader sh)
d212 2
a213 2
			byte[] buf = new byte[sh.Size];
			stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaData.VirtualAddress + sh.Offset), SeekOrigin.Begin);
d228 10
a237 1
			stream.Seek(peFile.RvaToFileOffset((uint)rva), SeekOrigin.Begin);
d346 4
d351 1
a351 1
				int len = ReadCompressedUInt(userStringHeap, ref index) & ~1;
d355 1
a355 1
					char ch = (char)(userStringHeap[index + i] | userStringHeap[index + i + 1] << 8);
d1241 4
a1244 1
			stream.Close();
d1286 1
a1286 1
			return Authenticode.GetSignerCertificate(stream);
@


1.73
log
@Added Type.__IsTypeForwarder property to let mcs distinguish between "normal" missing types and forwarded missing types.
@
text
@d1264 1
d1269 1
@


1.72
log
@Simplified LazyForwardType resolution to reuse ResolveExportedType() and thus always set the metadata token for forwarded missing types.
@
text
@d1091 1
d1095 1
a1095 1
					return ResolveAssemblyRef((implementation & 0xFFFFFF) - 1).ResolveType(typeName).SetMetadataTokenForMissing(token);
d1097 1
a1097 1
					return ResolveExportedType((implementation & 0xFFFFFF) - 1).ResolveNestedType(typeName).SetMetadataTokenForMissing(token);
d1100 1
a1100 1
					return module.FindType(typeName) ?? module.universe.GetMissingTypeOrThrow(module, null, typeName).SetMetadataTokenForMissing(token);
@


1.71
log
@Fixed ExportedType resolver to support types defined in another module in this assembly.
@
text
@d82 1
a82 1
			private readonly int assemblyRef;
d85 1
a85 1
			internal LazyForwardedType(int assemblyRef)
d87 1
a87 1
				this.assemblyRef = assemblyRef;
d90 1
a90 1
			internal Type GetType(ModuleReader module, TypeName typeName)
d92 1
a92 10
				if (type == null)
				{
					Assembly asm = module.ResolveAssemblyRef(assemblyRef);
					type = asm.ResolveType(typeName);
					if (type == null)
					{
						throw new TypeLoadException(typeName.ToString());
					}
				}
				return type;
d265 1
a265 1
						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
d563 1
a563 1
					return fw.GetType(this, typeName);
d583 1
a583 1
					return forwardedTypes[name].GetType(this, name);
@


1.70
log
@Bug fix. ModuleReader.ResolveMember() should support types. Thanks to Jb Evain for finding this.
@
text
@d1106 3
d1110 1
a1110 1
					throw new NotImplementedException();
@


1.69
log
@Small optimization to table record allocation. Thanks to Marek for the pointer.
@
text
@d619 4
@


1.68
log
@Renamed methods that deal with unsigned compressed integers to *CompressedUInt instead of *CompressedInt.
@
text
@a200 4
				else if (tables[i] != null)
				{
					tables[i].RowCount = 0;
				}
@


1.67
log
@Added (old) API Module.GetSignerCertificate().
@
text
@d304 1
a304 1
		private static int ReadCompressedInt(byte[] buffer, ref int offset)
d327 1
a327 1
			int len = ReadCompressedInt(blobHeap, ref blobIndex);
d348 1
a348 1
				int len = ReadCompressedInt(userStringHeap, ref index) & ~1;
@


1.66
log
@Bug fix. Ignore unknown metadata streams instead of throwing a BadImageFormatException. The CLR ignores these streams as well and some obfuscators add them.
@
text
@d1268 5
@


1.65
log
@Minor refactoring of Module.ResolveType(). Moved the wrapping of the type arrays into an IGenericContext up into Module.
@
text
@d147 3
a149 1
						throw new BadImageFormatException("Unsupported stream: " + sh.Name);
@


1.65.2.1
log
@Changes:
- Set version to 7.2.4630.2.
- Bug fix. Class.forName("") should not throw System.ArgumentException.
- Bug fix. Transient field modifier should be retained on literal fields.
- Bug fix. Field.getModifiers() should only return the relevant modifiers.
- IKVM.Reflection: Bug fix. Ignore unknown metadata streams.
- IKVM.Reflection: Bug fix. Set AddressOfRawData in IMAGE_DEBUG_DIRECTORY.
@
text
@d147 1
a147 3
						// we ignore unknown streams, because the CLR does so too
						// (and some obfuscators add bogus streams)
						break;
@


1.65.2.2
log
@Backported fixes for rc 3.
- Bug fix. Off-by-one error in local ref index reusing. Fix for bug #3575555.
- Bug fix. Don't try to inject DynamicMethod in array types (applies to array.clone() method for MethodHandles).
- IKVM.Reflection: Bug fix. ModuleReader.ResolveMember() should support types. Thanks to Jb Evain for finding this.
- IKVM.Reflection: Bug fix. While reading the Cecil source I realized that array bounds are signed.
- IKVM.Reflection: Bug fix. LocalBuilder should extend LocalVariableInfo.
- IKVM.Reflection: Implemented LocalVariableInfo.ToString().
@
text
@d304 1
a304 1
		private static int ReadCompressedUInt(byte[] buffer, ref int offset)
d327 1
a327 1
			int len = ReadCompressedUInt(blobHeap, ref blobIndex);
d348 1
a348 1
				int len = ReadCompressedUInt(userStringHeap, ref index) & ~1;
a622 4
				case TypeRefTable.Index:
				case TypeDefTable.Index:
				case TypeSpecTable.Index:
					return ResolveType(metadataToken, genericTypeArguments, genericMethodArguments);
@


1.64
log
@Added new API MethodInfo.__TryGetImplMap().
@
text
@d359 1
a359 1
		internal Type ResolveType(int metadataToken, IGenericContext context)
a487 12
		public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
		{
			if ((metadataToken >> 24) == TypeSpecTable.Index)
			{
				return ResolveType(metadataToken, new GenericContext(genericTypeArguments, genericMethodArguments));
			}
			else
			{
				return ResolveType(metadataToken, null);
			}
		}

a694 22
		private sealed class GenericContext : IGenericContext
		{
			private readonly Type[] genericTypeArguments;
			private readonly Type[] genericMethodArguments;

			internal GenericContext(Type[] genericTypeArguments, Type[] genericMethodArguments)
			{
				this.genericTypeArguments = genericTypeArguments;
				this.genericMethodArguments = genericMethodArguments;
			}

			public Type GetGenericTypeArgument(int index)
			{
				return genericTypeArguments[index];
			}

			public Type GetGenericMethodArgument(int index)
			{
				return genericMethodArguments[index];
			}
		}

@


1.63
log
@Added new .NET 4.5 API Type.IsConstructedGenericType.
@
text
@d282 1
a282 1
		internal string GetString(int index)
@


1.62
log
@Bug fix. Module.GetManifestResourceStream() should return null (instead of throwing FileNotFoundException) for non-existing resource names.
@
text
@d839 1
a839 1
						else if (type.IsGenericTypeInstance)
@


1.61
log
@Implemented Module.GetManifestResourceStream() for file and forwarded resources.
@
text
@d1032 1
a1032 1
			throw new FileNotFoundException();
@


1.60
log
@Added support for manifest resources that are forwarded to another assembly.
@
text
@d997 28
a1024 1
						throw new NotImplementedException();
@


1.59
log
@Added support for case-insensitive type lookup.
@
text
@d505 1
a505 1
		private Assembly ResolveAssemblyRef(int index)
d977 7
a983 1
					return new ManifestResourceInfo(this, i);
@


1.58
log
@New API. Added Module.__DllCharacteristics and ModuleBuilder.__DllCharacteristics properties to get and set image DLL characteristics flags.
@
text
@d592 20
@


1.57
log
@New API. Made ModuleBuilder.__FileAlignment writeable.
@
text
@d1233 5
@


1.56
log
@Marked ModuleBuilder.__SetStackReserve() obsolete and made ModuleBuilder.__StackReserve property writeable to be consistent with __ImageBase property.
@
text
@d1223 1
a1223 1
		protected override long  GetStackReserveImpl()
d1228 1
a1228 1
		public override int __FileAlignment
d1230 1
a1230 1
			get { return (int)peFile.OptionalHeader.FileAlignment; }
@


1.55
log
@Generalized sorted metadata table lookups with binary search.
@
text
@d1223 1
a1223 1
		public override long __StackReserve
d1225 1
a1225 1
			get { return (long)peFile.OptionalHeader.SizeOfStackReserve; }
@


1.54
log
@Use binary search in custom attribute lookup.
@
text
@d191 1
a191 1
			sortedTableMask = br.ReadUInt64();
d196 1
@


1.53
log
@Added Module.__ImageRuntimeVersion API.
@
text
@d191 1
a191 1
			/*ulong Sorted =*/ br.ReadUInt64();
@


1.52
log
@- Added Module.__EnumerateCustomAttributeTable() API.
- Removed Module.__GetDeclarativeSecurityFor() API.
- Added CustomAttributeData.__Parent API.
@
text
@d1095 1
a1095 1
		internal string ImageRuntimeVersion
@


1.51
log
@Fix to throw proper exception when wrong metadata token is passed to Module.Resolve* methods.
@
text
@d1199 1
a1199 2
						ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
						list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
@


1.50
log
@Fixed regression introduced with AssemblyName rewrite. The AssemblyName returned from __GetReferencedAssemblies() should include an empty public key token if the referenced assembly is not strong named.
@
text
@d2 1
a2 1
  Copyright (C) 2009-2011 Jeroen Frijters
d342 1
a342 1
					throw new ArgumentOutOfRangeException();
d360 11
a370 1
			switch (metadataToken >> 24)
d372 8
a379 4
				case TypeDefTable.Index:
					PopulateTypeDef();
					return typeDefs[(metadataToken & 0xFFFFFF) - 1];
				case TypeRefTable.Index:
d381 16
a396 9
						if (typeRefs == null)
						{
							typeRefs = new Type[TypeRef.records.Length];
						}
						int index = (metadataToken & 0xFFFFFF) - 1;
						if (typeRefs[index] == null)
						{
							int scope = TypeRef.records[index].ResolutionScope;
							switch (scope >> 24)
d398 4
a401 8
								case AssemblyRefTable.Index:
									{
										Assembly assembly = ResolveAssemblyRef((scope & 0xFFFFFF) - 1);
										TypeName typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
										typeRefs[index] = assembly.ResolveType(typeName);
										break;
									}
								case TypeRefTable.Index:
d403 1
a403 4
										Type outer = ResolveType(scope, null);
										TypeName typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
										typeRefs[index] = outer.ResolveNestedType(typeName);
										break;
d405 1
a405 2
								case ModuleTable.Index:
								case ModuleRefTable.Index:
d407 1
a407 19
										Module module;
										if (scope >> 24 == ModuleTable.Index)
										{
											if (scope == 0 || scope == 1)
											{
												module = this;
											}
											else
											{
												throw new NotImplementedException("self reference scope?");
											}
										}
										else
										{
											module = ResolveModuleRef(ModuleRef.records[(scope & 0xFFFFFF) - 1]);
										}
										TypeName typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
										typeRefs[index] = module.FindType(typeName) ?? module.universe.GetMissingTypeOrThrow(module, null, typeName);
										break;
d409 8
a416 2
								default:
									throw new NotImplementedException("ResolutionScope = " + scope.ToString("X"));
d418 2
a419 2
						}
						return typeRefs[index];
d421 15
a435 1
				case TypeSpecTable.Index:
d437 1
a437 16
						if (typeSpecs == null)
						{
							typeSpecs = new Type[TypeSpec.records.Length];
						}
						int index = (metadataToken & 0xFFFFFF) - 1;
						Type type = typeSpecs[index];
						if (type == null)
						{
							TrackingGenericContext tc = context == null ? null : new TrackingGenericContext(context);
							type = Signature.ReadTypeSpec(this, ByteReader.FromBlob(blobHeap, TypeSpec.records[index]), tc);
							if (tc == null || !tc.IsUsed)
							{
								typeSpecs[index] = type;
							}
						}
						return type;
d439 6
a444 2
				default:
					throw new NotImplementedException(String.Format("0x{0:X}", metadataToken));
d591 5
d603 6
a608 1
					return GetMemberRef((metadataToken & 0xFFFFFF) - 1, genericTypeArguments, genericMethodArguments);
d612 2
a614 1
			throw new ArgumentOutOfRangeException();
d632 6
a637 1
			if ((metadataToken >> 24) == FieldTable.Index)
a638 1
				int index = (metadataToken & 0xFFFFFF) - 1;
d641 1
a641 1
			else if ((metadataToken >> 24) == MemberRefTable.Index)
d643 1
a643 1
				FieldInfo field = GetMemberRef((metadataToken & 0xFFFFFF) - 1, genericTypeArguments, genericMethodArguments) as FieldInfo;
d648 5
a653 1
			throw new ArgumentOutOfRangeException();
d710 6
a715 1
			if ((metadataToken >> 24) == MethodDefTable.Index)
a716 1
				int index = (metadataToken & 0xFFFFFF) - 1;
d719 1
a719 1
			else if ((metadataToken >> 24) == MemberRefTable.Index)
a720 1
				int index = (metadataToken & 0xFFFFFF) - 1;
d726 1
d728 1
a728 1
			else if ((metadataToken >> 24) == MethodSpecTable.Index)
a729 1
				int index = (metadataToken & 0xFFFFFF) - 1;
d734 4
a737 1
			throw new ArgumentOutOfRangeException();
d742 6
a747 1
			if ((metadataToken >> 24) == MemberRefTable.Index)
a748 1
				int index = (metadataToken & 0xFFFFFF) - 1;
d752 1
a752 1
			else if ((metadataToken >> 24) == MethodDefTable.Index)
d760 4
a763 1
			throw new ArgumentOutOfRangeException();
d899 6
a904 1
		internal new ByteReader ResolveSignature(int metadataToken)
d906 2
a907 1
			if ((metadataToken >> 24) == StandAloneSigTable.Index)
d909 6
a914 2
				int index = (metadataToken & 0xFFFFFF) - 1;
				return ByteReader.FromBlob(blobHeap, StandAloneSig.records[index]);
a915 1
			throw new ArgumentOutOfRangeException();
d920 9
a928 1
			return MethodSignature.ReadStandAloneMethodSig(this, ResolveSignature(metadataToken), new GenericContext(genericTypeArguments, genericMethodArguments));
@


1.49
log
@Added Module.__EntryPointRVA and Module.__EntryPointToken properties.
@
text
@d953 4
@


1.48
log
@Added Module.__FileAlignment property.
@
text
@d1175 10
@


1.47
log
@Added new overload of __ResolveOptionalParameterTypes() that supports resolving generic type parameters and custom modifiers.
@
text
@d1170 5
@


1.46
log
@Implemented most of AssemblyName (except parsing) without dependency on System.Reflection.AssemblyName.
@
text
@d711 1
a711 1
		public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
d717 1
a717 1
				return Signature.ReadOptionalParameterTypes(this, GetBlob(sig));
d724 1
@


1.45
log
@Added support for PortableExecutableKinds.Preferred32Bit.
@
text
@d954 1
a954 1
					name.CultureInfo = new System.Globalization.CultureInfo(GetString(AssemblyRef.records[i].Culture));
d958 1
a958 1
					name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
@


1.44
log
@Fixed CliHeader read bug. Thanks to Oleg Mihailik for reporting this.
@
text
@d1088 1
a1088 1
			if ((cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_32BITREQUIRED) != 0)
d1090 10
a1099 1
				peKind |= PortableExecutableKinds.Required32Bit;
@


1.43
log
@Reverted Universe.ForceAssemblyResolve patch and introduced Module.__ResolveReferencedAssemblies() to allow custom assembly reference resolution.
@
text
@d124 1
a124 1
			stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA), SeekOrigin.Begin);
d143 1
a143 1
						stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
d220 1
a220 1
			stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
d918 1
a918 1
					SeekRVA((int)cliHeader.ResourcesRVA + ManifestResource.records[i].Offset);
@


1.42
log
@Added Module.__ReadDataFromRVA() to make it more convenient to read data based on rva.
@
text
@d970 15
@


1.41
log
@When missing member resolution is enabled, missing members should always be resolved as missing, instead of trying to resolve base class members first.
@
text
@d1047 19
@


1.40
log
@Added API extension Module.__GetSectionInfo() to query the section information based on an RVA.
@
text
@d826 2
a827 1
				do
d829 11
a839 8
					FieldInfo field = type.FindField(name, fieldSig);
					if (field != null)
					{
						return field;
					}
					type = type.BaseType;
				} while (type != null);
				return universe.GetMissingFieldOrThrow(org, name, fieldSig);
d845 2
a846 1
				do
d848 11
a858 8
					MethodBase method = type.FindMethod(name, methodSig);
					if (method != null)
					{
						return method;
					}
					type = type.BaseType;
				} while (type != null);
				return universe.GetMissingMethodOrThrow(org, name, methodSig);
@


1.39
log
@- Added API extension to query the types exported from a module.
- Fixed __AddTypeForwarder() to handle missing types.
@
text
@d1034 5
@


1.38
log
@Support roundtripping hash in AssemblyRef record.
@
text
@d982 26
@


1.37
log
@Added API extension to get/set stack reserve.
@
text
@d952 4
@


1.36
log
@Bug fix. String literals that are invalid UTF-16 should not be "corrected".
@
text
@d1078 5
@


1.35
log
@Unified type resolving for Module and ModuleRef cases and added support for resolving missing types.
@
text
@d346 7
a352 1
				str = Encoding.Unicode.GetString(userStringHeap, index, len);
@


1.34
log
@Added API extension Module.__GetReferencedTypes() to get the TypeRef table contents.
@
text
@a385 6
									if (scope != 0 && scope != 1)
									{
										throw new NotImplementedException("self reference scope?");
									}
									typeRefs[index] = FindType(GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName));
									break;
d388 13
a400 4
										Module module = ResolveModuleRef(ModuleRef.records[(scope & 0xFFFFFF) - 1]);
										TypeName typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
										Type type = module.FindType(typeName);
										if (type == null)
d402 1
a402 1
											throw new TypeLoadException(String.Format("Type '{0}' not found in module '{1}'", typeName, module.Name));
d404 2
a405 1
										typeRefs[index] = type;
@


1.33
log
@Added API extension __ImageBase to Module.
@
text
@d958 10
@


1.32
log
@Added API extensions to get and add referenced modules.
@
text
@d1053 5
@


1.31
log
@Changed member resolution to resolve members on generic type definition, instead of the instance and then create the corresponding member of the generic instance, this allows generic member resolution to work for missing types.
@
text
@d948 10
@


1.30
log
@Added support for missing fields.
@
text
@d756 1
a756 1
						memberRefs[index] = ResolveTypeMemberRef(ResolveModuleType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
d760 1
a760 1
						memberRefs[index] = ResolveTypeMemberRef(ResolveType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
d763 28
a790 1
						return ResolveTypeMemberRef(ResolveType(owner, genericTypeArguments, genericMethodArguments), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
d810 1
a810 1
		private MemberInfo ResolveTypeMemberRef(Type type, string name, ByteReader sig, Type[] genericTypeArguments, Type[] genericMethodArguments)
a811 9
			IGenericContext context;
			if ((genericTypeArguments == null && genericMethodArguments == null) || type.IsGenericType)
			{
				context = type;
			}
			else
			{
				context = new GenericContext(genericTypeArguments, genericMethodArguments);
			}
d815 1
a815 1
				FieldSignature fieldSig = FieldSignature.ReadSig(this, sig, context);
d830 1
a830 1
				MethodSignature methodSig = MethodSignature.ReadSig(this, sig, context);
@


1.29
log
@Added limited support for #- metadata stream ("uncompressed" table heap). ParamPtr table is not yet implemented.
@
text
@d807 1
a807 1
				throw new MissingFieldException(org.ToString(), name);
@


1.29.2.1
log
@Back ported fixes:
- Bug fix. BeginExceptFilterBlock() should behave like BeginCatchBlock(), not BeginFinallyBlock().
- Fix for http://gcc.gnu.org/bugzilla/show_bug.cgi?id=48131.
- Bug fix. Support loading resources from assemblies added to the boot classloader (with ikvm.runtime.Startup.addBootClassPathAssemby()).
- Type parameters should be separated by commas.
- Only the assembly name should escape the ']' characters.
- Bug fix. <Module> should not extend object.
- Bug fix. String literals that are invalid UTF-16 should not be "corrected".
- Bug fix. MaxStack returned incorrect value for tiny header methods.
- Fix. Module does not inherit members from Object.
- Align initialized data arrays.
- Align managed resources on 8 bytes.
@
text
@d346 1
a346 7
				StringBuilder sb = new StringBuilder(len / 2);
				for (int i = 0; i < len; i += 2)
				{
					char ch = (char)(userStringHeap[index + i] | userStringHeap[index + i + 1] << 8);
					sb.Append(ch);
				}
				str = sb.ToString();
@


1.29.2.2
log
@Updated version to 0.46.0.5 and backported bug fixes:
- IKVM.Reflection should ignore unknown metadata streams.
- Off-by-one error in local ref index reusing. Fix for bug #3575555.
- Interface mappings can be "incomplete". Fix for bug #3581564.
- The local variable state at the end of an exception block (if the last instruction is a local variable store) needs to be merged into the exception handler state.
- Local variable analysis for finally blocks was incorrect. Fixes bug #3600788.
- Don't implement interfaces that aren't accessible.
- Updated Mono workaround for Mono 3.0.x.
- Check for supported delegate signatures should detect pointers inside byref and array types and return type should be checked as well.
- Fake nested types should have Static modifier set in innerclasses attribute. Fixes scala compiler interop issue. Thanks to Michael Bayne for reporting this.
- ikvmstub -skiperror should also skip errors during WriteClass.
- An ITEMIDLIST should be freed using CoTaskMemFree.
- String.CaseInsensitiveComparator inner class should be acknowledged by String.
- Fixed the SHFILEINFO declaration. Thanks to Andras Kovacs for reporting this.
- Fixed race condition in MethodWrapper.ResolveMethod().
@
text
@d147 1
a147 3
						// we ignore unknown streams, because the CLR does so too
						// (and some obfuscators add bogus streams)
						break;
@


1.28
log
@Avoid compiler warnings about unused locals.
@
text
@d142 1
d211 4
@


1.27
log
@Metadata reading performance optimization. Inspired by Marek.
@
text
@d163 3
a165 3
			ushort MajorVersion = br.ReadUInt16();
			ushort MinorVersion = br.ReadUInt16();
			uint Reserved = br.ReadUInt32();
d169 1
a169 1
			ushort Flags = br.ReadUInt16();
d183 1
a183 1
			uint Reserved0 = br.ReadUInt32();
d188 1
a188 1
			byte Reserved7 = br.ReadByte();
d190 1
a190 1
			ulong Sorted = br.ReadUInt64();
@


1.26
log
@Added (partial) support for missing member resolution in existing types.
@
text
@d202 1
a202 1
			MetadataReader mr = new MetadataReader(this, br, HeapSizes);
@


1.25
log
@Add support for reflecting on assemblies without loading mscorlib (or with partial mscorlib) when missing type resolution is enabled.
@
text
@d817 1
a817 1
				throw new MissingMethodException(org.ToString(), name);
@


1.24
log
@More type name fixes. This time to support the fact that the CLR and Mono both treat TypeNamespace and TypeName as separate names and do not consider fullName to be relevant.
@
text
@d370 1
a370 6
										Type type = assembly.ResolveType(typeName);
										if (type == null)
										{
											throw new TypeLoadException(String.Format("Type '{0}' not found in assembly '{1}'", typeName, assembly.FullName));
										}
										typeRefs[index] = type;
@


1.23
log
@Added support for magic missing assemblies that resolve missing types to allow (some) reflection on assemblies with missing dependencies.
@
text
@d2 1
a2 1
  Copyright (C) 2009-2010 Jeroen Frijters
d77 2
a78 2
		private Dictionary<string, Type> types = new Dictionary<string, Type>();
		private Dictionary<string, LazyForwardedType> forwardedTypes = new Dictionary<string, LazyForwardedType>();
d90 1
a90 1
			internal Type GetType(ModuleReader module, string typeName)
d95 5
a99 1
					type = asm.GetType(typeName, true);
d258 1
a258 1
					else
d260 1
a260 1
						types.Add(type.FullName, type);
d269 2
a270 2
						string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
						forwardedTypes.Add(TypeNameParser.Escape(typeName), new LazyForwardedType((implementation & 0xFFFFFF) - 1));
d369 2
a370 1
										Type type = assembly.ResolveType(GetString(TypeRef.records[index].TypeNameSpace), GetString(TypeRef.records[index].TypeName));
a372 1
											string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
d381 2
a382 1
										typeRefs[index] = outer.ResolveNestedType(GetString(TypeRef.records[index].TypeNameSpace), GetString(TypeRef.records[index].TypeName));
d390 1
a390 1
									typeRefs[index] = GetType(TypeNameParser.Escape(GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName)));
d395 2
a396 2
										string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
										Type type = module.GetType(TypeNameParser.Escape(typeName));
d485 1
a485 1
		private string GetTypeName(int typeNamespace, int typeName)
d487 1
a487 8
			if (typeNamespace == 0)
			{
				return GetString(typeName);
			}
			else
			{
				return GetString(typeNamespace) + "." + GetString(typeName);
			}
d562 1
a562 1
		internal override Type GetTypeImpl(string typeName)
d982 1
a982 1
			string typeName;
d986 1
a986 1
					typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHere";
d989 1
a989 1
					typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereM";
d992 1
a992 1
					typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereS";
d996 1
a996 1
					typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereSM";
@


1.22
log
@Fix. Type names in forwardedTypes dictionary should be escaped.
@
text
@d365 1
a365 2
										string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
										Type type = assembly.GetType(TypeNameParser.Escape(typeName));
d368 1
d377 1
a377 2
										string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
										typeRefs[index] = outer.GetNestedTypeCorrectly(typeName);
@


1.21
log
@Fixed resolving nested type by name.
@
text
@d266 1
a266 1
						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
@


1.20
log
@Fix. [Assembly|Module].GetType() expect an escaped name.
@
text
@d377 2
a378 1
										typeRefs[index] = outer.GetNestedType(GetString(TypeRef.records[index].TypeName), BindingFlags.Public | BindingFlags.NonPublic);
@


1.19
log
@Fixed copy/paste bug. A typeref pointing to ModuleRef should resolve the type in that module, not the assembly.
@
text
@d366 1
a366 1
										Type type = assembly.GetType(typeName);
d385 1
a385 1
									typeRefs[index] = GetType(GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName));
d391 1
a391 1
										Type type = module.GetType(typeName);
@


1.18
log
@On Marek's request changed __TypeName property to __ReadTypeName() to avoid creating new strings.
@
text
@d391 1
a391 1
										Type type = assembly.GetType(typeName);
@


1.17
log
@Added CustomAttributeData.__TypeName property to allow the custom attribute type name to be queried without requiring the assembly containing the type to be present.
@
text
@d480 1
a480 1
		internal string GetTypeName(int typeNamespace, int typeName)
@


1.16
log
@Added Module.__GetReferencedAssemblies() API.
@
text
@d480 1
a480 1
		private string GetTypeName(int typeNamespace, int typeName)
@


1.15
log
@Removed NotImplementedException for unsorted GenericParam table, because we don't really care.
@
text
@d893 1
a893 1
		internal AssemblyName[] GetReferencedAssemblies()
@


1.14
log
@Added API to query placeholder assembly custom attributes in a module.
@
text
@a186 6
			// we require that the GenericParam table is sorted
			const ulong mask = (1UL << GenericParamTable.Index);
			if ((Valid & Sorted & mask) != (Valid & mask))
			{
				throw new NotImplementedException();
			}
@


1.13
log
@Added AssemblyBuilder.__AddModule() to allow pre-existing modules to be linked in.
@
text
@d988 35
@


1.12
log
@Pass the outer context to ReadSig when the member's declaring type isn't generic, to support the usage of generic parameters in array signatures (when you call one of the runtime synthesized array methods on a generic type array e.g. T[] array; array.Set(0, default(T));)
@
text
@d59 1
a59 1
		private readonly AssemblyReader assembly;
d147 5
d992 6
@


1.11
log
@Throw better exceptions if MemberRef can't be resolved.
@
text
@d759 1
a759 1
						memberRefs[index] = ResolveTypeMemberRef(ResolveModuleType(owner), name, ByteReader.FromBlob(blobHeap, sig));
d763 1
a763 1
						memberRefs[index] = ResolveTypeMemberRef(ResolveType(owner), name, ByteReader.FromBlob(blobHeap, sig));
d766 1
a766 1
						return ResolveTypeMemberRef(ResolveType(owner, genericTypeArguments, genericMethodArguments), name, ByteReader.FromBlob(blobHeap, sig));
d786 1
a786 1
		private MemberInfo ResolveTypeMemberRef(Type type, string name, ByteReader sig)
d788 9
d800 1
a800 1
				FieldSignature fieldSig = FieldSignature.ReadSig(this, sig, type);
d815 1
a815 1
				MethodSignature methodSig = MethodSignature.ReadSig(this, sig, type);
@


1.10
log
@A TypeRef with a null ResolutionScope is legal and refers to an entry in the export table of the current module.
@
text
@d790 1
d801 1
d805 1
d816 1
a817 1
			throw new BadImageFormatException();
@


1.9
log
@Cache assemblyRefs, instead of constructing the refnames and going thru Load every time.
@
text
@d382 1
a382 1
									if (scope != 1)
@


1.8
log
@Added RawModule to allow user code to load and inspect a module without it becoming part of the universe and also import it efficiently into the universe.
@
text
@d70 1
d94 1
a94 1
					Assembly asm = module.ResolveAssemblyRef(ref module.AssemblyRef.records[assemblyRef]);
d365 1
a365 1
										Assembly assembly = ResolveAssemblyRef(ref AssemblyRef.records[(scope & 0xFFFFFF) - 1]);
d493 14
a506 1
		private Assembly ResolveAssemblyRef(ref AssemblyRefTable.Record rec)
@


1.7
log
@Fixed GetReferencedAssemblies() to set AssemblyName.CultureInfo when it's the invariant culture and to set AssemblyName.Flags.
@
text
@d956 5
@


1.6
log
@Fixed AssemblyName.GetAssemblyName() to throw the proper exceptions (and by consequence Universe.LoadFile() now also throws the proper exceptions, module a race condition).
@
text
@d897 5
@


1.5
log
@Made forwarded type resolution lazy.
@
text
@d106 5
a110 1
			this.assembly = assembly ?? new AssemblyReader(location, this);
@


1.4
log
@Implemented ModuleRef ResolutionScope for TypeRef.
@
text
@d2 1
a2 1
  Copyright (C) 2009 Jeroen Frijters
d77 22
d255 1
a255 1
				// add forwarded types to our types dictionary (because Module.GetType(string) should return them)
d262 1
a262 2
						Assembly asm = ResolveAssemblyRef(ref AssemblyRef.records[(implementation & 0xFFFFFF) - 1]);
						types.Add(typeName, asm.GetType(typeName, true));
d551 8
a558 1
			types.TryGetValue(typeName, out type);
@


1.3
log
@Check Sorted flags only for the tables we really require to be sorted (currently only GenericParam).
@
text
@d362 12
d404 11
@


1.2
log
@Removed UTF-8 byte order marks.
@
text
@d155 3
a157 1
			if ((Valid & Sorted) != (Valid & 0x0016003301FA00L))
@


1.1
log
@New IKVM.Reflection implementation.
@
text
@d1 1
a1 1
﻿/*
@

